{"cell_type":{"8d87ed97":"code","e9a69226":"code","6b31392b":"code","e0b682cd":"code","b9a95e73":"code","26078994":"code","9c109df3":"code","f1002ab2":"code","2007772b":"code","3ccd8562":"code","63396155":"code","03a299e1":"code","8e665306":"code","5200d1de":"code","85357398":"code","5d3fadd7":"code","53b006c7":"code","b380244c":"code","6be10f28":"code","796d8224":"code","bf90f654":"code","59124d14":"code","0becf382":"markdown","670da1b7":"markdown","9d7e3afc":"markdown","987b2ba2":"markdown","208f491b":"markdown","489df035":"markdown","3a4f284f":"markdown","53b34fed":"markdown","15aaf2e6":"markdown","663915fa":"markdown","c8d29659":"markdown","11f8927a":"markdown","2b7fed21":"markdown","5d67202d":"markdown","337d1f67":"markdown","a195de27":"markdown","ce2d5d88":"markdown"},"source":{"8d87ed97":"import copy\nimport random","e9a69226":"def coupLicite(config, trouJoue):\n    if (config[trouJoue] > 0):\n        return True\n    else : \n        return False\n    \ndef coupsLicites(config, joueur):\n    decalage = 0\n    resultat = []\n    if(joueur == 2) : \n        decalage = 4\n    for indice in range(decalage, decalage + 4):\n        if coupLicite(config, indice) : \n            resultat.append(indice)\n    return resultat\n\n\n# transformation de estCoupFinal(v7) en estAffame() et partieFinie() :\n\n# estAffame() retourne 1 si le joueur est affame, 0 sinon.\n\ndef estAffame(config, joueur):\n    n = len(coupsLicites(config, joueur))\n    if (n == 0) : \n        return 1\n    return 0\n\n# partieFinie() retourne 2 si joueurArbre a gagn\u00e9, \n# 1 si joueurArbre est affam\u00e9 dans la configuration config ou a perdu,\n# 0 sinon.\n\ndef partieFinie(config, scores):\n    if (scores[joueurArbre-1] >= scoreGagnant):\n        return 2\n    if (scores[joueurSuivant(joueurArbre)-1] >= scoreGagnant):\n        return 1\n    if estAffame(config, joueurArbre):\n        return 1\n    if estAffame(config, joueurSuivant(joueurArbre)):\n        return 2\n    else : \n        return 0 \n    \n    \ndef jouerCoup(configuration, trouJoue, lesScores):\n    config = copy.copy(configuration)\n    scores = copy.copy(lesScores)\n    if coupLicite(config, trouJoue) : \n        if (trouJoue < 4):\n            Joueur = 1\n        else :\n            Joueur = 2\n        regleBoucle = 0\n        nombreDeGrainesPosees = 0\n        if (config[trouJoue]>7):\n            regleBoucle = config[trouJoue]\/\/8\n        \n        nbGraines = config[trouJoue]\n        config[trouJoue] = 0\n        indice = trouJoue\n        for i in range(1,nbGraines+1) :\n            indice += 1\n            if (nombreDeGrainesPosees % 7 == 0 and nombreDeGrainesPosees > 0): \n                indice += 1\n            if (indice > 7) :\n                indice -= 8\n            config[indice] += 1\n            nombreDeGrainesPosees += 1\n\n        \n        terrainAdverse = False\n        if ((indice > 3 and Joueur == 1) or (indice < 4 and Joueur == 2)) :\n            terrainAdverse = True\n\n        while((config[indice] == 2 or config[indice] == 3) and terrainAdverse) :\n        \n            scores[Joueur-1] += config[indice]\n            config[indice] = 0\n            if (indice>0) :\n                indice -= 1\n            else :\n                indice = 7\n        \n            if not ((indice > 3 and Joueur == 1) or (indice < 4 and Joueur == 2)) :\n                terrainAdverse = False\n        return copy.deepcopy(config),copy.deepcopy(scores)\n        \n    else : \n        \n        return \"erreurJouerCoup\",\"erreur\"","6b31392b":"def meilleurChoix(liste) : \n    n = len(liste)\n    ratios = []*n\n    print(liste)\n    for i in range(n) : \n        if (liste[i][1]==0):\n            ratios[i]=0\n        else:\n            ratios[i] = liste[i][0]\/liste[i][1]\n    return indiceMax(ratios)\n        \ndef indiceMax(liste):\n    n = len(liste)\n    max = liste[0]\n    indmax = 0\n    for i in range(1,n):\n        if liste[i]>max : \n            max = liste[i]\n            indmax = i\n    return i\n\n\n# choixFilsMeilleurRatio() renvoie l'indice de listeIndicesFils (normalement non vide) au meilleur ratio.\ndef choixFilsMeilleurRatio(arbre, listeIndicesFils):\n    ratioMax = 0.0;\n    iMax = 404;\n    for i in listeIndicesFils:\n        sTot = simTot(arbre[i])\n        sVic = simVic(arbre[i])\n        if (sTot != 0):\n            ratio = sVic\/sTot\n        else:\n            ratio = 0\n        if (ratio >= ratioMax):\n            ratioMax = ratio\n            iMax = i\n    return iMax\n\n\n# entr\u00e9e= 1 ou 2 , sortie: 2 ou 1\ndef joueurSuivant(joueur):\n    return joueur*-1+3","e0b682cd":"#Noeud : [configuration, scores, indices fils, indice p\u00e8re, simulations victorieuses, simulations totales, personne devant jouer, partieFinie ? (2 pour joueurArbre a gagn\u00e9, 1 s'il a perdu, 0 si la partie n'est pas finie), dernier trou jou\u00e9]\ndef askConfig(Noeud):\n    return copy.copy(Noeud[0])\ndef askScores(Noeud):\n    return copy.copy(Noeud[1])\ndef indicesFils(Noeud):\n    return copy.copy(Noeud[2])\ndef ajouterIndiceFils(Noeud, iFils):\n    Noeud[2].append(iFils)\ndef indicePere(Noeud):\n    return Noeud[3]\ndef simVic(Noeud):\n    return Noeud[4]\ndef simTot(Noeud):\n    return Noeud[5]\ndef joueurDevantJouer(Noeud):\n    return Noeud[6]\ndef valPartieFinie(Noeud):\n    return Noeud[7]\ndef dernierTrouJoue(Noeud):\n    return Noeud[8]","b9a95e73":"global joueurArbre  #Utilis\u00e9 pour simulation()\nglobal scoreGagnant  #score \u00e0 atteindre pour gagner\nglobal configInit\nglobal scoresInit\n# global arbre ?\nglobal probaChoixExploration\n\njoueurArbre = 2\nscoreGagnant = 10\nconfigInit = [4,4,4,4,4,4,4,4]\nscoresInit = [0,0]\nprobaChoixExploration = 0.75","26078994":"def creationArbre() : \n    arbre = []\n    racine = [copy.deepcopy(configInit),copy.deepcopy(scoresInit),[],-1, 0, 0, 1, 0, -800]\n    arbre.append(racine)\n    return arbre\n\n#Remplacement de estCoupFinal() par estAffame partieFinie()\ndef creationNouveauNoeud(arbre, config, scores, joueurDevantJouer, pere,dernierCoupJoue) :\n    noeud = [copy.deepcopy(config),copy.deepcopy(scores),[],pere, 0, 0, joueurDevantJouer, partieFinie(config, scores),dernierCoupJoue]\n    arbre.append(noeud)\n    # Mise \u00e0 jour des indices des fils du p\u00e8re\n    ajouterIndiceFils(arbre[pere],len(arbre)-1)\n    return arbre","9c109df3":"# Renvoie l'indice d'une feuille.\n\n# A chaque noeud o\u00f9 L'ORDI DOIT JOUER, on choisit le fils avec le meilleur ratio avec la proba probaChoixExploration. \n# Sinon, soit on choisit un fils parmi les autres fils, soit on cr\u00e9\u00e9 un nouveau fils si c'est possible d'en cr\u00e9er un nouveau.\n\ndef selection(arbre, iRacine):\n        i = iRacine\n #       print(arbre,i)\n        noeud = arbre[i]\n        listeIndicesFils = indicesFils(noeud)\n        \n #listeindicesfils est une copie ...pb?\n\n        while (listeIndicesFils != []):\n            r = random.random()\n            joueur = joueurDevantJouer(noeud)\n            filsMeilleurRatio = choixFilsMeilleurRatio(arbre,listeIndicesFils)\n            if (joueur == joueurArbre and r <= probaChoixExploration):\n                i = filsMeilleurRatio\n                \n            else :\n            # On choisit un fils au hasard, ou on cr\u00e9\u00e9 un autre fils diff\u00e9rent des autres fils. On choisit un fils de mani\u00e8re \u00e9quiprobable:\n                liste = copy.copy(listeIndicesFils)\n                n = len(liste)\n                r = random.random()\n                liste.remove(filsMeilleurRatio)\n                if (r <= 1\/n) :\n                    # On cr\u00e9\u00e9 un autre fils si c'est possible. C'est un choix \u00e9quiprobable \u00e0 choisir un autre fils parmi liste. Si liste est vide \u00e7a marche.\n                    config = askConfig(noeud)\n                    listeCoupsLicites = coupsLicites(config,joueur)\n                    if (len(listeCoupsLicites) == n):\n                        # Pas d'autres fils possible.\n                        i = random.choice(listeIndicesFils)\n                    else : \n                        # On cr\u00e9\u00e9 un fils diff\u00e9rent des fils existant\n                        scores = askScores(noeud)\n                        bool = 0\n                        for coup in listeCoupsLicites:\n                            configSuivante,scoresSuivants = jouerCoup(config, coup, scores)\n                            for iFils in listeIndicesFils :\n                                if not (compare(configSuivante, askConfig(arbre[iFils]))):\n                                    arbre = creationNouveauNoeud(arbre, copy.deepcopy(configSuivante), copy.deepcopy(scoresSuivants), joueurSuivant(joueur), i, coup)\n                                    i = len(arbre)-1\n                                    bool = 1\n                                    break\n                            if bool == 1 :\n                                break\n                else :\n                    # On choisit un fils parmi ceux qui n'ont pas le meilleur ratio si l'ordi doit jouer.\n                    # On choisit parmi tous les fils si ce n'est pas \u00e0 l'ordi de jouer\n                    if joueur == joueurArbre :\n                        i = random.choice(liste)\n                    else :\n                        i = random.choice(listeIndicesFils)\n            noeud = arbre[i]\n            listeIndicesFils = indicesFils(noeud)\n            \n        return arbre, i","f1002ab2":"random.random()","2007772b":"# Renvoie arbre et -1 si iFeuille correspond \u00e0 une fin de partie.\n# Sinon, expansion() cr\u00e9\u00e9 un fils 0\/0 \u00e0 la feuille, renvoie arbre et l'indice du fils dans l'arbre.\n# On pourra plus tard cr\u00e9er plusieurs fils et en choisir un.\n\ndef expansion(arbre, iFeuille):\n    noeudFeuille = arbre[iFeuille]\n    joueur = joueurDevantJouer(noeudFeuille)\n    configFeuille = copy.deepcopy(askConfig(noeudFeuille))\n    scoresConfig = copy.deepcopy(askScores(noeudFeuille))\n\n    val = partieFinie(configFeuille,scoresConfig)\n    if (val>0):\n        return arbre, -1\n    \n    listeCoupsLicites = coupsLicites(configFeuille,joueur)\n    #liste non vide\n    coup = random.choice(listeCoupsLicites)\n    configSuivante, scoresSuivants = jouerCoup(configFeuille, coup, scoresConfig)\n    arbre  = creationNouveauNoeud(arbre, copy.deepcopy(configSuivante), copy.deepcopy(scoresSuivants), joueurSuivant(joueur), iFeuille, coup)\n    \n    return arbre, len(arbre)-1","3ccd8562":"# Simulation() simule la partie au hasard depuis la configuration iFils jusqu'\u00e0 la fin, renvoie 1 pour une victoire du joueurArbre et 0 pour une d\u00e9faite.\n# On n'alterne pas l'arbre: victoire correspond \u00e0 la victoire du joueurArbre\n# Pour l'instant un joueur affam\u00e9 correspond \u00e0 une fin de partie et la d\u00e9faite du joueur affam\u00e9...\n\ndef simulation(arbre, iFils):\n    noeud = copy.deepcopy(arbre[iFils])\n    joueur = joueurDevantJouer(noeud)\n    scores = askScores(noeud)\n    config = askConfig(noeud)\n    valPartie = partieFinie(config, scores)\n    \n    while (valPartie == 0):\n\n        #choix du coup\n        ListecoupsLicites = coupsLicites(config, joueur)\n        coupJoue = random.choice(ListecoupsLicites) #choix au hasard\n        config, scores = jouerCoup(config, coupJoue, copy.copy(scores))\n\n        joueur = joueurSuivant(joueur)\n        valPartie = partieFinie(config, scores)\n        \n    return valPartie-1","63396155":"arbre = creationArbre()\nprint(arbre)\narbreDesequilibre = [[[3, 0, 3, 0, 4, 4, 4, 4], [0, 8], [], -1, 0, 0, 1, 0, -800]]","03a299e1":"simulation(arbre,0)","8e665306":"simulation(arbreDesequilibre,0)","5200d1de":"# Maj des ratios des noeuds situ\u00e9 entre les noeuds iFils et iRacine\n\ndef retropropagation(arbre, iFils, iRacine, victoire):\n    i= iFils\n    while (i >= iRacine) :\n        noeud = arbre[i]\n        noeud[4]+=victoire\n        noeud[5]+=1\n        i = noeud[3]\n    return arbre","85357398":"arbre = [[[4, 4, 4, 4, 4, 4, 4, 4], [0, 0], [1,2,3,4], -1, 4, 4, 1, 0, -800], [[5, 5, 4, 0, 0, 6, 6, 6], [0, 0], [], 0, 1, 1, 2, 0, 3], [[5, 1, 6, 5, 5, 5, 0, 5], [0, 0], [], 0, 1, 1, 2, 0, 1], [[1, 6, 6, 6, 5, 4, 4, 0], [0, 0], [], 0, 1, 1, 2, 0, 0], [[1, 6, 5, 5, 0, 5, 5, 5], [0, 0], [5], 0, 1, 1, 2, 0, 0],[[\"whatever\"],[\"ok\"],[],4,0,0]]\nprint(arbre)\nretropropagation(arbre, 5,0,0)","5d3fadd7":"# Renvoie l'indice du fils de arbre[iRacine] au meilleur ratio et l'indice SUR LE PLATEAU de ce coup.\n# Pour l'instant la partie se termine quand un adversaire est affam\u00e9...\n# Si tout va bien cette fonction n'est jamais appel\u00e9 si arbre[iRacine] n'a pas de fils\n\ndef choixCoup(arbre, iRacine):\n    listeIndicesFils = indicesFils(arbre[iRacine])\n    if listeIndicesFils == []:\n        # cas o\u00f9 on est arriv\u00e9 \u00e0 la toute fin de partie\n        print(\"erreur (synchronisation des scores ?)\")\n    else :\n        iMax = choixFilsMeilleurRatio(arbre, listeIndicesFils)\n    \n    #ensuite retrouver l'indice du plateau qu'on veut jouer\n    indicePlateau = dernierTrouJoue(arbre[iMax])\n    \n    return iMax, indicePlateau","53b006c7":"print(arbre)\nchoixCoup(arbre, 0)","b380244c":"# Compare deux configurations, renvoie 1 si elles sont identiques, 0 sinon.\n\ndef compare(config1, config2):\n    n = len(config1)\n    for i in range(0,n):\n        if (config1[i]!=config2[i]):\n            return False\n    return True\n\n\n\n# recherche l'indice de l'arbre correspondant \u00e0 la configuration identique \u00e0 plateau, parmi les fils de iRacine. \n# Cr\u00e9\u00e9 ce noeud (feuille) s'il n'existe pas.\n# \u00c0 utiliser apr\u00e8s le tour du joueur r\u00e9el.\n# PROBLEME sur les joueurs\n\ndef rechercheRacine(plateau, arbre, iRacine):\n    noeud = arbre[iRacine]\n    listeIndicesFils = indicesFils(noeud)\n    for iFils in listeIndicesFils :\n        if (compare(plateau, askConfig(arbre[iFils]))):\n            return arbre, iFils\n    \n    # Pas trouv\u00e9, il faut cr\u00e9er un nouveau fils\n    # On cr\u00e9\u00e9 des fils parmi les coups licites jusqu'\u00e0 trouver le bon\n    config = askConfig(noeud)\n    scores = askScores(noeud)\n    listeCoupsLicites = coupsLicites(config, joueurDevantJouer(noeud))\n    for coup in listeCoupsLicites:\n        configSuivante,scoresSuivants = jouerCoup(config, coup, scores)\n        if (compare(plateau, configSuivante)):\n            arbre = creationNouveauNoeud(arbre, copy.copy(plateau), copy.copy(scoresSuivants), joueurSuivant(joueurDevantJouer(noeud)), iRacine, coup)\n            return arbre, len(arbre)-1\n    print(\"erreurRechercheRacine\")\n    return \"erreurRechercheRacine\", \"erreur\"","6be10f28":"# tourOrdi(): maj l'arbre, trouvre le meilleur coup \u00e0 jouer, renvoie l'arbre et ce coup\n\ndef tourOrdi(plateau, arbre, iRacine):\n    arbre, iRacine = rechercheRacine(plateau, arbre, iRacine)\n    for n in range (0,1000):\n        arbre, iFeuille = selection(arbre, iRacine)\n        arbre, iFils = expansion(arbre, iFeuille)\n        if (iFils != -1):\n            victoire = simulation(arbre, iFils)\n        else :\n            #Fin de partie\n            if (iRacine == iFeuille):\n                print(\"\u00e9galit\u00e9 iRacine iFeuille\")\n                break\n            Feuille = arbre[iFeuille]\n            victoire = partieFinie(askConfig(Feuille), askScores(Feuille))-1\n            iFils = iFeuille\n        arbre = retropropagation(arbre, iFils, iRacine, victoire)\n    iRacine, coup = choixCoup(arbre, iRacine)\n    # Le fils choisi devient la nouvelle racine.\n    return arbre, iRacine, coup\n\n\n# tourJoueurReel(): Affiche le plateau, demande d'entrer un coup, renvoie ce coup.\n\ndef tourJoueurReel(plateau):\n    joueur = joueurSuivant(joueurArbre)\n    listeCoupsLicites = coupsLicites(plateau, joueur)\n    print(\"Entrez le num\u00e9ro de la coupelle \u00e0 jouer:\")\n    coup = int(input())\n    while coup not in listeCoupLicites:\n        print(\"Incorrect. Entrez le num\u00e9ro de la coupelle \u00e0 jouer.\")\n        coup = int(input())\n    return coup\n\ndef tourRandom(plateau, joueur):\n    listeCoupsLicites = coupsLicites(plateau, joueur)\n    return random.choice(listeCoupsLicites)","796d8224":"def reboot():\n    global joueurArbre  #Utilis\u00e9 pour simulation()\n    global scoreGagnant  #score \u00e0 atteindre pour gagner\n    global configInit\n    global scoresInit\n    # global arbre ?\n    global probaChoixExploration\n\n    joueurArbre = 2\n    scoreGagnant = 10\n    configInit = [4,4,4,4,4,4,4,4]\n    scoresInit = [0,0]\n    probaChoixExploration = 0.5\n\ndef jouer():\n    joueur = 1\n    reboot()\n    plateau = copy.copy(configInit)\n    scores = copy.copy(scoresInit)\n    arbre = creationArbre()\n    iRacine = 0;\n    valFinie = 0\n    print(plateau,scores)\n    while valFinie == 0 :\n        if joueur == joueurArbre :\n            arbre, iRacine, coup = tourOrdi(plateau, arbre, iRacine)\n            print(\"L'ordi joue le coup \", coup, \".\", \" iRacine = \", iRacine, \".\")\n        else :\n            coup = tourRandom(plateau, joueurSuivant(joueurArbre))\n        plateau, scores = jouerCoup(plateau, coup, scores)\n        print(plateau,scores)\n        valFinie = partieFinie(plateau, scores)\n        joueur = joueurSuivant(joueur)\n    return (plateau, scores, valFinie)\n\n#jouer()","bf90f654":"def testEfficacite():\n    nbSimulations=20\n    victoires = 0\n    for i in range(0,nbSimulations):\n        plateau, scores, victoire = jouer()\n        victoires+=victoire-1\n    return victoires\/nbSimulations\n\nv = testEfficacite()","59124d14":"v\n","0becf382":"TEST:","670da1b7":"TEST OK","9d7e3afc":"Cr\u00e9ation de la structure d'arbre et des noeuds :","987b2ba2":"Cr\u00e9ation de la premi\u00e8re \u00e9tape, la s\u00e9lection.","208f491b":"Cr\u00e9ation de l'arbre et des noeuds:","489df035":"Cr\u00e9ation des fonctions permettant de jouer un coup et de trouver les coups licites d'une situation:","3a4f284f":"Creation de fonctions utiles :","53b34fed":"Variables globales","15aaf2e6":"# Principe de l'algorithme","663915fa":"TEST","c8d29659":"TEST","11f8927a":"# Algorithme de Monte - Carlo, \u00e9ventuelle application","2b7fed21":"Les imports :","5d67202d":"Main :","337d1f67":"FIN TEST","a195de27":"L'algorithme de Monte Carlo Tree Search (MCTS) est une m\u00e9thode de recherche arborescente. La racine de l'arbre est la configuration initiale du jeu, et un noeud est une des configurations possibles. Les enfants d'un noeud sont les configurations suivantes.\n\nChaque noeud stocke deux nombres, le nombre de simulations gagnantes et le nombre total de simulations.\n\nUne \u00e9tape est compos\u00e9e de quatre phases, la s\u00e9lection, l'expansion, la simulation et la r\u00e9tropropagation.\n\n\n1. La s\u00e9lection : on se place \u00e0 la racine, et on descend jusqu'\u00e0 une feuille en choisissant \u00e0 chaque fois un enfant. Il faut faire un compromis entre un bon ratio (beaucoup de simulations victorieuses par rapport au nombre de simulations total) et la d\u00e9couverte de nouveaux chemins.\n\n\n2. L'expansion : Si la feuille \u00e0 laquelle on est arriv\u00e9e n'est pas une fin de partie, on cr\u00e9e un ou plusieurs enfants et on choisit l'un d'entre eux ; cet enfant est marqu\u00e9 0\/0 (pas de victoire en simulation... et pas de simulation)\n\n\n3. La simulation : on simule une partie totalement au hasard avec cet enfant, jusqu'\u00e0 une fin de partie.\n\n\n4. La r\u00e9tropropagation : on incr\u00e9mente d'un le nombre de simulations sur toute la branche (la feuille, et tous ses anc\u00eatres) jusqu'\u00e0 la racine. Si le r\u00e9sultat est une victoire, on fait la m\u00eame chose mais pour le nombre de simulations victorieuses.\n\n\n\nTentons d'appliquer ce principe \u00e0 un Awal\u00e9 \u00e0 4 trous.","ce2d5d88":"FIN TEST"}}