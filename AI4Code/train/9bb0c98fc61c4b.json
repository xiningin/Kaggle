{"cell_type":{"afac3c1c":"code","f75b123c":"code","8bc83e57":"code","4f3c841c":"code","49a27200":"code","3f346f4d":"code","186e38a0":"code","ae709f53":"code","6c95f829":"code","cf168456":"code","b05dab54":"markdown"},"source":{"afac3c1c":"!pip install imutils\nimport cv2\nimport imutils\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom imutils import contours\nfrom PIL import Image","f75b123c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8bc83e57":"#Code by Naim Mhedhbi  https:\/\/www.kaggle.com\/naim99\/ocr-opencv2-3-bank-cards\/comments\n# define a dictionary that maps the first digit of a credit card\n# number to the credit card type\n\nref = cv2.imread(\"..\/input\/cusersmarilonedriveimagenskilroypng\/images.png\")\nref = cv2.cvtColor(ref, cv2.COLOR_BGR2GRAY)\nref = cv2.threshold(ref, 10, 255, cv2.THRESH_BINARY_INV)[1]\nrefCnts = cv2.findContours(ref.copy(), cv2.RETR_EXTERNAL,\n                               cv2.CHAIN_APPROX_SIMPLE)\nrefCnts =refCnts[1] if imutils.is_cv3() else refCnts[0]\nrefCnts = contours.sort_contours(refCnts, method=\"left-to-right\")[0]\ndigits = {}\nprint(refCnts)","4f3c841c":"plt.imshow(ref)","49a27200":"from PIL import Image\n\nimage = Image.open(\"..\/input\/cusersmarilonedriveimagenskilroypng\/images.png\")\nimage","3f346f4d":"    # loop over the OCR-A reference contours\n    for (i, c) in enumerate(refCnts):\n        # compute the bounding box for the digit, extract it, and resize\n        # it to a fixed size\n        (x, y, w, h) = cv2.boundingRect(c)\n        roi = ref[y:y + h, x:x + w]\n        roi = cv2.resize(roi, (57, 88))\n\n        # update the digits dictionary, mapping the digit name to the ROI\n        digits[i] = roi\n\n    # initialize a rectangular (wider than it is tall) and square\n    # structuring kernel\n    rectKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (9, 3))\n    sqKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))\n\n    # load the input image, resize it, and convert it to grayscale\n    image = cv2.imread(imgFile)\n    image = imutils.resize(image, width=300)\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    plt.imshow(gray)\n    plt.show()\n    # apply a tophat (whitehat) morphological operator to find light\n    # regions against a dark background (i.e., the credit card numbers)\n    tophat = cv2.morphologyEx(gray, cv2.MORPH_TOPHAT, rectKernel)","186e38a0":"    # compute the Scharr gradient of the tophat image, then scale\n    # the rest back into the range [0, 255]\n    gradX = cv2.Sobel(tophat, ddepth=cv2.CV_32F, dx=1, dy=0,\n                      ksize=-1)\n    gradX = np.absolute(gradX)\n    (minVal, maxVal) = (np.min(gradX), np.max(gradX))\n    gradX = (255 * ((gradX - minVal) \/ (maxVal - minVal)))\n    gradX = gradX.astype(\"uint8\")\n\n    # apply a closing operation using the rectangular kernel to help\n    # cloes gaps in between credit card number digits, then apply\n    # Otsu's thresholding method to binarize the image\n    gradX = cv2.morphologyEx(gradX, cv2.MORPH_CLOSE, rectKernel)\n    thresh = cv2.threshold(gradX, 0, 255,\n                           cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n\n    # apply a second closing operation to the binary image, again\n    # to help close gaps between credit card number regions\n    thresh = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, sqKernel)\n\n    # find contours in the thresholded image, then initialize the\n    # list of digit locations\n    cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL,\n                            cv2.CHAIN_APPROX_SIMPLE)\n    cnts = cnts[1] if imutils.is_cv3() else cnts[0]\n    \n    locs = []\n","ae709f53":"    # loop over the contours\n    for (i, c) in enumerate(cnts):\n        # compute the bounding box of the contour, then use the\n        # bounding box coordinates to derive the aspect ratio\n        (x, y, w, h) = cv2.boundingRect(c)\n        ar = w \/ float(h)\n\n        # since credit cards used a fixed size fonts with 4 groups\n        # of 4 digits, we can prune potential contours based on the\n        # aspect ratio\n        if ar > 2.5 and ar < 4.0:\n            # contours can further be pruned on minimum\/maximum width\n            # and height\n            if (w > 40 and w < 55) and (h > 10 and h < 20):\n                # append the bounding box region of the digits group\n                # to our locations list\n                locs.append((x, y, w, h))\n\n    # sort the digit locations from left-to-right, then initialize the\n    # list of classified digits\n    locs = sorted(locs, key=lambda x: x[0])\n    output = []\n","6c95f829":"    # loop over the 4 groupings of 4 digits\n    for (i, (gX, gY, gW, gH)) in enumerate(locs):\n        # initialize the list of group digits\n        groupOutput = []\n\n        # extract the group ROI of 4 digits from the grayscale image,\n        # then apply thresholding to segment the digits from the\n        # background of the credit card\n        group = gray[gY - 5:gY + gH + 5, gX - 5:gX + gW + 5]\n        group = cv2.threshold(group, 0, 255,\n                              cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\n\n        # detect the contours of each individual digit in the group,\n        # then sort the digit contours from left to right\n        digitCnts = cv2.findContours(group.copy(), cv2.RETR_EXTERNAL,\n                                     cv2.CHAIN_APPROX_SIMPLE)\n        digitCnts = digitCnts[1] if imutils.is_cv3() else digitCnts[0]\n        digitCnts = contours.sort_contours(digitCnts,\n                                           method=\"left-to-right\")[0]","cf168456":"# loop over the digit contours\nfor c in digitCnts:\n# compute the bounding box of the individual digit, extract\n# the digit, and resize it to have the same fixed size as\n# the reference OCR-A images\n (x, y, w, h) = cv2.boundingRect(c)\nroi = group[y:y + h, x:x + w]\nroi = cv2.resize(roi, (57, 88))\n\n            # initialize a list of template matching scores\nscores = []\n\n            # loop over the reference digit name and digit ROI\nfor (digit, digitROI) in digits.items():\n                # apply correlation-based template matching, take the\n                # score, and update the scores list\n                result = cv2.matchTemplate(roi, digitROI,\n                                           cv2.TM_CCOEFF)\n                (_, score, _, _) = cv2.minMaxLoc(result)\n                scores.append(score)\nprint(scores)\n            # the classification for the digit ROI will be the reference\n            # digit name with the *largest* template matching score\ngroupOutput.append(str(np.argmax(scores)))\n            # draw the digit classifications around the group\ncv2.rectangle(image, (gX - 5, gY - 5),\n             (gX + gW + 5, gY + gH + 5), (0, 0, 255), 2)\ncv2.putText(image, \"\".join(groupOutput), (gX, gY - 15),\n            cv2.FONT_HERSHEY_SIMPLEX, 0.65, (0, 0, 255), 2)\n\n            # update the output digits list\noutput.extend(groupOutput)\n# display the output credit card information to the screen\n# print(\"Credit Card Type: {}\".format(FIRST_NUMBER[output[0]]))\nprint(\"Kilroy was Here #: {}\".format(\"\".join(output)))\nplt.imshow(image)\nplt.show()","b05dab54":"#Codes by Naim Mhedhbi https:\/\/www.kaggle.com\/naim99\/ocr-opencv2-3-bank-cards\/notebook"}}