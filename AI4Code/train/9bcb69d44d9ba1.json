{"cell_type":{"d02c336e":"code","c2d684aa":"code","86ddd850":"code","ddff8ed7":"code","cdd3e266":"markdown"},"source":{"d02c336e":"from __future__ import division, print_function\nimport pandas as pd\nimport numpy as np\nimport itertools","c2d684aa":"class FPTreeNode():\n    def __init__(self, item=None, support=1):\n        # 'Value' of the item\n        self.item = item\n        # Number of times the item occurs in a\n        # transaction\n        self.support = support\n        # Child nodes in the FP Growth Tree\n        self.children = {}\n","86ddd850":"class FPGrowth():\n    \"\"\"Find frequent itemsets in a transactional database using FP Growth tree, which can then be mined\n    to collect the frequent itemsets\n    \"\"\"\n\n    def __init__(self, min_sup=0.4):\n        self.min_sup = min_sup\n        # The root of the initial FP Growth Tree\n        self.tree_root = None\n        # Prefixes of itemsets in the FP Growth Tree\n        self.prefixes = {}\n        self.frequent_itemsets = []\n\n    # Count the number of transactions that contains item.\n    def _calculate_support(self, item, transactions):\n        count = 0\n        for transaction in transactions:\n            if item in transaction:\n                count += 1\n        support = count\n        return support\n\n    # Returns a set of frequent items. An item is determined to\n    # be frequent if there are atleast min_sup transactions that contains\n    # it.\n    def _get_frequent_items(self, transactions):\n        # Get all unique items in the transactions\n        unique_items = set(\n            item for transaction in transactions for item in transaction)\n        items = []\n        for item in unique_items:\n            sup = self._calculate_support(item, transactions)\n            if sup >= self.min_sup:\n                items.append([item, sup])\n        # Sort by support - Highest to lowest\n        items.sort(key=lambda item: item[1], reverse=True)\n        frequent_items = [[el[0]] for el in items]\n        # Only return the items\n        return frequent_items\n\n    # Recursive method which adds nodes to the tree.\n    def _insert_tree(self, node, children):\n        if not children:\n            return\n        # Create new node as the first item in children list\n        child_item = children[0]\n        child = FPTreeNode(item=child_item)\n        # If parent already contains item => increase the support\n        if child_item in node.children:\n            node.children[child.item].support += 1\n        else:\n            node.children[child.item] = child\n\n        # Execute _insert_tree on the rest of the children list\n        # from the new node\n        self._insert_tree(node.children[child.item], children[1:])\n\n    def _construct_tree(self, transactions, frequent_items=None):\n        if not frequent_items:\n            # Get frequent items sorted by support\n            frequent_items = self._get_frequent_items(transactions)\n        unique_frequent_items = list(\n            set(item for itemset in frequent_items for item in itemset))\n        # Construct the root of the FP Growth tree\n        root = FPTreeNode()\n        for transaction in transactions:\n            # Remove items that are not frequent according to\n            # unique_frequent_items\n            transaction = [item for item in transaction if item in unique_frequent_items]\n            transaction.sort(key=lambda item: frequent_items.index([item]))\n            self._insert_tree(root, transaction)\n\n        return root\n\n    # Recursive method which prints the FP Growth Tree\n    def print_tree(self, node=None, indent_times=0):\n        if not node:\n            node = self.tree_root\n        indent = \"    \" * indent_times\n        print(\"%s%s:%s\" % (indent, node.item, node.support))\n        for child_key in node.children:\n            child = node.children[child_key]\n            self.print_tree(child, indent_times + 1)\n\n    # Makes sure that the first item in itemset\n    # is a child of node and that every following item\n    # in itemset is reachable via that path\n    def _is_prefix(self, itemset, node):\n        for item in itemset:\n            if not item in node.children:\n                return False\n            node = node.children[item]\n        return True\n\n    # Recursive method that adds prefixes to the itemset by\n    # traversing the FP Growth Tree\n    def _determine_prefixes(self, itemset, node, prefixes=None):\n        if not prefixes:\n            prefixes = []\n\n        # If the current node is a prefix to the itemset\n        # add the current prefixes value as prefix to the itemset\n        if self._is_prefix(itemset, node):\n            itemset_key = self._get_itemset_key(itemset)\n            if not itemset_key in self.prefixes:\n                self.prefixes[itemset_key] = []\n            self.prefixes[itemset_key] += [{\"prefix\": prefixes, \"support\": node.children[itemset[0]].support}]\n\n        for child_key in node.children:\n            child = node.children[child_key]\n            # Recursive call with child as new node. Add the child item as potential\n            # prefix.\n            self._determine_prefixes(itemset, child, prefixes + [child.item])\n\n    # Determines the look of the hashmap key for self.prefixes\n    # List of more strings than one gets joined by '-'\n    def _get_itemset_key(self, itemset):\n        if len(itemset) > 1:\n            itemset_key = \"-\".join(itemset)\n        else:\n            itemset_key = str(itemset[0])\n        return itemset_key\n\n    def _determine_frequent_itemsets(self, conditional_database, suffix):\n        # Calculate new frequent items from the conditional database\n        # of suffix\n        frequent_items = self._get_frequent_items(conditional_database)\n\n        cond_tree = None\n\n        if suffix:\n            cond_tree = self._construct_tree(conditional_database, frequent_items)\n            # Output new frequent itemset as the suffix added to the frequent\n            # items\n            self.frequent_itemsets += [el + suffix for el in frequent_items]\n\n        # Find larger frequent itemset by finding prefixes\n        # of the frequent items in the FP Growth Tree for the conditional\n        # database.\n        self.prefixes = {}\n        for itemset in frequent_items:\n            # If no suffix (first run)\n            if not cond_tree:\n                cond_tree = self.tree_root\n            # Determine prefixes to itemset\n            self._determine_prefixes(itemset, cond_tree)\n            conditional_database = []\n            itemset_key = self._get_itemset_key(itemset)\n            # Build new conditional database\n            if itemset_key in self.prefixes:\n                for el in self.prefixes[itemset_key]:\n                    # If support = 4 => add 4 of the corresponding prefix set\n                    for _ in range(el[\"support\"]):\n                        conditional_database.append(el[\"prefix\"])\n                # Create new suffix\n                new_suffix = itemset + suffix if suffix else itemset\n                self._determine_frequent_itemsets(conditional_database, suffix=new_suffix)\n\n    def find_frequent_itemsets(self, transactions, suffix=None, show_tree=False):\n        self.transactions = transactions\n\n        # Build the FP Growth Tree\n        self.tree_root = self._construct_tree(transactions)\n        if show_tree:\n            print(\"FP-Growth Tree:\")\n            self.print_tree(self.tree_root)\n\n        self._determine_frequent_itemsets(transactions, suffix=None)\n\n        return self.frequent_itemsets\n\n\n","ddff8ed7":"def main():\n    # Data array\n  \n    transactions = np.array([\n        [\"drought\", \"kill\", \"farmer\", \"india\"],\n        [\"water\", \"scarcity\", \"major\",\"issue\"],\n        [\"drought\", \"increase\", \"suicide\", \"ratio\"],\n        [\"scarcity\", \"drink\", \"water\"],\n        [\"crop\", \"quality\", \"suffer\", \"due\", \"drought\"],\n        [\"drought\", \"kill\", \"farmer\", \"india\"],\n        [\"water\", \"scarcity\", \"major\", \"issue\"],\n        [\"drought\", \"increase\", \"suicide\", \"ratio\"],\n        [\"scarcity\", \"drink\", \"water\"],\n        [\"crop\", \"quality\", \"suffer\", \"due\", \"drought\"],\n        [\"drought\", \"kill\", \"farmer\", \"india\"],\n        [\"water\", \"scarcity\", \"major\", \"issue\"],\n        [\"drought\", \"increase\", \"suicide\", \"ratio\"],\n        [\"scarcity\", \"drink\", \"water\"],\n        [\"crop\", \"quality\", \"suffer\", \"due\", \"drought\"]\n    ])\n\n    print(\"- FP-Growth -\")\n    min_sup = 2\n    print(\"Minimum Support: %s\" % min_sup)\n    print(\"Transactions:\")\n    for transaction in transactions:\n        print(\"\\t%s\" % transaction)\n\n    fp_growth = FPGrowth(min_sup=min_sup)\n\n    # Get and print the frequent itemsets\n    frequent_itemsets = fp_growth.find_frequent_itemsets(transactions, show_tree=True)\n    print(\"Frequent itemsets:\")\n    for itemset in frequent_itemsets:\n\n        print(\"\\t%s\" % itemset)\n\n\nif __name__ == \"__main__\":\n    main()\n","cdd3e266":"**# Frequent patterns with Drought domain will be predicted & better results #are achieved with Frequent pattern tree.It will not only show the frequent #pattern but also tell the factors most affected by \"Drought\".\n\n# Please upvote if you like it.**"}}