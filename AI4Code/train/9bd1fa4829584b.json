{"cell_type":{"ddbaac43":"code","da9d82ef":"code","a1f700d9":"code","37a1de0f":"code","11e6d4e2":"code","522b0b9c":"code","2e643b26":"code","a185bc10":"code","265a39ca":"code","135559fa":"code","7493575b":"code","2e24db23":"code","51ac1aa9":"code","cdcfcce1":"code","8d2159ea":"code","06039b63":"code","ba0476b5":"code","86b60d55":"code","2a5e55da":"code","2ef31153":"code","df23c7d2":"code","f19bff12":"code","a12c2318":"code","070c19e9":"code","c3a187dd":"code","08b4a27b":"code","dca12169":"code","eff430f8":"code","352cbdf1":"code","6941c3fa":"code","27da0f01":"code","0fe63573":"code","0fa321be":"code","bdf2209f":"code","f6e6c535":"code","63a2dfdc":"code","6b7da4a1":"code","392b127c":"code","9c0ba45e":"code","ad7bd66c":"code","8e7cfc5a":"code","2101fc8a":"code","22b551c3":"code","791edc66":"code","767e38c2":"code","89920afb":"code","9de11942":"code","fb2fe8b1":"code","496e3fa7":"code","79f3671c":"markdown","693ae779":"markdown","4598e941":"markdown","23c0cffa":"markdown","af97a040":"markdown","8fae1f59":"markdown","f31d10de":"markdown","13b6ac2e":"markdown","e1d7ec42":"markdown","47e6fcf0":"markdown","e27bc6f4":"markdown","8c76ad6c":"markdown","584a3a62":"markdown","27ced7ed":"markdown","a4f83233":"markdown","f087c0ca":"markdown","38f79d3e":"markdown","f0ac5df0":"markdown","9d9474e6":"markdown","1670a20e":"markdown","a86790a0":"markdown","2672f85d":"markdown","960b421a":"markdown"},"source":{"ddbaac43":"\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\nimport math\nimport json\nimport time\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.metrics.pairwise import cosine_similarity\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import NearestNeighbors\nfrom sklearn.externals import joblib\nimport scipy.sparse\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import svds\nimport warnings; warnings.simplefilter('ignore')\n%matplotlib inline\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","da9d82ef":"electronics_data=pd.read_csv(\"\/kaggle\/input\/amazon-product-reviews\/ratings_Electronics (1).csv\",names=['userId', 'productId','Rating','timestamp'])\n","a1f700d9":"# Display the data\n\nelectronics_data.head()\n","37a1de0f":"\n#Shape of the data\nelectronics_data.shape","11e6d4e2":"#Taking subset of the dataset\nelectronics_data=electronics_data.iloc[:1048576,0:]","522b0b9c":"#Check the datatypes\nelectronics_data.dtypes","2e643b26":"electronics_data.info()\n","a185bc10":"#Five point summary \n\nelectronics_data.describe()['Rating'].T\n","265a39ca":"#Find the minimum and maximum ratings\nprint('Minimum rating is: %d' %(electronics_data.Rating.min()))\nprint('Maximum rating is: %d' %(electronics_data.Rating.max()))","135559fa":"#Check for missing values\nprint('Number of missing values across columns: \\n',electronics_data.isnull().sum())\n\n","7493575b":"# Check the distribution of the rating\nwith sns.axes_style('white'):\n    g = sns.factorplot(\"Rating\", data=electronics_data, aspect=2.0,kind='count')\n    g.set_ylabels(\"Total number of ratings\")","2e24db23":"print(\"Total data \")\nprint(\"-\"*50)\nprint(\"\\nTotal no of ratings :\",electronics_data.shape[0])\nprint(\"Total No of Users   :\", len(np.unique(electronics_data.userId)))\nprint(\"Total No of products  :\", len(np.unique(electronics_data.productId)))","51ac1aa9":"#Dropping the Timestamp column\n\nelectronics_data.drop(['timestamp'], axis=1,inplace=True)","cdcfcce1":"#Analysis of rating given by the user \n\nno_of_rated_products_per_user = electronics_data.groupby(by='userId')['Rating'].count().sort_values(ascending=False)\n\nno_of_rated_products_per_user.head()","8d2159ea":"no_of_rated_products_per_user.describe()\n","06039b63":"quantiles = no_of_rated_products_per_user.quantile(np.arange(0,1.01,0.01), interpolation='higher')\n","ba0476b5":"plt.figure(figsize=(10,10))\nplt.title(\"Quantiles and their Values\")\nquantiles.plot()\n# quantiles with 0.05 difference\nplt.scatter(x=quantiles.index[::5], y=quantiles.values[::5], c='orange', label=\"quantiles with 0.05 intervals\")\n# quantiles with 0.25 difference\nplt.scatter(x=quantiles.index[::25], y=quantiles.values[::25], c='m', label = \"quantiles with 0.25 intervals\")\nplt.ylabel('No of ratings by user')\nplt.xlabel('Value at the quantile')\nplt.legend(loc='best')\nplt.show()","86b60d55":"print('\\n No of rated product more than 50 per user : {}\\n'.format(sum(no_of_rated_products_per_user >= 50)) )\n","2a5e55da":"#Getting the new dataframe which contains users who has given 50 or more ratings\n\nnew_df=electronics_data.groupby(\"productId\").filter(lambda x:x['Rating'].count() >=50)","2ef31153":"no_of_ratings_per_product = new_df.groupby(by='productId')['Rating'].count().sort_values(ascending=False)\n\nfig = plt.figure(figsize=plt.figaspect(.5))\nax = plt.gca()\nplt.plot(no_of_ratings_per_product.values)\nplt.title('# RATINGS per Product')\nplt.xlabel('Product')\nplt.ylabel('No of ratings per product')\nax.set_xticklabels([])\n\nplt.show()","df23c7d2":"#Average rating of the product \n\nnew_df.groupby('productId')['Rating'].mean().head()","f19bff12":"new_df.groupby('productId')['Rating'].mean().sort_values(ascending=False).head()\n","a12c2318":"#Total no of rating for product\n\nnew_df.groupby('productId')['Rating'].count().sort_values(ascending=False).head()","070c19e9":"ratings_mean_count = pd.DataFrame(new_df.groupby('productId')['Rating'].mean())\n","c3a187dd":"ratings_mean_count['rating_counts'] = pd.DataFrame(new_df.groupby('productId')['Rating'].count())\n","08b4a27b":"ratings_mean_count.head()\n","dca12169":"ratings_mean_count['rating_counts'].max()\n","eff430f8":"plt.figure(figsize=(8,6))\nplt.rcParams['patch.force_edgecolor'] = True\nratings_mean_count['rating_counts'].hist(bins=50)","352cbdf1":"plt.figure(figsize=(8,6))\nplt.rcParams['patch.force_edgecolor'] = True\nratings_mean_count['Rating'].hist(bins=50)","6941c3fa":"plt.figure(figsize=(8,6))\nplt.rcParams['patch.force_edgecolor'] = True\nsns.jointplot(x='Rating', y='rating_counts', data=ratings_mean_count, alpha=0.4)","27da0f01":"popular_products = pd.DataFrame(new_df.groupby('productId')['Rating'].count())\nmost_popular = popular_products.sort_values('Rating', ascending=False)\nmost_popular.head(30).plot(kind = \"bar\")","0fe63573":"from surprise import KNNWithMeans\nfrom surprise import Dataset\nfrom surprise import accuracy\nfrom surprise import Reader\nimport os\nfrom surprise.model_selection import train_test_split","0fa321be":"#Reading the dataset\nreader = Reader(rating_scale=(1, 5))\ndata = Dataset.load_from_df(new_df,reader)","bdf2209f":"#Splitting the dataset\ntrainset, testset = train_test_split(data, test_size=0.3,random_state=10)","f6e6c535":"# Use user_based true\/false to switch between user-based or item-based collaborative filtering\nalgo = KNNWithMeans(k=5, sim_options={'name': 'pearson_baseline', 'user_based': False})\nalgo.fit(trainset)","63a2dfdc":"# run the trained model against the testset\ntest_pred = algo.test(testset)","6b7da4a1":"test_pred\n","392b127c":"# get RMSE\nprint(\"Item-based Model : Test Set\")\naccuracy.rmse(test_pred, verbose=True)","9c0ba45e":"\nnew_df1=new_df.head(10000)\nratings_matrix = new_df1.pivot_table(values='Rating', index='userId', columns='productId', fill_value=0)\nratings_matrix.head()","ad7bd66c":"ratings_matrix.shape\n","8e7cfc5a":"X = ratings_matrix.T\nX.head()","2101fc8a":"X.shape\n","22b551c3":"X1 = X\n","791edc66":"#Decomposing the Matrix\nfrom sklearn.decomposition import TruncatedSVD\nSVD = TruncatedSVD(n_components=10)\ndecomposed_matrix = SVD.fit_transform(X)\ndecomposed_matrix.shape","767e38c2":"#Correlation Matrix\n\ncorrelation_matrix = np.corrcoef(decomposed_matrix)\ncorrelation_matrix.shape","89920afb":"X.index[75]\n","9de11942":"i = \"B00000K135\"\n\nproduct_names = list(X.index)\nproduct_ID = product_names.index(i)\nproduct_ID","fb2fe8b1":"correlation_product_ID = correlation_matrix[product_ID]\ncorrelation_product_ID.shape","496e3fa7":"Recommend = list(X.index[correlation_product_ID > 0.65])\n\n# Removes the item already bought by the customer\nRecommend.remove(i) \n\nRecommend[0:24]","79f3671c":"# Analyzing the rating","693ae779":"Correlation for all items with the item purchased by this customer based on items rated by other customers people who bought the same product","4598e941":"# Load the Dataset and Add headers","23c0cffa":"Transposing the matrix","af97a040":"Most of the people has given the rating of 5","8fae1f59":"The rating of the product range from 0 to 1","f31d10de":"As expected, the utility matrix obtaned above is sparce, I have filled up the unknown values wth 0.\n\n","13b6ac2e":"Index # of product ID purchased by customer\n\n","e1d7ec42":"# Types of recommendations\n\nThere are mainly 6 types of the recommendations systems :-\n\n1. Popularity based systems :- It works by recommeding items viewed and purchased by most people and are rated high.It is not a personalized recommendation.\n2. Classification model based:- It works by understanding the features of the user and applying the classification algorithm to decide whether the user is     interested or not in the prodcut.\n3. Content based recommedations:- It is based on the information on the contents of the item rather than on the user opinions.The main idea is if the user likes an item then he or she will like the \"other\" similar item.\n4. Collaberative Filtering:- It is based on assumption that people like things similar to other things they like, and things that are liked by other people with similar taste. it is mainly of two types:\n a) User-User \n b) Item -Item\n \n5. Hybrid Approaches:- This system approach is to combine collaborative filtering, content-based filtering, and other approaches . \n6. Association rule mining :- Association rules capture the relationships between items based on their patterns of co-occurrence across transactions.\n\n","47e6fcf0":"# Introduction to Recommendation systems\n\nIn this modern world we are overloaded with data and this data provides us the useful information. But it's not possible for the user to extract the information which interest them from these data. In order to help the user to find out information about the product , recommedation systems where developed. \n\nRecommeder system creates a similarity between the user and items and exploits the similarity between user\/item to make recommendations.\n\n\nWhat recommeder system can solve ?\n\n1. It can help the user to find the right product.\n2. It can increase the user engagement. For example, there's 40% more click on the google news due to recommendation.\n3. It helps the item providers to deliver the items to the right user.In Amazon , 35 % products get sold due to recommendation.\n4. It helps to make the contents more personalized.In Netflix most of the rented movies are from recommendations.\n","e27bc6f4":"## Ratings","8c76ad6c":"## Handling Missing values\n","584a3a62":"Recommending top 25 highly correlated products in sequence\n\n","27ced7ed":"## Unique Users and products\n","a4f83233":"# Background \n\nE-commerce companies like AMazon , flipkart uses different recommendation systems to provide suggestions to the customers.Amazon uses currently item-item collaberrative filtering, which scales to massive datasets and produces high quality recommendation system in the real time. This system is a kind of a information filtering system which seeks to predict the \"rating\" or preferences which user is interested in. \n\n![image.png](attachment:image.png)\n\n","f087c0ca":"# Attribute Information:\n\n\u25cf userId : Every user identified with a unique id \n\n\u25cf productId : Every product identified with a unique id \n\n\u25cf Rating : Rating of the corresponding product by the corresponding user \n\n\u25cf timestamp : Time of the rating ( ignore this column for this exercise)\n\n","38f79d3e":"Unique products in subset of data\n","f0ac5df0":"# Import Libraries ","9d9474e6":"# Collaberative filtering (Item-Item recommedation)\n\nCollaborative filtering is commonly used for recommender systems. These techniques aim to fill in the missing entries of a user-item association matrix. We are going to use collaborative filtering (CF) approach.\nCF is based on the idea that the best recommendations come from people who have similar tastes. In other words, it uses historical item ratings of like-minded people to predict how someone would rate an item.Collaborative filtering has two sub-categories that are generally called memory based and model-based approaches.\n\n","1670a20e":"# Model-based collaborative filtering system\n\nThese methods are based on machine learning and data mining techniques. The goal is to train models to be able to make predictions. For example, we could use existing user-item interactions to train a model to predict the top-5 items that a user might like the most. One advantage of these methods is that they are able to recommend a larger number of items to a larger number of users, compared to other methods like memory based approach. They have large coverage, even when working with large sparse matrices.","a86790a0":"Here are the top 10 products to be displayed by the recommendation system to the above customer based on the purchase history of other customers in the website.\n","2672f85d":"## Dropping the TimeStamp Column","960b421a":"# Popularity Based Recommendation\n\nPopularity based recommendation system works with the trend. It basically uses the items which are in trend right now. For example, if any product which is usually bought by every new user then there are chances that it may suggest that item to the user who just signed up.\n\nThe problems with popularity based recommendation system is that the personalization is not available with this method i.e. even though you know the behaviour of the user you cannot recommend items accordingly.\n\n![image.png](attachment:image.png)"}}