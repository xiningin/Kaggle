{"cell_type":{"17c26942":"code","dcdee201":"code","4ed2d390":"code","44d47b73":"code","806922f6":"code","16f9e590":"code","1534168e":"code","51dfc511":"code","55191de3":"code","27288552":"code","e8086ed6":"code","05695f24":"code","96c25e3f":"code","7ba5659a":"code","07644b3f":"code","e2436400":"code","7f8f9805":"code","6823d7eb":"code","72f3748b":"code","3927118e":"code","e0fb1fd0":"code","004cbe2b":"code","646cc8d1":"code","2d1adb6d":"code","2ecd8c1b":"code","670e2814":"code","efc7022b":"code","701d7bda":"code","c99294d4":"code","909b45e3":"code","fdc00bcf":"code","b8f72818":"code","085d48cd":"code","0a1edec9":"code","b8ac30c4":"code","2191de4a":"code","bb0b2676":"code","f12b323c":"code","1043532f":"code","1f0bd3a0":"code","5da0425b":"code","c0ef51a9":"code","42b455d4":"code","6e1b5bbb":"code","49078255":"code","f02e01ef":"code","6588290a":"markdown","2939f4f9":"markdown","ad12280f":"markdown","6ebb6a9f":"markdown","e74d6558":"markdown","bda61f7b":"markdown","073c2323":"markdown","b19832a5":"markdown","84a34c7b":"markdown","1a631d66":"markdown","0707d69f":"markdown","f965253f":"markdown","7c985bfb":"markdown","8cfb38a5":"markdown","b4ba0ff0":"markdown","ca20db6a":"markdown","4a524f0b":"markdown","5d77657d":"markdown","38a3858e":"markdown","9b5ae672":"markdown","5b102c16":"markdown","5a650e58":"markdown","33509e37":"markdown","4754831e":"markdown","7279dd43":"markdown","83f618ec":"markdown","30094f9f":"markdown","844184c0":"markdown","b4340e23":"markdown","ee3673ce":"markdown","7576af5a":"markdown","51921b5c":"markdown","3a3a446c":"markdown","f958c7c5":"markdown","e8174c69":"markdown","cdb3b813":"markdown","04fadbec":"markdown","1f6033cb":"markdown","8b18f79c":"markdown","c7e0b250":"markdown","7a2a0582":"markdown","3ec17e38":"markdown"},"source":{"17c26942":"from IPython.display import Image\nImage(url='https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/e\/e0\/Three_Phase_Electric_Power_Transmission.jpg\/1200px-Three_Phase_Electric_Power_Transmission.jpg')","dcdee201":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport pyarrow.parquet as pq #reading parquet files \nimport matplotlib.pyplot as plt\nimport os\nimport seaborn as sns","4ed2d390":"INIT_DIR = '..\/input'\nSIZE = 2001","44d47b73":"train = pq.read_pandas(os.path.join(INIT_DIR, 'vsb-power-line-fault-detection\/train.parquet'), columns=[str(i) for i in range(SIZE)]).to_pandas()\nmetadata = pd.read_csv('..\/input\/vsb-power-line-fault-detection\/metadata_train.csv')","806922f6":"train.head()","16f9e590":"train.shape","1534168e":"metadata.head()","51dfc511":"metadata.shape","55191de3":"train_metadata = metadata[:SIZE]","27288552":"train_metadata.shape","e8086ed6":"train = train.T","05695f24":"train.head(2)","96c25e3f":"train['signal_id'] = list(train_metadata['signal_id'])","7ba5659a":"train.head(2)","07644b3f":"train = train.merge(train_metadata, on='signal_id')","e2436400":"train.head(2)","7f8f9805":"train.isnull().sum().sum()","6823d7eb":"fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 4))\nsns.countplot(x=\"target\", data=train, ax=ax1)\nsns.countplot(x=\"target\", data=train, hue=\"phase\", ax=ax2);","72f3748b":"# https:\/\/www.w3resource.com\/graphics\/matplotlib\/piechart\/matplotlib-piechart-exercise-2.php\nplt.rcParams[\"figure.figsize\"] = (40,6.5)\ndata = train['target'].value_counts()\nlabels = ['Target 0', 'Target 1']\ncolors = [\"#1f77b4\", \"#ff7f0e\"]\ntitle = 'Count of signals distributed by phase'\nexplodes = [0, 0.1]\nplt.pie(data,explode=explodes, labels=labels, colors=colors, shadow=True, startangle=20, autopct='%.1f%%')\nplt.title(title, bbox={'facecolor':'0.8', 'pad':5})\nplt.show()","3927118e":"target_count = train.target.value_counts()\nprint(\"negative(target=0) target: {}\".format(target_count[0]))\nprint(\"positive(target=1) target: {}\".format(target_count[1]))\nprint(\"positive data {:.3}%\".format((target_count[1]\/(target_count[0]+target_count[1]))*100))","e0fb1fd0":"train[['id_measurement', 'phase']]","004cbe2b":"target_mismatch = train[[\"id_measurement\", \"target\"]].groupby([\"id_measurement\"]).sum().query(\"target != 3 & target != 0\")\nprint(\"Target values not all postive or negative for same signal: {}\".format(target_mismatch.shape[0]))\ntarget_mismatch","646cc8d1":"train[train['id_measurement'] == 67]","2d1adb6d":"print(\"id_measurement have {} unique values\".format(train.id_measurement.nunique()))","2ecd8c1b":"train.id_measurement.value_counts().describe()","670e2814":"print(\"phase have {} unique values {} in train\".format(len(train.phase.unique()),train.phase.unique()))","efc7022b":"sns.countplot(train['phase']);","701d7bda":"# https:\/\/www.w3resource.com\/graphics\/matplotlib\/piechart\/matplotlib-piechart-exercise-2.php\ndata = train['phase'].value_counts()\nlabels = ['Phase 0', 'Phase 1', 'Phase 3']\ncolors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\"]\ntitle = 'Count of signals distributed by phase'\nplt.pie(data, labels=labels, colors=colors, shadow=True, startangle=90, autopct='%.1f%%')\nplt.title(title, bbox={'facecolor':'0.8', 'pad':5})\nplt.show()","c99294d4":"from sklearn.manifold import TSNE\n\ntsne = TSNE(n_components=2, perplexity=30, learning_rate=200, random_state=42)\n\nX_embedding = tsne.fit_transform(train[:500])\ny = np.array(train['target'][:500])\n\nfor_tsne = np.hstack((X_embedding, y.reshape(-1,1)))\nfor_tsne_df = pd.DataFrame(data=for_tsne, columns=['Dimension_x','Dimension_y','Score'])\ncolors = {0:'red', 1:'blue', 2:'green'}\nplt.scatter(for_tsne_df['Dimension_x'], for_tsne_df['Dimension_y'], c=for_tsne_df['Score'].apply(lambda x: colors[x]))\nplt.show()\n\ndel(tsne)","909b45e3":"from sklearn.manifold import TSNE\n\ntsne = TSNE(n_components=2, perplexity=50, learning_rate=200, random_state=42)\n\nX_embedding = tsne.fit_transform(train[:500])\ny = np.array(train['target'][:500])\n\nfor_tsne = np.hstack((X_embedding, y.reshape(-1,1)))\nfor_tsne_df = pd.DataFrame(data=for_tsne, columns=['Dimension_x','Dimension_y','Score'])\ncolors = {0:'red', 1:'blue', 2:'green'}\nplt.scatter(for_tsne_df['Dimension_x'], for_tsne_df['Dimension_y'], c=for_tsne_df['Score'].apply(lambda x: colors[x]))\nplt.show()\n\ndel(tsne)","fdc00bcf":"from sklearn.manifold import TSNE\n\ntsne = TSNE(n_components=2, perplexity=100, learning_rate=150, random_state=42)\n\nX_embedding = tsne.fit_transform(train[:500])\ny = np.array(train['target'][:500])\n\nfor_tsne = np.hstack((X_embedding, y.reshape(-1,1)))\nfor_tsne_df = pd.DataFrame(data=for_tsne, columns=['Dimension_x','Dimension_y','Score'])\ncolors = {0:'red', 1:'blue', 2:'green'}\nplt.scatter(for_tsne_df['Dimension_x'], for_tsne_df['Dimension_y'], c=for_tsne_df['Score'].apply(lambda x: colors[x]))\nplt.show()\n\ndel(tsne)","b8f72818":"#signal with target 0 (normal signal)\ntrain.loc[1]['target']","085d48cd":"plt.figure(figsize=(24, 8))\nplt.plot((train.loc[1].values), alpha=0.7);\nplt.ylim([-100, 100])","0a1edec9":"#signal with target 1 (Faulty Signal)\ntrain.loc[201]['target']","b8ac30c4":"plt.figure(figsize=(24, 8))\nplt.plot((train.loc[201].values), alpha=0.7);\nplt.ylim([-100, 100])","2191de4a":"#signal with target 0 (Normal Signal)\ntrain.loc[0:2][['target', 'id_measurement']]","bb0b2676":"plt.figure(figsize=(24, 8))\nplt.plot((train.loc[0].values), alpha=0.7);\nplt.plot((train.loc[1].values), alpha=0.7);\nplt.plot((train.loc[2].values), alpha=0.7);\nplt.ylim([-100, 100])","f12b323c":"#signal with target 1 (Faulty Signal)\ntrain.loc[3:5][['target', 'id_measurement']]","1043532f":"plt.figure(figsize=(24, 8))\nplt.plot((train.loc[3].values), alpha=0.7);\nplt.plot((train.loc[4].values), alpha=0.7);\nplt.plot((train.loc[5].values), alpha=0.7);\nplt.ylim([-100, 100])","1f0bd3a0":"def flatiron(x, alpha=50, beta=1):\n    new_x = np.zeros_like(x)\n    zero = x[0]\n    for i in range(1, len(x)):\n        zero = zero*(alpha-beta)\/alpha + beta*x[i]\/alpha\n        new_x[i] =  x[i] - zero\n    return new_x","5da0425b":"#Flattening a Normal signal\nnormal_sample_filt =  [None] * 3\nnormal_sample_filt[0] = flatiron(train.loc[0].values)\nnormal_sample_filt[1] = flatiron(train.loc[1].values)\nnormal_sample_filt[2] = flatiron(train.loc[2].values)","c0ef51a9":"normal_sample_filt","42b455d4":"#Code to plot faulty signal with flattened faulty signal\nf, ax = plt.subplots(1, 2, figsize=(24, 8))\n\nax[0].plot((train.loc[0].values), alpha=0.7);\nax[0].plot((train.loc[1].values), alpha=0.7);\nax[0].plot((train.loc[2].values), alpha=0.7);\nax[0].set_title('Normal signal')\nax[0].set_ylim([-100, 100])\n\nax[1].plot((normal_sample_filt)[0], alpha=0.7);\nax[1].plot((normal_sample_filt)[1], alpha=0.7);\nax[1].plot((normal_sample_filt)[2], alpha=0.7);\nax[1].set_title('filtered Normal signal')\nax[1].set_ylim([-100, 100])\n\ndel(normal_sample_filt)","6e1b5bbb":"#Flattening a Faulty signal\nfault_sample_filt =  [None] * 3\nfault_sample_filt[0] = flatiron(train.loc[3].values)\nfault_sample_filt[1] = flatiron(train.loc[4].values)\nfault_sample_filt[2] = flatiron(train.loc[5].values)","49078255":"fault_sample_filt","f02e01ef":"#Code to plot faulty signal with flattened faulty signal\nf, ax = plt.subplots(1, 2, figsize=(24, 8))\n\nax[0].plot((train.loc[3].values), alpha=0.7);\nax[0].plot((train.loc[4].values), alpha=0.7);\nax[0].plot((train.loc[5].values), alpha=0.7);\nax[0].set_title('fault signal')\nax[0].set_ylim([-100, 100])\n\nax[1].plot((fault_sample_filt)[0], alpha=0.7);\nax[1].plot((fault_sample_filt)[1], alpha=0.7);\nax[1].plot((fault_sample_filt)[2], alpha=0.7);\nax[1].set_title('filtered fault signal')\nax[1].set_ylim([-100, 100])\n\ndel(fault_sample_filt)","6588290a":"#### Observation:\nPhase columns is having only 3 values 1,2,3 for each signal as there are three phases of each signal","2939f4f9":"### Adding signal id to the main data frame","ad12280f":"## Plotting signals ","6ebb6a9f":"#### Plotting all three phases of a normal signal","e74d6558":"#### Observation:\n\nFaulty signal has more noise","bda61f7b":"### Finding the Unique values of id_measurement in our dataset","073c2323":"#### Observation:\n\nFaulty signal have more noise than the normal signal. \nHence, noise can be a very useful feature for fault detection","b19832a5":"### Merging Metadata and Signal Data based on signal_id","84a34c7b":"#### Checking target for id _measurement==67 where target value is different in different phase","1a631d66":"#### Observation:\n\nData is imbalanced and the faulty signals are only 6.3% of the total signals","0707d69f":"#### 3. Using Perplexity:100 and learning rate: 150","f965253f":"### Importing Libraries","7c985bfb":"#### Observation:\n\nThe unique value of the id_measurement is as expected : (total signals) \/ 3 , as there are three phases of each signal","8cfb38a5":"### Plotting count vs target plots to check data imbalance","b4ba0ff0":"### Taking first 2000 rows (due to computational limitations) for EDA and visualization","ca20db6a":"#### Plotting normal Signal","4a524f0b":"### Checking if there are different values of target in the different phase of same signal","5d77657d":"### Percentage of positive and negative target values","38a3858e":"#### Observation:\n\nValues are all as expected.\n\nMax count and min count of each signal is 3, as there are three phases of each signal\n\ncount is total\/3, as each signal is having three phases.","9b5ae672":"### Plotting all three phases of a signal","5b102c16":"### Printing unique values of phase column","5a650e58":"### Transposing the dataframe as each column represents one data point.","33509e37":"#### Plotting all three phases of a faulty signal","4754831e":"## Plotting 2d plots using t-SNE using different values of perplexity and learning rate\n\n#### Plotting the t-SNE plots only for 1\/4th of the points due to computational limitations","7279dd43":"# VSB Power Grid Fault Detection","83f618ec":"#### Observation:\n\nData is highly imbalances as the target with value 1 are much less than the target with value 0","30094f9f":"#### Observation:\n\nFaulty signal has more noise than normal signal","844184c0":"#### Plotting normal signal with flattened normal signal","b4340e23":"#### Observation:\n\nWe are able to flatten the signal and are able to visualize the noise in the signal more easily","ee3673ce":"#### 1. Using perplexity: 30 and learning rate: 200","7576af5a":"#### Observation:\n\nTarget values can be different for same signal in different phases","51921b5c":"The idea of flatiron is similar to High Pass Filter. It allows high frequency to pass. It can be useful for noise extraction","3a3a446c":"### Basic description of the id_measurement column ","f958c7c5":"## Flatiron\n\n#### reference: https:\/\/www.kaggle.com\/miklgr500\/flatiron","e8174c69":"### Checking for null values in the dataframe","cdb3b813":"Data Source: https:\/\/www.kaggle.com\/c\/vsb-power-line-fault-detection\n\nUseful read: https:\/\/en.wikipedia.org\/wiki\/Three-phase_electric_power\n","04fadbec":"#### Observation:\n\nAs each column represent a signal, it will be  better if we transpose the dataframe","1f6033cb":"#### Observation: \n\nThere is no null values","8b18f79c":"#### Plotting faulty signal with flattened faulty signal","c7e0b250":"### Observation:\n\nThe points are not well seperated in 2-dimensions as observed by these t-sne plots","7a2a0582":"#### 2. Using perplexity: 50 and learning rate:200","3ec17e38":"#### Plotting Faulty signal"}}