{"cell_type":{"e09198f8":"code","19455dea":"code","ed8bb3ce":"code","eb805301":"code","437e69ae":"code","f09f7a4a":"code","5f9c8d97":"code","b50c1e23":"code","be287478":"code","91638ccf":"code","63570d2c":"code","d3ca22c8":"code","0ce5707f":"code","41dbc40c":"code","600e87b0":"code","3a4402c7":"code","67f8c256":"code","06a51e06":"code","18b29657":"code","b84c1ed6":"code","9c8ecb3c":"code","79ecda90":"code","f20c7471":"code","5d03fbfa":"code","b0920508":"code","368f0f85":"code","b42b2ecb":"code","0f935c9c":"code","2c17733e":"markdown","e1636f2a":"markdown","cdb529ba":"markdown","3f5ef5f9":"markdown","df01f963":"markdown","2ddc9057":"markdown","f536a27d":"markdown","2e185e6d":"markdown","2307b30e":"markdown","9e841196":"markdown","f2bf0d89":"markdown","2ed19b49":"markdown","9358434f":"markdown","90d3ed97":"markdown","5e35d2b5":"markdown","976adf3d":"markdown","4c24d715":"markdown","80d9bfb6":"markdown","4989a1ec":"markdown","a915f3e0":"markdown"},"source":{"e09198f8":"import os\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\nimport math\nimport networkx as nx\n#from nxviz import CircosPlot #nxviz unavailable on kaggle\nimport random\n\nfrom collections import defaultdict\nfrom scipy.stats import ttest_ind\n\nprint(os.listdir(\"..\/input\"))","19455dea":"df = pd.read_csv(\"..\/input\/CityAunrecMW.csv\", low_memory=False)","ed8bb3ce":"print(len(df))\nlist(df)","eb805301":"df.sender_gender.value_counts()","437e69ae":"df.receiver_gender.value_counts()","f09f7a4a":"df = df[df.receiver_gender == 1]","5f9c8d97":"# redo this with column as datetime object\ndf['timestamp'] = pd.to_datetime(df.timestamp, infer_datetime_format=True)\n\nend_date = df.timestamp.max()\nstart_date = df.timestamp.min()\nprint(\"Messaging data was collected from {0} until {1}.\".format(start_date.date(), end_date.date()))","b50c1e23":"df.nway.value_counts(1)","be287478":"senders = set(df.senderid)\nreceivers = set(df.receiverid)\nnum_users = len(senders.union(receivers))\nprint(\"We have message data for {} distinct users.\".format(str(num_users)))\nprint(\"{} users sent messages on the platform.\".format(str(len(senders))))\nprint(\"{} users received messages on the platform.\".format(str(len(receivers))))","91638ccf":"df['age_difference'] = df.sender_age - df.receiver_age\nplt.hist(df.age_difference)\nplt.title(\"Histogram of Difference Between Sender Age and Receiver Age\")\ndf.age_difference.describe()","63570d2c":"df['attractive_difference'] = df.sender_attractive - df.receiver_attractive\nplt.hist(df.attractive_difference)\nplt.title(\"Histogram of Difference in Attractiveness Scores of Sender and Receiver\")\ndf.attractive_difference.describe()","d3ca22c8":"plt.scatter(df.sender_age, df.receiver_age, alpha = 0.01)\nplt.xlabel(\"Sender Age\")\nplt.ylabel(\"Receiver Age\")\nplt.title(\"Receiver Age (y) vs. Sender Age (x)\")\nplt.show()","0ce5707f":"plt.scatter(df.sender_attractive, df.receiver_attractive, alpha = 0.01)\nplt.xlabel(\"Sender Attractiveness Score\")\nplt.ylabel(\"Receiver Attractiveness Score\")\nplt.title(\"Receiver Attractiveness Score (y) vs. Sender Attractiveness Score (x)\")\nplt.show()","41dbc40c":"df.sender_attractive.describe()","600e87b0":"df.receiver_attractive.describe()","3a4402c7":"fig, ax = plt.subplots(1,2)\n\nax[0].hist(df.sender_attractive, alpha=0.5, label='M', color='b')\nax[1].hist(df.receiver_attractive, alpha=0.5, label='F', color='r')\nplt.show()","67f8c256":"t = ttest_ind(df.sender_attractive, df.receiver_attractive, equal_var=False)\nprint(t)","06a51e06":"df['sender_attractive_normalized'] = (df.sender_attractive - df.sender_attractive.mean()) \/ df.sender_attractive.std()\ndf['receiver_attractive_normalized'] = (df.receiver_attractive - df.receiver_attractive.mean()) \/ df.receiver_attractive.std() \n\nplt.scatter(df.sender_attractive_normalized, df.receiver_attractive_normalized, alpha = 0.01)\nplt.show()","18b29657":"df['normalized_attractive_difference'] = df.sender_attractive_normalized - df.receiver_attractive_normalized\nplt.hist(df.normalized_attractive_difference)\ndf.normalized_attractive_difference.describe()","b84c1ed6":"G = nx.Graph()\nG.add_nodes_from(df.senderid, bipartite='sender')\nG.add_nodes_from(df.receiverid, bipartite='receiver')\nG.add_edges_from(zip(df.senderid, df.receiverid))\nnx.is_bipartite(G) # verifies that created graph is bipartite","9c8ecb3c":"def get_nodes_from_partition(G, partition):\n    \"\"\"\n    Returns a list of all nodes from G belong to the specified partition.\n    \n    Args:\n        G - a networkx Graph object, assumed to be a bipartite graph\n            NB: we assume the metadata 'bipartite' is correctly assigned\n            to nodes in this graph\n        partition - a value corresponding to one of the two partitions of\n            nodes in the bipartite graph.\n            \n    Output:\n        a list of nodes belonging to the specified partition\n    \"\"\"\n    return [n for n in G.nodes() if G.node[n]['bipartite'] == partition]\n","79ecda90":"sender_nodes = get_nodes_from_partition(G, 'sender')\nreceiver_nodes = get_nodes_from_partition(G, 'receiver')\n\nprint(\"Number of sender nodes: \" + str(len(sender_nodes)))\nprint(\"Number of receiver nodes: \" + str(len(receiver_nodes)))\n\ndeg_centrality = nx.bipartite.degree_centrality(G, sender_nodes)\n\ndeg_centrality_series = pd.Series(list(deg_centrality.values()))\n\nprint(deg_centrality_series.describe())\n\nplt.yscale('log')\nplt.hist(deg_centrality.values(), bins=20)\nplt.title(\"Histogram of Degree Centrality (log scale)\")\nplt.show()","f20c7471":"receiver_dcs = [deg_centrality[n] for n in receiver_nodes]\nsender_dcs = [deg_centrality[n] for n in sender_nodes]\n\nprint(\"Summary Statistics for Sender Degree Centralities:\")\nprint(pd.Series(sender_dcs).describe())\nprint()\nprint(\"Summary Statistics for Receiver Degree Centralities\")\nprint(pd.Series(receiver_dcs).describe())\n\nfig, ax = plt.subplots(1,2)\n\nplt.yscale('log')\nax[0].hist(sender_dcs, label='Sender', color='b')\nax[1].hist(receiver_dcs, label='Receiver', color='r')\nplt.show()","5d03fbfa":"temp = df.groupby(by=['senderid']).sender_attractive.mean()\nsender_attractive_series = pd.Series([temp[n] for n in sender_nodes])\n\ntemp = df.groupby(by=['receiverid']).receiver_attractive.mean()\nreceiver_attractive_series = pd.Series([temp[n] for n in receiver_nodes])\n\nprint(\"Summary Statistics for Sender Attractiveness Score: \")\nprint(sender_attractive_series.describe())\nprint()\nprint(\"Summary Statistics for Receiver Attractiveness Score:\")\nprint(receiver_attractive_series.describe())\n\nfig, ax = plt.subplots(1,2)\n\nax[0].hist(sender_attractive_series, alpha=0.5, label='M', color='b')\nax[1].hist(receiver_attractive_series, alpha=0.5, label='F', color='r')\nplt.show()","b0920508":"plt.title(\"Sender Attractiveness Score vs. Sender Degree Centrality\")\nplt.scatter([math.log(s) for s in sender_dcs], sender_attractive_series, alpha = 0.01)\nplt.show()","368f0f85":"plt.title(\"Receiver Attractiveness Score vs. Receiver Degree Centrality\")\nplt.scatter([math.log(s) for s in receiver_dcs], receiver_attractive_series, alpha = 0.01)\nplt.show()","b42b2ecb":"def shared_partition_nodes(G, node1, node2):\n    \"\"\"\n    Returns the nodes which are neighbors of both node1 and node2\n    \n    Args:\n        G - a networkx graph object\n        node1 - a networkx node belonging to G\n        node2 - a networkx node belonging to G\n        \n    Output:\n        a set of nodes belonging to the other partition of the bipartite\n        graph which are neighbors of both node1 and node2.\n    \"\"\"\n    assert G.node[node1]['bipartite'] == G.node[node2]['bipartite']\n\n    nbrs1 = G.neighbors(node1)\n    nbrs2 = G.neighbors(node2)\n\n    return set(nbrs1).intersection(nbrs2)\n\ndef node_similarity(G, sender1, sender2, receiver_nodes):\n    \"\"\"\n    Returns a measure of the similarity between the nodes sender1 and sender2.\n    \n    Args:\n        G - a networkx Graph object representing a bipartite graph\n        sender1 - a node in G belonging to the same partition as sender2\n        sender2 - a node in G belonging to the same partition as sender1\n        receiver_nodes - a list of nodes in the other partition of the bipartite graph G\n        \n    Output:\n        a number between 0 and 1 representing the fraction of the total possible neighbors\n        that the nodes sender1 and sender 2 share.\n    \"\"\"\n    assert G.node[sender1]['bipartite'] == 'sender'\n    assert G.node[sender2]['bipartite'] == 'sender'\n\n    shared_nodes = shared_partition_nodes(G, sender1, sender2)\n\n    return len(shared_nodes) \/ len(receiver_nodes)\n\ndef most_similar_users(G, user, user_nodes, receiver_nodes):\n    \"\"\"\n    Returns a list of users with the highest similarity score to user.\n    \n    Args:\n        G - a networkx Graph object representing a bipartite graph\n        user - the node for which we want to find the most similar users\n        user_nodes - a list containing the other nodes in the same partition as the user node\n        receiver_nodes - a list of nodes in the other partition\n        \n    Output:\n        a list of users with the highest similarity score to user\n    \"\"\"\n    assert G.node[user]['bipartite'] == 'sender'\n\n    user_nodes = set(user_nodes)\n    user_nodes.remove(user)\n\n    similarities = defaultdict(list)\n    for n in user_nodes:\n        similarity = node_similarity(G, user, n, receiver_nodes)\n        similarities[similarity].append(n)\n\n    max_similarity = max(similarities.keys())\n\n    return similarities[max_similarity]\n\ndef suggest_receiver(G, from_user, to_user):\n    \"\"\"\n    Returns the set of all neighbors of from_user which are not neighbors of to_user.\n    \n    Args:\n        G - a networkx Graph object representing a bipartite graph\n        from_user - the user we are recommending from\n        to_user - the user we are recommending to\n        \n    Outputs:\n        a set of nodes representing the neighbors of from_user which are not neighbors\n        of to_user. If this set is empty, returns the set of all non-neighbors of the\n        to_user. If to_user is neighbors with all possible nodes, it returns the set of\n        all nodes.\n    \"\"\"\n    from_receivers =  set(G.neighbors(from_user))\n    to_receivers = set(G.neighbors(to_user))\n    suggestions = from_receivers.difference(to_receivers)\n    backup = set(receiver_nodes).difference(to_receivers)\n    if suggestions:\n        return suggestions\n    elif backup: # if intersected set is empty, return receivers the user hasn't messaged\n        return backup\n    else: #only if user has messaged every possible receiver\n        return set(receiver_nodes)\n\ndef recommend(G, user, sender_nodes, receiver_nodes):\n    \"\"\"\n    Recommends a profile for user to try messaging.\n    \"\"\"\n    most_similar = most_similar_users(G, user, sender_nodes, receiver_nodes)\n    if most_similar:\n        node2 = random.choice(most_similar)\n    else:\n        node2 = rando.choice(sender_nodes)\n    return random.choice(list(suggest_receiver(G, user, node2)))","0f935c9c":"user = random.choice(sender_nodes)\nprint(user)\nmost_sim = most_similar_users(G, user, sender_nodes, receiver_nodes)\nprint(most_sim)\nsuggest_receiver(G, user, random.choice(most_sim))\n\nprint(recommend(G, user, sender_nodes, receiver_nodes))","2c17733e":"In this data set, all of the messages originated from men. This is confirmed by the cell below. The value 0 corresponds to males and the value 1 corresponds to females.","e1636f2a":"The degree centrality of a node is defined to be the number of neighbors of that node divided by the total number of neighbors that node could have. For a sender node, the denominator would equal the total number of receiver nodes. Likewise, for a receiver node, the denominator would be the total number of sender nodes. Degree centrality of a sender node tells us what fraction of the receivers that particular user has messaged and for a receiver node the degree centrality tells us what fraction of the senders have messaged that receiver.","cdb529ba":"Let's investigate the age differences between message senders and receivers.","3f5ef5f9":"From the scatter plot above, it appears that women tend to receive messages from men of a fairly wide age range, while men send messages to women in narrower age ranges. We can make this more statistically rigorous with a bit of linear regression analysis. TBA.","df01f963":"However, the above plot indicates a positive relationship between receiver attractiveness and the number of messages she receives.","2ddc9057":"In order to build a recommender system based on this bipartite graph, we need to write a few functions which will allow us to look at and quantify the similarities between the senders' messages.\n","f536a27d":"The **nway** column encodes information about whether or not the sender's message was responded to by the receiver. A value of 1 indicates that the message was ignored. A value of 2 indicates that the receiver replied to the message, but the original sender did not reply to that message. A value of 3 indicates that the receiver replied to the message and the sender sent at least one more message back to the receiver. Thus, the above calculation shows us the following summary information.\n* 78% of messages received no response from the recipient.\n* 18% of messages received a response from the woman; however, the man did not continue the conversation as a result.\n* 4% of messages sent actually started some sort of conversation.\n\nWe can first figure out the number of users (senders and receivers) contained in this data set.","2e185e6d":"We can represent the messaging schemes as a bipartite graph with senders (men) in one partition and receivers (women) in the other partition. In the remainder of this kernel, we will focus on applying graph theory to this data set for the purposes of building a recommender system that suggests profiles the sender may want to message. To start, we need to build a bipartite graph from this data set. One partition will contain the senders (men) and the other will contain the receivers (women).","2307b30e":"From the summary statistics, we can see that men sent a median of 14 messages to different women on the platform. Note the distribution of sender degree centralities is skewed right and that one user messaged around 22.5% of the women on the site! This suggests that the earlier comparison of attractiveness distributions of senders and receivers was not exactly correct. The rows in our original data frame corresponded to messages rather than users. A more appropriate comparison of the distributions of sender and receiver attractiveness would count each sender and each receiver only once.\n\nWe will first create scatter plots to invesitgate the relationship between degree centrality and attractiveness scores. We will then remake the histograms presnted earlier by averaging creating a series that only counts each users' attractiveness score once per user rather than once per message. This will give a better indication of how attractiveness ratings vary between senders (males) and receivers (females).","9e841196":"There doesn't appear to be much of a relationship between the attractiveness of the sender and the percentage of users that he messages.","f2bf0d89":"Although this graph has the same shape, standardization seems to have greatly reduced the gap in attractiveness scores between senders and receivers. This can be confirmed with the calculations performed below.","2ed19b49":"Since there are very few messages from men to other men, we elect to drop these from our analysis for the remainder of this investigation.","9358434f":"This lets us know our data was collected over about six and a half months.","90d3ed97":"The statistics presented in the cell above do not separate the sender and receiver nodes from the bipatrite graph. We separate the partiions below and compute summary statistics for each partition along with plotting logarithmically scaled histograms for the degree centrality.","5e35d2b5":"This notebook is an adaptation of previous joint work with Karen Ertrachter, Tuba Kestin, and Michael Hauser. Much of this work was originally performed in R. I reworked this project as a means of getting practice with some graph packages in Python.","976adf3d":"From the analysis above, we see that the men have overall lower attractiveness scores than the women. We will confirm the statistical significance of this observation rigorously below by using Welch's t-test. It should be noted that this histogram is based on treating each message as a statistical unit. This point will be revisited later in the kernel when we begin analyzing the data through a bipartite graph.","4c24d715":"On average, men send message to women who are about 2 years younger than them. There was one man who messaged someone 42 years younger than him and one man who messaged someone 44 years older than him. Only 25% of messages were sent to women older than the sender.\n\nLet's perform the same analysis based on the difference in attractiveness ratings between the men and women.","80d9bfb6":"We see that on average the women receiving messages were typically of a higher attractiveness rating (by about 1.5 standard deviations) than the men messaging them. Let's investigate how the distribution of attractiveness scores compare for men and women.\n","4989a1ec":"Most of the messages from the men were sent to female users, as the cell below confirms.","a915f3e0":"The p-value of 0.0 supports our previous observation. We can now standardize each column and see whether or not standardizing the distributions to account for the differences in scoring by men and women accounts for the tendency of men to send messages to women who have higher attractiveness ratings than they do."}}