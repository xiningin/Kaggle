{"cell_type":{"6fbbdd92":"code","2db3dbe6":"code","c3ffad4a":"code","67bf041f":"code","ef86dccc":"code","f23b8031":"code","97d953df":"code","0b9ecbaf":"code","fba2a09c":"code","21b5ff03":"code","5432fe33":"code","9606533b":"code","4a9d7c8e":"code","215ebc76":"code","bab2ea98":"code","54dee6fd":"code","d430aafe":"code","78b1e2c8":"code","521bff3d":"code","c35ca097":"code","352ad339":"code","f917b1ef":"markdown","8e31a9a4":"markdown","a97f358f":"markdown","46efe101":"markdown","1a30c977":"markdown","fdacd9c7":"markdown","1e77a045":"markdown","2fea3bc0":"markdown","9884b25a":"markdown","4b00d729":"markdown","4e5125e1":"markdown"},"source":{"6fbbdd92":"!conda install '..\/input\/gdcm-file\/libjpeg-turbo-2.1.0-h7f98852_0.tar.bz2' -y --offline\n!conda install '..\/input\/gdcm-file\/\/libgcc-ng-9.3.0-h2828fa1_19.tar.bz2' -y --offline\n!conda install '..\/input\/gdcm-file\/\/gdcm-2.8.9-py37h500ead1_1.tar.bz2' -y --offline\n!conda install '..\/input\/gdcm-file\/\/conda-4.10.1-py37h89c1867_0.tar.bz2' -y --offline\n!conda install '..\/input\/gdcm-file\/\/certifi-2020.12.5-py37h89c1867_1.tar.bz2' -y --offline\n!conda install '..\/input\/gdcm-file\/\/openssl-1.1.1k-h7f98852_0.tar.bz2' -y --offline","2db3dbe6":"!pip install timm","c3ffad4a":"import torch\n\nimport os\nimport math\nimport time\nimport random\nimport shutil\nfrom pathlib import Path\nfrom contextlib import contextmanager\nfrom collections import defaultdict, Counter\nimport glob\nimport scipy as sp\nimport numpy as np\nimport pandas as pd\n\nimport librosa\nfrom sklearn import preprocessing\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import StratifiedKFold, GroupKFold, KFold\n\nfrom tqdm.auto import tqdm\nfrom functools import partial\nimport tensorflow as tf\nimport cv2\nfrom PIL import Image\nimport re\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.optim import Adam, SGD\nimport torchvision.models as models\nfrom torch.nn.parameter import Parameter\nfrom torch.utils.data import DataLoader, Dataset\nfrom torch.optim.lr_scheduler import CosineAnnealingWarmRestarts, CosineAnnealingLR, ReduceLROnPlateau\nimport albumentations as A\nfrom albumentations.pytorch import ToTensorV2\nfrom albumentations import ImageOnlyTransform\nimport matplotlib.pyplot as plt\nfrom torch.utils import data as torch_data\nimport timm\n\nfrom torch.cuda.amp import autocast, GradScaler\nimport pydicom\nfrom pydicom.pixel_data_handlers.util import apply_voi_lut\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nimport os\n\nOUTPUT_DIR = '.\/'\nif not os.path.exists(OUTPUT_DIR):\n    os.makedirs(OUTPUT_DIR)","67bf041f":"timm.list_models()","ef86dccc":"train = pd.read_csv('..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train_labels.csv')\ntrain['BraTS21ID'] =train['BraTS21ID'].apply(lambda x: str(x).zfill(5))\ntest = pd.read_csv('..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/sample_submission.csv')\ntest['BraTS21ID'] =test['BraTS21ID'].apply(lambda x: str(x).zfill(5))\ndef get_train_file_path(image_id):\n    return \"..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/{}\".format(image_id)\n\ndef get_test_file_path(image_id):\n    return \"..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/test\/{}\".format(image_id)\n\ntrain['file_path'] = train['BraTS21ID'].apply(get_train_file_path)\ntest['file_path'] = test['BraTS21ID'].apply(get_test_file_path)\n\nprint(len(train))\ndisplay(train.head())\ndisplay(test.head())","f23b8031":"train.loc[0,'file_path']","97d953df":"# ====================================================\n# Utils\n# ====================================================\ndef get_score(y_true, y_pred):\n    score = roc_auc_score(y_true, y_pred)\n    return score\n\ndef init_logger(log_file=OUTPUT_DIR+'train.log'):\n    from logging import getLogger, INFO, FileHandler,  Formatter,  StreamHandler\n    logger = getLogger(__name__)\n    logger.setLevel(INFO)\n    handler1 = StreamHandler()\n    handler1.setFormatter(Formatter(\"%(message)s\"))\n    handler2 = FileHandler(filename=log_file)\n    handler2.setFormatter(Formatter(\"%(message)s\"))\n    logger.addHandler(handler1)\n    logger.addHandler(handler2)\n    return logger\n\nLOGGER = init_logger()\n\ndef seed_torch(seed=42):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n\n#seed_torch(seed=CFG.seed)\n    ","0b9ecbaf":"class CFG:\n    sliced =0\n    apex=False\n    debug=False\n    print_freq=100\n    num_workers=4\n    #odel_name='nfnet_l0'\n    \n    scheduler='CosineAnnealingLR' # ['ReduceLROnPlateau', 'CosineAnnealingLR', 'CosineAnnealingWarmRestarts']\n    epochs=3#3\n    T_max=3 # CosineAnnealingLR\n    #T_0=3 # CosineAnnealingWarmRestarts\n    lr=1e-4\n    min_lr=1e-6\n    batch_size=8 #64\n    weight_decay=1e-6\n    gradient_accumulation_steps=1\n    max_grad_norm=1000\n    seed=42\n    target_size=1\n    target_col='MGMT_value'\n    n_fold=2 #5\n    trn_fold=[0, 1]  #, 2, 3, 4]\n    train=True\n    mai =8\n    col ='FLAIR' #'T1w,T1wCE,T2w'\n    \nif CFG.debug:\n    CFG.epochs = 1\n    train = train.sample(n=5000, random_state=CFG.seed).reset_index(drop=True)\n    \ncfg = CFG()\n\nmri_types = ['FLAIR','T1w','T1wCE','T2w']\nSIZE = 256\nNUM_IMAGES = 64 #64\n\ndata_directory = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification'\n","fba2a09c":"train['fold'] = range(len(train))\ntrain['fold'] = train['fold'].apply(lambda x: x%5)\n    \ntrain.to_csv('study_train_df.csv')\ntrain.head(6)\n\n\n","21b5ff03":"def load_dicom_image(path, img_size=SIZE, voi_lut=True, rotate=0):\n    dicom = pydicom.read_file(path)\n    data = dicom.pixel_array\n    if voi_lut:\n        data = apply_voi_lut(dicom.pixel_array, dicom)\n    else:\n        data = dicom.pixel_array\n        \n    if rotate > 0:\n        rot_choices = [0, cv2.ROTATE_90_CLOCKWISE, cv2.ROTATE_90_COUNTERCLOCKWISE, cv2.ROTATE_180]\n        data = cv2.rotate(data, rot_choices[rotate])\n        \n    data = cv2.resize(data, (img_size, img_size))\n    return data\n\n\ndef load_dicom_images_3d(scan_id, num_imgs=NUM_IMAGES, img_size=SIZE, mri_type=\"FLAIR\", split=\"train\", rotate=0):\n\n    files = sorted(glob.glob(f\"{data_directory}\/{split}\/{scan_id}\/{mri_type}\/*.dcm\"), \n               key=lambda var:[int(x) if x.isdigit() else x for x in re.findall(r'[^0-9]|[0-9]+', var)])\n\n    middle = len(files)\/\/2\n    num_imgs2 = num_imgs\/\/2\n    p1 = max(0, middle - num_imgs2)\n    p2 = min(len(files), middle + num_imgs2)\n    #print(p1,p2)\n    img3d = np.stack([load_dicom_image(f, rotate=rotate) for f in files[p1:p2]]).T \n    if img3d.shape[-1] < num_imgs:\n        n_zero = np.zeros((img_size, img_size, num_imgs - img3d.shape[-1]))\n        img3d = np.concatenate((img3d,  n_zero), axis = -1)\n        \n    if np.min(img3d) < np.max(img3d):\n        img3d = img3d - np.min(img3d)\n        img3d = img3d \/ np.max(img3d)\n            \n    return np.expand_dims(img3d,0)\n\na = load_dicom_images_3d(\"00000\")\nprint(a.shape)\nprint(np.min(a), np.max(a), np.mean(a), np.median(a))","5432fe33":"# ====================================================\n# Dataset\n# ====================================================\nclass Dataset(torch_data.Dataset):\n    def __init__(self, paths, targets=None, mri_type=None, label_smoothing=0.01, split=\"train\", augment=False):\n        self.paths = paths\n        self.targets = targets\n        self.mri_type = mri_type\n        self.label_smoothing = label_smoothing\n        self.split = split\n        self.augment = augment\n          \n    def __len__(self):\n        return len(self.paths)\n        \n\n    def __getitem__(self, index):\n        \n        scan_id = self.paths[index]\n        if self.targets is None:\n            data = load_dicom_images_3d(str(scan_id).zfill(5), mri_type=self.mri_type, split=self.split)\n        else:\n            if self.augment:\n                rotation = np.random.randint(0,4)\n            else:\n                rotation = 0\n\n            data = load_dicom_images_3d(str(scan_id).zfill(5), mri_type=self.mri_type, split=\"train\", rotate=rotation)\n\n        if self.targets is None:\n            return torch.tensor(data).float(), scan_id\n        else:\n            y = torch.tensor(self.targets[index], dtype=torch.float)\n            return torch.tensor(data).float(), y","9606533b":"# ====================================================\n# Transforms\n# ====================================================\ndef get_transforms(*, data):\n    \n    if data == 'train':\n        return A.Compose([\n            ToTensorV2(),\n        ])\n\n    elif data == 'valid':\n        return A.Compose([\n            ToTensorV2(),\n        ])","4a9d7c8e":"# ====================================================\n# MODEL\n# ====================================================\nclass CustomModel(nn.Module):\n    def __init__(self, cfg, pretrained=False):\n        super().__init__()\n        self.cfg = cfg\n        chan=1\n        if model_name.split('_')[0][:9]  =='seresnext':\n            self.model = timm.create_model(model_name ,pretrained=pretrained, in_chans=chan)\n            self.n_features = self.model.fc.in_features\n            self.model.fc = nn.Linear(self.n_features, self.cfg.target_size)\n\n        if model_name.split('_')[0] =='efficientnet':\n            self.model = timm.create_model(model_name, pretrained=pretrained, in_chans=chan)\n            self.n_features = self.model.classifier.in_features\n            self.model.classifier = nn.Linear(self.n_features, self.cfg.target_size)\n\n        if model_name.split('_')[0] =='tf':\n            self.model = timm.create_model(model_name, pretrained=pretrained, in_chans=chan)\n            self.n_features = self.model.classifier.in_features\n            self.model.classifier = nn.Linear(self.n_features, self.cfg.target_size)\n\n        \n        if model_name.split('_')[0] =='nfnet':   \n            self.model = timm.create_model(model_name, pretrained=pretrained, in_chans=chan)\n            self.n_features = self.model.head.fc.in_features\n            self.model.head.fc = nn.Linear(self.n_features, self.cfg.target_size)\n            \n        if model_name.split('_')[0] =='vit':\n            self.model = timm.create_model(model_name, pretrained=pretrained)\n            self.n_features = self.model.head.in_features\n            self.model.head = nn.Linear(self.n_features, CFG.target_size)\n\n        \n    def forward(self, x):\n        output = self.model(x)\n        return output","215ebc76":"class AverageMeter(object):\n    \"\"\"Computes and stores the average and current value\"\"\"\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.val = 0\n        self.avg = 0\n        self.sum = 0\n        self.count = 0\n\n    def update(self, val, n=1):\n        self.val = val\n        self.sum += val * n\n        self.count += n\n        self.avg = self.sum \/ self.count\n\n\ndef asMinutes(s):\n    m = math.floor(s \/ 60)\n    s -= m * 60\n    return '%dm %ds' % (m, s)\n\n\ndef timeSince(since, percent):\n    now = time.time()\n    s = now - since\n    es = s \/ (percent)\n    rs = es - s\n    return '%s (remain %s)' % (asMinutes(s), asMinutes(rs))","bab2ea98":"\n    model_name='seresnet152'\n    folds = train\n    fold =0\n    trn_idx = folds[folds['fold'] != fold].index\n    val_idx = folds[folds['fold'] == fold].index\n\n    train_folds = folds.loc[trn_idx].reset_index(drop=True)\n    valid_folds = folds.loc[val_idx].reset_index(drop=True)\n    valid_labels = valid_folds[CFG.target_col].values\n    \n    train_dataset = Dataset(train_folds.BraTS21ID,targets=train_folds.MGMT_value,mri_type='FLAIR') #, transform=get_transforms(data='train'))\n    valid_dataset = Dataset(valid_folds.BraTS21ID,targets=valid_folds.MGMT_value,mri_type='FLAIR') #, transform=get_transforms(data='valid'))\n\n    train_loader = DataLoader(train_dataset,\n                              batch_size=CFG.batch_size, \n                              shuffle=True, \n                              num_workers=CFG.num_workers, pin_memory=True, drop_last=True)\n    valid_loader = DataLoader(valid_dataset, \n                              batch_size=CFG.batch_size * 2, \n                              shuffle=False, \n                              num_workers=CFG.num_workers, pin_memory=True, drop_last=False)\n    \n    model = CustomModel(CFG, pretrained=True)\n    model.to(device)\n\n    \n    if CFG.apex:\n        scaler = GradScaler()\n    batch_time = AverageMeter()\n    data_time = AverageMeter()\n    losses = AverageMeter()\n    scores = AverageMeter()\n    # switch to train mode\n    model.train()\n    start = end = time.time()\n    global_step = 0\n    for step, (images, labels) in tqdm(enumerate(train_loader)):\n        print('step',step)\n        break\n    \n      ","54dee6fd":"images.shape","d430aafe":"def train_fn(train_loader, model, criterion, optimizer, epoch, scheduler, device):\n    if CFG.apex:\n        scaler = GradScaler()\n    batch_time = AverageMeter()\n    data_time = AverageMeter()\n    losses = AverageMeter()\n    scores = AverageMeter()\n    # switch to train mode\n    model.train()\n    start = end = time.time()\n    global_step = 0\n    for step, (images, labels) in tqdm(enumerate(train_loader)):\n      images = np.array(images)\n      images = images.transpose(4,0,1,2,3)\n      #print(images.shape)\n      images = torch.tensor(images)\n      for i in range(images.shape[0]):\n       #for x in range(images.shape[1]):\n       #for x in range(images.shape[1]):\n        #print(images.shape[4])\n        data_time.update(time.time() - end)\n        image = torch.tensor(images[i])\n        #print('#',image.shape)\n        #image = torch.tensor(image[:,:,:,np.newaxis])\n        image = image.to(device)\n        label = torch.tensor(labels[step\/\/NUM_IMAGES])\n        label = label.to(device)\n        batch_size = cfg.batch_size\n        if CFG.apex:\n            with autocast():\n                y_preds = model(image)\n                loss = criterion(y_preds.view(-1), label)\n        else:\n            y_preds = model(image)\n            #print('@@@@',y_preds,y_preds.view(-1)[0],label)\n            loss = criterion(y_preds.view(-1)[0], label)\n        # record loss\n        losses.update(loss.item(), batch_size)\n        if CFG.gradient_accumulation_steps > 1:\n            loss = loss \/ CFG.gradient_accumulation_steps\n        if CFG.apex:\n            scaler.scale(loss).backward()\n        else:\n            loss.backward()\n        grad_norm = torch.nn.utils.clip_grad_norm_(model.parameters(), CFG.max_grad_norm)\n        if (step + 1) % CFG.gradient_accumulation_steps == 0:\n            if CFG.apex:\n                scaler.step(optimizer)\n                scaler.update()\n            else:\n                optimizer.step()\n            optimizer.zero_grad()\n            global_step += 1\n        # measure elapsed time\n        batch_time.update(time.time() - end)\n        end = time.time()\n        if i==(images.shape[0]-1):# and i==(images.shape[0]-1):\n        #if step % CFG.print_freq == 0 or step == (len(train_loader)-1):\n            print('Epoch: [{0}][{1}\/{2}] '\n                  'Data {data_time.val:.3f} ({data_time.avg:.3f}) '\n                  'Elapsed {remain:s} '\n                  'Loss: {loss.val:.4f}({loss.avg:.4f}) '\n                  'Grad: {grad_norm:.4f}  '\n                  #'LR: {lr:.6f}  '\n                  .format(\n                   epoch+1, step, len(train_loader), batch_time=batch_time,\n                   data_time=data_time, loss=losses,\n                   remain=timeSince(start, float(step+1)\/len(train_loader)),\n                   grad_norm=grad_norm,\n                   #lr=scheduler.get_lr()[0],\n                   ))  \n    return losses.avg\n\ndef valid_fn(valid_loader, model, criterion, device):\n    batch_time = AverageMeter()\n    data_time = AverageMeter()\n    losses = AverageMeter()\n    scores = AverageMeter()\n    # switch to evaluation mode\n    model.eval()\n    preds_sum=[]\n    start = end = time.time()\n    for step, (images, labels) in enumerate(valid_loader):\n        # measure data loading time\n      \n      preds = []\n      images = np.array(images)\n      images = images.transpose(4,0,1,2,3)\n      images = torch.tensor(images)\n      #print(images.shape)\n      for i in range(images.shape[0]):\n       #for x in range(images.shape[1]):\n        #print(images.shape[4])\n        data_time.update(time.time() - end)\n        image = torch.tensor(images[i])\n        #image = torch.tensor(image[:,:,:,np.newaxis])\n        image = image.to(device)\n        label = torch.tensor(labels)\n        label = label.to(device)\n        batch_size = cfg.batch_size\n        # compute loss\n        with torch.no_grad():\n            y_preds = model(image)\n        #print('@@@@',y_preds,y_preds.view(-1)[0],label,label[0])\n        loss = criterion(y_preds.view(-1), label)\n        losses.update(loss.item(), batch_size)\n        # record accuracy\n        preds.append(y_preds.sigmoid().to('cpu').numpy())\n        if CFG.gradient_accumulation_steps > 1:\n            loss = loss \/ CFG.gradient_accumulation_steps\n        # measure elapsed time\n        batch_time.update(time.time() - end)\n        end = time.time()\n        if i==(images.shape[0]-1):\n        #if step % CFG.print_freq == 0 or step == (len(valid_loader)-1):\n            print('EVAL: [{0}\/{1}] '\n                  'Data {data_time.val:.3f} ({data_time.avg:.3f}) '\n                  'Elapsed {remain:s} '\n                  'Loss: {loss.val:.4f}({loss.avg:.4f}) '\n                  .format(\n                   step, len(valid_loader), batch_time=batch_time,\n                   data_time=data_time, loss=losses,\n                   remain=timeSince(start, float(step+1)\/len(valid_loader)),\n                   ))\n       #print(step,i,images.shape[0])\n        if i %(images.shape[0]-1)==0 and i!=0:\n           preds_sum.append(np.mean(preds)) #\u3053\u3053\u306764\u679a\u306e\u4e88\u6e2c\u5e73\u5747\u306e\u7b97\u51fa\u304c\u5fc5\u8981   \n           #print('##',step,' ',i,' ',len(preds_sum))\n    predictions = preds_sum\n    return losses.avg, predictions","78b1e2c8":"    '''\n    #def train_loop(folds, fold,mri):\n    folds=train\n    fold =0\n    model_name='tf_efficientnetv2_m'\n    mri='FLAIR'\n    \n    LOGGER.info(f\"========== fold: {fold} training ==========\")\n\n    # ====================================================\n    # loader\n    # ====================================================\n    trn_idx = folds[folds['fold'] != fold].index\n    val_idx = folds[folds['fold'] == fold].index\n\n    train_folds = folds.loc[trn_idx].reset_index(drop=True)\n    valid_folds = folds.loc[val_idx].reset_index(drop=True)\n    valid_labels = valid_folds[CFG.target_col].values\n\n    train_dataset = Dataset(train_folds.BraTS21ID,targets=train_folds.MGMT_value,mri_type=mri)\n    valid_dataset = Dataset(valid_folds.BraTS21ID,targets=valid_folds.MGMT_value,mri_type=mri)\n\n    train_loader = DataLoader(train_dataset,\n                              batch_size=CFG.batch_size, \n                              shuffle=True, \n                              num_workers=CFG.num_workers, pin_memory=True, drop_last=True)\n    valid_loader = DataLoader(valid_dataset, \n                              batch_size=1, #CFG.batch_size, \n                              shuffle=False, \n                              num_workers=CFG.num_workers, pin_memory=True, drop_last=False)\n       # ====================================================\n    # scheduler \n    # ====================================================\n    def get_scheduler(optimizer):\n        if CFG.scheduler=='ReduceLROnPlateau':\n            scheduler = ReduceLROnPlateau(optimizer, mode='min', factor=CFG.factor, patience=CFG.patience, verbose=True, eps=CFG.eps)\n        elif CFG.scheduler=='CosineAnnealingLR':\n            scheduler = CosineAnnealingLR(optimizer, T_max=CFG.T_max, eta_min=CFG.min_lr, last_epoch=-1)\n        elif CFG.scheduler=='CosineAnnealingWarmRestarts':\n            scheduler = CosineAnnealingWarmRestarts(optimizer, T_0=CFG.T_0, T_mult=1, eta_min=CFG.min_lr, last_epoch=-1)\n        return scheduler\n\n    # ====================================================\n    # model & optimizer\n    # ====================================================\n    model = CustomModel(CFG, pretrained=True)\n    model.to(device)\n\n    optimizer = Adam(model.parameters(), lr=CFG.lr, weight_decay=CFG.weight_decay, amsgrad=False)\n    scheduler = get_scheduler(optimizer)\n\n    # ====================================================\n    # loop\n    # ====================================================\n    criterion = nn.BCEWithLogitsLoss()\n\n    best_score = 0.\n    best_loss = np.inf\n    \n    for epoch in range(CFG.epochs):\n        \n        start_time = time.time()\n        \n        # train\n        avg_loss = train_fn(train_loader, model, criterion, optimizer, epoch, scheduler, device)\n\n        # eval\n        avg_val_loss, preds = valid_fn(valid_loader, model, criterion, device)\n        \n        if isinstance(scheduler, ReduceLROnPlateau):\n            scheduler.step(avg_val_loss)\n        elif isinstance(scheduler, CosineAnnealingLR):\n            scheduler.step()\n        elif isinstance(scheduler, CosineAnnealingWarmRestarts):\n            scheduler.step()\n\n        # scoring\n        print(valid_labels, preds)\n        score = get_score(valid_labels, preds)\n\n        elapsed = time.time() - start_time\n\n        LOGGER.info(f'Epoch {epoch+1} - avg_train_loss: {avg_loss:.4f}  avg_val_loss: {avg_val_loss:.4f}  time: {elapsed:.0f}s')\n'''","521bff3d":"def train_loop(folds, fold,mri):\n    \n    LOGGER.info(f\"========== fold: {fold} training ==========\")\n\n    # ====================================================\n    # loader\n    # ====================================================\n    trn_idx = folds[folds['fold'] != fold].index\n    val_idx = folds[folds['fold'] == fold].index\n\n    train_folds = folds.loc[trn_idx].reset_index(drop=True)\n    valid_folds = folds.loc[val_idx].reset_index(drop=True)\n    valid_labels = valid_folds[CFG.target_col].values\n\n    train_dataset = Dataset(train_folds.BraTS21ID,targets=train_folds.MGMT_value,mri_type=mri)\n    valid_dataset = Dataset(valid_folds.BraTS21ID,targets=valid_folds.MGMT_value,mri_type=mri)\n\n    train_loader = DataLoader(train_dataset,\n                              batch_size=CFG.batch_size, \n                              shuffle=True, \n                              num_workers=CFG.num_workers, pin_memory=True, drop_last=True)\n    valid_loader = DataLoader(valid_dataset, \n                              batch_size=1, #CFG.batch_size, \n                              shuffle=False, \n                              num_workers=CFG.num_workers, pin_memory=True, drop_last=False)\n       # ====================================================\n    # scheduler \n    # ====================================================\n    def get_scheduler(optimizer):\n        if CFG.scheduler=='ReduceLROnPlateau':\n            scheduler = ReduceLROnPlateau(optimizer, mode='min', factor=CFG.factor, patience=CFG.patience, verbose=True, eps=CFG.eps)\n        elif CFG.scheduler=='CosineAnnealingLR':\n            scheduler = CosineAnnealingLR(optimizer, T_max=CFG.T_max, eta_min=CFG.min_lr, last_epoch=-1)\n        elif CFG.scheduler=='CosineAnnealingWarmRestarts':\n            scheduler = CosineAnnealingWarmRestarts(optimizer, T_0=CFG.T_0, T_mult=1, eta_min=CFG.min_lr, last_epoch=-1)\n        return scheduler\n\n    # ====================================================\n    # model & optimizer\n    # ====================================================\n    model = CustomModel(CFG, pretrained=True)\n    model.to(device)\n\n    optimizer = Adam(model.parameters(), lr=CFG.lr, weight_decay=CFG.weight_decay, amsgrad=False)\n    scheduler = get_scheduler(optimizer)\n\n    # ====================================================\n    # loop\n    # ====================================================\n    criterion = nn.BCEWithLogitsLoss()\n\n    best_score = 0.\n    best_loss = np.inf\n    \n    for epoch in range(CFG.epochs):\n        \n        start_time = time.time()\n        \n        # train\n        avg_loss = train_fn(train_loader, model, criterion, optimizer, epoch, scheduler, device)\n\n        # eval\n        avg_val_loss, preds = valid_fn(valid_loader, model, criterion, device)\n        \n        if isinstance(scheduler, ReduceLROnPlateau):\n            #scheduler.step(avg_val_loss)\n            continue\n        elif isinstance(scheduler, CosineAnnealingLR):\n            scheduler.step()\n        elif isinstance(scheduler, CosineAnnealingWarmRestarts):\n            scheduler.step()\n\n        # scoring\n        #print(valid_labels, preds)\n        score = get_score(valid_labels, preds)\n\n        elapsed = time.time() - start_time\n\n        LOGGER.info(f'Epoch {epoch+1} - avg_train_loss: {avg_loss:.4f}  avg_val_loss: {avg_val_loss:.4f}  time: {elapsed:.0f}s')\n        LOGGER.info(f'Epoch {epoch+1} - Score: {score:.4f}')\n\n        if score > best_score:\n            best_score = score\n            LOGGER.info(f'Epoch {epoch+1} - Save Best Score: {best_score:.4f} Model')\n            torch.save({'model': model.state_dict(), \n                        'preds': preds},\n                        OUTPUT_DIR+f'{model_name}_fold{fold}_{mri}_best_score.pth')\n        \n        #if avg_val_loss < best_loss:\n        #    best_loss = avg_val_loss\n        #    LOGGER.info(f'Epoch {epoch+1} - Save Best Loss: {best_loss:.4f} Model')\n        #    torch.save({'model': model.state_dict(), \n        #                'preds': preds},\n        #                OUTPUT_DIR+f'{model_name}_fold{fold}_{mri}_best_loss.pth')\n    \n    valid_folds['preds'] = torch.load(OUTPUT_DIR+f'{model_name}_fold{fold}_{mri}_best_score.pth', \n                                      map_location=torch.device('cpu'))['preds']\n\n    return valid_folds","c35ca097":"# ====================================================\n# main\n# ====================================================\ndef main():\n\n    \"\"\"\n    Prepare: 1.train \n    \"\"\"\n\n    def get_result(result_df):\n        preds = result_df['preds'].values\n        labels = result_df[CFG.target_col].values\n        score = get_score(labels, preds)\n        LOGGER.info(f'Score: {score:<.4f}')\n    \n    if CFG.train:\n        # train \n        oof_df = pd.DataFrame()\n        for fold in range(CFG.n_fold):\n            if fold in CFG.trn_fold:\n                _oof_df = train_loop(train, fold,mri)\n                oof_df = pd.concat([oof_df, _oof_df])\n                LOGGER.info(f\"========== fold: {fold} result ==========\")\n                get_result(_oof_df)\n        # CV result\n        LOGGER.info(f\"========== CV ==========\")\n        get_result(oof_df)\n        # save result\n        oof_df.to_csv(OUTPUT_DIR+'oof_df.csv', index=False)","352ad339":"if __name__ == '__main__':\n    model_name='seresnet152'\n    mri='FLAIR'\n    #main()\n    \n    mri='T1w'\n    #main()\n    \n    mri='T1wCE'\n    main()\n    \n    mri='T2w'\n    #main()","f917b1ef":"<span style=\"color: orange; font-family: Segoe UI; font-size: 1.9em; font-weight: 300;\">Training<\/span>","8e31a9a4":"<span style=\"color: orange; font-family: Segoe UI; font-size: 1.9em; font-weight: 300;\">Dataset<\/span>","a97f358f":"<span style=\"color: orange; font-family: Segoe UI; font-size: 1.9em; font-weight: 300;\">Data Load<\/span>","46efe101":"<span style=\"color: orange; font-family: Segoe UI; font-size: 1.9em; font-weight: 300;\">Functions<\/span>","1a30c977":"<span style=\"color: orange; font-family: Segoe UI; font-size: 1.9em; font-weight: 300;\">Settings<\/span>","fdacd9c7":"<span style=\"color: orange; font-family: Segoe UI; font-size: 1.9em; font-weight: 300;\">Model<\/span>","1e77a045":"\ud83d\ude3a\ud83d\ude05\u3299\ud83d\udd30\ud83d\uddd1\u2b1b\ud83d\udfe5\ud83d\udfe8\ud83d\udfe9","2fea3bc0":"<span style=\"color: orange; font-family: Segoe UI; font-size: 1.9em; font-weight: 300;\">Functions<\/span>","9884b25a":"![image.png](attachment:79b3abda-c80c-4db3-81fa-f2016ff3f280.png)","4b00d729":"<span style=\"color: orange; font-family: Segoe UI; font-size: 1.9em; font-weight: 300;\">Import<\/span>","4e5125e1":"### Debug"}}