{"cell_type":{"06a557fb":"code","ae1c5b80":"code","aa4150ce":"code","301a0ab8":"code","d4446bdb":"code","f01b0cbd":"code","98e67c1a":"code","750e1b1b":"code","4697f438":"code","690ec19a":"code","29b92c70":"code","2fcf5c12":"code","9d18fb58":"code","c864e23a":"code","7c44f239":"code","dfcf092b":"code","e2b2ef9c":"code","5e460d65":"code","96490af3":"code","6fbbb3a9":"code","937acc11":"code","f5f165f2":"code","3bd197fa":"code","66ceaa6a":"code","a242db83":"code","a0191137":"code","0b137d2d":"code","3a57ad91":"code","8f7819c6":"code","bcd000c5":"code","0c8f52d7":"code","c61bff7a":"code","11684a7b":"code","51d79807":"code","aac1af39":"code","188d70e9":"code","a7ca715a":"code","5911a4d1":"code","e936df5b":"code","d94c7643":"code","ca3a8203":"code","12889ba3":"code","e692532a":"code","d4b6d1f4":"code","84468fc6":"code","edbc9dc9":"code","19e04175":"code","fd3735fd":"code","6828805a":"code","be9eda06":"code","ce2d05d9":"code","4b374b28":"code","e2c01237":"code","8b969fa0":"markdown","d98f7171":"markdown","8246383e":"markdown","8a2d153a":"markdown","55c6fac6":"markdown","51dc1aad":"markdown","2f7ce787":"markdown","357f0f43":"markdown","533e0075":"markdown","db8df2ed":"markdown","e63718a1":"markdown","697422e1":"markdown","597e3bab":"markdown","0ecb4ed8":"markdown","56979480":"markdown","33a21693":"markdown","cffece66":"markdown","8ebfe3b3":"markdown","e1572adc":"markdown","81246e6f":"markdown","52529b88":"markdown","40a30dbf":"markdown","f5c2b614":"markdown","7a2b7350":"markdown","9ef84a9b":"markdown","1671635d":"markdown","5a776435":"markdown","d6c7ea3e":"markdown","4a61b605":"markdown","f7489987":"markdown","98d74f2d":"markdown","e1c48bce":"markdown","58486af9":"markdown","d5bc7847":"markdown","972871ac":"markdown","a86b50f1":"markdown","58afa651":"markdown","c21e27fb":"markdown","26d1e149":"markdown","17bd30a6":"markdown","2befac70":"markdown","f67a8699":"markdown","0d723f1e":"markdown","43cbe7f2":"markdown","1163d84b":"markdown","39663a17":"markdown","85a4ec3e":"markdown"},"source":{"06a557fb":"import numpy as np \nimport pandas as pd ","ae1c5b80":"raw_data_with_measures = pd.read_csv('\/kaggle\/input\/spotify-dataset-19212020-160k-tracks\/data.csv')\nraw_data_with_measures.head(4)","aa4150ce":"# lets see if there is missing data\n\ndef display_missing(df):    \n    for col in df.columns.tolist():   \n        print('{} column missing values: {}'.format(col, df[col].isnull().sum()))   \n    print('\\n')\n    \ndisplay_missing(raw_data_with_measures)","301a0ab8":"raw_data_with_measures['artists'] = raw_data_with_measures['artists'].apply(lambda x: x[1:-1].split(', ')) # makes the string lists in artists column into actual lists\n\nraw_data_with_measures = raw_data_with_measures.explode('artists') # opens the lists so that each artist is on a song has his own row with the song\n\nraw_data_with_measures['artists'] = raw_data_with_measures['artists'].apply(lambda x: x.strip(\"'\")) #  we want to take off the quotes on the artists\n\nraw_data =  raw_data_with_measures.loc[:,['artists','name','popularity','year']] # we will just focus on these columns for now, and rename our data to raw_data\n\n\nraw_data","d4446bdb":"raw_data['artists'].value_counts()","f01b0cbd":"import plotly.express as px\n\ndef top_n_artists_by_song_count(data, lower_bound, upper_bound):\n    \n    reindex_order = data['artists'].value_counts()[lower_bound:upper_bound].index[::-1]     \n    # order of index to make right values in right places\n        \n    total_value_of_songs = data['artists'].value_counts()[lower_bound:upper_bound].reindex(reindex_order)\n    \n    total_value_of_popularity =  data.groupby(['artists']).sum()['popularity'].reindex(reindex_order)   # so we can see their popularity too\n    \n    df = pd.DataFrame({('Artist ') :total_value_of_songs.index, \n                        ('Total Song Count '): total_value_of_songs.values,\n                        ('Total Artist Popularity '): total_value_of_popularity.values}) \n  \n    fig = px.bar(df, x = ('Total Song Count ') , y = ('Artist '),\n                    \n                     hover_data = [('Total Song Count '), ('Total Artist Popularity ')],\n                                       \n                     color = ('Total Song Count ') , title= f'Artists Song Count Ranked ({lower_bound+1},{upper_bound}) ',\n               \n                     height = 700  )\n\n    return fig.show()","98e67c1a":"top_n_artists_by_song_count(raw_data,0,20)","750e1b1b":"raw_data.groupby(\"artists\")[\"popularity\"].sum().sort_values(ascending=False).head(20)","4697f438":"def top_n_artists_by_popularity(data, lower_bound, upper_bound):\n    \n\n    reindex_order =  data.groupby(['artists']).sum()['popularity'].sort_values(ascending = False)[lower_bound:upper_bound].index[::-1]     \n    # order of index to make right values in right places\n        \n    total_value_of_popularity =  data.groupby(['artists']).sum()['popularity'].sort_values(ascending = False)[\n        lower_bound:upper_bound].reindex(reindex_order)\n    \n    total_songs = data['artists'].value_counts().round(0).reindex(reindex_order)   \n    \n    df = pd.DataFrame({('Artist ') :total_value_of_popularity.index, \n                        ('Total Artist Popularity '): total_value_of_popularity.values,\n                        ('Total Song Count '): total_songs.values}) \n  \n    fig = px.bar(df, x = ('Total Artist Popularity ') , y = ('Artist '),\n                    \n                     hover_data = [('Total Artist Popularity '), ('Total Song Count ')],\n                                       \n                     color = ('Total Artist Popularity ') , title= f'Artists Popularity Ranked ({lower_bound +1},{upper_bound})',\n               \n                     height = 700  )\n\n    return fig.show()","690ec19a":"top_n_artists_by_popularity(raw_data, 0, 20)","29b92c70":"# most popular by year\n\npop_year = raw_data.sort_values('popularity', ascending=False).groupby('year').first()\npop_year = pop_year.reset_index()\npop_year = pop_year[['year', 'artists', 'name', 'popularity']]\n\npop_year","2fcf5c12":"def top_songs_by_year(data, lower_bound, upper_bound):\n    \n    pop_year = data.sort_values('popularity', ascending=False).groupby('year').first()\n    pop_year = pop_year.reset_index()\n    pop_year = pop_year[['year', 'artists', 'name', 'popularity']]\n\n    reindex_order =  pop_year[lower_bound -1921  :upper_bound -1921].index[::-1]     \n    # order of index to make right values in right places\n        \n    total_song_popularity =  pop_year[lower_bound -1921 :upper_bound -1921].reindex(reindex_order)\n    \n    \n    df = pd.DataFrame({('Year ') :total_song_popularity['year'].values, \n                        ('Top Song Popularity '): total_song_popularity['popularity'].values,\n                        ('Artist '): total_song_popularity['artists'].values,\n                        ('Song '): total_song_popularity['name'].values })\n  \n    fig = px.line(df, x = ('Year ') , y = ('Top Song Popularity '),\n                    \n                     hover_data = [('Top Song Popularity '), ('Year '), ('Artist '), ('Song ') ],\n                  \n                     \n                                       \n                     title= f'Top Songs by Year ({lower_bound } - {upper_bound})', \n               \n                     height = 700  )\n    \n    fig.update_traces(mode='markers+lines')\n\n    return fig.show()","9d18fb58":"top_songs_by_year(raw_data, 1921,2020)","c864e23a":"# lets make a decades column to further sort our list\n\nraw_data['Song Decade'] = None\n\nraw_data.loc[(raw_data['year'] >= 1920) & (raw_data['year'] < 1930), 'Song Decade'] = '1920s'\nraw_data.loc[(raw_data['year'] >= 1930) & (raw_data['year'] < 1940), 'Song Decade'] = '1930s'\nraw_data.loc[(raw_data['year'] >= 1940) & (raw_data['year'] < 1950), 'Song Decade'] = '1940s'\nraw_data.loc[(raw_data['year'] >= 1950) & (raw_data['year'] < 1960), 'Song Decade'] = '1950s'\nraw_data.loc[(raw_data['year'] >= 1960) & (raw_data['year'] < 1970), 'Song Decade'] = '1960s'\nraw_data.loc[(raw_data['year'] >= 1970) & (raw_data['year'] < 1980) , 'Song Decade'] = '1970s'\nraw_data.loc[(raw_data['year'] >= 1980) & (raw_data['year'] < 1990) , 'Song Decade'] = '1980s'\nraw_data.loc[(raw_data['year'] >= 1990) & (raw_data['year'] < 2000) , 'Song Decade'] = '1990s'\nraw_data.loc[(raw_data['year'] >= 2000) & (raw_data['year'] < 2010) , 'Song Decade'] = '2000s'\nraw_data.loc[(raw_data['year'] >= 2010) & (raw_data['year'] < 2020) , 'Song Decade'] = '2010s'\nraw_data.loc[(raw_data['year'] >= 2020) & (raw_data['year'] < 2030) , 'Song Decade'] = '2020s'\n\nraw_data","7c44f239":"most_popular_song_decade = raw_data.sort_values('popularity', ascending=False).groupby('Song Decade').first()\nmost_popular_song_decade = most_popular_song_decade.reset_index()\nmost_popular_song_decade = most_popular_song_decade[['Song Decade', 'artists', 'name', 'popularity']]\n\nmost_popular_song_decade","dfcf092b":"most_pop_decade = raw_data.groupby([\"artists\",\"Song Decade\"])[\"popularity\"].sum()\nmost_pop_decade = most_pop_decade.reset_index()\nmost_pop_decade['Decade Song Count'] = raw_data.groupby([\"artists\",\"Song Decade\"])['artists'].value_counts().values\nmost_pop_decade = most_pop_decade.sort_values([\"Song Decade\",\"popularity\"], ascending = False)\nmost_pop_decade.groupby('Song Decade').first()","e2b2ef9c":"def top_artists_by_decade(data, decade, lower_bound, upper_bound): \n    \n    most_pop_decade = raw_data.groupby([\"artists\",\"Song Decade\"])[\"popularity\"].sum()\n    most_pop_decade = most_pop_decade.reset_index()\n    most_pop_decade['Decade Song Count'] = raw_data.groupby([\"artists\",\"Song Decade\"])['artists'].value_counts().values\n    most_pop_decade = most_pop_decade.sort_values([\"Song Decade\",\"popularity\"], ascending = False)\n    most_pop_decade = most_pop_decade[most_pop_decade['Song Decade'] == decade]\n    \n    reindex_order = most_pop_decade[lower_bound:upper_bound].index[::-1]     \n    # order of index to make right values in right places\n        \n    total_value_of_popularity =  most_pop_decade[lower_bound:upper_bound].reindex(reindex_order)\n    \n    df = pd.DataFrame({('Artist ') :total_value_of_popularity['artists'].values, \n                        ('Total Decade Popularity '): total_value_of_popularity['popularity'].values,\n                        ('Decade Song Count '): total_value_of_popularity['Decade Song Count'].values}) \n  \n    fig = px.bar(df, x = ('Total Decade Popularity ') , y = ('Artist '),\n                    \n                     hover_data = [('Total Decade Popularity '), ('Artist '), ('Decade Song Count ')],\n                                       \n                     color = ('Total Decade Popularity ') , title= f'Most Popular Artists {decade} Ranked ({lower_bound +1},{upper_bound})',\n               \n                     height = 700  )\n\n    return fig.show()","5e460d65":"top_artists_by_decade(raw_data, '2000s', 0, 20) ","96490af3":"song_count_decade = raw_data['Song Decade'].value_counts()\nsong_count_decade = song_count_decade.reset_index()\nsong_count_decade.columns = ['Decade', 'Song Count']\nsong_count_decade = song_count_decade.sort_values(by= 'Decade')\nsong_count_decade","6fbbb3a9":"import plotly.express as px\n\nfig = px.pie(song_count_decade, values= song_count_decade['Song Count'] , names= song_count_decade['Decade'], title='Songs Released in Each Decade')\nfig.update_traces(textposition='inside', textinfo='percent+label')\nfig.show()","937acc11":"raw_data_genre = pd.read_csv('\/kaggle\/input\/spotify-dataset-19212020-160k-tracks\/data_w_genres.csv')\nraw_data_genre.head(4)","f5f165f2":"# lets see if there is missing data\n\ndef display_missing(df):    \n    for col in df.columns.tolist():   \n        print('{} column missing values: {}'.format(col, df[col].isnull().sum()))   \n    print('\\n')\n    \ndisplay_missing(raw_data)","3bd197fa":"pd.options.mode.chained_assignment = None \n\ndata_genre = raw_data_genre.loc[:,['artists','count','genres','popularity']] # lets explore these columns for now\ndata_genre['genres'] = data_genre['genres'].apply(lambda x: x[1:-1].split(', '))  # makes it into actual list instead of string list\n\nfor i in data_genre.index:\n\n    data_genre['genres'].loc[i] = list(filter(None, data_genre['genres'][i]))  # filters out empty values in each list\n    \n\ndata_genre.head(10)","66ceaa6a":"count_genres = data_genre['genres'].explode().value_counts()\ncount_genres","a242db83":"def top_genres(data, lower_bound, upper_bound): \n    \n    count_genres = data_genre['genres'].explode().value_counts()    \n    \n    reindex_order = count_genres[lower_bound:upper_bound].index[::-1]     \n    # order of index to make right values in right places\n        \n    count_genres_ranked =  count_genres[lower_bound:upper_bound].reindex(reindex_order)\n    \n    df = pd.DataFrame({('Genre ') :count_genres_ranked.index, \n                        ('Artist Count '): count_genres_ranked.values}) \n  \n    fig = px.bar(df, x = ('Artist Count ' ) , y = ('Genre '),\n                    \n                     hover_data = [('Artist Count ' ) , ('Genre ')],\n                                       \n                     color = ('Artist Count ') , title= f'Most Popular Genres Ranked ({lower_bound +1},{upper_bound})',\n               \n                     height = 700  )\n\n    return fig.show()","a0191137":"top_genres(data_genre, 0, 20)","0b137d2d":"genre_counts = raw_data_genre.groupby('genres')['artists'].count().sort_values(ascending=False)  \ngenre_counts.head(10)","3a57ad91":"missing_genre_artists = data_genre[data_genre['genres'].map(lambda x: len(x)) < 1]\nmissing_genre_artists","8f7819c6":"missing_genre_artists_split = missing_genre_artists.copy()\nmissing_genre_artists_split['artists'] = missing_genre_artists_split['artists'].apply(lambda x: x.split())  # split into words\nmissing_genre_artists_split","bcd000c5":"# lets find most common words in artists\n\ndef word_count(data):\n\n    all_words = []  \n    for elmnt in data['artists']:  \n        all_words += elmnt  \n\n    val_counts = pd.Series(all_words).value_counts()\n\n    return val_counts.head(40)\n\nword_count(missing_genre_artists_split)","0c8f52d7":"data_genre[data_genre['genres'].map(lambda x: len(x)) < 1].sort_values(ascending = False,by = 'count').head(20)","c61bff7a":"pd.options.mode.chained_assignment = None \n\nfor i in data_genre.index:\n    \n    if 'Broadway' in data_genre['artists'].loc[i]:\n        data_genre['genres'].loc[i].append(\"'broadway'\")\n    if 'Motion Picture' in data_genre['artists'].loc[i]:\n        data_genre['genres'].loc[i].append(\"'movie tunes'\")\n    if 'Cast' in data_genre['artists'].loc[i]:\n        data_genre['genres'].loc[i].append(\"'ensemble'\")     # we will put any cast artists under ensemble genre \n    if 'Ensemble' in data_genre['artists'].loc[i]:\n        data_genre['genres'].loc[i].append(\"'ensemble'\")  \n    if 'Orchestra' in data_genre['artists'].loc[i]:\n        data_genre['genres'].loc[i].append(\"'orchestra'\")\n    if 'Orquesta' in data_genre['artists'].loc[i]:              # these are just vara\n        data_genre['genres'].loc[i].append(\"'orchestra'\")\n    if 'Orchestre' in data_genre['artists'].loc[i]:\n        data_genre['genres'].loc[i].append(\"'orchestra'\")\n    if 'Chorus' in data_genre['artists'].loc[i]:\n        data_genre['genres'].loc[i].append(\"'chorus'\")\n    if 'Choir' in data_genre['artists'].loc[i]:\n        data_genre['genres'].loc[i].append(\"'choir'\")\n        \n    data_genre['genres'].loc[i] = list(dict.fromkeys(data_genre['genres'].loc[i])) # removes duplicates\n    \n\ndata_genre.head(12)","11684a7b":"final_data_genre = data_genre[data_genre['genres'].map(lambda x: len(x)) > 0] # removes empty lists\nfinal_data_genre = final_data_genre.reset_index(drop=True)\nfinal_data_genre = final_data_genre.drop('count', axis =1 )\nfinal_data_genre.rename(columns={'popularity': 'Artist Popularity'}, inplace=True)\nfinal_data_genre['Artist Popularity'] = final_data_genre['Artist Popularity'].astype(int)\nfinal_data_genre","51d79807":"def rank_artist_similarity(data, artist, genre_parameter):\n    artist_data = data[data.artists == artist]\n    artist_genres = set(*artist_data.genres)\n    similarity_data = data.drop(artist_data.index)\n    similarity_data.genres = similarity_data.genres.apply(lambda genres: list(set(genres).intersection(artist_genres)))\n    similarity_lengths = similarity_data.genres.str.len()\n    similarity_data = similarity_data.reindex(similarity_lengths[similarity_lengths >= genre_parameter].sort_values(ascending=False).index)\n    similarity_data.rename(columns={'artists': f'Similar Artists to {artist}', 'genres': 'Similar Genres', 'popularity': 'Artist Popularity'}, inplace=True)\n    return similarity_data","aac1af39":"rank_artist_similarity(final_data_genre, 'Eminem',3)","188d70e9":"rank_artist_similarity(final_data_genre, 'Foo Fighters',6)","a7ca715a":"rank_artist_similarity(final_data_genre, 'Taylor Swift',3)","5911a4d1":"merged_df = raw_data.merge(final_data_genre, how = 'inner', on = ['artists'])\nmerged_df_copy = merged_df.copy()\nmerged_df_copy.rename(columns={'artists': 'Artist', 'name':'Song Name','popularity':'Song Popularity','year':'Year','genres':'Genres'}, inplace=True)\n\nmerged_df_copy","e936df5b":"def rank_song_similarity(data, song, artist, genre_parameter):\n    \n    song_and_artist_data = data[(data.Artist == artist) & (data['Song Name'] == song)].sort_values('Year')[0:1]  # this ensures the first song is picked, not any remasters\n    artist_genres = set(*song_and_artist_data.Genres)\n\n    similarity_data = data[~data.Artist.str.contains(artist)] # drops the artist from the dataframe\n    \n    similarity_data.Genres = similarity_data.Genres.apply(lambda Genres: list(set(Genres).intersection(artist_genres)))\n    \n    similarity_lengths = similarity_data.Genres.str.len()\n    similarity_data = similarity_data.reindex(similarity_lengths[similarity_lengths >= genre_parameter].sort_values(ascending=False).index)\n    \n    similarity_data = similarity_data[similarity_data['Song Decade'] == song_and_artist_data['Song Decade'].values[0]]\n    \n    similarity_data = similarity_data.sort_values(by ='Song Popularity', ascending = False)\n    \n    \n    similarity_data.rename(columns={'Song Name': f'Similar Song to {song}', 'Genres' : 'Similar Genres'}, inplace=True)\n    return similarity_data.head(30)\n","d94c7643":"rank_song_similarity(merged_df_copy, 'Bohemian Rhapsody', 'Queen',2)","ca3a8203":"rank_song_similarity(merged_df_copy, 'Learn to Fly', 'Foo Fighters',4)","12889ba3":"rank_song_similarity(merged_df_copy, 'Learn to Fly', 'Foo Fighters',3)","e692532a":"rank_song_similarity(merged_df_copy, 'Without Me', 'Eminem',2)","d4b6d1f4":"rank_song_similarity(merged_df_copy, 'Without Me', 'Eminem',3)","84468fc6":"merged_df_with_measures = raw_data_with_measures.merge(final_data_genre, how = 'inner', on = ['artists'])\nmerged_df_with_measures.rename(columns={'artists': 'Artist', 'name':'Song Name','popularity':'Song Popularity','year':'Year','genres':'Genres'}, inplace=True)\nmerged_df_with_measures = merged_df_with_measures.drop(['duration_ms','explicit','id','release_date'], axis =1 )\n\nmerged_df_with_measures","edbc9dc9":"# this is missing the song deacades, lets put it in again\n\nmerged_df_with_measures['Song Decade'] = None\n\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 1920) & (merged_df_with_measures['Year'] < 1930), 'Song Decade'] = '1920s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 1930) & (merged_df_with_measures['Year'] < 1940), 'Song Decade'] = '1930s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 1940) & (merged_df_with_measures['Year'] < 1950), 'Song Decade'] = '1940s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 1950) & (merged_df_with_measures['Year'] < 1960), 'Song Decade'] = '1950s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 1960) & (merged_df_with_measures['Year'] < 1970), 'Song Decade'] = '1960s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 1970) & (merged_df_with_measures['Year'] < 1980) , 'Song Decade'] = '1970s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 1980) & (merged_df_with_measures['Year'] < 1990) , 'Song Decade'] = '1980s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 1990) & (merged_df_with_measures['Year'] < 2000) , 'Song Decade'] = '1990s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 2000) & (merged_df_with_measures['Year'] < 2010) , 'Song Decade'] = '2000s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 2010) & (merged_df_with_measures['Year'] < 2020) , 'Song Decade'] = '2010s'\nmerged_df_with_measures.loc[(merged_df_with_measures['Year'] >= 2020) & (merged_df_with_measures['Year'] < 2030) , 'Song Decade'] = '2020s'\n\nmerged_df_with_measures","19e04175":"columns_reorder = ['Artist', 'Song Name', 'Song Popularity','Year','Genres','Artist Popularity', 'Song Decade', 'acousticness', \n                   'danceability', 'energy', 'instrumentalness', 'key', 'liveness', 'loudness', 'mode', 'speechiness', 'tempo', 'valence']\n\nmerged_df_with_measures = merged_df_with_measures.reindex(columns=columns_reorder)\n\nmerged_df_with_measures","fd3735fd":"song_data= merged_df_with_measures.loc[:,['acousticness', 'danceability', 'energy', 'instrumentalness', 'key',\n       'liveness', 'loudness', 'mode', 'speechiness', 'tempo', 'valence']]\n\nfrom sklearn.preprocessing import MinMaxScaler\nscaler = MinMaxScaler()\n\nsong_features = pd.DataFrame()\n\nfor col in song_data.iloc[:,:].columns:    \n       \n    scaler.fit(song_data[[col]])\n    song_features[col] = scaler.transform(song_data[col].values.reshape(-1,1)).ravel() ","6828805a":"song_features","be9eda06":"data_to_merge = merged_df_with_measures.drop(['acousticness', 'danceability',\n       'energy', 'instrumentalness', 'key', 'liveness', 'loudness', 'mode',\n       'speechiness', 'tempo', 'valence'], axis = 1)\n\nfinal_merged_df = data_to_merge.join(song_features)\nfinal_merged_df","ce2d05d9":"from sklearn.metrics.pairwise import cosine_similarity, euclidean_distances\n\ndef rank_song_similarity_by_measure(data, song, artist, genre_parameter):\n    \n    song_and_artist_data = data[(data.Artist == artist) & (data['Song Name'] == song)].sort_values('Year')[0:1]\n    \n    similarity_data = data.copy()\n    \n    data_values = similarity_data.loc[:,['acousticness', 'danceability',\n       'energy', 'instrumentalness', 'key', 'liveness', 'loudness', 'mode',\n       'speechiness', 'tempo', 'valence']]\n    \n    similarity_data['Similarity with song'] =cosine_similarity(data_values, data_values.to_numpy()[song_and_artist_data.index[0],None]).squeeze()\n    \n    artist_genres = set(*song_and_artist_data.Genres)\n\n    similarity_data.Genres = similarity_data.Genres.apply(lambda Genres: list(set(Genres).intersection(artist_genres)))\n    \n    similarity_lengths = similarity_data.Genres.str.len()\n    similarity_data = similarity_data.reindex(similarity_lengths[similarity_lengths >= genre_parameter].sort_values(ascending=False).index)\n    \n    similarity_data = similarity_data[similarity_data['Song Decade'] == song_and_artist_data['Song Decade'].values[0]]\n \n    similarity_data.rename(columns={'Song Name': f'Similar Song to {song}'}, inplace=True)\n    \n    similarity_data = similarity_data.sort_values(by= 'Similarity with song', ascending = False)\n    \n    similarity_data = similarity_data[['Artist', f'Similar Song to {song}',\n       'Song Popularity', 'Year', 'Genres', 'Artist Popularity', 'Song Decade', 'Similarity with song',\n       'acousticness', 'danceability', 'energy', 'instrumentalness', 'key',\n       'liveness', 'loudness', 'mode', 'speechiness', 'tempo', 'valence']]\n    \n    return similarity_data.head(15)","4b374b28":"rank_song_similarity_by_measure(final_merged_df, 'Bohemian Rhapsody', 'Queen',2)","e2c01237":"rank_song_similarity_by_measure(final_merged_df, 'Learn to Fly', 'Foo Fighters', 4)","8b969fa0":"Lets see the amount of songs released in each decade","d98f7171":"The rest of the artists without genres will need to be deleted since it would be far too long to find their associated genres. You could in theory look them all up manually and do it but for time effiency I will delete them.","8246383e":"### Binning Data into Decades","8a2d153a":"Now we count the words to see if anything comes up to engineer","55c6fac6":"Now we can build the system. In this first one I will just sort them by popularity within the same genres, so that it will be like a recommendation based on what others like. It will also only contain songs in the same decade as a genres tend to sound different as the decades change","51dc1aad":"Here we will use the measures seen in the very first dataset we imported, raw_data_with_measures. We will basically use these measures to find the songs that are mathematically closest.","2f7ce787":"We will now build the first song recommender system. It will be based upon songs in the same genre that are the most popular.\n\nFirstly we will merge the genres associated with an Artist and assign them to all the songs they have","357f0f43":"Lets see the artists with the most songs","533e0075":"We could look at the correlations between the measures, where some are heavily correlated and suggest multicollinearity. But I have kept all the measures in as each one is seemingly quite important to the song and if I deleted everything with a VIF higher than 5, the remaining measures are not good at suggesting similar songs","db8df2ed":"We now need to scale the data ","e63718a1":"One way of trying to assign an artist to a genre is to look at the artist name and see if there are any words that can help us to assign a genre\n\nWe will split the artist name into words and investigate the words","697422e1":"Lets now readd these scaled measures to the data","597e3bab":"### Artist Analysis","0ecb4ed8":"Lets reorder this for better useability","56979480":"### Top Artists by Song Count","33a21693":"And that concludes the notebook, if you have any suggestions or comments please let me know. Thank You :)","cffece66":"### Song Recommendation System 1 (by popularity)","8ebfe3b3":"### Top Songs by Popularity","e1572adc":"Lets look at the most popular songs from each year","81246e6f":"Lets make a function that gives us the top n artists of each decade","52529b88":"Now that we have cleaned our data, we can build our recommendation system\n\nThis will be based on how many shared genres another artist has with the one you input","40a30dbf":"We can save a lot of artists that need to be deleted via a simple genre assignment based upon whether they have a possible genre in the Artist's name","f5c2b614":"### Genre Analysis","7a2b7350":"We need to clean our data a little first so we can do our analysis","9ef84a9b":"### Top Artists by Popularity","1671635d":"### Artist Recommendation System","5a776435":"### Song Recommendation System 2 (by Similarity of Song Measures)","d6c7ea3e":"We can also lessen the genre parameter to open up more songs but in less genres","4a61b605":"Now we will look at the most popular artists","f7489987":"I have included a parameter that allows you to filter the amount of shared genres you want to see. In some cases there may be only 1 or 2 and in some other there may be way more allowing us to find the artists who are very similar.","98d74f2d":"Lets see if there is any missing data","e1c48bce":"Let's also look at the artists with missing genres who have the most songs","58486af9":"### Introduction\n\nIn this notebook, I will explore the Spotify dataset to see what fun interesting insights can be found!\n\nI will build an Artist Recommender System and also a Song Recommender System based upon similar genres after analysis and see how good we can get it. This is my first project so please let know if there is anything I should change\n\nThis is quite a long notebook so if you want the recommender systems just skip to the end","d5bc7847":"Lets look at the genres to see if anything is missing","972871ac":"Lets make a nice pie chart for it","a86b50f1":"I will now make a function that allows us to see the the top artists via plotly, I will also include parameters that allow us to see any part of the rankings","58afa651":"Lets drop the song measures for now and explore the artists and their genres. We also need to clean the lists in the genres column","c21e27fb":"So it's clear we have to some words that we can assign to a genre, like orchestra and maybe making an 'ensemble' or 'broadway' genre for all artists with ensemble and broadway in their title","26d1e149":"There seems to be a lot of empty genre rows, 9530 in fact, lets investigate this","17bd30a6":"Lets see the most popular song for each decade","2befac70":"### Conclusion","f67a8699":"Lets now make a new column which puts each song into a decade","0d723f1e":"Lets also look at the top artists of each decade","43cbe7f2":"Now for the song recommender, we will use cosine similarity to find the songs closest to eachother. We could also use euclidean distance","1163d84b":"### Data Engineering","39663a17":"Lets look at the genre counts","85a4ec3e":"We will now look at another dataset, and analyse Genres"}}