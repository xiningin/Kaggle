{"cell_type":{"d5f3cdbc":"code","6c47b9f1":"code","e92de4e0":"code","a677f31b":"code","27f9ea27":"code","56aab780":"code","b13e8d9b":"code","b74f3b6b":"code","0981d158":"code","c2bf7544":"code","622fbe27":"code","2b2969b1":"code","5179587d":"code","1c7916cd":"code","ecb6c37f":"code","d550b445":"code","d280d873":"code","91f4571d":"code","6ac94b02":"code","3d5cb94b":"code","3f7ab040":"code","823803d4":"code","63981a64":"markdown","34de940b":"markdown","f285cdc2":"markdown","c4c04b2b":"markdown","f8f5f1f3":"markdown","89b9c4dd":"markdown","a4cb73a4":"markdown","373c7f73":"markdown","ed8afc70":"markdown","91674ed6":"markdown","48b577aa":"markdown","ce42b2da":"markdown","7c00c356":"markdown","5e3ffab5":"markdown","b6e8f66d":"markdown","d109e6e5":"markdown","3df38368":"markdown","76722377":"markdown"},"source":{"d5f3cdbc":"import os\nimport json\nimport time\nimport numpy as np\nimport pandas as pd\nfrom tqdm import tqdm\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\n\nimport xgboost as xgb\nfrom xgboost import plot_importance, plot_tree\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error","6c47b9f1":"!pip install -q --upgrade wandb","e92de4e0":"import wandb\nfrom wandb.xgboost import wandb_callback\n\nwandb.login()","a677f31b":"crypto_df = pd.read_csv('..\/input\/g-research-crypto-forecasting\/train.csv')\ncrypto_df.head()","27f9ea27":"assets = pd.read_csv('..\/input\/g-research-crypto-forecasting\/asset_details.csv').sort_values(\"Asset_ID\").reset_index(drop=True)\nassets","56aab780":"# The config below is for demonstration purposes. \nwandb_config = {'competition': 'gresearch', '_wandb_kernel': 'ayut'}\n\nrun = wandb.init(project='gresearch', config=wandb_config, job_type='raw_data')\nraw_data_artifact = wandb.Artifact('raw-data', type='raw-dataset')\nraw_data_artifact.add_file('..\/input\/g-research-crypto-forecasting\/train.csv')\nraw_data_artifact.add_file('..\/input\/g-research-crypto-forecasting\/asset_details.csv')    \nrun.log_artifact(raw_data_artifact)\nrun.finish()","b13e8d9b":"# if you encounter a \"year is out of range\" error the timestamp\n# may be in milliseconds, try `ts \/= 1000` in that case\ndef timestamp_to_utc(timestamp: int):\n    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')\n\ndef utc_to_timestamp(date_str):\n    return np.int32(time.mktime(datetime.strptime(date_str, \"%d\/%m\/%Y\").timetuple()))","b74f3b6b":"crypto_df['datetime'] = pd.to_datetime(crypto_df['timestamp'], unit='s')\ntrain_df = crypto_df[crypto_df['datetime'] < '2021-06-13 00:00:00']\nvalid_df = crypto_df[crypto_df['datetime'] >= '2021-06-13 00:00:00']\n\nprint(\"Number of samples in train_df: \", len(train_df))\nprint(\"Number of samples in valid_df: \", len(valid_df))","0981d158":"train_df.to_csv('train_df.csv', index=False)\nvalid_df.to_csv('valid_df.csv', index=False)\n\nrun = wandb.init(project='gresearch', config=wandb_config, job_type='data_split')\n# Notice the use of raw_artifact. This will act as reference for this split.\nraw_artifact = run.use_artifact('ayush-thakur\/gresearch\/raw-data:latest', type='raw-dataset')\n\ntrain_artifact = wandb.Artifact('train-data', type='train-split')\nvalid_artifact = wandb.Artifact('valid-data', type='valid-split')\n\ntrain_artifact.add_file('train_df.csv')\nvalid_artifact.add_file('valid_df.csv')\n\nrun.log_artifact(train_artifact)\nrun.log_artifact(valid_artifact)\n\nrun.finish()","c2bf7544":"# Features\nfeatues_col = [\"Count\", \"Open\", \"High\", \"Low\", \"Close\", \"Volume\", \"VWAP\"]\n\ndef upper_shadow(df):\n    return df['High'] - np.maximum(df['Close'], df['Open'])\n\ndef lower_shadow(df):\n    return np.minimum(df['Close'], df['Open']) - df['Low']\n\ndef log_return(series, periods=1):\n    return np.log(series).diff(periods=periods)\n\ndef fill_nan_inf(df):\n    # Fill NaN values\n    df = df.fillna(0)\n    # Fill Inf values\n    df = df.replace([np.inf, -np.inf], 0)\n    \n    return df\n\ndef create_features(df, label=False):\n    \"\"\"\n    Create time series features\n    \"\"\"\n    # Build features\n    up_shadow = upper_shadow(df)\n    low_shadow = lower_shadow(df)    \n    five_min_log_return = log_return(df.VWAP, periods=5)\n    abs_one_min_log_return = log_return(df.VWAP,periods=1).abs()    \n    features = df[featues_col]\n\n    # Concat all the features into one dataframe\n    X = pd.concat([features, up_shadow, low_shadow, \n                   five_min_log_return, abs_one_min_log_return], \n                  axis=1)\n    \n    # Rename feature columns\n    X.columns = featues_col+[\"up_shadow\", \"low_shadow\", \"five_min_log_return\", \"abs_one_min_log_return\"]\n    \n    # Fill NaN and Inf\n    X = fill_nan_inf(X)\n    \n    if label:\n        y = df.Target\n        # Fill NaN and Inf\n        y = fill_nan_inf(y)\n        \n        return X, y\n    \n    return X","622fbe27":"# Initialize a W&B run\nrun = wandb.init(project='gresearch', config=wandb_config, job_type='subset') \n\n# # Notice the use of splits.\ntrain_artifact = run.use_artifact('ayush-thakur\/gresearch\/train-data:latest', type='train-split')\nvalid_artifact = run.use_artifact('ayush-thakur\/gresearch\/valid-data:latest', type='valid-split')","2b2969b1":"# Get single crypto trading data\nbtc_train = train_df[train_df.Asset_ID==1]\nbtc_valid = valid_df[valid_df.Asset_ID==1]\n\n# Fill missing value\nbtc_train = btc_train.reindex(range(btc_train.index[0],btc_train.index[-1]+60,60),method='pad')\nbtc_valid = btc_valid.reindex(range(btc_valid.index[0],btc_valid.index[-1]+60,60),method='pad')\n\n# Create features\nX_train, y_train = create_features(btc_train, label=True)\nX_valid, y_valid = create_features(btc_valid, label=True)","5179587d":"btc_subset_train = pd.concat([X_train, y_train], axis=1).to_csv('btc_subset_train.csv', index=False)\nbtc_subset_valid = pd.concat([X_valid, y_valid], axis=1).to_csv('btc_subset_train.csv', index=False)\n\nbtc_subset = wandb.Artifact('btc-data', type='subset')\nbtc_subset.add_file('btc_subset_train.csv')\nbtc_subset.add_file('btc_subset_train.csv')\nrun.log_artifact(btc_subset)\n\nrun.finish()","1c7916cd":"# Initialize a W&B run\nrun = wandb.init(project='gresearch', config=wandb_config, job_type='train') \n\n# Initialize an XGBRegressor with some parameters.\nreg = xgb.XGBRegressor(n_estimators=1000)\n\n# Train the regressor. Note the use of wandb_callback\nreg.fit(X_train, y_train,\n        eval_set=[(X_valid, y_valid)],\n        early_stopping_rounds=50,\n        verbose=False,\n        callbacks=[wandb_callback()])","ecb6c37f":"# Get the booster\nbstr = reg.get_booster()\n\n# Save the booster to disk\nmodel_name = f'{run.id}_model.json'\nmodel_path = f'.\/{model_name}'\nbstr.save_model(str(model_path))\n\n# Get the booster's config\nconfig = json.loads(bstr.save_config())\n\nmodel_artifact = wandb.Artifact(name=model_name, type='model', metadata=dict(config))\n# Notice the use of earlier artifact as reference for model artifact\nfeatures_artifact = run.use_artifact('ayush-thakur\/gresearch\/btc-data:v1', type='subset')\n\nmodel_artifact.add_file(model_path)\nrun.log_artifact(model_artifact)\nrun.finish()","d550b445":"# select training and test periods\n# 86400 corresponds to one day (24 hrs) in seconds. \n\ntrain_window = [utc_to_timestamp(\"01\/01\/2021\"), utc_to_timestamp(\"31\/01\/2021\")]\nvalid_window = [utc_to_timestamp(\"01\/02\/2021\")-86340, utc_to_timestamp(\"28\/02\/2021\")]\n\ntrain_window, valid_window","d280d873":"# Get single crypto trading data\nbtc_df = crypto_df[crypto_df.Asset_ID==1].set_index('timestamp')\n\n# Get the windowed data\nbtc_train = btc_df.loc[train_window[0]:train_window[1]]\nbtc_valid = btc_df.loc[valid_window[0]:valid_window[1]]\n\n# Fill missing value\nbtc_train = btc_train.reindex(range(train_window[0], train_window[1]+60,60),method='pad')\nbtc_valid = btc_valid.reindex(range(valid_window[0], valid_window[1]+60,60),method='pad')\n\n# # Create features\nX_train, y_train = create_features(btc_train, label=True)\nX_valid, y_valid = create_features(btc_valid, label=True)","91f4571d":"X_trains, y_trains, X_valids, y_valids = [], [], [], []\n\nfor i in tqdm(range(len(assets))):\n    row = assets.loc[i]\n    # Get single crypto trading data\n    df = crypto_df[crypto_df.Asset_ID==i].set_index('timestamp')\n    \n    # Get the windowed data\n    train = df.loc[train_window[0]:train_window[1]]\n    valid = df.loc[test_window[0]:test_window[1]]\n\n    # Fill missing value\n    train = train.reindex(range(train_window[0], train_window[1]+60,60),method='pad')\n    valid = valid.reindex(range(valid_window[0], valid_window[1]+60,60),method='pad')\n\n    # Create features\n    X_train, y_train = create_features(train, label=True)\n    X_valid, y_valid = create_features(valid, label=True)\n    \n    X_trains.append(X_train); y_trains.append(y_train)\n    X_valids.append(X_valid); y_valids.append(y_valid)","6ac94b02":"X_all_train = np.concatenate(X_trains, axis=1)\nX_all_valid = np.concatenate(X_valids, axis=1)\ny_all_train = np.column_stack(y_trains)\ny_all_valid = np.column_stack(y_valids)\n\nX_all_train.shape, y_all_train.shape, X_all_valid.shape, y_all_valid.shape","3d5cb94b":"# define the direct multioutput model and fit it\nfrom sklearn.multioutput import MultiOutputRegressor\nmreg = MultiOutputRegressor(xgb.XGBRegressor(n_estimators=1000))\n\nmreg.fit(X_all_train[:10], y_all_train[:10])","3f7ab040":"y_pred_lr_all = mreg.predict(X_all_valid)","823803d4":"y_pred_lr_all","63981a64":"# Load Dataset\n\nIf you haven't already check out the [Tutorial to the G-Research Crypto Competition](https:\/\/www.kaggle.com\/cstein06\/tutorial-to-the-g-research-crypto-competition).","34de940b":"This notebook can be considered a tutorial on how to use XGBoost for this competition and use Weights and Biases to make the most out of your XGBoost model. \n\nThis tutorial is based on [[Tutorial] Time Series forecasting with XGBoost](https:\/\/www.kaggle.com\/robikscube\/tutorial-time-series-forecasting-with-xgboost) by [Rob Mulla](https:\/\/www.kaggle.com\/robikscube). ","f285cdc2":"# WORK IN PROGRESS\n\nI hope you will find it useful. If you have any questions feel free to comment or reach out. Plus if you think it can be improved further please let me know. \n\nUpcoming:\n\n* Extend the regression for the entire dataset.\n* Use a quarter worth of data and forecast for one month ahead. (Not sure how exactly)\n* Show how to use W&B Sweeps for Hyperparameter Optimization. ","c4c04b2b":"We will again save the splits as W&B Artifact and use the reference to the previously logged raw data to build the data lineage. \n\nThe step below might take some time, since a large `csv` file is being written on the disk. Again this is a one time process. You might want to repeat this for different splits of the raw dataset. For a competition that runs for months a good data version control can make a huge difference.","f8f5f1f3":"#### Utils","89b9c4dd":"# Features","a4cb73a4":"# Prepare Train-Validation Split\n\nNote that I have used the data that's used for LB score computation as `valid_df`. I will be using this `valid_df` for evaluating all my models. ","373c7f73":"# Setup and Imports","ed8afc70":"# So Far\n\nSo far we built a data and model lineage and used `wandb_callback` for XGBoost. Using `wandb_callback` is like using a single line of code to keep a tab of your experiments.\n\n## [Check out the W&B Dashboard](https:\/\/wandb.ai\/ayush-thakur\/gresearch?workspace=user-ayush-thakur)\n\nThe image below shows the data and model lineage created so far. Imagine you are training tons of models on different splits of the same dataset. Taking the extra effor to build an MLOps pipeline around the same can be really useful in the long run. \n\n![img](https:\/\/i.imgur.com\/jkVCZRi.png)\n\nThe image shown below is the logged metrics.\n\n![img](https:\/\/i.imgur.com\/FXQTmts.png)","91674ed6":"Weights and Biases comes preinstalled with Kaggle environment but it's recommended to get the latest version of the same. ","48b577aa":"Let's prepare the features for just Bitcoin trading data.","ce42b2da":"# Train a naive XGBRegressor on one crypto data\n\nIn this section, we will train an XGBRegressor, which is an implementation of the scikit-learn API for XGBoost regression.\n\nWe will take the crypto data of Bitcoin, fill the missing gaps in the series, compute features for train and validation splits. We will then initalize a W&B run and train an XGBRegressor with default parameters. Later in this notebook we will try to find the best parameters. \n\nLet's first start by initializing a W&B run and use the split artifact reference that we logged previously.","7c00c356":"The following are the columns available in the `train.csv` file.\n\n* `timestamp`: All timestamps are returned as second Unix timestamps (the number of seconds elapsed since 1970-01-01 00:00:00.000 UTC). Timestamps in this dataset are multiple of 60, indicating minute-by-minute data.\n\n* `Asset_ID`: The asset ID corresponding to one of the crytocurrencies (e.g. Asset_ID = 1 for Bitcoin). The mapping from Asset_ID to crypto asset is contained in `asset_details.csv`.\n\n* `Count`: Total number of trades in the time interval (last minute).\n\n* `Open`: Opening price of the time interval (in USD).\n\n* `High`: Highest price reached during time interval (in USD).\n\n* `Low`: Lowest price reached during time interval (in USD).\n\n* `Close`: Closing price of the time interval (in USD).\n\n* `Volume`: Quantity of asset bought or sold, displayed in base currency USD.\n\n* `VWAP`: The average price of the asset over the time interval, weighted by volume. VWAP is an aggregated form of trade data.\n\n* `Target`: Residual log-returns for the asset over a 15 minute horizon.","5e3ffab5":"Since we have used the training and validation split and are going to train the model on a subset of the data we should log the subset as W&B artifacts. Here we will log the features dataframe for better sanity check in the future.","b6e8f66d":"# XGBRegressor as Multi Output Regressor\n\nIn this section we will take in the trading data for one quarter (3 months) and try to forecast the returns for the 4th month. \n\nLet's see how things go. \n\nWe will use Sklearn's `MultiOutputRegressor`. Note however that this strategy doesn't use any dependence between different targets. \n\nFirst let's build our train and valid dataset for one quarter. We will use the data from ","d109e6e5":"Here we will log the raw dataset as W&B Artifacts to build data lineage as we train models and validate on different split of the dataset. \n\nThis might be an additional step but can be really useful to have in your arsenal. \n\nNote: This is a one time step. Once you have logged your raw_data you just need to log different splits of the same or preprocessed data. ","3df38368":"Now finally let's train a simple regression and use W&B's XGBoost Callback to log the metrics and configs. ","76722377":"Let's save the model along with model configuration. We will use the data lineage created so far and start building model lineage on top of it."}}