{"cell_type":{"4501d296":"code","31a928f3":"code","325db7fe":"code","80700910":"code","8e043323":"code","95c2677c":"code","df9eeaf5":"code","7404032b":"code","bda3b64e":"code","030a6d56":"code","42f57746":"code","8b6095c5":"code","920d6f4a":"code","a43b2d95":"code","9f4246e1":"code","a63b44fc":"code","dd1fa1c1":"code","a64d8669":"code","46c1115e":"code","d2754ca6":"code","cada9e4d":"markdown","926588cc":"markdown","88931d12":"markdown","82fc1c9d":"markdown","97279b97":"markdown","3a96a3ee":"markdown","961afe05":"markdown","b953e6b5":"markdown","771b97d7":"markdown","716cf1f2":"markdown","7d21febc":"markdown","8cf97793":"markdown","2f2d3acf":"markdown","7462b557":"markdown","f7cb0c5f":"markdown","6cca821a":"markdown"},"source":{"4501d296":"from keras import models\nfrom keras import layers\nfrom keras.layers import Dense, Conv2D, Flatten,MaxPooling2D,Dropout,ZeroPadding2D,BatchNormalization\nfrom keras.preprocessing.image import ImageDataGenerator\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot\nimport os\nimport zipfile\nimport tensorflow as tf\nfrom tensorflow.keras.optimizers import RMSprop,Adam\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nimport random\n\n","31a928f3":"Train = pd.read_csv(\"..\/input\/train.csv\")\nTest = pd.read_csv(\"..\/input\/test.csv\")","325db7fe":"Train.head()","80700910":"#Read the labels into a seprate array\ny_train = Train['label'].values\n\n#convert the images into a matrix of size 42,000 X 28 X 28 \ntrain_images = Train.loc[:,Train.columns != 'label'].values\ntrain_images = train_images.reshape(-1,28,28,1)\ntrain_images.shape\n","8e043323":"\n#convert the images into a matrix of size 28,000 X 28 X 28 \ntest_images = Test.values\ntest_images_final = test_images.reshape(-1,28,28,1)\ntest_images_final.shape\n","95c2677c":"# create a grid of 3x3 images\nfor i in range(0, 9):\n    pyplot.subplot(330 + 1 + i)\n    pyplot.imshow(train_images[i].reshape(28,28), cmap=pyplot.get_cmap('gray'))\n# show the plot\npyplot.show()","df9eeaf5":"#reshape data to fit model\n\ntrain_images = train_images.astype('float32') \/255\n\ntest_images_final = test_images_final.astype('float32') \/255","7404032b":"import tensorflow as tf\nnetwork = tf.keras.models.Sequential([\n    tf.keras.layers.ZeroPadding2D(padding=(1, 1), data_format=None,input_shape=(28, 28, 1)),\n    tf.keras.layers.Conv2D(32, (5,5), activation='relu'),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.ZeroPadding2D(padding=(1, 1), data_format=None),\n    tf.keras.layers.Conv2D(64, (6,6), activation='relu'),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.ZeroPadding2D(padding=(1, 1), data_format=None),\n    tf.keras.layers.Conv2D(64, (7,7), activation='relu'),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.MaxPooling2D(5,5),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(128, activation='relu'),\n    tf.keras.layers.Dropout(0.45),\n    tf.keras.layers.Dense(10, activation='softmax')\n])","bda3b64e":"from keras import optimizers\n\n#network.compile(optimizer=RMSprop(lr=0.001),\nnetwork.compile(optimizer=Adam(lr=0.001),\nloss='categorical_crossentropy',\nmetrics=['accuracy'])","030a6d56":"network.summary()","42f57746":"from sklearn.model_selection  import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(train_images, y_train, test_size=0.15)","8b6095c5":"from keras.utils import to_categorical\ntrain_labels = to_categorical(y_train)\ntest_labels = to_categorical(y_test)\ny_train = train_labels\ny_train.shape\n\n","920d6f4a":"#datagen = ImageDataGenerator(featurewise_center=True, featurewise_std_normalization=True)\ndatagen = ImageDataGenerator( rotation_range=10,  \n        zoom_range = 0.10,  \n        width_shift_range=0.1, \n        height_shift_range=0.1)\n# fit parameters from data\ndatagen.fit(X_train)\n\nnp.concatenate((X_train,X_train),axis=0)\nrandom.seed(12345)\nfor X_batch, y_batch in datagen.flow(np.concatenate((X_train,X_train),axis=0), np.concatenate((y_train,y_train),axis=0), batch_size=35700):\n  break\n \n  \nX_trainE = X_batch\ny_trainE = y_batch\n\n\nfor i in range(0, 9):\n        pyplot.subplot(330 + 1 + i)\n        pyplot.imshow(X_trainE[i].reshape(28, 28), cmap=pyplot.get_cmap('gray'))\n# show the plot\npyplot.show()\n\n\n","a43b2d95":"\nX_Combine = np.concatenate((X_train,X_trainE),axis=0)\ny_combine = np.concatenate((y_train,y_trainE),axis=0)\nprint(X_Combine.shape)\nprint(y_combine.shape)","9f4246e1":"class myCallback(tf.keras.callbacks.Callback):\n  def on_epoch_end(self, epoch, logs={}):\n    if(logs.get('val_acc')>=0.9930):\n      print(\"\\nReached 99.0% accuracy so cancelling training!\")\n      self.model.stop_training = True\n      \ncallbacks = myCallback()","a63b44fc":"history = network.fit(X_Combine, y_combine, epochs=60, batch_size=512,validation_data=(X_test,test_labels),callbacks=[callbacks])","dd1fa1c1":"test_loss, test_acc = network.evaluate(X_test, test_labels)\nprint('test_acc:', test_acc)","a64d8669":"#Make Prediction\npredict = network.predict(test_images_final)\n#Convert the results to the digits value \ny_classes = [np.argmax(y, axis=None, out=None) for y in predict]","46c1115e":"import matplotlib.pyplot as plt\nhistory_dict = history.history\nloss_values = history_dict['loss']\nval_loss_values = history_dict['val_loss']\nepochs = range (1,len(history_dict['loss'])+1)\n#epochs = range(1, 36)\nplt.plot(epochs, loss_values, 'bo', label='Training loss')\nplt.plot(epochs, val_loss_values, 'b', label='Validation loss')\nplt.title('Training and validation loss')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend()\nplt.show()","d2754ca6":"x = list(range(1, 28001))\ndf = pd.DataFrame({'ImageId' :x,'Label':y_classes})\ndf.to_csv(\"output.csv\",index=False)\n","cada9e4d":"## The network architecture","926588cc":"## Spliting the Train data ","88931d12":"## Load Libraries \nLoading the required libraries \nThe implementation is based on the Keras\/TenserFlow Python libraries ","82fc1c9d":"## Displaying Grid of some images","97279b97":"## The compilation step","3a96a3ee":"## Fit the Network","961afe05":"## Model Performances ","b953e6b5":"## Kaggle Digit Recognizer \nA simple Python note Book which provide a starting point for using a CNN for the \nKaggle Digit Recognizer ","771b97d7":"## Pre Processing","716cf1f2":"## Image augmentaion  \nCreating another set of image augmentaion  ","7d21febc":"## Format Change - Test\nHandle the test dataset ...","8cf97793":"## Label Hot Encoding","2f2d3acf":"## Plotting the training and validation loss","7462b557":"## Normalizing","f7cb0c5f":"## Format Change - Train \nTo feed the images into the network, it needs to be in a matrix format \n\n\n---\n\nRows (Images)\n\nImage - Width \nImage Hight\n\nImage pixels (gray scale -1)\n\n\n---\n\nAlso, the labels must be provided in a separate array","6cca821a":"## Read Data "}}