{"cell_type":{"4529c9d4":"code","f3ccb2fa":"code","fdb68181":"code","efd372bd":"code","5f49ee3d":"code","f584a668":"code","34c8bb60":"code","fb247f80":"code","55ce7112":"code","8074ea27":"code","dec56714":"code","2c8f4452":"code","a74f7377":"code","51b7b269":"code","487075c3":"markdown","2bd333e1":"markdown","6f653b29":"markdown","cdc97033":"markdown","d5d4457e":"markdown","0a9f8fac":"markdown","6ad6c435":"markdown","80a038d6":"markdown","d3eafa90":"markdown","d6f43caf":"markdown","f32c4a3d":"markdown","21641585":"markdown","2da353d4":"markdown","b29d5a17":"markdown","e8c3ec44":"markdown","057fda1b":"markdown","2323aabf":"markdown","afe19213":"markdown","56b67249":"markdown","a21aed1c":"markdown","fb3d1d99":"markdown","9c5b0d26":"markdown"},"source":{"4529c9d4":"def add_two_integers(x: int = 1, y: int = 2) -> int:\n    return x + y","f3ccb2fa":"length: int # no value at runtime until assigned\nlength: int = 10\n\nis_square: bool # no value at runtime until assigned\nis_square: bool = False\n    \nwidth: float # no value at runtime until assigned\nwidth: float = 100\n    \nname: str # no value at runtime until assigned\nname: str = \"rectangle\"","fdb68181":"from typing import List, Set, Dict, Tuple, Optional","efd372bd":"x: List[int] = [1, 2]","5f49ee3d":"x: Set[str] = {'rect', 'square'}","f584a668":"x: Dict[str, float] = {'length': 10.0, 'width': 100.0}","34c8bb60":"x: Tuple[str, float, float] = (\"rect\", 10.0, 100.0)\n    \nx: Tuple[int, ...] = (1, 2, 3) # Variable size tuple","fb247f80":"def compare_numbers(x: int) -> int:\n    if x<10:\n        return 1\n    elif x>10:\n        return 0\n    else:\n        return None\n    \n\nx: Optional[int] = compare_numbers(10)","55ce7112":"from typing import Callable, Iterator, Union","8074ea27":"x: Callable[[int, int], int] = add_two_integers","dec56714":"def generator(n: int) -> Iterator[int]:\n    i = 0\n    while i < n:\n        yield i\n        i += 1","2c8f4452":"def add_two_integers_or_floats(x: Union[int, float], y: Union[int, float]) -> Union[int, float]:\n    return x + y","a74f7377":"F = List[float] # Aliasing list of floats\n\na: F = [1.0, 4.6, 9.1]","51b7b269":"from typing import TypeVar, Iterable, DefaultDict\n\nRelation = Tuple[T, T]\ndef create_tree(tuples: Iterable[Relation]) -> DefaultDict[T, List[T]]:\n    tree: DefaultDict[T, List[T]] = defaultdict(list)\n    for idx, child in enumerate(tuples):\n        tree[idx].append(child)\n\n    return tree\n\nprint(create_tree([(2.0,1.0), (3.0,1.0), (4.0,3.0), (1.0,6.0)]))","487075c3":"### Tuples","2bd333e1":"Here, we use colon ```:``` to specify the type of input arguments, and arrow ```->``` to specify the type of the return variable of a function. We can use equal ```=``` to specify default value of the input parameters. ","6f653b29":"### Iterators\n\nFor generator functions that use ```yield``` can use ```Iterators``` to specify the return type.","cdc97033":"## Further Reading\n\n- https:\/\/www.kite.com\/blog\/python\/type-hinting\/\n- http:\/\/mypy-lang.org\/\n- https:\/\/realpython.com\/lessons\/pros-and-cons-type-hints\/\n- https:\/\/mypy.readthedocs.io\/en\/stable\/cheat_sheet_py3.html","d5d4457e":"### Dictionary","0a9f8fac":"## Generics\n\nDefining a fixed type may be sometimes restrictive. We can use ```TypeVar``` for generic definitions. Here is an example from [4]","6ad6c435":"### Callable function\n\nIt follows the format ```Callable[[arg1, arg2], return_type]```, where ```arg1```, ```arg2``` and input types and ```return_type``` is the type of the return variable.","80a038d6":"## Functions\n","d3eafa90":"## Built-in Data Structures\n\nTo statically type built-in data structure we can use ```typing``` package as follows.","d6f43caf":"## Type aliases\n\nYou can also use type aliases for the convenience of coding.","f32c4a3d":"# Usage","21641585":"### Union\nUnion can be used as ```Union[A, B]``` to indicate that the object can have type ```A``` or ```B```.","2da353d4":"### Optional\n\nOptional is used as ```Optional[A]``` to indicate that the object is either of type ```A``` or  ```None```.","b29d5a17":"Python is a dynamic programming language, i.e., the environment can be changed at run-time and isn't explicitly coded in the source code. Variables have no types, functions, and objects can be altered on run-time. Therefore, to run a python script we don't need to specify the types of the variables unlike strongly typed languages such as C++. It makes Python an easy language to learn and code. But at the same type, for debugging, documenting, improve IDEs and linters, build and maintain a cleaner architecture. and integrating with scripts written in another language, it is often useful to know the types of the variables. Python lacks it.\nTo solve this issue, optional static type hinting was specified in the Python Enhancement Proposal (PEP) 484 and introduced for the first time in Python 3.5.","e8c3ec44":"# <center> Python Good Practices: Type Hinting <center>","057fda1b":"\n## Style Suggestions\n\n- **Colon usage**: Use normal rules for colons, that is, no space before and one space after a colon (text: str).\n- **Default assignment usage**: Use spaces around the = sign when combining an argument annotation with a default value (align: bool = True).\n- **Return arrow usage**: Use spaces around the -> arrow (def headline(...) -> str).","2323aabf":"You can use mypy python static type checker pacakge (http:\/\/mypy-lang.org\/) to check whether a script has some type errors.\n\nYou can install it by running:\n\n```\npip install mypy\n```\n\nThen you can test your script (say, ```my_script.py```) by running:\n\n```\nmypy my_script.py\n```","afe19213":"### Set","56b67249":"## Basic Syntax\n\nThe basic syntax of type hinting is as follows:\n","a21aed1c":"# Using Mypy ","fb3d1d99":"### List","9c5b0d26":"## Basic Variables\n\nAll the following declarations are valid. Any simple basic types not mentioned below can be used."}}