{"cell_type":{"e04939e3":"code","6b686945":"code","c5a0a46b":"code","2e1115b2":"code","cb13ac7f":"code","4cabfd75":"code","1df250d2":"code","21264523":"code","b72a02e7":"code","9d20e051":"code","d890c59d":"code","9893a636":"code","710d7883":"code","407c9f10":"code","47eafd5e":"code","c6bbe6fa":"code","3f0852dd":"code","28795d72":"code","0ecafa6c":"code","943eac5d":"code","dba703a6":"code","a0f1c522":"code","ed28ca5a":"code","ea8ff6a1":"code","0d16008f":"code","263755aa":"markdown","ca1e9195":"markdown","e58f1887":"markdown","a4679fd4":"markdown","ddf6a917":"markdown","3fb46fcf":"markdown","c58d1856":"markdown","be9fde66":"markdown","4b72ae3f":"markdown","ca653ae1":"markdown","6007db0d":"markdown","6e972fb5":"markdown","3c03c4d6":"markdown","76bda114":"markdown","9c2d7bf0":"markdown"},"source":{"e04939e3":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport gc\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\nimport seaborn as sns\nsns.set(style='white', context='notebook', palette='Set2')\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)","6b686945":"train_df = pd.read_csv(\"..\/input\/pubg-finish-placement-prediction\/train_V2.csv\")\ntest_df = pd.read_csv(\"..\/input\/pubg-finish-placement-prediction\/test_V2.csv\")","c5a0a46b":"train_df.head()","2e1115b2":"train_df.describe()","cb13ac7f":"test_df.describe()","4cabfd75":"pd.DataFrame({'train':train_df.isna().sum(), 'test':test_df.isna().sum()})","1df250d2":"train_df = train_df.dropna()","21264523":"drop_features = [\"Id\", \"groupId\", \"matchId\"]\nfeats = [f for f in train_df.columns if f not in drop_features]\n\nplt.figure(figsize=(18,16))\nsns.heatmap(train_df[feats].corr(), linewidths=0.1,vmax=1.0,\n               square=True, linecolor='white', annot=True, cmap=\"RdBu\")","b72a02e7":"plt.figure(figsize=(12,6))\nsns.distplot(train_df['winPlacePerc'].values, bins=100, kde=False)","9d20e051":"# Memory saving function credit to https:\/\/www.kaggle.com\/gemartin\/load-data-reduce-memory-usage\ndef reduce_mem_usage(df):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.        \n    \"\"\"\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage of dataframe is {:.2f} MB'.format(start_mem))\n\n    for col in df.columns:\n        col_type = df[col].dtype\n\n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))\n    print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) \/ start_mem))\n\n    return df","d890c59d":"dataset = pd.concat([train_df, test_df], sort=True)\ndataset = reduce_mem_usage(dataset)","9893a636":"plt.figure(figsize=(12,6))\nplt.title('Number of Team Members')\ntmp = dataset.groupby(['matchId','groupId'])['Id'].agg('count')\nsns.countplot(tmp)","710d7883":"plt.figure(figsize=(12,6))\nplt.title('Number of Team Members')\nax = sns.countplot(x='matchType', data=dataset)\nax.set_xticklabels(ax.get_xticklabels(), rotation=40, ha=\"right\")\nplt.tight_layout()","407c9f10":"#dataset\u306btrain_df\u3068test_df\u3092\u304f\u3063\u3064\u3051\u3066\u5165\u308c\u3061\u3083\u3046\ndataset = pd.concat([train_df, test_df], sort=True)\ndataset = reduce_mem_usage(dataset)","47eafd5e":"# \u8ffd\u52a0\u7279\u5fb4\u91cf\u3092\u4f5c\u6210\u3059\u308b\ndef feature_engineering(df):\n    #\u30ad\u30eb\u6570\u306e\u3046\u3061\uff0c\u30d8\u30c3\u30c9\u30b7\u30e7\u30c3\u30c8\u3092\u3057\u305f\u5272\u5408\uff08\u4e0a\u624b\u306a\u4eba\u306f\u30d8\u30c3\u30c9\u30b7\u30e7\u30c3\u30c8\u3092\u3059\u308b\u5272\u5408\u304c\u9ad8\u3044\u3068\u8003\u3048\u3089\u308c\u308b\uff09\n    df['headshotrate'] = df['kills']\/(df['headshotKills']+0.1)\n    #killStreaks:\u77ed\u6642\u9593\u3067\u306e\u6700\u591a\u9023\u7d9a\u30ad\u30eb\u3000\u30ad\u30eb\u6570\u306e\u3046\u3061\uff0ckillStreak\u304c\u9ad8\u3044\u3068\u3044\u3046\u3053\u3068\u306f\uff0c\u77ed\u6642\u9593\u3067\u591a\u304f\u306e\u4eba\u3092\u76f8\u624b\u306b\u30ad\u30eb\u3092\u53d6\u308c\u308b\uff08\u304b\u306a\u308a\u4e0a\u624b\u3044\uff09\u3068\u3044\u3046\u3053\u3068\u306b\u306a\u308b\n    df['killStreakrate'] = df['killStreaks']\/(df['kills']+0.1)\n    #heals\u3082boosts\u3082\u56de\u5fa9\u30a2\u30a4\u30c6\u30e0\uff08\u7a2e\u985e\u306f\u7570\u306a\u308b\u304c\uff09\u306e\u4f7f\u7528\u56de\u6570\u306a\u306e\u3067\uff0c\u305d\u308c\u306e\u5408\u8a08\u56de\u6570\u3092\u7279\u5fb4\u91cf\u3068\u3059\u308b.\u9577\u304f\u751f\u304d\u6b8b\u3063\u3066\u3044\u308b\u5834\u5408\uff0c\u591a\u304f\u306e\u56de\u5fa9\u30a2\u30a4\u30c6\u30e0\u3092\u4f7f\u3046\u50be\u5411\u306b\u3042\u308b\u306f\u305a\n    df['healthitems'] = df['heals'] + df['boosts']\n    #\u7dcf\u79fb\u52d5\u8ddd\u96e2\uff0c\u4e57\u308a\u7269\uff0c\u6b69\u884c\uff0c\u6c34\u6cf3\u5168\u90e8\u8db3\u3057\u5408\u308f\u305b\u308b\n    df['totalDistance'] = df['rideDistance'] + df[\"walkDistance\"] + df[\"swimDistance\"]\n    #\u30ad\u30eb\u9806\u4f4d(killPlace=1\u301c100)\u3092\u53c2\u52a0\u4eba\u6570\uff08\u305d\u306e\u8a66\u5408\u3067\u306e\u6700\u4f4e\u9806\u4f4d\uff09\u3067\u5272\u308b\uff0ekillPlace\u306e\u307e\u307e\u3060\u3068\uff0c\u5c11\u4eba\u6570\u30de\u30c3\u30c1\uff08\u4f8b\u3048\u307010\u4eba\u306e\u8a66\u5408\uff09\u306e\u6642\uff0c\u8d85\u4e0b\u624b\u306a\u4eba\u3067\u3082\u4e0a\u4f4d\uff0810\u4f4d\u306a\u3069\uff09\u3068\u8868\u793a\u3055\u308c\u3066\u3057\u307e\u3046\u6050\u308c\u304c\u3042\u308b\uff0e\u30de\u30c3\u30c1\u4eba\u6570\u306b\u3088\u3089\u305b\u306a\u3044\u305f\u3081\u306b\u4f5c\u6210\n    df['killPlace_over_maxPlace'] = df['killPlace'] \/ (df['maxPlace']+0.1)\n    #\u4e0a\u306eheadshotrate\u3068\u540c\u3058\u611f\u3058\uff0c\u3000\u3088\u304f\u308f\u304b\u3089\u3093\n    df['headshotKills_over_kills'] = df['headshotKills'] \/ (df['kills']+0.1)\n    #weaponsAcquired:\u62fe\u3063\u305f\u6b66\u5668\u306e\u6570\u3000\u3088\u304f\u308f\u304b\u3089\u3093\n    df['distance_over_weapons'] = df['totalDistance'] \/ (df['weaponsAcquired']+0.1)\n    #\u56de\u5fa9\u30a2\u30a4\u30c6\u30e0\u3092\u4f7f\u3046\u3068\u30a8\u30ea\u30a2\u306e\u5916\u306b\u3044\u3066\u3082\u751f\u304d\u6b8b\u308c\u308b\uff0c\u30d6\u30fc\u30b9\u30c8\u30a2\u30a4\u30c6\u30e0\u3092\u4f7f\u3046\u3068\u65e9\u304f\u8d70\u308c\u308b\u304b\u3089walkDistance\u3068\u95a2\u4fc2\u3042\u308a\u305d\u3046\n    df['walkDistance_over_heals'] = df['walkDistance'] \/ (df['heals'] +0.1)\n    df['walkDistance_over_boosts'] = df['walkDistance'] \/ (df['boosts']+0.1)\n    df['walkDistance_ober_healthitems'] = df['walkDistance'] \/ (df['healthitems']+0.1)\n    #\u9577\u8ddd\u96e2\u79fb\u52d5\u3092\u3059\u308b\u3068\u6575\u3068\u3076\u3064\u304b\u308b\u3053\u3068\u304c\u591a\u3044\uff0ckills\u3068\u79fb\u52d5\u8ddd\u96e2\u306f\u95a2\u4fc2\u3042\u308a\u305d\u3046\n    df['walkDistance_over_kills'] = df['walkDistance'] \/ (df['kills']+0.1)\n    df['killsPerWalkDistance'] = df['kills'] \/ df['walkDistance']\n    df['totalDistance_over_kills'] = df['totalDistance'] \/ (df['kills']+0.1)\n    #\u30d7\u30ec\u30a4\u30e4\u30fc\u30b9\u30ad\u30eb\u3068\u3057\u3066\u30d8\u30c3\u30c9\u30b7\u30e7\u30c3\u30c8\u30ad\u30eb\u3084\u30ed\u30fc\u30c9\u30ad\u30eb\u3092\u3057\u305f\u6570\u3068\u3057\u3066\u7279\u5fb4\u91cf\u3092\u4f5c\u6210\u3059\u308b\uff0e\uff08\u4e0a\u624b\u306a\u4eba\u306f\u30d8\u30c3\u30c9\u30b7\u30e7\u30c3\u30c8\u3084\uff0c\u4e57\u308a\u7269\u7206\u7834\u306b\u3088\u308b\u30ad\u30eb\u6570\u304c\u591a\u3044\u3068\u3044\u3046\u3053\u3068\u304cEDA\u306b\u3088\u308a\u308f\u304b\u3063\u3066\u3044\u308b\uff0e\uff09\n    df[\"skill\"] = df[\"headshotKills\"] + df[\"roadKills\"]\n    \n    return df","c6bbe6fa":"dataset = feature_engineering(dataset)","3f0852dd":"dataset.head()","28795d72":"# https:\/\/www.kaggle.com\/rejasupotaro\/effective-feature-engineering\n#\u7d71\u8a08\u91cf\u3092\u53d6\u3063\u3066\u7279\u5fb4\u91cf\u3092\u91cf\u7523\uff08\u30e1\u30e2\u30ea\u3081\u3063\u3061\u3083\u98df\u3046\uff09\ndef min_by_team(df):\n    cols_to_drop = ['Id', 'groupId', 'matchId', 'matchType', 'winPlacePerc']\n    features = [col for col in df.columns if col not in cols_to_drop]\n    agg = df.groupby(['matchId','groupId'])[features].min()\n    return df.merge(agg, suffixes=['', '_min'], how='left', on=['matchId', 'groupId'])\n\ndef max_by_team(df):\n    cols_to_drop = ['Id', 'groupId', 'matchId', 'matchType', 'winPlacePerc']\n    features = [col for col in df.columns if col not in cols_to_drop]\n    agg = df.groupby(['matchId', 'groupId'])[features].max()\n    return df.merge(agg, suffixes=['', '_max'], how='left', on=['matchId', 'groupId'])\n\ndef sum_by_team(df):\n    cols_to_drop = ['Id', 'groupId', 'matchId', 'matchType', 'winPlacePerc']\n    features = [col for col in df.columns if col not in cols_to_drop]\n    agg = df.groupby(['matchId', 'groupId'])[features].sum()\n    return df.merge(agg, suffixes=['', '_sum'], how='left', on=['matchId', 'groupId'])\n\ndef median_by_team(df):\n    cols_to_drop = ['Id', 'groupId', 'matchId', 'matchType', 'winPlacePerc']\n    features = [col for col in df.columns if col not in cols_to_drop]\n    agg = df.groupby(['matchId', 'groupId'])[features].median()\n    return df.merge(agg, suffixes=['', '_median'], how='left', on=['matchId', 'groupId'])\n\ndef mean_by_team(df):\n    cols_to_drop = ['Id', 'groupId', 'matchId', 'matchType', 'winPlacePerc']\n    features = [col for col in df.columns if col not in cols_to_drop]\n    agg = df.groupby(['matchId', 'groupId'])[features].mean()\n    return df.merge(agg, suffixes=['', '_mean'], how='left', on=['matchId', 'groupId'])\n\ndef rank_by_team(df):\n    cols_to_drop = ['Id', 'groupId', 'matchId', 'matchType', 'winPlacePerc']\n    features = [col for col in df.columns if col not in cols_to_drop]\n    agg = df.groupby(['matchId', 'groupId'])[features].mean()\n    #\u9806\u4f4d\u3067\u8fd4\u3059\uff08pct=True\u306b\u3059\u308b\u3068\u5168\u4f53\u306e\u4f55\u30d1\u30fc\u30bb\u30f3\u30c8\u306e\u4f4d\u7f6e\u306b\u3044\u308b\u304b\u3092\u8fd4\u3059\uff09\n    agg = agg.groupby('matchId')[features].rank(pct=True)\n    return df.merge(agg, suffixes=['', '_mean_rank'], how='left', on=['matchId', 'groupId'])\n\n\n#\u7d71\u8a08\u91cf\u5168\u90e8\u3084\u3063\u3061\u3083\u3046\ndef all_agg_by_team(df):\n    cols_to_drop = ['Id', 'groupId', 'matchId', 'matchType', 'winPlacePerc']\n    features = [col for col in df.columns if col not in cols_to_drop]\n    df_ = df.copy()\n    #min_by_team\n    agg = df_.groupby(['matchId','groupId'])[features].min()\n    df = df.merge(agg, suffixes=['', '_min'], how='left', on=['matchId', 'groupId'])\n    print('min_by_team fin')\n    #max_by_team\n    agg = df_.groupby(['matchId', 'groupId'])[features].max()\n    df = df.merge(agg, suffixes=['', '_max'], how='left', on=['matchId', 'groupId'])\n    print('max_by_team fin')\n    #median_by_team\n    agg = df_.groupby(['matchId', 'groupId'])[features].median()\n    df = df.merge(agg, suffixes=['', '_median'], how='left', on=['matchId', 'groupId'])\n    #mean_by_team\n    agg = df_.groupby(['matchId', 'groupId'])[features].mean()\n    df = df.merge(agg, suffixes=['', '_mean'], how='left', on=['matchId', 'groupId'])\n    print('mean_by_team fin')\n    #rank_by_team\n    agg = df_.groupby(['matchId', 'groupId'])[features].mean()\n    agg = agg.groupby('matchId')[features].rank(pct=True)\n    df = df.merge(agg, suffixes=['', '_mean_rank'], how='left', on=['matchId', 'groupId'])\n    return df","0ecafa6c":"#\u4e0a\u3067\u4f5c\u3063\u305f\u7279\u5fb4\u91cf\u4f5c\u6210\u95a2\u6570\u306e\u3046\u3061\uff0c\u3044\u304f\u3064\u304b\u3092\u5b9f\u884c\uff08\u30ab\u30fc\u30cd\u30eb\u306e\u30e1\u30e2\u30ea\u306b\u4e57\u308a\u5207\u3089\u3093...)\n# dataset = all_agg_by_team(dataset)\n# dataset = rank_by_team(dataset)\ndataset = mean_by_team(dataset)\ngc.collect()\ndataset.head()","943eac5d":"from sklearn.model_selection import KFold, StratifiedKFold, train_test_split\nfrom sklearn.metrics import mean_absolute_error","dba703a6":"def oof_model_preds(df, model, num_folds, params):\n    #\u5f15\u6570\u306edf\u306b\u306f\u5148\u307b\u3069\u4f5c\u6210\u3057\u305fdataset\uff08train_df\u3068test_df\u304c\u304f\u3063\u3064\u3044\u305f\u3082\u306e\uff09\u3092\u3044\u308c\u3066\u3044\u308b\u306e\u3067\u305d\u308c\u3092\u3053\u3053\u3067train\u3068test\u306b\u5206\u5272\u3059\u308b\n    train_df = df[df['winPlacePerc'].notnull()]\n    test_df = df[df['winPlacePerc'].isnull()]\n    print(\"Starting LightGBM. Train shape: {}, test shape: {}\".format(train_df.shape, test_df.shape))\n    del df\n    gc.collect()\n\n    # \u7d50\u679c\u3092\u3044\u308c\u308b\u305f\u3081\u306e\u914d\u5217\u3068\uff0c\u7279\u5fb4\u91cf\u306e\u91cd\u8981\u5ea6\u3092\u5165\u308c\u3066\u304a\u304f\u305f\u3081\u306e\u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0\u3092\u4f5c\u6210\n    oof_preds = np.zeros(train_df.shape[0])\n    sub_preds = np.zeros(test_df.shape[0])\n    feature_importance_df = pd.DataFrame()\n    \n    # \u5fc5\u8981\u306a\u3044\u7279\u5fb4\u91cf\uff0c\u30bf\u30fc\u30b2\u30c3\u30c8\u306a\u3069\u3092\u9664\u3044\u305f\u3082\u306e\u3092feats\u306b\u5165\u308c\u308b\n    drop_features = ['Id', 'groupId', 'matchId', 'matchType', 'winPlacePerc']    \n    feats = [f for f in train_df.columns if f not in drop_features]\n\n    # Create model\n    if num_folds == 1:\n        #train\u306e8\u5272\u3092train_x\uff0ctrain_y\u306b\uff0c\u6b8b\u308a\u306e2\u5272\u3092valid_x, valid_y\u306b\n        train_x, valid_x, train_y, valid_y = train_test_split(train_df[feats], train_df['winPlacePerc'], test_size=0.2, random_state=1001)\n        model.fit(train_x, train_y, eval_set=[(train_x, train_y), (valid_x, valid_y)],\n            eval_metric= 'mae', verbose=params['verbose'], early_stopping_rounds=params['early_stopping_rounds'])\n\n        oof_preds = model.predict(train_df[feats])\n        sub_preds = model.predict(test_df[feats])\n\n        fold_importance_df = pd.DataFrame()\n        fold_importance_df[\"feature\"] = feats\n        fold_importance_df[\"importance\"] = model.feature_importances_\n        fold_importance_df[\"fold\"] = 1\n        feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0)\n        print('MAE : %.6f' % (mean_absolute_error(train_df['winPlacePerc'], oof_preds)))\n        del train_x, train_y, valid_x, valid_y\n        gc.collect()\n\n    # \u30af\u30ed\u30b9\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u3059\u308b\u30e2\u30c7\u30eb\n    elif num_folds > 1:\n        folds = KFold(n_splits= num_folds, shuffle=True, random_state=1001)\n        for n_fold, (train_idx, valid_idx) in enumerate(folds.split(train_df[feats], train_df['winPlacePerc'])):\n            train_x, train_y = train_df[feats].iloc[train_idx], train_df['winPlacePerc'].iloc[train_idx]\n            valid_x, valid_y = train_df[feats].iloc[valid_idx], train_df['winPlacePerc'].iloc[valid_idx]\n\n            model.fit(train_x, train_y, eval_set=[(train_x, train_y), (valid_x, valid_y)],\n                eval_metric= 'mae', verbose=params['verbose'], early_stopping_rounds=params['early_stopping_rounds'])\n            \n            #\u5b66\u7fd2\u306b\u4f7f\u7528\u3057\u3066\u3044\u306a\u3044\u90e8\u5206\u306e\u30c7\u30fc\u30bf\u3092\u30e2\u30c7\u30eb\u306b\u5165\u308c\u3066\u4e88\u6e2c\u3057\u305f\u3082\u306e\u3092oof\u306b(\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u30b9\u30b3\u30a2\u7528)\n            oof_preds[valid_idx] = model.predict(valid_x)\n            #\u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\u306b\u5bfe\u3057\u3066\u306f\uff0cn\u56de\u76ee\u306e\u30af\u30ed\u30b9\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u3067\u4f7f\u7528\u3057\u305f\u30c7\u30fc\u30bf\u306e\u90e8\u5206\u3067\u5b66\u7fd2\u3057\u305f\u30e2\u30c7\u30eb\u3067\u4e88\u6e2c\uff0en\u56de\u306e\u30af\u30ed\u30b9\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u306e\u5e73\u5747\u3092\u3068\u308b\u305f\u3081\uff0c \/folds.n_splits\u3068\u3057\u3066\u3044\u308b\n            sub_preds += model.predict(test_df[feats]) \/ folds.n_splits\n\n            fold_importance_df = pd.DataFrame()\n            fold_importance_df[\"feature\"] = feats\n            fold_importance_df[\"importance\"] = model.feature_importances_\n            fold_importance_df[\"fold\"] = n_fold + 1\n            feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0)\n            print('Fold %2d MAE : %.6f' % (n_fold + 1, mean_absolute_error(valid_y, oof_preds[valid_idx])))\n            del train_x, train_y, valid_x, valid_y\n            gc.collect()\n\n    print('Full MAE score %.6f' % mean_absolute_error(train_df['winPlacePerc'], oof_preds))\n    return oof_preds, sub_preds, feature_importance_df","a0f1c522":"import lightgbm as lgb\n\nparams = {\n    'num_leaves': 144,\n    'learning_rate': 0.1,\n    'n_estimators': 800,\n    'max_depth':12,\n    'max_bin':55,\n    'bagging_fraction':0.8,\n    'bagging_freq':5,\n    'feature_fraction':0.9,\n    'verbose':50, \n    'early_stopping_rounds':100\n    }\n\n# LightGBM parameters\nlgbm_reg = lgb.LGBMRegressor(num_leaves=params['num_leaves'], learning_rate=params['learning_rate'], \n                    n_estimators=params['n_estimators'], max_depth=params['max_depth'],\n                    max_bin = params['max_bin'], bagging_fraction = params['bagging_fraction'], \n                    bagging_freq = params['bagging_freq'], feature_fraction = params['feature_fraction'],\n                   )\n\nlgb_oof_preds, lgb_sub_preds, lgb_feature_importance_df = oof_model_preds(dataset, lgbm_reg, num_folds=4, params=params)","ed28ca5a":"def display_importances(feature_importance_df_):\n    cols = feature_importance_df_[[\"feature\", \"importance\"]].groupby(\"feature\").mean().sort_values(by=\"importance\", ascending=False)[:40].index\n    best_features = feature_importance_df_.loc[feature_importance_df_.feature.isin(cols)]\n    plt.figure(figsize=(8, 10))\n    sns.barplot(x=\"importance\", y=\"feature\", data=best_features.sort_values(by=\"importance\", ascending=False))\n    plt.title('LightGBM Features (avg over folds)')\n    plt.tight_layout()\n    plt.savefig('lgbm_importances.png')","ea8ff6a1":"display_importances(lgb_feature_importance_df)","0d16008f":"sub = pd.DataFrame()\nsub['Id'] = test_df['Id']\nsub['winPlacePerc'] = lgb_sub_preds\nsub['winPlacePerc'][sub['winPlacePerc'] > 1] = 1\n\nsub.to_csv('lgb_submission.csv',index=False)","263755aa":"### explore dataset","ca1e9195":"###  create submission file","e58f1887":"### check dataset","a4679fd4":"## \u30d2\u30fc\u30c8\u30de\u30c3\u30d7\u3092\u898b\u308b\u3068killPlace\u306a\u3069\u304cwinPlacePerc\u3068\u76f8\u95a2\u304c\u3042\u308b\u307f\u305f\u3044**","ddf6a917":"##### Number of Team Members","3fb46fcf":"#### null check","c58d1856":"### Display\/plot feature importance","be9fde66":"#### Correlation","4b72ae3f":"### model\n- LightGBM","ca653ae1":"### target\n*PUBG Finish Placement*","6007db0d":"##### reduce memory","6e972fb5":"#### LightGBM","3c03c4d6":"##### matchType","76bda114":"pubg-simple-LightGBM\n\n### PUBG Finish Placement Prediction (Kernels Only)\nhttps:\/\/www.kaggle.com\/c\/pubg-finish-placement-prediction\n\nCan you predict the battle royale finish of PUBG Players?\n\n*What's the best strategy to win in PUBG?*\n\n### reference\n- https:\/\/www.kaggle.com\/rejasupotaro\/effective-feature-engineering\n- https:\/\/www.kaggle.com\/mlisovyi\/relativerank-of-predictions\/notebook\n- https:\/\/www.kaggle.com\/jsaguiar\/lightgbm-with-simple-features","9c2d7bf0":"### feature engineering [WIP]"}}