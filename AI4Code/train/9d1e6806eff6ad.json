{"cell_type":{"0e53d6d6":"code","ec77cddb":"code","0e1f86d0":"code","df188611":"code","a894b59b":"code","533419b1":"code","45dfd55e":"code","b4b1ba10":"code","f8979107":"code","edcb7feb":"code","ab4ffc94":"code","afdb9730":"code","4b9353e4":"code","75526a97":"code","e87b3e16":"code","696974a9":"code","2639db2a":"markdown","cf53da50":"markdown","c4d31ff0":"markdown","33e584cb":"markdown","08d37485":"markdown"},"source":{"0e53d6d6":"# Loading libs\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom torch.utils import data\nimport torchvision\nfrom torchvision import models\n\nimport cv2\nfrom pathlib import Path\nimport glob","ec77cddb":"# Up TensorFlow, so driver up too - > torch can upgrade too\ntorch.__version__","0e1f86d0":"# Model from:\n# https:\/\/github.com\/ternaus\/TernausNet\/blob\/master\/unet_models.py\ndef conv3x3(in_, out):\n    return nn.Conv2d(in_, out, 3, padding=1)\n\nclass ConvRelu(nn.Module):\n    def __init__(self, in_, out):\n        super().__init__()\n        self.conv = conv3x3(in_, out)\n        self.activation = nn.ReLU(inplace=True)\n\n    def forward(self, x):\n        x = self.conv(x)\n        x = self.activation(x)\n        return x\n\nclass DecoderBlock(nn.Module):\n    def __init__(self, in_channels, middle_channels, out_channels):\n        super().__init__()\n\n        self.block = nn.Sequential(\n            ConvRelu(in_channels, middle_channels),\n            nn.ConvTranspose2d(middle_channels, out_channels, kernel_size=3, stride=2, padding=1, output_padding=1),\n            nn.ReLU(inplace=True)\n        )\n\n    def forward(self, x):\n        return self.block(x)\n\nclass UNet11(nn.Module):\n    def __init__(self, num_filters=32):\n        \"\"\"\n        :param num_classes:\n        :param num_filters:\n        \"\"\"\n        super().__init__()\n        self.pool = nn.MaxPool2d(2, 2)\n\n        # Convolutions are from VGG11\n        self.encoder = models.vgg11().features\n        \n        # \"relu\" layer is taken from VGG probably for generality, but it's not clear \n        self.relu = self.encoder[1]\n        \n        self.conv1 = self.encoder[0]\n        self.conv2 = self.encoder[3]\n        self.conv3s = self.encoder[6]\n        self.conv3 = self.encoder[8]\n        self.conv4s = self.encoder[11]\n        self.conv4 = self.encoder[13]\n        self.conv5s = self.encoder[16]\n        self.conv5 = self.encoder[18]\n\n        self.center = DecoderBlock(num_filters * 8 * 2, num_filters * 8 * 2, num_filters * 8)\n        self.dec5 = DecoderBlock(num_filters * (16 + 8), num_filters * 8 * 2, num_filters * 8)\n        self.dec4 = DecoderBlock(num_filters * (16 + 8), num_filters * 8 * 2, num_filters * 4)\n        self.dec3 = DecoderBlock(num_filters * (8 + 4), num_filters * 4 * 2, num_filters * 2)\n        self.dec2 = DecoderBlock(num_filters * (4 + 2), num_filters * 2 * 2, num_filters)\n        self.dec1 = ConvRelu(num_filters * (2 + 1), num_filters)\n        \n        self.final = nn.Conv2d(num_filters, 1, kernel_size=1, )\n\n    def forward(self, x):\n        conv1 = self.relu(self.conv1(x))\n        conv2 = self.relu(self.conv2(self.pool(conv1)))\n        conv3s = self.relu(self.conv3s(self.pool(conv2)))\n        conv3 = self.relu(self.conv3(conv3s))\n        conv4s = self.relu(self.conv4s(self.pool(conv3)))\n        conv4 = self.relu(self.conv4(conv4s))\n        conv5s = self.relu(self.conv5s(self.pool(conv4)))\n        conv5 = self.relu(self.conv5(conv5s))\n\n        center = self.center(self.pool(conv5))\n\n        # Deconvolutions with copies of VGG11 layers of corresponding size \n        dec5 = self.dec5(torch.cat([center, conv5], 1))\n        dec4 = self.dec4(torch.cat([dec5, conv4], 1))\n        dec3 = self.dec3(torch.cat([dec4, conv3], 1))\n        dec2 = self.dec2(torch.cat([dec3, conv2], 1))\n        dec1 = self.dec1(torch.cat([dec2, conv1], 1))\n        return torch.sigmoid(self.final(dec1))\n\ndef unet11(**kwargs):\n    model = UNet11(**kwargs)\n    return model\n\ndef get_model():\n    np.random.seed(717)\n    torch.cuda.manual_seed(717);\n    torch.manual_seed(717);\n    model = unet11()\n    model.train()\n    return model.to(device)","df188611":"directory = '..\/input'\ndevice = 'cuda'","a894b59b":"def load_image(path, mask = False):\n    \"\"\"\n    Load image from a given path and pad it on the sides, so that eash side is divisible by 32 (newtwork requirement)\n    \n    if pad = True:\n        returns image as numpy.array, tuple with padding in pixels as(x_min_pad, y_min_pad, x_max_pad, y_max_pad)\n    else:\n        returns image as numpy.array\n    \"\"\"\n    img = cv2.imread(str(path))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    \n    height, width, _ = img.shape\n\n    # Padding in needed for UNet models because they need image size to be divisible by 32 \n    if height % 32 == 0:\n        y_min_pad = 0\n        y_max_pad = 0\n    else:\n        y_pad = 32 - height % 32\n        y_min_pad = int(y_pad \/ 2)\n        y_max_pad = y_pad - y_min_pad\n        \n    if width % 32 == 0:\n        x_min_pad = 0\n        x_max_pad = 0\n    else:\n        x_pad = 32 - width % 32\n        x_min_pad = int(x_pad \/ 2)\n        x_max_pad = x_pad - x_min_pad\n    \n    img = cv2.copyMakeBorder(img, y_min_pad, y_max_pad, x_min_pad, x_max_pad, cv2.BORDER_REFLECT_101)\n    if mask:\n        # Convert mask to 0 and 1 format\n        img = img[:, :, 0:1] \/\/ 255\n        return torch.from_numpy(np.transpose(img, (2, 0, 1)).astype('float32'))\n    else:\n        img = img \/ 255.0\n        return torch.from_numpy(np.transpose(img, (2, 0, 1)).astype('float32'))","533419b1":"class TGSSaltDataset(data.Dataset):\n    def __init__(self, root_path, file_list, is_test = False):\n        self.is_test = is_test\n        self.root_path = root_path\n        self.file_list = file_list\n    \n    def __len__(self):\n        return len(self.file_list)\n    \n    def __getitem__(self, index):\n        if index not in range(0, len(self.file_list)):\n            return self.__getitem__(np.random.randint(0, self.__len__()))\n        \n        file_id = self.file_list[index]\n        \n        image_folder = os.path.join(self.root_path, \"images\")\n        image_path = os.path.join(image_folder, file_id + \".png\")\n        \n        mask_folder = os.path.join(self.root_path, \"masks\")\n        mask_path = os.path.join(mask_folder, file_id + \".png\")\n        \n        image = load_image(image_path)\n        \n        if self.is_test:\n            return (image,)\n        else:\n            mask = load_image(mask_path, mask = True)\n            return image, mask\n\ndepths_df = pd.read_csv(os.path.join(directory, 'train.csv'))\n\ntrain_path = os.path.join(directory, 'train')\nfile_list = list(depths_df['id'].values)","45dfd55e":"torch.backends.cudnn.deterministic = True","b4b1ba10":"file_list_val = file_list[::10]\nfile_list_train = [f for f in file_list if f not in file_list_val]\ndataset = TGSSaltDataset(train_path, file_list_train)\ndataset_val = TGSSaltDataset(train_path, file_list_val)\n\nmodel = get_model()","f8979107":"%%time\nepoch = 3\nlearning_rate = 1e-4\nloss_fn = torch.nn.BCELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\nfor e in range(epoch):\n    train_loss = []\n    for image, mask in data.DataLoader(dataset, batch_size = 30, shuffle = True):\n        image = image.type(torch.FloatTensor).to(device)\n        y_pred = model(image)\n        loss = loss_fn(y_pred, mask.to(device))\n\n        optimizer.zero_grad()\n        loss.backward()\n\n        optimizer.step()\n        train_loss.append(loss.item())\n        \n    val_loss = []\n    for image, mask in data.DataLoader(dataset_val, batch_size = 50, shuffle = False):\n        image = image.cuda()\n        y_pred = model(image)\n\n        loss = loss_fn(y_pred, mask.to(device))\n        val_loss.append(loss.item())\n\n    print(\"Epoch: %d, Train: %.5f, Val: %.5f\" % (e, np.mean(train_loss), np.mean(val_loss)))","edcb7feb":"def count_params(model):\n    \"\"\"Count the number of parameters\"\"\"\n    param_count = np.sum([torch.numel(p) for p in model.parameters()])\n    return param_count","ab4ffc94":"print('Total parametrs before squeeze: ',count_params(model))","afdb9730":"features_3ch = model.encoder[0](image)","4b9353e4":"def squeeze_weights(m):\n        m.weight.data = m.weight.data.sum(dim=1)[:,None]\n        m.in_channels = 1\nmodel.encoder[0].apply(squeeze_weights);\nprint('Total parametrs after squeeze: ',count_params(model))","75526a97":"features_1ch = model.encoder[0](image[:,0][:,None])\n(features_1ch-features_3ch).sum().item()","e87b3e16":"model2 = get_model()\nmodel2.encoder[0].apply(squeeze_weights);","696974a9":"%%time\nepoch = 3\nlearning_rate = 1e-4\nloss_fn = torch.nn.BCELoss()\noptimizer = torch.optim.Adam(model2.parameters(), lr=learning_rate)\nfor e in range(epoch):\n    train_loss = []\n    for image, mask in data.DataLoader(dataset, batch_size = 30, shuffle = True):\n        optimizer.zero_grad()\n        image = image[:,0][:,None].type(torch.FloatTensor).to(device) # select only 1 channel (all channel equal)\n        y_pred = model2(image)\n        loss = loss_fn(y_pred, mask.to(device))\n        loss.backward()\n        optimizer.step()\n        train_loss.append(loss.item())\n        \n    val_loss = []\n    for image, mask in data.DataLoader(dataset_val, batch_size = 50, shuffle = False):\n        image = image[:,0][:,None].type(torch.FloatTensor).to(device) # select only 1 channel (all channel equal)\n        y_pred = model2(image)\n\n        loss = loss_fn(y_pred, mask.to(device))\n        val_loss.append(loss.item())\n\n    print(\"Epoch: %d, Train: %.5f, Val: %.5f\" % (e, np.mean(train_loss), np.mean(val_loss)))","2639db2a":"As we can see results are similar. But we have less parametrs (but really small change)","cf53da50":"Difference  very small.","c4d31ff0":"Image from dataset are grayscele, but pre-trained model is for rgb image. So chenge it.","33e584cb":"## Traing again new model with squeeze params","08d37485":"## Convert model to 1 channel input image\nRepeat again with converting model to 1 channel input image. Data from set all grayscale, so rgb channels are equal."}}