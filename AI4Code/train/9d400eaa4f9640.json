{"cell_type":{"adf2066d":"code","3fe30208":"code","b00ae71e":"code","ad1745e6":"code","4e18153d":"code","18fdc437":"code","f7bb4646":"code","82c6d6bc":"code","3dc9eaf1":"markdown","3ec329c0":"markdown","67b6e00a":"markdown","b764669b":"markdown","40628e5e":"markdown","312079a1":"markdown","1e46d24d":"markdown","65d49a8c":"markdown","93c87e54":"markdown","9c660185":"markdown","f73f6881":"markdown","b6f1c885":"markdown"},"source":{"adf2066d":"import plotly.offline\nimport plotly.graph_objs as go\nimport networkx as nx\nimport numpy as np\nimport pandas as pd\nimport sqlite3\nimport re\nfrom itertools import combinations\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nconn = sqlite3.connect('..\/input\/database.sqlite')\n\ndf_games = pd.read_sql_query('SELECT * FROM BoardGames ', conn)\n\nconn.close()\n\ntext_columns = []\nnumber_columns = []\nother_columns = []\n\nc = list(df_games.columns)\n\nfor i in range(df_games.shape[1]):\n    if df_games.iloc[:,i].dtype == 'object':\n        text_columns.append(c[i])\n    elif (df_games.iloc[:,i].dtype == 'float64') or (df_games.iloc[:,i].dtype == 'int64'):\n        number_columns.append(c[i])\n    else:\n        other_columns.append(c[i])\n        ","3fe30208":"print(\"TEXT COLUMNS:\",len(text_columns))\nfor tcol in text_columns:\n    print(tcol)\nprint('\\n')\nprint(\"NUMBER COLUMNS:\",len(number_columns))\nfor ncol in number_columns:\n    print(ncol)\nprint('\\n')\nprint(\"OTHER COLUMNS:\",len(other_columns))","b00ae71e":"text_df = df_games[text_columns]\nnmplyrs_df = text_df.iloc[:, 18:29]\nprint(list(nmplyrs_df))\nprint('\\n')\nprint(nmplyrs_df.head(10))\nprint(list(nmplyrs_df['polls.suggested_numplayers.1'].unique()))","ad1745e6":"mp_dict = {'Best': 1, np.nan: 0, 'Recommended': 1, 'NotRecommended': 0}\nremap_df = nmplyrs_df.replace(mp_dict)","4e18153d":"num_df = df_games[number_columns]\nframesCrrctd = (num_df[\"stats.bayesaverage\"], remap_df)\nnum_dfCrrctd = pd.concat(framesCrrctd, axis = 1)\nprint(num_dfCrrctd.corr())","18fdc437":"f,ax = plt.subplots(figsize=(13, 12))\nsns.heatmap(num_dfCrrctd.corr(), cmap='YlGnBu', annot=True, linewidths=.5, fmt= '.1f',ax=ax)\nplt.show()","f7bb4646":"def nKey(node):\n    se = re.search('(?<=\\.)\\w+$', node)\n    return(se.group(0))\n#the regex above reads as:\n# \"a substring of one or more alphanumeric characters preceded by '.' and followed by the end of the string.\"\n#note that '_' is alphanumeric, but '.' is not.\n\nndDict = {}\nfor node in list(num_dfCrrctd):\n    ndDict[node] = nKey(node)","82c6d6bc":"G = nx.Graph()\nG.add_nodes_from(list(num_dfCrrctd))\n\ndf_corr = num_dfCrrctd.corr()        # The correlation matrix for our dataframe\n\nnodelist = list(G.nodes)\n\nuniqueEdges = list(combinations(nodelist, 2))\ndef weight(edge):\n    return(df_corr.loc[edge])\n\nthreshold = .5                       # Controls significant correlation threshold for when edges will appear\n\nedgelist = []\nfor edge in uniqueEdges:\n    if weight(edge) >= threshold:\n         edgelist.append(edge)\n\nG.add_edges_from(edgelist)\n\nedgelist = list(G.edges)             # Ensures that the order of output is static\n\nweightD={}                           # edges and edge weights as a dict\nweightE=[]                           # edge weights as a list\nfor edge in edgelist:\n    weightD[edge] = round(weight(edge),3)\n    weightE.append(round(weight(edge),3))\n\nposlist = [(1,8),(2,0),(2,8),(1,6),(2,6),(1,4),(2,4),(1,2),(2,2),(1,0),(1,-2),(3,3)]\n#these points are contrived for a better image\n\npos = dict(zip(sorted(nodelist), poslist))\nprint(pos)\n\nplt.figure(1,figsize=(13,12))\nnx.draw_networkx(G, pos, node_color='violet', node_size=350, labels=ndDict)\nnx.draw_networkx_edges(G, pos, edgelist=edgelist, cmap=plt.get_cmap('Accent'), edge_color=weightE)\nnx.draw_networkx_edge_labels(G, pos, edge_labels=weightD)\n\nplt.axis('off')\nplt.show()","3dc9eaf1":"Now that we have remapped all of the strings and missing values to numbers, we are able to look at correlations within this set of columns as well as with stats.bayesaverage. To view these correlations we create a new dataframe of numerical columns in the next input field from the results of our mapping concatenated with the stats.bayesaverage column. ","3ec329c0":"Right away we can see that a game is a bit more likely to be successful if it is designed to play well with 2, 3, or 4 players. Some careful scrutiny of this map reveals that games reccomended for X or Y number of players tend to cluster together for certain values of X and Y. What we really want here in order to see the clustering clearly is a cool little graph which focuses on it specifically.","67b6e00a":"Some other kernels have already investigated correlations among our \"number_columns\" listed here and have found nothing surprising going on. What I would like to investigate instead is correlation among our \"text_columns\" as well as any correlation these columns may have with the \"stats.bayesaverage\" column from the second set. I have chosen this last column because according to the source site it is the most representative of their overall ranking for a game. I will use this as a somewhat naive measure of success for a game.\n\nThe first thing I notice about our \"text_columns\" is the prevalence of numbers in the \"polls.suggested.numplayers...\" columns. I would rather not spend time implementing a bunch of NLP algorithms on this stuff if I don't have to, so let's see if there is a way to quickly quantify some the data without losing its integrity. ","b764669b":"...And as long as we can, let's go ahead and view these correlations as a heatmap.","40628e5e":"Now we get cracking on our little graph. We will only graph edges for statistically significant correlations, typically .5 or greater but let's make it variable.","312079a1":"*Still more to come!*","1e46d24d":"What this graph is showing us is how often a game that is reccomended for X number of players is also reccomended for Y number of players. Would you rather design a game for 5 players or for 4? Would you want to design a game for 5 - 7 players? A lot of sales and marketing insights are gleaned from this graph!   ","65d49a8c":"First, let's setup some reasonable values for our node labels.","93c87e54":"It turns out that each of these columns has only four possible values which I will reduce to two: 1 or 0. I am interested in when a given number of players has been  reccomended for a game versus when it hasn't been. It is a safe assumption that the best number of players for a game is also a reccomended number of players. Since I am only interested in affrimative information, I can regard 'NotRecommended' as equivalent to having no data i.e. a value of None.","9c660185":"This kernel investigates a great dataset from [BoardGameGeek](http:\/\/boardgamegeek.com) (which I personally thought needed a little more love) with the goal of identifying trends in factors weighing into the design of more highly rated games. The data consists of over 90k records of games which users of the source site have rated in different categories along with some metrics related to these ratings.","f73f6881":"Now let's take a look at the attributes we are dealing with here.","b6f1c885":"First let's import the modules we intend to use and implement a script which I have selfishly borrowed from the parent kernel for classifying our columns."}}