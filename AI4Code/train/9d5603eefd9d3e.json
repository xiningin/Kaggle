{"cell_type":{"d2729942":"code","6db16825":"code","b1b3ca85":"code","4fe9bda7":"code","40882aef":"code","2ddaa19c":"code","ff7137b6":"code","f99bd953":"code","712cc2f4":"code","ab5e72bb":"code","0dc2abb8":"code","d9c0fdb3":"code","8e0dce31":"code","1fe248bb":"code","745a869f":"code","c26178d6":"code","8926a2aa":"code","92969269":"code","e22a3d79":"markdown","f9c37704":"markdown","8a77c0d5":"markdown","763e6825":"markdown","a0ad0dfc":"markdown","fa18e6f4":"markdown","47fef5b5":"markdown"},"source":{"d2729942":"# Imports \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport sqlite3\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\npath = \"..\/input\/\"  #Insert path here\ndatabase = path + 'database.sqlite'","6db16825":"conn = sqlite3.connect(database)\n\n# Let's see what tables do we have in the DB to explore\ntables = pd.read_sql(\"\"\"SELECT *\n                        FROM sqlite_master\n                        WHERE type='table';\"\"\", conn)\ntables","b1b3ca85":"# Now, let's check out on the tables we have \n\nPlayer_Attributes = pd.read_sql(\"\"\"SELECT * FROM Player_Attributes;\"\"\", conn)\nPlayer = pd.read_sql(\"\"\"SELECT * FROM Player;\"\"\", conn)\nMatch = pd.read_sql(\"\"\"SELECT * FROM Match;\"\"\", conn)\nLeague = pd.read_sql(\"\"\"SELECT * FROM League;\"\"\", conn)\nCountry = pd.read_sql(\"\"\"SELECT * FROM Country;\"\"\", conn)\nTeam = pd.read_sql(\"\"\"SELECT * FROM Team;\"\"\", conn)\nTeam_Attributes = pd.read_sql(\"\"\"SELECT * FROM Team_Attributes;\"\"\", conn)\n\n# Note that we are simply unsing a 'Select * from TableName' to get everything from every table from the DB connected\n# Next we'll show just the first row of each table so that we can have a look on what do we have here","4fe9bda7":"Player_Attributes.head(1)","40882aef":"Player.head(1)","2ddaa19c":"Match.head(1)","ff7137b6":"League.head(1)","f99bd953":"Country.head(1)","712cc2f4":"Team.head(1)","ab5e72bb":"Team_Attributes.head(1)","0dc2abb8":"# Using LEFT JOIN\n\n# On the table 'Player_Attributes' we have a lot of information about the player attributes as it's name already suggests, \n# but this table doesn't have the Name of the Player, which is on the table 'Player'\n# The table 'Player' also have information about the birthdate, height and weight of the player\n\n# So here's what we are going to do, we are going to bring the informations about the player from the table 'Player' to the table 'Player_Attributes', so this one is complete!\n\n# Left join works this way: \n# you can bring what you find about you the key (in this case, our key is player_api_id) in the table on the right side of the join to the table on the left. \n# In case we didn't find some player_api_id in the table on the right, there would be missings generated to this player_api_id, and we wouldn't know his name, but that's not the case\n\nplayer_attributes_complete = pd.read_sql(\"\"\"\n    SELECT \n        A.*,\n        B.player_name,\n        B.birthday,\n        B.height,\n        B.weight\n    FROM Player_Attributes A\n    LEFT JOIN Player AS B\n        ON A.player_api_id = B.player_api_id;\"\"\",conn)\n\n# Note that we've renamed the tables during the join: \"Player_Attributes\" has become \"A\" (implicitly) and \"Player\" has become \"B\" (by statement AS)\n# I guess you allready know what the RIGHT JOIN does by now\n\nplayer_attributes_complete.head(1)","d9c0fdb3":"# Using INNER JOIN\n\n# Inner join is just as simple as getting just the INTERSECTION between the tables in the join, \n# meaning the result of this query has only keys that where found in both tables of the inner join\n\nmatches_n_countries = pd.read_sql(\"\"\"\n    SELECT \n        A.*,\n        B.name as league_name,\n        C.name as country_name\n    FROM Match A\n    INNER JOIN League AS B\n        ON A.country_id = B.country_id\n    JOIN Country C\n        ON A.country_id = C.id;\"\"\",conn)\n\n# Note that we are doing an INNER JOIN between the tables 'Match' and 'League'\n# and we are also doing an INNER JOIN (implicitly) between tables 'Match' and 'Country'\n# The results of this query will be only matches wich we could find both it's League's name and it's country name \n# Note also that we selected only the columns we wanted to keep from the tables 'League' and 'Country'\n\nmatches_n_countries.head(1)","8e0dce31":"# Using FULL OUTER JOIN\n\n# Full Outer Join is just as simple as getting the UNION between the tables in the join, \n# meaning the result of this query will return all observations that where found in any of the tables in the full outer join\n# this is a join that can generate a lot of missings in the proccess, depending on the case \n\n# If you try running this next query, it won't work if your connection is an sqlite database\n\n# player_attributes_complete = pd.read_sql(\"\"\"\n#SELECT \n#    A.*,\n#    B.*\n#FROM Player_Attributes A\n#FULL OUTER JOIN Player AS B\n#    ON A.player_api_id = B.player_api_id;\"\"\",conn)\n\n# Note that the SQL query we are doing is similar to the first one we've made using LEFF JOIN\n# except for this time, in case there is any player on the table 'Player' that is not on the table 'Player_Attributes', he will be at the result of this query \n\n\n# If your connecion is an sqlite database, the query above won't work, so let's do this FULL OUTER JOIN in another way \n# The results shouldn't change doing it by the SQL query above or below\n\n\nFULL_players = pd.read_sql(\"\"\"\n    SELECT A.* FROM (\n         SELECT X.*, Y.* \n         FROM Player_Attributes X \n         LEFT JOIN Player Y\n             ON X.player_api_id = Y.player_api_id\n     ) A\n     UNION ALL\n     SELECT B.* FROM (\n         SELECT X.*, Y.*\n         FROM Player X\n         LEFT JOIN Player_Attributes Y\n             ON X.player_api_id = Y.player_api_id\n         WHERE Y.player_api_id IS NULL\n     ) B;\"\"\",conn)\n\n# Note that we have completed the table 'Player_Attributes' within the information remaining in the table 'Player': we've called this new table 'A'\n# Next, we have completed the table 'Player' within the information remaining in the table 'Player_Attributes' (just to the players that aren't in the table 'A', to evoid duplications): \n# we've called this new table 'B'\n# This query is equivalent the commented query using FULL OUTER JOIN in the begining of this cell\n\nFULL_players.head(1)","1fe248bb":"leages_by_season = pd.read_sql(\"\"\"\n    SELECT \n        Country.name AS country_name, \n        League.name AS league_name, \n        season,\n        count(distinct stage) AS matches_in_season,\n        count(distinct HT.team_long_name) AS number_of_teams,\n        avg(home_team_goal) AS avg_home_team_scors, \n        avg(away_team_goal) AS avg_away_team_goals, \n        avg(home_team_goal-away_team_goal) AS avg_goal_dif, \n        max(abs(home_team_goal-away_team_goal)) AS biggest_season_trash,\n        avg(home_team_goal+away_team_goal) AS avg_goals, \n        sum(home_team_goal+away_team_goal) AS total_goals,\n        max(home_team_goal+away_team_goal) AS max_goals_1match_season\n    FROM Match\n    JOIN Country \n        ON Country.id = Match.country_id\n    JOIN League \n        ON League.id = Match.league_id\n    LEFT JOIN Team AS HT \n        ON HT.team_api_id = Match.home_team_api_id\n    WHERE country_name in ('Spain', 'Germany', 'France', 'Italy', 'England')     \/* filtering just the 5 biggest leagues from Europe *\/\n    GROUP BY Country.name, League.name, season     \/*We're aggregating the data by this 3 columns, computing the functions avg, count, sum and max*\/\n    HAVING count(distinct stage) > 10     \/* selecting just seasons with more then 10 stages (rounds of matches by each club in the league in the season) *\/\n    ORDER BY Country.name, League.name, season DESC     \/*We are ordering the results by the country name (ascending), then by the league name (ascending) and by season (descending)*\/\n    ;\"\"\", conn)\n\nleages_by_season.head(1)","745a869f":"match_complete = pd.read_sql(\"\"\"\n    SELECT  \n        A.country_name, \n        A.league_name, \n        A.season,\n        A.stage,\n        A.RESULT,\n        A.RESUME,\n        A.match_date,\n        A.home_team_goal,\n        A.away_team_goal,\n        A.home_team_goal + A.away_team_goal AS total_match_goals,\n        B.team_long_name AS Home_Team_Name,\n        C.team_long_name AS Visitors_Team_Name, \n        A.RESULT || ': ' || A.RESUME || ': ' || B.team_long_name || ' ' || A.home_team_goal || ' x ' || A.away_team_goal || ' ' || C.team_long_name AS RESUME_MATCH\n        \/*CONCAT(A.RESULT,': ',A.RESUME,': ',B.team_long_name,' ',A.home_team_goal,' x ',A.away_team_goal,' ',C.team_long_name) AS RESUME_MATCH*\/\n    FROM \n    (\n        SELECT  \n            X.*,\n            DATE(X.date) as match_date,\n            CASE \n                WHEN X.home_team_goal = X.away_team_goal THEN 'DRAW'\n                WHEN X.home_team_goal > X.away_team_goal THEN 'HOME WIN'\n                WHEN X.home_team_goal < X.away_team_goal THEN 'VISITORS WIN'\n            END AS RESULT,\n            CASE\n                WHEN abs(home_team_goal - away_team_goal) >= 3 THEN 'This game was a hammer!'\n                WHEN abs(home_team_goal - away_team_goal) = 2 THEN 'A convincent win'\n                WHEN abs(home_team_goal - away_team_goal) = 1 THEN 'Minimum Victory'\n                WHEN (home_team_goal = away_team_goal) and home_team_goal > 0 THEN 'A draw with goals'\n                ELSE 'A draw without goals'\n            END AS RESUME,\n            Y.name as league_name,\n            Z.name as country_name\n        FROM Match X\n        JOIN League Y\n            ON X.country_id = Y.country_id\n        JOIN Country Z\n            ON X.country_id = Z.id\n    ) A\n    LEFT JOIN Team B\n        ON A.home_team_api_id = B.team_api_id\n    LEFT JOIN Team C\n        ON A.away_team_api_id = C.team_api_id\n    WHERE A.country_name NOT IN ('Switzerland', 'Scotland', 'Poland', 'Belgium');\"\"\", conn)\n                                    \nmatch_complete.head(1)","c26178d6":"# Getting to see the top 20 matches (in number of gols scored) of the 2015\/2016 Spanish League (La Liga) season\n\nlaliga_top20_2015_2016 = pd.read_sql(\"\"\"\n    SELECT \n        A.*,\n        RESULT || ': ' || RESUME || ': ' || Home_Team_Name || ' ' || home_team_goal || ' x ' || away_team_goal || ' ' || Visitors_Team_Name AS RESUME_MATCH\n    FROM \n    (\n        SELECT  \n            X.stage,\n            DATE(X.date) as match_date,\n            X.home_team_goal,\n            X.away_team_goal,\n            X.home_team_goal + X.away_team_goal AS total_match_goals,\n            CASE \n                WHEN X.home_team_goal = X.away_team_goal THEN 'DRAW'\n                WHEN X.home_team_goal > X.away_team_goal THEN 'HOME WIN'\n                WHEN X.home_team_goal < X.away_team_goal THEN 'VISITORS WIN'\n            END AS RESULT,\n            CASE\n                WHEN abs(home_team_goal - away_team_goal) >= 3 THEN 'This game was a hammer!'\n                WHEN abs(home_team_goal - away_team_goal) = 2 THEN 'A convincent win'\n                WHEN abs(home_team_goal - away_team_goal) = 1 THEN 'Minimum Victory'\n                WHEN (home_team_goal = away_team_goal) and home_team_goal > 0 THEN 'A draw with goals'\n                ELSE 'A draw without goals'\n            END AS RESUME,\n            B.team_long_name AS Home_Team_Name,\n            C.team_long_name AS Visitors_Team_Name\n        FROM Match X\n        LEFT JOIN Team B\n            ON X.home_team_api_id = B.team_api_id\n        LEFT JOIN Team C\n            ON X.away_team_api_id = C.team_api_id\n        JOIN Country Z\n            ON X.country_id = Z.id\n        WHERE X.season = '2015\/2016'\n            AND Z.name = 'Spain'  \n    ) A\n    ORDER BY total_match_goals DESC\n    LIMIT 20;\"\"\", conn)\n                                    \nlaliga_top20_2015_2016","8926a2aa":"top3_players_ratings = pd.read_sql(\"\"\"\n    SELECT \n        X.*,\n        ROW_NUMBER() OVER(PARTITION BY player_api_id ORDER BY date) AS RANK\n    FROM\n    (\n        SELECT \n            A.overall_rating,\n            A.player_api_id,\n            A.potential,\n            B.height,\n            B.weight,\n            DATE(A.date) as date,\n            B.player_name\n        FROM Player_Attributes A\n        JOIN Player B\n            ON A.player_api_id = B.player_api_id\n        WHERE B.player_name IN ('Lionel Messi', 'Neymar', 'Cristiano Ronaldo')\n    ) X;\"\"\",conn)\n\ntop3_players_ratings","92969269":"top3_players_ratings = pd.read_sql(\"\"\"\n    SELECT \n        A.overall_rating,\n        A.potential,\n        B.height,\n        B.weight,\n        A.date,\n        B.player_name\n    FROM Player_Attributes A\n    JOIN Player B\n        ON A.player_api_id = B.player_api_id\n    WHERE B.player_name IN ('Lionel Messi', 'Neymar', 'Cristiano Ronaldo');\"\"\",conn)\n\ntop3_players_ratings","e22a3d79":"# Presentation\n\nHello there! Hope you're fine! \n\nWe are Lucas Galdino de Camargo and Carlos Danilo Tom\u00e9, both brazilians and we're here for the same reason you are: learning, sharing and practicing on handling with data.\n\nWe are students from IFSP-Campinas (https:\/\/portal.cmp.ifsp.edu.br\/) on the Post Graduation: Specialization in Data Science (learn more about it on: https:\/\/portal.cmp.ifsp.edu.br\/index.php\/pos-graduacao\/especializacao-em-ciencia-de-dados), and this notebook was made as an activity of the course.\n\nOur goal is to use some tools from AWS throughout the course (in this case we are gonna use the Amazon RDS), as we are going to use SQL to access and to analyse the data from the database we've created.\n\n\n# Motivation\n\nRelational databases are essential to companies, making SQL an essential tool to anyone who aims to work with data.\n\nThis notebook was made to discuss a little bit about relational databases and to practice data analysis using SQL.\n\nWe are using a database of soccer, including lists of clubs, players, matches, and so on.\n\n\n# Database\n\nThe relational database we're gonna use in this notebook was created by this means: RDS from AWS, which is a relational database service based on the cloud, being easily configured, scalable, redimensionable, and offering a lot more facilities to implementing and managing a relational database with security and high performance (you can see more about Amazon RDS on https:\/\/aws.amazon.com\/pt\/rds\/). \n\n\n# Uploading the tables to the database\n\nOnce we have created the database, we can connect to it, in order to:\n   - create our tables in the DB\n   - insert\/load the data to the tables\n   - explore and analyse the data by using SQL queries\n   \n   \n# DER (Diagram Entity Relationship)\n\nDER is the Graphic representation of our relational database, showing the relationships between the tables (lern more about it on: https:\/\/www.smartdraw.com\/entity-relationship-diagram\/).\n\n\n# SQL queries\n\nOur goal here is to briefly cover at least one of each type of SQL queries from the following list:\n   - Junctions (inner join, left join, right join, ...) - you can learn more about junction queries on: https:\/\/pt.stackoverflow.com\/questions\/6441\/qual-%C3%A9-a-diferen%C3%A7a-entre-inner-join-e-outer-join\n   - Aggregations (group by, having, max, min, avg, sum, count, ...) - you can learn more about aggregation functions on: https:\/\/mode.com\/sql-tutorial\/sql-aggregate-functions\/\n   - Subqueries and functions (not in, when, date_format, concat, ...) - you can learn more about sql subqueries on: https:\/\/www.w3resource.com\/sql\/subqueries\/understanding-sql-subqueries.php\n   - Ordenations (order by, limit) - you can learn more about ordenations on: https:\/\/www.w3schools.com\/sql\/sql_top.asp\n   - Analytical functions (partition, rank, ...) - you can learn more about these sql functions on: https:\/\/dev.mysql.com\/doc\/refman\/8.0\/en\/window-function-descriptions.html","f9c37704":"# SQL queries: Aggregations\n\nWhen working on data analysis, raw data must be transformed in order to get real value over the information stored. \n\nIn that case, we must be familiar with aggregation functions from SQL, so we can transform raw data into insights and value to orientate decision making.\n\nHere we are going to explore some aggregation functions in order to answer some questions about the data we have.","8a77c0d5":"# SQL queries: Junctions\n\nThere are a lot of different types of joins we could do, but we are going to foccus to exercise on:\n   - Left join \n   - Inner join\n   - Full outer join","763e6825":"# Analytical functions\n\n\nAnalytical functions (partition, rank, ...) ","a0ad0dfc":"# Connecting to our Database\n\n","fa18e6f4":"# Subqueries and functions \n\nSometimes, you've got to transform so much your raw data that many intermediate tables are needed.\n\nIn order to make your code cleaner and reducing the intermediate tables generated in the proccess, subqueries could help you so.\n\nAnother thing we've got to know is how to use the SQL functions, essential in the routines of every single data analyst\/scientist.","47fef5b5":"# Ordenations\n\nWe have already used the 'Order By' statement in this notebook before, but let's try it some more.\n\nThe next query is going to be upon the 2015\/2016 season of the Spanish League (La Liga).\n\nWe want to see the Top 20 matches with more goals in this particular season, and we'll do it by using 'Where', 'Order By' and 'Limit' statements."}}