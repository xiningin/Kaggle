{"cell_type":{"4c65dc22":"code","c0b1c5a4":"code","8fcd5505":"code","82eb438d":"code","ddaea2dd":"code","d65f1733":"code","fa620b1f":"code","90769212":"code","c1bb288d":"code","cf05f4be":"code","a76fa112":"code","414bdd56":"code","094f4c71":"code","e3eb221c":"code","21d8a704":"code","6fadd5e6":"code","b659b5b2":"code","a4c9b50c":"code","2284f474":"code","87ce7ed9":"code","d720b130":"markdown","aadca924":"markdown","8dc2618f":"markdown","248a1bce":"markdown","e1271299":"markdown","6c05d38a":"markdown","22044de3":"markdown","d5c29f24":"markdown","26e925d2":"markdown","c637672a":"markdown","3a7b460b":"markdown","3161e726":"markdown","16f59268":"markdown","52a33153":"markdown","5a3b1e62":"markdown","56f73dd8":"markdown","09e16084":"markdown"},"source":{"4c65dc22":"import sys\nfrom typing import Union\nimport sklearn as skl\nimport joblib as jb\nimport string\nfrom tqdm.auto import tqdm, trange\nimport os\n\n# data manipulation\nimport pandas as pd\nimport numpy as np\nfrom sklearn.preprocessing import LabelEncoder","c0b1c5a4":"# read data\ngames = pd.read_csv('..\/input\/online-chess-games\/chess_games.csv', index_col='game_id')\ngames.head(2)","8fcd5505":"# missing values counts\npd.DataFrame({'dtypes': games.dtypes, 'null_count': games.isnull().sum()}).loc[lambda x: x.null_count != 0]","82eb438d":"# check if 'None' is already used in dataset\n(games.loc[:, games.dtypes.loc[lambda x: x==object].index] == 'None').any(axis=None)","ddaea2dd":"# fill missing\ngames = games.fillna(value='None')","d65f1733":"# check for survived missing values\ngames.isnull().any(axis=None)","fa620b1f":"# isolate categorical features\ngames.dtypes.loc[lambda x: x == object]","90769212":"def encode_label(arr: Union[np.array, pd.Series], *, enc: skl.preprocessing._label.LabelEncoder = None\n                ) -> (Union[np.array, pd.Series], skl.preprocessing._label.LabelEncoder):\n    \n    '''Encode label in array using passed encoder.\n    \n    If no encoder is passed a new one is created and fitted on data.'''\n    \n    try:\n        \n        # check `arr` type\n        if type(arr) != np.array and type(arr) != pd.Series:\n            raise TypeError(f'`arr` is not of a valid type ({type(arr)})')\n        \n        # check `enc` type\n        if type(enc) == skl.preprocessing._label.LabelEncoder:\n            pass\n        elif enc == None:\n            enc = LabelEncoder().fit(arr)\n        else:\n            raise TypeError(f'`enc` is not of a valid type ({type(enc)})')\n    \n    except TypeError as ex:\n        # just throw exception\n        raise ex\n        \n    except Exception:\n        # other exceptions; arguments may be of a type not valid to be used in comparisons\n        raise TypeError(f'arguments not of a valid type (arr: {type(arr)}, enc: {type(enc)})').with_traceback(sys.exc_info()[-1])\n    \n    ## try-except ##\n        \n    new_arr = enc.transform(arr)\n    \n    # copy pandas.Series attributes\n    if type(arr) == pd.Series:\n        new_arr = pd.Series(new_arr, index=arr.index, name=arr.name)\n        \n    return new_arr, enc\n\ndef encode_cols(df: pd.DataFrame, *, cols: Union[str,list] = None, enc: dict = None, n_jobs: int = -1, progress: bool = False) -> (pd.DataFrame, dict):\n    \n    '''Encode dataframe columns.\n    \n    `cols` provides columns to consider, `enc` previously used encoders.\n    If no columns are passed, all categorical features are encoded.\n    If no encoder for specified specified columns is present in `enc` it is generated a new one.\n    Return encoded dataframe and dictionary containing (column name, encoder) pairs.'''\n    \n    # avoid modifying original dataframe\n    df = df.copy()\n    \n    if cols == None:\n        # select categorical columns automatically when no col is passed\n        cols = df.dtypes.loc[lambda x: x == object].index.tolist()\n    elif type(cols) == str:\n        # convert single column to list\n        cols = [cols]\n        \n    # if no encoders dict passed use a void one\n    if enc == None:\n        enc = {}\n\n    # parallel encoding\n    results = jb.Parallel(n_jobs=-1)(jb.delayed(encode_label)(df.loc[:,col], enc = enc[col] if col in enc.keys() else None) for col in tqdm(cols, disable=not progress))\n        \n    # save results\n    for result,col in zip(results, cols):\n        df.loc[:,col] = result[0]\n        enc[col] = result[1]\n    del results\n    \n    return df, enc","c1bb288d":"games, games_encoders = encode_cols(games, cols = ['victory_status', 'winner', 'white_id', 'black_id'])","cf05f4be":"games = games.drop(columns=['opening_fullname', 'opening_code'])\ngames, games_encoders = encode_cols(games, cols = ['opening_shortname', 'opening_response', 'opening_variation'], enc = games_encoders)","a76fa112":"# split time information into initial time and time increment\ngames.insert(loc=games.columns.tolist().index('time_increment'), value=games.time_increment.apply(lambda x: x.split('+')[0]).astype(int), column='initial_time')\ngames.time_increment = games.time_increment.apply(lambda x: x.split('+')[-1]).astype(int)","414bdd56":"def decode_algebraic(move: str) -> pd.Series:\n    \n    '''Decode a single move encoded in algebraic notation.'''\n\n    pieces = {\n        '':  'Pawn',\n        'R': 'Rook',\n        'N': 'Knight',\n        'B': 'Bishop',\n        'Q': 'Queen',\n        'K': 'King'\n    }\n\n    try:\n        return pd.Series({\n            'castling':         ['Long', 'Short'][0 if 'O-O-O' in move else 1] if 'O-O' in move else np.nan,\n            'piece':            np.nan if 'O-O' in move else pieces[move[0] if move[0].isupper() else ''],\n            'pawn_file':        move[0] if 'x' in move and move[0].islower() else np.nan,\n            'pos':              move.split('=')[0][-2:] if '=' in move else move.rstrip('+#')[-2:],\n            'pawn_promotion':   pieces[move.split('=')[1][0]] if '=' in move else np.nan,\n            'capture':          'x' in move,\n            'check':            '+' in move,\n            'checkmate':        '#' in move,\n            'notation':         move\n        })\n    except Exception as ex:\n        # print move that generates an exception\n        raise ValueError(f'unable to decode move \\'{move}\\'').with_traceback(sys.exc_info()[-1])\n\n\ndef decode_game(moves: str, *, n_jobs: int = -1) -> pd.DataFrame:\n    \n    '''Decode algebraic notation of an entire game into a pandas.dataframe.'''\n\n    # indexes returned by decode_algebraic\n    features = ['castling', 'piece', 'pawn_file', 'pos', 'pawn_promotion', 'capture', 'check', 'checkmate', 'notation']\n    \n    # split single moves\n    moves = np.array(moves.split())\n    \n    # split white and black moves\n    dec = { # decoded moves\n        'white': np.compress([True, False]*(moves.shape[0]\/\/2), a=moves, axis=0),\n        'black': np.compress([False, True]*(moves.shape[0]\/\/2), a=moves, axis=0)\n    }\n    \n    # append white's last move when black did not move at the end\n    if moves.shape[0] % 2 != 0:\n        dec['white'] = np.append(dec['white'], [moves[-1]], axis=0)\n    \n    for color in dec.keys():\n        \n        # decode moves\n        dec[color] = jb.Parallel(n_jobs=n_jobs)(jb.delayed(decode_algebraic)(move) for move in dec[color])\n        \n        # concatenate moves for color\n        dec[color] = pd.DataFrame(dec[color])\n        \n        if dec[color].shape[1] == 0:\n            # player did not move at all (e.g. black immediately resigned)\n            dec[color] = pd.DataFrame(columns=pd.MultiIndex.from_product([[color], features], names=['color', 'move_feature']))\n        else:\n            dec[color].columns = pd.MultiIndex.from_product([[color], features], names=['color', ''])\n    \n    # join white and black moves into a single dataframe\n    dec = dec['white'].join(dec['black'])\n    \n    # change index to have first move labelled as 1 instead of 0\n    dec.index = pd.Index(np.arange(dec.shape[0])+1, name='move')\n    \n    return dec\n\n\ndef decode_moves(moves: pd.Series, *, n_jobs: int = -1, progress: bool = True) -> pd.DataFrame:\n    \n    '''Decode a pandas.Series containing multiple games.\n    This function provides parallel execution, speeding up the decoding process.'''\n    \n    # decoded games\n    dec = jb.Parallel(n_jobs=n_jobs)(jb.delayed(decode_game)(moves.loc[game_id]) for game_id in tqdm(moves.index, disable=not progress))\n    \n    # insert game_id as an additional index level\n    for i,game_id in enumerate(moves.index):\n        dec[i].index = pd.MultiIndex.from_product([[game_id], dec[i].index.tolist()], names=['game_id', dec[i].index.name])\n    \n    return pd.concat(dec)","094f4c71":"# example of game decoding\ndecode_game(games.moves.iloc[0])","e3eb221c":"# new dataframe with decoded moves\nmoves = decode_moves(games.moves) # should take about 20 minutes on Kaggle notebooks\ngames = games.drop(columns='moves')\n\nmoves.head()","21d8a704":"# missing values counts\npd.DataFrame({'dtypes': moves.dtypes, 'null_count': moves.isnull().sum()}).loc[lambda x: x.null_count != 0]","6fadd5e6":"# fill missing labels\nmoves = moves.fillna(value='None')","b659b5b2":"# encode labels\nmoves, moves_encoders = encode_cols(moves, cols = [(color,feat) for color in ['white', 'black'] for feat in ['castling', 'piece', 'pawn_file', 'pos', 'pawn_promotion']])","a4c9b50c":"def make_dir(path: str):\n    \n    '''Create new directory checking if it is already present or there is a name conflict with a file.'''\n    \n    if os.path.isdir(path):\n        return\n    elif os.path.isfile(path):\n        raise ValueError(f'\\'{path}\\' is a file')\n    else:\n        os.mkdir(path)","2284f474":"# save encoders\n\nencoders_dir = 'encoders'\nencoders = {'games': games_encoders, 'moves': moves_encoders}\n\nmake_dir(encoders_dir)\n\nfor label,encoder in encoders.items():\n    \n    make_dir(f'{encoders_dir}\/{label}')\n    \n    for col in encoders[label].keys():\n        \n        enc = encoders[label][col]\n        \n        # if column was multi-indexed, `col` is a tuple\n        # encoder is saved using '_' to separate different levels (e.g. `(white, piece) --> \"white_piece.pkl\"`)\n        if type(col) == tuple:\n            col = ''.join([col[i] + '_' for i in range(len(col))])[:-1]\n            \n        jb.dump(enc, f'{encoders_dir}\/{label}\/{col}.pkl')","87ce7ed9":"# save dataframes\n\ndf = {'games': games, 'moves': moves}\n\nfor label, data in df.items():\n    data.to_csv(f'{label}.csv')","d720b130":"As for games dataframe, moves needs to be preprocessed removing missing values and re-encoding categorical features (that now are separated instead of the contract notation in use originally).","aadca924":"`time_increment` contain information about game timing used.\nChess timing is described by two values:\n- **initial time**, the time given at the beginning of the game (expressed in minutes);\n- **increment**, which is the time earned at the end of each turn (expressed in seconds).\n\nIn the original dataframe these two values are written in the form `initial_time+increment`.\nIt is fine but not for computers.\nTo make that useable `time_increment` column is splitted in two new ones: `initial_time` and `time_increment` (containing only increment now).","8dc2618f":"# Introduction","248a1bce":"At this point the only categorical feature remained is `moves`.\nThis column contains game's transcription in [algebraic notation](https:\/\/en.wikipedia.org\/wiki\/Algebraic_notation_(chess)).\n\nNotation decodification needs a little bit of effort and the following functions are used to decode the entire dataframe.","e1271299":"# Labels encoding","6c05d38a":"Missing values are present only in categorical features, so they can be removed using label `'None'` label as previously.","22044de3":"This notebook encode all categorical features present in data generating a ready-to-use output for learning.\n\nThe target is achieved following these steps:\n- first missing values in categorical features are filled with `'None'` label;\n- then purely categories are encoded using sklearn label encoders;\n- `time_increment` is splitted into `initial_time` and `time_increment` (e.g. `15+2 --> (15,2)`);\n- played moves are splitted in multiple features generating a separate dataframe whose index points to the original games data;\n- eventually the resulting objects are saved as output.\n\nThe output generated is composed of the following files:\n- `games.csv` containing encoded data about games;\n- `moves.csv` containing separately re-encoded features obtained during decodification of games' moves from algebraic notation;\n- `encoders` folder containing label encoders used, saved as `encoders\/{df_name}\/{col_name}.pkl`.","d5c29f24":"Eventually labels can be encoded.\n`notation` is not encoded because it contains the original notation to check if there are any mistake in its decodification.","26e925d2":"# Missing values","c637672a":"# Game moves","3a7b460b":"# Final results","3161e726":"Missing values are present only in categorical features.\n`'None'` label can be used to fill null values.","16f59268":"# Game timing","52a33153":"This is the original dataset's dataframe:","5a3b1e62":"Purely categorical features are encoded using sklearn label encoder.","56f73dd8":"Regarding opening attributes, there are some considerations that can be done:\n- `opening_fullname` contains names that summarize shortname, response and variation;\n- dataset does not provide description about `opening_code` but it is probably generated using the same features used by fullname.\n\nBecause of the above reasons, `opening_fullname` and `opening_code` do not provide additional information and they can be dropped.\nIn addition is better having separate variables instead of one that combines others.","09e16084":"Finally dataframes and encoders are saved to disk."}}