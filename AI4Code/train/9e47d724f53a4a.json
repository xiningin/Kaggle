{"cell_type":{"0ca2e0ec":"code","85ff3c4b":"code","eb861cca":"code","42a8416e":"code","58523be5":"code","c6e337be":"code","691bb8b9":"code","c0068652":"code","e2a511cc":"code","5e6745a3":"code","e7ea834d":"markdown","c2e702a5":"markdown","d8d5b717":"markdown","dc3b94a2":"markdown","790293f8":"markdown"},"source":{"0ca2e0ec":"# The essentials\nimport numpy as np\nimport pandas as pd\n\n# Plotting\n%matplotlib inline\nimport matplotlib.pyplot as plt\n\n# Std lib\nfrom collections import defaultdict, Counter\n\nfrom tqdm import tqdm_notebook","85ff3c4b":"# load text and ciphertexts in pandas dataframe\ntrain = pd.read_csv('..\/input\/training.csv', index_col='index')\ntrain['length'] = train['text'].apply(lambda x: len(x))\n# ceil the length of the plain texts and save locally (for matching plain and cipher texts)\ntrain['length_100'] = (np.ceil(train['length'] \/ 100) * 100).astype(int)\ntest = pd.read_csv('..\/input\/test.csv')\ntest['length'] = test['ciphertext'].apply(lambda x: len(x))","eb861cca":"# Difficulty 1\nalphabet = \"\"\"7lx4v!2oQ[O=,yCzV:}dFX#(Wak\/bqne*JApK{cmf6 GZDj9gT\\'\"YSHiE]5)81hMNwI@P?Us%;30uBrLR-.$t\"\"\"\nkey =      \"\"\" etaoinsrhldcumfygwpb.v,kI\\'T\"A-SBMxDHj)CW(ELORN!FGPJz0qK?1VY:U92\/3*5;478QZ6X%$}#@={[]\"\"\"\n\ndecrypt_mapping = {}\nencrypt_mapping = {}\nfor i, j in zip(alphabet, key):\n    decrypt_mapping[ord(i)] = ord(j)\n    encrypt_mapping[ord(j)] = ord(i)\n\ndef encrypt_step1(x):\n    return x.translate(encrypt_mapping)\n\ndef decrypt_step1(x):\n    return x.translate(decrypt_mapping)\n\n# Difficulty 2\ndef encrypt_step2(plaintext, key='xenophon', alphabet='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'):\n    key_length = len(key)\n    cntr = 0\n    ciphertext = ''\n    for i, c in enumerate(plaintext):\n        if c in alphabet:\n            charIndex = alphabet.index(c)\n            keyIndex = alphabet.index(key[cntr])\n            newIndex = (charIndex + keyIndex) % len(alphabet)\n            ciphertext += alphabet[newIndex]\n            cntr = (cntr + 1) % key_length\n        else:\n            ciphertext += c\n            \n    return ciphertext\n\ndef decrypt_step2(ciphertext, key='xenophon', alphabet='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'):\n    key_length = len(key)\n    cntr = 0\n    plaintext = ''\n    for i, c in enumerate(ciphertext):\n        if c in alphabet:\n            charIndex = alphabet.index(c)\n            keyIndex = alphabet.index(key[cntr])\n            newIndex = (charIndex - keyIndex) % len(alphabet)\n            plaintext += alphabet[newIndex]\n            cntr = (cntr + 1) % key_length\n        else:\n            plaintext += c\n            \n    return plaintext\n","42a8416e":"# Count occurences of characters of ciphertexts of difficulty 2\ndiff2_cntr = Counter(''.join(test[test['difficulty'] == 2]['ciphertext'].values))\n# new dataframe with frequency and letter\ndiff2_stats = pd.DataFrame([[x[0], x[1]] for x in diff2_cntr.items()], columns=['Letter', 'Frequency'])\n# sort dataframe on occurence of frequency\ndiff2_stats = diff2_stats.sort_values(by='Frequency', ascending=True)\n\n# plot\nf, ax = plt.subplots(figsize=(5, 15))\nplt.barh(np.array(range(len(diff2_stats))) + 0.5, diff2_stats['Frequency'].values)\nplt.yticks(np.array(range(len(diff2_stats))) + 0.5, diff2_stats['Letter'].values)\nplt.show()","58523be5":"# Count occurences of characters of ciphertexts of difficulty 3\ndiff3_cntr = Counter(''.join(test[test['difficulty'] == 3]['ciphertext'].values))\n# new dataframe with frequency and letter\ndiff3_stats = pd.DataFrame([[x[0], x[1]] for x in diff3_cntr.items()], columns=['Letter', 'Frequency'])\n# sort dataframe on occurence of frequency\ndiff3_stats = diff3_stats.sort_values(by='Frequency', ascending=True)\n\n# plot\nf, ax = plt.subplots(figsize=(5, 15))\nplt.barh(np.array(range(len(diff3_stats))) + 0.5, diff3_stats['Frequency'].values)\nplt.yticks(np.array(range(len(diff3_stats))) + 0.5, diff3_stats['Letter'].values)\nplt.show()","c6e337be":"# Let's get all plaintexts of length 700 (this can be done with any length % 100 == 0)\ntrain_filtered = train[train['length'] == 700]\ntrain_filtered['cipher2'] = train_filtered['text'].apply(lambda x: encrypt_step2(encrypt_step1(x)))\n\nplain_to_cipher = defaultdict(list)\nfor i, row in tqdm_notebook(train_filtered.iterrows(), total=len(train_filtered)):\n    row_cntr = Counter(row['cipher2'])\n    test_filtered = test[(test['length'] == len(row['text'])) & (test['difficulty'] == 3)]\n    for j, row2 in test_filtered.iterrows():\n        row2_cntr = Counter(row2['ciphertext'])\n        \n        match = True\n        for k in row_cntr:\n            if k not in row2_cntr or row_cntr[k] != row2_cntr[k]:\n                match = False\n                break\n                \n        if match:\n            plain_to_cipher[i].append(j)\n            break\n            \nprint(plain_to_cipher)","691bb8b9":"mapping = defaultdict(set)\nfor k in tqdm_notebook(plain_to_cipher):\n    plain_encrypted = train_filtered.loc[k, 'cipher2']\n    plain_cntr = Counter(plain_encrypted)\n    \n    cipher = test.loc[plain_to_cipher[k][0], 'ciphertext']\n    cipher_cntr = Counter(cipher)\n    \n    for key in plain_cntr:\n        if plain_cntr[key] == 1 and cipher_cntr[key] == 1:\n            mapping[cipher.index(key)].add(plain_encrypted.index(key))\n            \nfor key in sorted(mapping.keys()):\n    print(key, mapping[key])","c0068652":"def create_table(length, n_cols=22):\n    n_rows = int(np.ceil(length \/ n_cols))\n    table = np.zeros((n_rows, n_cols))\n    table[:, 0] = list(range(n_rows))\n    \n    cntr = n_rows - 1\n    for col in range(1, n_cols \/\/ 2):\n        for row in range(n_rows):\n            if 0 < (length % n_cols) <= col and row == n_rows - 1:\n                table[row, col] = np.NaN\n            else:\n                cntr += 1\n                table[row, col] = cntr\n                \n            \n            if 0 < (length % n_cols) <= 22 - col and row == n_rows - 1:\n                table[row, 22 - col] = np.NaN\n            else:\n                cntr += 1\n                table[row, 22 - col] = cntr\n            \n    for row in range(n_rows):\n        if 0 < (length % n_cols) <= n_cols \/\/ 2 and row == n_rows - 1:\n            table[row, n_cols \/\/ 2] = np.NaN\n        else:\n            cntr += 1\n            table[row, n_cols \/\/ 2] = cntr\n        \n    return table\n\nnp.set_printoptions(edgeitems=30, linewidth=100000, \n                    formatter=dict(float=lambda x: \"% 4g\" % x))\ncreate_table(300)\n\n# We now number the cells in this table from 0 -> L, starting from the left and top and going from left to right and from top to bottom.\n# For length 300, the mapping thus becomes:\n# * Map character k in 0 - 13 on 22 * k\n# * Map character 14 on 1\n# * Map character 15 on 21\n# * Map character 16 on 23\n# * Map character 17 on 43\n# ...","e2a511cc":"def create_map(text, n_cols=22):\n    table = create_table(len(text), n_cols=n_cols)\n    mapping = {}\n    rev_mapping = {}\n    for i, c in enumerate(text):\n        row_ix, col_ix = [x[0] for x in np.where(table == i)]\n        new_pos = row_ix * n_cols + col_ix\n        mapping[i] = new_pos\n        rev_mapping[new_pos] = i\n\n    return mapping, rev_mapping\n\ndef encrypt_step3(text):\n    mapping, _ = create_map(text)\n    output = ''\n    for i, c in enumerate(text):\n        output += text[mapping[i]]\n    return output\n\ndef decrypt_step3(text):\n    _, rev_mapping = create_map(text)\n    output = ''\n    for i, c in enumerate(text):\n        output += text[rev_mapping[i]]\n    return output","5e6745a3":"cipher = test[(test['difficulty'] == 3)].sample(1).iloc[0, :]['ciphertext']\nstep1 = decrypt_step3(cipher)\nstep2 = decrypt_step2(step1)\nstep3 = decrypt_step1(step2)\nprint(step3)","e7ea834d":"**While the ciphertexts for which we generated the barplots vary (the ciphertexts of difficulty 2 and difficulty 3 are not the same) we can clearly see that the distributions (almost) exactly match. This is a clear indication of a transposition cipher, where the letters of a text are just permuted.**\n\n# More importantly, we can easily match cipher- and plaintexts now, since we know that the distributions of the text encrypted until level 2 must exactly match the ciphertext of difficulty 3 (with padding included)","c2e702a5":"# 0. Loading the prerequisites, based on the two previous kernels","d8d5b717":"# 1. Frequency analysis difficulty 2 vs difficulty 3","dc3b94a2":"# We find a pattern that is very related to the difficulty 4 challenge of previous competition, where we have to construct a transposition table that is used to permute the original text. \n\n- By looking at the first values, we see a periodicity of 22 occur (0 -> 22, 13 -> 286, 15 -> 330).\n- This pattern stops after ceil(700 \/ 22) = 32 characters, e.g. 33 -> 21\n- An interesting sequence: \n```\n114 {218}\n115 {222}\n116 {240}\n117 {244}\n```\n**--> We see that there is a difference of 22 between `116` & `114` and between `115` & `117`, which is exactly the number of columns\/periodicity we noticed before!**\n\nAfter looking at a lot of mappings for different lengths, we found the following pattern:\n\n1) The first $ceil(\\frac{L}{22})$, with $L$ the length of the input are mapped as follows: character on position $k$ is mapped to position $k * 22$\n\n2) Then a transposition table is used for the following mappings, and we switch for the between column $1 + i$ and $22 - i$","790293f8":"# Now, to find out to which position a certain letter is mapped, we search for letters that occur only once in the encrypted plaintext and see to which index it is mapped in the ciphertext"}}