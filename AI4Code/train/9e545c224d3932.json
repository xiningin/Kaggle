{"cell_type":{"783670e8":"code","73e1e017":"code","0f634661":"code","7523e854":"code","6b0f9a0f":"code","ea4b250e":"code","3a9d7035":"code","2e49a086":"code","2bef7633":"code","839db56a":"code","1d40b6f9":"code","c3f3b4d8":"code","3d43eeaf":"code","302db6fb":"code","c3fe761a":"markdown","e669eb4f":"markdown","6eb7b141":"markdown","3141d9cd":"markdown","a649a422":"markdown","6fdb4f99":"markdown","aacd4d68":"markdown","2ce0a76d":"markdown","a63e757e":"markdown","0ec38c8d":"markdown","932b6b00":"markdown","4087423a":"markdown","1971311b":"markdown","afab8e20":"markdown","2b418503":"markdown","3c182ab1":"markdown","1117b750":"markdown","0213da0c":"markdown","fc1f7bb6":"markdown"},"source":{"783670e8":"!pip install kaggle-environments --upgrade","73e1e017":"%%writefile submission.py\n\nfrom kaggle_environments.envs.halite.helpers import *\nfrom random import choice\n\nBOARD_SIZE = None\nEPISODE_STEPS = None\nCONVERT_COST = None\nSPAWN_COST = None\n\nNORTH = ShipAction.NORTH\nEAST = ShipAction.EAST\nSOUTH = ShipAction.SOUTH\nWEST = ShipAction.WEST\nCONVERT = ShipAction.CONVERT\nSPAWN = ShipyardAction.SPAWN\n\nDIRECTIONS = [NORTH, EAST, SOUTH, WEST]\n\nMOVEMENT_TACTICS = [\n    [NORTH, EAST, SOUTH, WEST],\n    [NORTH, WEST, SOUTH, EAST],\n    [EAST, SOUTH, WEST, NORTH],\n    [EAST, NORTH, WEST, SOUTH],\n    [SOUTH, WEST, NORTH, EAST],\n    [SOUTH, EAST, NORTH, WEST],\n    [WEST, NORTH, EAST, SOUTH],\n    [WEST, SOUTH, EAST, NORTH],\n]\nN_MOVEMENT_TACTICS = len(MOVEMENT_TACTICS)","0f634661":"%%writefile -a submission.py\n\nclass Controller:\n    def __init__(self, obs, config):\n        \"\"\" Initialize parameters \"\"\"\n        global BOARD_SIZE, EPISODE_STEPS, CONVERT_COST, SPAWN_COST\n        self.board = Board(obs, config)\n        self.player = self.board.current_player\n        self.STEP = obs.step\n        \n        # Define global constants\n        if self.STEP == 0:\n            BOARD_SIZE = config.size\n            EPISODE_STEPS = config.episodeSteps\n            CONVERT_COST = config.convertCost\n            SPAWN_COST = config.spawnCost\n            \n        self.FINAL_STEP = self.STEP == EPISODE_STEPS - 2\n        self.N_SHIPS = len(self.player.ships)\n        self.N_SHIPYARDS = len(self.player.shipyards)\n\n        # Cell tracking to avoid collisions of current player's ships\n        self.ship_cells = set(s.cell for s in self.player.ships)\n        self.ship_count = self.N_SHIPS\n        self.shipyard_count = self.N_SHIPYARDS\n        self.halite = self.player.halite\n\n        # Minimum total halite before ships can convert\n        self.CONVERT_THRESHOLD = CONVERT_COST + 3 * SPAWN_COST\n\n        stocks = [c.halite for c in self.board.cells.values() if c.halite > 0]\n        average_halite = int(sum(stocks) \/ len(stocks)) if len(stocks) > 0 else 0\n        # Minimum halite a cell must have before a ship will harvest\n        self.LOW_HALITE = max(average_halite \/\/ 2, 4)\n\n        # Minimum number of ships at any time\n        self.MIN_SHIPS = 10\n        # Maximum number of ships to spawn\n        self.MAX_SHIPS = 0\n        # Increase MAX_SHIPS in first half of game only\n        if self.STEP < EPISODE_STEPS \/\/ 2:\n            total_ships = sum(len(p.ships) for p in self.board.players.values())\n            if total_ships > 0:\n                self.MAX_SHIPS = (average_halite \/\/ total_ships) * 10\n        # Fix MAX_SHIPS if less than MIN_SHIPS\n        self.MAX_SHIPS = max(self.MIN_SHIPS, self.MAX_SHIPS)\n\n    def clear(self, cell):\n        \"\"\" Check if cell is safe to move in \"\"\"\n        if (cell.ship is not None and\n                cell.ship not in self.player.ships):\n            return False\n\n        if (cell.shipyard is not None and\n                cell.shipyard not in self.player.shipyards):\n            return False\n\n        if cell in self.ship_cells:\n            return False\n        return True\n\n    def hostile_ship_near(self, cell, halite):\n        \"\"\" Check if hostile ship is one move away and has less or equal halite \"\"\"\n        neighbors = [cell.neighbor(d.to_point()) for d in DIRECTIONS]\n        for neighbor in neighbors:\n            if (neighbor.ship is not None and\n                neighbor.ship not in self.player.ships and\n                    neighbor.ship.halite <= halite):\n                return True\n        return False\n\n    def spawn(self, shipyard):\n        \"\"\" Spawn ship from shipyard \"\"\"\n        shipyard.next_action = SPAWN\n        self.halite -= SPAWN_COST\n        self.ship_count += 1\n        # Cell tracking to avoid collisions of current player's ships\n        self.ship_cells.add(shipyard.cell)\n\n    def convert(self, ship):\n        \"\"\" Convert ship to shipyard \"\"\"\n        ship.next_action = CONVERT\n        self.halite -= CONVERT_COST\n        self.ship_count -= 1\n        self.shipyard_count += 1\n        # Cell tracking to avoid collisions of current player's ships\n        self.ship_cells.remove(ship.cell)\n\n    def move(self, ship, direction):\n        \"\"\" Move ship in direction \"\"\"\n        ship.next_action = direction\n        # Cell tracking to avoid collisions of current player's ships\n        if direction is not None:\n            d_cell = ship.cell.neighbor(direction.to_point())\n            self.ship_cells.remove(ship.cell)\n            self.ship_cells.add(d_cell)\n            \n    def endgame(self, ship):\n        \"\"\"\" Final step: convert if possible \"\"\"\n        if (self.FINAL_STEP and\n                ship.halite >= CONVERT_COST):\n            self.convert(ship)\n            return True\n        return False\n    \n    def build_shipyard(self, ship):\n        \"\"\" Convert to shipyard if necessary \"\"\"\n        if (self.shipyard_count == 0 and\n              self.ship_count < self.MAX_SHIPS and\n              self.STEP < EPISODE_STEPS \/\/ 2 and\n              self.halite + ship.halite >= self.CONVERT_THRESHOLD and\n              not self.hostile_ship_near(ship.cell, ship.halite)):\n            self.convert(ship)\n            return True\n        return False\n    \n    def stay_on_cell(self, ship):\n        \"\"\" Stay on current cell if profitable and safe \"\"\"\n        if (ship.cell.halite > self.LOW_HALITE and\n              not self.hostile_ship_near(ship.cell, ship.halite)):\n            ship.next_action = None\n            return True\n        return False\n    \n    def go_for_halite(self, ship):\n        \"\"\" Ship will move to safe cell with largest amount of halite \"\"\"\n        neighbors = [(d, ship.cell.neighbor(d.to_point())) for d in DIRECTIONS]\n        candidates = [(d, c) for d, c in neighbors if self.clear(c) and\n                      not self.hostile_ship_near(c, ship.halite) and\n                      c.halite > self.LOW_HALITE]\n\n        if candidates:\n            stocks = [c.halite for d, c in candidates]\n            max_idx = stocks.index(max(stocks))\n            direction = candidates[max_idx][0]\n            self.move(ship, direction)\n            return True\n        return False\n\n    def unload_halite(self, ship):\n        \"\"\" Unload ship's halite if it has any and vacant shipyard is near \"\"\"\n        if ship.halite > 0:\n            for d in DIRECTIONS:\n                d_cell = ship.cell.neighbor(d.to_point())\n\n                if (d_cell.shipyard is not None and\n                        self.clear(d_cell)):\n                    self.move(ship, d)\n                    return True\n        return False\n\n    def standard_patrol(self, ship):\n        \"\"\" Ship will move in circles clockwise or counterclockwise if safe\"\"\"\n        # Choose movement tactic\n        i = int(ship.id.split(\"-\")[0]) % N_MOVEMENT_TACTICS\n        directions = MOVEMENT_TACTICS[i]\n        # Select initial direction\n        n_directions = len(directions)\n        j = (self.STEP \/\/ BOARD_SIZE) % n_directions\n        # Move to first safe direction found\n        for _ in range(n_directions):\n            direction = directions[j]\n            d_cell = ship.cell.neighbor(direction.to_point())\n            # Check if direction is safe\n            if (self.clear(d_cell) and\n                    not self.hostile_ship_near(d_cell, ship.halite)):\n                self.move(ship, direction)\n                return True\n            # Try next direction\n            j = (j + 1) % n_directions\n        # No safe direction\n        return False\n\n    def safety_convert(self, ship):\n        \"\"\" Convert ship if not on shipyard and hostile ship is near \"\"\"\n        if (ship.cell.shipyard is None and\n            self.hostile_ship_near(ship.cell, ship.halite) and\n                ship.halite >= CONVERT_COST):\n            self.convert(ship)\n            return True\n        return False\n\n    def crash_shipyard(self, ship):\n        \"\"\" Crash into opponent shipyard \"\"\"\n        for d in DIRECTIONS:\n            d_cell = ship.cell.neighbor(d.to_point())\n\n            if (d_cell.shipyard is not None and\n                    d_cell.shipyard not in self.player.shipyards):\n                self.move(ship, d)\n                return True\n        return False\n\n    def actions_of_ships(self):\n        \"\"\" Next actions of every ship \"\"\"\n        for ship in self.player.ships:\n            # Act according to first acceptable tactic\n            if self.endgame(ship):\n                continue\n            if self.build_shipyard(ship):\n                continue\n            if self.stay_on_cell(ship):\n                continue\n            if self.go_for_halite(ship):\n                continue\n            if self.unload_halite(ship):\n                continue\n            if self.standard_patrol(ship):\n                continue\n            if self.safety_convert(ship):\n                continue\n            if self.crash_shipyard(ship):\n                continue\n            # Default random action\n            self.move(ship, choice(DIRECTIONS + [None]))\n\n    def actions_of_shipyards(self):\n        \"\"\" Next actions of every shipyard \"\"\"\n        # Spawn ships from every shipyard if possible\n        for shipyard in self.player.shipyards:\n            if (self.ship_count < self.MAX_SHIPS and\n                self.halite >= SPAWN_COST and\n                not self.FINAL_STEP and\n                    self.clear(shipyard.cell)):\n                self.spawn(shipyard)\n            else:\n                shipyard.next_action = None\n\n    def next_actions(self):\n        \"\"\" Perform next actions for current player \"\"\"\n        self.actions_of_ships()\n        self.actions_of_shipyards()\n        return self.player.next_actions\n","7523e854":"%%writefile -a submission.py\n\ndef agent(obs, config):\n    controller = Controller(obs, config)\n    return controller.next_actions()","6b0f9a0f":"%%writefile attack_bot.py\nfrom kaggle_environments.envs.halite.helpers import *\n\nDIRECTIONS = [ShipAction.NORTH, ShipAction.EAST, \n              ShipAction.SOUTH, ShipAction.WEST]\n\ndef agent(obs, config):\n    board = Board(obs, config)\n    player = board.current_player\n    next_cells = set()\n\n    def safe(c, halite):\n        if c in next_cells:\n            return False\n        good = player.ships + player.shipyards + [None]\n        if c.shipyard not in good:\n            return False\n        for n in [c, c.north, c.east, c.south, c.west]:\n            if (n.ship not in good) and (n.ship.halite <= halite):\n                return False\n        return True\n\n    def next_action(s, action):\n        s.next_action = action\n        if action in DIRECTIONS:\n            next_cells.add(s.cell.neighbor(action.to_point()))\n        elif action is None:\n            next_cells.add(s.cell)\n\n    yields = [int(c.halite) for c in board.cells.values() if c.halite > 0]\n    min_halite = max(4, sum(yields) \/\/ max(1, len(yields)) \/\/ 2)\n    max_shipyards = 10\n    \n    for ship in player.ships:\n        cell = ship.cell\n        ship.next_action = None\n        \n        if len(player.shipyards) == 0 and safe(cell, ship.halite):\n            next_action(ship, ShipAction.CONVERT)\n            continue\n            \n        if (obs.step == config.episodeSteps - 2 and \n            ship.halite >= config.convertCost):\n            next_action(ship, ShipAction.CONVERT)\n            continue\n            \n        if (obs.step > config.episodeSteps - 20 and \n            len(player.shipyards) > 0 and ship.halite > 0):\n            i = sum(int(k) for k in ship.id.split(\"-\")) % len(player.shipyards)\n            dx, dy = player.shipyards[i].position - ship.position\n            if dx > 0 and safe(cell.east, ship.halite):\n                next_action(ship, ShipAction.EAST)\n            elif dx < 0 and safe(cell.west, ship.halite):\n                next_action(ship, ShipAction.WEST)\n            elif dy > 0 and safe(cell.north, ship.halite):\n                next_action(ship, ShipAction.NORTH)\n            elif dy < 0 and safe(cell.south, ship.halite):\n                next_action(ship, ShipAction.SOUTH)\n            if ship.next_action in DIRECTIONS:\n                continue\n        \n        for d in DIRECTIONS:\n            neighbor = cell.neighbor(d.to_point())\n            if (neighbor.ship is not None and \n                neighbor.ship not in player.ships and\n                safe(neighbor, ship.halite)):\n                next_action(ship, d)\n                break\n        if ship.next_action in DIRECTIONS:\n            continue\n                \n        if cell.halite > min_halite and safe(cell, ship.halite):\n            next_action(ship, None)\n            continue\n            \n        if (ship.halite > config.convertCost * 4 and \n            len(player.shipyards) < max_shipyards and safe(cell, ship.halite)):\n            next_action(ship, ShipAction.CONVERT)\n            continue\n                \n        neighbors = [cell.neighbor(d.to_point()) for d in DIRECTIONS]\n        max_halite = max([0] + [n.halite for n in neighbors if safe(n, ship.halite)])\n        i = sum(int(k) for k in ship.id.split(\"-\")) * config.size\n        j = ((i + obs.step) \/\/ config.size) % 4\n        safe_list = []\n        for _ in range(4):\n            d = DIRECTIONS[j]\n            n = cell.neighbor(d.to_point())\n            if safe(n, ship.halite):\n                if ((n.halite > min_halite and n.halite == max_halite) or \n                    (ship.halite > 20 and n.shipyard in player.shipyards)):\n                    next_action(ship, d)\n                    break\n                safe_list.append(d)\n            j = (j + 1) % 4\n        else:\n            if safe_list:\n                next_action(ship, safe_list[0])\n            elif safe(cell, ship.halite):\n                next_action(ship, None)\n            elif ship.halite >= config.convertCost:\n                next_action(ship, ShipAction.CONVERT)\n            else:\n                next_action(ship, None)\n                \n    max_ships = min(50, len(player.ships) +\n                    player.halite \/\/ config.spawnCost \/\/ \n                    max(1, len(player.shipyards)))\n    \n    for shipyard in player.shipyards:\n        if len(player.ships) == 0:\n            shipyard.next_action = ShipyardAction.SPAWN\n            \n        elif (len(player.ships) < max_ships and\n              obs.step < config.episodeSteps - 50 and\n              safe(shipyard.cell, ship.halite)):\n            shipyard.next_action = ShipyardAction.SPAWN\n            \n    return player.next_actions","ea4b250e":"%%writefile duo_bot.py\nfrom kaggle_environments.envs.halite.helpers import *\n\nDIRECTIONS = [ShipAction.NORTH, ShipAction.EAST, \n              ShipAction.SOUTH, ShipAction.WEST]\n\ndef agent(obs, config):\n    board = Board(obs, config)\n    player = board.current_player\n    next_cells = set()\n\n    def safe(c, halite):\n        if c in next_cells:\n            return False\n        good = player.ships + player.shipyards + [None]\n        if c.shipyard not in good:\n            return False\n        for n in [c, c.north, c.east, c.south, c.west]:\n            if (n.ship not in good) and (n.ship.halite <= halite):\n                return False\n        return True\n\n    def next_action(s, action):\n        s.next_action = action\n        if action in DIRECTIONS:\n            next_cells.add(s.cell.neighbor(action.to_point()))\n        elif action is None:\n            next_cells.add(s.cell)\n\n    yields = [int(c.halite) for c in board.cells.values() if c.halite > 0]\n    avg_halite = sum(yields) \/\/ max(1, len(yields))\n    min_halite = max(4, avg_halite \/\/ 2)\n    max_halite = 4 * min_halite\n    \n    for ship in player.ships:\n        cell = ship.cell\n        ship.next_action = None\n        \n        if len(player.shipyards) == 0 and safe(cell, ship.halite):\n            next_action(ship, ShipAction.CONVERT)\n            continue\n            \n        if (obs.step == config.episodeSteps - 2 and \n            ship.halite >= config.convertCost):\n            next_action(ship, ShipAction.CONVERT)\n            continue\n            \n        if (ship.id == player.ships[0].id and \n            ship.halite > max_halite and \n            len(player.shipyards) > 0):\n            i = sum(int(k) for k in ship.id.split(\"-\")) % len(player.shipyards)\n            dx, dy = player.shipyards[i].position - ship.position\n            if dx > 0 and safe(cell.east, ship.halite):\n                next_action(ship, ShipAction.EAST)\n            elif dx < 0 and safe(cell.west, ship.halite):\n                next_action(ship, ShipAction.WEST)\n            elif dy > 0 and safe(cell.north, ship.halite):\n                next_action(ship, ShipAction.NORTH)\n            elif dy < 0 and safe(cell.south, ship.halite):\n                next_action(ship, ShipAction.SOUTH)\n            if ship.next_action in DIRECTIONS:\n                continue\n                \n        if cell.halite > min_halite and safe(cell, ship.halite):\n            next_action(ship, None)\n            continue\n                            \n        neighbors = [cell.neighbor(d.to_point()) for d in DIRECTIONS]\n        max_halite = max([0] + [n.halite for n in neighbors if safe(n, ship.halite)])\n        i = sum(int(k) for k in ship.id.split(\"-\")) * config.size\n        j = ((i + obs.step) \/\/ config.size) % 4\n        safe_list = []\n        for _ in range(4):\n            d = DIRECTIONS[j]\n            n = cell.neighbor(d.to_point())\n            if safe(n, ship.halite):\n                if n.halite > min_halite and n.halite == max_halite:\n                    next_action(ship, d)\n                    break\n                safe_list.append(d)\n            j = (j + 1) % 4\n        else:\n            if safe_list:\n                next_action(ship, safe_list[0])\n            elif safe(cell, ship.halite):\n                next_action(ship, None)\n            elif ship.halite >= config.convertCost:\n                next_action(ship, ShipAction.CONVERT)\n            else:\n                next_action(ship, None)\n    \n    for shipyard in player.shipyards:\n        if len(player.ships) < 2:\n            shipyard.next_action = ShipyardAction.SPAWN\n            \n    return player.next_actions","3a9d7035":"%%writefile beetle_bot.py\nfrom kaggle_environments.envs.halite.helpers import *\n\ndef agent(obs, config):    \n    board = Board(obs, config)\n    player = board.current_player\n    \n    for ship in player.ships:\n        if len(player.shipyards) == 0:\n            ship.next_action = ShipAction.CONVERT\n        \n    for shipyard in player.shipyards:\n        if len(player.ships) == 0:\n            shipyard.next_action = ShipyardAction.SPAWN\n            \n    return player.next_actions","2e49a086":"%%writefile idle_bot.py\ndef agent(obs, config):            \n    return {}","2bef7633":"import random\nfrom kaggle_environments import make\n\ndef run_test():\n    agent_zoo = [\"random\", \"idle_bot.py\", \"beetle_bot.py\", \"duo_bot.py\", \"attack_bot.py\"]\n    agents = random.sample(agent_zoo, 3)\n    agents.insert(random.randint(0,3), \"submission.py\")\n    print(\"Agents:\", agents)\n    \n    environment = make(\"halite\", configuration={\"episodeSteps\": 200}, debug=True)\n    environment.run(agents)\n    environment.render(mode=\"ipython\", width=640, height=480)","839db56a":"%%time\nrun_test()","1d40b6f9":"%%time\nrun_test()","c3f3b4d8":"%%time\nrun_test()","3d43eeaf":"%%time\nrun_test()","302db6fb":"%%time\nrun_test()","c3fe761a":"## Swarm Controller Class\n### Class Overview\n\n```\nController: {\n    __init__(obs: Dict[str, Any], config: Dict[str, Any]) -> None\n    \n    clear(cell: Cell) -> bool\n    hostile_ship_near(cell: Cell, halite: int) -> bool\n\n    spawn(shipyard: Shipyard) -> None\n    convert(ship: Ship) -> None\n    move(ship: Ship, direction: ShipAction) -> None\n\n    endgame(ship: Ship) -> bool\n    build_shipyard(ship: Ship) -> bool\n    stay_on_cell(ship: Ship) -> bool\n    go_for_halite(ship: Ship) -> bool\n    unload_halite(ship: Ship) -> bool\n    standard_patrol(ship: Ship) -> bool\n    safety_convert(ship: Ship) -> bool\n    crash_shipyard(ship: Ship) -> bool\n\n    actions_of_ships() -> None\n    actions_of_shipyards() -> None\n    \n    next_actions() -> Dict[str, str]\n}\n```","e669eb4f":"---\n<a id=\"top\"><\/a>\n# Contents\n\nThis notebook is a <a href=\"https:\/\/www.kaggle.com\/sam\/halite-sdk-overview\">Halite SDK<\/a> version of the totally cool notebook, <a href=\"https:\/\/www.kaggle.com\/yegorbiryukov\/halite-swarm-intelligence\">Halite Swarm Intelligence<\/a>.\n\n---\n\n<ol>\n    <li><a href=\"#kaggle-environments\")>Install kaggle-environments<\/a><\/li>\n    <li><a href=\"#swarm-agent\")>Swarm Agent<\/a><\/li>\n    <li><a href=\"#attack-bot\")>Attack Bot<\/a><\/li>\n    <li><a href=\"#duo-bot\")>Duo Bot<\/a><\/li>\n    <li><a href=\"#beetle-bot\")>Beetle Bot<\/a><\/li>\n    <li><a href=\"#idle-bot\")>Idle Bot<\/a><\/li>\n    <li><a href=\"#test-run\")>Test Run<\/a><\/li>\n<\/ol>\n\n---","6eb7b141":"### Class Implementation","3141d9cd":"<a href=\"#top\">&uarr; back to top<\/a>","a649a422":"<a href=\"#top\">&uarr; back to top<\/a>","6fdb4f99":"## Main Agent Function","aacd4d68":"<a id=\"attack-bot\"><\/a>\n# Attack Bot\n\nThis bot tries to attack the swarm.","2ce0a76d":"<a href=\"#top\">&uarr; back to top<\/a>","a63e757e":"<a id=\"idle-bot\"><\/a>\n# Idle Bot\n\nThis bot does nothing.\n","0ec38c8d":"<a id=\"swarm-agent\"><\/a>\n# Swarm Agent\n## Imports and Constants","932b6b00":"<a id=\"kaggle-environments\"><\/a>\n# Install kaggle-environments","4087423a":"<a id=\"test-run\"><\/a>\n# Test Run","1971311b":"<a id=\"duo-bot\"><\/a>\n# Duo Bot\n\nThis bot maintains a fleet of two ships.\n","afab8e20":"<a href=\"#top\">&uarr; back to top<\/a>","2b418503":"<a href=\"#top\">&uarr; back to top<\/a>","3c182ab1":"<a href=\"#top\">&uarr; back to top<\/a>","1117b750":"<a href=\"#top\">&uarr; back to top<\/a>","0213da0c":"---\n\n# <center> Swarm Intelligence with SDK <\/center>\n\n---\n\n<center><img src=\"https:\/\/images.unsplash.com\/photo-1516434233442-0c69c369b66d?auto=format&fit=min&crop=top&w=800&h=400\"><\/center>\n\n---","fc1f7bb6":"<a id=\"beetle-bot\"><\/a>\n# Beetle Bot\n\nThis is a bot with one ship and one shipyard which is described in the notebook: <a href=\"https:\/\/www.kaggle.com\/benzyx\/make-sure-you-can-beat-this-baseline-idle-bot\">Make sure you can beat this: Baseline Idle Bot<\/a>.\n"}}