{"cell_type":{"b08832d1":"code","b30a2515":"code","78807c6f":"code","d43cae01":"code","66b28f93":"code","d77e499b":"code","5a710f02":"code","fb42bffc":"code","dea8ff50":"code","537adec3":"code","52b0ca29":"code","0311a13d":"code","5ac9bb88":"code","449f4e2b":"code","fc5d38ac":"code","24a790ce":"markdown","b2c8c454":"markdown","67d20769":"markdown","0231eaf1":"markdown","50749697":"markdown","9f9edd7b":"markdown","68d537e9":"markdown","2e5adff2":"markdown","06c547bf":"markdown","000e0bfe":"markdown","eafa496b":"markdown","fed27d05":"markdown","15373c58":"markdown"},"source":{"b08832d1":"import time\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport jax\nimport jax.numpy as jnp\nfrom jax import random\nfrom jax import make_jaxpr\nfrom jax import vmap, pmap, jit\nfrom jax import grad, value_and_grad\nfrom jax.test_util import check_grads\n\n\n%config IPCompleter.use_jedi = False","b30a2515":"# A list as a pytree\nexample_1 = [1, 2, 3]\n\n# As in normal Python code, a list that represents pytree\n# can contain obejcts of any type\nexample_2 = [1, 2, \"a\", \"b\", (3, 4)]\n\n# Similarly we can define pytree using a tuple as well\nexample_3 = (1, 2, \"a\", \"b\", (3, 4))\n\n# We can define the same pytree using a dict as well\nexample_4 = {\"k1\": 1, \"k2\": 2, \"k3\": \"a\", \"k4\": \"b\", \"k5\": (3, 4)}\n\n# Let's check the number of leaves and the corresponding values in the above pytrees\nexample_pytrees = [example_1, example_2, example_3, example_4]\nfor pytree in example_pytrees:\n    leaves = jax.tree_leaves(pytree)\n    print(f\"Pytree: {repr(pytree):<30}\")\n    print(f\"Number of leaves: {len(leaves)}\")\n    print(f\"Leaves are: {leaves}\\n\")\n    print(\"=\"*50)","78807c6f":"# Check if we can make a pytree from a DeviceArray\nexample_5 = jnp.array([1, 2, 3])\nleaves = jax.tree_leaves(example_5)\nprint(f\"DeviceArray: {repr(example_5):<30}\")\nprint(f\"Number of leaves: {len(leaves)}\")\nprint(f\"Leaves are: {leaves}\")","d43cae01":"# We will use the `example_2` pytree for this purpose.\n# Our pytree looks like this: [1, 2, 'a', 'b', (3, 4)]\n# We will unflatten it, obtain the leaves, and the tree structure as well\n\nexample_2_leaves, example_2_treedef = jax.tree_flatten(example_2)\nprint(f\"Original Pytree: {repr(example_2)}\")\nprint(f\"Leaves: {repr(example_2_leaves)}\")\nprint(f\"Pytree structure: {repr(example_2_treedef)}\")","66b28f93":"def change_even_positioned_leaf(x, pos):\n    if pos % 2 == 0:\n        return x * 2\n    else:\n        return x\n    \ntransformed_leaves = [\n    change_even_positioned_leaf(leaf, pos+1) for pos, leaf in enumerate(example_2_leaves)\n]\n\nprint(f\"Original leaves:    {repr(example_2_leaves)}\")\nprint(f\"Transformed leaves: {repr(transformed_leaves)}\")","d77e499b":"# Reconstruct the tree\nexample_2_modified = jax.tree_unflatten(treedef=example_2_treedef, leaves=transformed_leaves)\nprint(f\"Original Pytree:    {repr(example_2)}\")\nprint(f\"Transformed Pytree: {repr(example_2_modified)}\")","5a710f02":"from jax.tree_util import register_pytree_node\nfrom jax.tree_util import register_pytree_node_class","fb42bffc":"class Counter:\n    def __init__(self, count, name):\n        self.count = count\n        self.name = name\n        \n    def __repr__(self):\n        return f\"Counter value = {self.count}\"\n    \n    def increment(self):\n        return self.count + 1\n    \n    def decrement(self):\n        return self.count - 1\n    \n\n# Because JAX doesn't know how to flattent and unflatten these custom objects\n# hence we need to define those methods for these objects\n\ndef flatten_counter(tree):\n    \"\"\"Specifies how to flatten a Counter class object.\n    \n    Args:\n        tree: Counter class object represented as Pytree node\n    Returns:\n        A pair of an iterable with the children to be flattened recursively,\n        and some opaque auxiliary data to pass back to the unflattening recipe.\n        The auxiliary data is stored in the treedef for use during unflattening.\n        The auxiliary data could be used, e.g., for dictionary keys.\n    \"\"\"\n    \n    children = (tree.count,)\n    aux_data = tree.name # We don't want to treat the name as a child\n    return (children, aux_data)\n\n\ndef unflatten_counter(aux_data, children):\n    \"\"\"Specifies how to unflattening a Counter class object.\n\n    Args:\n        aux_data: the opaque data that was specified during flattening of the\n            current treedef.\n        children: the unflattened children\n    Returns:\n        A re-constructed object of the registered type, using the specified\n        children and auxiliary data.\n    \"\"\"\n    return Counter(*children, aux_data)\n\n\n# Now all we need to do is to tell JAX that we need to Register our class as\n# a Pytree node and it need to treat all the objects of that class as such\nregister_pytree_node(\n    Counter,\n    flatten_counter,    # tell JAX what are the children nodes\n    unflatten_counter   # tell JAX how to pack back into a `Counter`\n)","dea8ff50":"# An instance of the Counter class\nmy_counter = Counter(count=5, name=\"Counter_class_as_pytree_node\")\n\n# Flatten the custom object\nmy_counter_leaves, my_counter_treedef = jax.tree_flatten(my_counter)\n\n# Unflatten\nmy_counter_reconstructed = jax.tree_unflatten(\n    treedef=my_counter_treedef, leaves=my_counter_leaves\n)\nprint(f\"Original Pytree: {repr(my_counter)}\")\nprint(f\"Leaves: {repr(my_counter_leaves)}\")\nprint(f\"Pytree structure: {repr(my_counter_treedef)}\")\nprint(f\"Reconstructed Pytree: {repr(my_counter_reconstructed)}\")","537adec3":"# Another instance\nmy_counter_2 = Counter(count=5, name=\"Counter_class_as_pytree_node\")\n\n# Flatten the custom object\nmy_counter_2_leaves, my_counter_2_treedef = jax.tree_flatten(my_counter)\n\n# Check if the treedef are same for both the pytrees\nmy_counter_treedef == my_counter_2_treedef","52b0ca29":"def activate(x):\n    \"\"\"Applies tanh activation.\"\"\"\n    return jnp.tanh(x[\"weights\"])\n\n\n# Always use the PRNG\nkey = random.PRNGKey(1234)\nexample_pytree = {\"weights\": random.normal(key=key, shape=(5,))}\n\n# We will now use vmap and grad to compute the gradients per sample\ngrads_example_pytree = vmap(grad(activate), in_axes=({\"weights\":0},))(example_pytree)\n\nprint(\"Original pytree:\")\nprint(f\" {repr(example_pytree)}\\n\")\nprint(\"Leaves in the pytree:\")\nprint(f\"{repr(jax.tree_leaves(example_pytree))}\\n\")\nprint(\"Gradients per example:\")\nprint(f\"{grads_example_pytree}\\n\")","0311a13d":"make_jaxpr(vmap(grad(activate), in_axes=({\"weights\":0},)))(example_pytree)","5ac9bb88":"key = random.PRNGKey(111)\nkey, subkey = random.split(key)\n\n# Generate some random data\nx = random.normal(key=key, shape=(128, 1))\n# Let's just do y = 10x + 20\ny = 10 * x + 20\n\nplt.plot(x, y, marker='x', label='Generated linear function')\nplt.legend()\nplt.show()","449f4e2b":"def initialize_params(key, dims):\n    \"\"\"Initialize the weights and biases of the MLP.\n    \n    Args:\n        key: PRNG key\n        dims: List of integers\n    Returns:\n        A pytree of initialized paramters for each layer\n    \"\"\"\n    \n    params = []\n    \n    for dim_in, dim_out in zip(dims[:-1], dims[1:]):\n        key, subkey = random.split(key)\n        weights = random.normal(key=key, shape=(dim_in, dim_out)) * jnp.sqrt(2 \/ dim_in)\n        biases = jnp.zeros(shape=(dim_out))\n        params.append({\"weights\": weights, \"biases\":biases})\n    \n    return params\n\n\n# Initialize the parameters\nparams = initialize_params(key=subkey, dims=[1, 128, 128, 1])\n\n# We can inspect the shape of the intialized params as well\nshapes = jax.tree_map(lambda layer_params: layer_params.shape, params)\n\nfor i, shape in enumerate(shapes):\n    print(f\"Layer {i+1} => Params shape: {shape}\")","fc5d38ac":"def forward(params, x):\n    \"\"\"Forward pass for the MLP\n    \n    Args:\n        params: A pytree containing the parameters of the network\n        x: Inputs\n    \"\"\"\n    *hidden, last = params\n    for layer in hidden:\n        x = jax.nn.relu(x @ layer['weights'] + layer['biases'])\n    return x @ last['weights'] + last['biases']\n\n\ndef loss_fn(params, x, y):\n    \"\"\"Mean squared error loss function.\"\"\"\n    return jnp.mean((forward(params, x) - y) ** 2)\n\n\n\n@jax.jit\ndef update(params, x, y):\n    \"\"\"Updates the parameters of the network.\n    \n    Args:\n        params: A pytree containing the parameters of the network\n        x : Inputs\n        y:  Outputs\n    Returns:\n        Pytree with updated values\n    \"\"\"\n    \n    # 1. Calculate the gradients based on the loss\n    grads = jax.grad(loss_fn)(params, x, y)\n    \n    # 2. Update the parameters using `tree_multi_map(...)`\n    return jax.tree_multimap(lambda p, g: p - 0.0001 * g, params, grads)\n\n\n\n\n# Run the model for a few iterations\nfor _ in range(2000):\n    params = update(params, x, y)\n    \n    \n# Plot the predictions and the ground truth\nplt.plot(x, y, marker='x', label='Generated linear function')\nplt.plot(x, forward(params, x), marker=\"x\", label=\"Predictions\")\nplt.legend()\nplt.show()","24a790ce":"# Why pytrees?\n\nTill now we discussed Pytrees but one question that we didn't answer yet is why should you learn about pytrees and what are the common use cases for using pytrees. Although there are many use-cases for pytrees, the most common use-case is to specify the model parameters. For example, if you want to build a DNN, you can store the weights and biases corresponding to each layer as pytrees. You can even define your whole module representing the functionality of your DNN as a pytree.\nLet's see an example in action for the same. This one is taken from the JAX docs only.","b2c8c454":"As you can see, the ndarray is considered as one leaf only. The same goes for numeric values.\n\nAnother important thing to note is that pytrees are tree-like data structures rather than DAG-like or graph-like. They assume referential transparency, and that there are no reference cycles present. So, don't use the same object in multiple leaves of a pytree\n\nWe can *flatten* the tree at each level, get the leaves, and the original tree structure as well. Let's see it in action","67d20769":"A few things to note:\n1. We can combine any JAX transformation and apply it to the pytrees.\n2. Some transformations like `vmap` and `pmap` take in optional parameters like `in_axes` and `out_axes` that specify how certain input or output values should be treated. These parameters can also be pytrees, and their structure must correspond to the pytree structure of the corresponding arguments. For example, check how we passed the value for `in_axes` in the above example","0231eaf1":"# Pytrees and JAX transformations\n\nTill now we discussed what pytrees are and how can you create one, including using a custom container-like object. Before we jump onto using pytrees for some high-level examples, let's take a step back and understand how JAX function transformations like `grad`, `vmap`, etc can be applied to pytrees.","50749697":"We can now use the original tree structure to rebuild the tree with the transformed leaves","9f9edd7b":"# Pytrees\n\nWhat is a Pytree? If we go by the definition of Pytress as provided in the [docs](https:\/\/jax.readthedocs.io\/en\/latest\/pytrees.html), then a *pytree* refers to a tree-like structure built out of container-like Python objects.\n\nWhat are the container-like Python objects? Given the name, you might have already guessed that the container-like Python objects include **list**, **tuples**, **dictionaries**, **namedtuple**, **OrderedDict**, and **None** (this isn't so obvious). These data structures are the default container-like objects treated as Pytrees. We can also tell JAX to treat a class as a container-like object but we need to include them in pytree registry first (We will discuss this in detail later on in this tutorial).\n\nLet's take a look at a few examples of Pytrees.","68d537e9":"Easy, right? Well, that's JAX is all about, making things easy!\n\n**Note:** When defining a function to flatten the custom objects, please recheck the order of arguments passed to that function. The first positional parameter always represents the *auxiliary* data while the second argument always represents the *children*. Please check the `flatten_counter(...)` above as an example.\n\nOne thing that we haven't checked yet is that if our pytree can do the equality check. Let's check it.","2e5adff2":"<img src=\"https:\/\/raw.githubusercontent.com\/google\/jax\/main\/images\/jax_logo_250px.png\" width=\"300\" height=\"300\" align=\"center\"\/><br>\n\nWelcome to another JAX tutorial. I hope you all have been enjoying the JAX Tutorials so far. If you haven't gone through the previous tutorials, I highly suggest going through them. Here are the links:\n\n1. [TF_JAX_Tutorials - Part 1](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part1)\n2. [TF_JAX_Tutorials - Part 2](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part2)\n3. [TF_JAX_Tutorials - Part 3](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part3)\n4. [TF_JAX_Tutorials - Part 4 (JAX and DeviceArray)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-4-jax-and-devicearray)\n5. [TF_JAX_Tutorials - Part 5 (Pure Functions in JAX)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-5-pure-functions-in-jax\/)\n6. [TF_JAX_Tutorials - Part 6 (PRNG in JAX)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-6-prng-in-jax\/)\n7. [TF_JAX_Tutorials - Part 7 (JIT in JAX)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-7-jit-in-jax)\n8. [TF_JAX_Tutorials - Part 8 (Vmap and Pmap)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-8-vmap-pmap)\n9. [TF_JAX_Tutorials - Part 9 (Autodiff in JAX)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-9-autodiff-in-jax)\n\n\nWe are going to cover an important concept that is very specific to JAX, and not to other libraries. Also, this notebook is the last notbook that will be wrap up the fundamentals or the building blocks of JAX. If you have gone through all the other tutorials already, I am hoping that you know have a very solid understanding of how JAX works under the hood. Understanding the fundamnetals is the key to learn anything in a solid way. Without any further due, let's start!","06c547bf":"So, in short, a pytree is just a composition of **nodes**(container-like Python objects) and **leaves**(all other Python objects). JAX also lets you register custom types as pytrees (we will take a few examples of this later on)\n\nOne question that you should be asking at this point is whether a **DeviceArray**, the core data structure in JAX, can be used as a pytree or not. Well, the answer is no. Any *ndarray* is treated as a leaf in a pytree\/ Let's take an example to make it clear.","000e0bfe":"That's it for now. We have now completed all the basic things you need to know about JAX. I believe if you grasp the understanding of the concepts that we have covered yet, it will be more than sufficient. In future tutorials, we will build NNs using JAX.\n\n# References\n\n1. https:\/\/jax.readthedocs.io\/en\/latest\/pytrees.html\n2. https:\/\/jax.readthedocs.io\/en\/latest\/jax-101\/05.1-pytrees.html\n3. https:\/\/arxiv.org\/pdf\/2111.00254v1.pdf\n4. https:\/\/github.com\/patrick-kidger\/equinox\n5. https:\/\/github.com\/poets-ai\/elegy","eafa496b":"Now that we have extracted the leaves, we can modify these and reconstruct the tree again using the original tree structure (treedef). \n\n**Note:** We can(should) use `tree_map(...)` and `tree_multimap(...)` for doing operations on leaves as it is a much better way to achieve it. The above example is to showcase that you can do it in a way where you want more control over the operations applied to different leaves of the tree","fed27d05":"# Jaxprs and Pytrees\n\nAs with any other JAX code, you can use jaxprs with pytrees as well. For example, let's check the jaxpr of the above example","15373c58":"We saw that Pytree are container-like Python objects like lists, tuples, dicts, etc. But what if you want to extend this set of Python objects treated as pytree nodes? For example, what if you want to treat your class as a Pytree node? \n\nWell, if you think about it, to treat a class as a pytree node, we need to:\n1. Tell JAX that you want to treat it as a node and not a leaf by registering it in the internal registry.\n2. Because this is a custom object, JAX doesn't know how to `flatten` and `unflatten` it, we need to tell JAX this as well\n3. There are cases when we need to compare two `treedef` structures for equality. Hence we need to make sure that adding a custom object doesn't break the equality check.\n\nLet's look at an example."}}