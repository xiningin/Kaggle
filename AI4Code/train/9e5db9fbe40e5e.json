{"cell_type":{"2dc86773":"code","d4e8260e":"code","ee39d807":"code","6cf9a37c":"code","e22ca4fe":"code","21bd64a7":"code","abfc5790":"markdown","030d4fca":"markdown","754e2cbd":"markdown","973a5fb5":"markdown","0f6a740c":"markdown","297da6dd":"markdown","fb5af700":"markdown","10087f5c":"markdown"},"source":{"2dc86773":"import matplotlib.pyplot as plt\nimport numpy as np\n\ndemand_level = 150\n# only plot quantities up to demand_level. That's point where price becomes 0\nrevenue = [(demand_level - q) * q for q in range(demand_level)]\n\n# Make primary plot\nplt.plot(revenue, label=\"Revenue\")\nplt.xlabel(\"Seats Sold\")\nplt.ylabel(\"Dollars\")\nplt.ylim(ymin=0)\nplt.xlim(xmin=0)\n\n# Show the revenue maximizing quantity\noptimal_q = np.argmax(revenue)\nplt.vlines(x = optimal_q, \n           ymin=0, ymax = max(revenue), color = 'red', linestyle = \"--\", \n           label=\"Optimal Quantity\")\n\nplt.legend(loc = 'lower right')\nplt.show()","d4e8260e":"n_demand_levels = 11\nmin_demand_level = 100\nmax_demand_level = 150\ndemand_levels = np.linspace(min_demand_level, max_demand_level, n_demand_levels)\n\nmax_tickets = 150\nmax_days = 100\n\n# Q indices are: n_sold in day, tickets_left to start day, demand_level, days_left\nQ = np.zeros([max_tickets, max_tickets, n_demand_levels, max_days])\n# V indices are: n_left and n_days\nV = np.zeros([max_tickets, max_days])\n","ee39d807":"for tickets_left in range(max_tickets):\n    for tickets_sold in range(tickets_left+1): # add 1 to offset 0 indexing. Allow selling all tickets\n        for demand_index, demand_level in enumerate(demand_levels):\n            # Never set negative prices\n            price = max(demand_level - tickets_sold, 0)\n            Q[tickets_sold, tickets_left, demand_index, 0] = price * tickets_sold\n    # For each demand_level, choose the optimum number to sell. Output of this is array .of size n_demand_levels\n    revenue_from_best_quantity_at_each_demand_level = Q[:, tickets_left, :, 0].max(axis=0)\n    # take the average, since we don't know demand level ahead of time and all are equally likely\n    V[tickets_left, 0] = revenue_from_best_quantity_at_each_demand_level.mean()","6cf9a37c":"for days_left in range(1, max_days):\n    for tickets_left in range(max_tickets):\n        for tickets_sold in range(tickets_left):\n            for demand_index, demand_level in enumerate(demand_levels):\n                price = max(demand_level - tickets_sold, 0)\n                rev_today = price * tickets_sold\n                Q[tickets_sold, tickets_left, demand_index, days_left] = rev_today + V[tickets_left-tickets_sold, days_left-1]\n        expected_total_rev_from_best_quantity_at_each_demand_level = Q[:, tickets_left, :, days_left].max(axis=0)\n        V[tickets_left, days_left] = expected_total_rev_from_best_quantity_at_each_demand_level.mean()","e22ca4fe":"def pricing_function(days_left, tickets_left, demand_level):\n    demand_level_index = np.abs(demand_level - demand_levels).argmin()\n    day_index = days_left - 1 # arrays are 0 indexed\n    tickets_index = int(tickets_left)  # in case it comes in as float, but need to index with it\n    relevant_Q_vals = Q[:, tickets_index, demand_level_index, day_index]\n    desired_quantity = relevant_Q_vals.argmax()# offset 0 indexing\n    price = demand_level - desired_quantity\n    return price","21bd64a7":"import sys\nsys.path.append(\"..\/input\")\nfrom flight_revenue_simulator import simulate_revenue, score_me\n\nscore_me(pricing_function)","abfc5790":"\nFor any given number of tickets, days_left and demand_level, look in **Q** to find the number of tickets with the highest Q-value.\n\nUse pricing function to implement that:","030d4fca":"# 7) Score","754e2cbd":"# 4) Q & V functions \n\n- Values of Q & V can be stored in numpy arrays \n> indexed by inputs \n\n- Q input = demand (variable affecting decision)\n\n- Demand is unknown in future days, even if V is used to examine potential revenue on those days \n> Develop 'expected value' by averaging over future revenue from a specified demand range \n\n- Discretize demand range \n> evenly spread values ","973a5fb5":"# 6) Solving for other time horizons \n\n- Iteratively calc Q & V for previous periods ","0f6a740c":"# 3) Base case (1-day sale) \n\n#### *Given that *\n- Qty = demand - price \n\n#### *find price and quantity that maximizes *\n- Revenue = price * Qty\n\n#### *Re-arrange Qty equation to solve for price (single choice variable)*\n- Price = demand - Qty \n\n#### *Plug price into revenue equation*\n- Revenue = (demand - Qty) * Qty\n\n### 3.1) Demand & Revenue \n\n- Demand = given number when making daily price decisions \n- Plot revenue as equation dependent on Qty","297da6dd":"# 5) Base case: 1 day remaining \n\n- last day remaining, no concern for future values ","fb5af700":"# 1) Overview \n\n- Optimization technique = dynamic programming \n> solve a problem with a limited scenario, iterative rule to expand to larger problems \n\n- Solve for optimal price, given that only 1 day is available to sell tickets BEFORE flights\n> apply to longer time-horizons 1 day at a time \n\n- Value function = best outcome achievable from any singular input state \n> v(tickets remaining, days remaining) = best revenue expected for a given number of tickets and days \n\n- Q function = includes decision input and expected revenue if it is not based on optimal decision policy\n> Q function output for T+1 days = dependent on sum of revenue from flights sold that day, revenue earned in the previous days. ","10087f5c":"# 2) Strategy \n\n- Start near flight time \n- Iteratively work backwards \n- Check revenue from previous days from value function \n- Single choice variable in this dynamic programming problem is price or quantity\n\n### 2.1) Q & V\n\n- After obtaining Q at T + 1\n- Compute V on the same day by checking revenue associated with best decision from Q function \n- Q includes current revenue calculation & V(leftover tickets)"}}