{"cell_type":{"cdc927d4":"code","b3a3fe61":"code","4c7c60a9":"code","b25da226":"code","9c6c7f33":"code","22a73035":"code","dc187fa8":"code","018b7a90":"code","48700411":"code","696e8389":"code","832d25f8":"code","a0fa7991":"code","62c885db":"code","5db8c60f":"code","a2cec57e":"code","963d4a95":"code","87f0525b":"code","ff9babe3":"code","595616f3":"code","101e067b":"code","6108abf6":"code","9ea0ec5b":"code","6745a8d1":"code","49f544ef":"code","34b0e1dc":"code","5c18b516":"code","29cbe768":"code","91a0093c":"code","4bf714a9":"code","de8c3eeb":"markdown","16c88af5":"markdown","36d41698":"markdown","aca55703":"markdown","11a4a180":"markdown","e7090353":"markdown","2d253304":"markdown","851547ba":"markdown","b3033fb7":"markdown","59b09e61":"markdown","c009606b":"markdown","8c4115a2":"markdown","9a5bab87":"markdown","9cdb1ccf":"markdown","83b8dbb7":"markdown","8e588118":"markdown"},"source":{"cdc927d4":"from __future__ import print_function, division\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.optim import lr_scheduler\nfrom torch.autograd import Variable\nimport numpy as np\nimport torchvision\nfrom torchvision import datasets,models,transforms\nimport matplotlib.pyplot as plt\nimport time\nimport os\nimport copy\nimport cv2\nimport numpy as np\nfrom skimage.morphology import (erosion, dilation, opening, closing, white_tophat,disk)\n\nplt.ion()  \n\nuse_gpu = torch.cuda.is_available()\nif use_gpu:\n    print(\"Using CUDA\")","b3a3fe61":"class ImageFolderWithPaths(datasets.ImageFolder):\n    \"\"\"Custom dataset that includes image file paths. Extends\n    torchvision.datasets.ImageFolder\n    \"\"\"\n\n    # override the __getitem__ method. this is the method that dataloader calls\n    def __getitem__(self, index):\n        # this is what ImageFolder normally returns \n        original_tuple = super(ImageFolderWithPaths, self).__getitem__(index)\n        # the image file path\n        path = self.imgs[index][0]\n        # make a new tuple that includes original and the path\n        tuple_with_path = (original_tuple + (path,))\n        return tuple_with_path","4c7c60a9":"def opening(img):\n    kernel = np.ones((5, 5), np.uint8)\n    img_erosion = cv2.erode(img, kernel, iterations=1)\n    img_dilation = cv2.dilate(img_erosion, kernel, iterations=1)\n    return img_dilation\ndef denoise(img):\n    #denoise_img = cv2.medianBlur(img,9)\n    denoise_img = cv2.bilateralFilter(img, 15, 75, 75)\n    return denoise_img","b25da226":"def apply_brightness_contrast(input_img, brightness = 0, contrast = 0):\n    if brightness != 0:\n        if brightness > 0:\n            shadow = brightness\n            highlight = 255\n        else:\n            shadow = 0\n            highlight = 255 + brightness\n        alpha_b = (highlight - shadow)\/255\n        gamma_b = shadow\n        \n        buf = cv2.addWeighted(input_img, alpha_b, input_img, 0, gamma_b)\n    else:\n        buf = input_img.copy()\n    \n    if contrast != 0:\n        f = 131*(contrast + 127)\/(127*(131-contrast))\n        alpha_c = f\n        gamma_c = 127*(1-f)\n        \n        buf = cv2.addWeighted(buf, alpha_c, buf, 0, gamma_c)\n\n    return buf","9c6c7f33":"from PIL import Image\nfrom matplotlib import cm\ndef preprocessing(img):\n    return Image.fromarray(np.uint8(apply_brightness_contrast(opening(denoise(np.array(img))),0,16)))\n","22a73035":"data_dir = '..\/input\/data-chamber\/DATA_CHAMBER_2021\/'\nTRAIN = 'train'\nTEST = 'test'\n# VGG-16 Takes 224x224 images as input, so we resize all of them\n\ndata_transforms = {\n    TRAIN: transforms.Compose([\n        transforms.Resize(256),\n        transforms.RandomCrop(224),\n        transforms.RandomHorizontalFlip(),\n        preprocessing,\n        transforms.ToTensor()]),\n    TEST: transforms.Compose([\n        transforms.Resize(224),\n        transforms.CenterCrop(224),\n        preprocessing,\n        transforms.ToTensor(),\n    ])\n}\n\nimage_datasets = {\n    x: ImageFolderWithPaths(\n        os.path.join(data_dir, x), \n        transform=data_transforms[x]\n    )\n    for x in [TRAIN,TEST]\n}\n\ndataloaders = {\n    TRAIN: torch.utils.data.DataLoader(\n        image_datasets[TRAIN], batch_size=32,\n        shuffle=True, num_workers=4\n    ),\n    TEST: torch.utils.data.DataLoader(\n        image_datasets[TEST], batch_size=32,\n        shuffle=False, num_workers=4\n    )\n    \n}\n\ndataset_sizes = {x: len(image_datasets[x]) for x in [TRAIN,  TEST]}\n\nfor x in [TRAIN, TEST]:\n    print(\"Loaded {} images under {}\".format(dataset_sizes[x], x))\n    \nprint(\"Classes: \")\nclass_names = image_datasets[TRAIN].classes\nprint(image_datasets[TRAIN].classes)","dc187fa8":"def imshow(inp, title=None):\n    inp = inp.numpy().transpose((1, 2, 0))\n    # plt.figure(figsize=(10, 10))\n    plt.axis('off')\n    plt.imshow(inp)\n    if title is not None:\n        plt.title(title)\n    plt.pause(0.001)\n\ndef show_databatch(inputs, classes):\n    out = torchvision.utils.make_grid(inputs)\n    imshow(out, title=[class_names[x] for x in classes])\n\n# Get a batch of training data\ninputs, classes,_ = next(iter(dataloaders[TRAIN]))\nshow_databatch(inputs, classes)","018b7a90":"torch.__version__","48700411":"def visualize_model(vgg, num_images=6):\n    was_training = vgg.training\n    \n    # Set model for evaluation\n    vgg.train(False)\n    vgg.eval() \n    \n    images_so_far = 0\n\n    for i, data in enumerate(dataloaders[TEST]):\n        inputs, labels,_ = data\n        size = inputs.size()[0]\n        \n        if use_gpu:\n            inputs, labels = Variable(inputs.cuda(), volatile=True), Variable(labels.cuda(), volatile=True)\n        else:\n            inputs, labels = Variable(inputs, volatile=True), Variable(labels, volatile=True)\n        \n        outputs = vgg(inputs)\n        \n        _, preds = torch.max(outputs.data, 1)\n        predicted_labels = [preds[j] for j in range(inputs.size()[0])]\n        \n        print(\"Ground truth:\")\n        show_databatch(inputs.data.cpu(), labels.data.cpu())\n        print(\"Prediction:\")\n        show_databatch(inputs.data.cpu(), predicted_labels)\n        \n        del inputs, labels, outputs, preds, predicted_labels\n        torch.cuda.empty_cache()\n        \n        images_so_far += size\n        if images_so_far >= num_images:\n            break\n        \n    vgg.train(mode=was_training) # Revert model back to original training state","696e8389":"\ndef eval_model(vgg, criterion):\n    y_true = []\n    y_pred = []\n    vid_id = []\n    since = time.time()\n    avg_loss = 0\n    avg_acc = 0\n    loss_test = 0\n    acc_test = 0\n    \n    test_batches = len(dataloaders[TEST])\n    print(\"Evaluating model\")\n    print('-' * 10)\n    \n    for i, data in enumerate(dataloaders[TEST]):\n        if i % 100 == 0:\n            print(\"\\rTest batch {}\/{}\".format(i, test_batches), end='', flush=True)\n\n        vgg.train(False)\n        vgg.eval()\n        inputs, labels, fname = data\n        for f in fname:\n            vid_id.append(f.split('\/')[-1].split('.')[0].split('_')[0])\n        y_true = y_true + labels.tolist()\n        if use_gpu:\n            inputs, labels = Variable(inputs.cuda(), volatile=True), Variable(labels.cuda(), volatile=True)\n        else:\n            inputs, labels = Variable(inputs, volatile=True), Variable(labels, volatile=True)\n\n        outputs = vgg(inputs)\n\n        _, preds = torch.max(outputs.data, 1)\n        loss = criterion(outputs, labels)\n        #print(preds)\n        y_pred = y_pred + preds.tolist()\n        \n        loss_test += loss.data[0]\n        acc_test += torch.sum(preds == labels.data)\n\n        del inputs, labels, outputs, preds\n        torch.cuda.empty_cache()\n        \n    avg_loss = loss_test \/ dataset_sizes[TEST]\n    avg_acc = acc_test \/ dataset_sizes[TEST]\n    \n    elapsed_time = time.time() - since\n    print()\n    print(\"Evaluation completed in {:.0f}m {:.0f}s\".format(elapsed_time \/\/ 60, elapsed_time % 60))\n    print(\"Avg loss (test): {:.4f}\".format(avg_loss))\n    print(\"Avg acc (test): {:.4f}\".format(avg_acc))\n    print('-' * 10)\n    return y_true,y_pred,vid_id","832d25f8":"vgg16 = models.vgg19_bn()\nvgg16.load_state_dict(torch.load(\"..\/input\/vgg19bn\/vgg19_bn.pth\"))\nprint(vgg16.classifier[6].out_features) # 1000 \n\n\n# Freeze training for all layers\n# for param in vgg16.features.parameters():\n#     param.require_grad = False\n\n# Newly created modules have require_grad=True by default\nnum_features = vgg16.classifier[6].in_features\nfeatures = list(vgg16.classifier.children())[:-1] # Remove last layer\nfeatures.extend([nn.Linear(num_features, len(class_names))]) # Add our layer with 4 outputs\nvgg16.classifier = nn.Sequential(*features) # Replace the model classifier","a0fa7991":"# If you want to train the model for more than 10 epochs, set this to True after the first run\nresume_training = False\n\nif resume_training:\n    print(\"Loading pretrained model..\")\n    vgg16.load_state_dict(torch.load('..\/input\/vgg19bnechocardiogrampretrained\/VGG19_echocardiogram.pt'))\n    print(\"Loaded!\")","62c885db":"if use_gpu:\n    vgg16.cuda() #.cuda() will move everything to the GPU side\n    \ncriterion = nn.CrossEntropyLoss()\n\noptimizer_ft = optim.SGD(vgg16.parameters(), lr=0.01, momentum=0.9)\nexp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=1, gamma=0.1)","5db8c60f":"print(\"Test before training\")\neval_model(vgg16, criterion)\nprint('')","a2cec57e":"#visualize_model(vgg16) #test before training","963d4a95":"def train_model(vgg, criterion, optimizer, scheduler, num_epochs=5):\n    since = time.time()\n    best_model_wts = copy.deepcopy(vgg.state_dict())\n    best_acc = 0.0\n    \n    avg_loss = 0\n    avg_acc = 0\n    avg_loss_val = 0\n    avg_acc_val = 0\n    \n    train_batches = len(dataloaders[TRAIN])\n    #val_batches = len(dataloaders[VAL])\n    loss_values = []\n    acc_values = []\n    for epoch in range(num_epochs):\n        print(\"Epoch {}\/{}\".format(epoch+1, num_epochs))\n        print('-' * 10)\n        \n        loss_train = 0\n        loss_val = 0\n        acc_train = 0\n#         acc_val = 0\n        \n        vgg.train(True)\n        \n        for i, data in enumerate(dataloaders[TRAIN]):\n            \n            print(\"\\rTraining batch {}\/{}\".format(i+1, train_batches), end='', flush=True)\n                \n            \n                \n            inputs, labels,_= data\n            \n            if use_gpu:\n                inputs, labels = Variable(inputs.cuda()), Variable(labels.cuda())\n            else:\n                inputs, labels = Variable(inputs), Variable(labels)\n            #Sets the gradients of all optimized torch.Tensor s to zero.\n            optimizer.zero_grad()\n            \n            outputs = vgg(inputs)\n            \n            _, preds = torch.max(outputs.data, 1)\n            loss = criterion(outputs, labels)\n            \n            #computes dloss\/dw for every parameter w which has requires_grad=True.\n            #These are accumulated into w.grad for every parameter w\n            loss.backward()\n            \n            #updates the value of w using the gradient w.grad\n            optimizer.step()\n            \n            loss_train += loss.data[0]\n            acc_train += torch.sum(preds == labels.data)\n            \n            del inputs, labels, outputs, preds\n            torch.cuda.empty_cache()\n        \n        print()\n        avg_loss = loss_train  \/ dataset_sizes[TRAIN]\n        avg_acc = acc_train  \/ dataset_sizes[TRAIN]\n        loss_values.append(avg_loss)\n        acc_values.append(avg_acc)\n        vgg.train(False)\n        vgg.eval()\n            \n\n        \n        print()\n        print(\"Epoch {} result: \".format(epoch))\n        print(\"Avg loss (train): {:.4f}\".format(avg_loss))\n        print(\"Avg acc (train): {:.4f}\".format(avg_acc))\n\n        print('-' * 10)\n        print()\n        \n        if avg_acc > best_acc:\n            best_acc = avg_acc\n            best_model_wts = copy.deepcopy(vgg.state_dict())\n        \n    elapsed_time = time.time() - since\n    print()\n    print(\"Training completed in {:.0f}m {:.0f}s\".format(elapsed_time \/\/ 60, elapsed_time % 60))\n    print(\"Best acc: {:.4f}\".format(best_acc))\n    \n    vgg.load_state_dict(best_model_wts)\n    return vgg,acc_values,loss_values","87f0525b":"vgg16,acc,loss = train_model(vgg16, criterion, optimizer_ft, exp_lr_scheduler, num_epochs=10)\ntorch.save(vgg16.state_dict(),'VGG19_echocardiogram.pt')","ff9babe3":"y_true,y_pred,vid_code = eval_model(vgg16, criterion)","595616f3":"print(len(y_true)) \nprint(len(y_pred))","101e067b":"visualize_model(vgg16, num_images=32)","6108abf6":"from sklearn.metrics import accuracy_score,classification_report\nprint(classification_report(y_true,y_pred))\nprint(accuracy_score(y_true,y_pred))","9ea0ec5b":"import pandas as pd\nimport glob\n\n\ndf = pd.DataFrame(list(zip(y_true,y_pred,vid_code)),columns =['y_true','y_pred','vid_id'])\ndf.to_csv('df.csv',encoding='utf-8',index=False)","6745a8d1":"df.head(10)","49f544ef":"from statistics import mode\nvid_list = list(set(df['vid_id'].values))\n#df.groupby(['vid_id'])\n","34b0e1dc":"print(vid_list)","5c18b516":"y_true = []\ny_pred = []\nfor vid in vid_list:\n    #print(vid)\n    tmp_df = df[df['vid_id']==vid]\n    #print(len(tmp_df))\n    vid_pred = tmp_df['y_pred'].mode().values[0]\n    vid_label = tmp_df['y_true'].mode().values[0]\n    y_true.append(vid_label)\n    y_pred.append(vid_pred)\n    #print(vid_label,\"\\n\",vid_pred)\n    \n    #print('vid: {} label: {} pred: {}'.format(vid,vid_label,vid_pred))","29cbe768":"accuracy_score(y_true,y_pred)","91a0093c":"def plot_history(history,loss,acc): \n    fig, ax1 = plt.subplots()\n    \n    ax1.plot(loss, 'r', label=\"training loss\")\n    ax1.grid(True)\n    ax1.set_xlabel('iteration')\n    ax1.set_ylabel('loss', color='r')\n    ax1.legend(loc=\"lower right\", fontsize=9)    \n    ax1.tick_params('y', colors='r')\n\n    ax2 = ax1.twinx()\n    ax2.plot(acc, 'b', label=\"training acc\")\n    ax2.legend(loc=\"upper right\", fontsize=9)\n    ax2.set_ylabel('acc', color='b')        \n    ax2.tick_params('y', colors='b')","4bf714a9":"plot_history(vgg16,loss,acc)","de8c3eeb":"# Let check out our test data\n","16c88af5":"The output above is the summary of our model. Notice how the last layer has 4 output features as we specified. ","36d41698":"## Model evaluation and visualization (before training)\n\nLet's see how our model performs before any training","aca55703":"# Evaluate func","11a4a180":"*Python Modules*","e7090353":"# Load model","2d253304":"## Model evaluation and visualization (after training)\n\nLet's evaluate our model again after 10 epochs of training","851547ba":"# Load train and test data","b3033fb7":"This helper function will give us the accuracy of our model on the test set.","59b09e61":"# Show images from a batch","c009606b":"# Preprocessing image","8c4115a2":"## Training\n\n\n\nFor every epoch we iterate over all the training batches, compute the loss , and adjust the network weights with `loss.backward()` and `optimizer.step()`. \nThen we evaluate the performance over the validaton set. At the end of every epoch we print the network progress (loss and accuracy). \nThe accuracy will tell us how many predictions were correct.\n\nAs we said before, transfer learning can work on smaller dataset too, so for every epoch we only iterate over half the trainig dataset (worth noting that it won't exactly be half of it over the entire training, as the data is shuffled, but it will almost certainly be a subset) ","9a5bab87":"The accuracy score seem to be good \n\nHope you found this useful! ","9cdb1ccf":"# Plot training history","83b8dbb7":"# Visualize our model ._.","8e588118":"Not really great results. Let's see if it can do better after training "}}