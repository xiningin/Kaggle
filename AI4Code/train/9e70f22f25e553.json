{"cell_type":{"ac16a376":"code","c55ffad4":"code","7f9a8d6b":"code","3f91d9eb":"code","04a47bd5":"code","ae61f64a":"code","2af70eda":"code","838d9c89":"code","606a6454":"code","33564795":"code","3b69aba6":"markdown","707be40a":"markdown","653f16c5":"markdown","45633d95":"markdown","2c88c8ce":"markdown"},"source":{"ac16a376":"import tensorflow as tf\nfrom keras.preprocessing.image import ImageDataGenerator\nimport pandas as pd\nfrom abc import ABC, abstractmethod\n\nfrom typing import Optional, Callable\nimport numpy as np","c55ffad4":"class Pipeline(ABC):\n    input_path = '..\/input\/petfinder-pawpularity-score\/'\n\n\nclass ImagePipeline(Pipeline):\n    X: tf.keras.preprocessing.image.DirectoryIterator\n    \n    def get_dataframe(self, csv: str):\n        self.df = pd.read_csv(\n            self.input_path + csv,\n        )[['Id']]\n        self.df.index = self.df.Id\n        self.df.index = self.df.index.astype(str) + \".jpg\"\n        self.df.drop(\"Id\", axis=1, inplace=True)\n        \n    def __init__(\n        self,\n        csv: str,\n        datagen: Optional[ImageDataGenerator]=None,\n        seed: Optional[int]=1234\n    ):\n        self.datagen = ImageDataGenerator(\n            rescale=1.\/255\n        )\n        self.get_dataframe(csv)\n        self.X = self.datagen.flow_from_dataframe(\n            dataframe=self.df.reset_index(),\n            directory=self.input_path + csv.replace(\".csv\", \"\"),\n            x_col=\"Id\",\n            class_mode=None,\n            target_size=(224, 224),\n            batch_size=32,\n            shuffle=False,\n            seed=seed\n        )\n\nclass POCEncoder:\n    def __init__(self):\n        poc = tf.keras.models.load_model(\"..\/input\/01-keras-images-model-poc\/poc.h5\")\n        poc.summary()\n        self.poc_extract = tf.keras.models.Model(poc.input, poc.get_layer(\"encode\").output)\n    def predict(self, X):\n        return self.poc_extract.predict(X)\n    \n\nclass ImportPipeline(ABC):\n    @abstractmethod\n    def import_data(self):\n        pass\n    \n    \nclass ImportPOCPipeline(ImportPipeline):\n    def __init__(self):\n        self.poc_encoder = POCEncoder()\n        \n    def import_data(self):\n        self.train_encode = pd.read_csv(\"..\/input\/02-encode\/train_poc_encoded.csv\")\n        self.train_encode = self.train_encode.set_index(\"Id\")\n        self.selected_columns = self.train_encode.columns\n\n        self.test_image_pipeline = ImagePipeline(\"test.csv\")\n        self.test_image_encoded = self.poc_encoder.predict(self.test_image_pipeline.X)\n\n        self.test_encode = pd.DataFrame(self.test_image_encoded)\n        self.test_encode.index = self.test_image_pipeline.df.index\n        self.test_encode.columns =  \"poc_\"+ self.test_encode.columns.astype(str)\n\n        self.test_encode = pd.concat([self.test_image_pipeline.df, self.test_encode], axis=1)\n        self.test_encode.index = self.test_encode.index.str.replace(\".jpg\", \"\")\n        self.test_encode = self.test_encode[self.selected_columns]","7f9a8d6b":"class MainPipeline(Pipeline):\n    mergepocpipeline = ImportPOCPipeline()\n    mergepocpipeline.import_data()\n\nclass TrainPipeline(MainPipeline):\n    def __init__(self, filepath, target):\n        self.df = pd.read_csv(filepath)\n        self.df = self.df.set_index(\"Id\")\n        self.target = target\n    def run(self):\n        self.y = self.df[self.target]\n        self.X = self.df.drop(self.target, axis=1)\n        self.X = pd.concat([self.X, self.mergepocpipeline.train_encode], axis=1)\n\nclass TestPipeline(MainPipeline):\n    def __init__(self, filepath):\n        self.df = pd.read_csv(filepath)\n        self.df = self.df.set_index(\"Id\")\n    def run(self):\n        self.X = self.df\n        self.X = pd.concat([self.X, self.mergepocpipeline.test_encode], axis=1)\n        \n        \ntrain = TrainPipeline(\"..\/input\/petfinder-pawpularity-score\/train.csv\", target='Pawpularity')\ntrain.run()\n\ntest = TestPipeline(\"..\/input\/petfinder-pawpularity-score\/test.csv\")\ntest.run()","3f91d9eb":"corr = pd.concat([train.X, train.y], axis=1).corr()\ncorr['Pawpularity']","04a47bd5":"import os\nfrom sklearn.model_selection import KFold, RepeatedKFold, RepeatedStratifiedKFold\nimport pickle\nimport json\nfrom catboost import CatBoostRegressor\nfrom sklearn.metrics import mean_squared_error\n\n\n\ndef rmse(y_true, y_pred):\n    return mean_squared_error(y_true, y_pred)**0.5\n\n\ndef fit_catboost(X_train, y_train, X_test, y_test):\n    from catboost import Pool\n    eval_set = Pool(X_test, y_test)\n    reg = CatBoostRegressor(\n        iterations=500,\n        grow_policy='Lossguide',\n        loss_function='RMSE',\n        verbose=False,\n        l2_leaf_reg=100.5,\n        task_type='GPU',\n        # use_best_model=True,\n    )\n    reg.fit(X_train, y_train)\n    return reg\n\n\nfit_models = [fit_catboost]\nkf = KFold(n_splits=5, shuffle=True, random_state=1234)\n# kf = RepeatedKFold(n_splits=5, n_repeats=30, random_state=1234)\n\nfit_results = {}\nfor k, (train_index, test_index) in enumerate(kf.split(train.X)):\n    print(f\"K Fold: {k + 1}\")\n    print(\"TRAIN:\", train_index, \"TEST:\", test_index)\n    X_train, X_test = train.X.iloc[train_index], train.X.iloc[test_index]\n    y_train, y_test = train.y.iloc[train_index], train.y.iloc[test_index]\n    \n    for fit_model in fit_models:\n        model_name = '_'.join(fit_model.__name__.split('fit_')[1:])\n        model_result_path = f\"model_results\/{model_name}\"\n        model_checkpoint = f\"model_results\/{model_name}\/fold_{k+1}.pickle\"\n        \n        if not os.path.exists(model_result_path):\n            os.makedirs(model_result_path)\n        if model_name not in fit_results:\n            fit_results[model_name] = []\n        if os.path.isfile(model_checkpoint):\n            print(\"Found trained model\")\n            with open(model_checkpoint, 'rb') as f:\n                model = pickle.load(f)\n\n        else:\n            model = fit_model(X_train, y_train, X_test, y_test)\n        \n        train_pred = model.predict(X_train)\n        rmse_train = rmse(y_train, train_pred)\n\n        test_pred = model.predict(X_test)\n        rmse_test = rmse(y_test, test_pred)\n        \n        print(f\"rmse train: {rmse_train}\")\n        print(f\"rmse test: {rmse_test}\")\n        \n        try:\n            oof_pred = model.predict(X_oof)\n            rmse_oof = rmse(y_oof, oof_pred)\n            print(f\"rmse OOF: {rmse_oof}\")\n        except NameError:\n            pass\n\n        try:\n            with open(f\"model_results\/{model_name}\/fold_{k+1}.pickle\", \"wb\") as f:\n                pickle.dump(model, f)\n        except:\n            pass\n        fit_results[model_name].append({\n            'model': model,\n            'rmse_train': rmse_train,\n            'rmse_test': rmse_test\n        })","ae61f64a":"np.mean([score['rmse_test'] for score in fit_results[model_name]])","2af70eda":"np.std([score['rmse_test'] for score in fit_results[model_name]])","838d9c89":"sub = np.mean(\n    [model['model'].predict(test.X) for model in fit_results[model_name]],\n    axis=0\n)","606a6454":"sub = pd.DataFrame(sub)","33564795":"sub.columns = ['Pawpularity']\nsub.index = test.X.index\nsub.to_csv(\"submission.csv\")","3b69aba6":"# Import essential","707be40a":"## Main pipeline","653f16c5":"# Modeling","45633d95":"# Pipeline","2c88c8ce":"## Import encode data pipeline"}}