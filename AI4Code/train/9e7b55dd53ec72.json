{"cell_type":{"ae453d71":"code","137ea108":"code","e595b498":"code","170a12f6":"code","293ad753":"code","ddd04701":"code","cbd0c401":"code","c5cd1671":"code","5544b332":"code","f8459e86":"code","45871fc6":"code","382d9706":"code","4a18ccff":"code","a5b95a6a":"markdown"},"source":{"ae453d71":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","137ea108":"# Read the json file\ndf = pd.read_json(\"\/kaggle\/input\/scl-2021-da\/contacts.json\")\ndf.head()","e595b498":"# Initialize parent array\nparent = list(df.Id)\ncluster = [[i] for i in parent]\ntotalcontact = list(df.Contacts)\n# Union find code\ndef root(i):\n  while(i != parent[i]):\n    parent[i] = parent[parent[i]]\n    i = parent[i]\n  return i\n\ndef union(p,q):\n  i = root(p)\n  j = root(q)\n  if i==j:\n    pass\n  elif len(cluster[i]) > len(cluster[j]):\n    parent[j] = i\n    cluster[i] += cluster[j]\n    totalcontact[i] += totalcontact[j]\n  else:\n    parent[i] = j\n    cluster[j] += cluster[i]\n    totalcontact[j] += totalcontact[i]","170a12f6":"def cluster_on_col(col):\n    # Sort by column\n    df_1 = df.sort_values(by=col, ignore_index=True)\n    for id_fi,id_se,col_fi,col_se in zip(df_1.Id, df_1.Id[1:], df_1[col], df_1[col][1:]):\n        if col_se == \"\": # Skip NA\n            continue\n        if col_fi == col_se: # If intersect, union\n            union(id_fi,id_se)","293ad753":"# Cluster on the 3 columns\ncluster_on_col(\"Email\")\ncluster_on_col(\"Phone\")\ncluster_on_col(\"OrderId\")","ddd04701":"# Store roots in df\ndf[\"Parent\"] = [root(i) for i in parent]","cbd0c401":"# Sanity check of how many unique \"people\" are in the dataset\ndf[\"Parent\"].value_counts()","c5cd1671":"# Process ticket_trace and total contacts\ntemp = [(i,'-'.join(map(str,sorted(cluster[i]))) + \", \" + str(totalcontact[i]) ) for i in df[\"Parent\"].unique()]\ntemp = pd.DataFrame(temp, columns=[\"Parent\",\"ticket_trace\/contact\"])\ntemp","5544b332":"# Merge result back into dataframe\ndf = df.merge(temp, on=\"Parent\")","f8459e86":"# Make the ticket_id column\ndf[\"ticket_id\"] = df[\"Id\"].astype(\"str\")","45871fc6":"# They want sorted by id\ndf = df.sort_values(by=\"Id\", ignore_index=True)\ndf.head()","382d9706":"# Subset out what we want to submit\nsubmit = df[[\"ticket_id\",\"ticket_trace\/contact\"]]\nsubmit.head()","4a18ccff":"submit.to_csv(\"submission.csv\", index=False)","a5b95a6a":"<p>This notebook provides a solution to the problem using Union Find. The reason that union find is used is because the question requires one to be able to cluster tickets into sets.<\/p>\n\n```\nUnion find has 2 main operations:\n1. It must be able to find if 2 elements are part of the same set\n2. It must be able to combine two sets\n```\n\n<p>The concept of implementation is simple, we construct a tree for each set and say that two elements are part of the same set if and only if they have the same root in their tree. <\/p>\n\n```\nOperation (1) can then be achieved by comparing roots.\nif root(a) == root(b), they are part of the same set\nelse they are not part of the same set\n```\n```\nOperation (2) can then be achieved by making the root of A the root of B by setting root of B to its parent.\nif root(a) == root(b), pass\nelse parent[root(a)] = root(b)\n```\n\n<p>Now that we have a method to combine sets. We need a way to find when to combine them. This means we must find when they have the same Email, Phone or OrderId. Since the union operation is idempotent and symmetric (Applying multiple times does not change the result and it has no direction) we can do each column independently.<\/p>\n<p>We will sort the column and parse through each consecutive pair of rows in O(n). This will identify all duplicates for that particular column. We will then perform the union operation if duplicate rows are identified.<\/p>\n\n\n   \n"}}