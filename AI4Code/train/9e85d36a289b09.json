{"cell_type":{"8822ea56":"code","f380fa08":"code","c7f3ec87":"code","d1bd8f3f":"code","1fede188":"code","b39e4d76":"code","1fa36e73":"code","2b216f27":"code","b1b8ca2c":"code","d015764d":"code","0f99f610":"code","e98bef05":"code","2ef6ebbf":"code","0da0e763":"code","bfc13454":"code","43d8499b":"code","af3902c6":"code","71cd3400":"code","89ce23b4":"code","f7a60bae":"code","f1c18a37":"code","50aab025":"code","063c5287":"code","59726a1f":"code","f0ec37c1":"code","9927431e":"code","3cb9a9b5":"markdown","d3838608":"markdown","40937974":"markdown","2e37623c":"markdown","dd3e53d9":"markdown","32057cb9":"markdown","80eead54":"markdown","0afd591f":"markdown","11064533":"markdown","e5e8d931":"markdown","4923f9cd":"markdown","fbfd753a":"markdown","238d39db":"markdown","44ba1b0d":"markdown","8b99c947":"markdown","9c601f25":"markdown","eebef564":"markdown","93260a4f":"markdown","7f7032c1":"markdown","08cedbc4":"markdown","0ada68e8":"markdown","6b93f93e":"markdown","0aa429f5":"markdown","7009b799":"markdown","efb8af43":"markdown","72c94b95":"markdown","8f65f24a":"markdown"},"source":{"8822ea56":"from IPython.display import Image\nImage(\"..\/input\/pneumoniadata\/Pneumonia.jpg\")\n\n# Image source: https:\/\/www.drugs.com\/health-guide\/pneumonia.html","f380fa08":"# importing libraries\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport os\nimport random\nimport glob # to find files\n\n# Seaborn library for bar chart\nimport seaborn as sns\n\n# Libraries for TensorFlow\nfrom tensorflow.keras.utils import to_categorical\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras import models, layers\n\n# Library for Transfer Learning\nfrom tensorflow.keras.applications import VGG16\nfrom keras.applications.vgg16 import preprocess_input\n\nprint(\"Importing libraries completed.\")","c7f3ec87":"# Declaring variables\n\n# variables for data paths\npath = '..\/input\/chest-xray-pneumonia\/chest_xray\/'\n\n# train directory\ntrain_folder=path+\"train\/\"\ntrain_normal_dir=train_folder+\"NORMAL\/\"\ntrain_pneu_dir=train_folder+\"PNEUMONIA\/\"\n# test directory\ntest_folder=path+\"test\/\"\ntest_normal_dir=test_folder+\"NORMAL\/\"\ntest_pneu_dir=test_folder+\"PNEUMONIA\/\"\n# validation directory\nval_folder=path+\"val\/\"\nval_normal_dir=val_folder+\"NORMAL\/\"\nval_pneu_dir=val_folder+\"PNEUMONIA\/\"\n\n# variables for image size\nimg_width=196\nimg_height=196\n\n# variable for model\nbatch_size=64\nepochs=10\n\nprint(\"Variable declaration completed.\")","d1bd8f3f":"# listing the folders containing images\n\n# Train Dataset\ntrain_class_names=os.listdir(train_folder)\nprint(\"Train class names: %s\" % (train_class_names))\n# print(\"\\n\")\n\n# Test Dataset\ntest_class_names=os.listdir(test_folder)\nprint(\"Test class names: %s\" % (test_class_names))\n# print(\"\\n\")\n\n# Validation Dataset\nval_class_names=os.listdir(val_folder)\nprint(\"Validation class names: %s\" % (val_class_names))\n\nprint(\"\\nDataset class name listing completed.\")","1fede188":"# declaration of functions\n\n# Function get name of xray type\ndef Get_Xray_Type(argument):\n    switcher = {\n        \"NORMAL\": \"Normal\",\n        \"PNEUMONIA\": \"Pneumonia\",\n    }\n    return switcher.get(argument, \"Invalid X-ray\")\n# Get_Xray_Type(\"NORMAL\") # this is how the function can be called\n\nprint(\"Declaration of functions completed.\")","b39e4d76":"# Analysis of Train, Test and Validation directory\n\n# find all files, our files has extension jpeg\ntrain_normal_cases = glob.glob(train_normal_dir + '*jpeg')\ntrain_pneu_cases = glob.glob(train_pneu_dir + '*jpeg')\n\ntest_normal_cases = glob.glob(test_normal_dir + '*jpeg')\ntest_pneu_cases = glob.glob(test_pneu_dir + '*jpeg')\n\nval_normal_cases = glob.glob(val_normal_dir + '*jpeg')\nval_pneu_cases = glob.glob(val_pneu_dir + '*jpeg')\n\n# create lists for train, test & validation cases, create labels as well\ntrain_list = []\ntest_list = []\nval_list = []\n\nfor x in train_normal_cases:\n    train_list.append([x, \"Normal\"])\n    \nfor x in train_pneu_cases:\n    train_list.append([x, \"Pneumonia\"])\n    \nfor x in test_normal_cases:\n    test_list.append([x, \"Normal\"])\n    \nfor x in test_pneu_cases:\n    test_list.append([x, \"Pneumonia\"])\n    \nfor x in val_normal_cases:\n    val_list.append([x, \"Normal\"])\n    \nfor x in val_pneu_cases:\n    val_list.append([x, \"Pneumonia\"])\n\n# create dataframes\ntrain_df = pd.DataFrame(train_list, columns=['image', 'Diagnos'])\nprint(train_df.shape)\ntest_df = pd.DataFrame(test_list, columns=['image', 'Diagnos'])\nprint(test_df.shape)\nval_df = pd.DataFrame(val_list, columns=['image', 'Diagnos'])\nprint(val_df.shape)","1fa36e73":"# plotting the Train, Test and Validation image data\n\nplt.figure(figsize=(20,5))\n\nplt.subplot(1,3,1)\nsns.countplot(train_df['Diagnos'])\nplt.title('Train data')\n\nplt.subplot(1,3,2)\nsns.countplot(test_df['Diagnos'])\nplt.title('Test data')\n\nplt.subplot(1,3,3)\nsns.countplot(val_df['Diagnos'])\nplt.title('Validation data')\n\nplt.show()","2b216f27":"# Plotting raw images just for review\n\nplt.figure(figsize=(20,8))\nfor i,img_path in enumerate(train_df[train_df['Diagnos'] == \"Pneumonia\"][0:4]['image']):\n    plt.subplot(2,4,i+1)\n    plt.axis('off')\n    img = plt.imread(img_path)\n    plt.imshow(img, cmap='gray')\n    plt.title('Pneumonia')\n    \nfor i,img_path in enumerate(train_df[train_df['Diagnos'] == \"Normal\"][0:4]['image']):\n    plt.subplot(2,4,4+i+1)\n    plt.axis('off')\n    img = plt.imread(img_path)\n    plt.imshow(img, cmap='gray')\n    plt.title('Normal')","b1b8ca2c":"# Preparing Training image data (image array and class name) for processing\n\n# Declaring variables\nx=[] # to store array value of the images\ny=[] # to store the labels of the images\n\nfor folder in os.listdir(train_folder):\n    image_list=os.listdir(train_folder+\"\/\"+folder)\n    for img_name in image_list:\n        # Loading images\n        img=image.load_img(train_folder+\"\/\"+folder+\"\/\"+img_name,target_size=(img_width,img_height))\n        \n        # Converting to arrary\n        img=image.img_to_array(img)\n        \n        # Transfer Learning: this is to apply preprocess of VGG16 model to our images before passing it to VGG16\n        img=preprocess_input(img) #  Optional step\n        \n        # Appending the arrarys\n        x.append(img) # appending image array\n        y.append(train_class_names.index(folder)) # appending class index to the array\n        \nprint(\"Preparing Training Dataset Completed.\")","d015764d":"# Preparing validation images data (image array and class name) for processing\n\n# Declaring variables\nval_images=[]\nval_images_Original=[]\nval_image_label=[] # to store the labels of the images\n\nfor folder in os.listdir(val_folder):\n    image_list=os.listdir(val_folder+\"\/\"+folder)\n    for img_name in image_list:\n        # Loading images\n        img=image.load_img(val_folder+\"\/\"+folder+\"\/\"+img_name,target_size=(img_width,img_height))\n        \n        # Converting to arrarys\n        img=image.img_to_array(img)\n        \n        # Saving original images, will be used just for display at the end\n        val_images_Original.append(img.copy())\n        \n        # Transfer Learning: this is to apply preprocess of VGG16 to our images before passing it to VGG16\n        img=preprocess_input(img) #  Optional step\n        \n        # Appending arrays\n        val_images.append(img) # appending image array\n        val_image_label.append(val_class_names.index(folder))\n        \nprint(\"Preparing Validation Dataset Completed.\")","0f99f610":"# Preparing validation images data (image array and class name) for processing\n\n# Declaring variables\ntest_images=[]\ntest_images_Original=[]\ntest_image_label=[] # to store the labels of the images\n\nfor folder in os.listdir(test_folder):\n    image_list=os.listdir(test_folder+\"\/\"+folder)\n    for img_name in image_list:\n        # Loading images\n        img=image.load_img(test_folder+\"\/\"+folder+\"\/\"+img_name,target_size=(img_width,img_height))\n        \n        # Converting to arrarys\n        img=image.img_to_array(img)\n        \n        # Saving original images, will be used just for display at the end\n        test_images_Original.append(img.copy())\n        \n        # Transfer Learning: this is to apply preprocess of VGG16 to our images before passing it to VGG16\n        img=preprocess_input(img) #  Optional step\n        \n        # Appending arrays\n        test_images.append(img) # appending image array\n        test_image_label.append(test_class_names.index(folder))\n        \nprint(\"Preparing Test Dataset Completed.\")","e98bef05":"# Verifying the output\n\n# Training Dataset\nprint(\"Training Dataset\")\n\nx=np.array(x) # Converting to np arrary to pass to the model\nprint(x.shape)\n\ny=to_categorical(y) # onehot encoding of the labels\n# print(y)\nprint(y.shape)\n\n# ===========\n\n# Test Dataset\nprint(\"Test Dataset\")\n\ntest_images=np.array(test_images) \nprint(test_images.shape)\n\ntest_image_label=to_categorical(test_image_label) # onehot encoding of the labels)\nprint(test_image_label.shape)\n\n# ===========\n\n# Validation Dataset\nprint(\"Validation Dataset\")\n\nval_images=np.array(val_images) \nprint(val_images.shape)\n\nval_image_label=to_categorical(val_image_label) # onehot encoding of the labels)\nprint(val_image_label.shape)","2ef6ebbf":"# Check properties of the model that we are going to use for Transfer Learning\n\nprint(\"Summary of default VGG16 model.\\n\")\n\n# we are using VGG16 for transfer learnin here. So we have imported it\nfrom tensorflow.keras.applications import VGG16\n\n# initializing model with weights='imagenet'i.e. we are carring its original weights\nmodel_vgg16=VGG16(weights='imagenet')\n\n# display the summary to see the properties of the model\nmodel_vgg16.summary()","0da0e763":"# Modelling WITH Transfer Learning\n\n# Here we will prepare model as per our requirements\n\nprint(\"Summary of Custom VGG16 model.\\n\")\nprint(\"1) We setup input layer and 2) We removed top (last) layer. \\n\")\n\n# let us prepare our input_layer to pass our image size. default is (224,224,3). we will change it to (224,224,3)\ninput_layer=layers.Input(shape=(img_width,img_height,3))\n\n# initialize the transfer model VGG16 with appropriate properties per our need.\n# we are passing paramers as following\n# 1) weights='imagenet' - Using this we are carring weights as of original weights.\n# 2) input_tensor to pass the VGG16 using input_tensor\n# 3) we want to change the last layer so we are not including top layer\nmodel_vgg16=VGG16(weights='imagenet',input_tensor=input_layer,include_top=False)\n\n# See the summary of the model with our properties.\nmodel_vgg16.summary()","bfc13454":"# access the current last layer of the model and add flatten and dense after it\n\nprint(\"Summary of Custom VGG16 model.\\n\")\nprint(\"1) We flatten the last layer and added 1 Dense layer and 1 output layer.\\n\")\n\nlast_layer=model_vgg16.output # we are taking last layer of the model\n\n# Add flatten layer: we are extending Neural Network by adding flattn layer\nflatten=layers.Flatten()(last_layer) \n\n# Add dense layer\n# dense1=layers.Dense(100,activation='relu')(flatten)\n\n# Add dense layer to the final output layer\noutput_layer=layers.Dense(2,activation='softmax')(flatten)\n\n# Creating modle with input and output layer\nmodel=models.Model(inputs=input_layer,outputs=output_layer)\n\n# Summarize the model\nmodel.summary()","43d8499b":"# we will freez all the layers except the last layer\n\n# we are making all the layers intrainable except the last layer\nprint(\"We are making all the layers intrainable except the last layer. \\n\")\nfor layer in model.layers[:-1]:\n    layer.trainable=False\nmodel.summary()","af3902c6":"# Train the Model\n\nfrom sklearn.model_selection import train_test_split\nxtrain, xtest, ytrain, ytest = train_test_split(x,y,test_size=0.2,random_state=5)\n# print(xtrain)\n# print(xtest)\n# print(ytrain)\n# print(ytest)\n\nprint(\"Splitting data for train and test completed.\")","71cd3400":"# Compiling Model\n\nmodel.compile(loss='categorical_crossentropy', optimizer='adam',metrics=['accuracy'])\n\nprint(\"Model compilation completed.\")","89ce23b4":"# # this experiment can also be done using ImageDataGenerator approach\n# # As this approach gave me less accuracy, I choose approach of NOT using ImageDataGenerator\n\n# from keras.preprocessing.image import ImageDataGenerator\n\n# train_datagen = ImageDataGenerator(rescale = 1.\/255,           \n#                                    shear_range = 0.2,          \n#                                    zoom_range = 0.2,  \n#                                    horizontal_flip = True)\n\n# train_data = train_datagen.flow_from_directory(train_folder,                      \n#                                                target_size = (img_width, img_height),      \n#                                                batch_size = 128,\n#                                                class_mode = 'categorical') \n\n# test_datagen = ImageDataGenerator(rescale = 1.\/255) \n# test_data = test_datagen.flow_from_directory(test_folder,\n#                                             target_size = (img_width, img_height),\n#                                             batch_size = 128,\n#                                             class_mode = 'categorical')\n\n# history = model.fit(train_data,validation_data=test_data,epochs=epochs)  \n\n# # Above approach gives following output:\n# Epoch 1\/10\n# 82\/82 [==============================] - 110s 1s\/step - loss: 0.2688 - accuracy: 0.8869 - val_loss: 0.2438 - val_accuracy: 0.9038\n# Epoch 2\/10\n# 82\/82 [==============================] - 107s 1s\/step - loss: 0.1238 - accuracy: 0.9559 - val_loss: 0.2501 - val_accuracy: 0.9103\n# Epoch 3\/10\n# 82\/82 [==============================] - 106s 1s\/step - loss: 0.1114 - accuracy: 0.9576 - val_loss: 0.2619 - val_accuracy: 0.9103\n# Epoch 4\/10\n# 82\/82 [==============================] - 104s 1s\/step - loss: 0.1001 - accuracy: 0.9647 - val_loss: 0.2290 - val_accuracy: 0.9151\n# Epoch 5\/10\n# 82\/82 [==============================] - 105s 1s\/step - loss: 0.0850 - accuracy: 0.9711 - val_loss: 0.2211 - val_accuracy: 0.9247\n# Epoch 6\/10\n# 82\/82 [==============================] - 103s 1s\/step - loss: 0.0858 - accuracy: 0.9697 - val_loss: 0.2130 - val_accuracy: 0.9263\n# Epoch 7\/10\n# 82\/82 [==============================] - 104s 1s\/step - loss: 0.0773 - accuracy: 0.9703 - val_loss: 0.2308 - val_accuracy: 0.9199\n# Epoch 8\/10\n# 82\/82 [==============================] - 104s 1s\/step - loss: 0.0759 - accuracy: 0.9718 - val_loss: 0.2149 - val_accuracy: 0.9199\n# Epoch 9\/10\n# 82\/82 [==============================] - 103s 1s\/step - loss: 0.0745 - accuracy: 0.9722 - val_loss: 0.4007 - val_accuracy: 0.8830\n# Epoch 10\/10\n# 82\/82 [==============================] - 104s 1s\/step - loss: 0.0659 - accuracy: 0.9741 - val_loss: 0.3147 - val_accuracy: 0.8942\n","f7a60bae":"# Fit the Model\n\nmodel.fit(xtrain,ytrain,epochs=epochs,batch_size=batch_size,verbose=True,validation_data=(xtest,ytest))\n\nprint(\"Fitting the model completed.\")","f1c18a37":"# This function helps to predict individual image supplied to it\ndef predict(img_name):\n    img=image.load_img(img_name,target_size=(img_width,img_height))\n    img=image.img_to_array(img)\n    plt.imshow(img.astype('int32'))\n    plt.show()\n    img=preprocess_input(img)\n#     plt.imshow(img.astype('int32'))\n#     plt.show()\n    prediction=model.predict(img.reshape(1,img_width,img_height,3))\n    output=np.argmax(prediction)\n    print(train_class_names[output] + \": \" + Get_Xray_Type(train_class_names[output]))\n#     print(train_class_names[output])\n#     print(class_names_actual[output])\n    \n    \n\n# This function plots the image supplied in array\ndef plot_image(i, predictions_array, true_label, img): # taking index and 3 arrays viz. prediction array, true label array and image array\n    \n    predictions_array, true_label, img = predictions_array[i], true_label[i], img[i]\n    \n    plt.grid(False)\n    plt.xticks([])\n    plt.yticks([])\n    \n    plt.imshow(img.astype('int32'))\n    \n    predicted_label=np.argmax(predictions_array)\n    true_label=np.argmax(true_label)\n\n#     print(predicted_label)\n#     print(true_label)\n\n    if predicted_label == true_label: #setting up label color\n        color='green' # correct then blue colour\n    else:\n        color='red' # wrong then red colour\n    \n#     predicted_class=val_class_names[predicted_label]\n#     true_class=val_class_names[true_label]\n    \n    plt.xlabel(\"{} {:2.0f}% \\n ({})\".format(str(Get_Xray_Type(val_class_names[predicted_label])), 100*np.max(predictions_array), str(Get_Xray_Type(val_class_names[true_label])), color=color, horizontalalignment='left'))\n#     plt.xlabel(\"{} {:2.0f}% ({})\".format(val_class_names[predicted_label], 100*np.max(predictions_array), val_class_names[true_label]), color=color)\n\n# This function plots bar chart supplied in the array data\ndef plot_value_array(i, predictions_array, true_label): # taking index along with predictions and true label array\n    predictions_array, true_label = predictions_array[i], true_label[i]\n    plt.grid(False)\n    plt.xticks([])\n    plt.yticks([])\n    predicted_label=np.argmax(predictions_array)\n    true_label=np.argmax(true_label)\n#     print(predicted_label)\n#     print(true_label)\n    if predicted_label == 0:\n        predicted_label=1\n    if true_label == 0:\n        true_label=1\n    \n    thisplot=plt.bar(range(10), predicted_label, color='seashell')\n    plt.ylim([0,1])\n\n    thisplot[predicted_label].set_color('red')\n    thisplot[true_label].set_color('green')","50aab025":"# Preparing prediction arrary\nval_predictions=[]\n\nfor img in val_images:\n    img=img.reshape(1,img_width,img_height,3)\n    val_predictions.append(model.predict(img))\n    \ntest_predictions=[]\n\nfor img in test_images:\n    img=img.reshape(1,img_width,img_height,3)\n    test_predictions.append(model.predict(img))","063c5287":"# Prediction of individual images taken from internet\n\n# !wget -q https:\/\/prod-images-static.radiopaedia.org\/images\/25074651\/ec1fa7072de87da7445f43ad54a784_jumbo.jpeg\npredict('..\/input\/chest-xray-pneumonia\/chest_xray\/train\/PNEUMONIA\/person1000_bacteria_2931.jpeg') \n\n# white_headed_capuchin\n# !wget -q https:\/\/drbeeneducation.files.wordpress.com\/2016\/09\/posteriorv1-v11.png?resize=1113%2C886\npredict('..\/input\/chest-xray-pneumonia\/chest_xray\/test\/PNEUMONIA\/person108_bacteria_506.jpeg') \n    \n# japanese_macaque\n# !wget -q https:\/\/hongkongliving.com\/wp-content\/uploads\/2019\/06\/Monkey-Hill.jpg\npredict('..\/input\/chest-xray-pneumonia\/chest_xray\/val\/NORMAL\/NORMAL2-IM-1436-0001.jpeg')\n\n# patas_monkey\n# !wget -q https:\/\/sambadenglish.com\/wp-content\/uploads\/2019\/05\/Nilgiri-langur-1024x683.jpg\npredict('..\/input\/chest-xray-pneumonia\/chest_xray\/val\/PNEUMONIA\/person1947_bacteria_4876.jpeg')\n\n\n# call the function\n\n# defining parameters to pass to function\ni=random.randrange(1,10) # image number 12. You may change value of i for play around\nplt.figure(figsize=(6,3))\nplt.subplot(1,2,1)\n# we are passing \"val_images_Original\" just to show original image instead of \"val_images\" \n# which is preprocessed as VGG16 process and used for prediction.\nplot_image(i,val_predictions, val_image_label, val_images_Original) \nplt.subplot(1,2,2)\nplot_value_array(i, val_predictions, val_image_label)\nplt.show()","59726a1f":"# Prediction on Test images\n\n# Declaring variables\nnum_rows=4\nnum_cols=4\nnum_images=num_rows*num_cols\n\nplt.figure(figsize=(2*2*num_cols,2*num_rows))\n\nprint(\"Classification of Test Chest X-ray into Normal and Pneumonia using Transfer Learning (VGG16)\\n\")\nprint(\"Predicted Diagnose, Percentage, (Original Diagnose)\\n\")\n\nfor i in range(num_images):\n    plt.subplot(num_rows, 2*num_cols, 2*i+1)\n#     ii=random.randrange(1,227)\n    # we are passing \"val_images_Original\" just to show original image instead of \"val_images\" \n    # which is preprocessed as VGG16 process and used for prediction.\n    indexer=random.randrange(1,624)\n    plot_image(indexer,test_predictions, test_image_label, test_images_Original)\n    \n    plt.subplot(num_rows, 2*num_cols, 2*i+2)\n\n    plot_value_array(indexer, test_predictions, test_image_label)\nplt.subplots_adjust(hspace=0.5)\nplt.show()","f0ec37c1":"# Prediction on Validation images\n\n# Declaring variables\nnum_rows=4\nnum_cols=4\nnum_images=num_rows*num_cols\n\nplt.figure(figsize=(2*2*num_cols,2*num_rows))\n\nprint(\"Classification of Chest X-ray into Normal and Pneumonia using Transfer Learning (VGG16)\\n\")\nprint(\"Predicted Species, Percentage, (Original Species)\\n\")\n\nfor i in range(num_images):\n    plt.subplot(num_rows, 2*num_cols, 2*i+1)\n#     ii=random.randrange(1,227)\n    # we are passing \"val_images_Original\" just to show original image instead of \"val_images\" \n    # which is preprocessed as VGG16 process and used for prediction.\n    plot_image(i,val_predictions, val_image_label, val_images_Original)\n    \n    plt.subplot(num_rows, 2*num_cols, 2*i+2)\n\n    plot_value_array(i, val_predictions, val_image_label)\nplt.subplots_adjust(hspace=0.5)\nplt.show()","9927431e":"print(\"Future tasks: 1. Image distribution correction 2. Creating confusion matrix and 3. Looking for F1 score\\n\")\n\nprint(\"Notebook completed.\")","3cb9a9b5":"# 5. Building a Model: Using Transfer Learning - VGG16 model\n\nTransfer learning (TL) is a research problem in machine learning (ML) that focuses on storing knowledge gained while solving one problem and applying it to a different but related problem. For example, knowledge gained while learning to recognize cars could apply when trying to recognize trucks. (Source: https:\/\/en.wikipedia.org\/wiki\/Transfer_learning)\n\nTransfer learning is a machine learning method where a model developed for a task is reused as the starting point for a model on a second task which is related to original task.\n\nIt is quite popular in deep learning where pre-trained models are used as the starting point on Computer Vision (CV) and Natural Language Processing (NLP) tasks. This is very helpful approach as it saves lots of time, resoureses. This way one can avail benefit of using complex models developed by others as start point and on top of it develop another.","d3838608":"## Functions","40937974":"### Preparing Traning Image Data","2e37623c":"## Importing libraries","dd3e53d9":"# 2. Data Gethering","32057cb9":"# 10. Predictions","80eead54":"# 9. Model Evaluation","0afd591f":"## Plotting raw images","11064533":"# 7. Compile the Model","e5e8d931":"## Custom use VGG16 model (set input layer, remove last (top) layer)","4923f9cd":"## Visualization","fbfd753a":"# 6. Train the Model","238d39db":"# Another approach: Use ImageDataGenerator (we are NOT using this)","44ba1b0d":"## Preparing data for visualization","8b99c947":" # Chest X-ray Image Classification using Transfer Learning - VGG16\n \n**What is Pneumonia**\n\n**Pneumonia** is such an infection that is caused in one or both the lungs. This is caused due to viruses, fungi, etc. This results in inflammation in air sacs in the lungs by which it becomes difficult to breathe. In this experiment, we will explore how to build a classification model by which we can classify whether a person has pneumonia or not through CXR (Chest X-Ray) images. We will be building the model using pre-trained model Vgg19. For this experiment, we will make use of Pneumonia Chest X Rays data that is publicly available on Kaggle. \n\nI have used 2 class classification dataset (https:\/\/www.kaggle.com\/paultimothymooney\/chest-xray-pneumonia) for this experiment. My whole heartedly thanks to Mario (https:\/\/www.kaggle.com\/paultimothymooney).\n\n\n[Viratkumar Kothari](https:\/\/www.linkedin.com\/in\/viratkkothari\/)","9c601f25":"# 3. Preparing Data","eebef564":"# 1. Importing Libraries","93260a4f":"## Verify the default VGG16 model","7f7032c1":"**Observation:**\n\n1. The first layer is having image size = (224,224,3) now as we defined.\n1. Also, see the folloiwng 2 top (last) layers which were there in original VGG16 are now not the part of our customized layer because we set include_top=False:\n\nflatten (Flatten)            (None, 25088)             0         \n_________________________________________________________________\nfc1 (Dense)                  (None, 4096)              102764544 \n_________________________________________________________________\nfc2 (Dense)                  (None, 4096)              16781312  \n_________________________________________________________________\npredictions (Dense)          (None, 1000)              4097000   ","08cedbc4":"### Preparing Validation Image Data","0ada68e8":"### Verifying the dataset","6b93f93e":"# 8. Fit the Model","0aa429f5":"## Freeze all the layers except the last which we added","7009b799":"## **Observations:**\n1. We want to carry weights as it was in original model, so we are carring weights = 'imagenet'\n2. The very first layer is input layer which accept image size = (224, 224, 3). Our image size are different, so we need to change the parameter - image_size in the first layer. Our size will be: (224,224, 3)\n3. We want to change the last layer as we have 10 class classificatoin problem. So, we will not include top layer\n4. Also, we will not train all the layers except the last one as we will have to train that. So, we will set properties for trainable = False excet for the top i.e. last layer.","efb8af43":"## Setup last (top) custom layer","72c94b95":"## Declaring variables","8f65f24a":"# 3. Verification of Data"}}