{"cell_type":{"17b7ba1b":"code","8ecc0aad":"code","bfeb0b68":"code","4dd2084e":"code","8dca8119":"code","28addcb8":"code","21330471":"code","e8582de8":"code","6358c1c7":"code","d31b2bba":"code","f493ae6c":"code","1ffebea6":"code","1293817d":"code","3d18f6fc":"code","d599e00e":"code","cd9c6258":"code","1ae8caa5":"code","38752b94":"code","74689b09":"code","839725c7":"code","e419ef73":"code","d22db25f":"code","0baa7e44":"code","a6aea754":"code","0812f101":"code","65851c50":"code","5ea2399e":"code","d3652482":"code","2e4053b2":"code","5d3c5c5c":"code","047362c9":"markdown","0a192ade":"markdown","8e4859a7":"markdown","b7172f7b":"markdown","964ffd5e":"markdown","810cc387":"markdown","eed0c060":"markdown","4f766230":"markdown","3bbf55f4":"markdown","cd291fee":"markdown","599ea4bc":"markdown","e09b9572":"markdown","93112ce7":"markdown","3e543409":"markdown","177f8696":"markdown","68913380":"markdown","e8fb36db":"markdown","ed81a4ef":"markdown","55d36a41":"markdown","72bb8246":"markdown","5e464807":"markdown","8f027f8b":"markdown","1030154a":"markdown","ad40ff9c":"markdown"},"source":{"17b7ba1b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8ecc0aad":"plant1 = pd.read_csv('\/kaggle\/input\/solar-power-generation-data\/Plant_1_Generation_Data.csv')\nplant2 = pd.read_csv('\/kaggle\/input\/solar-power-generation-data\/Plant_2_Generation_Data.csv')\nweather1 = pd.read_csv('\/kaggle\/input\/solar-power-generation-data\/Plant_1_Weather_Sensor_Data.csv')\nweather2 = pd.read_csv('\/kaggle\/input\/solar-power-generation-data\/Plant_2_Weather_Sensor_Data.csv')","bfeb0b68":"plant1.tail()","4dd2084e":"plant2.tail()","8dca8119":"plant1['DATE_TIME'] = pd.to_datetime(plant1['DATE_TIME'], format = '%d-%m-%Y %H:%M')\nweather1['DATE_TIME'] = pd.to_datetime(weather1['DATE_TIME'], format = '%Y-%m-%d %H:%M:%S')\nplant1.columns = plant1.columns.str.lower()\nweather1.columns = weather1.columns.str.lower()\nplant2['DATE_TIME'] = pd.to_datetime(plant2['DATE_TIME'], format = '%Y-%m-%d %H:%M:%S')\nweather2['DATE_TIME'] = pd.to_datetime(weather2['DATE_TIME'], format = '%Y-%m-%d %H:%M:%S')\nplant2.columns = plant2.columns.str.lower()\nweather2.columns = weather2.columns.str.lower()","28addcb8":"print(plant1.head())\nprint(plant2.head())","21330471":"plant1['date'] = plant1['date_time'].dt.date\nplant1['time'] = plant1['date_time'].dt.time\nplant2['date'] = plant2['date_time'].dt.date\nplant2['time'] = plant2['date_time'].dt.time","e8582de8":"dc_plant1 = plant1.groupby('time')['dc_power'].sum()\nac_plant1 = plant1.groupby('time')['ac_power'].sum()\ndc_plant2 = plant2.groupby('time')['dc_power'].sum()\nac_plant2 = plant2.groupby('time')['ac_power'].sum()","6358c1c7":"fig, ax = plt.subplots(1, 2, dpi=100, figsize=(20, 5))\ndc_plant1.plot(ax=ax[0])\ndc_plant2.plot(ax=ax[0])\nac_plant1.plot(ax=ax[1])\nac_plant2.plot(ax=ax[1])\nax[0].legend(['plant1', 'plant2'])\nax[1].legend(['plant1', 'plant2'])\nax[0].set_title('DC Power')\nax[1].set_title('AC Power')\nplt.show()","d31b2bba":"loss_p1 = plant1.copy()\nloss_p2 = plant2.copy()\nloss_p1 = loss_p1.groupby('date').sum()\nloss_p1['losses'] = loss_p1['ac_power'] \/ loss_p1['dc_power'] * 100\nloss_p2 = loss_p2.groupby('date').sum()\nloss_p2['losses'] = loss_p2['ac_power'] \/ loss_p2['dc_power'] * 100\n\n#Plot the losses\nfig, ax = plt.subplots(2, 1, sharex = True, dpi=100, figsize=(13,7))\nloss_p1['losses'].plot(style='o--', ax=ax[0])\nloss_p2['losses'].plot(style='o--', ax=ax[1])\nax[0].set_title('Percentage of DC Power converted into AC Power for Plant 1')\nax[1].set_title('Percentage of DC Power converted into AC Power for Plant 2')\nplt.xticks(rotation=45)\nplt.show()","f493ae6c":"unique_keyes = set(plant1['source_key'])\ntotal_dc_power_p1 = {}\nfor key in unique_keyes:\n    dc_power = plant1[plant1['source_key'] == key]['total_yield'].iloc[-1] - plant1[plant1['source_key'] == key]['total_yield'].iloc[0]\n    total_dc_power_p1[key] = dc_power\nprint(total_dc_power_p1)\nfig, ax = plt.subplots(figsize = (17, 5))\nax.plot(list(total_dc_power_p1.values()), marker = '^', linestyle = '-.')\nax.set(xlabel = 'Source', ylabel='kW', title='Total yielded power by different solar battery for plant 1')\nplt.xticks(range(0, 22), list(total_dc_power_p1.keys()), rotation = 90)\nplt.show()","1ffebea6":"unique_keyes2 = set(plant2['source_key'])\ntotal_dc_power_p2 = {}\nfor key in unique_keyes2:\n    dc_power = plant2[plant2['source_key'] == key]['total_yield'].iloc[-1] - plant2[plant2['source_key'] == key]['total_yield'].iloc[0]\n    total_dc_power_p2[key] = dc_power\nprint(total_dc_power_p2)\nfig, ax = plt.subplots(figsize = (17, 5))\nax.plot(list(total_dc_power_p2.values()), marker = '^', linestyle = '-.')\nax.set(xlabel = 'Source', ylabel='kW', title='Total yielded power by different solar battery for plant 2')\nplt.xticks(range(0, 22), list(total_dc_power_p2.keys()), rotation = 90)\nplt.show()","1293817d":"worst_inverter_p1 = plant1[plant1['source_key'] == 'bvBOhCH3iADSZry'].reset_index(drop=True)\n\nax=worst_inverter_p1.groupby(['time', 'date'])['dc_power'].mean().unstack().plot(sharex=True,subplots=True,layout=(17,2),figsize=(20,30))\nworst_inverter_p1.groupby(['time', 'date'])['daily_yield'].mean().unstack().plot(sharex=True,subplots=True,layout=(17,2),figsize=(20,30),ax=ax,style='-.')\ncols=worst_inverter_p1.groupby(['time', 'date'])['dc_power'].mean().unstack().columns\na=0\nfor i in range(len(ax)):\n    for j in range(len(ax[i])):\n        ax[i,j].set_title(cols[a], size=15)\n        ax[i,j].legend(['dc_power','daily_yield'])\n        a=a+1\nplt.tight_layout()\nplt.show()","3d18f6fc":"best_inverter_p1 = plant1[plant1['source_key'] == 'adLQvlD726eNBSB'].reset_index(drop=True)\n\nax=best_inverter_p1.groupby(['time', 'date'])['dc_power'].mean().unstack().plot(sharex=True,subplots=True,layout=(17,2),figsize=(20,30))\nbest_inverter_p1.groupby(['time', 'date'])['daily_yield'].mean().unstack().plot(sharex=True,subplots=True,layout=(17,2),figsize=(20,30),ax=ax,style='-.')\ncols=best_inverter_p1.groupby(['time', 'date'])['dc_power'].mean().unstack().columns\na=0\nfor i in range(len(ax)):\n    for j in range(len(ax[i])):\n        ax[i,j].set_title(cols[a], size=15)\n        ax[i,j].legend(['dc_power','daily_yield'])\n        a=a+1\nplt.tight_layout()\nplt.show()","d599e00e":"worst_inverter_p2 = plant2[plant2['source_key'] == 'Quc1TzYxW2pYoWX'].reset_index(drop=True)\n\nax=worst_inverter_p2.groupby(['time', 'date'])['dc_power'].mean().unstack().plot(sharex=True,subplots=True,layout=(17,2),figsize=(20,30))\nworst_inverter_p2.groupby(['time', 'date'])['daily_yield'].mean().unstack().plot(sharex=True,subplots=True,layout=(17,2),figsize=(20,30),ax=ax,style='-.')\ncols=worst_inverter_p2.groupby(['time', 'date'])['dc_power'].mean().unstack().columns\na=0\nfor i in range(len(ax)):\n    for j in range(len(ax[i])):\n        ax[i,j].set_title(cols[a], size=15)\n        ax[i,j].legend(['dc_power','daily_yield'])\n        a=a+1\nplt.tight_layout()\nplt.show()","cd9c6258":"df_plant1 = plant1.merge(weather1, on='date_time', suffixes=['', '_w'])\ndf_plant1['hour'] = df_plant1['date_time'].dt.hour\ndf_plant1 = df_plant1.drop(['source_key_w', 'plant_id', 'plant_id_w', 'date', 'time', 'date_time'], axis = 1)\ndf_to_corr = df_plant1.drop('source_key', axis=1)\ndf_to_corr.corr()","1ae8caa5":"from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor\nfrom sklearn.metrics import mean_absolute_error, r2_score\nfrom sklearn.preprocessing import OneHotEncoder, LabelEncoder","38752b94":"df1 = plant1.merge(weather1, on='date_time', suffixes=['', '_w'])\ncolumns_to_drop = ['date_time', 'date', 'time', 'dc_power', 'daily_yield', 'total_yield', 'module_temperature', 'irradiation', 'source_key_w', 'plant_id', 'plant_id_w']\ndf_p1 = df1.drop(columns_to_drop, axis=1)\ndf_p1['hour'] = df1['date_time'].dt.hour","74689b09":"values = np.array(df_p1['source_key'])\n#Encoding\nlabel_enc = LabelEncoder()\ninteger_enc = label_enc.fit_transform(values)\nonehot_enc = OneHotEncoder(sparse=False)\nenc_keys = onehot_enc.fit_transform(integer_enc.reshape(-1, 1))\nenc_keys_df = pd.DataFrame(enc_keys)\n# Create dictionary with categories of encoded feature, to use them in plotting\nkeys = label_enc.classes_\nvalues = label_enc.transform(label_enc.classes_)\ndictionary = dict(zip(values, keys))","839725c7":"df_p1 = pd.concat([df_p1, enc_keys_df], axis=1).drop('source_key', axis=1)\ndf_p1.head()","e419ef73":"train_columns = df_p1.columns[1:]\nX_train = df_p1[df1['date_time'] < '2020-06-16'][train_columns].reset_index().drop('index', axis=1)\nX_test = df_p1[df1['date_time'] < '2020-06-16']['ac_power'].reset_index().drop('index', axis=1)\ny_test = df_p1[df1['date_time'] >= '2020-06-16']['ac_power'].reset_index().drop('index', axis=1)\ny_train = df_p1[df1['date_time'] >= '2020-06-16'][train_columns].reset_index().drop('index', axis=1)","d22db25f":"reg = RandomForestRegressor()\nreg.fit(X_train, X_test)\ny_pred_rf = reg.predict(y_train)\nprint(mean_absolute_error(y_pred_rf, y_test))\nprint(r2_score(y_pred_rf, y_test))","0baa7e44":"gbr = GradientBoostingRegressor(learning_rate = 0.05, n_estimators=200)\ngbr.fit(X_train, X_test)\ny_pred = gbr.predict(y_train)\nprint(mean_absolute_error(y_pred, y_test))\nprint(r2_score(y_pred, y_test))","a6aea754":"fig = plt.figure(figsize=(20, 20))\nfig.subplots_adjust(wspace=0.2, hspace=0.6)\nfor i in range(0, 22):\n    ax = fig.add_subplot(6, 4, i+1)\n    index = df1[(df1['source_key'] == dictionary[i])&(df1['date_time'] >= pd.to_datetime('2020-06-16'))]['date_time'] # just for index\n    ax.plot(pd.DataFrame(y_test[y_train[y_train.columns[i+2]] == 1]).set_index(index))\n    ax.plot(pd.DataFrame(y_pred[y_train[y_train.columns[i+2]] == 1]).set_index(index), color='darkorange')\n    ax.set_title('\"{}\" source, Plant 1'.format(dictionary[i]))\n    ax.legend(['real', 'predicted'])\n    plt.xticks(rotation = 45)","0812f101":"df2 = plant2.merge(weather2, on='date_time', suffixes=['', '_w'])\ncolumns_to_drop = ['date_time', 'date', 'time', 'dc_power', 'daily_yield', 'total_yield', 'module_temperature', 'irradiation', 'source_key_w', 'plant_id', 'plant_id_w']\ndf_p2 = df2.drop(columns_to_drop, axis=1)\ndf_p2['hour'] = df2['date_time'].dt.hour","65851c50":"values = np.array(df_p2['source_key'])\n\n#Encoding\n\nlabel_enc = LabelEncoder()\ninteger_enc = label_enc.fit_transform(values)\nonehot_enc = OneHotEncoder(sparse=False)\nenc_keys = onehot_enc.fit_transform(integer_enc.reshape(-1, 1))\nenc_keys_df = pd.DataFrame(enc_keys)\n\n# Create dictionary with categories of encoded feature, to use them in plotting\n\nkeys = label_enc.classes_\nvalues = label_enc.transform(label_enc.classes_)\ndictionary = dict(zip(values, keys))","5ea2399e":"df_p2 = pd.concat([df_p2, enc_keys_df], axis=1).drop('source_key', axis=1)\ndf_p2.head()","d3652482":"train_columns = df_p2.columns[1:]\nX_train2 = df_p2[df2['date_time'] < '2020-06-16'][train_columns].reset_index(drop=True)\nX_test2 = df_p2[df2['date_time'] < '2020-06-16']['ac_power'].reset_index(drop=True)\ny_test2 = df_p2[df2['date_time'] >= '2020-06-16']['ac_power'].reset_index(drop=True)\ny_train2 = df_p2[df2['date_time'] >= '2020-06-16'][train_columns].reset_index(drop=True)","2e4053b2":"gbr = GradientBoostingRegressor(learning_rate = 0.05, n_estimators=200)\ngbr.fit(X_train2, X_test2)\ny_pred2 = gbr.predict(y_train2)\nprint(mean_absolute_error(y_pred2, y_test2))\nprint(r2_score(y_pred2, y_test2))","5d3c5c5c":"fig = plt.figure(figsize=(20, 20))\nfig.subplots_adjust(wspace=0.2, hspace=0.6)\nfor i in range(0, 22):\n    ax = fig.add_subplot(6, 4, i+1)\n    index = df2[(df2['source_key'] == dictionary[i])&(df2['date_time'] >= pd.to_datetime('2020-06-16'))]['date_time'] # just for index\n    ax.plot(pd.DataFrame(y_test2[y_train2[y_train2.columns[i+2]] == 1]).set_index(index))\n    ax.plot(pd.DataFrame(y_pred2[y_train2[y_train2.columns[i+2]] == 1]).set_index(index), color='darkorange')\n    ax.set_title('\"{}\" source, Plant 2'.format(dictionary[i]))\n    ax.legend(['real', 'predicted'])\n    plt.xticks(rotation = 45)","047362c9":"As we see prediction of our model for Plant 2 is less precise then for Plant 1. I think it might be because of days when particular solar batteries on plant 2 didn't work properly (we saw it in Task 1).\n\nAlso we see that for the most efficient solar batteries (xMbIugepa2P7lBB', 'IQ2d7wF4YD8zU1Q' and 'NgDl19wMapZy17u) our model gives more precise prediction. This is because they worked properly during all time in this period.","0a192ade":"### Step 5. Plot the results","8e4859a7":"In this graphs we see that Plant 1 is accumulating much more DC Power than Plant 2, nevertheless AC Power of Plant 1 and Plant 2 doesn't differ such as DC Power. \nMaybe Plant 1 has some issues with converting DC Power to AC Power.","b7172f7b":"Now lets take a look if all solar batteries are working properly","964ffd5e":"Here we also see some missing data, but the best solar battery at Plant 1 was working properly all the time","810cc387":"In this table we see that power generation is strongly correlated with module temperature and irradiation, and have not so strong correlation with ambient_tempreture (pearson r = 0.725). Also daily yielded power is clearly correlated with the hour of the day.","eed0c060":"# Thanks for reading my work!\n## I am beginner at Data Science so if I did something wrong, please comment it so I can do better next time","4f766230":"# Conclusion\n\n## Task 1:\n\n- We saw that plant 1 accumulate more DC Power but has problems with converting it to AC Power.\n- We saw that not all solar batteries are working properly at Plant 1, as well as at Plant 2. We were able to give suggestions which batteries need to be repaired or replaced\n\n## Task 2:\n\n- We defined 2 models of ML to predict AC Power generation at both Plants\n- GradientBoosting gave us more precise results than Randomforest (MAE and R2 Score were 61 kW and 88.4% respectively\n- We plot predictions and real results for each battery to see patterns of our model.","3bbf55f4":"### Step 2. Encode categorical features (source key)","cd291fee":"Now let's take a look on worst and best solar battery at Plant 1","599ea4bc":"Lets take a look on the correlation of the features\n","e09b9572":"Firstly we take a look on DC and AC power, accumulating by 2 plants","93112ce7":"As we can see on the graphs our model was able to predict AC power quite good. Unless there is a pattern that at June 16 real AC power was less then predicted one.\nI think that might be because of some sort of cloudy weather, when solar engines couldn't get enough sunlight. If we would have another feature of weather type, maybe our model would be more precise\n\nMAE score of our model for Plant 1 - 61 kW, R2 score - 0.88","3e543409":"### Now lets make the same for Plant 2","177f8696":"In these graphs we see that Plant 1 can convert about 9.78 percent of accumulated DC power, when Plant 2 can convert about 97.8 percent of DC Power","68913380":"Here we can see that on June 7th and June 14th there is time that energy by the worst solar battery was not produced at all.\nAlso there are missing data for some hours since May 19th to to May 21st","e8fb36db":"On these graphs we also see that worst inverter at Plant 2 wasn't producing energy during some days. Maybe it is because they were repairing some equipment during that days. If not, that battery should be repaired or replaced","ed81a4ef":"Import data","55d36a41":"In these graphs we see that two solar batteries have less efficiency than others at Plant 1. At Plant 2 there are about 4 batteries that have less efficiency than others.","72bb8246":"# Task 2","5e464807":"### Step 1. Delete and add new features","8f027f8b":"We are going to predict AC Power that have generated each 15 minutes by Plant 1 and 2 on June 16th an 17th.\n\nWe assume that we have precise forecast of ambient temperature, but we don't have other features, so I will delete DC Power, daily yield, total yield, module temperature and irradiation columns. Also I will add hour column, as plant produces energy only since 6 AM to 6 PM.","1030154a":"### Step 3. Split dataset into train and test","ad40ff9c":"### Step 4. Define the model"}}