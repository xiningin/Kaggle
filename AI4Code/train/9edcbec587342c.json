{"cell_type":{"52a1a9f8":"code","02357f94":"code","839aa7bb":"code","1d53c5ae":"code","afe6df96":"code","0f83fb74":"code","6d09ab67":"code","7cb6deb1":"code","93ea4cd7":"code","6883f543":"code","2ef592e0":"code","78c06f4f":"markdown","ae330818":"markdown","65ead706":"markdown","c19c419f":"markdown","a3c65ac1":"markdown","b59e0eda":"markdown","b51fd173":"markdown","2f993177":"markdown"},"source":{"52a1a9f8":"# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","02357f94":"import cv2 as cv\nimport matplotlib.pyplot as plt\n\nfile = \"\/kaggle\/input\/ransac\/moba_HA1_Abb1_Rechteck.bmp\"\nimg = cv.imread(file, cv.IMREAD_GRAYSCALE)\n\nplt.figure(figsize=(20, 20))\nplt.subplot(1, 2, 1)\nplt.title(\"Original\")\nplt.imshow(img)","839aa7bb":"import numpy as np\n\ndef changePictureColor(img):    \n    number_of_white_pix = np.sum(img == 255)      # extracting only white pixels \n    number_of_black_pix = np.sum(img == 0)          # extracting only black pixels \n    \n    # print(\"Number of white pixels: \" + str(number_of_white_pix))\n    # print(\"Number of black pixels: \" + str(number_of_black_pix))\n    \n    #change the color of the picture acording to color of the line\n    if number_of_white_pix > number_of_black_pix:\n        img = cv.bitwise_not(img)\n        print(\"More white than black pixels, did invers the image!\")\n    plt.imshow(img)\n    return img\n\nchangePictureColor(img)","1d53c5ae":"#get the indices of every point in img\ndef countIndices(img):\n    indices = []\n    for y, row in enumerate(img):\n        for x, column in enumerate(row):\n            if column == 255:\n                indices.append(Point(x,y))\n    # print(len(indices))\n    return indices","afe6df96":"def callculateCoefficients(line_start, line_end):    \n    A = line_start.y - line_end.y\n    B = line_end.x - line_start.x\n    C = line_start.x*line_end.y - line_start.y*line_end.x    \n    \n    return Coefficients(A, B, C)\n\n\ndef pointToLineError(line_start, line_end, point):        \n    c = callculateCoefficients(line_start, line_end)\n    \n    try :\n        distance = abs(c.A*point.x + c.B*point.y + c.C)\/(pow(c.A*c.A + c.B*c.B, 0.5))\n        return int(distance)\n    \n    #for debugging\n    except:\n        print(\"Error: These coefficients could not be callculated: \")\n        print(c)\n        print(\"With these points\")\n        print(str(line_start) + str(line_end))","0f83fb74":"def getTotalInliersForLine(start, end, threshold):\n    pointsFound = []\n    numberOfPoints = 0\n    \n    for point in indices:\n        distance = pointToLineError(start, end, point)\n        \n        if distance <= threshold:\n            pointsFound.append(point)\n            numberOfPoints +=1\n    \n    return numberOfPoints","6d09ab67":"def RANSAC(threshold, iterations, img):\n    bestPoints = [{0,0},{0,0}]\n    bestNumberOfInliers = 0\n    \n    numberOfInliers = 0\n    \n    while iterations >= 0: \n        line_start = random.choice(indices)\n        line_end = random.choice(indices)\n        \n        if line_start != line_end:    \n            numberOfInliers = getTotalInliersForLine(line_start, line_end, threshold)\n    \n            if numberOfInliers > bestNumberOfInliers:\n                bestNumberOfInliers = numberOfInliers\n                numberOfInliers = 0\n                bestPoints[0] = line_start\n                bestPoints[1] = line_end\n                print(\"Found new Line!\")\n                print(bestPoints)\n                print(bestNumberOfInliers)\n\n                \n            else:\n                # for debugging\n                # print(str(numberOfInliers) + \" is not bigger than \" + str(bestNumberOfInliers))\n                pass\n        \n        iterations -= 1\n        \n    return[bestNumberOfInliers, callculateCoefficients(bestPoints[0],bestPoints[1])]\n","7cb6deb1":"def drawLongLine(coefficients, indices):\n    A = bestCoefficients.A\n    B = bestCoefficients.B\n    C = bestCoefficients.C\n    \n    allxvalues = [point[0] for point in indices]\n    \n    xvalues = [min(allxvalues), max(allxvalues)]\n    yvalues = [(-C-A*xvalues[0])\/B, (-C-A*xvalues[1])\/B]\n    plt.plot(xvalues, yvalues, color=\"red\")\n    plt.title('Line Fitted through points in 2D using Ransac')\n    plt.show()","93ea4cd7":"from typing import NamedTuple\nimport random\n#create NamedTuple \nclass Coefficients(NamedTuple):\n    A: int\n    B: int\n    C: int\n        \nclass Point(NamedTuple):\n    x: int\n    y: int\n        \nimg = cv.imread(file, cv.IMREAD_GRAYSCALE)\nimg = changePictureColor(img)\nindices = countIndices(img)\n\nbestNumberOfInliers, bestCoefficients = RANSAC(10, 100, img)\ndrawLongLine(bestCoefficients, indices)\nprint(\"inliers count = {0}\".format(bestNumberOfInliers))","6883f543":"file = \"\/kaggle\/input\/ransac\/moba_HA1_Abb2_Scan.bmp\"\nimg = cv.imread(file, cv.IMREAD_GRAYSCALE)\nimg = changePictureColor(img)\nindices = countIndices(img)\n\nbestNumberOfInliers, bestCoefficients = RANSAC(10, 100, img)\ndrawLongLine(bestCoefficients, indices)\nprint(\"inliers count = {0}\".format(bestNumberOfInliers))","2ef592e0":"file = \"\/kaggle\/input\/ransac\/moba_HA1_Abb3_NZroads.jpg\"\nimg = cv.imread(file, cv.IMREAD_GRAYSCALE)\nimg = changePictureColor(img)\nindices = countIndices(img)\n\n# plt.figure(figsize=(20, 20))\n# plt.subplot(1, 2, 1)\n# plt.imshow(img)\n# plt.title(\"Original\")\n# plt.show()\n\nbestNumberOfInliers, bestCoefficients = RANSAC(10, 100, img)\ndrawLongLine(bestCoefficients, indices)\nprint(\"inliers count = {0}\".format(bestNumberOfInliers))","78c06f4f":"\nFarbe des Bildes erkennen","ae330818":"ToDo:\n* X  Jupyter Notebook aufsetzen\n* X  Inversion des Bildes anhand der prozentualen Datenpunkte erstellen.\n* X  Zwei zuf\u00e4llige Punkte ausw\u00e4hlen und Linie auf Bild anzeigen\n* X  Abstand von Punkt zu Linie berechnen\n* 0  Plots sauber darstellen - Vorher \/ Nacher vergleichen\n* 0  \u00c4nderung der Seitenverh\u00e4ltnisse der Plots korrigieren\n\n","65ead706":"*For debugging*","c19c419f":"# **FHNW-MOBA-RANSAC**\n\nQuellen:\n* https:\/\/github.com\/divy-works\/ransac_tutorial\/blob\/master\/ransac_2d.ipynb\n* https:\/\/en.wikipedia.org\/wiki\/Distance_from_a_point_to_a_line\n","a3c65ac1":"Damit man die Linie im Bild besser erkennen kann, bietet die Funktion \"drawLongLine\" die M\u00f6glichkeit, eine Linie mit den durch RANSAC evaluierten Koeffizienten zu berechne. ","b59e0eda":"Sobald man den Abstand eines Punktes zur Geraden berechnen kann, lassen sich alle Punkte des Bildes in \"Inliers\" und \"Outliers\" anhand eines thresholds kategorisieren. Die Anzahl der Inliers ist f\u00fcr die Bestimmung der Geraden essentziell und wird daher aufsummiert.","b51fd173":"Die Funktion \"RANSAC\" ist das Herzst\u00fcck des Codes. Sie bildet eine Gerade aus zwei zuf\u00e4lligen Punkten. Anschliesend wird die Anzahl der Inliers f\u00fcr die Gerade berechnet und mit dem vorherigen Bestwert verglichen. Dies wird eine beliebige Anzal an Interationen wiederholt. ","2f993177":"Mit der Funktion \"callculateCoefficients\" lassen sich die Koeffizienten der Geraden aus zwei Punkten berechnen. Anschliessend wird die Distanz eine zuf\u00e4lligen Punktes zur Geraden mit \"pointToLineError\" berechnet. "}}