{"cell_type":{"d579cabe":"code","0d1d4836":"code","79c4eb0e":"code","ceb47103":"code","15b63cbf":"code","ad835d4d":"code","3a22ff23":"code","bbe09aa5":"code","00c8a177":"code","c8da9b02":"code","ebc3fc8f":"code","b1eae327":"code","912716e5":"code","935b6fda":"code","c395ae8c":"code","5ea4fd00":"code","eeeeb952":"code","dce28782":"code","66eb9e7b":"code","922fd591":"markdown","3372a078":"markdown","c906b786":"markdown","ac16a809":"markdown","38fb397c":"markdown","89992bf3":"markdown","6d01bd65":"markdown","3a349fa8":"markdown","bee7d1e6":"markdown","a314402b":"markdown","c2c24132":"markdown","916edab5":"markdown","d349a7fb":"markdown","31918e3c":"markdown","8c42d214":"markdown","130c7631":"markdown","6990747f":"markdown","5c60bc04":"markdown","2e969238":"markdown","214a40bb":"markdown","5c7cb43c":"markdown","e89a14e2":"markdown","7d54427d":"markdown","9c139301":"markdown","91042b3b":"markdown","6c2ca257":"markdown","d08b6b74":"markdown","3f3d7669":"markdown","ee321f5d":"markdown","3f067064":"markdown","40b49b63":"markdown","73a01eda":"markdown","ec0f2257":"markdown","91578563":"markdown","818f450a":"markdown","2f0fcd5e":"markdown","45a54a35":"markdown","aaf8feb7":"markdown","53893a67":"markdown","600e0bbd":"markdown","1a2a5bb8":"markdown","e85c3f89":"markdown","560d0747":"markdown","403dabb7":"markdown","63705903":"markdown","afa2124c":"markdown","ffd5c376":"markdown","2a445a5c":"markdown","34d633e6":"markdown","7a75c097":"markdown","4ef3af04":"markdown"},"source":{"d579cabe":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5GoalHeaderImage.png\")","0d1d4836":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5Eqn5_1.png\")","79c4eb0e":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5Eqn5_2.png\")","ceb47103":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5Eqn5_3.png\")","15b63cbf":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5Eqn5_4.png\")","ad835d4d":"#function obtains maximal return portfolio using linear programming\n\ndef MaximizeReturns(MeanReturns, PortfolioSize):\n    \n    #dependencies\n    from scipy.optimize import linprog\n    import numpy as np\n    \n    c = (np.multiply(-1, MeanReturns))\n    A = np.ones([PortfolioSize,1]).T\n    b=[1]\n    res = linprog(c, A_ub = A, b_ub = b, bounds = (0,1), method = 'simplex') \n    \n    return res","3a22ff23":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5Eqn5_5.png\")","bbe09aa5":"#function obtains minimal risk portfolio \n\n#dependencies\nimport numpy as np\nfrom scipy import optimize \n\ndef MinimizeRisk(CovarReturns, PortfolioSize):\n    \n    def  f(x, CovarReturns):\n        func = np.matmul(np.matmul(x, CovarReturns), x.T) \n        return func\n\n    def constraintEq(x):\n        A=np.ones(x.shape)\n        b=1\n        constraintVal = np.matmul(A,x.T)-b \n        return constraintVal\n    \n    xinit=np.repeat(0.1, PortfolioSize)\n    cons = ({'type': 'eq', 'fun':constraintEq})\n    lb = 0\n    ub = 1\n    bnds = tuple([(lb,ub) for x in xinit])\n\n    opt = optimize.minimize (f, x0 = xinit, args = (CovarReturns),  bounds = bnds, \\\n                             constraints = cons, tol = 10**-3)\n    \n    return opt\n    ","00c8a177":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5Eqn5_6.png\")","c8da9b02":"#function obtains Minimal risk and Maximum return portfolios\n\n#dependencies\nimport numpy as np\nfrom scipy import optimize \n\ndef MinimizeRiskConstr(MeanReturns, CovarReturns, PortfolioSize, R):\n    \n    def  f(x,CovarReturns):\n         \n        func = np.matmul(np.matmul(x,CovarReturns ), x.T)\n        return func\n\n    def constraintEq(x):\n        AEq=np.ones(x.shape)\n        bEq=1\n        EqconstraintVal = np.matmul(AEq,x.T)-bEq \n        return EqconstraintVal\n    \n    def constraintIneq(x, MeanReturns, R):\n        AIneq = np.array(MeanReturns)\n        bIneq = R\n        IneqconstraintVal = np.matmul(AIneq,x.T) - bIneq\n        return IneqconstraintVal\n    \n\n    xinit=np.repeat(0.1, PortfolioSize)\n    cons = ({'type': 'eq', 'fun':constraintEq},\n            {'type':'ineq', 'fun':constraintIneq, 'args':(MeanReturns,R) })\n    lb = 0\n    ub = 1\n    bnds = tuple([(lb,ub) for x in xinit])\n\n    opt = optimize.minimize (f, args = (CovarReturns), method ='trust-constr',  \\\n                        x0 = xinit,   bounds = bnds, constraints = cons, tol = 10**-3)\n    \n    return  opt\n    \n","ebc3fc8f":"# function computes asset returns \ndef StockReturnsComputing(StockPrice, Rows, Columns):\n    \n    import numpy as np\n    \n    StockReturn = np.zeros([Rows-1, Columns])\n    for j in range(Columns):        # j: Assets\n        for i in range(Rows-1):     # i: Daily Prices\n            StockReturn[i,j]=((StockPrice[i+1, j]-StockPrice[i,j])\/StockPrice[i,j])* 100\n\n    return StockReturn","b1eae327":"# Obtain optimal portfolio sets that maximize return and minimize risk\n\n#Dependencies\nimport numpy as np\nimport pandas as pd\n\n\n#input k-portfolio 1 dataset comprising 15 stocks\nStockFileName = '\/kaggle\/input\/mean-variance-optimization-of-portfolios\/DJIA_Apr112014_Apr112019_kpf1.csv'\n\nRows = 1259  #excluding header\nColumns = 15  #excluding date\nportfolioSize = Columns #set portfolio size\n\n#read stock prices in a dataframe\ndf = pd.read_csv(StockFileName,  nrows= Rows)\n\n#extract asset labels\nassetLabels = df.columns[1:Columns+1].tolist()\nprint(assetLabels)\n\n#extract asset prices\nStockData = df.iloc[0:, 1:]\n\n\n#compute asset returns\narStockPrices = np.asarray(StockData)\n[Rows, Cols]=arStockPrices.shape\narReturns = StockReturnsComputing(arStockPrices, Rows, Cols)\n\n\n#compute mean returns and variance covariance matrix of returns\nmeanReturns = np.mean(arReturns, axis = 0)\ncovReturns = np.cov(arReturns, rowvar=False)\n\n#set precision for printing results\nnp.set_printoptions(precision=3, suppress = True)\n\n#display mean returns and variance-covariance matrix of returns\nprint('Mean returns of assets in k-portfolio 1\\n', meanReturns)\nprint('Variance-Covariance matrix of returns\\n', covReturns)\n","912716e5":"#Maximal expected portfolio return computation for the k-portfolio\nresult1 = MaximizeReturns(meanReturns, portfolioSize)\nmaxReturnWeights = result1.x\nmaxExpPortfolioReturn = np.matmul(meanReturns.T, maxReturnWeights)\nprint(\"Maximal Expected Portfolio Return:   %7.4f\" % maxExpPortfolioReturn )\n","935b6fda":"#expected portfolio return computation for the minimum risk k-portfolio \nresult2 = MinimizeRisk(covReturns, portfolioSize)\nminRiskWeights = result2.x\nminRiskExpPortfolioReturn = np.matmul(meanReturns.T, minRiskWeights)\nprint(\"Expected Return of Minimum Risk Portfolio:  %7.4f\" % minRiskExpPortfolioReturn)\n","c395ae8c":"#compute efficient set for the maximum return and minimum risk portfolios\nincrement = 0.001\nlow = minRiskExpPortfolioReturn\nhigh = maxExpPortfolioReturn\n\n#initialize optimal weight set and risk-return point set\nxOptimal =[]\nminRiskPoint = []\nexpPortfolioReturnPoint =[]\n\n#repeated execution of function MinimizeRiskConstr to determine the efficient set \nwhile (low < high):\n    \n    result3 = MinimizeRiskConstr(meanReturns, covReturns, portfolioSize, low)\n    xOptimal.append(result3.x)\n    expPortfolioReturnPoint.append(low)\n    low = low+increment\n    \n#gather optimal weight set    \nxOptimalArray = np.array(xOptimal)\n\n#obtain annualized risk for the efficient set portfolios \n#for trading days = 251\nminRiskPoint = np.diagonal(np.matmul((np.matmul(xOptimalArray,covReturns)),\\\n                                     np.transpose(xOptimalArray)))\nriskPoint =   np.sqrt(minRiskPoint*251) \n\n#obtain expected portfolio annualized return for the \n#efficient set portfolios, for trading days = 251\nretPoint = 251*np.array(expPortfolioReturnPoint) \n\n#display efficient set portfolio parameters\nprint(\"Size of the  efficient set:\", xOptimalArray.shape )\nprint(\"Optimal weights of the efficient set portfolios: \\n\", xOptimalArray)\nprint(\"Annualized Risk and Return of the efficient set portfolios: \\n\", \\\n                                                np.c_[riskPoint, retPoint])","5ea4fd00":"#Graph Efficient Frontier\nimport matplotlib.pyplot as plt\n\nNoPoints = riskPoint.size\n\ncolours = \"blue\"\narea = np.pi*3\n\nplt.title('Efficient Frontier for k-portfolio 1 of Dow stocks')\nplt.xlabel('Annualized Risk(%)')\nplt.ylabel('Annualized Expected Portfolio Return(%)' )\nplt.scatter(riskPoint, retPoint, s=area, c=colours, alpha =0.5)\nplt.show()\n\n","eeeeb952":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5Fig5_1.png\")\n","dce28782":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5Fig5_2.png\")\n","66eb9e7b":"from IPython.display import Image\nImage(\"\/kaggle\/input\/mean-variance-optimization-of-portfolios\/Lesson5ExitTailImage.png\")","922fd591":"**Lesson 6: Sharpe Ratio based Portfolio Optimization**   \n\n(Goal: If a portfolio with higher Sharpe Ratio than its counterparts, is considered superior to them, then how does one invest in the assets of the portfolio, to ensure maximal Sharpe Ratio?)  \n  \nKaggle Kernel: Sharpe Ratio Based Portfolio Optimization","3372a078":"## 5.3 Solving the MVO Model","c906b786":"### Companion Reading","ac16a809":"The mathematical model for this sub-problem is given by","38fb397c":"The Mean-Variance Optimization model is given by:","89992bf3":"## Lesson 5\n","6d01bd65":"### 5.3.3   Obtaining the Optimal Weights  for Minimum Risk and  Maximum Return Portfolios","3a349fa8":"#### Fig. 5.2 Performance Comparison of efficient frontiers of $k$-portfolios with the \"ideal\" efficient frontier,  for DJIA Index (April 2014-Aprl 2019)","bee7d1e6":"## 5.3  Case Study","a314402b":"* **Python for Portfolio Optimization: The Ascent!**\n\nFirst working lessons to ascend the hilly terrain of Portfolio Optimization in seven strides (Lessons), beginning with the fundamentals (Lesson 1) and climbing slope after slope (Lessons 2-6), to reach the first peak of constrained portfolio optimization models (Lesson 7), amongst a range of peaks waiting beyond!\n\n* **Lesson 1 Fundamentals of Risk and Return of a Portfolio**    \n\n* **Lesson 2 Some Glimpses of Financial Data Wrangling**   \n\n* **Lesson 3 Heuristic Portfolio Selection**  \n\n* **Lesson 4 Traditional Methods for Portfolio Construction**\n","c2c24132":"The efficient frontier for a portfolio serves to provide a road-map for the choices that investors can make,  based on their risk appetites.  \n  \nFor a specific annualized risk (x%) or a range of values desired by the investor,  the corresponding annualized expected portfolio return (y%) or a range of return values or vice-versa,  can be easily obtained by a visual inspection of the graph.   The point(s) of intersection on the efficient frontier which represent(s) the optimal portfolios,  can be easily decoded to arrive at the optimal weights which determine the optimal allocations of capital to the assets in the portfolio, corresponding to the choice of risk or return.   \n\nFig. 5.1 illustrates how an efficient frontier can direct a risk-seeking investor who desires an annualized expected return of 20%,  to invest in a portfolio that holds a 14% annualized risk, while enlightening the investor on the optimal weights which will ensure the aspired risk\/return.  ","916edab5":"#### Fig. 5.1 Usefulness of efficient frontiers to investors - an illustration","d349a7fb":"<h5 align=\"right\">.............................(5.4)<\/h5>","31918e3c":"The efficient set comprises 64 different optimal portfolios. Each of the optimal weight sets can be seen to satisfy all the constraints imposed on them. The optimal weight sets and the annualized risk(%) and return (%) of each of the optimal portfolios,  are now available to the investor for making prudent decisions on the portfolios.  \n\nTo get back to the investor's objective, if a risk seeking investor aspires to get an annual return of *y*% mindless of the risk involved, then the efficient set allows selecting that portfolio whose risk-return point is [x%, y%] for some x% risk. The corresponding optimal weight set indicates how the investor should apportion the capital on the various assets comprising the $k$-portfolio, to reap the return desired.  \n\nIn contrast, a risk-averse investor who is too concerned about the risk and hence fixes a risk of x%,  can also get to know about the corresponding return (y%) that the portfolio will fetch for that risk, besides knowing about the  optimal weights that are  required for making such an investment.   \n  \n The efficient set therefore provides a gamut of optimal investment decisions to suit the investor's risk appetite.   \n\n**Example**  \n\nTo keep it simple, let us consider a risk averse investor who desires to invest in the aforementioned $k$-portfolio of Dow stocks, with the lowest risk possible.  The efficient set lists the pair [11.571  9.049]  which is the first pair in the efficient set output, offering the lowest annualized risk of 11.571%. If the investor agrees to this risk, then the investor can expect an   annual return of 9.049%. The optimal weights that will effect this are as follows:\n   [0.028  0.039  0.023  0.017  0.026  0.103  0.017  0.05   0.032  0.021\n   0.319  0.192  0.062  0.047  0.025].   \n   \nTo elaborate further, if the investor owns a capital of USD10000,  to gain an annual expected return of 9.049% holding an annualized risk of 11.571%, the investor will have to allot  the capital to the assets in the $k$-portfolio, in the following manner:\n   \n['AAPL', 2.8%],  ['AXP', 3.9%],   ['BA', 2.3%],  ['CAT', 1.7%],  ['CSCO', 2.6%],  ['DIS', 10.3%],   ['GS', 1.7%],    ['HD', 5%],  ['IBM', 3.2%],  ['JPM', 2.1%],  ['KO', 31.9%],    ['MCD', 19.2%],  ['MRK', 6.2%], ['UNH', 4.7%],  ['WBA', 2.5%]","8c42d214":"The efficient frontiers traced by the Mean-Variance Optimization model or known as the Markowitz model,  are termed as \u201cexact\u201d or \u201cideal\u201d in the literature. The Markowitz model merely deals with basic constraints imposed over a bi-criterion objective function. The model can be easily solved using a variety of traditional methods including the one discussed in this lesson.  \n\nIn reality, portfolio optimization problem models can turn too complex for direct solving by traditional methods. Thus when constraints reflective of investor preferences or  investment strategies or  market norms or religious laws etc.,  are included,  the problem models can turn complex,  warranting the need to look for non-traditional, nature-inspired  methods, referred to as **metaheuristics** in recent literature, to arrive at acceptable if not accurate solutions.  In the face of these models, a Markowitz model is often dubbed as an \u201cUnconstrained Optimization\u201d problem for it can be easily solved with the simplest of the traditional techniques.","130c7631":"The Python function **MinimizeRiskConstr** employs scipy and NumPy to obtain the optimal weight sets. Functions <b>f<\/b>, **constraintEq** and **constraintIneq** describe the objective function, equality constraint and inequality constraint of (5.6). Function **optimize.minimize** uses the Trust-Region Constrained algorithm (**method = 'trust-constr'**) to solve the constrained optimization problem with both equality and inequality constraints.   ","6990747f":"We briefly recall the return and risk of a portfolio that was discussed in **Lesson 1 Fundamentals of risk and return of a portfolio**.     \n","5c60bc04":"where $\\sigma_{i,j}$ is the variance-covariance matrix of returns. ","2e969238":"<h5 align=\"right\">..............................(5.3)<\/h5>","214a40bb":"The model works on two **objective functions**,  \n(i)  **to maximize expected portfolio return** and   \n(ii) **to minimize risk of the portfolio**   \nIt therefore aims to solve a **non-linear bi-objective optimization problem**.     \n\nThe MVO model incorporates the **basic constraints** of   \n(i) **the sum of the weights equals 1.**   \n    This means that  the investor's capital is fully invested in the portfolio and in such a case,  the portfolio is termed as a **fully invested portfolio**.   \n(ii) **the weights $W_i$ lie between 0 and 1.**   \nThis means that either no capital may be allotted for investment in an asset ($W_i = 0$) or the entire capital may be invested in  an asset ($W_i = 1$) or the capital may be apportioned between assets in the porfolio for weights that range between the interval (0,1).  ","5c7cb43c":"## Next...","e89a14e2":"<h5 align=\"right\">.............................(5.1)<\/h5>","7d54427d":"<h3 align=\"left\">References<\/h3>   \n\n[MAR 52]   Markowitz H., Portfolio Selection, *The Journal of Finance*, vol. 7, no. 1, \n           pp. 77-91, Mar., 1952.  \n  \n  \n[PAI 18]   Vijayalakshmi Pai G. A., Metaheuristics for Portfolio Optimization- *An Introduction using MATLAB*, Wiley-ISTE, 2018. https:\/\/www.mathworks.com\/academia\/books\/metaheuristics-for-portfolio-optimization-pai.html  \n  \n**GitHub Repository**    \n\nPythonFinance-PortfolioOptimization https:\/\/github.com\/PaiViji\n","9c139301":"## 5.4  Efficient Frontier","91042b3b":"### 5.3.2  Obtaining the Optimal Expected Return of a Minimum Risk Portfolio","6c2ca257":"In the third stage, the mathematical model discussed in Sec. 5.3.3 is applied,  employing function **MinimizeRiskConstr**. The following Python code shows the repeated invocation of the function controlled by a **while** loop that varies from **low** to **high** in steps of **increment = 0.001**. Here **low** and **high** denote $R^{MinRisk}$ and $R^{MaxReturn}$ respectively. The loop therefore executes (5.6) repeatedly varying R as defined by $R^{MinRisk} \\le R \\le R^{MaxRetrn}$.   ","d08b6b74":"**Lesson 3 Heuristic Portfolio Selection** discussed three different selections of $k$-portfolios comprising Dow stocks. Labelled as $k$-portfolio 1, 2 and 3, the behaviour of these portfolios were compared with  that of an \"ideal\" portfolio where the investor decides to invest in all the stocks of the \"mini-universe\". The observations discussed in Sec. 4.4 of **Lesson 4 Traditional Methods for Portfolio Construction** showed that $k$-portfolios were endowed with merits that rendered them advantageous to the investors.   \n  \n In this lesson, we investigate the  risk-return trade-off behaviour of the $k$-portfolios, by tracing their efficient frontiers and comparing the same with that of the  \"ideal\" portfolio. The Mean-Variance Optimization model was applied over all the portfolios. Fig. 5.2 illustrates the efficient frontiers traced for $k$-portfolio 1, $k$-portfolio 2, $k$-portfolio 3 and the \"ideal\" portfolio, over the DJIA Index data set (April 2014 - April 2019).  \n   \nThe CSV files DJIA_Apr112014_Apr112019_kpf1.csv, DJIA_Apr112014_Apr112019_kpf2.csv, DJIA_Apr112014_Apr112019_kpf3.csv hold the datasets for the respective $k$-portfolios 1,2 and 3, and DJIA_Apr112014_Apr112019.csv, the dataset for the Dow \"mini-universe\".     \n   \n The proximity of the $k$-portfolio efficient frontiers to that of the \"ideal\" portfolio reveals the similarity of  risk-return trade-off behaviour of the $k$-portfolios,  to that of the \"ideal\" portfolio. The proximity of the $k$-portfolio efficient frontiers to one another, also reveals the similarity of their portfolio behaviour despite holding different sets of assets that were randomly selected, one  from each of the clusters, during their construction. (Refer Sec 3.4 of  **Lesson 3 Heuristic Portfolio Selection** for the construction of $k$-portfolios of Dow stocks)","3f3d7669":"The Python function **MaximizeReturns** employs scipy and NumPy to obtain the optimal weights. Since the problem model is linear, **linprog** function from the package scipy.optimize is invoked to execute **linear programming** to solve the problem model.  ","ee321f5d":"## 5.1 Introduction","3f067064":"The Python function **MinimizeRisk** employs scipy.optimize and NumPy to obtain the optimal weights.  \n\nFunctions  <b>f<\/b> and **constraintEq** describe the non-linear objective function and the fully invested constraint described in (5.5),  respectively. **optimize.minimize** function executes minimization of scalar functions with one or more variables. ","40b49b63":"  \n\nThis blog  is an abridged adaptation of concepts discussed in Chapter 1 and Chapter 3 of [PAI 18] to Dow Jones dataset (DJIA index: April, 2014- April, 2019) and implemented in Python. Readers (read \"worker bees\"),  seeking more information may refer to the corresponding chapter in the  book.\n","73a01eda":"While there are many ways to solve a bi-objective optimization problem, we choose to solve the problem by decomposing it into two three sub-problem models, viz.,   \n(i)   obtaining the maximal expected return $R^{MaxRetrn}$ of the portfolio,  subject to basic constraints,  \n(ii)  obtaining the optimal expected return $R^{MinRisk}$ corresponding to the minimum risk portfolio,  subject to basic constraints, and finally,   \n(iii) obtaining the optimal weights of the portfolio sets that minimize risk and whose returns R lie between $R^{MinRisk}$ and  $R^{MaxRetrn}$, (i.e.)  $R^{MinRisk} \\le R \\le R^{MaxRetrn}$, subject to basic constraints.    \n\nThe optimal portfolio set is referred to as the **efficient set**.\n","ec0f2257":"Let P be a portfolio comprising assets $A_1, A_2,...A_N$ with weights $W_1, W_2,...W_N$ and $\\mu_1, \\mu_2, ...\\mu_N$ as the asset returns. The portfolio return *r*  determined by a weighted summation of its individual asset returns is given by, ","91578563":"<h5 align=\"right\">..............................(5.5)<\/h5>","818f450a":"In the second stage, the mathematical model discussed in Sec. 5.3.2 is applied to the dataset and $R^{MinRisk}$,  the expected portfolio return corresponding to the minimum risk is determined. The following Python code shows the invocation of function **MinimizeRisk** to arrive at the return corresponding to minimum risk.  ","2f0fcd5e":"The optimal weights $W_{i}^{Optimal}$ obtained by solving (5.5) is used to compute $R^{MinRisk} = \\sum{\\left(W_{i}^{Optimal}.\\mu_i\\right)}$","45a54a35":"## 5.2 Mean-Variance Optimization Model","aaf8feb7":"The mathematical model for this sub-problem is defined as follows, where for each R, $R^{MinRisk} \\le R \\le R^{MaxRetrn}$, the problem model is repeatedly solved to arrive at the optimal weight sets,  each of which determines a portfolio that minimizes risk and maximizes return.  ","53893a67":"An investor can take recourse to traditional portfolio construction methods to determine the asset allocation weights.  **Lesson 4 Traditional Methods for Portfolio Construction** discussed two such methods, viz., **Equal weighted portfolio contruction** and **Inverse volatility weighted portfolio construction**.   \n\nHowever, is there a possibility where the **optimal weights**,  that obtains the **maximum return** of a portfolio  for a **minimal risk**, can be determined? In other words, is it possible for an investor to determine the optimal or the best apportionment of capital to assets in the portfolio, so that the investor reaps maximum return for  a minimum risk? Tough question, indeed! But thankfully, the answer is a firm Yes!  \n  \nThe **Markowitz model** [MAR 52]  built on the **Mean-Variance** framework of asset returns is an elegant solution to this question. Also known as **Mean-Variance Optimization (MVO)**,  the model aims to solve a multi-objective optimization problem subject to basic constraints imposed on the portfolio. ","600e0bbd":"## Prologue","1a2a5bb8":"Let us suppose that an investor decides to invest in a $k$-portfolio ($k$-portfolio 1) comprising the  following  Dow stocks. (Selection of $k$ portfolio 1, is detailed in **Lesson 3 Heuristic Portfolio Selection**)   \n\n**\ud835\udc58-portfolio 1**:  \n\n{Coca-Cola (KO), United Health (UNH), Walt Disney (DIS), IBM (IBM), Cisco (CSCO), JPMorgan Chase (JPM), Goldman Sachs (GS), Walgreens Boots Alliance (WBA), Apple (AAPL), Home Depot (HD), American Express (AXP), McDonald's (MCD), Merck (MRK), Boeing (BA), Caterpillar (CAT)}     \n\nThe investor desires to explore the optimal portfolio sets that yield maximum expected portfolio return and  minimum risk. The objective is to know the optimal weights given an expected return or a desired risk.  \n\nTo apply the MVO model, the historical data set for the $k$-portfolio ( DJIA index: April 11 2014 to April 11, 2019) is cleaned and kept fit for use by the three stage process of optimization discussed in Sec. 5.2. (**Lesson 2 Some glimpses of Financial Data Wrangling** discusses aspects of data cleaning or data wrangling)  \n\nThe following Python code reads the dataset concerned, computes the stock returns using the Python function **StockReturnsComputing** and obtains the mean returns and the variance-covariance matrix of returns. (Refer **Lesson 1 Fundamentals of Risk and Return of a Portfolio** to know about risk and return of a portfolio). \n\n","e85c3f89":"As the first stage to executing the MVO, the mathematical model discussed in Sec. 5.3.1 is applied to the dataset concerned and the maximum expected portfolio return $R^{MaxRetrn}$ is obtained. The following Python code shows the invocation of function **MaximizeReturns** to arrive at the maximum return. ","560d0747":"The mathematical model for this sub-problem is given by, ","403dabb7":"# Mean-Variance Optimization of Portfolios ","63705903":"<h5 align=\"right\">..............................(5.2)<\/h5>","afa2124c":"<h5 align=\"right\">..............................(5.6)<\/h5>","ffd5c376":"## 5.5  Efficient Frontiers: $k$-portfolios vs \"Ideal\" portfolio","2a445a5c":"### 5.3.1  Obtaining the Maximal Expected Return of the Portfolio","34d633e6":"Portfolio risk is the standard deviation of its returns and is given by,","7a75c097":"The optimal weights $W_{i}^{Optimal}$ obtained by solving (5.4) is used to compute $R^{MaxRetrn} = \\sum{\\left(W_{i}^{Optimal}.\\mu_i\\right)}$","4ef3af04":"The efficient set obtained by the Mean-Variance Optimization model can be graphically represented by what is called an **efficient frontier**. An efficient frontier is a **risk-return tradeoff graph**, which describes a set of optimal portfolios that yield the highest expected  portfolio return for a  defined level of risk or the lowest possible risk for a  defined level of expected portfolio return. It graphs the optimal structure of the portfolio which yields the maximum expected return for a given level of risk or vice-versa.   \n\nPortfolio optimization  strives to build portfolios which are on the efficient frontier and not below it, for these are sub-optimal. The set of all optimal portfolios that lie on the efficient frontier, in other words,  those portfolios that generate the largest return for a given level of risk or vice-versa, are also known as the **Markowitz efficient set**. \n\nGiven the efficient set, generated for the $k$-portfolio of Dow stocks discussed in Sec. 5.3, the following Python code traces the efficient frontier using **matplotlib** library."}}