{"cell_type":{"d6f112b9":"code","13984f4f":"code","becbbfce":"code","ba081943":"code","95c64c2c":"code","d3f26e86":"code","6c63c030":"code","3d7efb5d":"code","8709f0e6":"code","9db050e2":"code","47d023c0":"code","8b3cb4c7":"code","ff7e93cc":"code","97bc1cac":"code","3b9700d5":"code","79f66890":"code","15f19774":"code","92f9d234":"code","e0ce4ac1":"code","b6a90158":"code","66769187":"code","41be1e5a":"code","095d9218":"code","f0d4f888":"code","f42ef350":"code","1373cbe9":"code","545fa988":"code","f070f748":"code","58c04d3f":"code","fc9c166b":"code","e068d220":"code","794f2efb":"code","adabda81":"code","c147b3f6":"code","9d1591d6":"code","82061853":"code","f1ced562":"code","bb973b7a":"code","febd5241":"code","0e11597e":"code","f52197c2":"code","927437ea":"code","ea2bf9b1":"code","bacaef58":"code","2cec3c3e":"code","e697b174":"code","e3105490":"code","b7191068":"code","4bdecb84":"code","43537e71":"code","0ca983af":"code","f9a222a5":"code","9c8c2d68":"code","65416c2d":"code","87c6eeb8":"code","b0954bcc":"code","1e13f6d8":"code","7ab333a5":"code","de317230":"code","76c59c40":"code","6d307792":"code","7013f4c3":"code","edb2d024":"code","7d64a1d0":"code","c4133f7c":"code","c3db2069":"code","cc6b6933":"code","9935e02a":"code","e2b82633":"markdown","664ca2c0":"markdown","43eab48d":"markdown","1cbbd74d":"markdown","129c1dac":"markdown","4f38f40a":"markdown","bc02f77d":"markdown","eb0d4700":"markdown","b6997e9e":"markdown","b27e3665":"markdown","bbc98e41":"markdown","dab2705c":"markdown","8da204e2":"markdown","17b65447":"markdown","c979a203":"markdown","9495bdea":"markdown","231c54ea":"markdown","cda2db27":"markdown","c82c68cf":"markdown","970783a7":"markdown","0178bb5d":"markdown","1e4a640f":"markdown","701b8624":"markdown","536565f4":"markdown","7a9ed417":"markdown","1778b242":"markdown","2bb7f409":"markdown","c84fb0b9":"markdown","a692ba5c":"markdown","e123b4be":"markdown","8c76c391":"markdown","de8c0293":"markdown","4927bcbc":"markdown","d349d086":"markdown","7b1ad188":"markdown","66965790":"markdown","fea67e1e":"markdown","843c4370":"markdown","2a68d5f5":"markdown","61b06892":"markdown","490fcd30":"markdown","ab8a3dec":"markdown","0c0b080b":"markdown","c188ed25":"markdown","295cde32":"markdown","9fd06f2c":"markdown","2e9c1027":"markdown","b3b75114":"markdown","9db76e13":"markdown","a9580bc0":"markdown","a2ca4ef9":"markdown","4c9a5a5e":"markdown","0749a5ee":"markdown","9f117f9c":"markdown","e651bb5a":"markdown","185aca58":"markdown","5156944b":"markdown","8f279969":"markdown"},"source":{"d6f112b9":"import pandas as pd","13984f4f":"pd.DataFrame({'Bob': ['I liked it.', 'It was awful.'], 'Sue': ['Pretty good.', 'Bland.']})","becbbfce":"reviews = pd.DataFrame({'Bob': ['I liked it.', 'It was awful.'], 'Sue': ['Pretty good.', 'Bland.']}, index=['Product A', 'Product B'])\nreviews","ba081943":"reviews.rename_axis(\"Products\", axis='rows').rename_axis(\"Reviewers\", axis='columns')","95c64c2c":"pd.Series([30, 35, 40], index=['2015 Sales', '2016 Sales', '2017 Sales'], name='Product A')","d3f26e86":"reviews.to_csv(\"reviews.csv\")","6c63c030":"wine_reviews = pd.read_csv(\"..\/input\/wine-reviews\/winemag-data-130k-v2.csv\")\nwine_reviews.head()","3d7efb5d":"wine_reviews = pd.read_csv(\"..\/input\/wine-reviews\/winemag-data-130k-v2.csv\", index_col=0)\nwine_reviews.head()","8709f0e6":"wine_reviews = wine_reviews.rename(columns={'region_1': 'region', 'region_2': 'locale'})\nwine_reviews","9db050e2":"print(wine_reviews.country)\nwine_reviews.country[0]","47d023c0":"print(wine_reviews['country'])\nwine_reviews['country'][:5]","8b3cb4c7":"wine_reviews.head()","ff7e93cc":"wine_reviews.iloc[0]","97bc1cac":"wine_reviews.iloc[:3,0]","3b9700d5":"wine_reviews.iloc[[0, 1, 2], [0,1]]","79f66890":"wine_reviews.country.iloc[1]","15f19774":"wine_reviews.head()","92f9d234":"wine_reviews.loc[0, 'country']","e0ce4ac1":"wine_reviews.loc[[0,1,10,100],['country', 'province', 'region', 'locale']]","b6a90158":"wine_reviews.loc[[1, 2, 3, 5, 8]]","66769187":"wine_reviews[(wine_reviews.country == 'Brazil')]","41be1e5a":"wine_reviews.loc[(wine_reviews.country.isin(['Australia', 'New Zealand'])) & (wine_reviews.points >= 95)]","095d9218":"wine_reviews.loc[wine_reviews.price.isnull()]","f0d4f888":"wine_reviews.set_index(\"title\")","f42ef350":"wine_reviews.reset_index(drop=True)","1373cbe9":"wine_reviews['critic'] = 'everyone'\nwine_reviews['critic']","545fa988":"wine_reviews['index_backwards'] = range(len(wine_reviews), 0, -1)\nwine_reviews","f070f748":"wine_reviews.points.describe()","58c04d3f":"wine_reviews.taster_name.describe()","fc9c166b":"wine_reviews.head()","e068d220":"wine_reviews.columns","794f2efb":"wine_reviews.price.mean()","adabda81":"wine_reviews.price.median()","c147b3f6":"wine_reviews.taster_name.unique()","9d1591d6":"wine_reviews.nunique()","82061853":"wine_reviews.taster_name.nunique()","f1ced562":"wine_reviews.country.value_counts()","bb973b7a":"wine_reviews.count()","febd5241":"wine_reviews.price.min()","0e11597e":"bargain_idx = (wine_reviews.points \/ wine_reviews.price).idxmax()\nwine_reviews.loc[bargain_idx, 'title']","f52197c2":"wine_reviews.points.dtype","927437ea":"wine_reviews.price.dtype","ea2bf9b1":"wine_reviews.country.dtype","bacaef58":"wine_reviews.dtypes","2cec3c3e":"wine_reviews.select_dtypes(include='object')","e697b174":"wine_reviews.select_dtypes(exclude='object')","e3105490":"wine_reviews.points.astype('float64')","b7191068":"wine_reviews.groupby('country').price.max()","4bdecb84":"wine_reviews.groupby('points').price.min()","43537e71":"wine_reviews.groupby(['country', 'province']).apply(lambda df: df.loc[df.points.idxmax()])","0ca983af":"wine_reviews.groupby(['country']).points.agg([len, min, max])","f9a222a5":"countries_reviewed = wine_reviews.groupby(['country', 'province']).points.agg([max])\ncountries_reviewed = countries_reviewed.reset_index()\ncountries_reviewed.sort_values(by='max', ascending=False)","9c8c2d68":"countries_reviewed.sort_values(by=['country', 'max'])","65416c2d":"countries_reviewed.sort_index()","87c6eeb8":"mean = wine_reviews.price.mean()\ncentered_price = wine_reviews.price.map(lambda p: p - mean)\ncentered_price","b0954bcc":"n_trop = wine_reviews.description.map(lambda desc: \"tropical\" in desc).sum()\nn_fruity = wine_reviews.description.map(lambda desc: \"fruity\" in desc).sum()\ndescriptor_counts = pd.Series([n_trop, n_fruity], index=['tropical', 'fruity'])\ndescriptor_counts","1e13f6d8":"def reduced_price(row):\n    row.price = row.price - 1\n    return row\n\nnew_price = wine_reviews.apply(reduced_price, axis='columns')\nnew_price","7ab333a5":"def starring(row):\n    if row.country == 'Canada' or row.points >= 95:\n        return 3\n    elif row.points >= 85:\n        return 2\n    else:\n        return 1\nstar_ratings = wine_reviews.apply(starring, axis='columns')\nwine_reviews['rating'] = star_ratings\nwine_reviews","de317230":"wine_reviews['country - province'] = wine_reviews.country + \" - \" + wine_reviews.province\nwine_reviews","76c59c40":"wine_reviews.groupby(['country', 'province']).apply(lambda df: df.loc[df.points.idxmax()])","6d307792":"wine_reviews[wine_reviews.country.isnull()]","7013f4c3":"wine_reviews.locale.fillna(\"Unknown\")","edb2d024":"wine_reviews.taster_twitter_handle.replace(\"@kerinokeefe\", \"@kerino\")","7d64a1d0":"wine_reviews.drop([\"index_backwards\"], axis=1, inplace=True)\nwine_reviews","c4133f7c":"wine_reviews.dropna(axis=0, subset=['price'], inplace=True)\nwine_reviews","c3db2069":"canadian_youtube = pd.read_csv(\"..\/input\/youtube-new\/CAvideos.csv\")\nbritish_youtube = pd.read_csv(\"..\/input\/youtube-new\/GBvideos.csv\")","cc6b6933":"pd.concat([canadian_youtube, british_youtube])","9935e02a":"canadian_youtube.set_index(['title', 'trending_date']).join(british_youtube.set_index(['title', 'trending_date']), lsuffix='_CAN', rsuffix='_UK')","e2b82633":"- **idxmax():** *DataFrame* -> return index of first occurrence of maximum over requested axis. *Series* -> return the row label of the maximum value.","664ca2c0":"### Indexing operator []\nIf we have a Python dictionary, we can access its values using the indexing operator **[]**. We can do the same with columns in a DataFrame.","43eab48d":"- **rename():** *DataFrame* -> alter axes labels. *Series* -> alter Series index labels or name.","1cbbd74d":"- **apply():** *DataFrame* -> a mapping method that apply a function along an axis of the DataFrame by calling this custom function on each row or column. *Series* -> invoke function on values of Series. apply() returns a **new** DataFrame.","129c1dac":"- **isnull(), notnull():** built-in conditional selectors let you highlight missing values which are NA\/ non-NA. NA: None, NaN, NaT.","4f38f40a":"- **min()\/max():** return the minimum\/ minimum of the values for the requested axis.","bc02f77d":"# Data Exploration \n### Summary functions\n- **describe():** generate a high-level summary of the data input. It is type-aware, meaning that its output changes based on the data type of the input.","eb0d4700":"- **fillna():** fill NA\/NaN values using the specified method.","b6997e9e":"# Indexing\nThese are the two ways of selecting a specific Series out of a DataFrame in native Python.","b27e3665":"Pandas provides many common mapping operations as built-ins, all of the standard Python operators (>, <, ==, +, -).","bbc98e41":"- **count():** *DataFrame* -> count non-NA (`None`, `NaN`, `NaT`) cells for each column or row. *Series* -> return number of non-NA in the Series.","dab2705c":"- **median():** return the median of the values for the requested axis.","8da204e2":"- **dropna():** *DataFrame* -> Remove missing values. *Series* -> return a new Series with missing values removed.","17b65447":"# Data Creation\nThere are two core objects in pandas: the **DataFrame** and the **Series**.","c979a203":"- **sort_index():** *Dataframe* -> sort object by labels (along an axis). *Series* -> sort by the values.","9495bdea":"- **dtypes:** DataFrame -> return the dtypes in the DataFrame.","231c54ea":"# Data Reading\n- **pd.read_csv():** load a CSV file, a data, into a DataFrame.","cda2db27":"- **mean():** return the mean of the values for the requested axis. \n","c82c68cf":"- **unique():** *Series* -> return unique values of Series object.","970783a7":"It's possible to sort by more than one column at a time.","0178bb5d":"Columns consisting entirely of strings or timestamps do not get their own type; they are instead given the **object** type.","1e4a640f":"### DataFrame\nA DataFrame is a table. It contains an array of individual entries, each of which has a certain value. Each **entry** corresponds to a **row** (or record) and a **column** (or field).","701b8624":"### Label-based selection\nThe second paradigm for attribute selection is the one followed by the **loc** operator: label-based selection. In this paradigm, it's the data index value, not its position, which matters.","536565f4":"- **agg():** aggregate using one or more operations over the specified axis.","7a9ed417":"### Conditional selection\nConditional selection produce a Series of True\/False booleans. This result can then be used inside of loc to select the relevant data.","1778b242":"- **reset_index():** *DataFrame* -> reset the index, or a level of it. Reset the index of the DataFrame, and use the default one instead. If the DataFrame has a MultiIndex, this method can remove one or more levels. We can use the `drop` parameter to avoid the old index being added as a column.","2bb7f409":"# Data Assignment \nYou can assign with a constant value:","c84fb0b9":"### Sorting\n- **sort_values()**: *DataFrame* -> sort by the values along either axis. *Series* -> sort by the values. Defaults to an ascending sort.","a692ba5c":"- **astype():** cast a pandas object to a specified dtype `dtype`. ","e123b4be":"### Groupwise analysis\n- **groupby():** group DataFrame\/ Series using a mapper or by a Series of columns.","8c76c391":"# Index Manipulation\n- **set_index():** *DataFrame* -> set the DataFrame index using existing columns.","de8c0293":"- **isin():** built-in conditional selector lets you select data whose value \"is in\" a list of values.","4927bcbc":"- **nunique():** *DataFrame* -> Return Series with number of distinct observations. Can ignore NaN values. *Series* -> return number of unique elements in the object.","d349d086":"# Data Manipulation \n### Mapping\n**Map** is a term, borrowed from mathematics, for a function that takes one set of values and \"maps\" them to another set of values. In data science we often have a need for creating new representations from existing data, or for transforming data from the format it is in now to the format that we want it to be in later.\n\n- **map():** Series -> a mapping method that map values of Series according to input correspondence. The function passed to map() should expect a single value from the Series and return a transformed version of that value. map() returns a **new** Series where all the values have been transformed by the function.","7b1ad188":"### Index-based selection\nSelecting data based on its numerical position in the data. **iloc** follows this paradigm.","66965790":"- **select_dtypes():** *DataFrame* -> return a subset of the DataFrame's columns based on the column dtypes.","fea67e1e":"### Dtypes\n- **dtype:** *Series* -> return the dtype object of the underlying data, it could be used to get the type of a specific column. ","843c4370":"- **concat():** concatenate pandas objects along a particular axis with optional set logic\n    along the other axes. For instance, this is useful when we have data in different DataFrame or Series objects but having the **same fields** (columns).","2a68d5f5":"### Missing Data\n- **isnull(), notnull():** detect NA or non-NA values. NA: None, NaN, NaT.","61b06892":"- **drop():** *DataFrame* -> drop specified labels from rows or columns. *Series* -> return Series with specified index labels removed.","490fcd30":"- **Backfill strategy:** a strategy in which each missing value is filled with the first non-null value that appears sometime after the given record in the database.","ab8a3dec":"However, pandas has its own accessor operators, loc and iloc. Both of them are row-first, column-second. ","0c0b080b":"### Combining\nTo combine different DataFrames and\/or Series in non-trivial ways:","c188ed25":"- **head(), tail():** return the first\/ last `n` rows. `n` is set to 5 by default.","295cde32":"- **to_csv():** write object to a Comma-Separated Values (CSV) file.","9fd06f2c":"The list of row labels used in a DataFrame is known as an **Index**. We can assign values to it by using an `index` parameter.","2e9c1027":"### Attribute selection\nWe can access the property of an object by accessing it as an **attribute**. Columns in a pandas DataFrame work in much the same way.","b3b75114":"- **rename_axis():** set the name of the axis for the index (row labels) or columns.","9db76e13":"- **join():** *DataFrame* -> join columns of another DataFrame, either on **index** or on a **key column**. The `lsuffix` and `rsuffix` parameters are necessary in case the data has the same column labels in both datasets.","a9580bc0":"- **value_conuts():** *Series* -> return a Series containing counts of unique values.","a2ca4ef9":"Or with an iterable of values:","4c9a5a5e":"- **pd.DataFrame():** is used to generate DataFrame objects. The syntax for declaring a new one is a dictionary whose keys are the **column labels**, and whose values are a **list of entries**. The dictionary-list constructor assigns an ascending count from 0 for the **row labels**.","0749a5ee":"### Series\nA Series is a sequence of data values. If a DataFrame is a table, a Series is a list.\n\n- A Series is, in essence, a single column of a DataFrame. So you can assign row labels to the Series using an `index` parameter. \n- A Series does not have a column name, it only has one overall `name`.","9f117f9c":"- **columns:** *DataFrame* -> return DataFrame column labels.","e651bb5a":"# Acknowledgements\n> Most information in this notebook are based on Kaggle micro-courses available in [Kaggle Learn](https:\/\/www.kaggle.com\/learn\/overview).","185aca58":"- **replace():** is handy for replacing missing data which is given some kind of sentinel value in the dataset: things like \"Unknown\", \"Undisclosed\", \"Invalid\", and so on.","5156944b":"To make pandas use a column for the index (instead of creating a new one from scratch), we can specify an index_col ``index_col``.","8f279969":"**Both loc and iloc are row-first, column-second. This is the opposite of what we do in native Python, which is column-first, row-second.**"}}