{"cell_type":{"b14152d1":"code","d09da3a8":"code","c76b3f8f":"code","25d98dee":"code","4d42bfc5":"code","d4fc7354":"code","e03a9104":"markdown","2bc36e82":"markdown","6d50bde1":"markdown","629f7333":"markdown","1f0e5489":"markdown","859d4ecd":"markdown","2adf284b":"markdown"},"source":{"b14152d1":"import xlrd, pdb, numpy as np\nfrom scipy import stats\nimport pandas as pd\n\n##################### FIM IMPORTS\n\nclass patient():\n    def __init__(self, line, header):\n        self.id = line[0].value\n        data = dict()\n        i = 1\n        for key in header:\n            name = key.value.replace('\\xa0', ' ')\n            if name == 'Patient ID':\n                continue\n            if line[i].value == '':\n                data[name] = None\n            else:\n                if line[i].value == 'negative' or line[i].value == 'not_detected':\n                    data[name] = 0\n                else:\n                    if line[i].value == 'positive' or line[i].value == 'detected':\n                        data[name] = 1\n                    else:\n                        data[name] = line[i].value\n            i += 1\n        self.data = data\n\n\n\n####MAIN ANALISYS\n\n# DEFINICOES\nFILE_DATASET = \"\/kaggle\/input\/covid19\/dataset.xlsx\"  # destino do xlsx com a base de dados\nSHEET_NAME = \"All\"  # nome da planilha\nRATE_DATA_VALID = 0.9  # taxa do total de dados validas para validar analise da coluna\nRATE_DATA_TO_VERIFY = 0.7  # taxa de distorcao entre as integrais das duas distribuicoes normais das amostras\nRATE_DIFF_PROB_VALUE = 0.1  # taxa de diferen\u00e7a entre probabilidades\nCOLUMN_RESULT_COVID = \"SARS-Cov-2 exam result\"  # nome da coluna com resultado do exame do covid\nCOLUMN_VERIFY_HEMOGRAM = \"Hematocrit\"  # nome da colula para verificacao de hemograma presente\nNONE = 0\nADDMITED = 1\n\n# FIM DAS DEFINICOES\n\ncovid_base = xlrd.open_workbook(FILE_DATASET)\ndata = covid_base.sheet_by_name(SHEET_NAME)\n\npatient_list = dict()\nno_float_data = list()\n\n# inclusao dos dados na classe patient\nfor i in range(1, data.nrows):\n    p = patient(data.row(i), data.row(0))\n    patient_list[p.id] = p\n\n\nprint(\"Total de Registros:\",data.nrows)","d09da3a8":"pa_1 = \"Patient addmited to regular ward (1=yes, 0=no)\"\npa_2 = \"Patient addmited to semi-intensive unit (1=yes, 0=no)\"\npa_3 = \"Patient addmited to intensive care unit (1=yes, 0=no)\"\n\n# verificando dados float e crindo coluna Patient addmited\nfor patient in patient_list:\n\n    if (patient_list[patient].data[pa_3] == 1) or (patient_list[patient].data[pa_2] == 1) :\n        patient_list[patient].data[\"Patient addmited\"] = ADDMITED\n    else:\n        patient_list[patient].data[\"Patient addmited\"] = NONE\n\n    for data_type in patient_list[patient].data:\n        if ((type(patient_list[patient].data[data_type]) != float)\n            or (int(patient_list[patient].data[data_type]) == patient_list[patient].data[data_type]))   \\\n                and (patient_list[patient].data[data_type] != None):\n            if data_type not in no_float_data:\n                no_float_data.append(data_type)\nprint(\"colunas n\u00e3o verificadas:\",no_float_data)","c76b3f8f":"count_data_ok = dict()\n\ncount_hemogram = 0\nhas_hemogram = list()\n\nfor patient in patient_list:\n    # Verifica se paciente tem hemograma pelo dados nao nulos na coluna COLUMN_VERIFY_HEMOGRAM\n    if patient_list[patient].data[COLUMN_VERIFY_HEMOGRAM] != None:\n        count_hemogram += 1\n        has_hemogram.append(patient)\n        # conta o numero de amostras com dados de hemograma\n        for data_type in patient_list[patient].data:\n            if data_type not in count_data_ok:\n                count_data_ok[data_type] = 0\n            if patient_list[patient].data[data_type] != None:\n                count_data_ok[data_type] += 1\n\ncount_data_ok = dict()\n\ncount_hemogram = 0\nhas_hemogram = list()\n\nfor patient in patient_list:\n    # Verifica se paciente tem hemograma pelo dados nao nulos na coluna COLUMN_VERIFY_HEMOGRAM\n    if patient_list[patient].data[COLUMN_VERIFY_HEMOGRAM] != None:\n        count_hemogram += 1\n        has_hemogram.append(patient)\n        # conta o numero de amostras com dados de hemograma\n        for data_type in patient_list[patient].data:\n            if data_type not in count_data_ok:\n                count_data_ok[data_type] = 0\n            if patient_list[patient].data[data_type] != None:\n                count_data_ok[data_type] += 1\n\nvalid_data = list()\n\n# lista de colunas que ser\u00e3o excluidas da an\u00e1lise\nexclude_data = [\"Patient age quantile\"]\n\nlist_analisys = dict()\n\n# verifica lista que tem dados validos\nfor data_type in count_data_ok:\n    if (count_data_ok[data_type] > RATE_DATA_VALID * count_hemogram) \\\n            and (data_type not in exclude_data) \\\n            and (data_type not in no_float_data):\n        # print(data_type, count_data_ok[data_type])\n        valid_data.append(data_type)\n        print(data_type,\"->\",count_data_ok[data_type],\"valores\")\n","25d98dee":"for patient in has_hemogram:\n    for data_type in valid_data:\n        if data_type not in list_analisys:\n            list_analisys[data_type] = dict()\n        if patient_list[patient].data[data_type] is not None:\n            # separa dados v\u00e1lidas entre os pacientes diagnostidos com COVID e SEM COVID\n            if patient_list[patient].data[\"Patient addmited\"] == ADDMITED:\n                if ADDMITED not in list_analisys[data_type]:\n                    list_analisys[data_type][ADDMITED] = list()\n                list_analisys[data_type][ADDMITED].append(patient_list[patient].data[data_type])\n            else:\n                if NONE not in list_analisys[data_type]:\n                    list_analisys[data_type][NONE] = list()\n                list_analisys[data_type][NONE].append(patient_list[patient].data[data_type])\n\n# print(len(list_analisys[data_type][ADDMITED]),len(list_analisys[data_type][NONE]))\n\nlist_to_verify = list()\nprint(\"Columns Verified:\")\n\nmean = list()\nsigma = list()\nmin_type = list()\nmax_type = list()\nintegral = list()\n\n\npa = [NONE, ADDMITED]\npa_name = [\"NONE\/REGULAR\", \"SEMI-INTENSIVE\/INTENSIVE\"]\n\nfor i in pa:\n    mean.append(0)\n    sigma.append(0)\n    min_type.append(0)\n    max_type.append(0)\n    integral.append(0)\n\nfor data_type in list_analisys:\n\n    # calcula as medias e os desvios padrao das duas amostras\n\n    for i in pa:\n        mean[i] = np.mean(list_analisys[data_type][i])\n        sigma[i] = np.std(list_analisys[data_type][i])\n        min_type[i] = sigma[i] - mean[i]\n        max_type[i] = mean[i] + sigma[i]\n    # determina a regiao de comparacao das distribui\u00e7\u00f5es normais das amostras (utilizamos 1 sigma)\n\n    minimum = np.amax(min_type)\n    maximum = np.amax(max_type)\n\n    center = (maximum - minimum) \/ 2\n\n    for i in pa:\n        # calcula a integral das distribui\u00e7\u00f5es normais das amostras\n        integral[i] = stats.norm.cdf(center, loc=mean[i], scale=sigma[i])\n\n    compare = np.amin(integral) \/ np.amax(integral)\n\n    # verifica se existe distorcao entre as distribuicoes normais que possa ser utilizado para a comparacao\n    # entre pacientes com COVID e sem COVID\n    if compare < RATE_DATA_TO_VERIFY:\n        list_to_verify.append(data_type)\n\nprint(list_to_verify)\n","4d42bfc5":"score = dict()\nprob_mean = list()\nprob_data_value_patient = list()\n\nfor i in pa:\n    prob_mean.append(0)\n    prob_data_value_patient.append(0)\n\nfor patient in has_hemogram:\n    if patient not in score:\n        score[patient] = list()\n        for i in pa:\n            score[patient].append(0)\n\n    for data_type in list_to_verify:\n\n        # calcula as medias e os desvios padrao das duas amostras\n\n        for i in pa:\n            mean[i] = np.mean(list_analisys[data_type][i])\n            sigma[i] = np.std(list_analisys[data_type][i])\n\n        data_value_patient = patient_list[patient].data[data_type]\n\n        # se existe algum valor nulo nos dados da list_to_verify nao calcula\n        if data_value_patient == None:\n            continue\n\n        # calcula o valor da probabilidade dos valores nas duas curvas de distrbui\u00e7\u00e3o e divide pelo m\u00e1ximo (normaliza)\n\n        for i in pa:\n            # calcula a probabilidade das m\u00e9dias, como refer\u00eancia de valor m\u00e1ximo da curva\n            prob_mean[i] = stats.norm.pdf(mean[i], scale=sigma[i], loc=mean[i])\n            prob_data_value_patient[i] = stats.norm.pdf(data_value_patient, scale=sigma[i], loc=mean[i]) \/ prob_mean[i]\n\n        prob_analisys = prob_data_value_patient.copy()\n        index_max = np.argmax(prob_analisys)\n        value_index_max = prob_analisys[index_max]\n        prob_analisys.pop(index_max)\n        index_2max = np.argmax(prob_analisys)\n\n        value_index_2max = prob_analisys[index_2max]\n\n        if value_index_2max == 0:\n            rate = 1\n        else:\n            rate = value_index_max \/ value_index_2max\n\n        # verifica qual a probabilidade maior. SE diferen\u00e7a for menor que RATE_DIFF_PROB_VALUE\n        # o resultado \u00e9 inconclusivo\n\n        if (rate > 1 + RATE_DIFF_PROB_VALUE):\n                score[patient][index_max] += 1\n","d4fc7354":"count_result_ok = list()\ncount_total = list()\nacc = list()\ncount_result_ok_sum = 0\ncount_total_sum = 0\n\nfor i in pa:\n    count_result_ok.append(0)\n    count_total.append(0)\n    acc.append(0)\n\n# verifica a lista de pacientes com todos os dados completos para a realizacao do teste\nhas_all_data = list()\n\nfor patient in has_hemogram:\n    miss_data = False\n    for data_type in list_to_verify:\n        data_value_patient = patient_list[patient].data[data_type]\n        if data_value_patient == None:\n            miss_data = True\n\n    if (miss_data == False):\n        has_all_data.append(patient)\n\n# compara os resultados previstos e os realidos\nfor patient in has_all_data:\n\n    result = np.argmax(score[patient])\n    #print(score[patient], result)\n\n    for i in pa:\n        if (patient_list[patient].data[\"Patient addmited\"] == i):\n            count_total[i] += 1\n            if result == i:\n                count_result_ok[i] += 1\n\ncount_result_ok_sum = np.sum(count_result_ok)\ncount_total_sum = np.sum(count_total)\n\npa.append(len(pa))\npa_name.append(\"TOTAL\")\ncount_result_ok.append(count_result_ok_sum)\ncount_total.append(count_total_sum)\nacc.append(count_result_ok_sum\/count_total_sum)\n\nfor i in pa:\n    acc[i] = count_result_ok[i] \/ count_total[i]\n    print(pa_name[i], \"OK:\", count_result_ok[i], \"TOTAL:\", count_total[i], \"RATE:\",\n      acc[i])\n    \nmy_submission = pd.DataFrame({'TYPE': pa_name,\n                              'OK': count_result_ok,\n                              'TOTAL': count_total,\n                              'ACCURACY': acc })\n# you could use any filename. We choose submission here\nmy_submission.to_csv('submission.csv', index=False, sep=',' )","e03a9104":"Descartamos os pacientes que n\u00e3o tem dados suficientes para a an\u00e1lise. Deixamos somente os pacientes que possuem infoma\u00e7\u00f5es de hemograma, num total de 603 pacientes.<br \/>\nDescartamos da an\u00e1lise, colunas com menos de 540 valores, que \u00e9 90% (valor configur\u00e1vel) dos pacientes com hemograma.\n\n> Esta amostra \u00e9 muito pequena para uma predi\u00e7\u00e3o mais precisa. ","2bc36e82":"Nesta fase do c\u00f3digo, separamos os dados entre pacientes internados no semi-intensivo\/intensivo e n\u00e3o internados\/enfermaria. Geramos as curvas de  distribui\u00e7\u00e3o normal para cada conjunto de dados e verificamos se as duas distribui\u00e7\u00f5es possuem diferen\u00e7as suficientes para serem utilizadas como colunas refer\u00eancia.\n> Caso tenhamos maior quantidade de dados, poderiamos clusterizar os dados tamb\u00e9m por idade ou por exames parecidos. Neste momento, seccionar a amostra de pacientes infectados, por idade por exemplo, n\u00e3o melhoraria a predi\u00e7\u00e3o.","6d50bde1":"Verificando o resultado obtido podemos concluir que o modelo \u00e9 excelente, com **70%** de precis\u00e3o, sendo **70%** para os casos \"N\u00c3O INTERNADOS\/ENFERMARIA\" e **72%** para casos \"SEMI-INTENSIVO\/INTENSIVO\". A medida que a base de dados aumenta, a precis\u00e3o ir\u00e1 aumentar.<br \/>\nOutra oportunidade de melhoria seria o seccionamento dos dados por idade, por\u00e9m a quantidade de dados de \"SEMI-INTENSIVO\/INTENSIVO\" \u00e9 muito pequena para realizamos essa clusteriza\u00e7\u00e3o e podermos validar a efic\u00e1cia.\nO desempenho pode ainda ser otimizado com a ajuda de especialistas da \u00e1rea m\u00e9dica, pois assim, pode ser adicionado sentido biol\u00f3gico aos par\u00e2metros analisados, como por exemplo, atribuir diferentes pesos aos par\u00e2metros durante a tomada de decis\u00e3o de acordo com a influ\u00eancia desta infec\u00e7\u00e3o viral em sua grandeza.<br \/>\n","629f7333":"Ap\u00f3s a importa\u00e7\u00e3o dos dados, filtramos as colunas que cont\u00e9m valores do tipo **float**, para formar a curva de distribui\u00e7\u00e3o de probabilidade. Tamb\u00e9m criamos a coluna Patient Addmited pra identificarmos os pacientes no Semi-Intensivo\/Intensivo e os N\u00e3o Internados\/Enfermaria.","1f0e5489":"Este algor\u00edtmo foi construido baseado na an\u00e1lise da distribui\u00e7\u00e3o normal de probabilidade dos resultados dos exames, comparando pessoas indicadas e n\u00e3o indicadas para semi-intensivo e intensivo. <br \/>\nSeparamos primeiramente em 4 grupos:\n* Sem indica\u00e7\u00e3o de interna\u00e7\u00e3o\n* Enfermaria\n* Semi- Intensivo\n* Intensivo\n\nPor\u00e9m os resultados n\u00e3o foram conclusivos:\n\n**Columns Verified:\nHematocrit\nHemoglobin\nLeukocytes\n\nNONE OK: 235 TOTAL: 473 RATE: 0.49682875264270615\nREGULAR OK: 33 TOTAL: 58 RATE: 0.5689655172413793\nSEMI_INTENSIVE OK: 4 TOTAL: 42 RATE: 0.09523809523809523\nINTENSIVE OK: 15 TOTAL: 29 RATE: 0.5172413793103449**\n\nE n\u00e3o conseguimos detectar praticamente nada do semi-intensivo.\n\nDividomos ent\u00e3o em dois grupos:\n\n* Sem indica\u00e7\u00e3o de interna\u00e7\u00e3o e Enfermaria\n* Semi_Intensivo e Intensivo\n\nUtilizamos tamb\u00e9m a base completa, n\u00e3o nos atendo somente a pessoas com COVID-19.\n\n![image.png](attachment:image.png)","859d4ecd":"Definidos os conjuntos de dados que ser\u00e3o utilizados com refer\u00eancia na an\u00e1lise. Temos ent\u00e3o, nosso algoritmo \"treinado\" para receber as informa\u00e7\u00f5es dos pacientes e indicar se est\u00e3o infectados ou n\u00e3o.<br \/>\n\nQuando o programa recebe as informa\u00e7\u00f5es dos exames dos pacientes, ele obt\u00e9m o valor da probabilidade em cada uma das curvas de distribui\u00e7\u00e3o normal, semi-intensivo\/intensivo e infermaria\/n\u00e3o internado. Esse valor \u00e9 dividido pelo valor de probabilidade m\u00e1xima da curva, tendo assim um valor percentual da probabilidade m\u00e1xima.<br \/>\nComparamos os valores obtidos nas duas curvas e indicamos a curva em que o valor de probabilidade foi maior.< br\/>\nFazemos este procedimento para todos os tipos de dados refer\u00eancia, e verificamos quantos valores est\u00e3o indicados como semi-intensivo\/intensivo e como infermaria\/n\u00e3o internado. O grupo que obtiver a maioria ser\u00e1 a predi\u00e7\u00e3o do programa para aquele paciente.\n> Para a realiza\u00e7\u00e3o de testes, utilizamos os dados dos pacientes listados na base de dados.\n","2adf284b":"Por fim totalizamos as informa\u00e7\u00f5es e calculamos a precis\u00e3o na an\u00e1lise."}}