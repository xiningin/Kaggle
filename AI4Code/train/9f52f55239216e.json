{"cell_type":{"c8e15692":"code","b2b445d8":"code","5f52c9a5":"code","56ab5099":"code","11b9c1b6":"markdown","f55d9472":"markdown","d8ef4fa3":"markdown"},"source":{"c8e15692":"!pip install pycbc","b2b445d8":"import pandas as pd\ndf = pd.read_csv('..\/input\/g2net-gravitational-wave-detection\/training_labels.csv')\n\ndef train_filepath_from_id(id):\n    return f'..\/input\/g2net-gravitational-wave-detection\/train\/{id[0]}\/{id[1]}\/{id[2]}\/{id}.npy'\n\ndf['filepath'] = df.id.apply(train_filepath_from_id)\nprint(df.shape)","5f52c9a5":"import pylab, glob, os\nimport numpy as np\nimport pycbc.types\nfrom time import time\n\ndef plot_cqf(filepath, label):    \n    data = np.load(filepath)\n    \n    fig, axes = pylab.subplots(4, 1, figsize=[9,8], dpi=100)\n    pylab.title(f\"{label} \/ {os.path.basename(filepath)}\")\n    powers = list()\n    for i in range(3):\n        ts = pycbc.types.TimeSeries(data[i, :], epoch=0, delta_t=1.0\/2048) \n        \n        # whiten the data (i.e. normalize the noise power at different frequencies)\n        ts = ts.whiten(0.125, 0.125, remove_corrupted=True)\n        \n        # calculate the qtransform\n        t, freq, power = ts.qtransform(.002, logfsteps=100, qrange=(10, 10), frange=(20, 512))\n        powers.append(power)\n        \n    #standardized_powers = [(p -np.mean(p))\/np.std(p) for p in powers]\n    mean_of_all_sites = sum(powers)\/3\n    powers.append(mean_of_all_sites)\n    \n    for i, power in enumerate(powers):\n        # convert the data to a TimeSeries instance\n        #print(time()-t0)\n        pylab.sca(axes[i])\n        pylab.pcolormesh(t, freq, power, vmax=15, vmin=0)\n        #pylab.xlim(.25, 1.75)\n        pylab.yscale('log')\n        #breakpoint()\n    pylab.show()\n    print()\n\nfor _, row in df[df.target == 1].sample(n=1).iterrows():\n    plot_cqf(row['filepath'], row['target'])\n    \n#for _, row in df[df.target == 0].sample(n=10).iterrows():\n#    plot_cqf(row['filepath'], row['target'])","56ab5099":"from pathlib import Path\nfrom tqdm.notebook import tqdm\n\ndef compute_and_save_qtransform(filepath: str, output_directory: str):    \n    output_path = Path(output_directory) \/  '\/'.join(filepath.split('\/')[-5:])\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    data = np.load(filepath)\n    \n    powers = list()\n    for i in range(3):\n        ts = pycbc.types.TimeSeries(data[i, :], epoch=0, delta_t=1.0\/2048) \n        ts = ts.whiten(0.125, 0.125, remove_corrupted=True)\n        t, freq, power = ts.qtransform(.002, logfsteps=100, qrange=(10, 10), frange=(20, 512))\n        powers.append(power)\n    all_powers = np.array(powers)\n    np.save(output_path, all_powers)\n    \nfrom joblib import Parallel, delayed\nParallel(n_jobs=2)(delayed(compute_and_save_qtransform)(filepath, '\/kaggle\/working\/') \n                   for filepath in tqdm(df['filepath'].values[:50]))","11b9c1b6":"# Get labels","f55d9472":"# Plot the q-transform of the data\n\nA constant q-transform (https:\/\/en.wikipedia.org\/wiki\/Constant-Q_transform) is a common method to visualize gravitational-wave data. Almost all time-frequency figures in the gravitaitonal-wave literature use this method. ","d8ef4fa3":"# Install the PyCBC gravitational-wave analysis toolkit\n* https:\/\/github.com\/gwastro\/pycbc\n\nPyCBC is a python package developed by the community of GW astronomers to help analyze gravitational-wave data, detect signals, and even estimate the parameters of a source binary. It's meant to be accessible and welcomes contributions."}}