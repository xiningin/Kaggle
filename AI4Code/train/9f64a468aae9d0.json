{"cell_type":{"e6c81cfc":"code","8444ab00":"code","abb1c90c":"code","1dda9cd7":"code","18f0b904":"code","1a74b85a":"code","e8a839fd":"code","2ff9da4a":"code","cc4eef8e":"code","0ed66c81":"code","0cd8b268":"code","6c7dd246":"code","71621b1b":"code","00a343ea":"code","b5a19a0b":"code","5b6aa237":"code","2f310557":"code","604c2823":"code","8b15c86f":"code","a11657b3":"code","082c616e":"code","b62a6158":"code","7349a4a9":"code","6e7fdd0b":"code","259d6c80":"code","8068e53a":"code","3a53fa6d":"code","9e83d6b3":"code","3dcbb54b":"code","c36ffa47":"code","34807c86":"code","e0178aaf":"code","6e48ec35":"code","84306545":"code","7f097fcb":"code","783e60f7":"code","b7b536ed":"code","2a167fb2":"code","0e000041":"code","dd373970":"code","f9af74b4":"code","b389c1dc":"code","933e3059":"code","f6c3e5f3":"code","fec711e5":"code","8ac14139":"code","81de116a":"code","c508072f":"code","ee7151ba":"code","44e9abd9":"code","44fa5cc3":"code","24270961":"code","2d830929":"code","aedd2ee3":"code","047acd50":"code","cdab5674":"code","fd1e70ed":"code","4bff5229":"code","73a9ed05":"code","2e31ceae":"code","76dbe2f1":"code","5a22d889":"code","6edcec77":"markdown","e3489d12":"markdown","1494feaf":"markdown","be82e053":"markdown","24b2a907":"markdown","3fc0b498":"markdown","d2bb0fad":"markdown","34e19450":"markdown","0fdcca99":"markdown","619b2c57":"markdown","e39d5961":"markdown","46390996":"markdown","915eb0ae":"markdown","fde4e079":"markdown","469cc33c":"markdown","8496c86a":"markdown","3cf68894":"markdown","03c8a399":"markdown","5425c438":"markdown","85602e66":"markdown","3e4c3901":"markdown","010b8c1d":"markdown","76185eb4":"markdown","fd2f2c53":"markdown","876801c3":"markdown","8d5fa324":"markdown","787b5661":"markdown","d9773b4b":"markdown","054a6e35":"markdown","bccc3357":"markdown","6e647bae":"markdown"},"source":{"e6c81cfc":"# manipulation data\nimport pandas as pd\nimport numpy as np\n\n#visualiation data\nimport matplotlib.pyplot as plt\nimport seaborn as sns \nimport matplotlib\nimport plotly.graph_objects as go\nimport plotly.express as px\n\n#default theme\nsns.set(context='notebook', style='darkgrid', palette='colorblind', font='sans-serif', font_scale=1, rc=None)\nmatplotlib.rcParams['figure.figsize'] =[8,8]\nmatplotlib.rcParams.update({'font.size': 15})\nmatplotlib.rcParams['font.family'] = 'sans-serif'","8444ab00":"train = pd.read_csv('..\/input\/breast-cancer-wisconsin-data\/data.csv')\ntrain.head()","abb1c90c":"train.info()","1dda9cd7":"train.shape","18f0b904":"train.describe(include='all')","1a74b85a":"missing_values=train.isnull().sum()\npercent_missing = train.isnull().sum()\/train.shape[0]*100\n\nvalue = {\n    'missing_values ':missing_values,\n    'percent_missing %':percent_missing\n}\nframe=pd.DataFrame(value)\nframe","e8a839fd":"train=train.drop('Unnamed: 32',axis=1)\ntrain.head()","2ff9da4a":"# drop the id columns\ntrain=train.drop('id',axis=1)","cc4eef8e":"# transformation of type of the target value to numerical \nfrom sklearn import preprocessing\nle = preprocessing.LabelEncoder()\ntrain.diagnosis = le.fit_transform(train.diagnosis)\ntrain.diagnosis\n","0ed66c81":"train.corr().style.background_gradient(cmap='coolwarm').set_precision(2)","0cd8b268":"# drop this columns \ntrain=train.drop(['fractal_dimension_mean','texture_se','smoothness_se','symmetry_se','fractal_dimension_se'],axis=1)","6c7dd246":"# Feature Selection\n\nplt.rcParams['figure.figsize']=15,6 \nsns.set_style(\"darkgrid\")\n\nx = train.drop('diagnosis',axis=1)\ny = train.diagnosis\n\nfrom sklearn.ensemble import ExtraTreesClassifier\n\nmodel = ExtraTreesClassifier()\nmodel.fit(x,y)\nprint(model.feature_importances_) \nfeat_importances = pd.Series(model.feature_importances_, index=x.columns)\nfeat_importances.nlargest(15).plot(kind='barh')\nplt.title('the most 15 important feature are')\nplt.show()","71621b1b":"train.columns","00a343ea":"train=train.drop(['texture_mean','smoothness_mean','compactness_mean','symmetry_mean','perimeter_se','compactness_se','concavity_se','concave points_se','smoothness_worst','symmetry_worst','fractal_dimension_worst'],axis=1)","b5a19a0b":"g = sns.PairGrid(x)\ng.map_upper(sns.histplot)\ng.map_lower(sns.kdeplot, fill=True)\ng.map_diag(sns.histplot, kde=True)","5b6aa237":"plt.rcParams['figure.figsize']=25,7 \nsns.set_style(\"darkgrid\")\nax = sns.countplot(x=train.diagnosis , palette = \"rocket\", saturation =1.5)\nplt.xlabel(\"diagnosis malignant = 1 \/ benign = 0 \", fontsize = 10 )\nplt.ylabel(\"count\", fontsize = 10)\nplt.title('Number of diagnosis ')","2f310557":"sns.boxplot(x=train['concave points_worst'])","604c2823":"sns.displot(train, x='concave points_worst')","8b15c86f":"sns.displot(train, x=\"concave points_worst\", kde=True)","a11657b3":"sns.displot(train, x=\"concave points_worst\", col=\"diagnosis\", multiple=\"dodge\")","082c616e":"sns.boxplot(x=train['concavity_mean'])","b62a6158":"outlier=train[train['concavity_mean']>=0.25]\noutlier","7349a4a9":"train = train[train['concavity_mean']<0.25]\ntrain","6e7fdd0b":"sns.boxplot(x=train['concavity_mean'])","259d6c80":"sns.catplot(x=\"concavity_mean\",\n                col=\"diagnosis\",\n                data=train, kind=\"box\",\n                height=4, aspect=.7);","8068e53a":"sns.boxplot(x=train['perimeter_worst'])","3a53fa6d":"outlier=train[train['perimeter_worst']>=165]\noutlier","9e83d6b3":"train = train[train['perimeter_worst']<165]\ntrain","3dcbb54b":"sns.boxplot(x=train['perimeter_worst'])","c36ffa47":"from sklearn.model_selection import train_test_split\nfrom sklearn import metrics\nfrom sklearn.metrics import accuracy_score","34807c86":"x=train.drop('diagnosis',axis=1)\ny=train.diagnosis","e0178aaf":"print(x.shape)\nprint(y.shape)","6e48ec35":"x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.3)","84306545":"from sklearn.preprocessing import StandardScaler\nsc = StandardScaler()\nx_train = sc.fit_transform(x_train)\nx_test = sc.transform(x_test)","7f097fcb":"# Making Confusion Matrix and calculating accuracy score\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, accuracy_score\n\nmodel = LogisticRegression()\n\n#Fit the model\nmodel.fit(x_train, y_train)\ny_pred = model.predict(x_test)\n\nmylist = []\n# Confusion Matrix\ncm = confusion_matrix(y_test, y_pred)\n# accuracy score\nacc_logreg = accuracy_score(y_test, y_pred)\n\nmylist.append(acc_logreg)\nprint(cm)\nprint(acc_logreg,'%')","783e60f7":"# Finding the optimum number of neighbors \n\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import confusion_matrix, accuracy_score\n\nlist1 = []\nfor neighbors in range(1,5):\n    classifier = KNeighborsClassifier(n_neighbors=neighbors, metric='minkowski')\n    classifier.fit(x_train, y_train)\n    y_pred = classifier.predict(x_test)\n    list1.append(accuracy_score(y_test,y_pred))\nplt.plot(list(range(1,5)), list1)\nplt.show()","b7b536ed":"# Training the K Nearest Neighbor Classifier on the Training set\n\nclassifier = KNeighborsClassifier(n_neighbors=3)\nclassifier.fit(x_train, y_train)\n\n# Predicting the Test set results\n\ny_pred = classifier.predict(x_test)\nprint(y_pred)\n\n","2a167fb2":"# Making the confusion matrix and calculating accuracy score\n\nfrom sklearn.metrics import confusion_matrix, accuracy_score\ncm = confusion_matrix(y_test, y_pred)\nacc_knn = accuracy_score(y_test, y_pred)\nmylist.append(acc_knn)\nprint(cm)\nprint(acc_knn)","0e000041":"from sklearn.svm import SVC\nfrom sklearn.metrics import confusion_matrix, accuracy_score\nlist1 = []\nfor c in [0.5,0.6,0.7,0.8,0.9,1.0]:\n    classifier = SVC(C = c, random_state=0, kernel = 'rbf')\n    classifier.fit(x_train, y_train)\n    y_pred = classifier.predict(x_test)\n    list1.append(accuracy_score(y_test,y_pred))\nplt.plot([0.5,0.6,0.7,0.8,0.9,1.0], list1)\nplt.show()","dd373970":"# Training the Support Vector Classifier on the Training set\n\nfrom sklearn.svm import SVC\nclassifier = SVC(C = 0.9, random_state=0, kernel = 'rbf')\nclassifier.fit(x_train, y_train)\n\n","f9af74b4":"# Predicting the test set results\n\ny_pred = classifier.predict(x_test)\nprint(y_pred)","b389c1dc":"# Making the confusion matrix and calculating accuracy score\n\nfrom sklearn.metrics import confusion_matrix, accuracy_score\ncm = confusion_matrix(y_test, y_pred)\nacc_svc = accuracy_score(y_test, y_pred)\nprint(cm)\nprint(acc_svc,'%')\nmylist.append(acc_svc)","933e3059":"# Finding the optimum number of max_leaf_nodes\n\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.metrics import confusion_matrix, accuracy_score\nlist1 = []\nfor leaves in range(2,15):\n    classifier = DecisionTreeClassifier(max_leaf_nodes = leaves, random_state=0, criterion='entropy')\n    classifier.fit(x_train, y_train)\n    y_pred = classifier.predict(x_test)\n    list1.append(accuracy_score(y_test,y_pred))\n#print(mylist)\nplt.plot(list(range(2,15)), list1)\nplt.show()","f6c3e5f3":"# Training the Decision Tree Classifier on the Training set\n\nclassifier = DecisionTreeClassifier(max_leaf_nodes = 5, random_state=0, criterion='entropy')\nclassifier.fit(x_train, y_train)","fec711e5":"#Predicting the test set results\n\ny_pred = classifier.predict(x_test)\nprint(y_pred)","8ac14139":"# Making the confusion matrix and calculating accuracy score\n\nfrom sklearn.metrics import confusion_matrix, accuracy_score\ncm = confusion_matrix(y_test, y_pred)\nacc_decisiontree = accuracy_score(y_test, y_pred)\nprint(cm)\nprint(acc_decisiontree)\nmylist.append(acc_decisiontree)","81de116a":"#Finding the optimum number of n_estimators\n\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import confusion_matrix, accuracy_score\nlist1 = []\nfor estimators in range(10,30):\n    classifier = RandomForestClassifier(n_estimators = estimators, random_state=0, criterion='entropy')\n    classifier.fit(x_train, y_train)\n    y_pred = classifier.predict(x_test)\n    list1.append(accuracy_score(y_test,y_pred))\n#print(mylist)\nplt.plot(list(range(10,30)), list1)\nplt.show()","c508072f":"# Training the RandomForest Classifier on the Training set\n\nfrom sklearn.ensemble import RandomForestClassifier\nclassifier = RandomForestClassifier(n_estimators = 15, criterion='entropy', random_state=0)\nclassifier.fit(x_train,y_train)","ee7151ba":"# Predicting the test set results\n\ny_pred = classifier.predict(x_test)\nprint(y_pred)","44e9abd9":"# Making the confusion matrix and calculating the accuracy score\n\nfrom sklearn.metrics import confusion_matrix, accuracy_score\ncm = confusion_matrix(y_test, y_pred)\nacc_randomforest = accuracy_score(y_test, y_pred)\nmylist.append(acc_randomforest)\nprint(cm)\nprint(acc_randomforest)","44fa5cc3":"np.random.seed(0)\nimport tensorflow as tf\n\n# Initialising the ANN\n\nann = tf.keras.models.Sequential()\n\n# Adding the input layer and the first hidden layer\n\nann.add(tf.keras.layers.Dense(units = 7, activation = 'relu'))\n\n# Adding the second hidden layer\n\nann.add(tf.keras.layers.Dense(units = 7, activation = 'relu'))\n\n# Adding the third hidden layer\n\nann.add(tf.keras.layers.Dense(units = 7, activation = 'relu'))\n\n# Adding the fourth hidden layer\n\nann.add(tf.keras.layers.Dense(units = 7, activation = 'relu'))\n\n# Adding the output layer\n\nann.add(tf.keras.layers.Dense(units = 1, activation = 'sigmoid'))\n\n# Compiling the ANN\n\nann.compile(optimizer = 'adam', loss = 'binary_crossentropy' , metrics = ['accuracy'] )\n\n# Training the ANN on the training set\n\nann.fit(x_train, y_train, batch_size = 16, epochs = 100)","24270961":"# Predicting the test set results\n\ny_pred = ann.predict(x_test)\ny_pred = (y_pred > 0.9)\nnp.set_printoptions()","2d830929":"# Making the confusion matrix, calculating accuracy_score \n\nfrom sklearn.metrics import confusion_matrix, accuracy_score\n\n# confusion matrix\ncm = confusion_matrix(y_test,y_pred)\nprint(\"Confusion Matrix\")\nprint(cm)\nprint()\n\n# accuracy\nac_ann = accuracy_score(y_test,y_pred)\nprint(\"Accuracy\")\nprint(ac_ann)\nmylist.append(ac_ann)","aedd2ee3":"from xgboost import XGBClassifier\nfrom sklearn.metrics import confusion_matrix, accuracy_score\nlist1 = []\nfor estimators in range(10,30,1):\n    classifier = XGBClassifier(n_estimators = estimators, max_depth=12, subsample=0.7)\n    classifier.fit(x_train, y_train)\n    y_pred = classifier.predict(x_test)\n    list1.append(accuracy_score(y_test,y_pred))\n#print(mylist)\nplt.plot(list(range(10,30,1)), list1)\nplt.show()","047acd50":"from xgboost import XGBClassifier\nclassifier = XGBClassifier(n_estimators = 15, max_depth=12, subsample=0.7)\nclassifier.fit(x_train,y_train)","cdab5674":"y_pred = classifier.predict(x_test)\nprint(y_pred)","fd1e70ed":"# Making the confusion matrix and calculating the accuracy score\n\nfrom sklearn.metrics import confusion_matrix, accuracy_score\ncm = confusion_matrix(y_test, y_pred)\nac_xgboost = accuracy_score(y_test, y_pred)\nmylist.append(ac_xgboost)\nprint(cm)\nprint(ac_xgboost)","4bff5229":"from catboost import CatBoostClassifier\nclassifier = CatBoostClassifier()\nclassifier.fit(x_train, y_train)","73a9ed05":"y_pred = classifier.predict(x_test)\nprint(y_pred)","2e31ceae":"# Making the confusion matrix and calculating the accuracy score\n\nfrom sklearn.metrics import confusion_matrix, accuracy_score\ncm = confusion_matrix(y_test, y_pred)\nac_catboost = accuracy_score(y_test, y_pred)\nmylist.append(ac_catboost)\nprint(cm)\nprint(ac_catboost)","76dbe2f1":"models = pd.DataFrame({\n    'Model': ['Support Vector Machines', 'KNN', 'Logistic Regression', \n              'Random Forest', 'ANN',   \n              'Decision Tree','xgboost','catboost'],\n    'Score': [acc_svc, acc_knn, acc_logreg, \n              acc_randomforest, ac_ann, acc_decisiontree,ac_xgboost,ac_catboost\n              ]})\nmodels.sort_values(by='Score', ascending=False)","5a22d889":"plt.rcParams['figure.figsize']=15,6 \nsns.set_style(\"darkgrid\")\nax = sns.barplot(x=models.Model, y=models.Score, palette = \"rocket\", saturation =1.5)\nplt.xlabel(\"Classifier Models\", fontsize = 20 )\nplt.ylabel(\"% of Accuracy\", fontsize = 20)\nplt.title(\"Accuracy of different Classifier Models\", fontsize = 20)\nplt.xticks(fontsize = 12, horizontalalignment = 'center', rotation = 8)\nplt.yticks(fontsize = 13)\nfor p in ax.patches:\n    width, height = p.get_width(), p.get_height()\n    x, y = p.get_xy() \n    ax.annotate(f'{height:.2%}', (x + width\/2, y + height*1.02), ha='center', fontsize = 'x-large')\nplt.show()","6edcec77":"# 4. data vizualisation","e3489d12":"### a) Logistic Regression","1494feaf":"### e) RANDOM FOREST CLASSIFCATION","be82e053":"### g) xgboost","24b2a907":"## A) diagnosis","3fc0b498":"##### like we see all our feautres are numirical values exept the target value ***diagnosis*** (M = malignant, B = benign)","d2bb0fad":"##### we had 569 Rows and 33 columns (small data )","34e19450":"## B) concave points_worst","0fdcca99":"We can see there are some outliers. Lets remove them (0.3- 0.5)","619b2c57":"### c) Support Vector Machines","e39d5961":"## A) finding missing values","46390996":"#### this feautres had a corralation valus < 0.07 with the target columns \nfractal_dimension_mean \/ texture_se \/ smoothness_se \/ symmetry_se \/ fractal_dimension_se","915eb0ae":"### b) KNN","fde4e079":"# 2. load and analys data","469cc33c":"#### Diagnosis \n\n1. M = malignant ==> 1\n2. B = benign    ==> 0 ","8496c86a":"# Data Set Information:\n\nFeatures are computed from a digitized image of a fine needle aspirate (FNA) of a breast mass. They describe characteristics of the cell nuclei present in the image. A few of the images can be found at [Web Link]\n\nSeparating plane described above was obtained using Multisurface Method-Tree (MSM-T) [K. P. Bennett, \"Decision Tree Construction Via Linear Programming.\" Proceedings of the 4th Midwest Artificial Intelligence and Cognitive Science Society, pp. 97-101, 1992], a classification method which uses linear programming to construct a decision tree. Relevant features were selected using an exhaustive search in the space of 1-4 features and 1-3 separating planes.\n\nThe actual linear program used to obtain the separating plane in the 3-dimensional space is that described in: [K. P. Bennett and O. L. Mangasarian: \"Robust Linear Programming Discrimination of Two Linearly Inseparable Sets\", Optimization Methods and Software 1, 1992, 23-34].\n\nThis database is also available through the UW CS ftp server:\nftp ftp.cs.wisc.edu\ncd math-prog\/cpo-dataset\/machine-learn\/WDBC\/\n\n\n## Attribute Information:\n\n1. ID number\n2. Diagnosis (M = malignant, B = benign) \n3. 3-32 Ten real-valued features are computed for each cell nucleus:\n\n    * radius (mean of distances from center to points on the perimeter)\n    * texture (standard deviation of gray-scale values)\n    * perimeter\n    * area\n    * smoothness (local variation in radius lengths)\n    * compactness (perimeter^2 \/ area - 1.0)\n    * concavity (severity of concave portions of the contour)\n    * concave points (number of concave portions of the contour)\n    * symmetry\n    * fractal dimension (\"coastline approximation\" - 1)\n\n![](https:\/\/static.packt-cdn.com\/products\/9781783980284\/graphics\/3a298fcc-54fb-42c2-a212-52823e709e30.png)","3cf68894":"##### like we c our data is clean exept the last columns that is empty so we gonna drop it ","03c8a399":"## B) concavity_mean","5425c438":"#### from the first look in our data description we can see that :\n\n1. B = benign is the most frequent value in our target columns\n2. Unnamed: 32 columns is an empty column ","85602e66":"# 1. import library","3e4c3901":"## A) split data ","010b8c1d":"## B) Feature Scaling","76185eb4":"### d) DecisionTreeClassifier","fd2f2c53":"## A) correlation map","876801c3":"## 3) perimeter_worst","8d5fa324":"## Plotting many distributions","787b5661":"### h) catboost","d9773b4b":"# 3. feautres selection ","054a6e35":"# 5) machine learning application","bccc3357":"### f) ANN (neural network )","6e647bae":"We can see there are 2 outliers. Lets remove them >120"}}