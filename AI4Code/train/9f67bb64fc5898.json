{"cell_type":{"09abce6b":"code","b1d49367":"code","18c14e38":"code","16e0e178":"code","f01da294":"code","94d2b357":"code","8385782c":"code","daba50c2":"markdown","317d8adf":"markdown","67015476":"markdown"},"source":{"09abce6b":"!pip install openpyxl\n!pip install lifetimes","b1d49367":"# Importing necessary libraries\n\nimport datetime as dt\nimport pandas as pd\nimport lifetimes\nfrom lifetimes import BetaGeoFitter\nfrom lifetimes import GammaGammaFitter","18c14e38":"############ REMINDER ############\n# DESCRIPTIVE STATISTICS WILL BE OUT SHOULD THIS CODE RUN\n# PLEASE RUN THIS CODE THAN RUN THE FUNCTION BELOW FOR CERTAIN COUNTRIES\n\n# Setting necessary display options:\n\npd.set_option('display.max_columns', None)\npd.set_option('display.width', 500)\npd.set_option('display.float_format', lambda x: '%.5f' % x)\nfrom sklearn.preprocessing import MinMaxScaler\n\n\n# Reading dataset:\n\ndf_ = pd.read_excel(\"..\/input\/online-retail-ii-data-set-from-ml-repository\/online_retail_II.xlsx\", sheet_name=\"Year 2010-2011\")\ndf = df_.copy()\n\n\n# Deleting POSTAGE payments from dataset:\n\ndf = df[~(df[\"Description\"] == \"POSTAGE\")]\n\n\n# Quick check to the dataset:\n\ndef check_df(dataframe):\n    print(\"##################### Shape #####################\")\n    print(f\"Rows: {dataframe.shape[0]}\")\n    print(f\"Columns: {dataframe.shape[1]}\")\n    print(\"##################### Types #####################\")\n    print(dataframe.dtypes)\n    print(\"####################### NA ######################\")\n    print(dataframe.isnull().sum())\n    print(\"################### Quantiles ###################\")\n    print(dataframe.quantile([0, 0.05, 0.50, 0.95, 0.99, 1]).T)\n    print(\"##################### Head ######################\")\n    print(dataframe.head())\ncheck_df(df)\n\n\n# Setting outlier thresholds:\n\ndef outlier_thresholds(dataframe, col_name, q1=0.01, q3=0.99):\n    quartile1 = dataframe[col_name].quantile(q1)\n    quartile3 = dataframe[col_name].quantile(q3)\n    interquantile_range = quartile3 - quartile1\n    up_limit = quartile3 + 1.5 * interquantile_range\n    low_limit = quartile1 - 1.5 * interquantile_range\n    return low_limit, up_limit\n\nnum_cols = [\"Quantity\", \"Price\"]\n\n\n# Outlier analysis:\n\ndef grab_outliers(dataframe, col_name, index=False):\n    low, up = outlier_thresholds(dataframe, col_name)\n\n    if dataframe[((dataframe[col_name] < low) | (dataframe[col_name] > up))].shape[0] > 10:\n        print(\"#####################################################\")\n        print(str(col_name) + \" variable have too much outliers: \" + str(dataframe[((dataframe[col_name] < low) | (dataframe[col_name] > up))].shape[0]))\n        print(\"#####################################################\")\n        print(dataframe[((dataframe[col_name] < low) | (dataframe[col_name] > up))].head(15))\n        print(\"#####################################################\")\n        print(\"Lower threshold: \" + str(low) + \"   Lowest outlier: \" + str(dataframe[col_name].min()) +\n              \"   Upper threshold: \" + str(up) + \"   Highest outlier: \" + str(dataframe[col_name].max()))\n        print(\"#####################################################\")\n    elif (dataframe[((dataframe[col_name] < low) | (dataframe[col_name] > up))].shape[0] < 10) & \\\n            (dataframe[((dataframe[col_name] < low) | (dataframe[col_name] > up))].shape[0] > 0):\n        print(\"#####################################################\")\n        print(str(col_name) + \" variable have less than 10 outlier values: \" + str(dataframe[((dataframe[col_name] < low) | (dataframe[col_name] > up))].shape[0]))\n        print(\"#####################################################\")\n        print(dataframe[((dataframe[col_name] < low) | (dataframe[col_name] > up))])\n        print(\"#####################################################\")\n        print(\"Lower threshold: \" + str(low) + \"   Lowest outlier: \" + str(dataframe[col_name].min()) +\n              \"   Upper threshold: \" + str(up) + \"   Highest outlier: \" + str(dataframe[col_name].max()))\n        print(\"#####################################################\")\n    else:\n        print(\"#####################################################\")\n        print(str(col_name) + \" variable does not have outlier values\")\n        print(\"#####################################################\")\n\n    if index:\n        print(str(col_name) + \" variable's outlier indexes\")\n        print(\"#####################################################\")\n        outlier_index = dataframe[((dataframe[col_name] < low) | (dataframe[col_name] > up))].index\n        return outlier_index\n\nfor col in num_cols:\n    grab_outliers(df, col)\n\n\n# Replacing outliers:\n\ndef replace_with_thresholds(dataframe, variable):\n    low_limit, up_limit = outlier_thresholds(dataframe, variable)\n    dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit\n    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit\n\nfor col in num_cols:\n    replace_with_thresholds(df, col)\n\n\n# Removing NaN values; Removing canceled purchases (Invoices containing \"C\"):\n\ndf.dropna(inplace=True)\ndf = df[~df[\"Invoice\"].str.contains(\"C\", na=False)]\ndf = df[df[\"Quantity\"] > 0]\ndf = df[df[\"Price\"] > 0]\n\n\n# Creating TotalPrice variable and setting today's date as follows:\n\ndf[\"TotalPrice\"] = df[\"Quantity\"] * df[\"Price\"]\ntoday_date = dt.datetime(2011, 12, 11)\n\n\n\n\n# THE FUNCTION\n\n\n\ndef cltv_create(dataframe, country, expected_purchase=False,\n                month_expected=1, expected_profit=False, cltv_prediction=False,\n                cltv_month=1):\n\n    if dataframe[dataframe[\"Country\"] == country][\"Customer ID\"].nunique() < 2:\n        print(\"Datas from: \" + str(country) + \" aren't enough for CLTV analysis.\")\n\n    else:\n        one_country = dataframe.loc[dataframe[\"Country\"] == country]\n        country_code = one_country.groupby(\"Customer ID\").agg(\n            {'InvoiceDate': [lambda date: (date.max() - date.min()).days,\n                            lambda date: (today_date - date.min()).days],\n            'Invoice': lambda num: num.nunique(),\n            'TotalPrice': lambda TotalPrice: TotalPrice.sum()})\n\n        country_code.columns = country_code.columns.droplevel(0)\n\n        country_code.columns = [\"recency\", \"T\", \"frequency\", \"monetary\"]\n\n        country_code[\"monetary\"] = country_code[\"monetary\"] \/ country_code[\"frequency\"]\n        country_code = country_code[(country_code['frequency'] > 1)]\n\n        country_code[\"recency\"] = country_code[\"recency\"] \/ 7\n        country_code[\"T\"] = country_code[\"T\"] \/ 7\n\n\n\n        if expected_purchase:\n            bgf = BetaGeoFitter(penalizer_coef=0.001)\n            bgf.fit(country_code['frequency'], country_code['recency'], country_code['T'])\n\n            country_code[\"expected_purchase\"] = bgf.predict(month_expected,\n                                                           country_code['frequency'],\n                                                           country_code['recency'],\n                                                           country_code['T'])\n\n            print(\"###########################################################\")\n            print(\"Expected purchase for: \" + str(month_expected) + \" months\" + \" for \" + str(country) + \" customers\")\n            print(\"###########################################################\")\n            print(country_code)\n\n\n\n        if expected_profit:\n            ggf = GammaGammaFitter(penalizer_coef=0.01)\n            ggf.fit(country_code['frequency'], country_code['monetary'])\n            country_code[\"expected_average_profit\"] = ggf.conditional_expected_average_profit(country_code['frequency'],\n                                                                                       country_code['monetary'])\n            print(\"###########################################################\")\n            print(\"Expected profit for \" + str(country) + \" customers\")\n            print(\"###########################################################\")\n            print(country_code)\n\n\n\n\n        if cltv_prediction:\n            bgf = BetaGeoFitter(penalizer_coef=0.001)\n            bgf.fit(country_code['frequency'], country_code['recency'], country_code['T'])\n\n            ggf = GammaGammaFitter(penalizer_coef=0.01)\n            ggf.fit(country_code['frequency'], country_code['monetary'])\n\n            cltv_x_month = ggf.customer_lifetime_value(bgf,\n                                                     country_code['frequency'],\n                                                     country_code['recency'],\n                                                     country_code['T'],\n                                                     country_code['monetary'],\n                                                     time=cltv_month,\n                                                     freq=\"W\",\n                                                     discount_rate=0.01)\n\n            country_final_cltv = country_code.merge(cltv_x_month, on=\"Customer ID\", how=\"left\")\n\n            scaler = MinMaxScaler(feature_range=(0, 1))\n            scaler.fit(country_final_cltv[[\"clv\"]])\n            country_final_cltv[\"scaled_clv\"] = scaler.transform(country_final_cltv[[\"clv\"]])\n\n            country_final_cltv[\"segment\"] = pd.qcut(country_final_cltv[\"scaled_clv\"], 4, labels=[\"D\", \"C\", \"B\", \"A\"])\n\n            print(\"###########################################################\")\n            print(\"Customer Lifetime Value analysis for \" + str(country) + \" for \" + str(cltv_month) + \" months\")\n            print(\"###########################################################\")\n            return country_final_cltv","16e0e178":"# 6 month CLTV analysis for Spain customers:\n\ncltv_create(df, \"Spain\", cltv_prediction=True, cltv_month=6)","f01da294":"# 3 month expected purchase analysis for Belgium customers:\n\ncltv_create(df, \"Belgium\", expected_purchase=True, month_expected=3)","94d2b357":"# Expected profit for Austria customers:\n\ncltv_create(df, \"Austria\", expected_profit=True)","8385782c":"# Lithuania\n\ncltv_create(df, \"Lithuania\", cltv_prediction=True, cltv_month=3)","daba50c2":"# CLTV Prediction Analysis\n\nInvestments are company\u2019s commitment for better future. Each company has it\u2019s own calculations to determine the amount of investment, direction and time of exposure. Also a lot work should be done to determine which way to promote\/advert our next steps. But as economics is here to say, for sharing limited resources to limitless demands; every company also has limited resources to reach certain part of their customers.\n\nBut further of reaching them, we need to understand whether they will continue to buy from us. For example who will be our company\u2019s top 10 most valuable customer 2 quarters later; or which ones aren\u2019t buying anymore from our company so we can specify our adverts for them.\n\nLet\u2019s start.\n\nWe have one year dataset of a retail gift shop. This analysis will start as if dataset has no null and no minus values. So we have kind of a \u201chalf-baked\u201d dataset.\n\n**Retail gift shop dataset\u2019s variables are as below:**\n\nInvoice \u2014 Unique code for bill\/invoice\n\nStockCode \u2014 Unique code for product\n\nDescription \u2014 Product name\n\nQuantity \u2014 Number of product sold in certain bill\n\nInvoiceDate \u2014 Bill date and time\n\nUnitPrice \u2014 Price of product\n\nCustomer ID \u2014 Unique customer ID for each customer\n\nCountry \u2014 Name of the country where sale occurs\n\n**BUSINESS PROBLEM**: An e-commerce company wants to predict customers future purchases\nand determine business investment plan according to predicted data.\n\n**DATASET STORY**: There is Online Retail II, 2010-2011 sheet file as dataset.\nProducts sold are mostly souvenirs and most of the customers are corporates.","317d8adf":"**Thank your for your reading!**\n\n**This work has been done with the support of** [VBO](https:\/\/www.veribilimiokulu.com\/) - [Vahit Keskin](https:\/\/www.linkedin.com\/in\/vahitkeskin\/).\n\n**My LinkedIn profile:**\n[Blirind Danjolli](https:\/\/www.linkedin.com\/in\/blirind\/)","67015476":"![1_08BwP7HVNIHBUxJj-It2yg.gif](attachment:7daa206c-0fdc-44ee-b047-3beb3b62a647.gif)"}}