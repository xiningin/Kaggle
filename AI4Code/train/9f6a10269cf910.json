{"cell_type":{"a249abab":"code","5798ccc4":"code","e4137473":"code","165a98f7":"code","143705dd":"code","204b7a01":"code","a142bb69":"code","e6a2e235":"code","c73dc199":"code","ebf89cd7":"code","d3fd93b8":"code","9b7f9c79":"code","166d662d":"code","e5852cc7":"code","3caeee9d":"code","f014c1d7":"code","c2ac842a":"code","9bac5c5c":"code","44dabe84":"code","dc034951":"code","5d7650b9":"markdown","768c519f":"markdown","0654599e":"markdown","88cc57f2":"markdown","2d1a68c0":"markdown","d8720fee":"markdown","8b12b14c":"markdown"},"source":{"a249abab":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","5798ccc4":"class Node():\n    # the constructor\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.previous = None\n","e4137473":"class DoublyLinkedList():\n    \n    # the initializer\n    def __init__(self):\n        # no data in the head\n        self.head = None\n        # make the tail point to the head\n        self.tail = self.head\n        # initialize length\n        self.length = 0\n        \n    def print_list(self):\n        if self.head == None:\n            # if no data in the head\n            print(\"Empty\")\n        else:\n            # initialize a pointer to the node head\n            current_node = self.head\n            # continue as long as the pointer doesn't point to None\n            while current_node != None:\n                # print current node data\n                print(current_node.data, end = ' ')\n                # let the pointer move to the next data item in the LinkedList\n                current_node = current_node.next\n        # print a new line\n        print()\n    \n    def append(self, data):\n        # make a new node\n        new_node = Node(data)\n        if self.head == None:\n            # if the linked list is empty, make the head and tail equal to the new node\n            self.head = new_node\n            self.tail = self.head\n        else:\n            # else let the new node previous pointer point to the current LinkedList tail\n            new_node.previous = self.tail\n            # let the LinkedList tail next pointer point to the new node\n            self.tail.next = new_node\n            # let the data in the LinkedList tail be the new node data thus updating the tail value\n            self.tail = new_node\n        # incrementing Linked List length by 1\n        self.length += 1\n        \n    def prepend(self, data):\n        # make a new node\n        new_node = Node(data)\n        if self.head == None:\n            # if the linked list is empty, make the head and tail equal to the new node\n            self.head = new_node\n            self.tail = self.head\n        else:\n            # else let the new node next pointer point to the current LinkedList head\n            new_node.next = self.head\n            # let the LinkedList head previous pointer point to the new node\n            self.head.previous = new_node\n            # let the data in the LinkedList head be the new node data thus updating the head value\n            self.head = new_node\n        # incrementing Linked List length by 1   \n        self.length += 1\n        \n    def insert(self, position, data):\n\n        if position == 0:\n            # inserting at the first position is the same as prepending\n            self.prepend(data)\n        elif position >= self.length:\n            # inserting at the last position is the same as appending\n            self.append(data)\n        else:\n            # creating a new node\n            new_node = Node(data)\n            # making a pointer to the Linked List head\n            current_node = self.head\n            # traversing until reaching the position just before the desired position\n            for i in range(position - 1):\n                current_node = current_node.next\n            # making the previous of the new_node point to the curernt node\n            new_node.previous = current_node\n            # making the next of the new_node point to the next of the current node\n            new_node.next = current_node.next\n            # making the next of the current node point to the new_node\n            current_node.next = new_node\n            # making the previous of the next node point to the new_node instead of the\n            # current_node\n            new_node.next.previous = new_node\n            # incrementing Linked List length by 1\n            self.length += 1\n            \n    def delete_by_value(self, data):\n        if self.head == None:\n            # if Linked List is empty\n            print(\"Linked List is empty. There is nothing to delete.\")\n            # get out of the function\n            return\n        if (self.length == 1) or (self.length == 2):\n            # if Linked List contains one or two nodes\n            if (self.head.data != data) and (self.tail.data != data):\n                # if value isn't found\n                print('Value not found!')\n            elif self.length == 1:\n                # if value is found and there is only one Node, then point head to Null\n                self.head = None\n                # point tail to head\n                self.tail = self.head\n            elif self.head.data == data:\n                # if value is found at the Linked List head, and there are two nodes, point head next\n                # pointer to Null\n                self.head.next = None\n                # point head to tail\n                self.head = self.tail\n                # point tail previous pointer to Null\n                self.tail.previous = None\n            elif self.tail.data == data:\n                # if value is found at the Linked List tail, and there are two nodes, point tail previous\n                # pointer to Null\n                self.tail.previous = None\n                # point tail to head\n                self.tail = self.head\n                # point head next pointer to Null\n                self.head.next = None\n            # decrementing Linked List length by 1\n            self.length -= 1\n                \n        else:\n            # if Linked List contains more than one node\n            # position tracker\n            current_pos = 0\n            # make a pointer to the Linked List head\n            current_node = self.head\n            try:\n                # traverse through the list until you find the data, and change the position accordingly\n                while (current_node.data != data) and (current_pos <= self.length - 1):\n                    current_node = current_node.next\n                    current_pos += 1\n\n                if current_node.data != data:\n                    # if value isn't found\n                    print('Value not found!')\n                else:\n                    # if the value is found at the Linked List head\n                    if current_pos == 0:\n                        # make the head point to the next node\n                        self.head = current_node.next\n                        # point the current_node next, and previous pointers to Null\n                        current_node.previous = None\n                        current_node.next = None\n                    # else if value is found at the Linked List tail\n                    elif current_pos == self.length - 1:                   \n                        self.tail = current_node.previous\n                        # point the previous node next pointer to Null\n                        self.tail.next = None\n                        # point the current node previous pointer to Null\n                        current_node.previous = None\n                    # else if value is found at some where in the middle of the Linked List\n                    else:\n                        # point the previous node next pointer to the next node \n                        current_node.previous.next = current_node.next\n                        # point the next node previous pointer to the previous node\n                        current_node.next.previous = current_node.previous\n                        # point the current_node previous, and next pointers to Null\n                        current_node.previous = None\n                        current_node.next = None\n\n                    # decrementing Linked List length by 1\n                    self.length -= 1\n                    \n            except AttributeError:\n                print(\"Given value not found.\")\n                return\n\n    def delete_by_position(self, position):\n        # handling invalid inputs\n        # given that the input position is zero index-based (i.e. first position starts from zero)\n        if self.head == None:\n            # if Linked List is empty\n            print(\"Linked List is empty. There is nothing to delete.\")\n            # get out of the function\n            return\n        if (position < 0) or (position > self.length - 1):\n            print(\"This position doesn't exist in the Linked List!\")\n            # get out of the function\n            return\n        # handling valid inputs\n        # if the first position is chosen\n        if position == 0:\n            # update the Linked List head to be the next node\n            self.head = self.head.next\n            # if the Linked List had only one or two nodes before deleting the first node\n            if (self.head == None) or (self.head.next == None):\n                # make the tail point to the head\n                self.tail = self.head\n            # else if the Linked List had more than two nodes before deleting the first node\n            elif self.head != None:\n                # make the previous pointer of the new head point to Null\n                self.head.previous = None\n        # if the last position is chosen\n        elif position == self.length - 1:\n            # hold the current tail\n            current_node = self.tail\n            # set the tail to be the previous node\n            self.tail = self.tail.previous\n            # point the tail next pointer to Null\n            self.tail.next = None\n            # make the previous pointer of the last node (tail) point to Null to delete this node\n            current_node.previous = None\n        # if a position somewhere in the middle is chosen\n        else:\n            # track the Linkded List for traversing, starting form its head\n            current_node = self.head\n            # traverse throught the Linked List until you find the position you want to delete\n            for i in range(position):\n                current_node = current_node.next\n            # make the next pointer of the previous node point to the next node\n            current_node.previous.next = current_node.next\n            # make the previous pointer of the next node point to the previous node\n            current_node.next.previous = current_node.previous\n            # make the previous pointer of the current node point to Null for deleting its first link\n            current_node.previous = None\n            # make the next pointer of the current node point to Null for deleting it completely from the\n            # Linked List\n            current_node.next = None\n        # decrementing Linked List length by 1  \n        self.length -= 1\n        ","165a98f7":"my_linked_list = DoublyLinkedList()\nmy_linked_list.print_list()","143705dd":"my_linked_list.append(5)\nmy_linked_list.append(2)\nmy_linked_list.append(9)\nmy_linked_list.print_list()","204b7a01":"my_linked_list.prepend(4)\nmy_linked_list.print_list()","a142bb69":"my_linked_list.insert(2,7)\nmy_linked_list.print_list()","e6a2e235":"my_linked_list.insert(0,0)\nmy_linked_list.insert(6,0)\nmy_linked_list.insert(9,3)\nmy_linked_list.print_list()","c73dc199":"my_linked_list.delete_by_value(3)\nmy_linked_list.print_list()","ebf89cd7":"my_linked_list.delete_by_value(0)\nmy_linked_list.print_list()","d3fd93b8":"my_linked_list.delete_by_position(3)\nmy_linked_list.print_list()","9b7f9c79":"my_linked_list.delete_by_position(0)\nmy_linked_list.print_list()","166d662d":"my_linked_list.delete_by_position(8)\nmy_linked_list.print_list()","e5852cc7":"my_linked_list.delete_by_position(3)\nmy_linked_list.print_list()","3caeee9d":"my_linked_list.delete_by_value(3)\nmy_linked_list.print_list()","f014c1d7":"print(my_linked_list.length)","c2ac842a":"class Node():\n    def __init__(self, data):\n        self.data = data\n        self.right = None\n        self.left = None","9bac5c5c":"class BST():\n    def __init__(self):\n        self.root = None\n        self.num_of_nodes = 0\n        \n    def insert(self, data):\n        new_node = Node(data)\n        if self.root == None:\n            self.root = new_node    \n        else:\n            current_node = self.root\n            while (current_node.right != new_node) and (current_node.left != new_node):\n                try:\n                    if (data > current_node.data):\n                        if current_node.right != None:\n                            current_node = current_node.right\n                        else:\n                            current_node.right = new_node\n\n                    elif (data < current_node.data):\n                        if current_node.left != None:\n                            current_node = current_node.left\n                        else:\n                            current_node.left = new_node\n                    else:\n                        raise ValueError(\"This value already exists in the Binary Search Tree.\")\n                except ValueError:\n                    raise\n                    \n        self.num_of_nodes += 1\n        \n    def search(self, data):\n        if self.root == None:\n            print(\"The Tree is Empty.\")\n        else:\n            current_node = self.root\n            for i in range(self.num_of_nodes):\n                if data == current_node.data:\n                    print(\"Value is found\")\n                    return\n                elif data > current_node.data:\n                    current_node = current_node.right\n                else:\n                    current_node = current_node.left\n            print(\"Value is not found\")","44dabe84":"bst = BST()\nbst.insert(1)\nbst.insert(2)\nbst.insert(3)","dc034951":"bst.search(3)","5d7650b9":"## 1.2 Binary Search Tree (BST)","768c519f":"# 1. Data Structures","0654599e":"We need a node class for storing the following information for each node:\n1. Node Data\n2. Pointer to its right child\n3. Pointer to its left child","88cc57f2":"Testing the `DoublyLinkedList` class","2d1a68c0":"# Algorithms & Data Structures\n\nAlgorithms, and Data Structures are very important to understand for any software engineer for being able to code efficiently. During my practice in Problem Solving, and in my career, I find some very useful algorithms, and data structures that I have to understand how to use, and when to use. \n\nTherefore in this Notebook I am going to put my *Algorithms & Data Structures Python Practice* that includes the use of:\n1. Ready available useful algorithms and data structures already implemented in Python that used and wanted to have reference for them.\n2. Known useful algorithms and data structures that I coded by myself to understand these different algorithms, and data structures on a deeper level.\n\nI have also copied different codes from here into Python files for uploading them to that [GitHub repository](https:\/\/github.com\/bahgat-ahmed\/Algorithms-Data-Structures).\n\nDuring my practice, I was guided by this [GitHub repository](https:\/\/github.com\/VicodinAbuser\/ZTM-DS-and-Algo-Python).","d8720fee":"Now for implementing the BST, we should have a constructor with the root node initialized to `None` with zero number of nodes and it will have the following three methods:\n1. lookup\n2. insert\n3. delete","8b12b14c":"## 1.1 Doubly Linked List"}}