{"cell_type":{"38ae43bd":"code","84d0cb63":"code","8f4143ea":"code","5c1ec088":"code","baa2ff99":"code","159ece38":"code","40b0a251":"code","8cbd05c5":"code","6ff29555":"code","b8528f89":"code","8fec98ce":"code","279c5724":"code","a84246f0":"code","51a17b09":"code","f0341b1f":"markdown","1c510d03":"markdown","918e6e00":"markdown","d45f3c93":"markdown","5b75118d":"markdown","8f65a7d3":"markdown","a177fef6":"markdown","9ddb3fc6":"markdown","0b14c826":"markdown","7ad4dc08":"markdown","152050c8":"markdown"},"source":{"38ae43bd":"import pandas as pd\ninput_path = \"\/kaggle\/input\/histopathologic-cancer-detection\"\ntrain_data = pd.read_csv(f\"{input_path}\/train_labels.csv\")\ntrain_data.head()\n\n","84d0cb63":"from PIL import Image\nfrom matplotlib import pyplot as plt\nimport numpy as np\nid = train_data.loc[0][\"id\"]\nim = np.array(Image.open(f'{input_path}\/train\/{id}.tif'))\nplt.title(f\"{id} \\n {im.shape}\")\nplt.imshow(im)\nplt.show()","8f4143ea":"import torch\nclass Dataset(torch.utils.data.Dataset):\n    def __init__(self, transform=None):\n        self.input_path = \"\/kaggle\/input\/histopathologic-cancer-detection\"\n        self.dataset = pd.read_csv(f\"{input_path}\/train_labels.csv\")\n        self.img_path = f\"{self.input_path}\/train\/\"\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.dataset)\n\n    def __getitem__(self, idx):\n        if torch.is_tensor(idx):\n            idx = idx.tolist()\n        image = Image.open(f'{self.input_path}\/train\/{self.dataset.iloc[idx][\"id\"]}.tif')\n        label = self.dataset.iloc[idx][\"label\"]\n        \n        if self.transform:\n            image = self.transform(image)\n        #label = np.zeros([1 if label == i else 0 for i in range(2)])\n        return image, label","5c1ec088":"import torchvision\ndata_transform = torchvision.transforms.Compose([\n    torchvision.transforms.RandomRotation(30),\n    torchvision.transforms.Resize((256, 256)), \n    torchvision.transforms.RandomResizedCrop(224),\n    torchvision.transforms.RandomHorizontalFlip(),\n    torchvision.transforms.RandomVerticalFlip(),\n    torchvision.transforms.ToTensor(),\n    torchvision.transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]),\n])\n\nbatch_size = 128\ndataset = Dataset(transform=data_transform)\ntrainset, validset = torch.utils.data.random_split(dataset, [int(len(dataset)*0.7), len(dataset) - int(len(dataset)*0.7)], generator=torch.Generator().manual_seed(42))\ndataloaders = {\n    \"train\" : torch.utils.data.DataLoader(trainset, batch_size=batch_size, shuffle=True, num_workers=4),\n    \"valid\" : torch.utils.data.DataLoader(validset, batch_size=batch_size, shuffle=True, num_workers=4),\n}\ndataset_sizes = {\n    \"train\" : int(len(dataset)*0.7),\n    \"valid\" : len(dataset) - int(len(dataset)*0.7),\n}\ngenerator = iter(dataloaders[\"train\"])\nimage, label = next(generator)\nfor i in range(3):\n    plt.title(label[i])\n    plt.imshow(image[i].permute(1, 2, 0))\n    plt.show()","baa2ff99":"backbone = torchvision.models.resnet50(pretrained=True)\nnum = backbone.fc.in_features\nbackbone.fc = torch.nn.Linear(num, 2)\n\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nmodel = backbone.to(device)\nprint(device)","159ece38":"!pip3 install adamp\nimport adamp","40b0a251":"criterion = torch.nn.CrossEntropyLoss()\n#optimizer = torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)\n#optimizer = torch.optim.Adam(model.parameters(), lr=0.001)\noptimizer = adamp.AdamP(model.parameters(), lr=0.001, betas=(0.9, 0.999), weight_decay=1e-2)\nscheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)","8cbd05c5":"import time\nimport copy\ndef train_model(model, criterion, optimizer, scheduler, num_epochs=25):\n    since = time.time()\n\n    best_model_wts = copy.deepcopy(model.state_dict())\n    best_acc = 0.0\n\n    for epoch in range(num_epochs):\n        print('Epoch {}\/{}'.format(epoch, num_epochs - 1))\n\n        for phase in ['train', 'valid']:\n            if phase == 'train':\n                model.train() \n            else:\n                model.eval() \n\n            running_loss = 0.0\n            running_corrects = 0\n\n            for inputs, labels in dataloaders[phase]:\n                inputs = inputs.to(device)\n                labels = labels.to(device)\n\n                optimizer.zero_grad()\n\n                with torch.set_grad_enabled(phase == 'train'):\n                    outputs = model(inputs)\n                    _, preds = torch.max(outputs, 1)\n                    loss = criterion(outputs, labels)\n\n                    if phase == 'train':\n                        loss.backward()\n                        optimizer.step()\n\n                running_loss += loss.item() * inputs.size(0)\n                running_corrects += torch.sum(preds == labels.data)\n            if phase == 'train':\n                scheduler.step()\n\n            epoch_loss = running_loss \/ dataset_sizes[phase]\n            epoch_acc = running_corrects.double() \/ dataset_sizes[phase]\n\n            print('{} Loss: {:.4f} Acc: {:.4f}'.format(\n                phase, epoch_loss, epoch_acc))\n\n            if phase == 'valid' and epoch_acc > best_acc:\n                best_acc = epoch_acc\n                best_model_wts = copy.deepcopy(model.state_dict())\n\n        print()\n\n    time_elapsed = time.time() - since\n    print('Training complete in {:.0f}m {:.0f}s'.format(\n        time_elapsed \/\/ 60, time_elapsed % 60))\n    print('Best val Acc: {:4f}'.format(best_acc))\n\n    model.load_state_dict(best_model_wts)\n    return model","6ff29555":"model = train_model(model, criterion, optimizer, scheduler, num_epochs=20)","b8528f89":"input_path = \"\/kaggle\/input\/histopathologic-cancer-detection\"\ntest_data = pd.read_csv(f\"{input_path}\/sample_submission.csv\")\nprint(len(test_data))\ntest_data.head()","8fec98ce":"class Testset(torch.utils.data.Dataset):\n    def __init__(self, transform):\n        self.input_path = \"\/kaggle\/input\/histopathologic-cancer-detection\"\n        self.dataset = pd.read_csv(f\"{input_path}\/sample_submission.csv\")\n        self.img_path = f\"{self.input_path}\/test\/\"\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.dataset)\n\n    def __getitem__(self, idx):\n        if torch.is_tensor(idx):\n            idx = idx.tolist()\n        image = Image.open(f'{self.input_path}\/test\/{self.dataset.iloc[idx][\"id\"]}.tif')\n        label = self.dataset.iloc[idx][\"label\"]\n        \n        if self.transform:\n            image = self.transform(image)\n       \n        return image","279c5724":"data_transform = torchvision.transforms.Compose([\n    torchvision.transforms.Resize((224, 224)), \n    torchvision.transforms.ToTensor(),\n    torchvision.transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]),\n])\ntestset = Testset(transform= data_transform)\ntest_loader = torch.utils.data.DataLoader(testset, batch_size=1, shuffle=False)","a84246f0":"import numpy as np\nfor i, image in enumerate(test_loader):\n    if i % 10000 == 0:\n        print(i, \"\/\", len(test_loader))\n    outputs = model(image.to(device))\n    test_data.loc[i, 'label'] = int(torch.argmax(outputs))","51a17b09":"test_data.to_csv('submission.csv', index=False)\ntest_data","f0341b1f":"# 4. Test\n","1c510d03":"# 1. Data Exploration\n- Let's take a look at the data.\n- \uc77c\ub2e8 \ub370\uc774\ud130\ub97c \uc0b4\ud3b4\ubd05\uc2dc\ub2e4.\n\n## 1.1 CSV","918e6e00":"- It consists of an image name (id) and a classification value (label).\n- \uc774\ubbf8\uc9c0 \uc774\ub984(id)\uc640 \ubd84\ub958\uac12(label)\ub85c \uad6c\uc131\ub418\uc5b4\uc788\ub124\uc694.","d45f3c93":"# 3. Modeling\n- Let's do transfer learning using ResNet.\n- ResNet\uc744 \uc774\uc6a9\ud574\uc11c \uc804\uc774\ud559\uc2b5 \uc2dc\ucf1c\ubd05\uc2dc\ub2e4.\nhttps:\/\/tutorials.pytorch.kr\/beginner\/transfer_learning_tutorial.html","5b75118d":"## 1.2 Img\n- The image has a tif extension and cannot be loaded through OpenCV. You need to utilize the PIL library.\n- \uc774\ubbf8\uc9c0\uac00 tif \ud655\uc7a5\uc790\ub85c \ub418\uc5b4\uc788\uc5b4 OpenCV\ub97c \ud1b5\ud574\uc11c \ubd88\ub7ec\uc62c \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. PIL \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \ud65c\uc6a9\ud574\uc57c\ud569\ub2c8\ub2e4.","8f65a7d3":"## 3.3 Training","a177fef6":"## 2.2 Dataloader & Transform\n- \ub370\uc774\ud130 \uc99d\uac15\uc744 \uc704\ud55c \ud2b8\ub79c\uc2a4\ud3fc\uc744 \uad6c\uc131\ud569\ub2c8\ub2e4.\n- Construct a transform for data augmentation.","9ddb3fc6":"## 3.2 Set Functions\n- SGD and Adam are mainly used as optimizers. But here we will use Adamp (ICLR 2021).\n- Optimizer\ub85c\ub294 SGD, Adam\uc744 \uc8fc\ub85c \uc0ac\uc6a9\ud569\ub2c8\ub2e4. \ud558\uc9c0\ub9cc \uc5ec\uae30\uc11c\ub294 Adamp(ICLR 2021)\ub97c \uc0ac\uc6a9\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4.\n- Ref : https:\/\/github.com\/clovaai\/AdamP","0b14c826":"# 2. Data Loader\n- Let's configure the dataset and data loader.\n- \ub370\uc774\ud130\uc14b\uacfc \ub370\uc774\ud130\ub85c\ub354\ub97c \uad6c\uc131\ud574\ubd05\uc2dc\ub2e4.\n- Ref : https:\/\/tutorials.pytorch.kr\/beginner\/data_loading_tutorial.html","7ad4dc08":"## 3.1 Import Model\n- Load the ResNet to be used as the backbone model, and adjust the Output Layer to 2 (number of classes in our problem).\n- \ubc31\ubcf8 \ubaa8\ub378\ub85c \uc0ac\uc6a9\ud560 ResNet\uc744 \ubd88\ub7ec\uc624\uace0, Output Layer\ub97c 2\uac1c(\uc6b0\ub9ac \ubb38\uc81c\uc758 \ud074\ub798\uc2a4 \uc218)\ub85c \uc870\uc815\ud569\ub2c8\ub2e4. ","152050c8":"## 2.1 Dataset"}}