{"cell_type":{"d5127dd0":"code","c8fce5b8":"code","1a119ab8":"code","ab39463f":"code","f8cfd2f9":"code","2c9a623e":"code","ac624c8d":"code","8161ff4b":"code","d708d3b3":"code","65e2bb65":"code","5865d47c":"code","19f6997f":"code","2b6fb74a":"code","3db6d786":"code","211cbd07":"code","30767638":"code","3ca31a0b":"code","a5ed96af":"code","b7961877":"code","28d6bf9e":"code","586fc83a":"code","5939663f":"code","af16a13c":"code","873edf47":"code","c210900c":"code","1350c000":"code","b8c95f34":"code","5080ea78":"code","e0e17331":"code","7a124e0b":"code","31560152":"code","dc292f9b":"code","f2897142":"code","0d43d33b":"code","c7e76630":"code","18311294":"code","25800cc9":"code","30e2b9c2":"code","5640c9b9":"code","5cf1aebb":"code","f9ea2a28":"code","96374b67":"code","0291fe1d":"code","135dc6c4":"code","c8a11a77":"code","9e065cfe":"code","9010b150":"code","f4d1c41f":"code","e967edbc":"markdown","c2a603b0":"markdown","ad1f187e":"markdown","2a0a2df3":"markdown","7aded0f4":"markdown","b5e90b5a":"markdown","8c261112":"markdown","1aa9be23":"markdown","4f6296f3":"markdown","925b94c0":"markdown","8b2689be":"markdown","43189f40":"markdown","0830bda6":"markdown","1183a427":"markdown","d3a88624":"markdown","5941dade":"markdown","022cff04":"markdown","419856dd":"markdown","c6b47231":"markdown","edb51fe3":"markdown","2a7498b4":"markdown","af8a531c":"markdown","56ede1e0":"markdown","a86e5f64":"markdown","f3404247":"markdown","0fa7d262":"markdown","0ee1206f":"markdown","4a2b9648":"markdown","40e63180":"markdown","442a8a09":"markdown","441863ce":"markdown","1fd8c16b":"markdown","5adc2e1a":"markdown","f31d9fa2":"markdown","1d9feeab":"markdown","dd937b1d":"markdown","3782faeb":"markdown","929282d1":"markdown","ebbcc6f4":"markdown","dc37468c":"markdown","cc919d28":"markdown","e1581e77":"markdown","11a29800":"markdown","6052bae9":"markdown","c846f3de":"markdown","0d2e01c3":"markdown","eeb4451a":"markdown","5be04d2b":"markdown","3520d4ce":"markdown","fe7d894b":"markdown","b6b0fd21":"markdown"},"source":{"d5127dd0":"!pip install numpy","c8fce5b8":"import numpy as np","1a119ab8":"c = np.array(1, dtype=np.float32)\nprint(f\"c: shape {c.shape} - dtype: {c.dtype}\")\nprint(c)","ab39463f":"v = np.array([1.0, 2.0, 3.0], dtype=np.int32)\nprint(f\"v: shape {v.shape} - dtype: {v.dtype}\")\nprint(v)","f8cfd2f9":"A = np.array([[1, 2, 3, 4], [3, 4, 5, 6], [6, 7, 8, 9]])\nprint(f\"A: shape {A.shape} - dtype: {A.dtype}\")\nprint(A)","2c9a623e":"data = np.array([[1, 2], [4, 5]])\nprint(data)","ac624c8d":"data = np.zeros(5)\nprint(data)","8161ff4b":"data = np.ones((3, 3))\nprint(data)","d708d3b3":"data = np.arange(5)\nprint(data)","65e2bb65":"arr = np.array([1, 2, 3])\nprint(f\"Original data type: {arr.dtype}\")","5865d47c":"arr = np.float32(arr)\nprint(f\"Converted data type: {arr.dtype}\")","19f6997f":"arr = arr.astype(np.float64)\nprint(f\"Converted data type: {arr.dtype}\")","2b6fb74a":"arr = np.arange(10)\nprint(arr)","3db6d786":"print(arr[1])","211cbd07":"print(arr[-3])","30767638":"print(arr[[0, 1]])","3ca31a0b":"print(arr[5:8])","a5ed96af":"print(arr[:3])","b7961877":"print(arr[3:])","28d6bf9e":"print(arr[:])","586fc83a":"arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])","5939663f":"print(f\"Get a row: {arr[0]} or {arr[0, :]}\")","af16a13c":"print(f\"Get a col: {arr[:, 1]}\")","873edf47":"print(f\"Get an element: {arr[0, 1]} or {arr[0][1]}\")","c210900c":"print(f\"Indexing with slices: {arr[:2, 1:]}\")","1350c000":"arr = np.empty((3, 3, 3))\nprint(arr)","b8c95f34":"print(f\"Get element indexed 0 in the 2nd dimension:\")\nprint(arr[:, 0, :])\nprint(\"---\")\nprint(f\"Get element indexed 0 in the first dimension:\")\nprint(arr[0, :, :])\nprint(\"or\")\nprint(arr[0, ...])\nprint(\"---\")\nprint(f\"Get element indexed 0 in the last dimension:\")\nprint(arr[:, :, 0])\nprint(\"or\")\nprint(arr[..., 0])\nprint(\"---\")","5080ea78":"ids = np.array([1, 2, 3])\nnames = np.array([\"a\", \"b\", \"a\"])","e0e17331":"print(ids[names == \"a\"])","7a124e0b":"arr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\nprint(f\"addition: {arr1 + arr2}\")\nprint(\"---\")\nprint(f\"compare: {arr1 > arr2}\")","31560152":"arr = np.array([1, 2, 3])\nscalar = 3\n\nprint(f\"addition: {arr+scalar}\")\nprint(\"---\")\nprint(f\"multiplication: {arr*scalar}\")\nprint(\"---\")\nprint(f\"power: {arr**scalar}\")\nprint(\"---\")\nprint(f\"compare: {arr == scalar}\")","dc292f9b":"arr1 = np.arange(5)\narr2 = 5 * np.random.rand(5)\nprint(f\"original arrays:\")\nprint(arr1)\nprint(\"and\")\nprint(arr2)\nprint(\"---\")\n\nprint(f\"square root: {np.sqrt(arr1)}\")\nprint(\"---\")\nprint(f\"exponential root: {np.exp(arr1)}\")\nprint(\"---\")\nprint(f\"max: {np.maximum(arr1, arr2)}\")\nprint(\"---\")","f2897142":"arr = np.arange(10)\nprint(f\"original shape: {arr.shape}\")\nprint(f\"original array: {arr}\")\n\narr = arr.reshape((2, 5))\nprint(f\"new shape: {arr.shape}\")\nprint(f\"new array: {arr}\")","0d43d33b":"arr = np.arange(10)\narr = arr.reshape((2, 5))\nprint(f\"original array: {arr}\")\n\nprint(f\"transposed array: {arr.T} or {arr.transpose((1, 0))}\")\n\nprint(f\"swap two axes: {arr.swapaxes(1, 0)}\")","c7e76630":"mat1 = np.random.randint(low=0, high=10, size=(3, 3))\nmat2 = np.random.randint(low=0, high=10, size=(3, 3))\nprint(f\"matrix 1: {mat1}\")\nprint(f\"matrix 2: {mat2}\")\nprint(\"---\")\n\nprint(f\"concatenated matrix (along axis 0): {np.concatenate([mat1, mat2], axis=0)}\")\nprint(f\"concatenated matrix (along axis 1): {np.concatenate([mat1, mat2], axis=1)}\")","18311294":"import matplotlib.pyplot as plt\n\n# generate random numbers\nX = np.random.randint(low=0, high=5, size=(30, 2))\n\n# visualize generated numbers\nplt.plot(X[:, 0], X[:, 1], \"ro\", alpha=0.5)\nplt.show()","25800cc9":"import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# generate random numbers\nmeans = [[2, 2]]\ncov = [[3, 0], [0, 1]]\nN = 1000\nX0 = np.random.multivariate_normal(means[0], cov, N)\n\n# visualize generated numbers\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\n\nax[0].plot(X0[:, 0], X0[:, 1], \"ro\", alpha=0.2)\nax[0].set_title(\"Random 2D points\")\nax[0].set_xlabel(\"X\")\nax[0].set_ylabel(\"Y\")\n\nax[1] = sns.kdeplot(X0[:, 0], X0[:, 1], shade=True)\nax[1].set_title(\"Underlying Gaussian\")\nax[1].set_xlabel(\"X\")\nax[1].set_ylabel(\"Y\")\n\nplt.show()","30e2b9c2":"print(np.random.permutation(10))","5640c9b9":"import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# generate random numbers\nX = np.random.randn(500, 1)\n\n# visualize generated numbers\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\nax[0].plot(X[:, 0], [7e-3]*500, \"ro\", alpha=0.1)\nax[0].set_title(\"Generated data points\")\nax[0].set_xlim([-3, 3])\n\nax[1] = sns.kdeplot(X[:, 0], shade=True)\nax[1].set_title(\"Underlying Gaussian\")\nax[1].set_xlim([-3, 3])\nplt.show()","5cf1aebb":"import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# generate random numbers\nX = np.random.uniform(low=0, high=10, size=(100, 1))\n\n# visualize generated numbers\nplt.plot(X[:, 0], [7e-3]*100, \"ro\", alpha=0.5)\nplt.xlim([0, 10])\nplt.show()","f9ea2a28":"arr = np.random.randint(low=0, high=10, size=(2, 2))\nprint(arr)","96374b67":"print(f\"sum: {arr.sum()} or {np.sum(arr)}\")\nprint(f\"sum along axis 0: {arr.sum(axis=0)} or {np.sum(arr, axis=0)}\")\nprint(f\"argmin: {arr.argmin()} or {np.argmin(arr)}\")\nprint(f\"cumsum: {arr.cumsum()} or {np.cumsum(arr)}\")","0291fe1d":"arr = np.random.randn(300)","135dc6c4":"import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# visualize generated numbers\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\nax[0].plot(arr, [7e-3]*300, \"ro\", alpha=0.1)\nax[0].set_title(\"Generated data points\")\nax[0].set_xlim([-3, 3])\n\nax[1] = sns.kdeplot(arr, shade=True)\nax[1].set_title(\"Underlying Gaussian\")\nax[1].set_xlim([-3, 3])\nplt.show()","c8a11a77":"print(f\"mean: {arr.mean()} or {np.mean(arr)}\")\nprint(f\"std: {arr.std()} or {np.std(arr)}\")\nprint(f\"var: {arr.var()} or {np.var(arr)}\")","9e065cfe":"mat1 = np.random.randint(low=0, high=10, size=(3, 3))\nprint(f\"original matrix:\")\nprint(mat1)\nprint(\"---\")\n\nmat1.sort()\nprint(f\"sorted matrix:\")\nprint(mat1)\nprint(\"---\")\n\nmat1.sort(axis=0)\nprint(f\"sorted along axis 0\")\nprint(mat1)\nprint(\"---\")","9010b150":"mat1 = np.random.randint(low=0, high=10, size=10)\nmat2 = np.random.randint(low=0, high=10, size=8)\nprint(f\"matrix 1: {mat1}\")\nprint(f\"matrix 2: {mat2}\")\nprint(\"---\")\n\nprint(f\"unique elements of mat1: {np.unique(mat1)}\")\nprint(\"---\")\nprint(f\"intersection of mat1 and mat2: {np.intersect1d(mat1, mat2)}\")\nprint(\"---\")\nprint(f\"union of mat1 and mat2: {np.union1d(mat1, mat2)}\")\nprint(\"---\")\nprint(f\"whether each element of mat1 is in mat2 or not: {np.in1d(mat1, mat2)}\")\nprint(\"---\")\nprint(f\"elements in mat1 but not in mat2: {np.setdiff1d(mat1, mat2)}\")\nprint(\"---\")","f4d1c41f":"mat1 = np.random.randint(low=0, high=10, size=(2, 2))\nmat2 = np.random.randint(low=0, high=10, size=(2, 2))\nprint(f\"matrix 1:\")\nprint(mat1)\nprint(f\"matrix 2:\")\nprint(mat2)\nprint(\"---\")\n\nprint(f\"matrix multiplication\")\nprint(np.dot(mat1, mat2))\nprint(\"---\")\nprint(f\"matrix trace\")\nprint(np.trace(mat1))\nprint(\"---\")\nprint(f\"matrix determinant\")\nprint(np.linalg.det(mat1))\nprint(\"---\")\nprint(\"---\")\nprint(f\"matrix pseudo-inverse\")\nprint(np.linalg.pinv(mat1))\nprint(\"---\")","e967edbc":">**NOTE**: Python keywords `and` and `or` don't work with boolean arrays\n\n**Fast element-wise array functions**: ","c2a603b0":"* Option 2: use `arr.astype(np.float32)` if we want to cast `arr.dtype` to `np.float32`","ad1f187e":"### Indexing\n**Single element indexing**:\n* Get the 2nd element of `arr` (i.e. element $1$)","2a0a2df3":"**Other options for creating a ndarray**:\n\n| Function | Description |\n| --- | --- |\n| `array` | Convert input data (list, tuple, etc.) to an ndarray. The input data is copied by default |\n| `asarray` | Convert input to ndarray without copying if the input is an ndarray already |\n| `ones`, `ones_like` | Produce an array of ones given shape and dtype |\n| `zeros`, `zeros_like` | Produce an array of ones given shape and dtype |\n| `empty`, `empty_like` | Create new arrays by allocating new memory with random values |\n| `eye`, `identity` | Create a square $N \\times N$ matrix |\n\n# Data types for ndarrays\n**Data types**:\n* Numerical data type:\n    * Integer: `int8`, `uint8`, `int16`, `uint16`, `int32`, `uint32`, `int64`, `uint64`\n        * Explain: \n            * `int8` is signed 8-bit integer type\n            * `uint8` is unsigned 8-bit integer type\n    * Float: `float16`, `float32`, `float64`, `float128`\n    * Complex numbers: `complex64`, `complex128`, `complex256`\n* Other types:\n    * Boolean: `bool`\n    * Python object type: `object`\n    * String type: `string_`\n    * Unicode: `unicode_`\n\n**Data type casting**: consider the array `arr` $= \\begin{bmatrix} 1 & 2 & 3 \\end{bmatrix}$","7aded0f4":"* Import NumPy","b5e90b5a":"* Transpose array","8c261112":"## Sorting\n* Sort (for 1D array): `arr.sort()`\n* Sort along the 1st axis: `arr.sort(1)`","1aa9be23":"* Slicing the first 3 elements (i.e. $\\begin{bmatrix} 0 & 1 & 2 \\end{bmatrix}$)","4f6296f3":"* Get the 3rd last element of `arr` (i.e. the 3rd element from the right)","925b94c0":"# NumPy ndarray\n## Introduction to ndarray\n**ndarray**: a N-dimensional array object, which is the key features of NumPy\n* Advantages: \n    * Fast, flexible container for datasets in Python\n    * Allow us to perform mathematical operations\n\n\n**Basic attributes of a ndarray**:\n* `ndarray.shape`: return shape of the array\n* `ndarray.dtype`: return the data type of the data in the array\n\n**Example code**:\n* Create one array representing a scalar $c = 1$ with type `float32`","8b2689be":"First, let's visualize the generated numbers in `arr` and their underlying distribution","43189f40":"## Mathematical and statistical methods\n\n| Method | Description |\n| --- | --- |\n| `sum` | Sum of all elements in the array or along an axis. Zero-length arrays have sum $0$ |\n| `mean` | Arithmetic mean. Zero-length arrays have NaN mean |\n| `std`, `var` | Standard deviation and variance |\n| `min`, `max` | Minimum and maximum element in the array |\n| `argmin`, `argmax` | Indices of minimum and maximum elements |\n| `cumsum` | Cumulative sum of elements starting from $0$ |\n| `cumprod` | Cumulative product of elements starting from $1$ |\n\n### Mathematical methods\nConsider the underlying array","0830bda6":"Here is some mathematical methods provided by NumPy to work with `arr`","1183a427":"* Get the 2nd col of `arr` (i.e. $\\begin{bmatrix} 2 \\\\ 5 \\\\ 8 \\end{bmatrix}$)","d3a88624":"* Slicing the whole array (i.e. $\\begin{bmatrix} 0 & 1 & \\cdots & 8 & 9 \\end{bmatrix}$)","5941dade":"\n**Indexing**:","022cff04":"* Concatenate arrays","419856dd":"* Any operations with scalars propagating the scalar to each element","c6b47231":"# Basic operations\n**Operations between arrays and scalars**:\n* Any operations between equal-size arrays applies the operation element-wise","edb51fe3":"### N-d arrays\nConsider a random array with shape $3 \\times 3 \\times 3$","2a7498b4":"We can compute some statistical properties of `arr` using `numpy`","af8a531c":"* Example 2: generate random set of points $\\{\\textbf{x}_i\\}_{i=1}^{1000}$ where $\\textbf{x}_i = (x^{(1)}_i, x^{(2)}_i)$ from multivariate Gaussian with mean $\\begin{bmatrix} 2 \\\\ 2\\end{bmatrix}$ and covariance $\\begin{bmatrix} 3 & 0 \\\\ 0 & 1\\end{bmatrix}$","56ede1e0":"* Create an array with all ones (e.g. $\\begin{bmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{bmatrix}$)","a86e5f64":"# CAUTION\nIf you don't know something, Google it!\n\n# References\n* [NumPy documentation](https:\/\/numpy.org\/doc\/)\n* [NumPy broadcasting](https:\/\/docs.scipy.org\/doc\/numpy-1.15.0\/user\/basics.broadcasting.html) (advanced)\n* Python for Data Analysis (O'reilly)","f3404247":"# Data processing using arrays\n## Random number generation\nWe can use methods of module `numpy.random`\n\n| Method | Description |\n| --- | --- |\n| `seed` | Seed the random number generator |\n| `permutation` | Return a random permutation of a sequence |\n| `shuffle` | Randomly permute a sequence inplace |\n| `rand` | Draw samples from a uniform distribution | \n| `randint` | Draw integers from a given low-to-high range |\n| `randn` | Draw samples from a standard normal distribution |\n| `binomial` | Draw samples from a binomial distribution |\n| `normal` | Draw samples from a normal distribution |\n| `beta` | Draw samples from a beta distribution |\n| `chisquare` | Draw samples from a chisquare distribution |\n| `gamma` | Draw samples from a gamma distribution |\n| `uniform` | Draw samples from a uniform distribution |\n\n* Example 1: generate random set of points $\\{\\textbf{x}_i\\}_{i=1}^{30}$ where $\\textbf{x}_i = (x^{(1)}_i, x^{(2)}_i)$ with $x^{(1)}_i$ and $x^{(2)}_i$ are integers","0fa7d262":"If we want to convert `arr.dtype` to `np.float32`, we have two options:\n* Option 1: use `np.float32(arr)` if we want to cast `arr.dtype` to `np.float32`","0ee1206f":"# Transposing arrays, swapping axes, and concatenation\n* Reshape array","4a2b9648":"* Create one array representing a matrix $\\textbf{A} = \\begin{bmatrix} 1 & 2 & 3 & 4 \\\\ 3 & 4 & 5 & 6 \\\\ 6 & 7 & 8 & 9 \\end{bmatrix}$ whose type is inferred by NumPy","40e63180":"* Unary element-wise functions (example):\n\n| Function | Description |\n| --- | --- |\n| `abs` | Compute the absolute value element-wise |\n| `square` | Compute the square of each element |\n| `exp` | Compute the exponent $e^x$ of each element |\n| `log`, `log10`, `log2` | Compute the logarithms of each element |\n| `sign` | Compute the sign of each element |\n| `floor`, `ceil` | Compute the floor and ceiling of each element |\n| `round` | Round each element |\n| `isnan` | Check if each element is `np.nan` (not a number) or not |\n| `isfinite`, `isinf` | Check if each element is finite or infinite |\n| `cos`, `cosh`, `sin`, `sinh`, `tan`, `tanh` | Regular and hyperbolic trigonometric functions |\n| `arccos`, `arccosh`, `arcsin`, `arcsinh`, `arctan`, `arctanh` | Inverse trigonometric functions |\n| `logical_not` | Logical not element-wise |\n\n* Binary element-wise functions (example):\n\n| Function | Description |\n| --- | --- |\n| `add`, `subtract`, `multiply`, `divide`, `mod` | Basic operations element-wise |\n| `floor_divide` | Floor divide (truncate the remainder) elementwise |\n| `power` | Power elementwise | \n| `maximum`, `minimum` | Maximum and minimum elementwise |\n| `logical_and`, `logical_or`, `logical_xor` | Binary logical functions elementwise |","442a8a09":"* Example 4: generate random numbers from Standard Gaussian","441863ce":"## Unique and other set logic\n\n| Method | Description |\n| --- | --- |\n| unique(x) | Compute the sorted, unique elements in `x` |\n| `intersect1d(x, y)` | Compute the sorted, common elements in 1D arrays `x` and `y` |\n| `union1d(x, y)` | Compute the sorted, union of elements in 1D arrays `x` and `y` |\n| `in1d(x, y)` | Compute a boolean array indicating whether each element of `x` is in `y` |\n| `setdiff1d(x, y)` | Set difference, elements in `x` and not in `y` |","1fd8c16b":"* Slicing the elements from the 3rd element till the last element (i.e. $\\begin{bmatrix} 3 & 4 & \\cdots 8 & 9 \\end{bmatrix}$)","5adc2e1a":"* Create an array with elements ranging from $0$ to $4$ (i.e. $\\begin{bmatrix} 0 & 1 & 2 & 3 & 4 \\end{bmatrix}$)","f31d9fa2":"* Create one array representing a row vector $\\textbf{v} = \\begin{bmatrix} 1 & 2 & 3 \\end{bmatrix}$ with type `int32`","1d9feeab":">**NOTE**: multiple element indexing isn't applied to Python `list`","dd937b1d":"* Example 3: generate random permutation of integers $0, 1, 2, ..., 9$","3782faeb":"## Creating ndarray\n**Create pre-specified elements**: we can create the matrix $\\begin{bmatrix} 1 & 2 \\\\ 4 & 5 \\end{bmatrix}$ with the code below","929282d1":"### Slicing\n* Get a slide from the 5th element to the 8th element (i.e. $\\begin{bmatrix} 5 & 6 & 7 \\end{bmatrix}$)","ebbcc6f4":"**Create some special arrays**:\n* Create an array with all zeros (e.g. $\\begin{bmatrix} 0 & 0 & 0 & 0 & 0 \\end{bmatrix}$)[](http:\/\/)","dc37468c":"* Get element `arr`$_{0, 1}$ (i.e. $2$)","cc919d28":"* Example 5: generate random numbers from uniform distribution within interval $[0, 10]$","e1581e77":"We can get the IDs of students named $a$ by the following code","11a29800":"**Multiple element indexing**:\n* Get the 1st and the 2nd elements of `arr` (i.e. elements $0$ and $1$)","6052bae9":"* Get the submatrix $\\begin{bmatrix} 2 & 3 \\\\ 5  & 6 \\end{bmatrix}$ with slicing","c846f3de":"## Linear algebra\nWe can use the methods of module `numpy.linalg`\n\n| Method | Description |\n| --- | --- |\n| `diag` | Return the diagonal elements of a square matrix as a 1D array, or convert a 1D array into a diagonal matrix |\n| `dot` | Matrix multiplication |\n| `trace` | Compute matrix trace |\n| `det` | Compute matrix determinant |\n| `eig` | Compute the eigenvalues and eigenvectors of a square matrix | \n| `inv` | Compute the inverse of a square matrix |\n| `pinv` | Compute the pseudo-inverse of a square matrix |\n| `qr` | Compute the QR decomposition of a matrix | \n| `svd` | Compute the SVD of a matrix |\n| `solve` | Solve the linear system $A x = b$ |\n| `lstsq` | Compute the least-squares solution to $y = X b$ |`","0d2e01c3":"# Introduction to NumPy\n**NumPy**: short for Numerical Python, the fundamental package required for high performance scientific computing and analysis\n\n**Utilities provided by NumPy**:\n* `ndarray`, a fast and space-efficient multi-dimensional array for vectorized arithmetic operations with sophisticated broadcasting mechanism\n* Standard mathematical operations and matrix operations\n* Linear algebra, random number generators, Fourier transform, etc.\n\n**Setup**:\n* Install NumPy","eeb4451a":"### Statistical methods\nConsider the underlying array","5be04d2b":"# Indexing and slicing\n## 1D arrays\nConsider array `arr` $= \\begin{bmatrix} 0 & 1 & \\cdots & 8 & 9 \\end{bmatrix}$","3520d4ce":"## Advanced indexing\n**Boolean indexing**: if we have an array of student names $\\begin{bmatrix} a & b & a \\end{bmatrix}$ and an array of their IDs $\\begin{bmatrix} 1 & 2 & 3 \\end{bmatrix}$","fe7d894b":"## Higher-dimensional indexing\n### 2D arrays\nConsider `arr` $= \\begin{bmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{bmatrix}$","b6b0fd21":"**Indexing**:\n* Get the 1st row of `arr` (i.e. $\\begin{bmatrix} 1 & 2 & 3 \\end{bmatrix}$)"}}