{"cell_type":{"69e22c57":"code","000aaf35":"code","ad255538":"code","0c801100":"code","fbb7f42a":"code","9863297b":"code","f0dbb19b":"code","6d8c0ddd":"code","984774fd":"code","fb15c7ec":"code","e5070dc0":"code","b52d09bc":"code","cf824b01":"code","16745a6c":"code","cf5e047f":"code","60e2c5f8":"code","33ead1ab":"code","99e7ac67":"code","1f90ebde":"code","9641190e":"code","e384d759":"code","5068e888":"code","05bf7cec":"code","4c6b8da9":"code","25084af5":"code","3cc4565e":"code","b01c212b":"code","59c16bd4":"code","3aaa374a":"code","232470b4":"code","f144844c":"code","403fa2c6":"code","a6659bb6":"code","0222b5cf":"code","a809bc86":"code","c53e55b1":"code","722748af":"code","a9305dad":"code","2c57a881":"code","9ad6e9bf":"code","c4cc901e":"code","b3e2eade":"code","41ff5f54":"code","3ab0506b":"code","82417784":"code","e6b87ace":"code","c149d260":"code","933c448b":"code","250a4b92":"code","cd0ee662":"code","fe1fcf8b":"code","115c0036":"code","fb299aa9":"code","1bec1256":"code","bfc51946":"code","b5c4a429":"code","ffe93ace":"code","5cf8b27e":"code","103e52aa":"code","e933a9ac":"code","6baa9f8a":"code","a8e4efb5":"code","32102b6b":"code","2f1e99ff":"code","1e1b24bd":"code","2cc01400":"code","cc6b5c35":"markdown","5978f0b2":"markdown","b086cd69":"markdown","3b3508a3":"markdown","ee627616":"markdown","c6d12d4c":"markdown","eccfcf49":"markdown","5b9fca50":"markdown","7f839314":"markdown","aa27edda":"markdown","4cb01471":"markdown","0411d400":"markdown","01484f6f":"markdown","62c9621a":"markdown","a302a375":"markdown","8c5843c9":"markdown","c1ed3507":"markdown","1b1acb96":"markdown","62b7d1e1":"markdown","d3f1ccc6":"markdown","58261594":"markdown","4b4fdace":"markdown","2d0fe4e0":"markdown","11f85aaf":"markdown","e82127ae":"markdown","cf605d33":"markdown","28a61123":"markdown","378465e1":"markdown","c2b55a9b":"markdown","aceb5939":"markdown","02c40f2b":"markdown","450ef20f":"markdown","af6f50c5":"markdown"},"source":{"69e22c57":"%matplotlib inline\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport io, base64, os, json, re \nimport pandas as pd\nimport numpy as np\nimport datetime\nfrom random import randint\nimport requests\nimport time  as _time\nfrom IPython.display import HTML\nfrom datetime import datetime","000aaf35":"from pandas.plotting import register_matplotlib_converters\nregister_matplotlib_converters()","ad255538":"pip install yfinance","0c801100":"import yfinance as yf","fbb7f42a":"from pandas_datareader import data as pdr\nyf.pdr_override() # <== that's all it takes :-)\n\nstockdata = pdr.get_data_yahoo(  # or pdr.get_data_yahoo(...\n        # tickers list or string as well\n        tickers = \"^NSEI\",\n                             #tickers = \"SPY AAPL MSFT\",    !!!!!! to get multiple stocks at once\n\n        # use \"period\" instead of start\/end\n        # valid periods: 1d,5d,1mo,3mo,6mo,1y,2y,5y,10y,ytd,max\n        # (optional, default is '1mo')\n        period = None,\n    \n        start='2020-06-01', end='2021-5-31',\n\n        # fetch data by interval (including intraday if period < 60 days)\n        # valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo\n        # (optional, default is '1d')\n        interval = \"1d\",\n\n        # group by ticker (to access via data['SPY'])\n        # (optional, default is 'column')\n        group_by = 'ticker',\n\n        # adjust all OHLC automatically\n        # (optional, default is False)\n        auto_adjust = True,\n\n        # download pre\/post regular market hours data\n        # (optional, default is False)\n        prepost = True,\n\n        # use threads for mass downloading? (True\/False\/Integer)\n        # (optional, default is True)\n        threads = True,\n\n        # proxy URL scheme use use when downloading?\n        # (optional, default is None)\n        proxy = None\n    )","9863297b":"prices=pd.DataFrame([stockdata.index, stockdata.Close], ['Date', 'Close'])\nprices=prices.T","f0dbb19b":"plt.figure(figsize = (15, 5))\nplt.plot(prices['Date'], prices['Close'])\nplt.xlabel('Days')\nplt.ylabel('Stock Prices')\nplt.show()","6d8c0ddd":"xdata = np.arange(len(prices['Close']))\nfrom scipy.optimize import curve_fit\ndef sigmoid(x, L ,x0, k, b):\n    y = L \/ (1 + np.exp(-k*(x-x0)))+b\n    return (y)\n\np0 = [max(prices['Close'].values), np.median(xdata),1,min(prices['Close'].values)] # this is an mandatory initial guess\n\npopt, pcov = curve_fit(sigmoid, xdata, prices['Close'].values,p0, method='dogbox')\nx = np.linspace(0, len(xdata), 1000)\ny = sigmoid(x, *popt)\nplt.figure(figsize = (15, 5))\nplt.plot(xdata, prices['Close'], 'o', label='data')\nplt.plot(x,y, label='fit')\nplt.legend(loc='best')","984774fd":"means=[]\ndevs=[]\nstrings = ['2021-4-30', '2021-3-30', '2021-2-28', '2021-1-30', '2020-12-30', '2020-11-30', '2020-10-30', '2020-9-20', '2020-8-30', '2020-7-30', '2020-6-30', '2020-5-30']\nfor i in range(len(strings)):\n    stockdata = pdr.get_data_yahoo(\n            tickers = \"^NSEI\",\n            period = None,\n            start=strings[i], \n            end='2021-5-31',\n            interval = \"1d\",\n            group_by = 'ticker',\n            auto_adjust = True,\n            prepost = True,\n            threads = True,\n            proxy = None\n        )\n    \n    prices=pd.DataFrame([stockdata.index, stockdata.Close], ['Date', 'Close'])\n    prices=prices.T\n    \n    So = prices.loc[prices.shape[0] - 1, \"Close\"]\n    dt = 1\n    pred_end_date = '2021-06-30 03:45:00'\n    start_date = str(prices['Date'][0])\n    end_date = str(prices['Date'].iloc[-1])\n    n_of_wkdays = pd.date_range(start = pd.to_datetime(end_date, \n                  format = \"%Y-%m-%d %H:%M:%S\") + pd.Timedelta('1 days'), \n                  end = pd.to_datetime(pred_end_date, \n                  format = \"%Y-%m-%d %H:%M:%S\")).to_series(\n                  ).map(lambda x: \n                  1 if x.isoweekday() in range(1,6) else 0).sum()\n    T = n_of_wkdays\n    N = T \/ dt\n    t = np.arange(1, int(N) + 1)\n    returns = (prices.loc[1:, 'Close'] - \\\n              prices.shift(1).loc[1:, 'Close']) \/ \\\n              prices.shift(1).loc[1:, 'Close']\n    mu = np.mean(returns)\n    sigma = np.std(returns)\n    scen_size = 6\n    b = {str(scen): np.random.normal(0, 1, int(N)) for scen in range(1, scen_size + 1)}\n    W = {str(scen): b[str(scen)].cumsum() for scen in range(1, scen_size + 1)}\n    drift = (mu - 0.5 * sigma**2) * t\n    diffusion = {str(scen): sigma * W[str(scen)] for scen in range(1, scen_size + 1)}\n    S = np.array([So * np.exp(drift + diffusion[str(scen)]) for scen in range(1, scen_size + 1)]) \n    S = np.hstack((np.array([[So] for scen in range(scen_size)]), S))\n    means.append(mu)\n    devs.append(sigma)    ","fb15c7ec":"new = pd.DataFrame(list(zip(means, devs)), columns =['means', 'devs'])\nnew","e5070dc0":"new.mean()","b52d09bc":"    mu = new.means.mean()\n    sigma = new.devs.mean()\n    scen_size = 200\n    b = {str(scen): np.random.normal(0, 1, int(N)) for scen in range(1, scen_size + 1)}\n    W = {str(scen): b[str(scen)].cumsum() for scen in range(1, scen_size + 1)}\n    drift = (mu - 0.5 * sigma**2) * t\n    diffusion = {str(scen): sigma * W[str(scen)] for scen in range(1, scen_size + 1)}\n    S = np.array([So * np.exp(drift + diffusion[str(scen)]) for scen in range(1, scen_size + 1)]) \n    S = np.hstack((np.array([[So] for scen in range(scen_size)]), S))\n    plt.figure(figsize = (20,10))\n    means.append(mu)\n    devs.append(sigma)\n\n    for i in range(scen_size):\n        plt.title(\"Daily Volatility: \" + str(sigma))\n        plt.plot(pd.date_range(start = prices[\"Date\"].max(), \n                    end = pred_end_date, freq = 'D').map(lambda x:\n                    x if x.isoweekday() in range(1, 6) else np.nan).dropna(), S[i, :])\n        plt.ylabel('Stock Prices, \u20ac')\n        plt.xlabel('Prediction Days')\n    plt.show()","cf824b01":"b = np.random.normal(0, 1, int(N))\/10\np = b.cumsum()\nrr=0.08\np  = sigma*np.exp(p + rr*(sigma-p))\nplt.figure(figsize = (20,10))\nplt.plot(p)","16745a6c":"plt.figure(figsize = (20,10))\n\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\ntheta = 0.1\nmu = 15500\nsigma = 0.011\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndrift = lambda y,t: theta*(mu-y) # define drift term, google to learn about lambda\ndiffusion = lambda y,t: sigma*y # define diffusion term\n\nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt)\n    for i in range(1,length):\n        y[i] = y[i-1] + drift(y[i-1],i*dt)*dt + diffusion(y[i-1],i*dt)*noise[i]\n\n    plt.plot(t,y)\nplt.show()\n\n","cf5e047f":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\ntheta = 0.1\nmu = 15500\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ny0 = np.random.normal(loc=0.0,scale=1.0) # initial condition\ndrift = lambda y,t: theta*(mu-y) # define drift term, google to learn about lambda\nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    for i in range(1,length):\n        diffusion = lambda y,t: p[i-1]*y\n        y[i] = y[i-1] + drift(y[i-1],i*dt)*dt + diffusion(y[i-1],i*dt)*noise[i]\n    plt.plot(t,y)\nplt.show()\n","60e2c5f8":"def ema(x, n):\n    x = np.asarray(x)\n\n    weights = np.exp(np.linspace(-1., 0., n))\n\n    weights \/= weights.sum()\n\n    a =  np.convolve(x, weights, mode='full')[:len(x)]\n    a[:n] = x[0]\n    return a","33ead1ab":"plt.figure(figsize = (20,10))\nplt.plot(t,y)\nplt.plot(ema(y, 9))\nplt.show()","99e7ac67":"b1 = np.random.normal(0, 1, 250)\/10\np1 = b1.cumsum()\np1  = sigma*np.exp(p1 + rr*(sigma-p1))\nplt.figure(figsize = (20,10))\nplt.plot(p1)","1f90ebde":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 250\nlength = 250\ntheta = 0.1\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndrift = lambda y,t: theta*(mu-y) # define drift term, google to learn about lambda\n\nnoise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n# solve SDE\nemaplot = []\nfor i in range(1,length): \n    mu = ema(y[:i], 20)[-1]\n    diffusion = lambda y,t: p1[i-1]*y\n    y[i] = y[i-1] + drift(y[i-1],i*dt)*dt + diffusion(y[i-1],i*dt)*noise[i]\n    emaplot.append(mu)\n\nplt.plot(t,y)\nplt.plot(emaplot)\nplt.show()\n","9641190e":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\ntheta = 0.1\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndrift = lambda y,t: theta*(mu-y) # define drift term, google to learn about lambda\nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: p[i-1]*y\n        y[i] = y[i-1] + drift(y[i-1],i*dt)*dt + diffusion(y[i-1],i*dt)*noise[i]\n        emaplot.append(mu)\n    plt.plot(t,y)\n\nplt.show()\n","e384d759":"t_0 = 0 # define model parameters\nt_end = 250\nlength = 250\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1 + 0.01\nrate2 = 1+ 0.01\naction1 = 14900\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action):\n    if (action-y)<0:\n        return maxi2*(rate2**(action-y))\n    elif (action-y)>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nnoise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n# solve SDE\nemaplot = []\nfor i in range(1,length): \n    mu = ema(y[:i], 20)[-1]\n    diffusion = lambda y,t: p1[i-1]*y\n    y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + drift1(y[i-1], action1)*dt\n    emaplot.append(mu)\nplt.figure(figsize = (20,10))    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-b')\n\nplt.plot(t,y)\nplt.plot(emaplot)\nplt.show()\n","5068e888":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift\nmaxi2 = 200  #at y-action = 0, value of drift1 = maxi2\nrate1 = 1 + 0.01\nrate2 = 1 + 0.01\naction1 = 14700\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: p[i-1]*y\n        y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + drift1(y[i-1], action1)*dt\n        emaplot.append(mu)\n    plt.plot(t,y)\n    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-b')\n\n\nplt.show()\n","05bf7cec":"t_0 = 0 # define model parameters\nt_end = 250\nlength = 250\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1 + 0.01\nrate2 = 1 + 0.01\naction1 = 14500\naction2 = 15500\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nnoise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n# solve SDE\nemaplot = []\nfor i in range(1,length): \n    mu = ema(y[:i], 9)[-1]\n    diffusion = lambda y,t: p1[i-1]*y\n    forces = drift1(y[i-1], action1)*dt + drift1(y[i-1], action2)*dt\n    y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n    emaplot.append(mu)\nplt.figure(figsize = (20,10))    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\nplt.plot(t,y)\nplt.plot(emaplot)\nplt.show()\n","4c6b8da9":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1.01\nrate2 = 1.01\naction1 = 14500\naction2 = 15500\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: p[i-1]*y\n        forces = drift1(y[i-1], action1)*dt + drift1(y[i-1], action2)*dt\n        y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n        emaplot.append(mu)\n    plt.plot(t,y)    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\n\nplt.show()\n","25084af5":"t_0 = 0 # define model parameters\nt_end = 250\nlength = 250\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1 + 0.01\nrate2 = 1 + 0.01\naction1 = 14500\naction2 = 15500\ntrend = np.linspace(14400, 15600, length)\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action, maxi2):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nnoise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n# solve SDE\nemaplot = []\nfor i in range(1,length): \n    mu = ema(y[:i], 9)[-1]\n    diffusion = lambda y,t: p1[i-1]*y\n    forces = drift1(y[i-1], action1, maxi2)*dt + drift1(y[i-1], action2, maxi2)*dt + drift1(y[i-1], trend[i-1], 300)\n    y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n    emaplot.append(mu)\nplt.figure(figsize = (20,10))    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\nplt.plot(trend, '-r')\n\nplt.plot(t,y)\nplt.plot(emaplot)\nplt.show()\n","3cc4565e":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1.01\nrate2 = 1.01\naction1 = 14500\naction2 = 15500\ntrend = np.linspace(14500, 16000, length)\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action, maxi2):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: p[i-1]*y\n        forces = drift1(y[i-1], action1, maxi2)*dt + drift1(y[i-1], action2, maxi2)*dt + drift1(y[i-1], trend[i-1], 300)\n        y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n        emaplot.append(mu)\n    plt.plot(t,y)    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\nplt.plot(trend, '-r')\n\nplt.show()\n","b01c212b":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 250\nlength = 250\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1.01\nrate2 = 1.01\naction1 = 14500\naction2 = 15500\ntrend = np.linspace(14000, 16000, length)\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y, mu, maxi1):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action, maxi2):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: p1[i-1]*y\n        forces = drift1(y[i-1], action1, maxi2)*dt + drift1(y[i-1], action2, maxi2)*dt + drift1(y[i-1], trend[i-1], 300)\n        y[i] = y[i-1] + drift(y[i-1], mu, maxi1)*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n        emaplot.append(mu)\n    plt.plot(t,y)    \n    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\nplt.plot(trend, '-r')\n\nplt.show()\n","59c16bd4":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 250\nlength = 250\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1.01\nrate2 = 1.01\ntrend = np.linspace(15000, 16000, length)\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y, mu, maxi1):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action, maxi2):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: p1[i-1]*y\n        forces = drift(y[i-1], trend[i-1], 400)\n        y[i] = y[i-1] + drift(y[i-1], mu, maxi1)*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n        emaplot.append(mu)\n    plt.plot(t,y)    \n\nplt.plot(trend, '-r')\n\nplt.show()\n","3aaa374a":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 250\nlength = 250\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1.01\nrate2 = 1.01\naction1 = 14500\naction2 = 15500\ntrend = np.linspace(15000, 16000, length)\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y, mu, maxi1):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action, maxi2):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: p1[i-1]*y\n        forces = drift1(y[i-1], action1, maxi2)*dt + drift1(y[i-1], action2, maxi2)*dt + drift(y[i-1], trend[i-1], 100)\n        y[i] = y[i-1] + drift(y[i-1], mu, maxi1)*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n        emaplot.append(mu)\n    plt.plot(t,y)    \n    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\nplt.plot(trend, '-r')\n\nplt.show()\n","232470b4":"def volf():\n    b = np.random.normal(0, 1, 23)\/10\n    p = b.cumsum()\n    rr=0.08\n    p  = ((2*sigma)\/(1+np.exp((-2)*(p + rr*(sigma-p)))))\n    return p","f144844c":"def volf1():\n    b1 = np.random.normal(0, 1, 250)\/10\n    p1 = b1.cumsum()\n    p1  = (2*sigma)\/(1+np.exp((-2)*(p1 + rr*(sigma-p1))))\n    return p1","403fa2c6":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\ntheta = 0.1\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndrift = lambda y,t: theta*(mu-y) # define drift term, google to learn about lambda\nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n    v = volf()\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: v[i-1]*y\n        y[i] = y[i-1] + drift(y[i-1],i*dt)*dt + diffusion(y[i-1],i*dt)*noise[i]\n        emaplot.append(mu)\n    plt.plot(t,y)\n\nplt.show()\n","a6659bb6":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift\nmaxi2 = 200  #at y-action = 0, value of drift1 = maxi2\nrate1 = 1 + 0.01\nrate2 = 1 + 0.01\naction1 = 14700\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n    v = volf()\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: v[i-1]*y\n        y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + drift1(y[i-1], action1)*dt\n        emaplot.append(mu)\n    plt.plot(t,y)\n    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-b')\n\n\nplt.show()\n","0222b5cf":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1.01\nrate2 = 1.01\naction1 = 14500\naction2 = 15500\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n    v = volf()\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: v[i-1]*y\n        forces = drift1(y[i-1], action1)*dt + drift1(y[i-1], action2)*dt\n        y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n        emaplot.append(mu)\n    plt.plot(t,y)    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\n\nplt.show()\n","a809bc86":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1.01\nrate2 = 1.01\naction1 = 14500\naction2 = 15500\ntrend = np.linspace(14500, 16000, length)\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action, maxi2):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n    v = volf()\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: v[i-1]*y\n        forces = drift1(y[i-1], action1, maxi2)*dt + drift1(y[i-1], action2, maxi2)*dt + drift1(y[i-1], trend[i-1], 300)\n        y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n        emaplot.append(mu)\n    plt.plot(t,y)    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\nplt.plot(trend, '-r')\n\nplt.show()","c53e55b1":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 250\nlength = 250\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1.01\nrate2 = 1.01\naction1 = 14500\naction2 = 15500\ntrend = np.linspace(14000, 16000, length)\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y, mu, maxi1):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action, maxi2):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n    v1 = volf1()\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: v1[i-1]*y\n        forces = drift1(y[i-1], action1, maxi2)*dt + drift1(y[i-1], action2, maxi2)*dt + drift1(y[i-1], trend[i-1], 300)\n        y[i] = y[i-1] + drift(y[i-1], mu, maxi1)*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n        emaplot.append(mu)\n    plt.plot(t,y)    \n    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\nplt.plot(trend, '-r')\n\nplt.show()\n","722748af":"plt.figure(figsize = (20,10))\nt_0 = 0 # define model parameters\nt_end = 250\nlength = 250\nmaxi1 = 200  #(max1)\/2 is the max possible value of drift1\nmaxi2 = 200  #at y-action = 0, value of drift2 = 0.3\nrate1 = 1.01\nrate2 = 1.01\naction1 = 14500\naction2 = 15500\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndef drift(y):\n    return (maxi1\/(1+rate1**(y-mu)) - (maxi1)\/2)\ndef drift1(y,action):\n    if action-y<0:\n        return maxi2*(rate2**(action-y))\n    elif action-y>0:\n        return -maxi2*(rate2**(y-action))\n    else:\n        return 0\n    \nfor x in range(200):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n    v1 = volf1()\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: v1[i-1]*y\n        forces = drift1(y[i-1], action1)*dt + drift1(y[i-1], action2)*dt\n        y[i] = y[i-1] + drift(y[i-1])*dt + diffusion(y[i-1],i*dt)*noise[i] + forces\n        emaplot.append(mu)\n    plt.plot(t,y)    \nxline = np.linspace(0,length,100)\nyline = 0*xline + action1                #2*xline+1\nplt.plot(xline, yline, '-k')\n\nxline = np.linspace(0,length,100)\nyline = 0*xline + action2                \nplt.plot(xline, yline, '-k')\n\n\nplt.show()","a9305dad":"fig, (ax1, ax2) = plt.subplots(2, figsize = (20,20))\nt_0 = 0 # define model parameters\nt_end = 23\nlength = 23\ntheta = 0.1\nt = np.linspace(t_0,t_end,length) # define time axis\ndt = np.mean(np.diff(t))\ny = np.zeros(length)\ny[0] = 15000\ndrift = lambda y,t: theta*(mu-y) # define drift term, google to learn about lambda\nplt.figure(figsize = (20,10))\nfor x in range(1000):\n    noise = np.random.normal(loc=0.0,scale=1.0,size=length)*np.sqrt(dt) #define noise process\n    # solve SDE\n    emaplot = []\n    v = volf()\n    ax1.plot(v)\n    for i in range(1,length): \n        mu = ema(y[:i], 9)[-1]\n        diffusion = lambda y,t: v[i-1]*y\n        y[i] = y[i-1] + drift(y[i-1],i*dt)*dt + diffusion(y[i-1],i*dt)*noise[i]\n        emaplot.append(mu)\n    ax2.plot(t,y)\n\nplt.show()\n","2c57a881":"stockdata = pdr.get_data_yahoo(\n        tickers = \"COALINDIA.NS\",\n        period = '60d',\n        interval = \"5m\",\n        group_by = 'ticker',\n        auto_adjust = True,\n        prepost = True,\n        threads = True,\n        proxy = None\n    )","9ad6e9bf":"stockdata","c4cc901e":"prices=pd.DataFrame([stockdata.index, stockdata.Close], ['Date', 'Close'])\nprices=prices.T\n\nSo = prices.loc[prices.shape[0] - 1, \"Close\"]\npred_end_date = '2021-08-07 03:45:00'     #edit this\nstart_date = str(prices['Date'][0])\nend_date = str(prices['Date'].iloc[-1])\nN = len(stockdata)\nt = np.arange(1, int(N) + 1)\nreturns = (prices.loc[1:, 'Close'] - \\\n          prices.shift(1).loc[1:, 'Close']) \/ \\\n          prices.shift(1).loc[1:, 'Close']\nmu = np.mean(returns)\nsigma = np.std(returns)\nscen_size = 6\nb = {str(scen): np.random.normal(0, 1, int(N)) for scen in range(1, scen_size + 1)}\nW = {str(scen): b[str(scen)].cumsum() for scen in range(1, scen_size + 1)}\ndrift = (mu - 0.5 * sigma**2) * t\ndiffusion = {str(scen): sigma * W[str(scen)] for scen in range(1, scen_size + 1)}\nS = np.array([So * np.exp(drift + diffusion[str(scen)]) for scen in range(1, scen_size + 1)]) \nS = np.hstack((np.array([[So] for scen in range(scen_size)]), S)) ","b3e2eade":"plt.figure(figsize = (20,10))\nx = np.linspace(0,int(N),int(N))\nplt.plot(x, prices['Close'])","41ff5f54":"print(mu, sigma)","3ab0506b":"returns","82417784":"plt.figure(figsize = (20,10))\nplt.plot(ema(prices['Close'], 30))\nplt.plot(prices['Close'])","e6b87ace":"plt.figure(figsize = (20,10))\nplt.plot(ema(prices['Close'], 200))\nplt.plot(prices['Close'])","c149d260":"plt.figure(figsize = (20,10))\nplt.plot(ema(prices['Close'], 30)-prices['Close'])","933c448b":"plt.figure(figsize = (20,10))\nplt.plot(ema(prices['Close'], 200)-prices['Close'])","250a4b92":"plt.figure(figsize = (20,10))\nplt.plot((ema(prices['Close'], 30)-prices['Close'])\/prices['Close'])","cd0ee662":"plt.figure(figsize = (20,10))\nplt.plot((ema(prices['Close'], 200)-prices['Close'])\/prices['Close'])","fe1fcf8b":"returns*(prices['Close'])","115c0036":"plt.figure(figsize = (20,10))\nplt.plot(ema(prices['Close'], 30)[:int(N-1)]-prices['Close'][:int(N-1)], returns*prices['Close'][1:], 'o')","fb299aa9":"x=np.array(ema(prices['Close'], 200)[:int(N-1)]-prices['Close'][:int(N-1)])","1bec1256":"y=np.array(returns*prices['Close'][1:])","bfc51946":"print(x[0], y[0])","b5c4a429":"plt.figure(figsize = (20,10))\nplt.plot(np.array(ema(prices['Close'], 200)[:int(N-1)]-prices['Close'][:int(N-1)]), np.array(returns*prices['Close'][1:]), 'o')","ffe93ace":"file = (ema(prices['Close'], 30)[:int(N-1)]-prices['Close'][:int(N-1)])\/prices['Close'][:int(N-1)]","5cf8b27e":"filex = []\nfor i in range(1,int(N-1)):\n    filex.append(file[i]-file[i-1])","103e52aa":"plt.figure(figsize = (20,10))\nplt.plot(filex)","e933a9ac":"plt.figure(figsize = (20,10))\nplt.hist(filex, bins=300)","6baa9f8a":"prices['Close']","a8e4efb5":"xplo=np.array(prices['Close'][:4419])\nyplo=np.array(prices['Close'][1:])","32102b6b":"print(xplo, yplo)","2f1e99ff":"returns","1e1b24bd":"plt.plot(xplo, yplo, 'o')","2cc01400":"plt.plot(xplo, returns, 'o')","cc6b5c35":"using the values of distribution from the 12mo data alone, there is 4% prob that stock price after 30days is between 42.27 and 46.14 ","5978f0b2":"not really a sigmoid(?)","b086cd69":"here it looks correct, when its largely deviated from 0, it tries to return","3b3508a3":"trendline","ee627616":"p = np.linspace(0.011, 0.011, 23)  \np1 = np.linspace(0.011, 0.011, 250)\n\n#use these for const volatility","c6d12d4c":"adding price action","eccfcf49":"# calibration","5b9fca50":"# trying to fit it to sigmoid, might be better that exp, for brownian motion (?)","7f839314":"clearly this seems wrong","aa27edda":"# adding price action","4cb01471":"this model implies that the parameters of gbm are continuously changing, can be thought of as a parallel to 'n' period moving average. very similar to bollinger band in theory","0411d400":"# more action","01484f6f":"# adding aversive trendline","62c9621a":"# trying to fit","a302a375":"using 12mo data to predict future, so So is the current(initial) price","8c5843c9":"more action","c1ed3507":"# sigmafunc for long plots","1b1acb96":"mean reversion to ema","62b7d1e1":"comparing against 250 day model without trendline","d3f1ccc6":"p  = sigma np.exp(p + rr*(sigma-p)), consider as c (e^x)    \n\nthe new func used is sigmoid, but it has the same value AND slope as this exp at x=0","58261594":"# only mean reversion","4b4fdace":"# EMA","2d0fe4e0":"# plot of prices","11f85aaf":"# changing trendline to be reversive","e82127ae":"this function by itself can be modelled easily by a mean reversion simple brownian motion model. we can use the data from that to fit to our model, by maybe converting our equation a bit. This function also accounts for volatility also\n\ncan use same method as above, find sigma\/mu for last n months and average","cf605d33":"normalising by price","28a61123":"without price action, the logic is to fit the mean reversion sigmoid curve first, and then finding value of sigma, as that term only adds noise centered around 0.","378465e1":"https:\/\/www.desmos.com\/calculator\/i0bkmfpqgw    for calibration","c2b55a9b":"# sigmafunc for small plots","aceb5939":"taking an average of all the above brownian motion equations and paths would give another gbm which prioritises newer data opposed to old, because it takes past month into consideration 12 times, but the first month data is only considered once","02c40f2b":"# mean reversion with stochastic volatility","450ef20f":"# stochastic volatility func is generated for each path","af6f50c5":"# mean reversion to EMA"}}