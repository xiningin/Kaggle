{"cell_type":{"ab91872f":"code","50083a3f":"code","a901d0b9":"code","23cd1282":"code","974644c8":"code","9c82bb00":"code","8bd35ac7":"code","41773ab7":"code","cd9761f4":"code","e19d1e65":"code","0ec848fa":"markdown","811bb32f":"markdown","10970430":"markdown"},"source":{"ab91872f":"import numpy as np\nimport os\nimport torch\nimport pandas as pd\nimport cv2\nfrom torch import nn\nfrom torchvision import transforms\nfrom sklearn.model_selection import train_test_split","50083a3f":"petdf = pd.read_csv('..\/input\/petfinder-pawpularity-score\/train.csv')\n# petdf = petdf[(petdf.Pawpularity < 25) | (petdf.Pawpularity > 75)]\n\ntrain_df, test_df = train_test_split(petdf, test_size=0.2)\ntrain_df, test_df = train_df.reset_index(), test_df.reset_index()","a901d0b9":"class PawpularDataset:\n    def __init__(self, image_ids, pawpularity):\n        self.image_ids = image_ids\n        print(self.image_ids)\n        self.pawpularity = pawpularity\n        \n    def __len__(self):\n        return len(self.image_ids)\n    \n    def __getitem__(self, item):\n        embedding = np.load(os.path.join(\n            '..\/input\/petfinder-msvision-features\/embeddings\/ms_vision',\n            self.image_ids[item] + '.npy'\n        ))\n        return {\n            \"embedding\": embedding,\n            \"pawpularity\": self.pawpularity[item],\n        }","23cd1282":"train_data = PawpularDataset(train_df.Id, train_df.Pawpularity)\ntest_data = PawpularDataset(test_df.Id, train_df.Pawpularity)\ntrain_loader = torch.utils.data.DataLoader(train_data, batch_size=128, shuffle=True)\ntest_loader = torch.utils.data.DataLoader(train_data, batch_size=128, shuffle=False)","974644c8":"model = nn.Sequential(\n  nn.Linear(4096, 1024),\n  nn.ReLU(),\n  nn.Linear(1024, 512),\n  nn.ReLU(),\n  nn.Linear(512, 512),\n  nn.ReLU(),\n  nn.Linear(512, 2),\n)","9c82bb00":"def train_epoch(model, train_loader, test_loader, epoch, device='cpu'):\n    criterion = nn.CrossEntropyLoss()\n    optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9)\n    running_loss = 0\n    model.train()\n    \n    # Train model\n    for batch_idx, pawbatch in enumerate(train_loader):\n        left_emb = pawbatch['embedding'].to(device)\n        right_emb = torch.roll(left_emb, 1, 0).to(device)\n        left_pawpul = pawbatch['pawpularity'].to(device)\n        right_pawpul = torch.roll(left_pawpul, 1, 0).to(device)\n        target = (left_pawpul < right_pawpul).type(torch.LongTensor)\n        nn_input = torch.cat([left_emb, right_emb], dim=-1)\n        \n        optimizer.zero_grad()\n        \n        outputs = model(nn_input)\n        loss = criterion(outputs, target)\n        loss.backward()\n        optimizer.step()\n        \n        # print statistics\n        running_loss += loss.item()\n        if batch_idx % 20 == 19:    # print every 20 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, batch_idx + 1, running_loss \/ 20))\n            running_loss = 0.0\n\n    # Eval model\n    model.eval()\n    accuracy = 0\n    null_acc = 0\n    odin_acc = 0\n    with torch.no_grad():\n        for batch_idx, pawbatch in enumerate(test_loader):\n            left_emb = pawbatch['embedding'].to(device)\n            right_emb = torch.roll(left_emb, 1, 0).to(device)\n            left_pawpul = pawbatch['pawpularity'].to(device)\n            right_pawpul = torch.roll(left_pawpul, 1, 0).to(device)\n            target = (left_pawpul < right_pawpul).type(torch.LongTensor)\n            nn_input = torch.cat([left_emb, right_emb], dim=-1)\n            outputs = model(nn_input)\n            accuracy += torch.sum(torch.argmax(outputs, 1) == target)\n            null_acc += torch.sum(0 == target)\n            odin_acc += torch.sum(1 == target)\n        print('---------------------------------')\n        print('Test acc   :', accuracy \/ (128. * len(test_loader)))\n        print('Guess 0 acc:', null_acc \/ (128. * len(test_loader)))\n        print('Guess 1 acc:', odin_acc \/ (128. * len(test_loader)))\n        print('---------------------------------')","8bd35ac7":"for epoch in range(5):\n    train_epoch(model, train_loader, test_loader, epoch=epoch)","41773ab7":"model = nn.Sequential(\n  nn.Linear(2048, 1024),\n  nn.ReLU(),\n  nn.Linear(1024, 512),\n  nn.ReLU(),\n  nn.Linear(512, 512),\n  nn.ReLU(),\n  nn.Linear(512, 2),\n)","cd9761f4":"def train_epoch(model, train_loader, test_loader, epoch, device='cpu'):\n    criterion = nn.CrossEntropyLoss()\n    optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9)\n    running_loss = 0\n    model.train()\n    \n    # Train model\n    for batch_idx, pawbatch in enumerate(train_loader):\n        emb = pawbatch['embedding'].to(device)\n        pawpul = pawbatch['pawpularity'].to(device)\n        target = (pawpul >= np.mean(petdf.Pawpularity)).type(torch.LongTensor)\n        \n        optimizer.zero_grad()\n        \n        outputs = model(emb)\n        loss = criterion(outputs, target)\n        loss.backward()\n        optimizer.step()\n        \n        # print statistics\n        running_loss += loss.item()\n        if batch_idx % 20 == 19:    # print every 20 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, batch_idx + 1, running_loss \/ 20))\n            running_loss = 0.0\n\n    # Eval model\n    model.eval()\n    accuracy = 0\n    null_acc = 0\n    odin_acc = 0\n    with torch.no_grad():\n        for batch_idx, pawbatch in enumerate(test_loader):\n            emb = pawbatch['embedding'].to(device)\n            pawpul = pawbatch['pawpularity'].to(device)\n            target = (pawpul >= np.median(petdf.Pawpularity)).type(torch.LongTensor)\n            outputs = model(emb)\n            accuracy += torch.sum(torch.argmax(outputs, 1) == target) \/ 128.\n            null_acc += torch.sum(0 == target) \/ 128.\n            odin_acc += torch.sum(1 == target) \/ 128.\n        print('---------------------------------')\n        print('Test acc   :', accuracy \/ (len(test_loader)))\n        print('Guess 0 acc:', null_acc \/ (len(test_loader)))\n        print('Guess 1 acc:', odin_acc \/ (len(test_loader)))\n        print('---------------------------------')","e19d1e65":"for epoch in range(5):\n    train_epoch(model, train_loader, test_loader, epoch=epoch)","0ec848fa":"**First question:** is it possible to train a simple model that can tell which pet has a higher **pawpularity** score (i.e. a binary classifier)?","811bb32f":"**Second question:** can we predict if a pet belongs to the upper half (~33 pawpularity, where 33 is median pawpularity)?","10970430":"# Sanity Check\n\nIn this notebook, we want to run sanity checks to test if the data actually contains meaningful information."}}