{"cell_type":{"4ec28220":"code","06e834a2":"code","2fccd831":"code","19d0186b":"code","af6e57cf":"code","964a8825":"code","1557ff70":"code","bec91943":"code","7ee4e8ea":"code","55326ff6":"code","49a9475d":"code","13df5479":"code","4eee9552":"code","f2fa1175":"code","400920ec":"markdown","95dce87b":"markdown","c544d84f":"markdown","d980003a":"markdown","4a8fbf02":"markdown","04535ca9":"markdown","cc1b4d9f":"markdown"},"source":{"4ec28220":"import numpy as np\nimport cv2\nfrom matplotlib import pyplot as plt\nfrom PIL import Image","06e834a2":"image = cv2.imread(r'..\/input\/image-for-basic-digital-image-processing-operation\/crow.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\nplt.imshow(image)","2fccd831":"#plt.hist(image.ravel(),256,[0,256]); plt.show()\nhist = cv2.calcHist([image],[0],None,[256],[0,256])\nplt.plot(hist)","19d0186b":"row,col = image.shape\nimg_hist = np.zeros((256,1))\nfor i in range(0,row):\n    for j in range(0,col):\n        val = image[i,j]\n        img_hist[val] = img_hist[val] + 1\n\nplt.plot(img_hist)","af6e57cf":"cdf = np.zeros((256,1))\ncdf[0,0] = img_hist[0]\n\nfor i in range(1,256):\n    cdf[i] = cdf[i-1] + img_hist[i]\n    \nplt.plot(cdf)","964a8825":"\n\nimg = Image.open('..\/input\/image-for-basic-digital-image-processing-operation\/lena.jpg')\n\n# display the image\nplt.imshow(img, cmap='gray')","1557ff70":"# convert our image into a numpy array\nimg = np.asarray(img)\n\n# put pixels in a 1D array by flattening out img array\nflat = img.flatten()\n\n# show the histogram\nplt.hist(flat, bins=50)","bec91943":"# create our own histogram function\ndef get_histogram(image, bins):\n    # array with size of bins, set to zeros\n    histogram = np.zeros(bins)\n    \n    # loop through pixels and sum up counts of pixels\n    for pixel in image:\n        histogram[pixel] += 1\n    \n    # return our final result\n    return histogram\n\n# execute our histogram function\nhist = get_histogram(flat, 256)","7ee4e8ea":"# create our cumulative sum function\ndef cumsum(a):\n    a = iter(a)\n    b = [next(a)]\n    for i in a:\n        b.append(b[-1] + i)\n    return np.array(b)\n\n# execute the fn\ncs = cumsum(hist)\n\n# display the result\nplt.plot(cs)","55326ff6":"# numerator & denomenator\nnj = (cs - cs.min()) * 255\nN = cs.max() - cs.min()\n\n# re-normalize the cumsum\ncs = nj \/ N\n\n# cast it back to uint8 since we can't use floating point values in images\ncs = cs.astype('uint8')\n\nplt.plot(cs)","49a9475d":"# get the value from cumulative sum for every index in flat, and set that as img_new\nimg_new = cs[flat]\n\n# put array back into original shape since we flattened it\nimg_new = np.reshape(img_new, img.shape)\n\n# set up side-by-side image display\nfig = plt.figure()\nfig.set_figheight(15)\nfig.set_figwidth(15)\n\nfig.add_subplot(1,2,1)\nplt.imshow(img, cmap='gray')\n\n# display the new image\nfig.add_subplot(1,2,2)\nplt.imshow(img_new, cmap='gray')\n\nplt.show(block=True)","13df5479":"def find_nearest_above(my_array, target):\n    diff = my_array - target\n    mask = np.ma.less_equal(diff, -1)\n    # We need to mask the negative differences\n    # since we are looking for values above\n    if np.all(mask):\n        c = np.abs(diff).argmin()\n        return c # returns min index of the nearest if target is greater than any value\n    masked_diff = np.ma.masked_array(diff, mask)\n    return masked_diff.argmin()","4eee9552":"def hist_match(original, specified):\n\n    oldshape = original.shape\n    original = original.ravel()\n    specified = specified.ravel()\n\n    # get the set of unique pixel values and their corresponding indices and counts\n    s_values, bin_idx, s_counts = np.unique(original, return_inverse=True,return_counts=True)\n    t_values, t_counts = np.unique(specified, return_counts=True)\n\n    # Calculate s_k for original image\n    s_quantiles = np.cumsum(s_counts).astype(np.float64)\n    s_quantiles \/= s_quantiles[-1]\n    \n    # Calculate s_k for specified image\n    t_quantiles = np.cumsum(t_counts).astype(np.float64)\n    t_quantiles \/= t_quantiles[-1]\n\n    # Round the values\n    sour = np.around(s_quantiles*255)\n    temp = np.around(t_quantiles*255)\n    \n    # Map the rounded values\n    b=[]\n    for data in sour[:]:\n        b.append(find_nearest_above(temp,data))\n    b= np.array(b,dtype='uint8')\n\n    return b[bin_idx].reshape(oldshape)","f2fa1175":"import cv2\nimport numpy as np\n\n# Load the images in greyscale\noriginal = cv2.imread('..\/input\/image-for-basic-digital-image-processing-operation\/lena.jpg',0)\nspecified = cv2.imread('..\/input\/image-for-basic-digital-image-processing-operation\/crow.jpg',0)\n\n# perform Histogram Matching\na = hist_match(original, specified)\n\n# Display the image\nplt.imshow('a',np.array(a,dtype='uint8'))\nplt.imshow('a1',original)\nplt.imshow('a2',specified)\n","400920ec":"# 2. CDF of an image","95dce87b":"# 1. Histogram of an Image","c544d84f":"# 4. Histogram Specification","d980003a":"With Inbuilt Function","4a8fbf02":"Without Inbuilt Function","04535ca9":"# 3. Histogram Normalization","cc1b4d9f":"# Image to be used:"}}