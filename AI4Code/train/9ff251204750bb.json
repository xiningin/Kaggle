{"cell_type":{"376adc46":"code","8a7ff0cb":"code","512040bf":"code","74a077bf":"code","78ad27b0":"code","76469842":"code","8fac7ad2":"code","2cc860e3":"code","05042b82":"code","00d09f5a":"code","9a32a662":"code","51f8f806":"code","cd4a4d7e":"code","deab454c":"code","94cd5959":"code","a81e92db":"code","b20ce567":"code","579895f7":"code","8221a973":"code","a57d972e":"code","ee4eb274":"code","21c3ca8a":"code","0697c7aa":"code","b7715662":"code","dc602e92":"code","feae83d5":"markdown"},"source":{"376adc46":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","8a7ff0cb":"import pandas as pd\nimport numpy as np\nimport seaborn as sns; sns.set()\nimport matplotlib.pyplot as plt\nfrom scipy import stats","512040bf":"#################### Helper Stylers ##########################\n\ncolor_scheme = {\n    'index': '#B6B2CF',\n    'etf': '#2D3ECF',\n    'tracking_error': '#6F91DE',\n    'df_header': 'silver',\n    'df_value': 'white',\n    'df_line': 'silver',\n    'heatmap_colorscale': [(0, '#6F91DE'), (0.5, 'grey'), (1, 'red')],\n    'background_label': '#9dbdd5',\n    'low_value': '#B6B2CF',\n    'high_value': '#2D3ECF',\n    'y_axis_2_text_color': 'grey',\n    'shadow': 'rgba(0, 0, 0, 0.75)',\n    'major_line': '#2D3ECF',\n    'minor_line': '#B6B2CF',\n    'main_line': 'black'}\n\ndef generate_config():\n    return {'showLink': False, 'displayModeBar': False, 'showAxisRangeEntryBoxes': True}\n","74a077bf":"#################### Helper Methods ##########################\nimport helper\nimport plotly.graph_objs as go\nimport plotly.offline as offline_py\noffline_py.init_notebook_mode(connected=True)\n\n\ndef _generate_stock_trace(prices):\n    return go.Scatter(\n        name='Index',\n        x=prices.index,\n        y=prices,\n        line={'color': color_scheme['major_line']})\n\n\ndef _generate_traces(name_df_color_data):\n    traces = []\n\n    for name, df, color in name_df_color_data:\n        traces.append(go.Scatter(\n            name=name,\n            x=df.index,\n            y=df,\n            mode='lines',\n            line={'color': color}))\n\n    return traces\n\n\ndef plot_stock(prices, title):\n    config = generate_config()\n    layout = go.Layout(title=title)\n\n    stock_trace = _generate_stock_trace(prices)\n\n    offline_py.iplot({'data': [stock_trace], 'layout': layout}, config=config)\n\n\ndef print_dataframe(df, n_rows=10, n_columns=3):\n    missing_val_str = '...'\n    config = generate_config()\n\n    formatted_df = df.iloc[:n_rows, :n_columns]\n    formatted_df = formatted_df.applymap('{:.3f}'.format)\n\n    if len(df.columns) > n_columns:\n        formatted_df[missing_val_str] = [missing_val_str]*len(formatted_df.index)\n    if len(df.index) > n_rows:\n        formatted_df.loc[missing_val_str] = [missing_val_str]*len(formatted_df.columns)\n\n    trace = go.Table(\n        type='table',\n        columnwidth=[1, 3],\n        header={\n            'values': [''] + list(formatted_df.columns.values),\n            'line': {'color': color_scheme['df_line']},\n            'fill': {'color': color_scheme['df_header']},\n            'font': {'size': 13}},\n        cells={\n            'values': formatted_df.reset_index().values.T,\n            'line': {'color': color_scheme['df_line']},\n            'fill': {'color': [color_scheme['df_header'], color_scheme['df_value']]},\n            'font': {'size': 13}})\n\n    offline_py.iplot([trace], config=config)\n\n\ndef plot_resampled_prices(df_resampled, df, title):\n    config = generate_config()\n    layout = go.Layout(title=title)\n\n    traces = _generate_traces([\n        ('Monthly Close', df_resampled, color_scheme['major_line']),\n        ('Close', df, color_scheme['minor_line'])])\n\n    offline_py.iplot({'data': traces, 'layout': layout}, config=config)\n\n\ndef plot_returns(returns, title):\n    config = generate_config()\n    layout = go.Layout(title=title)\n\n    traces = _generate_traces([\n        ('Returns', returns, color_scheme['major_line'])])\n\n    offline_py.iplot({'data': traces, 'layout': layout}, config=config)\n\n\ndef plot_shifted_returns(df_shited, df, title):\n    config = generate_config()\n    layout = go.Layout(title=title)\n\n    traces = _generate_traces([\n        ('Shifted Returns', df_shited, color_scheme['major_line']),\n        ('Returns', df, color_scheme['minor_line'])])\n\n    offline_py.iplot({'data': traces, 'layout': layout}, config=config)\n\n\ndef print_top(df, name, top_n=10):\n    print('{} Most {}:'.format(top_n, name))\n    print(', '.join(df.sum().sort_values(ascending=False).index[:top_n].values.tolist()))\n","78ad27b0":"df = pd.read_csv('..\/input\/cryptocurrency-market-history-coinmarketcap\/all_currencies.csv', parse_dates=['Date'], index_col=False)","76469842":"# Get top 20 cryptos based on market cap. Most of them are \"shitcoins\" and have low volume\nindicies = df.groupby('Symbol').agg({'Market Cap': max}).sort_values(by='Market Cap', ascending=False).index[:20]","8fac7ad2":"# Create a new pivot table to work with the data and fill missing values with latest closing prices. \nclose = df.reset_index().pivot(index='Date', columns='Symbol', values='Close')\nclose.drop(close.columns.difference(indicies), axis=1, inplace=True)\nclose.fillna(method='bfill', inplace=True)\nclose.head()","2cc860e3":"# Throughout the notebook we will mainly visualize Bitcoin\nticker = 'BTC'\nplot_stock(close[ticker], '{} Price'.format(ticker))","05042b82":"def resample_prices(close_prices, freq='M'):\n    \"\"\"\n    Resamples close prices for each ticker at specified frequency.\n    \"\"\"   \n    return close_prices.resample(freq).last()","00d09f5a":"monthly_close = resample_prices(close)\nmonthly_close.head()","9a32a662":"plot_resampled_prices(\n    monthly_close.loc[:, ticker],\n    close.loc[:, ticker],\n    '{} Close Vs Monthly Close'.format(ticker))","51f8f806":"def compute_log_returns(prices):\n    \"\"\"\n    Computes the log returns on given prices\n    \"\"\"\n    log_returns = np.log(prices) - np.log(prices.shift(1))\n    return log_returns","cd4a4d7e":"# Calculate monthly returns\nmonthly_close_returns = compute_log_returns(monthly_close)","deab454c":"plot_returns(\n    monthly_close_returns.loc[:, ticker],\n    'Log Returns of {} Stock (Monthly)'.format(ticker))","94cd5959":"def shift_returns(returns, n):\n    \"\"\"\n    Generate shifted returns to get lookahead and previous returns\n    \"\"\"\n    return returns.shift(n)","a81e92db":"# Previous month's returns\nprev_returns = shift_returns(monthly_close_returns, 1)\n# Next month's returns\nlookahead_returns = shift_returns(monthly_close_returns, -1)","b20ce567":"plot_shifted_returns(\n    prev_returns.loc[:, ticker],\n    monthly_close_returns.loc[:, ticker],\n    'Previous Returns of {} Stock'.format(ticker))","579895f7":"plot_shifted_returns(\n    lookahead_returns.loc[:, ticker],\n    monthly_close_returns.loc[:, ticker],\n    'Lookahead Returns of {} Stock'.format(ticker))","8221a973":"def get_top_n(prev_returns, top_n):\n    \"\"\"\n    Return top N cryptos for each day\n    \"\"\"\n    top_cryptos = prev_returns.mask(prev_returns.rank(axis = 1, method='max', ascending=False) > top_n, 0)\n    top_cryptos = top_cryptos.mask(top_cryptos > 0, int(1))\n    top_cryptos = top_cryptos.mask(top_cryptos < 0, int(1))\n    top_cryptos.fillna(0, inplace=True)\n    return top_cryptos.astype(int)","a57d972e":"top_n = 3\ndf_long = get_top_n(prev_returns, top_n)\ndf_short = get_top_n(-1*prev_returns, top_n)\nprint_top(df_long, 'Longed Cryptos')\nprint_top(df_short, 'Shorted Cryptos')","ee4eb274":"def portfolio_returns(df_long, df_short, lookahead_returns, top_n_coins):\n    \"\"\"\n    Computes expected returns for a portfolio. \n    \"\"\"\n    return ((df_long - df_short) * lookahead_returns) \/ top_n_coins","21c3ca8a":"# Let's see the returns of our portfolio\nexpected_portfolio_returns = portfolio_returns(df_long, df_short, lookahead_returns, 2*top_n)\n\nplot_returns(expected_portfolio_returns.T.sum(), 'Portfolio Returns')","0697c7aa":"# Annualized rate of return\nexpected_portfolio_returns_by_date = expected_portfolio_returns.T.sum().dropna()\nportfolio_ret_mean = expected_portfolio_returns_by_date.mean()\nportfolio_ret_ste = expected_portfolio_returns_by_date.sem()\nportfolio_ret_annual_rate = (np.exp(portfolio_ret_mean * 12) - 1) * 100\n\nprint(\"\"\"\nMean:                       {:.6f}\nStandard Error:             {:.6f}\nAnnualized Rate of Return:  {:.2f}%\n\"\"\".format(portfolio_ret_mean, portfolio_ret_ste, portfolio_ret_annual_rate))","b7715662":"# Apply T-Test\ndef analyze_alpha(expected_portfolio_returns_by_date):\n    null_hypothesis = 0\n    t, p = stats.ttest_1samp(expected_portfolio_returns_by_date.values, null_hypothesis)\n    return t, p\/2","dc602e92":"t_value, p_value = analyze_alpha(expected_portfolio_returns_by_date)\nprint(\"\"\"\nAlpha analysis:\n t-value:        {:.3f}\n p-value:        {:.6f}\n\"\"\".format(t_value, p_value))","feae83d5":"* At first we might go with this strategy because of the annual return. However our t-test shows that results are not statistically significant this is probably just a flactuation and we cannot reject the null hypothesis. "}}