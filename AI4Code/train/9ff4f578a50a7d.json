{"cell_type":{"5b89bf2d":"code","5ee5fad2":"code","3ce33230":"code","3ffe3f89":"code","0e1c89fe":"code","84e2bfc0":"code","04aafc14":"code","82c1716a":"code","cc0a6bbb":"code","e256d85d":"code","7d818a44":"code","ab3afd5c":"code","8fa6d237":"code","b3d4e9ce":"code","a6aaaabc":"code","690725a7":"code","380bcccc":"code","552b4fa2":"code","b73b95cd":"code","e98c3d08":"code","c448ad4c":"code","049232af":"code","1a7b1792":"code","120f68bc":"code","b8fcf9ac":"code","bd97de6f":"code","e6d80042":"code","f50b8220":"code","eea94b0e":"code","18e87c3f":"code","5dc75631":"code","15705464":"code","8452bd7f":"code","e191aa5f":"code","fbcc4d30":"code","c656b316":"code","dbd37261":"code","e314d5f5":"code","b46c82fb":"code","c1c033f6":"code","bd6777d4":"code","91938651":"code","59dbef46":"code","11badc83":"code","c7589a48":"code","8c89fd49":"code","76f11c6f":"code","e0787588":"code","ef3796be":"markdown","4bf2e98d":"markdown","af451870":"markdown","e5e343fb":"markdown","2781e38f":"markdown","481aad74":"markdown","a84f1145":"markdown","e22dd0e3":"markdown","69862be2":"markdown","dcd6e1d9":"markdown","245bd0b3":"markdown","f946edcc":"markdown"},"source":{"5b89bf2d":"import pandas as pd\nfrom statistics import mean \nimport numpy as np","5ee5fad2":"df = pd.read_csv(\".\/train.csv\")","3ce33230":"df.head()","3ffe3f89":"print(\"Class distribution after fetching unique orders\")\ndf[[\"order_id\",\"label\"]].drop_duplicates().reset_index().groupby([\"label\"]).size().to_frame(name=\"count\").reset_index()","0e1c89fe":"print(\"Average accuracy for label 0:\", mean(df.groupby(\"label\")[\"accuracy_in_meters\"].apply(list)[0]))\nprint(\"Average accuracy for label 1:\", mean(df.groupby(\"label\")[\"accuracy_in_meters\"].apply(list)[1]))","84e2bfc0":"agg_df = df.groupby('order_id').agg(pd.Series.tolist)","04aafc14":"agg_df.head()","82c1716a":"for index,row in agg_df.iterrows():\n    for c in [\"service_type\", \"date\", \"hour\",\"label\"]:\n        agg_df.loc[index, c]=list(set(row[c]))","cc0a6bbb":"agg_df.head()","e256d85d":"from math import atan2, cos, sin, pi, sqrt, radians\ndef haversine_distance(lat1, lon1,lat2, lon2):\n    # earth radius in kilometers\n    R = 6373.0\n    # convert decimal degrees to radians\n    lon1=radians(lon1)\n    lon2=radians(lon2)\n    lat1=radians(lat1)\n    lat2=radians(lat2)\n    # distance between pairs\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = (sin(dlat\/2))**2 + cos(lat1) * cos(lat2) * (sin(dlon\/2))**2\n    c = 2 * atan2(sqrt(a), sqrt(1-a))\n    # return distance in meters\n    distance = R * c * 1000\n    return distance","7d818a44":"#agg_df[\"speeds\"] =  [[]] * agg_df.shape[0]\nss = []\nfor index, row in agg_df.iterrows():\n    lats, lngs, secs = row[\"latitude\"], row[\"longitude\"], row[\"seconds\"]\n    speeds = []\n    for i in range(len(lats)-1):\n        distance = haversine_distance(lats[i], lngs[i], lats[i+1], lngs[i+1])\n        if secs[i+1] - secs[i] != 0:\n            speed = distance\/(secs[i+1] - secs[i])\n            speeds.append(speed)\n    ss.append(speeds)\n\nagg_df[\"speeds\"] = ss","ab3afd5c":"counter=0\nfor index,row in agg_df.iterrows():\n    try:\n        max_acc = max(row[\"accuracy_in_meters\"])\n        min_acc = min(row[\"accuracy_in_meters\"])\n        max_alt = max(row[\"altitude_in_meters\"])\n        min_alt = min(row[\"altitude_in_meters\"])\n        mean_alt = mean(row[\"altitude_in_meters\"])\n        mean_acc = mean(row[\"accuracy_in_meters\"])\n\n        max_speed = max(row[\"speeds\"])\n        min_speed = min(row[\"speeds\"])\n        mean_speed = mean(row[\"speeds\"])\n        \n        agg_df.loc[index, \"max_alt\"] = max_alt\n        agg_df.loc[index, \"min_alt\"] = min_alt\n        agg_df.loc[index, \"diff_max_min_alt\"] = max_alt - min_alt\n        agg_df.loc[index, \"max_acc\"] = max_acc\n        agg_df.loc[index, \"min_acc\"] = min_acc\n        agg_df.loc[index, \"diff_max_min_acc\"] = max_acc - min_acc\n        agg_df.loc[index, \"mean_alt\"] = mean_alt\n        agg_df.loc[index, \"mean_acc\"] = mean_acc\n        \n        agg_df.loc[index, \"max_speed\"] = max_speed\n        agg_df.loc[index, \"min_speed\"] = min_speed\n        agg_df.loc[index, \"diff_max_min_speed\"] = max_speed - min_speed\n        agg_df.loc[index, \"mean_speed\"] = mean_speed\n    except:\n        pass","8fa6d237":"agg_df.head()","b3d4e9ce":"agg_df.columns","a6aaaabc":"_X,_Y = agg_df[[\"service_type\", \"max_alt\", \"min_alt\", \"diff_max_min_alt\", \"max_acc\", \"min_acc\", \"diff_max_min_acc\", \"mean_alt\", \"mean_acc\", 'max_speed','min_speed', 'diff_max_min_speed', 'mean_speed']], agg_df[\"label\"]\n","690725a7":"_X = _X.fillna(-1)","380bcccc":"X = []\nfor x in _X.values:\n    if x[0][0] == \"GO_FOOD\":\n        x[0] = 1\n    else:\n        x[0] = 2\n    X.append(x)","552b4fa2":"Y = []\nfor y in _Y:\n    Y.append(y[0])","b73b95cd":"__X = []\nfor x in X:\n    __X.append(x.tolist())\nX = __X","e98c3d08":"from xgboost import XGBClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nimport xgboost as xgb\nimport sklearn\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.linear_model import LogisticRegression, RidgeClassifier\n\nclf_multilabel = XGBClassifier(max_depth=30)","c448ad4c":"X_train, X_test, Y_train, Y_test = sklearn.model_selection.train_test_split(X, Y, test_size=0.33, random_state=42)","049232af":"LR_classifier = LogisticRegression()\naccuracy_score(Y_test, LR_classifier.fit(X_train, Y_train).predict(X_test))","1a7b1792":"clf_multilabel.fit(np.matrix(X_train), Y_train)","120f68bc":"y_val_predicted_labels_tfidf = clf_multilabel.predict(np.matrix(X_test))\naccuracy_score(Y_test, y_val_predicted_labels_tfidf)","b8fcf9ac":"import numpy as np\nimport matplotlib.pyplot as plt\nimport sklearn.datasets\nfrom sklearn.model_selection import train_test_split\n%matplotlib inline\n\nfrom keras import Sequential\nfrom keras.layers import Dense\nimport matplotlib.pyplot as plt \nfrom keras.utils import np_utils","bd97de6f":"np.matrix(X_train).shape","e6d80042":"classifier = Sequential()\nclassifier.add(Dense(64, activation='relu', kernel_initializer='random_normal', input_dim=np.matrix(X_train).shape[1]))\nclassifier.add(Dense(32, activation='tanh'))\nclassifier.add(Dense(16, activation='relu'))\nclassifier.add(Dense(1, activation='sigmoid'))\nclassifier.compile(optimizer ='adam',loss='binary_crossentropy', metrics =['accuracy'])\n","f50b8220":"classifier.fit(np.matrix(X_train),Y_train, batch_size=10, epochs=50)","eea94b0e":"eval_model=classifier.evaluate(np.matrix(X_test), Y_test)\neval_model","18e87c3f":"classifier.predict(np.matrix(X_test)) < .5","5dc75631":"test_df = pd.read_csv(\".\/test.csv\")","15705464":"test_df.head(2)","8452bd7f":"agg_df_test = test_df.groupby('order_id').agg(pd.Series.tolist)","e191aa5f":"for index,row in agg_df_test.iterrows():\n    for c in [\"service_type\", \"date\", \"hour\"]:\n        agg_df_test.loc[index, c]=list(set(row[c]))","fbcc4d30":"#agg_df[\"speeds\"] =  [[]] * agg_df.shape[0]\nss = []\nfor index, row in agg_df_test.iterrows():\n    lats, lngs, secs = row[\"latitude\"], row[\"longitude\"], row[\"seconds\"]\n    speeds = []\n    for i in range(len(lats)-1):\n        distance = haversine_distance(lats[i], lngs[i], lats[i+1], lngs[i+1])\n        if secs[i+1] - secs[i] != 0:\n            speed = distance\/(secs[i+1] - secs[i])\n            speeds.append(speed)\n    ss.append(speeds)\n\nagg_df_test[\"speeds\"] = ss","c656b316":"counter=0\nfor index,row in agg_df_test.iterrows():\n    try:\n        max_acc = max(row[\"accuracy_in_meters\"])\n        min_acc = min(row[\"accuracy_in_meters\"])\n        max_alt = max(row[\"altitude_in_meters\"])\n        min_alt = min(row[\"altitude_in_meters\"])\n        mean_alt = mean(row[\"altitude_in_meters\"])\n        mean_acc = mean(row[\"accuracy_in_meters\"])\n\n        max_speed = max(row[\"speeds\"])\n        min_speed = min(row[\"speeds\"])\n        mean_speed = mean(row[\"speeds\"])\n        \n        agg_df_test.loc[index, \"max_alt\"] = max_alt\n        agg_df_test.loc[index, \"min_alt\"] = min_alt\n        agg_df_test.loc[index, \"diff_max_min_alt\"] = max_alt - min_alt\n        agg_df_test.loc[index, \"max_acc\"] = max_acc\n        agg_df_test.loc[index, \"min_acc\"] = min_acc\n        agg_df_test.loc[index, \"diff_max_min_acc\"] = max_acc - min_acc\n        agg_df_test.loc[index, \"mean_alt\"] = mean_alt\n        agg_df_test.loc[index, \"mean_acc\"] = mean_acc\n        \n        agg_df_test.loc[index, \"max_speed\"] = max_speed\n        agg_df_test.loc[index, \"min_speed\"] = min_speed\n        agg_df_test.loc[index, \"diff_max_min_speed\"] = max_speed - min_speed\n        agg_df_test.loc[index, \"mean_speed\"] = mean_speed\n    except:\n        pass","dbd37261":"_X = agg_df_test[[\"service_type\", \"max_alt\", \"min_alt\", \"diff_max_min_alt\", \"max_acc\", \"min_acc\", \"diff_max_min_acc\", \"mean_alt\", \"mean_acc\", 'max_speed','min_speed', 'diff_max_min_speed', 'mean_speed']]\n","e314d5f5":"_X = _X.fillna(-1)","b46c82fb":"X = []\nfor x in _X.values:\n    if x[0][0] == \"GO_FOOD\":\n        x[0] = 1\n    else:\n        x[0] = 2\n    X.append(x)","c1c033f6":"__X = []\nfor x in X:\n    __X.append(x.tolist())\nX = __X","bd6777d4":"y_preds = clf_multilabel.predict(np.matrix(X))","91938651":"y_preds.shape,agg_df_test.shape","59dbef46":"results = []\ncounter=0\nfor index in agg_df_test.index:\n    results.append([index,y_preds[counter]])\n    counter=counter+1","11badc83":"import csv\n\nwith open(\"output.csv\", \"w\") as f:\n    writer = csv.writer(f)\n    writer.writerows(results)","c7589a48":"print(clf_multilabel.feature_importances_)","8c89fd49":"_X.columns","76f11c6f":"feat_imp = {}\ni=0\nfor val in clf_multilabel.feature_importances_:\n    feat_imp[_X.columns[i]] = val\n    i=i+1","e0787588":"feat_imp","ef3796be":"### XGBoost","4bf2e98d":"### NN","af451870":"#### remove redundant data","e5e343fb":"#### mean, max, min, difference in max and min for accuracy , alt and speed","2781e38f":"### submission","481aad74":"#### calculate speed","a84f1145":"### LR","e22dd0e3":"#### mean, max, min, difference in max and min for accuracy , alt and speed","69862be2":"### Feature importance","dcd6e1d9":"#### calculate speed","245bd0b3":"#### remove redundant data","f946edcc":"### Agg the data based on order_id"}}