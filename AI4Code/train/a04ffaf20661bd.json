{"cell_type":{"f1b008a5":"code","62fbcece":"code","718e4ca2":"code","3a07d57e":"code","5f305f58":"code","7a471ed0":"code","04a0485e":"code","72651c4e":"code","099cc9b9":"code","24a87b02":"code","38654b8a":"markdown","71d3538c":"markdown","d04a8a51":"markdown","348de86c":"markdown"},"source":{"f1b008a5":"import numpy as np # for manipulating 3d images\nimport pandas as pd # for reading and writing tables\nimport h5py # for reading the image files\nimport skimage # for image processing and visualizations\nimport sklearn # for machine learning and statistical models\nimport os # help us load files and deal with paths","62fbcece":"%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport seaborn as sns\nplt.rcParams[\"figure.figsize\"] = (8, 8)\nplt.rcParams[\"figure.dpi\"] = 125\nplt.rcParams[\"font.size\"] = 14\nplt.rcParams['font.family'] = ['sans-serif']\nplt.rcParams['font.sans-serif'] = ['DejaVu Sans']\nplt.rcParams['image.cmap'] = 'gray'\nplt.style.use('ggplot')\nsns.set_style(\"whitegrid\", {'axes.grid': False})","718e4ca2":"train_image = skimage.io.imread('..\/input\/training.tif')\nprint(train_image.shape)\nsample_slice = np.expand_dims(np.expand_dims(train_image[train_image.shape[0]\/\/2], 0), -1)\nplt.imshow(sample_slice[0, :, :, 0], cmap='gray')","3a07d57e":"from keras import layers, models, optimizers, losses, backend as K","5f305f58":"PATCH_SIZE = (32, 32)","7a471ed0":"def build_dlhn(patch_size = PATCH_SIZE, patch_strides = None, clip_max=1\/255.0):\n    if patch_strides is None:\n        patch_strides = (np.clip(patch_size[0]\/\/2, 1, patch_size[0]), \n                         np.clip(patch_size[1]\/\/2, 1, patch_size[1]))\n    image_in = layers.Input((None, None, 1))\n    flip_layer = layers.Conv2D(1, (1, 1), use_bias=False, activation='linear', weights=[-1*np.ones((1, 1, 1, 1))], name='FlipLayer')\n    flip_layer.trainable = False\n    region_max_image = layers.MaxPool2D(patch_size, strides=patch_strides, name='MaxLayer', padding='same')(image_in)\n    region_min_image = flip_layer(layers.MaxPool2D(patch_size, strides=patch_strides, name='MinLayer', padding='same')(flip_layer(image_in)))\n    if np.max(patch_strides)>1:\n        region_max_image = layers.UpSampling2D(patch_strides, name='UpsampleMax')(region_max_image)\n        region_min_image = layers.UpSampling2D(patch_strides, name='UpsampleMin')(region_min_image)\n    region_diff_image = layers.subtract([region_max_image, region_min_image], name='CalculateRange')\n    region_min_shift = layers.subtract([image_in, region_min_image], name='RemoveOffset')\n    norm_image = layers.Lambda(lambda x: x[0]\/K.clip(x[1], clip_max, 1\/clip_max), name='DivideByRange')([region_min_shift, region_diff_image])\n    return models.Model(inputs=[image_in], outputs=[norm_image])\ndlhn_model = build_dlhn(patch_size=PATCH_SIZE)\ndlhn_model.summary()","04a0485e":"from keras.utils import vis_utils\nfrom IPython.display import SVG\nSVG(vis_utils.model_to_dot(dlhn_model, show_shapes=True).create_svg())","72651c4e":"fig, m_axs = plt.subplots(2, 3, figsize=(12, 8))\nfor (ax1, ax2), c_img in zip(m_axs.T, \n                             [sample_slice[0, :, :, 0], \n                              dlhn_model.predict(sample_slice)[0, :, :, 0], \n                              skimage.exposure.equalize_adapthist(sample_slice[0, :, :, 0], kernel_size=PATCH_SIZE)]):\n    ax1.imshow(c_img, cmap='gray')\n    ax2.hist(c_img.ravel())\n","099cc9b9":"%%time\n_ = dlhn_model.predict(np.expand_dims(train_image, -1), verbose=True, batch_size=32)","24a87b02":"%%time\n_ = [skimage.exposure.equalize_adapthist(c_slice, kernel_size=PATCH_SIZE) for c_slice in train_image]","38654b8a":"# Load Sample Image","71d3538c":"# Simplistic Performance Comparisons","d04a8a51":"# Overview\nUse deep learning layers (in Keras\/Tensorflow) to perform histogram equalization at the beginning of the model (to avoid having to implement it where the model is deployed)","348de86c":"# Assemble a Model\n- Local histogram equalization works by taking patches of an image, calculating the distribution and rescaling the patch to have that range.\nWe can approximate this using a NN by combining MaxPooling with some simple operations"}}