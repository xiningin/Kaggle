{"cell_type":{"52f8c700":"code","bfaf319c":"code","d39b35b1":"code","9006d1a7":"code","a19428e9":"code","ce5a1605":"code","553eded2":"code","108ac800":"code","f810543a":"code","33262935":"code","a4b31e80":"code","3256d6cc":"code","97b84c5a":"code","e5bfab19":"code","8730947f":"code","fd538fda":"code","efdc479d":"code","97281ff3":"code","893bc74e":"code","cfcbffd1":"code","e3f39240":"code","2acc76fc":"code","1ce17bf1":"code","6e432662":"code","6f0c6779":"code","92688ef3":"code","4da18716":"code","1c92078d":"code","cdebda95":"code","3dd1200a":"code","ca169d45":"code","bf7b8cd5":"code","78d8bef8":"code","b9da82e0":"code","93a89a8b":"code","4bb81ec9":"code","e5c80150":"code","570da948":"code","e7fc89e1":"code","0fac1540":"code","d6a510db":"code","b04fcaa8":"code","3c50a57e":"code","8f424b2c":"code","4bee4eef":"code","fdd58451":"code","5da045b4":"code","9379aa09":"code","83037832":"code","f5a5bab7":"code","279b9e7a":"code","cb4f7c20":"code","c8259c8c":"code","4e211f8f":"code","3bc8b9db":"code","0adb3212":"code","4ffec03b":"code","ec164e8d":"code","977e68ed":"code","daf8aa06":"code","4e3bf28d":"code","64ab8012":"code","4b3279b3":"code","6b4ba399":"code","4b415534":"markdown","1c43e240":"markdown","0ca59a27":"markdown","c858311a":"markdown","0a4c0f2a":"markdown","c6ee87c5":"markdown","42ba42db":"markdown","76f652f9":"markdown","c45466ee":"markdown","51df81fc":"markdown","3b124d65":"markdown","ed8e46cf":"markdown","cd47d96e":"markdown","c098066f":"markdown","042fbfc4":"markdown","bab00775":"markdown","adf0b324":"markdown","e86b01d8":"markdown","aacfe6e8":"markdown","4102c8be":"markdown","2444a3b2":"markdown","b0ba2074":"markdown","d6bfec38":"markdown","9959b2f8":"markdown","4f8d9f95":"markdown"},"source":{"52f8c700":"import keras\nimport keras.backend as K\nfrom keras.layers import LSTM,Dropout,Dense,TimeDistributed,Conv1D,MaxPooling1D,Flatten\nfrom keras.models import Sequential\nimport tensorflow as tf\nimport gc\nfrom numba import jit\nfrom IPython.display import display, clear_output\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nimport sys\nsns.set_style(\"whitegrid\")","bfaf319c":"import pyarrow.parquet as pq\nimport pandas as pd\nimport numpy as np","d39b35b1":"%%time \ntrain_set = pq.read_pandas('..\/input\/train.parquet').to_pandas()","9006d1a7":"%%time\nmeta_train = pd.read_csv('..\/input\/metadata_train.csv')","a19428e9":"@jit('float32(float32[:,:], int32)')\ndef feature_extractor(x, n_part=1000):\n    lenght = len(x)\n    pool = np.int32(np.ceil(lenght\/n_part))\n    output = np.zeros((n_part,))\n    for j, i in enumerate(range(0,lenght, pool)):\n        if i+pool < lenght:\n            k = x[i:i+pool]\n        else:\n            k = x[i:]\n        output[j] = np.max(k, axis=0) - np.min(k, axis=0)\n    return output","ce5a1605":"x_train = []\ny_train = []\nfor i in tqdm(meta_train.signal_id):\n    idx = meta_train.loc[meta_train.signal_id==i, 'signal_id'].values.tolist()\n    y_train.append(meta_train.loc[meta_train.signal_id==i, 'target'].values)\n    x_train.append(abs(feature_extractor(train_set.iloc[:, idx].values, n_part=400)))","553eded2":"del train_set; gc.collect()","108ac800":"y_train = np.array(y_train).reshape(-1,)\nX_train = np.array(x_train).reshape(-1,x_train[0].shape[0])","f810543a":"def keras_auc(y_true, y_pred):\n    auc = tf.metrics.auc(y_true, y_pred)[1]\n    K.get_session().run(tf.local_variables_initializer())\n    return auc","33262935":"n_signals = 1 #So far each instance is one signal. We will diversify them in next step\nn_outputs = 1 #Binary Classification","a4b31e80":"#Build the model\nverbose, epochs, batch_size = True, 15, 16\nn_steps, n_length = 40, 10\nX_train = X_train.reshape((X_train.shape[0], n_steps, n_length, n_signals))\n# define model\nmodel = Sequential()\nmodel.add(TimeDistributed(Conv1D(filters=64, kernel_size=3, activation='relu'), input_shape=(None,n_length,n_signals)))\nmodel.add(TimeDistributed(Conv1D(filters=64, kernel_size=3, activation='relu')))\nmodel.add(TimeDistributed(Dropout(0.5)))\nmodel.add(TimeDistributed(MaxPooling1D(pool_size=2)))\nmodel.add(TimeDistributed(Flatten()))\nmodel.add(LSTM(100))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(100, activation='relu'))\nmodel.add(Dense(n_outputs, activation='sigmoid'))","3256d6cc":"model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[keras_auc])","97b84c5a":"model.fit(X_train, y_train, epochs=epochs, batch_size=batch_size, verbose=verbose)","e5bfab19":"model.save_weights('model1.hdf5')","8730947f":"#%%time\n#test_set = pq.read_pandas('..\/input\/test.parquet').to_pandas()","fd538fda":"#%%time\n#meta_test = pd.read_csv('..\/input\/metadata_test.csv')","efdc479d":"#x_test = []\n#for i in tqdm(meta_test.signal_id.values):\n#    idx=i-8712\n#    clear_output(wait=True)\n#    x_test.append(abs(feature_extractor(test_set.iloc[:, idx].values, n_part=400)))","97281ff3":"#del test_set; gc.collect()","893bc74e":"#X_test = x_test.reshape((x_test.shape[0], n_steps, n_length, n_signals))","cfcbffd1":"#preds = model.predict(X_test)","e3f39240":"#threshpreds = (preds>0.5)*1","2acc76fc":"#sub = pd.read_csv('..\/input\/sample_submission.csv')\n#sub.target = threshpreds","1ce17bf1":"#sub.to_csv('first_sub.csv',index=False)\n#Gave me an LB score of 0.450","6e432662":"#Both numpy and scipy has utilities for FFT which is an endlessly useful algorithm\nfrom numpy.fft import *\nfrom scipy import fftpack","6f0c6779":"%%time \ntrain_set = pq.read_pandas('..\/input\/train.parquet').to_pandas()","92688ef3":"#FFT to filter out HF components and get main signal profile\ndef low_pass(s, threshold=1e4):\n    fourier = rfft(s)\n    frequencies = rfftfreq(s.size, d=2e-2\/s.size)\n    fourier[frequencies > threshold] = 0\n    return irfft(fourier)","4da18716":"def phase_indices(signal_num):\n    phase1 = 3*signal_num\n    phase2 = 3*signal_num + 1\n    phase3 = 3*signal_num + 2\n    return phase1,phase2,phase3","1c92078d":"s_id = 14\np1,p2,p3 = phase_indices(s_id)","cdebda95":"plt.figure(figsize=(10,5))\nplt.title('Signal %d \/ Target:%d'%(s_id,meta_train[meta_train.id_measurement==s_id].target.unique()[0]))\nplt.plot(train_set.iloc[:,p1])\nplt.plot(train_set.iloc[:,p2])\nplt.plot(train_set.iloc[:,p3])","3dd1200a":"lf_signal_1 = low_pass(train_set.iloc[:,p1])\nlf_signal_2 = low_pass(train_set.iloc[:,p2])\nlf_signal_3 = low_pass(train_set.iloc[:,p3])","ca169d45":"plt.figure(figsize=(10,5))\nplt.title('De-noised Signal %d \/ Target:%d'%(s_id,meta_train[meta_train.id_measurement==s_id].target.unique()[0]))\nplt.plot(lf_signal_1)\nplt.plot(lf_signal_2)\nplt.plot(lf_signal_3)","bf7b8cd5":"plt.figure(figsize=(10,5))\nplt.title('Signal %d AbsVal \/ Target: %d'%(s_id,meta_train[meta_train.id_measurement==s_id].target.unique()[0]))\nplt.plot(np.abs(lf_signal_1))\nplt.plot(np.abs(lf_signal_2))\nplt.plot(np.abs(lf_signal_3))","78d8bef8":"plt.figure(figsize=(10,5))\nplt.title('Signal %d \/ Target: %d'%(s_id,meta_train[meta_train.id_measurement==s_id].target.unique()[0]))\nplt.plot(lf_signal_1)\nplt.plot(lf_signal_2)\nplt.plot(lf_signal_3)\nplt.plot((np.abs(lf_signal_1)+np.abs(lf_signal_2)+np.abs(lf_signal_3)))\nplt.legend(['phase 1','phase 2','phase 3','DC Component'],loc=1)","b9da82e0":"###Filter out low frequencies from the signal to get HF characteristics\ndef high_pass(s, threshold=1e7):\n    fourier = rfft(s)\n    frequencies = rfftfreq(s.size, d=2e-2\/s.size)\n    fourier[frequencies < threshold] = 0\n    return irfft(fourier)","93a89a8b":"hf_signal_1 = high_pass(train_set.iloc[:,p1])\nhf_signal_2 = high_pass(train_set.iloc[:,p2])\nhf_signal_3 = high_pass(train_set.iloc[:,p3])","4bb81ec9":"plt.figure(figsize=(10,5))\nplt.title('Signal %d \/ Target:%d'%(s_id,meta_train[meta_train.id_measurement==s_id].target.unique()[0]))\nplt.plot(hf_signal_1)\n#plt.plot(hf_signal_2)\n#plt.plot(hf_signal_3)","e5c80150":"signal = train_set.iloc[:,p1]","570da948":"%%time\nx = signal\nX = fftpack.fft(x,n=400)\nfreqs = fftpack.fftfreq(n=400,d=2e-2\/x.size) ","e7fc89e1":"plt.plot(x)","0fac1540":"fig, ax = plt.subplots()\nax.set_title('Full Spectrum with Scipy')\nax.set_xlabel('Frequency in Hertz [Hz]')\nax.set_ylabel('Frequency Domain (Spectrum) Magnitude')\nax.stem(freqs[1:], np.abs(X)[1:])","d6a510db":"%%time\nx = high_pass(train_set.iloc[:,p1])\nX = fftpack.fft(x,n=400)\nfreqs = fftpack.fftfreq(n=400,d=2e-2\/x.size) ","b04fcaa8":"plt.plot(x)","3c50a57e":"fig, ax = plt.subplots()\nax.set_title('High Frequency Spectrum')\nax.set_xlabel('Frequency in Hertz [Hz]')\nax.set_ylabel('Frequency Domain (Spectrum) Magnitude')\nax.stem(freqs[1:], np.abs(X)[1:])","8f424b2c":"%%time\nx = low_pass(signal)\nX = fftpack.fft(x,n=400)\nfreqs = fftpack.fftfreq(n=400,d=2e-2\/x.size) ","4bee4eef":"plt.plot(x)","fdd58451":"fig, ax = plt.subplots()\nax.set_title('Low Frequency Spectrum')\nax.set_xlabel('Frequency in Hertz [Hz]')\nax.set_ylabel('Frequency Domain (Spectrum) Magnitude')\nax.stem(freqs[1:], np.abs(X)[1:])","5da045b4":"p1,p2,p3 = phase_indices(100)\nsignal = train_set.iloc[:,p1]","9379aa09":"from scipy import signal as sgn\nM = 1024\nrate = 1\/(2e-2\/signal.size)\n\nfreqs, times, Sx = sgn.spectrogram(signal.values, fs=rate, window='hanning',\n                                      nperseg=1024, noverlap=M - 100,\n                                      detrend='constant', scaling='spectrum')\n\nf, ax = plt.subplots(figsize=(10, 5))\nax.set_ylabel('Frequency [Hz]')\nax.set_xlabel('Time(s)')\nax.set_title('Spectogram')\nax.pcolormesh(times, freqs, np.log10(Sx), cmap='viridis')","83037832":"x_train_lp = []\nx_train_hp = []\nx_train_dc = []\nfor i in meta_train.signal_id:\n    idx = meta_train.loc[meta_train.signal_id==i, 'signal_id'].values.tolist()\n    clear_output(wait=True)\n    display(idx)\n    hp = high_pass(train_set.iloc[:, idx[0]])\n    lp = low_pass(train_set.iloc[:, idx[0]])\n    meas_id = meta_train.id_measurement[meta_train.signal_id==idx].values[0]\n    p1,p2,p3=phase_indices(meas_id)\n    lf_signal_1,lf_signal_2,lf_signal_3 = low_pass(train_set.iloc[:,p1]), low_pass(train_set.iloc[:,p2]), low_pass(train_set.iloc[:,p3])\n    dc = np.abs(lf_signal_1)+np.abs(lf_signal_2)+np.abs(lf_signal_3)\n    x_train_lp.append(abs(feature_extractor(lp, n_part=400)))\n    x_train_hp.append(abs(feature_extractor(hp, n_part=400)))\n    x_train_dc.append(abs(feature_extractor(dc, n_part=400)))","f5a5bab7":"del train_set; gc.collect()","279b9e7a":"#x_test_lp = []\n#x_test_hp = []\n#x_test_dc = []\n#for i in tqdm(meta_test.signal_id):\n#    idx = idx=i-8712\n#    clear_output(wait=True)\n#    #display(idx)\n#    hp = high_pass(test_set.iloc[:, idx])\n#    lp = low_pass(test_set.iloc[:, idx])\n#    meas_id = meta_test.id_measurement[meta_test.signal_id==i].values[0]\n#    p1,p2,p3=phase_indices(meas_id)\n#    lf_signal_1,lf_signal_2,lf_signal_3 = low_pass(test_set.iloc[:,p1-8712]), low_pass(test_set.iloc[:,p2-8712]), low_pass(test_set.iloc[:,p3-8712])\n#    dc = np.abs(lf_signal_1)+np.abs(lf_signal_2)+np.abs(lf_signal_3)\n#    x_test_lp.append(abs(feature_extractor(lp, n_part=400)))\n#    x_test_hp.append(abs(feature_extractor(hp, n_part=400)))\n#    x_test_dc.append(abs(feature_extractor(dc, n_part=400)))","cb4f7c20":"x_train = np.array(x_train).reshape(-1,x_train[0].shape[0])\nx_train_lp = np.array(x_train).reshape(-1,x_train_lp[0].shape[0])\nx_train_hp = np.array(x_train).reshape(-1,x_train_hp[0].shape[0])\nx_train_dc = np.array(x_train).reshape(-1,x_train_dc[0].shape[0])","c8259c8c":"#x_test = np.array(x_test).reshape(-1,x_test[0].shape[0])\n#x_test_lp = np.array(x_test).reshape(-1,x_test_lp[0].shape[0])\n#x_test_hp = np.array(x_test).reshape(-1,x_test_hp[0].shape[0])\n#x_test_dc = np.array(x_test).reshape(-1,x_test_dc[0].shape[0])","4e211f8f":"train = np.dstack((x_train,x_train_lp,x_train_hp,x_train_dc))\n#test = np.dstack((x_test,x_test_lp,x_test_hp,x_test_dc))","3bc8b9db":"y_train = np.array(y_train).reshape(-1,)","0adb3212":"verbose, epochs, batch_size = True, 15, 16\nn_signals,n_steps, n_length = 4,40, 10\ntrain = train.reshape((train.shape[0], n_steps, n_length, n_signals))\n# define model\nmodel = Sequential()\nmodel.add(TimeDistributed(Conv1D(filters=64, kernel_size=3, activation='relu'), input_shape=(None,n_length,n_signals)))\nmodel.add(TimeDistributed(Conv1D(filters=64, kernel_size=3, activation='relu')))\nmodel.add(TimeDistributed(Dropout(0.5)))\nmodel.add(TimeDistributed(MaxPooling1D(pool_size=2)))\nmodel.add(TimeDistributed(Flatten()))\nmodel.add(LSTM(100))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(100, activation='relu'))\nmodel.add(Dense(n_outputs, activation='sigmoid'))","4ffec03b":"model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[keras_auc])","ec164e8d":"# fit network\nmodel.fit(train, y_train, epochs=epochs, batch_size=batch_size, verbose=verbose)","977e68ed":"model.save_weights('model2.hdf5')","daf8aa06":"#X_test = test.reshape((test.shape[0], n_steps, n_length, n_signals))","4e3bf28d":"#preds = model.predict(X_test)","64ab8012":"#threshpreds = (preds>0.5)*1","4b3279b3":"#sub = pd.read_csv('data\/sample_submission.csv')\n#sub.target = threshpreds","6b4ba399":"#sub.to_csv('submissions\/second_sub.csv',index=False)","4b415534":"## 0. Info","1c43e240":"Many thanks to following kernels:\n- For shortening the signals with a simple feature extraction thanks to: https:\/\/www.kaggle.com\/ashishpatel26\/transfer-learning-in-basic-nn\n- For signal denoising and fft: https:\/\/www.kaggle.com\/theoviel\/fast-fourier-transform-denoising","0ca59a27":"### **TASK:** Classify long-term failure of covered conductors based on signal characteristics:\n- Extract features from time series data for classification.\n- Use **CNN** for further FE and **LSTM** to get temporal dependencies and perform time series classification on the top layer.","c858311a":"# TODO#1: Turn Spectral Analysis into Features\n# TODO#2: Enhcance the experiment with cross_val, adaptive learning rate, early stopping, ensembling etc.","0a4c0f2a":"## 1. Load Data","c6ee87c5":"### What is partial discharge?","42ba42db":"### Second submission with 4 channels scores higher on LB. Increased number of epochs and playing with threshold may yield better results. I got 0.513 with re-training the model for 3+ times. ","76f652f9":"### Classical Modes of Detection\n- Partial Discharges can be detected by **measuring the emissions** they give off: Ultrasonic Sound, Transient Earth Voltages (TEV and UHF energy).\n- Is it possible to enhance the modes of detection by **better feature extraction** for the classifiers?\n- **Intel Mobile ODT** challenge on 2017 was about topping **classical image processing** methods by automatic feature extaction using pre-trained CNN models and **transfer learning**.\n- **Two possible approaches**:\n    - FE on signals and feeding them into NNs for classification.\n    - Using NNs further as feature extractors and then use shallow classifiers (XGBoost) for binary classification\n","c45466ee":"We only fed what we were given and only feature engineering was to reduce signal lengths because 800000 time steps is troublesome with LSTM. Signal classification applications takes more than one modalities or channels in real life. So I will try to increase the feature size in terms of channel depth rather than feature count.\n\nProposed data structure: **n_instances x n_timesteps x  n_channels**","51df81fc":"As seen above we can decouple the signals into their high and low frequency components using FFT. So the number of signal channels that are fed into the model can may very well be diversified using different decouplings in time and frequency domains. \n\nThe mode of decoupling so far was filtering what we have to get new signals. Following part is about playing around the frequency domain to create features. ","3b124d65":"## 3. Build Primitive CNN + LSTM Model","ed8e46cf":"**Signals:**\n\n- 800.000 measurement points for 8712 signals.\n- The signals are **three-phased** so there are 2904 distinct signaling instances.\n- Three phase signals:\n    - Sums to zero.\n    - When one fails other continue to carry the current.\n    - Can be rectified to be converted to DC current.\n    - Ripples in rectification can be seen on failure.\n   ","cd47d96e":"### 4.a - Filter & Transform Signals","c098066f":"Apart from the signals themselves we have: \n- Low Pass Filtered Signal (800000)\n- High Pass Filtered Signal (800000)\n- DC component from adding absolute values of 3-phases. (800000)\n- Frequency Magnitude Spectrum of full signal (400)\n- Frequency Magnitude Spectrum of Low Freq signal (400)\n- Frequency Magnitude Spectrum of High Freq signal (400)\n- Frequency Spectrum ","042fbfc4":"* CNN is for feature extraction and LSTM is for capturing time dependency.","bab00775":"![](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/4\/48\/3-phase_flow.gif\/357px-3-phase_flow.gif)","adf0b324":"This is my first kernel on Kaggle. I am very excited to contribute to this competition and going back to my days of studying biomechatonics where I first met the concept of feature extraction to classify signals from sensors on human body. \n\nI made a fast literature review on feature extraction and signal classification and prepared following experiment for my first submissions.\n\nI will be updating explanatory walktrough alongside model improvements.\n\nRunning and submitting from full notebook on interactive session was problemmatic due to memory troubles with the test set. I will work my way around it meanwhile you can download to use or fork to improve. Open for feedbacks to improve my first kernel.\n\nHave fun everyone!","e86b01d8":"## 2. Process and Minimize Data","aacfe6e8":"## 4. Further processing of Signals to Diversify the Model","4102c8be":"Now we have the temporal behavior of frequencies that compose our signal in terms of their magnitudes. Aggregations can be made on both time and frequency axes by selecting appropriate window sizes.","2444a3b2":"### 4.c - Frequencies vs. Time\n","b0ba2074":"For initial improvement of our model we will use diversification of signals from **4.a** and create **4 channels**:\n- **Signal itself**\n- **LF** component\n- **HF** component\n- **DC** component from three-phase merge)\n\nThe justification for DC component is that all three phase signals are rectified to form a DC behavior with a small amount of ripple. I naively assumed that a partial discharce occuring in any of the 3 signals, will result in corruption at the resulting voltage behavior. While composing up the features, each instance that belong to a triple will have the same \"DC component.\"","d6bfec38":" - Typical situation of PD: imagine there is an internal cavity\/void or **impurity in insulation**. \n - When **High Voltage** is applied on conductor, a field is also induced on the cavity. Further, when the field increases, this **defect breaks down** and **discharges** different forms of energy which result in partial discharge.\n - This phenomenon is damaging over a long period of time. It is not event that occurs suddenly. ","9959b2f8":"## 5. Add Features","4f8d9f95":"### 4.b - Spectogram Features"}}