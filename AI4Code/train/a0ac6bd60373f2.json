{"cell_type":{"929643bb":"code","8cf62a11":"code","9df059ed":"code","1440602e":"code","780ba3ce":"code","0d7f19d0":"code","7f06f7cb":"code","4c37d214":"code","ceccdfbb":"code","92a86ae2":"code","51db6eed":"code","c2e9697a":"code","26a87f69":"code","23e3af64":"code","89fcfe66":"code","44b44c45":"code","d2ddeb6b":"code","6a53709d":"code","8dbf83b9":"code","9c848694":"code","70b5c1be":"code","126974d1":"code","7e2a4f5d":"code","772ab15b":"code","abb64e05":"code","261488f2":"code","7dbee4da":"code","0e3b974d":"code","bcbc3eaf":"code","a04dd38d":"code","293fd5c4":"markdown","09b4a708":"markdown","1a248f91":"markdown","f20e5a7d":"markdown","d649ab88":"markdown","22c285f3":"markdown","bda9944c":"markdown","c79eec2d":"markdown","72b2510f":"markdown","2340c741":"markdown"},"source":{"929643bb":"import torch\nimport torch.nn as nn # Neural Network modules, loss functions, Activation functions\nimport torch.optim as optim # Optimizers like SGD, ADAM, etc\nimport torch.nn.functional as F # Activation functions like tanh, relu, etc\nfrom torch.utils.data import DataLoader # for mini batches\nimport torchvision.transforms as transforms # for transformations on dataset\n\nimport pandas as pd\nimport numpy as np","8cf62a11":"class CNN(nn.Module):\n    def __init__(self, in_channels=1, num_classes=10):\n        super(CNN, self).__init__()\n        self.conv1 = nn.Conv2d(in_channels=1, out_channels=8, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) # same conv\n        self.pool = nn.MaxPool2d(kernel_size=(2, 2), stride=(2, 2))\n        self.conv2 = nn.Conv2d(in_channels=8, out_channels=16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) # same conv\n        self.conv3 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n        self.fc1 = nn.Linear(32*3*3, 64)\n        self.dropout = nn.Dropout(p=0.3)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, num_classes)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = self.pool(x)\n        x = F.relu(self.conv2(x))\n        x = self.pool(x)\n        x = F.relu(self.conv3(x))\n        x = self.pool(x)\n        x = x.reshape(x.shape[0], -1)\n        x = F.relu(self.fc1(x))\n        x = self.dropout(x)\n        x = F.relu(self.fc2(x))\n        x = self.dropout(x)\n        x = self.fc3(x)\n        return x","9df059ed":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")","1440602e":"torch.cuda.is_available()","780ba3ce":"torch.cuda.get_device_name(0)","0d7f19d0":"in_channels = 1\nnum_classes = 10\nlearning_rate = 0.001\nbatch_size = 64\nnum_epoch = 10","7f06f7cb":"train_data = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\ntrain_data.head()","4c37d214":"X_train = train_data.iloc[:, 1:]\ny_train = train_data.iloc[:, 0]\n\nX_train.head()","ceccdfbb":"y_train.head()","92a86ae2":"X_train.shape, y_train.shape","51db6eed":"X_train = X_train.values.reshape(42000, 1, 28, 28)\nX_train.shape","c2e9697a":"class ClassificationDataset:\n    def __init__(self, X, y):\n        \n        self.X = X\n        self.y = y\n        print(X.shape)\n        print(y.shape)\n        \n    def __len__(self):\n        return len(self.y)\n    \n    def __getitem__(self, item):\n        \n        return {\n            \"image\" : torch.tensor(self.X[item], dtype=torch.float),\n            \"targets\": torch.tensor(self.y[item], dtype=torch.long)\n        }","26a87f69":"train_dataset = ClassificationDataset(X_train, y_train)\n\ntrain_loader = torch.utils.data.DataLoader(\n        train_dataset, batch_size=64, shuffle=True\n)","23e3af64":"model = CNN().to(device)","89fcfe66":"criterion = nn.CrossEntropyLoss()\noptimizer = optim.Adam(model.parameters(), lr=learning_rate)","44b44c45":"for data in train_loader:\n    \n    print(data[\"image\"].shape)\n    print(data[\"targets\"].shape)\n    break\n","d2ddeb6b":"for epoch in range(num_epoch):\n    for batch in train_loader:\n        # Get data to cuda if possible\n        data = batch[\"image\"].to(device=device)\n        targets = batch[\"targets\"].to(device=device)\n\n        # forward\n        scores = model(data)\n        loss = criterion(scores, targets)\n\n        # backward\n        optimizer.zero_grad() # making grad to 0\n        # so that it doesn't use the gradient from the previous batch\n        loss.backward()\n\n        # gradient descent or adam step\n        optimizer.step()","6a53709d":"def check_accuracy(loader, model):\n\n    num_correct = 0\n    num_samples = 0\n    model.eval()\n\n    with torch.no_grad():\n        for batch in train_loader:\n            # Get data to cuda if possible\n            x = batch[\"image\"].to(device=device)\n            y = batch[\"targets\"].to(device=device)\n            \n            scores = model(x) # 64 X 10\n            _, predictions = scores.max(1)\n            num_correct += (predictions == y).sum()\n            num_samples += predictions.size(0)\n\n        print(f\"Got {num_correct} \/ {num_samples} with accuracy {float(num_correct)\/float(num_samples) * 100:.2f}\")\n\n    model.train()","8dbf83b9":"check_accuracy(train_loader, model)","9c848694":"test = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\ntest.head()","70b5c1be":"X_test = test.values\nX_test.shape","126974d1":"X_test = X_test.reshape(28000, 1, 28, 28)\nprint(X_test.shape)","7e2a4f5d":"class ClassificationTestDataset:\n    def __init__(self, X):\n        \n        self.X = X\n        print(X.shape)\n        \n    def __len__(self):\n        return len(self.X)\n    \n    def __getitem__(self, item):\n        \n        return {\n            \"image\" : torch.tensor(self.X[item], dtype=torch.float)\n        }","772ab15b":"test_dataset = ClassificationTestDataset(X_test)\n\ntest_loader = torch.utils.data.DataLoader(\n        test_dataset, batch_size=64, shuffle=False\n)","abb64e05":"preds = []\n\nmodel.eval()\n\nfor data in test_loader:\n    x = data[\"image\"].to(device=device)\n    scores = model(x)\n    _, predictions = scores.max(1)\n    for p in predictions:\n        preds.append(p.item())\n    \nmodel.train()","261488f2":"print(preds[:10])","7dbee4da":"sub = pd.read_csv(\"..\/input\/digit-recognizer\/sample_submission.csv\")\nsub.head()","0e3b974d":"len(sub)","bcbc3eaf":"sub[\"Label\"] = preds","a04dd38d":"sub.to_csv(\"submission.csv\", index=False)","293fd5c4":"# Step 6 : Init Network","09b4a708":"# Step 4 : Hyperparameters","1a248f91":"# Step 7 : Loss and Optimizer","f20e5a7d":"## Step 9 : Check Accuarcy","d649ab88":"# Step 2 : Create a CNN","22c285f3":"# Step 3 : Set device","bda9944c":"# Step 8 : Train Network","c79eec2d":"## Step 10 : Testing and Submission","72b2510f":"# Step 5 : Load Data","2340c741":"# Step 1 : Imports"}}