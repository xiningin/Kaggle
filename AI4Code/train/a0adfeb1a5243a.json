{"cell_type":{"84c9ec7a":"code","0c5dada8":"code","2b2367a5":"code","10772b25":"code","b3ca4efa":"code","c6220eb0":"code","ca626eec":"code","ee2622fd":"code","d609ae87":"code","2180c237":"code","023f2131":"code","86076643":"code","1cf1bd7e":"code","7f234819":"code","6156ffed":"code","c1c7b3c8":"code","b1746939":"code","a91afd66":"code","39f42013":"code","38995987":"code","6a6f0889":"code","dd3f141b":"code","666ed1f1":"code","bbc984a7":"code","c1812aa1":"code","29390155":"code","d7ad502a":"code","61fd6eca":"code","d8af6297":"code","fac58e4c":"markdown","3f3de93e":"markdown","b3afee0f":"markdown","e2b10b18":"markdown","225efa48":"markdown","ee86d68e":"markdown","363fc4b2":"markdown","a1fe9881":"markdown","49d23527":"markdown","a2639a8f":"markdown","4d9d742d":"markdown","fce20d76":"markdown","63e85c29":"markdown","19cb099f":"markdown","abb5cfa3":"markdown","b2c0af98":"markdown","84bb381b":"markdown","bc84c8e4":"markdown","a0c4ea55":"markdown","7300d336":"markdown"},"source":{"84c9ec7a":"import re\nimport os\nimport math\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport tensorflow as tf\nfrom tensorflow import keras\n\nfrom functools import partial\nfrom kaggle_datasets import KaggleDatasets\nfrom sklearn.model_selection import train_test_split\nprint(\"Tensorflow version \" + tf.__version__)","0c5dada8":"try:\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\n    \nexcept:\n    strategy = tf.distribute.get_strategy()\n    \nprint('Number of replicas in sync:', strategy.num_replicas_in_sync)","2b2367a5":"AUTOTUNE = tf.data.experimental.AUTOTUNE\nGCS_PATH = KaggleDatasets().get_gcs_path()\nBATCH_SIZE = 16 * strategy.num_replicas_in_sync\nIMAGE_SIZE = [512, 512]\nCLASSES = ['0', '1', '2', '3', '4']\nCLASS_NAMES = ['Cassava Bacterial Blight', \n               'Cassava Brown Streak Disease', \n               'Cassava Green Mottle', \n               'Cassava Mosaic Disease', \n               'Healthy']\nEPOCHS = 7","10772b25":"def decode_image(image):\n    image = tf.image.decode_jpeg(image, channels = 3)\n    image = tf.cast(image, tf.float32) \/ 255.0\n    image = tf.reshape(image, [*IMAGE_SIZE, 3])\n    return image","b3ca4efa":"def read_tfrecord(example, labeled):\n    tfrecord_format = {'image': tf.io.FixedLenFeature([], tf.string), \n                       'target': tf.io.FixedLenFeature([], tf.int64)} if labeled else \\\n     {'image': tf.io.FixedLenFeature([], tf.string), \n      'image_name': tf.io.FixedLenFeature([], tf.string)}\n    \n    example = tf.io.parse_single_example(example, tfrecord_format)\n    image = decode_image(example['image'])\n    if labeled:\n        label = tf.cast(example['target'], tf.int32)\n        return image, label\n    idnum = example['image_name']\n    return image, idnum","c6220eb0":"def load_dataset(filenames, labeled = True, ordered = False):\n    # For optimal performance, reading from multiple files at once\n    # Order does not matter since we will be shuffling the data anyway\n    ignore_order = tf.data.Options()\n    if not ordered:\n        # disable order, increase speed\n        ignore_order.experimental_deterministic = False \n        \n    # automatically interleaves reads from multiple files\n    dataset = tf.data.TFRecordDataset(filenames, num_parallel_reads = AUTOTUNE) \n    \n    # uses data as soon as it streams in, rather than in its original order\n    dataset = dataset.with_options(ignore_order) \n    \n    dataset = dataset.map(partial(read_tfrecord, labeled = labeled), num_parallel_calls = AUTOTUNE)\n    return dataset","ca626eec":"TRAIN_FILENAMES, VAL_FILENAMES = train_test_split(\n    tf.io.gfile.glob(GCS_PATH + '\/train_tfrecords\/ld_train*.tfrec'),\n    test_size = 0.2, random_state = 5)\n\nTEST_FILENAMES = tf.io.gfile.glob(GCS_PATH + '\/test_tfrecords\/ld_test*.tfrec')","ee2622fd":"def data_augment(image, label): \n    image = tf.image.random_flip_left_right(image)\n    return image, label","d609ae87":"def get_training_dataset():\n    dataset = load_dataset(TRAIN_FILENAMES, labeled = True)  \n    dataset = dataset.map(data_augment, num_parallel_calls = AUTOTUNE)  \n    dataset = dataset.repeat().shuffle(2048).batch(BATCH_SIZE).prefetch(AUTOTUNE)\n    return dataset","2180c237":"def get_validation_dataset(ordered = False):\n    dataset = load_dataset(VAL_FILENAMES, labeled = True, ordered = ordered) \n    dataset = dataset.batch(BATCH_SIZE).cache().prefetch(AUTOTUNE)\n    return dataset","023f2131":"def get_test_dataset(ordered = False):\n    dataset = load_dataset(TEST_FILENAMES, labeled = False, ordered = ordered)\n    dataset = dataset.batch(BATCH_SIZE).prefetch(AUTOTUNE)\n    return dataset","86076643":"def count_data_items(filenames):\n    n = [int(re.compile(r\"-([0-9]*)\\.\").search(filename).group(1)) for filename in filenames]\n    return np.sum(n)","1cf1bd7e":"# check the number of training, validation and test examples\nNUM_TRAINING_IMAGES = count_data_items(TRAIN_FILENAMES)\nNUM_VALIDATION_IMAGES = count_data_items(VAL_FILENAMES)\nNUM_TEST_IMAGES = count_data_items(TEST_FILENAMES)\n\nprint('Dataset: {} training images, {} validation images, {} (unlabeled) test images'.format(\n    NUM_TRAINING_IMAGES, NUM_VALIDATION_IMAGES, NUM_TEST_IMAGES))","7f234819":"print(\"Training data shapes:\")\nfor image, label in get_training_dataset().take(3):\n    print(image.numpy().shape, label.numpy().shape)\nprint('-------')\n\nprint(\"Validation data shapes:\")\nfor image, label in get_validation_dataset().take(3):\n    print(image.numpy().shape, label.numpy().shape)\nprint('------')\n\nprint(\"Test data shapes:\")\nfor image, idnum in get_test_dataset().take(3):\n    print(image.numpy().shape, idnum.numpy().shape)\nprint(\"Test data IDs:\", idnum.numpy().astype('U')) # U = unicode string","6156ffed":"# numpy and matplotlib defaults\nnp.set_printoptions(threshold = 15, linewidth = 80)\n\ndef batch_to_numpy_images_and_labels(data):\n    images, labels = data\n    numpy_images = images.numpy()\n    numpy_labels = labels.numpy()\n    if numpy_labels.dtype == object: # binary string in this case, these are image ID strings\n        # If no labels, only image IDs, return None for labels (this is the case for test data)\n        numpy_labels = [None for _ in enumerate(numpy_images)]\n    return numpy_images, numpy_labels\n\n\ndef title_from_label_and_target(label, correct_label):\n    if correct_label is None:\n        return CLASSES[label], True\n    correct = (label == correct_label)\n    return \"{} [{}{}{}]\".format(CLASSES[label], 'OK' if correct else 'NO', u\"\\u2192\" if not correct else '',\n                                CLASSES[correct_label] if not correct else ''), correct\n\n\ndef display_one_plant(image, title, subplot, red = False, titlesize = 16):\n    plt.subplot(*subplot)\n    plt.axis('off')\n    plt.imshow(image)\n    if len(title) > 0:\n        plt.title(title, fontsize = int(titlesize) if not red else int(titlesize \/ 1.2), color = 'red' if red else 'black', \n                  fontdict = {'verticalalignment':'center'}, pad = int(titlesize \/ 1.5))\n    return (subplot[0], subplot[1], subplot[2] + 1)\n\n\ndef display_batch_of_images(databatch, predictions = None):\n    \"\"\"This will work with:\n    display_batch_of_images(images)\n    display_batch_of_images(images, predictions)\n    display_batch_of_images((images, labels))\n    display_batch_of_images((images, labels), predictions)\n    \"\"\"\n    # data\n    images, labels = batch_to_numpy_images_and_labels(databatch)\n    if labels is None:\n        labels = [None for _ in enumerate(images)]\n        \n    # auto-squaring: this will drop data that does not fit into square or square-ish rectangle\n    rows = int(math.sqrt(len(images)))\n    cols = len(images)\/\/rows\n        \n    # size and spacing\n    FIGSIZE = 13.0\n    SPACING = 0.1\n    subplot = (rows, cols, 1)\n    if rows < cols:\n        plt.figure(figsize = (FIGSIZE, FIGSIZE \/ cols * rows))\n    else:\n        plt.figure(figsize = (FIGSIZE \/ rows * cols, FIGSIZE))\n    \n    # display\n    for i, (image, label) in enumerate(zip(images[:rows * cols], labels[:rows * cols])):\n        title = '' if label is None else CLASSES[label]\n        correct = True\n        if predictions is not None:\n            title, correct = title_from_label_and_target(predictions[i], label)\n            \n        # magic formula tested to work from 1x1 to 10x10 images\n        dynamic_titlesize = FIGSIZE * SPACING \/ max(rows, cols) * 40 + 3 \n        subplot = display_one_plant(image, title, subplot, not correct, titlesize = dynamic_titlesize)\n    \n    # layout\n    plt.tight_layout()\n    if label is None and predictions is None:\n        plt.subplots_adjust(wspace = 0, hspace = 0)\n    else:\n        plt.subplots_adjust(wspace = SPACING, hspace = SPACING)\n    plt.show()","c1c7b3c8":"# load training dataset to display images\ntraining_dataset = get_training_dataset()\ntraining_dataset = training_dataset.unbatch().batch(20)\ntrain_batch = iter(training_dataset)","b1746939":"# run this cell again for another randomized set of training images\ndisplay_batch_of_images(next(train_batch))","a91afd66":"# load validation dataset to display images\nvalidation_dataset = get_validation_dataset()\nvalidation_dataset = validation_dataset.unbatch().batch(20)\nvalid_batch = iter(validation_dataset)","39f42013":"# run this cell again for another randomized set of validation images\ndisplay_batch_of_images(next(valid_batch))","38995987":"# Learning Rate Schedule for Fine Tuning \ndef exponential_lr(epoch,\n                   start_lr = 0.00001, min_lr = 0.00001, max_lr = 0.00005,\n                   rampup_epochs = 5, sustain_epochs = 0,\n                   exp_decay = 0.8):\n\n    def lr(epoch, start_lr, min_lr, max_lr, rampup_epochs, sustain_epochs, exp_decay):\n        # linear increase from start to rampup_epochs\n        if epoch < rampup_epochs:\n            lr = ((max_lr - start_lr) \/\n                  rampup_epochs * epoch + start_lr)\n            \n        # constant max_lr during sustain_epochs\n        elif epoch < rampup_epochs + sustain_epochs:\n            lr = max_lr\n            \n        # exponential decay towards min_lr\n        else:\n            lr = ((max_lr - min_lr) *\n                  exp_decay ** (epoch - rampup_epochs - sustain_epochs) +\n                  min_lr)\n        return lr\n    \n    return lr(epoch,\n              start_lr,\n              min_lr,\n              max_lr,\n              rampup_epochs,\n              sustain_epochs,\n              exp_decay)\n\nlr_callback = tf.keras.callbacks.LearningRateScheduler(exponential_lr, verbose = True)\n\nrng = [i for i in range(EPOCHS)]\ny = [exponential_lr(x) for x in rng]\nplt.plot(rng, y)\n\nprint(\"Learning rate schedule: {:.3g} to {:.3g} to {:.3g}\".format(y[0], max(y), y[-1]))","6a6f0889":"with strategy.scope():       \n    base_model = tf.keras.applications.DenseNet201(weights = 'imagenet', include_top = False, input_shape = (512, 512, 3))\n    base_model.trainable = True\n    pooled_out = tf.keras.layers.GlobalAveragePooling2D()(base_model.output)\n    out = tf.keras.layers.Dropout(0.5)(pooled_out)\n    out = tf.keras.layers.Dense(len(CLASSES), activation = 'softmax')(out)\n    \n    model = tf.keras.Model(base_model.input, out)\n    \n    model.compile(\n        optimizer = tf.keras.optimizers.Adam(),\n        loss = 'sparse_categorical_crossentropy',  \n        metrics = ['sparse_categorical_accuracy'])","dd3f141b":"# load data DenseNet201\ntrain_dataset = get_training_dataset()\nvalid_dataset = get_validation_dataset()\n\nSTEPS_PER_EPOCH = NUM_TRAINING_IMAGES \/\/ BATCH_SIZE\nVALID_STEPS = NUM_VALIDATION_IMAGES \/\/ BATCH_SIZE","666ed1f1":"# train the model\nhistory = model.fit(train_dataset, steps_per_epoch = STEPS_PER_EPOCH, \n                    epochs = EPOCHS, validation_data = valid_dataset, \n                    validation_steps = VALID_STEPS, callbacks = [lr_callback])","bbc984a7":"model.save('model.h5')","c1812aa1":"# print out variables available to us\nprint(history.history.keys())","29390155":"# create learning curves to evaluate model performance\nhistory_frame = pd.DataFrame(history.history)\nhistory_frame.loc[:, ['loss', 'val_loss']].plot()\nhistory_frame.loc[:, ['sparse_categorical_accuracy', 'val_sparse_categorical_accuracy']].plot();","d7ad502a":"# this code will convert our test image data to a float32 \ndef to_float32(image, label):\n    return tf.cast(image, tf.float32), label","61fd6eca":"test_ds = get_test_dataset(ordered = True) \ntest_ds = test_ds.map(to_float32)\n\nprint('Computing predictions...')\ntest_images_ds = test_ds\ntest_images_ds = test_ds.map(lambda image, idnum: image)\nprobabilities = model.predict(test_images_ds)\npredictions = np.argmax(probabilities, axis = -1)\nprint(predictions)","d8af6297":"print('Generating submission.csv file...')\ntest_ids_ds = test_ds.map(lambda image, idnum: idnum).unbatch()\ntest_ids = next(iter(test_ids_ds.batch(NUM_TEST_IMAGES))).numpy().astype('U') # all in one batch\nnp.savetxt('submission.csv', np.rec.fromarrays([test_ids, predictions]), fmt = ['%s', '%d'], delimiter =',', \n           header = 'id,label', comments = '')\n!head submission.csv","fac58e4c":"## Save the model for inference","3f3de93e":"## Check the dataset output shapes","b3afee0f":"## Train validation split","e2b10b18":"## Data decoding","225efa48":"## This notebook is inspired from [Getting Started: TPUs + Cassava Leaf Disease](https:\/\/www.kaggle.com\/jessemostipak\/getting-started-tpus-cassava-leaf-disease)","ee86d68e":"## Display few images","363fc4b2":"## Train the model","a1fe9881":"## Parse single example from TFRecord format","49d23527":"## Set up some constant variables","a2639a8f":"## Make predictions on test data","4d9d742d":"## Validation data pipeline","fce20d76":"## Data Augmentation","63e85c29":"## Evaluate model","19cb099f":"## Training data pipeline","abb5cfa3":"## Read TFRecords dataset","b2c0af98":"## Import modules","84bb381b":"## Initialize TPU","bc84c8e4":"## Learning rate scheduler","a0c4ea55":"## Build model\n","7300d336":"## Test data pipeline"}}