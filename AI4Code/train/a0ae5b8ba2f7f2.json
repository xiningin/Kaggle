{"cell_type":{"c69b000d":"code","385afd02":"code","53e56d65":"code","60f517e5":"code","462cb9a6":"code","815ec716":"code","acf126a7":"code","3a45d05b":"code","fa841f1d":"code","f09214ae":"code","e043fd6a":"code","dfbb3601":"code","e4c7305e":"code","301873c6":"code","3d3db4a0":"code","1fcae490":"code","baed4399":"code","47305e3f":"code","25fc518d":"code","b2366e09":"code","0559ebf3":"code","f9ae6186":"code","5a83ab64":"code","d6e19be5":"code","c058a464":"code","75ecffe3":"code","6320af77":"code","4b664f81":"code","b3e6612f":"code","70f25934":"code","14f44569":"code","db880479":"code","6b0f57e1":"code","d34a182c":"code","0b43c195":"code","a18949dc":"code","9ba4fd42":"code","bc5ee3bd":"code","46c28155":"code","6d498ec1":"code","3fda8ab5":"code","703d0eb3":"code","0a0fc407":"code","863a079d":"code","0c34035c":"markdown","54e1f30e":"markdown","662ae2b2":"markdown","3f2cfd36":"markdown","0a8411a8":"markdown","7aa7a436":"markdown","424b1755":"markdown","9466d1ee":"markdown","92a49f07":"markdown","f2cf187f":"markdown","2d0dea88":"markdown","5b873254":"markdown","9a0e89fe":"markdown","5496c8c0":"markdown","ea8bb039":"markdown","11de91ef":"markdown","4f3ed50e":"markdown","5f33019d":"markdown","897fd307":"markdown","2936c7e6":"markdown","64d91f4a":"markdown","29546cac":"markdown","f467bab3":"markdown","569055fb":"markdown","d1fe3da0":"markdown","1200dd1a":"markdown","7391d664":"markdown","e9b98947":"markdown","7e951825":"markdown","4ef8a467":"markdown","036bdfe3":"markdown","88323b37":"markdown","618597c9":"markdown"},"source":{"c69b000d":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport plotly.express as px\n%matplotlib inline\nimport warnings\nfrom sklearn.tree import DecisionTreeClassifier, export_graphviz\nfrom sklearn import tree\nfrom lightgbm import LGBMClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.tree import export_graphviz\nfrom xgboost import XGBClassifier\nfrom sklearn.metrics import confusion_matrix, accuracy_score, classification_report\nfrom sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score\nfrom sklearn.preprocessing import StandardScaler\nwarnings.filterwarnings('ignore')","385afd02":"df=pd.read_csv(\"..\/input\/ckdisease\/kidney_disease.csv\")","53e56d65":"df.head()","60f517e5":"df.shape","462cb9a6":"df.size","815ec716":"df.describe().T","acf126a7":"df.info()","3a45d05b":"df.isnull().values.any()","fa841f1d":"df.isnull().sum().sort_values(ascending=False)","f09214ae":"# Checking missing value with percent\nmis_val_percent=((df.isnull().sum()\/df.shape[0])*100).sort_values(ascending=False)\nmis_val_percent","e043fd6a":"for x in ['rc','wc','pcv']:\n    df[x] = df[x].str.extract('(\\d+)').astype(float)","dfbb3601":"df.info()","e4c7305e":"df.drop([\"id\"],axis=1,inplace=True)","301873c6":"# Filling missing numeric data in the dataset with mean\nfor x in ['age','bp','sg','al','su','bgr','bu','sc','sod','pot','hemo','rc','wc','pcv']:\n    df[x].fillna(df[x].mean(),inplace=True)","3d3db4a0":"df.isnull().sum().sort_values(ascending=False)","1fcae490":"df.shape","baed4399":"df.cad.value_counts()","47305e3f":"df['cad'] = df['cad'].replace(to_replace='\\tno',value='no')","25fc518d":"df.cad.value_counts()","b2366e09":"df.dm.value_counts()","0559ebf3":"df['dm'] = df['dm'].replace(to_replace={'\\tno':'no','\\tyes':'yes',' yes':'yes'})","f9ae6186":"df.dm.value_counts()","5a83ab64":"df.classification.value_counts()","d6e19be5":"df['classification'] = df['classification'].replace(to_replace = 'ckd\\t', value = 'ckd')","c058a464":"df.classification.value_counts()","75ecffe3":"df.head()","6320af77":"df[['htn','dm','cad','pe','ane']] = df[['htn','dm','cad','pe','ane']].replace(to_replace={'yes':1,'no':0})\ndf[['rbc','pc']] = df[['rbc','pc']].replace(to_replace={'abnormal':1,'normal':0})\ndf[['pcc','ba']] = df[['pcc','ba']].replace(to_replace={'present':1,'notpresent':0})\ndf[['appet']] = df[['appet']].replace(to_replace={'good':1,'poor':0,'no':np.nan})\ndf['classification'] = df['classification'].replace(to_replace={'ckd':1,'notckd':0})\ne = ['rbc', 'pc', 'pcc', 'ba', 'htn', 'dm', 'cad', 'appet', 'pe', 'ane', 'classification']\ndf[e] = df[e].astype(\"O\")\ndf['classification'] = df['classification'].astype(\"int\")","4b664f81":"df.head()","b3e6612f":"# Visualization\ncorr = df.corr()\nplt.figure(figsize=(18,10))\nsns.heatmap(corr, annot=True)\nplt.show()","70f25934":"cat_cols = [col for col in df.columns if df[col].dtypes == 'O']\nprint('Number of Categorical Variables : ', len(cat_cols))\nprint(cat_cols)","14f44569":"fig, axes = plt.subplots(5, 2, figsize=(12,18))\nfs = ['rbc', 'pc', 'pcc', 'ba', 'htn', 'dm', 'cad', 'appet', 'pe', 'ane']\nfor i, axi in enumerate(axes.flat):\n    sns.countplot(x=fs[i], hue='classification', data=df, palette='prism', ax=axi) \n    axi.set(ylabel='Frequency')\n    axi.legend([\"Not Disease\", \"Disease\"])","db880479":"num_cols = [col for col in df.columns if df[col].dtypes != 'O' and col not in \"id\"]\nprint('Number of numeric variables: ', len(num_cols))\n\nnum_cols","6b0f57e1":"numeric_cols1= ['age','bp','sg','al','su','bgr','bu','sc','sod','pot','hemo','pcv','wc','rc']\n\ndef hist_for_nums(data, numeric_cols1):\n    col_counter = 0\n    data = data.copy()\n    for col in numeric_cols1:\n        data[col].hist(bins=3)\n        plt.xlabel(col)\n        plt.title(col)\n        plt.show()\n        col_counter += 1\n    print(col_counter, \"variables have been plotted\")\nhist_for_nums(df, numeric_cols1)\n","d34a182c":"df[\"classification\"].value_counts()","0b43c195":"fig1, ax1 = plt.subplots()\nax1.pie(df[\"classification\"].value_counts(),  labels=['CKD','NOTCKD'], autopct='%1.1f%%',\n        shadow=True, startangle=90)\nax1.axis('equal')\nplt.show()","a18949dc":"cat_cols = [col for col in df.columns if df[col].dtypes == 'O']\nprint('Number of Categorical Variables : ', len(cat_cols))\ncat_cols","9ba4fd42":"def one_hot_encoder(df, nan_as_category = True):\n    original_columns = list(df.columns)\n    categorical_columns = [col for col in df.columns if df[col].dtype == 'object']\n    df= pd.get_dummies(df, columns= categorical_columns, dummy_na= nan_as_category)\n    new_columns = [c for c in df.columns if c not in original_columns]\n    return df, new_columns\ndf, cat_cols = one_hot_encoder(df, nan_as_category= True)","bc5ee3bd":"df.head()","46c28155":"X = df.drop('classification', axis=1)\ny = df[[\"classification\"]]\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=46)","6d498ec1":"scaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_train = pd.DataFrame(X_train_scaled)\nX_test_scaled = scaler.transform(X_test)\nX_test = pd.DataFrame(X_test_scaled)","3fda8ab5":"lgbm = LGBMClassifier(random_state=46)\nlgbm.fit(X_train, y_train)\nLgbm_pred = lgbm.predict(X_test)\nacc_lgbm = round(lgbm.score(X_train, y_train) * 100, 2)\nacc_lgbm","703d0eb3":"xgboost = XGBClassifier(random_state=46)\nxgboost.fit(X_train, y_train)\nxgboost_pred = xgboost.predict(X_test)\nacc_xgboost = round(xgboost.score(X_train, y_train) * 100, 2)\nacc_xgboost","0a0fc407":"DecisionTree = XGBClassifier(random_state=46)\nDecisionTree.fit(X_train, y_train)\nDecisionTree_pred = DecisionTree.predict(X_test)\nacc_DecisionTree = round(DecisionTree.score(X_train, y_train) * 100, 2)\nacc_DecisionTree","863a079d":"models = pd.DataFrame({\n    'Model': [\"LightGBM\",'Decision Tree', \"XGBOOST\"],\n    'Score': [acc_lgbm,acc_DecisionTree, acc_xgboost]})\nmodels.sort_values(by='Score', ascending=False)","0c34035c":"> **Model**","54e1f30e":"![image.png](attachment:image.png)\nSource: https:\/\/www.verywellhealth.com\/","662ae2b2":"* **Scaling the features**","3f2cfd36":"# 1. IMPORT SOME NECESSARY LIBRARIES","0a8411a8":"**> The description of variables in this data as follows:**\n> **Dependent Variable:**\n* target: Class (nominal): class - (ckd,notckd)\n\n> **Independent Variable:**\n1. Age(numerical) : age in years\n1. Blood Pressure(numerical): bp in mm\/Hg\n1. Specific Gravity(nominal): sg - (1.005,1.010,1.015,1.020,1.025)\n1. Albumin(nominal): al - (0,1,2,3,4,5)\n1. Sugar(nominal): su - (0,1,2,3,4,5)\n1. Red Blood Cells(nominal): rbc - (normal,abnormal)\n1. Pus Cell (nominal): pc - (normal,abnormal)\n1. Pus Cell clumps(nominal): pcc - (present,notpresent)\n1. Bacteria(nominal): ba - (present,notpresent)\n1. Blood Glucose Random(numerical): bgr in mgs\/dl\n1. Blood Urea(numerical): bu in mgs\/dl\n1. Serum Creatinine(numerical): sc in mgs\/dl\n1. Sodium(numerical): sod in mEq\/L\n1. Potassium(numerical) pot in mEq\/L\n1. Hemoglobin(numerical) hemo in gms\n1. Packed Cell Volume(numerical)\n1. White Blood Cell Count(numerical): wc in cells\/cumm\n1. Red Blood Cell Count(numerical): rc in millions\/cmm\n1. Hypertension(nominal) htn : (yes,no)\n1. Diabetes Mellitus(nominal): dm - (yes,no)\n1. Coronary Artery Disease(nominal): cad - (yes,no)\n1. Appetite(nominal): appet - (good,poor)\n1. Pedal Edema(nominal): pe - (yes,no)\n1. Anemia(nominal): ane - (yes,no)**\n","7aa7a436":"> **Model**","424b1755":"> **Model**","9466d1ee":"# Load Data","92a49f07":"> Data Summary: The dataset used in this study is  received  from the UCI Machine Learning Repository.  The dataset was created by Soundarapandian and his colleague in 2015. It includes 400 samples with 25 variables, 11 numeric and 14 nominal. The dependent variable \u201cclass\u201d has two categories (\u201cCKD\u201d and \u201cNOTCKD\u201d).","f2cf187f":"It need to drop \"id\" column. It doesn't have any help for the data analysis.","2d0dea88":"# Replace Incorrect Values\n\u2022\tThere are some incorrect values  with columns \u201ccad(coronary artery disease)\u201d, \u201cdm (diabetes mellitus)\u201d, and \u201cclassification\u201d such as tyes and \\tno.  The values have been recovered systematically. ","5b873254":"* **Visualization of numeric variables**","9a0e89fe":"# 5. ANALYSIS of DEPENDENT VARIABLE (TARGET ANALYSIS)","5496c8c0":"# 7. MODELING","ea8bb039":"> **References:**\n* Alebiosu, C. O., & Ayodele, O. E. (2005). The global burden of chronic kidney disease and the way forward. Ethnicity & Disease, 15(3), 418.\n* Jha, V., Garcia-Garcia, G., Iseki, K., Li, Z., Naicker, S., Plattner, B., ... & Yang, C. W. (2013). Chronic kidney disease: global dimension and perspectives. The Lancet, 382(9888), 260-272.\n","11de91ef":"# 6. ONE-HOT ENCODING","4f3ed50e":"# Chronic Kidney Disease \nChronic kidney disease has affected a valuable portion of World population. For instance, according the Global Burden of Disease study, chronic kidney disease is one of the leading causes of death in the World (Jha et al., 2013). In addition, Alebiosu and  Ayodele (2005) also  indicate that Chronic kidney disease is an aggravated problem for welfare and causes of death in the World. ","5f33019d":"# xgboost","897fd307":"# If you find this work useful, please don't forget upvoting :)","2936c7e6":"# 2. UNDERSTANDING THE DATA-SET","64d91f4a":"# 3. EXPLORATORY DATA ANALYSIS ON CATEGORICAL DATA","29546cac":"***Objective***\n\nThe main purpose of this study is to raise awareness about how fatal Chronic Kidney disease is. To do this,I try to create a model to predict if a patient has this disease or not in the dataset.","f467bab3":"As seen above, there are numerous missing values.  Most variables have various\namounts of missing entries. ","569055fb":"The variables \"'rc','wc','pcv'\" are seen as object type. But they should be  numerical type. It needs to change them to numerical dtype.","d1fe3da0":"Finding the number of values in the dependent column\ntarget: classification (0 = notckd, 1 = ckd)","1200dd1a":"# DecisionTree","7391d664":"# 4. ANALYSIS of NUMERICAL VARIABLE","e9b98947":"# LightGBM","7e951825":"* I split the data set: 80% of the data is train, and 20% of it is test data.","4ef8a467":"# Cleaning and Preprocessing of Data ","036bdfe3":"# Checking missing value","88323b37":"> As seen from the values above, there is no big imbalance between the classes of the dependent variable.","618597c9":"* There is no high correlation among the features in data set."}}