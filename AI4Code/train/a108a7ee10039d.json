{"cell_type":{"afedbc24":"code","1ba58274":"code","9cf405de":"code","42387992":"code","f8ddbb33":"code","8fd80110":"code","86cca26e":"code","de77075a":"code","4a6c1102":"code","5324c2f0":"code","eba2c3ea":"code","4e7cf754":"code","491c3c86":"code","301744c7":"code","2158081e":"code","95bca3f7":"code","2a84e9f4":"markdown"},"source":{"afedbc24":"!pip install detecto\n!pip install pycocotools","1ba58274":"# \u6570\u636e\u91cd\u65b0\u5904\u7406\u8fc7\uff0c\u5c06\u8bad\u7ec3\u96c6\u548c\u9a8c\u8bc1\u96c6\u653e\u5230\u4e86\u4e0d\u540c\u7684\u6587\u4ef6\u5939\u4e2d\n# \u538b\u7f29\u5305\u4e2d\u7684\u4ee3\u7801\u6765\u81eahttps:\/\/github.com\/pytorch\/vision\/tree\/master\/references\/detection\uff0c\u7528\u4e8e\u8bad\u7ec3\u6a21\u578b\u548c\u4f7f\u7528COCO Metrics\u8fdb\u884c\u6a21\u578b\u7684\u8bc4\u5224\n!wget --no-check-certificate -O data.tar \"https:\/\/onedrive.live.com\/download?cid=0A908748F2E95D62&resid=A908748F2E95D62%2186882&authkey=ANkEaADZh0qe0VA\"\n!tar -xf data.tar","9cf405de":"import os\nfrom PIL import Image\nimport torch\nfrom detecto import visualize\nfrom torchvision import transforms\nimport xml.etree.ElementTree as ET","42387992":"class MarsDataset():\n    def __init__(self, label_path, image_path, transform, classes):\n        self.label = list(sorted(os.listdir(label_path)))\n        self.image = list(sorted(os.listdir(image_path)))\n        self.label_path = label_path\n        self.image_path = image_path\n        if transform:\n            self.transforms = transform\n        else:\n            self.transforms = transforms.Compose([transforms.ToTensor(), \n                                transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])])\n        \n        self._classes = ['__background__'] + classes\n        self._int_mapping = {label: index for index, label in enumerate(self._classes)}\n        \n    def __getitem__(self, idx):\n        img_path = os.path.join(self.image_path, self.image[idx])\n        label_path = os.path.join(self.label_path, self.label[idx])\n        \n        img = Image.open(img_path)\n        \n        root = ET.parse(label_path).getroot()\n        \n        filename = root.find('filename').text\n        assert filename == self.image[idx]\n        \n        size = root.find('size')\n        width = int(size.find('width').text)\n        height = int(size.find('height').text)\n        labels = []\n        boxes = []\n        for member in root.findall('object'):\n            box = member.find('bndbox')\n            label = member.find('name').text\n            if label == \"butte\":\n                continue\n            xmin = int(box[0].text)\n            ymin = int(box[1].text)\n            xmax = int(box[2].text)\n            ymax = int(box[3].text)\n            labels.append(self._int_mapping[label])\n            boxes.append([xmin, ymin, xmax, ymax])\n        \n        boxes = torch.tensor(boxes, dtype=torch.float32)\n        labels = torch.tensor(labels, dtype=torch.int64)\n\n        target = {}\n        target['boxes'] = boxes\n        target['labels'] = labels\n        target['image_id'] = torch.tensor([idx])\n        target['area'] = (boxes[:, 3] - boxes[:, 1]) * (boxes[:, 2] - boxes[:, 0])\n        target['iscrowd'] = torch.zeros((len(boxes),), dtype=torch.int64)\n        \n        image = self.transforms(img)\n        \n        return image, target\n    \n    def __len__(self):\n        return len(self.image)","f8ddbb33":"classes = ['crater','cone']\ntrain = MarsDataset(\"label\/train\/\", \"data\/train\/\", None, classes)\ntest = MarsDataset(\"label\/test\/\", \"data\/test\/\", None, classes)","8fd80110":"idx2class = {k+1:v for k,v in enumerate(classes)}\nimage, targets = test[0]\nboxes = targets[\"boxes\"]\nlabels = [idx2class[l.item()] for l in targets[\"labels\"]]\nvisualize.show_labeled_image(image, boxes, labels)","86cca26e":"import torchvision\nfrom torchvision.models.detection import FasterRCNN\nfrom engine import train_one_epoch, evaluate\nimport utils\n\nnum_classes = 3\n# \u6a21\u578b\u5b9a\u4e49\nbackbone = torchvision.models.vgg16(pretrained=True).features\nbackbone.out_channels = 512\nmodel = FasterRCNN(backbone, num_classes=num_classes)\n\ndevice = torch.device('cuda') if torch.cuda.is_available() else torch.device(\"cpu\")\n\nmodel.to(device)\n\ntrain = MarsDataset(\"label\/train\/\", \"data\/train\/\", None, classes)\ntest = MarsDataset(\"label\/test\/\", \"data\/test\/\", None, classes)\ntrain_loader = torch.utils.data.DataLoader(\n        train, batch_size=8, shuffle=True, num_workers=4,collate_fn=utils.collate_fn)\ntest_loader = torch.utils.data.DataLoader(\n        test, batch_size=1, shuffle=False, num_workers=4,collate_fn=utils.collate_fn)","de77075a":"model.train()\nparams = [p for p in model.parameters() if p.requires_grad]\noptimizer = torch.optim.SGD(params, lr=4e-3, momentum=0.9, weight_decay=0.0005)\nlr_scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=8, gamma=0.1)\nnum_epochs = 12\n\nfor epoch in range(num_epochs):\n    # train for one epoch, printing every 10 iterations\n    train_one_epoch(model, optimizer, train_loader, device, epoch, print_freq=10)\n    # update the learning rate\n    lr_scheduler.step()\n    # evaluate on the test dataset\n    evaluate(model, test_loader, device=device)","4a6c1102":"torch.save(model.state_dict(), \"faster-rcnn.pth\")","5324c2f0":"image, targets = test[0]\nmodel.eval()\nmodel.to(torch.device(\"cpu\"))\nwith torch.no_grad():\n    %time pred = model([image])","eba2c3ea":"image, targets = test[0]\nmodel.eval()\nmodel.to(torch.device(\"cpu\"))\nwith torch.no_grad():\n    pred = model([image])\n    pred = pred[0]\n    labels, boxes, scores = pred['labels'], pred['boxes'], pred['scores']\n    labels, boxes, scores = labels[scores>0.3], boxes[scores>0.3], scores[scores>0.3] # \u53ea\u9009\u53d6\u5206\u6570\u5927\u4e8e0.3\u7684\u6846","4e7cf754":"idx2class = {k+1:v for k,v in enumerate(classes)}","491c3c86":"# \u7ecf\u8fc7nms\u4e4b\u540e\u5c55\u793a\u5904\u7406\u7ed3\u679c\nkeep = torchvision.ops.nms(boxes,scores,0.3)\nlabels = labels[keep]\nboxes = boxes[keep]\nscores = scores[keep]\nlabels = [idx2class[val.item()] for val in labels]\nvisualize.show_labeled_image(image, boxes, labels)","301744c7":"# \u6b63\u786e\u7ed3\u679c\u5982\u4e0b\nimage, targets = test[0]\nboxes = targets[\"boxes\"]\nlabels = [idx2class[l.item()] for l in targets[\"labels\"]]\nvisualize.show_labeled_image(image, boxes, labels)","2158081e":"import torchvision\nfrom torchvision.models.detection import FasterRCNN\nfrom torchvision.models.detection.faster_rcnn import FastRCNNPredictor\nfrom engine import train_one_epoch, evaluate\nimport utils\n\nnum_classes = 3\n\n# \u52a0\u5165fpn\nmodel = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)\nin_features = model.roi_heads.box_predictor.cls_score.in_features\nmodel.roi_heads.box_predictor = FastRCNNPredictor(in_features, num_classes)\n\ndevice = torch.device('cuda') if torch.cuda.is_available() else torch.device(\"cpu\")\n\nmodel.to(device)\n\ntrain = MarsDataset(\"label\/train\/\", \"data\/train\/\", None, classes)\ntest = MarsDataset(\"label\/test\/\", \"data\/test\/\", None, classes)\ntrain_loader = torch.utils.data.DataLoader(\n        train, batch_size=8, shuffle=True, num_workers=4,collate_fn=utils.collate_fn)\ntest_loader = torch.utils.data.DataLoader(\n        test, batch_size=1, shuffle=False, num_workers=4,collate_fn=utils.collate_fn)","95bca3f7":"model.train()\nparams = [p for p in model.parameters() if p.requires_grad]\noptimizer = torch.optim.SGD(params, lr=4e-3, momentum=0.9, weight_decay=0.0005)\nlr_scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=8, gamma=0.1)\nnum_epochs = 12\n\nfor epoch in range(num_epochs):\n    # train for one epoch, printing every 10 iterations\n    train_one_epoch(model, optimizer, train_loader, device, epoch, print_freq=10)\n    # update the learning rate\n    lr_scheduler.step()\n    # evaluate on the test dataset\n    evaluate(model, test_loader, device=device)","2a84e9f4":"## backbone\u6539\u4e3a\u52a0\u5165fpn\u7684resnet50"}}