{"cell_type":{"6b99fb41":"code","a8eeb01d":"code","c424939b":"code","831aa13c":"code","8d6ec46b":"code","5ab1f213":"code","32089926":"code","6d88ab00":"code","7635d0cd":"code","0b8b8d24":"code","c10909bb":"code","d66a80d4":"code","31dba06d":"markdown","0c4d3b05":"markdown","5626e848":"markdown","2f3acb19":"markdown","83bb70b0":"markdown","45c8067a":"markdown"},"source":{"6b99fb41":"pip install fitz","a8eeb01d":"pip install PyMuPDF","c424939b":"#Importing Libraries\nfrom operator import itemgetter\nimport fitz\nimport json","831aa13c":"# To identify fonts\ndef fonts(doc, granularity=False):\n    styles = {}\n    font_counts = {}\n\n    for page in doc:\n        blocks = page.getText(\"dict\")[\"blocks\"]\n        for b in blocks:  # iterate through the text blocks\n            if b['type'] == 0:  # block contains text\n                for l in b[\"lines\"]:  # iterate through the text lines\n                    for s in l[\"spans\"]:  # iterate through the text spans\n                        if granularity:\n                            identifier = \"{0}_{1}_{2}_{3}\".format(s['size'], s['flags'], s['font'], s['color'])\n                            styles[identifier] = {'size': s['size'], 'flags': s['flags'], 'font': s['font'],\n                                                  'color': s['color']}\n                        else:\n                            identifier = \"{0}\".format(s['size'])\n                            styles[identifier] = {'size': s['size'], 'font': s['font']}\n\n                        font_counts[identifier] = font_counts.get(identifier, 0) + 1  # count the fonts usage\n\n    font_counts = sorted(font_counts.items(), key=itemgetter(1), reverse=True)\n\n    if len(font_counts) < 1:\n        raise ValueError(\"Zero discriminating fonts found!\")\n\n    return font_counts, styles\n\n\n# To identify font tags\ndef font_tags(font_counts, styles):\n    p_style = styles[font_counts[0][0]]  # get style for most used font by count (paragraph)\n    p_size = p_style['size']  \n\n    # sorting the font sizes high to low, so that we can append the right integer to each tag\n    font_sizes = []\n    for (font_size, count) in font_counts:\n        font_sizes.append(float(font_size))\n    font_sizes.sort(reverse=True)\n\n    # aggregating the tags for each font size\n    idx = 0\n    size_tag = {}\n    for size in font_sizes:\n        idx += 1\n        if size == p_size:\n            idx = 0\n            size_tag[size] = '<p>'\n        if size > p_size:\n            size_tag[size] = '<h>'\n        elif size < p_size:\n            size_tag[size] = '<s>'\n\n    return size_tag\n\n\ndef headers_para(doc, size_tag):\n    header_para = []  # list with headers and paragraphs\n    first = True  # boolean operator for first header\n    previous_s = {}  # previous span\n\n    for page in doc:\n        blocks = page.getText(\"dict\")[\"blocks\"]\n        for b in blocks:  # iterate through the text blocks\n            if b['type'] == 0:  # this block contains text\n\n                # REMEMBER: multiple fonts and sizes are possible IN one block\n\n                block_string = \"\"  # text found in block\n                for l in b[\"lines\"]:  # iterate through the text lines\n                    for s in l[\"spans\"]:  # iterate through the text spans\n                        if s['text'].strip():  # removing whitespaces:\n                            if first:\n                                previous_s = s\n                                first = False\n                                block_string = size_tag[s['size']] + s['text']\n                            else:\n                                if s['size'] == previous_s['size']:\n\n                                    if block_string and all((c == \"|\") for c in block_string):\n                                        # block_string only contains pipes\n                                        block_string = size_tag[s['size']] + s['text']\n                                    if block_string == \"\":\n                                        # new block has started, so append size tag\n                                        block_string = size_tag[s['size']] + s['text']\n                                    else:  # in the same block, so concatenate strings\n                                        block_string += \" \" + s['text']\n\n                                else:\n                                    header_para.append(block_string)\n                                    block_string = size_tag[s['size']] + s['text']\n\n                                previous_s = s\n\n                    # new block started, indicating with a pipe\n                    block_string += \"|\"\n\n                header_para.append(block_string)\n\n    return header_para\n\n\ndef main():\n\n    document = '..\/input\/a-perfect-fit\/dataset\/testResumes\/candidate_018.pdf'\n    doc = fitz.open(document)\n\n    font_counts, styles = fonts(doc, granularity=False)\n\n    size_tag = font_tags(font_counts, styles)\n\n    elements = headers_para(doc, size_tag)\n\n    return elements\n\n\nif __name__ == '__main__':\n    text=main()","8d6ec46b":"# Function to convert  \ndef listToString(s): \n    \n    # initialize an empty string\n    str1 = \" \" \n    \n    # return string  \n    return (str1.join(s))","5ab1f213":"text = listToString(text)","32089926":"print(text)","6d88ab00":"content = text.split('<h>')","7635d0cd":"# List of strings split at <h>\ncontent","0b8b8d24":"parsed = {}\nfor cont in content:\n    content_split = cont.split('<p>')\n    #Assigning the key and contents to the dictionary\n    parsed[content_split[0]] = cont","c10909bb":"parsed","d66a80d4":"with open(\"parsed_doc.json\", 'w') as json_out:\n        json.dump(parsed, json_out)","31dba06d":"**Dump the parsed text into json file**","0c4d3b05":"**Creating a dictionary to store parsed text**","5626e848":"**Converting list to string of text**","2f3acb19":"**Function to identify font tags in document**","83bb70b0":"**Splitting the text after each heading**","45c8067a":"**Installing Dependencies**"}}