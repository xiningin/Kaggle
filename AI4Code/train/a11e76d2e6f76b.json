{"cell_type":{"81d49421":"code","c8f7298c":"code","c1007f84":"code","684d4b27":"code","47f8e588":"code","67c7f175":"code","6b86fd83":"code","daa2eafc":"code","c55ea4a8":"code","4eb9dc6a":"code","da3a3bce":"code","41071e3a":"code","51f51988":"markdown","f2498ab5":"markdown","ad8f0ac4":"markdown","424e122f":"markdown","a5fe5ab8":"markdown","987ee060":"markdown","5019d61b":"markdown","734ccfa2":"markdown","7c2c622c":"markdown","c83fd1ba":"markdown","5af2ef09":"markdown","53b98091":"markdown","901bbd8b":"markdown","806be5cd":"markdown","7ce8d38a":"markdown","9dd5f2ee":"markdown","8df17561":"markdown","4f8d0c55":"markdown","01053a06":"markdown","e72b0a16":"markdown","7738c67a":"markdown","a3eaf086":"markdown","b3e2153e":"markdown","3a8a7b82":"markdown","04523e58":"markdown","308c8094":"markdown","d61a3466":"markdown","1d482cc5":"markdown","db39bee7":"markdown","5f30ca02":"markdown","dfae1b44":"markdown","346c8add":"markdown","7acbba9e":"markdown","719b4f13":"markdown","bf750191":"markdown","4b8c7c76":"markdown"},"source":{"81d49421":"from IPython.display import Image\nImage(\"\/kaggle\/input\/constrained-portfolio-optimization\/Lesson7GoalHeaderImage.png\")\n","c8f7298c":"from IPython.display import Image\nImage(\"\/kaggle\/input\/constrained-portfolio-optimization\/Lesson7Eqn7_1.png\")","c1007f84":"# function computes asset returns \ndef StockReturnsComputing(StockPrice, Rows, Columns):\n    \n    import numpy as np\n    \n    StockReturn = np.zeros([Rows-1, Columns])\n    for j in range(Columns):        # j: Assets\n        for i in range(Rows-1):     # i: Daily Prices\n            StockReturn[i,j]=((StockPrice[i+1, j]-StockPrice[i,j])\/StockPrice[i,j])*100\n\n    return StockReturn","684d4b27":"#compute stock returns for k-portfolio 1 and market returns to compute asset betas\n\n#Dependencies\nimport numpy as np\nimport pandas as pd\n\n\n#input k portfolio 1 dataset  comprising 15 Dow stocks and DJIA market dataset \n#over a 3 Year period (April 2016 to April 2019)\nstockFileName = '\/kaggle\/input\/constrained-portfolio-optimization\/DJIAkpf1Apr2016to20193YBeta.csv'\nmarketFileName = '\/kaggle\/input\/constrained-portfolio-optimization\/DJIAMarketDataApr2016to20193YBeta.csv'\nstockRows = 756    #excluding header of stock dataset \nstockColumns = 15  #excluding date of stock dataset \nmarketRows = 756   #excluding header of market dataset\nmarketColumns = 7  #excluding date of market dataset\n\n#read stock prices and closing prices of market data (column index 4),  into dataframes\ndfStock = pd.read_csv(stockFileName,  nrows= stockRows)\ndfMarket = pd.read_csv(marketFileName, nrows = marketRows)\nstockData = dfStock.iloc[0:, 1:]\nmarketData = dfMarket.iloc[0:, [4]] \n\n#extract asset labels in the portfolio\nassetLabels = dfStock.columns[1:stockColumns+1].tolist()\nprint('Asset labels of k-portfolio 1: \\n', assetLabels)\n\n#compute asset returns\narStockPrices = np.asarray(stockData)\n[sRows, sCols]=arStockPrices.shape\narStockReturns = StockReturnsComputing(arStockPrices, sRows, sCols)\n\n#compute market returns\narMarketPrices = np.asarray(marketData)\n[mRows, mCols]=arMarketPrices.shape\narMarketReturns = StockReturnsComputing(arMarketPrices, mRows, mCols)\n","47f8e588":"#compute betas of the assets in k-portfolio 1\nbeta= []\nVar = np.var(arMarketReturns, ddof =1)\nfor i in range(stockColumns):\n    CovarMat = np.cov(arMarketReturns[:,0], arStockReturns[:, i ])\n    Covar  = CovarMat[1,0]\n    beta.append(Covar\/Var)\n\n\n#display results\nprint('Asset Betas:\\n')\nfor data in beta:\n    print('{:9.3f}'.format(data))","67c7f175":"from IPython.display import Image\nImage(\"\/kaggle\/input\/constrained-portfolio-optimization\/Lesson7Eqn7_2.png\")","6b86fd83":"from IPython.display import Image\nImage(\"\/kaggle\/input\/constrained-portfolio-optimization\/Lesson7Eqn7_3.png\")","daa2eafc":"#obtain mean returns and variance-covariance matrix of returns of k-portfolio 1\n#historical dataset: DJIA Index April 2014 to April 2019\n\n#Dependencies\nimport numpy as np\nimport pandas as pd\n\n#input k portfolio 1 dataset comprising 15 Dow stocks\nStockFileName = '\/kaggle\/input\/constrained-portfolio-optimization\/DJIA_Apr112014_Apr112019_kpf1.csv'\nRows = 1259  #excluding header\nColumns = 15  #excluding date\n\n#read stock prices \ndf = pd.read_csv(StockFileName,  nrows= Rows)\n\n#extract asset labels\nassetLabels = df.columns[1:Columns+1].tolist()\nprint('Asset labels for k-portfolio 1: \\n', assetLabels)\n\n#extract the asset prices data\nstockData = df.iloc[0:, 1:]\n\n#compute asset returns\narStockPrices = np.asarray(stockData)\n[Rows, Cols]=arStockPrices.shape\narReturns = StockReturnsComputing(arStockPrices, Rows, Cols)\n\n#set precision for printing data\nnp.set_printoptions(precision=3, suppress = True)\n\n#compute mean returns and variance covariance matrix of returns\nmeanReturns = np.mean(arReturns, axis = 0)\ncovReturns = np.cov(arReturns, rowvar=False)\nprint('\\nMean Returns:\\n', meanReturns)\nprint('\\nVariance-Covariance Matrix of Returns:\\n', covReturns)\n\n","c55ea4a8":"#function to handle bi-criterion portfolio optimization with constraints\n\n#dependencies\nimport numpy as np\nfrom scipy import optimize \n\ndef BiCriterionFunctionOptmzn(MeanReturns, CovarReturns, RiskAversParam, PortfolioSize):\n       \n    def  f(x, MeanReturns, CovarReturns, RiskAversParam, PortfolioSize):\n        PortfolioVariance = np.matmul(np.matmul(x, CovarReturns), x.T) \n        PortfolioExpReturn = np.matmul(np.array(MeanReturns),x.T)\n        func = RiskAversParam * PortfolioVariance - (1-RiskAversParam)*PortfolioExpReturn\n        return func\n\n    def ConstraintEq(x):\n        A=np.ones(x.shape)\n        b=1\n        constraintVal = np.matmul(A,x.T)-b \n        return constraintVal\n    \n    def ConstraintIneqUpBounds(x):\n        A= [[0,0,0,0,0, 1,0,1,1,0, 1,1,1,1,1], [1,1,1,1,1,0,1,0,0,1,0,0,0,0,0]]\n        bUpBounds =np.array([0.6,0.4]).T\n        constraintValUpBounds = bUpBounds-np.matmul(A,x.T) \n        return constraintValUpBounds\n\n    def ConstraintIneqLowBounds(x):\n        A= [[0,0,0,0,0,1,0,1,1,0, 1,1,1,1,1], [1,1,1,1,1,0,1,0,0,1,0,0,0,0,0]]\n        bLowBounds =np.array([0.01, 0.01]).T\n        constraintValLowBounds = np.matmul(A,x.T)-bLowBounds  \n        return constraintValLowBounds\n    \n    xinit=np.repeat(0.01, PortfolioSize)\n    cons = ({'type': 'eq', 'fun':ConstraintEq}, \\\n            {'type':'ineq', 'fun': ConstraintIneqUpBounds},\\\n            {'type':'ineq', 'fun': ConstraintIneqLowBounds})\n    bnds = [(0,0.1),(0,0.1), (0,0.1), (0,0.1), (0,0.1), (0,1), (0,0.1), (0,1),\\\n            (0,1), (0,0.1), (0,1),  (0,1),(0,1),(0,1),(0,1)]\n\n    opt = optimize.minimize (f, x0 = xinit, args = ( MeanReturns, CovarReturns,\\\n                                                    RiskAversParam, PortfolioSize), \\\n                             method = 'SLSQP',  bounds = bnds, constraints = cons, \\\n                             tol = 10**-3)\n    print(opt)\n    return opt\n\n","4eb9dc6a":"#obtain optimal portfolios for the constrained portfolio optimization model\n#Maximize returns and Minimize risk with fully invested, bound and \n#class constraints\n\n#set portfolio size \nportfolioSize = Columns\n\n#initialization\nxOptimal =[]\nminRiskPoint = []\nexpPortfolioReturnPoint =[]\n\nfor points in range(0,60):\n    riskAversParam = points\/60.0\n    result = BiCriterionFunctionOptmzn(meanReturns, covReturns, riskAversParam, \\\n                                       portfolioSize)\n    xOptimal.append(result.x)\n\n#compute annualized risk and return  of the optimal portfolios for trading days = 251  \nxOptimalArray = np.array(xOptimal)\nminRiskPoint = np.diagonal(np.matmul((np.matmul(xOptimalArray,covReturns)),\\\n                                     np.transpose(xOptimalArray)))\nriskPoint =   np.sqrt(minRiskPoint*251) \nexpPortfolioReturnPoint= np.matmul(xOptimalArray, meanReturns )\nretPoint = 251*np.array(expPortfolioReturnPoint) \n\n#set precision for printing results\nnp.set_printoptions(precision=3, suppress = True)\n\n#display optimal portfolio results\nprint(\"Optimal weights of the efficient set portfolios\\n:\", xOptimalArray)\nprint(\"\\nAnnualized Risk and Return of the efficient set portfolios:\\n\",\\\n      np.c_[riskPoint, retPoint])\n","da3a3bce":"import matplotlib.pyplot as plt\n\n#Graph Efficient Frontier for the constrained portfolio model\nNoPoints = riskPoint.size\n\ncolours = \"blue\"\narea = np.pi*3\n\nplt.title('Efficient Frontier for constrained k-portfolio 1 of Dow stocks')\nplt.xlabel('Annualized Risk(%)')\nplt.ylabel('Annualized Expected Portfolio Return(%)' )\nplt.scatter(riskPoint, retPoint, s=area, c=colours, alpha =0.5)\nplt.show()\n","41071e3a":"from IPython.display import Image\nImage(\"\/kaggle\/input\/constrained-portfolio-optimization\/Lesson7ExitTailImage.png\")","51f51988":"# Constrained Portfolio Optimization ","f2498ab5":"<h5 align=\"right\">..............................(7.3)<\/h5>","ad8f0ac4":"<h5 align=\"right\">..............................(7.1)<\/h5>","424e122f":"## 7.1 Introduction","a5fe5ab8":"Of the two objective functions, minimizing the variance of the portfolio is tantamount to minimizing its risk and hence the objective function in the model has been defined accordingly. ","987ee060":"### Companion Reading  ","5019d61b":"The transformed single-criterion constrained optimization model is defined as, ","734ccfa2":"Let us suppose that an investor decides to follow this constrained portfolio optimization model to invest in a  $k$-portfolio of Dow stocks listed below ($k$-portfolio 1, for example). Refer **Lesson 3 Heuristic Portfolio Selection** to know more about $k$ portfolios and Sec. 3.5 to know about $k$-portfolio 1.   \n  \n**$k$-portfolio 1**:  \n\n{Coca-Cola (KO), United Health (UNH), Walt Disney (DIS), IBM (IBM), Cisco (CSCO), JPMorgan Chase (JPM), Goldman Sachs (GS), Walgreens Boots Alliance (WBA), Apple (AAPL), Home Depot (HD), American Express (AXP), McDonald's (MCD), Merck (MRK), Boeing (BA), Caterpillar (CAT)}     \n","7c2c622c":"## 7.3 Case Study","c83fd1ba":"The first step is to identify the stocks belonging to the asset classes of *High Volatility* and *Low Volatility*,  by computing the asset betas.   \n  \nThe asset betas are computed as  $\\beta = \\frac{ cov(r_i, r_P)} { var(r_P)}$  where $cov(r_i, r_P)$ is the covariance of the rate of return $r_i$  of the asset $i$ in a portfolio P and $r_P$,  the rate of return of the portfolio P. $var(r_P)$ is the variance of the rate of return $r_P$ of the portfolio P. In practice, the portfolio return $r_P$ is replaced by the market index return as explained in Sec. 1.3. of **Lesson 1 Fundamentals of  Risk and Return of a Portfolio**.   \n  \nThe asset betas  are obtained over a 3-year historical period (DJIA Index: April 2016 - April 2019).   \n\nTo compute the asset betas, the asset returns and the market returns need to be readied. The Python function **StockReturnsComputing** doubles up  to compute both asset returns and market returns.   ","5af2ef09":"The risk aversion parameter $\\lambda$ varies between [0,1]. Thus, when $\\lambda = 0$, the single-criterion function becomes $min\\left( - \\sum{W_i.\\mu_i} \\right)$ which is equivalent to maximizing return and when $\\lambda = 1$, the single-criterion function becomes $min\\left( {\\sum\\sum\\ {W_i.W_j.\\sigma_{ij}}} \\right)$ which is tantamount to minimizing the portfolio  risk. For all other values of $\\lambda$, solving the portfolio optimization model for each value of $\\lambda$,  yields a collection of optimal portfolio sets that forms the efficient set of the portfolio. The risk return couples of these efficient sets will trace the corresponding **efficient frontier** for the portfolio. (See **Lesson 5 Mean-Variance Optimization of Portfolios** to know about efficient frontier). ","53b98091":"<h3 align=\"left\">References<\/h3>   \n \n \n[PAI 18]   Vijayalakshmi Pai G. A., Metaheuristics for Portfolio Optimization- An Introduction using MATLAB, Wiley-ISTE, 2018. https:\/\/www.mathworks.com\/academia\/books\/metaheuristics-for-portfolio-optimization-pai.html   \n  \n**GitHub Repository**    \n\nPythonFinance-PortfolioOptimization https:\/\/github.com\/PaiViji\n","901bbd8b":"It can be observed that the risk-return couples for the constrained portfolio optimization model, during one of its runs,  runs through the points beginning at (12.002%, 11.4%), which represents the minimum risk portfolio, to end at  (15.375%, 21.883%) which represents the maximum expected portfolio return portfolio.   \nThe optimal weight set corresponding to the minimum-risk portfolio,  which possibly could be opted for by a risk averse investor  is,  \n[0.078, 0.1, 0.044, 0.003, 0.091, 0.044, 0.009, 0, 0, 0.076, 0.368, 0.158, 0.03, 0, 0]. This weight set corresponding to $\\lambda =1$, occupies the  last row of array variable **xOptimalArray**.   \nThe interpretation is, if the risk averse investor desires to hold such a constrained portfolio with the minimal annualized risk of 12.002%, then the investor can be assured of an annualized expected portfolio return of 11.4%. To accomplish this,  the capital allocation to various assets in the portfolio ($k$-portfolio 1, in fact) should be done in the following fashion, as dictated by the corresponding optimal weights:  \n\n['AAPL': 7.8%], ['AXP': 10%], ['BA': 4.4%], ['CAT': 0.3%], ['CSCO': 9.1%], ['DIS': 4.4%], ['GS': 0.9%%],  ['HD': 0%], ['IBM': 0%], ['JPM': 7.6%], ['KO': 36.8%], ['MCD': 15.8%], ['MRK': 0.03%], ['UNH': 0%], ['WBA': 0%].   \n\nIt can be seen that all the constraints imposed  by the investor on the model are satisfied by the optimal solution.  \n  \n - The sum of optimal weights equals 1 (100% capital allocation) verifying the fully invested nature of the portfolio which was one of the constraints imposed by the investor (condition 8).   \n - The capital allocations made to the asset classes of  *HighVolatility* : { 'AAPL', 'AXP', 'BA',  'CAT',  'CSCO', 'GS', 'JPM'} and  *LowVolatility*  : {'DIS',  'HD',  'IBM',  'KO',  'MCD',  'MRK',  'UNH',  'WBA'}, equal 40% and 60% of the capital,  satisfying the class constraints imposed by the investor (conditions 3-5).  \n - With regard to the bound constraints, the optimal weights of all assets belonging to the *HighVolatility* class do not exceed 0.1 (10% capital allocation) as desired by the investor. The zero weights accorded to the assets {'HD', 'IBM', 'UNH', 'WBA'} is perfectly fine considering the fact that the investor had set the weights of all assets to have zero lower bounds (conditions 6-7).    \n  \n  \nA similar verification and interpretation of the results can be carried out for each of the optimal portfolios graphed by the efficient frontier.   \n\nAs already discussed in Sec. 5.4 of **Lesson 5 Mean-Variance Optimization of Portfolios**, the efficient frontier can be used by the investor to select an optimal portfolio with an  expected portfolio return of y%, given the investor's choice of  x% risk or vice-versa. It can be verified that the optimal portfolio weights satisfy all the constraints laid down by the investor and guarantees the desired risk - return of (x%, y%) as emphasized by the investor. ","806be5cd":"From the output, it can be gathered that $k$-portfolio 1 has the following asset betas:  \n  \n['AAPL': 1.134], ['AXP': 1.087], ['BA': 1.392], ['CAT': 1.527], ['CSCO': 1.154], ['DIS': 0.767], ['GS': 1.317],  ['HD': 0.937], ['IBM': 0.976], ['JPM': 1.115], ['KO': 0.460], ['MCD': 0.554], ['MRK': 0.735], ['UNH': 0.950], ['WBA': 0.850]  \n\nChoosing those stocks with $\\beta >1$ as high volatility stocks and the rest as low volatility stocks, the asset classes obtained are:  \n\nAsset class *HighVolatility* : { 'AAPL', 'AXP', 'BA',  'CAT',  'CSCO', 'GS', 'JPM']  \nAsset class *LowVolatility*  : {'DIS',  'HD',  'IBM',  'KO',  'MCD',  'MRK',  'UNH',  'WBA'}\n","7ce8d38a":"The market returns **arMarketReturns** and stock returns  **arStockReturns** for $k$-portfolio 1 are used to obtain the asset betas. ","9dd5f2ee":"The main Python program to optimize the constrained portfolio optimization model described in (7.3) is shown below. **riskAversParam** is allowed to vary between [0,1] to generate $m$ points and for each one of these values  (7.3) is repeatedly  solved using the function **BiCriterionFunctionOptmzn** to arrive at the optimal weights. $m$ can be chosen to be any positive integer that will eventually help to graph the efficient frontier clearly using the optimal risk-return couples of the efficient set.  \n  \n  \nThis demonstration makes use of $m$ = 60.  **xOptimalArray** therefore, represents an array of 60 optimal weight sets. Arrays **riskPoint** and **retPoint** represent the annualized risk and return of the corresponding optimal portfolio sets generated. ","8df17561":"The Python program shown below,  reads the 3-Year stock price dataset for $k$-portfolio 1 and the market dataset for the corresponding period, computes the respective returns and  the asset betas for the $k$-portfolio 1. ","4f8d0c55":"Tracing the efficient frontier using the risk-return couples represented by the arrays **riskPoint** and **retPoint** yields the following:","01053a06":"The optimization model described by (7.1) holds two objective functions of maximizing return and minimizing risk. Though there are methods available in the literature to tackle Multi-objective optimization problems, a time-tested approach is to tranform the multi-objective functions into a single-criterion function.    \n\nKnown as **linear scalarization**, the tranformation function is a **weighted** formulation of the two objective functions as shown below. In the context of Portfolio Optimization theory, $\\lambda$ is referred to as **risk-aversion parameter*.\n  ","e72b0a16":"The mathematical formulation of the model is as shown below.  \n","7738c67a":"## 7.4  Interpretation of  Results","a3eaf086":"### Identification of High Volatility  and Low Volatility Assets","b3e2153e":"Having determined the asset classes of *HighVolatility* and *LowVolatility* based on the 3-Year asset betas, we now proceed to demonstrate the execution of the single-criterion constrained optimization model described by (7.3), using a Python program.  \nThe historical dataset (DJIA Index: April 2014-April 2019), is used to obtain the mean returns and the variance-covariance matrix of returns of $k$-portfolio 1.   \nThe following Python code demonstrates the same. ","3a8a7b82":"### Obtaining Optimal Constrained Portfolios","04523e58":"Solving the portfolio optimization model defined by (7.1) obtains the optimal weights which  yields maximum return for a corresponding minimal risk, adhering to all  the investor preferential constraints imposed on the portfolio. ","308c8094":"* **Python for Portfolio Optimization: The Ascent!**\n\nFirst working lessons to ascend the hilly terrain of Portfolio Optimization in seven strides (Lessons), beginning with the fundamentals (Lesson 1) and climbing slope after slope (Lessons 2-6), to reach the first peak of constrained portfolio optimization models (Lesson 7), amongst a range of peaks waiting beyond!\n\n* **Lesson 1 Fundamentals of Risk and Return of a Portfolio**    \n\n* **Lesson 2 Some Glimpses of Financial Data Wrangling**   \n\n* **Lesson 3 Heuristic Portfolio Selection**  \n\n* **Lesson 4 Traditional Methods for Portfolio Construction**  \n\n* **Lesson 5 Mean-Variance Optimization of Portfolios**  \n  \n* **Lesson 6 Sharpe Ratio based Portfolio Optimization**","d61a3466":"##  Lesson 7\n","1d482cc5":"Let P be a portfolio comprising assets $A_1, A_2, ...A_N$ with weights $W_1, W_2, ...W_N$   asset returns $\\mu_1, \\mu_2, ...\\mu_N$ and variance-covariance matrix of returns $\\sigma_{i,j}$ .  Let $HighVolatility$ and $LowVolatility$ denote the asset classes of high volatility and low volatility stocks selected by the investor, based on their betas. (See **Lesson 1 Fundamentals of Risk and Return of a Portfolio** to know about portfolio risk,  return and computation of asset betas).    \n\n","db39bee7":"Let us consider an investor who desires to invest in a portfolio of assets with the following objectives:  \n\n(1) maximize expected portfolio return, and   \n(2) minimize portfolio risk.  \n\nHowever, the moderately risk averse investor decides to impose the following preferences and conditions on the investment:  \n\n(3) Choose a mix of **High Volatility** and **Low Volatility** stocks based on the **betas** of the assets in the stock universe. The investor thereby wishes to invest in the two **asset classes** of *High Volatility* and *Low Volatility* stocks,  spread across any sector. To recall,  assets with betas greater than 1 are highly volatile stocks and those which are less than 1 are low volatile stocks. (Refer **Lesson 1 Fundamentals of Risk and Return of a Portfolio** to know more about betas of assets). The intention behind the investor's choice for high volatility assets is just that stock market volatility,  which can up investment risk, can also throw open avenues to earn superior returns on the investment.      \n\n(4) Exercise caution over the inclusion of high volatility stocks by ensuring that only 40% of the  capital is invested in these  stocks, with the larger balance of  60% invested in low volatility stocks.  \n\n(5) Having decided on the asset classes, ensure that a minimal  amount of 1% (at least) of the capital,  must be invested in the two classes. \n\n(6) Some assets if need be may not be invested in,  in other words, the lower bounds for the weights could be zero ($W_i \\ge 0$).   \n\n(7) Impose a ceiling on the amount of capital allotted for individual high volatility and low volatility stocks. Thus while the weights of low volatility stocks can have an upper bound of 1 ($W_i \\le 1$), those of  high volatility stocks cannot exceed 0.1 ($W_i \\le 0.1$), which means that only a maximum of 10% of the capital can be invested in each of the high volatility assets.    \n\n(8) Ensure a  fully invested portfolio, where the entire capital is invested in the assets of the portfolio.  \n  \nThe investor seems to be asking for the moon! - doesn't she? Let's explore.","5f30ca02":"### Transformation of bi-criterion objective function into single-criterion function","dfae1b44":"The function **BiCriterionFunctionOptmzn** handles the objective function, equality constraint and class constraints described in (7.3). Thus, it   defines the single-criterion objective function of (7.3) as <b>f<\/b>, where  **RiskAversParam** denotes parameter $\\lambda$. Function  **ConstraintEq** defines the fully invested portfolio constraint which ensures that the sum of weights equals 1. Function **ConstraintIneqUpBounds** defines the upper bounds of the class constraints with regard to *HighVolatility* and *LowVolatility* asset classes as 0.4 and 0.6 respectively.  Function **ConstraintIneqLowBounds** defines the lower bounds of the class constraints with regard to *HighVolatility* and *LowVolatility* asset classes as 0.01 for both. **bnds** inputs the respective lower and upper bounds of the high volatility and low volatility assets in the portfolio.  \n\nThe **optimize.minimize** function from **scipy.optimize** package undertakes the constrained optimization of the portfolio. \n","346c8add":"This blog  is an abridged adaptation of concepts discussed in Chapter 1 and Chapter 3 of [PAI 18] to Dow Jones dataset (DJIA index: April, 2014- April, 2019) and implemented in Python. Readers (read \"worker bees\"),  seeking more information may refer to the corresponding chapters in the  book.","7acbba9e":"## Prologue","719b4f13":"## 7.2 Portfolio Optimization Model","bf750191":"The objectives, preferences and conditions laid down by the investor on the portfolio concerned, defines what is generally termed as a **Constrained Portfolio Optimization** model.   \nObjectives (1) and (2) described above,  define the **objective functions** of the portfolio optimization model. The model is therefore a **two-objective non-linear optimization model**.   \n\n\nThe investor preferences and conditions described in points (3) - (7) define the **constraints** of the optimization model.   \n\n\nPreference (3) and conditions (4) and (5), described above,  together define what is known as  **class constraint** in portfolio optimization theory.  \nClass constraints  or group constraints denote situations when assets belonging to a specific sector or asset class,  have bounds imposed on their respective *sum of weights*, (i.e.) $ \\epsilon \\le \\sum {W_i} \\le \\delta$, where \n${i\\in Asset Class A}$  \nTherefore, there are two class constraints imposed on the portfolio where the sum of weights of the stocks in the asset classes of High Volatility and Low Volatility are bound by 1% of the capital  at the lower end and 40% and 60% of the capital at the higher end, respectively.   \n  \n  \nConditions (6) and (7) together define what are referred to as **bound constraints**, in portfolio optimization theory.   \n    \n**Bound constraints** define the specific upper and lower bounds imposed on the weights of the assets, (i.e.) $\\epsilon_i \\le W_i \\le\\delta_i$.   \nThe investor has opted for zero lower bounds for all stocks in the portfolio,  with the upper bounds of 0.1 and 1 for the high volatility and low volatility stocks respectively.  \n  \n  \nCondition (8) only means that the investor desires to  invest the entire capital in the portfolio, which means that the sum of weights of the portfolio should equal  1.  \n\n","4b8c7c76":"<h5 align=\"right\">...............................(7.2)<\/h5>"}}