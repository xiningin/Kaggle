{"cell_type":{"ae9a55d4":"code","b6f3a016":"code","f8763267":"code","a193dcde":"code","15734484":"code","619ab976":"code","73bf56ce":"code","b3060c3d":"code","62e6110e":"code","ded1cab3":"code","19da35e0":"code","7453cf0e":"markdown","abb25049":"markdown","80683aee":"markdown","42249fc4":"markdown","b8232281":"markdown","07aee589":"markdown","5ac721f2":"markdown","f235e87c":"markdown","30f47c57":"markdown"},"source":{"ae9a55d4":"import torch\nimport torch.nn as nn\nimport numpy as np","b6f3a016":"inputs = torch.Tensor([[0.1, 0.1, 0.1, 0.1, 0.8]]).float() # pred as 4\ntargets = torch.Tensor([3]).long()\n\nloss_func = torch.nn.CrossEntropyLoss()\nprint(loss_func(inputs, targets))","f8763267":"inputs = torch.Tensor([[0.8, 0.1, 0.1, 0.1, 0.1]]).float() # pred as 0\ntargets = torch.Tensor([3]).long()\n\nloss_func = torch.nn.CrossEntropyLoss()\nprint(loss_func(inputs, targets))","a193dcde":"def pos_weight(pred_tensor, pos_tensor, neg_weight=1, pos_weight=1):\n    # neg_weight for when pred position < target position\n    # pos_weight for when pred position > target position\n    gap = torch.argmax(pred_tensor, dim=1) - pos_tensor\n    gap = gap.type(torch.float32)\n    return torch.where(gap < 0, -neg_weight * gap, pos_weight * gap)","15734484":"inputs = torch.Tensor([[0.1, 0.1, 0.1, 0.1, 0.8]]).float() # pred as 4\ntargets = torch.Tensor([3]).long()\n\npos_weight(inputs, targets, 1, 1)","619ab976":"inputs = torch.Tensor([[0.8, 0.1, 0.1, 0.1, 0.1]]).float() # pred as 0\ntargets = torch.Tensor([3]).long()\n\npos_weight(inputs, targets, 1, 1)","73bf56ce":"def loss_fn(start_logits, end_logits, start_positions, end_positions):\n    loss_fct = nn.CrossEntropyLoss(reduce='none') # do reduction later\n    \n    start_loss = loss_fct(start_logits, start_positions) * pos_weight(start_logits, start_positions, 1, 1)\n    end_loss = loss_fct(end_logits, end_positions) * pos_weight(end_logits, end_positions, 1, 1)\n    \n    start_loss = torch.mean(start_loss)\n    end_loss = torch.mean(end_loss)\n    \n    total_loss = (start_loss + end_loss)\n    return total_loss","b3060c3d":"# argmax pred for the start is 3, target is 1\n# argmax pred for the end is 3, target is 3\nstart = torch.Tensor([[0.1, 0.1, 0.1, 0.8, 0.1]]).float()\nstart_target = torch.Tensor([1]).long()\n\nend = torch.Tensor([[0.1, 0.1, 0.1, 0.8, 0.1]]).float()\nend_target = torch.Tensor([3]).long()","62e6110e":"loss_fn(start, end, start_target, end_target)","ded1cab3":"# argmax pred for the start is 2, target is 1\n# argmax pred for the end is 3, target is 3\nstart = torch.Tensor([[0.1, 0.1, 0.8, 0.1, 0.1]]).float()\nstart_target = torch.Tensor([1]).long()\n\nend = torch.Tensor([[0.1, 0.1, 0.1, 0.8, 0.1]]).float()\nend_target = torch.Tensor([3]).long()","19da35e0":"loss_fn(start, end, start_target, end_target)","7453cf0e":"In [abhishek](https:\/\/www.kaggle.com\/abhishek)'s great baseline notebook, the loss function used is the `CrossEntropyLoss`.  \n\nHowever, one drawback of `CrossEntropyLoss` if that it doesn't care \"the position of the error\".   \n\nWe can see from a simple example.   \n\nLet's say we got a sentence of length 5 (index starts from 0), and the correct answer is position 3.   \n\nThe first prediction has its highest probability at position 4, while the second prediction put it at position 0.","abb25049":"As you can see, the loss is the same, but 4 is much closer to 3 than 0. Then how can we optimise the loss function a bit?","80683aee":"Now it's time to combine them. A simply tweak on the original `loss_fn` is all we need.  \n\nYou can either multiple `loss_fct` with `pos_weight`, or squeeze `pos_weight` first and then add them together.","42249fc4":"The larger the gap is, the more penalty it'll get.","b8232281":"# Penalty based on the position gap","07aee589":"# Start from CrossEntropyLoss","5ac721f2":"# Combine them","f235e87c":"As you can see, the loss for the second one is smaller, which also aligns with the jaccard.","30f47c57":"Now let's add more penalty when our \"argmax prediction\" is far away from our target.   \n\nThis function also allows you to add different penalty to \"argmax prediction\" before\/after the target."}}