{"cell_type":{"7c2c6000":"code","ad5255b9":"code","61194eb8":"code","0c79eb35":"code","02dbc681":"markdown","f3b684fe":"markdown","2d1f6595":"markdown","03a4dc84":"markdown","7069a8f6":"markdown","2acdf0be":"markdown","2a770ad7":"markdown","2d3e9087":"markdown","9c3199c5":"markdown","fe6c99f6":"markdown","9043cbd3":"markdown","332bef34":"markdown","a7d3f0ea":"markdown","b563361f":"markdown","e2977e09":"markdown","75ac883f":"markdown","0625a536":"markdown","1a4438de":"markdown","6b8a6d2f":"markdown","987f1d7e":"markdown","b4741530":"markdown"},"source":{"7c2c6000":"import pandas as pd\nimport numpy as np\nimport os\nimport seaborn as sns\n\nfrom pathlib import Path\nfrom textwrap import wrap\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\nfrom ipywidgets import interact, fixed\n\n%matplotlib inline\nfrom matplotlib import animation\nfrom matplotlib.animation import FFMpegWriter\n\nimport dateutil\nfrom math import radians\nfrom IPython.display import Video","ad5255b9":"def create_football_field(fig,\n                          ax,\n                          linenumbers=True,\n                          endzones=True,\n                          highlight_line=False,\n                          highlight_line_number=50,\n                          highlighted_name='Line of Scrimmage',\n                          highlight_first_down_line=False,\n                          yards_to_go=10,\n                          fifty_is_los=False):\n    \"\"\"\n    Function that plots the football field for viewing plays.\n    Allows for showing or hiding endzones.\n    \"\"\"\n    rect = patches.Rectangle((0, 0), 120, 53.3, linewidth=0.1,\n                             edgecolor='gray', facecolor='white', zorder=0)\n\n    ax.add_patch(rect)\n\n    plt.plot([10, 10, 10, 20, 20, 30, 30, 40, 40, 50, 50, 60, 60, 70, 70, 80,\n              80, 90, 90, 100, 100, 110, 110, 120, 0, 0, 120, 120],\n             [0, 0, 53.3, 53.3, 0, 0, 53.3, 53.3, 0, 0, 53.3, 53.3, 0, 0, 53.3,\n              53.3, 0, 0, 53.3, 53.3, 0, 0, 53.3, 53.3, 53.3, 0, 0, 53.3],\n             color='grey')\n    if fifty_is_los:\n        plt.plot([60, 60], [0, 53.3], color='gold')\n        plt.text(62, 50, '<- Player Yardline at Snap', color='gold')\n    # Endzones\n    if endzones:\n        ez1 = patches.Rectangle((0, 0), 10, 53.3,\n                                linewidth=0.1,\n                                edgecolor='grey',\n                                facecolor='white',\n                                alpha=0.2,\n                                zorder=0)\n        ez2 = patches.Rectangle((110, 0), 120, 53.3,\n                                linewidth=0.1,\n                                edgecolor='grey',\n                                facecolor='white',\n                                alpha=0.2,\n                                zorder=0)\n        ax.add_patch(ez1)\n        ax.add_patch(ez2)\n    plt.xlim(0, 120)\n    plt.ylim(-5, 58.3)\n    plt.axis('off')\n    if linenumbers:\n        for x in range(20, 110, 10):\n            numb = x\n            if x > 50:\n                numb = 120 - x\n            plt.text(x, 5, str(numb - 10),\n                     horizontalalignment='center',\n                     fontsize=20,  # fontname='Arial',\n                     color='grey')\n            plt.text(x - 0.95, 53.3 - 5, str(numb - 10),\n                     horizontalalignment='center',\n                     fontsize=20,  # fontname='Arial',\n                     color='grey', rotation=180)\n    if endzones:\n        hash_range = range(11, 110)\n    else:\n        hash_range = range(1, 120)\n\n    for x in hash_range:\n        ax.plot([x, x], [0.4, 0.7], color='grey')\n        ax.plot([x, x], [53.0, 52.5], color='grey')\n        ax.plot([x, x], [22.91, 23.57], color='grey')\n        ax.plot([x, x], [29.73, 30.39], color='grey')\n\n    if highlight_line:\n        hl = highlight_line_number + 10\n        plt.plot([hl, hl], [0, 53.3], color='blue')\n        plt.text(hl + 2, 50, '<- {}'.format(highlighted_name),\n                 color='yellow')\n        \n    if highlight_first_down_line:\n        fl = hl + yards_to_go\n        plt.plot([fl, fl], [0, 53.3], color='yellow')\n    return fig, ax\n\n\n# Create animation of play\n\n\ndef calculate_dx_dy_arrow(x, y, angle, speed, multiplier):\n    if angle <= 90:\n        angle = angle\n        dx = np.sin(radians(angle)) * multiplier * speed\n        dy = np.cos(radians(angle)) * multiplier * speed\n        return dx, dy\n    if angle > 90 and angle <= 180:\n        angle = angle - 90\n        dx = np.sin(radians(angle)) * multiplier * speed\n        dy = -np.cos(radians(angle)) * multiplier * speed\n        return dx, dy\n    if angle > 180 and angle <= 270:\n        angle = angle - 180\n        dx = -(np.sin(radians(angle)) * multiplier * speed)\n        dy = -(np.cos(radians(angle)) * multiplier * speed)\n        return dx, dy\n    if angle > 270 and angle <= 360:\n        angle = 360 - angle\n        dx = -np.sin(radians(angle)) * multiplier * speed\n        dy = np.cos(radians(angle)) * multiplier * speed\n        return dx, dy\n    \ndef animate_player_movement(weekData, playData, playId, gameId):\n#     weekData = pd.read_csv(input_dir + 'week' + str(weekNumber) + '.csv')\n#     playData = pd.read_csv(input_dir + '\/plays.csv')\n    \n    playHome = weekData.query('gameId==' + str(gameId) + ' and playId==' + str(playId) + ' and team == \"home\"')\n    playAway = weekData.query('gameId==' + str(gameId) + ' and playId==' + str(playId) + ' and team == \"away\"')\n    playFootball = weekData.query('gameId==' + str(gameId) + ' and playId==' + str(playId) + ' and team == \"football\"')\n    \n    playHome['time'] = playHome['time'].apply(lambda x: dateutil.parser.parse(x).timestamp()).rank(method='dense')\n    playAway['time'] = playAway['time'].apply(lambda x: dateutil.parser.parse(x).timestamp()).rank(method='dense')\n    playFootball['time'] = playFootball['time'].apply(lambda x: dateutil.parser.parse(x).timestamp()).rank(method='dense')\n    \n    maxTime = int(playAway['time'].unique().max())\n    minTime = int(playAway['time'].unique().min())\n    \n    yardlineNumber = playData.query('gameId==' + str(gameId) + ' and playId==' + str(playId))['yardlineNumber'].item()\n    yardsToGo = playData.query('gameId==' + str(gameId) + ' and playId==' + str(playId))['yardsToGo'].item()\n    absoluteYardlineNumber = playData.query('gameId==' + str(gameId) + ' and playId==' + str(playId))['absoluteYardlineNumber'].item() - 10\n    playDir = playHome.sample(1)['playDirection'].item()\n    \n    if (absoluteYardlineNumber > 50):\n        yardlineNumber = 100 - yardlineNumber\n    if (absoluteYardlineNumber <= 50):\n        yardlineNumber = yardlineNumber\n        \n    if (playDir == 'left'):\n        yardsToGo = -yardsToGo\n    else:\n        yardsToGo = yardsToGo\n    \n    figsize=(12, 6.33)\n    fig, ax = plt.subplots(1, figsize=figsize)\n    playDesc = playData.query('gameId==' + str(gameId) + ' and playId==' + str(playId))['playDescription'].item()\n    plt.title(f'Game # {gameId} Play # {playId} \\n {playDesc}')\n    \n    def update_animation(time):\n        patch = []\n        create_football_field(fig,ax,highlight_line=True, highlight_line_number=yardlineNumber, highlight_first_down_line=True, yards_to_go=yardsToGo)\n\n        homeX = playHome.query('time == ' + str(time))['x']\n        homeY = playHome.query('time == ' + str(time))['y']\n        homeNum = playHome.query('time == ' + str(time))['jerseyNumber']\n        homeOrient = playHome.query('time == ' + str(time))['o']\n        homeDir = playHome.query('time == ' + str(time))['dir']\n        homeSpeed = playHome.query('time == ' + str(time))['s']\n        patch.extend(plt.plot(homeX, homeY, 'o',c='gold', ms=20, mec='white'))\n        \n        # Home players' jersey number \n        for x, y, num in zip(homeX, homeY, homeNum):\n            patch.append(plt.text(x, y, int(num), va='center', ha='center', color='black', size='medium'))\n            \n        # Home players' orientation\n        for x, y, orient in zip(homeX, homeY, homeOrient):\n            dx, dy = calculate_dx_dy_arrow(x, y, orient, 1, 1)\n            patch.append(plt.arrow(x, y, dx, dy, color='gold', width=0.5, shape='full'))\n            \n        # Home players' direction\n        for x, y, direction, speed in zip(homeX, homeY, homeDir, homeSpeed):\n            dx, dy = calculate_dx_dy_arrow(x, y, direction, speed, 1)\n            patch.append(plt.arrow(x, y, dx, dy, color='black', width=0.25, shape='full'))\n        \n        # Home players' location\n        awayX = playAway.query('time == ' + str(time))['x']\n        awayY = playAway.query('time == ' + str(time))['y']\n        awayNum = playAway.query('time == ' + str(time))['jerseyNumber']\n        awayOrient = playAway.query('time == ' + str(time))['o']\n        awayDir = playAway.query('time == ' + str(time))['dir']\n        awaySpeed = playAway.query('time == ' + str(time))['s']\n        patch.extend(plt.plot(awayX, awayY, 'o',c='orangered', ms=20, mec='white'))\n        \n        # Away players' jersey number \n        for x, y, num in zip(awayX, awayY, awayNum):\n            patch.append(plt.text(x, y, int(num), va='center', ha='center', color='white', size='medium'))\n            \n        # Away players' orientation\n        for x, y, orient in zip(awayX, awayY, awayOrient):\n            dx, dy = calculate_dx_dy_arrow(x, y, orient, 1, 1)\n            patch.append(plt.arrow(x, y, dx, dy, color='orangered', width=0.5, shape='full'))\n        \n        # Away players' direction\n        for x, y, direction, speed in zip(awayX, awayY, awayDir, awaySpeed):\n            dx, dy = calculate_dx_dy_arrow(x, y, direction, speed, 1)\n            patch.append(plt.arrow(x, y, dx, dy, color='black', width=0.25, shape='full'))\n        \n        # Away players' location\n        footballX = playFootball.query('time == ' + str(time))['x']\n        footballY = playFootball.query('time == ' + str(time))['y']\n        patch.extend(plt.plot(footballX, footballY, 'o', c='black', ms=10, mec='white', data=playFootball.query('time == ' + str(time))['team']))\n        \n        \n        return patch\n    \n    ims = [[]]\n    for time in np.arange(minTime, maxTime+1):\n        patch = update_animation(time)\n        ims.append(patch)\n        \n    anim = animation.ArtistAnimation(fig, ims, repeat=False)\n    \n    return anim","61194eb8":"# defining relevant data directories and file names for relevant data import\ndata_dir = Path('\/kaggle\/input\/nfl-big-data-bowl-2021')\nplays_fname = Path('plays.csv')\nplayers_fname = Path('players.csv')\ngames_fname = Path('games.csv')\n\n# reading the data into separate dataframes for processing and output\ngames_df= pd.read_csv(data_dir.joinpath(games_fname))\nplays_df = pd.read_csv(data_dir.joinpath(plays_fname))\nplayers_df = pd.read_csv(data_dir.joinpath(players_fname))\n\n# Because the data processing performed for this submission was ultimately exported to Stata for further statistical analysis, \n# we ultimately wanted to append the plays dataset with a number of new parameters developed for our \"attacking\" analysis. \n# In particular, \nplays_df['isSafetyAttack'] = [0] * np.size(plays_df.gameId)\nplays_df['attackingSafety1'] = [None] * np.size(plays_df.gameId)\nplays_df['attackingSafety2'] = [None] * np.size(plays_df.gameId)\nplays_df['attackingSafety3'] = [None] * np.size(plays_df.gameId)\nplays_df['attackingSafety4'] = [None] * np.size(plays_df.gameId)\nplays_df['attackingSafety5'] = [None] * np.size(plays_df.gameId)\nplays_df['safetyOnField1'] = [None] * np.size(plays_df.gameId)\nplays_df['safetyOnField2'] = [None] * np.size(plays_df.gameId)\nplays_df['safetyOnField3'] = [None] * np.size(plays_df.gameId)\nplays_df['safetyOnField4'] = [None] * np.size(plays_df.gameId)\nplays_df['safetyOnField5'] = [None] * np.size(plays_df.gameId)\nplays_df['defendingTeam'] = [None] * np.size(plays_df.gameId)\n\n# The data processor is generic to which defensive positions are classified as attacking on a given play. This particular analysis\n# is analyzing any safety on the field for a given play.\npositions = ['FS', 'SS']\n# The attack threshold metric filters the specified positions to classify an \"attacking\" action during a play. \n# The metric is defined as the percentage of frames between snap and throw (or any other event that could cause the defender \n# to stop attacking the line of scrimmage) in which the defender is moving towards the line of scrimmage. \n# For this particular analysis, we set the attack threshold to be 85% - thus, if a defender's x-position is moving towards the LOS for \n# more than 85% of the frames within the relevant window, he would be classified as \"attacking.\"\nattack_threshold = 0.85\nend_window_events = ['pass_forward', 'qb_sack', 'pass_shovel', 'qb_strip_sack', 'run']\n\n# Specify which weeks we want to analyze.\n# For our analysis, we wanted to consider the entire dataset, so we're looping over every play of every game in each week to populate our new columns\nweeks_to_analyze = [6, 15, 17] #range(1, 18)\n\nfor week in weeks_to_analyze:\n    week_fname = Path('week%i.csv' % week)\n    week_df = pd.read_csv(data_dir.joinpath(week_fname))\n    for game in np.unique(week_df.gameId):\n\n        team_plays = plays_df[plays_df.gameId == game]\n        team_plays_details = week_df[week_df.gameId == game]\n        unique_plays = np.unique(team_plays_details.playId)\n\n        for play_id in unique_plays:\n            plays_idx = np.intersect1d(np.where(plays_df.playId == play_id), np.where(plays_df.gameId == game))[0]\n            play = team_plays_details[team_plays_details.playId == play_id]\n            players = play.nflId.unique()\n            play_direction = play.playDirection.values[0]\n            \n            safeties = [player for player in players if players_df.position[(player == players_df.nflId)].values in positions]\n\n            plays_df.defendingTeam.iat[plays_idx] = np.setdiff1d(np.array([games_df[games_df.gameId == game]['homeTeamAbbr'].values[0], games_df[games_df.gameId == game]['visitorTeamAbbr'].values[0]]), np.array([plays_df.possessionTeam.values[plays_idx]]))[0]\n            if not safeties: # if there are no safeties on the field, then skip the play\n                continue\n            else:\n                for iSafety, player in enumerate(safeties):\n                    plays_df['safetyOnField%i' % (iSafety+1)].iat[plays_idx] = players_df.displayName[players_df.nflId == player].values[0]\n            \n            start_window = play.frameId.values[np.where(play.event == 'ball_snap')][0]\n            # get each play event, so that we can loop over them to determine which event triggers an end to our window\n            play_events = np.unique(play.event.values[play.event != 'None'])\n            try: # hacky try\/catch in case a play doesn't include an end window event defined above\n                end_window_event = [event for event in play_events if event in end_window_events][0]\n                end_window = play.frameId.values[np.where(play.event == end_window_event)][0]\n            except:\n                continue\n            # get each safety's trajectory during the window of interest\n            relevant_trajectories = [play.x.values[np.where(play.nflId == player)][start_window+1:end_window+1] for player in safeties]\n            # calculate our attack metric\n            if play_direction == 'left':\n                attack_criteria = np.array([sum(np.diff(traj) > 0) \/ (np.size(traj)) for traj in relevant_trajectories if np.size(traj)>0])\n            else:\n                attack_criteria = np.array([sum(np.diff(traj) < 0) \/ (np.size(traj)) for traj in relevant_trajectories if np.size(traj)>0])\n            # see if any safety's attack metric is above the specified threshold value and, if so, append to the dataframe\n            if any(attack_criteria >= attack_threshold):\n                plays_df['isSafetyAttack'].iat[plays_idx] = 1\n                iSafety = 1\n                for player, bc in zip(safeties, attack_criteria):\n                    if bc >= attack_threshold:\n                        plays_df['attackingSafety%i' % iSafety].iat[plays_idx] = players_df.displayName.values[np.where(players_df.nflId == player)][0]\n                        iSafety += 1","0c79eb35":"for play in [1, 2, 3]:\n    if play==1:\n        play_name = 'jamal_adams_sack'\n        week = 15\n        game_id = 2018121500\n        play_id = 3146\n    elif play==2:\n        play_name = 'mosley_int'\n        week = 17\n        game_id = 2018123000\n        play_id = 4376\n    elif play==3:\n        play_name = 'bengals_blitz'\n        week = 6\n        game_id = 2018101401\n        play_id = 4061\n\n    week_fname = Path('week%i.csv' % week)\n    week_df = pd.read_csv(data_dir.joinpath(week_fname))\n\n    # Animate our example play\n    anim = animate_player_movement(week_df, plays_df, play_id, game_id)\n    writer = FFMpegWriter(fps=10)\n    anim.save('%s.mp4' % play_name, writer=writer)\n    Video('%s.mp4' % play_name, embed=True)\n    plays_df[['possessionTeam', 'defendingTeam', 'isSafetyAttack','attackingSafety1','attackingSafety2','passResult', 'playResult', 'epa']].loc[np.where((plays_df.gameId == game_id) & (plays_df.playId == play_id))].head()\n","02dbc681":"**Which teams use their safeties to attack?** \nOf the 19,239 pass plays that occurred in 2018, a safety attacked the line of scrimmage on 17.73% of those downs.  ","f3b684fe":"In this notebook, we primarily utilized Sam Weinberg's Notebook (https:\/\/www.kaggle.com\/samweinberg\/field-control-visualization), wherein the relevant parts of our code drew from the following resources:\n\nRob Mulla's Notebook - \"Plotting Player Position\" (https:\/\/www.kaggle.com\/robikscube\/nfl-big-data-bowl-plotting-player-position)\nAndika Rachman's Notebook - \"Animating Player Movement\" (https:\/\/www.kaggle.com\/ar2017\/nfl-big-data-bowl-2021-animating-players-movement)\n","2d1f6595":"What's  most notable in the above graph is the wide swings we find across offensive opponents. Half the league is prepared to handle a safety attack and achieve a positive outcome, while the other half clearly is not - information we anticipate defensive coordinators would be pleased to get their hands on.  ","03a4dc84":"kdensity.jpg![image.png](attachment:image.png)","7069a8f6":"Team EPA Offense Attack.jpg![image.png](attachment:image.png)","2acdf0be":"team high leverage.jpg![image.png](attachment:image.png)","2a770ad7":"![](https:\/\/thumbs.gfycat.com\/BlushingEuphoricAiredale-max-1mb.gif)","2d3e9087":"**Conclusion**\n\nWe have demonstrated the developement and usefullnes of quantifying and evaluating the \"safety attack\" as a tool to defend against the pass. In addition to evaluating the Jamal Adams trade, we belive this measure will be useful in situational football defensive play calling, evaluating opponents and individual players, and projecting success of an indiviual player given their style of play and pairing that style with defensive play caller tendencies. ","9c3199c5":"The distribution of safety attack rate across a variety of high leverage situations is instructive in assessing how teams value an attacking safety and the expected risk vs. reward in a given situation. The Rams (\"LA\"), for example, are less than 10% likely to allow their safeties to attack in the 4th quarter of a one score game, clearly an attempt to mitigate the risk of getting beat over the top. The Ravens (\"BAL\"), on the other hand, are allowing their safeties to attack on nearly 40% of downs in similar situation, clearly attempting to force the action and create big plays. That same Rams team, however, attacks with their safeties at the third highest rate in the league when defending in the red zone! Given the constrained field of play in the red zone, it appears the Rams are less concerned about getting beat over the top and are willing to let their safeties force the action. ","fe6c99f6":"adams v bal.jpg![image.png](attachment:image.png)","9043cbd3":"Both Adams and the Ravens have a similar distribution of EPA, clustering somewhat below the league mean of 0.02. Comparing Adams playing coverage to Adams attacking, the distributions tell us that, on average, not much difference can be found on the majority of plays. Notable, however, are the tails of the distribution in which the Adams attach exposes the Jets to giving up greater plays (greater density in larger EPA segments) while also increasing the chances for a \"momentum\" play, (greater density in larger negative EPA segments). \n\nThe Ravens distribution shows that the team has mitigated much of the perceived risk in how using safeties to attack. When attacking, the Ravens defense does not allow a play with an EPA greater than 3.8, while averaging an EPA of -0.17 and achieving a maximum score of -9.48. This indicates to us that the Ravens' strategic utilization of the safety attack, both in personnel and game situation, has allowed them to capitalize on the benefits while mitigating the risk. ","332bef34":"**Employing the Safety Attack**\n\nThis then begs the question: against which teams are safety attacks most successful? The answer didn't particularly surprise us, as many of the most successful 2018 teams performed well against the safety attack, while many of the least successful teams did not. ","a7d3f0ea":"![](https:\/\/i2.wp.com\/media.giphy.com\/media\/d7MmfauxGRclIXgMF2\/giphy.gif?resize=353%2C161&ssl=1)","b563361f":"Above we demonstrate the effect safeties have on completion percentage in a high leverage situation (4th quarter of a one score game), showing both Jamal Adams himself and the Ravens defence overall. When Adams attacks, mean completion percentage increases. Assigning logic to this relationship, we can say that the reason for this is that QBs are getting the ball out faster. The graph below shows that this isn't necessarily a bad thing, as we find elsewhere that both epa and yards per completion decrease when a pass is completed during a safety attack. \n\nLooking at the Ravens, we find that the attacking safety decreases the likelihood of a completed pass in high levarage situations. ","e2977e09":"Team DGA: \nClark Demasi -clark@demasi-group.com\nCory Kays - corykays@gmail.com ","75ac883f":"Below we animate a handful of notable plays that we have tagged as downs in which a safety attacks, showing the high end and low end of potential outcomes.  ","0625a536":"Team Attack Rate.jpg![image.png](attachment:image.png)","1a4438de":"![](https:\/\/cdn.vox-cdn.com\/uploads\/chorus_asset\/file\/13658403\/Mosley.gif)","6b8a6d2f":"**Evaluation of Effectiveness**\n\nGiven that Jamal Adams is our entry into the project, we use Adams as a proxy for evaluating individual safety effctiveness on the attack. In 2018, Adams attacked most the any other safety in the league, 122 times in 632 downs (19.3%), while accounting for 85% of the Jets' total safety attacks. To explore the effectiveness of safety attacks from a team perspective, we find the Baltimore Ravens to be most instructive. Not only were the Ravens one of the top 2 defenses in the league in 2018, but we found that the employ the safety attack using individual safeties interchangably (Weddle: 64 Attacks, Jefferson: 70 Attacks, Clark: 22 Attacks). ","987f1d7e":"**Effectiveness of Safety Attacks on Completions & EPA**","b4741530":"**Introduction**\n\nIt seems for the past 5 months, the Mina Kimes Podcast (ft. Lenny), GMFB, or NFL Live have had something to say about who won the the \u201cJamal Adams Trade.\u201d The argument over Adams\u2019 worth is reenergized each week when one of two things typically happens on a Sunday: \n(a) Jamal Adams has an interception, 2 forced fumbles, and a sack on a 3rd and long that swings the outcome of the game; or \n(b) Adams was beat in coverage by Tyler Higbee or some other TE with half his athleticism at a crucial time because Adams was guessing run, abandoned his zone, got caught looking in the backfield, etc. \n\nThe frequency of the Adams debate is an instructive entry in to the purpose of this project: the quantification and evaluation of the attacking safety. Within this project we will describe how we identify an attacking safety, which teams use their safeties to attack most frequently, which individual safeties attack most frequently, and which offenses receives the most attacks from opposition safeties. Furthermore, we will use outcome variables such as EPA, incompletions, and \"big plays\"  to determine the efficacy of attacking safeties.\n\n\nOut ultimate goal is to then able to weigh the cost vs. benefit of a player like Adams. Is he worth the draft capital the Seahawks gave up for him? Or is his play style so detrimental that no amount of \u201cbig moment\u201d plays can make up for the times he exposes his defense because he\u2019s just \u201cfollowing his gut out there.\u201d \n\nIdentifying an Attacking Safety\n\nWe differentiate between a safety \u201cattack\u201d and a safety \u201cblitz\u201d for a number of reasons. While we absolutely want to incorporate safety blitzes into our analysis of pass defense, safety blitzes drawn up by the defensive coordinator make up just a portion of what make attacking safeties worth exploring. In identifying when a safety \u201cattacks,\u201d we attempt to account forthe following:\n\t(i) A called safety blitz\n\t(ii) An uncalled safety blitz\n\t(iii) A safety following his instincts and attacking the line of scrimmage at the snap\n\t(iv) A safety misreading the play (biting on play-action) and continuing his run toward the line of scrimmage. \n    \nBelow we detail our methodology on generating the \"Attacking Safety\" Metric    "}}