{"cell_type":{"4ed70644":"code","af725860":"code","344e07c6":"code","7eb20a48":"code","c612e3c4":"code","6aff9c06":"markdown","f895b4ea":"markdown","84965792":"markdown","db8ee33a":"markdown","586c857d":"markdown","7eb12b02":"markdown"},"source":{"4ed70644":"import pandas as pd\nimport numpy as np\nimport math\nimport random\n\nSub_mas = []\n\nprint('Extracting data')\n\nwith open('..\/input\/hashcode-drone-delivery\/busy_day.in') as file:\n    line_list = file.read().splitlines()\n\nROWS, COLS, DRONES_num, TURNS, MAXLOAD = map(int, line_list[0].split())\nSCORE = 0\n# \u0432\u0435\u0441\u0430 \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u043e\u0432 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0442\u0438\u043f\u0430 (\u0434\u0435\u043b\u0430\u0435\u0442 \u0442\u0430\u0431\u043b\u0438\u0446\u0443)\nweights = line_list[2].split()\nproducts_df = pd.DataFrame({'weight': weights})\n# \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u0438\u0437 \u0442\u0430\u0431\u043b\u0438\u0446\u044b\n# a = int(products_df.iloc[3])\n# print(a)\n\n# \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u043a\u043b\u0430\u0434\u043e\u0432\nwh_count = int(line_list[3])\nwh_endline = (wh_count * 2) + 4\n\n# \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0442\u043e\u0432\u0430\u0440\u043e\u0432 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0442\u0438\u043f\u0430 \u043d\u0430 \u0441\u043a\u043b\u0430\u0434\u0435\nwh_invs = line_list[5:wh_endline + 1:2]\nfor i, wh_inv in enumerate(wh_invs):\n    products_df[f'wh{i}_inv'] = wh_inv.split()\n\n# products_df has shape [400,11]\n# (# of products, [weight, wh0_inv, wh1_inv,...])\nproducts_df = products_df.astype(int)\n\n# \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0441\u043a\u043b\u0430\u0434\u043e\u0432\nwh_locs = line_list[4:wh_endline:2]\nwh_rows = [wl.split()[0] for wl in wh_locs]\nwh_cols = [wl.split()[1] for wl in wh_locs]\n\nwarehouse_df = pd.DataFrame(\n    {'wh_row': wh_rows, 'wh_col': wh_cols}).astype(np.uint16)\n\norder_locs = line_list[wh_endline + 1::3]\no_rows = [ol.split()[0] for ol in order_locs]\no_cols = [ol.split()[1] for ol in order_locs]\n\norders_df = pd.DataFrame({'row': o_rows, 'col': o_cols})\n\norders_df[orders_df.duplicated(keep=False)].sort_values('row')\n\norders_df['product_count'] = line_list[wh_endline + 2::3]\n\norder_array = np.zeros((len(orders_df), len(products_df)), dtype=np.uint16)\norders = line_list[wh_endline + 3::3]\n\nfor i, order in enumerate(orders):\n    products = [int(prod) for prod in order.split()]\n    for p in products:\n        order_array[i, p] += 1\n\ndf = pd.DataFrame(data=order_array,\n                  columns=['p_' + str(i) for i in range(400)],\n                  index=orders_df.index)\n\n# \u0442\u0430\u0431\u043b\u0438\u0446\u0430 \u0441 \u043d\u043e\u043c\u0435\u0440\u0430\u043c\u0438 \u0437\u0430\u043a\u0430\u0437\u043e\u0432\norders_df = orders_df.astype(int).join(df)\nprint('... success')","af725860":"def distance(point1, point2):\n    return np.sqrt((point1[0] - int(point2[0])) ** 2 + (point1[1] - int(point2[1])) ** 2)\n\n\nclass Order(object):\n    def __init__(self, row, colom, number):\n        self.number = number\n        self.point = [row, colom]\n        self.products = []\n        self.haveabind = False\n        self.warehouse = []\n        pass\n    def setProduct(self, products):\n        a = [int(x) for x in products.split()]\n        self.products = a\n        pass\n    # \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u0435\u0442 \u0437\u0430\u043a\u0430\u0437\u0443 \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0438\u0439 \u0441\u043a\u043b\u0430\u0434\n    def setWarehouse(self, locs_wh):\n        dist = [distance(self.point, [wl.split()[0], wl.split()[1]]) for wl in locs_wh]\n        self.warehouse = np.argmin(dist)\n        pass\n    #\u0440\u0430\u0434\u0438\u0430\u043b\u044c\u043d\u0430\u044f \u0432\u0435\u0441\u0440\u0438\u044f - \u043d\u0435 \u0432\u0441\u0435 \u043f\u043e\u043b\u0435, \u0430 \u043b\u0438\u0448\u044c \u0447\u0430\u0441\u0442\u044c \u043e\u043a\u0440\u0443\u0436\u043d\u043e\u0441\u0442\u044c\u044e\n    def setWarehouse_radial(self, wh_massive):\n        self.warehouse = []\n        for wh in range(len(wh_massive)):\n            rast = distance(self.point, [wh_massive[wh].point[0], wh_massive[wh].point[1]])\n            if not wh_massive[wh].extornot:\n                if rast - wh_massive[wh].radius <= 0:\n                    self.haveabind = True\n                    self.warehouse.append(wh)\n            else:\n                if rast - wh_massive[wh].ext_radius >= 0:\n                    self.haveabind = True\n                    self.warehouse.append(wh)\n        #if len(self.warehouse) > 1:\n            #print(self.warehouse, \"kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk\")\n        pass\n    def setWarehouse_radial_one(self, wh_one):\n            #self.warehouse = []\n            self.haveabind = False\n            # ist = False\n            # for i in self.warehouse:\n            #     if i == wh_one:\n            #         ist = True\n            #if ist:\n            rast = distance(self.point, wh_mass[wh_one].point)\n            if not wh_mass[wh_one].extornot:\n                if (rast - wh_mass[wh_one].radius <= 0 and rast - wh_mass[wh_one].old_radius >= 0):\n                    self.haveabind = True\n            else:\n                if ( rast >= wh_mass[wh_one].ext_radius ):\n                    self.haveabind = True\n            return self.haveabind\n\nclass Warehouse(object):\n    def __init__(self, row, colom, HAHA):\n        self.point = [row, colom]\n        self.orders = []\n        self.products = []\n        self.W = [[]]\n        self.radius = 50\n        self.old_radius = -1\n        self.initedprod = False\n        self.extornot = HAHA\n        if self.extornot:\n            self.ext_radius = 450\n        pass\n    #\u043f\u0440\u043e\u043a\u0430\u0447\u0435\u043d\u043d\u0430\u044f \u0432\u0435\u0440\u0441\u0438\u044f\n    def setOrder(self, order):\n        temp = [0 for i in range(len(self.products))]\n        if  self.initedprod:\n            for i in range(len(self.products)):\n                temp[i] = self.products[i] + self.not_requirement[i]\n        can = False\n        for i in order.products:\n            for j in range(len(temp)):\n                if i == j and temp[j] > 0:\n                    can = True\n        if can:\n            self.orders.append(order)\n        pass\n    def setProducts(self, products_num):\n        self.products = [int(k) for k in products_num]\n        pass\n    # \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u0435\u0442 \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u044b \u043d\u0430 \u0442\u0435 \u0447\u0442\u043e \u043f\u0435\u0440\u0435\u0432\u0435\u0437\u0442\u0438 \u043d\u0430 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u043a\u043b\u0430\u0434\u044b \u0442\u0435 \u0447\u0442\u043e \u043e\u0441\u0442\u0430\u043d\u0443\u0442\u0441\u044f \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0430\u0432\u043a\u0438\n    def determProducts(self):\n        if  self.initedprod:\n            for i in range(len(self.products)):\n                self.products[i] = self.products[i] + self.not_requirement[i]\n        \n        self.requirement = [0 for _ in range(len(self.products))]\n        for i in self.orders:\n            for j in i.products:\n                self.requirement[j] += 1\n        self.div = [int(self.products[k]) - self.requirement[k] for k in range(len(self.products))]\n        self.not_requirement = [0 for _ in range(len(self.products))]\n        for i in range(len(self.div)):\n            if (self.div[i] >= 0):\n                self.requirement[i] = 0\n                self.not_requirement[i] = self.div[i]\n                self.products[i] -= self.not_requirement[i]\n            else:\n                self.requirement[i] = abs(self.div[i])\n                #self.products[i] = 0\n        self.initedprod = True\n        pass\n    def show_state(self, it = -1):\n        sum_p = 0\n        for i in self.products:\n            sum_p += i\n        sum_r = 0\n        for i in self.requirement:\n            sum_r += i\n        sum_nr = 0\n        for i in self.not_requirement:\n            sum_nr += i\n        print(\"\\t\", it, \") \u0435\u0441\u0442\u044c \", sum_p, \"; \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \", sum_r, \"; \u043d\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \", sum_nr)\n    def products_num(self):\n        sum_p = 0\n        for i in self.products:\n            sum_p += i\n        return sum_p\n    def requirement_num(self):\n        sum_r = 0\n        for i in self.requirement:\n            sum_r += i\n        return sum_r\n    #\u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439 \u043f\u043e \u0437\u0430\u043a\u0430\u0437\u0430\u043c\n    def createW(self):\n        self.w = []\n        self.W = [[0 for _ in range(len(self.orders))] for _ in range(len(self.orders))]\n        for i in range(len(self.orders)):\n            for j in range(len(self.orders)):\n                if i == j:\n                    self.W[i][j] = -1\n                    continue\n                self.W[i][j] = math.ceil(distance(self.orders[i].point, self.orders[j].point))\n        pass","344e07c6":"doneOrdersyyy = 0\nclass Drone(object):\n    def __init__(self, point, isdeliver, number, wh=None):\n        self.number = number\n        self.point = point\n        self.turns = TURNS\n        self.isdeliver = isdeliver\n        if isdeliver == True:\n            self.wh = wh\n        pass\n        self.bobo = 0\n        self.momo = 0\n    def delive_cicle(self):\n        self.wh_mass[self.wh_numb].determProducts()\n        if not self.wh_mass[self.wh_numb].extornot:\n            if self.wh_mass[self.wh_numb].radius > 550:\n                maxi = 0\n                for i in range(len(self.wh_mass)):\n                    if self.wh_mass[i].products_num() > self.wh_mass[maxi].products_num():\n                        maxi = i\n                self.turns -= math.ceil(distance(self.wh_mass[self.wh_numb].point, self.wh_mass[maxi].point))\n                #print(\"\u0414\u0440\u043e\u043d \", self.number, \" \u0441\u043c\u0435\u043d\u0438\u043b \u0441\u043a\u043b\u0430\u0434 \", self.wh_numb, \" \u043d\u0430 \u0441\u043a\u043b\u0430\u0434 \", maxi)\n                self.wh_numb = maxi\n                if self.wh_mass[self.wh_numb].products_num() == 0 and self.wh_mass[self.wh_numb].requirement_num() == 0:\n                    return\n        else: \n            if self.wh_mass[self.wh_numb].ext_radius < -50:\n                maxi = 0\n                for i in range(len(self.wh_mass)):\n                    if self.wh_mass[i].products_num() > self.wh_mass[maxi].products_num():\n                        maxi = i\n                self.turns -= math.ceil(distance(self.wh_mass[self.wh_numb].point, self.wh_mass[maxi].point))\n                #print(\"\u0414\u0440\u043e\u043d \", self.number, \" \u0441\u043c\u0435\u043d\u0438\u043b \u0441\u043a\u043b\u0430\u0434 \", self.wh_numb, \" \u043d\u0430 \u0441\u043a\u043b\u0430\u0434 \", maxi)\n                self.wh_numb = maxi\n                if self.wh_mass[self.wh_numb].products_num() == 0 and self.wh_mass[self.wh_numb].requirement_num() == 0:\n                    return\n        if self.wh_mass[self.wh_numb].products_num() == 0:\n            if self.wh_mass[self.wh_numb].extornot:\n                self.wh_mass[self.wh_numb].ext_radius -= 100\n                #self.wh_mass[self.wh_numb].radius = 999\n                print(self.wh_mass[self.wh_numb].ext_radius)\n            else:\n                wh_mass[self.wh_numb].old_radius = self.wh_mass[self.wh_numb].radius\n                self.wh_mass[self.wh_numb].radius += 100\n            self.wh_mass[self.wh_numb].orders = []\n            for i in orders_mass:\n                #self.wh_mass[self.wh_numb].orders.append(i)\n                self.wh_mass[self.wh_numb].setOrder(i)\n            self.turns -= 1\n            self.wh_mass[self.wh_numb].determProducts()\n            print(\"\u041d\u0430\u0447\u0438\u043d\u0430\u044e \u0434\u0435\u043b\u0430\u0442\u044c \u043c\u0430\u0442\u0440\u0438\u0446\u0443\")\n            self.wh_mass[self.wh_numb].createW()\n            print(\"\u0417\u0430\u043a\u043e\u043d\u0447\u0438\u043b \u0434\u0435\u043b\u0430\u0442\u044c \u043c\u0430\u0442\u0440\u0438\u0446\u0443\")\n            return\n        self.wh_mass[self.wh_numb].determProducts()\n        \n        #\u0437\u0430\u043f\u0443\u0441\u043a \u0433\u0435\u043d\u0435\u0442\u0438\u043a\u0438\n        way = self.genetic_solve(2000)\n\n        if len(way) <= 4:\n            self.momo += 1\n        else: self.bobo += 1\n        self.turns -= self.f_way(way)\n        bag = 0\n        temp_sub_mas = []\n        products_temp_global = []\n        for i in way:\n            products_temp = []\n            for o_i in range(len(self.wh_mass[self.wh_numb].orders[i].products)):\n                if MAXLOAD <= bag:\n                    if MAXLOAD < bag: print(\"\u043e\u0448\u0438\u0431\u043a\u0430, \u043f\u0435\u0440\u0435\u0432\u0435\u0441\")\n                    break\n                o = self.wh_mass[self.wh_numb].orders[i].products[o_i]\n                if self.wh_mass[self.wh_numb].products[o] != 0 and MAXLOAD >= bag + weights_int[o]:\n                    da = True\n                    for om in products_temp:\n                        if (om == o):\n                            da = False\n                    net = True\n                    for om in products_temp_global:\n                        if (om == o):\n                            net = False\n                    products_temp.append(o)\n                    products_temp_global.append(o)\n                    self.wh_mass[self.wh_numb].products[o] -= 1  # \u0437\u0430\u0431\u0440\u0430\u043b\u0438\n                    self.wh_mass[self.wh_numb].orders[i].products[o_i] = -1  # \u043c\u0433\u043d\u043e\u0432\u0435\u043d\u043d\u043e \u0434\u043e\u0441\u0442\u0430\u0432\u0438\u043b\u0438 :)\n                    for asdf in wh_mass:\n                        asdf.determProducts()\n                    if da:\n                        if net:\n                            self.turns -= 2  # \u0431\u0443\u0434\u0435\u043c \u043f\u043e 1 \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u0443 \u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u0438 \u0431\u0440\u0430\u0442\u044c\n                        else:\n                            self.turns -= 1\n                    bag += weights_int[o]\n                    Sub_mas.append(str(self.number) + \" \" + 'L' + \" \" + str(self.wh_numb) + \" \" + str(o) + \" \" + str(1))\n                    temp_sub_mas.append(str(self.number) + \" \" + 'D' + \" \" + str(\n                        self.wh_mass[self.wh_numb].orders[i].number) + \" \" + str(o) + \" \" + str(1))\n            for o_i in range(len(self.wh_mass[self.wh_numb].orders[i].products) - 1, -1, -1):\n                if self.wh_mass[self.wh_numb].orders[i].products[o_i] == -1:\n                    #print(self.wh_mass[self.wh_numb].orders[i])\n                    self.wh_mass[self.wh_numb].orders[i].products.pop(o_i)\n                    #print(len(self.wh_mass[0].orders))\n                    if len(self.wh_mass[self.wh_numb].orders[i].products) == 0:\n                        global SCORE, doneOrdersyyy\n                        doneOrdersyyy += 1\n                        SCORE += math.ceil((self.turns) \/ TURNS * 100)\n        Sub_mas.extend(temp_sub_mas)\n        if Sub_mas[-1] == ['']: print(\"\u043f\u0443\u0441\u0442\u0430\u044f \u0441\u0442\u043e\u0440\u043e\u043a\u0430\")\n        pass\n    def deliver__init__(self, wh_mass, start_wh):\n        self.wh_mass = wh_mass\n        self.wh_numb = start_wh\n        pass\n    def delive(self, order_num, products):\n        order_coords = orders_mass[order_num].point\n        self.__goto__(order_coords)\n\n        for prod_num in products:\n            if self.__nessesary_delive_this_prod__(prod_num, order_num):\n                # self.orders_mass[prod_num] -= 1\n                self.bag.append(prod_num)\n            else:\n                print(\"\u0414\u043e\u0441\u0442\u0430\u0432\u044f\u043b\u0435\u0448\u044c \u0442\u043e, \u0447\u0442\u043e \u043d\u0435 \u043d\u0430\u0434\u043e \u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c!\")\n        pass\n    def load(self, wh_num, products_to_load):\n        wh_coords = wh_mass[wh_num].point\n        self.__goto__(wh_coords)\n\n        for prod_num in products_to_load:\n            count = wh_mass[wh_num].not_requirement[prod_num]\n            if count <= 0:\n                print(\"\u0411\u0435\u0440\u0435\u0448\u044c \u043d\u0435\u0431\u0435\u0440\u0443\u0449\u0435\u0435\u0441\u044f!\")\n            else:\n                if self.__can_add_to_bag__(prod_num):\n                    wh_mass[wh_num].not_requirement[prod_num] -= 1\n                    self.bag.append(prod_num)\n        pass  \n    def wait(self, wait_turns):\n        self.turns -= wait_turns\n        Sub_mas.append(str(self.number) + \" \" + 'W' + \" \" + str(wait_turns))\n        pass  \n    def __goto__(self, point):\n        dist = math.ceil(distance(self.point, point))\n        self.turns -= dist\n        # \u043f\u0440\u043e\u0432\u0435\u0440\u043e\u0447\u043a\u0430 \u0431\u0443\u0438\u0442\u044c \u043d\u0430 \u043e\u0441\u0442\u0430\u0432\u0448\u0435\u0435\u0441\u044f \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0445\u043e\u0434\u043e\u0432\n        self.point = point\n        pass\n    def __can_add_to_bag__(self, oneprod):\n        if int(weights[oneprod]) + self.nowload <= MAXLOAD:\n            return 1\n        else:\n            return 0\n    def __can_pop_from_bag__(self, oneprod):\n        for i in self.bag:\n            if i == oneprod:\n                return i\n        return -1\n    def __nessesary_delive_this_prod__(self, oneprod, order_num):\n        for i in orders_mass[order_num]:\n            if i == oneprod:\n                return 1\n        return 0\n    \n    def checkfororders(self):\n        pass\n\n    # \u0447\u0430\u0441\u0442\u044c \u0441 \u0433\u0435\u043d\u0435\u0442\u0438\u043a\u043e\u0439\n    def f_way(self, x):\n        sum = 0\n        m = len(x)\n        # print(m)\n        sum += math.ceil(distance(self.wh_mass[self.wh_numb].point, self.wh_mass[self.wh_numb].orders[x[0]].point))\n        for i in range(m - 1):\n            sum += self.wh_mass[self.wh_numb].W[x[i]][x[i + 1]]\n        sum += math.ceil(distance(self.wh_mass[self.wh_numb].point, self.wh_mass[self.wh_numb].orders[x[m - 1]].point))\n        return sum\n    def f(self, x):\n        count = 0\n        bag = 0\n        wh_products = self.wh_mass[self.wh_numb].products.copy()\n        for i in x:\n            products_temp = self.wh_mass[self.wh_numb].orders[i].products.copy()\n            for o_i in range(len(products_temp)):\n                if MAXLOAD <= bag:\n                    if MAXLOAD < bag: print(\"\u043e\u0448\u0438\u0431\u043a\u0430, \u043f\u0435\u0440\u0435\u0432\u0435\u0441\")\n                    break\n                o = products_temp[o_i]\n                if wh_products[o] != 0 and MAXLOAD >= bag + weights_int[o]:\n                    wh_products[o] -= 1  # \u0437\u0430\u0431\u0440\u0430\u043b\u0438\n                    products_temp[o_i] = -1  # \u043c\u0433\u043d\u043e\u0432\u0435\u043d\u043d\u043e \u0434\u043e\u0441\u0442\u0430\u0432\u0438\u043b\u0438 :)\n                    bag += weights_int[o]\n            for o_i in range(len(products_temp) - 1, -1, -1):\n                if products_temp[o_i] == -1:\n                    products_temp.pop(o_i)\n                    if len(products_temp) == 0:\n                        count += 1\n\n        sum = 0\n        m = len(x)\n        # print(m)\n        sum += math.ceil(distance(self.wh_mass[self.wh_numb].point, self.wh_mass[self.wh_numb].orders[x[0]].point))\n        for i in range(m - 1):\n            sum += self.wh_mass[self.wh_numb].W[x[i]][x[i + 1]]\n        sum += math.ceil(distance(self.wh_mass[self.wh_numb].point, self.wh_mass[self.wh_numb].orders[x[m - 1]].point))\n        if count != 0:\n            return sum \/ (2**count + 1)\n        return sum\n    def mutation(self, x):\n        m = len(x)\n        k = random.randint(0, m - 2)\n        x[k], x[k + 1] = x[k + 1], x[k]\n    def crossing(self, pop, prob=20):\n        n = int(len(pop) \/ 2)\n        for i in range(n):\n            pop[n + i] = pop[i].copy()\n            m = len(pop[i])\n            if (m <= 1):\n                continue\n            r = random.randint(0, m - 1)\n            l = random.randint(0, m - 1)\n            # if m != 1:\n            while r == l:\n                l = random.randint(0, m - 1)\n            if l < r:\n                l, r = r, l\n            for j in range(math.ceil((l - r) \/ 2)):\n                pop[i + n][r + j], pop[i + n][l - j] = pop[i + n][l - j], pop[i + n][r + j]\n            if (1 + random.randint(0, 99) <= prob):\n                self.mutation(pop[i + n])\n    def qsort(self, pop):\n        listik = []\n        for i in range(len(pop)):\n            listik.append((self.f(pop[i]), i))\n        listik.sort(key=lambda x: x[0])\n        newpop = []\n        for i in range(len(pop)):\n            newpop.append(pop[listik[i][1]].copy())\n        for i in range(len(pop)):\n            pop[i] = newpop[i].copy()\n        pass\n    def randPopulation_delive(self, pop):\n        n = len(pop)\n        m = len(self.wh_mass[self.wh_numb].orders)\n\n        for i in range(n):\n            temp_prod = self.wh_mass[self.wh_numb].products.copy()\n            bag = 0\n            pop[i] = []\n            for _ in range(m):\n                opop = m\n                #print(len(self.wh_mass[self.wh_numb].orders))\n                while (True):\n                    opop -= 1\n                    new_o = random.randint(0, len(self.wh_mass[self.wh_numb].orders) - 1)\n                    #print(new_o)\n                    myb = True\n                    for p in pop[i]:\n                        if new_o == p:\n                            myb = False\n                    if myb:\n                        break\n                    deb = []\n                    for h in range(len(temp_prod)):\n                        if temp_prod[h] == 0:\n                            deb.append(0)\n                        else: deb.append(h)             \n                temp_attantion = False\n                for o in self.wh_mass[self.wh_numb].orders[new_o].products:\n                    if MAXLOAD <= bag:\n                        break\n                    if temp_prod[o] != 0 and MAXLOAD >= bag + weights_int[o]:\n                        temp_prod[o] -= 1\n                        bag += weights_int[o]\n                        temp_attantion = True\n                        # \u0440\u0430\u0441\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0438\u0442\u044c\/\u0437\u0430\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0438\u0442\u044c break, \u0435\u0441\u043b\u0438 \u043c\u044b \u0445\u043e\u0442\u0438\u043c \u0431\u0440\u0430\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u043e \u043e\u0434\u043d\u043e\u043c\u0443\/\u043c\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u0443\n                        # break\n                if temp_attantion:\n                    pop[i].append(new_o)\n            # \u043e\u043f\u0430\u0441\u043d\u0430\u044f \u0448\u0442\u0443\u043a\u0430. \u043d\u0443\u043b\u0435\u0432\u044b\u0435 \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u0441\u044f \u0435\u0441\u043b\u0438 \u043d\u0435 \u0443\u0441\u043f\u0435\u043b \u043d\u0430\u0440\u0430\u043d\u0434\u043e\u043c\u0438\u0442\u044c, \u043a\u043e\u0433\u0434\u0430 \u043c\u0430\u043b\u043e. \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u043d\u0430\u0441\u0438\u043b\u044c\u043d\u043e\n            if len(pop[i]) == 0:\n                for ord in range(len(self.wh_mass[self.wh_numb].orders)):\n                    for pr in self.wh_mass[self.wh_numb].orders[ord].products:\n                        if self.wh_mass[self.wh_numb].products[pr] != 0:\n                            pop[i].append(ord)\n                            break\n        for i in range(len(pop) - 1, -1, -1):\n            if len(pop[i]) == 0:\n                pop.pop(i)\n        if len(pop) == 0:\n            sum = 0\n            for it in self.wh_mass[self.wh_numb].products:\n                sum += it\n            print(\"\u043e\u0441\u0442\u0430\u043b\u043e\u0441\u044c \", sum, \" \", self.wh_numb)\n        pass \n    def genetic_solve(self, max_osob):\n        N = max_osob  # \u0447\u0438\u0441\u043b\u043e \u043e\u0441\u043e\u0431\u0435\u0439 \u0432 \u043f\u043e\u043f\u0443\u043b\u044f\u0446\u0438\u0438\n        M = 50  # \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0433\u043e\u0440\u043e\u0434\u043e\u0432\n        prob = 99  # \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c \u043c\u0443\u0442\u0430\u0446\u0438\u0438\n        if N % 2 != 0:\n            print(\"think again\")\n        pop = [[0 for _ in range(M)] for _ in range(N)]\n        T = 5  # \u0447\u0438\u0441\u043b\u043e \u043f\u043e\u043a\u043e\u043b\u0435\u043d\u0438\u0439\n        self.randPopulation_delive(pop)\n\n        for t in range(T):\n            self.qsort(pop)\n            self.crossing(pop, prob)\n\n        return pop[0]","7eb20a48":"# \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0417\u0430\u043a\u0430\u0437\u044b \u043f\u0440\u0435\u0434\u0430\u0432\u0430\u044f \u0438\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b\norders_mass = [Order(int(order_locs[ol].split()[0]), int(order_locs[ol].split()[1]), ol) for ol in range(len(order_locs))]\n\n# \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0432 \u0417\u0430\u043a\u0430\u0437\u044b \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u044b\nfor i in range(len(orders_mass)):\n    orders_mass[i].setProduct(orders[i])\n# \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0421\u043a\u043b\u0430\u0434\u044b \u043f\u0440\u0435\u0434\u0430\u0432\u0430\u044f \u0438\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b\nwh_mass = [Warehouse(int(wh_locs[wl].split()[0]), int(wh_locs[wl].split()[1]), 0) for wl in range(len(wh_locs))]\n# \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0432 \u0421\u043a\u043b\u0430\u0434\u044b \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u044b\nfor i in range(len(wh_mass)):\n    wh_mass[i].setProducts(wh_invs[i].split())\n\n\n\nfor i in orders_mass:\n    i.setWarehouse_radial(wh_mass)\n    if len(i.warehouse) != 0:\n        for tete in i.warehouse:\n            #wh_mass[tete].setOrder(i)\n            wh_mass[tete].orders.append(i)\n\n# \u043d\u0430 \u043a\u0430\u0436\u0434\u043e\u043c \u0441\u043a\u043b\u0430\u0434\u0435 \u0440\u0430\u0437\u0431\u0438\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0434\u0443\u043a\u044b\u0442\u044b \u043d\u0430 3 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438 \u0438 \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u043c\u0430\u0442\u0440\u0438\u0446\u0443 \u0432\u0435\u0441\u043e\u0432\nfor i in wh_mass:\n    i.determProducts()\n    i.createW()\n\n\n\nweights_int = [int(w) for w in weights]\n\n\nraspeadDR = [4,1,2,4,5,2,5,2,1,4]\nif len(raspeadDR) != len(wh_mass): print(\"\u041e\u0448\u0438\u0431\u043a\u0430, \u0431\u043b\u0438\u043d\")\nsummir = 0\nfor i in raspeadDR:\n    summir += i\nif summir != DRONES_num: print(\"\u041e\u0448\u0438\u0431\u043a\u0430, \u0431\u043b\u0438\u043d \", summir - DRONES_num)\n\n# \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0434\u0440\u043e\u043d\u043e\u0432 2\u0445 \u0442\u0438\u043f\u043e\u0432\nDRONES_delivers_count = DRONES_num\n# \u0434\u0440\u043e\u043d\u044b \u0440\u0430\u0437\u043b\u0435\u0442\u0430\u044e\u0442\u0441\u044f \u043f\u043e \u0441\u0432\u043e\u0438\u043c \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u043c \u0421\u043a\u043b\u0430\u0434\u0430\u043c\nbeta = 0\nDRONES_delivers = [Drone(wh_mass[0].point, True, nb) for nb in range(DRONES_delivers_count)]\nfor i in range(DRONES_delivers_count):\n    DRONES_delivers[i].__goto__(wh_mass[beta].point)\n    DRONES_delivers[i].deliver__init__(wh_mass, beta)\n    beta += 1\n    if beta >= len(wh_mass): beta = 0\n\n# \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0446\u0438\u043a\u043b \u0441\u0442\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u0438\nprint(\"\u0421\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u044f \u043d\u0430\u0447\u0430\u0442\u0430\")\n\nfor turn_simul in range(TURNS,0,-1):\n    if turn_simul % 1000 == 0 or turn_simul == TURNS:\n        print(TURNS - turn_simul, \" \", SCORE)\n\n    # \u0446\u0438\u043a\u043b \u043f\u043e \u0434\u043e\u0441\u0442\u0430\u0432\u0449\u0438\u043a\u0430\u043c\n    for i in DRONES_delivers:\n        # \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442\u0441\u044f \u0445\u043e\u0434 \u0434\u0440\u043e\u043d\u0430\n        if i.turns == turn_simul:\n            # \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043d\u0430 \u043e\u0447\u0435\u0440\u0435\u0434\u043d\u0443\u044e \u043f\u0435\u0442\u043b\u044e (\u0432\u044b\u0437\u043e\u0432 deliver_cicle)\n            i.delive_cicle()\n\n    continue\nprint(\"\u0421\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u044f \u043e\u043a\u043e\u043d\u0447\u0435\u043d\u0430\")\nprint(\"SCORE \", SCORE)","c612e3c4":"print(\"\u0417\u0430\u043f\u0438\u0441\u044c...\")\nsubmis = open('.\/submission.csv', 'w')\nsubmis.write(str(len(Sub_mas)) + '\\n')\nfor i in Sub_mas:\n    submis.write(i + '\\n')\nprint(\"\u043e\u043a\u043e\u043d\u0447\u0435\u043d\u0430:)\")","6aff9c06":"## Main. Make drones and let them do their work (Simulation)","f895b4ea":"# Using Genetic Algorithm to solve the problem\nThe solution was written by a team of St. Petersburg State University students.\n## Developers:  \naleka_alexander@mail.ru\n### Allahverdyan Alexander  \n### Martemyanov Alexey  \n### Markelova Anastasia  \n### Our professor: Dr. Ovanes Petrosian http:\/\/www.apmath.spbu.ru\/en\/staff\/petrosjanol\/index.html","84965792":"## Main class Drone - main function is delive_cicle + genetic algotithm\nDrones try to find the best way from the warehouse to the warehouse across orders","db8ee33a":"## Make submission","586c857d":"## Sub-classes","7eb12b02":"## Reading from the file"}}