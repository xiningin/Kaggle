{"cell_type":{"893d7852":"code","110382ef":"code","e6dbfb05":"code","29148d92":"code","35719da6":"code","4acd51a0":"code","3afaabf0":"code","27fc2aee":"code","31f23e0a":"code","94fdd845":"code","d02ed5da":"markdown","4cc5a3a2":"markdown","d06402cd":"markdown","54e702b7":"markdown","f15313e0":"markdown","e8c91621":"markdown","3dc20815":"markdown","c7b3e510":"markdown","badee1f1":"markdown"},"source":{"893d7852":"!pip install git+https:\/\/github.com\/EasyArray\/phosphorus#egg=phosphorus\n%load_ext phosphorus\nfrom IPython.core.display import display, HTML\ndef header(s, size=\"h3\"): display(HTML(f\"<{size}>{s}<\/{size}>\"))","110382ef":"myset = {\u27e81,2\u27e9, \u27e82,3\u27e9}\nmyset(1)    #treats the set as an explicit function\nmyset(\u27e81,2\u27e9) #treats the set as a characteristic function\nmyset(1,2)  #you can leave off the brackets\nmyset(5,6)  #False, since the function does not include the pair \u27e85,6\u27e9\n\n#Throws an error, since it assumes myset is an explicit function:\n#myset(5)   # NOTE: uncomment to confirm, then recomment if you want to be able to \"Run All\"","e6dbfb05":"from functools import reduce\ndef powerset(lst):\n    return reduce(lambda result, x: result \u222a {subset \u222a {x} for subset \u2208 result},\n                  lst, {{}})\n\npowerset({A..G})","29148d92":"DOMAIN  = \u27e8A..D\u27e9\n#Properties used below; feel free to change these to test for equality under all conditions\n`green = {A,B,C}                   #A set of green things\n`likes = {\u27e8A,B\u27e9, \u27e8A,D\u27e9, \u27e8B,C\u27e9, \u27e8D,A\u27e9} #A RELATION capturing who likes whom\n\nheader(\"Exercise a:\")\n{\u27e8\u03b1,\u03b2\u27e9 : {\u03b1} == {\u03b2} | \u03b1\u2208DOMAIN, \u03b2\u2208DOMAIN}\n\nheader(\"Exercise b:\")\n{\u03b1 : {x | x\u2208DOMAIN, x==\u03b1} == {\u03b1} | \u03b1\u2208DOMAIN }\n\nheader(\"Exercise c:\")\n{x | x\u2208DOMAIN, `green(x) } == {y | y\u2208DOMAIN, `green(y) }\n\nheader(\"Exercise d:\")\n{\u27e8\u03b1,\u03b2\u27e9 : {x | x\u2208DOMAIN, `likes(x,\u03b1) } == {y | y\u2208DOMAIN, `likes(y,\u03b2) } |  \u03b1\u2208DOMAIN, \u03b2\u2208DOMAIN}\n\nheader(\"Exercise e:\")\n{\u03b3 : {x | x\u2208\u03b3} == \u03b3 | \u03b3\u2208powerset(DOMAIN)}\n\nheader(\"Exercise f:\")\n{\u03b3 : {x | x\u2208{y | y\u2208\u03b3}} == \u03b3 | \u03b3\u2208powerset(DOMAIN)}\n\nheader(\"Exercise g:\")\n{x | x\u2208DOMAIN, {y | y\u2208DOMAIN, `likes(y,x)}=={}}\n{x | x\u2208DOMAIN, {y | y\u2208DOMAIN, `likes(y,y)}=={}}","35719da6":"# Heim & Kratzer System pp 15-16\nDOMAIN  = [A..Z]\n\nlex Ann    = A\nlex Jan    = J\nlex Maria  = M\nlex works  = {A\u27f61,M\u27f61,J\u27f60}\nlex smokes = {A\u27f60,M\u27f60,J\u27f61}\n\nRule.deregister()\n#Note: S1 is written to NOT apply in the negated sentence from Problem 3 below\nrule S1 \u27e6tree[_S \u03b2 \u03b3]\u27e7 = \u27e6\u03b3\u27e7(\u27e6\u03b2\u27e7) || \u03b2 != it_is_not_the_case_that\nrule S2 \u27e6tree[_NP \u03b2]\u27e7  = \u27e6\u03b2\u27e7\nrule S3 \u27e6tree[_VP \u03b2]\u27e7  = \u27e6\u03b2\u27e7\nrule S4 \u27e6tree[_N \u03b2]\u27e7   = \u27e6\u03b2\u27e7\nrule S5 \u27e6tree[_V \u03b2]\u27e7   = \u27e6\u03b2\u27e7\n\nrule word \u27e6\u03b1\u27e7 = lex[\u03b1] || \u03b1 \u2208 lex","4acd51a0":"#Test cases:\n\u27e6Ann\u27e7\n\u27e6smokes\u27e7\nt = tree[_S [_NP [_N Ann]] [_VP [_V smokes]]]\nt\n\u27e6t, showparse=True\u27e7 #You can show the parse this way, or with a simple \", True\"","3afaabf0":"\"Enter-first-tree-here----\"\nt1 = tree[_S REPLACE]\nt1\n\u27e6t1\u27e7\n\n\"Enter-second-tree-here----\"\nt2 = tree[_S REPLACE]\nt2\n\u27e6t2\u27e7","27fc2aee":"# New lexical items: FIX THESE\nlex it_is_not_the_case_that = {}\nlex AND = {} \nlex OR  = {}\n\n# New rule or rules:  ADD HERE\n#     (Notice the ConjP phrase type below)\n\n\n\n\"Tests-----------------\" #Note that a \\ at the end of a line shows that it continues on the next line\nt1 = tree[_S [_S Jan works] \\\n             [_ConjP AND [_S it_is_not_the_case_that \\\n                             [_S Jan smokes] \\\n                         ] \\\n             ] \\\n         ]\nt1\n\u27e6t1\u27e7\n\nta = tree[_S Ann works]\nta\n\u27e6ta\u27e7\ntb = tree[_S Ann smokes]\ntb\n\u27e6tb\u27e7\nt2 = tree[_S ta [_ConjP AND tb]]\nt2\n\u27e6t2\u27e7\n\nt3 = tree[_S ta [_ConjP OR tb]]\nt3\n\u27e6t3\u27e7\n\nt4 = tree[_S ta [_ConjP AND [_S Ann works]]]\nt4\n\u27e6t4\u27e7\n\nt5 = tree[_S ta [_ConjP OR [_S Ann works]]]\nt5\n\u27e6t5\u27e7\n","31f23e0a":"rule AltS1 \u27e6 tree[_AltS REPLACE] \u27e7 = REPLACE\n\nlex alt_smokes = {A,J}\n\n\u27e6 tree[_AltS Ann alt_smokes] \u27e7","94fdd845":"#Relations (GIVEN TO YOU)\nR_adores     = {\u27e8J,M\u27e9, \u27e8M,M\u27e9}\nR_assigns_to = {\u27e8J,J,M\u27e9, \u27e8M,J,M\u27e9}\n\n\n#Characteristic functions (YOU COMPLETE)\nCHAR_adores     = {}\nCHAR_assigns_to = {}\n\n#New Lexical entries (YOU COMPLETE)\nlex adores  = {J\u27f6{}, M\u27f6{} }\nlex assigns = {J\u27f6{}, M\u27f6{} }\n\n\n#New rules (GIVEN TO YOU)\nrule S6 \u27e6 tree[_VP \u03b2 \u03b3]  \u27e7 = \u27e6\u03b2\u27e7(\u27e6\u03b3\u27e7)\nrule PP \u27e6 tree[_PP to \u03b2] \u27e7 = \u27e6\u03b2\u27e7\n\n#Tests\nt1 = tree[_S Jan [_VP adores Maria]]\nt1\n\u27e6t1\u27e7\nt2 = tree[_S Jan [_VP [_VP assigns Maria] [_PP to Jan]]]\nt2\n\u27e6t2\u27e7","d02ed5da":"**<mark>Problem 5 (pp. 31-2, 25 points)<\/mark>** Assume for the purpose of this problem that our universe ``DOMAIN`` contains JUST the elements, **J** and **M** for *Jan* and *Maria*. Consider now the binary and ternary relations ``R_adores`` and ``R_assigns_to``, defined in the cell below. \nFirst, write the characteristic functions for these sets in the variables ``CHAR_adores`` and ``CHAR_assigns_to`` below. Next, Sch&ouml;nfinkel (aka curry) them from right-to-left and enter the result in the lexical entries for ``adores`` and ``assigns`` below. \n\n**Remember:** \n+ A characteristic function will always be a set of pairs whose second item is either 0 or 1\n+ A characteristic function must have a pair for every possible element of the set. For `R_adores` this will be all four pairs of J's and M's. For `R_assigns_to`, it will be all eight triples.\n+ Currying right-to-left means that you start with the *last* element of the tuples, e.g. `M` in `\u27e8J,J,M\u27e9`.\n\nFinally, check if the two trees ``t1`` and ``t2`` below give satisfactory results, based on these lexical entries. Why or why not? (Answer in markdown here:)\n\n","4cc5a3a2":"### Lambda Notation\n\n**<mark>Problem 6 (p. 39, 15 points)<\/mark>** Use normal language to describe the following functions in words, avoiding variable names as much as possible!\n\n*Hint 1*: you can answer each as \"the smallest function mapping a(n) \\_\\_\\_\\_\\_ to \\_\\_\\_\\_\\_\"\n\n*Hint 2*: For any $A\\subseteq B$, $B\\setminus A$ is called \"A's complement in B\".\n\na. $[\\lambda x{\\in}\\mathbb{N}\\:.\\:x{>}3 \\text{ and } x{<}7]$\n\nb. $[\\lambda x : x \\text{ is a person } . x\\text{'s father}]$\n\nc. $[\\lambda X{\\in}{\\mathscr Pow}(D)\\:.\\: \\{y{\\in}D : y{\\notin}X\\}]$\n\nd. $[\\lambda X{\\subseteq}D\\:.\\: \\left[\\lambda y{\\in}D\\:.\\: y{\\notin}X\\right]]$\n","d06402cd":"# Homework 2: Chapters 1-2\n### Sets\n\nPhosphorus is very flexible in how it allows sets to act as explicit functions. It can treat a set as an explicit function, where the first element of each pair in the set maps to the second element. But it *also* can treat sets as characteristic functions, returning `True` for elements in the set and `False` otherwise. Finally, tuples can be sent as multiple arguments to sets, leaving off their brackets. This functionality is illustrated in the cell below.","54e702b7":"### Explicit Functions\n\nThe first cell below implements the system presented on pp. 15-16. Notes:\n* An explicit domain ``DOMAIN`` of individuals is given, consisting of all the uppercase letters.\n* The names **Ann**, **Jan**, and **Maria** denote individuals ``A``, ``J``, and ``M`` respectively.\n* The intransitive verbs **works** and **smokes** are given explicit denotations over just these individuals. The extensions chosen are arbitrary.\n* Just as in the book, pairs may be introduced with arrows instead of angle brackets and commas. To enter `\u27f6`, type `\\->` then hit tab.\n* As mentioned above, Phosphorus recognizes these explicit functions and will return the proper value, for instance, for `{\u27e8A,1\u27e9,\u27e8M,1\u27e9,\u27e8J,0\u27e9}(A)` (namely `1`, try it!).\n* Note that these verbs are functions from individuals to Heim \\& Kratzer truth values, i.e., special sets of pairs where the first member is an individal and the second is either 0 or 1.\n* Finally, the rules (S1) - (S5) are implemented in Phosphorus.","f15313e0":"#### Power Sets\nThe power set of a set *S*, often written **&Pscr;&oscr;&wscr;**(*S*) is the set of all subsets of *S*. The following cell contains a helper function `powerset` that returns the powerset of a set. (Don't worry if you don't understand the code that defines `powerset`!) This function will be used in the first problem below.","e8c91621":"**<mark>Problem 2 (4 points)<\/mark>** Enter two new trees (not the ones in the book) in the cell below: one that evaluates to true, given the lexicon above, and one that evaluates to false. <mark style=\"background-color:lightgreen;\">Both trees should use all five rules.<\/mark>","3dc20815":"**<mark>Problem 3 (p. 23 and p. 32, 25 points)<\/mark>**\nSuppose we extend our fragment to include phrase structures of the forms below (where the embedded S-constituents may either belong to the initial fragment or have one of these three forms themselves):\n    \n        [_S it is not the case that [_S ...]]\n\n        [_S [_S ... ] [_ConjP AND [_S ... ]]]\n\n        [_S [_S ... ] [_ConjP OR [_S ... ]]]\n    \nHow do we have to revise and extend the semantic component in order to provide all the phrase structures in this expanded fragment with interpretations? Your task in this exercise is to define an appropriate semantic value for each new lexical item (treat \"it is not the case that\" as a single lexical item `it_is_not_the_case_that` here) and to write appropriate semantic rules for the new types of non-terminal nodes. To do this, you will also have to expand the inventory of possible semantic values to include two new types of functions. Make sure that you stick to our working hypothesis that all semantic composition is functional application (Frege's Conjecture).\n    \n*Hint*: These lexical items should be functions that take truth values (**0** or **1**). In other words, they should be sets of pairs, and the first item in each pair should be either 0 or 1.","c7b3e510":"**<mark> Problem 4 (p. 24, 10 points)<\/mark>** Write a new rule ``AltS1`` for combining the subject and predicate (VP) of a sentence labeled ``AltS`` assuming that the denotation of the VP is a set of individuals, instead of a function. This type of meaning is provided in the made-up word ``alt_smokes`` below. NOTE:\n+ This is asking you consider\/create an alternative system, rather than fix the official system. That is why we have given different names to several of the items involved.\n+ Your answer to this H\\&K problem should be very similar to the system from HW1...\n","badee1f1":"**<mark>Problem 1 (from p. 9, 21 points)<\/mark>** The same set can be described in many different ways, which often look quite different superficially.  For this problem, you must figure out which of the following equalities hold and which ones don't.  Sometimes the right answer is not just plain \"yes\" or \"no\", but something like \"yes, but only if...\".  For example, the two sets `{\u03b1}` and `{\u03b2}` are equal only in the special case where `\u03b1==\u03b2`. In this case, specify the special case(s) when they are equal.\n    \nTake full advantage of Phosphorus by running the cell below. You can also play around with the values for the predicates given at the top of the next cell: `` `green``, and `` `likes``. Then, rerun the cell to see if the sets are equal or not. This will be especially useful for exercise g!\n\nFinally, <mark style=\"background-color:lightgreen;\">answer the question in this cell<\/mark>, here:<p\/>\n    \na. ``{\u03b1} == {\u03b2}``\n\nb. ``{x | x\u2208DOMAIN, x==\u03b1} == {\u03b1}``\n\nc. ``{x | x\u2208DOMAIN, `green(x) } == {y | y\u2208DOMAIN, `green(y) }``\n\nd. ``{x | x\u2208DOMAIN, `likes(x,\u03b1) } == {y | y\u2208DOMAIN, `likes(y,\u03b2) }``\n\ne. ``{x | x\u2208\u03b3} == \u03b3``\n\nf. ``{x | x\u2208{y | y\u2208\u03b3}} == \u03b3``\n\ng. ``{x | x\u2208DOMAIN, {y | y\u2208DOMAIN, `likes(y,x)}=={}} == {x | x\u2208DOMAIN, {y | y\u2208DOMAIN, `likes(y,y)}=={}}``"}}