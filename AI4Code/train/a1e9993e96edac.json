{"cell_type":{"86395ad1":"code","874a0f70":"code","c06de921":"code","d2ba7c6d":"code","68e25440":"code","086a2e35":"code","b6f0a507":"code","ce9fc41e":"code","9f313ddc":"code","ad00b91b":"code","a74b33b1":"code","004234ba":"code","0c8ed804":"code","15b58fdf":"code","bae97f3e":"code","4e11adfc":"markdown"},"source":{"86395ad1":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","874a0f70":"df = pd.read_csv('..\/input\/malware-detection-ga-team\/train.csv', dtype = {'PuaMode': str})","c06de921":"convert_category = {\n    'ProductName': 'category',\n    'EngineVersion': 'category',\n    'AppVersion': 'category',\n    'AvSigVersion': 'category',\n    'Platform': 'category',\n    'Processor': 'category',\n    'OsVer': 'category',\n    'OsPlatformSubRelease': 'category',\n    'OsBuildLab': 'category',\n    'SkuEdition': 'category',\n    'SmartScreen': 'category',\n    'Census_MDC2FormFactor': 'category',\n    'Census_DeviceFamily': 'category',\n    'Census_PrimaryDiskTypeName': 'category',\n    'Census_ChassisTypeName': 'category',\n    'Census_PowerPlatformRoleName': 'category',\n    'Census_InternalBatteryType': 'category',\n    'Census_OSVersion': 'category',\n    'Census_OSArchitecture': 'category',\n    'Census_OSBranch': 'category',\n    'Census_OSEdition': 'category',\n    'Census_OSInstallTypeName': 'category',\n    'Census_OSWUAutoUpdateOptionsName': 'category',\n    'Census_GenuineStateName': 'category',\n    'Census_ActivationChannel': 'category',\n    'Census_FlightRing': 'category',\n    'OrganizationIdentifier': 'category',\n    'CityIdentifier': 'category',\n    'Wdft_RegionIdentifier': 'category',\n    'Census_FirmwareManufacturerIdentifier': 'category',\n    'Census_FirmwareVersionIdentifier': 'category',\n    'Census_OEMModelIdentifier': 'category',\n    'Census_OEMNameIdentifier': 'category',\n    'AVProductStatesIdentifier': 'category',\n    'Census_ProcessorModelIdentifier': 'category',\n    'Census_ProcessorManufacturerIdentifier': 'category',\n    'Census_PrimaryDiskTypeName': 'category',\n    'Census_ChassisTypeName': 'category',\n    'GeoNameIdentifier': 'category',\n    'OsBuildLab': 'category',\n    'Census_PowerPlatformRoleName': 'category',\n    'OsBuild': 'category',\n    'Census_OSUILocaleIdentifier': 'category',\n    \n}\n\ndf = df.astype(convert_category)\n","d2ba7c6d":"def check_missing_data(df, label, cols=None):\n    data_slice = df if cols is None else df[cols]\n    missing_count = data_slice.isnull().sum(axis=0)\n    missing_percent = 100 * missing_count \/ len(data_slice)\n    missing_values = pd.concat([missing_count, missing_percent], axis=1)\n    missing_values = missing_values.rename(\n                        columns = {0 : 'Missing Count', \n                                   1 : '% Missing'}\n                     )\n    missing_values = missing_values[missing_values.iloc[:,1] != 0]\\\n                        .sort_values('% Missing', \n                                     ascending=False).round(1)\n    print()\n    print(f'{label} Missing Values')\n    print(missing_values.head(8))\n\ndef summarize_missing_data(cols=None):\n    check_missing_data(df, 'Training', cols)\n\nsummarize_missing_data()","68e25440":"df.drop(['PuaMode', 'Census_ProcessorClass', 'DefaultBrowsersIdentifier', 'Census_IsFlightingInternal'], axis=1, inplace = True)","086a2e35":"df.drop(['MachineIdentifier','IsBeta', 'Census_IsFlightsDisabled', 'Census_OSSkuName', 'AutoSampleOptIn', 'SMode', 'Census_ThresholdOptIn'], axis=1, inplace = True)","b6f0a507":"df.drop(['ProductName','AvSigVersion','IsSxsPassiveMode', 'Platform','Census_OSArchitecture','Census_OSVersion','Census_OSBuildNumber','SkuEdition','Census_OSEdition','IeVerIdentifier','Census_InternalPrimaryDisplayResolutionVertical','Census_OSInstallLanguageIdentifier'], axis=1, inplace = True)","ce9fc41e":"na_values = {\n    'Census_InternalBatteryType': 'unkn',\n    'Census_IsWIMBootEnabled': 1,\n    'SmartScreen': 'off',\n    'OrganizationIdentifier': df.OrganizationIdentifier.mode().iloc[0],\n    'CityIdentifier': df.CityIdentifier.mode().iloc[0],\n    'Wdft_RegionIdentifier': df.Wdft_RegionIdentifier.mode().iloc[0],\n    'Wdft_IsGamer': 0,\n    'Census_InternalBatteryNumberOfCharges': 0,\n    'Census_FirmwareManufacturerIdentifier': df.Census_FirmwareManufacturerIdentifier.mode().iloc[0],\n    'Census_FirmwareVersionIdentifier': df.Census_FirmwareVersionIdentifier.mode().iloc[0],\n    'Census_OEMModelIdentifier': df.Census_OEMModelIdentifier.mode().iloc[0],\n    'Census_OEMNameIdentifier': df.Census_OEMNameIdentifier.mode().iloc[0],\n    'Firewall': 0,\n    'Census_TotalPhysicalRAM': 4096,\n    'Census_IsAlwaysOnAlwaysConnectedCapable': 0,\n    'Census_SystemVolumeTotalCapacity': df.Census_SystemVolumeTotalCapacity.mode().iloc[0],\n    'Census_PrimaryDiskTotalCapacity': df.Census_PrimaryDiskTotalCapacity.mode().iloc[0],\n    'Census_InternalPrimaryDiagonalDisplaySizeInInches': df.Census_InternalPrimaryDiagonalDisplaySizeInInches.mode().iloc[0],\n    'Census_InternalPrimaryDisplayResolutionHorizontal': df.Census_InternalPrimaryDisplayResolutionHorizontal.mode().iloc[0],\n    'AVProductStatesIdentifier': df.AVProductStatesIdentifier.mode().iloc[0],\n    'AVProductsInstalled': 0,\n    'AVProductsEnabled': 0,\n    'IsProtected': 0,\n    'Census_ProcessorModelIdentifier': df.Census_ProcessorModelIdentifier.mode().iloc[0],\n    'Census_ProcessorCoreCount': df.Census_ProcessorCoreCount.mode().iloc[0],\n    'Census_ProcessorManufacturerIdentifier': df.Census_ProcessorManufacturerIdentifier.mode().iloc[0],\n    'RtpStateBitfield': df.RtpStateBitfield.mode().iloc[0],\n    'Census_IsVirtualDevice': 0,\n    'Census_PrimaryDiskTypeName': 'UNKNOWN',\n    'UacLuaenable': 0,\n    'Census_ChassisTypeName': 'Other',\n    'GeoNameIdentifier': df.GeoNameIdentifier.mode().iloc[0],\n    'OsBuildLab': df.OsBuildLab.mode().iloc[0],\n    'Census_PowerPlatformRoleName': df.Census_PowerPlatformRoleName.mode().iloc[0]\n}\n\ndf.fillna(value = na_values, inplace = True)","9f313ddc":"df.SmartScreen.replace(to_replace=['Off', 'OFF', '&#x01;', '&#x02;'], value='off', inplace=True)\ndf.SmartScreen.replace(to_replace=['On'], value='on', inplace=True)\n\ndf.Census_MDC2FormFactor.replace(to_replace=['SmallServer', 'MediumServer', 'LargeServer', 'ServerOther'], value='Server', inplace=True)\ndf.Census_MDC2FormFactor.replace(to_replace=['LargeTablet', 'SmallTablet'], value='Tablet', inplace=True)\n\ndf.Census_DeviceFamily.replace(to_replace=['Windows'], value = 'Windows.Desktop', inplace=True)\n\ndf.Census_PrimaryDiskTypeName.replace(to_replace=['Unspecified'], value = 'UNKNOWN', inplace=True)\n\ndf.Census_ChassisTypeName.replace(to_replace=['UNKNOWN', 'Unknown', '30', 'StickPC', '0', \n                                              'MultisystemChassis', 'Blade', 'PizzaBox', '35', \n                                              'SubChassis', 'DockingStation', 'ExpansionChassis',\n                                              '25', '127', '32', 'SealedCasePC'], value = 'Other', inplace=True)\n\ndf.Census_PowerPlatformRoleName.replace(to_replace=['Unspecified', 'UNKNOWN'], value = 'Unkown', inplace=True)\n\ndf.Census_InternalBatteryType.replace(to_replace=['li-i', 'ithi', 'lit', 'li', 'liio'], value='lion', inplace=True)\ndf.Census_InternalBatteryType.replace(to_replace=['li p', 'lipo', 'lipp', 'li-p', '\u0003ip'], value='lip', inplace=True)\ndf.Census_InternalBatteryType.replace(to_replace=['4cel','lgi0', 'lhp0', 'virt', 'batt', 'ram', 'ca48', 'pad0', 'ots0',\n                                                  'l\u0006&#TAB#', 'bad', 'asmb', '#'], value='unkn', inplace=True)\n\ndf.Census_OSBranch.replace(to_replace=['rs5_release_sign', 'rs5_release_sigma'], value='rs5_release', inplace=True)\ndf.Census_OSBranch.replace(to_replace=['rs1_release_srvmedia'], value='rs1_release', inplace=True)\ndf.Census_OSBranch.replace(to_replace=['rs_prerelease_flt'], value='rs_prerelease', inplace=True)\ndf.Census_OSBranch.replace(to_replace=['rs3_release_svc_escrow_im'], value='rs3_release_svc_escrow', inplace=True)\ndf.Census_OSBranch.replace(to_replace=['winblue_ltsb', 'win7sp1_ldr'], value='rs4_release', inplace=True)\n\ndf.Census_FlightRing.replace(to_replace=['NOT_SET', 'Disabled'], value='Unknown', inplace=True)\n\ndf.RtpStateBitfield.replace(to_replace=35.0, value=3.0, inplace=True)\ndf.UacLuaenable.replace(to_replace=[48.0, 6357062.0, 49.0, 7798884.0, 2.0], value=1.0, inplace=True)\n","ad00b91b":"cat_columns = df.select_dtypes(['category']).columns\nint_columns = df.select_dtypes(['int']).columns\nfloat_columns = df.select_dtypes(['float']).columns","a74b33b1":"df[cat_columns] = df[cat_columns].apply(lambda x: x.cat.codes)","004234ba":"corr_matrix = df.corr()","0c8ed804":"high_corr = {}\n\nfor column in corr_matrix.columns:\n    for index in corr_matrix.index:\n        if (corr_matrix[index][column] > 0.85 or corr_matrix[index][column] < -0.85) and column != index:\n            if(index in high_corr and column in high_corr[index]):\n                continue\n            if column not in high_corr: \n                high_corr[column] = []\n            high_corr[column].extend([index, round(corr_matrix[index][column], 2)])\n            \nhigh_corr","15b58fdf":"pd.Series(df.columns)","bae97f3e":"from sklearn.svm import SVC\nfrom sklearn.model_selection import train_test_split\n\ntraining_set, test_set = train_test_split(df, test_size = 0.2, random_state = 1)\n\nX_train = training_set.iloc[:,0:59].values\nY_train = training_set.iloc[:,59].values\n\nclassifier = SVC(kernel='rbf', random_state = 1)\nclassifier.fit(X_train,Y_train)","4e11adfc":"**HasDetections** is the target attribute. Yes and No predictions are to be made, i.e, if a machine will detect malware, thus a Logistic Regression model or a Support Vector Machine can be used"}}