{"cell_type":{"3bf58106":"code","7aa7b179":"code","3768560d":"code","a9d507e2":"code","705af3ee":"code","38ad3f49":"code","11a3bed7":"code","151a6b97":"code","e6a62fb4":"code","04130e91":"code","780ad28d":"code","5ea0aaa7":"code","0b3f0454":"code","de88338a":"code","676ac757":"code","358da41a":"code","528e5777":"code","152de39d":"code","6bd869e5":"markdown","7121996b":"markdown","3efb12f6":"markdown","7d6c42a1":"markdown","544ff459":"markdown","7b81a536":"markdown","c6d51b30":"markdown","5cbddaef":"markdown","f2785497":"markdown","0fe52cb8":"markdown","7e123565":"markdown","974bc61a":"markdown","70d31e0a":"markdown","1cc82fdf":"markdown"},"source":{"3bf58106":"from sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import KFold, StratifiedKFold\nfrom sklearn import preprocessing\nfrom sklearn.metrics import log_loss\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nfrom keras.models import Model\nimport tensorflow as tf\nfrom tensorflow.keras import activations,callbacks\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.metrics import categorical_crossentropy\nfrom keras.models import Sequential\nimport keras \nfrom keras.layers import Dense, Flatten, Conv1D,MaxPooling1D, Dropout,BatchNormalization,Embedding,Concatenate, Activation,Input\nfrom keras.callbacks import ModelCheckpoint\nfrom keras.models import model_from_json\nfrom keras import backend as K\n","7aa7b179":"train = pd.read_csv('..\/input\/tabular-playground-series-may-2021\/train.csv')\ntest = pd.read_csv('..\/input\/tabular-playground-series-may-2021\/test.csv')","3768560d":"# Without labelencoding\ntarget = pd.get_dummies(train['target'])\ny = train['target']\nX = train.iloc[:,1:-1]\ntest = test.iloc[:,1:]\n\n# To avoid negative values (for embedding), \n# we just add 8 to all categories :\nX = X + 8\ntest = test + 8\nX.shape, test.shape, y.shape, target.shape","a9d507e2":"X_train, X_test, y_train, y_test = train_test_split(X,\n                                                    target,\n                                                    test_size = 0.2,\n                                                    stratify = y,\n                                                    random_state = 41)\n\nX_train.shape, y_test.shape, y_train.shape, y_test.shape","705af3ee":"es = callbacks.EarlyStopping(\n                monitor = 'val_categorical_crossentropy', \n                min_delta = 0.00000001, \n                patience = 3,\n                mode = 'min',\n                baseline = None, \n                restore_best_weights = True,\n                verbose = 1)\n\nplateau  = callbacks.ReduceLROnPlateau(\n                monitor = 'val_categorical_crossentropy',\n                factor = 0.5, \n                patience = 2, \n                mode = 'min', \n                min_delt = 0.00000001,\n                cooldown = 0, \n                min_lr = 1e-7,\n                verbose = 1) \n\nmetrics = [tf.keras.metrics.CategoricalCrossentropy()]\nloss = tf.keras.losses.CategoricalCrossentropy(\n                from_logits = False,\n                label_smoothing = 0,\n                reduction =\"auto\",\n                name = \"categorical_crossentropy\")","38ad3f49":"inputs_API_Embedding = Input(shape = (50,), name = 'API_input_Embedding')\nx = Embedding(80, 10, input_length = 50)(inputs_API_Embedding)\nx = Flatten()(x)\nx = Dense(80, activation =\"relu\")(x)\nx = Dense(40, activation =\"relu\")(x)\nx = Dense(20, activation ='relu')(x)\noutputs_API_Embedding = Dense(4, activation ='relu')(x)","11a3bed7":"model0 = Sequential()\nmodel0.add(Embedding(80, 10, input_length = 50, input_shape = (50,)))\nmodel0.add(Flatten())\nmodel0.add(Dense(80, activation ='relu'))\nmodel0.add(Dense(40, activation ='relu'))\nmodel0.add(Dense(20, activation ='relu'))\nmodel0.add(Dense(4, activation ='relu'))","151a6b97":"inputs_API_Conv1D = Input(shape = (50,1), name = 'API_input_Conv1D') \ny = Conv1D(\n            filters = 512, \n            kernel_size = 5,\n            padding='same', \n            activation = 'relu',\n            )(inputs_API_Conv1D)\n\ny = MaxPooling1D(pool_size = 3)(inputs_API_Conv1D)\ny = Flatten()(y)\ny = Dense(64, activation = 'relu')(y)\noutputs_API_Conv1D = Dense(4, activation ='relu')(y)","e6a62fb4":"model3 = Sequential()\nmodel3.add(Conv1D(\n            filters = 256, \n            kernel_size = 5,\n            padding = 'same', \n            activation = 'relu',\n            input_shape = (50, 1)))\n\nmodel3.add(MaxPooling1D(pool_size = 5))\nmodel3.add(Flatten())\nmodel3.add(Dense(64, activation ='relu'))\nmodel3.add(Dense(4, activation ='softmax'))","04130e91":"# We need to prepare inputs and outputs \n# for Sequential models to be able to concatenate with API later:\n\nsequential_input_embedding = Input(shape = (50,), \n                                   name = 'Sequential_Embedding')\nsequential_output_embedding = model0(sequential_input_embedding)\n\nsequential_input_conv1D = Input(shape = (50,), \n                                name = 'Sequential_Conv1D')\nsequential_output_conv1D = model0(sequential_input_conv1D)","780ad28d":"# Final step with concatenation of Embedding and Conv1D :\nz = Concatenate(axis=1)([sequential_output_embedding, outputs_API_Conv1D])\nout = Dense(4, activation = 'softmax', name = 'out')(z)\n\n# Creation of the merged model :\nmodel_merged = Model(\n                    inputs = [sequential_input_embedding,inputs_API_Conv1D],\n                    outputs = out, \n                    name = \"model_merged\")\n\n# Compile and fit of the merged model :\nmodel_merged.compile(\n                    tf.keras.optimizers.Adam(learning_rate=0.0001),\n                    loss = loss ,\n                    metrics = metrics)\nmodel_merged.fit(\n                    {'Sequential_Embedding': X_train, \n                     'API_input_Conv1D': X_train},\n                    {'out':y_train},\n                    validation_data = ([X_test,X_test], y_test),\n                    batch_size = 128,\n                    epochs = 50,\n                    verbose = 0,\n                    callbacks = [es,plateau])","5ea0aaa7":"print(\"Score for train.csv :\",log_loss(target, model_merged.predict([X,X])))","0b3f0454":"# Final step with concatenation of Embedding and Conv1D :\nz = Concatenate(axis=1)([sequential_output_conv1D, outputs_API_Embedding])\nout = Dense(4, activation = 'softmax', name = 'out')(z)\n\n# Creation of the merged model :\nmodel_merged = Model(\n                    inputs=[sequential_input_conv1D,inputs_API_Embedding],\n                    outputs=out,\n                    name=\"model_merged\")\n\n# Compile and fit of the merged model :\nmodel_merged.compile(\n                    tf.keras.optimizers.Adam(learning_rate=0.0001),\n                    loss = loss ,\n                    metrics = metrics)\nmodel_merged.fit(\n                    {'Sequential_Conv1D':X_train, \n                     'API_input_Embedding':X_train},\n                    {'out':y_train},\n                    validation_data = ([X_test,X_test], y_test),\n                    batch_size=128,\n                    epochs=50,\n                    verbose=0,\n                    callbacks=[es,plateau])","de88338a":"print(\"Score for train.csv :\",log_loss(target, model_merged.predict([X,X])))","676ac757":"# Final step with concatenation of Embedding and Conv1D :\nz = Concatenate(axis=1)([sequential_output_conv1D, sequential_output_embedding])\nout = Dense(4, activation = 'softmax', name = 'out')(z)\n\n# Creation of the merged model :\nmodel_merged = Model(\n                    inputs=[sequential_input_conv1D,sequential_input_embedding],\n                    outputs=out, \n                    name=\"model_merged\")\n\n# Compile and fit of the merged model :\nmodel_merged.compile(\n                    tf.keras.optimizers.Adam(learning_rate=0.0001),\n                    loss = loss ,\n                    metrics = metrics)\nmodel_merged.fit(\n                    {'Sequential_Conv1D':X_train,\n                     'Sequential_Embedding':X_train},\n                    {'out':y_train},\n                    validation_data = ([X_test,X_test], y_test),\n                    batch_size=128,\n                    epochs=50,\n                    verbose=0,\n                    callbacks=[es,plateau])","358da41a":"print(\"Score for train.csv :\",log_loss(target, model_merged.predict([X,X])))","528e5777":"# Final step with concatenation of Embedding and Conv1D :\nz = Concatenate(axis=1)([outputs_API_Conv1D, outputs_API_Embedding])\nout = Dense(4, activation = 'softmax', name = 'out')(z)\n\n# Creation of the merged model :\nmodel_merged = Model(\n                    inputs=[inputs_API_Conv1D,inputs_API_Embedding],\n                    outputs=out, \n                    name=\"model_merged\")\n\n# Compile and fit of the merged model :\nmodel_merged.compile(\n                    tf.keras.optimizers.Adam(learning_rate=0.0001),\n                    loss = loss ,\n                    metrics = metrics)\nmodel_merged.fit(\n                    {'API_input_Conv1D':X_train, \n                     'API_input_Embedding':X_train},\n                    {'out':y_train},\n                    validation_data = ([X_test,X_test], y_test),\n                    batch_size=128,\n                    epochs=50,\n                    verbose=0,\n                    callbacks=[es,plateau])","152de39d":"print(\"Score for train.csv :\",log_loss(target, model_merged.predict([X,X])))","6bd869e5":"<h1> Let's have some fun with Keras cooking","7121996b":"<h2> API Conv1D + API Embedding","3efb12f6":"<h3> Functional API for Embedding","7d6c42a1":"<h3> Functional API for Conv1D","544ff459":"<h2> Compile & fit parameters","7b81a536":"<h3> Inputs and Outputs for Sequential models","c6d51b30":"<h3> Sequential for Conv1D","5cbddaef":"<h3> Sequential for Embedding","f2785497":"<h2> Sequential Embedding + API Conv1D","0fe52cb8":"<h2> Sequential Conv1D + API Embedding","7e123565":"<h2> Basic data preparation","974bc61a":"The goal was to mix Sequential and functional API and also 2 kind of model : Conv1D and Embedding.\nYou won't win the race, but the results are not ridiculous neither :-)\n\nFor those who are interested in creating a mix of API and Simple sequential model, it will be a simple example. \nSo you will find :\n- Sequential Embedding concatenated with Functional API Conv1D\n- Sequential Conv1D concatenated with Functional API Embedding\n- Sequential Conv1D concatenated with Sequential Embedding\n- Functional API Conv1D concatenated with Functional API Embedding","70d31e0a":"<h2> Sequential Conv1D + Sequential Embedding","1cc82fdf":"<h2> Base models : Embedding & Conv1D with Sequential & functional API "}}