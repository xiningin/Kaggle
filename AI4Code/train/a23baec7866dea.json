{"cell_type":{"1e70f8c8":"code","cf8d6eb0":"code","80abac61":"code","087e84e4":"code","787a4d35":"code","39746493":"code","941c426e":"code","5e632ef3":"code","f5e0ec2f":"code","57b558d7":"code","6545f0c5":"code","0737d95c":"code","3246ace8":"code","beed67d8":"markdown","d4d457cd":"markdown","aeeacaab":"markdown","b8289268":"markdown","24848f7a":"markdown","a8fbd1f8":"markdown","a1264ae0":"markdown","a681707d":"markdown","6969eb5a":"markdown","19fc9bbd":"markdown"},"source":{"1e70f8c8":"import numpy as np\nfrom numpy import sin, cos, pi\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom matplotlib.patches import Rectangle\nplt.style.use('seaborn-whitegrid')\n\n\ndef solve(initial_state, times, integrate_func, derivative_func):\n    \"\"\"\n    Solves the initial-value problem of the first order ODEs\n    :param initial_state: initial state\n    :param times: a sequence of time points for which to solve\n    :param integrate_func: calculates the next state\n    :param derivative_func: computes derivatives of each state component\n    :return:\n    \"\"\"\n    dt = times[1] - times[0]\n    states = [initial_state]\n    for step, t in enumerate(times):\n        states.append(integrate_func(states[-1], step, t, dt, derivative_func))\n    return np.array(states)\n\n\ndef integrate_rk4(state, step, t, dt, dydx_func):\n    \"\"\"\n    Fourth-order Runge-Kutta method.\n    Source: https:\/\/www.geeksforgeeks.org\/runge-kutta-4th-order-method-solve-differential-equation\/\n    :param step:\n    :param state:\n    :param t:\n    :param dt:\n    :param dydx_func:\n    :return:\n    \"\"\"\n    k1 = dydx_func(state, step, t, dt)\n    k2 = dydx_func([v + d * dt \/ 2 for v, d in zip(state, k1)], step, t, dt)\n    k3 = dydx_func([v + d * dt \/ 2 for v, d in zip(state, k2)], step, t, dt)\n    k4 = dydx_func([v + d * dt for v, d in zip(state, k3)], step, t, dt)\n    return [v + (k1_ + 2 * k2_ + 2 * k3_ + k4_) * dt \/ 6 for v, k1_, k2_, k3_, k4_ in zip(state, k1, k2, k3, k4)]","cf8d6eb0":"# model parameters\nM = 5.0\nm1 = 2.0\nm2 = 1.5\nl1 = 0.5\nl2 = 0.25\ng = 9.81\n\n# initial state\nX0 = 0.0  # cart position\ndX0 = 0.0  # cart velocity\nA0 = -0.2  # angle of the first joint\ndA0 = 0.0  # angular velocity of the first joint\nB0 = 0.1  # angle of the second joint\ndB0 = 0.0  # angular velocity of the second joint\n\ninitial_state = np.array([X0, dX0, A0, dA0, B0, dB0])\n\ndef derivatives(state, step, t_, dt_):\n    x, dx, a, da, b, db = state\n\n    dL_dx = 0.0\n    dL_da = -(m1 + m2) * l1 * da * dx * sin(a) + (m1 + m2) * g * l1 * sin(a) - m2 * l1 * l2 * da * db * sin(a - b)\n    dL_db = m2 * l2 * (g * sin(b) + l1 * da * db * sin(a - b) - dx * db * sin(b))\n\n    a11 = M + m1 + m2\n    a12 = (m1 + m2) * l1 * cos(a)\n    a13 = m2 * l2 * cos(b)\n    b1 = (m1 + m2) * l1 * da ** 2 * sin(a) + m2 * l2 * db ** 2 * sin(b)\n\n    a21 = (m1 + m2) * l1 * cos(a)\n    a22 = (m1 + m2) * l1 ** 2\n    a23 = m2 * l1 * l2 * cos(a - b)\n    b2 = (m1 + m2) * dx * da * l1 * sin(a) + m2 * l1 * l2 * db * (da - db) * sin(a - b)\n\n    a31 = m2 * l2 * cos(b)\n    a32 = m2 * l1 * l2 * cos(a - b)\n    a33 = m2 * l2 ** 2\n    b3 = m2 * dx * db * l2 * sin(b) + m2 * l1 * l2 * da * (da - db) * sin(a - b)\n\n    A = np.array([[a11, a12, a13], [a21, a22, a23], [a31, a32, a33]])\n    b_vec = np.array([b1 + dL_dx, b2 + dL_da, b3 + dL_db])\n    det_A = np.linalg.det(A)\n\n    Ax = np.copy(A)\n    Ax[:, 0] = b_vec\n    ddx = np.linalg.det(Ax) \/ det_A\n\n    Aa = np.copy(A)\n    Aa[:, 1] = b_vec\n    dda = np.linalg.det(Aa) \/ det_A\n\n    Ab = np.copy(A)\n    Ab[:, 2] = b_vec\n    ddb = np.linalg.det(Ab) \/ det_A\n    return [dx, ddx, da, dda, db, ddb]\n","80abac61":"times = np.linspace(0, 6, 6000)\ndt = times[1] - times[0]\n\nsolution = solve(initial_state, times, integrate_rk4, derivatives)","087e84e4":"def render(solution):\n    x_solution = solution[:, 0]\n    a_solution = solution[:, 2]\n    b_solution = solution[:, 4]\n\n    skip_frames = 40\n\n    x_solution = x_solution[::skip_frames]\n    a_solution = a_solution[::skip_frames]\n    b_solution = b_solution[::skip_frames]\n\n    frames = len(x_solution)\n\n    j1_x = l1 * sin(a_solution) + x_solution\n    j1_y = l1 * cos(a_solution)\n\n    j2_x = l2 * sin(b_solution) + j1_x\n    j2_y = l2 * cos(b_solution) + j1_y\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, autoscale_on=False, xlim=(-1, 1), ylim=(-1, 1))\n    ax.set_aspect('equal')\n    ax.grid()\n\n    patch = ax.add_patch(Rectangle((0, 0), 0, 0, linewidth=1, edgecolor='k', facecolor='r'))\n\n    line, = ax.plot([], [], 'o-', lw=2)\n    time_template = 'time: %.1f s'\n    time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)\n\n    cart_width = 0.15\n    cart_height = 0.1\n\n\n    def init():\n        line.set_data([], [])\n        time_text.set_text('')\n        patch.set_xy((-cart_width \/ 2, -cart_height \/ 2))\n        patch.set_width(cart_width)\n        patch.set_height(cart_height)\n        return line, time_text\n\n\n    def animate(i):\n        thisx = [x_solution[i], j1_x[i], j2_x[i]]\n        thisy = [0, j1_y[i], j2_y[i]]\n\n        line.set_data(thisx, thisy)\n        now = i * skip_frames * dt\n        time_text.set_text(time_template % now)\n\n        patch.set_x(x_solution[i] - cart_width \/ 2)\n        return line, time_text, patch\n\n\n    ani = animation.FuncAnimation(fig, animate, frames=frames,\n                                  interval=1, blit=True, init_func=init)\n    plt.close(fig)\n    return ani","787a4d35":"ani = render(solution)\n%time ani.save('free_dipc.gif', writer='imagemagick', fps=24)","39746493":"!pip install control","941c426e":"from numpy.linalg import matrix_rank, inv\nfrom control import ctrb, obsv\n\ndef get_a_b(M, m1, m2, l1, l2):\n    X = np.array([\n        [1, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 0],\n        [0, 0, 1, 0, 0, 0],\n        [0, 0, 0, M + m1 + m2, l1 * (m1 + m2), l2 * m2],\n        [0, 0, 0, l1 * (m1 + m2), l1 ** 2 * (m1 + m2), l1 * l2 * m2],\n        [0, 0, 0, l2 * m2, l1 * l2 * m2, l2 ** 2 * m2]\n    ], dtype=\"float64\")\n    N = np.array([\n        [0, 0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0, 0],\n        [0, (m1 + m2) * l1 * g, 0, 0, 0, 0],\n        [0, 0, m2 * l2 * g, 0, 0, 0]\n    ], dtype=\"float64\")\n    F = np.array([[0, 0, 0, 1, 0, 0]], dtype=\"float64\").T\n    X_inv = inv(X)\n    A = X_inv @ N\n    B = inv(X) @ F\n    return A, B","5e632ef3":"def check_ctrb_obsv(A, B, C):\n    ctrb_matrix = ctrb(A, B)\n    obsv_matrix = obsv(A, C)\n\n    print(\"Controllability matrix rank: %d\" % matrix_rank(ctrb_matrix))\n    print(\"Observability matrix rank: %d\" % matrix_rank(obsv_matrix))","f5e0ec2f":"# rank 6 means the system is controllable and observable\nA, B = get_a_b(M, m1, m2, l1, l2)\ncheck_ctrb_obsv(A, B, C=np.array([[1, 1, 1, 0, 0, 0]]))","57b558d7":"\"\"\"\n    Source: http:\/\/www.kostasalexis.com\/lqr-control.html\n\"\"\"\nimport scipy.linalg\n\ndef lqr(A, B, Q, R):\n    \"\"\"\n        Solve the continuous time lqr controller.\n        dx\/dt = A x + B u\n        cost = integral x.T*Q*x + u.T*R*u\n    \"\"\"\n    # ref Bertsekas, p.151\n    # first, try to solve the ricatti equation\n    X = np.array(scipy.linalg.solve_continuous_are(A, B, Q, R))\n    # compute the LQR gain\n    K = np.array(scipy.linalg.inv(R) @ (B.T @ X))\n    eigVals, eigVecs = scipy.linalg.eig(A - B @ K)\n    return K, X, eigVals","6545f0c5":"def get_lqr_gains(A, B, Q, R):\n    K, _, _ = lqr(A, B, Q, R)\n    return K\n\nQ = np.array([\n    [1000000., .0, .0, .0, .0, .0],\n    [.0, 1., .0, .0, .0, .0],\n    [.0, .0, 1., .0, .0, .0],\n    [.0, .0, .0, 1., .0, .0],\n    [.0, .0, .0, .0, 1., .0],\n    [.0, .0, .0, .0, .0, 1.],\n])\n\nR = np.array([[2000.]])\nA, B = get_a_b(M, m1, m2, l1, l2)\nK = get_lqr_gains(A, B, Q, R)","0737d95c":"disable_control_threshold = 3.0\n\n\ndef get_control(state, t):\n    \"\"\"\n    Returns control based on LQR gains and disables after time threshold\n    \"\"\"\n    x, dx, a, da, b, db = state\n    if t < disable_control_threshold:\n        _state = np.array([[x, a, b, dx, da, db]])\n        return (-K @ _state.T)[0, 0]\n    else:\n        return .0\n    \ndef derivatives(state, step, t_, dt_):\n    x, dx, a, da, b, db = state\n\n    u = get_control(state, t_)\n\n    dL_dx = 0.0\n    dL_da = -(m1 + m2) * l1 * da * dx * sin(a) + (m1 + m2) * g * l1 * sin(a) - m2 * l1 * l2 * da * db * sin(a - b)\n    dL_db = m2 * l2 * (g * sin(b) + l1 * da * db * sin(a - b) - dx * db * sin(b))\n\n    a11 = M + m1 + m2\n    a12 = (m1 + m2) * l1 * cos(a)\n    a13 = m2 * l2 * cos(b)\n    b1 = (m1 + m2) * l1 * da ** 2 * sin(a) + m2 * l2 * db ** 2 * sin(b)\n\n    a21 = (m1 + m2) * l1 * cos(a)\n    a22 = (m1 + m2) * l1 ** 2\n    a23 = m2 * l1 * l2 * cos(a - b)\n    b2 = (m1 + m2) * dx * da * l1 * sin(a) + m2 * l1 * l2 * db * (da - db) * sin(a - b)\n\n    a31 = m2 * l2 * cos(b)\n    a32 = m2 * l1 * l2 * cos(a - b)\n    a33 = m2 * l2 ** 2\n    b3 = m2 * dx * db * l2 * sin(b) + m2 * l1 * l2 * da * (da - db) * sin(a - b)\n\n    A = np.array([[a11, a12, a13], [a21, a22, a23], [a31, a32, a33]])\n    b_vec = np.array([b1 + dL_dx + u, b2 + dL_da, b3 + dL_db])\n    det_A = np.linalg.det(A)\n\n    Ax = np.copy(A)\n    Ax[:, 0] = b_vec\n    ddx = np.linalg.det(Ax) \/ det_A\n\n    Aa = np.copy(A)\n    Aa[:, 1] = b_vec\n    dda = np.linalg.det(Aa) \/ det_A\n\n    Ab = np.copy(A)\n    Ab[:, 2] = b_vec\n    ddb = np.linalg.det(Ab) \/ det_A\n    return [dx, ddx, da, dda, db, ddb]\n\ntimes = np.linspace(0, 6, 6000)\ndt = times[1] - times[0]\n\nsolution = solve(initial_state, times, integrate_rk4, derivatives)","3246ace8":"ani = render(solution)\n%time ani.save('controlled_dipc.gif', writer='imagemagick', fps=24)","beed67d8":"![](.\/controlled_dipc.gif)","d4d457cd":"### Deriving equations of motion\n\nThis step requires some manual work with pen and paper.\n\n$$\n\\begin{align*}\n&\\frac{d}{dt}\\frac{\\partial{L}}{\\partial{\\dot{x}}} = (M + m_1 + m_2)\\ddot{x} + l_1cos\\alpha(m_1 + m_2)\\ddot{\\alpha} + l_2m_2cos\\beta\\ddot{\\beta} - l_1sin\\alpha(m_1 + m_2)\\dot{\\alpha}^2 - l_2m_2sin\\beta\\dot{\\beta}^2,\\\\\n&\\frac{d}{dt}\\frac{\\partial{L}}{\\partial{\\dot{\\alpha}}} = l_1cos\\alpha(m_1 + m_2)\\ddot{x} + l_1^2(m_1 + m_2)\\ddot{\\alpha} + l_1l_2m_2cos(\\alpha-\\beta)\\ddot{\\beta} - l_1(m_1 + m_2)sin\\alpha\\dot{x}\\dot{\\alpha} - l_1l_2m_2sin(\\alpha-\\beta)\\dot{\\beta}(\\dot{\\alpha} - \\dot{\\beta}),\\\\\n&\\frac{d}{dt}\\frac{\\partial{L}}{\\partial{\\dot{\\beta}}} = l_2m_2cos\\beta\\ddot{x} + l_1l_2m_2cos(\\alpha-\\beta)\\ddot{\\alpha} + m_2l_2^2\\ddot{\\beta} - l_2m_2sin\\beta\\dot{x}\\dot{\\beta} - l_1l_2m_2sin(\\alpha-\\beta)\\dot{\\alpha}(\\dot{\\alpha} - \\dot{\\beta}),\\\\\n&\\frac{\\partial{L}}{\\partial{x}} = 0,\\\\\n&\\frac{\\partial{L}}{\\partial{\\alpha}} = (m_1 + m_2)l_1gsin\\alpha - (m_1 + m_2)l_1sin\\alpha\\dot{x}\\dot{\\alpha} - l_1l_2m_2sin(\\alpha-\\beta)\\dot{\\alpha}\\dot{\\beta},\\\\\n&\\frac{\\partial{L}}{\\partial{\\beta}} = m_2l_2gsin\\beta + l_1l_2m_2sin(\\alpha - \\beta)\\dot{\\alpha}\\dot{\\beta} - l_2m_2sin\\beta\\dot{x}\\dot{\\beta}\n\\end{align*}\n$$\n\nSolving the system of equations of motion of the free fall model in matrix form $A\\boldsymbol{\\dot{x}} = \\boldsymbol{b}$, where\n\n$$\n\\begin{align*}\n&A = \\begin{bmatrix}\nM + m_1 + m_2 & l_1(m_1 + m_2)cos\\alpha & l_2m_2cos\\beta\\\\\nl_1(m_1 + m_2)cos\\alpha & (m_1 + m_2)l_1^2 & l_1l_2m_2cos(\\alpha - \\beta)\\\\\nl_2m_2cos\\beta & l_1l_2m_2cos(\\alpha - \\beta) & m_2l_2^2\n\\end{bmatrix},\\\\\n&\\boldsymbol{b} = \\begin{bmatrix}\n(m_1 + m_2)l_1\\dot{\\alpha}^2sin\\alpha + m_2l_2\\dot{\\beta}^2sin\\beta + \\frac{\\partial{L}}{\\partial{x}}\\\\\n(m_1 + m_2)\\dot{x}\\dot{\\alpha}l_1sin\\alpha + m_2l_1l_2\\dot{\\beta}(\\dot{\\alpha} - \\dot{\\beta})sin(\\alpha - \\beta) + \\frac{\\partial{L}}{\\partial{\\alpha}}\\\\\nm_2\\dot{x}\\dot{\\beta}l_2sin\\beta + m_2l_1l_2\\dot{\\alpha}(\\dot{\\alpha} - \\dot{\\beta})sin(\\alpha - \\beta) + \\frac{\\partial{L}}{\\partial{\\beta}}\\\\\n\\end{bmatrix},\\\\\n&\\boldsymbol{x} = \\begin{bmatrix}\n\\dot{x}\\\\\n\\dot{\\alpha}\\\\\n\\dot{\\beta}\\\\\n\\end{bmatrix}\n\\end{align*}\n$$\n","aeeacaab":"## Equations of motion\n\nEquations of motion are derived from the Lagrangian: \n\n$$\\frac{d}{dt}\\frac{\\partial{L}}{\\partial{\\dot{q_i}}} - \\frac{\\partial{L}}{\\partial{q_i}} = f_i$$\n\nwhere $q_i = \\{x, \\alpha, \\beta\\}, f_i = \\{u, 0, 0\\}$,\n\n$$\n\\begin{align*}\n    &L = K - P,\\\\\n    &K = K_{cart} + K_{j1} + K_{j2},\\\\\n    &P = P_{cart} + P_{j1} + P_{j2}    \n\\end{align*}\n$$\n\n### Kinetic energy\n\n$$\n\\begin{align*}\n    &K_{cart} = \\frac{1}{2}M\\dot{x}^2,\\\\\n    &K_{j1} = \\frac{1}{2}m_1\\left[(\\dot{x} + l_1\\dot{\\alpha}cos\\alpha)^2 + (l_1\\dot{\\alpha}sin\\alpha)^2\\right],\\\\\n    &K_{j2} = \\frac{1}{2}m_2\\left[ (\\dot{x} + l_1\\dot{\\alpha}cos\\alpha + l_2\\dot{\\beta}cos\\beta)^2 + (l_1\\dot{\\alpha}sin\\alpha + l_2\\dot{\\beta}sin\\beta)^2 \\right]\n\\end{align*}\n$$\n\n### Potential energy\n\n$$\nP = m_1gl_1cos\\alpha + m_2g\\left(l_1cos\\alpha + l_2cos\\beta\\right)\n$$","b8289268":"![](.\/free_dipc.gif)","24848f7a":"# Stabilizing a double inverted pendulum on a cart\n\nThe notebook contains derivation of the equations of motion, simulation of the free model and stabilisation with a full state feedback controller.\n\n## Preview\n\n|      Free model      |      Controlled model      |\n|----------------------|----------------------------|\n| ![](.\/free_dipc.gif) | ![](.\/controlled_dipc.gif) |\n\n## Model\n\n![double-inverted-pendulum.png](attachment:096fa194-c5bd-41c6-8027-f288d7b5dedf.png)\n\nModel parameters:\n- M - mass of the cart\n- $m_1$ - mass of the first joint\n- $m_2$ - mass of the second joint\n- $l_1$ - length of the first joint\n- $l_2$ - length of the second joint\n\nState variables:\n\n- $x$ - position of the cart\n- ${\\alpha}$ - angle of the first joint\n- ${\\beta}$ - angle of the second joint\n\nAssumptions\n\n- the force $u$ acts upon the cart horizontally, $u = 0$ for free fall simulation\n- the model is frictionless","a8fbd1f8":"## References\n\n1. [Equations of motion](https:\/\/www3.math.tu-berlin.de\/Vorlesungen\/SoSe12\/Kontrolltheorie\/matlab\/inverted_pendulum.pdf)\n2. [Stability Control of Double Inverted Pendulum on a Cart using Full State](https:\/\/www.scienceopen.com\/hosted-document?doi=10.14293\/S2199-1006.1.SOR-.PP0CSDR.v1)\n3. [Source code](https:\/\/github.com\/zjor\/snippets\/tree\/master\/python\/ode_solver\/examples\/double_inverted_pendulum)","a1264ae0":"# Simulation of the free fall model","a681707d":"# Stabilizing the model\n\nLet's stabilize the system around the point of unstable equilibrium: $\\alpha = 0, \\beta = 0$, we'll also require $x = 0$. \n\nAssuming the angles are small we can linearize equations of motion around the balancing point. In addition, we can assume the following: \n$$\n\\begin{align*}\n\\alpha \\ll 1,\\beta \\ll 1,\\\\\n\\dot{\\alpha} \\ll 1, \\dot{\\beta} \\ll 1,\\\\\nsin\\alpha \\approx \\alpha, sin\\beta \\approx \\beta,\\\\\ncos\\alpha \\approx 1, cos\\beta \\approx 1,\n\\end{align*}\n$$\n\nLinearized system of equations will look as follows:\n\n$$\n\\begin{bmatrix}\nM + m_1 + m_2 & l_1(m_1 + m_2) & l_2m_2\\\\\nl_1(m_1 + m_2) & l_1^2(m_1 + m_2) & l_1l_2m_2\\\\\nl_2m_2 & l_1l_2m_2 & l_2^2m_2\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n\\ddot{x}\\\\\n\\ddot{\\alpha}\\\\\n\\ddot{\\beta}\n\\end{bmatrix} = \n\\begin{bmatrix}\nu\\\\\nl_1g(m_1+m_2)\\alpha\\\\\nm_2l_2g\\beta\n\\end{bmatrix}\n$$\n\nNext, we'll turn it into state-space representation $\\boldsymbol{\\dot{x}} = A\\boldsymbol{x} + B\\boldsymbol{u}$, check controllability and observability, and build an LQR controller.","6969eb5a":"## Building LQR regulator","19fc9bbd":"## State-space representation\n\nThe system is described by the state vector: $\\left[x \\, \\alpha \\, \\beta \\, \\dot{x} \\, \\dot{\\alpha} \\, \\dot{\\beta}\\right]$.\n\nBased on the article [2] matrices $A$ and $B$ can be calculated as follows: $A = M^{-1}N, B = M^{-1}F$, where\n\n$$\nM = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 0 & M + m_1 + m_2 & l_1(m_1 + m_2) & l_2m_2\\\\\n0 & 0 & 0 & l_1(m_1 + m_2) & l_1^2(m_1 + m_2) & l_1l_2m_2\\\\\n0 & 0 & 0 & l_2m_2 & l_1l_2m_2 & l_2^2m_2\n\\end{bmatrix},\nN = \\begin{bmatrix}\n0 & 0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 1 & 0\\\\\n0 & 0 & 0 & 0 & 0 & 1\\\\\n0 & 0 & 0 & 0 & 0 & 0\\\\\n0 & (m_1 + m_2)l_1g & 0 & 0 & 0 & 0\\\\\n0 & 0 & m_2l_2g & 0 & 0 & 0\\\\\n\\end{bmatrix},\nF = \\begin{bmatrix}\n0\\\\ 0\\\\ 0\\\\ 1\\\\ 0\\\\ 0\n\\end{bmatrix}\n$$"}}