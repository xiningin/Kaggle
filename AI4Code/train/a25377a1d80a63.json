{"cell_type":{"ba32ec5c":"code","a749f3e4":"code","29037143":"code","1256e0be":"code","e15f2f94":"code","045de9db":"code","1772367e":"code","bd2fad42":"code","520d60b1":"code","bde2121e":"code","705338f8":"code","105449bf":"code","aa01725e":"code","810016f9":"code","eef75264":"code","d1cdf819":"code","46da92c4":"code","8c0aaac9":"code","5a7df776":"code","f53754b7":"markdown","9011c23f":"markdown","db02be32":"markdown","ed808557":"markdown","ff2d7f8b":"markdown","b794bf6a":"markdown","fb83d0e6":"markdown","48813cc9":"markdown","fe552f06":"markdown","d8bb85d7":"markdown","d69716d7":"markdown","9fccad74":"markdown","8c4daecc":"markdown","2d80bc4a":"markdown","1c13f4a7":"markdown","42399903":"markdown","993669d9":"markdown","46513b6b":"markdown","cbd12f27":"markdown","81194b4e":"markdown","71b0d7ca":"markdown","4f3e760d":"markdown","713fb2c0":"markdown","9829d4dd":"markdown","954bb710":"markdown","9bfa89d6":"markdown","3c15f81d":"markdown","e41e73f2":"markdown","cc0d1c36":"markdown","ec84d5b3":"markdown","2e3dce36":"markdown"},"source":{"ba32ec5c":"import pandas as pd\nimport numpy as np\nimport plotly\nimport plotly.graph_objs as go\n\nplotly.offline.init_notebook_mode(connected=True)\n\n# source\napps = pd.read_csv('..\/input\/apps.csv')\ncategories = pd.read_csv('..\/input\/categories.csv')\nreviews = pd.read_csv('..\/input\/reviews.csv')","a749f3e4":"apps.head()","29037143":"categories.head()","1256e0be":"reviews.head()","e15f2f94":"categories['category_id'] = categories['category'].factorize()[0]","045de9db":"apps_and_reviews = pd.merge(apps, reviews, how='right', left_on='url', right_on='app_url')\napps_with_categories = pd.merge(apps, categories, how='right', left_on='url', right_on='app_url')\napps_and_reviews_with_categories = pd.merge(apps_and_reviews, categories, how='right', left_on='app_url', right_on='app_url')","1772367e":"reviews_count_check = pd.merge(\n    apps[['url', 'reviews_count']], \n    reviews.groupby(['app_url']).size().reset_index(name='reviews_available_count'), \n    how='left', left_on='url', right_on='app_url')\n\nreviews_count_check[['reviews_available_count']] = reviews_count_check[['reviews_available_count']].fillna(value=0)\nreviews_count_check['diff'] = reviews_count_check['reviews_available_count'] - reviews_count_check['reviews_count']\nreviews_count_check.loc[reviews_count_check['diff'] != 0].drop_duplicates(subset=['url'])","bd2fad42":"import holoviews as hv\n\nhv.extension('bokeh')\n%output size=250\n\ncategory_id_df = apps_with_categories[['category', 'category_id']].drop_duplicates().sort_values('category_id')\ncategory_to_id = dict(category_id_df.values)\n\nresults = pd.DataFrame()\n\nfor cat in categories['category'].unique():\n    app_urls = categories[categories['category'] == cat]['app_url'].values\n    category_connections = categories[(categories['app_url'].isin(app_urls)) & (categories['category'] != cat)]\\\n        .groupby(['category']) \\\n        .size() \\\n        .reset_index(name='connections')\n    category_connections['from'] = cat\n    category_connections['to'] = category_connections['category']\n    \n    category_connections['source']=category_connections['from'].map(category_to_id)\n    category_connections['target']=category_connections['to'].map(category_to_id)\n    category_connections['value']=category_connections['connections']\n    \n    results = pd.concat([results, category_connections[['source', 'target', 'value']]])\n\nsource = results[['source', 'target']].min(axis=1)\ntarget = results[['source', 'target']].max(axis=1)\nresults['source'] = source\nresults['target'] = target\nresults = results.drop_duplicates(subset=['source', 'target'])\n\nnodes_data = categories[['category']].drop_duplicates()\nnodes_data['index'] = categories['category'].map(category_to_id)\n\nnodes = hv.Dataset(nodes_data, 'index')\n\n%opts Chord [label_index='category' color_index='index' edge_color_index='source'] \n\nhv.Chord((results, nodes))","520d60b1":"apps_per_category = apps_with_categories\\\n    .groupby(['category']) \\\n    .size() \\\n    .reset_index(name='apps_count') \\\n    .sort_values('apps_count', ascending=False)\n\nplotly.offline.iplot({\n    'data': [go.Pie(labels=apps_per_category['category'], values=apps_per_category['apps_count'])],\n    'layout': go.Layout(title='Apps per category')\n})","bde2121e":"apps_and_reviews_grouped_by_category = apps_and_reviews_with_categories\\\n    .groupby(['category']) \\\n    .size() \\\n    .reset_index(name='reviews') \\\n    .sort_values('reviews', ascending=False)\n\nplotly.offline.iplot({\n    'data': [go.Pie(labels=apps_and_reviews_grouped_by_category['category'], values=apps_and_reviews_grouped_by_category['reviews'])],\n    'layout': go.Layout(title='Reviews per category')\n})","705338f8":"apps_and_reviews_grouped_by_app_title = apps_and_reviews \\\n    .groupby(['title']) \\\n    .size() \\\n    .reset_index(name='reviews') \\\n    .sort_values('reviews', ascending=False)\n\nlimit = 15\nplotly.offline.iplot({\n    'data': [go.Bar(\n        name='Reviews',\n        x=apps_and_reviews_grouped_by_app_title.head(limit)['title'],\n        y=apps_and_reviews_grouped_by_app_title.head(limit)['reviews']\n    )],\n    'layout': go.Layout(title='Apps ordered by number of reviews', margin=go.layout.Margin(b=200))\n})","105449bf":"reviews_in_category = (apps_and_reviews_with_categories.groupby(['category', 'title'], as_index=False)['rating_x'].mean())\\\n    .dropna(subset=['rating_x'])\\\n    .groupby(['category'], as_index=False)\\\n    .mean()\\\n    .sort_values('rating_x', ascending=True)\nreviews_in_category[['mean_rating']] = reviews_in_category[['rating_x']]\nreviews_in_category = reviews_in_category.drop(columns=['rating_x'])\n\nplotly.offline.iplot({\n    'data': [go.Bar(\n        name='Rating',\n        x=reviews_in_category['mean_rating'],\n        y=reviews_in_category['category'],\n        orientation = 'h'\n    )],\n    'layout': go.Layout(title='Average rating per category', margin=go.layout.Margin(l=250))\n})","aa01725e":"each_rating_count_in_category = pd.DataFrame({\n    'category': apps_and_reviews_with_categories['category'].unique(),\n    'r_count': [\n        apps_and_reviews_with_categories.loc[apps_and_reviews_with_categories['category'] == cat].shape[0]\n        for cat in apps_and_reviews_with_categories['category'].unique()],\n    'r_1_count': [\n        apps_and_reviews_with_categories.loc[(apps_and_reviews_with_categories['rating_y'] == 1.0) & (apps_and_reviews_with_categories['category'] == cat)].shape[0]\n        for cat in apps_and_reviews_with_categories['category'].unique()],\n    'r_2_count': [\n        apps_and_reviews_with_categories.loc[(apps_and_reviews_with_categories['rating_y'] == 2.0) & (apps_and_reviews_with_categories['category'] == cat)].shape[0]\n        for cat in apps_and_reviews_with_categories['category'].unique()],\n    'r_3_count': [\n        apps_and_reviews_with_categories.loc[(apps_and_reviews_with_categories['rating_y'] == 3.0) & (apps_and_reviews_with_categories['category'] == cat)].shape[0]\n        for cat in apps_and_reviews_with_categories['category'].unique()],\n    'r_4_count': [\n        apps_and_reviews_with_categories.loc[(apps_and_reviews_with_categories['rating_y'] == 4.0) & (apps_and_reviews_with_categories['category'] == cat)].shape[0]\n        for cat in apps_and_reviews_with_categories['category'].unique()],\n    'r_5_count': [\n        apps_and_reviews_with_categories.loc[(apps_and_reviews_with_categories['rating_y'] == 5.0) & (apps_and_reviews_with_categories['category'] == cat)].shape[0]\n        for cat in apps_and_reviews_with_categories['category'].unique()],\n})\neach_rating_count_in_category = each_rating_count_in_category.loc[each_rating_count_in_category.category.notna()]\n\ngroups = ['r_1_count', 'r_2_count', 'r_3_count', 'r_4_count', 'r_5_count']\ntraces = []\nx_axis_lables = ['Share of 1 star ratings', 'Share of 2 star ratings', 'Share of 3 star ratings', 'Share of 4 star ratings', 'Share of 5 star ratings']\n\nfor idx, row in each_rating_count_in_category.iterrows():\n    traces.append(go.Bar(\n        x=x_axis_lables,\n        y=list((row[groups] \/ row['r_count'])),\n        name=row['category']\n    ))\n\nlayout = go.Layout(\n    title='Share of reviews per rating per category',\n    yaxis = dict(\n        tickformat='.2%'\n    )\n)\n\nplotly.offline.iplot(go.Figure(data=traces, layout=layout))\n\neach_rating_count_in_category","810016f9":"from plotly import tools\n\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.feature_selection import chi2\nfrom sklearn.cluster import KMeans\nfrom sklearn.decomposition import PCA\nfrom sklearn.manifold import TSNE\n\napps_with_categories['normalized_description'] = (apps_with_categories['description'].map(str) + apps_with_categories['pricing'])\n\ncategory_id_df = apps_with_categories[['category', 'category_id']].drop_duplicates().sort_values('category_id')\ncategory_to_id = dict(category_id_df.values)\nid_to_category = dict(category_id_df[['category_id', 'category']].values)\n\ntfidf = TfidfVectorizer(sublinear_tf=True, min_df=2, norm='l2', ngram_range=(2, 5), stop_words='english')\nfeatures = tfidf.fit_transform(apps_with_categories['normalized_description']).toarray()\nlabels = apps_with_categories['category_id']\n\nN = 15\nfig = tools.make_subplots(rows=6, cols=2, \n                          shared_yaxes=False, shared_xaxes=False,\n                          horizontal_spacing=0.5, print_grid=False, \n                          subplot_titles=[\"'{0}' term scores\".format(entry[0]) for entry in category_to_id.items()])\n\nfor category, category_id in sorted(category_to_id.items()):\n    features_chi2 = chi2(features, labels == category_id)\n    indices = np.argsort(features_chi2[0])    \n    feature_names = np.array(tfidf.get_feature_names())[indices]\n    scores = features_chi2[0][indices]\n\n    category_significant_terms = pd.DataFrame({'term': feature_names, 'score': scores})\\\n        .sort_values('score', ascending=True)\\\n        .tail(N)\n\n    row = int(category_id \/ 2) + 1\n    col = 1 if (category_id % 2 == 0) else 2\n    bar_chart = go.Bar(\n        name=category, \n        x=category_significant_terms['score'], \n        y=category_significant_terms['term'], \n        orientation='h'\n    )\n    fig.append_trace(bar_chart, row, col)\n\n    \nfig['layout'].update(title='Category terms', \n                     height=1024, width=1024, \n                     margin=go.layout.Margin(l=225, r=225), showlegend=False)\nplotly.offline.iplot(fig)","eef75264":"reviews_with_low_ratings = pd.DataFrame()\nfor category in apps_and_reviews_with_categories['category'].dropna().unique():\n    reviews_in_category = apps_and_reviews_with_categories[apps_and_reviews_with_categories['category'] == category]\n    reviews_with_rating_lower_than_app_rating = reviews_in_category[(reviews_in_category['rating_y'] < reviews_in_category['rating_x']) & \\\n                                                        (reviews_in_category['reviews_count'] > 0)]\n    reviews_with_low_ratings = pd.concat([reviews_with_low_ratings, reviews_with_rating_lower_than_app_rating])\nreviews_with_low_ratings.head()","d1cdf819":"from plotly import tools\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.feature_selection import chi2\nfrom sklearn.cluster import KMeans\nfrom sklearn.decomposition import PCA\nfrom sklearn.manifold import TSNE\n\nfrom vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer\nanalyser = SentimentIntensityAnalyzer()\n\nreviews_with_low_ratings = reviews_with_low_ratings.dropna(subset=['body'])\nreviews_with_low_ratings['negative_prob'] = reviews_with_low_ratings['body'].apply(lambda body: analyser.polarity_scores(body)[\"neg\"])\nnegative_reviews_with_low_rating = reviews_with_low_ratings[reviews_with_low_ratings['negative_prob'] >= 0.5]\n\ncategory_id_df = negative_reviews_with_low_rating[['category', 'category_id']].drop_duplicates().sort_values('category_id')\ncategory_to_id = dict(category_id_df.values)\nid_to_category = dict(category_id_df[['category_id', 'category']].values)\n\ntfidf = TfidfVectorizer(sublinear_tf=True, \n                        min_df=3, \n                        norm='l2',\n                        ngram_range=(2, 5), \n                        stop_words='english')\n\nfeatures = tfidf.fit_transform(negative_reviews_with_low_rating['body']).toarray()\nlabels = negative_reviews_with_low_rating['category_id']\n\nN = 15\nfig = tools.make_subplots(rows=6, cols=2, \n                          shared_yaxes=False, shared_xaxes=False,\n                          horizontal_spacing=0.5, print_grid=False, \n                          subplot_titles=[\"'{0}' term scores\".format(entry[0]) for entry in category_to_id.items()])\n\ncharts = []\n\nfor category, category_id in sorted(category_to_id.items()):\n    features_chi2 = chi2(features, labels == category_id)\n    indices = np.argsort(features_chi2[0])    \n    feature_names = np.array(tfidf.get_feature_names())[indices]\n    scores = features_chi2[0][indices]\n\n    category_significant_terms = pd.DataFrame({'term': feature_names, 'score': scores})\\\n        .sort_values('score', ascending=True)\\\n        .tail(N)\n\n    if category_significant_terms.shape[0] == 0:\n        next\n\n    bar_chart = go.Bar(\n        name=category, \n        x=category_significant_terms['score'], \n        y=category_significant_terms['term'], \n        orientation='h'\n    )\n    charts.append(bar_chart)\n\nfor number, chart in enumerate(charts):\n    row = int(number \/ 2) + 1\n    col = 1 if (number % 2 == 0) else 2\n    fig.append_trace(chart, row, col)\n    \nfig['layout'].update(title='Terms of low rating reviews', \n                     height=1024, width=1024, \n                     margin=go.layout.Margin(l=225, r=225), showlegend=False)\nplotly.offline.iplot(fig)","46da92c4":"limit = 15\n\napps_per_developer = apps\\\n    .groupby(['developer']) \\\n    .size() \\\n    .reset_index(name='apps_count') \\\n    .sort_values('apps_count', ascending=False)\n\nplotly.offline.iplot({\n    'data': [go.Bar(\n            name='Summary rating',\n            x=apps_per_developer.head(limit)['developer'],\n            y=apps_per_developer.head(limit)['apps_count']\n    )],\n    'layout': go.Layout(title='Developers ordered by the number of apps', margin=go.layout.Margin(b=100))\n})","8c0aaac9":"limit = 15\n\napps_and_reviews_grouped_by_developer = apps_and_reviews \\\n    .groupby(['developer']) \\\n    .agg({'rating_y': ['size', 'mean', 'sum']}) \\\n    .reset_index() \\\n    .sort_values(('rating_y', 'sum'), ascending=False)\n\n\nplotly.offline.iplot({\n    'data': [go.Bar(\n            name='Summary rating',\n            x=apps_and_reviews_grouped_by_developer.head(limit)['developer'],\n            y=apps_and_reviews_grouped_by_developer.head(limit)[('rating_y', 'sum')]\n    ),go.Bar(\n            name='Reviews',\n            x=apps_and_reviews_grouped_by_developer.head(limit)['developer'],\n            y=apps_and_reviews_grouped_by_developer.head(limit)[('rating_y', 'size')]\n    ),go.Scatter(\n            name='Rating',\n            x=apps_and_reviews_grouped_by_developer.head(limit)['developer'],\n            y=apps_and_reviews_grouped_by_developer.head(limit)[('rating_y', 'mean')],\n            yaxis='y2'\n    )],\n    'layout': go.Layout(\n        title='Developers with the highest summary rating',\n        legend=dict(x=1.25, y=1),\n        barmode='group',\n        yaxis2=dict(\n            overlaying='y',\n            anchor='x',\n            side='right'\n        )\n    )\n})\n","5a7df776":"apps_with_rating_scores = apps_with_categories[(apps_with_categories['reviews_count'] > 0)].copy()\napps_with_rating_scores['rating_mult_by_reviews'] = apps_with_rating_scores['rating'] * apps_with_rating_scores['reviews_count']\n\napps_with_highest_score = apps_with_rating_scores\\\n    .loc[apps_with_rating_scores.groupby(['category'])['rating_mult_by_reviews'].idxmax()]\n\napps_with_highest_score[['category', 'app_url', 'title', 'rating', 'reviews_count']]","f53754b7":"Each app belongs to at least one category. The chord graph shows the intersection of the existing 12 categories.","9011c23f":"Which category has the highest number of apps ?","db02be32":"It looks like customers are less satisfied with tools from 'Places to sell' category.","ed808557":"# Shopify App Store overview","ff2d7f8b":"- 'Store design' category (29%) includes more than 1.5 times more apps than closest 'Sales and conversion optimization' category (17.5%)\n- The 'Sales and conversion optimization' and 'Marketing' categories are close","b794bf6a":"## Supply and demand","fb83d0e6":"## Developers","48813cc9":"Shopify is a complete commerce platform that lets clients start, grow, and manage a business. The company reported that it had more than **600,000 merchants** using its platform as of August 2017, with total gross merchandise volume exceeding **$82 billion**.\n\nThat is one of the main causes why more and more developers choose the Shopify platform and the Shopify apps marketplace as the next app store for their products.\n\nThis notebook is an attempt to describe the Shopify app store. What kind of apps are the most popular? What shop owners are looking for? What apps provide and what they fail to deliver? \nAll these questions are explained in the following blocks.","fe552f06":"The **'Places to sell'** category has the largest share of 1 star reviews and the smallest share of 5 star reviews. It fits with the previous assumption that users are least satisfied with apps from **'Places to sell'** category.","d8bb85d7":"This chart shows that **'Store design'**, **'Sales and conversion optimization'** and **'Marketing'** categories have intersection. **'Reporting'** category has lower number of connections with that group but has more connections that other groups.","d69716d7":"On the next chart you can see the word combinations that appears on the reviews with low rating. Users complain about those things so they can be used as a proxy to 'what app fail to deliver'.","9fccad74":"On the next chart you can see the word combinations that appears on the apps description most frequently. Developers write down those qualities so they can be used as a proxy to 'functionality\/features the app provides'.","8c4daecc":"Let's try to understand what people in reviews are complaining about. Poor quality app might be an opportunity for the new app that solves the same problem better.","2d80bc4a":"## Shopify apps marketplace breakdown","1c13f4a7":"- Nothing surprises here, the same top 3 categories\n- The distribution is proportional to apps per category numbers","42399903":"The categories from the source dataset do not have the ids, the `category_id` column might be usefull for joining\/grouping tables.","993669d9":"The 2 patterns can be seen between the developers from the cart:\n- Developer has multiple highly rated apps (most of the developers follow this pattern)\n- Developer has only one but incredibly successfull app\n\n\nOnly **3** ([BOLD](https:\/\/apps.shopify.com\/partners\/bold), [SpurIT](https:\/\/apps.shopify.com\/partners\/spurit), [Booster Apps]()) devs from first chart managed to get into **'Top 15'**.","46513b6b":"Prepare Dataframes with joined data","cbd12f27":"### Feedback","81194b4e":"## Data preprocessing","71b0d7ca":"These charts show that terrible customer support, constant error screens and 'app simply does not work' are the main complaints across all categories.","4f3e760d":"This part describes the marketplace from developers & reviewers point of view.","713fb2c0":"Another interesting thing to investigate is the connection between category and rating. How app rating is distributed between categories, which category has the lowest\/highest average rating.","9829d4dd":"### Category leaderboards\n\nThe next table displays the category leaders for each of 12 categories.","954bb710":"## Conclusion\n\n### Observations\n\n- It looks like the 'bad support' is the most frequent problem that users deal with. Maybe it can be handled on the markeplace level by providing links to forum. Specific threads for apps on [Discussion Forums](https:\/\/ecommerce.shopify.com\/forums) might improve experience of those users.\n- The apps from 'Places to sell' category are the most downvoted. It also looks like it may happen because of high expectations of the users. After analyzing the reviews it can be seen that many users don't even know what they want from apps.\n- The 'Store design', 'Sales and conversion optimization' and 'Marketing' are categories with the biggest amount of apps","9bfa89d6":"### Category connections","3c15f81d":"#### Validation\n\nSmall ammount of apps (**22**) have reviews which were published and included in the reviews count but are not available on the marketplace. This is small part of overal number (< 0.8%) so it doesn't have big impact on category statistics.","e41e73f2":"The developer with the biggest number of published apps is the **\"Webkup Software Pvt Ltd\"**.\n\nBut the number of apps is not the same as the quality of apps. The top 15 developers (by sum of ratings of all their apps) can be seen on the next chart .","cc0d1c36":"---","ec84d5b3":"Which category has the highest number of reviews ?","2e3dce36":"## Dataset import"}}