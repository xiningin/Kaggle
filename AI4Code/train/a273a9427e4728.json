{"cell_type":{"d5c8a889":"code","ead49799":"code","453c3261":"code","de1956db":"code","52f85376":"code","aa1daddc":"code","12e4a6d8":"code","af2d4563":"code","dc308504":"code","be0ec579":"code","02a37185":"code","1507e39c":"code","64f0984b":"code","519bf729":"code","05d63401":"code","be9f6541":"code","392bedbe":"code","8092be5d":"markdown","ac00ac2d":"markdown","11942287":"markdown","7ae300b0":"markdown","d6471eec":"markdown","8b01ca76":"markdown","858fedce":"markdown","99215411":"markdown","51b4d3bf":"markdown","15845c0d":"markdown","5b6b827e":"markdown","ed66b135":"markdown","b0c59a52":"markdown","9475bdd3":"markdown","345a4522":"markdown","fd8fc460":"markdown","b864f3a6":"markdown","0b34e906":"markdown","4c1a1f8d":"markdown","482de455":"markdown","7f95907d":"markdown","b3071f3d":"markdown","ef685de9":"markdown","ab848084":"markdown","175c3ffc":"markdown","f90080c1":"markdown"},"source":{"d5c8a889":"!pip install yfinance --quiet\n!pip install pmdarima --quiet","ead49799":"!pip install statsmodels==0.11.0rc1 --quiet\n!pip install -Iv pulp==1.6.8 --quiet","453c3261":"import yfinance as yf\n\n# getting data from Yahoo Finance\nstock_name = 'AMD'  # here you can change the name of stock ticker, for example we will take AMD ticker\ndata = yf.download(stock_name, start=\"2020-03-26\", end=\"2021-03-29\")","de1956db":"# import plotly package for graphs\nimport plotly\nimport plotly.graph_objs as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots","52f85376":"from sklearn.preprocessing import MinMaxScaler\nimport math\nimport matplotlib.pyplot as plt\nimport keras\nimport pandas as pd\nimport numpy as np\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\nfrom keras.layers import Dropout\nfrom keras.layers import *\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.model_selection import train_test_split\nfrom keras.callbacks import EarlyStopping\nfrom keras.models import Sequential\nfrom keras.layers import Dense, LSTM\n\ndef lstm(stock_name, data):\n    # Choose only Close price of stock\n    data = data.filter(['Close'])\n    dataset = data.values\n    # Train data - 80%, test - 20%\n    training_data_len = int(np.ceil( len(dataset) * .80 ))\n    \n    # Scale our data from 0 to 1\n    scaler = MinMaxScaler(feature_range=(0,1))\n    scaled_data = scaler.fit_transform(dataset)\n    \n    # Use our scaled data for training\n    train_data = scaled_data[0:int(training_data_len), :]\n    x_train = []\n    y_train = []\n\n    for i in range(60, len(train_data)):\n        x_train.append(train_data[i-60:i, 0])\n        y_train.append(train_data[i, 0])\n        if i<= 61:\n            print(x_train)\n            print(y_train)\n            print()\n\n    x_train, y_train = np.array(x_train), np.array(y_train)\n\n    x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))\n    \n    # Build LSTM model\n    model = Sequential()\n    model.add(LSTM(128, return_sequences=True, input_shape = (x_train.shape[1], 1)))\n    model.add(Dropout(0.35))\n    model.add(LSTM(64, return_sequences=False))\n    model.add(Dropout(0.3))\n    model.add(Dense(25, activation = 'relu'))\n    model.add(Dense(1))\n    \n    # Compile the model\n    model.compile(optimizer='adam', loss='mean_squared_error', metrics=['accuracy'])\n\n    # \u0422rain the model\n    model.fit(x_train, y_train, batch_size=1, epochs=21)\n    \n    # Structure of the model\n    keras.utils.plot_model(model, 'multi_input_and_output_model.png', show_shapes=True)\n\n    # Create test dataset\n    test_data = scaled_data[training_data_len - 60: , :]\n    x_test = []\n    y_test = dataset[training_data_len:, :]\n    for i in range(60, len(test_data)):\n        x_test.append(test_data[i-60:i, 0])\n\n    x_test = np.array(x_test)\n\n    x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1 ))\n\n    # Predict on test data\n    predictions = model.predict(x_test)\n    predictions = scaler.inverse_transform(predictions)\n\n    # For finding error we use RMSE formula, but MSE can be used too\n    rmse = np.sqrt(np.mean(((predictions - y_test) ** 2)))\n    print(f'RMSE LSTM: {rmse}')\n    \n    # Graphs\n    train = data[:training_data_len]\n    valid = data[training_data_len:]\n    #valid['Predictions'] = predictions\n    train_gr = np.reshape(train, (203,))\n    train_gr = train_gr['Close']\n    valid_gr = np.reshape(valid, (50,))\n    valid_gr = valid_gr['Close']\n    preds_gr = np.reshape(predictions, (50,))\n    \n\n    x_train = list(range(0, len(train_data)))\n    x_valid = list(range(len(train_data)-1, len(dataset)))\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=x_train, y=train_gr, mode='lines+markers', marker=dict(size=4),  name='train', marker_color='#39304A'))\n    fig.add_trace(go.Scatter(x=x_valid, y=valid_gr, mode='lines+markers', marker=dict(size=4), name='valid', marker_color='#A98D75'))\n    fig.add_trace(go.Scatter(x=x_valid, y=preds_gr, mode='lines+markers', marker=dict(size=4), name='predictions', marker_color='#FFAA00'))\n    fig.update_layout(legend_orientation=\"h\",\n                  legend=dict(x=.5, xanchor=\"center\"),\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'),    \n                  title_text = f'{stock_name} LSTM data', title_x = 0.5,\n                  xaxis_title=\"Timestep\",\n                  yaxis_title=\"Stock price\",\n                  margin=dict(l=0, r=0, t=30, b=0))\n    fig.show()\n    \n    # Predict stock prices for next moth\n    data_new = yf.download(stock_name, start=\"2021-03-01\", end=\"2021-04-30\")\n\n    data_new = data_new.filter(['Close'])\n    dataset = data_new.values\n    training_data_len = len(dataset)\n\n    scaler = MinMaxScaler(feature_range=(0,1))\n    scaled_data = scaler.fit_transform(dataset)\n\n    test_data = scaled_data[training_data_len - len(data_new): , :]\n    x_test = []\n    y_test = dataset[training_data_len:, :]\n    for i in range(20, len(test_data)):\n        x_test.append(test_data[i-20:i, 0])\n\n    x_test = np.array(x_test)\n\n    x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1 ))\n\n    hist_data_new = yf.download(stock_name, start=\"2021-04-01\", end=\"2021-05-04\")\n    hist_data_new = hist_data_new.drop(['Open', 'High', 'Low', 'Adj Close', 'Volume'], axis=1)\n    hist_data_new = hist_data_new['Close']\n    hist_data_new = np.array(hist_data_new)\n    pred_lstm = model.predict(x_test)\n    pred_lstm = pred_lstm[:-1]\n    pred_lstm = scaler.inverse_transform(pred_lstm)\n\n    \n    # build graphs\n    preds_gr = np.reshape(pred_lstm, (22,))\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=list(range(0, 21)), y=hist_data_new, mode='lines+markers',  name='historical', marker_color='#39304A'))\n    fig.add_trace(go.Scatter(x=list(range(0, 21)), y=preds_gr, mode='lines+markers', name='predictions', marker_color='#FFAA00'))\n    fig.update_layout(legend_orientation=\"h\",\n                  legend=dict(x=.5, xanchor=\"center\"),\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'),    \n                  title_text = f'{stock_name} LSTM prediction', title_x = 0.5,\n                  xaxis_title=\"Timestep\",\n                  yaxis_title=\"Stock price\",\n                  margin=dict(l=0, r=0, t=30, b=0))\n    fig.show()\n    \n    return pred_lstm, rmse","aa1daddc":"lstm_pred, lstm_rmse = lstm(stock_name, data)","12e4a6d8":"# Check size of predictions array\nprint(lstm_pred.shape)","af2d4563":"data_adf = data.drop(['Open', 'High', 'Low', 'Adj Close', 'Volume'], axis=1)\ndata_adf = data_adf['Close']\n\nfrom pmdarima.arima import ADFTest\nadf_test = ADFTest(alpha = 0.05)\nadf_test.should_diff(data_adf)","dc308504":"import os\nimport warnings\nwarnings.filterwarnings('ignore')\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport pmdarima as pm\nplt.style.use('fivethirtyeight')\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 10, 6\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom pmdarima.arima import ADFTest\nfrom pmdarima.datasets import load_wineind\nimport random\n\ndef arima(stock_name, data):\n    df_close = data['Close']\n    \n    # Split data into train and test set (90% - train, 10% - test)\n    df_log = df_close\n    #train_data, test_data = df_log[3:int(len(df_log) * 0.9)], df_log[int(len(df_log) * 0.9):]\n    train_data, test_data = df_log[3:int(len(df_log) * 0.9)], df_log[int(len(df_log) * 0.9):]\n    test_values = len(df_log) * 0.01 + 1.0\n    x_train = list(range(0, 224))\n    x_test = list(range(224, int(len(data))))\n    \n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=x_train, y=train_data, mode='lines+markers', marker=dict(size=4),  name='train', marker_color='#39304A'))\n    fig.add_trace(go.Scatter(x=x_test, y=test_data, mode='lines+markers', marker=dict(size=4), name='test', marker_color='#A98D75'))\n    fig.update_layout(legend_orientation=\"h\",\n                  legend=dict(x=.5, xanchor=\"center\"),\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'),\n                  title_text = f'{stock_name} ARIMA data', title_x = 0.5,\n                  xaxis_title=\"Timestep\",\n                  yaxis_title=\"Stock price\",\n                  margin=dict(l=0, r=0, t=30, b=0))\n    fig.show()\n    \n    model =  pm.auto_arima(df_log,start_p=0, d=None, start_q=0, \n                          max_p=5, max_d=5, max_q=5, start_P=0, \n                          D=1, start_Q=0, max_P=5, max_D=5,\n                          max_Q=5, m=7, seasonal=True, \n                          error_action='warn',trace = True,\n                          supress_warnings=True,stepwise = True,\n                          random_state=20,n_fits = 50 )\n\n    model.summary()\n\n    exo_data = data['Volume']\n    exo_data = exo_data[int(len(exo_data) * 0.9):]\n    \n    preds = model.predict(n_periods = 22, X = exo_data)\n\n    preds = np.vstack(preds)\n    hist_data = yf.download(stock_name, start=\"2021-04-01\", end=\"2021-05-04\")\n    hist_data = hist_data.drop(['Open', 'High', 'Low', 'Adj Close', 'Volume'], axis=1)\n    hist_data = hist_data['Close']\n    hist_data = np.array(hist_data)\n    \n    rmse = np.sqrt(np.mean(((preds - hist_data) ** 2)))\n    print(f'RMSE ARIMA: {rmse}')\n    \n    # build graphs\n    preds_gr = np.reshape(preds, (22,))\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=list(range(0, 21)), y=hist_data, mode='lines+markers',  name='historical', marker_color='#39304A'))\n    fig.add_trace(go.Scatter(x=list(range(0, 21)), y=preds_gr, mode='lines+markers', name='predictions', marker_color='#FFAA00'))\n    fig.update_layout(legend_orientation=\"h\",\n                  legend=dict(x=.5, xanchor=\"center\"),\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'),\n                  title_text = f'{stock_name} ARIMA prediction', title_x = 0.5,\n                  xaxis_title=\"Timestep\",\n                  yaxis_title=\"Stock price\",\n                  margin=dict(l=0, r=0, t=30, b=0))\n    fig.show()\n\n    return preds, rmse","be0ec579":"arima_pred, arima_rmse = arima(stock_name, data)\nprint(arima_pred.shape)","02a37185":"from statsmodels.tsa.statespace.sarimax import SARIMAX\ndata3 = data['Close']\n    \n# Split data into train and test set (90% - train, 10% - test)\ntrain3_data, test3_data = data3[3:int(len(data3) * 0.9)], data3[int(len(data3) * 0.9):]\n#test_values = len(data3) * 0.01 + 1.0\nx_train = list(range(0, 224))\nx_test = list(range(224, int(len(data3))))\n\nexo_data = data['Volume']\nexo_data = exo_data[int(len(exo_data) * 0.9):]\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=x_train, y=train3_data, mode='lines+markers', marker=dict(size=4),  name='train', marker_color='#39304A'))\nfig.add_trace(go.Scatter(x=x_test, y=test3_data, mode='lines+markers', marker=dict(size=4), name='test', marker_color='#A98D75'))\nfig.update_layout(legend_orientation=\"h\",\n                  legend=dict(x=.5, xanchor=\"center\"),\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'),\n                  title_text = f'{stock_name} SARIMAX data', title_x = 0.5,\n                  xaxis_title=\"Timestep\",\n                  yaxis_title=\"Stock price\",\n                  margin=dict(l=0, r=0, t=30, b=0))\nfig.show()\n    \nmodel = SARIMAX(train3_data, order=(3, 1, 2))\n\narima_model = model.fit(X = exo_data, disp=-1)\n\nprint(arima_model.summary())\n\n\npreds3 = arima_model.predict(n_periods=22, alpha=0.05)\n\npreds3 = np.vstack(preds3)\npreds3 = preds3[-22:]\nhist_data = yf.download(stock_name, start=\"2021-04-01\", end=\"2021-05-04\")\nhist_data = hist_data.drop(['Open', 'High', 'Low', 'Adj Close', 'Volume'], axis=1)\nhist_data = hist_data['Close']\nhist_data = np.array(hist_data)\n    \nrmse = np.sqrt(np.mean(((preds3 - hist_data) ** 2)))\nprint(f'RMSE SARIMAX: {rmse}')\n    \npreds_gr = np.reshape(preds3, (22,))\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=hist_data, mode='lines+markers', name='historical', marker_color='#39304A'))\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=preds_gr, mode='lines+markers', name='predictions', marker_color='#FFAA00'))\nfig.update_layout(legend_orientation=\"h\",\n                  legend=dict(x=.5, xanchor=\"center\"),\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'),\n                  title_text = f'{stock_name} SARIMAX prediction', title_x = 0.5,\n                  xaxis_title=\"Timestep\",\n                  yaxis_title=\"Stock price\",\n                  margin=dict(l=0, r=0, t=30, b=0))\nfig.show()","1507e39c":"import math\ndata4 = yf.download(stock_name, start=\"2020-03-26\", end=\"2021-03-29\")\ncols = ['Open', 'High', 'Low', 'Close', 'Volume']\ndata4 = data4.drop(['Adj Close'], axis=1)\n\n# Train set - 80%\ntrain4 = data4[:int(0.8*(len(data)))]\nvalid4 = data4[int(0.8*(len(data))):]\n\n#fit the model\nfrom statsmodels.tsa.vector_ar.var_model import VAR\n\nmodel4 = VAR(endog=train4)\nmodel4_fit = model4.fit(trend = 'ctt')\n\n# make prediction on validation\nprediction = model4_fit.forecast(model4_fit.y, steps=len(valid4))\npred4 = pd.DataFrame(index=range(0,len(prediction)),columns=[cols])\nfor j in range(0,5):\n    for i in range(0, len(prediction)):\n        pred4.iloc[i][j] = prediction[i][j]\n\n# Check rmse\ni = 'Close'\nprint('rmse value for', i, 'is : ', math.sqrt(mean_squared_error(pred4[i], valid4[i])))\n\n\nmodel4 = VAR(endog=data4)\nmodel4_fit = model4.fit(trend = 'ct')\nyhat = model4_fit.forecast(model4_fit.y, steps=23)\npreds = []\n\ni = 0\nwhile i < (len(yhat)):\n    pr = yhat[i][3]\n    preds.append([pr])\n    i = i + 1\n#print(preds)\nhist_data = yf.download(stock_name, start=\"2021-04-01\", end=\"2021-05-04\")\nhist_data = hist_data.drop(['Open', 'High', 'Low', 'Adj Close', 'Volume'], axis=1)\nhist_data = hist_data['Close']\nhist_data = np.array(hist_data)\n\npreds_gr = np.reshape(preds, (23,))\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=hist_data, mode='lines+markers',  name='historical', marker_color='#39304A'))\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=preds_gr, mode='lines+markers', name='predictions', marker_color='#FFAA00'))\nfig.update_layout(legend_orientation=\"h\",\n                  legend=dict(x=.5, xanchor=\"center\"),\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'),\n                  title_text = f'{stock_name} VAR prediction', title_x = 0.5,\n                  xaxis_title=\"Timestep\",\n                  yaxis_title=\"Stock price\",\n                  margin=dict(l=0, r=0, t=30, b=0))\nfig.show()","64f0984b":"import numpy as np\nimport math\nfrom numpy import linalg as la\nimport matplotlib.pyplot as plt\nimport math\nimport pandas as pd\nimport yfinance as yf\nimport statistics as stat\nfrom scipy.special import ndtri\nfrom scipy.stats import norm\nimport random\nfrom sklearn.metrics import mean_squared_error\n\nmu, sig, N = 1.1, 1, 100000\npts = []\n\n\ndef q(x):\n    return (1 \/ (math.sqrt(2 * math.pi * sig ** 2))) * (math.e ** (-((x - mu) ** 2) \/ (2 * sig ** 2)))\n\ndef MCMC(n):\n    r = np.zeros(1)\n    p = q(r[0])\n    pts = []\n\n    for i in range(N):\n        rn = r + np.random.uniform(-1, 1)\n        pn = q(rn[0])\n        if pn >= p:\n            p = pn\n            r = rn\n        else:\n            u = np.random.rand()\n            if u < pn \/ p:\n                p = pn\n                r = rn\n        pts.append(r)\n\n    pts = random.sample(pts, len(pts))\n    pts = np.array(pts)\n    \n    return pts\n\ndef MH(stock_name, data):\n    hist_data = yf.download(stock_name, start=\"2021-04-01\", end=\"2021-05-04\")\n    hist_data = hist_data.drop(['Open', 'High', 'Low', 'Adj Close', 'Volume'], axis=1)\n    hist_data = hist_data['Close']\n    hist_data = np.array(hist_data)\n    stock_pred = []\n    data = data.drop(['Open', 'High', 'Low', 'Adj Close', 'Volume'], axis=1)\n    dt1 = data['Close']\n    maturnity = 1\n    volatility = 0.25\n    risk_free = 0.1\n    timestep = 1\n    steps = 22\n    delta_t = maturnity \/ steps\n    i = 0\n    stock_pred.append(dt1[-1])\n    while timestep < steps:\n        stock_price = stock_pred[-i]\n        time_exp = maturnity - delta_t * timestep\n        # Generate z_t using MCMC method\n        pts = MCMC(N)\n        stock_price = stock_price * math.exp(((risk_free - 0.5 * (\n            math.pow(volatility, 2))) * delta_t + volatility * math.sqrt(delta_t) * pts[timestep + 5]))\n        stock_pred.append(stock_price)\n        i = i + 1\n        timestep = timestep + 1\n    \n    rmse = math.sqrt(mean_squared_error(hist_data, stock_pred))\n    print(f'RMSE MCMC: {rmse}')\n    \n    \n    # build graphs\n    preds_gr = np.reshape(stock_pred, (22,))\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=list(range(0, 21)), y=hist_data, mode='lines+markers',  name='historical', marker_color='#39304A'))\n    fig.add_trace(go.Scatter(x=list(range(0, 21)), y=preds_gr, mode='lines+markers', name='predictions', marker_color='#FFAA00'))\n    fig.update_layout(legend_orientation=\"h\",\n                  legend=dict(x=.5, xanchor=\"center\"),\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'),\n                  title_text = f'{stock_name} MCMC prediction', title_x = 0.5,\n                  xaxis_title=\"Timestep\",\n                  yaxis_title=\"Stock price\",\n                  margin=dict(l=0, r=0, t=30, b=0))\n    fig.show()\n    \n    return stock_pred, rmse","519bf729":"mcmc_pred, mcmc_rmse = MH(stock_name, data)\nmcmc_pred = np.vstack(mcmc_pred)","05d63401":"print(mcmc_pred.shape)","be9f6541":"# compare predictions\nlstm_pred_gr = np.reshape(lstm_pred, (22,))\nmcmc_pred_gr = np.reshape(mcmc_pred, (22,))\narima_pred_gr = np.reshape(arima_pred, (22,))\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=hist_data, mode='lines+markers', line=dict(color='#39304A', width=5),\n                         marker=dict(color='#39304A', size=10),  name='historical'))\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=lstm_pred_gr, mode='lines+markers', \n                         line=dict(color='#FF6601'), name='LSTM'))\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=mcmc_pred_gr, mode='lines+markers', \n                         line=dict(color='#CB000A'), name='MCMC'))\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=arima_pred_gr, mode='lines+markers', \n                         line=dict(color='#FFDB2D'), name='ARIMA'))\n\nfig.update_layout(legend_orientation=\"h\",\n                  legend=dict(x=.5, xanchor=\"center\"),\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'),\n                  title_text = f'{stock_name} predictions', title_x = 0.5,\n                  xaxis_title=\"Timestep\",\n                  yaxis_title=\"Stock price\",\n                  margin=dict(l=0, r=0, t=30, b=0))\nfig.show()\n\nx = ['LSTM', 'ARIMA', 'MCMC']\ny = [lstm_rmse, arima_rmse, mcmc_rmse]\n\nfig = go.Figure(data=[go.Bar(x=x, y=y,\n            hovertext=['LSTM RMSE (21 epochs)', 'ARIMA RMSE', 'MCMC RMSE (100000 iterations)'])])\nfig.update_traces(marker_color='#FFAA00', marker_line_color='#39304A',\n                  marker_line_width=1.5, opacity=0.7)\nfig.update_layout(title_text='Prediction RMSE by methods',\n                  plot_bgcolor='#FFFFFF',  \n                  xaxis=dict(gridcolor = 'lightgrey'),\n                  yaxis=dict(gridcolor = 'lightgrey'))\nfig.show()","392bedbe":"import pulp as plp\n\nhist_data = yf.download(stock_name, start=\"2021-04-01\", end=\"2021-05-04\")\nhist_data = hist_data.drop(['Open', 'High', 'Low', 'Adj Close', 'Volume'], axis=1)\nhist_data = hist_data['Close']\nhist_data = np.array(hist_data)\n\npreds = []\nmse = []\n\nweights_lstm = 0.3\nweight_mcmc = 0.4\nweight_arima = 0.4\n\n# weights solver\nmodel = plp.LpProblem('Optimal_weights', plp.LpMinimize)\n# weights--->variables\nweight_lstm = plp.LpVariable(\"weight_lstm\", lowBound = 0, upBound=0.6)\nweight_mcmc = plp.LpVariable(\"weight_mcmc\", lowBound = 0, upBound=0.6)\nweight_arima = plp.LpVariable(\"weight_arima\", lowBound = 0, upBound=0.6)\n\nfor i in range(len(hist_data)):\n    preds.append(lstm_pred[i]*weight_lstm + mcmc_pred[i]*weight_mcmc + arima_pred[i]*weight_arima)\n    \nfor i in range (len(hist_data)):\n    mse.append(hist_data[i] - preds[i])\n# target function--->mean squared error\nmse = np.mean(mse)\nsum_w = weight_lstm + weight_mcmc + weight_arima \n\nmodel += mse\nmodel += sum_w <= 1.0\nmodel += sum_w >= 1.0\n\nplp.LpSolverDefault.msg = 1\n\n# solve #\nmodel.solve()\nprint('model solve')\nstatus = model.solve()\nprint(\"Model status: \", plp.LpStatus[status])\nprint(model)\n\nweight_mcmc_f = weight_mcmc.varValue\nweight_arima_f = weight_arima.varValue\nweight_lstm_f = weight_lstm.varValue\n\npreds_final = []\n# Create final predictions from 3 methods\nfor i in range(len(hist_data)):\n    preds_final.append(lstm_pred[i]*weight_lstm_f + mcmc_pred[i]*weight_mcmc_f + arima_pred[i]*weight_arima_f)\npreds_final = np.vstack(preds_final)    \n#print(preds_final)\n\n# build graphs\npreds_gr = np.reshape(preds_final, (22,))\nfig = go.Figure()\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=hist_data, mode='lines+markers',  name='historical', marker_color='#39304A'))\nfig.add_trace(go.Scatter(x=list(range(0, 21)), y=preds_gr, mode='lines+markers', name='predictions', marker_color='#FFAA00'))\nfig.update_layout(legend_orientation=\"h\",\n                legend=dict(x=.5, xanchor=\"center\"),\n                plot_bgcolor='#FFFFFF',  \n                xaxis=dict(gridcolor = 'lightgrey'),\n                yaxis=dict(gridcolor = 'lightgrey'), \n                title_text = f'{stock_name} final prediction', title_x = 0.5,\n                xaxis_title=\"Timestep\",\n                yaxis_title=\"Stock price\",\n                margin=dict(l=0, r=0, t=30, b=0))\nfig.show()\n\nmse = []\nfor i in range (len(hist_data)):\n    mse.append(abs(hist_data[i] - preds_final[i]))\nmse = np.mean(mse)\nrmse = math.sqrt(mse)\nprint(f'RMSE = {rmse}')\nprint(f'LSTM weight: {weight_lstm_f}')\nprint(f'MCMC weight: {weight_mcmc_f}')\nprint(f'ARIMA weight: {weight_arima_f}')","8092be5d":"<a id=\"section-six\"><\/a>\n# Prediction optimization","ac00ac2d":"<a id=\"section-three\"><\/a>\n# LSTM model","11942287":"**VAR**","7ae300b0":"<a id=\"section-two\"><\/a>\n# Collecting train data","d6471eec":"![image.png](attachment:d3ccd022-2d5e-4ea1-b600-d086060338ef.png)\n> The stock market refers to the collection of markets and exchanges where regular activities of buying, selling, and issuance of shares of publicly-held companies take place.\n> A stock or share (also known as a company's \"equity\") is a financial instrument that represents ownership in a company or corporation and represents a proportionate claim on its assets (what it owns) and earnings (what it generates in profits).\n\nForecasting the direction of future stock prices is a widely studied topic in many fields including trading, finance, statistics and computer science. The motivation for which is naturally to predict the direction of future prices such that stocks can be bought and sold at profitable positions.","8b01ca76":"# Table of contents\n1. [Installing necessary packages](#section-one)\n1. [Collecting train data](#section-two)\n1. [LSTM](#section-three)\n1. [ARIMA](#section-four)\n1. [Monte Carlo Markov Chain (Metropolis_Hastings method)](#section-five)\n1. [Prediction optimization](#section-six)  \n1. [Summary](#section-seven)    ","858fedce":"# Introduction\nThis notebook illustrates a process of trial and error with various methods of stock prediction methods as a part of my bachelor's thesis. I am sure that most of you already know these methods - **LSTM**, **ARIMA** (and its variations) and **MCMC (Markov Chain Monte Carlo)**. The thing is that stock prices are usually a bit tougher to forecast due to market volatility and social influence on the trend of each stock. Thus, the key point in my research was finding the way to combine such methods in order to make my predictions flexible, depending on each stock's historical data. I hope you will find this notebook useful.","99215411":"> *MCMC allows us to draw samples from any distribution that we can't sample from directly. It can be used to sample from the posterior distribution over parameters. It has seen much success in many applications, such as computing the distribution of parameters, given a set of observations and some prior belief, and also computing high dimensional integrals in physics and in digital communications.*\n\nWhen applying the Monte Carlo method, there is a problem of obtaining a sample from some multidimensional probability distribution *p(x)*. The solution to this problem is the basis of MKML methods. In particular, there have been attempts to integrate very complex functions with random simulations. The result of these attempts is the Metropolis-Hastings algorithm. \nThis algorithm requires the use of a simple distribution, called the proposal distribution *Q(\u03b8'\/\u03b8)*, to extract suitable values from the posterior distribution *P(\u0398=\u03b8\/D)*. \nMetropolis-Hastings method uses *Q* to randomly walk in the distribution space, accepting or rejecting jumps to new positions based on how likely the sample is. This \"memoriless\" random walk is the \"Markov Chain\" part of MCMC.\n\nThe probability of each new sample is determined by the function *f*. The function *f* must be proportional to the given distribution from which we want to take samples. The function f is usually chosen as a probability density function that expresses this proportionality. To get a new position of the parameter, just take our current one *\u03b8* and propose a new one *\u03b8'*, that is randomly drawn from our distibution *Q(\u03b8'\/\u03b8)*. Usually it is a symmetric distribution, for example, a normal distribution with mean *\u03b8* and some standard deviation *\u03c3: Q(\u03b8'\/\u03b8) = N(\u03b8,\u03c3)*. The acception criterion for the sample \u03b8' is the formula:\n\n![image.png](attachment:3bcbefda-0f48-4dc9-bd02-5750596b8b07.png)\n\nIf *\u03b8'* is more likely than the current *\u03b8*, then we always accept *\u03b8'*. If it is less likely than the current *\u03b8*, then we might accept it or reject it randomly with decreasing probability, the less likely it is.\n\nReferences: \n[Reference 1](https:\/\/github.com\/Joseph94m\/MCMC\/blob\/master\/MCMC.ipynb)\n[Reference 2](http:\/\/janroman.dhis.org\/stud\/I2010\/MCBS\/AFI.pdf)","51b4d3bf":"<a id=\"section-one\"><\/a>\n# Installing necessary packages","15845c0d":"For stock predicting using the following method we use stock price formula below, according to Black-Scholes method. That means, that price of stock follows a geometric Brownian motion with constant drift and volatility.\n\n![mcmc_price.PNG](attachment:d0a3868a-902b-4003-9a8c-39aa964f0686.PNG)\n\nz_t is our random shift indicator, which is generated with MCMC method.\nThe inputs for the Black-Scholes equation are volatility (in our case 25%), stock price for previous time period and the risk-free interest rate (10%). As we predict prices for each day of next trading month, we use \u2206t as 1(day)\/22(trading days in month).\n","5b6b827e":"<a id=\"section-four\"><\/a>\n# ARIMA","ed66b135":"Therefore we can see that data is stationary and we can use regressive models for forecasting. Now we can apply ARIMA (Auto ARIMA)","b0c59a52":"**SARIMAX**","9475bdd3":"Obviously, all threee methods demonstrate very different performance. What I do in the next step is just blending predictions of 3 models by creating an optimization problem, where target function is RMSE between forecast and historical data for last month: \n![pred_opt.PNG](attachment:8d8e6254-4052-4682-8829-2a4927d81c1b.PNG)\n\nwhere *S* is the actual data for the prediction period;\n*S^* - predicted data for the period;\n*W* - weights for the forecasts of each model; \nThe output is weighted prediction data which are close to the actual data. The model shown above is solved with PuLP package:","345a4522":"![multi_input_and_output_model.png](attachment:b70b2f5a-7b21-4e5e-b8d4-626d94f26a3d.png)","fd8fc460":"In this notebook various methods of stock price predicting were tested on historical stock data. Each method has its own advantages and disavantages, but those can be used for good by blending different methods for generating one prediction. In this case our historical data from last year shows high volatility, so methods like ARIMA lose their efficiency in forecasting. Using our blending method our predictions can be flexible, depending on previous historical data of the stock. \n\n***If you made it this far, congrats! Thank you for reading this and hope you enjoyed my notebook! Please feel free to comment and upvote :)***","b864f3a6":"For data scraping I use yfinance package, it is easy to install and use.\n\n> *yfinance is a popular open source library developed by Ran Aroussi as a means to access the financial data available on Yahoo Finance. Yahoo Finance offers an excellent range of market data on stocks, bonds, currencies and cryptocurrencies. It also offers market news, reports and analysis and additionally options and fundamentals data- setting it apart from some of it\u2019s competitors.*\n\nDocumentation is available at [Yfinance](https:\/\/pypi.org\/project\/yfinance\/)","0b34e906":"<a id=\"section-five\"><\/a>\n# Monte Carlo Markov Chain (Metropolings-Hastings method)","4c1a1f8d":"*PuLP is a python library which can be used to solve linear programming problems.*\n\nPuLP is usually used for simpler tasks, but it can also come handy for predictions blending. By default, CBC solver is used in the package, but there are plenty more of them available, for example, CPLEX, Gurobi and GLPK. For reference, you can see how PuLP is used for optimization tasks in my other notebook: [Optimization problem solving with PuLP](https:\/\/www.kaggle.com\/equinxx\/optimization-problem-solving-with-pulp)\n\n[Documentation source](http:\/\/coin-or.github.io\/pulp\/)","482de455":"Since we can see a big difference between real and predicted data, we might want to try other regressive methods, like SARIMAX or VAR. Actually, I tested them but they showed almost the same results (see below). The reason might be a high market volatility during prediction period where such methods are not able to adapt their forecasting trend for each day. BTW if we test these regressive methods on older data, we will see that an error is lower.","7f95907d":"<a id=\"section-seven\"><\/a>\n# Summary","b3071f3d":"Model structure:\n","ef685de9":"*Autoregressive Integrated Moving Average (ARIMA) Model converts non-stationary data to stationary data before working on it. It is one of the most popular models to predict linear time series data.*\n\n*ARIMA model has been used extensively in the field of finance and economics as it is known to be robust, efficient and has a strong potential for short-term share market prediction.*","ab848084":"Let's perform ADF test for stock data:","175c3ffc":"Now let's compare performance of 3 methods: LSTM, ARIMA and MCMC.","f90080c1":"Calculated weights speak for themselves. Sadly, ARIMA did not prove to be efficient at all."}}