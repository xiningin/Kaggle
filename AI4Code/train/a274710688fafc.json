{"cell_type":{"34c4c1a0":"code","80cacd95":"code","b9b5189d":"code","05610989":"code","3c093dfb":"code","b54d9c66":"code","ee64bb1e":"code","a4b16d75":"code","20e0218a":"code","3cde52d2":"code","df4e0eac":"code","bfe14837":"code","615b9249":"code","f7248dcc":"code","c36b18cf":"code","1a7a9be0":"code","18ac23b7":"code","c3319f05":"code","1140989c":"code","7ab1c298":"code","115e9ea3":"code","b93bc915":"code","43fbea45":"code","9c288a90":"code","826ab657":"code","33aa8b7b":"code","39233986":"code","52952269":"code","e2fc752d":"code","df815fec":"code","fcca17b5":"code","2ce382c2":"code","d50ff66a":"code","64cc49ec":"code","e78e8895":"code","b86b8062":"code","493d3235":"code","04636c9a":"code","6e6226c3":"code","eaf42612":"markdown","f1a3d3ea":"markdown","895caaac":"markdown","8e7b77cc":"markdown","9a5ca3ae":"markdown","85ffbc40":"markdown","412c20c4":"markdown","beab89a8":"markdown","e1409ed5":"markdown","8128ed64":"markdown","5864c85b":"markdown","3f5f34f4":"markdown","3818fa0e":"markdown","df7972d0":"markdown","d8de30cb":"markdown","6be2841a":"markdown","7d039b30":"markdown"},"source":{"34c4c1a0":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport io\nimport requests\n\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nfrom plotly import tools\nimport plotly.figure_factory as ff\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-whitegrid')\nimport matplotlib.colors as matcol\nimport random\nimport math\nimport time\nimport datetime\nimport operator\n\nfrom sklearn.model_selection import RandomizedSearchCV, train_test_split\nfrom sklearn.svm import SVR\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","80cacd95":"# confirmed_url = \"https:\/\/github.com\/CSSEGISandData\/COVID-19\/raw\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_19-covid-Confirmed.csv\"\n# deaths_url = \"https:\/\/github.com\/CSSEGISandData\/COVID-19\/raw\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_19-covid-Deaths.csv\"\n# recovered_url = \"https:\/\/github.com\/CSSEGISandData\/COVID-19\/raw\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_19-covid-Recovered.csv\"\n\n\n# url = confirmed_url\n# s = requests.get(url).content\n# cases = pd.read_csv(io.StringIO(s.decode('utf-8')))\n\n# url = deaths_url\n# s = requests.get(url).content\n# deaths = pd.read_csv(io.StringIO(s.decode('utf-8')))\n\n# url = recovered_url\n# s = requests.get(url).content\n# recovered = pd.read_csv(io.StringIO(s.decode('utf-8')))\n\ncases = pd.read_csv(\"\/kaggle\/input\/covid1\/time_series_19-covid-Confirmed.csv\")\n\ndeaths = pd.read_csv(\"\/kaggle\/input\/covid1\/time_series_19-covid-Deaths.csv\")\n\nrecovered = pd.read_csv(\"\/kaggle\/input\/covid1\/time_series_19-covid-Recovered.csv\")\n","b9b5189d":"cases['Country\/Region'] = cases['Country\/Region'].replace('Iran (Islamic Republic of)', 'Iran')\ncases['Country\/Region'] = cases['Country\/Region'].replace('Taiwan*', 'Taiwan')\ncases['Country\/Region'] = cases['Country\/Region'].replace('Criuse Ship', 'Diamond Princess')\ncases['Country\/Region'] = cases['Country\/Region'].replace('Korea, South', 'South Korea')\ncases['Country\/Region'] = cases['Country\/Region'].replace('Indonesia*', 'Indonesia')\n\ndeaths['Country\/Region'] = deaths['Country\/Region'].replace('Iran (Islamic Republic of)', 'Iran')\ndeaths['Country\/Region'] = deaths['Country\/Region'].replace('Taiwan*', 'Taiwan')\ndeaths['Country\/Region'] = deaths['Country\/Region'].replace('Criuse Ship', 'Diamond Princess')\ndeaths['Country\/Region'] = deaths['Country\/Region'].replace('Korea, South', 'South Korea')\ndeaths['Country\/Region'] = deaths['Country\/Region'].replace('Indonesia*', 'Indonesia')\n\nrecovered['Country\/Region'] = recovered['Country\/Region'].replace('Iran (Islamic Republic of)', 'Iran')\nrecovered['Country\/Region'] = recovered['Country\/Region'].replace('Taiwan*', 'Taiwan')\nrecovered['Country\/Region'] = recovered['Country\/Region'].replace('Criuse Ship', 'Diamond Princess')\nrecovered['Country\/Region'] = recovered['Country\/Region'].replace('Korea, South', 'South Korea')\nrecovered['Country\/Region'] = recovered['Country\/Region'].replace('Indonesia*', 'Indonesia')\n\n\ncountries = cases.iloc[:,1].unique()\ncountries.sort()","05610989":"# counter = 0\n\n# plt.figure(figsize=(25,40))\n# plt.tight_layout(pad=3.0)\n\n# plt.rcParams.update({'font.size': 26})\n\n# for country in countries:\n#     ma = np.where(cases['Country\/Region'] == country)[0]\n#     c_count = cases.iloc[ma, 4:].sum(axis=0)\n#     d_count = deaths.iloc[ma, 4:].sum(axis=0)\n#     r_count = recovered.iloc[ma, 4:].sum(axis=0)\n    \n#     if np.max(c_count) > 500:\n#         sig_cases = np.where(c_count > 30)[0]\n#         counter = counter + 1\n#         ax1 = plt.subplot(10, 3, counter)\n#         res1, = plt.plot(c_count[sig_cases], 'ro-', linewidth=3, label=\"reported cases\")\n#         res2, = plt.plot(r_count[sig_cases], 'b^-', linewidth=3, label=\"recovered\")\n#         plt.xticks(rotation=90)\n#         ax2 = ax1.twinx()\n#         res3, = ax2.plot(d_count[sig_cases], 'gs-', linewidth=3, label=\"deaths\")\n        \n#         plt.title(country)\n#         ax1.set_ylabel('cases', color=\"black\")\n#         color = 'green'\n#         ax2.set_ylabel('deaths', color=color)\n#         ax2.tick_params(axis='y', labelcolor=color)\n#         plt.legend(handles=[res1, res2, res3])\n\n# plt.subplots_adjust(left=0, right=2, top=2, bottom=0.5, hspace=1)\n# plt.show()","3c093dfb":"counter = 0\n\nplt.figure(figsize=(16,30))\nplt.tight_layout(pad=3.0)\n\nplt.rcParams.update({'font.size': 26})\n\nfor country in countries:\n    ma = np.where(cases['Country\/Region'] == country)[0]\n    c_count = cases.iloc[ma, 4:].sum(axis=0)\n    d_count = deaths.iloc[ma, 4:].sum(axis=0)\n    r_count = recovered.iloc[ma, 4:].sum(axis=0)\n    \n    if np.max(c_count) > 1000:\n        sig_cases = np.where(c_count > 30)[0]\n        counter = counter + 1\n        ax1 = plt.subplot(10, 3, counter)\n        res1, = plt.plot(c_count[sig_cases], 'ro-', linewidth=3, label=\"reported cases\")\n        res2, = plt.plot(r_count[sig_cases], 'b^-', linewidth=3, label=\"recovered\")\n        plt.xticks(rotation=90)\n        ax2 = ax1.twinx()\n        res3, = ax2.plot(d_count[sig_cases], 'gs-', linewidth=3, label=\"deaths\")\n        \n        plt.title(country)\n        ax1.set_ylabel('cases', color=\"black\")\n        color = 'green'\n        ax2.set_ylabel('deaths', color=color)\n        ax2.tick_params(axis='y', labelcolor=color)\n        plt.legend(handles=[res1, res2, res3])\n\nplt.subplots_adjust(left=0, right=2, top=2, bottom=0.5, hspace=1)\nplt.show()","b54d9c66":"country1 = \"Indonesia\"\ncountry2 = \"South Korea\"","ee64bb1e":"country = country1\nma = np.where(cases[\"Country\/Region\"] == country)[0]\ncountry_count = cases.iloc[ma, 4:].sum(axis=0)\ncountry_deaths = deaths.iloc[ma, 4:].sum(axis=0)\ndr_c1 = country_deaths \/ country_count\n\nd_cases = np.where(country_deaths > 1)[0]\n\ncountry = country2\nma = np.where(cases[\"Country\/Region\"] == country)[0]\ncountry_count = cases.iloc[ma, 4:].sum(axis=0)\ncountry_deaths = deaths.iloc[ma, 4:].sum(axis=0)\ndr_c2 = country_deaths \/ country_count\nd_cases_c2 = np.where(country_deaths > .0)[0]\n\nplt.figure(figsize=(20,10))\nplt.rc('ytick', labelsize=26) \nplt.rc('xtick', labelsize=13)\n\nres1, = plt.plot(dr_c1[d_cases]*100, 'b.-', label=\"Death rate (\"+country1+\")\")\nres2, = plt.plot(dr_c2[d_cases]*100, 'r.-', label=\"Death rate (\"+country2+\")\")\n\nplt.ylabel(\"death rate\")\nplt.xticks(rotation=90)\nplt.legend(handles=[res1, res2])\nplt.show()","a4b16d75":"plt.figure(figsize=(5,6))\nx = [dr_c1[d_cases]*100,\n     dr_c2[d_cases_c2]*100]\nplt.boxplot(x)\nplt.xticks([1, 2], [country1, country2])\nplt.show()","20e0218a":"demo = pd.read_csv(\"\/kaggle\/input\/world-population-demographics-by-age-2019\/world_demographics.csv\")\n\ndemo[:1]\n\ndemo[\"Country or Area\"] = demo[\"Country or Area\"].replace(\"Viet Nam\", \"Vietnam\")\ndemo[\"Country or Area\"] = demo[\"Country or Area\"].replace(\"United States of America\", \"US\")\ndemo[\"Country or Area\"] = demo[\"Country or Area\"].replace(\"United Kingdom of Great Britain and Northern Ireland\", \"United Kingdom\")\ndemo[\"Country or Area\"] = demo[\"Country or Area\"].replace(\"Republic of Korea\", \"South Korea\")\ndemo[\"Country or Area\"] = demo[\"Country or Area\"].replace(\"Venezuela (Bolivarian Republic of)\", \"Venezuela\")\ndemo[\"Country or Area\"] = demo[\"Country or Area\"].replace('Iran (Islamic Republic of)', 'Iran')\ndemo[\"Country or Area\"] = demo[\"Country or Area\"].replace('Indonesia', 'Indonesia')\n\nduc = demo[\"Country or Area\"].unique()\nduc.sort()","3cde52d2":"ma = np.where(demo[\"Country or Area\"] == country1)[0]\ndemo_c1 = demo.iloc[ma,:]\nmax_year = np.where(demo_c1[\"Year\"] == demo_c1[\"Year\"].max())[0]\ndemo_c1 = demo_c1.iloc[max_year]\n\nma = np.where(demo[\"Country or Area\"] == country2)[0]\ndemo_c2 = demo.iloc[ma,:]\nmax_year = np.where(demo_c2[\"Year\"] == demo_c2[\"Year\"].max())[0]\ndemo_c2 = demo_c2.iloc[max_year]\n\nll = list(range(0,120))\nll = [str(i) for i in ll]\n\nma = np.where(np.isin(demo_c1[\"Age\"], np.array(ll)))[0]\ndemo_c1 = demo_c1.iloc[ma,:]\n\nma = np.where(np.isin(demo_c2[\"Age\"], np.array(ll)))[0]\ndemo_c2 = demo_c2.iloc[ma,:]","df4e0eac":"p_c1 = demo_c1[\"Value\"]\np_c2 = demo_c2[\"Value\"]\n\ny = list(range(0, 100, 1))\n\nlayout = go.Layout(yaxis=go.layout.YAxis(title='Age'),\n                   xaxis=go.layout.XAxis(\n                       range=[-(p_c1+p_c2).max(), (p_c1+p_c2).max()],\n                       tickvals=[-1000000, -500000, 0, 500000, 1000000],\n                       ticktext=[\"1M\", \"0.5M\", \"0\", \"0.5M\", \"1M\"],\n                       title='Number'),\n                   barmode='overlay',\n                   bargap=0.1)\n\ndata = [go.Bar(y=y,\n               x=-p_c1,\n               orientation='h',\n               name=country1,\n               hoverinfo='x',\n               marker=dict(color='lightgreen')\n               ),\n        go.Bar(y=y,\n               x=p_c2,\n               orientation='h',\n               name=country2,\n               text=-1 * p_c2.astype('int'),\n               hoverinfo='text',\n               marker=dict(color='seagreen')\n               )]\n\nfig = py.iplot(dict(data=data, layout=layout), filename='EXAMPLES\/bar_pyramid')","bfe14837":"deathrate_age = list(range(0,120))\n\ndeathrate_age[0:30] = [0]*30\ndeathrate_age[30:40] = [0.0011]*10\ndeathrate_age[40:50] = [0.0009]*10\ndeathrate_age[50:60] = [0.0037]*10\ndeathrate_age[60:70] = [0.0151]*10\ndeathrate_age[70:80] = [0.0535]*10\ndeathrate_age[80:120] = [0.1084]*40","615b9249":"vulnerable_c1 = [a * b for a, b in zip(demo_c1[\"Value\"], deathrate_age)]\nvulnerable_c2 = [a * b for a, b in zip(demo_c2[\"Value\"], deathrate_age)]","f7248dcc":"p_c1 = np.array(vulnerable_c1)\np_c2 = np.array(vulnerable_c2)\n\ny = list(range(0, 100, 1))\n\nlayout = go.Layout(yaxis=go.layout.YAxis(title='Age'),\n                   xaxis=go.layout.XAxis(\n                       range=[-max(list(p_c1)+list(p_c2)), max(list(p_c1)+list(p_c2))],\n                       tickvals=[-50000, -25000, 0, 25000, 50000],\n                       ticktext=[\"50k\", \"25k\", \"0\", \"25k\", \"50k\"],\n                       title='Number'),\n                   barmode='overlay',\n                   bargap=0.1)\n\ndata = [go.Bar(y=y,\n               x=-p_c1,\n               orientation='h',\n               name=country1,\n               hoverinfo='x',\n               marker=dict(color='powderblue')\n               ),\n        go.Bar(y=y,\n               x=p_c2,\n               orientation='h',\n               name=country2,\n               text=-1 * p_c2.astype('int'),\n               hoverinfo='text',\n               marker=dict(color='seagreen')\n               )]\n\npy.iplot(dict(data=data, layout=layout), filename='EXAMPLES\/bar_pyramid')","c36b18cf":"v_c1 = sum(vulnerable_c1)\/sum(demo_c1[\"Value\"])\nv_c2 = sum(vulnerable_c2)\/sum(demo_c2[\"Value\"])\n\nexp_diff = v_c1\/v_c2\nprint(exp_diff)","1a7a9be0":"country = country1\nma = np.where(cases[\"Country\/Region\"] == country)[0]\ncountry_count = cases.iloc[ma, 4:].sum(axis=0)\ncountry_deaths = deaths.iloc[ma, 4:].sum(axis=0)\ndr_c1 = country_deaths \/ country_count\n\nd_cases = np.where(country_deaths > 0)[0]\n\ncountry = country2\nma = np.where(cases[\"Country\/Region\"] == country)[0]\ncountry_count = cases.iloc[ma, 4:].sum(axis=0)\ncountry_deaths = deaths.iloc[ma, 4:].sum(axis=0)\ndr_c2 = country_deaths \/ country_count\n\nd_cases_c2 = np.where(country_deaths > 0)[0]\n\nscaling_factor = dr_c1[d_cases] \/ (exp_diff*sum(dr_c2[d_cases_c2])\/len(d_cases_c2))\ncountry = country1\nma = np.where(cases[\"Country\/Region\"] == country)[0]\n\ncountry_count = cases.iloc[ma, 4:].sum(axis=0)\ncountry_deaths = deaths.iloc[ma, 4:].sum(axis=0)\n\npotential_cases = country_count[d_cases] * scaling_factor\n\nplt.figure(figsize=(16,10))\nres1, = plt.plot(country_count[d_cases], 'bo-', label=\"Reported Cases (\"+country1+\")\")\nres2, = plt.plot(potential_cases, 'ro-', label=\"Potential Actual Cases (\"+country1+\")\")\n\nplt.ylabel(\"cases\")\nplt.xticks(rotation=90)\nplt.legend(handles=[res1, res2])\nplt.show()","18ac23b7":"print(country_count[d_cases][-1])\nprint(round(potential_cases[-1]))\nprint(round(100*round(potential_cases[-1])\/country_count[d_cases][-1]))","c3319f05":"cases.head()\n","1140989c":"deaths.head()","7ab1c298":"recovered.head()","115e9ea3":"col_names = cases.keys()\ncol_names","b93bc915":"dates_cases = cases.loc[:,col_names[4]:col_names[-1]]\ndates_deaths = deaths.loc[:,col_names[4]:col_names[-1]]\ndates_recovered = recovered.loc[:,col_names[4]:col_names[-1]]","43fbea45":"dates = dates_cases.keys()\ntotal_cases = []\ntotal_deaths = []\nmortality_rate = []\ntotal_recovered = []\n\nfor date in dates:\n    cases_sum = dates_cases[date].sum()\n    deaths_sum = dates_deaths[date].sum()\n    recovered_sum = dates_recovered[date].sum()\n    \n    total_cases.append(cases_sum)\n    total_deaths.append(deaths_sum)\n    total_recovered.append(recovered_sum)","9c288a90":"cases_sum, deaths_sum, recovered_sum","826ab657":"days_since_23_mar = np.array([i for i in range(len(dates))]).reshape(-1, 1)\ntotal_cases = np.array(total_cases).reshape(-1, 1)\ntotal_deaths = np.array(total_deaths).reshape(-1, 1)\ntotal_recovered = np.array(total_recovered).reshape(-1, 1)","33aa8b7b":"future_days = 10\nfuture_prediction = np.array([i for i in range(len(dates)+future_days)]).reshape(-1, 1)\nadjusted_days = future_prediction[:-10]\nfuture_prediction","39233986":"start = '23\/3\/2020'\nstart_date = datetime.datetime.strptime(start, '%d\/%m\/%Y')\nfuture_prediction_dates = []\nfor i in range(len(future_prediction)):\n    future_prediction_dates.append((start_date + datetime.timedelta(days=i)).strftime('%d\/%m\/%Y'))\nfuture_prediction_dates","52952269":"latest_cases = cases[dates[-1]]\nlatest_deaths = deaths[dates[-1]]\nlatest_recovered = recovered[dates[-1]]","e2fc752d":"countries = list(cases['Country\/Region'].unique())\ncountries","df815fec":"kernel = ['poly', 'sigmoid', 'rbf']\nc = [0.01, 0.1, 1, 10]\ngamma = [0.01, 0.1, 1]\nepsilon = [0.01, 0.1, 1]\nshrinking = [True, False]\nsvm_grid = {'kernel':kernel, 'C':c, 'gamma':gamma, 'epsilon':epsilon, 'shrinking':shrinking}\n\nX_train_confirmed, X_test_confirmed, y_train_confirmed, y_test_confirmed = train_test_split(days_since_23_mar, total_cases, test_size=0.15, shuffle=False)\n\nsvm = SVR()\nsvm_search = RandomizedSearchCV(svm, svm_grid, scoring='neg_mean_squared_error', cv=3, return_train_score=True, n_jobs=-1, n_iter=40, verbose=1)\nsvm_search.fit(X_train_confirmed, y_train_confirmed)","fcca17b5":"svm_search.best_params_","2ce382c2":"svm_cases = svm_search.best_estimator_\nsvm_predict = svm_cases.predict(future_prediction)\nsvm_cases, svm_predict","d50ff66a":"\nsvm_test_predict = svm_cases.predict(X_test_confirmed)\nplt.plot(svm_test_predict)\nplt.plot(y_test_confirmed)\n\nprint('Mean Absolute Error', mean_absolute_error(svm_test_predict, y_test_confirmed))\nprint('Mean Squared Error', mean_squared_error(svm_test_predict, y_test_confirmed))","64cc49ec":"plt.figure(figsize=(20, 12))\nplt.plot(adjusted_days, total_cases)\nplt.title('Number of Cases Over Time', size=30)\nplt.xlabel('Days Since 22 Jan', size=20)\nplt.ylabel('Number of Cases', size=20)\nplt.xticks(size=15)\nplt.show()","e78e8895":"plt.figure(figsize=(20, 12))\nplt.plot(adjusted_days, total_cases)\nplt.plot(future_prediction, svm_predict, linestyle='dashed', color='orange')\nplt.title('Confirmed vs Predicted', size=30)\nplt.xlabel('Days Since 22 March', size=20)\nplt.ylabel('Number of Cases', size=20)\nplt.legend(['Confirmed Cases', 'Predicted Cases'])\nplt.xticks(size=15)\nplt.yticks(size=15)\nplt.show()","b86b8062":"set(zip(future_prediction_dates[-30:],svm_predict[-30:]))","493d3235":"from sklearn.linear_model import LinearRegression\n\nlinear_model = LinearRegression(normalize=True, fit_intercept=True)\nlinear_model.fit(X_train_confirmed, y_train_confirmed)\ntest_linear_predict = linear_model.predict(X_test_confirmed)\nlinear_predict = linear_model.predict(future_prediction)\n\nprint('Mean Absolute Error', mean_absolute_error(test_linear_predict, y_test_confirmed))\nprint('Mean Squared Error', mean_squared_error(test_linear_predict, y_test_confirmed))","04636c9a":"plt.plot(y_test_confirmed)\nplt.plot(test_linear_predict)","6e6226c3":"plt.figure(figsize=(20, 12))\nplt.plot(adjusted_days, total_cases)\nplt.plot(future_prediction, linear_predict, linestyle='dashed', color='orange')\nplt.title('Confirmed vs Predicted', size=30)\nplt.xlabel('Days Since 22 Jan', size=20)\nplt.ylabel('Number of Cases', size=20)\nplt.legend(['Confirmed Cases', 'Predicted Cases'])\nplt.xticks(size=15)\nplt.yticks(size=15)\nplt.show()","eaf42612":"Aggregate demographic informaton for the countries. ","f1a3d3ea":"Download and initialize datasets","895caaac":"### User input required\nSelect two countries to be analyzed. \n\n**country1** = target country (as descripted in manuscript)\n\nThe target country case progression will be corrected using a benchmark country. Currently South Korea has the most accurate information available.\n\n**country2** = benchmark country (as described in manuscript)\n\nThe benchmark country death-rate and population demographics are used to correct the case progression of **country1**","8e7b77cc":"Plot the demographic distribution of the countries by year of birth.","9a5ca3ae":"Print the reported cases, adjusted cases, increase in adjustment (%)","85ffbc40":"The vulnerable vector is the number of expected fatal outcomes if everybody in the population is infected.","412c20c4":"Plot the demographic information for predicted fatalities.","beab89a8":"This information is published by The Center for Disease Control of South Korea. The data is based on a data release from 3\/18\/2020.","e1409ed5":"Load population demographics. The data covers 2007 to 2019. Some countries may not be included in this time frame. ","8128ed64":"Homogenize some country names, to make them compatible accross datasets","5864c85b":"Plot the number of adjusted cases vs the reported cases.","3f5f34f4":"## Correcting under-reported COVID-19 case numbers\n\nThe COVID-19 virus has spread worldwide in a matter of a few month. Healthcare systems struggle to monitor and report current cases. Limited capabilities in testing result in difficult to guide policies and mitigate lack of preparation. Since severe cases, which more likely lead to fatal outcomes, are detected at a higher percentage than mild cases, the reported death rates are likely inflated in most countries. Such under-estimation can be attributed to under-sampling of infection cases and results in systematic death rate estimation biases.\n\nThe method proposed here utilizes a benchmark country (South Korea) and its reported death rates in combination with population demographics to correct the reported COVID-19 case numbers. By applying a correction, we predict that the number of cases is highly under-reported in most countries. In the case of China, it is estimated that more than 700.000 cases of COVID-19 actually occurred instead of the confirmed 80,932 cases as of 3\/13\/2020.\n\nManuscript:\nhttps:\/\/www.medrxiv.org\/content\/10.1101\/2020.03.14.20036178v1","3818fa0e":"This workflow utilizes population demographics and public COVID-19 case reports to estimate the true case progression workwide.","df7972d0":"1. Plot the case progression of reported COVID-19 cases by country and the respective deaths. These numbers are cummulative case counts. There are two scales for the y-axis. The left scale is for the case numbers and recovered cases. The right scale in green is the number of deaths. Only countries with more than 1000 cases are plotted.","d8de30cb":"Calculate the Vulnerability Factor.","6be2841a":"Collapse the line plots to show the distibution of death-rate as a barplot.","7d039b30":"Plot the death-rate of **country1** and **country2** over time. The depicted time interval is limited to days where **country1** reported at least 4 deaths."}}