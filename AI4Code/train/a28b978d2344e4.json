{"cell_type":{"8ea77183":"code","a7dc0bbc":"code","171b0c92":"code","720f149e":"code","af305c0b":"code","a5997f85":"code","5b4e4245":"code","a4f19272":"code","0f1f5fd8":"code","31442e41":"code","5714523d":"code","1f55e047":"code","4c630385":"code","2c94f82b":"code","64105705":"code","6c1cf02c":"code","1f53b460":"code","c5149285":"code","6eda54e0":"code","f17380d5":"code","d9ea1827":"code","b037c11f":"code","1ab2d224":"code","6cfdfb4a":"code","f8de4227":"code","78732192":"code","231950c8":"code","0953d861":"code","a4e109cf":"code","6553fed4":"code","087adf66":"code","5f837522":"code","052dbb38":"code","0f741481":"code","c92865b8":"code","3d370a88":"code","af5dd8fa":"code","6a06e697":"code","c9c49847":"code","3c32d5b0":"code","b7d9df05":"code","97fac027":"code","a71ba6f0":"code","3b1ed723":"code","14a26dd7":"code","cad8e356":"code","7df2a454":"code","a1896448":"code","d6393460":"code","15d56cb8":"code","4cc3efc1":"markdown","537228ab":"markdown","92580b25":"markdown","e2cd91f2":"markdown","26cf68b4":"markdown","bd704cda":"markdown","e4551816":"markdown","99eae5c1":"markdown","c19360fc":"markdown","2d2dea00":"markdown","b6f0047a":"markdown","f1991291":"markdown","4c5c6286":"markdown","ccfc24aa":"markdown","774f9f54":"markdown","7798498e":"markdown","14434157":"markdown","a73b9eea":"markdown","311beacd":"markdown","c7a96edd":"markdown","36e85ffc":"markdown","67dc1b9a":"markdown","20a222dd":"markdown","db22c406":"markdown","fbf5eb55":"markdown","9e41f61a":"markdown","80348a92":"markdown","363e627f":"markdown","047fec4b":"markdown","ffaf96c9":"markdown","21584e13":"markdown","6d90819d":"markdown","07d32e7f":"markdown","72cc1d1e":"markdown","a08bb015":"markdown","409f3e0c":"markdown","bbb84f40":"markdown","8c39f64a":"markdown","4c5cd092":"markdown","d402cacb":"markdown","a58d4fb7":"markdown"},"source":{"8ea77183":"\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport string\n\nplt.rcParams.update({'font.size': 14})\n\n# Load data\ntrain = pd.read_csv(\"\/kaggle\/input\/nlp-getting-started\/train.csv\")\ntest = pd.read_csv(\"\/kaggle\/input\/nlp-getting-started\/test.csv\")\nsub_sample = pd.read_csv(\"\/kaggle\/input\/nlp-getting-started\/sample_submission.csv\")","a7dc0bbc":"print (train.shape, test.shape, sub_sample.shape)","171b0c92":"train.head()","720f149e":"train.duplicated().sum()","af305c0b":"train = train.drop_duplicates().reset_index(drop=True)","a5997f85":"\nsns.countplot(y=train.target);","5b4e4245":"train.target.value_counts()","a4f19272":"# NA data\ntrain.isnull().sum()","0f1f5fd8":"test.isnull().sum()","31442e41":"# Check number of unique keywords, and whether they are the same for train and test sets\nprint (train.keyword.nunique(), test.keyword.nunique())\nprint (set(train.keyword.unique()) - set(test.keyword.unique()))","5714523d":"# Most common keywords\nplt.figure(figsize=(9,6))\nsns.countplot(y=train.keyword, order = train.keyword.value_counts().iloc[:15].index)\nplt.title('Top 15 keywords')\nplt.show()\n# train.keyword.value_counts().head(10)","1f55e047":"kw_d = train[train.target==1].keyword.value_counts().head(10)\nkw_nd = train[train.target==0].keyword.value_counts().head(10)\n\nplt.figure(figsize=(13,5))\nplt.subplot(121)\nsns.barplot(kw_d, kw_d.index, color='c')\nplt.title('Top keywords for disaster tweets')\nplt.subplot(122)\nsns.barplot(kw_nd, kw_nd.index, color='y')\nplt.title('Top keywords for non-disaster tweets')\nplt.show()","4c630385":"top_d = train.groupby('keyword').mean()['target'].sort_values(ascending=False).head(10)\ntop_nd = train.groupby('keyword').mean()['target'].sort_values().head(10)\n\nplt.figure(figsize=(13,5))\nplt.subplot(121)\nsns.barplot(top_d, top_d.index, color='pink')\nplt.title('Keywords with highest % of disaster tweets')\nplt.subplot(122)\nsns.barplot(top_nd, top_nd.index, color='yellow')\nplt.title('Keywords with lowest % of disaster tweets')\nplt.show()","2c94f82b":"# Check number of unique keywords and locations\nprint (train.location.nunique(), test.location.nunique())","64105705":"# Most common locations\nplt.figure(figsize=(9,6))\nsns.countplot(y=train.location, order = train.location.value_counts().iloc[:15].index)\nplt.title('Top 15 locations')\nplt.show()","6c1cf02c":"raw_loc = train.location.value_counts()\ntop_loc = list(raw_loc[raw_loc>=10].index)\ntop_only = train[train.location.isin(top_loc)]\n\ntop_l = top_only.groupby('location').mean()['target'].sort_values(ascending=False)\nplt.figure(figsize=(14,6))\nsns.barplot(x=top_l.index, y=top_l)\nplt.axhline(np.mean(train.target))\nplt.xticks(rotation=80)\nplt.show()","1f53b460":"# Fill NA values\nfor col in ['keyword','location']:\n    train[col] = train[col].fillna('None')\n    test[col] = test[col].fillna('None')\n\ndef clean_loc(x):\n    if x == 'None':\n        return 'None'\n    elif x == 'Earth' or x =='Worldwide' or x == 'Everywhere':\n        return 'World'\n    elif 'New York' in x or 'NYC' in x:\n        return 'New York'    \n    elif 'London' in x:\n        return 'London'\n    elif 'Mumbai' in x:\n        return 'Mumbai'\n    elif 'Washington' in x and 'D' in x and 'C' in x:\n        return 'Washington DC'\n    elif 'San Francisco' in x:\n        return 'San Francisco'\n    elif 'Los Angeles' in x:\n        return 'Los Angeles'\n    elif 'Seattle' in x:\n        return 'Seattle'\n    elif 'Chicago' in x:\n        return 'Chicago'\n    elif 'Toronto' in x:\n        return 'Toronto'\n    elif 'Sacramento' in x:\n        return 'Sacramento'\n    elif 'Atlanta' in x:\n        return 'Atlanta'\n    elif 'California' in x:\n        return 'California'\n    elif 'Florida' in x:\n        return 'Florida'\n    elif 'Texas' in x:\n        return 'Texas'\n    elif 'United States' in x or 'USA' in x:\n        return 'USA'\n    elif 'United Kingdom' in x or 'UK' in x or 'Britain' in x:\n        return 'UK'\n    elif 'Canada' in x:\n        return 'Canada'\n    elif 'India' in x:\n        return 'India'\n    elif 'Kenya' in x:\n        return 'Kenya'\n    elif 'Nigeria' in x:\n        return 'Nigeria'\n    elif 'Australia' in x:\n        return 'Australia'\n    elif 'Indonesia' in x:\n        return 'Indonesia'\n    elif x in top_loc:\n        return x\n    else: return 'Others'\n    \ntrain['location_clean'] = train['location'].apply(lambda x: clean_loc(str(x)))\ntest['location_clean'] = test['location'].apply(lambda x: clean_loc(str(x)))","c5149285":"top_l2 = train.groupby('location_clean').mean()['target'].sort_values(ascending=False)\nplt.figure(figsize=(14,6))\nsns.barplot(x=top_l2.index, y=top_l2)\nplt.axhline(np.mean(train.target))\nplt.xticks(rotation=80)\nplt.show()","6eda54e0":"leak = pd.read_csv(\"..\/input\/disasters-on-social-media\/socialmedia-disaster-tweets-DFE.csv\", encoding='latin_1')\nleak['target'] = (leak['choose_one']=='Relevant').astype(int)\nleak['id'] = leak.index\nleak = leak[['id', 'target','text']]\nmerged_df = pd.merge(test, leak, on='id')\nsub1 = merged_df[['id', 'target']]\nsub1.to_csv('submit_1.csv', index=False)","f17380d5":"import re\n\ntest_str = train.loc[417, 'text']\n\ndef clean_text(text):\n    text = re.sub(r'https?:\/\/\\S+', '', text) # Remove link\n    text = re.sub(r'\\n',' ', text) # Remove line breaks\n    text = re.sub('\\s+', ' ', text).strip() # Remove leading, trailing, and extra spaces\n    return text\n\nprint(\"Original text: \" + test_str)\nprint(\"Cleaned text: \" + clean_text(test_str))","d9ea1827":"def find_hashtags(tweet):\n    return \" \".join([match.group(0)[1:] for match in re.finditer(r\"#\\w+\", tweet)]) or 'no'\n\ndef find_mentions(tweet):\n    return \" \".join([match.group(0)[1:] for match in re.finditer(r\"@\\w+\", tweet)]) or 'no'\n\ndef find_links(tweet):\n    return \" \".join([match.group(0)[:] for match in re.finditer(r\"https?:\/\/\\S+\", tweet)]) or 'no'\n\ndef process_text(df):\n    \n    df['text_clean'] = df['text'].apply(lambda x: clean_text(x))\n    df['hashtags'] = df['text'].apply(lambda x: find_hashtags(x))\n    df['mentions'] = df['text'].apply(lambda x: find_mentions(x))\n    df['links'] = df['text'].apply(lambda x: find_links(x))\n    # df['hashtags'].fillna(value='no', inplace=True)\n    # df['mentions'].fillna(value='no', inplace=True)\n    \n    return df\n    \ntrain = process_text(train)\ntest = process_text(test)","b037c11f":"from wordcloud import STOPWORDS\n\ndef create_stat(df):\n    # Tweet length\n    df['text_len'] = df['text_clean'].apply(len)\n    # Word count\n    df['word_count'] = df[\"text_clean\"].apply(lambda x: len(str(x).split()))\n    # Stopword count\n    df['stop_word_count'] = df['text_clean'].apply(lambda x: len([w for w in str(x).lower().split() if w in STOPWORDS]))\n    # Punctuation count\n    df['punctuation_count'] = df['text_clean'].apply(lambda x: len([c for c in str(x) if c in string.punctuation]))\n    # Count of hashtags (#)\n    df['hashtag_count'] = df['hashtags'].apply(lambda x: len(str(x).split()))\n    # Count of mentions (@)\n    df['mention_count'] = df['mentions'].apply(lambda x: len(str(x).split()))\n    # Count of links\n    df['link_count'] = df['links'].apply(lambda x: len(str(x).split()))\n    # Count of uppercase letters\n    df['caps_count'] = df['text_clean'].apply(lambda x: sum(1 for c in str(x) if c.isupper()))\n    # Ratio of uppercase letters\n    df['caps_ratio'] = df['caps_count'] \/ df['text_len']\n    return df\n\ntrain = create_stat(train)\ntest = create_stat(test)\n\nprint(train.shape, test.shape)","1ab2d224":"train.corr()['target'].drop('target').sort_values()","6cfdfb4a":"from nltk import FreqDist, word_tokenize\n\n# Make a set of stop words\nstopwords = set(STOPWORDS)\n# more_stopwords = {'https', 'amp'}\n# stopwords = stopwords.union(more_stopwords)","f8de4227":"import matplotlib.pyplot as plt\nfrom wordcloud import WordCloud\n \nwc = WordCloud().generate(stopwords)\n \nplt.imshow(wc, interpolation='bilinear')\nplt.axis(\"off\")\nplt.show()","78732192":"# Unigrams\nword_freq = FreqDist(w for w in word_tokenize(' '.join(train['text_clean']).lower()) if \n                     (w not in stopwords) & (w.isalpha()))\ndf_word_freq = pd.DataFrame.from_dict(word_freq, orient='index', columns=['count'])\ntop20w = df_word_freq.sort_values('count',ascending=False).head(20)\n\nplt.figure(figsize=(8,6))\nsns.barplot(top20w['count'], top20w.index)\nplt.title('Top 20 words')\nplt.show()","231950c8":"plt.figure(figsize=(16,7))\nplt.subplot(121)\nfreq_d = FreqDist(w for w in word_tokenize(' '.join(train.loc[train.target==1, 'text_clean']).lower()) if \n                     (w not in stopwords) & (w.isalpha()))\ndf_d = pd.DataFrame.from_dict(freq_d, orient='index', columns=['count'])\ntop20_d = df_d.sort_values('count',ascending=False).head(20)\nsns.barplot(top20_d['count'], top20_d.index, color='c')\nplt.title('Top words in disaster tweets')\nplt.subplot(122)\nfreq_nd = FreqDist(w for w in word_tokenize(' '.join(train.loc[train.target==0, 'text_clean']).lower()) if \n                     (w not in stopwords) & (w.isalpha()))\ndf_nd = pd.DataFrame.from_dict(freq_nd, orient='index', columns=['count'])\ntop20_nd = df_nd.sort_values('count',ascending=False).head(20)\nsns.barplot(top20_nd['count'], top20_nd.index, color='y')\nplt.title('Top words in non-disaster tweets')\nplt.show()","0953d861":"# Bigrams\n\nfrom nltk import bigrams\n\nplt.figure(figsize=(16,7))\nplt.subplot(121)\nbigram_d = list(bigrams([w for w in word_tokenize(' '.join(train.loc[train.target==1, 'text_clean']).lower()) if \n              (w not in stopwords) & (w.isalpha())]))\nd_fq = FreqDist(bg for bg in bigram_d)\nbgdf_d = pd.DataFrame.from_dict(d_fq, orient='index', columns=['count'])\nbgdf_d.index = bgdf_d.index.map(lambda x: ' '.join(x))\nbgdf_d = bgdf_d.sort_values('count',ascending=False)\nsns.barplot(bgdf_d.head(20)['count'], bgdf_d.index[:20], color='pink')\nplt.title('Top bigrams in disaster tweets')\nplt.subplot(122)\nbigram_nd = list(bigrams([w for w in word_tokenize(' '.join(train.loc[train.target==0, 'text_clean']).lower()) if \n              (w not in stopwords) & (w.isalpha())]))\nnd_fq = FreqDist(bg for bg in bigram_nd)\nbgdf_nd = pd.DataFrame.from_dict(nd_fq, orient='index', columns=['count'])\nbgdf_nd.index = bgdf_nd.index.map(lambda x: ' '.join(x))\nbgdf_nd = bgdf_nd.sort_values('count',ascending=False)\nsns.barplot(bgdf_nd.head(20)['count'], bgdf_nd.index[:20], color='yellow')\nplt.title('Top bigrams in non-disaster tweets')\nplt.show()","a4e109cf":"import category_encoders as ce\n\n# Target encoding\nfeatures = ['keyword', 'location_clean']\nencoder = ce.TargetEncoder(cols=features)\nencoder.fit(train[features],train['target'])\n\ntrain = train.join(encoder.transform(train[features]).add_suffix('_target'))\ntest = test.join(encoder.transform(test[features]).add_suffix('_target'))","6553fed4":"from sklearn.feature_extraction.text import CountVectorizer\n\n# CountVectorizer\n\n# Links\nvec_links = CountVectorizer(min_df = 5, analyzer = 'word', token_pattern = r'https?:\/\/\\S+') # Only include those >=5 occurrences\nlink_vec = vec_links.fit_transform(train['links'])\nlink_vec_test = vec_links.transform(test['links'])\nX_train_link = pd.DataFrame(link_vec.toarray(), columns=vec_links.get_feature_names())\nX_test_link = pd.DataFrame(link_vec_test.toarray(), columns=vec_links.get_feature_names())\n\n# Mentions\nvec_men = CountVectorizer(min_df = 5)\nmen_vec = vec_men.fit_transform(train['mentions'])\nmen_vec_test = vec_men.transform(test['mentions'])\nX_train_men = pd.DataFrame(men_vec.toarray(), columns=vec_men.get_feature_names())\nX_test_men = pd.DataFrame(men_vec_test.toarray(), columns=vec_men.get_feature_names())\n\n# Hashtags\nvec_hash = CountVectorizer(min_df = 5)\nhash_vec = vec_hash.fit_transform(train['hashtags'])\nhash_vec_test = vec_hash.transform(test['hashtags'])\nX_train_hash = pd.DataFrame(hash_vec.toarray(), columns=vec_hash.get_feature_names())\nX_test_hash = pd.DataFrame(hash_vec_test.toarray(), columns=vec_hash.get_feature_names())\nprint (X_train_link.shape, X_train_men.shape, X_train_hash.shape)","087adf66":"_ = (X_train_link.transpose().dot(train['target']) \/ X_train_link.sum(axis=0)).sort_values(ascending=False)\nplt.figure(figsize=(10,6))\nsns.barplot(x=_, y=_.index)\nplt.axvline(np.mean(train.target))\nplt.title('% of disaster tweet given links')\nplt.show()","5f837522":"_ = (X_train_men.transpose().dot(train['target']) \/ X_train_men.sum(axis=0)).sort_values(ascending=False)\nplt.figure(figsize=(14,6))\nsns.barplot(x=_.index, y=_)\nplt.axhline(np.mean(train.target))\nplt.title('% of disaster tweet given mentions')\nplt.xticks(rotation = 50)\nplt.show()","052dbb38":"hash_rank = (X_train_hash.transpose().dot(train['target']) \/ X_train_hash.sum(axis=0)).sort_values(ascending=False)\nprint('Hashtags with which 100% of Tweets are disasters: ')\nprint(list(hash_rank[hash_rank==1].index))\nprint('Total: ' + str(len(hash_rank[hash_rank==1])))\nprint('Hashtags with which 0% of Tweets are disasters: ')\nprint(list(hash_rank[hash_rank==0].index))\nprint('Total: ' + str(len(hash_rank[hash_rank==0])))","0f741481":"# Tf-idf for text\nfrom sklearn.feature_extraction.text import TfidfVectorizer\n\nvec_text = TfidfVectorizer(min_df = 10, ngram_range = (1,2), stop_words='english') \n# Only include >=10 occurrences\n# Have unigrams and bigrams\ntext_vec = vec_text.fit_transform(train['text_clean'])\ntext_vec_test = vec_text.transform(test['text_clean'])\nX_train_text = pd.DataFrame(text_vec.toarray(), columns=vec_text.get_feature_names())\nX_test_text = pd.DataFrame(text_vec_test.toarray(), columns=vec_text.get_feature_names())\nprint (X_train_text.shape)","c92865b8":"# Joining the dataframes together\n\ntrain = train.join(X_train_link, rsuffix='_link')\ntrain = train.join(X_train_men, rsuffix='_mention')\ntrain = train.join(X_train_hash, rsuffix='_hashtag')\ntrain = train.join(X_train_text, rsuffix='_text')\ntest = test.join(X_test_link, rsuffix='_link')\ntest = test.join(X_test_men, rsuffix='_mention')\ntest = test.join(X_test_hash, rsuffix='_hashtag')\ntest = test.join(X_test_text, rsuffix='_text')\nprint (train.shape, test.shape)","3d370a88":"from sklearn.linear_model import LogisticRegression\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import MinMaxScaler\n\nfeatures_to_drop = ['id', 'keyword','location','text','location_clean','text_clean', 'hashtags', 'mentions','links']\nscaler = MinMaxScaler()\n\nX_train = train.drop(columns = features_to_drop + ['target'])\nX_test = test.drop(columns = features_to_drop)\ny_train = train.target\n\nlr = LogisticRegression(solver='liblinear', random_state=777) # Other solvers have failure to converge problem\n\npipeline = Pipeline([('scale',scaler), ('lr', lr),])\n\npipeline.fit(X_train, y_train)\ny_test = pipeline.predict(X_test)\n\nsubmit = sub_sample.copy()\nsubmit.target = y_test\nsubmit.to_csv('submit_lr.csv',index=False)","af5dd8fa":"print ('Training accuracy: %.4f' % pipeline.score(X_train, y_train))","6a06e697":"# F-1 score\nfrom sklearn.metrics import f1_score\n\nprint ('Training f-1 score: %.4f' % f1_score(y_train, pipeline.predict(X_train)))","c9c49847":"\nfrom sklearn.metrics import confusion_matrix\npd.DataFrame(confusion_matrix(y_train, pipeline.predict(X_train)))","3c32d5b0":"# Cross validation\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.model_selection import ShuffleSplit\n\ncv = ShuffleSplit(n_splits=5, test_size=0.2, random_state=123)\ncv_score = cross_val_score(pipeline, X_train, y_train, cv=cv, scoring='f1')\nprint('Cross validation F-1 score: %.3f' %np.mean(cv_score))","b7d9df05":"# Top features\nplt.figure(figsize=(16,7))\ns1 = pd.Series(np.transpose(lr.coef_[0]), index=X_train.columns).sort_values(ascending=False)[:20]\ns2 = pd.Series(np.transpose(lr.coef_[0]), index=X_train.columns).sort_values()[:20]\nplt.subplot(121)\nsns.barplot(y=s1.index, x=s1)\nplt.title('Top positive coefficients')\nplt.subplot(122)\nsns.barplot(y=s2.index, x=s2)\nplt.title('Top negative coefficients')\nplt.show()","97fac027":"# Feature selection\nfrom sklearn.feature_selection import RFECV\n\nsteps = 20\nn_features = len(X_train.columns)\nX_range = np.arange(n_features - (int(n_features\/steps)) * steps, n_features+1, steps)\n\nrfecv = RFECV(estimator=lr, step=steps, cv=cv, scoring='f1')\n\npipeline2 = Pipeline([('scale',scaler), ('rfecv', rfecv)])\npipeline2.fit(X_train, y_train)\nplt.figure(figsize=(10,6))\nplt.xlabel(\"Number of features selected\")\nplt.ylabel(\"Cross validation score (nb of correct classifications)\")\nplt.plot(np.insert(X_range, 0, 1), rfecv.grid_scores_)\nplt.show()","a71ba6f0":"print ('Optimal no. of features: %d' % np.insert(X_range, 0, 1)[np.argmax(rfecv.grid_scores_)])","3b1ed723":"selected_features = X_train.columns[rfecv.ranking_ == 1]\nX_train2 = X_train[selected_features]\nX_test2 = X_test[selected_features]","14a26dd7":"# lr2 = LogisticRegression(solver='liblinear', random_state=37)\npipeline.fit(X_train2, y_train)\ncv2 = ShuffleSplit(n_splits=5, test_size=0.2, random_state=456)\ncv_score2 = cross_val_score(pipeline, X_train2, y_train, cv=cv2, scoring='f1')\nprint('Cross validation F-1 score: %.3f' %np.mean(cv_score2))","cad8e356":"from sklearn.model_selection import GridSearchCV\n\ngrid={\"C\":np.logspace(-2,2,5), \"penalty\":[\"l1\",\"l2\"]}\nlr_cv = GridSearchCV(LogisticRegression(solver='liblinear', random_state=20), grid, cv=cv2, scoring = 'f1')\n\npipeline_grid = Pipeline([('scale',scaler), ('gridsearch', lr_cv),])\n\npipeline_grid.fit(X_train2, y_train)\n\nprint(\"Best parameter: \", lr_cv.best_params_)\nprint(\"F-1 score: %.3f\" %lr_cv.best_score_)","7df2a454":"# Submit fine-tuned model\n\ny_test2 = pipeline_grid.predict(X_test2)\nsubmit2 = sub_sample.copy()\nsubmit2.target = y_test2\nsubmit2.to_csv('submit_lr2.csv',index=False)","a1896448":"# Top features with fine-tuned model\nplt.figure(figsize=(16,7))\ns1 = pd.Series(np.transpose(lr.coef_[0]), index=X_train2.columns).sort_values(ascending=False)[:20]\ns2 = pd.Series(np.transpose(lr.coef_[0]), index=X_train2.columns).sort_values()[:20]\nplt.subplot(121)\nsns.barplot(y=s1.index, x=s1)\nplt.title('Top positive coefficients')\nplt.subplot(122)\nsns.barplot(y=s2.index, x=s2)\nplt.title('Top negative coefficients')\nplt.show()","d6393460":"# Error analysis\ny_hat = pipeline_grid.predict_proba(X_train2)[:,1]\nchecker = train.loc[:,['text','keyword','location','target']]\nchecker['pred_prob'] = y_hat\nchecker['error'] = np.abs(checker['target'] - checker['pred_prob'])\n\n# Top 50 mispredicted tweets\nerror50 = checker.sort_values('error', ascending=False).head(50)\nerror50 = error50.rename_axis('id').reset_index()\nerror50.target.value_counts()","15d56cb8":"pd.options.display.max_colwidth = 200\n\nerror50.loc[0:10,['text','target','pred_prob']]","4cc3efc1":"# WordCloud","537228ab":"The top 3 locations with highest % of disaster tweets are **Mumbai, Inida, and Nigeria**. As the location data is not clean, we see some interesting cases, such as **'London, UK' saw a higher-than-average % of disaster tweets, but 'London' is below average**. We try to clean up the location and see if there is any difference:","92580b25":"## <a id='text'>5. Clean up Text Column<\/a>\n\nHere we clean up the text column by:\n- Making a 'clean' text column, removing links and unnecessary white spaces\n- Creating separate columns containing lists of hashtags, mentions, and links","e2cd91f2":"As location is free text, the data is not clean, you can see both 'USA' and 'United States' in top locations. We than have a look at % of disaster tweets for common locations.","26cf68b4":"There is no common top 10 keywords between disaster and non-disaster tweets.","bd704cda":"This forms the basis of evaluating and modifying our models in the next section.","e4551816":"Among the top 50 mispredicted tweets, only 4 are false positive","99eae5c1":"# Import libraries","c19360fc":"# Regression Technique","2d2dea00":"Default hyperparameters gave the best score.","b6f0047a":"# TD IDF Count","f1991291":"## <a id='gram'>7. Most frequent words and bigrams<\/a>\n\nWhat are the most common unigrams (single word) and bigrams (two-word sequence)?","4c5c6286":"Lets Visualize with the class imbalance thing !","ccfc24aa":"Train and test have the same set of keywords","774f9f54":"## <a id='basic'>1. Basic Exploration<\/a>","7798498e":"Next, we inspect the tweets that predicted probability differs the most from target outcome","14434157":"### <a id='simple'>9. Logistic Regression<\/a>\n\nWe try the simplest model with logistic regression, based on all features we created above. Before we fit a model, we first transform the features into the same scale with minimum 0 and maximum 1. We do this in the form of pipeline.","a73b9eea":"## <a id='encode'>8. Encoding and Vectorizers<\/a>\n\nAs part of feature generation, we will:\n- Apply target encoding to keyword and location (cleaned)\n- Count Vectorize cleaned text, links, hashtags and mentions columns","311beacd":"We then pick up the 1133 selected features to do Grid Search CV to find optimal hyperparameters","c7a96edd":"## <a id='location'>3. Locations<\/a>","36e85ffc":"## <a id='improve'>10. Evaluate and Improve Our Model<\/a>\n\nSeveral things will be done:\n- Cross validation with shuffle split\n- Feature selections\n- Grid search for hyperparameters\n- Identify errors\n\nReference: [scoring parameters](https:\/\/scikit-learn.org\/stable\/modules\/model_evaluation.html#scoring-parameter)","67dc1b9a":"A little improvement from the earlier model","20a222dd":"We try to distinguish disaster and non-disaster tweets:","db22c406":"# Feature Engineering","fbf5eb55":"Findings:\n- Top two words in disaster tweets: 'fire' and 'news', don't make the top 20 on unreal disaster tweets.\n- Words are more specific for real disaster tweets (e.g. 'califonia', 'hiroshima', 'fire', 'police', 'suicide', 'bomb').","9e41f61a":"# Cleaning the Data","80348a92":"# F1 SCORE","363e627f":"Findings:\n- 'keyword_target' is the top positive coefficient, meaning the keyword column made a good feature\n- hiroshima both as text and hashtag made the top 20 positive coefficients\n- Punctuation count and stop word count are among top 20 negative coefficients\n- None of the bigrams made the top features","047fec4b":"# Data Preprocessing Part","ffaf96c9":"## <a id='keyword'>2. Keywords<\/a>","21584e13":"# Confusion matrix","6d90819d":"Reading the tweet texts, it is quite strange that they are labelled as disaster tweets indeed.\n\nThat's it for now. Stay tuned for more analysis!","07d32e7f":"# Hypertuning","72cc1d1e":"# Basic NLP on Disaster Tweets\n\nThis is a getting started competition of predicting whether a tweet is actually referring to real disasters.\n\n### Competition Description\nTwitter has become an important communication channel in times of emergency.\nThe ubiquitousness of smartphones enables people to announce an emergency they\u2019re observing in real-time. Because of this, more agencies are interested in programatically monitoring Twitter (i.e. disaster relief organizations and news agencies.\n\nWell, Thanks to Holf Yuen for creating this amazing notebook.\n\n\nBefore going ahead to we should follow through the very basic things which are actively related with any machine learning problem along with this one too.\nF1 is calculated as follows:\n\n\n\n![image.png](attachment:image.png)\n\n\nTrue Positive [TP] = your prediction is 1, and the ground truth is also 1 - you predicted a positive and that's true!\n\nFalse Positive [FP] = your prediction is 1, and the ground truth is 0 - you predicted a positive, and that's false.\n\nFalse Negative [FN] = your prediction is 0, and the ground truth is 1 - you predicted a negative, and that's false.\n\nContents: in this notebook which will be coverd .\n\n* <a href='#basic'>Basic exploration<\/a>\n* <a href='#keyword'>Keywords<\/a>\n* <a href='#location'>Locations<\/a>\n* <a href='#text'>Clean up text<\/a>\n* <a href='#stat'>Text statistics<\/a>\n* <a href='#gram'>Unigrams and bigrams<\/a>\n* <a href='#encode'>Encoding and Vectorizers<\/a>\n* <a href='#simple'>Simple model<\/a>\n* <a href='#improve'>Evaluate and improve our model<\/a>","a08bb015":"## <a id='stat'>6. Create statistics from texts<\/a>","409f3e0c":"Findings:\n- Most top bigrams in disaster tweets show certain kinds of catestrophe (e.g. suicide bomber, oil spill, california wildfire); for non-disaster tweets, only 'burning buildings' as top bigram look like a disaster;\n- Top bigrams in disaster tweets have a more casual tone;\n- 'youtube' appears in three of the twenty bigrams for non-disaster tweets; none in disaster tweets","bbb84f40":"All of the statistics have very low correlation with the target variable","8c39f64a":"# Output data for Submission","4c5cd092":"From the above evaluation we understand that Text is all non-null. Only a small percentage of tweets have no keyword. Location has much more null values.","d402cacb":"There are 52 duplicated rows. The duplicates will be removed.","a58d4fb7":"Mumbai and Nigeria are still on the top. Other than the strange 'ss', London and New York made the bottom of % of disaster tweets."}}