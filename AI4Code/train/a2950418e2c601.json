{"cell_type":{"dd0ad154":"code","f8c96dc9":"code","595cc9fd":"code","9f9496af":"code","cc74624c":"code","b4d8223b":"code","0587851b":"code","838f1446":"code","0ae36b5c":"code","68e2b38b":"code","78c810bc":"markdown","dfef5217":"markdown","a4380299":"markdown","b05eebb6":"markdown","af8d0079":"markdown","61a1dc7a":"markdown","67fa535a":"markdown"},"source":{"dd0ad154":"import numpy as np \nimport pandas as pd \nimport os\nfrom biosppy import storage\nfrom biosppy.signals import ecg\nimport matplotlib.pyplot as plt","f8c96dc9":"import numpy as np\nimport pdb\nimport pywt\n\ndef upArrow_op(li, j):\n    if j == 0:\n        return [1]\n    N = len(li)\n    li_n = np.zeros(2 ** (j - 1) * (N - 1) + 1)\n    for i in range(N):\n        li_n[2 ** (j - 1) * i] = li[i]\n    return li_n\n\n\ndef period_list(li, N):\n    n = len(li)\n    # append [0 0 ...]\n    n_app = N - np.mod(n, N)\n    li = list(li)\n    li = li + [0] * n_app\n    if len(li) < 2 * N:\n        return np.array(li)\n    else:\n        li = np.array(li)\n        li = np.reshape(li, [-1, N])\n        li = np.sum(li, axis=0)\n        return li\n\n\ndef circular_convolve_mra(h_j_o, w_j):\n    ''' calculate the mra D_j'''\n    N = len(w_j)\n    l = np.arange(N)\n    D_j = np.zeros(N)\n    for t in range(N):\n        index = np.mod(t + l, N)\n        w_j_p = np.array([w_j[ind] for ind in index])\n        D_j[t] = (np.array(h_j_o) * w_j_p).sum()\n    return D_j\n\n\ndef circular_convolve_d(h_t, v_j_1, j):\n    '''\n    jth level decomposition\n    h_t: \\tilde{h} = h \/ sqrt(2)\n    v_j_1: v_{j-1}, the (j-1)th scale coefficients\n    return: w_j (or v_j)\n    '''\n    N = len(v_j_1)\n    L = len(h_t)\n    w_j = np.zeros(N)\n    l = np.arange(L)\n    for t in range(N):\n        index = np.mod(t - 2 ** (j - 1) * l, N)\n        v_p = np.array([v_j_1[ind] for ind in index])\n        w_j[t] = (np.array(h_t) * v_p).sum()\n    return w_j\n\n\ndef circular_convolve_s(h_t, g_t, w_j, v_j, j):\n    '''\n    (j-1)th level synthesis from w_j, w_j\n    see function circular_convolve_d\n    '''\n    N = len(v_j)\n    L = len(h_t)\n    v_j_1 = np.zeros(N)\n    l = np.arange(L)\n    for t in range(N):\n        index = np.mod(t + 2 ** (j - 1) * l, N)\n        w_p = np.array([w_j[ind] for ind in index])\n        v_p = np.array([v_j[ind] for ind in index])\n        v_j_1[t] = (np.array(h_t) * w_p).sum()\n        v_j_1[t] = v_j_1[t] + (np.array(g_t) * v_p).sum()\n    return v_j_1\n\n\ndef modwt(x, filters, level):\n    '''\n    filters: 'db1', 'db2', 'haar', ...\n    return: see matlab\n    '''\n    # filter\n    wavelet = pywt.Wavelet(filters)\n    h = wavelet.dec_hi\n    g = wavelet.dec_lo\n    h_t = np.array(h) \/ np.sqrt(2)\n    g_t = np.array(g) \/ np.sqrt(2)\n    wavecoeff = []\n    v_j_1 = x\n    for j in range(level):\n        w = circular_convolve_d(h_t, v_j_1, j + 1)\n        v_j_1 = circular_convolve_d(g_t, v_j_1, j + 1)\n        wavecoeff.append(w)\n    wavecoeff.append(v_j_1)\n    return np.vstack(wavecoeff)\n\n\ndef imodwt(w, filters):\n    ''' inverse modwt '''\n    # filter\n    wavelet = pywt.Wavelet(filters)\n    h = wavelet.dec_hi\n    g = wavelet.dec_lo\n    h_t = np.array(h) \/ np.sqrt(2)\n    g_t = np.array(g) \/ np.sqrt(2)\n    level = len(w) - 1\n    v_j = w[-1]\n    for jp in range(level):\n        j = level - jp - 1\n        v_j = circular_convolve_s(h_t, g_t, w[j], v_j, j + 1)\n    return v_j\n\n\ndef modwtmra(w, filters):\n    ''' Multiresolution analysis based on MODWT'''\n    # filter\n    wavelet = pywt.Wavelet(filters)\n    h = wavelet.dec_hi\n    g = wavelet.dec_lo\n    # D\n    level, N = w.shape\n    level = level - 1\n    D = []\n    g_j_part = [1]\n    for j in range(level):\n        # g_j_part\n        g_j_up = upArrow_op(g, j)\n        g_j_part = np.convolve(g_j_part, g_j_up)\n        # h_j_o\n        h_j_up = upArrow_op(h, j + 1)\n        h_j = np.convolve(g_j_part, h_j_up)\n        h_j_t = h_j \/ (2 ** ((j + 1) \/ 2.))\n        if j == 0: h_j_t = h \/ np.sqrt(2)\n        h_j_t_o = period_list(h_j_t, N)\n        D.append(circular_convolve_mra(h_j_t_o, w[j]))\n    # S\n    j = level - 1\n    g_j_up = upArrow_op(g, j + 1)\n    g_j = np.convolve(g_j_part, g_j_up)\n    g_j_t = g_j \/ (2 ** ((j + 1) \/ 2.))\n    g_j_t_o = period_list(g_j_t, N)\n    S = circular_convolve_mra(g_j_t_o, w[-1])\n    D.append(S)\n    return np.vstack(D)\n","595cc9fd":"def fix_broken_csv(file_name):\n    rf = open (os.path.join('..\/input',file_name), 'r')\n    ff = open(os.path.join('output',file_name), 'w')\n    line = rf.readline()\n    ff.write(line)\n    while line:\n        line = rf.readline()\n        line = line.replace(',AMEER','')\n        line = line.replace(',j',',0')\n        if \"03:51:35.125749,52303:52:33.684308,664\" in line:\n            ff.write(\"03:51:35.125749,523\\n\")\n            ff.write(\"03:52:33.684308,664\\n\")   \n        else:\n            ff.write(line)\n    rf.close()\n    ff.close()","9f9496af":"os.mkdir('output')\nall_files = os.listdir(\"..\/input\")\nall_files = np.array(all_files)[[\"ppg\" in x for x in  all_files]]\n[fix_broken_csv(f) for f in all_files]","cc74624c":"def load_gamer(x):\n    df = pd.read_csv('output\/gamer'+x+'-ppg-2000-01-01.csv')\n    df['Day'] = len(df)*[1]\n    df2 = pd.read_csv('output\/gamer'+x+'-ppg-2000-01-02.csv')\n    df2['Day']= len(df2)*[2]\n    df = df.append(df2, ignore_index=True) \n    return df","b4d8223b":"def peaks_to_series(signal, peaks):\n    pks=np.zeros(len(signal))\n    pks[peaks]=1\n    return pks","0587851b":"def filter_signal(signal, sampling_rate):\n    order = int(0.3 * sampling_rate)\n    filtered, _, _ = ecg.st.filter_signal(signal=signal,\n                                      ftype='FIR',\n                                      band='bandpass',\n                                      order=order,\n                                      frequency=[3, 45],\n                                      sampling_rate=sampling_rate)\n    \n    rpeaks, = ecg.hamilton_segmenter(signal=filtered, sampling_rate=sampling_rate)\n\n    \n    rpeaks_corrected, = ecg.correct_rpeaks(signal=filtered,\n                             rpeaks=rpeaks,\n                             sampling_rate=sampling_rate,\n                             tol=0.05)\n    \n    rpeaks = peaks_to_series(signal,rpeaks)\n    rpeaks_corrected = peaks_to_series(signal,rpeaks_corrected)\n    \n    return filtered, rpeaks, rpeaks_corrected","838f1446":"def process_gamer(x):\n    print(\"Processing Gamer #\", x)\n    df = load_gamer(x)\n    signal = df['Red_Signal'].values\n    out, rpeak, rpeak_corr = filter_signal(signal, sampling_rate=100.)\n    df['ecg_out']=out\n    df['rpeak']=rpeak\n    df['rpeak_corr']=rpeak_corr\n    df.to_csv('output\/gamer-'+x+'-ecg.csv', index=False)\n    del df\n    del signal\n    del out","0ae36b5c":"[process_gamer(gamer) for  gamer in [\"1\",\"2\",\"3\",\"4\",\"5\"]]","68e2b38b":"df=pd.read_csv('output\/gamer-1-ecg.csv') # try any of the GAMERS  \nminr=3000\nmaxr=6000\nnumber_of_freq=5\necgd=df['ecg_out'].values[minr:maxr]\nraw=df['Red_Signal'].values[minr:maxr]\nrp=df['rpeak'].values[minr:maxr]\nwt = modwt(ecgd, 'db2', number_of_freq)\nwtmra = modwtmra(wt, 'db2')\nfor i in range(len(wtmra)):\n    print (\"Wavlet Transfom \", i )\n    plt.plot(wtmra[i])\n    plt.show()    \n\nprint (\"de-noised signal\" )\nplt.plot(wtmra[4] + wtmra[5])\nplt.show()       \n    \nprint (\"Filtered Signal from ECG module\")    \nplt.plot(ecgd)\nplt.show()\n\nprint (\"Raw Signal\")    \nplt.plot(raw)\nplt.show()\n\nprint (\"R-Peaks from ECG module\")\nplt.plot(raw*rp)\nplt.show()\n","78c810bc":"#### Filter the Signal and evaluate R Peaks using the Biosppy ECG module","dfef5217":"##  Working with Canaria 5 Gamers dataset.  \n #### We'll try biosppy ecg signal processing module  & some wavelet transformations\n more infomation can be found in this repo  https:\/\/github.com\/sheriefkhorshid\/canaria-5gamers","a4380299":"####   Repair errors in the CSV files","b05eebb6":"#### Look  the results & try some Wavelet transformations on the filtered signal  ","af8d0079":"### use wavelets from https:\/\/github.com\/pistonly\/modwtpy.git","61a1dc7a":"### Conclusions \nThe raw data seems too noisy to get a reliable signal to be used for r-peak detection  ","67fa535a":"##### Generate filtered signal files for each gamer ( NOTE this is not fast ... go get a coffee) "}}