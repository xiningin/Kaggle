{"cell_type":{"cb61b959":"code","b8224139":"code","91c8a4f5":"code","9ab0e957":"code","9aba5702":"code","7fcde0ee":"code","bef3338a":"code","7ea2f980":"markdown","4221ef7c":"markdown","faeda7e4":"markdown","578b979f":"markdown","02fe1fe8":"markdown"},"source":{"cb61b959":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nfrom tqdm import tqdm\nfrom itertools import combinations\nimport networkx as nx\nimport gc\nimport plotly.graph_objects as go\n\n!pip install datatable > \/dev\/null\nimport datatable as dt\n\npd.set_option('display.max_columns', None)\nwarnings.filterwarnings('ignore')\nsns.set()\n\n\ndt_train_data = dt.fread('\/kaggle\/input\/jane-street-market-prediction\/train.csv')\ntrain = dt_train_data.to_pandas()\n\ndel dt_train_data\ngc.collect()\n\ntrain = train.astype({col: np.float32 for col in train.select_dtypes(include='float64').columns})\nfeature_cols = [col for col in train.columns if \"feature\" in col]","b8224139":"def calc_missing_value_share_rate(is_nan_df):\n    share = list()\n    for f_i in is_nan_df.columns:\n        row = list()\n        for f_j in is_nan_df.columns:\n            cap = np.logical_and(is_nan_df[f_i].values, is_nan_df[f_j].values).sum()\n            cup = (~np.logical_and((~is_nan_df[f_i].values), (~is_nan_df[f_j].values))).sum()\n            if cup > 0:\n                row.append(cap \/ cup)\n            else:\n                row.append(0)\n        share.append(row)\n    mv_sr_df = pd.DataFrame(share, index=is_nan_df.columns, columns=is_nan_df.columns)\n    return mv_sr_df\n\n\ndef plot_share_rate_hist(mv_sr_df):\n    index = mv_sr_df.index\n    sr = list()\n    for i in range(len(index)):\n        for j in range(i + 1, len(index)):\n            sr.append(mv_sr_df.loc[index[i], index[j]])\n    fig, axs = plt.subplots(1, 2, figsize=(15, 6))\n    for i in range(2):\n        axs[i].hist(sr, bins=100)\n        axs[i].set_ylabel('number')\n        axs[i].set_xlabel('missing value share rate')\n    axs[1].set_xlim((0.5, 1.0))\n    axs[1].set_ylim(0, 400)\n    plt.show()\n\n\ndef find_high_share_rate_cluster(mv_sr_df, thr):\n    index = mv_sr_df.index\n    edges = list()\n    for i in range(len(index)):\n        for j in range(i + 1, len(index)):\n            sr = mv_sr_df.loc[index[i], index[j]]\n            if sr >= thr:\n                edges.append((index[i], index[j]))\n                \n    G = nx.Graph()\n    G.add_edges_from(edges)\n    hsr_cluster = list()\n    for cmp_graph in nx.find_cliques(G):\n        hsr_cluster.append(cmp_graph)\n    return hsr_cluster","91c8a4f5":"mv_sr_df = calc_missing_value_share_rate(train[feature_cols[:-2]].isnull())\nmv_sr_df.style.background_gradient(cmap='Blues')","9ab0e957":"grp = find_high_share_rate_cluster(mv_sr_df, 0.9)","9aba5702":"i = 5\nprint(grp[i])\nmv_sr_df.loc[grp[i], grp[i]].style.background_gradient(cmap='Blues', vmax=1, vmin=0)","7fcde0ee":"def plot_correlation_graph(groups, n_size=3, figsize=(1500, 1000), k=0.3):\n    graph = nx.Graph()\n   \n    for grp in groups:\n        grp_nodes = list()\n        for f_no in [int(f.replace('feature_', '')) for f in grp]:\n            graph.add_node(f_no)\n            grp_nodes.append(f_no)\n        for p in combinations(grp_nodes, 2):\n            graph.add_edge(p[0], p[1])\n    pos = nx.spring_layout(graph, k=k, seed=1)\n    for node in graph.nodes():\n        graph.nodes[node][\"pos\"] = pos[node]\n        \n    node_x = []\n    node_y = []\n    text = []\n    for n in graph.nodes():\n        x, y = graph.nodes[n][\"pos\"]\n        node_x.append(x)\n        node_y.append(y)\n        text.append(f\"feature {n}\")\n\n    nodes = go.Scatter(\n        x=node_x,\n        y=node_y,\n        mode=\"markers+text\",\n        marker=dict(size=n_size, line=dict(width=2)),\n        text=text,\n        textposition=\"top center\",\n        hoverinfo='none'\n    )\n\n    edge_x = []\n    edge_y = []\n    for e in graph.edges():\n        x0, y0 = graph.nodes[e[0]][\"pos\"]\n        x1, y1 = graph.nodes[e[1]][\"pos\"]\n        edge_x.append(x0)\n        edge_y.append(y0)\n        edge_x.append(x1)\n        edge_y.append(y1)\n        edge_x.append(None)\n        edge_y.append(None)\n\n    edges = go.Scatter(\n        x=edge_x,\n        y=edge_y,\n        mode=\"lines\",\n        line=dict(width=2),\n    ) \n\n    fig = go.Figure(\n        data=[edges, nodes],\n        layout=go.Layout(\n            showlegend=False,\n            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n            plot_bgcolor=\"rgba(0, 0, 0, 0)\",\n            paper_bgcolor=\"rgba(0, 0, 0, 0)\",\n            width=figsize[0],\n            height=figsize[1]\n        ),\n    )\n    fig.show()","bef3338a":"plot_correlation_graph(\n    grp,\n    n_size=3,\n    figsize=(1500, 1000),\n    k=0.5\n)","7ea2f980":"We can see that there are some kind of groups in features, because some columns have missing values at the some time.","4221ef7c":"We can use graph representation to find feature groups with highly shared missing values.\n- node: feature\n- edge: pair of features that share missing values ('missing value share rate' >= 'threshold')\n\nFeatures in a group create a complete graph in which every nodes is connected by edges.\n\n\u203b Note that loops and multiple edges are ignored","faeda7e4":"Thank you for watching!!","578b979f":"- cup_ij : number of rows having a missing value in ***column i*** or ***column j***\n- cap_ij : number of rows having a missing value in ***column i*** and ***column j***\n\nThen, ***missing value share rate*** between ***column i*** and ***column j*** is cap_ij \/ cup_i.","02fe1fe8":"- example"}}