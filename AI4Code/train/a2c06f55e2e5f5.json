{"cell_type":{"3efa8af6":"code","45fa8ce9":"code","3ed7adc4":"code","66e24995":"code","26f20dc3":"code","b681179c":"code","eb2e25e5":"code","ca16b367":"code","4a094136":"code","28711f6a":"code","14d76ba6":"code","7eb9b091":"code","303f387c":"code","8e893dc2":"code","99ee5c0f":"code","c012244b":"code","b85df40f":"code","9c217646":"code","f8f5d44f":"code","ce5c82e9":"code","656899b8":"code","3bffff14":"code","ebe5f771":"code","f5ca60da":"markdown","0b3347af":"markdown","afff6a0d":"markdown","c971df14":"markdown","4e74875b":"markdown","0e0b263b":"markdown","ec7914a6":"markdown","7c236db9":"markdown","452c0b68":"markdown","bc9f31cd":"markdown","c2f57f1a":"markdown","47b6842d":"markdown","911be755":"markdown","092291f6":"markdown","859a7a4a":"markdown","c63b30b8":"markdown","75928108":"markdown","1806a249":"markdown","f7c0bb44":"markdown","0e6a0603":"markdown","adb57b9f":"markdown","c7cb7999":"markdown","31fd0cf3":"markdown"},"source":{"3efa8af6":"!pip install datatable > \/dev\/null","45fa8ce9":"import os\nimport gc\n\nimport numpy as np\nimport pandas as pd\nimport datatable as dt\nimport matplotlib.pyplot as plt","3ed7adc4":"root_dir = \"\/kaggle\/input\/jane-street-market-prediction\/\"","66e24995":"%%time\n\ndf = dt.fread(f\"{root_dir}train.csv\").to_pandas()\nsample_sub = dt.fread(f\"{root_dir}example_sample_submission.csv\").to_pandas()","26f20dc3":"df","b681179c":"fig, ax = plt.subplots(figsize=(15, 5))\nax.set_xlabel (\"Trade\", fontsize=18)\nax.set_ylabel (\"Cumulative return\", fontsize=18)\nplt.plot(pd.Series(df['resp']).cumsum())","eb2e25e5":"fig, ax = plt.subplots(figsize=(15, 5))\nax.set_xlabel (\"Trade\", fontsize=18)\nax.set_ylabel (\"Cumulative return\", fontsize=18)\n\ndf['resp'].cumsum().plot()\ndf['resp_1'].cumsum().plot()\ndf['resp_2'].cumsum().plot()\ndf['resp_3'].cumsum().plot()\ndf['resp_4'].cumsum().plot()\n\nplt.legend(loc=\"upper left\")","ca16b367":"fig, ax = plt.subplots(figsize=(15, 5))\nax.set_xlabel (\"Trade\", fontsize=18)\nax.set_ylabel (\"Cumulative return\", fontsize=18)\npd.Series(df['resp']*df[\"weight\"], name=\"weighted_resp\").cumsum().plot()\npd.Series(df['resp_1']*df[\"weight\"], name=\"weighted_resp_1\").cumsum().plot()\npd.Series(df['resp_2']*df[\"weight\"], name=\"weighted_resp_2\").cumsum().plot()\npd.Series(df['resp_3']*df[\"weight\"], name=\"weighted_resp_3\").cumsum().plot()\npd.Series(df['resp_4']*df[\"weight\"], name=\"weighted_resp_4\").cumsum().plot()\nplt.legend(loc=\"upper left\")\n","4a094136":"resp_cols = [col for col in df.columns if col.startswith(\"resp\")]","28711f6a":"(df[resp_cols[:-1]].mean(1)).cumsum().plot()","14d76ba6":"day_0 = df[df[\"date\"]==0]","7eb9b091":"day_0","303f387c":"fig, ax = plt.subplots(figsize=(15, 5))\nax.set_xlabel (\"Trade\", fontsize=18)\nax.set_ylabel (\"Cumulative return for a day\", fontsize=18)\n\nday_0['resp'].cumsum().plot()\nday_0['resp_1'].cumsum().plot()\nday_0['resp_2'].cumsum().plot()\nday_0['resp_3'].cumsum().plot()\nday_0['resp_4'].cumsum().plot()\n\nplt.legend(loc=\"upper left\")","8e893dc2":"fig, ax = plt.subplots(figsize=(15, 5))\nax.set_xlabel (\"Trade\", fontsize=18)\nax.set_ylabel (\"Cumulative return for a day\", fontsize=18)\npd.Series(day_0['resp']*day_0[\"weight\"], name=\"weighted_resp\").cumsum().plot()\npd.Series(day_0['resp_1']*day_0[\"weight\"], name=\"weighted_resp_1\").cumsum().plot()\npd.Series(day_0['resp_2']*day_0[\"weight\"], name=\"weighted_resp_2\").cumsum().plot()\npd.Series(day_0['resp_3']*day_0[\"weight\"], name=\"weighted_resp_3\").cumsum().plot()\npd.Series(day_0['resp_4']*day_0[\"weight\"], name=\"weighted_resp_4\").cumsum().plot()\nplt.legend(loc=\"upper left\")\n","99ee5c0f":"grouped = df.groupby(\"date\")","c012244b":"fig, ax = plt.subplots(figsize=(15, 5))\nax.set_xlabel (\"Trade\", fontsize=18)\nax.set_ylabel (\"Cumulative return\", fontsize=18)\n\n(pd.Series(grouped[\"resp\"].sum() * grouped[\"weight\"].sum(), name = \"grouped_weigh_resp\")).cumsum().plot()\n(pd.Series(grouped[\"resp_1\"].sum() * grouped[\"weight\"].sum(), name = \"grouped_weigh_resp_1\")).cumsum().plot()\n(pd.Series(grouped[\"resp_2\"].sum() * grouped[\"weight\"].sum(), name = \"grouped_weigh_resp_2\")).cumsum().plot()\n(pd.Series(grouped[\"resp_3\"].sum() * grouped[\"weight\"].sum(), name = \"grouped_weigh_resp_3\")).cumsum().plot()\n(pd.Series(grouped[\"resp_4\"].sum() * grouped[\"weight\"].sum(), name = \"grouped_weigh_resp_4\")).cumsum().plot()\n\nplt.legend(loc=\"upper left\")","b85df40f":"df['action'] = ((df['resp'])>0)*1","9c217646":"df[df[\"action\"]==1]","f8f5d44f":"p_i = (day_0[\"weight\"] * day_0[\"resp\"] * 1).sum()\nprint(p_i)","ce5c82e9":"p_i = (day_0[\"weight\"] * day_0[\"resp\"] * 0).sum()\nprint(p_i)","656899b8":"p_i = (day_0[\"weight\"] * day_0[\"resp\"] * (df[\"resp\"]>0)*1).sum()\nprint(p_i)","3bffff14":"n_days = len(df[\"date\"].unique())\npi_arr = []\n\nfor i in range(n_days):\n    \n    #considering the best opportunities where resp is positive\n    p_i = (\n        df[df[\"date\"] == i][\"weight\"]\n        * df[df[\"date\"] == i][\"resp\"]\n        * (df[df[\"date\"] == i][\"resp\"] > 0) * 1\n    ).sum()\n    \n    pi_arr.append(p_i)\n\npi_arr = np.array(pi_arr)\n\nt = (pi_arr.sum() \/ np.sqrt((pi_arr ** 2).sum())) * np.sqrt(250\/n_days);\nprint(f\"t: {t}\")\n\nutility_score = np.minimum(np.maximum(t, 0), 6) * pi_arr.sum()\nprint(f\"Utility score for {n_days} days: {utility_score}\")","ebe5f771":"n_days = len(df[\"date\"].unique())\npi_arr = []\n\nfor i in range(n_days):\n    \n    #considering all the trades\n    p_i = (\n        df[df[\"date\"] == i][\"weight\"]\n        * df[df[\"date\"] == i][\"resp\"]\n        * 1\n    ).sum()\n    \n    pi_arr.append(p_i)\n\npi_arr = np.array(pi_arr)\n\nt = (pi_arr.sum() \/ np.sqrt((pi_arr ** 2).sum())) * np.sqrt(250\/n_days);\nprint(f\"t: {t}\")\n\nutility_score = np.minimum(np.maximum(t, 0), 6) * pi_arr.sum()\nprint(f\"Utility score for {n_days} days: {utility_score}\")","f5ca60da":"Since the decisions made are with a time-stamp, we can check how much return we can get in a day","0b3347af":"## Returns for a day","afff6a0d":"## Utility function for a date\n\nhttps:\/\/www.kaggle.com\/renataghisloti\/understanding-the-utility-score-function\n","c971df14":"So, the utility function scores based on daily overall returns.","4e74875b":"If we take weighted `resp` as an indication of return, let's see overall return\n\nhttps:\/\/www.kaggle.com\/carlmcbrideellis\/jane-street-eda-of-day-0-and-feature-importance","0e0b263b":"### t_i\n\n#### $$ t = \\frac{\\sum p_i }{\\sqrt{\\sum p_i^2}} * \\sqrt{\\frac{250}{|i|}}, $$\n\nwhere |i| is the number of unique dates in the test set. 250 seems to indicate a span of trading for a year. \n\n**So, I guess t_i is the daily sharpe ration annualized.** \n\nlet's take 10 days of trades","ec7914a6":"Only trades with positive `resp`. the max p_i we can have for a day","7c236db9":"#### No trades executed","452c0b68":"## Grouping by date","bc9f31cd":"## Combining resps","c2f57f1a":"`resp` has better comulative returns than the mean of other resps","47b6842d":"#### Weighted resp => returns","911be755":"## Evaluation\n\n> This competition is evaluated on a utility score. Each row in the test set represents a trading opportunity for which you will be predicting an action value, 1 to make the trade and 0 to pass on it. Each trade j has an associated weight and resp, which represents a return.\n\nFor each date i, we define:\n\n#### $$ p_i = \\sum_j(weight_{ij} * resp_{ij} * action_{ij}), $$\n#### $$ t = \\frac{\\sum p_i }{\\sqrt{\\sum p_i^2}} * \\sqrt{\\frac{250}{|i|}}, $$\nwhere |i| is the number of unique dates in the test set. \nThe utility is then defined as:\n#### $$u = min(max(t,0), 6)  \\sum p_i.$$","092291f6":"Looks like `resp_4` is holding good for longer time horizons and `resp` is highly correlated to that","859a7a4a":"### Making a target\n\nSince this is the maxilum utility score we can achieve on training data\n\nWe can set action = 1 for all the rows which contributes to higher utility score and others as 0.","c63b30b8":"> This dataset contains an anonymized set of features, feature_{0...129}, representing real stock market data. Each row in the dataset represents a trading opportunity, for which you will be predicting an action value: 1 to make the trade and 0 to pass on it. \n\nWe can see the features here grouped into dates along with `resp`\n\n> Each trade has an associated weight and resp, which together represents a return on the trade. The date column is an integer which represents the day of the trade, while ts_id represents a time ordering.\n\n`resp * weight` seems to be an indication of return for that trading oppurtinity\n\n>In the training set, train.csv, you are provided a resp value, as well as several other resp_{1,2,3,4} values that represent returns over different time horizons. \n\nOther `resp_{1, 2, 3, 4}` also represents the returns over different [time horizons](https:\/\/www.investopedia.com\/terms\/t\/timehorizon.asp)","75928108":"## Cumulative return","1806a249":"## Action\n\nLet's use positive `resp` as an indication of making a trade","f7c0bb44":"### Weight","0e6a0603":"This also includes the trades with zero weights and the ones which should be avoided","adb57b9f":"Let's see how other `resp`'s performed","c7cb7999":"#### All trades executed","31fd0cf3":"### p_i\n\n#### $$ p_i = \\sum_j(weight_{ij} * resp_{ij} * action_{ij}), $$"}}