{"cell_type":{"9fc068e1":"code","6bcc3d29":"code","ca7fe8d2":"code","64db7700":"code","d5396d1a":"code","4c3c13a7":"code","88d2ec25":"code","e82f4b23":"code","711e9c5a":"code","61dbb967":"code","2db1df34":"code","ad46a375":"code","3a378db0":"code","e49f5cc7":"code","8bdcc487":"code","dcc63901":"code","1395e52d":"code","96fc2e75":"code","8b43b2c7":"code","232fd0b1":"code","e35d429f":"code","5cb4f4dc":"code","94dcc6bb":"code","9da801cf":"code","03c84a99":"code","b26b810a":"code","96e282a9":"code","c4384bd5":"code","ae1e58be":"code","0cf582bd":"code","9a740ab5":"code","49a6e78d":"code","6e1ca497":"code","9ed85e13":"code","ecf72fd3":"code","7910f2b4":"code","65078004":"code","672273a3":"code","1f1ea81d":"code","43c2030b":"markdown","e7d5cea5":"markdown","6de1ce6b":"markdown","c4a21f07":"markdown","7e81eb0f":"markdown","42766826":"markdown","2b3d6b41":"markdown","07507bab":"markdown","8e3f795d":"markdown","9de7dd99":"markdown","e7ec3af3":"markdown","aa025dfc":"markdown","7041ca62":"markdown","0574ca2b":"markdown","1d7a5691":"markdown","a194adaa":"markdown","68a8fa0e":"markdown","df4e1d2e":"markdown","52f3490f":"markdown","67b7cd78":"markdown","0fb5b85b":"markdown","67a65ddc":"markdown","1b25ce44":"markdown","5cf97db9":"markdown","741ca808":"markdown","c40af3e4":"markdown","164627bb":"markdown","49ca9b5b":"markdown","bd3dd0e6":"markdown","7af454de":"markdown","12063fa7":"markdown","2d8511ae":"markdown","e9f83eef":"markdown","011864a7":"markdown","4b22f276":"markdown","299812ff":"markdown","6ad55628":"markdown","3f609b8e":"markdown","71ea4e34":"markdown","83f0594c":"markdown","66ab93f3":"markdown","69ec00c0":"markdown","f22538b9":"markdown","5320e033":"markdown","825dd3be":"markdown","cd40b927":"markdown","ed329c00":"markdown","467ad615":"markdown","dd2e32a2":"markdown","1ec75c19":"markdown","30f6831d":"markdown","cbd79ea5":"markdown"},"source":{"9fc068e1":"%%latex inline\n\n$$\\Delta_{n} = [infectious_{(n-1)} - infectious_{(n-1-X)}]*r$$\n$$healthy_{n} = healthy_{(n-1)}-\\Delta_{n}$$\n$$infectious_{n} = [infectious_{(n-1)}-infectious_{(n-1-X)}] + \\Delta_{n}$$\n$$cured_{n} = [cured_{(n-1)}+infectious_{(n-1-X)}]*mortality{\\_}rate$$\n$$victims_{n} = victims_{(n-1)}+infectious_{(n-1-X)}*mortality{\\_}rate$$","6bcc3d29":"%%latex inline\n$$\\Delta_{n} = min(infectious{\\_}after_{\\_}decay*logistic{\\_}factor*oscillation{\\_}1*oscillation{\\_}2*(r\/100)),$$","ca7fe8d2":"%%latex inline\n$$logistic{\\_}factor = \\frac{remaining{\\_}healthy}{total{\\_}population}$$","64db7700":"%%latex inline\n\n$$\\Delta_{n} = [infectious_{(n-1)} - infectious_{(n-1-X)}]*r$$","d5396d1a":"%%latex inline\n\n$$u(n) = r^{(no{\\_}of{\\_}days{\\_}since{\\_}start{\\_}of{\\_}epidemic)}$$\n$$\\therefore$$\n$$u(n-5) = r^{(no{\\_}of{\\_}days{\\_}since{\\_}start{\\_}of{\\_}epidemic-5)}$$\n$$\\implies$$\n$$no{\\_}of{\\_}days{\\_}since{\\_}start{\\_}of{\\_}epidemic=\\frac{ln(un(n))}{ln(r)}$$","4c3c13a7":"%%latex inline\n$$mortality{\\_}rate = \\frac{no{\\_}of{\\_}deaths}{no{\\_}of{\\_}cases}$$","88d2ec25":"%%latex inline\n$$T_{d} = \\frac{ln(2)}{ln(1+\\frac{r}{100})}$$","e82f4b23":"import datetime \nfrom datetime import date\nimport math\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport matplotlib.pylab as plt","711e9c5a":"#!pip install chart_studio","61dbb967":"import numpy as np\nimport matplotlib.pyplot as plt\n#import joypy\nimport pandas as pd\nfrom string import ascii_letters\nimport seaborn as sns\n\nimport chart_studio\nimport plotly\n# plotly standard imports\nimport plotly.graph_objs as go\nimport chart_studio.plotly as py\nfrom plotly import tools\n\n# Cufflinks wrapper on plotly\nimport cufflinks as cf\n\n# Options for pandas\npd.options.display.max_columns = None\n\n# Display all cell outputs\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = 'all'\n\nfrom plotly.offline import iplot, init_notebook_mode, plot\ncf.go_offline()\n\ninit_notebook_mode(connected=False)\n\n# Set global theme\ncf.set_config_file(world_readable=True, theme='pearl')\n\nimport warnings  \nwarnings.filterwarnings('ignore')\nnp.seterr(divide='ignore', invalid='ignore')","2db1df34":"def estimates_unknown_previous_new_cases(first_known_val, distance, growth_rate):\n    \"\"\"\n    when we start the simulation, some data is often missing, especially the number of new cases in the previous days. \n    This function allow to estimates the missing point based on the growth rate and the the first known value\n    \"\"\"\n    # the new cases doesn't follow exactly the growth rate because of the decay\n    ajusted_growth_rate = growth_rate * 0.9759453945528388\n    n = math.log(first_known_val)\/ math.log( ajusted_growth_rate)\n    if distance > n:\n        result = 0\n    else:\n        result =ajusted_growth_rate**(n - distance)\n    #print(first_known_val, distance, result )\n    return result\nexamples = [ 1.1**i for i in range(1,21)]\n\n#examples, estimates_unknown_previous_new_cases(examples[-1], 2, 1.1)","ad46a375":"mu=-15 \nsigma=3\nbins = np.array([i for i in range(2* mu -1 , -1)])\nnormal_distrib = 1\/(sigma * np.sqrt(2 * np.pi)) * np.exp( - (bins - mu)**2 \/ (2 * sigma**2) )\nplt.scatter(bins, normal_distrib)","3a378db0":"def refined_infecious_removal(deltas, growth_rate, mu=-15, sigma=3):\n    \"\"\"\n    follow a normal distribution pattern for the time people stay infected instead or removing the infecious of X days before\n    \"\"\"\n    bins = np.array([i for i in range(2* mu -1 , -1)])\n    normal_distrib = 1\/(sigma * np.sqrt(2 * np.pi)) * np.exp( - (bins - mu)**2 \/ (2 * sigma**2) )\n    \n    return np.sum(\n        [\n            deltas[deltas_i] * normal_distrib[i] \n            if len(deltas) > abs(deltas_i) \n            else estimates_unknown_previous_new_cases(\n                deltas[0], \n                abs(len(deltas) + deltas_i), \n                growth_rate\n            ) * normal_distrib[i] \n            for i, deltas_i in enumerate(bins)\n        ]\n    )\ndeltas = [100 * 1.1**i for i in range(15, 31)]\n#deltas, refined_infecious_removal(deltas, growth_rate=1.1)","e49f5cc7":"def generate_series(population, doubling_time, todays_estimates, today_cured=4, today_dead=0, today_new_cases=0, mortality_rate=0.00, hospitalization_rate=0.02, infection_time=15, number_of_days_to_simulate=200, with_annealing=None, with_season=None, use_normal_ditribution_cure=False):\n    # calculate contant grow time per day\n    r = 70\/doubling_time\n    \n    uninfected = [population]\n    infectious = [todays_estimates]\n    needs_hospitalization = [todays_estimates * hospitalization_rate]\n    mild_cases = [todays_estimates * (1- hospitalization_rate)]\n    cured = [today_cured]\n    \n    dead = [today_dead]\n    \n    deltas = [todays_estimates - estimates_unknown_previous_new_cases(todays_estimates, 1, 1+r\/100)]\n\n    if  with_annealing is None:\n        x = np.ones(2) \n    else:\n        x = with_annealing \n    \n    if  with_season is None:\n        xs = np.ones(2) \n    else:\n        xs = with_season \n    \n    print(\"daily increase :\",r, '%', 1 + r\/100,'mortality rate:',mortality_rate)\n    for i in range(number_of_days_to_simulate):\n        if use_normal_ditribution_cure:\n            decay = refined_infecious_removal(deltas, 1 + r\/100, mu=-infection_time, sigma = infection_time \/ 5)\n        else:\n            decay = 0\n            # people get cured and gain immunity\n            if i >= infection_time:\n                decay = deltas[-infection_time]\n          \n        cured.append(cured[-1] + decay * (1 - mortality_rate))\n        # mortality\n        dead.append(dead[-1]+ decay * ( mortality_rate))\n        # still infectious people after removing cured people\n        infectious_after_decay = max(infectious[-1] - decay, 0)\n        # fraction of the population still uninfected\n        logistic_factor = uninfected[-1]\/ uninfected[0]\n        \n        \n        delta = min(infectious_after_decay * logistic_factor * x[i % x.shape[0]] * xs[i % xs.shape[0]] * r\/ 100, uninfected[-1])\n        #print(i, delta, infectious_after_decay, logistic_factor, r \/ 100, infectious[-1])\n        deltas.append(delta)\n        infectious.append(infectious_after_decay + delta)\n        uninfected.append(uninfected[-1] - delta)\n        needs_hospitalization.append(infectious[-1] * hospitalization_rate)\n        mild_cases.append(infectious[-1] * (1-hospitalization_rate))\n        if uninfected[-1] <= 0:\n            print('all contaminated')\n            break\n    \n    # search where we are in the logistic curve, we check when the \n \n    todays_i = 0\n    df_data = []\n    df_data2 = []\n    current_date = datetime.datetime.now()#datetime.datetime(2020, 3, 14, 10, 51, 45, 333977)\n    for i in range(todays_i, number_of_days_to_simulate):\n        df_data.append({\n            \"date\": current_date.strftime(\"%d\/%m\/%Y\"),\n            'infected': uninfected[0] - uninfected[i],\n            \"infectious\":infectious[i],\n            \"deltas\":deltas[i],\n            \"cured\":cured[i],\n            'dead':dead[i],\n            'uninfected':uninfected[i],\n            'severe_cases':needs_hospitalization[i] , \n            'mild_cases':mild_cases[i]\n            \n        })\n        \n        for t in [ 'cured', 'dead', 'severe_cases', 'mild_cases', 'uninfected']:\n            \n            df_data2.append({\n                \"i\":i,\n                \"date\": current_date.strftime(\"%d\/%m\/%Y\"),\n                \"count\":df_data[-1][t],\n                'type':t,\n                'country':'france'\n            })\n        current_date += datetime.timedelta(days=1)\n    return pd.DataFrame(df_data), pd.DataFrame(df_data2)","8bdcc487":"def plot(population, doubling_rate, currently_infectious, number_of_days_to_simulate,today_new_cases=0,mortality_rate=0.0, hospitalization_rate=0.02, with_annealing=None, with_season=None, use_normal_ditribution_cure=False):\n    df_country, df_c2 = generate_series(\n        population, \n        doubling_rate, \n        currently_infectious, \n        mortality_rate=mortality_rate, \n        hospitalization_rate=mortality_rate,\n        number_of_days_to_simulate=number_of_days_to_simulate,\n        today_new_cases=today_new_cases, \n        with_annealing=with_annealing, with_season=with_season, \n        use_normal_ditribution_cure=use_normal_ditribution_cure\n    )\n    \n    groups=[ 'cured', 'dead', 'severe_cases', 'mild_cases', 'uninfected']\n    fig = go.Figure(data=[ go.Bar(name=g, x=df_country[\"date\"], y=df_country[g] ) for g in groups])\n    fig.layout.update(barmode='stack',bargap=0,bargroupgap=0, title=\"Potential dynamics of Namibian population -- under various assumptions\",\n                      colorway=['#2cc70a','#000000','#fb1321','#636EFA','#8f968d'],plot_bgcolor='white')\n    #iplot(fig)\n\n    fig1 = go.Figure()\n    fig1.add_trace(go.Scatter(x=df_country[\"date\"], y=df_country[\"deltas\"], fill='tozeroy', name=\"New cases per day\")) # fill down to xaxis\n    fig1.add_trace(go.Scatter(x=df_country[\"date\"], y=df_country[\"severe_cases\"], fill='tozeroy', name='Severe cases')) # fill to trace0 y\n    fig1.layout.update( title=\"New cases per day and Severe cases\")\n    #iplot(fig1)\n    return iplot(fig),iplot(fig1)","dcc63901":"df_country, df_c2 = generate_series(2738406, 8, 16, today_new_cases=0, number_of_days_to_simulate=50, use_normal_ditribution_cure=True)\ndf_country.head(5)","1395e52d":"# NOTE: date changed\nplot(2738406, 8, 16, number_of_days_to_simulate=50, use_normal_ditribution_cure=True)","96fc2e75":"f_date = date(2020,3,14)\nl_date = date.today()\ndelta = l_date - f_date\n# does this work for the southern hemisphere!?\nportion_of_year = -2*np.pi * delta.days \/ 365\nx = np.linspace(portion_of_year, 2*np.pi +portion_of_year, 120)\n_ = plt.plot(x, (1 + np.cos(x))\/2  )","8b43b2c7":"plot(2738406, 8, 16, number_of_days_to_simulate=400, with_season=(1 + np.cos(np.linspace(portion_of_year, 2*np.pi +portion_of_year, 365))\/2 )) ","232fd0b1":"x = np.linspace(-np.pi, np.pi, 30)\n_ = plt.plot(x,(1 + np.cos(x))\/2)","e35d429f":"plot(2738406, 8, 16, number_of_days_to_simulate=200, with_annealing=(1 + np.cos(np.linspace(-np.pi, np.pi, 90))\/2 )) ","5cb4f4dc":"def generate_series(population, doubling_time, todays_estimates, today_cured, today_dead, today_new_cases, mortality_rate, hospitalization_rate, infection_time=15, number_of_days_to_simulate=200, with_annealing=None, with_season=None, use_normal_ditribution_cure=False):\n    # calculate contant grow time per day\n    r = 70\/doubling_time\n    \n    uninfected = [population]\n    infectious = [todays_estimates]\n    needs_hospitalization = [todays_estimates * hospitalization_rate]\n    mild_cases = [todays_estimates * (1- hospitalization_rate)]\n    cured = [today_cured]\n    \n    dead = [today_dead]\n    \n    deltas = [todays_estimates - estimates_unknown_previous_new_cases(todays_estimates, 1, 1+r\/100)]\n\n    if  with_annealing is None:\n        x = np.ones(2) \n    else:\n        x = with_annealing \n    \n    if  with_season is None:\n        xs = np.ones(2) \n    else:\n        xs = with_season \n    \n    print(\"daily increase :\",r, '%', 1 + r\/100,'mortality rate:',mortality_rate)\n    for i in range(number_of_days_to_simulate):\n        if use_normal_ditribution_cure:\n            decay = refined_infecious_removal(deltas, 1 + r\/100, mu=-infection_time, sigma = infection_time \/ 5)\n        else:\n            decay = 0\n            # people get cured and gain immunity\n            if i >= infection_time:\n                decay = deltas[-infection_time]\n          \n        cured.append(cured[-1] + decay * (1 - mortality_rate))\n        # mortality\n        dead.append(dead[-1]+ decay * ( mortality_rate))\n        # still infectious people after removing cured people\n        infectious_after_decay = max(infectious[-1] - decay, 0)\n        # fraction of the population still uninfected\n        logistic_factor = uninfected[-1]\/ uninfected[0]\n        \n        \n        delta = min(infectious_after_decay * logistic_factor * x[i % x.shape[0]] * xs[i % xs.shape[0]] * r\/ 100, uninfected[-1])\n        #print(i, delta, infectious_after_decay, logistic_factor, r \/ 100, infectious[-1])\n        deltas.append(delta)\n        infectious.append(infectious_after_decay + delta)\n        uninfected.append(uninfected[-1] - delta)\n        needs_hospitalization.append(infectious[-1] * hospitalization_rate)\n        mild_cases.append(infectious[-1] * (1-hospitalization_rate))\n        if uninfected[-1] <= 0:\n            print('all contaminated')\n            break\n    \n    # search where we are in the logistic curve, we check when the \n \n    todays_i = 0\n    df_data = []\n    df_data2 = []\n    current_date = datetime.datetime.now()#datetime.datetime(2020, 3, 14, 10, 51, 45, 333977)\n    for i in range(todays_i, number_of_days_to_simulate):\n        df_data.append({\n            \"date\": current_date.strftime(\"%d\/%m\/%Y\"),\n            'infected': uninfected[0] - uninfected[i],\n            \"infectious\":infectious[i],\n            \"deltas\":deltas[i],\n            \"cured\":cured[i],\n            'dead':dead[i],\n            'uninfected':uninfected[i],\n            'severe_cases':needs_hospitalization[i] , \n            'mild_cases':mild_cases[i]\n            \n        })\n        \n        for t in [ 'cured', 'dead', 'severe_cases', 'mild_cases', 'uninfected']:\n            \n            df_data2.append({\n                \"i\":i,\n                \"date\": current_date.strftime(\"%d\/%m\/%Y\"),\n                \"count\":df_data[-1][t],\n                'type':t,\n                'country':'france'\n            })\n        current_date += datetime.timedelta(days=1)\n    return pd.DataFrame(df_data), pd.DataFrame(df_data2)","94dcc6bb":"import panel as pn\nimport param\nimport altair as alt\nfrom altair import datum\nimport pandas as pd\n#from vega_datasets import data\nimport datetime as dt\n#alt.data_transformers.enable('default')","9da801cf":"\npn.extension('vega','plotly')","03c84a99":"# set a logo,title, and subtitle for your dashboard\nlogo  = \"\"\"<a href=\"http:\/\/panel.pyviz.org\">\n           <img src=\"https:\/\/encrypted-tbn0.gstatic.com\/images?q=tbn%3AANd9GcS5ACQVJ51yIZuRBmC5CwvjHrXCGNZDpceaBMroui3ZU6L_qa0A&usqp=CAU\" \n            width=200 height=160 align=\"center\" margin=20px>\"\"\"\n\ntitle = '## Interactive SIR Model and Dashboard'\nt1 = pn.pane.HTML('<marquee width=500><b>Model Assumptions<\/b><\/marquee>')\nsubtitle = \"This dashboard will allow Front-line staff and policy-makers will be able to plug and play with the tool, and gain insights into how the dynamics of covid-19 could play out, given various well informed assumptions. The latter could be used for planning the number of beds, masks, etc needed to combat the virus.\"","b26b810a":"slider_pop = pn.widgets.FloatSlider(name='Susceptible Namibian Population', width=400,start=1000,end=3000000,step=1)\npn.Column(slider_pop, width=400)","96e282a9":"slider_dt = pn.widgets.FloatSlider(name='Doubling Time', width=400,start=1,end=30,step=1)\npn.Column(slider_dt, width=400)","c4384bd5":"slider_pc = pn.widgets.FloatSlider(name='Current Positive Cases', width=400,start=1,end=10000,step=1)\npn.Column(slider_pc, width=400)","ae1e58be":"slider_recov = pn.widgets.FloatSlider(name='Number of Recoveries', width=400,start=1,end=1000,step=1)\npn.Column(slider_recov, width=400)","0cf582bd":"slider_dead = pn.widgets.FloatSlider(name='Number of dead', width=400,start=1,end=10000,step=1)\npn.Column(slider_dead, width=400)","9a740ab5":"slider_nc = pn.widgets.FloatSlider(name=\"Today's new cases\", width=400,start=0,end=100,step=1)\npn.Column(slider_nc, width=400)","49a6e78d":"slider_mr = pn.widgets.FloatSlider(name='Mortality rate', width=400,start=0.01,end=0.1,step=0.001)\npn.Column(slider_mr, width=400)","6e1ca497":"slider_hr = pn.widgets.FloatSlider(name='Rate of hospitalization', width=400,start=0.01,end=0.1,step=0.001)\npn.Column(slider_hr, width=400)","9ed85e13":"@pn.depends(slider_pop.param.value,slider_dt.param.value,slider_pc.param.value,slider_recov.param.value,slider_dead.param.value,slider_nc.param.value,slider_mr.param.value,slider_hr.param.value)\ndef plot_1(slider_pop, slider_dt, slider_pc,slider_recov,slider_dead,slider_nc,slider_mr, slider_hr,infection_time=15,number_of_days_to_simulate=200, with_annealing=None, with_season=None, use_normal_ditribution_cure=True):\n    df_country, df_c2 = generate_series(\n        slider_pop,\n        slider_dt, \n        slider_pc,\n        slider_recov,\n        slider_dead,\n        slider_nc, \n        slider_mr, \n        slider_hr,\n        infection_time=infection_time,\n        number_of_days_to_simulate=number_of_days_to_simulate,\n        with_annealing=with_annealing, with_season=with_season,\n        use_normal_ditribution_cure=use_normal_ditribution_cure\n    )\n    traces=[]\n    groups=[ 'cured', 'dead', 'severe_cases', 'mild_cases', 'uninfected']\n    for g in groups:\n        traces.append(go.Bar(name=g, x=df_country[\"date\"], y=df_country[g]))\n        layout = go.Layout(barmode='stack',bargap=0,bargroupgap=0, title=\"Potential dynamics of Namibian population -- under various assumptions\",\n                  colorway=['#2cc70a','#000000','#fb1321','#636EFA','#8f968d'],plot_bgcolor='white')\n    \n    return go.Figure(data=traces, layout=layout)","ecf72fd3":"@pn.depends(slider_pop.param.value,slider_dt.param.value,slider_pc.param.value,slider_recov.param.value,slider_dead.param.value,slider_nc.param.value,slider_mr.param.value,slider_hr.param.value)\ndef plot_2(slider_pop, slider_dt, slider_pc,slider_recov,slider_dead,slider_nc,slider_mr, slider_hr,infection_time=15,number_of_days_to_simulate=200, with_annealing=None, with_season=None, use_normal_ditribution_cure=True):\n    df_country, df_c2 = generate_series(\n        slider_pop,\n        slider_dt, \n        slider_pc,\n        slider_recov,\n        slider_dead,\n        slider_nc, \n        slider_mr, \n        slider_hr,\n        infection_time=infection_time,\n        number_of_days_to_simulate=number_of_days_to_simulate,\n        with_annealing=with_annealing, with_season=with_season,\n        use_normal_ditribution_cure=use_normal_ditribution_cure\n    )    \n\n    traces = []\n    traces.append(go.Scatter(x=df_country[\"date\"], y=df_country[\"deltas\"], fill='tozeroy', name=\"New cases per day\")) # fill down to xaxis\n    traces.append(go.Scatter(x=df_country[\"date\"], y=df_country[\"severe_cases\"], fill='tozeroy', name='Severe cases')) # fill to trace0 y\n    layout = go.Layout(title=\"New cases per day and Severe cases\")\n    return go.Figure(data=traces, layout=layout)","7910f2b4":"# create the Panel object, passing in all smaller objects\n'''First we create our single row. Then, we fill it with the contents of two columns. \nOur first column will contain our 1) title, 2) subtitle, 3) dropdown and 4) date slider.\nThe second column will display the chart.'''\ndashboard = pn.Row(\n    pn.Column(logo,title, subtitle,t1, slider_pop, slider_dt, slider_pc,slider_recov,slider_dead,slider_nc,slider_mr, slider_hr),\n    pn.Row(plot_1,plot_2)# draw chart function!\n)\n#pn.Row(pn.Column(plot_3,plot_4)","65078004":"# %%javascript\n# IPython.OutputArea.prototype._should_scroll = function(lines) {\n#     return false;\n# }","672273a3":"dashboard.servable()","1f1ea81d":"#!panel serve --show --port 5009 Modelling Covid-19 Spread.ipyn","43c2030b":"## Simulate a progressive stop of lockdown measures","e7d5cea5":"Then we need to add two special lines of code, one for Altair and one for Panel. The first tells Altair to set the Vega-Lite rendered to Jupyter Notebook (if you\u2019re using Jupyter Lab, check the Altair docs for alternative). The second line tells Panel to accept Vega (which powers Altair) as an extension. You can learn more about how extensions work in the components section of the Panel docs.","6de1ce6b":"For which the data is not available, so we estimate the number of new cases, because of the observed exponential growth in the beginning, using:","c4a21f07":"The recent spread of the COVID-19 virus, makes it paramount to better understand the dynamics of the virus, in terms of how it spreads, by leveraging the power of computer simulations and the use of some informed input parameters, to gain inights into how a change in parameters can drastically change the results.\n\nFor more info on the corona virus, please see the [CDC](https:\/\/www.cdc.gov\/coronavirus\/2019-ncov\/faq.html#Coronavirus-Disease-2019-Basics) website.","7e81eb0f":"### rate of hospitalization","42766826":"The spanish flu had 3 waves, the coronavirus could also be sensitive to seasons. we will use the following function to modulate the probability of the virus to infect new people. This function is close to 0 during summer months.","2b3d6b41":"Test all widgets:","07507bab":"### Function parameters ","8e3f795d":"## Sliders","9de7dd99":"#### Analysis and comments","e7ec3af3":"Namibia has a population of roughly 2,738,406 people [Source](https:\/\/countrymeters.info\/en\/Namibia). Since the last cases had doubled from March 28 (8 cases) to 16 on 05 April, this gives us a post lockdown doubling rate of every 8 days [worldometers](https:\/\/www.worldometers.info\/coronavirus\/country\/namibia\/), and an approximate number of infectious cases of 16.","aa025dfc":"## Title & Subtitle","7041ca62":"### Utilities functions\nestimates_unknown_previous_new_cases allow us to estimate missing data, when we initialiwe the first day, we don't want to add the last month of new cases and number of active cases. instead we can estimates them based on the fact that at the beginning of the epidemic the we have an exponential growth.","0574ca2b":"## SIR Model","1d7a5691":"### Recoveries","a194adaa":"# Dashboard","68a8fa0e":"## The different parameters","df4e1d2e":"## The SIR Model","52f3490f":"### mortality rate","67b7cd78":"<h1><center> Applying a simple epidemiological SIR model to COVID-19 spread in Namibia<\/center><\/h1>","0fb5b85b":"## Launching dashboard from terminal","67a65ddc":"### There are 3 main categories,\n\n- **Susceptible**: representing the population of individuals susceptible to the virus, \n- **Infected**, the people currently infected with the virus,\n- and **Recovered** (people that have either recovered or died).\n\nEach day, the people that where infected (**infection_time**) days before are transfered from infectious to cured or dead, the people still infectious infect new people. This constitues **delta**, the number of susceptibles that that become infected for the specific day.\n<br>\nThis delta is varing with the number of currently infectious people by a percentage **r** calculated with the doubling time (r = 70\/doubling_time) [Wikipedia](https:\/\/en.wikipedia.org\/wiki\/Doubling_time).\n\nThis delta is taken from uninfected, and become infectious, they will stop to be 15 days later, and so on...\n<br>\nThe model is an  implemention of The SIR Model Without Vital Dynamics from [Three Basic Epidemiological by HW Hethcote](https:\/\/link.springer.com\/chapter\/10.1007\/978-3-642-61317-3_5)\n<br>\nThe main difference is that instead of taking a % of the infectious pop to be cured, i take the population infected *infection_time* days before.","1b25ce44":"# Introduction","5cf97db9":"- We are yet to reach a peak, thus we expect exponential growth in the number of cases.","741ca808":"Here\u2019s what we are going to build: a COVID-19 dashboard, composed of multiple charts and various filters and slicers. We\u2019ll also add a title, subtitle, and some logo.","c40af3e4":"## Seasonality","164627bb":"## import necessary libraries","49ca9b5b":"* **no of days symptoms last:** Symptoms ussually last for 15 days in most cases.\n* **severity rate:** 2% (worldometers).\n* **Growth rate:** According to research by [Max Roser, Hannah Richie & Esteban Ortiz-Ospina (2020)](https:\/\/reaction.life\/how-to-model-a-coronavirus-pandemic\/older-people-are-more-likely-to-die-from-covid-19-than-the-population-as-a-whole-max-roser-hannah-ritchie-and-esteban-ortiz-ospina-2020-coronavirus-disease-covid-19-statistics-and-r\/), it makes more sense to look at the growth rate per country. Growth rate is calculated in terms of doubling time. **The doubling time, is the time required so that the infectious population is multiplied by two**.\n* **mortality rate:** most accurate when you look at the mortality rate of countries testing the most (e.g. South Korea and Germany)","bd3dd0e6":"* where \n    * **n:** represents the day\n    * **r:** the growth rate, expressed in terms of doubling time\n    * the calculation of \\Delta_{n} is slightly modified, as shown below to:","7af454de":"Once people recover, they become immune and thus cannot be infected again, which is the opposite of the SIS model. Here are the equations, governing the model:","12063fa7":"Instead of simply removing the cases from 15 days before, we can use a normal distribution to remove some cases on the days surrounding the average. This allow to simulate that some people heal in less than 15 days and some require more time. We use the distribution that we can see on the plot below to improve our estimation of cured patients","2d8511ae":"![title](https:\/\/wiki.eclipse.org\/images\/2\/27\/CMfig3.gif)","e9f83eef":"![title](https:\/\/s3-ap-southeast-1.amazonaws.com\/eatigo-blog\/wp-content\/uploads\/sites\/11\/2020\/02\/27155159\/TH_Flu-1080x608.png)","011864a7":"which allows us to make the simulation slightly more realistic, by taking into account waves of spreadings or changes in confinement policies.\n\n* **Min:** Ensures, we do not go over the population total.\n* **Logistic Factor:** takes into account, that the population is not infinite, implies virus can spread only among remaining healthy people, if 80% of the population have already been infected, this implies, only 1 person in 5 can be infected. it is calculated as:","4b22f276":"### today's new cases","299812ff":"## Scenario Testing","6ad55628":"Approach used here is based on an excellent article by Guillaume Ringwald, find it at [Link to Article](https:\/\/medium.com\/analytics-vidhya\/a-simple-epidemiological-model-applied-to-the-coronavirus-covid-19-244a8e3ca608).","3f609b8e":"Panel calls itself a \u201chigh-level app and dashboarding solution for Python\u201d and it\u2019s part of the HoloViz ecosystem managed by Anaconda. I\u2019d heard of HoloViz before (and it\u2019s relative overview site, PyViz), but never really spent the time to dive into the landscape. So here we go!\n\nAt first glance, what I love about Panel is that it is plotting-library-agnostic \u2014 it supports nearly all visualization libraries. So you don\u2019t have to be a loyal Altair user to learn a bit about making dashboards in this post. That being said, compared to the other code samples in the Panel example gallery, I think the integration with Altair feels really intuitive.\n\nHere are a few other really nice things about Panel:\n* It\u2019s reactive (updates automatically!)\n* It\u2019s declarative (readable code)\n* Supports different layouts (flexible)\n* Fully deployable to a server (shareable)\n* Jupyter Notebook compatible (but not dependent\u2026Altair, however, is dependent on Jupyter. So I don\u2019t advise trying this tutorial in something else.)","71ea4e34":"The following senario is for lockdown oscillating between total to semi open ( doubling time of 9 days, which is higher than South Korea but below all european country.\nThe growth rate oscillate between doubling every 10 days to no growth at all. ","83f0594c":"#### Analysis and comments","66ab93f3":"The function inputs in calculating the evolution of proportions of susceptibles, infected, recovered (cured or dead) people among a population as the virus spread\n - the size of the population\n - doubling time ( number of days for the number of infectious people to double)\n - number of infectious people today ( active cases)\n - current number of cured people\n - current number of dead people\n - number of new cases today\n - mortality rate (default from [worldometers](https:\/\/www.worldometers.info\/coronavirus\/country\/south-korea\/) nb of death \/ nb of cases ), \n - hospitalisation rate (default at 0.01 [worldometers](https:\/\/www.worldometers.info\/coronavirus\/country\/south-korea\/))\n - infection time. avegage number of days to heal or die\n - number of days to run the simulation\n - annealing is to simulate progressive lockdown and back to more freedom of move","69ec00c0":"#### Analysis and comments","f22538b9":"Place all sliders and graphs into a Panel object.","5320e033":"### Namibia with growth rate observed after the lockdown","825dd3be":"### Number of dead","cd40b927":"### current positive cases","ed329c00":"### doubling time","467ad615":"We will use the following function to describe the lockdown removal. After 3 months, the number of cases decreases, the economy does't look good and the government remove social distanciation measures progressively, until the disease spread again, so reintroduce it again and so on","dd2e32a2":"We can express the doubling time T_{d} in terms of a constant growth rate of r%, using","1ec75c19":"## Assumptions","30f6831d":"* **Oscillations:** take variations in growth into account, array of coeeficients that will be use periodically to adjust the growth rate.\n\n* **Improved decay estimations:** To take into account that some people take less than 15 days to recover and others more, we use a normal distribution to remove some cases on the days surrounding the average.\n\n* **The first calc of new cases:** The first number of new cases, requires data from X days ago:","cbd79ea5":"### population"}}