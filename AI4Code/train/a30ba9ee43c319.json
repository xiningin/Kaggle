{"cell_type":{"215e7e6c":"code","552a1a27":"code","64443793":"code","d81ab111":"code","f5bbf178":"code","02398a02":"code","f07f97e7":"code","86a10e06":"code","4ff3db11":"code","4d243263":"code","282b8489":"markdown","c2d9e98b":"markdown","c4955d59":"markdown","8dfc55d2":"markdown"},"source":{"215e7e6c":"# IMPORTS\nimport numpy as np\nimport pandas as pd\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix\n\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Conv1D, Flatten, MaxPooling1D, Dropout, LeakyReLU","552a1a27":"# Load information about the stock\nstonks = 'fdx.us.txt'\ndf = pd.read_csv('\/kaggle\/input\/price-volume-data-for-all-us-stocks-etfs\/Stocks\/'+stonks)\nprint(df.info())","64443793":"# Compute labels automatically based on the method given in the paper\n# If value is greater 10 day ahead then label current day \"buy (1)\" otherwise \"sell (0)\"\ndf['Open10'] = df['Open'].shift(periods=-10)\ndf = df.dropna()\ndf['label'] = np.where(df['Open'] < df['Open10'], 1, 0)\n\n\n# Drop useless columns, keeping only OHLCV\ndropCols= ['Date', 'OpenInt', 'Open10'] # 'Open', 'High', 'Low', 'Close', 'Volume'\ndf = df.drop(labels=dropCols, axis=1)\nprint(df.head())","d81ab111":"# Computing split index\nx, _ = df.shape\nsplitCoeff = 0.80\nsplitRow = int(x * splitCoeff)\ndfNum = df.to_numpy()\n\n# Separating training data from testing data\ntrainX = dfNum[:splitRow, :-1]\ntrainY = dfNum[:splitRow, -1]\ntestX = dfNum[splitRow:, :-1]\ntestY = dfNum[splitRow:, -1]\n\n# Showing price figure for 'open' prices\nxPlot = range(0, x)\nplt.figure()\nplt.title('Data Separation')\nplt.grid(True)\nplt.ylabel('Open Price')\nplt.plot(xPlot[:splitRow], trainX[:,0], 'blue', label='Train data')\nplt.plot(xPlot[splitRow:], testX[:,0], 'red', label='Test data')\nplt.legend()\nplt.show()\nplt.close()","f5bbf178":"# Input normalization\nnorm = MinMaxScaler()\ntrainX = norm.fit_transform(trainX)\n\n# Reshaping data to get a 3D tensor for Conv1D\ntrainX = trainX.reshape(trainX.shape[0], trainX.shape[1], 1)\ntestX = testX.reshape(testX.shape[0], testX.shape[1], 1)\n\n# Parameters\nnFeatures = trainX.shape[1]\nepochs = 20\nbatchSize = 1000\nnOutput = 1\nkernelSize = 1","02398a02":"# Model Building\nmodel = Sequential()\nmodel.add(Conv1D(filters=32, kernel_size=kernelSize, padding='same', activation='relu', input_shape=(nFeatures, 1)))\nmodel.add(Conv1D(filters=64, kernel_size=kernelSize, padding='same'))\nmodel.add(LeakyReLU(alpha=0.01))\nmodel.add(MaxPooling1D(pool_size=(1)))\nmodel.add(Conv1D(filters=128, kernel_size=kernelSize, padding='same'))\nmodel.add(LeakyReLU(alpha=0.01))\nmodel.add(Flatten())\nmodel.add(Dense(256,))\nmodel.add(LeakyReLU(alpha=0.01))\nmodel.add(Dropout(0.8))\nmodel.add(Dense(nOutput, activation='sigmoid'))\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\nmodel.summary()\n\n# Fit the model\nfitReturn = model.fit(trainX, trainY, validation_data=(testX, testY), epochs=epochs, batch_size=batchSize, verbose=1)","f07f97e7":"plt.title('Loss')\nplt.grid(True)\nplt.xlabel('Epochs')\nplt.ylabel('Values')\nplt.plot(fitReturn.history['loss'], 'blue', label='Train Loss')\nplt.plot(fitReturn.history['val_loss'], 'red', label='Test Loss')\nplt.legend()\nplt.show()\nplt.close()","86a10e06":"plt.title('Accuracy')\nplt.grid(True)\nplt.xlabel('Epochs')\nplt.ylabel('Values')\nplt.plot(fitReturn.history['accuracy'], 'blue', label='Train Accuracy')\nplt.plot(fitReturn.history['val_accuracy'], 'red', label='Test Accuracy')\nplt.legend()\nplt.show()\nplt.close()","4ff3db11":"# Predictions\npredictY = model.predict_classes(testX, verbose=0)\npredictY = predictY[:, 0]\n\n# Basic Counting\ntestY0 = (testY == 0).sum()\ntestY1 = (testY == 1).sum()\nprint(\"Test Set - Sell signal : \"+str(testY0))\nprint(\"Test Set - Buy signal  : \"+str(testY1))\nprint(\"=\"*40)\npredictY0 = (predictY == 0).sum()\npredictY1 = (predictY == 1).sum()\nprint(\"Predicted - Sell signal : \"+str(predictY0))\nprint(\"Predicted - Buy signal  : \"+str(predictY1))","4d243263":"# Computing Scores\naccuracy = accuracy_score(testY, predictY)\nprecision = precision_score(testY, predictY)\nrecall = recall_score(testY, predictY)\nf1 = f1_score(testY, predictY)\nmatrix = confusion_matrix(testY, predictY)\nprint('Accuracy: '+str(accuracy))\nprint('Precision: '+str(precision))\nprint('Recall: '+str(recall))\nprint('F1 Score: '+str(f1))\nprint(matrix)","282b8489":"# **Convolutional Neural Network for Market Forecasting**\n\nOne of class of algorithm that is not proposed yet is Convolutional Neural Networks. I came across [this paper](https:\/\/iopscience.iop.org\/article\/10.1088\/1757-899X\/435\/1\/012026\/pdf) by Chen & al. and decided to give it a try. They use 1D CNN to forecast Chinese stock market from 05\/25\/2017 to 12\/29\/2017 with an accuracy close to 74%. I tried to extract their model architecture and hyperparemeters as accurately as possible and reproduced the network using sklearn and keras.","c2d9e98b":"## Data shaping & data management","c4955d59":"## Building the network","8dfc55d2":"## Results Exploitation"}}