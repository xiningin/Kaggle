{"cell_type":{"7f83e235":"code","bca60224":"code","c43e9038":"code","5f243ce4":"code","6ff9e8f1":"code","304d80f7":"code","446bba61":"code","0e65f3fa":"code","32636c75":"code","c19bb456":"code","908ad9c5":"code","4e785657":"code","91613b11":"code","5fddf4e4":"code","e5cf8464":"code","c16e908b":"code","2759c825":"code","4357cea7":"code","a9936133":"code","42b169fb":"code","e17ead92":"code","05c82a3d":"code","a08f29e8":"code","67934406":"code","f94ec263":"code","8766d4d8":"code","2f0c2d27":"code","e6816133":"code","2904aa6e":"code","857804b2":"code","ddf13d89":"code","f08d8556":"code","eeded99a":"code","f469be7a":"code","45d02ccd":"code","b8d5ae99":"code","66a3239c":"code","348e7cd5":"code","a73ecdcd":"code","3e13e5dd":"markdown","93ee09b1":"markdown","5465cb0d":"markdown","7cf64257":"markdown","9dac0353":"markdown","c31323b2":"markdown"},"source":{"7f83e235":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","bca60224":"path = '\/kaggle\/input\/pokemon-dataset-with-team-combat\/'","c43e9038":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport glob\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.model_selection import (\n    train_test_split,\n    GridSearchCV\n)\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.metrics import (\n    confusion_matrix,\n    classification_report\n)\nimport math\nimport time","5f243ce4":"df = pd.read_csv(path + 'pokemon.csv', index_col=0)\ndf","6ff9e8f1":"df['Legendary'] = df['Legendary'].astype('int')","304d80f7":"pokemon_types = sorted(df['Type 1'].unique())\nprint(pokemon_types)","446bba61":"def one_hot_modify(row):\n    global pokemon_types\n    datum = {i: 0 for i in pokemon_types}\n    datum[row['Type 1']] = 1\n    if isinstance(row['Type 2'], str):\n        datum[row['Type 2']] = 1\n    return [i for i in datum.values()]","0e65f3fa":"df","32636c75":"one_hot_types = df.T.apply(one_hot_modify).T\none_hot_types.columns = pokemon_types\none_hot_types","c19bb456":"pokemon = pd.concat([df, one_hot_types], axis=1).drop(['Type 1', 'Type 2', 'Name'], axis=1)\npokemon","908ad9c5":"# pokemon.reset_index().to_csv('preprocessed_pokemon.csv', index=False)","4e785657":"combat = pd.read_csv(path + 'combats.csv')\ncombat.columns = ['first', 'second', 'win']\ncombat","91613b11":"combat['winner'] = combat.T.apply(lambda x: x['second'] == x['win']).astype('int')","5fddf4e4":"combat","e5cf8464":"def make_pokemon_data(dataframe, combatdata):\n    data = []\n    for idx, row in combatdata.iterrows():\n        pokemon_1 = dataframe.loc[row['first']].values.tolist()\n        pokemon_2 = dataframe.loc[row['second']].values.tolist()\n        data.append(pokemon_1 + pokemon_2 + [row['winner']])\n    return data","c16e908b":"data = make_pokemon_data(pokemon, combat)","2759c825":"pokemon_columns = pokemon.columns\ncompose_columns = [col + '_1' for col in pokemon_columns]\ncompose_columns += [col + '_2' for col in pokemon_columns]\ncompose_columns += ['winner']\nprint(compose_columns)","4357cea7":"final_data = pd.DataFrame(data, columns=compose_columns)\nfinal_data","a9936133":"features = final_data.columns[:-1]\npredict = final_data.columns[-1]\nX = final_data[features].values\ny = final_data[predict].values\nX.shape, y.shape","42b169fb":"random_state = 10","e17ead92":"Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.2, random_state=random_state)\nXtrain.shape, Xtest.shape, ytrain.shape, ytest.shape","05c82a3d":"rf = RandomForestClassifier(n_estimators=300)\nrf.fit(Xtrain, ytrain)","a08f29e8":"rf.score(Xtrain, ytrain)","67934406":"rf.score(Xtest, ytest)","f94ec263":"def make_combat_data(first, second):\n    test_combat = pd.DataFrame({\n        'first': [first],\n        'second': [second],\n        'winner': [0]\n    })\n    X = pd.DataFrame(make_pokemon_data(pokemon, test_combat), columns=compose_columns).drop('winner', axis=1).values\n    return X","8766d4d8":"X_164_233 = make_combat_data(164, 233)\nrf.predict(X_164_233)","2f0c2d27":"X_233_164 = make_combat_data(233, 164)\nrf.predict(X_233_164)","e6816133":"sns.heatmap(confusion_matrix(ytest, rf.predict(Xtest)), annot=True, fmt='.0f')","2904aa6e":"print('Predict 1st pokemon win (true): ', 7409 \/ Xtest.shape[0] * 100, '%')\nprint('Predict 2nd pokemon win (true): ', 8305 \/ Xtest.shape[0] * 100, '%')","857804b2":"print('Predict 1st pokemon win (false): ', 458 \/ Xtest.shape[0] * 100, '%')\nprint('Predict 2nd pokemon win (false): ', 495 \/ Xtest.shape[0] * 100, '%')","ddf13d89":"print(classification_report(ytest, rf.predict(Xtest)))","f08d8556":"def get_team_6():\n    '''\n    This function will return # of Pokemon that are random\n    and team data\n    '''\n    return np.random.randint(1, 801, size=6)","eeded99a":"def combat_2_teams(team1, team2, model_1vs1):\n    start = time.time()\n    total = 0\n    for p1 in team1:\n        for p2 in team2:\n            total += model_1vs1.predict(make_combat_data(p1, p2))\n    ret_data = {\n        'team1': team1,\n        'team2': team2,\n        'winner': int(total >= 18)\n    }\n    print('Time for a match: %.2fs' % (time.time() - start))\n    return ret_data","f469be7a":"pokemon_teams = {}\nfor i in range(1, 101):\n    pokemon_teams[i] = get_team_6()","45d02ccd":"start = time.time()\nteam_matches = []\nfor i in range(1, 101):\n    for j in range(1, 101):\n        idx_team1 = pokemon_teams[i]\n        idx_team2 = pokemon_teams[j]\n        winner = combat_2_teams(idx_team1, idx_team2, rf)\n        team_matches.append(dict(first=i, second=j, winner=winner))\nend = time.time()\nprint(end - time, ' second')","b8d5ae99":"team_combat = []\nfor data in team_matches:\n    datum = dict(\n        first=data['first'],\n        second=data['second'],\n        winner=data['winner']['winner']\n    )\n    team_combat += [datum]","66a3239c":"pd.DataFrame(team_combat).to_csv('team_combat.csv', index=False)","348e7cd5":"# pd.DataFrame(pokemon_teams).T.reset_index().rename(columns={'index': '#'}).to_csv('pokemon_id_each_team.csv', index=False)","a73ecdcd":"pd.DataFrame(pokemon_teams).T.reset_index().rename(columns={'index': '#'})","3e13e5dd":"Create 100 pokemon teams","93ee09b1":"M\u1ed7i team g\u1ed3m c\u00f3 6 th\u00e0nh vi\u00ean, index t\u1eeb 0 \u0111\u1ebfn 5\n\n`#` ch\u00ednh l\u00e0 id c\u1ee7a team","5465cb0d":"Both of the above predictions point to pokemon with index of 164, indicating that this model works quite well.","7cf64257":"Let 100 team combat with each other.","9dac0353":"This dataset contains the ids of the teams and winners, if 1 then 2nd team wins, if 0 then 1st team wins.","c31323b2":"After training the 1 vs 1 model, we can see the high efficiency when testing on the test suite. We will now use this model to output the result for a pair of inserted pokemon.\n\nThe problem here is the team fight. A team will have 6 members (6 pokemon, possible duplicate) against another team (also 6 pokemon). Since it can't be simulated, we'll have to have Pokemon go all-in. That means a total of 36 matches (1 pokemon will fight 6 other team's pokemon). Finally, the number of wins of team 1 and team 2 will be counted. The team with the higher number of wins in that 12 Pokemon match will win."}}