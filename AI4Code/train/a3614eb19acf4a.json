{"cell_type":{"7f397ada":"code","b2e4b735":"code","e867f699":"code","0245a836":"code","771cad29":"code","7fa98c4d":"code","edca6bca":"code","192cac9d":"code","603244f7":"code","1f9de13e":"code","513f6c2f":"code","04feb1e1":"code","8d6da867":"code","3d2d2d63":"code","2ac474b6":"code","001b3877":"code","d477b6c3":"markdown","c243b462":"markdown","f68013f3":"markdown","c766a1a6":"markdown"},"source":{"7f397ada":"import numpy as np\nimport random\nimport pandas as pd \nfrom pylab import mpl, plt\nplt.style.use('seaborn')\nmpl.rcParams['font.family'] = 'serif'\n%matplotlib inline\n\nfrom pandas import datetime\nimport math, time\nimport itertools\nimport datetime\nfrom operator import itemgetter\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import MinMaxScaler\nfrom math import sqrt\nimport torch\nimport torch.nn as nn\nfrom torch.autograd import Variable\n\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for i, filename in enumerate(filenames):\n        if i<5:\n            print(os.path.join(dirname,filename))\n","b2e4b735":"def stocks_data(symbols, dates):\n    df = pd.DataFrame(index=dates)\n    for symbol in symbols:\n        df_temp = pd.read_csv(\"..\/input\/Data\/Stocks\/{}.us.txt\".format(symbol), index_col='Date',\n                parse_dates=True, usecols=['Date', 'Close'], na_values=['nan'])\n        df_temp = df_temp.rename(columns={'Close': symbol})\n        df = df.join(df_temp)\n    return df","e867f699":"dates = pd.date_range('2015-01-02','2016-12-31',freq='B')\nsymbols = ['goog','ibm','aapl']\ndf = stocks_data(symbols, dates)\ndf.fillna(method='pad')\ndf.plot(figsize=(10, 6), subplots=True);","0245a836":"df.head()","771cad29":"dates = pd.date_range('2010-01-02','2017-10-11',freq='B')\ndf1=pd.DataFrame(index=dates)\ndf_ibm=pd.read_csv(\"..\/input\/Data\/Stocks\/ibm.us.txt\", parse_dates=True, index_col=0)\ndf_ibm=df1.join(df_ibm)\ndf_ibm[['Close']].plot(figsize=(15, 6))\nplt.ylabel(\"stock_price\")\nplt.title(\"IBM Stock\")\nplt.show()","7fa98c4d":"df_ibm=df_ibm[['Close']]\ndf_ibm.info()","edca6bca":"df_ibm=df_ibm.fillna(method='ffill')\n\nscaler = MinMaxScaler(feature_range=(-1, 1))\ndf_ibm['Close'] = scaler.fit_transform(df_ibm['Close'].values.reshape(-1,1))\n#df_ibm","192cac9d":"# function to create train, test data given stock data and sequence length\ndef load_data(stock, look_back):\n    data_raw = stock.values # convert to numpy array\n    data = []\n    \n    # create all possible sequences of length look_back\n    for index in range(len(data_raw) - look_back): \n        data.append(data_raw[index: index + look_back])\n    \n    data = np.array(data);\n    test_set_size = int(np.round(0.2*data.shape[0]));\n    train_set_size = data.shape[0] - (test_set_size);\n    \n    x_train = data[:train_set_size,:-1,:]\n    y_train = data[:train_set_size,-1,:]\n    \n    x_test = data[train_set_size:,:-1]\n    y_test = data[train_set_size:,-1,:]\n    \n    return [x_train, y_train, x_test, y_test]\n\nlook_back = 60 # choose sequence length\nx_train, y_train, x_test, y_test = load_data(df_ibm, look_back)\nprint('x_train.shape = ',x_train.shape)\nprint('y_train.shape = ',y_train.shape)\nprint('x_test.shape = ',x_test.shape)\nprint('y_test.shape = ',y_test.shape)","603244f7":"# make training and test sets in torch\nx_train = torch.from_numpy(x_train).type(torch.Tensor)\nx_test = torch.from_numpy(x_test).type(torch.Tensor)\ny_train = torch.from_numpy(y_train).type(torch.Tensor)\ny_test = torch.from_numpy(y_test).type(torch.Tensor)","1f9de13e":"y_train.size(),x_train.size()","513f6c2f":"# Build model\n#####################\ninput_dim = 1\nhidden_dim = 32\nnum_layers = 2 \noutput_dim = 1\n\n\n# Here we define our model as a class\nclass LSTM(nn.Module):\n    def __init__(self, input_dim, hidden_dim, num_layers, output_dim):\n        super(LSTM, self).__init__()\n        # Hidden dimensions\n        self.hidden_dim = hidden_dim\n\n        # Number of hidden layers\n        self.num_layers = num_layers\n\n        # batch_first=True causes input\/output tensors to be of shape\n        # (batch_dim, seq_dim, feature_dim)\n        self.lstm = nn.LSTM(input_dim, hidden_dim, num_layers, batch_first=True)\n\n        # Readout layer\n        self.fc = nn.Linear(hidden_dim, output_dim)\n\n    def forward(self, x):\n        # Initialize hidden state with zeros\n        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_dim).requires_grad_()\n\n        # Initialize cell state\n        c0 = torch.zeros(self.num_layers, x.size(0), self.hidden_dim).requires_grad_()\n\n        # We need to detach as we are doing truncated backpropagation through time (BPTT)\n        # If we don't, we'll backprop all the way to the start even after going through another batch\n        out, (hn, cn) = self.lstm(x, (h0.detach(), c0.detach()))\n\n        # Index hidden state of last time step\n        # out.size() --> 100, 32, 100\n        # out[:, -1, :] --> 100, 100 --> just want last time step hidden states! \n        out = self.fc(out[:, -1, :]) \n        # out.size() --> 100, 10\n        return out\n    \nmodel = LSTM(input_dim=input_dim, hidden_dim=hidden_dim, output_dim=output_dim, num_layers=num_layers)\n\nloss_fn = torch.nn.MSELoss()\n\noptimiser = torch.optim.Adam(model.parameters(), lr=0.01)\nprint(model)\nprint(len(list(model.parameters())))\nfor i in range(len(list(model.parameters()))):\n    print(list(model.parameters())[i].size())","04feb1e1":"# Train model\n#####################\nnum_epochs = 100\nhist = np.zeros(num_epochs)\n\n# Number of steps to unroll\nseq_dim =look_back-1  \n\nfor t in range(num_epochs):\n    # Initialise hidden state\n    # Don't do this if you want your LSTM to be stateful\n    #model.hidden = model.init_hidden()\n    \n    # Forward pass\n    y_train_pred = model(x_train)\n\n    loss = loss_fn(y_train_pred, y_train)\n    if t % 10 == 0 and t !=0:\n        print(\"Epoch \", t, \"MSE: \", loss.item())\n    hist[t] = loss.item()\n\n    # Zero out gradient, else they will accumulate between epochs\n    optimiser.zero_grad()\n\n    # Backward pass\n    loss.backward()\n\n    # Update parameters\n    optimiser.step()","8d6da867":"plt.plot(hist, label=\"Training loss\")\nplt.legend()\nplt.show()","3d2d2d63":"np.shape(y_train_pred)","2ac474b6":"# make predictions\ny_test_pred = model(x_test)\n\n# invert predictions\ny_train_pred = scaler.inverse_transform(y_train_pred.detach().numpy())\ny_train = scaler.inverse_transform(y_train.detach().numpy())\ny_test_pred = scaler.inverse_transform(y_test_pred.detach().numpy())\ny_test = scaler.inverse_transform(y_test.detach().numpy())\n\n# calculate root mean squared error\ntrainScore = math.sqrt(mean_squared_error(y_train[:,0], y_train_pred[:,0]))\nprint('Train Score: %.2f RMSE' % (trainScore))\ntestScore = math.sqrt(mean_squared_error(y_test[:,0], y_test_pred[:,0]))\nprint('Test Score: %.2f RMSE' % (testScore))","001b3877":"# Visualising the results\nfigure, axes = plt.subplots(figsize=(15, 6))\naxes.xaxis_date()\n\naxes.plot(df_ibm[len(df_ibm)-len(y_test):].index, y_test, color = 'red', label = 'Real IBM Stock Price')\naxes.plot(df_ibm[len(df_ibm)-len(y_test):].index, y_test_pred, color = 'blue', label = 'Predicted IBM Stock Price')\n#axes.xticks(np.arange(0,394,50))\nplt.title('IBM Stock Price Prediction')\nplt.xlabel('Time')\nplt.ylabel('IBM Stock Price')\nplt.legend()\nplt.savefig('ibm_pred.png')\nplt.show()","d477b6c3":"In this notebook we will be building and training LSTM to predict IBM stock. We will use PyTorch.","c243b462":"## 1. Libraries and settings","f68013f3":"## 3. Build the structure of model","c766a1a6":"## 2. Load data"}}