{"cell_type":{"3f7ad266":"code","c04eaa09":"code","80b62af9":"code","7cda30cd":"code","40582787":"markdown"},"source":{"3f7ad266":"import numpy as np\nfrom sklearn.metrics import cohen_kappa_score\n\n# import tensorflow.keras.backend as K\nimport tensorflow as tf","c04eaa09":"def kappa_keras(y_true, y_pred):\n\n    y_true = tf.cast(tf.math.argmax(y_true, axis=-1), dtype='int32')\n    y_pred = tf.cast(tf.math.argmax(y_pred, axis=-1), dtype='int32')\n\n    # Figure out normalized expected values\n    min_rating = tf.minimum(tf.math.reduce_min(y_true), tf.math.reduce_min(y_pred))\n    max_rating = tf.maximum(tf.math.reduce_max(y_true), tf.math.reduce_max(y_pred))\n\n    # shift the values so that the lowest value is 0\n    # (to support scales that include negative values)\n    y_true = tf.map_fn(lambda y: y - min_rating, y_true, dtype='int32')\n    y_pred = tf.map_fn(lambda y: y - min_rating, y_pred, dtype='int32')\n\n    # Build the observed\/confusion matrix\n    num_ratings = max_rating - min_rating + 1\n    observed = tf.math.confusion_matrix(y_true, y_pred,\n                                        num_classes=num_ratings)\n    num_scored_items = y_true.shape[0]\n\n    weights = tf.expand_dims(tf.range(num_ratings), axis=-1) - tf.expand_dims(tf.range(num_ratings), axis=0)\n    weights = tf.cast(tf.math.pow(weights, 2), dtype=tf.float32)\n\n    hist_true = tf.math.bincount(y_true, minlength=num_ratings)\n    hist_true = hist_true[:num_ratings] \/ num_scored_items\n    hist_pred = tf.math.bincount(y_pred, minlength=num_ratings)\n    hist_pred = hist_pred[:num_ratings] \/ num_scored_items\n    expected = tf.cast(tf.tensordot(tf.expand_dims(hist_true, axis=-1), tf.expand_dims(hist_pred, axis=0), axes=1),\n                       dtype=tf.float32)\n\n    # Normalize observed array\n    observed = tf.cast(observed \/ num_scored_items, dtype=tf.float32)\n\n    # If all weights are zero, that means no disagreements matter.\n    score = tf.where(tf.math.reduce_any(tf.math.not_equal(weights, 0)),\n                     tf.math.reduce_sum(weights * observed) \/ tf.math.reduce_sum(weights * expected),\n                     0)\n\n    return 1. - score","80b62af9":"def test_kappa_keras():\n\n    LABELS = [0, 1, 2]\n    N = 10\n    TRIALS = 100\n\n    for _ in range(TRIALS):\n        y_true = np.random.choice(LABELS, size=N, replace=True)\n        y_pred = np.random.choice(LABELS, size=N, replace=True)\n\n        # Calculating QWK score with scikit-learn\n        skl_score = cohen_kappa_score(y_true, y_pred, weights='quadratic')\n\n        # Keras implementation of QWK work with one hot encoding labels and predictions (also it works with softmax probabilities)\n        # Converting arrays to one hot encoded representation\n        shape = (y_true.shape[0], np.maximum(y_true.max(), y_pred.max()) + 1)\n\n        y_true_ohe = np.zeros(shape)\n        y_true_ohe[np.arange(shape[0]), y_true] = 1\n\n        y_pred_ohe = np.zeros(shape)\n        y_pred_ohe[np.arange(shape[0]), y_pred] = 1\n\n        keras_score = kappa_keras(y_true_ohe, y_pred_ohe).numpy()\n\n        if not np.isclose(skl_score, keras_score):\n            print(skl_score, keras_score)","7cda30cd":"# some errors due to casting to float32\ntest_kappa_keras()","40582787":"This is `quadratic kappa score` as computed in `sklearn` `cohen_kappa_score`. Works with `tf 2.0`. Based on this [kernel](https:\/\/www.kaggle.com\/maxmanko\/quadratic-weighted-kappa-metric-in-keras)."}}