{"cell_type":{"9533b5e0":"code","53a83cbf":"code","dfd49bec":"code","e1a69236":"code","e883350d":"code","a90a0e0d":"code","4f4764fa":"code","3958a8e4":"code","a9aed8f5":"code","863b4814":"code","b7169f65":"code","c6b3a8d7":"code","7bda3bbe":"markdown","f3e6bab5":"markdown","9698f633":"markdown","da2f9c34":"markdown","8c5ac851":"markdown"},"source":{"9533b5e0":"import numpy as np\nimport pandas as pd\nimport logging\nimport copy\nimport time\nimport random\nfrom tqdm import tqdm\nimport sys\nimport glob\nimport os\nimport argparse\nimport threading\nimport ntpath\nfrom multiprocessing import Pool\nfrom contextlib import contextmanager","53a83cbf":"@contextmanager\ndef time_limit(seconds):\n    timer = threading.Timer(seconds, lambda: _thread.interrupt_main())\n    timer.start()\n    try:\n        yield\n    except KeyboardInterrupt:\n        raise TimeoutException()\n    finally:\n        timer.cancel()","dfd49bec":"random.seed(0)\nnp.random.seed(0)\n\nlogging.basicConfig(level=logging.INFO, format='[%(asctime)s] - %(message)s', datefmt='%H:%M:%S')","e1a69236":"class TimeoutException(Exception):\n    pass","e883350d":"def path_leaf(path):\n    head, tail = ntpath.split(path)\n    return tail or ntpath.basename(head)","a90a0e0d":"import time\n\nclass AntClique:\n    def __init__(self, num_ants=7, taomin=0.01, taomax=4, alpha=2, rho=.995, max_cycles=3000):\n        self.num_ants = num_ants\n        self.taomin = taomin\n        self.taomax = taomax\n        self.alpha = alpha\n        self.rho = rho\n        self.max_cycles = max_cycles\n        \n        self.graph = None\n        self.best_clique_info = None\n        \n    def initialize_pheromone_trails(self, graph):\n        self.graph = copy.deepcopy(graph)\n        self.best_clique_info = {\n            'clique': set(),\n            'req_time': -1,\n            'req_cycles': -1,\n        } \n\n        # initialize all edges with taomax pheromone\n        for n, nbrs in graph.items():\n            for nbr, attrs in nbrs.items():\n                attrs['pheromone'] = self.taomax\n                self.graph[n][nbr] = attrs\n    \n\n    def construct_clique(self, ant_idx):\n        clique = set()\n        candidates = set()\n        neigbors = lambda node: set(self.graph[node].keys())\n        pheromone_factor = lambda node: sum(self.graph[node][clique_node]['pheromone'] for clique_node in clique)  \n        \n        initial_vertex = random.sample(self.graph.keys(), 1)[0]\n        clique.add(initial_vertex)\n        candidates.update(neigbors(initial_vertex))\n\n        while candidates:\n            pheromone_factors = [pheromone_factor(node) ** self.alpha for node in candidates]\n            pheromone_probs = [factor \/ sum(pheromone_factors) for factor in pheromone_factors]\n    \n            selected_vertex = np.random.choice(list(candidates), size=1, p=pheromone_probs)[0]\n\n            clique.add(selected_vertex)\n            candidates = candidates.intersection(neigbors(selected_vertex))\n\n        return (ant_idx, clique)\n\n    def update_pheromone_trails(self, iteration_no, start_time_u, cliques):\n        best_ant_idx, best_clique = max(cliques, key=lambda t: len(t[1]))\n        \n        # update global info\n        if len(best_clique) > len(self.best_clique_info['clique']):\n            self.best_clique_info = {\n                'clique': best_clique,\n                'req_time': (time.time() - start_time_u) * 1000,\n                'req_cycles': iteration_no + 1\n            }\n\n        c_best = len(self.best_clique_info['clique'])\n        c_k = len(best_clique)\n\n        # evaporate pheromone on all edges\n        for n, nbrs in self.graph.items():\n            for nbr, attrs in nbrs.items():\n                attrs['pheromone'] = max(self.taomin, self.rho * attrs['pheromone'])\n                self.graph[n][nbr] = attrs\n\n        # deposit pheromone for best ant\n        for n in best_clique:\n            for nbr in best_clique:\n                if n == nbr:\n                    continue\n                \n                attrs = self.graph[n][nbr]\n                attrs['pheromone'] = min(self.taomax, (1 \/ (1 + c_best - c_k)) + attrs['pheromone'])\n                self.graph[n][nbr] = attrs\n\n\n    def run(self, graph, use_threading=False):\n        start_time_c = time.time()\n        start_time_aco = start_time_c\n        \n        self.initialize_pheromone_trails(graph)\n\n        for iteration_no in tqdm(range(self.max_cycles), desc='Running ant-clique loops'):\n            if use_threading:\n                with Pool(self.num_ants) as pool:\n                    formed_cliques = pool.map(self.construct_clique, range(self.num_ants))\n            else:\n                formed_cliques = [self.construct_clique(i) for i in range(self.num_ants)]\n\n            self.update_pheromone_trails(iteration_no, copy.deepcopy(start_time_aco), formed_cliques)\n        \n        s = len(self.best_clique_info['clique'])\n        t = self.best_clique_info['req_time']\n        c = self.best_clique_info['req_cycles']\n\n        logging.info(f\"clique size: {s}, req cycles: {c}, req time(ms): {t:.3f}\")\n        return (s, t, c)","4f4764fa":"import time\n\nclass BranchAndBound:\n    def __init__(self, lb=0):\n        self.lb = lb\n        \n        self.best_clique = []\n        self.cur_max = 0\n\n    def Clique(self, graph, U, size, cur_clique):\n        if len(U) == 0:\n            if size > self.cur_max:\n                self.cur_max = size\n                self.best_clique = cur_clique\n            return\n\n        while len(U) > 0:\n            if size + len(U) <= self.cur_max: # pruning 4\n                return\n\n            vertex = U.pop()\n            new_cur_clique = cur_clique[:]\n            new_cur_clique.append(vertex)\n            \n            # pruning 5\n            neib_vertex = set(v for v in graph[vertex] if len(graph[v]) >= self.cur_max)\n            new_U = U.intersection(neib_vertex)\n\n            self.Clique(graph, new_U, size + 1, new_cur_clique)\n\n    def MaxClique(self, graph, lb=0):\n        # nodes are labeled as 1, 2, ....no_of_vertices\n        no_of_vertices = len(graph)\n        self.cur_max = lb\n        self.best_clique = []\n\n        for i in tqdm(range(1, no_of_vertices + 1), desc='Running bnb loops'):\n            if str(i) not in graph:\n                continue\n            neib_vi = graph[str(i)]\n\n            # pruning 1\n            if len(neib_vi) >= self.cur_max: \n                U = set()\n                cur_clique = [str(i)]\n\n                for j in neib_vi:\n                    # pruning 2\n                    if int(j) > i: \n                        # pruning 3\n                        if len(graph[j]) >= self.cur_max: \n                            U.add(j)\n\n                self.Clique(graph, U, 1, cur_clique)\n\n\n    def run(self, graph):\n        start_time_bb = time.time()\n        self.MaxClique(graph, self.lb)\n        end_time = time.time()\n        timeval = end_time - start_time_bb\n        \n        s = self.cur_max\n        t = timeval * 1000\n\n        logging.info(f\"clique size: {s}, time(ms): {t:.3f}\")\n        return (s, t)","3958a8e4":"def read_graph(graph_loc):\n    \"\"\"Reads dimacs styled graphs\"\"\"\n    graph_adj = {}\n    with open(graph_loc) as f:\n        for i, line in enumerate(f):\n            if i == 0:\n                logging.info(f'Reading graph: {\" \".join(line.strip().split()[1:])}')\n            elif line.startswith('p'):\n                _, _, vertices_num, edges_num = line.split()\n                logging.info(f'Vertices: {vertices_num}, Edges: {edges_num}')\n            elif line.startswith('e'):\n                _, v1, v2 = line.split()\n                if v1 == v2:\n                    continue\n\n                if v1 not in graph_adj:\n                    graph_adj[v1] = {}\n                if v2 not in graph_adj:\n                    graph_adj[v2] = {}\n\n                l = graph_adj[v1].get(v2, {})\n                graph_adj[v1][v2] = l\n                graph_adj[v2][v1] = l\n            else:\n                continue\n    \n    return graph_adj","a9aed8f5":"args = {\n    'num_ants' : 7,\n    'taomin' : 0.01,\n    'taomax' : 4,\n    'alpha' : 2,\n    'rho' : .995,\n    'max_cycles' : 1000,\n    'runs_per_graph': 3,\n    'time_limit': 1200,\n    'lb': 0\n}\n\nantClique = AntClique(args['num_ants'], args['taomin'], args['taomax'], args['alpha'], args['rho'], args['max_cycles'])\nbranchAndBound = BranchAndBound(args['lb'])","863b4814":"input_files = []\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        input_files.append(os.path.join(dirname, filename))\n        \ninput_files_test = [\n    '\/kaggle\/input\/graphs-clique\/anna.col',\n    '\/kaggle\/input\/graphs-clique\/le450_5d.col'\n] ","b7169f65":"results = []\nfor f in input_files_test:\n    graph = read_graph(f)\n    \n    # <ACO>\n    outputs_aco = []\n    for i in range(args['runs_per_graph']):\n        logging.info(f'Run {i}')\n        try:\n            with time_limit(args['time_limit']):\n                outputs_aco.append(antClique.run(graph))\n        except TimeoutException:\n            logging.info('Execution timed out!')\n            continue\n    # <\/ACO>\n    \n    # <BB>\n    try:\n        with time_limit(args['time_limit']):\n            size_bb, time_bb = branchAndBound.run(graph)\n    except TimeoutException:\n        logging.info('Execution timed out!')\n        continue\n    \n\n    sizes_aco = [o[0] for o in outputs_aco]\n    times_aco = [o[1] for o in outputs_aco]\n    cycles_aco = [o[2] for o in outputs_aco]\n\n    out_json = {\n        'filename': [path_leaf(f)],\n        'ACO size->mean(stdev)': [f'{np.mean(sizes_aco):.4f}({np.std(sizes_aco):.4f})'],\n        'ACO time->mean(stdev)': [f'{np.mean(times_aco):.4f}({np.std(times_aco):.4f})'],\n        'ACO cycles->mean(stdev)': [f'{np.mean(cycles_aco):.4f}({np.std(cycles_aco):.4f})'],\n        'BB size': [f'{size_bb:.4f}'],\n        'BB time': [f'{time_bb:.4f}']\n    }\n    log_msg = \"Final results-> \" + \", \".join(f\"{k}: {v[0]}\" for k, v in out_json.items())\n\n    results.append(pd.DataFrame(out_json))\n    logging.info(log_msg)\n    print('\\n')","c6b3a8d7":"pd.concat(results)","7bda3bbe":"# BranchAndBound","f3e6bab5":"### Params","9698f633":"# Read graph","da2f9c34":"# ACO","8c5ac851":"### Results"}}