{"cell_type":{"46fc7d29":"code","07a1cc58":"code","62692392":"code","86852edc":"code","9460064b":"code","9a34493c":"code","76b1312e":"code","a3eab3b6":"code","89015cfa":"code","2587c127":"code","3e946c98":"code","4892d7f2":"code","54ec870e":"code","cf47f972":"code","8898345a":"code","fce30265":"code","26db6379":"markdown","e71ac002":"markdown","3ae6aeb1":"markdown","15e00177":"markdown","ccb37333":"markdown","6e0229d7":"markdown","ac0d82fe":"markdown","d5fd466f":"markdown","2012658b":"markdown","81cf1fd7":"markdown","3c39e838":"markdown","826c767e":"markdown","78c1c629":"markdown","c0a08346":"markdown","438d7b50":"markdown","93d2461b":"markdown"},"source":{"46fc7d29":"import numpy as np\nimport pandas as pd\nimport json\nimport os\nimport re\nimport math\nfrom pandas.io.json import json_normalize\nimport pprint\npp = pprint.PrettyPrinter(indent=4)\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()\n\nfiles = []\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n        files.append(os.path.join(dirname, filename))","07a1cc58":"f = [str(s) for s in files if 'json' in s]\n\nwith open(f[0]) as jsn:\n    df = json.load(jsn)\nprint(df.keys())","62692392":"ab_dict = df['Abigail']\nk0s = []\nk1s_vals =[]\nfor k0,v0 in ab_dict.items():\n    k0s.append(k0)\n    k1s = []\n    for k1,v1 in ab_dict[k0].items():\n        k1s.append(k1)\n    k1s_vals.append(k1s)","86852edc":"print(k0s[0],':' + ','.join(k1s_vals[0]))","9460064b":"print(k0s[1],':' + ','.join(k1s_vals[1]))","9a34493c":"def make_stats(name):\n    temp_dict = df[name]\n    tempo_df = pd.DataFrame([temp_dict['stats']])\n    tempo_df['Character'] = name\n    #tempo_df['Character'] = list(df.keys())[0]\n    return(tempo_df)\n    \nlist_chars = []\nfor k,v in df.items():\n    list_chars.append(make_stats(k))\ndf_stats = pd.concat(list_chars, axis=0, sort=True)","76b1312e":"health_char = df_stats[['Character', 'health']].sort_values(by='health')\nplt.figure(figsize=(10,10)) \nsns.barplot(y=health_char['Character'], \n            x= health_char['health'], \n            color=\"b\").set_title('Character\\'s health')","a3eab3b6":"print(k0s[0],':' + ','.join(k1s_vals[0]))","89015cfa":"ab_dict['moves']['normal'].keys()","2587c127":"ab_dict['moves']['vtOne'].keys()","3e946c98":"ab_dict['moves']['vtTwo'].keys()","4892d7f2":"def make_moves(name):\n    # get the name of normal, vt1 and vt2 moves for this character\n    normal_moves = list(df[name]['moves']['normal'].keys())\n    vt1_moves = list(df[name]['moves']['vtOne'].keys())\n    vt2_moves = list(df[name]['moves']['vtTwo'].keys())\n    \n    # find same moves in the normal and vt1 list\n    normal_vt1 = list(set(normal_moves).intersection(set(vt1_moves)))\n    \n    print(\"name: {}, total moves {}\".format(name, len(normal_vt1)))\n    \n    normal_damages = []\n    vt1_damages = []\n    moves_name = []\n    \n    if len(normal_vt1) >0:\n        for m in normal_vt1:\n            moves_name.append(df[name]['moves']['normal'][m]['moveName'])\n            try:\n                normal_damages.append(df[name]['moves']['normal'][m]['damage'])\n            except KeyError:\n                normal_damages.append(np.nan) \n            try:\n                vt1_damages.append(df[name]['moves']['vtOne'][m]['damage'])\n            except KeyError:\n                vt1_damages.append(np.nan) \n\n        temp_char = pd.DataFrame(list(zip(moves_name, normal_damages, vt1_damages)), \n                      columns = ['move name','normal damage', 'vt1 damage'])\n        temp_char['Character'] = [name] * len(temp_char)\n    elif len(normal_vt1) == 0:\n        normal_damages.append(np.nan)\n        vt1_damages.append(np.nan) \n        moves_name.append(np.nan)\n        \n        temp_char = pd.DataFrame(list(zip(moves_name, normal_damages, vt1_damages)), \n                      columns = ['move name','normal damage', 'vt1 damage'])\n        temp_char['Character'] = [name] * len(temp_char)\n    #print(temp_char)\n    return(temp_char)\n    \nall_chars_moves = []\nfor name in list(df.keys()):\n    all_chars_moves.append(make_moves(name))","54ec870e":"df_moves = pd.concat(all_chars_moves, axis=0, sort=True)\ndf_moves.head(6)","cf47f972":"# first check if it's nan or a string --> apply some regexp\n# then deal with number\ndef get_val(x):\n    #print(x)\n    if x == \"NaN\" or x ==\"~\":\n        return np.nan\n    elif \"(\" in str(x):\n        f = re.findall('\\(([^)]+)', x)\n        #print(f[0])\n        #if isinstance(f[0], str):\n        if f[0] == \"air\":\n            return(np.nan) # \"air\" case\n        else:\n            return(int(f[0]))\n    elif \"x\" in str(x) and \"*\" in str(x):\n        d = x.split(\"x\")\n        x = d[0]\n        y = d[1].split(\"*\")\n        mysum = int(x) + int(y[0]) + int(y[1])\n        return(mysum)\n    elif \"*\" in str(x):\n        return(int(x.split(\"*\")[0]) + int(x.split(\"*\")[1]))\n    elif \"+\" in str(x):\n        return(int(x.split(\"+\")[0]) + int(x.split(\"+\")[1]))\n    elif \"x\" in str(x):\n        return(int(x.split(\"x\")[0]) + int(x.split(\"x\")[1]))\n    elif math.isnan(x):\n        return np.nan\n    else:\n        return(int(x))","8898345a":"df_moves['normal damage num'] = df_moves['normal damage'].apply(get_val)\ndf_moves['vt1 damage num'] = df_moves['vt1 damage'].apply(get_val)","fce30265":"df_moves[['normal damage','normal damage num','vt1 damage','vt1 damage num']].head(10)","26db6379":"# `Moves` dictionary ","e71ac002":"A large part of this kernel is to actually turn the data (originally nested dictionaries) into a flat structure.\nLet's start by looking at the keys:","3ae6aeb1":"Putting the `stats` data into a dataframe ","15e00177":"### Checkpoint example: `Health` per `Character` bar plot","ccb37333":"## Explanation","6e0229d7":"it seems to work but this method needs to be redo since it can be much more efficient","ac0d82fe":"([from wikipedia](https:\/\/en.wikipedia.org\/wiki\/Street_Fighter_V)) just in case ... **Street Fighter V** is the 5th iteration in the Street Fighter series, which features a side-scrolling fighting gameplay system. In short a 2D fighting game.\n\nThe game developed by Capcom and Dimps and published by Capcom for the PlayStation 4 and Microsoft Windows in 2016. \n\nThis opus features a side-scrolling fighting gameplay system and introduces the `V-Gauge`, which builds as the player receives attacks and adds three new skills.","d5fd466f":"For each character a list of `normal`, `vtOne` and `vtTwo` (aka supers) moves are available.","2012658b":"So the data is organized by character. We can also notice the nested dictionaries for each of them. Below an example for `Abigael`:","81cf1fd7":"from : [sfv wiki](https:\/\/streetfighter.fandom.com\/wiki\/V-Trigger)\nThe V-Trigger is a mechanic introduced in Street Fighter V. Executed by pressing both `Heavy Punch` and `Heavy Kick` simultaneously, the character activates his\/her V-Trigger. Some fighters gain access to a power-up that enhances their moves or abilities that lasts for a limited amount of time. Others perform a single move that can turn the tide of battle. \n\nIn order to obtain V-Trigger, the character's V-Gauge must be full. Characters can build V-Gauge by using their specific V-Skill, blocking the opponent's attacks, or taking damage. Some V-Triggers are 2-bar, while others are 3-bar. \n\nIn Street Fighter V: Arcade Edition all playable fighters gain a second V-Trigger. Their original ones are referred to in-game as \"V-Trigger I\" while the second ones are labelled \"V-Trigger II\".\n\nAs we saw earlier, the `moves` dictionary has 3 nested structures related to the `normal` moves data and the `V-T` moves:","3c39e838":"Now we see that some `regexp` is need to actually extract the value as numeric. Below are the different possibilities:\n* `30`: convert to numeric\n* `nan`: impute `nan`\n* `40*27 (67)` or `70*70*50 (190)`: extract the number inside the parenthesis\n* `50*50`: add the 2 numbers (I think the multiplication is wrong)\n","826c767e":"We can also notice that not all the moves have a `VT-1` and\/or `VT-2` versions:","78c1c629":"# Quick intro","c0a08346":"My idea below is to find the same moves in the `normal` and `vtOne` list to compare their characteristics.","438d7b50":"## Gathering the `stats` data into a dataframe","93d2461b":"# Loading dataset and decoding the json structure"}}