{"cell_type":{"c2a3419b":"code","c147efe6":"code","49ac2973":"code","36281254":"code","f063a90e":"code","f2f10fea":"code","e8cab9f9":"code","6698da7c":"code","5ac62901":"code","d9840380":"code","0236968b":"code","c7d5e79a":"code","93fada41":"code","1f609204":"code","ea6926aa":"code","cfd84c0c":"code","c16edbd3":"code","cb0b9363":"code","ebd5e629":"code","7c129daa":"markdown","f8576de7":"markdown","7d28563f":"markdown","e22d7794":"markdown","5f798977":"markdown","82c1665e":"markdown","fc934a70":"markdown","5aa100b2":"markdown"},"source":{"c2a3419b":"## Problemrepr\u00e4sentation\n\nproblem1 = ((\"1\",\"101\"),(\"10\",\"00\"),(\"011\",\"11\"))\n\n# Not elegant, made for demo purposes\ndef isValid(x,y):\n    lx = len(x)\n    ly = len(y)\n    length = lx if lx < ly else ly\n    for i in range(length):\n        if x[i] != y[i]:\n            return False\n    return True\n\n# some tests\nprint(isValid(\"100\",\"1001\"))   # -> True\nprint(isValid(\"1001\",\"100\"))   # -> True\nprint(isValid(\"\",\"100\"))       # -> True \nprint(isValid(\"100\",\"\"))       # -> True\nprint(isValid(\"\",\"\"))          # -> True\nprint(isValid(\"1001\",\"1000\"))  # -> False      \nprint(isValid(\"0\",\"1\"))        # -> False","c147efe6":"class Queue:\n    def __init__(self):\n        # Creates an internal list to manage the queue\n        self._queue = []\n        \n    def push(self,element):\n        # Appends the new element to the end of the internal list\n        self._queue.append(element)\n        \n    def pop(self): \n        # Returns the first element in the internal list\n        return self._queue.pop(0)\n    \n    def isEmpty(self):\n        # Checks, if the list is empty\n        return len(self._queue) == 0\n\n    \ndef search(problem,debug=True):\n    first = (\"\",\"\") # no domino selected\n    q = Queue()\n    q.push(first) \n    \n    stop = False\n    solution = None\n    node_count = 0\n    while not stop:\n        if q.isEmpty(): # Wir k\u00f6nnen nichts mehr ausprobieren!\n           stop = True\n        else:\n            x,y = q.pop()\n            node_count += 1\n            if not node_count % 50: print(\".\",end=\"\")\n            if node_count and not node_count % 4000: print(\"  (\",node_count,\")\")\n            if debug: print(\"x,y:\",x,y)\n            # Check, if this is a solution\n            if x == y and x != '' and y != '':\n                solution = (x,y)\n                stop = True\n            elif isValid(x,y):\n                for domino in problem:\n                    xi,yi = domino\n                    q.push((x+xi,y+yi))\n            else:\n                # Ok, ignore this search node\n                pass # do nothing\n    print(\"\\nThis search inspected \",node_count,\"nodes in the search tree!\")\n    return solution","49ac2973":"result1 = search(problem1)\nprint(\"Result: \",result1)","36281254":"problem2 = ((\"001\",\"0\"),(\"01\",\"011\"),(\"01\",\"101\"),(\"10\",\"001\"))\nresult2 = search(problem2,debug=False)\nprint(\"\\nResult for Problem 2: \",result2)","f063a90e":"problem3 = ((\"0\",\"1\"),) # see https:\/\/wiki.python.org\/moin\/TupleSyntax, \",\" creates a tuple, not \"()\"\nprint(search(problem3))","f2f10fea":"def search(problem,debug=True):\n    first = (\"\",\"\",[]) # no domino selected (CHANGED)\n    q = Queue()\n    q.push(first) \n    \n    stop = False\n    solution = None\n    node_count = 0\n    while not stop:\n        if q.isEmpty(): # Wir k\u00f6nnen nichts mehr ausprobieren!\n           stop = True\n        else:\n            x,y,idx = q.pop() # (CHANGED)\n            node_count += 1\n            if not node_count % 50: print(\".\",end=\"\")\n            if node_count and not node_count % 4000: print(\"  (\",node_count,\")\")\n            if debug: print(\"x,y:\",x,y,idx) # (CHANGED)\n            # Check, if this is a solution\n            if x == y and x != '' and y != '':\n                solution = idx,x,y # (CHANGED)\n                stop = True\n            elif isValid(x,y):\n                for index,domino in enumerate(problem): # (CHANGED)\n                    xi,yi = domino\n                    q.push((x+xi,y+yi,idx+[index])) # (CHANGED)\n            else:\n                # Ok, ignore this search node\n                pass # do nothing\n    print(\"\\nThis search inspected \",node_count,\"nodes in the search tree!\")\n    return solution","e8cab9f9":"result1 = search(problem1)\nprint(\"Result: \",result1)","6698da7c":"problem2 = ((\"001\",\"0\"),(\"01\",\"011\"),(\"01\",\"101\"),(\"10\",\"001\"))\nresult2 = search(problem2,debug=False)\nprint(\"\\nResult for Problem 2: \",result2)","5ac62901":"def isValid(x,y):\n    global count_vgl\n    lx = len(x)\n    ly = len(y)\n    length = lx if lx < ly else ly\n    for i in range(length):\n        count_vgl += 1 # Frage: Warum steht das nicht im if oder hinter dem if?\n        if x[i] != y[i]:\n            return False\n    return True","d9840380":"count_vgl = 0 # stilistisch nicht sch\u00f6n, globale Variable, use at your own risk!\nresult1 = search(problem1,debug=True)\nprint(\"Anzahl an Einzelzeichen-Vergleichen:\",count_vgl)","0236968b":"count_vgl = 0 # stilistisch nicht sch\u00f6n, globale Variable, use at your own risk!\nresult2 = search(problem2,debug=False)\nprint(\"Anzahl an Einzelzeichen-Vergleichen:\",count_vgl)","c7d5e79a":"def isValid(x,y,start=0):\n    global count_vgl\n    lx = len(x)-start\n    ly = len(y)-start\n    length = lx if lx < ly else ly\n    for i in range(length):\n        count_vgl += 1 # Frage: Warum steht das nicht im if oder hinter dem if?\n        if x[i+start] != y[i+start]:\n            return False,0\n    return True,length+start\n\ndef search(problem,debug=True):\n    first = (\"\",\"\",[],0) # no domino selected (CHANGED)\n    q = Queue()\n    q.push(first) \n    \n    stop = False\n    solution = None\n    node_count = 0\n    while not stop:\n        if q.isEmpty(): # Wir k\u00f6nnen nichts mehr ausprobieren!\n           stop = True\n        else:\n            x,y,idx,tested = q.pop() \n            node_count += 1\n            if not node_count % 50: print(\".\",end=\"\")\n            if node_count and not node_count % 4000: print(\"  (\",node_count,\")\")\n            if debug: print(\"x,y:\",x,y,idx,tested) # (CHANGED)\n            # Check, if this is a solution\n            if x == y and x != '' and y != '':\n                solution = idx,x,y\n                stop = True\n            else: # (CHANGED)\n                valid,tested = isValid(x,y,start=tested) # (CHANGED)\n                if valid: # (CHANGED)\n                    for index,domino in enumerate(problem): \n                        xi,yi = domino\n                        q.push((x+xi,y+yi,idx+[index],tested))                 \n    print(\"\\nThis search inspected \",node_count,\"nodes in the search tree!\")\n    return solution","93fada41":"count_vgl = 0 # stilistisch nicht sch\u00f6n, globale Variable, use at your own risk!\nresult1 = search(problem1,debug=True)\nprint(\"Result: \",result1)\nprint(\"\\nAnzahl an Einzelzeichen-Vergleichen:\",count_vgl)","1f609204":"count_vgl = 0 # stilistisch nicht sch\u00f6n, globale Variable, use at your own risk!\nresult2 = search(problem2,debug=False)\nprint(\"Result: \",result2)\nprint(\"\\nAnzahl an Einzelzeichen-Vergleichen:\",count_vgl)","ea6926aa":"def isValid(x,y):\n    global count_vgl\n    lx = len(x)\n    ly = len(y)\n    length = lx if lx < ly else ly\n    for i in range(length):\n        count_vgl += 1 # Frage: Warum steht das nicht im if oder hinter dem if?\n        if x[i] != y[i]:\n            return False,None,None\n    return True,x[length:],y[length:]\n\ndef search(problem,debug=True):\n    first = (\"\",\"\",[]) # no domino selected (CHANGED)\n    q = Queue()\n    q.push(first) \n    \n    stop = False\n    solution = None\n    node_count = 0\n    while not stop:\n        if q.isEmpty(): # Wir k\u00f6nnen nichts mehr ausprobieren!\n           stop = True\n        else:\n            x,y,idx = q.pop() # (CHANGED)\n            node_count += 1\n            if not node_count % 50: print(\".\",end=\"\")\n            if node_count and not node_count % 4000: print(\"  (\",node_count,\")\")\n            if debug: print(\"x,y:\",x,y,idx) # (CHANGED)\n            # Check, if this is a solution\n            if x == y and x != '' and y != '':\n                solution = idx,x,y \n                stop = True\n            else:\n                valid,new_x,new_y = isValid(x,y)\n                if valid:\n                    for index,domino in enumerate(problem): \n                        xi,yi = domino\n                        q.push((new_x+xi,new_y+yi,idx+[index]))                 \n    print(\"\\nThis search inspected \",node_count,\"nodes in the search tree!\")\n    return solution","cfd84c0c":"count_vgl = 0 # stilistisch nicht sch\u00f6n, globale Variable, use at your own risk!\nresult1 = search(problem1,debug=True)\nprint(\"Result: \",result1)\nprint(\"\\nAnzahl an Einzelzeichen-Vergleichen:\",count_vgl)","c16edbd3":"# Hier noch der Code, um die String-L\u00f6sung f\u00fcr eine gegebene Sequenz von Indices zu erzeugen:\n\ndef solve(problem,sequence):\n    x = []\n    y = []\n    for idx in sequence:\n        x += [problem[idx][0]] # x-Position des Dominos mit Index idx\n        y += [problem[idx][1]] # y-Position des Dominos mit Index idx\n    return ''.join(x),''.join(y)\n        ","cb0b9363":"sequence,_,_ = search(problem1,debug=True)\nprint(\"L\u00f6sung als Sequenz von Indices: \",sequence)\nx,y = solve(problem1,sequence)\nprint(\"L\u00f6sung als x- und y-String: \",\"x=\",x,\"und y=\",y)","ebd5e629":"# Hier noch die Version von search aufschreiben, die ohne R\u00fcckgabe von x und y auskommt. \n# Und sie testen!","7c129daa":"Wir f\u00fchren also \u00fcber 34 Millionen Vergleiche einzelner Buchstaben aus. Da k\u00f6nnen wir einiges sparen! Warum? Weil wir f\u00fcr erfolgreich getestete Knoten danach ihre Nachfolger testen, die aus den gleichen Strings f\u00fcr x und y bestehen, wie der vorher getestete Knoten plus einige weitere Zeichen in jeder Kette f\u00fcr den hinzukommenden Domino.\n\nSchauen wir uns das mal konkret bei Problem1 an. Wir testen z.B.:\n\n<pre>\n...\n(Zeile 1) x,y: 1011 10111 [0, 2]\n(Zeile 2) x,y: 10111 10111101 [0, 2, 0]\n(Zeile 3) x,y: 101110 1011100 [0, 2, 1]\n...\n<\/pre>\n\nWir haben in der Zeile 1 bereits 1011 gegen 1011 getestet. In der Zeile 2 tun wir das erneut (plus ein Test von 1 gegen 1), in der Zeile 3 wieder (plus Tests von 10 gegen 10).\n\nDie wiederholten Tests des bereits getesteten Pr\u00e4fix sind unn\u00f6tig - sie sind \"doppelt gemoppelt\"! \n\nWie k\u00f6nnen wir die redundanten Tests vermeiden? \n\nIdee 1: Wir k\u00f6nnen uns merken, bis zu welchem Index wir bereits getestet haben und im n\u00e4chsten _isValid_ dort aufsetzen.","f8576de7":"Was uns jetzt aber noch interessiert, ist, ob wir nicht __effizienter im Erzeugen von L\u00f6sungen__ (oder dem Feststellen des Scheiterns) werden k\u00f6nnen.\n\nWo liegt das Problem? Verwenden wir einmal eine Version von _isValid_, in der wir die einzelnen Vergleiche von einzelnen Zeichen gegen einzelne Zeichen z\u00e4hlen.","7d28563f":"F\u00fcr manche Probleme k\u00f6nnen wir auch erkennen, dass sie nicht l\u00f6sbar sind. F\u00fcr Probleme, die nicht l\u00f6sbar sind, und zu Zweigen f\u00fchren, die (a) sehr lang werden, bevor sie \"scheitern\", oder die (b) unendlich lang so aussehen, als k\u00f6nnten sie noch zu einem Erfolg f\u00fchren, w\u00fcssten wir nach sehr langer Laufzeit nicht, ob sie noch eine L\u00f6sung produzieren oder nicht. Das kann uns nat\u00fcrlich auch f\u00fcr l\u00f6sbare Instanzen passieren, die lange oder sehr lange \"k\u00fcrzeste\" L\u00f6sungen haben. Das Problem ist eben nicht entscheidbar.","e22d7794":"Wow, von 34 Millionen zu 420.000, schon eine gewisse Einsparung!\n\nWas k\u00f6nnten wir noch besser machen? Nun, es k\u00f6nnte sein, dass wir zu gewissen Zeitpunkten viele Knoten in der Queue haben. Wir speichern uns gerade f\u00fcr jeden Knoten die folgenden Informationen in der Suche:\n\n<pre>\nq.push((x+xi,y+yi,idx+[index],tested))  \n<\/pre>\n\nHierbei sind _x+xi_ und _y+yi_ vollst\u00e4ndige Strings, die auf den ersten _tested_ Zeichen \u00fcbereinstimmen. Die sind f\u00fcr die Kontrolle, ob Reste der Strings \u00fcbereinstimmen, irrelevant. Wir brauchen Sie auch nicht f\u00fcr das Erzeugen der L\u00f6sung (falls wir die Strings f\u00fcr _x_ und _y_ \u00fcberhaupt sehen wollen am Ende), denn wir k\u00f6nnen sie bei Bedarf leicht aus der Sequenz mit den Indices erzeugen.\n\nBauen wir die Suche einmal so um, dass wir diesen zus\u00e4tzlichen Speicherbedarf vermeiden:","5f798977":"Wenn wir eine Antwort erhalten, dann sagt die bisher im Grunde nur \"JA\" (repr\u00e4sentiert durch die aneinandergeh\u00e4ngten, identischen x- und y-Sequenzen der Dominoober- bzw. unterseiten) oder \"Nein\" (repr\u00e4sentiert durch die R\u00fcckgabe von _None_). Jetzt wollen wir im \"JA\"-Fall aber auch die L\u00f6sungssequenz, die aus den Domino-Indices besteht, die wir in dieser Reihenfolge verkettet haben, um die x- bzw. y-Sequenzen zu erhalten.\n\nAUFGABE: Passen Sie in ihrem eigenen Notebook die _search_-Funktion so an, dass sie auch die Sequenz von Domino-Indices finden!\n\nACHTUNG: Direkt hier drunter steht die L\u00f6sung, also Augen-Zu und selbst dr\u00fcber nachdenken: was m\u00fc\u00dfte man tun? (dar\u00fcber kann man nachdenken, auch, wenn man vielleicht noch nicht wei\u00df, wie genau man es hinterher realisiert. Man kann dann die gezeigte L\u00f6sung (hoffentlich) besser verstehen).","82c1665e":"In der Vorlesung haben Sie mit speziellen Dominos ein Post\u00b4sches Korrespondenzproblem gel\u00f6st. Und ich habe ein zweites Problem gezeigt, \ndas aber schon eine ziemlich lange Folge von Dominos zur L\u00f6sung erfordert h\u00e4tte. Danach konnten wir in der Vorlesungszeit nicht ernsthaft suchen.\n\nWie l\u00f6st das ein Informatiker?\n\n(1) Das Problem vern\u00fcnftig modellieren.\n\nEine m\u00f6gliche, ziemlich pr\u00e4zise Formalisierung zu dem Problem haben wir schon in der Vorlesung gesehen, [s. Folie 34 in der Pr\u00e4sentation](https:\/\/moodle.w-hs.de\/pluginfile.php\/410509\/mod_resource\/content\/5\/Vorlesungen\/Vorlesung-zur-geschichte-inf.pdf#page=34). Die k\u00f6nnen wir praktisch \ndirekt in einem Programm verwenden, s. unten.\n\n(2) Ein Programm schreiben, um das Problem zu l\u00f6sen. \n\nDazu brauchen wir zun\u00e4chst eine Idee: Was soll das Programm tun?\n    \nDie grunds\u00e4tzliche Idee haben wir schon kennengelernt: wir suchen systematisch nach einer L\u00f6sung. \nL\u00f6sungskandidaten bauen wir in einem Baum zusammen, in dem wir nach und nach Entscheidungen f\u00fcr den n\u00e4chsten Dominostein treffen.\nDies wollen wir _schichtweise_ tun (das nennt sich _Breitensuche_, klar, wir suchen nach einer L\u00f6sung und gehen dabei in die Breite des Baumes, Schicht f\u00fcr Schicht)\n\nWir setzen \u00c4ste des Baumes nur fort, wenn wir noch keine L\u00f6sung gefunden haben, die durch den Ast repr\u00e4sentierte Auswahl aber m\u00f6glicherweise noch zu einer L\u00f6sung erg\u00e4nzbar ist. \u00c4ste, die sich nicht in g\u00fcltiger Weise fortsetzen lassen, beenden wir nat\u00fcrlich.\n\nDas kann man sehr straight\" auch im Code sehen. Wir verwenden dazu eine der derzeitigen \"Top-3-Sprachen\", Python.\n\nProbieren wir es:","fc934a70":"# Python, Berechenbarkeit und Anderes","5aa100b2":"Klar, in der Funktion _search_ macht es jetzt keinen rechten Sinn mehr, x und y \u00fcberhaupt zur\u00fcck zu geben (die enthalten nur das Ende der L\u00f6sung). Das k\u00f6nnen Sie, lieber Leser, weiter unten einfach noch selbst korrigieren!\n\n\n_Den nachfolgenden Kommentar d\u00fcrfen Sie ignorieren:_\n\nWas man auch noch machen k\u00f6nnte: man k\u00f6nnte GANZ auf das Mitf\u00fchren von Strings verzichten. Die naive Idee: jedesmal den String vor dem Testen aus der Sequenz neu erzeugen, ist aber echt unschlau (weil man sehr, sehr oft die Anfangsteile neu erzeugen w\u00fcrde). Man k\u00f6nnte sich zwar weiterhin die letzte Pr\u00fcfposition im String merken (wie in der L\u00f6sung f\u00fcr _isValid_ etwas weiter oben) und so das redundante Testen vermeiden, aber das Erzeugen ist schon sehr teuer!\n\nWas man ausprobieren k\u00f6nnte, w\u00e4re, sich zu merken, bis zu welcher Position in der Indexsequence man schon komplett getestet hat (getrennt f\u00fcr x und y) und bei welchem Zeichen man im folgenden Index f\u00fcr x und y jeweils ist (das ist jetzt nicht so leicht zu verstehen, eine der Zeichenpositionen w\u00e4re \u00fcbrigens immer 0, das k\u00f6nnte sich allerdings abwechseln). Dann k\u00f6nnte man zielgerichtet nur das Erzeugen, was man f\u00fcr die Kontrolle der Validit\u00e4t braucht (immer noch nicht trivial, merken Sie, wenn sie die Details probieren w\u00fcrden). Das wird aber ziemlich kompliziert und bringt nur substantiell etwas, wenn die \"Reste\" von x oder von y weit auseinanderlaufen (also einer davon ziemlich lang wird). Der Aufwand lohnt bei diesem \"k\u00fcnstlichen\" Problem eher nicht - und er w\u00fcrde die _isValid_-Test-Mechanik auch ganz sch\u00f6n kompliziert machen. Wenn das Programm am Ende schnell, aber falsch ist, hilft das auch niemandem! (das ist \u00fcbrigens ein typisches Resultat von Optimierungen in den ersten, sagen wir mal, 5 Jahren ihres Studiums... ;)"}}