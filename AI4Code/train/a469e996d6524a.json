{"cell_type":{"28a00af1":"code","8aea9130":"code","1b1ae13e":"code","2fc385ca":"code","3bb80ef3":"code","58bd11f2":"code","f70f8474":"markdown","0437281c":"markdown","1002a174":"markdown","5dbb5263":"markdown","e279a5f7":"markdown"},"source":{"28a00af1":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm","8aea9130":"class Agent:\n\n    def __init__(self):\n        # for now the only attribute an agent has is v_u which is the min. requirement when the agent is a firm and the productivity if the agent is a worker\n        self.v_u = np.nan\n        pass\n\n    def create_agent(self, distribution, pop):\n        # assigns v or u randomly and inserts the agent into the sorted population\n        self.v_u = np.random.uniform(low=distribution.lower, high=distribution.upper, size=None)\n        if len(pop) == 0 or self.v_u <= pop[-1].v_u:\n            pop.append(self)\n        else:\n            for i in range(len(pop)):\n                if self.v_u > pop[i].v_u:\n                    pop.insert(i, self)\n                    break\n\n\nclass Distribution:\n\n    def __init__(self, upper, lower):\n        # for now only uniform distributions\n        self.upper = upper\n        self.lower = lower\n\n\nclass Simulation:\n\n    def __init__(self, population_size, dist_v, dist_u):\n        self.num_matches = 0\n        self.firm_population = []\n        self.worker_population = []\n        self.population_size = population_size\n        self.dist_v = Distribution(dist_v[0], dist_v[1]) # Distribution firm min requirements\n        self.dist_u = Distribution(dist_u[0], dist_u[1]) # Distribution worker productivity\n\n    def run_sim_seq(self):\n        # running the sequential simulation\n        for p in range(self.population_size):\n            Agent().create_agent(self.dist_u, self.worker_population)\n            Agent().create_agent(self.dist_v, self.firm_population)\n            self.match()\n\n    def run_sim_sim(self):\n        # running the simultaneous simulation\n        for p in range(self.population_size):\n            Agent().create_agent(self.dist_u, self.worker_population)\n            Agent().create_agent(self.dist_v, self.firm_population)\n        self.match()\n\n    def match(self):\n        # matches the worker with the highest u with the firm with the highest v aslong as v <= u\n        tmp_firm_pop = []\n        for firm in range(len(self.firm_population)):\n            if self.firm_population[firm].v_u <= self.worker_population[0].v_u:\n                self.worker_population.pop(0)\n                self.num_matches += 1\n            else:\n                tmp_firm_pop.append(self.firm_population[firm])\n        self.firm_population = tmp_firm_pop","1b1ae13e":"# r := list of population sizes\n# n := number of simulations per r\n# dist1 := distribution for min requirements insert in form of a list [min, max]\n# dist2 := distribution for productivities insert in form of a list [min, max]\n# seq := simultaneous or sequential matching (sequential = True, simultaneous = False)\ndef run_range_of_sims(r, n, dist1, dist2, seq = False):\n    means = []\n    for i in r:\n        print('number of Openings\/Candidates: ' + str(i))\n        tmp_mean = []\n        for j in tqdm(range(n)):\n            sim = Simulation(i, dist1, dist2)\n            if seq:\n                sim.run_sim_seq()\n            else:\n                sim.run_sim_sim()\n            tmp_mean.append(sim.num_matches \/ i)\n        means.append(np.mean(tmp_mean))\n    return means","2fc385ca":"# Considered sizes for U and V\nN = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100]\n# Number of simulations\nn = 30000","3bb80ef3":"simultaneous = run_range_of_sims(N, n, [0, 1], [0, 1])\nsequential = run_range_of_sims(N, n, [0, 1], [0, 1], True)\nsimultaneous_lower = run_range_of_sims(N, n, [0, 1], [0, 0.9])\nsimultaneous_higher = run_range_of_sims(N, n, [0, 1], [0, 1.1])","58bd11f2":"fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20,10))\nax1.plot(N, simultaneous, color = 'deeppink')\nax1.plot(N, sequential, color = 'darkturquoise')\nax1.set_title('Simultaneous matching compared to sequential matching')\nax1.legend(('Simultaneous', 'Sequential'))\nax1.set_xlabel('Openings\/Candidates')\nax1.set_ylabel('Matching Probability')\nax2.plot(N, simultaneous, color = 'black')\nax2.plot(N, simultaneous_lower, color = 'darkturquoise')\nax2.plot(N, simultaneous_higher, color = 'deeppink')\nax2.set_title('Differing mean productivities in the case of simultaneous matching')\nax2.legend(('Identical distributions', 'Lower worker productivity', 'Higher worker productivity'))\nax2.set_xlabel('Openings\/Candidates')\nax2.set_ylabel('Matching Probability')\nplt.show()","f70f8474":"# Introduction\n\nLi and Gan (2004) showed that labor markets become more efficient at matching employers and employees the thicker the market is. Their paper includes a matching model, simulations of this model and an empirical analysis of the market for PhD Economists. In this notebook I will try to recreate the simulation results.","0437281c":"# The Simulation\n\nMy replication of the simulation will only consider the situation when the number of openings is equal to the number of candidates. I will look at a range of number of openings\/candidates from 1 to 100 and I will simulate the matching process for each considered marekt size 30,000 times.  ","1002a174":"# The Results","5dbb5263":"# The Model\n\nThere are V firms and U workers in the market. Each worker has a productivity of u which is drawn from a continuous distribution. A firm's profit function will be described as \u03c0(u, v) = max{0, u \u2212 v}, where v is the firms minimum requirement which is also drawn from a continuous distribution. The firm has only one opening and will maximize their profit by either hiring the available worker with the highest productivity that is at least as large as the minimum requirement or by not hiring a worker. A workers utility function will be w(u, v) = max{0, v}. This means they will work for any firm with v >= 0 but they prefer firms with a larger v. Both the firm and the worker will leave the market when they match. \n\nWhat this essentially means is that the firm with the largest minimum requirement will match with the worker who has the largest productivity as long as the productivity is at least as large as the minimum requirement. If the match happens both will leave the market. Otherwise we will try to match the firm with the next largest minimum requirement. This process repeats until no match is possible.\n\n**Simultaneous Matching**\n\nAll agents arrive at the same time and are then matched.\n\n**Sequential Matching**\n\nThe agents arrive pairwise and can match with each other or the existing stock. Firms and workers who don't match with any agent will enter the stock. In the following simulation I will only consider the situation without rematching.","e279a5f7":"My results match the results from the original paper. We can see that the matching probability increases the thicker the market becomes.\n\n# Sources\n\n* Gan, L., & Li, Q. (2004). Efficiency of thin and thick markets. National Bureau of Economic Research. https:\/\/www.nber.org\/papers\/w10815"}}