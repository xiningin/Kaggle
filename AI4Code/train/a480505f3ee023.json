{"cell_type":{"108eddef":"code","d69be472":"code","e6003bbd":"code","e784335b":"code","c25c2fd7":"code","54c5e1fa":"code","ef9b5055":"code","f075217b":"code","431707b2":"code","32418ec2":"code","27e0516a":"markdown","785d3d7c":"markdown","4b39e7eb":"markdown","741f4a14":"markdown","8132ac11":"markdown","6697bf4e":"markdown","7fda2204":"markdown","47faa498":"markdown","22dbe9d7":"markdown","a8a21497":"markdown","a266cf4e":"markdown"},"source":{"108eddef":"import numpy as np\nimport time\nfrom tqdm import tqdm\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nimport seaborn as sns","d69be472":"def bench(cases):\n    elapsed = {}\n    for name, case in tqdm(cases.items()):\n        algorithm = case['algorithm']\n        estimator = algorithm['estimator'](**algorithm['params'])\n        data = case['data']\n        x, y = data['generator'](**data['params'])\n        \n        # Timing of fit and predict    \n        start = time.time()\n        estimator.fit(x, y)\n        if hasattr(estimator, 'predict'):\n            estimator.predict(x)\n        time_measure = time.time() - start\n        \n        elapsed[name] = time_measure\n    return elapsed","e6003bbd":"def get_cases():\n    import sklearn\n    import sklearn.svm, sklearn.datasets, sklearn.neighbors, sklearn.linear_model\n    return {\n    'SVC with Linear Kernel': {\n        \"algorithm\": {\n            'estimator': sklearn.svm.SVC,\n            'params': {\n                'C': 1.0,\n                'kernel': 'linear',\n            }\n        },\n        \"data\": {\n            'generator': sklearn.datasets.make_classification,\n            'params':\n            {\n                'n_samples': 20000,\n                'n_features': 30,\n                'n_classes': 3,\n                'n_informative': 3,\n                'random_state': 43,\n            }\n        }\n    },\n    'SVC with RBF Kernel': {\n        \"algorithm\": {\n            'estimator': sklearn.svm.SVC,\n            'params': {\n                'C': 1.0,\n                'kernel': 'rbf',\n            }\n        },\n        \"data\": {\n            'generator': sklearn.datasets.make_classification,\n            'params':\n            {\n                'n_samples': 25000,\n                'n_features': 30,\n                'n_classes': 5,\n                'n_informative': 4,\n                'random_state': 43,\n            }\n        }\n    },\n    'Logistic Regression': {\n        \"algorithm\": {\n            'estimator': sklearn.linear_model.LogisticRegression,\n            'params': {\n                'n_jobs': -1,\n                'random_state': 43,\n                'max_iter': 300\n            }\n        },\n        \"data\": {\n            'generator': sklearn.datasets.make_classification,\n            'params':\n            {\n                'n_samples': 1000000,\n                'n_features': 40,\n                'n_classes': 10,\n                'n_informative': 5,\n                'random_state': 43,\n            }\n        }\n    },\n    'KNN Classifier': {\n        \"algorithm\": {\n            'estimator': sklearn.neighbors.KNeighborsClassifier,\n            'params': {\n                'n_jobs': -1,\n            }\n        },\n        \"data\": {\n            'generator': sklearn.datasets.make_classification,\n            'params':\n            {\n                'n_samples': 35000,\n                'n_features': 30,\n                'n_classes': 3,\n                'n_informative': 3,\n                'random_state': 43,\n            }\n        }\n    },\n    'KNN Regression': {\n        \"algorithm\": {\n            'estimator': sklearn.neighbors.KNeighborsRegressor,\n            'params': {\n                'n_neighbors': 10,\n                'n_jobs': -1,\n            }\n        },\n        \"data\": {\n            'generator': sklearn.datasets.make_regression,\n            'params':\n            {\n                'n_samples': 35000,\n                'n_features': 30,\n                'random_state': 43,\n            }\n        }\n    },\n    'Linear Regression': {\n        \"algorithm\": {\n            'estimator': sklearn.linear_model.LinearRegression,\n            'params': {\n                'n_jobs': -1,\n            }\n        },\n        \"data\": {\n            'generator': sklearn.datasets.make_regression,\n            'params':\n            {\n                'n_samples': 3000000,\n                'n_features': 100,\n                'n_targets': 60,\n                'random_state': 43,\n            }\n        }\n    }, \n    'PCA': {\n            \"algorithm\": {\n            'estimator': sklearn.decomposition.PCA,\n            'params': {\n                'n_components': 90,\n                'svd_solver': 'full',\n                'random_state': 43,\n            }\n        },\n        \"data\": {\n            'generator': sklearn.datasets.make_blobs,\n            'params':\n            {\n                'n_samples': 3000000,\n                'n_features': 100,\n                'centers': 20,\n                'random_state': 43,\n            }\n        }\n    },\n}","e784335b":"cases = get_cases()\nsklearn_result = bench(cases)","c25c2fd7":"print('Result of original scikit-learn : ', sklearn_result)","54c5e1fa":"!pip install scikit-learn-intelex --progress-bar off >> \/tmp\/pip_sklearnex.log","ef9b5055":"from sklearnex import patch_sklearn\npatch_sklearn()","f075217b":"cases = get_cases()\nsklearnex_result = bench(cases)","431707b2":"print('Result of scikit-learn with Intel(R) Extension: ', sklearnex_result)","32418ec2":"result = { name_sk: [time_ex, time_sk] for (name_sk, time_sk), \n          (name_ex, time_ex) in zip(sklearn_result.items(), sklearnex_result.items())}\nresult['Library'] = ['sklearnex', 'sklearn']\ndf = pd.DataFrame(data=result).melt('Library', var_name='Algorithms', value_name='Time')\n\nfig = plt.figure(figsize=(18, 6))\nfig.patch.set_alpha(1)\n\nplt.subplot(1, 1, 1)\n\nbarplot = sns.barplot(x='Algorithms', y='Time', hue='Library',\n                      data=df, errwidth = 2,\n                      capsize = 0.05, saturation = 8,)\n\nfor p in barplot.patches:\n    barplot.annotate(format(p.get_height(), '.0f'),\n                     (p.get_x() + p.get_width() \/ 2., p.get_height() + 2),\n                     ha = 'center', va = 'center')\n\nplt.legend(loc=2)\nplt.ylabel(\"Time (sec)\", size=14)\nplt.xlabel(\"algorithms\", size=14)\nplt.title(\"Performance result\")\nplt.show()","27e0516a":"# \u26a1 Performance measure of the scikit-learn with Intel(R) Extension","785d3d7c":"To get optimizations, patch scikit-learn using Intel(R) Extension for Scikit-learn:","4b39e7eb":"# \ud83d\udcca Analysis of result","741f4a14":"All algorithms were greatly accelerated, instead of minutes, they worked in just a few seconds! Acceleration reaches **up to 100 times** - imagine how simple and fast it is now to compute your kernels with scikit-learn applications using Intel(R) Extension!","8132ac11":"Let's try to use sklearnex. First, download it:","6697bf4e":"# \ud83d\ude80Accelerate scikit-learn algorithms using Intel(R) Extension\nFor classical machine learning algorithms, we often use the most popular Python library, scikit-learn. We use it to fit models and search for optimal parameters, but\u202fscikit-learn\u202fsometimes works for hours, if not days. Speeding up this process is something anyone who uses scikit-learn would be interested in.\n\nI want to show you how to get results faster without changing the code. To do this, we will use another Python library,\u202f**[Intel(R) Extension for Scikit-learn*](https:\/\/github.com\/intel\/scikit-learn-intelex)**. It accelerates scikit-learn and does not require you changing the code written for scikit-learn.\n","7fda2204":"# \ud83d\udcda Algorithms and parameters\n\nI selected the most popular algorithms from scikit-learn: SVM's, KNN's, Linear Regression and PCA.\n\nThey are also accelerated with Intel(R) Extension for Scikit-learn*. You can see the full list [here](https:\/\/intel.github.io\/scikit-learn-intelex\/algorithms.html).\n\nI selected the parameters and datasets so that it would work for about 1 minute for original scikit-learn.","47faa498":"# \ud83d\udcdc Conclusions\n\nWith Intel(R) Extension for Scikit-learn* patching you can:\n\n- Use your scikit-learn code for training and inference without modification.\n- Train and predict scikit-learn models **up to 100 times faster**.\n- Get the same quality of predictions as other tested frameworks.\n\nIntel(R) Extension for Scikit-learn* adds more accelerated scikit-learn algorithms to each release, learn what algorithms are optimized [here](https:\/\/intel.github.io\/scikit-learn-intelex\/).","22dbe9d7":"# \u23f3 Performance measure of the scikit-learn","a8a21497":"# \ud83d\udeb4 Benchmarks\n\nAs a measurement, I made a function in which both methods: training and prediction.\n","a266cf4e":"\u2714\ufe0f Please note that sklearnex has not changed a single line of code for the called scikit-learn algorithms. Moreover, sklearnex guarantees the same accuracy."}}