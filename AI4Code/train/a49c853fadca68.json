{"cell_type":{"ab8bae8b":"code","650f691b":"code","42d93f11":"code","1e719aa6":"code","c1f4920a":"code","54eab65a":"code","fe1922bc":"code","7e6f36a7":"code","2c1a4aa7":"code","7b1f39e4":"code","d017b0a6":"markdown","e80979bf":"markdown","c1655091":"markdown","2b46156e":"markdown","448ddb69":"markdown","9f89766e":"markdown","f021a956":"markdown","a66af1db":"markdown","969eccf1":"markdown","b5d3bae1":"markdown"},"source":{"ab8bae8b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","650f691b":"!python -m pip install snap-stanford\nimport snap\n\n","42d93f11":"import numpy as np\n\ndef erdos_renyi(n,m):\n  '''\n  Generare Erdos-Renyi graph in snap format of Graph\n  Input:\n  n - number of nodes\n  m - number of edges\n  '''\n  #n = 5242;  m = 14484\n  G = snap.TUNGraph.New(n,m) # Allocate memory for UNdirected graph n-nodes, m-edges\n  for i in range(n): # Add n-nodes  \n    G.AddNode(i)\n  for i in range(m): # Add m edges connected at random \n    while True: # technical loop - check we are not adding already existing edges \n      v1 = np.random.randint(0,n )\n      v2 = np.random.randint(0,n )\n      if v1 == v2: \n        continue\n      if G.IsEdge(v1,v2):\n        continue\n      G.AddEdge(v1,v2)\n      break\n  return G\n\nG = erdos_renyi(5242,14484)\nprint(G.GetNodes(), G.GetEdges() )    \nprint('Mean Degree', np.mean( [n.GetDeg() for n in G.Nodes()] ),\n      'Median Degree', np.median( [n.GetDeg() for n in G.Nodes()] ),\n      'Max Degree', np.max( [n.GetDeg() for n in G.Nodes()] ),\n      'Min Degree', np.min( [n.GetDeg() for n in G.Nodes()] ) )\n","1e719aa6":"import numpy as np\n\ndef watts_strogatz (n, n_pairs_additionally_connected  ):\n  '''\n  Generate small world (Watts-Strogatz) model, i.e. first generate circle graph, than make additional connections i,i+2 nodes (round-upped),\n  and then additionally connect several radomly selected nodes (not previously connected). \n\n  Ouput: G - snap undirected graph ( snap.TUNGraph.New() )\n  '''\n  #n = 5242\n  #n_pairs_additionally_connected  = 4000 \n\n  G = snap.TUNGraph.New() # UNdirected graph \n  for i in range(n): # Add n-nodes  \n    G.AddNode(i)\n\n  G.AddEdge(0, n-1) # Round-up edge to make circle \n  for i in range(n-1): # connect i,i+1 nodes\n    G.AddEdge(i, i+1) # C\n  G.AddEdge(0, n-2) #  \n  G.AddEdge(1, n-1) #  \n  for i in range(n-2): # connect i,i+2 nodes\n    G.AddEdge(i, i+2) # C\n\n  for i in range(n_pairs_additionally_connected): # Connect n_pairs_additionally_connected  Add m edges connected at random \n    while True: # technical loop - check we are not adding already existing edges \n      v1 = np.random.randint(0,n )\n      v2 = np.random.randint(0,n )\n      if v1 == v2: \n        continue\n      if G.IsEdge(v1,v2):\n        continue\n      G.AddEdge(v1,v2)\n      break\n\n  return G\n\nG =  watts_strogatz (5242, 4000  )\nprint(G.GetNodes(), G.GetEdges() ) \nprint('Mean Degree', np.mean( [n.GetDeg() for n in G.Nodes()] ),\n      'Median Degree', np.median( [n.GetDeg() for n in G.Nodes()] ),\n      'Max Degree', np.max( [n.GetDeg() for n in G.Nodes()] ),\n      'Min Degree', np.min( [n.GetDeg() for n in G.Nodes()] ) )\n\n","c1f4920a":"\ndef load_CoathorsArxivGrQc():\n    filepath = \"\/kaggle\/input\/ml-in-graphs-hw1\/ca-GrQc.txt\"\n    import os\n    print('File exists: ',  os.path.isfile(filepath  )  )\n\n    G = snap.LoadEdgeList(snap.PUNGraph,filepath,0,1) \n    snap.DelSelfEdges(G)\n    return G\nG = load_CoathorsArxivGrQc()\nprint(G.GetNodes(), G.GetEdges() ) \nprint('Mean Degree', np.mean( [n.GetDeg() for n in G.Nodes()] ),\n      'Median Degree', np.median( [n.GetDeg() for n in G.Nodes()] ),\n      'Max Degree', np.max( [n.GetDeg() for n in G.Nodes()] ),\n      'Min Degree', np.min( [n.GetDeg() for n in G.Nodes()] ) )","54eab65a":"import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('ggplot')\nfig = plt.figure( figsize = (15,6 ) )\nplt.suptitle('Degree Distribution of Erdos Renyi, Small World, and Collaboration Networks')\n\nfor i,graph_type in enumerate(['ErdosRenyi','SmallWorld','CoathorsArxivGrQc']):\n    if graph_type == 'ErdosRenyi':\n        G = erdos_renyi(5242,14484)\n        if 0: # Built-in way for Erdos-Renyi:\n            G = snap.GenRndGnm(snap.PNGraph, 5242,14484) # 1000, 10000)\n    if graph_type == 'SmallWorld':\n        G =  watts_strogatz(5242, 4000  )\n    if graph_type == 'CoathorsArxivGrQc':\n        G = load_CoathorsArxivGrQc()\n\n    CntV = snap.TIntPrV()\n    snap.GetOutDegCnt(G, CntV)\n    list_degs = []\n    list_counts = []\n    for p in CntV:\n      #print(\"degree %d: count %d\" % (p.GetVal1(), p.GetVal2()))\n      list_degs.append(p.GetVal1() )\n      list_counts.append(p.GetVal2() )\n\n    fig.add_subplot(1,2,1)\n    plt.loglog(list_degs, list_counts, linestyle = 'dotted',  label = graph_type)# color = 'b', #Collaboration Network')\n    plt.xlabel('Node Degree (log)')\n    plt.ylabel('Proportion of Nodes with a Given Degree (log)')\n    plt.title('loglog plot')\n    plt.legend()\n\n    fig.add_subplot(1,2,2)\n    plt.plot(list_degs, list_counts, linestyle = 'dotted', label = graph_type)# color = 'b',  #Collaboration Network')\n    plt.xlabel('Node Degree')\n    plt.ylabel('Proportion of Nodes with a Given Degree')\n    plt.title('NOT loglog plot')\n    plt.legend()\nplt.show()\n\n","fe1922bc":"def clustering_coef(G , mode_for_end_nodes = 'put_zeros' ):\n  '''\n  Calculate vector of clustering coefficient for each node \n  input G - snap undirected Graph \n  mode_for_end_nodes = 'nan' - end\/disconnected nodes will be ignored i.e. non included in output list\n  mode_for_end_nodes = 'put_zero' - assign zero for end\/disconnected\n\n  Example:\n  # Create triangle graph \n  Gsmall = snap.TUNGraph.New() \n  Gsmall.AddNode(1) # Add nodes \n  Gsmall.AddNode(2)\n  Gsmall.AddNode(3)\n  Gsmall.AddEdge(1,2)\n  Gsmall.AddEdge(1,3)\n  Gsmall.AddEdge(2,3)\n \n  list_clusterning_coefs4nodes = clustering_coef(Gsmall)\n  # We get [1,1,1] - all clustering coefs = 1\n  '''\n  list_clusterning_coefs4nodes = []\n  for n in G.Nodes():\n    NodeVec = snap.TIntV()\n    snap.GetNodesAtHop(G, n.GetId(), 1, NodeVec, False) # Get neigbours of current node # https:\/\/snap.stanford.edu\/snappy\/doc\/reference\/GetNodesAtHop.html\n    current_degree = len(NodeVec) # same as n.GetDeg()\n    if current_degree <= 1: # skip disconnected&end nodes - impossible to calculate for them - getting division by zero\n      if mode_for_end_nodes == 'nan':\n        continue \n      else:\n        list_clusterning_coefs4nodes.append(0)\n        continue\n    count_edges_between_neigbours = 0\n    for neigbor1 in NodeVec:\n      for neigbor2 in NodeVec:\n        if neigbor1 >= neigbor2:\n          continue\n        if G.IsEdge(neigbor1, neigbor2):\n          count_edges_between_neigbours += 1\n    clustering_coef4current_node = 2*count_edges_between_neigbours\/ (current_degree * (current_degree-1)  )\n    list_clusterning_coefs4nodes.append(clustering_coef4current_node)\n  return list_clusterning_coefs4nodes\n\n\n\nGsmall = snap.TUNGraph.New() \nGsmall.AddNode(1) # Add nodes \nGsmall.AddNode(2)\nGsmall.AddNode(3)\nGsmall.AddEdge(1,2)\nGsmall.AddEdge(1,3)\nGsmall.AddEdge(2,3)\n\nlist_clusterning_coefs4nodes = clustering_coef(Gsmall)\nlist_clusterning_coefs4nodes","7e6f36a7":"import numpy\nfor i,graph_type in enumerate(['ErdosRenyi','SmallWorld','CoathorsArxivGrQc']):\n    if graph_type == 'ErdosRenyi':\n        G = erdos_renyi(5242,14484)\n        if 0: # Built-in way for Erdos-Renyi:\n            G = snap.GenRndGnm(snap.PNGraph, 5242,14484) # 1000, 10000)\n    if graph_type == 'SmallWorld':\n        G =  watts_strogatz(5242, 4000  )\n    if graph_type == 'CoathorsArxivGrQc':\n        G = load_CoathorsArxivGrQc()\n        \n    list_clusterning_coefs4nodes = clustering_coef(G , mode_for_end_nodes = 'put_zeros' )\n\n    # Compare with built-in implementation:\n    GraphClustCoeff = snap.GetClustCf (G, -1)\n\n    print(graph_type,'Clustering coef:', np.mean(list_clusterning_coefs4nodes), \n          'same by built-in function:', GraphClustCoeff)\n","2c1a4aa7":"### Teting Clustering coef. Triangle graph example - get [1,1,1] - correct\n\nprint('Triangle graph')\nGsmall = snap.TUNGraph.New() \nGsmall.AddNode(1) # Add nodes \nGsmall.AddNode(2)\nGsmall.AddNode(3)\nGsmall.AddEdge(1,2)\nGsmall.AddEdge(1,3)\nGsmall.AddEdge(2,3)\n\nlist_clusterning_coefs4nodes = clustering_coef(Gsmall)\nprint(list_clusterning_coefs4nodes )\n\nprint('Check with built-in function:')\nNIdCCfH = snap.TIntFltH()\nsnap.GetNodeClustCf(Gsmall, NIdCCfH)\nfor item in NIdCCfH:\n    print(item, NIdCCfH[item])\nprint()\nprint()\n\n\n### Testing  Clustering coef. Square graph example - get [0,0,0,0] - correct\nprint('Square graph')\nG = snap.TUNGraph.New() \nG.AddNode(1) # Add nodes \nG.AddNode(2)\nG.AddNode(3)\nG.AddNode(4)\nG.AddEdge(1,2)\nG.AddEdge(2,3)\nG.AddEdge(3,4)\nG.AddEdge(4,1)\n\nlist_clusterning_coefs4nodes = clustering_coef(G)\nprint( list_clusterning_coefs4nodes )\n\nprint('Check with built-in function:')\nNIdCCfH = snap.TIntFltH()\nsnap.GetNodeClustCf(G, NIdCCfH)\nfor item in NIdCCfH:\n    print(item, NIdCCfH[item])\n    \nprint()\nprint()\n\n\n### Testing  Clustering coef. Erdos-Renyi graph - compare result with built-in function\nprint('Erdos-Renyi graph')\nG = erdos_renyi(5242,14484)\nlist_clusterning_coefs4nodes = clustering_coef(G, mode_for_end_nodes='put_zero')\nprint( np.mean(list_clusterning_coefs4nodes) )\n\nprint('Compare with built-in function GetNodeClustCf')\nNIdCCfH = snap.TIntFltH()\nsnap.GetNodeClustCf(G, NIdCCfH)\nl = [NIdCCfH[item] for item in NIdCCfH ]\nprint(np.mean(l) )\nprint('Compare with built-in function GraphClustCoeff')\nGraphClustCoeff = snap.GetClustCf (G, -1)\nprint(\"Clustering coefficient: %f\" % GraphClustCoeff)\n","7b1f39e4":"import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('ggplot')\nfig = plt.figure( figsize = (15,6 ) )\n\nfor i,graph_type in enumerate(['ErdosRenyi','SmallWorld','CoathorsArxivGrQc']):\n    if graph_type == 'ErdosRenyi':\n        G = erdos_renyi(5242,14484)\n        if 0: # Built-in way for Erdos-Renyi:\n            G = snap.GenRndGnm(snap.PNGraph, 5242,14484) # 1000, 10000)\n    if graph_type == 'SmallWorld':\n        G =  watts_strogatz(5242, 4000  )\n    if graph_type == 'CoathorsArxivGrQc':\n        G = load_CoathorsArxivGrQc()\n\n    CntV = snap.TIntPrV()\n    snap.GetOutDegCnt(G, CntV)\n    list_degs = []\n    list_counts = []\n    for p in CntV:\n      #print(\"degree %d: count %d\" % (p.GetVal1(), p.GetVal2()))\n      list_degs.append(p.GetVal1() )\n      list_counts.append(p.GetVal2() )\n\n    CfVec = snap.TFltPrV()\n    snap.GetClustCf(G, CfVec, -1) # https:\/\/snap.stanford.edu\/snappy\/doc\/reference\/GetClustCf1.html\n    list_degs = []\n    list_cluster_coef_mean_for_degree = []\n    for p in CfVec:\n      list_degs.append(p.GetVal1() )\n      list_cluster_coef_mean_for_degree.append(p.GetVal2() )\n\n    plt.loglog(list_degs, list_cluster_coef_mean_for_degree, linestyle = 'dotted', label = graph_type)# , color = 'b' 'Collaboration Network')\n\n    plt.xlabel('Node Degree (log)')\n    plt.ylabel('Clustering coefficient (mean for nodes with a Given Degree)  (log)')\n    plt.title('Degree Distribution of Erdos Renyi, Small World, and Collaboration Networks')\n    plt.legend()\n\nplt.show()\n\n#for pair in CfVec:\n#    print(\"degree: %d, clustering coefficient: %f\" % (pair.GetVal1(), pair.GetVal2()))\n\nprint('Comment: for small world model we get a declining line - as expected for many natural networks',\n      'but actually for real graph of coauthorship we get not very declining line',\n        'for Erdos-Renyi we get that coefficient does not depend on degree')","d017b0a6":"# 1 Network Characteristics\n\nOne of the goals of network analysis is to find mathematical models that characterize real-world\nnetworks and that can then be used to generate new networks with similar properties. In this\nproblem, we will explore two famous models\u2014Erd\u0151s-R\u00e9nyi and Small World\u2014and compare them\nto real-world data from an academic collaboration network. Note that in this problem all networks\nare undirected. You may use the starter code in hw1-q1-starter.py for this problem.\n\nTemplate: http:\/\/snap.stanford.edu\/cs224w-17-data\/hw1\/q1-starter.py\n","e80979bf":"## Appendix. Clustering coefficient plots - averaged over degrees ","c1655091":"# 1.2 Clustering coef - handy implementation - [13] points\n\nRecall that the local clustering coefficient for a node v i was defined in class as\n\nCi={2|ei|ki\u22c5(ki\u22121)0ki\u22652otherwise,\nwhere k i is the degree of node v i and e i is the number of edges between the neighbors of v i . The average clustering coefficient is defined as\n\nC=1|V|\u2211i\u03f5VCi\nCompute and report the average clustering coefficient of the three networks. For this question,\nwrite your own implementation to compute the clustering coefficient, instead of using a built-in\nSNAP function. Which network has the largest clustering coefficient? In one to two sentences, explain. Think about the underlying process that generated the network.\n\nWhat to submit\n\nPage 2:\n\nAverage clustering coefficient for each network.\nNetwork that has the largest average clustering coefficient.\nOne to two sentences explaining why this network has the largest average clustering\ncoefficient.\n\n----------------\n\nBeware: such clustering coefficients were defined by Watts and Strogatz in 1999, \nbefore another version of \"global clustering coefficient\" was considered - \nnot an average of clustering coefficients for each node, but just  3*(number of triangles)\/(number of triplets)\n\nSee https:\/\/en.wikipedia.org\/wiki\/Clustering_coefficient","2b46156e":"### Testing clustering coefficient function - simple examples and comparaisons with built-in","448ddb69":"# What is about ?\n\nSolutions to exercises HW1 cs224w Part 1. Network Characteristics\n\nPreliminary draft June 2020 AC","9f89766e":"### Real-World Collaboration Network: \n\nDownload this undirected network from http:\/\/snap.stanford.edu\/data\/ca-GrQc.txt.gz. Nodes in this network represent authors of research papers on the arXiv in the General Relativity and Quantum Cosmology section. There is\nan edge between two authors if they have co-authored at least one paper together. Note\nthat some edges may appear twice in the data, once for each direction. Ignoring repeats and\nself-edges, there are 5242 nodes and 14484 edges. (Note: Repeats are automatically ignored\nwhen loading an (un)directed graph with SNAP\u2019s LoadEdgeList function).","f021a956":"#  1.1  Write code for Erdos-Renyi and Small World (Watts-Strogaz) models, make loglog degree plots for them and for academic coauthotship real dataset [12 points]\n\nGenerate a random graph from both the Erd\u0151s-R\u00e9nyi (i.e., G(n, m)) and Small-World models and\nread in the collaboration network. Delete all of the self-edges in the collaboration network (there\nshould be 14,484 total edges remaining).\nPlot the degree distribution of all three networks in the same plot on a log-log scale. In other words,\ngenerate a plot with the horizontal axis representing node degrees and the vertical axis representing\nthe proportion of nodes with a given degree (by \u201clog-log scale\u201d we mean that both the horizontal\nand vertical axis must be in logarithmic scale). In one to two sentences, describe one key difference\nbetween the degree distribution of the collaboration network and the degree distributions of the\nrandom graph models.\n\nWhat to submit\nPage 1:\n\nLog-log degree distribution plot for all three networks (in same plot)","a66af1db":"### Small-world (Watts\u2013Strogatz) model \n\nGenerate an instance from this model as follows: begin with\nn = 5242 nodes arranged as a ring, i.e., imagine the nodes form a circle and each node is\nconnected to its two direct neighbors (e.g., node 399 is connected to nodes 398 and 400),\ngiving us 5242 edges. Next, connect each node to the neighbors of its neighbors (e.g., node\n399 is also connected to nodes 397 and 401). This gives us another 5242 edges. Finally,\nrandomly select 4000 pairs of nodes not yet connected and add an edge between them. In\ntotal, this will make m = 5242 * 2+4000 = 14484 edges. Write code to construct instances of\nthis model, i.e., do not call a SNAP function.\n\nhttps:\/\/en.wikipedia.org\/wiki\/Watts%E2%80%93Strogatz_model\n","969eccf1":"### Erd\u0151s-R\u00e9nyi Random graph (G(n, m) random network): \nGenerate a random instance of this model by using n = 5242 nodes and picking m = 14484 edges at random. Write code to construct instances of this model, i.e., do not call a SNAP function.","b5d3bae1":"### Degree distribution plots\n"}}