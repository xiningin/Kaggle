{"cell_type":{"6fa0e68d":"code","2a441a5a":"code","53bcd739":"code","9080f0d4":"code","ab1f0273":"code","f0e66cb5":"code","32a4bf29":"code","5db3b68b":"code","2ce90ef3":"code","7d09c0e1":"code","d87f361d":"code","5506adb4":"code","cdcb65ab":"code","966e56c6":"code","4f0eafed":"code","a657e155":"code","434eb2e3":"code","9965a65c":"code","90695c1f":"code","19058081":"code","ef886312":"code","0e1c9a88":"code","79457d0c":"code","3b1c387d":"code","1d96cf56":"code","8b5d751f":"code","b8c804f3":"code","c21a94b1":"code","e0b5f4c1":"code","222d8c41":"code","f8bcc978":"code","2f7fc1cc":"markdown","026d162f":"markdown","e9215166":"markdown","5ea72259":"markdown","6a77e75f":"markdown","2cc58385":"markdown","3156a98d":"markdown","ee231ff7":"markdown","ee2446f0":"markdown","f120a218":"markdown","998f9d86":"markdown","8cbef6e2":"markdown","113ff4de":"markdown","7521827a":"markdown","2bc87814":"markdown","c7263340":"markdown","f281659c":"markdown","79c6a66a":"markdown","4f77bb56":"markdown","a8e6888c":"markdown","09187297":"markdown","89fc137f":"markdown","e4d4a7a4":"markdown","16817ef5":"markdown","4812c4b8":"markdown","ad86480d":"markdown","8860238a":"markdown","fa41cec6":"markdown"},"source":{"6fa0e68d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","2a441a5a":"\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n%matplotlib inline \nimport datetime\nfrom dateutil.parser import parse","53bcd739":"import os\nprint(os.listdir(\"..\/input\"))","9080f0d4":"data = pd.read_csv('\/kaggle\/input\/covidtracking\/all-states-history.csv', index_col=0, parse_dates=True)\ndata.shape","ab1f0273":"#create cummulative metrics, adjust positive cases to smaller number\ndata['posperThou'] = data['positive']\/1000\ndata['ratio'] = data['totalTestResults']\/data['positive']\ndata['diff'] = data['posperThou']- data['ratio']\n#create daily metrics, adjust daily new positive cases to smaller number\ndata['daily_new_positive_cases'] = data['positiveIncrease']\ndata['daily_new_total_test_results']=data['totalTestResultsIncrease']\ndata['daily_new_ratio'] = data['totalTestResultsIncrease']\/data['daily_new_positive_cases']\ndata['antibody_Percent_Positive']=100*(data['positiveTestsAntibody']\/data['totalTestsAntibody'])\nnlfactor = 50\ndata['daily_new_positive_cases_nl'] = data['daily_new_positive_cases']\/nlfactor\ndata['daily_new_diff'] =  data['daily_new_positive_cases_nl'] -  data['daily_new_ratio']\ndata['Covid 19 percent_Positive']= 100*(1\/data['ratio'])\n\n\ndata.head()\ndata ['date_col'] = data.index\nprint(data['date_col'])\ndata.head()","f0e66cb5":"sorted_data=data.sort_values(by='state', ascending=True)\nsorted_data.head()\n\n","32a4bf29":"sorted_data.shape","5db3b68b":"print(sorted_data.columns)","2ce90ef3":"\nstate_Set_1 = ['NY','AZ','CO','CA','DC'] \nstate_Set_2 = ['NY','AZ','GA','TX','WI']\nstate_Set_3 = ['NY','AZ','TN','CA','VI']\nstate_Set_4 = ['NY','AZ','GA','IN','DC']\nstate_Set_5 = ['NY','CA','CO','TX','WI']\nstate_Set_6 = ['NY','CA','AZ','TX','CO']\nstate_Set_7 = ['NY','CA','WA','TX','DC']\nstate_Set_8 = ['CT','FL','MN','LA','MO']\n\n#states_Studied = ['NY', 'FL','AZ','WA','DC','CA','DE','IA','IN','IL','MA','MI','NE','NV','OH','RI','TX','Wi','CO', 'AK','MI'] \nstates_Studied = state_Set_6\n\nfig= plt.figure(figsize =(16,8))\n#date_Sort= sorted_data.sort_values(by='date_col', ascending =True)\n#print(date_Sort.head(400))\n#first_date=date_Sort['date_col'].iloc[0]\nfirst_date=('2020-3-14')\nprint('THE BEGINNING DATE chosen is ', first_date)\nprint('SORTING THE DATA BY DATE BEFORE GROUPING BY STATE DOES NOT WORK TO GET UNIFORM STARTING or ENDING DATE')\ncutoff=first_date\nprint('starting cutoff is this date ', cutoff)\n\nlast_date=('2021-03-07')\nhicut=pd.to_datetime(last_date)\nprint('this is the last date', hicut)\n\n\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff ) & (df.state == state) & (df.date_col <= hicut)]\n    \n    \n    w = len(df_Select['date_col'])\n    print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    #print(df_Select_Ts.head())\n    last_date=df_Select_Ts['date_col'].iloc[-1]\n    test_date1=df_Select_Ts['date_col'].iloc[0]\n    test_date2=df_Select_Ts['date_col'].iloc[60]\n    test_date3=df_Select_Ts['date_col'].iloc[90]\n    print ('state is ', state, 'test date one ', test_date1, 'test date two' , test_date2, 'test date three ', test_date3)\n    print('the last date for the set is ', last_date, 'state is ', state)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    x = df_Select_Ts['date_col']\n    \n\n    y = df_Select_Ts['positive']\n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'Cumulative Positive Covid 19 Tests ')\n    plt.xlabel(' Testing Date')\n    plt.ylabel ('positive test results')\n  \n    \n   ","7d09c0e1":"fig= plt.figure(figsize =(16,8))\n\nlast_date=df_Select_Ts['date_col'].iloc[-200]\nprint('the last date for the set is ', last_date)\nhicut1=pd.to_datetime(last_date)\nprint('this is the last date', hicut1)\nprint('starting cutoff is this date ', cutoff)\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state) & (df.date_col < hicut1)]\n    \n    \n    w = len(df_Select['date_col'])\n    print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    #print(df_Select_Ts.head())\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    x = df_Select_Ts['date_col']\n    \n\n    y = df_Select_Ts['positive']\n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'Cumulative Positive Covid 19 Tests ')\n    plt.xlabel(' Testing Date')\n    plt.ylabel ('positive test results')\n  \n    \n   ","d87f361d":"\nfig= plt.figure(figsize =(16,8))\nfirst_date1=('2020-4-14')\ncutoff1 = pd.to_datetime(first_date1)\nprint('starting cutoff is this date ', cutoff1)\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff1) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    print(\"the number of dates is \", w, \"the state is  \", state)\n    \n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True) \n\n    \n    #z = len(df_Select_Ts['positiveTestsPeopleAntibody']\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n   \n    \n\n    y = df_Select_Ts['ratio']\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    x = df_Select_Ts['date_col']\n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'Testing Ratio')\n    plt.xlabel(' Testing Date')\n    plt.ylabel ('Testing Ratio')\n   \n   ","5506adb4":"fig= plt.figure(figsize =(16,8))\n\nprint('starting cutoff is this date ', cutoff1)\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff1) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    print(\"the number of dates is \", w, \"the state is  \", state)\n    \n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True) \n\n    \n    #z = len(df_Select_Ts['positiveTestsPeopleAntibody']\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n   \n    \n\n    y = df_Select_Ts['Covid 19 percent_Positive']\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    x = df_Select_Ts['date_col']\n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'Percent Positvity = (Positive PCR Tests\/Total Tests) * 100')\n    plt.xlabel(' Testing Date')\n    plt.ylabel ('Percent Positive PCR')\n   ","cdcb65ab":"fig= plt.figure(figsize =(16,8))\nprint('cutoff start date is ',cutoff)\n\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['positiveTestsAntibody'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    x = df_Select_Ts['date_col']\n    \n\n    y = df_Select_Ts['positiveTestsAntibody']\n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title(  'positiveTestsAntibody')\n    plt.xlabel(' Testing Date')\n    plt.ylabel ('positiveTestsAntibody')\n    \n   ","966e56c6":"fig= plt.figure(figsize =(16,8))\n\nprint('starting cutoff is this date ', cutoff)\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['totalTestsAntibody'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    x = df_Select_Ts['date_col']\n    \n\n    y = df_Select_Ts['totalTestsAntibody']\n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( ' totalTestsAntibody')\n    plt.xlabel(' Testing Date')\n    plt.ylabel ('totalTestsAntibody')\n    \n   ","4f0eafed":"fig= plt.figure(figsize =(16,8))\n\nprint('starting cutoff is this date ', cutoff)\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['totalTestsAntibody'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    x = df_Select_Ts['date_col']\n    \n\n    y = df_Select_Ts['antibody_Percent_Positive']\n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'Antibody Percent Positive')\n    plt.xlabel(' Testing Date')\n    plt.ylabel ('Percent Positive Antibody')\n    \n   ","a657e155":"print('the starting date is the cutoff for beginng date_col ',cutoff)\nfig= plt.figure(figsize =(12,8))\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    x = df_Select_Ts['date_col']\n    \n   \n    \n  \n    y = df_Select_Ts['diff']\n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'CUMULATIVE DIFFERENCE METRIC')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Difference')\n    ","434eb2e3":"print('the starting date is the cutoff for beginng date_col ',cutoff)\ngrf = 0\ngrf =  len (states_Studied)\ntot_grf = grf\n#print(grf)\nfig = plt.figure()\n\n\nfig.tight_layout(pad = 5.0)\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n  \n    #df_Select_Ts\n    #print('this is cumulative positives or positive ', df_Select_Ts['positive'])\n    #print('this cummulative total test results or totalTestResults ', df_Select_Ts['totalTestResults'])\n    #print('this is cumulativie ratio  or ratio ', df_Select_Ts['ratio'])\n    #print('this is cumulative difference metric or diff ', df_Select_Ts['diff'])\n    #print('this is daily_new_positive_cases ', df_Select_Ts['daily_new_positive_cases'])\n    #print('this is daily_new_positive_cases_nl ', df_Select_Ts['daily_new_positive_cases_nl'])\n    #print('this is daily_new_ratio ', df_Select_Ts['daily_new_ratio'])\n    #print('this is daily_new_diff ', df_Select_Ts['daily_new_diff'])\n    #print('this is new positives', df_Select_Ts['new_positive'])\n    #print('this is an experiment for what is iloc 90', df_Select_Ts.iloc[90])\n    #print('this is an experiment for what is iloc 91', df_Select_Ts.iloc[91])\n    #print('this is an experiment for what is iloc 92', df_Select_Ts.iloc[92])\n    #print('this is an experiment for what is iloc 93', df_Select_Ts.iloc[93])\n    \n    #print('this is an experiment for what is iloc 205', df_Select_Ts.iloc[205])\n    #print('this is an experiment for what is iloc -1', df_Select_Ts.iloc[-1])\n    print('this is an experiment for what is the last date in the date column iloc -1 for df_Select_Ts[date_col]'), print(df_Select_Ts['date_col'].iloc[-1])\n    x = df_Select_Ts['date_col']\n    fig = plt.figure(figsize=(24,24))\n                        \n    ax = 'ax' + str(grf) \n    #print(ax)\n    ax = fig.add_subplot(tot_grf,1,grf )\n   \n    \n    \n    y = df_Select_Ts['daily_new_ratio']\n    plt.plot(x,y, label = 'Daily New Testing Ratio')\n    plt.legend(loc= 'best')\n    plt.title(  state +' Metrics')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Relative Value')\n    \n    y = df_Select_Ts['daily_new_diff']\n    plt.plot(x,y, label = 'Daily New Difference Metric')\n    plt.legend(loc= 'best')\n    \n    grf = grf -1","9965a65c":"\nprint('the starting date is the cutoff for beginng date_col ',cutoff)\nprint('the last date is the hicut for the last date in the date_col', 'this will be called hicut in future cells')\ngrf = 0\ngrf =  len (states_Studied)\ntot_grf = grf\n#print(grf)\nfig = plt.figure()\n#fig, axes = plt.subplots(grf, 1, figsize = (8,16))\n\nfig.tight_layout(pad = 5.0)\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_diff'] = df_Select_Ts['daily_new_diff'].rolling(7, win_type ='triang').mean()\n    #df_Select_Ts\n    #print('this is cumulative positives or positive ', df_Select_Ts['positive'])\n    #print('this cummulative total test results or totalTestResults ', df_Select_Ts['totalTestResults'])\n    #print('this is cumulativie ratio  or ratio ', df_Select_Ts['ratio'])\n    #print('this is cumulative difference metric or diff ', df_Select_Ts['diff'])\n    #print('this is daily_new_positive_cases ', df_Select_Ts['daily_new_positive_cases'])\n    #print('this is daily_new_positive_cases_nl ', df_Select_Ts['daily_new_positive_cases_nl'])\n    #print('this is daily_new_ratio ', df_Select_Ts['daily_new_ratio'])\n    #print('this is daily_new_diff ', df_Select_Ts['daily_new_diff'])\n    #print('this is new positives', df_Select_Ts['new_positive'])\n    #print('this is an experiment for what is iloc 90', df_Select_Ts.iloc[90])\n    #print('this is an experiment for what is iloc 91', df_Select_Ts.iloc[91])\n    #print('this is an experiment for what is iloc 92', df_Select_Ts.iloc[92])\n    #print('this is an experiment for what is iloc 93', df_Select_Ts.iloc[93])\n    #print('this is an experiment for what is iloc 205', df_Select_Ts.iloc[205])\n    #print('this is an experiment for what is iloc 95', df_Select_Ts.iloc[206])\n  \n    fig = plt.figure(figsize=(24,30))\n    x = df_Select_Ts['date_col']                    \n    ax = 'ax' + str(grf) \n    #print(ax)\n    ax = fig.add_subplot(tot_grf,1,grf )\n   \n    \n    \n    y = df_Select_Ts['MA_daily_new_ratio']\n    plt.plot(x,y, label = 'Daily New Testing Ratio')\n    plt.legend(loc= 'best')\n    plt.title(  state +' Metrics 7 Day Moving Average')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Relative Value')\n    \n    y = df_Select_Ts['MA_daily_new_diff']\n    plt.plot(x,y, label = 'Daily New Difference Metric')\n    plt.legend(loc= 'best')\n    \n    grf = grf -1","90695c1f":"print('the starting date is the cutoff for beginng date_col ',cutoff)\ngrf = 0\ngrf =  len (states_Studied)\ntot_grf = grf\n#print(grf)\nfig = plt.figure()\n#fig, axes = plt.subplots(grf, 1, figsize = (8,16))\n\nfig.tight_layout(pad = 5.0)\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n   \n    \n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_diff'] = df_Select_Ts['daily_new_diff'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['diffmet\/testratio'] = df_Select_Ts['MA_daily_new_diff']\/df_Select_Ts['MA_daily_new_ratio']\n    #df_Select_Ts\n    #print('this is cumulative positives or positive ', df_Select_Ts['positive'])\n    #print('this cummulative total test results or totalTestResults ', df_Select_Ts['totalTestResults'])\n    #print('this is cumulativie ratio  or ratio ', df_Select_Ts['ratio'])\n    #print('this is cumulative difference metric or diff ', df_Select_Ts['diff'])\n    #print('this is daily_new_positive_cases ', df_Select_Ts['daily_new_positive_cases'])\n    #print('this is daily_new_positive_cases_nl ', df_Select_Ts['daily_new_positive_cases_nl'])\n    #print('this is daily_new_ratio ', df_Select_Ts['daily_new_ratio'])\n    #print('this is daily_new_diff ', df_Select_Ts['daily_new_diff'])\n    #print('this is new positives', df_Select_Ts['new_positive'])\n    #print('this is an experiment for what is iloc 90', df_Select_Ts.iloc[90])\n    #print('this is an experiment for what is iloc 91', df_Select_Ts.iloc[91])\n    #print('this is an experiment for what is iloc 92', df_Select_Ts.iloc[92])\n    #print('this is an experiment for what is iloc 93', df_Select_Ts.iloc[93])\n    #print('this is an experiment for what is iloc 205', df_Select_Ts.iloc[205])\n    #print('this is an experiment for what is iloc 95', df_Select_Ts.iloc[206])\n  \n    fig = plt.figure(figsize=(24,30))\n    x = df_Select_Ts['date_col']                    \n    ax = 'ax' + str(grf) \n    #print(ax)\n    ax = fig.add_subplot(tot_grf,1,grf )\n   \n    \n    \n    y = df_Select_Ts['diffmet\/testratio']\n    plt.plot(x,y, label = 'Daily Quotient')\n    plt.legend(loc= 'best')\n    plt.title(  state +' Quotient 7 Day Moving Average')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Relative Value')\n    \n    #y = df_Select_Ts['MA_daily_new_diff']\n    #plt.plot(x,y, label = 'Daily New Difference Metric')\n    #plt.legend(loc= 'best')\n    \n    grf = grf -1","19058081":"#assume correct number of tests is 40 times positive cases\n#sorted_data['needed'] = sorted_data['positiveIncrease']*40\n#shortfall is (predicted number of tests needed - total tests done)\n#sorted_data ['fraction_of_target'] =   sorted_data['totalTestResultsIncrease']\/sorted_data['needed']\n#percent of needed testing is (shortfall\/forty times positive) times 100\n#sorted_data['percent_of_target'] = 100*(sorted_data['fraction_of_target'])\n#sorted_data.head()\nprint('the starting date is the cutoff for beginng date_col ',cutoff)\nfig= plt.figure(figsize =(12,8))\nfor state in states_Studied:\n            \n    if state == 'CO':\n        state_Pop = 5.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'CA':\n        state_Pop = 39\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'NY':\n        state_Pop = 19\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'FL':\n        state_Pop = 21.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'WA':\n        state_Pop = 7.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'TX':\n        state_Pop = 29.4\n    \n    if state == 'DC':\n        state_Pop = 0.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'WI':\n        state_Pop = 6.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'AZ':\n        state_Pop = 7.4\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'VI':\n        state_Pop = 0.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'IN':\n        state_Pop = 6.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'MO':\n        state_Pop = 6.2\n    \n    if state == 'TN':\n        state_Pop = 6.9\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'LA':\n        state_Pop = 4.6\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    #w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_diff'] = df_Select_Ts['daily_new_diff'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['diffmet\/testratio'] = df_Select_Ts['MA_daily_new_diff']\/df_Select_Ts['MA_daily_new_ratio']\n \n        \n    df_Select_Ts['diffmet\/testratio\/pop']= df_Select_Ts['diffmet\/testratio']\/state_Pop\n\n    \n    print(state)\n    print(state_Pop)\n    #print(df_Select_Ts['diffmet\/testratio'])\n    x = df_Select_Ts['date_col']\n    #df = pd.DataFrame(sorted_data)\n    #df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    #w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    #df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    ##Troubleshooting\n    #df_Select_Ts.shape\n  \n    #print(df_Select_Ts.head())\n    #print(df_Select_Ts.isna().sum())\n    #df_T = pd.DataFrame(df_Select_Ts.iloc[:,-1])\n    #df_T['percent_of_target'] = df_T['percent_of_target'].fillna(0)\n    #df_T['MA'] = df_T['percent_of_target'].rolling(7, win_type ='triang').mean()\n    #print(df_T.head())\n    #df_T['percent_of_target'].fillna(df_T['percent_of_target'].mean())\n    #print(df_T.isna().sum())\n    #df_T['MA3']= df_T.iloc[:,1].rolling(window=3).mean()\n    #df_T['date_col2'] = df_T.index\n    #print(df_T.head(20))\n    \n    #z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    \n    #x = df_T['date_col2']\n    #x = df_Select_Ts['date_col']\n    #print(df_Select_Ts.head())\n    #df_Select_Ts.head()\n   \n    y = df_Select_Ts['diffmet\/testratio']\n  \n \n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'Quotient = diffmet\/testratio without normalization for state population')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Quotient')","ef886312":"#assume correct number of tests is 40 times positive cases\n#sorted_data['needed'] = sorted_data['positiveIncrease']*40\n#shortfall is (predicted number of tests needed - total tests done)\n#sorted_data ['fraction_of_target'] =   sorted_data['totalTestResultsIncrease']\/sorted_data['needed']\n#percent of needed testing is (shortfall\/forty times positive) times 100\n#sorted_data['percent_of_target'] = 100*(sorted_data['fraction_of_target'])\n#sorted_data.head()\nprint('the starting date is the cutoff for beginng date_col ',cutoff)\nfig= plt.figure(figsize =(12,8))\nfor state in states_Studied:\n            \n    if state == 'CO':\n        state_Pop = 5.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'CA':\n        state_Pop = 39\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'NY':\n        state_Pop = 19\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'FL':\n        state_Pop = 21.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'WA':\n        state_Pop = 7.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'TX':\n        state_Pop = 29.4\n    \n    if state == 'DC':\n        state_Pop = 0.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'WI':\n        state_Pop = 6.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'AZ':\n        state_Pop = 7.4\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'VI':\n        state_Pop = 0.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'IN':\n        state_Pop = 6.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'MO':\n        state_Pop = 6.2\n    \n    if state == 'TN':\n        state_Pop = 6.9\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'LA':\n        state_Pop = 4.6\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    #w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_diff'] = df_Select_Ts['daily_new_diff'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['diffmet\/testratio'] = df_Select_Ts['MA_daily_new_diff']\/df_Select_Ts['MA_daily_new_ratio']\n \n        \n    df_Select_Ts['diffmet\/testratio\/pop']= df_Select_Ts['diffmet\/testratio']\/state_Pop\n\n    \n    print(state)\n    print(state_Pop)\n    #print(df_Select_Ts['diffmet\/testratio'])\n    x = df_Select_Ts['date_col']\n    #df = pd.DataFrame(sorted_data)\n    #df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    #w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    #df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    ##Troubleshooting\n    #df_Select_Ts.shape\n  \n    #print(df_Select_Ts.head())\n    #print(df_Select_Ts.isna().sum())\n    #df_T = pd.DataFrame(df_Select_Ts.iloc[:,-1])\n    #df_T['percent_of_target'] = df_T['percent_of_target'].fillna(0)\n    #df_T['MA'] = df_T['percent_of_target'].rolling(7, win_type ='triang').mean()\n    #print(df_T.head())\n    #df_T['percent_of_target'].fillna(df_T['percent_of_target'].mean())\n    #print(df_T.isna().sum())\n    #df_T['MA3']= df_T.iloc[:,1].rolling(window=3).mean()\n    #df_T['date_col2'] = df_T.index\n    #print(df_T.head(20))\n    \n    #z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    \n    #x = df_T['date_col2']\n    #x = df_Select_Ts['date_col']\n    #print(df_Select_Ts.head())\n    #df_Select_Ts.head()\n   \n    y = df_Select_Ts['diffmet\/testratio\/pop']\n  \n \n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'diffmet\/testratio\/pop')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Quotient\/Pop')","0e1c9a88":"#assume correct number of tests is 40 times positive cases\n#sorted_data['needed'] = sorted_data['positiveIncrease']*40\n#shortfall is (predicted number of tests needed - total tests done)\n#sorted_data ['fraction_of_target'] =   sorted_data['totalTestResultsIncrease']\/sorted_data['needed']\n#percent of needed testing is (shortfall\/forty times positive) times 100\n#sorted_data['percent_of_target'] = 100*(sorted_data['fraction_of_target'])\n#sorted_data.head()\nprint('the starting date is the cutoff for beginng date_col ',cutoff)\nlast_date=df_Select_Ts['date_col'].iloc[-1]\nprint('the last date for the set is ', last_date)\nhicut=pd.to_datetime(last_date)\nprint(hicut)\n\nprint('the last date is the hicut for the last date in the date_col and has been assigned from last_date')\nfig= plt.figure(figsize =(12,8))\nfor state in states_Studied:\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state) & (df.date_col < hicut)]\n\n    \n    #w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_diff'] = df_Select_Ts['daily_new_diff'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['diffmet\/testratio'] = df_Select_Ts['MA_daily_new_diff']\/df_Select_Ts['MA_daily_new_ratio']\n    #print(state)\n    #print(df_Select_Ts['diffmet\/testratio'])\n    x = df_Select_Ts['date_col']\n    #df = pd.DataFrame(sorted_data)\n    \n\n    \n    #w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    #df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    ##Troubleshooting\n    #df_Select_Ts.shape\n  \n    #print(df_Select_Ts.head())\n    #print(df_Select_Ts.isna().sum())\n    #df_T = pd.DataFrame(df_Select_Ts.iloc[:,-1])\n    #df_T['percent_of_target'] = df_T['percent_of_target'].fillna(0)\n    #df_T['MA'] = df_T['percent_of_target'].rolling(7, win_type ='triang').mean()\n    #print(df_T.head())\n    #df_T['percent_of_target'].fillna(df_T['percent_of_target'].mean())\n    #print(df_T.isna().sum())\n    #df_T['MA3']= df_T.iloc[:,1].rolling(window=3).mean()\n    #df_T['date_col2'] = df_T.index\n    #print(df_T.head(20))\n    \n    #z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    \n    #x = df_T['date_col2']\n    #x = df_Select_Ts['date_col']\n    #print(df_Select_Ts.head())\n    #df_Select_Ts.head()\n   \n    y =  df_Select_Ts['MA_daily_new_ratio']\n  \n \n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'Daily New Test Ratio 7 Day Avg')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Daily New Test Ratio')","79457d0c":"#assume correct number of tests is 40 times positive cases\n#sorted_data['needed'] = sorted_data['positiveIncrease']*40\n#shortfall is (predicted number of tests needed - total tests done)\n#sorted_data ['fraction_of_target'] =   sorted_data['totalTestResultsIncrease']\/sorted_data['needed']\n#percent of needed testing is (shortfall\/forty times positive) times 100\n#sorted_data['percent_of_target'] = 100*(sorted_data['fraction_of_target'])\n#sorted_data.head()\nprint('the starting date is the cutoff for beginng date_col ',cutoff)\n#last_date=df_Select_Ts['date_col'].iloc[-1]\nprint('last date is ', last_date)\n#hicut=pd.to_datetime(last_date)\nprint('hicut is ', hicut)\nfig= plt.figure(figsize =(12,8))\nfor state in states_Studied:\n            \n    if state == 'CO':\n        state_Pop = 5.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'CA':\n        state_Pop = 6.5\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'NY':\n        state_Pop = 9.3\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \nfor state in states_Studied:\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    #w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_diff'] = df_Select_Ts['daily_new_diff'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['quotient'] = df_Select_Ts['MA_daily_new_diff']\/df_Select_Ts['MA_daily_new_ratio']\n    df_Select_Ts['inverse_test_ratio'] = 1\/df_Select_Ts['MA_daily_new_ratio']\n    df_Select_Ts['estimated_prevalence'] = df_Select_Ts['inverse_test_ratio']*state_Pop\n                                                                                      \n    #print('state ', df_Select_Ts['state'], 'state population ',state_Pop)\n    #print(df_Select_Ts['diffmet\/testratio'])\n    x = df_Select_Ts['date_col']\n    #df = pd.DataFrame(sorted_data)\n    #df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    #w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    #df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    ##Troubleshooting\n    #df_Select_Ts.shape\n  \n    #print(df_Select_Ts.head())\n    #print(df_Select_Ts.isna().sum())\n    #df_T = pd.DataFrame(df_Select_Ts.iloc[:,-1])\n    #df_T['percent_of_target'] = df_T['percent_of_target'].fillna(0)\n    #df_T['MA'] = df_T['percent_of_target'].rolling(7, win_type ='triang').mean()\n    #print(df_T.head())\n    #df_T['percent_of_target'].fillna(df_T['percent_of_target'].mean())\n    #print(df_T.isna().sum())\n    #df_T['MA3']= df_T.iloc[:,1].rolling(window=3).mean()\n    #df_T['date_col2'] = df_T.index\n    #print(df_T.head(20))\n    \n    #z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    \n    #x = df_T['date_col2']\n    #x = df_Select_Ts['date_col']\n    #print(df_Select_Ts.head())\n    #df_Select_Ts.head()\n   \n    y = df_Select_Ts['estimated_prevalence']\n  \n \n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'Estimated weekly prevalence = current decimal positivity factor x state population in Millions')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('estimated number of positive cases ')","3b1c387d":"print('the starting date is the cutoff for beginng date_col ',cutoff)\n#last_date=df_Select_Ts['date_col'].iloc[-1]\nprint('last date is ',last_date)\n#hicut=pd.to_datetime(last_date)\nprint('hicut is ',hicut)\n\n#assume correct number of tests is 40 times positive cases\nsorted_data['needed'] = sorted_data['positiveIncrease']*40\n#shortfall is (predicted number of tests needed - total tests done)\nsorted_data ['fraction_of_target'] =   sorted_data['totalTestResultsIncrease']\/sorted_data['needed']\n#percent of needed testing is (shortfall\/forty times positive) times 100\nsorted_data['percent_of_target'] = 100*(sorted_data['fraction_of_target'])\nsorted_data.head()\ngrf = 0\ngrf =  len (states_Studied)\ntot_grf = grf\n#print(grf)\n#fig, axes = plt.subplots(grf, 1, figsize = (12,24))\nfig.tight_layout(pad = 5.0)\n\nfor state in states_Studied:\n    \n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    x = df_Select_Ts['date_col']\n    \n    \n    \n    fig = plt.figure(figsize=(20,28))\n    \n\n    \n    \n    ax = 'ax' + str(grf) \n\n    #print(ax)\n    ax = fig.add_subplot(tot_grf,1,grf )\n   \n    \n    \n    y = df_Select_Ts['percent_of_target']\n    plt.plot(x,y, label = 'Testing as Percent of Target')\n    plt.legend(loc= 'best')\n    plt.title(  state +'  Estimated Percent of Target Testing')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Percent of Target Testing')\n    \n    #y = df_Select_Ts['diff']\n    \n    #plt.plot(x,y, label = 'Difference Metric')\n    #plt.legend(loc= 'best')\n    \n    grf = grf -1","1d96cf56":"print('the starting date is the cutoff for beginng date_col ',cutoff)\n#last_date=df_Select_Ts['date_col'].iloc[-1]\nprint('last date is ',last_date)\n#hicut=pd.to_datetime(last_date)\nprint('hicut is ',hicut)\n#import matplotlib.ticker as ticker\n#assume correct number of tests is 40 times positive cases\nsorted_data['needed'] = sorted_data['positiveIncrease']*40\n#shortfall is (predicted number of tests needed - total tests done)\nsorted_data ['fraction_of_target'] =   sorted_data['totalTestResultsIncrease']\/sorted_data['needed']\n#percent of needed testing is (shortfall\/forty times positive) times 100\nsorted_data['percent_of_target'] = 100*(sorted_data['fraction_of_target'])\nsorted_data.head()\ngrf = 0\ngrf =  len (states_Studied)\ntot_grf = grf\n#print(grf)\n#fig, axes = plt.subplots(grf, 1, figsize = (30,400))\nfig.tight_layout(pad = 5.0)\n\nfor state in states_Studied:\n    \n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    #Troubleshooting\n    #df_Select_Ts.shape\n  \n    #print(df_Select_Ts.head())\n    #print(df_Select_Ts.isna().sum())\n    df_T = pd.DataFrame(df_Select_Ts.iloc[:,-1])\n    df_T['percent_of_target'] = df_T['percent_of_target'].fillna(0)\n    df_T['MA'] = df_T['percent_of_target'].rolling(7, win_type ='triang').mean()\n    #print(df_T.head())\n    #df_T['percent_of_target'].fillna(df_T['percent_of_target'].mean())\n    #print(df_T.isna().sum())\n    #df_T['MA3']= df_T.iloc[:,1].rolling(window=3).mean()\n    df_T['date_col2'] = df_T.index\n    #print(df_T.head(20))\n    \n    #z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    \n    x = df_T['date_col2']\n    #x = df_Select_Ts['date_col']\n    #print(df_Select_Ts.head())\n    #df_Select_Ts.head()\n    \n    \n    \n    fig = plt.figure(figsize=(16,28))\n    \n\n    \n    \n    ax = 'ax' + str(grf) \n\n    #print(ax)\n    ax = fig.add_subplot(tot_grf,1,grf )\n   \n    y = df_T['MA']\n    \n    #y = df_Select_Ts['percent_of_target']\n    plt.plot(x,y, label = 'Testing as Percent of Target')\n    plt.legend(loc= 'best')\n    plt.title(  state +'  Estimated Percent of Target Testing 7 Day Moving Average')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Percent of Target Testing')\n    \n    #y = df_Select_Ts['diff']\n    \n    #plt.plot(x,y, label = 'Difference Metric')\n    #plt.legend(loc= 'best')\n    \n    grf = grf -1","8b5d751f":"print('the starting date is the cutoff for beginng date_col ',cutoff)\n#last_date=df_Select_Ts['date_col'].iloc[-1]\nprint('last date is',last_date)\n#hicut=pd.to_datetime(last_date)\nprint('hicut is ',hicut)\n#assume correct number of tests is 40 times positive cases\nsorted_data['needed'] = sorted_data['positiveIncrease']*40\n#shortfall is (predicted number of tests needed - total tests done)\nsorted_data ['fraction_of_target'] =   sorted_data['totalTestResultsIncrease']\/sorted_data['needed']\n#percent of needed testing is (shortfall\/forty times positive) times 100\nsorted_data['percent_of_target'] = 100*(sorted_data['fraction_of_target'])\nsorted_data.head()\nfig= plt.figure(figsize =(12,8))\nfor state in states_Studied:\n    \n    df = pd.DataFrame(sorted_data)\n   \n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state) & (df.date_col < hicut)]\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    #Troubleshooting\n    #df_Select_Ts.shape\n  \n    #print(df_Select_Ts.head())\n    #print(df_Select_Ts.isna().sum())\n    df_T = pd.DataFrame(df_Select_Ts.iloc[:,-1])\n    df_T['percent_of_target'] = df_T['percent_of_target'].fillna(0)\n    df_T['MA'] = df_T['percent_of_target'].rolling(7, win_type ='triang').mean()\n    #print(df_T.head())\n    #df_T['percent_of_target'].fillna(df_T['percent_of_target'].mean())\n    #print(df_T.isna().sum())\n    #df_T['MA3']= df_T.iloc[:,1].rolling(window=3).mean()\n    df_T['date_col2'] = df_T.index\n    #print(df_T.head(20))\n    \n    #z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    \n    x = df_T['date_col2']\n    #x = df_Select_Ts['date_col']\n    #print(df_Select_Ts.head())\n    #df_Select_Ts.head()\n   \n    y = df_T['MA']\n  \n \n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title( 'Percent Testing Target for several US States')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Percent of Testing Target')","b8c804f3":"print('the starting date is the cutoff for beginng date_col ',cutoff)\n#last_date=df_Select_Ts['date_col'].iloc[-1]\nprint('last date is ', last_date)\n#hicut=pd.to_datetime(last_date)\nprint('hicut is ', hicut)\ngrf = 0\ngrf =  len (states_Studied)\ntot_grf = grf\n#print(grf)\nfig = plt.figure()\n#fig, axes = plt.subplots(grf, 1, figsize = (8,16))\n\nfig.tight_layout(pad = 5.0)\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_positive_cases_nl'] = df_Select_Ts['daily_new_positive_cases_nl'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['pos_nl_cases\/testratio'] = df_Select_Ts['MA_daily_new_positive_cases_nl']\/df_Select_Ts['MA_daily_new_ratio']\n    #df_Select_Ts\n    #print('this is cumulative positives or positive ', df_Select_Ts['positive'])\n    #print('this cummulative total test results or totalTestResults ', df_Select_Ts['totalTestResults'])\n    #print('this is cumulativie ratio  or ratio ', df_Select_Ts['ratio'])\n    #print('this is cumulative difference metric or diff ', df_Select_Ts['diff'])\n    #print('this is daily_new_positive_cases ', df_Select_Ts['daily_new_positive_cases'])\n    #print('this is daily_new_positive_cases_nl ', df_Select_Ts['daily_new_positive_cases_nl'])\n    #print('this is daily_new_ratio ', df_Select_Ts['daily_new_ratio'])\n    #print('this is daily_new_diff ', df_Select_Ts['daily_new_diff'])\n    #print('this is new positives', df_Select_Ts['new_positive'])\n    #print('this is an experiment for what is iloc 90', df_Select_Ts.iloc[90])\n    #print('this is an experiment for what is iloc 91', df_Select_Ts.iloc[91])\n    #print('this is an experiment for what is iloc 92', df_Select_Ts.iloc[92])\n    #print('this is an experiment for what is iloc 93', df_Select_Ts.iloc[93])\n    #print('this is an experiment for what is iloc 205', df_Select_Ts.iloc[205])\n    #print('this is an experiment for what is iloc 95', df_Select_Ts.iloc[206])\n  \n    fig = plt.figure(figsize=(24,30))\n    x = df_Select_Ts['date_col']                    \n    ax = 'ax' + str(grf) \n    #print(ax)\n    ax = fig.add_subplot(tot_grf,1,grf )\n   \n    \n    \n    y = df_Select_Ts['pos_nl_cases\/testratio']\n    plt.plot(x,y, label = 'Daily Q2 defined (pos normal cases)\/ TR')\n    plt.legend(loc= 'best')\n    plt.title(  state +' Q2 7 Day Moving Average')\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Relative Value')\n    \n    #y = df_Select_Ts['MA_daily_new_diff']\n    #plt.plot(x,y, label = 'Daily New Difference Metric')\n    #plt.legend(loc= 'best')\n    \n    grf = grf -1","c21a94b1":"print('the starting date is the cutoff for beginng date_col ',cutoff)\n#last_date=df_Select_Ts['date_col'].iloc[-1]\nprint('last date is ', last_date)\n#hicut=pd.to_datetime(last_date)\nprint('hicut is ', hicut)\n\nfig= plt.figure(figsize =(12,8))\n\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_positive_cases_nl'] = df_Select_Ts['daily_new_positive_cases_nl'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['pos_nl_cases\/testratio'] = df_Select_Ts['MA_daily_new_positive_cases_nl']\/df_Select_Ts['MA_daily_new_ratio']\n    #df_Select_Ts\n    #print('this is cumulative positives or positive ', df_Select_Ts['positive'])\n    #print('this cummulative total test results or totalTestResults ', df_Select_Ts['totalTestResults'])\n    #print('this is cumulativie ratio  or ratio ', df_Select_Ts['ratio'])\n    #print('this is cumulative difference metric or diff ', df_Select_Ts['diff'])\n    #print('this is daily_new_positive_cases ', df_Select_Ts['daily_new_positive_cases'])\n    #print('this is daily_new_positive_cases_nl ', df_Select_Ts['daily_new_positive_cases_nl'])\n    #print('this is daily_new_ratio ', df_Select_Ts['daily_new_ratio'])\n    #print('this is daily_new_diff ', df_Select_Ts['daily_new_diff'])\n    #print('this is new positives', df_Select_Ts['new_positive'])\n    #print('this is an experiment for what is iloc 90', df_Select_Ts.iloc[90])\n    #print('this is an experiment for what is iloc 91', df_Select_Ts.iloc[91])\n    #print('this is an experiment for what is iloc 92', df_Select_Ts.iloc[92])\n    #print('this is an experiment for what is iloc 93', df_Select_Ts.iloc[93])\n    #print('this is an experiment for what is iloc 205', df_Select_Ts.iloc[205])\n    #print('this is an experiment for what is iloc 95', df_Select_Ts.iloc[206])\n  \n \n    x = df_Select_Ts['date_col']                    \n   \n  \n    y = df_Select_Ts['pos_nl_cases\/testratio']\n \n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title('Daily  (pos normal cases)\/ TR' )\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Relative Value')","e0b5f4c1":"print('the starting date is the cutoff for beginng date_col ',cutoff)\n#last_date=df_Select_Ts['date_col'].iloc[-1]\nprint('last date is ', last_date)\n#hicut=pd.to_datetime(last_date)\nprint('hicut is ', hicut)\n\nfig= plt.figure(figsize =(12,8))\nfor state in states_Studied:\n            \n    if state == 'CO':\n        state_Pop = 5.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'CA':\n        state_Pop = 39\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'NY':\n        state_Pop = 19\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'FL':\n        state_Pop = 21.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'WA':\n        state_Pop = 7.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'TX':\n        state_Pop = 29.4\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'DC':\n        state_Pop = 0.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'WI':\n        state_Pop = 6.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'AZ':\n        state_Pop = 7.4\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'VI':\n        state_Pop = 0.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'IN':\n        state_Pop = 6.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'MO':\n        state_Pop = 6.2\n    \n    if state == 'TN':\n        state_Pop = 6.9\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'LA':\n        state_Pop = 4.6\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_diff'] = df_Select_Ts['daily_new_diff'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_positive_cases_nl'] = df_Select_Ts['daily_new_positive_cases_nl'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['pos_nl_cases\/testratio'] = df_Select_Ts['MA_daily_new_positive_cases_nl']\/df_Select_Ts['MA_daily_new_ratio']\n    df_Select_Ts['pos_nl_cases\/testratio\/pop'] = df_Select_Ts['pos_nl_cases\/testratio']\/state_Pop\n    df_Select_Ts['Quotient'] = df_Select_Ts['MA_daily_new_diff']\/ df_Select_Ts['MA_daily_new_ratio']\n    df_Select_Ts['Quotient\/pop'] = df_Select_Ts['Quotient']\/state_Pop\n    #df_Select_Ts\n    #print('this is cumulative positives or positive ', df_Select_Ts['positive'])\n    #print('this cummulative total test results or totalTestResults ', df_Select_Ts['totalTestResults'])\n    #print('this is cumulativie ratio  or ratio ', df_Select_Ts['ratio'])\n    #print('this is cumulative difference metric or diff ', df_Select_Ts['diff'])\n    #print('this is daily_new_positive_cases ', df_Select_Ts['daily_new_positive_cases'])\n    #print('this is daily_new_positive_cases_nl ', df_Select_Ts['daily_new_positive_cases_nl'])\n    #print('this is daily_new_ratio ', df_Select_Ts['daily_new_ratio'])\n    #print('this is daily_new_diff ', df_Select_Ts['daily_new_diff'])\n    #print('this is new positives', df_Select_Ts['new_positive'])\n    #print('this is an experiment for what is iloc 90', df_Select_Ts.iloc[90])\n    #print('this is an experiment for what is iloc 91', df_Select_Ts.iloc[91])\n    #print('this is an experiment for what is iloc 92', df_Select_Ts.iloc[92])\n    #print('this is an experiment for what is iloc 93', df_Select_Ts.iloc[93])\n    #print('this is an experiment for what is iloc 205', df_Select_Ts.iloc[205])\n    #print('this is an experiment for what is iloc 95', df_Select_Ts.iloc[206])\n  \n \n    x = df_Select_Ts['date_col']                    \n   \n  \n    y = df_Select_Ts['pos_nl_cases\/testratio\/pop']\n \n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title('Daily ((pos normal cases)\/ TR)\/population' )\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Relative Value')","222d8c41":"print('the starting date is the cutoff for beginng date_col ',cutoff)\n#last_date=df_Select_Ts['date_col'].iloc[-1]\nprint('last date is ', last_date)\n#hicut=pd.to_datetime(last_date)\nprint('hicut is ', hicut)\n\nfig= plt.figure(figsize =(12,8))\nfor state in states_Studied:\n            \n    if state == 'CO':\n        state_Pop = 5.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'CA':\n        state_Pop = 39\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'NY':\n        state_Pop = 19\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'FL':\n        state_Pop = 21.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'WA':\n        state_Pop = 7.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'TX':\n        state_Pop = 29.4\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'DC':\n        state_Pop = 0.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'WI':\n        state_Pop = 6.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'AZ':\n        state_Pop = 7.4\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'VI':\n        state_Pop = 0.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'IN':\n        state_Pop = 6.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'MO':\n        state_Pop = 6.2\n    \n    if state == 'TN':\n        state_Pop = 6.9\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'LA':\n        state_Pop = 4.6\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_diff'] = df_Select_Ts['daily_new_diff'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_positive_cases_nl'] = df_Select_Ts['daily_new_positive_cases_nl'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['pos_nl_cases\/testratio'] = df_Select_Ts['MA_daily_new_positive_cases_nl']\/df_Select_Ts['MA_daily_new_ratio']\n    df_Select_Ts['pos_nl_cases\/testratio\/pop'] = df_Select_Ts['pos_nl_cases\/testratio']\/state_Pop\n    df_Select_Ts['Quotient'] = df_Select_Ts['MA_daily_new_diff']\/ df_Select_Ts['MA_daily_new_ratio']\n    df_Select_Ts['Quotient\/pop'] = df_Select_Ts['Quotient']\/state_Pop\n    #df_Select_Ts\n    #print('this is cumulative positives or positive ', df_Select_Ts['positive'])\n    #print('this cummulative total test results or totalTestResults ', df_Select_Ts['totalTestResults'])\n    #print('this is cumulativie ratio  or ratio ', df_Select_Ts['ratio'])\n    #print('this is cumulative difference metric or diff ', df_Select_Ts['diff'])\n    #print('this is daily_new_positive_cases ', df_Select_Ts['daily_new_positive_cases'])\n    #print('this is daily_new_positive_cases_nl ', df_Select_Ts['daily_new_positive_cases_nl'])\n    #print('this is daily_new_ratio ', df_Select_Ts['daily_new_ratio'])\n    #print('this is daily_new_diff ', df_Select_Ts['daily_new_diff'])\n    #print('this is new positives', df_Select_Ts['new_positive'])\n    #print('this is an experiment for what is iloc 90', df_Select_Ts.iloc[90])\n    #print('this is an experiment for what is iloc 91', df_Select_Ts.iloc[91])\n    #print('this is an experiment for what is iloc 92', df_Select_Ts.iloc[92])\n    #print('this is an experiment for what is iloc 93', df_Select_Ts.iloc[93])\n    #print('this is an experiment for what is iloc 205', df_Select_Ts.iloc[205])\n    #print('this is an experiment for what is iloc 95', df_Select_Ts.iloc[206])\n  \n \n    x = df_Select_Ts['date_col']                    \n   \n  \n    y = df_Select_Ts['Quotient']\n \n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title('Daily Quotient =  ((diff metric)\/ TR)' )\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Relative Quotient Value')","f8bcc978":"print('the starting date is the cutoff for beginng date_col ',cutoff)\n#last_date=df_Select_Ts['date_col'].iloc[-1]\nprint('last date is ', last_date)\n#hicut=pd.to_datetime(last_date)\nprint('hicut is ', hicut)\n\nfig= plt.figure(figsize =(12,8))\nfor state in states_Studied:\n            \n    if state == 'CO':\n        state_Pop = 5.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'CA':\n        state_Pop = 39\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'NY':\n        state_Pop = 19\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'FL':\n        state_Pop = 21.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'WA':\n        state_Pop = 7.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'TX':\n        state_Pop = 29.4\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'DC':\n        state_Pop = 0.7\n        print(\" state is \", state, \"pop is \", state_Pop)\n    \n    if state == 'WI':\n        state_Pop = 6.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'AZ':\n        state_Pop = 7.4\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'VI':\n        state_Pop = 0.1\n        print(\" state is \", state, \"pop is \", state_Pop)\n            \n    if state == 'IN':\n        state_Pop = 6.8\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'MO':\n        state_Pop = 6.2\n    \n    if state == 'TN':\n        state_Pop = 6.9\n        print(\" state is \", state, \"pop is \", state_Pop)\n        \n    if state == 'LA':\n        state_Pop = 4.6\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\nfor state in states_Studied:\n    df = pd.DataFrame(sorted_data)\n    df_Select = df[(df.date_col  >= cutoff) & (df.state == state)]\n\n    \n    w = len(df_Select['date_col'])\n    #print(\"the number of dates is \", w, \"the state is  \", state)\n    \n  \n\n    df_Select_Ts = df_Select.sort_values(by='date_col', ascending=True)\n    \n    z = len(df_Select_Ts['date_col'])\n    #print(\"the number of dates is \", z, \"the state is  \", state)\n    \n    df_Select_Ts['daily_new_positive_cases'] = df_Select_Ts['positiveIncrease']\n    df_Select_Ts['daily_new_total_test_results'] = df_Select_Ts['totalTestResultsIncrease']\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_total_test_results']\/df_Select_Ts['daily_new_positive_cases']\n    nlfactor=50 \n    df_Select_Ts['daily_new_positive_cases_nl']= df_Select_Ts['daily_new_positive_cases']\/nlfactor\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_positive_cases_nl'] - df_Select_Ts['daily_new_ratio']\n    df_Select_Ts['daily_new_diff'] = df_Select_Ts['daily_new_diff'].fillna(0)\n    df_Select_Ts['daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].fillna(0)\n    df_Select_Ts['MA_daily_new_ratio'] = df_Select_Ts['daily_new_ratio'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_diff'] = df_Select_Ts['daily_new_diff'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['MA_daily_new_positive_cases_nl'] = df_Select_Ts['daily_new_positive_cases_nl'].rolling(7, win_type ='triang').mean()\n    df_Select_Ts['pos_nl_cases\/testratio'] = df_Select_Ts['MA_daily_new_positive_cases_nl']\/df_Select_Ts['MA_daily_new_ratio']\n    df_Select_Ts['pos_nl_cases\/testratio\/pop'] = df_Select_Ts['pos_nl_cases\/testratio']\/state_Pop\n    df_Select_Ts['Quotient'] = df_Select_Ts['MA_daily_new_diff']\/ df_Select_Ts['MA_daily_new_ratio']\n    df_Select_Ts['Quotient\/pop'] = df_Select_Ts['Quotient']\/state_Pop\n    #df_Select_Ts\n    #print('this is cumulative positives or positive ', df_Select_Ts['positive'])\n    #print('this cummulative total test results or totalTestResults ', df_Select_Ts['totalTestResults'])\n    #print('this is cumulativie ratio  or ratio ', df_Select_Ts['ratio'])\n    #print('this is cumulative difference metric or diff ', df_Select_Ts['diff'])\n    #print('this is daily_new_positive_cases ', df_Select_Ts['daily_new_positive_cases'])\n    #print('this is daily_new_positive_cases_nl ', df_Select_Ts['daily_new_positive_cases_nl'])\n    #print('this is daily_new_ratio ', df_Select_Ts['daily_new_ratio'])\n    #print('this is daily_new_diff ', df_Select_Ts['daily_new_diff'])\n    #print('this is new positives', df_Select_Ts['new_positive'])\n    #print('this is an experiment for what is iloc 90', df_Select_Ts.iloc[90])\n    #print('this is an experiment for what is iloc 91', df_Select_Ts.iloc[91])\n    #print('this is an experiment for what is iloc 92', df_Select_Ts.iloc[92])\n    #print('this is an experiment for what is iloc 93', df_Select_Ts.iloc[93])\n    #print('this is an experiment for what is iloc 205', df_Select_Ts.iloc[205])\n    #print('this is an experiment for what is iloc 95', df_Select_Ts.iloc[206])\n  \n \n    x = df_Select_Ts['date_col']                    \n   \n  \n    y = df_Select_Ts['Quotient\/pop']\n \n    plt.plot(x,y, label = state)\n    plt.legend(loc= 'best')\n    plt.title('Daily Quotient\/population' )\n    plt.xlabel('Days of Testing')\n    plt.ylabel ('Relative Quotent Value')","2f7fc1cc":"Consider (daily new cases\/50)\/TR as the definition for Q2.  The plots are not different from Quotient = DM\/TR.\nWith high number of positive cases and low TR, the TR factor is negligible in the calculation of the DM.  TR is small relative to positive daily cases.  If positive cases became very small, then the Q2 metric might be a better measure. For example, WA state goes to between 0 and 1 during the midsummer for Q2 compared to 0 and -1 for Quotient.","026d162f":"The data is sourced from this website:\n\nhttps:\/\/covidtracking.com\/ \n\nhttps:\/\/covidtracking.com\/data\/download\n\nUS Data\n\nDownload all available US data: \/api\/v1\/us\/daily.csv \n\ndata file downloadded  daily.csv\n\nThe COVID Tracking Project is a volunteer organization launched from The Atlantic and dedicated to collecting and publishing the data required to understand the COVID-19 outbreak in the United States. Every day, we collect data on COVID-19 testing and patient outcomes from all 50 states, 5 territories, and the District of Columbia. Our dataset is currently in use by national and local news organizations across the US and by research projects and agencies worldwide. As of mid-April, our data API (which allows sites and apps to import our dataset automatically) receives about one million requests per day.","e9215166":"**READ THE DATA**\n\nMAKE SURE THE PATH TO THE FILE IS CORRECT '\/kaggle\/input\/folder\/file_in_folder.csv'","5ea72259":"**PLOT THE RELATIONSHIP BETWEEN TESTING RATIO AND DIFFERENCE METRIC FOR EACH STATE OVER TIME USING DAILY VALUES**\n**GRAPHING THESE TWO CURVES TOGETHER SHOWS THE DYNAMIC RELATIONSHIP BETWEEN PREVALENCE OF DISEASE AND LEVEL OF TESTING IN A REGION**","6a77e75f":"**The quotient metric is the ratio between the difference metric (DM)and the testing ratio (TR).**\n**Quotient = (DM)\/(TR) = (positive cases\/50)-(TR))\/(TR)**\n**When daily new cases = 50, DM = 1 - (TR), since the lower limit of TR is 1, DM is less < or = Zero when the number of daily new cases is 50.**\n**The Quotient denominator will always be > or = to 1 (because the TR cannot be less than one).**\n**Therefore, when testing is adequate, TR = 40\/1 and new cases are less than or equal to 50 daily.  Then,\nfor example, daily new cases =50, TR = 40 and Quotient = DM\/TR = (1-40)\/40 = -39\/40 = -.975**\n**When, daily new cases = 5000 and TR = 3, DM = (5000\/50 - TR) = (100 - 3) = 97 and Quotient = DM\/TR = 97\/3 = 32.3**\n**Thus, a Quotient of 32.3 shows inadequate testing relative to prevalence of disease in a region, and a\nQuotient of -.975 shows adequate testing relative to the prevalence of disease in a region** **Plotting the Quotient for different regions will show in a single line, the appropriateness of testing over time for comparable regions.**\n**IF THE DAILY NEW CASES GOES TO ZERO, THEN THE DM BECOMES (0\/50 - TR)AND THE QUOTIENT BECOMES -TR\/TR = -1, SO THE LOWER LIMIT OF THE QUOTIENT IS -1.**THE UPPER LIMIT OF THE QUOTIENT IS DRIVEN BY THE NUMBER OF DAILY NEW CASES.**\n    ","2cc58385":"Calculating a weekly moving average based on daily new cases will smooth out the curves will still demonstrating the dynamically changing achievement of ideal target testing.  The code below is used to calculate and plot weekly moving average values for percent of ideal target\ntesting achieved.","3156a98d":"The Cumulative Difference Metric (DM) is the difference between an arbitrary standard and the Testing Ratio.\n\nDifference Metric = (Positives\/1000) - Testing Ratio)\n\nThe greater the DM value, the more the spread of the epidemic is outpacing testing in that region.","ee231ff7":"Covid 19 Testing and Disease Prevalence\n\nNotebook \u201cCovid Daily US State Testing Shortfall\u201d\nThis notebook charts the relationship between level of testing and disease prevalence in (any) 5 states. \n\nSet one displays New York, Arizona, Colorado,California, Wisconsin. \n(state_Set_1 = ['NY', 'AZ', 'CO','CA', 'WI'])\n\nYou can choose different sets or make up your own set.\nThe charts look best with 5 states.  \n\nThe plots show the:\n\ntesting ratio = (tests done\/ positive tests)\n\ndifference metric = DM = disease prevalence \u2013 testing ratio\n\n\t\t\t= cumulative positive cases\/1000 \u2013 testing ratio\n            \nor \t\t    = daily new positive cases\/50 \u2013 testing ratio\n\npercent testing target   = the extent to which a region has achieved an arbitrary ideal testing ratio gold                                                                standard of 40\/1 as exemplified by South Korea.\n\nResults show three patterns achieved by October 25, 2020:\n\n\t**New York and Washington DC**\n\t\tHigh testing ratios, 200% of ideal testing target, control of the epidemic\n        It is ironic that Washington DC has a performed aggressive testing despite the administration\u2019s rhetoric that testing is not important.  \n        DC has a testing ratio similar to New York at about 200% ideal testing target in October.\n        \n\t**Texas and Wisconsin**\n         Low testing ratios, 50% or less of ideal target testing, rising Difference Metric \n         indicating a surge in new infections overcoming the ability of the testing (ratio), \n         (combined with public health measures) to facilitate control of the surge in coronavirus cases. \n    \n\t**California and Colorado**\n         Intermediate testing ratios, 40-60% or less of ideal target testing, these states are at inflection\n         points where the Difference Metric will cross the testing ratio curve indicating that disease prevalence \n         is about to overcome testing public health measures and signaling the impending loss of control of the epidemic\n","ee2446f0":"**Testing Percent Positivity shows an inverse relation to Test Ratio.  Early in the pandemic NY has very high percent positive rate on PCR Covid testing.  After mitigation and lockdown, NY has a much lower percent positivity compared to other states.**","f120a218":"At the beginning of the pandemic, low positive numbers of cases resulted in high testing ratios. As positive test results increased the ratios tests_done\/positive_tests decreased. NY (blue) had very low testing ratio last year but increased this year compared to the other states.  In March 2020, Texas and Arizona did over 100 tests to find one case but NY needed only to do one or two tests to find a positive result.  In 2021 NY required 10-20 tests to find one positive, a higher testing ratio than the other states.  This is the result of increased testing and decreased incidence of infection.","998f9d86":"**CREATE DATA SUBSETS SORTED BY STATE AND PLOT THE NUMBER OF CUMMULATIVE POSITIVE CASES OVER TIME FOR EACH STATE**\n\nCreat state_Set_x  where each state_Set is a list of 5 states that will be assigned to the variable \"states_Studied\"\nThe graphing output works best with about 5 or 6 states to compare without becoming to cluttered.  Once the variable\nstates_Studied is assigned, that list will be used throughout the rest of the Jupyter notebook cells.  New York and Washington DC are useful curves to include as they frame early-high and late-low extremes of coronavirus infection.\nCalifornia, Texas and Florida have numbers of infection in 2021 due in part to their large populations and state policies on mitigation.\n\nCreate a for loop that will take a list of states to process.\n\nFrom the database sorted by state,\ncreate a subset dataframe for each state that has only data on that one state.\n\nThen sort the subset dataframe by date in ascending order.  Assign variable \"cutoff\" the date March 10, 2020 so all curves start with that start date.  Do this with the .iloc method using the index that corresponds to March 10, 2020.\n\nPlot the cumulative positive test case values for each processed state on a single graph for comparison beginning with March 10, 2020.\n\n","8cbef6e2":"**CREATE PARAMETERS**\n#create cummulative metrics, adjust positive cases to smaller number\ndata['posperThou'] = data['positive']\/1000\ndata['ratio'] = data['totalTestResults']\/data['positive']\ndata['diff'] = data['posperThou']- data['ratio']\n\n#create daily metrics, adjust daily new positive cases to smaller number\ndata['daily_new_positive_cases'] = data['positiveIncrease']\ndata['daily_new_total_test_results']=data['totalTestResultsIncrease']\ndata['daily_new_ratio'] = data['totalTestResultsIncrease']\/data['daily_new_positive_cases']\ndata['antibody_Percent_Positive']=100*(data['positiveTestsAntibody']\/data['totalTestsAntibody'])\nnlfactor = 50\ndata['daily_new_positive_cases_nl'] = data['daily_new_positive_cases']\/nlfactor\ndata['daily_new_diff'] =  data['daily_new_positive_cases_nl'] -  data['daily_new_ratio']\ndata['Covid 19 percent_Positive']= 100*(1\/data['ratio'])\n","113ff4de":"\nThese CSV files contain daily data on the COVID-19 pandemic for the US and individual states. \nIf you are writing an application that uses our data, consider our API instead.\n\n**State Data** This is the data for all states used for the Testing Shortfall Jupyter Notebook.\n\nDownload ***data for all states***:\n\n","7521827a":"**ALL OF THE FOLLOWING GRAPHS REPRESENT CALCULATIONS BASED ON DAILY NEW POSITIVE RESULTS AND DAILY NEW TOTAL TESTS DONE**\n\n**THIS INCREASES THE VARIABILITY AND CAUSES THE GRAPHS TO BE LESS SMOOTH**","2bc87814":"**THE CHARTS ABOVE SHOW A SEVEN DAY MOVING AVERAGE OF DAILY NEW TESTING RATIO PLOTTED AGAINST DAILY NEW DIFFERENCE METRIC**\n**A positive testing ratio around 40:1 (similar to South Korea) and a negative difference metric indicates adequate testing**\n**The lower limit for the testing ratio is 1.  A testing ratio between 1-5 (100% - 20% test positivity) indicates either inadequate testing or a high prevalence of disease, or both.   If the difference metric is near 100, this means positive cases\/50 = 100, or daily new cases = 5000, and this combination represents surging epidemic (combined with inadequate testing if the testing ratio less than 5\/1.  The DM includes the normalization factor 50, used to reduce the scale of the daily new cases.  When daily new cases = 50, the difference metric becomes (1 - the testing ratio), so the difference metric will be less than or equal to zero.  The more testing that is done in this situation, the greater the difference between the testing ratio and the difference metric.  A high testing ratio near 40\/1 (less than 3% positivity) and a negative difference metric indicates adequate testing relative to the prevalence of disease.**","c7263340":"Create parameters:\nTesting Ratio defined as (Total Tests Done)\/Positive Tests with column label ['ratio']\n\nTesting Difference defined as ((Positive Tests\/1000) - Testing Ratio) with column label ['diff']\n\nTesting Date copied from the index value date with column label ['date_col']\n\n","f281659c":"**Few states have data on the prevalence of antibody status of the population. This makes it difficult to estimate the level of herd immunity that exists from symptomatic and asymptomatic individuals who have contracted the Covid 19 infection and then developed neutralizing antibodies.**","79c6a66a":"    **In the early months of the pandemic, testing in NY was grossly inadequate as evidenced by the high Quotient value of 80, but by the fall the Quotient is much lower, near zero, showing more adequate testing and lower prevalence of disease.  In contrast, states such as CA, CO, TX and WI, the testing is adequate early in the year but inadequate in the Fall as evidenced by the rise in the Quotient from near zero early in the year to the (10-120) range in the Fall.****A high positive Quotient value represents high positive cases overwhelming the level of testing.  A near zero Quotient value represents testing overwhelming positive cases.**","4f77bb56":"**PLOT THE CUMULATIVE DIFFERENCE METRIC FOR EACH STATE OVER TIME**","a8e6888c":"The estimated ideal number of  tests required will vary over time depending on the number of positive cases.\nAs positive cases increase, disease prevalence increases and the number of total tests required will increase.  As positive cases decline, diease prevalence declines, and then number of total tests required will decline.  Results based on Daily NEW Cases instead of Cummulative Cases will more accurately reflect the dynamically changing nature of the epidemic.  The graphs will show the percent of target testing achieved over the course of the pandemic.","09187297":"Plotting the dynamic relationship between Daily New Testing Ratio and the Daily New Difference Metric (DM) over time may show the moment spread of the epidemic overwhelms testing.  For NY this begins in mid March 2020 followed by improved performance in the Fall and a second surge overwhelming testing around New Years 2021.  \n\nThe more the Difference Metric (DM) exceeds the Testing Ratio, the more inadequate the testing in that region relative to the advance of the epidemic.  If aggressive testing, contact tracing and quarantine are implemented, the disease prevalence will decline and the DM will be come negative.\n\nFor NY, the tranisition begins in mid May and prevalence of disease stabilzes during July through October but then surges in Winter 2020.\n\n","89fc137f":"Since South Korea was successful in controling the epidemic, use their approximate testing ratio as a standard of adequate testing.\nTheir Testing Ratio was about 40\/1.  That is they performed 40 tests to find one positive case.\nCalculate the number of tests needed for a US state to acheive the testing performance of South Korea. \n\nEXAMPLE:\nSuppose a US state found 1000 positive cases on a particular day WHEN 10,000 total tests were performed on that same day.\nFor this state the testing ratio is 10\/1.  This is less than the testing ratio achieved by South Korea.\n\nFor this state to have tested as aggressively as South Korea that state should have performed 1,000 x 40 = 40,000 tests. \n40,000\/1,000 =  a testing ratio of 40\/1.  The needed number of tests is 40,000 to achieve this.  This state should do 40,000 tests the next day.\n\nProcess:\nStart with the number of positive cases in the state.\nExample: positive = 1000\nTotal tests performed = 10,000\nActual testing ratio = 10,000\/1000 =10\/1\n\nCalculate the estimated ideal number of tests needed to get a 40\/1 testing ratio.\n1000 x 40 = 40,000\n\nCalculate the fraction describing actual tests performed\/ estimated ideal number of tests\n\n = (actual tests performed)\/(estimated ideal number of tests)) = 10,000\/40,000 = 0.25\n = this fraction represents the extent to which the state has achieved ideal testing.\n\nExample: positive = 1000\ntotal tests done =10,000\ntarget number of tests = 40 x Positive cases = 1000 x 40 = 40,000\nNote: testing ratio is 10\/1 but needed ratio is 40\/1\nestimated ideal number of tests = 1000 x 40 = 40,000\n\npercent of ideal target = (10,000\/40,000) x 100 = 25%\n\nThis state has achieved 25% of its ideal target testing needed to achieve control of the epidemic.","e4d4a7a4":"****\n**NEXT, PLOT THE CUMULATIVE TESTING RATIO FOR EACH STATE OVER TIME (testing ratio is the inverse of the % positive ratio)**\n   Example: Perceent positive is  5% = 5\/100.  Inverse = 1\/(5\/100)= 1\/(.05) = 20  or testing ratio of 20\/1\n   Practical interpretation: 20 people are tested in order to find one positive case.","16817ef5":"**There are multiple columns of different categories of antibody test types in the database.  Some states collect different types of antibody information.\nThe sorted_data database contains NegativeTestsPeopleAntibody, positiveTestsAntibody, positiveTestsPeopleAntibody, totalTestsAntibody, totalTestsPeopleAntibody.  Trying to use Antibody results to calculate prevalence of immunity to estimate \"HERD IMMUNITY\" will be difficult.**","4812c4b8":"**Few states have data on the prevalence of antibody status of the population.  This makes it difficult to estimate the level of herd immunity that exists from symptomatic and asymptomatic individuals who have contracted the Covid 19 infection and then developed neutralizing antibodies.**","ad86480d":"**VERIFY FILE NAME**","8860238a":"**Beginning Sections are using CUMULATIVE POSITIVE RESULTS AND CUMULATIVE TOTAL TEST RESULTS**","fa41cec6":"**SORT THE DATA BY STATE alphabetically A->Z**"}}