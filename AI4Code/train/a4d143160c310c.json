{"cell_type":{"b76d80f3":"code","db4f707e":"code","5f9c7305":"code","2eede2e7":"code","ab686472":"code","f6a7dcb7":"code","89ccb03b":"code","8da48df2":"code","b0e59228":"code","52732073":"code","e5e1d7ed":"code","23a86953":"code","c6a18e2a":"code","7f365a5c":"code","f64927a7":"code","54ab138b":"code","c94cd32c":"code","ea0f82f9":"code","8af59b02":"code","e3f45edb":"markdown","bde640c6":"markdown","a9fbcbb7":"markdown","9e45f7cd":"markdown"},"source":{"b76d80f3":"import numpy as np\nimport pandas as pd","db4f707e":"# Generate uniform random stress level for 200 days\ndef stressLevels():\n    return np.random.randint(1, 10, 200)\n# Generate uniform random sleep qualities from previous nights\ndef sleptQualities():\n    return np.random.randint(1, 10, 200)\n# Generate randomly (50\/50 chance) if that day is work day\ndef workDays():\n    return np.array([1 if x >= 0.5 else 0 for x in np.random.random(200)])\n# Generate lambda => expected bernoully parameber for an yes\ndef lambdaVal(stressLevel, sleepQuality, workDay):\n    x = (stressLevel - sleepQuality - workDay * 2)\n    return (1\/(1 + np.exp(-x)))\/2.0","5f9c7305":"# Generate simulated data\nstresses = stressLevels()\nsleeps = sleptQualities()\nworks = workDays()\nlambdas = np.array([lambdaVal(stresses[i], sleeps[i], works[i]) for i in range(200)])","2eede2e7":"fig = pd.DataFrame(lambdas).hist()","ab686472":"# Generate number of coffees that you might drink on a day => maximum is 5\ncoffees = np.array([np.random.binomial(5, ld) for ld in lambdas])","f6a7dcb7":"fig = pd.DataFrame(coffees).hist()","89ccb03b":"# It is observable from the previous picture that number of coffees (outcomes) follow a bernoulli distribution => Linear regression will not work so we will try and see\nfrom sklearn.linear_model import LinearRegression\ndf = pd.DataFrame()\ndf['stresses'] = stresses\ndf['sleeps'] = sleeps\ndf['works'] = works\nX = df.values\ny = coffees","8da48df2":"model = LinearRegression()\nmodel.fit(X, y)","b0e59228":"r_sq = model.score(X, y)\nprint(\"coefficient of determination:\", r_sq)","52732073":"print('Intercept: ', model.intercept_)\nprint('slope: ', model.coef_)","e5e1d7ed":"predicts = model.predict(X)","23a86953":"fig = pd.DataFrame(predicts).hist()","c6a18e2a":"import statsmodels.api as sm","7f365a5c":"binomial_model = sm.GLM(y, X, family=sm.families.Poisson())","f64927a7":"binomial_results = binomial_model.fit()\nprint(binomial_results.summary())","54ab138b":"print(\"Parameters; \", binomial_results.params)","c94cd32c":"yhat = binomial_results.mu","ea0f82f9":"yhat","8af59b02":"pd.DataFrame(yhat).hist()","e3f45edb":"It is observable that the predictions are Gaussian while the actuals are Bernoulli","bde640c6":"# General Linear Models vs. Linear Models\nOne of the assumption for linear models is that the outputs are normally distributed (Gaussian), but in many cases they are not. For instance, number of coffees drank per day follows a Bernoulli distribution with lambda depends on the stress levels, sleep quality in the previous night, and whether the day is work day. In this case, simply using Linear Model will not work, it requires General Linear Model with a link function mapping the expected outputs to a normal distribution (E.g., ln of the bernoulli distribution gets back to normal => now we can use linear model)","a9fbcbb7":"Now the result looks a lot better.","9e45f7cd":"# Convert the data into log (poisson)\nSo in this case, it is suggested that there is a link (ln function) to convert the expected values of the outcome to a normal distribution, thus, can apply the linear model again."}}