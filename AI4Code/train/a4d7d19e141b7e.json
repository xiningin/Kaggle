{"cell_type":{"3983124e":"code","e8a0cec6":"code","35b1a999":"code","a86f1fc9":"code","1ab758a6":"code","a0e34f65":"code","3d609c47":"code","36372b0d":"code","20ccc787":"code","21bd04ce":"code","9f277dde":"code","5165097c":"code","50e1953f":"code","52273ada":"code","ae3d70e4":"code","26ec9bb0":"code","cdbe919a":"code","773cae02":"code","efb8813e":"code","14c1b34c":"code","1a26073d":"code","ec2d10a6":"code","d49f219e":"code","5d23d7b3":"code","df2b20a8":"code","9a267223":"code","93ba8f8e":"code","3fd90d4f":"code","1871492a":"code","8f99f55a":"code","2b6feacd":"code","79c725cd":"code","6133f45d":"code","de109743":"code","357e2e13":"code","19f1c25b":"code","dbc2de94":"code","22db56c4":"code","fda63b0d":"code","a507e38a":"code","ecf5b4f2":"code","6ccbb995":"code","d6bbb2fd":"code","0e556a37":"code","4b75acfb":"code","9c41778e":"code","b43b958a":"code","2f58d915":"code","f23a83ea":"markdown","d2a36392":"markdown","1d41325e":"markdown","27ef872e":"markdown","9d0a6715":"markdown","440f2c26":"markdown","d1330f5d":"markdown","a410a29e":"markdown","918cbbc2":"markdown","1a66c28f":"markdown","c1dbbd98":"markdown","62dbbc1b":"markdown","704bd1c2":"markdown","2da3b46f":"markdown","0a744d3d":"markdown","def8528f":"markdown","0f7662f1":"markdown","5060188d":"markdown","5548605e":"markdown","c48172d2":"markdown","3e058b10":"markdown","b080ab1b":"markdown","37a323c1":"markdown","6112ea4f":"markdown","d3aee989":"markdown","34b267e0":"markdown","b4bdb8d7":"markdown","2d9c5986":"markdown","149cf9d5":"markdown","3a98f1f7":"markdown","0b2a7e17":"markdown","51c5af2b":"markdown","0de3ed4a":"markdown"},"source":{"3983124e":"import numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nimport seaborn as sns\nimport gc\nimport glob\nimport os\nimport cv2\nimport pydicom\n\nimport warnings\nwarnings.simplefilter(action = 'ignore')","e8a0cec6":"detailed_df = pd.read_csv('\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_detailed_class_info.csv')\ntrain_df = pd.read_csv('\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_train_labels.csv')\n","35b1a999":"\ndetailed_df.shape","a86f1fc9":"\ntrain_df.shape","1ab758a6":"detailed_df.head()\n","a0e34f65":"train_df.head()\n","3d609c47":"df = pd.concat([train_df,detailed_df[\"class\"]],axis=1,sort=False)\n\n# df = pd.merge(left = detailed_df, right = train_df, how = 'left', on = 'patientId')\ndf = df.drop_duplicates()\ndf.info()","36372b0d":"df.shape\n","20ccc787":"df.isnull().sum()","21bd04ce":"pd.pivot_table(df,index=[\"Target\"], values=['patientId'], aggfunc='count')","9f277dde":"pd.pivot_table(df,index=[\"class\"], values=['patientId'], aggfunc='count')","5165097c":"df[\"class\"].value_counts().plot(kind='pie',autopct='%1.0f%%', shadow=True, subplots=False)","50e1953f":"pd.pivot_table(df,index=[\"Target\"], aggfunc='count')\n","52273ada":"df['patientId'].value_counts().value_counts()\n","ae3d70e4":"df[df['Target'] == 0]['patientId'].value_counts().value_counts()\n","26ec9bb0":"sns.countplot(x = 'class', hue = 'Target', data = df)\n","cdbe919a":"df.fillna(0.0)\n","773cae02":"df.corr()\n","efb8813e":"sns.jointplot(x = 'width', y = 'height', data = df, kind=\"reg\")\n","14c1b34c":"#df_Not_Normal = df[df['class']=='No Lung Opacity \/ Not Normal'].sample(n=390)\n#df_Normal = df[df['class']=='Normal'].sample(n=290)\n#df_Lunge_Opacity = df[df['class']=='Lung Opacity'].sample(n=320)\n#frames = [df_Not_Normal, df_Normal, df_Lunge_Opacity]\n\n#dicom_df = pd.concat(frames)\ndicom_df=df\ndicom_df.shape","1a26073d":"from tqdm import tqdm\ndef process_dicom_data(data_df):\n    for n, pid in tqdm(enumerate(data_df['patientId'].unique())):        \n        dcm_file = '\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_train_images\/%s.dcm' % pid\n        dcm_data = pydicom.read_file(dcm_file)        \n        idx = (data_df['patientId']==dcm_data.PatientID)\n        data_df.loc[idx,'Modality'] = dcm_data.Modality\n        data_df.loc[idx,'PatientAge'] = pd.to_numeric(dcm_data.PatientAge)\n        data_df.loc[idx,'PatientSex'] = dcm_data.PatientSex\n        data_df.loc[idx,'BodyPartExamined'] = dcm_data.BodyPartExamined\n        data_df.loc[idx,'ViewPosition'] = dcm_data.ViewPosition\n        \n    return data_df","ec2d10a6":"dicom_df = process_dicom_data(dicom_df)\n","d49f219e":"dicom_df = dicom_df.astype({\"PatientAge\": int})\ndicom_df.fillna(0.0, inplace=True)\ndicom_df.head()","5d23d7b3":"dicom_df.nunique()\n","df2b20a8":"plt.figure(figsize = (30, 10))\nsns.countplot(x = 'PatientAge', hue = 'Target', data = dicom_df)","9a267223":"sns.countplot(x = 'PatientSex', hue = 'Target', data = dicom_df)\n","93ba8f8e":"sns.countplot(x = 'ViewPosition', hue = 'Target', data = dicom_df);\n","3fd90d4f":"dicom_df = dicom_df.drop('Target', axis=1)","1871492a":"dicom_df['PatientSex'].astype('category')\ndicom_df['ViewPosition'].astype('category')\ndicom_df['PatientSex'] = np.where(dicom_df[\"PatientSex\"].str.contains(\"M\"), 1, 0)\ndicom_df['ViewPosition'] = np.where(dicom_df[\"ViewPosition\"].str.contains(\"AP\"), 1, 0)","8f99f55a":"dicom_df.head()\n","2b6feacd":"dicom_df.corr()\n","79c725cd":"def show_dicom_image(data_df):\n        img_data = list(data_df.T.to_dict().values())\n        f, ax = plt.subplots(2,2, figsize=(16,18))\n        for i,data_row in enumerate(img_data):\n            pid = data_row['patientId']\n            dcm_file = '\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_train_images\/%s.dcm' % pid\n            dcm_data = pydicom.read_file(dcm_file)                    \n            ax[i\/\/2, i%2].imshow(dcm_data.pixel_array, cmap=plt.cm.bone)\n            ax[i\/\/2, i%2].set_title('ID: {}\\n Age: {} Sex: {}'.format(\n                data_row['patientId'],dcm_data.PatientAge, dcm_data.PatientSex))\n","6133f45d":"show_dicom_image(df[df['Target']==1].sample(n=4))\n","de109743":"show_dicom_image(df[ (df['Target']==0) & (df['class']=='No Lung Opacity \/ Not Normal')].sample(n=4))","357e2e13":"show_dicom_image(df[ (df['Target']==0) & (df['class']=='Normal')].sample(n=4))\n","19f1c25b":"def show_dicome_with_boundingbox(data_df):\n    img_data = list(data_df.T.to_dict().values())\n    f, ax = plt.subplots(2,2, figsize=(16,18))\n    for i,data_row in enumerate(img_data):\n        pid = data_row['patientId']\n        dcm_file = '\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_train_images\/%s.dcm' % pid\n        dcm_data = pydicom.read_file(dcm_file)                    \n        ax[i\/\/2, i%2].imshow(dcm_data.pixel_array, cmap=plt.cm.bone)\n        ax[i\/\/2, i%2].set_title('ID: {}\\n Age: {} Sex: {}'.format(\n                data_row['patientId'],dcm_data.PatientAge, dcm_data.PatientSex))\n        rows = data_df[data_df['patientId']==data_row['patientId']]\n        box_data = list(rows.T.to_dict().values())        \n        for j, row in enumerate(box_data):            \n            x,y,width,height = row['x'], row['y'],row['width'],row['height']\n            rectangle = Rectangle(xy=(x,y),width=width, height=height, color=\"red\",alpha = 0.1)\n            ax[i\/\/2, i%2].add_patch(rectangle)    ","dbc2de94":"show_dicome_with_boundingbox(df[df['Target']==1].sample(n=4))\n","22db56c4":"import os\nimport csv\nimport random\nimport pydicom\nimport numpy as np\nimport pandas as pd\nfrom skimage import measure\nfrom skimage.transform import resize\n\nimport tensorflow as tf\nfrom tensorflow import keras","fda63b0d":"pneumonia_locations = {}\n# load table\nwith open(os.path.join('\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_train_labels.csv'), mode='r') as infile:\n    # open reader\n    reader = csv.reader(infile)\n    # skip header\n    next(reader, None)\n    # loop through rows\n    for rows in reader:\n        # retrieve information\n        filename = rows[0]\n        location = rows[1:5]\n        pneumonia = rows[5]\n        # if row contains pneumonia add label to dictionary\n        # which contains a list of pneumonia locations per filename\n        if pneumonia == '1':\n            # convert string to float to int\n            location = [int(float(i)) for i in location]\n            # save pneumonia location in dictionary\n            if filename in pneumonia_locations:\n                pneumonia_locations[filename].append(location)\n            else:\n                pneumonia_locations[filename] = [location]","a507e38a":"# load and shuffle filenames\nfolder = '\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_train_images'\nfilenames = os.listdir(folder)\nrandom.shuffle(filenames)\n# split into train and validation filenames\nn_valid_samples = 2560\ntrain_filenames = filenames[n_valid_samples:]\nvalid_filenames = filenames[:n_valid_samples]\nprint('n train samples', len(train_filenames))\nprint('n valid samples', len(valid_filenames))\nn_train_samples = len(filenames) - n_valid_samples","ecf5b4f2":"class generator(keras.utils.Sequence):\n    \n    def __init__(self, folder, filenames, pneumonia_locations=None, batch_size=32, image_size=320, shuffle=True, augment=False, predict=False):\n        self.folder = folder\n        self.filenames = filenames\n        self.pneumonia_locations = pneumonia_locations\n        self.batch_size = batch_size\n        self.image_size = image_size\n        self.shuffle = shuffle\n        self.augment = augment\n        self.predict = predict\n        self.on_epoch_end()\n        \n    def __load__(self, filename):\n        # load dicom file as numpy array\n        img = pydicom.dcmread(os.path.join(self.folder, filename)).pixel_array\n        # create empty mask\n        msk = np.zeros(img.shape)\n        # get filename without extension\n        filename = filename.split('.')[0]\n        # if image contains pneumonia\n        if filename in pneumonia_locations:\n            # loop through pneumonia\n            for location in pneumonia_locations[filename]:\n                # add 1's at the location of the pneumonia\n                x, y, w, h = location\n                msk[y:y+h, x:x+w] = 1\n        # if augment then horizontal flip half the time\n        if self.augment and random.random() > 0.5:\n            img = np.fliplr(img)\n            msk = np.fliplr(msk)\n        # resize both image and mask\n        img = resize(img, (self.image_size, self.image_size), mode='reflect')\n        msk = resize(msk, (self.image_size, self.image_size), mode='reflect') > 0.5\n        # add trailing channel dimension\n        img = np.expand_dims(img, -1)\n        msk = np.expand_dims(msk, -1)\n        return img, msk\n    \n    def __loadpredict__(self, filename):\n        # load dicom file as numpy array\n        img = pydicom.dcmread(os.path.join(self.folder, filename)).pixel_array\n        # resize image\n        img = resize(img, (self.image_size, self.image_size), mode='reflect')\n        # add trailing channel dimension\n        img = np.expand_dims(img, -1)\n        return img\n        \n    def __getitem__(self, index):\n        # select batch\n        filenames = self.filenames[index*self.batch_size:(index+1)*self.batch_size]\n        # predict mode: return images and filenames\n        if self.predict:\n            # load files\n            imgs = [self.__loadpredict__(filename) for filename in filenames]\n            # create numpy batch\n            imgs = np.array(imgs)\n            return imgs, filenames\n        # train mode: return images and masks\n        else:\n            # load files\n            items = [self.__load__(filename) for filename in filenames]\n            # unzip images and masks\n            imgs, msks = zip(*items)\n            # create numpy batch\n            imgs = np.array(imgs)\n            msks = np.array(msks)\n            return imgs, msks\n        \n    def on_epoch_end(self):\n        if self.shuffle:\n            random.shuffle(self.filenames)\n        \n    def __len__(self):\n        if self.predict:\n            # return everything\n            return int(np.ceil(len(self.filenames) \/ self.batch_size))\n        else:\n            # return full batches only\n            return int(len(self.filenames) \/ self.batch_size)","6ccbb995":"# define iou or jaccard loss function\ndef iou_loss(y_true, y_pred):\n    #print(y_true)\n    y_true=tf.cast(y_true, tf.float32)\n    y_pred=tf.cast(y_pred, tf.float32)\n    y_true = tf.reshape(y_true, [-1])\n    y_pred = tf.reshape(y_pred, [-1])\n   \n    intersection = tf.reduce_sum(y_true * y_pred)\n    score = (intersection + 1.) \/ (tf.reduce_sum(y_true) + tf.reduce_sum(y_pred) - intersection + 1.)\n    return 1 - score\n\n# combine bce loss and iou loss\ndef iou_bce_loss(y_true, y_pred):\n    return 0.5 * keras.losses.binary_crossentropy(y_true, y_pred) + 0.5 * iou_loss(y_true, y_pred)\n\n# mean iou as a metric\ndef mean_iou(y_true, y_pred):\n    y_pred = tf.round(y_pred)\n    intersect = tf.reduce_sum(y_true * y_pred, axis=[1, 2, 3])\n    union = tf.reduce_sum(y_true, axis=[1, 2, 3]) + tf.reduce_sum(y_pred, axis=[1, 2, 3])\n    smooth = tf.ones(tf.shape(intersect))\n    return tf.reduce_mean((intersect + smooth) \/ (union - intersect + smooth))\n\ndef create_downsample(channels, inputs):\n    x = keras.layers.BatchNormalization(momentum=0.9)(inputs)\n    x = keras.layers.LeakyReLU(0)(x)\n    x = keras.layers.Conv2D(channels, 1, padding='same', use_bias=False)(x)\n    x = keras.layers.MaxPool2D(2)(x)\n    return x\n\ndef create_resblock(channels, inputs):\n    x = keras.layers.BatchNormalization(momentum=0.9)(inputs)\n    x = keras.layers.LeakyReLU(0)(x)\n    x = keras.layers.Conv2D(channels, 3, padding='same', use_bias=False)(x)\n    x = keras.layers.BatchNormalization(momentum=0.9)(x)\n    x = keras.layers.LeakyReLU(0)(x)\n    x = keras.layers.Conv2D(channels, 3, padding='same', use_bias=False)(x)\n    return keras.layers.add([x, inputs])\n\ndef create_network(input_size, channels, n_blocks=2, depth=4):\n    # input\n    inputs = keras.Input(shape=(input_size, input_size, 1))\n    x = keras.layers.Conv2D(channels, 3, padding='same', use_bias=False)(inputs)\n    # residual blocks\n    for d in range(depth):\n        channels = channels * 2\n        x = create_downsample(channels, x)\n        for b in range(n_blocks):\n            x = create_resblock(channels, x)\n    # output\n    x = keras.layers.BatchNormalization(momentum=0.9)(x)\n    x = keras.layers.LeakyReLU(0)(x)\n    x = keras.layers.Conv2D(128, 1, activation=None)(x)\n    x = keras.layers.BatchNormalization(momentum=0.9)(x)\n    x = keras.layers.LeakyReLU(0)(x)\n    x = keras.layers.Conv2DTranspose(64, (8,8), (4,4), padding=\"same\", activation=None)(x)\n    x = keras.layers.BatchNormalization(momentum=0.9)(x)\n    x = keras.layers.LeakyReLU(0)(x)\n    x = keras.layers.Conv2D(1, 1, activation='sigmoid')(x)\n    outputs = keras.layers.UpSampling2D(2**(depth-2))(x)\n    model = keras.Model(inputs=inputs, outputs=outputs)\n    return model","d6bbb2fd":"BATCH_SIZE = 16\nIMAGE_SIZE = 128","0e556a37":"# create network and compiler\nmodel = create_network(input_size=IMAGE_SIZE, channels=32, n_blocks=2, depth=4)\nmodel.compile(optimizer='adam',\n              loss=iou_bce_loss,\n              metrics=['accuracy', mean_iou])\n\n#model.compile(optimizer='adam',loss='mean_squared_error', metrics=[])","4b75acfb":"# cosine learning rate annealing\ndef cosine_annealing(x):\n    lr = 0.001\n    epochs = 7\n    return lr*(np.cos(np.pi*x\/epochs)+1.)\/2\nlearning_rate = tf.keras.callbacks.LearningRateScheduler(cosine_annealing)\n\n# create train and validation generators\nfolder = '\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_train_images'\ntrain_gen = generator(folder, train_filenames, pneumonia_locations, batch_size=BATCH_SIZE, image_size=IMAGE_SIZE, shuffle=True, augment=False, predict=False)\nvalid_gen = generator(folder, valid_filenames, pneumonia_locations, batch_size=BATCH_SIZE, image_size=IMAGE_SIZE, shuffle=False, predict=False)\n\nprint(model.summary())","9c41778e":"EPOCHS=7\nMULTI_PROCESSING = True \n\n\nhistory = model.fit_generator(train_gen, validation_data=valid_gen, callbacks=[learning_rate], use_multiprocessing=True, epochs=EPOCHS, shuffle=True, verbose=1)\n","b43b958a":"plt.subplot(131)\nplt.plot(history.epoch, history.history[\"loss\"], label=\"Train loss\")\nplt.plot(history.epoch, history.history[\"val_loss\"], label=\"Valid loss\")\nplt.legend()\nplt.subplot(132)\nplt.plot(history.epoch, history.history[\"acc\"], label=\"Train accuracy\")\nplt.plot(history.epoch, history.history[\"val_acc\"], label=\"Valid accuracy\")\nplt.legend()\nplt.subplot(133)\nplt.plot(history.epoch, history.history[\"mean_iou\"], label=\"Train iou\")\nplt.plot(history.epoch, history.history[\"val_mean_iou\"], label=\"Valid iou\")\nplt.legend()\nplt.show()","2f58d915":"# load and shuffle filenames\n#folder = '..\/input\/stage_2_test_images'\nfolder = '\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_test_images'\ntest_filenames = os.listdir(folder)\nprint('n test samples:', len(test_filenames))\n\n# create test generator with predict flag set to True\ntest_gen = generator(folder, test_filenames, None, batch_size=16, image_size=IMAGE_SIZE, shuffle=False, predict=True)\n\n# create submission dictionary\nsubmission_dict = {}\n# loop through testset\nfor imgs, filenames in tqdm(test_gen):\n    # predict batch of images\n    preds = model.predict(imgs)\n    # loop through batch\n    for pred, filename in zip(preds, filenames):\n        # resize predicted mask\n        pred = resize(pred, (1024, 1024), mode='reflect')\n        # threshold predicted mask\n        comp = pred[:, :, 0] > 0.5\n        # apply connected components\n        comp = measure.label(comp)\n        # apply bounding boxes\n        predictionString = ''\n        for region in measure.regionprops(comp):\n            # retrieve x, y, height and width\n            y, x, y2, x2 = region.bbox\n            height = y2 - y\n            width = x2 - x\n            # proxy for confidence score\n            conf = np.mean(pred[y:y+height, x:x+width])\n            # add to predictionString\n            predictionString += str(conf) + ' ' + str(x) + ' ' + str(y) + ' ' + str(width) + ' ' + str(height) + ' '\n        # add filename and predictionString to dictionary\n        filename = filename.split('.')[0]\n        submission_dict[filename] = predictionString\n    # stop if we've got them all\n    if len(submission_dict) >= len(test_filenames):\n        break\n        \nprint(\"Done predicting...\")\n        \n# save dictionary as csv file\nsub = pd.DataFrame.from_dict(submission_dict,orient='index')\nsub.index.names = ['patientId']\nsub.columns = ['PredictionString']\nsub.to_csv('submission.csv')","f23a83ea":"> Showing some random dicom images of a patient who do not have Pnuemonia, however with class No Lung Opacity \/ Not Normal","d2a36392":"## Exploring the given Data files, classes and images of different classes.","1d41325e":"With respect to view proportion\n","27ef872e":"> ### Load Files\n","9d0a6715":"**Visualizing the dicom images**\n","440f2c26":"## Data generator\n\n\nThe dataset is too large to fit into memory, so we need to create a generator that loads data on the fly.\n\nThe generator takes in some filenames, batch_size and other parameters.\n\nThe generator outputs a random batch of numpy images and numpy masks.","d1330f5d":"# Overview\n\nPneumonia is an infection in one or both lungs. The infection causes inflammation in the air sacs in your lungs, which are called **alveoli**. The alveoli fill with fluid or pus, making it difficult to breathe.\n\n![Pneumonia Inflammation](https:\/\/www.physio-pedia.com\/images\/9\/94\/Pneumonia_Inflammation.jpg)\n","a410a29e":"Merging the data tables detailed_df and train_df\u00b6\n","918cbbc2":"Patient's gender proportion in the detection\n","1a66c28f":"Summary on the values, types and null values:\u00b6\n","c1dbbd98":"Patients who do not have pneumonia has only one record in the table\u00b6\n","62dbbc1b":"It is also clear from the below output that the patients who do not have pnuemonia do not have the bounding box coordinates","704bd1c2":"# MileStone 2\n# **Model Building**","2da3b46f":"## Load filenames ","0a744d3d":"## EDA with the header values from the dataframe\n* Creating a data frame with all of their appropriate header values from the dicom file takes long time as there are 30277 records. Hence, the EDA analysis is done on a subset of randomly chosen 1000 records by keeping the same proportion of the classes. (i.e) The classes Not Normal, Normal, Lunge Opacity are in a proportion 39%, 29%, and 32% respectively.\n\n* Number of rows of Not Normal class = 39% of 1000 = 390 rows\n* Number of rows of Normal class = 29% of 1000 = 290 rows\n* Number of rows of Lunge Opacity class = 32% of 1000 = 320 rows","def8528f":"> There are 995 unique patient rows exist\n> ","0f7662f1":"\nDoctors or radiologiests conduct a physical exam and use **CXR**(chest x-ray) to examin and detect pneumonia. In CXR it shows opacity in the reagion.\n\n![Pneumonia CXRs](https:\/\/ars.els-cdn.com\/content\/image\/1-s2.0-S0092867418301545-figs6_lrg.jpg)\n\n\n* There are multiple causes of opacity n CXR other than pneumonia like;\n    * fluid overload (pulmonary edema)\n    * bleeding\n    * volume loss (atelectasis or collapse)\n    * lung cancer\n    * post-radiation or surgical changes\n    * Outside of the lungs, fluid in the pleural space (pleural effusion) \n\nA number of factors such as positioning of the patient and depth of inspiration can alter the appearance of the CXR.\n\n\n\nPneumonia opacity can occour in different reagions of chest and the opacity can be of different kinds. This makes it the problem of detection(regression) as well as recognition(classification). For such purpose we can think of using the pre-existing models like 'Faster R-CNN' or 'Yolo'.\n\n![Types and Regions](http:\/\/adigaskell.org\/wp-content\/uploads\/2017\/11\/pneumonia-xray.jpg)\n\n\n","5060188d":"Count of patients having single row and more than single rows\u00b6\n","5548605e":"## Now Visualizing the data along with their dicom header values\n","c48172d2":"Apart from the correlation between the width and height,there is no strong correlation between the other variables in the dataframe","3e058b10":"### Imports\n[Back to top](#Table-of-Contents)","b080ab1b":"# Load pneumonia locations\n\nTable contains [filename : pneumonia location] pairs per row.\n\nIf a filename contains multiple pneumonia, the table contains multiple rows with the same filename but different pneumonia locations.\nIf a filename contains no pneumonia it contains a single row with an empty pneumonia location.\nThe code below loads the table and transforms it into a dictionary.\n\nThe dictionary uses the filename as key and a list of pneumonia locations in that filename as value.\nIf a filename is not present in the dictionary it means that it contains no pneumonia.","37a323c1":"## Table of Contents\n\n**- MileStone 1**\n- Pre-Processing,-Data-Visualisation,-EDA-and-Model-Building\n- Exploring-the-given-Data-files,-classes-and-images-of-different-classes\n- Imports\n- Load-images\n- Load-Labels\n- Load-Classes\n- Show-bounding-box-on-the-image-to-identify-pneumonia\n- Dealing-with-missing-values\n- Get-Target-Labels-and-Classes-into-one-dataset\n- Visualisation-of-different-classes\n- Show-image-of-class-'No-Lung-Opacity-\/-Not-Normal\n- Show-image-of-class-'Normal'\n- Show-image-of-class-'Lung-Opacity'\n- Show-images-with-multiple-bounding-boxes-as-applicable\n- Analysis-from-the-visualisation-of-different-classes\n \n**- MileStone 2** \n- Build-Model\n       \n\n   ","6112ea4f":"Distribution of classes\n\nThe following output shows that the nearly 2\/3 of the patients do not have pneumonia (with target value = 0) and 1\/3 of the patients have pneumonia (with target value =1)","d3aee989":"Preprocessing - Filling the null values\n","34b267e0":"# Plot Accuracy \/ Loss","b4bdb8d7":"Patient's age proportion in the detection\n","2d9c5986":"# Milestone 1: Pre-Processing, Data Visualisation, EDA and Model Building","149cf9d5":"# Predict test images","3a98f1f7":"> Showing some random dicom images of a patients who do not have Pnuemonia, however with class Normal","0b2a7e17":"The classes \"No Lung Opacity \/ Not Normal\", \"Normal\", and \"Lung Opacity\" are in the proportion of 39%, 29% and 32% respectively","51c5af2b":"Distribution of patients in each class\nThere are 9555 patients in the category 'Lung Opacity' and 11821 in 'No Lung Opacity \/ Not Normal' category and 8851 are in Normal category","0de3ed4a":"Correlation between the variables\nThere is a strong Correlation between height and width variables"}}