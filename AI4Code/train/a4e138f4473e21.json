{"cell_type":{"3b10db5f":"code","06e07535":"code","0f8fb2d2":"code","34aa411c":"code","d53a53a3":"code","2ecba278":"code","02303195":"code","bc1c27ae":"code","18224264":"code","79fc9714":"code","6b6b18bd":"code","0500c986":"code","4ae26a2b":"code","36016bcb":"code","4722af14":"code","d6906dfc":"code","b0ec898e":"code","43849d94":"code","dce794f7":"code","ea04735f":"code","8fbdbd6e":"code","10d44196":"code","d6daee16":"code","3fdb800e":"markdown","eab4a762":"markdown","da588f75":"markdown","f27797ef":"markdown","fb4e6581":"markdown","9a54b9d1":"markdown","084230df":"markdown","e33b4787":"markdown","fbc97090":"markdown","198b2880":"markdown","28695fd6":"markdown","e4a46486":"markdown","80261eb1":"markdown","3fa33b53":"markdown","a4868599":"markdown","4c61895b":"markdown","417d2618":"markdown","5ed1f360":"markdown","c89a5b26":"markdown","9cfe7ece":"markdown","8fc79190":"markdown","a1955c10":"markdown"},"source":{"3b10db5f":"# Downloading dataset:\nfrom zipfile import ZipFile\nimport os\nimport pandas as pd\n\n# The below code is ran in google colab\nos.environ[\"KAGGLE_USERNAME\"] = \"KAGGLE_USERNAME\"  # username from the json file\nos.environ[\"KAGGLE_KEY\"] = \"KAGGLE_KEY\"  # key from the json file\n!kaggle datasets download -d praveengovi\/coronahack-chest-xraydataset  # api copied from kaggle\n\n# Create a ZipFile Object and load chest-xray-pneumonia.zip in it\nwith ZipFile(\"\/content\/coronahack-chest-xraydataset.zip\", \"r\") as zipObj:\n    # Extract all the contents of zip file in current directory\n    zipObj.extractall()\n\n# KAGGLE LINK: https:\/\/www.kaggle.com\/praveengovi\/coronahack-chest-xraydataset\n","06e07535":"import pandas as pd\ndata = pd.read_csv(\"..\/input\/coronahack-chest-xraydataset\/Chest_xray_Corona_Metadata.csv\")\ndata","0f8fb2d2":"# Printing unique labels\nunique_labels = []\nfor i in  data['Label']:\n    if i not in unique_labels:\n        unique_labels.append(i)\n        \nprint(unique_labels)","34aa411c":"import os\nimport pandas as pd\nimport time\nimport shutil\n\nPATH_TRAIN = \"..\/input\/coronahack-chest-xraydataset\/Coronahack-Chest-XRay-Dataset\/Coronahack-Chest-XRay-Dataset\/train\"\nTOTAL_IMGS = len(os.listdir(PATH_TRAIN))\nnormal = 0\ninfected = 0\n\n\n\nimg = data[\"X_ray_image_name\"]\nlabel = data[\"Label\"]\nimage_type = data[\"Dataset_type\"]\nall_dir = os.listdir(PATH_TRAIN)\n\nos.mkdir(\"train\")\nos.mkdir('train\/INFECTED')\nos.mkdir(\"train\/NORMAL\")\n\nwrong_info = 0  # Checking if the provided list maps the images correctly\n\n# Moving the train images to designated folders\n\nfor i in range(len(image_type)):\n    if image_type[i] == \"TRAIN\":\n        if img[i] in all_dir: # Make sure that all images in Chest_xray_Corona_Metadata.csv is mapped\n            if label[i] == \"Normal\":\n                infected = infected + 1\n                shutil.copy(\n                    PATH_TRAIN + \"\/\" + img[i], \"train\/NORMAL\/\" + img[i]\n                )\n                normal = normal + 1\n\n            else:\n\n                shutil.copy(\n                    PATH_TRAIN + \"\/\" + img[i], \"train\/INFECTED\/\" + img[i]\n                )\n                infected = infected + 1\n\n        else:\n            wrong_info = wrong_info + 1\n\nprint(\n    \"X-ray of Normal patients (TRAIN DATASET): \" + str(normal),\n    \"X-ray of Infected patients (TRAIN DATASET): \" + str(infected),\n    end = \"\\n\"\n)\n","d53a53a3":"import matplotlib.pyplot as plt\n\nfig = plt.figure()\nax = fig.add_axes([0, 0, 1, 1])\ncategories = [\"NORMAL\", \"INFECTED\"]\nnumber_of_imgs = [normal, infected]\nax.bar(0, number_of_imgs[0], color=\"g\", width=0.1)\nax.bar(0.15, number_of_imgs[1], color=\"r\", width=0.1)\nax.legend(labels=categories)\nax.set_ylabel(\"Number of images\")\nax.set_xlabel(\"Categories\")\nplt.show()\n","2ecba278":"PATH_TEST = \"..\/input\/coronahack-chest-xraydataset\/Coronahack-Chest-XRay-Dataset\/Coronahack-Chest-XRay-Dataset\/test\"\nTOTAL_IMGS = len(os.listdir(PATH_TEST))\nnormal = 0\ninfected = 0\n\nimg = data[\"X_ray_image_name\"]\nlabel = data[\"Label\"]\nimage_type = data[\"Dataset_type\"]\nall_dir = os.listdir(PATH_TEST)\n\nos.mkdir(\"test\")\nos.mkdir('test\/INFECTED')\nos.mkdir(\"test\/NORMAL\")\n\n\n\nwrong_info = 0\n\nfor i in range(len(image_type)):\n    if image_type[i] == \"TEST\":\n        if img[i] in all_dir:\n            if label[i] == \"Normal\":\n                infected = infected + 1\n                shutil.copy(\n                    PATH_TEST + \"\/\" + img[i], \"test\/NORMAL\/\" + img[i]\n                )\n                normal = normal + 1\n\n            else:\n\n                shutil.copy(\n                    PATH_TEST + \"\/\" + img[i], \"test\/INFECTED\/\" + img[i]\n                )\n                infected = infected + 1\n\n        else:\n            wrong_info = wrong_info + 1\n\nprint(\n    \"X-ray of Normal patients (TEST DATASET): \" + str(normal),\n    \"X-ray of Infected patients (TEST DATASET): \" + str(infected),\n    end = \"\\n\"\n)\n\n","02303195":"fig = plt.figure()\nax = fig.add_axes([0, 0, 1, 1])\ncategories = [\"NORMAL\", \"INFECTED\"]\nnumber_of_imgs = [normal, infected]\nax.bar(0, number_of_imgs[0], color=\"g\", width=0.1)\nax.bar(0.15, number_of_imgs[1], color=\"r\", width=0.1)\nax.legend(labels=categories)\nax.set_ylabel(\"Number of images\")\nax.set_xlabel(\"Categories\")\nplt.show()","bc1c27ae":"import os\n\ndef list_files(startpath):\n    for root, dirs, files in os.walk(startpath):\n        level = root.replace(startpath, '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print('{}{}\/'.format(indent, os.path.basename(root)))\n        subindent = ' ' * 4 * (level + 1)\n        n = 0\n        for f in files:\n            n = n+1\n            if n>5:\n                print('{}{}'.format(subindent, f),end = \"  ...... \\n\")\n                break\n            print('{}{}'.format(subindent, f))\n\n\nlist_files(\"\/content\/Coronahack-Chest-XRay-Dataset\")","18224264":"import cv2\n\nnormal_sample = cv2.imread(\"train\/NORMAL\/\"+os.listdir(\"train\/NORMAL\")[3])\ninfected_sample = cv2.imread(\"train\/INFECTED\/\"+os.listdir(\"train\/INFECTED\")[2])\n\nplt.imshow(normal_sample)\nplt.title(\"NORMAL\")\nplt.show()\n\nplt.imshow(infected_sample)\nplt.title(\"INFECTED\")\nplt.show()","79fc9714":"from sklearn import cluster\nimport numpy as np\n\nkmeans = cluster.KMeans(5)\ndims = np.shape(infected_sample)\npixel_matrix = np.reshape(infected_sample, (dims[0] * dims[1], dims[2]))\nclustered = kmeans.fit_predict(pixel_matrix)\n\n\nclustered_img = np.reshape(clustered, (dims[0], dims[1]))\nplt.imshow(clustered_img)\nplt.title(\"INFECTED\")\nplt.show()\n\nkmeans = cluster.KMeans(5)\ndims = np.shape(normal_sample)\npixel_matrix = np.reshape(normal_sample, (dims[0] * dims[1], dims[2]))\nclustered = kmeans.fit_predict(pixel_matrix)\n\n\nclustered_img = np.reshape(clustered, (dims[0], dims[1]))\nplt.imshow(clustered_img)\nplt.title(\"NORMAL\")\nplt.show()\n","6b6b18bd":"from skimage import io\nimport matplotlib.pyplot as plt\n\nplt.imshow(normal_sample)\nplt.title(\"NORMAL\")\nplt.show()\n\nimage = io.imread(\"train\/NORMAL\/\"+os.listdir(\"train\/NORMAL\")[3])\nax = plt.hist(image.ravel(), bins = 256)\nplt.xlabel('Intensity Value')\nplt.ylabel('Frequency')\nplt.show()\n\nplt.imshow(infected_sample)\nplt.title(\"INFECTED\")\nplt.show()\n\nimage = io.imread(\"train\/INFECTED\/\"+os.listdir(\"train\/INFECTED\")[2])\nax = plt.hist(image.ravel(), bins = 256)\nplt.xlabel('Intensity Value')\nplt.ylabel('Frequency')\nplt.show()","0500c986":"import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport os\nimport time\nimport torchvision\nfrom PIL import ImageFile\nimport matplotlib.pyplot as plt\nimport cv2","4ae26a2b":"ImageFile.LOAD_TRUNCATED_IMAGES = True # To prevent error during loading broken images\n\nPATH_TRAIN = \"train\"\nPATH_TEST  = \"test\"\nEPOCHS = 10\nBATCH_SIZE = 32\nTOTAL_SIZE = len(os.listdir(PATH_TRAIN + \"\/NORMAL\")) + len(\n    os.listdir(PATH_TRAIN + \"\/INFECTED\")\n)\nTOTAL_TEST_SIZE = len(os.listdir(PATH_TEST + \"\/NORMAL\")) + len(\n    os.listdir(PATH_TEST + \"\/INFECTED\")\n)\nSTEPS_PER_EPOCH = TOTAL_SIZE \/\/ BATCH_SIZE\nSTEPS_PER_TEST_EPOCH = TOTAL_TEST_SIZE \/\/ BATCH_SIZE\nIMAGE_H, IMAGE_W = 224, 224","36016bcb":"transform = torchvision.transforms.Compose(\n    [  # Applying Augmentation\n        torchvision.transforms.Resize((IMAGE_H, IMAGE_W)),\n        torchvision.transforms.RandomHorizontalFlip(p=0.5),\n        torchvision.transforms.RandomVerticalFlip(p=0.5),\n        torchvision.transforms.RandomRotation(30),\n        torchvision.transforms.ToTensor(),\n        torchvision.transforms.Normalize(\n            mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]\n        ),\n    ]\n)  # Normalizing data\n\n# Intitalizing the train data loader and applying the transformations\n\ntrain_dataset = torchvision.datasets.ImageFolder(root=PATH_TRAIN, transform=transform)\n\ntrain_loader = torch.utils.data.DataLoader(\n    train_dataset, batch_size=BATCH_SIZE, num_workers=1, shuffle=True\n)\n\n# Intitalizing the test data loader\n\ntest_dataset = torchvision.datasets.ImageFolder(\n    root=PATH_TEST, transform=transform\n)\n\ntest_loader = torch.utils.data.DataLoader(\n    test_dataset, batch_size=BATCH_SIZE, num_workers=1, shuffle=True\n)","4722af14":"model_ft = torchvision.models.resnet18(False)  # Initializing resnet18\nmodel_ft.load_state_dict(torch.load(\"..\/input\/pretrained-pytorch-models\/resnet18-5c106cde.pth\"))\nnum_ftrs = model_ft.fc.in_features # Getting last layer's output features\nmodel_ft.fc = nn.Linear(num_ftrs, 2) # Modifying the last layer accordng to our need","d6906dfc":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nmodel_ft.to(device)  # Sending model to device\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(\n    model_ft.parameters(), lr=0.0007\n)  # lr should be kept low so that the pre-trained weights don't change easily","b0ec898e":"def get_test():\n    test_loss = []\n    correct = 0\n    incorrect = 0\n\n    device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n\n    for batch_idx, (data, target) in enumerate(test_loader):\n        if batch_idx == STEPS_PER_TEST_EPOCH:\n            break\n\n        # Model is used to predict the test data so we are switching off the gradient\n\n        with torch.no_grad():\n\n            data = data.to(device)\n            target = target.long().to(device)\n            output = model_ft(data)\n            criterion = nn.CrossEntropyLoss()\n            loss = criterion(output, target)\n\n            # Note that optimizer is not used because the model shouldn't learn the test dataset\n\n            for i in range(BATCH_SIZE):\n                a = []\n                for j in output[i]:\n                    a.append(float(j.detach()))\n\n                pred = a.index(max(a))\n\n                if pred == int(target[i]):\n                    correct = correct + 1\n\n                else:\n                    incorrect = incorrect + 1\n\n        test_loss.append(float(loss.detach()))\n    print(\"CORRECT: \" + str(correct), \"INCORRECT: \" + str(incorrect),\"TEST ACCURACY: \"+str(correct\/(correct+incorrect)))\n    return (\n            correct\/(incorrect+correct),\n            sum(test_loss)\/len(test_loss),\n    )\n\n\n\n","43849d94":"acc_ , loss_ = get_test()\nprint(\"ACCURACY AND LOSS BEFORE TUNING\")\nprint(\"ACCURACY : \"+str(acc_),\"LOSS : \"+str(loss_))","dce794f7":"avg_test_loss_history = []\navg_test_accuracy_history = []\navg_train_loss_history = []\navg_train_accuracy_history = []\n\nloss_history = []\naccuracy_history = []\n\nnew_best = 0\n\nfor i in range(EPOCHS):\n\n    start = time.time()\n    print(\n        \"-----------------------EPOCH \"\n        + str(i)\n        + \" -----------------------------------\"\n    )\n    for batch_idx, (data, target) in enumerate(train_loader):\n        if batch_idx == STEPS_PER_EPOCH:\n            break\n        optimizer.zero_grad()  # Resetting gradients after each optimizations\n        # Sending input , target to device\n        data = data.to(device) \n        target = target.to(device)\n        output = model_ft(data)\n        loss = criterion(output, target.reshape((BATCH_SIZE,)).long())\n        loss_history.append(loss.detach())\n        # The loss variable has gradient attached to it so we are removing it so that it can be used to plot graphs\n        loss.backward()\n        optimizer.step()  # Optimizing the model\n\n        # Checking train accuracy\n\n        correct = 0\n        incorrect = 0\n        for p in range(BATCH_SIZE):\n            a = []\n            for j in output[p]:\n                a.append(float(j.detach()))\n\n            pred = a.index(max(a))\n\n            if pred == int(target[p]):\n                correct = correct + 1\n\n            else:\n\n                incorrect = incorrect + 1\n\n        print(\n            \"\\r EPOCH \"\n            + str(i)\n            + \" MINIBATCH: \"\n            + str(batch_idx)\n            + \"\/\"\n            + str(STEPS_PER_EPOCH)\n            + \" LOSS: \"\n            + str(loss_history[-1]),\n            end = \"\"\n            \n        )\n        \n        accuracy_history.append(correct\/(correct+incorrect))\n\n    end = time.time()\n    print(\n        \" \\n EPOCH \"\n        + str(i)\n        + \" LOSS \"\n        + str(sum(loss_history[-STEPS_PER_EPOCH:]) \/ STEPS_PER_EPOCH)\n        + \" ETA: \"\n        + str(end - start)\n        + \" \\n MAX LOSS: \"\n        + str(max(loss_history[-STEPS_PER_EPOCH:]))\n        + \" MIN LOSS: \"\n        + str(min(loss_history[-STEPS_PER_EPOCH:]))\n        + \" TRAIN ACCURACY: \"\n        + str(sum(accuracy_history[-STEPS_PER_EPOCH:]) \/ STEPS_PER_EPOCH)\n    )\n    \n    avg_train_loss_history.append(sum(loss_history[-STEPS_PER_EPOCH:]) \/ STEPS_PER_EPOCH)\n    avg_train_accuracy_history.append(sum(accuracy_history[-STEPS_PER_EPOCH:]) \/ STEPS_PER_EPOCH)\n    \n    test_acc , test_loss  = get_test()\n    \n    avg_test_accuracy_history.append(test_acc)\n    avg_train_loss_history.append(test_loss)\n    \n    if test_acc>new_best: \n        new_best = test_acc\n        torch.save(model_ft.state_dict(), \"\/model.pth\") # Saving our best model\n","ea04735f":"print(\"ACCURACY : \",new_best)","8fbdbd6e":"plt.plot(avg_train_loss_history,label = \"Train\")\nplt.plot(avg_test_loss_history , label = \"Test\")\nplt.title('LOSS PER EPOCH')\nplt.xlabel(\"EPOCHS\")\nplt.ylabel(\"LOSS\")","10d44196":"plt.plot(loss_history)\nplt.title('LOSS PER BATCH')\nplt.xlabel(\"BATCH\")\nplt.ylabel(\"LOSS\")\nplt.show()","d6daee16":"plt.plot(avg_train_accuracy_history , label = \"Train\")\nplt.plot(avg_test_accuracy_history , label = \"Test\")\nplt.title('ACCURACY PER EPOCH')\nplt.xlabel(\"EPOCHS\")\nplt.ylabel(\"ACCURACY\")","3fdb800e":"The difference can be seen with different visualizations below","eab4a762":"#### Plotting the accuracy produced by model during training","da588f75":"Adam is an optimization algorithm that can be used instead of the classical stochastic gradient descent procedure to update network weights iterative based in training data.\n\nThe authors describe Adam as combining the advantages of two other extensions of stochastic gradient descent. Specifically:\n\n1.    Adaptive Gradient Algorithm (AdaGrad) that maintains a per-parameter learning rate that improves performance on problems with sparse gradients (e.g. natural language and computer vision problems).\n2.    Root Mean Square Propagation (RMSProp) that also maintains per-parameter learning rates that are adapted based on the average of recent magnitudes of the gradients for the weight (e.g. how quickly it is changing). This means the algorithm does well on online and non-stationary problems (e.g. noisy).\n","f27797ef":"## **Initializing optimizers and loss function** <br\/>\nWe will also specify the learning rate of the optimiser, here in this case it is set at 0.0001. If our training is bouncing a lot on epochs then we need to decrease the learning rate so that we can reach global minima.","fb4e6581":"ResNet, short for Residual Networks is a classic neural network used as a backbone for many computer vision tasks. This model was the winner of ImageNet challenge in 2015. The fundamental breakthrough with ResNet was it allowed us to train extremely deep neural networks with 150+layers successfully. Prior to ResNet training very deep neural networks was difficult due to the problem of vanishing gradients.\nHowever, increasing network depth does not work by simply stacking layers together. Deep networks are hard to train because of the notorious vanishing gradient problem \u2014 as the gradient is back-propagated to earlier layers, repeated multiplication may make the gradient extremely small. As a result, as the network goes deeper, its performance gets saturated or even starts degrading rapidly.","9a54b9d1":"vgg16 pre-trained models expect input images normalized in the same way, i.e. mini-batches of 3-channel RGB images of shape (3 x H x W), where H and W are expected to be at least 224.<br \/>\nThe images have to be loaded in to a range of [0, 1] and then normalized using:\n #### mean = [0.485, 0.456, 0.406] and std = [0.229, 0.224, 0.225] <br \/>\n \n We are applying augmentation like random rotation , horizontal and vertical flips to make sre the model doesn't overfit or learn the wrong features\n ","084230df":"#### **Initializing the data loader** ","e33b4787":"#### **Visualizing test dataset** ","fbc97090":"# **CoronaHack - Fine tuning resnet18 pre-trained model with Pytorch**\n\n#### We will be analysing the train dataset and fine tuning a pre-trained model","198b2880":"#### **Visualizing train dataset** ","28695fd6":"#### **TESTING THE MODEL** ","e4a46486":"## **Initializing pretrained resnet18 model** \n\n","80261eb1":"## **Exploring train dataset** \n\nWhenever you see an area of increased density within the lung, it must be the result of one of these four patterns.\n\n1.   **Consolidation ** - any pathologic process that fills the alveoli with fluid, pus, blood, cells (including tumor cells) or other substances resulting in lobar, diffuse or multifocal ill-defined opacities.\n\n2.   **Interstitial ** - involvement of the supporting tissue of the lung parenchyma resulting in fine or coarse reticular opacities or small nodules.\n\n3.   **Nodule or mass** - any space occupying lesion either solitary or multiple.\n\n4.   **Atelectasis** - collapse of a part of the lung due to a decrease in the amount of air in the alveoli resulting in volume loss and increased density.\n\n<img src=\"https:\/\/www.mayoclinic.org\/-\/media\/kcms\/gbs\/patient-consumer\/images\/2013\/08\/26\/10\/01\/ds00135_im00621_pnuesmal_gif.png\" width=\"450px\">\n\n","3fa33b53":"#### **Moving train dataset to designated directory** \n\n#### We will move the images used for training and testing by reading the 'Chest_xray_Corona_Metadata.csv' which contains the information about each image.We will split the dataset into images which are mapped with label normal as one class and the labels mapped with Pneumonia as infected","a4868599":"#### **Exploring train dataset** ","4c61895b":"We have saved the model with best accuracy as **model.pt**","417d2618":"This model was able to produce about 90 to 95% accuracy in different runs. This inconsistent result is due to model's random weight and bias initialization.Code to run in Google colab can be found [here](https:\/\/github.com\/FrozenWolf-Cyber\/Corona-Detection\/blob\/master\/CoronaHack_Finetuning_resnet18_pytorch.ipynb).You can also checkout tuning of pre-trained vgg16 model with pneumonia dataset [here](https:\/\/github.com\/FrozenWolf-Cyber\/Pneumonia-Detection)","5ed1f360":"<img src=\"https:\/\/d2l.ai\/_images\/residual-block.svg\" width=\"500px\">\n\n\n","c89a5b26":"#### Plotting the loss produced by model during training","9cfe7ece":"#### **Downloading Dataset from Kaggle (Optional)** ","8fc79190":"#### **Moving test dataset to designated directory** ","a1955c10":"#### **TUNING THE MODEL (TRAINING)** "}}