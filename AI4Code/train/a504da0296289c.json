{"cell_type":{"e36b1ae3":"code","013d7dfa":"code","aa0a48c6":"code","9cf2b41e":"code","e6e5219b":"code","c7bfa46c":"code","78cf7e29":"code","2c592512":"code","bbe0a77c":"code","1e2160f5":"markdown","ce371285":"markdown","3a3246a9":"markdown","56335be3":"markdown","e24510c0":"markdown"},"source":{"e36b1ae3":"import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport numpy as np\n\nimg = mpimg.imread('..\/input\/images\/Injila.jpg')\nimg.shape","013d7dfa":"plt.imshow(img)","aa0a48c6":"from operator import add\nfrom functools import reduce\n\ndef split4(image):\n    half_split = np.array_split(image, 2)\n    res = map(lambda x: np.array_split(x, 2, axis=1), half_split)\n    return reduce(add, res)\n\nsplit_img = split4(img)\nsplit_img[0].shape","9cf2b41e":"fig, axs = plt.subplots(2, 2)\naxs[0, 0].imshow(split_img[0])\naxs[0, 1].imshow(split_img[1])\naxs[1, 0].imshow(split_img[2])\naxs[1, 1].imshow(split_img[3])","e6e5219b":"def concatenate4(north_west, north_east, south_west, south_east):\n    top = np.concatenate((north_west, north_east), axis=1)\n    bottom = np.concatenate((south_west, south_east), axis=1)\n    return np.concatenate((top, bottom), axis=0)\n\nfull_img = concatenate4(split_img[0], split_img[1], split_img[2], split_img[3])\nplt.imshow(full_img)\nplt.show()","c7bfa46c":"def calculate_mean(img):\n    return np.mean(img, axis=(0, 1))\n\nmeans = np.array(list(map(lambda x: calculate_mean(x), split_img))).astype(int).reshape(2,2,3)\nprint(means)\nplt.imshow(means)\nplt.show()","78cf7e29":"def checkEqual(myList):\n    first=myList[0]\n    return all((x==first).all() for x in myList)\n\nclass QuadTree:\n    \n    def insert(self, img, level = 0):\n        self.level = level\n        self.mean = calculate_mean(img).astype(int)\n        self.resolution = (img.shape[0], img.shape[1])\n        self.final = True\n        \n        if not checkEqual(img):\n            split_img = split4(img)\n            \n            self.final = False\n            self.north_west = QuadTree().insert(split_img[0], level + 1)\n            self.north_east = QuadTree().insert(split_img[1], level + 1)\n            self.south_west = QuadTree().insert(split_img[2], level + 1)\n            self.south_east = QuadTree().insert(split_img[3], level + 1)\n\n        return self\n    \n    def get_image(self, level):\n        if(self.final or self.level == level):\n            return np.tile(self.mean, (self.resolution[0], self.resolution[1], 1))\n        \n        return concatenate4(\n            self.north_west.get_image(level), \n            self.north_east.get_image(level),\n            self.south_west.get_image(level),\n            self.south_east.get_image(level))","2c592512":"quadtree = QuadTree().insert(img)","bbe0a77c":"plt.imshow(quadtree.get_image(1))\nplt.show()\nplt.imshow(quadtree.get_image(3))\nplt.show()\nplt.imshow(quadtree.get_image(7))\nplt.show()\nplt.imshow(quadtree.get_image(10))\nplt.show()","1e2160f5":"## Calculate the mean\n\nCalculate the mean of all the parts of the split.","ce371285":"## Split Image in 4\n\nA big part of how the algorithm works is splitting the image into 4 quarters and calculate the mean color of each part to create a level of the tree. Let's split Split in 4 and calculate the mean color of each quarter.","3a3246a9":"# QuadTree\n\n### QuadTree from Images\n\nThe main objective is to generate a quad tree from an image and display it.","56335be3":"## Reconstruct The Full Image from The Split\nThis will be useful when we want to display the image back, as the quadtree will store the images split into 4","e24510c0":"## QuadTree Data Structure\n\nNow let's create a data structure that will allow us to construct our quad tree. It's a recursive calculation."}}