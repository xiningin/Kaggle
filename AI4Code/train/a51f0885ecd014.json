{"cell_type":{"5dd291f7":"code","44b41a2d":"code","e155570a":"code","ec05b44e":"code","f23e4817":"code","90ead68a":"code","e83ff416":"code","40c7c672":"code","14332532":"markdown","6882be74":"markdown","d8402521":"markdown","f95aec62":"markdown","c603e0d1":"markdown","cd3dcc8c":"markdown","5ac464a9":"markdown","6232c5ce":"markdown","bdd72538":"markdown"},"source":{"5dd291f7":"import numpy as np\nimport pennylane as qml\n\nfrom pennylane import expval, var\nfrom matplotlib import pyplot as plt\n","44b41a2d":"pi = np.pi\ndef initialize_theta(layers):\n    row = layers*2\n    column = 4\n    theta = np.random.uniform(low=0, high=2*pi, size=(row, column))\n    \n    \n    return theta","e155570a":"# This function returns a random valued numpy array phi, with respect to which cost of the quantum circuit will be calculated\n# dimension of phi will be same as the dimension of np array returned by make_circuit() \ndef initialize_random_phi():\n    phi = np.random.randn(16,)\n    return phi","ec05b44e":"def simulate_circuit(theta):\n    dev = qml.device(\"default.qubit\", wires=4)\n\n    @qml.qnode(dev)\n    def circuit(theta):\n    #This make_circuit function genrates the quantum circuit. It takes only the parameters theta as the argument\n    #The no. of layers has not to be passed explicitely, as it is calculated from dimension of theta\n\n\n        layers = theta.shape[0] \/\/ 2\n\n        for i in range(layers):\n\n            # yellow block\n            for j in range(4): #This loops over all four qubits and apply RX gate with proper param extracted from theta\n                qml.RX(theta[2*i][j], wires=j)\n\n            # Green block\n            for j in range(4): #THis loops over all 4 qubits and apply RZ gate with proper param extracted from theta\n                qml.RZ(theta[(2*i)+1][j], wires=j)\n\n            for control in range(3): # Double qubit CZ gates has been applied here\n                for target in range(control+1, 4):\n                    qml.CZ(wires=[control, target])\n\n\n        return qml.expval(qml.PauliZ(wires=0)),  qml.expval(qml.PauliZ(wires=1)), qml.expval(qml.PauliZ(wires=2)), qml.expval(qml.PauliZ(wires=3))\n       \n    circuit(theta)\n    \n    #returns the 2^4 = 16 dimensioned output statevector of the simulated circuit\n    return dev.state","f23e4817":"# This function takes the theta, calls the make_circuit() func and calculates the cost of vector returned \n# by the make_circuit() with respect to global variable psi\ndef calc_distance(theta):\n    \n    psi_of_theta = simulate_circuit(theta) \n    diff = psi_of_theta - phi #phi is the global one here, used for all the layers\n    mod_sqr = diff.real**2 + diff.imag**2\n    distance = np.sum(mod_sqr) #calculates the sum of squares of corresponding vector elements of psi and phi\n    \n    # returns the cost (mentioned as 'distance' in problem statement)\n    return distance","90ead68a":"# this takes param of the circuit, iteratioin and eta as necessary arguments\n# also two optional args to print and plot the cost for each layer count\ndef optimize(theta, iterations, print_distance=False, plot_distance=False):\n    \n    \n    distance_hist = [] #keeps track of cost after each iterations\n    \n    optimizer = qml.optimize.RotosolveOptimizer() \n    \n    # callback: this flag is initialized to keep track of repeating costs, which is further used to terminate the iteration\n    # when optimization is completed approx\n    flag = 0\n    \n    print(\"Optimizing\", end='')\n    \n    for i in range(iterations): \n        theta = optimizer.step(calc_distance, theta)\n        distance = calc_distance(theta) #calls the ampltude() to calculate cost of the circuit\n        print('.', end='')\n        \n        # this code chunk is used to compare current cost with the previous one to check repetations\n        if(len(distance_hist)>0):\n            if(round(distance_hist[-1],2)==round(distance,2)): #here upto 2 decimal places round off has been done\n                flag += 1\n            else:\n                flag = 0\n        distance_hist.append(distance)\n        if(print_distance):\n            print(\"Iteration=> \"+str(i)+\", distance=> \"+str(distance))\n        \n        # Whenever flag becomes 3, means 3 times same cost has been calculated, we can assume the params to be\n        # optimized and can terminate the gradient descent\n        if(flag == 3):\n            break\n    \n    print('\\nOptimization Completed')\n        \n        \n    if(plot_distance):\n        plt.style.use(\"seaborn\")\n        plt.plot(distance_hist, \"b\", label=\"Optimization\")\n        plt.ylabel(\"Distance value\")\n        plt.xlabel(\"Optimization steps\")\n        plt.legend()\n        plt.show()\n    \n    #returns the final_cost, maximum iteration used and optimized parameter values\n    cache = {\"min_distance\": distance_hist[-1],\n             \"iter\": i+1,\n             \"optimized_theta\": theta}\n    \n    return cache","e83ff416":"# main function\n\nphi = initialize_random_phi() #initialized a vector phi as a referenc of cost for the whole process\niter_list = [] # it will store no. of iterations used for each no. of layers\nmin_distance_list = [] # it will store the final cost of circuit for each no. of layers\noptimized_theta_list = [] #similarly stores the optimized params for each no. of layers\n\nmax_layers = 15 # so we will start from a single layer circuit and go upto 30 layers circuit\n\n\nfor layers in range(1,max_layers+1):\n    print(\"\\n\\n Layer count in Circuit => \"+str(layers))\n    theta = initialize_theta(layers) #initializes random theta values which will be optimized further\n    \n    # calls the optimize() function which will first create a circuit with the passed theta values \n    # then optimize the parameters using RotosolveOptimizer() algorithm and finally returns min_distance, iteration used and optimized params\n    # although the iteration is initialized as 50, if it fulfils the callback condition, it will be terminated\n    cache = optimize(theta, 50) \n    \n    iter_list.append(cache['iter'])\n    min_distance_list.append(cache['min_distance'])\n    \n    print(\"\\n Iteration used => \"+str(cache['iter']))\n    print(\" Minimum distance => \"+str(cache['min_distance']))\n    print(\"\\n_______________________________________\")\n    print(\"_______________________________________\")\n    \n\n","40c7c672":"# plots final cost as a function of no. of layers used in the circuit\nplt.style.use(\"seaborn\")\nplt.plot(np.arange(1,max_layers+1),min_distance_list, \"b\")\nplt.ylabel(\"Minimum distance\")\nplt.xlabel(\"No. of layers\")\n#plt.ylim(0,0.1)\nplt.title(\"Final cost as a function of no. of layers\")\nplt.show()\n\n# plots he maximum iterations used as a function of no. of layers in the specific circuit\nplt.plot(np.arange(1,max_layers+1),iter_list, \"g\")\nplt.ylabel(\"Iteration used\")\nplt.xlabel(\"No. of layers\")\nplt.title(\"Total no. of iterations used as a function of no. of layers\")\nplt.show()","14332532":"## initialize_random_phi()\n#### Arguments - no args is passed\n#### as the phi is used as reference with the circuit output, it returns an numpy array having same dimension of statevector returned by the circuit\n#### Since the circuit has 4 wires, statevector will have 2^4 or 16 elements","6882be74":"## simulate_circuit()\n#### Arguments - the numpy array containing all the parameters for each gate\n#### Creates a object of device class using required attributes\n#### calls the circuit() function defined inside it to generate the specific circuit using paramaters passed\n#### Return - returns the output statevector of the simulated circuit using dev.state","d8402521":"## initialize_theta()\n#### Arguments - only a single arg, no. of layers in the circuit\n#### It randomly generates a numpy array having (layers X 2) no. of rows and 4 columns\n#### Each element in the np array is a theta value for a parameterized gate ranging from (0,2pi)\n#### Return - numpy array","f95aec62":"## Three lists initialized below will store various data returned by each circuit simulated.\n\n## Finally looped over all the circuit starting from 1 to max_layers=15, initialized random parameter values, calls the optimize function to optimize the parameters to get minimum value of distance\n## finally prints some information about each circuit after optimization - minimum distance and no. of iteration used.","c603e0d1":"## calc_distance()\n#### Arguments - takes only the numpy array containing parameters for all parameterized gates in the circuit\n#### it calls the function simulate_circuit(), which returns the statevector psi_of_theta\n#### now it calculates the difference of psi_of_theta and phi (phi has been initialized globally and used the same for all the circuit in this notebook)\n#### Finally the sum of square of mod of all 16 complex numbers has been calculated \n#### Return - a single float value which is calculated, mentioned above","cd3dcc8c":"## The block below executes to do all the necessary imports","5ac464a9":"## optimize()\n#### Arguments - np array of all parameters, maximum no. of iteration used and two optional boolean parameters- print_distance, plot_distance\n#### *Imp. point to note - although iteration is passed as a parameter in the function, but there is a callback used below, which terminates the optimization when three consecutive calculated distance is same(upto 2 decimal places) considering the fact that minimum distance has been achieved*\n#### the RotosolveOptimizer available in pennylane has been used here to optimize the parameters to get the minimum distance for each circuit\n#### while calling the function, is print_distance is set as True, it prints the distance calculated in each iteration\n#### if the plot_distance is also set True, it will plot the calculated distance vs iteration after the optimization of a specific circuit is completed\n#### Returns - a dict containing minimum_distance calculated after the optimization, no. of iteration used and optimized parameters value","6232c5ce":"# **Task-1**\n\n### Information about this notebook\n\n##### 1. Optimization has been done starting from circuit with 1 layer upto circuit with 15 layers.\n##### 2. Finally the minimum distance in the circuit has been plotted as a function of no. of layers used in that circuit.\n##### 3. Also the no. of iteration used is also plotted as a function of no. of layers.\n\n### Note - In this notebook, all the circuits has been put together by looping over the no. of layers, and finally overall plots has been shown (no seperate plot for each circuit has been shown here). \n### In the another notebook, seperate cells has been dedicated for each circuit and finally in the last part, information like minimum distance from all circuits has been put together and plotted.","bdd72538":"# Final Plot 1 - Plot of Minimum distance as a function of no. of layers used in the circuit\n\n# Points to observe - \n## 1. In the plot below, starting from the circuit having 6 layers, upto the last i.e. 15 layers, the minimum distance has become very close and from layers 10 it became same approximately.\n## 2. Also from each specific circuit to the next circuit, minimum distance has been decreased.\n\n\n# Plot 2 - Plot of iteration as a function of no. of layers used in the circuit\n\n## Although we have specified the no. of iterations while calling the optimize() function, but due the callback, earlystopping has occured in almost all cases. \n## The no. of iteration used has also been placed as a function of layers in the circuit."}}