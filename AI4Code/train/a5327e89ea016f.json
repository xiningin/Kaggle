{"cell_type":{"71db81c0":"code","85785c28":"code","f5b5d7e1":"code","6c71ed3d":"code","3d6663e3":"code","0c4debb5":"code","bff8e533":"code","a97b4ce1":"code","a1118162":"code","8fadca95":"code","e58eaa52":"code","ebd6e77c":"code","2980dba2":"code","1f7b648b":"code","d5cef597":"code","0018241c":"code","72e7a7ca":"code","9a187515":"code","92f4ac88":"code","ec9ffc83":"code","02c8ed8e":"code","f435b2c9":"code","8226a323":"code","a6da12f0":"code","0d3addec":"code","6d028bbc":"code","d9d0c3ac":"code","ea8ff03c":"code","bb61a959":"code","721a5c55":"code","3af33ce8":"code","67ace9ab":"code","da48f28d":"code","748b92c5":"code","78b9fdff":"code","0674dee6":"code","a449c466":"markdown","3031a4bc":"markdown"},"source":{"71db81c0":"import numpy as np\nimport pandas as pd\nimport gc\nimport os\nimport random\nimport matplotlib.pyplot as plt","85785c28":"train = pd.read_csv('..\/input\/ventilator-pressure-prediction\/train.csv')\ntest = pd.read_csv('..\/input\/ventilator-pressure-prediction\/test.csv')\n\ntrain['dcount'] = train.groupby('breath_id')['id'].transform('cumcount')\ntest['dcount'] = test.groupby('breath_id')['id'].transform('cumcount')\n\ntrain['uo'] = 80 - train.groupby('breath_id')['u_out'].transform('sum')\ntest['uo'] = 80 - test.groupby('breath_id')['u_out'].transform('sum')\n\ntrain['time_delta'] = (train['time_step'] - train.groupby('breath_id')['time_step'].shift(1)).fillna(0)\ntest['time_delta'] = (test['time_step'] - test.groupby('breath_id')['time_step'].shift(1)).fillna(0)\n\nprint(train.shape)\ntrain.head()","f5b5d7e1":"oof = pd.read_csv('..\/input\/ventmodels\/train-blend-1.csv')\noof.columns = ['id', 'pred']\ntrain = train.merge(oof, on='id', how='left')\ntrain","6c71ed3d":"oof = pd.read_csv('..\/input\/ventmodels\/1336_submission.csv')\noof.columns = ['id', 'pred']\ntest = test.merge(oof, on='id', how='left')\ntest","3d6663e3":"train['error'] = (train['pressure'] - train['pred']).abs()\ntrain.loc[train.u_out>0,'error'] = 0\ntrain.loc[train.u_out==0,'error'].hist(bins=20)","0c4debb5":"maxdrift = train.loc[train.u_out==0,'error'].mean() + 3*train.loc[train.u_out==0,'error'].std()\nmaxdrift","bff8e533":"p_coef = [0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ni_coef = [0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nsetpoints = [10, 15, 20, 25, 30, 35]","a97b4ce1":"unique_pressures = train['pressure'].round(decimals=7).unique()\nunique_pressures = list(np.sort(unique_pressures))\nlen(unique_pressures), unique_pressures[:10]","a1118162":"maxdrift \/ (unique_pressures[1]-unique_pressures[0])","8fadca95":"max_pressure = 64.82099173863328\nmin_pressure = -1.895744294564641\ndiff_pressure = 0.0703021454512","e58eaa52":"def generate_u_in(pressure, time_step, kp, ki, kt, integral=0):\n    dt = np.diff(time_step, prepend=[0])\n    preds = []\n    for j in range(32):\n        error = kt - pressure[j]\n        integral += (error - integral) * (dt[j] \/ (dt[j] + 0.5))\n        preds.append(kp * error + ki * integral)\n    return preds\n\npressure = train[train['breath_id'] == 1]['pressure'].values \ntimestep = train[train['breath_id'] == 1]['time_step'].values\nu_in = generate_u_in(pressure, timestep, 0.8, 8.0, 20)\nnoise = train[train['breath_id'] == 1]['u_in'].values[:32] - u_in\n\nplt.figure()\nplt.plot(timestep[:32], train[train['breath_id'] == 1]['u_in'].values[:32], label='u_in')\nplt.plot(timestep[:32], u_in, label='u_in_hat')\nplt.legend()\nplt.show()","ebd6e77c":"# Ps = train['pressure'].unique()\n# Ps = np.sort(Ps)\n# P1s = Ps\n# P2s = Ps[:, None]\n# PDiff = P1s-P2s\n\n# def fill_gaps_b(kp, ki, kt, u_in, dts):\n#     us = np.zeros(80, dtype='float64') - 9\n#     preds = np.zeros(80, dtype='float64') - 9\n#     match = 0\n#     for j in range(32):\n#         u1, u2 = u_in[j], u_in[j+1]\n#         ki2 = ki * dts[j+1] \/ (0.5 + dts[j+1])\n#         u2_hat= u1+kp*PDiff + ki2*(kt-P2s-(u1-kp*(kt-P1s))\/ki)\n#         m = np.abs(u2 - u2_hat) <= 1e-7\n#         if np.any(m):\n#             us[j+1] = u2\n#             if preds[j + 1] == -9:\n#                 match += 1\n#                 pos = np.where(m)[0][0]\n#                 preds[j+1] = P2s[pos]\n#     return preds, match\n\n# pressure = train[train['breath_id'] == 1]['pressure'].values.copy()\n# timestep = train[train['breath_id'] == 1]['time_delta'].values.copy()\n# u_in = train[train['breath_id'] == 1]['u_in'].values.copy()\n# plt.plot(pressure[:32])\n\n# for P in p_coef:\n#     for I in i_coef:\n#         for SP in setpoints:\n#             res, match = fill_gaps_b(P, I, SP, u_in, timestep )\n#             if match>16:\n#                 print(match, P, I, SP)","2980dba2":"# Ps = train['pressure'].unique()\n# Ps = np.sort(Ps)\n# P1s = Ps\n# P2s = Ps[:, None]\n# PDiff = P1s-P2s\n\n# def fill_gaps_b(kp, ki, kt, u_in, dts, ypred):\n#     us = np.zeros(80, dtype='float64') - 9\n#     preds = np.zeros(80, dtype='float64') - 9\n#     match = 0\n#     for j in range(1,32):\n#         u1, u2 = u_in[j], u_in[j+1]\n#         ki2 = ki * dts[j+1] \/ (0.5 + dts[j+1])\n#         vmin = np.min(ypred[j:j+2])\n#         vmax = np.max(ypred[j:j+2])\n#         pi = np.clip(vmin - 2.0, min_pressure, max_pressure)\n#         pe = np.clip(vmax + 2.0, min_pressure, max_pressure)\n#         pi = np.sum(Ps<=pi)\n#         pe = np.sum(Ps<=pe)\n#         u2_hat= u1 + kp*PDiff[pi:pe, pi:pe] + ki2*(kt-P2s[pi:pe]-(u1-kp*(kt-P1s[pi:pe]))\/ki)\n#         #print(u2.shape, u2_hat.shape)\n#         m = np.abs(u2 - u2_hat) <= 1e-7\n#         if np.any(m):\n#             #print('hit')\n#             us[j+1] = u2\n#             if preds[j + 1] == -9:\n#                 match += 1\n#                 pos = np.where(m)[0][0]\n#                 preds[j+1] = P2s[pi+pos]\n            \n        \n#     return preds, match\n","1f7b648b":"# train['breath_id'].unique()","d5cef597":"# def match_breath(u_in, u_out, timestep, kp, ki, kt):\n#     dt = np.diff(timestep)\n#     dt2 = dt \/ (dt + 0.5)\n#     in_len = np.sum(1 - u_out)\n#     preds = np.zeros(len(u_in)) - 999\n    \n#     for t in range(1, in_len):\n#         # If we had a match in previous timestep, we can re-use that match\n#         if preds[t - 1] != -999:\n#             P0 = preds[t - 1]\n#         else:\n#             P0 = np.arange(MIN_PRESSURE, MAX_PRESSURE + DIFF_PRESSURE, DIFF_PRESSURE)\n            \n#         I0 = (u_in[t - 1] - kp * (kt - P0))\/ki\n\n#         # Calculate 2 points for our P1\n#         I11 = I0 + (kt - MIN_PRESSURE - I0) * dt2[t-1]\n#         u_in_hat1 = kp * (kt - MIN_PRESSURE) + ki * I11\n\n#         I12 = I0 + (kt - MIN_PRESSURE2 - I0) * dt2[t-1]\n#         u_in_hat2 = kp * (kt - MIN_PRESSURE2) + ki * I12\n\n#         # Get slope and intersection point\n#         slope = u_in_hat2 - u_in_hat1\n#         x_intersect = (u_in[t] - u_in_hat2) \/ slope\n        \n#         # We want the intersection to be an integer\n#         diff = np.abs(np.round(x_intersect) - x_intersect)\n        \n#         if diff.min() < 1e-10:\n#             pos = np.argmin(diff)\n            \n#             if preds[t - 1] == -999:\n#                 preds[t - 1] = P0[np.argmin(diff)]\n#                 preds[t] = MIN_PRESSURE + int(x_intersect[pos] + 1) * DIFF_PRESSURE\n#             else:\n#                 preds[t] = MIN_PRESSURE + (np.round(x_intersect) + 1) * DIFF_PRESSURE\n            \n#     return preds","0018241c":"# i = 1\n# pressure = train[train['breath_id'] == i]['pressure'].values.copy()\n# timestep = train[train['breath_id'] == i]['time_delta'].values.copy()\n# u_in = train[train['breath_id'] == i]['u_in'].values.copy()\n# ypred = train[train['breath_id'] == i]['pred'].values.copy()","72e7a7ca":"# %%timeit\n# res, match = fill_gaps_b(1, 8, 20, u_in, timestep, ypred )","9a187515":"MAX_PRESSURE  = PRESSURE_MAX  = 64.82099173863328\nMIN_PRESSURE  = PRESSURE_MIN  = -1.895744294564641\nDIFF_PRESSURE = PRESSURE_STEP = 0.0703021454512\nMIN_PRESSURE2 = PRESSURE_MIN2 = MIN_PRESSURE + DIFF_PRESSURE\n\ndef match_breath(u_in, u_out, timestep, kp, ki, kt):\n    dt = np.diff(timestep)\n    dt2 = dt \/ (dt + 0.5)\n    in_len = np.sum(1 - u_out)\n    preds = np.zeros(len(u_in)) - 999\n    \n    match=0\n    for t in range(1, in_len):\n        # If we had a match in previous timestep, we can re-use that match\n        if preds[t - 1] != -999:\n            P0 = preds[t - 1]\n        else:\n            P0 = np.arange(MIN_PRESSURE, MAX_PRESSURE + DIFF_PRESSURE, DIFF_PRESSURE)\n            \n        I0 = (u_in[t - 1] - kp * (kt - P0))\/ki\n\n        # Calculate 2 points for our P1\n        I11 = I0 + (kt - MIN_PRESSURE - I0) * dt2[t-1]\n        u_in_hat1 = kp * (kt - MIN_PRESSURE) + ki * I11\n\n        I12 = I0 + (kt - MIN_PRESSURE2 - I0) * dt2[t-1]\n        u_in_hat2 = kp * (kt - MIN_PRESSURE2) + ki * I12\n\n        # Get slope and intersection point\n        slope = u_in_hat2 - u_in_hat1\n        x_intersect = (u_in[t] - u_in_hat2) \/ slope\n        \n        # We want the intersection to be an integer\n        diff = np.abs(np.round(x_intersect) - x_intersect)\n        \n        if diff.min() < 1e-10:\n            match+=1\n            pos = np.argmin(diff)\n            \n            if preds[t - 1] == -999:\n                preds[t - 1] = P0[np.argmin(diff)]\n                preds[t] = MIN_PRESSURE + int(x_intersect[pos] + 1) * DIFF_PRESSURE\n            else:\n                preds[t] = MIN_PRESSURE + (np.round(x_intersect) + 1) * DIFF_PRESSURE\n            \n    return preds, match","92f4ac88":"i = 1\npressure = train[train['breath_id'] == i]['pressure'].values.copy()\ntimestep = train[train['breath_id'] == i]['time_step'].values.copy()\nu_in = train[train['breath_id'] == i]['u_in'].values.copy()\nu_out = train[train['breath_id'] == i]['u_out'].values.copy()\nypred = train[train['breath_id'] == i]['pred'].values.copy()","ec9ffc83":"%%time\nres, match = match_breath(u_in, u_out, timestep, 1, 8, 20)","02c8ed8e":"import time\n# starttime = time.time()\n# count = 0\n# for i in train['breath_id'].unique()[:10]:\n#     count += 1\n#     pressure = train[train['breath_id'] == i]['pressure'].values.copy()\n#     timestep = train[train['breath_id'] == i]['time_step'].values.copy()\n#     u_in = train[train['breath_id'] == i]['u_in'].values.copy()\n#     u_out = train[train['breath_id'] == i]['u_out'].values.copy()\n#     ypred = train[train['breath_id'] == i]['pred'].values.copy()\n#     match = 0\n#     for P in p_coef:\n#         for I in i_coef:\n#             for SP in setpoints:\n#                 res, match = match_breath(u_in, u_out, timestep, P, I, SP)\n#                 if match>24:\n#                     print(i, count, match, P, I, SP, (time.time()-starttime), (time.time()-starttime)\/count )\n#                     break\n#             if match>24:\n#                 break\n#         if match>24:\n#             break   \n#     print((time.time()-starttime)\/count)\n# #1 1 28 0.8 8 20 2.3033382892608643 2.3033394813537598","f435b2c9":"# %%time\n# import time\n# starttime = time.time()\n# count = 0\n# for i in train['breath_id'].unique()[:4]:\n#     count += 1\n#     pressure = train[train['breath_id'] == i]['pressure'].values.copy()\n#     timestep = train[train['breath_id'] == i]['time_delta'].values.copy()\n#     u_in = train[train['breath_id'] == i]['u_in'].values.copy()\n#     ypred = train[train['breath_id'] == i]['pred'].values.copy()\n#     match = 0\n#     for P in p_coef:\n#         for I in i_coef:\n#             for SP in setpoints:\n#                 res, match = fill_gaps_b(P, I, SP, u_in, timestep, ypred )\n#                 if match>24:\n#                     print(i, count, match, P, I, SP, (time.time()-starttime), (time.time()-starttime)\/count )\n#                     break\n#             if match>24:\n#                 break\n#         if match>24:\n#             break   \n#     print()","8226a323":"# %%time\n# import time\n# starttime = time.time()\n# count = 0\n# for i in train['breath_id'].unique():\n#     count += 1\n#     pressure = train[train['breath_id'] == i]['pressure'].values.copy()\n#     timestep = train[train['breath_id'] == i]['time_delta'].values.copy()\n#     u_in = train[train['breath_id'] == i]['u_in'].values.copy()\n#     ypred = train[train['breath_id'] == i]['pred'].values.copy()\n#     match = 0\n#     for P in p_coef:\n#         for I in i_coef:\n#             for SP in setpoints:\n#                 res, match = fill_gaps_b(P, I, SP, u_in, timestep, ypred )\n#                 if match>24:\n#                     print(i, count, match, P, I, SP, (time.time()-starttime), (time.time()-starttime)\/count )\n#                     break\n#             if match>24:\n#                 break\n#         if match>24:\n#             break   \n#     print()","a6da12f0":"starttime = time.time()\n\nPIDTEST = []\ncount = 0\nfor i in test['breath_id'].unique()[:1000]:\n    count += 1\n    ids = test[test['breath_id'] == i]['id'].values.copy()\n    timestep = test[test['breath_id'] == i]['time_step'].values.copy()\n    u_in = test[test['breath_id'] == i]['u_in'].values.copy()\n    u_out = test[test['breath_id'] == i]['u_out'].values.copy()\n    #ypred = test[test['breath_id'] == i]['pred'].values.copy()\n    match = 0\n    for P in p_coef:\n        for I in i_coef:\n            for SP in setpoints:\n                res, match = match_breath(u_in, u_out, timestep, P, I, SP)\n                if match>24:\n                    dt = pd.DataFrame({\n                        'id': ids,\n                        'breath_id': i,\n                        'P': P,\n                        'I': I,\n                        'SP': SP,\n                        'pressure': res,\n                    })                    \n                    PIDTEST.append(dt)\n                    print(i, count, match, P, I, SP, (time.time()-starttime), (time.time()-starttime)\/count )\n                    break\n            if match>24:\n                break\n        if match>24:\n            break\n            \nPIDTEST = pd.concat(PIDTEST).reset_index(drop=True)\nPIDTEST.shape","0d3addec":"# plt.plot(pressure[:32])\n# plt.plot(res[:32])","6d028bbc":"PIDTEST.to_csv('pid-test-1.csv', index=False)","d9d0c3ac":"# P  = proportional term\n# SP  = pressure set-point\n# for PID output: Pressure = (Setpoint - u_in) * P\n\nBIDtrain = []\nfor SP in setpoints:\n    for P in p_coef:\n        train['u_ctrl'] = ((SP - train['u_in']\/P)).round(decimals=7)\n        \n        #Check is results falls in any of the 950 train pressure values\n        train['isclass'] = 0\n        train.loc[train['u_ctrl'].isin(unique_pressures), 'isclass'] = 1\n        \n        dt = train.loc[(train.u_out==0)&(train.dcount>=1)].groupby('breath_id')[['isclass','uo']].agg({'isclass':'sum', 'uo':'first'}).reset_index().sort_values('isclass', ascending=False).reset_index(drop=True)\n        dt = dt.loc[dt['isclass']>=(dt['uo']-3)]\n        if dt.shape[0]>0:\n            print('matches:',dt.shape[0], 'P=',P, 'SP=', SP)\n            dt['P'] = P\n            dt['SP'] = SP\n            BIDtrain.append(dt)\n            \n\nBIDtrain = pd.concat(BIDtrain)\n#BIDtrain = BIDtrain.sort_values('error').reset_index(drop=True)\nprint(BIDtrain.shape)\nBIDtrain.head(10)","ea8ff03c":"# P  = proportional term\n# SP  = pressure set-point\n# for PID output: Pressure = (Setpoint - u_in) * P\n# Since testset doesn't have pressure, we know if the controller have the term P>0 and I==0, only if the results falls in any of the 950 different values of pressure found in train set.\n\nBIDtest = []\nfor SP in setpoints:\n    for P in p_coef:\n        test['u_ctrl'] = ((SP - test['u_in']\/P)).round(decimals=7)\n        \n        #Check is results falls in any of the 950 train pressure values\n        test['isclass'] = 0\n        test.loc[test['u_ctrl'].isin(unique_pressures), 'isclass'] = 1\n        \n        dt = test.loc[(test.u_out==0)&(test.dcount>=1)].groupby('breath_id')[['isclass','uo']].agg({'isclass':'sum', 'uo':'first'}).reset_index().sort_values('isclass', ascending=False).reset_index(drop=True)\n        dt = dt.loc[dt['isclass']>=(dt['uo']-3)]\n        if dt.shape[0]>0:\n            print('matches:',dt.shape[0], 'P=',P, 'SP=', SP)\n            dt['P'] = P\n            dt['SP'] = SP\n            BIDtest.append(dt)\n            \nBIDtest = pd.concat(BIDtest)\n#BIDtest = BIDtest.sort_values(['P', 'SP']).reset_index(drop=True)\nprint(BIDtest.shape)\nBIDtest.head(10)","bb61a959":"#for i in range(BIDtrain.shape[0]):\nfor i in range(10):\n    bid = BIDtrain.iloc[i]\n    P = bid.P\n    SP = bid.SP\n    tmp = train.loc[train.breath_id == bid.breath_id].copy()\n    tmp['u_ctrl'] =  (SP - tmp['u_in']\/P)\n    tmp.loc[(tmp.u_out==0)&(tmp.dcount>=0)].plot( x='time_step', y=['pressure', 'u_ctrl'], title = 'P='+str(P) + ' SP:'+str(SP) )","721a5c55":"#for i in range(BIDtest.shape[0]):\nfor i in range(10):\n    bid = BIDtest.iloc[i]\n    P = bid.P\n    SP = bid.SP\n    tmp = test.loc[test.breath_id == bid.breath_id].copy()\n    tmp['u_ctrl'] =  (SP - tmp['u_in']\/P)\n    tmp.loc[(tmp.u_out==0)&(tmp.dcount>=0)].plot( x='time_step', y=['u_ctrl'], title = 'P='+str(P) + ' SP:'+str(SP) )","3af33ce8":"test.head()","67ace9ab":"test = test.merge(BIDtest[['breath_id','P','SP']],on='breath_id',how='left')\ntest['pred'] = (test.SP - test['u_in']\/test.P).round(decimals=7)\ntest_ids = BIDtest.breath_id.values\n\ntmp = test.loc[(test.dcount>0)&(test.breath_id.isin(test_ids))]\ntmp","da48f28d":"sub = pd.read_csv('..\/input\/ventmodels\/Exp-102-ResBiLSTM-v2-CustomLoss-v1-AdamW-LogUin-30Fold-Seed2025-FineTune.csv')\n\nsub = sub.merge(tmp[['id','pred']],on='id',how='left')\n\nsub.loc[sub.pred.notna(),'pressure'] = sub.loc[sub.pred.notna(),'pred']\n\ndel sub['pred']\nsub","748b92c5":"tmp = pd.read_csv('pid-test-1.csv')\ntmp = tmp.loc[ tmp.pressure > - 999, ['id','pressure'] ].reset_index(drop=True)\ntmp.columns = ['id', 'pred']\ntmp.head()","78b9fdff":"sub = sub.merge(tmp[['id','pred']],on='id',how='left')\nsub.loc[sub.pred.notna(),'pressure'] = sub.loc[sub.pred.notna(),'pred']\n\ndel sub['pred']\nsub","0674dee6":"sub.to_csv('submission-postprocessing.csv', index=False)","a449c466":"- According the host paper https:\/\/arxiv.org\/pdf\/2102.06779.pdf, only the terms P and I were used in the PID simulations.\n- Hosts gives P, I and Setpoints used in appendinx A.2","3031a4bc":"- This notebook shows how is possible to calculate the output pressure given u_in for breath_ids, using only PID theory.\n- This notebook explores only PID terms: P > 0 and I = 0."}}