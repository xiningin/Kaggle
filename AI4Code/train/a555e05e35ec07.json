{"cell_type":{"4cccfbd1":"code","a72eda07":"code","40fc3039":"code","a0bf26ef":"code","a6a16b85":"code","abfd02e8":"code","17209141":"code","bc54c8f4":"code","4fbdef4c":"code","1bf5de32":"markdown"},"source":{"4cccfbd1":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","a72eda07":"print(__doc__)","40fc3039":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\nfrom sklearn import neighbors, datasets","a0bf26ef":"n_neighbour=5\n","a6a16b85":"irish=datasets.load_iris()","abfd02e8":"# we only take the first two features. We could avoid this ugly\n# slicing by using a two-dim dataset\nX=irish.data[:,:2]\ny=irish.target\n","17209141":"# step size in the mesh\nh=0.02","bc54c8f4":"# Create color maps\ncmap_light=ListedColormap(['orange','cyan','cornflowerblue'])\ncmap_bold=['darkorange','c','darkblue']","4fbdef4c":"for weights in ['uniform', 'distance']:\n    # we create an instance of Neighbours Classifier and fit the data.\n    clf=neighbors.KNeighborsClassifier(n_neighbour,weights=weights)\n    clf.fit(X,y)\n    \n    # Plot the decision boundary. For that, we will assign a color to each\n    # point in the mesh [x_min, x_max]x[y_min, y_max].\n    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n    \n    xx, yy=np.meshgrid(np.arange(x_min,x_max,h),np.arange(y_min, y_max,h))\n    Z=clf.predict(np.c_[xx.ravel(),yy.ravel()])\n    \n    # Put the result into a color plot\n    Z=Z.reshape(xx.shape)\n    plt.figure(figsize=(15,10))\n    plt.contourf(xx, yy,Z, cmap=cmap_light)\n    \n    # Plot also the training points\n    sns.scatterplot(x=X[:, 0], y=X[:, 1], hue=irish.target_names[y],\n                    palette=cmap_bold, alpha=1.0, edgecolor=\"black\")    \n    plt.xlim(xx.min(),xx.max())\n    plt.ylim(yy.min(), yy.max())\n    plt.title(\"3-Class Classification (k=%i, weights=%s)\" %(n_neighbour, weights))\n    plt.xlabel(irish.feature_names[0])\n    plt.ylabel(irish.feature_names[1])\n    \nplt.show()\n    \n    ","1bf5de32":"# # import some data to play with"}}