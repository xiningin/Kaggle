{"cell_type":{"803fb781":"code","4cbe8238":"code","1c0708e8":"code","2ff8f2ed":"code","0df163a0":"code","d3a2d8c9":"code","bd8fce8f":"code","440c5478":"code","3b5fcffa":"code","f2281436":"markdown","7bef347d":"markdown","f775eced":"markdown","f17f80a1":"markdown","2a4b5765":"markdown","1274521d":"markdown","4fa6f2ca":"markdown","3f32aac5":"markdown","ad08adf1":"markdown","91eb8dd3":"markdown","9d474aa5":"markdown","5dc0f058":"markdown"},"source":{"803fb781":"!pip install ..\/input\/detectron-05\/whls\/pycocotools-2.0.2\/dist\/pycocotools-2.0.2.tar --no-index --find-links ..\/input\/detectron-05\/whls \n!pip install ..\/input\/detectron-05\/whls\/fvcore-0.1.5.post20211019\/fvcore-0.1.5.post20211019 --no-index --find-links ..\/input\/detectron-05\/whls \n!pip install ..\/input\/detectron-05\/whls\/antlr4-python3-runtime-4.8\/antlr4-python3-runtime-4.8 --no-index --find-links ..\/input\/detectron-05\/whls \n!pip install ..\/input\/detectron-05\/whls\/detectron2-0.5\/detectron2 --no-index --find-links ..\/input\/detectron-05\/whls ","4cbe8238":"import detectron2\nfrom detectron2 import model_zoo\nfrom detectron2.engine import DefaultPredictor\nfrom detectron2.config import get_cfg\nfrom PIL import Image\nimport cv2\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom fastcore.all import *\ndetectron2.__version__","1c0708e8":"# From https:\/\/www.kaggle.com\/stainsby\/fast-tested-rle\ndef rle_decode(mask_rle, shape=(520, 704)):\n    '''\n    mask_rle: run-length as string formated (start length)\n    shape: (height,width) of array to return \n    Returns numpy array, 1 - mask, 0 - background\n\n    '''\n    s = mask_rle.split()\n    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0:][::2], s[1:][::2])]\n    starts -= 1\n    ends = starts + lengths\n    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)\n    for lo, hi in zip(starts, ends):\n        img[lo:hi] = 1\n    return img.reshape(shape)  # Needed to align to RLE direction\n\ndef rle_encode(img):\n    '''\n    img: numpy array, 1 - mask, 0 - background\n    Returns run length as string formated\n    '''\n    pixels = img.flatten()\n    pixels = np.concatenate([[0], pixels, [0]])\n    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1\n    runs[1::2] -= runs[::2]\n    return ' '.join(str(x) for x in runs)\n\ndef get_masks(fn, predictor):\n    im = cv2.imread(str(fn))\n    outputs = predictor(im)\n    pred_masks = outputs['instances'].pred_masks.cpu().numpy()\n    res = []\n    used = np.zeros(im.shape[:2], dtype=int) \n    for mask in pred_masks:\n        mask = mask * (1-used)\n        used += mask\n        res.append(rle_encode(mask))\n    return res","2ff8f2ed":"Dir_testdata=Path('..\/input\/sartorius-cell-instance-segmentation')\nids, masks=[],[]\ntest_image_names = (Dir_testdata\/'test').ls()","0df163a0":"cfg = get_cfg()\ncfg.merge_from_file(model_zoo.get_config_file(\"COCO-InstanceSegmentation\/mask_rcnn_R_50_FPN_3x.yaml\"))\ncfg.INPUT.MASK_FORMAT='bitmask'\ncfg.MODEL.WEIGHTS = \"..\/input\/sartoriussegmentationdetectron2rasin\/output\/model_final.pth\" \ncfg.MODEL.ROI_HEADS.NUM_CLASSES = 3 \ncfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5\ncfg.TEST.DETECTIONS_PER_IMAGE = 1000\npredictor = DefaultPredictor(cfg)","d3a2d8c9":"for fn in test_image_names:\n    encoded_masks = get_masks(fn, predictor)\n    for enc in encoded_masks:\n        ids.append(fn.stem)\n        masks.append(enc)","bd8fce8f":"print(\"id\",\",\",\"predicted\")\nprint(ids[0],\",\",masks[0])","440c5478":"encoded_masks = get_masks(test_image_names[2], predictor)\n_, axs = plt.subplots(1,2, figsize=(40,30))\naxs[1].imshow(cv2.imread(str(test_image_names[0])))\naxs[1].axis(\"off\")\nmask = np.zeros((520, 704, 1))\nfor enc in encoded_masks:\n    mask += rle_decode(enc, shape=(520, 704, 1))\n    \nmask = mask.clip(0, 1)\naxs[0].imshow(mask)\naxs[0].axis(\"off\")","3b5fcffa":"pd.DataFrame({'id':ids, 'predicted':masks}).to_csv('submission.csv', index=False)\npd.read_csv('submission.csv').head()","f2281436":"# Visualize predictions","7bef347d":"# References\n* https:\/\/www.kaggle.com\/slawekbiel\/positive-score-with-detectron-3-3-inference","f775eced":"# Sartorius Segmentation - Detectron2 [Inference]","f17f80a1":"# Submission","2a4b5765":"# Predicting","1274521d":"# Functions","4fa6f2ca":"# Load Model","3f32aac5":"## Install Detectron2 offline","ad08adf1":"# Detectron2 \nDetectron2 is Facebook AI Research's next generation software system that implements state-of-the-art object detection algorithms. It is a ground-up rewrite of the previous version, Detectron, and it originates from maskrcnn-benchmark\n\n","91eb8dd3":"## Other notebooks in this competition \n- [Sartorius Segmentation - Keras U-Net[Training]](https:\/\/www.kaggle.com\/ammarnassanalhajali\/sartorius-segmentation-keras-u-net-training)\n- [Sartorius Segmentation - Keras U-Net[Inference]](https:\/\/www.kaggle.com\/ammarnassanalhajali\/sartorius-segmentation-keras-u-net-inference\/edit)","9d474aa5":"### Hi kagglers, This is `Training` notebook using `Detectron2`.\n[Sartorius Segmentation - Detectron2 [training]](https:\/\/www.kaggle.com\/ammarnassanalhajali\/sartorius-segmentation-detectron2-training) \n### Please if this kernel is useful, <font color='red'>please upvote !!<\/font>","5dc0f058":"# importing libraries"}}