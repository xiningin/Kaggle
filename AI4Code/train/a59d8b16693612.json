{"cell_type":{"7fabcdbd":"code","74c55fb8":"code","21076367":"code","11369c33":"code","f0319054":"code","4ae25b47":"code","bddb6688":"code","d8bddc12":"code","be107ea9":"code","83b77b0d":"code","9b367b6d":"code","8f81e57e":"markdown","d9677b21":"markdown","38cfc132":"markdown","a5583e4c":"markdown","2dfdb039":"markdown","0fc8f0a7":"markdown","43ac8ba6":"markdown","f3eafaf2":"markdown","46962b9b":"markdown","9260e721":"markdown","b05f3fc3":"markdown","b55e9798":"markdown","5ce511ae":"markdown","83d8c73a":"markdown","2b492097":"markdown","9e005464":"markdown","5ad8d45c":"markdown"},"source":{"7fabcdbd":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport missingno as msno\n\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","74c55fb8":"train = pd.read_csv('\/kaggle\/input\/song-popularity-prediction\/train.csv')\ntest = pd.read_csv('\/kaggle\/input\/song-popularity-prediction\/test.csv')","21076367":"train.tail(6)","11369c33":"train.shape","f0319054":"train.info()","4ae25b47":"plt.figure(figsize=(10,10))\ncorr_matrix=train.corr()\nmask = np.zeros_like(corr_matrix)\nmask[np.triu_indices_from(mask)] = True\nsns.heatmap(corr_matrix, mask=mask, square=True)\nplt.show()","bddb6688":"train.isna().sum()","d8bddc12":"plt.figure(figsize=(15,8))\nsns.heatmap(train.isna().transpose(),cmap=\"binary\",cbar_kws={'label': 'Missing Data'})\nplt.show()","be107ea9":"%matplotlib inline\nmsno.matrix(train.sample(250))","83b77b0d":"msno.bar(train)","9b367b6d":"msno.dendrogram(train, orientation='right')","8f81e57e":"## We observe that energy and loudness are greatly correlated, whereas accousticness is not highly correlated with loudness and energy. Afterwards, we can check how many null values we have for each column.","d9677b21":"## We notice that our train set consists of 40000 rows with 15 features for each row. Since the song_popularity variable is the target variable, the other 14 columns will be used as the predictor variables.","38cfc132":"## After importing train and test set, it's time to have a first look at our train dataset. We can explore the last six rows of our data saved in a dataframe.","a5583e4c":"# Exploring missing values for Song Popularity Competition","2dfdb039":"## To interpret this graph, read it from a top-down perspective. \n## 1. Cluster leaves which linked together at a distance of zero fully predict one another's presence\u2014one variable might always be empty when another is filled, or \n## 2. they might always both be filled or both empty, and so on. \n## 3. In this specific example the dendrogram glues together the variables which are required and therefore present in every record.","0fc8f0a7":"## Now, we can have a closer look on the general information about the features of our dataset.","43ac8ba6":"## As expected, some columns have zero null values, whereas half of them have about 4000 missing values.","f3eafaf2":"## * At a glance, we notice that some variables, such as tempo and audio_valence are completely populated, whereas key is quite spotier.\n## * The sparkline at right summarizes the general shape of the data completeness and points out the rows with the maximum and minimum nullity in the dataset.","46962b9b":"## By looking at the above information, we see that some columns have null values and that all data are in int64 and float64 type format. Now, a heatmap is a good choice in order to explore the relationship between our features.","9260e721":"## P.S. If you want to check the procedure i followed about filling null values, you can wait for my final submission on the competition. :)","b05f3fc3":"## As a next step, we can create a dendrogram which allows you to more fully correlate variable completion, revealing trends deeper than the pairwise ones visible in the correlation heatmap.","b55e9798":"## 1 expresses no null values in the column. We infer that even in the columns that have missing values, these values express the 10% of each column values.","5ce511ae":"## Thanks to the missingno package, we can construct a nullity matrix. This matrix is a data-dense display which lets you quickly visually pick out patterns in data completion.","83d8c73a":"## The dendrogram uses a hierarchical clustering algorithm (courtesy of scipy) to bin variables against one another by their nullity correlation (measured in terms of binary distance). \n## * At each step of the tree the variables are split up based on which combination minimizes the distance of the remaining clusters. \n## * The more monotone the set of variables, the closer their total distance is to zero, and the closer their average distance (the x-axis) is to zero.","2b492097":"# You can learn more about how missingno Python package handles missing data here: [missingno github repo ](https:\/\/github.com\/ResidentMario\/missingno)","9e005464":"## Next, we can also explore the nullity of each column through a bar chart.","5ad8d45c":"## As a first step, we import all necessary packages and load the available datasets(train\/test data)."}}