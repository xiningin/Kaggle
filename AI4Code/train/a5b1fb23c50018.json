{"cell_type":{"de9940ad":"code","ef776aeb":"code","b16f9f0c":"code","a7e32f05":"code","ae336653":"code","5e13bc4e":"code","59cdeb0d":"code","b0d33dab":"code","c4205080":"code","cafc2a9d":"code","9d29f95e":"code","9479fa08":"code","36c55641":"code","fe2280fa":"code","764f4b95":"code","5ff02b6d":"code","dd343bbc":"code","dbd37f17":"code","73be23c3":"code","b25c33a6":"code","e75757da":"code","1eabe7a0":"code","ddd88c7c":"code","0aa0f0da":"code","14218e1f":"code","bfa13122":"code","cb62850c":"code","3b1ddbdb":"code","e557ef0c":"code","360ecb50":"code","9ec88485":"code","37eae983":"code","6a3ac2b2":"code","00bf4059":"code","09f3ce55":"markdown","0ed342d8":"markdown","56b04259":"markdown","357736fa":"markdown","1baef976":"markdown","5de15140":"markdown","17cde17e":"markdown","fa946d3e":"markdown","96200220":"markdown","66ced57f":"markdown","90010c12":"markdown"},"source":{"de9940ad":"import numpy as np #Numpy is used for array manipulation and processing\nimport pandas as pd #Pandas is used for table manipulation and processing\nimport matplotlib.pyplot as plt\nimport seaborn as sns # A very useful library other than matplotlib for plotting\nfrom sklearn.impute import KNNImputer \nfrom sklearn.svm import SVC\nfrom sklearn.neighbors import KNeighborsClassifier # Simple classification model\nfrom sklearn.model_selection import train_test_split #Splitting intro train and test\nfrom sklearn.model_selection import RandomizedSearchCV, GridSearchCV# Hyperparameter tunning\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import confusion_matrix, accuracy_score, plot_confusion_matrix # Classification metrics\n\n##These lines of code import the datasets that are also available in the Code tab on the Kaggle's competition\n# You could also upload them via the Add data button on the right of your kaggle notebook.\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","ef776aeb":"df = pd.read_csv('\/kaggle\/input\/titanic\/train.csv') #Import our data\ndf.columns #This method returns the names of the columns of the dataset","b16f9f0c":"sns.pairplot(data = df, hue = 'Survived') #Plotting histograms and distributions of each variable.\n# hue parameter sets color by another variable, in this case, \"Survived\"","a7e32f05":"sns.kdeplot(df.SibSp, hue = df.Survived)","ae336653":"df_test = pd.read_csv('\/kaggle\/input\/titanic\/test.csv') #Import our data\n\nsns.pairplot(df_test,)","5e13bc4e":"print(df_test.head(), df_test.shape)","59cdeb0d":"sns.heatmap(df_test.corr(), annot = True)\nplt.title('Correlation between Features in Train')","b0d33dab":"sns.heatmap(df.corr(), annot = True)\nplt.title('Correlations between Features in Test')","c4205080":"print('Missing values in Train: ')\ndf.isna().sum() # We count the number of missing values on each column","cafc2a9d":"print('Missing values in Test: ')\ndf_test.isna().sum()","9d29f95e":"print('Shape of Train: ', df.shape)\ndf.head()","9479fa08":"print('Shape of Test: ', df_test.shape)","36c55641":"sns.barplot(x = df.Sex, y = df.Survived) #easy Barplot with seaborn ","fe2280fa":"df.Sex = df.Sex.map(dict(female=1, male=0)) #The map method uses a dictionary to transform values on a Series object.\ndf_test.Sex = df_test.Sex.map(dict(female=1, male=0))","764f4b95":"df['Pclass'] = df['Pclass'].replace([3,1],[1,3]) #Another method to replace values on column\ndf_test['Pclass'] = df_test['Pclass'].replace([3,1],[1,3])\nprint(df.head(), df_test.head())","5ff02b6d":"df['Small Family'] = np.where((df['SibSp'] <= 2) & (df['SibSp'] != 0), 1, 0)\ndf_test['Small Family'] = np.where((df_test['SibSp'] <= 2) & (df_test['SibSp'] != 0), 1, 0)\ndf_test['Lonely Child'] = np.where(df_test['Parch'] == 1, 1, 0)\ndf['Lonely Child'] = np.where(df['Parch'] == 1, 1, 0)\n\ndf['Family'] = df['SibSp'] + df['Parch']\ndf_test['Family'] = df_test['SibSp'] + df_test['Parch']\ndf.head()","dd343bbc":"X = df[['Age', 'Pclass', 'Fare', 'Family','Lonely Child', 'Sex', 'Small Family','PassengerId']]#Select features\nXt = df_test[['Age', 'Pclass', 'Fare', 'Family','Lonely Child', 'Sex', 'Small Family', 'PassengerId']]\ny = df.Survived #Select target","dbd37f17":"X = X.append(Xt)\n\nfor i in range(4): # Run through all columns except encoded\n    X.iloc[:,i] = X.iloc[:,i] \/ X.iloc[:,i].max() # Scale each column dividing by maximum\n    mean = X.iloc[:,i].mean() # Calculate column mean\n    std = X.iloc[:,i].std() # Calculate column STD\n    X.iloc[:,i] = (X.iloc[:,i] - mean)\/std # Normalie column\nprint(X.shape, X.head())","73be23c3":"sns.kdeplot(Xt.Age) # plot first kde\nplt.title('Age Distribution without imputation')","b25c33a6":"imputer = KNNImputer() # Create the imputer object\nX = pd.DataFrame(imputer.fit_transform(X),columns = X.columns) # Transform the data","e75757da":"sns.kdeplot(Xt.Age) # plot first kde\nplt.title('Age Distribution without imputation')","1eabe7a0":"X['Child'] = np.where(X['Age']< -1.5, 1, 0)\nX['Expensive'] = np.where(X['Fare'] <= 0.14, 0, 1)\n\nX.head()","ddd88c7c":"sns.boxplot(x = 'variable', y = 'value', data=pd.melt(X[['Age', 'Pclass', 'Fare', 'Family', 'Sex', 'Small Family']]))\nplt.title('Distribution of the features')","0aa0f0da":"for i in [0, 2, 3]:\n    q1 = X.iloc[:,i].quantile(0.25) # Calculate 1 quartile\n    q3 = X.iloc[:,i].quantile(0.75) # Calculate 3 quartile\n\n    IQR = q3 - q1 # Interquartile range\n\n    #defining max and min limits\n    max_limit = q3 + (1.5 * IQR)\n    min_limit = q1 - (1.5 * IQR) \n\n    #capping\n    X.iloc[:,i] = pd.DataFrame(np.where(X.iloc[:,i] > max_limit, max_limit, \n             (np.where(X.iloc[:,i] < min_limit, min_limit,X.iloc[:,i] ))))","14218e1f":"sns.boxplot(x = 'variable', y = 'value', data=pd.melt(X[['Age', 'Pclass', 'Fare', 'Family', 'Sex', 'Small Family']]))\nplt.title('Distribution of the features')","bfa13122":"Xtrain = X.iloc[:891, :]\nXtest = X.iloc[891:, :]","cb62850c":"X_train = Xtrain[['Age', 'Pclass', 'Fare', 'Family','Lonely Child', 'Sex', 'Small Family', 'Expensive', 'Child']]\nX_test = Xtest[['Age', 'Pclass', 'Fare', 'Family','Lonely Child', 'Sex', 'Small Family', 'Expensive', 'Child']]","3b1ddbdb":"Xtrain2, Xtest2, ytrain, ytest = train_test_split(X_train, y, train_size = 0.7, test_size = 0.3)","e557ef0c":"rf = RandomForestClassifier()\ngrid_list = {\"n_estimators\": [100, 200, 300, 500, 1000],\n             'max_depth': [100, 30, 150, None],\n             'max_features':['auto', 'sqrt', 'log2']}\n\n\ngrid_search = GridSearchCV(rf, param_grid = grid_list, n_jobs = 4, cv = 5, scoring = 'accuracy') \ngrid_search.fit(Xtrain2, ytrain) \nprint(grid_search.best_params_, grid_search.best_score_)","360ecb50":"svc = SVC()\ngrid_list = {'C': [0.1,1, 10, 100], \n             'gamma': [1,0.1,0.01,0.001],\n             'kernel': ['rbf', 'poly', 'sigmoid']}\n\n\ngrid_search = GridSearchCV(svc, param_grid = grid_list, n_jobs = 4, cv = 5, scoring = 'accuracy') \ngrid_search.fit(Xtrain2, ytrain) \nprint(grid_search.best_params_, grid_search.best_score_)","9ec88485":"svc = SVC(C = 100, gamma = 0.01, kernel = 'rbf')\nsvc.fit(Xtrain2, ytrain)\npredictions = svc.predict(Xtest2)\naccuracy_score(ytest, predictions)","37eae983":"rf = RandomForestClassifier(n_estimators = 300)\nrf.fit(Xtrain2,ytrain)\npredictions = rf.predict(Xtest2)\naccuracy_score(ytest,predictions)","6a3ac2b2":"svc = SVC(C = 100, gamma = 0.01, kernel = 'rbf')\nsvc.fit(X_train, y)\npredictions = svc.predict(X_test)","00bf4059":"Xtest['PassengerId'] = Xtest['PassengerId'].astype(int)\n\noutput = pd.DataFrame({'PassengerId': Xtest.PassengerId, 'Survived': predictions})\noutput.to_csv('my_submission.csv', index=False)\nprint(\"Your submission was successfully saved!\")","09f3ce55":"<a id = \"out\"><\/a>\n### Outliers\n\nWithout scaling and normalization, you could tend to get too many instances(each **row** of your dataset) when detecting outliers. Now that you have everything set up nicely, let's see how these new features look like, this time with **boxplots** ","0ed342d8":"<a id = \"mod\"><\/a>\n### Modeling\n\nNow that you have both train and test sets preprocessed, let's train a Random Forest and a Support Vector Machine. My hypothesis is that SVC might perform better, since it can benefit from the scaling and normalizing.","56b04259":"<a id = \"norm\"><\/a>\n### Normalization - Scaling\n\nScaling data means(in a non-exhaustive, non-academic way) **bringing all your feature values to a common scale, maintaining the individual relationships between each feature**, this is, brinding each column of your dataframe to, say, values between 0 and 1. This makes sense: if a column has values between 1000 and 100000, and another between 0 and 1, some algorithms may incorrectly decide that the first feature is much more important than the second one.\nNormalizing is, well, **changing the shape of your distributions to fit a normal one**, said in very simple terms. The **encoded features** like \"Sex\" and \"Pclass\" are not normalized.\n \n\n#### Side Notes\n\nThe truth is, you should make some Statistical proof about the relation between the variables for the imputation. We are simplifying things a big lot here. If you want more details, just let me know.\n\nI'm also learning so any feedback on improvements are very, very welcomed :)","357736fa":"<a id = \"knn\"><\/a>\n### KNN Imputer\n\nThis kind of imputation uses KNNeighbors logic: it assings a value to the missing gaps depending on the nearests points values. It has it's own hyperparameters, but in this notebook I won't focus on those aspects. I don't want you to get too bored too quickly. Kaggle and StackOverflow are places to look up for amazing content.","1baef976":"<a id = \"eda\"><\/a>\n## Exploratory Data Analysis (EDA)\n\nWhen you are presented when a new problem, it might contain special vocabulary associated with the topic of the problem itself, so it's really important tu understand what are the variables(columns in this case) you have.\n\nIn this case, Kaggle provides information about it in the **Data** tab in the Titanic's competition page.\n\nBut it might happen you don't have this information(with most of the real world problems), so you will have to gather it by yourself. Usually, an expert of the topic can be a great place to start. **Research** it's a big part of solving a problem! \n\n### The columns\n\nMany of them are self-explanatory, but there are some that don't:\n\n* Embarked: Name of the port of embarkation\n* Parch: Number of parents\/children aboard\n* SibSp: Number of siblings\/spouses aboard\n\n### How do we continue?\n\nNow that you understand what are the data variables telling, you will try to figure out the relation of each variable with the target prediction(if the person survived or not). We will do some plotting and some further analysis.\n\nSome useful questions to guide youur analysis may be:\n\n* What type of distribution do the variables have?\n* Are there any outliers?\n* Are there any missing values? \n* What variables do you think will be of interest? Is there any that don't give too much information about the problem?","5de15140":"\n<a id = \"obs\"><\/a>\n### Observations\n\nYou can see that Age distribution looks close enough with and without imputation. **This is crucial**. You want your data to look similar with the imputation as how it looked without it.\n\n<a id = \"fea2\"><\/a>\n## Feature Engineering(Child and Family Columns)\n\nYou can see in the above graphs that we could create a new feature using this \"two headed distribution\". Let's add a new column named Child with 0 if False and 1 if True","17cde17e":"<a id = \"obs2\"><\/a>\n### Observations\n\nAs you may expect, there are no such thing as an outlier on an encoded column like Sex or Pclass, and in **all** other features we can see a long-tailed distribution. **This must be kept on mind for the outlier detection**.\n\nFor an **excellent in-depth article about outliers** visit: \nhttps:\/\/www.kaggle.com\/aimack\/how-to-handle-outliers\/notebook\nby Akash Dey. \n\nThe following steps follow his logic. Some of the code waws borrowed as well.\nSince there are not too many instances(each individual), less than 1000, **Capping method** will be used.","fa946d3e":"\n<a id = \"prepro\"><\/a>\n## Data Preprocessing\n\nDuring this step we want to leave the data ready for modeling. You will:\n\n* Impute missing values: A model can't have missing values. You have to do something with them. \n\n* Handle your Outliers: values that are too large or too small compared to the rest.\n\n* Normalize and scale: These steps are not always necessary. It depends on your Machine Learning Model. Some models are based on relations of distances(like K-Nearest Neighbors), so normalizing and scaling is indispensable to maintain an equally weighted importance of your features. Other models like Decision Trees are not designed the same way. Anyway, this is a good practice, so in this notebook you'll leasrn the basics on how to do it.\n\n\n### Some Feature Engineering\n\n**Label Encoding**: With the Sex column, Expensive Fare, and Small Family(see KDEs), all decisions based on the barplot, KDE and heatmap. \n\nI'll change Pclass from a descending rank to an ascending one. I don't know if this change something.\n ","96200220":"<a id = \"final\"><\/a>\n### Final Thoughts\n\nIf you have any comment, suggestion, or idea, please let me know. Hope you enjoyed it =).\n\ndrK~\n","66ced57f":"<a id = \"corr\"><\/a>\n### Correlations\n\nTake some time to understand what's happening in the pairplots and heatmaps. There's plenty of information in those few lines. Parch and SibSp are **strongly correlatied**, so it gives you the chance to do some feature engineering. \nIn the Train Heatmap(which has Survived as a column) we see that Pclass is **strongly negative correlated**, and that's because first class passengers had a better chance to survive.\n\n### Distributions\n\nIn the KDEs you can percieve that depending on the number of SibSp, **the number of survivals is greater than the fatalities**, and, from my point of view, that's a very good reason to think on doing some Feature Enginerring with it. Something similar happens with the **Fare**\n\nThere's so many patterns going on that I'm missing, probably. You can dig in all you want and find others. This part of the process if crucial to get a better performance model.\n\n### Feature Importance\n\nThere are some columns that don't give you any information, throw them. Keep the ones that matter.\n\n","90010c12":"## First Steps on the ML Universe - Titanic Disaster!\n\n## First Steos on Kaggle and ML!\n\nDuring the past few months, I've been learning the basics of Machine Learning. This notebook is an attempt to show others like me, the insights I've came across so far. Hope you find it useful!\n\n### Table of Contents\n\n* [Exploratory Data Analysis](#eda)\n    * [Correlations, Distributions](#corr)\n* [Pre Processing](#prepro)\n    * [Some Feature Engineering](#fea)\n    * [Normalization - Scaling](#norm)\n    * [Imputation](#imp)\n        * [Observations](#obs)\n    * [+ Feature Enginering](#fea2)\n    * [Outliers](#out)\n        * [Observations](#obs2)\n* [Modeling](#mod)\n* [Final Thoughts](#final)\n\n\n### Understanding your problem and your data\n\nThe first step on your journey is to understand the problem you are trying to solve(**who survived the Titanic disaster?**), and the data you have to do it.\n\nLet's import your datasets and some of the libraries you will be using and see what the dataset looks like:"}}