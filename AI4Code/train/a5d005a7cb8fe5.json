{"cell_type":{"3e4cbd80":"code","68f6bf7e":"code","19a5343e":"code","69866c65":"code","aad1f8d6":"code","56570f4d":"code","a8c5e781":"code","4b2c2f85":"code","a240f95b":"code","6b71d7f4":"code","0e57fb7f":"code","0de713a1":"code","42e947e5":"code","0c0926ba":"code","664f098f":"code","82917c12":"code","88586b73":"code","effd5e0a":"code","695ed80f":"code","fcdf6a30":"code","2352d9f8":"code","8506314f":"code","d612d53d":"markdown","d6a9d858":"markdown","84cdf424":"markdown","3163fe7b":"markdown","25cf8246":"markdown","6a214e2d":"markdown","5a1c4f76":"markdown","4b58d4b5":"markdown","98349153":"markdown","55fef8dc":"markdown","8b9e7e3c":"markdown","c5337d88":"markdown","a54d20ae":"markdown","11e8d512":"markdown"},"source":{"3e4cbd80":"import warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport ast\nimport os\nimport json\nimport pandas as pd\nimport numpy as np\nimport torch\nimport importlib\nimport cv2 \n\nimport shutil\nfrom shutil import copyfile, make_archive\nfrom tqdm.notebook import tqdm\ntqdm.pandas()\nfrom sklearn.model_selection import GroupKFold\nfrom PIL import Image\nfrom string import Template\nfrom IPython.display import display\n\nimport matplotlib.pyplot as plt\n\nTRAIN_PATH = '\/kaggle\/input\/tensorflow-great-barrier-reef'","68f6bf7e":"!git clone https:\/\/github.com\/ultralytics\/yolov5.git","19a5343e":"# Specify your custom set of Albumentations here\n# See https:\/\/www.kaggle.com\/alexchwong\/cots-albumentations-gallery for some ideas on what to include\n# Ensure there are at least 16 spaces after each new line, for correct indentations consistent with yolov5's augmentations.py script\n\n################ 16 hashes here\n\nALBUMENTATIONS = '''[\n                # Add your Albumentations after this line\n                    A.OneOf([\n                        A.MotionBlur(p=.2),\n                        A.MedianBlur(blur_limit=3, p=0.3),\n                        A.Blur(blur_limit=3, p=0.1),\n                    ], p=0.3),\n                    A.OneOf([\n                        A.CLAHE(clip_limit=2),\n                        A.RandomBrightnessContrast(),            \n                    ], p=0.3),\n                # Do not edit past this line\n                ],\n'''\n\n################ If you are not convinced whether your Albumentations are working, uncomment the following line to make all the training pictures gray at the end:\n\n# ALBUMENTATIONS = \"[A.ToGray(p=1.0),],\"\n","69866c65":"# From yolov5\/data\/hyps\/hyp.scratch.yaml\n\n# Change yolov5's built-in augmentations \/ training hyperparameters here\n\nhyps = '''\n\n# YOLOv5 \ud83d\ude80 by Ultralytics, GPL-3.0 license\n# Hyperparameters for COCO training from scratch\n# python train.py --batch 40 --cfg yolov5m.yaml --weights '' --data coco.yaml --img 640 --epochs 300\n# See tutorials for hyperparameter evolution https:\/\/github.com\/ultralytics\/yolov5#tutorials\n\nlr0: 0.01  # initial learning rate (SGD=1E-2, Adam=1E-3)\nlrf: 0.1  # final OneCycleLR learning rate (lr0 * lrf)\nmomentum: 0.937  # SGD momentum\/Adam beta1\nweight_decay: 0.0005  # optimizer weight decay 5e-4\nwarmup_epochs: 3.0  # warmup epochs (fractions ok)\nwarmup_momentum: 0.8  # warmup initial momentum\nwarmup_bias_lr: 0.1  # warmup initial bias lr\nbox: 0.05  # box loss gain\ncls: 0.5  # cls loss gain\ncls_pw: 1.0  # cls BCELoss positive_weight\nobj: 1.0  # obj loss gain (scale with pixels)\nobj_pw: 1.0  # obj BCELoss positive_weight\niou_t: 0.20  # IoU training threshold\nanchor_t: 4.0  # anchor-multiple threshold\n# anchors: 3  # anchors per output layer (0 to ignore)\nfl_gamma: 0.0  # focal loss gamma (efficientDet default gamma=1.5)\nhsv_h: 0.015  # image HSV-Hue augmentation (fraction)\nhsv_s: 0.7  # image HSV-Saturation augmentation (fraction)\nhsv_v: 0.4  # image HSV-Value augmentation (fraction)\ndegrees: 0.0  # image rotation (+\/- deg)\ntranslate: 0.1  # image translation (+\/- fraction)\nscale: 0.5  # image scale (+\/- gain)\nshear: 0.0  # image shear (+\/- deg)\nperspective: 0.0  # image perspective (+\/- fraction), range 0-0.001\nflipud: 0.0  # image flip up-down (probability)\nfliplr: 0.5  # image flip left-right (probability)\nmosaic: 1.0  # image mosaic (probability)\nmixup: 0.0  # image mixup (probability)\ncopy_paste: 0.0  # segment copy-paste (probability)\n\n'''","aad1f8d6":"# edit number of classes to 1\ncopyfile(\"\/kaggle\/working\/yolov5\/models\/yolov5s.yaml\", \"\/kaggle\/working\/yolov5\/yolov5s.yaml\")   \n!sed -i 's\/nc: 80\/nc: 1\/g' \/kaggle\/working\/yolov5\/yolov5s.yaml\n!cat '\/kaggle\/working\/yolov5\/yolov5s.yaml'","56570f4d":"cots_data = '''\ntrain: ..\/images\/train\nval: ..\/images\/valid\n\nnc: 1\nnames: [cots]\n'''","a8c5e781":"with open('.\/yolov5\/data\/cots.yaml', 'w') as fp:\n    fp.write(cots_data)\nwith open('.\/yolov5\/data\/hyps\/hyps_custom.yaml', 'w') as fp:\n    fp.write(hyps)","4b2c2f85":"augmentations_template = '''\n# YOLOv5 \ud83d\ude80 by Ultralytics, GPL-3.0 license\n\"\"\"\nImage augmentation functions\n\"\"\"\n\nimport math\nimport random\n\nimport cv2\nimport numpy as np\n\nfrom utils.general import LOGGER, check_version, colorstr, resample_segments, segment2box\nfrom utils.metrics import bbox_ioa\n\n\nclass Albumentations:\n    # YOLOv5 Albumentations class (optional, only used if package is installed)\n    def __init__(self):\n        self.transform = None\n        try:\n            import albumentations as A\n            # check_version(A.__version__, '1.0.3', hard=True)  # version requirement\n\n            self.transform = A.Compose($albumentations\n                bbox_params=A.BboxParams(format='yolo', label_fields=['class_labels']))\n\n            LOGGER.info(colorstr('albumentations: ') + ', '.join(f'{x}' for x in self.transform.transforms if x.p))\n        except ImportError:  # package not installed, skip\n            pass\n        except Exception as e:\n            LOGGER.info(colorstr('albumentations: ') + f'{e}')\n\n    def __call__(self, im, labels, p=1.0):\n        if self.transform and random.random() < p:\n            new = self.transform(image=im, bboxes=labels[:, 1:], class_labels=labels[:, 0])  # transformed\n            im, labels = new['image'], np.array([[c, *b] for c, b in zip(new['class_labels'], new['bboxes'])])\n        return im, labels\n\n\ndef augment_hsv(im, hgain=0.5, sgain=0.5, vgain=0.5):\n    # HSV color-space augmentation\n    if hgain or sgain or vgain:\n        r = np.random.uniform(-1, 1, 3) * [hgain, sgain, vgain] + 1  # random gains\n        hue, sat, val = cv2.split(cv2.cvtColor(im, cv2.COLOR_BGR2HSV))\n        dtype = im.dtype  # uint8\n\n        x = np.arange(0, 256, dtype=r.dtype)\n        lut_hue = ((x * r[0]) % 180).astype(dtype)\n        lut_sat = np.clip(x * r[1], 0, 255).astype(dtype)\n        lut_val = np.clip(x * r[2], 0, 255).astype(dtype)\n\n        im_hsv = cv2.merge((cv2.LUT(hue, lut_hue), cv2.LUT(sat, lut_sat), cv2.LUT(val, lut_val)))\n        cv2.cvtColor(im_hsv, cv2.COLOR_HSV2BGR, dst=im)  # no return needed\n\n\ndef hist_equalize(im, clahe=True, bgr=False):\n    # Equalize histogram on BGR image 'im' with im.shape(n,m,3) and range 0-255\n    yuv = cv2.cvtColor(im, cv2.COLOR_BGR2YUV if bgr else cv2.COLOR_RGB2YUV)\n    if clahe:\n        c = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n        yuv[:, :, 0] = c.apply(yuv[:, :, 0])\n    else:\n        yuv[:, :, 0] = cv2.equalizeHist(yuv[:, :, 0])  # equalize Y channel histogram\n    return cv2.cvtColor(yuv, cv2.COLOR_YUV2BGR if bgr else cv2.COLOR_YUV2RGB)  # convert YUV image to RGB\n\n\ndef replicate(im, labels):\n    # Replicate labels\n    h, w = im.shape[:2]\n    boxes = labels[:, 1:].astype(int)\n    x1, y1, x2, y2 = boxes.T\n    s = ((x2 - x1) + (y2 - y1)) \/ 2  # side length (pixels)\n    for i in s.argsort()[:round(s.size * 0.5)]:  # smallest indices\n        x1b, y1b, x2b, y2b = boxes[i]\n        bh, bw = y2b - y1b, x2b - x1b\n        yc, xc = int(random.uniform(0, h - bh)), int(random.uniform(0, w - bw))  # offset x, y\n        x1a, y1a, x2a, y2a = [xc, yc, xc + bw, yc + bh]\n        im[y1a:y2a, x1a:x2a] = im[y1b:y2b, x1b:x2b]  # im4[ymin:ymax, xmin:xmax]\n        labels = np.append(labels, [[labels[i, 0], x1a, y1a, x2a, y2a]], axis=0)\n\n    return im, labels\n\n\ndef letterbox(im, new_shape=(640, 640), color=(114, 114, 114), auto=True, scaleFill=False, scaleup=True, stride=32):\n    # Resize and pad image while meeting stride-multiple constraints\n    shape = im.shape[:2]  # current shape [height, width]\n    if isinstance(new_shape, int):\n        new_shape = (new_shape, new_shape)\n\n    # Scale ratio (new \/ old)\n    r = min(new_shape[0] \/ shape[0], new_shape[1] \/ shape[1])\n    if not scaleup:  # only scale down, do not scale up (for better val mAP)\n        r = min(r, 1.0)\n\n    # Compute padding\n    ratio = r, r  # width, height ratios\n    new_unpad = int(round(shape[1] * r)), int(round(shape[0] * r))\n    dw, dh = new_shape[1] - new_unpad[0], new_shape[0] - new_unpad[1]  # wh padding\n    if auto:  # minimum rectangle\n        dw, dh = np.mod(dw, stride), np.mod(dh, stride)  # wh padding\n    elif scaleFill:  # stretch\n        dw, dh = 0.0, 0.0\n        new_unpad = (new_shape[1], new_shape[0])\n        ratio = new_shape[1] \/ shape[1], new_shape[0] \/ shape[0]  # width, height ratios\n\n    dw \/= 2  # divide padding into 2 sides\n    dh \/= 2\n\n    if shape[::-1] != new_unpad:  # resize\n        im = cv2.resize(im, new_unpad, interpolation=cv2.INTER_LINEAR)\n    top, bottom = int(round(dh - 0.1)), int(round(dh + 0.1))\n    left, right = int(round(dw - 0.1)), int(round(dw + 0.1))\n    im = cv2.copyMakeBorder(im, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)  # add border\n    return im, ratio, (dw, dh)\n\n\ndef random_perspective(im, targets=(), segments=(), degrees=10, translate=.1, scale=.1, shear=10, perspective=0.0,\n                       border=(0, 0)):\n    # torchvision.transforms.RandomAffine(degrees=(-10, 10), translate=(0.1, 0.1), scale=(0.9, 1.1), shear=(-10, 10))\n    # targets = [cls, xyxy]\n\n    height = im.shape[0] + border[0] * 2  # shape(h,w,c)\n    width = im.shape[1] + border[1] * 2\n\n    # Center\n    C = np.eye(3)\n    C[0, 2] = -im.shape[1] \/ 2  # x translation (pixels)\n    C[1, 2] = -im.shape[0] \/ 2  # y translation (pixels)\n\n    # Perspective\n    P = np.eye(3)\n    P[2, 0] = random.uniform(-perspective, perspective)  # x perspective (about y)\n    P[2, 1] = random.uniform(-perspective, perspective)  # y perspective (about x)\n\n    # Rotation and Scale\n    R = np.eye(3)\n    a = random.uniform(-degrees, degrees)\n    # a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations\n    s = random.uniform(1 - scale, 1 + scale)\n    # s = 2 ** random.uniform(-scale, scale)\n    R[:2] = cv2.getRotationMatrix2D(angle=a, center=(0, 0), scale=s)\n\n    # Shear\n    S = np.eye(3)\n    S[0, 1] = math.tan(random.uniform(-shear, shear) * math.pi \/ 180)  # x shear (deg)\n    S[1, 0] = math.tan(random.uniform(-shear, shear) * math.pi \/ 180)  # y shear (deg)\n\n    # Translation\n    T = np.eye(3)\n    T[0, 2] = random.uniform(0.5 - translate, 0.5 + translate) * width  # x translation (pixels)\n    T[1, 2] = random.uniform(0.5 - translate, 0.5 + translate) * height  # y translation (pixels)\n\n    # Combined rotation matrix\n    M = T @ S @ R @ P @ C  # order of operations (right to left) is IMPORTANT\n    if (border[0] != 0) or (border[1] != 0) or (M != np.eye(3)).any():  # image changed\n        if perspective:\n            im = cv2.warpPerspective(im, M, dsize=(width, height), borderValue=(114, 114, 114))\n        else:  # affine\n            im = cv2.warpAffine(im, M[:2], dsize=(width, height), borderValue=(114, 114, 114))\n\n    # Visualize\n    # import matplotlib.pyplot as plt\n    # ax = plt.subplots(1, 2, figsize=(12, 6))[1].ravel()\n    # ax[0].imshow(im[:, :, ::-1])  # base\n    # ax[1].imshow(im2[:, :, ::-1])  # warped\n\n    # Transform label coordinates\n    n = len(targets)\n    if n:\n        use_segments = any(x.any() for x in segments)\n        new = np.zeros((n, 4))\n        if use_segments:  # warp segments\n            segments = resample_segments(segments)  # upsample\n            for i, segment in enumerate(segments):\n                xy = np.ones((len(segment), 3))\n                xy[:, :2] = segment\n                xy = xy @ M.T  # transform\n                xy = xy[:, :2] \/ xy[:, 2:3] if perspective else xy[:, :2]  # perspective rescale or affine\n\n                # clip\n                new[i] = segment2box(xy, width, height)\n\n        else:  # warp boxes\n            xy = np.ones((n * 4, 3))\n            xy[:, :2] = targets[:, [1, 2, 3, 4, 1, 4, 3, 2]].reshape(n * 4, 2)  # x1y1, x2y2, x1y2, x2y1\n            xy = xy @ M.T  # transform\n            xy = (xy[:, :2] \/ xy[:, 2:3] if perspective else xy[:, :2]).reshape(n, 8)  # perspective rescale or affine\n\n            # create new boxes\n            x = xy[:, [0, 2, 4, 6]]\n            y = xy[:, [1, 3, 5, 7]]\n            new = np.concatenate((x.min(1), y.min(1), x.max(1), y.max(1))).reshape(4, n).T\n\n            # clip\n            new[:, [0, 2]] = new[:, [0, 2]].clip(0, width)\n            new[:, [1, 3]] = new[:, [1, 3]].clip(0, height)\n\n        # filter candidates\n        i = box_candidates(box1=targets[:, 1:5].T * s, box2=new.T, area_thr=0.01 if use_segments else 0.10)\n        targets = targets[i]\n        targets[:, 1:5] = new[i]\n\n    return im, targets\n\n\ndef copy_paste(im, labels, segments, p=0.5):\n    # Implement Copy-Paste augmentation https:\/\/arxiv.org\/abs\/2012.07177, labels as nx5 np.array(cls, xyxy)\n    n = len(segments)\n    if p and n:\n        h, w, c = im.shape  # height, width, channels\n        im_new = np.zeros(im.shape, np.uint8)\n        for j in random.sample(range(n), k=round(p * n)):\n            l, s = labels[j], segments[j]\n            box = w - l[3], l[2], w - l[1], l[4]\n            ioa = bbox_ioa(box, labels[:, 1:5])  # intersection over area\n            if (ioa < 0.30).all():  # allow 30% obscuration of existing labels\n                labels = np.concatenate((labels, [[l[0], *box]]), 0)\n                segments.append(np.concatenate((w - s[:, 0:1], s[:, 1:2]), 1))\n                cv2.drawContours(im_new, [segments[j].astype(np.int32)], -1, (255, 255, 255), cv2.FILLED)\n\n        result = cv2.bitwise_and(src1=im, src2=im_new)\n        result = cv2.flip(result, 1)  # augment segments (flip left-right)\n        i = result > 0  # pixels to replace\n        # i[:, :] = result.max(2).reshape(h, w, 1)  # act over ch\n        im[i] = result[i]  # cv2.imwrite('debug.jpg', im)  # debug\n\n    return im, labels, segments\n\n\ndef cutout(im, labels, p=0.5):\n    # Applies image cutout augmentation https:\/\/arxiv.org\/abs\/1708.04552\n    if random.random() < p:\n        h, w = im.shape[:2]\n        scales = [0.5] * 1 + [0.25] * 2 + [0.125] * 4 + [0.0625] * 8 + [0.03125] * 16  # image size fraction\n        for s in scales:\n            mask_h = random.randint(1, int(h * s))  # create random masks\n            mask_w = random.randint(1, int(w * s))\n\n            # box\n            xmin = max(0, random.randint(0, w) - mask_w \/\/ 2)\n            ymin = max(0, random.randint(0, h) - mask_h \/\/ 2)\n            xmax = min(w, xmin + mask_w)\n            ymax = min(h, ymin + mask_h)\n\n            # apply random color mask\n            im[ymin:ymax, xmin:xmax] = [random.randint(64, 191) for _ in range(3)]\n\n            # return unobscured labels\n            if len(labels) and s > 0.03:\n                box = np.array([xmin, ymin, xmax, ymax], dtype=np.float32)\n                ioa = bbox_ioa(box, labels[:, 1:5])  # intersection over area\n                labels = labels[ioa < 0.60]  # remove >60% obscured labels\n\n    return labels\n\n\ndef mixup(im, labels, im2, labels2):\n    # Applies MixUp augmentation https:\/\/arxiv.org\/pdf\/1710.09412.pdf\n    r = np.random.beta(32.0, 32.0)  # mixup ratio, alpha=beta=32.0\n    im = (im * r + im2 * (1 - r)).astype(np.uint8)\n    labels = np.concatenate((labels, labels2), 0)\n    return im, labels\n\n\ndef box_candidates(box1, box2, wh_thr=2, ar_thr=100, area_thr=0.1, eps=1e-16):  # box1(4,n), box2(4,n)\n    # Compute candidate boxes: box1 before augment, box2 after augment, wh_thr (pixels), aspect_ratio_thr, area_ratio\n    w1, h1 = box1[2] - box1[0], box1[3] - box1[1]\n    w2, h2 = box2[2] - box2[0], box2[3] - box2[1]\n    ar = np.maximum(w2 \/ (h2 + eps), h2 \/ (w2 + eps))  # aspect ratio\n    return (w2 > wh_thr) & (h2 > wh_thr) & (w2 * h2 \/ (w1 * h1 + eps) > area_thr) & (ar < ar_thr)  # candidates\n\n'''\n\naugmentations = Template(augmentations_template).substitute(\n    albumentations = ALBUMENTATIONS,\n)\n\nwith open('\/kaggle\/working\/yolov5\/utils\/augmentations.py', 'w') as f:\n    f.write(augmentations)\n\n!cat \/kaggle\/working\/yolov5\/utils\/augmentations.py","a240f95b":"# Control Panel\n\nN_FOLDS = 5\nVALIDATION_FOLD = 4","6b71d7f4":"TRAIN_PATH = '\/kaggle\/input\/tensorflow-great-barrier-reef'\n\ndef get_bbox(annots):\n    bboxes = [list(annot.values()) for annot in annots]\n    return bboxes\n\ndef get_path(row):\n    row['image_path'] = f'{TRAIN_PATH}\/train_images\/video_{row.video_id}\/{row.video_frame}.jpg'\n    return row","0e57fb7f":"# hide\n\ndef coco2yolo(image_height, image_width, bboxes):\n    \"\"\"\n    coco => [xmin, ymin, w, h]\n    yolo => [xmid, ymid, w, h] (normalized)\n    \"\"\"\n    \n    bboxes = bboxes.copy().astype(float) # otherwise all value will be 0 as voc_pascal dtype is np.int\n    \n    for bbox in bboxes:\n        if bbox[0] + bbox[2] >= image_width:\n            bbox[2] = image_width - bbox[0] - 1\n        if bbox[1] + bbox[3] >= image_height:\n            bbox[3] = image_height - bbox[1] - 1\n    \n    # normolizinig\n    bboxes[..., [0, 2]]= bboxes[..., [0, 2]]\/ image_width\n    bboxes[..., [1, 3]]= bboxes[..., [1, 3]]\/ image_height\n    \n    # converstion (xmin, ymin) => (xmid, ymid)\n    bboxes[..., [0, 1]] = bboxes[..., [0, 1]] + bboxes[..., [2, 3]]\/2\n    \n    return bboxes","0de713a1":"df = pd.read_csv(\"\/kaggle\/input\/tensorflow-great-barrier-reef\/train.csv\")\n\n# Taken only annotated photos\ndf[\"num_bbox\"] = df['annotations'].apply(lambda x: str.count(x, 'x'))\ndf_train = df[df[\"num_bbox\"]>0]\n\n# Annotations \ndf_train['annotations'] = df_train['annotations'].progress_apply(lambda x: ast.literal_eval(x))\ndf_train['bboxes'] = df_train.annotations.progress_apply(get_bbox)\n\n# Images resolution\ndf_train[\"width\"] = 1280\ndf_train[\"height\"] = 720\n\n#Path of images\ndf_train = df_train.progress_apply(get_path, axis=1)","42e947e5":"kf = GroupKFold(n_splits = N_FOLDS) \ndf_train = df_train.reset_index(drop=True)\ndf_train['fold'] = -1\nfor fold, (train_idx, val_idx) in enumerate(kf.split(df_train, y = df_train.video_id.tolist(), groups=df_train.sequence)):\n    df_train.loc[val_idx, 'fold'] = fold\n\ndf_train.head(5)","0c0926ba":"IMAGE_DIR = \"\/kaggle\/working\/images\"\nLABEL_DIR = \"\/kaggle\/working\/labels\"\n\n!mkdir -p {IMAGE_DIR}\n!mkdir -p {LABEL_DIR}\n\n!mkdir -p {IMAGE_DIR + '\/train'}\n!mkdir -p {IMAGE_DIR + '\/valid'}\n!mkdir -p {LABEL_DIR + '\/train'}\n!mkdir -p {LABEL_DIR + '\/valid'}\n\ndef writeLabels(bboxes, destfile, image_width = 1280, image_height = 720):\n    bboxes_coco  = np.array(bboxes).astype(np.float32).copy()\n    num_bbox     = len(bboxes_coco)\n    names        = ['cots'] * num_bbox\n    labels       = [0] * num_bbox\n    with open(destfile, 'w') as f:\n        if num_bbox<1:\n            annot = ''\n            f.write(annot)\n        else:\n            bboxes_yolo  = coco2yolo(image_height, image_width, bboxes_coco)\n            for bbox_idx in range(len(bboxes_yolo)):\n                annot = [str(labels[bbox_idx])]+ list(bboxes_yolo[bbox_idx].astype(str))+(['\\n'] if num_bbox!=(bbox_idx+1) else [''])\n                annot = ' '.join(annot)\n                annot = annot.strip(' ')\n                f.write(annot)\n    return ''\n\ndf1 = df_train[df_train.fold != VALIDATION_FOLD]\nfor row_idx in tqdm(range(len(df1))):\n    row = df1.iloc[row_idx]\n    shutil.copyfile(row.image_path, f'{IMAGE_DIR}\/train\/{row.image_id}.jpg')\n    writeLabels(row.bboxes, f'{LABEL_DIR}\/train\/{row.image_id}.txt')\n\ndf2 = df_train[df_train.fold == VALIDATION_FOLD]\nfor row_idx in tqdm(range(len(df2))):\n    row = df2.iloc[row_idx]\n    shutil.copyfile(row.image_path, f'{IMAGE_DIR}\/valid\/{row.image_id}.jpg')\n    writeLabels(row.bboxes, f'{LABEL_DIR}\/valid\/{row.image_id}.txt')","664f098f":"%cd yolov5","82917c12":"!python -m wandb disabled\n\n!python train.py \\\n    --img 1280 \\\n    --batch 16 \\\n    --epochs 1 \\\n    --data data\/cots.yaml \\\n    --cfg yolov5s.yaml \\\n    --weights yolov5s.pt \\\n    --name cots_with_albs \\\n    --hyp data\/hyps\/hyps_custom.yaml","88586b73":"TRAIN_RUN_DIR = \"\/kaggle\/working\/yolov5\/runs\/train\/cots_with_albs\"","effd5e0a":"!ls {TRAIN_RUN_DIR}","695ed80f":"plt.figure(figsize=(30,15))\nplt.axis('off')\nplt.imshow(plt.imread(f'{TRAIN_RUN_DIR}\/train_batch0.jpg'));","fcdf6a30":"plt.figure(figsize=(30,15))\nplt.axis('off')\nplt.imshow(plt.imread(f'{TRAIN_RUN_DIR}\/train_batch1.jpg'));","2352d9f8":"plt.figure(figsize=(30,15))\nplt.axis('off')\nplt.imshow(plt.imread(f'{TRAIN_RUN_DIR}\/train_batch2.jpg'));","8506314f":"%cd \/kaggle\/working\n\n!cp -r \/kaggle\/working\/yolov5\/runs\/train\/cots_with_albs \/kaggle\/working\n\n!cp \/kaggle\/working\/yolov5\/data\/cots.yaml \/kaggle\/working\/cots_with_albs\/\n!cp \/kaggle\/working\/yolov5\/data\/hyps\/hyps_custom.yaml \/kaggle\/working\/cots_with_albs\/\n!cp \/kaggle\/working\/yolov5\/utils\/augmentations.py \/kaggle\/working\/cots_with_albs\/\n\n!rm -r \/kaggle\/working\/yolov5\n!rm -r \/kaggle\/working\/images\n!rm -r \/kaggle\/working\/labels","d612d53d":"## Setting your custom Albumentations","d6a9d858":"### Yolov5's hyperparameters file","84cdf424":"# Define Model YAML for 1 class","3163fe7b":"# View your Albumentations","25cf8246":"## Cleanup","6a214e2d":"### Bake your custom albumentations into Yolov5's augmentations.py script","5a1c4f76":"# Yolov5 training with Albumentations\n\n## Why this notebook?\n* There are no notebooks that show how to integrate custom augmentations into the Yolov5 training pipeline\n* Others bake the augmentations to the data prior to training.\n* This notebook shows you how to apply augmentations from the Albumentations package on the fly using yolov5's Albumentations integration","4b58d4b5":"### Write yaml files","98349153":"# Yolov5 Setup and Albumentations","55fef8dc":"# Training the Model","8b9e7e3c":"Forked from: https:\/\/www.kaggle.com\/steamedsheep\/yolov5-high-resolution-training but extensively modified using my private notebooks","c5337d88":"### For demo purposes, only 1 epoch of yolov5s trained @ 1280p to make this notebook run quickly","a54d20ae":"## Modules Required","11e8d512":"## Data Prep\n\n* This data prep uses 5-fold split using \"sequence\"\n* Fold 4 is used as validation dataset"}}