{"cell_type":{"105ada4c":"code","7f3a36b9":"code","ff2f5618":"code","e6ee060a":"code","de57e1c4":"code","33caf855":"code","62eca6d5":"code","3e56c369":"code","afb732c0":"code","6bab67e1":"code","b4351bde":"code","96f00c92":"markdown","ab9fde82":"markdown"},"source":{"105ada4c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","7f3a36b9":"# Load the dataset from the csv file using pandas\ndata = pd.read_csv('\/kaggle\/input\/creditcardfraud\/creditcard.csv')","ff2f5618":"data.head(10)","e6ee060a":"# Start exploring the dataset\nprint(data.columns)","de57e1c4":"# Print the shape of the data\ndata = data.sample(frac=0.1, random_state = 1)\nprint(data.shape)\nprint(data.describe())\n\n# V1 - V28 are the results of a PCA Dimensionality reduction to protect user identities and sensitive features","33caf855":"# Plot histograms of each parameter \n\ndata.hist(figsize = (20, 20))\nplt.show()","62eca6d5":"# Determine number of fraud cases in dataset\n\nFraud = data[data['Class'] == 1]\nValid = data[data['Class'] == 0]\n\noutlier_fraction = len(Fraud)\/float(len(Valid))\nprint(outlier_fraction)\n\nprint('Fraud Cases: {}'.format(len(data[data['Class'] == 1])))\nprint('Valid Transactions: {}'.format(len(data[data['Class'] == 0])))\n\n","3e56c369":"# Correlation matrix\ncorrmat = data.corr()\nfig = plt.figure(figsize = (12, 9))\n\nsns.heatmap(corrmat, vmax = .8, square = True)\nplt.show()","afb732c0":"# Get all the columns from the dataFrame\ncolumns = data.columns.tolist()\n\n# Filter the columns to remove data we do not want\ncolumns = [c for c in columns if c not in [\"Class\"]]\n\n# Store the variable we'll be predicting on\ntarget = \"Class\"\n\nX = data[columns]\nY = data[target]\n\n# Print shapes\nprint(X.shape)\nprint(Y.shape)","6bab67e1":"from sklearn.metrics import classification_report, accuracy_score\nfrom sklearn.ensemble import IsolationForest\nfrom sklearn.neighbors import LocalOutlierFactor\n\n# define random states\nstate = 1\n\n# define outlier detection tools to be compared\nclassifiers = {\n    \"Isolation Forest\": IsolationForest(max_samples=len(X),\n                                        contamination=outlier_fraction,\n                                        random_state=state),\n    \"Local Outlier Factor\": LocalOutlierFactor(\n        n_neighbors=20,\n        contamination=outlier_fraction)}","b4351bde":"# Fit the model\nplt.figure(figsize=(9, 7))\nn_outliers = len(Fraud)\n\n\nfor i, (clf_name, clf) in enumerate(classifiers.items()):\n    \n    # fit the data and tag outliers\n    if clf_name == \"Local Outlier Factor\":\n        y_pred = clf.fit_predict(X)\n        scores_pred = clf.negative_outlier_factor_\n    else:\n        clf.fit(X)\n        scores_pred = clf.decision_function(X)\n        y_pred = clf.predict(X)\n    \n    # Reshape the prediction values to 0 for valid, 1 for fraud. \n    y_pred[y_pred == 1] = 0\n    y_pred[y_pred == -1] = 1\n    \n    n_errors = (y_pred != Y).sum()\n    \n    # Run classification metrics\n    print('{}: {}'.format(clf_name, n_errors))\n    print(accuracy_score(Y, y_pred))\n    print(classification_report(Y, y_pred))\n","96f00c92":"Now that we have processed our data, we can begin deploying our machine learning algorithms. We will use the following techniques:\n\n**Local Outlier Factor (LOF)**\n\nThe anomaly score of each sample is called Local Outlier Factor. It measures the local deviation of density of a given sample with respect to its neighbors. It is local in that the anomaly score depends on how isolated the object is with respect to the surrounding neighborhood.\n\n**Isolation Forest Algorithm**\n\nThe IsolationForest \u2018isolates\u2019 observations by randomly selecting a feature and then randomly selecting a split value between the maximum and minimum values of the selected feature.\n\nSince recursive partitioning can be represented by a tree structure, the number of splittings required to isolate a sample is equivalent to the path length from the root node to the terminating node.\n\nThis path length, averaged over a forest of such random trees, is a measure of normality and our decision function.\n\nRandom partitioning produces noticeably shorter paths for anomalies. Hence, when a forest of random trees collectively produce shorter path lengths for particular samples, they are highly likely to be anomalies.","ab9fde82":"# **Unsupervised Outlier Detection**"}}