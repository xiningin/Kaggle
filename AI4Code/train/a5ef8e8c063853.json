{"cell_type":{"31a7f00d":"code","772cb758":"code","2f2dcc25":"code","0b77b39b":"code","93c00278":"code","b4c68ff6":"code","61e0d46a":"code","c0e5bd32":"code","f8a2cc80":"code","4fcad14c":"code","f638b625":"code","153a1535":"code","565823f2":"code","14659b9e":"code","c19c24c6":"code","47c3d6f2":"code","b8f551d8":"code","78c7ccc9":"code","187f8342":"code","cf8f19c5":"code","132ae7ab":"code","4328c0e1":"code","66fed6f2":"code","4fd83c42":"code","3b35c2f9":"code","e0247476":"code","799035c6":"code","81f46bc6":"code","407f1751":"code","8789a052":"code","6ac482b5":"code","7859bf26":"code","f1d24047":"code","d397265f":"code","6d9c4c78":"code","131e6e87":"code","c284e5ea":"code","aff263c9":"code","4a55f316":"markdown","d14c0647":"markdown","12de72a0":"markdown","f817c0d5":"markdown","6ededdb5":"markdown","d22815a6":"markdown","d437dab8":"markdown","f690059d":"markdown","d37fc557":"markdown","15105a0c":"markdown","0dcd056e":"markdown"},"source":{"31a7f00d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","772cb758":"import datetime as dt\nimport pandas as pd\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\npd.set_option('display.float_format', lambda x: '%.5f' % x)","2f2dcc25":"pip install openpyxl","0b77b39b":"df = pd.read_excel('\/kaggle\/input\/uci-online-retail-ii-data-set\/online_retail_II.xlsx', sheet_name='Year 2010-2011')","93c00278":"df_ = df.copy()","b4c68ff6":"df.head()","61e0d46a":"df.shape","c0e5bd32":"df.describe().T","f8a2cc80":"df[\"Description\"].nunique() # what is the number of unique products?","4fcad14c":"df[\"Description\"].value_counts().head() # how many products are there?","f638b625":"df.groupby(\"Description\").agg({\"Quantity\":\"sum\"}).head() # what is the most ordered product?","153a1535":"df.groupby(\"Description\").agg({\"Quantity\":\"sum\"}).sort_values(\"Quantity\", ascending = False).head() #how do we sort the output above?","565823f2":"df[\"Invoice\"].nunique() #how many invoices have been cut in total?","14659b9e":"# how much money has been earned per invoice? (it is necessary to create a new variable by multiplying two variables)\n#to find out how much money has been earned, \"quantity * price\" must be made.\ndf[\"TotalPrice\"] = df[\"Quantity\"] * df[\"Price\"]","c19c24c6":"df.head() # Dataframe\" Total Price \" variable added. This variable was studied through the first 5 observations.","47c3d6f2":"df.groupby(\"Invoice\").agg({\"TotalPrice\":\"sum\"}).head() #calculated the total amount of money earned per invoice.","b8f551d8":"df.groupby(\"Description\").agg({\"Price\":\"max\"}).sort_values(\"Price\", ascending = False).head() # what are the most expensive products?","78c7ccc9":"df.sort_values(\"Price\", ascending = False).head() # what are the most expensive products?","187f8342":"df[\"Country\"].value_counts().head() #how many orders came from what country?","cf8f19c5":"returned = df[df[\"Invoice\"].str.contains(\"C\",na=False)]\nreturned.sort_values(\"Quantity\", ascending = True).head() # which product gets the most returns?","132ae7ab":"df.isnull().sum() #Its asks the question of whether there are any missing observations","4328c0e1":"df.dropna(inplace=True) #erases incomplete observations.\n\ndf = df[~df[\"Invoice\"].str.contains(\"C\", na=False)]\ndf = df[(df['Quantity'] > 0)]\ndf = df[(df['Price'] > 0)]\n\ndf.head()\n","66fed6f2":"df[\"TotalPrice\"] = df[\"Quantity\"] * df[\"Price\"]","4fd83c42":"df[\"InvoiceDate\"].max()","3b35c2f9":"today_date = dt.datetime(2011, 12, 11)\n\n\nrfm = df.groupby('Customer ID').agg({'InvoiceDate': lambda InvoiceDate: (today_date - InvoiceDate.max()).days,\n                                     'Invoice': lambda Invoice: Invoice.nunique(),\n                                     'TotalPrice': lambda TotalPrice: TotalPrice.sum()})\n\nrfm.head()","e0247476":"rfm.columns = ['recency', 'frequency', 'monetary']","799035c6":"rfm[\"recency_score\"] = pd.qcut(rfm['recency'], 5, labels=[5, 4, 3, 2, 1])\n\n\nrfm[\"frequency_score\"] = pd.qcut(rfm['frequency'].rank(method=\"first\"), 5, labels=[1, 2, 3, 4, 5])","81f46bc6":"rfm[\"monetary_score\"] = pd.qcut(rfm['monetary'], 5, labels=[1, 2, 3, 4, 5])\n\nrfm[\"RFM_SCORE\"] = (rfm['recency_score'].astype(str) +\n                    rfm['frequency_score'].astype(str))\n\nrfm.head()\n\nrfm.describe().T\n\nrfm[rfm[\"RFM_SCORE\"] == \"55\"].head()\n\nrfm[rfm[\"RFM_SCORE\"] == \"11\"].head()","407f1751":"seg_map = {\n    r'[1-2][1-2]': 'hibernating',\n    r'[1-2][3-4]': 'at_Risk',\n    r'[1-2]5': 'cant_loose',\n    r'3[1-2]': 'about_to_sleep',\n    r'33': 'need_attention',\n    r'[3-4][4-5]': 'loyal_customers',\n    r'41': 'promising',\n    r'51': 'new_customers',\n    r'[4-5][2-3]': 'potential_loyalists',\n    r'5[4-5]': 'champions'\n}\n# Here classes are assigned according to rfm scores. Below is the December score for these classes.\n# As an example, the Hibernating class has the following score values.\n# The Recency value is 1-2, the Frequency value is 1-2, which is read this way in other classes.\n#The reason why only Recency and Frequency are added here is because only these two parameters are included in the table, but Monetary can also be added to them.","8789a052":"rfm['segment'] = rfm['RFM_SCORE'].replace(seg_map, regex=True)\n\nrfm.head()","6ac482b5":"rfm[[\"segment\", \"recency\", \"frequency\", \"monetary\"]].groupby(\"segment\").agg([\"mean\", \"count\"])","7859bf26":"rfm[rfm[\"segment\"] == \"need_attention\"].head()","f1d24047":"rfm[rfm[\"segment\"] == \"new_customers\"].index","d397265f":"new_df = pd.DataFrame()\nnew_df[\"new_customer_id\"] = rfm[rfm[\"segment\"] == \"new_customers\"].index\n\nnew_df.to_csv(\"new_customers.csv\")","6d9c4c78":"df[\"InvoiceDate\"].min() ","131e6e87":"def create_rfm(dataframe):\n\n    # PREPARING THE DATA\n    dataframe.dropna(inplace=True)\n    dataframe = dataframe[~dataframe[\"Invoice\"].str.contains(\"C\", na=False)]\n    dataframe = dataframe[(dataframe['Quantity'] > 0)]\n    dataframe = dataframe[(dataframe['Price'] > 0)]\n    dataframe[\"TotalPrice\"] = dataframe[\"Quantity\"] * dataframe[\"Price\"]\n\n    # CALCULATION OF RFM METRICS\n    today_date = dt.datetime(2011, 12, 11)\n    rfm = dataframe.groupby('Customer ID').agg({'InvoiceDate': lambda date: (today_date - date.max()).days,\n                                                'Invoice': lambda num: num.nunique(),\n                                                \"TotalPrice\": lambda price: price.sum()})\n    rfm.columns = ['recency', 'frequency', \"monetary\"]\n    rfm = rfm[(rfm['monetary'] > 0)]\n\n    # CALCULATION OF RFM SCORES\n    rfm[\"recency_score\"] = pd.qcut(rfm['recency'], 5, labels=[5, 4, 3, 2, 1])\n    rfm[\"frequency_score\"] = pd.qcut(rfm[\"frequency\"].rank(method=\"first\"), 5, labels=[1, 2, 3, 4, 5])\n    rfm[\"monetary_score\"] = pd.qcut(rfm['monetary'], 5, labels=[1, 2, 3, 4, 5])\n\n\n    rfm[\"RFM_SCORE\"] = (rfm['recency_score'].astype(str) +\n                        rfm['frequency_score'].astype(str))\n\n\n    # NAMING OF SEGMENTS\n    seg_map = {\n        r'[1-2][1-2]': 'hibernating',\n        r'[1-2][3-4]': 'at_risk',\n        r'[1-2]5': 'cant_loose',\n        r'3[1-2]': 'about_to_sleep',\n        r'33': 'need_attention',\n        r'[3-4][4-5]': 'loyal_customers',\n        r'41': 'promising',\n        r'51': 'new_customers',\n        r'[4-5][2-3]': 'potential_loyalists',\n        r'5[4-5]': 'champions'\n    }\n\n    rfm['segment'] = rfm['RFM_SCORE'].replace(seg_map, regex=True)\n    rfm = rfm[[\"recency\", \"frequency\", \"monetary\", \"segment\"]]\n    return rfm\n\ndf = df_.copy()\nrfm_new = create_rfm(df)\nrfm_new.head()","c284e5ea":"rfm_final=create_rfm(df_)","aff263c9":"rfm_final.head()","4a55f316":"# Customer Segmentation","d14c0647":"# Variables\n\u25cf InvoiceNo\u200a-\u200aInvoice Number\nIf this code starts with C, it means that the operation is canceled.\n\n\u25cf StockCode\u200a-\u200aProduct Code\nUnique number for each product.\n\n\u25cf Description\u200a-\u200aProduct Name\n\n\u25cfQuantity\u200a-\u200aNumber of Products\nIt expresses how many of the products on the invoices have been sold.\n\n\u25cf InvoiceDate\u200a-\u200aInvoice Date\n\n\u25cf UnitPrice\u200a-\u200aInvoice Price (Sterling)\n\n\u25cf CustomerID\u200a-\u200aUnique Customer Number\n\n\u25cf Country\u200a-\u200aCountry Name","12de72a0":"The dataset named \"Online Retail II\" includes the sales of a UK-based online store between 01\/12\/2009\u201309\/12\/2011. This company sells souvenirs. Think of it as promotional items. Most of their customers are wholesalers.","f817c0d5":"# Functionalization of the Process","6ededdb5":"# Incomplete Observation Analysis","d22815a6":"# Data Understanding","d437dab8":"# Recency-Frequency-Monetary","f690059d":"# What is RFM Analysis?","d37fc557":"![1_MC8qQgH04qHDA7LvFzudgw.png](attachment:cbdd72e6-08fd-4615-bc77-0cf962620366.png)","15105a0c":"The RFM model is a customer segmentation technique. RFM stands for Recency, Frequency, and Monetary value, each corresponding to some key customer trait. These RFM metrics are important indicators of a customer's behavior because frequency and monetary value affects a customer's lifetime value, and recency affects retention, a measure of engagement.","0dcd056e":"# Recency Score"}}