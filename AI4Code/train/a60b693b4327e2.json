{"cell_type":{"95dc3404":"code","4e9cd59d":"code","d6c454a4":"code","e42d7ddf":"code","fb53b3e8":"code","06a1c331":"code","37ca4930":"code","d7445be0":"code","0c1bab97":"code","bb776de2":"code","52e7a013":"code","ba596911":"code","bb32ab4d":"code","bc6fcc0b":"code","ad6b01de":"code","a779b93f":"code","11b2d246":"code","ab9e5353":"code","1d4c8fa8":"markdown","3e96441d":"markdown","89c75e01":"markdown","efd007bd":"markdown","1a38927e":"markdown","aae62f05":"markdown"},"source":{"95dc3404":"from PIL import Image \nImage.open(\"\/kaggle\/input\/rule-based-image\/rule-based-classification.png\")","4e9cd59d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d6c454a4":"# Installing required libraries\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing\nimport seaborn as sns # data visualization\nfrom matplotlib import pyplot as plt\n\n# Making the appearance settings of the printouts\n\npd.set_option('display.width', 500) \npd.set_option('display.max_columns', 20)\npd.set_option('display.max_rows', 15)\npd.set_option('display.float_format', lambda x: '%.3f' % x)\npd.set_option('display.expand_frame_repr', True)","e42d7ddf":"# Load data into pandas dataframe..\n\ndf = pd.read_csv(\"\/kaggle\/input\/persona\/persona.csv\")\ndf.head()","fb53b3e8":"# Describe of data sets\n\ndef check_df(dataframe):\n    print(f\"\"\"\n        ##################### Shape #####################\\n\\n\\t{dataframe.shape}\\n\\n\n        ##################### Types #####################\\n\\n{dataframe.dtypes}\\n\\n\n        ##################### Head #####################\\n\\n{dataframe.head(3)}\\n\\n\n        ##################### NA #####################\\n\\n{dataframe.isnull().sum()}\\n\\n\n        ##################### Quantiles #####################\\n\\n{dataframe.quantile([0, 0.05, 0.50, 0.95, 0.99, 1]).T}\\n\\n\"\"\")\ncheck_df(df)","06a1c331":"# Selection of Categorical and Numerical Variables\n# Let's define a function to perform the selection of numeric and categorical variables in the data set in a parametric way.\n\ndef grab_col_names(dataframe, cat_th=10, car_th=20):\n    \"\"\"\n    It gives the names of categorical, numerical and categorical but cardinal variables in the data set.\n    Note: Categorical variables with numerical appearance are also included in categorical variables.\n    Parameters\n    ------\n        dataframe: dataframe\n                The dataframe from which variable names are to be retrieved\n        cat_th: int, optional\n                For variables that are numeric but categorical\n        car_th: int, optional\n                For variables that are categorical but numeric\n    Returns\n    ------\n        cat_cols: list\n                Categorical variable list\n        num_cols: list\n                Numeric variable list\n        cat_but_car: list\n                Categorical view cardinal variable list\n    Examples\n    ------\n        import seaborn as sns\n        df = sns.load_dataset(\"iris\")\n        print(grab_col_names(df))\n    Notes\n    ------\n        cat_cols + num_cols + cat_but_car = total number of variables\n        num_but_cat in cat_cols\n    \"\"\"\n\n    # cat_cols, cat_but_car\n    cat_cols = [col for col in dataframe.columns if dataframe[col].dtypes == \"O\"]\n\n    num_but_cat = [col for col in dataframe.columns if dataframe[col].nunique() < cat_th and\n                   dataframe[col].dtypes != \"O\"]\n\n    cat_but_car = [col for col in dataframe.columns if dataframe[col].nunique() > car_th and\n                   dataframe[col].dtypes == \"O\"]\n\n    cat_cols = cat_cols + num_but_cat\n\n    cat_cols = [col for col in cat_cols if col not in cat_but_car]\n\n    # num_cols\n    num_cols = [col for col in dataframe.columns if dataframe[col].dtypes != \"O\"]\n\n    num_cols = [col for col in num_cols if col not in num_but_cat]\n\n    print(f\"Observations: {dataframe.shape[0]}\")\n    print(f\"Variables: {dataframe.shape[1]}\")\n    print(f'cat_cols: {len(cat_cols)}')\n    print(f'num_cols: {len(num_cols)}')\n    print(f'cat_but_car: {len(cat_but_car)}')\n    print(f'num_but_cat: {len(num_but_cat)}')\n\n    return cat_cols, num_cols, cat_but_car\n\n\ncat_cols, num_cols, cat_but_car = grab_col_names(df)","37ca4930":"# General Exploration for Categorical Data\n\ndef cat_summary(dataframe, plot=False):\n    # cat_cols = grab_col_names(dataframe)[\"Categorical_Data\"]\n    for col_name in cat_cols:\n        print(\"############## Unique Observations of Categorical Data ###############\")\n        print(\"The unique number of \" + col_name + \": \" + str(dataframe[col_name].nunique())+\"\\n\\n\")\n\n        print(\"############## Frequency of Categorical Data ########################\")\n        print(pd.DataFrame({col_name: dataframe[col_name].value_counts(),\n                            \"Ratio\": dataframe[col_name].value_counts() \/ len(dataframe)}))\n        if plot:  # plot == True (Default)\n            sns.countplot(x=dataframe[col_name], data=dataframe)\n            plt.show()\n\n\ncat_summary(df, plot=True)","d7445be0":"# General Exploration for Numerical Data\n\ndef num_summary(dataframe, plot=False):\n    numerical_col = ['PRICE', 'AGE']  ##or grab_col_names(dataframe)[\"Numerical_Data\"]\n    quantiles = [0.25, 0.50, 0.75, 1]\n    for col_name in numerical_col:\n        print(\"########## Summary Statistics of \" + col_name + \" ############\"+\"\\n\\n\")\n        print(dataframe[numerical_col].describe(quantiles).T)\n\n        if plot:\n            sns.histplot(data=dataframe, x=col_name)\n            plt.xlabel(col_name)\n            plt.title(\"The distribution of \" + col_name)\n            plt.grid(True)\n            plt.show(block=True)\n\n\nnum_summary(df, plot=True)","0c1bab97":"######### Analysis of the data set ########\n\ndef analysis_df(dataframe):\n    print(f\"\"\"\n        ###### Unique Value of Source ######\\n\\n\\t{dataframe[\"SOURCE\"].unique()}\\n\\n\n        ###### Frequency of Source ######\\n\\n\\t{dataframe[\"SOURCE\"].value_counts()}\\n\\n\n        {dataframe.groupby(\"SOURCE\").count()}\\n\\n\n        ###### Unique Value and Count of Price ######\\n\\n\\t{dataframe[\"PRICE\"].unique()}\\n\\n\n        {dataframe.groupby(\"PRICE\").count()}\\n\\n\n        ###### Sales by Country ######\\n\\n\\t{dataframe.groupby(\"COUNTRY\")[\"PRICE\"].count()}\\n\\n\n        ###### Total Sales by Country ######\\n\\n\\t{dataframe.groupby(\"COUNTRY\")[\"PRICE\"].sum()}\\n\\n\n        ###### Sales by Source ######\\n\\n\\t{dataframe.groupby(\"SOURCE\")[\"PRICE\"].count()}\\n\\n\n        ###### Mean of Sales by Country ######\\n\\n\\t{dataframe.groupby(\"COUNTRY\")[\"PRICE\"].mean()}\\n\\n\n        ###### Mean of Sales by Source ######\\n\\n\\t{dataframe.groupby(\"SOURCE\")[\"PRICE\"].mean()}\\n\\n\n        ###### mean of Sales by Source and Country ######\\n\\n\\t{dataframe.groupby([\"SOURCE\", \"COUNTRY\"])[\"PRICE\"].mean()}\\n\\n\"\"\")\n    \nanalysis_df(df)","bb776de2":"# Mean of sales by source,country,sex and age as descending order\n\nagg_df = df.groupby([\"COUNTRY\",\"SOURCE\",\"SEX\",\"AGE\"]).agg({\"PRICE\": \"mean\"}).sort_values((\"PRICE\"),\n                                                                                        ascending=False)\n\nagg_df.head()","52e7a013":"# As we can see in the output above; variables other than price are included in the index. So we should fix that.\nagg_df = agg_df.reset_index()","ba596911":"# Let's define new level-based customers (personas) by using Country, Source, Age and Sex.\n# But, firstly we need to convert age variable to categorical data.\n\nbins = [agg_df[\"AGE\"].min(), 18, 23, 35, 45, agg_df[\"AGE\"].max()]\nlabels = [str(agg_df[\"AGE\"].min())+'_18', '19_23', '24_35', '36_45', '46_'+ str(agg_df[\"AGE\"].max())]\n\nagg_df[\"AGE_CAT\"] = pd.cut(agg_df[\"AGE\"], bins , labels=labels)\nagg_df.groupby(\"AGE_CAT\").agg({\"PRICE\": [\"min\", \"max\", \"count\"]})","bb32ab4d":"# For creating personas, we group all the features in the dataset:\n\nagg_df = agg_df.groupby([\"COUNTRY\", \"SOURCE\", \"SEX\", \"AGE_CAT\", \"AGE\"])[[\"PRICE\"]].sum().reset_index()\nagg_df[\"CUSTOMERS_LEVEL_BASED\"] = pd.DataFrame([\"_\".join(row).upper() for row in agg_df.values[:,0:4]])\nagg_df.head()","bc6fcc0b":"# Calculating average amount of personas:\n\nagg_df.groupby('CUSTOMERS_LEVEL_BASED').agg({\"PRICE\": \"mean\"})","ad6b01de":"# Group by of personas:\n\nagg_df = agg_df.groupby('CUSTOMERS_LEVEL_BASED').agg({\"PRICE\": \"mean\"}).sort_values((\"PRICE\"),ascending=False).reset_index()\nagg_df.head()","a779b93f":"# Creating Segments Based on Personas\n\nsegment_labels = [\"D\",\"C\",\"B\",\"A\"]\nagg_df[\"SEGMENT\"] = pd.cut(agg_df[\"PRICE\"], 4, labels=segment_labels)\n\nagg_df.groupby(\"SEGMENT\").agg({\"PRICE\": [\"mean\", \"max\", \"sum\"]}).sort_values((\"SEGMENT\"),\n                                                                             ascending=False).reset_index()","11b2d246":"# Demonstrating segments as bars on a chart, where the length of each bar varies based on the value of the customer profile\n   \nplot = sns.barplot(x=\"SEGMENT\", y=\"PRICE\", data=agg_df)\n\nfor bar in plot.patches:\n    plot.annotate(format(bar.get_height(), '.2f'),\n             (bar.get_x() + bar.get_width() \/ 2,\n             bar.get_height()), ha='center', va='center',\n                   size=8, xytext=(0, 8),\n                      textcoords='offset points')","ab9e5353":"# Prediction \n\ndef ruled_based_classification(dataframe):\n\n    def AGE_CAT(age):\n        if age <= 18:\n            AGE_CAT = \"15_18\"\n            return AGE_CAT\n        elif (age > 18 and age <= 23):\n            AGE_CAT = \"19_23\"\n            return AGE_CAT\n        elif (age > 23 and age <= 35):\n            AGE_CAT = \"24_35\"\n            return AGE_CAT\n        elif (age > 35 and age <= 45):\n            AGE_CAT = \"36_45\"\n            return AGE_CAT\n        elif (age > 45 and age <= 66):\n            AGE_CAT = \"46_66\"\n            return AGE_CAT\n\n    COUNTRY = input(\"Enter a country name (USA\/EUR\/BRA\/DEU\/TUR\/FRA):\")\n    SOURCE = input(\"Enter the operating system of phone (IOS\/ANDROID):\")\n    SEX = input(\"Enter the gender (FEMALE\/MALE):\")\n    AGE = int(input(\"Enter the age:\"))\n    AGE_SEG = AGE_CAT(AGE)\n    new_user = COUNTRY.upper() + '_' + SOURCE.upper() + '_' + SEX.upper() + '_' + AGE_SEG\n\n    print(new_user)\n    print(\"Segment:\" + agg_df[agg_df[\"CUSTOMERS_LEVEL_BASED\"] == new_user].loc[:, \"SEGMENT\"].values[0])\n    print(\"Price:\" + str(agg_df[agg_df[\"CUSTOMERS_LEVEL_BASED\"] == new_user].loc[:, \"PRICE\"].values[0]))\n\n    return new_user\n\n\nruled_based_classification(df)","1d4c8fa8":"* > We define a new variable over the variables in the data set like \"COUNTRY\", \"SOURCE\", \"SEX\", \"AGE_CAT\", \"AGE\" . \n* > Thanks to this variable we defined, we will be able to define personas more efficiently.","3e96441d":"* > In the output above, categories were created according to the age variable. \n* > E.g; While the minimum income obtained from the customers in the 15_18 category is 19.000, it is 9.000 for the customers in the 24_35 category.","89c75e01":"**Thank you for taking the time.**","efd007bd":"* > In the output above, the average earnings are calculated based on the personas created.\n* > This analysis support for some strategies even without creating a segment over it but we will be defining 4 different segments for a more detailed analysis.","1a38927e":"* > The segment with the highest average of price; USA_ANDROID_FEMALE_24_35","aae62f05":"# **Rule-Based-Classification**\n \n**Business Problem**\n\nA game company wants to create level-based new customer definitions (personas) by using some features of its customers, and to create segments according to these new customer definitions and to estimate how much the new customers can earn on average according to these segments.\n\n\n**Variables (Features)**\n\n* PRICE: Customer spend amount\n* SOURCE: The type of device the customer is connecting to (IOS\/Android)\n* SEX: Gender of the customer\n* COUNTRY: Country of the customer\n* AGE: Age of the customer"}}