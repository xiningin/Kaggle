{"cell_type":{"24b39278":"code","21262661":"code","a91eb062":"code","13353dc7":"code","12fe614e":"code","8847282d":"code","edbdf94a":"code","6517ece2":"code","3d9f72c9":"code","8184458d":"code","ed658e9e":"code","efbf68aa":"code","76ef80bd":"code","641d1142":"code","a9739a07":"code","c96fa025":"code","9fe1c810":"code","307c3d1f":"code","28ccc907":"code","b9752248":"code","4bcf3ac3":"code","c78656dd":"code","813ed9ca":"code","3c846b59":"code","8a271780":"code","4bf6684b":"code","86a2cf98":"code","98b4d4f2":"code","d6d2ce9d":"code","b5e7aee1":"code","ebf3a4e6":"code","db5bd4cf":"code","21c496a6":"code","0b71d755":"code","3ef458e0":"code","43da541e":"code","bf160439":"code","ef810937":"code","21fbd559":"code","a7833d01":"markdown","15321a84":"markdown","d112a8ad":"markdown","990a33f6":"markdown","6294bd58":"markdown","f26654e9":"markdown","00b505b3":"markdown","5e005b44":"markdown","e77a6cf1":"markdown","1a6be9b9":"markdown","ba204c7c":"markdown","8625ed72":"markdown","8d3e62e0":"markdown","a0501904":"markdown","91dcd3b7":"markdown","de39e3b7":"markdown","49407306":"markdown","60d3830d":"markdown","8392f6e8":"markdown","2569aa52":"markdown","baec35c5":"markdown","0c86b129":"markdown","abc875a8":"markdown","525c89ef":"markdown","3903eaf9":"markdown","e6ba70bb":"markdown","7aefc584":"markdown","1c21690e":"markdown","ff3c8453":"markdown","7257a91c":"markdown","fbfb5420":"markdown","28fb72dc":"markdown"},"source":{"24b39278":"#Librer\u00edas\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom netCDF4 import Dataset\nimport cartopy.crs as ccrs  # Plot maps\nimport os\nfrom util_img import *\nimport fnmatch #Coincidencia de patrones de nombre de archivos Unix","21262661":"# Par\u00e1metros de las im\u00e1genes (DE DONDE SALEN???)\nnbandas = 16 #Cantidad de bandas del GOES16\n\nhora = 's20180961500406'\n#img_extent = (-5500000, 5500000, -5500000, 5500000) #dimensiones de la escena en m\nimg_extent = (-5434894.67527,5434894.67527,-5434894.67527,5434894.67527)\npsize = 500 # lado de pixel de referencia en m\nN = 5424*4 #numero de pixeles de referencia\n\n# Par\u00e1metros del recorte \n\nfilas = 1440 # filas del recorte para la de referencia\ncolumnas = 1440 # filas del recorte para la de referencia\n\nx0 = 1438000 # Coordenada x del limite superior izquierdo en m\ny0 = -2441000 # Coordenada y del limite superior izquierdo en m\n\nimg_extentr = [x0,x0+columnas*psize,y0-filas*psize,y0]","a91eb062":"# combinaciones de canales\ntotal_canales = ['C01','C02','C03', 'C04','C05','C06', 'C07','C08','C09', 'C10','C11','C12','C13','C14','C15','C16']\ncanal =['C02','C03','C01']\ncanal2 =['C13','C14','C15']\nch_vapor = ['C08','C09','C10'] #distintos niveles de vapor de agua\nch_nyc = ['C04','C05','C06'] #nieve y cirrus\nch_sur = ['C07','C13','C01'] #nubes convectivas, estratos, superficie","13353dc7":"#Creo las matrices donde voy a guardar las imagenes RGB al final\nimagRGB = np.zeros([filas, columnas,3])\nimagRGB2 = np.zeros([filas, columnas,3])\nRGBvapor = np.zeros([filas, columnas,3])\nRGBnyc = np.zeros([filas, columnas,3])\nRGBsur = np.zeros([filas, columnas,3])","12fe614e":"Inbox = \"..\/input\/goes-l1\/GOES_ABIL1nc\/\" #carpeta principal donde estan guardados los archivos","8847282d":"archivo = os.listdir(Inbox)[0]\narchivo","edbdf94a":"if fnmatch.fnmatch(archivo, '*'+total_canales[12]+'*'+hora+'*'):\n    img_name=archivo","6517ece2":"imagenobj = Dataset(Inbox + img_name, 'r')","3d9f72c9":"metadato = imagenobj.variables\nmetadato","8184458d":"metadato['goes_imager_projection']","ed658e9e":"altura = metadato['goes_imager_projection'].perspective_point_height\nsemieje_may = metadato['goes_imager_projection'].semi_major_axis\nsemieje_men = metadato['goes_imager_projection'].semi_minor_axis\nlon_cen = metadato['goes_imager_projection'].longitude_of_projection_origin","efbf68aa":"type(lon_cen)","76ef80bd":"pol=semieje_may*altura\/(semieje_may+altura) #DE DONDE SALE ESTA FORMULA???\necu=semieje_men*altura\/(semieje_may+altura)","641d1142":"metadato['band_id']","a9739a07":"metadato['band_id'][:]","c96fa025":"type(metadato['band_id'][:])","9fe1c810":"icanal = int(metadato['band_id'][:])\nprint ('Canal %d' %icanal)","307c3d1f":"metadato['Rad'][:].shape[0]","28ccc907":"esc= int(N\/metadato['Rad'][:].shape[0])\nNx = int(columnas\/esc) #numero de puntos del recorte en x\nNy = int(filas\/esc) #numero de puntos del recorte en x\nf0 = int((-y0\/psize+N\/2-1.5)\/esc) #fila del angulo superior izquierdo\nc0 = int((x0\/psize+N\/2+.5)\/esc) #columna del angulo superior izquierdo\nf1 = int(f0+Ny) #fila del angulo inferior derecho\nc1 = int(c0+Nx) #columna del angulo inferior derecho","b9752248":"im_rec = metadato['Rad'][:].data[f0:f1,c0:c1]","4bcf3ac3":"im_rec.shape","c78656dd":"plt.figure()\nvmin=im_rec.min()\nvmax=im_rec.max()\n\nif icanal >= 7 :\n    img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys') #emisivas\nelse:\n    img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys_r') #reflectivas\n    \nplt.title('Canal' + str(icanal))\nplt.show()","813ed9ca":"metadato['Rad']","3c846b59":"pendiente= metadato['Rad'].scale_factor\nordenada= metadato['Rad'].add_offset    \n#imag_rad =im_rec*pendiente+ordenada #DN ->mW m-2 sr-1 mum-1\nUnit = \"Radiancia [\"+metadato['Rad'].units+\"]\"","8a271780":"metadato['planck_fk1']","4bf6684b":"metadato['planck_fk1'][0] ","86a2cf98":"if icanal >=7:\n    #Par\u00e1metros de calibracion\n    fk1 = metadato['planck_fk1'][0] # DN -> K\n    fk2 = metadato['planck_fk2'][0]\n    bc1 = metadato['planck_bc1'][0]\n    bc2 = metadato['planck_bc2'][0]\n    imag_cal = (fk2 \/ (np.log((fk1 \/ im_rec) + 1)) - bc1 ) \/ bc2-273.15 # DN -> C\n    Unit = \"Temperatura de Brillo [\u00b0C]\"\nelse:\n    k0=imagenobj.variables['kappa0'][0]\n    imag_cal = im_rec*k0\n    Unit = \"Reflectancia\"","98b4d4f2":"x,y,imag_calm =muestreo(range(f0,f1),range(c0,c1),imag_cal,esc=esc)","d6d2ce9d":"vmin = 0\nvmax = imag_calm[1000:,:600].max()\nimag_calm = realce_lineal(vmin,vmax,imag_calm)","b5e7aee1":"plt.figure()\ncrs=ccrs.Geostationary(central_longitude=lon_cen, satellite_height=altura) #proyeccion geoestacionaria para Goes16\nax = plt.axes(projection=crs)\n            # ax = plt.axes(projection=ccrs.Geostationary(central_longitude=lon_cen)) #proyeccion geoestacionaria para Goes16\nax.gridlines() #agrega linea de meridianos y paralelos \nax.coastlines(resolution='10m',color='blue') #agrega l\u00edneas de costa\nimg = plt.imshow(RGBvapor,extent=img_extentr)\nplt.show()","ebf3a4e6":"for i in range(3):\n    for file_name in os.listdir(Inbox):\n        if fnmatch.fnmatch(file_name, '*'+ch_vapor[i]+'*'+hora+'*'):\n            img_name=file_name\n            \n            print ('Importando la imagen: %s' %img_name)\n            imagenobj = Dataset(Inbox + img_name, 'r')\n\n            print ('Importando las variables de la imagen: %s' %img_name)\n            metadato = imagenobj.variables\n            altura=metadato['goes_imager_projection'].perspective_point_height\n            semieje_may=metadato['goes_imager_projection'].semi_major_axis\n            semieje_men=metadato['goes_imager_projection'].semi_minor_axis\n            lon_cen=metadato['goes_imager_projection'].longitude_of_projection_origin\n            pol=semieje_may*altura\/(semieje_may+altura) #DE DONDE SALE ESTA FORMULA???\n            ecu=semieje_men*altura\/(semieje_may+altura)\n            #img_extent = (-ecu,ecu,-pol,pol)\n            #img_extent = (-pol,pol,-ecu,ecu)\n            icanal = int(metadato['band_id'][:])\n            print ('Canal %d' %icanal)\n\n# Recortes crudos\n            esc=int(N\/metadato['Rad'][:].shape[0])\n            Nx=int(columnas\/esc) #numero de puntos del recorte en x\n            Ny=int(filas\/esc) #numero de puntos del recorte en x\n            f0=int((-y0\/psize+N\/2-1.5)\/esc) #fila del angulo superior izquierdo\n            c0=int((x0\/psize+N\/2+.5)\/esc) #columna del angulo superior izquierdo\n            f1=int(f0+Ny) #fila del angulo inferior derecho\n            c1=int(c0+Nx) #columna del angulo inferior derecho\n\n            im_rec = metadato['Rad'][:].data[f0:f1,c0:c1]\n\n            plt.figure()\n            vmin=im_rec.min()\n            vmax=im_rec.max()\n\n            if icanal >= 7 :\n                img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys') #emisivas\n            else:\n                img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys_r') #reflectivas\n            plt.title(canal[i])\n            plt.show()\n\n            #Calibracion \n            print ('Calibrando la imagen')\n            pendiente= metadato['Rad'].scale_factor\n            ordenada= metadato['Rad'].add_offset    \n            #imag_rad =im_rec*pendiente+ordenada #DN ->mW m-2 sr-1 mum-1\n            Unit = \"Radiancia [\"+metadato['Rad'].units+\"]\"\n\n            if icanal >=7:\n                #Par\u00e1metros de calibracion\n                fk1 = metadato['planck_fk1'][0] # DN -> K\n                fk2 = metadato['planck_fk2'][0]\n                bc1 = metadato['planck_bc1'][0]\n                bc2 = metadato['planck_bc2'][0]\n                imag_cal = (fk2 \/ (np.log((fk1 \/ im_rec) + 1)) - bc1 ) \/ bc2-273.15 # DN -> C\n                Unit = \"Temperatura de Brillo [\u00b0C]\"\n            else:\n                k0=imagenobj.variables['kappa0'][0]\n                imag_cal = im_rec*k0\n                Unit = \"Reflectancia\"\n    \n# print (imagenobj.variables['max_radiance_value_of_valid_pixels'][0])\n            print('Interpolando')\n            x,y,imag_calm =muestreo(range(f0,f1),range(c0,c1),imag_cal,esc=esc)\n\n            print('Realzando')\n            vmin=0\n            vmax=imag_calm[1000:,:600].max()\n            imag_calm=realce_lineal(vmin,vmax,imag_calm)\n\n            RGBvapor[:imag_calm.shape[0],:imag_calm.shape[1],i]=imag_calm\n    \n            del imag_cal,im_rec\n        \n            print(\"Graficando\")\n            plt.figure()\n            crs=ccrs.Geostationary(central_longitude=lon_cen, satellite_height=altura) #proyeccion geoestacionaria para Goes16\n            ax = plt.axes(projection=crs)\n            # ax = plt.axes(projection=ccrs.Geostationary(central_longitude=lon_cen)) #proyeccion geoestacionaria para Goes16\n            ax.gridlines() #agrega linea de meridianos y paralelos \n            ax.coastlines(resolution='10m',color='blue') #agrega l\u00edneas de costa\n            img = plt.imshow(RGBvapor,extent=img_extentr)\n            plt.show()","db5bd4cf":"RGBvapor.shape","21c496a6":"# a)-Distintos nivles de vapor de agua\n\n#Esto me va a servir para probar distintas combinaciones RGB automaticamente:\nfrom itertools import permutations\np = list(permutations(range(3),3)) \n#Me da una lista de 3-tuplas con todas las posibles formas de ordenas los nros 0,1,2\n\nvapor = np.zeros([filas,columnas,3]) # Defino un array nuevo para cargar la imagen ahi\n\nfor i in range(len(p)): \n    # Por ej para la combicion(0,2,1) que es la 2da en la lista 'p' de tuplas\n    # vapor[:,:,0]=sur8, vapor[:,:,2]=sur9, vapor[:,:,1]=sur10\n    \n    vapor[:,:,p[i][0]]=RGBvapor[:,:,0] \n    vapor[:,:,p[i][1]]=RGBvapor[:,:,1] \n    vapor[:,:,p[i][2]]=RGBvapor[:,:,2] \n    plt.figure(i+1)\n    plt.title('Vapor: ' + str(p[i][0])+'=B8, '+str(p[i][1])+'=B9, '+str(p[i][2])+'=B10')\n    plt.imshow(vapor)","0b71d755":"for i in range(3):\n\n    for file_name in os.listdir(Inbox):\n        if fnmatch.fnmatch(file_name, '*'+ch_nyc[i]+'*'+hora+'*'):\n            img_name=file_name\n            \n            print ('Importando la imagen: %s' %img_name)\n            imagenobj = Dataset(Inbox + img_name, 'r')\n\n            print ('Importando las variables de la imagen: %s' %img_name)\n            metadato = imagenobj.variables\n            altura=metadato['goes_imager_projection'].perspective_point_height\n            semieje_may=metadato['goes_imager_projection'].semi_major_axis\n            semieje_men=metadato['goes_imager_projection'].semi_minor_axis\n            lon_cen=metadato['goes_imager_projection'].longitude_of_projection_origin\n            pol=semieje_may*altura\/(semieje_may+altura)\n            ecu=semieje_men*altura\/(semieje_may+altura)\n# img_extent = (-ecu,ecu,-pol,pol)\n# img_extent = (-pol,pol,-ecu,ecu)\n            icanal = int(metadato['band_id'][:])\n            print ('Canal %d' %icanal)\n\n# Recortes crudos\n            esc=int(N\/metadato['Rad'][:].shape[0])\n            Nx=int(columnas\/esc) #numero de puntos del recorte en x\n            Ny=int(filas\/esc) #numero de puntos del recorte en x\n            f0=int((-y0\/psize+N\/2-1.5)\/esc) #fila del angulo superior izquierdo\n            c0=int((x0\/psize+N\/2+.5)\/esc) #columna del angulo superior izquierdo\n            f1=int(f0+Ny) #fila del angulo inferior derecho\n            c1=int(c0+Nx) #columna del angulo inferior derecho\n\n            im_rec = metadato['Rad'][:].data[f0:f1,c0:c1]\n\n            plt.figure()\n            vmin=im_rec.min()\n            vmax=im_rec.max()\n\n            if icanal >= 7 :\n                img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys') #emisivas\n            else:\n                img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys_r') #reflectivas\n            plt.title(icanal)\n            plt.show()\n\n#%%calibracion \n            print ('Calibrando la imagen')\n            pendiente= metadato['Rad'].scale_factor\n            ordenada= metadato['Rad'].add_offset    \n        #imag_rad =im_rec*pendiente+ordenada #DN ->mW m-2 sr-1 mum-1\n            Unit = \"Radiancia [\"+metadato['Rad'].units+\"]\"\n\n            if icanal >=7:\n        #Par\u00e1metros de calibracion\n                fk1 = metadato['planck_fk1'][0] # DN -> K\n                fk2 = metadato['planck_fk2'][0]\n                bc1 = metadato['planck_bc1'][0]\n                bc2 = metadato['planck_bc2'][0]\n                imag_cal = (fk2 \/ (np.log((fk1 \/ im_rec) + 1)) - bc1 ) \/ bc2-273.15 # DN -> C\n                Unit = \"Temperatura de Brillo [\u00b0C]\"\n            else:\n                k0=imagenobj.variables['kappa0'][0]\n                imag_cal = im_rec*k0\n                Unit = \"Reflectancia\"\n    \n    # print (imagenobj.variables['max_radiance_value_of_valid_pixels'][0])\n            print('Interpolando')\n            x,y,imag_calm =muestreo(range(f0,f1),range(c0,c1),imag_cal,esc=esc)\n\n            print('Realzando')\n            vmin=0\n            vmax=imag_calm[1000:,:600].max()\n            imag_calm=realce_lineal(vmin,vmax,imag_calm)\n\n            RGBnyc[:imag_calm.shape[0],:imag_calm.shape[1],i]=imag_calm\n    \n            del imag_cal,im_rec\n        \n            print(\"Graficando\")\n            plt.figure()\n            crs=ccrs.Geostationary(central_longitude=lon_cen, satellite_height=altura) #proyeccion geoestacionaria para Goes16\n            ax = plt.axes(projection=crs)\n            # ax = plt.axes(projection=ccrs.Geostationary(central_longitude=lon_cen)) #proyeccion geoestacionaria para Goes16\n            ax.gridlines() #agrega linea de meridianos y paralelos \n            ax.coastlines(resolution='10m',color='blue') #agrega l\u00edneas de costa\n            img = plt.imshow(RGBnyc,extent=img_extentr)\n            plt.show()","3ef458e0":"#%% b)- Cirrus y nieve\ncyn = np.zeros([filas,columnas,3])\n\nfor i in range(len(p)): \n    cyn[:,:,p[i][0]]=RGBnyc[:,:,0]\n    cyn[:,:,p[i][1]]=RGBnyc[:,:,1]\n    cyn[:,:,p[i][2]]=RGBnyc[:,:,2] \n    plt.figure(i+11)\n    plt.title('Cirrus y nieve: ' + str(p[i][0])+'=B4, '+str(p[i][1])+'=B6, '+str(p[i][2])+'=B5')\n    plt.imshow(cyn)","43da541e":"for i in range(3):\n\n    for file_name in os.listdir(Inbox):\n        if fnmatch.fnmatch(file_name, '*'+ch_sur[i]+'*'+hora+'*'):\n            img_name=file_name\n            \n            print ('Importando la imagen: %s' %img_name)\n            imagenobj = Dataset(Inbox + img_name, 'r')\n\n            print ('Importando las variables de la imagen: %s' %img_name)\n            metadato = imagenobj.variables\n            altura=metadato['goes_imager_projection'].perspective_point_height\n            semieje_may=metadato['goes_imager_projection'].semi_major_axis\n            semieje_men=metadato['goes_imager_projection'].semi_minor_axis\n            lon_cen=metadato['goes_imager_projection'].longitude_of_projection_origin\n            pol=semieje_may*altura\/(semieje_may+altura)\n            ecu=semieje_men*altura\/(semieje_may+altura)\n# img_extent = (-ecu,ecu,-pol,pol)\n# img_extent = (-pol,pol,-ecu,ecu)\n            icanal = int(metadato['band_id'][:])\n            print ('Canal %d' %icanal)\n\n# Recortes crudos\n            esc=int(N\/metadato['Rad'][:].shape[0])\n            Nx=int(columnas\/esc) #numero de puntos del recorte en x\n            Ny=int(filas\/esc) #numero de puntos del recorte en x\n            f0=int((-y0\/psize+N\/2-1.5)\/esc) #fila del angulo superior izquierdo\n            c0=int((x0\/psize+N\/2+.5)\/esc) #columna del angulo superior izquierdo\n            f1=int(f0+Ny) #fila del angulo inferior derecho\n            c1=int(c0+Nx) #columna del angulo inferior derecho\n\n            im_rec = metadato['Rad'][:].data[f0:f1,c0:c1]\n\n            plt.figure()\n            vmin=im_rec.min()\n            vmax=im_rec.max()\n\n            if icanal >= 7 :\n                img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys') #emisivas\n            else:\n                img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys_r') #reflectivas\n            plt.title(icanal)\n            plt.show()\n\n#%%calibracion \n            print ('Calibrando la imagen')\n            pendiente= metadato['Rad'].scale_factor\n            ordenada= metadato['Rad'].add_offset    \n        #imag_rad =im_rec*pendiente+ordenada #DN ->mW m-2 sr-1 mum-1\n            Unit = \"Radiancia [\"+metadato['Rad'].units+\"]\"\n\n            if icanal >=7:\n        #Par\u00e1metros de calibracion\n                fk1 = metadato['planck_fk1'][0] # DN -> K\n                fk2 = metadato['planck_fk2'][0]\n                bc1 = metadato['planck_bc1'][0]\n                bc2 = metadato['planck_bc2'][0]\n                imag_cal = (fk2 \/ (np.log((fk1 \/ im_rec) + 1)) - bc1 ) \/ bc2-273.15 # DN -> C\n                Unit = \"Temperatura de Brillo [\u00b0C]\"\n            else:\n                k0=imagenobj.variables['kappa0'][0]\n                imag_cal = im_rec*k0\n                Unit = \"Reflectancia\"\n    \n    # print (imagenobj.variables['max_radiance_value_of_valid_pixels'][0])\n            print('Interpolando')\n            x,y,imag_calm =muestreo(range(f0,f1),range(c0,c1),imag_cal,esc=esc)\n\n            print('Realzando')\n            vmin=0\n            vmax=imag_calm[1000:,:600].max()\n            imag_calm=realce_lineal(vmin,vmax,imag_calm)\n\n            RGBsur[:imag_calm.shape[0],:imag_calm.shape[1],i]=imag_calm\n    \n            del imag_cal,im_rec\n        \n            print(\"Graficando\")\n            plt.figure()\n            crs=ccrs.Geostationary(central_longitude=lon_cen, satellite_height=altura) #proyeccion geoestacionaria para Goes16\n            ax = plt.axes(projection=crs)\n            # ax = plt.axes(projection=ccrs.Geostationary(central_longitude=lon_cen)) #proyeccion geoestacionaria para Goes16\n            ax.gridlines() #agrega linea de meridianos y paralelos \n            ax.coastlines(resolution='10m',color='blue') #agrega l\u00edneas de costa\n            img = plt.imshow(RGBsur,extent=img_extentr)\n            plt.show()","bf160439":"sup = np.zeros([filas,columnas,3])\n\nfor i in range(len(p)): \n    sup[:,:,p[i][0]]=RGBsur[:,:,0]\n    sup[:,:,p[i][1]]=RGBsur[:,:,1]\n    sup[:,:,p[i][2]]=RGBsur[:,:,2]\n    \n    plt.figure(21+i)\n    plt.title(str(p[i][0])+'=B1, '+str(p[i][1])+'=B7, '+str(p[i][2])+'=B13')\n    plt.imshow(sup)","ef810937":"ch_sup = ['C07','C13','C06'] #superficie\nRGBsup= np.zeros([filas,columnas,3])\nfor i in range(3):\n\n    for file_name in os.listdir(Inbox):\n        if fnmatch.fnmatch(file_name, '*'+ch_sup[i]+'*'+hora+'*'):\n            img_name=file_name\n            \n            print ('Importando la imagen: %s' %img_name)\n            imagenobj = Dataset(Inbox + img_name, 'r')\n\n            print ('Importando las variables de la imagen: %s' %img_name)\n            metadato = imagenobj.variables\n            altura=metadato['goes_imager_projection'].perspective_point_height\n            semieje_may=metadato['goes_imager_projection'].semi_major_axis\n            semieje_men=metadato['goes_imager_projection'].semi_minor_axis\n            lon_cen=metadato['goes_imager_projection'].longitude_of_projection_origin\n            pol=semieje_may*altura\/(semieje_may+altura)\n            ecu=semieje_men*altura\/(semieje_may+altura)\n# img_extent = (-ecu,ecu,-pol,pol)\n# img_extent = (-pol,pol,-ecu,ecu)\n            icanal = int(metadato['band_id'][:])\n            print ('Canal %d' %icanal)\n\n# Recortes crudos\n            esc=int(N\/metadato['Rad'][:].shape[0])\n            Nx=int(columnas\/esc) #numero de puntos del recorte en x\n            Ny=int(filas\/esc) #numero de puntos del recorte en x\n            f0=int((-y0\/psize+N\/2-1.5)\/esc) #fila del angulo superior izquierdo\n            c0=int((x0\/psize+N\/2+.5)\/esc) #columna del angulo superior izquierdo\n            f1=int(f0+Ny) #fila del angulo inferior derecho\n            c1=int(c0+Nx) #columna del angulo inferior derecho\n\n            im_rec = metadato['Rad'][:].data[f0:f1,c0:c1]\n\n            plt.figure()\n            vmin=im_rec.min()\n            vmax=im_rec.max()\n\n            if icanal >= 7 :\n                img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys') #emisivas\n            else:\n                img=plt.imshow(im_rec,vmin=vmin,vmax=vmax,cmap='Greys_r') #reflectivas\n            plt.title(icanal)\n            plt.show()\n\n#%%calibracion \n            print ('Calibrando la imagen')\n            pendiente= metadato['Rad'].scale_factor\n            ordenada= metadato['Rad'].add_offset    \n        #imag_rad =im_rec*pendiente+ordenada #DN ->mW m-2 sr-1 mum-1\n            Unit = \"Radiancia [\"+metadato['Rad'].units+\"]\"\n\n            if icanal >=7:\n        #Par\u00e1metros de calibracion\n                fk1 = metadato['planck_fk1'][0] # DN -> K\n                fk2 = metadato['planck_fk2'][0]\n                bc1 = metadato['planck_bc1'][0]\n                bc2 = metadato['planck_bc2'][0]\n                imag_cal = (fk2 \/ (np.log((fk1 \/ im_rec) + 1)) - bc1 ) \/ bc2-273.15 # DN -> C\n                Unit = \"Temperatura de Brillo [\u00b0C]\"\n            else:\n                k0=imagenobj.variables['kappa0'][0]\n                imag_cal = im_rec*k0\n                Unit = \"Reflectancia\"\n    \n    # print (imagenobj.variables['max_radiance_value_of_valid_pixels'][0])\n            print('Interpolando')\n            x,y,imag_calm =muestreo(range(f0,f1),range(c0,c1),imag_cal,esc=esc)\n\n            print('Realzando')\n            vmin=0\n            vmax=imag_calm[1000:,:600].max()\n            imag_calm=realce_lineal(vmin,vmax,imag_calm)\n\n            RGBsup[:imag_calm.shape[0],:imag_calm.shape[1],i]=imag_calm\n    \n            del imag_cal,im_rec\n        \n            print(\"Graficando\")\n            plt.figure()\n            crs=ccrs.Geostationary(central_longitude=lon_cen, satellite_height=altura) #proyeccion geoestacionaria para Goes16\n            ax = plt.axes(projection=crs)\n            # ax = plt.axes(projection=ccrs.Geostationary(central_longitude=lon_cen)) #proyeccion geoestacionaria para Goes16\n            ax.gridlines() #agrega linea de meridianos y paralelos \n            ax.coastlines(resolution='10m',color='blue') #agrega l\u00edneas de costa\n            img = plt.imshow(RGBsup,extent=img_extentr)\n            plt.show()","21fbd559":"elem = np.zeros([filas,columnas,3])\n\nfor i in range(len(p)): \n    elem[:,:,p[i][0]]=RGBsup[:,:,0]\n    elem[:,:,p[i][1]]=RGBsup[:,:,1]\n    elem[:,:,p[i][2]]=RGBsup[:,:,2]\n    \n    plt.figure(21+i)\n    plt.title(str(p[i][0])+'=B6, '+str(p[i][1])+'=B7, '+str(p[i][2])+'=B13')\n    plt.imshow(elem)","a7833d01":"### Recortes\nRecortamos antes de calibrar porque de lo contrario deberemos abrir y calibrar una imagen de m\u00e1s de 5000x5000 pixeles de tama\u00f1o, proceso que puede ser muy lento y directamente no funcionar en algunas computadoras.\n\nAbrimos la variable __Rad__, que se refiere a las _radiancias_. En t\u00e9rminos f\u00edsicos, la radiancia es la cantidad de radiaci\u00f3n electromagn\u00e9tica que es emitida por un \u00e1rea (flujo radiado), en un \u00e1ngulo s\u00f3lido dado, en una direcci\u00f3n especificada. Vemos que las unidades son $\\frac{mW}{ m^2 cm^{-1}sr}$, donde __mW__ se refiere a miliWatts (unidad de potencia) y __sr__ se refiere al [estereoradi\u00e1n](https:\/\/es.wikipedia.org\/wiki\/Estereorradi%C3%A1n#:~:text=El%20estereorradi%C3%A1n%20(s%C3%ADmbolo%3A%20sr),el%20equivalente%20tridimensional%20del%20radi%C3%A1n.), que es la unidad en la que se miden los \u00e1ngulos s\u00f3lidos. \n","15321a84":"Comprobamos que el recorte tenga las dimensiones que quer\u00edamos","d112a8ad":"![image.png](attachment:image.png)","990a33f6":"2. Importamos el archivo NetCDF. Para eso usamos el m\u00e9todo __Dataset__ que importamos del paquete netCDF4 ([documentaci\u00f3n](https:\/\/unidata.github.io\/netcdf4-python\/netCDF4\/index.html#netCDF4.Dataset)). Le tenemos que pasar la ruta completa de acceso al archivo, la cual se forma con Inbox+el nombre del archivo, y la letra __'r'__ significa *read*, es decir que le estamos pidiendo que _lea_ el archivo.","6294bd58":"### Im\u00e1gen final\nPara plotear la im\u00e1gen georeferenciada utilizaremos la librer\u00eda _Cartopy_ que importamos al principio. ","f26654e9":"Extraemos los siguientes datos, aplicando a la variable _metadato['goes_imager_projection']_ el nombre del dato que queremos extraer\n* altura:\n* semieje mayor:\n* semieje menor:\n* longitud del origen de la proyecci\u00f3n:\n\nTodos estos datos son constantes, n\u00fameros de tipo flotante de 64 d\u00edgitos.","00b505b3":"A continuaci\u00f3n, definimos los par\u00e1metros de las im\u00e1genes.\n* _hora_ : se refiere a la fecha y hora a las que **empez\u00f3** la observaci\u00f3n (s por start); el formato es YYYYJJJHHMMSSs donde YYYY representa el a\u00f1o, JJJ el n\u00famero de d\u00eda del a\u00f1o, HH la hora, MM los minitos y SSs los segundos. Se puede observar que todos los archivos de este dataset corresponden a la misma fecha.\n* _img_extent_ : se refiere a la extensi\u00f3n de la im\u00e1gen, es decir hay que pasarle 'un cuadrado' de coordenadas (__ver bien__)\n* psize: lado de pixel de referencia en m ... ver a que se refiere con referencia\n* N: numero de pixeles de referencia\n\nDado que las imagenes son muy grandes (kmxkm) es dificil trabajar con la imagen entera, por lo tanto no vamos a abrir toda la imagen si no un recorte de la misma, cuyos par\u00e1metros ser\u00e1n:\n* filas: ancho en p\u00edxeles \n* columnas: alto en p\u00edxeles\n* x0 Coordenada x del limite superior izquierdo en m\n* y0  Coordenada y del limite superior izquierdo en m\n* img_extentr: extensi\u00f3n del recorte; debe ser una lista con 4 cooordenadas [x0,x0+columnas*psize,y0-filas*psize,y0]. Las primeras dos marcan desde d\u00f3nde y hasta d\u00f3nde ir\u00e1 el recorte en cuanto a ancho; las ultimas dos marcan hasta d\u00f3nde y desde d\u00f3nde ir\u00e1 el recorte en cuanto a alto.","5e005b44":"5. Con los datos extra\u00eddos, podemos calcular el polo y el ecuador.","e77a6cf1":"Si bien todas las combinaciones son similares, en la combinaci\u00f3n 0=Banda 5, 1=Banda 4, 2=Banda 6 se ven resaltados algunos elementos que con las otras combinaciones no se llegan a apreciar","1a6be9b9":"Vemos en que directorio est\u00e1n guardados los archivos; Kaggle tiene la opci\u00f3n de copiar el directorio.","ba204c7c":"Realce","8625ed72":"Realizamos distintas combinaciones de canales pensando en plotear una imagen RGB, es decir debemos elegir 3 canales para cada combinacion. Los elegi segun los [datos de GOES 16.](http:\/\/cimss.ssec.wisc.edu\/goes\/OCLOFactSheetPDFs\/)\n\n![image.png](attachment:image.png)","8d3e62e0":"Se puede observar que cualquier combinaci\u00f3n resulta en imagenes parecidas pero debido al contraste entre los colores que se presenta creo que la combinaci\u00f3n 0=banda 8, 1=Banda 10, 2=banda 9 es la mejor.","a0501904":"Para extraer el numerito debemos hacer lo siguiente, que vemos que nos devuelve un [_array enmascarado_](https:\/\/numpy.org\/doc\/stable\/reference\/maskedarray.generic.html).","91dcd3b7":"## Abrir varios canales con un loop","de39e3b7":"Con esto, podemos recortarlo extrayendo con el m\u00e9todo _data_ , desde f0 hasta f1 en ancho y desde c0 hasta c1 en alto. Esta ser\u00e1 la imagen (la matriz o array) recortada sin calibrar a\u00fan.","49407306":"Ahora, veamos el siguiente c\u00f3digo por partes. Primero vamos a abrir un solo canal para entender, luego haremos im\u00e1genes compuestas or 3 canales (rgb).\n\n### Georeferenciaci\u00f3n\n    \n1. Le pedimos que se fije si el nombre del archivo que est\u00e1 en _Inbox_ coincide con el que queremos abrir. Para eso usamos el m\u00e9todo _fnmatch_. Creamos a variable img_name (str) con el nombre del archivo.","60d3830d":"### Calibraci\u00f3n","8392f6e8":"3. Abrimos los metadatos, es decir,...... Lo hacemos aplicando el m\u00e9todo _variables_ al objeto tipo NetCDF que importamos, es decir a _imagenobj_. La variable de Python _metadato_ ser\u00e1 un diccionario de Python que almacenar\u00e1 'cosas' de tipo variables netCDF. ","2569aa52":"Se pueden distinguir claramente r\u00edos y otros cursos de agua, junto con lo que podrian ser algunas nubes finas. Tambien una secci\u00f3n que podr\u00eda ser un relieve.","baec35c5":"4. Extraemos los datos, los n\u00fameros: \n\nHaciendo metadato['algo'] le estamos pidiendo que busque en el diccionario metadato lo que sea que est\u00e9 almacenado bajo el key 'algo'(como en cualquier diccionario de Python). Si le pedimos que nos devuelva lo que est\u00e1 bajo el key *'goes_imager_projection'* veremos que nos devuelve una [__variable de netCDF__](https:\/\/unidata.github.io\/netcdf4-python\/netCDF4\/index.html#netCDF4.Variable), que es una estructura parecida a un diccionario de Python com\u00fan. Podemos observar que el nombre de la variable es 'goes_imager_projection' y el nombre largo es _GOES-R ABI fixed grid projection_. Vemos que en esta variable se almacenan todos los datos que necesitaremos para georeferenciar la im\u00e1gen.","0c86b129":"Ahora, abramos todas la imagenes posibles para vapor. Todo est\u00e1 dentro de un loop que pasa a traves de todos los archivos contenidos en el directorio _Inbox_ (Python method listdir()), es decir que el c\u00f3digo que est\u00e1 dentro del loop se aplicar\u00e1 a cada una de las imagenes (canales). El c\u00f3digo que est\u00e1 dentro es el que explicamos anteriormente.","abc875a8":"Interpolaci\u00f3n","525c89ef":"Ahora cambiamos las unidades a unidades de temperatura. Para ello necesitaremos extraer la variable 'planck_fk1' que es wavenumber-dependent coefficient (2 h c2\/ nu3) used in the ABI emissive band monochromatic brightness temperature computation, where nu =central wavenumber and h and c are standard constants. Solo necesitaremos el primer elemento de esta variable, que resulta ser un _masked array_.","3903eaf9":"La mejor combinaci\u00f3n es la tercera, se pueden distinguir varios curos de agua, incluso algunos peque\u00f1os.","e6ba70bb":"# GOES-16: Abrir y referenciar archivos\n\nObjetivo: abrir archivos de tipo CDF, formato en el que vienen los archivos del satelite GOES-16, plotearlos y georeferenciarlos mediante la libreria *Cartopy*.\n\n## Introducci\u00f3n:\n\nAlgo sobre GOES16\nalgo sobre archivos tipo netcdf\n\n\nPara empezar, importamos las librer\u00edas que vamos a usar:","7aefc584":"Para calibrar usaremos la siguiente ecuaci\u00f3n sobre cada pixel:\n    \n    imag_rad = im_rec*pendiente + ordenada #DN ->mW m-2 sr-1 mum-1\n    \ndonde la pendiente ser\u00e1 el metadato __scale_factor__, que es el factor de escala. Esto quiere decir que cada pixel multiplicar\u00e1 su valor (radiancia) por el n\u00famero que obtengamos del factor de escala. La ordenada estar\u00e1 dada por el metadato __add_offset__ que es.....","1c21690e":"Utilizaremos la variable 'Rad', que como vimos contiene las radiancias, es decir lo que capt\u00f3 el sat\u00e9lite, la imagen, junto con otros datos. Podemos observar por ejemplo que contiene las unidades en las que se miden la radiancia.","ff3c8453":"Chequeamos que alguna de las im\u00e1genes tenga la forma que queremos, es decir (filas, columnas, 3 canales)","7257a91c":"Finalemnte ploteamos la imagen. Ac\u00e1 debemos tener una consideraci\u00f3n: las bandas 1 a 7 son emisivas mientras que las bandas 8 a 16 son reflectivas. Esto quiere decir que .......","fbfb5420":"6. Extraemos el n\u00famero de canal del archivo. Ahora sabemos que estamos abriendo el canal 1 pero cuando trabajamos con varias imagenes y canales puede ser confus, por lo que es mejor extraer el canal directamente del archivo netCDF. La banda o canal se encuentra almacenado bajo la llave *'band_id'*. ","28fb72dc":"Lo que nos interesa de esta variabe para hacer el recorte es simplemente la forma o _shape_ de la imagen. Vemos que para un solo canal, es una matriz o array bidimensional cuadrado de 5424 filas x 5424 columnas."}}