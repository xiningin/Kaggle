{"cell_type":{"7eeaed60":"code","641d3738":"code","d7958c76":"code","34efe49d":"code","1bbb9158":"code","c28d8b5e":"code","40deb20d":"code","a956c3c6":"code","32127cc9":"code","1d303d09":"code","29dd3eee":"code","cd09fbae":"code","26016d08":"code","723948e0":"code","1f0eca21":"code","7da09b94":"code","f36921b8":"code","61c42603":"code","a3a405c5":"code","025777b6":"code","a34687c4":"code","621b9561":"code","71278195":"code","3c616ede":"code","848570f0":"code","cd83b384":"code","c8ebd18e":"code","dc7c5287":"code","dff77a96":"code","cd3916c4":"code","8cc04467":"code","337b4cdd":"code","0cf3ca40":"code","3e90a18b":"code","a7828f2d":"code","74497a17":"code","796a0218":"code","c7902ba2":"code","ba0c4d5b":"code","9ec4eca4":"code","a0ae2811":"code","bd38ca0c":"code","3152e440":"code","eb1b0abb":"code","0f578f96":"code","dfee1e72":"code","99e726ba":"code","f40f4567":"code","1c1e3362":"code","f8a7eb4e":"code","1bc7f662":"code","af92b0ff":"code","ea92dace":"code","ad56f147":"code","c6d64eae":"code","e7d2e7ce":"code","61763a07":"code","f8032c29":"code","4c5a5bdf":"code","0137b504":"code","5bdd5881":"code","619a717e":"code","f37d7f0c":"code","00b9377e":"code","41095f52":"code","8200ae4f":"code","ef6d8b87":"code","cd950c9e":"code","8f68bf51":"code","cac03291":"markdown","917100ec":"markdown","52e6f59a":"markdown","62262c0c":"markdown","71a244b6":"markdown","d63aec4d":"markdown","a12177c9":"markdown","ac8c7bb2":"markdown","003f5734":"markdown","0df66510":"markdown","4c468529":"markdown","d9455e2a":"markdown","e806d77f":"markdown","c22eb745":"markdown","c4a7f3e1":"markdown","fa310d4a":"markdown","a1b7ddde":"markdown","93a09d31":"markdown","a39e4ec8":"markdown","58390006":"markdown","df037d6e":"markdown","a31a61df":"markdown"},"source":{"7eeaed60":"# Imports\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pycountry_convert as pc    \nimport plotly.express as px\nimport seaborn as sns\nfrom sklearn.preprocessing import StandardScaler\nimport sklearn.cluster\nimport sklearn.mixture\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.cluster import KMeans\nfrom fbprophet import Prophet       \nfrom fbprophet.plot import plot_plotly  \nfrom scipy.stats import boxcox","641d3738":"# Time series data set for confirmed cases between 22.01.2020 and 28.03.2020\nconfirmed = pd.read_csv('..\/input\/time-series-covid-19-confirmeddeathsrecovered\/time_series_covid19_confirmed_global.csv')\n# Time series data set for death cases between 22.01.2020 and 28.03.2020\ndeaths = pd.read_csv('..\/input\/time-series-covid-19-confirmeddeathsrecovered\/time_series_covid19_deaths_global.csv')\n# Time series data set for recovered cases between 22.01.2020 and 28.03.2020\nrecovered = pd.read_csv('..\/input\/time-series-covid-19-confirmeddeathsrecovered\/time_series_covid19_recovered_global.csv')\n# Total number of death, confirmed,recovered and active cases to 28.03.2020 \ntotal = pd.read_csv('..\/input\/covid19-map\/csse_covid_19_data\/csse_covid_19_daily_reports\/03-28-2020.csv')\n# Time series data set for death cases between 29.03.2020 and 06.04.2020\nfuture_forecast = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_deaths_global.csv')\n# Sars outbreak cases\nsars = pd.read_csv('..\/input\/sars-outbreak-2003-complete-dataset\/sars_2003_complete_dataset_clean.csv')\n# Mers outbreak cases\nmers = pd.read_csv('..\/input\/mers-outbreak-dataset-20122019\/country_count_latest.csv')","d7958c76":"# I converted data set into more sutiable way for future forecasting. \nconfirmed_ff = confirmed.melt(id_vars=[\"Province\/State\", \"Country\/Region\", \"Lat\", \"Long\"],value_vars= confirmed.iloc[:,4:],var_name=\"Date\", value_name=\"Confirmed\")\ndeath_ff = deaths.melt(id_vars=[\"Province\/State\", \"Country\/Region\", \"Lat\", \"Long\"],value_vars= deaths.iloc[:,4:], var_name=\"Date\", value_name=\"Deaths\")\nrecovered_ff = recovered.melt(id_vars=[\"Province\/State\", \"Country\/Region\", \"Lat\", \"Long\"],value_vars= recovered.iloc[:,4:],var_name=\"Date\", value_name=\"Recovered\")\nfuture_forecast = future_forecast.melt(id_vars=[ \"Lat\", \"Long\",\"Country\/Region\"],value_vars= future_forecast.iloc[:,71:78], var_name=\"Date\", value_name=\"Deaths\")\n# I merged confirmed, death and recovered cases in one dataframe called full. Full dataframe will be used in future forecasting stage\nfull = confirmed_ff.merge(death_ff).merge(recovered_ff)\n# Change our feature 'Data' type to datetime\nfull['Date'] = pd.to_datetime(full['Date'])\nfuture_forecast['Date'] = pd.to_datetime(future_forecast['Date'])\n# Organise the column names\nfull = full.rename(columns={\"Province\/State\":\"state\",\"Country\/Region\": \"country\"})\nfuture_forecast = future_forecast.rename(columns = {\"Country\/Region\": \"country\"})\n# New columns is created. Active cases represent people which still suffer from covid 19\nfull['Active'] = full['Confirmed'] - full['Deaths'] - full['Recovered']\n# Fill null values in state column with blank \nfull[['state']] = full[['state']].fillna('')\n# Fill null values in Confirmed, Deaths and Recovered columns with zero\nfull[['Confirmed', 'Deaths', 'Recovered']] = full[['Confirmed', 'Deaths', 'Recovered']].fillna(0)\n# Notice there are some instances which have zero latitude and longtitude. These are ships.  \nfilter1 = full['Lat'] == 0\n# MS Zaandam and Diamond Princess are ships. Time series dataframe for those ships\nship = full.where(filter1).dropna()\n# Drop the ships from our time series dataframe\nfull.drop(ship.index, inplace = True)\nfull.head()","34efe49d":"# Dataframe called total will be used in clustering part\ntotal.drop(['FIPS','Admin2','Last_Update','Combined_Key'],axis = 1,inplace = True)\n# Organise the column names\ntotal= total.rename(columns={\"Province_State\":\"state\",\"Country_Region\": \"country\"})\n# Fill null values in state column with blank \ntotal[['state']] = total[['state']].fillna('')\n# Fill null values in Confirmed, Deaths and Recovered columns with zero\ntotal[['Confirmed', 'Deaths', 'Recovered','Active']] = total[['Confirmed', 'Deaths', 'Recovered','Active']].fillna(0)\n# Notice there are some instances which have zero latitude and longtitude. These are ships.\nfilter1 = total['Lat'] == 0\n# MS Zaandam and Diamond Princess are ships. Total case dataframe for those ships\nship1 = total.where(filter1).dropna()\n# Drop the ships from our total case dataframe\ntotal.drop(ship1.index, inplace = True)\ntotal.head()","1bbb9158":"# Data types of features in the dataframe\nfull.dtypes","c28d8b5e":"# Data types of features in the dataframe\ntotal.dtypes","40deb20d":"# Check the null values in the dataset\nsns.heatmap(full.isnull(), yticklabels = False, cbar = False, cmap = 'viridis')","a956c3c6":"#Check the null values in the dataset\nsns.heatmap(total.isnull(), yticklabels = False, cbar = False, cmap = 'viridis')","32127cc9":"# To give ISO country names to pycountry-convert(for continent names) package, change the name of the some countries\nfull.loc[full['country'] == \"US\", \"country\"] = \"USA\"\nfull.loc[full['country'] == 'Korea, South', \"country\"] = 'South Korea'\nfull.loc[full['country'] == 'Taiwan*', \"country\"] = 'Taiwan'\nfull.loc[full['country'] == 'Congo (Kinshasa)', \"country\"] = 'Democratic Republic of the Congo'\ntotal.loc[total['country'] == \"US\", \"country\"] = \"USA\"\ntotal.loc[total['country'] == 'Korea, South', \"country\"] = 'South Korea'\ntotal.loc[total['country'] == 'Taiwan*', \"country\"] = 'Taiwan'\ntotal.loc[total['country'] == 'Congo (Kinshasa)', \"country\"] = 'Democratic Republic of the Congo'\n","1d303d09":"# Total country which represents total Confirmed, deaths, recovered and active cases for each country\ntotal_country = total.groupby('country')['Confirmed', 'Deaths', 'Recovered', 'Active'].sum().reset_index()\ntotal_country.head()\n","29dd3eee":"# Total numbers for ships\nship_total = ship[ship['Date']==max(ship['Date'])]\nship_total","cd09fbae":"# Population data set\npopulation = pd.read_csv('..\/input\/population-by-country-2020\/population_by_country_2020.csv')\npopulation = population[['Country (or dependency)','Population (2020)', 'Med. Age']]\npopulation.columns= ['country','population','Avrg_age']\npopulation.loc[population['country'] == 'United States', \"country\"] = \"USA\"\npopulation.loc[population['country'] == 'Czech Republic (Czechia)', \"country\"] = 'Czechia'\npopulation.head()","26016d08":"# Healthcare index data set\nhealth = pd.read_html('https:\/\/www.numbeo.com\/health-care\/rankings_by_country.jsp')\nhealth = health[2]\nhealth = health[['Country', 'Health Care Index']]\nhealth.columns= ['country','healthcare_index']\nhealth.loc[health['country'] == 'United States', \"country\"] = \"USA\"\nhealth.loc[health['country'] == 'Czech Republic', \"country\"] = \"Czechia\"\nhealth.head()","723948e0":"# We merge total_country, population and healthcare index data set to find useful clusters in clustering stage\ntotal_country = pd.merge(total_country, population, on='country', how='left',copy = False)\ntotal_country = pd.merge(total_country, health, on='country', how = 'left',copy = False)\n# New column is created for clustering stage: Mortality Rate\ntotal_country['Mortality_rate'] = np.round((total_country['Deaths'] \/ total_country['Confirmed']) *100,2)\ntotal_country.head()","1f0eca21":"# However, there are null values in the merged data set. We handle those null values. We replace these with mean values of the dataframe\ntotal_country['Avrg_age'] = total_country['Avrg_age'].fillna(0)\ntotal_country['Avrg_age'] = total_country['Avrg_age'].replace('N.A.', '0')\n# Change the datatype of average age column\ntotal_country['Avrg_age'] = total_country['Avrg_age'].astype('int')\ntotal_country['healthcare_index'] = total_country['healthcare_index'].replace(np.nan, total_country['healthcare_index'].mean())\ntotal_country['Avrg_age'] = total_country['Avrg_age'].replace(0, total_country['Avrg_age'].mean())\ntotal_country['Avrg_age'] = total_country['Avrg_age'].replace(np.nan, total_country['Avrg_age'].mean())\ntotal_country['population'] = total_country['population'].replace('N.A.', total_country['population'].mean())\ntotal_country['population'] = total_country['population'].replace(np.nan, total_country['population'].mean())\n","7da09b94":"# Change the datatype of healthcare index column\ntotal_country['healthcare_index'] = total_country['healthcare_index'].astype('int')\ntotal_country['Avrg_age'] = total_country['Avrg_age'].astype('int')","f36921b8":"# Use pycountry-convert package to assign continent name to each country. But our function didn't assign some countries to continent names\n# We assign those countries to 'Others'\n# Create dictionary to assing ISO continent name to continents\ncontinents = {\n    'EU' : 'Europe',\n    'SA': 'South America', \n    'OC': 'Australia',\n    'AS': 'Asia',\n    'AF': 'Africa',\n    'NA': 'North America',\n    'Unknown' : 'Others'\n}\n# All of the countries in the data set\ncountries = total_country['country'].unique()\ndef get_continent(country):\n    try:\n        return pc.country_alpha2_to_continent_code(pc.country_name_to_country_alpha2(country))\n    except :\n        return 'Unknown'\n\n#Insert continent column to dataframe\ntotal_country.insert(0,\"continent\", [continents[get_continent(country)] for country in countries])\n","61c42603":"full.head()","a3a405c5":"# Worldwide Confirmed cases between 22.01.2020 and 28.03.2020\ntotal_confirm = full.groupby('Date')['Date', 'Confirmed'].sum().reset_index()\nfig = px.line(total_confirm, x=\"Date\", y=\"Confirmed\", \n              title=\"Worldwide Confirmed Cases Over Time\")\nfig.show()","025777b6":"# Countries with Confirmed Cases\nfigure = px.choropleth(total_country, locations=\"country\", \n                    locationmode='country names', color=\"Confirmed\", \n                    hover_name=\"country\",  range_color=[1,122000],\n                    color_continuous_scale= px.colors.sequential.Viridis, \n                    title='Countries with Confirmed Cases')\nfigure.show()","a34687c4":"# Size of the circle represents the number of the confirmed cases, whereas colour represents the number of the death cases\nfig = px.scatter_geo(total_country, locations=\"country\",locationmode='country names', color=\"Deaths\",\n                     hover_name=\"country\", size=\"Confirmed\",hover_data = ['country','Deaths','Mortality_rate','Confirmed'],\n                     projection=\"natural earth\",title='Countries with Confirmed and Death Cases')\nfig.show()","621b9561":"# Size of the circle represents the number of the confirmed cases, whereas colour represents the number of the recovered cases\nfig = px.scatter_geo(total_country, locations=\"country\",locationmode='country names', color=\"Recovered\",\n                     hover_name=\"country\", size=\"Confirmed\",hover_data = ['country','Recovered', 'Confirmed'],\n                     projection=\"natural earth\",title='Countries with Confirmed and Recovered Cases')\nfig.show()","71278195":"# Countries with active cases\nfig = px.treemap(total_country, path=['continent','country'], values='Active',\n                 height=600,title='Number of Active Cases',color_discrete_sequence = px.colors.qualitative.Dark2)\nfig.data[0].textinfo = 'label+text+value'\nfig.show()","3c616ede":"# Continents with Confirmed Cases\ntotal_continent= total_country.groupby('continent')['continent', 'Confirmed'].sum().reset_index()\nfig = px.bar(total_continent.sort_values('Confirmed', ascending=False)[::-1], x='Confirmed', y='continent',color_discrete_sequence=['#84DCC6'],\n             title='Continents with Confirmed Cases', text='Confirmed', height=500, orientation='h')\nfig.show()","848570f0":"#Confirmed cases in Europe\neurope = total_country[total_country['continent'] == 'Europe']\nfig = px.choropleth(europe, locations=\"country\", \n                    locationmode='country names', color=\"Confirmed\", \n                    hover_name=\"country\", \n                     color_continuous_scale= px.colors.sequential.Viridis, \n                    title='Confirmed cases in Europe', scope='europe', height=800)\nfig.show()","cd83b384":"# Continents with Death Cases\ntotal_continent1= total_country.groupby('continent')['continent', 'Deaths'].sum().reset_index()\nfig = px.bar(total_continent1.sort_values('Deaths', ascending=False)[::-1], x='Deaths', y='continent',color_discrete_sequence=['#D63230'],\n             title='Continents with Deaths Cases', text='Deaths', height=500, orientation='h')\nfig.show()","c8ebd18e":"# Death Cases in Europe\nfig = px.choropleth(europe, locations=\"country\", \n                    locationmode='country names', color=\"Deaths\", \n                    hover_name=\"country\", \n                     color_continuous_scale= px.colors.sequential.Viridis, \n                    title='Death cases in Europe', scope='europe', height=800)\nfig.show()","dc7c5287":"# Create dataframe which consists of three important outbreaks\noutbreaks = {'Outbreaks' : ['COVID19', 'SARS', 'MERS'],\n            'Confirmed' : [total_country['Confirmed'].sum(),sars[sars['Date'] == '2003-07-11']['Cumulative number of case(s)'].sum(),mers['Confirmed'].sum() ]}\ndf = pd.DataFrame(outbreaks, columns = ['Outbreaks', 'Confirmed'])\nfig = px.bar(df.sort_values('Confirmed', ascending=False)[::-1], x='Confirmed', y='Outbreaks',color_discrete_sequence=['#D63230'],\n             title='Three Important Outbreak with Confirmed Cases', text='Confirmed', height=500, orientation='h')\nfig.show()","dff77a96":"# Top 50 Countries with confirmed, deaths and mortality rates \ntotal_country.sort_values('Confirmed', ascending=False)[['country','Confirmed', 'Deaths', 'Mortality_rate']][:50].style.background_gradient(cmap='Reds')","cd3916c4":"# In clustering part we will use first 50 countries with highest confirmed case numbers. \ntotal_50 = total_country.sort_values(by = 'Confirmed', ascending = False).head(50)","8cc04467":"# Feature Correlation map\nsns.heatmap(total_50.corr(), annot=True, cmap=plt.cm.Reds)\nplt.show()","337b4cdd":"# Feature selection respect to correlation map\ndata = total_50[['Mortality_rate','Avrg_age','population','healthcare_index']]","0cf3ca40":"# Describe the dataframe to see variation of the data. Variation in population is high. We must normalize it. \ndata.describe()","3e90a18b":"# Standardisation the data because groups are defined based on the distance between points\nscaler = StandardScaler()\ndata_scaled = scaler.fit_transform(data)\npd.DataFrame(data_scaled).describe()","a7828f2d":"# calculate the sum of squares of the distances of each data points which represents countries\nwcss=[]\nfor i in range(1,11):\n    kmeans = KMeans(n_clusters=i, init='k-means++', max_iter=300, n_init=10)\n    y_means = kmeans.fit(data_scaled)\n    wcss.append(y_means.inertia_)\n# Plot WCSS to find the number of clusters\nplt.plot(range(1,11), wcss)\nplt.xlabel(\"No. of clusters\")\nplt.ylabel(\" Within Cluster Sum of Squares\")\nplt.show()","74497a17":"# Decide the number of clusters. The coefficient varies between -1 and 1. The best value is 1\nsilhoutte=[]\nfor i in range(3,11):\n    kmeans = KMeans(n_clusters=i, init='k-means++', max_iter=300, n_init=10)\n    y_means = kmeans.fit(data_scaled)\n    data_cluster = y_means.predict(data_scaled)\n    silhoutte.append(sklearn.metrics.silhouette_score(data_scaled,data_cluster))\n#Plot silhoutte score to find the number of clusters\nplt.plot(range(3,11), silhoutte)\nplt.xlabel(\"No. of clusters\")\nplt.ylabel(\"Silhoutte Score for each cluster\")\nplt.show()","796a0218":"# Initialise the model with the number of clusters\nk_meansmodel = sklearn.cluster.KMeans(6,init='k-means++')\n# Fit the model\nk_meansmodel.fit(data_scaled)\n# Predict the clusters\ndata_cluster = k_meansmodel.predict(data_scaled)","c7902ba2":"# Visualisation of the clusters is not easy becasue our data have more than 2 dimensions\nplt.figure(figsize=(8, 4))\n# Mortality rate vs average age of the countries\nplt.scatter(data_scaled[:, 0], data_scaled[:, 1], c= data_cluster, cmap = 'rainbow')\nplt.xlabel('Mortality rate')\nplt.ylabel('Average Age')\nplt.title('Visualisation of risk groups based on mortality rate and average age with K-Means clustering')\nplt.show()","ba0c4d5b":"# We grouped countries into 6 groups respecto K-means clustering\nrisk_group= pd.DataFrame()\nrisk_group[\"country\"]=total_50[\"country\"]\nrisk_group[\"risk_group\"]=data_cluster\nfor group in range(0,6):\n    countries=risk_group.loc[risk_group['risk_group']==group]\n    country_list= list(countries['country'])\n    print(\"Group\", group, \":\", country_list)","9ec4eca4":"risk_group['Mortality_rate'] = data_scaled[:,0]\nrisk_group['Avrg_age'] = data_scaled[:,1]\nrisk_group['population'] = data_scaled[:,2]\nrisk_group['healthcare_index'] = data_scaled[:,3]\n\n","a0ae2811":"risk_group[\"risk_group\"] = risk_group[\"risk_group\"].astype(str)\nfig = px.scatter(risk_group, x=\"Mortality_rate\", y=\"Avrg_age\", color=\"risk_group\", hover_name = 'country',category_orders={\"risk_group\": [\"0\", \"1\", \"2\", \"3\", \"4\",\"5\"]},width = 600, height = 400 )\nfig.update_layout(\n    title=\" Visualisation of risk groups based on mortality rate and average age with K-Means clustering\",\n    xaxis_title=\"Mortality rate\",\n    yaxis_title=\"Average Age\",\n    font=dict(\n        size=8,\n        color=\"#7f7f7f\"))\nfig.show()","bd38ca0c":"# Standardize the data because population may dominate the other variables otherwise\nscaler = StandardScaler()\ndata_scaled2 = scaler.fit_transform(data)\npd.DataFrame(data_scaled2).describe()","3152e440":"# Decide the number of clusters. The coefficient varies between -1 and 1. The best value is 1\nsilhoutte2=[]\nfor i in range(3,11):\n    gmm_model = sklearn.mixture.GaussianMixture(i)\n    gmm_model.fit(data_scaled2)\n    gmm_model_cluster = gmm_model.predict(data_scaled2)\n    silhoutte2.append(sklearn.metrics.silhouette_score(data_scaled2,gmm_model_cluster))\n# Plot silhoutte score to find the number of clusters\nplt.plot(range(3,11), silhoutte2)\nplt.xlabel(\"No. of clusters\")\nplt.ylabel(\"Silhoutte score for each cluster\")\nplt.show()","eb1b0abb":"# Initalise the model with number of components\ngmm_model = sklearn.mixture.GaussianMixture(7)\n# fit our data to the model\ngmm_model.fit(data_scaled2)\n# predict data clusters \ngmm_model_cluster = gmm_model.predict(data_scaled2)\n# Visualisation of the clusters is not easy becasue our data have more than 2 dimensions\n# Mortality rate vs average age of the countries\nplt.figure(figsize=(10, 8))\nplt.scatter(data_scaled2[:, 0], data_scaled2[:, 1], c= gmm_model_cluster,cmap = 'rainbow')\nplt.xlabel('Mortality rate')\nplt.ylabel('Average Age')\nplt.title('Visualisation of risk groups based on mortality rate and average age with Gaussian Mixture Clustering')\n","0f578f96":"# We grouped countries into 6 groups respecto Gaussian mixture clustering\nrisk_group2= pd.DataFrame()\nrisk_group2[\"country\"]=total_50[\"country\"]\nrisk_group2[\"risk_group\"]=gmm_model_cluster\nfor group in range(0,7):\n    countries=risk_group2.loc[risk_group2['risk_group']==group]\n    country_list1 = list(countries['country'])\n    print(\"Group\", group, \":\", country_list1)","dfee1e72":"# See the same pattern for confirmed cases in K-means group 3. Also,we will focus on group 3 in future forecasting stage\nitaly = full[full['country'] == 'Italy']\ngrouped_italy = italy.groupby('Date')['Date', 'Confirmed', 'Deaths','country'].sum().reset_index()\nspain = full[full['country'] == 'Spain']\ngrouped_spain = spain.groupby('Date')['Date', 'Confirmed', 'Deaths'].sum().reset_index()\nfrance = full[full['country'] == 'France']\ngrouped_france = france.groupby('Date')['Date', 'Confirmed', 'Deaths','country'].sum().reset_index()\nuk = full[full['country'] == 'United Kingdom']\ngrouped_uk = uk.groupby('Date')['Date', 'Confirmed', 'Deaths'].sum().reset_index()\nnetherlands = full[full['country'] == 'Netherlands']\ngrouped_netherlands = netherlands.groupby('Date')['Date', 'Confirmed', 'Deaths'].sum().reset_index()\nfig = px.line(grouped_italy, x = 'Date', y= 'Deaths', title=\"Italy Death Cases Over Time\")\nfig.show()\nfig = px.line(grouped_spain, x = 'Date', y= 'Deaths', title=\"Spain Death Cases Over Time\")\nfig.show()\nfig = px.line(grouped_france, x = 'Date', y= 'Deaths', title=\"France Death Cases Over Time\")\nfig.show()\nfig = px.line(grouped_uk, x = 'Date', y= 'Deaths', title=\"United Kingdom Death Cases Over Time\")\nfig.show()\nfig = px.line(grouped_netherlands, x = 'Date', y= 'Deaths', title=\"Netherlands Death Cases Over Time\")\nfig.show()","99e726ba":"# In this stage we will focus on K-means group 3. Prepare the data for Prophet method. We use time series dataframe\n# Between 22.01.2020 - 28.03.2020\nitaly = full[full['country'] == 'Italy']\nspain = full[full['country'] == 'Spain']\nfrance = full[full['country'] == 'France']\nuk = full[full['country'] == 'United Kingdom']\nnetherlands = full[full['country'] == 'Netherlands']\n# Set Date to index and sum all the deaths respect to date\nfull_prophet_italy = italy.groupby('Date').sum()['Deaths'].reset_index()\nfull_prophet_spain = spain.groupby('Date').sum()['Deaths'].reset_index()\nfull_prophet_france = france.groupby('Date').sum()['Deaths'].reset_index()\nfull_prophet_uk = uk.groupby('Date').sum()['Deaths'].reset_index()\nfull_prophet_net = netherlands.groupby('Date').sum()['Deaths'].reset_index()","f40f4567":"# Prepare the data to evaluate prophet method. Future forecast dataframe contains death cases between 29.03.2020 and 06.04.2020\nfuture_italy = future_forecast[future_forecast['country'] == 'Italy']\nfuture_spain = future_forecast[future_forecast['country'] == 'Spain']\nfuture_france = future_forecast[future_forecast['country'] == 'France']\nfuture_uk = future_forecast[future_forecast['country'] == 'United Kingdom']\nfuture_net = future_forecast[future_forecast['country'] == 'Netherlands']\n# Set Date to index and sum all the deaths respect to date\nfuture_italy = future_italy.groupby('Date').sum()['Deaths'].reset_index()\nfuture_spain = future_spain.groupby('Date').sum()['Deaths'].reset_index()\nfuture_france = future_france.groupby('Date').sum()['Deaths'].reset_index()\nfuture_uk = future_uk.groupby('Date').sum()['Deaths'].reset_index()\nfuture_net = future_net.groupby('Date').sum()['Deaths'].reset_index()","1c1e3362":"# Prophet only takes data as a dataframe with a ds (datestamp) and y (value we want to forecast) column\nfull_prophet_italy.columns = ['ds','y']\nfull_prophet_spain.columns = ['ds','y']\nfull_prophet_france.columns = ['ds','y']\nfull_prophet_uk.columns = ['ds','y']\nfull_prophet_net.columns = ['ds','y']","f8a7eb4e":"# Initialize prophet method for Italy\np = Prophet(interval_width=0.95,yearly_seasonality= True,daily_seasonality=True)\n# Fit the data\np.fit(full_prophet_italy)\n# Predict death cases for following 7 days\nfuture = p.make_future_dataframe(periods=7)\nforecast = p.predict(future)\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(7)","1bc7f662":"# Evaluate model with compare real results\nerror_italy = mean_squared_error(future_italy['Deaths'].array,forecast['yhat'].tail(7).array )\nprint('Mean squarred error of Prophet Method for Italy is :', error_italy)","af92b0ff":"plt.scatter(future_italy['Deaths'].array,forecast['yhat'].tail(7).array)\nplt.xlabel('Acutal number of death cases for Italy')\nplt.ylabel('Predicted number of death cases for Italy')\nplt.title('Actual number vs Predicted Number for Italy')","ea92dace":"confirmed_forecast_plot_italy = p.plot(forecast, xlabel = 'Date', ylabel = 'Deaths in Italy')","ad56f147":"# # Initialize prophet method for Spain\np1 = Prophet(interval_width=0.95,yearly_seasonality= True,daily_seasonality=True)\n# Fit the data\np1.fit(full_prophet_spain)\n# Predict death cases for following 7 days\nfuture1 = p1.make_future_dataframe(periods=7)\nforecast1 = p1.predict(future1)\nforecast1[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(7)","c6d64eae":"# Evaluate model with compare real results\nerror_spain = mean_squared_error(future_spain['Deaths'].array,forecast1['yhat'].tail(7).array )\nprint('Mean squarred error of Prophet Method for Spain is :', error_spain)","e7d2e7ce":"plt.scatter(future_spain['Deaths'].array,forecast1['yhat'].tail(7).array)\nplt.xlabel('Acutal number of death cases for Spain')\nplt.ylabel('Predicted number of death cases for Spain')\nplt.title('Actual number vs Predicted Number for Spain')","61763a07":"confirmed_forecast_plot_spain = p1.plot(forecast1, xlabel = 'Date', ylabel = 'Deaths in Spain')","f8032c29":"# # Initialize prophet method for France\np2 = Prophet(interval_width=0.95,yearly_seasonality= True,daily_seasonality=True)\n# Fit the data\np2.fit(full_prophet_france)\n# Predict death cases for following 7 days\nfuture2 = p2.make_future_dataframe(periods=7)\nforecast2 = p2.predict(future2)\nforecast2[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(7)","4c5a5bdf":"# Evaluate model with compare real results\nerror_france = mean_squared_error(future_france['Deaths'].array,forecast2['yhat'].tail(7).array )\nprint('Mean squarred error of Prophet Method for France is :', error_france)","0137b504":"plt.scatter(future_france['Deaths'].array,forecast2['yhat'].tail(7).array)\nplt.xlabel('Acutal number of death cases for France')\nplt.ylabel('Predicted number of death cases for France')\nplt.title('Actual number vs Predicted Number for France')","5bdd5881":"confirmed_forecast_plot_france = p2.plot(forecast2, xlabel = 'Date', ylabel = 'Deaths in France')","619a717e":"# # Initialize prophet method for United Kingdom\np3 = Prophet(interval_width=0.95,yearly_seasonality= True,daily_seasonality=True)\n# Fit the data\np3.fit(full_prophet_uk)\n# Predict death cases for following 7 days\nfuture3 = p3.make_future_dataframe(periods=7)\nforecast3 = p3.predict(future3)\nforecast3[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(7)","f37d7f0c":"# Evaluate model with compare real results\nerror_uk = mean_squared_error(future_uk['Deaths'].array,forecast3['yhat'].tail(7).array )\nprint('Mean squarred error of Prophet Method for United Kingdom is :', error_uk)","00b9377e":"plt.scatter(future_uk['Deaths'].array,forecast3['yhat'].tail(7).array)\nplt.xlabel('Acutal number of death cases for United Kingdom')\nplt.ylabel('Predicted number of death cases for United Kingdom')\nplt.title('Actual number vs Predicted Number for United Kingdom')","41095f52":"confirmed_forecast_plot_france = p3.plot(forecast3, xlabel = 'Date', ylabel = 'Deaths in United Kingdom')","8200ae4f":"# Initialize prophet method for Netherlands\np4 = Prophet(interval_width=0.95,yearly_seasonality= True,daily_seasonality=True)\n# Fit the data\np4.fit(full_prophet_net)\n# Predict death cases for following 7 days\nfuture4 = p4.make_future_dataframe(periods=7)\nforecast4 = p4.predict(future4)\nforecast4[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(7)","ef6d8b87":"# Evaluate model with compare real results\nerror_net = mean_squared_error(future_net['Deaths'].array,forecast4['yhat'].tail(7).array )\nprint('Mean squarred error of Prophet Method for Netherlands is :', error_net)","cd950c9e":"plt.scatter(future_net['Deaths'].array,forecast4['yhat'].tail(7).array)\nplt.xlabel('Acutal number of death cases for Netherlands')\nplt.ylabel('Predicted number of death cases for Netherlands')\nplt.title('Actual number vs Predicted Number for Netherlands')","8f68bf51":"confirmed_forecast_plot_france = p4.plot(forecast4, xlabel = 'Date', ylabel = 'Deaths in Netherlands')","cac03291":"## Spain","917100ec":"### Datasets used in the coursework : \n\u2018Population by Country -2020\u2019 https:\/\/www.kaggle.com\/tanuprabhu\/population-by-country-2020\n\n\u2018Health Care Index by Country 2020\u2019 https:\/\/www.numbeo.com\/health-care\/rankings_by_country.jsp --- HTML data\n\n\u2018MERS Outbreak Dataset 2012-2019\u2019  https:\/\/www.kaggle.com\/imdevskp\/mers-outbreak-dataset-20122019\n\n\u2018SARS 2003 Outbreak Complete Dataset\u2019 https:\/\/www.kaggle.com\/imdevskp\/sars-outbreak-2003-complete-dataset","52e6f59a":"### United Kingdom","62262c0c":"### Netherlands","71a244b6":"## Prophet method","d63aec4d":"### Future Forecasting - Prophet Method","a12177c9":"### Clustering","ac8c7bb2":"### Prophet Method","003f5734":"### Prophet Method","0df66510":"  ## COVID19 EDA + CLUSTERING + PROPHET FORECASTING","4c468529":"> > ### The coronavirus disease(Covid-19) is an ongoing pandemic caused by severe acute respiratory syndrome coronavirus 2(SARS\u2011CoV\u20112)[1].The outbreak was firstly detected in Wuhan,China,and The World Health Organisation(WHO) declared the outbreak an international health emergency. As of 29 March 2020, more than 677,622 cases of COVID-19 have been reported in 199           countries and territories. As a data scientist, I can help countries and global health institutions to take the necessary steps to fight against the outbreak. In this notebook, my primary objective is to find subgroups among the countries with similar COVID-19 mortality rates, healthcare quality index,and demographic characteristics such as population and average age. In this way, countries in the same groups can help each other and make similar provisions against COVID-19. After identifying subgroups within different countries, I make future forecasting of the number of deaths for countries  from the cluster, which are in urgent need of help and assistance,to guide government officials to cope with COVID-19.  \n","d9455e2a":"### Kmeans","e806d77f":"### Prophet Method","c22eb745":"## Italy","c4a7f3e1":"## Exploratory Data Analysis Stage","fa310d4a":"### France","a1b7ddde":"### Clustering + Future Forecasting","93a09d31":"![image.png](attachment:image.png)\n","a39e4ec8":"## Proposed Method ","58390006":"### Gaussian Mixture Model","df037d6e":"## Preprocessing Stage","a31a61df":"### Prophet Method"}}