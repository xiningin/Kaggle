{"cell_type":{"a46f59b0":"code","b3c21fbc":"code","a728cd3e":"code","75eeea5a":"code","32466de9":"code","99345a5d":"code","df81aedc":"code","5fc16011":"markdown","c194964c":"markdown","4ef780c5":"markdown","665a42db":"markdown","ac8f3564":"markdown","f18d196b":"markdown","dfa52022":"markdown"},"source":{"a46f59b0":"# Import packages\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\nimport datetime","b3c21fbc":"def overview():\n    data = pd.read_csv('..\/input\/weatherww2\/Summary of Weather.csv')\n    # Print the first 5 lines of data\n    print(\"First 5 lines of data \\n\\n\")\n    print(data.head())\n    \n    # Print data type\n    print(\"\\n\\n\\nDatatype\\n\")\n    print(data.dtypes)\n    \n    # Print number of null values \n    print(\"\\n\\n\\nNumber of null values\\n\")\n    print(data.isnull().sum())\n    \n    # Print data summary\n    print(\"\\n\\n\\nData summary\\n\")\n    print(data.describe())\n    \n    # Print data shape\n    print(\"\\n\\n\\nData shape\\n\")\n    print(\"Data has {} rows and {} columns\".format(data.shape[0], data.shape[1]))\n   \n    return data\n\ndata = overview()","a728cd3e":"# Dropping NaN rows \ndata = data.dropna(subset = ['Snowfall', 'PRCP', 'MAX', 'MIN', 'MEA', 'SNF'])\n\n# Dropping redundant column\ndata = data.drop(columns = ['PRCP'])\n\n# Dropping NaN columns \ndata = data.dropna(axis = 'columns')\n\n# Taking a look at whats left\ndata.isnull().sum()","75eeea5a":"# Create a function to separate out numerical and categorical data\n    ## Using this function to ensure that all non-numerical in a numerical column\n    ## and non-categorical in a categorical column is annotated\ndef cat_variable(df):\n    return list(df.select_dtypes(include = ['category', 'object']))\n\ndef num_variable(df):\n    return list(df.select_dtypes(exclude = ['category', 'object']))\n\ncategorical_variable = cat_variable(data)\nnumerical_variable = num_variable(data)\n\n# Create a function to process outlier data\ndef outlier(data):\n    z = np.abs(stats.zscore(data[numerical_variable]))\n    z_data = data[(z < 3).all(axis=1)] # Remove any outliers with Z-score > 3 or < -3\n    return z_data\n\ndata = outlier(data)","32466de9":"# Removing non-numeric data and cnverting date to datetime format\ndata['Precip'] = pd.to_numeric(data['Precip'], errors='coerce')\ndata['Year'] = pd.DatetimeIndex(data['Date']).year\ndata.applymap(np.isreal)","99345a5d":"print('Before cleaning: \\n\\n{}'.format(data.isnull().sum()))\n\ndata = data.fillna(method='ffill').fillna(method='bfill')\n\nprint('\\nAfter cleaning: \\n\\n{}'.format(data.isnull().sum()))","df81aedc":"# Convert year to datetime format\ndata = data[:][:1000] # We take in the first 1000 data since we do not want to cluster bomb the whole plot. \ndata['Date'] = pd.to_datetime(data['Date'])\n\n# Indexing the year\ndata = data.set_index('Date')\naxes = data[[\"MaxTemp\", \"MinTemp\", \"MeanTemp\", \"Precip\"]].plot(figsize=(11, 9), subplots=True, linewidth=1)","5fc16011":"## Removing meaningless data from columns ","c194964c":"## Dealing with NaN values again\n- We have 15549 NaN values that were converted in the previous steps. \n- We will use ffill() and bbfill() to replace NaN","4ef780c5":"## Dealing with NaN values\n- We have a total of 119040 rows of data. We will only remove the affected rows if < 5% of the values are NaN. This means we can only remove NaN values if the total counts are below 5952.\n- For columns with significantly huge amount of NaN values, we will remove it totally since we can't replace the values.","665a42db":"We can see that the occurance of precipitation lower the mean temperature. ","ac8f3564":"## Temperature between 1942-1945","f18d196b":"![](https:\/\/thumbs.gfycat.com\/CreepyInbornGrayling-size_restricted.gif)\n# Introduction\nWeather plays a key role in many times of human history. Kublai Khan\u2019s attempted conquest of Japan failed terribly when the invasion fleet was wiped out by a typhoon. Over the years, the role of weather becomes more significant with the invention of heavy armours vehicles brought to battle. Land and sea invasions were heavily dependent on the weather as bombers and air-strikes have to be aborted during bad weather conditions. Meteorologists in the 1940s also lacked modern devices like satelite imagery devices to forcast weather predictions days in advance. This means that sea convoys are heavily dependent on to gather valuable meteorological data.\n\nIn this dataset, we analyse the aerial bombing operations dataset which explore the weather condition during the D-Day landing. ","dfa52022":"## Dealing with outliers\n- To deal with outliers, we use Z-score.\n- A Z-score is a numerical measurement used in statistics of a value\u2019s relationship to the mean (average) of a group of values, measured in terms of standard deviations from the mean.\n    - If a Z-score is 0, it indicates that the data point\u2019s score is identical to the mean score.\n    - A Z-score of 1.0 would indicate a value that is one standard deviation from the mean.\n    - Z-scores may be positive or negative, with a positive value indicating the score is above the mean and a negative score indicating it is below the mean.\n- In most of the cases a threshold of 3 or -3 is used i.e if the Z-score value is greater than or less than 3 or -3 respectively, that data point will be identified as outliers."}}