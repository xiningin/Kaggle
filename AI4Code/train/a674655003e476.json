{"cell_type":{"bcaa898a":"code","dfb4bedc":"code","fd91bf08":"code","7c225946":"code","80e5c7aa":"code","cfe7c374":"markdown","742b57b9":"markdown","a77aef38":"markdown","4b9c928f":"markdown"},"source":{"bcaa898a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom bs4 import BeautifulSoup as bs\nimport requests\nimport re\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        pass\n        #print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","dfb4bedc":"# Given an RGB tuple and a base dataframe containing RGB tuples\n# this function returns the RGB value from the base dataframe that \n# most closely matches the given RGB tuple\ndef closest_color(rgb, base):\n    r, g, b = rgb\n    color_diffs = []\n    for index, row in base.iterrows():\n        cr, cg, cb = row['Rgb']\n        color_diff = sqrt((r - cr)**2 + (g - cg)**2 + (b - cb)**2)\n        color_diffs.append((color_diff, row['Name']))\n    return min(color_diffs)\n\n# Given a HEX code, this function returns the respective RGB tuple\ndef hex_to_rgb(value):\n    value = value.replace('#', '')\n    lv = len(value)\n    return tuple(int(value[i:i + lv \/\/ 3], 16) for i in range(0, lv, lv \/\/ 3))\n\n# Given an RGB code, this function returns the respective HSV tuple\ndef rgb_to_hsv(rgb):\n    rt, gt, bt = rgb\n    r, g, b = rt\/255.0, gt\/255.0, bt\/255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx-mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g-b)\/df) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b-r)\/df) + 120) % 360\n    elif mx == b:\n        h = (60 * ((r-g)\/df) + 240) % 360\n    if mx == 0:\n        s = 0\n    else:\n        s = (df\/mx)*100\n    v = mx*100\n    return h, s, v","fd91bf08":"murl = 'https:\/\/www.color-hex.com\/color-names.html'\nproj_names = []\nproj_rgb = []\n\ntable = bs(requests.get(murl).content, \"html.parser\").find('table', class_='table table-bordered')\nrows = table.find_all('tr')\n\nfor row in rows:\n    useful = row.find_all('td')\n    if not useful:\n        continue\n\n    prename = re.findall('[A-Z][a-z]*', re.sub(r'[0-9]+', '', useful[0].text))\n\n    if len(prename) > 1:\n        name = prename[0] + ' ' + prename[1]\n        proj_names.append(name)\n    else:\n        proj_names.append(prename[0])\n\n    proj_rgb.append(hex_to_rgb(useful[2].text))\n    \ncolor_space = pd.DataFrame(columns=['Name', 'Rgb'])\ncolor_space['Name'] = proj_names\ncolor_space['Rgb'] = proj_rgb\ncolor_space.to_csv('color_space.csv', index=False)\ncolor_space","7c225946":"df_reduced = pd.read_csv('\/kaggle\/input\/colors-of-van-gogh\/df_reduced.csv')\ndf = pd.read_csv('\/kaggle\/input\/colors-of-van-gogh\/df.csv')\ndf_reduced['Colors'] = df_reduced['Colors'].apply(eval)\ndf['Colors'] = df['Colors'].apply(eval)\n\n# This is the website that will be used to retrieve Hue information about colors\nhurl = 'https:\/\/en.wikipedia.org\/wiki\/Hue'\n\ntable = bs(requests.get(hurl).content, \"html.parser\").find_all('table', class_='wikitable')[1]\nrows = table.find_all('tr')\n\nhue_degrees = []\nhue_names = []\n\nfor row in rows:\n    use = row.find_all('td')\n    if not use:\n        continue\n    degree = int(use[0].text[:-2])\n    hue_degrees.append(degree)\n    hue_names.append(use[2].text.strip())\n    \nhuedf = pd.DataFrame(columns=['Name', 'Degree'])\nhuedf['Name'] = hue_names\nhuedf['Degree'] = hue_degrees\n\nfound = []\nyearange = []\nhues = []\ntemps = []\n\nnodes = pd.DataFrame(columns=['Id', 'Label', 'Hue_Name', 'Temperature', 'Start_year', 'End_year'])\n\nfor i, row in df_reduced.iterrows():\n    names = row['Colors']\n    for namef in names:\n        if namef not in found:\n            found.append(namef)\n            s = len(list(color_space[color_space['Name'] == namef]['Rgb'])) \/\/ 2\n            rgb = list(color_space[color_space['Name'] == namef]['Rgb'])[int(s)]\n            angle = round(rgb_to_hsv(rgb)[0])\n            tmin = 500\n            for deg in huedf['Degree']:\n                cmin = abs(angle - deg)\n                mdeg = deg\n                if cmin < tmin:\n                    tmin = cmin\n                    tdeg = deg\n            hues.append(list(huedf[huedf['Degree'] == tdeg]['Name'])[0])\n            if (tdeg > 80 and tdeg < 330):\n                temps.append('Cold')\n            else:\n                temps.append('Warm')\n    \nnodes['Id'] = np.linspace(1, len(found), len(found), dtype=int)\nnodes['Start_year'] = np.full(shape = len(found), fill_value = 5000)\nnodes['End_year'] = np.full(shape = len(found), fill_value = -5000)\nnodes['Label'] = found\nnodes['Hue_Name'] = hues\nnodes['Temperature'] = temps\n\nfor i, row in df_reduced.iterrows():\n    \n    colors = row['Colors']\n    year = row['Year']\n    \n    for color in colors:\n        if year < nodes.loc[nodes['Label'] == color, ['Start_year']].values[0]:\n            nodes.loc[nodes['Label'] == color, ['Start_year']] = year\n        if year > nodes.loc[nodes['Label'] == color, ['End_year']].values[0]:\n            nodes.loc[nodes['Label'] == color, ['End_year']] = year   \n    \nnodes.to_csv('nodes.csv', index=False)\nnodes","80e5c7aa":"edges = pd.DataFrame(columns=['Source', 'Target', 'Type', 'Weight'])\n\ninteractions = []\ndf_mod = df_reduced.copy(deep=False)\n\nfor index, row in df_mod.iterrows():\n    \n    col1 = row['Colors'][0]\n    col2 = row['Colors'][1]\n    col3 = row['Colors'][2]\n    col4 = row['Colors'][3]\n    col5 = row['Colors'][4]\n    \n    saw_this_row = []\n    \n    if (col1 != col2) and ((col1, col2) not in saw_this_row):\n        interactions.append((col1, col2))\n        saw_this_row.append((col1, col2))\n        saw_this_row.append((col2, col1))\n    if (col1 != col3) and ((col1, col3) not in saw_this_row):\n        interactions.append((col1, col3))\n        saw_this_row.append((col1, col3))\n        saw_this_row.append((col3, col1))\n    if (col1 != col4) and ((col1, col4) not in saw_this_row):\n        interactions.append((col1, col4))\n        saw_this_row.append((col1, col4))\n        saw_this_row.append((col4, col1))\n    if (col1 != col5) and ((col1, col5) not in saw_this_row):\n        interactions.append((col1, col5))\n        saw_this_row.append((col1, col5))\n        saw_this_row.append((col5, col1))\n        \n        \n    if (col2 != col3) and ((col2, col3) not in saw_this_row):\n        interactions.append((col2, col3))\n        saw_this_row.append((col2, col3))\n        saw_this_row.append((col3, col2))\n    if (col2 != col4) and ((col2, col4) not in saw_this_row):\n        interactions.append((col2, col4))\n        saw_this_row.append((col2, col4))\n        saw_this_row.append((col4, col2))\n    if (col2 != col5) and ((col2, col5) not in saw_this_row):\n        interactions.append((col2, col5))\n        saw_this_row.append((col2, col5))\n        saw_this_row.append((col5, col2))\n        \n    if (col3 != col4) and ((col3, col4) not in saw_this_row):\n        interactions.append((col3, col4))\n        saw_this_row.append((col3, col4))\n        saw_this_row.append((col4, col3))\n    if (col3 != col5) and ((col3, col5) not in saw_this_row):\n        interactions.append((col3, col5))\n        saw_this_row.append((col3, col5))\n        saw_this_row.append((col5, col3))\n        \n    if (col4 != col5) and ((col4, col5) not in saw_this_row):\n        interactions.append((col4, col5))\n        saw_this_row.append((col4, col5))\n        saw_this_row.append((col5, col4))\n        \ntest = pd.DataFrame(columns=['Inter'])\ntest['Inter'] = interactions\n\nseen = []\n\nfor index, row in test.iterrows():\n    tup = row['Inter']\n    rev_tup = (tup[1], tup[0])\n    if rev_tup not in seen:\n        seen.append(tup)\n    else:\n        row['Inter'] = rev_tup\n\ngrouped = test.groupby(test.Inter, as_index=False).size()\n\nfor index, row in grouped.iterrows():\n    edges.at[index, 'Source'] = row['Inter'][0]\n    edges.at[index, 'Target'] = row['Inter'][1]\n    edges.at[index, 'Type'] = 'undirected'\n    edges.at[index, 'Weight'] = row['size']\n    \nfor index, row in edges.iterrows():\n    row['Source'] = list(nodes[nodes['Label'] == row['Source']]['Id'])[0]\n    row['Target'] = list(nodes[nodes['Label'] == row['Target']]['Id'])[0]\n    \nedges.to_csv('edges.csv', index=False)\nedges","cfe7c374":"## **Here we create the Color_space dataframe**","742b57b9":"## **Here we create the Nodes dataset**","a77aef38":"## **These are helper functions we need**","4b9c928f":"## **Here we create the Edges dataset**"}}