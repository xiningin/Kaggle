{"cell_type":{"0e4deca7":"code","79f0df87":"code","3091630c":"code","64630096":"code","ca531937":"code","b588e668":"code","4201e7fd":"code","e10b9c4d":"code","734cdf2b":"code","285dca89":"code","1c112484":"code","31647da4":"code","a87db213":"code","97759aa8":"code","59d5184d":"code","107ed776":"code","da319628":"code","f9467270":"code","6e91a3e8":"markdown","5de7d3d4":"markdown","35f1f058":"markdown"},"source":{"0e4deca7":"#install packages before anything else\n!pip install cvxopt\n!pip install cvxpy\n!pip install mip\n!pip install pulp","79f0df87":"#import libraries\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom tqdm import notebook\nimport numpy as np\nimport cvxpy as cp\nfrom itertools import combinations \nfrom ortools.linear_solver import pywraplp\nfrom ortools.sat.python import cp_model\nimport cvxopt\nimport cvxpy\nfrom mip import Model, xsum, maximize, minimize, BINARY\nimport pulp as plp\nimport random\nimport copy","3091630c":"#For referecne, display available solvers for CVXPY\nprint(cvxpy.installed_solvers())","64630096":"# generate alll tickets and possible draws given the problem parameters\ndef generate(n,k,p,t):\n    comb_tickets = combinations([i+1 for i in range(n)], k) \n    tickets = np.array([set(x) for x in list(comb_tickets)])\n\n    comb_draws = combinations([i+1 for i in range(n)], p) \n    draws = np.array([set(x) for x in list(comb_draws)])\n    \n    coef_matrix = np.zeros((len(draws), len(tickets)), dtype=int)\n    \n    for i in notebook.tqdm(range(coef_matrix.shape[0])):\n        for j in range(coef_matrix.shape[1]):\n            intersection = len(draws[i] & tickets[j])\n            coef_matrix[i,j] = 1 if intersection >= t else 0\n\n    return draws, tickets, coef_matrix","ca531937":"def MIP_Optmise(coef_matrix):\n    \n    w = coef_matrix\n    T = range(w.shape[1])\n    D = range(w.shape[0])\n    m = Model('lotto')\n\n    x = [m.add_var(var_type=BINARY) for i in T]\n\n    m.objective = minimize(xsum(x[i] for i in T))\n\n    for i in D:\n        m += (xsum(w[i][j]* x[j] for j in T) >= 1)\n\n    #print(m.optimize(max_seconds=60))\n    print(m.optimize())\n    \n    selected = [i for i in T if x[i].x >= 0.99]\n    #print('selected items: {}'.format(selected))\n    \n    deselected = [i for i in T if x[i].x <= 0.99]\n    \n    return selected, deselected  ","b588e668":"def CVXPY_Optmise(coef_matrix):\n    \n    M = coef_matrix\n\n    selection = cp.Variable(M.shape[1], boolean = True)\n    ones_vec = np.ones(M.shape[1], dtype=int)\n    \n    constraints = []\n    \n    for i in range(M.shape[0]):\n        constraints.append(M[i] * selection >= 1)\n\n    cost = ones_vec * selection\n\n    problem = cp.Problem(cp.Minimize(cost), constraints)\n\n    print(problem.solve(solver=cp.GLPK_MI))\n\n    selected = np.nonzero(selection.value > 0.75)\n    #print('selected items: {}'.format(list(selected[0])))\n    \n    deselected = np.nonzero(selection.value < 0.75)\n    \n    return list(selected[0]), list(deselected[0])  ","4201e7fd":"def OR_Optmise(coef_matrix):    \n    w = coef_matrix\n    T = range(w.shape[1])\n    D = range(w.shape[0])\n    \n    # Create the mip solver with the CBC backend.\n    solver = pywraplp.Solver('simple_mip_program', pywraplp.Solver.CBC_MIXED_INTEGER_PROGRAMMING)\n    \n    # Variables\n    x = {}\n    for i in T:\n        x[i] = solver.BoolVar('x_%i' % (i))\n    \n    # The amount packed\n    for i in D:\n        solver.Add(solver.Sum(w[i][j] * x[j] for j in T) >= 1)  \n        \n    solver.Minimize(solver.Sum([x[j] for j in T]))\n      \n    status = solver.Solve()\n    \n    if status == pywraplp.Solver.OPTIMAL:\n        print('An optimal feasible solution was found.')\n    elif status == pywraplp.Solver.FEASIBLE:\n        print('A feasible solution was found, but we dont know if its optimal.')\n    elif status == pywraplp.Solver.INFEASIBLE:\n        print('The problem was proven infeasible.')\n        return\n    elif status == pywraplp.Solver.MODEL_INVALID:\n        print('The given CpModelProto didnt pass the validation step.')\n        return\n    else:\n        print('The status of the model is unknown because a search limit was reached.')\n        return\n         \n    # The objective value of the solution.\n    print('WallTime = %f mSecs' % solver.WallTime())\n    \n    selected = [i for i in T if x[i].solution_value() == 1]\n    #print('selected items: {}'.format(selected))\n    \n    deselected = [i for i in T if x[i].solution_value() < 1]\n    \n    return selected, deselected  ","e10b9c4d":"def OR_ContraintProgramming(coef_matrix, target, greedy_initialisation = False):    \n    \n    w = coef_matrix\n    T = range(w.shape[1])\n    D = range(w.shape[0])\n    \n    # Create the mip solver with the CBC backend.\n    model = cp_model.CpModel()\n    \n    # Variables\n    x = {}\n    for i in T:\n        x[i] = model.NewBoolVar('x_%i' % (i))\n    \n    if greedy_initialisation == True:\n        print(\"Greedy Init\")\n        selected, deselected = Greedy_Optmise(coef_matrix)\n        for i in selected:\n            model.AddHint(x[i], True)\n        \n    #break symmetry when it exists to speed up solution finding\n    model.Add(x[0] == 1) \n    \n    model.Add(sum([x[j] for j in T])==target)\n    \n    # The amount packed\n    for i in D:\n        model.Add(sum(w[i][j] * x[j] for j in T) >= 1)  \n              \n    solver = cp_model.CpSolver()\n\n    status = solver.Solve(model)\n    \n    print(solver.ResponseStats())\n    \n    if status == cp_model.OPTIMAL:\n        print('An optimal feasible solution was found.')\n    elif status == cp_model.FEASIBLE:\n        print('A feasible solution was found, but we dont know if its optimal.')\n    elif status == cp_model.INFEASIBLE:\n        print('The problem was proven infeasible.')\n        return [], []\n    elif status == cp_model.MODEL_INVALID:\n        print('The given CpModelProto didnt pass the validation step.')\n        return [], []\n    else:\n        print('The status of the model is unknown because a search limit was reached.')\n        return [], []\n    \n    selected = [i for i in T if solver.Value(x[i]) == 1]\n    print('selected items: {}'.format(selected))\n    \n    deselected = [i for i in T if solver.Value(x[i]) < 1]\n    \n    return selected, deselected  ","734cdf2b":"def PULP_Optmise(coef_matrix):    \n    w = coef_matrix\n    T = range(w.shape[1])\n    D = range(w.shape[0])\n       \n    opt_model = plp.LpProblem(name=\"MIP_Model\")\n   \n    # if x is Binary\n    x_vars  = {(i): plp.LpVariable(cat=plp.LpBinary, name=\"x_{0}\".format(i)) for i in T}\n\n    # >= constraints\n    constraints = {i : opt_model.addConstraint(plp.LpConstraint(e=plp.lpSum(w[i,j] * x_vars[j] for j in T),\n                         sense=plp.LpConstraintGE,\n                         rhs=1,\n                         name=\"constraint_{0}\".format(i))) for i in D}\n\n    objective = plp.lpSum(x_vars[i] for i in T)\n\n    # for minimization\n    opt_model.sense = plp.LpMinimize\n    opt_model.setObjective(objective)\n\n    # solving with CBC\n    opt_model.solve()\n    \n    selected = [i for i in T if x_vars[i].varValue == 1]\n    #print('selected items: {}'.format(selected))\n    \n    deselected = [i for i in T if x_vars[i].varValue < 1]\n    \n    return selected, deselected  ","285dca89":"def RemoveRedundant(coef_matrix, selected, deselected):\n    \n    coef_matrix_red = np.zeros(coef_matrix.shape, dtype=int)\n    \n    for i in selected:\n        coef_matrix_red[:,i] = coef_matrix[:,i]\n        \n    v = np.count_nonzero(coef_matrix_red, axis=1)\n    \n    selected_copy = copy.deepcopy(selected)\n    for i in selected_copy:\n        if(min(v[np.nonzero(coef_matrix_red[:,i])])>1):\n            selected.remove(i)\n            deselected.append(i)\n            v = np.subtract(v, coef_matrix_red[:,i])\n            \n    return selected, deselected","1c112484":"def Greedy_Optmise(coef_matrix):\n    # let solution be empty\n    X = set()\n    # for each ticket compute how many draws it covers\n    d = np.count_nonzero(coef_matrix, axis=0)\n    # initialise set of uncovered draws i.e. all uncovered\n    I = set(range(coef_matrix.shape[0]))\n    # initialise set of unselected tickets i.e. none selected\n    J = set(range(coef_matrix.shape[1]))\n    # select first ticket\n    w = 0\n    # add to the solution\n    X.add(w)\n    # remove the ticket from the unselected list\n    J.remove(w)\n    # get draws it covers\n    Dw = set(np.nonzero(coef_matrix[:,w])[0])\n    # remove covered draws from the uncovered set\n    I = I - Dw\n    for i in Dw:\n        d = np.subtract(d, coef_matrix[i,:])\n    while I != set():\n        print(\"-\", end=\"\")\n        # select random ticket that maximizes uncovered draws\n        f = (np.where(d == np.amax(d))[0]) \n        w = random.choice(f)\n        # add to the solution\n        X.add(w)\n        # remove the ticket from the unselected list\n        J.remove(w)\n        # get draws it covers\n        Dw = set(np.nonzero(coef_matrix[:,w])[0])\n        Dw = Dw.intersection(I)\n        # remove covered draws from the uncovered set\n        I = I - Dw \n        for i in Dw:\n            d = np.subtract(d, coef_matrix[i,:]) \n    print(\"\")\n    \n    return list(X), list(J)","31647da4":"def Improve(coef_matrix, selected, deselected, factor=0.5, algo='or'):\n    #select % of solution\n    sampling = random.sample(selected, k=int(len(selected)*factor))\n    print(\" Keeping \", len(sampling), \"tickets ouf of\" , len(selected))\n    reduced_coef_matrix = coef_matrix[:,sampling]\n    #check which draws are no longer covered\n    v = np.count_nonzero(reduced_coef_matrix, axis=1)\n    not_coverd_draws = np.where(v == 0)[0]\n    \n    others_tickets = list(set(range(coef_matrix.shape[1]))-set(sampling))\n    \n    reduced_coef_matrix = coef_matrix[:, others_tickets]\n    reduced_coef_matrix = reduced_coef_matrix[not_coverd_draws, :]\n    \n    print(\" OR Size = \", reduced_coef_matrix.shape)\n    \n    \n    if algo == 'cvx':\n        print('CVXPY Optimise')\n        x, y = CVXPY_Optmise(reduced_coef_matrix)\n        \n    if algo == 'mip':\n        print('MIP Optimise')\n        x, y = MIP_Optmise(reduced_coef_matrix) \n        \n    if algo == 'or':\n        print('OR Optimise')\n        x, y = OR_Optmise(reduced_coef_matrix)  \n\n    if algo == 'pulp':\n        print('PULP Optimise')\n        x, y = PULP_Optmise(reduced_coef_matrix)      \n    \n    \n    for i in x:\n        sampling.append(others_tickets[i])\n       \n    others_tickets = list(set(range(coef_matrix.shape[1]))-set(sampling))\n        \n    return RemoveRedundant(coef_matrix, sampling, others_tickets)","a87db213":"def Greedy_Optmise_Tries(coef_matrix, tries=1, factor=0.5, algo = 'or'):\n    selected, deselected = Greedy_Optmise(coef_matrix)\n    print(\"Original Solution Tickets =\", len(selected))\n\n    selected, deselect = RemoveRedundant(coef_matrix, selected, deselected)\n    print(\"Remove Redundant Tickets =\", len(selected))\n\n    for i in range(tries):\n        print(\"Iteration = \", i, end=\"\")\n        selected, deselect = Improve(coef_matrix, selected, deselected, factor, algo)\n        print(\"Improved Tickets =\", len(selected))\n\n    return selected, deselected      ","97759aa8":"#get tickets that provides the solution to our problem\ndef get_tickets(draws, tickets, coef_matrix, deselected):\n    tickets_str = [str(x) for x in tickets]\n    draws_str = [str(x) for x in draws]\n\n    coefficient_matrix = pd.DataFrame(coef_matrix, index = draws_str, columns = tickets_str)\n    coefficient_matrix = coefficient_matrix.drop(coefficient_matrix.columns[deselected], axis=1)\n    \n    return coefficient_matrix","59d5184d":"# perform the optmisation using the library of our choice\ndef get_reduced_wheel(n,k,p,t,algo, target=0, greedy_initialisation = False, factor=0.5, tries=1):\n    \n    draws, tickets, coef_matrix = generate(n,k,p,t)\n\n    number_tickets = len(tickets)\n    print('Tickets =', number_tickets)\n\n    number_draws = len(draws)\n    print('Draws =', number_draws)\n    \n    selected, deselected =  Greedy_Optmise_Tries(coef_matrix, tries, factor, algo)\n        \n    optimal_tickets = get_tickets(draws, tickets, coef_matrix, deselected)\n    \n    return optimal_tickets","107ed776":"n = 12  # numbers in the set\nk = 5  # numbers in ticket\np = 4  # numbers in draw\nt = 3 # at least match","da319628":"%%time\nGreedy_tickets = get_reduced_wheel(n,k,p,t,algo = 'cvx', factor=0.75, tries=10)","f9467270":"Greedy_tickets","6e91a3e8":"Inspired by that article I implemented a solution using a variety of open source optimisers:\n* CVXPY\n* PuLP\n* ORtools\n* MIP\n\nOf course one of the challenges is that for large sets the optmiser takes an unfeasible amount of time to find a solution. What is interesting to note is that this is a 0-1 Integer Linear Programming. Therefore, I was wondering if there are optmisers tailored to this type of problem.\n\nI would be keen to hear your thoughts.","5de7d3d4":"# Solving the lottery problem using integer linear programming","35f1f058":"\nIn a lottery problem, p numbers are randomly drawn from a n-set. These p numbers are lottery winning numbers of which we are not aware. We write k numbers out of the n numbers on each ticket. We wish to know how many tickets have to be bought, and what numbers should be written on each ticket, so that we will have at least one ticket which has, at least, t numbers in common with the p numbers of the lottery winning numbers. The objective is minimizing the number of tickets that have to be purchased. We call this problem a (n,k, p, t) lottery problem, with n \u2265 k,p and k,p \u2265 t.\n\nThe lottery problem can be solved using integer linear programming. \n\nA good source of information is this article:\n[Heuristic algorithm for solving the integer programming of the lottery problem](https:\/\/core.ac.uk\/download\/pdf\/82321386.pdf)"}}