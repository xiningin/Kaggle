{"cell_type":{"43bae787":"code","813341a4":"code","b0b2d13d":"code","ec86cdd9":"code","8b2e5f4e":"code","4faaee70":"code","c4630216":"code","bd73609b":"code","d7e99d28":"code","ce7271a2":"code","aab230bd":"code","ded97d1e":"code","b472e958":"code","a112990f":"code","7ed32d5b":"code","ddc79e16":"code","8d765440":"code","d407fb87":"code","1b454a09":"code","25cf21f1":"code","1fa427af":"code","3439821d":"code","df49d0e2":"markdown","07398ec2":"markdown"},"source":{"43bae787":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Modeling\nimport lightgbm as lgb\n\nMAX_EVALS = 500\nN_FOLDS = 10\n\nimport matplotlib.pyplot as plt\nimport pandas as pd \nimport numpy as np\nimport seaborn as sns\nsns.set(style=\"whitegrid\")\nnp.random.seed(203)\n\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import train_test_split\n\nfrom matplotlib import pyplot as plt\nfrom timeit import default_timer as timer\n\nimport random\n\n#Suppress warnings from pandas\nimport warnings\nwarnings.filterwarnings('ignore')\n\nplt.style.use('fivethirtyeight')\n\n# Memory management\nimport gc \n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\n%matplotlib inline\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","813341a4":"train_df = pd.read_csv('..\/input\/train.csv')","b0b2d13d":"train_df.head()","ec86cdd9":"test_df = pd.read_csv('..\/input\/test.csv')","8b2e5f4e":"test_df.head()","4faaee70":"# Function to calculate missing values by column# Funct \ndef missing_values_table(df):\n        # Total missing values\n        mis_val = df.isnull().sum()\n        \n        # Percentage of missing values\n        mis_val_percent = 100 * df.isnull().sum() \/ len(df)\n        \n        # Make a table with the results\n        mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1)\n        \n        # Rename the columns\n        mis_val_table_ren_columns = mis_val_table.rename(\n        columns = {0 : 'Missing Values', 1 : '% of Total Values'})\n        \n        # Sort the table by percentage of missing descending\n        mis_val_table_ren_columns = mis_val_table_ren_columns[\n            mis_val_table_ren_columns.iloc[:,1] != 0].sort_values(\n        '% of Total Values', ascending=False).round(1)\n        \n        # Print some summary information\n        print (\"Your selected dataframe has \" + str(df.shape[1]) + \" columns.\\n\"      \n            \"There are \" + str(mis_val_table_ren_columns.shape[0]) +\n              \" columns that have missing values.\")\n        \n        # Return the dataframe with missing information\n        return mis_val_table_ren_columns","c4630216":"# Missing values statistics\nmissing_values = missing_values_table(train_df)\nmissing_values.head(20)","bd73609b":"# Missing values statistics\nmissing_values = missing_values_table(test_df)\nmissing_values.head(20)","d7e99d28":"# Number of each type of column\ntrain_df.dtypes.value_counts()","ce7271a2":"X_train, y_train = train_test_split(train_df, test_size=0.2)\n\n# Extract the labels and format properly\ntrain_labels = np.array(X_train['target'].astype(np.int32)).reshape((-1,))\ntest_labels = np.array(y_train['target'].astype(np.int32)).reshape((-1,))\n\n# Drop the unneeded columns\ntrain = X_train.drop(columns = ['ID_code', 'target'])\ntest = y_train.drop(columns = ['ID_code','target'])\n\n# Convert to numpy array for splitting in cross validation\nfeatures = np.array(train)\ntest_features = np.array(test)\nlabels = train_labels[:]\n\nprint('Train shape: ', train.shape)\nprint('Test shape: ', test.shape)\ntrain.head()","aab230bd":"plt.hist(labels, edgecolor = 'k'); \nplt.xlabel('Label'); plt.ylabel('Count'); plt.title('Counts of Labels');","ded97d1e":"# Model with default hyperparameters\nmodel = lgb.LGBMClassifier()\nmodel","b472e958":"start = timer()\nmodel.fit(features, labels)\ntrain_time = timer() - start\n\npredictions = model.predict_proba(test_features)[:, 1]\nauc = roc_auc_score(test_labels, predictions)\n\nprint('The baseline score on the test set is {:.4f}.'.format(auc))\nprint('The baseline training time is {:.4f} seconds'.format(train_time))","a112990f":"# Hyperparameter grid\nparam_grid = {\n    'class_weight': [None, 'balanced'],\n    'boosting_type': ['gbdt', 'goss', 'dart'],\n    'num_leaves': list(range(30, 150)),\n    'learning_rate': list(np.logspace(np.log(0.005), np.log(0.2), base = np.exp(1), num = 1000)),\n    'subsample_for_bin': list(range(20000, 300000, 20000)),\n    'min_child_samples': list(range(20, 500, 5)),\n    'reg_alpha': list(np.linspace(0, 1)),\n    'reg_lambda': list(np.linspace(0, 1)),\n    'colsample_bytree': list(np.linspace(0.6, 1, 10))\n}\n\n# Subsampling (only applicable with 'goss')\nsubsample_dist = list(np.linspace(0.5, 1, 100))","7ed32d5b":"plt.hist(param_grid['learning_rate'], color = 'r', edgecolor = 'k');\nplt.xlabel('Learning Rate', size = 14); plt.ylabel('Count', size = 14); plt.title('Learning Rate Distribution', size = 18);","ddc79e16":"# Randomly sample parameters for gbm\nparams = {key: random.sample(value, 1)[0] for key, value in param_grid.items()}\nparams","8d765440":"params['subsample'] = random.sample(subsample_dist, 1)[0] if params['boosting_type'] != 'goss' else 1.0\nparams","d407fb87":"#Create a lgb dataset\ntrain_set = lgb.Dataset(features, label = labels)","1b454a09":"# Perform cross validation with 10 folds\nr = lgb.cv(params, train_set, num_boost_round = 10000, nfold = 10, metrics = 'auc', \n           early_stopping_rounds = 100, verbose_eval = False, seed = 50)\n\n# Highest score\nr_best = np.max(r['auc-mean'])\n\n# Standard deviation of best score\nr_best_std = r['auc-stdv'][np.argmax(r['auc-mean'])]\n\nprint('The maximium ROC AUC on the validation set was {:.5f} with std of {:.5f}.'.format(r_best, r_best_std))\nprint('The ideal number of iterations was {}.'.format(np.argmax(r['auc-mean']) + 1))","25cf21f1":"# Dataframe to hold cv results\nrandom_results = pd.DataFrame(columns = ['loss', 'params', 'iteration', 'estimators', 'time'],\n                       index = list(range(MAX_EVALS)))","1fa427af":"def random_objective(params, iteration, n_folds = N_FOLDS):\n    \"\"\"Random search objective function. Takes in hyperparameters\n       and returns a list of results to be saved.\"\"\"\n\n    start = timer()\n    \n    # Perform n_folds cross validation\n    cv_results = lgb.cv(params, train_set, num_boost_round = 10000, nfold = n_folds, \n                        early_stopping_rounds = 100, metrics = 'auc', seed = 50)\n    end = timer()\n    best_score = np.max(cv_results['auc-mean'])\n    \n    # Loss must be minimized\n    loss = 1 - best_score\n    \n    # Boosting rounds that returned the highest cv score\n    n_estimators = int(np.argmax(cv_results['auc-mean']) + 1)\n    \n    # Return list of results\n    return [loss, params, iteration, n_estimators, end - start]","3439821d":"%%capture\n\nrandom.seed(50)\n\n# Iterate through the specified number of evaluations\nfor i in range(MAX_EVALS):\n    \n    # Randomly sample parameters for gbm\n    params = {key: random.sample(value, 1)[0] for key, value in param_grid.items()}\n    \n    print(params)\n    \n    if params['boosting_type'] == 'goss':\n        # Cannot subsample with goss\n        params['subsample'] = 1.0\n    else:\n        # Subsample supported for gdbt and dart\n        params['subsample'] = random.sample(subsample_dist, 1)[0]\n        \n        \n    results_list = random_objective(params, i)\n    \n    # Add results to next row in dataframe\n    random_results.loc[i, :] = results_list","df49d0e2":"**Credits**:\n* [Start Here: A Gentle Introduction e1d8c7](https:\/\/www.kaggle.com\/thaer2018\/start-here-a-gentle-introduction-e1d8c7\/edit)\n* [WillKoehrsen: Hyperparameter Optimization](https:\/\/github.com\/WillKoehrsen\/hyperparameter-optimization\/blob\/master\/Bayesian%20Hyperparameter%20Optimization%20of%20Gradient%20Boosting%20Machine.ipynb)","07398ec2":"The only 'object' type column is the Customer Index."}}