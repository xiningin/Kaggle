{"cell_type":{"190d10f9":"code","3a2c30bc":"code","ac99eade":"code","193c0978":"code","9cbc5661":"code","cf752523":"code","37698eac":"code","34b2fa9e":"code","70097293":"code","b19c14d0":"code","06231711":"code","b4f2c071":"code","4883ce60":"code","5bac9960":"code","acaa5c15":"code","6a475e7e":"code","377d210f":"code","7f378091":"code","3722f787":"code","b194e533":"code","6145fc41":"code","e9aca7e0":"code","056d45ad":"code","afe9569c":"code","d69078be":"code","8dfb90c6":"code","1261b005":"code","869eecd7":"code","399b37e0":"code","97d3986e":"code","cf0bbef2":"code","812609f3":"markdown"},"source":{"190d10f9":"from keras.layers import Input, Lambda, Dense, Flatten\nfrom keras.models import Model\nfrom keras.applications.vgg16 import VGG16\nfrom keras.applications.vgg16 import preprocess_input\nfrom keras.preprocessing import image\nfrom keras.preprocessing.image import ImageDataGenerator\n\nfrom sklearn.metrics import confusion_matrix\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom glob import glob","3a2c30bc":"#Keras\nfrom tensorflow import keras\n\n# Import of keras model and hidden layers for CNN\nfrom keras.models import Sequential\nfrom keras.layers.convolutional import Conv2D, MaxPooling2D\nfrom keras.layers import Dense, Flatten, Dropout\n\n#Image handling libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cv2\nimport pandas as pd\n\n#Sklearn libraries\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix\n\nimport warnings\nwarnings.filterwarnings('always')\nwarnings.filterwarnings('ignore')\n\n# data visualisation and manipulation\nimport matplotlib.pyplot as plt\nfrom matplotlib import style\n\n#Initialize a list of paths for images\nimagepaths = []\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        path = os.path.join(dirname, filename)\n        imagepaths.append(path)\n\nprint(len(imagepaths))","ac99eade":"IMG_SIZE=128\nX=[]\ny=[]\nfor image in imagepaths:\n    try:\n        img = cv2.imread(image,cv2.IMREAD_COLOR)\n        img = cv2.resize(img, (IMG_SIZE,IMG_SIZE))\n\n        X.append(np.array(img))\n        if(image.startswith('\/kaggle\/input\/pothole-detection-dataset\/normal\/')):\n            y.append('NORMAL')\n        else:\n            y.append('POTHOLES')\n    except:\n        pass","193c0978":"import random as rn\nfig,ax=plt.subplots(2,5)\nplt.subplots_adjust(bottom=0.3, top=0.7, hspace=0)\nfig.set_size_inches(15,15)\n\nfor i in range(2):\n    for j in range (5):\n        l=rn.randint(0,len(y))\n        ax[i,j].imshow(X[l][:,:,::-1])\n        ax[i,j].set_title(y[l])\n        ax[i,j].set_aspect('equal')","9cbc5661":"from sklearn.preprocessing import LabelEncoder\nfrom keras.utils import to_categorical\nfrom sklearn.model_selection import train_test_split\n\nle=LabelEncoder()\nY=le.fit_transform(y)\nY=to_categorical(Y,2)\nprint(Y)\nX=np.array(X)\n#X=X\/255\n\nx_train,x_test,y_train,y_test=train_test_split(X,Y,test_size=0.25,random_state=5)","cf752523":"# Create a CNN Sequential Model\nmodel = Sequential()\n\nmodel.add(Conv2D(32, (5,5), activation = 'relu', input_shape=(128,128,3)))\nmodel.add(MaxPooling2D((2,2)))\n\nmodel.add(Conv2D(64, (3, 3), activation='relu')) \nmodel.add(MaxPooling2D((2, 2)))\n\nmodel.add(Conv2D(128, (3, 3), activation='relu')) \nmodel.add(MaxPooling2D((2, 2)))\n\nmodel.add(Conv2D(128, (3, 3), activation='relu')) \nmodel.add(MaxPooling2D((2, 2)))\n\nmodel.add(Conv2D(128, (3, 3), activation='relu')) \nmodel.add(MaxPooling2D((2, 2)))\n\nmodel.add(Flatten())\n\nmodel.add(Dropout(0.4))\n\nmodel.add(Dense(128, activation='relu'))\n\nmodel.add(Dense(2, activation='softmax'))","37698eac":"#Model configuration for training purpose\nmodel.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])","34b2fa9e":"print(model.summary())","70097293":"model.fit(x_train, y_train, epochs=30, batch_size=12, verbose=2, \n         validation_data=(x_test, y_test))","b19c14d0":"\nloss, accuracy = model.evaluate(x_test, y_test)\n\nprint('Test accuracy: {:2.2f}%'.format(accuracy*100))","06231711":"# Making predictions on test data\nprediction = model.predict(x_test)","b4f2c071":"#Transform predictions into 1D array \ny_pred = np.argmax(prediction, axis=1)","4883ce60":"y_test1=y_test.astype(int)\ny_test2=[]\nfor i in y_test1:\n    a=1\n    #print(i[0],i[1])\n    if(i[0]==1 and i[1]==0):\n        a=0\n    y_test2.append(a)    \n        ","5bac9960":"#Create a Confusion Matrix for Evaluation\n# H = Horizontal\n# V = Vertical\npd.DataFrame(confusion_matrix(y_test2, y_pred),\n             columns=[\"Predicted NORMAL\", \"Predicted POTHOLES\"],\n             index=[\"Actual NORMAL\", \"Actual POTHOLES\"])","acaa5c15":"IMG_SIZE=128\n\n# training config:\nepochs = 5\nbatch_size = 32\n\nX=[]\ny=[]\nfor image in imagepaths:\n    try:\n        img = cv2.imread(image,cv2.IMREAD_COLOR)\n        img = cv2.resize(img, (IMG_SIZE,IMG_SIZE))\n\n        X.append(np.array(img))\n        if(image.startswith('\/kaggle\/input\/pothole-detection-dataset\/normal\/')):\n            y.append('NORMAL')\n        else:\n            y.append('POTHOLES')\n    except:\n        pass","6a475e7e":"IMG_SIZE=128\n\n# training config:\nepochs = 5\nbatch_size = 32\n\nfilename=[]\ny=[]\nfor image in imagepaths:\n    try:\n        #filename.append(image[image.rfind('\/')+1:])\n        filename.append(image)\n        if(image.startswith('\/kaggle\/input\/pothole-detection-dataset\/normal\/')):\n            y.append('NORMAL')\n        else:\n            y.append('POTHOLES')\n    except:\n        pass","377d210f":"img_df = pd.DataFrame(\n    {'filename': filename,\n     'y': y\n    })\n\nimg_df=img_df.sample(frac=1)","7f378091":"tr_img=img_df[:450]\nvalid_img=img_df[450:]","3722f787":"IMAGE_SIZE = [128, 128]\nvgg = VGG16(input_shape=IMAGE_SIZE + [3], weights='imagenet', include_top=False)","b194e533":"# don't train existing weights\nfor layer in vgg.layers:\n  layer.trainable = False","6145fc41":"folders = glob('\/kaggle\/input\/pothole-detection-dataset' + '\/*')","e9aca7e0":"# our layers - you can add more if you want\nx = Flatten()(vgg.output)\n# x = Dense(1000, activation='relu')(x)\nprediction = Dense(len(folders), activation='softmax')(x)","056d45ad":"# create a model object\nmodel = Model(inputs=vgg.input, outputs=prediction)","afe9569c":"# view the structure of the model\nmodel.summary()","d69078be":"# tell the model what cost and optimization method to use\nmodel.compile(\n  loss='categorical_crossentropy',\n  optimizer='rmsprop',\n  metrics=['accuracy'])","8dfb90c6":"# create an instance of ImageDataGenerator\ngen = ImageDataGenerator(\n  rotation_range=20,\n  width_shift_range=0.1,\n  height_shift_range=0.1,\n  shear_range=0.1,\n  zoom_range=0.2,\n  horizontal_flip=True,\n  vertical_flip=True,\n  preprocessing_function=preprocess_input\n)","1261b005":"test_gen = gen.flow_from_dataframe(\n        dataframe=img_df,\n        #directory='\/kaggle\/input\/pothole-detection-dataset',\n        x_col=\"filename\",\n        y_col=\"y\",\n        target_size=IMAGE_SIZE)\nprint(test_gen.class_indices)","869eecd7":"labels = [None] * len(test_gen.class_indices)\nfor k, v in test_gen.class_indices.items():\n  labels[v] = k","399b37e0":"try:\n    for x, y in test_gen:\n      print(\"min:\", x[0].min(), \"max:\", x[0].max())\n      plt.title(labels[np.argmax(y[0])])\n      plt.imshow(x[0])\n      plt.show()\n      break\nexcept:\n    pass","97d3986e":"train_path = '\/kaggle\/input\/pothole-detection-dataset'\n# create generators\ntrain_generator = gen.flow_from_dataframe(\n        dataframe=tr_img,\n        #directory='\/kaggle\/input\/pothole-detection-dataset',\n        x_col=\"filename\",\n        y_col=\"y\",\n        target_size=IMAGE_SIZE,\n        shuffle=True,\n      batch_size=batch_size)\n\nvalid_generator = gen.flow_from_dataframe(\n        dataframe=valid_img,\n        #directory='\/kaggle\/input\/pothole-detection-dataset',\n        x_col=\"filename\",\n        y_col=\"y\",\n        target_size=IMAGE_SIZE,\n        shuffle=True,\n      batch_size=batch_size)","cf0bbef2":"train_img_path = '\/kaggle\/input\/pothole-detection-dataset' + '\/*\/*.j*'\n# fit the model\ntry:\n    r = model.fit_generator(\n          train_generator,\n          validation_data=valid_generator,\n          epochs=epochs,\n          steps_per_epoch=len(image_files) \/\/ batch_size,\n          validation_steps=len(valid_image_files) \/\/ batch_size)\nexcept:\n    pass","812609f3":"# **VGG16 Transfer Learning**"}}