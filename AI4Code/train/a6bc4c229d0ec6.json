{"cell_type":{"55af9195":"code","8e086794":"code","3bd956b6":"code","1cbd49da":"code","fb0ee0fd":"code","75cd3331":"code","74724ede":"code","5484d62d":"code","78c2184b":"code","7656d216":"code","f234a102":"code","b574e72a":"code","6eb2a490":"code","83e8b301":"markdown"},"source":{"55af9195":"# Libraries \nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n%matplotlib inline\n\nfrom keras.datasets import mnist\nfrom keras.utils import to_categorical\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D, MaxPooling2D, Dense, Flatten, Reshape, Dropout\nfrom keras.optimizers import SGD, Adadelta\nfrom keras.models import load_model\n\n# Path\ninput_path = \"\/kaggle\/input\/\"\noutput_path = \"\/kaggle\/working\/\"","8e086794":"# CNN Model for Handwritten Digit Recognition\ndef load_dataset(show=False, idx=0):\n    (trainX, trainY), (testX, testY) = mnist.load_data()\n    if (show):\n        for i in range(9):\n            plt.subplot(330 + 1 + i)\n            plt.imshow(trainX[idx+i], cmap=plt.get_cmap('gray'))\n    plt.show()\n\n    trainX = trainX.reshape((trainX.shape[0], 28, 28, 1))\n    testX = testX.reshape((testX.shape[0], 28, 28, 1))\n    trainY = to_categorical(trainY)\n    testY = to_categorical(testY)\n    return trainX, trainY, testX, testY\n\ndef get_model(n1,n2,bReshape=False):\n    model = Sequential()\n    model.add(Conv2D(32, (3,3), activation='relu', kernel_initializer='he_uniform', input_shape=(n1, n2, 1)))\n    model.add(MaxPooling2D((2,2)))\n    model.add(Conv2D(32, (3,3), activation='relu', kernel_initializer='he_uniform'))\n    model.add(MaxPooling2D((2,2)))\n    model.add(Conv2D(64, (3,3), activation='relu', kernel_initializer='he_uniform'))\n    model.add(Conv2D(64, (3,3), activation='relu', kernel_initializer='he_uniform'))    \n    model.add(Conv2D(50, (1,1), activation='relu', kernel_initializer='he_uniform'))\n    model.add(Conv2D(10, (1,1), activation='softmax'))\n    if (bReshape):\n        model.add(Reshape((10,)))\n    opt = SGD(lr=0.01, momentum=0.9)\n    model.compile(optimizer=opt, loss='categorical_crossentropy', metrics=['accuracy'])\n    return model\n\ndef train_model():\n    trainX, trainY, testX, testY = load_dataset()\n    trainX, testX = trainX.astype('float32')\/255.0, testX.astype('float32')\/255.0\n    model = get_model(28,28,True)\n    model.fit(trainX, trainY, epochs=10, batch_size=32, verbose=2)\n    _, acc = model.evaluate(testX, testY, verbose=2)\n    return model\n\nmodel = train_model()","3bd956b6":"model.summary()","1cbd49da":"# Image Processing libraries\nimport cv2\nimport os\nfrom PIL import Image\n\n# Get the relevant area of the hand written form \ndef get_area(file):\n    img = cv2.imread(file, 0)\n    imgray = 255 - img\n    ret, thresh = cv2.threshold(imgray, 127, 255, cv2.THRESH_BINARY)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n    rects = [cv2.boundingRect(cnt) for cnt in contours]\n\n    max_w = max([w for (x, y, w, h) in rects])\n    max_h = max([h for (x, y, w, h) in rects])\n    top_x = min([x for (x, y, w, h) in rects if ((w > max_w\/2) & (h > max_h\/2))])\n    top_y = min([y for (x, y, w, h) in rects if ((w > max_w\/2) & (h > max_h\/2))])\n    bot_x = max([x+w for (x, y, w, h) in rects if ((w > max_w\/2) & (h > max_h\/2))])\n    bot_y = max([y+h for (x, y, w, h) in rects if ((w > max_w\/2) & (h > max_h\/2))])\n    area = img[top_y:bot_y,top_x:bot_x]\n    return area\n\n\n# Get the strips where the entries are made from area extracted\ndef get_strips(area, para_row, para_col):\n    n_row = len(para_row)\n    row_dim = area.shape[0] \/ sum(para_row)\n    n_col = len(para_col)\n    col_dim = area.shape[1] \/ sum(para_col)\n\n    list_strips = []\n    for row in range(1,n_row):   # row 0 is header\n        strips = []\n        for col in range(n_col):\n            top_y = np.ceil(sum(para_row[:row])*row_dim)                 \n            bot_y = top_y + np.floor(row_dim*para_row[row])            \n            top_x = np.ceil(sum(para_col[:col])*col_dim)     \n            bot_x = top_x + np.floor(col_dim*para_col[col])\n            top_y, bot_y, top_x, bot_x = int(top_y), int(bot_y), int(top_x), int(bot_x)\n            out = area[top_y:bot_y,top_x:bot_x]\n\n            top_hcut, bot_hcut = 0.1, 0.1                                 # PARA\n            top_wcut, bot_wcut = 0.1, 0.1\n            if (col == 0):\n                top_wcut = 0.2\n            if (col == n_col-1):\n                bot_wcut = 0.2\n                \n            h,w = out.shape[0],out.shape[1]\n            out = out[int(h*top_hcut):int(h-h*bot_hcut),int(w*top_wcut):int(w-w*bot_wcut)]\n            strips.append(out)\n        list_strips.append(strips)\n    return list_strips\n\n\n# Get location of digits within strips\ndef get_locations(strip):\n    (H,W) = strip.shape\n    imgray = 255 - strip\n    ret, thresh = cv2.threshold(imgray, 127, 255, cv2.THRESH_BINARY)\n    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n    \n    rects = [cv2.boundingRect(cnt) for cnt in contours]\n    rects = [(x, y, w, h) for (x, y, w, h) in rects if (h > H\/4)]\n    rects = sorted(rects, key=lambda rect: rect[0])\n    \n    # Removing overlap rectangles\n    Rects = []\n    if (len(rects)):\n        i=0\n        rectA = rects[0]\n        for j in range(1,len(rects)):\n            rectB = rects[j]\n            if (rectA[0] + rectA[2] >= rectB[0]):\n                x = rectA[0]\n                y = min(rectA[1],rectB[1])\n                x_bot = max(rectA[0]+rectA[2],rectB[0]+rectB[2])\n                y_bot = max(rectA[1]+rectA[3],rectB[1]+rectB[3])\n                w = x_bot - x\n                h = y_bot - y\n                rectA = (x,y,w,h)\n            else:\n                Rects.append(rectA)\n                i=j   \n                rectA = rects[i]    \n        Rects.append(rectA)\n    rects = Rects\n    \n    cut_margin = 0.1                                                      # PARA\n    pad_margin = 0.2\n    locs = []\n    for i,(x,y,w,h) in enumerate(rects):\n        # cutting\n        top_y = max(y - h*cut_margin,0)\n        bot_y = y + h + min(h*cut_margin, y)\n        top_x = max(x - w*cut_margin,0)\n        bot_x = x + w + min(w*cut_margin, x)\n        top_y, bot_y, top_x, bot_x = int(top_y), int(bot_y), int(top_x), int(bot_x)    \n        loc = strip[top_y:bot_y,top_x:bot_x]\n        \n        # padding\n        pad = max(w,h)*pad_margin\n        pad_x = pad\n        pad_y = pad\n        if (w>h):\n            pad_y = pad + (w-h)\/2\n        else:\n            pad_x = pad + (h-w)\/2\n        BRIGHT = [255,255,255]\n        pad_x, pad_y = int(pad_x), int(pad_y)\n        loc = cv2.copyMakeBorder(loc, pad_y, pad_y, pad_x, pad_x, cv2.BORDER_CONSTANT, value=BRIGHT)           \n        locs.append(loc)\n    return locs\n\n\n# Predicting digits present in strip\ndef predict_strip(locs):\n    preds = []\n    for i,loc in enumerate(locs):\n        img = Image.fromarray(loc,'L')\n        img = img.resize((28,28))\n        \n        arr = np.asarray(img)\n        arr = (1 - arr\/255.0).astype(float)\n        arr[arr > 0.5] = 1.0\n        arr[arr < 0.45] = 0.0\n        arr1 = arr.reshape((1, 28, 28, 1))\n        \n        pred = model.predict(arr1)[0]\n        pred = np.argmax(pred)\n        preds.append(str(pred))\n    ans = -1\n    if (len(preds)):\n        ans = int(''.join(preds))\n    return ans\n\n# Function to get data from a form\ndef get_data(form, para_row, para_col):\n    area = get_area(form)\n    # plt.imshow(area, cmap='gray')                                   \n    list_strips = get_strips(area, para_row, para_col)\n    row = 0\n    for col in range(0):\n        plt.subplot(510 + 1 + col)\n        plt.imshow(list_strips[row][col], cmap='gray')\n\n    data = np.zeros((len(list_strips),len(list_strips[0])))\n    for i,strips in enumerate(list_strips):\n        for j,strip in enumerate(strips):\n            locs = get_locations(strip)\n            data[i,j] = predict_strip(locs)\n    return data\n\n\n# Function to process folder with multiple forms\ndef process_folder(folder, columns, para_row, para_col):\n    data_folder = np.empty((0,len(columns)), int)\n    for dirname, _, filenames in os.walk(input_path + folder):\n        for filename in filenames:\n            if (filename.lower().endswith(('.png', '.jpg', '.jpeg'))):\n                form = os.path.join(dirname, filename)\n                print (\"Processing \", folder, \">\", filename, \"... \", end='')\n                data_form = get_data(form, para_row, para_col)\n                data_folder = np.concatenate((data_folder, data_form), axis=0)\n                print (\"Done\")\n    \n    df = pd.DataFrame(data=data_folder, columns=columns)\n    df.drop(columns=\"Redundant\", inplace=True, errors='ignore')\n    print (\"\\nExtracted details:\")\n    print(df.head(100).astype(int))\n    df.to_csv(output_path + folder.strip('\/') + '.csv', index=False)","fb0ee0fd":"# Manual Reports of Weekly Fuel Consumption & Working Hours\nfig = plt.figure(figsize=(48,16))\nplt.suptitle(\"Manual Reports of Weekly Fuel Consumption & Working Hours\", fontweight='bold', fontsize=16, x=0.51, y=0.93);\nax1 = fig.add_subplot(211)\nax1.set_title('Week #1', fontsize=16)\nax1.imshow(cv2.imread(input_path + 'fuelconsumption\/Week1.jpg'), cmap='gray')\nax2 = fig.add_subplot(212)\nax2.set_title('Week #2', fontsize=16)\nax2.imshow(cv2.imread(input_path + 'fuelconsumption\/Week2.jpg'), cmap='gray')","75cd3331":"# Processing Fuel Consumption Reports\npara_row = [32+32] + [36]*12\npara_col = [1,1,2,2,2,2,2]\nprocess_folder('fuelconsumption', [\"Week\",\"Day\",\"Machine\",\"Initial\",\"Added\",\"Final\",\"Hours\"], para_row, para_col)","74724ede":"# Manual Reports of Weekly Fuel Consumption & Working Hours\nfig = plt.figure(figsize=(30,10))\nplt.title(\"Manual Reports of Weekly Fuel Inventory\", fontsize=16, fontweight='bold')\nplt.imshow(cv2.imread(input_path + 'fuelinventory\/Week1.JPG'), cmap='gray')","5484d62d":"# Processing Fuel Inventory Reports\npara_row = [1+1] + [1]*21\npara_col = [1,1,1,2,2,2]\nprocess_folder('fuelinventory', [\"Week\",\"Day\",\"Site\",\"In\",\"Out\",\"Redundant\"], para_row, para_col)","78c2184b":"# Fuel Consumption Analysis \ndf = pd.read_csv(output_path + \"\/fuelconsumption.csv\") \n\n# Correction for incorrect read digits\ndf.at[df[(df[\"Week\"] == 2) & (df[\"Day\"] == 2) & (df[\"Machine\"] == 2)].index, \"Hours\"] = 6\n\ndf[\"Fuel_Consumed\"] = (df[\"Initial\"] + df[\"Added\"] - df[\"Final\"])\ndf[\"Fuel_Average\"] = (df[\"Fuel_Consumed\"]) \/ df[\"Hours\"]\n#df.head()\n\ndf1 = df.copy()\ndf1 = pd.pivot_table(df1, values=[\"Hours\",\"Fuel_Consumed\",\"Fuel_Average\"], index=[\"Week\",\"Day\"], columns=\"Machine\")\ndf1.reset_index(inplace=True)\ndf1.head(100)","7656d216":"# Plotting Weekly Avergaes\nN = 6\nind = np.arange(N)\nwidth = 0.2       \n\nfig = plt.figure(figsize=(12,4))\nplt.suptitle(\"Weekly Fuel Averages\", fontweight='bold', fontsize=16, y=1.06)\n\nax1 = fig.add_subplot(121)\ndf_1 = df1[df1[\"Week\"] == 1]\nrects1 = ax1.bar(ind, df_1[(\"Fuel_Average\",1)], width, color='g')\nrects2 = ax1.bar(ind+width, df_1[(\"Fuel_Average\",2)], width, color='y')\nax1.set_title('Week 1', fontsize=16)\nax1.set_ylabel('Fuel Average (L\/hr)', fontsize=14)\nax1.set_xticks(ind+width)\nax1.set_xticklabels((df_1[\"Day\"]), fontsize=12)\nax1.legend((rects1[0],rects2[0]),('Machine 1','Machine 2'), loc='upper right')\nax1.set_ylim((0,14));\n\nax2 = fig.add_subplot(122)\ndf_2 = df1[df1[\"Week\"] == 2]\nrects1 = ax2.bar(ind, df_2[(\"Fuel_Average\",1)], width, color='g')\nrects2 = ax2.bar(ind+width, df_2[(\"Fuel_Average\",2)], width, color='y')\nax2.set_title('Week 2', fontsize=16)\nax2.set_ylabel('Fuel Average (L\/hr)', fontsize=14)\nax2.set_xticks(ind+width)\nax2.set_xticklabels((df_2[\"Day\"]), fontsize=12)\nax2.legend((rects1[0],rects2[0]),('Machine 1','Machine 2'), loc='upper right')\nax2.set_ylim((0,14));","f234a102":"# Plotting Weekly Fuel Consumption & Working Hours\nlabels = 'Machine 1', 'Machine 2'\ncolors = 'g','y'\nexplode = (0, 0.1)\n\nfig = plt.figure(figsize=(12,4))\nplt.suptitle(\"Weekly Fuel Consumption & Working Hours (Week #1)\", fontweight='bold', fontsize=16, y=1.05);\n\nfc11 = df_1[(\"Fuel_Consumed\",1)].sum()\nfc12 = df_1[(\"Fuel_Consumed\",2)].sum()\nfc1 = fc11 + fc12\nsizes = [fc11, fc12]\nax1 = fig.add_subplot(121)\nax1.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',shadow=True, startangle=90)\nax1.title.set_text('Fuel Consumption (' + str(int(fc1)) + ' L)')\nax1.axis('equal') \n\nwh11 = df_1[(\"Hours\",1)].sum()\nwh12 = df_1[(\"Hours\",2)].sum()\nwh1 = wh11 + wh12\nsizes = [wh11, wh12]\nax2 = fig.add_subplot(122)\nax2.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)\nax2.axis('equal')\nax2.title.set_text('Working Hours (' + str(int(wh1)) + ' hrs)')\nplt.show()\n\nfig = plt.figure(figsize=(12,4))\nplt.suptitle(\"Weekly Fuel Consumption & Working Hours (Week #2)\", fontweight='bold', fontsize=16, y=1.05);\n\nfc21 = df_2[(\"Fuel_Consumed\",1)].sum()\nfc22 = df_2[(\"Fuel_Consumed\",2)].sum()\nfc2 = fc21 + fc22\nsizes = [fc21, fc22]\nax1 = fig.add_subplot(121)\nax1.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',shadow=True, startangle=90)\nax1.title.set_text('Fuel Consumption (' + str(int(fc2)) + ' L)')\nax1.axis('equal') \n\nwh21 = df_2[(\"Hours\",1)].sum()\nwh22 = df_2[(\"Hours\",2)].sum()\nwh2 = wh21 + wh22\nsizes = [wh21, wh22]\nax2 = fig.add_subplot(122)\nax2.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)\nax2.axis('equal')\nax2.title.set_text('Working Hours (' + str(int(wh2)) + ' hrs)')\nplt.show()","b574e72a":"# Fuel Inventory Analysis \ndf = pd.read_csv(output_path + \"\/fuelinventory.csv\") \n#df.head()\n\ndf1 = df.copy()\ndf1[\"Balance\"] = 0\ndf1 = pd.pivot_table(df1, values=[\"In\",\"Out\",\"Balance\"], index=[\"Week\",\"Day\"], columns=\"Site\")\ndf1.reset_index(inplace=True)\n\ndf1.loc[df1[\"Day\"] == 0, (\"Balance\",1)] = df1[df1[\"Day\"] == 0][(\"In\",1)]\ndf1.loc[df1[\"Day\"] == 0, (\"Balance\",2)] = df1[df1[\"Day\"] == 0][(\"In\",2)]\ndf1.loc[df1[\"Day\"] == 0, (\"Balance\",3)] = df1[df1[\"Day\"] == 0][(\"In\",3)]\n\nfor i in range(1,df1.shape[0]):\n    df1.at[i,(\"Balance\",1)] = df1.at[i-1,(\"Balance\",1)] + df1.at[i,(\"In\",1)] - df1.at[i,(\"Out\",1)]\n    df1.at[i,(\"Balance\",2)] = df1.at[i-1,(\"Balance\",2)] + df1.at[i,(\"In\",2)] - df1.at[i,(\"Out\",2)]\n    df1.at[i,(\"Balance\",3)] = df1.at[i-1,(\"Balance\",3)] + df1.at[i,(\"In\",3)] - df1.at[i,(\"Out\",3)]\n\ndf1.drop(df1[df1[\"Day\"] == 0].index, inplace=True)\ndf1.head(10)","6eb2a490":"# Plotting Weekly Fuel Stock \ndf1.plot(kind='line', x='Day', y=[('Balance',1), ('Balance',2), ('Balance',3)], color=['r','b','g'], marker='o')\nfig = plt.gcf()\nfig.set_size_inches(10,5)\n\nplt.title('Weekly Fuel Stock', fontweight='bold', fontsize=16)\nplt.xlabel('Day', fontsize=14)\nplt.ylabel('Fuel (L)', fontsize=14)\nplt.legend(('Site 1','Site 2', 'Site 3'), loc='upper right');\nplt.ylim((0,2000));","83e8b301":"DESCRIPTION \n\nToday most of the decisions and actions are driven by data and therefore the data collection has become an integral part to organisations ranging from software companies to sports teams. Though few sectors like internet companies are at inherent advantage when it comes to data collection (photo you tagged, video you liked, etc), other sectors like construction were not evolved with that mindset. Lot of data in small scale businesses is still handwritten and unorganized, making it difficult to generate actionable insights. Here an application is presented to convert these manual reports to databases and informative plots.\n\n\nMETHODOLOGY\n\nFirst, the application uses image-processing to extract the handwritten sections of the reports. These sections are then processed using Convolutional Neural Network (CNN) model to predict the written digits. The CNN model used was trained using MNIST data for handwritten digit classification. The application can process the reports in batches for the entire folder. Eventually the data is appended in the appropriate databases and summarized using plots."}}