{"cell_type":{"4c528889":"code","23ea2187":"code","2a8d0592":"code","fb1c214c":"code","3fe88236":"code","5e02cdd3":"code","8b71fdcf":"code","cd986143":"code","0651e360":"code","b294f84a":"code","f4dca66b":"code","cfc37c86":"code","90551d6d":"code","fbdc66b5":"code","b6d0df0e":"code","e054fe2f":"code","4609e0cb":"code","91b8a12d":"code","df3a8662":"code","6faeb170":"code","7fb9be78":"code","94a1443c":"code","9fd82316":"code","14955318":"code","cd5d3777":"code","b675dccb":"code","6be014d3":"code","d48ac760":"code","f02e117a":"code","b5c166fa":"code","11a45127":"code","3b4d0a0b":"code","06dc5913":"code","c47021d1":"code","4a82cd79":"code","957a7988":"code","0de20483":"code","9f8892cd":"code","1e3ea6ff":"code","60fe70d2":"code","3fea226e":"code","677ddb82":"code","12ac83d7":"code","aac8e289":"code","c1115286":"code","df194e2a":"code","b90fe31f":"code","6dca046f":"code","84cca4b1":"code","894dc1c9":"code","64cbddcb":"markdown","e12e5407":"markdown","5012279f":"markdown","b958be01":"markdown","205c3ede":"markdown","2ce7e8d6":"markdown","9f2da1c3":"markdown","c7cbadbc":"markdown","ae06b340":"markdown","c72e74ea":"markdown","2db239e4":"markdown","4d9712ad":"markdown","c1fd44e4":"markdown","0e1feb48":"markdown","1409b992":"markdown","e08e150e":"markdown","4cc3b112":"markdown","e9d0215c":"markdown","7651ca52":"markdown","dd892285":"markdown","147bbc36":"markdown","2de2b578":"markdown","4a68dcbe":"markdown","433e3154":"markdown","0d7c3286":"markdown","71fcb21d":"markdown","8f984f36":"markdown","5aa1b6f3":"markdown","e6429c48":"markdown","5a395daa":"markdown","b9737b7f":"markdown","e7156cc4":"markdown","39ab898d":"markdown","003fdab1":"markdown","67785876":"markdown","30f6b2ea":"markdown","c4bf723b":"markdown","77167e9e":"markdown","5b835fd8":"markdown","dbda1527":"markdown","41afb651":"markdown"},"source":{"4c528889":"import numpy as np \nimport pandas as pd\nimport os\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.svm import SVR\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_absolute_error,r2_score\nfrom sklearn.neural_network import MLPRegressor\n%matplotlib inline\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","23ea2187":"train = pd.read_csv('\/kaggle\/input\/pubg-finish-placement-prediction\/train_V2.csv')","2a8d0592":"train.shape","fb1c214c":"train.iloc[:,:15].head()","3fe88236":"train.iloc[:,14:].head()","5e02cdd3":"train.info()","8b71fdcf":"train.isnull().sum()","cd986143":"train.dropna(inplace=True)","0651e360":"train.describe().T","b294f84a":"train['kills'].quantile(0.99)","f4dca66b":"#replace any no of kills greater than 0.99 of data with 8 kills for better visuals\ntemp= train.copy()\ntemp.loc[temp['kills'] > temp['kills'].quantile(0.99)] = '8+'\nplt.figure(figsize=(15,10))\nsns.countplot(temp['kills'].astype('str').sort_values())\nplt.title('No. of Kills');","cfc37c86":"temp= train.copy()\ntemp =temp[temp['kills']==0]\nplt.figure(figsize=(15,10))\nsns.distplot(temp['damageDealt'])\nplt.title('Damage dealt by non killers');","90551d6d":"del temp","fbdc66b5":"train.columns","b6d0df0e":"plt.figure(figsize=(15,10))\nplt.xticks(rotation=45)\nsns.countplot(train['matchType'].astype('str'));","e054fe2f":"train['matchType'].value_counts()","4609e0cb":"train.matchType.replace(['squad-fpp','squad','normal-squad-fpp','normal-squad'],'Squad',inplace=True)","91b8a12d":"train.matchType.replace(['duo-fpp','duo','normal-duo-fpp','normal-duo'],'Duo',inplace=True)\n","df3a8662":"train.matchType.replace(['solo-fpp','solo','normal-solo-fpp','normal-solo'],'Solo',inplace=True)","6faeb170":"train.matchType.replace(['crashfpp','flaretpp','flarefpp','crashtpp'],'Othertypes',inplace=True)","7fb9be78":"sns.countplot(train.matchType);","94a1443c":"print('{}% of players play as Squads'.format(train.matchType.value_counts()['Squad']\/len(train.matchType) *100 ))","9fd82316":"## The running players\nprint('A player travels an avg distance of {} meters'.format(train['walkDistance'].mean()))","14955318":"temp= train.copy()\ntemp=temp[temp['walkDistance'] > temp['walkDistance'].quantile(0.99)] \nplt.figure(figsize=(15,10))\nsns.distplot(temp['walkDistance'])\nplt.title('Walking dinstance distribution');","cd5d3777":"plt.figure(figsize=(15,10))\nsns.scatterplot(x='winPlacePerc',y='walkDistance',data=train)\nplt.title('The relationship between winning and running')","b675dccb":"train[['winPlacePerc','walkDistance']].corr()","6be014d3":"plt.figure(figsize=(15,10))\nsns.scatterplot(x='winPlacePerc',y='rideDistance',data=train)\nplt.title('The relationship between winning and driving')","d48ac760":"train[['winPlacePerc','rideDistance']].corr()","f02e117a":"f,ax1 = plt.subplots(figsize =(20,10))\nsns.pointplot(x='vehicleDestroys',y='winPlacePerc',data=train,color='#606060',alpha=0.8)\nplt.xlabel('Number of Vehicle Destroys',fontsize = 15,color='blue')\nplt.ylabel('Win Percentage',fontsize = 15,color='blue')\nplt.title('Vehicle Destroys\/ Win Ratio',fontsize = 20,color='blue')\nplt.grid();","b5c166fa":"f,ax1 = plt.subplots(figsize =(20,10))\nsns.pointplot(x='revives',y='winPlacePerc',data=train,alpha=0.8)\nplt.xlabel('Number of Revives',fontsize = 15,color='blue')\nplt.ylabel('Win Percentage',fontsize = 15,color='blue')\nplt.title('Revives\/ Win Ratio',fontsize = 20,color='blue')\nplt.grid();","11a45127":"plt.figure(figsize=(15,10))\nsns.scatterplot(x='winPlacePerc',y='heals',data=train)\nplt.title('The relationship between winning and healing elements')","3b4d0a0b":"train[['winPlacePerc','heals']].corr()","06dc5913":"train[['winPlacePerc','boosts']].corr()","c47021d1":"train.shape","4a82cd79":"f,ax = plt.subplots(figsize=(15, 15))\nsns.heatmap(train.corr(), annot=True, linewidths=.5, fmt= '.1f',ax=ax);","957a7988":"f,ax = plt.subplots(figsize=(11, 11))\ncols = train.corr().nlargest(5, 'winPlacePerc')['winPlacePerc'].index\ncm = np.corrcoef(train[cols].values.T)\nsns.set(font_scale=1.25)\nhm = sns.heatmap(cm, cbar=True, annot=True, square=True, fmt='.2f', annot_kws={'size': 10}, yticklabels=cols.values, xticklabels=cols.values)\nplt.show()","0de20483":"train['playersJoined'] = train.groupby('matchId')['matchId'].transform('count')","9f8892cd":"plt.figure(figsize=(15,15))\ntemp=train[train['playersJoined']>=50]\nsns.countplot(temp['playersJoined'])\nplt.title(\"Players Joined\",fontsize=15)\nplt.show()","1e3ea6ff":"train['healsAndBoosts'] = train['heals']+train['boosts']\ntrain['totalDistance'] = train['walkDistance']+train['rideDistance']+train['swimDistance']","60fe70d2":"train.columns","3fea226e":"train['team'] = [1 if i>50 else 2 if (i>25 & i<=50) else 4 for i in train['numGroups']]","677ddb82":"train.columns","12ac83d7":"train=train[['assists','healsAndBoosts','damageDealt','DBNOs','kills','playersJoined','totalDistance','weaponsAcquired','winPlacePerc']]","aac8e289":"train.head()","c1115286":"X=train.drop('winPlacePerc',axis=1)\ny=train['winPlacePerc']","df194e2a":"sns.distplot(X['damageDealt']);","b90fe31f":"sns.distplot(X['totalDistance']);","6dca046f":"X['damageDealt']=X['damageDealt']**(1\/3)\nsns.distplot(X['damageDealt']);","84cca4b1":"X['totalDistance']=X['totalDistance']**(1\/3)\nsns.distplot(X['totalDistance']);","894dc1c9":"## to do, regression :D","64cbddcb":"### The killers..","e12e5407":"# last thing I will check is the boosts and healing elements\n","5012279f":"### most people don't kill anyone, let's check if they deal damage..","b958be01":"### Let's move on to check who wins most Solos,Duos or squads?","205c3ede":"### looks like it doesn't affect winning that much.. ","2ce7e8d6":"### Most walking players win according to the scatter plot with a correlation coefficient of 0.81","9f2da1c3":"### let's check riding vehicles..","c7cbadbc":"### getting rid of skewness","ae06b340":"### checking datatypes","c72e74ea":"# PUBG mobile data analysis","2db239e4":"## PUBG is a team based game, when a member in your team is knocked down, you can revive him and bring him back in the game as long as he's not dead..let's check if that affects the winning.","4d9712ad":"### looks like health boosters do relate to winning, as shown in the plots below with a correlation coefficient of 0.42 for heals, and 0.634 for boosts","c1fd44e4":"### reading dataset","0e1feb48":"### looks like datatypes are fine","1409b992":"### Creating new feature playersJoined that indicate the number of players in a game","e08e150e":"### Get the number of players in a team corresponding to solos, duos, and squads in team columns","4cc3b112":"## EDA and visulaization","e9d0215c":"### let's check correlation between variables in our data","7651ca52":"## Feature engineering.","dd892285":"### looks like there's a +ve correlation, let's get the exact value","147bbc36":"### driving is less corelated, but there's a trick in PUBG a player can kill an enemy by destroyng the enemy's car by shooting it or throwing a bomb at it, let's check","2de2b578":"### There are many attributes that have little corr values with the target variable..let's choose the top 5 attributes and explore them further,it's also to be noticed that the least correlated feature is the kill place","4a68dcbe":"### both are +ve skewed so i'll use cube root transformation to keep 0 values","433e3154":"### checking missing values","0d7c3286":"### most players play as squad \"4members\"","71fcb21d":"### getting stats. info ","8f984f36":"### it's obvious that most non killers don't deal damage too.","5aa1b6f3":"### importing libraries","e6429c48":"## let's see what's the best strategy to win a match through: vehicles,kills damages and other variables.","5a395daa":"## The winning strategy (My objective):\n### So I\u2019ve said in the beginning that I\u2019m trying to find out the best strategy to win a PUBG game by using analytics, so here\u2019s what I figured out from the analysis:\n1. Play in a team.\n2. Use healings and health-boosting elements.\n3. Destroy your enemies vehicles.\n4. Kill as many enemies as you can.\n5. Move a lot and collect powerful weapons.\n","b9737b7f":"### In EDA we knew that bosts and healing elements increase tha chance of winning a game so let's put them in one feature also the walking,swimming and riding distance","e7156cc4":"### selecting relavent data columns","39ab898d":"### 1- Movement and vehicles","003fdab1":"### The relationship between walking and winning","67785876":"### The point plot, it shows that destroying at least on vehicle increases the chance of winning by ~35%, AWESOME!!","30f6b2ea":"## In this notebook, I\u2019ll be analyzing PUBG mobile game dataset, which is an online battle game, I will also build a model to predict the winning place percentage of a player. \n### In a PUBG game, up to 100 players start in each match (matchId). Players can be on teams (groupId) that get ranked at the end of the game (winPlacePerc) based on how many other teams are still alive when they are eliminated. In-game, players can pick up different munitions, revive downed-but-not-out (knocked) teammates, drive vehicles, swim, run, shoot, and experience all of the consequences -- such as falling too far or running themselves over and eliminating themselves. My goal in this project is to build a storyline of the perfect winning PUBG match with the help of EDA and ML.","c4bf723b":"### let's check the matchType further as tpp and fpp are not that intersting it's just a mode","77167e9e":"### only one missing value, we'll drop it as it's not significant ","5b835fd8":"### A PUBG game typically have 100 players but sometimes not all the 100 players join, let's create a feature indicates the number of players in a pubg match","dbda1527":"### Combine all squad types into 1 column Squad, same for solo, duo other will be combined in others","41afb651":"### all the 29 columns wouldn't fit in the preview so I'll divide them"}}