{"cell_type":{"ed5c49b6":"code","735746b2":"code","ece5e199":"code","51024889":"code","24082024":"code","b3ff1c1c":"code","38aafde5":"code","7a2e4ac1":"code","0b61b9a7":"code","bd9a354d":"markdown","d4eb3ca3":"markdown","98f5c51b":"markdown","dcc52598":"markdown","276f43a5":"markdown","6b6ca845":"markdown"},"source":{"ed5c49b6":"import itertools\nimport re\n\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt # plotting\nimport numpy as np # linear algebra\nimport os # accessing directory structure\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns","735746b2":"print(os.listdir('..\/input'))","ece5e199":"def heatmap(x, y, **kwargs):\n    if 'color' in kwargs:\n        color = kwargs['color']\n    else:\n        color = [1]*len(x)\n\n    if 'palette' in kwargs:\n        palette = kwargs['palette']\n        n_colors = len(palette)\n    else:\n        n_colors = 256 # Use 256 colors for the diverging color palette\n        palette = sns.color_palette(\"Blues\", n_colors) \n\n    if 'color_range' in kwargs:\n        color_min, color_max = kwargs['color_range']\n    else:\n        color_min, color_max = min(color), max(color) # Range of values that will be mapped to the palette, i.e. min and max possible correlation\n\n    def value_to_color(val):\n        if color_min == color_max:\n            return palette[-1]\n        else:\n            val_position = float((val - color_min)) \/ (color_max - color_min) # position of value in the input range, relative to the length of the input range\n            val_position = min(max(val_position, 0), 1) # bound the position betwen 0 and 1\n            ind = int(val_position * (n_colors - 1)) # target index in the color palette\n            return palette[ind]\n\n    if 'size' in kwargs:\n        size = kwargs['size']\n    else:\n        size = [1]*len(x)\n\n    if 'size_range' in kwargs:\n        size_min, size_max = kwargs['size_range'][0], kwargs['size_range'][1]\n    else:\n        size_min, size_max = min(size), max(size)\n\n    size_scale = kwargs.get('size_scale', 500)\n\n    def value_to_size(val):\n        if size_min == size_max:\n            return 1 * size_scale\n        else:\n            val_position = (val - size_min) * 0.99 \/ (size_max - size_min) + 0.01 # position of value in the input range, relative to the length of the input range\n            val_position = min(max(val_position, 0), 1) # bound the position betwen 0 and 1\n            return val_position * size_scale\n    if 'x_order' in kwargs: \n        x_names = [t for t in kwargs['x_order']]\n    else:\n        x_names = [t for t in sorted(set([v for v in x]))]\n    x_to_num = {p[1]:p[0] for p in enumerate(x_names)}\n\n    if 'y_order' in kwargs: \n        y_names = [t for t in kwargs['y_order']]\n    else:\n        y_names = [t for t in sorted(set([v for v in y]))]\n    y_to_num = {p[1]:p[0] for p in enumerate(y_names)}\n\n    plot_grid = plt.GridSpec(1, 15, hspace=0.2, wspace=0.1) # Setup a 1x10 grid\n    ax = plt.subplot(plot_grid[:,:-1]) # Use the left 14\/15ths of the grid for the main plot\n\n    marker = kwargs.get('marker', 's')\n\n    kwargs_pass_on = {k:v for k,v in kwargs.items() if k not in [\n         'color', 'palette', 'color_range', 'size', 'size_range', 'size_scale', 'marker', 'x_order', 'y_order'\n    ]}\n\n    ax.scatter(\n        x=[x_to_num[v] for v in x],\n        y=[y_to_num[v] for v in y],\n        marker=marker,\n        s=[value_to_size(v) for v in size], \n        c=[value_to_color(v) for v in color],\n        **kwargs_pass_on\n    )\n    ax.set_xticks([v for k,v in x_to_num.items()])\n    ax.set_xticklabels([k for k in x_to_num], rotation=45, horizontalalignment='right')\n    ax.set_yticks([v for k,v in y_to_num.items()])\n    ax.set_yticklabels([k for k in y_to_num])\n\n    ax.grid(False, 'major')\n    ax.grid(True, 'minor')\n    ax.set_xticks([t + 0.5 for t in ax.get_xticks()], minor=True)\n    ax.set_yticks([t + 0.5 for t in ax.get_yticks()], minor=True)\n\n    ax.set_xlim([-0.5, max([v for v in x_to_num.values()]) + 0.5])\n    ax.set_ylim([-0.5, max([v for v in y_to_num.values()]) + 0.5])\n    ax.set_facecolor('#F1F1F1')\n\n    # Add color legend on the right side of the plot\n    if color_min < color_max:\n        ax = plt.subplot(plot_grid[:,-1]) # Use the rightmost column of the plot\n\n        col_x = [0]*len(palette) # Fixed x coordinate for the bars\n        bar_y=np.linspace(color_min, color_max, n_colors) # y coordinates for each of the n_colors bars\n\n        bar_height = bar_y[1] - bar_y[0]\n        ax.barh(\n            y=bar_y,\n            width=[5]*len(palette), # Make bars 5 units wide\n            left=col_x, # Make bars start at 0\n            height=bar_height,\n            color=palette,\n            linewidth=0\n        )\n        ax.set_xlim(1, 2) # Bars are going from 0 to 5, so lets crop the plot somewhere in the middle\n        ax.grid(False) # Hide grid\n        ax.set_facecolor('white') # Make background white\n        ax.set_xticks([]) # Remove horizontal ticks\n        ax.set_yticks(np.linspace(min(bar_y), max(bar_y), 3)) # Show vertical ticks for min, middle and max\n        ax.yaxis.tick_right() # Show vertical ticks on the right \n","51024889":"# Correlation matrix\ndef plotCorrelationMatrix(df, graphWidth):\n    filename = df.dataframeName\n    df = df.dropna('columns') # drop columns with NaN\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    if df.shape[1] < 2:\n        print(f'No correlation plots shown: The number of non-NaN or constant columns ({df.shape[1]}) is less than 2')\n        return\n    corr = df.corr()\n    plt.figure(num=None, figsize=(graphWidth, graphWidth), dpi=80, facecolor='w', edgecolor='k')\n    corrMat = plt.matshow(corr, fignum = 1)\n    plt.xticks(range(len(corr.columns)), corr.columns, rotation=90)\n    plt.yticks(range(len(corr.columns)), corr.columns)\n    plt.gca().xaxis.tick_bottom()\n    plt.colorbar(corrMat)\n    plt.title(f'Correlation Matrix for {filename}', fontsize=15)\n    \n    \n    #EINGEF\u00dcGT\n    def corrplot(data, size_scale=500, marker='s'):\n        corr = pd.melt(data.reset_index(), id_vars='index')\n        corr.columns = ['x', 'y', 'value']\n        heatmap(\n            corr['x'], corr['y'],\n            color=corr['value'], color_range=[-1, 1],\n            palette=sns.diverging_palette(20, 220, n=256),\n            size=corr['value'].abs(), size_range=[0,1],\n            marker=marker,\n            x_order=data.columns,\n            y_order=data.columns[::-1],\n            size_scale=size_scale\n    )\n    ##\n    corrplot(corr)#, size_scale=1000)\n    plt.savefig('correlation.png')\n    plt.show()\n","24082024":"raw1 = pd.read_csv('..\/input\/steam.csv', delimiter=',')\nnRow, nCol = raw1.shape\nprint(f'There are {nRow} rows and {nCol} columns')","b3ff1c1c":"raw1.head(5)","38aafde5":"def filter_columns_for_correlation(df, filter_many):\n    #nRow, nCol = df.shape\n    #print(f'There are {nRow} rows and {nCol} columns before filtering')\n    df.head()\n    if filter_many == True:\n        df = df.drop(['est_revenue','single_player', 'multi_player', 'weighted_rating', 'owners', 'appid', 'name', 'required_age', 'english', 'total_ratings', 'achievements', 'release_year', 'positive_ratings', 'negative_ratings', 'massively_multiplayer', 'average_playtime', 'median_playtime'], axis=1)\n    else:\n        df = df.drop(['appid', 'name', 'total_ratings', 'release_year', 'weighted_rating', 'positive_ratings', 'negative_ratings', 'average_playtime'], axis=1)    \n    #nRow, nCol = df.shape\n    #print(f'There are {nRow} rows and {nCol} columns after filtering')\n    df.head()\n    return df\n\ndef remove_non_english(df):\n    df = df[df['english'] == 1].copy()\n    \n    # doesn't contain 3 or more non-ascii characters\n    df = df[~df['name'].str.contains('[^\\u0001-\\u007F]{3,}')]\n    \n    df = df.drop('english', axis=1)\n    \n    return df\n\n\ndef calc_rating(row):\n\n    import math\n\n    pos = row['positive_ratings']\n    neg = row['negative_ratings']\n\n    total_reviews = pos + neg\n\n    average = pos \/ total_reviews\n\n    score = average - (average*0.5) * 2**(-math.log10(total_reviews + 1))\n\n    return score * 100\n\n\ndef get_unique(series):\n    return set(list(itertools.chain(*series.apply(lambda x: [c for c in x.split(';')]))))\n\n\ndef process_cat_gen_tag(df):\n    cat_cols = get_unique(df['categories'])\n    \n    # remove comments to use all categories\n    cat_cols = [\n#         'Local Multi-Player',\n#         'MMO',\n#         'Mods',\n        'Multi-player',\n#         'Online Co-op',\n#         'Online Multi-Player',\n        'Single-player'\n    ]\n    \n    for col in sorted(cat_cols):\n        col_name = re.sub(r'[\\s\\-\\\/]', '_', col.lower())\n        col_name = re.sub(r'[()]', '', col_name)\n        \n        df[col_name] = df['categories'].apply(lambda x: 1 if col in x.split(';') else 0)\n        \n    gen_cols = get_unique(df['genres'])\n    \n    # remove comments to use all genres. Currently uses main ones as per steam store home page\n    gen_cols = [\n#         'Accounting',\n        'Action',\n        'Adventure',\n#         'Animation & Modeling',\n#         'Audio Production',\n        'Casual',\n#         'Design & Illustration',\n#         'Documentary',\n#         'Early Access',\n#         'Education',\n#         'Free to Play',\n#         'Game Development',\n#         'Gore',\n        'Indie',\n        'Massively Multiplayer',\n#         'Nudity',\n#         'Photo Editing',\n        'RPG',\n        'Racing',\n#         'Sexual Content',\n        'Simulation',\n#         'Software Training',\n        'Sports',\n        'Strategy'\n#         'Tutorial',\n#         'Utilities',\n#         'Video Production',\n#         'Violent',\n#         'Web Publishing'\n    ]\n    \n    gen_col_names = []\n    \n    for col in sorted(gen_cols):\n        col_name = col.lower().replace('&', 'and').replace(' ', '_')\n        gen_col_names.append(col_name)\n        \n        df[col_name] = df['genres'].apply(lambda x: 1 if col in x.split(';') else 0)\n    \n    # remove \"non-games\" based on genre\n    gen_sums = df[gen_col_names].sum(axis=1)\n    df = df[gen_sums > 0]\n        \n    tag_cols = get_unique(df['steamspy_tags'])\n    # df['top_tag'] = df['tags'].apply(lambda x: x.split(';')[0] if ';' in x else x)\n    \n    # display(cat_cols, gen_cols, tag_cols)\n    df = df.drop(['categories', 'genres', 'steamspy_tags'], axis=1)\n    \n    return df\n\n\ndef process_year(df):\n    df['release_date'] = df['release_date'].astype('datetime64[ns]')\n    df['release_year'] = df['release_date'].apply(lambda x: x.year)\n    return df\n\n    \ndef process_revenue(df):\n    df['est_revenue'] = df['owners'] * df['price']\n    return df\n\n\ndef process_price(df):\n    cut_points = [-1, 0, 4, 10, 30, 50, 1000]\n    label_names = ['free', 'very cheap', 'cheap', 'moderate', 'expensive', 'very expensive']\n    \n    df['price_categories'] = pd.cut(df['price'], cut_points, labels=label_names)\n    \n    return df\n\n\ndef pre_process(df):\n    # DEAKTIVIERT\n    # english only\n    #df = remove_non_english(df)\n    \n    # DEAKTIVIERT\n    # windows only\n    #df = df[df['platforms'].str.contains('windows')].drop('platforms', axis=1).copy()\n    \n    df['owners'] = df['owners'].str.split('-').apply(lambda x: (int(x[0]) + int(x[1])) \/ 2).astype(int)\n    # df['owners'] = df['owners'].str.replace('[+,]', '').astype(int)\n    \n    # calculate ratings\n    df['total_ratings'] = df['positive_ratings'] + df['negative_ratings']\n    df['ratings_ratio'] = df['positive_ratings'] \/ df['total_ratings']\n    df['weighted_rating'] = df.apply(calc_rating, axis=1)\n    # df = df.drop(['positive', 'negative'], axis=1)\n    \n    df = df.rename(columns={'average_forever': 'average_playtime', 'median_forever': 'median_playtime'})\n    \n    df = process_year(df)\n    df = process_revenue(df)\n    df = process_price(df)\n    df = process_cat_gen_tag(df)\n    \n    return df\n\ndf1 = pre_process(raw1)\ndf1.dataframeName = 'steam'\n\nnRow, nCol = df1.shape\nprint(f'There are {nRow} rows and {nCol} columns after preprocessing')\n\n#df1.head()","7a2e4ac1":"df_correlation = df1\ndf_correlation = filter_columns_for_correlation(df_correlation, False)\ndf_correlation.dataframeName = 'steam'\ndf_correlation.head()","0b61b9a7":"plotCorrelationMatrix(df_correlation, 10)","bd9a354d":"There is 1 csv file in the current version of the dataset:\n","d4eb3ca3":"### Let's check 1st file: ..\/input\/steam.csv","98f5c51b":"The next hidden code cells define functions for plotting data. Click on the \"Code\" button in the published kernel to reveal the hidden code.","dcc52598":"Let's take a quick look at what the raw data looks like:","276f43a5":"Now let's do a bit of feature engineering, and transform some columns into more useful ones.","6b6ca845":"Now you're ready to read in the data and use the plotting functions to visualize the data."}}