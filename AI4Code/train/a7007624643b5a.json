{"cell_type":{"59288543":"code","de69acc0":"code","5b920b58":"code","861ee48f":"code","a3be49db":"code","91454e60":"code","3190cd21":"code","dd7c2e28":"code","ce327ff9":"code","455433a5":"code","7f346402":"markdown"},"source":{"59288543":"### READING DATA FROM INPUT\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\n# remove warning!!\npd.options.mode.chained_assignment = None  # default='warn'\n\n\nimport os\n# print(os.listdir(\"..\/input\"))\ndf = pd.read_csv(\"..\/input\/train.csv\", index_col=[0])\ntestData = pd.read_csv(\"..\/input\/test.csv\")\n### DESCRIPTION OF DATA\ndf.describe(include=\"all\")","de69acc0":"### DATA PREPARATION ###\ndef prepare(df):\n    global json_cols\n    global train_dict\n\n    ### separate release date into year, month, day\n    df[['release_month','release_day','release_year']]=df['release_date'].str.split('\/',expand=True).replace(np.nan, 0).astype(int)\n    df['release_year'] = df['release_year']\n    df.loc[ (df['release_year'] <= 18) & (df['release_year'] < 100), \"release_year\"] += 2000\n    df.loc[ (df['release_year'] > 18)  & (df['release_year'] < 100), \"release_year\"] += 1900\n    ###\n\n    ### add ratio datas for correlations\n    meanRuntime = df['runtime'].mean()\n    df.loc[ df['runtime'] == 0 ,'runtime'] = meanRuntime\n    df['_budget_runtime_ratio'] =  df['budget']\/df['runtime']\n    df['_budget_popularity_ratio'] = df['budget']\/df['popularity']\n    df['_budget_year_ratio'] = df['budget']\/(df['release_year'])\n    df['_releaseYear_popularity_ratio'] = df['release_year']\/df['popularity']\n    df['_popularity_releaseYear_ratio'] = df['popularity']\/df['release_year']\n    ###\n\n    ### add binary fields for descriptive data\n    df['isMovieReleased'] = 1\n    df.loc[ df['status'] != \"Released\" ,\"isMovieReleased\"] = 0 \n\n    df['isOriginalLanguageEng'] = 0 \n    df.loc[ df['original_language'] == \"en\" ,\"isOriginalLanguageEng\"] = 1\n    ###\n\n    ### add mean data\n    df['meanRuntimeByYear'] = df.groupby(\"release_year\")[\"runtime\"].aggregate('mean')\n    ###\n    \n    df = df.drop(['belongs_to_collection','genres','homepage','overview', 'imdb_id'\n    ,'poster_path','production_companies','production_countries','release_date','spoken_languages'\n    ,'status','title','Keywords','cast','crew','original_language','original_title','tagline'\n    ],axis=1)\n    \n    df.fillna(value=0.0, inplace = True) \n    df.fillna(value=0.0, inplace = True) \n    return df\n\n# all_data = prepare(pd.concat([df, testData], sort=True).reset_index(drop = True))\ntrain = prepare(df)\ntrain['id'] = range(1, len(train) + 1)\ntrain.index = train['id']\n\ntest = prepare(testData)\ntest['id'] = range(1, len(test) + 1)\ntest.index = test['id']\n\n\n### END OF DATA PREPARATION ###\n# data after preparation:\nfeatures = list(train.columns)\nfeatures =  [i for i in features if i != 'id' and i != 'revenue']\nprint(\"*** Features are:\")\nprint(train.dtypes)\ntrain.describe(include=\"all\")","5b920b58":"### K-FOLD Class Decleration\nfrom sklearn.model_selection import GroupKFold\nfrom sklearn.metrics import mean_squared_error\n\ndef score(data, y):\n    validation_res = pd.DataFrame(\n    {\"id\": data[\"id\"].values,\n     \"transactionrevenue\": data[\"revenue\"].values,\n     \"predictedrevenue\": np.expm1(y)})\n\n    validation_res = validation_res.groupby(\"id\")[\"transactionrevenue\", \"predictedrevenue\"].sum().reset_index()\n    return np.sqrt(mean_squared_error(np.log1p(validation_res[\"transactionrevenue\"].values), \n                                     np.log1p(validation_res[\"predictedrevenue\"].values)))\n\nclass KFoldValidation():\n    def __init__(self, data, n_splits=5):\n        unique_vis = np.array(sorted(data['id'].astype(str).unique()))\n        folds = GroupKFold(n_splits)\n        ids = np.arange(data.shape[0])\n        \n        self.fold_ids = []\n        for trn_vis, val_vis in folds.split(X=unique_vis, y=unique_vis, groups=unique_vis):\n            self.fold_ids.append([\n                    ids[data['id'].astype(str).isin(unique_vis[trn_vis])],\n                    ids[data['id'].astype(str).isin(unique_vis[val_vis])]\n                ])\n            \n    def validate(self, train, test, features, model, name=\"\", prepare_stacking=False, \n                 fit_params={\"early_stopping_rounds\": 500, \"verbose\": 0, \"eval_metric\": \"rmse\"}):\n        model.FI = pd.DataFrame(index=features)\n        full_score = 0\n        \n        if prepare_stacking:\n            test[name] = 0\n            train[name] = np.NaN\n        \n        for fold_id, (trn, val) in enumerate(self.fold_ids):\n            devel = train[features].iloc[trn]\n            y_devel = np.log1p(train[\"revenue\"].iloc[trn])\n            valid = train[features].iloc[val]\n            y_valid = np.log1p(train[\"revenue\"].iloc[val])\n                       \n            #print(\"Fold \", fold_id, \":\")\n            model.fit(devel, y_devel, eval_set=[(valid, y_valid)], **fit_params)\n            \n            if len(model.feature_importances_) == len(features):  # some bugs in catboost?\n                model.FI['fold' + str(fold_id)] = model.feature_importances_ \/ model.feature_importances_.sum()\n\n            predictions = model.predict(valid)\n            predictions[predictions < 0] = 0\n            #print(\"Fold \", fold_id, \" error: \", mean_squared_error(y_valid, predictions)**0.5)\n            \n            fold_score = score(train.iloc[val], predictions)\n            full_score += fold_score \/ len(self.fold_ids)\n            #print(\"Fold \", fold_id, \" score: \", fold_score)\n            \n            if prepare_stacking:\n                train[name].iloc[val] = predictions\n                \n                test_predictions = model.predict(test[features])\n                test_predictions[test_predictions < 0] = 0\n                test[name] += test_predictions \/ len(self.fold_ids)\n                \n        print(\"Final score: \", full_score)\n        return full_score\n\nKfoldResult = KFoldValidation(train)","861ee48f":"### K-Fold Validation with lightgbm\nimport lightgbm as lgb\n\nlgbmodel = lgb.LGBMRegressor(n_estimators=10000, \n                             objective=\"regression\", \n                             metric=\"rmse\", \n                             num_leaves=20, \n                             min_child_samples=100,\n                             learning_rate=0.01, \n                             bagging_fraction=0.8, \n                             feature_fraction=0.8, \n                             bagging_frequency=1, \n                             bagging_seed=2019, \n                             subsample=.9, \n                             colsample_bytree=.9,\n                             use_best_model=True)\n\nKfoldResult.validate(train, test, features , lgbmodel, name=\"lgbfeatures\", prepare_stacking=True) \n","a3be49db":"### plot features importance\nsortedFeatureValues = lgbmodel.FI.mean(axis=1).sort_values()\nsortedFeatureValues.plot(kind=\"barh\",title = \"Features Importance\", figsize = (10,10));\n","91454e60":"### Correlation matrix\nfrom pandas.plotting import scatter_matrix\n\ndef plot_corr(df,size=10):\n    '''Function plots a graphical correlation matrix for each pair of columns in the dataframe.\n\n    Input:\n        df: pandas DataFrame\n        size: vertical and horizontal size of the plot'''\n\n    corr = df.corr()\n    fig = plt.figure(figsize=(size, size))\n    ax = fig.add_subplot(111)\n    cmap = plt.cm.get_cmap('RdYlBu')\n    cax = ax.matshow(corr, vmin=-1, vmax=1, cmap=cmap)\n    fig.colorbar(cax)\n    ax.matshow(corr, cmap=cmap)\n    plt.xticks(range(len(corr.columns)), corr.columns, rotation='vertical');\n    plt.yticks(range(len(corr.columns)), corr.columns);\n    plt.show()\n\n### WAY 1 ###\nplot_corr(train, 10)\n\n### WAY 2 ###\n#corr = train.corr()\n#corr.style.background_gradient(cmap='coolwarm').set_precision(2)\n\n### WAY 3 ###\n# scatter_matrix(train)","3190cd21":"def trainWithModel(X, Y, testX, features, target, model, modelName):    \n    predictY = model.predict(testX)\n\n    for feature in features:\n        testResults = pd.DataFrame(data=predictY, columns=[target])\n        testResults[feature] = test[feature]\n        testResults = testResults.sort_values(feature)\n        plt.xlabel(feature)\n        plt.ylabel(target)\n        plt.scatter(train[feature], Y, color='black', s=3)    \n        plt.plot(testResults[feature], testResults[target], color='blue', linewidth=1)\n        plt.show()\n\n    predictY = pd.DataFrame(data=predictY,    # values\n                  columns=[target])  # 1st row as the column names\n    predictY['id'] = testData['id']\n    predictY.index = predictY['id']\n\n    predictY.to_csv(modelName+\".csv\", index=False)","dd7c2e28":"### LINEAR REGRESSION TRAINING\nfrom sklearn import preprocessing\nfrom sklearn.linear_model import LinearRegression\n\n# filterItems = ['release_year', 'runtime']#, 'popularity', '_budget_runtime_ratio', '_budget_popularity_ratio', '_releaseYear_popularity_ratio', 'budget']\ntestItem = 'revenue'\n\n## features based on correlation matrix\nfilterItems = ['budget', '_budget_year_ratio', '_budget_runtime_ratio', 'runtime', 'release_year']\n\ntestCols = test[filterItems]\ntestX = testCols.values.reshape(-1, len(filterItems))\n\ntrainCols = train[filterItems]\nX = trainCols.values.reshape(-1, len(filterItems))\nY = train[testItem].values\n\nlinearModel = LinearRegression()\nlinearModel.fit(X, Y)\n\ntrainWithModel(X, Y, testX, filterItems, testItem, linearModel, 'linearRegression')\n","ce327ff9":"### Ridge regression\nfrom sklearn.linear_model import RidgeCV\n\n# filterItems = ['release_year', 'runtime', 'popularity', '_budget_runtime_ratio', '_budget_popularity_ratio', '_releaseYear_popularity_ratio', 'budget']\nfilterItems = [\n'budget'\n,'popularity'\n,'runtime'\n,'release_month'\n,'release_day'\n,'release_year'\n,'_budget_runtime_ratio'\n,'_budget_popularity_ratio'\n,'_budget_year_ratio'\n,'_releaseYear_popularity_ratio'\n# ,'_popularity_releaseYear_ratio'\n# ,'isMovieReleased'\n# ,'isOriginalLanguageEng'\n# ,'meanRuntimeByYear'\n### Last Four Items contain ill-conditioned data\n]\n\n\ntarget = 'revenue'\n\n\ntestCols = test[filterItems]\ntestX = testCols.values.reshape(-1, len(filterItems))\n\ntrainCols = train[filterItems]\nX = trainCols.values.reshape(-1, len(filterItems))\nY = train[testItem].values\n\nridgeModel = RidgeCV(cv=5)\nridgeModel.fit(X, Y)\n\ntrainWithModel(X, Y, testX, filterItems, target, ridgeModel, 'ridgeRegression')","455433a5":"### Ridge regression and Lasso regression\nfrom sklearn.linear_model import LassoCV\n\n# filterItems = ['release_year', 'runtime', 'popularity', '_budget_runtime_ratio', '_budget_popularity_ratio', '_releaseYear_popularity_ratio', 'budget']\nfilterItems = [\n'budget'\n,'popularity'\n,'runtime'\n,'release_month'\n,'release_day'\n,'release_year'\n,'_budget_runtime_ratio'\n,'_budget_popularity_ratio'\n,'_budget_year_ratio'\n,'_releaseYear_popularity_ratio'\n# ,'_popularity_releaseYear_ratio'\n# ,'isMovieReleased'\n# ,'isOriginalLanguageEng'\n# ,'meanRuntimeByYear'\n### Last Four Items contain ill-conditioned data\n]\n\ntarget = 'revenue'\n\n\ntestCols = test[filterItems]\ntestX = testCols.values.reshape(-1, len(filterItems))\n\ntrainCols = train[filterItems]\nX = trainCols.values.reshape(-1, len(filterItems))\nY = train[testItem].values\n\nlassoModel = LassoCV(cv=5)\nlassoModel.fit(X, Y)\n\ntrainWithModel(X, Y, testX, filterItems, target, lassoModel, 'lassoRegression')","7f346402":"based on correlation matrix, revenue is more related to **budget**, **budget_runtime_ratio** and **budget_year_ratio**."}}