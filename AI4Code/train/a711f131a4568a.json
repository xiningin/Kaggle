{"cell_type":{"920ac0a8":"code","bbc0b25b":"code","55bfe5da":"code","123294e5":"code","0f785166":"code","d3b1a532":"code","32d8b0bb":"code","ee52f6e0":"code","98394299":"code","b47df67d":"code","3b44d94c":"code","613f7125":"code","19f6ad98":"markdown","58937c21":"markdown","dc3721f8":"markdown","51a4cb02":"markdown","3c78321d":"markdown"},"source":{"920ac0a8":"import numpy as np\nimport pandas as pd \nfrom numba import njit","bbc0b25b":"data = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/family_data.csv', index_col='family_id')\nsubmission = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/sample_submission.csv', index_col='family_id')","55bfe5da":"family_size_dict = data[['n_people']].to_dict()['n_people']\n\ncols = [f'choice_{i}' for i in range(10)]\nchoice_dict = data[cols].to_dict()\n\nN_DAYS = 100\nMAX_OCCUPANCY = 300\nMIN_OCCUPANCY = 125\n\n# from 100 to 1\ndays = list(range(N_DAYS,0,-1))\n\ndef old_cost_function(prediction):\n    penalty = 0\n\n    # We'll use this to count the number of people scheduled each day\n    daily_occupancy = {k:0 for k in days}\n    \n    # Looping over each family; d is the day for each family f\n    for f, d in enumerate(prediction):\n\n        # Using our lookup dictionaries to make simpler variable names\n        n = family_size_dict[f]\n        choice_0 = choice_dict['choice_0'][f]\n        choice_1 = choice_dict['choice_1'][f]\n        choice_2 = choice_dict['choice_2'][f]\n        choice_3 = choice_dict['choice_3'][f]\n        choice_4 = choice_dict['choice_4'][f]\n        choice_5 = choice_dict['choice_5'][f]\n        choice_6 = choice_dict['choice_6'][f]\n        choice_7 = choice_dict['choice_7'][f]\n        choice_8 = choice_dict['choice_8'][f]\n        choice_9 = choice_dict['choice_9'][f]\n\n        # add the family member count to the daily occupancy\n        daily_occupancy[d] += n\n\n        # Calculate the penalty for not getting top preference\n        if d == choice_0:\n            penalty += 0\n        elif d == choice_1:\n            penalty += 50\n        elif d == choice_2:\n            penalty += 50 + 9 * n\n        elif d == choice_3:\n            penalty += 100 + 9 * n\n        elif d == choice_4:\n            penalty += 200 + 9 * n\n        elif d == choice_5:\n            penalty += 200 + 18 * n\n        elif d == choice_6:\n            penalty += 300 + 18 * n\n        elif d == choice_7:\n            penalty += 300 + 36 * n\n        elif d == choice_8:\n            penalty += 400 + 36 * n\n        elif d == choice_9:\n            penalty += 500 + 36 * n + 199 * n\n        else:\n            penalty += 500 + 36 * n + 398 * n\n\n    # for each date, check total occupancy\n    #  (using soft constraints instead of hard constraints)\n    for _, v in daily_occupancy.items():\n        if (v > MAX_OCCUPANCY) or (v < MIN_OCCUPANCY):\n            penalty += 100000000\n\n    # Calculate the accounting cost\n    # The first day (day 100) is treated special\n    accounting_cost = (daily_occupancy[days[0]]-125.0) \/ 400.0 * daily_occupancy[days[0]]**(0.5)\n    # using the max function because the soft constraints might allow occupancy to dip below 125\n    accounting_cost = max(0, accounting_cost)\n    \n    # Loop over the rest of the days, keeping track of previous count\n    yesterday_count = daily_occupancy[days[0]]\n    acc_cost = []\n    for day in days[1:]:\n        today_count = daily_occupancy[day]\n        diff = abs(today_count - yesterday_count)\n        accounting_cost += max(0, (daily_occupancy[day]-125.0) \/ 400.0 * daily_occupancy[day]**(0.5 + diff \/ 50.0))\n        yesterday_count = today_count\n    penalty += accounting_cost\n    return penalty\n","123294e5":"old_val = old_cost_function(submission['assigned_day'].tolist())","0f785166":"%timeit old_cost_function(submission['assigned_day'].tolist())","d3b1a532":"prediction = submission['assigned_day'].values\ndesired = data.values[:, :-1]\nfamily_size = data.n_people.values\npenalties = np.asarray([\n    [\n        0,\n        50,\n        50 + 9 * n,\n        100 + 9 * n,\n        200 + 9 * n,\n        200 + 18 * n,\n        300 + 18 * n,\n        300 + 36 * n,\n        400 + 36 * n,\n        500 + 36 * n + 199 * n,\n        500 + 36 * n + 398 * n\n    ] for n in range(family_size.max() + 1)\n])","32d8b0bb":"@njit()\ndef jited_cost(prediction, desired, family_size, penalties):\n    N_DAYS = 100\n    MAX_OCCUPANCY = 300\n    MIN_OCCUPANCY = 125\n    penalty = 0\n    daily_occupancy = np.zeros(N_DAYS + 1, dtype=np.int64)\n    for i in range(len(prediction)):\n        n = family_size[i]\n        pred = prediction[i]\n        n_choice = 0\n        for j in range(len(desired[i])):\n            if desired[i, j] == pred:\n                break\n            else:\n                n_choice += 1\n        \n        daily_occupancy[pred - 1] += n\n        penalty += penalties[n, n_choice]\n\n    accounting_cost = 0\n    n_out_of_range = 0\n    daily_occupancy[-1] = daily_occupancy[-2]\n    for day in range(N_DAYS):\n        n_next = daily_occupancy[day + 1]\n        n = daily_occupancy[day]\n        n_out_of_range += (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        diff = abs(n - n_next)\n        accounting_cost += max(0, (n-125.0) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n\n    penalty += accounting_cost\n    return np.asarray([penalty, n_out_of_range])","ee52f6e0":"@njit()\ndef preference_cost(n, c):\n    return 450-100*(c<9)-100*(c<8)-100*(c<6)-100*(c<4)-50*(c<3)+50*(c>0) + \\\n           (36-(c<7)*18-(c<5)*9-(c<2)*9+199*(c>8)+199*(c>9))*n\n\n@njit()\ndef jited_cost_pinto(prediction, desired, family_size):\n    N_DAYS = 100\n    MAX_OCCUPANCY = 300\n    MIN_OCCUPANCY = 125\n    penalty = 0\n    daily_occupancy = np.zeros(N_DAYS + 1, dtype=np.int64)\n    for i in range(len(prediction)):\n        n = family_size[i]\n        pred = prediction[i]\n        n_choice = 0\n        for j in range(len(desired[i])):\n            if desired[i, j] == pred:\n                break\n            else:\n                n_choice += 1\n        \n        daily_occupancy[pred - 1] += n\n        penalty += preference_cost(n, n_choice)\n\n    accounting_cost = 0\n    n_out_of_range = 0\n    daily_occupancy[-1] = daily_occupancy[-2]\n    for day in range(N_DAYS):\n        n_next = daily_occupancy[day + 1]\n        n = daily_occupancy[day]\n        n_out_of_range += (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        diff = abs(n - n_next)\n        accounting_cost += max(0, (n-125.0) \/ 400.0 * n**(0.5 + diff \/ 50.0))\n\n    penalty += accounting_cost\n    return np.asarray([penalty, n_out_of_range])","98394299":"new_val, errors = jited_cost(prediction, desired, family_size, penalties)\nnew_val2, errors2 = jited_cost_pinto(prediction, desired, family_size)","b47df67d":"new_val, old_val, new_val2, new_val == old_val, errors, new_val2 == old_val, errors2","3b44d94c":"%timeit jited_cost(prediction, desired, family_size, penalties)","613f7125":"%timeit jited_cost_pinto(prediction, desired, family_size)","19f6ad98":"## Old Cost Function","58937c21":"## New Cost Function\n\nWe need to use arrays instead of dicts in order to take advantage of no-python JIT compilation. Also, it returns the number of error days (out of bounds), so it is up to the caller to handle. ","dc3721f8":"## Results\n\nThe compiled function is about 250 times faster (circa 15 ms vs 60 \u00b5s), while giving the same result as the original. ","51a4cb02":"## Compared with Pinto's version\n\nComparing with updated code from https:\/\/www.kaggle.com\/paulorzp\/cost-matrix-low-memory-and-fast","3c78321d":"Based on the Original Kernel: https:\/\/www.kaggle.com\/inversion\/santa-s-2019-starter-notebook"}}