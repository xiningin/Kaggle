{"cell_type":{"448c1ccf":"code","36c302ca":"code","b59862e5":"code","e3e411c1":"code","ae1f49d2":"code","2958d991":"code","d074fc37":"code","7294cfb0":"code","bcbe703d":"code","2a2e590f":"code","d06472f3":"code","3d8a5ec7":"code","b8739696":"markdown","db057624":"markdown","a8b409fe":"markdown","a06788d6":"markdown","4cd02b25":"markdown","1ebd591f":"markdown","e9c0cd77":"markdown"},"source":{"448c1ccf":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","36c302ca":"#imports\nimport keras\nfrom keras.preprocessing import image\nfrom keras.engine import Layer\nfrom keras.layers import Conv2D, Conv3D, UpSampling2D, InputLayer, Conv2DTranspose, Input, Reshape, merge, concatenate\nfrom keras.layers import Activation, Dense, Dropout, Flatten\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.callbacks import TensorBoard\nfrom keras.models import Sequential, Model\nfrom keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img\nfrom skimage.color import rgb2lab, lab2rgb, rgb2gray, gray2rgb\nfrom skimage.transform import resize\nfrom skimage.io import imsave\nfrom time import time\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\nimport cv2\nimport random\nimport tensorflow as tf\nfrom PIL import Image, ImageFile\nfrom zipfile import ZipFile\nfrom io import BytesIO,StringIO\nimport base64","b59862e5":"proto = '\/kaggle\/input\/monochrome-image-dataset\/colorization_deploy_v2.prototxt.txt'\nweights = '\/kaggle\/input\/monochrome-image-dataset\/colorization_release_v2_norebal.caffemodel'\n\n# load cluster centers\npts_in_hull = np.load('\/kaggle\/input\/monochrome-image-dataset\/pts_in_hull.npy')\npts_in_hull = pts_in_hull.transpose().reshape(2, 313, 1, 1).astype(np.float32)","e3e411c1":"# load model\nnet = cv2.dnn.readNetFromCaffe(proto, weights)\nnet.getLayerNames()","ae1f49d2":"# populate cluster centers as 1x1 convolution kernel\nnet.getLayer(net.getLayerId('class8_ab')).blobs = [pts_in_hull]\n# scale layer doesn't work in OpenCV dnn module, we need to fill 2.606 to conv8_313_rh layer manually\nnet.getLayer(net.getLayerId('conv8_313_rh')).blobs = [np.full((1, 313), 2.606, np.float32)]","2958d991":"def get_images(path):\n    a = []\n    b = []\n    c = []\n    for file in os.listdir(path):\n        img = cv2.imread(os.path.join(path,file),cv2.IMREAD_GRAYSCALE)\n        print(type(img))\n        if(img is None):\n            b.append(img)\n        else:\n            img_input = img.copy()\n            img = cv2.resize(img,(600,600))\n\n            # convert BGR to RGB\n            img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)\n            img_rgb = img.copy()\n            img_rgb = (img_rgb \/ 255.).astype(np.float32)\n\n            # convert RGB to LAB\n            img_lab = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2Lab)\n            # only L channel to be used\n            img_L = img_lab[:,:,0]\n\n            input_img = cv2.resize(img_L, (224, 224))\n            input_img -= 50 # subtract 50 for mean-centering\n            c.append(img_L)\n            a.append(input_img)\n                   \n    return a,c\n\n\ndef predict(a,c):\n    p = []\n    for i in range(len(a)):\n        net.setInput(cv2.dnn.blobFromImage(a[i]))\n        pred = net.forward()[0,:,:,:].transpose((1, 2, 0))\n\n        # resize to original image shape\n        pred_resize = cv2.resize(pred, (600, 600))\n        img_L = c[i]\n\n        # concatenate with original image L\n        pred_lab = np.concatenate([img_L[:, :, np.newaxis], pred_resize], axis=2)\n\n        # convert LAB to RGB\n        pred_rgb = cv2.cvtColor(pred_lab, cv2.COLOR_Lab2RGB)\n        pred_rgb = np.clip(pred_rgb, 0, 1) * 255\n        pred_rgb = pred_rgb.astype(np.uint8)\n        p.append(pred_rgb)\n    \n    return p","d074fc37":"path = '\/kaggle\/input\/monochrome-image-dataset\/'\nX,y = get_images(path)","7294cfb0":"plt.figure(figsize=(10,10))\nfor i in range(len(X)):\n    plt.subplot(3,7,i+1)\n    plt.imshow(X[i],cmap='gray')\n    plt.axis('off')\nplt.tight_layout()\nplt.show()","bcbe703d":"P = predict(X,y)","2a2e590f":"plt.figure(figsize=(10,10))\nfor i in range(len(P)):\n    plt.subplot(3,7,i+1)\n    plt.imshow(P[i])\n    plt.axis('off')\nplt.tight_layout()\nplt.show()","d06472f3":"# save result image file\nfor i in range(len(P)):\n    img = Image.fromarray(P[i], 'RGB')\n    img.save('output'+str(i)+'.png')","3d8a5ec7":"!zip -m images.zip output*.png","b8739696":"looking at some of the predicted images.","db057624":"# Utility Functions","a8b409fe":"Works just fine :)\n\n\n\nThis application could prove to be quite useful in the film and photography industry.","a06788d6":"This notebook uses Richard Zhang's pre-trained model for image colourization. Necessary files are loaded from the dataset.","4cd02b25":"# INTRODUCTION","1ebd591f":"# Predictions","e9c0cd77":"lets look at some processes images."}}