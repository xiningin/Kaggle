{"cell_type":{"49a31b34":"code","a30ce02b":"code","4155c48d":"code","ab532fba":"code","bac2e0d8":"code","7bc3cf7d":"code","a59a3c96":"code","3c00431d":"code","a3429db4":"code","7d1f4b7e":"code","5bf12d6f":"code","aee7dd10":"code","a7771db9":"code","2d02729a":"markdown","7d5d6793":"markdown","a84fa246":"markdown","d0ab0317":"markdown","7f77d15a":"markdown","7f3325be":"markdown","4fba3724":"markdown","48ee7c77":"markdown","19130069":"markdown"},"source":{"49a31b34":"from sklearn import neighbors\nimport pandas as pd\nimport numpy as np\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import train_test_split","a30ce02b":"\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))","4155c48d":"#Dataset\ndata = pd.read_csv('..\/input\/train_data.csv')\n#X= np.array([['AAAAAAA'],['AAATTAA'], ['TTTTTTT'],['TTTAAAA'],['TTTTAAA'],['TATATAT']]) \n## class 0 if #A>#T, class 1 if #A<#T\n#y= [0,0,1,0,1,1]\ndata.head()","ab532fba":"# Example of string kernel\n# compare poisition-wise 2 sequences(X & Y) and return similarity score.\ndef equal_elements(s1,s2):\n    score = 0\n    for i in range(len(s1)):\n        score += (s1[i] == s2[i])*1 # This is an unoptimized way to do this. \n    return score\n\nequal_elements(\"STRING\",\"KERNEL\")","bac2e0d8":"clf = SVC(kernel=equal_elements)\nclf.fit(data['DNA_sequence'],data['RPOD']) # this producecs an error","7bc3cf7d":"data.iloc[1,0]","a59a3c96":"# We use only a small fraction of the data for demonstration purposes,\n# be aware that the equal_elements function is unoptimized and will \n# take some time if executed on the whole dataset\n\nsize = 12\nnot_so_good_string_kernel = np.zeros((size, size))\nfor row in range(size):\n    for column in range(size):\n        not_so_good_string_kernel[row,column] = equal_elements(data.iloc[row, 0],data.iloc[column, 0])\nnot_so_good_string_kernel","3c00431d":"def compose_kernel(row_idxs, col_idxs):\n    row_idxs = np.array(row_idxs).astype(np.int)\n    col_idxs = np.array(col_idxs).astype(np.int)\n    select_kernel = np.zeros((len(row_idxs),len(col_idxs)))\n    for i, row_idx in enumerate(row_idxs):\n        for j, col_idx in enumerate(col_idxs):\n            select_kernel[i,j] = not_so_good_string_kernel[row_idx,col_idx]  # Change to custom distance kernel\n    \n    return select_kernel\n\ncompose_kernel([5,2,3,1],[5,2,3,1]) # random example","a3429db4":"y = data['RPOD'].values\nX_train_idx, X_test_idx, y_train, y_test = train_test_split(np.arange(size),y[:size], test_size=4) # OR USE KFoldStratified()\nX_train_idx, X_test_idx, y_train, y_test","7d1f4b7e":"# KERNEL used for training\ncompose_kernel(X_train_idx, X_train_idx) # Distances between the training sequences","5bf12d6f":"# KERNEL used for predictions\ncompose_kernel(X_train_idx, X_test_idx) # Distances between the training sequences and the testing sequences","aee7dd10":"clf= SVC(kernel=compose_kernel)\nclf.fit(X_train_idx.reshape(-1,1), y_train) # reshape X_train_idx to be 2D","a7771db9":"pred = clf.predict(X_test_idx.reshape(-1,1))\nprint(pred, y_test)","2d02729a":"\n In sklearn, a problem exists where the inputs of the custom function given the support vector machine class object has to be of the type integer\/float:","7d5d6793":"For training, distances between training samples and their corresponding  are used to fit a support vector machine","a84fa246":"\nInput data files are available in the \"..\/input\/\" directory.\n\nFor example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n","d0ab0317":"## Step 2","7f77d15a":"When using support vector machines, a list of default kernel functions is available (e.g. rbf,...). These functions use the kernel trick to compute the distance between different points in a higher dimensional space. With these distances, a support vector machine can be calculated to best differentiate the classes.\nWhen using string kernels, no kernel trick is used as the idea is to measure a distance between two strings using a custom function. This function determines the similarity of two strings (given a criteria) and are at the basis of how well the support vector machine will work.","7f3325be":"As a workaround, we use the following procedure:\n    1. create precomputed distance kernel\n    2. use function which obtains a distance given the index of the string kernel\n    3. obtain indices of training and testing set\n    \n This is actually more advantaguous because some functions that calculate the string kernels require a lot of processing power. By precomputing these distances they only have to be computed once as the resulting string kernel can be saved locally.\n ","4fba3724":"## Step 1","48ee7c77":"> ## Step 3","19130069":"Due to some restrictions in sklearn, the use of string kernels is not as straightforward as it should be. Luckily, I have written some code explaining the problem and a workaround. This code can easily be plugged into your custom notebooks.\n\nThe use of string kernels is a very common approach when creating models involving omics data. For this dataset it is recommended to consider the use of these when using support vector machines. The string kernel used in the notebook is a very simple (read: bad) example. Various amounts of string kernels have been created specifically for DNA interactions, which can be recovered from literature. The implementation of some more advanced kernels might be challenging, and might not necessarily result in good performances. Therefore I remind everybody that a good reasoning behind chosing different approaches (even when you find out they didn't work well) is more important than the actual performances. "}}