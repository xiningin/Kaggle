{"cell_type":{"b493d623":"code","e3a9bd4c":"code","b4706ff5":"code","eea90b28":"code","b6a329cb":"code","8664abf6":"code","01a327f9":"code","60e7f5f3":"code","20267c87":"code","14f6626b":"code","3d504103":"code","e1cbcba8":"code","51582e93":"code","a3965bb9":"code","20e3d6b7":"code","d6f9acb1":"code","ca0ab50e":"code","71cac3a2":"code","ea0cb5d3":"markdown","e3893fa8":"markdown","df86aa23":"markdown","39063684":"markdown","5756d45f":"markdown"},"source":{"b493d623":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef data_preprocessing(data_name,pre_days):\n    \n    data = pd.read_csv(\"..\/input\/d\/pentiumlin\/taiwan-and-usa-stocks-data\/stock2\/\"+ data_name +\".csv\")\n    print(data.head())\n\n    plt.figure(figsize=(12,4))\n    plt.title('Close Price History')\n    plt.plot(data['Close'])\n    plt.xlabel('Date', fontsize=18)\n    plt.ylabel('Close Price', fontsize=18)\n    plt.show()\n     \n    # Create a new dataframe with only the 'Close column \n    data = data.filter(['Close'])\n    # Convert the dataframe to a numpy array\n    dataset = data.values\n    # Get the number of rows to train the model on\n    training_data_len = int(len(dataset)*.7)\n    validation_data_len = int(len(dataset)*0.2)\n    testing_data_len = len(dataset) - training_data_len - validation_data_len\n    print(\"The number of trainning dataset: \", training_data_len)\n    print(\"The number of validation dataset: \", validation_data_len)\n    print(\"The number of testing dataset: \", testing_data_len)\n    \n    # Create the training data set \n    # Create the scaled training data set\n    train_data = dataset[0:training_data_len, :]\n    # Split the data into x_train and y_train data sets\n    x_train = []\n    y_train = []\n\n    for i in range(pre_days, len(train_data)):\n        x_train.append(train_data[i-pre_days:i, 0])\n        y_train.append(train_data[i, 0])\n\n\n    # Convert the x_train and y_train to numpy arrays \n    x_train, y_train = np.array(x_train), np.array(y_train)\n\n    # Scale the data\n    from sklearn.preprocessing import MinMaxScaler\n\n    scaler_x = MinMaxScaler(feature_range=(0,1))\n    input_sc = scaler_x.fit(x_train)\n    x_train_norm = input_sc.transform(x_train)\n\n    y_train = np.reshape(y_train,(y_train.shape[0], 1))\n    scaler_y = MinMaxScaler(feature_range=(0,1))\n    output_sc = scaler_y.fit(y_train)\n    y_train_norm = output_sc.transform(y_train)\n\n    # Reshape the data\n    x_train_norm = np.reshape(x_train_norm, (x_train_norm.shape[0], x_train_norm.shape[1], 1))\n    print(\"The shape of input data: \", x_train_norm.shape)\n\n    # Create the validation data set \n    # Create the scaled validation data set\n    val_data = dataset[training_data_len - pre_days: training_data_len + validation_data_len, :]\n    # Split the data into x_val and y_val data sets\n    x_val = []\n    y_val = []\n\n    for i in range(pre_days, len(val_data)):\n        x_val.append(val_data[i-pre_days:i, 0])\n        y_val.append(val_data[i, 0])\n\n    # Convert the x_train and y_train to numpy arrays \n    x_val, y_val = np.array(x_val), np.array(y_val)\n\n    x_val_norm = input_sc.transform(x_val)\n    y_val = np.reshape(y_val, (y_val.shape[0], 1))\n    y_val_norm = output_sc.transform(y_val)\n\n    # Reshape the data\n    x_val_norm = np.reshape(x_val_norm, (x_val_norm.shape[0], x_val_norm.shape[1], 1))\n    print(\"The shape of validation data: \", x_val_norm.shape)\n\n    # Create the testing data set \n    # Create the scaled testing data set\n    test_data = dataset[training_data_len + validation_data_len - pre_days:, :]\n    # Split the data into x_test and y_test data sets\n    x_test = []\n    y_test = []\n\n    for i in range(pre_days, len(test_data)):\n        x_test.append(test_data[i-pre_days:i, 0])\n        y_test.append(test_data[i, 0])\n\n    # Convert the x_train and y_train to numpy arrays \n    x_test, y_test = np.array(x_test), np.array(y_test)\n\n    x_test_norm = input_sc.transform(x_test)\n    y_test = np.reshape(y_test, (y_test.shape[0],1))\n    y_test_norm = output_sc.transform(y_test)\n\n    # Reshape the data\n    x_test_norm = np.reshape(x_test_norm, (x_test_norm.shape[0], x_test_norm.shape[1], 1))\n    print(\"The shape of testing data: \", x_test_norm.shape)\n    \n    return (data,x_train,y_train,y_test,y_val,x_train_norm, y_train_norm,x_test_norm,y_test_norm,\n            x_val_norm, y_val_norm,output_sc,training_data_len, validation_data_len )","e3a9bd4c":"(data,x_train,y_train,y_test,y_val,\n x_train_norm, y_train_norm,x_test_norm,\n y_test_norm,x_val_norm, y_val_norm,output_sc,\n training_data_len, validation_data_len ) = data_preprocessing(\"0050\",60)","b4706ff5":"from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Activation\nfrom tensorflow.keras import optimizers\n\n# Build the LSTM model\nmodel = Sequential()\nmodel.add(LSTM(128, return_sequences=True, input_shape= (x_train.shape[1], 1), activation = 'relu'))\nmodel.add(LSTM(64, return_sequences=False))\nmodel.add(Dense(100))\nmodel.add(Dense(1))\n\nmodel.summary()\nprint(\"\\n\")\n# Compile the model\nopt = optimizers.Adam(learning_rate = 1e-3\n                     )\nmodel.compile(optimizer = opt, loss = 'mean_squared_error')\n\n# Train the model\nmodel.fit(x_train_norm, y_train_norm, batch_size = 16, epochs = 20, validation_data = (x_val_norm, y_val_norm))","eea90b28":"def error_of_predicton():\n\n    # Get the models predicted price values \n    predictions_train = model.predict(x_train_norm)\n    predictions_train = output_sc.inverse_transform(predictions_train)\n\n    # Get the root mean squared error (RMSE)\n    rmse = np.sqrt(np.mean(((predictions_train - y_train) ** 2)))\n    print(\"root mean squred error of trainning data: \", rmse)\n\n    predictions_val = model.predict(x_val_norm)\n    predictions_val = output_sc.inverse_transform(predictions_val)\n\n    # Get the root mean squared error (RMSE)\n    rmse = np.sqrt(np.mean(((predictions_val - y_val) ** 2)))\n    print(\"root mean squred error of validation data: \", rmse)\n\n    predictions_test = model.predict(x_test_norm)\n    predictions_test = output_sc.inverse_transform(predictions_test)\n\n    # Get the root mean squared error (RMSE)\n    rmse = np.sqrt(np.mean(((predictions_test - y_test) ** 2)))\n    print(\"root mean squred error of testing data: \", rmse)\n    \n    return predictions_val,predictions_test","b6a329cb":"predictions_val,predictions_test = error_of_predicton()","8664abf6":"# Plot the data\ntrain = data[:training_data_len]\nvalid = data[training_data_len: training_data_len+validation_data_len]\ntest = data[training_data_len+validation_data_len:]\nvalid['Predictions'] = predictions_val\ntest['Predictions'] = predictions_test\n\n# Visualize the data\nplt.figure(figsize=(12,6))\nplt.subplot(2,1,1)\nplt.title('Close Price ML Predicton of Taiwan Top 50')\nplt.xlabel('Date', fontsize=18)\nplt.ylabel('Close Price(TWD)', fontsize=18)\nplt.plot(train['Close'])\nplt.plot(valid['Close' ])\nplt.plot(test['Close'])\nplt.plot(valid['Predictions'],color=\"g\")\nplt.plot(test['Predictions'],color=\"c\")\nplt.legend(['Train', 'Val', 'Test', 'Val_prediction', 'Test_prediction'], loc='upper left')\nplt.savefig(\"0050_1.png\")\n\nplt.figure(figsize=(12,6))\nplt.subplot(2,1,2)\nplt.title('Close Price ML Predicton of Taiwan Top 50')\nplt.xlabel('Date', fontsize=18)\nplt.ylabel('Close Price(TWD)', fontsize=18)\nplt.plot(train['Close'])\nplt.plot(valid[['Predictions']],color=\"g\")\nplt.plot(test[['Predictions']],color=\"c\")\nplt.legend([ 'Train', 'Val_prediction', 'Test_prediction'], loc='upper left')\nplt.savefig(\"0050_2.png\")\nplt.show()\n","01a327f9":"(data,x_train,y_train,y_test,y_val,x_train_norm, y_train_norm,x_test_norm,y_test_norm,\nx_val_norm, y_val_norm,output_sc,training_data_len, validation_data_len ) = data_preprocessing(\"SPY\",60)","60e7f5f3":"from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Activation,Dropout\n\n# Build the LSTM model\nmodel = Sequential()\nmodel.add(LSTM(128, return_sequences=True, input_shape= (x_train.shape[1], 1), activation = 'relu'))\nmodel.add(LSTM(64, return_sequences=False))\nmodel.add(Dense(150))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(1))\nmodel.summary()\nprint(\"\\n\")\n\n# Compile the model\nmodel.compile(optimizer='adam', loss='mean_squared_error')\n\n# Train the model\nmodel.fit(x_train_norm, y_train_norm, batch_size = 16, epochs = 20, validation_data = (x_val_norm, y_val_norm))","20267c87":"predictions_val,predictions_test = error_of_predicton()","14f6626b":"# Plot the data\ntrain = data[:training_data_len]\nvalid = data[training_data_len: training_data_len+validation_data_len]\ntest = data[training_data_len+validation_data_len:]\nvalid['Predictions'] = predictions_val\ntest['Predictions'] = predictions_test\n\n# Visualize the data\nplt.figure(figsize=(12,6))\nplt.subplot(2,1,1)\nplt.title('Close Price ML Predicton of SPY')\nplt.xlabel('Date', fontsize=18)\nplt.ylabel('Close Price(USD)', fontsize=18)\nplt.plot(train['Close'])\nplt.plot(valid['Close' ])\nplt.plot(test['Close'])\nplt.plot(valid['Predictions'],color=\"g\")\nplt.plot(test['Predictions'],color=\"c\")\nplt.legend(['Train', 'Val', 'Test', 'Val_prediction', 'Test_prediction'], loc='upper left')\nplt.savefig(\"SPY_1.png\")\n\nplt.figure(figsize=(12,6))\nplt.subplot(2,1,2)\nplt.title('Close Price ML Predicton of SPY')\nplt.xlabel('Date', fontsize=18)\nplt.ylabel('Close Price(USD)', fontsize=18)\nplt.plot(train['Close'])\nplt.plot(valid[['Predictions']],color=\"g\")\nplt.plot(test[['Predictions']],color=\"c\")\nplt.legend([ 'Train', 'Val_prediction', 'Test_prediction'], loc='upper left')\nplt.savefig(\"SPY_2.png\")\nplt.show()","3d504103":"(data,x_train,y_train,y_test,y_val,x_train_norm, y_train_norm,x_test_norm,y_test_norm,\nx_val_norm, y_val_norm,output_sc,training_data_len, validation_data_len ) = data_preprocessing(\"TSMC\",60)","e1cbcba8":"from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Activation\n\n# Build the LSTM model\nmodel = Sequential()\nmodel.add(LSTM(128, return_sequences=True, input_shape= (x_train.shape[1], 1), activation = 'relu'))\nmodel.add(LSTM(64, return_sequences=False))\nmodel.add(Dense(100))\nmodel.add(Dense(1))\nmodel.summary()\nprint(\"\\n\")\n\n# Compile the model\nmodel.compile(optimizer='adam', loss='mean_squared_error')\n\n# Train the model\nmodel.fit(x_train_norm, y_train_norm, batch_size = 16, epochs = 20, validation_data = (x_val_norm, y_val_norm))","51582e93":"predictions_val,predictions_test = error_of_predicton()","a3965bb9":"# Plot the data\ntrain = data[:training_data_len]\nvalid = data[training_data_len: training_data_len+validation_data_len]\ntest = data[training_data_len+validation_data_len:]\nvalid['Predictions'] = predictions_val\ntest['Predictions'] = predictions_test\n\n# Visualize the data\nplt.figure(figsize=(12,6))\nplt.subplot(2,1,1)\nplt.title('Close Price ML Predicton of TSMC')\nplt.xlabel('Date', fontsize=18)\nplt.ylabel('Close Price(TWD)', fontsize=18)\nplt.plot(train['Close'])\nplt.plot(valid['Close' ])\nplt.plot(test['Close'])\nplt.plot(valid['Predictions'],color=\"g\")\nplt.plot(test['Predictions'],color=\"c\")\nplt.legend(['Train', 'Val', 'Test', 'Val_prediction', 'Test_prediction'], loc='upper left')\nplt.savefig(\"TSMC_1.png\")\n\nplt.figure(figsize=(12,6))\nplt.subplot(2,1,2)\nplt.title('Close Price ML Predicton of TSMC')\nplt.xlabel('Date', fontsize=18)\nplt.ylabel('Close Price(TWD)', fontsize=18)\nplt.plot(train['Close'])\nplt.plot(valid[['Predictions']],color=\"g\")\nplt.plot(test[['Predictions']],color=\"c\")\nplt.legend([ 'Train', 'Val_prediction', 'Test_prediction'], loc='upper left')\nplt.savefig(\"TSMC_2.png\")\nplt.show()","20e3d6b7":"(data,x_train,y_train,y_test,y_val,x_train_norm, y_train_norm,x_test_norm,y_test_norm,\nx_val_norm, y_val_norm,output_sc,training_data_len, validation_data_len ) = data_preprocessing(\"INTC\",60)","d6f9acb1":"from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Activation\n\n# Build the LSTM model\nmodel = Sequential()\nmodel.add(LSTM(128, return_sequences=True, input_shape= (x_train.shape[1], 1), activation = 'relu'))\nmodel.add(LSTM(64, return_sequences=False))\nmodel.add(Dense(100))\nmodel.add(Dense(1))\nmodel.summary()\nprint(\"\\n\")\n\n# Compile the model\nmodel.compile(optimizer='adam', loss='mean_squared_error')\n\n# Train the model\nmodel.fit(x_train_norm, y_train_norm, batch_size = 16, epochs = 20, validation_data = (x_val_norm, y_val_norm))","ca0ab50e":"predictions_val,predictions_test = error_of_predicton()","71cac3a2":"# Plot the data\ntrain = data[:training_data_len]\nvalid = data[training_data_len: training_data_len+validation_data_len]\ntest = data[training_data_len+validation_data_len:]\nvalid['Predictions'] = predictions_val\ntest['Predictions'] = predictions_test\n\n# Visualize the data\nplt.figure(figsize=(12,6))\nplt.subplot(2,1,1)\nplt.title('Close Price ML Predicton of INTC')\nplt.xlabel('Date', fontsize=18)\nplt.ylabel('Close Price(USD)', fontsize=18)\nplt.plot(train['Close'])\nplt.plot(valid['Close' ])\nplt.plot(test['Close'])\nplt.plot(valid['Predictions'],color=\"g\")\nplt.plot(test['Predictions'],color=\"c\")\nplt.legend(['Train', 'Val', 'Test', 'Val_prediction', 'Test_prediction'], loc='upper left')\nplt.savefig(\"Intel_1.png\")\n\nplt.figure(figsize=(12,6))\nplt.subplot(2,1,2)\nplt.title('Close Price ML Predicton of INTC')\nplt.xlabel('Date', fontsize=18)\nplt.ylabel('Close Price(USD)', fontsize=18)\nplt.plot(train['Close'])\nplt.plot(valid[['Predictions']],color=\"g\")\nplt.plot(test[['Predictions']],color=\"c\")\nplt.legend([ 'Train', 'Val_prediction', 'Test_prediction'], loc='upper left')\nplt.savefig(\"Intel_2.png\")\nplt.show()","ea0cb5d3":"## TSMC","e3893fa8":"## Data Preprocessing","df86aa23":"## SPY","39063684":"## Intel","5756d45f":"## Taiwan Top 50(0050)"}}