{"cell_type":{"16ccf930":"code","6844770b":"code","db2f826b":"code","5d9b52be":"code","c73f47e8":"code","dbb793d4":"code","b76c5818":"code","8612aa7d":"code","65c93a13":"code","d558109e":"code","4c713720":"code","310879f9":"code","7dc224f5":"code","f6690533":"code","07db0c41":"code","e13a0d69":"code","4c7a3a31":"code","4a1b2537":"code","44be5ab4":"code","f0ca2f9f":"markdown"},"source":{"16ccf930":"from collections import defaultdict\nimport functools\nimport itertools\nimport math\nfrom ortools.constraint_solver import pywrapcp\nfrom ortools.constraint_solver import routing_enums_pb2\nimport pandas as pd","6844770b":"N_STRINGS = 3\nLETTERS = [\n    '\ud83c\udf85',  # father christmas\n    '\ud83e\udd36',  # mother christmas\n    '\ud83e\udd8c',  # reindeer\n    '\ud83e\udddd',  # elf\n    '\ud83c\udf84',  # christmas tree\n    '\ud83c\udf81',  # gift\n    '\ud83c\udf80',  # ribbon\n]\nN = len(LETTERS)\nDEPOT = '0'  # a starting dummy node\nINF = 999  # number to represent \"infinite distance\", could try sys.maxsize for hard constraint\n\n# Configure stopping conditions for the search\nN_MINUTES = 60","db2f826b":"def make_nodes():\n    perms = list(itertools.permutations(LETTERS, N))\n    all_ = perms[:math.factorial(N-2)]  # permutations beginning with \ud83c\udf85\ud83e\udd36\n    some = perms[math.factorial(N-2):]  # everything else\n    \n    return [DEPOT] + (all_ * N_STRINGS) + some","5d9b52be":"def create_data_model():\n    data = {}\n    data['locations'] = make_nodes()\n    data['num_vehicles'] = N_STRINGS\n    data['depot'] = 0\n    \n    return data","c73f47e8":"data = create_data_model()","dbb793d4":"manager = pywrapcp.RoutingIndexManager(\n    len(data['locations']),\n    data['num_vehicles'],\n    data['depot'],\n)\n\nrouting = pywrapcp.RoutingModel(manager)","b76c5818":"def distance(p, q):\n    if p == DEPOT or q == DEPOT: return 0\n    for n in range(N+1):  # never choose maximum distance nodes (the N+1 case)\n        if p[n:] == q[:N-n]:\n            return n\n    return INF  # max distance N becomes distance infinity","8612aa7d":"def distance_callback(from_index, to_index):\n    # Convert from the internal representation to an actual permutation\n    from_node = manager.IndexToNode(from_index)\n    from_perm = data['locations'][from_node]\n    to_node = manager.IndexToNode(to_index)\n    to_perm = data['locations'][to_node]\n    \n    return distance(from_perm, to_perm)","65c93a13":"transit_callback_index = routing.RegisterTransitCallback(distance_callback)\nrouting.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)","d558109e":"dimension_name = 'Length'\nrouting.AddDimension(\n    transit_callback_index,\n    0,  # slack is additional fixed cost at each node; not applicable here\n    10**16, # max length per route; set to some large-enough number\n    True,  # start with total length of 0\n    dimension_name)\nlength_dimension = routing.GetDimensionOrDie(dimension_name)\nlength_dimension.SetGlobalSpanCostCoefficient(100) # total cost += 100 * (max_length - min_length)\n\nn_all = math.factorial(N-2)\nfor vehicle in range(N_STRINGS):\n    for node in range(n_all):\n        routing.SetAllowedVehiclesForIndex(\n            [vehicle],\n            manager.NodeToIndex(1+vehicle*n_all+node),\n        )","4c713720":"search_parameters = pywrapcp.DefaultRoutingSearchParameters()\nsearch_parameters.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.LOCAL_CHEAPEST_ARC\nsearch_parameters.local_search_metaheuristic = routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\nsearch_parameters.time_limit.seconds = N_MINUTES * 60\nsearch_parameters.log_search = True","310879f9":"solution = routing.SolveWithParameters(search_parameters)","7dc224f5":"def get_routes(data, manager, routing, solution):\n    routes = defaultdict(list)\n    for vehicle_id in range(data['num_vehicles']):\n        index = routing.Start(vehicle_id)\n        while not routing.IsEnd(index):\n            idx_node = manager.IndexToNode(index)\n            if idx_node != data['depot']:\n                routes[vehicle_id].append(idx_node)\n            index = solution.Value(routing.NextVar(index))\n    \n    return routes","f6690533":"def route_to_schedule(route, nodes):\n    def overlap(a, b):\n        return max(i for i in range(len(b)+1) if a.endswith(b[:i]))\n\n    def squeeze(ws):\n        return functools.reduce(lambda a, b: a + b[overlap(a, b):], ws)\n\n    return squeeze([\"\".join(nodes[i]) for i in route])","07db0c41":"def get_schedules(routes):\n    words = [route_to_schedule(routes[vehicle_id], data['locations'])\n             for vehicle_id in range(data['num_vehicles'])]\n    \n    return words","e13a0d69":"routes = get_routes(data, manager, routing, solution)\nwords = get_schedules(routes)","4c7a3a31":"submission = pd.Series(words, name='schedule')\nsubmission","4a1b2537":"# Evaluating score\n\nmax(map(len, submission.to_list()))","44be5ab4":"submission.to_csv('submission.csv', index=False)","f0ca2f9f":"This is my first attempt to solve the problem.\n\nPreviously, I have done analysis of the problem in the [Problem Analysis](https:\/\/www.kaggle.com\/aniketsharma00411\/santa-2021-problem-analysis) notebook."}}