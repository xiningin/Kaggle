{"cell_type":{"63afb8af":"code","5f93c07b":"code","7682129b":"code","70190e27":"code","599252a0":"code","60d7569e":"code","cd4e840a":"code","ff7510fc":"code","e5ceafeb":"code","a596ae7d":"code","460c25ce":"code","f247f32d":"code","c5951f5d":"code","51a7a166":"code","d5dc8db0":"code","d855441d":"code","9888b967":"markdown","a2fb1386":"markdown","f02934ec":"markdown"},"source":{"63afb8af":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pymc3 as pm\n%matplotlib inline\nimport theano.tensor as T\nimport scipy.stats as stats","5f93c07b":"\"\"\"Code 2.2\"\"\"\n# p(observed_data | probability of our thumb landing on Water 6 times out of 9 tries)\nstats.binom.pmf(6, n=9, p=0.5)","7682129b":"\"\"\"Code 2.3\"\"\"\ndef posterior_grid_approx(grid_points=5, success=6, tosses=9):\n\n    # define grid\n    p_grid = np.linspace(0, 1, grid_points)\n\n    # define prior\n    prior = np.repeat(5, grid_points)  # uniform probability at all grid_points\n    #prior = (p_grid >= 0.5).astype(int)  # truncated\n    #prior = np.exp(- 5 * abs(p_grid - 0.5))  # double exp\n\n    # compute likelihood at each point in the grid\n    likelihood = stats.binom.pmf(success, tosses, p_grid)\n\n    # compute product of likelihood and prior\n    unstd_posterior = likelihood * prior\n\n    # standardize the posterior, so it sums to 1\n    posterior = unstd_posterior \/ unstd_posterior.sum()\n    return p_grid, posterior","70190e27":"points = 5\nw, n = 6, 9\np_grid, posterior = posterior_grid_approx(points, w, n)\nplt.plot(p_grid, posterior, 'o-', label='success = {}\\ntosses = {}'.format(w, n))\nplt.xlabel('probability of water', fontsize=14)\nplt.ylabel('posterior probability', fontsize=14)\nplt.title('{} points'.format(points))\nplt.legend(loc=0);","599252a0":"points = 20\nw, n = 6, 9\np_grid, posterior = posterior_grid_approx(points, w, n)\nplt.plot(p_grid, posterior, 'o-', label='success = {}\\ntosses = {}'.format(w, n))\nplt.xlabel('probability of water', fontsize=14)\nplt.ylabel('posterior probability', fontsize=14)\nplt.title('{} points'.format(points))\nplt.legend(loc=0);","60d7569e":"\"\"\"Code 2.5\"\"\"\ndef posterior_grid_approx(grid_points=5, success=6, tosses=9):\n    # define grid\n    p_grid = np.linspace(0, 1, grid_points)\n\n    # define prior\n    #prior = np.repeat(5, grid_points)  # uniform probability at all grid_points\n    prior = (p_grid >= 0.5).astype(int)  # truncated (0 if smaller than 0.5; else 1. Meaning prior is uniform only from 0.5-1)\n    #prior = np.exp(- 20 * abs(p_grid - 0.5))  # double exp\n\n    # compute likelihood at each point in the grid\n    likelihood = stats.binom.pmf(success, tosses, p_grid)\n\n    # compute product of likelihood and prior\n    unstd_posterior = likelihood * prior\n\n    # standardize the posterior, so it sums to 1\n    posterior = unstd_posterior \/ unstd_posterior.sum()\n    return p_grid, posterior","cd4e840a":"points = 20\nw, n = 6, 9\np_grid, posterior = posterior_grid_approx(points, w, n)\nplt.plot(p_grid, posterior, 'o-', label='success = {}\\ntosses = {}'.format(w, n))\nplt.xlabel('probability of water', fontsize=14)\nplt.ylabel('posterior probability', fontsize=14)\nplt.title('{} points'.format(points))\nplt.legend(loc=0);","ff7510fc":"\"\"\"Code 2.5\"\"\"\ndef posterior_grid_approx(grid_points=5, success=6, tosses=9):\n    # define grid\n    p_grid = np.linspace(0, 1, grid_points)\n\n    # define prior\n    #prior = np.repeat(5, grid_points)  # uniform probability at all grid_points\n    #prior = (p_grid >= 0.5).astype(int)  # truncated (0 if smaller than 0.5; else 1. Meaning prior is uniform only from 0.5-1)\n    prior = np.exp(- 20 * abs(p_grid - 0.5))  # double exp\n\n    # compute likelihood at each point in the grid\n    likelihood = stats.binom.pmf(success, tosses, p_grid)\n\n    # compute product of likelihood and prior\n    unstd_posterior = likelihood * prior\n\n    # standardize the posterior, so it sums to 1\n    posterior = unstd_posterior \/ unstd_posterior.sum()\n    return p_grid, posterior","e5ceafeb":"points = 20\nw, n = 6, 9\np_grid, posterior = posterior_grid_approx(points, w, n)\nplt.plot(p_grid, posterior, 'o-', label='success = {}\\ntosses = {}'.format(w, n))\nplt.xlabel('probability of water', fontsize=14)\nplt.ylabel('posterior probability', fontsize=14)\nplt.title('{} points'.format(points))\nplt.legend(loc=0);","a596ae7d":"\"\"\"Code 2.6\"\"\"\n# Computing the posterior using the quadratic approximation. It does two things: 1) finds the peak of\n# the posterior (mode), and 2) calculates the curvature near the peak to compute the approximation of the posterior distribution\ndata = np.repeat((0, 1), (3, 6))\nwith pm.Model() as normal_approximation:\n    p = pm.Uniform('p', 0, 1)\n    w = pm.Binomial('w', n=len(data), p=p, observed=data.sum())\n    mean_q = pm.find_MAP() #find peak of the posterior distribution (its mode), which always uses a GAUSSIAN\n    std_q = ((1\/pm.find_hessian(mean_q, vars=[p]))**0.5)[0]","460c25ce":"print(\"The mode of the posterior (MAP) is: (this is the mean of the Guassian used to calculate the NAP)\")\nprint(mean_q['p'])\nprint(\"\\nThe curvature at its peak is: (this is the std of the Guassian used to calculate the curvature)\")\nprint(std_q)","f247f32d":"norm = stats.norm(mean_q, std_q)\nprob = .89\nz = stats.norm.ppf([(1-prob)\/2, (1+prob)\/2])\npi = mean_q['p'] + std_q * z \n\nprint(\"The 89th percentile interval is:\")\npi","c5951f5d":"\"\"\"Code 2.7\"\"\"\n# analytical calculation (beta\/binomial conjugate)\nw, n = 6, 9\nx = np.linspace(0, 1, 100)\n\n# Here we're using beta posterior distribution to do the plot because the beta is the conjugate prior of the \n# binomial: beta(1,1) is the uniform prior for the binomial data, resulting in:  \nplt.plot(x, stats.beta.pdf(x , w+1, n-w+1),\n         label='True posterior')\n\n# quadratic approximation\nplt.plot(x, stats.norm.pdf(x, mean_q['p'], std_q),\n         label='Quadratic approximation')\nplt.legend(loc=0, fontsize=9)\n\nplt.title('n = {}'.format(n), fontsize=14)\nplt.xlabel('Proportion water', fontsize=14)\nplt.ylabel('Density', fontsize=14);","51a7a166":"\"\"\"Code 2.6 (my addition)\"\"\"\n#changed to n=180 (60 zeros or no water, and 120 ones or landing on water)\ndata = np.repeat((0, 1), (60, 120))\n\nwith pm.Model() as normal_approximation:\n    p = pm.Uniform('p', 0, 1)\n    w = pm.Binomial('w', n=len(data), p=p, observed=data.sum())\n    mean_q = pm.find_MAP() #find peak of the posterior distribution (its mode), which always uses a GAUSSIAN\n    std_q = ((1\/pm.find_hessian(mean_q, vars=[p]))**0.5)[0]","d5dc8db0":"\"\"\"Code 2.7 (my addition)\"\"\"\n# changed to higher count \nw, n = 120, 180\nx = np.linspace(0, 1, 100)\nplt.plot(x, stats.beta.pdf(x , w+1, n-w+1),\n         label='True posterior')\n\n# quadratic approximation\nplt.plot(x, stats.norm.pdf(x, mean_q['p'], std_q),\n         label='Quadratic approximation')\nplt.legend(loc=0, fontsize=9)\n\nplt.title('n = {}'.format(n), fontsize=14)\nplt.xlabel('Proportion water', fontsize=14)\nplt.ylabel('Density', fontsize=14);","d855441d":"import sys, IPython, scipy, matplotlib, platform\nprint(\"This notebook was createad on a computer %s running %s and using:\\nPython %s\\nIPython %s\\nPyMC3 %s\\nNumPy %s\\nSciPy %s\\nMatplotlib %s\\n\" % (platform.machine(), ' '.join(platform.linux_distribution()[:2]), sys.version[:5], IPython.__version__, pm.__version__, np.__version__, scipy.__version__, matplotlib.__version__))","9888b967":"We see above that more data means better quadratic approximation of the true `p` ","a2fb1386":"# Grid Approximation","f02934ec":"# Quadratic Approximation"}}