{"cell_type":{"6c564fc0":"code","94b08abe":"code","c8285dc1":"code","b02b4bf6":"code","450704d1":"code","54689771":"code","3e55a02d":"code","ff417abf":"code","cc1fb6c8":"code","dc7186ff":"code","89d84da2":"code","71ade5cc":"code","065c4aa5":"code","e2d68cc2":"code","ad63007b":"code","7338f7cc":"code","e8ccdb4d":"code","8d99a5cd":"code","a61378d7":"code","e2e5e5f9":"code","71d19f5a":"code","217c6f63":"code","05b064e5":"code","23315748":"code","6fa60264":"markdown","f48da5cd":"markdown","8938541b":"markdown","67f245dd":"markdown","21e48ec5":"markdown","20faed57":"markdown","2709516b":"markdown","6f3e79d1":"markdown","c27ce016":"markdown","95aee21c":"markdown","17f49a66":"markdown","86d9a437":"markdown"},"source":{"6c564fc0":"%%time\n# installing ffmpeg so that animation module can work\n!apt-get -y install ffmpeg > \/dev\/null\n\nimport secrets  # python 3.6 necessary\nimport random\nimport numpy as np\nimport pandas as pd  # we try not to depend on pandas, to better translate later?\nfrom copy import deepcopy\nfrom IPython.display import display, HTML\nfrom tqdm import tqdm_notebook\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt  # for viz\nimport matplotlib.path as path  # for histogram\nimport matplotlib.patches as patches  # for histogram\n\n\npd.set_option('display.max_rows', 100)","94b08abe":"# defining utility functions which forms the basis of housing valuation\ndef utility_general(house):\n    '''\n    Every person considers a house to have a certain utility.\n    This is not based on personal perferences.\n    '''\n    utility_due_to_location = 2\/(1 + (house[\"location\"][0] - 5.3)**2 \n                                   + (house[\"location\"][1] - 5.3)**2)\n    return utility_due_to_location + house[\"amenities\"][\"fengshui\"]\n\ndef utility_function(person, house):\n    '''\n    A person considers each house to have a different utility.\n    This assigns an additional utility of each house based on personal preferences.\n    '''\n    utility_due_to_person = 1\/(1 + (house[\"location\"][0] - person[\"idio\"][\"preferred_location\"][0])**2 \n                                 + (house[\"location\"][1] - person[\"idio\"][\"preferred_location\"][1])**2)\n    return utility_general(house) + utility_due_to_person\n\n### Weets' Vectorised Utility Functions (works with pd.Series) ###\n# mere translation of above functions\n# its quite hardcoded so not comfortable rofl\n\ndef utility_general_vectorised(house):\n    '''\n    Every person considers a house to have a certain utility.\n    This is not based on personal perferences.\n    '''\n    utility_due_to_location = 2\/(1 + (house[\"location\"].apply(lambda tup: tup[0]) - 5.3)**2 \n                                   + (house[\"location\"].apply(lambda tup: tup[1]) - 5.3)**2)\n    return utility_due_to_location + house[\"amenities\"].apply(lambda amen_dt: amen_dt[\"fengshui\"])\n\ndef utility_function_vectorised(person, house):\n    '''\n    A person considers each house to have a different utility.\n    This assigns an additional utility of each house based on personal preferences.\n    Input\n        person: a dict or pandas df row\n    '''\n    # print(house[\"location\"])\n    # print(house[\"location\"].apply(lambda tup: tup[0]))\n    \n    xloc = (house[\"location\"].apply(lambda tup: tup[0]) - person[\"idio\"][\"preferred_location\"][0])\n    yloc = (house[\"location\"].apply(lambda tup: tup[1]) - person[\"idio\"][\"preferred_location\"][1])\n    \n    utility_due_to_person = 1\/(1 + xloc**2 + yloc**2)\n    return utility_general_vectorised(house) + utility_due_to_person","c8285dc1":"# params\n\n# demographic\nmigration_base_age = 20\nDEATH_RATE = 0.05 #deprecated? cant see where it was called\ndeath_coef = 0.2\nbirth_n, birth_p = 10, 0.2\n\n# geographic\ncity_x, city_y = 7, 9\n\n# economic\nincome_mu, income_sigma = 10, 5\nwealth_mu, wealth_sigma = 300, 10\n\n# houses\ninitialization_price_mu, initialization_price_sigma = 300, 10\nfengshui_mu, fengshui_sigma = 1, .1\n\n# transactions\nPROBA_SELL, PROBA_BUY  = 0.4, 0.8\n","b02b4bf6":"# defining a template person and generate persons\n\ndef generate_person():\n    person = {\n        \"age\": migration_base_age,\n        \"income\": np.random.normal(wealth_mu,wealth_sigma,1)[0],\n        \"wealth\": np.random.normal(wealth_mu,wealth_sigma,1)[0],\n        \"house_staying\": np.NaN,\n        \"house_selling\": np.NaN,\n        \"utility\": 0, # WEETS: utility here is person's 'score'. Every decision person makes must immediately result in increase of 0 or more, never decrease.\n        \"idio\": {\"preferred_location\": (np.random.normal(city_x, 0.1, 1)[0],np.random.normal(city_y, 0.1, 1)[0])}\n    }\n    return person\n\npersons = {}\nfor _ in range(10):\n    persons[secrets.token_hex(4)] = generate_person()\npersons = pd.DataFrame.from_dict(persons, orient='index')\n\npersons['house_staying'] = persons['house_staying'].astype(object)\npersons['house_selling'] = persons['house_selling'].astype(object)\n\npersons.head()","450704d1":"# defining a template house and generate houses\nhouses = {}\nfor x in range(10):\n    for y in range(10):\n        houses[(x,y)] = {\n            \"location\": (x,y),  # also the key \n            \"last_bought_price\": np.random.normal(initialization_price_mu, initialization_price_sigma, 1)[0],\n            \"status\": \"empty\",  # \"empty\", \"occupied\", \"selling\" \n            \"amenities\": {\"fengshui\" : np.random.normal(fengshui_mu, fengshui_sigma, 1)[0]},\n            \"occupant\": np.NaN,\n            \"last_updated\": 0\n        }\n        houses[(x,y)][\"market_price\"] = houses[(x,y)][\"last_bought_price\"]\n\nhouses = pd.DataFrame.from_dict(houses, orient='index')\n\ndef status_to_float(status):\n    if status == \"empty\": return 0 \n    if status == \"occupied\": return 1 \n    if status == \"selling\": return 2\n    \nhouses.head()","54689771":"def aging(verbose = False): # change this a function of age\n    persons[\"age\"] += 1\n    persons[\"wealth\"] += persons[\"income\"]\n    houses[\"last_updated\"] += 1","3e55a02d":"def dying_prob_function(age):\n    return 1.\/(1.+np.exp(-(death_coef*(age-50))))\nplt.figure(figsize = (14,2))\nplt.plot([dying_prob_function(age) for age in np.arange(100)])\nplt.title(\"death probability over age\")\nplt.show()","ff417abf":"def dying(verbose = False): # change this a function of age\n    persons_id_dead = []\n    for person_id in persons.index:\n        if np.random.uniform() < dying_prob_function(persons.loc[person_id,\"age\"]):\n            if verbose: print(person_id, \" died\")\n            dead_person = persons.loc[person_id]\n            if dead_person[\"house_staying\"] != None:\n                if verbose: print(\"vacated \", dead_person[\"house_staying\"])\n                houses.loc[dead_person[\"house_staying\"],\"status\"] = \"empty\"\n                houses.loc[dead_person[\"house_staying\"],\"occupant\"] = None\n                houses.loc[dead_person[\"house_selling\"],\"status\"] = \"empty\"\n                houses.loc[dead_person[\"house_selling\"],\"occupant\"] = None\n            persons_id_dead.append(person_id)\n    persons.drop(persons_id_dead, inplace=True)","cc1fb6c8":"def birth(verbose = False):\n    born = np.random.binomial(birth_n, birth_p)\n    for _ in range(born):\n        persons.loc[secrets.token_hex(4)] = generate_person()","dc7186ff":"persons","89d84da2":"from collections import defaultdict\nhistory = defaultdict(list)\n\ndef update_history(verbose = False):\n    history[\"popn_with_zero_house\"].append((persons.house_staying.values != persons.house_staying.values).sum())\n    history[\"popn_with_one_house\"].append((persons.house_selling.values != persons.house_selling.values).sum())\n    history[\"popn_with_two_house\"].append((persons.house_selling.values == persons.house_selling.values).sum())\n    history[\"average_wealth\"].append(np.mean(persons[\"wealth\"]))\n    history[\"total_houses_empty\"].append((houses.status == \"empty\").sum())\n    history[\"total_houses_occupied\"].append((houses.status == \"occupied\").sum())\n    history[\"total_houses_selling\"].append((houses.status == \"selling\").sum())\n    return None","71ade5cc":"### Phase 2: ASK -> BID -> MATCH -> UPDATE\n# this is meant to be ran just once at the start\nask_df = pd.DataFrame(columns = ['location','occupant_id','amenities', 'ask_price']) # init empty ask_df with col\n            \ndef gen_asks():\n    ''' phase 2 bid-ask\n    1. Refresh ask_df pd.DataFrame()\n    2. Add empty houses from `houses` to ask_df\n    3. Add more listings from persons who can and want to sell houses\n    '''\n    global ask_df # may not be necessary\n    ask_df_columns = ask_df.columns.to_list() # ['house_pos','current_occupant_id','amenities', 'ask_price']\n    \n    # 1. Refresh ask_df pd.DataFrame()\n    ask_df.drop(ask_df.index, inplace=True) # drops all rows\n    \n    # 2. Add empty houses from `houses` to ask_df\n    empty_houses = houses[houses['status']=='empty']\n    \n    ## 2.1 Rename, reorder into ask_df column mold\n    ## ask_df column order: ['house_pos','current_occupant_id','amenities', 'ask_price']\n    empty_houses_listing = empty_houses.rename(columns={\n        'occupant':'occupant_id',\n        'last_bought_price':'ask_price',\n    })\n    empty_houses_listing = empty_houses_listing[ask_df_columns] # reorder\n    \n    ask_df = ask_df.append(empty_houses_listing, ignore_index=True) # TODO: optimise\n    \n    # 3. Add more listings from `persons` who can and want to sell houses\n    ## 3.1 get sub df of persons who have a second house to sell\n    COND_have_house_selling = persons['house_selling'] != None\n    potential_sellers = persons[COND_have_house_selling] # a persons sub df\n    \n    ## 3.2 Get sellable houses that have market price >= cost price\n    potential_house_selling_loc = potential_sellers['house_selling']\n    potential_house_selling = houses[houses['location'].isin(potential_house_selling_loc.values)]\n    COND_market_greater_or_equal_cost_price = potential_house_selling['market_price'] >= potential_house_selling['last_bought_price'] \n    no_loss_house_selling = potential_house_selling[COND_market_greater_or_equal_cost_price] # a houses subdf\n    \n    ## 3.3 Random decide if want to sell or not\n    # arbitrary threshold; TODO: turn into adjustable param\n    COND_want_sell = no_loss_house_selling['status'].apply(lambda runif: np.random.uniform()) <= PROBA_SELL\n    want_sell_houses = no_loss_house_selling[COND_want_sell]\n    want_sell_houses_loc = want_sell_houses['location']\n    actual_house_selling = potential_house_selling[potential_house_selling['location'].isin(want_sell_houses_loc.values)]\n    \n    ## 3.4 Rename, reorder actual_house_selling into ask_df column mold\n    ## ask_df column order: ['house_pos','current_occupant_id','amenities', 'ask_price']\n    main_listing = actual_house_selling.rename(columns={'market_price':'ask_price',\n                                               'occupant':'occupant_id'})\n    main_listing = main_listing[ask_df_columns]\n    \n    ask_df = ask_df.append(main_listing, ignore_index=True)\n    \n    # strangely, there's a row with nan value in location appearing\n    # this chunk fixes that\n    if any(ask_df['location'].apply(lambda loc: type(loc)!=tuple)):\n        # print('Missing location in ask_df, applying fix')\n        ori_len = len(ask_df)\n        ask_df = ask_df[~ask_df['location'].isna()]\n        # print('Change in len', len(ask_df)-ori_len)\n    \n    \n# test run\n# gen_asks()\n# ask_df.sample(10)","065c4aa5":"### Phase 2: ASK -> BID -> MATCH -> UPDATE\n# init empty ask_df with col\nbid_df = pd.DataFrame(columns = ['location', 'bidder_id', 'utility_to_buyer', 'max_bid_price', 'bid_price'])\n    \ndef gen_bids():\n    ''' phase 2 bid-ask\n    1. Refresh bid_df pd.DataFrame()\n    2. Generate subdf of persons who can and want to buy houses\n    3. For each eligible person, iterate over ask, grow person_bids list of dict\n    4. Merge \n    '''\n    global bid_df # may not be necessary\n    bid_df_columns = bid_df.columns.to_list() # ['location', 'bidder_id', 'utility', 'bid_price']\n    \n    # 1. Refresh bid_df pd.DataFrame()\n    bid_df.drop(bid_df.index, inplace=True) # drops all rows\n    \n    # 2. Screen viable bidders\n    ## 2.1 Does not own a second house (can have 1 or 0 houses)\n    COND_only_one_house = persons['house_selling'].isna() # NOTE: do not use `persons['house_selling'] == None` to check\n    potential_buyers = persons[COND_only_one_house]\n    \n    ## 2.2 Random decide if want to seek or not\n     # arbitrary threshold; TODO: turn into adjustable param\n    COND_want_buy = potential_buyers['age'].apply(lambda runif: np.random.uniform()) <= PROBA_BUY\n    eligible_and_seeking_buyers = potential_buyers[COND_want_buy] # these are the eligible people who want to buy houses\n    \n    # 3. Each eligible buyer makes a bid for each house on sale\n    list_of_bid_sets = [] # to be populated with df corr. to each person's bids\n    \n    ## 3.1 Define helper fn\n    def _gen_bid_price(listing_row):\n        max_bid_price = listing_row['max_bid_price']\n        ask_price = listing_row['ask_price']\n        if  max_bid_price >= ask_price:\n            surplus = max_bid_price - ask_price\n            return ask_price + np.random.uniform() * surplus\n        else:\n            return max_bid_price\n    \n    ## 3.2 Iterate over buyers\n    for idx, buyer in eligible_and_seeking_buyers.iterrows():\n        buyer_view_of_ask_df = ask_df.copy()\n        \n        ###  3.2.1 Calculate each listing's utility to buyer\n        buyer_view_of_ask_df['bidder_id'] = idx\n        buyer_view_of_ask_df['utility_to_buyer'] = utility_function_vectorised(buyer, buyer_view_of_ask_df)\n        # NOTE: utility_to_buyer is partial -- it only consider's a houses's general and locational utility and buyer idio\n        \n        ### 3.2.2 Calculate bid_price\n        buyer_view_of_ask_df['max_bid_price'] = buyer['wealth'] - buyer['utility'] + buyer_view_of_ask_df['utility_to_buyer'] # TODO: double check if this is a good rule\n        # NOTE: WEETS suspects above formula may be wrong since it does not compare the differential in utility DUE TO HOUSE only\n        # test: what if utility to buyer is negative? Would you still bid (and spend money)?\n        buyer_view_of_ask_df['max_bid_price'] = buyer_view_of_ask_df['max_bid_price'].apply(lambda mbp: min(mbp, buyer['wealth']))\n        # mbp must be capped at buyer's wealth\n        buyer_view_of_ask_df['max_bid_price'] = buyer_view_of_ask_df['max_bid_price'].apply(lambda mbp: max(0,mbp))\n        # mbp must be non-negative\n        \n        bid_price = buyer_view_of_ask_df.apply(_gen_bid_price, axis=1)\n        buyer_view_of_ask_df['bid_price'] = bid_price\n        \n        ### 3.2.3 Append specific columns of buyer_view_of_ask_df to list_of_bid_sets\n        select_columns = ['location', 'bidder_id', 'utility_to_buyer', 'max_bid_price', 'bid_price']\n        list_of_bid_sets.append(buyer_view_of_ask_df[select_columns])\n    \n    # 4. Concatenate list of dataframes into one dataframe\n    if list_of_bid_sets: # possible that no bids take place\n        bid_df = pd.concat(list_of_bid_sets)\n    return bid_df\n\n# bid_df = gen_bids()\n# # print(bid_df['bidder_id'].nunique())\n# bid_df.head()","e2d68cc2":"### Phase 2: ASK -> BID -> MATCH -> UPDATE\n\ndef match_ask_bid():\n    '''\n    1. Create a container list to store dicts of info relating to bidding for each listing\n    2. Iterate over listings in ask_df, find best bid - is successful match\n    3. For each successful match\n        1. Create and append dict of info relating to bids for the listing\n        2. Remove all bids for same listing\n        3. Remove all other bids by same bidder\n        4. Update asker and bidder\n    4. For each unsuccessful match\n        1. Create and append dict of info relating to bids for the listing\n        2. Remove all bids for same listing\n    5. Make match_df\n    '''\n    global bid_df, persons, houses\n    # 1. Create a container list to store dicts of info relating to bidding for each listing\n    list_of_matches = [] # contains info on winning bid\n    \n    # 2. Iterate over listings in ask_df, find best bid - is successful match\n    for idx, listing in ask_df.iterrows():\n        match_info_dict = {} # stats for each listing match\n        \n        ## 2.1 Get general data\n        listing_loc = listing['location']\n        match_info_dict['location'] = listing_loc\n        \n        match_info_dict['ask_price'] = listing['ask_price']\n        \n        relevant_bids = bid_df[bid_df['location']==listing_loc]\n        match_info_dict['num_bids'] = len(relevant_bids) # expect 0 or more\n        \n        highest_bid_value = relevant_bids['bid_price'].max()\n        match_info_dict['highest_bid_value'] = highest_bid_value\n        \n        match_info_dict['mean_bid_value'] = relevant_bids['bid_price'].mean()\n        \n        # 3. Found winning bid(s)\n        if highest_bid_value >= listing['ask_price']: # there exists a successful match\n            ## 3.1 Create and append dict of info relating to bids for the listing\n            ### 3.1.1 Check for ties among highest bid\n            highest_bids = relevant_bids[relevant_bids['bid_price']==highest_bid_value]\n            num_highest_bid = len(highest_bids) # expect at least 1, rarely more\n            assert num_highest_bid >= 1, 'ERR: num_highest_bid must be >= 1'\n            \n            ### 3.1.2 Get the winner\n            winning_bid = highest_bids.sample(1) # tie-breaker: randomly choose one highest bidder to win\n            \n            winning_bidder_id = winning_bid['bidder_id'].iloc[0]\n            match_info_dict['winning_bidder_id'] = winning_bidder_id\n            match_info_dict['winning_bid_value'] = highest_bid_value # obviously; stated explicitly as highest_bid_value may not win for the `else` case\n            \n            ### 3.1.3 Append match info\n            list_of_matches.append(match_info_dict)\n            \n            ## 3.2 Remove all corresponding bids, 3.3 Remove all other bids by same bidder\n            bid_df = bid_df.drop(relevant_bids.index, axis=0)\n            bid_df = bid_df[~(bid_df['bidder_id']==winning_bidder_id)]\n            \n            ## 3.4 Update asker and bidder\n            asker_id = listing['occupant_id']\n            \n            ### 3.4.1 Update asker\n            if type(asker_id) is str: # if str, then not empty house\n                persons['wealth'].loc[asker_id] += highest_bid_value\n                persons['house_selling'].iloc[asker_id] = np.NaN # potential problem here?\n                # TODO: check where to update 'utility' (person's simulation score) -- here or elsewhere?\n                # ENSURE: asker['utility'] increase or stay the same\n                \n            ### 3.4.2 Update bidder\n            winning_bidder = persons.loc[winning_bidder_id]\n            persons['wealth'].loc[winning_bidder_id] -= highest_bid_value\n            \n            #### Additional updates for bidder if second house buyer\n            if type(winning_bidder['house_staying']) is tuple: # first house exists, buyer is buying second house\n                persons['house_selling'].loc[winning_bidder_id] = winning_bidder['house_staying'] # set current house_staying to be house_selling\n                houses['status'].loc[winning_bidder['house_staying']] = 'selling' # set that same current house to 'selling' status\n            persons['house_staying'].loc[winning_bidder_id] = listing_loc\n            # TODO: check where to update 'utility' (person's simulation score) -- here or elsewhere?\n            # ENSURE: asker['utility'] increase or stay the same\n            \n            ### 3.4.3 Update house\n            houses['last_bought_price'].loc[listing_loc] = highest_bid_value\n            houses['status'].loc[listing_loc] = 'occupied'\n            # Note: for second house buyers, their first house's status has already been updated\n            houses['occupant'].loc[listing_loc] = winning_bidder_id\n            houses['last_updated'].loc[listing_loc] = 0\n            # TODO: update houses['market_price'] at the end of each time step, somewhere else perhaps\n            \n        # 4. No successful match   \n        else:\n            ## 4.1 Create and append dict of info relating to bids for the listing\n            match_info_dict['winning_bidder_id'] = np.NaN\n            match_info_dict['winning_bid_value'] = np.NaN\n            list_of_matches.append(match_info_dict)\n            \n            ## 4.2 Remove all bids for same listing\n            bid_df = bid_df.drop(relevant_bids.index, axis=0)\n            \n    # 5. Make match_df\n    match_df = pd.DataFrame(list_of_matches)\n    return match_df\n\n# gen_asks()\n# bid_df = gen_bids()\n# match_df = match_ask_bid() # Note: changes bid_df each time it is called\n# match_df.head(10)","ad63007b":"persons","7338f7cc":"houses","e8ccdb4d":"%%time\ndef simulate():\n    aging()\n    birth()\n    dying()\n    gen_asks()\n    gen_bids()\n    match_ask_bid()\nfor _ in tqdm_notebook(range(10)):\n    simulate()","8d99a5cd":"%%time\nfig, ax = plt.subplots(2,5,figsize=(12,7))\nplt.subplots_adjust(wspace=0.4)\nim0 = ax[0,0].imshow(np.random.randn(10,10), vmin=0, vmax=2)\nim1 = ax[0,1].imshow(np.random.randn(10,10), vmin=0, vmax=400)\nim2 = ax[0,2].imshow(np.random.randn(10,10), vmin=0, vmax=400)\nim3 = ax[0,3].imshow(np.random.randn(10,10), vmin=0, vmax=100)\nim4 = ax[0,4].imshow(np.random.randn(10,10), vmin=0, vmax=2)\nax[0,0].set_title(\"utility_general\")\nax[0,1].set_title(\"market_price\")\nax[0,2].set_title(\"last_bought_price\")\nax[0,3].set_title(\"last_updated\")\nax[0,4].set_title(\"occupancy status\")\n\nline_pop_0, = ax[1,0].plot([], lw=3)\nline_pop_1, = ax[1,0].plot([], lw=3)\nline_pop_2, = ax[1,0].plot([], lw=3)\nax[1,0].set_ylim((0, 60))\nax[1,0].set_xlim((-20, 0))\nax[1,0].set_title(\"population\")\n\nline_wealth_0, = ax[1,1].plot([], lw=3)\nax[1,1].set_ylim((0, 600))\nax[1,1].set_xlim((-20, 0))\nax[1,1].set_title(\"average wealth\")\n\nscat_income_age = ax[1,2].scatter([], [], s=20)\nax[1,2].set_ylim((0, 600))\nax[1,2].set_xlim((20, 60))\nax[1,2].set_title(\"wealth against age\")\n\n# animating histogram is quite troublesome\n# https:\/\/matplotlib.org\/gallery\/animation\/animated_histogram.html\nbins_bdrs = np.arange(0,600,50)  # defining boundaries\nn, bins = np.histogram(np.random.randn(1000), bins=bins_bdrs)\nleft, right = np.array(bins[:-1]), np.array(bins[1:])\ntop, bottom = np.zeros(len(left)), np.zeros(len(left))\nnrects = len(left)  # defining rectangles\nnverts = nrects * (1 + 3 + 1)\nverts = np.zeros((nverts, 2))\ncodes = np.ones(nverts, int) * path.Path.LINETO\ncodes[0::5], codes[4::5] = path.Path.MOVETO, path.Path.CLOSEPOLY\nverts[0::5, 0], verts[0::5, 1] = left, bottom\nverts[1::5, 0], verts[1::5, 1] = left, top\nverts[2::5, 0], verts[2::5, 1] = right, top\nverts[3::5, 0], verts[3::5, 1] = right, bottom\nbarpath = path.Path(verts, codes)  # defining graphs\nhist_patch = patches.PathPatch(barpath, facecolor='green', edgecolor='yellow', alpha=0.5)\nax[1,3].add_patch(hist_patch)\nax[1,3].set_ylim((0, 20))\nax[1,3].set_xlim((0, 600))\nax[1,3].set_title(\"histogram of wealth\")\n\nline_house_0, = ax[1,4].plot([], lw=3)\nline_house_1, = ax[1,4].plot([], lw=3)\nline_house_2, = ax[1,4].plot([], lw=3)\nax[1,4].set_ylim((0, 100))\nax[1,4].set_xlim((-20, 0))\nax[1,4].set_title(\"housing occupancy\")\n\npatch = [im0, im1, im2, im3, im4, hist_patch]\n\na1 = np.random.randn(10,10)\na2 = np.random.randn(10,10)\na3 = np.random.randn(10,10)\na4 = np.random.randn(10,10)\na5 = np.random.randn(10,10)\n\ndef update_plot():\n    for x in range(10):\n        for y in range(10):\n            a1[x,y] = utility_general(houses.loc[(x,y)])\n            a2[x,y] = houses.loc[(x,y),\"market_price\"]\n            a3[x,y] = houses.loc[(x,y),\"last_bought_price\"]\n            a4[x,y] = houses.loc[(x,y),\"last_updated\"]\n            a5[x,y] = status_to_float(houses.loc[(x,y),\"status\"])\n#     for index in list(houses.index):\n#         a1[index[0], index[1]] = utility_general(houses.loc[(x,y)])\n#         a2[index[0], index[1]] = houses.loc[(x,y),\"market_price\"]\n#         a3[index[0], index[1]] = houses.loc[(x,y),\"last_bought_price\"]\n#         a4[index[0], index[1]] = houses.loc[(x,y),\"last_updated\"]\n#         a5[index[0], index[1]] = status_to_float(houses.loc[(x,y),\"status\"])\n    im0.set_data(a1)\n    im1.set_data(a2)\n    im2.set_data(a3)\n    im3.set_data(a4)\n    im4.set_data(a5)\n    line_pop_0.set_data(range(0,-len(history[\"popn_with_zero_house\"][-20:]),-1), \n                        history[\"popn_with_zero_house\"][-20:][::-1])\n    line_pop_1.set_data(range(0,-len(history[\"popn_with_one_house\"][-20:]),-1), \n                        history[\"popn_with_one_house\"][-20:][::-1])\n    line_pop_2.set_data(range(0,-len(history[\"popn_with_two_house\"][-20:]),-1), \n                        history[\"popn_with_two_house\"][-20:][::-1])\n    \n    line_house_0.set_data(range(0,-len(history[\"total_houses_empty\"][-20:]),-1), \n                          history[\"total_houses_empty\"][-20:][::-1])\n    line_house_1.set_data(range(0,-len(history[\"total_houses_occupied\"][-20:]),-1), \n                          history[\"total_houses_occupied\"][-20:][::-1])\n    line_house_2.set_data(range(0,-len(history[\"total_houses_selling\"][-20:]),-1), \n                          history[\"total_houses_selling\"][-20:][::-1])\n    \n    line_wealth_0.set_data(range(0,-len(history[\"average_wealth\"][-20:]),-1), \n                           history[\"average_wealth\"][-20:][::-1])\n    scat_income_age.set_offsets(np.transpose((persons[\"age\"], persons[\"wealth\"])))\n    \n    # histogram\n    height, bins = np.histogram(persons[\"wealth\"], bins=bins_bdrs)\n    verts[1::5, 1], verts[2::5, 1] = height, height\n\ndef init():\n    return patch\n\ndef animate(i):\n    simulate()\n    update_history()\n    update_plot()\n    return patch\n\n# call the animator. blit=True means only re-draw the parts that have changed.\nanim = animation.FuncAnimation(fig, animate, init_func=init,\n                               frames=1000, interval=100, blit=True)\n\nvid = anim.to_html5_video()\nplt.close()","a61378d7":"HTML(vid)","e2e5e5f9":"persons","71d19f5a":"houses","217c6f63":"# somehow NaN is introduced to the dataframe index\n# this converts the index to a numpy float which I need to reconvert back\nif np.NaN in houses.index:\n    houses = houses.drop([np.NaN])\n\ndef convert_to_tuple_int(index):\n    return (int(index[0]), int(index[1]))\nhouses.index = houses.index.map(convert_to_tuple_int)","05b064e5":"houses","23315748":"import plotly.figure_factory as ff\n# reference https:\/\/plot.ly\/python\/annotated_heatmap\/#custom-hovertext\n\nz = np.empty([10, 10])\nhover = [[None for _ in range(10)] for _ in range(10)]\nann = [[\"\" for _ in range(10)] for _ in range(10)]\n\nfor addr in houses.index:\n    z[addr] = status_to_float(houses.loc[addr,\"status\"])\n    displayed = \"<br>\".join([\"{}: {}\".format(k,v) for k,v in houses.loc[addr].to_dict().items()])\n    occupant = houses.loc[addr,\"occupant\"]\n    if occupant:\n        try:\n            displayed += \"<br><br>Tenant information<br>\"\n            displayed += \"<br>\".join([\"{}: {}\".format(k,v) for k,v in persons.loc[occupant].to_dict().items()])\n        except:\n            pass\n#             print(occupant, \" not found\")\n    hover[addr[0]][addr[1]] = displayed\n\ncolorscale=[[0.0, 'rgb(255,255,255)'],[0.2, 'rgb(255, 255, 153)'],\n            [0.4, 'rgb(153,255,204)'],[0.6, 'rgb(179, 217, 255)'],\n            [0.8, 'rgb(240,179,255)'],[1.0, 'rgb(255,  77, 148)']]\n\n# Make Annotated Heatmap\nfig = ff.create_annotated_heatmap(z, text=hover, hoverinfo='text', annotation_text=ann,\n                                  colorscale=colorscale, font_colors=['black'])\nfig.update_layout(title_text='Occupancy Status')\nfig.show()","6fa60264":"### Update history\nFor trend visualisation at the dashboard.","f48da5cd":"To run this notebook, **you have to enable the Internet connection**","8938541b":"# Inspect housing characteristics","67f245dd":"# Transactions\nWe generate two dataframes - asking and buying.","21e48ec5":"# Visualise simulation","20faed57":"### Birth\nAt every time period, a random number of people enters the system.","2709516b":"# Initial state","6f3e79d1":"# Activities in timestep\nIn every time step, people age, people die, and people get born. Transactions then occur.","c27ce016":"# Read dataframes","95aee21c":"### Aging\nAt every time step, people get old, had wealth increased due to income. \nThe last transcation time of the house is updated for visualisation.","17f49a66":"### Death\nWe define a probability of dying, which is dependent on age.","86d9a437":"# Begin simulation\nWe are using Matplotlib animation module to visualise the simulation.\n\nVisualisations include line graph, scatter plot, histogram and heatmaps.\n\nAt each time step, `simulate()` is called, carries out the changes and updates the dashboard."}}