{"cell_type":{"79197771":"code","c453afeb":"code","23f6f26e":"code","ec5e92db":"code","98b32b4c":"code","574dbc1a":"code","863ada93":"code","12c5779a":"code","3f968f53":"code","d65c6210":"code","d9810499":"code","322f9aee":"code","9ca279b4":"code","12bde257":"code","75e8eb04":"code","6f993f97":"code","2c82f882":"code","5d6afa7d":"code","3c0b58d5":"code","d0d081b9":"code","3dfc9fef":"markdown","9fd7e79e":"markdown","7496583a":"markdown","eda1d30c":"markdown","0c057807":"markdown","6c07bdb7":"markdown"},"source":{"79197771":"# from google.colab import drive\n# drive.mount._DEBUG = True\n# # drive.mount('\/content\/drive', force_remount=True)\n# drive.mount('\/content\/drive')\n\n# #Change the Directry to your project in GOogle driver (Create a folder named : \"App\")\n# %cd \"\/content\/drive\/My Drive\/Colab Notebooks\"\n\n# # List driver\n# !ls\n","c453afeb":"\n\n# !pip install -U -q kaggle\n# !mkdir -p ~\/.kaggle\n\n# from google.colab import files\n# # files.upload()\n\n# !cp kaggle.json ~\/.kaggle\/\n# # !kaggle datasets list\n\n# !kaggle datasets download -d chetankv\/dogs-cats-images\n# !ls","23f6f26e":"import torch\nimport numpy as np\n\n# check if CUDA is available\ntrain_on_gpu = torch.cuda.is_available()\n\nif not train_on_gpu:\n    print('CUDA is not available.  Training on CPU ...')\nelse:\n    print('CUDA is available!  Training on GPU ...')","ec5e92db":"import torch\nimport os\nimport torch.nn as nn \nimport torch.nn.functional as F\nimport torch.optim as optim\n\nimport torchvision\nfrom torchvision import datasets, transforms, models\n\ntorch.set_printoptions(linewidth=120)  # Displa optin for output\ntorch.set_grad_enabled(True) # Already on by default\n\nbatch_size = 32","98b32b4c":"print(torch.__version__)\nprint(torchvision.__version__)","574dbc1a":"def get_num_correct(preds, labels):\n    return preds.argmax(dim=1).eq(labels).sum().item()","863ada93":"\ndata_dir = '..\/input\/dog vs cat\/dataset'\n\ntransform = transforms.Compose([\n    transforms.RandomHorizontalFlip(),\n    transforms.RandomRotation(20),\n    transforms.Resize(size=(224,224)),\n    transforms.ToTensor(),\n    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n    ])\n\n# test_transform = transforms.Compose([\n#                                 transforms.Resize(254),\n#                                 transforms.CenterCrop(254),\n#                                 transforms.ToTensor()])\n\n\ntrain_data =  torchvision.datasets.ImageFolder(data_dir + '\/training_set', transform = transform)\ntest_data =  torchvision.datasets.ImageFolder(data_dir + '\/test_set', transform = transform)","12c5779a":"BATCH_SIZE = 64\n\ntrain_iterator = torch.utils.data.DataLoader(train_data, shuffle=True, batch_size=BATCH_SIZE)\nvalid_iterator = torch.utils.data.DataLoader(test_data, batch_size=BATCH_SIZE)\n# test_iterator = torch.utils.data.DataLoader(test_data, batch_size=BATCH_SIZE)","3f968f53":"device = torch.device('cuda')","d65c6210":"import torchvision.models as models\n\nmodel = models.resnet18(pretrained=True).to(device)","d9810499":"print(model)","322f9aee":"for param in model.parameters():\n    param.requires_grad = False","9ca279b4":"model.fc = nn.Linear(in_features=512, out_features=2).to(device)","12bde257":"\ncriterion = nn.CrossEntropyLoss()","75e8eb04":"optimizer = optim.Adam(model.parameters())","6f993f97":"def calculate_accuracy(fx, y):\n    preds = fx.max(1, keepdim=True)[1]\n    correct = preds.eq(y.view_as(preds)).sum()\n    acc = correct.float()\/preds.shape[0]\n    return acc","2c82f882":"def train(model, device, iterator, optimizer, criterion):\n    \n    epoch_loss = 0\n    epoch_acc = 0\n    \n    model.train()\n    \n    for (x, y) in iterator:\n        \n        x = x.to(device)\n        y = y.to(device)\n        \n        optimizer.zero_grad()\n                \n        fx = model(x)\n        \n        loss = criterion(fx, y)\n        \n        acc = calculate_accuracy(fx, y)\n        \n        loss.backward()\n        \n        optimizer.step()\n        \n        epoch_loss += loss.item()\n        epoch_acc += acc.item()\n        \n    return epoch_loss \/ len(iterator), epoch_acc \/ len(iterator)","5d6afa7d":"def evaluate(model, device, iterator, criterion):\n    \n    epoch_loss = 0\n    epoch_acc = 0\n    \n    model.eval()\n    \n    with torch.no_grad():\n        for (x, y) in iterator:\n\n            x = x.to(device)\n            y = y.to(device)\n\n            fx = model(x)\n\n            loss = criterion(fx, y)\n\n            acc = calculate_accuracy(fx, y)\n\n            epoch_loss += loss.item()\n            epoch_acc += acc.item()\n        \n    return epoch_loss \/ len(iterator), epoch_acc \/ len(iterator)","3c0b58d5":"EPOCHS = 10\nSAVE_DIR = 'models'\nMODEL_SAVE_PATH = os.path.join(SAVE_DIR, 'resnet18-dogs-vs-cats.pt')\n\nbest_valid_loss = float('inf')\n\nif not os.path.isdir(f'{SAVE_DIR}'):\n    os.makedirs(f'{SAVE_DIR}')\n\nfor epoch in range(EPOCHS):\n    train_loss, train_acc = train(model, device, train_iterator, optimizer, criterion)\n    valid_loss, valid_acc = evaluate(model, device, valid_iterator, criterion)\n    \n    if valid_loss < best_valid_loss:\n        best_valid_loss = valid_loss\n        torch.save(model.state_dict(), MODEL_SAVE_PATH)\n    \n    print(f'| Epoch: {epoch+1:02} | Train Loss: {train_loss:.3f} | Train Acc: {train_acc*100:05.2f}% | Val. Loss: {valid_loss:.3f} | Val. Acc: {valid_acc*100:05.2f}% |')","d0d081b9":"model.load_state_dict(torch.load(MODEL_SAVE_PATH))\n\ntest_loss, test_acc = evaluate(model, device, valid_iterator, criterion)\n\nprint(f'| Test Loss: {test_loss:.3f} | Test Acc: {test_acc*100:05.2f}% |')","3dfc9fef":"### Connect Colab to Google drive ","9fd7e79e":"## if using google colab","7496583a":"### Check GPU availability","eda1d30c":"# Dog Cat Classifier - Pretrained - pytroch","0c057807":"### Download data set from kaggle\n[Downloading Kaggle Datasets into Google Colab](https:\/\/medium.com\/@opalkabert\/downloading-kaggle-datasets-into-google-colab-fb9654c94235)","6c07bdb7":"### Preprocess images"}}