{"cell_type":{"f7afe793":"code","e8bee9d7":"code","552a0925":"code","15e6a4cc":"code","80c43ac9":"code","2f466746":"code","6217d918":"code","69707480":"code","ca60b308":"code","7b8ba0fb":"code","9b7ab47e":"code","848548b7":"code","a0b27798":"code","5eb35aa6":"code","9069d315":"code","eae279d2":"code","708ae101":"code","4fd01795":"code","02647e1d":"code","f5ae106d":"code","5b3edb2b":"code","bbec9bd2":"code","4fe209cd":"code","fe5f686c":"code","a98081eb":"code","5feca202":"code","dc9a8c20":"code","1076a392":"code","6384d12a":"code","c1b18700":"code","788de788":"code","1a381bec":"code","5b758552":"code","eb22db0a":"code","3d7b16bd":"code","7a5de180":"code","6cb8ee58":"code","fcd4bcb4":"code","ec268c09":"code","552498f8":"code","6ccd1367":"code","961fbffe":"code","25f8d16e":"code","3d65909c":"code","0cdd1707":"code","c842fb32":"code","7e0b2a79":"code","5f542cb7":"code","e4d1f473":"code","eb972234":"code","6315064e":"code","a6efeaf6":"code","c61ece41":"code","a2c7e9fa":"code","362b6b6b":"code","eb8c0a91":"code","e2fe4e5b":"code","9a3b0a01":"markdown","811d03b5":"markdown","f27e1d94":"markdown","984bed74":"markdown","d7380edb":"markdown","490551b3":"markdown","39ca4f99":"markdown","9e890776":"markdown","79cb8ba7":"markdown","8d5e5af1":"markdown","46965858":"markdown","cd875f34":"markdown","d84078dc":"markdown","3a4bf0e7":"markdown","d7ff3e57":"markdown","a7ceeb91":"markdown","7bae768f":"markdown","9ca695dd":"markdown","d5d9a86e":"markdown","ed55f039":"markdown","c686536f":"markdown","a2ebf61d":"markdown"},"source":{"f7afe793":"import random\nimport math\nimport numpy as np\n\nrandom.seed(0)\nrand_list = [random.randint(0, 100) for r in range(1000)]\n\ndef list_sqrt(list):\n    return [math.sqrt(n) for n in list]\n\n%timeit rand_list_sqrt = list_sqrt(rand_list)\n","e8bee9d7":"np_rand_array = np.array(rand_list)\n%timeit np_rand_array_sqrt = np.sqrt(np_rand_array)","552a0925":"# From a Python list\narray1 = np.array([1, 2, 3, 4, 5])\narray1","15e6a4cc":"# Print the underlying data type used by the array.\narray1.dtype","80c43ac9":"# NumPy's equivalent of `range`\narray2 = np.arange(0, 100, 2)\narray2","2f466746":"# Using a specific data type. See the following page for a list of available types: https:\/\/numpy.org\/doc\/1.17\/user\/basics.types.html\narray3 = np.arange(0, 100, 2, dtype='float32')\narray3","6217d918":"# Fill an array with zeros\narray4 = np.zeros(10, dtype='float64')\narray4","69707480":"# Or ones\narray5 = np.ones(10, dtype='int32')\narray5","ca60b308":"# Or custom number\narray6 = np.full(30, 2.7818)\narray6","7b8ba0fb":"# Or a range between certain numbers, with a certain stride (3 in this case).\narray7 = np.arange(0, 100, 3)\narray7","9b7ab47e":"# Or a range between certain numbers, specifying the total number of numbers instead of stride.\narray8 = np.linspace(0, 10, 21) # 21 uniformly-spaced numbers between 0 and 10\narray8","848548b7":"# Randomly generating an array of floats.\narray9 = np.random.random(10)\narray9","a0b27798":"# Or an array of integers between a specific range\narray10 = np.random.randint(10, 20, size=50) # 50 random integers between 10 and 20.\narray10\n","5eb35aa6":"# Creating a 2-D array of zeros.\narray11 = np.zeros((10, 10))\narray11","9069d315":"# Similarly, the type can be specified.\narray12 = np.zeros((10, 10), dtype='int64')\narray12","eae279d2":"# Or fill with ones.\narray13 = np.ones((5, 5), dtype='int64')\narray13","708ae101":"# Creating 3-D arrays is as easy.\narray14 = np.ones((3, 3, 3), dtype='int64')\narray14","4fd01795":"# Back to 2-D arrays, you could also convert a Python list of lists into an array.\narray15 = np.array([[1, 2, 3],\n                    [2, 3, 2],\n                    [3, 2, 1]])\narray15\n","02647e1d":"array16 = np.ones((3, 5), dtype='float64')\nprint(array16.ndim)\nprint(array16.shape)\nprint(array16.dtype)\nprint(array16.itemsize)\nprint(array16.size)\n","f5ae106d":"# I will use this array for the examples of this section.\nnp.random.seed(0)\narray17 = np.random.randint(0, 10, size=(4, 5))\narray17","5b3edb2b":"# Extract the first row.\narray17[0, :]","bbec9bd2":"# Or the last row.\narray17[-1, :]","4fe209cd":"# Extract the first and third columns.\narray17[:, [0, 2]]","fe5f686c":"# Extract the element in the 3rd row and 4th column. This should have been the first example, shouldn't it?\narray17[2, 3]","a98081eb":"# From the first row, extract the third element up until the end.\narray17[0, 2:]","5feca202":"# Extract the elements in the middle.\narray17[1:3, 1:4]","dc9a8c20":"# Like indexing for Python lists, you could use negative strides to arrays. The line below extract the first row in reversed order.\narray17[0, ::-1]","1076a392":"array18 = array17.copy() # Copy the array so we don't modify the original one.\narray18","6384d12a":"array18[0, 0] = 100\narray18","c1b18700":"# Change the first three elements of the first row in one operation.\narray18[0, 0:3] = (1000, 2000, 3000)\narray18","788de788":"# Change the first and third elements of the fourth column.\narray18[[0, 2], 3] = [5000, 6000]\narray18","1a381bec":"array19 = np.arange(0, 10)\narray19","5b758552":"# Find the squares of the numbers.\narray20 = np.square(array19)\narray20","eb22db0a":"# Let's find the difference between the numbers and their squares.\narray21 = np.subtract(array20, array19)\narray21","3d7b16bd":"# Actually, for substraction and other elementary functions, you could simply\n# use the Python operators, but I wanted to illustrate the original function\n# which the operator will end up calling.\narray21 = array20 - array19\narray21\n","7a5de180":"# Find the sines for values between 0 and 2*pi.\narray22 = np.linspace(0, 2*np.pi, 20)\narray22_sin = np.sin(array22)\narray22_sin","6cb8ee58":"# and the cosines\narray22_cos = np.cos(array22)\narray22_cos","fcd4bcb4":"# Having the sines and cosines, we might as well draw the circle!\nfrom matplotlib import pyplot as plt\nplt.figure(figsize=(4, 4))\nplt.plot(array22_sin, array22_cos)","ec268c09":"# Let's use NumPy to sum the numbers from 1 to 100 to see whether Gauss was right: https:\/\/en.wikipedia.org\/wiki\/Carl_Friedrich_Gauss#Anecdotes\narray23 = np.arange(1, 101)\nnp.sum(array23)","552498f8":"# To find the average:\nnp.average(array23)","6ccd1367":"# To find the minimum:\nnp.min(array23)","961fbffe":"# To find the maximum:\nnp.max(array23)","25f8d16e":"array24_x = np.random.randint(-10, 10, size=50) # 50 random integers between 10 and 20.\narray24_y = np.random.randint(-10, 10, size=50) # 50 random integers between 10 and 20.\narray24_x_centre = np.average(array24_x)\narray24_y_centre = np.average(array24_y)\n\nfrom matplotlib import pyplot as plt\nplt.figure(figsize=(6, 6))\nplt.plot(array24_x, array24_y, 'o', color='green')\nplt.plot(array24_x_centre, array24_y_centre, 'x', color='red')\n","3d65909c":"array24 = np.random.randint(0, 100, size=50)\narray24","0cdd1707":"# Sort the array.\narray25 = np.sort(array24)\narray25","c842fb32":"array26 = np.random.randint(10, 30, size=50) # random temperatures in Celesius\narray26","7e0b2a79":"# Comparison operators produce a True\/False array.\narray26 > 20","5f542cb7":"# By passing in a True\/False array to another array, we could extract\n# the elements for which we pass True.\narray26[array26 > 20]","e4d1f473":"# We could then use a function like count_nonzero on the boolean array\n# to find the number of days in whech the temparuter is above 20.\nnp.count_nonzero(array26 > 20)","eb972234":"# Let's start by generating an array of 10 random numbers between 0 and 100.\narray27 = np.random.random(10)*100\narray27","6315064e":"# Find the average\narray27_mean = np.average(array27)\narray27_std = np.std(array27)\nprint(f\"Mean = {array27_mean}\")\nprint(f\"Standard Deviation = {array27_std}\")\n","a6efeaf6":"# Normalize the array: substract the average from all the elements and divide the\narray27_normal = (array27 - array27_mean)\/array27_std\narray27_normal","c61ece41":" # reduce precision to make printing compact\n%precision 2\narray28 = np.random.random((3, 7))*100\narray28","a2c7e9fa":"# Assuming each column represent a sample, find the mean of each column.\narray28_mean = np.average(array28, axis=0) # Notice that we have to specify the dimension,\n                                           # otherwise the function would average all elements.\narray28_mean\n\n","362b6b6b":"# Similarly, find the standard deviation.\narray28_std = np.std(array28, axis=0)\narray28_std","eb8c0a91":"# Now let's do only the substraction so we could see what is happening\narray28 - array28_mean","e2fe4e5b":"# Now find the full normalization\n(array28 - array28_mean)\/array28_std","9a3b0a01":"# Conclusion\n\nI hope the demos in this notebook helped you build a good understanding of NumPy. It is, nevertheless, still a good to do more reading. Consider reading [Chatpre 2: Introduction to NumPy](https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/02.00-introduction-to-numpy.html) of the [Python Data Science Handbook](http:\/\/shop.oreilly.com\/product\/0636920034919.do). It is also worth navigating NumPy's official [user guide](https:\/\/numpy.org\/doc\/1.17\/user\/index.html) and [reference](https:\/\/numpy.org\/doc\/1.17\/reference\/index.html).","811d03b5":"# Multi-Dimensional Arrays\n\nDealing with multi-dimensional arrays in NumPy is not much different from dealing with single dimensional arrays. The examples below illustrates how.","f27e1d94":"As you can see, by simply substracting a number from an array, NumPy automatically substracted the number from every element of the array; same thing with the division by the standard deviation. This is broadcasting in NumPy. In fact, I cheated a little bit in this section, as when I generated the random list above, I used broadcasting when multiplying the array generated by `np.random.random` by 100; that was also broadcasting.\n\nBroadcasting is not limited to operation between a 1-D array and a scalar. For example, you can subtract a `[1 x 5]` matrix from a `[5 x 5]` matrix, and NumPy will do the equivalent of duplicating the `[1 x 5]` 5 times row-wise such that it becomes a `[5 x 5]` matrix, then subtract it from the other `[5 x 5]` matrix.\n\nIt might be a little bit complicated at the beginning to understand how broadcasting works, and in fact there are [rules](https:\/\/numpy.org\/doc\/1.17\/user\/quickstart.html#broadcasting-rules) that I encourage you to read, but the idea is basically that **NumPy will try to make the operands match in size by doing the necessary duplications, and then apply the operation**. For example, in the normalization example above, when we substracted the mean from the array, you could think of it as generating another array containing the mean duplicated across it, and then substracting that array from the original array.\n\nBroadcasting is extremely useful in machine learning. Usually, you have a huge number of samples that you want to train your model on. To achieve the best performance, the samples are stored in huge matrices and the same operation (whatever it is that need to be computed) is applied to all the rows of the matrix. For example, if we have a million arrays to be normalized, then we could put them all in one huge matrix and then find a vector containing the means and another one containing the standard deviation, then employ broadcasting to efficiently normalize all arrays:\n","984bed74":"For more information on array creation, see [NumPy's reference](https:\/\/numpy.org\/doc\/1.17\/reference\/routines.array-creation.html).","d7380edb":"# Universal Functions\n\nThe most important feature in NumPy after arrays themselves is universal functions. Don't let the term \"universal\" confuse you in that they are special functions. They are the same typical computational functions like addition, multiplication, log, sin, cos, etc. They are called universal because they apply to multiple elements at the same time. So, instead of iterating over all the elements of an array, you simply pass the array to those functions and they will do the job. Let's demonstrate this with examples.","490551b3":"# Modifying Arrays\n\nModifying NumPy arrays is no different than modifying Python lists. However, with the power of indexing as explained in the previous seciton, you can do much more than you can with a Python list.","39ca4f99":"# Indexing\n\nIndexing is very powerful in NumPy. You can extract single elements, multiple adjacent elements, multiple elements randomly selected, certain columns or rows from matrics, and so on. Again, this is best explained by examples.","9e890776":"# Creating NumPy Arrays","79cb8ba7":"# Broadcasting\n\nAt times, we need to perform operations among arrays of different sizes, or arrays and scalars, and so on. For example, it is very common in statistics to need to [normalize](https:\/\/en.wikipedia.org\/wiki\/Normalization_%28statistics%29) a list of numbers, for which we need to find the mean and then substract it from all numbers, and then divide by the standard deviation. NumPy allows us to do such operations by what is called [broadcasting](https:\/\/numpy.org\/doc\/1.17\/reference\/ufuncs.html#broadcasting). Let's implement the normalization using NumPy to see how this works.","8d5e5af1":"As easy as that! Notice that we didn't have to worry about providing the dimensions of the array, all we did was a simple substraction and division and NumPy did the rest.","46965858":"There are many more universal functions in NumPy, but this should be enough to introduce the basic idea. For a list of available functions, see [NumPy reference](https:\/\/numpy.org\/doc\/1.17\/reference\/ufuncs.html#available-ufuncs). Also see [Computation on NumPy Arrays: Universal Functions](https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/02.03-computation-on-arrays-ufuncs.html) section of Chapter 2 of [Python Data Science Handbook](http:\/\/shop.oreilly.com\/product\/0636920034919.do).","cd875f34":"This is the first part of a series of notebooks about machine learning. I will take the reader through the basic functionality of [NumPy](https:\/\/numpy.org). NumPy is the main package for scientific computing in Python. Machine learning is not different from scientific computing in this regard; it requires a lot of computations for which NumPy is a cornerstone.\n\nAs someone who is excited about machine learning, NumPy might not immediately be very exciting, since it might not be obvious at the beginning what the link between this package and machine learning is, especially for someone who is just starting with machine learning. However, as a package which is used a lot in machine learning, it is important to build a good familiarity of NumPy.\n\n# Why NumPy?\n\nNumPy provides computational functionalities like arithmetic, mathematical functions, etc. The first question that might come to mind is why do we need this when Python provides many computational functionalities out of the box? There are multiple reasons:\n\n1. Python mainly deals with individual numbers, as opposed to NumPy which makes computations on arrays much easier.\n2. Numbers in python are [objects](https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/02.01-understanding-data-types.html#A-Python-Integer-Is-More-Than-Just-an-Integer), making computations, especially on a large number of them, much slower than NumPy, which stores numbers efficiently and employ [CPU special instructions](https:\/\/stackoverflow.com\/questions\/8385602\/why-are-numpy-arrays-so-fast) to make computations extremely fast.\n3. Finally, NumPy provides a plethora of functions that are otherwise not available in Python out of the box. NumPy is actually a computational framework.","d84078dc":"# NumPy for MATLAB\/Octave Users\n\nFor those of you have already used MATLAB\/Octave before, the material presented in this notebook should not be new to you and the important thing is how to map your knowledge of MATLAB\/Octave to NumPy. I found [this page](https:\/\/numpy.org\/doc\/1.17\/user\/numpy-for-matlab-users.html) from NumPy documentation to be useful as a quick cheatsheet. I hope you find it useful too.","3a4bf0e7":"Let's generate a random set of points and find their centre of mass:","d7ff3e57":"# Comparison on Arrays\n\nYou can apply comparison operations on arrays. For example, assume you have an array containing the daily average temperature and you want to find temperatures above a certain number.","a7ceeb91":"Notice the 3-fold difference in speed. Furthermore, notice that without NumPy I had to define a function to find the square root of an array, while with NumPy I simply used the `np.sqrt` function.\n\nThe remaining of this notebook will go through the different functionalities of NumPy by example. As a reference, I depended on [NumPy manual](https:\/\/numpy.org\/doc\/1.17\/index.html) and [Chapter 2](https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/#2.-Introduction-to-NumPy) of [Python Data Science Handbook](http:\/\/shop.oreilly.com\/product\/0636920034919.do).","7bae768f":"Like aggregation, sorting is also easy to do with NumPy.","9ca695dd":"# NumPy's Array Attributes\n\nNow that we got a taste of how NumPy works, let's get into some details. The main object of NumPy is the the [ndarray object](https:\/\/numpy.org\/doc\/1.17\/reference\/arrays.ndarray.html). This object has the following [attributes](https:\/\/numpy.org\/doc\/1.17\/user\/quickstart.html#the-basics) which are useful to understand:\n\n- **ndim**: The number of dimensions of the array.\n- **shape**: A tuple containing the size of each dimension, e.g. a `2x3` matrix will have a shape of `(2, 3)`.\n- **dtype**: The type of the elements of the array, e.g. `int32`, `float32`, etc.\n- **itemsize**: The size in bytes of each element of the array. For example, for `int32` the size is 4.\n- **size**: The total number of elements in the array. This is equivalent to the multiplication of the elements of `shape`. For example, for a shape of `(2, 3)`, the size is 2 x 3 = 6.\n\nThe example below best illustrates those fields.","d5d9a86e":"# How Fast is it?\n\nCalculations in NumPy are usually faster than vanilla Python by orders of magnitude. Check the example below. It generates random a list of numbers (fixing the seed to 0 so the same list is generated every time) then use Python to find the square root of each element in the list. It then uses NumPy to do the same.","ed55f039":"For more examples, see [Fancy Indexing](https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/02.07-fancy-indexing.html) in Chapter 2 of [Python Data Science Handbook](http:\/\/shop.oreilly.com\/product\/0636920034919.do).","c686536f":"# Aggregation and Sorting\n\nNumPy also provides a set of functions for use with aggregation, e.g. min, max, etc. The way you use those functions is not different than universal functions.\n","a2ebf61d":"You get the basic idea. You could try any different combination of indexing and assign values to them in one go. This is really powerful, especially for processing huge arrays as is very common in machine learning."}}