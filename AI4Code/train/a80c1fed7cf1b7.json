{"cell_type":{"8b5f324d":"code","8a28a172":"code","29f01a43":"code","b14d4966":"code","e0d33cf6":"code","b3c61b45":"code","199739cd":"code","44875f10":"code","f8296d87":"code","40f40e5c":"markdown","44f08ea5":"markdown","37e9ea53":"markdown","4257e2e3":"markdown","b6990768":"markdown","efd93fd9":"markdown","9c4be930":"markdown"},"source":{"8b5f324d":"import numpy as np \nimport pandas as pd\nimport glob\nimport warnings\nfrom sklearn.metrics import r2_score\nwarnings.filterwarnings('ignore')","8a28a172":"#log return\ndef log_return(list_stock_prices):\n    return np.log(list_stock_prices).diff()\n\n#realized volatility\ndef realized_volatility(series_log_return):\n    return np.sqrt(np.sum(series_log_return**2))\n\n#rmspe\ndef rmspe(y_true, y_pred):\n    return  (np.sqrt(np.mean(np.square((y_true - y_pred) \/ y_true))))","29f01a43":"df_train = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/train.csv')\ndf_train['row_id'] = df_train['stock_id'].astype(str) + '-' + df_train['time_id'].astype(str)\ndf_train = df_train[['row_id','target']]","b14d4966":"def predictions(list_order_book_file):\n    list_pred = []\n\n    for file in list_order_book_file:\n        stock_id = file.split('=')[1]\n\n        df_book = pd.read_parquet(file)\n\n\n        #I consider important both prices, the most importans and the second, so 0.8 of weight for the best wap and a 0.2 for the second sounds ok for me\n        df_book['wap1'] = (df_book['bid_price1'] * df_book['ask_size1']\\\n                              + df_book['ask_price1'] * df_book['bid_size1'])\\\n                                \/(df_book['bid_size1']+ df_book['ask_size1'])\n\n        df_book['wap2'] = (df_book['bid_price2'] * df_book['ask_size2']\\\n                              + df_book['ask_price2'] * df_book['bid_size2'])\\\n                                \/(df_book['bid_size2']+ df_book['ask_size2'])\n\n        df_book['wap']= df_book['wap1']*0.8 + df_book['wap2']*0.2\n\n        #this is the unique list of time_id elements. it's used for looping each stock on each time_id\n        list_times = list(pd.unique(df_book['time_id']))\n\n\n        for t in list_times:\n            df_pre= df_book[df_book['time_id']== t]\n\n            df_pre.loc[:,'log_return'] = log_return(df_pre['wap'])\n            df_pre = df_pre[~df_pre['log_return'].isnull()]\n\n            realized_vol = realized_volatility(df_pre['log_return'])\n\n            list_pred.append({\n                'row_id': str(stock_id)+'-'+str(t),\n                'pred':realized_vol\n            })\n            \n    return pd.DataFrame(list_pred)","e0d33cf6":"list_order_book_file_train = glob.glob('..\/input\/optiver-realized-volatility-prediction\/book_train.parquet\/*')\ndf_pred_train = predictions(list_order_book_file_train)\ndf_pred_train.head(5)","b3c61b45":"df_joined = df_train.merge(df_pred_train[['row_id','pred']], on = ['row_id'], how = 'left')\\\n.dropna().reset_index(drop=True)","199739cd":"R2 = round(r2_score(y_true = df_joined['target'], y_pred = df_joined['pred']),3)\nRMSPE = round(rmspe(y_true = df_joined['target'], y_pred = df_joined['pred']),3)\nprint(f'Performance of the naive prediction: R2 score: {R2}, RMSPE: {RMSPE}')","44875f10":"list_order_book_file_test = glob.glob('..\/input\/optiver-realized-volatility-prediction\/book_test.parquet\/*')","f8296d87":"df_pred_test = predictions(list_order_book_file_test)\ndf_pred_test.to_csv('submission.csv',index = False)","40f40e5c":"Show the results","44f08ea5":"### **Usefull functions**\n\nlog_return and realized_volatility are the same function as [Jiashen Liu](https:\/\/www.kaggle.com\/jiashenliu) from Optiver provides.\n\n","37e9ea53":"### Submission\nAs a last step, we will make a submission via the tutorial notebook -- through a file written to output folder. \nThe naive submission scored a RMSPE 0.308 on public LB, the room of improvement is big for sure!","4257e2e3":"#### **Load the train set**\n\nNote that i create a new column called row_id. It is goin to be used for merge the table with the results","b6990768":"Join both dataframes, the previos and the train using the row_id as a key value","efd93fd9":"# **Optiver Realized Volatility Predic**\n\nThis reproduces the naive solution from the [notebook](https:\/\/www.kaggle.com\/jiashenliu\/introduction-to-financial-concepts-and-data) provided by the contest organizers, but replaces the way that WAP is calculted.\n\nAlso i used the notebook shared by Slawek Biel as a template to organize the information.","9c4be930":"In the next cell i will calculate the wap for each stock at a particular time_id making a 80-20 distribution betwen the most important and the second."}}