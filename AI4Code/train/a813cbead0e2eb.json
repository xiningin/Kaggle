{"cell_type":{"5a97ecb6":"code","9596dec6":"code","3f09d01c":"code","895d0b00":"code","bad92bdd":"code","5b49007f":"code","74a50321":"code","d2d2a66b":"code","fe34f5f8":"code","b6ba4e4c":"code","1c539fe6":"code","f5b741b9":"code","7317a547":"code","992deb81":"code","1db8917e":"code","da349f23":"code","4aecba0f":"code","bbc7b067":"code","70043a6c":"code","9c1edf87":"code","8b86d653":"code","6aaa63c7":"code","f0271ae7":"code","25eaee9e":"code","be50386c":"code","81fc5cf3":"code","91932beb":"code","c31cad1e":"code","f1afab5b":"code","dc2d54f8":"code","9b99c1a7":"code","4ec43ff2":"code","9bab76df":"code","4cee7f0e":"markdown","b6eff8be":"markdown","fb926d06":"markdown"},"source":{"5a97ecb6":"import torch\nimport torch.nn as nn\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom torchvision import datasets, transforms\nimport torch.nn.functional as F\nfrom torch.utils.data.sampler import SubsetRandomSampler\nimport torch.optim as optim\nimport os","9596dec6":"# from google.colab import drive\n# drive.mount('\/content\/drive')\n# !unzip '\/content\/drive\/MyDrive\/Colab Notebooks\/hindisme\/DevanagariHandwrittenCharacterDataset.zip' -d '\/content\/drive\/MyDrive\/Colab Notebooks\/hindisme\/'","3f09d01c":"# define training and test data directories\ndata_dir = '..\/input\/hindi-character-recognition\/DevanagariHandwrittenCharacterDataset'\ntrain_dir = os.path.join(data_dir, 'Train\/')\ntest_dir = os.path.join(data_dir, 'Test\/')","895d0b00":"classes = os.listdir(train_dir)\nprint(len(classes))\nclasses","bad92bdd":"train_transform = transforms.Compose([\n    transforms.RandomRotation(10),\n    transforms.RandomAffine(degrees=45, translate=(0.1, 0.1), scale=(0.8, 1.2)),\n    transforms.RandomCrop(32),\n    transforms.ToTensor(),\n    transforms.Normalize((0.5, ), (0.5, ))\n])\n\ntest_transform = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize((0.5, ), (0.5, ))\n])\n\ntrain_data = datasets.ImageFolder(train_dir, transform=train_transform)\ntest_data = datasets.ImageFolder(test_dir, transform=train_transform)\n\n# print out some data stats\nprint('Num training images: ', len(train_data))\nprint('Num test images: ', len(test_data))","5b49007f":"batch_size = 32\nvalid_size = 0.10\n\nnum_train = len(train_data)\nsplit_point = int(valid_size * num_train)\n\nindices = list(range(num_train))\nnp.random.shuffle(indices)\n\nvalid_indices = indices[:split_point]\ntrain_indices = indices[split_point:]\n\ntrain_sampler = SubsetRandomSampler(train_indices)\nvalid_sampler = SubsetRandomSampler(valid_indices)","74a50321":"train_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, sampler=train_sampler)\nvalid_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, sampler=valid_sampler)\ntest_loader = torch.utils.data.DataLoader(test_data, batch_size=batch_size, shuffle=True)","d2d2a66b":"# checking batch\nexamples = enumerate(train_loader)\nbatch_idx, (example_data, example_targets) = next(examples)\nexample_data.shape","fe34f5f8":"# checking batch\nexamples = enumerate(test_loader)\nbatch_idx, (example_data, example_targets) = next(examples)\nexample_data.shape","b6ba4e4c":"torch.cuda.is_available()","1c539fe6":" train_on_gpu = torch.cuda.is_available()\n # obtain one batch of test images\ndataiter = iter(test_loader)\nimages, labels = dataiter.next()\nimages.numpy()\n\n# move model inputs to cuda, if GPU available\nif train_on_gpu:\n    images = images.cuda()\n\n\n# plot the images in the batch, along with predicted labels\nfig = plt.figure(figsize=(25, 4))\nfor idx in np.arange(20):\n    ax = fig.add_subplot(2, 20\/2, idx+1, xticks=[], yticks=[])\n    img = images.cpu()[idx]\n    img = img * 0.5 + 0.5\n    img = np.transpose(img, (1, 2, 0))\n    # img = torchvision.transforms.ToTensor()(img)\n    plt.imshow(img)\n    ax.set_title(test_data.classes[labels[idx].item()])","f5b741b9":"def output(input_volume, kernel_size, padding, stride=1):\n    return ((input_volume - kernel_size + 2 * padding)\/stride) + 1\n\ninput_size = 32\nprint(\"Input image is of size: {}x{}\".format(input_size, input_size))\nprint(\"First Conv sees: {}x{}\".format(input_size, input_size))\ninput_size = output(input_volume=input_size, kernel_size=5, padding=0, stride=1)\nprint(\"Second Conv sees: {}x{}\".format(input_size, input_size))\ninput_size = output(input_volume=input_size, kernel_size=5, padding=0, stride=1)\nprint(\"Third Conv sees: {}x{}\".format(input_size, input_size))\ninput_size = output(input_volume=input_size, kernel_size=5, padding=0, stride=1)\nprint(\"Fourth Conv sees: {}x{}\".format(input_size, input_size))","7317a547":"class Network(nn.Module):\n    \n    def __init__(self):\n        super().__init__()\n        \n        # First layer sees: 32x32x3\n        self.conv1 = nn.Conv2d(in_channels=3, out_channels=16, \n                    kernel_size=5, stride=1, padding=0)\n        \n        # Second layer sees: 28x28x16\n        self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, \n                    kernel_size=5, stride=1, padding=0)\n        \n        # Third layer sees: 24x24x32\n        self.conv3 = nn.Conv2d(in_channels=32, out_channels=64, \n                    kernel_size=5, stride=1, padding=0)\n        \n        # This layer output 20 x 20 x 64\n        \n        self.fc1 = nn.Linear(20*20*64, 1000)\n        self.fc2 = nn.Linear(1000, 46)\n        self.dropout = nn.Dropout(p=0.25)\n    \n    def forward(self, x):\n        \n        x = F.relu(self.conv1(x))\n        x = F.relu(self.conv2(x))\n        x = F.relu(self.conv3(x))\n        \n        x = x.view(-1, 20*20*64)\n        \n        x = self.dropout(x)\n        x = F.relu(self.fc1(x))\n        x = self.dropout(x)\n        x = self.fc2(x)\n        \n        return x","992deb81":"train_on_gpu = True if torch.cuda.is_available() else False\ntrain_on_gpu","1db8917e":"dhcd_model = Network()\n\nif train_on_gpu:\n  print(\"Training on GPU...\")\n  dhcd_model.cuda()","da349f23":"criterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(dhcd_model.parameters(), lr=0.001, momentum=0.9)","4aecba0f":"n_epochs = 55\ntrain_losses = []\nvalid_losses = []\nvalid_loss_min = np.inf\n\nfor e in range(n_epochs):\n    train_loss = 0\n    valid_loss = 0\n    \n    dhcd_model.train()\n    \n    for img, label in train_loader:\n        \n        if train_on_gpu:\n            img = img.cuda()\n            label = label.cuda()\n        \n        optimizer.zero_grad()\n        \n        predicted_label = dhcd_model(img)\n        loss = criterion(predicted_label, label)\n        loss.backward()\n        optimizer.step()\n        train_loss = train_loss + loss.item()\n    \n    dhcd_model.eval()\n    \n    for img, label in valid_loader:\n        \n        if train_on_gpu:\n            img = img.cuda()\n            label = label.cuda()\n        predicted_label = dhcd_model(img)\n        loss = criterion(predicted_label, label)\n        \n        valid_loss = valid_loss + loss.item()\n    \n    train_loss = train_loss\/len(train_loader)\n    train_losses.append(train_loss)\n    valid_loss = valid_loss\/len(valid_loader)\n    valid_losses.append(valid_loss)\n    \n    print(\"Epoch: {} Train Loss: {} Valid Loss: {}\".format(e+1, train_loss, valid_loss))\n    \n    if valid_loss < valid_loss_min:\n        print(\"Validation Loss Decreased From {} to {}\".format(valid_loss_min, valid_loss))\n        valid_loss_min = valid_loss\n        torch.save(dhcd_model.state_dict(), \"dhcd_model_8_March_2020.pth\")\n        print(\"Saving Best Model\")\n    \n        ","bbc7b067":"# torch.save(dhcd_model.state_dict(), \"\/content\/drive\/MyDrive\/Colab Notebooks\/hindisme\/model_98.pt\")\n\n# dhcd_model.load_state_dict(torch.load(\"dhcd_model_8_March_2020.pth\"))\n\n# torch.save(dhcd_model.state_dict(), \"\/content\/drive\/MyDrive\/Colab Notebooks\/hindisme\/model_best84.pt\")","70043a6c":"n_epochs = 50\navg_accuracy = 0\ntotal_accuracy = 0\ntest_loss = 0\naccuracy = 0\ndhcd_model.eval()\n\nfor epoch in range(n_epochs):\n    \n    for img, label in test_loader:\n        if train_on_gpu:\n            img = img.cuda()\n            label = label.cuda()\n        predicted_label = dhcd_model(img)\n        loss = criterion(predicted_label, label)\n        test_loss = test_loss + loss.item()\n\n        top_probab, top_label = predicted_label.topk(1, dim=1)\n        equals = top_label == label.view(*top_label.shape)\n        accuracy = accuracy + torch.mean(equals.type(torch.FloatTensor))\n\n    test_loss = test_loss\/len(test_loader)\n    accuracy = accuracy\/len(test_loader)\n    total_accuracy = total_accuracy + accuracy\n\n    print(\"Epoch: {} Test Loss: {} Accuracy: {}\".format(epoch+1, test_loss, accuracy))\n\navg_accuracy = total_accuracy\/(n_epochs) * 100\nprint(\"______________________\\nAverage Accuracy: {:.3f}%\\n______________________\".format(avg_accuracy))","9c1edf87":"fig, axes = plt.subplots(nrows=1, ncols=1)\naxes.plot(train_losses, label=\"Training\")\naxes.plot(valid_losses, label=\"Validating\")\naxes.legend(frameon=False)","8b86d653":"print('train : ')\nprint(train_losses)\nprint('val : ')\nprint(valid_losses)","6aaa63c7":"# obtain one batch of test images\ndataiter = iter(test_loader)\nimages, labels = dataiter.next()\nimages.numpy()\n\n# move model inputs to cuda, if GPU available\nif train_on_gpu:\n    images = images.cuda()\n\n# get sample outputs\noutput = dhcd_model(images)\n# convert output probabilities to predicted class\n_, preds_tensor = torch.max(output, 1)\npreds = np.squeeze( \n    preds_tensor.numpy()) if not train_on_gpu else np.squeeze(\n         preds_tensor.cpu().numpy())\n\n\n\n# plot the images in the batch, along with predicted and true labels\nfig = plt.figure(figsize=(25, 4))\nfor idx in np.arange(16):\n    ax = fig.add_subplot(2, 20\/2, idx+1, xticks=[], yticks=[])\n    img = images.cpu()[idx]\n    img = img * 0.5 + 0.5\n    img = np.transpose(img, (1, 2, 0))\n    plt.imshow(img)\n    ax.set_title(\"{} ({})\".format(train_data.classes[preds[idx].item()], \n                train_data.classes[labels[idx].item()]),\n                 color=(\"green\" if preds[idx]==labels[idx].item() else \"red\")) ","f0271ae7":"# obtain one batch of test images\ndataiter = iter(test_loader)\nimages, labels = dataiter.next()\nimages.numpy()\n\n# move model inputs to cuda, if GPU available\nimages = images.cuda()\n\n# get sample outputs\noutput = dhcd_model(images)\n# convert output probabilities to predicted class\n_, preds_tensor = torch.max(output, 1)\n# preds = np.squeeze(preds_tensor.numpy()) if not train_on_gpu else np.squeeze(preds_tensor.cpu().detach().numpy())\npreds = preds_tensor.cpu().detach().numpy()\n\npreds","25eaee9e":"yes = 0\nno = 0\nfor i in range(len(preds)):\n    print(classes[preds[i]], classes[labels[i]])\n    if (classes[preds[i]] == classes[labels[i]]):\n        yes+=1\n    else:\n        no+=1\n\nprint(yes,no)","be50386c":"# torch.save(dhcd_model.state_dict(), \"\/content\/drive\/MyDrive\/Colab Notebooks\/hindisme\/model_best84.pt\")\ndhcd_model.load_state_dict(torch.load(\"\/content\/drive\/MyDrive\/Colab Notebooks\/hindisme\/model_best84.pt\"))","81fc5cf3":"dataiter = iter(test_loader)\nimages, labels = dataiter.next()\nimages.numpy()\n\n# move model inputs to cuda, if GPU available\nif train_on_gpu:\n    images = images.cuda()\n\nimages[0].shape","91932beb":"pth = '\/content\/drive\/MyDrive\/Colab Notebooks\/hindisme\/DevanagariHandwrittenCharacterDataset\/Test\/character_14_dhaa\/10721.png'\npth = '\/content\/drive\/MyDrive\/Colab Notebooks\/hindisme\/017_07.jpg'\npth = '\/content\/drive\/MyDrive\/Colab Notebooks\/hindisme\/DevanagariHandwrittenCharacterDataset\/Test\/digit_4\/103744.png'\nfrom PIL import Image\n\ndef pil_loader(pth):\n    with open(pth, 'rb') as f:\n    with Image.open(f) as img:\n    return img.convert('RGB')\n\nimg = pil_loader(pth)\nimg","c31cad1e":"tfms =  transforms.Compose([\n        transforms.Scale((32,32)),\n        transforms.ToTensor(),\n        transforms.Normalize((0.5,), (0.5))])","f1afab5b":"transform = transforms.Compose([transforms.ToTensor()])","dc2d54f8":"img_tensor = tfms(img).to('cuda').unsqueeze(0)\n\nimg_tensor[0].shape","9b99c1a7":"if train_on_gpu:\n    img_tensor = img_tensor.cuda()\n\n# get sample outputs\noutput = dhcd_model(img_tensor)\n# convert output probabilities to predicted class\n_, preds_tensor = torch.max(output, 1)\npreds = np.squeeze(preds_tensor.numpy()) if not train_on_gpu else np.squeeze(preds_tensor.cpu().numpy())","4ec43ff2":"test_data.classes","9bab76df":"test_data.classes[preds_tensor[0]]","4cee7f0e":"## NEW","b6eff8be":"## The link to 97% acc. CNN model notebook : [Here](https:\/\/colab.research.google.com\/drive\/1ZH2oUtcQbWjEHepbkOfbl5ueSEQ4mz95?usp=sharing)","fb926d06":"# CNN"}}