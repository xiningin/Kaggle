{"cell_type":{"597f62b8":"code","3c6b1b8c":"code","a5b663a5":"code","b456fc74":"code","27467f29":"code","4a42f5c5":"code","4ef969fc":"code","b3f65343":"code","809a4b0b":"code","39e6d3e4":"code","66896d2e":"code","a13c3064":"code","3356e489":"code","c9376850":"code","6cd1d99f":"code","87c25a47":"code","ab07d560":"code","c31bd87a":"code","03933e59":"code","7682b1d2":"code","23694a29":"code","d412f4db":"code","e7cf6bad":"code","5395775e":"code","5448f9f3":"code","2f755e4c":"code","cd7e5815":"code","ae7f010f":"code","2cfe0f60":"code","754b09b0":"code","9a56d4e4":"code","556cd391":"code","0913e697":"code","0008567b":"code","7fea82d3":"code","2877f7b5":"code","2bdbf6f3":"code","0d870ac7":"code","2dcdb3ca":"code","bd854b77":"code","00b64236":"code","08640a87":"code","e5252cbc":"code","883aa8e6":"code","bca7ed06":"code","6389ee70":"code","07cc29a0":"code","32c08b4c":"code","de86011e":"code","593eb356":"code","5a747eff":"code","65b0ebaf":"code","7760cb52":"code","5507e9e0":"markdown","35c49610":"markdown","2b897b38":"markdown","27891ef6":"markdown","d3eb9154":"markdown","984f8556":"markdown","07dcdf7c":"markdown","73cec418":"markdown","5d20eaa9":"markdown","ffce8fe3":"markdown","a52cea72":"markdown","32a9ebbc":"markdown","79ed5c40":"markdown","465d7425":"markdown","794919a8":"markdown","3f8428c9":"markdown","1e93750f":"markdown","5ed30d96":"markdown","0452f300":"markdown","95f84a74":"markdown","083c12f9":"markdown","b4121d79":"markdown","8a82947a":"markdown","b3c696b8":"markdown","d53deaa4":"markdown","3a2a37d8":"markdown","8fb247fe":"markdown","242010fe":"markdown","c73f6327":"markdown","822ff685":"markdown","7e97abf0":"markdown","4e871569":"markdown","305d134c":"markdown"},"source":{"597f62b8":"import pandas as pd   #importing all the important packages\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.style.use('fivethirtyeight')","3c6b1b8c":"import os\nprint(os.listdir(\"..\/input\/\"))","a5b663a5":"\ndf =  pd.read_csv(\"..\/input\/Pokemon.csv\")  #read the csv file and save it into a variable","b456fc74":"df.head() # print the 5 first rows","27467f29":"df.columns # get all the columns","4a42f5c5":"df[[\"Name\",\"Type 1\"]] # get spesific columns","4ef969fc":"df = df.set_index('Name') #change and set the index to the name attribute","b3f65343":"df.head()","809a4b0b":"df=df.drop(['#'],axis=1) #remove the # column\ndf.head()","39e6d3e4":"df[df.index.str.contains(\"Mega\")]","66896d2e":"df.index.str.contains(\"Mega\")","a13c3064":"df[df.index.str.contains(\"Mega\")].head()","3356e489":"## The index of Mega Pokemons contained extra and unneeded text. Removed all the text before \"Mega\"  \ndf.index = df.index.str.replace(\".*(?=Mega)\", \"\")\ndf.head(10)","c9376850":"df[df.index.str.contains(\"Mega\")].head()","6cd1d99f":"df.columns = df.columns.str.upper().str.replace('_', '') #change into upper case\ndf.head()","87c25a47":"df[df['LEGENDARY']==True].head(20)  #Showing the legendary pokemons","ab07d560":"print('The columns of the dataset are: ',df.columns) #show the dataframe columns\nprint('The shape of the dataframe is: ',df.shape)    #shape of the dataframe","c31bd87a":"#some values in TYPE2 are empty and thus they have to be filled or deleted\ndf['TYPE 2'].fillna(df['TYPE 1'], inplace=True) #fill NaN values in Type2 with corresponding values of Type\ndf.head(100)","03933e59":"df.loc['Bulbasaur'] #retrieves complete row data from index with value Bulbasaur","7682b1d2":"df.iloc[0] #retrieves complete row date from index 0 ; integer version of loc","23694a29":"df.ix[0] #similar to iloc","d412f4db":"df.ix['Kakuna'] #similar to loc","e7cf6bad":"#filtering pokemons using logical operators\ndf[((df['TYPE 1']=='Fire') | (df['TYPE 1']=='Dragon')) & ((df['TYPE 2']=='Dragon') | (df['TYPE 2']=='Fire'))].head(3)","5395775e":"print(\"MAx HP:\",df['HP'].idxmax())  #returns the pokemon with highest HP\nprint(\"Max DEFENCE:\",(df['DEFENSE']).idxmax()) #similar to argmax()","5448f9f3":"df.sort_values('TOTAL',ascending=False).head(3)  #this arranges the pokemons in the descendng order of the Totals.\n#sort_values() is used for sorting and ascending=False is making it in descending order","2f755e4c":"print('The unique  pokemon types are',df['TYPE 1'].unique()) #shows all the unique types in column\nprint('The number of unique types are',df['TYPE 1'].nunique()) #shows count of unique values ","cd7e5815":"print(df['TYPE 1'].value_counts(), '\\n' ,df['TYPE 2'].value_counts())#count different types of pokemons","ae7f010f":"df.groupby(['TYPE 1']).size()  #same as above","2cfe0f60":"(df['TYPE 1']=='Bug').sum() #counts for a single value","754b09b0":"df_summary = df.describe() #summary of the pokemon dataframe\ndf_summary","9a56d4e4":"df[\"LEGENDARY\"] == True # the condition","556cd391":"df[df[\"LEGENDARY\"] == True].head()","0913e697":"df.loc[df[\"LEGENDARY\"] == True,\"SPEED\"].head()","0008567b":"df.loc[df[\"LEGENDARY\"] == True,\"SPEED\"] += 10","7fea82d3":"df.describe()","2877f7b5":"df.loc[df[\"LEGENDARY\"] == True,\"SPEED\"] -= 10","2bdbf6f3":"df[\"GENERATION\"].value_counts().sort_index().plot.bar()","0d870ac7":"df[\"TYPE 1\"].value_counts().plot.barh()","2dcdb3ca":"df.hist(column='ATTACK')","bd854b77":"fire=df[(df['TYPE 1']=='Fire') | ((df['TYPE 2'])==\"Fire\")] #fire contains all fire pokemons\nwater=df[(df['TYPE 1']=='Water') | ((df['TYPE 2'])==\"Water\")]  #all water pokemins\nax = fire.plot.scatter(x='ATTACK', y='DEFENSE', color='Red', label='Fire')\nwater.plot.scatter(x='ATTACK', y='DEFENSE', color='Blue', label='Water', ax=ax);","00b64236":"strong=df.sort_values(by='TOTAL', ascending=False) #sorting the rows in descending order\nstrong.drop_duplicates(subset=['TYPE 1'],keep='first') #since the rows are now sorted in descending oredr\n#thus we take the first row for every new type of pokemon i.e the table will check TYPE 1 of every pokemon\n#The first pokemon of that type is the strongest for that type\n#so we just keep the first row","08640a87":"df['TYPE 1'].value_counts().plot.pie()","e5252cbc":"df2=df.drop(['GENERATION','TOTAL'],axis=1)\nsns.boxplot(data=df2)\nplt.ylim(0,300)  #change the scale of y axix\nplt.show()","883aa8e6":"plt.subplots(figsize = (15,5))\nplt.title('Attack by Type1')\nsns.boxplot(x = \"TYPE 1\", y = \"ATTACK\",data = df)\nplt.ylim(0,200)\nplt.show()","bca7ed06":"plt.subplots(figsize = (15,5))\nplt.title('Attack by Type2')\nsns.boxplot(x = \"TYPE 2\", y = \"ATTACK\",data=df)\nplt.show()","6389ee70":"plt.subplots(figsize = (15,5))\nplt.title('Defence by Type')\nsns.boxplot(x = \"TYPE 1\", y = \"DEFENSE\",data = df)\nplt.show()","07cc29a0":"plt.subplots(figsize = (20,10))\nplt.title('Attack by Type1')\nsns.violinplot(x = \"TYPE 1\", y = \"ATTACK\",data = df)\nplt.ylim(0,200)\nplt.show()","32c08b4c":"plt.subplots(figsize = (20,10))\nplt.title('Attack by Type1')\nsns.violinplot(x = \"TYPE 1\", y = \"DEFENSE\",data = df)\nplt.ylim(0,200)\nplt.show()","de86011e":"plt.subplots(figsize = (15,5))\nplt.title('Strongest Genaration')\nsns.violinplot(x = \"GENERATION\", y = \"TOTAL\",data = df)\nplt.show()","593eb356":"plt.figure(figsize=(12,6))\ntop_types=df['TYPE 1'].value_counts()[:10] #take the top 10 Types\ndf1=df[df['TYPE 1'].isin(top_types.index)] #take the pokemons of the type with highest numbers, top 10\nsns.swarmplot(x='TYPE 1',y='TOTAL',data=df1,hue='LEGENDARY') # this plot shows the points belonging to individual pokemons\n# It is distributed by Type\nplt.axhline(df1['TOTAL'].mean(),color='red',linestyle='dashed')\nplt.show()","5a747eff":"plt.figure(figsize=(10,6)) #manage the size of the plot\nsns.heatmap(df.corr(),annot=True) #df.corr() makes a correlation matrix and sns.heatmap is used to show the correlations heatmap\nplt.show()","65b0ebaf":"a=df.groupby(['GENERATION','TYPE 1']).count().reset_index()\na=a[['GENERATION','TYPE 1','TOTAL']]\na=a.pivot('GENERATION','TYPE 1','TOTAL')\na[['Water','Fire','Grass','Dragon','Normal','Rock','Flying','Electric']].plot(color=['b','r','g','#FFA500','brown','#6666ff','#001012','y'],marker='o')\nfig=plt.gcf()\nfig.set_size_inches(12,6)\nplt.show()","7760cb52":"a=df.groupby(['GENERATION','TYPE 2']).count().reset_index()\na=a[['GENERATION','TYPE 2','TOTAL']]\na=a.pivot('GENERATION','TYPE 2','TOTAL')\na[['Water','Fire','Grass','Dragon','Normal','Rock','Flying','Electric']].plot(color=['b','r','g','#FFA500','brown','#6666ff','#001012','y'],marker='o')\nfig=plt.gcf()\nfig.set_size_inches(12,6)\nplt.show()","5507e9e0":"Lets see how we change values in a column, based on condition:\n\nWe will add 10 to speed to all Legedary Pokrmons.","35c49610":"lets get all the names that contain Mega in their name","2b897b38":"## All stats analysis of the pokemons","27891ef6":"This shows that steel type pokemons have the highest defence but normal type pokemons have the lowest defence","d3eb9154":"We can see that water pokemons had the highest numbers in the 1st Generation. However the number has decreased with passing generations. Similarly Grass type pokemons showed an increase in their numbers till generation 5.","984f8556":"A bar chart of the number of pokemons from each generation","07dcdf7c":"### Strongest Pokemons By Types","73cec418":"What the violinplot actually does is it plots according to the density of a region. This means that the parts of the plot where the width is thicker denotes a region with higher density points whereas regions with thinner area show less densely populated points.","5d20eaa9":"From the heatmap it can be seen that there is not much correlation between the attributes of the pokemons. The highest we can see is the correlation between Sp.Atk and the Total ","ffce8fe3":"### Finding any Correlation between the attributes","a52cea72":" Legendary Pokemons are mostly taking the top spots in the Strongest Pokemons\n","32a9ebbc":"##### The attack distribution for the pokemons across all the genarations","79ed5c40":"Lets get all the values with mega in thier name again to see if it worked","465d7425":"# The following part is more advanced you can stop here","794919a8":"## POKEMON STATS ANALYSIS","3f8428c9":"Above is a Histogram showing the distribution of attacks for the Pokemons. The average value is between 75-77","1e93750f":"Lets understand what happand:\nThe following line give as array with boolean variables,it tells as if the string in the given place fulfill the condition.","5ed30d96":"### CLEANING THE DATAFRAME","0452f300":"### Type 1","95f84a74":"A horizontal bar chart of the number of pokemons for each type 1","083c12f9":"#### This shows that the Dragon type pokemons have an edge over the other types as they have a higher attacks compared to the other types. Also since the fire pokemons have lower range of values, but higher attacks, they can be preferred over the grass and water types for attacking.\n","b4121d79":"This shows that fire type pokemons have a better attack than water type pokemons but have a lower defence than water type.","8a82947a":"### Fire Vs Water","b3c696b8":"This graph shows that the number of Type2 Grass Pokemons has been steadily increasing. The same is the case for the Dragon Type Pokemons. For other Types the trends are somewhat uneven.","d53deaa4":"## Distribution of various pokemon types","3a2a37d8":"loc works on labels in the index.\n\niloc works on the positions in the index (so it only takes integers).\n\nix usually tries to behave like loc but falls back to behaving like iloc if the label is not in the index.\n\ninoreder to find details about any pokemon, just specify its name","8fb247fe":"## VISUALISATIONS","242010fe":"When putting it in the '[]' it will return us only the places where there is an True in the given array","c73f6327":"### Number of Pokemons by Type And Generation","822ff685":"Lets revers the changes","7e97abf0":"This shows that generation 3  has the better pokemons","4e871569":"### Now lets see the same stats in violinplot","305d134c":"### Strong Pokemons By Type"}}