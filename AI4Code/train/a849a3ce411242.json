{"cell_type":{"da52207d":"code","07f8e148":"code","b8573a59":"code","6f4e55de":"code","95cd4e1e":"code","24ad9c08":"code","13284db4":"code","db543261":"markdown","9f8e23dc":"markdown","a114a2a4":"markdown","a4b0e9dd":"markdown","4c7654f7":"markdown","96649e11":"markdown","5881a87a":"markdown","525fdc19":"markdown","e4eb8d23":"markdown","09f31501":"markdown"},"source":{"da52207d":"# We started with the following:\n# https:\/\/www.kaggle.com\/dmilla\/introduction-to-decision-trees-titanic-dataset\n#\n# Imports needed for the script\nimport numpy as np\nimport pandas as pd\nimport re\nimport xgboost as xgb\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls\n\nfrom sklearn import tree\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom IPython.display import Image as PImage\nfrom subprocess import check_call\nfrom PIL import Image, ImageDraw, ImageFont\n\n# Loading the data into train and test dataframes\ntrain = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')\n\n# Store our test passenger IDs for easy access\nPassengerId = test['PassengerId']\n\n# Showing overview of the train dataset\ntrain.head(5)","07f8e148":"# Copy original dataset in case we need it later when digging into interesting features\n# WARNING: Beware of actually copying the dataframe instead of just referencing it\n# \"original_train = train\" will create a reference to the train variable (changes in 'train' will apply to 'original_train')\noriginal_train = train.copy() # Using 'copy()' allows to clone the dataset, creating a different object with the same values\n\n# Feature engineering steps taken from Sina and Anisotropic, with minor changes to avoid warnings\nfull_data = [train, test]\n\n# Feature that tells whether a passenger had a cabin on the Titanic\ntrain['Has_Cabin'] = train[\"Cabin\"].apply(lambda x: 0 if type(x) == float else 1)\ntest['Has_Cabin'] = test[\"Cabin\"].apply(lambda x: 0 if type(x) == float else 1)\n\n# Create new feature FamilySize as a combination of SibSp and Parch\nfor dataset in full_data:\n    dataset['FamilySize'] = dataset['SibSp'] + dataset['Parch'] + 1\n\n# Remove all NULLS in the Embarked column\nfor dataset in full_data:\n    dataset['Embarked'] = dataset['Embarked'].fillna('S')\n# Remove all NULLS in the Fare column\nfor dataset in full_data:\n    dataset['Fare'] = dataset['Fare'].fillna(train['Fare'].median())\n\n# Remove all NULLS in the Age column\nfor dataset in full_data:\n    dataset['Age'] = dataset['Age'].fillna(train['Age'].median())\n    dataset['Age'] = dataset['Age'].astype(int)\n\n# Define function to extract titles from passenger names\n# This is used to convert titles to integers later. This is the only\n# information we get from the names of the passengers.\n# Code from https:\/\/www.kaggle.com\/dmilla\/introduction-to-decision-trees-titanic-dataset\ndef get_title(name):\n    title_search = re.search(' ([A-Za-z]+)\\.', name)\n    # If the title exists, extract and return it.\n    if title_search:\n        return title_search.group(1)\n    return \"\"\n\nfor dataset in full_data:\n    dataset['Title'] = dataset['Name'].apply(get_title)\n# Group all non-common titles into one single grouping \"Rare\"\nfor dataset in full_data:\n    dataset['Title'] = dataset['Title'].replace(['Lady', 'Countess','Capt', 'Col','Don', 'Dr', 'Major', 'Rev', 'Sir', 'Jonkheer', 'Dona'], 'Rare')\n\n    dataset['Title'] = dataset['Title'].replace('Mlle', 'Miss')\n    dataset['Title'] = dataset['Title'].replace('Ms', 'Miss')\n    dataset['Title'] = dataset['Title'].replace('Mme', 'Mrs')\n\nfor dataset in full_data:\n    # Mapping Sex\n    dataset['Sex'] = dataset['Sex'].map( {'female': 0, 'male': 1} ).astype(int)\n    \n    # Mapping titles\n    title_mapping = {\"Mr\": 1, \"Master\": 2, \"Mrs\": 3, \"Miss\": 4, \"Rare\": 5}\n    dataset['Title'] = dataset['Title'].map(title_mapping)\n    dataset['Title'] = dataset['Title'].fillna(0)\n\n    # Mapping Embarked\n    dataset['Embarked'] = dataset['Embarked'].map( {'S': 0, 'C': 1, 'Q': 2} ).astype(int)\n    \n","b8573a59":"# Feature selection: remove variables no longer containing relevant information\ndrop_elements = ['PassengerId', 'Name', 'Ticket', 'Cabin', 'SibSp']\ntrain = train.drop(drop_elements, axis = 1)\ntest  = test.drop(drop_elements, axis = 1)","6f4e55de":"train.head(3)","95cd4e1e":"cv = KFold(n_splits=10)            # Desired number of Cross Validation folds\naccuracies = list()\nmax_attributes = len(list(test))\ndepth_range = range(1, max_attributes + 1)\n\n# Testing max_depths from 1 to max attributes\n# Uncomment prints for details about each Cross Validation pass\nfor depth in depth_range:\n    fold_accuracy = []\n    tree_model = tree.DecisionTreeClassifier(max_depth = depth)\n    # print(\"Current max depth: \", depth, \"\\n\")\n    for train_fold, valid_fold in cv.split(train):\n        f_train = train.loc[train_fold] # Extract train data with cv indices\n        f_valid = train.loc[valid_fold] # Extract valid data with cv indices\n\n        model = tree_model.fit(X = f_train.drop(['Survived'], axis=1), \n                               y = f_train[\"Survived\"]) # We fit the model with the fold train data\n        valid_acc = model.score(X = f_valid.drop(['Survived'], axis=1), \n                                y = f_valid[\"Survived\"])# We calculate accuracy with the fold validation data\n        fold_accuracy.append(valid_acc)\n\n    avg = sum(fold_accuracy)\/len(fold_accuracy)\n    accuracies.append(avg)\n    # print(\"Accuracy per fold: \", fold_accuracy, \"\\n\")\n    # print(\"Average accuracy: \", avg)\n    # print(\"\\n\")\n    \n# Just to show results conveniently\ndf = pd.DataFrame({\"Max Depth\": depth_range, \"Average Accuracy\": accuracies})\ndf = df[[\"Max Depth\", \"Average Accuracy\"]]\nprint(df.to_string(index=False))","24ad9c08":"# Create Numpy arrays of train, test and target (Survived) dataframes to feed into our models\ny_train = train['Survived']\nx_train = train.drop(['Survived'], axis=1).values \nx_test = test.values\n\n# Create Decision Tree with max_depth = 4\ndecision_tree = tree.DecisionTreeClassifier(max_depth = 4)\ndecision_tree.fit(x_train, y_train)\n\n# Predicting results for test dataset\ny_pred = decision_tree.predict(x_test)\nsubmission = pd.DataFrame({\n        \"PassengerId\": PassengerId,\n        \"Survived\": y_pred\n    })\nsubmission.to_csv('submission.csv', index=False)\n\n# Export our trained model as a .dot file\nwith open(\"tree1.dot\", 'w') as f:\n     f = tree.export_graphviz(decision_tree,\n                              out_file=f,\n                              max_depth = 4,\n                              impurity = True,\n                              feature_names = list(train.drop(['Survived'], axis=1)),\n                              class_names = ['Died', 'Survived'],\n                              rounded = True,\n                              filled= True )\n        \n#Convert .dot to .png to allow display in web notebook\ncheck_call(['dot','-Tpng','tree1.dot','-o','tree1.png'])\n\n# Annotating chart with PIL\nimg = Image.open(\"tree1.png\")\ndraw = ImageDraw.Draw(img)\n#font = ImageFont.truetype('\/usr\/share\/fonts\/truetype\/liberation\/LiberationSerif-Bold.ttf', 26)\ndraw.text((10, 0), # Drawing offset (position)\n          '\"Title <= 1.5\" corresponds to \"Mr.\" title', # Text to draw\n          (0,0,255))\n#          (0,0,255), # RGB desired color\n#          font=font) # ImageFont object with desired font\nimg.save('sample-out.png')\nPImage(\"sample-out.png\")\n\n# Code to check available fonts and respective paths\n# import matplotlib.font_manager\n# matplotlib.font_manager.findSystemFonts(fontpaths=None, fontext='ttf')","13284db4":"acc_decision_tree = round(decision_tree.score(x_train, y_train) * 100, 2)\nacc_decision_tree","db543261":"## Visualising processed data ##","9f8e23dc":"The best *max_depth* parameter seems therefore to be 4 (83.2% average accuracy across the 10 folds), and feeding the model with more data results in worst results probably due to over-fitting. We'll therefore use 4 as the *max_depth* parameter for our final model.","a114a2a4":"Finally, here we have our *Decision Tree*! It achieves an accuracy of 82.38% across the training dataset. Let's begin explaining how to read the graph.\n\nThe first line of each node (except those of the final row) shows the splitting condition in the form \"*feature* <= *value*\".\n\nNext, we find the Gini Impurity of the node, already explained in this kernel. \"Samples\" is simply the number of observations contained in the node.\n\n\"Value\" shows the class distribution of the samples ([count non_survived, count survived]).\n\nLastly, \"class\" correspond to the predominant class of each node, and this is how our model will classify an observation. The colour also represents the class, the opacity increasing with the actual distribution of samples.\n\nOur model can therefore be summarised with 4 simple rules:\n\n - If our observation includes de \"Mr\" *Title*, then we classify it as not survived (all the branches in the left side of the tree lead to an orange node)\n - If it doesn't include \"Mr\" *Title*, and *FamilySize* is 4 or less, then we classify it as survived.\n - If it doesn't include \"Mr\" *Title*,  *FamilySize* is  more than 4 and *Pclass* is 2 or less, then we classify it as survived.\n - If it doesn't include \"Mr\" *Title*,  *FamilySize* is  more than 4 and *Pclass* is more than 2, then we classify it as not survived.\n","a4b0e9dd":"Thanks to this overview we can see that our dataset needs some treatment. The class *Survived* is already in binary format so no additional formatting is necessary, but features like *Name*, *Ticket* or *Cabin* need to be adapted for the problem we're trying to solve, and we can also engineer some new features by merging or regrouping existing ones. There's already extended work on this so we're just using one the best approches out there (credit to [Sina][1], [Anisotropic][2] and also [Megan Risdal][3] for the suggestion of the \"Title\" feature).\n\n\n  [1]: https:\/\/www.kaggle.com\/sinakhorami\/titanic\/titanic-best-working-classifier\n  [2]: https:\/\/www.kaggle.com\/arthurtok\/titanic\/introduction-to-ensembling-stacking-in-python\n  [3]: https:\/\/www.kaggle.com\/mrisdal\/titanic\/exploring-survival-on-the-titanic","4c7654f7":"## Final Tree ##","96649e11":"## Abstract ##\n\nIn this Kernel we're going to take a look at [*Decision Trees*][1] using *Python* and the Titanic dataset. It's not intended to be the most accurate Titanic survival model out there, but to explain how to create, visualise and understand *Classification Trees*. The main aspects covered are:\n\n - Learning from the data with *Decision Trees*\n - Dataset exploration and processing\n - Relevant features for *Decision Trees*\n - Gini Impurity\n - Finding best tree depth with the help of cross-validation\n - Generating and visualising the final model\n\nThis is my first Kernel, so please feel free to include any suggestions, comments or critics!\n\n[1]: https:\/\/en.wikipedia.org\/wiki\/Decision_tree_learning","5881a87a":"## Finding best tree depth with the help of Cross Validation ##\n\nAfter exploring the data, we're going to find of much of it can be relevant for our decision tree. This is a critical point for every Data Science project, since too much train data can easily result in bad model generalisation (accuracy on test\/real\/unseen observations). Over-fitting (a model excessively adapted to the train data) is a common reason. In other cases, too much data can also hide meaningful relationships either because they evolve with time or because highly correlated features prevent the model from capturing properly the value of each single one.\n\nIn the case of decision trees, the 'max_depth' parameter determines the maximum number of attributes the model is going to use for each prediction (up to the number of available features in the dataset).  A good way to find the best value for this parameter is just iterating through all the possible depths and measure the accuracy with a robust method such as [Cross Validation][1].\n\n*Cross Validation* is a model validation technique that splits the training dataset in a given number of \"folds\". Each split uses different data for training and testing purposes, allowing the model to be trained and tested with different data each time. This allows the algorithm to be trained and tested with all available data across all folds, avoiding any splitting bias and giving a good idea of the generalisation of the chosen model. The main downside is that *Cross Validation* requires the model to be trained for each fold, so the computational cost can be very high for complex models or huge datasets.\n\n\n  [1]: https:\/\/en.wikipedia.org\/wiki\/Cross-validation_(statistics)","525fdc19":"Thanks to these rules we can infer some insights about the shipwreck. \"Misters\" seem to have honoured their title and sacrificed themselves in favour on women and men with more exotic titles like \"Master\" or \"Dr\".  We can also note that smaller families had better chances to survive, maybe because bigger families tried to stick together or look for missing members and therefore didn't had places left in the lifeboats. Finally, we can observe that 3rd class passengers had also less chances to survive so probably passengers belonging to upper social social classes were privileged, or simply 3rd class cabins may have been further away of the lifeboats.\n\nOur submission to the Titanic competition results in scoring 2234 out of 5672 competition entries. This result only accounts for part of the submission dataset and is indicative while the competition is running. Not bad for a simple *Decision Tree*!\n\nAnd remember, any suggestions, comments or critics are welcome!\n\nThanks for reading,\n\nDiego","e4eb8d23":"Introduction\n--------------------\n\nWhen applying Machine Learning algorithms, it's critical to always keep in mind the problem we're trying to solve. In most cases, the most accurate and robust model might be what you're looking for. But sometimes we need to actually get insights from the available data and in these cases transparent, easy to understand models like *Decision Trees* will greatly simplify our task.\n\nIf we need to build a model that will be directly used for some task and **only show it's end results**, then we don't really care about building some kind of \"blackbox\" if it's accurate enough (image or speech recognition for example). That's why advanced techniques such as [*Deep Learning*][1] or [*Ensemble Learning*][2]  (cf. [Anisotropic Kernel][3]) are commonly used for complex tasks. But remember the KISS principle (Keep It Simple, Stupid)! Always consider the complexity\/accuracy trade-off: complex techniques should only be used if they offer significant improvements. Simpler models are also less prone to over-fitting and tend to generalise better.\n\nBut if we're using Machine Learning to actually **get insights from the data**, \"blackbox\" models are almost useless and it's best to stick with simpler, transparent techniques. Let's take the case of a supermarket looking to better understand customer behaviour: the straightforward [*Apriori*][4] algorithm can quickly offer relevant insights like \"80% of customers who bought a suit also bought a tie\" so they may try to increase tie sales by offering a discount to clients buying a suit . Of course, a complex classification algorithm will do better at identifying the customers who bought a tie by taking into account more features, but is that really useful for the supermarket?\n\n*Decision Trees* can also help a lot when we need to understanding the data. A good example is the traditional problem of classifying Iris flowers included in the [sklearn documentation][5], were we can learn about the characteristics of each flower type in the resulting tree. Given their transparency and relatively low computational cost, *Decision Trees* are also very useful for exploring your data before applying other algorithms. They're helpful for checking the quality of engineered features and identifying the most relevant ones by visualising the resulting tree.\n\nThe main downsides of *Decision Trees* are their tendency to over-fit, their inability to grasp relationships between features, and the use of greedy learning algorithms (not guaranteed to find the global optimal model). Using them in a [*Random Forest*][6] helps mitigate some of this issues.\n\nAfter this short introduction to *Decision Trees* and their place in Machine Learning, let's see how to apply them for the Titanic challenge. First, we're going to prepare the dataset and discuss the most relevant features. We'll then find the best tree depth to avoid over-fitting, generate the final model, and explain how to visualise the resulting tree.\n\n\n  [1]: https:\/\/en.wikipedia.org\/wiki\/Deep_learning\n  [2]: https:\/\/en.wikipedia.org\/wiki\/Ensemble_learning\n  [3]: https:\/\/www.kaggle.com\/arthurtok\/titanic\/introduction-to-ensembling-stacking-in-python\n  [4]: https:\/\/en.wikipedia.org\/wiki\/Apriori_algorithm\n  [5]: http:\/\/scikit-learn.org\/stable\/modules\/tree.html\n  [6]: https:\/\/en.wikipedia.org\/wiki\/Random_forest","09f31501":"## Preparing the Titanic dataset ##\n\nFor the Titanic challenge we need to guess wheter the individuals from the *test* dataset had survived or not. But for our current purpose let's also find out what can the data tell us about the shipwreck with the help of a *Classification Tree*. Let's load the data and get an overview."}}