{"cell_type":{"1e1b1498":"code","1f4a8e6b":"code","7a56f2e0":"code","f748f2d1":"code","0eae23c0":"code","23576681":"code","7f8a8ad1":"code","b7f2d3b0":"code","b59d9b56":"code","f1b592e0":"code","b587c113":"code","af8e87ff":"code","5230cd91":"code","9972cde0":"code","b63eb9ad":"code","577ab7af":"code","af2417b7":"code","6a1d8431":"code","eba5d519":"code","508b17e7":"code","fed254de":"code","c6c26e5a":"code","c9e74e97":"code","197e4e4f":"code","b3042ea4":"code","c1e4d6f6":"code","350840f3":"code","7ef9deca":"code","59adc681":"code","4d82652b":"code","522bf30e":"code","13551320":"code","e6b52e3f":"code","b1d8b896":"code","7eb4fb2d":"markdown","1c0ba4d2":"markdown","4058abac":"markdown","c1905a75":"markdown","ec6f836f":"markdown","226612ad":"markdown","367b5a6e":"markdown","cb6d7d19":"markdown","9df84397":"markdown","192fee38":"markdown","daf57afc":"markdown","aab655ea":"markdown","a6449d81":"markdown","858fa185":"markdown","02cbe80a":"markdown","e925ee42":"markdown","96233b57":"markdown","cbbc17a8":"markdown","c10a73d4":"markdown","e289a0b7":"markdown","c77ae84e":"markdown","1c614536":"markdown","719fcd3f":"markdown","34f5f757":"markdown","df83408e":"markdown","feeab226":"markdown","d0913070":"markdown","0c956688":"markdown","34bba18a":"markdown","4eaf373a":"markdown","89ec4d72":"markdown","f9e12955":"markdown","dd9ba8dd":"markdown","e3dbbd9f":"markdown","14c75177":"markdown","4633ae5a":"markdown","61e34f40":"markdown","13d3923d":"markdown","a9d97bea":"markdown","11b2920e":"markdown","5428c0a2":"markdown","adf4b9bc":"markdown"},"source":{"1e1b1498":"import torch\nimport numpy as np","1f4a8e6b":"data = [[1,2],[3,4]]\nx_data = torch.tensor(data)\nx_data","7a56f2e0":"np_array = np.array(data)\nx_np = torch.from_numpy(np_array)\nx_np","f748f2d1":"x_ones = torch.ones_like(x_data)\ntry:\n    x_rand = torch.rand_like(x_data)\nexcept Exception as e:\n    print(e)\n    \nx_rand = torch.rand_like(x_data, dtype=torch.float)\nx_ones, x_rand","0eae23c0":"shape = (2,3,)\nrand_tensor = torch.rand(shape)\nones_tensor = torch.ones(shape)\nzeros_tensor = torch.zeros(shape)\n\nrand_tensor, ones_tensor, zeros_tensor","23576681":"tensor = torch.rand(3,4)\n\ntensor.shape, tensor.dtype, tensor.device","7f8a8ad1":"if torch.cuda.is_available():\n    tensor = tensor.to('cuda')","b7f2d3b0":"tensor = torch.ones(4,4)\nprint('before:\\n ',tensor)\ntensor[:,1] = 0\nprint('after:\\n ', tensor)","b59d9b56":"t1 = torch.cat([tensor,tensor,tensor],dim=1)\nprint(t1)","f1b592e0":"tensor.mul(tensor)","b587c113":"tensor * tensor","af8e87ff":"tensor.matmul(tensor)","5230cd91":"tensor, tensor.T","9972cde0":"tensor.matmul(tensor.T)","b63eb9ad":"tensor @ tensor.T","577ab7af":"print(tensor, \"\\n\")\ntensor.add_(5)\ntensor\n\n# tensor has changed inplace","af2417b7":"n = tensor.numpy()\nn","6a1d8431":"tensor.add_(1)\n\ntensor, n","eba5d519":"n = np.ones(5)\nt = torch.from_numpy(n)\nn,t","508b17e7":"np.add(n,1, out=n)\nt, n","fed254de":"import torch, torchvision\n\nmodel = torchvision.models.resnet18(pretrained=True)\ndata = torch.rand(1,3,64,64)\nlabels = torch.rand(1, 1000)\n\ndata.shape, labels.shape","c6c26e5a":"prediction =  model(data)\nprediction[0]","c9e74e97":"loss = (prediction - labels).sum()\nloss.backward()\n","197e4e4f":"loss","b3042ea4":"optim = torch.optim.SGD(model.parameters(), lr=1e-2, momentum=0.9)","c1e4d6f6":"optim.step()","350840f3":"a = torch.tensor([2.,3.], requires_grad=True)\nb = torch.tensor([6., 4.], requires_grad=True)","7ef9deca":"Q = 3 * a ** 3 - b ** 2","59adc681":"external_grad = torch.tensor([1.,1.])\nQ.backward(gradient=external_grad)","4d82652b":"print(9 * a ** 2 == a.grad)\nprint(-2 * b == b.grad)","522bf30e":"x = torch.rand(5,5)\ny = torch.rand(5,5)\nz = torch.rand((5,5), requires_grad=True)\n\na = x+y\nprint(a.requires_grad)\nb = x +z\n\nprint(b.requires_grad)","13551320":"from torch import nn, optim\nmodel = torchvision.models.resnet18(pretrained=True)\n\nfor param in model.parameters():\n    param.requires_grad = False\n","e6b52e3f":"model.fc = nn.Linear(512, 10)","b1d8b896":"optimizer.optim.SGD(model.fc.parameters(), lr=1e-2,momentum=0.9)","7eb4fb2d":"### Usage in PyTorch\n\nLet\u2019s take a look at a single training step. For this example, we load a pretrained resnet18 model from torchvision. We create a random data tensor to represent a single image with 3 channels, and height & width of 64, and its corresponding label initialized to some random values.","1c0ba4d2":"From a NumPy array\n\nTensors can be created from NumPy arrays (and vice versa - see Bridge with NumPy).","4058abac":"Working through the official pytorch blitz tutorial, in one notebook. https:\/\/pytorch.org\/tutorials\/beginner\/deep_learning_60min_blitz.html#deep-learning-with-pytorch-a-60-minute-blitz","c1905a75":"Gradients are now deposited in a.grad and b.grad","ec6f836f":"### Bridge with NumPy\n\nTensors on the CPU and NumPy arrays can share their underlying memory locations, and changing one will change the other.\n","226612ad":"change in tensor reflects innumpy array","367b5a6e":"We create another tensor Q from a and b.","cb6d7d19":"### Tensor Initialization\n\nTensors can be initialized in various ways. Take a look at the following examples:\n\n","9df84397":"Try out some of the operations from the list. If you\u2019re familiar with the NumPy API, you\u2019ll find the Tensor API a breeze to use.\n\nStandard numpy-like indexing and slicing:","192fee38":"numpy array to tensor","daf57afc":"## A GENTLE INTRODUCTION TO TORCH.AUTOGRAD\n\n\ntorch.autograd is PyTorch\u2019s automatic differentiation engine that powers neural network training. In this section, you will get a conceptual understanding of how autograd helps a neural network train.\n\n","aab655ea":"In a NN, parameters that don't compute gradients are usually called frozen parameters. It is useful to \"freeze\" part of your model if you know in advance that you won't need the gradients of those parameters (this offers some performance benefits by reducing autograd computations).\n\nAnother common usecase where exclusion from the DAG is important is for finetuning a pretrained network <https:\/\/pytorch.org\/tutorials\/beginner\/finetuning_torchvision_models_tutorial.html>__\n\nIn finetuning, we freeze most of the model and typically only modify the classifier layers to make predictions on new labels. Let's walk through a small example to demonstrate this. As before, we load a pretrained resnet18 model, and freeze all the parameters.","a6449d81":"Directly from data\n\nTensors can be created directly from data. The data type is automatically inferred.","858fa185":"From another tensor:\n\nThe new tensor retains the properties (shape, datatype) of the argument tensor, unless explicitly overridden.","02cbe80a":"Joining tensors\n\nYou can use torch.cat to concatenate a sequence of tensors along a given dimension. See also torch.stack, another tensor joining op that is subtly different from torch.cat.","e925ee42":"### Autograd - a closer look","96233b57":"Optional Reading - Vector Calculus using ``autograd``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nMathematically, if you have a vector valued function\n$\\vec{y}=f(\\vec{x})$, then the gradient of $\\vec{y}$ with\nrespect to $\\vec{x}$ is a Jacobian matrix $J$:\n\n\\begin{align}J\n     =\n      \\left(\\begin{array}{cc}\n      \\frac{\\partial \\bf{y}}{\\partial x_{1}} &\n      ... &\n      \\frac{\\partial \\bf{y}}{\\partial x_{n}}\n      \\end{array}\\right)\n     =\n     \\left(\\begin{array}{ccc}\n      \\frac{\\partial y_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial y_{1}}{\\partial x_{n}}\\\\\n      \\vdots & \\ddots & \\vdots\\\\\n      \\frac{\\partial y_{m}}{\\partial x_{1}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{n}}\n      \\end{array}\\right)\\end{align}\n\nGenerally speaking, ``torch.autograd`` is an engine for computing\nvector-Jacobian product. That is, given any vector $\\vec{v}$, compute the product\n$J^{T}\\cdot \\vec{v}$\n\nIf $v$ happens to be the gradient of a scalar function\n\n\\begin{align}l\n   =\n   g\\left(\\vec{y}\\right)\n   =\n   \\left(\\begin{array}{ccc}\\frac{\\partial l}{\\partial y_{1}} & \\cdots & \\frac{\\partial l}{\\partial y_{m}}\\end{array}\\right)^{T}\\end{align}\n\nthen by the chain rule, the vector-Jacobian product would be the\ngradient of $l$ with respect to $\\vec{x}$:\n\n\\begin{align}J^{T}\\cdot \\vec{v}=\\left(\\begin{array}{ccc}\n      \\frac{\\partial y_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{1}}\\\\\n      \\vdots & \\ddots & \\vdots\\\\\n      \\frac{\\partial y_{1}}{\\partial x_{n}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{n}}\n      \\end{array}\\right)\\left(\\begin{array}{c}\n      \\frac{\\partial l}{\\partial y_{1}}\\\\\n      \\vdots\\\\\n      \\frac{\\partial l}{\\partial y_{m}}\n      \\end{array}\\right)=\\left(\\begin{array}{c}\n      \\frac{\\partial l}{\\partial x_{1}}\\\\\n      \\vdots\\\\\n      \\frac{\\partial l}{\\partial x_{n}}\n      \\end{array}\\right)\\end{align}\n\nThis characteristic of vector-Jacobian product is what we use in the above example;\n``external_grad`` represents $\\vec{v}$.\n\n\n","cbbc17a8":"Exclusion from the DAG\n\n``torch.autograd`` tracks operations on all tensors which have their\n``requires_grad`` flag set to ``True``. For tensors that don\u2019t require\ngradients, setting this attribute to ``False`` excludes it from the\ngradient computation DAG.\n\nThe output tensor of an operation will require gradients even if only a\nsingle input tensor has ``requires_grad=True``.\n\n","c10a73d4":"Next, we run the input data through the model through each of its layers to make a prediction. This is the forward pas","e289a0b7":"Next, we load an optimizer, in this case SGD with a learning rate of 0.01 and momentum of 0.9. We register all the parameters of the model in the optimizer.","c77ae84e":"At this point, you have everything you need to train your neural network. The below sections detail the workings of autograd - feel free to skip them.","1c614536":"Computational Graph\n~~~~~~~~~~~~~~~~~~~\n\nConceptually, autograd keeps a record of data (tensors) & all executed\noperations (along with the resulting new tensors) in a directed acyclic\ngraph (DAG) consisting of\n`Function <https:\/\/pytorch.org\/docs\/stable\/autograd.html#torch.autograd.Function>`__\nobjects. In this DAG, leaves are the input tensors, roots are the output\ntensors. By tracing this graph from roots to leaves, you can\nautomatically compute the gradients using the chain rule.\n\nIn a forward pass, autograd does two things simultaneously:\n\n- run the requested operation to compute a resulting tensor, and\n- maintain the operation\u2019s *gradient function* in the DAG.\n\nThe backward pass kicks off when ``.backward()`` is called on the DAG\nroot. ``autograd`` then:\n\n- computes the gradients from each ``.grad_fn``,\n- accumulates them in the respective tensor\u2019s ``.grad`` attribute, and\n- using the chain rule, propagates all the way to the leaf tensors.\n\nBelow is a visual representation of the DAG in our example. In the graph,\nthe arrows are in the direction of the forward pass. The nodes represent the backward functions\nof each operation in the forward pass. The leaf nodes in blue represent our leaf tensors ``a`` and ``b``.\n\n.. figure::![](https:\/\/pytorch.org\/tutorials\/_images\/dag_autograd.png)\n\n<div class=\"alert alert-info\"><h4>Note<\/h4><p>**DAGs are dynamic in PyTorch**\n  An important thing to note is that the graph is recreated from scratch; after each\n  ``.backward()`` call, autograd starts populating a new graph. This is\n  exactly what allows you to use control flow statements in your model;\n  you can change the shape, size and operations at every iteration if\n  needed.<\/p><\/div>\n\n\n","719fcd3f":"Let's say we want to finetune the model on a new dataset with 10 labels.\nIn resnet, the classifier is the last linear layer ``model.fc``.\nWe can simply replace it with a new linear layer (unfrozen by default)\nthat acts as our classifier.\n\n","34f5f757":"Finally, we call .step() to initiate gradient descent. The optimizer adjusts each parameter by its gradient stored in .grad","df83408e":"With random or constant values:\n\nshape is a tuple of tensor dimensions. In the functions below, it determines the dimensionality of the output tensor.","feeab226":"## TENSORS\n\nTensors are a specialized data structure that are very similar to arrays and matrices. In PyTorch, we use tensors to encode the inputs and outputs of a model, as well as the model\u2019s parameters.\n\nTensors are similar to NumPy\u2019s ndarrays, except that tensors can run on GPUs or other specialized hardware to accelerate computing. If you\u2019re familiar with ndarrays, you\u2019ll be right at home with the Tensor API. If not, follow along in this quick API walkthrough.","d0913070":"Notice although we register all the parameters in the optimizer, the only parameters that are computing gradients (and hence updated in gradient descent) are the weights and bias of the classifier.\n\nThe same exclusionary functionality is available as a context manager in torch.no_grad() <https:\/\/pytorch.org\/docs\/stable\/generated\/torch.no_grad.html>__\n","0c956688":"Let's assume ``a`` and ``b`` to be parameters of an NN, and ``Q``\nto be the error. In NN training, we want gradients of the error\nw.r.t. parameters, i.e.\n\n\\begin{align}\\frac{\\partial Q}{\\partial a} = 9a^2\\end{align}\n\n\\begin{align}\\frac{\\partial Q}{\\partial b} = -2b\\end{align}\n\n\nWhen we call ``.backward()`` on ``Q``, autograd calculates these gradients\nand stores them in the respective tensors' ``.grad`` attribute.\n\nWe need to explicitly pass a ``gradient`` argument in ``Q.backward()`` because it is a vector.\n``gradient`` is a tensor of the same shape as ``Q``, and it represents the\ngradient of Q w.r.t. itself, i.e.\n\n\\begin{align}\\frac{dQ}{dQ} = 1\\end{align}\n\nEquivalently, we can also aggregate Q into a scalar and call backward implicitly, like ``Q.sum().backward()``.\n\n\n","34bba18a":"Matrix multiplicaiton","4eaf373a":"\n### Tensor Operations\n\nOver 100 tensor operations, including transposing, indexing, slicing, mathematical operations, linear algebra, random sampling, and more are comprehensively described here.\n\nEach of them can be run on the GPU (at typically higher speeds than on a CPU). If you\u2019re using Colab, allocate a GPU by going to Edit > Notebook Settings.","89ec4d72":"Now all parameters in the model, except the parameters of model.fc, are frozen. The only parameters that compute gradients are the weights and bias of model.fc.","f9e12955":"## Goal of this tutorial:\n\n1. Understand PyTorch\u2019s Tensor library and neural networks at a high level.\n2. Train a small neural network to classify images","dd9ba8dd":"Let\u2019s take a look at how autograd collects gradients. We create two tensors a and b with requires_grad=True. This signals to autograd that every operation on them should be tracked.","e3dbbd9f":"### Background\n\nNeural networks (NNs) are a collection of nested functions that are executed on some input data. These functions are defined by parameters (consisting of weights and biases), which in PyTorch are stored in tensors.\n\nTraining a NN happens in two steps:\n\nForward Propagation: In forward prop, the NN makes its best guess about the correct output. It runs the input data through each of its functions to make this guess.\n\nBackward Propagation: In backprop, the NN adjusts its parameters proportionate to the error in its guess. It does this by traversing backwards from the output, collecting the derivatives of the error with respect to the parameters of the functions (gradients), and optimizing the parameters using gradient descent. For a more detailed walkthrough of backprop, check out video from 3Blue1Brown.","14c75177":"Changes in the NumPy array reflects in the tensor.","4633ae5a":"Tensor to NumPy array","61e34f40":"Multiplying tensors","13d3923d":"# What is PyTorch?\n\nPyTorch is a Python-based scientific computing package serving two broad purposes:\n\n1. A replacement for NumPy to use the power of GPUs and other accelerators.\n2. An automatic differentiation library that is useful to implement neural networks.\n","a9d97bea":"In-place operations Operations that have a _ suffix are in-place. For example: x.copy_(y), x.t_(), will change x.","11b2920e":"### Tensor Attributes\n\nTensor attributes describe their shape, datatype, and the device on which they are stored.","5428c0a2":"We use the model\u2019s prediction and the corresponding label to calculate the error (loss). The next step is to backpropagate this error through the network. Backward propagation is kicked off when we call .backward() on the error tensor. Autograd then calculates and stores the gradients for each model parameter in the parameter\u2019s .grad attribute.","adf4b9bc":"Further readings:\n~~~~~~~~~~~~~~~~~~~\n\n-  `In-place operations & Multithreaded Autograd <https:\/\/pytorch.org\/docs\/stable\/notes\/autograd.html>`__\n-  `Example implementation of reverse-mode autodiff <https:\/\/colab.research.google.com\/drive\/1VpeE6UvEPRz9HmsHh1KS0XxXjYu533EC>`__\n\n"}}