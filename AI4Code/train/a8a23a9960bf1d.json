{"cell_type":{"23fbdc7d":"code","9fdde12d":"code","0409332b":"code","6c566953":"code","08e1dfc0":"code","f8f2e3fd":"code","1798b685":"code","a00832a7":"code","256a9e99":"code","4463264a":"code","1aace8c8":"code","d5e71697":"code","a46ff089":"code","ec6c2f64":"code","a69593b9":"markdown","c6610601":"markdown","c379bdef":"markdown","327c5e2b":"markdown","74305486":"markdown","cf043b87":"markdown","56fb9d3b":"markdown","0acd6407":"markdown","8ad31144":"markdown","4a0ecba7":"markdown","d5d50546":"markdown","fa93a5c7":"markdown","fa4029dd":"markdown","32a6c3ba":"markdown"},"source":{"23fbdc7d":"import torch\nimport torch.nn.functional as F\nfrom torch import nn, optim\nfrom torch.utils.data.sampler import SubsetRandomSampler\nfrom torchvision import transforms, models\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport os\nimport time\nimport csv","9fdde12d":"train_on_gpu = torch.cuda.is_available()","0409332b":"class MNIST(torch.utils.data.Dataset):\n    def __init__(self, data, transform=None):\n        self.data = data\n        self.transform = transform\n        \n    def __len__(self):\n        return len(self.data)\n    \n    def __getitem__(self, index):\n        item = self.data.iloc[index]\n                \n        image = item[1:].values.astype(np.uint8).reshape((28, 28))\n        label = item[0]\n        \n        if self.transform is not None:\n            image = self.transform(image)\n            \n        return image, label","6c566953":"BATCH_SIZE = 128\nVALID_SIZE = 0.15\n\ntransform = transforms.Compose([\n    transforms.ToPILImage(),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=(0.5,), std=(0.5,))\n])\ndataset = pd.read_csv('..\/input\/digit-recognizer\/train.csv')\ntrain = MNIST(dataset, transform=transform)\nvalid = MNIST(dataset, transform=transform)\n\nnum_train = len(train)\nindices = list(range(num_train))\nnp.random.shuffle(indices)\nsplit = int(np.floor(VALID_SIZE * num_train))\ntrain_idx, valid_idx = indices[split:], indices[:split]\n\ntrain_sampler = SubsetRandomSampler(train_idx)\nvalid_sampler = SubsetRandomSampler(valid_idx)\n\ntrain_loader = torch.utils.data.DataLoader(train, batch_size=BATCH_SIZE, sampler=train_sampler)\nvalid_loader = torch.utils.data.DataLoader(valid, batch_size=BATCH_SIZE, sampler=valid_sampler)\n\nprint(\"Train length-\")\nprint(len(train_idx))\nprint(\"Valid length-\")\nprint(len(valid_idx))","08e1dfc0":"class Net(nn.Module):\n    def __init__(self): \n        super(Net, self).__init__()\n        self.cnn_model = nn.Sequential(\n            nn.Conv2d(1, 10, 5),         # (N, 1, 28, 28) -> (N,  10, 24, 24)\n            nn.ReLU(),\n            nn.MaxPool2d(2, stride=2),  # (N, 10, 24, 24) -> (N,  10, 12, 12)\n            nn.Conv2d(10, 20, 5),        # (N, 10, 12, 12) -> (N, 20, 8, 8)  \n            nn.Dropout2d(),\n            nn.ReLU(),\n            nn.MaxPool2d(2, stride=2)   # (N,20, 8, 8) -> (N, 20, 4, 4)\n        )\n        self.fc_model = nn.Sequential(\n            nn.Linear(320,50),         # (N, 320) -> (N, 50)\n            nn.ReLU(),\n            nn.Linear(50,10)            # (N, 50)  -> (N, 10)\n        )\n        \n    def forward(self, x):\n        x = self.cnn_model(x)\n        x = x.view(x.size(0), -1)\n        x = self.fc_model(x)\n        return x","f8f2e3fd":"model = Net()\nif train_on_gpu:\n    model.cuda()","1798b685":"LEARNING_RATE = 0.01\n\ncriterion = nn.CrossEntropyLoss()\nmomentum = 0.5\noptimizer = optim.SGD(model.parameters(), lr=LEARNING_RATE,\n                                momentum=momentum)","a00832a7":"%%time\nepochs = 150\nvalid_loss_min = np.Inf\ntrain_losses, valid_losses = [], []\n\nfor epoch in range(1, epochs+1):\n    running_loss = 0\n\n    for images, labels in train_loader:\n        if train_on_gpu:\n            images, labels = images.cuda(), labels.cuda()\n        optimizer.zero_grad()\n        output = model(images)\n        loss = criterion(output, labels)\n        loss.backward()\n        optimizer.step()\n        running_loss += loss.item()\n    else:\n        valid_loss = 0\n        accuracy = 0\n        with torch.no_grad():\n            model.eval()\n            for images, labels in valid_loader:\n                if train_on_gpu:\n                    images, labels = images.cuda(), labels.cuda()\n                output = model(images)\n                _, top_class = output.topk(1, dim=1)\n                equals = top_class == labels.view(*top_class.shape)\n                \n                valid_loss += criterion(output, labels)\n                accuracy += torch.mean(equals.type(torch.FloatTensor))\n                \n        model.train()\n        \n        train_losses.append(running_loss\/len(train_loader))\n        valid_losses.append(valid_loss\/len(valid_loader))\n        \n        improved = valid_loss < valid_loss_min\n\n        if epoch == 1 or epoch % 5 == 0 or improved:\n            print(f\"Epoch: {epoch}\/{epochs}.. \",\n                  f\"Training Loss: {running_loss\/len(train_loader):.3f}.. \",\n                  f\"Validation Loss: {valid_loss\/len(valid_loader):.3f}.. \",\n                  f\"Valid Accuracy: {accuracy\/len(valid_loader):.3f}\")\n        \n        if improved:\n            valid_loss_min = valid_loss\n            torch.save(model.state_dict(), 'mnist.pt')\n            print('saving current model')","256a9e99":"%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nimport matplotlib.pyplot as plt\n\nplt.plot(train_losses, label='Training Loss')\nplt.plot(valid_losses, label='Validation Loss')\nplt.legend(frameon=False)","4463264a":"model.load_state_dict(torch.load('mnist.pt'))","1aace8c8":"class SubmissionMNIST(torch.utils.data.Dataset):\n    def __init__(self, file_path, transform=None):\n        self.data = pd.read_csv(file_path)\n        self.transform = transform\n        \n    def __len__(self):\n        return len(self.data)\n    \n    def __getitem__(self, index):\n        image = self.data.iloc[index].values.astype(np.uint8).reshape((28, 28, 1))\n\n        \n        if self.transform is not None:\n            image = self.transform(image)\n            \n        return image","d5e71697":"transform = transforms.Compose([\n    transforms.ToPILImage(),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=(0.5,), std=(0.5,))\n])\n\ntestset = SubmissionMNIST('..\/input\/digit-recognizer\/test.csv', transform=transform)\ntestloader = torch.utils.data.DataLoader(testset, batch_size=BATCH_SIZE, shuffle=False)\n","a46ff089":"submission = [['ImageId', 'Label']]\n\nwith torch.no_grad():\n    model.eval()\n    image_id = 1\n\n    for images in testloader:\n        if train_on_gpu:\n            images = images.cuda()\n        output = model(images)\n        ps = torch.exp(output)\n        top_p, top_class = output.topk(1, dim=1)\n        \n        for prediction in top_class:\n            submission.append([image_id, prediction.item()])\n            image_id += 1","ec6c2f64":"with open('prediction.csv', 'w') as File:\n    writer = csv.writer(File)\n    writer.writerows(submission)","a69593b9":"Checked for GPU connection","c6610601":"Imported the libraries needed","c379bdef":"Defined training parameters and loss function","327c5e2b":"Defined a class MNIST to convert pixels into torch utils dataset format","74305486":"Defined NET class defining neural network. The size of input image after every layer is commented . N denotes batch size.","cf043b87":"Finally written all the predictions in prediction.csv which is final output file","56fb9d3b":"Train and valid loss plotting","0acd6407":"Finally splitted dataset into train_loader and valid_loader with batch_size- 128","8ad31144":"Saved all predictions in submission 2-D list","4a0ecba7":"Trained the model","d5d50546":"Loaded train loader","fa93a5c7":"Defined Model instance and moved it to CUDA","fa4029dd":"Defined this class to convert test dataset pixels in torch.utils dataset format","32a6c3ba":"Loaded the best model"}}