{"cell_type":{"abead4f0":"code","13903404":"code","3e4e78ce":"code","43b8181d":"code","b2d1ace0":"code","c5ceac9b":"code","37b2723e":"code","c67a668c":"code","e764e876":"code","d0d2df84":"code","1b3a672d":"code","53414fcd":"code","79829575":"code","dc51505f":"code","4d13ee34":"code","c82cbb53":"markdown","ec310c76":"markdown","2b6f541b":"markdown","430643b1":"markdown","9715bff8":"markdown","66a89cae":"markdown","70665bfd":"markdown","bca73e99":"markdown","ace392d5":"markdown","ecd8d75d":"markdown","ca34e199":"markdown","5b2aab2b":"markdown","82ba42ce":"markdown"},"source":{"abead4f0":"#import important stuff\nimport os\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom collections import Counter\nimport re\n%matplotlib inline\nplt.style.use(\"seaborn\")","13903404":"df = pd.read_csv(\"..\/input\/zomato.csv\")\ndf.head(3)","3e4e78ce":"df.info()","43b8181d":"#let's modify few column names for our ease. This is subjective, you may\/may not want to do this  \ndf = df.rename({'approx_cost(for two people)': 'approx_cost', 'listed_in(type)': 'type', 'listed_in(city)':'city'}, axis='columns')\ndf.head(1)","b2d1ace0":"###################################################################################\n#      This section is for data cleanup and handling missing values and stuff     #\n###################################################################################\nfrom numpy import median\n\n# This methods strips off anything after '?' in the url.\ndef clean_url():\n    url_regex = '^.+www.zomato.com\\\/.+\\?'     \n    for index,row in df.iterrows():\n        new_url= re.findall(url_regex,row['url'])\n        if new_url != []:\n            new_url = new_url[0][:-1]\n            df.at[index,'url']=new_url #strip the ?\n    print(\"-Done URL-\")\n\n# This methods reformats the data in column 'rate', from (eg) '4.1\/5' to 4.1\ndef clean_rate():\n    all_rates =[]\n    for index,row in df.iterrows():\n        if row['rate']=='NEW' or row['rate']=='-':\n            df.at[index,'rate']= float(3.7)   #I already calculated the median(3.7) of the rest of the values, so using that(3.7) directly here.\n            continue\n        elif type(row['rate']) != str:\n            continue\n        rate = row['rate']\n        rate = rate.split(\"\/\")\n        rate= rate[0]\n        df.at[index,'rate']=float(rate)\n        all_rates.append(float(rate))\n    value_for_nan = median(all_rates)\n    #print(value_for_nan)\n    df['rate'] = df['rate'].fillna(value_for_nan)\n    print(\"-Done rate-\")\n\n# This method changes the column 'phone', to 1 or 0, depending on whether we have the phone no. or not\ndef clean_phone():\n    for index,row in df.iterrows():\n        if type(row['phone']) != str:\n            df.at[index,'phone']=0\n        else:\n            df.at[index,'phone']=1\n    print(\"-Done phone-\")\n\n            \n# The following method 'one-hot' encodes the restaurant type(s), effectively creating a whole bunch of new columns, corresponding to the respective restaurant's type \ndef clean_rest_type():\n    all_types_list=[]\n    for index,row in df.iterrows():\n        rest_type= row['rest_type']\n        if type(rest_type) != str:\n            continue\n        rest_type_list = rest_type.split(',')\n        for val in rest_type_list:\n            val = val.strip()\n            if val not in all_types_list:\n                all_types_list.append(val)\n    print(\"These are the type categories for restaurants we have-\\n %s\"%all_types_list)\n    \n    for index,row in df.iterrows():\n        rest_type= row['rest_type']\n        if type(rest_type) != str:\n            present = None\n            for types in all_types_list:\n                df.at[index,types]=0\n            continue\n        for types in all_types_list:\n            if types in rest_type:\n                df.at[index,types]=1\n            else:\n                df.at[index,types]=0\n    print(\"-Done rest_type-\")\n\n# This method modifies the type of approx_cost, from str to float. It also fills the nan values with the median\ndef clean_approx_cost():\n    all_cost= []\n    for index,row in df.iterrows():\n        if type(row['approx_cost'] ) != str:\n            continue\n        else:\n            cost_str = row['approx_cost']\n            cost_str= cost_str.replace(',','')\n            df.at[index,'approx_cost'] = float(cost_str)\n            all_cost.append(float(cost_str))  \n#     median(all_cost) #Comes as 400\n    df['approx_cost']=df['approx_cost'].fillna(400.0)\n    print(\"-Done approx_cost -\")\n    \n\n# This method creates 5 new columns for customer rates. For each entry, these column contain information on how many 1,2,3,4, or 5 star(s) were given by customers in review_list    \ndef clean_reviews_list():\n    rate_list=[]\n    #add column with default values\n    df['cust_rate_1']=0\n    df['cust_rate_2']=0\n    df['cust_rate_3']=0\n    df['cust_rate_4']=0\n    df['cust_rate_5']=0\n    for index,row in df.iterrows():\n        reviews = row['reviews_list']\n        regex_rate = 'Rated\\s[0-9].[0-9]'  #Regex to fetch just the phrase 'Rated X.X'\n        rates = re.findall(regex_rate,reviews)\n        for cust_rate in rates:\n            given_rate = float(cust_rate.split(' ')[1])\n            if given_rate == 1.0:\n                    current=df.loc[index,'cust_rate_1']\n                    current = current + 1\n                    df.at[index,'cust_rate_1'] = float(current)\n            elif given_rate == 2.0:\n                    current=df.loc[index,'cust_rate_2']\n                    current = current + 1\n                    df.at[index,'cust_rate_2'] = float(current)\n            elif given_rate == 3.0:\n                    current=df.loc[index,'cust_rate_3']\n                    current = current + 1\n                    df.at[index,'cust_rate_3'] = float(current)\n            elif given_rate == 4.0:\n                    current=df.loc[index,'cust_rate_4']\n                    current = current + 1\n                    df.at[index,'cust_rate_4'] = float(current)\n            elif given_rate == 5.0:\n                    current=df.loc[index,'cust_rate_5']\n                    current = current + 1\n                    df.at[index,'cust_rate_5'] = float(current)\n                    \n    print('-Done reviews_list -')\n\n\n# This method creates a whole new bunch of columns based on different cuisines. These column have 1 or 0, based on whether the restaurant serves that particular cuisine\ndef clean_cuisines():\n    all_cuisines=[]\n    df['cuisines'].count()\n    for index,row in df.iterrows():\n        cuisine = row['cuisines']\n        if type(cuisine) != str:\n            continue\n        cuisine = cuisine.split(',')\n        for items in cuisine:\n            item= items.strip()\n            if item not in all_cuisines:\n                all_cuisines.append(item)\n    print(\"Following are all of the cuisines:\\n%s\"%all_cuisines) \n    #create columns for these cuisines with default value as 0(s). \n    for cuisine in all_cuisines:\n        df[cuisine]=0\n    for index,row in df.iterrows():\n        cuisine = row['cuisines']\n        if type(cuisine) != str:\n            continue\n        cuisine = cuisine.split(',')\n        for items in cuisine:\n            item= items.strip()\n            df.at[index,item]=1\n    print(\"-Done cuisines -\")\n    \n\n# ------------Call----------------------------------------#\n\ndf.drop(['url'],inplace = True,axis=1)\ndf.drop(['address'],inplace = True,axis=1)\nclean_rate()\nclean_phone()\ndf['location']=df['location'].fillna('Unknown')\nclean_rest_type()\ndf.drop(['rest_type'],inplace = True,axis=1)\nclean_approx_cost()\nclean_reviews_list()\ndf.drop(['reviews_list'],inplace=True,axis=1)\nclean_cuisines()\ndf.drop(['cuisines'],inplace= True, axis=1)\ndf.drop(['dish_liked'],inplace= True, axis=1) #Any suggestions on how to handle a large number of missing data is welcomed. 51717-23639 = 28,078 missing values.\ndf.drop(['menu_item'],inplace=True,axis=1)\ndf.head(2)","c5ceac9b":"# df.info(verbose =True,null_counts=True)","37b2723e":"#UNIVARIATE ANALYSIS\n##########################################\nplt.xkcd(True) \nfig = plt.figure(figsize=(15,5))\nfig.subplots_adjust(wspace=2)\nfig.subplots_adjust(hspace=0.2)\nax1 = fig.add_subplot(2,2,1)\nax2 = fig.add_subplot(2,2,2)\nax3 = fig.add_subplot(2,2,3)\nax4 = fig.add_subplot(2,2,4)\n\n##########################################\n \ncolors = ['#66b3ff','#ff9999']\n#column 'online_order' has categorical values. We could use a bar chart\nx,y=[],[]\nonline_orders=df['online_order'].value_counts().to_frame()\nfor index,row in online_orders.iterrows():\n    x.append(index)\n    y.append(row.values[0])\nax1.set_ylim(top=50000)\nax1.bar(x,y,color = colors)\nax1.set_xlabel(\"Online Order available?\")\nax1.set_ylabel(\"No. of restaurants\")\nax1.set_title(\"Do restaurants accept online orders?\")\n\n#column 'book_table' has categorical values. We could use a bar chart\nx2,y2=[],[]\ntables_booked=df['book_table'].value_counts().to_frame()\nfor index,row in tables_booked.iterrows():\n    x2.append(index)\n    y2.append(row.values[0])\n\nx2 = x2[::-1] #Reversing it to say Yes first, then No\ny2 = y2[::-1] #Reversing it to say Yes first, then No\nax2.set_ylim(top=50000)\nax2.bar(x2,y2,color=colors)\nax2.set_xlabel(\"Table booking available?\")\nax2.set_ylabel(\"No. of restaurants\")\nax2.set_title(\"Do restaurants allow table booking?\")\n\n\n\n#Do restaurants which allow online booking have a better rating?\nonline_order_yes_avg_rate= df.loc[(df['online_order'] == \"Yes\")]['rate'].mean()    \nonline_order_no_avg_rate= df.loc[(df['online_order'] == \"No\")]['rate'].mean()\nprint(\"Average Rating for restaurants which allow online booking: %s\\nAverage Rating for restaurants which don't allow online booking: %s\\n\"%(online_order_yes_avg_rate,online_order_no_avg_rate))\n\nx = [\"Yes\",\"No\"]\ny= [online_order_yes_avg_rate,online_order_no_avg_rate]\nax3.set_ylim(top=5)\nax3.bar(x,y,color=colors)\nax3.set_xlabel(\"Online Booking available\")\nax3.set_ylabel(\"Average Rate\")\nax3.set_title(\"What is the average rate for rest. which allow online ordering?\")\n\n\n#Do restaurants which allow table booking have a better rating?\nbook_table_yes_avg_rate= df.loc[(df['book_table'] == \"Yes\")]['rate'].mean()    \nbook_table_no_avg_rate= df.loc[(df['book_table'] == \"No\")]['rate'].mean()\nprint(\"Average Rating for restaurants which allow table booking: %s\\nAverage Rating for restaurants which don't allow table booking: %s\\n\"%(book_table_yes_avg_rate,book_table_no_avg_rate))\n\nx = [\"Yes\",\"No\"]\ny= [online_order_yes_avg_rate,online_order_no_avg_rate]\nax4.set_ylim(top=5)\nax4.bar(x,y,color=colors,align='center')\nax4.set_xlabel(\"Table Booking available\")\nax4.set_ylabel(\"Average Rate\")\nax4.set_title(\"What is the average rate for rest. which allow table booking?\")\nplt.tight_layout()\nplt.show()","c67a668c":"plt.xkcd(False)\ndummy_2 = df.copy()\n#create a new column 'booking_ordering', which basically tells whether a restaurant allows or doesn't allow, booking or online ordering.\ndummy_2['booking_ordering']='None'  \n\nfor index,row in dummy_2.iterrows():\n    if row['online_order'] == \"Yes\" and row['book_table']=='Yes':\n        dummy_2.at[index,'booking_ordering'] = 'booking Available, online Available'      \n    elif row['online_order'] == \"Yes\" and row['book_table']=='No':\n        dummy_2.at[index,'booking_ordering'] = 'booking Unavailable, online Available'\n    elif row['online_order'] == \"No\" and row['book_table']=='Yes':\n        dummy_2.at[index,'booking_ordering'] = 'booking Available, online Unavailable'\n    elif row['online_order'] == \"No\" and row['book_table']=='No':\n        dummy_2.at[index,'booking_ordering'] = 'booking Unavailable, online Unavailable'\n\ndummy_3 = dummy_2[['booking_ordering','rate']]\n\n#Plot\nfig = plt.figure(figsize=(15,15))\nax1 = fig.add_subplot(1,1,1)\nsns.countplot(data=dummy_3,x='rate',hue='booking_ordering',ax =ax1,palette='tab10')\nplt.legend(loc='upper left')\nplt.setp(ax1.get_legend().get_texts(), fontsize='22') # for legend text\nplt.setp(ax1.get_legend().get_title(), fontsize='32') # for legend title\nplt.tight_layout()\nplt.show()","e764e876":"#column 'rate' has quantitative values. We could use a histogram\nplt.xkcd(False)  \nplt.hist(df['rate'],bins=15,color = \"#ADADEB\", lw=\"0\")\nplt.xlabel(\"overall rest. rating\")\nplt.ylabel(\"frequency\")\nplt.tight_layout()\nplt.grid(True)\nfig = plt.gcf()\nfig.set_size_inches(6,4)\nplt.show()\nprint(\"Mean-\",df['rate'].mean())\nprint(\"Standard Dev-\",df['rate'].std())\n\n\n#Uncomment below please\n# sns.boxplot(df['rate'])  #Can someone please suggest to me what we can do with the outliers? or why should we even do something about it?","d0d2df84":"# column 'location' has categorical values. We could use a bar chart or maybe piechart?\n\n#########[ generate colors ]#################################\n# import pylab                                              #\n# NUM_COLORS = 94   #94 colors for 94 locations             #\n# cm = pylab.get_cmap('gist_rainbow')                       #\n# cgen = (cm(2.*i\/NUM_COLORS) for i in range(NUM_COLORS))   #\n#############################################################\n\nplt.xkcd(False)\nsize=[]\nlocation=[]\nfor index,row in (df['location'].value_counts().to_frame()).iterrows():\n    location.append(index)\n    size.append(row.values[0])\n\n#Keep only top 20 location names, replace all others with '.' to avoid text overlapping.\n#THIS IS A HACK, DON'T USE IT (Suggestions welcomed)\nfor i in range(20,len(location)):\n    location[i]=''\n    \ncolors = ['#ff9999','#ff99cf','#ff99b4','#ff99a7','#ffcf99','#ffdd99','#66b3ff','#66dcff','#668aff','#7f66ff','#99ff99','#ddff99','#a7ff99','#99ffb4','#99ffdd','#ffcc99','#eeff99']\nexplode = [0.05]*len(location)\n# plt.barh(location[::-1],size[::-1])   #If you prefer bar chart \nplt.pie(size, labels=location,colors=colors,explode =explode, autopct='%1.f%%', pctdistance=0.85,textprops={'fontsize': 14},shadow=True)\nplt.title('\"% Of Total Restaurants In An Area\"', y=1.08,fontsize=20)\nplt.axis(\"equal\")\n\n#draw circle\ncentre_circle = plt.Circle((0,0),0.80,fc='whitesmoke')\nfig = plt.gcf()\nfig.gca().add_artist(centre_circle)\nfig.set_facecolor('whitesmoke')\nfig.set_size_inches(18,9)\nplt.show()","1b3a672d":"plt.xkcd(False)\nfig = plt.figure(figsize=(15,7))\nax1 = fig.add_subplot(1,2,1)\nax2 = fig.add_subplot(1,2,2)\n\n\n#BIGGEST CHAIN RESTAURANTS (top 10)\nnames,count = [],[]\ntop_ten_by_numbers = df['name'].value_counts().to_frame()[:10]\nfor index,row in top_ten_by_numbers.iterrows():\n    names.append(index)\n    count.append(row.values[0])\n\n# ax1.barh(names,count)   #This was boring. :( \nsns.barplot(count, names, palette=\"Blues_d\",ax=ax1)   #Seaborn ! :D\nax1.set_xlabel(\"No. of restaurants\")\nax1.set_title(\"BIGGEST CHAIN RESTAURANTS. (TOP 10)\")\n\n#TOP 10 BEST CHAIN RESTAURANT (top 10)  (Rated 4.8 and above)\nname_by_rate,count_by_rate=[],[]\ntop_ten_by_rate_and_number = df[df['rate']>=4.8]['name'].value_counts().to_frame()[:10]\nfor index,row in top_ten_by_rate_and_number.iterrows():\n    name_by_rate.append(index)\n    count_by_rate.append(row.values[0])\n\n# ax2.barh(name_by_rate,count_by_rate)    #This was boring. :( \nax2 = sns.barplot(count_by_rate,name_by_rate,palette=\"Reds_d\",ax=ax2) #Seaborn,what is dead may never d...wait what?\nax2.set_xlabel(\"No. of restaurants\")\nax2.set_title(\"BEST RATED CHAIN RESTAURANTS. (TOP 10)\")\nplt.tight_layout()\nplt.show()","53414fcd":"#Which restuarant has the best rating, and which restaurant has most number of 4 stars or above? Are they same?\nbest_restaurants= df[df['rate']==df['rate'].max()]  #ie, restaurants which have an overall rating of 4.9(the max in out dataset)\n\nprint(\"All the restaurants mentioned below had an overall rating of 4.9! :\\n\")\nprint(\"Restaurant name\\t\\t\\t\\t\\t\\t\\t\\t\\tNo of outlets\\n\")\nprint(\"---------------------------------------------------------------------------------------------\")\nprint(best_restaurants['name'].value_counts())","79829575":"cust_rate_df= best_restaurants.groupby(['name'])['cust_rate_4','cust_rate_5'].sum() #Create the dataframe grouped according to names, and having the sum of total 4 & 5 stars.\n# print(cust_rate_df.head()) #Uncomment to check it out.\nplt.xkcd(False)\nx_axis_names = []\nx_axis_4=[]\nx_axis_5=[]\ny_axis_4=[]\ny_axis_5=[]\nwidth = 0.4\ni=1\nfor group_names in cust_rate_df.index:\n    x_axis_names.append(group_names)\n    i=i+2\n    x_axis_4.append(i)\n    x_axis_5.append(i+width)\n    y_axis_4.append(cust_rate_df.loc[group_names].values[0])\n    y_axis_5.append(cust_rate_df.loc[group_names].values[1])\n\nx_axis_names[-1]='Santa Spa Cuisine'\nx_axis_4=x_axis_4[::-1]  \nx_axis_5=x_axis_5[::-1]\n#########\n#  Plot #\n#########\nfig = plt.figure(figsize=(15,8))\nax1 = fig.add_subplot(1,1,1)\nax1.barh(x_axis_4,y_axis_4,color=\"#89bedc\",label='4 Stars')\nax1.barh(x_axis_5,y_axis_5,color=\"#0b559f\",label='5 Stars')\nax1.set_yticks(x_axis_4,[])\nax1.set_yticklabels(x_axis_names,[])\n\nplt.title(\"How many 4 & 5 stars did the best rated(4.9 overall rate) restaurants get?\", y=1.08,fontsize=20)\n\nax1.legend(prop={'size': 22,'weight':'bold'})\nax1.set_xlabel(\"No of stars\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()","dc51505f":"rest_types = df.columns[10:35] #All types of restaurants\n#How many of each type of restaurant\nprint(\"(*) Restaurants are categorized as following, on the basis of the type of meal.\\nMeal Type\\t\\tNo. of restaurants in this meal type\\n--------------------------------------------\\n%s\"%df.groupby('type')['name'].count())\nprint(\"\\n(*) Restaurants are categorized as following, on the basis of restaurant type\\n \")\nprint(\"Rest. Type\\t\\t\\t\\t\\tNo. of restaurants of this type\")\nprint(\"-------------------------------------------------------------------------------\")\nfor rest_type in rest_types:\n    total = df[rest_type].sum().astype(int)\n    print(\"%s\\t\\t\\t\\t\\t\\t%s\"%(rest_type,total))","4d13ee34":"#TODO do few MULTIVARIATE ANALYSES\n#TODO Organise the notebook with a proper navigation section and descriptions","c82cbb53":"Let's get some info on our dataset","ec310c76":"\n*Coming Soon- Contd. some basic visual analysis. Stay tuned-*\n\n> <br>\n__________________\n![](https:\/\/lh3.googleusercontent.com\/rzd_ueW6F7C1TLgbZ8a9te_VtdZ1MA7qCS8-OsH71U06kZmtRdWHdbwLufjVeEHWSoRF) \n![](https:\/\/s3-img.pixpa.com\/com\/large\/37698\/-btfu5q.png)\n________________","2b6f541b":"> So, most of them are chain restaurants.\n<br>Lets see, among these, which one gets most no of 4 and 5 stars by customers","430643b1":"> So , I'm definitely checking out **\"Asia Kitchen, By Mainland China\"** when I visit Bangalore.","9715bff8":"Let's have a sneak peek at our data","66a89cae":"---------------------------------\n**~We'll keep on writing questions which pop in mind, and later find their answers~ **<br>\n* <strike>Which is the biggest chain restaurant?<\/strike> <br>\n* <strike>Do restaurants which take online orders, have better rating?<\/strike><br>\n* <strike>How many\/what percentage of restaurants which take online orders, allow table booking?<\/strike><br>\n* <strike>Do restaurants which allow table booking have better rating? or is it the other way round?<\/strike> <br>\n* <strike>Which restaurant has the best rating, and which restaurant has the most 4 star rating and above? <\/strike><br>\n* Which are the most served cuisines. Any relation to good rated restaurants?<br>\n* How many good restaurant does BTM have \/ Are most of the good restaurants located in BTM?<br>\n* What type of restaurant works the most? <br>\n* Cost related analyses <br>\n* Do chain restaurants earn more? or do good rated restaurants earn more?<br>\n* What's  the average price by location?\n\n------------------","70665bfd":"Therefore, just opening a hell lot of restaurants is not enough. Service and customer satisfaction is also important.","bca73e99":"Notice how this looks kinda similar to the last plot we did.","ace392d5":"[Please note that this is still a work in progress. But, feel free to leave suggestions]\n\n--------------------------\n![](https:\/\/cdn-images-1.medium.com\/max\/1200\/1*jAH0Sl4b48AEOG_5LAFuFw.gif)\n\n\n----------\n****ZOMATO****- B'Lore\n---------\n","ecd8d75d":"Data Munging\n-------","ca34e199":"---------------------\nSo, we have 51717 entries and 17 columns.<br>Among these, there are few data missing from the following columns: \nrate, phone, location, rest_type, dish_liked, cuisines, approx_cost\n<br>Let's clean the data and go through all columns one by one,","5b2aab2b":">Number of restaurants who don't allow table bookings is too damn high. https:\/\/img.washingtonpost.com\/blogs\/the-fix\/files\/2015\/07\/PHO-10Oct19-261389.jpg\n> <br>\n> <br>\nOkay,<br>\n> Let's try and plot something which could give an insight on the above, together.\n> ","82ba42ce":"> Okay this is interesting.<br> We can see how each of the colors (attributes) are distributed within certain range of rates.<br>\n> We can infer a number of things from this:<br>\n> For instance, the red(or maroon?) attribute, ie, 'booking available, online unavailable' is uniformly distributed between rates 3.5 and 4.8 <br>\nSimilar is the case for blue color attribue, ie, 'booking available, online available'.\nSo one might say that restaurants which allow table booking, *usually* turn out to be good ones, whether or not they support online orders.\n\n> <br>\n> Now if we check the others, there's a huge spike for color green and orange, ie, \"booking unavailable, online available\" and \"booking unavailable online unavailable\" around 3.7 <br>\nThat is, *most* of restaurants don't usually let you book table.\nThese restaurant types on an average get a rating of about ~3.7 whether or not they support online orders <br>\n> 3.7 Not great, not terrible. \n> https:\/\/media1.tenor.com\/images\/6d16d53a1dfdc3e35071636096c9b40c\/tenor.gif\n"}}