{"cell_type":{"f6911be6":"code","fbe1e7c4":"code","79e0ad4c":"code","9d198164":"code","65d7cf78":"code","7c9b98fe":"code","243f81d4":"markdown","0ec33a5f":"markdown","9acd3494":"markdown","bf44c49a":"markdown","cff9c26b":"markdown","887d4d02":"markdown"},"source":{"f6911be6":"import pandas as pd\nimport numpy as np\nfrom tqdm import tqdm","fbe1e7c4":"print('Extracting data')\n\n# =============================================================================\n# load problem file\n# =============================================================================\nwith open('\/kaggle\/input\/hashcode-drone-delivery\/busy_day.in') as file:\n    line_list = file.read().splitlines()\n    \n# =============================================================================\n# problem parameters\n# =============================================================================\nROWS, COLS, DRONES, TURNS, MAXLOAD = map(int, line_list[0].split())\n   \n# =============================================================================\n# load product information\n# =============================================================================\nweights = line_list[2].split()\nproducts_df = pd.DataFrame({'weight': weights})\n\nwh_count = int(line_list[3])\nwh_endline = (wh_count*2)+4\n\nwh_invs = line_list[5:wh_endline+1:2]\nfor i, wh_inv in enumerate(wh_invs):\n    products_df[f'wh{i}_inv'] = wh_inv.split()\n\n# products_df has shape [400,11]\n# (# of products, [weight, wh0_inv, wh1_inv,...])\nproducts_df = products_df.astype(int)\n\n# =============================================================================\n# load warehouse locations\n# =============================================================================\nwh_locs = line_list[4:wh_endline:2]\nwh_rows = [wl.split()[0] for wl in wh_locs]\nwh_cols = [wl.split()[1] for wl in wh_locs]\n\nwarehouse_df = pd.DataFrame(\n    {'wh_row': wh_rows, 'wh_col': wh_cols}).astype(np.uint16)\n\n# =============================================================================\n# load order information\n# =============================================================================\norder_locs = line_list[wh_endline+1::3]\no_rows = [ol.split()[0] for ol in order_locs]\no_cols = [ol.split()[1] for ol in order_locs]\n\norders_df = pd.DataFrame({'row': o_rows, 'col': o_cols})\n\norders_df[orders_df.duplicated(keep=False)].sort_values('row')\n\norders_df['product_count'] = line_list[wh_endline+2::3]\n\norder_array = np.zeros((len(orders_df), len(products_df)), dtype=np.uint16)\norders = line_list[wh_endline+3::3]\nfor i,order in enumerate(orders):\n    products = [int(prod) for prod in order.split()]\n    for p in products:\n        order_array[i, p] += 1\n\ndf = pd.DataFrame(data=order_array,\n                  columns=['p_'+ str(i) for i in range(400)],\n                  index=orders_df.index)\n\norders_df = orders_df.astype(int).join(df)\n\nprint('... success')","79e0ad4c":"# get list of drone commands\nsubmission = pd.read_csv('\/kaggle\/input\/2020hcdd-sample-submission\/submission.csv')\nallcommands = submission[submission.columns[0]].values\n\n# delivery_times will store the timestamp of the last delivery for each order\norder_completion_times = np.full((len(orders_df)), -1)\n# missing_items holds the number of each product required to complete an order\nmissing_items = orders_df.copy()\n# inventory_ops simply lists all inventory changes of all warehouses\ninventory_ops = pd.DataFrame(columns=['action', 'wh', 'item', 'count', 'turn'])\n\n# iterate through all drones\nfor ddd in tqdm(range(DRONES)):\n    \n    # get only commands for this specific drone\n    dronecommands = [iii for iii in allcommands if iii.split()[0] == str(ddd)]\n    \n    # all drones start at warehouse 0 at timestep 0 with 0 weight loaded\n    currentloc = warehouse_df.loc[0].values\n    currenttime = 0\n    currentweight = 0\n    \n    # go through commands in order\n    for cmd in dronecommands:\n        \n        # split command into separate components\n        _, action, locidx, prod, count = cmd.split(' ')\n        \n        # for \"wait\" commands\n        # add given number of turns to timer and continue\n        if action == 'W':\n            currenttime += locidx\n            continue\n\n        # get target location\n        if action == 'L' or action == 'U':\n            newloc = warehouse_df.loc[int(locidx)].values\n        elif action == 'D':\n            newloc = orders_df.loc[int(locidx), ['row', 'col']].values\n        # calculate distance, round up to the next integer and add to timer\n        dist = int(np.ceil(np.sqrt(np.sum((currentloc-newloc)**2))))\n        currenttime += dist\n        # add one step for loading \/ unloading \/ delivery itself\n        currenttime += 1\n        # check if end of simulation is reached\n        if currenttime > TURNS:\n            raise Exception('Maximum simulation time exceeded')\n        # update current location\n        currentloc = np.copy(newloc)\n        \n        # update drone weight\n        if action == 'L':\n            currentweight += int(count) * products_df.loc[int(prod),'weight']\n        elif action == 'D' or action == 'U':\n            currentweight -= int(count) * products_df.loc[int(prod),'weight']\n        # check if drone weight limit exceeded  \n        if currentweight > MAXLOAD:\n            raise Exception('Maximum drone load exceeded')\n        \n        # for deliveries\n        if action == 'D':\n            # check number of items delivered and update required items\n            if missing_items.at[int(locidx), 'p_{}'.format(prod)] >= int(count):\n                missing_items.at[int(locidx), 'p_{}'.format(prod)] -= int(count)\n                # note latest delivery for each order\n                if currenttime > order_completion_times[int(locidx)]:\n                     order_completion_times[int(locidx)] = currenttime\n            else:\n                raise Exception('Too many items delivered')\n                \n        # save list of loading \/ unloading operations for checking warehouse inventory\n        if action == 'L' or action == 'U':\n            inventory_ops = inventory_ops.append({\n                'action': action,\n                'wh': int(locidx),\n                'item': int(prod),\n                'count': int(count),\n                'turn': currenttime\n            }, ignore_index=True)","9d198164":"for wh in range(len(warehouse_df)):\n    for item in tqdm(range(len(products_df))):\n        # all inventory operations at this warehouse involving this product\n        tmp = inventory_ops[\n            (inventory_ops['wh'] == wh) &\n            (inventory_ops['item'] == item)            \n        ]\n        if not len(tmp):\n            continue\n        \n        # sort chronologically\n        tmp = tmp.sort_values(by='turn')\n        # get initial stock\n        inv = products_df.loc[item, f'wh{wh}_inv']\n        # if overall fewer or just as many products are removed as are stored\n        # in the warehouse, no further checks needed\n        if len(tmp[tmp['action'] == 'L']) <= inv:\n            continue\n        # otherwise, \"simulate\" loading and unloading to see\n        # whether inventory goes negative\n        for iii in tmp.index:\n            if tmp.loc[iii, 'action'] == 'L':\n                inv -= tmp.loc[iii, 'count']\n            else:\n                inv += tmp.loc[iii, 'count']\n            # check inventory after each step\n            if inv < 0:\n                raise Exception('Removal of unstocked product attempted')","65d7cf78":"# check which orders are still missing items\ncompleted = np.max(missing_items.iloc[:,3:].values > 0, axis=1) <= 0\nprint('Orders completed:', len(np.where(completed)[0]))\nprint('Orders not completed:', len(np.where(completed == False)[0]))\n# sum up scores of all completed orders\norder_scores = np.ceil(100 * (TURNS - order_completion_times[np.where(completed)[0]]) \/ TURNS)\nprint('Score:', int(np.sum(order_scores)))","7c9b98fe":"import shutil\n\nshutil.copyfile('\/kaggle\/input\/2020hcdd-sample-submission\/submission.csv', 'submission.csv')","243f81d4":"First we read in a sample submission (one of my recent submissions packed into a Kaggle dataset) and go through the commands, drone by drone, carefully tracking time as well as currently loaded weight. We make sure to note a timestamp for each delivery, and we create a list of inventory actions (loading \/ unloading) which we'll use in the next cell to track warehouse inventory.","0ec33a5f":"Lastly, we check out when the last item was delivered for each order (using <code>delivery_times<\/code>) and whether all required items were delivered (using <code>missing_items<\/code>), and then calculate the final score according to the equation given in the instruction file.","9acd3494":"# Sample submission evaluation\n\nHere's my current implementation for scoring drone delivery submissions - let me know if you see anything wrong with it!\nFeel free to fork or use for your own submissions, can be useful to find errors and such.","bf44c49a":"Let's copy the submission file into the output directory to compare outputs.","cff9c26b":"Now let's quickly check whether we don't happen to try and remove products which aren't in stock...","887d4d02":"This block reads the input file, I took it pretty much unchanged from [jpmiller](https:\/\/www.kaggle.com\/jpmiller)'s awesome notebook [https:\/\/www.kaggle.com\/jpmiller\/18-second-solution-with-google-or-tools](https:\/\/www.kaggle.com\/jpmiller\/18-second-solution-with-google-or-tools)."}}