{"cell_type":{"c88536f7":"code","8851c07d":"code","010c2964":"code","a89062de":"code","5ee652f9":"code","9cdd1985":"code","a8b2b7ed":"code","67ffc547":"code","f93cbb88":"code","1973c6a5":"code","ed56ddaa":"markdown","d89db2fb":"markdown","45b1edd1":"markdown","91fd7279":"markdown","130493ec":"markdown","989c22ce":"markdown","4c052aa0":"markdown","b7e58bda":"markdown","92028b4a":"markdown","e81c0d80":"markdown","3f8b90d7":"markdown","7ed493d3":"markdown","fbc61293":"markdown","ad39fded":"markdown","46359176":"markdown","6ccb629a":"markdown"},"source":{"c88536f7":"%matplotlib inline\n\nimport matplotlib\nimport numpy as np\nimport pandas as pd\nimport seaborn as sb\nimport matplotlib.pyplot as plt","8851c07d":"ratings_df = pd.read_csv('..\/input\/recommendationmovieviacorrelation\/movie_data_updated.tsv', sep='\\t', encoding='ISO-8859-1', usecols=range(3), names=['userID', 'movieID', 'rating'])\ntitles_df = pd.read_csv('..\/input\/recommendationmovieviacorrelation\/movie_title_updated.csv', encoding='ISO-8859-1', usecols=range(2), names=['movieID', 'title'], skiprows=1)\nratings_df = pd.merge(ratings_df, titles_df, how='inner', on='movieID').reset_index(drop=True)\nratings_df.head()","010c2964":"count_df = ratings_df.groupby('userID')['movieID'].agg([np.size]).rename(columns={'size': 'review count'}).reset_index()\nsb.set(style='whitegrid')\nsb.boxplot(y=count_df['review count'])","a89062de":"count_df = count_df[count_df['review count'] < 320].reset_index(drop=True)\nratings_df = ratings_df[ratings_df['userID'].isin(count_df['userID'])]\npivot1 = ratings_df.pivot_table(index='userID', columns='title', values='rating')\npivot1.head()","5ee652f9":"times_a_movie_was_rated = pivot1.count(axis=0)\ntimes_a_movie_was_rated.head()","9cdd1985":"sb.boxplot(y=times_a_movie_was_rated)\nplt.show()","a8b2b7ed":"corelated = pivot1.corr(method='pearson', min_periods=159)\ncorelated.head()","67ffc547":"Star_Wars_rating = corelated['Star Wars (1977)'].sort_values(ascending=False).dropna()\nStar_Wars_rating.head()","f93cbb88":"user_ratings = ratings_df[ratings_df['userID'] == 0].set_index('title').rating\nuser_ratings.head()","1973c6a5":"recommendation = pd.Series(dtype=float)\nfor ind in user_ratings.index:\n    suggestions = corelated[ind].dropna()\n    if len(suggestions.index) != 0:\n        if user_ratings[ind] >= 3:\n            suggestions = suggestions.apply(lambda x: x * user_ratings[ind])\n            recommendation = recommendation.append(suggestions)\n        if user_ratings[ind] < 3:\n            suggestions = suggestions.apply(lambda x: (-x) * user_ratings[ind])\n            recommendation = recommendation.append(suggestions)\n\nrecommendation = recommendation.groupby(recommendation.index).sum().sort_values(ascending=False)\nrecommendation = recommendation[recommendation.index.isin(user_ratings)==False]\n\nrecommendation.head(10)","ed56ddaa":"First lets see how the user with ID number 0 has rated the movies","d89db2fb":"### Removing outliers\n##### Get a boxplot to find outliers","45b1edd1":"Here I would take the outliers values because those are the insanely most rated movies and are better recommendations. The value is 159.\nSo we will calculate corelation with movies which are at least rated by 159 users.","91fd7279":"### An intuition of the filtering strength\n##### Lets check the movies similar to Star Wars (1977)","130493ec":"### Creating sparse corelation matrix","989c22ce":"To set the min_periods it is needed to understand the statistics of number of ratings given per movie","4c052aa0":"Results look good intuitively. However tests might be performed to check if the user will actually like or not like the movies suggested. On of the ways to do this would be to use a train test method and match the predictions vs user ratings. To be more clear, the rating data could be split using train test and this model could be prepred using the training data. Afterwards using this model we could try predicting the ratings of the test users and match it with the actual ratings. But such test can't completely evaluate a recommender engine because users may like what they have never seen before. If the recommender gives the user a suggestion to watch movie 'X' which he hasn't watched and therefore did not rate also. But just because he didn't rate it doesn't mean that thehe won't enjoy the movie.","b7e58bda":"### Creation of corelation matrix","92028b4a":"##### Boxplot to find outliers or exceptionally popular movies","e81c0d80":"A pretty good match!\n\n### Building Recommendation engine\n- Similar movies to the movies rated by the user will be found out using the corelation matrix.\n- The similarity score will be boosted for higher ratings and will be penalized for lower ratings.\n- A list of desired number of recommenations are presented excluding the ones already seen by the user.\n\n\n##### Now we will recommend movies for the person with user ID '0' based on his ratings on various movies","3f8b90d7":"### Removing outliers & creating a sparse matrix using pivot table","7ed493d3":"Looks like the user likes science fiction\/action\/fantasy movies and hates romantic movies! Lets see how well the recommender performs - (We'll look at the top 10 movie recommendations from the engine excluding the ones rated or watched by the user)","fbc61293":"### Read the files\n##### Reshape the dataframes and merge ","ad39fded":"Evidently  from the boxplot its seen that outliers are those who gave away more than 320 ratings. So will drop the user IDs of those who rated more than\n320 movies.","46359176":"### Importing the necessary modules","6ccb629a":"# A Movie Recommendation System using Item Based Collaborative Filtering\nThe recommender is created using data from [GroupLens](https:\/\/grouplens.org\/) where movie and other data is made public for research and other purposes. The two files *u.item* & *u.data* containing movie rating data of the 90's movies were downloaded.\n\n\n**Item Based Collaborative Filtering:**\n\nItem-item, item based or item to item, is a kind of collaborative filtering technique used to recommend items through finding similarity scores based on ratings on those items provided by users. It was invented by Amazon.com and has many advantages over the pre-existing user based collaborative filtering as it was computationally expensive due to keeping records of all users. Again, it was easier to game the system. This notebook is a demonstration of a simple process to recommend items to users based on their ratings. As mentioned in above the dataset was downloaded from grouplens.org as file names: u.data & u.item"}}