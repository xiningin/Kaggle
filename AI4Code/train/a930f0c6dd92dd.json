{"cell_type":{"06b1e834":"code","01e5624b":"code","f7a26d3e":"code","3cc8a7c8":"code","717689eb":"code","b5b32860":"code","23689800":"code","72ef8601":"code","c139cfc2":"code","7941dc74":"code","5e339020":"code","f9deb169":"markdown","e6e07bfd":"markdown","90ef47f1":"markdown","793979b9":"markdown","63724fa6":"markdown","b0e7e6e0":"markdown"},"source":{"06b1e834":"# this is a code cell\n# a pound sign is used to create a comment\n# this will comment out everything that follows on that line\n# python code follows usual code notation, and might remind you of VBA as it uses the \"dot\" convention... i.e. object.do_something_to_object(paramters)","01e5624b":"# use the radians function in the math package\n\nangle = 90.\n\n# option 1\nimport math\n\nradians = math.radians(angle) # notice how we import the package \"as-is\", and refer to it by its full and proper name. Let's be lazy and give it a nickname\n\n# option 2\nimport math as m\n\nradians = m.radians(angle) # we've decided to call math \"m\", so we refer to it as \"m.some_function\". We can also import radians() directly\n\n# option 3\nfrom math import radians\n\nresult = radians(angle) # notice how since we have an object called radians, we need to change our variable name (otherwise the radians function will be overwritten)","f7a26d3e":"l = ['brad','number',1,'teacher']\nd = {'name':'brad','rank':1,'job':'teacher'}\n\nprint(l)\nprint(d)\n\nfor item in l:\n    print(item)","3cc8a7c8":"d['name']","717689eb":"# import the pandas package for data manipulation; it's conventionally called \"pd\"\nimport pandas as pd\n\n# import the meteorites CSV. The import statement would look different if you're working outside of a Kaggle kernel\ndf = pd.read_csv('..\/input\/meteorite-landings\/meteorite_landings_prod.csv')\n\nprint('Import complete!')","b5b32860":"df.head()","23689800":"# quickly demo attribute v method using data\n\n# shape is a pandas DataFrame attribute that gives a tuple of (number of rows,number of columns)\n# sum is a pandas DataFrame \/ Series method that we will apply to a single column\n\nprint(df.shape)\nprint(df['mass'].sum())","72ef8601":"# iloc v loc\n# integer v general\n# excludes last entry v includes last entry\n\n# select the mass column:\ndf['mass']\n#df.mass\n#df.loc[:,'mass']\n#df.iloc[:,'mass'] #?\n#df.iloc[:,7]","c139cfc2":"# select the 42nd row of mass\n#df.iloc[41,7]\n#df.loc[41,'mass']","7941dc74":"# conditionally select\nx = df.loc[df['location_code']=='DE',['mass','location','location_code']].copy()\nx['mass'].sum()\nx['mass'].mean()","5e339020":"# add a new column called centred mass\nx['centred_mass'] = x['mass'] - x['mass'].mean()\nx.head()","f9deb169":"## Functions + Charts\n\n### Functions\n\nKaggle would have taught you something about functions - hopefully how to:\n- write a function\n- specify the input for a function (especially setting \"default\" function values)\n- return the desired - potentially multiple - outputs (sad shake of head in R's direction)\n\nMy frustration with introductory courses is that they tend to focus a lot on manipulating strings. When we're working with tabular data, which are mostly numeric anyway, this becomes pretty redundant.\n\nSo, I'll jot down some things that I've learned, mostly the hard way.\n- As tempting as it sounds, if you're using functionality from a package, don't include the `import` statment within the function. If the function is dependent on a package, specify the import statement outside of the function (preferably at the top of the script you're using).\n- Be carfeul of local \/ global variables - i.e. what exists within the function, what exists outside of the function, and what exists in both places. As an example, consider the list called `listy_mac_list_face`:\n    - If `listy_mac_list_face` is created inside the function, it will only be available in the function, unless you specify it as an output\n    - If `listy_mac_list_face` is created outside of the function, it is available for reference in the function\n    - If `listy_mac_list_face` is created outside of the function, any operations you perform on it within the function will be persisted outside of the function\n\n\n### Charts\nI think the visualisation course will introduce `seaborn`. It's a great package and makes plotting variables with multiple facets really easy. It's also important to understand how to use `matplotlib`'s `pyplot` functionality, as you can't control all the aspects of a chart via `seaborn`... e.g. chart elements like axis labels.\n\nWorking with charts from within a function is slightly different, as you'll need to decide whether you would like to actually show the chart or return the chart as an object. You'll see what I mean when you start with the lap time chart function.","e6e07bfd":"### Objects, methods, and attributes\n\nPython is an \"object-oriented\" programming language. Python objects have _attributes_ and _methods_ associated with them:\n- attributes describe the object - e.g. data set size - and look like object.attribute\n- methods do something, either to the object itself, or to another object. They look like object.method().\n\nWe'll look at more concrete examples soon. Let's import data and start playing around with it.","90ef47f1":"### Selecting and slicing","793979b9":"When you \"open\" in Python, you only have access to the built-in functionality of Python. Remembering that it is at its core a general-purpose language, you won't be surprised to hear that you need extra bits to do anything meaningful. These extra bits live in packages, and can be loaded in using the `import` statement (as well as various forms thereof).\n\nThere are a few useful packages to know about:\n- `pandas`: _the_ data manipulation package for Python\n- `numpy`: very fast numerical methods\n- `sklearn`: or \"sci-kit learn\" contains almost everything you'll need to produce and analyse a suite of machine learning models\n\nWhen you use any bit that lives in a package, the way you refer to it depends on how you `import` it. Some examples:","63724fa6":"### Lists and dicts\n\nThese are two key Python data structures and form part of the built-in functionality.\n\nA __list__ is basically an array that contains data. Data can be alpha or numeric, or a mix of both. Lists are created using `[]`, like so `['brad','number',1,'teacher']`. Notice how strings are encapsulated in apostrophes (can be single or double). _Ask Brad about using 1 vs 1.0 vs 1._\n\nLists are really useful to hold data, or to contain an index for loops, and for other things which I can remember as I write this. There is also a thing called a list comprehension which can be super useful.\n\nNow, a __dict__ is a key \/ object pairing created using `{key:object}`. An example could be `{'name':'brad','rank':1,'job':'teacher'}`. A dict is powerful as it can hold more than just a single data point - e.g. objects can be lists, functions, or entire data sets.\n\nIn actual code, this looks like:","b0e7e6e0":"# IntroPy\n\nA quick introduction into Python notebooks.\n\nLet's get going.\n\n\n## 1. Jupyter \/ Kaggle Notebooks\n\nThis is the \"environment\" that we're using now.\n\nIt's essentially just a GUI for an underlying software package - e.g. you could have an R notebook as well. You can think of these notebooks as \"integrated\" coding and reporting tools since we can run code, produce visualisations, and write notes all in the same space.\n\nThere are other IDE if you prefer, but these are more focussed on the code than the discussion bit.\n\nYou input stuff into a notebook \"cell\". There are two types of cells:\n- __Markdown cells__ which are used for wordy bits and are written in markdown language. For instance, this is a markdown cell.\n- __Code cells__ which are used for code (believe it or not).\n\nBoth are executed by keyboard \"ctrl + Enter\", or clicking on \"run current cell\". There are other options for running cells - see the drop-down \"Run\" menu above.\n\nLet's move on to `code` cells.\n\n## 2. Code"}}