{"cell_type":{"329d106b":"code","77a92a0c":"code","4db0dfe1":"code","dfca840c":"code","654f800e":"code","e83946c9":"code","26bcccf3":"code","e305ad79":"code","086d4f8d":"code","ad1bf903":"code","2aada673":"code","cd558022":"code","ecc5ca3e":"code","f3475807":"code","8635569b":"code","877472c6":"code","bae8e911":"code","ac6a3978":"code","f7d36e4e":"code","7032e5d8":"code","79b3aed6":"code","803a0520":"code","c53d5538":"code","678a98ac":"code","62a268fa":"code","753592d5":"code","bf402bc1":"code","47c24ebf":"code","ac4bdd1d":"code","c24903d9":"code","b95746af":"code","7d9e9208":"code","dfb3b438":"code","a431626c":"code","69e5d21a":"code","a75ee5d9":"code","d2ff985d":"code","63f16246":"code","8371a21e":"code","df2a5c09":"code","75ab9c89":"code","bb0623fe":"code","93a89d44":"code","7b987da9":"markdown","9b298f23":"markdown","89fcfb27":"markdown","e799bbe3":"markdown","8cc5131c":"markdown","d3fa46a2":"markdown","fd98a4fc":"markdown","3653584a":"markdown","7478a99d":"markdown","ad5726b2":"markdown","b8b92f9d":"markdown","deec3765":"markdown","9fc2ab98":"markdown","64a080c2":"markdown","b0d9ad87":"markdown","dc7ce922":"markdown","bb03e7d0":"markdown","a8b08085":"markdown","c246bd6a":"markdown","76cd7518":"markdown","e1a4f593":"markdown","6f508556":"markdown","787a6b63":"markdown","a82cd78d":"markdown","3c61e445":"markdown"},"source":{"329d106b":"# List relevant data directory paths\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","77a92a0c":"import numpy as np\nimport pandas as pd\nfrom pathlib import Path\nfrom fuzzywuzzy import fuzz\nfrom fuzzywuzzy import process","4db0dfe1":"# Set Data Directory\ndata_dir = Path('\/kaggle\/input\/')","dfca840c":"# Load first data set - Beer Reviews\ndf_reviews = pd.read_csv(data_dir \/ 'beerreviews\/beer_reviews.csv')\ndf_reviews.info()","654f800e":"df_reviews.head(10)","e83946c9":"# Get average scores for each brew and call new dataframe `df_scores`\ndf_scores = df_reviews.drop(['brewery_id', \n                             'review_time', \n                             'review_profilename', \n                             'beer_style', \n                             'beer_beerid', \n                             'beer_abv'], \n                            axis=1).groupby(by=['brewery_name', \n                                                'beer_name'], \n                                            as_index = False).mean()\n\n# Get count of reviews per brew\ndf_scores_count = df_reviews.drop(['brewery_id', 'review_time', 'review_profilename', 'beer_style', 'beer_beerid', 'beer_abv'], axis=1).groupby(by=['brewery_name', 'beer_name'], as_index=False).count()\ndf_scores_count = df_scores_count['review_overall']\n\n# Combine information into one dataframe \ndf_scores['number_of_reviews'] = df_scores_count\ndf_scores.head()","26bcccf3":"# Load second data set - Beer Profile\ndf_profile = pd.read_csv(data_dir \/ 'top-beer-information\/beer_data_set.csv')\ndf_profile.info()","e305ad79":"df_profile.head()","086d4f8d":"# Display `df_profile` rows with null values (missing beer names)\ndf_profile[df_profile['Name'].isnull()]","ad1bf903":"# Look up data on 'Monastyrskiy Kvas' from `df_scores`\ndf_scores[df_scores['brewery_name']=='Monastyrskiy Kvas']\n\n\n# Highlight important row\ndf_scores[df_scores['brewery_name']=='Monastyrskiy Kvas'].style.apply(\n    lambda x: ['background: lightgreen' if x.name == 40781 else '' for i in x], \n    axis=1)","2aada673":"# Look up data on 'Stella Artois' from `df_scores`\ndf_scores[df_scores['brewery_name']=='Stella Artois']\n\n\n# Highlight important row\ndf_scores[df_scores['brewery_name']=='Stella Artois'].style.apply(\n    lambda x: ['background: lightgreen' if x.name == 55651 else '' for i in x], \n    axis=1)","cd558022":"# Edit `Name` column for `Stella Artois` and `Monastyrskiy Kvas` on `df_profile`\ndf_profile.loc[[1803, 2150],'Name'] = df_profile.loc[[1803, 2150],'Brewery']","ecc5ca3e":"# Create new column on `df_profile` indicating whether the brewery name exists on `df_scores`\ndf_profile['brewery_review_exists'] = np.where(df_profile['Brewery'].isin(list(df_scores['brewery_name'].unique())), 1, 0)\n\n\n# Formatting for better display\nslice_ = 'brewery_review_exists'\n\ndef highlight_indicator(val):\n    pink = 'background-color: pink' if val < 1 else ''\n    return pink\n\ndf_profile.head(10).style.set_properties(**{'background-color': '#ffffb3'}, subset=slice_)\\\n                         .applymap(highlight_indicator, subset=[slice_])","f3475807":"# Create new data frame (`brewery_no_scores`) listing breweries on `df_profile` with no exact match on `df_scores`\nbrewery_no_scores = pd.DataFrame(df_profile[df_profile['brewery_review_exists']==0]['Brewery'].unique()).set_axis(['Brewery'], axis=1)\nbrewery_no_scores","8635569b":"# Fuzzy matching\ndef fuzzy_merge(df_1, df_2, key1, key2, threshold=90, limit=1):\n    \"\"\"\n    :param df_1: the left table to join\n    :param df_2: the right table to join\n    :param key1: key column of the left table\n    :param key2: key column of the right table\n    :param threshold: how close the matches should be to return a match, based on Levenshtein distance\n    :param limit: the amount of matches that will get returned, these are sorted high to low\n    :return: dataframe with boths keys and matches\n    \"\"\"\n    s = df_2[key2].tolist()\n    \n    m = df_1[key1].apply(lambda x: process.extract(x, s, limit=limit))    \n    df_1['matches'] = m\n    \n    m2 = df_1['matches'].apply(lambda x: ', '.join([i[0] for i in x if i[1] >= threshold]))\n    df_1['matches'] = m2\n    \n    return df_1","877472c6":"# Create new column on `df_scores` indicating whether the brewery name exists on `df_profile`\ndf_scores['brewery_profile_exists'] = np.where(df_scores['brewery_name'].isin(list(df_profile['Brewery'].unique())), 1, 0)\n\n# Create new data frame (`brewery_no_profile`) listing breweries on `df_scores` with no exact match on `df_profile`\nbrewery_no_profile = pd.DataFrame(df_scores[df_scores['brewery_profile_exists']==0]['brewery_name'].unique()).set_axis(['Brewery'], axis=1)","bae8e911":"# # (Uncomment to let pandas display all rows and column content for all data frames)\n# pd.set_option('display.max_rows', None)\n# pd.set_option('display.max_colwidth', None)\n\n# # (Default setting)\n# pd.set_option('display.max_rows', 10)\n# pd.set_option('display.max_colwidth', 50)","ac6a3978":"# # Get fuzzy matches for 543 breweries\n# # Warning: Takes a long time to run\n# fuzzy_match_brewery = fuzzy_merge(brewery_no_scores, brewery_no_profile, 'Brewery', 'brewery_name', threshold=88, limit=1)\n# fuzzy_match_brewery.to_csv(your_data_dir \/ 'Brewery Fuzzy Match List.csv', index=False)","f7d36e4e":"# Load table containing saved brewery name matches (\"Brewery Name Fuzzy Match List.csv\")\nfuzzy_match_brewery = pd.read_csv(data_dir \/ \"beer-profile-and-ratings-data-set\/Brewery Name Fuzzy Match List.csv\")\nfuzzy_match_brewery","7032e5d8":"# Save table as dictionary\nfuzzy_match_dict = dict(zip(fuzzy_match_brewery['Brewery'], fuzzy_match_brewery['matches']))\n\n# Replace relevant brewery names in `df_profile`\ndf_profile['Brewery'] = df_profile['Brewery'].replace(fuzzy_match_dict)","79b3aed6":"# Additionally, manually replace \"Yuengling Brewery \" with \"Yuengling Brewery\" (no space) in both `df_profile` and `df_scores`\ndf_profile['Brewery'] = df_profile['Brewery'].replace({'Yuengling Brewery ': 'Yuengling Brewery'})\ndf_scores['brewery_name'] = df_scores['brewery_name'].replace({'Yuengling Brewery ': 'Yuengling Brewery'})","803a0520":"# Correcting 'brewery_review_exists' indicator column values on `df_profile` after using fuzzy matches\ndf_profile['brewery_review_exists'] = np.where(df_profile['Brewery'].isin(list(df_scores['brewery_name'].unique())), 1, 0)\n\n# Correcting 'brewery_profile_exists' indicator column values on `df_scores` after using fuzzy matches\ndf_scores['brewery_profile_exists'] = np.where(df_scores['brewery_name'].isin(list(df_profile['Brewery'].unique())), 1, 0)","c53d5538":"# Remove all brews from breweries that are not listed in either `df_profile` or `df_scores`\ndf_scores.drop(df_scores[df_scores['brewery_profile_exists']==0].index, axis=0, inplace=True)\ndf_profile.drop(df_profile[df_profile['brewery_review_exists']==0].index, axis=0, inplace=True)","678a98ac":"# Create new identifier column in `df_scores` called 'beer_name_full'\n# Fill column by concatenating `brewery_name` and `beer_name`\ndf_scores['beer_name_full'] = df_scores['brewery_name'] + ' ' + df_scores['beer_name']\n\n# Check if all generated brew names in df_scores are unique:\ndf_scores['beer_name_full'].nunique() == len(df_scores.index)","62a268fa":"# Create new identifier column in `df_profile` called 'Beer Name (Full)' \n# Fill column by concatenating `Brewery` and `Name`\ndf_profile['Beer Name (Full)'] = df_profile['Brewery'] + ' ' + df_profile['Name']\n\n# Check if all generated brew names in `df_profile` are unique:\ndf_profile['Beer Name (Full)'].nunique() == len(df_profile.index)","753592d5":"# Check duplicated brew name\ndf_profile[df_profile['Beer Name (Full)'].duplicated()]","bf402bc1":"# List rows with duplicated brew name\ndf_profile[df_profile['Beer Name (Full)']=='Sweetwater Tavern & Brewery Crazy Jackass Ale']\n\n\n# Highlight row with error\ndf_profile[df_profile['Beer Name (Full)']=='Sweetwater Tavern & Brewery Crazy Jackass Ale'].style.apply(\n    lambda x: ['background: pink' if x.name == 4056 else '' for i in x], \n    axis=1)","47c24ebf":"# Remove duplicate row containing error (missing data)\ndf_profile.drop(4056, inplace=True)","ac4bdd1d":"# Create new column on `df_profile` indicating whether the complete brew name exists on `df_scores`\ndf_profile['beer_review_exists'] = np.where(df_profile['Beer Name (Full)'].isin(list(df_scores['beer_name_full'])), 1, 0)\n\n\n# Formatting for better display\nslice_ = 'beer_review_exists'\n\ndf_profile.head(10).style.set_properties(**{'background-color': '#ffffb3'}, subset=slice_)\\\n                         .applymap(highlight_indicator, subset=[slice_])","c24903d9":"# Create new data frame (`beer_no_scores`) listing brews on `df_profile` with no exact match on `df_scores`\nbeer_no_scores = pd.DataFrame(df_profile[df_profile['beer_review_exists']==0]['Beer Name (Full)']).set_axis(['Beer Name (Full)'], axis=1)\nbeer_no_scores","b95746af":"# Create new column on `df_scores` indicating whether the complete brew name exists on `df_profile`\ndf_scores['beer_profile_exists'] = np.where(df_scores['beer_name_full'].isin(list(df_profile['Beer Name (Full)'])), 1, 0)\n\n# Create new data frame (`beer_no_profile`) listing brews on `df_scores` with no exact match on `df_profile`\nbeer_no_profile = pd.DataFrame(df_scores[df_scores['beer_profile_exists']==0]['beer_name_full']).set_axis(['beer_name_full'], axis=1)","7d9e9208":"# # Get fuzzy matches for 2460 brews\n# # Warning: Takes a long time to run\n# fuzzy_match_beer_name = fuzzy_merge(beer_no_scores, beer_no_profile, 'Beer Name (Full)', 'beer_name_full', threshold=87, limit=1)\n# fuzzy_match_beer_name.to_csv(your_data_dir \/ 'Beer Name Fuzzy Match List.csv', index=False)","dfb3b438":"fuzzy_match_beer_name = pd.read_csv(data_dir \/ 'beer-profile-and-ratings-data-set\/Beer Name Fuzzy Match List.csv')\nfuzzy_match_beer_name","a431626c":"# Save table as dictionary\nfuzzy_match_dict = dict(zip(fuzzy_match_beer_name['Beer Name (Full)'], fuzzy_match_beer_name['matches']))\n\n# Replace relevant brewery names in `df_profile`\ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace(fuzzy_match_dict)","69e5d21a":"# Additionally, manually replace some beer names (containing spacing errors) in both `df_profile` and `df_scores`\ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace({'Panil  Barriqu\u00e9e (Sour Version)': 'Panil Barriqu\u00e9e (Sour Version)'})\ndf_scores['beer_name_full'] = df_scores['beer_name_full'].replace({'Panil Panil Barriqu\u00e9e (Sour Version)': 'Panil Barriqu\u00e9e (Sour Version)'})\n\ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace({'Panil  Barriqu\u00e9e (Italy Version)': 'Panil Barriqu\u00e9e (Italy Version)'})\ndf_scores['beer_name_full'] = df_scores['beer_name_full'].replace({'Panil Panil Barriqu\u00e9e  (Italy Version)': 'Panil Barriqu\u00e9e (Italy Version)'})\n                                                                                                                                   \ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace({'Unibroue  17 Grande R\u00e9serve': 'Unibroue 17 Grande R\u00e9serve'})\ndf_scores['beer_name_full'] = df_scores['beer_name_full'].replace({'Unibroue Unibroue 17 Grande R\u00e9serve': 'Unibroue 17 Grande R\u00e9serve'})\n\ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace({'Schorschbr\u00e4u  Schorschbock 57%': 'Schorschbr\u00e4u Schorschbock 57%'})\ndf_scores['beer_name_full'] = df_scores['beer_name_full'].replace({'Schorschbr\u00e4u Schorschbr\u00e4u Schorschbock 57%': 'Schorschbr\u00e4u Schorschbock 57%'})\n\ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace({\"Alexander Keith's  India Pale Ale\": \"Alexander Keith's India Pale Ale\"})\ndf_scores['beer_name_full'] = df_scores['beer_name_full'].replace({\"Alexander Keith's Alexander Keith's India Pale Ale\": \"Alexander Keith's India Pale Ale\"})\n\ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace({'Schorschbr\u00e4u  Schorschbock 31%': 'Schorschbr\u00e4u Schorschbock 31%'})\ndf_scores['beer_name_full'] = df_scores['beer_name_full'].replace({'Schorschbr\u00e4u Schorschbr\u00e4u Schorschbock 31%': 'Schorschbr\u00e4u Schorschbock 31%'})\n\ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace({'Klosterbrauerei Andechs Andechser Dunkles Weissbier': 'Klosterbrauerei Andechs Andechs Weissbier Dunkel'})\ndf_scores['beer_name_full'] = df_scores['beer_name_full'].replace({'Klosterbrauerei Andechs Andechser  Dunkles Weissbier': 'Klosterbrauerei Andechs Andechs Weissbier Dunkel'})\n\ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace({\"St. Georgenbr\u00e4u St. Georgenbr\u00e4u Keller Bier\": \"St. Georgenbr\u00e4u Buttenheimer Keller Bier\"})\ndf_scores['beer_name_full'] = df_scores['beer_name_full'].replace({\"St. Georgenbr\u00e4u St. Georgenbr\u00e4u  Keller Bier\": \"St. Georgenbr\u00e4u Buttenheimer Keller Bier\"})\n\ndf_profile['Beer Name (Full)'] = df_profile['Beer Name (Full)'].replace({'Weisses Br\u00e4uhaus G. Schneider & Sohn GmbH Schneider Weisse Mein Alkoholfreies': 'Weisses Br\u00e4uhaus G. Schneider & Sohn GmbH Schneider Weisse Mein Alkoholfreies'})\ndf_scores['beer_name_full'] = df_scores['beer_name_full'].replace({'Weisses Br\u00e4uhaus G. Schneider & Sohn GmbH Schneider Weisse  Mein Alkoholfreies': 'Weisses Br\u00e4uhaus G. Schneider & Sohn GmbH Schneider Weisse Mein Alkoholfreies'})","a75ee5d9":"# Correcting 'beer_review_exist' indicator column values on `df_profile` after using fuzzy matches\ndf_profile['beer_review_exists'] = np.where(df_profile['Beer Name (Full)'].isin(list(df_scores['beer_name_full'].unique())), 1, 0)\n\n# Correcting 'beer_profile_exists' indicator column values on `df_scores` after using fuzzy matches\ndf_scores['beer_profile_exists'] = np.where(df_scores['beer_name_full'].isin(list(df_profile['Beer Name (Full)'].unique())), 1, 0)","d2ff985d":"# Remove all brews that are not listed in either `df_profile` or `df_scores`\ndf_scores.drop(df_scores[df_scores['beer_profile_exists']==0].index, axis=0, inplace=True)\ndf_profile.drop(df_profile[df_profile['beer_review_exists']==0].index, axis=0, inplace=True)","63f16246":"len(df_scores.index)","8371a21e":"len(df_profile.index)","df2a5c09":"# Drop columns that are redundant or no longer neccessary\ndf_profile.drop(['key', 'Style Key', 'brewery_review_exists', 'beer_review_exists', 'Ave Rating'], axis=1, inplace=True)\ndf_scores.drop(['brewery_name', 'beer_name', 'brewery_profile_exists', 'beer_profile_exists'], axis=1, inplace=True)\n\n\ndf_scores.rename(columns={\"beer_name_full\": \"Beer Name (Full)\"}, inplace=True)","75ab9c89":"# Join data frames to make new dataset\ndf_final = pd.merge(df_profile, df_scores, how='left', on=['Beer Name (Full)'])\n\n# Re-arrange column order\ndf_final = df_final[['Name', 'Style', 'Brewery', 'Beer Name (Full)', \n                     'Description', 'ABV', 'Min IBU', 'Max IBU', \n                     'Astringency', 'Body', 'Alcohol', \n                     'Bitter', 'Sweet', 'Sour', 'Salty', 'Fruits', 'Hoppy', 'Spices', 'Malty', \n                     'review_aroma','review_appearance', 'review_palate', 'review_taste', 'number_of_reviews', 'review_overall']]","bb0623fe":"# Resulting dataset:\ndf_final","93a89d44":"# df_final.to_csv(your_data_dir \/ 'beer_profile_and_ratings.csv', index=False)","7b987da9":"The complete resulting dataset is available [here](https:\/\/www.kaggle.com\/ruthgn\/beer-profile-and-ratings-data-set).","9b298f23":"Now we're going to match brewery names from both data frames.","89fcfb27":"After manually going through the fuzzy matches, we found 87 correct matches and saved them as a .csv file called \"Brewery Name Fuzzy Match List.csv\" (to save time from having to run the code each time and re-do some manual corrections). We're going to replace the brewery names in `df_scores` with their equivalents from `df_profile`.","e799bbe3":"At this stage, we can remove all brews with incomplete data (i.e., those with no entry matches between `df_profile` and `df_scores`).","8cc5131c":"From looking at the tables, we know that the appropriate review data match for each brew lies in the row with highest the `number_of_reviews` on `df_scores` (see highlighted rows above). Let's go ahead and apply an identical label format for the two brews on `df_profile`:","d3fa46a2":"Source: [1.5 Million Beer Reviews](https:\/\/www.kaggle.com\/rdoume\/beerreviews) by Tanya Cashorali (uploaded by [Datadoume](https:\/\/www.kaggle.com\/rdoume)).\n\nOur first dataset contains 1.5 million beer reviews from *BeerAdvocate*. Each individual review includes appearance, aroma, palate, and taste scores, as well as an overall review score.","fd98a4fc":"We ended up with a total of 3197 unique brews from 934 different breweries with in one table:","3653584a":"This notebook outlines how the [Beer Profile and Ratings Dataset](https:\/\/www.kaggle.com\/ruthgn\/beer-profile-and-ratings-data-set) was created--specifically the data wrangling process in integrating the existing datasets below:\n* [1.5 Million Beer Reviews](https:\/\/www.kaggle.com\/rdoume\/beerreviews)\n* [Beer Tasting Profiles Dataset](https:\/\/www.kaggle.com\/stephenpolozoff\/top-beer-information)\n\nThe purpose of the data integration is to create a new dataset that contains consumer ratings and reviews for different brews, combined with their detailed tasting profiles.","7478a99d":"Fantastic! We have an identical number of rows from each data frame. We also know the brew name labels are consistent on both data frames now. All we need to do now is to join all the columns we want to have in our new dataseet.","ad5726b2":"# Joining Datasets","b8b92f9d":"Source: [Beer Tasting Profiles Dataset](https:\/\/www.kaggle.com\/stephenpolozoff\/top-beer-information) by [sp1222](https:\/\/www.kaggle.com\/stephenpolozoff).\n\nThe second dataset we're going to use contains tasting profiles of up to 50 top-rated beers across 112 styles, 5558 beers in total, scrapped from *BeerAdvocate*. The first ten columns provide information on the beer provided by the source, along with contributed information like a unique key for each beer and style. The last eleven columns represent the tasting profile features of the beer, and are defined by word counts found in up to 25 reviews of each beer. The assumption is that people writing reviews are more than likely describing what they do experience rather than what they do not. Note that one or two styles did not have 50 beers to collect information on, and that few beers may have had limited or no reviews available to define features with.","deec3765":"## Matching brewery names","9fc2ab98":"To speed up all upcoming data processing, we will remove rows on `df_scores` with brewery names that don't exist in `df_profiles` at all. Similarly, we're also removing rows on `df_profiles` with breweries that don't exist `df_scores`. We are removing these brews because we won't have their appropriate data points for our desired integration.","64a080c2":"It's time to match our brew names (unique identifiers) from `df_profile` with the ones that exist on `df_scores`. We're going to follow a process similar to the one we've applied on the brewery names earlier.","b0d9ad87":"As mentioned previously, in order to integrate information from both datasets, we need to create a unique identifier for every single brew. We will concatenate the brewery name and beer name to create this unique identifier.","dc7ce922":"# Data Cleaning","bb03e7d0":"## Beer Profile Data","a8b08085":"# Introduction","c246bd6a":"This time, we found 1088 correct beer name matches and saved them as a .csv file called \"Beer Name Fuzzy Match List.csv\". Let's replace the beer names in `df_scores` with their equivalents from `df_profile`.","76cd7518":"## Matching beer names (brews)","e1a4f593":"We need to aggregate the data because it contains multiple reviews for a single brew. We'll do this getting the average scores of each brew.","6f508556":"## Imports and Configuration","787a6b63":"## Beer Reviews Data","a82cd78d":"We want to check if some of the breweries on the previous list *actually* have corresponding data on `df_scores` without having the *exact* same brewery name labels (caused by typos, character errors, inconsistent labelling, etc.). This is where the Python library [FuzzyWuzzy](https:\/\/github.com\/seatgeek\/fuzzywuzzy) comes in handy. We will create a new function to find \"fuzzy\" matches for the remaining 543 breweries on `df_profile`.","3c61e445":"Our goal is to match as many brews from `df_profile` with the available beer ratings data from `df_scores`.\n\nTo create a unique identifier for every single brew on both data frames, we need to concatenate the brewery name and the beer name. The `Amber` beer by `Alaskan Brewing Co.` on the first row of `df_profile` above, for example, will be identified as `Alaskan Brewing Co. Amber`.\n\nBefore we proceed with that, however, there are several checks we need to perform to make sure that the concatenation will yield unique identifiers that are (somewhat) consistent accross both data frames for optimum results:\n1. Check rows with missing data on `Name` column on `df_profile`.\n2. Match brewery names from both data frames."}}