{"cell_type":{"a6f8042e":"code","6f702862":"code","b61f3041":"code","2824ca7a":"code","a3680eab":"code","52f25fbf":"code","9c7d24b7":"code","72bc60fa":"code","ac76e766":"code","634ce353":"code","56238dde":"code","117f7afa":"code","6daa58cd":"code","fc9620c8":"code","fbd0274b":"code","a9af8580":"code","2483663e":"markdown"},"source":{"a6f8042e":"!pip install icevision[all]\n!pip install matplotlib==3.1.3\n!pip install tqdm==4.45.0","6f702862":"import os\nimport random\nimport cv2\nimport warnings\nimport torch\nimport numpy as np\nimport pandas as pd\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nimport pytorch_lightning as pl\n\nfrom tqdm import tqdm_notebook as tqdm\nfrom sklearn.model_selection import GroupKFold\nfrom icevision.all import *\n\nwarnings.filterwarnings('ignore')","b61f3041":"SEED = 2021\nDEBUG = False\nIMG_DIM = 512\nBATCH_SIZE = 16\nNUM_WORKERS = 4\nN_FOLDS = 5\nFOLDS_IDS = [0]\nLR = 1e-4\nNUM_EPOCHS = 20\nDEVICE = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n\ndef seed_everything(seed):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = True\n\nseed_everything(SEED)","2824ca7a":"source = Path(\"..\/input\/vinbigdata-512-png\")\n\ntrain_df = pd.read_csv(source \/ 'train.csv')\ntest_df = pd.read_csv(source \/ 'test.csv')\nsubmission_df = pd.read_csv(source \/ 'sample_submission.csv')\n\nsubmission_df.head()","a3680eab":"if DEBUG:\n    submission_df = submission_df[:20]","52f25fbf":"class VinBigDataFilepathParser(parsers.Parser, parsers.FilepathMixin):\n    pass\n\nVinBigDataFilepathParser.generate_template()","9c7d24b7":"class VinBigDataFilepathParser(parsers.Parser, parsers.FilepathMixin):\n    def __init__(self, df, source):\n        self.df = df\n        self.source = source\n\n    def __iter__(self):\n        yield from self.df.itertuples()\n\n    def __len__(self):\n        return len(self.df)\n\n    def imageid(self, o) -> Hashable:\n        return o.image_id\n\n    def filepath(self, o) -> Union[str, Path]:\n        return self.source \/ f\"{o.image_id}.png\"\n\n    def image_width_height(self, o) -> Tuple[int, int]:\n        return get_image_size(self.filepath(o))","72bc60fa":"parser = VinBigDataFilepathParser(submission_df, source \/ \"test\")\nrecords = parser.parse(data_splitter=None, idmap=None, autofix=True, show_pbar=True, cache_filepath=None)\ntest_rs = records[0] + records[1]","ac76e766":"# imagenet normalization params are used\n\npresize = 512\nsize = 384\n\ninfer_tfms = tfms.A.Adapter([*tfms.A.resize_and_pad(size), tfms.A.Normalize()])","634ce353":"infer_ds = Dataset(test_rs, infer_tfms)","56238dde":"train_df = train_df[train_df.class_id!=14].reset_index(drop = True)\nIDX_TO_CLASS = dict(sorted(list(zip(list(train_df['class_id'].unique()), list(train_df['class_name'].unique())))))\nclass_map = ClassMap(list(IDX_TO_CLASS.values()), background=None)","117f7afa":"backbone = backbones.resnet_fpn.resnext50_32x4d(pretrained=False)\nmodel = faster_rcnn.model(backbone=backbone, num_classes=len(class_map))\n\ncheckpoint_path = '..\/input\/vinbigdata-eda-faster-rcnn-icevision-training\/frcnn-best-model-fold0-epoch=58.ckpt'\ncheckpoint = torch.load(checkpoint_path, map_location=torch.device(DEVICE))\n\nnew_state_dict = OrderedDict()\nfor key, value in checkpoint['state_dict'].items():\n    if key.startswith('model.'):\n        new_key = key[6:]\n        new_state_dict[new_key] = value\n    else:\n        new_state_dict[key] = value\n        \nmodel.load_state_dict(new_state_dict, strict=False)","6daa58cd":"# predict in batches\ninfer_dl = faster_rcnn.infer_dl(infer_ds, batch_size=1, shuffle=False)\n_, preds = faster_rcnn.predict_dl(model=model, infer_dl=infer_dl, detection_threshold=0.5)","fc9620c8":"# prepare submission file\n\nfor idx, pred in tqdm(enumerate(preds)):\n    \n    if len(pred['labels']) == 0:\n        continue\n        \n    image_idx = dict(test_rs[idx])['imageid']\n    image_id = submission_df.iloc[image_idx]['image_id']\n    original_width, original_height = test_df.loc[test_df['image_id'] == image_id][['width', 'height']].values[0]\n            \n    s = ''\n    for label, score, bbox in zip(pred['labels'], pred['scores'], pred['bboxes']):\n        bbox = vars(bbox)\n        xmin = int(bbox['xmin']*(original_width\/size))\n        ymin = int(bbox['ymin']*(original_height\/size))\n        xmax = int(bbox['xmax']*(original_width\/size))     \n        ymax = int(bbox['ymax']*(original_height\/size))\n\n        values_list = [label, np.round(score, 2), xmin, ymin, xmax, ymax]\n        s += ' '.join(map(str, values_list))\n        s += ' '\n    \n    submission_df.iloc[image_idx]['PredictionString'] = s.strip()","fbd0274b":"submission_df.head()","a9af8580":"submission_df.to_csv('submission.csv', index=False)","2483663e":"This kernel is based on my previous one [VinBigData: EDA, Faster-RCNN, icevision [training]](https:\/\/www.kaggle.com\/mariazorkaltseva\/vinbigdata-eda-faster-rcnn-icevision-training)"}}