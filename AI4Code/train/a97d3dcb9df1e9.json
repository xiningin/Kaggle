{"cell_type":{"05d35a41":"code","46155ba8":"code","11f44b54":"code","038d54a1":"code","ce732105":"code","911f634a":"code","363b3ec0":"code","10a20a1b":"code","b3d42fd9":"code","83162f20":"code","8ab15aeb":"code","b2c5128b":"code","18634be9":"code","9bf4c52d":"code","05559a5c":"code","47ff322c":"code","d305502f":"code","d6b5ae60":"code","2c939c56":"code","3a6c7d1e":"code","1c5b5ed9":"code","68cdc446":"code","a37f74ab":"markdown","6d1fd13b":"markdown","7579079a":"markdown","00f0b106":"markdown","5fe3c763":"markdown","893efcc9":"markdown"},"source":{"05d35a41":"import numpy as np\nimport pandas as pd\nimport os\nimport cv2\n\nimport matplotlib.pyplot as plt","46155ba8":"from sklearn.model_selection import train_test_split\nfrom scipy.ndimage.filters import maximum_filter\nimport skimage.measure\nfrom scipy.signal import convolve2d","11f44b54":"features = {}","038d54a1":"for file in np.array(list(os.walk('..\/input\/basicshapes\/shapes')))[1:]:\n    directory = file[0]\n    type = file[0].split('\/')[-1]\n    if(type not in features.keys()):\n        features[type] = []\n    for img in file[2]:\n        features[type].append(cv2.imread(directory + '\/' + img, cv2.IMREAD_GRAYSCALE))\n","ce732105":"features.keys()","911f634a":"# Display a triangle\nf, axarr = plt.subplots(1,3, figsize=(12, 12))\naxarr[0].set_title('Triangle')\naxarr[0].imshow(features['triangles'][1])\naxarr[1].set_title('Square')\naxarr[1].imshow(features['squares'][1])\naxarr[2].set_title('Circle')\naxarr[2].imshow(features['circles'][1])","363b3ec0":"X = np.array(features['triangles'] + features['squares'] + features['circles'])\ny = np.array([[1, 0, 0]] * len(features['triangles']) + [[0, 1, 0]] * len(features['squares']) + [[0, 0, 1]] * len(features['circles']))","10a20a1b":"# normalization\nX = X \/ 255.0","b3d42fd9":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)","83162f20":"def relu(x):\n    mask = (x>0) * 1.0 \n    return x * mask\n\ndef drelu(x):\n    mask = (x>0) * 1.0 \n    return  mask","8ab15aeb":"def sigmoid(z):\n    return 1.0 \/ (1 + np.exp(-z))\n\ndef dsigmoid(z):\n    return sigmoid(z) * (1-sigmoid(z))","b2c5128b":"def softmax(s): \n    exps = np.exp(s - np.max(s, axis=1, keepdims=True))\n    return exps\/np.sum(exps, axis=1, keepdims=True)\n\ndef cross_entropy(pred, real):\n    n_samples = real.shape[0]\n    res = pred - real\n    return res\/n_samples","18634be9":"def forward(x, theta):\n    k, w1, w2, w3, b1, b2, b3 = theta\n\n    # conv2d\n    m = np.array([convolve2d(x[i], k, mode='valid') for i in range(len(x))])\n    n = relu(m)\n    \n    # maxpool\n    o = np.array([skimage.measure.block_reduce(n[i], (2,2), np.max) for i in range(len(n))])\n\n    # flatten\n    f = o.reshape(o.shape[0], 121)\n\n    # layers\n    p = f.dot(w1) + b1\n    q = sigmoid(p)\n\n    r = q.dot(w2) + b2\n    s = sigmoid(r)\n\n    t = s.dot(w3) + b3\n    u = softmax(t)\n\n    return m, n, o, p, q, r, s, t, u","9bf4c52d":"def backward(x, y, theta):\n    k, w1, w2, w3, b1, b2, b3 = theta\n\n    m, n, o, p, q, r, s, t, u = forward(x, theta)\n\n    dloss = cross_entropy(u, y)\n\n    dt = w3.dot(dloss.T).T\n    ds = dt * dsigmoid(r)\n    dr = w2.dot(ds.T).T\n    dq = dr * dsigmoid(p)\n    dp = w1.dot(dq.T).T\n\n    db3 = dloss\n    dw3 = dloss.T.dot(s).T\n\n    db2 = ds\n    dw2 = ds.T.dot(q).T\n\n    db1 = dq\n    dw1 = dq.T.dot(o.reshape(o.shape[0], 121)).T\n\n    masks = np.array([np.equal(n[i], o[i].repeat(2, axis=0).repeat(2, axis=1)).astype(int) for i in range(len(n))])\n    windows = np.array([masks[i] * dp[i].reshape(11,11).repeat(2, axis=0).repeat(2, axis=1) for i in range(len(masks))])\n\n    dks = np.array([np.rot90(convolve2d(x[i],np.rot90(windows[i] * n[i],2 ),mode='valid'),2) for i in range(len(windows))])\n    dk = np.mean(dks, axis=0)\n\n    return dk, dw1, dw2, dw3, db1, db2, db3","05559a5c":"np.random.seed(123213131)\n\nk = np.random.uniform(size=(7,7))\n\nw1 = np.random.uniform(size=(121, 64)) * np.sqrt(1.\/ 121.)\nb1 = np.random.uniform(size=(1, 64)) * np.sqrt(1.\/ 64.)\n\nw2 = np.random.uniform(size=(64, 32)) * np.sqrt(1.\/ 64.)\nb2 = np.random.uniform(size=(1, 32)) * np.sqrt(1.\/ 32.)\n\nw3 = np.random.uniform(size=(32, 3)) * np.sqrt(1.\/ 32.)\nb3 = np.random.uniform(size=(1, 3)) * np.sqrt(1.\/ 3.)\n\ntheta = k, w1, w2, w3, b1, b2, b3","47ff322c":"def optimize(grads, theta, lr=0.5):\n    theta = tuple([theta[i] - (grads[i] * lr) for i in range(len(theta))])\n    \n    return theta","d305502f":"def error(pred, real):\n    n_samples = real.shape[0]\n    logp = - np.log(pred[np.arange(n_samples), real.argmax(axis=1)])\n    loss = np.sum(logp)\/n_samples\n    return loss","d6b5ae60":"losses = []","2c939c56":"for e in range(5000):\n    grads = backward(X_train, y_train, theta)\n    theta = optimize(grads, theta)\n    if(e % 500 == 0):\n        l = error(forward(X_train, theta)[-1], y_train)\n        losses.append(l)\n        print(\"Epoch: {0}, Loss: {1}\".format(e, l))","3a6c7d1e":"plt.plot(losses)","1c5b5ed9":"preds = np.argmax(forward(X_train, theta)[-1], axis=1)\nreal = np.argmax(y_train, axis=1)","68cdc446":"print(\"Accuracy: \", (preds == real).sum() \/ len(preds))","a37f74ab":"# Activation Functions and Derivatives","6d1fd13b":"# Backward Propagation","7579079a":"# CNN Geometrical Shapes from Scratch","00f0b106":"# Forward Propagation","5fe3c763":"# Accuracy","893efcc9":"# Data Preparation"}}