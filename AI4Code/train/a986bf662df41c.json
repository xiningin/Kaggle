{"cell_type":{"244a9d9c":"code","6f610e7c":"markdown"},"source":{"244a9d9c":"import signal\nimport sys\nimport time\nimport threading\nfrom queue import Queue\n\ninitially_granted_proc = \"A\"\nprocs = {\"A\", \"B\", \"C\"}\nresource_usage_counts = {\"A\": 0, \"B\": 0, \"C\": 0}\nmessage_queues = {\"A\" : Queue(), \"B\": Queue(), \"C\": Queue()}\n\nclass Message(object):\n    def __init__(self, msg_type, timestamp, sender, receiver):\n        self.msg_type = msg_type\n        self.timestamp = timestamp\n        self.sender = sender\n        self.receiver = receiver\n\n    def __repr__(self):\n        return \"Message {} at {} from {} to {}\".format(\n            self.msg_type, self.timestamp, \n            self.sender, self.receiver)\n\nclass Process(threading.Thread):\n\n    def __init__(self, name, initially_granted, other_processes):\n        super(Process, self).__init__()\n        self.name = name\n        self.has_resource = initially_granted == name\n        self.other_processes = other_processes\n        self.lamport_clock = 0 # tick after each \"event\"\n        self.request_queue = []\n        self.requested = False\n        self.request_queue.append(Message(\"request\", \n            -1, initially_granted, initially_granted))\n\n    def remove_request(self, msg_type, sender):\n        index_of_req = -1\n        for i in range(len(self.request_queue)):\n            if self.request_queue[i].msg_type == msg_type and \\\n               self.request_queue[i].sender == sender:\n                index_of_req = i\n                break\n        if i == -1:\n            print(\"Unable to remove\") \n        else:\n            del self.request_queue[i]\n\n    def use_resource(self):\n        print(\"Process {} is using resource\".format(self.name))\n        resource_usage_counts[self.name] += 1\n        time.sleep(2)\n\n    def process_message(self, msg):\n        # Based on msg_type handle appropriately\n        if msg.msg_type == \"request\":\n            # Put in our request queue and send an ack \n            # to the sender\n            self.request_queue.append(msg)\n            for proc in self.other_processes:\n                if proc == msg.sender:\n                    message_queues[proc].put(Message(\n                        \"ack\", self.lamport_clock, \n                        self.name, msg.sender))\n        elif msg.msg_type == \"release\":\n            # Got a release, remove it from our queue\n            self.remove_request(\"request\", msg.sender)\n        elif msg.msg_type == \"ack\":\n            pass\n        else:\n            print(\"Unknown message type\")\n\n    def run(self):\n        while True:\n            if self.has_resource:\n                self.use_resource()\n                self.remove_request(\"request\", self.name)\n                # Tell everyone that we are done\n                for proc in self.other_processes:\n                    message_queues[proc].put(Message(\n                        \"release\", self.lamport_clock, \n                        self.name, proc))\n                    self.lamport_clock += 1\n                self.has_resource, self.requested = False, False\n                continue\n            # Want to get the resource\n            if not self.requested:\n                # Request it\n                print(\"Process {} requesting resource\".format(\n                    self.name))\n                self.request_queue.append(Message(\n                    \"request\", self.lamport_clock, \n                    self.name, self.name))\n                # Broadcast this request\n                for proc in self.other_processes:\n                    message_queues[proc].put(Message(\n                        \"request\", self.lamport_clock, \n                        self.name, proc))\n                    self.lamport_clock += 1\n                self.requested = True\n            else:\n                # Just wait until it is available by processing messages\n                print(\"Process {} waiting for message\".format(self.name))\n                msg = message_queues[self.name].get(block=True)        \n                # Got a message, check if the timestamp \n                # is greater than our clock, if so advance it\n                if msg.timestamp >= self.lamport_clock:\n                    self.lamport_clock = msg.timestamp + 1\n                print(\"Got message {}\".format(msg))\n                self.process_message(msg)\n                self.lamport_clock += 1\n                # Check after processing if the resource is \n                # available for me now, if so, grab it.\n                # We need earliest request to be ours and check that we \n                # have received an older message from everyone else \n                if self.check_available():\n                    print(\"Resource available for {}\".format(self.name))\n                    self.has_resource = True\n            print(\"Process {}: {}\".format(self.name, self.request_queue))\n            print(\"Process {} Clock: {}\".format(self.name, self.lamport_clock))\n            time.sleep(1)\n\n    def check_available(self):\n        got_older = {k: False for k in self.other_processes}\n        # Get timestamp of our req\n        our_req = None\n        for req in self.request_queue:\n            if req.sender == self.name:\n                our_req = req\n        if our_req is None:\n            return False\n        # We found our req make sure it is younger than \n        # all the others and we have an older one from \n        # the other guys\n        for req in self.request_queue:\n            if req.sender in got_older and req.timestamp > our_req.timestamp:\n                got_older[req.sender] = True\n        if all(got_older.values()):\n            return True\n        return False\n\nt1 = Process(\"A\", initially_granted_proc, list(procs - set(\"A\")))\nt2 = Process(\"B\", initially_granted_proc, list(procs - set(\"B\")))\nt3 = Process(\"C\", initially_granted_proc, list(procs - set(\"C\")))\n\n# Daemonizing threads means that if main thread dies, so do they. \n# That way the process will exit if the main thread is killed.\nt1.setDaemon(True)\nt2.setDaemon(True)\nt3.setDaemon(True)\n\ntry:\n    t1.start()\n    t2.start()\n    t3.start()\n    while True:\n        # Need some arbitrary timeout here, seems a bit hackish. \n        # If we don't do this then the main thread will just block \n        # forever waiting for the threads to return and the \n        # keyboardinterrupt never gets hit. Interestingly regardless of the \n        # timeout, the keyboard interrupt still occurs immediately \n        # upon ctrl-c'ing\n        t1.join(30)\n        t2.join(30)\n        t3.join(30)\nexcept KeyboardInterrupt:\n    print(\"Ctrl-c pressed\")\n    print(\"Resource usage:\")\n    print(resource_usage_counts)\n    sys.exit(1)","6f610e7c":"# Lamport's Logical Clock\n\n## LCS-Connorwstein"}}