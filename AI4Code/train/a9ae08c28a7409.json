{"cell_type":{"090752bb":"code","27b5023e":"code","fc9cc77b":"code","a6da9f83":"code","5cee34b9":"code","2f8c6114":"code","be815ebd":"code","ba292ff2":"code","4c5934ec":"code","5722f72d":"code","a98bf2a4":"code","253cc95c":"code","3a408206":"code","1a4e66ee":"code","b3c51e82":"code","dfd09bf5":"code","6e398cbb":"code","456265fd":"markdown","f1168320":"markdown","7ee3f112":"markdown","348719e7":"markdown","f0f99651":"markdown","efb512bb":"markdown","7c0eda80":"markdown","5dbec8a9":"markdown","afff4b9a":"markdown","249392a7":"markdown","6a8b102c":"markdown","64374697":"markdown","0db5c843":"markdown"},"source":{"090752bb":"from PIL import Image\nimport pandas as pd\nimport datetime\n\nimport tensorflow as tf\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.preprocessing.image import array_to_img, img_to_array\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D, Flatten, BatchNormalization, Dropout, Dense, MaxPool2D\nfrom keras.callbacks import ReduceLROnPlateau\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, classification_report","27b5023e":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nraw_data = pd.read_csv('..\/input\/skin-cancer-mnist-ham10000\/hmnist_28_28_RGB.csv')\nraw_data = raw_data.sample(frac = 1)\ndata = raw_data.iloc[:,:-1]\nlabels = raw_data.iloc[:,-1:]\n\ntype_cancer = ['akiec','df','bkl','mel','nv','vasc','bcc']\ncounts = list(labels.value_counts())\nplt.figure(figsize = (8,6))\nsns.barplot(x = type_cancer, y = counts)","fc9cc77b":"raw_data = pd.read_csv('..\/input\/skin-cancer-mnist-ham10000\/hmnist_28_28_RGB.csv')\nraw_data = raw_data.sort_values('label')\nraw_data = raw_data.reset_index()\n\nindex0 = raw_data[raw_data['label'] == 0].index.values\nindex1 = raw_data[raw_data['label'] == 1].index.values\nindex2 = raw_data[raw_data['label'] == 2].index.values\nindex3 = raw_data[raw_data['label'] == 3].index.values\nindex5 = raw_data[raw_data['label'] == 5].index.values\nindex6 = raw_data[raw_data['label'] == 6].index.values\n\ndf_index0 = raw_data.iloc[int(min(index0)):int(max(index0)+1)]\ndf_index1 = raw_data.iloc[int(min(index1)):int(max(index1)+1)]\ndf_index2 = raw_data.iloc[int(min(index2)):int(max(index2)+1)]\ndf_index3 = raw_data.iloc[int(min(index3)):int(max(index3)+1)]\ndf_index5 = raw_data.iloc[int(min(index5)):int(max(index5)+1)]\ndf_index6 = raw_data.iloc[int(min(index6)):int(max(index6)+1)]\n\n\ndf_index0 = df_index0.append([df_index0]*17, ignore_index = True)\ndf_index1 = df_index1.append([df_index1]*15, ignore_index = True)\ndf_index2 = df_index2.append([df_index2]*5, ignore_index = True)\ndf_index3 = df_index3.append([df_index3]*52, ignore_index = True)\ndf_index5 = df_index5.append([df_index5]*45, ignore_index = True)\ndf_index6 = df_index6.append([df_index6]*5, ignore_index = True)\n\nframes = [raw_data, df_index0, df_index1, df_index2, df_index3, df_index5, df_index6]\n\nfinal_data = pd.concat(frames)\nfinal_data.drop('index', inplace = True, axis = 1)\nfinal_data = final_data.sample(frac = 1)\ndata = final_data.iloc[:,:-1]\nlabels = final_data.iloc[:,-1:]","a6da9f83":"raw_data.iloc[int(min(index2)):int(max(index2)+1)].shape","5cee34b9":"raw_data.iloc[int(min(index0)):int(max(index0)+1)].shape","2f8c6114":"raw_data[raw_data['label'] == 3].index.values.shape","be815ebd":"'''\nNOW WE CAN SEE THAT THE DISTRIBUTION OF THE CLASSES ARE MORE NORMALIZED THAN BEFORE\nAND NOT BIASED FOR ONE SPECIFIC CLASSES\n'''\n\ntype_cancer = ['akiec','df','bkl','mel','nv','vasc','bcc']\ncounts = list(labels.value_counts())\nplt.figure(figsize = (8,6))\nsns.barplot(x = type_cancer, y = counts)\nprint(list(labels.value_counts()))","ba292ff2":"X = np.array(data)\nY = np.array(labels)\n\n# reshaping the data\n\nX = X.reshape(-1,28,28,3)\n\nprint(\"SHAPE OF X IS: \", X.shape)\nprint(\"SHAPE OF Y IS: \", Y.shape)","4c5934ec":"def visualisePlots(X,Y, rows, columns):\n    class_dicts = {\n        0: 'nv',\n        1: 'mel',\n        2: 'bkl',\n        3: 'bcc',\n        4: 'akiec',\n        5: 'vasc',\n        6: 'df', \n    }\n    \n    data = []\n    target = []\n\n    for i in range(rows*columns):\n        data.append(X[i])\n        target.append(Y[i])\n\n    width = 10\n    height = 10\n    fig = plt.figure(figsize=(10,10))\n    for i in range(columns*rows):\n        temp_img = array_to_img(data[i])\n        fig.add_subplot(rows, columns, i+1)\n        plt.imshow(temp_img)\n        plt.xticks([])\n        plt.yticks([])\n        plt.title(str(class_dicts[target[i][0]]))\n    plt.show()\n    \n# using the above function\n\nvisualisePlots(X,Y, 3,3)","5722f72d":"X = (X-np.mean(X))\/np.std(X) # Standardizing the data on X\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=1) \n\ntrain_datagen = ImageDataGenerator(rescale = 1.\/255,\n                                  rotation_range = 10,\n                                  width_shift_range = 0.2,\n                                  height_shift_range = 0.2,\n                                  shear_range = 0.2,\n                                  horizontal_flip = True,\n                                  vertical_flip = True,\n                                  fill_mode = 'nearest')\ntrain_datagen.fit(X_train)\n\ntest_datagen = ImageDataGenerator(rescale = 1.\/255)\ntest_datagen.fit(X_test)\n\ntrain_data = train_datagen.flow(X_train, Y_train, batch_size = 64)\ntest_data = test_datagen.flow(X_test, Y_test, batch_size = 64)","a98bf2a4":"model = Sequential()\nmodel.add(Conv2D(16, kernel_size = (3,3), input_shape = (28, 28, 3), activation = 'relu', padding = 'same'))\nmodel.add(Conv2D(32, kernel_size = (3,3), activation = 'relu'))\nmodel.add(MaxPool2D(pool_size = (2,2)))\n\nmodel.add(Conv2D(32, kernel_size = (3,3), activation = 'relu', padding = 'same'))\nmodel.add(Conv2D(64, kernel_size = (3,3), activation = 'relu'))\nmodel.add(MaxPool2D(pool_size = (2,2), padding = 'same'))\n\nmodel.add(Conv2D(64, kernel_size = (3,3), activation = 'relu'))\nmodel.add(Conv2D(64, kernel_size = (3,3), activation = 'relu', padding = 'same'))\nmodel.add(MaxPool2D(pool_size = (2,2), padding = 'same'))\n\nmodel.add(Flatten())\n\nmodel.add(Dense(64, activation = 'relu'))\nmodel.add(Dense(64, activation='relu'))\nmodel.add(Dense(32, activation='relu'))\nmodel.add(Dense(32, activation='relu'))\nmodel.add(Dense(7, activation='softmax'))\n\n\nlearning_rate_reduction = ReduceLROnPlateau(monitor='val_acc', \n                                            patience=3, \n                                            verbose=1)\n\noptimizer = tf.keras.optimizers.Adam(learning_rate = 0.001)\n\nmodel.compile(loss = 'sparse_categorical_crossentropy',\n             optimizer = optimizer,\n              metrics = ['accuracy'])\n\nprint(model.summary())","253cc95c":"history = model.fit(X_train,\n                    Y_train,\n                    validation_split=0.2,\n                    batch_size = 32,\n                    epochs = 10,\n                    callbacks=[learning_rate_reduction])","3a408206":"acc = history.history['accuracy']\nval_acc = history.history['val_accuracy']\n\nplt.figure(figsize=(8,6))\nplt.title(\"Training and Validation accuracy of the model\")\nplt.plot(acc, label = 'train_acc')\nplt.plot(val_acc, label = 'val_acc')\nplt.legend()\n\nloss = history.history['loss']\nval_loss = history.history['val_loss']\n\nplt.figure(figsize=(8,6))\nplt.title(\"Training and Validation loss of the model\")\nplt.plot(loss, label = 'train_loss')\nplt.plot(val_loss, label = 'val_loss')\nplt.legend()","1a4e66ee":"Y_true = np.array(Y_test)\n\nY_pred = model.predict(X_test)\nY_pred = np.array(list(map(lambda x: np.argmax(x), Y_pred)))\n\ncm1 = confusion_matrix(Y_true, Y_pred)\nplt.figure(figsize=(12, 6))\nplt.title('The confusion matrix of model on test set')\nsns.heatmap(cm1, annot = True, fmt = 'g' ,vmin = 0, cmap = 'viridis')\nplt.show()","b3c51e82":"def visualisePlots_test(X,Y, model, rows, columns):\n    class_dicts = {\n        0: 'nv',\n        1: 'mel',\n        2: 'bkl',\n        3: 'bcc',\n        4: 'akiec',\n        5: 'vasc',\n        6: 'df', \n    }\n    \n    data = []\n    target = []\n    \n    Y_pred = model.predict(X)\n    Y_pred = np.array(list(map(lambda x: np.argmax(x), Y_pred)))\n\n    for i in range(rows*columns):\n        data.append(X[i])\n        target.append(Y[i])\n\n    width = 10\n    height = 10\n    fig = plt.figure(figsize=(10,10))\n    for i in range(columns*rows):\n        temp_img = array_to_img(data[i])\n        fig.add_subplot(rows, columns, i+1)\n        plt.imshow(temp_img)\n        plt.xticks([])\n        plt.yticks([])\n        plt.title(str(class_dicts[target[i][0]]) + \" || \" + str(class_dicts[Y_pred[i]]))\n    plt.show()\n    \n# USING THE MODELS AND VISUALISING THEM\n\nprint('THE PLOTS TESTING WITH THE MODEL')\nvisualisePlots_test(X_test,Y_test, model, 3, 3) ","dfd09bf5":"label_mapping = {\n    0: 'nv',\n    1: 'mel',\n    2: 'bkl',\n    3: 'bcc',\n    4: 'akiec',\n    5: 'vasc',\n    6: 'df'\n}\n\nclassification_report_model = classification_report(Y_true, Y_pred, target_names=label_mapping.values())\nprint(classification_report_model)","6e398cbb":"model_acc_test = model.evaluate(X_test, Y_test, verbose=0)[1]\nprint(\"Test Accuracy of model: {:.3f}%\".format(model_acc_test * 100))","456265fd":"**WE ARE GETTING AN ACCURACY OF 94% ON THE TEST DATA WHICH IS PRETTY GOOD.**","f1168320":"**BUILDING THE MODEL**","7ee3f112":"# **Skin Cancer Image Classification**","348719e7":"**VISUALISING THE PLOTS OF THE IMAGES WHERE EACH OF THE IMAGES ARE LABELED WITH \nTHE CORRESPONDING LABELS OF THE IMAGES i.e. WHICH TYPE OF THE CACNCER IT IS**\n\nnv - Melanocytic nevi\n\nmel - Melanoma\n\nbkl - Benign keratosis-like lesions\n\nbcc - Basal cell carcinoma\n\nakiec - Actinic keratoses and intraepithelial carcinoma \/ Bowen's disease\n\nvasc - Vascular lesions\n\ndf - Dermatofibroma","f0f99651":"**MANUALLY UPSAMPLING THE CLASS DISTRIBUTIONS FOR PREDICTING THE CORRECT CLASS LABEL**","efb512bb":"### GETTING THE FEARURES FROM DATA, MAKING THE MODEL, TRAINING THE MODEL","7c0eda80":"**Evaluating the performance on test set**","5dbec8a9":"Getting the correct labels after training the model.","afff4b9a":"**THERE ARE TOTAL OF 7 DIFFERENT KIND OF CLASSES PRESENT HERE WHICH AE TO BE CLASSIFIED**\n\n0: nv - Melanocytic nevi\n\n1: mel - Melanoma\n\n2: bkl - Benign keratosis-like lesions\n\n3: bcc - Basal cell carcinoma\n\n4: akiec - Actinic keratoses and intraepithelial carcinoma \/ Bowen's disease\n\n5: vasc - Vascular lesions\n\n6: df - Dermatofibroma","249392a7":"**Confusion Matrix**","6a8b102c":"**TRAINING THE MODEL**","64374697":"**RESHAPING THE DATA TO FEED INTO THE CNN MODEL**","0db5c843":"**Plotting training and validation curve for the model**"}}