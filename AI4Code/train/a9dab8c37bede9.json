{"cell_type":{"e545a4f0":"code","dc6fe963":"code","a0291e75":"code","e40f642a":"code","6de17933":"code","2e6529af":"code","65c4ad9c":"code","5738fadb":"code","83635c0e":"code","054c6a0d":"code","fcee5b05":"code","0eede4f6":"code","63662f40":"code","d557bc27":"code","10512e55":"code","5138a1fe":"code","5309bfd9":"code","64f9ec14":"code","b65ad800":"code","70899dae":"code","e66cec7a":"code","14cbf085":"code","368da5bc":"code","edda2166":"code","6156970a":"code","a5831e51":"code","f9b9535e":"code","2c827416":"code","6323cb68":"code","e7583a10":"code","9bf77b39":"code","356274eb":"code","74c7b80d":"code","b760211f":"code","b68a831d":"code","e9bf840b":"code","6665f59b":"code","b96767f3":"markdown","f5b29987":"markdown","bae9793e":"markdown","3e09c9fe":"markdown","c42c3538":"markdown","418b792d":"markdown","7af95c50":"markdown","91713853":"markdown","6caaba14":"markdown","ee60ad4e":"markdown","adcf9d61":"markdown","a23bd753":"markdown","a580a1c6":"markdown","a8d2223c":"markdown","fe99f521":"markdown","5ec2c287":"markdown","af33212b":"markdown"},"source":{"e545a4f0":"!pip install git+https:\/\/github.com\/fastai\/fastcore > \/dev\/null\n!pip install git+https:\/\/github.com\/fastai\/fastai2 > \/dev\/null\n!pip install iterative-stratification > \/dev\/null","dc6fe963":"%load_ext autoreload\n%autoreload 2\n\nimport os\nimport pandas as pd\nimport sys\nfrom collections import Counter\nfrom pathlib import Path\n\nfrom iterstrat.ml_stratifiers import MultilabelStratifiedKFold\nfrom tqdm.notebook import tqdm\nfrom torchvision.models import densenet121\nfrom sklearn.metrics import roc_auc_score\nfrom torch.utils.data.sampler import WeightedRandomSampler\n\nfrom fastai2.basics import *\nfrom fastai2.callback.all import *\nfrom fastai2.vision.all import *\n\n\ndef seed_everything(seed):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True","a0291e75":"DATA_PATH = Path('..\/input\/plant-pathology-2020-fgvc7')\nIMG_PATH = DATA_PATH \/ 'images'\nLABEL_COLS = ['healthy', 'multiple_diseases', 'rust', 'scab']\n\nIMG_SIZE = 512\nSEED = 420\nN_FOLDS = 5\nBS = 16\nN_FOLDS = 5\n\nARCH = densenet121","e40f642a":"seed_everything(SEED)","6de17933":"train_df = pd.read_csv('..\/input\/plant-pathology-2020-fgvc7\/train.csv')\ntest_df = pd.read_csv('..\/input\/plant-pathology-2020-fgvc7\/test.csv')","2e6529af":"train_df.head()","65c4ad9c":"(len(train_df), len(test_df))","5738fadb":"_, axes = plt.subplots(ncols=4, nrows=1, constrained_layout=True, figsize=(10, 3))\nfor ax, column in zip(axes, LABEL_COLS):\n    train_df[column].value_counts().plot.bar(title=column, ax=ax)\nplt.show()","83635c0e":"plt.title('Label dist')\ntrain_df[LABEL_COLS].idxmax(axis=1).value_counts().plot.bar()","054c6a0d":"train_df.iloc[:,1:-1].sum(axis=1).value_counts()","fcee5b05":"train_df[['healthy', 'multiple_diseases', 'rust', 'scab']].sum(axis=1).unique()","0eede4f6":"def get_size(df):\n    hs, ws = [], []\n    for _, row in tqdm(df.iterrows(), total=len(train_df)):\n        img = Image.open(IMG_PATH\/(row.image_id+'.jpg'))\n        h, w = img.size\n        hs.append(h)\n        ws.append(w)\n        \n    return hs, ws","63662f40":"train_hs, train_ws = get_size(train_df)\ntest_hs, test_ws = get_size(test_df)","d557bc27":"for set_label, set_size in ('train', [train_hs, train_ws]), ('test', [test_hs, test_ws]):\n    print(f'{set_label} height val counts: {Counter(set_size[0])}')\n    print(f'{set_label} width val counts: {Counter(set_size[1])}')\n\n    _, axes = plt.subplots(ncols=2, nrows=1, constrained_layout=True, figsize=(10, 3))\n    for ax, column, vals in zip(axes, ['heights', 'widths'], set_size):\n        ax.hist(vals, bins=100)\n        ax.set_title(f'{set_label} {column} hist')\n\nplt.show()","10512e55":"def plot_colour_hist(df, title):\n    red_values = []; green_values = []; blue_values = []; all_channels = []\n    for _, row in tqdm(df.iterrows(), total=len(df)):\n        img = np.array(Image.open(IMG_PATH\/(row.image_id+'.jpg')))\n        red_values.append(np.mean(img[:, :, 0]))\n        green_values.append(np.mean(img[:, :, 1]))\n        blue_values.append(np.mean(img[:, :, 2]))\n        all_channels.append(np.mean(img))\n        \n    _, axes = plt.subplots(ncols=4, nrows=1, constrained_layout=True, figsize=(16, 3), sharey=True)\n    for ax, column, vals, c in zip(\n        axes,\n        ['red', 'green', 'blue', 'all colours'],\n        [red_values, green_values, blue_values, all_channels],\n        'rgbk'\n    ):\n        ax.hist(vals, bins=100, color=c)\n        ax.set_title(f'{column} hist')\n\n    plt.suptitle(title)\n    plt.show()","5138a1fe":"plot_colour_hist(train_df, title='Train colour dist')","5309bfd9":"plot_colour_hist(test_df, title='Test colour dist')","64f9ec14":"train_df['fold'] = -1\n\nstrat_kfold = MultilabelStratifiedKFold(n_splits=N_FOLDS, random_state=SEED, shuffle=True)\nfor i, (_, test_index) in enumerate(strat_kfold.split(train_df.image_id.values, train_df.iloc[:,1:].values)):\n    train_df.iloc[test_index, -1] = i\n    \ntrain_df['fold'] = train_df['fold'].astype('int')","b65ad800":"_, axes = plt.subplots(ncols=5, nrows=1, constrained_layout=True, figsize=(16, 3), sharey=True)\nfor ax, fold in zip(axes, range(5)):\n    train_df.query(f'fold == {fold}')[LABEL_COLS].idxmax(axis=1).value_counts().plot.bar(ax=ax)\n    ax.set_title(f'Fold {fold} label dist') \n\nplt.show()","70899dae":"train_df.to_csv('train_with_strat_folds.csv', index=False)","e66cec7a":"train_df['label'] = train_df[LABEL_COLS].idxmax(axis=1)","14cbf085":"def get_data(fold):\n    train_df_no_val = train_df.query(f'fold != {fold}')\n    train_df_just_val = train_df.query(f'fold == {fold}')\n\n    train_df_bal = pd.concat(\n        [train_df_no_val.query('label != \"multiple_diseases\"'), train_df_just_val] +\n        [train_df_no_val.query('label == \"multiple_diseases\"')] * 2\n    ).sample(frac=1.0, random_state=SEED).reset_index(drop=True)\n\n    datablock = DataBlock(\n        blocks=(ImageBlock, CategoryBlock(vocab=LABEL_COLS)),\n        getters=[\n            ColReader('image_id', pref=IMG_PATH, suff='.jpg'),\n            ColReader('label')\n        ],\n        splitter=IndexSplitter(train_df_bal.loc[train_df_bal.fold==fold].index),\n        item_tfms=Resize(IMG_SIZE),\n        batch_tfms=aug_transforms(size=IMG_SIZE, max_rotate=30., min_scale=0.75, flip_vert=True, do_flip=True)\n    )\n    return datablock.dataloaders(source=train_df_bal, bs=BS)","368da5bc":"dls = get_data(fold=0)","edda2166":"dls.show_batch()","6156970a":"def comp_metric(preds, targs, labels=range(len(LABEL_COLS))):\n    # One-hot encode targets\n    targs = np.eye(4)[targs]\n    return np.mean([roc_auc_score(targs[:,i], preds[:,i]) for i in labels])\n\ndef healthy_roc_auc(*args):\n    return comp_metric(*args, labels=[0])\n\ndef multiple_diseases_roc_auc(*args):\n    return comp_metric(*args, labels=[1])\n\ndef rust_roc_auc(*args):\n    return comp_metric(*args, labels=[2])\n\ndef scab_roc_auc(*args):\n    return comp_metric(*args, labels=[3])","a5831e51":"def get_learner(fold_num, lr=1e-3):\n    opt_func = partial(Adam, lr=lr, wd=0.01, eps=1e-8)\n\n    data = get_data(fold_num)\n\n    learn = cnn_learner(\n        data, ARCH, opt_func=opt_func,\n        loss_func=LabelSmoothingCrossEntropy(),\n        metrics=[\n            AccumMetric(healthy_roc_auc, flatten=False),\n            AccumMetric(multiple_diseases_roc_auc, flatten=False),\n            AccumMetric(rust_roc_auc, flatten=False),\n            AccumMetric(scab_roc_auc, flatten=False),\n            AccumMetric(comp_metric, flatten=False)]\n        ).to_fp16()\n\n    return learn","f9b9535e":"get_learner(fold_num=0).lr_find()","2c827416":"def print_metrics(val_preds, val_labels):\n    comp_metric_fold = comp_metric(val_preds, val_labels)\n    print(f'Comp metric: {comp_metric_fold}')\n    \n    healthy_roc_auc_metric = healthy_roc_auc(val_preds, val_labels)\n    print(f'Healthy metric: {healthy_roc_auc_metric}')\n    \n    multiple_diseases_roc_auc_metric = multiple_diseases_roc_auc(val_preds, val_labels)\n    print(f'Multi disease: {multiple_diseases_roc_auc_metric}')\n    \n    rust_roc_auc_metric = rust_roc_auc(val_preds, val_labels)\n    print(f'Rust metric: {rust_roc_auc_metric}')\n    \n    scab_roc_auc_metric = scab_roc_auc(val_preds, val_labels)\n    print(f'Scab metric: {scab_roc_auc_metric}')","6323cb68":"all_val_preds = []\nall_val_labels = []\nall_test_preds = []\n\nfor i in range(N_FOLDS):\n    print(f'Fold {i} results')\n\n    learn = get_learner(fold_num=i)\n\n    learn.fit_one_cycle(4)\n    learn.unfreeze()\n\n    learn.fit_one_cycle(8, slice(1e-5, 1e-4))\n    \n    learn.recorder.plot_loss()\n    \n    learn.save(f'model_fold_{i}')\n    \n    val_preds, val_labels = learn.get_preds()\n    \n    print_metrics(val_preds, val_labels)\n    \n    all_val_preds.append(val_preds)\n    all_val_labels.append(val_labels)\n    \n    test_dl = dls.test_dl(test_df)\n    test_preds, _ = learn.get_preds(dl=test_dl)\n    all_test_preds.append(test_preds)\n    \nplt.show()","e7583a10":"print_metrics(np.concatenate(all_val_preds), np.concatenate(all_val_labels))","9bf77b39":"interp = ClassificationInterpretation.from_learner(learn)","356274eb":"interp.plot_top_losses(9, figsize=(15, 10))","74c7b80d":"interp.plot_confusion_matrix(normalize=True, figsize=(6, 6))","b760211f":"test_df_output = pd.concat([test_df, pd.DataFrame(np.mean(np.stack(all_test_preds), axis=0), columns=LABEL_COLS)], axis=1)","b68a831d":"test_df_output.head()","e9bf840b":"test_df_output.to_csv('submission.csv', index=False)","6665f59b":"!head -n 5 submission.csv","b96767f3":"## Data (inc oversampling)","f5b29987":"# Plant Pathology 2020 with fastai2\n\nThe goal of this notebook is to showcase some of the features in the soon to be released [fastai2](https:\/\/github.com\/fastai\/fastai2) library and to provide a starter example for classifying categories of foliar diseases in apple trees.\n\n## Changelog\n\n### v10 (2020-05-1)\n\n* Bug fixes.\n* Add test data to EDA.\n\n### v8,v9 (2020-03-15)\n\n* Train 5 folds.\n* Clean up some broken parts.\n\n### v7 (2020-03-13)\n\n* Resize to 1024\n* Less oversampling.\n\n### v6 (2020-03-13)\n\n* Label smoothing.\n* Fix validation bug.\n\n### v5 (2020-03-13)\n\n* Oversampling minority class.\n\n### v4 (2020-03-12)\n\n* Add competition metric to learner output.\n* Add confusion matrix.\n\n### v3. 2020-03-12\n\n* Bigger image size.\n\n### v2. 2020-03-12\n\n* First working version","bae9793e":"Looks like never. So this appears to be multiclass but not multilabel classification.","3e09c9fe":"## Test predictions","c42c3538":"## Create folds","418b792d":"### Colour distribution","7af95c50":"## Training","91713853":"I'll use iterative stratification to create balanced folds.","6caaba14":"## EDA","ee60ad4e":"Let's see how many times the labels appear together.","adcf9d61":"### Dataset size","a23bd753":"### Img size distribution","a580a1c6":"### Label distribution","a8d2223c":"## Params","fe99f521":"## Interpret","5ec2c287":"All images are either: 2048x1365 or 1365x2048.","af33212b":"Right now, I'm x2 the number of multiple diseases labels as that appears to be the majorly unrepresented class."}}