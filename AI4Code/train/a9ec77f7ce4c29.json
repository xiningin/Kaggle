{"cell_type":{"dd4de45a":"code","782fb147":"code","d224d414":"code","079a65d6":"code","75cb841b":"code","932e58f2":"code","9bf8c505":"code","c45f5104":"code","3b27603b":"code","1998214b":"code","bb8c25b0":"code","36f039e0":"code","c7e841fd":"code","bf7b7a7a":"code","db3fff4f":"code","104adc5c":"code","7ce6d9c3":"code","597b94bb":"code","fa0275c1":"code","ac1b6bab":"code","25bbc4b1":"code","99fdf17c":"code","5381fff7":"code","49054e87":"code","e7312847":"code","df39d0f0":"code","ccc5958c":"code","d683cc0a":"code","b2e40823":"code","e6fe079b":"code","e02f8e1f":"code","1fc1dcc7":"code","c6a365ce":"code","6c033b1d":"code","b41f7a2f":"code","4c4bd324":"code","38d0fa24":"code","ed0912b9":"code","5e66b7aa":"code","8874cda7":"code","05966ab4":"code","7b792a03":"code","2e4ab978":"code","33b1371e":"code","712bca43":"markdown","5d8eec57":"markdown","1979d350":"markdown","88b24cd3":"markdown","95e34cc7":"markdown","20a9d14c":"markdown","cd1a35f6":"markdown","386dbdaf":"markdown","c54d3128":"markdown","ff4c291b":"markdown","2810a302":"markdown","09ad4036":"markdown","2b415f78":"markdown","adf6d40d":"markdown","26c7e7cc":"markdown","b39cbdb1":"markdown","1f15a582":"markdown","e9838f76":"markdown","edea9055":"markdown","52840c6a":"markdown","14db6cea":"markdown","43e26b64":"markdown","2fead53a":"markdown","7061dcec":"markdown","d0c3bc63":"markdown","c52be71f":"markdown","a17fd18d":"markdown","5cdbf018":"markdown","5423b95b":"markdown","698a6679":"markdown","df664666":"markdown","8e14eb4c":"markdown","432bd699":"markdown","4a84ce87":"markdown","a14144e2":"markdown","44b4ee80":"markdown","5707e4a3":"markdown","68f58cec":"markdown","6e02c64f":"markdown","82754dc5":"markdown","9e997675":"markdown","f1142467":"markdown","683e935a":"markdown"},"source":{"dd4de45a":"# Importing the required libraries\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline","782fb147":"# To ignore warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\")","d224d414":"# Reading the csv file and putting it into 'df' object.\ndf = pd.read_csv('..\/input\/income-data-dt\/adult_dataset.csv')","079a65d6":"# Let's understand the type of values in each column of our dataframe 'df'.\ndf.info()","75cb841b":"# Let's understand the data, how it look like.\ndf.head()","932e58f2":"# rows with missing values represented as'?'.\ndf_1 = df[df.workclass == '?']\ndf_1","9bf8c505":"df_1.info()","c45f5104":"# dropping the rows having missing values in workclass\ndf = df[df['workclass'] != '?']\ndf.head()","3b27603b":"# select all categorical variables\ndf_categorical = df.select_dtypes(include=['object'])\n\n# checking whether any other columns contain a \"?\"\ndf_categorical.apply(lambda x: x==\"?\", axis=0).sum()","1998214b":"# dropping the \"?\"s\ndf = df[df['occupation'] != '?']\ndf = df[df['native.country'] != '?']","bb8c25b0":"# clean dataframe\ndf.info()","36f039e0":"from sklearn import preprocessing\n\n\n# encode categorical variables using Label Encoder\n\n# select all categorical variables\ndf_categorical = df.select_dtypes(include=['object'])\ndf_categorical.head()","c7e841fd":"# apply Label encoder to df_categorical\n\nle = preprocessing.LabelEncoder()\ndf_categorical = df_categorical.apply(le.fit_transform)\ndf_categorical.head()","bf7b7a7a":"# concat df_categorical with original df\ndf = df.drop(df_categorical.columns, axis=1)\ndf = pd.concat([df, df_categorical], axis=1)\ndf.head()","db3fff4f":"# look at column types\ndf.info()","104adc5c":"# convert target variable income to categorical\ndf['income'] = df['income'].astype('category')","7ce6d9c3":"# Importing train-test-split \nfrom sklearn.model_selection import train_test_split","597b94bb":"# Putting feature variable to X\nX = df.drop('income',axis=1)\n\n# Putting response variable to y\ny = df['income']","fa0275c1":"# Splitting the data into train and test\nX_train, X_test, y_train, y_test = train_test_split(X, y, \n                                                    test_size=0.30, \n                                                    random_state = 99)\nX_train.head()","ac1b6bab":"# Importing decision tree classifier from sklearn library\nfrom sklearn.tree import DecisionTreeClassifier\n\n# Fitting the decision tree with default hyperparameters, apart from\n# max_depth which is 5 so that we can plot and read the tree.\ndt_default = DecisionTreeClassifier(max_depth=5)\ndt_default.fit(X_train, y_train)","25bbc4b1":"# Let's check the evaluation metrics of our default model\n\n# Importing classification report and confusion matrix from sklearn metrics\nfrom sklearn.metrics import classification_report, confusion_matrix, accuracy_score\n\n# Making predictions\ny_pred_default = dt_default.predict(X_test)\n\n# Printing classification report\nprint(classification_report(y_test, y_pred_default))","99fdf17c":"# Printing confusion matrix and accuracy\nprint(confusion_matrix(y_test,y_pred_default))\nprint(accuracy_score(y_test,y_pred_default))","5381fff7":"# Importing required packages for visualization\n#from IPython.display import Image  \n#from sklearn.externals.six import StringIO  \n#from sklearn.tree import export_graphviz\n#import pydotplus, graphviz\n\n# Putting features\nfeatures = list(df.columns[1:])\nfeatures","49054e87":"# If you're on windows:\n# Specifing path for dot file.\n# import os\n# os.environ[\"PATH\"] += os.pathsep + 'C:\/Program Files (x86)\/graphviz-2.38\/release\/bin\/'","e7312847":"# plotting tree with max_depth=3\n#dot_data = StringIO()  \n#export_graphviz(dt_default, out_file=dot_data,\n#                feature_names=features, filled=True,rounded=True)\n\n#graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  \n#Image(graph.create_png())","df39d0f0":"# GridSearchCV to find optimal max_depth\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import GridSearchCV\n\n\n# specify number of folds for k-fold CV\nn_folds = 5\n\n# parameters to build the model on\nparameters = {'max_depth': range(1, 40)}\n\n# instantiate the model\ndtree = DecisionTreeClassifier(criterion = \"gini\", \n                               random_state = 100)\n\n# fit tree on training data\ntree = GridSearchCV(dtree, parameters, \n                    cv=n_folds, \n                   scoring=\"accuracy\",return_train_score=True)\ntree.fit(X_train, y_train)","ccc5958c":"# scores of GridSearch CV\nscores = tree.cv_results_\npd.DataFrame(scores).head()","d683cc0a":"# plotting accuracies with max_depth\nplt.figure()\nplt.plot(scores[\"param_max_depth\"], \n         scores[\"mean_train_score\"], \n         label=\"training accuracy\")\nplt.plot(scores[\"param_max_depth\"], \n         scores[\"mean_test_score\"], \n         label=\"test accuracy\")\nplt.xlabel(\"max_depth\")\nplt.ylabel(\"Accuracy\")\nplt.legend()\nplt.show()\n","b2e40823":"# GridSearchCV to find optimal max_depth\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import GridSearchCV\n\n\n# specify number of folds for k-fold CV\nn_folds = 5\n\n# parameters to build the model on\nparameters = {'min_samples_leaf': range(5, 200, 20)}\n\n# instantiate the model\ndtree = DecisionTreeClassifier(criterion = \"gini\", \n                               random_state = 100)\n\n# fit tree on training data\ntree = GridSearchCV(dtree, parameters, \n                    cv=n_folds, \n                   scoring=\"accuracy\",return_train_score=True)\ntree.fit(X_train, y_train)","e6fe079b":"# scores of GridSearch CV\nscores = tree.cv_results_\npd.DataFrame(scores).head()","e02f8e1f":"# plotting accuracies with min_samples_leaf\nplt.figure()\nplt.plot(scores[\"param_min_samples_leaf\"], \n         scores[\"mean_train_score\"], \n         label=\"training accuracy\")\nplt.plot(scores[\"param_min_samples_leaf\"], \n         scores[\"mean_test_score\"], \n         label=\"test accuracy\")\nplt.xlabel(\"min_samples_leaf\")\nplt.ylabel(\"Accuracy\")\nplt.legend()\nplt.show()\n","1fc1dcc7":"# GridSearchCV to find optimal min_samples_split\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import GridSearchCV\n\n\n# specify number of folds for k-fold CV\nn_folds = 5\n\n# parameters to build the model on\nparameters = {'min_samples_split': range(5, 200, 20)}\n\n# instantiate the model\ndtree = DecisionTreeClassifier(criterion = \"gini\", \n                               random_state = 100)\n\n# fit tree on training data\ntree = GridSearchCV(dtree, parameters, \n                    cv=n_folds, \n                   scoring=\"accuracy\",return_train_score=True)\ntree.fit(X_train, y_train)","c6a365ce":"# scores of GridSearch CV\nscores = tree.cv_results_\npd.DataFrame(scores).head()","6c033b1d":"# plotting accuracies with min_samples_leaf\nplt.figure()\nplt.plot(scores[\"param_min_samples_split\"], \n         scores[\"mean_train_score\"], \n         label=\"training accuracy\")\nplt.plot(scores[\"param_min_samples_split\"], \n         scores[\"mean_test_score\"], \n         label=\"test accuracy\")\nplt.xlabel(\"min_samples_split\")\nplt.ylabel(\"Accuracy\")\nplt.legend()\nplt.show()\n","b41f7a2f":"# Create the parameter grid \nparam_grid = {\n    'max_depth': range(5, 15, 5),\n    'min_samples_leaf': range(50, 150, 50),\n    'min_samples_split': range(50, 150, 50),\n    'criterion': [\"entropy\", \"gini\"]\n}\n\nn_folds = 5\n\n# Instantiate the grid search model\ndtree = DecisionTreeClassifier()\ngrid_search = GridSearchCV(estimator = dtree, param_grid = param_grid, \n                          cv = n_folds, verbose = 1,return_train_score=True)\n\n# Fit the grid search to the data\ngrid_search.fit(X_train,y_train)","4c4bd324":"# cv results\ncv_results = pd.DataFrame(grid_search.cv_results_)\ncv_results","38d0fa24":"# printing the optimal accuracy score and hyperparameters\nprint(\"best accuracy\", grid_search.best_score_)\nprint(grid_search.best_estimator_)","ed0912b9":"# model with optimal hyperparameters\nclf_gini = DecisionTreeClassifier(criterion = \"gini\", \n                                  random_state = 100,\n                                  max_depth=10, \n                                  min_samples_leaf=50,\n                                  min_samples_split=50)\nclf_gini.fit(X_train, y_train)","5e66b7aa":"# accuracy score\nclf_gini.score(X_test,y_test)","8874cda7":"# plotting the tree\n#dot_data = StringIO()  \n#export_graphviz(clf_gini, out_file=dot_data,feature_names=features,filled=True,rounded=True)\n\n#graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  \n#Image(graph.create_png())","05966ab4":"# tree with max_depth = 3\nclf_gini = DecisionTreeClassifier(criterion = \"gini\", \n                                  random_state = 100,\n                                  max_depth=3, \n                                  min_samples_leaf=50,\n                                  min_samples_split=50)\nclf_gini.fit(X_train, y_train)\n\n# score\nprint(clf_gini.score(X_test,y_test))","7b792a03":"# plotting tree with max_depth=3\n#dot_data = StringIO()  \n#export_graphviz(clf_gini, out_file=dot_data,feature_names=features,filled=True,rounded=True)\n\n#graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  \n#Image(graph.create_png())","2e4ab978":"# classification metrics\nfrom sklearn.metrics import classification_report,confusion_matrix\ny_pred = clf_gini.predict(X_test)\nprint(classification_report(y_test, y_pred))","33b1371e":"# confusion matrix\nprint(confusion_matrix(y_test,y_pred))","712bca43":"<hr>","5d8eec57":"You can see that this tree is too complex to understand. Let's try reducing the max_depth and see how the tree looks.","1979d350":"You can observe that the columns workclass and occupation consist of missing values which are represented as '?' in the  dataframe.\n\nOn looking a bit more closely, you will also find that whenever workclass is having a missing value, occupation is also missing in that row. Let's check how may rows are missing.","88b24cd3":"## Data Preparation\n\nThere are a number of preprocessing steps we need to do before building the model. \n\nFirstly, note that we have both categorical and numeric features as predictors. In previous models such as linear and logistic regression, we had created **dummy variables** for categorical variables, since those models (being mathematical equations) can  process only numeric variables.\n\nAll that is not required in decision trees, since they can process categorical variables easily. However, we still need to **encode the categorical variables** into a standard format so that sklearn can understand them and build the tree. We'll do that using the ```LabelEncoder()``` class, which comes with ```sklearn.preprocessing```. \n\nYou can read the documentation of ```LabelEncoder``` <a href=\"http:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.preprocessing.LabelEncoder.html\">here<\/a>.\n\n\n\n","95e34cc7":"This shows that as you increase the min_samples_split, the tree overfits lesser since the model is less complex.","20a9d14c":"You can see that at low values of min_samples_leaf, the tree gets a bit overfitted. At values > 100, however, the model becomes more stable and the training and test accuracy start to converge.","cd1a35f6":"Now we can check the number of rows in df_1.","386dbdaf":"**Running the model with best parameters obtained from grid search.**","c54d3128":"Thus, it is clear that the model is overfitting the training data if the max_depth is too high. Next, let's see how the model behaves with other hyperparameters.","ff4c291b":"<hr>","2810a302":"Thus, the columns occupation and native.country contain some \"?\"s. Let's get rid of them.","09ad4036":"<hr>","2b415f78":"We can now use GridSearchCV to find multiple optimal hyperparameters together. Note that this time, we'll also specify the criterion (gini\/entropy or IG).","adf6d40d":"Now all the categorical variables are suitably encoded. Let's build the model.","26c7e7cc":"### Understanding and Cleaning the Data","b39cbdb1":"Now let's visualize how train and test score changes with max_depth.","1f15a582":"<hr>","e9838f76":"### Hyperparameter Tuning","edea9055":"<hr>","52840c6a":"### Tuning min_samples_leaf","14db6cea":"<hr>","43e26b64":"Let's first try to find the optimum values for max_depth and understand how the value of max_depth affects the decision tree.","2fead53a":"we will build a decision tree to predict the income of a given population, which is labelled as <=$50K and >$50K. The attributes (predictors) are age, working class type, marital status, gender, race etc.\n\n\nIn the following sections, we'll:\n- clean and prepare the data, \n- build a decision tree with default hyperparameters, \n- understand all the hyperparameters that we can tune, and finally\n- choose the optimal hyperparameters using grid search cross-validation.\n","7061dcec":"Here, we are creating a dataframe with max_depth in range 1 to 80 and checking the accuracy score corresponding to each max_depth. \n\nTo reiterate, a grid search scheme consists of:\n\n    - an estimator (classifier such as SVC() or decision tree)\n    - a parameter space\n    - a method for searching or sampling candidates (optional) \n    - a cross-validation scheme, and\n    - a score function (accuracy, roc_auc etc.)","d0c3bc63":"The hyperparameter **min_samples_split** is the minimum no. of samples required to split an internal node. Its default value is 2, which means that even if a node is having 2 samples it can be furthur divided into leaf nodes.","c52be71f":"### Tuning min_samples_split","a17fd18d":"There are 1836 rows with missing values, which is about 5% of the total data. We choose to simply drop these rows.","5cdbf018":"<hr>","5423b95b":"### Tuning max_depth","698a6679":"### Model Building and Evaluation","df664666":"<hr>","8e14eb4c":"You can see that as we increase the value of max_depth, both training and test score increase till about max-depth = 10, after which the test score gradually reduces. Note that the scores are average accuracies across the 5-folds. ","432bd699":"Now we have a clean dataframe which is ready for model building.<br>","4a84ce87":"The default tree is quite complex, and we need to simplify it by tuning the hyperparameters. \n\nFirst, let's understand the parameters in a decision tree. You can read this in the documentation using ```help(DecisionTreeClassifier)```.\n\n\n- **criterion** (Gini\/IG or entropy): It defines the function to measure the quality of a split. Sklearn supports \u201cgini\u201d criteria for Gini Index & \u201centropy\u201d for Information Gain. By default, it takes the value \u201cgini\u201d.\n- **splitter**: It defines the strategy to choose the split at each node. Supports \u201cbest\u201d value to choose the best split & \u201crandom\u201d to choose the best random split. By default, it takes \u201cbest\u201d value.\n- **max_features**: It defines the no. of features to consider when looking for the best split. We can input integer, float, string & None value.\n    - If an integer is inputted then it considers that value as max features at each split.\n    - If float value is taken then it shows the percentage of features at each split.\n    - If \u201cauto\u201d or \u201csqrt\u201d is taken then max_features=sqrt(n_features).\n    - If \u201clog2\u201d is taken then max_features= log2(n_features).\n    - If None, then max_features=n_features. By default, it takes \u201cNone\u201d value.\n- **max_depth**: The max_depth parameter denotes maximum depth of the tree. It can take any integer value or None. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples. By default, it takes \u201cNone\u201d value.\n- **min_samples_split**: This tells above the minimum no. of samples reqd. to split an internal node. If an integer value is taken then consider min_samples_split as the minimum no. If float, then it shows percentage. By default, it takes \u201c2\u201d value.\n- **min_samples_leaf**: The minimum number of samples required to be at a leaf node. If an integer value is taken then consider - -min_samples_leaf as the minimum no. If float, then it shows percentage. By default, it takes \u201c1\u201d value.\n- **max_leaf_nodes**: It defines the maximum number of possible leaf nodes. If None then it takes an unlimited number of leaf nodes. By default, it takes \u201cNone\u201d value.\n- **min_impurity_split**: It defines the threshold for early stopping tree growth. A node will split if its impurity is above the threshold otherwise it is a leaf.<br>\n\n","a14144e2":"**Note**:<br>\nPython requires library pydot and an external software graphviz to visualize the decision tree. If you are on wondows, you'll need to specify the path for the pydot library to access dot file from graphviz.\n\nPlease read the downloadable instructions to install graphviz. For Mac users, one way is to:\n- Install the python graphviz module: ```pip install graphviz```\n- Then install the Graphviz software on Mac, you do this using homebrew:\n    - Install homebrew: https:\/\/docs.brew.sh\/Installation\n    - ```brew install graphviz```","44b4ee80":"The hyperparameter **min_samples_leaf** indicates the minimum number of samples required to be at a leaf.<br>\n\nSo if the values of min_samples_leaf is less, say 5, then the will be constructed even if a leaf has 5, 6 etc. observations (and is likely to overfit).<br>\n\nLet's see what will be the optimum value for min_samples_leaf.","5707e4a3":"<hr>","68f58cec":"## Grid Search to Find Optimal Hyperparameters","6e02c64f":"<hr>","82754dc5":"### Plotting the Decision Tree\n\nTo visualise decision trees in python, you need to install certain external libraries. You can read about the process in detail here: http:\/\/scikit-learn.org\/stable\/modules\/tree.html\n\nWe need the ```graphviz``` library to plot a tree.","9e997675":"Let's first build a decision tree with default hyperparameters. Then we'll use cross-validation to tune them.","f1142467":"# Decision Tree: Income Prediction","683e935a":"Let's see whether any other columns contain a \"?\". Since \"?\" is a string, we can apply this check only on the categorical columns."}}