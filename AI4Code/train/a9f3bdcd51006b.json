{"cell_type":{"7d8124d0":"code","30c22352":"code","e67890a1":"code","0a179c5c":"code","67a57381":"code","1d79eb10":"code","53272f2e":"code","8c2cb2ad":"code","37fdc1e0":"code","b02c39ae":"markdown","46ab8e29":"markdown","aa2c65d0":"markdown","d3ea21f1":"markdown","0aedc543":"markdown","9cacdaa2":"markdown","91f244a5":"markdown","0f270b28":"markdown","549c856e":"markdown"},"source":{"7d8124d0":"import pandas as pd \nimport cv2                 \nimport numpy as np         \nimport os\nimport matplotlib.pyplot as plt\nfrom random import shuffle\nfrom tqdm import tqdm  \nimport scipy\nimport skimage\nfrom skimage.transform import resize","30c22352":"dataset_path = '..\/input\/pap-smear-datasets\/'\nprint(dataset_path)\nfor item in os.listdir(dataset_path):\n    print('  -- ' + item)\n    for sub_item in os.listdir(dataset_path+item+'\/'):\n        print('    -- {} ({} files)'.format(sub_item, len(os.listdir(dataset_path + item + '\/' + sub_item))))","e67890a1":"dataset_path = '..\/input\/pap-smear-datasets\/'\nherlev = dataset_path + 'herlev_pap_smear\/'\nsipakmed = dataset_path + 'sipakmed_fci_pap_smear\/'\nherlev_normal = 0\nherlev_abnormal = 0\nsipakmed_normal = 0\nsipakmed_abnormal = 0\nsipakmed_benign = 0\n\nfor item in os.listdir(herlev):\n    if item[:3] == 'abn': herlev_abnormal = int(herlev_abnormal + len(os.listdir(herlev + item)) \/ 2)\n    elif item[:3] == 'nor': herlev_normal = int(herlev_normal + len(os.listdir(herlev + item)) \/ 2)\nfor item in os.listdir(sipakmed):\n    if item[:3] == 'abn': sipakmed_abnormal = int(sipakmed_abnormal + len(os.listdir(sipakmed + item)) \/ 3)\n    elif item[:3] == 'nor': sipakmed_normal = int(sipakmed_normal + len(os.listdir(sipakmed + item)) \/ 3)\n    elif item[:3] == 'ben': sipakmed_benign = int(sipakmed_benign + len(os.listdir(sipakmed + item)) \/ 3)\n    \nprint(f'herlev_normal: {herlev_normal}')\nprint(f'herlev_abnormal: {herlev_abnormal}')\nprint(f'sipakmed_normal: {sipakmed_normal}')\nprint(f'sipakmed_abnormal: {sipakmed_abnormal}')\nprint(f'sipakmed_benign: {sipakmed_benign}')\nprint(f'total normal: {herlev_normal + sipakmed_normal}')\nprint(f'total abnormal: {herlev_abnormal + sipakmed_abnormal}')","0a179c5c":"Herlev = \"..\/input\/pap-smear-datasets\/herlev_pap_smear\/\"\nSipakmed_fci = \"..\/input\/pap-smear-datasets\/sipakmed_fci_pap_smear\/\"\nSipakmed_wsi = \"..\/input\/pap-smear-datasets\/sipakmed_wsi_pap_smear\/\"\nlist_H = os.listdir(Herlev)\nlist_H.sort(reverse=True)\nlist_S1 = os.listdir(Sipakmed_fci)\nlist_S2 = os.listdir(Sipakmed_wsi)","67a57381":"fig, axes = plt.subplots(7, 6, figsize=(15,15))\nfor i in range(7):\n    axes[i,0].set_title(list_H[i])\n    for j in range(3):\n        img_list = os.listdir(Herlev+list_H[i])\n        img_list = [item for item in img_list if item[-5] != 'd']\n        img_name = '{}{}\/{}'.format(Herlev, list_H[i], img_list[j*2-1])\n        img_d_name = img_name[:-4]+'-d'+img_name[-4:].lower()\n        img = plt.imread(img_name)\n        img_d = plt.imread(img_d_name)\n        axes[i, 2*j].imshow(img)\n        axes[i, 2*j+1].imshow(img_d)\nplt.tight_layout()\nplt.show()","1d79eb10":"import matplotlib.cm as cm\n\n# Contrast manipulator function\ndef contrast(x, a, b):\n    k = 1\/(b-a)\n    l = -k*a\n    return max(min(x*k+l, 1), 0)\n\ncontrast_v = np.vectorize(contrast, otypes=[float])\n\n# Effect visualization\nx = np.linspace(0,1)\nplt.plot(x, contrast_v(x, 0.25, 0.75))\nplt.title('k = 2, l = -0.5')\n# plt.plot(x, x, '--')\nplt.show()\n\n# Example using an image\nimg = plt.imread(Herlev+'\/normal_intermediate\/153955676-153955721-001.BMP')\nimg_gs = img.sum(axis=2)       # Convert to grayscale\nimg_gs = img_gs\/img_gs.max()   # Normalize\nimg_contrasted = contrast_v(img_gs, 0.2, 0.8)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize = (10, 4))\nax1.imshow(img_gs, cmap='gray')\nax1.set_title('original')\nax2.imshow(img_contrasted, cmap='gray')\nax2.set_title('contrasted')\nfig.colorbar(mappable = cm.ScalarMappable(cmap='gray'), ax=[ax1,ax2])\nfig.show()","53272f2e":"a_space = np.linspace(0, 1, 10)\nb_space = np.linspace(0, 1, 10)\n\nimg = plt.imread(Herlev+'\/normal_intermediate\/153955676-153955721-001.BMP')\nimg_gs = img.sum(axis=2)       # Convert to grayscale\nimg_gs = img_gs\/img_gs.max()   # Normalize\n\nfig, ax = plt.subplots(len(a_space), len(b_space)-1, figsize = (30,30))\nax[0,0].imshow(img_gs, cmap='gray')\nax[0,0].set_title('original')\ni = 1\nfor a in a_space:\n    j = 0\n    for b in b_space:\n        if b > a:\n            ax_current = ax[i, 9-i-j]\n            ax_current.imshow(contrast_v(img_gs, a, b), cmap='gray')\n            ax_current.set_title('a = {:.2f}, b = {:.2f}'.format(a, b))\n            j = j+1\n    i = i+1\n\nfor axis in ax.flat: axis.axis('off')\nfig.show()","8c2cb2ad":"img = plt.imread(Herlev+'\/normal_intermediate\/153955676-153955721-001.BMP')\nimg_gs = img.sum(axis=2)       # Convert to grayscale\nimg_gs = img_gs\/img_gs.max()   # Normalize\n\n# Apply a 3x3 convolution to an m-by-n matrix\ndef convolve(matrix, pattern):\n    [m, n] = matrix.shape\n    output = np.zeros((m-1, n-1))\n    for i in range(1, m-1):\n        for j in range(1, n-1):\n            output[i-1,j-1] = (matrix[i-1:i+2,j-1:j+2]*pattern).sum()\n    return output\n\npattern_horizontal = np.array([[-1, -1, -1],\n                               [0, 0, 0],\n                               [1, 1, 1]])\/6\n\npattern_vertical = np.array([[-1, 0, 1],\n                             [-1, 0, 1],\n                             [-1, 0, 1]])\/6\n\nc1 = convolve(img_gs, pattern_horizontal)\nc2 = convolve(img_gs, pattern_vertical)\n\nfix, ax = plt.subplots(1, 4, figsize = (15, 4))\nax[0].imshow(img_gs, cmap = 'gray')\nax[0].set_title('original')\nax[1].imshow(c1, cmap = 'gray')\nax[1].set_title('horizontal edges')\nax[2].imshow(c2, cmap = 'gray')\nax[2].set_title('vertical edges')\nax[3].imshow(c1+c2, cmap = 'gray')\nax[3].set_title('summed')\nfig.colorbar(mappable = cm.ScalarMappable(cmap='gray'), ax=ax)\nfor axis in ax.flat: axis.axis('off')\n\nfig.show()\n","37fdc1e0":"import csv\n\npath = '..\/input\/pap-smear-datasets\/sipakmed_fci_pap_smear\/normal_Parabasal\/'\n\ni = 0\nimages = []\ncyt_paths = []\nnuc_paths = []\nfor img_name in [item for item in os.listdir(path) if item[-4:] == '.bmp']:\n    designation = img_name[:-4]\n    \n    images.append(plt.imread(path + designation + '.bmp'))\n\n    cyt_path = []\n    with open(path + designation + '_cyt.dat') as f:\n        r = csv.reader(f, delimiter = ',')\n        for row in r: cyt_path.append([float(row[0]), float(row[1])])\n    cyt_paths.append(np.array(cyt_path))\n    \n    nuc_path = []\n    with open(path + designation + '_nuc.dat') as f:\n        r = csv.reader(f, delimiter = ',')\n        for row in r: nuc_path.append([float(row[0]), float(row[1])])\n    nuc_paths.append(np.array(nuc_path))\n    i = i+1\n    if i>10: break\n    \nfig, ax = plt.subplots(len(images), 2, figsize = (10,40))\nfor i, [img, cyt, nuc] in enumerate(zip(images, cyt_paths, nuc_paths)):\n    ax[i, 0].imshow(img)\n    ax[i, 1].imshow(img)\n    ax[i, 1].plot(cyt[:,0], cyt[:,1])\n    ax[i, 1].plot(nuc[:,0], nuc[:,1])\nax[0,1].legend(['cytoplasm', 'nucleus'])\nfig.show()","b02c39ae":"Na kraju \u010detvrtog reda odozdo vidimo da se jezgra vrlo dobro isti\u010de od svojeg okru\u017eenja - ona ostaje sasvim crna, dok je citoplazma oko nje potpuno pobjelila. U zadnjem redu vidimo da je cijela citoplazma vrlo tamna, dok je podru\u010dje oko stanice i dalje vrlo svjetlo. Vjerujemo da \u0107emo uz malo finiju manipulaciju ovog tipa vrlo lako mo\u0107i segmentirati stanice. Isto tako mo\u017eemo na sliku primjeniti neke rudimentarne konvolucije (npr. detekcija horizontalnih i vertikalnih rubova) i vidjeti ho\u0107e li to pomo\u0107i pri segmentaciji: ","46ab8e29":"## Podaci iz bolnice Herlev\n\nPodaci iz bolnice Herlev podjeljeni su na sedam skupina - 4 vrste abnormalnih (pre-malignih) stanica i tri vrste normalnih stanica. Podaci u ovom skupu dolaze i sa segmentiranim verzijama slika, pri \u010demu je svaka slika podjeljena na jezgru stanice, citoplazmu te podru\u010dje izvan stanice. Na sljede\u0107oj slici je uzorak nekih od slika u pitanju te njihovih segmentiranih ina\u010dica:\n","aa2c65d0":"Sada mo\u017eemo primjeniti funkciju na gornji primjer sa vi\u0161e razli\u010ditih vrijednosti za $k$ i $l$ kako bismo vidjeli kako \u0107e se rezultat pona\u0161ati. $a$ i $b$ su vrijednosti u kojima pravac $kx+l$ sje\u0107e pravce $y=0$ i $y=1$, respektivno ","d3ea21f1":"Vidimo da je u ovom slucaju znacajno teze razaznati granicu izmedu citoplazme i podru\u010dja izvan stanica, \u010dak i ljudskom oku, pa \u0107e biti vrlo te\u0161ko konstruirati preciznu automatsku segmentaciju. ","0aedc543":"Odmah vidimo ta je karakteristika abnormalnih stanica vrlo velika jezgra u odnosu na ostatak stanice - u nekim primjerima, ona zauzima gotovo cijelu stanicu. Mo\u017eemo zaklju\u010diti sljede\u0107e: kada bismo mogli automatizirati segmentaciju prikazanu gore (nau\u010diti ra\u010dunalo da razlikuje jezgru od citoplazme), mo\u017eda je dovoljno usporediti njihove veli\u010dine da bismo dobili dobru ideju o tome je li neka stanica abnormalna ili nije. S obzirom da je to problem binarne klasifikacije na osnovu jedne numeri\u010dke karakteristike, on je rje\u0161iv jednostavnom logisti\u010dkom regresijom. \n\n### Segmentacija stanica\n\nAko je gornji zaklju\u010dak to\u010dan, glavni problem kojeg treba rije\u0161iti je segmentacija. Na slikama odmah primje\u0107ujemo da je jezgra puno tamnije boje od citoplazme, koja je pak tamnija od podru\u010dja izvan stanice. Da bismo pomogli ra\u010dunalu da razazna razliku izme\u0111u ta tri podru\u010dja, mo\u017eemo se poigrati sa kontrastom na slikama kako bismo naglasili razliku u ja\u010dini boje. \n\nU sljede\u0107em primjeru na slike po elementima djelujemo sa funkcijom \n\n$$\nf(x) = \\max(\\min(kx+l), 1), 0)\\\\\nk > 0, l < 0\n$$\nkoja na segmentu $[0, 1]$ izgleda ovako:","9cacdaa2":"'Columnar', 'superficial' i 'intermediate' ozna\u010davaju tip stanice, dok 'light', 'moderate' i 'severe dysplastic' ozna\u010davaju stupanj abnormalnosti stanica. Podaci iz SIPaKMeD-a su podjeljeni na 'wsi' (whole slide images) - slike cijelih slajdova sa mno\u0161tvom stanica na svakoj slici, te 'fci' (full cell images) - slike pojedina\u010dnih stanica, te su dalje podjeljene na vrste stanice i tipove abnormalnosti. \n\nPri klasifikaciji \u0107emo primjere vjerojatno razvrstavati samo na dvije klase - normalne i abnormalne, radi jednostavnosti izvedbe. Nadalje, slike cijelih slajdova \u0107emo ve\u010dinom ignorirati, te \u0107emo se baviti klasifikacijom pojedina\u010dnih stanica. Promotrimo broj primjera u svakom skupu:","91f244a5":"Vidimo da imamo relativno malen broj podataka iz bolnice Herlev, te su jo\u0161 uz to lo\u0161e balansirani (puno vi\u0161e primjera abnormalnih stanica nego normalnih). Stoga \u0107emo za bilo kakav trening modela strojnog u\u010denja morati kombinirati primjere iz Herlev i SIPaKMeD baza, a mo\u017eda \u0107ak i umjetno pro\u0161iriti te baze nekim transformacijama slika (zrcaljenjem, rotacijom, smicanjem i sli\u010dnim). ","0f270b28":"## SIPaKMeD baza (pojedina\u010dne stanice)\n\nUz svaku sliku u ovoj bazi dolaze jo\u0161 dvije .dat datoteke - CSV datoteke koje opisuju poligone koji okru\u017euju jezgru i citoplazmu stanice na slici. Na primjer:","549c856e":"# Eksploratorna analiza podataka o PAPA testova vrata maternice\n\nPodaci dolaze iz dva izvora - bolnice Herlev u Copenhagenu i SIPaKMeD-a - baze podataka posebno sastavljene za ovu svrhu. Sastoje se od niza slika pojedina\u010dnih stanica vrata maternice, te cijelih slajdova takvih da se na svakoj slici nalaze brojne stanice odjednom. "}}