{"cell_type":{"8204398b":"code","9287146f":"code","d8377535":"code","49cf3aa2":"code","97953a9b":"markdown","2f94c0e9":"markdown"},"source":{"8204398b":"%%writefile greedy_agent.py\n\nfrom kaggle_environments.envs.hungry_geese.hungry_geese import Observation, Configuration, Action, row_col\n\n\ndef greedy_agent(obs_dict, config_dict):\n    \"\"\"This agent always moves toward observation.food[0] but does not take advantage of board wrapping\"\"\"\n    observation = Observation(obs_dict)\n    configuration = Configuration(config_dict)\n    player_index = observation.index\n    player_goose = observation.geese[player_index]\n    player_head = player_goose[0]\n    player_row, player_column = row_col(player_head, configuration.columns)\n    food = observation.food[0]\n    food_row, food_column = row_col(food, configuration.columns)\n\n    if food_row > player_row:\n        return Action.SOUTH.name\n    if food_row < player_row:\n        return Action.NORTH.name\n    if food_column > player_column:\n        return Action.EAST.name\n    return Action.WEST.name","9287146f":"%%writefile agent.py\n\nfrom kaggle_environments.envs.hungry_geese.hungry_geese import Observation, Configuration, Action, row_col, min_distance\nfrom itertools import chain\nimport numpy as np\n\n# Presettings for directions\nlast_direction = ''\n\n# Create dictionary of opposite directions \nopposite_direction = {Action.SOUTH.name: Action.NORTH.name,\n                      Action.NORTH.name: Action.SOUTH.name,\n                      Action.EAST.name: Action.WEST.name,\n                      Action.WEST.name: Action.EAST.name,\n                     '': ''}\n\n\ndef possible_moves(position, rows, columns):\n    \"\"\"Generate all possible moves from position\"\"\"\n    \n    # Current position decoding\n    row, column = row_col(position, columns)\n    \n    # Possible moves\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n\n    # Try to move in each direction\n    possible_moves_ = []\n    for x, y in zip(dx, dy):\n        new_row = (row + x + rows) % rows\n        new_column = (column + y + columns) % columns\n        possible_moves_.append(new_row * columns + new_column)\n\n    return possible_moves_\n    \n    \ndef make_move(from_, to_, rows, columns):\n    \"\"\"Returns direction in which we should go if we want to move from from_ position to to_ position\"\"\"\n    \n    # Convert positions to row-column\n    from_row, from_column = row_col(from_, columns)\n    to_row, to_column = row_col(to_, columns)\n\n    # Count differences between from and to\n    row_diff = from_row - to_row\n    column_diff = from_column - to_column\n    \n    # Edge cases (if we want to go out of board)\n    if row_diff == rows-1:\n        return Action.SOUTH.name\n    elif row_diff == -(rows-1):\n        return Action.NORTH.name\n    elif column_diff == columns-1:\n        return Action.EAST.name\n    elif column_diff == -(columns-1):\n        return Action.WEST.name\n    \n    # Most likely case of move\n    if to_row > from_row:\n        return Action.SOUTH.name\n    if to_row < from_row:\n        return Action.NORTH.name\n    if to_column > from_column:\n        return Action.EAST.name\n    return Action.WEST.name\n\n    \ndef distance(pos1, pos2, columns):\n    \"\"\"Compute distance between two positions\"\"\"\n    \n    # Convert pos to row-column format\n    pos1_row, pos1_column = row_col(pos1, columns)\n    pos2_row, pos2_column = row_col(pos2, columns)\n    \n    # Compute distance\n    distance = abs(pos1_row - pos2_row) + abs(pos1_column - pos2_column)\n    \n    return distance\n\n\ndef get_closest_food_index(player, food, columns):\n    \"\"\"Finds the closest food index between goose and array of foods.\"\"\"\n    \n    # Compute distance from player position to all food items\n    distances = [\n        distance(player, food_position, columns)\n        for food_position in food\n    ]\n    \n    # Find closest food index\n    closest_index = np.argmin(distances)\n    \n    return closest_index\n\n\ndef get_goose_next_placement(goose, observation, configuration):\n    \"\"\"Find goose placement on the next step.\"\"\"\n    \n    if not goose:\n        return set()\n    \n    # Retrieve basic information for goose\n    goose_head = goose[0]\n    rows, columns = configuration.rows, configuration.columns\n    \n    # Get all possible moves\n    possible_moves_ = possible_moves(goose_head, rows, columns)\n    \n    # Placement of goose is equal to current placement and one cell towards food\n    next_move_placement = set(goose + possible_moves_)\n\n    return next_move_placement\n\n\ndef custom_agent(obs_dict, config_dict):\n    \"\"\"Customized version of organizers agent with modifications in choosing food item and in choosing next move.\"\"\"\n    \n    # Create python objects of game\n    observation = Observation(obs_dict)\n    configuration = Configuration(config_dict)\n    rows, columns = configuration.rows, configuration.columns\n    \n    # Get basic information about ourself\n    player_index = observation.index\n    player_goose = observation.geese[player_index]\n    player_head = player_goose[0]\n    player_row, player_column = row_col(player_head, columns)\n\n    # Get information about geese positions of other players\n    geese_positions = observation.geese\n    geese_positions.pop(player_index)\n    \n    # Find positions which will be used by others geese in the next move\n    dangerous_geese_positions = [get_goose_next_placement(goose, observation, configuration)\n                                 for goose in geese_positions]\n    dangerous_geese_positions = list(chain.from_iterable(dangerous_geese_positions))\n    \n    # Find closest food and get its position\n    closest_food_index = get_closest_food_index(player_head, observation.food, columns)\n    food = observation.food[closest_food_index]\n    \n    # Get all possible moves\n    possible_moves_ = possible_moves(player_head, rows, columns)\n\n    # Get distances to the food and sort moves by their distance to food\n    moves_distances = [distance(move, food, columns) for move in possible_moves_]\n    preferred_moves = [possible_moves_[idx] for idx in np.argsort(moves_distances)]\n    \n    # Default move direction\n    new_direction = Action.NORTH.name\n    global last_direction\n    \n    # Check if agent is in the next cell\n    for move in preferred_moves:\n        if move not in dangerous_geese_positions and move not in player_goose:\n            # Get direction of new move\n            temp_direction = make_move(player_head, move, rows, columns)\n            \n            # Check if direction is not going 180 degees to current direction\n            if temp_direction != opposite_direction[last_direction]:\n                new_direction = temp_direction\n                break\n    \n    # Update direction of last move \n    last_direction = new_direction\n    \n    return new_direction","d8377535":"!pip install kaggle_environments==1.7.6","49cf3aa2":"from kaggle_environments import evaluate, make, utils\nenv = make(\"hungry_geese\")\n\nenv.reset()\nenv.run(\n    [\n        \"agent.py\", \n        \"greedy_agent.py\",\n        \"agent.py\", \n        \"greedy_agent.py\"\n        \n    ],\n)\nenv.render(mode=\"ipython\", width=800, height=700)","97953a9b":"# Greedy Agent function from organizers","2f94c0e9":"# Custom Greedy Agent\n\nHere some modifications were done:\n* Find the closest food item and go to it\n* Try to move in each of 4 possible directions and choose the optimal one\n* Before making a move check wheather it will be counteracting with other geese bodies"}}