{"cell_type":{"d1198ac5":"code","b89e248c":"code","f976edfc":"code","7ae55e47":"code","adc6fd60":"code","1c6d46bf":"code","1b9b4972":"code","15aad2b1":"code","483de3bf":"code","b7bd1725":"code","7abb5e28":"code","3c95c972":"code","cb9a924e":"code","6dae2a4e":"code","87e9e6d3":"code","b6714982":"code","413b5809":"code","f8a80ce8":"code","1641b6f6":"markdown","85442e85":"markdown","b70edfa6":"markdown","282eb993":"markdown","98aee244":"markdown","992ae6a8":"markdown","0fbd9a78":"markdown","dcd06194":"markdown"},"source":{"d1198ac5":"import joblib\nimport torch\ndevice = 'gpu' if torch.cuda.is_available() else 'cpu'\nimport numpy as np\nimport pandas as pd\npd.options.display.max_columns = 100\nimport lightgbm as lgb\nfrom lightgbm import LGBMClassifier\nfrom sklearn.model_selection import StratifiedKFold, RepeatedStratifiedKFold\nfrom sklearn.metrics import log_loss, accuracy_score\nfrom sklearn.preprocessing import QuantileTransformer, StandardScaler, PolynomialFeatures, LabelEncoder\nfrom sklearn.feature_selection import VarianceThreshold, SelectKBest\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport optuna\nimport tqdm\nimport gc\nimport os\nroot_path = '\/kaggle\/input\/tabular-playground-series-may-2021'\n\n#https:\/\/www.kaggle.com\/c\/ieee-fraud-detection\/discussion\/104603\n\ndef robust_pow(num_base, num_pow):\n    # numpy does not permit negative numbers to fractional power\n    # use this to perform the power algorithmic\n\n    return np.sign(num_base) * (np.abs(num_base)) ** (num_pow)\n\ndef focal_binary_object(pred, dtrain):\n    gamma_indct = 2.5\n    # retrieve data from dtrain matrix\n    label = dtrain.get_label()\n    # compute the prediction with sigmoid\n    sigmoid_pred = 1.0 \/ (1.0 + np.exp(-pred))\n    # gradient\n    # complex gradient with different parts\n    g1 = sigmoid_pred * (1 - sigmoid_pred)\n    g2 = label + ((-1) ** label) * sigmoid_pred\n    g3 = sigmoid_pred + label - 1\n    g4 = 1 - label - ((-1) ** label) * sigmoid_pred\n    g5 = label + ((-1) ** label) * sigmoid_pred\n    # combine the gradient\n    grad = gamma_indct * g3 * robust_pow(g2, gamma_indct) * np.log(g4 + 1e-9) + \\\n           ((-1) ** label) * robust_pow(g5, (gamma_indct + 1))\n    # combine the gradient parts to get hessian components\n    hess_1 = robust_pow(g2, gamma_indct) + \\\n             gamma_indct * ((-1) ** label) * g3 * robust_pow(g2, (gamma_indct - 1))\n    hess_2 = ((-1) ** label) * g3 * robust_pow(g2, gamma_indct) \/ g4\n    # get the final 2nd order derivative\n    hess = ((hess_1 * np.log(g4 + 1e-9) - hess_2) * gamma_indct +\n            (gamma_indct + 1) * robust_pow(g5, gamma_indct)) * g1\n\n    return grad, hess","b89e248c":"#preprocessing\n\ntrain = pd.read_csv(os.path.join(root_path, 'train.csv'))\ntest = pd.read_csv(os.path.join(root_path, 'test.csv'))\nsample_submission = pd.read_csv(os.path.join(root_path, 'sample_submission.csv'))\n\n#label mapping\nunique_targets = train['target'].unique().tolist()\nlabel_mapping = dict(zip(unique_targets, [int(i[-1]) - 1 for i in unique_targets]))\n\ntrain['target'] = train['target'].map(label_mapping)\ndataset = pd.concat([train, test], axis = 0, ignore_index = True)\ntrain_len = len(train)\n\nfeatures = dataset.drop(['id', 'target'], axis=1).columns.tolist()\ncategorical_feature_columns = (dataset[features].apply(lambda x: x.nunique(), axis = 0)\n                               .rename('n_unique').to_frame()\n                               .query('n_unique < 10').index.tolist())\n\nlabel = LabelEncoder() \n#Not needed: in other challenges there were proper categorical string cols, so I did this and kept it here\n\nfor column in categorical_feature_columns:\n    label.fit(dataset[column])\n    dataset[column] = label.transform(dataset[column])\n        \ncategorical_features = list(range(len(categorical_feature_columns)))\n\ntrain_preprocessed = dataset[:train_len]\ntest_preprocessed = dataset[train_len:]\n\nassert train_preprocessed.shape[1] == test_preprocessed.shape[1]\n\ndel train, test\ngc.collect()\ncat_indices = [features.index(i) for i in categorical_feature_columns]","f976edfc":"#Set to False if you want to skip it\n\nOPTUNA_OPTIMIZATION = True\nN_SPLITS = 5 #Number of folds for validation\nN_TRIALS = 3 #Number of trials to find best hyperparameters\nTIME = 3600*6 #Time to run optimization (alternative to N_TRIALS)\nFOLD_RANDOM_SEED = 42\nREPEATED_FOLD = True #Whether to use RepeatedStratifiedKFold over StratifiedKFold\n\nFIXED_PARAMS = {\"random_state\": 42,\n                \"num_classes\": len(unique_targets),\n                \"categorical_feature\": cat_indices,\n                \"verbosity\": -1,\n                \"n_jobs\": -1}","7ae55e47":"best_params_v8 = {'cat_smooth': 26.99876024734043,\n                  \"boosting_type\": 'gbdt',\n                  'subsample': 0.04819398102128819,\n                  'colsample_bytree': 0.29931062204176767,\n                  'reg_lambda': 8.739370560117008,\n                  'reg_alpha': 7.6767068886807674,\n                  'max_depth': 21,\n                  'num_leaves': 62,\n                  'learning_rate': 0.01,\n                  'n_estimators': 1000,\n                  \"random_state\": 42,\n                  \"objective\": \"multiclass\",\n                  \"num_classes\": len(unique_targets),\n                  \"categorical_feature\": cat_indices,\n                  \"verbosity\": -1,\n                  \"n_jobs\": -1,}","adc6fd60":"skfold = StratifiedKFold(N_SPLITS, shuffle = True, random_state = FOLD_RANDOM_SEED)\nif REPEATED_FOLD:\n    skfold = RepeatedStratifiedKFold(N_SPLITS, n_repeats=2, random_state=FOLD_RANDOM_SEED)\n\ndef objective(trial, cv=skfold):\n    \n    param_to_search_lgb = {\n        \"objective\": trial.suggest_categorical('objective', ['multiclass', 'multiclassova']),\n        \"boosting_type\": trial.suggest_categorical('boosting_type', ['gbdt', 'goss', 'dart']),\n        \"n_estimators\": trial.suggest_categorical('n_estimators', [500, 1000, 2500, 5000, 10000]),\n        #'class_weight': trial.suggest_categorical('class_weight', [None, 'balanced']),\n        \"learning_rate\": trial.suggest_categorical('learning_rate', [0.001, 0.005, 0.01, 0.05, 0.1]),\n        'num_leaves': trial.suggest_int('num_leaves', 2, 1024),\n        'max_depth': trial.suggest_int('max_depth', -1, 32),\n        'reg_alpha': trial.suggest_float('reg_alpha', 1E-16, 25),\n        'reg_lambda': trial.suggest_float('reg_lambda', 1E-16, 25),\n        'colsample_bytree': trial.suggest_float('colsample_bytree', 1E-16, 1.0),\n        'subsample': trial.suggest_float('subsample', 1E-16, 1.0),\n        'cat_smooth': trial.suggest_float('cat_smooth', 1.0, 50.0)  \n    }\n    \n    param_lgb = param_to_search_lgb.copy()\n    param_lgb.update(FIXED_PARAMS)\n    \n    \n    val_losses = []\n    losses_1 = []\n    pruning_callback = optuna.integration.LightGBMPruningCallback(trial, 'multi_logloss', valid_name='valid_1') \n    \n    for kfold, (train_idx, val_idx) in tqdm.tqdm(enumerate(cv.split(train_preprocessed[features].values, \n                                                                    train_preprocessed['target'].values))):\n        \n        X_train = train_preprocessed.loc[train_idx, features]\n        y_train = train_preprocessed.loc[train_idx, 'target']\n        \n        X_valid = train_preprocessed.loc[val_idx, features]\n        y_valid = train_preprocessed.loc[val_idx, 'target']\n        \n        d_train = lgb.Dataset(X_train, label=y_train)\n        d_valid = lgb.Dataset(X_valid, label=y_valid)\n        watchlist = [d_train, d_valid]\n        \n        model = lgb.train(param_lgb,\n                      train_set=d_train,\n                      valid_sets=watchlist,\n                      verbose_eval=0,\n                      early_stopping_rounds=100,\n                      callbacks=[pruning_callback])\n    \n        scores = model.predict(X_valid)\n        loss_1 = log_loss(y_valid, scores)\n        losses_1.append(loss_1)\n        \n    \n    return np.average(losses_1)","1c6d46bf":"if OPTUNA_OPTIMIZATION:\n    study = optuna.create_study(study_name = 'lgbm_parameter_opt', direction = 'minimize',\n                                pruner=optuna.pruners.MedianPruner(n_warmup_steps=25))\n    \n    study.enqueue_trial(best_params_v8)\n    #study.optimize(objective, n_trials=1, show_progress_bar=True)\n    study.optimize(objective, timeout=TIME, show_progress_bar=True) \n    \n    trial = study.best_trial\n    \n    print(\"  Value: {}\".format(trial.value))\n    \n    print(\"  Params: \")\n    for key, value in trial.params.items():\n        print(\"    {}: {}\".format(key, value))\n    best_params = FIXED_PARAMS.copy()\n    best_params.update(trial.params)\n    \nelse:\n    trial = {\n            \"random_state\": 42,\n            \"metric\": \"auc\",\n            \"categorical_feature\": cat_indices,\n            \"verbosity\": -1,\n            \"n_estimators\": 20000,\n             'learning_rate': 0.1,\n             'num_leaves': 98,\n             'max_depth': 24,\n             'reg_alpha': 0.6013328384502188,\n             'reg_lambda': 8.864402629739141,\n             'colsample_bytree': 0.8295666531935949,\n             'subsample': 0.5621932264483348,\n             'cat_smooth': 31.788282544015413}\n    best_params=trial","1b9b4972":"#if you wish to save the study\nimport joblib\njoblib.dump(study, 'study.pkl')","15aad2b1":"if OPTUNA_OPTIMIZATION:\n    display(optuna.visualization.plot_intermediate_values(study))","483de3bf":"if OPTUNA_OPTIMIZATION:\n    display()","b7bd1725":"if OPTUNA_OPTIMIZATION:\n    display(optuna.visualization.plot_optimization_history(study, target_name = 'Average Validation LogLoss'))","7abb5e28":"if OPTUNA_OPTIMIZATION:\n    display(optuna.visualization.plot_slice(study, target_name = 'Average Validation LogLoss'))","3c95c972":"if OPTUNA_OPTIMIZATION:\n    display(optuna.visualization.plot_parallel_coordinate(study, target_name = 'Average Validation LogLoss'))","cb9a924e":"if OPTUNA_OPTIMIZATION:\n    display(study.trials_dataframe())","6dae2a4e":"if OPTUNA_OPTIMIZATION:\n    final_model = LGBMClassifier(**best_params)\nelse:\n    final_model = LGBMClassifier(**trial)","87e9e6d3":"test_preds = []\naccuracies = []\nloglosses = []\n\nfor kfold, (train_idx, val_idx) in enumerate(skfold.split(train_preprocessed[features].values, \n                                                          train_preprocessed['target'].values)):\n        \n        final_model.fit(train_preprocessed.loc[train_idx, features], \n                        train_preprocessed.loc[train_idx, 'target'])\n        print('Fitted {}'.format(type(final_model).__name__))\n        \n        val_true = train_preprocessed.loc[val_idx, 'target'].values\n        \n        preds = final_model.predict(train_preprocessed.loc[val_idx, features])\n        probs = final_model.predict_proba(train_preprocessed.loc[val_idx, features])\n        \n        accuracy = accuracy_score(val_true, preds)\n        accuracies.append(accuracy)\n        print('Fold: {}\\t Validation Accuracy: {}\\n'.format(kfold, accuracy))\n        \n        logloss = log_loss(val_true, probs)\n        loglosses.append(logloss)\n        print('Fold: {}\\t Validation logloss: {}\\n'.format(kfold, logloss))\n        \n        test_preds.append(final_model.predict_proba(test_preprocessed[features]))\n        \nprint(\"Best Parameters mean Accuracy: {}\".format(np.mean(accuracies)))\nprint(\"Best Parameters mean logloss: {}\".format(np.mean(loglosses)))","b6714982":"test_predictions = np.mean(test_preds, axis = 0)\nassert len(test_predictions) == len(test_preprocessed)","413b5809":"predictions_df = pd.DataFrame(test_predictions, columns = [\"Class_1\", \"Class_2\", \"Class_3\", \"Class_4\"])\npredictions_df['id'] = sample_submission['id']","f8a80ce8":"predictions_df.to_csv(\"submission.csv\", index = False)","1641b6f6":"<a id = \"submission\"><\/a>\n\n### Submission","85442e85":"<a id=\"optuna\"><\/a>\n\n### Optuna\n\nLook [here](https:\/\/optuna.readthedocs.io\/en\/stable\/tutorial\/) for reference about Optuna library. \n\nLook [here](https:\/\/lightgbm.readthedocs.io\/en\/latest\/pythonapi\/lightgbm.LGBMClassifier.html) for a set of Lightgbm Classifier hyperparameters.","b70edfa6":"## Tabular Playground Series May 2021\n\n<img src=\"https:\/\/i.imgur.com\/uHVJtv0.png\">\n<img src=\"https:\/\/lightgbm.readthedocs.io\/en\/latest\/_images\/LightGBM_logo_black_text.svg\">\n\n<br><br>\n\n### Notebook Contents:\n\n<div id=\"toc_container\" style=\"background: #f9f9f9; border: 1px solid #aaa; display: table; font-size: 95%;\n                               margin-bottom: 1em; padding: 20px; width: auto;\">\n<p class=\"toc_title\" style=\"font-weight: 700; text-align: center\">Notebook Contents<\/p>\n<ul class=\"toc_list\">\n  <li><a href=\"#loading\">0. Imports, Data Loading and Preprocessing<\/a>\n  <li><a href=\"#optuna\">1. Optuna Hyperparameter Optimization<\/a>\n      <br>\n      <ul>\n    <li><a href=\"#optuna_objective\">1.0 Define Objective<\/a><\/li>\n    <li><a href=\"#optuna_study\">1.1 Start Optimization<\/a><\/li>\n    <li><a href=\"#optuna_plots\">1.2 Check Optimization Plots<\/a><\/li>\n  <\/ul>\n<\/li>\n<li><a href=\"#submission\">2. Submission<\/a><\/li>\n<\/ul>\n<\/div>\n\n##### Props\n\nProps to [corochann](https:\/\/www.kaggle.com\/corochann\/optuna-tutorial-for-hyperparameter-optimization), I believe this notebook is the best you can find about Optuna.\n\n--- \n\n<h5> Edit 04th May 2021 <\/h5>\n\n- Added `enqueue_trial` to choose starting parameters\n\n- Added saving of Optuna study\n\n- Added focal_loss as objective: code from [here](https:\/\/www.kaggle.com\/c\/ieee-fraud-detection\/discussion\/104603)","282eb993":"<a id=\"loading\"><\/a>\n\n##### 0. Imports, Data Loading and Preprocessing","98aee244":"_Objective_","992ae6a8":"<a id = \"optuna_plots\"><\/a>\n<h6> Check Optimization plots <\/h6>","0fbd9a78":"<a id = \"optuna_objective\"><\/a>\n<h5> Define Objective <\/h5>\n\n\n\nI have updated the code with the following: \n\n1. Possibility to use [RepeatedStratifiedKFold](https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.model_selection.RepeatedStratifiedKFold.html) for cross validation\n\n2. Define starting parameters for Optuna (read [here](https:\/\/github.com\/optuna\/optuna\/issues\/417)), using `enqueue_trial`\n\n3. Optimizing more than one loss: I've included [focal loss](https:\/\/paperswithcode.com\/method\/focal-loss), which in other contexts has done well with class imbalance.\n\n4. Saving your Optuna study\n\n\n**I will now start from my best params from [version 8](https:\/\/www.kaggle.com\/tomwarrens\/tps-may-2021-lightgbm-optuna?scriptVersionId=61575667)**","dcd06194":"<a id = \"optuna_study\"><\/a>\n<h6> Start Optimization <\/h6>"}}