{"cell_type":{"c5dc7ab7":"code","c5ca0b8d":"code","6d736da2":"code","bd5dfaf7":"code","c3e3f9b5":"code","bbbdef54":"code","401fed61":"code","899a5b7d":"code","df0fe63c":"code","fd71028c":"code","85f8e00f":"code","4bf70007":"code","81156a43":"code","e1f37fed":"code","65881eaf":"code","358c5993":"code","f933c042":"code","dc8cfa1e":"code","aeef00d6":"code","97223add":"code","f2267702":"code","b59ee5ee":"code","af8139ab":"code","8c50cbe3":"code","3497fb5a":"code","d5296d10":"code","bc0db3d8":"code","15c44b8f":"code","7e84cb54":"code","00f73450":"code","bdda7d1e":"code","a806d430":"code","a672f526":"code","30ad131d":"code","5373118e":"code","3c819eba":"code","d8aef6e8":"code","5af7ef91":"code","df1a95ac":"code","ed3996ce":"code","d41454df":"code","b0402511":"code","88b34918":"code","ff9fdd96":"code","067bda5c":"code","6869dde6":"code","227fd6aa":"code","0c436920":"code","0ebdd41b":"code","a302625b":"code","ae5cffd3":"code","3bf850e6":"code","8e43656d":"code","464208d8":"code","5aee22db":"code","478098c6":"code","f95905c4":"code","923567a5":"code","6a4b40cd":"code","096db0df":"markdown","4789e341":"markdown","a922d791":"markdown","cde9b8d7":"markdown","a0ff2ce8":"markdown","db459c3a":"markdown","c0eee943":"markdown","a819683b":"markdown","a9d2adb6":"markdown","59c43438":"markdown","8e9dd7a7":"markdown","fb68faf1":"markdown"},"source":{"c5dc7ab7":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline","c5ca0b8d":"import1= pd.read_csv('..\/input\/pizza-price-prediction\/pizza_v1.csv')\nimport2= pd.read_csv('..\/input\/pizza-price-prediction\/pizza_v2.csv')","6d736da2":"pizza=pd.concat([import1,import2],axis=1)","bd5dfaf7":"pizza = pizza.T.drop_duplicates().T","c3e3f9b5":"pizza['price'] = pizza['price_rupiah'].apply(lambda x:x.split('Rp')[1]).apply(lambda x:x.split(',')[0]).astype(int)\npizza.drop(['price_rupiah','size'],axis=1,inplace=True)","bbbdef54":"pizza = pd.DataFrame(np.delete(np.array(pizza),(7,6),1),columns= pizza.columns.drop_duplicates())","401fed61":"pizza[['diameter','price']]=pizza[['diameter','price']].astype(int)","899a5b7d":"#pizza[pizza['variant']=='spicy_tuna'] = pizza[pizza['variant']=='spicy tuna']","df0fe63c":"pizza= pizza.drop('variant',axis=1).drop_duplicates().reset_index(drop=True)","fd71028c":"pizza.head(3)","85f8e00f":"sns.displot(pizza['price'],color='blue')","4bf70007":"pizza['cost'] = pd.cut(pizza['price'],\n                          bins=[0.0,40.0,70,100,160,np.inf],\n                          labels=['Very Cheap','Cheap','Average','Expensive','Very Expensive'])","81156a43":"pizza['cost'].value_counts().sort_values().plot.barh()","e1f37fed":"from sklearn.model_selection import StratifiedShuffleSplit","65881eaf":"split= StratifiedShuffleSplit(n_splits=1,test_size=0.3,random_state=42)\nfor train_index, test_index in split.split(pizza, pizza[\"cost\"]):\n    strat_train_set = pizza.loc[train_index]\n    strat_test_set = pizza.loc[test_index]","358c5993":"strat_test_set['cost'].value_counts()\/ len(strat_test_set)","f933c042":"for _set in strat_test_set,strat_train_set:\n    _set.drop('cost',axis=1,inplace=True)","dc8cfa1e":"X_train = strat_train_set.drop('price',axis=1)\nX_test = strat_test_set.drop('price',axis=1)\ny_train= strat_train_set['price']\ny_test= strat_test_set['price']","aeef00d6":"prices = pd.concat([strat_train_set.copy(),strat_test_set.copy()]).reset_index(drop=True)","97223add":"from sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.decomposition import PCA","f2267702":"numerical_variables = ['diameter']\ncateg_variables = [col for col in prices if prices[col].dtype == 'object']\nOrdinal_Vars= ['extra_sauce','extra_cheese','extra_mushrooms']\nOneHot_Vars= list(set(categ_variables).difference(Ordinal_Vars))","b59ee5ee":"scaler = StandardScaler(with_mean=False)\nOH = OneHotEncoder(handle_unknown='ignore',sparse=False)\nOE= OrdinalEncoder()\nLNR= LinearRegression()\nPCA = PCA()","af8139ab":"numpipe= Pipeline([\n    ('scaler',scaler)\n])\n\nOHtransformer= Pipeline([\n        ('OneHot',OH),\n        ('Scaler',scaler)\n    ])\n\nOEtransformer= Pipeline([\n        ('OrdinalEncoder',OE),\n        ('Scaler',scaler)\n    ])\n\nPPipe= ColumnTransformer(\n    transformers=\n    [\n    ('Numericals',numpipe,numerical_variables),\n    ('OneHots',OHtransformer,OneHot_Vars),\n    ('Ordinals',OEtransformer,Ordinal_Vars)\n]\n)\n\nFullPipe= Pipeline([\n    ('transforming',PPipe),\n    ('model',LNR)\n])","8c50cbe3":"from sklearn.model_selection import train_test_split","3497fb5a":"FullPipe.fit(X_train,y_train)\nLNRpredictions = FullPipe.predict(X_test)","d5296d10":"from sklearn.linear_model import SGDRegressor","bc0db3d8":"SGD= SGDRegressor(alpha=0.03,max_iter=10000)","15c44b8f":"SGDPipe= Pipeline([\n    ('transforming',PPipe),\n    ('model',SGD)\n])","7e84cb54":"SGDPipe.fit(X_train,y_train)\nSGDpreds= SGDPipe.predict(X_test)","00f73450":"from sklearn.ensemble import RandomForestRegressor\nfrom sklearn.ensemble import GradientBoostingRegressor","bdda7d1e":"RFR= RandomForestRegressor()\nGBR= GradientBoostingRegressor()","a806d430":"RFRPipe= Pipeline([\n    ('transforming',PPipe),\n    ('model',RFR)\n])","a672f526":"RFRPipe.fit(X_train,y_train)\nRFRpreds= RFRPipe.predict(X_test)","30ad131d":"GBRPipe= Pipeline([\n    ('transforming',PPipe),\n    ('model',GBR)\n])","5373118e":"GBRPipe.fit(X_train,y_train)\nGBRpreds= GBRPipe.predict(X_test)","3c819eba":"from sklearn.metrics import mean_absolute_error,r2_score,mean_squared_error","d8aef6e8":"def evaltotable(predictions,y_test):\n    MAE=mean_absolute_error(predictions,y_test)\n    RMSE=np.sqrt(mean_squared_error(predictions,y_test))\n    R2=r2_score(predictions,y_test)\n    return MAE,RMSE,R2","5af7ef91":"modelstocompare= [LNRpredictions,SGDpreds,RFRpreds,GBRpreds]","df1a95ac":"appended=[]\nfor i in modelstocompare:\n    appended.append(evaltotable(i,y_test))","ed3996ce":"modelcomparison= pd.DataFrame(np.array(appended).T,columns=['LR','SGD','RFR','GBR'],\n                              index=['MAE','RMSE','R2']).T.reset_index().rename(columns={'index':'Models'}).sort_values(by='R2',ascending=False).reset_index(drop=True)","d41454df":"modelcomparison","b0402511":"plt.plot(figsize=(12,6))\nsns.barplot(x=modelcomparison['Models'],y=modelcomparison['R2'],palette='cividis')\nplt.title('Coefficient of Determination',fontsize=14)\nplt.ylim(0,0.65)","88b34918":"plt.plot(figsize=(12,6))\nsns.barplot(x=modelcomparison['Models'],y=modelcomparison['MAE'].sort_values(),palette='cividis')\nplt.title('MAE',fontsize=14)\n\nplt.ylim(15,23)","ff9fdd96":"modelcomparison.loc[0]","067bda5c":"plt.figure(figsize=(12,6))\nsns.histplot(GBRpreds,alpha=0.6,color='blue',bins=15)\nsns.histplot(y_test,alpha=0.6,color='green',bins=15)\nplt.title('Real Pricing (Green) & Predicted Prices (Blue)',fontsize=14)","6869dde6":"OH_Varnames= GBRPipe['transforming'].transformers_[1][1].named_steps['OneHot'].get_feature_names()","227fd6aa":"TransformedVariables = ['diameter']+Ordinal_Vars+ OH_Varnames.tolist() ","0c436920":"FeatImportance= pd.DataFrame(GBR.feature_importances_,TransformedVariables,\n                             columns=['Feature Importance']).sort_values(by='Feature Importance',ascending=False)","0ebdd41b":"plt.figure(figsize=(17,10))\nsns.heatmap(FeatImportance,annot=True,lw=1,cmap='cividis')","a302625b":"GBR.estimators_[0][0]","ae5cffd3":"from sklearn import tree","3bf850e6":"fig = plt.figure(figsize=(25,20))\n_ = tree.plot_tree(GBR.estimators_[0][0], \n                   feature_names=TransformedVariables,  \n                   filled=True)","8e43656d":"X_train.drop('diameter',axis=1,inplace=True)\nX_test.drop('diameter',axis=1,inplace=True)","464208d8":"NoDiamPrePro= ColumnTransformer(\n    transformers=\n    [\n    ('OneHots',OHtransformer,OneHot_Vars),\n    ('Ordinals',OEtransformer,Ordinal_Vars)\n]\n)\n\nGBRnoDiam= Pipeline([\n    ('transforming',NoDiamPrePro),\n    ('model',GBR)\n])\n\nRFRnoDiam= Pipeline([\n    ('transforming',NoDiamPrePro),\n    ('model',RFR)\n])\n","5aee22db":"GBRnoDiam.fit(X_train,y_train)","478098c6":"RFRnoDiam.fit(X_train,y_train)","f95905c4":"nodiamRFRpreds= RFRnoDiam.predict(X_test)\nnodiamGBRpreds= GBRnoDiam.predict(X_test)","923567a5":"# RFR\nevaltotable(nodiamRFRpreds,y_test)","6a4b40cd":"#GBR\nevaltotable(nodiamGBRpreds,y_test)","096db0df":"***Stratifying our Target Variable***","4789e341":"*Stochastic Gradient Descent*","a922d791":"*Gradient Boosting Regressor*","cde9b8d7":"***Gradient Boosting Regressor fits our data decently for our sample size, explaining most of the pizza prices by diameter, which makes sense & overfits the data to it. \nWithout the diameter feature & because of the small sample size, no model can adjust to the data. (Shown below)***\n","a0ff2ce8":"*Random Forest Regressor*","db459c3a":"*Setting up Data for Linear Regression*","c0eee943":"*Linear Regression*","a819683b":"## Pizza Pricing ( Low Sample Size )","a9d2adb6":"***Standard Pipeline***","59c43438":"**Model Comparisons**","8e9dd7a7":"**Data Cleaning**","fb68faf1":"**Best Fit Conclusions**"}}