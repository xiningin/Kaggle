{"cell_type":{"5b8bed07":"code","5ea5ef54":"code","d61e0ea8":"code","fa188d63":"code","5a36f95d":"code","e7b1fda3":"code","faa7e4dd":"code","7ecdf21b":"code","c2002a50":"code","438cfa69":"code","183f389c":"code","c9472ce0":"code","64fbe0be":"code","094fb132":"code","0a4bad25":"code","b05b4468":"code","d65f52ae":"code","c1f3f1c1":"code","7b6a7fa9":"markdown","85404ffc":"markdown","1afa9923":"markdown","b318a579":"markdown","c0a07447":"markdown","72d88ad2":"markdown","35ac6741":"markdown","c37195c5":"markdown","8e0d567a":"markdown","991b25d5":"markdown"},"source":{"5b8bed07":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport imblearn\nfrom imblearn.over_sampling import SMOTE\n\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\n\nimport keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense , GlobalAveragePooling2D\nfrom keras.preprocessing.image import img_to_array\nfrom keras.applications.mobilenet_v2 import preprocess_input\nfrom keras.applications import MobileNetV2\n","5ea5ef54":"BC_df = pd.read_csv('..\/input\/breast-cancer\/sample_BC_dataset.csv')\nBC_df.drop(columns={'Unnamed: 0','pixels'},axis=1,inplace=True)\n# BC_df.head()\nBC_df_copy = BC_df.iloc[:10000,:]","d61e0ea8":"from PIL.Image import open\nBC_df_copy['pixels'] =  BC_df_copy['pathes'].map(lambda x:np.asarray(open(x).resize((128,128))))\n\n","fa188d63":"X = BC_df_copy['pixels']\ny =  np.array(BC_df_copy['diagnosis'])","5a36f95d":"X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=0)\nprint('The shape of X_train :'+\" \"+str(X_train.shape))\nprint('The size of X_train :'+\" \"+str(X_train.shape[0]))\n\nprint('The shape of X_test :'+\" \"+str(X_test.shape))\nprint('The size of X_test :'+\" \"+str(X_test.shape[0]))\n","e7b1fda3":"# training set\nimg_list = []\nfor i in range (0,len(X_train)):\n    brain_img =np.array(X_train)[i]\n    img_arr = img_to_array(brain_img).astype(np.float32)\n    img_list.append(preprocess_input(img_arr))\nX_scaled = np.array(img_list)\n\nprint(X_scaled.shape)\n    ","faa7e4dd":"X_train_shape = X_scaled.shape[1]*X_scaled.shape[2]*X_scaled.shape[3]\nX_Flatten = X_scaled.reshape(X_scaled.shape[0],X_train_shape)\n","7ecdf21b":"# start resampling via smote\nfrom imblearn.over_sampling import SMOTE\nsm = SMOTE(random_state=0)\nx_sm,y_sm = sm.fit_resample(X_Flatten,y_train)\n","c2002a50":"#print the size of our dataset after oversampling\nprint('The size of our dataset after oversampling:'+' '+str(y_sm.shape[0]))","438cfa69":"sns.countplot(y_sm )\n","183f389c":"row,col,channel = 128 ,128 , 3 \nX_sm_reshaped = x_sm.reshape(len(x_sm),row,col,channel)\n# chec the shape of our training set\nprint('The shape of the training set after reshape it :'+\" \"+str(X_sm_reshaped.shape))","c9472ce0":"num_classes = 1\nmodel = Sequential([\n     MobileNetV2(input_shape=(224,224,3),weights=\"imagenet\",include_top=False), \n     GlobalAveragePooling2D(),\n     Dense(num_classes, activation='sigmoid',name='preds'),\n])\nmodel.layers[0].trainable= False\n# show model summary\nmodel.summary()","64fbe0be":"model.compile(optimizer='sgd',\n             loss=keras.losses.binary_crossentropy,\n             metrics=['accuracy'])\nmodel.fit(X_sm_reshaped,y_sm\n          ,epochs=20,verbose=1)","094fb132":"# testing set\nimg_test = []\nfor i in range (0,len(X_test)):\n    brain_img_test =np.array(X_test)[i]\n    img_test_arr = img_to_array(brain_img_test).astype(np.float32)\n    img_test.append(preprocess_input(img_test_arr))\nX_scaled_test = np.array(img_test)\n\nprint(X_scaled_test.shape)\n    ","0a4bad25":"eval_score = model.evaluate(X_scaled_test,y_test)\nprint('The loss of the evaluation :'+' '+str(eval_score[0]*100))\nprint('The accuracy of the evaluation :'+' '+str(eval_score[1]*100))","b05b4468":"from sklearn.metrics import classification_report , confusion_matrix\ny_pred = model.predict_classes(X_scaled_test)\ny_pred","d65f52ae":"target_name = ['benign','malignant']\nclassification_report(y_true=y_test , y_pred=y_pred , output_dict=True , target_names= target_name )","c1f3f1c1":"plt.figure(figsize=(10,5))\nsns.heatmap(confusion_matrix(y_true=y_test, y_pred=y_pred),annot=True , fmt='2d')\nplt.title('Confusion Metrix',fontsize=30)\nplt.xlabel('Prediction Label',fontsize=20)\nplt.ylabel('True Label',fontsize=20)","7b6a7fa9":"# splitting the dataset to 80% train and 20% test","85404ffc":"## Get our pixels values ready for the SMOTE ","1afa9923":"# continue the previous work of \nhttps:\/\/www.kaggle.com\/angieashraf\/eda-breast-histopathology","b318a579":"# Get our data ready!","c0a07447":"# Preprocessing our dataset","72d88ad2":"# Performance Evaluation","35ac6741":"### return our data to its real shape (#records , rows, col , #channels)","c37195c5":"# Check the imbalance data one more time ...","8e0d567a":"# Building the model","991b25d5":"## Visualizing our balance dataset  "}}