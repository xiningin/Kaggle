{"cell_type":{"ba29ec59":"code","2bcdd1d6":"code","829259e7":"code","5c5cc969":"code","0dc4579e":"code","1df014e7":"code","e349fe3a":"code","0fe6d994":"code","0afed1a5":"code","c1dd46f3":"code","8ce53e6f":"code","8ab0c7e2":"code","d4a295e9":"code","3f9102a2":"code","df0b835e":"code","24e1124f":"code","028decb7":"code","7a6ebc10":"code","2f472d88":"code","5e8bee14":"code","858d522d":"code","17b5add6":"code","8a895bcd":"code","a41242f7":"code","fba9fefe":"code","de54c163":"code","3838197a":"code","8f6e7fb9":"code","955d81d3":"code","75cce2e8":"code","f76f5f6c":"markdown","88a4a01f":"markdown","c80d2ab5":"markdown","809fa913":"markdown","f1aa9ede":"markdown","9ea9713a":"markdown","69223fb8":"markdown","21896c10":"markdown","cdfe1605":"markdown","75d86426":"markdown","e733a150":"markdown","121770f5":"markdown","b638cbf7":"markdown","df2b3e1c":"markdown","a665e09b":"markdown","da7c1a61":"markdown","00cd804c":"markdown","8a8006a3":"markdown","782d7b37":"markdown","ee7a88bd":"markdown","560e0513":"markdown","a9cac4c6":"markdown","d15b2680":"markdown","82a303dc":"markdown","69b871df":"markdown","a3169ee6":"markdown","0d806ecd":"markdown"},"source":{"ba29ec59":"import numpy as np\nimport pandas as pd\nfrom datetime import timedelta\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\n\nfrom scipy.stats import boxcox\nfrom scipy.special import inv_boxcox, inv_boxcox1p\n\nimport lightgbm as lgb\n\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.metrics import mean_absolute_error\n\nimport os.path as osp\nfrom easydict import EasyDict as edict\nfrom typing import Tuple","2bcdd1d6":"# pd.set_option('display.max_columns', None)\n# pd.set_option('display.max_rows', None)","829259e7":"cfg = edict({\n    'DEBUG': False,\n    'do_rm_outliers': False,\n    'do_seed_averaging': False,\n    'target_transform': 'log',\n#     'target_transform': 'boxcox',\n    'rnd_seed': 334,\n    'lgb_rnd_seed_list': list(range(10)),\n    'root_data': osp.join('..','input','the-datascience-cup-beta'),\n    'num_folds': 10,\n#     'cv_type': 'KFold',\n    'cv_type': 'CStratified'\n})\n\nif cfg.DEBUG:\n    cfg.num_folds = 2","5c5cc969":"train = pd.read_csv(osp.join(cfg.root_data, 'train.csv'), index_col=0)\ntest = pd.read_csv(osp.join(cfg.root_data, 'test.csv'), index_col=0)\nsub = pd.read_csv(osp.join(cfg.root_data, 'sample.csv'), index_col=0)\ndescription = pd.read_csv(osp.join(cfg.root_data, 'description.csv'), index_col=0)","0dc4579e":"if cfg.do_rm_outliers:\n    r_min = train['price'].quantile(0.001)\n    r_max = train['price'].quantile(0.999)\n\n    train = train.query('price < @r_max & price > @r_min')\n    train = train.reset_index(drop=True)\n    print(train.shape[0])","1df014e7":"# \u3053\u308c\u3089\u306e\u30c7\u30fc\u30bf\u306f\u524a\u9664\u3057\u307e\u3057\u305f\ntrain = train.query('price > 0').reset_index(drop=True)\ntrain = train.query('accommodates > 0').reset_index(drop=True)","e349fe3a":"data = pd.concat([train, test], sort=False)","0fe6d994":"data['host_id'] = data['host_since'] + '_' + data['host_neighbourhood']","0afed1a5":"datetime_cols = ['host_since', 'first_review', 'last_review']\nfor col in datetime_cols:\n    data[col] = pd.to_datetime(data[col])\n\ndata['num_days_to_first_review'] = (data['first_review'] - data['host_since']) \/ timedelta(days=1)\ndata['num_days_to_last_review'] = (data['last_review'] - data['host_since']) \/ timedelta(days=1)\ndata['num_days_first_to_last_review'] = (data['last_review'] - data['first_review']) \/ timedelta(days=1)\n\ndata['host_since_year'] = pd.to_datetime(data['host_since']).dt.year\ndata['host_since_month'] = pd.to_datetime(data['host_since']).dt.month\ndata['host_since_day'] = pd.to_datetime(data['host_since']).dt.day","c1dd46f3":"data['host_response_rate'].replace('(.*)%', r'\\1', regex=True, inplace=True)\ndata['host_response_rate'] = data['host_response_rate'].astype('float')\n\ndata['host_acceptance_rate'].replace('(.*)%', r'\\1', regex=True, inplace=True)\ndata['host_acceptance_rate'] = data['host_acceptance_rate'].astype('float')\n\ndata['host_response_acceptance_rate'] = data['host_response_rate'] * data['host_acceptance_rate']","8ce53e6f":"data['sum_min_max_nights'] = data['maximum_nights'] + data['minimum_nights']\ndata['diff_min_max_nights'] = data['maximum_nights'] - data['minimum_nights']\ndata['prod_min_max_nights'] = data['maximum_nights'] * data['minimum_nights']","8ab0c7e2":"data['num_normal_baths'] = data['bathrooms_text'].str.extract(r'([0-9]+\\.?)').astype('float')\n\nexcep_vals = ['Private half-bath', 'Shared half-bath', 'Half-bath']\nfor e_val in excep_vals:\n    data['num_normal_baths'][data['bathrooms_text'] == e_val] = 0.","d4a295e9":"data['half_bath'] = data['bathrooms_text'].str.contains(r'\\.|half|Half') * 1\ndata['private_bath'] = data['bathrooms_text'].str.contains(r'private|Private') * 1\ndata['shared_bath'] = data['bathrooms_text'].str.contains(r'shared|Shared') * 1","3f9102a2":"data['beds_per_person'] = data['beds'].values \/ data['accommodates'].values\ndata['bedrooms_per_person'] = data['bedrooms'].values \/ data['accommodates'].values\ndata['normal_baths_per_person'] = data['num_normal_baths'].values \/ data['accommodates'].values\n\ndata['sum_num_baths_beds'] = data['num_normal_baths'] + data['beds']\ndata['diff_num_baths_beds'] = data['num_normal_baths'] - data['beds']\ndata['prod_num_baths_beds'] = data['num_normal_baths'] * data['beds']\n\ndata['sum_num_baths_bedrooms'] = data['num_normal_baths'] + data['bedrooms']\ndata['diff_num_baths_bedrooms'] = data['num_normal_baths'] - data['bedrooms']\ndata['prod_num_baths_bedrooms'] = data['num_normal_baths'] * data['bedrooms']\n\ndata['sum_beds_bedrooms'] = data['beds'] + data['bedrooms']\ndata['diff_beds_bedrooms'] = data['beds'] - data['bedrooms']\ndata['prod_beds_bedrooms'] = data['beds'] * data['bedrooms']","df0b835e":"data['property_room_type'] = data['property_type'] + '_' + data['room_type']","24e1124f":"data['latitude_longitude'] = data['latitude'].round(2).astype('str') + '_' + data['longitude'].round(2).astype('str')","028decb7":"data['sum_availability_30_60'] = data['availability_30'] + data['availability_60']\ndata['sum_availability_30_60_90'] = data['availability_30'] + data['availability_60'] + data['availability_90']\ndata['sum_availability_30_60_90_365'] = data['availability_30'] + data['availability_60'] + data['availability_90'] + data['availability_365']\ndata['diff_availability_30_60'] = data['availability_60'] - data['availability_30']\ndata['diff_availability_60_90'] = data['availability_90'] - data['availability_60']\ndata['diff_availability_90_365'] = data['availability_365'] - data['availability_90']","7a6ebc10":"cat_cols = ['host_id', 'latitude_longitude', 'property_type']\nagg_cols = [\n    'host_response_rate',\n    'host_acceptance_rate',\n    'accommodates',\n    'minimum_nights',\n    'maximum_nights',\n    'availability_30',\n    'availability_60',\n    'availability_90',\n    'availability_365',\n    'number_of_reviews',\n    'review_scores_rating',\n    'reviews_per_month',\n    'num_days_to_last_review',\n    'num_days_to_first_review',\n    'beds_per_person',\n    'bedrooms_per_person',\n    'normal_baths_per_person',    \n]\nagg_types = ['max', 'min', 'sum', 'mean', 'std', 'count']\n\nfor cat_col in cat_cols:\n    for agg_col in agg_cols:\n        for agg_type in agg_types:\n            if cat_col != agg_col:\n                new_col_name = cat_col + '_' + agg_col + '_' + agg_type\n                temp = data[[cat_col, agg_col]]\n                temp = temp.groupby([cat_col])[agg_col].agg([agg_type]).reset_index().rename(columns={agg_type: new_col_name})\n                temp.index = list(temp[cat_col])\n                temp = temp[new_col_name].to_dict()\n                data[new_col_name] = data[cat_col].map(temp)\n","2f472d88":"data['number_of_NAN'] = data.isna().sum(axis=1).astype(int)","5e8bee14":"plt.hist(data['price'],bins=50)\nplt.show()","858d522d":"if cfg.target_transform == \"log\":\n    data['price'] = np.log10(data['price'] + 1)\n    plt.hist(data['price'], bins=50)\n    plt.show()","17b5add6":"def label_encoding(df, cols):\n    for col in cols:\n        if df[col].dtype == 'object':\n            lbl = LabelEncoder()\n            df[col] = lbl.fit_transform(df[col].fillna('NA').astype(str))\n    return df","8a895bcd":"data = label_encoding(data, data.columns)","a41242f7":"train = data[:len(train)]\ntest = data[-len(test):]","fba9fefe":"if cfg.DEBUG:\n    train = train.iloc[:100, :]","de54c163":"class ContinuousStratifiedKFold:\n    def __init__(self, n_split: int=5, shuffle: bool=True, random_state: int=42) -> None:\n        self.n_split = n_split\n        self.shuffle = shuffle\n        self.random_state = random_state\n\n    def split(self, X: pd.DataFrame, reference: pd.Series, bins: int=20) -> Tuple[np.ndarray, np.ndarray]:\n        min_ref, max_ref = int(reference.min() - 1), int(reference.max() + 1)\n        cut_threshold = np.linspace(min_ref, max_ref, bins)\n        out = pd.cut(reference, bins=cut_threshold, labels=False)\n\n        skf = StratifiedKFold(self.n_split, shuffle=self.shuffle, random_state=self.random_state)\n        for train_idx, val_idx in skf.split(X, out):\n            yield train_idx, val_idx\n\ndef get_continuous_stratified_fold_split(X, y, n_split=cfg.num_folds, shuffle=True, random_state=cfg.rnd_seed):\n    cstratified = ContinuousStratifiedKFold(n_split=n_split, shuffle=shuffle, random_state=random_state)\n    return cstratified.split(X, y)","3838197a":"drop_cols = ['host_since', 'first_review', 'last_review']\nuse_cols = [col for col in data.columns if (col != 'price') and (col not in drop_cols)]","8f6e7fb9":"def lgbm_train_predict(train_df, test_df, use_cols, drop_cols, rnd_seed):\n    y_preds = []\n    scores = []\n    models = []\n    y_test_preds = []\n\n    lgb_params = {\n#         \"objective\": \"regression_l1\",\n#         \"objective\": \"huber\",\n        \"objective\": \"regression_l2\",\n        \"metric\": \"l1\",\n#         \"metric\": \"huber\",\n#         \"metric\": \"l2\",\n#         \"alpha\": 0.9,   # hyper-parameter of Huber Loss (default: 0.9)\n        \"eta\": 0.01,\n        \"seed\": rnd_seed,\n        \"bagging_freq\": 3,\n        \"bagging_fraction\": 0.8,\n        \"feature_fraction\": 0.8\n    }\n\n    if cfg.cv_type == 'KFold':\n        folds_split = KFold(n_splits=cfg.num_folds, random_state=cfg.rnd_seed, shuffle=True).split(train_df[use_cols].values, train_df['price'].values)\n    elif cfg.cv_type == 'CStratified':\n        folds_split = get_continuous_stratified_fold_split(train_df[use_cols].values, train_df['price'].values.flatten(), n_split=cfg.num_folds, shuffle=True, random_state=cfg.rnd_seed)\n    else:   # default: KFold\n        folds_split = KFold(n_splits=cfg.num_folds, random_state=cfg.rnd_seed, shuffle=True).split(train_df[use_cols].values, train_df['price'].values)\n\n\n    for fold, (train_idx, val_idx) in tqdm(enumerate(folds_split)):\n        x_train = train_df[use_cols].iloc[train_idx]\n        x_val = train_df[use_cols].iloc[val_idx]\n        y_train = train_df['price'].iloc[train_idx]\n        y_val = train_df['price'].iloc[val_idx]\n        \n        if cfg.target_transform == \"boxcox\":\n            y_train, boxcox_lambda = boxcox(y_train + 1)\n            y_val = boxcox(y_val + 1, boxcox_lambda)\n\n        lgb_train = lgb.Dataset(x_train, y_train)\n        lgb_val = lgb.Dataset(x_val, y_val, reference=lgb_train)\n        evals_result = {}\n\n        model=lgb.train(lgb_params,\n                      lgb_train,\n                      valid_sets = [lgb_train, lgb_val],\n                      valid_names = ['train', 'valid'],\n                      num_boost_round=10000,\n                      early_stopping_rounds = 100,\n                      verbose_eval = 100,\n                      evals_result = evals_result)\n\n        y_pred = model.predict(x_val)\n\n        # \u4e88\u6e2c\u5024\u3092\u5909\u63db\u524d\u306e\u30b9\u30b1\u30fc\u30eb\u306b\u623b\u3059\n        if cfg.target_transform == \"log\":\n            y_val = np.power(10, y_val) - 1\n            y_pred = np.power(10, y_pred) - 1\n        elif cfg.target_transform == \"boxcox\":\n            y_val = inv_boxcox1p(y_val, boxcox_lambda)\n            y_pred = inv_boxcox1p(y_pred, boxcox_lambda)\n        \n        score = mean_absolute_error(y_val, y_pred)\n        y_preds.append(y_pred)\n        scores.append(score)\n        models.append(model)\n\n        train_metric = evals_result['train']['l1']\n#         train_metric = evals_result['train']['huber']\n#         train_metric = evals_result['train']['l2']\n        eval_metric = evals_result['valid']['l1']\n#         eval_metric = evals_result['valid']['huber']\n#         eval_metric = evals_result['valid']['l2']\n        plt.plot(train_metric, label='train')\n        plt.plot(eval_metric, label='valid')\n        plt.grid()\n        plt.legend()\n        plt.xlabel('rounds')\n        plt.ylabel('scaled score')\n        plt.show()\n\n        # predict test\n        y_test_pred = model.predict(test_df[use_cols])\n        if cfg.target_transform == \"log\":\n            y_test_pred = np.power(10, y_test_pred) - 1\n        elif cfg.target_transform == \"boxcox\":\n            y_test_pred = inv_boxcox1p(y_test_pred, boxcox_lambda)\n        \n        y_test_preds.append(y_test_pred)\n\n    print(f'**********************CV Score is {np.array(scores).mean()}**********************')\n    \n    y_test_preds_avg = np.mean(y_test_preds, axis=0)\n    return models, y_test_preds","955d81d3":"y_test_preds_avg_seed = []\nif cfg.do_seed_averaging:\n    for lgb_seed in cfg.lgb_rnd_seed_list:\n        models, y_test_preds = lgbm_train_predict(train, test, use_cols, drop_cols, lgb_seed)\n        y_test_preds_avg_seed += y_test_preds\n    y_test_preds_avg = np.mean(y_test_preds_avg_seed, axis=0)\nelse:\n    models, y_test_preds = lgbm_train_predict(train, test, use_cols, drop_cols, cfg.rnd_seed)\n    y_test_preds_avg = np.mean(y_test_preds, axis=0)","75cce2e8":"submission = pd.DataFrame({\"index\": test.index, \"price\": y_test_preds_avg})\nsubmission.to_csv(\"submission.csv\",index=False)","f76f5f6c":"## host_id","88a4a01f":"## availability_30, 60, 90, 365","c80d2ab5":"## number_of_NAN","809fa913":"## bathrooms_text","f1aa9ede":"# Submission","9ea9713a":"# Label Encoding","69223fb8":"# Configuration","21896c10":"## latitude, longitude\n\u7d4c\u7def\u5ea6\u306e\u5024\u3092\u9069\u5f53\u306a\u6841\u3067\u5c0f\u6570\u70b9\u3092\u4e38\u3081\u3066\u30b0\u30ea\u30c3\u30c9\uff08\u30ab\u30c6\u30b4\u30ea\uff09\u3068\u3057\u3066\u3044\u307e\u3059.  \n\u4e38\u3081\u308b\u6841\u6570\u306f\u3001\u4f5c\u6210\u3057\u305f\u30ab\u30c6\u30b4\u30ea\u6570\u304c\u591a\u3059\u304e\u305a\u3001\u5c11\u306a\u3059\u304e\u306a\u3044\u3088\u3046\u306b\u6c7a\u3081\u307e\u3057\u305f.","cdfe1605":"\u9593\u9055\u3063\u3066\u308b\u7b87\u6240\u3084\u3053\u3046\u3057\u305f\u65b9\u304c\u3044\u3044\u3088\uff01\u3068\u3044\u3046\u7b87\u6240\u3082\u3042\u308b\u3068\u601d\u3044\u307e\u3059.  \n\u8272\u3005\u3068\u30b3\u30e1\u30f3\u30c8\u3044\u305f\u3060\u3051\u308b\u3068\u5b09\u3057\u3044\u3067\u3059\uff01\uff01","75d86426":"# Feature Engineering\nKaggle \u306e\u30c6\u30af\u30cb\u30c3\u30af\u3092\u8272\u3005\u3068\u8abf\u3079\u3066\u307f\u308b\u3068, LightGBM, XGBoost \u306a\u3069\u306e\u6c7a\u5b9a\u6728\u7cfb\u306e\u30e2\u30c7\u30eb\u3067\u306f, \u6570\u5024\u306e\u7279\u5fb4\u91cf\u540c\u58eb\u3092\u56db\u5247\u6f14\u7b97\u3057\u3066\u65b0\u305f\u306b\u7279\u5fb4\u91cf\u3092\u4f5c\u308b\u3068\u3044\u3063\u305f\u3053\u3068\u304c\u4e88\u6e2c\u7cbe\u5ea6\u306e\u9762\u3067\u306f\u6709\u52b9\u306a\u3053\u3068\u304c\u3042\u308b\u3088\u3046\u3067\u3059.  \n\u305f\u3060\u3057, \u30e2\u30c7\u30eb\u306e\u7d50\u679c\u306e\u89e3\u91c8\uff08\u7279\u5fb4\u91cf\u306e\u91cd\u8981\u5ea6\u306e\u89e3\u91c8\uff09\u304c\u96e3\u3057\u304f\u306a\u308a\u305d\u3046\u3067\u3059.","e733a150":"## property type, room type","121770f5":"# Libraries","b638cbf7":"# Load dataset","df2b3e1c":"# Modeling","a665e09b":"## minimum, maximum_nights","da7c1a61":"### Continuous Stratified KFold","00cd804c":"# Comment\n\u30b3\u30f3\u30da\u4e2d\u306b\u8a66\u3057\u305f\u3053\u3068\u3092\u307e\u3068\u3081\u307e\u3057\u305f.\n\n\u6700\u521d\u306e\uff11\u9031\u9593\u304f\u3089\u3044\u306f 1. \u306e\u7279\u5fb4\u91cf\u30a8\u30f3\u30b8\u30cb\u30a2\u30ea\u30f3\u30b0\u3092\u305a\u3063\u3068\u9811\u5f35\u308a\u307e\u3057\u305f\u304c, 8\u4f4d\u304f\u3089\u3044\u304b\u3089\u30b9\u30b3\u30a2\u304c\u5168\u304f\u4e0a\u304c\u3089\u305a\u4e0a\u4f4d\u306e\u65b9\u3068\u306e\u5dee\u304c\u958b\u304f\u3070\u304b\u308a\u3067\u3057\u305f.  \n\u660e\u3089\u304b\u306b\u81ea\u5206\u3068\u306f\u30b9\u30b3\u30a2\u306e\u5dee\u304c\u3042\u308b\u3088\u3046\u306b\u611f\u3058\u305f\u306e\u3067, \u8996\u70b9\u3092\u5909\u3048\u3066 2. \u306e\u76ee\u7684\u5909\u6570\u306e\u5909\u63db\u3084 3. \u306e Loss \u306e\u5909\u66f4\u3092\u8a66\u3057\u305f\u3089\u304b\u306a\u308a\u30b9\u30b3\u30a2\u304c\u6539\u5584\u3057\u3066\u4e0a\u4f4d\u306b\u98df\u3044\u8fbc\u3081\u307e\u3057\u305f.\n\n1. \u69d8\u3005\u306a\u7279\u5fb4\u91cf\u3092\u4f5c\u3063\u3066\u307f\u308b\n    - \u4e88\u6e2c\u306b\u52b9\u304d\u305d\u3046\u306a\u7279\u5fb4\u91cf\u3092\u8003\u3048\u3066\u4f5c\u308b\n    - \u30ab\u30c6\u30b4\u30ea\u5909\u6570\u306e\u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306e\u5e73\u5747\u5024\u306a\u3069\u306e\u7279\u5fb4\u91cf\u3092\u4f5c\u308b (aggregate)\n        - \u7d4c\u7def\u5ea6\u304c\u91cd\u8981\u305d\u3046\u3060\u3063\u305f\u306e\u3067, \u7d4c\u7def\u5ea6\u3092\u30b0\u30ea\u30c3\u30c9\u306b\u3057\u305f\u30ab\u30c6\u30b4\u30ea\u5909\u6570\u3092\u65b0\u305f\u306b\u4f5c\u6210 (longitude_latitude)\n        - \u3053\u306e longitude_latitude \u3068, \u305d\u308c\u3067 aggregate \u3057\u305f\u7279\u5fb4\u91cf\u304c\u304b\u306a\u308a\u30b9\u30b3\u30a2\u306b\u52b9\u3044\u3066\u3044\u305f (\u30b3\u30f3\u30da\u7d42\u4e86\u5f8c\u306b\u691c\u8a3c. \u3053\u306e\u7279\u5fb4\u91cf\u306a\u304b\u3063\u305f\u3089\u512a\u52dd\u3067\u304d\u3066\u306a\u304b\u3063\u305f\u3067\u3059\u306d...)\n            - \u6700\u7d42 submit \u306e\u30e2\u30c7\u30eb (10fold, seed averaging \u306a\u3057) : <font color=\"Red\">Public=8009.56952, Private=8073.29332<\/font>\n            - \u3053\u306e\u30e2\u30c7\u30eb\u304b\u3089 longitude_latitude \u3068 aggregate \u3057\u305f\u7279\u5fb4\u91cf\u3092\u5168\u3066\u524a\u9664\u3057\u305f\u30e2\u30c7\u30eb : <font color=\"Red\">Public=8303.52010, Private=8401.28172<\/font>\n    - \u6570\u5024\u306e\u7279\u5fb4\u91cf\u540c\u58eb\u306e\u56db\u5247\u6f14\u7b97\n    - target encoding (\u30ab\u30c6\u30b4\u30ea\u5909\u6570\u306e\u5024\u3092\u76ee\u7684\u5909\u6570\u306e\u5e73\u5747\u5024\u3067\u7f6e\u304d\u63db\u3048\u308b)\n        - \u3084\u3089\u306a\u3044\u65b9\u304c\u30b9\u30b3\u30a2\u304c\u3088\u304b\u3063\u305f\u306e\u3067, \u9014\u4e2d\u304b\u3089\u63a1\u7528\u3057\u306a\u304f\u306a\u3063\u305f\n2. \u76ee\u7684\u5909\u6570\u3092\u5909\u63db\u3059\u308b\n    - \u5bfe\u6570\u5909\u63db\n    - Box-Cox \u5909\u63db\n        - Box-Cox \u5909\u63db\u306e\u65b9\u304c\u60aa\u304b\u3063\u305f\u306e\u3067\u5bfe\u6570\u5909\u63db\u3092\u63a1\u7528\u3057\u305f.\n        - \u30d1\u30e9\u30e1\u30fc\u30bf lambda \u306e fitting \u304c\u60aa\u304b\u3063\u305f\u306e\u304b\u3082\n3. CV \u3067\u30e2\u30c7\u30eb\u3092\u5b66\u7fd2 & \u8a55\u4fa1\u3059\u308b\n    - \u30e9\u30f3\u30c0\u30e0\u306b K Fold\n    - \u76ee\u7684\u5909\u6570\u3092\u96e2\u6563\u5316\u3057\u305f\u3046\u3048\u3067 Stratified K Fold (\u5404\u5206\u5272\u3054\u3068\u306b\u76ee\u7684\u5909\u6570\u306e\u5206\u5e03\u304c\u7b49\u3057\u304f\u306a\u308b\u3088\u3046\u306b\u5206\u5272\u3059\u308b)\n        - CV score \u3068 Public LB \u306e\u76f8\u95a2\u304c\u3042\u3063\u305f\u306e\u3067, \u9014\u4e2d\u304b\u3089\u6700\u5f8c\u307e\u3067\u3053\u306e\u5206\u5272\u65b9\u6cd5\u3092\u4f7f\u3063\u305f.\n    - 5 fold, 10 fold, 20 fold\n        - \u7279\u5fb4\u91cf\u4f5c\u6210\u306a\u3069\u3067\u8a66\u884c\u932f\u8aa4\u3057\u3066\u3044\u308b\u3068\u304d\u306f\u624b\u8efd\u306b 5 fold\n        - \u30c7\u30fc\u30bf\u306e\u7dcf\u6570\u304c\u5c11\u306a\u3044\u306e\u3067\u304d\u3061\u3093\u3068\u8a55\u4fa1\u3059\u308b\u3068\u304d\u306f 10 fold\n        - \u6700\u5f8c\u306e\u65b9\u306b 20 fold \u3082\u8a66\u3057\u3066 public LB \u304c\u3088\u304b\u3063\u305f\u306e\u3067\u6700\u7d42\u30b5\u30d6\u30df\u30c3\u30c8\u3067\u3082\uff11\u3064\u63a1\u7528\u3057\u305f\u304c, \u7d50\u679c\u7684\u306b\u306f private \u306e\u65b9\u304c\u60aa\u304b\u3063\u305f\u306e\u3067 shake down \u306e\u5371\u967a\u6027\u304c\u3042\u3063\u305f\u304b\u3082.\n    - Loss (LightGBM \u306e objective): l1, huber, l2\n        - huber, l2 \u306b\u3057\u305f\u3089\u3081\u3061\u3083\u304f\u3061\u3083\u30b9\u30b3\u30a2\u304c\u3042\u304c\u3063\u305f\n4. \u30e2\u30c7\u30eb\u3092\u30a2\u30f3\u30b5\u30f3\u30d6\u30eb\u3059\u308b\n    - seed averaging (\u30e2\u30c7\u30eb\u306e\u4e71\u6570\u306e\u30b7\u30fc\u30c9\u3092 N \u901a\u308a\u5909\u3048\u3066\u4f5c\u3063\u305f N \u500b\u306e\u30e2\u30c7\u30eb\u306e\u4e88\u6e2c\u5024\u306e\u5e73\u5747\u3092\u3068\u308b) \u306f\u624b\u8efd\u306b\u5b9f\u88c5\u3067\u304d\u3066\u30b9\u30b3\u30a2\u304c\u3042\u304c\u308b\u53ef\u80fd\u6027\u304c\u9ad8\u3044\u3053\u3068\u3092\u77e5\u3063\u305f\u306e\u3067\u8a66\u3057\u305f.\n    - 10 seed averaging\n    - 70 seed averaging\n        - \u6700\u5f8c\u306e\u6700\u5f8c\u306e\u60aa\u3042\u304c\u304d...\n    - \u7d50\u679c\u7684\u306b\u306f seed averaging \u3057\u3066\u3082 Public, Private \u3068\u3082\u306b\u307b\u307c\u6539\u5584\u304c\u306a\u304b\u3063\u305f.\n","8a8006a3":"# Remove outliers\n\u76ee\u7684\u5909\u6570\uff08price\uff09\u306e\u5916\u308c\u5024\u9664\u53bb\u3059\u308b\u3068\u3069\u3046\u306a\u308b\u304b\u3068\u601d\u3044, \u30b3\u30f3\u30da\u958b\u59cb\u5f53\u521d\u306b\u3084\u3063\u3066\u307f\u307e\u3057\u305f.  \nCV score \u306f\u3044\u3044\u3051\u3069 LB (Leader Board) \u306f\u60aa\u3044\u3068\u3044\u3046\u7d50\u679c\u306b... \u5916\u308c\u5024\u3092\u7121\u8996\u3057\u3066\u30e2\u30c7\u30ea\u30f3\u30b0\u3059\u308b\u3068\u6c4e\u5316\u6027\u80fd\u306f\u60aa\u5316\u3057\u305d\u3046(= test data \u306b\u3082\u8d85\u9ad8\u984d\u7269\u4ef6\u306f\u5b58\u5728\u3057\u305d\u3046)\u306a\u306e\u3067\u4e0d\u63a1\u7528.","782d7b37":"\u3084\u308a\u5207\u308c\u306a\u304b\u3063\u305f\u3053\u3068\n- \u30cf\u30a4\u30d1\u30fc\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\n- LightGBM \u4ee5\u5916\u306e\u30e2\u30c7\u30eb\u3068\u306e\u30a2\u30f3\u30b5\u30f3\u30d6\u30eb\uff08\u3044\u308f\u3086\u308b\u30b9\u30bf\u30c3\u30ad\u30f3\u30b0\uff09\n- \u6b20\u640d\u5024\u306e\u51e6\u7406\n- pseudo labeling","ee7a88bd":"## Cross Validation Strategy","560e0513":"# References\n- [\u904b\u55b6]\u3010Starter #2\u3011\u6a5f\u68b0\u5b66\u7fd2\u306e\u6d41\u308c - https:\/\/www.kaggle.com\/wakepon\/starter-2\n- Use host info - https:\/\/www.kaggle.com\/gegege\/use-host-info\n- Simple feature extraction - https:\/\/www.kaggle.com\/gegege\/simple-feature-extraction","a9cac4c6":"## host_response_rate, host_acceptance_rate","d15b2680":"## log transform","82a303dc":"# Transform 'price'","69b871df":"## Aggregate features\n\u30ab\u30c6\u30b4\u30ea\u5909\u6570\u306e\u5404\u30ab\u30c6\u30b4\u30ea\u3054\u3068\u306b\u30c7\u30fc\u30bf\u3092\u30b0\u30eb\u30fc\u30d7\u5206\u3051\u3057, \u305d\u306e\u30b0\u30eb\u30fc\u30d7\u3067\u306e\u3042\u308b\u7279\u5fb4\u91cf\u306e\u5e73\u5747\u306a\u3069\u3092, \u65b0\u305f\u306a\u7279\u5fb4\u91cf\u3068\u3057\u3066\u52a0\u3048\u308b\u3068\u3044\u3046\u3053\u3068\u304c\u3088\u304f (?) \u884c\u308f\u308c\u307e\u3059.","a3169ee6":"## host_since, first_review, last_review","0d806ecd":"# LightGBM"}}