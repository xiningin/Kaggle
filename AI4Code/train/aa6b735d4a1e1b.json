{"cell_type":{"0c22a25f":"code","820513b4":"code","d1b97b13":"code","65835d05":"code","6ce81faf":"code","6b2e0fdc":"code","3ce8a3c4":"code","3570f0c5":"code","4ad1e15c":"code","88017ce9":"code","e61f6a41":"code","2b73b736":"code","4c978bcd":"code","b76badaf":"code","ce0cb73d":"code","b48ddff0":"code","b4ce800f":"code","5498a35e":"code","abbed422":"code","a0ce12df":"code","54aba1e7":"code","57f27b7c":"code","6f510b85":"code","afe88f85":"code","1eb22979":"code","a4ac91d4":"code","37e1da23":"code","7ec41fd0":"code","e30ab797":"code","cca6ed3e":"code","be2906aa":"code","b1f31d4a":"code","c956ee70":"code","56b583fe":"code","7a554ea8":"code","6f266672":"code","c1329b7f":"code","7c8ed7d0":"code","5e7e0a25":"code","4d28b61f":"code","1dcfdc9c":"code","056c024c":"code","6396e280":"markdown","c8ec707f":"markdown","ca930b00":"markdown","81b73ed7":"markdown","05a78e4c":"markdown","16528405":"markdown","07c55371":"markdown","01afc7ff":"markdown"},"source":{"0c22a25f":"!pip install -q timm\n!pip install -qq efficientnet_pytorch","820513b4":"tez_path = '..\/input\/tez-modified-tqdm\/'","d1b97b13":"import sys\nsys.path.append(tez_path)","65835d05":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.image as immg\nimport matplotlib.ticker as ticker\nimport seaborn as sns\nfrom PIL import Image\nimport matplotlib.image as immg\nimport os,gc,random\nimport albumentations\nimport tez\nimport timm\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom efficientnet_pytorch import EfficientNet","6ce81faf":"os.mkdir('\/kaggle\/working\/train\/')","6b2e0fdc":"!unzip -qq '..\/input\/band-pass-traintest-g2net-audio-wave-data\/TrainG2NET.zip' -d '\/kaggle\/working\/train\/'","3ce8a3c4":"os.mkdir('\/kaggle\/working\/test\/')","3570f0c5":"!unzip -qq '..\/input\/band-pass-traintest-g2net-audio-wave-data\/TestG2NET.zip' -d '\/kaggle\/working\/test\/'","4ad1e15c":"import warnings\nwarnings.filterwarnings('ignore')","88017ce9":"train = pd.read_csv('..\/input\/g2net-gravitational-wave-detection\/training_labels.csv')\ntest = pd.read_csv('..\/input\/g2net-gravitational-wave-detection\/sample_submission.csv')\n\ndef get_train_file_path(image_id):\n    return \"..\/input\/g2net-gravitational-wave-detection\/train\/{}\/{}\/{}\/{}.npy\".format(\n        image_id[0], image_id[1], image_id[2], image_id)\n\ndef get_test_file_path(image_id):\n    return \"..\/input\/g2net-gravitational-wave-detection\/test\/{}\/{}\/{}\/{}.npy\".format(\n        image_id[0], image_id[1], image_id[2], image_id)","e61f6a41":"train['file_path'] = train['id'].apply(lambda x:\"\/kaggle\/working\/train\/\"+str(x)+\".png\")","2b73b736":"from sklearn.model_selection import train_test_split,StratifiedKFold","4c978bcd":"train_df = train.copy()\ntrain_df['kfold'] = -1\ny = train_df['target'].values\nkf = StratifiedKFold(n_splits=200,random_state = 2021,shuffle = True)\nfor fold ,(trn_,val_ )in enumerate(kf.split(X=train_df,y=y)):\n    train_df.loc[val_,'kfold'] = fold","b76badaf":"# train_df.to_csv('cnn1d_cqt_train_kfold.csv',index=False)","ce0cb73d":"# train_df = pd.read_csv('..\/input\/effnetb0-3ch3-g2net\/cnn1d_cqt_train_kfold.csv')","b48ddff0":"train_df[train_df.kfold==1].shape,train_df[train_df.kfold!=1].shape","b4ce800f":"train_df.head()","5498a35e":"FOLD = 1","abbed422":"df_train = train_df[train_df['kfold']!=FOLD].reset_index(drop=True)\ndf_valid = train_df[train_df['kfold']==FOLD].reset_index(drop=True)\ntrain_targets = df_train['target'].values\nvalid_targets = df_valid['target'].values","a0ce12df":"df_train.shape[0],df_valid.shape[0]","54aba1e7":"class G2NetDataset:\n    def __init__(self,paths,targets):\n        \n        self.paths = paths\n        self.targets = targets\n        \n    def __len__(self):\n        return len(self.paths)\n    \n    def __getitem__(self,item):\n        \n        targs = self.targets[item]\n        image = Image.open(self.paths[item])\n        image = np.array(image)\/255.0\n        image123 = np.array([image[:,:129],image[:,129:129*2],image[:,129*2:]])\n        image_tensor = torch.tensor(image123,dtype=torch.float)\n        \n        return {\"image\": image_tensor,\n                \"targets\": torch.tensor(targs,dtype=torch.float)}","57f27b7c":"train_dataset = G2NetDataset(df_train.file_path,train_targets)\nvalid_dataset = G2NetDataset(df_valid.file_path,valid_targets)","6f510b85":"img  = train_dataset[0]['image']\ntar = train_dataset[0]['targets']","afe88f85":"import sklearn.metrics as sklm\nimport torch.optim as optim","1eb22979":"class G2NetModel(tez.Model):\n    def __init__(self):\n        super().__init__()\n        \n        self.net = timm.create_model('resnest50d',pretrained=True)\n        #self.net = EfficientNet.from_pretrained(\"efficientnet-b4\")\n        self.dropout = nn.Dropout(0.1)\n        self.out = nn.Linear(1000,1)\n        \n        self.step_scheduler_after = \"epoch\"\n        self.step_scheduler_metric = \"valid_rocauc\"\n        \n\n    def monitor_metrics(self, outputs, targets):\n        outputs = torch.sigmoid(outputs).cpu().detach().numpy() \n        targets = targets.cpu().detach().numpy()\n        try:\n            res = sklm.roc_auc_score(targets, outputs)\n        except:\n            res = 0.5\n        return {\"rocauc\": res}\n\n    def fetch_optimizer(self):\n        opt = torch.optim.Adam(self.parameters(), lr=1e-3)\n        return opt\n\n    def fetch_scheduler(self):\n        rlr = torch.optim.lr_scheduler.ReduceLROnPlateau(\n            self.optimizer,\n            verbose=True,\n            factor=0.7,\n            mode=\"max\",\n            patience=2,\n            threshold=0.01,)\n        return rlr\n\n    def forward(self, image, targets=None):\n        \n        #batch_size, _, _, _ = image.shape\n        x = self.net(image)\n        #x = F.adaptive_avg_pool2d(x, 1).reshape(batch_size, -1)\n        outputs = self.out(self.dropout(x))\n        \n        if targets is not None:\n            loss = nn.BCEWithLogitsLoss()(outputs, targets.view(-1, 1))\n            metrics = self.monitor_metrics(outputs, targets)\n            return outputs, loss, metrics\n        return outputs, None, {}","a4ac91d4":"model = G2NetModel()","37e1da23":"from tez.callbacks import EarlyStopping\nes = EarlyStopping(\n    monitor=\"valid_rocauc\", model_path=\"model.bin\", patience=5, mode=\"max\"\n)","7ec41fd0":"print('Starting Model Training:')","e30ab797":"model.fit(\n        train_dataset,\n        valid_dataset=valid_dataset,\n        train_bs = 128,\n        valid_bs = 128,\n        device = \"cuda\",\n        epochs = 8,\n        callbacks = [es],\n        fp16 = True)","cca6ed3e":"class G2NetModel(tez.Model):\n    def __init__(self):\n        super().__init__()\n        self.net = timm.create_model('resnest50d',pretrained=False)\n        self.dropout = nn.Dropout(0.1)\n        self.out = nn.Linear(1000,1)\n    def forward(self, image):\n        x = self.net(image)\n        outputs = self.out(self.dropout(x))\n        return outputs, None, {}","be2906aa":"model = G2NetModel()","b1f31d4a":"model.load(os.path.join('\/kaggle\/working', \"model.bin\"))","c956ee70":"sub = pd.read_csv('..\/input\/g2net-gravitational-wave-detection\/sample_submission.csv')","56b583fe":"sub.head()","7a554ea8":"ts_filepath = sub['id'].apply(lambda x:'\/kaggle\/working\/test\/'+str(x)+'.png').values","6f266672":"class TestDataset:\n    def __init__(self,paths):\n        \n        self.paths = paths\n        self.targets = None\n        \n    def __len__(self):\n        return len(self.paths)\n    \n    def __getitem__(self,item):\n        \n        image = Image.open(self.paths[item])\n        image = np.array(image)\/255.0\n        image123 = np.array([image[:,:129],image[:,129:129*2],image[:,129*2:]])\n        image_tensor = torch.tensor(image123,dtype=torch.float)\n        \n        return {\"image\": image_tensor}","c1329b7f":"test_dataset = TestDataset(ts_filepath)","7c8ed7d0":"preds = model.predict(\n    test_dataset, batch_size=64, n_jobs=2, device=\"cuda\"\n)\ntemp_preds = None\nfor p in preds:\n    if temp_preds is None:\n        temp_preds = p\n    else:\n        temp_preds = np.vstack((temp_preds, p))","5e7e0a25":"sub['target'] = torch.from_numpy(temp_preds).sigmoid().flatten().numpy()","4d28b61f":"sub.to_csv('submission_3ch.csv',index=False)","1dcfdc9c":"!rm -r '\/kaggle\/working\/test\/'","056c024c":"!rm -r '\/kaggle\/working\/train\/'","6396e280":"## Test Dataset & Load Best Model","c8ec707f":"## Stratified Kfold","ca930b00":"## Model G2Net ResNest50d","81b73ed7":"### Special thanks to Grandmaster Abhishek thakur, for super useful pytorch trainer","05a78e4c":"## Prediction on Test Set","16528405":"## Start Training","07c55371":"## Loading data","01afc7ff":"## Dataset"}}