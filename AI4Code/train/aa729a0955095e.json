{"cell_type":{"9e95ed3e":"code","7c38793f":"code","a8933311":"code","3d51bd47":"code","42a5bed0":"code","5cb8f305":"code","ec786ad2":"code","9377ab89":"code","04442692":"code","09ae9570":"code","4c97e1bf":"code","6b214879":"code","846a0ba2":"code","ace82131":"code","382e7287":"code","b5e6e4b1":"markdown","b26ec4ed":"markdown","76da74db":"markdown","55461961":"markdown","1f43dd4a":"markdown","3feef780":"markdown","b1c3d1ea":"markdown"},"source":{"9e95ed3e":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session\npd.__version__","7c38793f":"df = pd.read_csv(\"\/kaggle\/input\/gufhtugu-publications-dataset-challenge\/GP Orders - 5.csv\", encoding = 'utf-8')\ndf.info()","a8933311":"df = df[df['Book Name'].notna()]\ndf['Order Date & Time'] = pd.to_datetime(df['Order Date & Time'])\ndf.fillna('-',inplace=True)\ndf['Order Status'].value_counts()","3d51bd47":"a = lambda x: x.strip('')\ndf['Book Name'] = df['Book Name'].map(a)\ndf['Book Name'].value_counts()","42a5bed0":"print(\"\\t\\t\\t*** INSIGHTS FOR BLOCKCHAIN ***\\n\\n\\n\")\nprint(df.iloc[0]['Book Name'],\"\\nTotal items: \",df.iloc[0]['Total items'])\nprint(\"-------x-------x----------x--------x\\n\\n\")\nprint(df.iloc[28]['Book Name'],\"\\nTotal items: \",df.iloc[28]['Total items'])\nprint(\"-------x-------x----------x--------x\\n\\n\")\nprint(df.iloc[6]['Book Name'],\"\\nTotal items: \",df.iloc[6]['Total items'])\nprint(\"-------x-------x----------x--------x\\n\\n\")\nprint(df.iloc[11]['Book Name'],\"\\nTotal items: \",df.iloc[11]['Total items'])\nprint(\"-------x-------x----------x--------x--------------------------------------\\n\\n\")\nprint(\"\\t\\t\\t*** INSIGHTS FOR (C++)\/C ***\\n\\n\\n\")\nprint(df.iloc[9]['Book Name'],\"\\nTotal items: \",df.iloc[9]['Total items'])\nprint(\"-------x-------x----------x--------x\\n\\n\")\nprint(df.iloc[50]['Book Name'],\"\\nTotal items: \",df.iloc[50]['Total items'])\nprint(\"-------x-------x----------x--------x\\n\\n\")\nprint(df.iloc[1012]['Book Name'],\"\\nTotal items: \",df.iloc[1012]['Total items'])\nprint(\"-------x-------x----------x--------x\\n\\n\")\nprint(df.iloc[699]['Book Name'],\"\\nTotal items: \",df.iloc[699]['Total items'])\nprint(\"-------x-------x----------x--------x\\n\\n\")\nprint(df.iloc[711]['Book Name'],\"\\nTotal items: \",df.iloc[711]['Total items'])\nprint(\"-------x-------x----------x--------x\\n\\n\")","5cb8f305":"df['Book Name'] = df['Book Name'].str.replace(r\"\\(C\\++\\)\\s\\++\u0633\u06cc\/\u0633\u06cc\" , '(C++) ++\u0633\u06cc-\u0633\u06cc', regex=True)\n\ndef func(x):\n    ans = x.split('\/')\n    return ans\n    \n\ndf[\"Book Name\"] = df[\"Book Name\"].map(func)\ndf.head(5)","ec786ad2":"#Repeating String\nind = df.index\n\nfor ind in ind:\n    if (len(df['Book Name'][ind]) < df['Total items'][ind]):\n        count = df['Total items'][ind] - len(df['Book Name'][ind])\n#         print(\"Counter To Repeat String: \",count)\n#         print(\"-----BEFORE----\\n\\n\")\n#         print(\"\\nIndex: \", ind ,\"\\nBooks: \", df['Book Name'][ind] , \"\\nTotal Items: \", df['Total items'][ind] ,\\\n#         end=\"\\n-----------------------X---------------------X-----------------\\n\\n\")\n        for i in range(count):\n            df['Book Name'][ind].append(df['Book Name'][ind][0])\n#         print(\"-----After----\\n\\n\")\n#         print(\"\\nIndex: \", ind ,\"\\nBooks: \", df['Book Name'][ind] , \"\\nTotal Items: \", df['Total items'][ind] ,\\\n#         end=\"\\n-----------------------X---------------------X-----------------\\n\\n\")","9377ab89":"df.head()","04442692":"#Cross Check\n\nind = df.index\nfor ind in ind:\n    if (len(df['Book Name'][ind]) < df['Total items'][ind]):\n        print(df['Book Name'][ind])\nelse:\n    print(\"cleaned\")","09ae9570":"# Splitting in multiple columns \nnew_df = df.explode(\"Book Name\", ignore_index= True)\nnew_df.shape","4c97e1bf":"df['Total items'].sum()","6b214879":"new_df.head(50)","846a0ba2":"print(\"Unique Status: \",new_df['Order Status'].unique() ,\\\n      \"\\nNo. of Unique Books :\", len(new_df['Book Name'].unique()) ,\\\n      \"\\nNo. of Unique Cities :\", len(new_df['City'].unique()))\n","ace82131":"delievered = new_df[new_df['Order Status'] == 'Completed']\ndelievered['Order Status'].unique()","382e7287":"best_selling_book = delievered['Book Name'].value_counts().to_frame()\nbest_selling_book.iloc[:10]","b5e6e4b1":"# TASK 1: \n## **What is the best-selling book?**","b26ec4ed":"**The best selling book can be extracted from where the Order Status is Completed**","76da74db":"## Answer:\n### Top 3 Selling Books, Respectively:\n\n1. \u0627\u0646\u0679\u0631\u0646\u06cc\u0679 \u0633\u06d2 \u067e\u06cc\u0633\u06c1 \u06a9\u0645\u0627\u0626\u06cc\u06ba\n\n2. Python Programming\t\n\n3. Artificial Intelligence","55461961":"As Column **Book Name** has 2 values missing so we'll drop these rows. Nan in columns **City (Billing)** and **Payment Method** will not effect our analysis much we'll leave it and replace this with '-' ","1f43dd4a":"# Points:\n\n\n1) From above we have seen that some of the quanities of books doesn't match to its item size in column **Total items**.\n\n2) So we have to add or repeat more books where needed. E.g at **Index 0** , **Index 6** and so on.\n\n3) Each cell contain multiple books so we have to split each cell in multiple rows.\n### Issue:\n4) We'll split it with the help of **\/ (Fwd slash)** . But if we do this, it will interpret **(C++) ++\u0633\u06cc\/\u0633\u06cc** as 2 different books instead of 1.\n### Solution:\n5) We are going to modify the string from **(C++) ++\u0633\u06cc\/\u0633\u06cc** to **(C++) ++\u0633\u06cc-\u0633\u06cc**. Then we can split into rows easily. ","3feef780":"# EDA -  with Data Updation (GP Orders - 5)","b1c3d1ea":"# POINT\n- No. of rows in **new_df or Book Name** should be equal to the sum of values in column **Total items**"}}