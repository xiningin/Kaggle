{"cell_type":{"0017aa46":"code","6d2bf785":"code","aa7d4f9d":"code","548337a7":"code","6465cd1d":"code","b9a1ac4b":"code","68264537":"code","84ce3146":"code","7c34a6de":"code","a59eee1d":"code","6e703082":"code","65560adc":"code","45374e7f":"code","1a1a988d":"code","32375ab0":"code","86f7c6eb":"code","cbc4319c":"code","fa610e43":"code","4912a8e5":"code","3b6e9e00":"code","ad3f4280":"code","827f8c7f":"code","86b8aeb1":"code","ca2c57e0":"code","08590831":"code","a76ececb":"code","15fb40b8":"code","2ccf1a27":"code","9c920e3a":"code","b4ab5ebf":"code","3c9a810e":"code","21a2219c":"code","17c3167d":"code","e034c0cd":"code","09e17fad":"code","8a1430aa":"code","e8188900":"code","03664da4":"code","c2e96e2c":"code","a6059ee0":"code","88b6e9a1":"code","e0082665":"code","844c140b":"code","b9246700":"code","d5c1361d":"code","7a0795c5":"code","fda09b0c":"code","8fbb5cb4":"code","d8ea0be7":"code","41456e55":"code","8a113456":"code","0bc2a214":"code","8a5270af":"code","069ad369":"code","c3a81cc7":"code","1369e678":"code","75961671":"code","27ece3f4":"code","1a77ffbc":"code","6d2170bf":"code","dcdfaaee":"code","154e4471":"code","bd6e78e8":"code","69ea6d5e":"code","e620abb4":"code","cc5d4755":"code","f98feb1c":"code","a00643fb":"code","cbf69713":"code","9f1e15e8":"code","da7920d9":"code","153731c2":"code","93648fb4":"code","92dbeb05":"code","7349a1ce":"code","cc822c84":"code","5602660b":"code","e671f1fe":"code","03f846c5":"code","d193f867":"code","1805503a":"code","dd6a7f23":"code","9e389f2b":"code","b465dcec":"code","6f08386e":"code","f5771437":"code","7719b1f8":"code","0cd93e74":"code","604a56b3":"code","07954fd0":"code","200962b9":"code","a4102d8e":"code","2b7ff287":"code","98271bf0":"code","b6059a42":"code","82e3d953":"code","8af171be":"code","1760dbd5":"code","58eebf9f":"code","a6f6fcdb":"code","e70ae8fd":"code","40ff2e77":"code","c4ce9143":"code","7c2c6aa5":"code","a3c45d35":"code","4c5f95f6":"code","e6a4e022":"code","c465ffdf":"code","659dd140":"code","5bd85174":"code","41c6f2d7":"code","918a54aa":"code","36e6194c":"code","ca76ff72":"code","225005b6":"code","dd948b9a":"code","7dc3abf4":"code","ebfc4696":"code","95c72a50":"code","0a9e277b":"markdown","4317ba04":"markdown","96373c59":"markdown","3eaeadd3":"markdown","6e14b6cb":"markdown","ebe73dc6":"markdown","a0a80eb2":"markdown","19749ea6":"markdown","43510bab":"markdown","72b20053":"markdown","9dfc5d41":"markdown","aa13fe13":"markdown","af80e030":"markdown","2e2773ee":"markdown","7da59d76":"markdown","b9cf80be":"markdown"},"source":{"0017aa46":"from pylab import rcParams\nrcParams['figure.figsize'] = 10, 20","6d2bf785":"import imageio\nimport matplotlib.pyplot as plt\nim = imageio.imread(\"..\/input\/tcia-chest-ct-sample\/chest-220.dcm\")","aa7d4f9d":"print(\"Type of image {}\".format(type(im)))\nprint(\"shape of image {}\".format(type(im.shape)))","548337a7":"plt.imshow(im)\nplt.axis(\"off\")","6465cd1d":"print(im.meta.keys())\nprint(\"----------------------------------\")\nprint(im.meta)","b9a1ac4b":"print(\"Type of the image {}\".format(type(im)))\nprint(\"Shape of the image {}\".format(im.shape))\nplt.imshow(im,cmap='gray')\nplt.axis(\"off\")","68264537":"plt.imshow(im,cmap = \"gray\",vmin=-200,vmax=200)\nplt.show()","84ce3146":"### create a 3d image \nimport imageio\nimport numpy as np\n\n# Read in each 2D image\nim1 = imageio.imread('..\/input\/tcia-chest-ct-sample\/chest-220.dcm')\nim2 = imageio.imread('..\/input\/tcia-chest-ct-sample\/chest-221.dcm')\nim3 = imageio.imread('..\/input\/tcia-chest-ct-sample\/chest-222.dcm')\n\n# Stack images into a volume\nvol = np.stack([im1,im2,im3])\nprint('Volume dimensions:', vol.shape)","7c34a6de":"## we can directly load a image folder\nimport imageio\nvol = imageio.volread(\"..\/input\/tcia-chest-ct-sample\/\")\nprint(\"Avilable metadata: {} \".format(vol.meta.keys()))\nprint(\"Shape of the image Array: {} \".format(vol.shape))","a59eee1d":"print(vol.shape)","6e703082":"#image shape: number of element on each axis\nn0,n1,n2 = vol.shape \n#sampling rate : physical space covered by each sample\nd0,d1,d2 = vol.meta['sampling'] \n# field of view : physical space covered along each axis\nprint(\"Physical space covered by each axis\")\nprint(n0*d0,n1*d1,n2*d2)","65560adc":"## pltting image with subplot\nimport imageio\ncol = imageio.volread(\"..\/input\/tcia-chest-ct-sample\/\")\nfig,axis = plt.subplots(nrows=1,ncols=3)\naxis[0].imshow(vol[0],cmap=\"gray\")\naxis[1].imshow(vol[1],cmap=\"gray\")\naxis[2].imshow(vol[2],cmap=\"gray\")","45374e7f":"### plotting in row\nimport matplotlib.pyplot as plt\nfig,axis = plt.subplots(nrows=2,ncols=1)\nim1 = imageio.imread('..\/input\/tcia-chest-ct-sample\/chest-220.dcm')\nim2 = imageio.imread('..\/input\/tcia-chest-ct-sample\/chest-221.dcm')\naxis[0].imshow(im1,cmap=\"gray\")\naxis[1].imshow(im2,cmap=\"gray\")\nplt.show()","1a1a988d":"## how tosee the image from different dimension\n## first lock one dimension and then \n## take the rest of the data and plot it\nfig,axis = plt.subplots(nrows=1,ncols=4)\nfor dimension in range(4):\n    im = vol[dimension,:,:]\n    axis[dimension].imshow(im,cmap=\"gray\")\n    axis[dimension].axis(\"off\")\nplt.show()","32375ab0":"## calculating aspect ratio\nd0,d1,d2 = vol.meta['sampling']\nasp1 = d0\/d1\nasp2 = d0\/d2\n\n## plot the image with the aspect ratio\nfig,axis = plt.subplots(nrows=1,ncols=2)\naxis[0].imshow(im1,cmap=\"gray\",aspect = asp1)\naxis[1].imshow(im2,cmap=\"gray\",aspect = asp1)","86f7c6eb":"import imageio\nim = imageio.imread(\"..\/input\/hand.png\")","cbc4319c":"print(im.dtype)\nprint(im.size)","fa610e43":"## chaning dtpye and size\nim_int64 = im.astype(np.uint64)\nprint(im_int64.size)","4912a8e5":"plt.imshow(im)","3b6e9e00":"## make a histogram to plot the pixel and the intensity of the value throughout image\nimport scipy.ndimage as ndi\nhist = ndi.histogram(im,min=0,max=255,bins=256)\nplt.plot(hist)","ad3f4280":"plt.hist(hist)","827f8c7f":"## thats show that this is a skewed image\n## because most of the background is blak and some of the portion (the hand portion)\n## is is image take hisger pixel thats why it is a skewed image\n## we can redistribute this with the \n## Equalization\n## distribution often skewed to the background image in medical image\n## but we can redistribute this  intensity to optimize the full intensity length\n## you can redistribute this thing with CDF (cumulative distributuion function)\n## VDF can show that then range that your image is build in the total pixel range\n## so lets redistribute this image","86b8aeb1":"import scipy.ndimage as ndi\nhist = ndi.histogram(im,min=0,max=255,bins=256)\n\n## calculate the cdf\n## find the cumulative sum and then devie witht eh histogram sum\n## to make a cumulative histogram\ncdf = hist.cumsum()\/hist.sum()\ncdf.shape","ca2c57e0":"im_equilized = cdf[im]*255","08590831":"## lets plot the both image\nfig,axes = plt.subplots(nrows=2,ncols=1)\naxes[0].imshow(im)\naxes[1].imshow(im_equilized)","a76ececb":"## this is good but you can see that it does the redistribute this image\n## but it also brighten up the background of the image","15fb40b8":"# Load the hand radiograph\nim = imageio.imread(\"..\/input\/hand.png\")\nprint('Data type:', im.dtype)\nprint('Min. value:', im.min())\nprint('Max value:', im.max())\n\n# Plot the grayscale image\nplt.imshow(im,cmap=\"gray\",vmin=0,vmax=255)\nplt.colorbar()","2ccf1a27":"import scipy.ndimage as ndi\nhist = ndi.histogram(im,min=0,max=255,bins=256)\n\n## calculate the cdf\n## find the cumulative sum and then devie witht eh histogram sum\n## to make a cumulative histogram\ncdf = hist.cumsum()\/hist.sum()\nfig, axes = plt.subplots(2, 1, sharex=True)\naxes[0].plot(hist, label='Histogram')\naxes[1].plot(cdf, label='CDF')","9c920e3a":"## masking image\n## if you see the distribution you can see that\n## only a part of the pixel have value high\n## that means this image is themain feature of theimage \n## so lets extract the image","b4ab5ebf":"plt.plot(hist)","3c9a810e":"## so we can see that after 35 (apporx ) the curve went down\n## lets filter it down\nmask1 = im > 35","21a2219c":"plt.imshow(mask1)","17c3167d":"## so you can see we can extract theonlt the hand part\n## but the main challange is can we show the bones too ??????\n## because bones are the hoghest intensity tissue in an xray","e034c0cd":"## lets make a narder one \nmask2 = im>70","09e17fad":"plt.imshow(mask2)","8a1430aa":"## can you plot both the bone and the tissue","e8188900":"# masking that are in the mask1 but ont in mask2\nmask3 = mask1 & ~mask2","03664da4":"plt.imshow(mask3)","c2e96e2c":"## now you can detect the skin and the bone too","a6059ee0":"## same work you can do it with numpy too\nimport numpy as np\nim_bone_np = np.where(im>70,im,0)","88b6e9a1":"plt.imshow(im_bone_np,cmap=\"gray\")\nplt.show()","e0082665":"im_bone_np = ndi.binary_dilation(im_bone_np,iterations=5)\nplt.imshow(im_bone_np,cmap=\"gray\")\nplt.show()","844c140b":"## now you can do the opposite thing that ts pixel erosion\nim_bone_np_down = ndi.binary_erosion(im_bone_np,iterations=5)\nplt.imshow(im_bone_np_down,cmap=\"gray\")\nplt.show()","b9246700":"im = imageio.imread(\"..\/input\/hand.png\")\n# Create skin and bone masks\nmask_bone = im>=45\nmask_skin = (im >=45) & (im<=145)\n\n# Plot the skin (0) and bone (1) masks\nfig, axes = plt.subplots(1,2)\naxes[0].imshow(mask_bone,cmap=\"gray\")\naxes[1].imshow(mask_skin,cmap=\"gray\")","d5c1361d":"# Import SciPy's \"ndimage\" module\nimport scipy.ndimage as ndi\n#im_bone_np = np.where(im>70,im,0)\n# Screen out non-bone pixels from \"im\"\nmask_bone = im>=145\nim_bone = np.where(im>-145, im, 0)\n\n# Get the histogram of bone intensities\nhist = ndi.histogram(im_bone,min=1,max=255,bins=255)\n\n# Plot masked image and histogram\nfig, axes = plt.subplots(2,1)\naxes[0].imshow(im_bone)\naxes[1].plot(hist)","7a0795c5":"# Create and tune bone mask\n# mask_bone = im >= 145\n# mask_dilate = ndi.binary_dilation(mask_bone, iterations=1)\n# mask_closed = ndi.binary_closing(mask_bone, iterations=1)\n\n# Plot masked images\n# fig, axes = plt.subplots(1,3)\n# axes[0].imshow(mask_bone)\n# axes[1].imshow(mask_dilate)\n# axes[2].imshow(mask_closed)","fda09b0c":"import imageio\nimport scipy.ndimage as ndi\nim = imageio.imread(\"..\/input\/hand.png\")\n## adding weight\n##  we emphasize the middle one\nweight = [[.11,.11,.11],\n          [.11,.12,.11],\n          [.11,.11,.11]]\nim_fit = ndi.convolve(im,weight)","8fbb5cb4":"## plot the original and the convolution filter\nfig,axes = plt.subplots(2,1)\naxes[0].imshow(im,cmap=\"gray\")\naxes[1].imshow(im_fit,cmap=\"gray\")","d8ea0be7":"### apply median filter\n# apply median filter to the  image\n## this is the uniform filter\n# Set filter weights\nweights = [[0.11, 0.11,.11],\n           [0.11, .11, 0.11], \n            [0.11, .11, 0.11]]\nim_filt = ndi.convolve(im,weights)\nplt.imshow(im_filt)","41456e55":"## smooting image with gaussian filter\n## it will smooth the image with reducig the surge of pixel value\n# Smooth \"im\" with Gaussian filters\nim_s1 = ndi.gaussian_filter(im, sigma=1)\nim_s3 = ndi.gaussian_filter(im, sigma=3)","8a113456":"fig, axes = plt.subplots(1,3)\naxes[0].imshow( im)\naxes[1].imshow(im_s1)\naxes[2].imshow(im_s3)","0bc2a214":"## weight increase at the top and bottom\nim = imageio.imread('..\/input\/hand.png')\nweights = [[+1,+1,+1],\n          [0 ,0 ,0 ],\n          [-1,-1,-1]]\nedges = ndi.convolve(im,weights)\nplt.imshow(edges)","8a5270af":"## applying default sovel filter to findn the edge\nim = imageio.imread('..\/input\/hand.png')\nedges = ndi.sobel(im,axis=1)\nplt.imshow(edges,cmap=\"seismic\")","069ad369":"# Set weights to detect vertical edges\nweights = [[1,0,-1],\n          [0 ,0 ,0 ],\n          [-1,-1,-1]]\n\n# Convolve \"im\" with filter weights\nedges = ndi.convolve(im,weights)\nplt.imshow(edges,cmap=\"seismic\",vmin=-150,vmax=150)\nplt.colorbar()","c3a81cc7":"## image of the heart pumping blod we need to extract the left ventricle image\n## the one in the circled\nim = imageio.imread(\"..\/input\/sunnybrook-cardiac-mr\/SCD2001_006\/SCD2001_MR_117.dcm\")\nplt.imshow(im)","1369e678":"## apply gausian filter to smooth the image\nimport scipy.ndimage as ndi\nfilt = ndi.gaussian_filter(im,sigma=2)\n## not apply the filter\nmask = filt >100\n","75961671":"## lets see where we going\nplt.imshow(mask,cmap=\"rainbow\")","27ece3f4":"##extract the label and the number of  the label\nlabels,nlabels = ndi.label(mask)","1a77ffbc":"print(nlabels)","6d2170bf":"## you can now select individual objects\nplt.imshow(np.where(labels==3,im,0))","dcdfaaee":"## ok we got the circullar image\n## make  abounding box\n## extract objects from the larger image\nboxes = ndi.find_objects(labels)","154e4471":"###plotting the box\nplt.imshow(im[boxes[2]])\n","bd6e78e8":"# Label the image \"mask\"\nlabels, nlabels = ndi.label(mask)\n\n# Select left ventricle pixels\nlv_val = labels[128, 128]\nlv_mask = np.where(labels==lv_val,1,np.nan)\n\n# Overlay selected label\nplt.imshow(lv_mask, cmap='rainbow')\nplt.show()","69ea6d5e":"# Create left ventricle mask\nlabels, nlabels = ndi.label(mask)\nlv_val = labels[128,128]\n\nlv_mask = np.where(labels==lv_val, 1, 0)","e620abb4":"plt.imshow(lv_mask)","cc5d4755":"## getting a mean intensity of the entire vol 3d image\nimport imageio\nimport scipy.ndimage as ndi\nvol = imageio.volread('..\/input\/sunnybrook-cardiac-mr\/SCD2001_006\/')","f98feb1c":"## find the mean of all the pixel\nprint(ndi.mean(vol))","a00643fb":"## if you provde a mask this mean will be avilabe for ony the non zero pixel\nprint(ndi.mean(vol,labels))","cbf69713":"## you can find for a specfic one\nprint(ndi.mean(vol,labels,index=1))\nprint(ndi.mean(vol,labels,index=[1,2]))","9f1e15e8":"## you can add this directly to a histogram plot\nhist = ndi.histogram(vol,min=0,max=255,bins=256,labels=labels,index=[1,2])","da7920d9":"len(hist)","153731c2":"plt.hist(hist)","93648fb4":"\n## finding varience of all the picture \n## vs some labels picture\n# Variance for all pixels\nvar_all = ndi.variance(vol, labels=None, index=None)\nprint('All pixels:', var_all)\n\n# Variance for labeled pixels\nvar_labels = ndi.variance(vol, labels, index=None)\nprint('Labeled pixels:', var_labels)\n\n# Variance for each object\nvar_objects = ndi.variance(vol, labels, index=[1,2])\nprint('Left ventricle:', var_objects[0])","92dbeb05":"# Create histograms for selected pixels\nhist1 = ndi.histogram(vol, min=0, max=255, bins=256)\nhist2 = ndi.histogram(vol, 0, 255, 256, labels=labels)\nhist3 = ndi.histogram(vol, 0, 255, 256, labels=labels, index=1)","7349a1ce":"fig,axis = plt.subplots(nrows=1,ncols=3)\naxis[0].hist(hist1)\naxis[1].hist(hist2)\naxis[2].hist(hist3)","cc822c84":"## calculate the volume by multipleplying each voxel\n## you can find it in the samppling in dicom images\nd0,d1,d2 = vol.meta['sampling']\ndvoxels = d0*d1*d2","5602660b":"## we want to count the number of vosxels in left ventricle\n## this one is tricky\n## first you assign the numebr 1 in the label and index 1 and then sum it that\n## make the portion of the left ventricle\n## then you mulltiply with the dvoxels thats how you find the volume of the portion\n## volume of the portion = portion*total_volume\n## nvoxels = ndi.sum(1,label,index=1)\n## volume = nvoxels*dvoxels","e671f1fe":"#1)\nlabels,nlabels = ndi.label(mask)\nlabels_of_the_left_vn=np.where(labels==3,im,0)\nplt.imshow(labels_of_the_left_vn)","03f846c5":"# 2)\n## calculate the volum in mm^3 in a  specfic time point\nd0,d1,d2 = vol.meta['sampling']\ndvoxels = d0*d1*d2\n## instantiate an empty list\nts = np.zeros(20)\n\n## loop through the volume time series\nfor t in range(20):\n    nvoxels = ndi.sum(1,labels_of_the_left_vn[t],index=3)\n    ts[t] = nvoxels*dvoxels\n","d193f867":"#3)\ntmax = np.argmax(ts)\ntmin = np.argmin(ts)\n","1805503a":"#4)# Calculate ejection fraction\nej_vol = ts.max() - ts.min()\nej_frac = ej_vol \/ ts.max()\nprint('Est. ejection volume (mm^3):', ej_vol)\nprint('Est. ejection fraction:', ej_frac)","dd6a7f23":"import imageio\nimport scipy.ndimage as ndi\nim = imageio.imread('..\/input\/hand.png')\nplt.imshow(im)","9e389f2b":"## find the center of mass to rotate\ncom = ndi.center_of_mass(im)","b465dcec":"print(com)","6f08386e":"## we set the target point\ntarget = 128\n## thenfor row and column we calculate the difference\nd0 = target - com[0]\nd2 = target - com[1]","f5771437":"## shift the image \nxfm = ndi.shift(im,shift=[d0,d1])","7719b1f8":"plt.imshow(xfm)","0cd93e74":"## rotate the imgae\nplt.imshow(ndi.rotate(im,angle=25,axes=(0,1)))","604a56b3":"## rotate the imgae\nplt.imshow(ndi.rotate(im,angle=25,axes=(0,1),reshape=False))","07954fd0":"## resclaling image\nmat = [[.8,0,-20],[0,.8,-10],[0,0,1]]\nxfm = ndi.affine_transform(im,mat)\nplt.imshow(xfm)","200962b9":"## resampling (slicing the imge ,changes the shape of the array )\n## downsampling\n## upsampling","a4102d8e":"down_im = ndi.zoom(im,zoom=.5)","2b7ff287":"plt.imshow(down_im)","98271bf0":"## the image is downsamopled and the quality is reduced \n## you can see the image scattered a little bit\nprint(\"shpe of image before downsampling {}\".format(im.shape))\nprint(\"shpe of image after downsampling {}\".format(down_im.shape))","b6059a42":"## upsampling is not as same as downsampling\n## you are not adding any feature \n## it just resample toa  larger grid\n## some times it requires estimating some portionof the image that are not actually there\n## like we do in image editing\n## its called interpolation","82e3d953":"# Center and level image\nxfm = ndi.shift(im, shift=(-20, -20))\nxfm = ndi.rotate(xfm, angle=-35, reshape=False)\n\n# Resample image\nim_dn = ndi.zoom(xfm, zoom=0.25)\nim_up = ndi.zoom(xfm, zoom=4.00)\n\n# Plot the images\nfig, axes = plt.subplots(2, 1)\naxes[0].imshow(im_dn)\naxes[1].imshow(im_up)\n","8af171be":"# Upsample \"im\" by a factor of 4\nup0 = ndi.zoom(im, zoom=4, order=0)\nup5 = ndi.zoom(im, zoom=4, order=5)\n\n# Print original and new shape\nprint('Original shape:', im.shape)\nprint('Upsampled shape:', up0.shape)\n\n# Plot close-ups of the new images\nfig, axes = plt.subplots(1, 2)\naxes[0].imshow(up0[128:256, 128:256])\naxes[1].imshow(up5[128:256, 128:256])","1760dbd5":"## we import two image\nim1 = imageio.imread('..\/input\/tcia-chest-ct-sample\/chest-220.dcm')\nim3 = imageio.imread('..\/input\/tcia-chest-ct-sample\/chest-222.dcm')","58eebf9f":"##find the difference\nerr = im1-im3","a6f6fcdb":"fig,axis = plt.subplots(nrows=1,ncols=3)\naxis[0].imshow(err,vmin=-200,vmax=200)\naxis[1].imshow(im1)\naxis[2].imshow(im2)","e70ae8fd":"## the difference are highlighted","40ff2e77":"## if you want absolute image difference then add np.abs\n# Calculate absolute image difference\nabs_err = np.abs(im1 - im3)\n\n# Plot the difference\nplt.imshow(abs_err, cmap='seismic', vmin=-200, vmax=200)","c4ce9143":"## if you want to find MAE (mean absolute error)\n# Calculate mean absolute error\nmean_abs_err = np.mean(np.abs(im1 - im3))\nprint('MAE:', mean_abs_err)","7c2c6aa5":"import pandas as pd\ndf = pd.read_csv('..\/input\/oasis_all_volumes.csv')","a3c45d35":"df.head()","4c5f95f6":"# null hypothisis : men and women brain volume are equal\n# we apply a t-test","e6a4e022":"male_brain_vol=df[df.sex==\"M\"][['brain_vol']]\nfemale_brain_vol=df[df.sex==\"F\"][['brain_vol']]","c465ffdf":"from scipy.stats import ttest_ind\nresult = ttest_ind(male_brain_vol,female_brain_vol)","659dd140":"print(result)","5bd85174":"## the large statistics and low p value means there are significant difference between gender brain size","41c6f2d7":"## but the brain and the skull size are related and the skull size is related with the body\ndf[['brain_vol','skull_vol']].corr()","918a54aa":"df[['brain_vol','skull_vol']].corr()","36e6194c":"## so lets normalize the brain size with skull size thus we are comparing with the body size because\n## skull size is related with the body sizee","ca76ff72":"df['brain_norm'] = df.brain_vol\/df.skull_vol\nmale_brain_vol=df[df.sex==\"M\"][['brain_norm']]\nfemale_brain_vol=df[df.sex==\"F\"][['brain_norm']]","225005b6":"from scipy.stats import ttest_ind\nresult = ttest_ind(male_brain_vol,female_brain_vol)","dd948b9a":"print(result)","7dc3abf4":"## now its telling different it was never dependent on the male or female\n## its dependedn on the body size that means its related with other value too","ebfc4696":"## test the alzeimar with the brain vol\n# Import independent two-sample t-test\nfrom scipy.stats import ttest_ind\n\n# Select data from \"alzheimers\" and \"typical\" groups\nbrain_alz = df.loc[df.alzheimers == True, 'brain_vol']\nbrain_typ = df.loc[df.alzheimers == False, 'brain_vol']\n\n# Perform t-test of \"alz\" > \"typ\"\nresults = ttest_ind(brain_alz, brain_typ)\nprint('t = ', results.statistic)\nprint('p = ', results.pvalue)","95c72a50":"# Import independent two-sample t-test\nfrom scipy.stats import ttest_ind\n\n# Select data from \"alzheimers\" and \"typical\" groups\nbrain_alz = df.loc[df.alzheimers == True, 'brain_vol']\nbrain_typ = df.loc[df.alzheimers == False, 'brain_vol']\n\n# Perform t-test of \"alz\" > \"typ\"\nresults = ttest_ind(brain_alz, brain_typ)\nprint('t = ', results.statistic)\nprint('p = ', results.pvalue)\n\n# Show boxplot of brain_vol differences\ndf.boxplot(column='brain_vol', by='alzheimers')\nplt.show()","0a9e277b":"### dialation is adding pixel to  a image\n### this will be done when the image become fuzzy after masking","4317ba04":"* Hostogram containing multiple tissue types will have severel peaks\n* if your segmentation is look like a normal distribution this may be a good job because all of the other place is filled with blood","96373c59":"# **MASK** \nusing mask you can select the image that you only needed for the processing \n ","3eaeadd3":"## **Edge Detection**\n\n*   **sobel filter**\n*   **sismic colormap**","6e14b6cb":"Process\n* first segment the left ventricle\n* calculate the volume for a specfic time point sequentially that hold both the expand and squize part using a  for loop\n* find the min and max \n* plug them in the formula\n* remember data is 4d the first one is the time\n","ebe73dc6":"intensity value\nyou may need to change the intensity\nof the image or part of the image \nto understand thhis you need to understand the intensity distribution\nand two thing \n\n\n*   **pixel** pixel is for 2D element\n*   **voxels** voxel is dor the 3D image\n\nand you need to understand two property intensity and location\nsuppose you are working with the xray of a bode(dense tissue) your data type that is used for image can be a very impotant affet in the memory allocation of the image","a0a80eb2":"## upsampling is not as same as downsampling\n## you are not adding any feature \n## it just resample toa  larger grid\n## some times it requires estimating some portionof the image that are not actually there\n## like we do in image editing\n## its called interpolation\n# Interpolation (this is where the machine learning comes because you need to predict)\nstiches togather the grid points to model the space between points","19749ea6":"# Comparing image\n## and see where is the change happen","43510bab":"# normalizing data","72b20053":"# find the ejection fraction of a persons heart\n\n***ejection fraction = (lv_max - lv_min )\/(lv_max)***","9dfc5d41":"# **Measuring Intensity**\n## * finding the center of mass\n## * finding the volume of the part from the 3D image","aa13fe13":"## Segmentation objects and lebel\n## labeling image components","af80e030":"# Measuring Shape and size volium (morphology)\n\nto measure the ammount of object accupied by and object we need two quantities\n## * space ocupied by each element\n## * number of array element","2e2773ee":"# all are called in combine **Affine transformation**\n## * sifting image (it is called translation of image)\n## * rotating image ( rotating image) \n## * scaling image (changing the size of the image)\n## * shering changing axis ( chaning the axis of the image)","7da59d76":"# **FILTER**\nyou can apply convolutional filter\n\n\n1.   **Smoothing**\n2.   **Sharpening**\n\nit apply the convolution just  like we did in the convd layer and it extract the important feature by multiply with weight with that","b9cf80be":"## downsampling an image\ninformation is merged accross multiple pixels to reduce the image zise"}}