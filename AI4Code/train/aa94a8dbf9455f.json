{"cell_type":{"02a32162":"code","5606d67b":"code","e5da8958":"code","b5ca0eb2":"code","f40843c0":"code","ad4d56b1":"code","e75013e8":"code","23c4bf56":"code","5b19e399":"code","c94809f2":"code","2c461ff0":"code","793b964a":"code","5234370d":"code","3027f539":"code","a2e267c1":"code","6d84db22":"code","ad1703ea":"code","39c88970":"markdown"},"source":{"02a32162":"# Detect hardware, return appropriate distribution strategy\nimport tensorflow as tf\ntry:\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()  # TPU detection. No parameters necessary if TPU_NAME environment variable is set. On Kaggle this is always the case.\n    print('Running on TPU ', tpu.master())\nexcept ValueError:\n    tpu = None\n\nif tpu:\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\nelse:\n    strategy = tf.distribute.get_strategy() # default distribution strategy in Tensorflow. Works on CPU and single GPU.\n\nprint(\"REPLICAS: \", strategy.num_replicas_in_sync)","5606d67b":"pwd","e5da8958":"import numpy as np # numeric python\nimport pandas as pd # data management\nimport seaborn as sbn # data visualisation\nimport matplotlib.pyplot as pplt\n%matplotlib inline\nfrom keras.models import Sequential\nfrom keras.layers.core import Dense\nfrom keras.layers import Conv2D, MaxPool2D, Flatten\nfrom keras.regularizers import l2\nfrom keras.utils import np_utils","b5ca0eb2":"train = pd.read_csv(\"\/kaggle\/input\/digit-recognizer\/train.csv\") \ntest = pd.read_csv(\"\/kaggle\/input\/digit-recognizer\/test.csv\")","f40843c0":"train.head()","ad4d56b1":"test.head()","e75013e8":"# seperate the first column as Output-Data\nYTrain = train[\"label\"] \n# cut the 'label' column from training-data\nXTrain = train.drop(labels = [\"label\"],axis = 1)  \ndel train\ng = sbn.countplot(YTrain) \nYTrain.value_counts()","23c4bf56":"# normalisation to [0..1] instead of [0..255]\nXTrain = XTrain \/ 255.0 \ntest = test \/ 255.0","5b19e399":"# keras needs a shape (height,weight,channel)\n# whith channel=1=greyscale, =3=rgb\nXTrain = XTrain.values.reshape(-1,28,28,1) # -1 means all samples\nprint(XTrain.shape)\ntest = test.values.reshape(-1,28,28,1)\n# the lables as \"one-hot\"-coding \nYTrain = np_utils.to_categorical(YTrain, num_classes = 10)\nprint(YTrain.shape)","c94809f2":"# like to see the first digit\nmyfirstdigit = XTrain[0]\npplt.imshow(myfirstdigit [:,:,0],cmap=pplt.cm.binary)\npplt.show()","2c461ff0":"# showing the last digit\nmylastdigit = XTrain[41999]\npplt.imshow(mylastdigit [:,:,0],cmap=pplt.cm.binary)\npplt.show()","793b964a":"# create the train- and validation-data\nfrom sklearn.model_selection import train_test_split\nXTrain, XVal, YTrain, YVal = train_test_split(XTrain, YTrain, test_size=0.1, random_state=None )\nprint(\"XTrain shape: \",XTrain.shape)\nprint(\"YTrain shape: \",YTrain.shape)\nprint(\"XVal shape: \",XVal.shape)\nprint(\"YVal shape: \",YVal.shape)","5234370d":"# instantiating the model in the strategy scope creates the model on the TPU\n\nwith strategy.scope():\n    model = tf.keras.Sequential([\n         tf.keras.layers.Conv2D(32,(4,4),padding='same',activation='relu',kernel_regularizer=l2(0.001),activity_regularizer=l2(0.001),input_shape=(28,28,1)), \n         tf.keras.layers.MaxPool2D((2,2)),\n         tf.keras.layers.Conv2D(64,(4,4),padding='same',activation='relu',kernel_regularizer=l2(0.01),activity_regularizer=l2(0.01)),\n         tf.keras.layers.MaxPool2D((2,2)),\n         tf.keras.layers.Conv2D(128,(4,4),padding='same',activation='relu',kernel_regularizer=l2(0.001),activity_regularizer=l2(0.001)),\n         tf.keras.layers.MaxPool2D((2,2)),\n         tf.keras.layers.Flatten(),\n         tf.keras.layers.Dense(128,activation='relu'),#128\n         tf.keras.layers.Dense(10,activation='softmax'),\n     ])\n    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])\n\n    model.summary()","3027f539":"#history=CNN.fit(XTrain,YTrain,epochs=6)\nmy_batch_size = 8  * strategy.num_replicas_in_sync *16 \nmy_steps = len(XTrain) \/\/ my_batch_size\nhistory = model.fit(XTrain.astype(np.float32),YTrain.astype(np.float32),\n                    shuffle=True,\n                    epochs=200,\n                    batch_size=my_batch_size,\n                    steps_per_epoch=my_steps,\n                    validation_data=(XVal.astype(np.float32),YVal.astype(np.float32))# astype float32 seems to be very important for TPU processing\n                    )","a2e267c1":"history_dict = history.history\nhistory_dict.keys()# look witch keys exist\nloss_values = history_dict['loss']\nacc_values = history_dict['accuracy']\nepochs = range(1, len(loss_values)+1)\npplt.plot(epochs,loss_values,'r', label='training loss')\npplt.plot(epochs,acc_values,'g',label='accuracy')\npplt.title('loss and accuracy')\npplt.xlabel('epochs')\npplt.ylabel('loss vs. accuracy')\npplt.legend()\npplt.show()","6d84db22":"# prediction\nresults = model.predict(test.astype(np.float32)) \n# index with the maximum probability\nresults = np.argmax(results,axis = 1) \nresults = pd.Series(results,name=\"Label\")","ad1703ea":"submission = pd.concat([pd.Series(range(1,28001),name = \"ImageId\"),results],axis = 1) \nsubmission.to_csv(\"mysubmission.csv\",index=False) ","39c88970":"This notebook works in my original version on an Android Tablet :) (Pydroid3 jupyter notebook).\nBut in this new Version I try to use a TPU v3-8"}}