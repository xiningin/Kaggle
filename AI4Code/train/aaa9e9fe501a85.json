{"cell_type":{"3b455ebe":"code","0ce4ef79":"code","1b3d313e":"code","83fcb1ee":"code","73ee000b":"code","6c83d106":"code","e1643237":"code","55edc9b9":"code","024d7481":"code","808bdece":"code","4e9bea6b":"code","baafbd90":"code","cffaeee9":"code","e2cc0d9a":"code","747dde66":"code","dfdecebb":"code","3d5d5ee3":"code","14e79344":"code","70bf91b4":"code","5f4b2aa4":"code","61b8dfc3":"code","c65016ae":"code","1d11e0f8":"code","43ac1410":"code","c59ae579":"code","7d50e278":"code","4ba334e6":"code","17b183d2":"code","e37a669b":"code","007cc780":"code","49d362ba":"code","5cf78c79":"code","aaae8ce9":"code","ac6e97b2":"code","46e0ecdc":"code","fc904498":"code","c284c6f6":"code","a97190fe":"code","f847a4ea":"code","6340e7ca":"code","02a9fa7e":"code","b8bc881e":"code","7123a4ea":"code","dd535b75":"code","41a8db8a":"code","7a75708f":"markdown","bf6c8013":"markdown","6220f92b":"markdown","228dc3b9":"markdown","54331451":"markdown","cd24b57e":"markdown","878e9e54":"markdown","f0326b03":"markdown","55a734c1":"markdown","cfc10cd9":"markdown","99afdd06":"markdown","46b083af":"markdown","9a535051":"markdown"},"source":{"3b455ebe":"import numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nimport copy\nwarnings.simplefilter(\"ignore\")\nplt.style.use(\"bmh\")","0ce4ef79":"df = pd.read_csv(\"\/kaggle\/input\/hurricane-database\/atlantic.csv\")","1b3d313e":"df[\"Time\"] = df[\"Time\"].astype(\"object\")\ntime_replace = [str(x) for x in df[\"Time\"].unique()]\nfor i, txt in enumerate(time_replace):\n    time_replace[i] = txt.rjust(4, \"0\")\n    time_replace[i] = f\"{time_replace[i][0:2]}:{time_replace[i][2:4]}:00\"\nfor old, new in zip(df[\"Time\"].unique(), time_replace):\n    df.loc[df[\"Time\"]==old, \"Time\"] = new\n#df[\"Time\"].unique() ","83fcb1ee":"df[\"Date\"] = df[\"Date\"].astype(\"object\")\nfor i, date_str in enumerate(df[\"Date\"].unique()):\n    df.loc[df[\"Date\"]==date_str, \"Date\"] = f\"{str(date_str)[0:4]}-{str(date_str)[4:6]}-{str(date_str)[6:]}\"","73ee000b":"df[\"Datetime\"] = df[\"Date\"]+\" \"+df[\"Time\"]\ndf[\"Datetime\"] = pd.to_datetime(df[\"Datetime\"])\ndf.drop(columns=[\"Date\", \"Time\"], inplace=True)\ndf.sort_values(by=[\"Datetime\"], inplace=True)","6c83d106":"df[\"Name\"] = df[\"Name\"].str.strip()\ndf[\"Status\"] = df[\"Status\"].str.strip()\ndf[\"Event\"] = df[\"Event\"].str.strip()","e1643237":"print(f\"Dataset contains data of {df['ID'].unique().shape[0]} individual storms from {df['Datetime'].dt.year.min()} to {df['Datetime'].dt.year.max()}.\")","55edc9b9":"def coordinate_mapping(x):\n    coord = float(x[:-1])\n    if x[-1]==\"W\":\n        coord *= -1\n    if x[-1]==\"S\":\n        coord *= -1\n    return coord","024d7481":"df[\"Latitude\"] = df[\"Latitude\"].apply(coordinate_mapping)\ndf[\"Longitude\"] = df[\"Longitude\"].apply(coordinate_mapping)","808bdece":"print(\"Min. Long.:\", df.Longitude.min(), \"Max. Long.:\", df.Longitude.max(), \"Min. Lat.:\", df.Latitude.min(), \"Max. Lat.:\", df.Latitude.max())","4e9bea6b":"df.loc[df.Longitude<-180, \"Longitude\"] = df.Longitude+360","baafbd90":"gdf = gpd.GeoDataFrame(df,geometry=gpd.points_from_xy(df.Longitude,df.Latitude), crs={'init' :'epsg:4326'})","cffaeee9":"gdf.crs","e2cc0d9a":"world = gpd.read_file(gpd.datasets.get_path(\"naturalearth_lowres\"))","747dde66":"ax = world.plot(color=\"white\", edgecolor=\"black\", figsize=(25,12))\n_ = gdf[gdf[\"ID\"]==\"AL092004\"].plot(ax=ax, c=\"r\", markersize=\"Maximum Wind\", alpha=0.5)\n_ = plt.xlim(-120, 20)\n_ = plt.ylim(-10, 60)\n_ = plt.title(f'{gdf[gdf[\"ID\"]==\"AL092004\"].Name.unique()[0]} ({gdf[gdf[\"ID\"]==\"AL092004\"].Datetime.dt.year.unique()[0]})')","dfdecebb":"lat_min = gdf.Latitude.min()\nlong_min = gdf.Longitude.min()\ngdf[\"x\"] = gdf.Latitude-lat_min\ngdf[\"x\"] = gdf[\"x\"]\/gdf[\"x\"].max()\ngdf[\"y\"] = gdf.Longitude-long_min\ngdf[\"y\"] = gdf[\"y\"]\/gdf[\"y\"].max()","3d5d5ee3":"gdf[\"relative_time\"] = ((gdf.Datetime.dt.dayofyear+(gdf.Datetime.dt.hour\/24.)+(gdf.Datetime.dt.minute\/60.*24))\/366.) # Each day is 1\/366 of a year (WITH 31th of december), each hour is a 1\/24 of a day and each minute 1\/60 of a hour.","14e79344":"gdf[\"month\"] = gdf.Datetime.dt.month\ngdf[\"hour\"] = gdf.Datetime.dt.hour","70bf91b4":"_ = gdf.plot(x=\"relative_time\", y=\"Maximum Wind\", kind=\"scatter\", figsize=(20,12), title=\"Max. Wind vs. relative_time\")\n_ = plt.ylim(0,180)\n_ = plt.xlim(0,1)","5f4b2aa4":"gdf[\"vec_x\"] = np.nan\ngdf[\"vec_y\"] = np.nan\nvecs = {\"x\": [], \"y\": [], \"id\": []}\nfor storm_id in gdf[\"ID\"].unique():\n    last_x = 0\n    last_y = 0\n    for i, row in gdf[gdf[\"ID\"]==storm_id].iterrows():\n        if last_x==0:\n            last_x = row.x\n            last_y = row.y\n        else:\n            vec_x = row.x-last_x\n            vec_y = row.y-last_y\n            vecs[\"x\"].append(vec_x)\n            vecs[\"y\"].append(vec_y)\n            vecs[\"id\"].append(i)\n            last_x = row.x\n            last_y = row.y\ngdf.loc[vecs[\"id\"], \"vec_x\"] = vecs[\"x\"]\ngdf.loc[vecs[\"id\"], \"vec_y\"] = vecs[\"y\"]","61b8dfc3":"gdf[\"vec_len\"] = np.sqrt((gdf[\"vec_x\"]**2)+(gdf[\"vec_y\"]**2))","c65016ae":"def calculate_direction(vec_x, vec_y):\n    def vec_angle(a, b):\n        return np.arccos(np.dot(a,b)\/(np.linalg.norm(a)*np.linalg.norm(b)))\n    ref_vec = np.array([vec_x, vec_y])\n    N_vec = np.array([0,1])\n    S_vec = np.array([0,-1])\n    E_vec = np.array([1,0])\n    W_vec = np.array([-1,0])\n    N_angle = vec_angle(ref_vec, N_vec)\n    E_angle = vec_angle(ref_vec, E_vec)\n    W_angle = vec_angle(ref_vec, W_vec)\n    return_angle = N_angle\n    if W_angle<E_angle:\n        return_angle = 2*np.pi-return_angle\n    return return_angle","1d11e0f8":"gdf[\"vec_direction\"] = gdf.apply(lambda x: calculate_direction(x.vec_x, x.vec_y), axis=1)","43ac1410":"gdf[\"tdelta\"] = np.nan\ntdeltas = {\"t\": [], \"id\": []}\nfor storm_id in gdf[\"ID\"].unique():\n    last_time = 0\n    for i, row in gdf[gdf[\"ID\"]==storm_id].iterrows():\n        if last_time==0:\n            last_time = row.Datetime\n        else:\n            tdeltas[\"t\"].append((row.Datetime-last_time).seconds)\n            tdeltas[\"id\"].append(i)\n            last_time = row.Datetime\ngdf.loc[tdeltas[\"id\"], \"tdelta\"] = tdeltas[\"t\"]","c59ae579":"gdf = gdf[gdf[\"tdelta\"]==21600]\ngdf.shape","7d50e278":"gdf[\"prev_len\"] = np.nan\ngdf[\"prev_direction\"] = np.nan\nprevs = {\"len\": [], \"direction\": [], \"id\": []}\nfor storm_id in gdf[\"ID\"].unique():\n    last_len = False\n    last_direction = False\n    for i, row in gdf[gdf[\"ID\"]==storm_id].iterrows():\n        if last_len==False:\n            last_len = row.vec_len\n            last_direction = row.vec_direction\n        else:\n            prevs[\"len\"].append(last_len)\n            prevs[\"direction\"].append(last_direction)\n            prevs[\"id\"].append(i)\n            last_len = row.vec_len\n            last_direction = row.vec_direction\ngdf.loc[prevs[\"id\"], \"prev_len\"] = prevs[\"len\"]\ngdf.loc[prevs[\"id\"], \"prev_direction\"] = prevs[\"direction\"]","4ba334e6":"gdf.dropna(how=\"any\", inplace=True)\ngdf.shape","17b183d2":"gdf_prediction_direction = gdf[[\"Maximum Wind\", \"x\", \"y\", \"month\", \"hour\", \"prev_len\", \"prev_direction\", \"vec_direction\"]]\ngdf_prediction_length = gdf[[\"Maximum Wind\", \"x\", \"y\", \"month\", \"hour\", \"prev_len\", \"prev_direction\",\"vec_len\"]]\nX_direction = gdf_prediction_direction.values[:,:-1]\ny_direction = gdf_prediction_direction.values[:,-1]\nX_length = gdf_prediction_length.values[:,:-1]\ny_length = gdf_prediction_length.values[:,-1]","e37a669b":"from sklearn.model_selection import train_test_split\nX_direction_train, X_direction_test, y_direction_train, y_direction_test = train_test_split(X_direction, y_direction, test_size=0.2, random_state=42)\nX_length_train, X_length_test, y_length_train, y_length_test = train_test_split(X_length, y_length, test_size=0.2, random_state=42)","007cc780":"from sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.metrics import mean_squared_error","49d362ba":"model_direction = GradientBoostingRegressor(n_estimators=100, learning_rate=0.1, max_depth=5, random_state=0, loss='ls').fit(X_direction_train, y_direction_train)\nmean_squared_error(y_direction_test, model_direction.predict(X_direction_test))","5cf78c79":"model_length = GradientBoostingRegressor(n_estimators=100, learning_rate=0.1, max_depth=5, random_state=0, loss='ls').fit(X_length_train, y_length_train)\nmean_squared_error(y_length_test, model_length.predict(X_length_test))","aaae8ce9":"import shap","ac6e97b2":"explainer_direction = shap.TreeExplainer(model_direction)\nshap_values_direction = explainer_direction.shap_values(X_direction_test)\nshap.summary_plot(shap_values_direction, X_direction_test, plot_type=\"bar\", feature_names=[\"Maximum Wind\", \"x\", \"y\", \"month\", \"hour\", \"prev_len\", \"prev_direction\"], title=\"Feature importances model_direction\", plot_size=(20,10))","46e0ecdc":"explainer_length = shap.TreeExplainer(model_length)\nshap_values_length = explainer_length.shap_values(X_length_test)\nshap.summary_plot(shap_values_length, X_length_test, plot_type=\"bar\", feature_names=[\"Maximum Wind\", \"x\", \"y\", \"month\", \"hour\", \"prev_len\", \"prev_direction\"], title=\"Feature importances model_length\", plot_size=(20,10))","fc904498":"lat_min = df.Latitude.min()\nlong_min = df.Longitude.min()\ntemp_x = df.Latitude-lat_min\ntemp_y = df.Longitude-long_min\nx_max = temp_x.max()\ny_max = temp_y.max()\n\ndef coords_to_latlong(x, y, lat_min, long_min, x_max, y_max):\n    return (x*x_max)+lat_min, (y*y_max)+long_min","c284c6f6":"gdf[gdf.Name==\"KATRINA\"].ID.unique()","a97190fe":"storm_id = \"AL122005\"\ngdf_pred = gdf[[\"Latitude\", \"Longitude\", \"Maximum Wind\", \"x\", \"y\", \"month\", \"hour\", \"prev_len\", \"prev_direction\", \"vec_len\", \"vec_direction\"]][gdf.ID==storm_id]\nX_pred_direction = gdf_pred[[\"Maximum Wind\", \"x\", \"y\", \"month\", \"hour\", \"prev_len\", \"prev_direction\"]].iloc[1:].values\nX_pred_len = gdf_pred[[\"Maximum Wind\", \"x\", \"y\", \"month\", \"hour\", \"prev_len\", \"prev_direction\"]].iloc[1:].values","f847a4ea":"df_pred = pd.DataFrame({\"pred_len\": model_length.predict(X_pred_len), \"pred_direction\": model_direction.predict(X_pred_direction)})","6340e7ca":"df_pred[\"pred_x\"] = np.nan\ndf_pred[\"pred_y\"] = np.nan\ndf_pred[\"real_x\"] = gdf_pred[\"x\"].iloc[1:].values\ndf_pred[\"real_y\"] = gdf_pred[\"y\"].iloc[1:].values","02a9fa7e":"last_x = gdf_pred[\"x\"].iloc[0]\nlast_y = gdf_pred[\"y\"].iloc[0]\ncoords = {\"x\": [], \"y\": [], \"id\": []}\nfor i, row in df_pred.iterrows():\n    vector = np.array([0,1])\n    R = np.array([[np.cos(row.pred_direction), -np.sin(row.pred_direction)], [np.sin(row.pred_direction), np.cos(row.pred_direction)]])\n    vector = np.matmul(vector, R)\n    vector = vector\/np.linalg.norm(vector)\n    vector *= row.pred_len\n    coords[\"x\"].append(last_x+vector[0])\n    coords[\"y\"].append(last_y+vector[1])\n    coords[\"id\"].append(i)\n    last_x = row.real_x\n    last_y = row.real_y\ndf_pred.loc[coords[\"id\"], \"pred_x\"] = coords[\"x\"]\ndf_pred.loc[coords[\"id\"], \"pred_y\"] = coords[\"y\"]","b8bc881e":"df_pred[\"pred_Longitude\"] = np.nan\ndf_pred[\"real_Longitude\"] = np.nan\ndf_pred[\"pred_Latitude\"] = np.nan\ndf_pred[\"real_Latitude\"] = np.nan\nlatslongs = {\"pred_Longitude\": [], \"real_Longitude\": [], \"pred_Latitude\": [], \"real_Latitude\": [], \"id\": []}\nfor i, row in df_pred.iterrows():\n    real_Latitude, real_Longitude = coords_to_latlong(row.real_x, row.real_y, lat_min, long_min, x_max, y_max)\n    latslongs[\"real_Latitude\"].append(real_Latitude)\n    latslongs[\"real_Longitude\"].append(real_Longitude)\n    pred_Latitude, pred_Longitude = coords_to_latlong(row.pred_x, row.pred_y, lat_min, long_min, x_max, y_max)\n    latslongs[\"pred_Latitude\"].append(pred_Latitude)\n    latslongs[\"pred_Longitude\"].append(pred_Longitude)\n    latslongs[\"id\"].append(i)\ndf_pred.loc[latslongs[\"id\"], \"real_Latitude\"] = latslongs[\"real_Latitude\"]\ndf_pred.loc[latslongs[\"id\"], \"real_Longitude\"] = latslongs[\"real_Longitude\"]\ndf_pred.loc[latslongs[\"id\"], \"pred_Latitude\"] = latslongs[\"pred_Latitude\"]\ndf_pred.loc[latslongs[\"id\"], \"pred_Longitude\"] = latslongs[\"pred_Longitude\"]","7123a4ea":"df_pred","dd535b75":"gdf_real = gpd.GeoDataFrame(df_pred,geometry=gpd.points_from_xy(df_pred.real_Longitude,df_pred.real_Latitude), crs={'init' :'epsg:4326'})\ngdf_pred = gpd.GeoDataFrame(df_pred,geometry=gpd.points_from_xy(df_pred.pred_Longitude,df_pred.pred_Latitude), crs={'init' :'epsg:4326'})","41a8db8a":"ax = world.plot(color=\"white\", edgecolor=\"black\", figsize=(25,12))\n_ = gdf_real.plot(ax=ax, c=\"r\", marker=\"x\", alpha=0.5)\n_ = gdf_pred.plot(ax=ax, c=\"b\", marker=\"x\", alpha=0.5)\n_ = plt.xlim(-120, 20)\n_ = plt.ylim(-10, 60)","7a75708f":"# Analysis of caribbean hurricanes\nInspired by https:\/\/arxiv.org\/abs\/1802.02548 i also wanted to try to predict the tracks of hurricanes based on data of past storms.\nI found this similar looking dataset and will try to do similar predictions but experiment with different methods (and not start with RNN's).","bf6c8013":"I remember from some news articles\/documentaries that there is something like a \"hurricane season\" let's see if this is reflected in the dataset.","6220f92b":"**That's not bad!**<br>As the error of the direction is a multiple of PI we can calculate the mean squared error as 22.9\u00b0<br>The error of the length\/distance is very low.<br><br>Let's look at the feature importances with the help of the shap module.","228dc3b9":"We'll try to predict the next position in the storm trajectory. To be able to do this we need to calculate the vectors for each positional change.","54331451":"### Model\nThe hypothesis for both models (distance traveled, direction) depends on the following features:\n* Maximum Wind: The highest measured windspeed\n* Position (x, y): Probably the most important feature, as storms behave similary in the gulf etc. (my hope is, that the models create some kind of artifical grid, e.g. if x>0.1 and x<0.2 etc., even though that requires A LOT of splits)\n* Month of year: A latent variable for the genereal climatic conditions (Temperature, Jet stream etc.)\n* Hour of day: A latent variable for temperature (usually the temperature at 12am is different than at 2am etc.)\n* Previous distance\/direction","cd24b57e":"## Prediction\nNow i'll try to predict the direction and the distance of for each time step.","878e9e54":"To make predictions i'll construct a simplified coordinate system where the latitude is the x axis and longitude is the y axis and the positions of all storms are between 0 and 1. ","f0326b03":"## Visualization of the results\nIn the last part of this notebook i'll predict the trajectory of a storm and plot the real (red) and predicted (blue) trajectories in the same plot.<br>\nThis involves some rather complicated transformations, similar to the calculation of the features above (only in the opposite direction)","55a734c1":"For the distance\/length prediction the previous value is the most important one, too.","cfc10cd9":"A minimum longitude of -359.1 makes no sense as the scale is between 180 und -180, so we have to rotate these values.","99afdd06":"As expected the previous direction has a huge influence, followed by the latitude and the previous distance.","46b083af":"The month and season is an important feature because this contains implicit information such as the water temperature. A continous number is much easier to work with than with months\/days etc. so i'll create a feature where the first of january corresponds to 0 and the 31th of december corresponds to 1.<br>Additionally i'll create a feature \"Month of year\" and \"Hour of day\". ","9a535051":"Because we can only predict one value we'll need two models to predict the trajectory. As the independent prediction of the x and y position probably won't work i'll use one model to predict the change in direction (angle) and the change in distance (length)."}}