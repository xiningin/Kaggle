{"cell_type":{"ba2c4c21":"code","d2ce534a":"code","df21c5a1":"code","be0510cf":"code","ad7f9824":"code","451d35f5":"code","8d76cce1":"code","a0cfcfa5":"code","390a23f9":"code","b9ce6475":"code","dd16e111":"code","e4bab41e":"markdown","cf00cca0":"markdown","61507795":"markdown","a56493db":"markdown","5333d0e1":"markdown","13332ed4":"markdown","02ad5f09":"markdown","e00d0233":"markdown","3dcefd4a":"markdown","fdbf7f79":"markdown","d4874283":"markdown","96bdcc5a":"markdown","58137d91":"markdown"},"source":{"ba2c4c21":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nimport cv2\nimport warnings\nwarnings.filterwarnings('ignore')","d2ce534a":"image = cv2.imread('\/kaggle\/input\/kmeans\/color.jfif')\n\nplt.imshow(image);","df21c5a1":"image.shape","be0510cf":"from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler(with_mean = 0,with_std=1)","ad7f9824":"r = []\ng = []\nb = []\n\nfor line in image:\n    for pixel in line:\n        temp_b , temp_g,temp_r = pixel\n        \n        r.append(temp_r)\n        g.append(temp_g)\n        b.append(temp_b)\n    \ndf = pd.DataFrame({'red': r,'green': g,'blue': b})\n\ndf['scaled_red'] = scaler.fit_transform(df[['red']])\ndf['scaled_green'] = scaler.fit_transform(df[['green']])\ndf['scaled_blue'] = scaler.fit_transform(df[['blue']])\n\ndf.head()","451d35f5":"X = df[['scaled_red','scaled_green','scaled_blue']].values\nX","8d76cce1":"SSE = []\n\nfor cluster in range(2,8): \n    kmeans = KMeans(n_clusters=cluster,random_state=42)\n    kmeans.fit(X)\n    \n    pred_clusters = kmeans.predict(X)\n    SSE.append(kmeans.inertia_)\n    \nframe = pd.DataFrame({'Cluster':range(2,8) , 'SSE':SSE})\nprint(frame)","a0cfcfa5":"plt.figure(figsize=(5,5))\nplt.plot(frame['Cluster'],frame['SSE'],marker='o')\nplt.title('Clusters Vs SSE')\nplt.xlabel('No of Clusters')\nplt.ylabel('Intertia')\nplt.show()","390a23f9":"#Fit and predict for k = 4\nk=4\nkmeans = KMeans(n_clusters=k)\nkmeans.fit(X)\nk_pred = kmeans.predict(X)\n\n#These are the centroids of the clusters\ncluster_centers = kmeans.cluster_centers_\ncluster_centers","b9ce6475":"colors = []\n\nr_std, g_std, b_std = df[['red', 'green', 'blue']].std()\n\nfor cluster_center in cluster_centers:\n    scaled_r, scaled_g, scaled_b = cluster_center\n    \n    colors.append((\n    scaled_r * r_std \/255,\n    scaled_g * g_std \/ 255,\n    scaled_b * b_std\/ 255\n    ))\n    \nplt.imshow([colors])\nplt.show()","dd16e111":"res = cluster_centers[k_pred.flatten()]\nresult_image = res.reshape((image.shape))\n\nim_bgr = result_image[:, :, [2, 1, 0]] #restoring the image in bgr form\n\nrescale_image = scaler.inverse_transform(im_bgr).astype(int) #rescaling it back to original\n\nfigure_size = 15\nplt.figure(figsize=(figure_size,figure_size))\nplt.subplot(1,2,1),plt.imshow(image)\nplt.title('Original Image'), plt.xticks([]), plt.yticks([])\nplt.subplot(1,2,2),plt.imshow(rescale_image)\nplt.title('Segmented Image when K = 4'), plt.xticks([]), plt.yticks([])\nplt.show()","e4bab41e":"    Read the pixel data into R,G and B and scale them","cf00cca0":"    Let's just use the scaled RGB values for for KMeans","61507795":"    In Python, the image can be read using the imread method from cv2 library. It can be plotted using imshow.","a56493db":"    How to determine the number of clusters to be used. With simple images, its easy to visually identify the \n    number of clusters. But more the number of color\/gradient in the image, the harder it is!\n\n    Elbow method can used to determine the optimal value of k\n\n    1: Choose the number of clusters k\n    2: Select k random points from the data as centroids\n    3: Assign all the points to the closest cluster centroid\n    4: Recompute the centroids of newly formed clusters\n    5: Repeat steps 3 and 4\n\n    Stopping Criteria :\n    Centroids of newly formed clusters do not change\n    Points remain in the same cluster\n    Maximum number of iterations are reached","5333d0e1":"    Kindly upvote my work and suggest improvements or corrections. This is my first attempt of KMeans with images\n","13332ed4":"    We do not see the exact colors as in the image. \n    That's because the cluster centers are the means all of of the RGB values of all pixels in each cluster. \n    Hence the ouptput cluster center may not appear in the same color as in the original image\n    It's only the RBG value that is at the center of the cluster of all similar looking pixels from our image.","02ad5f09":"    Let's just read the RGB values from the image. \n    Loop over each line of the image, and again loop over each pixel to decode the r,g,b values\n\n    Here the image pixels are stored in BGR format and hence take care while reading!\n\n    The R,G,B is then stored into a dataframe and scaled using StandardScaler(with standard deviation set to True)\n    This scaled data is stored in r_scaled,g_scaled and b_scaled columns","e00d0233":"    This image has 300 rows, 300 columns with 3 RGB values.","3dcefd4a":"    Let's check the predicted image against original image    ","fdbf7f79":"    Images can have various extensions like JPG, PNG, TIFF. The first step in the process is to read the image. \n    Image is stored as a list of dots called pixels. \n    The color of each pixel is a combination of 3 color component(Red,Green,Blue).","d4874283":"    The sum of squared errors can be plotted to see the changes in SSE with respect to k. As k increases, \n    the cluster will have less values and the average error will reduce. The lesser number of values in a\n    cluster means closer to the centroid. The point where the error almost declines, will be the optimal \n    value for k and is the elbow point","96bdcc5a":"    First let's see what are the dominant colors in this image.\n    The results from the KMeans cluster_centers are standardized versions of RGB values. \n    To get the original color values we need to multiply them with their standard deviations. \n    (In our StandardScaler we used the standardization with standard deviation set to True). \n    We can plot using imshow.","58137d91":"    From the above figure , we can see that k could range from 3 to 7. \n    However 4 looks more optimal for this image"}}