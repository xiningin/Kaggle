{"cell_type":{"cd24e5a5":"code","7c077f32":"code","7aace9c5":"code","d05010a5":"code","948fc581":"code","fa83b744":"code","627e7406":"code","7a70c974":"code","4851e2e1":"code","2a494df6":"code","933e9d2b":"code","c3de8f1d":"code","5232244d":"code","a030bb84":"code","cb4a7eca":"code","c6971835":"code","e225ee4d":"code","2dc7b964":"code","69ac71ca":"code","a227a65e":"code","eb2736ad":"code","2f8779f5":"code","3e66b0eb":"code","31574a3a":"code","3b11c4cc":"code","624d5fb8":"code","aaf6eede":"code","5d6663b2":"code","7d6d4d8f":"code","4f9c5f1e":"code","1865a448":"code","7aba0222":"code","b95a8080":"code","0122fb02":"code","ec6e06a0":"code","7df9f076":"code","4397f5ad":"markdown","0306c1cb":"markdown","3ed74e93":"markdown","04719b67":"markdown","0d7cd2de":"markdown","f03851d7":"markdown","ac0575d5":"markdown","20dd9cb3":"markdown","28f6d4de":"markdown","67d3b146":"markdown","e1cddfed":"markdown","7123f194":"markdown","9dc07801":"markdown","06fbfa67":"markdown","e6da2e16":"markdown","82bf8f62":"markdown","7e337dd5":"markdown","955db92f":"markdown","5f5b799e":"markdown"},"source":{"cd24e5a5":"!pip install albumentations > \/dev\/null\n!pip install -U efficientnet==0.0.4\nimport numpy as np\nimport pandas as pd\nimport gc\nimport keras\n\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-white')\nimport seaborn as sns\nsns.set_style(\"white\")\n\nfrom sklearn.model_selection import train_test_split,StratifiedKFold\n\nfrom skimage.transform import resize\nimport tensorflow as tf\nimport keras.backend as K\nfrom keras.losses import binary_crossentropy\n\nfrom keras.preprocessing.image import load_img\nfrom keras import Model\nfrom keras.callbacks import  ModelCheckpoint\nfrom keras.layers import Input, Conv2D, Conv2DTranspose, MaxPooling2D, concatenate, Dropout,BatchNormalization\nfrom keras.layers import Conv2D, Concatenate, MaxPooling2D\nfrom keras.layers import UpSampling2D, Dropout, BatchNormalization\nfrom tqdm import tqdm_notebook\nfrom keras import initializers\nfrom keras import regularizers\nfrom keras import constraints\nfrom keras.utils import conv_utils\nfrom keras.utils.data_utils import get_file\nfrom keras.engine.topology import get_source_inputs\nfrom keras.engine import InputSpec\nfrom keras import backend as K\nfrom keras.layers import LeakyReLU\nfrom keras.layers import ZeroPadding2D\nfrom keras.losses import binary_crossentropy\nimport keras.callbacks as callbacks\nfrom keras.callbacks import Callback\nfrom keras.applications.xception import Xception\nfrom keras.layers import multiply\n\n\nfrom keras import optimizers\nfrom keras.legacy import interfaces\nfrom keras.utils.generic_utils import get_custom_objects\n\nfrom keras.engine.topology import Input\nfrom keras.engine.training import Model\nfrom keras.layers.convolutional import Conv2D, UpSampling2D, Conv2DTranspose\nfrom keras.layers.core import Activation, SpatialDropout2D\nfrom keras.layers.merge import concatenate\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.layers.pooling import MaxPooling2D\nfrom keras.layers import Input,Dropout,BatchNormalization,Activation,Add\nfrom keras.regularizers import l2\nfrom keras.layers.core import Dense, Lambda\nfrom keras.layers.merge import concatenate, add\nfrom keras.layers import GlobalAveragePooling2D, Reshape, Dense, multiply, Permute\nfrom keras.optimizers import SGD\nfrom keras.preprocessing.image import ImageDataGenerator\n\nimport glob\nimport shutil\nimport os\nimport random\nfrom PIL import Image\n\nseed = 10\nnp.random.seed(seed)\nrandom.seed(seed)\nos.environ['PYTHONHASHSEED'] = str(seed)\nnp.random.seed(seed)\ntf.set_random_seed(seed)\n    \n%matplotlib inline","7c077f32":"!mkdir masks\n!unzip -q ..\/input\/data-repack-and-image-statistics\/masks.zip -d masks \n!mkdir train\n!unzip -q ..\/input\/data-repack-and-image-statistics\/train.zip -d train \n!mkdir test\n!unzip -q ..\/input\/data-repack-and-image-statistics\/test.zip -d test ","7aace9c5":"all_mask_fn = glob.glob('.\/masks\/*')\nmask_df = pd.DataFrame()\nmask_df['file_names'] = all_mask_fn\nmask_df['mask_percentage'] = 0\nmask_df.set_index('file_names',inplace=True)\nfor fn in all_mask_fn:\n    mask_df.loc[fn,'mask_percentage'] = np.array(Image.open(fn)).sum()\/(256*256*255) #255 is bcz img range is 255\n    \nmask_df.reset_index(inplace=True)\nsns.distplot(mask_df.mask_percentage)\nmask_df['labels'] = 0\nmask_df.loc[mask_df.mask_percentage>0,'labels'] = 1","d05010a5":"all_train_fn = glob.glob('.\/train\/*')\ntotal_samples = len(all_train_fn)\nidx = np.arange(total_samples)\ntrain_fn,val_fn = train_test_split(all_train_fn,stratify=mask_df.labels,test_size=0.1,random_state=10)\n\nprint('No. of train files:', len(train_fn))\nprint('No. of val files:', len(val_fn))\n\nmasks_train_fn = [fn.replace('.\/train','.\/masks') for fn in train_fn]    \nmasks_val_fn = [fn.replace('.\/train','.\/masks') for fn in val_fn]","948fc581":"!mkdir .\/keras_im_train\ntrain_dir = '.\/keras_im_train'\nfor full_fn in train_fn:\n    fn = full_fn.split('\/')[-1]\n    shutil.move(full_fn,os.path.join(train_dir,fn))\n    \n!mkdir .\/keras_mask_train\ntrain_dir = '.\/keras_mask_train'\nfor full_fn in masks_train_fn:\n    fn = full_fn.split('\/')[-1]\n    shutil.move(full_fn,os.path.join(train_dir,fn))\n    \n!mkdir .\/keras_im_val\ntrain_dir = '.\/keras_im_val'\nfor full_fn in val_fn:\n    fn = full_fn.split('\/')[-1]\n    shutil.move(full_fn,os.path.join(train_dir,fn))\n    \n!mkdir .\/keras_mask_val\ntrain_dir = '.\/keras_mask_val'\nfor full_fn in masks_val_fn:\n    fn = full_fn.split('\/')[-1]\n    shutil.move(full_fn,os.path.join(train_dir,fn))","fa83b744":"train_im_path,train_mask_path = '.\/keras_im_train','.\/keras_mask_train'\nh,w,batch_size = 256,256,16\n\nval_im_path,val_mask_path = '.\/keras_im_val','.\/keras_mask_val'\n\nclass DataGenerator(keras.utils.Sequence):\n    'Generates data for Keras'\n    def __init__(self, train_im_path=train_im_path,train_mask_path=train_mask_path,\n                 augmentations=None, batch_size=batch_size,img_size=256, n_channels=3, shuffle=True):\n        'Initialization'\n        self.batch_size = batch_size\n        self.train_im_paths = glob.glob(train_im_path+'\/*')\n        \n        self.train_im_path = train_im_path\n        self.train_mask_path = train_mask_path\n\n        self.img_size = img_size\n        \n        self.n_channels = n_channels\n        self.shuffle = shuffle\n        self.augment = augmentations\n        self.on_epoch_end()\n\n    def __len__(self):\n        'Denotes the number of batches per epoch'\n        return int(np.ceil(len(self.train_im_paths) \/ self.batch_size))\n\n    def __getitem__(self, index):\n        'Generate one batch of data'\n        # Generate indexes of the batch\n        indexes = self.indexes[index*self.batch_size:min((index+1)*self.batch_size,len(self.train_im_paths))]\n\n        # Find list of IDs\n        list_IDs_im = [self.train_im_paths[k] for k in indexes]\n\n        # Generate data\n        X, y = self.data_generation(list_IDs_im)\n\n        if self.augment is None:\n            return X,np.array(y)\/255\n        else:            \n            im,mask = [],[]   \n            for x,y in zip(X,y):\n                augmented = self.augment(image=x, mask=y)\n                im.append(augmented['image'])\n                mask.append(augmented['mask'])\n            return np.array(im),np.array(mask)\/255\n\n    def on_epoch_end(self):\n        'Updates indexes after each epoch'\n        self.indexes = np.arange(len(self.train_im_paths))\n        if self.shuffle == True:\n            np.random.shuffle(self.indexes)\n\n    def data_generation(self, list_IDs_im):\n        'Generates data containing batch_size samples' # X : (n_samples, *dim, n_channels)\n        # Initialization\n        X = np.empty((len(list_IDs_im),self.img_size,self.img_size, self.n_channels))\n        y = np.empty((len(list_IDs_im),self.img_size,self.img_size, 1))\n\n        # Generate data\n        for i, im_path in enumerate(list_IDs_im):\n            \n            im = np.array(Image.open(im_path))\n            mask_path = im_path.replace(self.train_im_path,self.train_mask_path)\n            \n            mask = np.array(Image.open(mask_path))\n            \n            \n            if len(im.shape)==2:\n                im = np.repeat(im[...,None],3,2)\n\n#             # Resize sample\n            X[i,] = cv2.resize(im,(self.img_size,self.img_size))\n\n            # Store class\n            y[i,] = cv2.resize(mask,(self.img_size,self.img_size))[..., np.newaxis]\n            y[y>0] = 255\n\n        return np.uint8(X),np.uint8(y)","627e7406":"import cv2\nfrom albumentations import (\n    Compose, HorizontalFlip, CLAHE, HueSaturationValue,\n    RandomBrightness, RandomContrast, RandomGamma,OneOf,\n    ToFloat, ShiftScaleRotate,GridDistortion, ElasticTransform, JpegCompression, HueSaturationValue,\n    RGBShift, RandomBrightness, RandomContrast, Blur, MotionBlur, MedianBlur, GaussNoise,CenterCrop,\n    IAAAdditiveGaussianNoise,GaussNoise,OpticalDistortion,RandomSizedCrop\n)\n\nAUGMENTATIONS_TRAIN = Compose([\n    HorizontalFlip(p=0.5),\n    OneOf([\n        RandomContrast(),\n        RandomGamma(),\n        RandomBrightness(),\n         ], p=0.3),\n    OneOf([\n        ElasticTransform(alpha=120, sigma=120 * 0.05, alpha_affine=120 * 0.03),\n        GridDistortion(),\n        OpticalDistortion(distort_limit=2, shift_limit=0.5),\n        ], p=0.3),\n    RandomSizedCrop(min_max_height=(176, 256), height=h, width=w,p=0.25),\n    ToFloat(max_value=1)\n],p=1)\n\n\nAUGMENTATIONS_TEST = Compose([\n    ToFloat(max_value=1)\n],p=1)","7a70c974":"a = DataGenerator(batch_size=64,shuffle=False)\nimages,masks = a.__getitem__(0)\nmax_images = 64\ngrid_width = 16\ngrid_height = int(max_images \/ grid_width)\nfig, axs = plt.subplots(grid_height, grid_width, figsize=(grid_width, grid_height))\n\nfor i,(im, mask) in enumerate(zip(images,masks)):\n    ax = axs[int(i \/ grid_width), i % grid_width]\n    ax.imshow(im.squeeze(), cmap=\"bone\")\n    ax.imshow(mask.squeeze(), alpha=0.5, cmap=\"Reds\")    \n    ax.axis('off')\nplt.suptitle(\"Chest X-rays, Red: Pneumothorax.\")","4851e2e1":"a = DataGenerator(batch_size=64,augmentations=AUGMENTATIONS_TRAIN,shuffle=False)\nimages,masks = a.__getitem__(0)\nmax_images = 64\ngrid_width = 16\ngrid_height = int(max_images \/ grid_width)\nfig, axs = plt.subplots(grid_height, grid_width, figsize=(grid_width, grid_height))\n\nfor i,(im, mask) in enumerate(zip(images,masks)):\n    ax = axs[int(i \/ grid_width), i % grid_width]\n    ax.imshow(im[:,:,0], cmap=\"bone\")\n    ax.imshow(mask.squeeze(), alpha=0.5, cmap=\"Reds\")    \n    ax.axis('off')\nplt.suptitle(\"Chest X-rays, Red: Pneumothorax.\")","2a494df6":"# https:\/\/www.kaggle.com\/cpmpml\/fast-iou-metric-in-numpy-and-tensorflow\ndef get_iou_vector(A, B):\n    # Numpy version    \n    batch_size = A.shape[0]\n    metric = 0.0\n    for batch in range(batch_size):\n        t, p = A[batch], B[batch]\n        true = np.sum(t)\n        pred = np.sum(p)\n        \n        # deal with empty mask first\n        if true == 0:\n            metric += (pred == 0)\n            continue\n        \n        # non empty mask case.  Union is never empty \n        # hence it is safe to divide by its number of pixels\n        intersection = np.sum(t * p)\n        union = true + pred - intersection\n        iou = intersection \/ union\n        \n        # iou metrric is a stepwise approximation of the real iou over 0.5\n        iou = np.floor(max(0, (iou - 0.45)*20)) \/ 10\n        \n        metric += iou\n        \n    # teake the average over all images in batch\n    metric \/= batch_size\n    return metric\n\n\ndef my_iou_metric(label, pred):\n    # Tensorflow version\n    return tf.py_func(get_iou_vector, [label, pred > 0.5], tf.float64)","933e9d2b":"def dice_coef(y_true, y_pred):\n    y_true_f = K.flatten(y_true)\n    y_pred = K.cast(y_pred, 'float32')\n    y_pred_f = K.cast(K.greater(K.flatten(y_pred), 0.5), 'float32')\n    intersection = y_true_f * y_pred_f\n    score = 2. * K.sum(intersection) \/ (K.sum(y_true_f) + K.sum(y_pred_f))\n    return score\n\ndef dice_loss(y_true, y_pred):\n    smooth = 1.\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = y_true_f * y_pred_f\n    score = (2. * K.sum(intersection) + smooth) \/ (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)\n    return 1. - score\n\ndef bce_dice_loss(y_true, y_pred):\n    return binary_crossentropy(y_true, y_pred) + dice_loss(y_true, y_pred)\n\ndef bce_logdice_loss(y_true, y_pred):\n    return binary_crossentropy(y_true, y_pred) - K.log(1. - dice_loss(y_true, y_pred))","c3de8f1d":"class SnapshotCallbackBuilder:\n    def __init__(self, nb_epochs, nb_snapshots, init_lr=0.1):\n        self.T = nb_epochs\n        self.M = nb_snapshots\n        self.alpha_zero = init_lr\n\n    def get_callbacks(self, model_prefix='Model'):\n\n        callback_list = [\n            callbacks.ModelCheckpoint(\".\/keras.model\",monitor='val_my_iou_metric', \n                                   mode = 'max', save_best_only=True, verbose=1),\n            swa,\n            callbacks.LearningRateScheduler(schedule=self._cosine_anneal_schedule)\n        ]\n\n        return callback_list\n\n    def _cosine_anneal_schedule(self, t):\n        cos_inner = np.pi * (t % (self.T \/\/ self.M))  # t - 1 is used when t has 1-based indexing.\n        cos_inner \/= self.T \/\/ self.M\n        cos_out = np.cos(cos_inner) + 1\n        return float(self.alpha_zero \/ 2 * cos_out)","5232244d":"def convolution_block(x, filters, size, strides=(1,1), padding='same', activation=True):\n    x = Conv2D(filters, size, strides=strides, padding=padding)(x)\n    x = BatchNormalization()(x)\n    if activation == True:\n        x = LeakyReLU(alpha=0.1)(x)\n    return x\n\ndef residual_block(blockInput, num_filters=16):\n    x = LeakyReLU(alpha=0.1)(blockInput)\n    x = BatchNormalization()(x)\n    blockInput = BatchNormalization()(blockInput)\n    x = convolution_block(x, num_filters, (3,3) )\n    x = convolution_block(x, num_filters, (3,3), activation=False)\n    x = Add()([x, blockInput])\n    return x","a030bb84":"from efficientnet import EfficientNetB4\n\ndef UEfficientNet(input_shape=(None, None, 3),dropout_rate=0.1):\n\n    backbone = EfficientNetB4(weights='imagenet',\n                            include_top=False,\n                            input_shape=input_shape)\n    input = backbone.input\n    start_neurons = 8\n\n    conv4 = backbone.layers[342].output\n    conv4 = LeakyReLU(alpha=0.1)(conv4)\n    pool4 = MaxPooling2D((2, 2))(conv4)\n    pool4 = Dropout(dropout_rate)(pool4)\n    \n     # Middle\n    convm = Conv2D(start_neurons * 32, (3, 3), activation=None, padding=\"same\",name='conv_middle')(pool4)\n    convm = residual_block(convm,start_neurons * 32)\n    convm = residual_block(convm,start_neurons * 32)\n    convm = LeakyReLU(alpha=0.1)(convm)\n    \n    deconv4 = Conv2DTranspose(start_neurons * 16, (3, 3), strides=(2, 2), padding=\"same\")(convm)\n    deconv4_up1 = Conv2DTranspose(start_neurons * 16, (3, 3), strides=(2, 2), padding=\"same\")(deconv4)\n    deconv4_up2 = Conv2DTranspose(start_neurons * 16, (3, 3), strides=(2, 2), padding=\"same\")(deconv4_up1)\n    deconv4_up3 = Conv2DTranspose(start_neurons * 16, (3, 3), strides=(2, 2), padding=\"same\")(deconv4_up2)\n    uconv4 = concatenate([deconv4, conv4])\n    uconv4 = Dropout(dropout_rate)(uconv4) \n    \n    uconv4 = Conv2D(start_neurons * 16, (3, 3), activation=None, padding=\"same\")(uconv4)\n    uconv4 = residual_block(uconv4,start_neurons * 16)\n#     uconv4 = residual_block(uconv4,start_neurons * 16)\n    uconv4 = LeakyReLU(alpha=0.1)(uconv4)  #conv1_2\n    \n    deconv3 = Conv2DTranspose(start_neurons * 8, (3, 3), strides=(2, 2), padding=\"same\")(uconv4)\n    deconv3_up1 = Conv2DTranspose(start_neurons * 8, (3, 3), strides=(2, 2), padding=\"same\")(deconv3)\n    deconv3_up2 = Conv2DTranspose(start_neurons * 8, (3, 3), strides=(2, 2), padding=\"same\")(deconv3_up1)\n    conv3 = backbone.layers[154].output\n    uconv3 = concatenate([deconv3,deconv4_up1, conv3])    \n    uconv3 = Dropout(dropout_rate)(uconv3)\n    \n    uconv3 = Conv2D(start_neurons * 8, (3, 3), activation=None, padding=\"same\")(uconv3)\n    uconv3 = residual_block(uconv3,start_neurons * 8)\n#     uconv3 = residual_block(uconv3,start_neurons * 8)\n    uconv3 = LeakyReLU(alpha=0.1)(uconv3)\n\n    deconv2 = Conv2DTranspose(start_neurons * 4, (3, 3), strides=(2, 2), padding=\"same\")(uconv3)\n    deconv2_up1 = Conv2DTranspose(start_neurons * 4, (3, 3), strides=(2, 2), padding=\"same\")(deconv2)\n    conv2 = backbone.layers[92].output\n    uconv2 = concatenate([deconv2,deconv3_up1,deconv4_up2, conv2])\n        \n    uconv2 = Dropout(0.1)(uconv2)\n    uconv2 = Conv2D(start_neurons * 4, (3, 3), activation=None, padding=\"same\")(uconv2)\n    uconv2 = residual_block(uconv2,start_neurons * 4)\n#     uconv2 = residual_block(uconv2,start_neurons * 4)\n    uconv2 = LeakyReLU(alpha=0.1)(uconv2)\n    \n    deconv1 = Conv2DTranspose(start_neurons * 2, (3, 3), strides=(2, 2), padding=\"same\")(uconv2)\n    conv1 = backbone.layers[30].output\n    uconv1 = concatenate([deconv1,deconv2_up1,deconv3_up2,deconv4_up3, conv1])\n    \n    uconv1 = Dropout(0.1)(uconv1)\n    uconv1 = Conv2D(start_neurons * 2, (3, 3), activation=None, padding=\"same\")(uconv1)\n    uconv1 = residual_block(uconv1,start_neurons * 2)\n#     uconv1 = residual_block(uconv1,start_neurons * 2)\n    uconv1 = LeakyReLU(alpha=0.1)(uconv1)\n    \n    uconv0 = Conv2DTranspose(start_neurons * 1, (3, 3), strides=(2, 2), padding=\"same\")(uconv1)   \n    uconv0 = Dropout(0.1)(uconv0)\n    uconv0 = Conv2D(start_neurons * 1, (3, 3), activation=None, padding=\"same\")(uconv0)\n    uconv0 = residual_block(uconv0,start_neurons * 1)\n#     uconv0 = residual_block(uconv0,start_neurons * 1)\n    uconv0 = LeakyReLU(alpha=0.1)(uconv0)\n    \n    uconv0 = Dropout(dropout_rate\/2)(uconv0)\n    output_layer = Conv2D(1, (1,1), padding=\"same\", activation=\"sigmoid\")(uconv0)    \n    \n    model = Model(input, output_layer)\n    model.name = 'u-xception'\n\n    return model","cb4a7eca":"K.clear_session()\nimg_size = 256\nmodel = UEfficientNet(input_shape=(img_size,img_size,3),dropout_rate=0.5)","c6971835":"model.summary()","e225ee4d":"class SWA(keras.callbacks.Callback):\n    \n    def __init__(self, filepath, swa_epoch):\n        super(SWA, self).__init__()\n        self.filepath = filepath\n        self.swa_epoch = swa_epoch \n    \n    def on_train_begin(self, logs=None):\n        self.nb_epoch = self.params['epochs']\n        print('Stochastic weight averaging selected for last {} epochs.'\n              .format(self.nb_epoch - self.swa_epoch))\n        \n    def on_epoch_end(self, epoch, logs=None):\n        \n        if epoch == self.swa_epoch:\n            self.swa_weights = self.model.get_weights()\n            \n        elif epoch > self.swa_epoch:    \n            for i in range(len(self.swa_weights)):\n                self.swa_weights[i] = (self.swa_weights[i] * \n                    (epoch - self.swa_epoch) + self.model.get_weights()[i])\/((epoch - self.swa_epoch)  + 1)  \n\n        else:\n            pass\n        \n    def on_train_end(self, logs=None):\n        self.model.set_weights(self.swa_weights)\n        print('Final model parameters set to stochastic weight average.')\n        self.model.save_weights(self.filepath)\n        print('Final stochastic averaged weights saved to file.')","2dc7b964":"model.compile(loss=bce_dice_loss, optimizer='adam', metrics=[my_iou_metric])","69ac71ca":"epochs = 70\nsnapshot = SnapshotCallbackBuilder(nb_epochs=epochs,nb_snapshots=1,init_lr=1e-3)\nbatch_size = 16\nswa = SWA('.\/keras_swa.model',67)\nvalid_im_path,valid_mask_path = '.\/keras_im_val','.\/keras_mask_val'\n# Generators\ntraining_generator = DataGenerator(augmentations=AUGMENTATIONS_TRAIN,img_size=img_size)\nvalidation_generator = DataGenerator(train_im_path = valid_im_path ,\n                                     train_mask_path=valid_mask_path,augmentations=AUGMENTATIONS_TEST,\n                                     img_size=img_size)\n\nhistory = model.fit_generator(generator=training_generator,\n                            validation_data=validation_generator,                            \n                            use_multiprocessing=False,\n                            epochs=epochs,verbose=2,\n                            callbacks=snapshot.get_callbacks())","a227a65e":"plt.figure(figsize=(16,4))\nplt.subplot(1,2,1)\nplt.plot(history.history['my_iou_metric'][1:])\nplt.plot(history.history['val_my_iou_metric'][1:])\nplt.ylabel('iou')\nplt.xlabel('epoch')\nplt.legend(['train','Validation'], loc='upper left')\n\nplt.title('model IOU')\n\nplt.subplot(1,2,2)\nplt.plot(history.history['loss'][1:])\nplt.plot(history.history['val_loss'][1:])\nplt.ylabel('val_loss')\nplt.xlabel('epoch')\nplt.legend(['train','Validation'], loc='upper left')\nplt.title('model loss')\ngc.collect()","eb2736ad":"# Load best model or swa model if not available\ntry:\n    print('using swa weight model')\n    model.load_weights('.\/keras_swa.model')\nexcept Exception as e:\n    print(e)\n    model.load_weights('.\/keras.model')","2f8779f5":"def predict_result(model,validation_generator,img_size): \n    # TBD predict both orginal and reflect x\n    preds_test1 = model.predict_generator(validation_generator).reshape(-1, img_size, img_size)\n    return preds_test1","3e66b0eb":"validation_generator = DataGenerator(train_im_path = valid_im_path ,\n                                     train_mask_path=valid_mask_path,augmentations=AUGMENTATIONS_TEST,\n                                     img_size=img_size,shuffle=False)\n\nAUGMENTATIONS_TEST_FLIPPED = Compose([\n    HorizontalFlip(p=1),\n    ToFloat(max_value=1)\n],p=1)\n\nvalidation_generator_flipped = DataGenerator(train_im_path = valid_im_path ,\n                                     train_mask_path=valid_mask_path,augmentations=AUGMENTATIONS_TEST_FLIPPED,\n                                     img_size=img_size,shuffle=False)\n\npreds_valid_orig = predict_result(model,validation_generator,img_size)\npreds_valid_flipped = predict_result(model,validation_generator_flipped,img_size)\npreds_valid_flipped = np.array([np.fliplr(x) for x in preds_valid_flipped])\npreds_valid = 0.5*preds_valid_orig + 0.5*preds_valid_flipped","31574a3a":"valid_fn = glob.glob('.\/keras_mask_val\/*')\ny_valid_ori = np.array([cv2.resize(np.array(Image.open(fn)),(img_size,img_size)) for fn in valid_fn])\nassert y_valid_ori.shape == preds_valid.shape","3b11c4cc":"threshold_best = 0.5\nmax_images = 64\ngrid_width = 16\ngrid_height = int(max_images \/ grid_width)\nfig, axs = plt.subplots(grid_height, grid_width, figsize=(grid_width, grid_height))\n\nvalidation_generator = DataGenerator(train_im_path = valid_im_path ,\n                                     train_mask_path=valid_mask_path,augmentations=AUGMENTATIONS_TEST,\n                                     img_size=img_size,batch_size=64,shuffle=False)\n\nimages,masks = validation_generator.__getitem__(0)\nfor i,(im, mask) in enumerate(zip(images,masks)):\n    pred = preds_valid[i]\n    ax = axs[int(i \/ grid_width), i % grid_width]\n    ax.imshow(im[...,0], cmap=\"bone\")\n    ax.imshow(mask.squeeze(), alpha=0.5, cmap=\"Reds\")    \n    ax.imshow(np.array(np.round(pred > threshold_best), dtype=np.float32), alpha=0.5, cmap=\"Greens\")\n    ax.axis('off')\nplt.suptitle(\"Green:Prediction , Red: Pneumothorax.\")","624d5fb8":"# src: https:\/\/www.kaggle.com\/aglotero\/another-iou-metric\ndef iou_metric(y_true_in, y_pred_in, print_table=False):\n    labels = y_true_in\n    y_pred = y_pred_in\n    \n    true_objects = 2\n    pred_objects = 2\n\n    intersection = np.histogram2d(labels.flatten(), y_pred.flatten(), bins=(true_objects, pred_objects))[0]\n\n    # Compute areas (needed for finding the union between all objects)\n    area_true = np.histogram(labels, bins = true_objects)[0]\n    area_pred = np.histogram(y_pred, bins = pred_objects)[0]\n    area_true = np.expand_dims(area_true, -1)\n    area_pred = np.expand_dims(area_pred, 0)\n\n    # Compute union\n    union = area_true + area_pred - intersection\n\n    # Exclude background from the analysis\n    intersection = intersection[1:,1:]\n    union = union[1:,1:]\n    union[union == 0] = 1e-9\n\n    # Compute the intersection over union\n    iou = intersection \/ union\n\n    # Precision helper function\n    def precision_at(threshold, iou):\n        matches = iou > threshold\n        true_positives = np.sum(matches, axis=1) == 1   # Correct objects\n        false_positives = np.sum(matches, axis=0) == 0  # Missed objects\n        false_negatives = np.sum(matches, axis=1) == 0  # Extra objects\n        tp, fp, fn = np.sum(true_positives), np.sum(false_positives), np.sum(false_negatives)\n        return tp, fp, fn\n\n    # Loop over IoU thresholds\n    prec = []\n    if print_table:\n        print(\"Thresh\\tTP\\tFP\\tFN\\tPrec.\")\n    for t in np.arange(0.5, 1.0, 0.05):\n        tp, fp, fn = precision_at(t, iou)\n        if (tp + fp + fn) > 0:\n            p = tp \/ (tp + fp + fn)\n        else:\n            p = 0\n        if print_table:\n            print(\"{:1.3f}\\t{}\\t{}\\t{}\\t{:1.3f}\".format(t, tp, fp, fn, p))\n        prec.append(p)\n    \n    if print_table:\n        print(\"AP\\t-\\t-\\t-\\t{:1.3f}\".format(np.mean(prec)))\n    return np.mean(prec)\n\ndef iou_metric_batch(y_true_in, y_pred_in):\n    batch_size = y_true_in.shape[0]\n    metric = []\n    for batch in range(batch_size):\n        value = iou_metric(y_true_in[batch], y_pred_in[batch])\n        metric.append(value)\n    return np.mean(metric)\n\nvalid_fn = glob.glob('.\/keras_mask_val\/*')\ny_valid_ori = np.array([cv2.resize(np.array(Image.open(fn)),(img_size,img_size)) for fn in valid_fn])\nassert y_valid_ori.shape == preds_valid.shape","aaf6eede":"## Scoring for last model\nthresholds = np.linspace(0.2, 0.9, 31)\nious = np.array([iou_metric_batch(y_valid_ori, np.int32(preds_valid > threshold)) for threshold in tqdm_notebook(thresholds)])","5d6663b2":"threshold_best_index = np.argmax(ious) \niou_best = ious[threshold_best_index]\nthreshold_best = thresholds[threshold_best_index]\n\nplt.plot(thresholds, ious)\nplt.plot(threshold_best, iou_best, \"xr\", label=\"Best threshold\")\nplt.xlabel(\"Threshold\")\nplt.ylabel(\"IoU\")\nplt.title(\"Threshold vs IoU ({}, {})\".format(threshold_best, iou_best))\nplt.legend()","7d6d4d8f":"max_images = 64\ngrid_width = 16\ngrid_height = int(max_images \/ grid_width)\nfig, axs = plt.subplots(grid_height, grid_width, figsize=(grid_width, grid_height))\n\nvalidation_generator = DataGenerator(train_im_path = valid_im_path ,\n                                     train_mask_path=valid_mask_path,augmentations=AUGMENTATIONS_TEST,\n                                     img_size=img_size,batch_size=64,shuffle=False)\n\nimages,masks = validation_generator.__getitem__(0)\nfor i,(im, mask) in enumerate(zip(images,masks)):\n    pred = preds_valid[i]\n    ax = axs[int(i \/ grid_width), i % grid_width]\n    ax.imshow(im[...,0], cmap=\"bone\")\n    ax.imshow(mask.squeeze(), alpha=0.5, cmap=\"Reds\")    \n    ax.imshow(np.array(np.round(pred > threshold_best), dtype=np.float32), alpha=0.5, cmap=\"Greens\")\n    ax.axis('off')\nplt.suptitle(\"Green:Prediction , Red: Pneumothorax.\")","4f9c5f1e":"test_fn = glob.glob('.\/test\/*')\nx_test = [cv2.resize(np.array(Image.open(fn)),(img_size,img_size)) for fn in test_fn]\nx_test = np.array(x_test)\nx_test = np.array([np.repeat(im[...,None],3,2) for im in x_test])\nprint(x_test.shape)\npreds_test_orig = model.predict(x_test,batch_size=batch_size)\n\nx_test = np.array([np.fliplr(x) for x in x_test])\npreds_test_flipped = model.predict(x_test,batch_size=batch_size)\npreds_test_flipped = np.array([np.fliplr(x) for x in preds_test_flipped])\n\npreds_test = 0.5*preds_test_orig + 0.5*preds_test_flipped\n\n# del x_test; gc.collect()","1865a448":"max_images = 64\ngrid_width = 16\ngrid_height = int(max_images \/ grid_width)\nfig, axs = plt.subplots(grid_height, grid_width, figsize=(grid_width, grid_height))\n# for i, idx in enumerate(index_val[:max_images]):\nfor i, idx in enumerate(test_fn[:max_images]):\n    img = x_test[i]\n    pred = preds_test[i].squeeze()\n    ax = axs[int(i \/ grid_width), i % grid_width]\n    ax.imshow(img, cmap=\"Greys\")\n    ax.imshow(np.array(np.round(pred > threshold_best).T, dtype=np.float32), alpha=0.5, cmap=\"Reds\")\n    ax.axis('off')","7aba0222":"import sys\nsys.path.insert(0, '..\/input\/siim-acr-pneumothorax-segmentation')\n\nfrom mask_functions import rle2mask,mask2rle\nimport pdb\n\n# Generate rle encodings (images are first converted to the original size)\nrles = []\ni,max_img = 1,10\nplt.figure(figsize=(16,4))\nfor p in tqdm_notebook(preds_test):\n    p = p.squeeze()\n    im = cv2.resize(p,(1024,1024))\n    im = im > threshold_best\n#     zero out the smaller regions.\n    if im.sum()<1024*2:\n        im[:] = 0\n    im = (im.T*255).astype(np.uint8)  \n    rles.append(mask2rle(im, 1024, 1024))\n    i += 1\n    if i<max_img:\n        plt.subplot(1,max_img,i)\n        plt.imshow(im)\n        plt.axis('off')","b95a8080":"ids = [o.split('\/')[-1][:-4] for o in test_fn]\nsub_df = pd.DataFrame({'ImageId': ids, 'EncodedPixels': rles})\nsub_df.loc[sub_df.EncodedPixels=='', 'EncodedPixels'] = '-1'\nsub_df.head()","0122fb02":"sub_df.to_csv('submission.csv', index=False)","ec6e06a0":"sub_df.tail(10)","7df9f076":"!rm -r *\/","4397f5ad":"# Defining UEfficientNet Model","0306c1cb":"# Some Test Set Predictions","3ed74e93":"# Train Set Images with Masks","04719b67":"# Loading Libraries","0d7cd2de":"# Define Learning Rate Scheduler\nusing cosine annealing for learning rate","f03851d7":"![image.png](attachment:image.png)","ac0575d5":"# Pneumothorax as percentage of mask","20dd9cb3":"# Useful Model Blocks","28f6d4de":"# Training Begins","67d3b146":"# Test Set Prediction","e1cddfed":"In this kernel I implement Unet Plus Plus with EfficientNet Encoder. Unet Plus Plus introduce intermediate layers to skip connections of U-Net, which naturally form multiple new up-sampling paths from different depths, ensembling U-Nets of various receptive fields. This results in far better performance than traditional Unet. \nFor more details please [refer] .( \"UNet++: A Nested U-Net Architecture for Medical Image Segmentation\" )\n\n- I have made some changes to the augmentation part. \n- I have added TTA.\n","7123f194":"# Calculating IOU","9dc07801":"# Predict the validation set to do a sanity check\nAgain plot some sample images including the predictions.","06fbfa67":"# Stochastic Weight Averaging\nI have found SWA to give better results. Please check out the paper for more info.","e6da2e16":"# Defining Dice Loss","82bf8f62":"# Loading Training Set Data\nAs mentioned earlier, I don't have international credit card so, I am using the data from this [kernel](https:\/\/www.kaggle.com\/iafoss\/data-repack-and-image-statistics)","7e337dd5":"# Plot some predictions for validation set images","955db92f":"# Images after Augmentations","5f5b799e":"As mentioned above, this model uses pretrained EfficientNetB4 model as encoder. I use Residual blocks in the decoder part."}}