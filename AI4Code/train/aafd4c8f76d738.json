{"cell_type":{"92f92422":"code","77b5f9dc":"code","592b9309":"code","44214c28":"code","fe4bf2da":"code","7aa214a5":"code","2551853c":"code","74b57e2a":"code","f6d41677":"code","6d2e65ee":"code","102e48e3":"code","03df9dde":"code","c32e7e10":"code","6cfa9f25":"code","9c468cf5":"code","4bc2e9a3":"code","19e70a50":"code","933a7b3d":"code","9dcbed95":"code","210e63c5":"code","012a958c":"code","ad139255":"code","3ea1cccc":"code","9f636026":"code","7a5b711d":"code","acbef609":"code","ecc00a7f":"code","0724816d":"code","de12aa3a":"markdown","190f2f50":"markdown","f8d4c39d":"markdown","8a292d65":"markdown","2f84425f":"markdown","dc2a0d48":"markdown","ba01e7b2":"markdown","1ee464bc":"markdown","99138576":"markdown","e9be80c8":"markdown","22bb8b40":"markdown"},"source":{"92f92422":"from IPython.core.display import display, HTML\ndisplay(HTML(\"<style>.container { width:80% !important; }<\/style>\"))","77b5f9dc":"import os\nimport json\nimport gc\n\nimport cv2\nimport keras\nfrom keras import backend as K\nfrom keras import layers\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.models import Model, load_model\nfrom keras.layers import Input\nfrom keras.layers.convolutional import Conv2D, Conv2DTranspose\nfrom keras.layers.pooling import MaxPooling2D\nfrom keras.layers.merge import concatenate\nfrom keras.optimizers import Adam\nfrom keras.callbacks import Callback, ModelCheckpoint\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom tqdm import tqdm\nfrom sklearn.model_selection import train_test_split","592b9309":"from pathlib import Path\nimport shutil\n\nINPUT_PATH = \"..\/input\"\n\nBOOTSTRAP = False\n\nDF_TRAIN_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection\/train.csv\")\nDF_TEST_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection\/sample_submission.csv\")\n\nTRAIN_IMAGE_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection\/train_images\")\nTEST_IMAGE_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection\/test_images\")\nDATA_PATH = os.path.join(INPUT_PATH, \"severstal-steel-defect-detection-data-files\")\n\nGENERATE_WEIGHTS = False\nUSE_CALLBACK = True\n\nEPOCHS = 16\nif BOOTSTRAP:\n    EPOCHS = 1\nCHANNELS = 3\n\nMODEL_NAME = \"model_single_segmentation.h5\"\n\ndata_dir_path = \"..\/input\/severstal-steel-defect-detection-data-files\"\nif os.path.exists(data_dir_path):\n    for fname in os.listdir(data_dir_path):\n        filepath = os.path.join(data_dir_path, fname)\n        print(filepath)\n        if os.path.isfile(filepath):\n            if GENERATE_WEIGHTS == True:\n                if fname.find(\"h5\") > 0:\n                    continue\n                if fname.find(\"json\") > 0:\n                    continue\n            destfilepath = os.path.join(\".\/\", fname)\n            print(\"copy file \", filepath, \" to \", destfilepath)\n            shutil.copy(filepath, destfilepath)\n                \n","44214c28":"train_df = pd.read_csv(DF_TRAIN_PATH, index_col=False)\ntrain_df.head()","fe4bf2da":"# make ImageId \/ ClassId \/ hasMask\nif \"ImageId_ClassId\" in list(train_df.columns):\n    train_df['ImageId'] = train_df['ImageId_ClassId'].apply(lambda x: x.split('_')[0])\n    train_df['ClassId'] = train_df['ImageId_ClassId'].apply(lambda x: x.split('_')[1])\ntrain_df.head()","7aa214a5":"'''\nadd rows with empty 'EncodedPixels' (same as old train.csv file)\n'''\nrows = []\nfor imageId in train_df['ImageId'].unique():\n    for i in range(4):        \n        exists = ((train_df['ImageId'] == imageId) & (train_df['ClassId'] == i + 1)).any()\n        if exists == False:\n            rows.append({'ImageId':imageId, 'ClassId':i+1, 'EncodedPixels':np.NaN})\n            \ntmp_df = pd.DataFrame(rows)\ntrain_df = pd.concat([train_df, tmp_df], ignore_index=True)\n\ntrain_df['hasMask'] = ~ train_df['EncodedPixels'].isna()\ntrain_df = train_df.sort_values(['ImageId', 'ClassId']).reset_index(drop=True)\n\ntrain_df.head(20)","2551853c":"# \uc774\ubbf8\uc9c0 \uc911\uc5d0 hasMask\uac00 \ud558\ub098\ub77c\ub3c4 \uc788\ub294 \uac83\uc744 \uad6c\ubd84\ud558\uae30 \uc704\ud574 ImageId\ub85c \uc815\ub82c\ud558\uace0\n# sum\uc744 \uc801\uc6a9\ud55c\ub2e4. \uc22b\uc790\uac00 \uc544\ub2cc column\uc740 \uc801\uc6a9\uc2dc \uc0ac\ub77c\uc9c4\ub2e4.\n\nmask_count_df = train_df.groupby('ImageId').agg(np.sum).reset_index()\nmask_count_df.sort_values('hasMask', ascending=False, inplace=True)\nmask_count_df = mask_count_df.drop('ClassId', axis=1)\nmask_count_df.head()","74b57e2a":"non_missing_train_idx = mask_count_df[mask_count_df['hasMask'] > 0]\nnon_missing_train_idx.head()","f6d41677":"def mask2rle(img):\n    '''\n    img: numpy array, 1 - mask, 0 - background\n    Returns run length as string formated\n    '''\n    pixels= img.T.flatten()\n    pixels = np.concatenate([[0], pixels, [0]])\n    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1\n    runs[1::2] -= runs[::2]\n    return ' '.join(str(x) for x in runs)\n\ndef rle2mask(rle, input_shape):\n    '''\n    rle: run-length as string formated (start length)\n    shape: (height, width) of array to return \n    Returns numpy array, 1 - mask, 0 - background\n    '''\n    height, width = input_shape[:2]\n    \n    mask= np.zeros(width * height).astype(np.uint8)\n    \n    \"\"\"    \n    RLE\uac00 (\uc2dc\uc791\uc810,\uae38\uc774)\uc758 \ubc18\ubcf5\uc774\ubbc0\ub85c, \uc9dd\uc218\/\ud640\uc218\ub85c \ubd84\ub9ac\ud574\uc11c \uc2dc\uc791\uc810 \ubc30\uc5f4\uacfc\n    \uae38\uc774 \ubc30\uc5f4\uc744 \ub9cc\ub4e0\ub2e4.\n    s[1:] : 1\ubd80\ud130 \ub05d\uae4c\uc9c0\n    s[1:][::2] : s[1:]\ubc30\uc5f4\uc5d0 2\uc529 \uac74\ub108\ub6f0\uba70 \ucd94\ucd9c\ud55c \uac12\ub4e4\uc758 \ubc30\uc5f4\uc744 \uc5bb\ub294\ub2e4.\n    \"\"\"\n    array = np.asarray([int(x) for x in rle.split()])\n    starts = array[0::2]\n    lengths = array[1::2]\n    \n    for index, start in enumerate(starts):\n        begin = int(start - 1)\n        end = int(begin + lengths[index])        \n        mask[begin : end] = 1\n        \n    \"\"\"    \n    img\uc758 pixel \uc21c\uc11c\ub294 \uc88c\uce21 \uc138\ub85c\uc904\ubd80\ud130 \uc704\uc5d0\uc11c \uc544\ub798\ucabd\uc73c\ub85c \uc774\uc5b4\uc9c0\ubbc0\ub85c \uc21c\uc11c\uc5d0 \ub9de\uac8c\n    \ub9cc\ub4e4\uc5b4\uc11c \ub118\uaca8\uc57c \ud55c\ub2e4.\n    width\/height\ub294 \ud589\uacfc \uc5f4\uc5d0 \ub9de\uac8c [height, width, ...] \ub85c \ub9cc\ub4e4\uc5b4\uc57c \ud55c\ub2e4.\n\n    ex) width=4, height=3\uc778 \uacbd\uc6b0\n    \n    s = [1,2,3,4,5,6,7,8,9,10,11,12]\n        => 1,2,3\uc774 \uc88c\uce21 \uccab\ubc88\uca68 \uc138\ub85c\uc904, 4,5,6\uc740 \ub450\ubc88\uc9f8 \uc904\n\n    s.reshape(4,3) :\n    [[ 1  2  3]\n     [ 4  5  6]\n     [ 7  8  9]\n     [10 11 12]]\n\n    s.reshape(4,3).T :\n    [[ 1  4  7 10]\n     [ 2  5  8 11]\n     [ 3  6  9 12]]\n    \"\"\"\n    return mask.reshape(width, height).T\n\n# https:\/\/www.kaggle.com\/titericz\/building-and-visualizing-masks\ndef mask2contour(mask, width=3):\n    # CONVERT MASK TO ITS CONTOUR\n    w = mask.shape[1]\n    h = mask.shape[0]\n    mask2 = np.concatenate([mask[:,width:],np.zeros((h,width))],axis=1)\n    mask2 = np.logical_xor(mask,mask2)\n    mask3 = np.concatenate([mask[width:,:],np.zeros((width,w))],axis=0)\n    mask3 = np.logical_xor(mask,mask3)\n    return np.logical_or(mask2,mask3) \n\ndef mask2pad(mask, pad=2):\n    # ENLARGE MASK TO INCLUDE MORE SPACE AROUND DEFECT\n    w = mask.shape[1]\n    h = mask.shape[0]\n    \n    # MASK UP\n    for k in range(1,pad,2):\n        temp = np.concatenate([mask[k:,:],np.zeros((k,w))],axis=0)\n        mask = np.logical_or(mask,temp)\n    # MASK DOWN\n    for k in range(1,pad,2):\n        temp = np.concatenate([np.zeros((k,w)),mask[:-k,:]],axis=0)\n        mask = np.logical_or(mask,temp)\n    # MASK LEFT\n    for k in range(1,pad,2):\n        temp = np.concatenate([mask[:,k:],np.zeros((h,k))],axis=1)\n        mask = np.logical_or(mask,temp)\n    # MASK RIGHT\n    for k in range(1,pad,2):\n        temp = np.concatenate([np.zeros((h,k)),mask[:,:-k]],axis=1)\n        mask = np.logical_or(mask,temp)\n    \n    return mask \n\ndef build_masks(rles, input_shape):\n    \"\"\"transfer run-length-encoding strings to mask image array\n    \n    Args:\n        rles : array of rle string\n        input_shape : mask shape\n        \n    Returns:\n        (h, w, 5) mask array\n    \"\"\"\n    depth = 5\n    masks = np.zeros((*input_shape, depth))\n\n    assert len(rles) == 4    \n    \n    for i, rle in enumerate(rles):\n        if type(rle) is str:\n            masks[:, :, i] = rle2mask(rle, input_shape)\n\n    #print(\"masks.shape \", masks.shape)\n    m2 = np.sum(masks, axis=-1).astype('bool')\n    m2 = np.logical_not(m2).astype('int')\n    m2 = m2.reshape(input_shape[0], input_shape[1], 1)\n    \n    #print(\"masks.shape = \", masks.shape, \"m2.shape\",  m2.shape)\n    masks[:, :, 4] = m2.reshape(input_shape) #masks.shape =  (256, 1600, 5) m2.shape (256, 1600, 1)\n    \n    return masks #(256, 1600, 4)\n\ndef build_rles(masks):\n    width, height, depth = masks.shape\n    \n    rles = [mask2rle(masks[:, :, i])\n            for i in range(depth)]\n    \n    return rles\n","6d2e65ee":"columns = 1\nrows = 8\nfig = plt.figure(figsize=(10,5 * rows))\ndf = train_df\nimport math\n\ngrp = mask_count_df['ImageId'].values\n\nax_idx = 1\nfor filename in grp:\n    if ax_idx > rows * columns * 2:\n        break\n    \n    subdf = df[df['ImageId'] == filename].reset_index()\n    row = ax_idx\n    col = 0\n    fig.add_subplot(rows * 2, columns, ax_idx).set_title(filename)\n\n    # show defect mask\n    img = cv2.imread(os.path.join(TRAIN_IMAGE_PATH, filename ))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    for _, row in subdf.iterrows():        \n        pixels = str(row['EncodedPixels'])\n        if pixels != 'nan' and len(pixels) > 10:\n            #print(row['EncodedPixels'], type(row['EncodedPixels']))\n            mask = rle2mask(row['EncodedPixels'], (256,1600))\n            mask = mask2pad(mask,pad=3)\n            mask = mask2contour(mask,width=4)\n            # print(img.shape, mask.shape)\n            classId = int(row['ClassId'])\n            img[mask == 1, classId % 3] = 255\n    plt.imshow(img)\n    ax_idx += 1\n\n    # show non-defect mask\n    fig.add_subplot(rows * 2, columns, ax_idx).set_title(filename + \" - no mask\")\n    img = cv2.imread(os.path.join(TRAIN_IMAGE_PATH, filename ))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\n    rles = subdf['EncodedPixels'].values # 1\uac1c\uc758 \uc774\ubbf8\uc9c0\ub9c8\ub2e4 4\uac1c\uc529 \uc788\uc74c(\ub300\ubd80\ubd84 \ube44\uc5b4\uc788\uc74c)\n    masks = build_masks(rles, input_shape=(256,1600)) #(256, 1600, 4)\n\n    no_defect_mask = masks[:, :, 4] # set defect mask\n    # print(\"img.shape:\", img.shape)\n    # print(\"no_defect_mask.shape:\", no_defect_mask.shape)\n    # print(masks.shape, no_defect_mask.shape)\n    img[no_defect_mask == 1, 0] = 255\n    plt.imshow(img)\n    ax_idx += 1\n    \nplt.show()","102e48e3":"class DataGenerator(keras.utils.Sequence):\n    'Generates data for Keras'\n    def __init__(self, list_IDs, df, target_df=None, mode='fit',\n                 base_path=TRAIN_IMAGE_PATH,\n                 batch_size=32, dim=(256, 1600), n_channels=CHANNELS,\n                 n_classes=4, random_state=2019, shuffle=True):\n        self.dim = dim\n        self.batch_size = batch_size\n        self.df = df\n        self.mode = mode\n        self.base_path = base_path\n        self.target_df = target_df # ImageId\ub85c label(4 masks)\uc744 \uac00\uc838\uc62c \ub54c \uc0ac\uc6a9\ud55c\ub2e4.\n        self.list_IDs = list_IDs # df.index\n        self.n_channels = n_channels\n        self.n_classes = n_classes\n        self.shuffle = shuffle\n        self.random_state = random_state\n        \n        self.on_epoch_end()\n\n    ##########################################################\n    # DataGenerator Sub Methods:\n    ##########################################################\n    def __len__(self):\n        'Denotes the number of batches per epoch'\n\n        # \uac2f\uc218\uac00 \ube60\uc9c8\ub4ef.\n        ret = 0\n        if (len(self.list_IDs) % self.batch_size) > 0:\n            ret = int(len(self.list_IDs) \/ self.batch_size) + 1\n        else:\n            ret = int(np.floor(len(self.list_IDs) \/ self.batch_size))\n        \n        return ret\n\n    def __getitem__(self, index):\n        'Generate one batch of data'\n        \"\"\"\n        batch \ud558\ub098\uc5d0 \ud574\ub2f9\ud558\ub294 \ub370\uc774\ud130(train\uc774\uba74 X,y, predict\uba74 X \ub9cc)\ub97c \ub9cc\ub4e4\uc5b4\uc11c \ub9ac\ud134\ud55c\ub2e4.        \n        \"\"\"\n        # Generate indexes of the batch\n        start = index * self.batch_size\n        end = min(len(self.list_IDs), (index + 1) * self.batch_size)\n        #print(\"start\/end = \", start, end)\n        #indexes = self.indexes[index*self.batch_size : (index+1)*self.batch_size]\n        indexes = self.indexes[start : end]\n\n\n        # Find list of IDs\n        list_IDs_batch = [self.list_IDs[k] for k in indexes]        \n        #print(\"list_IDs_batch :\", list_IDs_batch)\n        X = self.__generate_X(list_IDs_batch)\n        # X.shape : (16, 256, 1600, 1)\n        \n        if self.mode == 'fit':\n            y = self.__generate_y(list_IDs_batch)\n            return X, y\n        \n        elif self.mode == 'predict':\n            return X\n\n        else:\n            raise AttributeError('The mode parameter should be set to \"fit\" or \"predict\".')\n\n        \n    def on_epoch_end(self):        \n        'Updates indexes after each epoch'        \n        self.indexes = np.arange(len(self.list_IDs)) # \uadf8\ub0e5 0 ~ n\uae4c\uc9c0 \ubc30\uc5f4\n        if self.shuffle == True:\n            np.random.seed(self.random_state)\n            np.random.shuffle(self.indexes)\n    ##########################################################\n    \n    \n    def __generate_X(self, list_IDs_batch):\n        'Generates data containing batch_size samples'\n        # Initialization\n        X = np.empty((len(list_IDs_batch), *self.dim, self.n_channels)) #(?, h, w, \ucc44\ub110\uc218(1))\n        \n        # Generate data\n        for i, ID in enumerate(list_IDs_batch):            \n            im_name = self.df['ImageId'].loc[ID]\n            img_path = f\"{self.base_path}\/{im_name}\"\n            #img = self.__load_grayscale(img_path)\n            img = self.__load_rgb(img_path)\n\n            #print(\"im_name\", im_name)\n            \n            # Store samples\n            X[i,] = img\n\n        return X\n    \n    def __generate_y(self, list_IDs_batch):\n        y = np.empty((len(list_IDs_batch), *self.dim, self.n_classes), dtype=int)\n        \n        for i, ID in enumerate(list_IDs_batch):\n            im_name = self.df['ImageId'].loc[ID]\n            image_df = self.target_df[self.target_df['ImageId'] == im_name]\n            \n            # y\uac12\uc740 RLE\ub97c \uc77d\uace0 mask\ub85c \ub9cc\ub4e4\uc5b4\uc11c \uc0ac\uc6a9\n            rles = image_df['EncodedPixels'].values # 1\uac1c\uc758 \uc774\ubbf8\uc9c0\ub9c8\ub2e4 4\uac1c\uc529 \uc788\uc74c(\ub300\ubd80\ubd84 \ube44\uc5b4\uc788\uc74c)\n            masks = build_masks(rles, input_shape=self.dim) #(256, 1600, 5)\n            \n            y[i, ] = masks\n        \n        return y #(batch_size, 256, 1600, 5)\n    \n    def __load_grayscale(self, img_path):\n        \"\"\"\n        load image as grayscale\n        \"\"\"\n        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)\n        img = img.astype(np.float32) \/ 255.        \n        img = np.expand_dims(img, axis=-1) # [h, w] => [h, w, 1]\n\n        return img\n    \n    def __load_rgb(self, img_path):\n        img = cv2.imread(img_path)\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        img = img.astype(np.float32) \/ 255.\n\n        return img","03df9dde":"TEST_INDEX = 16\n\n# TEST :\n\ndef test_DataGenerator_src(index = 0):\n    BATCH_SIZE = 4    \n    rows = BATCH_SIZE\n    columns = 1\n    \n    train_idx = non_missing_train_idx.index\n\n    fig = plt.figure(figsize=(12, BATCH_SIZE * 6))    \n\n    ax_idx = 1\n    for i in range(BATCH_SIZE):\n        if ax_idx > rows * columns * 2:\n            break\n\n        cur_row = mask_count_df.loc[train_idx[BATCH_SIZE * index + i]]\n        filename = cur_row['ImageId']        \n        image_df = train_df[train_df['ImageId'] == filename] # ImageId\ub9c8\ub2e4 4\uac1c\uc529 \uc788\uc74c.\n        image_df = image_df.fillna(\"\")\n\n        fig.add_subplot(rows * 2, columns, ax_idx).set_title(filename)\n        img = cv2.imread(os.path.join(TRAIN_IMAGE_PATH, filename ))\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        \n        for _, row in image_df.iterrows():\n            #print(\"row['EncodedPixels']\", type(row['EncodedPixels']), row['EncodedPixels'])\n            if len(str(row['EncodedPixels'])) > 0 :\n                mask = rle2mask(row['EncodedPixels'], (256,1600))\n                mask = mask2pad(mask,pad=3)\n                mask = mask2contour(mask,width=4)\n                classId = int(row['ClassId'])\n                img[mask == 1, (classId - 1) % 3] = 255                \n        plt.imshow(img)\n        ax_idx += 1\n\n        fig.add_subplot(rows * 2, columns, ax_idx).set_title(filename + \"- no defect\")\n        img = cv2.imread(os.path.join(TRAIN_IMAGE_PATH, filename ))\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        masks = build_masks(image_df['EncodedPixels'].values, input_shape=(256,1600))\n        non_defect_mask = masks[:, :, 4]\n        img[non_defect_mask > 0, 0] = 255\n        plt.imshow(img)\n        ax_idx += 1\n        \n    plt.show()\n    \ntest_DataGenerator_src(TEST_INDEX)","c32e7e10":"# TEST :\n\ndef test_DataGenerator(index = 0):\n    BATCH_SIZE = 4\n\n    rows = BATCH_SIZE\n    columns = 1    \n    \n    train_idx = non_missing_train_idx.index\n\n    fig = plt.figure(figsize=(12, BATCH_SIZE * 6))\n\n    gen = DataGenerator(\n        train_idx,\n        df=mask_count_df,\n        target_df=train_df,\n        batch_size=BATCH_SIZE, \n        n_classes=5,\n        shuffle = False)\n\n    X, y = gen.__getitem__(index)\n\n    print(\"X.shape :\", X.shape)\n    print(\"y.shape :\", y.shape)    \n\n    ax_idx = 1\n    for i in range(BATCH_SIZE):\n        if ax_idx > rows * columns * 2:\n            break\n            \n        img = X[i]\n        img = img * 255\n        img = img.astype(int)\n\n        fig.add_subplot(rows * 2, columns, ax_idx).set_title(str(i) + \"- source image\")\n\n        for mask_index in range(4):\n            mask = y[i, :, :, mask_index]\n            mask = mask2pad(mask,pad=3)\n            mask = mask2contour(mask,width=4)\n            y[i, :, :, mask_index] = mask\n            k = y[i, :, :, mask_index]            \n            img[k == 1, mask_index % 3] = 255        \n        plt.imshow(img)\n        ax_idx += 1\n\n        fig.add_subplot(rows * 2, columns, ax_idx).set_title(str(i) + \"- mask area\")\n        img = X[i]\n        img = img * 255\n        img = img.astype(int)\n        no_defect_mask = y[i, :, :, 4]\n        img[no_defect_mask > 0, 0] = 255\n        plt.imshow(img)\n        ax_idx += 1\n        \n    plt.show()\n\n    \ntest_DataGenerator(TEST_INDEX)","6cfa9f25":"# make image generators \n\nBATCH_SIZE = 4\n\ntrain_idx, val_idx = train_test_split(\n    mask_count_df.index, # \ubaa8\ub4e0 \ud30c\uc77c\uc744 \uc785\ub825\uc73c\ub85c \uc0ac\uc6a9\ud574\uc57c \ud558\ubbc0\ub85c non_missing_train_idx.index\ub97c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uc74c\n    random_state=2019,\n    test_size=0.15\n)\n\ntrain_generator = DataGenerator(\n    train_idx,\n    df=mask_count_df,\n    target_df=train_df,\n    batch_size=BATCH_SIZE,\n    n_classes=5)\n\nval_generator = DataGenerator(\n    val_idx,\n    df=mask_count_df,\n    target_df=train_df,\n    batch_size=BATCH_SIZE,\n    n_classes=5)","9c468cf5":"def dice_coef(y_true, y_pred, smooth=1):\n    print(y_true.shape, y_pred.shape)\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = K.sum(y_true_f * y_pred_f)\n    return (2. * intersection + smooth) \/ (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)","4bc2e9a3":"# https:\/\/github.com\/qubvel\/segmentation_models\n\n! pip install segmentation-models","19e70a50":"import segmentation_models as sm\nfrom segmentation_models import Unet\nimport keras\n\ndef build_model():\n\n    # class\ub294 5\uac00 \ub418\uc5b4\uc57c \ud558\uace0, activation -> softmax, loss : cross entropy\n    preprocess = sm.get_preprocessing('resnet34')\n    model = Unet(backbone_name='resnet34', input_shape=(256,1600, 3), classes=5, activation='softmax')\n    \n    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['acc'])\n    print(\"Model Input => Output : \", model.input_shape, \" ======> \", model.output_shape)\n\n    #model.summary()\n\n    return model\n\nmodel = build_model()\n\nmodel.summary()","933a7b3d":"def get_pretrained_model():\n    \"\"\"\n    get model with loaded weight & json model file\n    \"\"\"\n    model_json_file_name = MODEL_NAME.split('.')[0] + \".json\"\n    json_file = open(model_json_file_name, \"r\")\n    loaded_model_json = json_file.read()\n    json_file.close()\n    loaded_model = model_from_json(loaded_model_json)\n    loaded_model.load_weights(MODEL_NAME)\n    loaded_model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['acc'])\n    print(\"Loaded Model Input => Output : \", loaded_model.input_shape, \" ======> \", loaded_model.output_shape)\n    return loaded_model\n    ","9dcbed95":"from keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau, LambdaCallback\n\nes = EarlyStopping(monitor='val_acc', min_delta=0, patience = 3, verbose=1, mode='max')\n\nrl = ReduceLROnPlateau(monitor = 'val_acc', factor = 0.5, patience = 2,\n                       min_lr=0.0000001,\n                       verbose=1, \n                       mode='max')\n\ncheckpoint = ModelCheckpoint(\n    MODEL_NAME,\n    monitor='val_acc',\n    verbose=1,\n    save_best_only=True,\n    save_weights_only=False,\n    mode='max')\n\nif GENERATE_WEIGHTS:\n    history = None\n    \n    history = model.fit_generator(\n        train_generator,\n        validation_data=val_generator,\n        callbacks=[es, rl, checkpoint],\n        use_multiprocessing=False,\n        workers=1,\n        epochs=EPOCHS)\n    \n    # save model as json file\n    # weight is already stored by callback(checkpoint)\n    model_json = model.to_json()\n    model_json_file_name = MODEL_NAME.split('.')[0] + \".json\"\n    with open(model_json_file_name, \"w\") as json_file: \n        json_file.write(model_json)\n    \n    hdf = pd.DataFrame(history.history)\n    hdf[['loss', 'val_loss']].plot()\n    hdf[['acc', 'val_acc']].plot()\n    #hdf[['dice_coef', 'val_dice_coef']].plot()\n    \n","210e63c5":"from keras.models import model_from_json\n\n# model = build_model()\n# model.load_weights(MODEL_NAME)\nmodel = get_pretrained_model()\n\ncheck_df = mask_count_df.sample(10)\n\ngen = DataGenerator(\n        check_df.index,\n        df=mask_count_df,\n        target_df=train_df,\n        batch_size=BATCH_SIZE, \n        n_classes=5,\n        shuffle=False)\n\npredict = model.predict_generator(gen)","012a958c":"def get_one_hot(targets, nb_classes):    \n    res = np.eye(nb_classes)[np.array(targets).reshape(-1)] # flatten pixels and ont-hot encode\n    return res.reshape(list(targets.shape)+[nb_classes]) # restore shape(plus add ont-hot dimension)\n\ndef pred_to_onehot(pred, nb_classes=5):\n    retval = np.argmax(pred, axis=-1)\n    retval = get_one_hot(retval.reshape(-1), nb_classes)\n    retval = retval.reshape(pred.shape)\n    return retval","ad139255":"pred = pred_to_onehot(predict)\n\nrows = 10\ncolumns = 1\n\nfig = plt.figure(figsize=(12, 6 * rows))\n\nax_idx=1\nfor index, bindex, in enumerate(check_df.index):\n    if ax_idx > rows * columns * 2:\n        break\n            \n    fname = check_df['ImageId'].loc[bindex]\n    image_df = train_df[train_df['ImageId'] == fname]\n\n    fig.add_subplot(rows * 2, columns, ax_idx).set_title(fname + \" - source image\")\n    img = cv2.imread(os.path.join(TRAIN_IMAGE_PATH, fname ))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    plt.imshow(img)\n    ax_idx += 1\n\n    fig.add_subplot(rows * 2, columns, ax_idx).set_title(fname + \" - prediction\")\n    for mask_index in range(4):\n        mask = pred[index, :, :, mask_index]        \n        img[mask == 1, mask_index % 3] = 255\n    plt.imshow(img)\n    ax_idx += 1\n\nplt.show()","3ea1cccc":"def get_test_imgs_df():\n    \"\"\"build test image DataFrame from test image directory\"\"\"\n    test_df = []\n    for fname in os.listdir(TEST_IMAGE_PATH):\n        test_df.append(fname)        \n\n    test_df = pd.DataFrame({'ImageId' : test_df, 'EncodedPixels' : ''})    \n    ret = test_df[['ImageId']].reset_index()\n    return ret\n\n\ndef get_test_df():\n    \"\"\"build image mask DataFrame\"\"\"\n    test_df = []\n    for fname in os.listdir(TEST_IMAGE_PATH):\n        filepath = os.path.join(TEST_IMAGE_PATH, fname)    \n        if os.path.isfile(filepath):\n            for i in range(4):\n                img_cls = fname + \"_\" + str(i + 1)\n                test_df.append(img_cls)\n    \n    test_df = pd.DataFrame({'ImageId_ClassId' : test_df, 'EncodedPixels' : ''})\n    test_df['ImageId'] = test_df['ImageId_ClassId'].apply(lambda x: x.split('_')[0])\n    test_df['ClassId'] = test_df['ImageId_ClassId'].apply(lambda x: x.split('_')[1])\n    test_df['EncodedPixels'] = \"\"\n    test_df.reset_index()\n    \n    return test_df","9f636026":"#######################################################################################\n# FIXME : TEST CODE:\n#######################################################################################\n\nfrom keras.backend import clear_session\nimport gc\n\ndef show_test_prediction_head(n=60):\n\n    # Reset Keras Session\n    def clear_memory():\n        clear_session()\n        for i in range(20):\n            gc.collect()\n\n    clear_memory()\n    TEST_BATCH_SIZE = n\n\n    test_df = get_test_df()\n    test_images_df = get_test_imgs_df()    \n\n    batch_idx = list(range(0, min(test_images_df.shape[0], TEST_BATCH_SIZE)))\n    print(\"running: \", 0, \" - \", min(test_images_df.shape[0], TEST_BATCH_SIZE))\n\n#     model = build_model()\n#     model.load_weights(MODEL_NAME)\n    model = get_pretrained_model()\n    \n    test_generator = DataGenerator(\n        batch_idx,\n        df=test_images_df,\n        base_path = TEST_IMAGE_PATH,\n        target_df=test_df, #label mask\ub97c \ub9cc\ub4e4 \ub54c \uc0ac\uc6a9\ud558\ub294 DataFrame. mode = 'predict' \uc778 \uacbd\uc6b0 \ud544\uc694\uc5c6\uc74c.\n        mode = 'predict',\n        batch_size=TEST_BATCH_SIZE,\n        shuffle=False,\n        n_classes=5)\n\n    src_generator = DataGenerator(\n        batch_idx,\n        df=test_images_df,\n        base_path = TEST_IMAGE_PATH,\n        target_df=test_df,\n        batch_size=TEST_BATCH_SIZE,\n        shuffle=False,\n        n_classes=5)\n\n    X, _ = src_generator.__getitem__(0)\n    \n    # make prediction\n    predict = model.predict_generator(test_generator)\n    pred = pred_to_onehot(predict)\n\n    columns = 1\n    rows = TEST_BATCH_SIZE\n    fig = plt.figure(figsize=(12, 3 * rows))\n\n    ax_idx = 1\n    for i in range(rows):\n        if ax_idx > rows * columns:\n            break\n            \n        # add plot\n        fig.add_subplot(rows, columns, ax_idx).set_title(str(i))\n        \n        # source image\n        img = X[i]\n        img = img * 255\n        img = img.astype(int)    \n\n        # draw mask over image\n        for mask_index in range(4):\n            k = pred[i, :, :, mask_index]            \n            img[k == 1, mask_index % 3] = 255\n        plt.imshow(img)\n        ax_idx += 1\n\n    plt.show()\n\n# show_test_prediction_head()\n\n#######################################################################################","7a5b711d":"from keras.backend import clear_session\nimport gc\n\n# Reset Keras Session\ndef clear_memory():\n    clear_session()\n    for i in range(20):\n        gc.collect()\n\nclear_memory()\n\nTEST_BATCH_SIZE = 100\ndf_submit = []\nMIN_MASK_PIXEL_THRESHOLD = 3500\n\ntest_df = get_test_df()\ntest_images_df = get_test_imgs_df()\n\n# \ud558\ub098\uc758 \uc774\ubbf8\uc9c0\ub9c8\ub2e4 \ub3d9\uc77c \ud06c\uae30\uc758 5\uac1c mask \uc774\ubbf8\uc9c0\uac00 \uc0dd\uc131\ub418\uae30 \ub54c\ubb38\uc5d0\n# \uba54\ubaa8\ub9ac \uc18c\ube44\uac00 \ucee4\uc11c \ub098\ub220\uc11c \ucc98\ub9ac\ud574\uc57c \ud55c\ub2e4.\nfor batch_start in range(0, test_images_df.shape[0], TEST_BATCH_SIZE):\n    batch_idx = list(range(batch_start, min(test_images_df.shape[0], batch_start + TEST_BATCH_SIZE)))\n    print(\"running: \", batch_start, \" - \", min(test_images_df.shape[0], batch_start + TEST_BATCH_SIZE))\n\n    model = get_pretrained_model()\n\n    test_generator = DataGenerator(\n        batch_idx,\n        df=test_images_df,\n        base_path = TEST_IMAGE_PATH,\n        target_df=test_df,\n        mode = 'predict',\n        batch_size=BATCH_SIZE,\n        shuffle=False,\n        n_classes=5)\n    \n    predict = model.predict_generator(test_generator)\n    pred = pred_to_onehot(predict)\n\n    for index, bindex, in enumerate(batch_idx):\n        fname = test_images_df['ImageId'].loc[bindex]\n        image_df = test_df[test_df['ImageId'] == fname]\n\n        pred_masks = pred[index, ]\n        #print(\"pred_masks.shape :\", pred_masks.shape)\n\n        # threshold \uc774\ud558 pixel \uc218\ub294 \ubaa8\ub450 \uc5c6\uc564\ub2e4.\n        for mask_index in range(4):\n            pixelcnt = np.count_nonzero(pred_masks[:,:,mask_index])        \n            if pixelcnt < MIN_MASK_PIXEL_THRESHOLD:\n                pred_masks[:,:,mask_index] = 0\n\n        pred_masks = pred_masks[:, :, :-1] # drop non-defect mask values\n        pred_rles = build_rles(pred_masks)\n        image_df['EncodedPixels'] = pred_rles        \n        df_submit.append(image_df)\n    \n    clear_memory()\n\ndf_submit = pd.concat(df_submit)\nprint(df_submit.shape[0])\ndf_submit.head()","acbef609":"df_temp = df_submit\n\ndf_temp['maskPixelCount'] = df_temp['EncodedPixels'].map(str).apply(len)\ndf_temp = df_temp.sort_values(['maskPixelCount'], ascending=[False])\ndf_temp = df_temp.reset_index()\n\ncolumns = 1\nrows = 40\nfig = plt.figure(figsize=(12, 6 * rows))\n\nax_idx = 1\nfor index, row in df_temp.iterrows():\n    if ax_idx > rows * columns:\n        break\n\n    #print(\"index:\", index, \"imageid\", row[\"ImageId\"], \"class\", row[\"ClassId\"])\n\n    filename = row['ImageId']\n    fig.add_subplot(rows, columns, ax_idx).set_title(filename)\n    img = cv2.imread(os.path.join(TEST_IMAGE_PATH, filename))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    \n    mask = rle2mask(row['EncodedPixels'], (256,1600))\n    img[mask == 1, 0] = 255\n            \n    plt.imshow(img)\n    ax_idx += 1\n        \nplt.show()\n","ecc00a7f":"df_submit.head(20)","0724816d":"df_submit[['ImageId_ClassId', 'EncodedPixels']].to_csv('submission.csv', index=False)","de12aa3a":"\ucd9c\ub825\ub41c 5\uac1c\uc758 mask \uc774\ubbf8\uc9c0\uc758 \uac01\uac01\uc758 pixel\uc744 one-hot encoding \uacb0\uacfc\ub85c \uac04\uc8fc\ud574\uc11c max\uac12\uc744 1\ub85c, \uadf8 \uc678\uc5d0\ub294 0\uc73c\ub85c \ubc14\uafd4\uc8fc\ub294 \ud568\uc218","190f2f50":"## Modeling\n\nUNet \ubaa8\ub378\uc744 \uc0ac\uc6a9(base\ub294 resnet34)\ud574\uc11c \ubaa8\ub378\uc744 \ub9cc\ub4e0\ub2e4.\n\n>input  : (256, 1600, 3) <br>\n>output : (256, 1600, 5)\n\nU-Net \ubaa8\ub378 :<br>\n<img src=\"https:\/\/www.depends-on-the-definition.com\/wp-content\/uploads\/2018\/07\/unet-945x369.png\">\n\ntrain \ub370\uc774\ud130\ub97c \ubcf4\uba74 defect \uc601\uc5ed\uc740 \uacb9\uce58\uc9c0 \uc54a\ub294 \uac83\uc73c\ub85c \ubcf4\uc774\ubbc0\ub85c \ud574\ub2f9 \ubb38\uc81c\ub97c \uac01\uac01\uc758 pixel\uc5d0 \ub300\ud55c classification \ubb38\uc81c\ub85c \ubc14\uafd4\ubcfc \uc218 \uc788\ub2e4.\n\n0\/1\/2\/3\uc758 defect \uc885\ub958\uc640 no_defect\ub97c \ud45c\ud604\ud558\ub294 mask\uae4c\uc9c0 \ud569\uccd0\uc11c \ucd9c\ub825\uc774 5\uac1c\uc758 channel\uc774 \ub418\ub3c4\ub85d \ubaa8\ub378\uc744 \uad6c\uc131\ud55c\ub2e4.\n\n\uac01\uac01\uc758 pixel \ucd9c\ub825\uc744 category \uc218\uac00 5\uc778 classification \ubb38\uc81c\ub85c \ubcc0\ud615\ud558\ub294 \uac83\uc774\ub2e4.\n","f8d4c39d":"If mask pixel count is below certain threshold, consider it as no-defect.\n\nSubmission sets all 'EncodedPixels' empty scores above 0.85, it's a good idea to actively exclude false positive.","8a292d65":"# Severstal: Steel Defect Detection : 1-Pass Segmentation Model Only\n\n### About this kernel:\n\n- This is 1-Pass Segmentation-only notebook.\n- 5 classification(0 ~ 3 defect, 4 non-defect) model","2f84425f":"## EDA","dc2a0d48":"pandas.DataFrame\uc5d0\uc11c mask image\ub97c \uc0dd\uc131\ud558\ub294 generator.\nkeras.utils.Sequence\ub97c \uc0c1\uc18d\ud574\uc11c custom DataGenerator\ub97c \uc0dd\uc131\ud55c\ub2e4.\n\n\ub2e4\uc74c \uba54\uc18c\ub4dc \uad6c\ud604\uc774 \ud544\uc694\ud558\ub2e4.\n\n- def __len__(self):\n    - 1 epoch\ub2f9 batch\uc758 \uc218\n- def __getitem__(self, index):\n    - \ud574\ub2f9 index batch\uc758 \ub370\uc774\ud130(X, y)\ub97c \ub9ac\ud134\ud55c\ub2e4.\n- def on_epoch_end(self):\n    - \uac01 epoch\uc774 \ub05d\ub0a0 \ub54c\ub9c8\ub2e4 \ud638\ucd9c\ub41c\ub2e4. ","ba01e7b2":"Show image with defect mask","1ee464bc":"\uc0dd\uc131 \uc644\ub8cc\ub41c \ubaa8\ub378\uc744 \uc0ac\uc6a9\ud574\uc11c train\/submit \uc774\ubbf8\uc9c0\ub97c inference\ud55c \uacb0\uacfc\ub97c \ucd9c\ub825\ud574 \ubcf8\ub2e4.","99138576":"## RLE functions\n\npad & contour functions from https:\/\/www.kaggle.com\/titericz\/building-and-visualizing-masks","e9be80c8":"## Submission","22bb8b40":"Check Generator works correctly."}}