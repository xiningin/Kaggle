{"cell_type":{"23c539d3":"code","db7222d1":"code","1b974e61":"code","2a99424a":"code","b95bf938":"code","3b79e3b3":"code","0d477920":"code","33911618":"code","826aadcd":"code","912ec025":"code","dcc61205":"code","82f7e2fe":"code","5d82ce12":"code","23305b69":"code","a8a9590b":"code","adf05f15":"code","0ebffeb8":"code","6564fd52":"code","63d75b68":"code","e723421a":"code","9052d202":"code","1ddbce07":"code","622ef5dd":"code","f4603329":"code","fda0dd1f":"code","919b18d8":"code","62f39b45":"code","e252330e":"code","9b6d00ff":"code","9ffba51e":"code","36cb0aa0":"code","817fc5dd":"markdown","74992e9e":"markdown","bfc8cd4e":"markdown"},"source":{"23c539d3":"from glob import glob\nimport os\nimport numpy as np\nimport pandas as pd\nimport random\nfrom skimage.io import imread\nimport cv2\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# import h5py\nfrom tensorflow.python.keras.models import load_model\nfrom tensorflow.python.keras.applications import ResNet50\nfrom tensorflow.python.keras.applications.resnet50 import preprocess_input, decode_predictions\nfrom tensorflow.python.keras.models import Sequential\nfrom tensorflow.python.keras.layers import Dense, Flatten, GlobalAveragePooling2D,Dropout\nfrom tensorflow.python.keras.optimizers import Adam, SGD, RMSprop\nfrom tensorflow.python.keras.preprocessing.image import ImageDataGenerator, img_to_array, load_img\nfrom tensorflow.python.keras.callbacks import EarlyStopping\nfrom tensorflow.python.keras.models import Model\nimport tensorflow.keras.backend as K\nfrom sklearn.metrics import f1_score, accuracy_score","db7222d1":"!ls ..\/input\/chest-xray-pneumonia","1b974e61":"# Path to data\ndata_dir  = '..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/'\ntrain_dir = data_dir+'train\/'\ntest_dir  = data_dir+'test\/'\nval_dir   = data_dir + 'val\/'\n\n# Get the path to the normal and pneumonia sub-directories\nnormal_cases_dir = train_dir + 'NORMAL\/'\npneumonia_cases_dir = train_dir + 'PNEUMONIA\/'\n\nprint(\"Datasets:\",os.listdir(data_dir))\nprint(\"Train:\\t\", os.listdir(train_dir))\nprint(\"Test:\\t\", os.listdir(test_dir))","2a99424a":"train_pos = len(glob(train_dir+'PNEUMONIA\/*.jpeg'))\ntrain_neg = len(glob(train_dir+'NORMAL\/*.jpeg'))\nprint(\"Traing set\\t pos case: {}\\t neg case: {}\\t ratio: {}\".format(train_pos,train_neg,train_pos \/ (train_neg + train_pos)))\n\nval_pos = len(glob(val_dir+'PNEUMONIA\/*.jpeg'))\nval_neg = len(glob(val_dir+'NORMAL\/*.jpeg'))\nprint(\"Validate set\\t pos case: {}\\t neg case: {}\\t ratio: {}\".format(val_pos,val_neg,val_pos \/ (val_neg + val_pos)))\n\ntest_pos = len(glob(test_dir+'PNEUMONIA\/*.jpeg'))\ntest_neg = len(glob(test_dir+'NORMAL\/*.jpeg'))\nprint(\"Test set\\t pos case: {}\\t neg case: {}\\t ratio: {}\".format(test_pos,test_neg,test_pos \/ (test_neg + test_pos)))\n","b95bf938":"# Get the list of all the images\nnormal_cases = glob(normal_cases_dir+'\/*.jpeg')\npneumonia_cases = glob(pneumonia_cases_dir+'\/*.jpeg')\n\n# An empty list. We will insert the data into this list in (img_path, label) format\ntrain_data = []\n\n# Go through all the normal cases. The label for these cases will be 0\nfor img in normal_cases:\n    train_data.append((img,0))\n\n# Go through all the pneumonia cases. The label for these cases will be 1\nfor img in pneumonia_cases:\n    train_data.append((img, 1))\n\n# Get a pandas dataframe from the data we have in our list \ntrain_data = pd.DataFrame(train_data, columns=['image', 'label'],index=None)\n\n# Shuffle the data \ntrain_data = train_data.sample(frac=1.).reset_index(drop=True)\n\n# Get few samples for both the classes\npneumonia_samples = (train_data[train_data['label']==1]['image'].iloc[:5]).tolist()\nnormal_samples = (train_data[train_data['label']==0]['image'].iloc[:5]).tolist()\n\n# Concat the data in a single list and del the above two list\nsamples = pneumonia_samples + normal_samples\ndel pneumonia_samples, normal_samples\n\n# Plot the data \nf, ax = plt.subplots(2,5, figsize=(30,10))\nfor i in range(10):\n    img = imread(samples[i])\n    ax[i\/\/5, i%5].imshow(img, cmap='gray')\n    if i<5:\n        ax[i\/\/5, i%5].set_title(\"Pneumonia\")\n    else:\n        ax[i\/\/5, i%5].set_title(\"Normal\")\n    ax[i\/\/5, i%5].axis('off')\n    ax[i\/\/5, i%5].set_aspect('auto')\nplt.show()","3b79e3b3":"samples[0]","0d477920":"imread(samples[0]).shape","33911618":"imread(samples[0])","826aadcd":"image_size = 150\nnb_train_samples = 5216 # number of files in training set\nbatch_size = 16\n# batch_size = 32\n\n\n## Specify the values for all arguments to data_generator_with_aug.\ndata_generator_with_aug = ImageDataGenerator(preprocessing_function=preprocess_input,\n                                             horizontal_flip = True,\n                                             width_shift_range = 0.2,\n                                             height_shift_range = 0.2,\n                                             shear_range = 0.2,\n                                             zoom_range = 0.2)\n            \ndata_generator_no_aug = ImageDataGenerator(preprocessing_function=preprocess_input)\n\ntrain_generator = data_generator_with_aug.flow_from_directory(\n       directory = train_dir,\n       target_size = (image_size, image_size),\n       batch_size = batch_size,\n       class_mode = 'categorical')\n\nvalidation_generator = data_generator_no_aug.flow_from_directory(\n       directory = val_dir,\n       target_size = (image_size, image_size),\n       class_mode = 'categorical')\n\ntest_generator = data_generator_no_aug.flow_from_directory(\n       directory = test_dir,\n       target_size = (image_size, image_size),\n       batch_size = batch_size,\n       class_mode = 'categorical')","912ec025":"train_generator.next()[0][0,:]","dcc61205":"# Plot Loss  \ndef plot_loss(model):\n    plt.plot(model.history.history['loss'])\n    plt.plot(model.history.history['val_loss'])\n    plt.title('Model Loss')\n    plt.ylabel('Loss')\n    plt.xlabel('Epoch')\n    plt.legend(['Training set', 'Test set'], loc='upper left')\n    plt.show()\n# Plot Accuracy \ndef plot_accuracy(model):\n    plt.plot(model.history.history['acc'])\n    plt.plot(model.history.history['val_acc'])\n    plt.title('Model Accuracy')\n    plt.ylabel('Accuracy')\n    plt.xlabel('Epoch')\n    plt.legend(['Training set', 'Validation set'], loc='upper left')\n    plt.show()","82f7e2fe":"# Choose a random image and apply model for prediction\ndef choose_image_and_predict():\n    normal_or_pneumonia = ['NORMAL', 'PNEUMONIA']\n    folder_choice = (random.choice(normal_or_pneumonia))\n    \n    pneumonia_images = glob('..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/val\/'+folder_choice+'\/*')\n    img_choice = (random.choice(pneumonia_images))\n\n    img = load_img(img_choice, target_size=(image_size, image_size))\n    img = img_to_array(img)\n    plt.imshow(img \/ 255.)\n    x = preprocess_input(np.expand_dims(img.copy(), axis=0))\n#     pred_class = model.predict_classes(x)\n    pred = model.predict(x)\n    pred_class = pred.argmax(axis=-1)\n    print(\"Actual class:\", folder_choice)\n    if pred_class[0] == 0:\n        print(\"Predicted class: Normal\")\n        print(\"Likelihood:\", pred[0][0].round(4))\n        if pred[0][0].round(4) < 0.8:\n            print(\"WARNING, low confidence\")\n    else:\n        print(\"Predicted class: Pneumonia\")\n        print('Likelihood:', pred[0][1].round(4))\n        if pred[0][1].round(4) < 0.8:\n            print(\"WARNING, low confidence\")        \n","5d82ce12":"def evaluation_result():\n    # Evaluation the results\n    y_prob = model.predict_generator(test_generator)\n    y_pred = np.argmax(y_prob, axis = -1)\n    y_true = test_generator.labels\n\n    f1 = f1_score(y_pred=y_pred, y_true=y_true)\n    print(\"F1 score: {}\".format(f1))\n\n    acc = accuracy_score(y_pred=y_pred, y_true=y_true)\n    print(\"Accuracy: {}\".format(acc))\n\n    # True positive rate TPR = TP \/ P\n    # True negative rate TNR = TN \/ N\n    P = len(y_pred[y_pred == 1])\n    N = len(y_pred[y_pred == 0])\n\n    TP = len(y_pred[(y_pred == 1) & (y_true == 1)])\n    TN = len(y_pred[(y_pred == 0) & (y_true == 0)])\n\n    if P != 0: \n        TPR = 100 * TP \/ P\n        print(\"True Positive Rate: {}\".format(TPR))\n\n        # False Negative Rate FN \/ P\n        FN = len(y_pred[(y_pred == 0) & (y_true == 1)])\n        FNR = 100 * FN \/ P\n        print(\"False Negative Rate: {}\".format(FNR))\n    else:\n        print(\"All sample tests are 0\")\n\n    if N != 0:\n        TNR = 100 * TN \/ N\n        print(\"True Negative Rate: {}\".format(TNR))\n    else:\n        print(\"All sample tests are 1\")\n","23305b69":"from tensorflow.python.keras.applications import VGG16\nfrom tensorflow.python.keras.applications.vgg16 import preprocess_input, decode_predictions","a8a9590b":"num_classes = 2\nEPOCHS = 20\nSTEPS = nb_train_samples \/ batch_size","adf05f15":"# # Load the pre-trained model\n# vgg_weights_path = '..\/input\/keras-pretrained-models\/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'\n\n# model = Sequential()\n# model.add(VGG16(include_top=False, pooling='avg', weights=vgg_weights_path))\n# model.add(Dense(units=2, activation='softmax'))\n# model.layers[0].trainable = False\n\n# model.compile(optimizer='sgd', loss='categorical_crossentropy', metrics=['accuracy'])","0ebffeb8":"# model.summary()","6564fd52":"# model.fit_generator(\n#     train_generator, # specify where model gets training data\n#     epochs = EPOCHS,\n#     steps_per_epoch=STEPS,\n#     validation_data=validation_generator) # specify where model gets validation data\n\n# # Evaluate the model\n# scores = model.evaluate_generator(test_generator)\n# print(\"\\n%s: %.2f%%\" % (model.metrics_names[1], scores[1]*100))","63d75b68":"# evaluation_result()","e723421a":"# Load the pre-trained model\nvgg_weights_path = '..\/input\/keras-pretrained-models\/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'\nvgg16 = VGG16(pooling='avg', \n                  weights=vgg_weights_path,\n                  input_shape=(image_size, image_size, 3),\n                  include_top = False)\n\n# Freeze all layers in Resnet\nfor layer in vgg16.layers:\n    layer.trainable = False\n\n# Stack the pre-trained model with a fully-connected layer\n# Add fully-connect layer (aka Dense layer) with softmax activation\nx = vgg16.output\n# x = Flatten()(x)\n# x = Dense(num_classes, activation='softmax')(x)\n\n# FC layer\nx = Flatten()(x)\nx = Dense(units=4096, activation='relu')(x)\n# x = Dropout(rate=0.3)(x)\n# x = Dense(units=4096, activation='relu')(x)\n# x = Dropout(rate=0.3)(x)\nx = Dense(units=2, activation='softmax')(x)\n\n\n\n# Define loss function, optimizer and metrics\nmodel = Model(inputs=vgg16.input, outputs= x)\n\noptimizer = Adam(lr = 0.0001)\nearly_stopping_monitor = EarlyStopping(patience = 3, monitor = \"val_acc\", mode=\"max\", verbose = 2)\nmodel.compile(optimizer = optimizer, loss='categorical_crossentropy', metrics=['accuracy'])\n# model.compile(optimizer='sgd', loss='categorical_crossentropy', metrics=['accuracy'])","9052d202":"model.summary()","1ddbce07":"model.fit_generator(\n    train_generator, # specify where model gets training data\n    epochs = EPOCHS,\n    steps_per_epoch=STEPS,\n    validation_data=validation_generator, # specify where model gets validation data\n    callbacks=[early_stopping_monitor])\n\n# history = model.fit_generator(epochs=5, callbacks=[early_stopping_monitor], shuffle=True, validation_data=val_batches, generator=train_batches, steps_per_epoch=500, validation_steps=10,verbose=2)\n\n# Evaluate the model\nscores = model.evaluate_generator(test_generator)\nprint(\"\\n%s: %.2f%%\" % (model.metrics_names[1], scores[1]*100))","622ef5dd":"evaluation_result()","f4603329":"# Make a prediction\nchoose_image_and_predict()","fda0dd1f":"plot_loss(model)\nplot_accuracy(model)","919b18d8":"# Save model\nmodel.save('xray_model_vgg16.h5')","62f39b45":"!ls '..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/test\/'","e252330e":"# path = '..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/test\/NORMAL\/'\npath = '..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/test\/PNEUMONIA\/'\npneumonia_cases = glob(path+'\/*.jpeg')\nimg_path = pneumonia_cases[0]\n\nimg = load_img(img_path, target_size=(image_size,image_size))\nx = img_to_array(img)\nx = np.expand_dims(x, axis=0)\nx = preprocess_input(x)","9b6d00ff":"pred = model.predict(x)\npred_class = pred.argmax(axis=-1)[0]\nclass_output = model.output[:, pred_class]\nlast_conv_layer = model.get_layer(\"block5_conv3\")\n\ngrads = K.gradients(class_output, last_conv_layer.output)[0]\npooled_grads = K.mean(grads, axis=(0, 1, 2))\niterate = K.function([model.input], [pooled_grads, last_conv_layer.output[0]])\npooled_grads_value, conv_layer_output_value = iterate([x])\nfor i in range(512):\n    conv_layer_output_value[:, :, i] *= pooled_grads_value[i]","9ffba51e":"heatmap = np.mean(conv_layer_output_value, axis=-1)\nheatmap = np.maximum(heatmap, 0)\nheatmap \/= np.max(heatmap)\n\nimg = cv2.imread(img_path)\n# img = img_to_array(img)\nheatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))\nheatmap = np.uint8(255 * heatmap)\nheatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)\nsuperimposed_img = cv2.addWeighted(img, 0.6, heatmap, 0.4, 0)","36cb0aa0":"f, ax = plt.subplots(1,2, figsize=(30,10))\nax[0].imshow(img, cmap='gray')\nax[1].imshow(superimposed_img, cmap='gray')","817fc5dd":"Second Method","74992e9e":"First Method","bfc8cd4e":"## Heatmap"}}