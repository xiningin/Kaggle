{"cell_type":{"e47e3a47":"code","aadcb43b":"code","c61faf22":"code","87e8110a":"code","083ae115":"code","398654c5":"code","29490c0a":"code","f5402e9c":"code","d7cea51e":"code","70e00f9c":"code","62255170":"markdown","ef4863b5":"markdown","978e55c8":"markdown","cccb354a":"markdown","9c475329":"markdown","9e377ebe":"markdown"},"source":{"e47e3a47":"import numpy as np\nimport pandas as pd\nimport scipy.optimize as opt\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm_notebook\nfrom datetime import datetime, timedelta\nfrom sklearn.metrics import mean_squared_log_error\nimport warnings; warnings.filterwarnings('ignore')","aadcb43b":"train = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-1\/train.csv')\ntrain['Date'] = pd.to_datetime(train['Date'])\ntest = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-1\/test.csv')\ntest['Date'] = pd.to_datetime(test['Date'])\nsub = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-1\/submission.csv')\nsub['ForecastId'] = test['ForecastId'].values\nsub = sub.set_index('ForecastId', drop=True)\ntrain","c61faf22":"# Only use data up to 11\/03 to get a public LB score\n#print(len(train))\n#eval = train[train[\"Date\"] >= min(test['Date'])]\n#train = train[train[\"Date\"] < min(test['Date'])]\n#print(len(train))","87e8110a":"def sigmoid(t, M, beta, alpha):\n    return M \/ (1 + np.exp(-beta * (t - alpha)))\n\nsigmoid_models = {}\ndef forecast(data, steps, key=None):\n    if sum(data) == 0 or sum(data != 0) <= 3:\n        return [data[-1]] * steps\n    \n    filtered_data = data[data > 0]\n    \n    try:\n        def error(params):\n            M, beta, alpha = params\n            return np.sqrt(mean_squared_log_error(filtered_data, sigmoid(list(range(sum(data == 0), len(data))), M, beta, alpha)))\n        res = opt.minimize(error, x0=[1000, 0.25, 100])\n        M, beta, alpha = res.x\n        sigmoid_models[key] = (M, beta, alpha)\n        return np.clip(sigmoid(list(range(len(data), len(data) + steps)), M, beta, alpha), 0, None).astype(int)\n    except:\n        try:\n            popt, pcov = opt.curve_fit(sigmoid, list(range(sum(data == 0), len(data))), \n                                       filtered_data, maxfev=10000, p0=[1000, 0.25, 100])\n            M, beta, alpha = popt\n            sigmoid_models[key] = (M, beta, alpha)\n            return np.clip(sigmoid(list(range(len(data), len(data) + steps)), M, beta, alpha), 0, None).astype(int)\n        except:\n            print(key)\n            return [data[-1]] * steps\n    \n\n\n","083ae115":"for country in tqdm_notebook(np.unique(train['Country\/Region'])):\n    country_data = train[(train['Country\/Region'] == country)]\n    country_data = country_data.sort_values(by='Date')\n    if country not in ['US', 'China', 'Canada', 'Australia', 'France', 'United Kingdom', 'Netherlands', 'Denmark', 'Cruise Ship']:\n        country_test_data = test[test['Country\/Region'] == country].sort_values(by='Date')\n        sub.loc[country_test_data['ForecastId'], 'ConfirmedCases'] = forecast(country_data['ConfirmedCases'].values, len(country_test_data), key=(country, np.NaN, 'ConfirmedCases'))\n        sub.loc[country_test_data['ForecastId'], 'Fatalities'] = forecast(country_data['Fatalities'].values, len(country_test_data), key=(country, np.NaN, 'Fatalities'))\n    else:\n        for region in np.unique(country_data['Province\/State']):\n            region_data = country_data[country_data['Province\/State'] == region]\n            region_data = region_data.sort_values(by='Date')\n            \n            region_test_data = test[(test['Country\/Region'] == country) & (test['Province\/State'] == region)].sort_values(by='Date')\n            sub.loc[region_test_data['ForecastId'], 'ConfirmedCases'] = forecast(region_data['ConfirmedCases'].values, len(region_test_data), key=(country, region, 'ConfirmedCases'))\n            sub.loc[region_test_data['ForecastId'], 'Fatalities'] = forecast(region_data['Fatalities'].values, len(region_test_data), key=(country, region, 'Fatalities'))","398654c5":"eval1 = eval.merge(test, how='left', on=['Date', 'Country\/Region', 'Province\/State'])\neval1 = eval1.merge(sub, left_on=['ForecastId'], right_index=True)\nscore_c = np.sqrt(mean_squared_log_error(eval1['ConfirmedCases_x'].values, eval1['ConfirmedCases_y']))\nscore_f = np.sqrt(mean_squared_log_error(eval1['Fatalities_x'].values, eval1['Fatalities_y']))\n\nprint(f'score_c: {score_c}, score_f: {score_f}, mean: {np.mean([score_c, score_f])}')","29490c0a":"sub.head(100)","f5402e9c":"#overwrite fatalities \n#sub['Fatalities'] = sub['ConfirmedCases'].apply(lambda x: x*.005)\n","d7cea51e":"complete_test= pd.merge(test, sub, how=\"left\", on=\"ForecastId\")\ncomplete_test.to_csv('complete_test.csv',index=False)","70e00f9c":"sub.to_csv('submission.csv')","62255170":"# Calculate public LB score","ef4863b5":"> # Remove overlap between train and test set","978e55c8":"# [STATISTICAL APPROACH FOR MAKING PREDICTIONS OF CONFIRMED INFECTION AND DEATHS ON CORONA VIRUS](https:\/\/assets.tue.nl\/fileadmin\/content\/pers\/2020\/03%20March\/TUe%20-%20Technical_Report_Prediction_Corona_Virus.pdf)\n\nI will be reimplementing the model proposed by researchers from TU Eindhoven in this notebook. They proposed to fit a simple sigmoid function to each of the measurements of a country:\n![image.png](attachment:image.png)\nwith M the maximal number of cases, \ud835\udefc the number of days at which the expected number of counts is half way the maximum,and \ud835\udefd > 0 the growth parameter.\n\n**Special caution should be taken with exponential models such as these though... I am not saying that this is the ideal approach, I am merely replicating their study**\n\n**!!! IMPORTANT: The public test set overlaps with the training set !!! We have to filter out data from after 11\/03 in order to get an accurate public LB score**","cccb354a":"# Write away our submission","9c475329":"# Fit sigmoid model for each country \/ region combination","9e377ebe":"# Load in our data"}}