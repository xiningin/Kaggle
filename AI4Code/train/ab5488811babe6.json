{"cell_type":{"fbbde101":"code","707fea4d":"code","d60e7bfd":"code","fa8eadae":"code","ac756182":"code","fdf82166":"code","cff7a34d":"code","c546baf6":"code","ab3356e0":"code","f5c42722":"code","9be1c331":"code","9918fa90":"code","829d6770":"code","86a76c74":"code","cb31d2e3":"code","566bb8d8":"code","e78b0572":"code","a618e53b":"code","b6b5ed59":"code","71ffcab1":"code","85edcc6d":"markdown","86bad47b":"markdown","f65956f5":"markdown","8fc79fa6":"markdown","6088163c":"markdown","71be95b7":"markdown","288ed3e2":"markdown","f1e456f6":"markdown","da53faba":"markdown","4c9c6164":"markdown","0ff10c36":"markdown"},"source":{"fbbde101":"import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport os","707fea4d":"df_train = pd.read_csv(\"..\/input\/liverpool-ion-switching\/train.csv\")\ndf_test  = pd.read_csv(\"..\/input\/liverpool-ion-switching\/test.csv\")","d60e7bfd":"def create_axes_grid(numplots_x, numplots_y, plotsize_x=6, plotsize_y=3):\n    fig, axes = plt.subplots(numplots_y, numplots_x)\n    fig.set_size_inches(plotsize_x * numplots_x, plotsize_y * numplots_y)\n    return fig, axes\n    \ndef set_axes(axes, use_grid=True, x_val = [0,100,10,5], y_val = [-50,50,10,5]):\n    axes.grid(use_grid)\n    axes.tick_params(which='both', direction='inout', top=True, right=True, labelbottom=True, labelleft=True)\n    axes.set_xlim(x_val[0], x_val[1])\n    axes.set_ylim(y_val[0], y_val[1])\n    axes.set_xticks(np.linspace(x_val[0], x_val[1], np.around((x_val[1] - x_val[0]) \/ x_val[2] + 1).astype(int)))\n    axes.set_xticks(np.linspace(x_val[0], x_val[1], np.around((x_val[1] - x_val[0]) \/ x_val[3] + 1).astype(int)), minor=True)\n    axes.set_yticks(np.linspace(y_val[0], y_val[1], np.around((y_val[1] - y_val[0]) \/ y_val[2] + 1).astype(int)))\n    axes.set_yticks(np.linspace(y_val[0], y_val[1], np.around((y_val[1] - y_val[0]) \/ y_val[3] + 1).astype(int)), minor=True)","fa8eadae":"fig, axes = create_axes_grid(1,2,30,5)\nset_axes(axes[0], x_val=[0,5000000,500000,100000], y_val=[-5,15,5,1])\naxes[0].plot(df_train['signal'], color='darkblue', linewidth=.1);\naxes[0].set_title('training')\nset_axes(axes[1], x_val=[0,2000000,100000,10000], y_val=[-5,15,5,1])\naxes[1].set_title('test')\naxes[1].plot(df_test['signal'], color='darkgreen', linewidth=.1);","ac756182":"train_segm_separators = np.concatenate([[0,500000,600000], np.arange(1000000,5000000+1,500000)])\ntrain_segm_signal_groups = [0,0,0,1,2,4,3,1,2,3,4] # from visual identification\ntrain_segm_is_shifted = [False, True, False, False, False, False, False, True, True, True, True] # from visual identification\ntrain_signal = np.split(df_train['signal'].values, train_segm_separators[1:-1])\ntrain_opench = np.split(df_train['open_channels'].values, train_segm_separators[1:-1])","fdf82166":"test_segm_separators = np.concatenate([np.arange(0,1000000+1,100000), [1500000,2000000]])\ntest_segm_signal_groups = [0,2,3,0,1,4,3,4,0,2,0,0] # from visual id\ntest_segm_is_shifted = [True, True, False, False, True, False, True, True, True, False, True, False] # from visual id\ntest_signal = np.split(df_test['signal'].values, test_segm_separators[1:-1])","cff7a34d":"#create clean signal histograms\nfig, axes = create_axes_grid(1,1,30,4)\nset_axes(axes, x_val=[-4,8,1,.1], y_val=[0,0.05,0.01,0.01])\n\nclean_hist = []\nhist_bins = np.linspace(-4,10,500)\n\nfor j,i in enumerate([0,3,4,6,5]):\n    clean_hist.append(np.histogram(train_signal[i], bins=hist_bins)[0])\n    clean_hist[-1] = clean_hist[-1] \/ 500000 # normalize histogram\n    axes.plot(hist_bins[1:], clean_hist[-1], label='Segment '+str(i)+', signal group '+str(j));\naxes.legend();\naxes.set_title(\"Clean reference histograms for all 5 signal groups\");","c546baf6":"window_size = 1000\n\nfig, axes = create_axes_grid(1,1,30,4)\nset_axes(axes, x_val=[-4,2,1,.1], y_val=[0,0.05,0.01,0.01])\n\naxes.plot(hist_bins[1:], clean_hist[0]);\nfor i in [0,25000,50000,75000]:\n    window_hist = np.histogram(train_signal[1][i:i+window_size], bins=hist_bins)[0] \/ window_size\n    axes.plot(hist_bins[1:], window_hist);","ab3356e0":"window_size = 1000\nbin_width = np.diff(hist_bins)[0]\ns_window = 10 # maximum absolute change in shift from window to window+1\ntrain_signal_shift = []\n\nfor clean_id in range(len(train_segm_signal_groups)):\n    \n    group_id = train_segm_signal_groups[clean_id]\n    window_shift = []\n    prev_s = 0 # all signal groups start with shift=0\n    window_data = train_signal[clean_id].reshape(-1,window_size)\n    \n    for w in window_data:\n        window_hist = np.histogram(w, bins=hist_bins)[0] \/ window_size\n        window_corr = np.array([ np.sum(clean_hist[group_id] * np.roll(window_hist, -s)) for s in range(prev_s-s_window, prev_s+s_window+1) ])\n        prev_s = prev_s + np.argmax(window_corr) - s_window\n        window_shift.append(-prev_s * bin_width)\n\n    window_shift = np.array(window_shift)\n    train_signal_shift.append(window_shift)    ","f5c42722":"fig, axes = create_axes_grid(1,1,30,4)\nset_axes(axes, x_val=[0,5000,500,100], y_val=[-5,1,1,.1])\naxes.plot(np.concatenate(train_signal_shift));\naxes.set_title(\"Shift value as determined by histogram matching:\");","9be1c331":"train_signal_shift_clean = []\ntrain_signal_detrend = []\n\nfor data, use_fit, signal in zip(train_signal_shift, train_segm_is_shifted, train_signal):\n    if use_fit:\n        data_x = np.arange(len(data), dtype=float) * window_size + window_size\/2\n        fit = np.flip(np.polyfit(data_x, data, 4))\n        data_x = np.arange(len(data) * window_size, dtype=float)\n        data_2 = np.sum([ c * data_x ** i for i, c in enumerate(fit) ], axis=0)\n    else:\n        data_2 = np.zeros(len(data) * window_size, dtype=float)\n        \n    train_signal_shift_clean.append(data_2)\n    train_signal_detrend.append(signal + data_2)","9918fa90":"fig, axes = create_axes_grid(1,1,30,4)\nset_axes(axes, x_val=[0,5000000,500000,100000], y_val=[-6,1,1,.1])\naxes.plot(np.concatenate(train_signal_shift_clean));\naxes.set_title(\"Final shift value after polynomial fit\");","829d6770":"fig, axes = create_axes_grid(1,1,30,5)\nset_axes(axes, x_val=[0,5000000,500000,100000], y_val=[-5,15,5,1])\naxes.plot(np.concatenate(train_signal_detrend), linewidth=.1);\naxes.set_title(\"Training data without shift\");","86a76c74":"window_size = 1000\nbin_width = np.diff(hist_bins)[0]\ns_window = 10\ntest_signal_detrend = []\ntest_signal_shift = []\n\nfor clean_id in range(len(test_segm_signal_groups)):\n    \n    group_id = test_segm_signal_groups[clean_id]\n    window_shift = []\n    prev_s = 0\n    window_data = test_signal[clean_id].reshape(-1,window_size)\n    \n    for w in window_data:\n        window_hist = np.histogram(w, bins=hist_bins)[0] \/ window_size\n        window_corr = np.array([ np.sum(clean_hist[group_id] * np.roll(window_hist, -s)) for s in range(prev_s-s_window, prev_s+s_window+1) ])\n        prev_s = prev_s + np.argmax(window_corr) - s_window\n        window_shift.append(-prev_s * bin_width)\n\n    window_shift = np.array(window_shift)\n    test_signal_shift.append(window_shift)    ","cb31d2e3":"fig, axes = create_axes_grid(1,1,30,4)\nset_axes(axes, x_val=[0,2000,100,10], y_val=[-6,1,1,.1])\naxes.plot(np.concatenate(test_signal_shift));\naxes.set_title(\"Shift value as determined by histogram matching:\");","566bb8d8":"test_signal_shift_clean = []\ntest_signal_detrend = []\ntest_remove_shift = [True, True, False, False, True, False, True, True, True, False, True, False]\n\nfor data, use_fit, signal in zip(test_signal_shift, test_segm_is_shifted, test_signal):\n    if use_fit:\n        data_x = np.arange(len(data), dtype=float) * window_size + window_size\/2\n        fit = np.flip(np.polyfit(data_x, data, 4))\n        data_x = np.arange(len(data) * window_size, dtype=float)\n        data_2 = np.sum([ c * data_x ** i for i, c in enumerate(fit) ], axis=0)\n    else:\n        data_2 = np.zeros(len(data) * window_size, dtype=float)\n        \n    test_signal_shift_clean.append(data_2)\n    test_signal_detrend.append(signal + data_2)","e78b0572":"fig, axes = create_axes_grid(1,1,30,4)\nset_axes(axes, x_val=[0,2000000,100000,10000], y_val=[-6,1,1,.1])\naxes.plot(np.concatenate(test_signal_shift_clean));\naxes.set_title(\"Final shift value after polynomial fit\");","a618e53b":"fig, axes = create_axes_grid(1,1,30,5)\nset_axes(axes, x_val=[0,2000000,200000,10000], y_val=[-5,12,5,1])\naxes.plot(np.concatenate(test_signal_detrend), linewidth=.1);\naxes.set_title(\"Test data without shift\");","b6b5ed59":"np.savez_compressed(\"train_detrend.npz\", train_signal=train_signal_detrend, train_opench=train_opench, train_groups=train_segm_signal_groups)","71ffcab1":"np.savez_compressed(\"test_detrend.npz\", test_signal=test_signal_detrend, test_groups=test_segm_signal_groups)","85edcc6d":"The final shift and the cleaned signal:","86bad47b":"It's visually clear that the shift can be determined by matching the window histograms to the clean histogram. Now we need to do this automatically for all shifted data segments:","f65956f5":"And the same procedure for the test data:","8fc79fa6":"Finally, approximation by a 4th order polynomial:","6088163c":"The data consists of different segments which can be sorted into one of 5 \"signal groups\":","71be95b7":"Let's take a look at the linear shift in segment 1 and compare the histogram of 4 slices of width 1000 (at 0,25000,50000 and 75000) to the clean histogram of segment 0:","288ed3e2":"Visual identification can easily determine a) the signal group and b) whether there is a drift:","f1e456f6":"This results in an already quite clean shift signal:","da53faba":"Finally, save all info in a convenient format (I like this more than csv, but otherwise just use a pandas DataFrame):","4c9c6164":"The training data segments 0,3,4,6,5 are the \"model segments\" for the signal groups 0-5, respectively (clean & no shift):","0ff10c36":"This notebook shows how to remove the drift from the training and test data as cleanly as possible. A clean signal is extremely important, since predictions from any ML models depend strongly on the precise value of each data point. The drift is removed by computing the histograms of small signal batches and matching them to an ideal (non-shifted) histogram. The resulting shifts are already much better than those from e.g. a rolling mean. The shifts are then further smoothed by approximating them with 4th degree polynomials. \nThe resulting clean signal retains the original offset.\nFor the pupose of this competition, the \"signal groups\" (see below) are determined by hand. This could also be done in an automated way (e.g. through analysis of the histograms) in the case of real-world data."}}