{"cell_type":{"41156b19":"code","5d86b4ec":"code","0730e5dc":"code","3716e918":"code","4fd21181":"markdown"},"source":{"41156b19":"import os\nimport sys\nimport re\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport pandas.io.sql as psql\nimport sqlite3\nfrom datetime import datetime as dt\nimport datetime\nimport time \nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n\nshow_tables = \"select tbl_name from sqlite_master where type = 'table'\"\ndesc = \"PRAGMA table_info([{table}])\"\n\ntry:\n    conn.close()\nexcept:\n    pass\nconn = sqlite3.connect(':memory:')\ncursor = conn.cursor()\n\n#\/kaggle\/input\/hayabusa2\/hkattrp.db\n#\/kaggle\/input\/hayabusa2\/aocsc.db\n\nattach = 'attach \"..\/input\/hayabusa2\/{data_name}.db\" as {data_name}'\n\ndata_list = ['hkattrp','aocsc']\n\nfor data_name in data_list:\n    cursor.execute(attach.format(data_name=data_name))\n    \n# count: aocsc 5075859 hkattrp 7501952\n# desc: ['datetime', 'q1', 'q2', 'q3', 'q4', 'avx', 'avy', 'avz']\n","5d86b4ec":"class nvdashboard():\n    def __init__(self):\n        print(dt.now())\n    # tg: table, ts: timestamp\n    def sample(self,d_type,tg,ts,start,interval=1,sample_num=100):\n        start_epoch = self.to_epoch(start)\n        last_epoch = start_epoch + interval*sample_num\n        last = dt.strftime(self.from_epoch(last_epoch),\n                           '%Y\/%m\/%d %H:%M:%S')+'.000'\n        print('last: ' + str(last))\n        \n        if d_type == 'sqlite':\n            sql = \"\"\"\n            select * from {tg}\n            where {ts} >  '{start}'\n            and {ts} < '{last}'\n            \"\"\"[1:-1]\n            df = pd.read_sql(sql.format(tg=tg,\n            ts=ts,start=start,last=last),conn)\n            df['epoch'] = df[ts]\n            df['epoch'] = df['epoch'].map(self.to_epoch)\n            df['s'] = df['epoch']\n            df['s'] = df['s'].map(lambda x: (x-start_epoch) \/\/ interval ) # allocate quotient for interval\n            df['s'] = df['s'].map(lambda x: self.from_epoch(start_epoch + x*interval)) # convert datetime from epoch\n            df_sample = df[['s', 'q1', 'q2', 'q3', 'q4', 'avx', 'avy', 'avz']].groupby('s') # \n            return(df_sample.mean())\n        \n        if d_type == 'D5A':\n            table_id = 0\n            item_id = 1\n            engine.open_srch(table_id,item_id)\n            search_id = engine.get_srchid_list()[-1]\n            ret = engine.exec_search(search_id,CONSTANT.SRCHCMD_BETWEEN,start,last)\n\n            return(ret)\n        \n        print('Error')\n        return()\n        \n    \n        \n    def to_epoch(self,datetime_string):\n        return(int(time.mktime(pd.to_datetime(datetime_string).timetuple())))\n    \n    def from_epoch(self,epoch_time):\n        return(dt.fromtimestamp(epoch_time))\n    \n    \n    # Extract from list using regular expression\n    def re(self,xlist,treg):\n        return([x for x in xlist if re.search(treg,x)])\n    def tc(self,tg):\n        start_time = time.perf_counter()\n        exec(tg)\n        execution_time = time.perf_counter() - start_time\n        print(execution_time)\n        return(execution_time)\n        \nnv = nvdashboard()","0730e5dc":"tg = 'aocsc'\nts = 'datetime'\nstart = '2014\/12\/03 04:07:05.773'\nprint('start: ' + start)\ninterval = 60  # second\nsample_num = 1000 # sampling number\n\nstart_time = time.perf_counter()\ndf = nv.sample('sqlite',tg,ts,start,interval,sample_num)\nexecution_time = time.perf_counter() - start_time\nprint(execution_time)","3716e918":"import plotly.graph_objects as go\nfig = go.Figure([\n                 go.Scatter(x=df.index,y=df['avx'],name='avx'),\n                 go.Scatter(x=df.index,y=df['avy'],name='avy'),\n                 go.Scatter(x=df.index,y=df['avz'],name='avz'),\n                ])\nfig.show()","4fd21181":"# Data acquisition (sampling) Sampling is performed at the interval specified in seconds, and the average value is sampled."}}