{"cell_type":{"98b74599":"code","e86342ed":"code","7982ee28":"code","4499dea1":"code","4ef03bd1":"code","98227eb0":"code","26e977b9":"code","bcd3260f":"code","2f4eae8b":"code","1702601d":"code","56beb492":"code","5038cd64":"markdown","fae222bc":"markdown","3d5d18e4":"markdown","e7b9cd7b":"markdown","7836218a":"markdown","2d86e98b":"markdown","2f0aa219":"markdown","818e8a38":"markdown","06dfc3bb":"markdown","6229094b":"markdown","7b4acd79":"markdown","33afcafc":"markdown","691c4654":"markdown","8e7e8459":"markdown","d1990664":"markdown","2289d271":"markdown"},"source":{"98b74599":"import numpy as np \nimport matplotlib.pyplot as plt\nimport cv2","e86342ed":"class CA_Grid:\n\n    def __init__(self, height=200, width=400, initial_number_of_black_cell=1):\n        self.height = height\n        self.width = width\n        self.initial_number_of_black_cell = initial_number_of_black_cell\n        self.grid = None\n\n\n    def __initialize(self,height, width, initial_number_of_black_cell):\n        self.height = height\n        self.width = width\n        self.grid = None\n        self.initial_number_of_black_cell = initial_number_of_black_cell\n\n    def get_grid(self):\n\n        if self.initial_number_of_black_cell==1:\n            self.__single_black_cell_grid()\n        else:\n            self.__multiple_black_cell_grid()\n\n        return self.grid\n\n    def __single_black_cell_grid(self):\n\n        \"\"\"\n        This function creates matrix in heightXwidth dimensions and \n        assigns 1 to the middle cell in the top row of the matrix.\n\n        :return:\n        \"\"\"\n        self.grid = np.zeros((self.height, self.width), dtype=np.int32)\n        self.grid[0, int(self.width \/ 2)] = 1\n\n\n\n\n    def __multiple_black_cell_grid(self):\n\n        \"\"\"\n        This function assigns a value of 1 to the desired \n        number of cells of the top row of the heightXwitdth matrix. \n        It ensures that the middle cell is 1.\n        :return:\n        \"\"\"\n\n\n\n        #Calling the function that assigns the value of the middle cell of the top row to 1.\n        self.__single_black_cell_grid()\n\n        \"\"\"remove 1 from the self.initial_number_of_black_cell variable \n        because the value has been assigned to the middle cell\"\"\"\n        n=self.initial_number_of_black_cell-1\n        for i in range(n):\n            random_col = np.random.randint(0, self.width)\n            self.grid[0, random_col] = 1\n\n","7982ee28":"class Elementary_CA(CA_Grid):\n\n    def __init__(self,grid_apparence=\"normal\",**kwargs):\n        super().__init__(**kwargs)\n\n        self.grid_apparence=grid_apparence\n\n\n        self.transform_vector=np.array([4,2,1])\n    \n        self.rule=None\n\n        self.rule_binary=None\n\n    def set_grid_parameters(self,\n                            height,\n                            width,\n                            initial_number_of_black_cell=1,\n                            grid_apparence=\"normal\"):\n        self.height = height\n        self.width = width\n        self.initial_number_of_black_cell = initial_number_of_black_cell\n        \n        self.grid = None\n        self.grid_apparence=grid_apparence\n\n    def __get_rule_binary(self):\n        self.rule_binary = np.array([int(b) for b in np.binary_repr(self.rule, 8)], dtype=np.int8)\n\n    def generate(self, rule):\n\n        self.rule=rule\n        self.get_grid()\n        self.__get_rule_binary()\n\n        for i in range(self.height-1):\n            self.grid[i+1,:]=self.step(self.grid[i,:])\n\n        self.grid[self.grid==1]=255\n\n        if self.grid_apparence==\"wolfram\":\n            self.grid=cv2.bitwise_not(self.grid)\n        \n        return self.grid\n\n    def generate_all_ca(self):\n        all_ca=list()\n        for i in range(256):\n            self.generate(i)\n            all_ca.append(self.grid)\n\n        return all_ca\n\n\n    def __get_neighborhood_matrix(self, center):\n        #vector that holds the neighbors on the left by shifting the row vector to the right\n        left=np.roll(center, 1)\n\n\n        #vector that holds the neighbors on the rights by shifting the row vector to the left\n        right=np.roll(center, -1)\n        \n        neighborhood_matrix=np.vstack((left, center, right)).astype(np.int8)\n\n        return neighborhood_matrix\n\n    def step(self, row):\n        neighborhood_matrix=self.__get_neighborhood_matrix(center=row)\n\n\n\n        #u=self.transform_vector.reshape((3,1))\n        #rmts=np.sum(neighborhood_matrix*u, axis=0)\n\n        rmts=self.transform_vector.dot(neighborhood_matrix)\n\n        return self.rule_binary[7-rmts].astype(np.int8)","4499dea1":"class Demonstrate_CA:\n    def __init__(self):\n        print(\"Demonstrate_CA object created\")\n    \n    def show_rule(self, rule, step):\n        step=step\n        elementary_CA=Elementary_CA(height=step, width=step*2, grid_apparence=\"wolfram\")\n        \n        rule=rule\n        generated_image=elementary_CA.generate(rule=rule)\n\n        plt.figure(figsize=(15,15))\n        plt.imshow(generated_image, cmap=\"gray\")\n        plt.xticks([])\n        plt.yticks([])\n        plt.title(\"Demonstration of Rule {} for {} Steps\".format(rule, step))\n        plt.show()\n    \n    def show_rules_between_0_and_127(self):\n        step=30\n        elementary_CA=Elementary_CA(height=step, width=step*2, grid_apparence=\"wolfram\")\n        all_ca_patterns=elementary_CA.generate_all_ca()\n        \n        fig,axarr=plt.subplots(nrows=32, ncols=4, figsize=(16, 80))\n        axarr=axarr.flatten()\n        for index, pattern_image in enumerate(all_ca_patterns[:128]):\n            axarr[index].imshow(pattern_image, cmap=\"gray\")\n            axarr[index].set_xticks([])\n            axarr[index].set_yticks([])\n            axarr[index].set_title(\"Rule {}\".format(index))\n        #plt.suptitle(\"Demonstration of Rules Between 0 and 127\")\n        plt.show()\n    \n    def show_rules_between_128_and_255(self):\n        step=30\n        elementary_CA=Elementary_CA(height=step, width=step*2, grid_apparence=\"wolfram\")\n        all_ca_patterns=elementary_CA.generate_all_ca()\n        \n        fig,axarr=plt.subplots(nrows=32, ncols=4, figsize=(16, 80))\n        axarr=axarr.flatten()\n        for index, pattern_image in enumerate(all_ca_patterns[128:]):\n            axarr[index].imshow(pattern_image, cmap=\"gray\")\n            axarr[index].set_xticks([])\n            axarr[index].set_yticks([])\n            axarr[index].set_title(\"Rule {}\".format(index+128))\n        #plt.suptitle(\"Demonstration of Rules Between 128 and 255\")\n        plt.show()","4ef03bd1":"demonstrate_ca=Demonstrate_CA()","98227eb0":"rules=[60, 73,105, 30, 90, 110]\nstep=100\nfor rule in rules:\n    print(\"Demontration of rule {} for {} step\".format(rule, step))\n    demonstrate_ca.show_rule(rule=rule, step=step)","26e977b9":"print(\"Rule Demonstration Between 0 and 127\")\ndemonstrate_ca.show_rules_between_0_and_127()\nprint(\"Rule Demontration Between 128 and 255\")\ndemonstrate_ca.show_rules_between_128_and_255()","bcd3260f":"class Totalistic_CA_Grid:\n\n    def __init__(self, height=200, width=400, initial_number_of_black_cell=1):\n        self.height = height\n        self.width = width\n        self.initial_number_of_black_cell = initial_number_of_black_cell\n        self.grid = None\n\n\n    def __initialize(self,height, width, initial_number_of_black_cell):\n        self.height = height\n        self.width = width\n        self.grid = None\n        self.initial_number_of_black_cell = initial_number_of_black_cell\n\n    def get_grid(self):\n\n        if self.initial_number_of_black_cell==1:\n            self.__single_black_cell_grid()\n        else:\n            self.__multiple_black_cell_grid()\n\n        return self.grid\n\n    def __single_black_cell_grid(self):\n\n        \"\"\"\n        This function creates matrix in heightXwidth dimensions and \n        assigns 1 to the middle cell in the top row of the matrix.\n\n        :return:\n        \"\"\"\n        self.grid = np.zeros((self.height, self.width), dtype=np.int32)\n        self.grid[0, int(self.width \/ 2)] = 2\n\n\n\n\n    def __multiple_black_cell_grid(self):\n\n        \"\"\"\n        This function assigns a value of 1 to the desired \n        number of cells of the top row of the heightXwitdth matrix. \n        It ensures that the middle cell is 1.\n        :return:\n        \"\"\"\n\n\n\n        #Calling the function that assigns the value of the middle cell of the top row to 1.\n        self.__single_black_cell_grid()\n\n        \"\"\"remove 1 from the self.initial_number_of_black_cell variable \n        because the value has been assigned to the middle cell\"\"\"\n        n=self.initial_number_of_black_cell-1\n        for i in range(n):\n            random_col = np.random.randint(0, self.width)\n            self.grid[0, random_col] = 2\n\n","2f4eae8b":"class Totalistic_CA(Totalistic_CA_Grid):\n\n    def __init__(self,grid_apparence=\"normal\",**kwargs):\n        super().__init__(**kwargs)\n\n        self.grid_apparence=grid_apparence\n\n        self.rule=None\n\n        self.rule_tenary=None\n\n    def set_grid_parameters(self,\n                            height,\n                            width,\n                            initial_number_of_black_cell=1,\n                            grid_apparence=\"normal\"):\n        self.height = height\n        self.width = width\n        self.initial_number_of_black_cell = initial_number_of_black_cell\n        \n        self.grid = None\n        self.grid_apparence=grid_apparence\n\n    def __get_rule_tenary(self):\n        length=7\n        if self.rule==0:\n            padding=length\n        else:\n            padding=length-len(np.base_repr(self.rule,base=3))\n            \n        self.rule_tenary = np.array([int(b) for b in np.base_repr(\n            number=self.rule, \n            base=3,\n            padding=padding)], dtype=np.int8)\n        \n\n    def generate(self, rule):\n\n        self.rule=rule\n        self.get_grid()\n        self.__get_rule_tenary()\n\n        for i in range(self.height-1):\n            self.grid[i+1,:]=self.step(self.grid[i,:])\n\n        if self.grid_apparence=='normal':\n            self.grid[self.grid==2]=255\n            self.grid[self.grid==1]=128\n            self.grid[self.grid==0]=0\n        \n        if self.grid_apparence=='wolfram':\n            self.grid[self.grid==1]=128\n            self.grid[self.grid==0]=255\n            self.grid[self.grid==2]=0\n        \n        return self.grid\n\n\n    def __get_neighborhood_matrix(self, center):\n        #vector that holds the neighbors on the left by shifting the row vector to the right\n        left=np.roll(center, 1)\n\n\n        #vector that holds the neighbors on the rights by shifting the row vector to the left\n        right=np.roll(center, -1)\n        \n        neighborhood_matrix=np.vstack((left, center, right)).astype(np.int8)\n\n        return neighborhood_matrix\n\n    def step(self, row):\n        neighborhood_matrix=self.__get_neighborhood_matrix(center=row)\n\n        rmts=np.sum(neighborhood_matrix, axis=0)\n        #print(\"rmts\",rmts)\n\n        return self.rule_tenary[6-rmts].astype(np.int8)","1702601d":"totalistic_rules=[224, 2049, 966, 1041, 993, 777]\nfor totalistic_rule in totalistic_rules:\n    totalistic_ca=Totalistic_CA(grid_apparence=\"wolfram\")\n    ca_pattern=totalistic_ca.generate(totalistic_rule)\n    plt.figure(figsize=(12,6))\n    plt.imshow(ca_pattern,cmap=\"gray\")\n    plt.xticks([])\n    plt.yticks([])\n    plt.title(\"Totalistic CA Pattern for Code:{}\".format(totalistic_rule))\n    plt.show()","56beb492":"totalistic_rules=[2049, 966, 1041, 993, 777,224]\nfor totalistic_rule in totalistic_rules:\n    totalistic_ca=Totalistic_CA(grid_apparence=\"wolfram\", initial_number_of_black_cell=4)\n    ca_pattern=totalistic_ca.generate(totalistic_rule)\n    plt.figure(figsize=(12,6))\n    plt.imshow(ca_pattern,cmap=\"gray\")\n    plt.xticks([])\n    plt.yticks([])\n    plt.title(\"Totalistic CA Pattern for Code:{}\".format(totalistic_rule))\n    plt.show()","5038cd64":"[Go to Contents Menu](#0.)\n\n<a class=\"anchor\" id=3.2.>3.2. Elementary_CA class<\/a>","fae222bc":"[Go to Contents Menu](#0.)\n\n<a class=\"anchor\" id=3.1.>3.1. CA_Grid class<\/a>","3d5d18e4":"[Go to Contents Menu](#0.)\n\n<a class=\"anchor\" id=3.3.>3.3. Demonstrate_CA class<\/a>","e7b9cd7b":"![2](http:\/\/i.hizliresim.com\/P1rZj9.png)\nFigure 1. Next states of a cell depend on Rule 254","7836218a":"# <a class=\"anchor\" id=0.><\/a> Contents\n\n* [1.Aim of the Kernel](#1.)\n* [2. Elementary Cellular Automata](#2.)\n* [3. Coding Elementary Cellular Automata from Scratch](#3.)\n* * [3.1. CA_Grid class](#3.1.)\n* * [3.2. Elementary_CA class](#3.2.)\n* * [3.3. Demonstrate_CA class](#3.3.)\n* * [3.4. Show Cellular Automata Patterns for Rules](#3.4.)\n* [4. Totalistic Cellular Automata](#4.)\n* * [4.1. Totalistic_CA_Grid class](#4.1.)\n* * [4.2.Totalistic_CA class](#4.2.)\n* * [4.3. Show  Patterns for Totalistic Rules](#4.3.)","2d86e98b":"[Go to Contents Menu](#0.)\n\n<a class=\"anchor\" id=3.4.>3.4. Show Elementary Cellular Automata Pattern for Rules<\/a>","2f0aa219":"In Figure 2, initianl there is only one black in the cellular grid. This black cell is located in the middle cell in the top row. The above pattern is obtained when Rule 254 is applied ten times to this cellular grid.","818e8a38":"[Go to Contents Menu](#0.)\n\n<a class=\"anchor\" id=2.>2. Cellular Automata Basics<\/a>\n\nAn important feature of CA is that its behavior can be shown in a visual way. CA works on a grid plane of cells whose colors are black or white. The state of the cells corresponds to the values of 1 or 0 in the context of the color value in black or white respectively. The next state of each cell is determined by states of its left neighbor, the right neighbor, and its own. It would be useful to examine Figure 1 to better understand the concept of state of cells.","06dfc3bb":"\n![3](http:\/\/i.hizliresim.com\/MVvM62.png)\nFigure 2. The pattern that Rule 254 produces after 10 steps.","6229094b":"[Go to Contents Menu](#0.)\n\n<a class=\"anchor\" id=4.>4. Totalistic Cellular Auotmata<\/a>\n\nUp to this point we talked about two-state cellular automata. The number of rules that cellular automata can have is 256. Since three cells can take up to eight different states, the rule value can consist of eight bits in the binary base. This means that different 2^8  rules can be applied. There is an exponential relationship between the number of rules that can be applied and the number of neighbors. If we formulate this relationship. The number of neighbors to k and the number of states n would be the number of rules  n^(n^k). 2(2^3)= 256. \n\nIf the number of state increases to three, what will be the result? In this case, the number of rules will be 3^(3^3) = 7 625 597 484 987\". Having so much rule makes it impossible to practice. This can be reduced by taking the rules in certain conditions. Wolfram set a rule for this.\n\n0, 1 ve 2 represented by white, gray and black in three state cellular automata demonstration. The next state of the cell is obtained according to the totals of these three cells. Accordingly, the number of rules will be 2187. Let's get a little more of how we get the number of rules. A one-dimensional cellular automaton has three neighbors, including its own, left and right cells. If these cells have a k number of values, can have 3k-2 different rules for totalistic automata. For such a case number k^3k-2 different rule is obtained. If the number of colors is 3, then the number of rules we get is 3^ 3x3-2 = 2187\".","7b4acd79":"[Go to Contents Menu](#0.)\n\n\n<a class=\"anchor\" id=\"4.3.\"><\/a>4.3. Show  Patterns for Totalistic Rules","33afcafc":"[Go to Contents Menu](#0.)\n\n\n<a class=\"anchor\" id=\"4.2.\"><\/a>4.2. Totalistic_CA class","691c4654":"[Go to Contents Menu](#0.)\n\n# <a class=\"anchor\" id=1.> <\/a>1. Aim of the Kernel\n\nAim of this kernel is to introduce  cellular automata and its demostration with python code. \n\nJon von Neumann proposed the concept of Cellular Automata(CA), a model of computation for the functioning of computers to model the self-renewal of biological organisms.\n\nCA consists of rules that determine the transition of cells in the grid plane from one state to another. There are a discrete number of states that are proportional to the number of cells that the cell is interacting with. When the rules are applied to a specified number of cells, the cells chage from one state to another, or remain in the same state.\n\nDifferent dimension of cellular automata are designed by researchers. CA  designed in two dimensions when first proposed by Neumman. Then one-dimensional and three-dimensional CA types were proposed. \n","8e7e8459":"The figure above consists of eight separate small shapes. Each small shape consists of three cells on top and one cell below them. For two-state cellular automata, there are eight different states that three cells can have. When three cells at the top are examined, eight different color sequences are seen. The single cell located under the three cells represents the next state of the cell in the middle of the three cells.\n\nFor Figure 1, the following state of the middle cell can be obtained simply: If the state of one of the three cells is black, the next state of the middle cell becomes black. CA, consisting of three neighboring and two states, can, however, determine the next state according to 256 different way. It is impossible to make a definition for each state transition. There is a better way to do this. A rule number is given for each different state transition.\n\nThe rule number is determined by the state of the eight underlying cells in the Figure 1. In the cellular automata, the black  and the white cells correspond to the number 1 and 0 respectively. In the above figure, if we write the number equivalents of the individual cells below, we can get the value 11111110. The resulting numerical value is considered to be a binary number. This is because the cells are composed of two states. The number 11111110 is in the binary base is 254 in decimal base. This number is the rule number applied on cell. For example; In Figure 1, the next state of the cell in the middle is obtained according to Rule 254.\n\nBecause three cells can take up to eight different states, the rule value can consist of eight bits in the binary base. This means that 2 ^ 8 = 256 different rules can be applied\n\nThe mystery of cellular automata is reserved in the repeated application of rules. The pattern that Rule254 will produce after 10 steps is given in Figure 2.","d1990664":"[Go to Contents Menu](#0.)\n\n\n<a class=\"anchor\" id=\"4.1.\"><\/a>4.1. Totalistic_CA_Grid class","2289d271":"[Go to Contents Menu](#0.)\n\n<a class=\"anchor\" id=3.>3. Coding Elemantary Cellular Automata from Scratch<\/a>\nIn this section, the coding of basic cellular automata will be realized. Three different classes will be created for coding:\n\n* CA_Grid class: will be used to form the cellular plane of the desired property (height, width, etc.)\n* Elementary_CA: Will be used to apply the CA rule to the cellular plane\n* Demonstrate_CA: Once the rule is applied to the cellular plane, it will be used to show the results obtained"}}