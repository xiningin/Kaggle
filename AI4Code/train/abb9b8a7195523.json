{"cell_type":{"b7c145b4":"code","b2a64b7e":"code","a2d8e4c9":"code","8219364b":"code","83bb2d93":"code","461d11fd":"code","1d0c03a0":"code","13f9bb2b":"code","fd94f852":"code","e1cb9072":"code","b76f3ee5":"code","d1b762d2":"code","8df3911b":"code","ec7e300d":"code","bed8d4db":"code","851cf381":"code","a2c20a2f":"code","c8ea1c07":"code","ed81baa4":"code","8d7e3203":"code","2f7b4364":"code","8e92ebee":"code","1b114aa3":"code","750284b5":"code","2cff17f7":"code","f9d699ae":"code","5f841001":"code","f22275b5":"code","e7d79455":"code","04323140":"code","28877e09":"code","82f29a3d":"code","d9aea4e5":"code","8bd7b8f6":"code","cf7916ed":"code","7fe61035":"code","33ddc5c8":"code","64050292":"code","55fd20bc":"markdown","ee17c15e":"markdown","f81c32a9":"markdown","cf32232a":"markdown","98e3184f":"markdown","422749f4":"markdown","ba9354ee":"markdown","ca3ea95f":"markdown","e5e95f7e":"markdown","e351e22a":"markdown","ed09d250":"markdown","a13c56c0":"markdown","af17e5bd":"markdown","5a4c8bbb":"markdown","15e7533e":"markdown","cf2ef9b0":"markdown","b833c929":"markdown","eedbc8b5":"markdown","93a101d6":"markdown","3ef15064":"markdown","d9309d34":"markdown","6b18e000":"markdown","4cf07b9f":"markdown","e19e2aa7":"markdown","88af73b9":"markdown","0ed944b4":"markdown","2ace4b6a":"markdown","908cbe74":"markdown","bea0d3b7":"markdown","fdc77e09":"markdown","f61e7a15":"markdown","0a3f0e29":"markdown","5d2f91c2":"markdown","36e5d565":"markdown","b148f6ac":"markdown","c45cdc07":"markdown","e7361a0d":"markdown","d1ca892d":"markdown","f865bb5a":"markdown","9796b8dc":"markdown","225153df":"markdown","11ddd533":"markdown","559eb933":"markdown","edeafcf6":"markdown","950cea36":"markdown","fd83f38e":"markdown","eec72288":"markdown","cc618eb1":"markdown","0598f84e":"markdown","587c7742":"markdown","f141d473":"markdown","25aa6ae2":"markdown","38b6fe0d":"markdown","f852c271":"markdown","66106780":"markdown","a21d08ed":"markdown","4f89cd45":"markdown","8ce85d77":"markdown","53ad0245":"markdown","522d236e":"markdown","18e758a2":"markdown"},"source":{"b7c145b4":"import numpy as np \nimport pandas as pd \nimport os\nfrom fbprophet import Prophet\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error\nimport warnings\nwarnings.filterwarnings('ignore')\nnp.random.seed(42)\n\n!pip install bubbly","b2a64b7e":"df = pd.read_csv(\"\/kaggle\/input\/daily-temperature-of-major-cities\/city_temperature.csv\")\n\nprint(f'There are {df.shape[0]} rows and {df.shape[1]} columns')","a2d8e4c9":"df_reg = df.groupby(['Region', 'Year'])['AvgTemperature'].mean().reset_index()\ndf_reg = df_reg[(df_reg['AvgTemperature']> 0 )]","8219364b":"import plotly.express as px\nfig = px.scatter(df_reg, x=\"Year\", y=\"AvgTemperature\", color=\"Region\",\n                 size='AvgTemperature', hover_data=['Region'])\n\nfig.show()","83bb2d93":"from bubbly.bubbly import bubbleplot \nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode()\n\nfigure = bubbleplot(dataset=df_reg, x_column='Year', y_column='AvgTemperature', \n    bubble_column='Region', time_column='Year', color_column='Region', \n    x_title=\"Year\", y_title=\"Avg Temperature\", title='Avg Temperature over the years across Continents',\n    scale_bubble=3, height=650)\n\niplot(figure, config={'scrollzoom': True})","461d11fd":"df_delhi = df[df['City'] == 'Delhi']\ndf_delhi['Date'] = pd.to_datetime(df_delhi[['Year', 'Month', 'Day']])\n#df_months = df_delhi.groupby(['Year', 'Month', 'Day'])['AvgTemperature'].mean().reset_index()\ndf_months = df_delhi[df_delhi['Year']>2017]\n\ndf_months = df_months.reset_index()\ndf_months.drop('index', axis=1, inplace=True)","1d0c03a0":"df_months = df_months[['Date', 'AvgTemperature']]\ndf_months['Date'] = df_months['Date'].apply(pd.to_datetime)\ndf_months.set_index(\"Date\", inplace = True)\ndf_months = df_months['2018-01':'2020-04']","13f9bb2b":"df_months_ = df_months.reset_index()\nfig = px.line(df_months_, x=\"Date\", y=\"AvgTemperature\", title='Average Temperature of Delhi over the last 2 years')\nfig.show()","fd94f852":"df_months['mavg_12'] = df_months['AvgTemperature'].rolling(window = 12).mean().shift(1)\npd.set_option('display.float_format', lambda x: '%.2f'% x)\nmayd = df_months.reset_index()\nmayd = mayd.tail(30)","e1cb9072":"import plotly.graph_objects as go\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=mayd['Date'],\n    y=mayd['AvgTemperature'],\n    name=\"Actual Avg Temperature\"\n))\n\nfig.add_trace(go.Scatter(\n    x=mayd['Date'],\n    y=mayd['mavg_12'],\n    name=\"Moving Average\"\n))\n\nfig.update_layout(\n    title=\"Avg Temp. - Actual vs Moving Average of Delhi for the Month of April 2020\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"Avg Temp\",\n    font=dict(\n        family=\"Courier New, monospace\",\n        size=9.5,\n        color=\"#7f7f7f\"\n    )\n)\n\nfig.show()","b76f3ee5":"def get_mape(actual, predicted):\n    y_true, y_pred = np.array(actual), np.array(predicted)\n    return np.round( np.mean(np.abs((actual - predicted)\/ actual)) * 100, 2)","d1b762d2":"get_mape(mayd['AvgTemperature'].values, mayd['mavg_12'].values)","8df3911b":"from sklearn.metrics import mean_squared_error \nnp.sqrt(mean_squared_error(mayd['AvgTemperature'].values, mayd['mavg_12'].values))","ec7e300d":"df_months['ewm'] = df_months['AvgTemperature'].ewm(alpha = 0.2 ).mean()\npd.set_option('display.float_format', lambda x: '%.2f'% x)\nemayd = df_months.tail(30)\nemayd = emayd.reset_index()","bed8d4db":"import plotly.graph_objects as go\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=emayd['Date'],\n    y=emayd['AvgTemperature'],\n    name=\"Actual AvgTemperature\"\n))\n\nfig.add_trace(go.Scatter(\n    x=emayd['Date'],\n    y=emayd['ewm'],\n    name=\"Exponential Smoothing\"\n))\n\nfig.update_layout(\n    title=\"AvgTemperature - Actual vs Exponential Smoothing of Delhi for the Month of Apr 2020\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"Avg Temperature\",\n    font=dict(\n        family=\"Courier New, monospace\",\n        size=9.5,\n        color=\"#7f7f7f\"\n    )\n)\n\nfig.show()","851cf381":"import plotly.graph_objects as go\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=emayd['Date'],\n    y=emayd['AvgTemperature'],\n    name=\"Actual AvgTemperature\"\n))\n\n\nfig.add_trace(go.Scatter(\n    x=emayd['Date'],\n    y=emayd['mavg_12'],\n    name=\"Moving Average AvgTemperature\"\n))\n\nfig.add_trace(go.Scatter(\n    x=emayd['Date'],\n    y=emayd['ewm'],\n    name=\"Exponential Smoothing AvgTemperature\"\n))\n\nfig.update_layout(\n    title=\"Avg Temp. - Actual vs vs Moving Average vs Exponential Smoothing of Delhi for the Month of April 2020\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"Avg Temperature\",\n    font=dict(\n        family=\"Courier New, monospace\",\n        size=9.5,\n        color=\"#7f7f7f\"\n    )\n)\n\nfig.show()","a2c20a2f":"df_months1 = df_months.reset_index()\nfrom statsmodels.tsa.seasonal import seasonal_decompose\n\n# Multiplicative Decomposition \n#result_mul = seasonal_decompose(df_months['AvgTemperature'], model='multiplicative', extrapolate_trend = 'freq', freq=12)\n\n# Additive Decomposition\nresult_add = seasonal_decompose(df_months['AvgTemperature'], model='additive', extrapolate_trend = 'freq', freq=12)\n\n# Plot\nplt.rcParams.update({'figure.figsize': (10,10)})","c8ea1c07":"#result_mul.plot().suptitle('Multiplicative Decompose', fontsize=15)","ed81baa4":"result_add.plot().suptitle('Additive Decompose', fontsize=15)","8d7e3203":"#vwap_itc_2020['mul_seasonal'] = result_mul.seasonal\n#vwap_itc_2020['mul_trend'] = result_mul.trend\ndf_months['add_seasonal'] = result_add.seasonal\ndf_months['add_trend'] = result_add.trend","2f7b4364":"import plotly.graph_objects as go\nfig = go.Figure()\n\ndf_monthsd = df_months.reset_index()\n\nfig.add_trace(go.Scatter(\n    x=df_monthsd['Date'],\n    y=df_monthsd['add_seasonal'],\n    name=\"Additive Seasonal Component\"\n))\n\nfig.update_layout(\n    title=\"Seasonal Component\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"AvgTemperature\",\n    font=dict(\n        family=\"Courier New, monospace\",\n        size=10.5,\n        color=\"#7f7f7f\"\n    )\n)\n\nfig.show()","8e92ebee":"import plotly.graph_objects as go\nfig = go.Figure()\n\ndf_monthsd = df_monthsd.reset_index()\n\nfig.add_trace(go.Scatter(\n    x=df_monthsd['Date'],\n    y=df_monthsd['add_trend'],\n    name=\"Additive Trend\"\n))\n\nfig.update_layout(\n    title=\"Trend Component\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"AvgTemperature\",\n    font=dict(\n        family=\"Courier New, monospace\",\n        size=10.5,\n        color=\"#7f7f7f\"\n    )\n)\n\nfig.show()","1b114aa3":"#ACF plot to show auto-correlation upto lag of 20\n    \nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nplt.rcParams.update({'figure.figsize': (10,6)})\nacf_plot = plot_acf(df_monthsd.AvgTemperature, lags=20)","750284b5":"plt.rcParams.update({'figure.figsize': (10,6)})\n\nacf_plot = plot_pacf(df_monthsd.AvgTemperature, lags=20)","2cff17f7":"from statsmodels.tsa.arima_model import ARIMA\narima = ARIMA(df_monthsd.AvgTemperature[0:821].astype(np.float64), order = (1,0,0))\narima1 = ARIMA(df_monthsd.AvgTemperature[0:821].astype(np.float64), order = (0,0,0))\nar_model = arima.fit()\nar_model1 = arima1.fit()\nar_model.summary2()","f9d699ae":"forecast_arima = ar_model.predict(821, 849)\nforecast_arima1 = ar_model1.predict(821, 849)\n\nget_mape(df_monthsd.AvgTemperature[821:850].values, forecast_arima.values)","5f841001":"get_mape(df_monthsd.AvgTemperature[821:850].values, forecast_arima1.values)","f22275b5":"arima = ARIMA(df_monthsd.AvgTemperature[0:821].astype(np.float64), order = (0,0,1))\nma_model = arima.fit()\nma_model.summary2()","e7d79455":"forecast_arima = ma_model.predict(821, 849)\n\nget_mape(df_monthsd.AvgTemperature[821:850].values, forecast_arima.values)","04323140":"arima = ARIMA(df_monthsd.AvgTemperature[0:821].astype(np.float64), order = (1,0,1)) \narma_model = arima.fit() \narma_model.summary2()","28877e09":"forecast_arma = arma_model.predict(821, 849)\nget_mape(df_monthsd.AvgTemperature[821:850].values, forecast_arma.values)","82f29a3d":"from statsmodels.tsa.stattools import adfuller\n\ndef adfuller_test(ts): \n    adfuller_result = adfuller(ts, autolag=None)\n    adfuller_out = pd.Series(adfuller_result[0:4],\n                             index=['Test Statistic', 'p-value', 'Lags Used', 'Number of Observations Used'])\n    print(adfuller_out)","d9aea4e5":"adfuller_test(df_monthsd.AvgTemperature)","8bd7b8f6":"df_monthsd['vdiff'] = df_monthsd.AvgTemperature - df_monthsd.AvgTemperature.shift(1)\ndf_monthsd.head(5)\ndf_monthsd = df_monthsd.dropna()","cf7916ed":"import plotly.graph_objects as go\nfig = go.Figure()\n\ndf_monthsd = df_monthsd.reset_index()\n\nfig.add_trace(go.Scatter(\n    x=df_monthsd['Date'],\n    y=df_monthsd['vdiff'],\n    name=\"First-Order Differencing\"\n))\n\nfig.update_layout(\n    xaxis_title=\"Date\",\n    yaxis_title=\"First-order difference\",\n    font=dict(\n        family=\"Courier New, monospace\",\n        size=12,\n        color=\"#7f7f7f\"\n    )\n)\n\nfig.show()","7fe61035":"pacf_plot = plot_acf(df_monthsd.vdiff.dropna(), lags=10)","33ddc5c8":"arima = ARIMA(df_monthsd.AvgTemperature[0:821].astype(np.float64), order = (1,1,1)) \narima_model = arima.fit()\narima_model.summary2()","64050292":"predict, stderr, ci = arima_model.forecast(steps=18)\nget_mape(df_monthsd.AvgTemperature[821:850].values, predict)","55fd20bc":"### The mape is high","ee17c15e":"<div class=\"alert alert-block alert-info\">\n\n### Differencing","f81c32a9":"<div class=\"alert alert-block alert-info\">\n\n#### Building an AR Model","cf32232a":"<a id=\"eda\"><\/a>\n\n### EDA","98e3184f":"### Forecast with P = 0 ","422749f4":"<div class=\"alert alert-block alert-warning\">\n\n<a id=\"tc\"><\/a>\n\n### Forecasting Techniques","ba9354ee":"The shaded area represents the upper and lower bounds for critical values, where the null hypothesis cannot be\nrejected (auto-correlation value is 0). ","ca3ea95f":"#### The MAPE in this case is 4.57. I would say its a decent number. ","e5e95f7e":"<div class=\"alert alert-block alert-info\">\n\n### We build a basic arima model with d=1(first-order differencing)","e351e22a":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"dts\"><\/a>\n\n### DECOMPOSING TIME SERIES","ed09d250":"### TIMELINE PLOT","a13c56c0":"<div class=\"alert alert-block alert-warning\">\n\n#### So, we will extract Delhi's data from the dataset for the last 2 years and try and forecast the average temperature for the month of April 2020 - using basic time-series techniques mentioned above.\n\n### But before that, lets take a look at;","af17e5bd":"<div class=\"alert alert-block alert-warning\">\n\n### End of Basics - Will add more approaches like SARIMAX which takes seasonal component into consideration to this notebook and more. Do upvote! ","5a4c8bbb":"<div class=\"alert alert-block alert-info\">\n\n### Visualizing Trend and Seasonal Component","15e7533e":"<div class=\"alert alert-block alert-warning\">\n\nPartial auto-correlation of lag k is the correlation between Yt and Yt\u2212k when the influence of all \nintermediate values (Yt\u22121, Yt\u22122, \u2026, Yt\u2212k+1) is removed (partial out) from both Yt and Yt\u2212k. \n\nA plot of partial auto-correlation for different values of k is called partial auto-correlation function (PACF). \n\nstatsmodels.graphics.tsaplots.plot_pacf plots the partial auto-correlation plot.","cf2ef9b0":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"arimaa\"><\/a>\n\n### ARIMA Model","b833c929":"<div class=\"alert alert-block alert-info\">\n### Forecasting using the d component","eedbc8b5":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"mv\"><\/a>\n\n### Forecasting using Moving Average","93a101d6":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"ar\"><\/a>\n\n### AR Models","3ef15064":"<div class=\"alert alert-block alert-warning\">\n\nMA processes are regression models in which the past residuals are used for forecasting future values of the time-series data. \n\nA moving average process of lag 1 can be written as\n\n\n![](https:\/\/github.com\/rakash\/images1\/blob\/master\/ma1.png?raw=true)\n\nThe value of q (number of lags) in a moving average process can be identified using the following rules:\n\n1. Auto-correlation value is significant for first q lags and cuts off to zero. \n\n2. The PACF decreases exponentially. \n\nBuilding a baseline with q=1","d9309d34":"<div class=\"alert alert-block alert-info\">\n\n### Plotting the first-order difference values","6b18e000":"### Multiplicative Decompose is not appropriate for -ve values and we have - 99 in our delhi dataset. So decomposing using additive model","4cf07b9f":"<div class=\"alert alert-block alert-warning\">\n\nAuto-correlation of lag k is the correlation between Yt and Yt\u2013k measured at different k values \n(e.g., Yt and Yt\u22121 or Yt and Yt\u22122). \n\nA plot of auto-correlation for different values of k is called an auto-correlation function \n(ACF) or correlogram. \n\n#### statsmodels.graphics.tsaplots.plot_acf plots the autocorrelation plot.","e19e2aa7":"<div class=\"alert alert-block alert-info\">\n\n### PACF","88af73b9":"<div class=\"alert alert-block alert-warning\">\n\nTo select the appropriate p in the AR model, the following thumb rule can be used:\n\n1. The partial auto-correlation is significant for first p-values (first p lags) and cuts off to zero.\n\n2. The ACF decreases exponentially. (Signs of stationarity).","0ed944b4":"<div class=\"alert alert-block alert-warning\">\n\nThe p-value (>0.05) indicates that we cannot reject the null hypothesis and hence, the series is not stationary. \n\nDifferencing the original time series is an usual approach for converting the non-stationary process into a stationary process (called difference stationarity). \n\nFor example, the first difference (d = 1) is the difference between consecutive values of the time series (Yt). That is, the first difference is given by\n\n![](https:\/\/github.com\/rakash\/images1\/blob\/master\/dk1.png?raw=true)","2ace4b6a":"### The ACF plot for the same","908cbe74":"<div class=\"alert alert-block alert-warning\">\n### So, The ARIMA model with first-order differencing gives forecast accuracy of approximately 9%.","bea0d3b7":"<div class=\"alert alert-block alert-info\">\n\n### Extracting only the seasonal and trend component for the last 2 years","fdc77e09":"<div class=\"alert alert-block alert-info\">\n### Finding if a series is Stationary","f61e7a15":"<div class=\"alert alert-block alert-warning\">\n\nThe time-series data can be modelled as addition or product of trend, seasonality, cyclical, and irregular components.\nThe additive time-series model is given by \n\n        Yt = Tt + St + Ct + It\n\nThe additive models assume that the seasonal and cyclical components are independent of the trend component.\nAdditive models are not very common, since in many cases the seasonal component may not be independent of the trend. \n\nA small example:\n\nThe seasonality effect on sales during festival times like Diwali does not result in constant increase in sales over the years. For example, the increase in sales of cars during festival season is not just 100 units every year. The seasonality effect has a multiplicative effect on sales based on the trend over the years like 10% additional units based on the trend in the current year. So, in many cases the seasonality effect is multiplied with the trend and not just added as in additive model. \n\nThe multiplicative time-series model is given by\n\n        Yt = Tt \u00d7 St \u00d7 Ct \u00d7 It\n        \n \n \nFor decomposing a time-series data, we can leverage the following libraries:\n1. statsmodel.tsa provides various features for time-series analysis. \n2. seasonal_decompose() in statsmodel.tsa.seasonal decomposes a time series into trend, seasonal, and residuals. It takes frequency parameters; for example, the frequency is 12 for monthly data.","0a3f0e29":"<div class=\"alert alert-block alert-warning\">\n\n### Mean Absolute Percentage Error\n\n\nMean absolute percentage error (MAPE) is the average of absolute percentage error.\nAssume that the validation data has n observations and forecasting is carried out on these n observations. \nThe mean absolute percentage error is given by\n\n![](https:\/\/github.com\/rakash\/images1\/blob\/master\/mape.png?raw=true)","5d2f91c2":"<div class=\"alert alert-block alert-warning\">\n\nAuto-regressive moving average (ARMA) is a combination auto-regressive and moving average process. \nARMA(p, q) process combines AR(p) and MA(q) processes.\nThe values of p and q in an ARMA process can be identified using the following thumb rules:\n    \n1. Auto-correlation values are significant for first q values (first q lags) and cuts off to zero. \n2. Partial auto-correlation values are significant for first p values and cuts off to zero.","36e5d565":"<div class=\"alert alert-block alert-info\">\n\n#### What is Stationary data?\n\nTime-series data should satisfy the following conditions to be stationary: \n    \n1. The mean values of Yt at different values of t are constant. \n2. The variances of Yt at different time periods are constant (Homoscedasticity). \n3. The covariance of Yt and Yt\u2212k for different lags depend only on k and not on time t.","b148f6ac":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"exps\"><\/a>\n\n### Forecasting using Exponential Smoothing","c45cdc07":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"summ\"><\/a>\n\n### Summary:\n\n1. Several techniques such as moving average, exponential smoothing, and auto-regressive models are used for forecasting future value of Yt. \n\n2. The forecasting models are mostly validated using accuracy measures such as RMSE and MAPE. \n\n3. Auto-regressive (AR) models are regression-based models in which dependent variable is Yt and the independent variables are Yt\u22121, Yt\u22122, etc. \n\n4. AR models can be used only when the data is stationary.\n\n5. Moving average (MA) models are regression models in which the independent variables are past error values. \n\n6. Auto-regressive integrated moving average (ARIMA) has three components: \n    a. Auto-regressive component with p lags \u2212 AR(p) \n    b. Moving average component with q lags \u2212 MA(q) \n    c. Integration which is differencing the original data to make it stationary (denoted by d)","e7361a0d":"### Additive Decompose","d1ca892d":"<div class=\"alert alert-block alert-warning\">\n\nstatsmodels.tsa.arima_model.ARIMA can be used to build AR model.\n\nIt takes the following two parameters:\n\n1. endog: list of values \u2013 It is the endogenous variable of the time series. \n\n2. order: The (p, d, q) \u2013 ARIMA model parameters. Order of AR is given by the value p, the order of integration is d, and the order of MA is given by q.","f865bb5a":"<div class=\"alert alert-block alert-info\">\n\n- The time-series data Y(t) is a random variable, usually collected at regular time intervals and in chronological order.\n- If the time-series data contains observations of just a single variable (such as demand of a product at time t), \nthen it is termed as univariate time-series data. \n\n- If the data consists of more than one variable, \nfor example, demand for a product at time t, price at time t, amount of money spent by the company on promotion at time t, \ncompetitors\u2019 price at time t, etc., then it is called multivariate timeseries data. \n\nA time-series data can be broken into the four following components:\n\n- Trend Component - Trend is the consistent long-term upward or downward movement of the data. \n- Seasonal Component (St): Seasonal component (measured using seasonality index) is the repetitive upward or downward movement (or fluctuations) from the trend that occurs within a calendar year at fixed intervals (i.e., time between seasons is fixed) such as seasons, quarters, months, days of the week, etc. The upward or downward fluctuation may be caused due to festivals, customs within a society,  school holidays, business practices within the market such as \u201cend of season sale\u201d, and so on.\n- Cyclical Component (Ct): Cyclical component is fluctuation around the trend line at random interval \n   (i.e., the time between cycles is random) that happens due to macro-economic changes such as recession, unemployment,\n   etc. Cyclical fluctuations have repetitive patterns with time between repetitions of more than a year.\n   Whereas in the case of seasonality, the fluctuations are observed within a calendar year and are driven by factors such as     festivals and customs that exist in a society. A major difference between seasonal fluctuation and cyclical fluctuation is that seasonal fluctuation occurs at fixed period within a calendar year, whereas cyclical fluctuations have random time between fluctuations. That is, the periodicity of seasonal fluctuations is constant, whereas the periodicity of cyclical fluctuations is not constant.\n- Irregular Component (It): Irregular component is the white noise or random uncorrelated changes that follow a normal distribution with mean value of 0 and constant variance.    ","9796b8dc":"<div class=\"alert alert-block alert-warning\">\n\nOne of the drawbacks of the simple moving average technique is that it gives equal weight to all the previous observations used in forecasting the future value. Exponential smoothing technique (also known as simple exponential smoothing; SES) assigns differential weights to past observations;\n\nEquation:\n\n![](https:\/\/github.com\/rakash\/images1\/blob\/master\/exp.png?raw=true)\n\n\nwhere \u03b1 is called the smoothing constant, and its value lies between 0 and 1. Ft+1 is the forecasted value at time t + 1 using actual value Yt at time t and forecasted values Ft of time t. But the model applies differential weights to both the inputs using smoothing constant \u03b1.\n\n\nThe ewm() method in Pandas provides the features for computing the exponential moving average taking alpha as a parameter.","225153df":"<div class=\"alert alert-block alert-warning\">\n\nARMA models can be used only when the time-series data is stationary. \nARIMA models are used when the time-series data is non-stationary. \nTime-series data is called stationary if the mean, variance, and covariance are constant over time. \n\n\nARIMA has the following three components and is represented as ARIMA (p, d, q): \n1. AR component with p lags AR(p). \n2. Integration component (d). \n3. MA with q lags, MA(q).\n\n\nThe main objective of the integration component is to convert a non-stationary time-series process to a stationary process so that the AR and MA processes can be used for forecasting.","11ddd533":"#### The Mape seems to be the same as AR(1) model. ","559eb933":"<div class=\"alert alert-block alert-warning\">\n\nAuto-regression is a regression of a variable on itself measured at different time points. Auto-regressive model with lag 1,\nAR (1), is given by\n\n\n![](https:\/\/github.com\/rakash\/images1\/blob\/master\/ar1.png?raw=true)\n\nThe above equation can be generalized to include p lags and is called a AR(p) model. The Equation can be re-written as;\n\n\n![](https:\/\/github.com\/rakash\/images1\/blob\/master\/ar2.png?raw=true)\n\n\nwhere et+1 is a sequence of uncorrelated residuals assumed to follow the normal distribution with zero mean and constant standard deviation. \n\n(Yt \u2212 m) can be interpreted as a deviation from mean value m; it is known as mean centered series.\n\nOne of the important tasks in using the AR model in forecasting is model identification, which is, identifying the value of p (the number of lags). \n\nOne of the standard approaches used for model identification is using\n    - auto-correlation function (ACF) and \n    - partial auto-correlation function (PACF)","edeafcf6":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"arima\"><\/a>\n\n### AUTO-REGRESSIVE INTEGRATED MOVING AVERAGE MODELS","950cea36":"<div class=\"alert alert-block alert-warning\">\n\nFirst difference between consecutive Yt values can be computed by subtracting the previous day\u2019s value from that day\u2019s value.\n\nWe can use shift() function in Pandas to shift the values before subtracting. ","fd83f38e":"#### IMPORTANT: Moving average and Exponential smoothing assume a fairly steady time-series data with no significant trend, seasonal or cyclical components, that is, the data is stationary.\n\n#### However, many dataset will have trend and seasonality.","eec72288":"<div class=\"alert alert-block alert-warning\">\n\nTo find out if a time series is stationary, Dickey\u2212Fuller test can also be conducted.\n\nDickey\u2013Fuller test checks whether the b in the equation in AR model section above is equal to 1 or less than equal to 1. \n\nEquation: ![](https:\/\/github.com\/rakash\/images1\/blob\/master\/ar1.png?raw=true)\n\nIt is a hypothesis test in which the null hypothesis and alternative hypothesis are given by,\n\nH0: b = 1 (the time series is non-stationary)\nHA: b < 1 (the time series is stationary)\n    \nstatsmodels.tsa.stattools.adfuller is a Dicky\u2212Fuller test and returns test statistics and p-value for the test of the null hypothesis.\n\nIf the p-value is less than 0.05, the time series is stationary.","cc618eb1":"<div class=\"alert alert-block alert-warning\">\n\nMoving average is one of the simplest forecasting techniques which forecasts the future value of a timeseries data using average (or weighted average) of the past N observations. \n\nForecasted value for time t +1 using the simple moving average is given by\n        \n![](https:\/\/github.com\/rakash\/images1\/blob\/master\/fma.png?raw=true)\n            \nPandas has a function rolling() which can be used with an aggregate function like mean() for calculating moving average for a time window. \n\nFor example, to calculate 12 month\u2019s moving average using last 12 months\u2019 data starting from last month (previous period), rolling() will take a parameter window, which is set to 12 to indicate moving average of 12-months data, and then use Pandas\u2019 shift() function, which takes parameter 1 to specify that the 12-months data should start from last month. \n\nshift(1) means calculating moving average for the specified window period starting from previous observation (in this case last month).\n\n\nHere, we will take data from 2018 Jan to 2020 March, to forecast Avg Temperature of April 2020 using Moving Average","0598f84e":"<div class=\"alert alert-block alert-warning\">\n\nAuto-regressive (AR) and moving average (MA) models are popular models that are frequently used for forecasting.\nAR and MA models are combined to create models such as auto-regressive moving average (ARMA) and auto-regressive\nintegrated moving average (ARIMA) models. \n\nARMA models are basically regression models. \n\nAuto-regression simply means regression of a variable on itself measured at different time periods. We will discuss each component in the subsequent sections.","587c7742":"# CONTENTS\n\n1. [EDA](#eda)\n\n2. [Components of Time series](#cmp)\n\n3. [Models](#tc)\n\n   3.1 [Moving Average](#mv)\n   3.2 [Exponential Smoothing](#exps)\n\n4. [Decomposing Time Series](dts)\n\n5. [ARIMA](#arima)\n\n   5.1 [AR Model](#ar)\n   5.2 [MA Model](#ma)\n   5.3 [ARMA](#arma)\n   5.4 [ARIMA](#arimaa)\n\n6. [Summary](#summ)","f141d473":"<div class=\"alert alert-block alert-info\">\n\nThere are several techniques, the famous ones being;\n    - Moving average, \n    - Exponential smoothing, and \n    - AutoRegressive Integrated Moving Average (ARIMA)\n    \nMoving average and exponential smoothing predict the future value of a time-series data as a function of past observations. \n\nThe regression-based models such as auto-regressive (AR), auto-regressive and moving average (ARMA), \nauto-regressive integrated moving average (ARIMA) use more sophisticated regression models. ","25aa6ae2":"<div class=\"alert alert-block alert-info\">\n\n### Forecasting and measuring accuracy","38b6fe0d":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"arma\"><\/a>\n\n### Building an ARMA MODEL","f852c271":"<div class=\"alert alert-block alert-info\">\n\n### ACF","66106780":"<div class=\"alert alert-block alert-warning\">\n\n<a id=\"cmp\"><\/a>\n\n### Components of Time-Series Data","a21d08ed":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"arma\"><\/a>\n\n### Building the ARMA Model","4f89cd45":"<div class=\"alert alert-block alert-warning\">\n\n### Root mean square error (RMSE)\n\nis the square root of average of squared error calculated over the validation dataset, and is the standard deviation of the errors for unbiased estimator.\n\nRMSE is given by\n\n![](https:\/\/github.com\/rakash\/images1\/blob\/master\/rmse.png?raw=true)\n\n\nLower RMSE implies better prediction. However, it depends on the scale of the time-series data.\n\nMSE (Mean Squared Error) can be calculated using mean_squared_error() method in sklearn.metrics.\n\nWe can pass MSE value to np.sqrt() to calculate RMSE.","8ce85d77":"<div class=\"alert alert-block alert-info\">\n\n<a id=\"ma\"><\/a>\n\n### Building an MA Model","53ad0245":"<div class=\"alert alert-block alert-info\">\n\n### Calculating Forecast Accuracy\n\n\nRoot mean square error (RMSE) and mean absolute percentage error (MAPE) are the two most popular accuracy measures of forecasting. We will be discussing these measures in this section.","522d236e":"<div class=\"alert alert-block alert-warning\">\n\n### In this Notebook, we will look at,\n\n1. Various components of time-series data such as trend, seasonality, cyclical component, and random component. \n\n2. Moving Average, Exponenial Smoothing, Auto-Regressive (AR), Moving Average (MA), and Auto-Regressive Integrated Moving Average (ARIMA) models.\n\n3. Build forecasting models in Python using the above on a specfic regions' temperature data","18e758a2":"### A little higher than the moving average Mape value"}}