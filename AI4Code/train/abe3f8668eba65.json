{"cell_type":{"ca72b167":"code","f9c456a4":"code","a4c72841":"code","1a8d0e06":"code","228f8e4c":"code","572ee8e4":"code","d9c9f361":"code","f4e2541c":"code","0fcf572b":"code","bebf20b0":"code","53fa9a46":"code","f6ecc93b":"code","e15b888c":"code","22e664e3":"code","7904d62f":"code","e2a91cc3":"code","1f13a753":"code","c9eed8ce":"code","c5a9efc0":"code","543d7ef4":"code","d77efe13":"code","7b57177f":"code","c9f77110":"code","b31c1583":"markdown","f47630bc":"markdown","78d7c295":"markdown","c307c112":"markdown","a5d51503":"markdown"},"source":{"ca72b167":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","f9c456a4":"df = pd.read_csv(\"..\/input\/netflix-shows\/netflix_titles.csv\")","a4c72841":"df.head(10)","1a8d0e06":"# Let's see how big the data is\ndf.shape","228f8e4c":"# Okay, let's clean the data. In other words, let me just keep the columns that I will be using and delete all the unneccesary columns.\n# drop show_id column\ndf.drop(columns = [\"show_id\"], inplace = True)\ndf.head()","572ee8e4":"# Great! I have deleted all the columns (even though it is a column)! Let's divide date_added in more detail into years, month and day.\ndf[[\"month_added\", \"day_added\", \"year_added\", \"null1\"]] = df[\"date_added\"].str.split(\" \", expand = True)\n","d9c9f361":"# delete null1 columns and get rid of \",\" from day_added column\ndf.drop(columns = [\"null1\"], inplace = True)\ndf[\"day_added\"] = df[\"day_added\"].str.replace(',','')\ndf.head()","f4e2541c":"# Let's reorder the columns and delete date_added column\ndf.columns","0fcf572b":"df = df[['type', 'title', 'country', 'month_added', 'day_added', 'year_added',\n       'release_year', 'rating', 'duration', 'listed_in', 'description',\n        'director', 'cast']]","bebf20b0":"df.head(5)","53fa9a46":"# let's perform basic EAD to understand the data first. we will be suing plotly\n\nimport plotly.graph_objects as go\nimport math\ndf_type = pd.DataFrame(df[\"type\"].value_counts())\ndf_type\n\nfig = go.Figure(data=go.Bar(x = df_type.index, y = df_type[\"type\"]))\nfig.show()\n\n\"{:.2f}\".format(13.949999999999999)\n\nprint(f' Netflix has more {float((df_type.loc[\"Movie\"] \/ df_type.loc[\"TV Show\"]))} times more movie than TV Shows.')\n# netflix has more 2.23 times more movies than TV Shows","f6ecc93b":"# EAD for country\ndf_country = pd.DataFrame(df[\"country\"].value_counts())\ndf_country.head()","e15b888c":"# Let's examine how many countries we have\ndf_country.shape\n# we will be only visualize for top 15 countries\ndf_country.sort_values(by = [\"country\"], ascending = False, inplace = True)\ndf_count15 = df_country.head(15)","22e664e3":"from plotly.subplots import make_subplots\n# Let's do ead for the df_country\nfig = go.Figure(data=go.Bar(x = df_count15.index, y = df_count15[\"country\"]))\n\nfig = make_subplots(rows=1, cols=2, column_widths=[0.7, 0.3])\n\nfig.add_trace(go.Bar(x=df_count15.index, y=df_count15[\"country\"]),\n              row=1, col=1)\n\nfig.add_trace(go.Scatter(x=df_count15.index, y=df_count15[\"country\"]),\n              row=1, col=2)\n\nfig.show()","7904d62f":"# How about the rating?\n# EAD for country\ndf_rating = pd.DataFrame(df[\"rating\"].value_counts())\ndf_rating.head()\n\nfig = go.Figure(data=[go.Pie(labels=df_rating.index, values=df_rating['rating'])])\nfig.show()","e2a91cc3":"# Now we want to explore listed_in column\n# First of all let's figure out how many unique categories we have\nimport re\nmerged_cat = \"\"\n# merge all the column into a string\nfor i in df[\"listed_in\"]:\n    merged_cat += i\n    merged_cat += \"@\"\n# split the list with , & and @\nmerged = re.split(', |&|@',merged_cat)\n# get rid of space\nmerged = [i.strip() for i in merged]\nprint(f\"in total we have {df.shape[0]} tv series and movies and overall it is defined by {len(merged)} which accounts for {len(merged)\/ df.shape[0]} per show\")","1f13a753":"# let's visualize what type of tv show or movie is listed in netflix the most?\nlist_value = pd.DataFrame(merged).value_counts()\nlist_value = pd.DataFrame(list_value)\nlist_value.columns = [\"list\"]\ntype(list(list_value.index)[0][0])\na = [i[0] for i in list(list_value.index)]\na\nfig = go.Figure(data=go.Bar(x = a, y = list_value[\"list\"]))\nfig.show()","c9eed8ce":"# The below is the top 10 netflix show category\n#list_value = list_value[\"list\"] \/ df.shape[0]\nlist_value.head(10)","c5a9efc0":"# Now we will check the release year\ndf_release = df[[\"year_added\",\"type\"]]\ndf_release[\"dummy\"] = 1\ndf_release\ntable = pd.pivot_table(df_release, values = \"dummy\",\n                      index = [\"year_added\"],columns = [\"type\"],aggfunc=np.sum)\ntable.fillna(0, inplace = True)\n\ndate = np.arange(2008, 2022, 1)\n\n#list(table[\"year_added\"]).index(2008)\n\n# list(table.index).index(\"2008\")\n# 12 - 25\n\n\ntable[\"Movie\"][12:26]\n\n\nfig = make_subplots(rows=1, cols=2, column_widths=[0.5, 0.5])\n\nfig.add_trace(go.Bar(x= date, y=table[\"Movie\"][12:26]),\n              row=1, col=1)\n\nfig.add_trace(go.Bar(x=date, y=table[\"TV Show\"][12:26]),\n              row=1, col=2)\n\nfig.show()\n\nprint(\"Trace 0 is Movie and Trace 1 is TV Show. We can see that number of TV show is increasing whereas Movie has decrease from 2020\")","543d7ef4":"a = df.groupby(by = \"year_added\").count()[\"type\"]\na = pd.DataFrame(a)\ndate = list(map(str,np.arange(2016,2022,1)))\nadded_per = float(a.loc[date].sum() \/ a.sum()) * 100\nprint(f' {\"{:.2f}\".format(added_per)} % of movie and tv shows were added between 2016 - 2021 so we will only examine the movie and tv shows that were released after 2016')\n","d77efe13":"df_newMovie = df[df['release_year'] > 2015]\n# make sure to convert all the columns into int\nprev_size = df_newMovie.shape[0]\nprint(df_newMovie.shape[0])\ndf_newMovie[\"year_added\"] = list(map(str, df_newMovie[\"year_added\"]))\ndf_newMovie[\"year_added\"].value_counts()\ndf_newMovie[\"year_added\"] = list(map(str.strip, df_newMovie[\"year_added\"]))\ndf_newMovie[\"year_added_len\"] = list(map(len, df_newMovie[\"year_added\"]))\ndf_newMovie = df_newMovie[df_newMovie[\"year_added_len\"]==4]\nnew_size = (df_newMovie.shape[0])\nprint(df_newMovie.shape)\nprint(f' {prev_size - new_size} row has been deleted')\ndf_newMovie[\"year_added\"] = list(map(int, df_newMovie[\"year_added\"]))\ndf_newMovie[\"fast\"] = df_newMovie[\"year_added\"] - df_newMovie[\"release_year\"]\n\n","7b57177f":"df_newMovie[\"fast\"].value_counts()\n","c9f77110":"df_title = pd.read_csv(\"..\/input\/titletsv\/title.tsv\", sep = \"\/t\")\n# ..\/input\/netflix-shows\n# ..\/input\/titletsv\n# ..\/input\/netflix-shows","b31c1583":"### Now I have a interesting hypothesis : If movie or tv show is {good}, then Netflix will {add to their website fast}\n\nLet's see my hyphothesis is true!\n\nHere we have two term that we have to define\n\nGood -> Good rating in Rotten Tomato (need to pull out from different data set)\nadd to their website fast -> added_year - release_year (we can make an additional column)\n\nTo Be Continue....","f47630bc":"Okay we Finally got the \"Fast\" Columns. Let's see how it looks like","78d7c295":"Let's explore the data first","c307c112":"As we all know, Let's import the data!","a5d51503":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session"}}