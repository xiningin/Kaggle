{"cell_type":{"60b28663":"code","2f8012cb":"markdown"},"source":{"60b28663":"# Script is developed by Ali (at MSE):\n# https:\/\/math.stackexchange.com\/a\/4352909\/993738\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport plotly.graph_objects as go\n\ndef weights(z, x, m):\n    n = len(x) - 1\n    c1 = 1.\n    c4 = x[0] - z\n    c = np.zeros((n + 1, m + 1), dtype=float)\n    c[0, 0] = 1.\n    for i in range(n + 1):\n        mn = min(i, m)\n        c2 = 1.\n        c5 = c4\n        c4 = x[i] - z\n        for j in range(i):\n            c3 = x[i] - x[j]\n            c2 = c2 * c3\n            if j == i - 1:\n                for k in range(mn, 0, -1):\n                    c[i, k] = c1 * (k * c[i - 1, k - 1] - c5 * c[i - 1, k]) \/ c2\n                c[i, 0] = -c1 * c5 * c[i - 1, 0] \/ c2\n            for k in range(mn, 0, -1):\n                c[j, k] = (c4 * c[j, k] - k * c[j, k - 1]) \/ c3\n            c[j, 0] = c4 * c[j, 0] \/ c3\n        c1 = c2\n    return c\n\nT = 0.5\nn = 500  # The number of time steps.\ndt = T \/ n\n\nN = 50  # The number of collocation points in the spatial dimension.\nbeta = 1\n\nx = 3 * np.cos(np.linspace(-np.pi, 0, N))\nw = [weights(xi, x, 2) for xi in x]\nD = np.array([c[:, 1] for c in w])\nD2 = np.array([c[:, 2] for c in w])\n\nA = np.diag(1 - (12 * (x ** 2) - 4) * dt) -\\\n    (4 * x * (x ** 2 - 1) + 0.1) * dt * D - (1 \/ beta) * dt * D @ D\nA = A[1:N-1, 1:N-1]  # That the boundary conditions are zero makes things simple.\n\ndef step(p):\n    b = p[1:N-1]\n    return np.hstack([0, np.linalg.solve(A, b), 0])\n\n# Grid Vars\nx_min = -3\nx_max = 3\n\ny_min = 0\ny_max = 0.5\n\nx_grid = np.linspace(x_min, x_max, 100)\nw = np.array([weights(gi, x, 0) for gi in x_grid]).reshape(100, N)\nz = []\n\np = np.exp(-(x ** 2) \/ 2) \/ np.sqrt(2 * np.pi)\nz.append(w @ p)\n\nfor i in range(n):\n    p = step(p)\n    z.append(w @ p)\n\ny_grid = np.linspace(y_min, y_max, n + 1)\n\nfig = go.Figure(data=[go.Surface(\n    contours = {\n        \"x\": {\"show\": True, \"color\":\"white\"},\n        \"y\": {\"show\": True, \"color\":\"white\"},\n        \"z\": {\"show\": True, \"color\":\"white\"}\n    },\n    x=x_grid,\n    y=y_grid,\n    z=z,\n    colorscale='Viridis',\n    showscale=False,\n    lighting=dict(roughness=0.9))])\nfig.update_layout(title='Spectral Method', autosize=False,\n                  width=500, height=500,\n                  margin=dict(l=65, r=50, b=65, t=90))\nfig.update_traces(contours_z=dict(show=True, usecolormap=True, highlightcolor=\"limegreen\", project_z=True))\nfig.show()\n\n#fig, ax = plt.subplots()\n#ax.plot(grid, w @ p)","2f8012cb":"Inspired by [this question](https:\/\/math.stackexchange.com\/questions\/4352292\/solving-a-parabolic-pde-numerically-with-the-spectral-method) Ali developed a Python Script for solving the following PDE on $x \\in [-3, 3]$ and $t \\in [0, 0.5]$ using the Spectral Method:\n\n$$\n\\frac{\\partial p}{\\partial t} = (12x^2-4) p + \\left[4x(x^2-1)+0.1\\right] \\frac{\\partial p}{\\partial x} + \\frac{1}{\\beta} \\frac{\\partial^2 p}{\\partial x^2} \\\\\n$$\n\nThe initial condition is $p(x,0)=\\frac{1}{\\sqrt{2\\pi}} \\exp(-\\frac{x^2}{2})$ and the zero boundary condition is $p(-3,t)=p(3,t)=0$."}}