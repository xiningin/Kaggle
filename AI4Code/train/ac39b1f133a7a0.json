{"cell_type":{"32ac518d":"code","5f1ccf1b":"code","a8983763":"code","9e54d3ea":"code","d0b85631":"code","0f5acfd3":"code","a7e5b499":"code","24e84f19":"code","3da77891":"code","154317ed":"markdown","af1eac36":"markdown","f260c1b8":"markdown","f6c6fa1b":"markdown","796847e2":"markdown"},"source":{"32ac518d":"import numpy as np\nimport pandas as pd\nimport cvxpy as cvx\nfrom plotly.offline import iplot, init_notebook_mode\ninit_notebook_mode(connected=True)","5f1ccf1b":"results_2019_raw = pd.read_csv(\"..\/input\/votes per settlement 2019 - hebrew.csv\", encoding='iso_8859_8')\nresults_2019_raw.set_index('\u05e9\u05dd \u05d9\u05e9\u05d5\u05d1',inplace=True)\nresults_2019_raw.head()","a8983763":"results_2015_raw = pd.read_csv(\"..\/input\/votes per settlement 2015 - hebrew.csv\",encoding='iso_8859_8')\nresults_2015_raw.set_index('\u05e9\u05dd \u05d9\u05e9\u05d5\u05d1',inplace=True)\nresults_2015_raw.head()","9e54d3ea":"def normalize_results(results):\n    party_results = results.sum()\n    party_results = party_results.div(party_results.sum())\n    return party_results\n\ndef threshold_parties(results,threshold=0.99):\n    cumulative_normalized_results = normalize_results(results).sort_values(ascending=False).cumsum()\n    parties_above_threshold = cumulative_normalized_results.index[cumulative_normalized_results<threshold]\n    return parties_above_threshold\n\ndef group_other_parties(results,threshold=0.99):\n    total_votes = results.sum(axis=1)\n    parties_above_threshold = threshold_parties(results,threshold)\n    other_votes = results.sum(axis=1)-results[parties_above_threshold].sum(axis=1)\n    results = results[parties_above_threshold]\n    results.loc[:,'other'] = other_votes\n    return results\n\ndef prepare_data(results,suffix):\n    return group_other_parties(results[results.columns[5:]]).rename(lambda x: x+suffix,axis=1,inplace=False)\n\nresults_2015 = prepare_data(results_2015_raw,'_2015')\nresults_2019 = prepare_data(results_2019_raw,'_2019')\nresults_2015.head()","d0b85631":"joint = results_2015.join(results_2019)\njoint.dropna(inplace=True, axis=0)\nvotes_diff = results_2019.loc[joint.index].sum(axis=1) - results_2015.loc[joint.index].sum(axis=1)\njoint['no_vote_2019']=[max(-x,0) for x in votes_diff]\njoint['no_vote_2015']=[max(x,0) for x in votes_diff]\nparties_2015 = np.append(results_2015.columns,'no_vote_2015')\nparties_2019 = np.append(results_2019.columns,'no_vote_2019')\njoint = joint[parties_2015].join(joint[parties_2019])\njoint.head()","0f5acfd3":"# solving functions\n\ndef solve_transfer_coefficients(x1,x2):\n    m1 = x1.shape[1]\n    m2 = x2.shape[1]\n    \n    C=cvx.Variable(shape=(m1,m2))\n    constraints=[0<=C, C<=1, cvx.sum(C,axis=1)==1]\n    \n    settlement_sizes = x1.sum(axis=1)\n    settlements_number = x1.shape[0]\n    \n    r_2_1 = cvx.sum_squares((x1*C)-x2)\/settlements_number\/np.square(settlement_sizes).mean()\n    objective=cvx.Minimize(r_2_1)\n    prob=cvx.Problem(objective, constraints)\n\n    r_2_1 = prob.solve(verbose = True, solver='OSQP')\n    coeff_mat = C.value\n    \n    overall_result = [v\/sum(v) for v in [np.mean(x2,axis=0)]][0]\n    naive_estimation = np.outer(np.sum(x2,axis=1),overall_result)\n    r_2_0 = np.mean(np.sum(np.square(naive_estimation-x2),axis=1)) \/np.square(settlement_sizes).mean()\n    r_2_score = 1-r_2_1\/r_2_0\n    print(\"The percentage of variance explained by the model is \"+str(np.round(r_2_score,2)))\n    \n    return coeff_mat, r_2_score\n\ndef make_transfer_coef_matrix(coeff_mat,titles_1, titles_2, resolution_digits = 3):\n    transfer_coeffs_dict = dict(zip(titles_2,np.round(coeff_mat.T,3)))\n    transfer_coeffs_matrix = pd.DataFrame.from_dict(transfer_coeffs_dict)\n    transfer_coeffs_matrix.set_index(titles_1,inplace=True)\n    return transfer_coeffs_matrix\n\ndef make_transfer_matrix(coeffs_mat,titles_1,titles_2,x1, resolution_digits=3):\n    foo = np.sum(x1,axis=0)\/np.sum(x1)\n    vote_transfers = np.round(np.matmul(np.diag(foo),coeffs_mat),resolution_digits)\n    vote_transfers = pd.DataFrame.from_dict(dict(zip(titles_2,np.round(vote_transfers.T,resolution_digits))))\n    vote_transfers.set_axis(titles_1,inplace=True)\n    return vote_transfers","a7e5b499":"m1 = len(parties_2015)\nx1 = joint[parties_2015].values\n\nm2 = len(parties_2019)\nx2 = joint[parties_2019].values\n\ncoeffs_mat, _ = solve_transfer_coefficients(x1,x2)\nmake_transfer_coef_matrix(coeffs_mat,parties_2015,parties_2019)","24e84f19":"vote_transfers = make_transfer_matrix(coeffs_mat,parties_2015,parties_2019,x1)\nvote_transfers","3da77891":"transfer_threshold=0.003\nlinks=np.where(vote_transfers > transfer_threshold)\n\nlabels_english = ['Likud_15', 'Avoda_15', 'Joint', 'Lapid','Kahlon_15', 'Bait',\n                  'Shas_15', 'Liberman_15', 'Gimel_15' ,'Meretz_15', 'Yachad', 'other_15', 'no_15',\n                 'Likud_19', 'Kaholavan', 'Shas_19', 'Gimel_19', 'Hadash', 'Avoda_19', 'Liberman_19',\n                  'UYamin', 'Meretz_19', 'Kahlon_19', 'Raam-Balad', 'NYamin','Zehut','other_19','no_19']\n\ndata = dict(\n    type='sankey',\n    node = dict(pad = 15, \n                thickness = 20, \n                line = dict(color = \"black\",width = 0.5),\n                color='black',\n                label=labels_english),\n    link = dict(source=links[0],\n                target=links[1]+max(links[0])+1,\n                value=[vote_transfers.values[f[0],f[1]]*120 for f in zip(links[0],links[1])]),\n    orientation = 'h'\n)\n\nlayout =  dict(\n    title = \"Shift in votes between parties, from 2015 to 2019 elections\",\n    font = dict(size = 14)\n)\n\nfig = dict(data=[data], layout=layout)\niplot(fig,validate=False)","154317ed":"#### Results\nThe results of the analysis are:\n1. Transfer coefficients: How much of each party's votes got to each other parties (i.e. rows sum to 100%).\n2. Vote transfers: How many votes moved from each party to each (i.e. entire matrix sums to 100%)\n3. Nice Sankey plot of #2.","af1eac36":"#### Data Processing\nThe only data processing done here was to:\n- Group insignificant parties into an 'other' party, where 'significant' parties make up 99% of total votes.\n- chalk up the difference in the number of votes between cycles to the 'no vote' party - i.e. voters that didn't vote in 2015 (perhaps they were too young?) or in 2019.","f260c1b8":"#### Solving functions\nPretty much the same as the previous kernel - find the vote transfer coefficients that best explain the results (and are between 0 and 1, etc). The solver used here is [OSQP](https:\/\/osqp.org\/), used through the cvxpy package.","f6c6fa1b":"# Shift in votes from 2015 elections to 2019 elections\n### Source code for ([this blog post](https:\/\/www.themarker.com\/techblogs\/ormigoldstein\/BLOG-1.7141220))\n\nThe following notebook shows the shift in votes between the two election cycles, i.e. which party got stronger at which party's expense. It is similar (though simpler) to [my previous kernel](https:\/\/www.kaggle.com\/itamarmushkin\/shift-in-votes-between-parties), which itself was explained in [this blog post (Hebrew)](https:\/\/www.themarker.com\/techblogs\/ormigoldstein\/BLOG-1.6567019).\n\nSpeed was essential when making this, so the only thing I translated into English is the final results plot (not the dataset). Sorry.","796847e2":"#### Data sources\nThe 2015 and 2019 raw results are given as-is. Note that they need to be opened with a specific encoding. Virtually no cleanup was made (or needed)."}}