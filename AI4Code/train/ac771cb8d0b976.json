{"cell_type":{"96d9af7a":"code","92d1effc":"code","006f24e8":"code","38619280":"code","77eff3a8":"code","b9e6a8d0":"code","b8c98042":"code","5af7c338":"code","2d432599":"code","e5537353":"code","f19d4371":"code","eeeef312":"code","e448087c":"code","3fccc243":"code","96d013e3":"code","a65b54a6":"code","3452ae57":"code","d1be9eaa":"code","febd22b1":"code","dd1be1a3":"code","11683902":"code","f68a1983":"code","055e6cae":"code","a05623d5":"code","e12f2467":"code","51e3433e":"code","12ca353a":"code","3d253446":"code","22dc5a34":"code","24c8aabe":"code","37163949":"code","66a93d43":"code","52779e6a":"code","bc2c2412":"code","540b517a":"code","c94ae2cc":"markdown","e22b1d82":"markdown","5e538b42":"markdown","ebd73ed2":"markdown","f5fe47e8":"markdown","5a19ff1e":"markdown","27a85a88":"markdown","78b7926a":"markdown","e53c6611":"markdown","21831521":"markdown","c8c1d98f":"markdown","235337a9":"markdown","9db26777":"markdown","448e4be0":"markdown","7428eea6":"markdown","8d950648":"markdown","c0413cc6":"markdown","6e940cfc":"markdown","9bbfd5d6":"markdown","36c5d53a":"markdown","13a4a2c6":"markdown","5629a270":"markdown","6769753a":"markdown","dab4724c":"markdown","9dbcaa76":"markdown","e642ddce":"markdown","2f2d7d17":"markdown","161dec90":"markdown","c1f04734":"markdown","3169309f":"markdown","e94fe036":"markdown","09203782":"markdown","330193f3":"markdown","26537e2f":"markdown","0366e11a":"markdown","322071ed":"markdown","4dcd646f":"markdown","44420d97":"markdown"},"source":{"96d9af7a":"import numpy as np      #import numpy library, use np as a shorter name\n\na = np.array([[1, 3, 5],[6, 4, 5]])   # Create a rank 1 array\nprint(a.shape)            # Prints \"(2,3), which represents the 2 rows and 3 columns\na                        #Shows array a","92d1effc":"print(a[0,1], a[1,0])   # Prints the elements from the first row, second column \n                        # and second row, first column of the array","006f24e8":"a[0,1] = 5                  # Change an element of the array\nprint(a)                  # Prints \"[[1, 3, 5], [6, 4, 5]]\"","38619280":"b = np.array([[1,2,3],[4,5,6]])           # Create a rank 2 array\n### START CODE HERE ### (\u2248 2 line of code)\nprint(None)                      # Fill a function to return the shape of the numpy array\nb[None] = 10                       # Change the third column elements into 10\n### END CODE HERE ###","77eff3a8":"print(b)","b9e6a8d0":"import numpy as np\n\na = np.zeros((2,2))   # Create an array of all zeros\nprint(a)              # Prints \"[[ 0.  0.]\n                      #          [ 0.  0.]]\"\n\nb = np.ones((1,2))    # Create an array of all ones\nprint(b)              # Prints \"[[ 1.  1.]]\"\n\nc = np.full((2,2), 7)  # Create a constant array\nprint(c)               # Prints \"[[ 7.  7.]\n                       #          [ 7.  7.]]\"\n\nd = np.eye(2)         # Create a 2x2 identity matrix\nprint(d)              # Prints \"[[ 1.  0.]\n                      #          [ 0.  1.]]\"\n\ne = np.random.random((2,2))  # Create an array filled with random values\nprint(e)                     # Might print \"[[ 0.91940167  0.08143941]\n                             #               [ 0.68744134  0.87236687]]\"\n    \nf = np.linspace(1, 15, 3)   # The linspace() function returns numbers evenly spaced over a specified intervals.\nprint (f)                   # Say we want 3 evenly spaced points from 1 to 15, we can easily use this.\n                            # linspace() takes the third argument as the number of datapoints to be created\ng= np.arange(3,10)       # Lists the natural numbers from 3 to 9, as the number in the second position is excluded\nprint (g)","b8c98042":"### START CODE HERE ### (\u2248 2 line of code)\nZ = None            \nW = None\n### END CODE HERE ###","5af7c338":"print(Z)\nprint(W)","2d432599":"# Create the following rank 2 array with shape (3, 4)\n# [[ 1  2  3  4]\n#  [ 5  6  7  8]\n#  [ 9 10 11 12]]\na = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\na","e5537353":"# Use slicing to pull out the subarray consisting of the first 2 rows\n# and columns 1 and 2; b is the following array of shape (2, 2):\n# [[2 3]\n#  [6 7]]\nb = a[:2, 1:3]\nprint (b)","f19d4371":"# A slice of an array is a view into the same data, so modifying it\n# will modify the original array.\nprint(a[0, 1])   # Prints the element from the first row, second column, which is \"2\" \nb[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1], \n                 # as we change the value of the corresponding position to 77 for both the a and b array\nprint(a[0, 1])   # Prints \"77\"","eeeef312":"\n# Create a 2d array with 1 on the border and 0 inside\n# Hint: make a numpy array full of ones, and then replace the selected elements into zero\n\nZ = np.ones((5,5))\n### START CODE HERE ### (\u2248 1 line of code)\nZ[None] = 0                        # How should we change the interior part of the array into zero?\n### END CODE HERE ###","e448087c":"print(Z)","3fccc243":"import numpy as np\n\na = np.array([[1,2], [3, 4], [5, 6]])    #Think, what does this array look like? \n\n# An example of integer array indexing.\n# The returned array will have shape (3, 2) \n\nprint(a[[0, 1, 2], [0, 1, 0]])  # Prints the element in position [0,0], [1,1], [2,0] - which is [1 4 5]\n\n# When using integer array indexing, you can reuse the same\n# element from the source array:\nprint(a[[0, 0], [1, 1]])  # Prints the element in position [0,1] twice - which is [2 2]\n","96d013e3":"import numpy as np\n\na = np.array([[1,2], [3, 2], [5, 1]])\n\nbool_idx = (a > 2)   # Find the elements of a that are bigger than 2;\n                     # this returns a numpy array of Booleans of the same\n                     # shape as a, where each slot of bool_idx tells\n                     # whether that element of a is > 2.\n\nprint(bool_idx)      # Prints \"[[False False]\n                     #          [ True  False]\n                     #          [ True  False]]\"\n\n# We use boolean array indexing to construct a rank 1 array \n# consisting of the elements of a corresponding to the True values\n# of bool_idx\nprint(a[bool_idx])  # Prints \"[3 5]\", since these elements are True values\n\n# We can also do all of the above in a single concise statement:\nprint(a[a > 2])     # Prints \"[3 5]\"","a65b54a6":"x = np.array([[1,2], [13, 2], [12, 1]])\n### START CODE HERE ### (\u2248 1 line of code)\ny = None                \n### END CODE HERE ###","3452ae57":"print(y)","d1be9eaa":"import numpy as np\n\nx = np.array([1, 2])   # Let numpy choose the datatype\nprint(x.dtype)         # Prints \"int64\"\n\nx = np.array([1.0, 2.0])   # Let numpy choose the datatype\nprint(x.dtype)             # Prints \"float64\"\n\nx = np.array([1, 2], dtype=np.int64)   # Force a particular datatype\nprint(x.dtype)                         # Prints \"int64\"","febd22b1":"arr = np.arange(1,11)          # Numbers from 1 to 10\nprint (arr)\nprint (arr * arr)              # Multiplies each element by itself \nprint (arr - arr)              # Subtracts each element from itself\nprint (arr + arr)              # Adds each element to itself\nprint (arr \/ arr)              # Divides each element by itself","dd1be1a3":"#Another example for mathematical operations in numpy\n\nx = np.array([[1,2],[3,4]], dtype=np.float64)\ny = np.array([[5,6],[7,8]], dtype=np.float64)\n\n# Elementwise sum; both produce the array\n# [[ 6.0  8.0]\n#  [10.0 12.0]]\nprint(np.add(x, y))\n\n# Elementwise difference; both produce the array\n# [[-4.0 -4.0]\n#  [-4.0 -4.0]]\nprint(np.subtract(x, y))\n\n# Elementwise product; both produce the array\n# [[ 5.0 12.0]\n#  [21.0 32.0]]\nprint(np.multiply(x, y))\n\n# Elementwise division; both produce the array\n# [[ 0.2         0.33333333]\n#  [ 0.42857143  0.5       ]]\nprint(np.divide(x, y))\n\n# Elementwise square root; produces the array\n# [[ 1.          1.41421356]\n#  [ 1.73205081  2.        ]]\nprint(np.sqrt(x))","11683902":"x = np.array([[1,2],[3,4]])\n### START CODE HERE ### (\u2248 1 line of code)\nx = np.exp(x)                \n### END CODE HERE ###","f68a1983":"print(x)","055e6cae":"# GRADED FUNCTION: basic_sigmoid\n\nimport math\n\ndef basic_sigmoid(x):\n    \"\"\"\n    Compute sigmoid of x.\n\n    Arguments:\n    x -- A scalar\n\n    Return:\n    s -- sigmoid(x)\n    \"\"\"\n    \n    ### START CODE HERE ### (\u2248 1 line of code)\n    s = None\n    ### END CODE HERE ###\n    \n    return s","a05623d5":"basic_sigmoid(3)","e12f2467":"### One reason why we use \"numpy\" instead of \"math\" in Deep Learning ###\nx = [1, 2, 3]\nbasic_sigmoid(x) # you will see this give an error when you run it, because x is a vector.","51e3433e":"# example of vector operation\nx = np.array([1, 2, 3])\nprint (x + 3)","12ca353a":"# GRADED FUNCTION: sigmoid\n\nimport numpy as np # this means you can access numpy functions by writing np.function() instead of numpy.function()\n\ndef sigmoid(x):\n    \"\"\"\n    Compute the sigmoid of x\n\n    Arguments:\n    x -- A scalar or numpy array of any size\n\n    Return:\n    s -- sigmoid(x)\n    \"\"\"\n    \n    ### START CODE HERE ### (\u2248 1 line of code)\n    s = None\n    ### END CODE HERE ###\n    \n    return s","3d253446":"x = np.array([1, 2, 3])\nsigmoid(x)","22dc5a34":"# GRADED FUNCTION: sigmoid_derivative\n\ndef sigmoid_derivative(x):\n    \"\"\"\n    Compute the gradient (also called the slope or derivative) of the sigmoid function with respect to its input x.\n    You can store the output of the sigmoid function into variables and then use it to calculate the gradient.\n    \n    Arguments:\n    x -- A scalar or numpy array\n\n    Return:\n    ds -- Your computed gradient.\n    \"\"\"\n    \n    ### START CODE HERE ### (\u2248 2 lines of code)\n    s = None\n    ds = None\n    ### END CODE HERE ###\n    \n    return ds","24c8aabe":"x = np.array([1, 2, 3])\nprint (\"sigmoid_derivative(x) = \" + str(sigmoid_derivative(x)))","37163949":"import numpy as np\n\nx = np.array([[1,2],[3,4]])  # What does this array look like?\n\nprint(np.sum(x))  # Compute sum of all elements; prints \"10\"\nprint(np.sum(x, axis=0))  # Compute sum of each column; prints \"[4 6]\"\nprint(np.sum(x, axis=1))  # Compute sum of each row; prints \"[3 7]\"","66a93d43":"# GRADED FUNCTION: L1\n\ndef L1(yhat, y):\n    \"\"\"\n    Arguments:\n    yhat -- vector of size m (predicted labels)\n    y -- vector of size m (true labels)\n    \n    Returns:\n    loss -- the value of the L1 loss function defined above\n    \"\"\"\n    \n    ### START CODE HERE ### (\u2248 1 line of code)\n    loss = None\n    ### END CODE HERE ###\n    \n    return loss","52779e6a":"yhat = np.array([.9, 0.2, 0.1, .4, .9])\ny = np.array([1, 0, 0, 1, 1])\nprint(\"L1 = \" + str(L1(yhat,y)))","bc2c2412":"# GRADED FUNCTION: L2\n\ndef L2(yhat, y):\n    \"\"\"\n    Arguments:\n    yhat -- vector of size m (predicted labels)\n    y -- vector of size m (true labels)\n    \n    Returns:\n    loss -- the value of the L2 loss function defined above\n    \"\"\"\n    \n    ### START CODE HERE ### (\u2248 1 line of code)\n    loss = np.sum (np.power(y-yhat,2))\n    ### END CODE HERE ###\n    \n    return loss","540b517a":"yhat = np.array([.9, 0.2, 0.1, .4, .9])\ny = np.array([1, 0, 0, 1, 1])\nprint(\"L2 = \" + str(L2(yhat,y)))","c94ae2cc":"**Expected Outcome:**\n\n(2,3)\n\n    array([[ 1,  2, 10],\n           [ 4,  5, 10]])\n","e22b1d82":"### 1.2 - Sigmoid gradient\n\nAs you've seen in lecture, you will need to compute gradients to optimize loss functions using backpropagation. Let's code your first gradient function.\n\n**Exercise**: Implement the function sigmoid_grad() to compute the gradient of the sigmoid function with respect to its input x. The formula is: $$sigmoid\\_derivative(x) = \\sigma'(x) = \\sigma(x) (1 - \\sigma(x))\\tag{2}$$\nYou often code this function in two steps:\n1. Set s to be the sigmoid of x. You might find your sigmoid(x) function useful.\n2. Compute $\\sigma'(x) = s(1-s)$","5e538b42":"**Exercise**: Implement the numpy vectorized version of the L2 loss. There are several way of implementing the L2 loss but you may find the function np.power() useful. As a reminder, if $x = [x_1, x_2, ..., x_n]$, then `np.power(x,2)` = $\\sum_{j=0}^n x_j^{2}$. \n\n- L2 loss is defined as $$\\begin{align*} & L_2(\\hat{y},y) = \\sum_{i=0}^m(y^{(i)} - \\hat{y}^{(i)})^2 \\end{align*}\\tag{7}$$","ebd73ed2":"You can find the full list of mathematical functions provided by numpy in the documentation.","f5fe47e8":"Actually, we rarely use the \"math\" library in deep learning because the inputs of the functions are real numbers. In deep learning we mostly use matrices and vectors. This is why numpy is more useful. ","5a19ff1e":"### Exercise 1","27a85a88":"In fact, if $ x = (x_1, x_2, ..., x_n)$ is a row vector then $np.exp(x)$ will apply the exponential function to every element of x. The output will thus be: $np.exp(x) = (e^{x_1}, e^{x_2}, ..., e^{x_n})$","78b7926a":"Congratulations on completing this assignment. We hope that this little warm-up exercise helps you in the future assignments, which will be more exciting and interesting!","e53c6611":"## 2. Array indexing\nNumpy offers several ways to index into arrays.\n\n**Slicing**: Similar to Python lists, numpy arrays can be sliced. Since arrays may be multidimensional, you must specify a slice for each dimension of the array:","21831521":"Numpy provides many more functions for manipulating arrays; you can see the full list in the documentation.\n","c8c1d98f":"### 2.1 Implement the L1 and L2 loss functions\n\n**Exercise**: Implement the numpy vectorized version of the L1 loss. You may find the function abs(x) (absolute value of x) useful.\n\n**Reminder**:\n- The loss is used to evaluate the performance of your model. The bigger your loss is, the more different your predictions ($ \\hat{y} $) are from the true values ($y$). In deep learning, you use optimization algorithms like Gradient Descent to train your model and to minimize the cost.\n- L1 loss is defined as:\n$$\\begin{align*} & L_1(\\hat{y}, y) = \\sum_{i=0}^m|y^{(i)} - \\hat{y}^{(i)}| \\end{align*}\\tag{6}$$\n\nhint: abs(x) = |x|","235337a9":"**Exercise 4**: Elementwise exponential array x; use np.exp(x)","9db26777":"**Expected Output**: \n<table style=\"width:20%\">\n     <tr> \n       <td> **L2** <\/td> \n       <td> 0.43 <\/td> \n     <\/tr>\n<\/table>","448e4be0":"**Expected Output**:\n\n<table style=\"width:20%\">\n\n     <tr> \n       <td> **L1** <\/td> \n       <td> 1.1 <\/td> \n     <\/tr>\n<\/table>\n","7428eea6":"For brevity we have left out a lot of details about numpy array indexing; if you want to know more you should read the documentation.\n","8d950648":"**Exercise 4**: return an array of number larger than 6","c0413cc6":"Numpy also provides many functions to create arrays:","6e940cfc":"You can read about other methods of array creation in the [documentation](https:\/\/docs.python.org\/3.5\/library\/stdtypes.html#numeric-types-int-float-complex).","9bbfd5d6":"Numpy provides many useful functions for performing computations on arrays; one of the most useful is sum:","36c5d53a":"### Exercise 3","13a4a2c6":"Any time you need more info on a numpy function, we encourage you to look at [the official documentation](https:\/\/docs.scipy.org\/doc\/numpy-1.10.1\/reference\/generated\/numpy.exp.html). \n\nYou can also create a new cell in the notebook and write `np.exp?` (for example) to get quick access to the documentation.\n\n**Exercise**: Implement the sigmoid function using numpy. \n\n**Instructions**: x could now be either a real number, a vector, or a matrix. The data structures we use in numpy to represent these shapes (vectors, matrices...) are called numpy arrays. You don't need to know more for now.\n$$ \\text{For } x \\in \\mathbb{R}^n \\text{,     } sigmoid(x) = sigmoid\\begin{pmatrix}\n    x_1  \\\\\n    x_2  \\\\\n    ...  \\\\\n    x_n  \\\\\n\\end{pmatrix} = \\begin{pmatrix}\n    \\frac{1}{1+e^{-x_1}}  \\\\\n    \\frac{1}{1+e^{-x_2}}  \\\\\n    ...  \\\\\n    \\frac{1}{1+e^{-x_n}}  \\\\\n\\end{pmatrix}\\tag{1} $$","5629a270":"## 4. Array Math\nBasic mathematical functions operate elementwise on arrays, and are available both as operator overloads and as functions in the numpy module:\n","6769753a":"**Expected Output**: \n<table>\n    <tr> \n        <td> **sigmoid([1,2,3])**<\/td> \n        <td> array([ 0.73105858,  0.88079708,  0.95257413]) <\/td> \n    <\/tr>\n<\/table> ","dab4724c":"**Boolean array indexing**: Boolean array indexing lets you pick out arbitrary elements of an array. Frequently this type of indexing is used to select the elements of an array that satisfy some condition. Here is an example:\n","9dbcaa76":"You can read all about numpy datatypes in the documentation.","e642ddce":"## 2 - Building basic functions with numpy ##\n\nNumpy is the main package for scientific computing in Python. It is maintained by a large community (www.numpy.org). In this exercise you will learn several key numpy functions such as np.exp, np.log, and np.reshape. You will need to know how to use these functions for future assignments.\n\n### 1.1 - sigmoid function, np.exp() ###\n\nBefore using np.exp(), you will use math.exp() to implement the sigmoid function. You will then see why np.exp() is preferable to math.exp().\n\n**Exercise**: Build a function that returns the sigmoid of a real number x. Use math.exp(x) for the exponential function.\n\n**Reminder**:\n$sigmoid(x) = \\frac{1}{1+e^{-x}}$ is sometimes also known as the logistic function. It is a non-linear function used not only in Machine Learning (Logistic Regression), but also in Deep Learning.\n\n![](http:\/\/i0.wp.com\/www.stokastik.in\/wp-content\/uploads\/2017\/07\/sigmoid.png)\n\nTo refer to a function belonging to a specific package you could call it using package_name.function(). Run the code below to see an example with math.exp().","2f2d7d17":"**Expected Outcome: ** \n\n       array([[1., 0., 0.],\n              [0., 1., 0.],\n              [0., 0., 1.]])\n       array([[0., 0., 0.],\n              [0., 0., 0.],\n              [0., 0., 0.]])","161dec90":"**Expected Output**: \n\n\n<table>\n    <tr> \n        <td> **sigmoid_derivative([1,2,3])**<\/td> \n        <td> [ 0.19661193  0.10499359  0.04517666] <\/td> \n    <\/tr>\n<\/table> \n\n","c1f04734":"## 3. Datatypes\nEvery numpy array is a grid of elements of the same type. Numpy provides a large set of numeric datatypes that you can use to construct arrays. Numpy tries to guess a datatype when you create an array, but functions that construct arrays usually also include an optional argument to explicitly specify the datatype. Here is an example:\n","3169309f":"**Expected Outcome:**\n\n\n    [13, 12]","e94fe036":"\n\n## Numpy Documentation\nThis brief overview has touched on many of the important things that you need to know about numpy, but is far from complete. Check out the numpy reference to find out much more about numpy.\n\n\n","09203782":"### Exercise 2: # \nCreate a 3x3 identity matrix 'Z' and zero matrix 'W', you can refer to the functions used above for creating arrays","330193f3":"**Expected Output**: \n<table style = \"width:40%\">\n    <tr>\n    <td>** basic_sigmoid(3) **<\/td> \n        <td>0.9525741268224334 <\/td> \n    <\/tr>\n\n<\/table>","26537e2f":"**Expected Outcome:**\n\n\n    array([1., 1., 1., 1., 1.], \n          [1., 0., 0., 0., 1.],\n          [1., 0., 0., 0., 1.],\n          [1., 0., 0., 0., 1.],\n          [1., 1., 1., 1., 1.]])","0366e11a":"Furthermore, if x is a vector, then a Python operation such as $s = x + 3$ or $s = \\frac{1}{x}$ will output s as a vector of the same size as x.","322071ed":"# Numpy\nNumpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays. If you are already familiar with MATLAB, you might find this [tutorial](http:\/\/cs231n.github.io\/python-numpy-tutorial\/#python-lists) useful to get started with Numpy.\n\n## 1. Arrays\nA numpy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size of the array along each dimension.\n\nWe can initialize numpy arrays from nested Python lists, and access elements using square brackets:\n\nRun the code to see what happens! Try and do the exercises as well!\n","4dcd646f":"**Integer array indexing**: When you index into numpy arrays using slicing, the resulting array view will always be a subarray of the original array. In contrast, integer array indexing allows you to construct arbitrary arrays using the data from another array. Here is an example:\n","44420d97":"**Expected Outcome:**\n\n[[ 2.71828183  7.3890561 ]\n [20.08553692 54.59815003]]"}}