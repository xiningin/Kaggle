{"cell_type":{"719adff0":"code","0eaf9f1f":"code","a48454d4":"code","0d7cf118":"code","40f4faca":"code","c1e72830":"code","21f055ed":"code","8c96009f":"code","c4e3ccf3":"code","0046931c":"code","efe9a6fa":"code","694c52a6":"code","52d4a17a":"code","e9cf71cc":"code","f7f27a0f":"code","45b358e8":"code","9366bb05":"code","06578dc5":"code","4071b6a5":"code","bb4968f1":"code","9aa11641":"code","43a134c1":"code","0118039a":"code","37ec351d":"code","36afdbb5":"code","8c3f73f1":"code","f1d4efe4":"code","53faa1ad":"code","62b19346":"code","f5375fc9":"code","bf603eaa":"code","a9bfc8c4":"code","d7548ea5":"code","a12c50ed":"code","4f93ef4c":"code","73dd8398":"code","965152ca":"code","705071e2":"code","fa81bb82":"code","0213f8d7":"markdown","145368b1":"markdown","26d3c1be":"markdown","2170f8cb":"markdown","b4f2c31e":"markdown","2f8489de":"markdown","eb159755":"markdown","6b16c8b3":"markdown","9a462140":"markdown","f6dc6391":"markdown","4a216adb":"markdown","355b6996":"markdown","e5e9acb4":"markdown","c043ba5c":"markdown","526c410e":"markdown","2f403e0d":"markdown","91650c9f":"markdown","f88fabe1":"markdown","787563af":"markdown","723a3a92":"markdown","7975c4ae":"markdown","4c6e9ae4":"markdown"},"source":{"719adff0":"!pip install -q efficientnet","0eaf9f1f":"import numpy as np\nimport pandas as pd\nimport os\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\nfrom tensorflow import keras\nimport cv2\nimport sys\nimport seaborn as sns\nfrom tqdm import tqdm\nfrom sklearn.model_selection import train_test_split, StratifiedKFold\nimport scikitplot as skplt\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score,precision_recall_curve\nimport efficientnet.tfkeras as efn","a48454d4":"dataset = pd.read_csv('..\/input\/resized-2015-2019-blindness-detection-images\/labels\/trainLabels19.csv')\n\ndataset","0d7cf118":"names = ['Normal', 'Mild', 'Moderate', 'Severe', 'Proliferate DR']\nprint(dataset['diagnosis'].value_counts())\nsns.barplot(x=names,y=dataset.diagnosis.value_counts().sort_index())","40f4faca":"dataset1 = pd.read_csv('..\/input\/resized-2015-2019-blindness-detection-images\/labels\/trainLabels15.csv')\ndataset1.columns = ['id_code','diagnosis']\ndataset1","c1e72830":"print(dataset1['diagnosis'].value_counts())\nsns.barplot(x=names,y=dataset1.diagnosis.value_counts().sort_index())","21f055ed":"#Now we will take 900 images in total for each class. So to complete the 900 images we will take majority of images from 'dataset' \n#and if necessary take the rest of the required images from 'dataset1'\n\n#index  Final_Img_count   Image taken from dataset 1\n# 0          900                   (0)\n# 1          900                 (530)\n# 2          900                   (0)\n# 3          900                 (707)\n# 4          900                 (605)\n\n\nlevel_1 = dataset1[dataset1.diagnosis == 1].sample(n=530)\n\nlevel_3 = dataset1[dataset1.diagnosis == 3].sample(n=707)\n\nlevel_4 = dataset1[dataset1.diagnosis == 4].sample(n=605)","8c96009f":"level_1.shape , level_3.shape, level_4.shape","c4e3ccf3":"level_0 = dataset[dataset.diagnosis == 0].sample(n=900)\nlevel_0","0046931c":"level_2 = dataset[dataset.diagnosis == 2].sample(n=900)\nlevel_2","efe9a6fa":"dataset= dataset[dataset['diagnosis']>0]\ndataset= dataset[dataset['diagnosis'] != 2]\nprint(dataset['diagnosis'].value_counts())","694c52a6":"dataset = pd.concat([level_0,level_2,dataset])\ndataset=dataset.sample(frac=1)\nprint(dataset['diagnosis'].value_counts())\ndataset","52d4a17a":"dataset1 = pd.concat([level_1,level_3, level_4])\ndataset1=dataset1.sample(frac=1)\n\nprint(dataset1['diagnosis'].value_counts())\ndataset1","e9cf71cc":"images = []\nfor i, image_id in enumerate(tqdm(dataset.id_code)):\n    im = cv2.imread(f'..\/input\/resized-2015-2019-blindness-detection-images\/resized train 19\/{image_id}.jpg')\n    #im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)\n    im = cv2.resize(im, (128, 128))\n    images.append(im)\n\nimages","f7f27a0f":"for i, image_id in enumerate(tqdm(dataset1.id_code)):\n    im = cv2.imread(f'..\/input\/resized-2015-2019-blindness-detection-images\/resized train 15\/{image_id}.jpg')\n    #im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)\n    im = cv2.resize(im, (128, 128))\n    images.append(im)\n\nimages","45b358e8":"# random image from imported data\nplt.imshow(images[-30])\nplt.show()","9366bb05":"# This function will act as a filter for the image data\n\ndef load_colorfilter(image, sigmaX=10):\n    #image = cv2.imread(path)\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    #image = crop_image_from_gray(image)\n    #image = cv2.resize(image, (IMG_SIZE, IMG_SIZE))\n    image=cv2.addWeighted ( image,4, cv2.GaussianBlur( image , (0,0) , sigmaX),-4 ,128)\n    return image","06578dc5":"for i in range(len(images)):\n    output = load_colorfilter(images[i])\n    images[i] = output","4071b6a5":"# image after filtering\nplt.imshow(images[-30])\nplt.show()","bb4968f1":"images = np.array(images)\nimages.shape","9aa11641":"dataset = pd.concat([dataset,dataset1])\nprint(dataset['diagnosis'].value_counts())\n\nsns.barplot(x=names,y=dataset.diagnosis.value_counts().sort_index())","43a134c1":"X = images\/255.0\ny = dataset.diagnosis.values\nX, y","0118039a":"# Cleaning some RAM memory space\ndel images,level_1,level_3, level_4, level_0, dataset1","37ec351d":"# Applying image augmentation\nsys.stdout.flush()\naug = ImageDataGenerator(rotation_range=0.2, width_shift_range=0.2, \\\n    height_shift_range=0.2, shear_range=0.2, zoom_range=0.2,\\\n    horizontal_flip=True, fill_mode=\"nearest\")","36afdbb5":"#from sklearn.model_selection import train_test_split\n#X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2)\n#X_train.shape, X_test.shape, y_train.shape, y_test.shape\n\n#X_train, X_valid, y_train, y_valid = train_test_split(X_train, y_train, test_size = 0.1)#\n#X_train.shape, X_valid.shape, y_train.shape, y_valid.shape\n#######################################################################################\n\nX, X_test, y, y_test = train_test_split(X,y,test_size=0.1, stratify = y)\nX.shape, X_test.shape, y.shape, y_test.shape","8c3f73f1":"# Function defined to plot the curves during training\n\ndef display_training_curves(training, validation, title, subplot):\n    \n    if subplot%10==1: # set up the subplots on the first call\n        plt.subplots(figsize=(10,10), facecolor='#F0F0F0')\n        plt.tight_layout()\n    ax = plt.subplot(subplot)\n    ax.set_facecolor('#F8F8F8')\n    ax.plot(training)\n    ax.plot(validation)\n    ax.set_title('model '+ title)\n    ax.set_ylabel(title)\n    #ax.set_ylim(0.28,1.05)\n    ax.set_xlabel('epoch')\n    ax.legend(['train', 'valid.'])\n    plt.show()","f1d4efe4":"BS = 32       #Batch size\naccuracy = []\n\n############ USING STRATIFIED K-FOLD CROSS VALIDATION TECHNIQUE ##########\n\nskf = StratifiedKFold(n_splits=5)\nskf.get_n_splits(X,y)\n\nfor train, test in skf.split(X,y):\n    model2 = tf.keras.Sequential([\n        efn.EfficientNetB5(\n            input_shape=(128,128, 3),\n            weights='imagenet',\n            include_top=False\n        ),\n        tf.keras.layers.GlobalAveragePooling2D(),\n        tf.keras.layers.Dropout(0.4),\n        tf.keras.layers.Dense(5, activation='softmax')\n    ])\n    \n    # Compiling the model\n    model2.compile(optimizer=tf.keras.optimizers.Adam(lr=0.00001),loss='sparse_categorical_crossentropy',metrics=['acc'])\n    \n    # Training\n    history = model2.fit_generator(aug.flow(X[train], y[train], batch_size=BS),\n    validation_data=(X[test], y[test]),\n    epochs=80, verbose = 1)\n\n    # Evaluate score\n    acc=model2.evaluate(X[test], y[test])\n    accuracy.append(acc[1])\n    \n    # Plotting traning curves\n    display_training_curves(\n    history.history['loss'], \n    history.history['val_loss'], \n    'loss', 211)\n    \n    display_training_curves(\n    history.history['acc'], \n    history.history['val_acc'], \n    'accuracy', 212)","53faa1ad":"# we can see the minimum and maximum validation accuracy received after training on the training dataset\naccuracy","62b19346":"# thus we can assume the mean accuracy of the model on the training set to be:\na=sum(accuracy)\/len(accuracy)\nprint(f'Mean evaluated accuracy of model : {a}')","f5375fc9":"from IPython.display import SVG\nfrom keras.utils.vis_utils import model_to_dot\nSVG(model_to_dot(model2).create(prog='dot', format='svg'))","bf603eaa":"#predicting training labels\ny_train_pred = model2.predict_classes(X)\n\n#Accuracy of train prediction\nprint('\\nAccuracy of training data prediction : {:.2f}\\n'.format(accuracy_score(y, y_train_pred)))\n\n#confusion matrix for training set\nconfusion = confusion_matrix(y, y_train_pred)\nprint('Confusion Matrix of training data prediction \\n')\nprint(confusion)","a9bfc8c4":"# Visualizing confusion matrix for train data\nskplt.metrics.plot_confusion_matrix(y, y_train_pred, figsize=(8, 8))\nplt.show()","d7548ea5":"#Classification report \nprint('\\nClassification Report of training set : \\n')\nprint(classification_report(y, y_train_pred, target_names=['No DR', 'Mild', 'Moderate', 'Severe', 'Proliferate DR']))","a12c50ed":"y_pred = model2.predict_classes(X_test)\ny_pred","4f93ef4c":"y_test","73dd8398":"# Accuracy of test prediction\nprint('\\nAccuracy: {:.2f}\\n'.format(accuracy_score(y_test, y_pred)))","965152ca":"# Confusion matrix of the test data\nconfusion = confusion_matrix(y_test, y_pred)\nprint('Confusion Matrix\\n')\nprint(confusion)","705071e2":"# Visualizing confusion matrix for test data\nskplt.metrics.plot_confusion_matrix(y_test, y_pred, figsize=(8, 8))\nplt.show()","fa81bb82":"#Classification report\nprint('\\nClassification Report\\n')\nprint(classification_report(y_test, y_pred, target_names=['No DR', 'Mild', 'Moderate', 'Severe', 'Proliferate DR']))","0213f8d7":"# PREDICTING TEST RESULTS","145368b1":"# BALANCING THE DATASET","26d3c1be":"**APPLYING GAUSSIAN BLUR NOISE FILTER**","2170f8cb":"**VISUALIZING DATASET1**","b4f2c31e":"**IMPORTING DIABETIC RETINOPATHY RESIZED DATA FROM THE KAGGLE COMPETITION 2015 CSV FILE**","2f8489de":"**RESIZING THE IMPORTING DATA**","eb159755":"# PREPROCESSING OF IMAGE DATA","6b16c8b3":"# SPLITTING OF DATASET IN TRAIN AND TEST DATA","9a462140":"# IMPORTING SELECTED IMAGES FROM THE DATASET","f6dc6391":"# IMPORTING DATA","4a216adb":"**VISUALIZING BALANCED DATASET**","355b6996":"**MODEL LAYER DIAGRAM**","e5e9acb4":"# ANALYSIS OF TRAINING MODEL","c043ba5c":"**IMPORTING APTOS-2019 BLINDNESS DETECTION DATA CSV FILE**","526c410e":"1. **DESIGNING THE CONVOLUTIONAL NEURAL NETWORK MODEL**\n2. **USING STRATIFIED K-FOLD CROSS VALIDATION TECHNIQUE TO SPLIT THE TRAINING DATA INTO TRAINING AND VALIDATION SETS**\n3. **COMPILE AND TRAIN THE MODEL FOR EACH SPLIT**\n4. **PLOT THE TRAINING CURVES FOR EACH SPLIT**","2f403e0d":"**SCALING\/NORMALISING IMAGE DATASET**","91650c9f":"**VISUALIZING DATASET**","f88fabe1":"**FORMING THE FINAL DATASET**","787563af":"**ANALYSIS OF TEST RESULTS**","723a3a92":"# IMPORTING LIBRARIES","7975c4ae":"# IMAGE AUGMENTATION","4c6e9ae4":"# TRAINING OF MODEL"}}