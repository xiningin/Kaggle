{"cell_type":{"62cc375d":"code","1ebb85c3":"code","5678774d":"code","8aebc4e2":"code","6e3bde76":"code","349e201f":"code","d643b9e5":"code","ccc4f940":"code","94d58dc5":"code","8b052e11":"code","4f19cc25":"code","1b9e4ba4":"code","dd18a24b":"code","e0ffe182":"code","f9477a9f":"code","2fd34da4":"code","fad86163":"code","b045ef80":"code","fc82ca77":"code","70651d3f":"code","3a447eb7":"code","42a4252f":"code","6dc12ec6":"code","7648fe5a":"code","b90f361b":"markdown","f98b1427":"markdown","72e105d0":"markdown","50ec337d":"markdown","ab00f095":"markdown","7817e1c2":"markdown","0a8168f0":"markdown","7ec808ec":"markdown","f0ca534f":"markdown","75a10436":"markdown","d2026160":"markdown","03c23aba":"markdown","11d7a1ff":"markdown","13690a11":"markdown","08b33755":"markdown","9840feac":"markdown"},"source":{"62cc375d":"%reset -sf\nimport pandas as pd\nimport collections\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm  # progress bar\n\ndf = pd.read_csv(\"..\/input\/students-order-brushing-1\/order_brush_order.csv\").astype('str')\ndf[\"shopid\"] = df[\"shopid\"].astype('str')","1ebb85c3":"# We assume we have the truth to calculate the score here\ndf_truth = pd.read_csv(\"..\/input\/cl1-wy-perf\/submission.csv\").astype('str')\nweights = df_truth[\"userid\"].apply(lambda x: 0.005 if x == \"0\" else 1)\n\n# Assume we have the truth, we develop our scoring mechanism, and also show some metrics\ndef scoring(df_submission):\n    df_compare = pd.merge(df_truth, df_submission, on=\"shopid\", how=\"left\")\n    suspicious_shops_detected = sum(df_compare[\"userid_y\"] != \"0\")\n    suspicious_shops_correct = sum((df_compare[\"userid_x\"] == df_compare[\"userid_y\"]) &\n                                   (df_compare[\"userid_x\"]!= \"0\"))\n    suspicious_shops_multiuser_detected = sum(df_compare[\"userid_y\"].str.contains(\"&\"))\n    suspicious_shops_multiuser_correct = sum((df_compare[\"userid_x\"] == df_compare[\"userid_y\"]) &\n                                             (df_compare[\"userid_x\"].str.contains(\"&\")))\n    score = sum((df_compare[\"userid_x\"] == df_compare[\"userid_y\"])*weights)\/407.25\n    return (\"Score: {:.5f}\\n\" + \n            \"Suspicious shops correct\/detected\/total: {}\/{}\/{}\\n\" + \n            \"Suspicious shops multiuser correct\/detected\/total {}\/{}\/{}\").format(\n        score, suspicious_shops_correct, suspicious_shops_detected, 315, \n        suspicious_shops_multiuser_correct, suspicious_shops_multiuser_detected, \n        sum(df_compare[\"userid_x\"].str.contains(\"&\")))","5678774d":"# score if we return all zeros\ndf_sample_submission = df_truth.copy()\ndf_sample_submission[\"userid\"] = \"0\"\nprint(scoring(df_sample_submission))\ndf_sample_submission","8aebc4e2":"# first we convert the time to an integer to work with it more easily\ntime_zero = pd.to_datetime('2019-12-27')\ndf[\"unix_time\"] = pd.to_datetime(df[\"event_time\"], format='%Y-%m-%d %H:%M:%S').apply(\n    lambda x: int((x - time_zero).total_seconds()))\n\ndf = df.sort_values([\"shopid\", \"unix_time\"])\ndf.head()","6e3bde76":"shops = collections.defaultdict(list)\norders = df.drop([\"orderid\", \"event_time\"], axis=1).values\n\nfor shop, userid, unix_time in orders:\n    shops[shop].append((userid, unix_time))","349e201f":"def plot_shop(shop_id_inspected, limit_range=False):\n    plt.figure(figsize=(14,2))\n    suspicious_users = df_truth[df_truth[\"shopid\"] == str(shop_id_inspected)][\"userid\"].values[0].split(\"&\")\n    unix_times, userids = list(zip(*shops[shop_id_inspected]))[::-1]\n    plt.scatter(unix_times, userids, marker=\"x\", \n                s=[500 if str(userid) in suspicious_users else 100 for userid in userids],\n                color=[\"r\" if str(userid) in suspicious_users else \"b\" for userid in userids])\n    if limit_range and suspicious_users:\n        sus_times = [time for time,userid in zip(unix_times, userids) if userid in suspicious_users]\n        plt.gca().set_xlim(min(sus_times) - 3600, max(sus_times) + 3600)\n    plt.title(shop_id_inspected)\n    plt.show()","d643b9e5":"plot_shop(\"175531295\")","ccc4f940":"res = collections.defaultdict(set)\nfor current_shop_id, current_shop in tqdm(shops.items()):\n    for i,(user,time) in enumerate(current_shop):\n        start_time = time\n        users = []\n        for j,(user,time) in enumerate(current_shop[i:], start=i):\n            if time > start_time + 3600:\n                break\n            users.append(user)\n        score = len(users)\/\/len(set(users))\n        if score < 3:\n            continue\n        c = collections.Counter(users)\n        maxc = max(c.values())\n        res[current_shop_id].update([user for user in set(users) if c[user] == maxc])","94d58dc5":"shopids = []\nuserids = []\nfor k,v in res.items():\n    shopids.append(str(k))\n    userids.append(\"&\".join(str(userid) for userid in sorted(v)))\n    \ndf_detected = pd.DataFrame.from_dict({\"shopid\": shopids, \"userid\": userids})\ndf_detected = df_detected.set_index(\"shopid\")","8b052e11":"df_forward_brushing = df_sample_submission.copy()\ndf_forward_brushing = df_forward_brushing.set_index(\"shopid\")\ndf_forward_brushing.update(df_detected)\ndf_forward_brushing = df_forward_brushing.reset_index()\nprint(scoring(df_forward_brushing))","4f19cc25":"forward_shops = df_forward_brushing[(df_forward_brushing.userid != \"0\")]\nfor shop_id_inspected in forward_shops[\"shopid\"][:3]:\n    plot_shop(shop_id_inspected, limit_range=True)","1b9e4ba4":"for current_shop_id, current_shop in tqdm(shops.items()):\n    for i,(user,time) in enumerate(current_shop[::-1]):  # reverse order of orders\n        start_time = -time  # filp the sign of time\n        users = []\n        for j,(user,time) in enumerate(current_shop[::-1][i:], start=i):  # reverse order of orders\n            time = -time  # filp the sign of time\n            if time > start_time + 3600:\n                break\n            users.append(user)\n        score = len(users)\/\/len(set(users))\n        if score < 3:\n            continue\n        c = collections.Counter(users)\n        maxc = max(c.values())\n        res[current_shop_id].update([user for user in set(users) if c[user] == maxc])","dd18a24b":"shopids = []\nuserids = []\nfor k,v in res.items():\n    shopids.append(str(k))\n    userids.append(\"&\".join(str(userid) for userid in sorted(v)))\n    \ndf_detected = pd.DataFrame.from_dict({\"shopid\": shopids, \"userid\": userids})\ndf_detected = df_detected.set_index(\"shopid\")","e0ffe182":"df_birdirectional_brushing = df_sample_submission.copy()\ndf_birdirectional_brushing = df_birdirectional_brushing.set_index(\"shopid\")\ndf_birdirectional_brushing.update(df_detected)\ndf_birdirectional_brushing = df_birdirectional_brushing.reset_index()\nprint(scoring(df_birdirectional_brushing))","f9477a9f":"backward_shops = df_birdirectional_brushing[(df_birdirectional_brushing.userid != \"0\") & \n                                            (df_forward_brushing.userid == \"0\")]\nfor shop_id_inspected in backward_shops[\"shopid\"][:3]:\n    plot_shop(shop_id_inspected, limit_range=True)","2fd34da4":"missing_shops = df_truth[(df_birdirectional_brushing.userid == \"0\") & (df_truth.userid != \"0\")]\nfor shop_id_inspected in missing_shops[\"shopid\"][:3]:\n    plot_shop(shop_id_inspected, limit_range=True)","fad86163":"for current_shop_id, current_shop in tqdm(shops.items()):\n    for i,(user,time) in enumerate(current_shop):\n        start_time = time\n        users = []\n        for j,(user,time) in enumerate(current_shop[i:], start=i):\n            if time > start_time + 3600:\n                break\n            if time == start_time:  # exclude current time\n                continue\n            users.append(user)\n        if len(users) == 0:\n            continue\n        score = len(users)\/\/len(set(users))\n        if score < 3:\n            continue\n        c = collections.Counter(users)\n        maxc = max(c.values())\n        res[current_shop_id].update([user for user in set(users) if c[user] == maxc])","b045ef80":"for current_shop_id, current_shop in tqdm(shops.items()):\n    for i,(user,time) in enumerate(current_shop[::-1]):\n        start_time = -time\n        users = []\n        for j,(user,time) in enumerate(current_shop[::-1][i:], start=i):\n            time = -time\n            if time > start_time + 3600:\n                break\n            if time == start_time:  # exclude current time\n                continue\n            users.append(user)\n        if len(users) == 0:\n            continue\n        score = len(users)\/\/len(set(users))\n        if score < 3:\n            continue\n        c = collections.Counter(users)\n        maxc = max(c.values())\n        res[current_shop_id].update([user for user in set(users) if c[user] == maxc])","fc82ca77":"shopids = []\nuserids = []\nfor k,v in res.items():\n    shopids.append(str(k))\n    userids.append(\"&\".join(str(userid) for userid in sorted(v)))\n    \ndf_detected = pd.DataFrame.from_dict({\"shopid\": shopids, \"userid\": userids})\ndf_detected = df_detected.set_index(\"shopid\")","70651d3f":"df_delayed_brushing = df_sample_submission.copy()\ndf_delayed_brushing = df_delayed_brushing.set_index(\"shopid\")\ndf_delayed_brushing.update(df_detected)\ndf_delayed_brushing = df_delayed_brushing.reset_index()\nprint(scoring(df_delayed_brushing))","3a447eb7":"df_delayed_brushing.to_csv(\"submission.csv\", index=False)\n!head \"submission.csv\"","42a4252f":"df_pred_multiuser = df_delayed_brushing[df_delayed_brushing[\"userid\"].str.contains(\"&\")]\ndf_pred_multiuser.join(df_truth, how=\"left\", rsuffix=\"_truth\", lsuffix=\"_pred\")","6dc12ec6":"shop_id_inspected = \"181009364\"\nshops[shop_id_inspected]","7648fe5a":"df_truth_multiuser = df_truth[df_truth[\"userid\"].str.contains(\"&\")]\nfor shop_id_inspected in df_truth_multiuser[\"shopid\"]:\n    plot_shop(shop_id_inspected)","b90f361b":"With the ground truth we see the shops with multiple suspicious users, and compare it with our current predictions.","f98b1427":"The methods used in this notebook includes all potential suspicious buyers and does not consider rule 4. You might want to consult other resources that correctly interpret rule 4.\n\nSince the number of shops is small, some of the group members check the entire list manually as well.\n\n\n\n","72e105d0":"It seems that the suspicious hour can start and end not exactly at an order time.\n\nHowever, once again, considering all possible windows is too time consuming, since there are 18770 shops and 6 days with 432000 seconds.\n\nConsider if you have following order sequence\n\nuserid|X|A|A|A|Y|\n-|-|-|-|-|-|\ntime|07:59:59|08:30:00|08:31:00|08:32:00|09:00:01|\n\n<br>\n\nThe suspicious hour starts happens from `08:00:00` to `09:00:00`, which is not one of the starting time. \n\nWe consider the following as all possible start times\n- every order time\n- one second after every order time\n\nWe consider the following as all possible end times\n- every order time\n- one second before every order time","50ec337d":"# Forward window scanning\nWe process each shop independently.\n\nConsidering all possible windows is too time consuming, since there are 18770 shops and 6 days with 432000 seconds.\n\nFor each shop, we consider every order time as a possible starting time for the window. This is how the examples were presented in the instructions.","ab00f095":"# Backward window scanning\n\nThe above method misses out some suspicious shops.\n\nFor instance you have following sequence\n\nuserid|X|A|A|A|B|Y|\n-|-|-|-|-|-|-|\ntime|00:00|08:30|08:31|08:32|09:01|12:00\n\n<br>\nThe algorithm will consider the starting time as 08:30 and will not detect the suspicious period from 08:00 to 09:00.\n\nWe simply take the negative of the time, reverse the order of orders for each shop in our computation. We append suspicious users to our list.","7817e1c2":"# Data preparation\n\nWe now first prepare our data. First we process the time information into an integer for easier computation.","0a8168f0":"# Shops with multiple suspicious users","7ec808ec":"# Finding the missing shops\nHowever there are still some missing shops when we applied both methods. Here we visualise some of them.","f0ca534f":"Above are the additional shops that we have found. \n\nNote that not all highlighted orders suspicious as they can happen outside of the suspicious period.","75a10436":"# Baseline solution\nHere we assume all zeroes.\n\nAccording to the evaluation metrics\n\n- 0.005 point is given to correct negative result\n- 1 point is given to correct positive result\n- There are 18770 shops\n- The total score is divided by 407.275\n\n$407.275 = x + (18770 - x) \\times 0.005$\n\nSolving the equation above you can calculate that there are $x=315$ shops.\n\nThe public leaderboard of the all zero submission also validates this observation.","d2026160":"Above are the shops that we have found with the scanning method.","03c23aba":"# Baseline methods and some visualisations\nHere I present some baseline submissions for the competition and visualisations on the dataset.\n\nYou can get \n- 0.22658 if you assume all shops are not suspicious\n- 0.88465 if you manage to detect 276 suspicious shops without filtering all potential suspicious buyers\n- 0.96323 if you manage to detect 308 suspicious shops without filtering all potential suspicious buyers\n- 0.98042 if you manage to detect all 315 suspicious shops without filtering all potential suspicious buyers\n\n\nThis notebook does not include information on how to filter the suspicious buyers.\n\nThis notebook also uses a ground truth (i.e. a 1.0 submission result) for the visualisation. If you want to run this notebook, please use your ground truth, or ask someone who has produced the ground truth by themselves to share the resource on Kaggle publicly so I can add it.","11d7a1ff":"# Visualisation\nWith the ground truth, we visualise the suspicious users.","13690a11":"We will write some code to make a submission","08b33755":"Hope this helps!\n\nIf you are interested in my work, you can also read about a notebook for a past Google Hashcode competition. https:\/\/www.kaggle.com\/huikang\/hc-2019q-eda-and-baseline-soln","9840feac":"We can consider all shops independently. \nThe only relevant information is a list of `userid` and `unix_time` for each shop."}}