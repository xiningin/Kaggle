{"cell_type":{"ea119dbd":"code","73c74008":"code","e13a3dad":"code","345cb41b":"code","586c399e":"code","504f03d0":"code","1db83f02":"code","c09710c2":"code","d0bccd51":"code","85241c53":"code","05459db6":"code","63af7e38":"code","7e06c671":"code","c96a0de5":"code","18831f75":"code","3114cab6":"code","4e80e358":"code","ecdc73a6":"code","64c65002":"code","f35bd0f2":"code","4632008d":"code","aaa8edb4":"code","c457dae7":"code","ceb390ad":"code","bbec663c":"code","2e52b47c":"code","b7b6ede1":"code","b9bf3c5b":"markdown","b59b7c04":"markdown","1340fecb":"markdown","a54c5550":"markdown","2519f3f3":"markdown"},"source":{"ea119dbd":"import numpy as np\nimport pandas as pd\nfrom tqdm import tqdm\nimport tensorflow as tf\nfrom datetime import datetime\n\n\n%load_ext tensorboard","73c74008":"training= pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\ntraining.head()","e13a3dad":"test = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\ntest.head()","345cb41b":"y_train = training['label']\nX_train = training.drop(labels = ['label'], axis=1)\nX_train = X_train \/ 255.0\nX_train = X_train.values.reshape(-1, 28,28,1)","586c399e":"X_test = test \/ 255.0\nX_test = X_test.values.reshape(-1, 28,28,1)","504f03d0":"testing_dataset_size = X_test.shape[0]\ntraining_dataset_size = X_train.shape[0]","1db83f02":"# Parameters Based on Paper\nepsilon = 1e-7\nm_plus = 0.9\nm_minus = 0.1\nlambda_ = 0.5\nalpha = 0.0005\nepochs = 10\nno_of_secondary_capsules = 10\n\noptimizer = tf.keras.optimizers.Adam()","c09710c2":"params = {\n    \"no_of_conv_kernels\": 256,\n    \"no_of_primary_capsules\": 32,\n    \"no_of_secondary_capsules\": 10,\n    \"primary_capsule_vector\": 8,\n    \"secondary_capsule_vector\": 16,\n    \"r\":3,\n}\n","d0bccd51":"checkpoint_path = '.\/logs\/model\/capsule'\n\nstamp = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n\nlogdir = '.\/logs\/func\/%s' % stamp\nwriter = tf.summary.create_file_writer(logdir)\n\nscalar_logdir = '.\/logs\/scalars\/%s' % stamp\nfile_writer = tf.summary.create_file_writer(scalar_logdir + \"\/metrics\")","85241c53":"dataset = tf.data.Dataset.from_tensor_slices((X_train, y_train))\ndataset = dataset.shuffle(buffer_size=10000, reshuffle_each_iteration=True)\ndataset = dataset.batch(batch_size=64)","05459db6":"testing = tf.data.Dataset.from_tensor_slices((X_test))\ntesting = testing.batch(batch_size=64)","63af7e38":"class CapsuleNetwork(tf.keras.Model):\n    def __init__(self, no_of_conv_kernels, no_of_primary_capsules, primary_capsule_vector, no_of_secondary_capsules, secondary_capsule_vector, r):\n        super(CapsuleNetwork, self).__init__()\n        self.no_of_conv_kernels = no_of_conv_kernels\n        self.no_of_primary_capsules = no_of_primary_capsules\n        self.primary_capsule_vector = primary_capsule_vector\n        self.no_of_secondary_capsules = no_of_secondary_capsules\n        self.secondary_capsule_vector = secondary_capsule_vector\n        self.r = r\n        \n        \n        with tf.name_scope(\"Variables\") as scope:\n            self.convolution = tf.keras.layers.Conv2D(self.no_of_conv_kernels, [9,9], strides=[1,1], name='ConvolutionLayer', activation='relu')\n            self.primary_capsule = tf.keras.layers.Conv2D(self.no_of_primary_capsules * self.primary_capsule_vector, [9,9], strides=[2,2], name=\"PrimaryCapsule\")\n            self.w = tf.Variable(tf.random_normal_initializer()(shape=[1, 1152, self.no_of_secondary_capsules, self.secondary_capsule_vector, self.primary_capsule_vector]), dtype=tf.float32, name=\"PoseEstimation\", trainable=True)\n            self.dense_1 = tf.keras.layers.Dense(units = 512, activation='relu')\n            self.dense_2 = tf.keras.layers.Dense(units = 1024, activation='relu')\n            self.dense_3 = tf.keras.layers.Dense(units = 784, activation='sigmoid', dtype='float32')\n        \n    def build(self, input_shape):\n        pass\n        \n    def squash(self, s):\n        with tf.name_scope(\"SquashFunction\") as scope:\n            s_norm = tf.norm(s, axis=-1, keepdims=True)\n            return tf.square(s_norm)\/(1 + tf.square(s_norm)) * s\/(s_norm + epsilon)\n    \n    @tf.function\n    def call(self, inputs):\n        input_x, y = inputs\n        # input_x.shape: (None, 28, 28, 1)\n        # y.shape: (None, 10)\n        \n        x = self.convolution(input_x) # x.shape: (None, 20, 20, 256)\n        x = self.primary_capsule(x) # x.shape: (None, 6, 6, 256)\n        \n        with tf.name_scope(\"CapsuleFormation\") as scope:\n            u = tf.reshape(x, (-1, self.no_of_primary_capsules * x.shape[1] * x.shape[2], 8)) # u.shape: (None, 1152, 8)\n            u = tf.expand_dims(u, axis=-2) # u.shape: (None, 1152, 1, 8)\n            u = tf.expand_dims(u, axis=-1) # u.shape: (None, 1152, 1, 8, 1)\n            u_hat = tf.matmul(self.w, u) # u_hat.shape: (None, 1152, 10, 16, 1)\n            u_hat = tf.squeeze(u_hat, [4]) # u_hat.shape: (None, 1152, 10, 16)\n\n        \n        with tf.name_scope(\"DynamicRouting\") as scope:\n            b = tf.zeros((input_x.shape[0], 1152, self.no_of_secondary_capsules, 1)) # b.shape: (None, 1152, 10, 1)\n            for i in range(self.r): # self.r = 3\n                c = tf.nn.softmax(b, axis=-2) # c.shape: (None, 1152, 10, 1)\n                s = tf.reduce_sum(tf.multiply(c, u_hat), axis=1, keepdims=True) # s.shape: (None, 1, 10, 16)\n                v = self.squash(s) # v.shape: (None, 1, 10, 16)\n                agreement = tf.squeeze(tf.matmul(tf.expand_dims(u_hat, axis=-1), tf.expand_dims(v, axis=-1), transpose_a=True), [4]) # agreement.shape: (None, 1152, 10, 1)\n                # Before matmul following intermediate shapes are present, they are not assigned to a variable but just for understanding the code.\n                # u_hat.shape (Intermediate shape) : (None, 1152, 10, 16, 1)\n                # v.shape (Intermediate shape): (None, 1, 10, 16, 1)\n                # Since the first parameter of matmul is to be transposed its shape becomes:(None, 1152, 10, 1, 16)\n                # Now matmul is performed in the last two dimensions, and others are broadcasted\n                # Before squeezing we have an intermediate shape of (None, 1152, 10, 1, 1)\n                b += agreement\n                \n        with tf.name_scope(\"Masking\") as scope:\n            y = tf.expand_dims(y, axis=-1) # y.shape: (None, 10, 1)\n            y = tf.expand_dims(y, axis=1) # y.shape: (None, 1, 10, 1)\n            mask = tf.cast(y, dtype=tf.float32) # mask.shape: (None, 1, 10, 1)\n            v_masked = tf.multiply(mask, v) # v_masked.shape: (None, 1, 10, 16)\n            \n        with tf.name_scope(\"Reconstruction\") as scope:\n            v_ = tf.reshape(v_masked, [-1, self.no_of_secondary_capsules * self.secondary_capsule_vector]) # v_.shape: (None, 160)\n            reconstructed_image = self.dense_1(v_) # reconstructed_image.shape: (None, 512)\n            reconstructed_image = self.dense_2(reconstructed_image) # reconstructed_image.shape: (None, 1024)\n            reconstructed_image = self.dense_3(reconstructed_image) # reconstructed_image.shape: (None, 784)\n        \n        return v, reconstructed_image\n\n    @tf.function\n    def predict_capsule_output(self, inputs):\n        x = self.convolution(inputs) # x.shape: (None, 20, 20, 256)\n        x = self.primary_capsule(x) # x.shape: (None, 6, 6, 256)\n        \n        with tf.name_scope(\"CapsuleFormation\") as scope:\n            u = tf.reshape(x, (-1, self.no_of_primary_capsules * x.shape[1] * x.shape[2], 8)) # u.shape: (None, 1152, 8)\n            u = tf.expand_dims(u, axis=-2) # u.shape: (None, 1152, 1, 8)\n            u = tf.expand_dims(u, axis=-1) # u.shape: (None, 1152, 1, 8, 1)\n            u_hat = tf.matmul(self.w, u) # u_hat.shape: (None, 1152, 10, 16, 1)\n            u_hat = tf.squeeze(u_hat, [4]) # u_hat.shape: (None, 1152, 10, 16)\n\n        \n        with tf.name_scope(\"DynamicRouting\") as scope:\n            b = tf.zeros((inputs.shape[0], 1152, self.no_of_secondary_capsules, 1)) # b.shape: (None, 1152, 10, 1)\n            for i in range(self.r): # self.r = 3\n                c = tf.nn.softmax(b, axis=-2) # c.shape: (None, 1152, 10, 1)\n                s = tf.reduce_sum(tf.multiply(c, u_hat), axis=1, keepdims=True) # s.shape: (None, 1, 10, 16)\n                v = self.squash(s) # v.shape: (None, 1, 10, 16)\n                agreement = tf.squeeze(tf.matmul(tf.expand_dims(u_hat, axis=-1), tf.expand_dims(v, axis=-1), transpose_a=True), [4]) # agreement.shape: (None, 1152, 10, 1)\n                # Before matmul following intermediate shapes are present, they are not assigned to a variable but just for understanding the code.\n                # u_hat.shape (Intermediate shape) : (None, 1152, 10, 16, 1)\n                # v.shape (Intermediate shape): (None, 1, 10, 16, 1)\n                # Since the first parameter of matmul is to be transposed its shape becomes:(None, 1152, 10, 1, 16)\n                # Now matmul is performed in the last two dimensions, and others are broadcasted\n                # Before squeezing we have an intermediate shape of (None, 1152, 10, 1, 1)\n                b += agreement\n        return v\n\n    @tf.function\n    def regenerate_image(self, inputs):\n        with tf.name_scope(\"Reconstruction\") as scope:\n            v_ = tf.reshape(inputs, [-1, self.no_of_secondary_capsules * self.secondary_capsule_vector]) # v_.shape: (None, 160)\n            reconstructed_image = self.dense_1(v_) # reconstructed_image.shape: (None, 512)\n            reconstructed_image = self.dense_2(reconstructed_image) # reconstructed_image.shape: (None, 1024)\n            reconstructed_image = self.dense_3(reconstructed_image) # reconstructed_image.shape: (None, 784)\n        return reconstructed_image\n","7e06c671":"tf.summary.trace_on(graph=True, profiler=True)","c96a0de5":"model = CapsuleNetwork(**params)","18831f75":"def safe_norm(v, axis=-1, epsilon=1e-7):\n    v_ = tf.reduce_sum(tf.square(v), axis = axis, keepdims=True)\n    return tf.sqrt(v_ + epsilon)","3114cab6":"def loss_function(v, reconstructed_image, y, y_image):\n    prediction = safe_norm(v)\n    prediction = tf.reshape(prediction, [-1, no_of_secondary_capsules])\n    \n    left_margin = tf.square(tf.maximum(0.0, m_plus - prediction))\n    right_margin = tf.square(tf.maximum(0.0, prediction - m_minus))\n    \n    l = tf.add(y * left_margin, lambda_ * (1.0 - y) * right_margin)\n    \n    margin_loss = tf.reduce_mean(tf.reduce_sum(l, axis=-1))\n    \n    y_image_flat = tf.reshape(y_image, [-1, 784])\n    y_image_flat = tf.cast(y_image_flat, dtype=tf.float32)\n    reconstruction_loss = tf.reduce_mean(tf.square(y_image_flat - reconstructed_image))\n    \n    loss = tf.add(margin_loss, alpha * reconstruction_loss)\n    \n    return loss","4e80e358":"def train(x,y):\n    y_one_hot = tf.one_hot(y, depth=10)\n    with tf.GradientTape() as tape:\n        v, reconstructed_image = model([x, y_one_hot])\n        loss = loss_function(v, reconstructed_image, y_one_hot, x)\n    grad = tape.gradient(loss, model.trainable_variables)\n    optimizer.apply_gradients(zip(grad, model.trainable_variables))\n    return loss","ecdc73a6":"_ = train(X_train[:32],y_train[:32])\nwith writer.as_default():\n    tf.summary.trace_export(name=\"my_func_trace\", step=0, profiler_outdir=logdir)","64c65002":"tf.summary.trace_off()","f35bd0f2":"model.summary()","4632008d":"def predict(model, x):\n    pred = safe_norm(model.predict_capsule_output(x))\n    pred = tf.squeeze(pred, [1])\n    return np.argmax(pred, axis=1)[:,0]","aaa8edb4":"checkpoint = tf.train.Checkpoint(model=model)","c457dae7":"losses = []\naccuracy = []\nfor i in range(1, epochs+1, 1):\n\n    loss = 0\n    with tqdm(total=training.shape[0]\/64) as pbar:\n        \n        description = \"Epoch \" + str(i) + \"\/\" + str(epochs)\n        pbar.set_description_str(description)\n\n        for X_batch, y_batch in dataset:\n\n            loss += train(X_batch,y_batch)\n            pbar.update(1)\n\n        loss \/= training.shape[0]\/64\n        losses.append(loss.numpy())\n        \n        training_sum = 0\n\n        print_statement = \"Loss :\" + str(loss.numpy()) + \" Evaluating Accuracy ...\"\n        pbar.set_postfix_str(print_statement)\n\n        for X_batch, y_batch in dataset:\n            training_sum += sum(predict(model, X_batch)==y_batch.numpy())\n        accuracy.append(training_sum\/training_dataset_size)\n\n        with file_writer.as_default():\n            tf.summary.scalar('Loss', data=loss.numpy(), step=i)\n            tf.summary.scalar('Accuracy', data=accuracy[-1], step=i)\n        \n        print_statement = \"Loss :\" + str(loss.numpy()) + \" Accuracy :\" + str(accuracy[-1])\n\n        if i % 10 == 0:\n            print_statement += ' Checkpoint Saved'\n            checkpoint.save(checkpoint_path)\n        \n        pbar.set_postfix_str(print_statement)","ceb390ad":"predictions = []\nfor X_batch in testing:\n    predictions.extend(predict(model, X_batch).tolist())","bbec663c":"len(predictions)","2e52b47c":"submission = pd.DataFrame({\"ImageId\":range(1,28001)})\nsubmission['Label'] = predictions\nsubmission.to_csv(\"submission_cnn.csv\",index=False)","b7b6ede1":"submission","b9bf3c5b":"# Importing Libraries","b59b7c04":"## If you found this useful then feel free to upvote !! ","1340fecb":"# Overview\n* Implemented Capsule Network with default configuration as described in the [paper](https:\/\/arxiv.org\/pdf\/1710.09829.pdf). \n* I have added the explanation of the code in the [blog post](https:\/\/towardsdatascience.com\/implementing-capsule-network-in-tensorflow-11e4cca5ecae).\n\n**Recommended :** Open the blog post and this kernel side by side to understand the flow of the code. \n\nv1: Capsule Network","a54c5550":"# Loss Function","2519f3f3":"# Capsule Network Model"}}