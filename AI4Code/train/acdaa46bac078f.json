{"cell_type":{"dde054b8":"code","64cb8e7d":"code","a0cc1462":"code","fdfd0dad":"code","b950cd5a":"code","a74d97ca":"code","ea0b218e":"code","eae06aae":"code","73d9f602":"code","03f16d6c":"code","f87e39e9":"code","8b73b6bb":"code","63938257":"code","5e7e6bc0":"code","636478f7":"code","0be072fa":"code","d984c898":"code","67c3bf90":"code","fc2b6639":"code","f56c6b51":"code","a6304a0b":"code","08536676":"code","280243d1":"code","ec16bba3":"code","ba909eea":"markdown","789d2764":"markdown"},"source":{"dde054b8":"import pandas as pd\r\nimport numpy as np\r\nfrom torch.utils.data import DataLoader,Dataset\r\nfrom torchvision import transforms\r\nfrom torch import nn\r\nimport cv2\r\nimport pytorch_lightning as pl\r\nimport torch\r\nfrom sklearn.model_selection import train_test_split\r\nimport torchvision","64cb8e7d":"input_df = \"..\/input\/images-of-randomly-generated-quadratic-equations\/Quadratic Equation Full Details.csv\"\ndf = pd.read_csv(input_df)\ndf","a0cc1462":"# transformers = transforms.Compose([\r\n#     transforms.\r\n# ])","fdfd0dad":"class Quadratic_Dataset(Dataset):\n    def __init__(self,path,targets = None):\n        self.path =  path\n        self.targets = targets\n        self.dir_path = \"..\/input\/images-of-randomly-generated-quadratic-equations\/Images of Equations\/\"\n    \n    def __len__(self):\n        return len(self.path)\n    \n    def __getitem__(self, index):\n        image_path = self.dir_path + self.path[index] + \".png\"\n        image = cv2.imread(image_path)\n        image = cv2.resize(image,(100,100))\n        if self.targets is None:\n            return 1.0 - torch.tensor(image).float().reshape(3,100,100)\/256\n        else:\n            return 1.0 - torch.tensor(image).float().reshape(3,100,100)\/256 , torch.tensor(self.targets[index]).float().reshape(2)\n","b950cd5a":"dataset = Quadratic_Dataset(path = df[\"id\"].values , targets = df[[\"root_1\" , \"root_2\"]].values)\nimage,label = next(iter(DataLoader(dataset , batch_size = 1 , shuffle = True)))\nlabel","a74d97ca":"def normalize(df_values,min_,max_):\n    df_list = df_values\n    return [(x-min_)\/(max_ - min_) for x in df_values]","ea0b218e":"def denormalize(df_values,min_,max_):\n    df_list = df_values\n    return [(x*(max_ - min_) + min_) for x in df_values]","eae06aae":"df['root_1_'] = normalize(df[\"root_1\"].values,-35 ,30)\ndf['root_2_'] = normalize(df[\"root_2\"].values,-30,30)","73d9f602":"train_df , test_df = train_test_split(df,test_size = 0.2 , random_state= 42)\ntrain_df , val_df = train_test_split(test_df,test_size = 0.33 , random_state= 42)","03f16d6c":"class Quadratic_Module(pl.LightningDataModule):\n    def __init__(self):\n        super().__init__()\n        self.train_dataset = Quadratic_Dataset(path = train_df[\"id\"].values , targets = train_df[[\"root_1_\" , \"root_2_\"]].values)\n        self.test_dataset = Quadratic_Dataset(path = test_df[\"id\"].values , targets = test_df[[\"root_1_\" , \"root_2_\"]].values)\n        self.val_dataset = Quadratic_Dataset(path = val_df[\"id\"].values , targets = val_df[[\"root_1_\" , \"root_2_\"]].values)\n        self.predictions = Quadratic_Dataset(path = test_df[\"id\"].values , targets = None)\n\n    def prepare_data(self) :\n        pass\n    \n    def train_dataloader(self):\n        return DataLoader(self.train_dataset , batch_size = 32  , shuffle = True)\n\n    def test_dataloader(self):\n        return DataLoader(self.test_dataset , batch_size = 32  , shuffle = False)\n\n    def val_dataloader(self):\n        return DataLoader(self.val_dataset , batch_size = 32  , shuffle = False)\n    \n    def predict_dataloader(self):\n        return DataLoader(self.predictions , batch_size = 1 , shuffle  = False)","f87e39e9":"neural_network = torchvision.models.resnet50(pretrained = True)\nneural_network.fc = nn.Sequential(\n    nn.Linear(2048,1024),\n    nn.LeakyReLU(0.2),\n    nn.Linear(1024,512),\n    nn.LeakyReLU(0.2),\n    nn.Linear(512,256),\n    nn.LeakyReLU(0.2),\n    nn.Linear(256,100),\n    nn.LeakyReLU(0.2),\n    nn.Linear(100,10),\n    nn.Linear(10,2),\n    \n)","8b73b6bb":"x = torch.ones(1,3,100,100)\r\nneural_network(x)","63938257":"class Quadratic_Model(pl.LightningModule):\n    def __init__(self):\n        super().__init__()\n        self.loss_func = nn.MSELoss()\n        self.net = neural_network\n        \n        \n    def forward(self,x):\n        out = self.net(x)\n        return out\n    \n    def configure_optimizers(self):\n        optimizer = torch.optim.Adam(self.parameters(), lr = 1e-3)\n        sch = torch.optim.lr_scheduler.StepLR(\n        optimizer, step_size  = 10 , gamma = 0.5)\n        return {\n            \"optimizer\":optimizer,\n            \"lr_scheduler\" : {\n                \"scheduler\" : sch,\n                \"monitor\" : \"train_loss\",\n                \n            }\n        }\n\n    def training_step(self,batch,batch_idx):\n        x , y_true = batch\n        y_pred = self(x)\n        loss = self.loss_func(y_true, y_pred)\n        self.log(\"train_loss\" , loss)\n        return loss\n    \n    def test_step(self,batch,batch_idx):\n        x , y_true = batch\n        y_pred = self(x)\n        loss = self.loss_func(y_true, y_pred)\n        self.log(\"test_loss\" , loss)\n        return loss\n    \n    def validation_step(self,batch,batch_idx):\n        x , y_true = batch\n        y_pred = self(x)\n        loss = self.loss_func(y_true, y_pred)\n        self.log(\"val_loss\" , loss)\n        return loss\n\n","5e7e6bc0":"from pytorch_lightning.callbacks import ModelCheckpoint\r\ncheckpoint = ModelCheckpoint(monitor= \"val_loss\" , \r\nmode = \"min\"\r\n)","636478f7":"from pytorch_lightning import Trainer\nmodel = Quadratic_Model()\nmodule = Quadratic_Module()\ntrainer = Trainer(max_epochs = 75,callbacks=[checkpoint] , gpus= 1)","0be072fa":"trainer.fit(model,module)","d984c898":"trainer.test()\r\n","67c3bf90":"predictions = trainer.predict()\nactual_values_1 = test_df[\"root_1\"].values\nactual_values_2 = test_df[\"root_2\"].values","fc2b6639":"prediction_a = []\nprediction_b = []\ni = 0\nfor preds in predictions:  \n    preds = [float(x) for x in preds.reshape(2)]\n    prediction_a.append(float(preds[0]))\n    prediction_b.append(float(preds[1]))\n    \nprediction_df = pd.DataFrame({\n    \"predictions_root_1\" : prediction_a,\n    \"predictions_root_2\" : prediction_b,\n    \"actual_values_1\" : actual_values_1,\n    \"actual_values_2\" : actual_values_2,\n})","f56c6b51":"prediction_df['predictions_root_1'] = denormalize(prediction_df[\"predictions_root_1\"].values,-35,30)\nprediction_df['predictions_root_2'] = denormalize(prediction_df[\"predictions_root_2\"].values,-30,30)","a6304a0b":"prediction_df.head(100)","08536676":"torch.save(model.state_dict(),\".\/save.pth\")","280243d1":"model_test = Quadratic_Model()\nmodel_test.load_state_dict(torch.load(\".\/save.pth\"))","ec16bba3":"model_test.eval()\nrandom_tensor = torch.ones(1,3,256,256)\nmodel_test(random_tensor)","ba909eea":"Sanity Check to Make Sure of what you are sending to the model","789d2764":"sanity check"}}