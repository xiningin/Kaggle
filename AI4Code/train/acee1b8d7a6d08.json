{"cell_type":{"b976b360":"code","50607e6d":"code","0a9933ca":"code","1ce0c131":"code","6b1eda0c":"code","4523748d":"code","06118e8b":"code","7241d802":"code","1133d372":"code","eae151f8":"code","8bccb23c":"code","4936e19a":"code","576a0415":"code","681cfe1f":"code","499d69a4":"code","d350ac17":"code","7175c50b":"code","1279c1ac":"code","431aed4b":"code","447d68be":"code","1d2a6449":"code","c624a5df":"code","5c6c5208":"code","2a2c9c93":"code","c930014c":"code","9cb50cf3":"code","f5acc7b6":"code","bbe1a1d0":"code","3b55af99":"code","10ba20d1":"code","51263f77":"code","abb7f6ae":"code","0604a710":"code","8e0ac7d7":"code","b95b5800":"code","2d3cb67a":"code","847ad1a4":"code","c2c71ef9":"code","e17d3834":"code","f94c2ca2":"code","7a8850ff":"code","7aa778a4":"code","9a4c05f1":"code","ab9dfda3":"code","ca795233":"markdown","988e725d":"markdown","6fb843c2":"markdown","31d6d7c6":"markdown","19a5f719":"markdown","a550ccdc":"markdown","f27c2c9f":"markdown","ef0aee39":"markdown","950a50cb":"markdown","424d7c2b":"markdown","cb776e28":"markdown","571298ff":"markdown","df49036e":"markdown","38416c61":"markdown","e26ad01a":"markdown","2b54ec17":"markdown","e08f6ee7":"markdown","3c8543fd":"markdown"},"source":{"b976b360":"import pandas as pd # reading all required header files\nimport numpy as np\nimport random\nimport operator\nimport math\nimport matplotlib.pyplot as plt \nfrom scipy.stats import multivariate_normal     # for generating pdf","50607e6d":"df_full = pd.read_csv(\"\/kaggle\/input\/iris\/Iris.csv\") #iris data","0a9933ca":"df_full.head()","1ce0c131":"df_full = df_full.drop(['Id'], axis=1)","6b1eda0c":"df_full.shape","4523748d":"columns = list(df_full.columns)\nfeatures = columns[:len(columns)-1]\nclass_labels = list(df_full[columns[-1]])\ndf = df_full[features]","06118e8b":"# Number of Clusters\nk = 3\n# Maximum number of iterations\nMAX_ITER = 100\n# Number of data points\nn = len(df)\n# Fuzzy parameter\nm = 1.7 #Select a value greater than 1 else it will be knn","7241d802":"plt.figure(figsize=(10,10))                #scatter plot of sepal length vs sepal width                              \nplt.scatter(list(df.iloc[:,0]), list(df.iloc[:,1]), marker='o')       \nplt.axis('equal')                                                                 \nplt.xlabel('Sepal Length', fontsize=16)                                                 \nplt.ylabel('Sepal Width', fontsize=16)                                                 \nplt.title('Sepal Plot', fontsize=22)                                            \nplt.grid()                                                                         \nplt.show()","1133d372":"plt.figure(figsize=(10,10))                    #scatter plot of petal length vs sepal width                          \nplt.scatter(list(df.iloc[:,2]), list(df.iloc[:,3]), marker='o')       \nplt.axis('equal')                                                                 \nplt.xlabel('Petal Length', fontsize=16)                                                 \nplt.ylabel('Petal Width', fontsize=16)                                                 \nplt.title('Petal Plot', fontsize=22)                                            \nplt.grid()                                                                         \nplt.show()","eae151f8":"#Calculating the accuracy\n# P.S. The accuracy calculation is for iris data only\ndef accuracy(cluster_labels, class_labels):\n    correct_pred = 0\n    #print(cluster_labels)\n    seto = max(set(labels[0:50]), key=labels[0:50].count)\n    vers = max(set(labels[50:100]), key=labels[50:100].count)\n    virg = max(set(labels[100:]), key=labels[100:].count)\n    \n    for i in range(len(df)):\n        if cluster_labels[i] == seto and class_labels[i] == 'Iris-setosa':\n            correct_pred = correct_pred + 1\n        if cluster_labels[i] == vers and class_labels[i] == 'Iris-versicolor' and vers!=seto:\n            correct_pred = correct_pred + 1\n        if cluster_labels[i] == virg and class_labels[i] == 'Iris-virginica' and virg!=seto and virg!=vers:\n            correct_pred = correct_pred + 1\n            \n    accuracy = (correct_pred\/len(df))*100\n    return accuracy","8bccb23c":"def initializeMembershipMatrix(): # initializing the membership matrix\n    membership_mat = []\n    for i in range(n):\n        random_num_list = [random.random() for i in range(k)]\n        summation = sum(random_num_list)\n        temp_list = [x\/summation for x in random_num_list]\n        \n        flag = temp_list.index(max(temp_list))\n        for j in range(0,len(temp_list)):\n            if(j == flag):\n                temp_list[j] = 1\n            else:\n                temp_list[j] = 0\n        \n        membership_mat.append(temp_list)\n    return membership_mat","4936e19a":"membership_mat = initializeMembershipMatrix()","576a0415":"def calculateClusterCenter(membership_mat): # calculating the cluster center\n    cluster_mem_val = list(zip(*membership_mat))\n    cluster_centers = []\n    for j in range(k):\n        x = list(cluster_mem_val[j])\n        xraised = [p ** m for p in x]\n        denominator = sum(xraised)\n        temp_num = []\n        for i in range(n):\n            data_point = list(df.iloc[i])\n            prod = [xraised[i] * val for val in data_point]\n            temp_num.append(prod)\n        numerator = map(sum, list(zip(*temp_num)))\n        center = [z\/denominator for z in numerator]\n        cluster_centers.append(center)\n    return cluster_centers","681cfe1f":"#cluster_centers = calculateClusterCenter(membership_mat)\ncalculateClusterCenter(membership_mat)","499d69a4":"def updateMembershipValue(membership_mat, cluster_centers): # Updating the membership value\n    p = float(2\/(m-1))\n    for i in range(n):\n        x = list(df.iloc[i])\n        distances = [np.linalg.norm(np.array(list(map(operator.sub, x, cluster_centers[j])))) for j in range(k)]\n        for j in range(k):\n            den = sum([math.pow(float(distances[j]\/distances[c]), p) for c in range(k)])\n            membership_mat[i][j] = float(1\/den)       \n    return membership_mat","d350ac17":"def getClusters(membership_mat): # getting the clusters\n    cluster_labels = list()\n    for i in range(n):\n        max_val, idx = max((val, idx) for (idx, val) in enumerate(membership_mat[i]))\n        cluster_labels.append(idx)\n    return cluster_labels","7175c50b":"def fuzzyCMeansClustering(): #First Iteration with centers at 0\n    # Membership Matrix\n    membership_mat = initializeMembershipMatrix()\n    curr = 0\n    acc=[]\n    cent_temp = [[0, 0, 0, 0],[0, 0, 0, 0],[0, 0, 0, 0]]\n    while curr < MAX_ITER:\n        if(curr == 0):\n            cluster_centers = cent_temp\n            print(\"Cluster Centers:\")\n            print(np.array(cluster_centers))\n        else:\n            cluster_centers = calculateClusterCenter(membership_mat)\n        #cluster_centers = calculateClusterCenter(membership_mat)\n        membership_mat = updateMembershipValue(membership_mat, cluster_centers)\n        cluster_labels = getClusters(membership_mat)\n        acc.append(cluster_labels)\n        curr += 1\n    print(\"---------------------------\")\n    print(\"Membership Matrix:\")\n    print(np.array(membership_mat))\n    return cluster_labels, cluster_centers, acc","1279c1ac":"def fuzzyCMeansClustering(): #Second Iteration Multivariate Gaussian\n    # Membership Matrix\n    membership_mat = initializeMembershipMatrix()\n    curr = 0\n    acc=[]\n    mean = [0, 0]\n    cov = [[1, 0], [0, 1]]\n    \n    lis1,cent_temp=[],[]\n    \n    for i in range(0,k):\n        Z = list(np.random.multivariate_normal(mean, cov))\n        Z1 = list(np.random.multivariate_normal(mean, cov))\n        lis1 = Z+Z1\n        cent_temp.append(lis1)\n    \n    \n    while curr < MAX_ITER:\n        if(curr == 0):\n            cluster_centers = cent_temp\n            print(\"Cluster Centers:\")\n            print(np.array(cluster_centers))\n        else:\n            cluster_centers = calculateClusterCenter(membership_mat)\n        #cluster_centers = calculateClusterCenter(membership_mat)\n        membership_mat = updateMembershipValue(membership_mat, cluster_centers)\n        cluster_labels = getClusters(membership_mat)\n        acc.append(cluster_labels)\n        curr += 1\n    print(\"---------------------------\")\n    print(\"Membership Matrix:\")\n    print(np.array(membership_mat))\n    return cluster_labels, cluster_centers, acc","431aed4b":"def fuzzyCMeansClustering(): #Third iteration Random vectors from data\n    # Membership Matrix\n    membership_mat = initializeMembershipMatrix()\n    curr = 0\n    acc=[]\n    while curr < MAX_ITER:\n        cluster_centers = calculateClusterCenter(membership_mat)\n        membership_mat = updateMembershipValue(membership_mat, cluster_centers)\n        cluster_labels = getClusters(membership_mat)\n        \n        acc.append(cluster_labels)\n        \n        if(curr == 0):\n            print(\"Cluster Centers:\")\n            print(np.array(cluster_centers))\n        curr += 1\n    print(\"---------------------------\")\n    print(\"Partition matrix:\")\n    print(np.array(membership_mat))\n    #return cluster_labels, cluster_centers\n    return cluster_labels, cluster_centers, acc","447d68be":"labels, centers, acc = fuzzyCMeansClustering()\na = accuracy(labels, class_labels)","1d2a6449":"acc_lis = [] \nfor i in range(0,len(acc)):\n    val = accuracy(acc[i], class_labels)\n    acc_lis.append(val)","c624a5df":"acc_lis = np.array(acc_lis) #calculating accuracy and std deviation 100 times\nprint(\"mean=\",np.mean(acc_lis))\nprint(\"Std dev=\",np.std(acc_lis))","5c6c5208":"print(\"Accuracy = \" + str(round(a, 2)))","2a2c9c93":"print(\"Cluster center vectors:\") #final cluster centers\nprint(np.array(centers))","c930014c":"sepal_df = df_full.iloc[:,0:2]\nsepal_df = np.array(sepal_df)","9cb50cf3":"#First initialization\n#m1 = [0,0]\n#m2 = [0,0]\n#m3 = [0,0]\n#Second initialization\n#m1 = [-0.47534495, -0.16392118]\n#m2 = [0.89019389, -1.19440781]\n#m3 = [1.29107135, 0.48248487]\n#Third initialization\nm1 = random.choice(sepal_df)\nm2 = random.choice(sepal_df)\nm3 = random.choice(sepal_df)\n\ncov1 = np.cov(np.transpose(sepal_df))\ncov2 = np.cov(np.transpose(sepal_df))\ncov3 = np.cov(np.transpose(sepal_df))","f5acc7b6":"x1 = np.linspace(4,8,150)  \nx2 = np.linspace(1.5,4.5,150)\n#x1 = np.linspace(-1,8,150)  \n#x2 = np.linspace(-1,4.5,150)\nX, Y = np.meshgrid(x1,x2) \n\nZ1 = multivariate_normal(m1, cov1)  \nZ2 = multivariate_normal(m2, cov2)\nZ3 = multivariate_normal(m3, cov3)\n\npos = np.empty(X.shape + (2,))                # a new array of given shape and type, without initializing entries\npos[:, :, 0] = X; pos[:, :, 1] = Y   \n\nplt.figure(figsize=(10,10))                                                          # creating the figure and assigning the size\nplt.scatter(sepal_df[:,0], sepal_df[:,1], marker='o')     \nplt.contour(X, Y, Z1.pdf(pos), colors=\"r\" ,alpha = 0.5) \nplt.contour(X, Y, Z2.pdf(pos), colors=\"b\" ,alpha = 0.5) \nplt.contour(X, Y, Z3.pdf(pos), colors=\"g\" ,alpha = 0.5) \nplt.axis('equal')                                                                  # making both the axis equal\nplt.xlabel('Sepal Length', fontsize=16)                                                  # X-Axis\nplt.ylabel('Sepal Width', fontsize=16)                                                  # Y-Axis\nplt.title('Initial Random Clusters(Sepal)', fontsize=22)                                            # Title of the plot\nplt.grid()                                                                         # displaying gridlines\nplt.show()","bbe1a1d0":"petal_df = df_full.iloc[:,2:4]\npetal_df = np.array(petal_df)","3b55af99":"#first initialization\n#m1 = [0,0]\n#m2 = [0,0]\n#m3 = [0,0]\n#second initialization\n#m1 = [-0.8005044 , -0.7017542]\n#m2 = [-2.17962154, -0.96475807]\n#m3 = [-0.68988961,  0.54596565]\n#third initialization\nm1 = random.choice(petal_df)\nm2 = random.choice(petal_df)\nm3 = random.choice(petal_df)\ncov1 = np.cov(np.transpose(petal_df))\ncov2 = np.cov(np.transpose(petal_df))\ncov3 = np.cov(np.transpose(petal_df))","10ba20d1":"#x1 = np.linspace(0.5,7,150)  \n#x2 = np.linspace(-1,4,150)\nx1 = np.linspace(-1,7,150)\nx2 = np.linspace(-1,4,150)\nX, Y = np.meshgrid(x1,x2) \n\nZ1 = multivariate_normal(m1, cov1)  \nZ2 = multivariate_normal(m2, cov2)\nZ3 = multivariate_normal(m3, cov3)\n\npos = np.empty(X.shape + (2,))                # a new array of given shape and type, without initializing entries\npos[:, :, 0] = X; pos[:, :, 1] = Y   \n\nplt.figure(figsize=(10,10))                                                          # creating the figure and assigning the size\nplt.scatter(petal_df[:,0], petal_df[:,1], marker='o')     \nplt.contour(X, Y, Z1.pdf(pos), colors=\"r\" ,alpha = 0.5) \nplt.contour(X, Y, Z2.pdf(pos), colors=\"b\" ,alpha = 0.5) \nplt.contour(X, Y, Z3.pdf(pos), colors=\"g\" ,alpha = 0.5) \nplt.axis('equal')                                                                  # making both the axis equal\nplt.xlabel('Petal Length', fontsize=16)                                                  # X-Axis\nplt.ylabel('Petal Width', fontsize=16)                                                  # Y-Axis\nplt.title('Initial Random Clusters(Petal)', fontsize=22)                                            # Title of the plot\nplt.grid()                                                                         # displaying gridlines\nplt.show()","51263f77":"#finding mode\nseto = max(set(labels[0:50]), key=labels[0:50].count)\nvers = max(set(labels[50:100]), key=labels[50:100].count)\nvirg = max(set(labels[100:]), key=labels[100:].count)","abb7f6ae":"#sepal\ns_mean_clus1 = np.array([centers[seto][0],centers[seto][1]])\ns_mean_clus2 = np.array([centers[vers][0],centers[vers][1]])\ns_mean_clus3 = np.array([centers[virg][0],centers[virg][1]])","0604a710":"values = np.array(labels) #label\n\n#search all 3 species\nsearchval_seto = seto\nsearchval_vers = vers\nsearchval_virg = virg\n\n#index of all 3 species\nii_seto = np.where(values == searchval_seto)[0]\nii_vers = np.where(values == searchval_vers)[0]\nii_virg = np.where(values == searchval_virg)[0]\nind_seto = list(ii_seto)\nind_vers = list(ii_vers)\nind_virg = list(ii_virg)","8e0ac7d7":"sepal_df = df_full.iloc[:,0:2]","b95b5800":"seto_df = sepal_df[sepal_df.index.isin(ind_seto)]\nvers_df = sepal_df[sepal_df.index.isin(ind_vers)]\nvirg_df = sepal_df[sepal_df.index.isin(ind_virg)]","2d3cb67a":"cov_seto = np.cov(np.transpose(np.array(seto_df)))\ncov_vers = np.cov(np.transpose(np.array(vers_df)))\ncov_virg = np.cov(np.transpose(np.array(virg_df)))","847ad1a4":"sepal_df = np.array(sepal_df)","c2c71ef9":"x1 = np.linspace(4,8,150)  \nx2 = np.linspace(1.5,4.5,150)\nX, Y = np.meshgrid(x1,x2) \n\nZ1 = multivariate_normal(s_mean_clus1, cov_seto)  \nZ2 = multivariate_normal(s_mean_clus2, cov_vers)\nZ3 = multivariate_normal(s_mean_clus3, cov_virg)\n\npos = np.empty(X.shape + (2,))                # a new array of given shape and type, without initializing entries\npos[:, :, 0] = X; pos[:, :, 1] = Y   \n\nplt.figure(figsize=(10,10))                                                          # creating the figure and assigning the size\nplt.scatter(sepal_df[:,0], sepal_df[:,1], marker='o')     \nplt.contour(X, Y, Z1.pdf(pos), colors=\"r\" ,alpha = 0.5) \nplt.contour(X, Y, Z2.pdf(pos), colors=\"b\" ,alpha = 0.5) \nplt.contour(X, Y, Z3.pdf(pos), colors=\"g\" ,alpha = 0.5) \nplt.axis('equal')                                                                  # making both the axis equal\nplt.xlabel('Sepal Length', fontsize=16)                                                  # X-Axis\nplt.ylabel('Sepal Width', fontsize=16)                                                  # Y-Axis\nplt.title('Final Clusters(Sepal)', fontsize=22)                                            # Title of the plot\nplt.grid()                                                                         # displaying gridlines\nplt.show()","e17d3834":"#petal\np_mean_clus1 = np.array([centers[seto][2],centers[seto][3]])\np_mean_clus2 = np.array([centers[vers][2],centers[vers][3]])\np_mean_clus3 = np.array([centers[virg][2],centers[virg][3]])","f94c2ca2":"petal_df = df_full.iloc[:,2:4]","7a8850ff":"seto_df = petal_df[petal_df.index.isin(ind_seto)]\nvers_df = petal_df[petal_df.index.isin(ind_vers)]\nvirg_df = petal_df[petal_df.index.isin(ind_virg)]","7aa778a4":"cov_seto = np.cov(np.transpose(np.array(seto_df)))\ncov_vers = np.cov(np.transpose(np.array(vers_df)))\ncov_virg = np.cov(np.transpose(np.array(virg_df)))","9a4c05f1":"petal_df = np.array(petal_df)","ab9dfda3":"x1 = np.linspace(0.5,7,150)  \nx2 = np.linspace(-1,4,150)\nX, Y = np.meshgrid(x1,x2) \n\nZ1 = multivariate_normal(p_mean_clus1, cov_seto)  \nZ2 = multivariate_normal(p_mean_clus2, cov_vers)\nZ3 = multivariate_normal(p_mean_clus3, cov_virg)\n\npos = np.empty(X.shape + (2,))                # a new array of given shape and type, without initializing entries\npos[:, :, 0] = X; pos[:, :, 1] = Y   \n\nplt.figure(figsize=(10,10))                                                          # creating the figure and assigning the size\nplt.scatter(petal_df[:,0], petal_df[:,1], marker='o')     \nplt.contour(X, Y, Z1.pdf(pos), colors=\"r\" ,alpha = 0.5) \nplt.contour(X, Y, Z2.pdf(pos), colors=\"b\" ,alpha = 0.5) \nplt.contour(X, Y, Z3.pdf(pos), colors=\"g\" ,alpha = 0.5) \nplt.axis('equal')                                                                  # making both the axis equal\nplt.xlabel('Petal Length', fontsize=16)                                                  # X-Axis\nplt.ylabel('Petal Width', fontsize=16)                                                  # Y-Axis\nplt.title('Final Clusters(Petal)', fontsize=22)                                            # Title of the plot\nplt.grid()                                                                         # displaying gridlines\nplt.show()","ca795233":"# Calculating the Accuracy","988e725d":"**Below are three different initializations. When the initialization is at the origin all points converge into one cluster and for the other 2 cases we get the clusters as we have initialized before(3 in this code**)**","6fb843c2":"# Updating Membership Value","31d6d7c6":"# Fuzzy C-Means with with cluster centers at random locations within a multi-variate Gaussian distribution with zero-mean and unit-variance.","19a5f719":"# Scatter Plots","a550ccdc":"# Defining parameters","f27c2c9f":"# Loading modules and training data","ef0aee39":"# Calculating accuracy","950a50cb":"# Calculating Cluster Center","424d7c2b":"# Getting the clusters","cb776e28":"# Introduction","571298ff":"The Algorithm****\nFuzzy c-means (FCM) is a method of clustering which allows one piece of data to belong to two or more clusters. This method (developed by Dunn in 1973 and improved by Bezdek in 1981) is frequently used in pattern recognition. You can find the documentation here [https:\/\/home.deib.polimi.it\/matteucc\/Clustering\/tutorial_html\/cmeans.html](http:\/\/)","df49036e":"Here I have only created 3 clusters because we have 3 classes in the Iris data. The MAX_ITER parameter acts as a fuse in our loop inorder to prevent us from the infinite loop. Next, is the fuzzy parameter, if the value is 1 its same as K-nearest neighbours I have taken the value as 1.7","38416c61":"# Plotting the data","e26ad01a":"# Fuzzy C-Means with cluster centers at random vectors chosen from the data.","2b54ec17":"# Fuzzy C-Means with cluster centres at the origin","e08f6ee7":"**Any feedback on this kernel will be highly appreciated!**","3c8543fd":"# Initialize membership matrix"}}