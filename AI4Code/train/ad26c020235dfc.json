{"cell_type":{"b0400759":"code","bb2c9236":"code","956df021":"code","b1e5edad":"code","789d11e5":"code","fa5bb1a3":"code","2512aefc":"code","b8e16421":"code","183c216b":"code","54b52a51":"code","3000b9de":"code","e90c94d7":"code","81fcc632":"code","e881cd2f":"code","75f873cd":"code","39b3da1d":"code","1518a6ea":"code","4f27fbb7":"code","a10b24ff":"code","5ce320ff":"code","aec1b201":"code","e86a1237":"code","e2da56d4":"code","70c14873":"code","0e201fe5":"code","265bd449":"code","454b7bcf":"code","70cdc0b9":"code","35a336b9":"code","41231626":"code","04189171":"code","85b32841":"code","a26e3e43":"code","5f4fe939":"code","92d71c9d":"markdown","f3bb2b0e":"markdown","250f14cf":"markdown","55a50979":"markdown","7d5420d1":"markdown","628a36f6":"markdown","274cbbcf":"markdown","6dcb8ac1":"markdown","d1f4ac82":"markdown","15b64856":"markdown","24988c8e":"markdown","0c92ec28":"markdown","3166cdf2":"markdown","b1ccca01":"markdown","1ae4f485":"markdown","0e324f4e":"markdown","0cdeac26":"markdown","3496b1a5":"markdown","43e39969":"markdown","4a99b3a1":"markdown","82700da5":"markdown","192fff06":"markdown","ec726b28":"markdown","c46cf12d":"markdown","b5c0b145":"markdown","66366b87":"markdown","6c467c9f":"markdown","17aad1b5":"markdown"},"source":{"b0400759":"import pandas as pd\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\nfrom sklearn.impute import KNNImputer\nfrom sklearn.linear_model import LinearRegression\nfrom xgboost import XGBRegressor\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.metrics import mean_squared_error\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","bb2c9236":"path = '\/kaggle\/input\/acea-water-prediction\/'\nfiles = os.listdir(path)\nfiles","956df021":"waterbodies = [wb.split('.')[0] for wb in files if '.csv' in wb]\nprint('number of waterbodies:', len(waterbodies))\nwaterbodies","b1e5edad":"def load_data(waterbody):\n    \"\"\" Load data by name of the waterbody \"\"\"\n    \n    file = waterbody+'.csv'\n    data = pd.read_csv(path+file, index_col=0, parse_dates=True)\n    data.sort_index(inplace=True)\n    return data\n\ndef plot_timeseries(data, feature):\n    \"\"\" Plot a feature as timeseries \"\"\"\n    \n    fig = plt.figure(figsize=(9, 3))\n    ax = fig.add_subplot(111)\n    x = data.index\n    y = data[feature]\n    ax.plot(x, y, label=feature)\n    plt.legend()\n    plt.xlabel('date')\n    plt.grid()\n    plt.title(feature)\n    plt.show()\n    \ndef label_missing_values(s):\n    \"\"\" Label missing values (=0) with None \"\"\"\n    if s == 0:\n        return None\n    else:\n        return s\n    \ndef plot_compare_before_after(data, y_test, target):\n    \"\"\" Compare target before and after prediction \"\"\"\n    \n    fig, axs = plt.subplots(1, 2, figsize=(18, 4))\n    fig.subplots_adjust(hspace = 0.5, wspace=0.2)\n    axs = axs.ravel()\n    x = data.index\n    axs[0].plot(x, data[target])\n    axs[1].plot(x, data[target], label='train')\n    axs[1].plot(y_test.index, y_test.values, label='pred', alpha=0.7)\n    for i in range(2):\n        axs[i].grid()\n        axs[i].set_xlabel('date')\n        axs[i].legend()\n    axs[0].set_title('Before')\n    axs[1].set_title('After')\n\n    plt.show()\n    \ndef plot_corr_matrix(data):\n    \"\"\" Plot the correlation matrix of all features \"\"\"\n    \n    corr = data.corr()\n    return corr.style.background_gradient(cmap='coolwarm', axis=None).set_precision(2)\n\n\ndef timestamp_features(data):\n    \"\"\" Create new features based on the timestamp index \"\"\"\n    \n    data['year']=data.index.year\n    data['month']=data.index.month\n    data['day']=data.index.day\n    \n    return data\n\ndef scale_data(data, targets):\n    \"\"\" Z-score Normalization of feature data \"\"\"\n    \n    data[data.columns.difference(targets)] -= data[data.columns.difference(targets)].mean()\n    data[data.columns.difference(targets)] \/= data[data.columns.difference(targets)].std()\n    return data\n\ndef create_train_and_test(data, targets, target, by_value=0):\n    \"\"\" Create train and test data for modelleing and prediction \"\"\"\n    \n    if by_value==0:\n        X_train = data[data.columns.difference(targets)][data[target]!=0]\n        y_train = data[target][data[target]!=0]\n        \n        X_test = data[data.columns.difference(targets)][data[target]==0]\n        y_test = data[target][data[target]==0]\n        \n    if by_value==None:\n        X_train = data[data.columns.difference(targets)][data[target].notnull()]\n        y_train = data[target][data[target].notnull()]\n        \n        X_test = data[data.columns.difference(targets)][data[target].isnull()]\n        y_test = data[target][data[target].isnull()]\n        \n    return X_train, y_train, X_test, y_test\n\ndef get_best_model_and_accuracy(model, params, X, y):\n    \"\"\" GridSearch for given model and parameters \"\"\"\n    \n    grid = GridSearchCV(model, params,\n                        error_score=0.,\n                        scoring='neg_root_mean_squared_error')\n    grid.fit(X, y)\n    \n    score = -grid.best_score_\n    time_fit = grid.cv_results_['mean_fit_time'].mean()\n    time_score = grid.cv_results_['mean_score_time'].mean()\n    best_params = grid.best_params_\n    \n    print('Best score:', score)\n    print('Best params:', best_params)\n    print('Average Time (Fit)', round(time_fit, 3))\n    print('Average Time (Score)', round(time_score, 3))\n    \n    return [score, time_fit, time_score, best_params]","789d11e5":"compare = pd.DataFrame(index=waterbodies, columns=['samples', 'features', 'features_with_nan'])\nfor waterbody in waterbodies:\n    data = load_data(waterbody)\n    compare.loc[waterbody, 'samples'] = len(data.index)\n    compare.loc[waterbody, 'features'] = len(data.columns)\n    counter = 0\n    for col in data.columns:\n        if data[col].isnull().sum():\n            counter += 1\n    compare.loc[waterbody, 'features_with_nan'] = counter","fa5bb1a3":"compare","2512aefc":"targets = {'Aquifer_Doganella': ['Depth_to_Groundwater_Pozzo_1', 'Depth_to_Groundwater_Pozzo_2', 'Depth_to_Groundwater_Pozzo_3',\n                                 'Depth_to_Groundwater_Pozzo_4', 'Depth_to_Groundwater_Pozzo_5', 'Depth_to_Groundwater_Pozzo_6',\n                                 'Depth_to_Groundwater_Pozzo_7', 'Depth_to_Groundwater_Pozzo_8', 'Depth_to_Groundwater_Pozzo_9'],\n           'Aquifer_Auser': ['Depth_to_Groundwater_SAL', 'Depth_to_Groundwater_CoS', 'Depth_to_Groundwater_LT2'],\n           'Water_Spring_Amiata': [ 'Flow_Rate_Bugnano', 'Flow_Rate_Arbure',\n                                    'Flow_Rate_Ermicciolo', 'Flow_Rate_Galleria_Alta'],\n           'Lake_Bilancino': ['Lake_Level', 'Flow_Rate'],\n           'Water_Spring_Madonna_di_Canneto': ['Flow_Rate_Madonna_di_Canneto'],\n           'Aquifer_Luco': ['Depth_to_Groundwater_Podere_Casetta'],\n           'Aquifer_Petrignano': ['Depth_to_Groundwater_P24', 'Depth_to_Groundwater_P25'],\n           'Water_Spring_Lupa': ['Flow_Rate_Lupa'],\n           'River_Arno': ['Hydrometry_Nave_di_Rosano']}","b8e16421":"River_Arno = load_data('River_Arno')\ntargets['River_Arno']","183c216b":"River_Arno = timestamp_features(River_Arno)","54b52a51":"plot_timeseries(River_Arno, targets['River_Arno'][0])","3000b9de":"River_Arno[River_Arno[targets['River_Arno']]==0].head()","e90c94d7":"plot_corr_matrix(River_Arno)","81fcc632":"date_from = '2005-01-01'\nRiver_Arno = River_Arno[date_from:]","e881cd2f":"River_Arno[River_Arno.columns.difference(targets['River_Arno'])] = River_Arno[River_Arno.columns.difference(targets['River_Arno'])].fillna(River_Arno[River_Arno.columns.difference(targets['River_Arno'])].mean())\nRiver_Arno[targets['River_Arno']] = River_Arno[targets['River_Arno']].fillna(0)","75f873cd":"River_Arno = scale_data(River_Arno, targets['River_Arno'])","39b3da1d":"X_train, y_train, X_test, y_test = create_train_and_test(River_Arno,\n                                                         targets['River_Arno'],\n                                                         targets['River_Arno'][0],\n                                                         by_value=0)","1518a6ea":"model_XGB = XGBRegressor(random_state=2020)\nparams_XGB = {'n_estimators': [5, 10, 50, 100],\n              'max_depth': [1, 2, 3, 4, 5]} \nscore, time_fit, time_score, best_params = get_best_model_and_accuracy(model_XGB, params_XGB,\n                                                                       X_train, y_train)","4f27fbb7":"model_LR = LinearRegression()\nparams_LR = {}\nscore, time_fit, time_score, best_params = get_best_model_and_accuracy(model_LR, params_LR,\n                                                                       X_train, y_train)","a10b24ff":"model_LR.fit(X_train, y_train)\ny_pred = model_LR.predict(X_test)","5ce320ff":"y_test[:]=y_pred","aec1b201":"River_Arno[targets['River_Arno'][0]] = River_Arno[targets['River_Arno'][0]].apply(label_missing_values)","e86a1237":"plot_compare_before_after(River_Arno, y_test, targets['River_Arno'][0])","e2da56d4":"Aquifer_Luco = load_data('Aquifer_Luco')\ntargets['Aquifer_Luco']","70c14873":"plot_timeseries(Aquifer_Luco, targets['Aquifer_Luco'][0])","0e201fe5":"Aquifer_Luco = timestamp_features(Aquifer_Luco)","265bd449":"Aquifer_Luco[Aquifer_Luco.columns.difference(targets['Aquifer_Luco'])] = Aquifer_Luco[Aquifer_Luco.columns.difference(targets['Aquifer_Luco'])].fillna(Aquifer_Luco[Aquifer_Luco.columns.difference(targets['Aquifer_Luco'])].mean())","454b7bcf":"plot_corr_matrix(Aquifer_Luco)","70cdc0b9":"Aquifer_Luco = scale_data(Aquifer_Luco, targets['Aquifer_Luco'])","35a336b9":"X_train, y_train, X_test, y_test = create_train_and_test(Aquifer_Luco,\n                                                         targets['Aquifer_Luco'],\n                                                         targets['Aquifer_Luco'][0],\n                                                         by_value=None)","41231626":"model_XGB = XGBRegressor(random_state=2020)\nparams_XGB = {'n_estimators': [1000, 1500, 2000],\n              'max_depth': [1, 2, 3, 4, 5]} \nscore, time_fit, time_score, best_params_XGB = get_best_model_and_accuracy(model_XGB, params_XGB,\n                                                                           X_train, y_train)","04189171":"model_LR = LinearRegression()\nparams_LR = {}\nscore, time_fit, time_score, best_params = get_best_model_and_accuracy(model_LR, params_LR,\n                                                                       X_train, y_train)","85b32841":"model_XGB = XGBRegressor(random_state=2020)\nmodel_XGB.set_params(**best_params_XGB)\nmodel_XGB.fit(X_train, y_train)\ny_pred = model_XGB.predict(X_test)","a26e3e43":"y_test[:]=y_pred","5f4fe939":"plot_compare_before_after(Aquifer_Luco, y_test['2008-01-01':], targets['Aquifer_Luco'][0])","92d71c9d":"Plot the target over the time:","f3bb2b0e":"# Intro\nWelcome to the [Acea Smart Water Analytics](https:\/\/www.kaggle.com\/c\/acea-water-prediction) competition.\n![](https:\/\/storage.googleapis.com\/kaggle-competitions\/kaggle\/24191\/logos\/header.png)\n\nThere are different waterbodies with different features. We will consider \n* Aquifer,\n* Water Spring,\n* Lake,\n* River.\n\nThe goal is to predict the amount of water in each unique waterbody.\n\n<span style=\"color: royalblue;\">Please vote the notebook up if it helps you. Thank you. <\/span>","250f14cf":"# Models\nThe goal is to generate four mathematical models, one for each category of waterbody (acquifers, water springs, river, lake) that might be applicable to each single waterbody.","55a50979":"# Libraries\nWe load some standard libraries and packages of sklearn.","7d5420d1":"Scale data:","628a36f6":"# Path\nDefine input path and show content files.","274cbbcf":"Define train and test data randomly:","6dcb8ac1":"Scale data:","d1f4ac82":"Grid Search with XGB:","15b64856":"# Overview\nThe datafiles are small. So we can load them on demand.","24988c8e":"Fill missing values with column mean value:","0c92ec28":"Create new features based on the timestamp index:","3166cdf2":"# Targets\nStore the targets of every waterbody in a dictonary by definition.","b1ccca01":"Modelling and Prediction:","1ae4f485":"There are 187 values with a target value equal to 0. We want to predict this values and use them as test data.","0e324f4e":"Grid Search with Linear Regression:","0cdeac26":"# Functions\nWe define some helper functions for ploting, feature engineering and calculations.","3496b1a5":"Plot the correlation matrix:","43e39969":"As we can see there are a lot of features with nan values. So we have to think about handling missing values. For that we recommend this [notebook](https:\/\/www.kaggle.com\/drcapa\/pima-indians-diabetes-eda-handle-missing-values).","4a99b3a1":"Fill missing feature values by mean.","82700da5":"Plot the correlation matrix.","192fff06":"## River Arno\nThe target which we want to predict is Hydrometry_Nave_di_Rosano","ec726b28":"Define train and test data randomly:","c46cf12d":"## Aquifer_Luco\nThere is only one target with the name Depth_to_Groundwater_Podere_Casetta.","b5c0b145":"Plot the timeseries with missing values.","66366b87":"# Waterbodies\nWrite the waterbodies into a list. ","6c467c9f":"Plot the timeseries before and after prediction. The image with the title before shows the origin data with nan values. The after image shows the origin data and the prediction for nan values.","17aad1b5":"Create new features based on the timestamp index:"}}