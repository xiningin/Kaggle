{"cell_type":{"a2a9817a":"code","a414932d":"code","ef8d1ba8":"code","1fb4d862":"code","ddb6a741":"code","8e15d9ee":"code","4b514d07":"code","ab4354d9":"code","b51636c2":"code","e91a241f":"code","d43749aa":"code","0acb7726":"code","e3e9c6d5":"code","6bfcc95b":"code","73acbc97":"code","4fb8e78c":"code","adb017ae":"code","028eff66":"code","208a1c6c":"code","8c405988":"code","5cb0e39a":"code","4d46d7f3":"code","85870d46":"code","b37f9643":"code","d1f19582":"code","ee453af4":"markdown"},"source":{"a2a9817a":"from keras.models import Sequential, Model\nfrom keras.layers import Dense\nfrom keras.layers import Flatten\nfrom keras.layers.convolutional import Conv2D\nfrom keras.layers.convolutional import MaxPooling2D\nfrom keras import backend as K\nfrom keras.utils import np_utils, to_categorical\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import accuracy_score\nfrom scipy.spatial import distance\nimport numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport string","a414932d":"data = pd.read_csv('\/kaggle\/input\/az-handwritten-alphabets-in-csv-format\/A_Z Handwritten Data.csv')","ef8d1ba8":"print(data.shape)","1fb4d862":"data.rename(columns={'0':'label'}, inplace=True)\ndata[\"label\"] = data.apply(lambda x: string.ascii_uppercase[x[\"label\"]], axis=1)","ddb6a741":"data[\"label\"].value_counts()","8e15d9ee":"zero_shot_categories = [\"J\", \"D\", \"H\", \"R\", \"Z\"]","4b514d07":"category_vectors = {\n    \"A\": [4,8,10,12],\n    \"B\": [1,5,11,15],\n    \"C\": [11,13],\n    \"D\": [1,5,11],\n    \"E\": [1,4,5,6],\n    \"F\": [1,4,6],\n    \"G\": [4,11,13,14],\n    \"H\": [1,3,4],\n    \"I\": [2],\n    \"J\": [3,11],\n    \"K\": [1,8,12],\n    \"L\": [1,7],\n    \"M\": [1,3,8,12],\n    \"N\": [1,3,8],\n    \"O\": [5,11,13,14],\n    \"P\": [1,5,15],\n    \"Q\": [5,8,13,14],\n    \"R\": [1,5,8,15],\n    \"S\": [8,11,13],\n    \"T\": [2,6],\n    \"U\": [1,3,11,14],\n    \"V\": [8,9,12],\n    \"W\": [8,9,10,12],\n    \"X\": [8,12],\n    \"Y\": [2,8,12],\n    \"Z\": [6,7,12]\n}","ab4354d9":"for d in category_vectors.keys():\n    category_vectors[d] = sum(to_categorical([v-1 for v in category_vectors[d]], num_classes=15))","b51636c2":"data[\"category_vector\"] = data.apply(lambda x: category_vectors[x[\"label\"]], axis=1)","e91a241f":"data_X = data[~data[\"label\"].isin(zero_shot_categories)].drop([\"label\", \"category_vector\"],axis=1)\ndata_Y = np.asarray(list(data[~data[\"label\"].isin(zero_shot_categories)][\"category_vector\"]))\nzero_X = data[data[\"label\"].isin(zero_shot_categories)].drop([\"label\", \"category_vector\"],axis=1)\nzero_Y = np.asarray(list(data[data[\"label\"].isin(zero_shot_categories)][\"category_vector\"]))","d43749aa":"train_X, test_X, train_Y, test_Y = train_test_split(data_X, data_Y, random_state=42)","0acb7726":"standard_scaler = MinMaxScaler()\n\ntrain_X = standard_scaler.fit_transform(train_X)\ntest_X = standard_scaler.transform(test_X)\nzero_X = standard_scaler.transform(zero_X)\n\ntrain_X = train_X.reshape((train_X.shape[0], 28, 28, 1)).astype('float32')\ntest_X = test_X.reshape((test_X.shape[0], 28, 28, 1)).astype('float32')\nzero_X = zero_X.reshape((zero_X.shape[0], 28, 28, 1)).astype('float32')\n","e3e9c6d5":"plt.imshow(train_X[0].reshape((28,28)))","6bfcc95b":"print(\"Train X:\", train_X.shape)\nprint(\"Test X:\", test_X.shape)\nprint(\"Train Y:\", train_Y.shape)\nprint(\"Test Y:\", test_Y.shape)","73acbc97":"model = Sequential()\nmodel.add(Conv2D(16, (3, 3), padding=\"same\", activation='relu', input_shape=(28, 28, 1)))\nmodel.add(MaxPooling2D((2, 2)))\nmodel.add(Conv2D(32, (3, 3), padding=\"same\", activation='relu'))\nmodel.add(MaxPooling2D((2, 2)))\nmodel.add(Flatten())\nmodel.add(Dense(15, activation='sigmoid'))\nmodel.compile(optimizer=\"Adam\", loss='binary_crossentropy', metrics=['binary_accuracy'])\nmodel.summary()","4fb8e78c":"model.fit(train_X, train_Y, epochs=50, batch_size=256, validation_data=(test_X, test_Y))","adb017ae":"def nearest_category(vector, only_zero_shot=False):\n    nearest = \"\"\n    value = -1\n    if only_zero_shot:\n        categories = zero_shot_categories\n    else:\n        categories = category_vectors.keys() #all categories\n    for k in categories:\n        d = distance.euclidean(vector, category_vectors[k])\n        if d < value or value == -1:\n            nearest = k\n            value = d\n    return nearest","028eff66":"def hard_decision(predictions, only_zero_shot=False):\n    output = []\n    for pred in predictions:\n        output.append(nearest_category([round(p) for p in pred], only_zero_shot))\n    return output","208a1c6c":"train_pred = model.predict(train_X)\ntest_pred = model.predict(test_X)\nzero_pred = model.predict(zero_X)","8c405988":"accuracy_score(hard_decision(test_Y), hard_decision(test_pred))","5cb0e39a":"accuracy_score(hard_decision(zero_Y), hard_decision(zero_pred, only_zero_shot=True))","4d46d7f3":"accuracy_score(hard_decision(zero_Y), hard_decision(zero_pred))","85870d46":"def plot_feature_maps(feature_maps):\n    plt.figure(figsize=(8, 8))\n    square = 4\n    ix = 1\n    for _ in range(square):\n        for _ in range(square):\n            ax = plt.subplot(square, square, ix)\n            ax.set_xticks([])\n            ax.set_yticks([])\n            # plot filter channel in grayscale\n            plt.imshow(feature_maps[0, :, :, ix-1], cmap='gray')\n            ix += 1\n    # show the figure\n    plt.show()","b37f9643":"fm_model = Sequential()\nfm_model.add(model.layers[0])\n#fm_model.add(model.layers[1])\n#fm_model.add(model.layers[2])","d1f19582":"plot_feature_maps(fm_model.predict(np.array([zero_X[14000]])))","ee453af4":"## Visualizing convolutional feature maps"}}