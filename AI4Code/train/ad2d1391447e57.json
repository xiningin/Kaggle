{"cell_type":{"e88b45cf":"code","68c6624d":"code","adde80d0":"code","9cf63bf8":"code","7f812b85":"code","f4642b53":"code","f005c730":"code","cec8ee47":"code","7c81d93f":"code","186939bd":"code","9b970c6f":"code","28b6a626":"code","08e4496e":"code","bfb70272":"code","483f771b":"code","d35d233c":"code","ad5da65b":"code","cf83311f":"code","46983046":"code","0b2cdaf7":"code","3ddc3777":"code","8c6ba32d":"code","05b4133e":"code","872dd282":"code","077b2b35":"code","c373c1f1":"markdown","cbc1d9e6":"markdown","f8c4668b":"markdown","e7343812":"markdown","6a1a97fe":"markdown","a2bc8489":"markdown","7a985dcf":"markdown","95d329d2":"markdown","a6719268":"markdown","d3e4fba0":"markdown","b2bd6a62":"markdown","1ae196ce":"markdown","f7ce2cb2":"markdown","2e14969d":"markdown","1fac1a38":"markdown","e5a7bc4c":"markdown","2a7516c6":"markdown"},"source":{"e88b45cf":"# Import libraries\nimport numpy as np\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler, PolynomialFeatures\nfrom sklearn.metrics import roc_auc_score\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.simplefilter(\"ignore\")","68c6624d":"# Load data using pandas\ndata = pd.read_csv(\"..\/input\/2016 County Election Data.csv\")","adde80d0":"# View column names\ndata.columns","9cf63bf8":"# Dataframe shape\ndata.shape","7f812b85":"# Take a glimpse of the data\ndata.head()","f4642b53":"data.info()","f005c730":"data.describe()","cec8ee47":"# Distribution of results\nprint('Trump Won Counties: ', len(data.loc[data['Clinton-lead'] < 0]), ', Mean Trump County Pop.: ', round(data.loc[data['Clinton-lead'] < 0]['Population'].mean(), 1))\nprint('Clinton Won Counties: ', len(data.loc[data['Clinton-lead'] > 0]), ', Mean Clinton County Pop.: ', round(data.loc[data['Clinton-lead'] > 0]['Population'].mean(), 1))\n","7c81d93f":"# Put the election results into bins\ndata['Results_binned'] = pd.cut(data['Clinton-lead'], bins = np.linspace(-100, 100, num = 7))\ndata.head()","186939bd":"# Group by the bin and review averages\ndata.groupby('Results_binned').mean()","9b970c6f":"data.corr()['Clinton-lead'].sort_values()","28b6a626":"data.corr()['Clinton-lead'].abs().sort_values(ascending = False)","08e4496e":"# Correlation Heatmap\nplt.figure(figsize=(10,10))\nmask = np.triu(np.ones_like(data.corr(), dtype=np.bool))\n#heatmap = sns.heatmap(data.corr(), mask=mask, cmap=plt.cm.RdBu_r, annot=True)\nheatmap = sns.heatmap(data.corr(), mask=mask, cmap=sns.color_palette(\"RdBu_r\", 7), annot=True)\nheatmap.set_title('Correlation Heatmap')\nplt.show()","bfb70272":"# Create histograms for each data column\nplt.style.use('fivethirtyeight')\nplt.rcParams['figure.figsize'] = (14,14)\ndata.hist(density=True, edgecolor='k');","483f771b":"# use the column that contains Clinton's margin of victory to create a column for our labels (Trump or Clinton victory)\ndata.loc[data[\"Clinton-lead\"] > 0, \"Label\"] = \"CLINTON\"\ndata.loc[data[\"Clinton-lead\"] <  0, \"Label\"] = \"TRUMP\"\n\n# we no longer need the binned results column and can drop it\ndata.drop([\"Results_binned\"], axis=1, inplace=True)","d35d233c":"sns.distributions._has_statsmodels = False\nnum_cols = len(data.columns[1:-1])\nplt.figure(figsize=(10, num_cols*8))\n\nfor i, col in enumerate(data.columns[1:-2]):\n  plt.subplot(num_cols, 1, i + 1)\n  sns.kdeplot(data.loc[data['Label'] == 'CLINTON', col], label='Clinton Counties', shade=True)\n  sns.kdeplot(data.loc[data['Label'] == 'TRUMP', col], label='Trump Counties', shade = True)\n  plt.ylabel('Density')\n  plt.xlabel('%s' % col)\n  plt.title('Distribution of %s' % col)","ad5da65b":"# Simple functions we can reuse to return a trained random forest model and to split our data into training and testing datasets\ndef trained_model(X, y):\n  model = RandomForestClassifier(random_state=7)\n  model.fit(X, y)\n  return model\n\ndef split_data(X, y, test_size=.2):\n  # Split the data into training and test sets\n  return train_test_split(X, y, test_size=test_size, random_state=5)","cf83311f":"y = data['Label'].values\n# Create a dataframe with the county features (X values). We exclude the county name, Clinton-lead, and Label columns.\nfeatures = data[data.columns[1:-2]]","46983046":"# Train the model using only the features that are in the original data\nX_train, X_test, y_train, y_test = split_data(features, y)\nmodel_original_feat = trained_model(X_train, y_train)\nprint('Accuracy score using original features only: ', round(model_original_feat.score(X_test, y_test) * 100, 2))\nprint('ROC AUC score using original features: ', round(roc_auc_score(y_test, model_original_feat.predict_proba(X_test)[:, 1]) * 100, 2))","0b2cdaf7":"# Create the polynomial object and fit using the original features\npoly_transformer = PolynomialFeatures(degree=3, include_bias=False)\npoly_transformer.fit(features)\npoly_features = poly_transformer.transform(features)\nfeature_names = poly_transformer.get_feature_names(input_features=features.columns)\npoly_features.shape","3ddc3777":"X_train, X_test, y_train, y_test = split_data(poly_features, y)\nmodel_poly_feat = trained_model(X_train, y_train)\nprint('Score using polynomial features: ', round(model_poly_feat.score(X_test, y_test) * 100, 2))\nprint('ROC AUC score using polynomial features: ', round(roc_auc_score(y_test, model_poly_feat.predict_proba(X_test)[:, 1]) * 100, 2))","8c6ba32d":"scaler = MinMaxScaler()\n\nX = scaler.fit_transform(features)\nX_train, X_test, y_train, y_test = split_data(X, y)\nmodel_scaled_feat = trained_model(X_train, y_train)\nprint('Score using MinMaxScaler on original features: ', round(model_scaled_feat.score(X_test, y_test) * 100, 2))\nprint('ROC AUC score using MinMaxScaler original features: ', round(roc_auc_score(y_test, model_scaled_feat.predict_proba(X_test)[:, 1]) * 100, 2))","05b4133e":"def predict_winner(county, model):\n    X = data[data['County'] == county][data.columns[1:-2]]\n    y = data[data['County'] == county]['Clinton-lead'].values[0]\n    prediction  = model.predict(X)[0]\n    print(county)\n    print(\"Predicted Winner: {0}\\nClinton margin of victory: {1}\\n\".format(prediction, y))","872dd282":"# Select 15 random counties\nrandom_counties = data.sample(n=15)\nrandom_counties","077b2b35":"# Predict the election winner for each county in the counties list\nfor county in random_counties['County']:\n  predict_winner(county, model_original_feat)","c373c1f1":"## 3.2. Correlation <a class=\"anchor\" id=\"Correlation\"><\/a>","cbc1d9e6":"# 6. Predict County Results <a class=\"anchor\" id=\"Predict-County-Results\"><\/a>","f8c4668b":"It appears that using the polynomial features does not improve the accuracy of our model and may actually decrease the accuracy. Let's try using a MinMaxScaler on the original features to see if that helps improve the accuracy.","e7343812":"We can see above that Trump won the majority of counties; however, when we look at the average population size of the counties each candidate won, the mean population of the Clinton counties was about seven times the size of the mean population in Trump-won counties.","6a1a97fe":"## 3.1. Review Data <a class=\"anchor\" id=\"Review-Data\"><\/a>","a2bc8489":"It looks like the use of the scaler does not improve the results in any meaningful way. \n\nLet's create a function below to select a county at random and predict the winner.","7a985dcf":"- [1. Introduction](#Introduction)\n- [2. Load Data](#Load-Data)\n- [3. Data Exploration](#Data-Exploration)\n    * [3.1 Review Data](#Review-Data)    \n    * [3.2 Correlation](#Correlation)    \n    * [3.3 Histograms](#Histograms)\n    * [3.4 KDE Plots](#KDE-Plots)\n- [4. Model Creation](#Model-Creation)\n- [5. Feature Engineering](#Feature-Engineering)\n- [6. Predict County Results](#Predict-County-Results)\n- [7. Conclusion](#Conclusion)","95d329d2":"# 4. Model Creation <a class=\"anchor\" id=\"Model-Creation\"><\/a>\n\nLet's build a random forest model to predict the election results. Due to the imbalance in the number of counties carried by each candidate, I will use AUC-ROC score in addition to the accuracy score to measure the model's performance.","a6719268":"# 5. Feature Engineering <a class='anchor' id='Feature-Engineering'><\/a>\n\nLet's engineer some polynomial features (using sklearn) to see if that improves our baseline results.","d3e4fba0":"It appears that as population density and the prevalence of poverty increase, so does the margin of Clinton's victory. Additionally, as the percentage of the population that is white increases, so does Trump's margin of victory.\n\nIf we look at correlated values below, an increase in the percent of the population that was white was the only feature that was correlated with an increase in the vote for Trump.","b2bd6a62":"# 1. Introduction <a class=\"anchor\" id=\"Introduction\"><\/a>\n\nAs we approach the 2020 election, many analysts will attempt to predict the outcome of the election using a combination of past results and recent polling. Here, I conducted some exploratory data analysis on the 2016 results, then used the results to train a random forest model in order to predict the results for each county.\n\nThe dataset was created by augmenting the 2016 election results with demographic and socioeconomic data. All of the features contained in the data are useful, so we do not need to spend time extracting the most useful features. Please note, the \"Clinton-lead\" column contains the margin of Clinton victory; therefore any negative number is the margin of Trump's victory for that county.","1ae196ce":"# 3. Data Exploration <a class=\"anchor\" id=\"Data-Exploration\"><\/a>","f7ce2cb2":"Here, we can see that the percentage white and bachlors-degree or higher have the strongest correlation with the percentage of vote the candidates received.","2e14969d":"## 3.4. KDE Plots <a class=\"anchor\" id=\"KDE-Plots\"><\/a>","1fac1a38":"## 3.3. Histograms <a class=\"anchor\" id=\"Histograms\"><\/a>","e5a7bc4c":"# 7. Conclusion <a class='anchor' id='Conclusion'><\/a>\nWe can see that the random forest model does a decent job of predicting whether Trump or Clinton will carry a county based on a small number of features. There are some counties that are difficult to predict based on demographic and socioeconomic data alone and past election results may be needed to more accurately predict these counties.\n\nI welcome any suggestions on how to imrove this notebook. If you found this helpful, please upvote, thanks!","2a7516c6":"# 2. Load Data <a class=\"anchor\" id=\"Load-Data\"><\/a>"}}