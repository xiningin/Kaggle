{"cell_type":{"953b128d":"code","6f9cd8fd":"code","746f0859":"code","47522345":"code","6fe3b864":"code","0dd6237d":"code","9e3a8e2d":"code","1f89d1aa":"code","96bd017d":"code","a9f647f3":"code","d429af77":"code","4173b0c8":"code","01502ccf":"code","da3e002c":"code","70523193":"code","558f0047":"code","0bf88b00":"code","a2affc81":"code","d215f0fe":"code","36f6fada":"code","d7fe358d":"code","93638dd7":"markdown","ccd85487":"markdown","0215eb9c":"markdown","fca47778":"markdown","f309f62b":"markdown","228180a7":"markdown","aee30af6":"markdown","83dd8bb9":"markdown","233ab5a7":"markdown","79e8b21d":"markdown","048a934e":"markdown","ba9c026b":"markdown","dbc3f0a8":"markdown","93815d6d":"markdown","c17b5520":"markdown","3eb79b1a":"markdown","bdb05d01":"markdown","6b5cb3b5":"markdown","25b3c278":"markdown","7ce63cdd":"markdown"},"source":{"953b128d":"import numpy as np\nimport pandas as pd","6f9cd8fd":"# Transformation d'une liste en vecteur :\nma_liste = [1,20,13,40,25]\nprint('ma_liste :')\nprint(ma_liste)\nmon_vecteur = np.array(ma_liste)\nprint('\\nmon vecteur :')\nprint(mon_vecteur)\n\n# Taille d'un vecteur :\nprint('\\nTaille de mon vecteur (m\u00eame appel que pour une liste) :')\nprint(len(mon_vecteur))\nprint('\\nDimension de mon vecteur (m\u00eame appel que pour une matrice) :')\nprint(mon_vecteur.shape) # Retourne un tupple","746f0859":"# Cr\u00e9ation d'un vecteur de taille n :\nn=5\nmon_vecteur = np.repeat(10, n)\nprint('Vecteur de r\u00e9p\u00e9tant une valeur :')\nprint(mon_vecteur)\n\nmon_vecteur = np.zeros(n)\nprint('\\nVecteur de 0 :')\nprint(mon_vecteur)\n\nmon_vecteur = np.ones(n)\nprint('\\nVecteur de 1 :')\nprint(mon_vecteur)\n\nmon_vecteur = np.linspace(0,10,n)\nprint('\\nVecteur de n valeurs a intervalles r\u00e9guliers entre 0 et 10 :')\nprint(mon_vecteur)","47522345":"mon_vecteur = np.linspace(0,10,5)\n\nprint('Multiplication par un scalaire :')\nprint(mon_vecteur * 2)\n\nprint('\\nComparaison \u00e0 un scalaire :')\nprint(mon_vecteur > 5)\n\nprint('\\nOp\u00e9ration avec un autre vecteur :')\nprint(mon_vecteur + np.ones(5))\n\nprint('\\nComparaison avec un autre vecteur :')\nprint(mon_vecteur > np.repeat(4,5))\n\nprint('\\nProduit vectoriel :')\nprint(np.dot(mon_vecteur, np.repeat(2,5)))\n\ndef custom_function(x):\n    if x%5==0 : # Si x est un multiple de 5 (i.e. x modulo 5 = 0)\n        y = x**2 # alors y = x\u00b2\n    else : y = x # sinon y = x\n    return(y)\nvectorized_function = np.vectorize(custom_function)\nprint('\\nAppliquer une fonction construite \u00e0 la main, \u00e9l\u00e9ment par \u00e9l\u00e9ment :')\nprint(vectorized_function(mon_vecteur))\n# Avec une boucle on pourrait faire : np.array([custom_function(x) for x in mon_vecteur])","6fe3b864":"mon_vecteur = np.linspace(0,100,11) # Vecteur de 11 \u00e9l\u00e9m\u00e9nts\n\nprint('Mon vecteur :')\nprint(mon_vecteur)\n\nprint('\\n5\u00e8me \u00e9l\u00e9ment du vecteur :') # Attention : l'indice du premier \u00e9l\u00e9ment d'un vecteur est toujours 0\nprint(mon_vecteur[4])\n\nprint('\\n3\u00e8me \u00e9l\u00e9ment en partant de la fin :') # Le premier \u00e9l\u00e9ment en partant de la fin est obtenu par l'index -1\nprint(mon_vecteur[-3])\n\nprint('\\n2\u00e8me au 5\u00e8me \u00e9l\u00e9ments : ')\nprint(mon_vecteur[1:5])","0dd6237d":"# Mask pour ne r\u00e9cup\u00e9rer que les lignes (index) paires :\nmask_pair = [i%2==0 for i in range(len(mon_vecteur))]\nprint(\"Mask lignes (index) pair :\")\nprint(mask_pair) # liste\nprint(\"Mon vecteur filtr\u00e9 :\")\nprint(mon_vecteur[mask_pair])\n\n# Mask pour ne r\u00e9cup\u00e9rer que les \u00e9l\u00e9ments sup\u00e9rieurs \u00e0 50 :\nmask_sup50 = mon_vecteur > 50\nprint(\"\\nMask \u00e9l\u00e9ments sup\u00e9rieurs \u00e0 50 :\")\nprint(mask_sup50) # np.array\nprint(\"Mon vecteur filtr\u00e9 :\")\nprint(mon_vecteur[mask_sup50])","9e3a8e2d":"# Transformation d'une liste de listes en matrice :\nma_liste_de_listes = [\n    [1,20,13,40,25],\n    [5,8,75,3,12],\n    [54,32,12,3,54],\n    [5,78,5,66,4]\n]\nprint('Ma liste de listes:')\nprint(ma_liste_de_listes)\nma_matrice = np.array(ma_liste_de_listes)\nprint('\\nMa matrice :')\nprint(ma_matrice)\n\n# Taille de la matrice :\nprint('\\nDimension de mon vecteur :')\nprint(ma_matrice.shape) # Retourne un tuple\nprint('\\nLa fonction de base len renvoie le nombre de lignes :')\nprint(len(ma_matrice))","1f89d1aa":"# Cr\u00e9er une matrice avec les fonctions np.ones, np.zeros ...\nprint(\"Matrice de 1 :\")\nprint(np.ones( shape=(4,5) ))\n\n# Cr\u00e9er une matrice \u00e0 partir d'une liste de valeurs :\nliste_plate = [i for i in range(12)]\nprint(\"\\nVecteur d'origine :\")\nprint(liste_plate)\nprint(\"\\nMatrice \u00e0 3 lignes et 4 colonnes :\")\nma_matrice = np.reshape(liste_plate, (3,4))\nprint(ma_matrice)\nprint(\"\\nOn r\u00e9\u00e9crit la matrice en matrice \u00e0 6 lignes et 2 colonnes :\")\nprint(ma_matrice.reshape(6, 2))","96bd017d":"ma_matrice = np.reshape([i for i in range(20)], (5,4))\nprint(\"Ma matrice :\")\nprint(ma_matrice)\nprint(\"Dimension de la matrice : \"+str(ma_matrice.shape))\n\nprint(\"\\nAcc\u00e9der \u00e0 l'\u00e9l\u00e9ment en ligne 2 et colonne 3 :\")\nprint(ma_matrice[1,2]) # Rappel, le premier index \u00e0 toujours la valeur 0\n\nprint(\"\\nOp\u00e9ration sur matrice (somme) :\")\nprint(np.sum(ma_matrice))\n\nprint(\"\\nOp\u00e9ration avec un scalaire :\")\nprint(ma_matrice * 10)\nprint(\"\\nPlusieurs op\u00e9rations successives avec scalaires :\")\nprint((ma_matrice-8)**2)\n\nprint(\"\\nComparaison \u00e9l\u00e9ment \u00e0 \u00e9l\u00e9ment, avec une autre matrice de dimension identique :\")\nprint(ma_matrice < (ma_matrice-10)**2)\n\nmask = ma_matrice < (ma_matrice-8)**2\nma_matrice[mask] = -1\nprint(\"\\nRemplacer par -1 les valeurs de la matrice d'origine lorsque ses valeurs sont inf\u00e9rieures \u00e0 celles de la matrice transform\u00e9e :\")\nprint(ma_matrice)","a9f647f3":"ma_matrice = np.reshape([i for i in range(20)], (5,4))\nprint(\"Ma matrice :\")\nprint(ma_matrice)\n\nmask_lignes = [True, False, True, True, False]\nmask_colonnes = [False, True, True, False]\nprint(\"\\nNe garder que les lignes 1, 3 et 4 :\")\nprint(ma_matrice[mask_lignes,:])\nprint(\"Ne garder que les colonnes 2 et 3 :\")\nprint(ma_matrice[:,mask_colonnes])\n\nprint(\"\\nOp\u00e9ration par ligne (somme) :\")\nprint(np.sum(ma_matrice, axis=0))\nprint(\"Op\u00e9ration par colonne (somme) :\")\nprint(np.sum(ma_matrice, axis=1))\n\ndef custom_function(x):\n    v_round = np.vectorize(round) # Vectorisation de la fonction d'arrondi\n    y = v_round(x**2 \/ x.mean(),2)\n    return(y)\nprint(\"\\nFonction custom appliqu\u00e9e ligne par ligne :\")\nprint(np.apply_along_axis(custom_function, axis=0, arr=ma_matrice))\nprint(\"Fonction custom appliqu\u00e9e colonne par colonne :\")\nprint(np.apply_along_axis(custom_function, axis=1, arr=ma_matrice))\n\n","d429af77":"mon_vecteur = np.array([i**2 for i in range(9)])\nma_serie = pd.Series(mon_vecteur)\nprint(\"Mon vecteur :\")\nprint(mon_vecteur)\nprint(\"Ma s\u00e9rie :\")\nprint(ma_serie)\nprint(\"Passer de la s\u00e9rie pandas au vecteur numpy :\")\nprint(ma_serie.values)\n\nma_matrice = mon_vecteur.reshape((3,3))\nmon_df = pd.DataFrame(ma_matrice)\nprint(\"\\nMa matrice :\")\nprint(mon_vecteur)\nprint(\"Mon data frame :\")\nprint(mon_df)\nprint(\"Passer du data frame pandas \u00e0 la matrice numpy :\")\nprint(mon_df.values)","4173b0c8":"mon_df.columns = ['X1','X2','X3']\nmon_df.index = [\"row1\",\"row2\",\"row3\"]\nprint(\"Mon data frame apr\u00e8s ajout de nom de colonnes et de lignes :\")\nprint(mon_df)\n\n\nprint(\"\\nOn r\u00e9cup\u00e8re facilement les noms de colonnes et de lignes :\")\nprint(mon_df.columns.values)\nprint(mon_df.index.values)","01502ccf":"print('Afficher la colonne X1 sous forme de s\u00e9rie :')\nprint(mon_df.X1)\n\nprint('-'*30)\nprint('\\nAfficher la ligne row2 :')\nprint(mon_df.loc['row2'])\nprint('\\nAfficher les colones X1 et X3 :')\nprint(mon_df.loc[:,['X1','X3']])\nprint('\\nAfficher la colonne X2 des row1 et row3 :')\nprint(mon_df.loc[['row1','row3'],'X2'])\n\nprint('-'*30)\nprint('\\nAfficher les deux premi\u00e8res lignes :')\nprint(mon_df.iloc[:2])\nprint('\\nAfficher la colonne 2 :')\nprint(mon_df.iloc[:,2])\nprint('\\nAfficher la colonne 1 et 3 de la derni\u00e8re ligne :')\nprint(mon_df.iloc[-1,[0,2]])\n\nprint('-'*30)\nprint('\\nAfficher la premi\u00e8re ligne avec un mask :')\nprint(mon_df.iloc[[True,False,False]])\nprint('\\nAfficher les colonnes 2 et 3 avec un mask :')\nprint(mon_df.iloc[:,[False,True,True]])\nprint('\\nRemplacer les \u00e9l\u00e9ments diagonnaux par 0:')\nv_bool = np.vectorize(bool) # Fonction vectoris\u00e9e pour transformer chaque \u00e9l\u00e9ment en bool\u00e9en (les valeurs nulles\/vides en False et le reste en True)\nmask = v_bool(np.eye(mon_df.shape[0],mon_df.shape[1]))\nmon_df[mask]=0\nprint(mon_df)","da3e002c":"print(\"Ajouter une colonne 'Xnew' :\")\nmon_df['Xnew'] = [100,101,102]\nprint(mon_df)\n\nprint(\"Ajouter une ligne :\")\nmon_df.loc['rowNew'] = [1001,1002,1003,1004]\nprint(mon_df)","70523193":"mon_df","558f0047":"mon_df.values","0bf88b00":"mon_df = pd.DataFrame([[21,3],[45,10],[0,24],[31,12],[7,3],[12,4],[9,5], [22,15],[8,7],[12,9],[10,36],[10,20],[1,3],[40,21]],\n                      columns = ['X1','X2'],\n                      index = ['client_'+str(i\/\/4) for i in range(14)])\nmon_df","a2affc81":"mon_df['X_sum'] = mon_df.apply(np.sum,axis=1)\nprint(\"Cr\u00e9ation d'une colonne X_sum qui soit la somme par ligne :\")\nprint(mon_df)\n\ndef substract_conditional(x): # x est un nombre scalaire entier\n    if not isinstance(x,int) : # Si x n'est pas un entier, on renvoie la valeur -999\n        return(-999)\n    elif x<10 : # Sinon, si x est inf\u00e9rieur \u00e0 10, y = 0\n        y = 0\n    else : # Sinon, y = x\n        y = x\n    return(y)\nprint(\"\\nMettre \u00e0 0 tous les \u00e9l\u00e9ments du DataFrame qui sont inf\u00e9rieurs \u00e0 10 :\")\nprint(mon_df.applymap(substract_conditional))","d215f0fe":"print(\"Combine groupy-apply pour obtenir la variance par client (utilisation de l'index) :\")\nprint(mon_df.groupby(level=0).apply(np.var))\n\nprint(\"\\nCombine groupby-apply pour obtenir le max de deux lignes successives (utilisation d'un mask).\\nOn affiche que la s\u00e9rie X_sum :\")\nprint(mon_df.groupby([i\/\/2 for i in range(14)]).X_sum.apply(np.max))\n\ndef centrer_reduire(x): # Le x en entr\u00e9e est un vecteur\n    y = (x - x.mean()) \/ x.var()\n    return(y) # Le y en sortie est un vecteur\nprint(\"\\nCombine groupby-transform pour centrer-r\u00e9duire les donn\u00e9es (utilisation de l'index) :\")\nprint(mon_df.groupby(level=0).transform(centrer_reduire))\n\nprint(\"\\nTraitements plus complexe dans une boucle :\")\nfor identifiant,valeurs in mon_df.groupby(level=0) :\n    print(identifiant)\n    print(valeurs)\n    print('.. ..'*5)","36f6fada":"mon_df = pd.DataFrame([[21,3],[45,10],[0,24],[31,12],[7,3],[12,4],[9,5], [22,15],[8,7],[12,9],[10,36],[10,20],[1,3],[40,21]],\n                      columns = ['TS1','TS2'])\nmon_df","d7fe358d":"print(\"Moyenne sur fen\u00eatre glissante centr\u00e9e de taille 5 :\")\nprint(mon_df.rolling(5, center=True).apply(np.mean))","93638dd7":"# Les matrices numpy\n\nLes matrices fonctionnent comme des listes de listes de taille fixes.<br>\nChaque liste \u00e9tant une ligne de la matrice.\n\nLes matrices pr\u00e9sentent peu ou prou les m\u00eames avantages que les vecteurs.<br>\nLa plupart des fonctions valables sur les vecteurs le sont aussi sur les matrices. Vous pouvez vous entra\u00eener en cr\u00e9ant votre matrice et en appliquant les m\u00eames fonctions que pour les vecteurs dans le paragraphe pr\u00e9c\u00e9dent.\n\n## Cr\u00e9ation de matrice","ccd85487":"\nUn **'mask'** est un vecteur de boul\u00e9ens utiliser pour le filtrage. Il est appliqu\u00e9 sur le vecteur d'origine (qui doit \u00eatre de m\u00eame taille) et permet de ne garder que les \u00e9l\u00e9ments pour lequel le 'mask' est True :","0215eb9c":"## Appliquer des fonctions en pandas :\n\n`pandas` fonctionne de mani\u00e8re tr\u00e8s similaire \u00e0 `numpy` :  en g\u00e9n\u00e9ral, une fonction qui marche avec `numpy` fonctionne aussi avec `pandas`. La r\u00e9ciproque est fausse : de nombreuses fonctionnalit\u00e9s de `pandas` ne fonctionnent pas avec `numpy`.<br>\nVous pouvez vous en convaincre en testant les diff\u00e9rents fonctions pr\u00e9sent\u00e9es dans les parties pr\u00e9c\u00e9dentes.\n\nQuelques diff\u00e9rences notables :\n- Pour appliquer une fonction par ligne ou par colonne, on utilise la m\u00e9thode `apply`\n- Pour appliquer une fonction \u00e0 tous les \u00e9l\u00e9ments du dataframe, on utilise la m\u00e9thode `applymap`\n- On peut appliquer des fonctions par groupe de lignes (par identifiant client par exemple) via la fonction `groupby`\n    - Si la fonction aggr\u00e8ge les donn\u00e9es en une statistique par identifiant (*e.g.* somme, moyenne ...), on utilisera la combine **groupby - apply**\n    - Si la fonction retourne une donn\u00e9e transform\u00e9e par donn\u00e9e en entr\u00e9e (*e.g.* normalisation par la variance du client), on utilisera la combine **groupby - transform**\n    - On peut appliquer des traitements plus complexes par identifiant au sein d'une boucle (plus lent en temps de calcul)\n- On peut appliquer des fonctions sur des fen\u00eatres glissantes via la fonction `rolling`. Particuli\u00e8rement utile pour les time series\n\nEn v\u00e9rit\u00e9, on peut effectuer le m\u00eame type d'applications avec `numpy`, mais l'usage dans `pandas` est clairement simplifi\u00e9 car on peut utiliser des index nomm\u00e9s, entre autres.\n\n### Appliquer une fonction :","fca47778":"# Numpy et Pandas\n\nNumpy et Pandas sont deux librairies indispensable \u00e0 tout data scientist.\n\nNumpy est une [librairie de calcul num\u00e9rique](https:\/\/docs.scipy.org\/doc\/numpy\/reference\/), tr\u00e8s efficace notamment pour faire des claculs sur des vecteurs et des matrices.\n\nPandas est une [libairie de structure de donn\u00e9es](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/getting_started\/index.html). Elle permet de traiter facilement et efficacement les Series (une seule colonne) et les DataFrame (plusieurs colonnes).\n\nTout d'abord, chargeons les librairies avec leurs diminutifs :","f309f62b":"*vs.* exemple d'output `numpy` :","228180a7":"## Quelques op\u00e9rations simples sur les vecteurs :\n- M\u00e9thodes numpy optimis\u00e9es pour les vecteurs : min, max, sum, cumsum, prod, cumprod, transpose ...\n- Op\u00e9ration avec un nombre scalaire :  +  ,  -  ,  \\*  ,  \/  ,  \\*\\*  ,  %  ,  \/\/\n- Comparaison avec un scalaire\n- Op\u00e9ration entre deux vecteurs\n- Comparaison entre deux vecteurs, \u00e9l\u00e9ment par \u00e9l\u00e9ment\n- Produit vectoriel\n- Appliquer une fonction construite \u00e0 la main, \u00e9l\u00e9ment par \u00e9l\u00e9ment : gain de temps par rapport \u00e0 une boucle classique","aee30af6":"**On peut aussi effectuer des op\u00e9rations par ligne ou par colonne** :\n- Filtrer par ligne ou par colonne : appliquer un 'mask' de la taille des lignes ou des colonnes\n- Op\u00e9ration sur la matrice par ligne ou par colonne: utiliser l'argument `axis=0` pour une op\u00e9ration sur les lignes ou `axis=1` sur les colonnes\n- Appliquer une fonction ligne par ligne ou colonne par colonne : utiliser la fonction `np.apply_along_axis` avec l'argument `axis=0 ou 1`","83dd8bb9":"### Fonctions par groupe :\n\nPour les fonctions par groupes via `groupby` , il faut lui sp\u00e9cifier comment former les groupes :\n- utiliser une ou des colonnes via l'argument `by`\n    - sous forme de cha\u00eene de caract\u00e8res pour appeler par un nom de colonne\n    - sous forme de chiffres pour l'index des colonnes\n- utiliser un ou des indexes via l'argument `level`\n    - sous forme de cha\u00eene de caract\u00e8res pour appeler par un nom d'index\n    - sous forme de chiffres pour le niveau d'index\n- utiliser un 'mask' de m\u00eame longueur que le data frame pour sp\u00e9cifier des groupes.","233ab5a7":"## Cr\u00e9er un vecteur","79e8b21d":"Il est aussi imm\u00e9diat de rajouter des lignes et des colonnes :","048a934e":"Une diff\u00e9rence importante dans pandas est la possibilit\u00e9 d'ajouter des noms de colonnes ou des noms de lignes :","ba9c026b":"Pour acc\u00e9der aux donn\u00e9es d'un data frame, on peut :\n- r\u00e9cup\u00e9rer une s\u00e9rie (colonne unique) avec la m\u00e9thode `.nom_de_colonne`\n- soit acc\u00e9der via les index nomm\u00e9s : utilisation de la fonction `.loc[noms_lignes, noms_colonnes]`\n- soit acc\u00e9der via les index chiffr\u00e9s : utilisation de la fonction `.iloc[ixs_lignes, ixs_colonnes]`\n- y acc\u00e9der sans placer de `.loc` ou `.iloc`, mais cela peut entra\u00eener des ambiguit\u00e9s et des erreurs \u00e0 l'execution. Pr\u00e9f\u00e9rer les solutions au dessus\n- y acc\u00e9der via des mask de la taille des lignes ou des colonnes (selon ce que l'on souhaite filter). L'utilisation conjointe de `.iloc` est recommmand\u00e9e car parfois n\u00e9cessaire.","dbc3f0a8":"Enfin, `pandas` est tr\u00e8s bien int\u00e9gr\u00e9 aux outils classiques pour visualiser les donn\u00e9es (notebooks, inspecteurs de variables, librairies de visualisation graphiques...).\n\nExemple d'output `pandas` :","93815d6d":"Bref, vous l'aurez compris, prendre en main les vecteurs et les matrices pr\u00e9sentent beaucoup de facilit\u00e9s d'usage une fois que les habitudes sont encr\u00e9es.\n\nEn particulier, la s\u00e9lection par index - obligatoire avec `numpy` et qui sera rendue parfois facultative avec `pandas` - offre de grandes libert\u00e9s dans la manipulation des donn\u00e9es.\n\n# Les Series et DataFrame de pandas\n\nOn arrive \u00e0 la librairie pr\u00e9f\u00e9r\u00e9e en python pour la manipulation de donn\u00e9es et en particulier de s\u00e9ries (colonne unique) ou de dataframes !\n\n## Passer de numpy \u00e0 pandas :\n\nOn peut passer tr\u00e8s rapidement de l'un \u00e0 l'autre :","c17b5520":"Quelques sp\u00e9cificit\u00e9s pour les matrices :\n- **Cr\u00e9ation de matrices de 0 ou de 1** : L'argument shape (les dimensions) est un tuple pour les matrices `shape=(nb_lignes,nb_colonnes)` \n- **Cr\u00e9ation d'une matrice \u00e0 partir d'une liste\/d'un vecteur plat** : On peut construire une matrice \u00e0 partir d'une liste de valeurs en sp\u00e9cifiant la dimension de la matrice attendue.\n- **Changer la dimension d'une matrice** : R\u00e9ccrire une matrice en changeant ses dimensions.","3eb79b1a":"# Les vecteurs numpy\n\nLes vecteurs fonctionnent comme des listes de taille fixe.\n\nOn les utilises pour :\n- **effectuer des calculs** : les calculs dits 'vectoriels' sont beaucoup plus efficaces que les boucles par exemple\n- **faire des filtres** : utilisation d'un vecteur de boul\u00e9ens comme un 'mask' de filtrage\n- **se faciliter la vie** : les vecteurs proposent de nombreuses m\u00e9thodes \/ fonctions que n'ont pas les listes","bdb05d01":"## S\u00e9lection d'\u00e9lements dans un vecteur (indexs et 'mask')\n\nIl existe plusieurs moyens de s\u00e9lectionner des \u00e9l\u00e9ments dans un vecteur.\n\nLe plus commun consiste \u00e0 indiquer les indexes des \u00e9l\u00e9ments \u00e0 r\u00e9cup\u00e9rer. Cela fonctionne comme pour les listes :","6b5cb3b5":"## Autres astuces de pandas :\n\nPandas propose de nombreuses fonctions int\u00e9gr\u00e9es mais aussi de nombreux tutoriels. Vous serez int\u00e9ress\u00e9 par les fonctions suivante (\u00e0 explorer par vous-m\u00eame) :\n- `info()` permet d'obtenir des informations sur le dataframe, notamment le type, le nombre de valeur nulles, etc (penser \u00e0 regarder les arguments)\n- `head()` and `tail()` permettent d'afficher uniquement le d\u00e9but et la fin d'un dataframe (par d\u00e9faut 5 lignes). Tr\u00e8s utile pour visualiser rapidement les donn\u00e9es\n- `.shape` permet de conna\u00eetre la dimension de la s\u00e9rie ou du dataframe\n- `pd.merge()` et `pd.concat()` permettent de faire des jointures de diff\u00e9rents dataframes\n- `describe()` sort automatiquement des statistiques descriptives sur le dataframe\n\nIl y a aussi plein de documentation sur des th\u00e8mes plus sp\u00e9cifiques :\n- [Pour revoir des bases pr\u00e9sent\u00e9es ici et aller plus loin, en une dizaine de minutes](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/getting_started\/10min.html)\n- [Pour les bonnes pratiques en pandas](http:\/\/tomaugspurger.github.io\/modern-1-intro.html)\n- [Enchainer proprement les transformations sur un dataframe](http:\/\/tomaugspurger.github.io\/method-chaining.html)\n- [Mieux g\u00e9rer les indexes](http:\/\/tomaugspurger.github.io\/modern-3-indexes.html)\n- [Optimiser les performances](http:\/\/tomaugspurger.github.io\/modern-4-performance.html)\n- [Les donn\u00e9es tidy](http:\/\/tomaugspurger.github.io\/modern-5-tidy.html)\n- [Visualisation et exploration avec pandas](http:\/\/tomaugspurger.github.io\/modern-6-visualization.html)\n- [G\u00e9rer les time series](http:\/\/tomaugspurger.github.io\/modern-7-timeseries.html)\n\n**A bient\u00f4t pour un nouveau tutoriel !**","25b3c278":"### Fonctions glissantes :\n\nL'utilisation de `rolling` permet d'appliquer une fonction d'aggr\u00e9gation (somme, moyenne, variance ...) sur une fen\u00eatre de valeurs avant de passer \u00e0 la suivante.\n\nCette fonction est particuli\u00e8rement utilse en time series, pour calculer les moving average par exemple !\n\nElle pr\u00e9sente la m\u00eame structure que la combine `groupby-apply` : `rolling-apply`","7ce63cdd":"## Op\u00e9rations sur les matrices :\n\nLes op\u00e9rations pr\u00e9sent\u00e9es pour les vecteurs sont valables pour les matrices :"}}