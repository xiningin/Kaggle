{"cell_type":{"4ffef60a":"code","45939a70":"code","e06448fd":"code","354a97e7":"code","84cf4437":"code","24ccba4f":"code","217afbd1":"code","ebc8ff65":"code","0b96e013":"code","2c6d9573":"code","d9c46bd9":"code","909795cf":"code","1a5ae9c0":"markdown","eb8eb0f9":"markdown"},"source":{"4ffef60a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nnp.random.seed(666)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","45939a70":"data = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/family_data.csv')\ndata","e06448fd":"matrix = data[['choice_0', 'choice_1', 'choice_2', 'choice_3', 'choice_4',\n       'choice_5', 'choice_6', 'choice_7', 'choice_8', 'choice_9']].to_numpy()","354a97e7":"submission = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/sample_submission.csv')\nsubmission","84cf4437":"best = pd.read_csv(\"..\/input\/local1\/sub1.csv\")\nbest = best['assigned_day'].to_list()","24ccba4f":"chromosome = [0 for i in range(500000)]\nfor i in range(5000):\n    chromosome[i*100+best[i]-1] = 1\n    \npopulation = []\npopulation.append(chromosome)","217afbd1":"#https:\/\/www.kaggle.com\/xhlulu\/santa-s-2019-4x-faster-cost-function\nfamily_size_dict = data[['n_people']].to_dict()['n_people']\n\ncols = [f'choice_{i}' for i in range(10)]\nchoice_dict = data[cols].T.to_dict()\n\nN_DAYS = 100\nMAX_OCCUPANCY = 300\nMIN_OCCUPANCY = 125\n\n# from 100 to 1\ndays = list(range(N_DAYS,0,-1))\n\nfamily_size_ls = list(family_size_dict.values())\nchoice_dict_num = [{vv:i for i, vv in enumerate(di.values())} for di in choice_dict.values()]\n\n# Computer penalities in a list\npenalties_dict = {\n    n: [\n        0,\n        50,\n        50 + 9 * n,\n        100 + 9 * n,\n        200 + 9 * n,\n        200 + 18 * n,\n        300 + 18 * n,\n        300 + 36 * n,\n        400 + 36 * n,\n        500 + 36 * n + 199 * n,\n        500 + 36 * n + 398 * n\n    ]\n    for n in range(max(family_size_dict.values())+1)\n} \n\ndef cost_function(prediction):\n    penalty = 0\n\n    # We'll use this to count the number of people scheduled each day\n    daily_occupancy = {k:0 for k in days}\n    \n    # Looping over each family; d is the day, n is size of that family, \n    # and choice is their top choices\n    for n, d, choice in zip(family_size_ls, prediction, choice_dict_num):\n        # add the family member count to the daily occupancy\n        daily_occupancy[d] += n\n\n        # Calculate the penalty for not getting top preference\n        if d not in choice:\n            penalty += penalties_dict[n][-1]\n        else:\n            penalty += penalties_dict[n][choice[d]]\n\n    # for each date, check total occupancy\n    #  (using soft constraints instead of hard constraints)\n    for v in daily_occupancy.values():\n        if (v > MAX_OCCUPANCY) or (v < MIN_OCCUPANCY):\n            penalty += 100000000\n\n    # Calculate the accounting cost\n    # The first day (day 100) is treated special\n    accounting_cost = (daily_occupancy[days[0]]-125.0) \/ 400.0 * daily_occupancy[days[0]]**(0.5)\n    # using the max function because the soft constraints might allow occupancy to dip below 125\n    accounting_cost = max(0, accounting_cost)\n    \n    # Loop over the rest of the days, keeping track of previous count\n    yesterday_count = daily_occupancy[days[0]]\n    for day in days[1:]:\n        today_count = daily_occupancy[day]\n        diff = abs(today_count - yesterday_count)\n        accounting_cost += max(0, (daily_occupancy[day]-125.0) \/ 400.0 * daily_occupancy[day]**(0.5 + diff \/ 50.0))\n        yesterday_count = today_count\n\n    penalty += accounting_cost\n\n    return penalty","ebc8ff65":"def convert(chromosome):\n    indexes = []\n    for i in range(0,500000):\n        if chromosome[i] == 1:\n            indexes.append((i+1)-(i\/\/100)*100)\n    return indexes\n\ndef selection(population, selection_size, group_size):\n\n    parents = []\n    for i in range(selection_size):\n        minimum = 9999999999999999999\n        index = -1\n        for t in range(group_size):\n            chromosome =  np.random.randint(len(population))\n            for_test = convert(population[chromosome])\n            if cost_function(for_test) < minimum:\n                minimum = cost_function(for_test)\n                index = chromosome\n        parents.append(population[index])\n                \n    return parents\n        \ndef crossover(p1, p2):\n    p = [p1[i] for i in range(50000)]\n    for i in range(50000, 100000):\n        p.append(p2[i])\n    for i in range(100000, 150000):\n        p.append(p1[i])\n    for i in range(150000, 200000):\n        p.append(p2[i])\n    for i in range(200000, 250000):\n        p.append(p1[i])\n    for i in range(250000, 300000):\n        p.append(p2[i])\n    for i in range(300000, 350000):\n        p.append(p1[i])\n    for i in range(350000, 400000):\n        p.append(p2[i])\n    for i in range(400000, 450000):\n        p.append(p1[i])\n    for i in range(450000, 500000):\n        p.append(p2[i])\n    return p\n\ndef mutation(family_matrix, chromosome, desired_rate=10):\n    family_number = np.random.randint(5000)\n    desired_probability = np.random.randint(100)\n    if desired_probability < desired_rate:\n        new_day = np.random.randint(100)\n    else:\n        ind = np.random.randint(10)\n        new_day = family_matrix[family_number][ind] - 1\n    for i in range(family_number*100, family_number*100+100):\n        chromosome[i] = 0\n    chromosome[family_number*100+new_day] = 1\n    \n    return chromosome\n\ndef reproduction(family_matrix, population, new_generation_size, mutation_rate, number_of_mutations):\n    new_generation = []\n    for i in range(new_generation_size):\n        p1_index = np.random.randint(len(population))\n        p2_index = np.random.randint(len(population))\n        p = crossover(population[p1_index], population[p2_index])\n        mutation_probability = np.random.randint(100)\n        if mutation_probability >= mutation_rate:\n            mutations_number = np.random.randint(number_of_mutations)\n            for m in range(mutations_number):\n                p = mutation(family_matrix, p, 10)\n            \n        new_generation.append(p)\n    return new_generation","0b96e013":"def epoch_optimal(population):\n    \n    minimum = 9999999999999999999999999999\n    chromosome=-1\n    for i in population:\n        test = convert(i)\n        if cost_function(test)<minimum:\n            chromosome = i\n            minimum = cost_function(test)\n            \n    return chromosome, minimum","2c6d9573":"population = reproduction(matrix, population, 50, 0.25, 50)","d9c46bd9":"best = -1\nbest_val = 105163.8446075958\nfor i in range(20):\n    print(i)\n    population = selection(population, 25, 5)\n    population = reproduction(matrix, population, 50, 0.25, 10)\n    ind, val = epoch_optimal(population)\n    print('Min on epoch: ', str(val))\n    if best_val > val:\n        best_val = val\n        best = ind","909795cf":"sub = convert(best)\nsubmission['assigned_day'] = sub\nsubmission.to_csv('submission.csv', index=False)\nsubmission","1a5ae9c0":"Here is simple implementation of Genetic Algorithm. It is based on current best public solution https:\/\/www.kaggle.com\/jazivxt\/using-a-baseline.\n\nInitial population generates from only one solution (that is not good, but enought for this example).","eb8eb0f9":"Represent a chromosome as binary vector of length 500000 (5000 families, 100 days)."}}