{"cell_type":{"0ac167f2":"code","5e8af203":"code","f773a34f":"code","33211f40":"code","730b6f5f":"code","02e31705":"code","78d23926":"code","12baf5ac":"code","64da2c66":"code","851e7716":"code","3ff95972":"code","00aa0e29":"code","610a3e18":"code","d6514723":"code","1c0d911a":"code","557eb75b":"code","68266cac":"code","42480beb":"code","0c838a6a":"code","68c8d72a":"code","1c1652f6":"code","0fb2ba4b":"code","5a9b190c":"code","deb069a2":"code","b8060cc9":"code","da498cbb":"code","13ddf102":"code","b1dc6eaf":"code","17633a36":"code","30908cfe":"code","499c6b8f":"code","f49fa891":"code","4ba54b8b":"code","99cd7f47":"code","c92e020e":"code","29f28142":"code","9d56f788":"code","79316e4b":"code","79001521":"code","5120bb0e":"code","1aa5bbb3":"code","0acb20b7":"code","f81d2957":"code","2a31c099":"code","ecad113c":"code","dfd6a470":"code","6e6e073e":"code","dcd5745d":"code","ebd9b91b":"code","0f151f06":"code","050dc5e5":"code","d4e0e153":"code","0980c56b":"code","efb3abf2":"code","9e313fed":"code","e2dc90b4":"code","e97e4e7f":"code","80f6282e":"code","057d2e37":"code","3bffef1f":"code","db834d52":"code","3d522ec6":"code","e6ed8137":"code","1e1547f1":"code","ae4f82b0":"code","aa2756ba":"code","de92f58f":"code","cee0ac02":"code","1d4acf7c":"code","d91156ea":"code","164310ec":"code","df9dc3cc":"code","3eee4be4":"code","84edcf59":"code","fd7c1320":"code","e0b825d6":"code","e10f9773":"code","e59ecfe1":"code","9cf6db13":"code","b649d3e1":"code","b8fdfcf2":"code","d00843fb":"code","36178c44":"code","9cb86d9b":"markdown","fc815a75":"markdown","e0730de4":"markdown","bc1b9c62":"markdown","deebe421":"markdown","9d0689f0":"markdown","951a2ce8":"markdown","e89f95e0":"markdown","4304a443":"markdown","c8c74138":"markdown","134e1ed6":"markdown","7767cba4":"markdown","10361ff3":"markdown","97960713":"markdown","01d64911":"markdown","526ba691":"markdown","831304be":"markdown","2ce0a76e":"markdown","6949f894":"markdown","55d957cc":"markdown","3d988d31":"markdown","2faca95b":"markdown","b78991ed":"markdown","3104ad98":"markdown","848b52db":"markdown","c928905a":"markdown","9cf2ae6f":"markdown","c470ac83":"markdown","8e20959d":"markdown","6d605c27":"markdown","31d56035":"markdown","077b53c5":"markdown","adec125d":"markdown","92e4aa9b":"markdown","4fdafcd8":"markdown","4fee5efe":"markdown","ac04cefb":"markdown","9bc497be":"markdown","587d85e3":"markdown","6b465f7c":"markdown","b22aaf76":"markdown","0d83b814":"markdown","7e80273b":"markdown","fad0def7":"markdown","6ccce924":"markdown","564efb0e":"markdown","6ba2ac49":"markdown"},"source":{"0ac167f2":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport itertools\nimport gc\nimport os\nimport sys\n\nsns.set_style('darkgrid')\nsns.set_palette('bone')\n\n#pd.options.display.float_format = '{:.5g}'.format\npd.options.display.float_format = '{:,.3f}'.format\n\nprint(os.listdir(\"..\/input\"))","5e8af203":"def toTapleList(list1,list2):\n    return list(itertools.product(list1,list2))","f773a34f":"# Memory saving function credit to https:\/\/www.kaggle.com\/gemartin\/load-data-reduce-memory-usage\ndef reduce_mem_usage(df):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.\n    \"\"\"\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    \n    for col in df.columns:\n        col_type = df[col].dtype\n        \n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                #if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                #    df[col] = df[col].astype(np.float16)\n                #el\n                if c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        #else:\n            #df[col] = df[col].astype('category')\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage of dataframe is {:.2f} MB --> {:.2f} MB (Decreased by {:.1f}%)'.format(\n        start_mem, end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df","33211f40":"%%time\ntrain = pd.read_csv('..\/input\/train_V2.csv')\ntrain = reduce_mem_usage(train)\ntest = pd.read_csv('..\/input\/test_V2.csv')\ntest = reduce_mem_usage(test)\nprint(train.shape, test.shape)","730b6f5f":"train.info()","02e31705":"null_cnt = train.isnull().sum().sort_values()\nprint('null count:', null_cnt[null_cnt > 0])\n# dropna\ntrain.dropna(inplace=True)","78d23926":"train.describe(include=np.number).drop('count').T","12baf5ac":"for c in ['Id','groupId','matchId']:\n    print(f'unique [{c}] count:', train[c].nunique())","64da2c66":"fig, ax = plt.subplots(1, 2, figsize=(12, 4))\n\ntrain.groupby('matchId')['matchType'].first().value_counts().plot.bar(ax=ax[0])\n\n'''\nsolo  <-- solo,solo-fpp,normal-solo,normal-solo-fpp\nduo   <-- duo,duo-fpp,normal-duo,normal-duo-fpp,crashfpp,crashtpp\nsquad <-- squad,squad-fpp,normal-squad,normal-squad-fpp,flarefpp,flaretpp\n'''\nmapper = lambda x: 'solo' if ('solo' in x) else 'duo' if ('duo' in x) or ('crash' in x) else 'squad'\ntrain['matchType'] = train['matchType'].apply(mapper)\ntrain.groupby('matchId')['matchType'].first().value_counts().plot.bar(ax=ax[1])","851e7716":"for q in ['numGroups == maxPlace','numGroups != maxPlace']:\n    print(q, ':', len(train.query(q)))","3ff95972":"# describe\ncols = ['numGroups','maxPlace']\ndesc1 = train.groupby('matchType')[cols].describe()[toTapleList(cols,['min','mean','max'])]\n# groups in match\ngroup = train.groupby(['matchType','matchId','groupId']).count().groupby(['matchType','matchId']).size().to_frame('groups in match')\ndesc2 = group.groupby('matchType').describe()[toTapleList(['groups in match'],['min','mean','max'])]\n\npd.concat([desc1, desc2], axis=1)","00aa0e29":"match = train.groupby(['matchType','matchId']).size().to_frame('players in match')\ngroup = train.groupby(['matchType','matchId','groupId']).size().to_frame('players in group')\npd.concat([match.groupby('matchType').describe()[toTapleList(['players in match'],['min','mean','max'])], \n           group.groupby('matchType').describe()[toTapleList(['players in group'],['min','mean','max'])]], axis=1)","610a3e18":"print(group['players in group'].nlargest(5))\ndel match,group","d6514723":"''' ex) matchId=='41a634f62f86b7', groupId=='128b07271aa012'\n'''\nsubset = train[train['matchId']=='41a634f62f86b7']\nsub_grp = subset[subset['groupId']=='128b07271aa012']\n\nprint('matchId==\\'41a634f62f86b7\\' & groupId==\\'128b07271aa012\\'')\nprint('-'*50)\nprint('players:',len(subset))\nprint('groups:',subset['groupId'].nunique())\nprint('numGroups:',subset['numGroups'].unique())\nprint('maxPlace:',subset['maxPlace'].unique())\nprint('-'*50)\nprint('max-group players:',len(sub_grp))\nprint('max-group winPlacePerc:',sub_grp['winPlacePerc'].unique())\nprint('-'*50)\nprint('winPlacePerc:',subset['winPlacePerc'].sort_values().unique())","1c0d911a":"group = train.groupby(['matchId','groupId','matchType'])['Id'].count().to_frame('players').reset_index()\ngroup.loc[group['players'] > 4, 'players'] = '5+'\ngroup['players'] = group['players'].astype(str)\n\nfig, ax = plt.subplots(1, 3, figsize=(16, 4))\nfor mt, ax in zip(['solo','duo','squad'], ax.ravel()):\n    ax.set_xlabel(mt)\n    group[group['matchType'] == mt]['players'].value_counts().sort_index().plot.bar(ax=ax)","557eb75b":"fig, ax = plt.subplots(1, 2, figsize=(12, 4))\n# there are two types of maps?\ntrain['matchDuration'].hist(bins=50, ax=ax[0])\ntrain.query('matchDuration >= 1400 & matchDuration <= 1800')['matchDuration'].hist(bins=50, ax=ax[1])","68266cac":"train[train['matchDuration'] == train['matchDuration'].min()].head()","42480beb":"train[train['matchDuration'] == train['matchDuration'].max()].head()","0c838a6a":"(train.groupby('matchId')['matchDuration'].nunique() > 1).any()","68c8d72a":"fig, ax = plt.subplots(2, 2, figsize=(16, 8))\n\ncols = ['boosts','heals']\nfor col, ax in zip(cols, ax):\n    sub = train[['winPlacePerc',col]].copy()\n    mv = (sub[col].max() \/\/ 5) + 1\n    sub[col] = pd.cut(sub[col], [5*x for x in range(0,mv)], right=False)\n    sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])\n    train[col].hist(bins=20, ax=ax[1])","1c1652f6":"print('solo player has revives:', 'solo' in train.query('revives > 0')['matchType'].unique())","0fb2ba4b":"fig, ax = plt.subplots(1, 2, figsize=(16, 4))\ncol = 'revives'\nsub = train.loc[~train['matchType'].str.contains('solo'),['winPlacePerc',col]].copy()\nsub[col] = pd.cut(sub[col], [5*x for x in range(0,8)], right=False)\nsub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])\ntrain[col].hist(bins=20, ax=ax[1])","5a9b190c":"train.groupby(['matchType'])['killPlace'].describe()[['min','mean','max']]","deb069a2":"plt.figure(figsize=(8,4))\ncol = 'killPlace'\nsub = train[['winPlacePerc',col]].copy()\nsub[col] = pd.cut(sub[col], [10*x for x in range(0,11)], right=False)\nsub.groupby(col).mean()['winPlacePerc'].plot.bar()","b8060cc9":"''' important \n'''\nsubMatch = train[train['matchId'] == train['matchId'].min()].sort_values(['winPlacePerc','killPlace'])\ncols = ['groupId','kills','winPlacePerc','killPlace']\nsubMatch[cols]","da498cbb":"fig, ax = plt.subplots(1, 2, figsize=(16, 4))\n\ncol = 'kills'\nsub = train[['winPlacePerc',col]].copy()\nsub[col] = pd.cut(sub[col], [5*x for x in range(0,20)], right=False)\nsub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])\ntrain[train['kills'] < 20][col].hist(bins=20, ax=ax[1])","13ddf102":"sub = train['matchType'].str.contains('solo')\npd.concat([train.loc[sub].groupby('matchId')['kills'].sum().describe(),\n         train.loc[~sub].groupby('matchId')['kills'].sum().describe()], keys=['solo','team'], axis=1).T","b1dc6eaf":"fig, ax = plt.subplots(2, 2, figsize=(16, 8))\n\ncols = ['killStreaks','DBNOs']\nfor col, ax in zip(cols, ax):\n    sub = train[['winPlacePerc',col]].copy()\n    sub[col] = pd.cut(sub[col], 6)\n    sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])\n    train[col].hist(bins=20, ax=ax[1])","17633a36":"fig, ax = plt.subplots(3, 2, figsize=(16, 12))\n\ncols = ['headshotKills','roadKills','teamKills']\nfor col, ax in zip(cols, ax):\n    sub = train[['winPlacePerc',col]].copy()\n    sub.loc[sub[col] >= 5, col] = '5+'  \n    sub[col] = sub[col].astype(str)\n    sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])\n    train[col].hist(bins=20, ax=ax[1])","30908cfe":"fig, ax = plt.subplots(1, 2, figsize=(16, 4))\n\ncol = 'assists'\nsub = train[['winPlacePerc',col]].copy()\nsub.loc[sub[col] >= 5, col] = '5+'  \nsub[col] = sub[col].astype(str)\nsub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])\ntrain[col].hist(bins=20, ax=ax[1])","499c6b8f":"pd.concat([train[train['matchType'] == 'solo'].describe()['assists'],\n           train[train['matchType'] != 'solo'].describe()['assists']],\n          keys=['solo','team'], axis=1).T","f49fa891":"fig, ax = plt.subplots(1, 2, figsize=(16, 4))\n\ncol = 'longestKill'\nsub = train[['winPlacePerc',col]].copy()\nsub[col] = pd.cut(sub[col], 6)\nsub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])\ntrain[col].hist(bins=20, ax=ax[1])","4ba54b8b":"fig, ax = plt.subplots(1, 2, figsize=(16, 4))\n\ncol = 'damageDealt'\nsub = train[['winPlacePerc',col]].copy()\nsub[col] = pd.cut(sub[col], 6)\nsub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])\ntrain[col].hist(bins=20, ax=ax[1])","99cd7f47":"train.query('damageDealt == 0 & (kills > 0 | DBNOs > 0)')[\n    ['damageDealt','kills','DBNOs','headshotKills','roadKills','teamKills']].head(20)","c92e020e":"fig, ax = plt.subplots(3, 2, figsize=(16, 12))\n\ncols = ['walkDistance', 'rideDistance', 'swimDistance']\nfor col, ax in zip(cols, ax):\n    sub = train[['winPlacePerc',col]].copy()\n    sub[col] = pd.cut(sub[col], 6)\n    sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])\n    train[col].hist(bins=20, ax=ax[1])","29f28142":"sub = train[['walkDistance','rideDistance','swimDistance','winPlacePerc']].copy()\nwalk = train['walkDistance']\nsub['walkDistanceBin'] = pd.cut(walk, [0, 0.001, walk.quantile(.25), walk.quantile(.5), walk.quantile(.75), 99999])\nsub['rideDistanceBin'] = (train['rideDistance'] > 0).astype(int)\nsub['swimDistanceBin'] = (train['swimDistance'] > 0).astype(int)\n\nfig, ax = plt.subplots(1, 3, figsize=(16, 3), sharey=True)\nsub.groupby('walkDistanceBin').mean()['winPlacePerc'].plot.bar(ax=ax[0])\nsub.groupby('rideDistanceBin').mean()['winPlacePerc'].plot.bar(ax=ax[1])\nsub.groupby('swimDistanceBin').mean()['winPlacePerc'].plot.bar(ax=ax[2])\ndel sub, walk","9d56f788":"# zombie\nsub = train.query('walkDistance == 0 & kills == 0 & weaponsAcquired == 0 & \\'solo\\' in matchType')\nprint('count:', len(sub), ' winPlacePerc:', round(sub['winPlacePerc'].mean(),3))","79316e4b":"sq = 'kills > 3 & (headshotKills \/ kills) >= 0.8'\nsub = train.query(sq)\nprint(sq, '\\n count:', len(sub), ' winPlacePerc:', round(sub['winPlacePerc'].mean(),3))","79001521":"fig, ax = plt.subplots(1, 3, figsize=(16, 4), sharey=True)\n\ncols = ['killPoints','rankPoints','winPoints']\nfor col, ax in zip(cols, ax.ravel()): \n    train.plot.scatter(x=col, y='winPlacePerc', ax=ax)","5120bb0e":"# rankPoint: being deprecated\n# killPoints,winPoints: If there is a value other than -1 in rankPoints, then any 0 should be treated as a \u201cNone\u201d.\nsign = lambda x: 'p<=0' if x <= 0 else 'p>0'\npd.concat([\n    pd.crosstab(train['rankPoints'].apply(sign), train['winPoints'].apply(sign), margins=False),\n    pd.crosstab(train['rankPoints'].apply(sign), train['killPoints'].apply(sign), margins=False)\n], keys=['winPoints','killPoints'], axis=1)","1aa5bbb3":"train['winPlacePerc'].describe()","0acb20b7":"# confirm unique winPlace in group\n#nuniquePlace = train.groupby(['matchId','groupId'])['winPlacePerc'].nunique()\n#print('not unique winPlace in group:', len(nuniquePlace[nuniquePlace > 1]))\n#del nuniquePlace","f81d2957":"print('match count:', train['matchId'].nunique())\n\n# not contains 1st place\nmaxPlacePerc = train.groupby('matchId')['winPlacePerc'].max()\nprint('match [not contains 1st place]:', len(maxPlacePerc[maxPlacePerc != 1]))\ndel maxPlacePerc\n\n# edge case\nsub = train[(train['maxPlace'] > 1) & (train['numGroups'] == 1)]\nprint('match [maxPlace>1 & numGroups==1]:', len(sub.groupby('matchId')))\nprint(' - unique winPlacePerc:', sub['winPlacePerc'].unique())","2a31c099":"pd.concat([train[train['winPlacePerc'] == 1].head(5),\n           train[train['winPlacePerc'] == 0].head(5)],\n          keys=['winPlacePerc_1', 'winPlacePerc_0'])","ecad113c":"cols = ['kills','teamKills','DBNOs','revives','assists','boosts','heals','damageDealt',\n    'walkDistance','rideDistance','swimDistance','weaponsAcquired']\n\naggs = ['count','min','mean','max']\n# summary of solo-match\ngrp = train.loc[train['matchType'].str.contains('solo')].groupby('matchId')\ngrpSolo = grp[cols].sum()\n# summary of team-match\ngrp = train.loc[~train['matchType'].str.contains('solo')].groupby('matchId')\ngrpTeam = grp[cols].sum()\n\npd.concat([grpSolo.describe().T[aggs], grpTeam.describe().T[aggs]], keys=['solo', 'team'], axis=1)","dfd6a470":"grpSolo.nlargest(5, 'kills')","6e6e073e":"grpTeam.nlargest(5, 'kills')","dcd5745d":"del grpSolo, grpTeam","ebd9b91b":"cols = ['kills','teamKills','DBNOs','revives','assists','boosts','heals','damageDealt',\n    'walkDistance','rideDistance','swimDistance','weaponsAcquired']\ncols.extend(['killPlace','winPlacePerc'])\ngroup = train.groupby(['matchId','groupId'])[cols]\n\nfig, ax = plt.subplots(3, 1, figsize=(12, 18), sharey=True)\nfor df, ax in zip([group.mean(), group.min(), group.max()], ax.ravel()):\n    sns.heatmap(df.corr(), annot=True, linewidths=.6, fmt='.2f', vmax=1, vmin=-1, center=0, cmap='Blues', ax=ax)\n\ndel df","0f151f06":"def printMatchStats(matchIds):\n    for mid in matchIds:\n        subMatch = train[train['matchId'] == mid]\n        print('matchType:', subMatch['matchType'].values[0])\n\n        grp1st = subMatch[subMatch['winPlacePerc'] == 1]\n        grpOther = subMatch[subMatch['winPlacePerc'] != 1]\n        print('players'.ljust(10), ' total:{:>3}  1st:{:>3}  other:{:>3}'.format(len(subMatch), len(grp1st), len(grpOther)))\n        for c in ['kills','teamKills','roadKills','DBNOs','revives','assists']:\n            print(c.ljust(10), ' total:{:>3}  1st:{:>3}  other:{:>3}'.format(subMatch[c].sum(), grp1st[c].sum(), grpOther[c].sum()))\n        print('-' * 30)","050dc5e5":"sampleMid = train['matchId'].unique()[0:5]\nprintMatchStats(sampleMid)","d4e0e153":"match = train.groupby(['matchId'])['Id'].count()\nfullplayer = match[match == 100].reset_index()\nsampleMid = fullplayer['matchId'][0:5]\nprintMatchStats(sampleMid)","0980c56b":"#print(pd.DataFrame([[val for val in dir()], [sys.getsizeof(eval(val)) for val in dir()]],\n#                   index=['name','size']).T.sort_values('size', ascending=False).reset_index(drop=True)[:10])","efb3abf2":"all_data = train.append(test, sort=False).reset_index(drop=True)\ndel train, test\ngc.collect()","9e313fed":"match = all_data.groupby('matchId')\nall_data['killsPerc'] = match['kills'].rank(pct=True).values\nall_data['killPlacePerc'] = match['killPlace'].rank(pct=True).values\nall_data['walkDistancePerc'] = match['walkDistance'].rank(pct=True).values\n#all_data['damageDealtPerc'] = match['damageDealt'].rank(pct=True).values\nall_data['walkPerc_killsPerc'] = all_data['walkDistancePerc'] \/ all_data['killsPerc']","e2dc90b4":"all_data['_totalDistance'] = all_data['rideDistance'] + all_data['walkDistance'] + all_data['swimDistance']\n#all_data['_rideBin'] = (all_data['rideDistance'] > 0).astype(int)\n#all_data['_swimBin'] = (all_data['swimDistance'] > 0).astype(int)","e97e4e7f":"def fillInf(df, val):\n    numcols = df.select_dtypes(include='number').columns\n    cols = numcols[numcols != 'winPlacePerc']\n    df[df == np.Inf] = np.NaN\n    df[df == np.NINF] = np.NaN\n    for c in cols: df[c].fillna(val, inplace=True)","80f6282e":"all_data['_healthItems'] = all_data['heals'] + all_data['boosts']\nall_data['_headshotKillRate'] = all_data['headshotKills'] \/ all_data['kills']\nall_data['_killPlaceOverMaxPlace'] = all_data['killPlace'] \/ all_data['maxPlace']\nall_data['_killsOverWalkDistance'] = all_data['kills'] \/ all_data['walkDistance']\n#all_data['_killsOverDistance'] = all_data['kills'] \/ all_data['_totalDistance']\n#all_data['_walkDistancePerSec'] = all_data['walkDistance'] \/ all_data['matchDuration']\n\nfillInf(all_data, 0)","057d2e37":"all_data.drop(['boosts','heals','killStreaks','DBNOs'], axis=1, inplace=True)\nall_data.drop(['headshotKills','roadKills','vehicleDestroys'], axis=1, inplace=True)\nall_data.drop(['rideDistance','swimDistance','matchDuration'], axis=1, inplace=True)\nall_data.drop(['rankPoints','killPoints','winPoints'], axis=1, inplace=True)","3bffef1f":"match = all_data.groupby(['matchId'])\ngroup = all_data.groupby(['matchId','groupId','matchType'])\n\n# target feature (max, min)\nagg_col = list(all_data.columns)\nexclude_agg_col = ['Id','matchId','groupId','matchType','maxPlace','numGroups','winPlacePerc']\nfor c in exclude_agg_col:\n    agg_col.remove(c)\nprint(agg_col)\n\n# target feature (sum)\nsum_col = ['kills','killPlace','damageDealt','walkDistance','_healthItems']","db834d52":"''' match sum, match max, match mean, group sum\n'''\nmatch_data = pd.concat([\n    match.size().to_frame('m.players'), \n    match[sum_col].sum().rename(columns=lambda s: 'm.sum.' + s), \n    match[sum_col].max().rename(columns=lambda s: 'm.max.' + s),\n    match[sum_col].mean().rename(columns=lambda s: 'm.mean.' + s)\n    ], axis=1).reset_index()\nmatch_data = pd.merge(match_data, \n    group[sum_col].sum().rename(columns=lambda s: 'sum.' + s).reset_index())\nmatch_data = reduce_mem_usage(match_data)\n\nprint(match_data.shape)","3d522ec6":"''' ranking of kills and killPlace in each match\n'''\nminKills = all_data.sort_values(['matchId','groupId','kills','killPlace']).groupby(\n    ['matchId','groupId','kills']).first().reset_index().copy()\nfor n in np.arange(4):\n    c = 'kills_' + str(n) + '_Place'\n    nKills = (minKills['kills'] == n)\n    minKills.loc[nKills, c] = minKills[nKills].groupby(['matchId'])['killPlace'].rank().values\n    match_data = pd.merge(match_data, minKills[nKills][['matchId','groupId',c]], how='left')\n    #match_data[c].fillna(0, inplace=True)\nmatch_data = reduce_mem_usage(match_data)\ndel minKills, nKills\n\nprint(match_data.shape)","e6ed8137":"match_data.head()","1e1547f1":"''' group mean, max, min\n'''\nall_data = pd.concat([\n    group.size().to_frame('players'),\n    group.mean(),\n    group[agg_col].max().rename(columns=lambda s: 'max.' + s),\n    group[agg_col].min().rename(columns=lambda s: 'min.' + s),\n    ], axis=1).reset_index()\nall_data = reduce_mem_usage(all_data)\n\nprint(all_data.shape)","ae4f82b0":"# suicide: solo and teamKills > 0\n#all_data['_suicide'] = ((all_data['players'] == 1) & (all_data['teamKills'] > 0)).astype(int)","aa2756ba":"numcols = all_data.select_dtypes(include='number').columns.values\nnumcols = numcols[numcols != 'winPlacePerc']","de92f58f":"''' match summary, max\n'''\nall_data = pd.merge(all_data, match_data)\ndel match_data\ngc.collect()\n\nall_data['enemy.players'] = all_data['m.players'] - all_data['players']\nfor c in sum_col:\n    #all_data['enemy.' + c] = (all_data['m.sum.' + c] - all_data['sum.' + c]) \/ all_data['enemy.players']\n    #all_data['p.sum_msum.' + c] = all_data['sum.' + c] \/ all_data['m.sum.' + c]\n    #all_data['p.max_mmean.' + c] = all_data['max.' + c] \/ all_data['m.mean.' + c]\n    all_data['p.max_msum.' + c] = all_data['max.' + c] \/ all_data['m.sum.' + c]\n    all_data['p.max_mmax.' + c] = all_data['max.' + c] \/ all_data['m.max.' + c]\n    all_data.drop(['m.sum.' + c, 'm.max.' + c], axis=1, inplace=True)\n    \nfillInf(all_data, 0)\nprint(all_data.shape)","cee0ac02":"''' match rank\n'''\nmatch = all_data.groupby('matchId')\nmatchRank = match[numcols].rank(pct=True).rename(columns=lambda s: 'rank.' + s)\nall_data = reduce_mem_usage(pd.concat([all_data, matchRank], axis=1))\nrank_col = matchRank.columns\ndel matchRank\ngc.collect()\n\n# instead of rank(pct=True, method='dense')\nmatch = all_data.groupby('matchId')\nmatchRank = match[rank_col].max().rename(columns=lambda s: 'max.' + s).reset_index()\nall_data = pd.merge(all_data, matchRank)\nfor c in numcols:\n    all_data['rank.' + c] = all_data['rank.' + c] \/ all_data['max.rank.' + c]\n    all_data.drop(['max.rank.' + c], axis=1, inplace=True)\ndel matchRank\ngc.collect()\n\nprint(all_data.shape)","1d4acf7c":"''' TODO: incomplete\n''' \nkillMinorRank = all_data[['matchId','min.kills','max.killPlace']].copy()\ngroup = killMinorRank.groupby(['matchId','min.kills'])\nkillMinorRank['rank.minor.maxKillPlace'] = group.rank(pct=True).values\nall_data = pd.merge(all_data, killMinorRank)\n\nkillMinorRank = all_data[['matchId','max.kills','min.killPlace']].copy()\ngroup = killMinorRank.groupby(['matchId','max.kills'])\nkillMinorRank['rank.minor.minKillPlace'] = group.rank(pct=True).values\nall_data = pd.merge(all_data, killMinorRank)\n\ndel killMinorRank\ngc.collect()","d91156ea":"# drop constant column\nconstant_column = [col for col in all_data.columns if all_data[col].nunique() == 1]\nprint('drop columns:', constant_column)\nall_data.drop(constant_column, axis=1, inplace=True)","164310ec":"'''\nsolo  <-- solo,solo-fpp,normal-solo,normal-solo-fpp\nduo   <-- duo,duo-fpp,normal-duo,normal-duo-fpp,crashfpp,crashtpp\nsquad <-- squad,squad-fpp,normal-squad,normal-squad-fpp,flarefpp,flaretpp\n'''\nall_data['matchType'] = all_data['matchType'].apply(mapper)\n\nall_data = pd.concat([all_data, pd.get_dummies(all_data['matchType'])], axis=1)\nall_data.drop(['matchType'], axis=1, inplace=True)\n\nall_data['matchId'] = all_data['matchId'].apply(lambda x: int(x,16))\nall_data['groupId'] = all_data['groupId'].apply(lambda x: int(x,16))","df9dc3cc":"null_cnt = all_data.isnull().sum().sort_values()\nprint(null_cnt[null_cnt > 0])","3eee4be4":"#all_data.drop([],axis=1,inplace=True)\n\ncols = [col for col in all_data.columns if col not in ['Id','matchId','groupId']]\nfor i, t in all_data.loc[:, cols].dtypes.iteritems():\n    if t == object:\n        all_data[i] = pd.factorize(all_data[i])[0]\n\nall_data = reduce_mem_usage(all_data)\nall_data.head()","84edcf59":"X_train = all_data[all_data['winPlacePerc'].notnull()].reset_index(drop=True)\nX_test = all_data[all_data['winPlacePerc'].isnull()].drop(['winPlacePerc'], axis=1).reset_index(drop=True)\ndel all_data\ngc.collect()\n\nY_train = X_train.pop('winPlacePerc')\nX_test_grp = X_test[['matchId','groupId']].copy()\ntrain_matchId = X_train['matchId']\n\n# drop matchId,groupId\nX_train.drop(['matchId','groupId'], axis=1, inplace=True)\nX_test.drop(['matchId','groupId'], axis=1, inplace=True)\n\nprint(X_train.shape, X_test.shape)","fd7c1320":"print(pd.DataFrame([[val for val in dir()], [sys.getsizeof(eval(val)) for val in dir()]],\n                   index=['name','size']).T.sort_values('size', ascending=False).reset_index(drop=True)[:10])","e0b825d6":"from sklearn.model_selection import GroupKFold\nfrom sklearn.preprocessing import minmax_scale\nimport lightgbm as lgb\n\nparams={'learning_rate': 0.05,\n        'objective':'mae',\n        'metric':'mae',\n        'num_leaves': 128,\n        'verbose': 1,\n        'random_state':42,\n        'bagging_fraction': 0.7,\n        'feature_fraction': 0.7\n       }\n\nreg = lgb.LGBMRegressor(**params, n_estimators=10000)\nreg.fit(X_train, Y_train)\npred = reg.predict(X_test, num_iteration=reg.best_iteration_)","e10f9773":"# Plot feature importance\nfeature_importance = reg.feature_importances_\nfeature_importance = 100.0 * (feature_importance \/ feature_importance.max())\nsorted_idx = np.argsort(feature_importance)\nsorted_idx = sorted_idx[len(feature_importance) - 30:]\npos = np.arange(sorted_idx.shape[0]) + .5\n\nplt.figure(figsize=(12,8))\nplt.barh(pos, feature_importance[sorted_idx], align='center')\nplt.yticks(pos, X_train.columns[sorted_idx])\nplt.xlabel('Relative Importance')\nplt.title('Variable Importance')\nplt.show()","e59ecfe1":"X_train.columns[np.argsort(-feature_importance)].values","9cf6db13":"X_test_grp['_nofit.winPlacePerc'] = pred\n\ngroup = X_test_grp.groupby(['matchId'])\nX_test_grp['winPlacePerc'] = pred\nX_test_grp['_rank.winPlacePerc'] = group['winPlacePerc'].rank(method='min')\nX_test = pd.concat([X_test, X_test_grp], axis=1)","b649d3e1":"fullgroup = (X_test['numGroups'] == X_test['maxPlace'])\n\n# full group (201366) --> calculate from rank\nsubset = X_test.loc[fullgroup]\nX_test.loc[fullgroup, 'winPlacePerc'] = (subset['_rank.winPlacePerc'].values - 1) \/ (subset['maxPlace'].values - 1)\n\n# not full group (684872) --> align with maxPlace\nsubset = X_test.loc[~fullgroup]\ngap = 1.0 \/ (subset['maxPlace'].values - 1)\nnew_perc = np.around(subset['winPlacePerc'].values \/ gap) * gap  # half&up\nX_test.loc[~fullgroup, 'winPlacePerc'] = new_perc\n\nX_test['winPlacePerc'] = X_test['winPlacePerc'].clip(lower=0,upper=1)","b8fdfcf2":"_='''\nsubset = X_test.loc[~fullgroup].groupby(['matchId','_pred.winPlace']).filter(lambda x: len(x)>1)\n\nrank1p, rank1m = list(), list()\nfor n, df in subset.groupby(['matchId','_pred.winPlace']):\n    matchId, rank = n[0], n[1]\n    matchRanks = X_test[X_test['matchId'] == matchId]['_pred.winPlace'].values\n    df = df.sort_values(['_rank.winPlacePerc'])\n    dupCount = len(df)\n    \n    hasUpper = (rank == 1) or ((rank - 1) in matchRanks)\n    hasLower = (rank == df['maxPlace'].values[0]) or ((rank + 1) in matchRanks)\n    if hasUpper and not hasLower:\n        rank1p.append(df.index[dupCount-1])\n    elif not hasUpper and hasLower:\n        rank1m.append(df.index[0])\n    elif not hasUpper and not hasLower:\n        if (dupCount > 2):\n            rank1p.append(df.index[dupCount-1])\n            rank1m.append(df.index[0])\n        else:\n            base = 1.0 \/ (df['maxPlace'].values[0] - 1) * rank\n            percs = df['_nofit.winPlacePerc'].values\n            if abs(percs[0] - base) < abs(percs[dupCount-1] - base):\n                rank1p.append(df.index[dupCount-1])\n            else:\n                rank1m.append(df.index[0])\n                                \nX_test.loc[rank1p, '_pred.winPlace'] = X_test.loc[rank1p, '_pred.winPlace'] + 1\nX_test.loc[rank1m, '_pred.winPlace'] = X_test.loc[rank1m, '_pred.winPlace'] - 1\nprint(len(rank1p),len(rank1m))\n\nsubset = X_test.loc[~fullgroup]\ngap = 1.0 \/ (subset['maxPlace'].values - 1)\nnew_perc = (subset['_pred.winPlace'].values - 1) * gap\nX_test.loc[~fullgroup, 'winPlacePerc'] = new_perc\n'''","d00843fb":"# edge cases\nX_test.loc[X_test['maxPlace'] == 0, 'winPlacePerc'] = 0\nX_test.loc[X_test['maxPlace'] == 1, 'winPlacePerc'] = 1  # nothing\nX_test.loc[(X_test['maxPlace'] > 1) & (X_test['numGroups'] == 1), 'winPlacePerc'] = 0\nX_test['winPlacePerc'].describe()","36178c44":"test = pd.read_csv('..\/input\/test_V2.csv')\ntest['matchId'] = test['matchId'].apply(lambda x: int(x,16))\ntest['groupId'] = test['groupId'].apply(lambda x: int(x,16))\n\nsubmission = pd.merge(test, X_test[['matchId','groupId','winPlacePerc']])\nsubmission = submission[['Id','winPlacePerc']]\nsubmission.to_csv(\"submission.csv\", index=False)","9cb86d9b":"## delete feature","fc815a75":"- Plot players in group","e0730de4":"# Load data","bc1b9c62":"## drop feature","deebe421":"## matchDuration","9d0689f0":"## encode","951a2ce8":"## any match stats","e89f95e0":"## rank as percent","4304a443":"- kills summary of match","c8c74138":"## revives","134e1ed6":"- cheater?","7767cba4":"## boosts, heals","10361ff3":"## Submit","97960713":"# Predict","01d64911":"- killPlace is a sorted ranking of kills and winPlacePerc in each match","526ba691":"## killPoints, rankPoints, winPoints","831304be":"## match summary","2ce0a76e":"- zombie","6949f894":"- players in match, group\n\n100 players join the same server,  so in the case of duos the max teams are 50 and in the case of squads the max teams are 25.\n","55d957cc":"## maxPlace, numGroups","3d988d31":"- same match is same duration","2faca95b":"## matchType\n\nThere are 3 game modes in the game.  One can play solo, or with a friend (duo), or with 3 other friends (squad).","b78991ed":"## group summary","3104ad98":"## longestKill","848b52db":"## distance","c928905a":"## killPlace rank of group and kills","9cf2ae6f":"## killPlace","c470ac83":"## players","8e20959d":"## winPlacePerc","6d605c27":"## Id, groupId, matchId","31d56035":"- cause by computer only groups?","077b53c5":"## kills","adec125d":"## headshotKills, roadKills, teamKills","92e4aa9b":"## assists","4fdafcd8":"- min matchDuration","4fee5efe":"## aggregate feature","ac04cefb":"# Feature Engineering","9bc497be":"- max matchDuration","587d85e3":"## new feature","6b465f7c":"- groups in match","b22aaf76":"## damageDealt","0d83b814":"- what this mean?","7e80273b":"## killStreaks, DBNOs","fad0def7":"## grouping\n\n* need to predict the order of places for groups within each match.\n* train on group-level instead of the user-level","6ccce924":"- Too many group players","564efb0e":"## walkDistance, rideDistance, swimDistance","6ba2ac49":"# Data Analysis"}}