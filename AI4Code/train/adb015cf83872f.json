{"cell_type":{"89a840f1":"code","d084ddcf":"code","12ea042a":"code","b78e5915":"code","42a9c96c":"code","42a74582":"code","acd30548":"code","62488dae":"code","47191202":"code","5de21a14":"code","f901ffb2":"code","f0fc3c81":"code","fbd927fd":"code","eaf98964":"markdown","46d5a578":"markdown","47d252d4":"markdown","193d4f0e":"markdown","911b07b9":"markdown","42c939b0":"markdown","b15202b7":"markdown","e00cdf30":"markdown","77e5e98b":"markdown","142b5c87":"markdown","3cc81500":"markdown","6b48f945":"markdown"},"source":{"89a840f1":"import json\nimport math\nimport matplotlib.mlab as mlab\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as pyplot\n\nimport numpy # linear algebra\nimport pandas  # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport pprint\nimport re\nimport requests\nfrom scipy.stats import norm\nimport seaborn\nfrom sklearn.mixture import GaussianMixture\nimport time\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using\n#\"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d084ddcf":"\n\nfor YEAR in [1924, 1928, 1932, 1936, 1948, \n             1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1994, 1998, 2002, 2006, 2010, 2014, 2018] :\n\n# The category naming is consistent\n# The years there were olympics isn't, so you gotta type that list out by hand.  Sorry.\n    print(\"Loading year \", YEAR) #Just so I know it ain't frozen\n    category_url = \"https:\/\/en.wikipedia.org\/w\/api.php?action=query&list=categorymembers&cmtitle=Category:Ice_hockey_players_at_the_\" + str(YEAR) + \"_Winter_Olympics&cmlimit=10000&format=json\"\n    category_response = requests.get(category_url).text\n    category_data = json.loads(category_response)\n\n    names = []\n\n    for index in range(len(category_data['query']['categorymembers'])):\n    #    print(len(data['query']['categorymembers']))    \n    #    print(data['query']['categorymembers'][index]['title'])\n    #    These are just leftovers from when I first loaded a page and read through the data\n    #    I left it here so you can follow how I did it; of course, I actually did print(data), then print(data['query'])\n    #    and so forth until I got to where i needed, only opening a single page\n        names.append(category_data['query']['categorymembers'][index]['title'])\n\n    #print(players)\n\n    value_holder = 0 #It holds value\n\n    protoframe = []  #I'm going to assemble it as a list, for simplicity\n\n    for name in names :\n\n        #print(name, ' ', end='')\n    \n        url = \"https:\/\/en.wikipedia.org\/w\/api.php?action=query&titles=\" + name + \"&prop=revisions&rvprop=content&format=json\"\n\n        response = requests.get(url).text\n\n        data = json.loads(response)\n\n        page_num = next(iter(data['query']['pages'].keys())) # Okay, looks odd, Wikipedia has a page number, I think for querying \n                                                             # multi pages at once.  But I think one by one is easier, so the only\n                                                             # key is the one I want\n                                                             # Maybe partly too because I wanted to get the script working on a \n                                                             # single page, before trying to load a whole category's worth\n\n        page = data['query']['pages'][page_num]['revisions'][0]['*'] #As above, found iteratively\n\n        height_inch = 0\n        height_foot = 0\n        \n        #Right, so because Wikipedia is full of hand entered data by many people, it's pretty irregular\n        #Still, the infoboxen are semi-standaradised, so that helps immensely\n        #Anyways, height_foot and height_inch is the most common standard, so I'm using them\n        #But, can be metric, and you can have blank metric and filled imperial or vice versa\n        #Anyways, do the obvious things : use try and have the code tell you every time it fails, inspect the failure by hand\n    \n        #In general, using \"try\" on a float() tells you you've indeed found a number\n        #You gotta be careful not to set the height_foot or height_inch until you're confident the try is going to succeed\n        if len(re.split('height_ft\\s*=\\s*', page)) > 1 :\n            try :\n                height_temp = re.split('height_ft\\s*=\\s*', page)[1]\n                height_temp = float(re.split('\\n|\\s+|<', height_temp)[0])\n                height_foot = height_temp\n                if len(re.split('height_in\\s*=\\s*', page)[1]) > 1 :\n                    height_temp = re.split('height_in\\s*=\\s*', page)[1]\n                    height_temp = float(re.split('\\n|\\s+|<', height_temp)[0])\n                    height_inch = height_temp\n                else :\n                    height_inch = 0\n            except :\n                value_holder += 1\n            \n        if len(re.split('height_cm\\s*=\\s*', page)) > 1 :\n            try :\n                height_cm = re.split('height_cm\\s*=\\s*', page)[1]\n                height_cm = float(re.split('\\n|\\s+|<', height_cm)[0])\n                height_inch = height_cm\/2.54 #We're gonna use this, but we've passed the danger zone of trying to convert to float\n                height_foot = 0\n    #            print(\"Alpha\", height_inch)\n            except :\n                value_holder += 1\n    #            print(\"Bravo\", height_inch, height_foot)\n            \n        if len(re.split('height_m\\s+=\\s+', page)) > 1 :\n            try :\n                height_temp = re.split('height_m\\s+=\\s+', page)[1]\n                height_temp = float(re.split('\\n|\\s+|<', height_temp)[0])\/0.0254\n                height_inch = height_temp\n                height_foot = 0\n            except :\n                value_holder += 1\n                \n        #Found a few of these generic ones, they seem to typically be 6 ft 3 in or 1.91 m formats\n        #Do check that other formats aren't used\n                \n        if len(re.split('height\\s+=\\s+', page)) > 1 :\n            try : \n                height_temp = re.split('height\\s+=\\s+', page)[1]\n                if len(re.split('\\s+ft\\s+', height_temp)) > 1 :\n                    height_temp = float(re.split('\\s+ft\\s+', height_temp)[0].split('\\n')[0])\n                    height_foot = height_temp\n                    height_inch = re.split('\\s+ft\\s+', page)[1]\n                    if len(re.split('\\s+in\\s+', height_inch[:20])) > 1 : #Limiting it to the next few characters reduces the risk of a false positive\n                        height_inch = float(re.split('\\s+ft\\s+', re.split('\\s+in\\s+', page)[0])[1])\n                    else :\n                        height_inch = 0\n                else :\n                    height_inch = 0\n                    height_foot = 0        \n            except : \n                value_holder += 1\n\n        weight_lb = 0\n        weight_temp = 0\n        weight_kg = 0\n    \n        if len(re.split('weight_lb\\s*=\\s*', page)) > 1 : \n            try :\n                weight_temp = re.split('weight_lb\\s*=\\s*', page)[1]\n                weight_temp = float(re.split('\\n|s+|<', weight_temp)[0])\n                weight_lb = weight_temp\n            except :\n                value_holder += 1\n        \n        if len(re.split('weight_lbs\\s*=\\s*', page)) > 1 : \n            try : \n                weight_temp = re.split('weight_lbs\\s*=\\s*', page)[1]\n                weight_temp = float(re.split('\\n|s+|<', weight_temp)[0])\n                weight_lb = weight_temp\n            except :\n                value_holder += 1\n            \n        if len(re.split('weight_kg\\s*=\\s*', page)) > 1 :\n            try:\n                weight_kg = re.split('weight_kg\\s*=\\s*', page)[1]\n                weight_kg= float(re.split('\\n|\\s+|<', weight_kg)[0])\n                weight_lb = weight_kg*2.2\n            except : \n                value_holder += 1\n            \n        #As with heights, the generic weights are lb lbs kg kgs - split on those, look for successes\n        #limit yourself to the next 20 chars to avoid hitting false positives\n        if len(re.split('weight\\s*=\\s*', page)) > 1 :\n            try: \n                weight_temp = re.split('weight\\s*=\\s*', page)[1]\n                if len(re.split('\\s*lb\\s*', weight_temp[:20])) > 1 :\n                    weight_temp = float(re.split('\\s*lb\\s*', weight_temp[:20])[0])\n                    weight_lb = weight_temp\n                elif len(re.split('\\s*kg\\s*', weight_lb[:20])) > 1 :\n                    weight_temp = float(re.split('\\s*kg\\s*', weight_temp[:20])[0])\n                    weight_lb = weight_temp*2.2\n            except :\n                value_holder += 1\n            \n        birth_year = page.split(' births]]')[0] #This is just the Wikipedia categorisation scheme\n                                                #But it seems to be used pretty ubiquitously\n    \n        try:\n            birth_year = int(birth_year[-4:]) #HARDCODING THEY WERE BORN IN A YEAR WITH 4 DIGITS?!  FOR SHAME!\n        except :\n            birth_year = 0\n    \n        if len(re.split('ntl_team\\s*=\\s*', page)) > 1 : \n            nationality = re.split('ntl_team\\s*=\\s*', page)[1]\n            if nationality[0] == '{':\n                nationality = nationality[2:5].upper()\n            else :\n                nationality = nationality[:3].upper()\n        else :\n            nationality = 'XXX'\n        #print(nationality)\n        \n    \n        #Okay, the below is not the most elegant solution, but it's pretty messy in the boxen\n        if nationality not in ['AUS', 'AUT', 'BEL', 'BLR', 'BUL', 'CAN', 'CHE', 'CHI', 'CHN', 'CSK', \n                               'CZE', 'DEU', 'DDR', 'EUA', 'EUN', 'FIN', 'FRA', 'FRG', 'GBR', 'GER', \n                               'GRE', 'HUN', 'ITA', 'JAP', 'KOR',\n                               'JPN', 'KAZ', 'LAT', 'LVA', 'NED', 'NET', 'NLD', 'NOR', \n                               'POL', 'PRK', 'ROM', 'SLO', 'SFR', 'SOU', 'SOV', 'SUI', 'SWI', 'SVK', 'SVN', \n                               'SWE', 'TCH', 'RUS', 'UKR', 'UNI', 'URS', 'USA', \n                               'USR', 'USS', 'WES', 'YUG', 'XXX'] :\n            #print('UNREGISTERED NATIONALITY: ', nationality, ' for ', name)\n            #Don't need this anymore, but it is indeed how I found all the errant nationalities\n            \n            nationality = 'XXX'\n        else :\n            if nationality == 'BEL' :\n                nationality = 'BLR'\n            if nationality == 'CHE' :\n                nationality = 'SUI'\n            if nationality == 'CHI' :\n                nationality = 'CHN'\n            if nationality == 'CSK' :\n                nationality = 'TCH'\n            if nationality == 'EUA' :\n                nationality = 'GER'\n            if nationality == 'EUN' :\n                nationality = 'URS'\n            if nationality == 'GRE' : #Could also be a GER type, but the first example O found was Great Britain typed out by hand\n                nationality = 'GBR'\n            if nationality == 'JAP' :\n                nationality = 'JPN'\n            if nationality == 'NET' :\n                nationality = 'NED'\n            if nationality == 'LVA' :\n                nationality = 'LAT'\n            if nationality == 'NLD' :\n                nationality = 'NED'\n            if nationality == 'SFR' :\n                nationality = 'YUG'\n            if nationality == 'SOU' :\n                nationality = 'KOR'\n            if nationality == 'SOV' :\n                nationality = 'USR'\n            if nationality == 'SVN' :\n                nationality = 'SLO'\n            if nationality == 'SWI' :\n                nationality = 'SUI'\n            if nationality == 'UNI' :\n                nationality = 'USA' #Could be others, but probably a safe bet\n            if nationality == 'USR' :\n                nationality = 'URS'\n            if nationality == 'USS' :\n                nationality = 'URS'\n            if nationality == 'WES' :\n                nationality = 'FRG'\n        # Right, so this is fearsome ugly, but what are you going to do?\n        # Actual fields are not well standardised in the database\n        # Hashtag Actual Data or the like, eh?\n        \n        #print(\"Height: \", height_foot, \"'\", height_inch,'\"')\n        #print(\"Weight: \", weight_lb)\n        #print(\"Born: \", birth_year)\n    \n        if len(re.split('sex\\s*=\\s*', page)) > 1 : \n            sex = re.split('sex\\s*=\\s*', page)[1]           \n            sex = sex[0].upper()\n        else :\n            sex = 'X'\n        if sex not in ['F', 'M'] : \n            sex = 'X'\n            \n        #In practice, there are basically no men with this field filled out\n        #It looks like most women are\n        #Still, if I want to use it, I'll have to figure out another way to pull it from the page\n        #A quick perusal of the pages of a few guys (Lemieux, Orr), I don't see a clear candidate\n        \n        if len(re.split('shoots\\s*=\\s*', page)) > 1 :\n            shoots = re.split('shoots\\s*=\\s*', page)[1]\n            shoots = shoots[0].upper()\n        else :\n            shoots = 'X'\n        if shoots not in ['A', 'L', 'R'] :\n            shoots = 'X'\n\n    \n        try : \n            print_name = re.split('\\(', name)[0] #Remove any disambiggy stuff from names\n                                                 # Because a lot are titles of the form John Smith (born 1982)\n                                                 # to also allow for John Smith (born 1983), but things like\n                                                 # Gordon MacKenzie (the hockey guy) are also used\n        except :\n            value_holder += 1\n            print_name = 'John Doe'\n        \n        # print(print_name, height_foot, height_inch, weight_lb, birth_year, nationality)\n        # Originally I was running one, then a couple dozen pages, and printing everything to check by hand it was working\n        # Now it's commented out, but left here for posterity\n    \n        if ((name[:3] != 'Ice') & (name[:8] != 'Category')) :\n            protoframe.append([print_name, 12*height_foot+height_inch, weight_lb, birth_year, nationality, page_num, sex, shoots])\n    \n        time.sleep(0.1)\n    #print(data['query']['pages']['revisions']['*'])\n\n    #print(protoframe)\n\n    column_names = ['Name', 'Height', 'Weight', 'Birth_Year', 'Nationality', 'ID', 'Sex', 'Shoots']\n\n    hockey_frame = pandas.DataFrame(protoframe, columns = column_names)\n\n    #print(hockey_frame.head())\n\n    #hockey_frame = hockey_frame.drop(hockey_frame[hockey_frame.Weight < 1].index)\n    #hockey_frame = hockey_frame.drop(hockey_frame[hockey_frame.Height < 1].index)\n    #hockey_frame.hist()\n \n    hockey_frame.to_pickle(str(YEAR) + \"_players.dat\")","12ea042a":"all_players = pandas.DataFrame()\n\nfor YEAR in [1924, 1928, 1932, 1936, 1948, \n             1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1994, 1998, 2002, 2006, 2010, 2014, 2018] :\n    load_frame = pandas.read_pickle(str(YEAR) + \"_players.dat\")\n    all_players = pandas.concat([all_players, load_frame]).drop_duplicates().reset_index(drop=True)\n\n    \n\n\n    \n\npairs = seaborn.pairplot(all_players, hue='Sex') #A good zeroeth order look at the data\npairs.axes[0,0].set_xlim((60,85))\npairs.axes[0,0].set_ylim((60,85))\npairs.axes[0,1].set_xlim((90,285))\npairs.axes[1,0].set_ylim((90,285))\npairs.axes[0,2].set_xlim((1880,2010))\npairs.axes[2,0].set_ylim((1880,2010))\n#Note that since I've set cuts to the \"plausible\" values of the data, I'll need to look at outliers afterwards\n\n\n","b78e5915":"print(all_players.loc[(all_players['Sex'] == 'F') & (all_players['Weight'] > 200)])","42a9c96c":"print(all_players.loc[(all_players['Birth_Year'] < 1880)]) #Seems like they're all old timers who don't have birth years\n                                                           #Or the list pages, but I've purged them now\nprint(all_players.loc[(all_players['Birth_Year'] > 2010)]) ","42a74582":"print(all_players.loc[(all_players['Height'] > 85)])\nprint(all_players.loc[(all_players['Height'] < 60) & (all_players['Height'] > 0)])\nprint(all_players.loc[(all_players['Weight'] > 285)])\nprint(all_players.loc[(all_players['Weight'] < 90) & (all_players['Weight'] > 0)])","acd30548":"figure, axes = pyplot.subplots(2,3, figsize=(20,14))\n\naxes[0,0].set_xlim(60,85)\naxes[0,0].set_ylim(90,285)\n\naxes[0,1].set_xlim(60,85)\naxes[0,1].set_ylim(90,285)\n\naxes[0,2].set_xlim(60,85)\n\naxes[1,0].set_xlim(1880,2010)\naxes[1,0].set_ylim(60,85)\n\naxes[1,1].set_xlim(1880,2010)\naxes[1,1].set_ylim(90,285)\n\naxes[1,2].set_xlim(1880,2010)\naxes[1,2].set_ylim(60,85)\n\n\nseaborn.scatterplot(data = all_players, x = 'Height', y = 'Weight', hue='Sex',ax=axes[0,0])\n\n\n\nseaborn.kdeplot(all_players[(all_players['Sex'] == 'F') \n                            & (all_players['Height'] > 0) \n                            & (all_players['Weight'] > 0)].Height, \n                all_players[(all_players['Sex'] == 'F')\n                            & (all_players['Height'] > 0) \n                            & (all_players['Weight'] > 0)].Weight, ax=axes[0,1])\nseaborn.kdeplot(all_players[(all_players['Sex'] == 'X') \n                            & (all_players['Height'] > 0) \n                            & (all_players['Weight'] > 0)].Height, \n                all_players[(all_players['Sex'] == 'X')\n                            & (all_players['Height'] > 0) \n                            & (all_players['Weight'] > 0)].Weight, ax=axes[0,1])\n\n#The first time I did this, I forgot to exclude the zereoes\n#It did not look good\n#Don't do it, eh?\n\nseaborn.distplot(all_players[all_players['Height'] > 0].Height, bins=[i for i in range(60,81)], ax=axes[0,2])\n\nseaborn.kdeplot(all_players[(all_players['Sex'] == 'F')\n                           & (all_players['Birth_Year'] > 0)\n                           & (all_players['Height'] > 0)].Birth_Year, \n                all_players[(all_players['Sex'] == 'F')\n                           & (all_players['Birth_Year'] > 0)\n                           & (all_players['Height'] > 0)].Height, ax=axes[1,0])\nseaborn.kdeplot(all_players[(all_players['Sex'] == 'X')\n                           & (all_players['Birth_Year'] > 0)\n                           & (all_players['Height'] > 0)].Birth_Year, \n                all_players[(all_players['Sex'] == 'X')\n                           & (all_players['Birth_Year'] > 0)\n                           & (all_players['Height'] > 0)].Height, ax=axes[1,0])\n\nseaborn.kdeplot(all_players[(all_players['Sex'] == 'F')\n                           & (all_players['Birth_Year'] > 0)\n                           & (all_players['Weight'] > 0)].Birth_Year, \n                all_players[(all_players['Sex'] == 'F')\n                           & (all_players['Birth_Year'] > 0)\n                           & (all_players['Weight'] > 0)].Weight, ax=axes[1,1])\n\nseaborn.kdeplot(all_players[(all_players['Sex'] == 'X')\n                           & (all_players['Birth_Year'] > 0)\n                           & (all_players['Weight'] > 0)].Birth_Year, \n                all_players[(all_players['Sex'] == 'X')\n                           & (all_players['Birth_Year'] > 0)\n                           & (all_players['Weight'] > 0)].Weight, ax=axes[1,1])\n\n\nseaborn.scatterplot(data = all_players, x = 'Birth_Year', y = 'Height', hue='Sex',ax=axes[1,2])","62488dae":"figure, axes = pyplot.subplots()\naxes.set_xlim(60,80)\n\n\nNorth_Americans = all_players[all_players['Nationality'].isin([\"CAN\", \"USA\"])]\n\n\nseaborn.distplot(North_Americans['Height'], bins=[i for i in range(60,81)], ax=axes)\n\n#print(sorted(all_players['Nationality'].unique()))\n#I just wanted them listed so I could sort by continent\n\nEuropeans = all_players[all_players['Nationality'].isin(['AUS', 'BLR', 'BUL', 'CZE', 'DDR', 'DEU', 'FIN', 'FRA', 'FRG', 'GBR', 'GER', \n                               'HUN', 'ITA', 'LAT', 'NED', 'NOR', \n                               'POL', 'ROM', 'SLO', 'SOV', 'SUI', 'SVK', \n                               'SWE', 'TCH', 'RUS', 'UKR', 'UNI', 'URS', \n                               'USR', 'WES', 'YUG'])]\n\nseaborn.distplot(Europeans['Height'], bins=[i for i in range(60,81)], ax=axes)\n\nAsians = all_players[all_players['Nationality'].isin(['CHN', 'JPN', 'KAZ', 'KOR', 'PRK'])]\n\nseaborn.distplot(Asians['Height'], bins=[i for i in range(60,81)], ax=axes)","47191202":"figure, axes = pyplot.subplots(figsize=(12,12))\n\ncounts, bins, bars = pyplot.hist(all_players[(all_players['Sex'] == 'X')\n                                             & (all_players['Height'] > 0)].Height, bins = [i for i in range(60,85)])\n\nbins = [i + 0.5 for i in bins[:-1]]\ncounts = [i for i in counts]\nsigma_counts = [math.sqrt(i)+1e-10 for i in counts]\n#print(type(sigma_counts), type(counts), type(bins))\n#print(len(sigma_counts), len(counts), len(bins))\n\nN_players = len(all_players[(all_players['Sex'] == 'X')\n                                             & (all_players['Height'] > 0)].Height)\n\n(mu, sigma) = norm.fit(all_players[(all_players['Sex'] == 'X')\n                                             & (all_players['Height'] > 0)].Height)\ng_bins = [i - 0.5 for i in bins]\n\nprint(mu, sigma)\ngauss_fit = norm.pdf(g_bins, mu, sigma)\npyplot.plot(bins, N_players*gauss_fit, 'b--', linewidth=2)\n\npyplot.bar(bins, counts, width=1.0, color='r', yerr=sigma_counts)\npyplot.show()\n\n","5de21a14":"print(\"Six foot tall is \", 72.0*2.54, \" cm to \", 72.999999*2.54, \" cm\")\n\npandas.options.display.max_rows = 4000\nprint(type(Europeans['Height'].value_counts(ascending=True)))\n\n#print((Europeans['Height'].value_counts(ascending=True)).sort_values(axis=0,ascending=False))\nprint((Europeans['Height'].value_counts(ascending=True)).sort_index())\n#Whether you find the former or latter format preferable is probably a matter of taste and custom\n\nful\n","f901ffb2":"figure, axes = pyplot.subplots(1,3)\nCanadians = all_players[all_players['Nationality'].isin([\"CAN\"])]\nCanadians.Shoots.value_counts().plot.bar(ax=axes[0])\n\nAmericans = all_players[all_players['Nationality'].isin([\"USA\"])]\nAmericans.Shoots.value_counts().plot.bar(ax=axes[1])\n\nall_players.Shoots.value_counts().plot.bar(ax=axes[2])\n","f0fc3c81":"print(all_players.Sex.value_counts())\n\nfigure, axes = pyplot.subplots(1, 2, figsize=(20,8))\n\naxes[0].set_xlim(60,85)\naxes[1].set_xlim(90,285)\n\nseaborn.distplot(all_players[(all_players['Sex'] == 'F') & (all_players['Height'] > 0)].Height, ax=axes[0], bins = [i for i in range(60,80)])\nseaborn.distplot(all_players[(all_players['Sex'] == 'X') & (all_players['Height'] > 0)].Height, ax=axes[0], bins = [i for i in range(60,80)])\n\nseaborn.distplot(all_players[(all_players['Sex'] == 'F') & (all_players['Weight'] > 0)].Weight, ax=axes[1], bins = [5*i for i in range(20,60)])\nseaborn.distplot(all_players[(all_players['Sex'] == 'X') & (all_players['Weight'] > 0)].Weight, ax=axes[1], bins = [5*i for i in range(20,60)])\n\n#Possibly it's not quite perfect, but those look pretty normal and non-overlapping","fbd927fd":"machine_model = GaussianMixture(n_components=2)\n\nheights = all_players[(all_players['Height'] > 0)\n                    & (all_players['Weight'] > 0)].Height.tolist()\nweights = all_players[(all_players['Height'] > 0)\n                    & (all_players['Weight'] > 0)].Weight.tolist()\n\n\n\nhwarray = numpy.dstack((numpy.array(heights), numpy.array(weights)))\n\nn_elements = len(numpy.array(heights))\n\nhwarray = hwarray.reshape(n_elements,2)\n\nmachine_model.fit(hwarray)\n# assign a cluster to each example\npops = machine_model.predict(hwarray)\n\nclusters = numpy.unique(pops)\n\nfigs, axes = pyplot.subplots(1,3, figsize=(18,8))\n\naxes[0].set_xlabel('Height (in)')\naxes[0].set_ylabel('Weight (lb)')\n\naxes[1].set_xlabel('Height (in)')\naxes[1].set_ylabel('Weight (lb)')\n\nfor cluster in clusters:\n    underlying = numpy.where(pops == cluster)\n    axes[0].scatter(hwarray[underlying, 0], hwarray[underlying, 1])\n\n\nplotFrame = pandas.DataFrame({'H': hwarray[:, 0], 'W': hwarray[:, 1], 'Population' : pops})\n\nseaborn.kdeplot(data = plotFrame[plotFrame['Population'] == 1], ax=axes[1])\nseaborn.kdeplot(data = plotFrame[plotFrame['Population'] == 0], ax=axes[1])\n\nlabels = []\n\nseaborn.kdeplot(all_players[(all_players['Sex'] == 'F') \n                            & (all_players['Height'] > 0) \n                            & (all_players['Weight'] > 0)].Height, \n                all_players[(all_players['Sex'] == 'F')\n                            & (all_players['Height'] > 0) \n                            & (all_players['Weight'] > 0)].Weight, \n                ax=axes[2])\nlabel = mpatches.Patch(\n        color='Orange',\n        label='Men')\nlabels.append(label)\nseaborn.kdeplot(all_players[(all_players['Sex'] == 'X') \n                            & (all_players['Height'] > 0) \n                            & (all_players['Weight'] > 0)].Height, \n                all_players[(all_players['Sex'] == 'X')\n                            & (all_players['Height'] > 0) \n                            & (all_players['Weight'] > 0)].Weight, \n                ax=axes[2])\nlabel = mpatches.Patch(\n        color='Blue',\n        label='Women')\nlabels.append(label)\naxes[2].legend(handles=labels, loc='upper left')\n\npyplot.show()\n\n","eaf98964":"**Yes, there's one guy who is twenty something feet tall**\n\nhttps:\/\/en.wikipedia.org\/w\/index.php?title=Maksymilian_Wi%C4%99cek&oldid=861607362\n\n**Since the article's creation, he has been listed as 6'185\", so ... yup**\n\n**I suspect it's a typo on data entry, though**\n\n**Yeah, it was 185 lbs, so I fixed it**\n\nhttps:\/\/en.wikipedia.org\/w\/index.php?title=Maksymilian_Wi%C4%99cek&type=revision&diff=977506356&oldid=967682974\n\n**We'll see if it sticks**\n\n**Okay, a couple of the women are 4'11\", which seems plausible**","46d5a578":"**Okay, compared to a gaussian fit, the excess at exactly six foot looks close to three sigma**\n\n**But, of course, we can't much mess with binning**\n\n**And 6'1\" is undershot ... but maybe that's the excess of 6'0\" pulling the dis ?**\n\n**This is probably what we can do with this data, maybe I'll scrape all NHL players when I have time**","47d252d4":"**The European overdensity at 6'0\" isn't a metric conversion, but given how they're overwhelming whole numbers of inches**\n\n**They aren't being converted from metric.  So, I can't conclude much, I think**\n\n**At least, you can see the shorter people, who're overwhelmingly women, have a lot of non integer heights (i.e., their heights were \nin metric), and the taller people (i.e., men) don't.  So, it's not a cm rounding issue, they are listed as 6'0\" **\n\n**The Asians too, but there are a lot more women in their pretty small sample, since the women's teams have been relatively more success**","193d4f0e":"**Okay, so editors are inserting the sex field on female hockey players, but not males.  A brief examination reveals getting the sex\nout of the pages isn't that straightforward.  Could try by first name, but with many different ethnic backgrounds, that's tricky\nCould try some more sophisticated machine learning if I were keen, but probably almost all X are really M.**\n\n\n**I'm not really sure what to do here, other than just use X as M ... I should probably put the 4 Ms back into X**","911b07b9":"**No, there's a few zeroes, but inspection shows they're just old-timers who don't have know birthdays**\n\n**Okay, how about heights or weights outside of the known range (excluding zeroes, of which there are lots, essentially null values**","42c939b0":"**You may ask me, Andrew, is it really wise to load and save players year by year, then load 'em and and eliminate\nduplicates?  Well ... if it crashes or something, maybe, and if you want to re-use just some data, maybe\nSo ... maybe**\n\n**I'm going to look at the implausible seeming outliers to clean them\nIn a huge dataset, you might check a few, maybe drop them\nHere, it's small enough you can check 'em all\nAnd it's Wikipedia, so I'll fix 'em where appropriate\nFor instance, I find a 5' 2\", 250lb lady?  That doesn't sound right**\n","b15202b7":"**Well, it's what the page says :** https:\/\/en.wikipedia.org\/wiki\/Yuka_Hirano\n\n**But I doubt it's right**\n\n**Indeed, looks like an error someone introduced trying to convert kgs to lbs but failing:**\n\nhttps:\/\/en.wikipedia.org\/w\/index.php?title=Yuka_Hirano&type=revision&diff=701890465&oldid=695738031\n\n**I fixed it :** https:\/\/en.wikipedia.org\/w\/index.php?title=Yuka_Hirano&type=revision&diff=977202283&oldid=930901729\n**But it's Wikipedia, who knows if it'll hold ?**\n**Anyways, a general purpose plot like this can reveal wacky outliers that haven't been properly cleaned, like that()**\n\n**Okay, so that's the funny looking height-weight combo, any odd birthdays?  **","e00cdf30":"**Anyways, I had this idea that if heights had lies, we'd see more Canadians and Americans listing their height as exactly six foot**\n\n**And less Europeans\/Asians, since they typically measure height in metric**\n\n**The data shows the opposite, and the European\/Asian men almost all have heights in feet and inches**\n\n**I suspect this is because the ones we have height\/weight for played in the NHL, but I haven't verified that**","77e5e98b":"**# Load all the libraries in a separate cell, since I don't need the data grabbing cell each time I play with this**","142b5c87":"**Hmm, auto-recognition doesn't work flawlessly on the overlap.  I guess men and women lie largely on the same height-weight sequence.**\n\n**I'm not sure if I should've expected that ?**\n\n**I suspect that the machine learning would do better if it knew about birth year.  But, okay, I was really just curious about whether the sequences would sort them, and it looks like it won't do a great job if they're near the interface.**","3cc81500":"**The effect isn't as extreme as the article, but does appear to be real.**  \n\n**Still, maybe there's some additional selection effects on Americans who make it to the top level?**\n\n**And Americans are overrepresented in players who weren't detected, a possible source of bias**","6b48f945":"**Just for fun (althought this all is), I'm going to look at Lefty-Righty, per this article : **\n\nhttps:\/\/www.nytimes.com\/2010\/02\/16\/sports\/olympics\/16lefty.html"}}