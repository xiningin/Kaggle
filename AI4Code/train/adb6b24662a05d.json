{"cell_type":{"2950dc57":"code","e8f64346":"code","2d47bc32":"code","9c727c90":"code","ba684c0e":"code","5cda7ea3":"code","9198a8f1":"code","4a576b13":"code","849aab08":"code","8d9e3cdf":"code","6a73e5f2":"code","5051340c":"code","02fa51cd":"code","41303acc":"code","c37af3f3":"code","d39054a6":"code","11602d38":"code","71b0c712":"code","6b562bd4":"code","601ea686":"code","d73a9eb4":"code","37572b95":"code","83cf30ec":"code","a1cbd9a0":"code","95b32bab":"code","8291a685":"code","6669b53b":"code","0968a716":"code","88d6b56b":"code","4a06a550":"code","6883a1ca":"code","49dd2764":"code","5b8f5e22":"code","9a0dfcf6":"markdown","1103ae83":"markdown","39f8ccda":"markdown","0c9fad62":"markdown"},"source":{"2950dc57":"import pandas as pd\nimport numpy as np\nfrom pathlib import Path\nimport os\nimport re\nfrom collections import defaultdict\nimport math","e8f64346":"from sklearn.metrics import roc_auc_score\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.model_selection import cross_validate\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import StratifiedKFold\nimport time\nfrom tqdm import tqdm_notebook as tqdm\nimport lightgbm as lgb\nfrom lightgbm import LGBMClassifier, LGBMRegressor\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import LabelEncoder\n\nfrom keras.layers import Input, Dense, Dropout, BatchNormalization\nfrom keras.optimizers import Adam\nfrom keras.models import Model\nfrom keras.callbacks import EarlyStopping\nfrom sklearn.linear_model import LogisticRegression\n\nfrom sklearn.dummy import DummyClassifier","2d47bc32":"seed_averaging = True","9c727c90":"seeds = [71, 7, 64, 65, 12345]","ba684c0e":"## \u74b0\u5883\u3054\u3068\u306e\u30d1\u30b9\u306e\u9055\u3044\u3092\u5438\u53ce\nimport os\nif 'KAGGLE_URL_BASE' in os.environ:\n    print('running in kaggle kernel')\n    data_dir = Path('\/kaggle\/input')\nelse:\n    print('running in other environment')\n    data_dir = Path('.\/')\ndata_dir","5cda7ea3":"train_file = data_dir \/ 'train.csv'\ntest_file = data_dir \/ 'test.csv'\ncountry_file = data_dir \/ 'country_info.csv'","9198a8f1":"col_target = 'ConvertedSalary'","4a576b13":"pd.set_option('display.max_columns', 120)\npd.set_option('display.max_rows', 150)","849aab08":"def remove_outliers(df_all):\n    # \u5e74\u53cemax\u5024\u306e2000000.0\u3068\u56de\u7b54\u3057\u3066\u3044\u308b\u4eba\u304c227\u4eba\u3044\u308b\u3002\u602a\u3057\u3044\u306e\u3067\u9664\u53bb\u3059\u308b\n    df_all = df_all.loc[df_all[col_target] != 2000000.0]\n    # 0\u3082\u9664\u53bb\u3057\u3066\u3057\u307e\u3046\u304b\uff1f 0\u306e\u4e88\u6e2c\u3092\u5916\u3059\u3068\u30a8\u30e9\u30fc\u304c\u6975\u3081\u3066\u5927\u304d\u3044\u306e\u30670\u304b\u3069\u3046\u304b\u4e88\u6e2c\u3059\u308b\u30e2\u30c7\u30eb\u3092\u4f5c\u3063\u305f\u3089\u3044\u3044\u306e\u3067\u306f\uff1f\n    df_all = df_all.loc[df_all[col_target] != 0]\n    \n    return df_all","8d9e3cdf":"def add_country_info(df_all):\n    df_country = pd.read_csv(country_file)\n    df_all = pd.merge(df_all, df_country, on='Country', how='left')\n    return df_all","6a73e5f2":"df_all_cache = None","5051340c":"# \u4e00\u756a\u57fa\u672c\u7684\u306a\u30c7\u30fc\u30bf\u30ed\u30fc\u30c9\u304c\u7d42\u308f\u3063\u305f\u3068\u3053\u308d\u3067\u30ad\u30e3\u30c3\u30b7\u30e5\u3092\u4fdd\u5b58\u3057\u3066\u304a\u304d\u3001\u4e8c\u56de\u76ee\u4ee5\u964d\u306f\u30ad\u30e3\u30c3\u30b7\u30e5\u306e\u30b3\u30d4\u30fc\u3092\u8fd4\u3057\u3066\u9ad8\u901f\u5316\ndef load_data():\n    # load data from file or return cache\n    global df_all_cache\n    if df_all_cache is not None:\n        return df_all_cache.copy()\n\n    df_train = pd.read_csv(train_file)\n    df_test = pd.read_csv(test_file)\n    df_country = pd.read_csv(country_file)\n    \n    df_train['is_train'] = True\n    df_test['is_train'] = False\n    df_test[col_target] = -0.5\n    df_test = df_test[df_train.columns]\n\n    df_all_cache = pd.concat([df_train, df_test], axis=0)\n    return df_all_cache.copy()","02fa51cd":"def encode_multiple_answers(df_all):\n    # \u8907\u6570\u56de\u7b54\u30ab\u30e9\u30e0\u3092\u6570\u5024\u306b\u30a8\u30f3\u30b3\u30fc\u30c9\u3002\n    # 1. \u56de\u7b54\u6570\u3092\u8ffd\u52a0\n    # 2. a;b;d \u2192 8 + 4 + 1 \u306e\u3088\u3046\u306a\u611f\u3058\u3067\u30a8\u30f3\u30b3\u30fc\u30c9\n    #  \u3082\u3063\u3068\u3082\u767b\u5834\u56de\u6570\u304c\u5927\u304d\u3044Value\u304c\u4e0a\u4f4d\u30d3\u30c3\u30c8\u306b\u30a8\u30f3\u30b3\u30fc\u30c9\u3055\u308c\u308b\u3088\u3046\u306b\u3059\u308b\n    #  \u6b20\u640d\u5024\u304c\u57cb\u3081\u3089\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u524d\u63d0\u3068\u3059\u308b\n    multiple_cols = [\"DevType\", \"CommunicationTools\", \"FrameworkWorkedWith\"]\n    \n    \n    for col in multiple_cols:\n        # \u56de\u7b54\u6570\n        new_col = col + '_answercount'\n        df_all[new_col] = df_all[col].apply(lambda x: len(re.split('\\s*;\\s*' , x)))\n        \n    for col in multiple_cols:\n        # \u30a8\u30f3\u30b3\u30fc\u30c9\n        new_col = col + '_multiple_encoded'\n\n        unique_values = defaultdict(int)\n        for row in df_all[col]:\n            vs = re.split('\\s*;\\s*', row)\n            for v in vs:\n                unique_values[v] += 1\n        score_map = {}\n        val = 1\n        for k in sorted(unique_values.keys(), key=lambda k: unique_values[k]):\n            score_map[k] = val\n            val *= 2\n        def to_score(record):\n            vs = re.split('\\s*;\\s*', record)\n            score = 0\n            for v in vs:\n                if v in score_map:\n                    score += score_map[v]\n            return score\n        df_all[new_col] = df_all[col].apply(to_score)\n    return df_all","41303acc":"def encode_missing_pattern(df_all):\n    # \u6b20\u640d\u5024\u306e\u5b58\u5728\u3059\u308b\u5217\u306e\u30d5\u30e9\u30b0\u3092\u4e26\u3079\u4e00\u3064\u306e2\u9032\u6570\u3068\u3057\u3066\u30a8\u30f3\u30b3\u30fc\u30c9\n    m = df_all.isnull().sum()\n    cols_with_missing = list(m[m != 0].index)\n\n    df_all['missing_pattern'] = 0\n    for col in cols_with_missing:\n        df_all['missing_pattern'] *= 2\n        df_all.loc[df_all[col].isnull(), 'missing_pattern'] += 1\n    \n    # \u30b1\u30bf\u304c\u5927\u304d\u304f\u306a\u308a\u3059\u304e\u308b\u306e\u3067\u5c0f\u3055\u304f\u3059\u308b\n    df_all['missing_pattern'] *= 1e-16\n    return df_all","c37af3f3":"def count_missing(df_all):\n    # \u6b20\u640d\u5024\u306e\u6570\u3092\u8fd4\u3059\n    df_all['missing_count'] = df_all.isnull().sum(axis=1)\n    return df_all","d39054a6":"def missing_value_impute_numbers(df_all):\n    # \u6570\u5024\u306f-1\u3067\u57cb\u3081\u308b\n    numeric_cols = []\n    for col in df_all.columns:\n        if df_all[col].dtype in ['int64', 'float64']:\n            numeric_cols.append(col)\n    numeric_cols.remove(col_target)\n\n    for col, v in df_all[numeric_cols].isnull().sum().iteritems():\n        if v == 0:\n            continue\n        # \u57cb\u3081\u305f\u3053\u3068\u3092\u8868\u3059\u30d5\u30e9\u30b0\u306f\u3064\u3051\u306a\u3044\u3002\u6b20\u640d\u30d1\u30bf\u30fc\u30f3\u306b\u6cd5\u5247\u304c\u3042\u308a\u305d\u3046\u306a\u306e\u3067\u30d1\u30bf\u30fc\u30f3\u3060\u3051\u5225\u95a2\u6570\u3067\u3082\u305f\u305b\u308b\n        #col_missing = f'{col}_missing'\n        #df_all[col_missing] = 0\n        #df_all.loc[df_all[col].isnull(), col_missing] = 1\n        df_all.loc[df_all[col].isnull(), col] = -1\n\n    return df_all","11602d38":"def missing_value_impute_categories(df_all):\n    # \u30ab\u30c6\u30b4\u30ea\u306f\u30de\u30fc\u30ab\u30fc\u3067\u57cb\u3081\u308b\n    missing_marker = '__MISSING_VALUE__'\n    categorical_cols = []\n    for col in df_all.columns:\n        if df_all[col].dtype in ['object']:\n            categorical_cols.append(col)\n\n    for col, v in df_all[categorical_cols].isnull().sum().iteritems():\n        if v == 0:\n            continue\n        df_all.loc[df_all[col].isnull(), col] = missing_marker\n\n    return df_all","71b0c712":"def encode_categorical_features(df_all):\n    categorical_cols = []\n    for col in df_all.columns:\n        if df_all[col].dtype in ['object']:\n            categorical_cols.append(col)\n        \n    for col in categorical_cols:\n        # replace cols with count encoded values\n        #new_col = f'{col}_count'\n        df_all[col] = df_all[col].map(df_all[col].value_counts())\n        \n    # grade \/ sub_grade\u306f\u7279\u5225\u6271\u3044\u3057\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u9806\u306b\u9023\u756a\u3092\u632f\u308b\n    #for f in ['grade', 'sub_grade']:\n    #    gs = sorted(df_all[f].unique())\n    #   df_all[f] = df_all[f].map({g: i for (g, i) in zip(gs, range(len(gs)))})\n    return df_all","6b562bd4":"def cv_score_lgb(X_train, y_train, params={}, n_splits=5, rounds=30, X_test=None, categorical_feature=None, seed=None, threashold=None):\n    print(f'cv_score_lgb rounds={rounds}')\n    # calc cv averaging when X_test is not None\n    \n    ## cv score (for stacking)\n    stacking_scores = pd.DataFrame({'score': np.zeros(X_train.shape[0])})\n    scores = []\n    predictions = []\n    kf = KFold(n_splits=n_splits, random_state=seed, shuffle=True)\n    #skf = StratifiedKFold(n_splits=n_splits, random_state=seed, shuffle=True)\n    for i, (train_ix, test_ix) in enumerate(tqdm(kf.split(X_train, y_train))):\n        X_t, y_t = X_train.iloc[train_ix], y_train.iloc[train_ix]\n        X_v, y_v = X_train.iloc[test_ix], y_train.iloc[test_ix]\n        clf = LGBMRegressor(n_estimators=9999, random_state=seed, **params)\n        print(f'cv_score_lgb classifier={clf}')\n        clf.fit(X_t, y_t, early_stopping_rounds=rounds, eval_metric='rmse', eval_set=[(X_v, y_v)], verbose=100)\n\n        y_pred  = clf.predict(X_v)\n        if threashold is not None:\n            y_pred = np.clip(y_pred, threashold, None)\n        # test_ix\u306f\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3067\u306f\u306a\u304f\u884c\u756a\u53f7\u306e\u30ea\u30b9\u30c8\u306a\u306e\u3067iloc\u3067\u30a2\u30af\u30bb\u30b9\n        stacking_scores.iloc[test_ix, stacking_scores.columns.get_loc('score')]= y_pred\n        # calculate RMSLE here\n        score = math.sqrt(sum((y_v - y_pred)**2) \/ (len(y_pred)))\n        scores.append(score)\n        if X_test is not None:\n            y_pred_test  = clf.predict(X_test)\n            predictions.append(y_pred_test)\n    mean = sum(scores) \/ n_splits\n    print(f'cv_score_lgb  scores={scores}, mean={mean}')\n    \n    stacking_scores = stacking_scores['score'].values\n    if X_test is not None:\n        pred = sum(predictions) \/ n_splits\n        return stacking_scores, scores, pred\n    else:\n        return stacking_scores, scores","601ea686":"df_all = load_data()","d73a9eb4":"# \u4e0a\u304c\u3089\u306a\u3044\n# df_all = remove_outliers(df_all)","37572b95":"# \u5358\u7d14\u306b\u5165\u308c\u305f\u3089\u4e0b\u304c\u3063\u305f\u304b\u3089\u30d1\u30b9\n# df_all = add_country_info(df_all)","83cf30ec":"# \u8a55\u4fa1\u6307\u6a19\u304cRMSLE\u306a\u306e\u3067\u30bf\u30fc\u30b2\u30c3\u30c8\u3092\u30ed\u30b0\u5909\u63db\u3057\u3066\u304b\u3089\u30e2\u30c7\u30ea\u30f3\u30b0\u3059\u308b\ndf_all[col_target] = np.log(df_all[col_target] + 1)","a1cbd9a0":"df_all = count_missing(df_all)\ndf_all = encode_missing_pattern(df_all)\ndf_all = missing_value_impute_numbers(df_all)\ndf_all = missing_value_impute_categories(df_all)","95b32bab":"# \u8907\u6570\u56de\u7b54\u306e\u30a8\u30f3\u30b3\u30fc\u30c9\ndf_all = encode_multiple_answers(df_all)","8291a685":"df_all = encode_categorical_features(df_all)","6669b53b":"X_train = df_all[df_all['is_train']].drop(columns=[col_target, 'is_train'])\ny_train = df_all[df_all['is_train']][col_target]\nX_test = df_all[~ (df_all['is_train'])].drop(columns=[col_target, 'is_train'])\n","0968a716":"if seed_averaging:\n    print('performing seed averaging')\n    preds = []\n    for seed in seeds:\n        stacking_scores, scores, pred = cv_score_lgb(X_train, y_train, rounds=100, X_test=X_test, seed=seed)\n        preds.append(pred)\n    pred = sum(preds) \/ len(seeds)\nelse:\n    stacking_scores, scores, pred = cv_score_lgb(X_train, y_train, rounds=100, X_test=X_test, seed=seeds[0])","88d6b56b":"submission = X_test.copy()\nsubmission = submission[['Respondent']]\nsubmission[col_target] = pred","4a06a550":"# log\u306e\u9006\u5909\u63db\nsubmission[col_target] = np.exp(submission[col_target]) - 1","6883a1ca":"# \u4e38\u3081(\u7e70\u308a\u4e0a\u3052)\nsubmission[col_target] = submission[col_target].apply(math.ceil)\n# \u4e38\u3081(\u56db\u6368\u4e94\u5165)\n#submission[col_target] = submission[col_target].apply(round)\n","49dd2764":"# \u6975\u7aef\u306b\u5c0f\u3055\u306a\u4e88\u6e2c\u5024\u3092\u4fdd\u5b88\u7684\u306b\u3059\u308b\nthreashold = math.e ** 0.2 \nsubmission.loc[submission[col_target] < threashold, col_target] = threashold","5b8f5e22":"submission.to_csv('submission.csv', index=False)","9a0dfcf6":"## \u95a2\u6570\u5b9a\u7fa9","1103ae83":"## \u524d\u51e6\u7406","39f8ccda":" * \u3084\u3063\u305f\u3053\u3068\n   * \u30bf\u30fc\u30b2\u30c3\u30c8\u3092log\u5909\u63db\u3057\u3066\u304b\u3089\u5b66\u7fd2\n   * \u6b20\u640d\u5024\n     * \u6570\u5024\u306f-1\u3067\u88dc\u9593\n     * \u6b20\u640d\u5024\u6570\u3092\u8ffd\u52a0\n     * \u6b20\u640d\u5024\u306e\u767b\u5834\u30d1\u30bf\u30fc\u30f3\u30922\u9032\u6570\u3067\u30a8\u30f3\u30b3\u30fc\u30c9\n   * \u30ab\u30c6\u30b4\u30ea\u5909\u6570\u306e\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\n     * \u30bb\u30df\u30b3\u30ed\u30f3\u3067\u533a\u5207\u3089\u308c\u305f\u8907\u6570\u56de\u7b54\u306e3\u30ab\u30e9\u30e0\u305d\u308c\u305e\u308c\u306b\u300c\u56de\u7b54\u6570\u300d\u3001\u300c\u767b\u5834\u30d1\u30bf\u30fc\u30f3\u306e2\u9032\u6570\u30a8\u30f3\u30b3\u30fc\u30c9\u300d\u3092\u8ffd\u52a0\n     * \u305d\u308c\u4ee5\u5916\u306fcount encoding\n   * \u30e2\u30c7\u30ea\u30f3\u30b0\n     * LightGBM\u3067CV averaging + seed averaging\n   * \u5f8c\u51e6\u7406\n     * \u6975\u7aef\u306b\u5c0f\u3055\u306a\u4e88\u6e2c\u5024\u306f\u3042\u308b\u7a0b\u5ea6\u306e\u6b63\u306e\u6570\u306b\u7f6e\u304d\u63db\u3048(\u4e0b\u632f\u308c\u306e\u30da\u30ca\u30eb\u30c6\u30a3\u3092\u907f\u3051\u3066\u4fdd\u5b88\u7684\u306b\u4e88\u6e2c)\n","0c9fad62":"## \u30e2\u30c7\u30ea\u30f3\u30b0"}}