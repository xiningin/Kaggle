{"cell_type":{"1b26c36e":"code","60918a8a":"code","835a5e2a":"code","470c9e8d":"code","edafca54":"code","d918a921":"code","d4e4b016":"code","913a46cf":"code","f4f673d5":"code","18398763":"markdown","e30618dd":"markdown","e3763502":"markdown"},"source":{"1b26c36e":"import os\nimport gc\nimport string\nimport re\nfrom tqdm import tqdm\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom scipy.sparse import csr_matrix\n\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.model_selection import GroupKFold\n\nimport nltk","60918a8a":"### CONFIGURATION ###\ncfg ={'text':{'how': 'tfidf',\n              'threshold': 0.6,\n              'binary': True}\n     }","835a5e2a":"### CONTROL ###\nDEBUG = False\nINFERENCE = False\n\n### CONSTANTS ###\nSEED = 157\n\n### PATHS ###\nTRAIN = '..\/input\/shopee-product-matching\/train.csv'\nTEST = '..\/input\/shopee-product-matching\/test.csv'\nSUB = '..\/input\/shopee-product-matching\/sample_submission.csv'\n\nIMG_TRAIN = '..\/input\/shopee-product-matching\/train_images'\nIMG_TEST = '..\/input\/shopee-product-matching\/test_images'\n\n### SUB-FUNCTIONS ###\ndef get_df():\n    df = pd.read_csv(TEST if INFERENCE else TRAIN)\n    \n    IMG_PATH = IMG_TEST if INFERENCE else IMG_TRAIN\n    df['img_path'] = IMG_PATH + '\/' + df['image']\n    \n    return df\n\ndef vectorize_text(text, how='tfidf'):\n    vec = TfidfVectorizer(stop_words='english', max_features=25_000,\n                          binary=cfg['text']['binary']) if how=='tfidf' else CountVectorizer(stop_words='english')\n    text_vec = vec.fit_transform(text)\n    return text_vec.toarray()\n    \ndef f1_score(y_true, y_pred):\n    y_true = y_true.apply(lambda x: set(x.split()))\n    y_pred = y_pred.apply(lambda x: set(x.split()))\n    intersection = np.array([len(x[0] & x[1]) for x in zip(y_true, y_pred)])\n    len_y_pred = y_pred.apply(lambda x: len(x)).values\n    len_y_true = y_true.apply(lambda x: len(x)).values\n    f1 = 2 * intersection \/ (len_y_pred + len_y_true)\n    return f1","470c9e8d":"### FUNCTIION TO BE IMPLEMENTED ###\ndef preprocess_text(text, flg_stemm=False, flg_lemm=True):\n\n    lst_stopwords = nltk.corpus.stopwords.words(\"english\")\n    \n    ## clean (convert to lowercase and remove punctuations and characters and then strip)\n    text = re.sub(r'[^\\w\\s]', '', str(text).lower().strip())\n            \n    ## Tokenize (convert from string to list)\n    lst_text = text.split()\n    ## remove Stopwords\n    if lst_stopwords is not None:\n        lst_text = [word for word in lst_text if word not in \n                    lst_stopwords]\n                \n    ## Stemming (remove -ing, -ly, ...)\n    if flg_stemm == True:\n        ps = nltk.stem.porter.PorterStemmer()\n        lst_text = [ps.stem(word) for word in lst_text]\n                \n    ## Lemmatisation (convert the word into root word)\n    if flg_lemm == True:\n        lem = nltk.stem.wordnet.WordNetLemmatizer()    \n        lst_text = [lem.lemmatize(word) for word in lst_text]\n            \n    ## back to string from list\n    text = \" \".join(lst_text)\n    return text","edafca54":"class TextClassify():\n    \n    def __init__(self, df):\n        self.df = df\n        self.df['matches'] = self.df['posting_id']\n        \n        self.X_train = vectorize_text(self.df['title'])\n    \n    def find_similar_titles(self, threshold_cosine=0.7, use_csr=True):\n        X_csr = csr_matrix(self.X_train) if use_csr else self.X_train # <- CSR or not\n        \n        num_rows = X_csr.shape[0]\n        \n        chunk = 1024 * 4\n        chunks = num_rows \/\/ chunk\n        \n        for chunk_start in range(chunks+1):\n            row_start = chunk_start * chunk\n            row_end = min((chunk_start+1) * chunk, X_csr.shape[0])\n            print('chunk: ', row_start, '-> ', row_end)\n\n            X_csr_T = X_csr[row_start: row_end].transpose() \n            cos_sim = (X_csr * X_csr_T).transpose() if use_csr else np.dot(X_csr, X_csr_T).transpose()\n            if use_csr:\n                cos_sim = cos_sim.toarray() > threshold_cosine\n            else:\n                cos_sim = cos_sim > threshold_cosine\n        \n            for i, row_num in enumerate(range(row_start, row_end)):\n                idx = cos_sim[i]\n                matches = self.df.loc[idx, 'posting_id'].to_list()\n                self.df.loc[row_num, 'matches'] = ' '.join(matches) ","d918a921":"### GET DATAFRAME ###\ndf = get_df()\ndf['title'] = df['title'].apply(preprocess_text)\n\nif DEBUG:\n    gkf = GroupKFold(n_splits=10)\n    for train_idx, val_idx in gkf.split(df['posting_id'], df['label_group'], groups=df['label_group']):\n        df = df.iloc[val_idx].reset_index(drop=True)\n        break","d4e4b016":"def main_cos_infer(df, threshold, use_csr=True):\n    model = TextClassify(df)\n    model.find_similar_titles(threshold_cosine=threshold, use_csr=use_csr)","913a46cf":"%%time\nmain_cos_infer(df, threshold=cfg['text']['threshold'], use_csr=True)","f4f673d5":"%%time\nmain_cos_infer(df, threshold=cfg['text']['threshold'], use_csr=False)","18398763":"## Using numpy matrix","e30618dd":"## Using csr_matrix","e3763502":"# Summary\n\nWhen you use thr CSR matrix for calculating the cosine similarity, you can get the results by ~ x10 faster compared to numpy matrix.\n- CSR (from scipy): around 2min\n- Numpy: around 15min"}}