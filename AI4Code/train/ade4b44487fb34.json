{"cell_type":{"c026e7d8":"code","ee956728":"code","00e2fc68":"code","ec802f2b":"code","9a39056c":"code","1c84bfbc":"code","e390ea27":"code","2e237fb0":"code","40bbf82a":"code","1d3e06de":"code","efbf390f":"code","0cf530f6":"code","1f1bfc6c":"code","f3f87643":"code","f94c22a1":"code","d5eaff6e":"code","b07967ac":"code","1b25f106":"code","ec513a65":"code","d3315e20":"code","5d0a4a5f":"code","bc634077":"code","bad53bef":"code","360a2698":"code","3f2091be":"code","163b1432":"markdown","7d1c5cd0":"markdown","229932da":"markdown","da04fe49":"markdown","805d8989":"markdown","5865ae86":"markdown","4de4bec8":"markdown","c50fe372":"markdown","5796ef88":"markdown","10057e4a":"markdown","b8c62dfc":"markdown","84696898":"markdown","4387fa67":"markdown","779a2640":"markdown","33201dbc":"markdown","96eec956":"markdown"},"source":{"c026e7d8":"# import basics\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport os\nfrom glob import glob\n\n# import plotting\nfrom matplotlib import pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib\nimport seaborn as sns\n\n# import image manipulation\nfrom PIL import Image\nimport imageio","ee956728":"# set paths to train and test image datasets\nTRAIN_PATH = '..\/input\/severstal-steel-defect-detection\/train_images\/'\nTEST_PATH = '..\/input\/severstal-steel-defect-detection\/test_images\/'\n\n# load dataframe with train labels\ntrain_df = pd.read_csv('..\/input\/severstal-steel-defect-detection\/train.csv')\n\n# load my predictions\nresults_df = pd.read_csv('..\/input\/steelsubmission\/test_masks.csv')","00e2fc68":"train_df.head(3)","ec802f2b":"results_df.head(3)","9a39056c":"def preprocess_df(df):\n    '''\n    Function for train dataframe preprocessing.\n    Creates additional columns 'Image' with image filename and 'Label' with label number.\n    '''\n    # split column\n    split_df = df[\"ImageId_ClassId\"].str.split(\"_\", n = 1, expand = True)\n    new_df = df.copy()\n\n    # add new columns to train_df\n    new_df['Image'] = split_df[0]\n    new_df['Label'] = split_df[1]\n\n    # check the result\n    return new_df","1c84bfbc":"train_df = preprocess_df(train_df)\nresults_df = preprocess_df(results_df)","e390ea27":"# https:\/\/www.kaggle.com\/titericz\/building-and-visualizing-masks\ndef rle2maskResize(rle):\n    # CONVERT RLE TO MASK \n    if (pd.isnull(rle))|(rle=='')|(rle=='-1'): \n        return np.zeros((256,1600) ,dtype=np.uint8)\n    \n    height= 256\n    width = 1600\n    mask= np.zeros( width*height ,dtype=np.uint8)\n\n    array = np.asarray([int(x) for x in rle.split()])\n    starts = array[0::2]-1\n    lengths = array[1::2]    \n    for index, start in enumerate(starts):\n        mask[int(start):int(start+lengths[index])] = 1\n    \n    return mask.reshape( (height,width), order='F' )","2e237fb0":"def compute_iou(target, prediction):\n    '''\n    Function to compute IOU metric\n    See:\n    https:\/\/www.jeremyjordan.me\/evaluating-image-segmentation-models\/\n    '''\n    target = np.asarray(target, dtype=float)\n    prediction = np.asarray(prediction, dtype=float)\n    \n    smooth = 1e-5 # smoothing for empty masks\n    \n    intersection = np.logical_and(target, prediction)\n    union = np.logical_or(target, prediction)\n    iou_score = np.sum(intersection) \/ (np.sum(union) + smooth)\n    \n    return iou_score","40bbf82a":"def plot_mask(image_filename):\n    '''\n    Function to plot an image and true\/predicted segmentation masks.\n    INPUT:\n        image_filename - filename of the image (with full path)\n    '''\n    img_id = image_filename.split('\/')[-1]\n    image = Image.open(image_filename)\n    train = train_df.fillna('-1')\n    pred = results_df.fillna('-1')\n    \n    rle_masks = train[(train['Image'] == img_id)]['EncodedPixels'].values    \n    pred_masks = pred[(pred['Image'] == img_id)]['EncodedPixels'].values\n    \n    fig, axs = plt.subplots(4, 2, figsize=(20, 7))\n    \n    iou = 0\n    for defect in range(1,5):\n        rle_mask = rle_masks[defect - 1]\n        pred_mask = pred_masks[defect - 1]\n        np_mask = 0\n        np_mask_pred = 0\n        \n        if rle_mask != '-1':\n            np_mask = rle2maskResize(rle_mask)\n            axs[defect - 1, 0].imshow(image)\n            axs[defect - 1, 0].imshow(np_mask, alpha = 0.5, cmap = \"Reds\")\n            axs[defect - 1, 0].axis('off')\n            axs[defect - 1, 0].set_title('Mask with defect #{}'.format(defect))\n        else:\n            axs[defect - 1, 0].imshow(image)\n            axs[defect - 1, 0].axis('off')\n            axs[defect - 1, 0].set_title('No defects type #{}'.format(defect))\n            \n        if pred_mask != '-1':\n            np_mask_pred = rle2maskResize(pred_mask)\n            axs[defect - 1, 1].imshow(image)\n            axs[defect - 1, 1].imshow(np_mask_pred, alpha = 0.5, cmap = \"Reds\")\n            axs[defect - 1, 1].axis('off')\n            axs[defect - 1, 1].set_title('Prediction for mask with defect #{}'.format(defect))\n        else:\n            axs[defect - 1, 1].imshow(image)\n            axs[defect - 1, 1].axis('off')\n            axs[defect - 1, 1].set_title('No prediction for defects type #{}'.format(defect))\n\n        # calculate average IOU for all defects\n        iou += compute_iou(np_mask, np_mask_pred)\n        \n    plt.suptitle('IOU for image: {:.2f}'.format(iou), fontsize = 16)\n        \n    plt.show()","1d3e06de":"plot_mask(TRAIN_PATH + '0002cc93b.jpg')","efbf390f":"plot_mask(TRAIN_PATH + '0007a71bf.jpg')","0cf530f6":"def plot_mask_by_id(idx):\n    '''\n    Plots true mask and predicted mask by id in train_df\n    '''\n    image_name = train_df.iloc[idx]['Image']\n    image_filename = TRAIN_PATH + image_name\n    image = Image.open(image_filename)\n    \n    rle_mask = train_df.iloc[idx]['EncodedPixels']\n    pred_mask = results_df.iloc[idx]['EncodedPixels']\n    \n    defect = train_df.iloc[idx]['Label']\n    \n    true = rle2maskResize(rle_mask)\n    pred = rle2maskResize(pred_mask)\n    \n    fig, axs = plt.subplots(1, 2, figsize=(20, 3.5))\n    \n    iou = compute_iou(true, pred)\n    \n    axs[0].imshow(image)\n    axs[0].imshow(true, alpha = 0.5, cmap = \"Reds\")\n    axs[0].axis('off')\n    axs[0].set_title('Mask with defect #{}'.format(defect))\n    \n    axs[1].imshow(image)\n    axs[1].imshow(pred, alpha = 0.5, cmap = \"Reds\")\n    axs[1].axis('off')\n    axs[1].set_title('Predicted mask for defect #{}'.format(defect))\n    \n    plt.suptitle('IOU for image: {:.2f}'.format(iou), fontsize = 16)\n    \n    plt.show()","1f1bfc6c":"plot_mask_by_id(27)","f3f87643":"from scipy.ndimage import label, generate_binary_structure\n\ndef get_mask(line_id):\n    '''\n    Function to visualize the image and the mask.\n    INPUT:\n        line_id - id of the line to visualize the masks\n    RETURNS:\n        np_mask - numpy segmentation map\n    '''\n    \n    # convert rle to mask\n    rle = train_df.loc[line_id]['EncodedPixels']\n    \n    np_mask = rle2maskResize(rle)\n    np_mask = np.clip(np_mask, 0, 1)\n        \n    return np_mask\n\ndef add_mask_areas(train_df):\n    '''\n    Helper function to add mask area as a new column to the dataframe\n    INPUT:\n        train_df - dataset with training labels\n    '''\n    masks_df = train_df.copy()\n    masks_df['Area'] = 0\n        \n    for i, row in masks_df.iterrows():\n        masks_df['Area'].loc[i] = np.sum(get_mask(i))\n    \n    return masks_df\n\ndef add_mask_number(train_df):\n    '''\n    Helper function to add mask area as a new column to the dataframe\n    INPUT:\n        train_df - dataset with training labels\n    '''\n    masks_df = train_df.copy()\n    masks_df['NumMasks'] = 0\n    \n    s = generate_binary_structure(2,2)\n        \n    for i, row in masks_df.iterrows():\n        mask = get_mask(i)\n        \n        if np.sum(mask) > 0:\n            labeled_array, labels = label(mask, structure=s)\n            masks_df['NumMasks'].loc[i] = labels\n        else:\n            masks_df['NumMasks'].loc[i] = 0\n    \n    return masks_df","f94c22a1":"masks_df = add_mask_number(train_df)","d5eaff6e":"many_masks_df = masks_df[masks_df['NumMasks'] > 10]\nline_ids = many_masks_df.index.values","b07967ac":"rnd_idx = line_ids[np.random.randint(len(line_ids))]\nplot_mask_by_id(rnd_idx)","1b25f106":"rnd_idx = line_ids[np.random.randint(len(line_ids))]\nplot_mask_by_id(rnd_idx)","ec513a65":"rnd_idx = line_ids[np.random.randint(len(line_ids))]\nplot_mask_by_id(rnd_idx)","d3315e20":"masks_df = add_mask_areas(masks_df)","5d0a4a5f":"# filter the dataframe, so we have only images with very large masks\nlarge_masks_df = masks_df[masks_df['Area'] > 200000]\nline_ids = large_masks_df.index.values","bc634077":"rnd_idx = line_ids[np.random.randint(len(line_ids))]\nplot_mask_by_id(rnd_idx)","bad53bef":"rnd_idx = line_ids[np.random.randint(len(line_ids))]\nplot_mask_by_id(rnd_idx)","360a2698":"rnd_idx = line_ids[np.random.randint(len(line_ids))]\nplot_mask_by_id(rnd_idx)","3f2091be":"rnd_idx = line_ids[np.random.randint(len(line_ids))]\nplot_mask_by_id(rnd_idx)","163b1432":"To my mind, the ground truth itself is controversial for large masks: somewhere the defects are cropped out accurately, somewhere there is a lot of empty space between the defects. That is why it is hard to achieve good performance on such images.","7d1c5cd0":"Visualizations above tell me that the thresholds for the defects should be tuned (I created my submission with a standard threshold equal to 0.5): the model doesn't identify the minor defects of different types.","229932da":"## Conclusion\n\nThe visualization of predicted masks can tell a lot. In my case, it tells me that my model certainly fails to find small defects of different types. The most probably, I should tune the thresholds or add some morphological postprocessing of the resulting masks.","da04fe49":"`3.` Plot predicted masks for cases with a large mask:","805d8989":"## Load Data and Setup","5865ae86":"This prediction is not that bad: the IOU is 0.7! But model still didn't catch a minor defect. Threshold for this type of defect certainly needs to be tuned.","4de4bec8":"`1.` A generic function to compare true and predicted masks for each defect:","c50fe372":"`2.` Plot true and predicted mask just by row index:","5796ef88":"Only few days a left for this competition. it is time to __finetune__ the models! One of the ways to finetune a model is to analyze the predictions made by this model.\n\nIn this notebook I used a csv file, which contains masks predicted by my model for the images from the train set (in `submission.csv` format). I created several helper functions, which you may use to analyze your predictions.","10057e4a":"# The Analysis of the Model Output","b8c62dfc":"Preprocess the dataframes (add dedicated columns for Image filename and Label):","84696898":"## Visualize Predictions:","4387fa67":"Setup path to the training set and load the dataframes with labels and predictions:","779a2640":"## References:\n1. Kernel with [function to convert RLE to mask](https:\/\/www.kaggle.com\/titericz\/building-and-visualizing-masks)\n2. Article with [calculation of IOU](https:\/\/www.jeremyjordan.me\/evaluating-image-segmentation-models\/)","33201dbc":"`3.` Plot predicted masks for cases with many masks on single image:","96eec956":"Setup the utilities:"}}