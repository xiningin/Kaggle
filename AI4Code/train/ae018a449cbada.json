{"cell_type":{"46827138":"code","d6274981":"code","2d4f9aac":"code","01db05fe":"code","846be03c":"code","fd3e02f7":"code","e56c41e5":"code","377b2f62":"code","60aeb36a":"code","51c6a731":"code","20010f3e":"code","94f22b47":"code","9618eff3":"code","8edf15ec":"code","179ab6eb":"code","568245fc":"code","37e21bb8":"markdown","358a5093":"markdown","73903b6c":"markdown","a0b2dc2d":"markdown","07424d88":"markdown","a0a34686":"markdown","e072e54c":"markdown","e04b36e3":"markdown","9046ba89":"markdown","948f9c4e":"markdown","9370ea5f":"markdown","cdc43dab":"markdown","40fa002d":"markdown"},"source":{"46827138":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport random\nimport numpy as np\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nimport math\nimport pandas as pd\nfrom sympy import isprime\nfrom multiprocessing import Pool\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","d6274981":"df_cities = pd.read_csv('..\/input\/cities.csv')\ndf_cities.head()","2d4f9aac":"fig = plt.figure(figsize=(10,10))\n#cmap, norm = from_levels_and_colors([0.0, 0.5, 1.5], ['red', 'black'])\nplt.scatter(df_cities['X'],df_cities['Y'],marker = '.',\n            c=(df_cities.CityId != 0).astype(int), cmap='Set1', \n            alpha = 0.6, s = 500*(df_cities.CityId == 0).astype(int)+1)\nplt.show()","01db05fe":"# The function to get the distance between the cities.\ndef distance(x1, y1, x2, y2, prev_is_prime, is_10th):\n    # Every 10th step is 10% more lengthy unless coming from a prime CityId.\n    cost_factor = 1.1 if is_10th and not prev_is_prime else 1.0\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) * cost_factor\n\n# The function to calculate score.\n\ndef calculate_score(path, cities_df_dict):\n    # The beginning and end of the paths must be City'0'.\n    paths = [0]\n    paths.extend(path)\n    paths.extend([0])\n\n    sum_distance = 0\n    prev_x, prev_y = cities_df_dict['X'][0], cities_df_dict['Y'][0]\n    prev_is_prime = False\n\n    for i, city in enumerate(paths):\n        x, y = cities_df_dict['X'][city], cities_df_dict['Y'][city]\n        is_prime = cities_df_dict['IsPrime'][city]\n\n        sum_distance += distance(prev_x, prev_y, x, y, prev_is_prime, i % 10 == 0)\n        prev_x, prev_y = x, y\n        prev_is_prime = is_prime\n\n    return sum_distance","846be03c":"df_cities['IsPrime'] = df_cities.CityId.apply(isprime)\ncities_df_dict       = df_cities.to_dict()\n\ndf_cities.head(4)","fd3e02f7":"%%time\n# test time in calc\nsample_path = df_cities.CityId[:].values[1:]\nfor i in range(100):\n    score = calculate_score(sample_path, cities_df_dict)","e56c41e5":"# start and end in the nort (0)\npath  = df_cities.CityId[:].values[1:]\nscore = calculate_score(path, cities_df_dict)\nprint('Total distance with the dumbest path is '+ \"{:,}\".format(score))\n#446884407.52","377b2f62":"dumbest_path = path\n\ndef plot_sample_path(path):\n    df_path = pd.merge_ordered(pd.DataFrame({'CityId':path}),df_cities,on=['CityId'])\n    fig, ax = plt.subplots(figsize=(10,10))\n    ax.plot(df_path.iloc[0:100,]['X'], df_path.iloc[0:100,]['Y'],marker = 'o')\n    for i, txt in enumerate(df_path.iloc[0:100,]['CityId']):\n        ax.annotate(txt, (df_path.iloc[0:100,]['X'][i], df_path.iloc[0:100,]['Y'][i]),size = 15)\n        \nplot_sample_path(dumbest_path)","60aeb36a":"df_cities.head(2)","51c6a731":"print(\"All cities: \", df_cities.shape)\nprint(\"Prime cities: \", df_cities[df_cities.IsPrime].shape)","20010f3e":"\"\"\"Genetic Algorithmn Implementation\nsee:\nhttp:\/\/www.obitko.com\/tutorials\/genetic-algorithms\/ga-basic-description.php\n\"\"\"\nclass GeneticAlgorithm(object):\n    def __init__(self, genetics):\n        self.genetics       = genetics\n        self.best_solution  = None\n        self.avg_fitness    = []\n        pass\n\n    def fitness(self, ch):\n        return (self.genetics.fitness(ch),  ch)\n    \n    def run(self, processes=4):\n        population = self.genetics.initial()\n        pool       = Pool(processes=processes)\n        \n        while True:\n            fits_pops = [self.fitness(ch) for ch in population]\n            fits_pops = list(sorted(fits_pops))\n            #fits_pops   = pool.map(self.fitness, population)\n\n            # Log\n            self.avg_fitness.append(np.mean([f for f, ch in fits_pops]))\n            self.best_solution = fits_pops[0][1]\n            \n            if self.genetics.check_stop(fits_pops): \n                break\n            \n            population = self.next(fits_pops)\n            pass\n        return population\n\n    def next(self, fits):\n        parents_generator = self.genetics.parents(fits)\n        size  = len(fits)\n        nexts = [self.best_solution.copy()]\n        while len(nexts) < size:\n            parents  = next(parents_generator)\n            cross    = random.random() < self.genetics.probability_crossover()\n            children = self.genetics.crossover(parents) if cross else parents\n\n            for ch in children:\n                mutate = random.random() < self.genetics.probability_mutation()\n                nexts.append(self.genetics.mutation(ch) if mutate else ch)\n                pass\n            pass\n        return nexts[0:size]\n    pass","94f22b47":"\nclass TravelingSanta():\n    def __init__(self, df_cities, generation=10, size=5,\n                 prob_crossover=0.9, \n                 prob_mutation=0.2):\n        self.df_cities  = df_cities\n        \n        self.counter   = 0\n        \n        self.generation = generation\n        self.size  = size        \n        self.prob_crossover = prob_crossover\n        self.prob_mutation  = prob_mutation\n        self.cities_df_dict = df_cities.to_dict()\n\n    # GeneticFunctions interface impls\n    def probability_crossover(self):\n        return self.prob_crossover\n\n    def probability_mutation(self):\n        return self.prob_mutation\n\n    # Initial population based in s0\n    def initial(self):\n        population = [self.random_chromo() for j in range(self.size)]\n        return population\n\n    def fitness(self, chromo):\n        score = calculate_score(chromo, self.cities_df_dict)\n        \n        return score\n\n    def check_stop(self, fits_populations):\n        self.counter += 1\n        \n        if self.counter % 2 == 0:\n\n            fits  = [f for f, ch in fits_populations]\n            best  = min(fits)\n            worst = max(fits)\n            ave   = sum(fits) \/ len(fits)\n            print(\n                \"[G %3d] score=(%2f, %2f, %2f, %2f): %r\" %\n                (self.counter, best, ave, worst, len(fits), []))\n            pass\n\n        return self.counter >= self.generation\n\n    def parents(self, fits_populations):\n        while True:\n            father = self.tournament(fits_populations)\n            mother = self.tournament(fits_populations)\n            yield (father, mother)\n            pass\n        pass\n\n    def crossover(self, parents):\n        ind1, ind2 = parents\n        \n        size = min(len(ind1), len(ind2))\n        a, b = random.sample(range(size), 2)\n        if a > b:\n            a, b = b, a\n\n        holes1, holes2 = [True]*size, [True]*size\n        for i in range(size):\n            if i < a or i > b:\n                holes1[ind2[i]-1] = False\n                holes2[ind1[i]-1] = False\n\n        # We must keep the original values somewhere before scrambling everything\n        temp1, temp2 = ind1, ind2\n        k1 , k2 = b + 1, b + 1\n        for i in range(size):\n            if not holes1[temp1[(i + b + 1) % size]-1]:\n                ind1[k1 % size] = temp1[(i + b + 1) % size]\n                k1 += 1\n\n            if not holes2[temp2[(i + b + 1) % size]-1]:\n                ind2[k2 % size] = temp2[(i + b + 1) % size]\n                k2 += 1\n\n        # Swap the content between a and b (included)\n        for i in range(a, b + 1):\n            ind1[i], ind2[i] = ind2[i], ind1[i]\n\n        return ind1, ind2\n\n    def mutation(self, chromosome):\n        mutated = chromosome\n        \n        for i in range(int(len(chromosome)*0.05)):\n            i1 = random.randint(0, len(chromosome)-1)\n            i2 = random.randint(0, len(chromosome)-1)\n        \n            origin       = mutated[i1]\n            mutated[i1]  = mutated[i2]\n            mutated[i2]  = origin\n\n        return mutated\n\n    def tournament(self, fits_populations):\n        alicef, alice = self.select_random(fits_populations)\n        bobf, bob = self.select_random(fits_populations)\n        return alice if alicef < bobf else bob\n\n    def select_random(self, fits_populations):\n        return fits_populations[random.randint(0, len(fits_populations)-1)]\n\n    def random_chromo(self):\n        chromo = list(df_cities.CityId.sample(frac=1).values)\n        return chromo\n    pass","9618eff3":"%%time\n\ngeneration      = 100\npopulation_size = 100\nprob_crossover  = 0.9\nprob_mutation   = 0.2\n\nga = GeneticAlgorithm(\n    TravelingSanta(df_cities, generation=generation, size=population_size, \n                   prob_crossover=prob_crossover, prob_mutation=prob_mutation)\n)\n\nbest_solution = ga.run()","8edf15ec":"fig, ax = plt.subplots(figsize=(10,6))\nax.plot(ga.avg_fitness)","179ab6eb":"calculate_score(ga.best_solution, cities_df_dict)","568245fc":"# Sample calculation\npath       = [0] + ga.best_solution + [0]\nsubmission = pd.DataFrame({\"Path\": path})\nsubmission.to_csv(\"submission.csv\", index=None)","37e21bb8":"## Genetic Algorithm\n\nBasic Description\nGenetic algorithms are inspired by Darwin's theory about evolution. Solution to a problem solved by genetic algorithms is evolved.\n\nAlgorithm is started with a set of solutions (represented by chromosomes) called population. Solutions from one population are taken and used to form a new population. This is motivated by a hope, that the new population will be better than the old one. Solutions which are selected to form new solutions (offspring) are selected according to their fitness - the more suitable they are the more chances they have to reproduce.\n\nOutline of the Basic Genetic Algorithm\n* **[Start]** Generate random population of n chromosomes (suitable solutions for the problem)\n* **[Fitness]** Evaluate the fitness f(x) of each chromosome x in the population\n    * **[New population]** Create a new population by repeating following steps until the new population is complete\n    * **[Selection]** Select two parent chromosomes from a population according to their fitness (the better fitness, the bigger chance to be selected)\n    * **[Crossover]** With a crossover probability cross over the parents to form a new offspring (children). If no crossover was performed, offspring is an exact copy of parents.\n    * **[Mutation]** With a mutation probability mutate new offspring at each locus (position in chromosome).\n    * [Accepting] Place new offspring in a new population\n* **[Replace]** Use new generated population for a further run of algorithm\n* **[Test]** If the end condition is satisfied, stop, and return the best solution in current population\n* **[Loop]** Go to step 2\n\nhttp:\/\/www.obitko.com\/tutorials\/genetic-algorithms\/ga-basic-description.php\n","358a5093":"## Dumbest Path: Go in the order of CityIDs: 0, 1, 2.. etc. and come back to zero when you reach the end. \n\nPer the problem: **\"submission is scored on the Euclidean distance of your submitted path, subject to the constraint that every 10th step is 10% more lengthy unless coming from a prime CityId.\"**\n\nTo see how good this path is, we need a couple of functions: \n1. A function to tell if a number is a prime\n2. Another funtion to compute the total distance given a series of numbers","73903b6c":"### In this kernel we try to get a basic understanding of the problem and explore a few simple solutions to see a how they differ. \n\nIn case you haven't already figured it out, this is a version of the [\"Traveling Salesman Problem\"](https:\/\/en.wikipedia.org\/wiki\/Travelling_salesman_problem). May be the winning solution is going to be one of the very advanced approaches to that problem. But let us not get scared by an NP-Complete problem. We will start with some simple dumb approaches first and see where they lead us. \n","a0b2dc2d":"## Dumbest Path\n\nThe same order path","07424d88":"### Submission","a0a34686":"### Taking a cue from the other kernels, let us first do a scatter plot of the locations of all the cities. \n* There is a surpise waiting in the locations of the cities :)","e072e54c":"### Compute GA  ","e04b36e3":"Let us first load the file and look at the data. ","9046ba89":"### As we can see, the dumbest path seems pretty bad. We are sending Santa all over the map, without any consideration for him whatsoever :)","948f9c4e":"#### Genetic Algorithms: The Travelling Salesman Problem\n\nhttps:\/\/medium.com\/@becmjo\/genetic-algorithms-and-the-travelling-salesman-problem-d10d1daf96a1","9370ea5f":"continue....","cdc43dab":"### Let us take a look at the first 100 steps of the dumbest path","40fa002d":"**So it looks like the cities are arranged in a reindeer pattern**. \n* The red dot indicates the North Pole (CityId = 0). \n* All we have to a do a is a find a path that goes from the red dot, touches all the other dots, and comes back to the red-dot, with minimum total distance travelled !"}}