{"cell_type":{"04ff6073":"code","d6d0846d":"code","372b08ae":"code","7cebabb3":"code","36572575":"code","baa6b140":"code","2ea93da9":"code","ef1a3b88":"code","5696ef9d":"code","579e35aa":"code","af7af9e6":"code","440978e4":"code","3eaa63e6":"code","41052246":"code","c6f23125":"code","8a0f4b17":"code","c5b7f0fb":"code","97b86aca":"code","d4cf8018":"code","0753cef2":"code","810b8a53":"code","d6ebf047":"code","44c47c6f":"code","0f445677":"code","c66dda89":"markdown","0e8bb056":"markdown","2e78b1fb":"markdown","50b25964":"markdown","090e8338":"markdown"},"source":{"04ff6073":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\nimport matplotlib.patches as patches\n\n# Any results you write to the current directory are saved as output.","d6d0846d":"thin_rate = 10\n\ndata = pd.read_csv('..\/input\/train.csv',  dtype={'acoustic_data': np.int16 ,'time_to_failure': np.float32})\ndata = data[::thin_rate]","372b08ae":"delta_time = ((data.time_to_failure[0]-data.time_to_failure[5000000])\/5000000)*thin_rate\ndelta_time","7cebabb3":"acoustic_data_per_100 = data.acoustic_data[::10]\ntime_to_failure_per_100 = data.time_to_failure[::10]\n\n\nfig, ax1 = plt.subplots(figsize=(20, 10))\nplt.title(\"train_data\", fontsize = 30)\nax1.plot(acoustic_data_per_100, color = \"blue\")\nax1.set_xlabel(\"index\", fontsize = 20)\nax1.set_ylabel(\"acoustic_data\", color = \"blue\", fontsize = 20)\nax1.tick_params(axis=\"x\",labelsize = 10)\nax1.tick_params(axis=\"y\", labelcolor=\"blue\", labelsize = 15)\nax1.plot()\n\nax2 = ax1.twinx()\nax2.plot(time_to_failure_per_100, color = \"green\")\nax2.set_ylabel(\"time_to_failure\", color = \"green\", fontsize = 20)\nax2.tick_params(axis=\"y\", labelcolor=\"green\", labelsize = 15)\nax2.plot()\n","36572575":"data[\"rolling_std\"] = data.acoustic_data.rolling(window=1000).std()\nrolling_std_per_100 = data['rolling_std'].values[::10]\ntime_to_failure_per_100 = data.time_to_failure[::10]\nacoustic_data_per_100 = data.acoustic_data[::10]\nindex = np.arange(len(acoustic_data_per_100))\nbbox = {\n    \"facecolor\" : \"lightblue\",\n    \"edgecolor\" : \"blue\",\n    \"boxstyle\" : \"Round\",\n    \"linewidth\" : 2\n}\n\nfig, ax1 = plt.subplots(figsize=(20, 10))\nplt.title(\"comparison between the two\", fontsize = 30)\nax1.plot(index,acoustic_data_per_100, color = \"blue\")\nax1.set_xlabel(\"index\", fontsize = 20)\nax1.set_ylabel(\"acoustic_data\", color = \"blue\", fontsize = 20)\nax1.set_ylim(-3000,3000)\nax1.tick_params(axis=\"x\",labelsize = 10)\nax1.tick_params(axis=\"y\", labelcolor=\"blue\", labelsize = 15)\nax1.plot()\n\nax2 = ax1.twinx()\nax2.plot(index,rolling_std_per_100, color = \"red\")\nax2.set_ylabel(\"rolling_std\", color = \"red\", fontsize = 20)\nax2.set_ylim(-600,600)\nax2.tick_params(axis=\"y\", labelcolor=\"red\", labelsize = 15)\nax2.plot()\n\nfig, ax1 = plt.subplots(figsize=(20, 10))\nplt.title(\"cut a signal\", fontsize = 30)\nax1.plot(index,acoustic_data_per_100, color = \"blue\")\nax1.set_xlabel(\"index\", fontsize = 20)\nax1.set_ylabel(\"acoustic_data\", color = \"blue\", fontsize = 20)\nax1.plot([44200, -1000], [44200, 1000], 'k-', lw=2)\nax1.set_xlim(44000,45000)\nax1.set_ylim(-3000,3000)\nax1.tick_params(axis=\"x\",labelsize = 10)\nax1.tick_params(axis=\"y\", labelcolor=\"blue\", labelsize = 15)\nax1.plot()\n\nax2 = ax1.twinx()\nax2.plot(index,rolling_std_per_100, color = \"red\")\nax2.hlines(80, 44375, 44509, linestyle='dashed', linewidth=2)\nax2.vlines(44375, 0, 200, linestyle='dashed', linewidth=2)\nax2.vlines(44509, 0, 200, linestyle='dashed', linewidth=2)\nax2.vlines(44345, -200, 200, linestyle='solid', linewidth=2,color = \"royalblue\")\nax2.vlines(44479, -200, 200, linestyle='solid', linewidth=2,color = \"royalblue\")\nax2.text(44290,270,\"cutting line\", size = 20, color = \"red\" ,bbox = bbox)\nax2.annotate('', xy=[44345,100], xytext=[44375,100],\n            arrowprops = dict(shrink=0, width=1, headwidth=8,headlength=10, connectionstyle='arc3',facecolor='royalblue', edgecolor='royalblue')\n           )\nax2.annotate('', xy=[44479,100], xytext=[44509,100],\n            arrowprops = dict(shrink=0, width=1, headwidth=8,headlength=10, connectionstyle='arc3',facecolor='royalblue', edgecolor='royalblue')\n           )\nax2.set_ylabel(\"rolling_std\", color = \"red\", fontsize = 20)\nax2.set_ylim(-600,600)\nax2.tick_params(axis=\"y\", labelcolor=\"red\", labelsize = 15)\nax2.plot()\n\ndel rolling_std_per_100\ndel acoustic_data_per_100\ndel time_to_failure_per_100\n","baa6b140":"peak_line = 80\ni= 0\n\nstart_index = []\nend_index = []\nsample_num = []\n\nnp_std = np.asarray(data.rolling_std)\n\nfor i in range(len(data)-1):\n    if ((np_std[i] < peak_line ) & ( peak_line <= np_std[i+1])):\n        start_index.append(i)\n    if ((peak_line <= np_std[i]) & ( np_std[i+1] < peak_line )\n    &((len(start_index) -  len(end_index)) ==  1)):\n        end_index.append(i)\n\nfor i in range (len(start_index)):\n    sample_num.append(-(start_index[i] - end_index[i]))\n\ndel np_std","2ea93da9":"data = data.drop(\"rolling_std\", axis = 1)","ef1a3b88":"acoustic_table = np.stack([start_index, end_index , sample_num], axis = 1) #numpy_ndarray\n\ncolumns = [\"start_index\", \"end_index\",\"sample_num\"] #pandas_DataFrame\n\nacoustic_table = pd.DataFrame(acoustic_table , columns=columns)\nacoustic_table.start_index = acoustic_table.start_index - 300\nacoustic_table.end_index = acoustic_table.end_index - 300\n\ndel start_index\ndel end_index\ndel sample_num","5696ef9d":"plt.figure(figsize=(20, 20))\n\n\nwork = data.acoustic_data[acoustic_table.start_index[0]:acoustic_table.end_index[0]]\nplt.subplot(511)\nplt.title(\"cutted signals\", fontsize = 30)\nplt.plot(work,color = 'b')\n\nwork = data.acoustic_data[acoustic_table.start_index[10]:acoustic_table.end_index[10]]\nplt.subplot(512)\nplt.plot(work,color = 'b')\n\nwork = data.acoustic_data[acoustic_table.start_index[20]:acoustic_table.end_index[20]]\nplt.subplot(513)\nplt.plot(work,color = 'b')\n\nwork = data.acoustic_data[acoustic_table.start_index[30]:acoustic_table.end_index[30]]\nplt.subplot(514)\nplt.plot(work,color = 'b')\n\nwork = data.acoustic_data[acoustic_table.start_index[40]:acoustic_table.end_index[40]]\nplt.subplot(515)\nplt.plot(work,color = 'b')\n\ndel work","579e35aa":"f = []\nF = []\nF_abs = []\nwork = []\npi = np.pi\n\nfourier_data = []\nomega_data = []\nenergy_data = []\n\nfor i in range(len(acoustic_table)):\n\n    f = []\n    F = []\n    F_abs = []\n    omega = []\n    fourier_work = data.acoustic_data[acoustic_table.start_index[i]:acoustic_table.end_index[i]]\n    N = len(fourier_work)\n    half_N = int(N\/2 + 1)\n    delta_omega = 2*pi\/half_N\n\n    #fourier_data\n    f.append(fourier_work)\n    F.append(np.fft.fft(fourier_work)[0:half_N+1])\n    F_abs.append(np.abs(F))\n    \n    #frequency_data (omega_data)\n    omega.append(np.linspace(0, 2*pi, half_N+1))\n    \n    #energy_data\n    U = np.dot(F_abs[0], omega[0])\n\n    fourier_data.append(F_abs)\n    omega_data.append(omega)\n    energy_data.append(U)","af7af9e6":"acoustic_table[\"fourier_data\"] = fourier_data\nacoustic_table[\"omega_data\"] = omega_data\nacoustic_table[\"energy_data\"] = energy_data\n\ndel fourier_data\ndel omega_data\ndel energy_data","440978e4":"np_index = np.asarray(acoustic_table.start_index)\nnp_time = np.asarray (data.time_to_failure)\n\n#time_data\ntime_work = []\ni = 0\nfor i in range(len(acoustic_table)):\n    index_work = np_index[i]\n    time_work.append(np_time[index_work])\nacoustic_table[\"time_to_failure\"] = time_work\n\ndel time_work","3eaa63e6":"acoustic_table","41052246":"#Border is determined sorted energy data.Border is center of the two enegy data these have most wide difference.\nnp_energy_data = np.asarray(acoustic_table.energy_data)\nnp_sort_energy_data = np.sort(np_energy_data)\nnp_sort_energy_data\n\nnp_sort_energy_diffdata = np.diff(np_sort_energy_data) \n\nhigh_border_index = (np.argmax(np_sort_energy_diffdata) + 1)\nlow_border_index = (np.argmax(np_sort_energy_diffdata))\nborder_energy = (np_sort_energy_data[high_border_index] + np_sort_energy_data[low_border_index])\/2\n\n#graph plot\nx = (np.asarray(acoustic_table.time_to_failure))\ny = (np.asarray(acoustic_table.energy_data))\nr = patches.Rectangle(xy=(0, border_energy), width=0.1, height=0.5, ec='#000000', fill=False)\n\nplt.figure(figsize=(15, 8))\nplt.scatter(x = x, y = y)\nplt.tick_params(axis=\"x\", labelsize = 15)\nplt.tick_params(axis=\"y\", labelleft=False, left=False)\nplt.title(\"The relationship of energy and time_to_failure\",fontsize = 20)\nplt.hlines(border_energy, 0, 10, linestyle='solid', color = \"red\",linewidth=2)\nplt.text(4,border_energy*1.05,\"border energy\", size = 20, color = \"red\")\nplt.text(0.8,border_energy*1.5,\"high energy data\", size = 20, color = \"royalblue\")\nplt.xlabel(\"time_to_failure\", fontsize = 20)\nplt.ylabel(\"energy_data\", fontsize = 20)\n\nplt.figure(figsize=(15, 8))\nplt.scatter(x = x, y = y)\nplt.tick_params(axis=\"x\", labelsize = 15)\nplt.tick_params(axis=\"y\", labelleft=False, left=False)\nplt.title(\"Expansion of high enegy data\",fontsize = 20)\nplt.vlines(border_energy, 0, 10, linestyle='solid', color = \"red\",linewidth=2)\nplt.text(0.33,border_energy*1.5,\"high energy data\", size = 20, color = \"royalblue\")\nplt.xlim(0.3,0.35)\nplt.ylim(border_energy,border_energy*2)\nplt.xlabel(\"time_to_failure\", fontsize = 20)\nplt.ylabel(\"energy_data\", fontsize = 20)","c6f23125":"data[\"predict_time\"] = np.nan\n\nnp_energy = np.asarray(acoustic_table.energy_data)\nnp_predict_time = np.asarray(data.predict_time)\n\nfor i in range(len(np_energy)):\n    if (np_energy[i] > border_energy):\n        np_predict_time[acoustic_table.start_index[i]] = 0.32\ndata.predict_time = np_predict_time\n\ndel np_energy\ndel np_predict_time","8a0f4b17":"just_before_time_data = data[data.predict_time > 0]\njust_before_time_data","c5b7f0fb":"quake_time = pd.DataFrame()\n\nnp_predict_time = np.asarray(data.predict_time)\nnp_wait_start_index = []\nnp_wait_end_index = []\n\nnp_before032_wait_end_index = np.where(np_predict_time == 0.32)\nnp_before032_wait_end_index = np_before032_wait_end_index[0]","97b86aca":"i = 0\nindex_length_toend = int((0.32\/delta_time))\n\nfor i in range(len(np_before032_wait_end_index)):\n    np_wait_end_index.append(int(np_before032_wait_end_index[i] + index_length_toend))\n \n \nnp_wait_start_index = np_wait_end_index + np.array(1)\nnp_wait_start_index = np.insert(np_wait_start_index, 0, 0)\nnp_wait_end_index.append(np.nan)\n\nquake_time[\"wait_start_index\"] = np_wait_start_index\nquake_time[\"wait_end_index\"] = np_wait_end_index\n\ndel np_predict_time\ndel np_wait_end_index\ndel np_before032_wait_end_index","d4cf8018":"quake_time","0753cef2":"np_wait_start_index = np.array(quake_time.wait_start_index)\nnp_wait_end_index = np.array(quake_time.wait_end_index)\nnp_wait_end_index = np_wait_end_index.astype(np.int32)\nnp_predict_time = np.array(data.predict_time)\ni = 0\nj = 0\n\nfor i in range(len(np_wait_end_index-1)):\n    j = np_wait_start_index[i]\n    k = 0\n    sample_num = np_wait_end_index[i] - np_wait_start_index[i]\n    while (j < np_wait_end_index[i] +1):\n        np_predict_time[j] = (sample_num - k)*delta_time\n        j+=1\n        k+=1","810b8a53":"data.predict_time = np_predict_time","d6ebf047":"data","44c47c6f":"predict_time_work = np_predict_time[~np.isnan(np_predict_time)]\npredict_time_work = predict_time_work[::50]\n\nindex_work = np.arange(len(predict_time_work))","0f445677":"time_to_failure_per_100 = data.time_to_failure[::10]\nindex_time_to_failure = np.arange(len(time_to_failure_per_100))\n\npredict_time_per_100 = data.predict_time[::10]\npredict_time_per_100 = predict_time_per_100[~np.isnan(predict_time_per_100)]\nindex_predict_time = np.arange(len(predict_time_per_100))\n\nplt.figure(figsize=(20, 10))\nplt.scatter(x = index_time_to_failure, y = time_to_failure_per_100, s=5)\nplt.tick_params(axis=\"x\", labelsize = 15)\nplt.tick_params(axis=\"y\", labelsize = 15)\nplt.title(\"Mesured time_to_failure\",fontsize = 20)\nplt.xlabel(\"index\", fontsize = 20)\nplt.ylabel(\"Mesured time_to_failure\", fontsize = 20)\n\nplt.figure(figsize=(20, 10))\nplt.scatter(x = index_predict_time, y = predict_time_per_100, s=5)\nplt.tick_params(axis=\"x\", labelsize = 15)\nplt.tick_params(axis=\"y\", labelsize = 15)\nplt.title(\"Predicted time_to_failure\",fontsize = 20)\nplt.xlabel(\"index\", fontsize = 20)\nplt.ylabel(\"Predicted time_to_failure\", fontsize = 20)","c66dda89":"delta_time means time per index","0e8bb056":"The graph of \"The relationship of energy and time_to_failure\" means high energy datas have same time_to_failures.  Border of high and low energy datas is about understood.\nIn below graph, border is determined sorted energy data.Border is center of the two energy data these have most wide energy difference.","2e78b1fb":"* Predicted time to failure is seem to same mesured. Here, end data of predicted is nan, becouse of can not read from acoustic_data in this method.\n* There was a problem for fitting test data. When cutting signal, threshold size of rolling_std could not be decided individual test data.","50b25964":"Time_to_failure could be predicted from high energy data's time_to_failure. \nI will calculate time_to_failure from now on.","090e8338":"TTF in the title means time to failure.\n\nTrain data shows earth quake being after a big signal of acoustic data. In this kernel, analyzing the relationship of earth quake and big signal.\nThe procedure is below.\n\n1. Cutting signal data from acoustic data.\n2. Analyzing individual signal data.\n3. Predicting time_to_failure \n\nIn making the kernel,I referred to\u3010https:\/\/www.kaggle.com\/allunia\/shaking-earth \u3011\u3000and \u3010https:\/\/www.kaggle.com\/artgor\/earthquakes-fe-more-features-and-samples \u3011.\nI really appreciate them."}}