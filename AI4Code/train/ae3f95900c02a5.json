{"cell_type":{"4ec9f62a":"code","2eb1797c":"code","59b7c19b":"code","f91fd715":"code","aaa1b1e3":"code","07ba20f5":"code","25d0294d":"code","8c0efef6":"code","4b57753c":"markdown","df59bf88":"markdown","a583a321":"markdown","e39c90b7":"markdown","ae36d7b4":"markdown","51ff2c11":"markdown","fee3f6a8":"markdown"},"source":{"4ec9f62a":"!pip install h3 folium fuggle>=0.1.2","2eb1797c":"from fuggle import setup, Plot, PlotBar, PlotBarH, PlotLine, Dag\nsetup(\"spark\", {\"fuggle.sqlite.path\":\"\/kaggle\/input\/california-traffic-collision-data-from-switrs\"})","59b7c19b":"from typing import Iterable, Dict, Any, List\nimport pandas as pd\nimport numpy as np\nimport h3\nimport json\nfrom geojson import Feature, FeatureCollection\nfrom folium import Map, GeoJson\nfrom IPython import display\nimport itertools\n\n# schema: *,hex_id:str\ndef to_hex_id(df:pd.DataFrame, resolution:int=6, lat_col:str=\"lat\", lng_col:str=\"lng\") -> pd.DataFrame:\n    df[\"hex_id\"] = df.apply(lambda row: h3.geo_to_h3(row[lat_col], row[lng_col], resolution), axis=1)\n    return df\n\n# input_has: hex_id:str,hex_value\n# schema: *,geojson_feature:str\ndef to_geojson_feature(df:Iterable[Dict[str,Any]]) -> Iterable[Dict[str,Any]]:\n    for row in df:\n        hex_id = row[\"hex_id\"]\n        geometry = {\"type\" : \"Polygon\", \"coordinates\": [h3.h3_to_geo_boundary(hex_id, geo_json=True)]}\n        feature = Feature(geometry=geometry, properties={\"hex_value\":row[\"hex_value\"]}, id=hex_id)\n        row[\"geojson_feature\"] = str(feature)\n        yield row\n\n# input_has: geojson_feature:str\ndef draw_folium_heatmap(df:List[Dict[str,Any]], color = 'red', min_opacity=0.2, max_opacity = 0.7, zoom=10) -> None:\n    collection = FeatureCollection([json.loads(x[\"geojson_feature\"]) for x in df])\n    \n    points = list(itertools.chain.from_iterable(h3.h3_to_geo_boundary(x[\"id\"]) for x in collection[\"features\"]))\n    initial_map = Map(\n        location = [np.mean([x[0] for x in points]),np.mean([x[1] for x in points])],\n        zoom_start=zoom\n    )\n    \n    hex_values = list(x[\"properties\"][\"hex_value\"] for x in collection[\"features\"])\n    min_hex_value = min(hex_values)\n    delta = max(hex_values) - min_hex_value\n    to_opacity = lambda x: max_opacity if delta==0 else (x-min_hex_value)\/delta*(max_opacity-min_opacity)+min_opacity\n    \n    GeoJson(\n        json.dumps(collection),\n        style_function=lambda feature: {\n            'fillColor': color,\n            'weight': 0,\n            'fillOpacity': to_opacity(feature[\"properties\"][\"hex_value\"])\n        }, \n        name = \"hex\"\n    ).add_to(initial_map)\n    display.display(initial_map)","f91fd715":"with Dag() as dag:\n    df = dag.df([[45.5051, -122.6750, 10]],\"lat:double,lng:double,hex_value:double\")\n    df = df.transform(to_hex_id, params=dict(resolution=6)).transform(to_geojson_feature)\n    df.output(draw_folium_heatmap, params={\"zoom\":10})\n    df.output(draw_folium_heatmap, params={\"zoom\":12})\n    df=None","aaa1b1e3":"%%fsql\nSELECT \n    case_id, alcohol_involved, collision_severity, \n    latitude, longitude, CASE\n    WHEN collision_severity=\"fatal\" THEN 5\n    WHEN collision_severity=\"severe injury\" THEN 4\n    WHEN collision_severity=\"other injury\" THEN 3\n    WHEN collision_severity=\"pain\" THEN 2\n    WHEN collision_severity=\"property damage only\" THEN 1\n    ELSE 0 END AS collision_severity_weight\nFROM switrs.sqlite.collisions \nWHERE collision_time IS NOT NULL\n    AND collision_date IS NOT NULL \n    AND latitude IS NOT NULL \n    AND longitude IS NOT NULL\n\nSAVE AND USE OVERWRITE \"\/kaggle\/working\/t1.parquet\"\nPRINT","07ba20f5":"%%fsql\nLOAD \"\/kaggle\/working\/t1.parquet\"\n\nTRANSFORM \n    USING to_hex_id(resolution=6,lat_col=\"latitude\",lng_col=\"longitude\")\n    DETERMINISTIC CHECKPOINT\n\nSELECT hex_id, COUNT(*) AS hex_value GROUP BY hex_id\nTRANSFORM USING to_geojson_feature\nOUTPUT USING draw_folium_heatmap(zoom=7)","25d0294d":"%%fsql\nLOAD \"\/kaggle\/working\/t1.parquet\"\n\nTRANSFORM \n    USING to_hex_id(resolution=6,lat_col=\"latitude\",lng_col=\"longitude\")\n    DETERMINISTIC CHECKPOINT\n\nSELECT hex_id, AVG(collision_severity_weight) AS hex_value, COUNT(*) AS ct GROUP BY hex_id\nSELECT * WHERE ct>100\nTRANSFORM USING to_geojson_feature\nOUTPUT USING draw_folium_heatmap(zoom=6)","8c0efef6":"%%fsql\nLOAD \"\/kaggle\/working\/t1.parquet\"\n\nTRANSFORM \n    USING to_hex_id(resolution=6,lat_col=\"latitude\",lng_col=\"longitude\")\n    DETERMINISTIC CHECKPOINT\n\nSELECT hex_id, AVG(collision_severity_weight) AS hex_value, COUNT(*) AS ct GROUP BY hex_id\nSELECT * WHERE ct>100 ORDER BY hex_value DESC LIMIT 200\nTRANSFORM USING to_geojson_feature\nOUTPUT USING draw_folium_heatmap(zoom=7)","4b57753c":"## Heatmap: weighted collission count\n\nUsing severity as weight, we see similar pattern on the heatmap","df59bf88":"## Get data from Sqlite\n\nSqlite itself can't be integrated with python extensions, also Sqlite is slower, so I decide to do some basic transformation with it and then save to a temp parquet file. I can also directly invoke the above extensions here, but since I need to use them multiple times, the best choice is to save the intermediate data to temp file first.","a583a321":"## Heatmap: top 200 regions with highest weighted collission count\n\nMountain road can cause more severe accidents","e39c90b7":"## Heatmap: collission total count\n\nWe can see bigger cities, busier regions have more collisions","ae36d7b4":"Now we write a very simple Fugue workflow with mock data and run on pandas backend to verify things work end to end","51ff2c11":"## Fugue extensions for H3 rendering\n\nActually, you only see native python functions here with comments (hints). Fugue is able to identify them and run them distributedly on Spark.","fee3f6a8":"# Collsions Heatmap using Uber H3 + Folium + Spark + Fugue\n\nIn this notebook, we rendre heatmap based on [H3](https:\/\/eng.uber.com\/h3\/) (Hexagonal Hierarchical Spatial Index).\n\nThe data aggregation is partially done by Sqlite and partially by Spark (because we need to convert lat lng to `hex_id`), orchestrated by [Fugue](https:\/\/github.com\/fugue-project\/fugue). The part converting input data to geojson and to render using Folium is written as Fugue [extensions](https:\/\/fugue-tutorials.readthedocs.io\/en\/latest\/tutorials\/extensions.html).\n\n## Install dependency and setup Spark backend"}}