{"cell_type":{"31e28796":"code","e9a32804":"code","f2afb7c8":"code","6cf30652":"code","b17ddc46":"code","be8b09b8":"code","d2242a81":"code","b7f53c5e":"code","dd277c36":"code","920a58df":"code","f46d58e6":"code","c880aeab":"code","3740d185":"code","c898db7d":"code","4deca58a":"code","c624eaf0":"code","b7abd586":"code","8be83370":"code","415c4db1":"code","4f2dff62":"code","880fb5e4":"code","b1217e9b":"markdown","3b595bad":"markdown","7c8b640c":"markdown"},"source":{"31e28796":"# !pip install --quiet \"torchvision\" \"torch\" \"pytorch-lightning\" \"torchmetrics\"\n# !pip install --quiet comet-ml","e9a32804":"import comet_ml\n\nfrom kaggle_secrets import UserSecretsClient\nfrom pytorch_lightning.loggers import CometLogger","f2afb7c8":"user_secrets = UserSecretsClient()\ncomet_logger = CometLogger(\n    api_key=user_secrets.get_secret(\"COMET_API_KEY\"),\n    workspace=user_secrets.get_secret(\"COMET_WORKSPACE\"),  # Optional\n    save_dir=\".\",  # Optional\n    project_name=user_secrets.get_secret(\"COMET_PROJECT\"),  # Optional\n    # rest_api_key=user_secrets.get_secret(\"COMET_REST_API_KEY\"),  # Optional\n    # experiment_name=\"smap\",  # Optional\n)","6cf30652":"import os\n\nimport pytorch_lightning as pl\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torchmetrics\nfrom PIL import Image\nfrom torch.utils.data import DataLoader\nfrom pytorch_lightning.callbacks.early_stopping import EarlyStopping\nfrom torchvision import datasets\nfrom torchvision import models\nfrom torchvision import transforms\nfrom pytorch_lightning import Trainer\nimport pandas as pd\nfrom pytorch_lightning.utilities.seed import seed_everything\nfrom sklearn.model_selection import train_test_split","b17ddc46":"ROOT = os.path.join(\"\/kaggle\", \"input\", \"lego-minifigures-classification\")\nAVAIL_GPUS = min(1, torch.cuda.device_count())\nBATCH_SIZE = 4","be8b09b8":"seed_everything(42)","d2242a81":"class Model(pl.LightningModule):\n    def __init__(self, classes: int):\n        super(Model, self).__init__()\n        \n        self.classes = classes\n        self.create_model()\n\n        self.train_acc = torchmetrics.Accuracy()\n        self.valid_acc = torchmetrics.Accuracy()\n        self.test_acc = torchmetrics.Accuracy()\n\n    def create_model(self):\n#        self.models = models.resnet50(pretrained=True)\n        self.models = models.mobilenet_v2(pretrained=True)\n    \n        print(self.models)\n\n        # num_ftrs = self.models.fc.in_features\n        # self.models.fc = nn.Linear(num_ftrs, self.classes)\n        num_ftrs = self.models.classifier[1].in_features\n        self.models.classifier[1] = nn.Linear(num_ftrs, self.classes)\n\n    def forward(self, x):\n        return self.models(x)\n\n    def training_step(self, batch, batch_idx):\n        images, target = batch\n        preds = self(images)\n\n        loss = F.cross_entropy(preds, target)\n        \n        _, preds = torch.max(preds, 1)\n        self.train_acc(preds, target)\n        self.log('train_acc', self.train_acc, on_step=True, on_epoch=True, prog_bar=True)\n\n        return loss\n\n    def validation_step(self, batch, batch_idx):\n        images, target = batch\n        preds = self.forward(images)\n        \n        loss = F.cross_entropy(preds, target)\n        \n        _, preds = torch.max(preds, 1)\n        self.valid_acc(preds, target)\n        self.log('valid_acc', self.valid_acc, on_step=False, on_epoch=True, prog_bar=True)\n        return loss\n\n    def test_step(self, batch, batch_idx):\n        images, target = batch\n        preds = self.forward(images)\n        \n        loss = F.cross_entropy(preds, target)\n        \n        _, preds = torch.max(preds, 1)\n        self.test_acc(preds, target)\n        self.log('test_acc', self.test_acc)\n        self.log(\"test_loss\", loss)\n        return loss\n\n    def configure_optimizers(self):\n        # return torch.optim.SGD(self.parameters(), lr=0.01, momentum=0.9)\n        return torch.optim.Adam(self.parameters(), lr=0.0001)","b7f53c5e":"data = pd.read_csv(os.path.join(ROOT,'index.csv'))\ndata.head()","dd277c36":"class LegoDataset(torch.utils.data.Dataset):\n    def __init__(self, X: list, y: list, root: str, transforms = None):\n        self.X = list(X)\n        self.y = list(y)\n\n        self.root = root\n        self.transforms = transforms\n\n    def __len__(self):\n        return len(self.X)\n\n    def __getitem__(self, index):\n        filename = os.path.join(self.root, self.X[index])\n        label = self.y[index]\n        image = Image.open(filename)\n        \n        if self.transforms is not None:\n            image = self.transforms(image)\n        \n        return image, label","920a58df":"X, y = data.path, data.class_id\ny = y-1\n\nX_train, X_valid, y_train, y_valid = train_test_split(X, y, random_state=0)\nprint(len(X_train), len(X_valid))","f46d58e6":"train_dataset = LegoDataset(X_train, y_train, root=ROOT, transforms=transforms.Compose([\n                                    transforms.Resize(224),\n                                    transforms.ToTensor(),\n                                    transforms.Normalize([0.485, 0.456, 0.406],[0.229, 0.224, 0.225])\n                                   ])\n                           )\n                            \ntrain_dataset[0]","c880aeab":"valid_dataset = LegoDataset(X_valid, y_valid, root=ROOT, transforms=transforms.Compose([\n                                    transforms.Resize(224),\n                                    transforms.ToTensor(),\n                                    transforms.Normalize([0.485, 0.456, 0.406],[0.229, 0.224, 0.225])\n                                   ])\n                           )\n\nvalid_dataset[0]","3740d185":"train_dataloader = DataLoader(train_dataset, batch_size=BATCH_SIZE)\nvalid_dataloader = DataLoader(valid_dataset, batch_size=1)","c898db7d":"classes = data.class_id.unique()\nprint(classes, len(classes))\nmodel = Model(classes=max(classes))","4deca58a":"#AVAIL_GPUS=0\n\ntrainer = Trainer(\n    logger=comet_logger,\n    callbacks=[EarlyStopping(monitor=\"valid_acc\", mode=\"max\", patience=5, min_delta=0.00)],\n    gpus=AVAIL_GPUS,\n    max_epochs=50,\n    default_root_dir=\".\/test\/\"\n)\n\nhist = trainer.fit(model, train_dataloader, valid_dataloader)","c624eaf0":"test_data = pd.read_csv(os.path.join(ROOT, 'test.csv'))\nvalid_dataset = LegoDataset(test_data.path, test_data.class_id-1, root=ROOT, transforms=transforms.Compose([\n                                    transforms.Resize(224),\n                                    transforms.ToTensor(),\n                                    transforms.Normalize([0.485, 0.456, 0.406],[0.229, 0.224, 0.225])\n                                   ])\n                           )\n\ntest_dataloader = DataLoader(valid_dataset, batch_size=1)","b7abd586":"trainer.test(model, test_dataloader)","8be83370":"import itertools\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_confusion_matrix(cm, classes, normalize=False, title='Confusion matrix', cmap=plt.cm.Blues):\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n    fig, ax = plt.subplots(figsize=(len(classes), len(classes)))\n    print(cm)\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=90)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt), horizontalalignment=\"center\", color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","415c4db1":"import torchmetrics\ndevice = torch.device(\"cuda\")\n\nmodel.eval()\nmodel = model.cuda()\n\nclass_names = pd.read_csv(os.path.join(ROOT, 'metadata.csv'))[\"minifigure_name\"].tolist()\n\nacc = torchmetrics.Accuracy()\n\ncm_p = []\ncm_t = []\n\nfor i, (inputs, targets) in enumerate(test_dataloader):\n    inputs = inputs.to(device)\n\n    preds = model(inputs).cpu()\n    _, preds = torch.max(preds, 1)\n    acc(preds, targets)\n\n    #      MC\n    cm_t.extend(targets.cpu().detach().numpy())\n    cm_p.extend(preds.cpu().detach().numpy())\n\nfrom sklearn.metrics import confusion_matrix\ncm = confusion_matrix(cm_t, cm_p)\n\nplot_confusion_matrix(cm, class_names, normalize=False)\nplot_confusion_matrix(cm, class_names, normalize=True)","4f2dff62":"comet_logger.experiment.log_confusion_matrix(cm_t, cm_p, labels=class_names)","880fb5e4":"comet_logger.experiment.end()","b1217e9b":"## Simplest example\n\nHere's the simplest most minimal example with just a training loop (no validation, no testing).\n\n**Keep in Mind** - A `LightningModule` *is* a PyTorch `nn.Module` - it just has a few more helpful features.","3b595bad":"## Setup\nThis notebook requires some packages besides pytorch-lightning.","7c8b640c":"# Evaluate"}}