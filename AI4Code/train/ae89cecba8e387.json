{"cell_type":{"0c0fa28e":"code","f55e49b0":"code","d7f5b884":"code","caeb13d2":"code","444ecaeb":"code","1ce685d8":"code","bc4b5af3":"code","b2c5a8fd":"code","2451e6c2":"code","d523ab33":"code","bbafa011":"code","bbb5cf43":"markdown"},"source":{"0c0fa28e":"## Assignment 1 PrintInOrder\nclass Node:\n    \n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n    \n    def insert(self, data):\n        if (self.data):\n            if (data < self.data):\n                if (self.left is None):\n                    self.left = Node(data)\n                else:\n                    self.left.insert(data)\n            elif (data > self.data):\n                if (self.right is None):\n                    self.right = Node(data)\n                else:\n                    self.right.insert(data)\n        else:\n            self.data = data\n    \n    def inorder_traversal(self):\n        elements = []\n        \n        # visit left tree side\n        if (self.left):\n            elements += self.left.inorder_traversal()\n        \n        # visit root-node for every subtree\n        elements.append(self.data)\n        \n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.inorder_traversal()\n            \n        # return values\n        return elements\n        \n            \n\ndef build_tree(elements):\n    root = Node(elements[0])\n    for i in range(1, len(elements)):\n        root.insert(elements[i])\n    \n    return root\n\n#######################\n\nnumbers = [15,12,7,14,27,20,23,89]\n\nnumbers_tree = build_tree(numbers)\n\nnumbers_inorder = numbers_tree.inorder_traversal()\nprint('Inorder')\nprint(numbers_inorder)\n        ","f55e49b0":"## Assignment 2 PrintInPreOrder\nclass Node:\n    \n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n    \n    def insert(self, data):\n        if (self.data):\n            if (data < self.data):\n                if (self.left is None):\n                    self.left = Node(data)\n                else:\n                    self.left.insert(data)\n            elif (data > self.data):\n                if (self.right is None):\n                    self.right = Node(data)\n                else:\n                    self.right.insert(data)\n        else:\n            self.data = data\n    \n    def preorder_traversal(self):\n        elements = []\n        \n        elements.append(self.data)\n        \n        if (self.left):\n            elements += self.left.preorder_traversal()\n        \n        if (self.right):\n            elements += self.right.preorder_traversal()\n            \n        # return values\n        return elements\n        \n            \n\ndef build_tree(elements):\n    root = Node(elements[0])\n    for i in range(1, len(elements)):\n        root.insert(elements[i])\n    \n    return root\n\n#######################\n\nnumbers = [15,12,7,14,27,20,23,89]\n\nnumbers_tree = build_tree(numbers)\n\nnumbers_preorder = numbers_tree.preorder_traversal()\nprint('preorder')\nprint(numbers_preorder)","d7f5b884":"## Assignment 3 PrintPostOrder\nclass Node:\n    \n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n    \n    def insert(self, data):\n        if (self.data):\n            if (data < self.data):\n                if (self.left is None):\n                    self.left = Node(data)\n                else:\n                    self.left.insert(data)\n            elif (data > self.data):\n                if (self.right is None):\n                    self.right = Node(data)\n                else:\n                    self.right.insert(data)\n        else:\n            self.data = data\n    \n    def postorder_traversal(self):\n        elements = []\n        \n        if (self.left):\n            elements += self.left.postorder_traversal()\n        \n        if (self.right):\n            elements += self.right.postorder_traversal()\n            \n        elements.append(self.data)\n            \n        # return values\n        return elements\n        \n            \n\ndef build_tree(elements):\n    root = Node(elements[0])\n    for i in range(1, len(elements)):\n        root.insert(elements[i])\n    \n    return root\n\n#######################\n\nnumbers = [15,12,7,14,27,20,23,89]\n\nnumbers_tree = build_tree(numbers)\n\nnumbers_postorder = numbers_tree.postorder_traversal()\nprint('postorder')\nprint(numbers_postorder)","caeb13d2":"## Assignment 4 min & max val\nclass Node:\n    \n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n    \n    def insert(self, data):\n        if (self.data):\n            if (data < self.data):\n                if (self.left is None):\n                    self.left = Node(data)\n                else:\n                    self.left.insert(data)\n            elif (data > self.data):\n                if (self.right is None):\n                    self.right = Node(data)\n                else:\n                    self.right.insert(data)\n        else:\n            self.data = data\n            \n    def minvalue(node):\n        current = node    \n        while(current.left is not None):\n            current = current.left\n            \n        return current.data\n        \n    def maxvalue(node):\n        current = node    \n        while(current.right is not None):\n            current = current.right\n            \n        return current.data\n\ndef build_tree(elements):\n    root = Node(elements[0])\n    for i in range(1, len(elements)):\n        root.insert(elements[i])\n    \n    return root\n\n\n\n#######################\n\nnumbers = [15,12,7,14,27,20,23,89]\n\nnumbers_tree = build_tree(numbers)\n\nprint('minvalue')\nprint(numbers_tree.minvalue())\n\nprint('maxvalue')\nprint(numbers_tree.maxvalue())","444ecaeb":"# Assignment 5 iterative BFS\n\nfrom queue import *\n\n## Assignment 4 min & max val\nclass Node:\n    \n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n    \n    def insert(self, data):\n        if (self.data):\n            if (data < self.data):\n                if (self.left is None):\n                    self.left = Node(data)\n                else:\n                    self.left.insert(data)\n            elif (data > self.data):\n                if (self.right is None):\n                    self.right = Node(data)\n                else:\n                    self.right.insert(data)\n        else:\n            self.data = data\n            \n    def bfs(self):\n\n        elements = []\n        queue = Queue()\n        queue.put(self)\n        \n        while not queue.empty():\n            self = queue.get()\n            elements.append(self.data)\n            \n            if self.left:\n                queue.put(self.left)\n                \n            if self.right:\n                queue.put(self.right)\n        \n        return elements\n\n            \n\ndef build_tree(elements):\n    root = Node(elements[0])\n    for i in range(1, len(elements)):\n        root.insert(elements[i])\n    \n    return root\n\n\n\n#######################\n\nnumbers = [15,12,7,14,27,20,23,89]\n\nnumbers_tree = build_tree(numbers)\n\nprint('bfs')\nprint(numbers_tree.bfs())\n\n\n","1ce685d8":"# Assignment 6 Search function returning value or NUL\n\nfrom queue import *\n\n\nclass Node:\n\n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n\n    def insert(self, data):\n        if (self.data):\n            if (data < self.data):\n                if (self.left is None):\n                    self.left = Node(data)\n                else:\n                    self.left.insert(data)\n            elif (data > self.data):\n                if (self.right is None):\n                    self.right = Node(data)\n                else:\n                    self.right.insert(data)\n        else:\n            self.data = data\n\n    def inorder_traversal(self):\n        elements = []\n\n        # visit left tree side\n        if (self.left):\n            elements += self.left.inorder_traversal()\n\n        # visit root-node for every subtree\n        elements.append(self.data)\n\n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.inorder_traversal()\n\n        # return values\n        return elements\n\n    def preorder_traversal(self):\n        elements = []\n\n        # visit root-node for every subtree\n        elements.append(self.data)\n\n        # visit left tree side\n        if (self.left):\n            elements += self.left.preorder_traversal()\n\n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.preorder_traversal()\n\n        # return values\n        return elements\n\n    def postorder_traversal(self):\n        elements = []\n\n        # visit left tree side\n        if (self.left):\n            elements += self.left.postorder_traversal()\n\n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.postorder_traversal()\n\n        # visit root-node for every subtree\n        elements.append(self.data)\n\n        # return values\n        return elements\n\n    def minvalue(node):\n        current = node\n\n        while (current.left is not None):\n            current = current.left\n\n        return current.data\n\n    def maxvalue(node):\n        current = node\n\n        while (current.right is not None):\n            current = current.right\n\n        return current.data\n\n    def bfs(self):\n\n        elements = []\n        queue = Queue()\n        queue.put(self)\n\n        while not queue.empty():\n            self = queue.get()\n            elements.append(self.data)\n\n            if self.left:\n                queue.put(self.left)\n\n            if self.right:\n                queue.put(self.right)\n\n        return elements\n\n    def search_value(self, val):\n        if (self.data is None):\n            return None\n        if (self.data == val):\n            return self.data\n        if (self.left is None):\n            return None\n        if (self.right is None):\n            return None\n        if (self.data and val < self.data):\n            return self.left.search_value(val)\n        if (self.data and val > self.data):\n            return self.right.search_value(val)\n\n\ndef build_tree(elements):\n    root = Node(elements[0])\n    for i in range(1, len(elements)):\n        root.insert(elements[i])\n\n    return root\n\n########################################################################\n\nnumbers = [15,12,7,14,27,20,23,89]\n\nnumbers_tree = build_tree(numbers)\n\nnumbers_inorder = numbers_tree.inorder_traversal()\nprint('Inorder')\nprint(numbers_inorder)\n\nnumbers_preorder = numbers_tree.preorder_traversal()\nprint('preorder')\nprint(numbers_preorder)\n\nnumbers_postorder = numbers_tree.postorder_traversal()\nprint('postorder')\nprint(numbers_postorder)\n\nprint('minvalue')\nprint(numbers_tree.minvalue())\n\nprint('maxvalue')\nprint(numbers_tree.maxvalue())\n\nprint('bfs')\nprint(numbers_tree.bfs())\n\nprint(\"search 20\")\nprint(\"found \", numbers_tree.search_value(20))\n","bc4b5af3":"# Delete Value Function delete_value\n\nfrom queue import *\n\nclass Node:\n    \n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n    \n    def insert(self, data):\n        if (self.data):\n            if (data < self.data):\n                if (self.left is None):\n                    self.left = Node(data)\n                else:\n                    self.left.insert(data)\n            elif (data > self.data):\n                if (self.right is None):\n                    self.right = Node(data)\n                else:\n                    self.right.insert(data)\n        else:\n            self.data = data\n    \n    def inorder_traversal(self):\n        elements = []\n        \n        # visit left tree side\n        if (self.left):\n            elements += self.left.inorder_traversal()\n        \n        # visit root-node for every subtree\n        elements.append(self.data)\n        \n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.inorder_traversal()\n            \n        # return values\n        return elements\n    \n    def preorder_traversal(self):\n        elements = []\n        \n        # visit root-node for every subtree\n        elements.append(self.data)\n\n        # visit left tree side\n        if (self.left):\n            elements += self.left.preorder_traversal()\n        \n        \n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.preorder_traversal()\n            \n        # return values\n        return elements    \n\n    def postorder_traversal(self):\n        elements = []\n        \n\n        # visit left tree side\n        if (self.left):\n            elements += self.left.postorder_traversal()\n        \n        \n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.postorder_traversal()\n            \n        # visit root-node for every subtree\n        elements.append(self.data)\n\n        # return values\n        return elements \n    \n    def minvalue(node):\n        current = node\n        \n        while(current.left is not None):\n            current = current.left\n            \n        return current.data\n        \n    def maxvalue(node):\n        current = node\n        \n        while(current.right is not None):\n            current = current.right\n            \n        return current.data\n    \n    def bfs(self):\n\n        elements = []\n        queue = Queue()\n        queue.put(self)\n        \n        while not queue.empty():\n            self = queue.get()\n            elements.append(self.data)\n            \n            if self.left:\n                queue.put(self.left)\n                \n            if self.right:\n                queue.put(self.right)\n        \n        return elements\n    \n    def searchval(self, val):\n        if (self.data is None):\n            return None\n        \n        if (self.data == val):\n            return self.data\n        \n        if (self.left and val < self.data):\n            return self.left.searchval(val)\n            \n        if (self.right and val > self.data):\n            return self.right.searchval(val)\n        \n    def minValueNode(node):\n        current = node\n        \n        while(current.left is not None):\n            current = current.left\n            \n        return current\n\n    def delete(self, val):\n        if (self is None):\n            return self\n        \n        if (self.left and val < self.data):\n            self.left = self.left.delete(val)\n        \n        elif (self.right and val > self.right):\n            self.right = self.right.delete(val)\n        \n        else:\n            \n            # we have found the node to delete\n            \n            # case 1 - node is a leaf\n            if (self.left is None and self.right is None):\n                return None\n                \n            # case 2 - we have left or right child \n            if (self.left is None):\n                temp = self.right\n                #self = None\n                return temp\n            elif (self.right is None):\n                temp = self.left\n                #self = None\n                return temp\n            \n            # case 3 - node hat two children\n            temp = minValueNode(self.right)\n            \n            self.data = temp.data\n            self.right = delete(self.right, temp.data)\n            \n        return self\n\ndef build_tree(elements):\n    root = Node(elements[0])\n    for i in range(1, len(elements)):\n        root.insert(elements[i])\n    \n    return root\n        \n######################################################################\n\nnumbers = [15,12,7,14,27,20,23,89]\n\nnumbers_tree = build_tree(numbers)\n\nnumbers_inorder = numbers_tree.inorder_traversal()\nprint('Inorder')\nprint(numbers_inorder)\n\nnumbers_preorder = numbers_tree.preorder_traversal()\nprint('preorder')\nprint(numbers_preorder)\n\nnumbers_postorder = numbers_tree.postorder_traversal()\nprint('postorder')\nprint(numbers_postorder)\n\nprint('minvalue')\n#print(numbers_tree.minvalue())\n\nprint('maxvalue')\n#print(numbers_tree.maxvalue())\n\nprint('bfs')\nprint(numbers_tree.bfs())\n\nprint('serach 20')\nprint(numbers_tree.searchval(20))\n\nprint('serach 21')\nprint(numbers_tree.searchval(21))","b2c5a8fd":"# Assignment 7 Check if Binary Tree is Balanced\n\nfrom queue import *\n\n\nclass Node:\n\n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n\n    def insert(self, data):\n        if (self.data):\n            if (data < self.data):\n                if (self.left is None):\n                    self.left = Node(data)\n                else:\n                    self.left.insert(data)\n            elif (data > self.data):\n                if (self.right is None):\n                    self.right = Node(data)\n                else:\n                    self.right.insert(data)\n        else:\n            self.data = data\n\n    def inorder_traversal(self):\n        elements = []\n\n        # visit left tree side\n        if (self.left):\n            elements += self.left.inorder_traversal()\n\n        # visit root-node for every subtree\n        elements.append(self.data)\n\n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.inorder_traversal()\n\n        # return values\n        return elements\n\n    def preorder_traversal(self):\n        elements = []\n\n        # visit root-node for every subtree\n        elements.append(self.data)\n\n        # visit left tree side\n        if (self.left):\n            elements += self.left.preorder_traversal()\n\n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.preorder_traversal()\n\n        # return values\n        return elements\n\n    def postorder_traversal(self):\n        elements = []\n\n        # visit left tree side\n        if (self.left):\n            elements += self.left.postorder_traversal()\n\n        # visit rigth tree side\n        if (self.right):\n            elements += self.right.postorder_traversal()\n\n        # visit root-node for every subtree\n        elements.append(self.data)\n\n        # return values\n        return elements\n\n    def minvalue(node):\n        current = node\n\n        while (current.left is not None):\n            current = current.left\n\n        return current.data\n\n    def maxvalue(node):\n        current = node\n\n        while (current.right is not None):\n            current = current.right\n\n        return current.data\n\n    def bfs(self):\n\n        elements = []\n        queue = Queue()\n        queue.put(self)\n\n        while not queue.empty():\n            self = queue.get()\n            elements.append(self.data)\n\n            if self.left:\n                queue.put(self.left)\n\n            if self.right:\n                queue.put(self.right)\n\n        return elements\n\n    def searchval(self, val):\n        if (self.data is None):\n            return None\n\n        if (self.data == val):\n            return self.data\n\n        if (self.left and val < self.data):\n            return self.left.searchval(val)\n\n        if (self.right and val > self.data):\n            return self.right.searchval(val)\n\n    def minValueNode(node):\n        current = node\n\n        while (current.left is not None):\n            current = current.left\n\n        return current\n\n    def delete(self, val):\n        if (self is None):\n            return self\n\n        if (self.left and val < self.data):\n            self.left = self.left.delete(val)\n\n        elif (self.right and val > self.right):\n            self.right = self.right.delete(val)\n\n        else:\n\n            # we have found the node to delete\n\n            # case 1 - node is a leaf\n            if (self.left is None and self.right is None):\n                return None\n\n            # case 2 - we have left or right child\n            if (self.left is None):\n                temp = self.right\n                # self = None\n                return temp\n            elif (self.right is None):\n                temp = self.left\n                # self = None\n                return temp\n\n            # case 3 - node hat two children\n            temp = self.right.minValueNode()\n\n            self.data = temp.data\n            self.right = self.right.delete(temp.data)\n\n        return self\n\n    def isTreeFullBinaryTree(self):\n        # empty tree case\n        if (self is None):\n            return True\n\n        # is it a leave?\n        if (self.left is None and self.right is None):\n            return True\n\n        # we have two children\n        if (self.left is not None and self.right is not None):\n            return self.left.isTreeFullBinaryTree() and self.right.isTreeFullBinaryTree()\n\n        return False\n\n    def height(root):\n        hleft = 0\n        hright = 0\n\n        if root == None:\n            return 0\n\n        if root.left is not None:\n            hleft = root.left.height()\n\n        if root.right is not None:\n            hright = root.right.height()\n   \n\n        if hleft is not None and hright is not None:\n            if hleft > hright:\n                return hleft + 1\n            else:\n                return hright + 1\n\n    def CheckBalancedBinaryTree(root):\n        lheight = 0\n        rheight = 0\n        lcheck = 0\n        rcheck = 0\n        if root == None:\n            return True\n\n        if root.left is not None:\n            lheight = root.left.height()\n        if root.right is not None:\n            rheight = root.right.height()\n\n        if lheight is not None and rheight is not None:\n            if (abs(lheight - rheight) > 1):\n                return False\n\n        if root.left is not None:\n            lcheck = root.left.CheckBalancedBinaryTree()\n\n        if root.right is not None:\n            rcheck = root.right.CheckBalancedBinaryTree()\n\n        if lcheck == True and rcheck == True:\n            return True\n        return True\n\n\ndef build_tree(elements):\n    root = Node(elements[0])\n    for i in range(1, len(elements)):\n        root.insert(elements[i])\n\n    return root\n\n#####################################################\n\nnumbers = [10, 5, 3, 6, 15, 12, 18]\nnumbers_tree = build_tree(numbers)\nprint(\"is balanced?\")\nprint(numbers_tree.CheckBalancedBinaryTree())\nprint(\"######################\")\n\nnumbers = [10, 5, 3, 6, 15, 12, 18]\nnumbers_tree = build_tree(numbers)\nprint(numbers_tree.isTreeFullBinaryTree())\n\nnumbers = [10, 5, 3, 6, 15, 12, 18, 11]\nnumbers_tree = build_tree(numbers)\nprint(numbers_tree.isTreeFullBinaryTree())\n\n#######################################################\n\nnumbers = [15,12,7,14,27,20,23,89]\n\nnumbers_tree = build_tree(numbers)\n\nnumbers_inorder = numbers_tree.inorder_traversal()\nprint('Inorder')\nprint(numbers_inorder)\n\nnumbers_preorder = numbers_tree.preorder_traversal()\nprint('preorder')\nprint(numbers_preorder)\n\nnumbers_postorder = numbers_tree.postorder_traversal()\nprint('postorder')\nprint(numbers_postorder)\n\nprint('minvalue')\nprint(numbers_tree.minvalue())\n\nprint('maxvalue')\nprint(numbers_tree.maxvalue())\n\nprint('bfs')\nprint(numbers_tree.bfs())\n\nprint('serach 20')\nprint(numbers_tree.searchval(20))\n\nprint('serach 21')\nprint(numbers_tree.searchval(21))","2451e6c2":"# AVL Tree - left and right rotation\n\nclass Node(object):\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.key = key\n        self.height = 0\n\n\nclass AVLTree(object):\n\n    # function to insert\n    def insert(self, root, key):\n        if not root:\n            return Node(key)\n        elif key < root.key:\n            root.left = self.insert(root.left, key)\n        else:\n            root.right = self.insert(root.right, key)\n\n        root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right))\n\n        balanceFactor = self.getBalanceFactor(root)\n\n        if balanceFactor > 1:\n            pass\n\n        if balanceFactor < -1:\n            pass\n\n        return root\n\n    def getBalanceFactor(self, root):\n        if not root:\n            return 0\n        return self.getHeight(root.left) - self.getHeight(root.right)\n\n    def getHeight(self, root):\n        if not root:\n            return 0\n        return root.height\n\n# Function to perform left rotation\n    def leftRotate(self, z):\n        y = z.right\n        T2 = y.left\n        y.left = z\n        z.right = T2\n        z.height = 1 + max(self.getHeight(z.left),\n                           self.getHeight(z.right))\n        y.height = 1 + max(self.getHeight(y.left),\n                           self.getHeight(y.right))\n        return y\n\n    # Function to perform right rotation\n    def rightRotate(self, z):\n        y = z.left\n        T3 = y.right\n        y.right = z\n        z.left = T3\n        z.height = 1 + max(self.getHeight(z.left),\n                           self.getHeight(z.right))\n        y.height = 1 + max(self.getHeight(y.left),\n                           self.getHeight(y.right))\n        return y","d523ab33":"# Exercise 9 - AVL Tree - delete & Min Value function\n\nclass Node(object):\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.key = key\n        self.height = 0\n\n\nclass AVLTree(object):\n\n    # function to insert\n    def insert(self, root, key):\n        if not root:\n            return Node(key)\n        elif key < root.key:\n            root.left = self.insert(root.left, key)\n        else:\n            root.right = self.insert(root.right, key)\n\n        root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right))\n\n        balanceFactor = self.getBalanceFactor(root)\n\n        if balanceFactor > 1:\n            pass\n\n        if balanceFactor < -1:\n            pass\n\n        return root\n\n    def getBalanceFactor(self, root):\n        if not root:\n            return 0\n        return self.getHeight(root.left) - self.getHeight(root.right)\n\n    def getHeight(self, root):\n        if not root:\n            return 0\n        return root.height\n\n# Function to perform left rotation\n    def leftRotate(self, z):\n        y = z.right\n        T2 = y.left\n        y.left = z\n        z.right = T2\n        z.height = 1 + max(self.getHeight(z.left),\n                           self.getHeight(z.right))\n        y.height = 1 + max(self.getHeight(y.left),\n                           self.getHeight(y.right))\n        return y\n\n    # Function to perform right rotation\n    def rightRotate(self, z):\n        y = z.left\n        T3 = y.right\n        y.right = z\n        z.left = T3\n        z.height = 1 + max(self.getHeight(z.left),\n                           self.getHeight(z.right))\n        y.height = 1 + max(self.getHeight(y.left),\n                           self.getHeight(y.right))\n        return y\n\n    def getMinValueNode(self, root):\n        if root is None or root.left is None:\n            return root\n        return self.getMinValueNode(root.left)\n\n    def delete_node(self, root, key):\n\n        # Find the node to be deleted and remove it\n        if not root:\n            return root\n        elif key < root.key:\n            root.left = self.delete_node(root.left, key)\n        elif key > root.key:\n            root.right = self.delete_node(root.right, key)\n        else:\n            if root.left is None:\n                temp = root.right\n                root = None\n                return temp\n            elif root.right is None:\n                temp = root.left\n                root = None\n                return temp\n            temp = self.getMinValueNode(root.right)\n            root.key = temp.key\n            root.right = self.delete_node(root.right,temp.key)\n\n        if root is None:\n            return root\n\n        # Update the balance factor of nodes\n        root.height = 1 + max(self.getHeight(root.left),\n                              self.getHeight(root.right))\n\n        balanceFactor = self.getBalanceFactor(root)\n\n        # Balance the tree\n        if balanceFactor > 1:\n            if self.getBalanceFactor(root.left) >= 0:\n                return self.rightRotate(root)\n            else:\n                root.left = self.leftRotate(root.left)\n                return self.rightRotate(root)\n        if balanceFactor < -1:\n            if self.getBalanceFactor(root.right) <= 0:\n                return self.leftRotate(root)\n            else:\n                root.right = self.rightRotate(root.right)\n                return self.leftRotate(root)\n        return root","bbafa011":"# Exercise 10 - BTree - Insert Full & NonFull\n\nclass BTreeNode:\n    def __init__(self, leaf=False):\n        self.keys = []\n        self.child = []\n        self.leaf = leaf\n\n\nclass BTree:\n    def __init__(self, t):\n        self.root = BTreeNode(True)\n        self.t = t\n\n    # Insert key\n    def insert(self, k):\n        root = self.root\n        if len(root.keys) == (2 * self.t) - 1:\n            temp = BTreeNode()\n            self.root = temp\n            temp.child.insert(0, root)\n            self.split(temp, 0)\n            self.insert_non_full(temp, k)\n        else:\n            self.insert_non_full(root, k)\n\n    def insert_non_full(self, x, k):\n        i = len(x.keys) - 1\n        if x.leaf:\n            x.keys.append((None, None))\n            while i >= 0 and k[0] < x.keys[i][0]:\n                x.keys[i + 1] = x.keys[i]\n                i -= 1\n            x.keys[i + 1] = k\n        else:\n            while i >= 0 and k[0] < x.keys[i][0]:\n                i -= 1\n            i += 1\n            if len(x.child[i].keys) == (2 * self.t) - 1:\n                self.split(x, i)\n                if k[0] > x.keys[i][0]:\n                    i += 1\n            self.insert_non_full(x.child[i], k)","bbb5cf43":"### This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session"}}