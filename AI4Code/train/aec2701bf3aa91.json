{"cell_type":{"79552cc8":"code","a895331e":"code","e0714b04":"code","876f319f":"code","b2605118":"code","19ecb14a":"code","4286ef52":"code","58417e4c":"code","2d4f34f9":"code","cf56fa8f":"markdown","1a367a60":"markdown","3c55ddbb":"markdown","db96ec27":"markdown"},"source":{"79552cc8":"import cv2\nimport os\nimport numpy as np\nfrom tqdm import tqdm\nfrom glob import glob\nfrom matplotlib import pyplot as plt\nfrom random import randint, choice, choices, shuffle\nfrom copy import deepcopy","a895331e":"def plot_img(img, size=(7,7), title=\"\"):\n    '''Display one image in notebook'''\n    if isinstance(img, str):\n        img = load_img(img)\n    plt.figure(figsize=size)\n    plt.imshow(img[:,:,::-1])\n    plt.suptitle(title)\n    plt.show()\n\ndef plot_imgs(imgs, cols=5, rows=5, size=7, title=\"\", wspace=0):\n    '''Display multi image in notebook'''\n    if rows is None:\n        rows = len(imgs)\/\/cols + 1\n    H, W = imgs[0].shape[:2]\n    fig = plt.figure(figsize=(int(cols*size), int(rows*size*H\/W)))\n\n    for i, img in enumerate(imgs):\n        if isinstance(img, str):\n            img = load_img(img, size=300)\n        fig.add_subplot(rows, cols, i+1)\n        plt.subplots_adjust(wspace=wspace, hspace=wspace)\n        plt.imshow(img[:,:,::-1])\n    plt.suptitle(title)\n    plt.show()\n    \ndef generate_jigsaw_image(img, m=5, n=5):\n    '''C\u1eaft \u1ea3nh th\u00e0nh 1 t\u1eadp c\u00e1c m\u1ea3nh'''\n    H, W, _ = img.shape\n    Hp, Wp = H\/\/m, W\/\/n\n    all_pieces = []\n    \n    for i in range(0, m):\n        for j in range(0, n):\n            piece_img = img[i*Hp: (i+1)*Hp, j*Wp:(j+1)*Wp]\n            index = (i,j)\n            all_pieces.append({\n                'p_image': piece_img,\n                'src_index': index\n            })\n    return all_pieces","e0714b04":"def compute_edge_distance(edge1, edge2):\n    max_pixel = max([edge1.max(), edge2.max()])\n    edge1, edge2 = edge1\/max_pixel, edge2\/max_pixel\n    d1 = (np.abs(edge1 - edge2)**2).mean()\n    d2 = (np.abs(edge1[1:,:] - edge2[:-1,:])**2).mean()\n    d3 = (np.abs(edge2[1:,:] - edge1[:-1,:])**2).mean()\n    total_distance = d1+d2+d3\n    return total_distance\n\ndef compute_edge_distance_matrix(input_pieces):\n    '''\n    Args:\n        input_pieces: 1 list c\u00e1c m\u1ea3nh img \u0111\u00e3 \u0111\u01b0\u1ee3c x\u00e1o tr\u1ed9n\n    Returns:\n        LR_distance_matrix: \n            - Ph\u1ea7n t\u1eed M[i,j] l\u00e0 distance gi\u1eefa c\u1ea1nh tr\u00e1i c\u1ee7a m\u1ea3nh i v\u1edbi c\u1ea1nh ph\u1ea3i m\u1ea3nh j\n        TB_distance_matrix:\n            - Ph\u1ea7n t\u1eed M[i,j] l\u00e0 distance gi\u1eefa c\u1ea1nh tr\u00ean c\u1ee7a m\u1ea3nh i v\u1edbi c\u1ea1nh d\u01b0\u1edbi m\u1ea3nh j\n    '''\n    for i, piece_data in enumerate(input_pieces):\n        piece_img = piece_data['p_image']\n        piece_data['index'] = i\n        piece_data['l_edge'] = piece_img[:,1,:]  #left edge\n        piece_data['r_edge'] = piece_img[:,-1,:] # right edge\n        piece_data['t_edge'] = piece_img[1,:,:] # top edge\n        piece_data['b_edge'] = piece_img[-1,:,:] # bottom edge\n\n    all_left_edges = [piece_data['l_edge'] for piece_data in input_pieces]\n    all_right_edges = [piece_data['r_edge'] for piece_data in input_pieces]\n    all_top_edges = [piece_data['t_edge'] for piece_data in input_pieces]\n    all_bottom_edges= [piece_data['b_edge'] for piece_data in input_pieces]\n\n    # kh\u1edfi t\u1ea1o gi\u00e1 tr\u1ecb m\u1ed7i ph\u1ea7n t\u1eed b\u1eb1ng 1 gi\u00e1 tr\u1ecb m\u1eb7c \u0111\u1ecbnh l\u1edbn\n    L = len(input_pieces)\n    LR_distance_matrix = np.ones((L, L))*10000000\n    TB_distance_matrix = np.ones((L, L))*10000000\n\n    # T\u00ednh l\u1ea1i gi\u00e1 tr\u1ecb t\u1eebng ph\u1ea7n t\u1eed Matrix[i,j] tr\u00ean LR_distance_matrix\n    for i, l_edge in enumerate(all_left_edges):\n        for j, r_edge in enumerate(all_right_edges):\n            if i==j: continue\n            LR_distance_matrix[i,j] = compute_edge_distance(l_edge, r_edge)\n\n    # T\u00ednh l\u1ea1i gi\u00e1 tr\u1ecb t\u1eebng ph\u1ea7n t\u1eed Matrix[i,j] tr\u00ean TB_distance_matrix\n    for i, t_edge in enumerate(all_top_edges):\n        for j, b_edge in enumerate(all_bottom_edges):\n            if i == j: continue\n            TB_distance_matrix[i,j] = compute_edge_distance(t_edge, b_edge)\n    return LR_distance_matrix, TB_distance_matrix","876f319f":"def find_best_bottom_piece(top_id, TB_distance_matrix, topk=3, ignore_ids=[]):\n    '''\n    T\u00ecm topK m\u1ea3nh n\u1eb1m b\u00ean d\u01b0\u1edbi m\u1ea3nh top_id\n    Args:\n        top_id: m\u1ea3nh th\u1ee9 top_id, c\u1ea7n t\u00ecm m\u1ea3nh b\u00ean d\u01b0\u1edbi k\u1ec1 n\u00f3\n        TB_distance_matrix: Ph\u1ea7n t\u1eed M[i,j] l\u00e0 distance gi\u1eefa\n                            c\u1ea1nh tr\u00ean c\u1ee7a m\u1ea3nh i v\u1edbi c\u1ea1nh d\u01b0\u1edbi m\u1ea3nh j\n        topk: s\u1ed1 m\u1ea3nh t\u1ed1t nh\u1ea5t \u0111\u01b0\u1ee3c tr\u1ea3 v\u1ec1\n        ignore_ids: nh\u1eefng m\u1ea3nh \u0111\u01b0\u1ee3c lo\u1ea1i b\u1ecf\n    Return:\n        topK_ids: id c\u1ee7a K m\u1ea3nh n\u1eb1m d\u01b0\u1edbi t\u1ed1t nh\u1ea5t\n        topK_distance_values: gi\u00e1 tr\u1ecb distance t\u01b0\u01a1ng \u1ee9ng v\u1edbi K m\u1ea3nh.\n    '''\n    distances = TB_distance_matrix[:, top_id]\n    bottom_ids = (distances).argsort()\n    bottom_ids = [id for id in bottom_ids if (id not in ignore_ids)]\n    topK_ids = bottom_ids[:topk]\n    topK_distance_values = distances[topK_ids]\n    return topK_ids, topK_distance_values\n\ndef find_best_right_piece(left_id, LR_distance_matrix, topk=3, ignore_ids=[]):\n    '''\n    T\u00ecm topK m\u1ea3nh n\u1eb1m b\u00ean ph\u1ea3i m\u1ea3nh left_id\n    Args:\n        left_id: m\u1ea3nh th\u1ee9 left_id, c\u1ea7n t\u00ecm m\u1ea3nh b\u00ean ph\u1ea3i k\u1ec1 n\u00f3 \n        LR_distance_matrix: Ph\u1ea7n t\u1eed M[i,j] l\u00e0 distance gi\u1eefa\n                            c\u1ea1nh tr\u00e1i c\u1ee7a m\u1ea3nh i v\u1edbi c\u1ea1nh ph\u1ea3i m\u1ea3nh j\n        topk: s\u1ed1 m\u1ea3nh t\u1ed1t nh\u1ea5t \u0111\u01b0\u1ee3c tr\u1ea3 v\u1ec1\n        ignore_ids: nh\u1eefng m\u1ea3nh \u0111\u01b0\u1ee3c lo\u1ea1i b\u1ecf\n    Return:\n        topK_ids: id c\u1ee7a K m\u1ea3nh n\u1eb1m b\u00ean ph\u1ea3i t\u1ed1t nh\u1ea5t\n        topK_distance_values: gi\u00e1 tr\u1ecb distance t\u01b0\u01a1ng \u1ee9ng v\u1edbi K m\u1ea3nh.\n    '''\n    distances = LR_distance_matrix[:, left_id]\n    right_ids  = (distances).argsort()\n    right_ids = [id for id in right_ids if (id not in ignore_ids)]\n    topK_ids = right_ids[:topk] \n    topK_distance_values= distances[topK_ids]\n    return topK_ids, topK_distance_values\n\ndef find_best_right_bottom_img(top_id, left_id, TB_distance_matrix, LR_distance_matrix, topk=3, ignore_ids=[]):\n    '''\n    T\u00ecm topK m\u1ea3nh n\u1eb1m b\u00ean d\u01b0\u1edbi m\u1ea3nh top_id v\u00e0 b\u00ean ph\u1ea3i m\u1ea3nh left_id\n    Args:\n        left_id: m\u1ea3nh th\u1ee9 left_id, c\u1ea7n t\u00ecm m\u1ea3nh b\u00ean ph\u1ea3i k\u1ec1 n\u00f3 \n        LR_distance_matrix: Ph\u1ea7n t\u1eed M[i,j] l\u00e0 distance gi\u1eefa\n                            c\u1ea1nh tr\u00e1i c\u1ee7a m\u1ea3nh i v\u1edbi c\u1ea1nh ph\u1ea3i m\u1ea3nh j\n        TB_distance_matrix: Ph\u1ea7n t\u1eed M[i,j] l\u00e0 distance gi\u1eefa\n                            c\u1ea1nh tr\u00ean c\u1ee7a m\u1ea3nh i v\u1edbi c\u1ea1nh d\u01b0\u1edbi m\u1ea3nh j\n        topk: s\u1ed1 m\u1ea3nh t\u1ed1t nh\u1ea5t \u0111\u01b0\u1ee3c tr\u1ea3 v\u1ec1\n        ignore_ids: nh\u1eefng m\u1ea3nh \u0111\u01b0\u1ee3c lo\u1ea1i b\u1ecf\n    Return:\n        topK_ids: id c\u1ee7a K m\u1ea3nh t\u1ed1t nh\u1ea5t\n        topK_distance_values: gi\u00e1 tr\u1ecb distance t\u01b0\u01a1ng \u1ee9ng v\u1edbi K m\u1ea3nh.\n    '''\n    distances = TB_distance_matrix[:, top_id] + LR_distance_matrix[:, left_id]\n    bottom_right_ids = (distances).argsort()\n    bottom_right_ids = [id for id in bottom_right_ids if (id not in ignore_ids)]\n    topK_ids = bottom_right_ids[:topk]\n    topK_distance_values= distances[topK_ids]\/2\n    return topK_ids, topK_distance_values","b2605118":"M, N = 4, 4 #chia img th\u00e0nh 4x4\nsrc_img = cv2.imread('..\/input\/demo-shuffle-imgs\/imgs\/2.jpg')\nplot_img(src_img, title='Origin image')\n\n## chia src_img th\u00e0nh 1 list c\u00e1c m\u1ea3nh\nsrc_jigsaw_pieces = generate_jigsaw_image(src_img, M, N)\n## shuffle\/x\u00e1o tr\u1ed9n c\u00e1c m\u1ea3nh\ninput_pieces = deepcopy(src_jigsaw_pieces)\nshuffle(input_pieces)\npiece_imgs = [piece['p_image'] for piece in input_pieces]\nplot_imgs(piece_imgs, rows=M, cols=N, size=2, title='Crop and shuffle Image')","19ecb14a":"LR_distance_matrix, TB_distance_matrix = compute_edge_distance_matrix(input_pieces)\n\nfor left_id in range(2):\n    topK_ids, topK_distance_values = find_best_right_piece(left_id, LR_distance_matrix)\n    for right_id, distance in zip(topK_ids[:1], topK_distance_values[:1]):\n        imgs = [input_pieces[id]['p_image'] for id in [left_id, right_id]]\n        plot_imgs(imgs, size=4, wspace=0)","4286ef52":"class Grid:\n    def __init__(self, rows, cols, level=0, i=0, j=0):\n        self.rows = rows\n        self.cols = cols\n        self.level = level\n        self.cur_i = 0\n        self.cur_j = 0\n        self.piece_cells = rows*[cols*[None]]\n        self.previous_piece_ids = []\n        self.total_distance = 0\n        self.piece_id = []\n        \n    def add_new_piece(self, pid, distance):\n        if pid in self.previous_piece_ids:\n            return False\n\n        i, j = self.cur_i, self.cur_j\n        self.previous_piece_ids.append(pid)\n        self.piece_cells[i][j] = pid\n        self.total_distance += distance\n        \n        if self.cur_j == self.cols-1:\n            self.cur_j = 0\n            self.cur_i += 1\n        else:\n            self.cur_j += 1\n        self.level += 1\n        return True\n        \n    def find_next_piece_id(self, LR_distance_matrix, TB_distance_matrix):\n        if self.cur_i == 0:\n            left_id = self.piece_cells[self.cur_i][self.cur_j-1]\n            topK_ids, topK_distance = find_best_right_piece(left_id, LR_distance_matrix, ignore_ids=self.previous_piece_ids)\n        elif self.cur_j == 0:\n            top_id = self.piece_cells[self.cur_i - 1][self.cur_j]\n            topK_ids, topK_distance = find_best_bottom_piece(top_id, TB_distance_matrix, ignore_ids=self.previous_piece_ids)\n        else:\n            left_id = self.piece_cells[self.cur_i][self.cur_j-1]\n            top_id = self.piece_cells[self.cur_i - 1][self.cur_j]\n            topK_ids, topK_distance = find_best_right_bottom_img(\n                top_id, left_id,\n                TB_distance_matrix,\n                LR_distance_matrix,\n                ignore_ids=self.previous_piece_ids\n            )\n        return topK_ids, topK_distance\n    \n    def plot_grid(self, input_pieces):\n        imgs = [input_pieces[id]['p_image'] for id in self.previous_piece_ids]\n        plot_imgs(imgs, rows=self.rows, cols=self.cols, size=2)","58417e4c":"def search_best_match(input_pieces, LR_distance_matrix, TB_distance_matrix, M, N, n=2):\n    grids_in_level = {}\n    grids_in_level[0] = []\n    level = 0\n    topK_grid = 50\n\n    ## Init list of grid in level 0, i=j=0\n    for pid, piece_data in enumerate(input_pieces):\n        new_grid = Grid(rows=M, cols=N, level=0, i=0, j=0)\n        new_grid.add_new_piece(pid, distance=0)\n        grids_in_level[0].append(new_grid)\n\n    for i in range(M):\n        for j in range(N):\n            ## if level 0 -> skip\n            if i == 0 and j == 0: continue\n            ## at level > 0\n            level += 1\n            grids_in_level[level] = []\n            for grid in grids_in_level[level-1]:\n                topK_ids, topK_distances = grid.find_next_piece_id(LR_distance_matrix, TB_distance_matrix)\n                for pid, distance in zip(topK_ids, topK_distances):\n                    new_grid = deepcopy(grid)\n                    is_valid = new_grid.add_new_piece(pid, distance)\n                    if is_valid:\n                        grids_in_level[level].append(new_grid)\n            if level > M:\n                grids_in_level[level] = sorted(grids_in_level[level], key=lambda x: x.total_distance)\n                grids_in_level[level] = grids_in_level[level][:topK_grid]\n            \n    grids_in_level[level] = sorted(grids_in_level[level], key=lambda x: x.total_distance)\n    return grids_in_level[level][:n]","2d4f34f9":"M, N = 4,4\nfor img_fn in glob('..\/input\/demo-shuffle-imgs\/imgs\/*.jpg'):\n    src_img = cv2.imread(img_fn)\n    src_jigsaw_pieces = generate_jigsaw_image(src_img, M, N)\n    plot_img(src_img, title='Origin image')\n\n    input_pieces = deepcopy(src_jigsaw_pieces)\n    shuffle(input_pieces)\n    piece_imgs = [piece['p_image'] for piece in input_pieces]\n    plot_imgs(piece_imgs, rows=M, cols=N, size=2, title='Crop and shuffle Image')\n    \n    LR_distance_matrix, TB_distance_matrix = compute_edge_distance_matrix(input_pieces)\n    topK_best_grid = search_best_match(piece_imgs, LR_distance_matrix, TB_distance_matrix, M, N, n=1)\n    \n    for grid in topK_best_grid:\n        grid.plot_grid(input_pieces)","cf56fa8f":"## Demo find best right\/bottom piece of a any piece","1a367a60":"## Demo split image","3c55ddbb":"\u0110\u1ec3 d\u1ec5 minh h\u1ecda, gi\u1ea3 s\u1eed chia \u1ea3nh th\u00e0nh 4x4\n- M\u1ed7i c\u00e1ch s\u1eafp x\u1ebfp 16 m\u1ea3nh t\u01b0\u01a1ng \u1ee9ng v\u1edbi 1 Grid. Grid bao g\u1ed3m c\u00e1c cells, cells c\u00f3 s\u1ed1 l\u01b0\u1ee3ng (4,4). Gi\u00e1 tr\u1ecb kh\u1edfi t\u1ea1o bao \u0111\u1ea7u c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c cell \u0111\u1ec1u l\u00e0 None\n- Khi x\u1ebfp m\u1ea3nh th\u1ee9 x v\u00e0o v\u1ecb tr\u00ed [i,j] ===> cells[i,j] = x\n- M\u1ed7i khi x\u1ebfp th\u00eam 1 m\u1ea3nh v\u00e0o grid, level c\u1ee7a grid s\u1ebd t\u0103ng l\u00ean 1. T\u1ee9c level t\u0103ng d\u1ea7n t\u1eeb 0 \u0111\u1ebfn 16. Khi level = 16 t\u1ee9c l\u00e0 \u0111\u00e3 x\u1ebfp \u0111\u1ee7 16 m\u1ea3nh v\u00e0o grid.\n\nChi\u1ebfn l\u01b0\u1ee3c x\u1ebfp: x\u1ebfp t\u1eebng m\u1ea3nh v\u00e0o grid theo chi\u1ec1u t\u1eeb tr\u00e1i qua ph\u1ea3i, t\u1eeb tr\u00ean xu\u1ed1ng d\u01b0\u1edbi.\n- T\u1ea1i v\u1ecb tr\u00ed i=j=0 (level=0). Kh\u1edfi t\u1ea1o 16 grid t\u01b0\u01a1ng \u1ee9ng v\u1edbi c\u00e1ch x\u1ebfp 16 m\u1ea3nh v\u00e0o v\u1ecb tr\u00ed (0,0)\n- T\u1ea1i h\u00e0ng ngang \u0111\u1ea7u ti\u00ean, v\u1ecb tr\u00ed (i=0, j>0), level = l. T\u00ecm K m\u1ea3nh t\u1ed1t nh\u1ea5t cho v\u1ecb tr\u00ed(i,j) d\u1ef1a v\u00e0o m\u1ea3nh n\u1eb1m b\u00ean tr\u00e1i (i,j-1). (T\u00ecm d\u1ef1a tr\u00ean \u0111\u1ed9 \u0111o sai kh\u00e1c 2 c\u1ea1nh c\u1ee7a 2 \u1ea3nh)\n- T\u1ea1i h\u00e0ng d\u1ecdc \u0111\u1ea7u ti\u00ean, v\u1ecb tr\u00ed (i, j=0), level = l. T\u00ecm K m\u1ea3nh t\u1ed1t nh\u1ea5t cho (i,j) d\u1ef1a v\u00e0o m\u1ea3nh n\u1eb1m b\u00ean tr\u00ean (i-1,j)\n- T\u1ea1i nh\u1eefng v\u1ecb tr\u00ed kh\u00f4ng thu\u1ed9c 3 tr\u01b0\u1eddng h\u1ee3p tr\u00ean. T\u00ecm K m\u1ea3nh t\u1ed1t nh\u1ea5t cho v\u1ecb tr\u00ed (i,j) d\u1ef1a v\u00e0o m\u1ea3nh (i,j-1) v\u00e0 m\u1ea3nh (i-1,j)\n-  \u0110\u1ec3 gi\u1edbi h\u1ea1n kh\u00f4ng gian t\u00ecm ki\u1ebfm kh\u00f4ng b\u1ecb b\u00f9ng n\u1ed5 (16!). Ta \u00e1p d\u1ee5ng BeamSearch: sau m\u1ed7i level ch\u1ec9 gi\u1eef l\u1ea1i topK c\u00e1c grid c\u00f3 total_distance t\u1ed1t nh\u1ea5t (t\u1ee9c c\u00f3 t\u1ed5ng \u0111\u1ed9 sai kh\u00e1c c\u1ea1nh c\u00e1c m\u1ea3nh li\u1ec1n k\u1ec1 nh\u1ecf)","db96ec27":"### Chi\u1ebfn l\u01b0\u1ee3c t\u00ecm ki\u1ebfm"}}