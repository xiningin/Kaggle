{"cell_type":{"8632ba40":"code","b1f8b9f2":"code","e1371014":"code","b3b232da":"code","c25ace8b":"code","72811d70":"code","0151e732":"code","57fb56a4":"code","68c99fc0":"code","9aadd557":"code","9a2ca7e1":"code","7fe5d10b":"code","224ac620":"code","72e578bd":"code","a8da4ad3":"code","8f6ff22c":"code","0815f825":"code","733b70d5":"code","64c07522":"code","f4f6a3f5":"code","1fb31722":"code","e4946939":"code","a762e736":"code","fc8792df":"code","3534ce2f":"code","c79a38db":"markdown","fbfe6e7a":"markdown","68a1eb60":"markdown","6249f2c3":"markdown","110e25bf":"markdown","7002d888":"markdown","261a4b65":"markdown","6667e547":"markdown","6f5ebae4":"markdown","bcd49bc2":"markdown","90b6d882":"markdown","9b067836":"markdown","875dca9b":"markdown"},"source":{"8632ba40":"!pip install nltk\n!pip install keras\n!pip install gensim\n!pip install seaborn\n\nimport nltk\nnltk.download('brown')\nnltk.download('treebank')\nnltk.download('conll2000')\nnltk.download('punkt')\nnltk.download('universal_tagset')","b1f8b9f2":"# import libraries\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport re\nimport numpy as np\nimport nltk\nfrom nltk.tokenize import word_tokenize\nimport requests\nfrom nltk.tokenize import word_tokenize\n\nfrom gensim.models import KeyedVectors\n\nfrom keras.preprocessing.text import Tokenizer\nfrom keras.utils import to_categorical\nfrom keras.preprocessing.sequence import pad_sequences\nfrom keras.utils.vis_utils import plot_model\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\nfrom keras.layers import Embedding","e1371014":"# download ebook\nurl = \"https:\/\/www.gutenberg.org\/files\/24869\/24869-0.txt\"\nbook = requests.get(url)\ndata = book.text","b3b232da":"# let's look at the text\nprint(data[:500])","c25ace8b":"# subset the book from the first chapter, that ism INVOCATION - everything before first chapter is irrelevant data\nstart_index = re.search(\"invocation.\\(1\\)\", data, re.I)\nprint(start_index.start())","72811d70":"# Let's see how does the text look like\ndata = data[start_index.start():]","0151e732":"# let's look at the text\nprint(data[:500])","57fb56a4":"# define a function to clean text data\ndef clean_document(document, char_filter = r\"[^\\w]\"):\n    '''\n    input:\n    document          :  string\n    char_filter       :  regex pattern - removes those characters from the text that match the pattern\n\n    output: clean document\n    '''\n    \n    # convert words to lower case\n    document = document.lower()\n\n    # tokenise words\n    words = word_tokenize(document)\n\n    # strip whitespace from all words\n    words = [word.strip() for word in words]\n\n    # join back words to get document\n    document = \" \".join(words)\n\n    # remove unwanted characters\n    document = re.sub(char_filter, \" \", document)\n\n    # replace multiple whitespaces with single whitespace\n    document = re.sub(r\"\\s+\", \" \", document)\n\n    # strip whitespace from document\n    document = document.strip()\n\n    return document\n\ndata = clean_document(data)","68c99fc0":"# length of text\nwords = word_tokenize(data)\nprint(\"Number of words in document: {}\".format(len(words)))","9aadd557":"# use Keras' Tokenizer() function to encode text to integers\nword_tokeniser = Tokenizer()\nword_tokeniser.fit_on_texts([data])\nencoded_words = word_tokeniser.texts_to_sequences([data])[0]","9a2ca7e1":"# check the size of the vocabulary\nVOCABULARY_SIZE = len(word_tokeniser.word_index) + 1\nprint('Vocabulary Size: {}'.format(VOCABULARY_SIZE))","7fe5d10b":"sequences = []\nMAX_SEQ_LENGTH = 5  # X will have five words, y will have the sixth word\n\nfor i in range(MAX_SEQ_LENGTH, len(encoded_words)):\n    sequence = encoded_words[i-MAX_SEQ_LENGTH:i+1]\n    sequences.append(sequence)\nsequences = np.array(sequences)","224ac620":"print('Total number of training samples: {}'.format(len(sequences)))\nprint('\\nSample sequences: \\n{}'.format(sequences[0:3]))","72e578bd":"# divide the sequence into X and y\nsequences = np.array(sequences)\n\nX = sequences[:80000,:-1]  # assign all but last words of a sequence to X\ny = sequences[:80000,-1]   # assign last word of each sequence to y","a8da4ad3":"# Look at the first training example\nprint(\"Input of the first data point:\", X[0], \"\\n\")\nprint(\"Output of the first data point: [\", y[0], \"]\")","8f6ff22c":"y.shape","0815f825":"y = to_categorical(y, num_classes=VOCABULARY_SIZE)","733b70d5":"print(X.shape)\nprint(y.shape)","64c07522":"X = pad_sequences(X, maxlen=MAX_SEQ_LENGTH, padding='pre')\nprint('Input sequence length: {}'.format(MAX_SEQ_LENGTH))","f4f6a3f5":"# create model architecture\n\nEMBEDDING_SIZE = 100\n\n\nmodel = Sequential()\n\n# embedding layer\nmodel.add(Embedding(VOCABULARY_SIZE, EMBEDDING_SIZE, input_length = MAX_SEQ_LENGTH))\n\n# lstm layer 1\nmodel.add(LSTM(128, return_sequences=True))\n\n# lstm layer 2\nmodel.add(LSTM(128))\n\n# output layer\nmodel.add(Dense(VOCABULARY_SIZE, activation='softmax'))","1fb31722":"# compile network\nmodel.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\n  \n# summarize defined model\nmodel.summary()","e4946939":"# fit network\nmodel.fit(X, y, epochs=125, verbose=1, batch_size=256)","a762e736":"# generate a sequence from a language model\ndef generate_words(model, word_tokeniser, MAX_SEQ_LENGTH, seed, n_words):\n    \n    text = seed\n    \n    # generate n_words\n    for _ in range(n_words):\n        \n        # encode text as integers\n        encoded_words = word_tokeniser.texts_to_sequences([text])[0]\n        \n        # pad sequences\n        padded_words = pad_sequences([encoded_words], maxlen=MAX_SEQ_LENGTH, padding='pre')\n        \n        # predict next word\n        prediction = model.predict_classes(padded_words, verbose=0)\n        \n        # convert predicted index to its word\n        next_word = \"\"\n        for word, i in word_tokeniser.word_index.items():\n            if i == prediction:\n                next_word = word\n                break\n        \n        # append predicted word to text\n        text += \" \" + next_word\n        \n    return text","fc8792df":"# text generation using first model - model without word embeddings\nseed_text = \"rama never told anyone about\"\nnum_words = 100\nprint(generate_words(model, word_tokeniser, MAX_SEQ_LENGTH, seed_text, num_words))","3534ce2f":"# text generation using first model - model without word embeddings\nseed_text = \"how are you doing\"\nnum_words = 100\nprint(generate_words(model, word_tokeniser, MAX_SEQ_LENGTH, seed_text, num_words))","c79a38db":"There are 80000 sequences (data points) in total.\n\nRemember that to use an RNN data has to be of the shape (#samples, #timesteps, #features)\n\nIn X, the third dimension, that is, number of features is missing because we're going to use the Keras' Embedding Layer. Hence we don't need to explicitly reshape the data to incorporate the third dimension. That will be done automatically by Keras.\n\nIn y, the second dimension is missing, that is, the number of timesteps because y is not a sequence, it's just a single word. The number of features are represented by a one-hot encoded vector whose length is the VOCABULARY_SIZE.","fbfe6e7a":"### Let's look at some text generations","68a1eb60":"## Clean text","6249f2c3":"## Divide data in X and y","110e25bf":"### Create sequences\n\nIn each training sample, X will have a sequence of 5 words and y will have the sixth word. In other words, this means that use previous five words of a sequence to predict next word.","7002d888":"### One-hot encode y","261a4b65":"### Pad sequences","6667e547":"## Convert characters to integers","6f5ebae4":"# LSTM","bcd49bc2":"# Preprocess data","90b6d882":"# Generate text","9b067836":"# Notebook Overview\n1. Preprocess data\n2. Build LSTM model\n3. Generate text","875dca9b":"# Text generation using RNN - Word Level\n\nTo generate text using RNN, we need a to convert raw text to a supervised learning problem format.\n\nTake, for example, the following corpus:\n\n\"Her brother shook his head incredulously. He was not aware of the situation at all.\"\n\nFirst we need to divide the data into tabular format containing input (X) and output (y) sequences. In case of a character level model, the X and y will look like this:\n\n|      X                |  Y      |\n|-----------------------|---------|\n|    < word1 >< word2 > | < word3 > |\n|    Her brother        |  shook  |\n|    brother shook      |  his    |\n|    shook his          |  head   |\n|    his head           | incredulously |\n|    head incredulously |    .    |\n|    ..                 |    .    |\n|    situation at       |  all    |\n|    at all             |    .    |\n\nNote that in the above problem, the sequence length of **X is two words** and that of **y is one word**. Hence, this is a many-to-one architecture. We can, however, change the number of input words to any number depending on the problem.\n\nA model is trained on such data. To generate text, we simply give the model any two words using which it predicts the next word. Then it appends the predicted word to the input sequence (to the extreme right of the sequence) and discards the first word (word on extreme left of the sequence). Then it predicts again using the new sequence and the cycle continues until a fix number of iterations. An example is shown below:\n\nSeed text: \"Did I\"\n\n|      X                                            |  Y                       |\n|---------------------------------------------------|--------------------------|\n|                        Did I                      |    < predicted word 1 >  |\n|               I < predicted word 1 >              |    < predicted word 2 >  |\n|       < predicted word 1 > < predicted word 2 >   |    < predicted word 3 >  |\n|       < predicted word 2 > < predicted word 3 >   |    < predicted word 4 >  |\n|                      ...                          |            ...           | "}}