{"cell_type":{"ccaf2351":"code","3311fd4a":"code","dd005ca9":"code","6b44e32f":"code","c346a993":"code","e895c948":"code","79cb6c59":"code","7b2bc254":"code","b94b516f":"code","b5b965a9":"code","b4f27500":"code","3ece61d5":"code","4239ee9e":"code","a0594047":"code","d74c1f17":"code","4554eb71":"code","08756fc5":"code","e58bad6b":"code","7a2024d1":"code","2b420409":"code","cfb2609f":"code","42d514b2":"markdown","5ad95f44":"markdown","4538b15d":"markdown","966ec54f":"markdown","c7a334f9":"markdown","b5e62d73":"markdown","8ee0a7de":"markdown","1ceb02d2":"markdown","633702f1":"markdown","b698995c":"markdown","c1fb20bb":"markdown","23968fbb":"markdown","7888d701":"markdown","d55491c5":"markdown"},"source":{"ccaf2351":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport json\nfrom sqlite3 import dbapi2 as sq3\nfrom pathlib import Path\nfrom collections import OrderedDict\n\n# import tensorflow as tf\n# from tensorflow import keras\n\nfrom time import time\nfrom IPython.display import clear_output\n\nimport warnings\nwarnings.filterwarnings('ignore')","3311fd4a":"#Dataset Doc: https:\/\/www.yelp.com\/dataset\/documentation\/main\n#Data Paths\nREVIEW_PATH = '\/kaggle\/input\/yelp-dataset\/yelp_academic_dataset_review.json'      #Contains full review text data including the user_id that wrote the review and the business_id the review is written for.\nCHECKIN_PATH = '\/kaggle\/input\/yelp-dataset\/yelp_academic_dataset_checkin.json'    #Checkins on a business.\nBUSINESS_PATH = '\/kaggle\/input\/yelp-dataset\/yelp_academic_dataset_business.json'  #Contains business data including location data, attributes, and categories.\nTIP_PATH = '\/kaggle\/input\/yelp-dataset\/yelp_academic_dataset_tip.json'            #Tips written by a user on a business. Tips are shorter than reviews and tend to convey quick suggestions.\nUSER_PATH = '\/kaggle\/input\/yelp-dataset\/yelp_academic_dataset_user.json'          #User data including the user's friend mapping and all the metadata associated with the user.\n\n# Functions to load data from json format\n#ref: https:\/\/www.kaggle.com\/hexianwang\/yelp-data\ndef load_rows(file_path, nrows=None, only_return_count=False, verbose=True):\n    \"\"\"\n    Returns dataframe from json file\n    \"\"\"\n    tic = time()\n    with open(file_path) as json_file:\n        count = 0\n        objs = []\n        line = json_file.readline()\n        while (nrows is None or count<nrows) and line:\n            count += 1\n            if not only_return_count:\n                obj = json.loads(line)\n                objs.append(obj)\n            line = json_file.readline()\n        toc = time()\n        if verbose:\n            print(file_path.split('\/')[-1], 'loaded. Count =', count, ', Time =', round(toc-tic,2), 'secs.')\n        \n        if only_return_count:\n            return count\n        \n        return pd.DataFrame(objs)\n    \n    \n#data generator to load data in chunks\ndef load_rows_gen(file_path, nrows=1e6, verbose=True):\n    \"\"\"\n    Returns data in chunks\n    \"\"\"\n    with open(file_path) as json_file:\n        line = json_file.readline()\n        total = 0\n        while line:\n            count = 0\n            objs = []\n            tic = time()\n            while count<nrows and line:\n                count+=1\n                obj = json.loads(line)\n                objs.append(obj)\n                line = json_file.readline()\n                total += count\n            toc = time()\n            print('Loaded chunk of size:', count, \", Time =\", round(toc-tic,2), 'secs.')\n            yield pd.DataFrame(objs)","dd005ca9":"user_df_head = load_rows(USER_PATH, 5)\nuser_df_head","6b44e32f":"review_df_head = load_rows(REVIEW_PATH, 5)\nreview_df_head","c346a993":"business_df_head = load_rows(BUSINESS_PATH, 5)\nbusiness_df_head.head()","e895c948":"checkin_df_head = load_rows(CHECKIN_PATH, 5)\ncheckin_df_head","79cb6c59":"tip_df_head = load_rows(TIP_PATH, 5)\ntip_df_head","7b2bc254":"# Functions to work with db2api from sqlite3\n\nPATHSTART = \".\"\ndef get_db(dbfile):\n    #get connection to db\n    sqlite_db = sq3.connect(Path(PATHSTART)\/ dbfile)\n    return sqlite_db\n\ndef init_db(dbfile, schema):\n    #create db a\/c to schema\n    db = get_db(dbfile)\n    \n    #execute sql code\n    c = db.cursor()\n    c.executescript(schema)\n    \n    #make commit\n    db.commit()\n    return db\n\ndef make_query(sel):\n    c = db.cursor().execute(sel)\n    return c.fetchall()\n\nfrom collections import OrderedDict\ndef make_frame(list_of_tuples, legend):\n    framelist=[]\n    for i, cname in enumerate(legend):\n        framelist.append((cname,[e[i] for e in list_of_tuples]))\n    return pd.DataFrame.from_dict(OrderedDict(framelist)) ","b94b516f":"#Table Schema for tables in our SQLite database\n\nusers_schema = \"\"\"\nDROP TABLE IF EXISTS \"users\";\n\nCREATE TABLE \"users\" (\n    \"user_id\" INTEGER PRIMARY KEY NOT NULL,\n    \"name\" VARCHAR,\n    \"review_count\" INTEGER,\n    \"yelping_since\" TIMESTAMP,\n    \"useful\" INTEGER,\n    \"funny\" INTEGER,\n    \"cool\" INTEGER,\n    \"elite\" VARCHAR,\n    \"friends\" VARCHAR,\n    \"fans\" INTEGER,\n    \"average_stars\" FLOAT,\n    \"compliment_hot\" INTEGER,\n    \"compliment_more\" INTEGER, \n    \"compliment_profile\" INTEGER,\n    \"compliment_cute\" INTEGER,\n    \"compliment_list\" INTEGER,\n    \"compliment_note\" INTEGER,\n    \"compliment_plain\" INTEGER,\n    \"compliment_cool\" INTEGER,\n    \"compliment_funny\" INTEGER,\n    \"compliment_writer\" INTEGER,\n    \"compliment_photos\" INTEGER\n);\n\"\"\"\nbusinesses_schema=\"\"\"\nDROP TABLE IF EXISTS \"businesses\";\n\nCREATE TABLE \"businesses\" (\n    \"business_id\" INTEGER PRIMARY KEY NOT NULL,\n    \"name\" VARCHAR,\n    \"address\" VARCHAR,\n    \"city\" VARCHAR,\n    \"state\" VARCHAR,\n    \"postal_code\" VARCHAR,\n    \"latitude\" FLOAT,\n    \"longitude\" FLOAT,\n    \"stars\" FLOAT,\n    \"review_count\" INTEGER,\n    \"is_open\" BOOLEAN,\n    \"categories\" VARCHAR,\n\"\"\"\nreviews_schema = \"\"\"\nDROP TABLE IF EXISTS \"reviews\";\n\nCREATE TABLE \"reviews\" (\n    \"review_id\" VARCHAR PRIMARY KEY,\n    \"user_id\" INTEGER,\n    \"business_id\" INTEGER,\n    \"stars\" FLOAT,\n    \"useful\" INTEGER,\n    \"funny\" INTEGER,\n    \"cool\" INTEGER,\n    \"text\"  VARCHAR,\n    \"date\" TIMESTAMP,\n    \n    \n    FOREIGN KEY (user_id) REFERENCES users(user_id),\n    FOREIGN KEY (business_id) REFERENCES businesses(business_id)\n);\n\"\"\"\nschema_close = \");\"","b5b965a9":"#Load data about all businesses\nbusiness_df = load_rows(BUSINESS_PATH)\nbusiness_df.head()","b4f27500":"%%time\n\n#Here we preprocess our businesses data\ndef preprocess_business_df(df):\n    \"\"\"\n    Preprocess data from BUSINESS_PATH\n    returns final DataFrame\n    \"\"\"\n    #mask to only select businesses which are either Restaurant or serve Food\n    mask = df.categories.str.contains('Restaurant', na=False) | df.categories.str.contains('Food', na=False)\n    df = df[mask]\n    #Changing business_id to numbers\n    global businessid_to_idx\n    businessid_to_idx = {b_id : idx for idx, b_id in enumerate(df.business_id.unique())}\n    df.business_id = df.business_id.map(lambda x: businessid_to_idx[x])\n\n    #TDT\n    df.is_open = df.is_open.astype(bool)\n\n    # Exploding attributes [MultiCategorization]\n    attr = [col for col in df.attributes.explode().unique() if col is not None]\n    lst_of_attr_dict = []\n    for attr_dict in df.attributes:\n        if not attr_dict:\n            lst_of_attr_dict.append({})\n            continue\n\n        if 'BusinessParking' in attr_dict:\n            if type(attr_dict['BusinessParking']) == str:\n                attr_dict['BusinessParking'] = ('True' in attr_dict['BusinessParking'])\n\n        lst_of_attr_dict.append(attr_dict)\n    \n    attr_df = pd.DataFrame(lst_of_attr_dict, columns=attr)\n    for col in attr_df:\n        #Handling missing\n        #Strategy -> absence of attribute means restauratn doesn't have it\n        #ex. If parking is null then restaurant doesn't have parking\n        attr_df[col] = attr_df[col].fillna(False).astype(bool)\n    \n    df = pd.concat([df.reset_index().drop('index', axis=1), attr_df], axis=1)\n    df.drop(['attributes'], axis=1, inplace=True)\n    \n    #Exploding hours ie. getting opening and closing time for various days\n    lst_of_time = []\n    for time_dict in df.hours:\n        if not time_dict:\n            lst_of_time.append({})\n            continue\n        lst_of_time.append(time_dict)\n    time_df = pd.DataFrame(lst_of_time)\n    df = pd.concat([df, time_df], axis=1).drop('hours', axis=1)\n    \n    return df\n\nbusiness_df = preprocess_business_df(business_df)\nbusiness_df.head()","3ece61d5":"# Looking at overview of our data\nbusiness_df.info()","4239ee9e":"# Completing Business Table Schema\nfor bool_col in business_df.columns[12:51]:\n    businesses_schema += '    \\\"' + bool_col + '\\\"' + ' BOOLEAN,\\n'\nfor day in business_df.columns[51:]:\n    businesses_schema += '    \\\"' + day + '\\\"' + ' VARCHAR,\\n'\n    \nbusinesses_schema = businesses_schema[:-2] + schema_close","a0594047":"%%time\n#Create db\ndb = init_db(\"yelp_database.db\", users_schema+businesses_schema+reviews_schema)\n\n#business data to sql\nbusiness_df.to_sql('businesses', db, if_exists='append', index=False)\n\n#release memory\ndel business_df","d74c1f17":"#load data about users\nuser_df = load_rows(USER_PATH)\nuser_df.head()","4554eb71":"%%time\n#Preproccess user data\ndef preprocess_user_df(df):\n    #Changing user id to something more suitable for our analysis\n    global userid_to_idx\n    userid_to_idx = {user : idx for idx, user in enumerate(df.user_id.unique())}\n    df.user_id = df.user_id.map(lambda x: userid_to_idx[x])\n    #Changing friends ids to new int ids\n    df.friends = df.friends.map(lambda x : str([userid_to_idx[user] for user in x.split(',') if user in userid_to_idx]))\n    #TDT to datetime\n    df.yelping_since = pd.to_datetime(df.yelping_since)\n    df.elite = df.elite.replace('', np.nan)\n    return df\n\nuser_df = preprocess_user_df(user_df)","08756fc5":"%%time\n#Sending user data to SQL db\nuser_df.to_sql('users', db, if_exists='append', index=False)\n#Release memory\ndel user_df","e58bad6b":"%%time\n#Here we load data from reviews\n\n#size of review.json overpowers RAM hence we'll process data in chunks and store it to table\nfor data in load_rows_gen(REVIEW_PATH):\n    #transformations\n    data.user_id = data.user_id.apply(lambda key : userid_to_idx[key] if key in userid_to_idx else np.nan)\n    data.business_id = data.business_id.apply(lambda key : businessid_to_idx[key] if key in businessid_to_idx else np.nan)\n    data.date = pd.to_datetime(data.date)\n    data.dropna(inplace=True)\n    #sending chunk to sql\n    data.to_sql('reviews', db, if_exists='append', index=False)\n#del data","7a2024d1":"#Looking at last chunk\ndata.head()","2b420409":"data.info()","cfb2609f":"#Release memory\ndel data","42d514b2":"## Introduction\nRecommedation Systems are ubiquitous. They help you decide where to eat (zomato), what to buy (amazon), whom to marry(matrimony), what to listen(spotify). In this project we'll build a Restaurant Recommendation System using Collaborative Filtering from scratch. We have been given [Yelp Dataset](https:\/\/www.yelp.com\/dataset) which has information of various users and their reviews to various businesses. Our model would learn from this information and would recommend new options to our users.","5ad95f44":"### Importing Libraries","4538b15d":"## 1. Getting Data Ready\n![image.png](attachment:image.png)","966ec54f":"#### Links\n\n[2. Exploratory Data Analysis (EDA)](https:\/\/www.kaggle.com\/yashrajwani\/yelp-exploratory-data-analysis)\n\n[3. Restaurant Recommendation](https:\/\/www.kaggle.com\/yashrajwani\/yelp-restaurant-recommendation-system)","c7a334f9":"## Team\n\nThis is final project for ML1. Team members include:\n\n- Iniyan Nagaraju\n- Jameel Khan\n- Yashraj Wani\n- Aziza \n- Akshay Kumar\n- Gunakar Goswami","b5e62d73":"### Create SQLite database\nAs data size is more than what our RAM can handle.","8ee0a7de":"## Motivation\nDue to the sheer amount of information available on the internet users feel overwhelmed with number of options available. To deal with this problem websites have Recommendation Systems, which simplifies decision making on user's part by showing options user might like based on his purchase history. Recommedation Systems play a very important role in websites like Youtube, Amazon, Spotify most of their revenue is driven by it.","1ceb02d2":"## Project Structure\nThis project is divided in three jupyter notebooks.\n1. Getting Data Ready\n2. Exploratory Data Analysis (EDA)\n3. Modelling","633702f1":"## Aim\nWe have been given [Yelp Dataset](https:\/\/www.yelp.com\/dataset). In this notebook we'll go through data given to us, clean it and, save it so that we can use it for further steps. ","b698995c":"## Conclusion\n- We made a SQLite db from our data.\n- Our db has 3 tables:\n - reviews (has review info)\n - users (has user info)\n - businesses (has business info)\n- Made basic transformations like simple null handling, changing id, type casting.","c1fb20bb":"### Looking at data","23968fbb":"We'll be using User (details abouts user), Business (Details about business), and Review (users and their reviews for business) data.","7888d701":"### Loading Data","d55491c5":"# Restaurant Recommendation System"}}