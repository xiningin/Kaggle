{"cell_type":{"91acf59b":"code","3ddb07e4":"code","df2f8be2":"code","0e493b2e":"code","cc011f8b":"code","daef5cec":"code","512f9fb5":"code","7a2e95a5":"code","2bef9137":"markdown","94a03454":"markdown","0cd63088":"markdown","2e4e4220":"markdown","441db244":"markdown","3242af0d":"markdown","5a662ff3":"markdown","58e108fb":"markdown"},"source":{"91acf59b":"# 1. Enable Internet in the Kernel (Settings side pane)\n\n# 2. Curl cache may need purged if v0.1.6 cannot be found (uncomment if needed). \n# !curl -X PURGE https:\/\/pypi.org\/simple\/kaggle-environments\n\n# ConnectX environment was defined in v0.1.6\n!pip install 'kaggle-environments>=0.1.6'","3ddb07e4":"from kaggle_environments import evaluate, make, utils, agent\nfrom random import choice\n\nenv = make(\"connectx\", debug=True)\nenv.render()","df2f8be2":"def is_winning_board(b, m):\n    #takes as input a board (b) and the player (mark, as m) and returns True if the board has a winner and False if there is not yet a winner\n\n    #check for winner in the rows\n    for i_row in range(0,41, 7):\n        for i_col in range(0,4):\n            if b[i_row+i_col+0] == m and b[i_row+i_col+1] == m  and b[i_row+i_col+2] == m  and b[i_row+i_col+3] == m:\n                return True\n    \n    #check for winner in the cols\n    for i_row in range(0,3):\n        i_row = i_row * 7\n        for i_col in range(0, 7):\n            if b[i_row+i_col+0] == m and b[i_row+i_col+7] == m  and b[i_row+i_col+14] == m and b[i_row+i_col+21] == m:\n                return True\n    \n    #check for winner in the down-right diagonals\n    for i_row in range(0,3):\n        i_row = i_row * 7\n        for i_col in range(0, 4):\n            if b[i_row+i_col+0] == m and b[i_row+i_col+8] == m and b[i_row+i_col+16] == m and b[i_row+i_col+24] == m:\n                return True\n\n    #check for winner in the down-left diagonals\n    for i_row in range(0,3):\n        i_row = i_row * 7\n        for i_col in range(3, 7):\n            if b[i_row+i_col+0] == m and b[i_row+i_col+6] == m and b[i_row+i_col+12] == m and b[i_row+i_col+18] == m:\n                return True\n    \n    #board is not a winner\n    return False","0e493b2e":"def get_next_board(board, action, mark):\n    #given the current board and chosen action, returns the next board\n    cols = [board[x::7] for x in range(0, 7)]\n    col = cols[action]\n    \n    row = [str(int) for int in col]\n    row = ''.join(row)\n    row = row.rindex('0')\n    next_board = board.copy()\n    next_board[action+((row)*7)] = mark\n    \n    return next_board","cc011f8b":"class connect_board:\n    def __init__(self, current_board, mark, possible_moves = []):\n        self.current_board = current_board\n        self.mark = mark #mark is the player, either a 1 or 2\n        self.possible_moves = possible_moves\n        self.possible_boards = []\n        self.winning_move = None\n        self.blocking_move = None\n        self.best_move = None #placeholder, not used\n    \n    def get_possible_moves(self, configuration):\n        #up to 7 possible moves, checks if top row is empty in each col\n        self.possible_moves = [c for c in range(configuration.columns) if self.current_board[c] == 0]\n        \n    \n    def get_possible_boards(self):\n        #generate all possible boards\n        for move in self.possible_moves:\n            self.possible_boards.append(get_next_board(self.current_board, move, self.mark))\n        \n    def find_winning_move(self):\n        #make sure your # moves and # of boards are the same\n        assert len(self.possible_moves) == len(self.possible_boards), \"Moves don't equal boards\"\n        \n        #if a possible board is a winning board, then choose that\n        for board,move in zip(self.possible_boards, self.possible_moves):\n            if is_winning_board(board, self.mark):\n                self.winning_move = move\n    \n    def find_best_move():\n        #placeholder for later versions\n        pass\n    \n    def find_blocking_move(self):\n        #is there a move that would allow your opponent to win? Well, fill that space before they can!\n        self.blocking_move\n        mark = self.mark%2 + 1 #get the opponent's mark\n        moves = self.possible_moves.copy()\n        opp_board = connect_board(self.current_board, mark, moves)\n        opp_board.get_possible_boards()\n        opp_board.find_winning_move()\n        self.blocking_move = opp_board.winning_move\n        \n    def find_random_move(self, configuration):\n        #finds a random, valid move\n        self.random_move = choice([c for c in range(configuration.columns) if self.current_board[c] == 0])\n        #if the valid move gives opponent a winning move, then pick again\n        next_board = get_next_board(self.current_board, self.random_move, self.mark)\n        next_turn = connect_board(next_board, mark = self.mark%2 + 1)\n        next_turn.get_possible_moves(configuration)\n        next_turn.get_possible_boards()\n        next_turn.find_winning_move()\n        if next_turn.winning_move is not None:\n            #print(\"rerolling!\")\n            self.random_move = choice([c for c in range(configuration.columns) if self.current_board[c] == 0])\n        ","daef5cec":"def my_agent(observation, configuration, boards = []):\n    #if you're new to this competition, uncomment the following line of code\n    #print(observation)\n    #print(configuration)\n\n    #instantite a new class using the present board\n    current_board = connect_board(observation['board'], observation['mark'], possible_moves = [])\n    current_board.get_possible_moves(configuration)\n    current_board.get_possible_boards()\n    \n    #return winner if it exists\n    current_board.find_winning_move()\n    if current_board.winning_move is not None:\n        return current_board.winning_move\n    \n    #return blocker if it exists\n    current_board.find_blocking_move()\n    if current_board.blocking_move is not None:\n        return current_board.blocking_move\n         \n    #else return a random move\n    current_board.find_random_move(configuration)\n    return current_board.random_move","512f9fb5":"env.reset()\n# Play as the first agent against default \"random\" agent.\nenv.run([my_agent, \"random\"])\nenv.render(mode=\"ipython\", width=500, height=450)","7a2e95a5":"def mean_reward(rewards):\n    return sum(r[0] for r in rewards) \/ float(len(rewards))\n\n# Run multiple episodes to estimate its performance.\nprint(\"My Agent vs Random Agent:\", mean_reward(evaluate(\"connectx\", [my_agent, \"random\"], num_episodes=20)))\nprint(\"My Agent vs Negamax Agent:\", mean_reward(evaluate(\"connectx\", [my_agent, \"negamax\"], num_episodes=20)))","2bef9137":"# Evaluate Agent vs. Random and Negamax\nhttps:\/\/en.wikipedia.org\/wiki\/Negamax","94a03454":"# Helper Function(s)","0cd63088":"# Test your Agent (1 match vs. random)","2e4e4220":"# Create Board Class","441db244":"# Install kaggle-environments and create ConnectX environment","3242af0d":"# n = 1 Look ahead, using classes\n\nHello everyone! As I went along my journey of the ConnectX competition, I found a need to refactor my code and clean it up in order to allow myself to continue building. I thought it would be helpful for the community if I shared my refactored version, so here it is below :).\n\nContents\n* Load kaggle environment\n* Helper function(s)\n* Agent (player)\n* Test performance of the agent","5a662ff3":"# Summary\n\nObviously this is just a simple starter notebook and, while it can stand on its own against the random player, it struggles against Negamax. I hope you find this useful for you to build on!","58e108fb":"# Create an Agent"}}