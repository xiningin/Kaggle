{"cell_type":{"b1a90796":"code","a316b821":"code","e5eae1a7":"code","425c8f62":"code","daa7902c":"code","40cb0449":"code","17be7643":"code","836297c3":"code","e50248ce":"code","ba2c7b90":"code","f8525bd9":"code","32518dbd":"code","7670cde9":"code","180d1d25":"code","8d6c8961":"code","1734e395":"code","bba6c973":"code","1e589a41":"code","97a56f1a":"code","3799f356":"code","8e57ea01":"code","ff8f57cc":"code","0adc7fb3":"code","213c1810":"code","b8fe579c":"code","55e6a028":"code","28ccd800":"code","81c8f24a":"code","214d7860":"code","6d4bc856":"code","94695563":"code","bfee1656":"code","0d8b9dfd":"code","2f3414a8":"code","b1173258":"code","de1e5f1e":"code","0e926f38":"code","18dd88f3":"code","5ab23b95":"code","28e65c8e":"code","b879b2aa":"code","eb0a4172":"code","67c304b5":"code","6f87b490":"code","fec8104b":"code","8af66e24":"code","526899b9":"code","08fcf1e9":"code","41f46489":"code","90c8a7d4":"code","26ac024b":"code","02e885cb":"code","ee09ff16":"code","b735a808":"code","73ed8627":"code","4aad0df0":"code","576de4ac":"code","36b7edfb":"code","8d66cff0":"code","243d6b4b":"code","f0041a80":"code","726a7d32":"code","3e4ef475":"code","e04c62fb":"code","ad5a4c3c":"markdown","f6a2f2ff":"markdown","39ea231d":"markdown","b211a11b":"markdown","500d06ae":"markdown","f179a100":"markdown","0f7ce445":"markdown","0138ebf0":"markdown","cb0a5b9b":"markdown","3943213c":"markdown","3d83b80f":"markdown","57225059":"markdown","cd0fb73d":"markdown","de1d3e54":"markdown","ab1871c1":"markdown","bf613ff6":"markdown","36dd7bcb":"markdown","0acc2706":"markdown","6d2f07d6":"markdown","691d6db2":"markdown","d8e67903":"markdown","a4c54013":"markdown","6dbf4fca":"markdown","75fe1329":"markdown","27ad5fdb":"markdown","e260fc58":"markdown","07eefa83":"markdown","4057dc9f":"markdown","e2342d32":"markdown","4c2d2e3d":"markdown","de4294b1":"markdown","c3bb6562":"markdown","a8e55cf9":"markdown","35f9e6e5":"markdown","2560662c":"markdown","beb6d2d4":"markdown","1bc155e6":"markdown","8c6d5c6f":"markdown","46628283":"markdown","53074f7a":"markdown","6c72c46d":"markdown","1b8feafa":"markdown"},"source":{"b1a90796":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom scipy.stats import norm\nimport warnings\nwarnings.filterwarnings(action='ignore')\nplt.style.use('fivethirtyeight')\nimport featuretools as ft\nimport dask.dataframe as dd\nimport gc\ngc.enable()","a316b821":"%time\n\ntrain_d=dd.read_csv('..\/input\/train_V2.csv',blocksize=25e6)\n\n","e5eae1a7":"train=pd.read_csv('..\/input\/train_V2.csv',nrows=100000)\ntest=pd.read_csv(\"..\/input\/test_V2.csv\",)\ntest_id=test['Id']","425c8f62":"print('size of the training data',train.shape)","daa7902c":"train.columns","40cb0449":"train.head()","17be7643":"train.info()","836297c3":"train.isnull().sum()","e50248ce":"plt.figure()\nsns.distplot(train['winPlacePerc'],fit=norm)\nplt.show()","ba2c7b90":"plt.figure()\nsns.distplot(train['winPoints'],fit=norm)\nplt.show()","f8525bd9":"train_group=train.groupby('groupId',as_index=False)['winPlacePerc'].agg('mean')","32518dbd":"train_group.head()","7670cde9":"train[train['groupId']==2]['winPlacePerc']","180d1d25":"train_corr=train.drop(columns=['Id',\"matchId\",\"groupId\"])\n","8d6c8961":"plt.figure(figsize=(9,7))\n\nsns.heatmap(train_corr.corr(),linewidths=.1)\nplt.show()\nplt.savefig('corr')","1734e395":"plt.figure()\nsns.distplot(train['killPlace'],bins=50)\nplt.show()","bba6c973":"plt.figure(figsize=(9,7))\nmatch_dur=train.groupby('matchType')['matchDuration'].agg('mean')\nsns.barplot(x=match_dur.index,y=match_dur)\nplt.gca().set_xticklabels(match_dur.index,rotation='45')\nplt.gca().set_title('mean match-type duration')\nplt.show()\nplt.savefig('duration')","1e589a41":"plt.figure()\nsns.regplot(train['kills'].values,train['damageDealt'].values)\nplt.gca().set_ylabel('Damage dealt')\nplt.gca().set_xlabel('Total kills')\nplt.show()\n","97a56f1a":"print(\"Avergae no of enemy players knocked per game is\",train['DBNOs'].sum()\/len(train))","3799f356":"train_dbno=pd.DataFrame(train['DBNOs'].value_counts(),columns=['DBNOs'])\ndbno=train_dbno.iloc[:9,:]\ndbno.iloc[8]['DBNOs']=train_dbno.iloc[8:,:].sum()['DBNOs']\n","8e57ea01":"plt.figure(figsize=(9,7))\nsns.barplot(dbno.index,dbno.DBNOs)\nplt.gca().set_xticklabels([0,1,2,3,4,5,6,7,'8+'])\nplt.gca().set_xlabel('No of enemy players knocked')\nplt.gca().set_ylabel(\"count\")\nplt.show()\nplt.savefig(\"enemy_\")","ff8f57cc":"print(\"World record for the most number of DBNOs in a single game is\",train_dbno.shape[0])","0adc7fb3":"print(\"A player uses on an avergae {} boost items\".format(train['boosts'].sum()\/len(train)))","213c1810":"print(\"A average player kills {} players\".format(train['kills'].sum()\/len(train)))","b8fe579c":"print('A player uses on an average {}  heals'.format(train['heals'].sum()\/len(train)))","55e6a028":"print('A player uses on an average rides {} '.format(train['rideDistance'].sum()\/len(train)))","28ccd800":"fig,(ax1,ax2)=plt.subplots(1,2)\nfig.set_figwidth(10)\nsns.boxplot(train['headshotKills'],ax=ax1)\nsns.boxplot(train['kills'],ax=ax2)\nplt.show()","81c8f24a":"set1=set(i for i in train[(train['kills']>40) & (train['heals']==0)].index.tolist())","214d7860":"fig,(ax1,ax2)=plt.subplots(1,2)\nsns.distplot(train['headshotKills'],ax=ax1)\nsns.boxplot(train['headshotKills']\/train['kills'],ax=ax2)","6d4bc856":"train['move']=train['rideDistance']+train['swimDistance']+train['walkDistance']\ntest['move']=test['rideDistance']+test['swimDistance']+test['walkDistance']\nsns.distplot(train['move'])","94695563":"set2=set(i for i in train[(train['move']==0) & (train['kills']>20) ].index.tolist())","bfee1656":"\nfig,(ax1,ax2)=plt.subplots(1,2)\nfig.set_figwidth(15)\n\nsns.distplot(train['damageDealt'],ax=ax1)\nsns.boxplot(train['damageDealt'],ax=ax2)\nplt.show()","0d8b9dfd":"set3=set(i for i in train[(train['damageDealt']>4000) & (train['heals']<2)].index.tolist())","2f3414a8":"plt.figure()\nsns.boxplot(train['rideDistance'])\nplt.show()","b1173258":"roadkills=train['roadKills'].value_counts()[1:]\nsns.barplot(x=roadkills.index,y=roadkills)","de1e5f1e":"train['roadkillsrate']=(train['roadKills']\/train['kills']).fillna(0)\nsns.boxplot(train['roadkillsrate'])\n\nplt.show()","0e926f38":"set4=set(i for i in train[(train['rideDistance']>25000) & (train['roadkillsrate']>.4) ].index.tolist())","18dd88f3":"killstreak=pd.DataFrame(train['killStreaks'].value_counts())\nkillstreak.iloc[4]=killstreak.iloc[4:].sum()\nkillstreak=killstreak[:5]\nsns.barplot(killstreak.index,killstreak['killStreaks'])","5ab23b95":"fig,(ax1,ax2)=plt.subplots(1,2)\nfig.set_figwidth(10)\nsns.distplot(train['weaponsAcquired'],ax=ax1)\nsns.boxplot(train['weaponsAcquired'],ax=ax2)","28e65c8e":"set5=set(i for i in train[(train['killStreaks']>3) & (train['weaponsAcquired']> 30)].index.tolist())","b879b2aa":"set6=set(i for i in train[(train['killStreaks']>3) & (train['weaponsAcquired']> 30)].index.tolist())","eb0a4172":"sets=set1 | set2 | set3 | set4 | set5 | set6","67c304b5":"train.drop(train.index[list(sets)],inplace=True)","6f87b490":"train.drop(['roadkillsrate'],axis=1,inplace=True)\ntrain.columns.drop('winPlacePerc')==test.columns","fec8104b":"def new_features(df):\n    df['items']=df['boosts']+df['heals']\n    df['headshotKills_over_kills'] = df['headshotKills'] \/ df['kills']\n    df['headshotKills_over_kills'].fillna(0, inplace=True)\n    df['killPlace_over_maxPlace'] = df['killPlace'] \/ df['maxPlace']\n    df['killPlace_over_maxPlace'].fillna(0, inplace=True)\n    df['killPlace_over_maxPlace'].replace(np.inf, 0, inplace=True)\n    df['walkDistance_over_heals'] = df['walkDistance'] \/ df['heals']\n    df['walkDistance_over_heals'].fillna(0, inplace=True)\n    df['walkDistance_over_heals'].replace(np.inf, 0, inplace=True)\n    df['walkDistance_over_kills'] = df['walkDistance'] \/ df['kills']\n    df['walkDistance_over_kills'].fillna(0, inplace=True)\n    df['walkDistance_over_kills'].replace(np.inf, 0, inplace=True)\n    df['teamwork'] = df['assists'] + df['revives']\n    return df","8af66e24":"train=new_features(train)\ntest=new_features(test)","526899b9":"def feature_engineering(is_train=True):\n    if is_train: \n        print(\"processing train.csv\")\n        df = train\n    else:\n        print(\"processing test.csv\")\n        df = test\n    \n    target = 'winPlacePerc'\n    features = list(df.columns)\n    features.remove(\"Id\")\n    features.remove(\"matchId\")\n    features.remove(\"groupId\")\n    features.remove('matchType')\n    y = None\n    if is_train: \n        y = np.array(df.groupby(['matchId','groupId'])[target].agg('mean'), dtype=np.float64)\n        features.remove(target)\n\n    print(\"get group mean feature\")\n    agg = df.groupby(['matchId','groupId'])[features].agg('mean')\n    agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    \n    if is_train: df_out = agg.reset_index()[['matchId','groupId']]\n    else: df_out = df[['matchId','groupId']]\n\n    df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    df_out = df_out.merge(agg_rank, suffixes=[\"_mean\", \"_mean_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    print(\"get group max feature\")\n    agg = df.groupby(['matchId','groupId'])[features].agg('max')\n    agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    df_out = df_out.merge(agg_rank, suffixes=[\"_max\", \"_max_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    print(\"get group min feature\")\n    agg = df.groupby(['matchId','groupId'])[features].agg('min')\n    agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    df_out = df_out.merge(agg_rank, suffixes=[\"_min\", \"_min_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    print(\"get group size feature\")\n    agg = df.groupby(['matchId','groupId']).size().reset_index(name='group_size')\n    df_out = df_out.merge(agg, how='left', on=['matchId', 'groupId'])\n    \n    print(\"get match mean feature\")\n    agg = df.groupby(['matchId'])[features].agg('mean').reset_index()\n    df_out = df_out.merge(agg, suffixes=[\"\", \"_match_mean\"], how='left', on=['matchId'])\n    \n    print(\"get match size feature\")\n    agg = df.groupby(['matchId']).size().reset_index(name='match_size')\n    df_out = df_out.merge(agg, how='left', on=['matchId'])\n    \n    df_out.drop([\"matchId\", \"groupId\"], axis=1, inplace=True)\n\n    X = np.array(df_out, dtype=np.float64)\n    del df, df_out, agg, agg_rank\n    gc.collect()\n\n    return X, y\n    \nx_train, y = feature_engineering(True)\n\n","08fcf1e9":"test,z=feature_engineering(False)","41f46489":"from sklearn.preprocessing import MinMaxScaler\nscaler=MinMaxScaler(feature_range=(-1,1),copy=False).fit(x_train)\nx_train=scaler.transform(x_train)","90c8a7d4":"x_test=scaler.transform(test)","26ac024b":"\nfrom xgboost.sklearn import XGBRegressor\nfrom sklearn.model_selection import cross_val_score,KFold\nimport numpy as np\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.linear_model import Lasso,LinearRegression\nfrom sklearn import preprocessing\nfrom  sklearn.model_selection import RandomizedSearchCV,train_test_split\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.base import BaseEstimator, TransformerMixin, RegressorMixin, clone","02e885cb":"n_folds=2\n\ndef mbs(model):\n    kf=KFold(n_folds,shuffle=True,random_state=42).get_n_splits(x_train)\n    score=-cross_val_score(model,x_train,y,scoring='neg_mean_absolute_error',cv=kf)\n    return score\n   \n\n","ee09ff16":"lasso=Lasso(alpha=.005,random_state=1)","b735a808":"#mbs(lasso)","73ed8627":"params={'learning_rate':[.02,.03,.1],'min_child_weight':[4,6,8],'max_depth':[8,10],\"subsample\":[.6,.4],\"n_estimators\":[300,500]}\n","4aad0df0":"#xgb_grid=GridSearchCV(xgb,param_grid=params,cv=2,verbose=True,n_jobs=-1)\n#xgb_grid.fit(x_train,y)\n","576de4ac":"\n#xgb_grid.best_params_","36b7edfb":"xgb=XGBRegressor(learning_rate=.03,min_child_weight=4,max_depth=10,subsample=.4,n_estimators=500,n_jobs=-1)\n#mbs(xgb)\n","8d66cff0":"GBoost = GradientBoostingRegressor(n_estimators=600, learning_rate=0.05,\n                                   max_depth=4, max_features='auto',\n                                   min_samples_leaf=15, min_samples_split=5, \n                                   loss='huber', random_state =5)","243d6b4b":"class Average_models(BaseEstimator,RegressorMixin,TransformerMixin):\n    def __init__(self,models):\n        self.models=models\n    def fit(self,X,y):\n        self.models_=[clone(x) for x in self.models]\n        for model in self.models_:\n            model.fit(X,y)\n        return self\n    def predict(self,X):\n            predictions= np.column_stack([model.predict(X) for model in self.models_])\n            return np.mean(predictions,axis=1)","f0041a80":"#mbs(Average_models(models=(xgb,GBoost)))","726a7d32":"#avg=Average_models(models=(xgb,GBoost))\n#avg.fit(x_train,y)\n#y_test=avg.predict(x_test)","3e4ef475":"training,valid,ytraining,yvalid=train_test_split(x_train,y)\nxgb.fit(training,ytraining)\nlasso.fit(training,ytraining)\n\n\npred1=xgb.predict(valid)\npred2=lasso.predict(valid)\n\n\ntest_pred1=xgb.predict(test)\ntest_pred2=lasso.predict(test)\n\n\nstacked_predictions=np.column_stack((pred1,pred2))\nstacked_test_prediction=np.column_stack((test_pred1,test_pred2))\n\nmeta_model=LinearRegression()\nmeta_model.fit(stacked_predictions,yvalid)\nfinal=meta_model.predict(stacked_test_prediction)\n","e04c62fb":"df=pd.DataFrame({'id':test_id,'winPlacePerc':final},columns=['id','winPlacePerc'])\ncsv=df[['id','winPlacePerc']].to_csv('submission_stack3.csv',index=False)","ad5a4c3c":"### Loading libraries","f6a2f2ff":"- High roadkill rate","39ea231d":"- ######  Types of cheaters","b211a11b":"###### MinMax scaling","500d06ae":"<img src='https:\/\/cdn.mos.cms.futurecdn.net\/Vd89dcrLiXGQq4ocje2bTR-650-80.jpg'>","f179a100":"There are outliers in damageDealt.","0f7ce445":"###### GradientBoosting","0138ebf0":"###### XGBoost","cb0a5b9b":"###### Why killplace always shows a negative correlation ?","3943213c":"###### Using pandas","3d83b80f":"PUBG aimbots and hacks are probably the most annoying things out there. They will take control of a players aim and automatically target it towards opponents. This can be abused in multiple ways. The most obvious is that every bullet they fire that has a line of sight towards another player will hit, and is the explanation to why other players seem to be able to hit ridiculous cross map shots. ","57225059":"## Identifying cheaters","cd0fb73d":"###### Advanced stacking","de1d3e54":"- From this it is clear that **winPlacePer** which is our target variable is same in each group","ab1871c1":"##### Target variable distribution","bf613ff6":"#### Model","36dd7bcb":"# What is in this kernel ?","0acc2706":"The **Killplace** feature shows negative correlation between other features because      \nkillplace is the Ranking in match of number of enemy players killed.","6d2f07d6":"<img src=\"https:\/\/cdn.mos.cms.futurecdn.net\/36pdCgyXDgKmbqSpxnJ6Ue-650-80.png\">","691d6db2":"##### Missing values","d8e67903":"- ######  PUBG speed Hacks","a4c54013":"###### mean absolute error","6dbf4fca":"\n\nWith Dask and its dataframe construct, you set up the dataframe must like you would in pandas but rather than loading the data into pandas, this approach keeps the dataframe as a sort of \u2018pointer\u2019 to the data file and doesn\u2019t load anything until you specifically tell it to do so.\n\nSource: http:\/\/pythondata.com\/dask-large-csv-python\/\n","75fe1329":"- High ride distance","27ad5fdb":"#### Importing the dataset","e260fc58":"#### Basic description of the data","07eefa83":"\n- They might have high headshot rate with aimhacks","4057dc9f":"###### PUBG aimbots and hacks","e2342d32":"#### Feature engineering ","4c2d2e3d":"###### Making my submission","de4294b1":"###### Are they correlated ?","c3bb6562":"###### If you reached till here,please consider upvoting my kernel.Thank you.","a8e55cf9":"###### MatchType and duration","35f9e6e5":"###### Using dask","2560662c":"When it comes to PUBG cheats there are two types of hacks that are pretty common, aim hacks and speed hacks. Both are pretty self explanatory, one makes you speed round the map at a rapid pace, while the other will automatically make sure that your bullets always head towards an opponent. Then there are a number of more subtle cheats that aren\u2019t usually as obvious.","beb6d2d4":"- Less movement","1bc155e6":"- ###### Recoil Scripts ","8c6d5c6f":"- simple edta     \n- Identifying hacks and removing them     \n- Feature engineering     \n- Baseline models    ","46628283":"<img src=\"https:\/\/cdn.mos.cms.futurecdn.net\/pWwhZzoz8VSA3aYcnapvUo-650-80.jpg\">","53074f7a":"<img src='https:\/\/cdn.mos.cms.futurecdn.net\/LodXF3A7ZFaHt8qNyevcZc-650-80.jpg'>","6c72c46d":"There are 26 columns in our training data.","1b8feafa":"##### Stacking"}}