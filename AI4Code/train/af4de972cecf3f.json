{"cell_type":{"080b331e":"code","b7db8ce8":"code","661ec464":"code","8f533202":"code","67479f58":"code","cca72869":"markdown","91257be1":"markdown","29b1f34b":"markdown","fec6b65b":"markdown"},"source":{"080b331e":"# you should not import any other packages\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nimport numpy as np\nfrom sklearn.linear_model import SGDRegressor","b7db8ce8":"import numpy as np\nimport scipy as sp\nimport scipy.optimize\n\ndef angles_in_ellipse(num,a,b):\n    assert(num > 0)\n    assert(a < b)\n    angles = 2 * np.pi * np.arange(num) \/ num\n    if a != b:\n        e = (1.0 - a ** 2.0 \/ b ** 2.0) ** 0.5\n        tot_size = sp.special.ellipeinc(2.0 * np.pi, e)\n        arc_size = tot_size \/ num\n        arcs = np.arange(num) * arc_size\n        res = sp.optimize.root(\n            lambda x: (sp.special.ellipeinc(x, e) - arcs), angles)\n        angles = res.x\n    return angles","661ec464":"a = 2\nb = 9\nn = 50\n\nphi = angles_in_ellipse(n, a, b)\ne = (1.0 - a ** 2.0 \/ b ** 2.0) ** 0.5\narcs = sp.special.ellipeinc(phi, e)\n\nfig = plt.figure()\nax = fig.gca()\nax.axes.set_aspect('equal')\nax.scatter(b * np.sin(phi), a * np.cos(phi))\nplt.show()","8f533202":"X= b * np.sin(phi)\nY= a * np.cos(phi)\ntarget1 = [1] * len(X)\ntarget0 = [0] * len(X)","67479f58":"\nalphas=[0.0001, 1, 100]\noutlier = [(0,2),(21, 13), (-23, -15), (22,14), (23, 14)]\n\nplt.figure(figsize=(10,10))\n\n\nfor alpha in alphas:\n    \n    # Reassign X and Y for each alpha\n    X= b * np.sin(phi)\n    Y= a * np.cos(phi)\n    plt.figure(figsize=(20,5))\n    \n    for j,olt in enumerate(outlier):\n        plt.subplot(1, 5, j+1)\n        # Add outlier\n        X = (np.append(X, olt[0]))\n        Y = (np.append(Y, olt[1]))\n        \n        X1 = np.array([[i] for i in X])\n        Y1 = np.array([[i] for i in Y])\n        \n        model = SGDRegressor(alpha=alpha, eta0=0.001, learning_rate='constant',random_state=0)\n        model.fit(X1,Y1)\n        pred = model.predict(X1)\n        \n        #plot\n        plt.scatter(X,Y)\n        plt.plot(X1, pred)\n    plt.show()","cca72869":"<h1>Handle Outliers with proper regularization<\/h1>","91257be1":"Datapoints that we are considering to train our model","29b1f34b":"Here we have to add outliers in datapoints and train the model and check the effect of outlier with the help of plots","fec6b65b":"Here we can observe that as the number of outliers increases the plane is rotated towards the outliers but if we use proper value of alpha than we can reduce this rotation (We can reduce effect of outliers.)\n\nHere as the value of alpha increases, the rotation of planne is reduces. 100 is the best value of alpha where plane is less biased towards outliers"}}