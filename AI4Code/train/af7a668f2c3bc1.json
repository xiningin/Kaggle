{"cell_type":{"c667bca5":"code","88f95b1a":"code","2f3b6a07":"code","690d720a":"code","c12d5dfe":"code","600ea787":"code","de7902f1":"code","8632ef16":"code","ba9f11b9":"code","73d90c3c":"code","888fc7fd":"markdown","b609eded":"markdown","1c3d07a2":"markdown","76b00512":"markdown"},"source":{"c667bca5":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.style.use(\"seaborn-deep\")\n%matplotlib inline","88f95b1a":"#\"Date\",\"Level\",\"NumBlocks\",\"IsWin\",\"ElapsedTime\",\"Score\",\"Accuracy\"\n#\"9\/9\/2019 3:47:23 PM\",\"Level_468\",\"56\",\"True\",\"28.914\",\"4900\",\"0.3725966\"\n#\"9\/9\/2019 3:47:53 PM\",\"Level_469\",\"56\",\"True\",\"29.72704\",\"2800\",\"0.3271338\"\n#\"9\/9\/2019 3:48:13 PM\",\"Level_471\",\"39\",\"True\",\"20.75284\",\"2100\",\"0.3765845\"\n#\"9\/9\/2019 3:48:37 PM\",\"Level_494\",\"50\",\"True\",\"23.229\",\"4000\",\"0.3834174\"\n#\"9\/9\/2019 3:49:05 PM\",\"Level_495\",\"40\",\"True\",\"27.80006\",\"2000\",\"0.350372\"\n#\"9\/9\/2019 3:49:13 PM\",\"Level_530\",\"43\",\"False\",\"7.810999\",\"1350\",\"0.3234939\"\n#\"9\/9\/2019 3:49:30 PM\",\"Level_262\",\"36\",\"True\",\"16.548\",\"1800\",\"0.3528175\"","2f3b6a07":"# read the data, use Level and Date as multilevel index, and parse the data.  Sort by level, then date.\ndf = pd.read_csv(\"..\/input\/GameStats.csv\", index_col=['Level', 'Date'], parse_dates=['Date']).sort_index()\n# Compute difficulty by level and append to dataframe: 1000 * fraction of wins\ng = df.groupby(level=\"Level\")['IsWin']\ns=np.round((1-g.sum()\/g.count())*1000)\n#also append 3 sigma value: 99.7% confidence interval based on number of samples\ns = pd.DataFrame({\"Difficulty\":s.apply(lambda x:np.int(x)), \"3 sigma\":3*np.sqrt((1-g.sum()\/g.count())*(g.sum()\/g.count())*g.count())})\ndf=df.merge(s, left_index=True, right_index=True)\n#Append number of samples per level\ns = np.round(g.count())\ns = pd.DataFrame({\"Count\":s.apply(lambda x:np.int(x))})\ndf=df.merge(s, left_index=True, right_index=True)\ndf.info()","690d720a":"df.head()","c12d5dfe":"#compute summary statistics per level\n#start with mean difficulty of each level\nmeans = df.groupby(level=\"Level\").mean().sort_values('Difficulty')\n#try to determine the value of \"Accuracy\" such that when playing the level\n# at this accuracy, it has a 50% chance of winning this level.\nmeans['ThresholdAccuracy'] = 0\nfor level in means.index:\n    l = df.loc[level]\n    r = np.linspace(l.Accuracy.min(), l.Accuracy.max(),100)\n    for x in r:\n        left = l[l['Accuracy'] < x]    \n        right = l[l['Accuracy'] > x]    \n        if left['IsWin'].sum() >= right['IsWin'].sum():\n            means.loc[level,'ThresholdAccuracy']  = x\n            break\nmeans","600ea787":"#check that the Difficulty depends more on the actual level difficulty than on the accuracy of the autoplay\nfrom sklearn import linear_model\nmodel = linear_model.LinearRegression()\nX=means[['Accuracy']]\ny=means['Difficulty']\nmodel.fit(X,y)\nprint(model.coef_, model.intercept_, means['Accuracy'].corr(means['Difficulty']))\ny_pred = model.predict(X)\nsns.regplot(means['Accuracy'], means['Difficulty'])","de7902f1":"#Level difficulties with 3-sigma error intervals\n#As you can see, statistically, many levels cannot be distinguished in difficulty without far more trials\nplt.figure(figsize=(20,6))\nplt.bar(means.index, means['Difficulty'], yerr=means['3 sigma'], capsize=10)","8632ef16":"# how many trials by level: between about 300 and 500\nplt.figure(figsize=(20,6))\nplt.bar(means.index, means['Count'])","ba9f11b9":"# expect ThresholdAccuracy and Difficulty to correlate very well, so the former can be an alternative to the latter\nsns.regplot(means['ThresholdAccuracy'], means['Difficulty'])\nmeans['ThresholdAccuracy'].corr(means['Difficulty'])","73d90c3c":"#the author used this to determine which range of accuracies should be chosen on the next test.  Between .35 and .38 seems to cover all the difficulty levels well.\nmeans['ThresholdAccuracy'].min(),means['ThresholdAccuracy'].max()","888fc7fd":"The author is in the process of creating a blockbreaker-like game, in which the jumping-off point is the \"Block Breaker\" section of the Udemy course, [Complete C# Unity Developer 2D: Learn to Code Making Games](https:\/\/www.udemy.com\/share\/1000PUA0EacVlURH4=\/)\n\nAfter making lots of levels, the author needed to sort them by difficulty.  How does one measure the difficulty of a level?  A first-cut solution is \nto make an auto-play bot that is not perfect, and see how well the bot does on each level, using thousands of trials.\n\n[Here is a video](https:\/\/youtu.be\/AVHsnsCWcU4) of the game in auto-play action.","b609eded":"The unity game outputs a log file (GameStats.csv), which looks something like this:","1c3d07a2":"# Statistics on a Blockbreaker-like Game","76b00512":"The fields are:\n\n* Date: date and time the game was auto-played\n* Level: the name of the level (the 3-digit number is an estimate of the difficulty from a previous run, no longer valid after tweaking)\n* NumBlocks: how many blocks have to be broken to win the level\n* IsWin: True if autoplay broke all the blocks, False if the ball fell past the paddle.\n* ElapsedTime: Seconds until either won or lost (game is played at 4x speed, so multiply by 4 to get an estimate of how long a human might play it)\n* Score: total score when the game was won or lost\n* Accuracy: the autoplay is tuned with a randomly-chosen accuracy.  Higher numbers are more likely to win.\n"}}