{"cell_type":{"c8fe25fb":"code","98ec3e32":"code","3bd63b55":"code","706a4a31":"code","56958d04":"code","2e18cefb":"code","9415e34c":"code","58cd1e85":"code","8432c211":"code","9384b8fa":"code","fedc7a52":"code","8f8f9735":"code","605bc3cc":"code","16eedd51":"code","fd4f8589":"code","981f92fd":"code","9a775272":"code","7c3cdf85":"code","0f1b7968":"code","76d15d22":"code","444f41b2":"code","fff54fe6":"code","92ecffad":"code","2aed59f3":"code","27e6af65":"code","080fdf81":"code","4a0ac943":"code","c9be4c24":"code","0333e3d4":"code","dad0a24f":"code","c0d9f002":"code","a1e60a51":"markdown"},"source":{"c8fe25fb":"import  os\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torchvision.datasets import ImageFolder\nfrom torchvision.transforms import ToTensor\nfrom torch.utils.data import random_split\nfrom torchvision.utils import make_grid\nfrom torch.utils.data.dataloader import DataLoader\n%matplotlib inline","98ec3e32":"data_dir = \"..\/input\/fruits\/fruits-360\"\nprint('folders : ',os.listdir(data_dir))\nclasses = os.listdir(data_dir + \"\/Training\")\nprint(classes)","3bd63b55":"dataset = ImageFolder(data_dir + '\/Training', transform=ToTensor())","706a4a31":"img,label = dataset[0]\nprint(img.shape,label)\nimg","56958d04":"len(dataset)","2e18cefb":"test_dataset = ImageFolder(data_dir + \"\/Test\", transform = ToTensor())\nlen(test_dataset)","9415e34c":"import matplotlib.pyplot as plt\n\ndef show_example(img,label):\n    print('label:', dataset.classes[label],\"(\"+str(label)+\")\")\n    plt.imshow(img.permute(1,2,0))\n    \nshow_example(*dataset[0])    ","58cd1e85":"show_example(*dataset[7699])","8432c211":"val_size = 6000\ntrain_size = len(dataset) - val_size\n\ntrain_ds, val_ds = random_split(dataset,[train_size,val_size])\n\nlen(train_ds), len(val_ds)","9384b8fa":"batch_size = 128\ntrain_dl = DataLoader(train_ds, batch_size, shuffle = True, num_workers = 4, pin_memory = True)\nval_dl = DataLoader(val_ds, batch_size*2, num_workers=4, pin_memory=True)\ntest_dl = DataLoader(test_dataset, batch_size*2, num_workers=4, pin_memory = True)","fedc7a52":"def show_batch(dl):\n    for images,labels in dl:\n        fig,ax = plt.subplots(figsize=(12,6))\n        ax.set_xticks([]); ax.set_yticks([])\n        ax.imshow(make_grid(images,nrow=16).permute(1,2,0))\n        break\n        \n        \nshow_batch(train_dl)        \n        ","8f8f9735":"def accuracy(outputs, labels):\n    _,preds = torch.max(outputs,dim=1)\n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds))","605bc3cc":"class Base(nn.Module):\n    def training_step(self,batch):\n        images,labels = batch\n        out = self(images)\n        loss = F.cross_entropy(out,labels)\n        return loss\n    \n    \n    def validation_step(self,batch):\n        images,labels = batch\n        out = self(images)\n        loss = F.cross_entropy(out,labels)\n        acc = accuracy(out,labels)\n        return {'val_loss': loss.detach(),'val_acc':acc}\n    \n    def validation_epoch_end(self,outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()\n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()\n        return {'val_loss':epoch_loss.item(),'val_acc':epoch_acc.item()}\n    \n    \n    def epoch_end(self,epoch,result):\n        print(\"Epoch [{}], val_loss:{:.4f}, val_acc:{:.4f}\".format(epoch, result['val_loss'], result['val_acc']))","16eedd51":"def evaluate(model,val_loader):\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func = torch.optim.SGD):\n    history = []\n    optimizer = opt_func(model.parameters(),lr)\n    for epoch in range(epochs):\n        for batch in train_loader:\n            loss = model.training_step(batch)\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n            \n        result = evaluate(model,val_loader)\n        model.epoch_end(epoch, result)\n        history.append(result)\n        \n    return history    ","fd4f8589":"torch.cuda.is_available()","981f92fd":"def get_default_device():\n    if torch.cuda.is_available():\n        return torch.device('cuda')\n    else:\n        return torch.device('cpu')","9a775272":"device = get_default_device()\ndevice","7c3cdf85":"def to_device(data,device):\n    if isinstance(data,(list,tuple)):\n        return [to_device(x,device) for x in data]\n    return data.to(device,non_blocking=True)\n\n\nclass DeviceDataLoader():\n    def __init__(self,dl,device):\n        self.dl = dl\n        self.device = device\n        \n    def __iter__(self):\n        for b in self.dl:\n            yield to_device(b,self.device)\n            \n    def __len__(self):\n        return len(self.dl)","0f1b7968":"train_loader = DeviceDataLoader(train_dl,device)\nval_loader  = DeviceDataLoader(val_dl,device)\ntest_loader = DeviceDataLoader(test_dl,device)","76d15d22":"input_size = 3*100*100\noutput_size = 131\nhidden_size = [512,1024,256]","444f41b2":"class FirstModel(Base):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = nn.Linear(input_size,hidden_size[0])\n        self.linear2 = nn.Linear(hidden_size[0],hidden_size[1])\n        self.linear3 = nn.Linear(hidden_size[1],hidden_size[2])\n        self.linear4 = nn.Linear(hidden_size[2],output_size)\n        \n        \n    def forward(self,xb):\n        out = xb.view(xb.size(0),-1)\n        out = self.linear1(out)\n        out = F.relu(out)\n        out = self.linear2(out)\n        out = F.relu(out)\n        out = self.linear3(out)\n        out = F.relu(out)\n        \n        out = self.linear4(out)\n        return out","fff54fe6":"model = to_device(FirstModel(),device)","92ecffad":"num_epochs = 5\nopt_func = torch.optim.Adam\nlr =0.001","2aed59f3":"history = fit(num_epochs, lr,model,train_loader,val_loader,opt_func)","27e6af65":"def plot_losses(histroy):\n    losses = [x['val_loss'] for x in history]\n    plt.plot(losses,'-x')\n    plt.xlabel('epoch')\n    plt.ylabel('loss')\n    plt.title('Loss vs No of epochs')","080fdf81":"plot_losses(history)","4a0ac943":"def plot_accuracies(history):\n    accuracies = [x['val_acc'] for x in history]\n    plt.plot(accuracies,'-x')\n    plt.xlabel('epoch')\n    plt.ylabel('accuracy')\n    plt.title('Accuracy vs No.of epochs')","c9be4c24":"plot_accuracies(history)","0333e3d4":"e = evaluate(model, test_loader)\ne","dad0a24f":"def predict_image(img,model):\n    xb  = to_device(img.unsqueeze(0),device)\n    yb = model(xb)\n    \n    _,preds = torch.max(yb,dim=1)\n    return dataset.classes[preds[0].item()]\n\n\nimg,label = test_dataset[1]\nplt.imshow(img.permute(1,2,0))\nprint('Label:', dataset.classes[label],',Predicted:',predict_image(img,model))","c0d9f002":"img,label = test_dataset[568]\nplt.imshow(img.permute(1,2,0))\nprint('Label:', dataset.classes[label],',Predicted:',predict_image(img,model))","a1e60a51":"# Put Training , Validation and Tresting Datasets into a DataLoader"}}