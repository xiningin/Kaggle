{"cell_type":{"370d16ca":"code","d1675950":"code","5e588361":"code","2daf2162":"code","9cd3b58a":"code","bb9aa94f":"code","305c909c":"code","e426e483":"code","7b7dacbf":"code","4f5136fb":"code","55648cd5":"code","42611471":"code","0f5c3944":"code","b3f39e20":"code","1c2bddb5":"markdown","9f2766b3":"markdown","cc766737":"markdown","ac2ee817":"markdown","c80336ad":"markdown","e381a36a":"markdown","e13676cc":"markdown","5450495f":"markdown"},"source":{"370d16ca":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os","d1675950":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n        \ndata=pd.read_csv('\/kaggle\/input\/social-network-ads\/Social_Network_Ads.csv')\ndata.head(5)","5e588361":"data=data.iloc[:,2:5]","2daf2162":"data","9cd3b58a":"x=data.iloc[:,:-1].values\ny=data.iloc[:,-1].values","bb9aa94f":"from sklearn.model_selection import train_test_split\nx_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.25, random_state=0)","305c909c":"from sklearn.preprocessing import StandardScaler\nsc=StandardScaler()","e426e483":"x_train=sc.fit_transform(x_train)\nx_test=sc.transform(x_test)","7b7dacbf":"## Training the Kernel SVM model on the Training set","4f5136fb":"from sklearn.svm import SVC\nclassifier = SVC(kernel='rbf', random_state=0)\nclassifier.fit(x_train, y_train)","55648cd5":"classifier.predict(sc.transform([[19,19000]]))","42611471":"y_pred = classifier.predict(x_test)\nprint(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))","0f5c3944":"from sklearn.metrics import confusion_matrix, accuracy_score\ncm=confusion_matrix(y_test, y_pred)\ncm\naccuracy_score(y_test, y_pred)","b3f39e20":"cm","1c2bddb5":"## Train Test Split the model","9f2766b3":"from matplotlib.colors import ListedColormap\nx_set, y_set = sc.inverse_transform(x_test), y_test\nx1, x2 = np.meshgrid(np.arange(start = x_set[:, 0].min() - 10, stop = x_set[:, 0].max() + 10, step = 0.25),\n                     np.arange(start = x_set[:, 1].min() - 1000, stop = x_set[:, 1].max() + 1000, step = 0.25))\nplt.contourf(x1, x2, classifier.predict(sc.transform(np.array([x1.ravel(), x2.ravel()]).T)).reshape(x1.shape),\n             alpha = 0.75, cmap = ListedColormap(('red', 'green')))\nplt.xlim(x1.min(), x1.max())\nplt.ylim(x2.min(), x2.max())\nfor i, j in enumerate(np.unique(y_set)):\n    plt.scatter(X_set[y_set == j, 0], x_set[y_set == j, 1], c = ListedColormap(('red', 'green'))(i), label = j)\nplt.title('Kernel SVM (Test set)')\nplt.xlabel('Age')\nplt.ylabel('Estimated Salary')\nplt.legend()\nplt.show()","cc766737":"## Visualising the Training set results\n","ac2ee817":"## Visualising the Test set results\n","c80336ad":"## Predicting the Test set results","e381a36a":"## Confusion Matrix and Accuracy Score","e13676cc":"## Feature Scaling","5450495f":"from matplotlib.colors import ListedColormap\nx_set, y_set = sc.inverse_transform(x_train), y_train\nx1, x2 = np.meshgrid(np.arange(start = x_set[:, 0].min() - 10, stop = x_set[:, 0].max() + 10, step = 0.25),\n                     np.arange(start = x_set[:, 1].min() - 1000, stop = x_set[:, 1].max() + 1000, step = 0.25))\nplt.contourf(x1, x2, classifier.predict(sc.transform(np.array([x1.ravel(), x2.ravel()]).T)).reshape(x1.shape),\n             alpha = 0.75, cmap = ListedColormap(('red', 'green')))\nplt.xlim(x1.min(), x1.max())\nplt.ylim(x2.min(), x2.max())\nfor i, j in enumerate(np.unique(y_set)):\n    plt.scatter(x_set[y_set == j, 0], x_set[y_set == j, 1], c = ListedColormap(('red', 'green'))(i), label = j)\nplt.title('Kernel SVM (Training set)')\nplt.xlabel('Age')\nplt.ylabel('Estimated Salary')\nplt.legend()\nplt.show()"}}