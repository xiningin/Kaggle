{"cell_type":{"d2151bc3":"code","e41395f0":"code","8638c7af":"code","411772ee":"code","2c7097a8":"code","9c9004c0":"markdown","e2cec046":"markdown","237f4eaa":"markdown","24e8b04c":"markdown","ca0d9d85":"markdown","e44fc3c4":"markdown","3b6a2f03":"markdown","63da5cac":"markdown","5e2953f2":"markdown","38ea4e7d":"markdown","78630e2b":"markdown","dc05059d":"markdown","97290456":"markdown","a4df0c57":"markdown","0de16a96":"markdown","2b4195e8":"markdown","0621a79b":"markdown","1f2c4d80":"markdown","aafffbd3":"markdown","d4e4fc2b":"markdown"},"source":{"d2151bc3":"import math\nimport numpy as np\nfrom scipy.fftpack import fft\nfrom timeit import Timer\n\narr_1d = 10*np.random.random(4)","e41395f0":"# Scalar implementation of DFT\ndef dft_scalar(x):\n    x = np.array(x)\n    N = np.max(x.shape)\n    X_k = []\n    \n    for k in range(N):\n        Xk = 0\n        for n in range(N):\n            Xk += x[n] * np.exp(-2j * np.pi * k * n \/ N)\n        X_k.append(Xk)\n        \n    return np.asarray(X_k)\n\nprint(np.around(dft_scalar(arr_1d), 4))","8638c7af":"# Vector implementation of DFT\ndef dft_vector(x):\n    x = np.array(x)\n    N = np.max(x.shape)\n    \n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    M = np.exp(-2j * np.pi * k * n \/ N)\n    \n    return np.dot(x, M)\n\nprint(np.around(dft_vector(arr_1d), 4))","411772ee":"# FFT implementation for 1D functions\ndef FFT_1d(x):\n    x = np.asarray(x, dtype=float)\n    N = np.max(x.shape)\n    \n    if N % 2 > 0:\n        raise ValueError(\"len of x must be power of 2\")\n        \n    elif N <= 4: # threshold\n        return dft_vector(x)\n    \n    else:\n        X_even = FFT_1d(x[::2])\n        X_odd = FFT_1d(x[1::2])\n        W = np.exp(-2j * np.pi * np.arange(N) \/ N)\n        \n        return np.concatenate([X_even + W[:N \/\/ 2] * X_odd,\n                               X_even + W[N \/\/ 2:] * X_odd])\n    \nprint(np.around(FFT_1d(arr_1d), 4)) ","2c7097a8":"repeat = 1000\n\nt_scal = Timer(lambda: dft_scalar(arr_1d)).timeit(repeat)\nt_vec = Timer(lambda: dft_vector(arr_1d)).timeit(repeat)\nt_fft = Timer(lambda: fft(arr_1d)).timeit(repeat)\n\nffts_times= [f\"Execution time for {repeat} reps:\\n\", \n             f\"Scalar: {t_scal:.4f} sec | The slowest\", \n             f\"Vector: {t_vec:.4f} sec | Vector DFT is {t_scal \/ t_vec:.2f}x faster than scalar DFT\", \n             f\"SciPy: {t_fft:.4f} sec | FFT is {t_scal \/ t_fft:.2f}x faster than scalar DFT\"]\n\nprint(*ffts_times, sep='\\n')","9c9004c0":"## References","e2cec046":"## Introduction","237f4eaa":"### Math","24e8b04c":"The same equation can also be implemented in vector. Vector form is computationally more efficient:","ca0d9d85":"### Math","e44fc3c4":"## Fast Fourier Transform","3b6a2f03":"\\begin{equation*}\nX_k = \\sum_{n=0}^{N-1}x_n e^{-i2\\pi k n \/ N} \\tag{1}\n\\end{equation*}\nfor $k=0, \\ldots, N-1$.","63da5cac":"## Discrete Fourier Transform","5e2953f2":"### Performance comparison","38ea4e7d":"- https:\/\/jakevdp.github.io\/blog\/2013\/08\/28\/understanding-the-fft\/","78630e2b":"**Discrete Fourier Transform** is the most important transform to go from discrete \"x\" domain to X domain, mathematically defined as follows:","dc05059d":"Oversimplified*ly*, Fourier transform is a nice way to convert a function from one domain into the other. But here is an official excerpt from [*Wiki*](https:\/\/en.wikipedia.org\/wiki\/Fourier_transform#Quantum_mechanics):\n> **Fourier transform (FT)** is a *mathematical transform* that decomposes *functions* depending on space or time into functions depending on spatial or temporal frequency, such as the expression of a musical chord in terms of the volumes and frequencies of its constituent notes. *The term Fourier transform* refers to both the **frequency domain representation** and the **mathematical operation** that associates the frequency domain representation to a function of space or time.","97290456":"### Code","a4df0c57":"\\begin{equation*}\nX_k = \\sum_{n=0}^{N-1}x_n e^{-i2\\pi k n \/ N} \\tag{2}\n\\end{equation*}\n\\begin{equation*}\n= \\sum_{m=0}^{N\/2-1}x_{2m} e^{-i2\\pi k (2m) \/ N} + \\sum_{m=0}^{N\/2-1}x_{2m+1} e^{-i2\\pi k (2m+1) \/ N}\n\\end{equation*}\n\\begin{equation*}\n= \\sum_{m=0}^{N\/2-1}x_{2m} e^{-i2\\pi k m \/ (N\/2)} + e^{-i2\\pi k \/ N} \\sum_{m=0}^{N\/2-1}x_{2m+1} e^{-i2\\pi k m \/ (N\/2)}\n\\end{equation*}","0de16a96":"The NumPy version of equation (1) can be implemeneted as follows:","2b4195e8":"Fourier Transforms are something magical, but yet so practical, the reason why we often hear about. Most of the common applications include signal processing, optics, analysis of differential equations and quantum mechanics.\n\nSo, why do we need Fourier transforms in the first place? The thing is: it helps us to analyze the signal in frequncy domain. And trust me, for engineers working with signal processing applications, like audio or images, frequency does mean a lot. In frequency domain, we can juggle signals and play with in various ways: filtering, denoising, apply algorithms, and a lot more fun operations.\n\n**tl;dr** The goal of this notebook is super-simple introduction into the world of FT, DFT and FFTs. Math definitions followed by the code in NumPy. \n\nLet's get it started!","0621a79b":"<center><figure><img src=\"https:\/\/upload.wikimedia.org\/wikipedia\/commons\/a\/aa\/Fourier2.jpg\" alt=\"drawing\" width=\"200\"\/><figcaption>Credits for an idea to <b>Jean-Baptiste Joseph Fourier<\/b> (1768-1830), French mathematician and physicist,<\/figcaption><\/figure><\/center>\n\n**Fun fact*: He accompanied Napoleon Bonaparte in Egyptian expedition as scientific adviser.","1f2c4d80":"FFT is an efficient algorithm to calculate DFT, which uses the trick of symmetry and periodicity","aafffbd3":"## On Fourier Transforms","d4e4fc2b":"### Code"}}