{"cell_type":{"dd7d37c1":"code","94412512":"code","282d5903":"code","edbea0e3":"code","98089554":"code","13732f69":"code","c4c1398b":"code","d3012955":"code","73f93f86":"code","eaee2b6e":"code","c431169f":"code","5756ee88":"code","fe689bb4":"code","2e3b1a56":"code","a00d3043":"code","779ad93b":"code","8de267e7":"code","a92c3288":"code","7b39a7fb":"code","d911d52d":"code","97a4bb53":"code","bbd1b9ce":"code","14eb8f45":"code","9592224c":"code","061c47d5":"code","ed72c483":"code","cb201499":"code","bd078a35":"code","48492d3f":"code","2ad96d79":"code","b34fb8cc":"code","b388f68e":"code","db46cd25":"code","0fc2e5c6":"code","26aae1fd":"code","c08416e8":"code","5b10c608":"code","02a27901":"code","068354c4":"markdown","e0409382":"markdown","eea7b594":"markdown","fa450685":"markdown","44c0907d":"markdown","46c5c861":"markdown","dd4ec01e":"markdown","bc9eea30":"markdown","fd1ba256":"markdown","fc901a86":"markdown","02573d5b":"markdown","d4fa1176":"markdown","55481cd3":"markdown","f65916cd":"markdown","f69cb471":"markdown","62e20da0":"markdown","e0a980fc":"markdown","e26ed7df":"markdown","02b7b97b":"markdown","2e857979":"markdown","9c477494":"markdown","e0a269f0":"markdown","454be89a":"markdown","b79769e8":"markdown","c0bc2345":"markdown","0e88a9d7":"markdown","a84a77a5":"markdown","d7bc59df":"markdown","bd101395":"markdown","08cdfee4":"markdown","50486930":"markdown"},"source":{"dd7d37c1":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt # plotting\nimport numpy as np # linear algebra\nimport os # accessing directory structure\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n","94412512":"print(os.listdir('..\/input'))","282d5903":"nRowsRead = 1000 # specify 'None' if want to read whole file\n# innercity.csv has 21613 rows in reality, but we are only loading\/previewing the first 1000 rows\ndf1 = pd.read_csv('..\/input\/innercity.csv', delimiter=',', nrows = nRowsRead)\ndf1.dataframeName = 'innercity.csv'\nnRow, nCol = df1.shape\nprint(f'There are {nRow} rows and {nCol} columns')","edbea0e3":"df1.head(5)","98089554":"df1.info()","13732f69":"df1.columns","c4c1398b":"df1.dtypes","d3012955":"df1.isnull().any()","73f93f86":"df1.isna().sum()","eaee2b6e":"df1.duplicated().sum()","c431169f":"df1.describe(include='all').T","5756ee88":"# Distribution graphs (histogram\/bar graph) of column data\ndef plotPerColumnDistribution(df, nGraphShown, nGraphPerRow):\n    nunique = df.nunique()\n    df = df[[col for col in df if nunique[col] > 1 and nunique[col] < 50]] # For displaying purposes, pick columns that have between 1 and 50 unique values\n    nRow, nCol = df.shape\n    columnNames = list(df)\n    nGraphRow = (nCol + nGraphPerRow - 1) \/ nGraphPerRow\n    plt.figure(num = None, figsize = (6 * nGraphPerRow, 8 * nGraphRow), dpi = 80, facecolor = 'w', edgecolor = 'k')\n    for i in range(min(nCol, nGraphShown)):\n        plt.subplot(nGraphRow, nGraphPerRow, i + 1)\n        columnDf = df.iloc[:, i]\n        if (not np.issubdtype(type(columnDf.iloc[0]), np.number)):\n            valueCounts = columnDf.value_counts()\n            valueCounts.plot.bar()\n        else:\n            columnDf.hist()\n        plt.ylabel('counts')\n        plt.xticks(rotation = 90)\n        plt.title(f'{columnNames[i]} (column {i})')\n    plt.tight_layout(pad = 1.0, w_pad = 1.0, h_pad = 1.0)\n    plt.show()\n","fe689bb4":"df1.corr()","2e3b1a56":"#PEARSON CORRELATION\n\nplt.figure(figsize = (15,10))\nsns.heatmap(df1.corr(method=\"pearson\"))\nplt.title('PEARSON CORRELATION', fontsize=15)","a00d3043":"#SPEARMAN CORRELATION\n\nplt.figure(figsize = (15,10))\nsns.heatmap(df1.corr(method=\"spearman\"))\nplt.title('SPEARMAN CORRELATION', fontsize=15)","779ad93b":"#KENDALL CORRELATION\n\nplt.figure(figsize = (15,10))\nsns.heatmap(df1.corr(method=\"kendall\"))\nplt.title('KENDALL CORRELATION', fontsize=15)","8de267e7":"# Correlation matrix\ndef plotCorrelationMatrix(df, graphWidth):\n    filename = df.dataframeName\n    df = df.dropna('columns') # drop columns with NaN\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    if df.shape[1] < 2:\n        print(f'No correlation plots shown: The number of non-NaN or constant columns ({df.shape[1]}) is less than 2')\n        return\n    corr = df.corr()\n    plt.figure(num=None, figsize=(graphWidth, graphWidth), dpi=80, facecolor='w', edgecolor='k')\n    corrMat = plt.matshow(corr, fignum = 1)\n    plt.xticks(range(len(corr.columns)), corr.columns, rotation=90)\n    plt.yticks(range(len(corr.columns)), corr.columns)\n    plt.gca().xaxis.tick_bottom()\n    plt.colorbar(corrMat)\n    plt.title(f'Correlation Matrix for {filename}', fontsize=15)\n    plt.show()\n","a92c3288":"# Scatter and density plots\ndef plotScatterMatrix(df, plotSize, textSize):\n    df = df.select_dtypes(include =[np.number]) # keep only numerical columns\n    # Remove rows and columns that would lead to df being singular\n    df = df.dropna('columns')\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    columnNames = list(df)\n    if len(columnNames) > 10: # reduce the number of columns for matrix inversion of kernel density plots\n        columnNames = columnNames[:10]\n    df = df[columnNames]\n    ax = pd.plotting.scatter_matrix(df, alpha=0.75, figsize=[plotSize, plotSize], diagonal='kde')\n    corrs = df.corr().values\n    for i, j in zip(*plt.np.triu_indices_from(ax, k = 1)):\n        ax[i, j].annotate('Corr. coef = %.3f' % corrs[i, j], (0.8, 0.2), xycoords='axes fraction', ha='center', va='center', size=textSize)\n    plt.suptitle('Scatter and Density Plot')\n    plt.show()\n","7b39a7fb":"%matplotlib inline\nsns.boxplot(data=df1)","d911d52d":"%matplotlib inline\nplt.figure(figsize = (28,8))\nsns.boxplot(data=df1)","97a4bb53":"plotPerColumnDistribution(df1, 10, 5)","bbd1b9ce":"plotCorrelationMatrix(df1, 8)","14eb8f45":"plotScatterMatrix(df1, 20, 10)","9592224c":"#missing data\ntotal = df1.isnull().sum().sort_values(ascending=False)\npercent = (df1.isnull().sum()\/df1.isnull().count()).sort_values(ascending=False)\nmissing_data = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])\nmissing_data.head(20)","061c47d5":"print(pd.isnull(df1).any())","ed72c483":"df1[\"sold_year\"] = df1[\"dayhours\"].apply(lambda x:x.split('T')[0][:4])","cb201499":"df1 = df1.drop(columns = 'cid')","bd078a35":"df1 = df1.drop(columns = 'dayhours')","48492d3f":"df1.head()","2ad96d79":"df1.head()","b34fb8cc":"X = df1.drop(\"price\", axis=1)\nY = df1[\"price\"]\nprint(X.shape)\nprint(Y.shape)","b388f68e":"from sklearn.preprocessing import StandardScaler, MinMaxScaler\nscaler = MinMaxScaler().fit(X)\nscaled_X = scaler.transform(X)","db46cd25":"from sklearn.model_selection import train_test_split\n\nseed      = 42\ntest_size = 0.30\n\nX_train, X_test, Y_train, Y_test = train_test_split(scaled_X, Y, test_size = test_size, random_state = seed)\n\nprint(X_train.shape)\nprint(X_test.shape)\nprint(Y_train.shape)\nprint(Y_test.shape)","0fc2e5c6":"from sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.linear_model import Lasso\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import ElasticNet\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.ensemble import AdaBoostRegressor\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom xgboost import XGBRegressor\n\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import mean_absolute_error\n\n# user variables to tune\nfolds   = 10\nmetric  = \"neg_mean_absolute_error\"\n\n# hold different regression models in a single dictionary\nmodels = {}\nmodels[\"Linear\"]        = LinearRegression()\nmodels[\"Lasso\"]         = Lasso()\nmodels[\"Ridge\"]         = Ridge()\nmodels[\"ElasticNet\"]    = ElasticNet()\nmodels[\"DecisionTree\"]  = DecisionTreeRegressor()\nmodels[\"KNN\"]           = KNeighborsRegressor()\nmodels[\"RandomForest\"]  = RandomForestRegressor()\nmodels[\"AdaBoost\"]      = AdaBoostRegressor()\nmodels[\"GradientBoost\"] = GradientBoostingRegressor()\nmodels[\"XGBoost\"] = XGBRegressor()\n\n# 10-fold cross validation for each model\nmodel_results = []\nmodel_names   = []\nfor model_name in models:\n\tmodel   = models[model_name]\n\tk_fold  = KFold(n_splits=folds, random_state=seed)\n\tresults = cross_val_score(model, X_train, Y_train, cv=k_fold, scoring=metric)\n\t\n\tmodel_results.append(results)\n\tmodel_names.append(model_name)\n\tprint(\"{}: {}, {}\".format(model_name, round(results.mean(), 3), round(results.std(), 3)))\n\n# box-whisker plot to compare regression models\nfigure = plt.figure(figsize = (20,8))\n\nfigure.suptitle('Regression models comparison')\naxis = figure.add_subplot(111)\nplt.boxplot(model_results)\naxis.set_xticklabels(model_names, rotation = 45, ha=\"right\")\naxis.set_ylabel(\"Mean Absolute Error (MAE)\")\nplt.margins(0.05, 0.1)\n","26aae1fd":"model = GradientBoostingRegressor()\nmodel.fit(X_train,Y_train)\n\n##print(\"Intercept : \", model.intercept_)\n##print(\"Slope : \", model.coef_)\n\n#Predicting TEST & TRAIN DATA\ntrain_predict = model.predict(X_train)\ntest_predict = model.predict(X_test)\n\nerror_percent = np.mean(np.abs((Y_train - train_predict) \/ Y_train)) * 100\nprint(\"MAPE - Mean Absolute Percentage Error (TRAIN DATA): \",error_percent )\nY_train, train_predict = np.array(Y_train), np.array(train_predict)","c08416e8":"model = GradientBoostingRegressor()\nmodel.fit(X_test,Y_test)\n\n##print(\"Intercept : \", model.intercept_)\n##print(\"Slope : \", model.coef_)\n\n#Predicting TEST & TRAIN DATA\ntrain_predict = model.predict(X_train)\ntest_predict = model.predict(X_test)\n\nerror_percent = np.mean(np.abs((Y_train - train_predict) \/ Y_train)) * 100\nprint(\"MAPE - Mean Absolute Percentage Error (TEST DATA): \",error_percent )\nY_train, train_predict = np.array(Y_train), np.array(train_predict)\n\n#print(\"Mape - Train:\" , np.mean(np.abs((Y_train,train_predict))))\n#print(\"Mape - Test:\" ,np.mean(np.abs((Y_test,test_predict))))\n","5b10c608":"# plot between predictions and Y_test\nx_axis = np.array(range(0, test_predict.shape[0]))\nplt.figure(figsize=(20,10))\nplt.plot(x_axis, test_predict, linestyle=\"--\", marker=\"o\", alpha=0.7, color='r', label=\"predictions\")\nplt.plot(x_axis, Y_test, linestyle=\"--\", marker=\"o\", alpha=0.7, color='g', label=\"Y_test\")\nplt.xlabel('Row number')\nplt.ylabel('PRICE')\nplt.title('Predictions vs Y_test')\nplt.legend(loc='lower right')","02a27901":"feature_importance = model.feature_importances_\nfeature_importance = 100.0 * (feature_importance \/ feature_importance.max())\n\nsorted_idx = np.argsort(feature_importance)\npos        = np.arange(sorted_idx.shape[0]) + .5\n\nplt.figure(figsize = (15,18))\n\n#Make a horizontal bar plot.\nplt.barh(pos, feature_importance[sorted_idx], align='center')\nplt.yticks(pos, df1.columns[sorted_idx])\nplt.xlabel('Relative Importance')\nplt.title('Variable Importance')","068354c4":"View the above Box plot clearly by adding figsize","e0409382":"Let's take a quick look at what the data looks like:","eea7b594":"There is 1 csv file in the current version of the dataset:","fa450685":"## Density plot\n\nDensity plot is another univariate plot that draws a histogram of the data distribution and fits a Kernel Density Estimate (KDE).\n\nA histogram is a graphical representation of a frequency distribution where data points are organized as bins, plotted with values along the x-axis and the count of data points in each bin along the y-axis.\n\n## Scatter plot\n\nScatter plot is used to understand relationship between two different attributes in the dataset. Below we have compared PRICE (target) vs each of the attribute in the dataset.","44c0907d":"Wow, there is no null values in the given Dataset. \ud83d\ude1c","46c5c861":"Distribution graphs (histogram\/bar graph) of sampled columns:","dd4ec01e":"## Exploratory Analysis\nTo begin this exploratory analysis, first import libraries and define functions for plotting the data using `matplotlib`. Depending on the data, not all plots will be made.","bc9eea30":"## Remove unwanted columns\n\nI'm just removing 2 columns\n\n* cid: a notation for a house\n* dayhours: Date house was sold","fd1ba256":"## Training Regression Model\n\nBy looking at the dataset, we simply can\u2019t suggest the best Regression Model for this problem. So, we will try out different Regression models available in scikit-learn with a k-fold cross validation method.\n\nlet's assume k = 10 (k-fold cross validation)\n\nIt means we split the training data into train and test data using a test_size parameter for 10-folds. Each fold will have different samples that are not present in other folds. By this way, we can throughly train our model on different samples in the dataset.\n\nBefore doing anything, we will split our dataframe df into features X and target Y.","fc901a86":"## Missing data\nImportant questions when thinking about missing data:\n\n* How prevalent is the missing data?\n* Is missing data random or does it have a pattern?\n\nThe answer to these questions is important for practical reasons because missing data can imply a reduction of the sample size. This can prevent us from proceeding with the analysis. Moreover, from a substantive perspective, we need to ensure that the missing data process is not biased and hidding an inconvenient truth.\n\nSometimes, in a dataset we will have missing values such as NaN or empty string in a cell. We need to take care of these missing values so that our machine learning model doesn\u2019t break. To handle missing values, there are three approaches followed.\n\n    Replace the missing value with a large negative number (e.g. -999).\n    Replace the missing value with mean of the column.\n    Replace the missing value with median of the column.\n\nTo find if a column in our dataset has missing values, you can use pd.isnull(df).any() which returns a boolean for each column in the dataset that tells if the column contains any missing value. In this dataset, there are no missing values!","02573d5b":"## Choosing the best model\n\nBased on the above comparison, we can see that Gradient Boosting Regression model outperforms all the other regression models. So, we will choose it as the best Regression Model for this problem.","d4fa1176":"We will use pandas and scikit-learn to load and explore the dataset. The dataset can easily be loaded from scikit-learn\u2019s datasets module using read_csv function.","55481cd3":"As we see different data distributions, we will standardize the dataset using StandardScaler function in scikit-learn. This is a useful technique where the attributes are transformed to a standard gaussian distribution with a mean of 0 and a standard deviation of 1.","f65916cd":"The next hidden code cells define functions for plotting data. Click on the \"Code\" button in the published kernel to reveal the hidden code.","f69cb471":"## Steps for Further Improvement\n\nSome additional steps that may be taken to improve score could be:\n\nDo additional pre-processing on the given data\nNot sure regularized Linear Regression approach is fine? Or prefer Ensemble methods? Or maybe something else?\nIntroduce a greater variety of base models for learning. The more uncorrelated the results, the better the final score.\n\n## It's up to you to find out.\ud83d\ude09\n","62e20da0":"## Correlation matrix:","e0a980fc":"We can visualize the predictions made by our best model and the original targets Y_test using the below code.","e26ed7df":"Now, we will understand the statistical summary of the dataset using the describe() function. Using this function, we can understand the count, min, max, mean and standard deviation for each attribute (column) in the dataset. \n\nEach of these can also be displayed individually using df.count(), df.min(), df.max(), df.median() and df.quantile(q).","02b7b97b":"## Descriptive Analysis\n\nLet's check the file: ..\/input\/innercity.csv\n\nIt is an important first step for conducting statistical analysis. It gives an idea of the distribution of the data, helps us to detect outliers and typos, and identify associations among variables, thus preparing you for conducting further statistical analyses","2e857979":"## Feature Importance\n\nOnce we have a trained model, we can understand feature importance (or variable importance) of the dataset which tells us how important each feature is, to predict the target. Below chart shows relative importance of different feature in the dataset made by our best model Gradient Boosting Regressor (GBR).","9c477494":"## Feature Extraction\n\nNow lets extract a new feature sold year from the give data by slicing the year alone.\n\nAnother feature which can be extracted from year is finding the Age of the house which is PENDING!!!! (WILL DO IN NEXT VERSION)","e0a269f0":"## Visualize the dataset\n\nNow you're ready to read in the data and use the plotting functions to visualize the data.\n\nWe will use two types of visualization strategy namely univariate plots and bivariate plots. As the name suggests, univariate plot is used to visualize a single column or an attribute whereas bivariate plot is used to visualize two columns or two attributes.\n\n## Box plot\n\nA box-whisker plot is a univariate plot used to visualize a data distribution.\n\n* * The ends of whiskers are the maximum and minimum range of data distribution.\n* The central line in the box is the median of the entire data distribution.\n* The right and left edges in the box are the medians of data distribution to the right and left from the central median, respectively.\n","454be89a":"We could still tune different regression models used in this example using scikit-learn\u2019s GridSearchCV() function. By tuning, we mean trying out different hyper-parameters for each model.","b79769e8":"## Problem statement:\n\nA house value is simply more than location and square footage. Like the features that make up a person, an educated party would want to know all aspects that give a house its value. For example, you want to sell a house and you don\u2019t know the price which you can take\u200a\u2014\u200ait can\u2019t be too low or too high. To find house price you usually try to find similar properties in your neighbourhood and based on gathered data you will try to assess your house price. ","c0bc2345":"## Correlation\n\nFinding correlation between attributes is a highly useful way to check for patterns in the dataset. Pandas offers three different ways to find correlation between attributes (columns). The output of each of these correlation functions fall within the range [-1, 1].\n\n    1 - Positively correlated\n    -1 - Negatively correlated.\n    0 - Not correlated.\n    \nWe will use df.corr() function to compute the correlation between attributes\n","0e88a9d7":"We can easily convert the dataset into a pandas dataframe to perform exploratory data analysis. Simply pass in the dataset.data as an argument to pd.DataFrame(). We can view the first 5 rows in the dataset using head() function.","a84a77a5":"Now, we will split the data into train and test set. We can easily do this using scikit-learn\u2019s train_test_split() function using a test_size parameter.","d7bc59df":"We will cover 3 methods\n\n* PEARSON CORRELATION\n* SPEARMAN CORRELATION\n* KENDALL CORRELATION","bd101395":"Let\u2019s dive into Regression. We will use different Regression models offered by scikit-learn to produce a baseline accuracy for this problem. \n\nWe will use the MAE (Mean Absolute Error) as the performance metric for the regression models.","08cdfee4":"Find the dimension of given data\n","50486930":"We can check the datatype of each column using dtypes to make sure every column has numeric datatype. If a column has different datatype such as string or character, we need to map that column to a numeric datatype such as integer or float. For this dataset, luckily there is no such column."}}