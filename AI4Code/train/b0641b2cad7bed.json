{"cell_type":{"274eae73":"code","967f8f56":"code","ee8b45e2":"code","c9b3fb1a":"code","df1c919d":"code","13bf5454":"code","1e4159f2":"code","905972cb":"code","144521dd":"code","0a67066c":"code","17ed0ece":"code","b4b3bcce":"code","5ebc0432":"code","dcf4f474":"code","32d26e42":"code","cf2f5f56":"code","f9a07e73":"code","be7745a2":"code","0a1f0f3e":"code","802e6251":"code","a35e41a4":"code","692d4f73":"code","c3fd39fa":"code","29710c5d":"code","0e7e866e":"code","a5106544":"markdown","f181d9c2":"markdown","4e5f9366":"markdown","592ddf51":"markdown","fced4309":"markdown","8381dd72":"markdown","77326364":"markdown","5bf74502":"markdown","97bc7960":"markdown","67a65bd1":"markdown","c9b98a18":"markdown","e0a4e8fd":"markdown","f701a3fa":"markdown","dd38d021":"markdown"},"source":{"274eae73":"!pip install pmdarima","967f8f56":"import time\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pylab import rcParams\nplt.style.use('fivethirtyeight')\nimport plotly.express as px\nfrom datetime import datetime\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn import metrics\nfrom sklearn.model_selection import cross_val_score\nfrom statsmodels.tsa.stattools import adfuller\nimport warnings\nwarnings.filterwarnings('ignore', 'statsmodels.tsa.arima_model.ARMA',\n                        FutureWarning)\nwarnings.filterwarnings('ignore', 'statsmodels.tsa.arima_model.ARIMA',\n                        FutureWarning)\nfrom pmdarima.arima import auto_arima\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error","ee8b45e2":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","c9b3fb1a":"path = \"..\/input\/g-research-crypto-forecasting\/\"\ntrain = pd.read_csv(path + \"train.csv\")\n#train.index = pd.to_datetime(train.index, unit='s')\ntrain['timestamp'] = pd.to_datetime(train['timestamp'], unit='s')\ntrain = train.set_index('timestamp')\n\nasset_details = pd.read_csv(path + \"asset_details.csv\")\n\nsupplemental_train = pd.read_csv(path + \"supplemental_train.csv\")\n# Converting the timestamp from string to timestamp format:\nsupplemental_train.index = pd.to_datetime(supplemental_train.index, unit='s')\nexample_test = pd.read_csv(path + \"example_test.csv\")\ntrain.head(8)","df1c919d":"train.tail(3)","13bf5454":"train.describe()","1e4159f2":"train.info()","905972cb":"asset_details","144521dd":"train.shape","0a67066c":"train.isnull().sum()","17ed0ece":"import plotly.express as px\nasset_details = asset_details.sort_values(by='Weight', ascending=False)\nfig = px.bar(asset_details, x='Asset_Name', y='Weight', title=\"The Cryptomoney with their Weight\")\nfig.show()","b4b3bcce":"btc = train[train[\"Asset_ID\"]==1] # Asset_ID = 1 for Bitcoin\nbtc_mini = btc.iloc[-200:] # Select recent data rows\n\neth = train[train[\"Asset_ID\"]==6] # Asset_ID = 6 for eth\neth_mini = eth.iloc[-200:] # Select recent data rows\n\ncrd = train[train[\"Asset_ID\"]==3] # Asset_ID = 3 for eth\ncrd_mini = crd.iloc[-400:] # Select recent data rows\n\nbc = train[train[\"Asset_ID\"]==0] # Asset_ID = 0 for eth\nbc_mini = bc.iloc[-400:] # Select recent data rows\n\ndg = train[train[\"Asset_ID\"]==4] # Asset_ID = 4 for eth\ndg_mini = dg.iloc[-400:] # Select recent data rows\n\nltc = train[train[\"Asset_ID\"]==9] # Asset_ID = 9 for eth","5ebc0432":"import matplotlib.pyplot as plt\n\nf = plt.figure(figsize=(15,7))\nax = f.add_subplot(321)\nplt.plot(btc['Close'], label='Bitcoin')\nplt.legend()\n\nax2 = f.add_subplot(322)\nax2.plot(eth['Close'], label='Ethereum', color='red')\nplt.legend()\n\nax3 = f.add_subplot(323)\nax3.plot(crd['Close'], label='Cardano', color='red',)\nplt.legend()\n\nax2 = f.add_subplot(324)\nax2.plot(bc['Close'], label='Binance Coin')\nplt.legend()\n\nax2 = f.add_subplot(325)\nax2.plot(dg['Close'], label='Dogecoin')\nplt.legend()\n\nax2 = f.add_subplot(326)\nax2.plot(ltc['Close'], label='Litecoin', color='red')\nplt.legend()\nplt.tight_layout()\nplt.show()","dcf4f474":"import plotly.graph_objects as go\n\ndef plotcandlcharts(monaie, title):\n    fig = go.Figure(data=[go.Candlestick(x=monaie.index, open=monaie['Open'], high=monaie['High'], low=monaie['Low'], close=monaie['Close'])])\n    fig.update_layout(\n        title=title,\n        xaxis_title=\"Time\",\n        yaxis_title=\"Stock\")\n\n    fig.show()\nplotcandlcharts(btc_mini,'Candlestick Trading for BITCOIN the latest day')\nplotcandlcharts(eth_mini,'Candlestick Trading for ETHERUM the latest day')\nplotcandlcharts(crd_mini,'Candlestick Trading for CARDINO the latest day')","32d26e42":"train1 = pd.read_csv(\"..\/input\/g-research-crypto-forecasting\/train.csv\")\n\nasset_details = pd.read_csv(\"..\/input\/g-research-crypto-forecasting\/asset_details.csv\")\nmapping = dict(asset_details[['Asset_ID', 'Asset_Name']].values)\ntrain1[\"Asset name\"] = train1[\"Asset_ID\"].map(mapping)\n\nbitcoin = train1.query(\"Asset_ID == 1\").reset_index(drop = True)\nbitcoin['timestamp'] = pd.to_datetime(bitcoin['timestamp'], unit='s')\nbitcoin = bitcoin.set_index('timestamp')\nbitcoin\n\nethereum = train1.query(\"Asset_ID == 6\").reset_index(drop = True)\nethereum['timestamp'] = pd.to_datetime(ethereum['timestamp'], unit='s')\nethereum = ethereum.set_index('timestamp')\nethereum\n\ncardano = train1.query(\"Asset_ID == 3\").reset_index(drop = True)\ncardano['timestamp'] = pd.to_datetime(cardano['timestamp'], unit='s')\ncardano = cardano.set_index('timestamp')\ncardano.head(1)\n\nmaker = train1.query(\"Asset_ID == 10\").reset_index(drop = True)\nmaker['timestamp'] = pd.to_datetime(maker['timestamp'], unit='s')\nmaker = maker.set_index('timestamp')","cf2f5f56":"import seaborn as sns\nplt.figure(figsize=(10,6))\nsns.heatmap(train[['Count','Open','High','Low','Close','Volume','VWAP','Target']].corr(), vmin=-1.0, vmax=1.0, annot=True, linewidths=0.1)\nplt.show()","f9a07e73":"df_close_bitcoin = bitcoin['Close']\ndf_close_ethereum = ethereum['Close']\ndf_close_cardano = cardano['Close']\ndf_close_maker = maker['Close']","be7745a2":"def test_stationarity(df_close):\n    plt.figure(figsize=(10,6))\n    rolling_mean = df_close.rolling(window = 12).mean()\n    rolling_std = df_close.rolling(window = 12).std()\n    plt.plot(df_close, color = 'blue', label = 'Origine')\n    plt.plot(rolling_mean, color = 'red', label = 'Moyenne mobile')\n    plt.plot(rolling_std, color = 'black', label = 'Ecart-type mobile')\n    plt.legend(loc = 'best')\n    plt.title('Moyenne et Ecart-type mobiles')\n    plt.show()\n    \ntest_stationarity(df_close_bitcoin)\ntest_stationarity(df_close_ethereum)\ntest_stationarity(df_close_cardano)","0a1f0f3e":"df_log = np.log(df_close_bitcoin)\nplt.plot(df_log)","802e6251":"result = seasonal_decompose(df_close_bitcoin, model='multiplicative', period = 30)\nfig = plt.figure()  \nfig = result.plot()  \nfig.set_size_inches(16, 9)","a35e41a4":"#split data into train and training set\ntrain_data, test_data = df_log[3:int(len(df_log)*0.9)], df_log[int(len(df_log)*0.9):]\nplt.figure(figsize=(10,6))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Closing Prices')\nplt.plot(df_log, 'green', label='Train data')\nplt.plot(test_data, 'blue', label='Test data')\nplt.legend()","692d4f73":"bitcoin['timestamp'] = bitcoin.index\n# Predicting the close price of BTC  \nrcParams['figure.figsize'] = 16, 6\nmodelARIMA = ARIMA(bitcoin[\"Close\"].diff().iloc[1:].values, order=(2,1,0))\nresult = modelARIMA.fit()\nprint(result.summary())\nresult.plot_predict(start=700, end=1000)\n_ = plt.title('modelARIMA: predicting Close price for BITCCOIN')\nplt.show()","c3fd39fa":"import math\ncount = len(btc[\"Close\"].diff().iloc[1000:1101].values)\nrmse = math.sqrt(mean_squared_error(bitcoin[\"Close\"].diff().iloc[1000:1101].values, result.predict(start=1000,end=999+count)))\nprint(\"The root mean squared error is {}.\".format(rmse))","29710c5d":"predicted_result = result.predict()","0e7e866e":"import gresearch_crypto\n#env = gresearch_crypto.make_env()   # initialize the environment\n#iter_test = env.iter_test()    # an iterator which loops over the test set and sample submission\nfor (df_test, sample_prediction_df) in iter_test:\n    sample_prediction_df['Target'] = 0  # make your predictions here\n    env.predict(sample_prediction_df)   # register your predictions","a5106544":"As mentioned earlier, before we can build a model, we need to make sure that the time series is stationary. There are two main ways to determine if a given time series is stationary:\n\n* **Rolling statistics** : Plot the moving average and moving standard deviation. The time series is stationary if it remains constant over time (by eye, look to see if the lines are straight and parallel to the x axis)\n* **Augmented Dickey-Fuller (ADF) test**: The time series is considered stationary if the p-value is small (according to the null hypothesis) and if the critical values at 1%, 5%, 10% confidence intervals are as close as possible to the ADF statistics.\n\nFor those who don't understand the difference between average and moving average, a 10-day moving average calculates the average of the closing prices of the first 10 days as the first data point. And so on for each subsequent data point.","f181d9c2":"# G-Research Crypto Forecasting\n## Use your ML expertise to predict real crypto market data","4e5f9366":"## 3. Data Understanding\n#### 3.1. Data volume (size, number of records)\n        - The size of the dataset is : 3.06 GB\n        - number of files in csv: 5 \n                - train.csv(2.82 GB)\n                - example_test.csv(5.92 kB)\n                - asset_details.csv(444 B)\n                - example_sample_submission.csv(406 B)\n                - supplemental_train.csv(243.24 MB)\n#### 3.2. Data attributes and their description (variables, data types)\n        - files variable: \n        train.csv - The training set\n*               **timestamp** - A timestamp for the minute covered by the row.\n*                **Asset_ID** - An ID code for the cryptoasset.\n*                **Count** - The number of trades that took place this minute.\n*                **Open** - The USD price at the beginning of the minute.\n*                **High** - The highest USD price during the minute.\n*                **Low** - The lowest USD price during the minute.\n*                **Close** - The USD price at the end of the minute.\n*                **Volume** - The number of cryptoasset units traded during the minute.\n*                **VWAP** - The volume weighted average price for the minute.\n*                **Target** - 15 minute residualized returns. See the 'Prediction and Evaluation' section of this notebook for details of how the target is calculated.\n\n\n        example_test.csv - An example of the data that will be delivered by the time series API.\n\n        example_sample_submission.csv - An example of the data that will be delivered by the time series API. The data is just copied from train.csv.\n\n        asset_details.csv - Provides the real name and of the cryptoasset for each Asset_ID and the weight each cryptoasset receives in the metric.\n\n        gresearch_crypto - An unoptimized version of the time series API files for offline work. You may need Python 3.7 and a Linux environment to run it without errors.\n\n        supplemental_train.csv - After the submission period is over this file's data will be replaced with cryptoasset prices from the submission period. In the Evaluation phase, the train, train supplement, and test set will be contiguous in time, apart from any missing data. The current copy, which is just filled approximately the right amount of data from train.csv is provided as a placeholder.\n#### 3.3. Relationship and mapping schemes (understand attribute representations)\nThese financial charts are named candlesticks because the rectangular shape and lines on either end represent a candle with wicks. Each candlestick resembles one minute\u2019s worth of price data of stock. With time, the candlesticks group into recognizable patterns that investors use for making buying and selling decisions.\n![How to easily understand the candlestick chart in the stock market](http:\/\/qph.fs.quoracdn.net\/main-qimg-3543e6c07485ced5fa0c7ff35f54081e)\n#### 3.4. Basic descriptive statistics (mean, median, variance)\n#### 3.5. Focus on which attributes are important for the business","592ddf51":"### What is a stationary series?\n\n1. The average of the series should not be in function of time. The red graph below is not stationary as the average increases over time.\n![](https:\/\/assets.moncoachdata.com\/v7\/moncoachdata.com\/wp-content\/uploads\/2020\/01\/moyenne-series-temporelles-stationnaires.png?w=555)\n\n2. The variance of the series must not be in function of time. Notice in the red graph below the variance of the data that varies over time.\n![](https:\/\/assets.moncoachdata.com\/v7\/moncoachdata.com\/wp-content\/uploads\/2020\/01\/variance-series-temporelles-stationnaires.png?w=555)\n\n3. Finally, the covariance of the i-th term and the (i + m)-th term must not be a function of time. In the following graph, you will notice that the gap gets closer as time increases. Therefore, the covariance is not related to time for the \u201cred series\u201d.\n![](https:\/\/assets.moncoachdata.com\/v7\/moncoachdata.com\/wp-content\/uploads\/2020\/01\/covariance-series-temporelles-stationnaires.png?w=555)\n\nIf a time series is stationary and exhibits a particular behavior during a given time interval, it is safe to assume that it will exhibit the same behavior at a later time. Most statistical modeling methods assume or require the time series to be stationary.","fced4309":"## 2. Our Goal is:\nTo forecast short term returns on the most popular cryptocurrencies","8381dd72":"Here we can see that each row of our dataset has the trading data for an asset, at a given minute timestamp, described in the first 8 rows of the table below.","77326364":"### 4. Exploratory Data Analysis","5bf74502":"## 1. Problem Understanding\n\nThe general research associated with the market is highly focusing on neither buy or sell. The common trend towards the stock market among the society is that it is highly risky for investment or not suitable for trade so most of the people are not even interested. The seasonal variance and steady flow of any index will help both existing and inexperienced investors to understand and make a decision to invest in the stock market.\n\nTo solve these types of problems, the time series analysis will be the best tool for forecasting the trend or even future. The trend chart will provide adequate guidance for the investors.\n\nSo let us understand this concept in great detail and use a machine learning technique to forecast stocks.\n\nOver $40 billion worth of cryptocurrencies are traded every day. They are among the most popular assets for speculation and investment, yet have proven wildly volatile. Fast-fluctuating prices have made millionaires of a lucky few, and delivered crushing losses to others. Could some of these price movements have been predicted in advance?","97bc7960":"Printing the DataFrame\u2019s info, we can see all that it contains:","67a65bd1":"Let's visualize the per day closing price of the stock.","c9b98a18":"As you can see, the moving average and the moving standard deviation increase with time. We can therefore conclude that the time series is not stationary.","e0a4e8fd":"## Is Our dataset Stationary data","f701a3fa":"### Load the training set","dd38d021":"**asset_details.csv** - Provides the real name and of the cryptoasset for each Asset_ID and the weight each cryptoasset receives in the metric."}}