{"cell_type":{"489cf2d5":"code","78fc7cea":"code","6d4ba0d8":"code","9cbddb12":"code","a1232aa8":"code","023c73e0":"code","80a9f1ea":"code","e896f174":"code","052c1b17":"markdown"},"source":{"489cf2d5":"!pip install git+git:\/\/github.com\/waspinator\/pycococreator.git@0.2.0\n!pip install git+git:\/\/github.com\/waspinator\/coco.git@2.1.0","78fc7cea":"import datetime\nimport json\nimport os\nimport re\nfrom glob import glob\nimport fnmatch\nfrom PIL import Image\nimport numpy as np\nfrom pycococreatortools import pycococreatortools\nimport pandas as pd\n\nfrom skimage.io import imread\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\n\n\ndataset_train = '..\/input\/sartorius-cell-instance-segmentation\/train'\ncsv_train = '..\/input\/sartorius-cell-instance-segmentation\/train.csv'\nIMAGE_DIR = dataset_train\n\ndf = pd.read_csv(csv_train )  # read csv file\n","6d4ba0d8":"INFO = {\n    \"description\": \"Kaggle Dataset\",\n    \"url\": \"https:\/\/github.com\/pmj110119\",\n    \"version\": \"0.1.0\",\n    \"year\": 2021,\n    \"contributor\": \"pmj110119\",\n    \"date_created\": datetime.datetime.utcnow().isoformat(' ')\n}\n\nLICENSES = [\n    {\n        \"id\": 1,\n        \"name\": \"Attribution-NonCommercial-ShareAlike License\",\n        \"url\": \"http:\/\/creativecommons.org\/licenses\/by-nc-sa\/2.0\/\"\n    }\n]\n\nCATEGORIES = [\n    {\n        'id': 1,\n        'name': 'cell',\n        'supercategory': 'cell',\n    },\n]","9cbddb12":"def rle_decode(mask_rle, shape=(520, 704)):\n    s = mask_rle.split()\n    starts =  np.asarray(s[0::2], dtype=int)\n    lengths = np.asarray(s[1::2], dtype=int)\n\n    starts -= 1\n    ends = starts + lengths\n    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)\n    for lo, hi in zip(starts, ends):\n        img[lo:hi] = 1\n    return img.reshape(shape).T  # Needed to align to RLE direction\n\ndef rle_decode(mask_rle, shape=(520, 704), color=1):\n    '''\n    mask_rle: run-length as string formated (start length)\n    shape: (height,width) of array to return \n    Returns numpy array, 1 - mask, 0 - background\n    '''\n    # Split the string by space, then convert it into a integer array\n    s = np.array(mask_rle.split(), dtype=int)\n\n    # Every even value is the start, every odd value is the \"run\" length\n    starts = s[0::2] - 1\n    lengths = s[1::2]\n    ends = starts + lengths\n\n    # The image image is actually flattened since RLE is a 1D \"run\"\n    if len(shape)==3:\n        h, w, d = shape\n        img = np.zeros((h * w, d), dtype=np.float32)\n    else:\n        h, w = shape\n        img = np.zeros((h * w,), dtype=np.float32)\n\n    # The color here is actually just any integer you want!\n    for lo, hi in zip(starts, ends):\n        img[lo : hi] = color\n        \n    # Don't forget to change the image back to the original shape\n    return img.reshape(shape)","a1232aa8":"# \u6700\u7ec8\u653e\u8fdbjson\u6587\u4ef6\u91cc\u7684\u5b57\u5178\ncoco_output = {\n    \"info\": INFO,\n    \"licenses\": LICENSES,\n    \"categories\": CATEGORIES,\n    \"images\": [],   # \u653e\u4e00\u4e2a\u7a7a\u5217\u8868\u5360\u4f4d\u7f6e\uff0c\u540e\u9762\u518dappend\n    \"annotations\": []\n}\n\nimage_id = 1\nsegmentation_id = 1\n\nimage_paths = glob(os.path.join(IMAGE_DIR,'*.png'))\n# \u904d\u5386\u6bcf\u4e00\u5f20\u56fe\u7247\nfor image_path in tqdm(image_paths,total=len(image_paths)):\n    if image_id > 5:    # delete this when used\n        break\n    # \u63d0\u53d6\u56fe\u7247\u4fe1\u606f\n    image = Image.open(image_path)\n    image_name = os.path.basename(image_path)   # \u4e0d\u9700\u8981\u5177\u4f53\u7684\u8def\u5f84\uff0c\u53ea\u8981\u56fe\u7247\u6587\u4ef6\u540d\n    image_info = pycococreatortools.create_image_info(\n        image_id, image_name, image.size)\n    coco_output[\"images\"].append(image_info)\n\n    # \u5185\u5c42\u5faa\u73af\u662fmask\uff0c\u628a\u6bcf\u4e00\u5f20\u56fe\u7247\u7684mask\u641c\u7d22\u51fa\u6765\n    rle_masks = df.loc[df['id'] == image_name[:-4], 'annotation'].tolist()\n    for index in range(len(rle_masks)):\n        binary_mask = rle_decode(rle_masks[index])\n        class_id = 1    # \u6240\u6709\u56fe\u7247\u7684\u7c7b\u522b\u90fd\u662f1\uff0cship\n        category_info = {'id': class_id, 'is_crowd': 0}\n        annotation_info = pycococreatortools.create_annotation_info(\n            segmentation_id, image_id, category_info, binary_mask,\n            image.size, tolerance=1)\n    \n        # save result\n        coco_output[\"annotations\"].append(annotation_info)\n        \n        # \u65e0\u8bba\u6807\u6ce8\u662f\u5426\u88ab\u5199\u5165\u6570\u636e\u96c6\uff0c\u5747\u5206\u914d\u4e00\u4e2a\u7f16\u53f7\n        segmentation_id = segmentation_id + 1   \n        \n    image_id = image_id + 1\n    \nwith open('instances_cell_train2021.json', 'w') as output_json_file:\n    json.dump(coco_output, output_json_file,indent=4)\n","023c73e0":"from pycocotools.coco import COCO\n\nannFile='instances_cell_train2021.json'\ncoco = COCO(annFile)","80a9f1ea":"print('categories:',coco.dataset['categories'])\nprint('image nums:',len(coco.dataset['images']))\nprint('annotation nums:',len(coco.dataset['annotations']))","e896f174":"from skimage import io\n\n# select one at random\nimgIds = coco.getImgIds(catIds=[1])\nimg = coco.loadImgs(imgIds[np.random.randint(0,len(imgIds))])[0]\nprint('file_name:',img['file_name'])\n\n# load and display origin image\nI = io.imread('%s\/%s'%(IMAGE_DIR,img['file_name']))\nplt.axis('off')\nplt.imshow(I)\nplt.show()\n\n# load and display instance annotations\nplt.imshow(I); plt.axis('off')\nannIds = coco.getAnnIds(imgIds=img['id'], catIds=[1], iscrowd=None)\nanns = coco.loadAnns(annIds)\ncoco.showAnns(anns)","052c1b17":"## Check COCO"}}