{"cell_type":{"2abddbae":"code","cb5d68ac":"code","da934e60":"code","9b872e94":"code","ea13ea48":"code","ac80980a":"code","9ffcb008":"code","d74d780b":"code","39693318":"code","f81096b2":"code","10076922":"code","caf04758":"code","d5c30011":"code","634c232b":"code","39fca15b":"code","292ae126":"code","bc90500b":"code","a6fd33c9":"code","7573ae52":"code","02438f6b":"code","78c33ef0":"code","c362114d":"code","434a7b1f":"code","95c9cb37":"code","49815044":"code","b421777b":"code","a52171f2":"code","75c1b8c0":"code","a6d33cd3":"code","f831b6ef":"markdown","a0ff6196":"markdown","22beff46":"markdown","107bc79f":"markdown","88442ba6":"markdown","29f41383":"markdown","4b9b3a11":"markdown","aad76be4":"markdown","9a34282d":"markdown","89334108":"markdown","e9b371ac":"markdown","3a40000a":"markdown","0be94051":"markdown","2c0fcee1":"markdown","8b0b7952":"markdown","2b1d77e7":"markdown","4ab0f614":"markdown","282fcea0":"markdown","3b67b5e9":"markdown","ed377083":"markdown","cd396616":"markdown","0ccdd6b5":"markdown","1bf7e5dd":"markdown","56493d06":"markdown","1d016321":"markdown","26ea9ddc":"markdown","480e315f":"markdown","caf51b3a":"markdown","b591576e":"markdown","a05dbcf8":"markdown","5e2f5eff":"markdown","3b55a87b":"markdown","5e4d1fde":"markdown","8a3f55d9":"markdown","867bf9e3":"markdown"},"source":{"2abddbae":"import gc\nimport random as rd\nimport time\nfrom math import pi\n\nimport keras\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sbn\nimport tensorflow as tf\nfrom keras.callbacks import ReduceLROnPlateau, EarlyStopping, Callback\nfrom keras.layers import (BatchNormalization, Conv2D, Dense, Dropout, Flatten,\n                          MaxPool2D, ReLU)\nfrom PIL import Image\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.model_selection import train_test_split\n%matplotlib inline","cb5d68ac":"print(\"Loading...\")\ndata_train = pd.read_csv(\"..\/input\/train.csv\")\ndata_test = pd.read_csv(\"..\/input\/test.csv\")\nprint(\"Done!\")","da934e60":"print(\"Training data: {} rows, {} columns.\".format(data_train.shape[0], data_train.shape[1]))\nprint(\"Test data: {} rows, {} columns.\".format(data_test.shape[0], data_test.shape[1]))","9b872e94":"x_train = data_train.values[:, 1:]\ny_train = data_train.values[:, 0]","ea13ea48":"def convert_2d(x):\n    \"\"\"x: 2d numpy array. m*n data image.\n       return a 3d image data. m * height * width * channel.\"\"\"\n    if len(x.shape) == 1:\n        m = 1\n        height = width = int(np.sqrt(x.shape[0]))\n    else:\n        m = x.shape[0]\n        height = width = int(np.sqrt(x.shape[1]))\n\n    x_2d = np.reshape(x, (m, height, width, 1))\n    \n    return x_2d","ac80980a":"x_display = convert_2d(data_train.values[0, 1:])\nplt.imshow(x_display.squeeze(), cmap=\"gray\")","9ffcb008":"def crop_image(x, y, min_scale):\n    \"\"\"x: 2d(m*n) numpy array. 1-dimension image data;\n       y: 1d numpy array. The ground truth label;\n       min_scale: float. The minimum scale for cropping.\n       return zoomed images.\n       This function crops the image, enlarges the cropped part and uses it as augmented data.\"\"\"\n    # convert the data to 2-d image. images should be a m*h*w*c numpy array.\n    images = convert_2d(x)\n    # m is the number of images. Since this is a gray-scale image scale from 0 to 255, it only has one channel.\n    m, height, width, channel = images.shape\n    \n    # tf tensor for original images\n    img_tensor = tf.placeholder(tf.int32, [1, height, width, channel])\n    # tf tensor for 4 coordinates for corners of the cropped image\n    box_tensor = tf.placeholder(tf.float32, [1, 4])\n    box_idx = [0]\n    crop_size = np.array([height, width])\n    # crop and resize the image tensor\n    cropped_img_tensor = tf.image.crop_and_resize(img_tensor, box_tensor, box_idx, crop_size)\n    # numpy array for the cropped image\n    cropped_img = np.zeros((m, height, width, 1))\n\n    with tf.Session() as sess:\n\n        for i in range(m):\n            \n            # randomly select a scale between [min_scale, min(min_scale + 0.05, 1)]\n            rand_scale = np.random.randint(min_scale * 100, np.minimum(min_scale * 100 + 5, 100)) \/ 100\n            # calculate the 4 coordinates\n            x1 = y1 = 0.5 - 0.5 * rand_scale\n            x2 = y2 = 0.5 + 0.5 * rand_scale\n            # lay down the cropping area\n            box = np.reshape(np.array([y1, x1, y2, x2]), (1, 4))\n            # save the cropped image\n            cropped_img[i:i + 1, :, :, :] = sess.run(cropped_img_tensor, feed_dict={img_tensor: images[i:i + 1], box_tensor: box})\n    \n    # flat the 2d image\n    cropped_img = np.reshape(cropped_img, (m, -1))\n    cropped_img = np.concatenate((y.reshape((-1, 1)), cropped_img), axis=1).astype(int)\n\n    return cropped_img","d74d780b":"def translate(x, y, dist):\n    \"\"\"x: 2d(m*n) numpy array. 1-dimension image data;\n       y: 1d numpy array. The ground truth label;\n       dist: float. Percentage of height\/width to shift.\n       return translated images.\n       This function shift the image to 4 different directions.\n       Crop a part of the image, shift it and fill the left part with 0.\"\"\"\n    # convert the 1d image data to a m*h*w*c array\n    images = convert_2d(x)\n    m, height, width, channel = images.shape\n    \n    # set 4 groups of anchors. The first 4 int in a certain group lay down the area we crop.\n    # The last 4 sets the area to be moved to. E.g.,\n    # new_img[new_top:new_bottom, new_left:new_right] = img[top:bottom, left:right]\n    anchors = []\n    anchors.append((0, height, int(dist * width), width, 0, height, 0, width - int(dist * width)))\n    anchors.append((0, height, 0, width - int(dist * width), 0, height, int(dist * width), width))\n    anchors.append((int(dist * height), height, 0, width, 0, height - int(dist * height), 0, width))\n    anchors.append((0, height - int(dist * height), 0, width, int(dist * height), height, 0, width))\n    \n    # new_images: d*m*h*w*c array. The first dimension is the 4 directions.\n    new_images = np.zeros((4, m, height, width, channel))\n    for i in range(4):\n        # shift the image\n        top, bottom, left, right, new_top, new_bottom, new_left, new_right = anchors[i]\n        new_images[i, :, new_top:new_bottom, new_left:new_right, :] = images[:, top:bottom, left:right, :]\n    \n    new_images = np.reshape(new_images, (4 * m, -1))\n    y = np.tile(y, (4, 1)).reshape((-1, 1))\n    new_images = np.concatenate((y, new_images), axis=1).astype(int)\n\n    return new_images","39693318":"def add_noise(x, y, noise_lvl):\n    \"\"\"x: 2d(m*n) numpy array. 1-dimension image data;\n       y: 1d numpy array. The ground truth label;\n       noise_lvl: float. Percentage of pixels to add noise in.\n       return images with white noise.\n       This function randomly picks some pixels and replace them with noise.\"\"\"\n    m, n = x.shape\n    # calculate the # of pixels to add noise in\n    noise_num = int(noise_lvl * n)\n\n    for i in range(m):\n        # generate n random numbers, sort it and choose the first noise_num indices\n        # which equals to generate random numbers w\/o replacement\n        noise_idx = np.random.randint(0, n, n).argsort()[:noise_num]\n        # replace the chosen pixels with noise from 0 to 255\n        x[i, noise_idx] = np.random.randint(0, 255, noise_num)\n\n    noisy_data = np.concatenate((y.reshape((-1, 1)), x), axis=1).astype(\"int\")\n\n    return noisy_data","f81096b2":"def rotate_image(x, y, max_angle):\n    \"\"\"x: 2d(m*n) numpy array. 1-dimension image data;\n       y: 1d numpy array. The ground truth label;\n       max_angle: int. The maximum degree for rotation.\n       return rotated images.\n       This function rotates the image for some random degrees(0.5 to 1 * max_angle degree).\"\"\"\n    images = convert_2d(x)\n    m, height, width, channel = images.shape\n    \n    img_tensor = tf.placeholder(tf.float32, [m, height, width, channel])\n    \n    # half of the images are rotated clockwise. The other half counter-clockwise\n    # positive angle: [max\/2, max]\n    # negative angle: [360-max\/2, 360-max]\n    rand_angle_pos = np.random.randint(max_angle \/ 2, max_angle, int(m \/ 2))\n    rand_angle_neg = np.random.randint(-max_angle, -max_angle \/ 2, m - int(m \/ 2)) + 360\n    rand_angle = np.transpose(np.hstack((rand_angle_pos, rand_angle_neg)))\n    np.random.shuffle(rand_angle)\n    # convert the degree to radian\n    rand_angle = rand_angle \/ 180 * pi\n    \n    # rotate the images\n    rotated_img_tensor = tf.contrib.image.rotate(img_tensor, rand_angle)\n\n    with tf.Session() as sess:\n        rotated_imgs = sess.run(rotated_img_tensor, feed_dict={img_tensor: images})\n    \n    rotated_imgs = np.reshape(rotated_imgs, (m, -1))\n    rotated_imgs = np.concatenate((y.reshape((-1, 1)), rotated_imgs), axis=1)\n    \n    return rotated_imgs","10076922":"start = time.clock()\nprint(\"Augment the data...\")\ncropped_imgs = crop_image(x_train, y_train, 0.9)\ntranslated_imgs = translate(x_train, y_train, 0.1)\nnoisy_imgs = add_noise(x_train, y_train, 0.1)\nrotated_imgs = rotate_image(x_train, y_train, 10)\n\ndata_train = np.vstack((data_train, cropped_imgs, translated_imgs, noisy_imgs, rotated_imgs))\nnp.random.shuffle(data_train)\nprint(\"Done!\")\ntime_used = int(time.clock() - start)\nprint(\"Time used: {}s.\".format(time_used))","caf04758":"x_train = data_train[:, 1:]\ny_train = data_train[:, 0]\nx_test = data_test.values\nprint(\"Augmented training data: {} rows, {} columns.\".format(data_train.shape[0], data_train.shape[1]))","d5c30011":"x_train = convert_2d(x_train)\nx_test = convert_2d(x_test)","634c232b":"num_classes = 10\ny_train = keras.utils.to_categorical(y_train, num_classes)","39fca15b":"x_train = x_train \/ 255\nx_test = x_test \/ 255","292ae126":"# generate a random seed for train-test-split\nseed = np.random.randint(1, 100)\nx_train, x_dev, y_train, y_dev = train_test_split(x_train, y_train, test_size=0.1, random_state=seed)","bc90500b":"del data_train\ndel data_test\ngc.collect()","a6fd33c9":"# number of channels for each of the 4 convolutional layers. \nfilters = (32, 32, 64, 64)\n# I use a 5x5 kernel for every conv layer\nkernel = (5, 5)\n# the drop probability of the dropout layer\ndrop_prob = 0.2\n\nmodel = keras.models.Sequential()\n\nmodel.add(Conv2D(filters[0], kernel, padding=\"same\", input_shape=(28, 28, 1),\n                 kernel_initializer=keras.initializers.he_normal()))\nmodel.add(BatchNormalization())\nmodel.add(ReLU())\nmodel.add(Conv2D(filters[0], kernel, padding=\"same\",\n                 kernel_initializer=keras.initializers.he_normal()))\nmodel.add(BatchNormalization())\nmodel.add(ReLU())\nmodel.add(MaxPool2D())\nmodel.add(Dropout(drop_prob))\n\nmodel.add(Conv2D(filters[1], kernel, padding=\"same\",\n                 kernel_initializer=keras.initializers.he_normal()))\nmodel.add(BatchNormalization())\nmodel.add(ReLU())\nmodel.add(MaxPool2D())\nmodel.add(Dropout(drop_prob))\n\nmodel.add(Conv2D(filters[2], kernel, padding=\"same\",\n                 kernel_initializer=keras.initializers.he_normal()))\nmodel.add(BatchNormalization())\nmodel.add(ReLU())\nmodel.add(MaxPool2D())\nmodel.add(Dropout(drop_prob))\n\nmodel.add(Conv2D(filters[3], kernel, padding=\"same\",\n                 kernel_initializer=keras.initializers.he_normal()))\nmodel.add(BatchNormalization())\nmodel.add(ReLU())\nmodel.add(MaxPool2D())\nmodel.add(Dropout(drop_prob))\n\n# several fully-connected layers after the conv layers\nmodel.add(Flatten())\nmodel.add(Dropout(drop_prob))\nmodel.add(Dense(128, activation=\"relu\"))\nmodel.add(Dropout(drop_prob))\nmodel.add(Dense(num_classes, activation=\"softmax\"))\n# use the Adam optimizer to accelerate convergence\nmodel.compile(keras.optimizers.Adam(), \"categorical_crossentropy\", metrics=[\"accuracy\"])","7573ae52":"model.summary()","02438f6b":"# number of epochs we run\niters = 100\n# batch size. Number of images we train before we take one step in MBGD.\nbatch_size = 1024","78c33ef0":"# monitor: the quantity to be monitored. When it no longer improves significantly, we lower the learning rate\n# factor: new learning rate = old learning rate * factor\n# patience: number of epochs we wait before we decrease the learning rate\n# verbose: whether or not the message are displayed\n# min_lr: the minimum learning rate\nlr_decay = ReduceLROnPlateau(monitor=\"val_acc\", factor=0.5, patience=3, verbose=1, min_lr=1e-5)","c362114d":"# monitor: the quantity to be monitored. When it no longer improves significantly, stop training\n# patience: number of epochs we wait before training is stopped\n# verbose: whether or not to display the message\nearly_stopping = EarlyStopping(monitor=\"val_acc\", patience=7, verbose=1)","434a7b1f":"print(\"Training model...\")\nfit_params = {\n    \"batch_size\": batch_size,\n    \"epochs\": iters,\n    \"verbose\": 1,\n    \"callbacks\": [lr_decay, early_stopping],\n    \"validation_data\": (x_dev, y_dev)                   # data for monitoring the model accuracy\n}\nhistory = model.fit(x_train, y_train, **fit_params)\nprint(\"Done!\")","95c9cb37":"train_acc = history.history[\"acc\"]\nval_acc = history.history[\"val_acc\"]\ntrain_loss = history.history[\"loss\"]\nval_loss = history.history[\"val_loss\"]\n\nplt.plot(train_acc)\nplt.plot(val_acc)\nplt.xlabel(\"epoch\")\nplt.ylabel(\"accuracy\")\nplt.legend([\"train_acc\", \"val_acc\"], loc=\"upper right\")\nplt.show()","49815044":"plt.plot(train_loss)\nplt.plot(val_loss)\nplt.xlabel(\"epoch\")\nplt.ylabel(\"loss\")\nplt.legend([\"train_loss\", \"val_loss\"], loc=\"upper right\")\nplt.show()","b421777b":"loss, acc = model.evaluate(x_dev, y_dev)\nprint(\"Validation loss: {:.4f}\".format(loss))\nprint(\"Validation accuracy: {:.4f}\".format(acc))","a52171f2":"num_samples = 10\ndev_size = x_dev.shape[0]\nsample_idx = np.random.randint(dev_size, size=num_samples)\nx_samples = x_dev[sample_idx, :, :, :]\ny_samples_pred = np.argmax(model.predict(x_samples), axis=1)\n\nplt.figure(figsize=(20, 10))\nfor i in range(num_samples):\n    \n    plt.subplot(2, 5, i + 1)\n    plt.imshow(x_samples[i, :, :, 0], cmap=\"gray\")\n    plt.title(\"Prediction: {}\".format(y_samples_pred[i]))","75c1b8c0":"y_val_true = np.argmax(y_dev, axis=1)\ny_val_pred = np.argmax(model.predict(x_dev), axis=1)\nconf_matrix = pd.DataFrame(confusion_matrix(y_val_true, y_val_pred), index=[i for i in range(10)], columns=[i for i in range(10)])\nplt.figure(figsize = (10,7))\nsbn.heatmap(conf_matrix, annot=True)","a6d33cd3":"y_pred = model.predict(x_test, batch_size=batch_size)\ny_pred = np.argmax(y_pred, axis=1).reshape((-1, 1))\nidx = np.reshape(np.arange(1, len(y_pred) + 1), (len(y_pred), -1))\ny_pred = np.hstack((idx, y_pred))\ny_pred = pd.DataFrame(y_pred, columns=['ImageId', 'Label'])\ny_pred.to_csv('y_pred.csv', index=False)","f831b6ef":"If our model are not getting any better on the validation data, we can set early stopping to prevent overfitting and also save some time. Early stopping stops the training when the monitored quantity doesn't improve.","a0ff6196":"### 2.2.3 Add White Noise\nNow we add some white noise to the image. We randomly choose some pixels and replace them with uniformly-distributed noise.","22beff46":"## 4.2 Evaluate the Model\nNow we need to evaluate our trained model on the validation data.","107bc79f":"Also, we need the label variable to be a dummy variable, which only contains 1 and 0. We will use a Keras utility function to do the conversion.","88442ba6":"Now we put them all together.","29f41383":"The list above is the structure of my CNN model. It goes:\n- (Conv-ReLU-BatchNormalization-MaxPooling-Dropout) x 4;\n- 3 fully-connected(dense) layers with 1 dropout layer. Dense(64)-Dense(128)-Dropout-Dense(with softmax activation).\n\n- In CNN people often use 3x3 or 5x5 kernel. I found that with a 5x5 kernel, the model's accuracy improved about 0.125%, which is quite a lot when you pass 99% threshold.\n- Convolutional layers and max pooling layers can extract some high-level traits from the pixels. With the [ReLU](https:\/\/en.wikipedia.org\/wiki\/Rectifier_(neural_networks)) unit the and max pooling, we also add non-linearity into the network;\n- Batch normalization helps the network converge faster since it keeps the input of every layer at the same scale;\n- [Dropout](https:\/\/en.wikipedia.org\/wiki\/Convolutional_neural_network#Dropout) layers help us prevent overfitting by randomly drop some of the input units. With dropout our model won't overfit to some specific extreme data or some noisy pixels;\n- The [Adam optimizer](https:\/\/en.wikipedia.org\/wiki\/Stochastic_gradient_descent#Adam) also accelerates the optimization. Usually when the dataset is too large, we use mini-batch gradient descent or stochastic gradient descent to save some training time. The randomness in MBGD or SGD means that the steps towards the optimum are zig-zag rather than straight forward. Adam, or Adaptive Moment Estimation, uses exponential moving average on the gradients and the secend moment of gradients to make the steps straight and in turn accelerate the optimization.","4b9b3a11":"## 2.2 Data Augmentation\n\nHere we delve straight into data augmentation. Data augmentation is a useful technique when you don't have enough data or would like to expand your data to improve the performance. In this competition, data augmentation basically means cutting, rotating and zooming the image without hurting its identifiability. Here I used zooming, translation, white noise and rotation. With data augmentation, you can expect a 1-2% accuracy improvement.","aad76be4":"There are 42,000 rows in the training data and 28,000 rows in the test data. Each row of the training set contains the image (28x28=784) and the label in the first column. The test data doesn't have the labels.","9a34282d":"Now we need to convert the 1d image data to 2-dimension.","89334108":"### 2.2.2 Translation\nNow we shift the image to 4 different directions. ","e9b371ac":"## 2.1 Data Exploration\n\nFirst load the data.","3a40000a":"Now let's plot the confusion matrix to see where we make mistakes most often.","0be94051":"# 5 Output the Prediction","2c0fcee1":"In Andrew Ng's deep learning course, he mentioned that it would be better to set the batch size to the power of 2 due to some reasons regarding hardware or TensorFlow underlying code. Not so sure about that.","8b0b7952":"Delete the original data_train to save some RAM.","2b1d77e7":"Now we plot the loss and accuracy history of the model.","4ab0f614":"## 2.3 Data Preparation","282fcea0":"# 4 Training and Evaluation","3b67b5e9":"Now we split the dataset into the training set and the developing(validation) set.","ed377083":"The values in the image range from 0 to 255. It would be easier for CNN to converge if we scale down these values. Thus, we divide all pixels by 255.","cd396616":"When we reach close to the optimum, we need to lower our learning rate to prevent overshooting. Large learning rate would keep us away from the optimum. Thus, I set this learning rate decay to decrease it when the accuracy on the validation data no longer improves.","0ccdd6b5":"On the validation set our model reached an accuracy over 99%, which is pretty good. Now let's see some sample prediction:","1bf7e5dd":"## 4.1 Train the Model\nNow we need to train our model. First let's set some basic hyperparameters for training.","56493d06":"### 2.2.1 Zoom In\nHere we use crop_image function to crop a part of the image around the center, resize it and save it as augmented data.","1d016321":"# 1 Introduction\n\nThe Digit Recognizer competition uses the famous MNIST hand-written number dataset, which is the hello-world dataset for computer vision. Here we are required to identify numbers from images. The training data contains 42,000 hand-written number images, each one of which is 28 pixels in height and 28 pixels in width. Simple models such as KNN or MLP are not as capable of this task as Convolutional Neural Network. Here I used Keras to build my CNN, for that it is more friendly to beginners than TensorFlow and these two are the only two DL frameworks that I am familiar with. Please do turn on the GPU button when running this kernel because it is extremely time-consuming to run CNN on CPU. It usually took me 50+ hours to run this code for 100 epochs on my laptop. With the Tesla K80 GPU, 100 epochs took only a little more than 1 hour. With early stopping, sometimes it only took around 15 mins to run","26ea9ddc":"Now let's see how the numbers look like. We will use the convert_2d function to convert the 1d data into two dimensions.","480e315f":"We can see that the model sometimes confuse 1 or 2 with 7, and 4 with 9.","caf51b3a":"Now we train the model.","b591576e":"Now we output the predictions and save it in a .csv file.","a05dbcf8":"Let's check the augmented data.","5e2f5eff":"# 2 Data Exploration, Augmentation and Preparation","3b55a87b":"# A Beginner's Guide - CNN with Keras\n\nKaiming Kuang\n\nThis is a beginner's guide of the Digit Recognizer competition. Some basic knowledges about the theory and practice of deep learning is still required. Here are some prerequisite readings on Convolutional Neural Network:\n- [Wikipedia of CNN](https:\/\/en.wikipedia.org\/wiki\/Convolutional_neural_network)\n- [A Beginner's Guide To Understanding Convolutional Neural Networks by Adit Deshpande](https:\/\/adeshpande3.github.io\/adeshpande3.github.io\/A-Beginner's-Guide-To-Understanding-Convolutional-Neural-Networks\/)\n\nThere is also a course on Coursera. I learned most of the basics from this course of Andrew Ng:\n- [Coursera: Convolutional Neural Network by Andrew Ng](https:\/\/www.coursera.org\/learn\/convolutional-neural-networks?specialization=deep-learning)\n\n## Content\n- 1 Introduction\n- 2 Data Exploration, Augmentation and Preparation\n    - 2.1 Data Exploration\n    - 2.2 Data Augmentation\n        - 2.2.1 Zoom In\n        - 2.2.2 Translation\n        - 2.2.3 Add White Noise\n        - 2.2.4 Rotation\n    - 2.3 Data Preparation\n- 3 CNN Structure\n- 4 Training and Evaluation\n    - 4.1 Train the Model\n    - 4.2 Evaluate the Model\n- 5 Output the Prediction","5e4d1fde":"### 2.2.4 Rotation\nNow we rotate the image.","8a3f55d9":"First we should import all the libraries we need in this kernel:\n- gc: The built-in garbage collection of Python. We need to delete some variables and collect spaces when necessary to save RAM.\n- random: The built-in package of Python. We need it to generate random numbers.\n- time: The built-in package of Python. Use it to check running time.\n- pi: In the data augmentation part we use pi to rotate the image.\n- keras: We need Keras to build our CNN model. It uses TensorFlow as backend. [Documentation of Keras](https:\/\/keras.io\/).\n- matplotlib.pyplot: We use pyplot to plot the hand-written number image.\n- numpy: We need Numpy to do all the matrix manipulation. [Documentation of Numpy](https:\/\/docs.scipy.org\/doc\/numpy\/reference\/).\n- pandas: We use Pandas to manipulate data, such as loading and outputing .csv files. [Documentation of Pandas](http:\/\/pandas.pydata.org\/pandas-docs\/stable\/).\n- tensorflow: TensorFlow is a popular deep learning framework. We use TensorFlow for the data augmentation part. [Documentation of TensorFlow](https:\/\/tensorflow.google.cn\/api_docs\/python\/tf).\n- ReduceLROnPlateau: This is the model we use to set up a learning rate decay.\n- BatchNormalization, Conv2D, Dense, Dropout, Flatten, MaxPool2D: These are some basic building blocks we need to set up CNN.\n- Image: This package is used for image display.\n- train_test_split: We use this module of sklearn to split the data into trainning and validation part.","867bf9e3":"# 3 CNN Structure\n\nA normal CNN usually consists of 3 types of layers, convolutional layers, pooling layers and fully-connected layers. I also added normalization layers and dropout layers into my model. Here is how I set up the CNN structure."}}