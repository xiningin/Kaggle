{"cell_type":{"f9357a1e":"code","28baf4d2":"code","cba94fe4":"code","e34c5e3e":"code","d0ce3570":"code","b72f6357":"code","565b2222":"code","a08cf871":"code","47399fb9":"code","93720a86":"code","66faf741":"code","74f24d97":"code","287bef2b":"code","aab6dc3e":"code","9b0eae2f":"code","f638709a":"code","3ed2ffb7":"code","3297beb5":"code","adc94132":"markdown","08c13350":"markdown","81e36001":"markdown","8ee12dbf":"markdown","6450be5f":"markdown","d8aa856c":"markdown","0e5abaee":"markdown","611c3192":"markdown","b8531a14":"markdown","3b71407c":"markdown","27b364f6":"markdown"},"source":{"f9357a1e":"# Import libraries\nimport numpy as np\nimport pandas as pd\nimport re\nimport seaborn as sns\nsns.set()\n\n# Import data\ntrain_data = pd.read_csv('..\/input\/train.csv')\ntest_data = pd.read_csv('..\/input\/test.csv')\nfull_data = pd.concat([train_data, test_data])","28baf4d2":"full_data.info()","cba94fe4":"full_data.Name[train_data.Age > 18].head(10)\n# Mr and Mrs have periods so let's check children\n# full_data.Name[train_data.Age < 18].head(10)\n# Master and Miss have a period as well, so assume this holds for all titles, for example Dr., Rev. etc","e34c5e3e":"def find_title(name):\n    # search name for title with a period and return the match if it's found\n    title = re.search(' ([A-Za-z]+)\\.', name)\n    if title: return title.group(1)\n    else: return \"\"","d0ce3570":"titles = full_data.Name.apply(find_title)\ntitles.unique().tolist()","b72f6357":"full_data['Title'] = full_data['Name'].apply(find_title)\nfull_data['Title'] = full_data['Title'].replace('Mme', \"Mrs\")\nfull_data['Title'] = full_data['Title'].replace('Ms', \"Miss\")\nfull_data['Title'] = full_data['Title'].replace('Mlle', \"Miss\")\nfull_data['Title'] = full_data['Title'].replace(['Don', 'Rev', 'Dr', 'Major', 'Lady', 'Sir', 'Col', 'Capt', 'Countess', 'Jonkheer', 'Dona'], 'Other')\n\nfull_data.groupby('Title').Age.describe()\n\nfull_data.iloc[[61,829]]","565b2222":"sns.boxplot(y='Fare',x='Embarked',hue='Pclass',data=full_data)","a08cf871":"train_data['Embarked'].fillna('C', inplace=True)","47399fb9":"### This is more advanced - ignore for now\n# def find_deck(cabin):\n#     if(pd.notnull(cabin)):\n#         # extract the deck letter and number of cabins\n#         t = re.findall('([A-Z])', cabin)\n#         return [t[0], len(t)] # deck letter, number of cabins\n#     else:\n#         return ['', 0]\ndef find_deck(cabin):\n    if(pd.notnull(cabin)): return re.match('([A-Z])', cabin).group(1)\n    else: return 'Unknown'","93720a86":"# find_deck(train_data.Cabin[0])\n# find_deck(train_data.Cabin[27])\nfull_data.Cabin.apply(find_deck).unique().tolist()","66faf741":"class_fare = full_data.groupby('Pclass').Fare.median()","74f24d97":"class_age = full_data.groupby('Title').Age.median()","287bef2b":"for i, df in enumerate([train_data, test_data]):\n    \n    # Creade dummy variables for Sex and drop original, as well as an unnecessary column (male or female)\n    df = df.join(pd.get_dummies(df['Sex']))\n    df.drop(['Sex', 'male'], inplace=True, axis=1)\n    \n    # Fix titles, replacing equivelent titles, and grouping unusual titles into 'Other'\n    df['Title'] = df['Name'].apply(find_title)\n    df['Title'] = df['Title'].replace('Mme', \"Mrs\")\n    df['Title'] = df['Title'].replace('Ms', \"Miss\")\n    df['Title'] = df['Title'].replace('Mlle', \"Miss\")\n    df['Title'] = df['Title'].replace(['Don', 'Rev', 'Dr', 'Major', 'Lady', 'Sir', 'Col', 'Capt', 'Countess', 'Jonkheer', 'Dona'], 'Other')\n\n    # Estimate missing ages - replace missing age with the median value of the group with the same title\n    nullAge = df.Age.isnull()\n    for title, age in class_age.iteritems():\n        df.loc[(nullAge) & (df['Title'] == title), 'Age'] = age\n\n    # Assign numbers to titles and drop name column\n    df['Title'] = df['Title'].map({\"Mr\": 1, \"Miss\": 2, \"Mrs\": 3, \"Master\": 4, \"Other\": 5})\n    df.drop(['Name', 'Title'], inplace=True, axis=1)\n    \n    # Create dummmy variables for Embarked and remove redundant column\n    df = df.join(pd.get_dummies(df['Embarked'], prefix='Embarked'))\n    df.drop(['Embarked', 'Embarked_S'], inplace=True, axis=1)\n    \n    # Fix cabin information by ignoring the cabin number and replace with deck\n    # Use dummy variables for deck\n#     df['Deck'] = df['Cabin'].apply(find_deck)\n#     decks = [\"deck_\" + d for d in ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'T', 'Unknown']]\n#     df['Deck'] = df['Deck'].map({deck : j+1 for j, deck in enumerate(decks)})\n#     # Need to reindex as test data doesn't contain every deck\n#     df = df.join(pd.get_dummies(df['Deck']).reindex(columns=decks, fill_value=0)) \n#     df.drop(['Cabin', 'Deck'], inplace=True, axis=1)\n    df.drop('Cabin', inplace=True, axis=1)\n\n    # Create new FamilySize feature: Number of Sibling\/Spouse aboard + Number of Parent\/Child aboard + original person\n    # Drop unnecessary columns\n    df['FamilySize'] = df['SibSp'] + df['Parch'] + 1\n#     df.drop(['SibSp', 'Parch'], inplace=True, axis=1)\n\n    # Bin ages \n    nbins = 5\n    labels=[j+1 for j in range(nbins)]\n    df['Age'] = pd.qcut(df['Age'], nbins, labels=labels)\n\n    # Create new feature relating Age and Class = Age * Class\n    df['AgeTimesClass'] = df['Age'].values * df['Pclass'].values\n\n    # Fill in missing fares based on median of that class, and Group Fares into bins\n    nullFare = df.Fare.isnull()\n    for c, fare in class_fare.iteritems():\n        df.loc[(nullFare) & (df['Pclass'] == c), 'Fare'] = fare\n    nbins = 4\n    labels=[j+1 for j in range(nbins)]\n    df['Fare'] = pd.qcut(df['Fare'], nbins, labels=labels)\n\n    # Create new feature for FarePerPerson = Fare\/FamilySize\n    df['FarePerPerson'] = df['Fare'].values \/ df['FamilySize'].values\n\n    # Create dummy variables for Class\n    df = df.join(pd.get_dummies(df['Pclass'], prefix='class'))\n    df.drop(['Pclass', 'class_3'], inplace=True, axis=1)\n\n    # Ticket feature provides no useful information, so drop it\n    df.drop('Ticket', inplace=True, axis=1)\n\n    if i == 0:\n        df.drop('PassengerId', inplace=True, axis=1)\n        X_train, y_train = df.loc[:, df.columns != 'Survived'], df.loc[:, df.columns == 'Survived']\n    else:\n        submission_id = df['PassengerId']\n        df.drop('PassengerId', inplace=True, axis=1)\n        X_test = df","aab6dc3e":"# X_test.info()\nX_train.info()","9b0eae2f":"from sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import KFold\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Function to fit a series of decision trees with a different number of leaf nodes to optimise fit\ndef get_accuracy(n_splits, max_leaf_nodes, n_estimators, X_train, y_train):\n    model = RandomForestClassifier(n_estimators=n_estimators, max_leaf_nodes=max_leaf_nodes, random_state=1)\n    kf = KFold(n_splits=n_splits, random_state=1)\n    kf_acc = 0\n    for train_index, test_index in kf.split(X_train):\n        kf_X_train, kf_X_test = X_train.values[train_index], X_train.values[test_index]\n        kf_y_train, kf_y_test = y_train.values[train_index].ravel(), y_train.values[test_index].ravel()\n        model.fit(kf_X_train, kf_y_train)\n        kf_acc += accuracy_score(kf_y_test, model.predict(kf_X_test))\n    return kf_acc \/ n_splits\n\ncandidate_max_leaf_nodes = range(5, 100, 5)\nn_splits = 5\nn_estimators = 500\n\nall_accuracy = [get_accuracy(n_splits, n, n_estimators, X_train, y_train) for n in candidate_max_leaf_nodes]\nsns.lineplot(candidate_max_leaf_nodes, all_accuracy)\nind = all_accuracy.index(max(all_accuracy))\nbest_tree_size = candidate_max_leaf_nodes[ind]\nprint(\"best_tree_size = {:d}\".format(best_tree_size))\nprint(\"Validation accuracy for Random Forest Model: {:.6f}\".format(all_accuracy[ind]))\n\n# Initialize model\nrf_model = RandomForestClassifier(n_estimators=n_estimators, max_leaf_nodes=best_tree_size, random_state=1)\n# Fit data\nrf_model.fit(X_train, y_train.values.ravel())","f638709a":"# Make submission file of passenger ids and predictions\ny_pred = pd.Series(rf_model.predict(X_test))\nsubmission = pd.concat([submission_id, y_pred], axis=1)\nsubmission = submission.rename(columns={0:'Survived'})\nsubmission.to_csv('submisson.csv', index=False)","3ed2ffb7":"importances = rf_model.feature_importances_\nsns.barplot(importances, X_train.columns)","3297beb5":"# from sklearn.ensemble import GradientBoostingClassifier\n# clf = GradientBoostingClassifier(n_estimators=500, learning_rate=1,max_leaf_nodes=50, random_state=1, loss='deviance')\n# clf.fit(X_train, y_train.values.ravel\u00e5())\n# accuracy_score(clf.predict(X_test), val_y)","adc94132":"## Preprocessing\n* Here we apply all the preprocessing described above","08c13350":"* It looks like a fare of 80$ in first class is similar to the median of Cherburg, so lets assign C to the missing data","81e36001":"### Sex & Name\n* While we know the sex of the person, their name will allow us to distinguish if they are an adult or child. We need to check what title is given to each entry, and if there are any unusual titles.\n* It appears titles are written with a period, so lets search for words with periods to extract titles.","8ee12dbf":"## Exploring features\nLet's see what features are in the data","6450be5f":"The deck letters are thus (from top to bottom), A, B, C, D, E, F, G, T and 'unknown'\n\n### Fare\n* Find the median fare in a given class and use it to fill in the missing values","d8aa856c":"### Cabin & Fare\n* There is a lot of missing cabin information, but we may be able to estimate the missing deck information based on the fare.\n* Let's simplify things by only using the deck info, ignoring cabin number\n* **to add later** Some people have more than 1 cabin, so lets create a new column with this info, and also use it to better estimate the missing deck information","0e5abaee":"### Age\n* Find the median age in a given class and use it to fill in the missing values","611c3192":"## Modelling\n* Now we have preprocess the dataset, it's time to model.\n\n## Random Forest\n* Let's try a random forest classifier first","b8531a14":"### Summary\n* there missing values in Age, Cabin and Embarked","3b71407c":"## Info on dataset\nThis dataset gives us information about the passengers onboard the Titanic, and tells us if they survived it's sinking or not. The goal is to predict whether the people in the test set survived or not.","27b364f6":"Some of these can be combined, as Mme is French for Mrs. Others can be grouped as they are rare and may be more important\n\n## Embarked\n* There are two missing values in the embarked data\n* Lets compare the Fare and Class to see if we can give an informed guess"}}