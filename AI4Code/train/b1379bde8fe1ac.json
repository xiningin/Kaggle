{"cell_type":{"f0605944":"code","8951d3bf":"code","816f9df6":"code","0db76c31":"code","f668fd59":"code","cbed77e2":"code","6c241675":"code","195340f7":"code","95976027":"code","340c8db7":"code","4094a7a8":"code","a40c8979":"code","31868d03":"code","b440bc67":"code","bc5b99fa":"code","f299b6b5":"code","1db3fae6":"code","283b0efd":"code","35107d47":"code","329e4763":"code","7654da9c":"code","de0163d8":"code","1f6e3d14":"code","dca3a00d":"code","96d9a0e7":"code","ae3e9056":"code","e04cde8f":"code","0a51a116":"markdown","1b87e01a":"markdown","c66c1e4e":"markdown","38639a64":"markdown","53cff970":"markdown","131f2dee":"markdown","7e0a2912":"markdown","24cbb985":"markdown","fd170551":"markdown","00768655":"markdown","af87bb53":"markdown","4d00454e":"markdown","4672e90a":"markdown","f09dd78d":"markdown","67291c18":"markdown","a04807df":"markdown","b0b91ed8":"markdown","fe43f686":"markdown","dc5f122c":"markdown","e34aacff":"markdown","1a9f4278":"markdown","9f51db4c":"markdown","dc5785b1":"markdown"},"source":{"f0605944":"# math operations\nfrom numpy import inf\n\n# time operations\nfrom datetime import timedelta\n\n# for numerical analyiss\nimport numpy as np\n\n# to store and process data in dataframe\nimport pandas as pd\n\n# basic visualization package\nimport matplotlib.pyplot as plt\n\n# advanced ploting\nimport seaborn as sns\n\n# interactive visualization\nimport plotly.express as px\nimport plotly.graph_objs as go\n# import plotly.figure_factory as ff\n#from plotly.subplots import make_subplots\n\n# for offline ploting\nfrom plotly.offline import plot, iplot, init_notebook_mode\ninit_notebook_mode(connected=True)\n\n# hide warnings\nimport warnings\nwarnings.filterwarnings('ignore')","8951d3bf":"# color pallette\ncnf, dth, rec, act = '#393e46', '#ff2e63', '#21bf73', '#fe9801' ","816f9df6":"# list files\n# ==========\n\n!ls ..\/input\/corona-virus-report","0db76c31":"# Full data\n# =========\n\nfull_table = pd.read_csv('..\/input\/corona-virus-report\/covid_19_clean_complete.csv')\n\n# Deep dive into the DataFrame\n# Examine DataFrame (object type, shape, columns, dtypes)\nfull_table.info()\n\n# type(full_table)\n# full_table.shape\n# full_table.columns\n# full_table.dtypes\n# full_table.head(20)","f668fd59":"# Country wise\n# ============\n\ncountry_wise = pd.read_csv('..\/input\/corona-virus-report\/country_wise_latest.csv')\n\n# Replace missing values '' with NAN and then 0\ncountry_wise = country_wise.replace('', np.nan).fillna(0)\n\n# Deep dive into the DataFrame\ncountry_wise.info()\ncountry_wise.head(10)\n","cbed77e2":"# Grouped by day, country\n# =======================\n\nfull_grouped = pd.read_csv('..\/input\/corona-virus-report\/full_grouped.csv')\nfull_grouped.info()\nfull_grouped.head(10)\n\n# Convert Date from Dtype \"Object\" (or String) to Dtype \"Datetime\"\nfull_grouped['Date'] = pd.to_datetime(full_grouped['Date'])\nfull_grouped.info()","6c241675":"# Day wise\n# ========\n\nday_wise = pd.read_csv('..\/input\/corona-virus-report\/day_wise.csv')\nday_wise['Date'] = pd.to_datetime(day_wise['Date'])\nday_wise.info()\nday_wise.head(10)","195340f7":"# Worldometer data\n# ================\n\nworldometer_data = pd.read_csv('..\/input\/corona-virus-report\/worldometer_data.csv')\n\n# Replace missing values '' with NAN and then 0\n# What are the alternatives? Drop or impute. Do they make sense in this context?\nworldometer_data = worldometer_data.replace('', np.nan).fillna(0)\nworldometer_data['Case Positivity'] = round(worldometer_data['TotalCases']\/worldometer_data['TotalTests'],2)\nworldometer_data['Case Fatality'] = round(worldometer_data['TotalDeaths']\/worldometer_data['TotalCases'],2)\n\n# Case Positivity is infinity when there is zero TotalTests due to division by zero\nworldometer_data[worldometer_data[\"Case Positivity\"] == inf] = 0\n\n# Qcut is quantile cut. Here we specify three equally sized bins and label them low, medium, and high, respectively.\nworldometer_data ['Case Positivity Bin']= pd.qcut(worldometer_data['Case Positivity'], q=3, labels=[\"low\", \"medium\", \"high\"])\n\n# Population Structure\nworldometer_pop_struc = pd.read_csv('..\/input\/covid19-worldometer-snapshots-since-april-18\/population_structure_by_age_per_contry.csv')\n\n# Replace missing values with zeros\nworldometer_pop_struc = worldometer_pop_struc.fillna(0)\n#worldometer_pop_struc.info()\n\n# Merge worldometer_data with worldometer_pop_struc\n# Inner means keep only common key values in both datasets\nworldometer_data = worldometer_data.merge(worldometer_pop_struc,how='inner',left_on='Country\/Region', right_on='Country')\n\n# Keep observations where column \"Country\/Region\" is not 0\nworldometer_data = worldometer_data[worldometer_data[\"Country\/Region\"] != 0]\n\n# Inspect worldometer_data's metadata\nworldometer_data.info()\n\n# Inspect Data\n# worldometer_data.info()\n# worldometer_data.tail(20)\n# worldometer_data[\"Case Positivity\"].describe()\n","95976027":"# The three arguments of the function are: \n# 1. input dataframe \n# 2. variable of interest \n# 3. color palette\ndef plot_map(df, col, pal):\n    df = df[df[col]>0]\n    \n    # choropleth draws maps based on shape files of different countries\n    fig = px.choropleth(df, locations=\"Country\/Region\", locationmode='country names', \n                  color=col, hover_name=\"Country\/Region\", \n                  title=col, hover_data=[col], color_continuous_scale=pal)\n    # 1:50m resolution\n    fig.update_geos (resolution=50)\n    fig.show()","340c8db7":"# Inspect dataframe worldometer_data\nworldometer_data.info()","4094a7a8":"# Plot 'TotalCases' on world map using worldometer_data as the input dataframe with color palette 'matter'\nplot_map(worldometer_data, 'TotalCases', 'matter')","a40c8979":"# What do you read this?\nplot_map(worldometer_data, 'Tot Cases\/1M pop', 'matter')","31868d03":"# Plot log(Confirmed Cases) for each Country\/Region Over time\nfig = px.choropleth(full_grouped, locations=\"Country\/Region\", \n                    color=np.log(full_grouped[\"Confirmed\"]),\n                    locationmode='country names', hover_name=\"Country\/Region\", \n                    animation_frame=full_grouped[\"Date\"].dt.strftime('%Y-%m-%d'),\n                    title='Cases over time', color_continuous_scale=px.colors.sequential.matter)\nfig.update(layout_coloraxis_showscale=False)\nfig.update_geos (resolution=50)\nfig.show()","b440bc67":"full_grouped_Brazil=full_grouped.groupby('Country\/Region').get_group('Brazil')\ntemp = full_grouped_Brazil.groupby('Date')['Recovered', 'Deaths', 'Active'].sum().reset_index()\ntemp = temp.melt(id_vars=\"Date\", value_vars=['Recovered', 'Deaths', 'Active'],\n                 var_name='Case', value_name='Count')\ntemp.head()\n\n# Plot a stack area graph with the three types of cases (i.e., recovered, deaths, and active)\nfig = px.area(temp, x=\"Date\", y=\"Count\", color='Case', height=600, width=700,\n             title='Cases over time', color_discrete_sequence = [rec, dth, act])\nfig.update_layout(xaxis_rangeslider_visible=True)\nfig.show()","bc5b99fa":"full_grouped_India=full_grouped.groupby('Country\/Region').get_group('India')\ntemp = full_grouped_India.groupby('Date')['Recovered', 'Deaths', 'Active'].sum().reset_index()\ntemp = temp.melt(id_vars=\"Date\", value_vars=['Recovered', 'Deaths', 'Active'],\n                 var_name='Case', value_name='Count')\ntemp.head()\n\n# Plot a stack area graph with the three types of cases (i.e., recovered, deaths, and active)\nfig = px.area(temp, x=\"Date\", y=\"Count\", color='Case', height=600, width=700,\n             title='Cases over time', color_discrete_sequence = [rec, dth, act])\nfig.update_layout(xaxis_rangeslider_visible=True)\nfig.show()","f299b6b5":"def gt_n(n):\n    # Identify countries with confirmed cases greater than N\n    # Then among these countries choose the unique set of countries\n    countries = full_grouped[full_grouped['Confirmed']>n]['Country\/Region'].unique()\n    \n    # Filter countries that are in the unique set of countries with confirmed cases greater than N\n    temp = full_table[full_table['Country\/Region'].isin(countries)]\n    \n    # Aggregate (i.e., sum up) confirmed cases by Country\/Region and Date\n    # Reset the index (it is no longer in running order)\n    temp = temp.groupby(['Country\/Region', 'Date'])['Confirmed'].sum().reset_index()\n    \n    # Filter observations with confirmed cases more than N\n    temp = temp[temp['Confirmed']>n]\n    # print(temp.head())\n\n    # Identify the start date when confirmed cases exceed N for each country\n    min_date = temp.groupby('Country\/Region')['Date'].min().reset_index()\n    \n    # Name the columns in the dataframe min_date\n    min_date.columns = ['Country\/Region', 'Min Date']\n    # print(min_date.head())\n\n    # Merge dataframe temp with dataframe min_date by 'Country\/Region'\n    from_nth_case = pd.merge(temp, min_date, on='Country\/Region')\n    \n    # Convert data type to datetime object\n    from_nth_case['Date'] = pd.to_datetime(from_nth_case['Date'])\n    from_nth_case['Min Date'] = pd.to_datetime(from_nth_case['Min Date'])\n    \n    # Create a variable that counts the number of days relative to the day when confirmed cases exceed N\n    from_nth_case['N days'] = (from_nth_case['Date'] - from_nth_case['Min Date']).dt.days\n    # print(from_nth_case.head())\n\n    # Plot a line graph from dataframe from_nth_case with column 'N days' and 'Confirmed' mapped to x-axis and y-axis, respectively.\n    # Distinguish each country by color (system-determined color)\n    # str converts n integer into string and \"'N days from '+ str(n) +' case'\" is the title \n    fig = px.line(from_nth_case, x='N days', y='Confirmed', color='Country\/Region', \n                  title='N days from '+ str(n) +' case', height=600)\n    fig.show()","1db3fae6":"# Call function gt_n with argument 100000 (i.e., 100000 confirmed cases)\ngt_n(100000)","283b0efd":"# Draw horizontal bar plot with three arguments\n# 1. variable of interest\n# 2. top n countries\n# 3. minimum population size (default value is 1000000)\ndef plot_hbar_wm(col, n, min_pop=1000000):\n    df = worldometer_data[worldometer_data['Population']>min_pop]\n    df = df.sort_values(col, ascending=True).tail(n)\n    df.info()\n    fig = px.bar(df,\n                 x=col, y=\"Country\/Region\", color='WHO Region',  \n                 text=col, orientation='h', width=700, \n                 color_discrete_sequence = px.colors.qualitative.Dark2)\n    fig.update_layout(title=col+' (Only countries with Population > ' + str(min_pop), \n                      xaxis_title=\"\", yaxis_title=\"\", \n                      yaxis_categoryorder = 'total ascending',\n                      uniformtext_minsize=8, uniformtext_mode='hide')\n    fig.show()\n    \n# Draw histogram with two arguments\n# 1. variable of interest\n# 2. the number of bins\ndef plot_histogram_wm(col, bins):\n    fig = px.histogram(worldometer_data[col], x=col, nbins=bins)\n    fig.show()","35107d47":"# Draw bar chart for case fatality of the top 15 countries with the highest case fatality rate (with the minimum population of 1 million)\nplot_hbar_wm('Case Fatality', 15, 1000000)","329e4763":"# Draw the histogram for case fatality rate (50 bins)\nplot_histogram_wm(\"Case Fatality\",50)","7654da9c":"# Draw a joint plot to diagnose the relationship between Tests\/1M population vs Total Cases\/1M population\n# Draw a regression line on the scatter plot\nsns.jointplot(x = 'Tests\/1M pop', y = 'Tot Cases\/1M pop', data = worldometer_data, kind='reg')","de0163d8":"# Show the descriptive statistics for case positivity bin (categorical variable)\nworldometer_data.groupby('Case Positivity Bin')['Case Positivity Bin'].describe()","1f6e3d14":"# Draw a Violin plot to diagnose the relationship betwen case positivity and case fatality rates\nfig = go.Figure()\n\n# Create a list of case positivity bin categories\nbins = ['low', 'medium', 'high']\n\n# Loop through each case positivity bin\nfor bin in bins:\n    \n    # worldometer_data['Case Positivity Bin'][worldometer_data['Case Positivity Bin'] == bin] means take the column 'Case Positivity Bin' and\n    # filter the column, such that Case Positivity Bin equals 'low', 'medium', or 'high'\n    fig.add_trace(go.Violin(x=worldometer_data['Case Positivity Bin'][worldometer_data['Case Positivity Bin'] == bin],\n                            y=worldometer_data['Case Fatality'][worldometer_data['Case Positivity Bin'] == bin],\n                            name=bin,\n                            box_visible=True,\n                            meanline_visible=True))\n    \nfig.update_layout(title='Case Fatality by Case Positivity Bins', \n                  yaxis_title=\"Case Fatality\", xaxis_title=\"Case Positivity Bins\", \n                  uniformtext_minsize=8, uniformtext_mode='hide')\nfig.show()","dca3a00d":"# Draw a joint plot to diagnose the relationship between fraction of population aged 65+ and case fatality rate\nsns.jointplot(x = 'Fraction age 65+ years', y = \"Case Fatality\", data = worldometer_data, kind='reg')","96d9a0e7":"# Show the summary statistics of column case positivity\nworldometer_data[\"Case Positivity\"].describe()\n\n# Filter countries with Case Positivity less than 1% (i.e., 1 confirmed case out of 100 tests)\n# These are countries that go for rigorous testing regime\nbenchmark_countries = worldometer_data[worldometer_data[\"Case Positivity\"]<=0.01]\n#benchmark_countries.info()\n#benchmark_countries.head(20)","ae3e9056":"# Assume that the number of confirmed cases are close to the true infections rates for countries with gold standard testing regimes \n# Thus, their case fatality rates are closer to the true infection fatality rates\ninfection_fatality_rate = benchmark_countries['TotalDeaths'].sum() \/ benchmark_countries['TotalCases'].sum()\n\n# Calculate the fraction of total Covid19 deaths for the population aged 65+ among the benchmark countries\nbenchmark_death_65y_pct = sum(benchmark_countries['TotalDeaths'] * benchmark_countries['Fraction age 65+ years']) \/ sum(benchmark_countries['TotalDeaths'])\n\nprint(infection_fatality_rate)\nprint(benchmark_death_65y_pct)\n\nprint('Estimated Infection Fatality Rate for a benchmark country with %.1f%s of population older than 65 years old \\\nis %.2f%s' %(100 * benchmark_death_65y_pct,'%',100 * infection_fatality_rate,'%'))","e04cde8f":"# Estimate Infection Fatality Ratio using the estimated fraction of total Covid19 deaths for the population aged 65+\nworldometer_data['Estimated Infection Fatality Ratio'] \\\n    = ((worldometer_data['TotalDeaths'] * worldometer_data['Fraction age 65+ years']\n        \/worldometer_data['TotalDeaths']) \/ benchmark_death_65y_pct) * infection_fatality_rate\n\n# Show descriptive statistics of the columns Estimated Infection Fatality Ratio and Case Fatality\nworldometer_data['Estimated Infection Fatality Ratio'].describe()\nworldometer_data['Case Fatality'].describe()\n\n# Plot histogram of Estimated Infection Fatality Ratio and Case Fatality\npx.histogram(worldometer_data, x='Estimated Infection Fatality Ratio', barmode=\"overlay\")\npx.histogram(worldometer_data, x='Case Fatality', barmode=\"overlay\")\n\n# Overlay both histograms for comparison\nfig = go.Figure()\n\nfig.add_trace(go.Histogram(x=worldometer_data['Estimated Infection Fatality Ratio'], \n    name = 'Estimated Infection Fatality Rate'\n))\n\nfig.add_trace(go.Histogram(x=worldometer_data['Case Fatality'], \n    name = 'Case Fatality Rate'\n))\n\nfig.update_layout(barmode='overlay', \n    title = 'Estimated Infection Fatality Rate vs. Case Fatality Rate',\n    xaxis_title_text='Value', # xaxis label\n    yaxis_title_text='Count', # yaxis label\n)\n                  \nfig.update_traces(opacity=0.75)\n\nfig.show()","0a51a116":"<a id=\"subsection-three-four\"><\/a>\n## 3.4 Question 4: How do we estimate the True Fatality Rate?","1b87e01a":"Yemen has the highest case fatality rate. What is going on? The next five countries are European countries. Is the same factor driving Yemen's high fatality rate at work here?","c66c1e4e":"<a id=\"section-three\"><\/a>\n# 3. STORY","38639a64":"Case fatality rate is a function of the fraction of age 65+ years in the population.","53cff970":"<a id=\"section-four\"><\/a>\n# 4. CONCLUSION\n\nThe country-level Covid19 pandemic curves are different around the world. Which shape a curve takes depends on government interventions (i.e., the type and the extent), pandemic preparedness, and healthcare infrastructure. Taking a deep dive into the official Covid19 figures, we discover an issue with the reported confirmed cases and case fatality rates. These numbers depend crucially on the testing intensity. Then, we measure the fraction of tests that returns a positive case (case positivity) and discover that this measure correlates with the case fatality rate. The fraction of population who is aged 65+ is positively correlated with case fatality rate too. We exploit this finding to create Infections Fatality Ratio, which is plausibly closer to the true state of the severity of Covid19.","131f2dee":"The higher the case positivity bin the higher the case fatality rate.","7e0a2912":"The pandemic curves are different across countries. While some countries manage to tame the pandemic, others continue to experience outbreak. What do you think contribute to these differences?","24cbb985":"<a id=\"section-five\"><\/a>\n# 5. REFERENCES\n\nThis notebook is partially adapted from code written by [Devakumar KP](https:\/\/www.kaggle.com\/imdevskp).\n\nDatasets are from [Worldometers](https:\/\/www.worldometers.info\/) and [COVID-19 Data Repository by the Center for Systems Science and Engineering (CSSE) at Johns Hopkins University](https:\/\/github.com\/CSSEGISandData\/COVID-19). [Devakumar KP](https:\/\/www.kaggle.com\/imdevskp) has kindly extracted, cleaned, and shared these datasets on Kaggle.","fd170551":"More details Plotly's choropleth [HERE](https:\/\/plotly.com\/python\/map-configuration\/).","00768655":"### Recap: Covid19 progression over time","af87bb53":"<a id=\"subsection-three-one\"><\/a>\n## 3.1 Question 1: How has Covid19 spread around the world?","4d00454e":"Details on qcut [HERE](https:\/\/www.geeksforgeeks.org\/how-to-use-pandas-cut-and-qcut\/).   \nDetails on merge [HERE](https:\/\/towardsdatascience.com\/why-and-how-to-use-merge-with-pandas-in-python-548600f7e738#:~:text=3.-,INNER%20Merge,in%20the%20merged%20data%20%E2%80%94%20inner_merge.).   \nDetails on the difference between merge, join, and concat [HERE](https:\/\/realpython.com\/pandas-merge-join-and-concat\/).","4672e90a":"<a id=\"subsection-two-one\"><\/a>\n## 2.1 Install and Load Libraries","f09dd78d":"Case Fatality Rate is positively correlated with the fraction of 65+ in the population. Here we calibrate each country's Infections Fatality Rate following the estimated fraction of total Covid19 deaths for the population aged 65+ (i.e., we expect the Infections Fatality Rate of a country with 20% estimated total Covid19 deaths among 65+ year old population to be twice higher than another country with 10%).","67291c18":"<a id=\"subsection-three-three\"><\/a>\n## 3.3 Question 3: Are the Reported Confirmed Cases and Deaths Reliable? Case Positivity and Case Fatality Rate.","a04807df":"<a id=\"subsection-two-three\"><\/a>\n## 2.3 Import Data\nPlease add Covid 19 data from https:\/\/www.kaggle.com\/imdevskp\/corona-virus-report  \nand Worldometer snapshot data from https:\/\/www.kaggle.com\/selfishgene\/covid19-worldometer-snapshots-since-april-18\n","b0b91ed8":"<a id=\"section-one\"><\/a>\n# 1. INTRODUCTION\n\nIn this notebook, we explore how the Covid19 pandemic has evolved geographically over time around the world and whether the Covid19 pandemic curves are different across the world. Then, we take a deep delve into the reported confirmed cases and case fatality rates. What may drive the two measures? Are the case fatality rates reliable measures of true fatality rates of the Covid19? What is the problem with the case fatality rate? How can we estimate the true infection rate?","fe43f686":"<a id=\"subsection-three-two\"><\/a>\n## 3.2 Question 2: Do country-level Covid19 pandemic curves differ?","dc5f122c":"<a id=\"section-two\"><\/a>\n# 2. SETUP\n1. Settings -> Environment -> \"Always use latest environment\"\n2. Settings -> Internet -> \"On\"","e34aacff":"<a id=\"subsection-two-two\"><\/a>\n## 2.2 Define Parameters","1a9f4278":"<a id=\"subsection-two-four\"><\/a>\n## 2.4 Wrangle Data","9f51db4c":"More details on Plotly map configuration [HERE](https:\/\/plotly.com\/python\/map-configuration\/).","dc5785b1":"# TABLE OF CONTENTS\n\n* [1. INTRODUCTION](#section-one)\n* [2. SETUP](#section-two)\n    - [2.1 Install and Load Libraries](#subsection-two-one)\n    - [2.2 Define Parameters](#subsection-two-two)\n    - [2.3 Import Data](#subsection-two-three)\n    - [2.4 Wrangle Data](#subsection-two-four)\n* [3. STORY](#section-three)\n    - [3.1 Question 1: How has Covid19 spread around the world?](#subsection-three-one)\n    - [3.2 Question 2: Are country-level Covid19 pandemic curves different?](#subsection-three-two)\n    - [3.3 Question 3: Are the Reported Confirmed Cases and Deaths Reliable? Case Positivity and Case Fatality Rate?](#subsection-three-three)\n    - [3.4 Question 4: How do we estimate the True Infection Rate?](#subsection-three-four)\n    \n* [4. CONCLUSION](#section-four)\n* [5. REFERENCES](#section-five)"}}