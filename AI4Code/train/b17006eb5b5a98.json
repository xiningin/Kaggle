{"cell_type":{"04837832":"code","50f24c5d":"code","010b1a3e":"code","f4f354be":"code","ca45ce10":"markdown","bfdfd374":"markdown","272dc6ee":"markdown","be270b64":"markdown","8b6b4a35":"markdown"},"source":{"04837832":"import pandas as pd\n\ndata_train = pd.read_csv(\"..\/input\/predict-the-data-scientists-salary-in-india\/Data\/Final_Train_Dataset.csv\")\ndata_train.head()","50f24c5d":"# First, let's define the titles we want to find out.\n## \"manage\" is meant to catch both manager and management\n## \"dev\" is likewise meant to catch both dev (short) and developer (long) \n\ntitles = ['head', 'senior', 'junior',\n          'manage', 'dev', 'research', 'engineer']\n\n# Then we check for each job_desig whether it contains the title\n# as a substring\n\ntitle_dict = {}\nfor title in titles:\n    title_dict[title] = data_train['job_desig'].str.lower().str.contains(title)\n\n\ntitle_df = pd.DataFrame(title_dict)\n\n# Add one column to indicate job postings without any of those titles\n# (consider this a baseline\/\"other\"\/\"unknown\" type-of-stuff category)\n\ntitle_df['no_titles'] = (title_df.sum(axis = 1) == 0).astype(bool)\ntitle_df","010b1a3e":"# To simplify things we assume that each job\n# posting pays the midpoint of the offered salary range\nsalary = data_train['salary'].str.split(\"to\", expand = True) \\\n    .astype(float).mean(axis = 1)\nsalary","f4f354be":"# Now we merge the dataframes together ...\ntitle_df['salary'] = salary\n\n# ... and reshape it to long-form ...\ntitle_df_plot = title_df.melt('salary') \\\n    .rename(columns={'variable': 'title', 'value': 'contains'})\n\n# ... and remove rows where contains == False because we already\n# handle the no_titles category ...\ntitle_df_plot = title_df_plot[title_df_plot['contains']][['salary', 'title']]\n\n# ... and finally plot it!\nimport seaborn as sns\nbox = sns.violinplot(data = title_df_plot, x = 'salary', y = 'title')\n\n# (this just manages the size)\nsns.set(rc = {'figure.figsize': (8, 8)})\n\n# (this just manages the range)\nbox.set(xlim = (-7.5, 50))\n\n# (this just adds annotation on how many job postings per title)\ntitle_count = title_df.sum(axis = 0)[0: -1]\nfor x, count in enumerate(title_count):\n    box.annotate(str(int(count)), xy = (50, x), verticalalignment = 'center', horizontalalignment = 'right')","ca45ce10":"# Introduction\n\nThis is a super-simplified exploration! Lightweight and for fun. Enjoy.","bfdfd374":"Challenges to work on this data:\n\n- Raw text on `job_description`, `job_desig`, and `key_skills`.\n- No clear categorization on `location`.\n- `experience` and `salary` is provided in ranges instead of precise values.\n- On top of that, `experience` is not restricted into clearly defined bins of ranges.","272dc6ee":"# How does job **title** relate to how much it pays?\n\nIs it related at all? Is there a title that makes a job pays higher\/lower? From the back of our heads, we can ballpark that the \"head\" of something is paid more. A workpost that has \"senior\" embellished in front of it also feels like it should pay more.\n\nLet's find out!","be270b64":"The graph shows that jobs with **Head** title pays distinctively higher than other titles.\n\nJobs with title **Junior** pays distinctively less. (Seemingly most of them are on 0 to 3 lakh range; none in 25 to 50 lakh range). **Research** looks like it also slightly pays less as well, but not as severe.\n\nThe other titles, however, does not show very much of a difference to one another and to jobs with no specified titles. Even jobs with title **Senior** does not differ much visually here!\n\n<br>\n\n(Hint: there's a small boxplot inside each violins if you're interested in it.)","8b6b4a35":"# Closing\n\nThere you have it. My two cents in super-simplified exploratory analysis. I hope this has been useful. Have fun and happy data-sciencing!\n\nFeel free to upvote and fork this notebook all you like!"}}