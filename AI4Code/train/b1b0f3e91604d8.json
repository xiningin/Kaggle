{"cell_type":{"e010136e":"code","38353431":"code","830d419c":"code","e8e32d47":"code","4233c5b2":"code","31fbd4c1":"code","8c623ae9":"code","67b51e40":"code","3e14f47b":"code","1d359c0d":"code","77aa21df":"code","21f471aa":"code","cea35878":"code","858aaf05":"code","aacce022":"code","ec3635b6":"code","14fc77d2":"markdown","f03f0244":"markdown","2d4552d5":"markdown","30355a26":"markdown","4bc2d7ec":"markdown","4386e44c":"markdown","3e9b9954":"markdown","76bc1097":"markdown","82877300":"markdown","e3552721":"markdown","e1c27012":"markdown","7d737512":"markdown"},"source":{"e010136e":"import pandas as pd\nimport numpy as np\nimport matplotlib as plt\nimport seaborn as sns\nimport tensorflow as tf","38353431":"spoti = pd.read_csv(\"\/kaggle\/input\/dataset-of-songs-in-spotify\/genres_v2.csv\", encoding='utf-8', quotechar='\"')\nspoti.head(3)","830d419c":"spoti.shape","e8e32d47":"song_name = spoti[\"song_name\"]","4233c5b2":"print(song_name.shape)\nprint(song_name.isnull().values.any())","31fbd4c1":"song_name = song_name.values.reshape(-1,1)","8c623ae9":"song_name.shape","67b51e40":"from sklearn.impute import SimpleImputer\nimr = SimpleImputer(missing_values=np.nan, strategy='most_frequent')\nimr = imr.fit(song_name)\nimputed_data = imr.transform(song_name)\nsong_name = pd.DataFrame(imputed_data)\nsong_name = song_name.rename(columns={0:\"Song-Names\"})\nsong_name.head(3)","3e14f47b":"core = spoti[[\"genre\",\"mode\",\"duration_ms\"]]\nprint(core.dtypes)\nprint(core.head())","1d359c0d":"core.dtypes","77aa21df":"core[\"genre\"].value_counts()","21f471aa":"core = core.replace({\"genre\":{\"Underground Rap\":0, \"Dark Trap\":1, \"Hiphop\":2, \"trance\":3, \"trap\":4, \"techhouse\":5, \"dnb\":6, \"psytrance\": 7, \"techno\":8, \"hardstyle\":9, \"RnB\":10, \"Trap Metal\":11, \"Rap\":12, \"Emo\":13, \"Pop\":14}})","cea35878":"from sklearn.decomposition import NMF\nnmf = NMF(n_components = 6)\nnmf_features = nmf.fit_transform(core)","858aaf05":"from sklearn.preprocessing import normalize\nnorm_features = normalize(nmf_features)\ncurrent_music = norm_features[23,:]\nsimilarities = norm_features.dot(current_music)\nsimilarities","aacce022":"df = pd.DataFrame(norm_features)\nx = df.join(song_name)\ndf = pd.pivot_table(x, x[[0,1,2,3,4,5]],[\"Song-Names\"])#for indexing song_name to our df\ndef current_music(value):\n    print(\"Top 5 recommendations for given music are:\")\n    value = df.loc[value]\n    similarities = df.dot(value)\n    print(format(similarities.nlargest()))","ec3635b6":"current_music(\"Missed Calls - Remix\")","14fc77d2":"#### CREATING song_name ","f03f0244":"#### IMPORTING NECESSARY LIBRARIES","2d4552d5":"#### CREATING CORE\nLet's create a DataFrame that contains genre, mode, and duration_ms info of the given song names. <br>\nLet's name it as core.","30355a26":"#### REPLACING NA VALUES","4bc2d7ec":"Hmm, looks like dtype of genre is object, and it contains string values. Let's encode them and make convinient for M.L. algorithm. ","4386e44c":"#### LAST TOUCHES AND CREATING current_music() function","3e9b9954":"#### IMPORTING OUR DATASET","76bc1097":"#### PREPROCESSING","82877300":"# BUILDING RECOMMENDATION SYSTEM FOR GIVEN SPOTIFY SONGS","e3552721":"In this repository, I built recommendation system for given 42305 Spotify songs based on their genre, mode, and duration. <br>\nI used `sklearn.decomposition`' s NMF to did that, <br>\nand I preprocessed the data by `normalize` method of `sklearn.preprocessing` <br>\nI also replaced Na values with `sklearn.impute`s `SimpleImputer` <br>\nThe source of data is: https:\/\/www.kaggle.com\/mrmorj\/dataset-of-songs-in-spotify","e1c27012":"`normalize()` samples individually to unit norm. Each sample (i.e. each row of the data matrix) with at least one non zero component is rescaled independently of other samples so that its norm (l1, l2 or inf) equals one. This transformer is able to work both with dense numpy arrays and scipy.","7d737512":"#### APPLYING NMF\nNon-negative matrix factorization (NMF), also non-negative matrix approximation is a group of algorithms in multivariate analysis and linear algebra where a matrix V is factorized into (usually) two matrices W and H, with the property that all three matrices have no negative elements. This non-negativity makes the resulting matrices easier to inspect."}}