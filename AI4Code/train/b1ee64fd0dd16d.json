{"cell_type":{"aed90b01":"code","27c086f4":"code","cde0cf07":"code","467d2b6b":"code","12aba8db":"code","ebc460ed":"code","db3b05a7":"code","da17b6ed":"code","25802751":"code","f9d14381":"code","1d9a6172":"markdown"},"source":{"aed90b01":"%%writefile submission.py\nimport pickle\nimport bz2\nimport base64\nimport random\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport math\nimport time\nfrom copy import deepcopy\nfrom kaggle_environments.envs.hungry_geese.hungry_geese import Action, translate\nfrom kaggle_environments.helpers import histogram","27c086f4":"%%writefile -a submission.py\nPARAM = b'XXXXXXXXXX'","cde0cf07":"%%writefile -a submission.py\nclass MCTS():\n    def __init__(self, game, nn_agent, eps=1e-8, cpuct=1.0):\n        self.game = game\n        self.nn_agent = nn_agent\n        self.eps = eps\n        self.cpuct = cpuct\n        self.gamma = 0.8\n\n        self.Qsa = {}  # stores Q values for s,a (as defined in the paper)\n        self.Nsa = {}  # stores #times edge s,a was visited\n        self.Ns = {}  # stores #times board s was visited\n        self.Ps = {}  # stores initial policy (returned by neural net)\n        self.Vs = {}  # stores value for board s (returned by neural net)\n        self.Ms = {}  # stores game.getValidMoves for board s\n\n        self.last_obs = None\n        self.rewards = [0] * 4\n\n    def getActionProb(self, obs, timelimit=1.0):\n        start_time = time.time()\n        while time.time() - start_time < timelimit:\n            self.search(obs, self.last_obs, self.rewards[:])\n            \n        for i in range(4):\n            if len(obs.geese[i]) > 0:\n                self.rewards[i] += 100\n            elif self.last_obs is not None:\n                self.rewards[i] += len(self.last_obs.geese[i])\n\n        s = self.game.stringRepresentation(obs)\n        i = obs.index\n        counts = [\n            self.Nsa[(s, i, a)] if (s, i, a) in self.Nsa else 0\n            for a in range(self.game.getActionSize())\n        ]\n        print(counts)\n\n        valids = np.array(self.game.getValidMoves(obs, self.last_obs, i))\n        valid_counts = counts * valids\n        sum_valid_counts = np.sum(valid_counts)\n        if sum_valid_counts > 0:\n            prob = valid_counts \/ sum_valid_counts\n        else:\n            valids = np.array(self.game.getNonOppositeMoves(obs, self.last_obs, i))\n            valid_counts = counts * valids\n            sum_valid_counts = np.sum(valid_counts)\n            if sum_valid_counts > 0:\n                prob = valid_counts \/ sum_valid_counts\n            else:\n                prob = [1.] * valids\n                prob \/= np.sum(prob)\n\n        self.last_obs = obs\n        return prob\n    \n    def get_values(self, obs, rewards):\n        '''\n        rank 1:    1\n        rank 1.5:  0.666\n        rank 2:   -1\n        rank 2.5: -1\n        rank 3:   -1\n        rank 3.5: -1\n        rank 4:   -1\n        '''\n        ranks = [1] * 4\n        for i in range(4):\n            for j in (j for j in range(4) if j != i):\n                if rewards[i] < rewards[j]:\n                    ranks[i] += 1\n                elif rewards[i] == rewards[j]:\n                    ranks[i] += 0.5\n        values = [(5 - 2 * rank) \/ 3 if rank < 2 else -1 for rank in ranks]\n        return values\n\n    def search(self, obs, last_obs, rewards):\n        s = self.game.stringRepresentation(obs)\n\n        for i in range(4):\n            if len(obs.geese[i]) > 0:\n                rewards[i] += 100\n            elif last_obs is not None:\n                rewards[i] += len(last_obs.geese[i])\n\n        if s not in self.Ns:\n            values = self.get_values(obs, rewards)\n#             print(values)\n\n            for i in range(4):\n                if len(obs.geese[i]) == 0 or obs.step == 199:\n                    continue\n\n                # leaf node\n#                 if i == obs.index:\n                self.Ps[(s, i)], values[i] = self.nn_agent.predict(obs, last_obs, i)\n#                     print(values[i])\n#                 else:\n#                     self.Ps[(s, i)] = np.array([0.25, 0.25, 0.25, 0.25])\n\n                valids = self.game.getValidMoves(obs, last_obs, i)\n                self.Ps[(s, i)] = self.Ps[(s, i)] * valids  # masking invalid moves\n                sum_Ps_s = np.sum(self.Ps[(s, i)])\n                if sum_Ps_s > 0:\n                    self.Ps[(s, i)] \/= sum_Ps_s  # renormalize\n\n                self.Vs[(s, i)] = values[i]\n                self.Ms[(s, i)] = valids\n                self.Ns[s] = 0\n\n            return values\n\n        best_acts = [None] * 4\n        for i in range(4):\n            if len(obs.geese[i]) == 0:\n                continue\n\n            # pick the action with the highest upper confidence bound\n            valids = self.Ms[(s, i)]\n            u = np.array([-float('inf')] * 4)\n            for a in range(self.game.getActionSize()):\n                if valids[a]:\n                    if (s, i, a) in self.Qsa:\n                        u[a] = self.Qsa[(s, i, a)] + self.cpuct * self.Ps[(s, i)][a] * math.sqrt(self.Ns[s]) \/ (1 + self.Nsa[(s, i, a)])\n                    else:\n                        u[a] = self.Vs[(s, i)] + self.cpuct * self.Ps[(s, i)][a] * math.sqrt(self.Ns[s] + self.eps)\n\n            # random choice among the best actions\n            best_acts[i] = self.game.actions[np.random.choice(np.argwhere(u == u.max()).flatten())]\n\n        next_obs = self.game.getNextState(obs, last_obs, best_acts)\n        values = self.search(next_obs, obs, rewards)\n\n        for i in range(4):\n            if len(obs.geese[i]) == 0:\n                continue\n\n            a = self.game.actions.index(best_acts[i])\n            v = values[i]\n            if (s, i, a) in self.Qsa:\n                self.Qsa[(s, i, a)] = (self.Nsa[(s, i, a)] * self.Qsa[(s, i, a)] + v) \/ (self.Nsa[(s, i, a)] + 1)\n                self.Nsa[(s, i, a)] += 1\n            else:\n                self.Qsa[(s, i, a)] = v\n                self.Nsa[(s, i, a)] = 1\n\n        self.Ns[s] += 1\n        \n        values = [value * self.gamma for value in values]\n        return values","467d2b6b":"%%writefile -a submission.py\nclass HungryGeese(object):\n    def __init__(self,\n                 rows=7,\n                 columns=11,\n                 actions=[Action.NORTH, Action.SOUTH, Action.WEST, Action.EAST],\n                 hunger_rate=40):\n        self.rows = rows\n        self.columns = columns\n        self.actions = actions\n        self.hunger_rate = hunger_rate\n\n    def getActionSize(self):\n        return len(self.actions)\n\n    def getNextState(self, obs, last_obs, directions):\n        next_obs = deepcopy(obs)\n        next_obs.step += 1\n        geese = next_obs.geese\n        food = next_obs.food\n        \n        for i in range(4):\n            goose = geese[i]\n            \n            if len(goose) == 0: \n                continue\n            \n            head = translate(goose[0], directions[i], self.columns, self.rows)\n\n            # Check action direction\n            if last_obs is not None and head == last_obs.geese[i][0]:\n                geese[i] = []\n                continue\n\n            # Consume food or drop a tail piece.\n            if head in food:\n                food.remove(head)\n            else:\n                goose.pop()\n            \n            # Add New Head to the Goose.\n            goose.insert(0, head)\n\n            # If hunger strikes remove from the tail.\n            if next_obs.step % self.hunger_rate == 0:\n                if len(goose) > 0:\n                    goose.pop()\n\n        goose_positions = histogram(\n            position\n            for goose in geese\n            for position in goose\n        )\n\n        # Check for collisions.\n        for i in range(4):\n            if len(geese[i]) > 0:\n                head = geese[i][0]\n                if goose_positions[head] > 1:\n                    geese[i] = []\n        \n        return next_obs\n\n    def getValidMoves(self, obs, last_obs, index):   \n        geese = obs.geese\n        pos = geese[index][0]\n        obstacles = {position for goose in geese for position in goose[:-1]}\n        if last_obs is not None: obstacles.add(last_obs.geese[index][0])\n        \n        valid_moves = [\n            translate(pos, action, self.columns, self.rows) not in obstacles\n            for action in self.actions\n        ]\n\n        return valid_moves\n    \n    def getNonOppositeMoves(self, obs, last_obs, index):   \n        geese = obs.geese\n        pos = geese[index][0]\n        opposite = None\n        if last_obs is not None: opposite = last_obs.geese[index][0]\n\n        valid_moves = [\n            translate(pos, action, self.columns, self.rows) != opposite\n            for action in self.actions\n        ]\n\n        return valid_moves\n\n    def stringRepresentation(self, obs):      \n        return str(obs.geese + obs.food)","12aba8db":"%%writefile -a submission.py\n# Neural Network for Hungry Geese\nclass TorusConv2d(nn.Module):\n    def __init__(self, input_dim, output_dim, kernel_size, bn):\n        super().__init__()\n        self.edge_size = (kernel_size[0] \/\/ 2, kernel_size[1] \/\/ 2)\n        self.conv = nn.Conv2d(input_dim, output_dim, kernel_size=kernel_size, padding=self.edge_size, padding_mode='circular')\n        self.bn = nn.BatchNorm2d(output_dim) if bn else None\n\n    def forward(self, x):\n        h = self.conv(x)\n        h = self.bn(h) if self.bn is not None else h\n        return h\n\n\nclass GeeseNet(nn.Module):\n    def __init__(self):\n        super().__init__()\n        layers, filters = 12, 32\n        self.conv0 = TorusConv2d(17, filters, (3, 3), True)\n        self.blocks = nn.ModuleList([TorusConv2d(filters, filters, (3, 3), True) for _ in range(layers)])\n        self.head_p = nn.Linear(filters, 4, bias=False)\n        self.head_v = nn.Linear(filters * 2, 1, bias=False)\n\n    def forward(self, x):\n        h = F.relu_(self.conv0(x))\n        for block in self.blocks:\n            h = F.relu_(h + block(h))\n        h_head = (h * x[:,:1]).view(h.size(0), h.size(1), -1).sum(-1)\n        h_avg = h.view(h.size(0), h.size(1), -1).mean(-1)\n        p = torch.softmax(self.head_p(h_head), 1)\n        v = torch.tanh(self.head_v(torch.cat([h_head, h_avg], 1)))\n\n        return p, v\n\n\nclass NNAgent():\n    def __init__(self, state_dict):\n        self.model = GeeseNet()\n        self.model.load_state_dict(state_dict)\n        self.model.eval()\n        \n    def predict(self, obs, last_obs, index):\n        x = self._make_input(obs, last_obs, index)\n        with torch.no_grad():\n            xt = torch.from_numpy(x).unsqueeze(0)\n            p, v = self.model(xt)\n            \n        return p.squeeze(0).detach().numpy(), v.item()\n        \n    # Input for Neural Network\n    def _make_input(self, obs, last_obs, index):\n        b = np.zeros((17, 7 * 11), dtype=np.float32)\n        \n        for p, pos_list in enumerate(obs.geese):\n            # head position\n            for pos in pos_list[:1]:\n                b[0 + (p - index) % 4, pos] = 1\n            # tip position\n            for pos in pos_list[-1:]:\n                b[4 + (p - index) % 4, pos] = 1\n            # whole position\n            for pos in pos_list:\n                b[8 + (p - index) % 4, pos] = 1\n\n        # previous head position\n        if last_obs is not None:\n            for p, pos_list in enumerate(last_obs.geese):\n                for pos in pos_list[:1]:\n                    b[12 + (p - index) % 4, pos] = 1\n\n        # food\n        for pos in obs.food:\n            b[16, pos] = 1\n\n        return b.reshape(-1, 7, 11)","ebc460ed":"%%writefile -a submission.py\ngame = HungryGeese()\nstate_dict = pickle.loads(bz2.decompress(base64.b64decode(PARAM)))\nagent = NNAgent(state_dict)\nmcts = MCTS(game, agent)\n\ndef alphageese_agent(obs, config):\n#     print(obs)\n    probs = mcts.getActionProb(obs, timelimit=config.actTimeout*1.)    \n#     probs = mcts.getActionProb(obs, timelimit=0.05)\n\n    action = game.actions[np.random.choice(np.argwhere(probs == probs.max()).flatten())]\n    return action.name","db3b05a7":"import torch\nimport base64\nimport bz2\nimport pickle\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nweights = torch.load('..\/input\/hungry-geese-models\/latest.pth', map_location=device)\nPARAM = base64.b64encode(bz2.compress(pickle.dumps(weights)))","da17b6ed":"# Read in the submission file\nwith open('submission.py',) as file:\n    filedata = file.read()\n\n# Replace the target string\nfiledata = filedata.replace('XXXXXXXXXX', PARAM.decode(\"utf-8\") )\n\n# Write the file out again\nwith open('submission.py','w') as file:\n    file.write(filedata)","25802751":"# %%writefile crazy-goose.py\n# # from https:\/\/www.kaggle.com\/gabrielmilan\/crazy-goose\n# # Base code for this from\n# # https:\/\/www.kaggle.com\/ilialar\/risk-averse-greedy-goose\n\n# import numpy as np\n# from kaggle_environments.envs.hungry_geese.hungry_geese import Observation, Configuration, Action, row_col\n\n# # Moves constants\n# SOUTH = 1\n# NORTH = 2\n# EAST  = 3\n# WEST  = 4\n# REVERSE_MOVE = {\n#     None : None,\n#     SOUTH: NORTH,\n#     NORTH: SOUTH,\n#     EAST : WEST,\n#     WEST : EAST,\n# }\n# CIRCLE_MOVE = {\n#     None : None,\n#     SOUTH: WEST,\n#     NORTH: EAST,\n#     EAST : SOUTH,\n#     WEST : NORTH\n# }\n\n# # Board constants\n# MY_HEAD             =  2\n# FOOD_CELL           =  1\n# EMPTY               =  0\n# HEAD_POSSIBLE_CELL  = -1\n# BODY_CELL           = -2\n\n# # Store last move\n# last_move = None\n# last_eaten = 0\n# last_size = 1\n# step = 0\n\n# # Returns a list of possible destinations in order to reach `dest_cell`\n# def move_towards (head_cell, neck_cell, dest_cell, configuration):\n#     print (\"--- Computing food movements...\")\n#     destinations = []\n#     x_head, y_head = row_col(head_cell, configuration.columns)\n#     x_neck, y_neck = row_col(neck_cell, configuration.columns)\n#     x_dest, y_dest = row_col(dest_cell, configuration.columns)\n#     print (\"-> Head at ({}, {})\".format(x_head, y_head))\n#     print (\"-> Neck at ({}, {})\".format(x_neck, y_neck))\n#     print (\"-> Dest at ({}, {})\".format(x_dest, y_dest))\n#     dx = x_head - x_dest\n#     dy = y_head - y_dest\n#     if (dx >= 4):\n#         dx = 7 - dx\n#     elif (dx <= -4):\n#         dx += 7\n#     if (dy >= 6):\n#         dy = 11 - dy\n#     elif (dy <= -6):\n#         dy += 11\n#     print (\"dx={}, dy={}\".format(dx, dy))\n#     if (dx > 0):\n#         x_move = (x_head - 1 + 7) % 7\n#         y_move = y_head\n#         print (\"Move ({}, {}), Neck ({}, {})\".format(x_move, y_move, x_neck, y_neck))\n#         if not ((x_move == x_neck) and (y_move == y_neck)):\n#             destinations.append((x_move, y_move, NORTH))\n#     elif (dx < 0):\n#         x_move = (x_head + 1 + 7) % 7\n#         y_move = y_head\n#         print (\"Move ({}, {}), Neck ({}, {})\".format(x_move, y_move, x_neck, y_neck))\n#         if not ((x_move == x_neck) and (y_move == y_neck)):\n#             destinations.append((x_move, y_move, SOUTH))\n#     if (dy > 0):\n#         x_move = x_head\n#         y_move = (y_head - 1 + 11) % 11\n#         print (\"Move ({}, {}), Neck ({}, {})\".format(x_move, y_move, x_neck, y_neck))\n#         if not ((x_move == x_neck) and (y_move == y_neck)):\n#             destinations.append((x_move, y_move, WEST))\n#     elif (dy < 0):\n#         x_move = x_head\n#         y_move = (y_head + 1 + 11) % 11\n#         print (\"Move ({}, {}), Neck ({}, {})\".format(x_move, y_move, x_neck, y_neck))\n#         if not ((x_move == x_neck) and (y_move == y_neck)):\n#             destinations.append((x_move, y_move, EAST))\n#     return destinations\n\n# def get_all_movements(goose_head, configuration):\n#     x_head, y_head = row_col(goose_head, configuration.columns)\n#     movements = []\n#     movements.append(((x_head - 1 + 7) % 7, y_head, NORTH))\n#     movements.append(((x_head + 1 + 7) % 7, y_head, SOUTH))\n#     movements.append((x_head, (y_head - 1 + 11) % 11, WEST))\n#     movements.append((x_head, (y_head + 1 + 11) % 11, EAST))\n#     return movements\n    \n# def get_nearest_cells(x, y):\n#     # Returns adjacent cells from the current one\n#     result = []\n#     for i in (-1,+1):\n#         result.append(((x+i+7)%7, y))\n#         result.append((x, (y+i+11)%11))\n#     return result\n\n# # Compute L1 distance between cells\n# def cell_distance (a, b, configuration):\n#     xa, ya = row_col(a, configuration.columns)\n#     xb, yb = row_col(b, configuration.columns)\n#     dx = abs(xa - xb)\n#     dy = abs(ya - yb)\n#     if (dx >= 4):\n#         dx = 7 - dx\n#     if (dy >= 6):\n#         dy = 11 - dy\n#     return dx + dy\n\n# # Tells if that particular cell forbids movement on the next step\n# def is_closed (movement, board):\n#     return all([board[x_adj, y_adj] for (x_adj, y_adj) in get_nearest_cells(movement[0], movement[1])])\n\n# def is_safe (movement, board):\n#     return board[movement[0], movement[1]] >= 0\n\n# def is_half_safe (movement, board):\n#     return board[movement[0], movement[1]] >= -1\n\n# def agent (obs_dict, config_dict):\n#     global last_move\n#     global last_eaten\n#     global last_size\n#     global step\n#     print (\"==============================================\")\n#     observation = Observation(obs_dict)\n#     configuration = Configuration(config_dict)\n#     player_index = observation.index\n#     player_goose = observation.geese[player_index]\n#     player_head = player_goose[0]\n#     player_row, player_column = row_col(player_head, configuration.columns)\n\n#     if (len(player_goose) > last_size):\n#         last_size = len(player_goose)\n#         last_eaten = step\n#     step += 1\n    \n#     moves = {\n#         1: 'SOUTH',\n#         2: 'NORTH',\n#         3: 'EAST',\n#         4: 'WEST'\n#     }\n\n#     board = np.zeros((7, 11))\n    \n#     # Adding food to board\n#     for food in observation.food:\n#         x, y = row_col(food, configuration.columns)\n#         print (\"Food cell on ({}, {})\".format(x, y))\n#         board[x, y] = FOOD_CELL\n        \n#     # Adding geese to the board\n#     for i in range(4):\n#         goose = observation.geese[i]\n#         # Skip if goose is dead\n#         if len(goose) == 0:\n#             continue\n#         # If it's an opponent\n#         if i != player_index:\n#             x, y = row_col(goose[0], configuration.columns)\n#             # Add possible head movements for it\n#             for px, py in get_nearest_cells(x, y):\n#                 print (\"Head possible cell on ({}, {})\".format(px, py))\n#                 # If one of these head movements may lead the goose\n#                 # to eat, add tail as BODY_CELL, because it won't move.\n#                 if board[px, py] == FOOD_CELL:\n#                     x_tail, y_tail = row_col(goose[-1], configuration.columns)\n#                     print (\"Adding tail on ({}, {}) as the goose may eat\".format(x_tail, y_tail))\n#                     board[x_tail, y_tail] = BODY_CELL\n#                 board[px, py] = HEAD_POSSIBLE_CELL\n#         # Adds goose body without tail (tail is previously added only if goose may eat)\n#         for n in goose[:-1]:\n#             x, y = row_col(n, configuration.columns)\n#             print (\"Body cell on ({}, {})\".format(x, y))\n#             board[x, y] = BODY_CELL\n    \n#     # Adding my head to the board\n#     x, y = row_col(player_head, configuration.columns)\n#     print (\"My head is at ({}, {})\".format(x, y))\n#     board[x, y] = MY_HEAD\n    \n#     # Debug board\n#     print (board)\n    \n#     # Iterate over food and geese in order to compute distances for each one\n#     food_race = {}\n#     for food in observation.food:\n#         food_race[food] = {}\n#         for i in range(4):\n#             goose = observation.geese[i]\n#             if len(goose) == 0:\n#                 continue\n#             food_race[food][i] = cell_distance(goose[0], food, configuration)\n    \n#     # The best food is the least coveted\n#     best_food = None\n#     best_distance = float('inf')\n#     best_closest_geese = float('inf')\n#     for food in food_race:\n#         print (\"-> Food on {}\".format(row_col(food, configuration.columns)))\n#         my_distance = food_race[food][player_index]\n#         print (\" - My distance is {}\".format(my_distance))\n#         closest_geese = 0\n#         for goose_id in food_race[food]:\n#             if goose_id == player_index:\n#                 continue\n#             if food_race[food][goose_id] <= my_distance:\n#                 closest_geese += 1\n#         print (\" - There are {} closest geese\".format(closest_geese))\n#         if (closest_geese < best_closest_geese):\n#             best_food = food\n#             best_distance = my_distance\n#             best_closest_geese = closest_geese\n#             print (\"  * This food is better\")\n#         elif (closest_geese == best_closest_geese) and (my_distance <= best_distance):\n#             best_food = food\n#             best_distance = my_distance\n#             best_closest_geese = closest_geese\n#             print (\"  * This food is better\")\n            \n#     # Now that the best food has been found, check if the movement towards it is safe.\n#     # Computes every available move and then check for move priorities.\n#     if len(player_goose) > 1:\n#         food_movements = move_towards(player_head, player_goose[1], best_food, configuration)\n#     else:\n#         food_movements = move_towards(player_head, player_head, best_food, configuration)\n#     all_movements = get_all_movements(player_head, configuration)\n#     # Excluding last movement reverse\n#     food_movements = [move for move in food_movements if move[2] != REVERSE_MOVE[last_move]]\n#     all_movements  = [move for move in all_movements if move[2] != REVERSE_MOVE[last_move]]\n#     print (\"-> Available food moves: {}\".format(food_movements))\n#     print (\"-> All moves: {}\".format(all_movements))\n    \n#     # Trying to reach goal size of 4\n#     if (len(player_goose) < 4):\n        \n#         # 1. Food movements that are safe and not closed\n#         for food_movement in food_movements:\n#             print (\"Food movement {}\".format(food_movement))\n#             if is_safe (food_movement, board) and not is_closed(food_movement, board):\n#                 print (\"It's safe! Let's move {}!\".format(moves[food_movement[2]]))\n#                 last_move = food_movement[2]\n#                 return moves[food_movement[2]] # Move here\n\n#         # 2. Any movement safe and not closed\n#         for movement in all_movements:\n#             print (\"Movement {}\".format(movement))\n#             if is_safe (movement, board) and not is_closed(movement, board):\n#                 print (\"It's safe! Let's move {}!\".format(moves[movement[2]]))\n#                 last_move = movement[2]\n#                 return moves[movement[2]] # Move here\n\n#         # 3. Food movements half safe and not closed\n#         for food_movement in food_movements:\n#             if is_half_safe (food_movement, board) and not is_closed(food_movement, board):\n#                 print (\"Food movement {} is half safe, I'm going {}!\".format(food_movement, moves[food_movement[2]]))\n#                 last_move = food_movement[2]\n#                 return moves[food_movement[2]] # Move here\n\n#         # 4. Any movement half safe and not closed\n#         for movement in all_movements:\n#             if is_half_safe (movement, board) and not is_closed(movement, board):\n#                 print (\"Movement {} is half safe, I'm going {}!\".format(movement, moves[movement[2]]))\n#                 last_move = movement[2]\n#                 return moves[movement[2]] # Move here\n\n#         # 5. Food movements that are safe\n#         for food_movement in food_movements:\n#             print (\"Food movement {}\".format(food_movement))\n#             if is_safe (food_movement, board):\n#                 print (\"It's safe! Let's move {}!\".format(moves[food_movement[2]]))\n#                 last_move = food_movement[2]\n#                 return moves[food_movement[2]] # Move here\n\n#         # 6. Any movement safe\n#         for movement in all_movements:\n#             print (\"Movement {}\".format(movement))\n#             if is_safe (movement, board):\n#                 print (\"It's safe! Let's move {}!\".format(moves[movement[2]]))\n#                 last_move = movement[2]\n#                 return moves[movement[2]] # Move here\n\n#         # 7. Food movements half safe\n#         for food_movement in food_movements:\n#             if is_half_safe (food_movement, board):\n#                 print (\"Food movement {} is half safe, I'm going {}!\".format(food_movement, moves[food_movement[2]]))\n#                 last_move = food_movement[2]\n#                 return moves[food_movement[2]] # Move here\n\n#         # 8. Any movement half safe\n#         for movement in all_movements:\n#             if is_half_safe (movement, board):\n#                 print (\"Movement {} is half safe, I'm going {}!\".format(movement, moves[movement[2]]))\n#                 last_move = movement[2]\n#                 return moves[movement[2]] # Move here\n    \n#     # Just trying to walk in circles\n#     else:\n        \n#         # Delete food moves\n#         food_coordinates = []\n#         for food in food_race:\n#             x_food, y_food = row_col(food, configuration.columns)\n#             food_coordinates.append((x_food, y_food))\n#         available_moves = []\n#         for move in all_movements:\n#             for (x_food, y_food) in food_coordinates:\n#                 if (move[0] != x_food) or (move[1] != y_food):\n#                     available_moves.append(move)\n        \n#         # 1. Run in circles if you can\n#         circle_move = CIRCLE_MOVE[last_move]\n#         for move in available_moves:\n#             if (move[2] == circle_move) and (is_safe(move, board)) and not (is_closed(move, board)):\n#                 last_move = move[2]\n#                 return moves[move[2]]\n        \n#         # 2. Any movement safe and not closed\n#         for movement in all_movements:\n#             print (\"Movement {}\".format(movement))\n#             if is_safe (movement, board) and not is_closed(movement, board):\n#                 print (\"It's safe! Let's move {}!\".format(moves[movement[2]]))\n#                 last_move = movement[2]\n#                 return moves[movement[2]] # Move here\n\n#         # 3. Any movement half safe and not closed\n#         for movement in all_movements:\n#             if is_half_safe (movement, board) and not is_closed(movement, board):\n#                 print (\"Movement {} is half safe, I'm going {}!\".format(movement, moves[movement[2]]))\n#                 last_move = movement[2]\n#                 return moves[movement[2]] # Move here\n\n#         # 4. Any movement safe\n#         for movement in all_movements:\n#             print (\"Movement {}\".format(movement))\n#             if is_safe (movement, board):\n#                 print (\"It's safe! Let's move {}!\".format(moves[movement[2]]))\n#                 last_move = movement[2]\n#                 return moves[movement[2]] # Move here\n\n#         # 5. Any movement half safe\n#         for movement in all_movements:\n#             if is_half_safe (movement, board):\n#                 print (\"Movement {} is half safe, I'm going {}!\".format(movement, moves[movement[2]]))\n#                 last_move = movement[2]\n#                 return moves[movement[2]] # Move here\n\n#     # Finally, if all moves are unsafe, randomly pick one\n#     rand_pick = np.random.randint(4) + 1\n#     last_move = rand_pick\n#     print (\"Yeah whatever, I'm going {}\".format(moves[rand_pick]))\n#     return moves[rand_pick]","f9d14381":"# from kaggle_environments import make\n# env = make(\"hungry_geese\", debug=True)\n# env.reset()\n# # env.run(['submission.py', 'crazy-goose.py', 'crazy-goose.py', 'crazy-goose.py'])\n# env.run(['submission.py'] * 4)\n# env.render(mode=\"ipython\", width=700, height=600)","1d9a6172":"### Reference\n- [Smart Geese Trained by Reinforcement Learning](https:\/\/www.kaggle.com\/yuricat\/smart-geese-trained-by-reinforcement-learning)\n- [Alpha Zero General](https:\/\/github.com\/suragnair\/alpha-zero-general)"}}