{"cell_type":{"e3d720f2":"code","21c9937e":"code","48ff49bb":"code","bc2fdcf7":"code","ef8d06ec":"code","3f3ab76a":"code","4dc2b496":"markdown"},"source":{"e3d720f2":"import pandas as pd\nimport itertools","21c9937e":"class ExtractCities:\n    def __init__(\n        self, letters=[\"\ud83c\udf85\", \"\ud83e\udd36\", \"\ud83e\udd8c\", \"\ud83e\udddd\", \"\ud83c\udf84\", \"\ud83c\udf81\", \"\ud83c\udf80\"], wildcard=\"\ud83c\udf1f\", verbose=True\n    ):\n        self.letters = letters\n        self.wildcard = wildcard\n        self.verbose = verbose\n        self.N = len(letters)\n        self.perms = itertools.permutations(letters, self.N)\n        self.perms = [\"\".join(list(p)) for p in self.perms]\n\n    def __call__(self, df_path):\n        df = pd.read_csv(df_path)\n        strings = [x for x in df[\"schedule\"].tolist()]\n        strings_perm_fmt = [self.extract_permutations(s) for s in strings]\n        all_cities = [item for sublist in strings_perm_fmt for item in sublist]\n\n        taken = [s for s in all_cities if s in self.perms]  # Used permutations\n        candidates = [p for p in self.perms if p not in taken]  # Unused permutations\n        wcs = [s for s in all_cities if self.wildcard in s]  # Cities with wildcards\n\n        mappings = {}\n        for i, s in enumerate(wcs):\n            matched = False\n            for c in candidates:\n                n_wildcards = s.count(self.wildcard)\n                if self.similarity(s, c) == self.N - n_wildcards:\n                    mappings[s] = c\n                    matched = True\n                    if self.verbose:\n                        print(i, \"Wildcard string\", s, \"matches\", c, \"from cands\")\n\n            for p in self.perms:\n                if self.similarity(s, p) == self.N - n_wildcards and not matched:\n                    mappings[s] = p\n                    if self.verbose:\n                        print(i, \"Wildcard string\", s, \"matches\", p, \"from perms\")\n                        \n        strings_final = []\n        for string in strings_perm_fmt:\n            strings_final.append([mappings[x] if self.wildcard in x else x for x in string])\n            \n        return strings_final\n\n    def similarity(self, string1, string2):\n        score = 0\n        for a, b in zip(string1, string2):\n            if a == b:\n                score += 1\n        return score\n\n    def extract_permutations(self, string):\n        permutations = []\n        for k in range(len(string) - self.N + 1):\n            s = string[k : k + self.N]\n\n            n_wildcards = s.count(self.wildcard)\n\n            if n_wildcards == 0:\n                is_perm = len(set(s)) == self.N\n            else:\n                is_perm = len(set(s)) == self.N - n_wildcards + 1\n\n            if is_perm and s not in permutations:\n                permutations.append(s)\n\n        return permutations","48ff49bb":"ec = ExtractCities()\nout = ec(\"\/kaggle\/input\/santa-2021-baseline-and-optimization-ideas\/submission.csv\")","bc2fdcf7":"len(out)","ef8d06ec":"# Each string has now been broken into 7-character strings\nout[0][:10]","3f3ab76a":"# Check if any wildcards still remain\nfor string in out:\n    for s in string:\n        if \"\ud83c\udf1f\" in s:\n            print(s)","4dc2b496":"# Going from superpermutation \u27a1\ufe0f permutation format\nWhen working on optimisation problems, you may want to use an existing solution (e.g. a `submission.csv`) as an initial starting point for another round of optimisation.\n\nThe class below does the following:\n* Split the string back into the 7 emoji \"cities\"\n* If a city has a wildcard, try and figure out what the city should be\n\nNote that the code is a bit rough and can certainly be optimised. There may also be some edge cases that will cause the wildcard lookup to fail. Any feedback is appreciated!"}}