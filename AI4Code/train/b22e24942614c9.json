{"cell_type":{"a245f9cd":"code","70f29a02":"code","4fca64b7":"code","13e01816":"code","deb9e0a2":"code","99f7de17":"code","cbbea312":"code","2465326f":"code","0261238b":"code","01c2f343":"code","5b33e44c":"code","a6626b7f":"code","6adc65e2":"code","8188bc6f":"code","8f0ab677":"code","51ae241f":"code","a40f11d8":"code","efd934d6":"code","9ca5949f":"code","fd238a56":"code","55a7a783":"code","a6661ee0":"code","346b332a":"code","ebb3e499":"code","1b6d77da":"code","301007c6":"code","c3524204":"markdown","6dbf9171":"markdown","e60d33d1":"markdown","8ab8830d":"markdown","094bf2dd":"markdown","fa089df9":"markdown","48327c6f":"markdown"},"source":{"a245f9cd":"!pip3 install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio==0.9.0 -f https:\/\/download.pytorch.org\/whl\/torch_stable.html\n!pip install pycocotools \n!wget https:\/\/raw.githubusercontent.com\/pytorch\/vision\/main\/references\/detection\/engine.py\n!wget https:\/\/raw.githubusercontent.com\/pytorch\/vision\/main\/references\/detection\/utils.py\n!wget https:\/\/raw.githubusercontent.com\/pytorch\/vision\/main\/references\/detection\/transforms.py\n!wget https:\/\/raw.githubusercontent.com\/pytorch\/vision\/main\/references\/detection\/coco_utils.py\n!wget https:\/\/raw.githubusercontent.com\/pytorch\/vision\/main\/references\/detection\/coco_eval.py    ","70f29a02":"import torch\nprint(torch.__version__)\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport torch.nn as nn\nimport albumentations as A\nfrom albumentations.pytorch import ToTensorV2 \nimport torch\nimport torchvision\nfrom torchvision import datasets,transforms\nfrom tqdm import tqdm\nimport cv2\nfrom torch.utils.data import Dataset,DataLoader\nimport torch.optim as optim\nfrom PIL import Image\nimport os\nimport torch.nn.functional as F\nimport ast","4fca64b7":"# configure the hyperparameters here\nLR = 1e-4\nSPLIT = 0.2\nDEVICE = \"cuda\" if torch.cuda.is_available() else \"cpu\"\nBATCH_SIZE = 4\nEPOCHS = 2\nDATAPATH = '..\/input\/global-wheat-detection'","13e01816":"!ls '..\/input\/global-wheat-detection'","deb9e0a2":"df = pd.read_csv(DATAPATH + '\/train.csv')\ndf.bbox = df.bbox.apply(ast.literal_eval)","99f7de17":"df = df.groupby(\"image_id\")[\"bbox\"].apply(list).reset_index(name=\"bboxes\")","cbbea312":"def train_test_split(dataFrame,split):\n    len_tot = len(dataFrame)\n    val_len = int(split*len_tot)\n    train_len = len_tot-val_len\n    train_data,val_data = dataFrame.iloc[:train_len][:],dataFrame.iloc[train_len:][:]\n    return train_data,val_data","2465326f":"train_data_df,val_data_df = train_test_split(df,SPLIT)","0261238b":"train_data_df","01c2f343":"class WheatDataset(Dataset):\n    def __init__(self,data,root_dir,transform=None,train=True):\n        self.data = data\n        self.root_dir = root_dir\n        self.image_names = self.data.image_id.values\n        self.bboxes = self.data.bboxes.values\n        self.transform = transform\n        self.isTrain = train\n        \n    def __len__(self):\n        return len(self.data)\n    \n    def __getitem__(self,index):\n#         print(self.image_names)\n#         print(self.bboxes)\n        img_path = os.path.join(self.root_dir,self.image_names[index]+\".jpg\")\n        image = cv2.imread(img_path, cv2.IMREAD_COLOR)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB).astype(np.float32)\n        image \/= 255.0\n        bboxes = torch.tensor(self.bboxes[index],dtype=torch.float64)\n#         print(bboxes)\n        \"\"\"\n            As per the docs of torchvision\n            we need bboxes in format (xmin,ymin,xmax,ymax)\n            Currently we have them in format (xmin,ymin,width,height)\n        \"\"\"\n        bboxes[:,2] = bboxes[:,0]+bboxes[:,2]\n        bboxes[:,3] = bboxes[:,1]+bboxes[:,3]\n#         print(image.size,type(image))\n        \"\"\"\n            we need to return image and a target dictionary\n            target:\n                boxes,labels,image_id,area,iscrowd\n        \"\"\"\n        area = (bboxes[:,3]-bboxes[:,1])*(bboxes[:,2]-bboxes[:,0])\n        area = torch.as_tensor(area,dtype=torch.float32)\n        \n        # there is only one class\n        labels = torch.ones((len(bboxes),),dtype=torch.int64)\n        \n        # suppose all instances are not crowded\n        iscrowd = torch.zeros((len(bboxes),),dtype=torch.int64)\n        \n        target = {}\n        target['boxes'] = bboxes\n        target['labels']= labels\n        target['image_id'] = torch.tensor([index])\n        target[\"area\"] = area\n        target['iscrowd'] = iscrowd\n        \n        if self.transform is not None:\n            sample = {\n                'image': image,\n                'bboxes': target['boxes'],\n                'labels': labels\n            }\n            sample = self.transform(**sample)\n            image = sample['image']\n            \n            target['boxes'] = torch.stack(tuple(map(torch.tensor, zip(*sample['bboxes'])))).permute(1, 0)\n            \n        return image,target","5b33e44c":"#Apply necessary transformations\n\ntrain_transform = A.Compose([\n    A.Flip(0.5),\n    ToTensorV2(p=1.0)\n],bbox_params = {'format':\"pascal_voc\",'label_fields': ['labels']})\n\nval_transform = A.Compose([\n      ToTensorV2(p=1.0)\n],bbox_params = {'format':\"pascal_voc\",\"label_fields\":['labels']})","a6626b7f":"def collate_fn(batch):\n    return tuple(zip(*batch))","6adc65e2":"train_data = WheatDataset(train_data_df,DATAPATH+\"\/train\",transform=train_transform)\nvalid_data = WheatDataset(val_data_df,DATAPATH+\"\/train\",transform=val_transform)","8188bc6f":"image,target = train_data.__getitem__(0)\nprint(image.shape)\n\nplt.imshow(image.permute(1, 2, 0))","8f0ab677":"from torchvision.models.detection.faster_rcnn import FastRCNNPredictor\n\n#We use the pretrained Faster-RCNN so that our training is faster\nmodel = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)\n\nnum_classes = 2\nin_features = model.roi_heads.box_predictor.cls_score.in_features\nmodel.roi_heads.box_predictor = FastRCNNPredictor(in_features,num_classes)","51ae241f":"class Averager:\n    def __init__(self):\n        self.current_total=0.0\n        self.iterations = 0.0\n    def send(self,value):\n        self.current_total+=value\n        self.iterations+=1\n    \n    @property\n    def value(self):\n        if self.iterations == 0:\n            return 0\n        else:\n            return 1.0*self.current_total\/self.iterations\n    def reset(self):\n        self.current_total = 0.0\n        self.iterations = 0.0","a40f11d8":"train_dataloader = DataLoader(train_data,batch_size=BATCH_SIZE,shuffle=True,collate_fn=collate_fn)\nval_dataloader = DataLoader(valid_data,batch_size=BATCH_SIZE,shuffle=False,collate_fn=collate_fn)\n\nprint(len(train_dataloader))\nprint(len(val_dataloader))","efd934d6":"train_loss = []\nval_loss = []\nmodel = model.to(DEVICE)\nparams =[p for p in model.parameters() if p.requires_grad]\n\n#We compile the model using Adaptive Momentum Optimizer\noptimizer = optim.Adam(params,lr=LR)\nloss_hist = Averager()\nitr = 1\nlr_scheduler=None","9ca5949f":"#training loop takes some time, better to use saved weights\n\nfrom engine import train_one_epoch, evaluate\n\nloss_hist = Averager()\nitr = 1\nmodel = model.float()\nfor epoch in range(EPOCHS):\n    loss_hist.reset()\n    \n    for images, targets in train_dataloader:\n        \n        images = list(image.to(DEVICE) for image in images)\n        targets = [{k: v.to(DEVICE) for k, v in t.items()} for t in targets]\n\n        loss_dict = model(images, targets)\n\n        losses = sum(loss for loss in loss_dict.values())\n        print(losses.dtype)\n        loss_value = losses.item()\n\n        loss_hist.send(loss_value)\n\n        optimizer.zero_grad()\n        losses.backward()\n        optimizer.step()\n\n        if itr % 50 == 0:\n            print(f\"Iteration #{itr} loss: {loss_value}\")\n\n        itr += 1\n    \n    # update the learning rate\n    if lr_scheduler is not None:\n        lr_scheduler.step()\n\n    print(f\"Epoch #{epoch} loss: {loss_hist.value}\")  \n    evaluate(model, val_dataloader, device=device)","fd238a56":"torch.save(model.state_dict(), 'fasterrcnn_resnet50_fpn.pth')","55a7a783":"model.load_state_dict(torch.load(\"..\/input\/fasterrcnn-weights\/fasterrcnn_resnet50_fpn_best.pth\"))","a6661ee0":"images, targets = next(iter(val_dataloader))\nimages = list(img.to(DEVICE) for img in images)\nprint(images[0].shape)\ntargets = [{k: v.to(DEVICE) for k, v in t.items()} for t in targets]\nboxes = targets[1]['boxes'].cpu().numpy().astype(np.int32)\nsample = images[1].permute(1,2,0).cpu().numpy()","346b332a":"model.eval()\ncpu_device = torch.device(\"cpu\")\n# print(images[0].shape)\noutputs = model(images)\noutputs = [{k: v.to(cpu_device) for k, v in t.items()} for t in outputs]","ebb3e499":"fig, ax = plt.subplots(1, 1, figsize=(16, 8))\n\nfor box in boxes:\n    cv2.rectangle(sample,\n                  (box[0], box[1]),\n                  (box[2], box[3]),\n                  (220, 0, 0), 3)\n    \nax.set_axis_off()\nax.imshow(sample)","1b6d77da":"def bb_intersection_over_union(boxA, boxB):\n\t# determine the (x, y)-coordinates of the intersection rectangle\n\txA = max(boxA[0], boxB[0])\n\tyA = max(boxA[1], boxB[1])\n\txB = min(boxA[2], boxB[2])\n\tyB = min(boxA[3], boxB[3])\n\t# compute the area of intersection rectangle\n\tinterArea = max(0, xB - xA + 1) * max(0, yB - yA + 1)\n\t# compute the area of both the prediction and ground-truth\n\t# rectangles\n\tboxAArea = (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1)\n\tboxBArea = (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1)\n\t# compute the intersection over union by taking the intersection\n\t# area and dividing it by the sum of prediction + ground-truth\n\t# areas - the interesection area\n\tiou = interArea \/ float(boxAArea + boxBArea - interArea)\n\t# return the intersection over union value\n\treturn interArea, float(boxAArea + boxBArea - interArea)","301007c6":"images, targets = next(iter(val_dataloader))\nimages = list(img.to(DEVICE) for img in images)\n#print(images[0].shape)\ntargets = [{k: v.to(DEVICE) for k, v in t.items()} for t in targets]\nboxes = targets[1]\n#sample = images[1].permute(1,2,0).cpu().numpy()\n\nmodel.eval()\ncpu_device = torch.device(\"cpu\")\n# print(images[0].shape)\noutputs = model(images)\noutputs = [{k: v.to(cpu_device) for k, v in t.items()} for t in outputs]\n#outputs = outputs\n\nval_iou = []\n\nfor i in range(len(outputs)):\n    b1 = targets[i]['boxes'].cpu().numpy().astype(np.int32)\n    b2 = outputs[i]['boxes'].detach().numpy().astype(np.int32)\n    sample = images[i].permute(1,2,0).cpu().numpy()\n    \n    scores = outputs[i]['scores'].detach().numpy()\n   # print(scores)\n    #b2 = b2[scores >= 0.5].astype(np.int32)\n    #print(b1.shape)\n    #print(b1)\n    \n    b2 = [x for _ , x in sorted(zip(scores,b2), key=lambda x: x[0], reverse = True)]\n    b2 = b2[:(b1.shape[0])]\n    b_good = []\n    #print(len(b2))\n    numerator = 0\n    denominator = 0\n    \n    for bb2 in b2:\n        for bb1 in b1:\n            #print(bb1, bb2)\n            o = bb_intersection_over_union(bb1, bb2)\n           # print(o)\n            num = o[0]\n            dem = o[1]\n            if num>0 and num\/dem>0.5:\n                numerator += num\n                denominator +=dem\n                b_good.append(bb2)\n    iou = numerator\/denominator\n    print(iou)\n    fig, ax = plt.subplots(1, 1, figsize=(16, 8))\n\n    for box in b1:\n        cv2.rectangle(sample,\n                      (box[0], box[1]),\n                      (box[2], box[3]),\n                      (220, 0, 0), 3)\n    for box in b_good:\n        cv2.rectangle(sample,\n                      (box[0], box[1]),\n                      (box[2], box[3]),\n                      (0, 0, 220), 3)\n    ax.set_axis_off()\n    ax.imshow(sample)\n    \n    \n    \nprint(val_iou)","c3524204":"Define function to calculate Intersection Over Union (IOU)","6dbf9171":"Load the saved weights","e60d33d1":"Save the training weights","8ab8830d":"Firstly we set up the required environment experiment and install necessary libraries and dependencies. ","094bf2dd":"Now let's test the model and see the results","fa089df9":"Name: Aviral Jain | \nRoll No: 18AG3AI08 | \nBTP Guide: Prof. Rajendra Machavaram\n\n# Application of Convolutional Neural Networks for Wheat Head Detection","48327c6f":"I have saved the training weights at: https:\/\/www.kaggle.com\/aviraljain898\/fasterrcnn-weights\n\nLoad model weights instead of training from scratch again."}}