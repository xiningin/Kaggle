{"cell_type":{"cf51c137":"code","30263503":"code","e154fa0c":"code","7ff186b1":"code","ee76acca":"code","e4da0cca":"code","ced6ffa8":"code","220961d7":"code","661dc293":"code","bc9c93dd":"code","dd584a9e":"code","55051fe3":"code","1ab6c4be":"code","90808337":"code","4a197311":"code","5165310e":"markdown"},"source":{"cf51c137":"!pip install --use-feature=2020-resolver --upgrade git+git:\/\/github.com\/Jigsaw-Code\/net-analysis.git@740b3233967c91ffc48f61dc973d51d963a88ed3","30263503":"import pandas as pd\n\nimport netanalysis.ooni.bucket as ob","e154fa0c":"import pathlib\n\nCOUNTRY = 'VE'\nDATA_DIR = pathlib.Path('\/kaggle\/working\/')\nif not DATA_DIR.is_dir():\n    DATA_DIR = pathlib.Path.home()\nDATA_DIR \/= 'ooni_data'\nlocal_measurements = ob.LocalMeasurements(DATA_DIR)","7ff186b1":"%%time\nimport datetime as dt\nLAST_DATE = dt.date.today()\nFIRST_DATE = dt.date.today() - dt.timedelta(days=14)\nbytes, cost = ob.sync_measurements(local_measurements, ob.Bucket().list_files(FIRST_DATE, LAST_DATE, None, COUNTRY), cost_usd_limit=1.00)\nprint(f'Download size: {bytes\/2**30:0.6f} GiB\\nEstimated Cost: ${cost:02f}')","ee76acca":"!(cd $DATA_DIR; du -d 2 -h)","e4da0cca":"%%time\nimport ipaddress\nimport netanalysis.ooni.analysis.dns as od\nfrom netanalysis.ooni.measurement import Measurement\n\ndef is_ip(hostname):\n    try:\n        ipaddress.ip_address(domain)\n        return True\n    except ValueError:\n        return False\n\n# Load measurements and create control.\ndomains = od.DomainRepository()\nevaluator: od.Evaluator = od.Evaluator(domains)\nrows = []\nfor measurement in local_measurements.get_measurements(COUNTRY, 'webconnectivity'):\n    m = Measurement(measurement)\n    domain = m.hostname\n    if is_ip(domain):\n        continue\n    evaluator.add_control(m)\n    try:\n        obs = od.get_observations(domains, m)\n    except:\n        print(f'Failed on measurement for domain {domain}: {m.explorer_url}')\n        raise        \n    rows.extend(o._asdict() for o in obs)\n\n# Now that we have the control, evaluate the measurements.\nfor row in rows:\n    evaluation = evaluator.evaluate(row['domain'], row['status'], row['answers'])\n    row['eval'] = evaluation\n    row['has_interference'] = 1 if evaluation.startswith('BAD') else 0\n\nobs = pd.DataFrame.from_records(rows).sort_values(by='time', ascending=False)\ndel(rows)\nobs","ced6ffa8":"# Fetch list of files from the OONI Bucket\n%time file_list = list(ooni.list_files(dt.date(2020, 10, 1), dt.date(2020, 10, 31), None, COUNTRY))\n\n# Print stats\ndef calculate_data_size(files: Iterable[ob.FileEntry]) -> Tuple[int, Counter]:\n    total_size = 0\n    type_size = Counter()\n    for entry in files:\n        total_size += entry.size\n        type_size[entry.test_type] += entry.size\n    return (total_size, type_size)\ntotal_size, type_size = calculate_data_size(file_list)\nfor test_type, size in type_size.most_common():\n    print(f'{test_type}: {size:,}')\nprint(f'================\\Data size: {total_size:,} bytes')\ndata_cost = 0.09 * total_size \/ 2**30  # $0.09 per GiB\nprint(f'Download cost: ${data_cost:.6f}')\nprint(f'Download time: {total_size \/ 85000000 * 8:.2f}s @ 85 Mbps, {total_size \/ 10000000 * 8:.2f}s @ 10 Mbps')","220961d7":"%%time\n\n# Download files\nfor entry in file_list:\n    local_filename = os.path.join(DATA_DIR, COUNTRY, entry.test_type, posixpath.basename(entry.filename))\n    if os.path.isfile(local_filename):\n        # print(f'File {local_filename} already exists. Skipping')\n        continue\n    print(f'Writing {local_filename}')\n    os.makedirs(os.path.dirname(local_filename), exist_ok=True)\n    with gzip.open(local_filename, mode='wt', encoding='utf-8') as local_file:\n        with ooni.get_file(entry.filename) as remote_file:\n            with gzip.GzipFile(fileobj=remote_file, mode='r') as input_file:\n                for line in input_file:\n                    measurement = ujson.loads(line)\n                    ujson.dump(ob.trim_measurement(measurement,  1000), local_file)\n                    local_file.write('\\n')","661dc293":"def get_local_measurements(directory: str):\n    with os.scandir(directory) as it:\n        for entry in it:\n            with gzip.open(entry.path, 'r') as test_file:\n                for line in test_file:\n                    yield ujson.loads(line)\n\ns = pd.Series(get_local_measurements(os.path.join(DATA_DIR, COUNTRY, 'webconnectivity')))\ndf = pd.DataFrame({\n    \"domain\": s.apply(lambda m: urlparse(m['input']).hostname),\n    \"asn\": s.apply(lambda m: m['probe_asn']),\n    \"country\": s.apply(lambda m: m['probe_cc']),\n    \"software_name\": s.apply(lambda m: m['software_name']),\n    \"measurement\": s})\ndf","bc9c93dd":"with pd.option_context('display.min_rows', 50):\n    display(df['asn'].value_counts())\n    display(df['domain'].value_counts()[:50])","dd584a9e":"with pd.option_context('display.min_rows', 50):\n    for asn, asn_df in df.groupby(by='asn'):\n        print(f'===== {asn} =====')\n        print(asn_df['domain'].value_counts()[:10])\n        print()\n","55051fe3":"# A list of measurement types and theis formats can be found at\n# https:\/\/github.com\/ooni\/spec\/tree\/master\/nettests\n\nfor m in itertools.islice(get_local_measurements(os.path.join(DATA_DIR, COUNTRY, 'webconnectivity')), 1):\n    pprint(m)","1ab6c4be":"https_df = df[df['measurement'].apply(lambda m: urlparse(m['input']).scheme == 'https')]\n\nfor asn, asn_df in https_df.groupby(by='asn'):\n    print(f'===== {asn} =====')\n    print(asn_df['domain'].value_counts()[:10])\n    print()","90808337":"df[(df['asn'] == 'AS0') & (df['domain'] == 'twitter.com')]['measurement'].apply(lambda m: m['test_keys'].get('requests', []))","4a197311":"def get_requests(m):\n    test_keys = m.get('test_keys', {})\n    if not test_keys: return 'ok'\n    return test_keys.get('http_experiment_failure', 'ok')\n    requests = test_keys.get('requests', [])\n    if not requests: return 'ok'\n    return [r.get('failure') for r in requests][0]\n\nfor asn, asn_df in https_df.groupby(by='asn'):\n    print(f'===== {asn} =====')\n    for domain, domain_df in https_df.groupby(by='domain'):\n        errors = domain_df['measurement'].apply(get_requests).value_counts()\n        if errors.empty:\n            continue\n        print(f'----- {domain} -----')\n        print(\"\\n\".join((f'{e[0]}: {e[1]}' for e in errors.items())))\n        print()\n    print()","5165310e":"## SNI-based blocking analysis"}}