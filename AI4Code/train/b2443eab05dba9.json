{"cell_type":{"c033a4d3":"code","676b58df":"code","bbd8bdb0":"code","04d5ccf4":"code","b22dd7c7":"code","ae6a20a5":"code","b0c1ca8d":"code","650e5270":"code","3137482f":"code","37b1a48a":"code","f9aac208":"code","b6746878":"code","c0ca2f47":"code","951c928f":"code","e5173539":"code","4339971b":"code","b17af4ba":"code","2ff35b68":"code","b60b98e9":"code","d27d11be":"code","6144e0a7":"code","a2ad09d3":"markdown","6c070212":"markdown","88f2d51f":"markdown","e18e29d5":"markdown","2505f85d":"markdown","542a11e8":"markdown","9681ce61":"markdown","998fb48f":"markdown","c1679577":"markdown","56b66b41":"markdown","c06bcc4e":"markdown","0358e76f":"markdown","2424c9d8":"markdown","cad945d5":"markdown","86096972":"markdown","afedeba3":"markdown","9dfd7c27":"markdown","0cb83d04":"markdown"},"source":{"c033a4d3":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport os\nimport glob\nimport h5py\nimport shutil\nimport imgaug as aug\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mimg\nimport imgaug.augmenters as iaa\nfrom os import listdir, makedirs, getcwd, remove\nfrom os.path import isfile, join, abspath, exists, isdir, expanduser\nfrom PIL import Image\nfrom pathlib import Path\nfrom skimage.io import imread\nfrom skimage.transform import resize\nfrom keras.models import Sequential, Model\nfrom keras.applications.vgg16 import VGG16, preprocess_input\nfrom keras.preprocessing.image import ImageDataGenerator,load_img, img_to_array\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D, MaxPooling2D, Dense, Dropout, Input, Flatten, SeparableConv2D\nfrom keras.layers import GlobalMaxPooling2D\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.layers.merge import Concatenate\nfrom keras.models import Model\nfrom keras.optimizers import Adam, SGD, RMSprop\nfrom keras.callbacks import ModelCheckpoint, Callback, EarlyStopping\nfrom keras.utils import to_categorical\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom mlxtend.plotting import plot_confusion_matrix\nfrom sklearn.metrics import confusion_matrix\nimport cv2\nfrom keras import backend as K\ncolor = sns.color_palette()\n%matplotlib inline\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","676b58df":"import tensorflow as tf\n\n# Set the seed for hash based operations in python\nos.environ['PYTHONHASHSEED'] = '0'\n\n# Set the numpy seed\nnp.random.seed(111)\n\n# Disable multi-threading in tensorflow ops\nsession_conf = tf.ConfigProto(intra_op_parallelism_threads=1, inter_op_parallelism_threads=1)\n\n# Set the random seed in tensorflow at graph level\ntf.set_random_seed(111)\n\n# Define a tensorflow session with above session configs\nsess = tf.Session(graph=tf.get_default_graph(), config=session_conf)\n\n# Set the session in keras\nK.set_session(sess)\n\n# Make the augmentation sequence deterministic\naug.seed(111)","bbd8bdb0":"# Define path to the data directory\ndata_dir = Path('..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray')\n\n# Path to train directory (Fancy pathlib...no more os.path!!)\ntrain_dir = data_dir \/ 'train'\n\n# Path to validation directory\nval_dir = data_dir \/ 'val'\n\n# Path to test directory\ntest_dir = data_dir \/ 'test'","04d5ccf4":"# Get the path to the normal and pneumonia sub-directories\nnormal_cases_dir = train_dir \/ 'NORMAL'\npneumonia_cases_dir = train_dir \/ 'PNEUMONIA'\n\n# Get the list of all the images\nnormal_cases = normal_cases_dir.glob('*.jpeg')\npneumonia_cases = pneumonia_cases_dir.glob('*.jpeg')\n\n# An empty list. We will insert the data into this list in (img_path, label) format\ntrain_data = []\n\n# Go through all the normal cases. The label for these cases will be 0\nfor img in normal_cases:\n    train_data.append((img,0))\n\n# Go through all the pneumonia cases. The label for these cases will be 1\nfor img in pneumonia_cases:\n    train_data.append((img, 1))\n\n# Get a pandas dataframe from the data we have in our list \ntrain_data = pd.DataFrame(train_data, columns=['image', 'label'],index=None)\n\n# Shuffle the data \ntrain_data = train_data.sample(frac=1.).reset_index(drop=True)\n\n# How the dataframe looks like?\ntrain_data.head()","b22dd7c7":"# Get the counts for each class\ncases_count = train_data['label'].value_counts()\nprint(cases_count)\n\n# Plot the results \nplt.figure(figsize=(10,8))\nsns.barplot(x=cases_count.index, y= cases_count.values)\nplt.title('Number of cases', fontsize=14)\nplt.xlabel('Case type', fontsize=12)\nplt.ylabel('Count', fontsize=12)\nplt.xticks(range(len(cases_count.index)), ['Normal(0)', 'Pneumonia(1)'])\nplt.show()","ae6a20a5":"# Get few samples for both the classes\npneumonia_samples = (train_data[train_data['label']==1]['image'].iloc[:5]).tolist()\nnormal_samples = (train_data[train_data['label']==0]['image'].iloc[:5]).tolist()\n\n# Concat the data in a single list and del the above two list\nsamples = pneumonia_samples + normal_samples\ndel pneumonia_samples, normal_samples\n\n# Plot the data \nf, ax = plt.subplots(2,5, figsize=(30,10))\nfor i in range(10):\n    img = imread(samples[i])\n    ax[i\/\/5, i%5].imshow(img, cmap='gray')\n    if i<5:\n        ax[i\/\/5, i%5].set_title(\"Pneumonia\")\n    else:\n        ax[i\/\/5, i%5].set_title(\"Normal\")\n    ax[i\/\/5, i%5].axis('off')\n    ax[i\/\/5, i%5].set_aspect('auto')\nplt.show()","b0c1ca8d":"# Get the path to the sub-directories\nnormal_cases_dir = val_dir \/ 'NORMAL'\npneumonia_cases_dir = val_dir \/ 'PNEUMONIA'\n\n# Get the list of all the images\nnormal_cases = normal_cases_dir.glob('*.jpeg')\npneumonia_cases = pneumonia_cases_dir.glob('*.jpeg')\n\n# List that are going to contain validation images data and the corresponding labels\nvalid_data = []\nvalid_labels = []\n\n\n# Some images are in grayscale while majority of them contains 3 channels. So, if the image is grayscale, we will convert into a image with 3 channels.\n# We will normalize the pixel values and resizing all the images to 224x224 \n\n# Normal cases\nfor img in normal_cases:\n    img = cv2.imread(str(img))\n    img = cv2.resize(img, (224,224))\n    if img.shape[2] ==1:\n        img = np.dstack([img, img, img])\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = img.astype(np.float32)\/255.\n    label = to_categorical(0, num_classes=2)\n    valid_data.append(img)\n    valid_labels.append(label)\n                      \n# Pneumonia cases        \nfor img in pneumonia_cases:\n    img = cv2.imread(str(img))\n    img = cv2.resize(img, (224,224))\n    if img.shape[2] ==1:\n        img = np.dstack([img, img, img])\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = img.astype(np.float32)\/255.\n    label = to_categorical(1, num_classes=2)\n    valid_data.append(img)\n    valid_labels.append(label)\n    \n# Convert the list into numpy arrays\nvalid_data = np.array(valid_data)\nvalid_labels = np.array(valid_labels)\n\nprint(\"Total number of validation examples: \", valid_data.shape[0])\nprint(\"Total number of labels:\", valid_labels.shape[0])","650e5270":"# Augmentation sequence \nseq = iaa.OneOf([\n    iaa.Fliplr(), # horizontal flips\n    iaa.Affine(rotate=20), # roatation\n    iaa.Multiply((1.2, 1.5))]) #random brightness","3137482f":"def data_gen(data, batch_size):\n    # Get total number of samples in the data\n    n = len(data)\n    steps = n\/\/batch_size\n    \n    # Define two numpy arrays for containing batch data and labels\n    batch_data = np.zeros((batch_size, 224, 224, 3), dtype=np.float32)\n    batch_labels = np.zeros((batch_size,2), dtype=np.float32)\n\n    # Get a numpy array of all the indices of the input data\n    indices = np.arange(n)\n    \n    # Initialize a counter\n    i =0\n    while True:\n        np.random.shuffle(indices)\n        # Get the next batch \n        count = 0\n        next_batch = indices[(i*batch_size):(i+1)*batch_size]\n        for j, idx in enumerate(next_batch):\n            img_name = data.iloc[idx]['image']\n            label = data.iloc[idx]['label']\n            \n            # one hot encoding\n            encoded_label = to_categorical(label, num_classes=2)\n            # read the image and resize\n            img = cv2.imread(str(img_name))\n            img = cv2.resize(img, (224,224))\n            \n            # check if it's grayscale\n            if img.shape[2]==1:\n                img = np.dstack([img, img, img])\n            \n            # cv2 reads in BGR mode by default\n            orig_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n            # normalize the image pixels\n            orig_img = img.astype(np.float32)\/255.\n            \n            batch_data[count] = orig_img\n            batch_labels[count] = encoded_label\n            \n            # generating more samples of the undersampled class\n            if label==0 and count < batch_size-2:\n                aug_img1 = seq.augment_image(img)\n                aug_img2 = seq.augment_image(img)\n                aug_img1 = cv2.cvtColor(aug_img1, cv2.COLOR_BGR2RGB)\n                aug_img2 = cv2.cvtColor(aug_img2, cv2.COLOR_BGR2RGB)\n                aug_img1 = aug_img1.astype(np.float32)\/255.\n                aug_img2 = aug_img2.astype(np.float32)\/255.\n\n                batch_data[count+1] = aug_img1\n                batch_labels[count+1] = encoded_label\n                batch_data[count+2] = aug_img2\n                batch_labels[count+2] = encoded_label\n                count +=2\n            \n            else:\n                count+=1\n            \n            if count==batch_size-1:\n                break\n            \n        i+=1\n        yield batch_data, batch_labels\n            \n        if i>=steps:\n            i=0","37b1a48a":"def build_model():\n    input_img = Input(shape=(224,224,3), name='ImageInput')\n    x = Conv2D(64, (3,3), activation='relu', padding='same', name='Conv1_1')(input_img)\n    x = Conv2D(64, (3,3), activation='relu', padding='same', name='Conv1_2')(x)\n    x = MaxPooling2D((2,2), name='pool1')(x)\n    \n    x = SeparableConv2D(128, (3,3), activation='relu', padding='same', name='Conv2_1')(x)\n    x = SeparableConv2D(128, (3,3), activation='relu', padding='same', name='Conv2_2')(x)\n    x = MaxPooling2D((2,2), name='pool2')(x)\n    \n    x = SeparableConv2D(256, (3,3), activation='relu', padding='same', name='Conv3_1')(x)\n    x = BatchNormalization(name='bn1')(x)\n    x = SeparableConv2D(256, (3,3), activation='relu', padding='same', name='Conv3_2')(x)\n    x = BatchNormalization(name='bn2')(x)\n    x = SeparableConv2D(256, (3,3), activation='relu', padding='same', name='Conv3_3')(x)\n    x = MaxPooling2D((2,2), name='pool3')(x)\n    \n    x = SeparableConv2D(512, (3,3), activation='relu', padding='same', name='Conv4_1')(x)\n    x = BatchNormalization(name='bn3')(x)\n    x = SeparableConv2D(512, (3,3), activation='relu', padding='same', name='Conv4_2')(x)\n    x = BatchNormalization(name='bn4')(x)\n    x = SeparableConv2D(512, (3,3), activation='relu', padding='same', name='Conv4_3')(x)\n    x = MaxPooling2D((2,2), name='pool4')(x)\n    \n    x = Flatten(name='flatten')(x)\n    x = Dense(1024, activation='relu', name='fc1')(x)\n    x = Dropout(0.7, name='dropout1')(x)\n    x = Dense(512, activation='relu', name='fc2')(x)\n    x = Dropout(0.5, name='dropout2')(x)\n    x = Dense(2, activation='softmax', name='fc3')(x)\n    \n    model = Model(inputs=input_img, outputs=x)\n    return model","f9aac208":"model =  build_model()\nmodel.summary()","b6746878":"# Open the VGG16 weight file\nf = h5py.File('..\/input\/vgg16\/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5', 'r')\n\n# Select the layers for which you want to set weight.\n\nw,b = f['block1_conv1']['block1_conv1_W_1:0'], f['block1_conv1']['block1_conv1_b_1:0']\nmodel.layers[1].set_weights = [w,b]\n\nw,b = f['block1_conv2']['block1_conv2_W_1:0'], f['block1_conv2']['block1_conv2_b_1:0']\nmodel.layers[2].set_weights = [w,b]\n\nw,b = f['block2_conv1']['block2_conv1_W_1:0'], f['block2_conv1']['block2_conv1_b_1:0']\nmodel.layers[4].set_weights = [w,b]\n\nw,b = f['block2_conv2']['block2_conv2_W_1:0'], f['block2_conv2']['block2_conv2_b_1:0']\nmodel.layers[5].set_weights = [w,b]\n\nf.close()\nmodel.summary()    ","c0ca2f47":"# opt = RMSprop(lr=0.0001, decay=1e-6)\nopt = Adam(lr=0.0001, decay=1e-5)\nes = EarlyStopping(patience=5)\nchkpt = ModelCheckpoint(filepath='best_model_todate', save_best_only=True, save_weights_only=True)\nmodel.compile(loss='binary_crossentropy', metrics=['accuracy'],optimizer=opt)","951c928f":"batch_size = 16\nnb_epochs = 20\n\n# Get a train data generator\ntrain_data_gen = data_gen(data=train_data, batch_size=batch_size)\n\n# Define the number of training steps\nnb_train_steps = train_data.shape[0]\/\/batch_size\n\nprint(\"Number of training and validation steps: {} and {}\".format(nb_train_steps, len(valid_data)))","e5173539":"# # Fit the model\n# history = model.fit_generator(train_data_gen, epochs=nb_epochs, steps_per_epoch=nb_train_steps,\n#                               validation_data=(valid_data, valid_labels),callbacks=[es, chkpt],\n#                               class_weight={0:1.0, 1:0.4})","4339971b":"# Load the model weights\nmodel.load_weights(\"..\/input\/xray-best-model\/best_model\/best_model.hdf5\")","b17af4ba":"# Preparing test data\nnormal_cases_dir = test_dir \/ 'NORMAL'\npneumonia_cases_dir = test_dir \/ 'PNEUMONIA'\n\nnormal_cases = normal_cases_dir.glob('*.jpeg')\npneumonia_cases = pneumonia_cases_dir.glob('*.jpeg')\n\ntest_data = []\ntest_labels = []\n\nfor img in normal_cases:\n    img = cv2.imread(str(img))\n    img = cv2.resize(img, (224,224))\n    if img.shape[2] ==1:\n        img = np.dstack([img, img, img])\n    else:\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = img.astype(np.float32)\/255.\n    label = to_categorical(0, num_classes=2)\n    test_data.append(img)\n    test_labels.append(label)\n                      \nfor img in pneumonia_cases:\n    img = cv2.imread(str(img))\n    img = cv2.resize(img, (224,224))\n    if img.shape[2] ==1:\n        img = np.dstack([img, img, img])\n    else:\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = img.astype(np.float32)\/255.\n    label = to_categorical(1, num_classes=2)\n    test_data.append(img)\n    test_labels.append(label)\n    \n\ntest_data = np.array(test_data)\ntest_labels = np.array(test_labels)\n\nprint(\"Total number of test examples: \", test_data.shape)\nprint(\"Total number of labels:\", test_labels.shape)","2ff35b68":"# Evaluation on test dataset\ntest_loss, test_score = model.evaluate(test_data, test_labels, batch_size=16)\nprint(\"Loss on test set: \", test_loss)\nprint(\"Accuracy on test set: \", test_score)","b60b98e9":"# Get predictions\npreds = model.predict(test_data, batch_size=16)\npreds = np.argmax(preds, axis=-1)\n\n# Original labels\norig_test_labels = np.argmax(test_labels, axis=-1)\n\nprint(orig_test_labels.shape)\nprint(preds.shape)","d27d11be":"# Get the confusion matrix\ncm  = confusion_matrix(orig_test_labels, preds)\nplt.figure()\nplot_confusion_matrix(cm,figsize=(12,8), hide_ticks=True, cmap=plt.cm.Blues)\nplt.xticks(range(2), ['Normal', 'Pneumonia'], fontsize=16)\nplt.yticks(range(2), ['Normal', 'Pneumonia'], fontsize=16)\nplt.show()","6144e0a7":"# Calculate Precision and Recall\ntn, fp, fn, tp = cm.ravel()\n\nprecision = tp\/(tp+fp)\nrecall = tp\/(tp+fn)\n\nprint(\"Recall of the model is {:.2f}\".format(recall))\nprint(\"Precision of the model is {:.2f}\".format(precision))","a2ad09d3":"## Augmentation\nData augmentation is a powerful technique which helps in almost every case for improving the robustness of a model. But augmentation can be much more helpful where the dataset is imbalanced. You can generate different samples of undersampled class in order to try to balance the overall distribution. \n\nI like [imgaug](https:\/\/imgaug.readthedocs.io\/en\/latest\/) a lot. It comes with a very clean api and you can do hell of augmentations with it. It's worth exploring!!\nIn the next code block, I will define a augmentation sequence. You will notice `Oneof` and it does exactly that. At each iteration, it will take one augmentation technique out of the three and will apply that on the samples ","6c070212":"Reproducibility is a great concern when doing deep learning. There was a good discussion on `KaggleNoobs` slack regarding this. We will set a numer of things in order to make sure that the results are almost reproducible(if not fully). ","88f2d51f":"The dataset is divided into three sets: 1) train set    2) validation set    and 3) test set.  Let's grab the dataset   ","e18e29d5":"Nice!!! So, our model has a 98% recall. In such problems, a good recall value is expected. But if you notice, the precision is only 80%. This is one thing to notice. Precision and Recall follows a trade-off, and you need to find a point where your recall, as well as your precision, is more than good but both can't increase simultaneously. ","2505f85d":"![training](https:\/\/i.imgur.com\/vVZgEKV.png)","542a11e8":"## Model \n\nSome best practices when doing deep learning:\n\n1. Choose a simple architecture.\n2. Initialize the first few layers from a network that is pretrained on imagenet. This is because first few layers capture general details like color blobs, patches, edges, etc. Instead of randomly initialized weights for these layers, it would be much better if you fine tune them.\n3. Choose layers that introduce a lesser number of parameters. For example, `Depthwise SeparableConv` is a good replacement for `Conv` layer. It introduces lesser number of parameters as compared to normal convolution and as different filters are applied to each channel, it captures more information.  `Xception` a powerful network, is built on top of such layers only. You can read about `Xception` and `Depthwise Separable Convolutions` in [this](https:\/\/arxiv.org\/abs\/1610.02357) paper.\n4. Use batch norm with convolutions.  As the network becomes deeper, batch norm start to play an important role.\n5. Add dense layers with reasonable amount of neurons. Train with a higher learning rate and experiment with the number of neurons in the dense layers. Do it for the depth of your network too. \n6. Once you know a good depth, start training your network with a lower learning rate along with decay.  \n\nThis is all that I have done in the next code block.\n","9681ce61":"As you can see the data is highly imbalanced. We have almost with three times more pneumonia cases here as compared to the normal cases. This situation is very normal when it comes to medical data. The data will always be imbalanced. either there will be too many normal cases or there will be too many cases with the disease. \n\nLet's look at how a normal case is different from that of a pneumonia case. We will look at somes samples from our training data itself.","998fb48f":"### Preparing validation data\nWe will be defining a generator for the training dataset later in the notebook but as the validation data is small, so I can read the images and can load the data without the need of a generator.  This is exactly what the code block given below is doing.","c1679577":"We will initialize the weights of first two convolutions with imagenet weights,","56b66b41":"When a particular problem includes an imbalanced dataset, then accuracy isn't a good  metric to look for. For example, if your dataset contains 95 negatives and 5 positives, having a model with 95% accuracy doesn't make sense at all. The classifier might label every example as negative and still achieve 95% accuracy. Hence,  we need to look for alternative metrics. **Precision** and **Recall** are really good metrics for such kind of problems. \n\nWe will get the confusion matrix from our predictions and see what is the recall and precision of our model.","c06bcc4e":"If you look carefully, then there are some cases where you won't be able to differentiate between a normal case and a pneumonia case with the naked eye. There is one case in the above plot, at least for me ,which is too much confusing. If we can build a robust classifier, it would be a great assist to the doctor too.","0358e76f":"### How many samples for each class are there in the dataset?","2424c9d8":"# Ethical Considerations\nWhen applying machine learning to medical data we must be very careful about how it is used and how successful it is likely to be. Whilst our model performed well, it falsely detected 100 cases of pneumonia, and 8 people with pneumonia were undiagnosed. Had this been a real diagnosis, those 8 people could have suffered much more or potentially even died due to a misdiagnosis. Thus we must be careful how models like this are used: edge cases must be reviewed by a professional and patients should be made aware of the possibility of a misdiagnosis. Transparency is key when working with this technology.\n\nHowever it should also be noted that doctors can also misdiagnose patients and so an imperfect model can still improve on doctors diagnoses. ","cad945d5":"I have commented out the training step as of now as it will train the network again while rendering the notebook and I would have to wait for an hour or so which I don't want to. I have uploaded the weights of the best model I achieved so far. Feel free to use it for further fine-tuning of the network. We will load those weights and will run the inference on the test set using those weights only. But...but for your reference, I will attach the screenshot of the training steps here.","86096972":"<h1>Classification<\/h1>\n<p>Classification tasks are tasks where you have to classify data into discrete classes. Here, we use as an example, x-ray images of people with and without pneumonia. We can then use machine learning to predict whether or not the person has pneumonia .<\/p>\n\n<h1> The Data <\/h1>\nThe dataset contains xray images of people who either do or do not have pneumonia. Bacterial pneumonia (middle) typically exhibits a focal lobar consolidation, in this case in the right upper lobe (white arrows), whereas viral pneumonia (right) manifests with a more diffuse \u2018\u2018interstitial\u2019\u2019 pattern in both lungs.![jZqpV51.png](attachment:jZqpV51.png)\n\nThis an ideal dataset for classification using deep learning.\n\n<h1> Exploratory Data Analysis <\/h1>\n<p> The first thing we must do is load the data and examine it <\/p>","afedeba3":"### Training data generator \nHere I will define a very simple data generator. You can do more than this if you want but I think at this point, this is more than enough I need.","9dfd7c27":"<h1> The need for convolution <\/h1>\nWhen processing image data convolutional neural networks are one of the best tools available. To see why this is we should first understand how a perceptron would process image data. The perceptron would take each pixel as an independent feature which would feed forward normally into the neural network to classify the data. Whilst it would be possible to learn very complex patterns using the perceptron, it would require a very large set of diverse images, which is very difficult to obtain. It is also quite different to how we humans process image data.\n\nThe CNN improves on this by using convolution.  The convolutional layers pass a filter over subsections of the image to produce data which with information about the local region rather than just one pixel. A typical CNN will have several filters which will process different information.\n![1_VVvdh-BUKFh2pwDD0kPeRA@2x.gif](attachment:1_VVvdh-BUKFh2pwDD0kPeRA@2x.gif)\n\nThis process is also known as feature extraction and it is what allows the CNN to perceive patterns in the relations between nearby pixels without having to worry about translation errors. In fact, CNNs are translation invariant!\n\nIt is then common to have a pooling layer which then reduces the dimensionality of the data by looking at windows of the data and extracting information from it. The most common kind of pooling is max pooling, where you take the maximum value in that window.\n![image.png](attachment:image.png)\n\n","0cb83d04":"We will first go through the training dataset. We will do some analysis on that, look at some of the samples, check the number of samples for each class, etc.  Lets' do it.\n\nEach of the above directory contains two sub-directories:\n* `NORMAL`: These are the samples that describe the normal (no pneumonia) case.\n* `PNEUMONIA`: This directory contains those samples that are the pneumonia cases."}}