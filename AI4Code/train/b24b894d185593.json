{"cell_type":{"21b0b110":"code","227680de":"code","7362a221":"code","d1f0b9e9":"code","21701c10":"code","3d21cf3a":"code","9204cbfe":"code","d4efd961":"code","7072eac0":"code","f2c3de71":"code","5f74e151":"code","e0090bcf":"code","da7a6a77":"code","f0f05fb3":"code","89229b29":"code","b455b793":"markdown","cc00a4a1":"markdown","9875adbb":"markdown","e0e84f64":"markdown","62d81b75":"markdown","5227a4c8":"markdown","27e06c01":"markdown"},"source":{"21b0b110":"import numpy as np\nimport pandas as pd\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\n\n# for progressbar\nfrom tqdm.autonotebook import tqdm\n\ndevice = 'cuda:0' if torch.cuda.is_available() else 'cpu'","227680de":"dataset = pd.read_csv('..\/input\/fashionmnist\/fashion-mnist_train.csv')\ndataset.head()","7362a221":"Y = dataset[\"label\"].values\nX = dataset.drop(\"label\", axis=1).values","d1f0b9e9":"labels = [\"T-shirt\/top\", \"Trouser\", \"Pullover\", \"Dress\", \"Coat\", \"Sandal\", \"Shirt\", \"Sneaker\", \"Bag\", \"Ankle boot\"]\n\nplt.figure(figsize=(10, 10))\nfor idx in range(36): \n    plt.subplot(6, 6, idx+1)\n    plt.xticks([])\n    plt.yticks([])\n    plt.grid(False)\n    plt.imshow(X[idx].reshape((28, 28)))\n    label_index = int(Y[idx])\n    plt.title(labels[label_index])\nplt.show()","21701c10":"batch_size = 32","3d21cf3a":"def get_data_loaders_from_numpy_arrays(X, Y): \n    \n    # split into training and testing set\n    X_train, X_val, Y_train, Y_val = train_test_split(X, Y, test_size=0.2, random_state=42)\n    \n    X_train = torch.from_numpy(X_train).view(-1, 1, 28, 28).float()\n    Y_train = torch.from_numpy(Y_train).type(torch.LongTensor)\n\n    X_val = torch.from_numpy(X_val).view(-1, 1, 28, 28).float()\n    Y_val = torch.from_numpy(Y_val).type(torch.LongTensor)\n\n    train = torch.utils.data.TensorDataset(X_train, Y_train)\n    val = torch.utils.data.TensorDataset(X_val, Y_val)\n\n    train_loader = torch.utils.data.DataLoader(train, batch_size=batch_size, shuffle=True)\n    val_loader = torch.utils.data.DataLoader(val, batch_size=batch_size, shuffle=True)\n    \n    return train_loader, val_loader","9204cbfe":"X = X \/ 255\n\ntrain_loader, val_loader = get_data_loaders_from_numpy_arrays(X, Y)","d4efd961":"learning_rate = 0.002\nmomentum = 0.9\nepochs = 7\n\nloss_function = F.cross_entropy","7072eac0":"class Net(nn.Module): \n    def __init__(self): \n        super().__init__()\n        \n        self.conv1 = nn.Conv2d(1, 32, kernel_size=3, padding=1)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1)\n        self.conv3 = nn.Conv2d(64, 128, kernel_size=3, padding=1)\n        \n        self.bn1 = nn.BatchNorm2d(32)\n        self.bn2 = nn.BatchNorm2d(64)\n        self.bn3 = nn.BatchNorm2d(128)\n        \n        self.fc1 = nn.Linear(14*14*128, 2048)\n        self.bn4 = nn.BatchNorm1d(2048)\n        \n        self.fc2 = nn.Linear(2048, 128)\n        self.bn5 = nn.BatchNorm1d(128)\n        \n        self.fc3 = nn.Linear(128, 10)\n        \n        \n    def forward(self, x):\n        \n        x = self.conv1(x)\n        x = self.bn1(x)\n        x = F.relu(x)\n        \n        x = self.conv2(x)\n        x = self.bn2(x)\n        x = F.relu(x)\n        \n        x = self.conv3(x)\n        x = self.bn3(x)\n        x = F.relu(x)\n        \n        x = F.max_pool2d(x, 2)\n        x = F.dropout(x, p=0.2)\n        \n        x = x.view(-1, 14*14*128)\n        x = self.fc1(x)\n        x = self.bn4(x)\n        x = F.relu(x)\n        \n        x = self.fc2(x)\n        x = self.bn5(x)\n        x = F.relu(x)\n        \n        x = self.fc3(x)\n        return x","f2c3de71":"def train(model, loss_function): \n    \n    optimizer = torch.optim.Adam(params=model.parameters(), lr=learning_rate)\n    \n    model.train()\n    \n    pbar = tqdm(total=len(train_loader))\n    errors = []\n    \n    for epoch in range(epochs): \n        \n        pbar.set_description('Epoch %d\/%d' % (epoch + 1, epochs))\n        pbar.reset()\n        errors.append(0)\n        \n        for inputs, targets in train_loader: \n            \n            inputs = inputs.to(device)\n            targets = targets.to(device)\n            \n            optimizer.zero_grad()\n            \n            preds = model(inputs)\n            error = loss_function(preds.squeeze(dim=1), targets)\n            errors[-1] += error.item()\n            error.backward()\n            \n            optimizer.step()\n            \n            pbar.update()\n            \n        errors[-1] \/= len(train_loader)\n        print('Epoch %d finished with training loss: %g' % (epoch + 1, errors[-1]))\n        \n    pbar.close()","5f74e151":"model = Net().to(device)\n\ntrain(model, loss_function)","e0090bcf":"def evaluate_model(model: torch.nn.Module, dataset: torch.utils.data.DataLoader, loss_function: F): \n    \n    loss_result = 0\n    acc_result = 0\n    \n    model.eval()\n    \n    for inputs, targets in dataset: \n        inputs = inputs.to(device)\n        targets = targets.to(device)\n        \n        with torch.no_grad(): \n            \n            preds = model(inputs)\n            \n            loss_result += loss_function(preds.squeeze(dim=1), targets).item()\n            acc_result += (preds.argmax(-1) == targets).float().mean()\n            \n    acc_result \/= len(dataset)\n        \n    return acc_result.item(), loss_result \/ len(dataset)    ","da7a6a77":"acc_train, loss_train = evaluate_model(model, train_loader, loss_function)\nprint('Training set: ')\nprint('Loss: %g, Accuracy: %g' % (loss_train, acc_train))\nprint('')\n\nacc_val, loss_val = evaluate_model(model, val_loader, loss_function)\nprint('Validation set: ')\nprint('Loss: %g, Accuracy: %g' % (loss_val, acc_val))","f0f05fb3":"test_dataset = pd.read_csv('..\/input\/fashionmnist\/fashion-mnist_test.csv')\n\nY_test_set = test_dataset[\"label\"].values\nY_test = torch.from_numpy(Y_test_set).type(torch.LongTensor)\nX_test_set = test_dataset.drop(\"label\", axis=1).values \/ 255\nX_test = torch.from_numpy(X_test_set).view(-1, 1, 28, 28).float()\n\ntest = torch.utils.data.TensorDataset(X_test, Y_test)\ntest_loader = torch.utils.data.DataLoader(test, batch_size=batch_size, shuffle=False)","89229b29":"test_acc, test_loss = evaluate_model(model, test_loader, loss_function)\nprint('Test set: ')\nprint('Loss: %g, Accuracy: %g' % (test_loss, test_acc))        ","b455b793":"## Load Dataset","cc00a4a1":"## Imports","9875adbb":"## Create Model","e0e84f64":"## Train Model","62d81b75":"## Create Dataloaders","5227a4c8":"## Evaluate Model","27e06c01":"## Taking a look on the dataset"}}