{"cell_type":{"f366fe76":"code","089b0416":"code","f6dfbf24":"code","36fe25ec":"code","20d4a2f6":"code","74105df3":"code","afea2805":"code","191ee1bb":"code","6832462c":"code","9bdcde8a":"code","b42136a3":"code","47ea04f7":"code","40b8e941":"code","cb3d2adf":"code","f8c5e758":"code","c8b41713":"code","3caa4e94":"code","14bb61dc":"code","0d149170":"code","72949d78":"code","85972e84":"code","ecffe720":"code","4dd6b47f":"code","59ae466b":"markdown","a6fd3c8b":"markdown","9548aaa1":"markdown","18c237ac":"markdown","fe7d2a08":"markdown","2a644f6b":"markdown","5fa753b4":"markdown","64ee1180":"markdown","1bba8ca3":"markdown","58dabf18":"markdown","80e95fc2":"markdown","ac9dd5f5":"markdown","0874153b":"markdown","013d89be":"markdown","55a95040":"markdown","56e679da":"markdown","587dd34f":"markdown","258384fd":"markdown","37ca11c2":"markdown","4266a8e8":"markdown","5f1931d7":"markdown","4032edcb":"markdown","c835f9fe":"markdown","a17961ad":"markdown"},"source":{"f366fe76":"import numpy as np\nimport pennylane as qml\n\nfrom pennylane import expval, var\nfrom matplotlib import pyplot as plt\n\nimport time","089b0416":"pi = np.pi\ndef initialize_theta(layers):\n    \n    row = layers*2\n    column = 4\n    theta = np.random.uniform(low=0, high=2*pi, size=(row, column))\n    \n    return theta","f6dfbf24":"# This function returns a random valued numpy array phi, with respect to which cost of the quantum circuit will be calculated\n# dimension of phi will be same as the dimension of np array returned by make_circuit() \ndef initialize_random_phi():\n    phi = np.random.randn(16,)\n    return phi","36fe25ec":"def simulate_circuit(theta):\n    dev = qml.device(\"default.qubit\", wires=4)\n\n    @qml.qnode(dev)\n    def circuit(theta):\n    #This circuit function genrates the quantum circuit. It takes only the parameters theta as the argument\n    #The no. of layers has not to be passed explicitely, as it is calculated from dimension of theta\n\n\n        layers = theta.shape[0] \/\/ 2\n\n        for i in range(layers):\n\n            # yellow block\n            for j in range(4): #This loops over all four qubits and apply RX gate with proper param extracted from theta\n                qml.RX(theta[2*i][j], wires=j)\n\n            # Green block\n            for j in range(4): #THis loops over all 4 qubits and apply RZ gate with proper param extracted from theta\n                qml.RZ(theta[(2*i)+1][j], wires=j)\n\n            for control in range(3): # Double qubit CZ gates has been applied here\n                for target in range(control+1, 4):\n                    qml.CZ(wires=[control, target])\n\n\n        return qml.expval(qml.PauliZ(wires=0)),  qml.expval(qml.PauliZ(wires=1)), qml.expval(qml.PauliZ(wires=2)), qml.expval(qml.PauliZ(wires=3))\n       \n    circuit(theta)\n    \n    #returns the 2^4 = 16 dimensioned output statevector of the simulated circuit\n    return dev.state","20d4a2f6":"# This function takes the theta, calls the simulate_circuit() func and calculates the cost of vector returned \n# by the simulate_circuit() with respect to global variable psi\ndef calc_distance(theta):\n    \n    psi_of_theta = simulate_circuit(theta) \n    diff = psi_of_theta - phi #phi is the global one here, used for all the layers\n    mod_sqr = diff.real**2 + diff.imag**2\n    distance = np.sum(mod_sqr) #calculates the sum of squares of corresponding vector elements of psi and phi\n    \n    # returns the cost (mentioned as 'distance' in problem statement)\n    return distance","74105df3":"# this takes param of the circuit, iteratioin and eta as necessary arguments\n# also two optional args to print and plot the cost for each layer count\ndef optimize(theta, iterations, print_distance=False, plot_distance=False):\n    \n    \n    distance_hist = [] #keeps track of cost after each iterations\n    \n    optimizer = qml.optimize.RotosolveOptimizer() \n    \n    # callback: this flag is initialized to keep track of repeating costs, which is further used to terminate the iteration\n    # when optimization is completed approx\n    flag = 0\n    \n    print(\"Optimizing\\n\", end='')\n    \n    for i in range(iterations): \n        theta = optimizer.step(calc_distance, theta)\n        distance = calc_distance(theta) #calls the ampltude() to calculate cost of the circuit\n        print('.', end='')\n        \n        # this code chunk is used to compare current cost with the previous one to check repetations\n        if(len(distance_hist)>0):\n            if(round(distance_hist[-1],2)==round(distance,2)): #here upto 2 decimal places round off has been done\n                flag += 1\n            else:\n                flag = 0\n        distance_hist.append(distance)\n        if(print_distance):\n            print(\"Iteration=> \"+str(i)+\", distance=> \"+str(distance))\n        \n        # Whenever flag becomes 3, means 3 times same cost has been calculated, we can assume the params to be\n        # optimized and can terminate the gradient descent\n        if(flag == 3):\n            break\n    \n    print('\\nOptimization Completed')\n        \n        \n    if(plot_distance):\n        plt.style.use(\"seaborn\")\n        plt.plot(distance_hist, \"b\", label=\"Optimization\")\n        plt.ylabel(\"Distance value\")\n        plt.xlabel(\"Optimization steps\")\n        plt.legend()\n        plt.show()\n    \n    #returns the final_cost, maximum iteration used and optimized parameter values\n    cache = {\"min_distance\": distance_hist[-1],\n             \"iter\": i+1,\n             \"optimized_theta\": theta}\n    \n    return cache","afea2805":"phi = initialize_random_phi()","191ee1bb":"min_distance_list = []\niter_list = []\noptimized_theta_list = []\ntime_list = []\n\ndef simulate(layer):\n    theta = initialize_theta(layer)\n\n    start = time.time()\n    cache = optimize(theta, 50, print_distance=True, plot_distance=True)\n    time_taken = time.time() - start\n\n    iter_list.append(cache['iter'])\n    min_distance_list.append(cache['min_distance'])\n    time_list.append(time_taken)\n\n    print(\"\\n_______________________________________\")\n    print(\"_______________________________________\")\n    print(\"\\n\\n Layer count in Circuit => \"+str(layer))\n    print(\"\\n Iteration used => \"+str(cache['iter']))\n    print(\" Minimum distance => \"+str(cache['min_distance']))\n    print(\" Time taken for optimization (minute) => \"+str(time_taken\/60))","6832462c":"layer = 1\nsimulate(layer)","9bdcde8a":"layer = 2\nsimulate(layer)","b42136a3":"layer = 3\nsimulate(layer)","47ea04f7":"layer = 4\nsimulate(layer)","40b8e941":"layer = 5\nsimulate(layer)","cb3d2adf":"layer = 6\nsimulate(layer)","f8c5e758":"layer = 7\nsimulate(layer)","c8b41713":"layer = 8\nsimulate(layer)","3caa4e94":"layer = 9\nsimulate(layer)","14bb61dc":"layer = 10\nsimulate(layer)","0d149170":"layer = 11\nsimulate(layer)","72949d78":"layer = 12\nsimulate(layer)","85972e84":"# plots final cost as a function of no. of layers used in the circuit\nplt.style.use(\"seaborn\")\nplt.plot(np.arange(1,layer+1),min_distance_list, \"b\")\nplt.ylabel(\"Minimum distance\")\nplt.xlabel(\"No. of layers\")\nplt.xticks(np.arange(1,layer+1))\nplt.title(\"Minimum Distance as a function of no. of layers\")\nplt.show()\n\n","ecffe720":"# plots he maximum iterations used as a function of no. of layers in the specific circuit\nplt.plot(np.arange(1,layer+1),iter_list, \"g\")\nplt.ylabel(\"Iteration used\")\nplt.xlabel(\"No. of layers\")\nplt.xticks(np.arange(1,layer+1))\nplt.title(\"Total no. of iterations used as a function of no. of layers\")\nplt.show()","4dd6b47f":"# plots he maximum iterations used as a function of no. of layers in the specific circuit\nplt.plot(np.arange(1,layer+1),time_list, \"g\")\nplt.ylabel(\"Time taken to optimize\")\nplt.xlabel(\"No. of layers\")\nplt.xticks(np.arange(1,layer+1))\nplt.title(\"Time taken to optimize as a function of no. of layers\")\nplt.show()","59ae466b":"# No. of Layers in the circuit = 6","a6fd3c8b":"# Plot of iteration as a function of no. of layers used in the circuit\n\n## Although we have specified the no. of iterations while calling the optimize() function, but due the callback, earlystopping has occured in almost all cases. \n## The no. of iteration used has also been placed as a function of layers in the circuit\n## Although their is no intuition has been achieved from the plot, from 7 upto 12 we can observe decrement in iteration, except in the case 9-10","9548aaa1":"# No. of Layers in the circuit = 12","18c237ac":"## initialize_random_phi()\n#### Arguments - no args is passed\n#### as the phi is used as reference with the circuit output, it returns an numpy array having same dimension of statevector returned by the circuit\n#### Since the circuit has 4 wires, statevector will have 2^4 or 16 elements","fe7d2a08":"# No. of Layers in the circuit = 7","2a644f6b":"# No. of Layers in the circuit = 5","5fa753b4":"## optimize()\n#### Arguments - np array of all parameters, maximum no. of iteration used and two optional boolean parameters- print_distance, plot_distance\n#### *Imp. point to note - although iteration is passed as a parameter in the function, but there is a callback used below, which terminates the optimization when three consecutive calculated distance is same(upto 2 decimal places) considering the fact that minimum distance has been achieved*\n#### the RotosolveOptimizer available in pennylane has been used here to optimize the parameters to get the minimum distance for each circuit\n#### while calling the function, is print_distance is set as True, it prints the distance calculated in each iteration\n#### if the plot_distance is also set True, it will plot the calculated distance vs iteration after the optimization of a specific circuit is completed\n#### Returns - a dict containing minimum_distance calculated after the optimization, no. of iteration used and optimized parameters value","64ee1180":"## simulate_circuit()\n#### Arguments - the numpy array containing all the parameters for each gate\n#### Creates a object of device class using required attributes\n#### calls the circuit() function defined inside it to generate the specific circuit using paramaters passed\n#### Return - returns the output statevector of the simulated circuit using dev.state","1bba8ca3":"# Final Plot - Plot of Minimum distance as a function of no. of layers used in the circuit\n\n# Points to observe - \n## 1. In the plot below, starting from the circuit having 7 layers, upto the last i.e. 12 layers, the minimum distance has become same almost\n## 2. Also from a specific circuit to the next circuit, minimum distance has been decreased except in the case of circuit with 5 layers to circuit with 6","58dabf18":"# No. of Layers in the circuit = 9","80e95fc2":"## The block below executes to do all the necessary imports","ac9dd5f5":"## initialize_theta()\n#### Arguments - only a single arg, no. of layers in the circuit\n#### It randomly generates a numpy array having (layers X 2) no. of rows and 4 columns\n#### Each element in the np array is a theta value for a parameterized gate ranging from (0,2pi)\n#### Return - numpy array","0874153b":"# No. of Layers in the circuit = 11","013d89be":"# **Task-1**\n\n### Information about this notebook\n\n##### 1. Optimization has been done starting from circuit with 1 layer upto circuit with 12 layers.\n##### 2. For Each circuit with specific no. of layers, distance calculated in each iteration has been printed and plotted also.\n##### 3. Finally the minimum distance in the circuit has been plotted as a function of no. of layers used in that circuit.\n##### 4. Also the no. of iteration used and the time taken for optimization is also plotted as a function of no. of layers.\n\n### Note - In this notebook seperate cells has been dedicated for each circuit and finally in the last part, information like minimum distance from all circuits has been put together and plotted. \n### In the another notebook, all the circuits has been put together by looping over the no. of layers, and finally overall plots has been shown (no seperate plot for each circuit has been shown there). ","55a95040":"# No. of Layers in the circuit = 8","56e679da":"## Four lists initialized below will store various data returned by each circuit simulated.\n\n## simulate()\n#### Argument - a single argument, which is the no. of layers used in the quantum circuit\n#### initializes random parameters, calls the optimize function to optimize the parameters to get minimum value of distance\n#### finally prints some information about circuit after optimization - minimum distance, no. of iteration used and time taken for the optimization\n#### *also print_distance, plot_distance parameter being True while calling the optimize function, distance at each step of iteration and a plot showing overall decrement in distance will also be printed*\n#### Returns nothing","587dd34f":"# No. of Layers in the circuit = 3","258384fd":"# No. of Layers in the circuit = 10","37ca11c2":"# No. of Layers in the circuit = 4","4266a8e8":"## calc_distance()\n#### Arguments - takes only the numpy array containing parameters for all parameterized gates in the circuit\n#### it calls the function simulate_circuit(), which returns the statevector psi_of_theta\n#### now it calculates the difference of psi_of_theta and phi (phi has been initialized globally and used the same for all the circuit in this notebook)\n#### Finally the sum of square of mod of all 16 complex numbers has been calculated \n#### Return - a single float value which is calculated, mentioned above","5f1931d7":"# No. of Layers in the circuit = 1","4032edcb":"# Plot of Time taken to optimize as a function of no. of layers used in the circuit\n\n## It is obvious that with incresing the no. of parameterized gates in the circuit, time taken for optimization will also be increasing.","c835f9fe":"## The below cell initializes the phi globally, which will be used as a referrence for the statevector returned by each circuit by calculating the distance w.r.t phi","a17961ad":"# No. of Layers in the circuit = 2"}}