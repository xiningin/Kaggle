{"cell_type":{"a7eba4cd":"code","a7c8a07c":"code","abaeed8f":"code","c63e3006":"code","5c21f311":"code","ae1defd2":"code","48ea5f9c":"code","4bf4655d":"code","6b87efe4":"code","c3385afc":"code","3425a71d":"markdown","b7481b67":"markdown","143eda7a":"markdown","51d3c5b3":"markdown","b2f568d2":"markdown","70dcce97":"markdown","a1c8fcf1":"markdown","60f3451d":"markdown"},"source":{"a7eba4cd":"import numpy as np\nimport pandas as pd\nimport numba\nfrom sympy import isprime, primerange\nfrom math import sqrt\nfrom sklearn.neighbors import KDTree\nfrom tqdm import tqdm\nfrom itertools import combinations","a7c8a07c":"cities = pd.read_csv('..\/input\/traveling-santa-2018-prime-paths\/cities.csv', index_col=['CityId'])\nXY = np.stack((cities.X.astype(np.float32), cities.Y.astype(np.float32)), axis=1)\nis_not_prime = np.array([0 if isprime(i) else 1 for i in cities.index], dtype=np.int32)","abaeed8f":"@numba.jit('f8(i8, i8, i8)', nopython=True, parallel=False)\ndef cities_distance(offset, id_from, id_to):\n    xy_from, xy_to = XY[id_from], XY[id_to]\n    dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n    distance = sqrt(dx * dx + dy * dy)\n    if offset % 10 == 9 and is_not_prime[id_from]:\n        return 1.1 * distance\n    return distance\n\n\n@numba.jit('f8(i4, i8[:])', nopython=True, parallel=False)\ndef score_chunk(offset, chunk):\n    pure_distance, penalty = 0.0, 0.0\n    penalty_modulo = 9 - offset % 10\n    for path_index in numba.prange(chunk.shape[0] - 1):\n        id_from, id_to = chunk[path_index], chunk[path_index+1]\n        xy_from, xy_to = XY[id_from], XY[id_to]\n        dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n        distance = sqrt(dx * dx + dy * dy)\n        pure_distance += distance\n        if path_index % 10 == penalty_modulo and is_not_prime[id_from]:\n            penalty += distance\n    return pure_distance + 0.1 * penalty\n\n\n@numba.jit('f8(i8[:])', nopython=True, parallel=False)\ndef score_path(path):\n    return score_chunk(0, path)","c63e3006":"kdt = KDTree(XY)","5c21f311":"pairs = set()\nfor city_id in tqdm(cities.index):\n    dists, neibs = kdt.query([XY[city_id]], 31)\n    for neib_id in neibs[0][1:]:\n        if city_id and neib_id:  # skip pairs that include starting city \n            pairs.add(tuple(sorted((city_id, neib_id))))\n    neibs = kdt.query_radius([XY[city_id]], 31, count_only=False, return_distance=False)\n    for neib_id in neibs[0]:\n        if city_id and neib_id and city_id != neib_id:\n            pairs.add(tuple(sorted((city_id, neib_id))))\n\nprint(f'{len(pairs)} cities pairs are selected.')\n# sort pairs by distance\npairs = np.array(list(pairs))\ndistances = np.sum((XY[pairs.T[0]] - XY[pairs.T[1]])**2, axis=1)\norder = distances.argsort()\npairs = pairs[order]","ae1defd2":"path = np.array(pd.read_csv('..\/input\/traveling-santa-lkh-solution\/pure1502650.csv').Path)\ninitial_score = score_path(path)","48ea5f9c":"path_index = np.argsort(path[:-1])\n\ntotal_score = initial_score\nprint(f'Total score is {total_score:.2f}.')\nfor _ in range(3):\n    for step, (id1, id2) in enumerate(tqdm(pairs), 1):\n        if step % 10**6 == 0:\n            new_total_score = score_path(path)\n            print(f'Score: {new_total_score:.2f}; improvement over last 10^6 steps: {total_score - new_total_score:.2f}; total improvement: {initial_score - new_total_score:.2f}.')\n            total_score = new_total_score\n        i, j = path_index[id1], path_index[id2]\n        i, j = min(i, j), max(i, j)\n        chunk, reversed_chunk = path[i-1:j+2], np.concatenate([path[i-1:i], path[j:i-1:-1], path[j+1:j+2]])\n        chunk_score, reversed_chunk_score = score_chunk(i-1, chunk), score_chunk(i-1, reversed_chunk)\n        if j - i > 2:\n            chunk_abc = np.concatenate([path[i-1:i+1], path[j:i:-1], path[j+1:j+2]])\n            chunk_acb = np.concatenate([path[i-1:i], path[j:j+1], path[i:j], path[j+1:j+2]])\n            chunk_abcb = np.concatenate([path[i-1:i+1], path[j:j+1], path[i+1:j], path[j+1:j+2]])\n            abc_score, acb_score, abcb_score = map(lambda chunk: score_chunk(i-1, chunk), [chunk_abc, chunk_acb, chunk_abcb])\n            for chunk, score, name in zip((chunk_abc, chunk_acb, chunk_abcb), (abc_score, acb_score, abcb_score), ('abc', 'acb', 'abcb')):\n                if score < chunk_score:\n                    path[i-1:j+2] = chunk\n                    path_index = np.argsort(path[:-1])  # update path index\n                    chunk_score = score\n        if reversed_chunk_score < chunk_score:\n            path[i-1:j+2] = reversed_chunk\n            path_index = np.argsort(path[:-1])  # update path index","4bf4655d":"print(f'Total improvement is {initial_score - total_score:.2f}.')","6b87efe4":"def make_submission(name, path):\n    pd.DataFrame({'Path': path}).to_csv(f'{name}.csv', index=False)","c3385afc":"make_submission(score_path(path), path)","3425a71d":"4. Precompute close cities pairs using KDTree.","b7481b67":"I'm going to feed a better initial tour found by [LKH](http:\/\/akira.ruc.dk\/~keld\/research\/LKH-3\/) on my local machine to [my previous kernel](https:\/\/www.kaggle.com\/kostyaatarik\/close-ends-chunks-optimization-aka-2-opt).","143eda7a":"2. Read input data and define some arrays that we'll need later.","51d3c5b3":"5. Load the initial path to start optimization from. I'll use the one with a pure score of 1502650 found by [LKH](http:\/\/akira.ruc.dk\/~keld\/research\/LKH-3\/) on my local machine.","b2f568d2":"7. Save the result path.","70dcce97":"3. Define fast scoring functions using numba.","a1c8fcf1":"1. Import all that we need.","60f3451d":"6. Use optimization described in [my previous kernel](https:\/\/www.kaggle.com\/kostyaatarik\/close-ends-chunks-optimization-aka-2-opt)."}}