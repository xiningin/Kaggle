{"cell_type":{"cc4852a4":"code","1e60fe6b":"code","55d402d8":"code","63d8da1a":"code","03e0c7aa":"code","bacf17aa":"code","1df23838":"code","a622516e":"code","910d066e":"code","033b4576":"code","00b7a99e":"code","ca960bc3":"code","1af428c7":"code","18bb0e82":"code","dd4651ed":"code","838ad812":"code","02109d6c":"markdown"},"source":{"cc4852a4":"!pip uninstall -y kaggle\n!pip install --upgrade pip\n!pip install kaggle==1.5.6","1e60fe6b":"! mkdir -p ~\/.kaggle\n! cp kaggle.json ~\/.kaggle\/\n! chmod 600 ~\/.kaggle\/kaggle.json\n! kaggle -v","55d402d8":"!kaggle competitions download -c music-genres-classification\n!unzip music-genres-classification.zip","63d8da1a":"import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader\n\nimport torchvision\nimport torchvision.transforms as transforms","03e0c7aa":"device = 'cuda' if torch.cuda.is_available() else 'cpu'\n\ntorch.manual_seed(777)\nif device =='cuda':\n    torch.cuda.manual_seed_all(777)","bacf17aa":"trans = transforms.Compose([\n    transforms.ToTensor() #\ud559\uc2b5\uc744 \uc704\ud574 dataset\ub4e4\uc744 \ud150\uc11c\ub85c \uc804\ud658\n])\n\ntrain_data = torchvision.datasets.ImageFolder(root='\/content\/train',transform=trans)\ntest_data = torchvision.datasets.ImageFolder(root='\/content\/test', transform=trans)","1df23838":"batch_size = 7\ndata_loader = DataLoader(dataset = train_data, \n                         batch_size = batch_size, \n                         shuffle = True, \n                         num_workers=2, # \ub370\uc774\ud130\ub97c \ube68\ub9ac \uc77d\uc5b4\uc624\uae30 \uc704\ud55c\uac83\n                         drop_last=True)","a622516e":"linear1 = torch.nn.Linear(3*784,784,bias=True) #input 3*28*28\nlinear2 = torch.nn.Linear(784,512,bias=True)\nlinear3 = torch.nn.Linear(512,512,bias=True)\nlinear4 = torch.nn.Linear(512,512,bias=True) #output 10 class\nlinear5 = torch.nn.Linear(512,10,bias=True)\n#linear6 = torch.nn.Linear(512,10,bias=True)\nrelu = torch.nn.ReLU() \ndropout = torch.nn.Dropout(p=0.3)","910d066e":"torch.nn.init.xavier_uniform_(linear1.weight)\ntorch.nn.init.xavier_uniform_(linear2.weight)\ntorch.nn.init.xavier_uniform_(linear3.weight)\ntorch.nn.init.xavier_uniform_(linear4.weight)\ntorch.nn.init.xavier_uniform_(linear5.weight)\n#torch.nn.init.xavier_uniform_(linear6.weight)","033b4576":"model = torch.nn.Sequential(linear1,relu,dropout,\n                            linear2,relu,dropout,\n                            linear3, relu,dropout,\n                            linear4,relu,dropout,\n                            linear5\n                            #linear6\n                            ).to(device)","00b7a99e":"loss = torch.nn.CrossEntropyLoss().to(device) \noptimizer = torch.optim.Adamax(model.parameters(), lr=0.1)","ca960bc3":"total_batch = len(data_loader)\n#model.train()\nfor epoch in range(100):\n    avg_cost = 0\n\n    for X, Y in data_loader:\n\n       \n        #print(X.shape) #\ud150\uc11c\uc758 \ud06c\uae30\ub97c \uc904\uc5ec\uc90c\n        X = X.view(-1, 3*28 * 28).to(device)\n        # one-hot encoding\ub418\uc5b4 \uc788\uc9c0 \uc54a\uc74c\n        Y = Y.to(device)\n      \n        optimizer.zero_grad()\n        hypothesis = model(X) #forward \uacc4\uc0b0\n        cost = loss(hypothesis, Y) #cost\n        cost.backward() #backpropagation\n        optimizer.step() #\uac31\uc2e0\n\n        avg_cost += cost \/ total_batch #\ud3c9\uade0 error\n    if epoch % 50==0:\n        print('Epoch:', '%04d' % (epoch + 1), 'cost =', '{:.9f}'.format(avg_cost))\n\nprint('Learning finished')","1af428c7":"test_set = DataLoader(dataset = test_data, \n                      batch_size = len(test_data),\n                      shuffle=False)","18bb0e82":"with torch.no_grad():\n  \n    for num, data in enumerate(test_set):\n        imgs, label = data\n        imgs = imgs.view(-1,3* 28 * 28).to(device)\n        label = label.to(device)\n        \n        prediction = model(imgs)\n        \n        correct_prediction = torch.argmax(prediction, 1) == label\n        \n        accuracy = correct_prediction.float().mean()\n        print('Accuracy:', accuracy.item())","dd4651ed":"prediction= prediction.cpu().data.numpy().reshape(-1,1)","838ad812":"submit=pd.read_csv('submition_form.csv')\n\nfor i in range(len(prediction)):\n  submit['label'][i]=int(prediction[i])\nsubmit['label']=submit['label'].astype(int)  \n\nsubmit.to_csv('baseline.csv',index=False,header=True)","02109d6c":"kaggle competitions submit -c music-genres-classification -f baseline.csv -m \"submit\""}}