{"cell_type":{"37150bf2":"code","a0b9db19":"code","496de9dc":"code","49d75a80":"code","2bd208cc":"code","c90b6367":"code","71bb472f":"code","ef494b70":"code","0d6ddc66":"code","1ad50fd0":"code","3dd23f8e":"code","237fc010":"code","963d1475":"code","2461b85a":"code","3aaa35da":"code","913946af":"code","d4eb2be2":"code","6d60dff6":"markdown","d72e63f2":"markdown","6f18323e":"markdown","50a917c6":"markdown","8c1a194c":"markdown"},"source":{"37150bf2":"import matplotlib as mlp\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\nfrom sklearn.gaussian_process import GaussianProcessClassifier, GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF, ConstantKernel as C\nimport numpy as np\n%matplotlib inline","a0b9db19":"plt.style.use('classic')","496de9dc":"x = np.linspace(0, 10, 1000)","49d75a80":"plt.plot(x, np.sin(x))\nplt.plot(x, np.cos(x))\nplt.show()","2bd208cc":"fig = plt.figure()\nplt.plot(x, np.sin(x), '-')\nplt.plot(x, np.cos(x), '--')\nplt.show()","c90b6367":"plt.figure()\nplt.subplot(2, 1, 1)\nplt.plot(x, np.sin(x))\nplt.subplot(2, 1, 2)\nplt.plot(x, np.cos(x))\nplt.show()","71bb472f":"fig, ax = plt.subplots(2)\nax[0].plot(x, np.sin(x))\nax[1].plot(x, np.cos(x))\nplt.show()","ef494b70":"fig = plt.figure()\nax = plt.axes()\nx = np.linspace(0, 10, 1000)\nax.plot(x, np.sin(x))\nplt.plot(x, np.sin(x))\nplt.show()","0d6ddc66":"plt.plot(x, np.sin(x-0), color = 'blue')\nplt.plot(x, np.sin(x-1), color = 'g')\nplt.plot(x, np.sin(x-2), color = '0.75')\nplt.plot(x, np.sin(x-3), color = '#FFDD44')\nplt.plot(x, np.sin(x-4), color = 'red')\nplt.plot(x, np.sin(x-5), color = 'green')\nplt.plot(x, np.sin(x-6), color = 'blue')\nplt.plot(x, np.sin(x-7), color = 'black')\nplt.plot(x, np.sin(x-8), color = (1.0, 0.2, 0.3))\nplt.plot(x, np.sin(x-9), color = 'chartreuse')","1ad50fd0":"plt.plot(x, x+0, linestyle = 'solid')\nplt.plot(x, x+1, linestyle = 'dashed')\nplt.plot(x, x+2, linestyle = 'dashdot')\nplt.plot(x, x+3, linestyle = 'dotted')\n\nplt.plot(x, x+4, linestyle = '-')\nplt.plot(x, x+5, linestyle = '--')\nplt.plot(x, x+6, linestyle = '-.')\nplt.plot(x, x+7, linestyle = ':')","3dd23f8e":"rng = np.random.RandomState(0)\nfor marker in ['o','x', '.', '+','v', '^', 's', 'd']:\n    plt.plot(rng.rand(5), rng.rand(5), marker,\n            label = \"'marker={0}'\".format(marker))","237fc010":"x = np.linspace(0, 10, 30)\ny = np.sin(x)\nplt.plot(x, y, '-p', color = 'gray',\n        markersize = 15, linewidth = 4,\n        markerfacecolor = 'white',\n        markeredgecolor = 'gray',\n        markeredgewidth=2)\nplt.ylim(-1.2, 1.2)","963d1475":"rng = np.random.RandomState(0)\nx = rng.randn(100)\ny = rng.randn(100)\ncolors = rng.randn(100)\nsizes = 1000 * rng.randn(100)\nplt.scatter(x, y, c = colors, s = sizes, alpha=0.3, cmap = 'viridis')\nplt.colorbar()","2461b85a":"dataset = load_iris()\nfeatures = dataset.data.T\nplt.scatter(features[0], features[1], alpha=0.2,\n           s = 100*features[3], c= dataset.target, cmap = 'viridis')\nplt.xlabel(dataset.feature_names[0])\nplt.ylabel(dataset.feature_names[1])\nplt.show()","3aaa35da":"plt.figure(figsize=(10, 8))\nplt.style.use('seaborn-whitegrid')\nx = np.linspace(0, 10, 50)\ndy = 0.8\ny = np.sin(x) + np.random.randn(50)\nplt.errorbar(x, y, yerr = dy, fmt = '.k')\nplt.tight_layout()\nplt.show()","913946af":"plt.figure(figsize=(10, 8))\nplt.style.use('seaborn-whitegrid')\nx = np.linspace(0, 10, 50)\ndy = 0.8\ny = np.sin(x) + np.random.randn(50)\nplt.errorbar(x, y, yerr = dy, fmt = 'o', color = 'blue',\n            ecolor = 'red', elinewidth=3, capsize = 0)\nplt.tight_layout()\nplt.show()","d4eb2be2":"def f(x):\n    \"\"\"The function to predict.\"\"\"\n    return x * np.sin(x)\n\n# ----------------------------------------------------------------------\n#  First the noiseless case\nX = np.atleast_2d([1., 3., 5., 6., 7., 8.]).T\n\n# Observations\ny = f(X).ravel()\n\n# Mesh the input space for evaluations of the real function, the prediction and\n# its MSE\nx = np.atleast_2d(np.linspace(0, 10, 1000)).T\n\n# Instantiate a Gaussian Process model\nkernel = C(1.0, (1e-3, 1e3)) * RBF(10, (1e-2, 1e2))\ngp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)\n\n# Fit to data using Maximum Likelihood Estimation of the parameters\ngp.fit(X, y)\n\n# Make the prediction on the meshed x-axis (ask for MSE as well)\ny_pred, sigma = gp.predict(x, return_std=True)\n\n# Plot the function, the prediction and the 95% confidence interval based on\n# the MSE\nplt.figure()\nplt.plot(x, f(x), 'r:', label=r'$f(x) = x\\,\\sin(x)$')\nplt.plot(X, y, 'r.', markersize=10, label='Observations')\nplt.plot(x, y_pred, 'b-', label='Prediction')\nplt.fill(np.concatenate([x, x[::-1]]),\n         np.concatenate([y_pred - 1.9600 * sigma,\n                        (y_pred + 1.9600 * sigma)[::-1]]),\n         alpha=.5, fc='b', ec='None', label='95% confidence interval')\nplt.xlabel('$x$')\nplt.ylabel('$f(x)$')\nplt.ylim(-10, 20)\nplt.legend(loc='upper left')","6d60dff6":"#### Basic Errorbars","d72e63f2":"### Continuous Errors","6f18323e":"#### MATLAB - style Interface","50a917c6":"### Setting Style\nWe will use the plt.style directive to choose appropriate aesthetic styles for our figures. Here we will set the classic style, which ensure that the plots we create use the classic matplotlib style.","8c1a194c":"#### Object Oriented interface"}}