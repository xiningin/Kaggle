{"cell_type":{"ada9e0ab":"code","ce843e1e":"code","a9e66490":"code","a398db6e":"code","fbb282d2":"code","12879142":"markdown","91999c27":"markdown","4af59d36":"markdown","eed5ccf8":"markdown","9cde2abe":"markdown"},"source":{"ada9e0ab":"#imports\nimport numpy as np\nimport pandas as pd\nimport random, tqdm\nfrom matplotlib import pyplot as plt\n\ndef polygon(length, angle=0, center=(100, 100), n_sides=6):\n    coordinates = []\n    for n in range(n_sides):\n        x = length * np.cos(2*np.pi*n\/n_sides + angle) + center[0]\n        y = length * np.sin(2*np.pi*n\/n_sides + angle) + center[1]\n        coordinates.append((x, y))\n    coordinates.append(coordinates[0])\n    return coordinates\n        \nvertices = polygon(100)\n\nx = np.array([i[0] for i in vertices])\n\ny = np.array([i[1] for i in vertices])\n\nprint(vertices)\nplt.plot(x, y)","ce843e1e":"def euclidean_distance(x0, x1, y0, y1):\n    return round(np.sqrt((x0-x1)**2 + (y0-y1)**2), 4)\n\nfor i in range(len(vertices)):\n    if i == len(vertices)-1:\n        continue\n    distance = euclidean_distance(vertices[i][0], vertices[i+1][0], vertices[i][1], vertices[i+1][1])\n    print(f'distance of vertex {i} from vertex {i+1} is: {distance}')","a9e66490":"def random_point(x, y, boundary=30):\n    x_min, x_max = np.min(x)+boundary, np.max(x)-boundary\n    y_min, y_max = np.min(y)+boundary, np.max(y)-boundary\n    P_x = np.random.randint(x_min, x_max)\n    P_y = np.random.randint(y_min, y_max)\n    return P_x, P_y\n\ndef validate_vertex_idx(x, y, v_idx):\n    rand_idx = random.choice(list(enumerate(y)))[0]\n    while True:\n        if euclidean_distance(x[v_idx], x[rand_idx], y[v_idx], y[rand_idx]) != distance:\n            rand_idx = random.choice(list(enumerate(y)))[0]\n        else:\n            break\n    return rand_idx\n\nrand_idx = validate_vertex_idx(x, y, -1)\n\nP_x, P_y = random_point(x, y)\n        \nx_new, y_new = np.append(x, P_x), np.append(y, P_y)\n\nx_new, y_new = np.append(x_new, x[rand_idx]), np.append(y_new, y[rand_idx])\n\nprint(f'P: {(P_x, P_y)}')\n\nplt.plot(x_new, y_new)","a398db6e":"def vertices(x, y):\n    v_1_rand_idx = random.choice(list(enumerate(x)))[0]\n    v_1 = x[v_1_rand_idx], y[v_1_rand_idx]\n    v_2_rand_idx = validate_vertex_idx(x, y, v_1_rand_idx)\n    v_2 = x[v_2_rand_idx], y[v_2_rand_idx]\n    return v_1, v_2\n\n\ncentroids = []\n\nfor i in tqdm.tqdm(range(10000)):\n    v_1, v_2 = vertices(x, y)\n    P = (P_x, P_y)\n    x_vals = np.array([v_1[0], v_2[0], P[0]])\n    y_vals = np.array([v_1[1], v_2[1], P[1]])\n    centroid = np.sum(x_vals)\/3, np.sum(y_vals)\/3\n    centroids.append(centroid)\n    P = centroid","fbb282d2":"x_centroids = np.array([i[0] for i in centroids])\n\ny_centroids = np.array([i[1] for i in centroids])\n\nplt.plot(x_centroids, y_centroids)","12879142":"<p>P is randomly connected to two adjacent vertices of the hexagon selected in the *vertices()* function to form a triangle who's centroid will be computed<br>\nWe also ensure that the two vertices being randomly selected are not the same.<\/p>\n<br>\n\n<p>The computed centroids will be stored in the *centroids* list and the new P will be saved as the new immediate centroid.<\/p>\n<br>\nThis process will be done for 10,000 iterations.","91999c27":"<p>The *polygon()* function generates vertices of an n-sided polygon who's center, orientation angle and length of sides is given<\/p>","4af59d36":"The Centroids stored up from the 10,000 iterations are then plotted","eed5ccf8":"<p>A random point vertice P is selected inside the boundaries of the hexagon with the *random_point()* function and plotted alognside the hexagon for visualization<\/p>\n<br>\n<p>The *validate_vertex_idx()* function matches a valid second vertex with the 1st random vertex selected so the vertices P and the two selected vertices will form a triangle.<\/p>","9cde2abe":"<p> The *euclidean_distance()* method computes the euclidean distance between consective vertices to verify if the polygon generated is equilateral and satisfies conditions of a regular polygon<\/p>"}}