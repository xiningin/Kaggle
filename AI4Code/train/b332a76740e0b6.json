{"cell_type":{"58cfead5":"code","22a4525f":"code","bb1147a1":"code","f3291abe":"code","4ff2071e":"code","e8ed08e9":"code","800c063c":"code","54d7716a":"code","38ae6eac":"code","7a947461":"code","9473fb4a":"code","24f6569e":"code","4c674daa":"code","f0df9cc7":"code","d3f67843":"code","ca8397cb":"code","07aa4277":"code","1aabf6ea":"code","fbe34015":"code","6baecba3":"code","b4903a50":"code","dea84fc3":"code","a772b5c5":"code","be6a8509":"code","5ef5b6ef":"markdown","35a44c6a":"markdown","48990abf":"markdown","5054f6f3":"markdown","8fbd0364":"markdown","e63f4f46":"markdown","33e7a041":"markdown","f0d4547e":"markdown","02fc7d8d":"markdown","39c5c138":"markdown","3686ccec":"markdown","6855634b":"markdown","01079e8d":"markdown","a67e226d":"markdown","50d4d034":"markdown","9447c270":"markdown","7203a183":"markdown","d02ef2b5":"markdown","7ab30535":"markdown","fa400f61":"markdown","e9ea83cc":"markdown","0e374d6a":"markdown"},"source":{"58cfead5":"import os                            # library to use operation system functions like `ls`, `mv` and so on.\nimport numpy as np                   # library to manipulate matrices\nimport rasterio as rio               # library to manipulate raster data (Loaded with the alias `rio`)          \nimport geopandas as gpd              # library to manipulate vector data (Loaded with the alias `gpd`)\n\nimport rasterio.mask as rio_mask     # module to crop raster data (Loaded with the alias `rio_mask`)\n\nfrom rasterio.windows import Window   # class to create windows to manipulate raster data\nfrom rasterio.enums import Resampling # enum with resampling methods supported by rasterio\n\nfrom math import pi","22a4525f":"def resampling(image_path, image_out_path, cell_size):\n    \"\"\"Resampling image\n    \n    Args:\n        image_path (str): Path to the image to be resampled\n        \n        image_out_path (str): Path to the file where the resampled image will be saved\n        \n        cell_size (int): spatial resolution\n    Returns:\n        str: Path to where the resampled image is saved\n    \"\"\"\n    with rio.open(image_path) as dataset:\n        \n        scale_factor = dataset.meta[\"transform\"].a \/ cell_size\n\n        # resample data to target shape\n        data = dataset.read(\n            out_shape=(\n                dataset.count,\n                int(dataset.height * scale_factor),\n                int(dataset.width * scale_factor)\n            ),\n            resampling=Resampling.bilinear\n        )\n\n        # scale image transform\n        transform = dataset.transform * dataset.transform.scale(\n            (dataset.width \/ data.shape[-1]),\n            (dataset.height \/ data.shape[-2])\n        )\n        \n        out_meta = dataset.meta.copy()        \n        out_meta.update({\n            \"driver\": \"GTiff\",\n            \"height\": data.shape[1],\n            \"width\": data.shape[2],\n            \"transform\": transform\n        })\n        \n        out_image = rio.open(image_out_path, \"w\", **out_meta)\n        out_image.write(data)\n        \n        return image_out_path","bb1147a1":"def rrs_image(image_path, output_path):\n    with rio.open(image_path, \"r\") as image_src:\n\n        image_arr = image_src.read()\n        image_arr_rrs = image_arr \/ pi\n\n        # generating output file metadata\n        metadata = image_src.meta\n        metadata[\"dtype\"] = str(image_arr.dtype)\n\n        with rio.open(output_path, \"w\", **metadata) as image_dst:\n            image_dst.write(image_arr_rrs)\n    return output_path","f3291abe":"def crop_image_by_shapefile(image_path, shapefile, output_file_path):\n    \"\"\"Crop image by shapefile\n    \n    Args:\n        image_path (str): Path to the image that will be cropped\n        \n        shapefile (geopandas.GeoDataFrame): GeoDataFrame with the geometries used to crop the image.\n\n        output_file_path (str): Path where cropped image will be saved\n        \n    Returns:\n        str: Path where cropped image is saved\n    \"\"\"\n    # load shapefile\n    shapefile = shapefile.copy()\n\n    with rio.open(image_path) as image_src:\n        shapefile = shapefile.to_crs(image_src.crs)\n        polygon_geometry = [\n            gpd.GeoSeries(\n                shapefile.unary_union).__geo_interface__[\"features\"][0][\"geometry\"]\n        ]\n\n        out_image, out_transform = rio_mask.mask(image_src, polygon_geometry, crop=True)\n        out_meta = image_src.meta\n\n        # defining output informations\n        out_meta.update({\"driver\": \"GTiff\",\n                         \"height\": out_image.shape[1],\n                         \"width\": out_image.shape[2],\n                         \"transform\": out_transform,\n                         \"nodata\": -9999})\n\n        # convert to input type and write file\n        with rio.open(output_file_path, \"w\", **out_meta) as dest:\n            dest.write(out_image.astype(out_meta[\"dtype\"]))\n\n    return output_file_path","4ff2071e":"def model_1(B4, B5, B6):\n    \"\"\"Function to estimate chla using the Gitelson et al. (2011) model.\n    \n    Args:\n        B4 (numpy.array): Array with the band 4 values that will be used as input to Gitelson et al. (2011) model.\n        \n        B5 (numpy.array): Array with the band 5 values that will be used as input to Gitelson et al. (2011) model.\n\n        B6 (numpy.array): Array with the band 6 values that will be used as input to Gitelson et al. (2011) model.\n        \n    Returns:\n        numpy.array: chla estimated by Gitelson et al. (2011) model.\n    \"\"\"\n    chla = (74.35 * ((1\/B4 - 1\/B5)*B6)) + 13.31\n    return chla","e8ed08e9":"def model_2(B4, B5):\n    \"\"\"Function to estimate chla using the Mishra & Mishra (2010) model.\n    \n    Args:\n        B4 (numpy.array): Array with the band 4 values that will be used as input to Mishra & Mishra (2010) model.\n        \n        B5 (numpy.array): Array with the band 5 values that will be used as input to Mishra & Mishra (2010) model.       \n    Returns:\n        numpy.array: chla estimated by Mishra & Mishra (2010) model.\n    \"\"\"\n    chla = 30.67 * np.exp(5682.47*((B5-B4)\/(705-665)))\n    return chla","800c063c":"#\n# B5\/B3 - model_3 up to 600\n#\ndef model_3_600(B3, B5):\n    \"\"\"Function to estimate chla using the band ratio B5\/B3 model.\n    \n    Args:\n        B3 (numpy.array): Array with the band 3 values.\n        \n        B5 (numpy.array): Array with the band 5 values.       \n    Returns:\n        numpy.array: chla estimated with the band ratio B5\/B3 model.\n    \"\"\"\n    \n    chla = 4.66 * np.exp(3.53*(B5\/B3))\n    return chla\n\n#\n# B6\/B3 - model_3 up to 1000\n#\ndef model_3_1000 (B3, B6):\n    \"\"\"Function to estimate chla using the band ratio B6\/B3 model.\n    \n    Args:\n        B3 (numpy.array): Array with the band 3 values.\n        \n        B6 (numpy.array): Array with the band 6 values.       \n    Returns:\n        numpy.array: chla estimated with the band ratio B6\/B3 model.\n    \"\"\"\n    chla = (-157.72*((B6\/B3)**2))+(810.11*(B6\/B3)) - 199.10\n    return chla","54d7716a":"def OHA_function(band_3, band_4, band_5, band_6, model_3 = model_3_600):\n    \"\"\"Function to calculate the OHA estimative.\n    \n    Args:\n        band_3 (numpy.array): Array with the band 3 values that will be used as input to OHA.\n\n        band_4 (numpy.array): Array with the band 4 values that will be used as input to OHA.\n        \n        band_5 (numpy.array): Array with the band 5 values that will be used as input to OHA.\n        \n        band_6 (numpy.array): Array with the band 6 values that will be used as input to OHA.\n        \n        model_3 (Callable): In OHA, model 3, used to estimate `high eutrophication conditions`, can be changed to consider \n        values up to 600 or 1000 mg\/m3. To allow the modification of the model 3, \n        this parameter can receive as input the functions `model_3_600` and `model_3_1000`, which represent respectively \n        model 3 for each of the mentioned ranges (Default is `model_3_600`).\n        \n    Returns:\n        Tuple (numpy.array, numpy.array): Tuple with the classes and estimative rasters.\n    \"\"\"\n    \n    # Establishing a rule: all bands must have the same dimensions. If not: error message!\n    if band_3.shape != band_4.shape != band_5.shape != band_6.shape:\n        raise ValueError(\"The input dimensions must be the same for all matrices!\")\n        \n    # Calculating the band ratio for the decision tree\n    band_ratio_5_4 = band_5 \/ band_4\n    \n    # Creating output matrices\n    classes = np.zeros(band_5.shape)\n    estimative = np.zeros(band_5.shape)\n    \n    # Iterating on raster pixels\n    matrix_shape = band_3.shape\n    \n    for row in range(matrix_shape[0]):\n        for column in range(matrix_shape[1]):\n            \n            band_3_value = band_3[row, column]\n            band_4_value = band_4[row, column]\n            band_5_value = band_5[row, column]\n            band_6_value = band_6[row, column]\n            \n            band_ratio_5_4_value = band_ratio_5_4[row, column]\n            \n            if band_ratio_5_4_value <= 1.206:\n                classes[row, column] = 1\n                estimative[row, column] = model_1(band_4_value, band_5_value, band_6_value)\n            \n            else:\n                if band_ratio_5_4_value <= 2.047:\n                    classes[row, column] = 2\n                    estimative[row, column] = model_2(band_4_value, band_5_value)\n                else:\n                    classes[row, column] = 3\n                    estimative[row, column] = model_3(band_3_value, band_5_value)\n\n    return (classes, estimative)","38ae6eac":"#\n# Output Resampled Bands\n#\noutput_resampled = \"Output_Data\/Resampled\"\nos.makedirs(output_resampled, exist_ok=True)\n\n#\n# Output Class Maps\n#\noutput_class_map = \"Output_Data\/Class_Map\"\nos.makedirs(output_class_map, exist_ok=True)\n\n#\n# Output Chla Maps\n#\noutput_chla_map = \"Output_Data\/Chla_Map\"\nos.makedirs(output_chla_map, exist_ok=True)\n\n#\n# Output Surface reflectance with atmospheric correction\n#\noutput_image_rrs = \"Output_Data\/Image_rrs\"\nos.makedirs(output_image_rrs, exist_ok=True)","7a947461":"#\n# chla map\n#\noutput_chla_map_file = os.path.join(output_chla_map,\"T22KGA_20180813T132229_chla_map.tif\")\n\n#\n# class map\n#\noutput_class_map_file = os.path.join(output_class_map, \"T22KGA_20180813T132229_class_map.tif\")","9473fb4a":"#\n# chla map (Cropped by shapefile)\n#\noutput_chla_map_cropped = os.path.join(output_chla_map,\"T22KGA_20180813T132229_chla_map_crop.tif\")\n\n#\n# class map (Cropped by shapefile)\n#\noutput_class_map_cropped = os.path.join(output_class_map, \"T22KGA_20180813T132229_class_map_crop.tif\")","24f6569e":"input_base_path = \"..\/input\/example-dataset-ibitinga-reservoir-sp-br\/Example_OHM\/Input_Data\"","4c674daa":"shapefile = gpd.read_file(os.path.join(input_base_path, \"shapefile_ROI\", \"reservoir.shp\"))\nshapefile.head()","f0df9cc7":"#\n# Defining path to the band 3 file\n#\nb3_original = os.path.join(input_base_path, 'atm_corrected_bands', 'T22KGA_20180813T132229_B03.TIF')\n\n#\n# Dividing by PI (Surface reflectance with atmospheric correction)\n#\nb3_rrs = os.path.join(output_image_rrs, 'T22KGA_20180813T132229_B03_rrs_20.TIF')\nb3_rrs = rrs_image(b3_original, b3_rrs)\n\n#\n# Defining the output file for resampling result\n#\nb3_resampled = os.path.join(output_resampled, 'T22KGA_20180813T132229_B03_resampled_20.TIF')\n\n#\n# Loading resampling band 3 file\n#\nb3 = rio.open(resampling(b3_rrs, b3_resampled, 20))","d3f67843":"#\n# Defining path to the band 4 file\n#\nb4_original = os.path.join(input_base_path, 'atm_corrected_bands', 'T22KGA_20180813T132229_B04.TIF')\n\n#\n# Dividing by PI (Surface reflectance with atmospheric correction)\n#\nb4_rrs = os.path.join(output_image_rrs, 'T22KGA_20180813T132229_B04_rrs_20.TIF')\nb4_rrs = rrs_image(b4_original, b4_rrs)\n\n#\n# Defining the output file for resampling result\n#\nb4_resampled = os.path.join(output_resampled, 'T22KGA_20180813T132229_B04_resampled_20.TIF')\n\n#\n# Loading and resampling band 4 file\n#\nb4 = rio.open(resampling(b4_rrs, b4_resampled, 20))","ca8397cb":"#\n# Defining path to the band 5 file\n#\nb5_original = os.path.join(input_base_path, 'atm_corrected_bands', 'T22KGA_20180813T132229_B05.TIF')\n\n#\n# Dividing by PI (Surface reflectance with atmospheric correction)\n#\nb5_rrs = os.path.join(output_image_rrs, 'T22KGA_20180813T132229_B05_rrs_20.TIF')\nb5_rrs = rrs_image(b5_original, b5_rrs)\n\n#\n# Loading and resampling band 5 file\n#\nb5 = rio.open(b5_rrs)","07aa4277":"#\n# Defining path to the band 6 file\n#\nb6_original = os.path.join(input_base_path, 'atm_corrected_bands','T22KGA_20180813T132229_B06.TIF')\n\n#\n# Dividing by PI (Surface reflectance with atmospheric correction)\n#\nb6_rrs = os.path.join(output_image_rrs, 'T22KGA_20180813T132229_B06_rrs_20.TIF')\nb6_rrs = rrs_image(b6_original, b6_rrs)\n\n#\n# Loading and resampling band 6 file\n#\nb6 = rio.open(b6_rrs)","1aabf6ea":"#\n# Defining path to the band 11 file\n#\nb11_original = os.path.join(input_base_path, 'atm_corrected_bands','T22KGA_20180813T132229_B11.TIF')\n\n#\n# Dividing by PI (Surface reflectance with atmospheric correction)\n#\nb11_rrs = os.path.join(output_image_rrs, 'T22KGA_20180813T132229_B11_rrs_20.TIF')\nb11_rrs = rrs_image(b11_original, b11_rrs)\n\n#\n# Loading and resampling band 11 file\n#\nb11 = rio.open(b11_rrs)","fbe34015":"#\n# Creating the metadata for output raster (Class and chla) \n#\noutput_metadata = b3.meta.copy()\n\noutput_metadata[\"driver\"] = \"GTiff\"\noutput_metadata[\"dtype\"]  = \"float64\"","6baecba3":"#\n# Chla raster file\n#\nchla_map = rio.open(output_chla_map_file, \"w\", **output_metadata)\n\n#\n# Class raster file\n#\nclass_map = rio.open(output_class_map_file, \"w\", **output_metadata)","b4903a50":"for _, block in b3.block_windows():\n    # opening every block of the scene, in each band\n    b3_arr  = b3.read(1, window  = block)\n    b4_arr  = b4.read(1, window  = block)\n    b5_arr  = b5.read(1, window  = block)\n    b6_arr  = b6.read(1, window  = block)\n    b11_arr = b11.read(1, window = block)\n\n    # Glint Correction Wang and Shi (2007)\n    b3_arr = b3_arr - b11_arr\n    b4_arr = b4_arr - b11_arr\n    b5_arr = b5_arr - b11_arr\n    b6_arr = b6_arr - b11_arr\n\n    # applying the model\n    classes, estimative = OHA_function(\n        b3_arr, b4_arr, b5_arr, b6_arr\n    )\n\n    # saving processed block\n    class_map.write(classes[np.newaxis, ...], window = block)\n    chla_map.write(estimative[np.newaxis, ...], window = block)","dea84fc3":"class_map.close()\nchla_map.close()","a772b5c5":"#\n# Cropping class map\n#\ncrop_image_by_shapefile(output_class_map_file, shapefile, output_class_map_cropped)","be6a8509":"#\n# Cropping chla map\n#\ncrop_image_by_shapefile(output_chla_map_file, shapefile, output_chla_map_cropped)","5ef5b6ef":"### Crop function","35a44c6a":"**OHA function**","48990abf":"**Applying OHA (by raster blocks)**","5054f6f3":"## 3 - Defining input and output","8fbd0364":"## 1 - Import libraries","e63f4f46":"### Input data definitions","33e7a041":"**Creating output file**","f0d4547e":"**Loading shapefile**","02fc7d8d":"**Model 1 - Gitelson et al. (2011) - Class 1 (low eutrophication condition)**","39c5c138":"### Rrs image ","3686ccec":"**Model 2 - Mishra & Mishra (2010) - Class 2 (medium eutrophication condition)**","6855634b":"## 2 - Defining auxiliary functions","01079e8d":"### Output data definitions","a67e226d":"# Optical Hybrid Algorithm - OHA - Cairo et al. (2020)","50d4d034":"## 5 - Cropping Class and Chla Maps by Reservoir shapefile","9447c270":"**Loading and resampling the raster bands files**","7203a183":"**Closing the results file**","d02ef2b5":"## 4 - Applying OHA on the Sentinel-2 image","7ab30535":"**Opening the results file (to write the estimative and chla values)**","fa400f61":"**Model 3 - B5\/B3 (up to 600 $mg\/m^3$) or B6\/B3 (up to 1000 $mg\/m^3$) - Class 3 (high eutrophication condition)**","e9ea83cc":"### Resampling function","0e374d6a":"### Model functions"}}