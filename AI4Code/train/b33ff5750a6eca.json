{"cell_type":{"7f6c7acb":"code","3947cbdc":"code","84f0a2c2":"code","ad69a5c3":"code","5f55f378":"code","2d3c3711":"code","3c613591":"code","b59acd60":"code","30226dfc":"code","a7322d4f":"code","caeb1137":"code","fdf8b3d7":"code","b057268d":"code","11885395":"code","0bdbe567":"code","4844909d":"code","4f3c2cf2":"code","2061fc5b":"code","66adf37f":"code","a86f8825":"code","6df4eb84":"code","5e038147":"code","6a91823e":"code","d853b283":"code","a620db32":"code","77035386":"code","c922ac5b":"code","2f37d0f3":"code","deea69a5":"code","b9b2017c":"code","d2c76b5e":"code","b26f9ea3":"code","ef8bd6c1":"code","6eb7f56e":"code","32457e7f":"code","d322ad23":"code","47dd51e7":"code","91500377":"code","74d93380":"code","f388aa41":"code","fcc1360e":"code","5f10b1e7":"code","a6878be6":"code","8164178f":"code","832e28f6":"markdown","d532f1fb":"markdown","c0da2239":"markdown","e1605e37":"markdown","48acc9fc":"markdown","0d612c6d":"markdown","4e5c17b0":"markdown","8f601968":"markdown","965c8550":"markdown","81e1a9f1":"markdown"},"source":{"7f6c7acb":"# MODULES TO IMPORT\nimport math\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport os\nimport re\nimport seaborn as sns","3947cbdc":"# CONFIGURE PANDAS OUTPUT\npd.set_option('display.max_columns', 999)\npd.set_option('display.width', 9999)\npd.set_option('display.max_colwidth', 9999)\npd.set_option('display.html.table_schema', True)\n\n# CUSTOM DATA FRAME STYLE CAN APPLY BY CALLING\n# df.head().style.set_table_styles(tom_df_style)\ntom_df_style = [\n    dict(selector=\"td\", props=[('font-family','Consolas'), ('font-size','8pt'), ('vertical-align','top'), ('text-align','left'), ('white-space', 'pre')]),\n    dict(selector=\"th\", props=[('font-family','Consolas'), ('font-size','8pt'), ('vertical-align','top'), ('text-align','left'), ('white-space', 'pre')])\n]","84f0a2c2":"# LOAD IN RAW (T)EXT DATASET AND ADD TEXT LENGTH VARIABLE\ndft = pd.read_csv(\"\/kaggle\/input\/train.csv\")\ndft[\"text_length\"] = dft[\"text\"].str.len()\ndft.head(7).style.set_table_styles(tom_df_style)","ad69a5c3":"# MOST ARE <100 CHARACTERS\nsns.distplot(dft[\"text_length\"], kde=False, rug=True);","5f55f378":"# LOAD IN (E)NCRYPTED DATASET AND ADD TEXT LENGTH VARIABLE\ndfe = pd.read_csv(\"\/kaggle\/input\/test.csv\")\ndfe[\"ciphertext_length\"] = dfe[\"ciphertext\"].str.len()\ndfe.head(7).style.set_table_styles(tom_df_style)","2d3c3711":"# BREAK OUT THE ENCRYPTED DATA SET INTO SEPARATE ONES BASED ON DIFFICULTY LEVEL, SINCE IT SOUNDS LIKE THEY'RE APPLIED IN SUCCESSION (1 -> 2 -> 3 ->4), SO LET'S JUST WORRY ABOUT TRYING TO \"CRACK\" LEVEL 1 FIRST\ndfe1 = dfe[dfe[\"difficulty\"] == 1].copy()\ndfe2 = dfe[dfe[\"difficulty\"] == 2].copy()\ndfe3 = dfe[dfe[\"difficulty\"] == 3].copy()\ndfe4 = dfe[dfe[\"difficulty\"] == 4].copy()","3c613591":"# LEVEL 1 APPEARS TO \"JUST\" BE SCRAMBLED IN SOME WAY\ndfe1.sort_values([\"ciphertext_length\",\"ciphertext\"], ascending=[True, True]).head(10).style.set_table_styles(tom_df_style)","b59acd60":"# LEVEL 2 APPEARS TO MAYBE BE SCRAMBLED AGAIN\ndfe2.sort_values([\"ciphertext_length\",\"ciphertext\"], ascending=[True, True]).head(7).style.set_table_styles(tom_df_style)","30226dfc":"# LEVEL 3 FURTHER ENCRYPTED INTO SOME NUMERIC CODING\ndfe3.sort_values([\"ciphertext_length\",\"ciphertext\"], ascending=[True, True]).head(7).style.set_table_styles(tom_df_style)","a7322d4f":"# LEVEL 4 LOOKS LIKE FURTHER MORE ADVANCED BYTE ENCODING\ndfe4.sort_values([\"ciphertext_length\",\"ciphertext\"], ascending=[True, True]).head(7).style.set_table_styles(tom_df_style)","caeb1137":"# WHAT'S THE DISTRUBITION OF THE ENCRYPTED STRING LENGTHS?\ndfe1.groupby([\"ciphertext_length\"]).agg(\"count\")","fdf8b3d7":"# FIND THE TWO LEVEL 1 ENCRYPTED PHRASES 400+ CHARACTERS WIDE\ndfe1[dfe1[\"ciphertext_length\"] >= 400].sort_values([\"ciphertext\"]).style.set_table_styles(tom_df_style)","b057268d":"# FIND WHAT INPUT PHRASES ARE AT LEAST 400+ CHARACTERS WIDE; WE KNOW THE ABOVE TWO ENCRYPTED PHRASES *MUST* CORRELATE TO ONE OF THESE INPUT PHRASES (NOTE: THERE ARE THREE OF THEM)\ndft[(dft[\"text_length\"] >= 400) & (dft[\"text_length\"] <= 500)].sort_values([\"text\"]).style.set_table_styles(tom_df_style)","11885395":"# LET'S TAKE AN EVEN CLOSER LOOK HERE\nexample_encrypted_text = dfe1[dfe1[\"ciphertext_id\"]==\"ID_6100247c5\"][\"ciphertext\"].values[0]\nexample_plain_text     = dft[dft[\"plaintext_id\"]==\"ID_f000cad17\"][\"text\"].values[0]\n\n# HAVE TO \"PAD\" THIS PLAIN TEXT MESSAGE WITH 6 SPACES TO ACCOUNT FOR FINDING #6 ABOVE\nexample_plain_text = \"      \" + example_plain_text\npd.DataFrame([example_plain_text, example_encrypted_text], columns=[\"Text\"], index=[\"ptext\", \"etext\"]).style.set_table_styles(tom_df_style)","0bdbe567":"# WHAT OTHER ENCRYPTED MESSAGES CONTAIN \"YSHEAPA\" (AKA, \"NORFOLK\" ?)\ndfe1[(dfe1[\"ciphertext\"].str.contains(\"YSHEAPA\"))].sort_values([\"ciphertext\"]).style.set_table_styles(tom_df_style)","4844909d":"# WE SEE A \"YSHEAPA: Ssi\" ABOVE, IS THERE A \"NORFOLK: The \" HERE? YEP! \ndft[dft[\"text\"].str.contains(\"NORFOLK: The \")].sort_values([\"text\"]).style.set_table_styles(tom_df_style)","4f3c2cf2":"# WITH THE HELP OF THE APOSTROPHE SEEN (WHICH WE KNOW ARE \"PRESERVED\") IN \"The Cardinal's\" \n# WE CAN PROBABLY GUESS THESE GO TOGETHER (ALTHOUGH: SHIFTED 27 SPACES INSTEAD OF 6..HMMM)\nexample_encrypted_text = dfe1[dfe1[\"ciphertext_id\"]==\"ID_9bf75d21c\"][\"ciphertext\"].values[0]\nexample_plain_text     = dft[dft[\"plaintext_id\"]==\"ID_9b8e655fe\"][\"text\"].values[0]\nexample_plain_text = (\" \" * 27) + example_plain_text\npd.DataFrame([example_plain_text, example_encrypted_text], columns=[\"Text\"], index=[\"ptext\", \"etext\"]).style.set_table_styles(tom_df_style)","2061fc5b":"# IT WOULD APPEAR THAT THE PLAIN TEXT MESSAGES ARE FIRST \"CENTERED\" BEFORE BEING ENCRYTED\nlist_text = list(dft[\"text\"])\nlist_lenx = [int(math.ceil(x \/ 100.0)) * 100 for x in dft[\"text_length\"]]\n\ndft[\"text_adj\"] = list(map(lambda t, x: t.center(x,\"`\"), list_text, list_lenx))\ndft.head().style.set_table_styles(tom_df_style)","66adf37f":"# LETS TRY THIS AGAIN\nexample_encrypted_text = dfe1[dfe1[\"ciphertext_id\"]==\"ID_9bf75d21c\"][\"ciphertext\"].values[0]\nexample_plain_text     = dft[dft[\"plaintext_id\"]==\"ID_9b8e655fe\"][\"text_adj\"].values[0]\npd.DataFrame([example_plain_text, example_encrypted_text], columns=[\"Text\"], index=[\"ptext\", \"etext\"]).style.set_table_styles(tom_df_style)","a86f8825":"# PERHAPS ADJUSTED SENTENCE PATTERNS ARE \"UNIQUE\" AND CAN PROVIDE US WITH A UNIQUE \"SENTENCE SIGNATURE\" (SINCE DON'T YET HAVE A FULL CHARACTER-FOR-CHARACTER MAPPING)\ndft[\"text_pattern\"] = dft[\"text_adj\"].str.replace(\"`\", \"`\", regex=False)\ndft[\"text_pattern\"] = dft[\"text_pattern\"].str.replace(\"[A-Z]\", \"X\", regex=True)\ndft[\"text_pattern\"] = dft[\"text_pattern\"].str.replace(\"[a-z]\", \"x\", regex=True)\ndft.head().style.set_table_styles(tom_df_style)","6df4eb84":"# MOST ARE UNIQUE! THIS MIGHT BE PROMISING!\ntmp = pd.DataFrame(dft.groupby([\"text_pattern\"]).size(), columns=[\"N\"])\nsns.distplot(tmp[\"N\"], kde=False, rug=True);","5e038147":"# LET'S APPLY THE SAME TRANSFORMATION TO THE LEVEL 1 ENCRYPTED TEXT\ndfe1[\"text_pattern\"] = dfe1[\"ciphertext\"].str.replace(\"`\", \"`\", regex=False)\ndfe1[\"text_pattern\"] = dfe1[\"text_pattern\"].str.replace(\"[A-Z]\", \"X\", regex=True)\ndfe1[\"text_pattern\"] = dfe1[\"text_pattern\"].str.replace(\"[a-z]\", \"x\", regex=True)\ndfe1.head().style.set_table_styles(tom_df_style)","6a91823e":"# HERE'S ONE EXAMPLE FOUND\ntmp1 = dfe1[dfe1[\"ciphertext_id\"]==\"ID_d649ebbb2\"][[\"ciphertext\",\"text_pattern\"]].rename(columns={\"ciphertext\":\"text\"})\ntmp2 = dft[dft[\"plaintext_id\"]==\"ID_97bea3ff9\"][[\"text_adj\",\"text_pattern\"]].rename(columns={\"text_adj\":\"text\"})\npd.concat([tmp1,tmp2], ignore_index=True).style.set_table_styles(tom_df_style)","d853b283":"# HERE IS A MESSY (AND VERY SLOW!) ATTEMPT AT \"AUTOMATING\" THE MATCHING OF SOME ENCRYPTED PHRASES BACK TO THE \"BEST GUESS\" MATCHING ORIGINAL MESSAGE BASED ON SENTENCE STRUCTURE\nresults = {}\ndft_data = list(dft[[\"plaintext_id\",\"text_length\",\"text_pattern\",]].to_records(index=False))\n\n#eids = [\"ID_6100247c5\",\"ID_9bf75d21c\",\"ID_fb906e3a4\",\"ID_93aa4509f\",\"ID_d649ebbb2\",\"ID_4a6fc1ea9\",\"ID_c85d54d74\",\"ID_ac57b8817\"]\n#for i, dfe1_row in dfe1[dfe1[\"ciphertext_id\"].isin(eids)].iterrows():\n\n# GRAB SOME ARBITRARY RECORDS (LIKE JUST 30 OR SO)\nfor i, dfe1_row in dfe1.sample(30, random_state=123).iterrows():    \n    (ciphertext_id, cipher_text_pattern) = (dfe1_row.ciphertext_id, dfe1_row.text_pattern)\n    print(ciphertext_id)\n    print(\"   ETEXT:\" + cipher_text_pattern)\n    \n    results[ciphertext_id] = \"\"\n    maxlength = 0\n    for d in dft_data:\n        (plaintext_id, plain_text_length, plain_text_pattern) = (d[0], d[1], d[2])\n        boxsize = int(math.ceil(plain_text_length \/ 100.0)) * 100\n        startpos = int((boxsize - plain_text_length) \/ 2)\n        if cipher_text_pattern[startpos:startpos+plain_text_length] == plain_text_pattern[startpos:startpos+plain_text_length]:\n            if plain_text_length > maxlength:\n                results[ciphertext_id] = plaintext_id\n                maxlength = plain_text_length\n                print(\"   PTEXT:\" + plain_text_pattern)","a620db32":"results","77035386":"cids = []\ntids = []\nfor k, v in results.items():\n    cids.append(k)\n    tids.append(v)","c922ac5b":"# NOW WE CAN THUMB THROUGH SOME MATCHES FOUND AND TRY AND GLEAN SOME MORE INSIGHTS INTO THE MAPPINGS\nk = 3\n\n(cid, tid) = (cids[k],tids[k])\ntmp1 = dft[dft[\"plaintext_id\"]==tid][[\"text_adj\"]].rename(columns={\"text_adj\":\"text\"})\ntmp2 = dfe1[dfe1[\"ciphertext_id\"]==cid][[\"ciphertext\"]].rename(columns={\"ciphertext\":\"text\"})\npd.concat([tmp1,tmp2], ignore_index=True).style.set_table_styles(tom_df_style)","2f37d0f3":"# FOR MATCH RESULTS FOUND, PAIR PLAIN => ENCYPTED MESSAGES\ndf_bridge = pd.DataFrame({\"TID\":tids, \"EID\":cids})\ndf_bridge = df_bridge.merge(dft, how=\"inner\", left_on=\"TID\", right_on=\"plaintext_id\")[[\"EID\",\"plaintext_id\",\"text\",\"text_length\"]]\ndf_bridge = df_bridge.merge(dfe1, how=\"inner\", left_on=\"EID\", right_on=\"ciphertext_id\")[[\"plaintext_id\",\"text\",\"text_length\",\"ciphertext_id\",\"ciphertext\"]]\ndf_bridge.head(10).style.set_table_styles(tom_df_style)","deea69a5":"# LET'S \"CLIP\" THE CIPHERTEXT TO OVERLAY KEEP THOSE CHARACTERS THAT ACTUALLY ALGN TO THE PLAIN TEXT |....XXXXXXX....| SIMILAR AS HAD DONE ABOVE\nlist_text     = list(df_bridge[\"ciphertext\"])\nlist_lenx     = list(df_bridge[\"text_length\"])\nlist_boxsize  = [int(math.ceil(L \/ 100.0)) * 100 for L in list_lenx]\nlist_startpos = list(map(lambda B, L: int((B - L) \/ 2), list_boxsize, list_lenx))\n\ndf_bridge[\"ciphertext_adj\"] = list(map(lambda T, P, L: T[P:P+L], list_text, list_startpos, list_lenx))\ndf_chars = df_bridge[[\"text\",\"ciphertext_adj\"]]\ndf_chars.head(10)","b9b2017c":"# NOW WE CAN ATTEMPT TO MAP ALL char_in => char_out FOR PHRASES INCLUDED IN OUR RESULTS\/BRIDGE DATASET\nlist_chars_in = []\nlist_chars_out = []\nfor i in range(0, len(df_chars)):\n    chars_in  = list(df_chars.iloc[i,0])\n    chars_out = list(df_chars.iloc[i,1])\n    assert (len(chars_out) == len(chars_in))\n    list_chars_in  = list_chars_in + chars_in\n    list_chars_out = list_chars_out + chars_out\n    \ndf_char_map = pd.DataFrame({\"in\":list_chars_in, \"out\":list_chars_out})\ndf_char_map.head(10).style.set_table_styles(tom_df_style)","d2c76b5e":"# LET'S DO A FULL CROSSTAB TO SAY WHAT MAPS TO WHAT AND HOW OFTEN\ndf_char_cross = pd.pivot_table(pd.DataFrame(df_char_map.groupby([\"in\",\"out\"]).size(), columns=[\"N\"]), values=\"N\", index=[\"out\"], columns=[\"in\"], aggfunc=np.sum, fill_value=0)\ndf_char_cross.head(10).style.set_table_styles(tom_df_style)","b26f9ea3":"# LEt'S PLOT THIS\nfig, ax = plt.subplots(figsize=(20,10))\nsns.heatmap(df_char_cross, linewidths=1, cmap=sns.light_palette(\"red\"), vmin=0, vmax=5, ax=ax)\nax.xaxis.set_ticks_position(\"top\")","ef8bd6c1":"df_chars.head(25).style.set_table_styles(tom_df_style)","6eb7f56e":"# ZOOM IN ON JUST THE lowercare LETTERS AND WE SEE THAT PERHAPS \"z\" CHARACTERS ARE SIMPLY LEFT ALONE (LIKE PUNCTUATION, CHRACATERS, AND NUMBERS APPEAR TO BE)\nfig, ax = plt.subplots(figsize=(20,10))\nsns.heatmap(df_char_cross.iloc[32:,28:], linewidths=1, cmap=sns.light_palette(\"red\"), vmin=0, vmax=5, ax=ax)\nax.xaxis.set_ticks_position(\"top\")","32457e7f":"# FIRST ROW CONTAINS ORIGINAL LETTERS WE WANT TO TRANSLATE AND SUBSEQUENT ROWS REPRESENT 1st, 2nd, 3rd, and 4th SHIFT\ntranslation = [\n\"ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy\",\n\"EFGHIJKLMNOPQRSTUVWXYABCDefghijklmnopqrstuvwxyabcd\",\n\"PQRSTUVWXYABCDEFGHIJKLMNOpqrstuvwxyabcdefghijklmno\",\n\"YABCDEFGHIJKLMNOPQRSTUVWXyabcdefghijklmnopqrstuvwx\",\n\"LMNOPQRSTUVWXYABCDEFGHIJKlmnopqrstuvwxyabcdefghijk\",\n]\n    \n# GIVEN AN INPUT CHARACTER AND ITS SEQUENCE MARKER, RETURN ENCYPTED CHARACTER (IF RELEVANT) AND INCREASE SEQUENCE INDICTATOR VALUE (IF RELEVANT)\ndef decrypt_letter(input_char, s):\n\n    k = s % 4    \n    retvals = (input_char, 0)\n\n    if (k == 0):\n        k = 4\n    \n    i = translation[k].find(input_char)\n    \n    if (i >= 0):\n        out_char = translation[0][i]\n        retvals = (out_char, 1)\n\n    return retvals","d322ad23":"# TEST SOME\nprint(decrypt_letter(\"F\",1))\nprint(decrypt_letter(\"[\",53))","47dd51e7":"# NOW BUILD FUNCTION TO DECRYPT ENTIRE PHRASES\ndef decrypt_phrase(input_phrase, xstart):\n    \n    return_chars = []\n    x = xstart\n    \n    for c in input_phrase:\n        (out_char, i) = decrypt_letter(c, x)\n        x = x + i\n        return_chars.append(out_char)\n    \n    return \"\".join(return_chars)","91500377":"# Fks nihslmd hewkd exhnvii lgwj ydfxsdejd:\n# But certain issue strokes must arbitrate:\ndecrypt_phrase(\"Fks nihslmd hewkd exhnvii lgwj ydfxsdejd:\", 1)","74d93380":"# YSHEAPA: Ssi rydhxmlp'i llpxbp edc smi oaxtmnd\n# NORFOLK: The cardinal's malice and his potency\ndecrypt_phrase(\"YSHEAPA: Ssi rydhxmlp'i llpxbp edc smi oaxtmnd\", 4)","f388aa41":"# TRIAL AND ERROR SEEMS TO SUGGEST IF WE SEND IN THE FULL CIPHERTEXT, THEN WE CAN TURN THE KNOB TO \"2\" AND THINGS COME INTO FOCUS (IN THE MIDDLE): \ndfe1.head(15)[\"ciphertext\"].apply(lambda x : decrypt_phrase(x,2))","fcc1360e":"%%time\n\n# HERE IS A MESSY (AND VERY SLOW!) ATTEMPT AT DECRYPTING LEVEL 1 PHRASES\nfull_results = []\n\ndfe1_data = list(dfe1[[\"ciphertext_id\",\"ciphertext\"]].to_records(index=False))\ndft_id    = list(dft[\"plaintext_id\"])\ndft_text  = list(dft[\"text\"])\ndft_index = list(dft[\"index\"])\n\nlist_lenx     = list(dft[\"text_length\"])\nlist_boxsize  = [int(math.ceil(L \/ 100.0)) * 100 for L in list_lenx]\nlist_startpos = list(map(lambda B, L: int((B - L) \/ 2), list_boxsize, list_lenx))\n\n# GRAB SOME ARBITRARY RECORDS (LIKE JUST 100 OR SO)\ni = 0\nN = len(dfe1_data)\nfor row_enc in dfe1_data:\n\n    i = i + 1\n    if i % 1000 == 0:\n        print(str(i) + \" [\" + f\"{(i\/N):0.2%}\" + \" ] records processed...\")\n        \n    (ciphertext_id, ciphertext) = (row_enc[0], row_enc[1])\n    deciphered_text = decrypt_phrase(ciphertext, 2)\n   \n    for j in range(0,len(dft_text)):\n        (plaintext_id, plain_text, plain_text_index, startpos, plain_text_length) = (dft_id[j], dft_text[j], dft_index[j], list_startpos[j], list_lenx[j])\n        if deciphered_text[startpos:startpos+plain_text_length] == plain_text:\n            full_results.append([ciphertext_id, ciphertext, plain_text, plaintext_id, plain_text_index])\n            break","5f10b1e7":"df_results = pd.DataFrame(full_results, columns=[\"ciphertext_id\",\"ciphertext\",\"plain_text\",\"plaintext_id\",\"plain_text_index\"])\ndf_results.head().style.set_table_styles(tom_df_style)","a6878be6":"# SETUP SUBMISSIONS FILE\ndf_submissions = dfe[[\"ciphertext_id\"]].merge(df_results[[\"ciphertext_id\",\"plain_text_index\"]], how=\"left\", left_on=\"ciphertext_id\", right_on=\"ciphertext_id\")\ndf_submissions[\"plain_text_index\"] = df_submissions[\"plain_text_index\"].fillna(0).astype(int)\ndf_submissions.rename(columns={\"plain_text_index\": \"index\"}, inplace=True)\ndf_submissions.head(10)","8164178f":"# EXPORT SUBMISSION FILE\ndf_submissions.to_csv(\"ct3_submission.csv\", index=None)","832e28f6":"Picking out a couple the phrases and comparing letter distances forward from input charracter, see this (imperfect) pattern:\n\n<pre style=\"font-size: 8pt\">| B| u| t|  | c| e| r| t| a| i| n|  | i| s| s| u| e|  | s| t| r| o| k| e| s|  | m| u| s| t|  | a| r| b| i| t| r| a| t| e| :|\n| F| k| s|  | n| i| h| s| l| m| d|  | h| e| w| k| d|  | e| x| h| n| v| i| i|  | l| g| w| j|  | y| d| f| x| s| d| e| j| d| :|\n|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|\n| 4|16|25|  |11| 4|16|25|11| 4|16|  |25|12| 4|16|25|  |12| 4|16|25|11| 4|16|  |25|12| 4|16|  |24|12| 4|15|25|12| 4|16|25|  |\n\n\n| N| O| R| F| O| L| K| :|  | T| h| e|  | c| a| r| d| i| n| a| l| '| s|  | m| a| l| i| c| e|  | a| n| d|  | h| i| s|  | p| o| t| e| n| c| y|\n| Y| S| H| E| A| P| A| :|  | S| s| i|  | r| y| d| h| x| m| l| p| '| i|  | l| l| p| x| b| p|  | e| d| c|  | s| m| i|  | o| a| x| t| m| n| d|\n|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|\n|11| 4|16|25|12| 4|16|  |  |25|11| 4|  |15|24|12| 4|15|25|11| 4|  |16|  |25|11| 4|15|25|11|  | 4|16|25|  |11| 4|16|  |25|12| 4|15|25|11| 5|<\/pre>\n\n**notes:**<br\/><br\/>\n1) The pattern <i>tends<\/i> to be 4-16-25-11 but sometimes is 5(+1) instead of 4; 15(-1) instead of 16; 24(-1) instead of 25; and 11(-1) instead of 12\n\n2) The first phrase started +4 but 2nd phrase started +11 ... how to know what to even start with?","d532f1fb":"### FROM THE ABOVE PICTURE, THERE'S CLEARLY SOME CYCLICAL PATTERN, BUT WHAT IS IT, EXACTLY??!","c0da2239":"## AT LONG LAST! LET'S TRY AND DECRYPT THINGS","e1605e37":"## MAYBE HAVE ENOUGH TO TRY MAPPING CHARACTERS NOW","48acc9fc":"### Part I: Load datasets and just do some high-level exploration","0d612c6d":"<div><b><u>Some observations:<\/u><\/b><br\/>\nWe can see that the first encrypted phrase <i>(ciphertext_id=ID_31bd699f6)<\/i> is \"too short\" to possibly go with any of these input phrases, so we know the one encrypted message <i>(ID_6100247c5)<\/i> <b>must<\/b> have come from one of these 3 input phrases<br\/>\n<br\/>\nBy close introspection, scanning the \"words\" from left-to-right, we can infer the 2nd one <i>(plaintext_id=ID_f000cad17)<\/i> is the one, all the punctuation and spaces <i>(including any double spaces)<\/i> just seem to magically align!<br\/>\n<br\/>\nThis has given us some \"good hope\" that:<br\/><br\/>\n1) Punctuation and spacing appears to be fully preserved \u2714<br\/><br\/>\n2) Case appears to be preserved (lower vs upper) \u2714<br\/><br\/>\n3) Indvidual word lengths appear to be preserved \u2714<br\/><br\/>\n<br\/>\nUnfortunately, there's some not-so-good things, it looks like:<br\/><br\/>\n4) It's unclear if we have the start of some sort of dictionary for 30+ words, as some words <i>(i.e. \"the\")<\/i> appear to have varying ouput values<i>(i.e. \"xwd\", \"flt\" and\/or \"ssi\")<\/i><br\/><br\/>\n5) It does not appear that individual letters are just 1-for-1; for example, sometimes input \"t\" \u279d encrypted \"s\", as in \"<b style=\"color: blue\">t<\/b>wo \u279d <b style=\"color: blue\">s<\/b>is\", and at other times \"f\", as in \"grea<b style=\"color: blue\">t<\/b> \u279d rvty<b style=\"color: blue\">f<\/b>\"<br\/><br\/>\n6) The very beginning of the ciphertext seem to violate found assumptions 2-4 ... <span style=\"font-family: monospace\">\"gQUXDo<span style=\"color: blue\">Bshspv<\/span>:\" \u279d \"<span style=\"color: blue\">Porter:<\/span>\"<\/span>\n<\/div>","4e5c17b0":"## NAIVE CHARACTER TRANSLATOR USING THE CYCLICAL +4 -> +16 > +25 -> +11 CONVERSION CYCLE AS WE MOVE LEFT-TO-RIGHT THRU LETTERS THAT REQUIRE ENCRYPTED","8f601968":"It looks like we can also probably assume numbers are preserved too!","965c8550":"## ANOTHER TWIST WAS SOME PHRASES DON'T ALWAYS START WITH FIRST +4 TRANSLATION, SO ADD PARAMETER TO FINE-TUNE ADJUST START-POS COUNTER","81e1a9f1":"<h2>Part II: Attempt to shrink the problem down<\/h2>\n\n<p style=\"font-size: 10pt\"><b>What's known:<\/b><br\/>\n1) It was given that <i>\"Every document in the dataset has been padded to the next hundred characters (95->100, 213->300) with random (in-alphabet) characters, then encrypted\"<\/i><br\/>\n-and-<br\/>\n2) While we don't know how each training record (plain text) ends up getting encrypted, we <i><b>do<\/b><\/i> know that each test record (encrypted text) comes from a training record<br\/>\n<br\/>\n<b>Therefore:<\/b><br\/>\nWe should focus on the very long encypted (level 1) records and see what we can glean from there; hoepfully, it leads to something \"unique\"!<br\/>\n<\/p>"}}