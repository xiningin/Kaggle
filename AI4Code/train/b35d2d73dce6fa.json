{"cell_type":{"64268c74":"code","cf456470":"code","161533b3":"code","7c268a0d":"code","4bdca5b3":"code","6c15f613":"code","b7e9b3a6":"code","92bd4e79":"code","56189116":"code","612320d1":"code","167c5fc5":"code","19c77391":"code","98d02e57":"markdown","3d87fda1":"markdown","ad5914ad":"markdown","8a8e12aa":"markdown"},"source":{"64268c74":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \nimport os\nimport sys\nimport itertools\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","cf456470":"class_map = pd.read_csv('\/kaggle\/input\/bengaliai-cv19\/class_map.csv')\ntrain_dataset = pd.read_csv('\/kaggle\/input\/bengaliai-cv19\/train.csv')","161533b3":"train_dataset.head()","7c268a0d":"class_map.head()","4bdca5b3":"# Breaking down a grapheme\n# Result corresponds to individual components\n\nprint(list('\u09b0\u09cd\u09af\u09cb'))\n\nprint(list('\u09b0\u09cd\u0985\u09cd\u09af')) \n\nprint(list('\u09a4\u09cd\u09ac'))\n\n# Character '\u09cd' acts as a binder to join root with consonant\/vowel","6c15f613":"# Collecting mappings of components\nbinder = '\u09cd'\nroot_mapper = dict(zip(class_map[class_map.component_type=='grapheme_root'].label.to_list(), class_map[class_map.component_type=='grapheme_root'].component.to_list()))\nvowel_mapper = dict(zip(class_map[class_map.component_type=='vowel_diacritic'].label.to_list(), class_map[class_map.component_type=='vowel_diacritic'].component.to_list()))\nconsonant_mapper = dict(zip(class_map[class_map.component_type=='consonant_diacritic'].label.to_list(), class_map[class_map.component_type=='consonant_diacritic'].component.to_list()))\ncover_edge_cases = True","b7e9b3a6":"# Abra Kadabra\nfinal_output = []\nfor combination in list(itertools.product(range(168),range(11), range(7))): # create tuple of every combinations and iterate over\n    output = ''\n    root = combination[0]\n    vowel = combination[1]\n    consonant = combination[2]\n    \n    root_label = root_mapper[root]\n    vowel_label = vowel_mapper[vowel]\n    consonant_label = consonant_mapper[consonant]\n    \n    # Ignore root with label 0 and 1\n    if root in [0, 1] and vowel==0 and consonant==0:\n        output = root_label\n        \n    elif root in [0, 1] and (vowel!=0 or consonant!=0):\n        pass\n    \n    elif root != 0:\n        if consonant == 0 and vowel==0:\n            output = list(root_label)\n            output = ''.join(output)\n            \n        elif consonant ==  0 and vowel!=0:\n            output = list(root_label) + list(vowel_label)\n            output = ''.join(output)\n            \n        elif consonant in [1,2,3]:   \n            if consonant==1 and vowel==0:  #High priority on right. preceedes vowel position\n                output = list(root_label) + list(consonant_label)\n                output = ''.join(output)\n            elif consonant==1 and vowel!=0:  #High priority on right. preceedes vowel position\n                output = list(root_label)+ list(vowel_label) + list(consonant_label)\n                output = ''.join(output)\n\n            elif consonant==2 and vowel==0: #High priority on left.\n                output = list(consonant_label) + list(root_label)\n                output = ''.join(output)\n                \n                #Edge Case Handling regarding consonant==2 \u09b0\u200d\u09cd\u09af\u09be \u09b0\u09cd\u09a6\u09cd\u09b0 \u09b0\u09cd\u09a4\u09cd\u09b0\u09c0 \u09b0\u09cd\u09a4\u09cd\u09b0\u09c7\n                if cover_edge_cases:\n                    final_output.append([root, vowel, consonant, output])\n                    output = list(consonant_label) + list(root_label) + [binder] + list(consonant_label[0])\n                    output = ''.join(output)\n                \n\n            elif consonant==2 and vowel!=0: #High priority on left.\n                output = list(consonant_label) + list(root_label) + list(vowel_label)\n                output = ''.join(output)\n                \n                #Edge Case Handling regarding consonant==2 \u09b0\u200d\u09cd\u09af\u09be \u09b0\u09cd\u09a6\u09cd\u09b0 \u09b0\u09cd\u09a4\u09cd\u09b0\u09c0 \u09b0\u09cd\u09a4\u09cd\u09b0\u09c7\n                if cover_edge_cases:\n                    final_output.append([root, vowel, consonant, output])\n                    output = list(consonant_label) + list(root_label) + [binder] + list(consonant_label[0]) + list(vowel_label)\n                    output = ''.join(output)\n\n            elif consonant==3 and vowel==0: #Split priority Left and Right rest in middle.\n                output = list(consonant_label[0])+ [binder] + list(root_label) + [binder] + list(consonant_label[-1])\n                output = ''.join(output)    \n\n            elif consonant==3 and vowel!=0: #Split priority Left and Right rest in middle.\n                output = list(consonant_label[0])+ [binder] + list(root_label) + [binder] + list(consonant_label[-1]) + list(vowel_label)\n                output = ''.join(output)\n                \n        elif consonant in [4,5,6]:  \n            if consonant in [4, 5, 6] and vowel==0: #Soft Right priority\n                output = list(root_label) + list(consonant_label)\n                output = ''.join(output) \n\n            elif consonant in [4, 5, 6] and vowel!=0: #Soft Right priority\n                output = list(root_label) + list(consonant_label) + list(vowel_label)\n                output = ''.join(output) \n            \n    else:\n        print(combination)\n        break\n        \n    if output:\n        final_output.append([root, vowel, consonant, output])","92bd4e79":"full_dataset = pd.DataFrame(final_output, columns=['grapheme_root', 'vowel_diacritic', 'consonant_diacritic', 'grapheme'])\nfull_dataset['image_id'] = full_dataset.index\nfull_dataset['image_id'] = 'Train_' + full_dataset['image_id'].astype(str)\ncols = full_dataset.columns.tolist()\ncols = cols[-1:] + cols[:-1]\nfull_dataset = full_dataset[cols]","56189116":"full_dataset.head()","612320d1":"len(full_dataset) # 168 x 11 x 7 = 12784 + 1826 (Edge Cases)","167c5fc5":"for char in train_dataset.grapheme.unique():\n    if char not in full_dataset.grapheme.tolist():\n        print('Missing Grapheme: ', char)\n        print('Unicode Components: ',list(char))","19c77391":"full_dataset.to_csv('BengaliAllCombinationsGrapheme.csv', index=None)","98d02e57":"## Read Class Map","3d87fda1":"## Rules discovered with manual observation from this [Kernel](https:\/\/www.kaggle.com\/jamesmcguigan\/unicode-visualization-of-the-bengali-alphabet) \n\n### 1. Consonant Label-1 has highest priority on right and preceeds vowel position.\n### 2. Consonant Label-2 has highest priority on left and preceeds root and grapheme position.\n### 3. Consonant Label-3 has two components that wraps around root with vowel taking highest priority on left.\n### 4. Consonant Label-4,5,6 has right priority with highest priority given to vowel if any.\n\n### This rules covers all the Graphemes from training data except one.","ad5914ad":"## Ultimate Magic","8a8e12aa":"## Unicode Components of Grapheme"}}