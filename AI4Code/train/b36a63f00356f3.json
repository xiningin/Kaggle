{"cell_type":{"7d1982e5":"code","8daeb478":"code","2fa49794":"code","ccb10041":"code","00d4bf9c":"code","417c56b5":"code","aa216a61":"code","9b0bfa6e":"code","802387b2":"code","8777ab2b":"code","b7c0858a":"code","ab6ecd23":"code","dfd81f54":"code","5ddc5a6f":"code","a2532adb":"code","ed21ab87":"code","2cf5d36e":"code","32543a47":"code","e1a6b9e3":"code","bae20a6e":"code","e83999ea":"code","fd8158b8":"code","e9105f3c":"code","2b4902a9":"code","2afebb8f":"code","2e764900":"code","28fc0ce0":"code","92e19c01":"code","0a33741f":"code","7b825a54":"code","4a77b2bb":"code","5ff4add8":"code","408ade6d":"code","261def79":"code","73dd14e2":"code","bbdcc807":"code","6ae82bd4":"code","88210693":"code","56612fd6":"code","c61c8330":"code","b44a753f":"code","80daea0f":"code","344990f0":"code","8ac4c66c":"code","9b943708":"code","8c69f199":"code","3b933543":"code","39eaf996":"code","9b40cd0f":"code","152b6c8d":"code","2743d2c8":"code","3f07d1fb":"code","7c5dd586":"code","2423cc7e":"code","bda3b587":"code","7cacf9ba":"code","2fe4d19d":"code","554c728b":"code","b9c989f9":"code","0afbcfcd":"code","06c991e5":"code","38078168":"code","0b0f4757":"code","e5ee40a3":"code","2004ffd8":"code","c89dcbcb":"code","2b541a61":"code","33046cf8":"code","1a39a854":"code","8a0bddd1":"code","40ac6b06":"code","d8536910":"code","7c2a3484":"code","3183a7ca":"code","d29e7717":"code","c3920618":"code","b7a24cdf":"code","99e59a38":"code","7a923b57":"code","f6e087a9":"code","044aa76d":"code","8f0b8896":"code","5326511a":"code","57769204":"code","21f02715":"code","3a1c3126":"code","8344ecc9":"code","d055013f":"code","e38d5937":"code","847b3696":"code","2f1c73e3":"code","bd8c36bc":"code","e759d4ca":"code","f37d4a98":"code","4debcf4b":"code","b5a9db47":"code","0ca6ba95":"markdown","dfac24b6":"markdown","aa560bde":"markdown","535d4222":"markdown","2419a645":"markdown","988956f8":"markdown","21bcf1d7":"markdown","e030baf7":"markdown","2b0b91e5":"markdown","58243ca5":"markdown","4e9bb80f":"markdown","5de2f31e":"markdown","9abe1aaa":"markdown","814c89ac":"markdown","984de4d1":"markdown","8fd3deef":"markdown","df6eac93":"markdown","8f38aba2":"markdown","b64fbabb":"markdown","702d1ca7":"markdown","5d518fa5":"markdown","51d8f612":"markdown","70a335ee":"markdown","7321c68a":"markdown","df7142d2":"markdown","d83d6545":"markdown","c7b7efed":"markdown","a833d186":"markdown","5a2adb80":"markdown","d389ecef":"markdown","84564b60":"markdown","82ecda33":"markdown","41c9149c":"markdown","18b468aa":"markdown","b0389236":"markdown","e47893b1":"markdown","47321f7d":"markdown","245af8da":"markdown","7e455c96":"markdown","40db8aa2":"markdown","703b35b4":"markdown"},"source":{"7d1982e5":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","8daeb478":"# Importing libraries\n\n# for data manipulation\nimport pandas as pd\nimport numpy as np\n\n# for data visualization  \nimport seaborn as sns\nimport matplotlib.pyplot as plt","2fa49794":"# Importing training data\n\ntrain = pd.read_csv(\"\/kaggle\/input\/credit-default-prediction-ai-big-data\/train.csv\", index_col = 'Id')\n\ntrain.dropna(how = 'all')\n\nprint(\"Train Data has been read\")\n\n# Printing transpose of dataset to view all columns\ntrain.T","ccb10041":"# Importing test data\n\ntest = pd.read_csv(\"\/kaggle\/input\/credit-default-prediction-ai-big-data\/test.csv\", index_col = 'Id')\n\ntest.dropna(how = 'all')\nprint(\"Train Data has been read\")\n\n# Printing transpose of dataset to view all columns\ntest.T","00d4bf9c":"# Info about the train dataset\n\ntrain.info()","417c56b5":"# Stats about the train dataset\n\ntrain.describe().T","aa216a61":"# Info about the test dataset\n\ntest.info()","9b0bfa6e":"# Stats about the test dataset\n\ntest.describe().T","802387b2":"#Deleting spaces between names and interchanging with underscore\n\nnew_cols = [str(i).lower().replace(\" \", \"_\") for i in (list(train.columns))]\nnew_cols","8777ab2b":"# Assigning new names to columns\n\ntrain.columns = new_cols\ntest.columns = new_cols[:-1]","b7c0858a":"# Printing transpose of dataset to view all columns\n\ntrain.T","ab6ecd23":"# Printing transpose of dataset to view all columns\n\ntest.T","dfd81f54":"## Since renewable energy has no value hence analyzing it\n\nprint(train.purpose.value_counts(dropna = False)), print('*' * 80, '\\n'), print(test.purpose.value_counts(dropna = False))","5ddc5a6f":"train = train[train.purpose != 'renewable energy']\ntrain.T","a2532adb":"# Creating a dataframe that contains various values to corresponding columns\n\nmask = train.isnull()                  # calculate total null values\ntotal = mask.sum()                    # calculate the sum\npercent = 100 * mask.mean()           # calculate the percent missing values\ndtype = train.dtypes                   # getting the data types of the columns\nunique = train.nunique()               # getting the all unique values of the columns\n\n\n# creating a dataframe\n\nnull_train = pd.concat([total, percent, dtype, unique], \n                       axis = 1, \n                       keys = ['Total Count', 'Percent Missing', 'dtype', 'Unique Values'])\n\nnull_train.sort_values(by = 'Total Count', ascending = False)","ed21ab87":"mask1 = test.isnull()                          # calculate total null values\ntotal1 = mask1.sum()                           # calculate the sum\npercent1 = 100 * mask1.mean()                  # calculate the percent missing values\ndtype1 = test.dtypes                           # getting the data types of the columns\nunique1 = test.nunique()                       # getting the all unique values of the columns\n\nnull_test = pd.concat([total1, percent1, dtype1, unique1], \n                      axis = 1, \n                      keys = ['Total Count', 'Percent Missing', 'dtype', 'Unique Values'])\n\n\n# Soritng the values by count\n\nnull_test.sort_values(by = 'Total Count', ascending = False)","2cf5d36e":"import seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline","32543a47":"plt.figure(figsize = (20,10))\nsns.heatmap(train.corr(), annot = True, vmax = 1, vmin = -1, square = True)","e1a6b9e3":"plt.figure(figsize = (17,7))\nsns.barplot(y = train.months_since_last_delinquent, x = train.bankruptcies, data = train)","bae20a6e":"plt.figure(figsize = (17,7))\nsns.barplot(y = train.months_since_last_delinquent, x = train.number_of_credit_problems, data = train)","e83999ea":"plt.figure(figsize = (17,7))\nsns.barplot(y = train.months_since_last_delinquent, x = train.purpose, data = train)","fd8158b8":"print('Tax Liens Value Counts ::\\n\\n', train.tax_liens.value_counts(dropna = False))\nprint('*' * 80)\nprint('\\nbankruptcies Value Counts ::\\n\\n', train.bankruptcies.value_counts(dropna = False))","e9105f3c":"print('purpose Value Counts ::\\n\\n', train.purpose.value_counts(dropna = False))\nprint('*' * 80)\nprint('\\number_of_credit_problems Value Counts ::\\n\\n', train.number_of_credit_problems.value_counts(dropna = False))","2b4902a9":"train.bankruptcies.value_counts(dropna = False)","2afebb8f":"from scipy.stats import mode\n\n# Filling with mode value\n\ntrain.bankruptcies =  train.bankruptcies.agg(lambda x : x.fillna(value = 2.0))\n\n# Checking for NaN values present\n\nprint('Total NaN values present after filling :: ', train.bankruptcies.isna().sum())\n","2e764900":"train.bankruptcies.value_counts(dropna = False)","28fc0ce0":"# Checking values before the filled values \n\ntrain['months_since_last_delinquent'].value_counts(dropna = False)","92e19c01":"# Grouping months_since_last_delinquent columns as per  'purpose', 'home_ownership'\n\nmean_score = train.groupby(['tax_liens','bankruptcies','number_of_credit_problems'])['months_since_last_delinquent']\nmean_score.agg([np.mean, np.median, np.size])","0a33741f":"train.loc[: , 'months_since_last_delinquent'] = mean_score.transform(lambda x : x.fillna(x.median()))\n\n#Using ffill to fill any left missing value\n\ntrain.months_since_last_delinquent = train.months_since_last_delinquent.fillna(method = 'ffill')\n# Checking for NaN values present\n\nprint('Total NaN values present after filling :: ', train.months_since_last_delinquent.isna().sum())","7b825a54":"train['months_since_last_delinquent'].value_counts(dropna = False)","4a77b2bb":"print('Total NaN values present before filling :: ', train.years_in_current_job.isna().sum())\n\n# Displaying total unique values present \n\ntrain.years_in_current_job.value_counts(dropna = False)","5ff4add8":"### Since NaN values present hence filling it using ffill and bfill \n\ntrain.years_in_current_job.fillna(method = 'ffill', inplace = True)\ntrain.years_in_current_job.fillna(method = 'bfill', inplace = True)\n\n\n# Checking for NaN values present\nprint('Total NaN values present after filling :: ', train.years_in_current_job.isna().sum())\n\ntrain.years_in_current_job.value_counts(dropna = False)","408ade6d":"# Visualizing to see its relationship with other columns\n\nplt.figure(figsize = (20,8))\nsns.barplot(x = train.number_of_credit_problems, y = train.annual_income, data = train)","261def79":"plt.figure(figsize = (20,8))\nsns.barplot(x = train.purpose, y = train.annual_income, data = train)","73dd14e2":"# Again visualizing \n\nplt.figure(figsize = (20,8))\nsns.barplot(x = train.years_in_current_job, y = train.annual_income, data = train)","bbdcc807":"plt.figure(figsize = (20,8))\nsns.barplot(x = train.number_of_open_accounts, y = train.annual_income, data = train)","6ae82bd4":"# Displaying total unique values\n\ntrain.annual_income.value_counts(dropna = False)","88210693":"val = train.groupby(['purpose','years_in_current_job'])['annual_income']\nval.agg([np.mean, np.median, np.size])","56612fd6":"#tranforming\/applying mean values to corresponding rows with missing values\n\ntrain.annual_income = val.transform(lambda x : x.fillna(x.median()))\ntrain.annual_income = train.annual_income.fillna(method = 'ffill')\n# Checking for NaN values present\n\nprint('Total NaN values present after filling :: ', train.annual_income.isna().sum())\n\n#Displaying values\n\ntrain.annual_income.value_counts(dropna = False)","c61c8330":"plt.figure(figsize = (20,8))\nsns.boxplot(train.annual_income, data = train)","b44a753f":"# Displaying total unique values\n\ntrain.credit_score.value_counts(dropna = False)","80daea0f":"plt.figure(figsize = (17,7))\nsns.barplot(x = train.tax_liens, y = 'credit_score', data = train)","344990f0":"plt.figure(figsize = (17,7))\nsns.barplot(x = train.term, y = 'credit_score', hue = train.years_in_current_job,data = train)","8ac4c66c":"plt.figure(figsize = (17,7))\nsns.barplot(x = 'years_in_current_job', y = 'credit_score', hue = train.tax_liens,data = train)","9b943708":"plt.figure(figsize = (17,7))\nsns.barplot(x = 'home_ownership', y = 'credit_score', data = train)","8c69f199":"plt.figure(figsize = (17,7))\nsns.barplot(x = train.bankruptcies, y = 'credit_score',data = train)","3b933543":"plt.figure(figsize = (20,8))\nsns.boxplot(x = train.credit_score, y = train.years_in_current_job \t, data = train)","39eaf996":"plt.figure(figsize = (17,7))\nsns.barplot(x = train.number_of_credit_problems, y = 'credit_score', data = train)","9b40cd0f":"train.credit_score.value_counts(dropna = False)","152b6c8d":"mean_score2 = train.groupby('purpose')['credit_score']\n\nmean_score2.agg(np.median)             # Since value are close so using this","2743d2c8":"train.credit_score = pd.Series(mean_score2.transform(lambda x : x.fillna(value = x.median())))\n\n# Since one category has no values in barchart hence using ffill to fill it\n#train.credit_score.fillna(method = 'ffill', inplace = True)\n\n# Checking for NaN values present\n\nprint('Total NaN values present after filling :: ', train.credit_score.isna().sum())","3f07d1fb":"#Displaying values\n\ntrain.credit_score.value_counts(dropna = False)","7c5dd586":"# Checking for NaN values\n\ntrain.agg(lambda x : x.isna().sum())","2423cc7e":"train_int_cols = list(train.select_dtypes(include = np.number).columns)\ntrain_obj_cols = list(train.select_dtypes(include = np.object).columns) ","bda3b587":"# Plotting all int\/float columns boxplot\n\nplt.figure(figsize = (20,15))\nsns.boxplot(data = train[train_int_cols], orient = 'h')","7cacf9ba":"train_int_cols","2fe4d19d":"# dropping last item\ntrain_int_cols_temp = train_int_cols[ :-1]\ntrain_int_cols_temp\n\ntrain[train_int_cols_temp]= train[train_int_cols_temp].transform(lambda x : np.log(x + 1))\ntrain[train_int_cols_temp].isna().sum()","554c728b":"# Plotting all int\/float columns boxplot\n\nplt.figure(figsize = (20,15))\nsns.boxplot(data = train[train_int_cols], orient = 'h')","b9c989f9":"cols = ['annual_income', 'maximum_open_credit', 'current_loan_amount', 'current_credit_balance', 'monthly_debt']\n\ntrain[cols].plot(kind = 'box', figsize = (20,15))","0afbcfcd":"train[train_int_cols].describe().T","06c991e5":"train[train_obj_cols].isna().sum()","38078168":"dummy = pd.get_dummies(train[train_obj_cols])\ndummy.T","0b0f4757":"train_final = pd.concat([train[train_int_cols], dummy], axis = 1)\ntrain_final","e5ee40a3":"x = train_final.drop('credit_default', axis = 1)\ny = train_final.credit_default","2004ffd8":"from sklearn.model_selection import train_test_split\n\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 100)","c89dcbcb":"from sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble  import RandomForestClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.svm import SVC","2b541a61":"model_dt = DecisionTreeClassifier(random_state = 10)\nmodel_rf = RandomForestClassifier(random_state = 11)\nmodel_knn = KNeighborsClassifier(n_neighbors = 10, n_jobs = -1)\n#model_lr = LogisticRegression(random_state = 12)\nmodel_nb = GaussianNB()\nmodel_svc = SVC(random_state = 14)","33046cf8":"train_final.credit_default.value_counts()","1a39a854":"from sklearn.metrics import accuracy_score, classification_report\n\nscore_values = []\ndef modelling(models, x_train, y_train, x_test, y_test):\n    for model in models:\n        model.fit(x_train, y_train)\n        predict = model.predict(x_test)\n        score = accuracy_score(y_test, predict)\n        score_values.append(score)\n        print(f\"Accurace score of {model} is :: \", score)\n        print(f\"Classification Report is :: \\n\")\n        print(classification_report(y_test, predict))\n        print('*' * 90)\n\n        \n# using the function\n\nmodels = [model_dt, model_knn, model_nb, model_rf, model_svc]\nmodelling(models, x_train, y_train, x_test, y_test)","8a0bddd1":"from sklearn.metrics import roc_auc_score, roc_curve\n\n# calculating log probabilities of models used\n\nprob_dt = model_dt.predict_proba(x_test)\nprob_rf = model_rf.predict_proba(x_test)\nprob_knn = model_knn.predict_proba(x_test)\nprob_nb = model_nb.predict_proba(x_test)\n","40ac6b06":"# Keep Probabilities of the positive class only.\n\nprob_dt = prob_dt[:, 1]\nprob_rf = prob_rf[:, 1]\nprob_knn = prob_knn[:, 1]\nprob_nb = prob_nb[:, 1]","d8536910":"# Calculating the auc score and displaying it\n\nauc_dt = roc_auc_score(y_test, prob_dt)\nauc_rf = roc_auc_score(y_test, prob_rf)\nauc_knn = roc_auc_score(y_test, prob_knn)\nauc_nb = roc_auc_score(y_test, prob_nb)\n\nprint('ROC- AUC Score for Decision Tree is :: %0.3f'%auc_dt)\nprint('ROC- AUC Score for Random Forest is :: %0.3f'%auc_rf)\nprint('ROC- AUC Score for KNN is :: %0.3f'%auc_knn)\nprint('ROC- AUC Score for Niave Bayes is :: %0.3f'%auc_nb)","7c2a3484":"# Getting the ROC Curve.\n\nfpr_dt, tpr_dt, threshold_dt = roc_curve(y_test, prob_dt)\nfpr_rf, tpr_rf, threshold_rf = roc_curve(y_test, prob_rf)\nfpr_knn, tpr_knn, threshold_knn = roc_curve(y_test, prob_knn)\nfpr_nb, tpr_nb, threshold_nb = roc_curve(y_test, prob_nb)","3183a7ca":"# Plotting the ROC Curve for all models \n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nplt.figure(figsize = (15,7))\nplt.plot(fpr_dt, tpr_dt, linewidth = 2, linestyle = 'dotted', label = 'Decision Tree')\nplt.plot(fpr_rf, tpr_rf, linewidth = 2, linestyle = 'dashdot', label = 'Random Forest')\nplt.plot(fpr_knn, tpr_knn, linewidth = 2, linestyle = 'dashed', label = 'K-Neighbours')\nplt.plot(fpr_nb, tpr_nb, linewidth = 2, linestyle = '-', label = 'Naive Bayes')\n\nplt.title('Receiver Operating Characteristic Curve (ROC AUC) Curve', fontsize = 25)\nplt.xlabel('False Positive Rate', fontsize = 20)\nplt.ylabel('True Positive Rate', fontsize = 20)\nplt.legend(fontsize = 16)\nplt.show()","d29e7717":"from scipy.stats import mode\n\n# Filling with mode value\n\ntest.bankruptcies =  test.bankruptcies.agg(lambda x : x.fillna(value = mode(x).mode[0]))\n\n# Checking for NaN values present\n\nprint('Total NaN values present after filling :: ', test.bankruptcies.isna().sum())\n","c3920618":"# Checking values before the filled values \n\ntest['months_since_last_delinquent'].value_counts(dropna = False)","b7a24cdf":"# Grouping months_since_last_delinquent columns as per  'purpose', 'home_ownership'\n\nmean_score_t = test.groupby(['purpose', 'home_ownership'])['months_since_last_delinquent']\nmean_score_t.agg([np.median])","99e59a38":"test.loc[: , 'months_since_last_delinquent'] = mean_score_t.transform(lambda x : x.fillna(x.median()))\n\n#Using ffill to fill any left missing value\n\ntest.months_since_last_delinquent = test.months_since_last_delinquent.fillna(method = 'ffill')\n# Checking for NaN values present\n\nprint('Total NaN values present after filling :: ', test.months_since_last_delinquent.isna().sum())","7a923b57":"print('Total NaN values present before filling :: ', test.years_in_current_job.isna().sum())\n\n# Displaying total unique values present \n\ntest.years_in_current_job.value_counts(dropna = False)","f6e087a9":"### Since NaN values present hence filling it using ffill and bfill \n\ntest.years_in_current_job.fillna(method = 'ffill', inplace = True)\ntest.years_in_current_job.fillna(method = 'bfill', inplace = True)\n\n\n# Checking for NaN values present\nprint('Total NaN values present after filling :: ', test.years_in_current_job.isna().sum())\n\ntest.years_in_current_job.value_counts(dropna = False)","044aa76d":"# Displaying total unique values\n\ntest.annual_income.value_counts(dropna = False)","8f0b8896":"#tranforming\/applying mean values to corresponding rows with missing values\n\ntest.annual_income = test.groupby('years_in_current_job')['annual_income'].transform(lambda x : x.fillna(x.mean()))\n\n# Checking for NaN values present\n\nprint('Total NaN values present after filling :: ', test.annual_income.isna().sum())\n\n#Displaying values\n\ntest.annual_income.value_counts(dropna = False)","5326511a":"# Displaying total unique values\n\ntest.credit_score.value_counts(dropna = False)","57769204":"mean_score_t2 = test.groupby('purpose')['credit_score']\n\nmean_score_t2.agg(np.median)             # Since value are close so using this","21f02715":"test.credit_score = mean_score_t2.transform(lambda x : x.fillna(value = x.median()))\n\n# Since one category has no values in barchart hence using ffill to fill it\n#train.credit_score.fillna(method = 'ffill', inplace = True)\n\n# Checking for NaN values present\n\nprint('Total NaN values present after filling :: ', test.credit_score.isna().sum())","3a1c3126":"#Displaying values\n\ntest.credit_score.value_counts(dropna = False)","8344ecc9":"# Checking for NaN values\n\ntest.agg(lambda x : x.isna().sum())","d055013f":"test_int_cols = list(test.select_dtypes(include = np.number).columns)\ntest_obj_cols = list(test.select_dtypes(include = np.object).columns) ","e38d5937":"# Plotting all int\/float columns boxplot\n\nplt.figure(figsize = (20,15))\nsns.boxplot(data = test[test_int_cols], orient = 'h')","847b3696":"test_int_cols","2f1c73e3":"test[test_int_cols]= test[test_int_cols].transform(lambda x : np.log(x + 1))\ntest[test_int_cols].isna().sum()","bd8c36bc":"# Plotting all int\/float columns boxplot\n\nplt.figure(figsize = (20,15))\nsns.boxplot(data = test[test_int_cols], orient = 'h')","e759d4ca":"test[test_int_cols].describe().T","f37d4a98":"test[test_obj_cols].isna().sum()","4debcf4b":"dummy_t = pd.get_dummies(test[test_obj_cols])\ndummy_t.T","b5a9db47":"test_final = pd.concat([test[test_int_cols], dummy_t], axis = 1)\ntest_final.T","0ca6ba95":"## Filling missing values of 'months_since_last_delinquent' column","dfac24b6":"## Changing Names of columns ::","aa560bde":"---\n# Missing Values Imputation ::","535d4222":"## Filling missing values of Annual Income column\n\n- Annual Income and Monthly debt are highly correlated :: 0.58\n- Annual Income and Current credti balance also related :: 0.38\n- So considering both columns to fill missing values of annual income column","2419a645":"# Performing Analysis of the dataset","988956f8":"## Filling 'years_in_current_job'  column ::","21bcf1d7":"submission_result_dt = pd.DataFrame({'Id': test_final.index, 'Credit Default' : prediction_dt})\nsubmission_result_dt.to_csv('submission_result_dt.csv', index=False)\n\nsubmission_result_knn = pd.DataFrame({'Id': test_final.index, 'Credit Default' : prediction_knn})\nsubmission_result_knn.to_csv('submission_result_knn.csv', index=False)\n\nsubmission_result_nb = pd.DataFrame({'Id': test_final.index, 'Credit Default' : prediction_nb})\nsubmission_result_knn.to_csv('submission_result_nb.csv', index=False)\n\nsubmission_result_rf = pd.DataFrame({'Id': test_final.index, 'Credit Default' : prediction_rf})\nsubmission_result_knn.to_csv('submission_result_rf.csv', index=False)\n\nsubmission_result_svc = pd.DataFrame({'Id': test_final.index, 'Credit Default' : prediction_svc})\nsubmission_result_knn.to_csv('submission_result_svc.csv', index=False)","e030baf7":"## Printing all unique values present in corresponding columns","2b0b91e5":"- Since the some values seems to be an outlier hence taking log of all values\n- Since some values in column are zero hence adding 1 to every value since log(1) == 0\n- Also taking first those columns that have big values in respective columns","58243ca5":"## Filling missing values of 'months_since_last_delinquent' column","4e9bb80f":"## Filling 'years_in_current_job'  column ::","5de2f31e":"## Filling missing values of Annual Income column\n\n- Annual Income and Monthly debt are highly correlated :: 0.58\n- Annual Income and Current credti balance also related :: 0.38\n- So considering both columns to fill missing values of annual income column","9abe1aaa":"## Filling missing values of 'bankruptcies' column","814c89ac":"### Since target variable is also present in integer columns hence dropping it before transfoming the values. ","984de4d1":"- Maimum Open credit has some outliers hence treating it first","8fd3deef":"## Selecting columns with missing values and observing their relationships with other features","df6eac93":"## Observation :: \n        \n- Months increase with increase in bankrupcies\n- So both are highly dependent to each other\n- We can try to fill the missing months with respective bankrupcies\n- Since bankruptcies also has missing values hence filling it with mode value","8f38aba2":"---\n# Missing Values Imputation ::","b64fbabb":"## Visualizing to see its relationship with other categorial features","702d1ca7":"# Data Visualization ::","5d518fa5":"## Filling 'annual_income' column ::","51d8f612":"- Since the some values seems to be an outlier hence taking log of all values\n- Since some values in column are zero hence adding 1 to every value since log(1) == 0\n- Also taking first those columns that have big values in respective columns","70a335ee":"### Since target variable is also present in integer columns hence dropping it before transfoming the values. ","7321c68a":"- Maimum Open credit has some outliers hence treating it first","df7142d2":"## Observation ::\n\n- number_of_credit_problems, tax_liens, bankruptcies have abnormally distributed values hence we can't use these column in filling missing values\n- purpose has nearly normally distributed values hence it can be used","d83d6545":"## Visualizing all three column : annual_income, current_credit_balance, monthly_debt","c7b7efed":"prediction_dt = model_dt.predict(test_final)\nprediction_knn = model_knn.predict(test_final)\nprediction_nb = model_nb.predict(test_final)\nprediction_rf = model_rf.predict(test_final)\nprediction_svc = model_svc.predict(test_final)","a833d186":"- Seems that all values have been taken care of. Now proceeding further","5a2adb80":"## Filling 'credit_score' column ::","d389ecef":"# filling missing values using forward fill and backward fill method\n\ntrain.months_since_last_delinquent = train.months_since_last_delinquent.fillna(method = 'ffill', limit = 3)\ntrain.months_since_last_delinquent = train.months_since_last_delinquent.fillna(method = 'bfill', limit = 3)\n\ntrain['months_since_last_delinquent'].isna().sum()\n#train['months_since_last_delinquent'].value_counts(dropna = False).sort_values(ascending = False).head(30)","84564b60":"### Since Renewable energy category is missing in test data so after converting it in dummy variable it will create a mismatch in modelling. Since number of columns in dummy variable will be one less . Hence dropping it now.","82ecda33":"# Data Visualization for Outliers ::","41c9149c":"- Seems that all values have been taken care of. Now proceeding further","18b468aa":"# Performing actions on Test Data ::","b0389236":"## Observation ::\n\n- SVC and RandomForest have same accuracy = 77%\n- naive Bayes have accuracy = 75%\n- Knn have accuracy = 76%\n- Decision Tree have accuracy = 69%","e47893b1":"## Filling missing values of 'bankruptcies' column","47321f7d":"## Filling 'credit_score' column ::","245af8da":"## Dataframe with dataset info","7e455c96":"# Data Visualization for Outliers ::","40db8aa2":"# Making Models ::","703b35b4":"## Filling 'annual_income' column ::"}}