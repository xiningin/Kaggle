{"cell_type":{"7fce72a7":"code","80f2cae0":"code","5d3daaa9":"code","866312cc":"code","88442aca":"code","795cb31c":"code","1acfb1be":"code","8027e307":"code","2e07d3f6":"code","e26ee64c":"code","06fdc82c":"code","2c9d8947":"markdown","5b2c78a3":"markdown","ffdd4016":"markdown","e9fee730":"markdown","16b70eb2":"markdown","7ec6d435":"markdown","bc579140":"markdown","6708dc93":"markdown","7d7525fe":"markdown","3e2db896":"markdown","3ec4482a":"markdown","683ff9d8":"markdown","2ea7e5cb":"markdown"},"source":{"7fce72a7":"def iterative_counter(initial_value):\n    num = initial_value\n    # 1. The condition\n    while (num < 5):\n        \n        # 2 The operation\n        print(num, end=\" \")\n        \n        # 3. The increment\n        num += 1\n    \ndef recursive_counter(num):\n    # 1. The base case\n    if (num >= 5):\n        return\n    \n    # 2. The operation\n    print(num, end=\" \")\n    \n    # 3. The recursive call\n    recursive_counter(num + 1)\n\nprint(\"Iteration: \")\niterative_counter(0)\n\nprint(\"\\nRecursion: \")\nrecursive_counter(0)","80f2cae0":"class BinaryTreeNode:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n        \nbinary_tree = BinaryTreeNode(1, \n                             BinaryTreeNode(2, BinaryTreeNode(3), BinaryTreeNode(4)), \n                             BinaryTreeNode(5))","5d3daaa9":"def binary_tree_preorder_traversal(node):\n    # 1. The base case\n    if node is None:\n        return\n    \n    # 2. The operation\n    print(node.value, end=\" \")\n    \n    #3. The recursive call(s)\n    binary_tree_preorder_traversal(node.left)\n    binary_tree_preorder_traversal(node.right)\n\nbinary_tree_preorder_traversal(binary_tree)","866312cc":"def binary_tree_inorder_traversal(node):\n    # 1. The base case\n    if node is None:\n        return\n    \n    # 3. The recursive call part 1\n    binary_tree_inorder_traversal(node.left)\n    \n    # 2. The operation\n    print(node.value, end=\" \")\n    \n    # 3. The recursive call part 2\n    binary_tree_inorder_traversal(node.right)\n\nbinary_tree_inorder_traversal(binary_tree)","88442aca":"def binary_tree_postorder_traversal(node):\n    # Implement here\n    return\n    \nbinary_tree_inorder_traversal(binary_tree)","795cb31c":"def add_one_binary_tree(node):\n    # Implement here\n    return None\n    \n    \n# I will make a copy of the binary tree for your method to mutate\nimport copy\nnew_binary_tree = copy.deepcopy(binary_tree)\nadd_one_binary_tree(new_binary_tree)\n\n# Print an answer\nbinary_tree_preorder_traversal(new_binary_tree)","1acfb1be":"def depth_first_search(node, search_value):\n    # 1. The base case\n    if node is None:\n        return None;\n    \n    # 2. The operation\n    if node.value == search_value:\n        return node\n    \n    # 3. The recursive call(s)\n    left = depth_first_search(node.left, search_value)\n    if left is not None:\n        return left\n    \n    right = depth_first_search(node.right, search_value)\n    if right is not None:\n        return right","8027e307":"def leftmost_value(node):\n    # 1. Base Case\n\n    # 2. Operation - If I can't go left anymore, I am the leftmost.\n    if node.left is None:\n        return node.value;\n    \n    # 3. Recursive Case\n    \n\nprint(leftmost_value(binary_tree))","2e07d3f6":"def count_nodes(node):\n    # 1. Base case\n    if node is None:\n        return 0\n    \n    # 3. Recursive calls\n    left_node_count = count_nodes(node.left)\n    right_node_count = count_nodes(node.right)\n    \n    #2. The operation (Post-Order)\n    subtree_node_count = left_node_count + right_node_count + 1\n    return subtree_node_count\n\ncount_nodes(binary_tree)","e26ee64c":"def sum_nodes(node):\n    # 1. Base case\n    if node is None:\n        return 0\n\n    # Implement here\n    \n\nprint(sum_nodes(binary_tree))","06fdc82c":"def find_max_value(node):\n    # 1. Base case\n    if node is None:\n        return 0\n    \n    # 3 Recursive calls\n    left_max = find_max_value(node.left)\n    right_max = find_max_value(node.right)\n    \n    # 2. Operation (post-order)\n    my_max = node.value\n    if left_max > my_max:\n        my_max = left_max\n    if right_max > my_max:\n        my_max = right_max\n        \n    return my_max\n    \nprint(\"For a positive tree, I found:\")\nprint(find_max_value(binary_tree),)\n\nnegative_binary_tree = BinaryTreeNode(-2, BinaryTreeNode(-3), BinaryTreeNode(-4))\nprint(\"For a negative tree, I found:\")\nprint(str(find_max_value(negative_binary_tree)) + \" (expected: -2)\")\n\n","2c9d8947":"Choosing a good base case can be tricky!\n\n**Exercise 7**\n\nThe following function does not work correctly because a bad base case was chosen.\n\n*Hint: If you decide to return None from the base case, make sure to handle the possibility that left_max or right_max could be none!*\n\nExpected: -2","5b2c78a3":"First, we defined a *preorder* traversal that would print a node, then print the left subtree, then print the right subtree. Next, we defined an *inorder* traversal which prints the left subtree first, then the node, then the right subtree. An inorder traversal is very important for iterating over a *binary search tree* which is a tree where the left subtree is smaller than the node and the right subtree is all greater than the node. \n\n**Exercise 2**\n\nImplement a *postorder* traversal. In a post-order traversal, the subtrees will be printed before the node.\n\nExpected output: 3 4 2 5 1","ffdd4016":"### Other tree problems\nThere is a broad class of tree problems that require you to process a tree in some way.\n\nThis class of problems is most commonly solved with a post-order approach.\n\nIn the following problem, we are asked to count the number of nodes in a binary tree. It can help to think locally. Think like node function, and the solution emerges:\n\n\"I only know one node\"  \n\"I have a function that counts nodes\"  \n\"I will use that function to find out how many nodes are on my left\"  \n\"I will use that function to find out how many nodes are on my right\"  \n\"My subtree has that many nodes, plus one, for me\"  \n","e9fee730":"### Depth First Search (DFS)\nThe next foundational recursive algorithm is the depth first search. This section will introduce the idea of returning values back up the recursive stack. A depth first search looks like this:","16b70eb2":"A DFS algorithm returns a node who matches some condition (in this case, values must match). However, the node you're looking for probably isn't the root node. In that case, you have to return the values back up the stack. That's what is happening in the recursive calls. \n\nTo help practice returning things up the stack, complete the following exercise on returning values.\n\n**Exercise 4**\n\nFinish implementing the following recursive function which returns the most-left value in a tree.\n\nExpected Output: 3","7ec6d435":"When thinking about binary trees, you will likely read about these three traversals:\n1. Preorder *Node, Left, Right*\n2. Inorder *Left, Node, Right*\n3. Postorder *Left, Right, Node*\n\nGenerally, for a tree problem, always visit the left before the right unless there\nis a good reason to do otherwise. \n\nA traversal doesn't have to only print, and in some cases you might be asked to modify the tree.\n\n**Exercise 3**\n\nImplement a recursive method that will add 1 to every node.\n\n*Hint: Follow the pattern of any of the three traversals above, but replace the operation to update node.value in place*\n\nExpected Output: 2 3 4 5 6\n","bc579140":"** Exercise 1**\n\nIn the recursive example above, the base case in an inversion of the while conditional, because it is a **stopping** conditional whereas the while is a **continuing** conditional. *Refactor* the recursive method to use the same conditional as the while loop. Remember that if you invert the conditional, you'll need to put the recursive call and operation both inside the if block.","6708dc93":"#Recursion\nThis Kernel will attempt to guide you through learning the basics of recursion. You will learn:\n1. Some intuition on approaching recursive algorithms\n2. The basic structure of a recursive solution\n3. Recursive primitives like traversals and depth first search\n4. Additional recursive building blocks for graph search and dynamic programming\n5. How to modify and combine recursive primitives to solve most problems\n6. How to approach more complex recursive problems on your own\n\n**Prerequisites**\n1. You should already have a basic understanding of python, including loops, classes and functions.\n2. You should know about theses data structures and common variants: trees, graphs, lists, linked lists, dictionaries","7d7525fe":"## Section 1 - Thinking Recursively\nRecursion is powerful because we can solve hard problems by thinking small. When done correctly, thinking recursively will make you feel like a wizard. You follow a few steps and a solution to a complex problem will magically emerge. That is how I feel when I approach and solve a challenging recursion problem. You will too, with a bit of practice.\n\n### What is recursion?\nFundamentally, recursion is the act of a function calling itself. There are many reasons to use recursion, but in my experience, these are the main classes of recursion you're likely to encounter in a job or interview:\n1. Graphs\n2. Trees\n3. Loops\n4. Branching algorithms* (basically trees)\n\n*TODO: I need to expand on this section. Please upvote the kernel if you find it useful**","3e2db896":"## Section 3 - Recursive Primitives\nThis section aims to cover a few basic recursion algorithms that will form the basis of most of the recursive solutions you ever write\n\n### Tree Traversal\nOne of the most foundational algorithms is the *traversal*. In this case, we'll use a binary tree as the thing to traverse:","3ec4482a":"## Section 2 - The Basic Structure of a Recursive Solution\nA recursive function generally has three parts:\n1. **A base case** - A statement that prevents the recursion from running indefinitely\n2. **An operation** - Do the main thing you're writing your solution to do\n3. **A recursive call** - Now recurse\n\nIn an interative world these are roughly equivalent to:\n1. A condition\n2. An operation (loop body)\n3. An increment\n\nThe following two functions are analagous. See how #1, #2 and #3 align.","683ff9d8":"The following exercises will help you practice:\n\n**Exercise 5**\n\nFinish implementing a recursive function that returns the sum of all nodes in a binary tree:\n\nExpected: 15","2ea7e5cb":"The traversal above follows the structure as any other recursion. It has a base case, an operation and a recursive call. Here, we have two recursive calls, allowing our algorithm to print both children nodes.\n\nRecursive methods generallly have three parts, but the parts don't have to be in order. For example, we could print our nodes in a different order by splitting up the recursive calls!"}}