{"cell_type":{"673ebac8":"code","0b4994bc":"code","ce930bdb":"code","9a4e3d37":"code","4fbc6ab4":"code","68c39e09":"code","b7f31924":"code","f1912170":"code","dbb9437b":"code","0a28e87d":"code","60d5aa94":"code","aa739568":"code","f87cd19a":"code","532d64c3":"code","110c77fe":"code","5c9ffed7":"code","46407acd":"code","ad4774aa":"code","d2e2a38c":"markdown","d1fb5eda":"markdown","77197e7e":"markdown","d2f9bae5":"markdown","c98bc694":"markdown","92638e45":"markdown","9e321972":"markdown","9e9d7cd8":"markdown","66463f45":"markdown","aa4ec270":"markdown","39f9b4c0":"markdown"},"source":{"673ebac8":"from __future__ import annotations\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.express as px\nfrom tqdm import tqdm\nfrom typing import *\nplt.rcParams[\"figure.figsize\"] = (10, 10)\nplt.rcParams[\"figure.dpi\"] = 125\nplt.rcParams[\"font.size\"] = 14\nplt.rcParams['font.family'] = ['sans-serif']\nplt.rcParams['font.sans-serif'] = ['DejaVu Sans']\nplt.style.use('ggplot')\nsns.set_style(\"whitegrid\", {'axes.grid': False})\nplt.rcParams['image.cmap'] = 'magma' # we do mostly heatmaps so this looks best\n%matplotlib inline","0b4994bc":"import attr\nimport enum\nfrom scipy.ndimage import label, binary_dilation\n\nHEX_MOVE_EL = np.array([[0, 1, 1], [1, 1, 1], [1, 1, 0]])\n\n\nclass NoValidMoveException(Exception):\n    \"\"\"No valid moves remaining.\"\"\"\n\n\nclass Player(enum.IntEnum):\n    empty = enum.auto()\n    x = enum.auto()\n    y = enum.auto()\n\n\n@attr.s(frozen=True, slots=True, auto_attribs=True, kw_only=True, repr=False)\nclass HexBoard:\n    board: np.ndarray  # (n, n)\n    move_history: Optional[Tuple[Tuple[Player, int, int], ...]] = None\n    \n    win_state: Optional[Player]\n    move_count: int = 0\n    last_player: Player = Player.empty\n\n    @staticmethod\n    def create(n: int) -> HexBoard:\n        return HexBoard(\n            board=np.full((n, n), Player.empty, dtype=\"uint8\"),\n            move_history=tuple(),\n            win_state=Player.empty,\n        )\n\n    def move(\n        self, *, p: Optional[Player] = None, i: int, j: int, validate: bool = True\n    ) -> HexBoard:\n        if p is None:\n            assert (\n                self.last_player!=Player.empty\n            ), \"Must specify player for first move!\"\n            p = Player.x if self.last_player == Player.y else Player.y\n        if validate:\n            assert (\n                self.board[i, j] == Player.empty\n            ), f\"Player {p.name} is moving into an occupied position {(i,j)}={Player(self.board[i,j]).name}\"\n            if len(self.move_history) > 0:\n                assert (\n                    self.last_player != p\n                ), f\"Player {p.name} is moving out of order\"\n\n        board = self.board.copy()\n        board[i, j] = p\n        if self.move_history is not None:\n            move_history = self.move_history + ((p, i, j),)\n        else:\n            move_history = self.move_history\n        return HexBoard(\n            board=board,\n            move_history=move_history,\n            move_count=self.move_count + 1,\n            win_state=HexBoard._check_win(board),\n            last_player=p\n        )\n\n    def random_move(\n        self, p: Optional[Player] = None, *, open_board: Optional[np.ndarray] = None\n    ) -> HexBoard:\n        if p is None:\n            assert (\n                self.move_history is not None and len(self.move_history) > 0\n            ), \"Must specify player for first move!\"\n            p = Player.x if self.move_history[-1][0] == Player.y else Player.y\n        if open_board is None:\n            open_board = self.board == Player.empty\n        i_open, j_open = np.where(open_board)\n        if len(i_open) < 1:\n            raise NoValidMoveException()\n        move_idx = np.random.randint(0, len(i_open))\n        return self.move(p=p, i=i_open[move_idx], j=j_open[move_idx])\n\n    def get_proximal_moves(self, p: Player, *, hops: int = 2):\n        return binary_dilation(\n            self.board == p, structure=HEX_MOVE_EL, iterations=hops\n        ) * (self.board == Player.empty)\n\n    def random_proximal_move(\n        self, p: Optional[Player] = None, hops: int = 2, *, expand: bool = False\n    ) -> HexBoard:\n        if p is None:\n            assert (\n                self.move_history is not None and len(self.move_history) > 0\n            ), \"Must specify player for first move!\"\n            p = Player.x if self.move_history[-1][0] == Player.y else Player.y\n        hop_moves = self.get_proximal_moves(p, hops=hops)\n        while expand and hop_moves.sum() < 1:\n            hops += 1\n            hop_moves = self.get_proximal_moves(p, hops=hops)\n        return self.random_move(p, open_board=hop_moves)\n\n    def random_proximal_moves(\n        self,\n        *,\n        moves: int,\n        p: Optional[Player] = None,\n        hops: int = 2,\n        check_win: bool = True,\n    ):\n        out_board = self\n        for i in range(moves):\n            out_board = out_board.random_proximal_move(p=p, hops=hops, expand=True)\n            if p is not None:\n                p = None\n            if out_board.win_state != Player.empty:\n                return out_board\n        return out_board\n\n    def random_moves(self, *, moves: int, p: Optional[Player] = None):\n        out_board = self\n        for i in range(moves):\n            out_board = out_board.random_move(p=p)\n            if p is not None:\n                p = None\n            if out_board.win_state != Player.empty:\n                return out_board\n        return out_board\n\n    def show(self) -> None:\n        fig, ax1 = plt.subplots(1, 1, figsize=(5, 5))\n        out_image = np.full(self.board.shape, np.NAN)\n        out_image[self.board == Player.x] = Player.x\n        out_image[self.board == Player.y] = Player.y\n        ax1.imshow(out_image, cmap=\"RdYlGn_r\")\n\n    def draw_board(self, *, ax1=None, draw_boxes: bool = True):\n        if ax1 is None:\n            fig, ax1 = plt.subplots(1, 1, figsize=(5, 5))\n            ax1.axis(\"off\")\n        hex_box = np.array(\n            [\n                [-0.5, -0.5],\n                [0, -1],\n                [0.5, -0.5],\n                [0.5, 0.5],\n                [0, 1],\n                [-0.5, 0.5],\n                [-0.5, -0.5],\n            ]\n        )\n        x_offset = lambda i, j: i + 0.5 * j\n        y_offset = lambda i, j: 1.5 * j\n\n        if draw_boxes:\n            for i in range(self.board.shape[0]):\n                for j in range(self.board.shape[1]):\n                    ax1.plot(\n                        hex_box[:, 0] + x_offset(i, j),\n                        hex_box[:, 1] + y_offset(i, j),\n                        \"k-\",\n                    )\n\n        x_i, x_j = np.where(self.board == Player.x)\n        ax1.plot(\n            x_offset(x_i, x_j), y_offset(x_i, x_j), \"gs\", ms=10, label=\"Horizonal (X)\"\n        )\n        y_i, y_j = np.where(self.board == Player.y)\n        ax1.plot(\n            x_offset(y_i, y_j), y_offset(y_i, y_j), \"r*\", ms=10, label=\"Vertical (Y)\"\n        )\n        return ax1\n\n    @staticmethod\n    def _check_win(board) -> Player:\n        lab_map, lab_max = label(board == Player.x, HEX_MOVE_EL)\n        for i in range(1, lab_max + 1):\n            i_lab, _ = np.where(lab_map == i)\n            if i_lab.min() == 0 and i_lab.max() == board.shape[0] - 1:\n                return Player.x\n        lab_map, lab_max = label(board == Player.y, HEX_MOVE_EL)\n        for i in range(1, lab_max + 1):\n            _, j_lab = np.where(lab_map == i)\n            if j_lab.min() == 0 and j_lab.max() == board.shape[1] - 1:\n                return Player.y\n        return Player.empty\n\n    def check_win(self) -> Player:\n        if self.win_state is None:\n            win_state = self._check_win(self.board)\n        else:\n            win_state = self.win_state\n        if win_state == Player.y:\n            print(\n                f\"Player y wins! {len(self.move_history) if self.move_history else ''} moves\"\n            )\n        elif win_state == Player.x:\n            print(\n                f\"Player x wins! {len(self.move_history) if self.move_history else ''} moves\"\n            )\n        return win_state\n","ce930bdb":"out_board = HexBoard.\\\n    create(5).\\\n    move(p=Player.x, i=0, j=0).\\\n    move(i=4, j=4).\\\n    move(i=1, j=1)\nout_board.draw_board()","9a4e3d37":"one_game = out_board.random_proximal_moves(moves=50, hops=1)\none_game.check_win()\none_game.draw_board()","4fbc6ab4":"from dask import bag\nfrom dask import diagnostics as diag\nimport cloudpickle","68c39e09":"cloudpickle.loads(cloudpickle.dumps(out_board))","b7f31924":"def sim_board() -> HexBoard:\n        return out_board.random_proximal_moves(moves=50, hops=2)\nsim_board()","f1912170":"parallel=False\nif parallel:\n    with diag.ProgressBar():\n        sim_outputs = bag.\\\n            from_sequence(np.arange(20_000)).\\\n            map(sim_board).\\\n            compute()\nelse:\n    sim_outputs = []\n    for i in tqdm(range(20_000)):\n        sim_outputs.append(out_board.random_proximal_moves(moves=50, hops=2))","dbb9437b":"x_wins = [c for c in sim_outputs if c.win_state==Player.x]\ny_wins = [c for c in sim_outputs if c.win_state==Player.y]\nprint(f\"X wins: {len(x_wins)} vs y_wins: {len(y_wins)}\")","0a28e87d":"x_board_stats = np.mean([(c.board==Player.x)*(out_board.board==Player.empty) \n                     for c in x_wins], axis=0)\nsns.heatmap(x_board_stats,\n        fmt='2.0%',\n            annot=True\n           )","60d5aa94":"y_board_stats = np.mean([(c.board==Player.y)*(out_board.board==Player.empty) for c in y_wins], axis=0)\nsns.heatmap(y_board_stats,\n        fmt='2.0%',\n            annot=True\n           )","aa739568":"sns.heatmap(0.5*x_board_stats+0.5*y_board_stats,\n        fmt='2.0%',\n            annot=True\n           )","f87cd19a":"next_board = out_board.random_move(open_board=y_board_stats==y_board_stats.max())\nnext_board.draw_board()","532d64c3":"from itertools import cycle\nvalid_boards = sim_outputs\nare_more_boards = True\nfor c_player in cycle([Player.x, Player.y]):\n    if are_more_boards:\n        valid_boards = [c \n                        for c in valid_boards if np.all(c.board*(next_board.board!=Player.empty)==next_board.board*(next_board.board!=Player.empty))]\n    \n    \n    if len(valid_boards)==0:\n        are_more_boards = False\n        c_boards = sim_outputs\n    else:\n        c_boards = valid_boards\n        \n    cur_board_stats = np.mean([(c.board==c_player)*(next_board.board==Player.empty) \n                             for c in c_boards \n                               if c.win_state==c_player], \n                              axis=0)\n    out_str = f\"{c_player.name} win chances: {sum([c.win_state==c_player for c in valid_boards])}\/{len(valid_boards)}\"\n    \n    next_board = next_board.random_move(open_board=cur_board_stats==cur_board_stats.max())\n    next_board.draw_board().set_title(f\"{out_str}: {next_board.win_state.name}\")\n    print(out_str)\n    if next_board.check_win()!=Player.empty:\n        break\n    ","110c77fe":"sns.heatmap(cur_board_stats,\n        fmt='2.0%',\n            annot=True\n           )","5c9ffed7":"sim_opening_outputs = []\nfor i in range(20_000):\n    sim_opening_outputs.append(HexBoard.\\\n                                   create(5).\\\n                                   random_moves(p=Player.x, moves=2).\\\n                                   random_proximal_moves(moves=50, hops=2))\n    ","46407acd":"x_board_stats = np.mean([(c.board==Player.x)\n                     for c in sim_opening_outputs if c.win_state==Player.x], axis=0)\nsns.heatmap(x_board_stats,\n        fmt='2.0%',\n            annot=True\n           )","ad4774aa":"big_board = HexBoard.create(16).\\\n    random_moves(p=Player.x, moves=2).\\\n    random_proximal_moves(moves=200, hops=3)\nbig_board.check_win()\nbig_board.draw_board()","d2e2a38c":"# Graph-based Approach\nClearly for a bigger board an array approach becomes very inefficient and we need to switch to a graph-based approach","d1fb5eda":"## Analyze the positions x had in its victories\nWe ignore the currently occupied positions and the order we are just concerned about which positions ultimately mattered","77197e7e":"# Opening Moves\nWe can also simulate opening moves","d2f9bae5":"# Combined stats\nSince x cannot take positions y already has we can add the x positions to the y positions","c98bc694":"# Setup\n- Hex Board (basically NxN array)\n - Green (horizontal) and Red (vertical)  players\n- Visualizing Matches","92638e45":"## Simulate 5000 games\nHere we simulate 5000 games from the current position","9e321972":"# Iterate over many moves\nWe can continually pick the optimum move by recalculate the stats based on those which include the current board configuration. We estimate the likelihood of winning by counting # victory boards for the current player \/ # total number of boards. This is not a particularly useful method because it is random play and doesn't show for optimum or even sensible play what the stats would be.","9e9d7cd8":"## Analyze the positions y had in its victories","66463f45":"# Make the optimum best move","aa4ec270":"# Try Bigger Boards","39f9b4c0":"# Overview\nThe idea is to explore some of the ideas from reinforcement learning and gameplay using [Hex](https:\/\/en.wikipedia.org\/wiki\/Hex_(board_game)) and writing things mostly from scratch. This notebook focuses primarily on statistical approaches by just simulating lots and lots of games. The idea is to make a baseline for more clever deep learning-based models"}}