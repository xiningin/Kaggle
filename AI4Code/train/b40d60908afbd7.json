{"cell_type":{"0a00e641":"code","2fe8f0af":"code","442e9687":"code","992a5eb5":"code","fcf08e68":"code","205714e4":"code","f986e13e":"code","af59dccb":"code","6534bd02":"code","b4540455":"code","5a73d8fc":"code","2f439d74":"code","b373969e":"code","976f25df":"code","4250b931":"code","c2add4fc":"code","470f1965":"code","c784518e":"code","6cc5493e":"code","26d5ec23":"code","6df32001":"code","dbe15980":"code","40193ee5":"code","e14739f2":"code","26978ed3":"code","4242e244":"code","f25d6ff7":"code","62f644c3":"code","ba8c03e3":"code","316445d4":"code","68fb5a72":"code","07830995":"code","a85c5707":"code","e6c5ab05":"code","17eb36cd":"code","3cc8d209":"code","99701c86":"code","234f246b":"code","ea618ca1":"code","1759f06a":"code","c0acfbb4":"code","bc2f1a08":"code","add6f23d":"code","1380286e":"markdown","0314a465":"markdown","8ac010e2":"markdown","0aabe8e2":"markdown","137d6fa1":"markdown","d49e63f5":"markdown","a92bc0b3":"markdown","2645ebf0":"markdown","1250f76d":"markdown","6d5af1b7":"markdown","6d9c3d5f":"markdown","e3c02145":"markdown","fc30a522":"markdown","8688dad4":"markdown","848d8a11":"markdown","04e9ef68":"markdown","9e513dc1":"markdown","4071d608":"markdown","73423806":"markdown","f2cd4097":"markdown","4993bd2c":"markdown","54f54b0c":"markdown","0889c720":"markdown","1c77af7d":"markdown","412a7c5f":"markdown","a9106e18":"markdown","35e42ce8":"markdown"},"source":{"0a00e641":"!apt-get install -y libgdal-dev\n!gdal-config --version\n!export CPLUS_INCLUDE_PATH=\/usr\/include\/gdal\/\n!export C_INCLUDE_PATH=\/usr\/include\/gdal\/\n#!cp \/usr\/include\/gdal\/*.h \/usr\/include\/\n!cp -n \/usr\/include\/gdal\/*.h \/usr\/include\/\n#!ls \/usr\/include\/\n!pip install GDAL==2.1.0","2fe8f0af":"!pip install rioxarray Pyproj==2.4.1\n#lists all installed libraries\n#!pip freeze","442e9687":"!ls ..\/input\/cmems-bal-phy-reanalysis-monthlymeans\/Winter\/","992a5eb5":"from netCDF4 import Dataset\n\nnc_f = '..\/input\/cmems-bal-phy-reanalysis-monthlymeans\/Winter\/CMEMS_BAL_PHY_reanalysis_monthlymeans_200402.nc'\n#http:\/\/marine.copernicus.eu\/services-portfolio\/access-to-products\/?option=com_csw&view=details&product_id=BALTICSEA_REANALYSIS_PHY_003_011\nf = Dataset(nc_f, 'r')\n#f = netCDF4.Dataset(\"..\/input\/cmems-bal-phy-reanalysis-monthlymeans\/Winter\/CMEMS_BAL_PHY_reanalysis_monthlymeans_199403.nc\", 'r')\n\nprint(f , \"\\n\")\nprint(f['so'] , \"\\n\")","fcf08e68":"import xarray as xr\nimport numpy as np\n\nncPHY = xr.open_mfdataset(\"..\/input\/cmems-bal-phy-reanalysis-monthlymeans\/Winter\/CMEMS_BAL_PHY_reanalysis_monthlymeans_******.nc\", combine='by_coords')\n#print(ncPHY)\nprint(ncPHY['so'] , \"\\n\")\nprint(ncPHY['depth'] , \"\\n\")\nso_surf = ncPHY['so'].sel(depth=slice(0.0,2.0))\nso_surf_m = so_surf.mean(dim='time')\nprint(so_surf_m , \"\\n\")\n\nso_surf_m.to_netcdf(path=\"Sal_surf_m.nc\")\nprint(\"done\")","205714e4":"import rioxarray\nimport xarray as xr\n#https:\/\/corteva.github.io\/rioxarray\/html\/modules.html\n\nxso_surf_m = xr.open_dataset(\"Sal_surf_m.nc\")\nxso_surf_m.rio.set_crs(\"EPSG:4326\")\nprint(xso_surf_m['so'] , \"\\n\")\n\nxso_surf_m['so'].rio.to_raster(\"Sal_surf_m.tif\")\nprint(\"done\")","f986e13e":"!rm \/kaggle\/working\/Salinity_today.tif\nfrom osgeo import gdal\nfrom osgeo.gdalconst import GA_Update\n\n\n#reproject and resample tif\n#https:\/\/gdal.org\/python\/index.html\n#info EPSG http:\/\/www.epsg.org\/\nwarp_opts = gdal.WarpOptions(\n    format=\"GTiff\",\n    outputBounds = [4030000.000000002, 3400000.000000002, 5440000.000000002, 4830000.000000002],\n    outputBoundsSRS=\"EPSG:3035\",\n    resampleAlg=gdal.GRIORA_NearestNeighbour,\n    xRes=250,\n    yRes=250,\n    srcSRS=\"EPSG:4326\",\n    dstSRS=\"EPSG:3035\",\n    srcNodata=\"nan\",\n    dstNodata=-9999,\n)\n\nsrc = \"Sal_surf_m.tif\"\ninput_raster = gdal.Open(src)\ndst_temp = \"Salinity_today.tif\"\nprint(warp_opts)\nres = gdal.Warp(dst_temp,\n                input_raster,\n                options=warp_opts)\n\nres = None\ninput_raster = None\nprint(\"done\") ","af59dccb":"#from osgeo import gdal\n#from osgeo.gdalconst import GA_Update\n\ndst_temp = \"Salinity_today.tif\"\ninput_raster = gdal.Open(dst_temp, GA_Update)\ninput_raster_band1 = input_raster.GetRasterBand(1)\ngdal.FillNodata(input_raster_band1, maskBand = None, maxSearchDist = 10, smoothingIterations = 0)\ninput_raster = None\ninput_raster_band1 = None","6534bd02":"from osgeo import gdal\nimport matplotlib.pyplot as mpl\n\nds = gdal.Open('Salinity_today.tif').ReadAsArray()\ncmap = mpl.cm.jet\ncmap.set_under('w')\nim = mpl.imshow(ds,vmin=0.0, cmap=cmap)\nmpl.colorbar()\nmpl.title('Salinity today')","b4540455":"!rm \/kaggle\/working\/Sal_surf_m.nc\n!rm \/kaggle\/working\/Sal_surf_m.tif","5a73d8fc":"from netCDF4 import Dataset\n\nnc_f = '..\/input\/cmems-bal-phy-reanalysis-monthlymeans\/Winter\/CMEMS_BAL_PHY_reanalysis_monthlymeans_200402.nc'\n#http:\/\/marine.copernicus.eu\/services-portfolio\/access-to-products\/?option=com_csw&view=details&product_id=BALTICSEA_REANALYSIS_PHY_003_011\nf = Dataset(nc_f, 'r')\n#f = netCDF4.Dataset(\"..\/input\/cmems-bal-phy-reanalysis-monthlymeans\/Winter\/CMEMS_BAL_PHY_reanalysis_monthlymeans_199403.nc\", 'r')\n\nprint(f , \"\\n\")\nprint(f['thetao'] , \"\\n\")","2f439d74":"import xarray as xr\nimport numpy as np\n\nncPHY = xr.open_mfdataset(\"..\/input\/cmems-bal-phy-reanalysis-monthlymeans\/Winter\/CMEMS_BAL_PHY_reanalysis_monthlymeans_******.nc\", combine='by_coords')\n#print(ncPHY)\nprint(ncPHY['thetao'] , \"\\n\")\nprint(ncPHY['depth'] , \"\\n\")\nthetao_surf = ncPHY['thetao'].sel(depth=slice(0.0,2.0))\nthetao_surf_m = thetao_surf.mean(dim='time')\nprint(thetao_surf_m , \"\\n\")\n\nthetao_surf_m.to_netcdf(path=\"Temperature_surf_m.nc\")\nprint(\"done\")","b373969e":"import rioxarray\nimport xarray as xr\n\nxso_surf_m = xr.open_dataset(\"Temperature_surf_m.nc\")\nxso_surf_m.rio.set_crs(\"EPSG:4326\")\nprint(xso_surf_m['thetao'] , \"\\n\")\n\nxso_surf_m['thetao'].rio.to_raster(\"Temperature_surf_m.tif\")\nprint(\"done\")","976f25df":"#from osgeo import gdal\n#from osgeo.gdalconst import GA_Update\n\n\nwarp_opts = gdal.WarpOptions(\n    format=\"GTiff\",\n    outputBounds = [4030000.000000002, 3400000.000000002, 5440000.000000002, 4830000.000000002],\n    outputBoundsSRS=\"EPSG:3035\",\n    resampleAlg=gdal.GRIORA_NearestNeighbour,\n    xRes=250,\n    yRes=250,\n    srcSRS=\"EPSG:4326\",\n    dstSRS=\"EPSG:3035\",\n    srcNodata=\"nan\",\n    dstNodata=-9999,\n)\n\nsrc = \"Temperature_surf_m.tif\"\ninput_raster = gdal.Open(src)\nprint(src)\n\ndst_temp = \"Temperature_today.tif\"\nprint(warp_opts)\nres = gdal.Warp(dst_temp,\n                input_raster,\n                options=warp_opts)\n\nres = None\ninput_raster = None\nprint(\"done\")","4250b931":"#from osgeo import gdal\n#from osgeo.gdalconst import GA_Update\n\ndst_temp = \"Temperature_today.tif\"\ninput_raster = gdal.Open(dst_temp, GA_Update)\ninput_raster_band1 = input_raster.GetRasterBand(1)\ngdal.FillNodata(input_raster_band1, maskBand = None, maxSearchDist = 10, smoothingIterations = 0)\n\ninput_raster = None\ninput_raster_band1 = None","c2add4fc":"from osgeo import gdal\nimport matplotlib.pyplot as mpl\n\nds = gdal.Open('Temperature_today.tif').ReadAsArray()\ncmap = mpl.cm.jet\ncmap.set_under('w')\nim = mpl.imshow(ds,vmin=0.0, cmap=cmap)\nmpl.colorbar()\nmpl.title('Temperature today')","470f1965":"!rm \/kaggle\/working\/Temperature_surf_m.nc\n!rm \/kaggle\/working\/Temperature_surf_m.tif","c784518e":"!ls ..\/input\/emodnetseabedsubstrates\n#create temp output folder\n!mkdir \/kaggle\/working\/temp\n#!ls \/kaggle\/working","6cc5493e":"from osgeo import ogr, osr\nimport os\n#Based on https:\/\/pcjericks.github.io\/py-gdalogr-cookbook\/projection.html\n\nshapeList = ['multiscale_50k', 'multiscale_100k', 'multiscale_250k', 'multiscale_1M']\nfor shape in shapeList:\n    driver = ogr.GetDriverByName('ESRI Shapefile')\n\n    # input SpatialReference\n    inSpatialRef = osr.SpatialReference()\n    inSpatialRef.ImportFromEPSG(4326)\n\n    # output SpatialReference\n    outSpatialRef = osr.SpatialReference()\n    outSpatialRef.ImportFromEPSG(3035)\n\n    # create the CoordinateTransformation\n    coordTrans = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)\n\n    # get the input layer\n    finDataSet = \"..\/input\/emodnetseabedsubstrates\/\" + shape + \".shp\"\n    inDataSet = driver.Open(finDataSet)\n    inLayer = inDataSet.GetLayer()\n\n    # create the output layer\n\n    foutputShapefile =\"\/kaggle\/working\/temp\/\" + shape + \"_3035.shp\"\n    if os.path.exists(foutputShapefile):\n        driver.DeleteDataSource(foutputShapefile)\n    outDataSet = driver.CreateDataSource(foutputShapefile)\n    foutlayer = \"\/kaggle\/working\/temp\/\" + shape + \"_3035.shp\"\n    outLayer = outDataSet.CreateLayer(foutlayer, geom_type=ogr.wkbMultiPolygon, options = ['ENCODING=UTF-8'])\n\n    # add fields\n    inLayerDefn = inLayer.GetLayerDefn()\n    for i in range(0, inLayerDefn.GetFieldCount()):\n        fieldDefn = inLayerDefn.GetFieldDefn(i)\n        outLayer.CreateField(fieldDefn)\n\n    # get the output layer's feature definition\n    outLayerDefn = outLayer.GetLayerDefn()\n\n    # loop through the input features\n    inFeature = inLayer.GetNextFeature()\n    while inFeature:\n        # get the input geometry\n        geom = inFeature.GetGeometryRef()\n        # reproject the geometry\n        geom.Transform(coordTrans)\n        # create a new feature\n        outFeature = ogr.Feature(outLayerDefn)\n        # set the geometry and attribute\n        outFeature.SetGeometry(geom)\n        for i in range(0, outLayerDefn.GetFieldCount()):\n            outFeature.SetField(outLayerDefn.GetFieldDefn(i).GetNameRef(), inFeature.GetField(i))\n        # add the feature to the shapefile\n        outLayer.CreateFeature(outFeature)\n        # dereference the features and get the next input feature\n        outFeature = None\n        inFeature = inLayer.GetNextFeature()\n\n    # Save and close the shapefiles\n    inDataSet = None\n    outDataSet = None\n    \n    #write projection file .prj\n    outSpatialRef.MorphToESRI()\n    fprj = \"\/kaggle\/working\/temp\/\" + shape + \"_3035.prj\"\n    file = open(fprj, 'w')\n    file.write(outSpatialRef.ExportToWkt())\n    file.close()\n    print(\"Finished reprojecting \"+ shape)\n\nprint(\"all done\")","26d5ec23":"!mkdir \/kaggle\/working\/tempraster\n!ls ..\/input\/referens-raster\/referens_raster","6df32001":"from osgeo import gdal\nfrom osgeo import ogr\nfrom osgeo import gdalconst\ntarget_ds = None\nshapeList = ['multiscale_50k_3035', 'multiscale_100k_3035', 'multiscale_250k_3035', 'multiscale_1M_3035']\nrefraster = \"..\/input\/referens-raster\/referens_raster\/Standardgrid_Symphony_v1b.tif\"\n\ndata = gdal.Open(refraster, gdalconst.GA_ReadOnly)\nproj = data.GetProjection()\ngeo_transform = data.GetGeoTransform()\nsource_layer = data.GetLayer()\nx_min = geo_transform[0]\ny_max = geo_transform[3]\nx_max = x_min + geo_transform[1] * data.RasterXSize\ny_min = y_max + geo_transform[5] * data.RasterYSize\nx_res = data.RasterXSize\ny_res = data.RasterYSize\npixel_width = geo_transform[1]\n\n\nfor shape in shapeList:\n    print(\"Rasterize \" + shape)\n    finDataSet = \"\/kaggle\/working\/temp\/\" + shape + \".shp\"\n    foutputRasterfile = \"\/kaggle\/working\/tempraster\/\" + shape + \".tif\"\n    \n    inDataSet = ogr.Open(finDataSet)\n    inDataSet1 = inDataSet.GetLayer()\n    target_ds = gdal.GetDriverByName('GTiff').Create(foutputRasterfile, x_res, y_res, 1, gdal.GDT_Byte)\n    target_ds.SetGeoTransform((x_min, pixel_width, 0, y_min, 0, pixel_width))\n    target_ds.SetProjection (proj)\n    band = target_ds.GetRasterBand(1)\n    NoData_value = 0\n    band.SetNoDataValue(NoData_value)\n    band.Fill(0)\n    band.FlushCache()\n    gdal.RasterizeLayer(target_ds, [1], inDataSet1, options=[\"ATTRIBUTE=Folk_5cl\"])\n\n    inDataSet = None\n    target_ds = None\n\nprint(\"done\")","dbe15980":"from osgeo import gdal\nimport numpy as np\nfrom osgeo.gdalconst import GDT_Byte\n\n\nrasterList = ['multiscale_50k_3035', 'multiscale_100k_3035', 'multiscale_250k_3035', 'multiscale_1M_3035']\nz_lenght = len(rasterList)\nprint(z_lenght)\n\n#get numpy shape\nfinputRasterfile = \"\/kaggle\/working\/tempraster\/\" + rasterList[0] + \".tif\"\ninput_raster = gdal.Open(finputRasterfile)\nnpArrfirst = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.uint8)\nprint(npArrfirst.shape)\nnpArr = np.zeros(shape=[z_lenght, npArrfirst.shape[0], npArrfirst.shape[1]], dtype=np.uint8)\nnpResult = np.zeros(shape=[npArrfirst.shape[0], npArrfirst.shape[1]], dtype=np.uint8)\nprint(npArr.shape)\nfirst = True\ni=1\n#read all the tif to numpy \nfor fnraster in rasterList:\n    if first:\n        finputRasterfile = \"\/kaggle\/working\/tempraster\/\" + fnraster + \".tif\"\n        input_raster = gdal.Open(finputRasterfile)\n        npArr[0,:,:] = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.uint8)\n        print(npArr.shape)\n        print(npArr[0,:,:].sum())\n        print(npArr.sum())\n        first = False\n    else:\n        \n        finputRasterfile = \"\/kaggle\/working\/tempraster\/\" + fnraster + \".tif\"\n        input_raster = gdal.Open(finputRasterfile)\n        npArrtemp = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.uint8)\n        npArr[i,:,:] = npArrtemp\n\n        print(npArr.shape)\n        print(npArr[i,:,:].sum())\n        print(npArr.sum())\n        i = i+1\n        \n#loop one cell at the time. If value exist in the best resolution use that. If not test the next and so on.\nfor E in range(npArrfirst.shape[0]):\n    for N in range(npArrfirst.shape[1]):\n        for Z in range(z_lenght):\n            if npArr[Z,E,N] > 0:\n                npResult[E,N] = npArr[Z,E,N]\n                break\n\n\n\n# create outfile with the same extent as the input raster input_raster.RasterXSize , input_raster.RasterYSize\ndriver = gdal.GetDriverByName('GTiff')\n\noutfile1 = driver.Create( '\/kaggle\/working\/tempraster\/Substrate_all.tif', input_raster.RasterXSize , input_raster.RasterYSize , 1, GDT_Byte)\nprint(npArrfirst.shape[0])\nprint(npArrfirst.shape[1])\nprint(npResult.shape)\n\n#There are inconsistancy in this version of GDAL between ReadAsArray() and WriteArray(npResult). we need to flip y-axis before writing to tif.\nnpResult = np.flipud(npResult)\noutfile1.GetRasterBand(1).WriteArray(npResult)\n\n# setting the spatial ref system same as the input\nproj = input_raster.GetProjection()\ngeoref = input_raster.GetGeoTransform()\noutfile1.SetProjection(proj)\noutfile1.SetGeoTransform(georef)\n#Set Nodata\noutfile1.GetRasterBand(1).SetNoDataValue(input_raster.GetRasterBand(1).GetNoDataValue())\n#write to disk\noutfile1 = None\nprint(\"done\")","40193ee5":"\nfrom osgeo import gdal\nimport matplotlib.pyplot as mpl\nimport matplotlib.colors\n\nds = gdal.Open('\/kaggle\/working\/tempraster\/Substrate_all.tif').ReadAsArray()\ncmap = matplotlib.colors.LinearSegmentedColormap.from_list(\"\", [\"white\",\"gold\",\"steelblue\"])\n\nim = mpl.imshow(ds,vmin=0.0, cmap=cmap, vmax=5)\nmpl.colorbar()\nmpl.title('Substrate all')","e14739f2":"import numpy as np\nfrom osgeo import gdal\nfrom osgeo.gdalconst import GDT_Byte\n\n\nfinputRaster = '\/kaggle\/working\/tempraster\/Substrate_all.tif'\ninput_raster = gdal.Open(finputRaster)\nnpArr = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.uint8)\n\nprint(npArr.max())\n\nnpArr[np.where( npArr != 2 )] = 1\nnpArr[np.where( npArr == 2 )] = 0\nprint(npArr.max())\nprint(npArr.min())\n\n#There are inconsistancy in this version of GDAL between ReadAsArray() and WriteArray(npResult). we need to flip y-axis before writing to tif.\nnpResult = np.flipud(npResult)\n\n# create outfile with the same extent as the input raster\ndriver = gdal.GetDriverByName('GTiff')\noutfile1 = driver.Create( 'Substrate.tif', input_raster.RasterXSize , input_raster.RasterYSize , 1, GDT_Byte)\noutfile1.GetRasterBand(1).WriteArray(npArr)\n\n# setting the spatial ref system same as the input\nproj = input_raster.GetProjection()\ngeoref = input_raster.GetGeoTransform()\noutfile1.SetProjection(proj)\noutfile1.SetGeoTransform(georef)\n#Set Nodata\noutfile1.GetRasterBand(1).SetNoDataValue(-9999)\n#write to disk\noutfile1 = None\n\nprint(\"done\")","26978ed3":"from osgeo import gdal\nimport matplotlib.pyplot as mpl\nimport numpy as np\nimport matplotlib.colors\n\nds = gdal.Open('Substrate.tif').ReadAsArray()\n\ndsref = gdal.Open(\"..\/input\/referens-raster\/referens_raster\/Standardgrid_Symphony_v1b.tif\").ReadAsArray()\n\ncmapref = mpl.cm.gray_r\ncmap1 = matplotlib.colors.LinearSegmentedColormap.from_list(\"\", [\"gold\",\"white\"])\n\nimref = mpl.imshow(dsref, vmin=4.0, cmap=cmapref)\nim = mpl.imshow(ds,vmin=0.0,vmax=1.0, cmap=cmap1, alpha=.9)\nmpl.colorbar(ticks=np.linspace(0,1,2))\nmpl.title('Substrate (sand)')\n\n","4242e244":"#deleting temporary files\n!rm \/kaggle\/working\/temp\/*\n!rm \/kaggle\/working\/tempraster\/*","f25d6ff7":"from osgeo import gdal\nimport matplotlib.pyplot as mpl\n\n#https:\/\/gdal.org\/python\/index.html\nsrc = \"..\/input\/emodnetbathymetry\/Emodnet_bathymetry_C5_2018.asc\"\ninput_raster = gdal.Open(src)\n\nstats = input_raster.GetRasterBand(1).GetStatistics(0,1)\n\nprint(\"Min, Max, Mean, StdDev\")\nprint(stats)\nprint(\"Nodata is \" + str(input_raster.GetRasterBand(1).GetNoDataValue()))\ngt =input_raster.GetGeoTransform()\nprint(\"Pixel Size (deg)= ({}, {})\".format(gt[1], gt[5]))\ninput_raster = None\ngt =  None\nprint(\"done\")","62f644c3":"from osgeo import gdal\n\ntileList = ['..\/input\/emodnetbathymetry\/Emodnet_bathymetry_C5_2018.asc',\n              '..\/input\/emodnetbathymetry\/Emodnet_bathymetry_C6_2018.asc',\n              '..\/input\/emodnetbathymetry\/Emodnet_bathymetry_C7_2018.asc',\n              '..\/input\/emodnetbathymetry\/Emodnet_bathymetry_D5_2018.asc',\n              '..\/input\/emodnetbathymetry\/Emodnet_bathymetry_D6_2018.asc',\n              '..\/input\/emodnetbathymetry\/Emodnet_bathymetry_D7_2018.asc']\n\n#BuildVRT(destName, srcDSOrSrcDSTab, **kwargs)\ndestName = '\/kaggle\/working\/tempraster\/C5C7_D5D7_2018.vrt'\n\ngdal.BuildVRT(destName, tileList)\n\n#write to disk\ndestName = None\nprint(\"done\")","ba8c03e3":"from osgeo import gdal\nfrom osgeo.gdalconst import GA_Update\n\n#resample tif\n#https:\/\/gdal.org\/python\/index.html\n#info EPSG http:\/\/www.epsg.org\/\nwarp_opts = gdal.WarpOptions(\n    format=\"GTiff\",\n    outputBounds = [4030000.0, 3400000.0, 5440000.0, 4830000.0],\n    srcSRS=\"EPSG:4326\",\n    dstSRS=\"EPSG:3035\",\n    resampleAlg=\"near\",\n    srcNodata=99.0,\n    dstNodata=-9999,\n)\n\nsrc = '\/kaggle\/working\/tempraster\/C5C7_D5D7_2018.vrt'\ninput_raster = gdal.Open(src)\ndst_temp = \"\/kaggle\/working\/tempraster\/C5C7_D5D7_2018.tif\"\nprint(warp_opts)\nres = gdal.Warp(dst_temp,\n                input_raster,\n                options=warp_opts)\n\ninput_raster = None\nres = None\n#result statistics\ndst_raster = gdal.Open(dst_temp)\nstats = dst_raster.GetRasterBand(1).GetStatistics(0,1)\nprint(\"Min, Max, Mean, StdDev\")\nprint(stats)\nprint(\"Nodata is\")\nprint(dst_raster.GetRasterBand(1).GetNoDataValue())\ngt = dst_raster.GetGeoTransform()\nprint(\"Pixel Size (m)= ({}, {})\".format(gt[1], gt[5]))\n\n\nprint(\"done\")","316445d4":"import numpy as np\nfrom osgeo import gdal\nfrom osgeo.gdalconst import GDT_Float32\n\nsrc = '\/kaggle\/working\/tempraster\/C5C7_D5D7_2018.tif'\ninput_raster = gdal.Open(src)\n\nnpArr = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.float32)\n\nprint(\"Highest land value is \"+str(npArr.max()))\n\nnpArr[np.where( npArr > -0.5 )] = input_raster.GetRasterBand(1).GetNoDataValue()\nprint(\"Lowest water depth\" + str(npArr.max()))\nprint(\"New land values \" + str(npArr.min()))\n\n# create outfile with the same extent as the input raster\ndriver = gdal.GetDriverByName('GTiff')\noutfile1 = driver.Create( '\/kaggle\/working\/tempraster\/C5C7_D5D7_2018_reclassify.tif', input_raster.RasterXSize , input_raster.RasterYSize , 1, GDT_Float32)\noutfile1.GetRasterBand(1).WriteArray(npArr)\n\n# setting the spatial ref system same as the input\nproj = input_raster.GetProjection()\ngeoref = input_raster.GetGeoTransform()\noutfile1.SetProjection(proj)\noutfile1.SetGeoTransform(georef)\n#Set Nodata\noutfile1.GetRasterBand(1).SetNoDataValue(input_raster.GetRasterBand(1).GetNoDataValue())\n#write to disk\noutfile1 = None\nprint(\"done\")","68fb5a72":"from osgeo import gdal\nfrom osgeo.gdalconst import GA_Update\n\n#resample tif\n#https:\/\/gdal.org\/python\/index.html\n#info EPSG http:\/\/www.epsg.org\/\nwarp_opts = gdal.WarpOptions(\n    format=\"GTiff\",\n    outputBounds = [4030000.0, 3400000.0, 5440000.0, 4830000.0],\n    xRes=250,\n    yRes=250,\n    srcSRS=\"EPSG:3035\",\n    dstSRS=\"EPSG:3035\",\n    resampleAlg=\"near\",\n    srcNodata=-9999,\n    dstNodata=-9999,\n)\n\nsrc = '\/kaggle\/working\/tempraster\/C5C7_D5D7_2018_reclassify.tif'\ninput_raster5 = gdal.Open(src)\ndst_temp = \"Depth.tif\"\nprint(warp_opts)\nres = gdal.Warp(dst_temp,\n                input_raster5,\n                options=warp_opts)\n\nres = None\ninput_raster5 = None\n\ninput_raster6 = gdal.Open(dst_temp, GA_Update)\ninput_raster6_band1 = input_raster6.GetRasterBand(1)\ngdal.FillNodata(input_raster6_band1, maskBand = None, maxSearchDist = 10, smoothingIterations = 0)\n\ninput_raster6 = None\ninput_raster6_band1 = None\nprint(\"done\")","07830995":"from osgeo import gdal\nimport matplotlib.pyplot as mpl\n\nds = gdal.Open('Depth.tif').ReadAsArray()\ncmap = mpl.cm.jet\ncmap.set_under('w')\nim = mpl.imshow(ds,vmin=-2000, cmap=cmap)\nmpl.colorbar()\nmpl.title('Depth')","a85c5707":"#deleting temporary files\n!rm \/kaggle\/working\/tempraster\/*","e6c5ab05":"from osgeo import gdal\nfrom osgeo.gdalconst import GA_Update\n\n#resample tif\n#https:\/\/gdal.org\/python\/index.html\n#info EPSG http:\/\/www.epsg.org\/\nwarp_opts = gdal.WarpOptions(\n    format=\"GTiff\",\n    outputBounds = [4030000.0, 3400000.0, 5440000.0, 4830000.0],\n    xRes=250,\n    yRes=250,\n    srcSRS=\"EPSG:4326\",\n    dstSRS=\"EPSG:3035\",\n    resampleAlg=\"near\",\n    srcNodata=-3.40282346639e+38,\n    dstNodata=-9999,\n)\n\nsrc = '..\/input\/waveexposure\/baltic_wei_swm_with_wh1.tif'\ninput_raster5 = gdal.Open(src)\ndst_temp = \"waveexposure.tif\"\nprint(warp_opts)\nres = gdal.Warp(dst_temp,\n                input_raster5,\n                options=warp_opts)\n\nres = None\ninput_raster5 = None\n\ninput_raster6 = gdal.Open(dst_temp, GA_Update)\ninput_raster6_band1 = input_raster6.GetRasterBand(1)\ngdal.FillNodata(input_raster6_band1, maskBand = None, maxSearchDist = 10, smoothingIterations = 0)\n\n\ninput_raster6 = None\ninput_raster6_band1 = None\n\n\nprint(\"done\")","17eb36cd":"from osgeo import gdal\nimport matplotlib.pyplot as mpl\n\nds = gdal.Open('waveexposure.tif').ReadAsArray()\ncmap = mpl.cm.jet\ncmap.set_under('w')\nim = mpl.imshow(ds,vmin=-2000, cmap=cmap)\nmpl.colorbar()\nmpl.title('Wave exposure')","3cc8d209":"from osgeo import gdal\nfrom osgeo.gdalconst import GA_Update\n\n\n#reproject and resample tif\n#https:\/\/gdal.org\/python\/index.html\n#info EPSG http:\/\/www.epsg.org\/\nwarp_opts = gdal.WarpOptions(\n    format=\"GTiff\",\n    outputBounds = [4030000.0, 3400000.0, 5440000.0, 4830000.0],\n    xRes=250,\n    yRes=250,\n    dstSRS=\"EPSG:3035\",\n    resampleAlg=\"near\",\n    dstNodata=-9999.0,)\n\n\nsrc = \"..\/input\/climatechangeversion20151211\/a1b_bau_2099_V_Salt1.tif\"\ninput_raster3 = gdal.Open(src)\ndst_temp = \"Salinity_ClimateChange.tif\"\nprint(warp_opts)\nres = gdal.Warp(dst_temp,\n                input_raster3,\n                options=warp_opts)\n\nres = None\ninput_raster3 = None\n\ninput_raster4 = gdal.Open(dst_temp, GA_Update)\ninput_raster4_band1 = input_raster4.GetRasterBand(1)\ngdal.FillNodata(input_raster4_band1, maskBand = None, maxSearchDist = 4, smoothingIterations = 0)\n\ninput_raster4_band1 = None\ninput_raster4 = None\nprint(\"done\")","99701c86":"from osgeo import gdal\nimport matplotlib.pyplot as mpl\n\nds = gdal.Open('Salinity_ClimateChange.tif').ReadAsArray()\ncmap = mpl.cm.jet\ncmap.set_under('w')\nim = mpl.imshow(ds,vmin=0.0, cmap=cmap)\nmpl.colorbar()\nmpl.title('Salinity Climate Change')","234f246b":"from osgeo import gdal\nfrom osgeo.gdalconst import GA_Update\n\n#reproject and resample tif\n#https:\/\/gdal.org\/python\/index.html\n#info EPSG http:\/\/www.epsg.org\/\nwarp_opts = gdal.WarpOptions(\n    format=\"GTiff\",\n    outputBounds = [4030000.0, 3400000.0, 5440000.0, 4830000.0],\n    xRes=250,\n    yRes=250,\n    dstSRS=\"EPSG:3035\",\n    resampleAlg=\"near\",\n    dstNodata=-9999,)\n\n\nsrc = \"..\/input\/climatechangeversion20151211\/a1b_bau_2099_V_Temp1.tif\"\ninput_raster = gdal.Open(src)\ndst_temp = \"Temperature_ClimateChange.tif\"\nprint(warp_opts)\nres = gdal.Warp(dst_temp,\n                input_raster,\n                options=warp_opts)\nres = None\ninput_raster = None\n\ninput_raster2 = gdal.Open(dst_temp, GA_Update)\ninput_raster2_band1 = input_raster2.GetRasterBand(1)\ngdal.FillNodata(input_raster2_band1, maskBand = None, maxSearchDist = 4, smoothingIterations = 0)\n\ninput_raster2_band1 = None\ninput_raster2 = None\nprint(\"done\")","ea618ca1":"from osgeo import gdal\nimport matplotlib.pyplot as mpl\n\nds = gdal.Open('Temperature_ClimateChange.tif').ReadAsArray()\ncmap = mpl.cm.jet\ncmap.set_under('w')\nim = mpl.imshow(ds,vmin=0.0, cmap=cmap)\nmpl.colorbar()\nmpl.title('Temperature Climate Change')","1759f06a":"from osgeo import ogr, osr, gdal\nimport numpy as np\nfrom pathlib import Path\n\n#Left, Bottom, Right, Top\noutputBounds=[4030000.0, 3400000.0, 5440000.0, 4830000.0]\ncolrows = [5640, 5720]\n\nrasterList = ['Salinity_today.tif',\n              'Temperature_today.tif',\n              'Substrate.tif',\n              'Depth.tif',\n              'waveexposure.tif']\n             #'..\\\\1_Sweden\\\\7_Absence_Shipping traffic\\\\out\\\\7_Absence_Shipping traffic.tif']\n        \nz_lenght = len(rasterList)\nprint(z_lenght)\n\n#get numpy shape\nfinputRasterfile = rasterList[0]\ninput_raster = gdal.Open(finputRasterfile)\nnpArrfirst = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.float32)\nprint(npArrfirst.shape)\nnpArr = np.zeros(shape=[z_lenght, npArrfirst.shape[0], npArrfirst.shape[1]], dtype=np.float32)\nnpResult = np.zeros(shape=[npArrfirst.shape[0], npArrfirst.shape[1]], dtype=np.float32)\nprint(npArr.shape)\nfirst = True\ni=0\n#read all the tif to numpy \nfor fnraster in rasterList:\n\n    finputRasterfile = fnraster\n    input_raster = gdal.Open(finputRasterfile)\n    npArrtemp = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.float32)\n    npArr[i,:,:] = npArrtemp\n\n    i = i + 1\n\n\nfinDataSet = '..\/input\/shapeinvasivespecies\/Dikerogammarus_villosus_20200110_baltic.shp'\ndriver = ogr.GetDriverByName('ESRI Shapefile')\ninPointShape = driver.Open(finDataSet)\nlayer = inPointShape.GetLayer()\nlayerDefinition = layer.GetLayerDefn()\n\n#layer_attr = ['pointid', 'grid_code', 'N_ETRS89', 'E_ETRS89', 'N_WGS84', 'E_WGS84']\nlayer_attr = ['pointid', 'N_ETRS89', 'E_ETRS89']\n\nf = open('Precence_baltic.csv', 'a')\nf.write(layer_attr[0] + \";\")\nfor inraster in rasterList:\n    f.write(Path(inraster).stem + \";\")\n    print(Path(inraster).stem)\nf.write(\"\\n\")\n\nfor feature in layer:\n    pointid = feature.GetField(layer_attr[0])\n    N = feature.GetField(layer_attr[1])\n    E = feature.GetField(layer_attr[2])\n    #print(pointid,N,E)\n    x = int((E - outputBounds[0])\/250)\n    y = (colrows[1]-1) - int((N - outputBounds[1])\/250)\n    #print(pointid,x,y)\n    f.write(str(pointid) + \";\")\n    for z in range(z_lenght):\n        f.write(str(npArr[z,y,x]) + \";\")\n    f.write(\"\\n\")\nf.close()\nprint(\"done\")","c0acfbb4":"from osgeo import ogr, osr, gdal\nimport numpy as np\nfrom pathlib import Path\n\n#Left, Bottom, Right, Top\noutputBounds=[4030000.0, 3400000.0, 5440000.0, 4830000.0]\ncolrows = [5640, 5720]\n\nrasterList = ['Salinity_today.tif',\n              'Temperature_today.tif',\n              'Substrate.tif',\n              'Depth.tif',\n              'waveexposure.tif']\n             #'..\\\\1_Sweden\\\\7_Absence_Shipping traffic\\\\out\\\\7_Absence_Shipping traffic.tif']\n        \nz_lenght = len(rasterList)\nprint(z_lenght)\n\n#get numpy shape\nfinputRasterfile = rasterList[0]\ninput_raster = gdal.Open(finputRasterfile)\nnpArrfirst = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.float32)\nprint(npArrfirst.shape)\nnpArr = np.zeros(shape=[z_lenght, npArrfirst.shape[0], npArrfirst.shape[1]], dtype=np.float32)\nnpResult = np.zeros(shape=[npArrfirst.shape[0], npArrfirst.shape[1]], dtype=np.float32)\nprint(npArr.shape)\nfirst = True\ni=0\n#read all the tif to numpy \nfor fnraster in rasterList:\n\n    finputRasterfile = fnraster\n    input_raster = gdal.Open(finputRasterfile)\n    npArrtemp = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.float32)\n    npArr[i,:,:] = npArrtemp\n\n    i = i + 1\n\n\nfinDataSet = '..\/input\/shapeinvasivespecies\/Absence_prediction_ETRS89.shp'\ndriver = ogr.GetDriverByName('ESRI Shapefile')\ninPointShape = driver.Open(finDataSet)\nlayer = inPointShape.GetLayer()\nlayerDefinition = layer.GetLayerDefn()\n\n#layer_attr = ['pointid', 'grid_code', 'N_ETRS89', 'E_ETRS89', 'N_WGS84', 'E_WGS84']\nlayer_attr = ['pointid', 'N_ETRS89', 'E_ETRS89']\n\nf = open('Absence_baltic.csv', 'a')\nf.write(layer_attr[0] + \";\")\nfor inraster in rasterList:\n    f.write(Path(inraster).stem + \";\")\n    print(Path(inraster).stem)\nf.write(\"\\n\")\n\nfor feature in layer:\n    pointid = feature.GetField(layer_attr[0])\n    N = feature.GetField(layer_attr[1])\n    E = feature.GetField(layer_attr[2])\n    #print(pointid,N,E)\n    x = int((E - outputBounds[0])\/250)\n    y = (colrows[1]-1) - int((N - outputBounds[1])\/250)\n    #print(pointid,x,y)\n    f.write(str(pointid) + \";\")\n    for z in range(z_lenght):\n        f.write(str(npArr[z,y,x]) + \";\")\n    f.write(\"\\n\")\nf.close()\nprint(\"done\")","bc2f1a08":"from osgeo import ogr, osr, gdal\nimport numpy as np\nfrom pathlib import Path\n\n#Left, Bottom, Right, Top\noutputBounds=[4030000.0, 3400000.0, 5440000.0, 4830000.0]\ncolrows = [5640, 5720]\n\nrasterList = ['Salinity_ClimateChange.tif',\n              'Temperature_ClimateChange.tif',\n              'Substrate.tif',\n              'Depth.tif',\n              'waveexposure.tif']\n             #'..\\\\1_Sweden\\\\7_Absence_Shipping traffic\\\\out\\\\7_Absence_Shipping traffic.tif']\n        \nz_lenght = len(rasterList)\nprint(z_lenght)\n\n#get numpy shape\nfinputRasterfile = rasterList[0]\ninput_raster = gdal.Open(finputRasterfile)\nnpArrfirst = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.float32)\nprint(npArrfirst.shape)\nnpArr = np.zeros(shape=[z_lenght, npArrfirst.shape[0], npArrfirst.shape[1]], dtype=np.float32)\nnpResult = np.zeros(shape=[npArrfirst.shape[0], npArrfirst.shape[1]], dtype=np.float32)\nprint(npArr.shape)\nfirst = True\ni=0\n#read all the tif to numpy \nfor fnraster in rasterList:\n\n    finputRasterfile = fnraster\n    input_raster = gdal.Open(finputRasterfile)\n    npArrtemp = np.array(input_raster.GetRasterBand(1).ReadAsArray(), dtype=np.float32)\n    npArr[i,:,:] = npArrtemp\n\n    i = i + 1\n\n\nfinDataSet = '..\/input\/shapeinvasivespecies\/Absence_prediction_ETRS89.shp'\ndriver = ogr.GetDriverByName('ESRI Shapefile')\ninPointShape = driver.Open(finDataSet)\nlayer = inPointShape.GetLayer()\nlayerDefinition = layer.GetLayerDefn()\n\n#layer_attr = ['pointid', 'grid_code', 'N_ETRS89', 'E_ETRS89', 'N_WGS84', 'E_WGS84']\nlayer_attr = ['pointid', 'N_ETRS89', 'E_ETRS89']\n\nf = open('Prediction_ClimateChange.csv', 'a')\nf.write(layer_attr[0] + \";\")\nfor inraster in rasterList:\n    f.write(Path(inraster).stem + \";\")\n    print(Path(inraster).stem)\nf.write(\"\\n\")\n\nfor feature in layer:\n    pointid = feature.GetField(layer_attr[0])\n    N = feature.GetField(layer_attr[1])\n    E = feature.GetField(layer_attr[2])\n    #print(pointid,N,E)\n    x = int((E - outputBounds[0])\/250)\n    y = (colrows[1]-1) - int((N - outputBounds[1])\/250)\n    #print(pointid,x,y)\n    f.write(str(pointid) + \";\")\n    for z in range(z_lenght):\n        f.write(str(npArr[z,y,x]) + \";\")\n    f.write(\"\\n\")\nf.close()\nprint(\"done\")","add6f23d":"#remove temporary files\n!rm -r \/kaggle\/working\/temp\n!rm -r \/kaggle\/working\/tempraster\n\n#remove result raster\n!rm Salinity_today.tif\n!rm Temperature_today.tif\n!rm Substrate.tif\n!rm Depth.tif\n!rm waveexposure.tif\n!rm Salinity_ClimateChange.tif\n!rm Temperature_ClimateChange.tif\n\n#remove result .csv\n#!rm Precence_baltic.csv\n#!rm Absence_baltic.csv\n#!rm Prediction_ClimateChange.csv","1380286e":"<font size=\"4\">\n    Salinity climate change<br \/>\n    <br \/>\n<font size=\"3\">\n    Due to increased watercirculation the salinity in the Baltic sea is predicted to decrease.<br \/>\n    <br \/>\n<\/font>","0314a465":"<font size=\"3\">\n    \"so\" is the parameter for salinity.<br \/>\n    Now we will read all the .nc files in the folder to mfdataset (xarray) and select only depth values between 0-2m. We then calculate mean values over the time dimension. That means that we keep spatial data. Finaly we save the result to a new .nc file.<br \/>\n<\/font>","8ac010e2":"<font size=\"3\">\nThe first print on 'so' show that there are 150 months (time: 150) and 56 depth levels in the data set.\nSecond print show the depth levels in meters.\nThe third print shows the result and we have now only one time dimension and one depth. Spatial data is still there.\n<br \/>\nSome pixels in the data set contains noData values. This will result in a warning \"invalid value encountered\" in divide. It's possible to omit those values in the calculation but for this project it's not necessary.\n<br \/>\n<br \/>    \n   In this step we are going to convert the .nc file (Sal_surf_m.nc) to a tif. NetCDF files can be tricky to convert. In the previous prints we cant see any information about coordinate system but we know it's WGS84 (\"EPSG:4326\"). So we read the file to a xarray and use rioxarray to put a projection to the data and then we are able to save the dataset to .tif. \n<\/font>","0aabe8e2":"<font size=\"4\">\n    Depth<br \/>\n    <br \/>\n<\/font>\n<font size=\"3\">\n    Baltic sea bathymetry data from <a href=https:\/\/portal.emodnet-bathymetry.eu\/>Emodnet bathymetry<\/a> <br \/>\n    Six DTM-tiles in the format .asc covers the entire baltic sea (C5-C7 and D5-D7). \n    First we inspect one raster with python library <a href=https:\/\/gdal.org\/python\/>gdal<\/a>. <br \/>\n    <br \/>\n<\/font>","137d6fa1":"<font size=\"3\">\n    We use gdal rasterize to make rasters from our shape files.<br \/>\n<\/font>","d49e63f5":"<font size=\"3\">\nNow we want to make the tif exactly match the cellsize of our reference raster. We resample our raster with gdal Warp.<br \/>\nTo match the shoreline the \"quick and dirty\" way we use fillNodata.\n<\/font>","a92bc0b3":"<font size=\"3\">\n    \"thetao\" is the parameter for temperature.<br \/>\n    More information on Potential temperature is found here:<a href=\"http:\/\/www.teos-10.org\/\">TEOS-10<\/a>\n<br \/>\n  <\/font> ","2645ebf0":"<font size=\"4\">\n    Installing GDAL <br \/>\n<\/font>    \n<font size=\"3\">\n    GDAL is a very powerfull library when you need to work with geographic data. Installing takes some time. <br \/>\n<\/font>","1250f76d":"<font size=\"3\">\n   We use reclassify to set sand (value 2) to 0 and all other values to 1.<br \/>\n<\/font>","6d5af1b7":"<font size=\"4\">\n    Substrate <br \/>\n    <br \/>\n<\/font>\n<font size=\"3\">\n    Substrate data is available at Emodnet Seabed Substrates <a href=https:\/\/www.emodnet-geology.eu\/data-products\/seabed-substrates\/>Emodnet Seabed Substrates<\/a><br \/>\n    The shape layers illustrate seabed properties at different scales \u2013 1:50 000, 1:100 000, 1:250 000 (250 k) and 1:1 000 000 (1 M). The layers have different coverage and we want to use the best resolution avalible at each raster cell. <br \/>\n    There are 5 classes of substrate in Folk_5:<br \/>\n    1. Mud to muddy Sand<br \/>\n    2. Sand<br \/>\n    3. Coarse-grained sediment<br \/>\n    4. Mixed sediment<br \/>\n    5. Rock & boulders<br \/>\n    The Killer shrimp don't like sand. Our final raster will only contain 0 for sand and 1 for no sand.<br \/>\n    In the first step we reproject the shapefiles from WGS84 to ETRS89.<br \/>\n    <br \/>\n<\/font>","6d9c3d5f":"<font size=\"4\">\n    Salinity <br \/>\n    <br \/>\n<\/font>\n<font size=\"3\">\n    We want to make a tiff-file matching the extent and cellsize of a reference raster containing mean winter surface salinity values. The use of a reference raster makes it easier later on to build a pointsampler.\n    Indata are netCDF\/HDF (.nc) files from marine Copernicus downloaded by FTP and filtred just to contain winter months (1993-2017).<br \/>\n    ls (Linux) lists the .nc files. <br \/>\n<\/font>","e3c02145":"<font size=\"3\">\nNow we want to make the tif exactly match the projection, cellsize and the extant of our reference raster. We reproject our raster with gdal Warp.\n    <br \/>\nTo match the shoreline the \"quick and dirty\" way we use fillNodata.\n<\/font>","fc30a522":"<font size=\"3\">\nTo match the shoreline the \"quick and dirty\" way we use fillNodata.\n<\/font>","8688dad4":"<font size=\"3\">\n    We need to reproject from WGS84 to ETRS89 and at the same time clip the data to our reference raster.<br \/>\n    <br \/>\n<\/font>","848d8a11":"<font size=\"3\">\nPlotting the result with matplotlib.\n<\/font>","04e9ef68":"<font size=\"3\">\n    Select data with best resolution starting with multiscale _50k<br \/>\n<\/font>","9e513dc1":"<font size=\"4\">\n    Temperature <br \/>\n    <br \/>\n<\/font>\n<font size=\"3\">\n    The data source for temperature is in the same dataset as the previus salinity. We use the same steps as with salinity.<br \/>\n<\/font>","4071d608":"<font size=\"3\">\n    We need to reclassify the land values to nodata (0 - 549m -> Nodata)<br \/>\n    <br \/>\n<\/font>","73423806":"<font size=\"4\">\n    Pointsampler abscence<br \/>\n    <br \/>\n<font size=\"3\">\n    We collect data where the shrimp is not found.<br \/>\n    <br \/>\n<\/font>","f2cd4097":"<font size=\"4\">\n    Pointsampler presence<br \/>\n    <br \/>\n<font size=\"3\">\n    We collect data where the shrimp is present.<br \/>\n    <br \/>\n<\/font>","4993bd2c":"<font size=\"4\">\n    Pointsampler climate change<br \/>\n    <br \/>\n<font size=\"3\">\n    We collect data where the shrimp is not found with values for salinity and temperature after climate change.<br \/>\n    <br \/>\n<\/font>","54f54b0c":"<a href=\"https:\/\/oceandatafactory.se\/\"><img src=\"https:\/\/drive.google.com\/uc?export=view&id=1ff3bG7PBdnMZIPZJCaJDyPJM2-fDtRrw\" align=\"right\" style=\"width:150px;height:150px;background-color:white\"\/><\/a>\n<font size=\"5\">\n    <br \/>\n    ODF Sweden Invasive species data sources\n    <br \/>\n    <br \/>\n    <br \/>\n    <br \/>\n<\/font>\n<font size=\"4\">\n    Introduction<br \/>\n<\/font>\n<font size=\"3\">\n    <br \/>\n    To predict future species distribution due to climate change is an important knowledge.  In this case we are focusing on a marine shrimp, Dikerogammarus villosus (\u201cKiller crimp\u201d) using freely available data sources to predict occurrence around the coasts of Sweden, \u00c5land and parts of Finland. Current (2019) distribution is shown in the map below.<br \/>\n    <br \/>\n<img src=\"https:\/\/drive.google.com\/uc?export=view&id=1oB6dhlWNmEzubS7-AhOyqVQg1GJBVBD-\" align=\"bottom\" style=\"height:150px;background-color:white\"\/>\n<\/font>\n<font size=\"4\">\n    <br \/>\n    What physical or biological data parameters are important for this species to thrive?<br \/>\n<\/font>\n<font size=\"3\">\n    <br \/>\n    Salinity tolerate up to 20\u2030  (Optimal up to 12\u2030)<br \/>\n    Tolerate temperatures from 0-35\u00b0C (Optimal 5-15\u00b0C)<br \/>\n    Occupy every substratum except sand<br \/>\n    Present in areas with low current velocity<br \/>\n    Depth probably not below 20m<br \/>\n    <br \/>\n<\/font>\n<font size=\"4\">\n    Preparing data sources<br \/>\n<\/font>\n<font size=\"3\">\n    <br \/>\n    The aim of this part is combining geographic data from many data sources in a structured way to produce simple data sets that we can feed to the AI. The resulting maps are shown below.<br \/>\n    <br \/>\n<\/font>\n<img src=\"https:\/\/drive.google.com\/uc?export=view&id=1XsfaLF13u99wIKq34qnI9k5MRO7w6Hg3\" align=\"bottom\" style=\"width:auto;height:280px;background-color:white\"\/>\n<font size=\"3\">\n    <br \/>\n    After the maps are produced we are using a pointsampler to get raster values at coordinates in .csv files.<br \/>\n    You will find the AI project <a href=\"https:\/\/www.kaggle.com\/jannesggg\/odf-1-invasive-species\">here<\/a> and <a href=\"https:\/\/www.kaggle.com\/jannesggg\/odf-2-invasive-species\">here<\/a>.\n    <br \/>\n<\/font>","0889c720":"<font size=\"3\">\n    First we inspect just one .nc file to see the dimensions and parameters.<br \/>\n<\/font>","1c77af7d":"<font size=\"4\">\n    Temperatur climate change<br \/>\n    <br \/>\n<font size=\"3\">\n    Due to climate change the water in the Baltic sea is predicted to increase.<br \/>\n    <br \/>\n<\/font>","412a7c5f":"<font size=\"3\">\nCleaning up temporary files\n<\/font>","a9106e18":"<font size=\"3\">\n    We build a virtual raster (.vrt) containing our tiles.<br \/>\n    <br \/>\n<\/font>","35e42ce8":"<font size=\"4\">\n    Wave exposure<br \/>\n    <br \/>\n<font size=\"3\">\n    Wave exposure is part of Emodnet seabed habitats <a href=https:\/\/www.emodnet.eu\/seabed-habitats>\nEmodnet seabed habitats<\/a> <br \/>\n    We use the dataset <a href=http:\/\/gis.ices.dk\/geonetwork\/srv\/eng\/catalog.search#\/metadata\/96ef7d9f-2f9c-4b7b-8ec1-3535c67aa1f8>Environmental variables \u2192 Waves \u2192 Wave exposure index at surface (Baltic)<\/a>. <br \/>\n    The dataset is in the format .tif and projection is WGS84. We only need to reproject the raster to fit our reference raster.<br \/>\n    <br \/>\n<\/font>"}}