{"cell_type":{"1578e3b6":"code","063ee72f":"code","235b5af9":"code","077479a8":"code","5e5c9195":"code","53dd5245":"code","706c4705":"code","d921a2b8":"code","0b5c606e":"code","783dd424":"code","1a2f8813":"code","3b47cc50":"code","c009ebc7":"markdown"},"source":{"1578e3b6":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom tqdm.notebook import tqdm\nfrom scipy.optimize import curve_fit\nfrom sklearn.metrics import r2_score\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn import linear_model","063ee72f":"%matplotlib inline\ndpi = 96\nplt.rcParams['figure.figsize'] = (1600\/dpi, 600\/dpi)\nplt.style.use('ggplot')","235b5af9":"# grabbing prepared dataset from https:\/\/www.kaggle.com\/jorijnsmit\/population-and-sub-continent-for-every-entity\ncovid = pd.read_csv('\/kaggle\/input\/population-and-sub-continent-for-every-entity\/covid.csv', parse_dates=['date'])","077479a8":"# perform same manipulations from the prepared dataset to the test set\ntest = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-3\/test.csv', parse_dates=['Date'])\ntest.columns = ['id', 'province_state', 'country_region', 'date']\ntest['country_region'].update(test['country_region'].str.replace('Georgia', 'Sakartvelo'))\ntest['entity'] = test['province_state'].where(~test['province_state'].isna(), test['country_region'])\ntest = test.set_index('id')[['date', 'entity']]","5e5c9195":"def logistic(t, k, r, a):\n    \"\"\"k > 0: final epidemic size\n    r > 0: infection rate\n    a = (k - c_0) \/ c_0\n    \"\"\"\n    \n    return k \/ (1 + a * np.exp(-r * t))","53dd5245":"def solve(c):\n    \"\"\"port from https:\/\/mathworks.com\/matlabcentral\/fileexchange\/74411-fitvirus\"\"\"\n    \n    n = len(c)\n    nmax = max(1, n \/\/ 2)\n\n    for i in np.arange(1, nmax+1):\n        k1 = i\n        k3 = n - 1\n        if (n - i) % 2 == 0:\n            k3 -= 1\n\n        k2 = (k1 + k3) \/\/ 2\n        m = k2 - k1 - 1\n\n        if k1 < 1 or k2 < 1 or k3 < 1 or m < 1:\n            return None\n\n        k1 -= 1\n        k2 -= 1\n        k3 -= 1\n\n        # calculate k\n        v = c[k1] * c[k2] - 2 * c[k1] * c[k3] + c[k2] * c[k3]\n        if v <= 0:\n            continue\n        w = c[k2]**2 - c[k3] * c[k1]\n        if w <= 0:\n            continue\n        k = c[k2] * v \/ w\n        if k <= 0:\n            continue\n\n        # calculate r\n        x = c[k3] * (c[k2] - c[k1])\n        if x <= 0:\n            continue\n        y = c[k1] * (c[k3] - c[k2])\n        if y <= 0:\n            continue\n        r = (1 \/ m) * np.log(x \/ y)\n        if r <= 0:\n            continue\n\n        # calculate a\n        z = ((c[k3] - c[k2]) * (c[k2] - c[k1])) \/ w\n        if z <= 0:\n            continue\n        a = z * (x \/ y) ** ((k3 + 1 - m) \/ m)\n        if a <= 0:\n            continue\n        \n        return k, r, a","706c4705":"def plot_fit(x_train, y_train, x_predict, y_predict, target, r2):\n    fig, ax = plt.subplots()\n    ax.set_title(f'{subject} ({target}) {r2}')\n    color = 'green' if r2 > 0.99 else 'red'\n    pd.Series(y_train, x_train).plot(subplots=True, style='.', color='black', legend=True, label='train')\n    pd.Series(y_predict, x_predict).plot(subplots=True, style=':', color=color, legend=True, label='predict')\n    plt.show()","d921a2b8":"herd_immunity = 0.7\ntest_ratio = 0.2\n\nfor target in ['confirmed', 'fatal']:\n    for subject in tqdm(covid['entity'].unique()):\n        population = covid[covid['entity'] == subject]['population'].max()\n\n        x_train = covid[covid['entity'] == subject]['date'].dt.dayofyear.values\n        y_train = covid[covid['entity'] == subject][target].values\n\n        mask = y_train > 0\n        x_train_m = x_train[mask]\n        y_train_m = y_train[mask]\n        \n        # no point in modelling a single point or no ints at all\n        if x_train_m.size < 2 or x_train_m.sum() == 0:\n            continue\n\n        x_predict = test[test['entity'] == subject]['date'].dt.dayofyear.values\n        submission_size = x_predict.size\n        # start calculating sigmoid at same point x_train_m starts\n        x_predict = np.arange(start=x_train_m[0], stop=x_predict[-1]+1)\n\n        params = solve(y_train_m)\n\n        if params != None:\n            params = (max(params[0], max(y_train_m)), params[1], params[2])\n            lower_bounds = (max(y_train_m), 0, 0)\n            upper_bounds = (max(population * herd_immunity * test_ratio, params[0]), np.inf, np.inf)\n\n            try:\n                params, _ = curve_fit(\n                    logistic,\n                    np.arange(x_train_m.size),\n                    y_train_m,\n                    p0=params,\n                    bounds=(lower_bounds, upper_bounds)\n#                    maxfev=100000\n                )\n            except:\n                print(subject, params, lower_bounds, upper_bounds)\n\n            y_eval = logistic(np.arange(x_train_m.size), params[0], params[1], params[2])\n            y_predict = logistic(np.arange(x_predict.size), params[0], params[1], params[2])\n\n            r2 = r2_score(y_train_m, y_eval)\n            covid.loc[covid['entity'] == subject, f'log_{target}'] = r2\n        else:\n            # a couple of countries remain which have too low numbers to fit the sigmoid\n            # simple regression with `np.maximum.accumulate` does the trick\n            model = Pipeline([\n                (\"polynomial_features\", PolynomialFeatures(degree=2)), \n                (\"linear_regression\", linear_model.Ridge())\n            ])\n            model.fit(np.arange(x_train_m.size).reshape(-1, 1), y_train_m)\n\n            y_eval = model.predict(np.arange(x_train_m.size).reshape(-1, 1))\n            y_predict = model.predict(np.arange(x_predict.size).reshape(-1 ,1))\n            y_predict = np.maximum.accumulate(y_predict).astype('int')\n            \n            r2 = r2_score(y_train_m, y_eval)\n            covid.loc[covid['entity'] == subject, f'poly_{target}'] = r2\n            \n        if subject in ['Hubei', 'Italy', 'New York', 'Nepal']:\n            plot_fit(x_train, y_train, x_predict, y_predict, target, r2)\n            \n        # assign the prediction to the test dataframe\n        delta = submission_size - y_predict.size\n        if delta > 0:\n            filler = [100] * delta if target == 'confirmed' else [1] * delta\n            y_predict = filler + y_predict.tolist()\n        test.loc[test['entity'] == subject, target] = y_predict[-submission_size:]","0b5c606e":"nonlogs = {}\n# resulting R2 scores for logistic approach\nfor target in ['confirmed', 'fatal']:\n    r2s = covid.groupby('entity')[f'log_{target}'].max()\n    print(r2s.describe())\n    nonlogs[target] = r2s[r2s.isna()].index.values\n    print(nonlogs[target])","783dd424":"# TODO: some weird ones in here\ntest.groupby('entity')['fatal'].max().sort_values(ascending=False).head(10)","1a2f8813":"# sanity check before submitting\nsubmission = test[['entity', 'date']].copy()\nsubmission[['confirmed', 'fatal']] = test[['confirmed', 'fatal']].fillna(0).astype('int')\nsubmission[submission['entity'] == 'Netherlands']","3b47cc50":"submission = submission[['confirmed', 'fatal']]\nsubmission.index.name = 'ForecastId'\nsubmission.columns = ['ConfirmedCases', 'Fatalities']\nsubmission.to_csv('submission.csv')","c009ebc7":"# To Sigmoid or not to Sigmoid, that is the Question\nA lot of people already noticed that the cumulative amount of cases for Hubei follows a sigmoid function. The general opinion however was that in a lot of countries\/regions it is still too early to try and fit these sigmoids. In my [notebook from last week]() I tried fitting them anyway, by making some 'educated' guesses about the expected maximum value and grow rate.\n\nThanks to [Sudeep Shouche](https:\/\/www.kaggle.com\/sudeepshouche) I came across the paper by Milan Batista entitled [\"*Estimation of the final size of the coronavirus epidemic by the logistic model*\"](https:\/\/www.researchgate.net\/publication\/339240777_Estimation_of_the_final_size_of_coronavirus_epidemic_by_the_logistic_model). What is interesting here is that **Batista is able to provide a mathematical solution** to these parameters.\n\n![](https:\/\/i.imgur.com\/mwMeNjf.png)\n[...]\n![](https:\/\/i.imgur.com\/YKkQfYe.png)"}}