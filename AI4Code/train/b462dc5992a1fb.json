{"cell_type":{"db233e47":"code","3e90d86e":"code","917c99fa":"code","a269a87f":"code","6ddd459f":"code","dfeac92f":"code","60002d58":"markdown","9957a8ec":"markdown","30d5bd18":"markdown","ddef88a9":"markdown","4387ba36":"markdown"},"source":{"db233e47":"import pandas as pd\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style('darkgrid')","3e90d86e":"xmin = 1\nxmax = 15","917c99fa":"def func(x):\n    return math.cos(x \/ 2) * math.exp(x \/ 42) + 8 * math.exp(-x \/ 2)","a269a87f":"# plot our func \nxmin = 1\nxmax = 15\nfloat_range_array = np.arange(start=xmin, stop=xmax, step=0.01) # in this way you can create a float step\nxlist = list(float_range_array)\nylist = [func (x) for x in xlist]\nplt.plot (xlist, ylist)\nplt.show()","6ddd459f":"# func to create our matrix A\ndef matrixA (x):\n    step = len(x)\n    values = []\n    \n    for i in x:\n        for j in range(step):\n            values.append(i**j)\n    res = np.array(values)\n    res = res.reshape(step,step)\n    return res\n\n# func for array b\n\ndef arrayB(x):\n    values = []\n    for i in x:\n        values.append(func(i))\n    res = np.array(values)\n    return res\n\n\ndef getW(w,x):\n    f = 0\n    for i in range(len(w)):\n        f = f + w[i] * x ** i\n    return f","dfeac92f":"X_values = [[1,15],[1,8,15],[ 1,4,10,15], [1,4,6, 10,12, 15]]\nfor x in X_values:\n    print ('Polynomial of degree:', len(x) - 1)\n    A = matrixA(x)\n    b = arrayB(x)\n    w = np.linalg.solve(A, b)\n    print (f'Solution {w}')\n    ylist_w = [getW(w , x) for x in xlist]\n    plt.plot (xlist, ylist, xlist, ylist_w)\n    plt.show()","60002d58":"Hello! a little theory block :)\n\nHope it will help someone - I am learning too and sometimes some things are difficult to understand :)   you can use this notebook for visualisation of func approximation\n\nA function approximation problem asks us to select a function among a well-defined class that closely matches a target function   \n\nLet us see a complex mathematical function on the line segment [1, 15]:  \n\n\n\nPolynomial of degree $n$ (i.e. $w_0 + w_1 x + w_2 x^2 + ... + w_n x^n$) uniquely identified by any $n + 1$ different points through which it passes. This means that its coefficients $w_0, ... w_n$ can be determined from the following system of linear equations:  \n\n\n\nwhere through $x_1, ..., x_n, x_{n+1}$ the points through which the polynomial passes, and through $f(x_1), ..., f(x_n), f(x_{n+1}$) \u2014the values \u200b\u200bthat it should take at these points.  \n\n\n\nWe will use the described property, and we will find an approximation of a function by a polynomial, solving a system of linear equations.  \n\n\n\n","9957a8ec":"We have the following func - You can take another function and experiment with it:\n\n$$ f(x) = cos(x \/ 2) * exp(x \/ 42) + 8 * exp(-x \/ 2) $$","30d5bd18":"We take a polynomial of the first degree $w0 + w1*x = y$  \n\n\nWe take $x$ (1 and 15) and y (calculate $f (x)$)  \n\n\nAt point 1 we get: $w0 + w1 * 1 = cos(1 \/ 2) * exp(1 \/ 42) + 8 * exp(-1 \/ 2)$  \n\n\nAt point 15 we get: $w0 + w1 * 15 = cos(15 \/ 2) * exp(15 \/ 42) + 8 * exp(-15 \/ 2)$\n\nWe get the system of equations:  \n\n\n$w0 + 1 * w1 = 6.126$  \n$w0 + 15 * w1 = -0.375$\n\n\nAnd so on for a polynomial of degree two, third and fourth, and fifth","ddef88a9":"Thank you for reading. Hope it is useful","4387ba36":"# Function approximation"}}