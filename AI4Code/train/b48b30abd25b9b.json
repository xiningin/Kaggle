{"cell_type":{"974c2613":"code","ab52bb20":"code","e9e3a65b":"code","ff59c08c":"code","3efa38e3":"code","ebcf4019":"code","20ab2db3":"code","2886f26e":"code","6ffb4981":"markdown","d10434b4":"markdown","c69135a8":"markdown","f1651bec":"markdown","55c01f1f":"markdown","ee5ef4a8":"markdown","8effebc1":"markdown"},"source":{"974c2613":"import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\nimport matplotlib.gridspec as gridspec\nfrom scipy import signal\n\nmatplotlib.rcParams['pdf.fonttype'] = 42\nmatplotlib.rcParams['svg.fonttype'] = 'none'","ab52bb20":"#%% script params\n\nnum_axons = 3\nnum_dendrites = 9\n\naxon_colors = ['magenta', 'teal', 'purple']\n\nnum_spikes_per_axon = 3\nexperiment_time_ms  = 300\n\ntau_rise_range  = [1,9]\ntau_decay_range = [5,30]\n\nv_reset     = -80\nv_threshold = -55\ncurrent_to_voltage_mult_factor = 4\nrefreactory_time_constant = 25\n\nsave_figures = True\nsave_figures = False\nall_file_endings_to_use = ['.png', '.pdf', '.svg']\n\nfigure_folder = '\/kaggle\/working\/'","e9e3a65b":"#%% helper functions\n\n\ndef create_single_PSP_profile(tau_rise, tau_decay, temporal_filter_length=50):\n\n    if tau_rise >= tau_decay:\n        tau_decay = tau_rise + 5\n\n    exp_r = signal.exponential(M=temporal_filter_length, center=0, tau=tau_rise , sym=False)\n    exp_d = signal.exponential(M=temporal_filter_length, center=0, tau=tau_decay, sym=False)\n\n    post_syn_potential = exp_d - exp_r\n    post_syn_potential \/= post_syn_potential.max()\n\n    return post_syn_potential\n\n\ndef construct_normlized_synaptic_filter(tau_rise_vec, tau_decay_vec):\n\n    num_synapses = tau_rise_vec.shape[0]\n    temporal_filter_length = int(7 * tau_decay_vec.max()) + 1\n\n    syn_filter = np.zeros((num_synapses, temporal_filter_length))\n\n    for k, (tau_r, tau_d) in enumerate(zip(tau_rise_vec, tau_decay_vec)):\n        syn_filter[k,:] = create_single_PSP_profile(tau_r, tau_d, temporal_filter_length=temporal_filter_length)\n\n    return syn_filter\n\n\ndef simulate_filter_and_fire_cell_training(presynaptic_input_spikes, synaptic_weights, tau_rise_vec, tau_decay_vec,\n                                           refreactory_time_constant=20, v_reset=-75, v_threshold=-55, current_to_voltage_mult_factor=2):\n\n    temporal_filter_length = int(5 * refreactory_time_constant) + 1\n    refreactory_filter = signal.exponential(M=temporal_filter_length,center=0,tau=refreactory_time_constant,sym=False)[np.newaxis,:]\n\n    # padd input and get all synaptic filters\n    normlized_syn_filter = np.flipud(construct_normlized_synaptic_filter(tau_rise_vec, tau_decay_vec))\n    padded_input = np.hstack((np.zeros(normlized_syn_filter.shape), presynaptic_input_spikes))\n\n    # calc local currents\n    local_normlized_currents = np.zeros(presynaptic_input_spikes.shape, dtype=np.float16)\n    for k in range(normlized_syn_filter.shape[0]):\n        local_normlized_currents[k] = signal.convolve(padded_input[k], normlized_syn_filter[k], mode='valid')[1:]\n\n    # multiply by weights to get the somatic current\n    soma_current = signal.convolve(local_normlized_currents, synaptic_weights, mode='valid')\n\n    # simulate the cell\n    soma_voltage = v_reset + current_to_voltage_mult_factor * soma_current.ravel()\n    output_spike_times_in_ms = []\n    # after a spike inject current that is exactly required to bring the cell back to v_reset (this current slowly decays)\n    for t in range(len(soma_voltage)):\n        # after a spike inject current that is exactly required to bring the cell back to v_reset (this current slowly decays)\n        if (soma_voltage[t] > v_threshold) and ((t + 1) < len(soma_voltage)):\n            t_start = t + 1\n            t_end = min(len(soma_voltage), t_start + temporal_filter_length)\n            soma_voltage[t_start:t_end] -= (soma_voltage[t + 1] - v_reset) * refreactory_filter.ravel()[:(t_end - t_start)]\n            output_spike_times_in_ms.append(t)\n\n    return local_normlized_currents, soma_voltage, output_spike_times_in_ms\n\n\ndef add_offset_for_plotting(traces_matrix, offset_size=1.1):\n\n    traces_matrix_with_offset = offset_size * np.kron(np.arange(traces_matrix.shape[0])[:,np.newaxis], np.ones((1,traces_matrix.shape[1])))\n    traces_matrix_with_offset = traces_matrix_with_offset + traces_matrix\n\n    return traces_matrix_with_offset\n","ff59c08c":"#%% simulate the cell\n\nconnections_per_axon = int(num_dendrites \/ num_axons)\nnum_synapses = num_dendrites\n\ntau_rise_vec  = np.linspace(tau_rise_range[0] , tau_rise_range[1] , num_synapses)[:,np.newaxis]\ntau_decay_vec = np.linspace(tau_decay_range[0], tau_decay_range[1], num_synapses)[:,np.newaxis]\n\n# synapse learnable parameters\nsynaptic_weights_vec = 1.0 + 0.1 * np.random.uniform(size=(num_synapses, 1))\n\nsynaptic_filters = construct_normlized_synaptic_filter(tau_rise_vec, tau_decay_vec)\n\n#%% run once\n\n# generate sample input\nstimulus_duration_ms = experiment_time_ms\n\naxon_input_spike_train = np.zeros((num_axons, stimulus_duration_ms))\nfor k in range(num_axons):\n    curr_axon_spike_times = 20 + np.random.randint(stimulus_duration_ms -80, size=num_spikes_per_axon)\n    axon_input_spike_train[k,curr_axon_spike_times] = 1.0\n\npresynaptic_input_spikes = np.kron(np.ones((connections_per_axon,1), dtype=bool), axon_input_spike_train).astype(bool)\n\n# simulate F&F cell with normlized currents\nlocal_normlized_currents, soma_voltage, output_spike_times_in_ms = simulate_filter_and_fire_cell_training(presynaptic_input_spikes,\n                                                                                                          synaptic_weights_vec, tau_rise_vec, tau_decay_vec,\n                                                                                                          refreactory_time_constant=refreactory_time_constant,\n                                                                                                          v_reset=v_reset, v_threshold=v_threshold,\n                                                                                                          current_to_voltage_mult_factor=current_to_voltage_mult_factor)\n\nlocal_normlized_currents = np.flipud(local_normlized_currents)\n\nsoma_voltage_with_spikes = soma_voltage\nsoma_voltage_with_spikes[output_spike_times_in_ms] = -25\n\n\nmax_local_added_voltage = add_offset_for_plotting(local_normlized_currents).T.max()\n\nprint('running once')\n\n\n#%% run again until we have at least 1 spike\n\nwhile len(output_spike_times_in_ms) != 1 or max_local_added_voltage > 10.15:\n    axon_input_spike_train = np.zeros((num_axons, stimulus_duration_ms))\n    for k in range(num_axons):\n        curr_axon_spike_times = 30 + np.random.randint(stimulus_duration_ms -60, size=num_spikes_per_axon)\n        axon_input_spike_train[k,curr_axon_spike_times] = 1.0\n\n    presynaptic_input_spikes = np.kron(np.ones((connections_per_axon,1), dtype=bool), axon_input_spike_train).astype(bool)\n\n    # simulate F&F cell with normlized currents\n    local_normlized_currents, soma_voltage, output_spike_times_in_ms = simulate_filter_and_fire_cell_training(presynaptic_input_spikes,\n                                                                                                              synaptic_weights_vec, tau_rise_vec, tau_decay_vec,\n                                                                                                              refreactory_time_constant=refreactory_time_constant,\n                                                                                                              v_reset=v_reset, v_threshold=v_threshold,\n                                                                                                              current_to_voltage_mult_factor=current_to_voltage_mult_factor)\n\n    local_normlized_currents = np.flipud(local_normlized_currents)\n\n    soma_voltage_with_spikes = soma_voltage\n    soma_voltage_with_spikes[output_spike_times_in_ms] = -15\n\n    max_local_added_voltage = add_offset_for_plotting(local_normlized_currents).T.max()\n\nprint('there is at least 1 spike')\n\n#%% run untill we have a changed enough spike location\n\nmin_spike_time_diff = 35\nmax_local_added_voltage = 0\n\nwhile True:\n\n    output_spike_times_in_ms =[]\n\n    # generate input axons with a single spike\n    while len(output_spike_times_in_ms) != 1 or max_local_added_voltage > 10.15:\n        axon_input_spike_train = np.zeros((num_axons, stimulus_duration_ms))\n        for k in range(num_axons):\n            curr_axon_spike_times = 30 + np.random.randint(stimulus_duration_ms -60, size=num_spikes_per_axon)\n            axon_input_spike_train[k,curr_axon_spike_times] = 1.0\n\n        presynaptic_input_spikes = np.kron(np.ones((connections_per_axon,1), dtype=bool), axon_input_spike_train).astype(bool)\n\n        # simulate F&F cell with normlized currents\n        local_normlized_currents, soma_voltage, output_spike_times_in_ms = simulate_filter_and_fire_cell_training(presynaptic_input_spikes,\n                                                                                                                  synaptic_weights_vec, tau_rise_vec, tau_decay_vec,\n                                                                                                                  refreactory_time_constant=refreactory_time_constant,\n                                                                                                                  v_reset=v_reset, v_threshold=v_threshold,\n                                                                                                                  current_to_voltage_mult_factor=current_to_voltage_mult_factor)\n\n        local_normlized_currents = np.flipud(local_normlized_currents)\n\n        soma_voltage_with_spikes = soma_voltage\n        soma_voltage_with_spikes[output_spike_times_in_ms] = -15\n\n        max_local_added_voltage = add_offset_for_plotting(local_normlized_currents).T.max()\n\n        if len(output_spike_times_in_ms) == 1 and (output_spike_times_in_ms[0] > 200 or output_spike_times_in_ms[0] < 120):\n            output_spike_times_in_ms = []\n\n    print('there is at least 1 spike, spike times: ', output_spike_times_in_ms)\n\n    # generate a weights change that will move this spikes by a minimum amount\n    mult_vector = np.random.permutation([0.25,0.5,0.5,0.75,1.25,1.5,1.75,1.75,2.0])[:,np.newaxis]\n    synaptic_weights_vec_2 = mult_vector * synaptic_weights_vec\n\n    # make sure only the a the middle axon weights are changed (for non cluttered visualization)\n    synaptic_weights_vec_2[0::3] = synaptic_weights_vec[0::3]\n    synaptic_weights_vec_2[2::3] = synaptic_weights_vec[2::3]\n    mult_vector[0::3] = 1\n    mult_vector[2::3] = 1\n\n    # simulate F&F cell with normlized currents\n    local_normlized_currents_2, soma_voltage_2, output_spike_times_in_ms_2 = simulate_filter_and_fire_cell_training(presynaptic_input_spikes,\n                                                                                                                    synaptic_weights_vec_2, tau_rise_vec, tau_decay_vec,\n                                                                                                                    refreactory_time_constant=refreactory_time_constant,\n                                                                                                                    v_reset=v_reset, v_threshold=v_threshold,\n                                                                                                                    current_to_voltage_mult_factor=current_to_voltage_mult_factor)\n\n    local_normlized_currents_2 = np.flipud(local_normlized_currents_2)\n\n    soma_voltage_with_spikes_2 = soma_voltage_2\n    soma_voltage_with_spikes_2[output_spike_times_in_ms_2] = -15\n\n    max_local_added_voltage_2 = add_offset_for_plotting(local_normlized_currents_2).T.max()\n\n    local_normlized_currents_2 = mult_vector * local_normlized_currents_2\n\n    if len(output_spike_times_in_ms_2) == 1 and ((output_spike_times_in_ms[0] - output_spike_times_in_ms_2[0]) <= -min_spike_time_diff):\n        break\n\nprint('changed weights such that the spike changed location for more than %d ms' %(min_spike_time_diff))\n","3efa38e3":"#%% Display Input Axons, Synaptic Filters and Local Voltage Traces \"Slopily\"\n\nplt.close('all')\nfig = plt.figure(figsize=(20,8))\nplt.subplots_adjust(left=0.03, right=0.97, top=0.95, bottom=0.05, wspace=0.25, hspace=0.35)\n\nplt.subplot(1,3,1);\nfor k, axon_color in enumerate(axon_colors):\n    plt.plot(add_offset_for_plotting(np.flipud(axon_input_spike_train)).T[:,k], color=axon_color); plt.title('Input Axons', fontsize=24);\n\nplt.subplot(1,3,2);\nfor k, axon_color in enumerate(axon_colors):\n    plt.plot(add_offset_for_plotting(synaptic_filters).T[:100,k::num_axons], color=axon_color); plt.title('Synaptic Filters', fontsize=24);\n\nplt.subplot(1,3,3);\nfor k, axon_color in enumerate(axon_colors):\n    plt.plot(add_offset_for_plotting(local_normlized_currents).T[:,k::num_axons], color=axon_color); plt.title('Synaptic Contact Voltage Contribution', fontsize=24);\n    plt.plot(add_offset_for_plotting(local_normlized_currents_2).T[:,k::num_axons], color=axon_color, linestyle='dashed');\n","ebcf4019":"#%% plot one below each other\n\nplt.close('all')\nplt.figure(figsize=(10,25))\ngs_figure = gridspec.GridSpec(nrows=11,ncols=1)\ngs_figure.update(left=0.04, right=0.95, bottom=0.05, top=0.95, wspace=0.1, hspace=0.8)\n\nax_axons          = plt.subplot(gs_figure[:3,:])\nax_local_voltages = plt.subplot(gs_figure[3:9,:])\nax_soma_voltage   = plt.subplot(gs_figure[9:,:])\n\nax_axons.plot(add_offset_for_plotting(axon_input_spike_train).T); ax_axons.set_title('Input Axons', fontsize=24);\nax_local_voltages.plot(add_offset_for_plotting(local_normlized_currents).T); ax_local_voltages.set_title('Synaptic Contact Voltage Contribution', fontsize=24);\nax_local_voltages.plot(add_offset_for_plotting(local_normlized_currents_2).T, linestyle='dashed');\nax_soma_voltage.plot(soma_voltage_with_spikes); ax_soma_voltage.set_title('Somatic Voltage', fontsize=24);\nax_soma_voltage.plot(soma_voltage_with_spikes_2, linestyle='dashed');\n","20ab2db3":"#%% Display The Full Figure\n\nplt.close('all')\nfig = plt.figure(figsize=(25,18))\ngs_figure = gridspec.GridSpec(nrows=11,ncols=30)\ngs_figure.update(left=0.04, right=0.95, bottom=0.05, top=0.92, wspace=0.2, hspace=0.7)\n\nax_axons         = plt.subplot(gs_figure[2:6,:9])\nax_syn_filters   = plt.subplot(gs_figure[:8,13:17])\nax_local_voltges = plt.subplot(gs_figure[:8,21:])\nax_soma_voltage  = plt.subplot(gs_figure[8:,21:])\n\n\nfor k, axon_color in enumerate(axon_colors):\n    ax_axons.plot(add_offset_for_plotting(np.flipud(axon_input_spike_train)).T[:,k], color=axon_color, lw=3);\nax_axons.set_yticks([])\nax_axons.set_xticks([])\nax_axons.set_title('Input Axons', fontsize=20);\nax_axons.spines['top'].set_visible(False)\nax_axons.spines['bottom'].set_visible(False)\nax_axons.spines['left'].set_visible(False)\nax_axons.spines['right'].set_visible(False)\n\nfor k, axon_color in enumerate(axon_colors):\n    ax_syn_filters.plot(add_offset_for_plotting(synaptic_filters).T[:100,k::num_axons], color=axon_color, lw=3);\nax_syn_filters.set_yticks([])\nax_syn_filters.set_xticks([])\nax_syn_filters.set_title('Synaptic Filters', fontsize=20);\nax_syn_filters.spines['top'].set_visible(False)\nax_syn_filters.spines['bottom'].set_visible(False)\nax_syn_filters.spines['left'].set_visible(False)\nax_syn_filters.spines['right'].set_visible(False)\n\nfor k, axon_color in enumerate(axon_colors):\n    ax_local_voltges.plot(add_offset_for_plotting(local_normlized_currents).T[:,k::num_axons], color=axon_color, lw=3);\n    ax_local_voltges.plot(add_offset_for_plotting(local_normlized_currents_2).T[:,k::num_axons], color=axon_color, ls='dashed', lw=2.5);\nax_local_voltges.set_xticks([])\nax_local_voltges.set_yticks([])\nax_local_voltges.set_title('Synaptic Contact Voltage Contribution', fontsize=20);\nax_local_voltges.spines['top'].set_visible(False)\nax_local_voltges.spines['bottom'].set_visible(False)\nax_local_voltges.spines['left'].set_visible(False)\nax_local_voltges.spines['right'].set_visible(False)\n\nax_soma_voltage.plot(soma_voltage_with_spikes, color='0.1', lw=3, alpha=0.85);\nax_soma_voltage.plot(soma_voltage_with_spikes_2, color='dodgerblue', lw=3);\nax_soma_voltage.set_yticks([])\nax_soma_voltage.set_xticks([])\nax_soma_voltage.set_title('Somatic Voltage', fontsize=20);\nax_soma_voltage.spines['top'].set_visible(False)\nax_soma_voltage.spines['bottom'].set_visible(False)\nax_soma_voltage.spines['left'].set_visible(False)\nax_soma_voltage.spines['right'].set_visible(False)\n","2886f26e":"save_figures = True\n\n# save figure\nif save_figures:\n    figure_name = 'F&F_A_Introduction_Figure_1_%d' %(np.random.randint(2000))\n    for file_ending in all_file_endings_to_use:\n        if file_ending == '.png':\n            fig.savefig(figure_folder + figure_name + file_ending, bbox_inches='tight')\n        else:\n            fig.savefig(figure_folder + figure_name + file_ending, bbox_inches='tight')\n","6ffb4981":"## Display Input Axons, Synaptic Filters and Local Voltage Traces \"Sloppily\"\n","d10434b4":"## Save the figure in multiple file formats","c69135a8":"## Simulate the Filter and Fire (F&F) Neuron\n#### Run untill weight configuration change results in significant changed spike location","f1651bec":"# Display the full figure","55c01f1f":"## Plot one below each other","ee5ef4a8":"## Main script params\n","8effebc1":"## Helper functions"}}