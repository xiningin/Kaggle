{"cell_type":{"8e65530e":"code","53c01c89":"code","edff6e69":"code","5c53df9d":"code","c2b7aec5":"code","b5db32ae":"code","a6ab3101":"code","22eab081":"markdown","f2e443cc":"markdown","a1a397ad":"markdown","30bb8a85":"markdown","4d85c716":"markdown","facbcb92":"markdown"},"source":{"8e65530e":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","53c01c89":"class Employee:\n    \n    def __init__(self,first,last,salary):\n        self.first = first\n        self.last = last\n        self.salary = salary\n        self.email = first + '.' + last + '.' + '@company.com'\n    \n    def fullname(self):\n        return '{} {}'.format(self.first,self.last)\n    \nemp1 = Employee('Pratik','Shinde',60000)\nemp2 = Employee('Adam','West',50000)\n\nemp1.fullname()\nprint(Employee.fullname(emp1))\n#Both of these commands give same results\n    \n    ","edff6e69":"class Employee:\n    \n    raise_amount = 1.04\n    no_of_employees = 0\n    def __init__(self,first,last,pay):\n        self.first = first\n        self.last = last\n        self.pay = pay\n        self.email = first + '.' + last + '.' + '@company.com'\n        \n        Employee.no_of_employees +=1 #Counter\n        \n    def fullname(self):\n        return '{} {}'.format(self.first,self.last)\n    \n    def apply_raise(self):\n        self.pay = int(self.pay * Employee.raise_amount)\n        # Instead of hardcoding the raise amount, we can declare it a class variable, so need to change only at one place without changing it everywhere\n    \nprint(Employee.no_of_employees)    \nemp1 = Employee('Pratik','Shinde',60000)\nemp2 = Employee('Akaash','Trivedi',90000)\nemp1.apply_raise()\nprint(Employee.no_of_employees)\n# Notice the no of employees before and after creating the instances\n\nprint(emp1.__dict__)\nprint(emp2.__dict__)\nprint(Employee.__dict__)\n\n# Here raise_amount and no_of_employees are Class variables that's why we can't see them in the instance dictionaries. We can see them in class dictionary","5c53df9d":"# Regular methods take class instances as their argument(e.g. self)\n# We can turn any regular method into a class method by adding decorator @classmethod.. These methods take class as their first instance.\n# Static methods don't take instance or the class as their first argument. So we can work with anything.\n\nclass Employee:\n    \n    raise_amount = 1.04\n    no_of_employees = 0\n    def __init__(self,first,last,pay):\n        self.first = first\n        self.last = last\n        self.pay = pay\n        self.email = first + '.' + last + '.' + '@company.com'\n        \n        Employee.no_of_employees +=1 #Counter\n        \n    def fullname(self):\n        return '{} {}'.format(self.first,self.last)\n    \n    def apply_raise(self):\n        self.pay = int(self.pay * Employee.raise_amount)\n       \n    @classmethod\n    def set_raise_amt(cls, amount):\n        cls.raise_amt = amount\n        \n    @classmethod\n    def from_string(cls, emp_str):\n        first, last, pay = emp_str.split('-')\n        return Employee(first, last, pay)\n        #return cls(first, last, pay)  Same as above\n        \n    @staticmethod\n    def is_workday(day):\n        if day.weekday()==5 or day.weekday()==6:\n            return False\n        return True\n        \n    \n  \nemp1 = Employee('Pratik','Shinde',60000)\nemp2 = Employee('Adam','West',50000)\n\nemp_str1 = 'John-Doe-30000'\nemp_str2 = 'Virat-Kohli-40000'\nemp_str3 = 'Optimus-Prime-50000'\n\nnew_emp1 = Employee.from_string(emp_str1) # Have to call a classmethod by class name\nnew_emp2 = Employee.from_string(emp_str2)\nnew_emp3 = Employee.from_string(emp_str3)\n\nprint(new_emp1.first)\n\nEmployee.set_raise_amt(1.09) #Another way of setting raising amount for every instance of the class at once by using a class method\nprint(emp1.raise_amt)\nprint(emp2.raise_amt)\n\nimport datetime\nmy_date =  datetime.date(2020, 8, 13)\n\nprint(Employee.is_workday(my_date)) #Static methods are also called with class names\n","c2b7aec5":"class Employee:\n\n    raise_amt = 1.04\n\n    def __init__(self, first, last, pay):\n        self.first = first\n        self.last = last\n        self.email = first + '.' + last + '@email.com'\n        self.pay = pay\n\n    def fullname(self):\n        return '{} {}'.format(self.first, self.last)\n\n    def apply_raise(self):\n        self.pay = int(self.pay * self.raise_amt)\n\n\nclass Developer(Employee):\n    raise_amt = 1.10\n\n    def __init__(self, first, last, pay, prog_lang):\n        super().__init__(first, last, pay)\n        self.prog_lang = prog_lang\n\n\nclass Manager(Employee):\n\n    def __init__(self, first, last, pay, employees=None):\n        super().__init__(first, last, pay)\n        if employees is None:\n            self.employees = []\n        else:\n            self.employees = employees\n\n    def add_emp(self, emp):\n        if emp not in self.employees:\n            self.employees.append(emp)\n\n    def remove_emp(self, emp):\n        if emp in self.employees:\n            self.employees.remove(emp)\n\n    def print_emps(self):\n        for emp in self.employees:\n            print('-->', emp.fullname())\n\n\ndev_1 = Developer('Corey', 'Schafer', 50000, 'Python')\ndev_2 = Developer('Test', 'Employee', 60000, 'Java')\n\nmgr_1 = Manager('Sue', 'Smith', 90000, [dev_1])\n\nprint(mgr_1.email)\n\nmgr_1.add_emp(dev_2)\nmgr_1.remove_emp(dev_2)\n\nmgr_1.print_emps()","b5db32ae":"class Employee:\n\n    raise_amt = 1.04\n\n    def __init__(self, first, last, pay):\n        self.first = first\n        self.last = last\n        self.email = first + '.' + last + '@email.com'\n        self.pay = pay\n\n    def fullname(self):\n        return '{} {}'.format(self.first, self.last) #using placeholders\n\n    def apply_raise(self):\n        self.pay = int(self.pay * self.raise_amt)\n\n    def __repr__(self):\n        return \"Employee('{}', '{}', {})\".format(self.first, self.last, self.pay)\n\n    def __str__(self):\n        return '{} - {}'.format(self.fullname(), self.email)\n\n    def __add__(self, other):\n        return self.pay + other.pay\n\n    def __len__(self):\n        return len(self.fullname())\n\n\nemp_1 = Employee('Corey', 'Schafer', 50000)\nemp_2 = Employee('Test', 'Employee', 60000)\n\n# print(emp_1 + emp_2)\n\nprint(len(emp_1))","a6ab3101":"class Employee:\n\n    def __init__(self, first, last):\n        self.first = first\n        self.last = last\n\n    @property        # Getter\n    def email(self):\n        return '{}.{}@email.com'.format(self.first, self.last)\n\n    @property        # Getter\n    def fullname(self):\n        return '{} {}'.format(self.first, self.last)\n    \n    @fullname.setter\n    def fullname(self, name):\n        first, last = name.split(' ')\n        self.first = first\n        self.last = last\n    \n    @fullname.deleter\n    def fullname(self):\n        print('Delete Name!')\n        self.first = None\n        self.last = None\n\n\nemp_1 = Employee('John', 'Smith')\nemp_1.fullname = \"Corey Schafer\"\n\nprint(emp_1.first)\nprint(emp_1.email)\nprint(emp_1.fullname)\n\ndel emp_1.fullname","22eab081":"**Property Decorators**","f2e443cc":"**Class Variables**","a1a397ad":"**Class and its Instances**","30bb8a85":"**Regular Methods, Class Methods and Static Methods**","4d85c716":"**Magic\/Dunder Methods**","facbcb92":"**Inheritance**"}}