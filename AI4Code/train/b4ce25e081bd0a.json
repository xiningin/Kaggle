{"cell_type":{"156638a7":"code","121c404a":"code","49a75ad3":"code","2ced777b":"code","1b4ab513":"code","5f8d4525":"code","bd8bc2c0":"code","a62e22da":"code","c5823847":"code","76c78af9":"code","733e60b7":"code","0e17609a":"code","8d615889":"code","d56fe1be":"code","d1f6d2e9":"code","bae8bfd7":"code","589f889a":"code","f8dafbff":"code","24624da2":"code","ebda9417":"code","3fd424b0":"code","be463cdd":"code","2c26c756":"code","a8cca3c9":"code","c5dbbb8f":"code","876b7ec2":"code","e5ee2873":"code","dcd740c7":"code","ec89642e":"code","425b3423":"code","ca816199":"code","0f78378f":"code","c88f3623":"markdown","94ac1d97":"markdown","41623f57":"markdown","40c0622a":"markdown","7048738a":"markdown"},"source":{"156638a7":"%matplotlib inline\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os, glob, time, copy, random, zipfile\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom sklearn.model_selection import train_test_split\nfrom tqdm import tqdm_notebook as tqdm\n\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.utils.data as data\nimport torch.nn.functional as F\nimport torchvision\nfrom torchvision import models, transforms","121c404a":"torch.__version__","49a75ad3":"# Check Current Directory\nos.listdir('..\/input\/dogs-vs-cats-redux-kernels-edition')","2ced777b":"# Make Directory for extracting from Zip\nos.makedirs('..\/data', exist_ok=True)","1b4ab513":"# Train_dir, Test_dir\nbase_dir = '..\/input\/dogs-vs-cats-redux-kernels-edition'\ntrain_dir = '..\/data\/train'\ntest_dir = '..\/data\/test'","5f8d4525":"# Extract All Data From Zip to \"..\/data\" Directory\nwith zipfile.ZipFile(os.path.join(base_dir, 'train.zip')) as train_zip:\n    train_zip.extractall('..\/data')\n    \nwith zipfile.ZipFile(os.path.join(base_dir, 'test.zip')) as test_zip:\n    test_zip.extractall('..\/data')","bd8bc2c0":"# Check File Name\nos.listdir(train_dir)[:5]","a62e22da":"# FilePath List\ntrain_list = glob.glob(os.path.join(train_dir, '*.jpg'))\ntest_list = glob.glob(os.path.join(test_dir, '*.jpg'))","c5823847":"img = Image.open(train_list[0])\nplt.imshow(img)\nplt.axis('off')\nplt.show()","76c78af9":"img = Image.open(test_list[0])\nplt.imshow(img)\nplt.axis('off')\nplt.show()","733e60b7":"# Label is contained in filepath\ntrain_list[:5]","0e17609a":"# Image_Id is contained in filepath\ntest_list[:5]","8d615889":"# Get Label\ntrain_list[0].split('\/')[-1].split('.')[0]","d56fe1be":"# Get Image_Id\nint(test_list[0].split('\/')[-1].split('.')[0])","d1f6d2e9":"# Number of Train Image\nlen(train_list)","bae8bfd7":"# Nuber of Test Image\nlen(test_list)","589f889a":"# Divide Train, Valid Data\ntrain_list, val_list = train_test_split(train_list, test_size=0.1)","f8dafbff":"print(len(train_list))\nprint(len(val_list))","24624da2":"# Data Augumentation\nclass ImageTransform():\n    \n    def __init__(self, resize, mean, std):\n        self.data_transform = {\n            'train': transforms.Compose([\n                transforms.RandomResizedCrop(resize, scale=(0.5, 1.0)),\n                transforms.RandomHorizontalFlip(),\n                transforms.ToTensor(),\n                transforms.Normalize(mean, std)\n            ]),\n            'val': transforms.Compose([\n                transforms.Resize(256),\n                transforms.CenterCrop(resize),\n                transforms.ToTensor(),\n                transforms.Normalize(mean, std)\n            ])\n        }\n        \n    def __call__(self, img, phase):\n        return self.data_transform[phase](img)","ebda9417":"# Dataset\nclass DogvsCatDataset(data.Dataset):\n    \n    def __init__(self, file_list, transform=None, phase='train'):    \n        self.file_list = file_list\n        self.transform = transform\n        self.phase = phase\n        \n    def __len__(self):\n        return len(self.file_list)\n    \n    def __getitem__(self, idx):\n        \n        img_path = self.file_list[idx]\n        img = Image.open(img_path)\n        \n        img_transformed = self.transform(img, self.phase)\n        \n        # Get Label\n        label = img_path.split('\/')[-1].split('.')[0]\n        if label == 'dog':\n            label = 1\n        elif label == 'cat':\n            label = 0\n\n        return img_transformed, label","3fd424b0":"# Config\nsize = 224\nmean = (0.485, 0.456, 0.406)\nstd = (0.229, 0.224, 0.225)\nbatch_size = 32\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")","be463cdd":"# Dataset\ntrain_dataset = DogvsCatDataset(train_list, transform=ImageTransform(size, mean, std), phase='train')\nval_dataset = DogvsCatDataset(val_list, transform=ImageTransform(size, mean, std), phase='val')\n\n# Operation Check\nprint('Operation Check')\nindex = 0\nprint(train_dataset.__getitem__(index)[0].size())\nprint(train_dataset.__getitem__(index)[1])","2c26c756":"# DataLoader\ntrain_dataloader = data.DataLoader(train_dataset, batch_size=batch_size, shuffle=True)\nval_dataloader = data.DataLoader(val_dataset, batch_size=batch_size, shuffle=False)\n\ndataloader_dict = {'train': train_dataloader, 'val': val_dataloader}\n\n# Operation Check\nprint('Operation Check')\nbatch_iterator = iter(train_dataloader)\ninputs, label = next(batch_iterator)\nprint(inputs.size())\nprint(label)","a8cca3c9":"# VGG16 Model Loading\nuse_pretrained = True\nnet = models.vgg16(pretrained=use_pretrained)\nprint(net)","c5dbbb8f":"# Change Last Layer\n# Output Features 1000 \u2192 2\nnet.classifier[6] = nn.Linear(in_features=4096, out_features=2)\nprint('Done')","876b7ec2":"# Specify The Layers for updating\nparams_to_update = []\n\nupdate_params_name = ['classifier.6.weight', 'classifier.6.bias']\n\nfor name, param in net.named_parameters():\n    if name in update_params_name:\n        param.requires_grad = True\n        params_to_update.append(param)\n        print(name)\n    else:\n        param.requires_grad = False","e5ee2873":"criterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(params=params_to_update, lr=0.001, momentum=0.9)","dcd740c7":"def train_model(net, dataloader_dict, criterion, optimizer, num_epoch):\n    \n    since = time.time()\n    best_model_wts = copy.deepcopy(net.state_dict())\n    best_acc = 0.0\n    net = net.to(device)\n    \n    for epoch in range(num_epoch):\n        print('Epoch {}\/{}'.format(epoch + 1, num_epoch))\n        print('-'*20)\n        \n        for phase in ['train', 'val']:\n            \n            if phase == 'train':\n                net.train()\n            else:\n                net.eval()\n                \n            epoch_loss = 0.0\n            epoch_corrects = 0\n            \n            for inputs, labels in tqdm(dataloader_dict[phase]):\n                inputs = inputs.to(device)\n                labels = labels.to(device)\n                optimizer.zero_grad()\n                \n                with torch.set_grad_enabled(phase == 'train'):\n                    outputs = net(inputs)\n                    _, preds = torch.max(outputs, 1)\n                    loss = criterion(outputs, labels)\n                    \n                    if phase == 'train':\n                        loss.backward()\n                        optimizer.step()\n                        \n                    epoch_loss += loss.item() * inputs.size(0)\n                    epoch_corrects += torch.sum(preds == labels.data)\n                    \n            epoch_loss = epoch_loss \/ len(dataloader_dict[phase].dataset)\n            epoch_acc = epoch_corrects.double() \/ len(dataloader_dict[phase].dataset)\n            \n            print('{} Loss: {:.4f} Acc: {:.4f}'.format(phase, epoch_loss, epoch_acc))\n            \n            # deep copy the model\n            if phase == 'val' and epoch_acc > best_acc:\n                best_acc = epoch_acc\n                best_model_wts = copy.deepcopy(net.state_dict())\n                \n    time_elapsed = time.time() - since\n    print('Training complete in {:.0f}m {:.0f}s'.format(\n        time_elapsed \/\/ 60, time_elapsed % 60))\n    print('Best val Acc: {:4f}'.format(best_acc))\n\n    # load best model weights\n    net.load_state_dict(best_model_wts)\n    return net","ec89642e":"# Train\nnum_epoch = 2\nnet = train_model(net, dataloader_dict, criterion, optimizer, num_epoch)","425b3423":"# Prediction\nid_list = []\npred_list = []\n\nwith torch.no_grad():\n    for test_path in tqdm(test_list):\n        img = Image.open(test_path)\n        _id = int(test_path.split('\/')[-1].split('.')[0])\n\n        transform = ImageTransform(size, mean, std)\n        img = transform(img, phase='val')\n        img = img.unsqueeze(0)\n        img = img.to(device)\n\n        net.eval()\n\n        outputs = net(img)\n        preds = F.softmax(outputs, dim=1)[:, 1].tolist()\n        \n        id_list.append(_id)\n        pred_list.append(preds[0])\n    \n    \nres = pd.DataFrame({\n    'id': id_list,\n    'label': pred_list\n})\n\nres.sort_values(by='id', inplace=True)\nres.reset_index(drop=True, inplace=True)\n\nres.to_csv('submission.csv', index=False)","ca816199":"res.head(10)","0f78378f":"# Visualize Prediction\nid_list = []\nclass_ = {0: 'cat', 1: 'dog'}\n\nfig, axes = plt.subplots(2, 5, figsize=(20, 12), facecolor='w')\n\nfor ax in axes.ravel():\n    \n    i = random.choice(res['id'].values)\n    \n    label = res.loc[res['id'] == i, 'label'].values[0]\n    if label > 0.5:\n        label = 1\n    else:\n        label = 0\n        \n    img_path = os.path.join(test_dir, '{}.jpg'.format(i))\n    img = Image.open(img_path)\n    \n    ax.set_title(class_[label])\n    ax.imshow(img)","c88f3623":"---\n## Model","94ac1d97":"Each train Data and test data is in 'Zipfile'\nSo, We need to extract from ZipFile","41623f57":"---\n## Data Confirm","40c0622a":"---\n## Predict","7048738a":"---\n## Train"}}