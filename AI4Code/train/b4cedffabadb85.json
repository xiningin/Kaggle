{"cell_type":{"095c1f10":"code","453534ea":"code","63b6f471":"code","c9943d12":"code","2f408afd":"code","b71025b8":"code","59fcbd64":"code","9830041c":"code","5f9ff7ab":"code","8c998698":"code","00f94887":"code","6ec84c8f":"code","f13e6ae2":"code","b2e6792a":"code","2db2635e":"code","ee6c21ee":"markdown","8127125e":"markdown","d909abbc":"markdown","33d4ef9c":"markdown","fd3f6abb":"markdown","a3582696":"markdown","8d710f25":"markdown","2912d29c":"markdown","5aac83ae":"markdown","803f74a8":"markdown","b883c71a":"markdown","00262a65":"markdown","3bc7fb68":"markdown"},"source":{"095c1f10":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","453534ea":"!pip install python-resize-image\nimport os\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom IPython.display import display\n%matplotlib inline\n\nimport pandas as pd\nimport numpy as np\n\nfrom PIL import Image\nfrom torchvision.datasets import ImageFolder\nfrom resizeimage import resizeimage\n\nfrom skimage.feature import hog\nfrom skimage.color import rgb2grey\n\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.svm import SVC\n\nfrom sklearn.metrics import roc_curve, auc, accuracy_score\n","63b6f471":"# importing images using torchvision\ndataset = ImageFolder(\"..\/input\/cat-and-dog\/training_set\/training_set\/\")\n\n# creating labels dataframe\nimgs, labels = zip(*dataset.imgs)\nimgs = list(imgs)\nlabels = list(labels)\nlabels_df = pd.DataFrame({'image': imgs, 'label':labels})\nlabels_df","c9943d12":"def get_image(path):\n    img = Image.open(path)\n    return np.array(img)\n\n# showing a dog image\ndog_row = labels_df[labels_df.label == 1].reset_index().image[23]\nplt.imshow(get_image(dog_row))\nplt.show()\n\n# showing a cat image\ncat_row = labels_df[labels_df.label == 0].reset_index().image[79]\nplt.imshow(get_image(cat_row))\nplt.show()","2f408afd":"# image manupulation\nimg = Image.open(cat_row)\nimg = resizeimage.resize_cover(img, [56, 56])\nplt.imshow(np.array(img), cmap='gray')\nplt.show()","b71025b8":"hog_features, hog_img = hog(img, visualize=True, block_norm='L2-Hys', pixels_per_cell=(8,8))\nplt.imshow(np.array(hog_img), cmap='gray')\nplt.show()","59fcbd64":"def create_features(path):\n    img = Image.open(path)\n    img = resizeimage.resize_cover(img, [56, 56])\n    img_arr = np.array(img)\n    # flatten three channel color image\n    color_features = img_arr.flatten()\n    # convert image to greyscale\n    grey_image = rgb2grey(img_arr)\n    # get HOG features from greyscale image\n    hog_features = hog(grey_image, block_norm='L2-Hys', pixels_per_cell=(8, 8))\n    # combine color and hog features into a single array\n    flat_features = np.hstack((color_features, hog_features))\n    return flat_features\n\ndog_features = create_features(dog_row)\nprint(dog_features.shape)","9830041c":"def create_feature_matrix(label_df):\n    features_list = []\n    \n    for img_path in labels_df.image:\n        # get features for image\n        img_features = create_features(img_path)\n        features_list.append(img_features)\n    \n    feature_matrix = np.array(features_list)\n    return feature_matrix\n\nfeature_matrix = create_feature_matrix(labels_df)","5f9ff7ab":"# get shape of feature matrix\nprint('Feature matrix shape is: ', feature_matrix.shape)\n\n# define standard scaler\nss = StandardScaler()\n# run this on our feature matrix\nimgs_stand = ss.fit_transform(feature_matrix)","8c998698":"X_train, X_test, y_train, y_test = train_test_split(imgs_stand,\n                                                    labels_df.label.values,\n                                                    test_size=.3,\n                                                    random_state=1234123)\n\n# look at the distrubution of labels in the train set\npd.Series(y_train).value_counts()","00f94887":"# define support vector classifier\nsvm = SVC(kernel='linear',probability=True, random_state=42)\n\n# fit model\nsvm.fit(X_train, y_train)","6ec84c8f":"# generate predictions\ny_pred = svm.predict(X_test)\n\n# calculate accuracy\naccuracy = accuracy_score(y_pred, y_test)\nprint('Model accuracy is: ', accuracy)","f13e6ae2":"# predict probabilities for X_test using predict_proba\nprobabilities = svm.predict_proba(X_test)\n\n# select the probabilities for label 1.0\ny_proba = probabilities[:, 1]\n\n# calculate false positive rate and true positive rate at different thresholds\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_proba, pos_label=1)\n\n# calculate AUC\nroc_auc = auc(false_positive_rate, true_positive_rate)\n\nplt.title('Receiver Operating Characteristic')\n# plot the false positive rate on the x axis and the true positive rate on the y axis\nroc_plot = plt.plot(false_positive_rate,\n                    true_positive_rate,\n                    label='AUC = {:0.2f}'.format(roc_auc))\n\nplt.legend(loc=0)\nplt.plot([0,1], [0,1], ls='--')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate');","b2e6792a":"from random import randint\n\ntest = ImageFolder(\"..\/input\/cat-and-dog\/test_set\/test_set\/\")\nimgs, labels = zip(*test.imgs)\nimgs = list(imgs)\nlabels = list(labels)","2db2635e":"random_ix = randint(0, len(imgs))\nlabel = {0: 'Cat', 1:'Dog'}\nrand_img = imgs[random_ix]\n# create features of the image\ntest_features = create_features(rand_img)\n# predict\nprediction = svm.predict([test_features])\nprint(\"Prediction: \" + label[prediction[0]])\nprint(\"Actual: \" + label[labels[random_ix]])\n# display image\ndisplay(Image.open(rand_img))","ee6c21ee":"## Train model\nNow let's finally build our model! We'll do this using an SVM classifier with a linear kernel.","8127125e":"## Visualizing Predictions\nLet's take random images from the test set and predict and display them individually. Here's we'll realize how bad this model is TwT","d909abbc":"Okay, the images vary widely in terms of resolution and aspect ratio. Since the subject is in the middle for *most* images we can just resize to our desired resolution and crop from the middle.\n\nAlso the color channels may help in classifying, so let's just keep it.","33d4ef9c":"### Exploring images of dataset\nLet's see what kind of images does the dataset provide and see what kind of preprocessing needs to be done. ","fd3f6abb":"## Split into train and test sets\nNow we need to convert our data into train and test sets. We'll use 70% of images as our training data and test our model on the remaining 30%.","a3582696":"## Create image features and flatten into a single row\nAlgorithms require data to be in a format where rows correspond to images and columns correspond to features. This means that all the information for a given image needs to be contained in a single row.\n\nWe want to provide our model with the raw pixel values from our images as well as the HOG features we just calculated. Let's do it!","8d710f25":"## Scale feature matrix\nOur features aren't quite done yet. Many machine learning methods are built to work best with data that has a mean of 0 and unit variance. So let's scale the features using the StandardScaler provided by scikit-learn","2912d29c":"## Histogram of oriented gradients\nWe've got a matrix of pixel values, but those don't contain enough interesting information on their own for most algorithms. We need to help the algorithms along by picking out some of the salient features for them using the **histogram of oriented gradients** (s shape within an image can be inferred by its edges, and a way to identify edges is by looking at the direction of intensity gradients (i.e. changes in luminescence).\n![HOG](https:\/\/scikit-image.org\/docs\/dev\/_images\/sphx_glr_plot_hog_001.png)","5aac83ae":"63%.. Not bad for a simple SVC model using such complicated data.. Probably better to use Deep Learning though UwU","803f74a8":"## ROC curve + AUC\nNow, we'll use svm.predict_proba to get the probability that each class is the true label. For example, predict_proba returns [0.46, 0.53] for the first image, meaning there is a 46% chance the image is a Cat (0.0) and a 53% chance the  image is a Dog (1.0). \n\nUsing the default settings, probabilities of 0.5 or above are assigned a class label of 1.0 and those below are assigned a 0.0. However, this threshold can be adjusted. The (ROC curve) plots the false positive rate and true positive rate at different thresholds. ROC curves are judged visually by how close they are to the upper lefthand corner.\n\nThe AUC is also calculated, where 1 means every predicted label was correct. Generally, the worst score for AUC is 0.5, which is the performance of a model that randomly guesses. Let's see how well ours do!","b883c71a":"## Loop over images to preprocess\nAbove we generated a flattened features array for a dog image. Now it's time to loop over all of our images. We will create features for each image and then stack the flattened features arrays into a big matrix we can pass into our model.\nIn the resulting features matrix, rows correspond to images and columns to features.","00262a65":"# Cat and Dog Classification using SVC\n<p><img src=\"https:\/\/wtamu.edu\/~cbaird\/sq\/images\/dog2.jpg\" alt=\"Dog\">\n<em>A Dog.<\/em><\/p>\n<p><img src=\"https:\/\/images.everydayhealth.com\/images\/lung-respiratory\/allergies\/hcallergieslivingwithcatarticle.jpg?sfvrsn=898fd1e5_0\" alt=\"Cat\">\n<em>A Cat.<\/em><\/p>\n\nAfter loading and pre-processing images, this notebook walks through building a model that can automatically detect dogs and cats using a simple SVM Classifier","3bc7fb68":"## Score model\nNow let's use our trained model to generate predictions for our data and see how it does. "}}