{"cell_type":{"98269a09":"code","a1cbbdb6":"code","4da1760a":"code","7e527487":"code","8293c03d":"code","752b316e":"code","069351e5":"code","53a2e972":"code","1e1fb3e2":"code","bff8e4a9":"code","43360e45":"code","c601b1cb":"code","8ee623fd":"code","0e1f84df":"code","e87c5894":"code","dc123375":"code","d855b832":"code","8f34a62b":"code","cdf8a4d1":"code","4d1fddb3":"code","97258106":"code","916d9f08":"code","7799a30a":"code","c46bd93b":"code","8851e84e":"code","0ce529fb":"code","215ce823":"code","8b693fc1":"code","ca8d0726":"code","ae9dadb0":"code","38473306":"code","1ea5ccdc":"code","a8e89f8e":"code","d23d1297":"code","3a62711c":"code","675f0364":"code","6a61792e":"code","ecc4f662":"code","2beb17ed":"code","a6c01cd1":"code","614546cf":"code","31955e4a":"code","360389da":"code","c6f8860b":"code","f3ceb21f":"code","3d218611":"code","9c92a882":"code","5452220f":"code","7d00fc43":"code","7a06c041":"code","7ea2f77b":"code","e085adf7":"code","762cc23b":"code","97c78af7":"code","259dedf1":"code","af409881":"code","b5d8a30f":"code","2c3151a2":"code","4143cd6e":"code","446efbb2":"code","de126bb0":"code","e929e649":"markdown","7218a759":"markdown","7ba795d7":"markdown","791b5fea":"markdown","cdd35c0e":"markdown","ef560080":"markdown","bcfee796":"markdown","8acf9249":"markdown","de22fc94":"markdown","5400b6f7":"markdown","a6acd102":"markdown","fd46c36d":"markdown","7224ed75":"markdown","88049e06":"markdown","49619f84":"markdown","65585b17":"markdown","0c7469d1":"markdown","37d0443c":"markdown","9f14374c":"markdown","d2b97ebd":"markdown","a2a351ab":"markdown","f5732366":"markdown","4987c8ba":"markdown","8e9a2b93":"markdown","9995956d":"markdown","4b38d7b8":"markdown","e59c29de":"markdown","b9ec8020":"markdown","13fba5d1":"markdown","e3252aaa":"markdown","33ceaeda":"markdown","31235126":"markdown","85e494c8":"markdown","09e5c258":"markdown","5236499e":"markdown","b138b72f":"markdown","30469d7d":"markdown","cfd1ae08":"markdown","73d0e46e":"markdown","3922cb01":"markdown","c5f6af3f":"markdown"},"source":{"98269a09":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","a1cbbdb6":"import pandas as pd\nimport numpy as np\n\nreviews = pd.read_csv(\"..\/input\/wine-reviews\/winemag-data-130k-v2.csv\", index_col=0)\npd.set_option(\"display.max_rows\", 5)","4da1760a":"pd.DataFrame({'Yes': [50, 21], 'No': [131, 2]})","7e527487":"pd.DataFrame({'Bob': ['I liked it.', 'It was awful.'], 'Sue': ['Pretty good.', 'Bland.']})","8293c03d":"pd.DataFrame({'Bob': ['I liked it.', 'It was awful.'], \n              'Sue': ['Pretty good.', 'Bland.']},\n             index=['Product A', 'Product B'])","752b316e":"pd.Series([1, 2, 3, 4, 5])","069351e5":"pd.Series([30, 35, 40], index=['2015 Sales', '2016 Sales', '2017 Sales'], name='Product A')","53a2e972":"wine_reviews = pd.read_csv(\"..\/input\/wine-reviews\/winemag-data-130k-v2.csv\")","1e1fb3e2":"wine_reviews.shape","bff8e4a9":"wine_reviews.head()","43360e45":"wine_reviews = pd.read_csv(\"..\/input\/wine-reviews\/winemag-data-130k-v2.csv\", index_col=0)\nwine_reviews.head()","c601b1cb":"reviews","8ee623fd":"reviews.country\n#reviews['country']","0e1f84df":"reviews['country'][0]","e87c5894":"# To select the first row of data in a DataFrame, we may use the following:\nreviews.iloc[0]","dc123375":"# To get a column with iloc, we can do the following:\nreviews.iloc[:, 0]","d855b832":"# It's also possible to pass a list:\nreviews.iloc[[0, 1, 2], 0]","8f34a62b":"# For example, to get the first entry in reviews, we would now do the following:\nreviews.loc[0, 'country']","cdf8a4d1":"reviews.loc[:, ['taster_name', 'taster_twitter_handle', 'points']]","4d1fddb3":"reviews.set_index(\"title\")","97258106":"reviews.country == 'Italy'","916d9f08":"reviews.loc[reviews.country == 'Italy']","7799a30a":"reviews.loc[(reviews.country == 'Italy') & (reviews.points >= 90)]\n#reviews.loc[(reviews.country == 'Italy') | (reviews.points >= 90)]","c46bd93b":"reviews.loc[reviews.country.isin(['Italy', 'France'])]","8851e84e":"reviews.loc[reviews.price.notnull()]","0ce529fb":"reviews['critic'] = 'everyone'\nreviews['critic']","215ce823":"reviews['index_backwards'] = range(len(reviews), 0, -1)\nreviews['index_backwards']","8b693fc1":"reviews.info()","ca8d0726":"reviews.points.describe()","ae9dadb0":"reviews.taster_name.describe()","38473306":"reviews.points.mean()","1ea5ccdc":"reviews.taster_name.unique()","a8e89f8e":"reviews.taster_name.value_counts()","d23d1297":"review_points_mean = reviews.points.mean()\nreviews.points.map(lambda p: p - review_points_mean)","3a62711c":"def remean_points(row):\n    row.points = row.points - review_points_mean\n    return row\n\nreviews.apply(remean_points, axis='columns')","675f0364":"review_points_mean = reviews.points.mean()\nreviews.points - review_points_mean","6a61792e":"reviews.country + \" - \" + reviews.region_1","ecc4f662":"reviews.groupby('points').points.count()","2beb17ed":"# size() also counts NaN.\nreviews.groupby('points').size()","a6c01cd1":"reviews.groupby('points').price.min()","614546cf":"reviews.groupby('winery').apply(lambda df: df.title.iloc[0])","31955e4a":"reviews.groupby(['country', 'province']).apply(lambda df: df.loc[df.points.idxmax()])","360389da":"reviews.groupby(['country']).price.agg([len, min, max])","c6f8860b":"countries_reviewed = reviews.groupby(['country', 'province']).description.agg([len])\ncountries_reviewed","f3ceb21f":"mi = countries_reviewed.index\ntype(mi)","3d218611":"countries_reviewed.reset_index()","9c92a882":"countries_reviewed = countries_reviewed.reset_index()\ncountries_reviewed.sort_values(by='len')\n#countries_reviewed.sort_values(by='len', ascending=False)","5452220f":"countries_reviewed.sort_index()","7d00fc43":"countries_reviewed.sort_values(by=['country', 'len'])","7a06c041":"reviews.price.dtype","7ea2f77b":"reviews.dtypes","e085adf7":"reviews.points.astype('float64')","762cc23b":"reviews.index.dtype","97c78af7":"reviews[pd.isnull(reviews.country)]\n#reviews[reviews.country.isnull()]","259dedf1":"reviews.region_2.fillna(\"Unknown\")\n#reviews.region_2.fillna(method='ffill')\n#reviews.region_2.fillna(method='bfill')","af409881":"reviews.taster_twitter_handle.replace(\"@kerinokeefe\", \"@kerino\")","b5d8a30f":"reviews.rename(columns={'points': 'score'})","2c3151a2":"reviews.rename(index={0: 'firstEntry', 1: 'secondEntry'})","4143cd6e":"reviews.rename_axis(\"wines\", axis='rows').rename_axis(\"fields\", axis='columns')","446efbb2":"canadian_youtube = pd.read_csv(\"..\/input\/youtube-new\/CAvideos.csv\")\nbritish_youtube = pd.read_csv(\"..\/input\/youtube-new\/GBvideos.csv\")\n\npd.concat([canadian_youtube, british_youtube])","de126bb0":"left = canadian_youtube.set_index(['title', 'trending_date'])\nright = british_youtube.set_index(['title', 'trending_date'])\n\nleft.join(right, lsuffix='_CAN', rsuffix='_UK')","e929e649":"* Another `groupby()` method worth mentioning is `agg()`, which lets you run a bunch of different functions on your DataFrame simultaneously. For example, we can generate a simple statistical summary of the dataset as follows:","7218a759":"* Both `loc` and `iloc` are row-first, column-second. This is the opposite of what we do in native Python, which is column-first, row-second.","7ba795d7":"# Renaming and Combining","791b5fea":"* You can think of each group we generate as being a slice of our DataFrame containing only data with values that match. This DataFrame is accessible to us directly using the `apply()` method, and we can then manipulate the data in any way we see fit. For example, here's one way of selecting the name of the first wine reviewed from each winery in the dataset:","cdd35c0e":"* To get data in the order want it in we can sort it ourselves. The sort_values() method is handy for this.","ef560080":"* `iloc` is conceptually simpler than `loc` because it ignores the dataset's indices. When we use `iloc` we treat the dataset like a big matrix (a list of lists), one that we have to index into by position. `loc`, by contrast, uses the information in the indices to do its work. Since your dataset usually has meaningful indices, it's usually easier to do things using `loc` instead. For example, here's one operation that's much easier using `loc`:","bcfee796":"* The `pd.read_csv()` function is well-endowed, with over 30 optional parameters you can specify. For example, you can see in this dataset that the CSV file has a built-in index, which pandas did not pick up on automatically. To make pandas use that column for the index (instead of creating a new one from scratch), we can specify an `index_col`.","8acf9249":"**Choosing between `loc` and `iloc`**\n\nWhen choosing or transitioning between `loc` and `iloc`, there is one \"gotcha\" worth keeping in mind, which is that the two methods use slightly different indexing schemes.\n\n`iloc` uses the Python stdlib indexing scheme, where the first element of the range is included and the last one excluded. So `0:10` will select entries `0,...,9`. `loc`, meanwhile, indexes inclusively. So `0:10` will select entries `0,...,10`.\n\nWhy the change? Remember that `loc` can index any stdlib type: strings, for example. If we have a DataFrame with index values `Apples, ..., Potatoes, ...`, and we want to select \"all the alphabetical fruit choices between Apples and Potatoes\", then it's a lot more convenient to index `df.loc['Apples':'Potatoes']` than it is to index something like `df.loc['Apples', 'Potatoet]` (`t` coming after `s` in the alphabet).\n\nThis is particularly confusing when the DataFrame index is a simple numerical list, e.g. `0,...,1000`. In this case `df.iloc[0:1000]` will return 1000 entries, while `df.loc[0:1000]` return 1001 of them! To get 1000 elements using `loc`, you will need to go one lower and ask for `df.loc[0:999]`.\n\nOtherwise, the semantics of using `loc` are the same as those for `iloc`.","de22fc94":"* The second is `isnull` (and its companion `notnull`). These methods let you highlight values which are (or are not) empty (`NaN`). For example, to filter out wines lacking a price tag in the dataset, here's what we would do:","5400b6f7":"* Multi-indices have several methods for dealing with their tiered structure which are absent for single-level indices. They also require two levels of labels to retrieve a value. Dealing with multi-index output is a common \"gotcha\" for users new to pandas.\n\n\n* The use cases for a multi-index are detailed alongside instructions on using them in the [MultiIndex \/ Advanced Selection](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/advanced.html) section of the pandas documentation.\n\n\n* However, in general the multi-index method you will use most often is the one for converting back to a regular index, the `reset_index()` method:","a6acd102":"* The simplest combining method is `concat()`. Given a list of elements, this function will smush those elements together along an axis, given that those DataFrame or Series objects have the same fields (columns).","fd46c36d":"* One peculiarity to keep in mind (and on display very clearly here) is that columns consisting entirely of strings do not get their own type; they are instead given the `object` type","7224ed75":"* When performing operations on a dataset, we will sometimes need to combine different DataFrames and\/or Series in non-trivial ways. Pandas has three core methods for doing this. In order of increasing complexity, these are `concat()`, `join()`, and `merge()`. Most of what `merge()` can do can also be done more simply with `join()`, so we will omit it and focus on the first two functions here.","88049e06":"* For even more fine-grained control, you can also group by more than one column. For an example, here's how we would pick out the best wine by country and province:","49619f84":"* The middlemost combiner in terms of complexity is `join()`. `join()` lets you combine different DataFrame objects which have an index in common.","65585b17":"* A multi-index differs from a regular index in that it has multiple levels. For example:","0c7469d1":"* A DataFrame or Series index has its own `dtype`, too:","37d0443c":"* Label-based selection derives its power from the labels in the index. Critically, the index we use is not immutable. We can manipulate the index in any way we see fit. This is useful if you can come up with an index for the dataset which is better than the current one.","9f14374c":"Going the other way, assigning data to a DataFrame is easy. \n\n* You can assign either a constant value:","d2b97ebd":"Pandas comes with a few built-in conditional selectors, two of which we will highlight here.\n\n* The first is `isin`. `isin` is lets you select data whose value \"is in\" a list of values. For example, here's how we can use it to select wines only from Italy or France:","a2a351ab":"# Summary Functions and Maps","f5732366":"* The first function we'll introduce here is `rename()`, which lets you change index names and\/or column names. For example, to change the `points` column in our dataset to `score`, we would do:","4987c8ba":"# Indexing, Selecting & Assigning","8e9a2b93":"* This operation produced a Series of `True\/False` booleans based on the `country` of each record. This result can then be used inside of `loc` to select the relevant data:","9995956d":"# Data Types and Missing Values","4b38d7b8":"* Entries missing values are given the value `NaN`, short for \"Not a Number\". For technical reasons these `NaN` values are always of the `float64` dtype.\n\n\n* Pandas provides some methods specific to missing data. To select NaN entries you can use `pd.isnull()` (or its companion `pd.notnull()`). This is meant to be used thusly:","e59c29de":"# Creating, Reading and Writing","b9ec8020":"* We can use any of the summary functions we've used before with this data. For example, to get the cheapest wine in each point value category, we can do the following:","13fba5d1":"* `rename()` lets you rename index or column values by specifying a `index` or `column` keyword parameter, respectively. It supports a variety of input formats, but usually a Python dictionary is the most convenient.\n\n\n* You'll probably rename columns very often, but rename index values very rarely. For that, `set_index()` is usually more convenient.","e3252aaa":"* Both the row index and the column index can have their own `name` attribute. The complimentary `rename_axis()` method may be used to change these names. For example:","33ceaeda":"* To sort by index values, use the companion method sort_index(). This method has the same arguments and default order:","31235126":"* Alternatively, we may have a non-null value that we would like to replace by using the `replace()` method:","85e494c8":"* We can check if each wine is Italian or not:","09e5c258":"* Finally, know that you can sort by more than one column at a time:","5236499e":"# Grouping and Sorting","b138b72f":"* Or with an iterable of values:","30469d7d":"* One function we've been using heavily thus far is the `value_counts()` function. We can replicate what `value_counts()` does by doing the following:","cfd1ae08":"* Pandas provides many common mapping operations as built-ins. For example, here's a faster way of remeaning our points column:","73d0e46e":"* Replacing missing values is a common operation. Pandas provides a really handy method for this problem: `fillna()`.","3922cb01":"* We can use the ampersand (`&`) or the pipe (`|`) to bring the two questions together:","c5f6af3f":"* The `lsuffix` and `rsuffix` parameters are necessary here because the data has the same column names in both British and Canadian datasets. If this wasn't true (because, say, we'd renamed them beforehand) we wouldn't need them."}}