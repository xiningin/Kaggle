{"cell_type":{"7e6d6aeb":"code","060788b7":"code","c6d143b1":"code","e524ec6c":"code","2617d5a0":"code","7a133022":"code","ed18609b":"code","804b3c16":"code","9ed6ecb5":"code","3d0dc553":"code","2fd9002e":"code","91dbd4f7":"code","5211fae0":"code","2c3ca3ea":"code","4f267d54":"code","e136c7cb":"code","101458ad":"code","569e7a6e":"code","658ef6af":"code","184cdf65":"code","52313722":"code","7d294291":"code","bd1276e9":"code","41fba784":"code","6b2431f4":"code","a58ef7c5":"code","8fa9f90b":"code","a4292d16":"code","7ea3d50b":"code","fa66f305":"code","32071b38":"code","aae5cdc2":"code","d1710e00":"code","c7dd301c":"code","de465592":"code","31655a21":"code","fb7a14dd":"code","dcb0fb8f":"code","ac9dcae5":"code","377b7cf0":"code","940fcf16":"code","88b56671":"code","85b8872e":"code","09eae828":"code","876f5109":"code","eb110ce0":"code","8384b6c7":"code","d8a48f1b":"code","8e1f32fd":"code","f260070c":"code","0f9b52d0":"code","c8503790":"code","c06d8849":"code","5f13e619":"code","acd3c0eb":"code","1a11bf63":"markdown","c9814661":"markdown","e73307e6":"markdown","c0a4edf2":"markdown","60548ea3":"markdown","cf23591a":"markdown","eb9f48c6":"markdown"},"source":{"7e6d6aeb":"#GENERAL\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport random\n#PATH PROCESS\nimport os\nimport os.path\nfrom pathlib import Path\nimport glob\n#IMAGE PROCESS\nfrom PIL import Image\nfrom keras.preprocessing import image\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nimport cv2\nfrom keras.applications.vgg16 import preprocess_input, decode_predictions\nimport imageio\nfrom IPython.display import Image\n#SCALER & TRANSFORMATION\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import MinMaxScaler\nfrom keras.utils.np_utils import to_categorical\nfrom sklearn.model_selection import train_test_split\nfrom keras import regularizers\nfrom sklearn.preprocessing import LabelEncoder\n#ACCURACY CONTROL\nfrom sklearn.metrics import confusion_matrix, accuracy_score, classification_report, roc_auc_score, roc_curve\nfrom sklearn.model_selection import GridSearchCV, cross_val_score\nfrom sklearn.metrics import mean_squared_error, r2_score\n#OPTIMIZER\nfrom keras.optimizers import RMSprop,Adam,Optimizer,Optimizer, SGD\n#MODEL LAYERS\nfrom tensorflow.keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, BatchNormalization,MaxPooling2D,BatchNormalization,\\\n                        Permute, TimeDistributed, Bidirectional,GRU, SimpleRNN,\\\nLSTM, GlobalAveragePooling2D, SeparableConv2D, ZeroPadding2D, Convolution2D, ZeroPadding2D,Reshape, Conv2DTranspose, LeakyReLU\nfrom keras import models\nfrom keras import layers\nimport tensorflow as tf\nfrom keras.applications import VGG16,VGG19,inception_v3\nfrom keras import backend as K\nfrom keras.utils import plot_model\nfrom keras.datasets import mnist\nimport keras\n#SKLEARN CLASSIFIER\nfrom xgboost import XGBClassifier, XGBRegressor\nfrom lightgbm import LGBMClassifier, LGBMRegressor\nfrom catboost import CatBoostClassifier, CatBoostRegressor\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.ensemble import GradientBoostingClassifier, GradientBoostingRegressor\nfrom sklearn.ensemble import BaggingRegressor\nfrom sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor\nfrom sklearn.neural_network import MLPClassifier, MLPRegressor\nfrom sklearn.neighbors import KNeighborsClassifier, KNeighborsRegressor\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.cross_decomposition import PLSRegression\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import RidgeCV\nfrom sklearn.linear_model import Lasso\nfrom sklearn.linear_model import LassoCV\nfrom sklearn.linear_model import ElasticNet\nfrom sklearn.linear_model import ElasticNetCV\n#IGNORING WARNINGS\nfrom warnings import filterwarnings\nfilterwarnings(\"ignore\",category=DeprecationWarning)\nfilterwarnings(\"ignore\", category=FutureWarning) \nfilterwarnings(\"ignore\", category=UserWarning)","060788b7":"Main_Train_Path = Path(\"..\/input\/impressionist-classifier-data\/training\/training\")","c6d143b1":"Train_JPG_Path = list(Main_Train_Path.glob(r\"*\/*.jpg\"))","e524ec6c":"Train_JPG_Labels = list(map(lambda x: os.path.split(os.path.split(x)[0])[1],Train_JPG_Path))","2617d5a0":"Train_JPG_Path_Series = pd.Series(Train_JPG_Path,name=\"JPG\").astype(str)\nTrain_JPG_Labels_Series = pd.Series(Train_JPG_Labels,name=\"CATEGORY\")","7a133022":"Main_Train_Data = pd.concat([Train_JPG_Path_Series,Train_JPG_Labels_Series],axis=1)","ed18609b":"print(Main_Train_Data.head(-1))","804b3c16":"print(Main_Train_Data[\"CATEGORY\"].value_counts())","9ed6ecb5":"VanGogh_IMG_Data = Main_Train_Data[Main_Train_Data[\"CATEGORY\"] == \"VanGogh\"]","3d0dc553":"print(VanGogh_IMG_Data.head(-1))","2fd9002e":"VanGogh_IMG_Data = VanGogh_IMG_Data.reset_index()","91dbd4f7":"print(VanGogh_IMG_Data.head(-1))","5211fae0":"plt.style.use(\"classic\")","2c3ca3ea":"example_IMG = VanGogh_IMG_Data[\"JPG\"][20]\nR_IMG = cv2.imread(example_IMG)\nplt.xlabel(R_IMG.shape)\nplt.ylabel(R_IMG.size)\nplt.imshow(R_IMG)","4f267d54":"example_IMG = VanGogh_IMG_Data[\"JPG\"][200]\nR_IMG = cv2.imread(example_IMG)\nplt.xlabel(R_IMG.shape)\nplt.ylabel(R_IMG.size)\nplt.imshow(R_IMG)","e136c7cb":"figure,axis = plt.subplots(ncols=5,nrows=5,figsize=(12,12))\n\nfor i,ax in enumerate(axis.flat):\n    IMG = cv2.imread(VanGogh_IMG_Data[\"JPG\"][i])\n    ax.set_xlabel(IMG.shape)\n    ax.set_ylabel(IMG.size)\n    ax.imshow(IMG)\nplt.tight_layout()\nplt.show()","101458ad":"Transformed_X = []\n\nfor IMG_X in VanGogh_IMG_Data[\"JPG\"]:\n    X_IMG = cv2.imread(IMG_X)\n    X_IMG = cv2.resize(X_IMG,(48,48))\n    X_IMG = X_IMG \/ 255.\n    Transformed_X.append(X_IMG)","569e7a6e":"print(Transformed_X[2].shape)","658ef6af":"plt.imshow(Transformed_X[2])","184cdf65":"Train_IMG_Set = np.asarray(Transformed_X)","52313722":"Train_IMG_Set = Train_IMG_Set.reshape(-1,48,48,3)","7d294291":"print(Train_IMG_Set.shape)","bd1276e9":"Generator_Input = keras.Input(shape=(48,))\nx = layers.Dense(128*24*24)(Generator_Input)\nx = layers.LeakyReLU()(x)\nx = layers.Reshape((24,24,128))(x)\n\nx = layers.Conv2D(256,4,padding=\"same\")(x)\nx = layers.LeakyReLU()(x)\n\nx = layers.Conv2DTranspose(256,4,padding=\"same\",strides=2)(x)\nx = layers.LeakyReLU()(x)\n\nx = layers.Conv2D(256,4,padding=\"same\")(x)\nx = layers.LeakyReLU()(x)\nx = layers.Conv2D(256,3,padding=\"same\")(x)\nx = layers.LeakyReLU()(x)\nx = layers.Conv2D(256,3,padding=\"same\")(x)\nx = layers.LeakyReLU()(x)\n\nx = layers.Conv2D(3,7,padding=\"same\",activation=\"tanh\")(x)\n\nGenerator = keras.models.Model(Generator_Input,x)","41fba784":"print(Generator.summary())","6b2431f4":"T_Noise = tf.random.normal(shape=[1,48])\nG_T_Img = Generator(T_Noise,training=False)","a58ef7c5":"G_T_Img_S = np.squeeze(G_T_Img,axis=0)","8fa9f90b":"plt.imshow(G_T_Img_S,cmap=\"binary\")","a4292d16":"print(T_Noise)","7ea3d50b":"plt.imshow(T_Noise,cmap=\"binary\")","fa66f305":"Discriminator_Input = layers.Input(shape=(48,48,3)) #32,32\nx = layers.Conv2D(128,3)(Discriminator_Input)\nx = layers.LeakyReLU()(x)\n\nx = layers.Conv2D(128,4,strides=2)(x)\nx = layers.LeakyReLU()(x)\nx = layers.Conv2D(128,4,strides=2)(x)\nx = layers.LeakyReLU()(x)\nx = layers.Conv2D(128,3,strides=2)(x)\nx = layers.LeakyReLU()(x)\n\nx = layers.Flatten()(x)\nx = layers.Dense(1,activation=\"sigmoid\")(x)\n\nDiscriminator = keras.models.Model(Discriminator_Input,x)","32071b38":"print(Discriminator.summary())","aae5cdc2":"Decision_IMG = Discriminator(G_T_Img)","d1710e00":"print(Decision_IMG)","c7dd301c":"Discriminator.compile(optimizer=RMSprop(lr=0.0004,clipvalue=1.0,decay=1e-8),loss=\"binary_crossentropy\")","de465592":"Discriminator.trainable = False","31655a21":"GAN_Input = keras.Input(shape=(48,))\nGAN_Output = Discriminator(Generator(GAN_Input))","fb7a14dd":"GAN_Model = keras.models.Model(GAN_Input,GAN_Output)","dcb0fb8f":"GAN_Model.compile(optimizer=RMSprop(lr=0.0002,clipvalue=1.0,decay=1e-8),loss=\"binary_crossentropy\")","ac9dcae5":"print(GAN_Model.summary())","377b7cf0":"os.mkdir(\"painting_1_new\")","940fcf16":"start = 0 \nbatch_size = 32\niterations = 10000\ndim_size = 48","88b56671":"for step in range(iterations):\n    random_noise = np.random.normal(size=(batch_size,dim_size))\n    generation_IMG = Generator.predict(random_noise)\n    \n    stop = start + batch_size\n    \n    real_IMG = Train_IMG_Set[start:stop]\n    combined_IMG = np.concatenate([generation_IMG,real_IMG])\n    \n    labels = np.concatenate([np.ones((batch_size,1)),np.zeros((batch_size,1))])\n    labels = labels + 0.05 * np.random.random(labels.shape)\n    \n    D_LS = Discriminator.train_on_batch(combined_IMG,labels)\n    \n    random_noise = np.random.normal(size=(batch_size,dim_size))\n    \n    misleading_target = np.zeros((batch_size,1))\n    \n    A_LS = GAN_Model.train_on_batch(random_noise,misleading_target)\n    \n    start = start + batch_size\n    \n    if start > len(Train_IMG_Set) - batch_size:\n        start = 0\n        \n    if step % 10 == 0:\n        GAN_Model.save_weights(\"GAN_MODEL.h5\")\n        \n        print(\"DISC_LOSS --> \",D_LS)\n        print(\"ADVERSARIAL_LOSS --> \",A_LS)\n        \n        Img_X_X = image.array_to_img(generation_IMG[0] * 255., scale=False)\n        Img_X_X.save(os.path.join(\".\/painting_1_new\",\"FAKE\" + str(step)+\".png\"))\n        \n        Img_X_X = image.array_to_img(real_IMG[0] * 255.,scale=False)\n        Img_X_X.save(os.path.join(\".\/painting_1_new\",\"REAL\"+str(step)+\".png\"))","85b8872e":"Export_Out = Path(\".\/painting_1_new\")\nList_Output = list(Export_Out.glob(r\"*.png\"))\nList_Output_Series = pd.Series(List_Output,name=\"PNG\").astype(str)","09eae828":"Predict_Noise = tf.random.normal(shape=[30,dim_size])","876f5109":"plt.imshow(Predict_Noise,cmap=\"binary\")","eb110ce0":"Gen_Predict_N = Generator(Predict_Noise)","8384b6c7":"figure, axes = plt.subplots(nrows=4,ncols=6,figsize=(10,10))\n\nfor i,ax in enumerate(axes.flat):\n    ax.imshow(Gen_Predict_N[i],cmap=\"binary\")\n    ax.set_xlabel(Gen_Predict_N[i].shape)\nplt.tight_layout()\nplt.show()","d8a48f1b":"figure = plt.figure(figsize=(7,7))\nplt.imshow(Gen_Predict_N[7],cmap=\"binary\")","8e1f32fd":"figure = plt.figure(figsize=(7,7))\nplt.imshow(Gen_Predict_N[1],cmap=\"binary\")","f260070c":"figure = plt.figure(figsize=(4,4))\nplt.imshow(Gen_Predict_N[6],cmap=\"binary\")","0f9b52d0":"figure = plt.figure(figsize=(4,4))\nplt.imshow(Gen_Predict_N[5],cmap=\"binary\")","c8503790":"figure = plt.figure(figsize=(10,10))\nplt.imshow(Gen_Predict_N[19],cmap=\"binary\")","c06d8849":"figure, axes = plt.subplots(nrows=4,ncols=4,figsize=(10,10))\n\nfor i,ax in enumerate(axes.flat):\n    List_Gen_Image = cv2.imread(List_Output_Series[i])\n    ax.imshow(List_Gen_Image,cmap=\"binary\")\n    ax.set_xlabel(List_Gen_Image.shape)\n    ax.set_ylabel(List_Gen_Image.size)\nplt.tight_layout()\nplt.show()","5f13e619":"anim_file = 'dcgan.gif'\n\nwith imageio.get_writer(anim_file, mode='I') as writer:\n  filenames = list(Export_Out.glob(r'*.png'))\n  filenames = sorted(filenames)\n  last = -1\n  for i,filename in enumerate(filenames):\n    frame = 2*(i)\n    if round(frame) > round(last):\n      last = frame\n    else:\n      continue\n    image = imageio.imread(filename)\n    writer.append_data(image)\n  image = imageio.imread(filename)\n  writer.append_data(image)","acd3c0eb":"Image(open(anim_file,\"rb\",).read())","1a11bf63":"# PATH & LABEL PROCESS","c9814661":"# DC-GAN","e73307e6":"# PACKAGES AND LIBRARIES","c0a4edf2":"# VISUALIZATION","60548ea3":"# HISTORY","cf23591a":"# DATA PROCESS","eb9f48c6":"This is the dataset for a multi-class Impressionist painter classification project.\n\n* The aim of this project is to build a multi-class classifier for 10 Impressionist painters, namely:\n* Camille Pisarro\n* Childe Hassam\n* Claude Monet\n* Edgar Degas\n* Henri Matisse\n* John Singer-Sargent\n* Paul Cezanne\n* Paul Gauguin\n* Pierre-Auguste Renoir\n* Vincent van Gogh"}}