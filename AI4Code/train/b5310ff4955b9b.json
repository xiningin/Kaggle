{"cell_type":{"309081bd":"code","89c0742e":"code","b8738002":"code","c5cd4685":"code","ec655764":"code","31096167":"code","fbd19213":"code","804b9585":"code","3f622251":"code","32ea1242":"code","4dbaf5c9":"code","608fec1f":"code","b5f1ba8c":"code","41d67acc":"code","c7232c5d":"code","c5fc3770":"code","7b05b1bd":"code","a325dbd8":"code","6641ee2a":"code","6057b0ba":"code","a1dad58c":"code","a02aae98":"code","4de8373a":"markdown","a8b74603":"markdown","c8d69aa8":"markdown","1574f92e":"markdown","5a1b3028":"markdown","5a8f0d4a":"markdown","c7e8d3f3":"markdown","768be187":"markdown","002ebfda":"markdown","ed6088a5":"markdown","1b71c86d":"markdown"},"source":{"309081bd":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport skimage, os\nfrom skimage.morphology import ball, disk, dilation, binary_erosion, remove_small_objects, erosion, closing, reconstruction, binary_closing\nfrom skimage.measure import label,regionprops, perimeter\nfrom skimage.morphology import binary_dilation, binary_opening\nfrom skimage.filters import roberts, sobel\nfrom skimage import measure, feature\nfrom skimage.segmentation import clear_border, mark_boundaries\nfrom skimage import data\nfrom scipy import ndimage as ndi\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\nimport scipy.misc\nfrom glob import glob\nfrom skimage.io import imread\nBASE_IMG_PATH=os.path.join('..','input')\nOUT_DIR= os.path.join('..','output\/kaggle\/working')","89c0742e":"# show some of the files\nall_images = glob(os.path.join(BASE_IMG_PATH,'2d_images','*.tif'))\n#print(all_images)\nall_masks =  glob(os.path.join(BASE_IMG_PATH,'2d_masks','*.tif'))\n#print(all_masks)\nprint(len(all_masks),' matching files found')","b8738002":"%matplotlib inline\ntest_image=imread(all_images[0])\ntest_mask=imread(all_masks[0])\nfig, (ax1,ax2) = plt.subplots(1,2)\nax1.imshow(test_image)\nax2.imshow(test_mask)","c5cd4685":"def get_segmented_lungs(raw_im, plot=False):\n    '''\n    Original function changes input image (ick!)\n    '''\n    im=raw_im.copy()\n    \n    '''\n    This funtion segments the lungs from the given 2D slice.\n    '''\n    if plot == True:\n        f, plots = plt.subplots(8, 1, figsize=(5, 40))\n    '''\n    Step 1: Convert into a binary image. \n    '''\n    binary = im < -400\n    if plot == True:\n        plots[0].axis('off')\n        plots[0].imshow(binary, cmap=plt.cm.bone) \n    '''\n    Step 2: Remove the blobs connected to the border of the image.\n    '''\n    cleared = clear_border(binary)\n    if plot == True:\n        plots[1].axis('off')\n        plots[1].imshow(cleared, cmap=plt.cm.bone) \n    '''\n    Step 3: Label the image.\n    '''\n    label_image = label(cleared)\n    if plot == True:\n        plots[2].axis('off')\n        plots[2].imshow(label_image, cmap=plt.cm.bone) \n    '''\n    Step 4: Keep the labels with 2 largest areas.\n    '''\n    areas = [r.area for r in regionprops(label_image)]\n    areas.sort()\n    if len(areas) > 2:\n        for region in regionprops(label_image):\n            if region.area < areas[-2]:\n                for coordinates in region.coords:                \n                       label_image[coordinates[0], coordinates[1]] = 0\n    binary = label_image > 0\n    if plot == True:\n        plots[3].axis('off')\n        plots[3].imshow(binary, cmap=plt.cm.bone) \n    '''\n    Step 5: Erosion operation with a disk of radius 2. This operation is \n    seperate the lung nodules attached to the blood vessels.\n    '''\n    selem = disk(2)\n    binary = binary_erosion(binary, selem)\n    if plot == True:\n        plots[4].axis('off')\n        plots[4].imshow(binary, cmap=plt.cm.bone) \n    '''\n    Step 6: Closure operation with a disk of radius 10. This operation is \n    to keep nodules attached to the lung wall.\n    '''\n    selem = disk(10)\n    binary = binary_closing(binary, selem)\n    if plot == True:\n        plots[5].axis('off')\n        plots[5].imshow(binary, cmap=plt.cm.bone) \n    '''\n    Step 7: Fill in the small holes inside the binary mask of lungs.\n    '''\n    edges = roberts(binary)\n    binary = ndi.binary_fill_holes(edges)\n    if plot == True:\n        plots[6].axis('off')\n        plots[6].imshow(binary, cmap=plt.cm.bone) \n    '''\n    Step 8: Superimpose the binary mask on the input image.\n    '''\n    get_high_vals = binary == 0\n    im[get_high_vals] = 0\n    if plot == True:\n        plots[7].axis('off')\n        plots[7].imshow(im, cmap=plt.cm.bone ) \n        \n    return binary","ec655764":"test_seg=get_segmented_lungs(test_image,True)","31096167":"%matplotlib inline\nfig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(2,2,figsize=(12,8))\nax1.imshow(test_image,cmap='bone')\nax1.set_title('CT Slice')\nax2.imshow(test_mask)\nax2.set_title('Ground Truth')\nax3.imshow(test_seg)\nax3.set_title('Simple Algorithm')\nax4.imshow((test_seg>0)^(test_mask>0),cmap='gist_earth')\nax4.set_title('Difference')","fbd19213":"from sklearn.metrics import roc_curve, auc, classification_report # roc curve tools\nprint(classification_report(y_pred=test_seg.ravel()>0,y_true=test_mask.ravel()>0))","804b9585":"def make_mb_image(i_img, i_gt, i_pred,ds_op=lambda x: x[::4,::4]):\n    n_img = (i_img-i_img.mean())\/(2*i_img.std())+0.5\n    c_img = plt.cm.bone(n_img)[:,:,:3]\n    c_img=mark_boundaries(ds_op(c_img),label_img=ds_op(i_pred), color = (1,0,0),mode='thick')\n    c_img=mark_boundaries(c_img,label_img=ds_op(i_gt),color=(0,1,0),mode='thick|')\n    return c_img\n\nplt.imshow(make_mb_image(test_image, test_mask, test_seg))","3f622251":"from sklearn.metrics import f1_score\npred_output=[]\nf1_scores=[]\nfor i_path, m_path in zip(all_images,all_masks):\n    n_img=imread(i_path)\n    n_mask=imread(m_path)\n    p_mask=get_segmented_lungs(n_img)\n    f1_scores+=[f1_score(y_pred=p_mask.ravel()>0,y_true=n_mask.ravel()>0)]\n    pred_output+=[make_mb_image(n_img, n_mask, p_mask)]","32ea1242":"fig, ((ax_score,ax_best),(ax_hist,ax_worst)) = plt.subplots(2,2,figsize=(12,8))\nax_score.plot(f1_scores)\nax_score.set_title('F1 Scores')\nax_hist.hist(f1_scores)\nax_hist.set_title('Score Distribution')\nax_best.imshow(pred_output[np.argmax(f1_scores)])\nax_best.set_title('Best Score %2.2f' % np.max(f1_scores))\nax_worst.imshow(pred_output[np.argmin(f1_scores)])\nax_worst.set_title('Worst Score %2.2f' % np.min(f1_scores))","4dbaf5c9":"from skimage.util import montage\nfrom skimage.io import imsave\nout_montage = []\nfor i in range(3):\n    out_montage += [montage(np.stack([i_img[:,:,i] for i_img in pred_output],0))]\nout_montage = np.stack(out_montage,-1)\nplt.imshow(out_montage)\nimsave('all_outputs.jpg',out_montage)","608fec1f":"import zipfile\nzip_folder = os.path.join(BASE_IMG_PATH,'3d_images.zip')\ndestination = '3D_Images'\n\n\nwith zipfile.ZipFile(zip_folder) as zf:\n    zf.extractall(\n        destination)","b5f1ba8c":"# show some of the files\n\nall_images=['3D_Images\/'+file for file in os.listdir('3D_Images\/')]\n\n\nall_masks =  all_images[4:]\nall_images= all_images[:4]\nprint(all_images)\nprint(all_masks)\n","41d67acc":"import nibabel as nib\nepi_img = nib.load(all_images[0])\nepi_mask = nib.load(all_masks[1])\nepi_img_data = epi_img.get_fdata()\nepi_mask_data = epi_mask.get_fdata()\nprint(epi_img_data.shape,epi_mask_data.shape)","c7232c5d":"import nilearn\nfrom nilearn.plotting import view_img, glass_brain, plot_anat, plot_epi","c5fc3770":"plot_anat(epi_img)","7b05b1bd":"view_img(epi_img)","a325dbd8":"plot_anat(epi_img, draw_cross=False, display_mode='z')","6641ee2a":"plt.imshow(epi_img_data[0])","6057b0ba":"f, plots = plt.subplots(10, 1, figsize=(5, 40))\nfor i in range(10):\n    \n    plots[i].axis('off')\n    plots[i].imshow(epi_img_data[i+50], cmap=plt.cm.gray ) ","a1dad58c":"from sklearn.metrics import f1_score\npred_output=[]\nf1_scores=[]\nfor i in range(117):\n    n_img=epi_img_data[i]\n    n_mask=epi_mask_data[i]\n    p_mask=get_segmented_lungs(n_img)\n    f1_scores+=[f1_score(y_pred=p_mask.ravel()>0,y_true=n_mask.ravel()>0)]\n    pred_output+=[make_mb_image(n_img, n_mask, p_mask)]","a02aae98":"fig, ((ax_score,ax_best),(ax_hist,ax_worst)) = plt.subplots(2,2,figsize=(12,8))\nax_score.plot(f1_scores)\nax_score.set_title('F1 Scores')\nax_hist.hist(f1_scores)\nax_hist.set_title('Score Distribution')\nax_best.imshow(pred_output[np.argmax(f1_scores)])\nax_best.set_title('Best Score %2.2f' % np.max(f1_scores))\nax_worst.imshow(pred_output[np.argmin(f1_scores)])\nax_worst.set_title('Worst Score %2.2f' % np.min(f1_scores))","4de8373a":"# **Segment all slices and claculate f1-scores**","a8b74603":"# **Visualize the images**","c8d69aa8":"# **Unzip the 3D file to our working directory**\n","1574f92e":"# **Load the images and the masks**","5a1b3028":"# **Show the best and worst prediction of slices**","5a8f0d4a":"# **Check the summary of the data**","c7e8d3f3":"** This algorithm for lung segmentation is from  https:\/\/www.kaggle.com\/arnavkj95\/data-science-bowl-2017\/candidate-generation-and-luna16-preprocessing)**\n\n# Text from Original Kernel\n# \nAfter reading the CT Scan, the first step in preprocessing is the segmentation of lung structures because it is obvious that the regions of interests lies inside the lungs. It is visible that the lungs are the darker regions in the CT Scans. The bright region inside the lungs are the blood vessels or air. A threshold of -400 HU is used at all places because it was found in experiments that it works just fine. We segment lung structures from each slice of the CT Scan image and try not to loose the possible region of interests attached to the lung wall. There are some nodules which may be attached to the lung wall.\nI will first explain a common method using simple Image Processing and Morphological operations to segment the lungs and then will give references and summaries to good links of papers.","768be187":"# Show Segmentation\nHere we make a nice function to show the ground truth (green) and the prediction (red) on the same image","002ebfda":"**For the Data Science Bowl 2017, many of the notebooks had 'lung segmentation' as a preprocessing step. We take one of the algorithms (modified slightly from: https:\/\/www.kaggle.com\/kmader\/dsb-lung-segmentation-algorithm) for practising on 3D images **","ed6088a5":"# **3d_images start Here**","1b71c86d":"# **Show slices**"}}