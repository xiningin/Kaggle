{"cell_type":{"02dea67e":"code","7f687e4e":"code","c4301d6c":"code","64606d20":"code","8707f544":"code","a50ce470":"code","50179dc0":"code","ce2d4a79":"code","55f8873f":"markdown","5733e314":"markdown","bc99bda2":"markdown","7e7fbdf1":"markdown","9f160904":"markdown","1639e47c":"markdown","c1bbabbc":"markdown","51e8b94a":"markdown","b7e0cbef":"markdown"},"source":{"02dea67e":"# Imports von Numpy sowie PIL (zum Einlesen von Bildern) und Matplotlib (zum Plotten)\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\n\n# Lese ein Bild als Numpy-Array ein\ndef read_jpg(path):\n    return np.asarray(Image.open(path))\n\ndef plot(X):\n    plt.imshow(X, cmap=plt.cm.gray, vmin=0, vmax=255)\n    plt.show()\n\nX = read_jpg('\/kaggle\/input\/d\/aulges\/potterfaces\/faces.png')\nplot(X)\n\nH,W,_ = np.shape(X)","7f687e4e":"Xgray = X.mean(axis = 2)\nplot(Xgray)","c4301d6c":"Xgray_mini = Xgray[::2,::2]\nplot(Xgray_mini)","64606d20":"height = H \/\/ 4\nwidth = W \/\/ 7\nharry = X[:height,:width]\nplot(harry)","8707f544":"def get_face(i,j):\n    return Xgray[i*height : (i*height + height), j*width : (j*width + width)]\n    \nplot(get_face(0,6))","a50ce470":"Xgray_array = []\n\n\nfor row in range(4):\n    for col in range(7):\n        Xgray_array.append(get_face(row,col))\n\nXgray_array = np.array(Xgray_array)\n\nXgray_a = np.array([get_face(row,col) for row in range(4) for col in range(7)])\n        \nplot(Xgray_array[2,:,:])","50179dc0":"for j in range(28):\n    img = Xgray_a[j]\n    _min = img.min()\n    _max = img.max()\n    img2 = 255 * (img - _min) \/ (_max - _min)\n    plot(np.hstack([img, img2]))","ce2d4a79":"Xpop = ((X > 127) * 255).astype('uint8')","55f8873f":"## 7. Kontrastverst\u00e4rkung\nManche der Gesichter sind ziemlich dunkel.oder grau-in-grau. Wir wollen die Bilder deshalb kontrastverst\u00e4rken: \n\n* Duchlaufen Sie die einzelnen Gesichter.\n* Ermitteln Sie f\u00fcr jedes Gesicht das Minimum und Maximum (siehe die Numpy-Funktionen <a href=\"https:\/\/numpy.org\/doc\/stable\/reference\/generated\/numpy.ndarray.min.html\">min()<\/a> und max()).\n* Skalieren Sie die einzelnen Pixelwerte linear, so dass der maximale Wert hinterher 255 und der minimale Wert 0 betr\u00e4gt. \n* Plotten Sie das Vorher-Bild neben dem kontrastverst\u00e4rkten Nachher-Bild. F\u00fcr welche Gesichter bemerken Sie einen Unterschied?\n\n*Hinweis: Sie m\u00fcssen die Pixel nicht einzeln durchlaufen: Rechnen Sie z.B. gray_image = gray_image\/2, halbieren Sie die Werte **aller** Pixel des Bildes!*","5733e314":"## 2. Bild in Grauwert-Bild verwandeln\nVerwandeln Sie das (dreidimensionale) Ausgangsbild X nun in ein zweidimensionales Grauwertbild Xgray, indem Sie die Werte der drei Farbkan\u00e4le mitteln.\n*Hinweis: Numpy bietet hierf\u00fcr eine n\u00fctzliche Funktion <a href=\"https:\/\/numpy.org\/doc\/stable\/reference\/generated\/numpy.mean.html?highlight=mean#numpy.mean\">mean()<\/a>.*","bc99bda2":"## 6. Mosaik in Bildsequenz zerlegen.\nXgray stellt bisher ein Mosaik aus 28 Gesichtern dar. Bauen Sie das Eingabebild Xgray um: Verwandeln Sie es in ein **28 x 131 x 131** - Array. In diesem stellt die vordere Dimension die Anzahl der Gesichter dar, X[j,:,:] ist das Bild des j-ten Gesichts.\n\n*Hinweis: Die obige Methode get_face() bietet sich an...*","7e7fbdf1":"## 4. Harry ausschneiden\nZur\u00fcck zum Ausgangs-Farbbild X: Links oben befindet sich das Bild von Harry. Benutzen Sie **Slicing** das Bild von Harry aus und plotten sie es.","9f160904":"## 5. Ein beliebiges Subbild ausschneiden\nSchreiben Sie eine Methode *get_face()*, die (gegeben eine Zeile i und eine Spalte j) das zugeh\u00f6rige Subbild, d.h. ein Gesicht unseres Mosaiks, ausw\u00e4hlt. Zum Beispiel sollte get_face(0,0) das Bild von Harry zur\u00fcckliefern, get_face(1,0) das von Dobby, get_face(0,6) das von Dumbledore.\n\nArbeiten Sie ab hier mit dem Grauwertbild Xgray.","1639e47c":" # Numpy 101 (mit Harry Potter)\nIn diesem Notebook lernen Sie **numpy** kennen, Pythons m\u00e4chtige Bibliothek f\u00fcr mehrdimensionale Arrays. Numpy bietet allerhand n\u00fctzliche Funktionalit\u00e4t, unter anderem ...\n\n* das kompakte Rechnen mit Vektoren, Matrizen, und generellen \"Tensoren\" (diese werden alle als Numpy-Arrays dargestellt)\n* die Selektion von Daten-Teilbereichen mit \"Slicing\"\n* viele m\u00e4chtige Operationen wie Eigenwertzerlegungen, automatische Optimierer\/L\u00f6ser, etc.","c1bbabbc":"## 3. Bild kleiner machen\nErstellen Sie ein kleineres Bild *Xgray_mini*, indem Sie nur jedes zweite Pixel in x- und y-Richtung verwenden.\n\n*Hinweis: Slicing besitzt einen dritten Parameter, die Schrittweite: z.B. w\u00e4hlt array[5:18:3] jedes dritte Element des Arrays zwischen 5 und 18.*","51e8b94a":"## 1. Bild einlesen\nDigitale Farbbilder sind in Numpy dreidimensionale Arrays mit den Dimensionen *(H\u00f6he,Breite,3)*. Die letzte Dimension entspricht den drei Farbkan\u00e4len Rot, Gr\u00fcn und Blau. Die einzelnen Pixelwerte liegen zwischen 0 (dunkel) und 255 (hell). \nDer folgende Code liest ein Bild ein und plottet es. Das Bild zeigt 28 Gesichter aus den Harry-Potter-Filmen.\n\nBestimmen Sie die Breite und H\u00f6he des Bildes mittels der **shape** des Numpy-Arrays X.","b7e0cbef":"## 8. Pop Art\nZuletzt **binarisieren** wir das Ausgangsbild X. Setzen Sie hierzu jeden Farbwert > 127 auf 255 (wei\u00df) und jeden Pixelwert <= 127 auf 0 (schwarz). Plotten Sie das resultierende Bild.\n\n*Hinweis: Auch boolesche Operatoren wie '>' k\u00f6nnen Sie direkt auf alle Pixel des Bildes anwenden!*"}}