{"cell_type":{"83707748":"code","d1c29a6a":"code","3c15e8ff":"code","808694ec":"code","dc649240":"code","d597b095":"code","5b83bd96":"code","f4f8867a":"code","cf16291e":"code","e6d8bed5":"code","6283cd8c":"code","aa19288c":"code","5c4489f4":"code","68820e01":"code","577efabb":"code","1ebf8da5":"code","4c9b5ffb":"code","67d385dc":"code","f83b2616":"code","b6c31116":"code","a6244373":"code","1291662a":"code","9e32f0a6":"code","cb9083aa":"code","cfb53bb0":"code","088f56c9":"code","12f0de91":"code","1cd805a6":"code","1d76044a":"code","c868f545":"code","7c7770cb":"code","4bf1565c":"code","86a8a33c":"code","5217fc47":"code","44b39ccb":"code","e9db5ef0":"code","e50899c4":"code","233a9ee3":"code","be0e1ee4":"markdown","8d70b6d3":"markdown","acb9226b":"markdown","8899039f":"markdown","8f25164d":"markdown","e79c3e70":"markdown","b747ccc1":"markdown","ad89b93d":"markdown","9a7b02d0":"markdown","4b8e69cb":"markdown","1ef81e01":"markdown","d4350392":"markdown","b709bff8":"markdown","d75b7ef3":"markdown","1764f35f":"markdown","c73befe0":"markdown","a018c0ca":"markdown","b0647ca4":"markdown","fee12621":"markdown","d5b21df0":"markdown","36a8832d":"markdown","d1a23d81":"markdown","6a56df57":"markdown","8195f4ca":"markdown","6f2eb3ed":"markdown","dd79ddb9":"markdown"},"source":{"83707748":"!pip install efficientnet","d1c29a6a":"import math, re, os \nimport json\nimport pandas as pd\nimport numpy as np\nimport tensorflow as tf\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport cv2\nfrom kaggle_datasets import KaggleDatasets\nimport albumentations as A\nfrom tensorflow import keras\nimport efficientnet.tfkeras as efn\nfrom keras.callbacks import ModelCheckpoint, EarlyStopping\nfrom keras.models import model_from_json\nfrom functools import partial\nfrom sklearn.model_selection import train_test_split\n\nprint(\"Tensorflow version \" + tf.__version__)","3c15e8ff":"try:\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    print('Device:', tpu.master())\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\nexcept:\n    strategy = tf.distribute.get_strategy()\nprint('Number of replicas:', strategy.num_replicas_in_sync)","808694ec":"AUTOTUNE = tf.data.experimental.AUTOTUNE\nmodel_path =  \"\/kaggle\/working\/models\/model_EffB3.h5\"\ndatasets_dir = KaggleDatasets().get_gcs_path()\nbatch_size = 64 * strategy.num_replicas_in_sync\nimage_size = [512, 512]\nclasses = ['0', '1', '2', '3', '4']\nepochs = 100","dc649240":"base_dir = \"..\/input\/cassava-leaf-disease-classification\/\"\nwith open(os.path.join(base_dir, \"label_num_to_disease_map.json\")) as file:\n    name_classes = json.loads(file.read())\n    name_classes = {int(k) : v for k, v in name_classes.items()}\n    \nprint(json.dumps(name_classes, indent=4))","d597b095":"input_files = os.listdir(os.path.join(base_dir, \"train_images\"))\nprint(f\"Images for training: {len(input_files)}\")","5b83bd96":"train = pd.read_csv(os.path.join(base_dir, \"train.csv\"))\ntrain[\"disease\"] = train[\"label\"].map(name_classes)\ntrain","f4f8867a":"plt.figure(figsize=(8, 6))\nsns.countplot(y=\"disease\", data=train);\nplt.ylabel(\"Health condition\")\nplt.xlabel(\"Disponible images\")","cf16291e":"# For visualize only one categorie\ndef plot_images(label, disease, images_number=3, verbose=0):\n    plot_list = train[train[\"label\"] == label].sample(images_number)['image_id'].tolist()    \n    if verbose:\n        print(plot_list)    \n    labels = [disease for i in range(len(plot_list))]        \n    plt.figure(figsize=(16, 12))    \n    for ind, (image_id, disease) in enumerate(zip(plot_list, labels)):\n        plt.subplot(3, 3, ind + 1)\n        image = cv2.imread(os.path.join(base_dir,\"train_images\",image_id))\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        plt.imshow(image)\n        plt.title(disease, fontsize=12)\n        plt.axis(\"off\")   \n    plt.show()","e6d8bed5":"plot_images(label=0, disease=\"Cassava Bacterial Blight (CBB)\")","6283cd8c":"plot_images(label=3, disease=\"Cassava Mosaic Disease (CMD)\")","aa19288c":"plot_images(label=1, disease=\"Cassava Brown Streak Disease (CBSD)\")","5c4489f4":"plot_images(label=2, disease=\"Cassava Green Mottle (CGM)\")","68820e01":"plot_images(label=4, disease='Healthy')","577efabb":"def decode_image(image):\n    image = tf.image.decode_jpeg(image, channels=3)\n    image = tf.cast(image, tf.float32) \/ 255.0\n    image = tf.reshape(image, [*image_size, 3])\n    return image","1ebf8da5":"def read_tfrecord(example, labeled):\n    tfrecord_format = {\n        \"image\": tf.io.FixedLenFeature([], tf.string),\n        \"target\": tf.io.FixedLenFeature([], tf.int64)\n    } if labeled else {\n        \"image\": tf.io.FixedLenFeature([], tf.string),\n        \"image_name\": tf.io.FixedLenFeature([], tf.string)}\n    \n    example = tf.io.parse_single_example(example, tfrecord_format)\n    image = decode_image(example['image'])\n    \n    if labeled:\n        label = tf.cast(example['target'], tf.int32)\n        return image, label\n    idnum = example['image_name']\n    return image, idnum","4c9b5ffb":"def load_dataset(filenames, labeled=True, ordered=False):\n    ignore_order = tf.data.Options()\n    if not ordered:\n        # disable order, increase speed\n        ignore_order.experimental_deterministic = False \n    # automatically interleaves reads from multiple files\n    dataset = tf.data.TFRecordDataset(filenames, num_parallel_reads=AUTOTUNE) \n    # uses data as soon as it streams in, rather than in its original order\n    dataset = dataset.with_options(ignore_order) \n    dataset = dataset.map(partial(read_tfrecord, labeled=labeled), \n                          num_parallel_calls=AUTOTUNE)\n    return dataset","67d385dc":"train_fnames, valid_fnames = train_test_split(\n    tf.io.gfile.glob(datasets_dir + '\/train_tfrecords\/ld_train*.tfrec'),\n    test_size=0.25, random_state=0)\ntest_fnames = tf.io.gfile.glob(datasets_dir + '\/test_tfrecords\/ld_test*.tfrec')","f83b2616":"def data_augment(image, label):\n    image = tf.image.random_flip_left_right(image)\n    image = tf.image.random_flip_up_down(image)\n    image = tf.image.random_brightness(image, 0.2)\n    image = tf.image.random_saturation(image, 0, 2)\n    image = tf.image.random_hue(image, 0.2)\n    return image, label","b6c31116":"def get_training_dataset():\n    dataset = load_dataset(train_fnames, labeled=True)  \n    dataset = dataset.map(data_augment, num_parallel_calls=AUTOTUNE)  \n    dataset = dataset.repeat()\n    dataset = dataset.shuffle(2048)\n    dataset = dataset.batch(batch_size)\n    dataset = dataset.prefetch(AUTOTUNE)\n    return dataset","a6244373":"def get_validation_dataset(ordered=False):\n    dataset = load_dataset(valid_fnames, labeled=True, ordered=ordered) \n    dataset = dataset.batch(batch_size)\n    dataset = dataset.cache()\n    dataset = dataset.prefetch(AUTOTUNE)\n    return dataset","1291662a":"def get_test_dataset(ordered=False):\n    dataset = load_dataset(test_fnames, labeled=False, ordered=ordered)\n    dataset = dataset.batch(batch_size)\n    dataset = dataset.prefetch(AUTOTUNE)\n    return dataset","9e32f0a6":"def count_data_items(filenames):\n    n = [int(re.compile(r\"-([0-9]*)\\.\").search(filename).group(1)) for filename in filenames]\n    return np.sum(n)","cb9083aa":"print('Dataset: {} training images, {} validation images, {} (unlabeled) test images'.format(\n    count_data_items(train_fnames), count_data_items(valid_fnames), count_data_items(test_fnames)))","cfb53bb0":"# def run_detector(detector, image_path):\n#     img = tf.io.read_file(image_path)\n#     img = tf.image.decode_jpeg(img, channels=3)\n#     converted_img  = tf.image.convert_image_dtype(img, tf.float32)[tf.newaxis, ...]\n#     result = detector(converted_img)\n#     result = {key:value.numpy() for key,value in result.items()}\n#     return result, img\n\n# def detecting_intruses(image, input_filename, boxes, class_names, scores, max_boxes=5):\n#     plants_options = [\"Plant\",\"Houseplant\",\"Flower\",\"Tree\"]\n#     ch = 0\n#     for i in range(min(boxes.shape[0], max_boxes)):\n#         if class_names[i].decode(\"ascii\") in plants_options:\n#             ch+=1\n#     if ch==0:\n#         print(ch)\n#         print(\"No plants in image:\",input_filename)","088f56c9":"# import tensorflow_hub as hub\n# module_handle = \"https:\/\/tfhub.dev\/google\/openimages_v4\/ssd\/mobilenet_v2\/1\"\n# detector = hub.load(module_handle).signatures['default']","12f0de91":"# for i in range(len(input_files)):\n#     image_path = datasets_dir+\"\/train_images\/\"+input_files[i]\n#     result, img = run_detector(detector, image_path)\n#     detecting_intruses(img.numpy(), input_files[i],result[\"detection_boxes\"],\n#               result[\"detection_class_entities\"], result[\"detection_scores\"])","1cd805a6":"lr_scheduler = keras.optimizers.schedules.ExponentialDecay(\n    initial_learning_rate=1e-3, decay_steps=10000, decay_rate=0.9)","1d76044a":"with strategy.scope():    \n    \n    #     img_adjust_layer = tf.keras.layers.Lambda(tf.keras.applications.mobilenet.preprocess_input, input_shape=[*image_size, 3])\n    #     base_model = tf.keras.applications.MobileNet(weights='imagenet', include_top=False)\n    \n    base_model = efn.EfficientNetB3(weights='imagenet', include_top=False)\n    \n    base_model.trainable = False\n    model = tf.keras.Sequential([\n        tf.keras.layers.BatchNormalization(renorm=True),\n#         img_adjust_layer,\n        base_model,\n        tf.keras.layers.GlobalAveragePooling2D(),\n        tf.keras.layers.Dense(256, activation='relu'),\n#         tf.keras.layers.Dropout(0.4),\n#         tf.keras.layers.Dense(64, activation='relu'),\n        tf.keras.layers.Dropout(0.1),\n        tf.keras.layers.Dense(len(classes), activation='softmax')  \n    ])\n    model.compile(\n        optimizer=tf.keras.optimizers.Adam(learning_rate=lr_scheduler, epsilon=0.00001),\n        loss='sparse_categorical_crossentropy',  \n        metrics=['sparse_categorical_accuracy'])\n","c868f545":"if not os.path.exists(\"\/kaggle\/working\/models\/\"):\n    os.mkdir(\"\/kaggle\/working\/models\/\") \nweights_path = \"\/kaggle\/working\/models\/weights_EffB3.h5\"\ncallbacks_list = [\n      ModelCheckpoint(weights_path, monitor='val_sparse_categorical_accuracy', \n                  verbose=1, save_best_only=True, save_weights_only=True),\n      EarlyStopping(monitor='val_sparse_categorical_accuracy', patience=10, verbose=0),\n#       ReduceLROnPlateau(monitor='val_sparse_categorical_accuracy', factor=0.2,\n#                               patience=5)\n      ]","7c7770cb":"# Let's take a look to see how many layers are in the base model\nprint(\"Number of layers in the base model: \", len(base_model.layers))\nprint(\"Number of layers in the model: \", len(model.layers))","4bf1565c":"# load data\ntrain_dataset = get_training_dataset()\nvalid_dataset = get_validation_dataset()","86a8a33c":"steps_per_epoch = count_data_items(train_fnames) \/\/ batch_size\nvalid_steps = count_data_items(valid_fnames) \/\/ batch_size\n\nhistory = model.fit(train_dataset, \n                    steps_per_epoch=steps_per_epoch, \n                    epochs=epochs,\n                    validation_data=valid_dataset,\n                    validation_steps=valid_steps,\n                    callbacks=[callbacks_list]\n                   )","5217fc47":"model.load_weights(weights_path)\nmodel.save(model_path)\nmodel.summary()","44b39ccb":"# print out variables available to use\nprint(history.history.keys())","e9db5ef0":"history_frame = pd.DataFrame(history.history)\nhistory_frame.loc[:, ['loss', 'val_loss']].plot()\nhistory_frame.loc[:, ['sparse_categorical_accuracy', 'val_sparse_categorical_accuracy']].plot();","e50899c4":"# this code will convert our test image data to a float32 \ndef to_float32(image, label):\n    return tf.cast(image, tf.float32), label","233a9ee3":"test_ds = get_test_dataset(ordered=True) \ntest_ds = test_ds.map(to_float32)\n\nprint('Predicted label')\ntest_images_ds = test_ds\ntest_images_ds = test_ds.map(lambda image, idnum: image)\nprobabilities = model.predict(test_images_ds)\npredictions = np.argmax(probabilities, axis=-1)\nprint(predictions)","be0e1ee4":"## Building the model\nIn order to ensure that the model is trained on the TPU, it is built using `with strategy.scope()`.    \n\nThis model is built using transfer learning, using the pretrained model EfficientNet B3 as base model, and adding the customizable model built using `tf.keras.Sequential`.\n\nNote that we're using `sparse_categorical_crossentropy` as our loss function, because I did not use one-hot-encoder in the labels.","8d70b6d3":"I'm using 75% of photographs for training and 25% for validation.","acb9226b":"## Exploratory data analysis (EDA)","8899039f":"In order to save the best model even if after some epochs it has degradeted, I'm going to use a checkpoint that allows me to go back to the best scores. I'm also using an early-stopping callback, that dont allows the training to continue if the monitored score is not improving. A third callback in test is the diminution of learning rate if after some epochs there is not improvement.","8f25164d":"## Setup\nFor this competition, I'm using the Cassava leaf disease classification dataset, that has been previously associated to the notebook.","e79c3e70":"The TFRecord format is a simple format for storing a sequence of binary records.","b747ccc1":"Test of apply object detection to dataset as a cleaning traitement before classification.","ad89b93d":"I prefer to use a fonction to specify the way of getting the datasets, since it is faster and cleaner.","9a7b02d0":"## Make predictions\nNow that the model is trained, I can use it to make predictions.","4b8e69cb":"## Train the model","1ef81e01":"## Librairies","d4350392":"# Building the model","b709bff8":"With a total of more than 21k JPG images, I can explore the kind of images and the distribution of presence of diseases.","d75b7ef3":"Even in the case of healthy plants, the range of posibilities is long. I could find here green, luminous, beatuful, well focused photos, but also low quality photos, damaged or whitered leaves, and a diversity of parts of the plant : roots, steams, leaves, etc.","1764f35f":"## Detect TPU\nTensor Processing Units (TPUs) are hardware accelerators that are specialized for deep learning tasks. \nThanks to Jesse Mostipak for the \"Getting Started Tutorial\".\nAs output we can expect an 1 if not working on TPU, and a 8 when using.","c73befe0":"The mapping between each label and the real disease name is in the \"label_num_to_disease_map.json\" file. I'm going to link it to the dataset of images in order to explore how does it look every disease and get a general idea of the kind of images thar are in the dataset. There are 4 types of disease (classes) and an extra class that refers to the healthy plant. ","a018c0ca":"CMD is the most important threat to cassava production in some African zones, and also in this dataset is the most common disease.","b0647ca4":"# Evaluate the model","fee12621":"In order to aument the data, I'm using two mainly means: Position variation and HSB representations of color.","d5b21df0":"I'm able to see a printout of each layer, their corresponding shape, as well as the associated number of parameters. \nAt the bottom of the printout it's possible to see information on the total parameters, trainable parameters, and non-trainable parameters. Because I am using a pre-trained model, there is a large number of non-trainable parameters.","36a8832d":"As we can see, there are a lot of photographs of Cassava mosaic disease in comparison with others diseases. Is this disease more frequent? Is easier to identify? Is a question of how the dataset has been selected? Let's see how looks like this Cassava disease.","d1a23d81":"# Cassava Leaf Disease Classification\n## Identify the type of disease present on a Cassava Leaf image","6a56df57":"### EfficientNet packages\nIn this notebook I'm going to use the EfficientNet B3 model as pre-trained base-model. It is possible to call its packages from internet or to download as a data set and use as a second input data set. ","8195f4ca":"It is useful to see the model performance through a plot of the scores as a fonction of the number of epochs. It gives me information about the moment at which an inflection occurs, about how smooth is the performance evolution, about the relashionship of validation and training datasets evolutions, etc. in a fast and comprehensible way.","6f2eb3ed":"## Load the data\nI'm going to use some fonctions to flow the datasets. ","dd79ddb9":"\n## Learning rate schedule\nWhen training a model, it is often recommended to lower the learning rate as the training progresses. This schedule applies an exponential decay function to an optimizer step, given a provided initial learning rate."}}