{"cell_type":{"bbb1fbc9":"code","68677e1d":"code","ff2e089c":"code","dd659fd3":"code","5b444f1b":"code","45afaa20":"code","9b0502b2":"code","cc19071d":"code","ae494603":"code","9ebdfe4e":"code","92d83f07":"code","75094e50":"code","e6dd3b96":"markdown","d090b849":"markdown","854a242e":"markdown","a0116591":"markdown","b25fc456":"markdown","a360c5fa":"markdown","109bb8d1":"markdown","3a512c42":"markdown","0b4bc011":"markdown"},"source":{"bbb1fbc9":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","68677e1d":"import sys\nimport warnings\nimport matplotlib.pyplot as plt\nimport matplotlib.cbook\nfrom matplotlib.ticker import MaxNLocator\n\nif not sys.warnoptions:\n    warnings.simplefilter(\"ignore\")\nwarnings.simplefilter(action='ignore', category=FutureWarning)\nwarnings.filterwarnings(\"ignore\", category=FutureWarning)\nwarnings.filterwarnings(\"ignore\", category=matplotlib.cbook.mplDeprecation)\n\n# Bibliotecas padr\u00f5es\nimport numpy as np\nimport matplotlib\nimport pandas as pd\nimport seaborn as sns\nimport datetime\nfrom datetime import datetime, timedelta\nfrom pandas.tseries.offsets import DateOffset\n\n\nsns.set_context('talk')\nplt.style.use('seaborn-whitegrid')\n%matplotlib inline\n\n# Bibliotecas importantes\nimport pymc3\nimport arviz as az\nimport altair as alt\n\n# Definindo tamanho da saida dos dados em tela\npd.options.display.max_seq_items = 8000\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)","ff2e089c":"# Vers\u00f5es dos pacotes usados neste jupyter notebook\n%reload_ext watermark\n%watermark -a \"Unimed-Blumenau\" --iversions","dd659fd3":"# Defini parametros do arquivo\npath        = \"\/kaggle\/input\/\"                                   # caminho do diretorio dos dados\nfile_name   = \"novos_casos_15_05_20.xlsx\"     # nome do arquivo base da prefeitura\nsheet_name  = \"Previsao\"                                   # nome da aba dos valores para alimentar o modelo\nfile_export = \"previsoes_blumenau_15_05_20.xlsx\"                    # nome do arquivo final com as previsoes\nencoding    = \"utf8\"                                       # tipo de encoding do arquivo\n\n# Definindo parametros para previsao\ncity          = \"Blumenau\"                                 # nome da cidade a ser analisada\nnum_caso_ini  = 98                                         # contar a partir de quantos casos\nqtd_dias_prev = 15                                         # quantidade de dias de forecast\n","5b444f1b":"# Define a fun\u00e7\u00e3o\ndef coleta_dados():\n    \n    # Leitura do arquivo de origem\n    data = pd.read_excel (path+file_name, sheet_name=sheet_name, encoding=encoding)\n    \n    # Define os nomes das colunas\n    data = data[['DATA','QTDE_POSITIVADO_DIA','QTDE_POSITIVADO_TOTAL']]\n    data.columns = ['date', 'newCases', 'totalCases']\n    data['date'] = pd.to_datetime(data['date'])\n\n    # Colocando a data como index\n    data = data.set_index('date')\n\n    # Busca o n\u00famero de dias desde o momento em que x casos confirmados foram cruzados\n    data['days_since'] = np.nan\n\n    # Marcando registros positivos acima de 'num_caso_ini' casos em Blumenau\n    data['days_since'] = np.arange(-len(data[data.totalCases < num_caso_ini]), len(data[data.totalCases >= num_caso_ini]))\n    \n    return data\n\n# Realizando a coleta dos dados\ndados_covid = coleta_dados()\n\n# Selecionando somente a partir de 'num_caso_ini' casos registrados de COVID-19\ndados_covid = dados_covid.loc[lambda x: (x.days_since >= 0)]","45afaa20":"dados_covid.head()","9b0502b2":"# Funcao para criacao do modelo\ndef create_model():\n    \n    # Cria\u00e7\u00e3o do Modelo\n    with pymc3.Model() as modelo:\n\n        # Definimos o intercepto\n        a_grp = pymc3.Normal('a_grp', 100, 50)\n        a_grp_sigma = pymc3.HalfNormal('a_grp_sigma', 50)\n        a_ind = pymc3.Normal('a_ind', mu = a_grp, sigma = a_grp_sigma, shape = 1)\n\n        # Definimos o slope\n        b_grp = pymc3.Normal('b_grp', 1.33, .5)\n        b_grp_sigma = pymc3.HalfNormal('b_grp_sigma', .5)\n        b_ind = pymc3.Normal('b_ind', mu = b_grp, sigma = b_grp_sigma, shape = 1)\n\n        # Erro\n        sigma = pymc3.HalfNormal('sigma', 500., shape = 1)\n\n        # Criar probabilidades\n        x = pymc3.Data(city + \"x_data\", dados_covid.days_since.values)\n        confirmed = pymc3.Data(city + \"y_data\", dados_covid.totalCases.astype('float64').values)\n\n        # Negative Binomial\n        pymc3.NegativeBinomial(city,\n                               (a_ind * b_ind ** x), \n                               sigma, \n                               observed = confirmed)\n        \n    return modelo\n\n# Funcao para realizar as previsoes com base no modelo\ndef fit_model(modelo):\n    with modelo:\n\n        # Amostra posterior\n        trace = pymc3.sample(tune = 1500, chains = 1, cores = 1, target_accept = .9, progressbar = True)\n\n        # Atualiza os dados para que possamos obter previs\u00f5es para o futuro\n        x_data = np.arange(0, dados_covid.shape[0] + qtd_dias_prev)\n        y_data = np.array([0] * len(x_data))\n        pymc3.set_data({city + \"x_data\": x_data})\n        pymc3.set_data({city + \"y_data\": y_data})\n\n        # Previs\u00e3o da amostra posterior (100 amostras)\n        previsoes = pymc3.sample_posterior_predictive(trace, samples = 100)\n\n    return trace, previsoes","cc19071d":"%%time\n\n# Criacao do modelo\nmodel = create_model()\n\n# Realizando as previsoes\ntrace, previsoes = fit_model(model)\n\n# Avalia\u00e7\u00e3o do Modelo\naz.plot_trace(trace, compact = True);","ae494603":"# Funcao para completar as datas futuras\ndef fill_prev_date(df, fill_value=0):\n\n    idx = pd.date_range(df[0], df[0]+DateOffset(days=df.shape[0]-1),freq='D')\n    df = df.reindex(idx, fill_value=fill_value)\n    df['date'] = pd.DatetimeIndex(df.index)\n\n    return df","9ebdfe4e":"# Renomeando coluna para realizar o merge com as previsoes\ndfBlumenauSC = dados_covid.rename(columns={\"days_since\": \"days\"})\ndfBlumenauSC = dfBlumenauSC.reset_index()\n\n# Convertendo as previsoes para dataframe\npred = previsoes[city].T\ndf_previsoes = pd.DataFrame(pred)\ndf_previsoes = df_previsoes.reset_index()\ndf_previsoes = df_previsoes.rename(columns={\"index\": \"days\"})\n\n# Realizando o merge dos dois datasets (como chave o dia)\nmerge = pd.merge(dfBlumenauSC, df_previsoes, on=['days'], how='right')\n\n# Selecionando apenas a m\u00e9dia das 100 probabilidades\ncol = merge.iloc[:, 4:merge.shape[1]]\n\n# Criando novas colunas para o gr\u00e1fico\nmerge['media']       = col.mean(axis = 1)\nmerge['min']         = col.min(axis = 1) \nmerge['max']         = col.max(axis = 1) \n\n# Ordenando valores para o grafico\nmerge['media'] = merge['media'].sort_values().values\nmerge['min'] = merge['min'].sort_values().values\nmerge['max'] = merge['max'].sort_values().values\n\n# Preenchendo valores nulos\nmerge['grafico_avg'] = merge['totalCases']\nmerge['grafico_avg'] = merge['grafico_avg'].fillna(merge['media'])\nmerge['grafico_min'] = merge['totalCases']\nmerge['grafico_min'] = merge['grafico_min'].fillna(merge['min'])\nmerge['grafico_max'] = merge['totalCases']\nmerge['grafico_max'] = merge['grafico_max'].fillna(merge['max'])\n\nmerge[['date','totalCases','media','min','max','grafico_avg','grafico_min','grafico_max']]\n\n# Preenchendo as datas futuras com nulo\nnew_data = fill_prev_date(df=merge['date'])\nmerge['date'] = new_data['date']\nmerge['date'] = merge['date'].dt.strftime('%d-%m-%Y')","92d83f07":"############# EXIBINDO GR\u00c1FICO GERAL ###############\nfig, ax = plt.subplots(nrows = 1, ncols = 1, figsize = (28, 14), sharex = True)\n\nax.plot(merge.date, merge.totalCases, color='b', linewidth=7)\nax.plot(merge.date, merge['media'], alpha = 1, color = '.5', ls = '--', linewidth=7)\nax.plot(merge.date, merge['min'],   alpha = 1, color = 'g', linewidth=7)\nax.plot(merge.date, merge['max'],   alpha = 1, color = 'r', linewidth=7)\n#ax.plot(covid_blumenau.date, covid_blumenau['recover'],  color = 'pink')\n\nax.plot(merge.date, merge.totalCases, color='b')\n#ax.set_ylim(0, 650)\nax.xaxis.set_major_locator(MaxNLocator(integer=True))\nax.set_title('Previs\u00e3o do crescimento dos casos confirmados de COVID-19 em Blumenau (modelo baseline '+str(datetime.now().date())+')', fontsize=20)\nax.legend(['Dados Observados', 'Previs\u00e3o M\u00e9dia', 'Previs\u00e3o Otimista', 'Previs\u00e3o Pessimista'])\nax.set(ylabel = 'Casos')\n\nxs = merge.date\n\n# Valores na linha de casos reais    \nys = merge['totalCases']\nfor x, y in zip(xs,ys):\n    label = \"{:.0f}\".format(y)\n    plt.annotate(label,\n                 (x,y),\n                 textcoords=\"offset points\",\n                 xytext=(0,10),\n                 weight='bold',\n                 fontsize=16,\n                 ha='center') \n\n\n# Valores na linha de medio    \nys = merge['grafico_avg']\nfor x, y in zip(xs,ys):\n    label = \"{:.0f}\".format(y)\n    plt.annotate(label,\n                 (x,y),\n                 textcoords=\"offset points\",\n                 xytext=(0,10),\n                 weight='bold',\n                 fontsize=16,\n                 ha='center') \n    \n# Valores na linha de Otimista    \nys = merge['grafico_min']\nfor x, y in zip(xs,ys):\n    label = \"{:.0f}\".format(y)\n    plt.annotate(label,\n                 (x,y),\n                 textcoords=\"offset points\",\n                 xytext=(0,10),\n                 weight='bold',\n                 fontsize=16,\n                 ha='center')   \n\n# Valores na linha de Pessimista    \nys = merge['grafico_max']\nfor x, y in zip(xs,ys):\n    label = \"{:.0f}\".format(y)\n    plt.annotate(label,\n                 (x,y),\n                 textcoords=\"offset points\",\n                 xytext=(0,10),\n                 weight='bold',\n                 fontsize=16,\n                 ha='center') \n\nfig.tight_layout();\n\n","75094e50":"merge.to_excel(file_export, index=False)","e6dd3b96":"## 6. Gr\u00e1ficos","d090b849":"## 4. Constru\u00e7\u00e3o do Modelo","854a242e":"## 5. Execu\u00e7\u00e3o do Modelo","a0116591":"## 2. Preparando o Ambiente","b25fc456":"## 3. Coletar dados sobre o COVID-19","a360c5fa":"## 1. Fonte de Dados\n- Prefeitura de Blumenau","109bb8d1":"# Fim","3a512c42":"# Previs\u00e3o da Taxa de Crescimento do COVID-19 em Blumenau\n\n- Criado em    : 23\/03\/2019\n- Atualizado em: 01\/05\/2020\n- Autor        : Rodrigo de Lima Oliveira (Unimed Blumenau)","0b4bc011":"## 7. Exportar para Excel"}}