{"cell_type":{"538d11ec":"code","0d08203e":"code","517b1ee8":"code","79fc7eda":"code","cfa0f825":"code","aba808dc":"code","afda3cb1":"code","21b3a20a":"code","b7166954":"code","a73b0bda":"code","fc948000":"code","8495dc43":"code","2bba1e8e":"code","4d81335b":"code","7dcc538c":"code","d6eca0eb":"code","b16c09d3":"code","b7a0fcee":"code","02d3e178":"code","26da04ad":"code","1d10c060":"code","02b42e68":"code","4f9d40dd":"code","6b84d3dd":"code","7e2a25a7":"code","11389240":"code","eb79294a":"code","26d6ba91":"code","67e1485a":"code","b77c92c5":"code","2d59fa39":"code","4a722dde":"code","1f11b821":"code","4955d26e":"markdown","801940b4":"markdown","1cfbb2ec":"markdown","4be4ed9e":"markdown","a5315e59":"markdown","013d1dc2":"markdown","73d27275":"markdown","b23c9329":"markdown"},"source":{"538d11ec":"#Deep SVDD\u306e\u5b66\u7fd2\u306e\u305f\u3081\u306b\u3001pyod\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\n!pip install pyod","0d08203e":"# \u30e9\u30a4\u30d6\u30e9\u30ea\u3092import\u3057\u307e\u3059\nimport os\nimport numpy as np\nimport pandas as pd\nfrom pandas import DataFrame\nimport matplotlib.pyplot as plt\n\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.neighbors import LocalOutlierFactor\nfrom sklearn.ensemble import IsolationForest\nfrom sklearn.svm import OneClassSVM\nfrom sklearn.preprocessing import MinMaxScaler\nfrom tqdm.notebook import tqdm\nimport librosa \nimport librosa.display\nimport IPython","517b1ee8":"INPUT_DIR = '\/kaggle\/input\/hah-data-science-challenge'","79fc7eda":"def display_audio(file_stem):\n    if 'train' in file_stem: \n        display(IPython.display.Audio(f'\/kaggle\/input\/hah-data-science-challenge\/train\/train\/{file_stem}.wav'))\n    elif 'test' in file_stem:\n        display(IPython.display.Audio(f'\/kaggle\/input\/hah-data-science-challenge\/test\/test\/{file_stem}.wav'))\n        \ndef display_meta(file_stem):\n    if 'train' in file_stem: \n        df = pd.read_csv('\/kaggle\/input\/hah-data-science-challenge\/train.csv', index_col=False)\n    elif 'test' in file_stem:\n        df = pd.read_csv('\/kaggle\/input\/hah-data-science-challenge\/test.csv', index_col=False)\n    df = df[df['\u30d5\u30a1\u30a4\u30eb']==file_stem + '.wav']\n    display(df)","cfa0f825":"# \u5225\u306enotebook\u3067\u4f5c\u6210\u3057\u305f\u6253\u97f3\u5206\u89e3\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u307f\ndf = pd.read_csv('..\/input\/hah-dsc-exp004\/meta_decomp.csv')","aba808dc":"df['signal_max'].hist()","afda3cb1":"# \u97f3\u306e\u5927\u304d\u3055\u304c\u4e00\u5b9a\u4ee5\u4e0b\u306e\u30c7\u30fc\u30bf\u306f\u7121\u97f3\u3068\u3057\u3066\u3001\u5bfe\u8c61\u304b\u3089\u9664\u5916\nth = 0.5\ndf = df[df['signal_max']>0.5].reset_index(drop=True)\ndf['signal_max'].hist()","21b3a20a":"df.shape","b7166954":"#\u53c2\u7167\u3000URL\uff1ahttps:\/\/github.com\/lukasruff\/Deep-SVDD-PyTorch\/blob\/master\/src\/deepSVDD.py\nimport numpy as np\nimport torch\nfrom pyod.models.base import BaseDetector\nfrom sklearn.utils import check_array\nfrom sklearn.utils.validation import check_is_fitted\nfrom torch import nn\nfrom tqdm import tqdm\n\nimport random\nimport tensorflow as tf\ndef fix_seed(seed):\n    # random\n    random.seed(seed)\n    # Numpy\n    np.random.seed(seed)\n    # Pytorch\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = False\n    # Tensorflow\n    tf.random.set_seed(seed)\n\nSEED = 42\nfix_seed(SEED)\n\n\ndef get_activation_by_name(name: str) -> nn.Module:\n    \"\"\"Get activation function by name (string).\"\"\"\n\n    activations = {\n        \"relu\": nn.ReLU(),\n        \"prelu\": nn.PReLU(),\n        \"sigmoid\": nn.Sigmoid(),\n        \"tanh\": nn.Tanh(),\n    }\n\n    if name not in activations.keys():\n        raise ValueError(name, \"is not a valid activation function\")\n\n    return activations[name]\n\n\nclass PyODDataset(torch.utils.data.Dataset):\n    \"\"\"PyOD Dataset class for PyTorch Dataloader.\"\"\"\n\n    def __init__(self, inputs, mean=None, std=None):\n        super().__init__()\n        self.inputs = inputs\n        self._mean = mean\n        self._std = std\n\n    def __len__(self):\n        return self.inputs.shape[0]\n\n    def __getitem__(self, idx):\n        if torch.is_tensor(idx):\n            idx = idx.tolist()\n        sample = self.inputs[idx, :]\n\n        if isinstance(self._mean, np.ndarray) is True:\n            sample = (sample - self._mean) \/ self._std\n\n        return torch.from_numpy(sample), idx\n\n\nclass AutoEncoder(nn.Module):\n    \"\"\"\n    Autoencoder for pretraining.\n    \"\"\"\n\n    def __init__(\n        self,\n        n_features,\n        output_dim=32,\n        hidden_neurons=None,\n        batch_norm=True,\n        hidden_activation=None,\n        output_activation=None,\n    ):\n        super().__init__()\n\n        if hidden_neurons is None:\n            hidden_neurons = [64, 32]\n\n        self.hidden_activation = hidden_activation\n        self.output_activation = output_activation\n        self.hidden_neurons = hidden_neurons\n\n        # Build encoder\n        modules = []\n        in_features = n_features\n        for _hidden_neurons in self.hidden_neurons:\n            modules.append(\n                nn.Linear(in_features, out_features=_hidden_neurons, bias=False)\n            )\n            if batch_norm is True:\n                modules.append(nn.BatchNorm1d(_hidden_neurons))\n\n            modules.append(self.hidden_activation)\n            in_features = _hidden_neurons\n        self.encoder = nn.Sequential(*modules)\n\n        # bottleneck layer\n        self.bottleneck = nn.Sequential(\n            nn.Linear(self.hidden_neurons[-1], output_dim, bias=False),\n            self.output_activation,\n        )\n\n        # Build decoder\n        modules = []\n        in_features = output_dim\n        for reversed_neurons in self.hidden_neurons[::-1]:\n            modules.append(\n                nn.Linear(\n                    in_features, out_features=reversed_neurons, bias=False\n                )\n            )\n            if batch_norm is True:\n                modules.append(nn.BatchNorm1d(reversed_neurons))\n\n            modules.append(self.hidden_activation)\n            in_features = reversed_neurons\n\n        modules.append(\n            nn.Linear(self.hidden_neurons[0], n_features, bias=False)\n        )\n        self.decoder = nn.Sequential(*modules)\n\n    def forward(self, x):\n        \"\"\"\n        forward.\n        \"\"\"\n        x = self.encoder(x)\n        x = self.bottleneck(x)\n        x = self.decoder(x)\n        return x\n\n\nclass DeepSVDD_net(nn.Module):\n    \"\"\"\n    Network for DeepSVDD.\n    \"\"\"\n\n    def __init__(\n        self,\n        n_features,\n        output_dim=32,\n        hidden_neurons=None,\n        batch_norm=True,\n        dropout_rate=0.0,\n        hidden_activation=None,\n        output_activation=None,\n    ):\n        super().__init__()\n\n        if hidden_neurons is None:\n            hidden_neurons = [64, 32]\n\n        self.hidden_activation = hidden_activation\n        self.output_activation = output_activation\n        self.hidden_neurons = hidden_neurons\n        self.dropout_rate = dropout_rate\n\n        # Build encoder\n        modules = []\n        in_features = n_features\n        for _hidden_neurons in self.hidden_neurons:\n            modules.append(\n                nn.Linear(in_features, out_features=_hidden_neurons, bias=False)\n            )\n            if batch_norm is True:\n                modules.append(nn.BatchNorm1d(_hidden_neurons))\n\n            modules.append(self.hidden_activation)\n            modules.append(nn.Dropout(self.dropout_rate))\n\n            in_features = _hidden_neurons\n        self.encoder = nn.Sequential(*modules)\n\n        # bottleneck layer\n        self.bottleneck = nn.Sequential(\n            nn.Linear(self.hidden_neurons[-1], output_dim, bias=False),\n            self.output_activation,\n        )\n\n    def forward(self, inputs):\n        \"\"\"\n        Perform forward propagation.\n        \"\"\"\n        hidden = self.encoder(inputs)\n        embed = self.bottleneck(hidden)\n        return embed\n\n\nclass DeepSVDD(BaseDetector):\n    \"\"\"Deep One-Class Classifier with AutoEncoder (AE) is a type of neural\n    networks for learning useful data representations unsupervisedly.\n    Similar to PCA, DeepSVDD could be used to detect outlying objects\n    in the data by calculating the distance from center.\n    See :cite:`ruff2018deepsvdd` for details.\n    Parameters\n    ----------\n    objective : str, optional (default='soft-boundary')\n        A string specifying the Deep SVDD objective\n        either 'one-class' or 'soft-boundary'.\n    c: float, optional (default=None)\n        Deep SVDD center, the default will be calculated based on network\n        initialization first forward pass. To get repeated results set\n        random_state if c is set to None.\n    nu: float, optional (default=0.1)\n        Deep SVDD hyperparameter nu (must be 0 < nu <= 1).\n    hidden_neurons : list, optional (default=[64, 32])\n        The number of neurons per hidden layers.\n    hidden_activation : str, optional (default='relu')\n        Activation function to use for hidden layers.\n        All hidden layers are forced to use the same type of activation.\n    output_dim : int, optional (default=32)\n        The number of neurons at output layers of Deep SVDD.\n    output_activation : str, optional (default='sigmoid')\n        Activation function to use for output layer.\n    epochs : int, optional (default=50)\n        Number of epochs to train the model.\n    batch_size : int, optional (default=32)\n        Number of samples per gradient update.\n    dropout_rate : float in (0., 1), optional (default=0.2)\n        The dropout to be used across all layers.\n    leaning_rate : float in (0., 1), optional (default=0.001)\n        Learning rate to be used in updating network weights.\n    weight_decay : float in (0., 1), optional (default=0.1)\n        The regularization strength of activity_regularizer\n        applied on each layer.\n    validation_size : float in (0., 1), optional (default=0.1)\n        The percentage of data to be used for validation.\n    preprocessing : bool, optional (default=False)\n        If True, apply standardization on the data.\n    pretraining : bool, optional (default=False)\n        If True, an autoencoder is pretrained.\n        The network weights of Deep SVDD will be initialized\n        by using pre-trained weights from the autoencoder.\n    pretrain_epochs : int, optional (default=10)\n        Number of epochs to pre-train the autoencoder.\n    warm_up_epochs : int, optional (default=10)\n        Number of training epochs for soft-boundary Deep SVDD\n        before radius R gets updated.\n    batch_norm : bool, optional (default=True)\n        If True, apply standardization on the data.\n    criterion : Torch Module, optional (default=torch.nn.MSEloss)\n        A criterion that measures erros between\n        network output and the Deep SVDD center.\n    verbose : int, optional (default=0)\n        Verbosity mode.\n        - 0 = silent\n        - 1 = progress bar\n        - 2 = one line per epoch.\n        For verbose >= 1, model summary may be printed.\n    contamination : float in (0., 0.5), optional (default=0.1)\n        The amount of contamination of the data set, i.e.\n        the proportion of outliers in the data set. When fitting this is used\n        to define the threshold on the decision function.\n    Attributes\n    ----------\n    decision_scores_ : numpy array of shape (n_samples,)\n        The outlier scores of the training data.\n        The higher, the more abnormal. Outliers tend to have higher\n        scores. This value is available once the detector is\n        fitted.\n    threshold_ : float\n        The threshold is based on ``contamination``. It is the\n        ``n_samples * contamination`` most abnormal samples in\n        ``decision_scores_``. The threshold is calculated for generating\n        binary outlier labels.\n    labels_ : int, either 0 or 1\n        The binary labels of the training data. 0 stands for inliers\n        and 1 for outliers\/anomalies. It is generated by applying\n        ``threshold_`` on ``decision_scores_``.\n    \"\"\"\n\n    def __init__(\n        self,\n        objective=\"soft-boundary\",\n        c=None,\n        nu=0.1,\n        hidden_neurons=None,\n        hidden_activation=\"relu\",\n        output_dim=32,\n        output_activation=\"sigmoid\",\n        epochs=50,\n        batch_size=32,\n        dropout_rate=0.2,\n        learning_rate=1e-3,\n        weight_decay=1e-5,\n        validation_size=0.1,\n        preprocessing=False,\n        pretraining=False,\n        pretrain_epochs=10,\n        warm_up_epochs=10,\n        batch_norm=True,\n        criterion=torch.nn.MSELoss(),\n        verbose=0,\n        contamination=0.1,\n        device=None,\n    ):\n        super().__init__(contamination=contamination)\n\n        assert objective in (\n            \"one-class\",\n            \"soft-boundary\",\n        ), \"Objective must be either 'one-class' or 'soft-boundary'.\"\n        self.objective = objective\n\n        assert (nu > 0) & (\n            nu <= 1\n        ), \"For hyperparameter nu, it must hold: 0 < nu <= 1.\"\n        self.nu = nu\n\n        if hidden_neurons is None:\n            hidden_neurons = [64, 32]\n\n        if device is None:\n            self.device = torch.device(\n                \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\n            )\n        else:\n            self.device = device\n\n        self.R = torch.tensor(0.0, device=self.device)\n        self.c = torch.tensor(c, device=self.device) if c is not None else None\n\n        self.hidden_neurons = hidden_neurons\n        self.hidden_activation = get_activation_by_name(hidden_activation)\n        self.output_dim = output_dim\n        self.output_activation = get_activation_by_name(output_activation)\n        self.epochs = epochs\n        self.batch_size = batch_size\n        self.dropout_rate = dropout_rate\n        self.learning_rate = learning_rate\n        self.weight_decay = weight_decay\n        self.validation_size = validation_size\n        self.preprocessing = preprocessing\n        self.pretraining = pretraining\n        self.pretrain_epochs = pretrain_epochs\n        self.warm_up_n_epochs = warm_up_epochs\n        self.batch_norm = batch_norm\n        self.criterion = criterion\n        self.verbose = verbose\n\n        self._ae_net = None\n        self._svdd_net = None\n        self.decision_scores_ = None\n        self._mean = None\n        self._std = None\n\n    def _init_center_c(self, train_loader, eps=0.1):\n        \"\"\"\n        Initialize hypersphere center c as the mean\n        from an initial forward pass on the data.\n        \"\"\"\n\n        c = torch.zeros(self.output_dim, device=self.device)\n\n        n_samples = 0\n        self._svdd_net.eval()\n        with torch.no_grad():\n            for data, _ in train_loader:\n                inputs = data.to(self.device).float()\n                outputs = self._svdd_net(inputs)\n                n_samples += outputs.shape[0]\n                c += torch.sum(outputs, dim=0)\n\n        c \/= n_samples\n\n        # If c_i is too close to 0, set to +-eps.\n        # Reason: a zero unit can be trivially matched with zero weights.\n        c[(abs(c) < eps) & (c < 0)] = -eps\n        c[(abs(c) < eps) & (c > 0)] = eps\n\n        return c\n\n    def _train_AutoEncoder(self, train_loader):\n        \"\"\"\n        Internal function to train AutoEncoder.\n        Parameters\n        ----------\n        train_loader : torch dataloader\n            Data loader of training data.\n        \"\"\"\n\n        optimizer = torch.optim.Adam(\n            self._ae_net.parameters(), lr=self.learning_rate, weight_decay=0.0\n        )\n\n        self._ae_net.train()\n        for _ in range(self.pretrain_epochs):\n            training_loss = 0.0\n            for data, _ in train_loader:\n                inputs = data.to(self.device).float()\n                optimizer.zero_grad()\n                outputs = self._ae_net(inputs)\n                loss = self.criterion(inputs, outputs)\n                loss.backward()\n                training_loss += loss.item()\n                optimizer.step()\n\n    def _init_network_weights_from_pretraining(self):\n        \"\"\"\n        Initialize the Deep SVDD network weights from the encoder\n        weights of the pretraining autoencoder.\n        \"\"\"\n\n        net_dict = self._svdd_net.state_dict()\n        ae_net_dict = self._ae_net.state_dict()\n\n        # Filter out decoder network keys\n        ae_net_dict = {k: v for k, v in ae_net_dict.items() if k in net_dict}\n\n        # Overwrite values in the existing state_dict\n        net_dict.update(ae_net_dict)\n\n        # Load the new state_dict\n        self._svdd_net.load_state_dict(net_dict)\n\n    def _get_loss(self, dist):\n        \"\"\"\n        Internal function to compute loss.\n        \"\"\"\n        if self.objective == \"soft-boundary\":\n            scores = dist - self.R ** 2\n            loss = self.R ** 2 + (1 \/ self.nu) * torch.mean(\n                torch.max(torch.zeros_like(scores), scores)\n            )\n        else:  # one-class deep SVDD\n            loss = torch.mean(dist)\n\n        return loss\n\n    def _update_radius(self, dist, epoch):\n        \"\"\"\n        Internal function to update radius R.\n        Optimally solve for radius R via the (1-nu)-quantile of distances.\n        \"\"\"\n        if (self.objective == \"soft-boundary\") and (\n            epoch >= self.warm_up_n_epochs\n        ):\n            newR = np.quantile(\n                np.sqrt(dist.cpu().detach().numpy()), 1 - self.nu\n            )\n            self.R.data = torch.tensor(newR, device=self.device)\n\n    def _train_DeepSVDD(self, train_loader, val_loader):\n        \"\"\"\n        Internal function to train DeepSVDD.\n        Parameters\n        ----------\n        train_loader : torch dataloader\n            Data loader of training data.\n        val_loader : torch dataloader\n            Data loader of validation data.\n        \"\"\"\n\n        optimizer = torch.optim.Adam(\n            self._svdd_net.parameters(), lr=self.learning_rate\n        )\n\n        # Initialize hypersphere center c (if c not loaded)\n        if self.c is None:\n            self.c = self._init_center_c(train_loader, eps=0.01)\n\n        tqdm_disable = True\n        if self.verbose == 1:\n            tqdm_disable = False\n\n        for epoch in tqdm(range(self.epochs), disable=tqdm_disable):\n            training_loss = []\n            self._svdd_net.train()\n            for data, _ in train_loader:\n                inputs = data.to(self.device).float()\n                optimizer.zero_grad()\n\n                # output of Deep SVDD net (embedded represention)\n                embed = self._svdd_net(inputs)\n\n                # distance from center\n                dist = torch.sum((embed - self.c) ** 2, dim=1)\n\n                # compute objective function (loss)\n                loss = self._get_loss(dist)\n\n                # add weight decay (L2)\n                decay = torch.tensor(0.0, requires_grad=True)\n                for w in self._svdd_net.parameters():\n                    decay = decay + torch.norm(w) ** 2\n                loss = loss + self.weight_decay * decay\n\n                # update weights\n                loss.backward()\n                optimizer.step()\n                training_loss.append(loss.item())\n\n                # update radius R\n                self._update_radius(dist, epoch)\n\n            if len(val_loader) > 0:\n                self._svdd_net.eval()\n                val_loss = []\n                with torch.no_grad():\n                    for data, _ in val_loader:\n                        inputs = data.to(self.device).float()\n                        embed = self._svdd_net(inputs)  # [N, D]\n                        dist = torch.sum((embed - self.c) ** 2, dim=1)  # [N, 1]\n                        loss = self._get_loss(dist)\n                        val_loss.append(loss.item())\n\n            if len(val_loader) > 0 and self.verbose == 2:\n                print(\n                    \"Epoch {}\/{}: train_loss={:.6f}, val_loss={:.6f}\".format(\n                        epoch + 1,\n                        self.epochs,\n                        np.mean(training_loss),\n                        np.mean(val_loss),\n                    )\n                )\n            elif self.verbose == 2:\n                print(\n                    \"Epoch {}\/{}: loss={:.6f}\".format(\n                        epoch + 1, self.epochs, np.mean(training_loss)\n                    )\n                )\n\n    def fit(self, X, y=None):\n        \"\"\"Fit detector. y is ignored in unsupervised methods.\n        Parameters\n        ----------\n        X : numpy array of shape (n_samples, n_features)\n            The input samples.\n        y : Ignored\n            Not used, present for API consistency by convention.\n        Returns\n        -------\n        self : object\n            Fitted estimator.\n        \"\"\"\n        # validate inputs X and y (optional)\n        X = check_array(X)\n        self._set_n_classes(y)\n\n        # Verify and construct the hidden units\n        n_features = X.shape[1]\n\n        # make dataset and dataloader\n        # conduct standardization if needed\n        if self.preprocessing:\n            self._mean, self._std = np.mean(X, axis=0), np.std(X, axis=0)\n            dataset = PyODDataset(inputs=X, mean=self._mean, std=self._std)\n        else:\n            dataset = PyODDataset(inputs=X)\n\n        train_size = int(len(dataset) * (1.0 - self.validation_size))\n        val_size = len(dataset) - train_size\n        train_dataset, val_dataset = torch.utils.data.random_split(\n            dataset, [train_size, val_size]\n        ,generator=torch.Generator().manual_seed(42))\n        train_loader = torch.utils.data.DataLoader(\n            train_dataset, batch_size=self.batch_size, shuffle=True\n        )\n        val_loader = torch.utils.data.DataLoader(\n            val_dataset, batch_size=self.batch_size, shuffle=False\n        )\n        # Initialize Deep SVDD\n        self._svdd_net = DeepSVDD_net(\n            n_features=n_features,\n            output_dim=self.output_dim,\n            hidden_neurons=self.hidden_neurons,\n            dropout_rate=self.dropout_rate,\n            batch_norm=self.batch_norm,\n            hidden_activation=self.hidden_activation,\n            output_activation=self.output_activation,\n        )\n        self._svdd_net = self._svdd_net.to(self.device)\n\n        # pre-training using autoencoder\n        if self.pretraining is True:\n\n            # initialize autoencoder\n            self._ae_net = AutoEncoder(\n                n_features=n_features,\n                output_dim=self.output_dim,\n                hidden_neurons=self.hidden_neurons,\n                batch_norm=self.batch_norm,\n                hidden_activation=self.hidden_activation,\n                output_activation=self.output_activation,\n            )\n            self._ae_net = self._ae_net.to(self.device)\n\n            # perform training\n            self._train_AutoEncoder(train_loader)\n\n            # copy weights from AE to Deep SVDD\n            self._init_network_weights_from_pretraining()\n\n        # perform training of Deep SVDD\n        self._train_DeepSVDD(train_loader, val_loader)\n\n        self.decision_scores_ = self.decision_function(X)\n        self._process_decision_scores()\n\n        return self\n\n    def decision_function(self, X):\n        \"\"\"Predict raw anomaly score of X using the fitted detector.\n        The anomaly score of an input sample is computed based on different\n        detector algorithms. For consistency, outliers are assigned with\n        larger anomaly scores.\n        Parameters\n        ----------\n        X : numpy array of shape (n_samples, n_features)\n            Sparse matrices are accepted only\n            if they are supported by the base estimator.\n        Returns\n        -------\n        outlier_scores : numpy array of shape (n_samples,)\n            The outlier score of the input samples.\n        \"\"\"\n        check_is_fitted(self, [\"_svdd_net\"])\n        X = check_array(X)\n\n        if self.preprocessing:\n            # self._mean, self._std = np.mean(X, axis=0), np.std(X, axis=0)\n            valid_set = PyODDataset(inputs=X, mean=self._mean, std=self._std)\n        else:\n            valid_set = PyODDataset(inputs=X)\n\n        valid_loader = torch.utils.data.DataLoader(\n            valid_set,\n            batch_size=self.batch_size,\n            shuffle=False,\n            drop_last=False,\n        )\n\n        # enable the evaluation mode\n        self._svdd_net.eval()\n\n        outlier_scores = []\n        with torch.no_grad():\n            for data, _ in valid_loader:\n                inputs = data.to(self.device).float()\n                embed = self._svdd_net(inputs)\n                dist = torch.sum((embed - self.c) ** 2, dim=1)\n\n                score = dist.to(\"cpu\").detach().numpy().copy()\n                outlier_scores.append(score)\n\n        outlier_scores = np.concatenate(outlier_scores)\n        return outlier_scores","a73b0bda":"# librosa\u3067.wav\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u7279\u5fb4\u62bd\u51fa\u3057\u307e\u3059\u3002\nn_features = 20\n\nfeatures = np.zeros((len(df), n_features*4))\nfor i in tqdm(range(len(df))):\n    filepath = df.loc[i, 'filepath']\n    st_time = df.loc[i, 'st_time']\n    \n    y, sr = librosa.load(filepath, offset=st_time, duration=0.2)\n    y = (y-y.min())\/(y.max()-y.min()) # \u30b5\u30f3\u30d7\u30eb\u3054\u3068\u306e\u6b63\u898f\u5316\n    mfcc = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=20)\n    ceps = mfcc.mean(axis=1)\n    ceps_std = mfcc.std(axis=1)\n    ceps_max = mfcc.max(axis=1)\n    ceps_min = mfcc.min(axis=1)\n    \n    # \u8907\u6570\u306e\u30ed\u30fc\u30ea\u30f3\u30b0\u30a6\u30a3\u30f3\u30c9\u30a6\u3067\u305d\u308c\u305e\u308c20\u6b21\u5143\u306eMFCC\u3092\u5f97\u3089\u308c\u308b\u306e\u3067\u3001\u305d\u306e\u5e73\u5747\u3092\u3068\u308b\u3002\n    features[i] = np.concatenate([ceps,ceps_std,ceps_max,ceps_min])","fc948000":"def outlier_scoring(train_data, pred_data, model_type, contamination = 0.1):\n    if model_type == 'lof':\n        model = LocalOutlierFactor(novelty=True, n_neighbors=15) # \u3053\u3053\u3067\u306fk-\u8fd1\u508d\u6cd5\u306e\u6d41\u308c\u3092\u304f\u3080LocalOutlierFactor\u3092\u7528\u3044\u307e\u3059\n    elif model_type == 'iforest':\n        model = IsolationForest(random_state=42) \n    elif model_type == 'oc-svm':\n        model = OneClassSVM(gamma='auto')\n    elif model_type =='deep-svdd':\n        model = DeepSVDD(hidden_neurons=[128], output_dim=128, batch_size=128, contamination=contamination, pretraining=True, epochs=200)\n    \n    if model_type != 'deep-svdd':        \n        model.fit(train_data) # \u6b63\u5e38\u30c7\u30fc\u30bf\u306e\u307f\u3092\u7528\u3044\u3066\u5b66\u7fd2\u3057\u307e\u3059\n        pred = model.score_samples(pred_data)\n        # \u5024\u304c\u5c0f\u3055\u3044\u307b\u3069\u7570\u5e38\u5ea6\u304c\u9ad8\u3044\u306e\u3067\u3001\u7b26\u53f7\u3092\u3072\u3063\u304f\u308a\u8fd4\u3057\u30660\u304b\u30891\u306b\u304a\u3055\u3081\u308b\n        scaler = MinMaxScaler()\n        pred = scaler.fit_transform(-pred.reshape(-1,1))\n    else:       \n        model.fit(train_data)\n        pred = model.decision_function(pred_data)\n        scaler = MinMaxScaler()\n        pred = scaler.fit_transform(pred.reshape(-1,1))\n    return pred","8495dc43":"# \u5f8c\u3005\u306e\u51e6\u7406\u306e\u305f\u3081\u306b\u305d\u308c\u305e\u308c\u306e\u6761\u4ef6\u306b\u5408\u81f4\u3059\u308bid\u3092\u53d6\u5f97\u3057\u3066\u304a\u304f\nnorm_idx = list(df[df['Target']==0].index)\nanorm_idx = list(df[df['Target']==1].index)\n\ntr_idx = norm_idx[:int(len(norm_idx)\/2)]\nval_idx = norm_idx[int(len(norm_idx)\/2):] + anorm_idx","2bba1e8e":"tr = features[tr_idx]\nval = features[val_idx]","4d81335b":"# model\u3054\u3068\u6bd4\u8f03\nfor model_type in ['lof', 'iforest', 'oc-svm', 'deep-svdd']:\n    df_valid = df.copy()\n    df_valid.loc[val_idx, 'pred'] = outlier_scoring(tr, val, model_type)\n    df_valid = df_valid.dropna(subset=['Target', 'pred'])\n    score = roc_auc_score(df_valid['Target'], df_valid['pred'])\n    print(model_type, score)","7dcc538c":"# deep-svdd\u306e\uff97\uff9d\uff80\uff9e\uff91\u6027\u3092\u691c\u8a3c\nfor i in range(5):\n    model_type ='deep-svdd'\n    df_valid = df.copy()\n    df_valid.loc[val_idx, 'pred'] = outlier_scoring(tr, val, model_type)\n    df_valid = df_valid.dropna(subset=['Target', 'pred'])\n    score = roc_auc_score(df_valid['Target'], df_valid['pred'])\n    print(model_type, score)","d6eca0eb":"# model\u3067blending\ndf_valid = df.copy()\ndf_valid.loc[val_idx, 'pred'] = outlier_scoring(tr, val, 'deep-svdd')\ndf_valid = df_valid.dropna(subset=['Target', 'pred'])\nscore = roc_auc_score(df_valid['Target'], df_valid['pred'])\nprint(score)","b16c09d3":"tr_idx = norm_idx\npl_idx = list(df[df['Target'].isnull()].index) # \u30e9\u30d9\u30eb\u306a\u3057\u30c7\u30fc\u30bf\u306eindex","b7a0fcee":"tr = features[tr_idx]\npl = features[pl_idx]","02d3e178":"df_pl = df.copy()\ndf_pl.loc[pl_idx, 'Target'] = outlier_scoring(tr, pl, 'deep-svdd')","26da04ad":"df_pl['Target'].hist()","1d10c060":"# \u7570\u5e38\u30b9\u30b3\u30a2\u304c\u95be\u5024\u4ee5\u4e0b\u306e\u30c7\u30fc\u30bf\u3092\u6b63\u5e38\u3078\u306e\u8ffd\u52a0\u30c7\u30fc\u30bf\u3068\u3057\u3066index\u3092\u62bd\u51fa\nth = 0.005\nadd_idx = df_pl[df_pl['Target'] <= th].index\nlen(add_idx)","02b42e68":"len(tr_idx)","4f9d40dd":"len(add_idx)","6b84d3dd":"# pseudo_labeling\u3067\u62bd\u51fa\u3057\u305f\u30c7\u30fc\u30bf\u3092\u5b66\u7fd2\u30c7\u30fc\u30bf\u306b\u8ffd\u52a0\ntr_idx.extend(add_idx)\npred_idx = list(df[df['\u30d5\u30a1\u30a4\u30eb'].str.contains('test')].index)","7e2a25a7":"tr = features[tr_idx]\npred = features[pred_idx]","11389240":"df_pred = df.copy()\ndf_pred.loc[pred_idx, 'Target'] = outlier_scoring(tr, pred, 'deep-svdd')\ndf_pred = df_pred[df_pred['\u30d5\u30a1\u30a4\u30eb'].str.contains('test')]","eb79294a":"df_pred['Target'].hist()","26d6ba91":"# 1\u6253\u97f3\u3054\u3068\u306e\u7d50\u679c\u306e\u5e73\u5747\u53d6\u3063\u3066\u30d5\u30a1\u30a4\u30eb\u5358\u4f4d\u306e\u4e88\u6e2c\u5024\u3092\u7b97\u51fa\u3059\u308b\nmean_pred = df_pred.groupby('ID')['Target'].mean().reset_index()","67e1485a":"mean_pred['Target'].hist()\nprint(mean_pred['Target'].max())","b77c92c5":"# sample_sub\u306b\u7d50\u679c\u3092merge\nsub = pd.read_csv('..\/input\/hah-data-science-challenge\/sample_submission.csv', usecols=['ID'])\nsub = sub.merge(mean_pred, on='ID', how='left')","2d59fa39":"sub","4a722dde":"# \u3059\u3079\u3066\u7121\u97f3\u3060\u3063\u305f\u5834\u5408\u3001\u4e88\u6e2c\u5024\u304c\u306a\u3044\u306e\u3067\u5e73\u5747\u5024\u3067\u57cb\u3081\u308b\nsub['Target'] = sub['Target'].fillna(sub['Target'].mean())\nsub = sub.set_index('ID')\nsub.to_csv('submission.csv')\nsub","1f11b821":"sub['Target'].hist()","4955d26e":"# pseudolabeling","801940b4":"\u30e9\u30d9\u30eb\u306a\u3057\u30c7\u30fc\u30bf(train & test)\u306b\u5bfe\u3057\u3066\u4e88\u6e2c\u5024\u3092\u7b97\u51fa\u3057\u3066\u3001\u78ba\u4fe1\u5ea6\u9ad8\u304f\u6b63\u5e38\u3068\u4e88\u6e2c\u3057\u3066\u3044\u308b\u3082\u306e\u3092\u6b63\u5e38\u30c7\u30fc\u30bf\u306b\u8ffd\u52a0\u3059\u308b","1cfbb2ec":"# \u7279\u5fb4\u91cf\u751f\u6210","4be4ed9e":"# \u30e2\u30c7\u30eb\u4f5c\u6210\u30fb\u8a55\u4fa1","a5315e59":"# utils","013d1dc2":"# sub","73d27275":"exp007\u306bpseudolabeling\u9069\u7528\uff08\u5b9f\u88c5\u306f\u3042\u307e\u308a\u81ea\u4fe1\u306a\u3057\uff09  \ndeep_svd\u306e\u30b7\u30f3\u30b0\u30eb\u306b","b23c9329":"# Deep SVDD\u30e2\u30c7\u30eb\u5b9a\u7fa9"}}