{"cell_type":{"898b8ce7":"code","65c517bc":"markdown"},"source":{"898b8ce7":"import numpy as np\nimport os\nimport pandas as pd\nimport json\n\nif os.path.exists('\/kaggle\/input'):\n    import sys\n    sys.path.append('\/kaggle\/input\/arclib4\/')\n\nfrom arclib.dsl import *\nfrom arclib.util import evaluate_predict_func, test_path, get_string, data_path\nfrom arclib.dsl import Task, unique_arrays\nfrom arclib.check import  check_output_color_from_input\n\n\ndef check_output_in_candidates(output, candidates):\n    output_is_candidate = False\n\n    for candidate in candidates:\n        if output.shape == candidate.shape:\n            if (output == candidate).all():\n                output_is_candidate = True\n    return output_is_candidate\n\n\ndef predict_part(task, get_candidates, train_object_maps=None, train_bg_colors=None):\n\n    part_task = True\n    for i, (input, output) in enumerate(task.pairs):\n        input = np.array(input)\n        output = np.array(output)\n\n        candidates = get_candidates(input, object_maps=train_object_maps[i], bg_color=train_bg_colors[i])\n\n        if candidates:\n            if check_output_in_candidates(output, candidates) == False:\n                part_task = False\n                break\n        else:\n            part_task = False\n            break\n\n    all_input_predictions = []\n    if part_task:\n        for input in task.test_inputs:\n            test_candidates = get_candidates(input)\n            predictions = test_candidates #[:3]\n            predictions = unique_arrays(predictions)\n            predictions = sorted(predictions, key= lambda x: x.shape[0] * x.shape[1], reverse=True)\n            all_input_predictions.append(predictions)\n\n    else:\n        all_input_predictions = []\n    return all_input_predictions\n\n\ndef get_cropped_object(array, object_map, bg_color=None):\n    axis0_min, axis0_max, axis1_min, axis1_max = get_object_map_min_max(object_map)\n    return array[axis0_min: axis0_max + 1, axis1_min: axis1_max + 1]\n\n\ndef keep_one_object(array, object_map, bg_color=None):\n    axis0_min, axis0_max, axis1_min, axis1_max = get_object_map_min_max(object_map)\n    if bg_color is None:\n        bg_color = detect_bg_(array)\n    output_ = np.full_like(array, bg_color)\n    output_[axis0_min: axis0_max + 1, axis1_min: axis1_max + 1] = array[axis0_min: axis0_max + 1, axis1_min: axis1_max + 1]\n    return output_\n\n\ndef get_cropped_objects(array, get_object_maps=None, object_maps=None, augment=None, bg_color=None):\n    if object_maps is None:\n        object_maps = get_object_maps(array)\n    objects = [augment(get_cropped_object(array, object_map)) for object_map in object_maps if np.count_nonzero(object_map) > 0]\n    return objects\n\n\ndef get_inputs_with_one_object(array, get_object_maps=None, object_maps=None, augment=None, bg_color=None):\n    if object_maps is None:\n        object_maps = get_object_maps(array)\n    objects = [augment(keep_one_object(array, object_map, bg_color=bg_color)) for object_map in object_maps if np.count_nonzero(object_map) > 0]\n    return objects\n\n\nget_object_map_funcs = [ get_objects_by_connectivity_, partial(get_objects_by_connectivity_, touch='corner'),\n                    get_objects_by_color_and_connectivity_, partial(get_objects_by_color_and_connectivity_, touch='corner'), get_objects_by_color_,\n                    get_objects_rectangles, partial(get_objects_rectangles, direction='horisontal'), get_objects_rectangles_without_noise, get_objects_rectangles_without_noise_without_padding]\n\ndef predict_part_types(task):\n\n    predictions = []\n\n    if check_output_color_from_input(task):\n\n        bg_colors = [detect_bg_(input_) for input_ in task.inputs]\n        for i, get_object_maps in enumerate(get_object_map_funcs):\n\n            object_maps_list = [get_object_maps(input_, bg_color=bg_color) for input_, bg_color in zip(task.inputs, bg_colors)]\n            for get_object_func in (get_cropped_objects, get_inputs_with_one_object):\n                for augment in simple_output_process_options:\n                    get_candidates = partial(get_object_func, get_object_maps=get_object_maps, augment=augment)\n                    predictions = predict_part(task, get_candidates=get_candidates, train_object_maps=object_maps_list, train_bg_colors=bg_colors)\n                    if predictions:\n                        break\n                if predictions:\n                    break\n            if predictions:\n                break\n\n\n    return predictions\n\n\ndef submit(predict):\n    submission = pd.read_csv(data_path \/ 'sample_submission.csv', index_col='output_id')\n    submission['output'] = ''\n    test_fns = sorted(os.listdir(test_path))\n    count = 0\n    for fn in test_fns:\n        fp = test_path \/ fn\n        with open(fp, 'r') as f:\n            task = Task(json.load(f))\n            all_input_preds = predict(task)\n            if all_input_preds:\n                print(fn)\n                count += 1\n\n            for i, preds in enumerate(all_input_preds):\n                output_id = str(fn.split('.')[-2]) + '_' + str(i)\n                string_preds = [get_string(pred) for pred in preds[:3]]\n                pred = ' '.join(string_preds)\n                submission.loc[output_id, 'output'] = pred\n\n    print(count)\n    submission.to_csv('submission.csv')\n\n\ndef main():\n    #evaluate_predict_func(predict_part_types)\n    submit(predict_part_types)\n\n\nif __name__ == '__main__':\n    main()","65c517bc":"Part of 9th place solution.\nFull solution desctiption: https:\/\/www.kaggle.com\/c\/abstraction-and-reasoning-challenge\/discussion\/154319"}}