{"cell_type":{"008fc4c9":"code","bc34bf7d":"code","fdf629fd":"code","999e92b4":"code","285c0ec9":"code","be25919d":"code","167fa198":"code","622ef2d6":"code","ab59ed3e":"code","3ed944b0":"code","7c47e4f8":"code","8fd51b83":"code","064c5368":"code","ee3b11e0":"markdown","07837546":"markdown","22ff6604":"markdown","e68b0a4e":"markdown","652626eb":"markdown","dc15b355":"markdown","c8f6889c":"markdown","ccdea608":"markdown"},"source":{"008fc4c9":"from keras import layers\nfrom keras.models import Model\nimport numpy as np","bc34bf7d":"import matplotlib.pyplot as plt\n%matplotlib inline","fdf629fd":"ibsr_data = np.load('..\/input\/IBSR_v2_resampled_cropped_8bit_64x64.npz')\nimages = ibsr_data['input']\nprint('Dimensions and extents after loading:', images.shape)","999e92b4":"# Reduce dimensions to (NumberOfDatasets, Height, Width)\ndataset = np.squeeze(images, axis=1);\nprint('Dimensions after dimensionality reduction:', dataset.shape) # should be (2716, 64, 64)","285c0ec9":"# Divide dataset into train and test (order is already random)\nx_train = dataset[:2300,:,:]\nx_test  = dataset[2300:,:,:]\n\n# Normalizing images to range [0...1]\nx_train = x_train.astype('float32') \/ 255.\nx_test = x_test.astype('float32') \/ 255.","be25919d":"# Flattening images into 64*64 = 4096 vector\nx_train = x_train.reshape((len(x_train), np.prod(x_train.shape[1:])))\nx_test = x_test.reshape((len(x_test), np.prod(x_test.shape[1:])))\nprint('Flattened dimensions of training data:', x_train.shape)\nprint('Flattened dimensions of testing data: ', x_test.shape)","167fa198":"# mapping input vector with factor 128, (32*128 = 4096)\nencode_dimension = 128\n\n# Input placeholder\ninput_img = layers.Input(shape=(4096,))\n\n# Encoding of the input\nencoded_1 = layers.Dense(encode_dimension, activation='relu')(input_img)\nencoded_2 = layers.Dense(encode_dimension, activation='relu')(encoded_1)\n\n# Decoding\/reconstruction of the input\ndecoded_1   = layers.Dense(4096, activation='sigmoid')(encoded_2)\ndecoded_2   = layers.Dense(4096, activation='sigmoid')(decoded_1)\n\n# This maps the input to its reconstruction\n# The aim is to fully recover the input image\nautoencoder = Model(input_img, decoded_2)","622ef2d6":"autoencoder.summary()","ab59ed3e":"# Set the optimizer (Adam is a popular choice), and the loss function\nautoencoder.compile(optimizer = 'adam', loss='mean_squared_error')","3ed944b0":"# Potentially change num_epochs or batch_size\nnum_epochs = 25\nhistory = autoencoder.fit(\n    x_train, x_train,\n    epochs=num_epochs,\n    batch_size=16,\n    shuffle=True,\n    validation_data=(x_test, x_test))","7c47e4f8":"# Test the autoencoder using the model to predict unseen data\ndecoded_imgs = autoencoder.predict(x_test)","8fd51b83":"# Following code is for displaying of results\n\nn = 6 # number of images to display\nplt.figure(figsize=(12, 4))\nfor i in range(n):\n    # display image\n    ax = plt.subplot(2, n, i + 1)\n    ax.imshow(x_test[i].reshape(64, 64), cmap = 'gray')\n    ax.set_xticks(())\n    ax.set_yticks(())\n    ax.set_aspect(1.0)\n\n    # display reconstructed\n    ax = plt.subplot(2, n, i + 1 + n)\n    ax.imshow(decoded_imgs[i].reshape(64, 64), cmap = 'gray')\n    ax.set_xticks(())\n    ax.set_yticks(())\n    ax.set_aspect(1.0)\nplt.show()","064c5368":"plt.figure()\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.show()","ee3b11e0":"The following cell starts an external tool to download the example data set (this only needs to be done once):\n\n> The 20 normal MR brain data sets and their manual\n  segmentations were provided by the Center for Morphometric Analysis at\n  Massachusetts General Hospital and are available at\n  http:\/\/www.cma.mgh.harvard.edu\/ibsr\/.","07837546":"## Train the autoencoder","22ff6604":"## Creating the model architecture","e68b0a4e":"We use Matplotlib for displaying results and images:","652626eb":"The following lines import required functionality from the [\"keras\"](https:\/\/keras.io) and [\"numpy\"](http:\/\/www.numpy.org) packages:","dc15b355":"Load example data:","c8f6889c":"You may read up on further options for the loss (like `mean_absolute_error` or `binary_crossentropy`) at https:\/\/keras.io\/losses\/, and on other optimizers (such as `sgd` or `adadelta`) at https:\/\/keras.io\/optimizers\/.","ccdea608":"# Machine Learning Tutorial \n## ESMRMB Lecture, Berlin September 2018\n### Teodora Chitiboi, Sandy Engelhardt, Hans Meine \n\nThis tutorial provides an introduction into Dense Autoencoders for reconstruction of MRI data."}}