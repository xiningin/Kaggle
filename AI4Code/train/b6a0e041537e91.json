{"cell_type":{"87d3dfa9":"code","f4327664":"code","9974b56a":"code","1c0ce0da":"code","b6baa607":"code","4ada836a":"code","d09f4230":"code","6bf6c379":"code","432c5233":"code","5e91467e":"code","2c5be680":"code","7010f13e":"code","a210249d":"code","562bfecc":"code","1c7054a3":"code","46157e16":"code","206a8a2e":"code","fc035b61":"code","8394c24e":"code","ead3432f":"code","81091337":"code","572b35c3":"code","b5784184":"code","ea317d06":"code","8809c549":"code","e2b6662e":"code","7cd62ed2":"code","b81a19d6":"code","6235c93b":"code","3e5669ab":"code","b8610f22":"code","2f2257a2":"code","b4d811bd":"code","4dbc331c":"markdown","11c91d69":"markdown","387f1d67":"markdown"},"source":{"87d3dfa9":"import numpy as np\nimport pandas as pd \nimport os\nprint(os.listdir(\"..\/input\"))","f4327664":"breeds = pd.read_csv('..\/input\/breed_labels.csv')\ncolors = pd.read_csv('..\/input\/color_labels.csv')\nstates = pd.read_csv('..\/input\/state_labels.csv')\ntrain = pd.read_csv('..\/input\/train\/train.csv')\ntest = pd.read_csv('..\/input\/test\/test.csv')\n\ntrain.head()","9974b56a":"import matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nfrom PIL import Image\nimport gc","1c0ce0da":"print(\"train.csv shape is {}\".format(train.shape))\nprint(\"test.csv shape is {}\".format(test.shape))","b6baa607":"fig, ax = plt.subplots(figsize=(6, 5))\nax.set_title(\"AdoptionSpeed count in train\")\nsns.countplot(x=\"AdoptionSpeed\", data=train, ax=ax)","4ada836a":"sns.distplot(train['Age'], bins = 100, kde=False)","d09f4230":"train.Age.unique()","6bf6c379":"#\u0423\u0434\u0430\u043b\u044f\u044e \u0441\u0440\u0435\u0434\u043d\u0438\u0439 \u0432\u043e\u0437\u0440\u0430\u0441\u0442 \u0431\u043e\u043b\u044c\u0448\u0435 20 \u0438 \u0437\u0430\u043c\u0435\u043d\u044f\u044e \u0441\u0440\u0435\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\ntrain['Age'] = train['Age'].fillna( method='pad')\ntrain.loc[train['Age'] > 20, 'Age'] = train['Age'].mean()","432c5233":"sns.distplot(train['Age'], bins = 20, kde=False)","5e91467e":"breed_dict = dict(zip(breeds['BreedID'], breeds['BreedName']))","2c5be680":"animal_dict = {1: 'Dog', 2: 'Cat'}","7010f13e":"train.head()","a210249d":"import warnings\nwarnings.filterwarnings(\"ignore\", 'This pattern has match groups')\n\ndef make_features(train):\n    train['Named'] = (~train['Name'].isnull() | train['Name'].str.contains('(No | Puppies | Kitty | Puppy | Kitten)')).astype(int)\n    train['PureBreed'] = (train.Breed2==0 | ~train.Breed1.isin(breeds[breeds.BreedName.str.contains('Domestic' or 'Mixed')].BreedID.values)).astype(int)\n    train = train.drop('Breed2', axis=1)\n\n    train = train.select_dtypes(exclude=[object])\n    return train\n\ndealed_train = make_features(train)","562bfecc":"dealed_train['Type'] = dealed_train['Type'].map(animal_dict)\ndealed_train['Breed1_new'] = dealed_train['Breed1'].map(breed_dict)","1c7054a3":"#\u041f\u043e\u0447\u0435\u043c\u0443-\u0442\u043e \u043f\u043e\u0441\u043b\u0435 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 make_features \u0443 \u043c\u0435\u043d\u044f \u043f\u0440\u043e\u043f\u0430\u0434\u0430\u0435\u0442 PetID\n#\u041f\u043e\u044d\u0442\u043e\u043c\u0443 \u044f \u043f\u043e\u0439\u0434\u0443 \u0432\u043e\u0442 \u043d\u0430 \u0442\u0430\u043a\u0438\u0445 \u043a\u043e\u0441\u0442\u044b\u043b\u044f\u0445\ntrain_2 =  dealed_train.combine_first(train)\ntrain = train_2.drop('Breed1', axis=1)\ntrain = train.drop('Breed2', axis=1)\ntrain = train.drop('Named', axis=1)","46157e16":"#\u0414\u0435\u043b\u0430\u044e \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u044b\u0435 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0441 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0432\u044b\u0431\u043e\u0440\u043a\u043e\u0439\ndealed_test = make_features(test)\ndealed_test['Type'] = dealed_test['Type'].map(animal_dict)\ndealed_test['Breed1_new'] = dealed_test['Breed1'].map(breed_dict)\ntest_2 =  dealed_test.combine_first(test)\ntest = test_2.drop('Breed1', axis=1)\ntest = test.drop('Breed2', axis=1)\ntest = test.drop('Named', axis=1)","206a8a2e":"train_dogs = train[dealed_train['Type'] == 'Dog']\ntrain_cats = train[dealed_train['Type'] == 'Cat']","fc035b61":"plt.figure(figsize=(28, 12));\nsns.barplot(x='PhotoAmt', y='AdoptionSpeed', data=train)\nplt.title('What about photos?')","8394c24e":"#\u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0434\u043b\u044f \u043a\u043e\u0448\u0435\u043a \u0434\u0430\u0442\u0430\u0444\u0440\u0435\u0439\u043c\u044b \u0434\u043b\u044f \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0439 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 adoption \u0432 \u0440\u0430\u0437\u0440\u0435\u0437\u0430\u0445 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0430\u043b\u044c\u043d\u044b\u0445 \u0444\u0438\u0447\nms_train_cats = pd.DataFrame(train_cats.groupby([ 'AdoptionSpeed', 'MaturitySize'])['PetID'].count()).reset_index()\nfr_train_cats = pd.DataFrame(train_cats.groupby(['AdoptionSpeed', 'FurLength'])['PetID'].count()).reset_index()\nvc_train_cats = pd.DataFrame(train_cats.groupby(['AdoptionSpeed', 'Vaccinated'])['PetID'].count()).reset_index()\ndw_train_cats = pd.DataFrame(train_cats.groupby(['AdoptionSpeed', 'Dewormed'])['PetID'].count()).reset_index()\nst_train_cats = pd.DataFrame(train_cats.groupby(['AdoptionSpeed', 'Sterilized'])['PetID'].count()).reset_index()\nh_train_cats = pd.DataFrame(train_cats.groupby(['AdoptionSpeed', 'Health'])['PetID'].count()).reset_index()\nage_train_cats = pd.DataFrame(train_cats.groupby(['AdoptionSpeed', 'Age'])['PetID'].count()).reset_index()","ead3432f":"#\u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a\u043e\u043b\u043e\u043d\u043a\u0443 \u0432 \u0434\u0430\u0442\u0430\u0444\u0440\u0435\u0439\u043c\u044b \u0441 \u0440\u0430\u0437\u0440\u0435\u0437\u0430\u043c\u0438 \u0441 \u0434\u043e\u043b\u0435\u0439 \u043f\u0438\u0442\u043e\u043c\u0446\u0435\u0432 \u043e\u0442 \u043e\u0431\u0449\u0435\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0444\u0438\u0447\u0438\nms_train_cats['PetID_Share'] = ms_train_cats['PetID']\/14993\nfr_train_cats['PetID_Share'] = ms_train_cats['PetID']\/14993\nvc_train_cats['PetID_Share'] = ms_train_cats['PetID']\/14993\ndw_train_cats['PetID_Share'] = ms_train_cats['PetID']\/14993\nst_train_cats['PetID_Share'] = ms_train_cats['PetID']\/14993\nh_train_cats['PetID_Share'] = ms_train_cats['PetID']\/14993\nage_train_cats['PetID_Share'] = ms_train_cats['PetID']\/14993\n#\u0415\u0441\u043b\u0438 \u0447\u0435\u0441\u0442\u043d\u043e, \u043d\u0435 \u043f\u043e\u043d\u0438\u043c\u0430\u044e, \u0434\u043b\u044f \u0447\u0435\u0433\u043e \u0431\u044b\u043b\u0438 \u0441\u043e\u0432\u0435\u0440\u0448\u0435\u043d\u044b \u044d\u0442\u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0438 \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u044e \u044d\u0442\u043e \u043f\u043e\u0442\u043e\u043c \u0443\u0434\u0430\u043b\u0438\u0442\u044c ))","81091337":"#\u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u0432 \u043f\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0443 \u043f\u0438\u0442\u043e\u043c\u0446\u0435\u0432\ntrain_cats.groupby(['MaturitySize'])['PetID'].count()","572b35c3":"sns.distplot(train_cats['MaturitySize'])","b5784184":"#\u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u0432 \u043f\u0438\u0442\u043e\u043c\u0446\u0435\u0432 \u0432 \u0440\u0430\u0437\u0440\u0435\u0437\u0435 adoption \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438\ntrain_cats.groupby(['MaturitySize', 'AdoptionSpeed'])['PetID'].count()","ea317d06":"# \u0425\u0438\u0442\u043c\u0430\u043f \u043f\u043e \u0440\u0430\u0437\u043c\u0435\u0440\u0443 \u043f\u0438\u0442\u043e\u043c\u0446\u0430\npv_ms_train_cats = ms_train_cats.pivot_table(values='PetID_Share', index='MaturitySize',   columns='AdoptionSpeed')\nsns.heatmap(pv_ms_train_cats, cmap='inferno_r')","8809c549":"# \u0423\u0442\u0430\u0449\u0438\u043b\u0430 \u0443 \u043a\u0430\u043a\u0438\u0445-\u0442\u043e \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u0438\u043a\u043e\u0432 https:\/\/www.kaggle.com\/tgibbons\/student-project-looking-for-feedback\nencodedColor1 = pd.get_dummies( train['Color1'], prefix=\"color\" )\n\n# Add the new dummy variables to the pet_train data frame\ntrain = pd.concat([train, encodedColor1], axis='columns')\n# Do the same thing to the submission data\nencodedColor2 = pd.get_dummies( test['Color1'], prefix=\"color\" )\ntest = pd.concat([test, encodedColor2], axis='columns')\n\n# print out the current data\nprint (\"Size of pet_train = \", train.shape)\nprint (\"Size of pet_submit = \", test.shape)\ntrain.head(5)","e2b6662e":"cat_columns = ['Breed1_new','FurLength','Dewormed']\n\n# Create the dummy variables for the columns listed above\ndfTemp = pd.get_dummies( train[cat_columns], columns=cat_columns )\ntrain = pd.concat([train, dfTemp], axis='columns')\n\n# Do the same to the submission data\ndfSummit = pd.get_dummies( test[cat_columns], columns=cat_columns )\ntest = pd.concat([test, dfSummit], axis='columns')\n# Get missing columns in the submission data\nmissing_cols = set( train.columns ) - set( test.columns )\n# Add a missing column to the submission set with default value equal to 0\nfor c in missing_cols:\n    test[c] = 0\n# Ensure the order of column in the test set is in the same order than in train set\ntest = test[train.columns]\n\n\n\n\n# print out the current data\nprint (\"Size of pet_train = \", train.shape)\nprint (\"Size of pet_submit = \", test.shape)\ntrain.head(5)","7cd62ed2":"import cv2\nimport pandas as pd\nimport numpy as np\nimport os\nfrom tqdm import tqdm, tqdm_notebook\nfrom keras.applications.densenet import preprocess_input, DenseNet121\n\nimg_size = 256\nbatch_size = 16","b81a19d6":"pet_ids = train['PetID'].values\nn_batches = len(pet_ids) \/\/ batch_size + 1","6235c93b":"# The following functions and the rest solution have been taken from Valentina's kernel\n# Thank you <3\ndef confusion_matrix(rater_a, rater_b, min_rating=None, max_rating=None):\n    \"\"\"\n    Returns the confusion matrix between rater's ratings\n    \"\"\"\n    assert(len(rater_a) == len(rater_b))\n    if min_rating is None:\n        min_rating = min(rater_a + rater_b)\n    if max_rating is None:\n        max_rating = max(rater_a + rater_b)\n    num_ratings = int(max_rating - min_rating + 1)\n    conf_mat = [[0 for i in range(num_ratings)]\n                for j in range(num_ratings)]\n    for a, b in zip(rater_a, rater_b):\n        conf_mat[a - min_rating][b - min_rating] += 1\n    return conf_mat\n\n\ndef histogram(ratings, min_rating=None, max_rating=None):\n    \"\"\"\n    Returns the counts of each type of rating that a rater made\n    \"\"\"\n    if min_rating is None:\n        min_rating = min(ratings)\n    if max_rating is None:\n        max_rating = max(ratings)\n    num_ratings = int(max_rating - min_rating + 1)\n    hist_ratings = [0 for x in range(num_ratings)]\n    for r in ratings:\n        hist_ratings[r - min_rating] += 1\n    return hist_ratings\n\n\ndef quadratic_weighted_kappa(y, y_pred):\n    \"\"\"\n    Calculates the quadratic weighted kappa\n    axquadratic_weighted_kappa calculates the quadratic weighted kappa\n    value, which is a measure of inter-rater agreement between two raters\n    that provide discrete numeric ratings.  Potential values range from -1\n    (representing complete disagreement) to 1 (representing complete\n    agreement).  A kappa value of 0 is expected if all agreement is due to\n    chance.\n    quadratic_weighted_kappa(rater_a, rater_b), where rater_a and rater_b\n    each correspond to a list of integer ratings.  These lists must have the\n    same length.\n    The ratings should be integers, and it is assumed that they contain\n    the complete range of possible ratings.\n    quadratic_weighted_kappa(X, min_rating, max_rating), where min_rating\n    is the minimum possible rating, and max_rating is the maximum possible\n    rating\n    \"\"\"\n    rater_a = y\n    rater_b = y_pred\n    min_rating=None\n    max_rating=None\n    rater_a = np.array(rater_a, dtype=int)\n    rater_b = np.array(rater_b, dtype=int)\n    assert(len(rater_a) == len(rater_b))\n    if min_rating is None:\n        min_rating = min(min(rater_a), min(rater_b))\n    if max_rating is None:\n        max_rating = max(max(rater_a), max(rater_b))\n    conf_mat = confusion_matrix(rater_a, rater_b,\n                                min_rating, max_rating)\n    num_ratings = len(conf_mat)\n    num_scored_items = float(len(rater_a))\n\n    hist_rater_a = histogram(rater_a, min_rating, max_rating)\n    hist_rater_b = histogram(rater_b, min_rating, max_rating)\n\n    numerator = 0.0\n    denominator = 0.0\n\n    for i in range(num_ratings):\n        for j in range(num_ratings):\n            expected_count = (hist_rater_a[i] * hist_rater_b[j]\n                              \/ num_scored_items)\n            d = pow(i - j, 2.0) \/ pow(num_ratings - 1, 2.0)\n            numerator += d * conf_mat[i][j] \/ num_scored_items\n            denominator += d * expected_count \/ num_scored_items\n\n    return (1.0 - numerator \/ denominator)","3e5669ab":"# \u041a\u0430\u0436\u0435\u0442\u0441\u044f, \u044d\u0442\u043e \u0430\u0434\u0441\u043a\u0438\u0439 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u044d\u0442\u043e\u0439 \u0441\u0430\u043c\u043e\u0439 \u043a\u0430\u043f\u043f\u044b\n# \u041d\u043e \u044f \u043d\u0438 \u0432 \u0447\u0435\u043c \u043d\u0435 \u0443\u0432\u0435\u0440\u0435\u043d\u0430\nclass OptimizedRounder(object):\n    def __init__(self):\n        self.coef_ = 0\n\n    def _kappa_loss(self, coef, X, y):\n        X_p = np.copy(X)\n        for i, pred in enumerate(X_p):\n            if pred < coef[0]:\n                X_p[i] = 0\n            elif pred >= coef[0] and pred < coef[1]:\n                X_p[i] = 1\n            elif pred >= coef[1] and pred < coef[2]:\n                X_p[i] = 2\n            elif pred >= coef[2] and pred < coef[3]:\n                X_p[i] = 3\n            else:\n                X_p[i] = 4\n\n        ll = quadratic_weighted_kappa(y, X_p)\n        return -ll\n\n    def fit(self, X, y):\n        loss_partial = partial(self._kappa_loss, X=X, y=y)\n        initial_coef = [0.5, 1.5, 2.5, 3.5]\n        self.coef_ = sp.optimize.minimize(loss_partial, initial_coef, method='nelder-mead')\n\n    def predict(self, X, coef):\n        X_p = np.copy(X)\n        for i, pred in enumerate(X_p):\n            if pred < coef[0]:\n                X_p[i] = 0\n            elif pred >= coef[0] and pred < coef[1]:\n                X_p[i] = 1\n            elif pred >= coef[1] and pred < coef[2]:\n                X_p[i] = 2\n            elif pred >= coef[2] and pred < coef[3]:\n                X_p[i] = 3\n            else:\n                X_p[i] = 4\n        return X_p\n\n    def coefficients(self):\n        return self.coef_['x']\n    \ndef rmse(actual, predicted):\n    return sqrt(mean_squared_error(actual, predicted))","b8610f22":"#\u0427\u0442\u043e \u0437\u0434\u0435\u0441\u044c \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442?\n#\u041c\u043d\u0435 \u0441\u0442\u0440\u0430\u0448\u043d\u043e\nfrom keras.models import Model\nfrom keras.layers import GlobalAveragePooling2D, Input, Lambda, AveragePooling1D\nimport keras.backend as K\nfrom keras.applications.densenet import DenseNet121\ninp = Input((256,256,3))\nbackbone = DenseNet121(input_tensor = inp, \n                       weights=None, #\u041c\u043d\u0435 \u043d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0432\u0435\u0441\u044b, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0431\u044b\u043b\u0438 \u0443 \u0412\u0430\u043b\u0435\u043d\u0442\u0438\u043d\u044b \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043f\u0443\u0441\u043a\u0430\u0439 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0441\u0430\u043c \u0443\u0447\u0438\u0442\u0441\u044f\n                       include_top = False)\nx = backbone.output\nx = GlobalAveragePooling2D()(x)\nx = Lambda(lambda x: K.expand_dims(x,axis = -1))(x)\nx = AveragePooling1D(4)(x)\nout = Lambda(lambda x: x[:,:,0])(x)\n\nm = Model(inp,out)\n","2f2257a2":"#\u042d\u0442\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u0440\u0435\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0438\u043a\u0438?? \u0421\u0435\u0440\u044c\u0435\u0437\u043d\u043e?\n#\u041d\u043e \u0437\u0430\u0447\u0435\u043c?\ndef resize_to_square(im):\n    old_size = im.shape[:2] # old_size is in (height, width) format\n    ratio = float(img_size)\/max(old_size)\n    new_size = tuple([int(x*ratio) for x in old_size])\n    # new_size should be in (width, height) format\n    im = cv2.resize(im, (new_size[1], new_size[0]))\n    delta_w = img_size - new_size[1]\n    delta_h = img_size - new_size[0]\n    top, bottom = delta_h\/\/2, delta_h-(delta_h\/\/2)\n    left, right = delta_w\/\/2, delta_w-(delta_w\/\/2)\n    color = [0, 0, 0]\n    new_im = cv2.copyMakeBorder(im, top, bottom, left, right, cv2.BORDER_CONSTANT,value=color)\n    return new_im\n\ndef load_image(path, pet_id):\n    image = cv2.imread(f'{path}{pet_id}-1.jpg')\n    new_image = resize_to_square(image)\n    new_image = preprocess_input(new_image)\n    return new_image","b4d811bd":"features = {}\nfor b in tqdm_notebook(range(n_batches)):\n    start = b*batch_size\n    end = (b+1)*batch_size\n    batch_pets = pet_ids[start:end]\n    batch_images = np.zeros((len(batch_pets),img_size,img_size,3))\n    for i,pet_id in enumerate(batch_pets):\n        try:\n            batch_images[i] = load_image(\"..\/input\/train_images\/\", pet_id)\n        except:\n            pass\n    batch_preds = m.predict(batch_images)\n    for i,pet_id in enumerate(batch_pets):\n        features[pet_id] = batch_preds[i]\n#\u041a \u0441\u043e\u0436\u0430\u043b\u0435\u043d\u0438\u044e, \u043c\u043d\u0435 \u043d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0434\u0443\u0431\u043b\u0438 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0439, \u0442\u043a \u0443 \u043c\u0430\u043a\u0431\u0443\u043a\u043e\u0432 \u043a\u0430\u043a\u0430\u044f-\u0442\u043e \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430 \u0441 CUDA\n#\u0418\u043b\u0438 \u0443 \u043c\u0435\u043d\u044f \u043a\u0430\u043a\u0430\u044f-\u0442\u043e \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430 \u0441 CUDA\n#\u041f\u043e\u044d\u0442\u043e\u043c\u0443 \u0432\u0441\u0435 \u0431\u0443\u0434\u0435\u0442 \u0434\u043e\u043b\u0433\u043e \u0438 \u043c\u0443\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e","4dbc331c":"1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 'name' - \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e, \u0447\u0442\u043e \u0435\u0441\u043b\u0438 \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u0437\u043d\u0430\u043a\u0435 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u043e \"no name yet\" \u0437\u043d\u0430\u0447\u0438\u0442 \u0443 \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e \u0435\u0449\u0435 \u043d\u0435 \u0431\u044b\u043b\u043e \u0445\u043e\u0437\u044f\u0438\u043d\u0430, \u0435\u0441\u043b\u0438 \u0435\u0441\u0442\u044c \u0438\u043c\u044f, \u0442\u043e \u043e\u0447\u0435\u0432\u0438\u0434\u043d\u043e \u0443 \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e \u0431\u044b\u043b \u0445\u043e\u0437\u044f\u0438\u043d\n1. 'Age' - \u0432\u043e\u0437\u0440\u0430\u0441\u0442 (\u043f\u043e\u0440\u044f\u0434\u043a\u043e\u0432\u0430\u044f \u0444\u0438\u0447\u0430)\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 'breed1' - \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e, \u044d\u0442\u043e \u043a\u043e\u0434 \u043f\u043e\u0440\u043e\u0434\u044b \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e (\u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0430\u043b\u044c\u043d\u0430\u044f)\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 'breed2' \u0443\u0442\u043e\u0447\u043d\u0435\u043d\u0438\u0435 \u043f\u043e\u0440\u043e\u0434\u044b (\u0435\u0441\u043b\u0438 \u043f\u043e\u0440\u043e\u0434\u0430 \u0441\u043c\u0435\u0448\u0435\u043d\u0430\u044f)\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 \"\u043f\u043e\u043b\" - \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u043f\u043e\u043b \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e\n1. \u041a\u043e\u043b\u043e\u043d\u043a\u0430 \u0446\u0432\u0435\u04421, \u0446\u0432\u0435\u04422, \u0446\u0432\u0435\u04423\n1. \u041a\u043e\u043b\u043e\u043d\u043a\u0430 MaturitySize - \u0440\u0430\u0437\u043c\u0435\u0440 \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e \u0432\u043e \u0432\u0437\u0440\u043e\u0441\u043b\u043e\u043c \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0435\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 FurLength - \u0434\u043b\u0438\u043d\u043d\u0430 \u0448\u0435\u0440\u0441\u0442\u0438 (1 \u043a\u043e\u0440\u043e\u0442\u043a\u0430\u044f,2 \u0441\u0440\u0435\u0434\u043d\u044f\u044f, 3 \u0434\u043b\u0438\u043d\u043d\u0430\u044f)\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 Vaccinated - \u0435\u0441\u0442\u044c \u043b\u0438 \u043f\u0440\u0438\u0432\u0438\u0432\u043a\u0438 1 \u0434\u0430, 2 \u043d\u0435\u0442, 3 \u043d\u0435 \u0443\u0432\u0435\u0440\u0435\u043d\u044b\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 Dewormed - \u043d\u0430\u043b\u0438\u0447\u0438\u0435 \u043f\u0430\u0440\u0430\u0437\u0438\u0442\u043e\u0432 1 \u0434\u0430, 2 \u043d\u0435\u0442, 3 \u043d\u0435 \u0443\u0432\u0435\u0440\u0435\u043d\u044b\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 Sterilized - \u0441\u0442\u0438\u0440\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e 1 \u0434\u0430, 2 \u043d\u0435\u0442, 3 \u043d\u0435 \u0443\u0432\u0435\u0440\u0435\u043d\u044b\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 Health - \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0437\u0434\u043e\u0440\u043e\u0432\u044c\u044f (1 \u0445\u043e\u0440\u043e\u0448\u0435\u0435, 2 \u043d\u0435 \u043e\u0447\u0435\u043d\u044c, 3 \u043f\u043b\u043e\u0445\u043e\u0435, 0 \u043d\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043e)\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 Quantity - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0436\u0438\u0432\u043e\u0442\u043d\u044b\u0445\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 fee - \u043f\u043b\u0430\u0442\u0430 \u0437\u0430 \u0443\u0441\u044b\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 State - \u0448\u0442\u0430\u0442 \u0432 \u043c\u0430\u043b\u0430\u0437\u0438\u0438\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 RescuerID - \u0430\u0439\u0434\u0438 \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 VideoAmt \u0432\u0438\u0434\u0435\u043e \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 PhotoAmt \u0444\u043e\u0442\u043e \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e\n1. \u043a\u043e\u043b\u043e\u043d\u043a\u0430 Description \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0433\u043e","11c91d69":"Encode some features","387f1d67":"\u0421\u043c\u043e\u0442\u0440\u0438\u043c, \u043a\u0430\u043a \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u044b \u043f\u043e\u0440\u044f\u0434\u043a\u043e\u0432\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435"}}