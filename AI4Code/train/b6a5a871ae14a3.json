{"cell_type":{"a0877294":"code","bafc6595":"code","b9d48765":"code","bf42f37a":"code","31a4e714":"code","8f78bcff":"code","b896e75c":"code","6b2ac4a3":"code","47c5c9e6":"code","deed9557":"code","0bdd435c":"code","c4464994":"code","a138e450":"code","090082c0":"code","e13404b2":"code","1c88e156":"code","24921010":"code","68cac518":"code","6c2c4fa0":"code","232f3656":"code","f0f9238c":"code","286b0d1d":"code","cdb44356":"code","b0988f9f":"code","80caa50c":"code","6def1e58":"code","cc9f5773":"code","91df0509":"code","fe86523e":"code","60bb55f6":"code","7e58f1f6":"code","62c0d6bf":"code","ad8d7370":"code","18e98527":"code","df612074":"code","05457660":"code","77aac839":"code","6cd0b445":"code","0029ddb5":"code","c03f5b8c":"markdown","deb2f26c":"markdown","5e1c2e64":"markdown","f39a1d59":"markdown","19277b5a":"markdown","66b01c36":"markdown","ded8e53d":"markdown","02650984":"markdown","7fe6e1a7":"markdown","4041174e":"markdown","b96559a4":"markdown"},"source":{"a0877294":"import pandas as pd\nimport numpy as np\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom tensorflow.keras.utils import to_categorical\n\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Conv2D, MaxPool2D, Flatten\nfrom tensorflow.keras.callbacks import EarlyStopping\n\n","bafc6595":"from tensorflow.keras.datasets import mnist\n\n(x_train, y_train), (x_test, y_test) = mnist.load_data()","b9d48765":"x_train.shape","bf42f37a":"y_train","31a4e714":"y_test","8f78bcff":"# we need one hot encode to get the classes\ny_train.shape","b896e75c":"y_cat_test = to_categorical(y_test,10)\ny_cat_train = to_categorical(y_train,10)","6b2ac4a3":"x_train = x_train\/255\nx_test = x_test\/255","47c5c9e6":"scaled_single = x_train[0]","deed9557":"scaled_single.max()","0bdd435c":"plt.imshow(scaled_single)","c4464994":"x_train.shape","a138e450":"x_test.shape","090082c0":"x_train = x_train.reshape(60000, 28, 28, 1)","e13404b2":"x_train.shape","1c88e156":"x_test = x_test.reshape(10000,28,28,1)","24921010":"x_test.shape","68cac518":"model = Sequential()\n\n# CONVOLUTIONAL LAYER\nmodel.add(Conv2D(filters=32, kernel_size=(4,4),input_shape=(28, 28, 1), activation='relu',))\n# POOLING LAYER\nmodel.add(MaxPool2D(pool_size=(2, 2)))\n\n# FLATTEN IMAGES FROM 28 by 28 to 764 BEFORE FINAL LAYER\nmodel.add(Flatten())\n\n# 128 NEURONS IN DENSE HIDDEN LAYER (YOU CAN CHANGE THIS NUMBER OF NEURONS)\nmodel.add(Dense(128, activation='relu'))\n\n# LAST LAYER IS THE CLASSIFIER, THUS 10 POSSIBLE CLASSES\nmodel.add(Dense(10, activation='softmax'))\n\n# https:\/\/keras.io\/metrics\/\nmodel.compile(loss='categorical_crossentropy',\n              optimizer='adam',\n              metrics=['accuracy']) # we can add in additional metrics https:\/\/keras.io\/metrics\/","6c2c4fa0":"model.summary()","232f3656":"early_stop = EarlyStopping(monitor='val_loss',patience=2)","f0f9238c":"model.fit(x_train,y_cat_train,epochs=10,validation_data=(x_test,y_cat_test),callbacks=[early_stop])","286b0d1d":"model.metrics_names","cdb44356":"losses = pd.DataFrame(model.history.history)\nlosses.head()","b0988f9f":"losses[['accuracy','val_accuracy']].plot()","80caa50c":"losses[['loss','val_loss']].plot()","6def1e58":"print(model.metrics_names)\nprint(model.evaluate(x_test,y_cat_test,verbose=0))","cc9f5773":"from sklearn.metrics import classification_report,confusion_matrix","91df0509":"predictions = model.predict_classes(x_test)","fe86523e":"y_cat_test.shape","60bb55f6":"y_cat_test[0]","7e58f1f6":"predictions[0]","62c0d6bf":"y_test","ad8d7370":"print(classification_report(y_test,predictions))","18e98527":"confusion_matrix(y_test,predictions)","df612074":"import seaborn as sns","05457660":"plt.figure(figsize=(10,6))\nsns.heatmap(confusion_matrix(y_test,predictions),annot=True)\n","77aac839":"my_number = x_test[0]","6cd0b445":"plt.imshow(my_number.reshape(28,28))","0029ddb5":"# SHAPE --> (num_images,width,height,color_channels)\nmodel.predict_classes(my_number.reshape(1,28,28,1))","c03f5b8c":"Hmmm, looks like our labels are literally categories of numbers. We need to translate this to be \"one hot encoded\" so our CNN can understand, otherwise it will think this is some sort of regression problem on a continuous axis. Luckily , Keras has an easy to use function for this:","deb2f26c":"## Reshaping the Data\n\nRight now our data is 60,000 images stored in 28 by 28 pixel array formation. \n\nThis is correct for a CNN, but we need to add one more dimension to show we're dealing with 1 RGB channel (since technically the images are in black and white, only showing values from 0-255 on a single channel), an color image would have 3 dimensions.","5e1c2e64":"## Evaluate the Model","f39a1d59":"# Predicting a given image","19277b5a":"Reshape to include channel dimension (in this case, 1 channel)","66b01c36":"##  Visualizing the Image Data","ded8e53d":"## Labels","02650984":"# Training the Model","7fe6e1a7":"# PreProcessing Data\n\nWe first need to make sure the labels will be understandable by our CNN.","4041174e":"### Processing X Data\n\nWe should normalize the X data","b96559a4":"## Train the Model"}}