{"cell_type":{"1b7d347e":"code","f87b2e0a":"code","2af7950f":"code","63335d5c":"code","b9a5d1c4":"code","4c335779":"code","d061abce":"code","c2600f70":"code","bac7234e":"code","62bbc164":"code","e3dad40c":"code","2746bcc5":"code","77ff780e":"code","dc829dea":"code","b62e1d37":"code","07b91488":"code","c2bc2826":"code","5546d4a9":"code","7f3d6da1":"code","fd9895cc":"code","6beb3887":"code","08f9aba1":"code","0e61d2f8":"code","ff237c26":"code","06cac6ec":"code","b340d3b4":"code","f9deaaf5":"code","e67898e6":"code","739d055b":"code","38a41f52":"code","0510de3d":"code","e708c5b6":"code","80d8f084":"code","28cbad45":"markdown","728c9177":"markdown","a1ce1dad":"markdown","b7895c09":"markdown","969dff44":"markdown","3f6002af":"markdown","411cd745":"markdown","2e5b13ba":"markdown","bf07c142":"markdown","fd5e7651":"markdown","15fad8e4":"markdown","05553c58":"markdown","cf55e84d":"markdown","15def610":"markdown","4691344a":"markdown","5ccf5c33":"markdown","9486b299":"markdown","ad57088a":"markdown","eb73be18":"markdown","7353b2a6":"markdown","5be6d4aa":"markdown","50f467e4":"markdown","1f84f3da":"markdown","32506a0c":"markdown","8c6a413f":"markdown","fdfc1250":"markdown","265001dc":"markdown","bee6e39b":"markdown","cdd5daea":"markdown","f678ba65":"markdown","e00db9eb":"markdown","b5ff07d2":"markdown","b2ba8fcf":"markdown"},"source":{"1b7d347e":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nplt.style.use('fivethirtyeight')","f87b2e0a":"# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","2af7950f":"#import plays data\nplays = pd.read_csv('\/kaggle\/input\/nfl-big-data-bowl-2022\/plays.csv')","63335d5c":"#filter out punt plays from all plays\npunts = plays[plays['specialTeamsPlayType'] == 'Punt']","b9a5d1c4":"#import PFF data\nPFF = pd.read_csv('\/kaggle\/input\/nfl-big-data-bowl-2022\/PFFScoutingData.csv')","4c335779":"#combine punt plays with PFF data\nPuntPFF = PFF.merge(punts, how='inner',on=['gameId','playId'])\nPuntPFF.sort_values(by=['gameId'], inplace=True)","d061abce":"#drop some variables\nPuntPlays = PuntPFF.drop(['passResult', 'penaltyCodes', 'penaltyJerseyNumbers', 'gameClock','preSnapHomeScore','preSnapVisitorScore','kickerId','returnerId','kickBlockerId','down','specialTeamsPlayType','specialTeamsSafeties','vises','tackler','kickoffReturnFormation','gunners','puntRushers','missedTackler','assistTackler'], axis=1)","c2600f70":"#make punt dataframe and drop more variables\nPuntDF = PuntPlays.drop(['returnDirectionIntended','returnDirectionActual','kickContactType'], axis=1)\nPuntDF","bac7234e":"# Create 'returned' boolean column to indicate whether a punt was returned or not\nPuntDF.loc[(PuntDF['specialTeamsResult'] == 'Return'), 'returned'] = 1\nPuntDF['returned'] = PuntDF['returned'].fillna(0)\nPuntDF.reset_index(inplace=True)\n\n# Create 'yardlineNumber' variable which accounts for teams punting over the midway 50 yard line\nPuntDF.loc[(PuntDF['possessionTeam'] == PuntDF['yardlineSide']), 'totalYardline'] = PuntDF['yardlineNumber']\nPuntDF.loc[(PuntDF['possessionTeam'] != PuntDF['yardlineSide']), 'totalYardline'] = ((50 - PuntDF['yardlineNumber']) + 50)\n\n# Re factor kickDirectionActual into numeric\nPuntDF.loc[(PuntDF['kickDirectionActual'] == 'L'), 'kickDirectionActual'] = 0\nPuntDF.loc[(PuntDF['kickDirectionActual'] == 'C'), 'kickDirectionActual'] = 1\nPuntDF.loc[(PuntDF['kickDirectionActual'] == 'R'), 'kickDirectionActual'] = 2\n\n# Re factor kickDirectionIntended into numeric\nPuntDF.loc[(PuntDF['kickDirectionIntended'] == 'L'), 'kickDirectionIntended'] = 0\nPuntDF.loc[(PuntDF['kickDirectionIntended'] == 'C'), 'kickDirectionIntended'] = 1\nPuntDF.loc[(PuntDF['kickDirectionIntended'] == 'R'), 'kickDirectionIntended'] = 2\n\n# Re factor kick type into two groups: normal = 0, non-normal (Aussie\/rugby) = 1\nPuntDF.loc[(PuntDF['kickType'] != 'N'), 'kickType'] = 1\nPuntDF.loc[(PuntDF['kickType'] == 'N'), 'kickType'] = 0\n\n# Re factor snapDetail into two groups: 0 = OK, 1 = Left\/right\/high\/low\nPuntDF.loc[(PuntDF['snapDetail'] != 'OK'), 'snapDetail'] = 1\nPuntDF.loc[(PuntDF['snapDetail'] == 'OK'), 'snapDetail'] = 0\n\n","62bbc164":"PuntDF","e3dad40c":"# Check how evenly weighted the two classes are\nPuntDF['returned'].value_counts()","2746bcc5":"#change type of variables\nPuntDF['snapDetail'] = PuntDF['snapDetail'].astype('int64')\nPuntDF['kickType'] = PuntDF['kickType'].astype('int64')","77ff780e":"# Correlation matrix\n\ncorr = PuntDF.corr()\n\nplt.rcParams[\"figure.figsize\"] = (15,10)\nsns.heatmap(corr, annot=True)\nplt.show()","dc829dea":"# df with features + target variable\n\nPuntDF_Target = PuntDF[['snapTime','operationTime','hangTime','kickDirectionActual','kickDirectionIntended','kickType','snapDetail','quarter','yardsToGo','kickLength','totalYardline','returned']]\nPuntDF_Target = PuntDF_Target.dropna()\n\nPuntDF_Target['kickDirectionIntended'] = PuntDF_Target['kickDirectionIntended'].astype('int64')\nPuntDF_Target['kickDirectionActual'] = PuntDF_Target['kickDirectionActual'].astype('int64')\nprint(PuntDF_Target.shape[0])\n\n# check correlation between variables\n\nplt.figure(figsize=(12,10))\ncor_target = PuntDF_Target.corr()\nsns.heatmap(cor_target, annot=True, cmap=plt.cm.Reds)\nplt.show()","b62e1d37":"# Drop kickDirectionIntended\n\nPuntDF_Target = PuntDF_Target.drop('kickDirectionIntended', axis=1)","07b91488":"# Pairplot of the target dataframe\n\nsns.pairplot(PuntDF_Target, hue='returned')\nplt.show()","c2bc2826":"# Scatter plot of operationTime vs. kickLength with returned punts colored orange\n\nsns.scatterplot(x='operationTime', y='kickLength', hue='returned', data=PuntDF)\nplt.title('Operation Time vs. Kick Length of Punts')\nplt.show()","5546d4a9":"# Scatter plot of hangTime vs. kickLength with returned punts colored in orange\n\nsns.scatterplot(PuntDF['hangTime'], PuntDF['kickLength'], hue=PuntDF['returned'])\nplt.title('Hang Time vs. Kick Length of Punts')\nplt.show()","7f3d6da1":"# Break down totalYardline into returned punts and non-returned punts. Check distribution of where those punts are being\n# kicked from on the field\n\nyardlineNotReturned = PuntDF[PuntDF['returned'] == 0]['totalYardline']\nyardlineReturned = PuntDF[PuntDF['returned'] == 1]['totalYardline']\n\nsns.distplot(yardlineNotReturned, label='No Return')\nsns.distplot(yardlineReturned, label='Return')\nplt.xlabel('Yards from own endzone to LOS')\nplt.title('Location of LOS for Returned and Non-returned Punts')\nplt.legend()\nplt.show()","fd9895cc":"from sklearn.model_selection import train_test_split\nfrom sklearn import metrics\nfrom sklearn.linear_model import LogisticRegression\n\nX_train, X_test, y_train, y_test = train_test_split(PuntDF_Target[['snapTime','operationTime','hangTime','kickDirectionActual','kickType','snapDetail','quarter','yardsToGo','kickLength','totalYardline']], PuntDF_Target[['returned']] , test_size=0.2, random_state=123)\n\nlogreg = LogisticRegression(max_iter=500)\nlogreg.fit(X_train, y_train.values.ravel())\npredictions = logreg.predict(X_test)\nscore = logreg.score(X_test, y_test)\nprint(score)","6beb3887":"# Classification report for logistic regression model\n\nprint(metrics.classification_report(y_test, predictions))","08f9aba1":"# Heat map for actual and predicted values for logistic regression\n\ncm = metrics.confusion_matrix(y_test, predictions)\nplt.figure(figsize=(9,9))\nsns.heatmap(cm, annot=True, fmt=\".3f\", linewidths=.5, square=True, cmap='Blues_r');\nplt.ylabel('Actual label');\nplt.xlabel('Predicted label');\nall_sample_title = 'Accuracy Score: {0}'.format(score)\nplt.title(all_sample_title, size = 15);","0e61d2f8":"# ROC curve for logistic regression\n\nimport scikitplot as skplt\n\nplt.rcParams['figure.figsize'] = [10, 10]\n\npredicted_probas = logreg.predict_proba(X_test)\n\nskplt.metrics.plot_roc(y_test, predicted_probas)\nplt.title('ROC Curves: Logistic Regression Classifier')\nplt.show()","ff237c26":"# Random Forest classification\n\nfrom sklearn.ensemble import RandomForestClassifier\n\nrf = RandomForestClassifier(n_estimators=500, oob_score=True, random_state=123)\nrf.fit(X_train, y_train.values.ravel())","06cac6ec":"# OOB score and accuracy score of RF model\n\npredicted = rf.predict(X_test)\naccuracy = metrics.accuracy_score(y_test, predicted)\nprint(f'Out-of-bag score estimate: {rf.oob_score_:.3}')\nprint(f'Mean accuracy score: {accuracy:.3}')","b340d3b4":"# Classification report for RF model\n\nprint(metrics.classification_report(y_test, predicted))","f9deaaf5":"cm = metrics.confusion_matrix(y_test, predicted)\nplt.figure(figsize=(9,9))\nsns.heatmap(cm, annot=True, fmt=\".3f\", linewidths=.5, square=True, cmap='Blues_r');\nplt.ylabel('Actual label');\nplt.xlabel('Predicted label');\nall_sample_title = 'Accuracy Score: {0}'.format(accuracy)\nplt.title(all_sample_title, size = 15);","e67898e6":"# ROC curve for RF model\n\nplt.rcParams['figure.figsize'] = [10, 10]\n\npredicted_probas = rf.predict_proba(X_test)\n\nskplt.metrics.plot_roc(y_test, predicted_probas)\nplt.title('ROC Curves: Random Forest Classifier')\nplt.show()","739d055b":"# RF feature importances using built-in functionality\nrf.feature_importances_","38a41f52":"# Feature importance for RF model\n\nfeature_names = np.array(['snapTime','operationTime','hangTime','kickDirectionActual','kickType','snapDetail','quarter','yardsToGo','kickLength','totalYardline'])\nsorted_idx = rf.feature_importances_.argsort()\nplt.barh(feature_names[sorted_idx], rf.feature_importances_[sorted_idx], color='midnightblue')\nplt.xlabel(\"Random Forest Feature Importance\")\nplt.show()","0510de3d":"# Permutation importance values\n# Similar to the in-model importances with a few exceptions\n\nfrom sklearn.inspection import permutation_importance\n\nperm_importance = permutation_importance(rf, X_test, y_test)\nsorted_idx = perm_importance.importances_mean.argsort()\nplt.barh(feature_names[sorted_idx], perm_importance.importances_mean[sorted_idx], color='midnightblue')\nplt.xlabel(\"Permutation Importance\")\nplt.show()","e708c5b6":"# SHAP Value estimating how much each feature contributes to the prediction\n\nimport shap\nexplainer = shap.TreeExplainer(rf)\nshap_values = explainer.shap_values(X_test)","80d8f084":"shap.summary_plot(shap_values, X_test, plot_type=\"bar\")","28cbad45":"We found that kickReturnYardage and playResult have high, negative correlation and that playResult and penaltyYards have a significant correlation. All others do not demonstrate a remarkable level of correlation with playResult. ","728c9177":"We found that the Random Forest classifcation was much better at predicting the punt returns than the logistic regression model. It is also slightly better at predicting the punts not returned.","a1ce1dad":"When looking at permutation importance, we found kicklength took the top spot, but totalYardline is still highly important. snapTime and operationTime are least important.\n\nWe noticed that on both importance checks, snap detail is low. We decide that it may be worth dropping next time.","b7895c09":"kickDirectionInteded and kickDirectionActual have very high correlation. totalYardline and kickType have a high correlation as well. Everything else seems to be fine.","969dff44":"We found that the logistic regression model had a strong recall rate for 0 (punts not returned). The model was less successful predicting 1 (punts that are returned).","3f6002af":"Logistic Regression has a moderate score for classification.","411cd745":"As mentioned above, Random Forest is still good at predicting punts not returned and better at making accurate predictions of punt returns. The overall accuracy score saw an increase of .043 from the logistic regression model we created. ","2e5b13ba":"Unreturned kicks, represented by 0.0, totaled at 3,705. Returned kicks, represented by 1.0, reached a total of 2286.","bf07c142":"### Let's explore the distribution of the data","fd5e7651":"Two variables that stood out immediately were snapDetail and totalYardline. Snap detail is very low in importance while totalYardline is exceedingly important. The rest of our variables fall between the two. ","15fad8e4":"Ultimately, from the two models we set out to create, we found that the Random Forest was best for predicting whether or not a punt will be returned. The most influential variables that impact the decision of a punt returner are totalYardline, kickLength, and hangTime (not in a specific order). To further polish our model, there were variables that could have been removed to focus more squarely on the factors that impact the decision of the returner. We were happy to close with a model that has shown success in predicting the outcome of a given punt.","05553c58":"# **5. Building Models**","cf55e84d":"### Logistic Regression","15def610":"### Changing Categorical Variables to Binary","4691344a":"### Create target df with features and outcome variable","5ccf5c33":"We decided here that we would use Random Forest for the rest of our model, as it is more accurate in predicitng correctly. Our next step was to determine feature importance for our variables. ","9486b299":"Data Frame used for analysis with booleans.","ad57088a":"# **6. Feature Importance**","eb73be18":"# **7. Summary**","7353b2a6":"To better manipulate our variables, we adjusted them from text to boolean and numerical values. ","5be6d4aa":"### Zooming in on a few of the most revealing plots","50f467e4":"# **2. Bringing in data \/ Cleaning data**","1f84f3da":"As demonstrated above, this model is effective for punts not returned (high correct predictions). It lacks when predicting true punt returns.","32506a0c":"### Check how evenly weighted the two classes are","8c6a413f":"# **Logistic Regression vs Random Forest to Predict if a Punt will be Returned**","fdfc1250":"\nWe began by trimming the data provided down to only punt plays. We removed unnecessary variables to make the data more manageable and allow for our model to run cleanly later. The variables that we decided to continue studying heavily focused on the punt\u2019s context rather than the actions of the players. To restate, the purpose of our model is to predict whether a punt will be returned based on game factors including the quarter in which the play is occurring, the yardline from which the ball is punted, the length of the kick, and other variables.\n\nThis lead us to our final data frame of punt plays.","265001dc":"## Random Forest Classification","bee6e39b":"# **1. Import libraries**","cdd5daea":"### Checking Correlation","f678ba65":"# **4. Data Visualization**","e00db9eb":"In this report, we would like to figure out if we can predict if a punt will be returned or not using two different methods of classification. We will compare Logistic Regression and Random Forest.","b5ff07d2":"# **3. Data Manipulation**","b2ba8fcf":"kickDirectionInteded is dropped due to high correlation and the belief that kickDirectionActual has more influence on a punt return."}}