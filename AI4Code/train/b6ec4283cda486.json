{"cell_type":{"5f932528":"code","7573bfb7":"code","066fff11":"code","b4eaef6e":"code","1b72271c":"code","184c6290":"code","330348c0":"code","81ee9a7b":"code","cd5e2ae7":"code","36c0f2e1":"code","220b30bc":"code","0c38c51b":"markdown","46c4a71a":"markdown","97d1f399":"markdown","554d4087":"markdown","3c44eb1c":"markdown"},"source":{"5f932528":"## forked from https:\/\/www.kaggle.com\/titericz\/building-and-visualizing-masks\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport random\nimport os\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport cv2\nimport os\nprint(os.listdir(\"..\/input\"))","7573bfb7":"train = pd.read_csv('..\/input\/train.csv')\ntrain_masks = train.loc[\n    lambda df: df['EncodedPixels'].notnull()\n].assign(\n    image_id=lambda df: df['ImageId_ClassId'].str.split('_', expand=True)[0],\n    class_id=lambda df: df['ImageId_ClassId'].str.split('_', expand=True)[1],\n)\ntrain_image_ids = train_masks.loc[:,'image_id'].drop_duplicates()\nprint('Number of RLEs: ', len(train_masks))\nprint('Number of train images with RLEs: ', len(train_image_ids))\ntrain_masks.head(10)","066fff11":"train_mask_counts = train_masks.groupby('image_id').agg({'class_id': 'count'}).reset_index()\ndist_non_null_train_masks = train_mask_counts.groupby('class_id').size()\ndist_non_null_train_masks.head()\nthree_class_images = train_mask_counts.loc[lambda df: df.class_id == 3, 'image_id']","b4eaef6e":"def rle2mask(rle, imgshape):\n    width = imgshape[0]\n    height= imgshape[1]\n    \n    mask= np.zeros( width*height ).astype(np.uint8)\n    \n    array = np.asarray([int(x) for x in rle.split()])\n    starts = array[0::2]\n    lengths = array[1::2]\n\n    current_position = 0\n    for index, start in enumerate(starts):\n        mask[int(start):int(start+lengths[index])] = 1\n        current_position += lengths[index]\n        \n    return np.flipud( np.rot90( mask.reshape(height,width), k=1 ) )","1b72271c":"def filter_images_w_classes(class_id):\n    image_ids = train_masks.loc[lambda df: df.class_id == str(class_id), 'image_id'].drop_duplicates()\n    return image_ids\n\nclass_image_ids = {    \n    i: filter_images_w_classes(i)\n    for i in range(1, 5)\n}","184c6290":"def plot_images(class_id):\n    fig=plt.figure(figsize=(20,150))\n    images = 8\n    columns = 4\n    horizontal_splits = 6\n    rows = int(images * horizontal_splits * 2 \/ columns)\n\n    rgb_class_ids = {\n        '1': (255, 0, 0),\n        '2': (0, 255, 0),\n        '3': (0, 0, 255),\n        '4': (255, 150, 0),\n    }\n    for i_image, image_id in enumerate(class_image_ids[class_id].sample(images).values):\n\n        img = cv2.imread( '..\/input\/train_images\/' + image_id)\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        img_w_masks = img.copy()\n\n        chunk_x_span = int(img.shape[1] \/ horizontal_splits)\n\n        classed_masks = train_masks.loc[lambda df: df.image_id == image_id]\n        for class_id, rle in classed_masks.loc[:,['class_id', 'EncodedPixels']].values:\n            mask = rle2mask(rle, img.shape)\n            img_w_masks[mask==1] = rgb_class_ids[class_id]\n\n        for i_chunk in range(horizontal_splits):\n            index_no_mask = i_image*horizontal_splits*2 + i_chunk*2 + 1\n            index_with_mask = index_no_mask + 1\n            fig.add_subplot(rows, columns, index_no_mask, title='{} [Chunk {}]'.format(image_id, i_chunk))\n            plt.imshow(img[:, chunk_x_span*i_chunk:chunk_x_span*(i_chunk + 1)])\n            fig.add_subplot(rows, columns, index_with_mask, title='{} [Chunk {}] with masks'.format(image_id, i_chunk))\n            plt.imshow(img_w_masks[:, chunk_x_span*i_chunk:chunk_x_span*(i_chunk + 1)])\n    plt.show()","330348c0":"plot_images(1)","81ee9a7b":"plot_images(2)","cd5e2ae7":"plot_images(3)","36c0f2e1":"plot_images(4)","220b30bc":"fig=plt.figure(figsize=(20,50))\nimages = 2\ncolumns = 4\nhorizontal_splits = 6\nrows = images * horizontal_splits\n\nrgb_class_ids = {\n    '1': (255, 0, 0),\n    '2': (0, 255, 0),\n    '3': (0, 0, 255),\n    '4': (255, 255, 255),\n}\nfor i_image, image_id in enumerate(three_class_images[:images].values):\n    \n    img = cv2.imread( '..\/input\/train_images\/' + image_id)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img_w_masks = img.copy()\n    \n    chunk_x_span = int(img.shape[1] \/ horizontal_splits)\n    \n    classed_masks = train_masks.loc[lambda df: df.image_id == image_id]\n    for class_id, rle in classed_masks.loc[:,['class_id', 'EncodedPixels']].values:\n        mask = rle2mask(rle, img.shape)\n        img_w_masks[mask==1] = rgb_class_ids[class_id]\n    \n    for i_chunk in range(horizontal_splits):\n        index_no_mask = i_image*horizontal_splits*2 + i_chunk*2 + 1\n        index_with_mask = i_image*horizontal_splits*2 + i_chunk*2 + 2\n        fig.add_subplot(rows, columns, index_no_mask, title='{} [Chunk {}]'.format(image_id, i_chunk))\n        plt.imshow(img[:, chunk_x_span*i_chunk:chunk_x_span*(i_chunk + 1)])\n        fig.add_subplot(rows, columns, index_with_mask, title='{} [Chunk {}] with masks'.format(image_id, i_chunk))\n        plt.imshow(img_w_masks[:, chunk_x_span*i_chunk:chunk_x_span*(i_chunk + 1)])\nplt.show()","0c38c51b":"# Images for Class 4","46c4a71a":"# Images for Class 3","97d1f399":"# Images for Class 1","554d4087":"### Let's also check out the images that had several different class IDs","3c44eb1c":"# Images for Class 2"}}