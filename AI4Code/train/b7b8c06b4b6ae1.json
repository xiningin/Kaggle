{"cell_type":{"e01f561e":"code","43b50adf":"code","f3268846":"code","058fff2e":"code","358cea81":"code","61ecf978":"code","b08b62f4":"code","95f1b0f2":"code","87f77d16":"code","1f1cf61d":"code","ead1ef79":"code","eae0ccde":"code","a7fee585":"code","3cae0203":"code","1bba323b":"code","c3cb711d":"code","7206e1ec":"code","e30e6bb6":"code","4c7bb6c5":"code","1cbd86a3":"code","3df84b40":"code","077cde21":"code","e0b5313b":"code","8b7bdc2b":"code","c9707370":"code","8eaeaca6":"code","d64b7eca":"code","4c1211ab":"code","10d4598f":"code","9dee0d8c":"code","e78a9909":"code","80c0370b":"code","07a5a45d":"markdown","bc3a1e63":"markdown","4d5d74cc":"markdown","53eac3ad":"markdown","53fd7681":"markdown","6dbd0abc":"markdown","a9f09b1d":"markdown","6c42fd5a":"markdown","4814276c":"markdown","ab3c5a3a":"markdown","3deb7ca2":"markdown","cb24a0f5":"markdown"},"source":{"e01f561e":"# Creates a playlist of more relevant recommended tracks of a playlist\n\n# install Spotipy first\n!pip install Spotipy","43b50adf":"import spotipy\nfrom spotipy.oauth2 import SpotifyClientCredentials\nimport spotipy.util as util\n\n\ncid ='' # Client ID; copy this from your app created on beta.developer.spotify.com\nsecret = '' # Client Secret; copy this from your app\nusername = '' # Your Spotify username\n\n#for avaliable scopes see https:\/\/developer.spotify.com\/web-api\/using-scopes\/\nscope = 'user-library-read playlist-modify-public playlist-read-private'\n\nredirect_uri='http:\/\/localhost:3000'\n\nclient_credentials_manager = SpotifyClientCredentials(client_id=cid, client_secret=secret) \n\nsp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)\n\ntoken = util.prompt_for_user_token(username, scope, cid, secret, redirect_uri)\n\nif token:\n    sp = spotipy.Spotify(auth=token)\nelse:\n    print(\"Can't get token for\", username)","f3268846":"#Create a dataframe of your playlist including tracks' names and audio features\nimport pandas as pd\n\nsourcePlaylistID = '37i9dQZF1DWY6UWUOwj4BO'\nsourcePlaylist = sp.user_playlist(username, sourcePlaylistID);\ntracks = sourcePlaylist[\"tracks\"];\nsongs = tracks[\"items\"];\n\ntrack_ids = []\ntrack_names = []\n\nfor i in range(0, len(songs)):\n    if songs[i]['track']['id'] != None: # Removes the local tracks in your playlist if there is any\n        track_ids.append(songs[i]['track']['id'])\n        track_names.append(songs[i]['track']['name'])\n\nfeatures = []\nfor i in range(0,len(track_ids)):\n    audio_features = sp.audio_features(track_ids[i])\n    for track in audio_features:\n        features.append(track)\n        \nplaylist_df = pd.DataFrame(features, index = track_names)","058fff2e":"playlist_df.head()","358cea81":"playlist_df=playlist_df[[\"id\", \"acousticness\", \"danceability\", \"duration_ms\", \n                         \"energy\", \"instrumentalness\",  \"key\", \"liveness\",\n                         \"loudness\", \"mode\", \"speechiness\", \"tempo\", \"valence\"]]\nplaylist_df.head()","61ecf978":"\n#used TFIDF on track names, tracks who have similar titles are prefered !!?\n\nfrom sklearn.feature_extraction.text import TfidfVectorizer\n\nv=TfidfVectorizer(sublinear_tf=True, ngram_range=(1, 6), max_features=10000)\nX_names_sparse = v.fit_transform(track_names)\nX_names_sparse.shape","b08b62f4":"## Change the below info for each playlist manually to get better results\n# Give ratings to your tracks with respect to their playlist relevances\n# Rate them from 1-10, give higher ratings to those tracks which you think best chracterizes your playlist\n# If you order your playlist by relevance while creating it, this step will become easier\n# So now, we will deal with a classification task\nimport numpy as np\nplaylist_df['ratings']=[10, 9, 9, 10, 8, 6, 8, 4, 3, 5, 7, 5, 5, 8, 8, 7, 8, 8, 10, 8, 10, 8, 4, 4, 4, 10, 10, 9, 8, 8, 4,10, 9, 9, 10, 8, 6, 8, 4, 3, 5, 7, 5, 5, 8, 8, 7, 8, 8, 10]\nplaylist_df.head()","95f1b0f2":"\nfrom sklearn.ensemble._forest import RandomForestRegressor, RandomForestClassifier\n\nX_train = playlist_df.drop(['id', 'ratings'], axis=1)\ny_train = playlist_df['ratings']\nforest = RandomForestClassifier(random_state=42, max_depth=5, max_features=12) # Set by GridSearchCV below\nforest.fit(X_train, y_train)\nimportances = forest.feature_importances_\nindices = np.argsort(importances)[::-1]\n\n# Print the feature rankings\nprint(\"Feature ranking:\")\n  \nfor f in range(len(importances)):\n    print(\"%d. %s %f \" % (f + 1, \n            X_train.columns[f], \n            importances[indices[f]]))\n","87f77d16":"\n#PCA reduces the dimensions which makes our model's performance faster \n\nfrom sklearn import decomposition\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt\nimport seaborn as sns; sns.set(style='white')\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\n#before applying PCA, we need to scale our dataset \nX_scaled = StandardScaler().fit_transform(X_train)\n\npca = decomposition.PCA().fit(X_scaled)\n\nplt.figure(figsize=(10,7))\nplt.plot(np.cumsum(pca.explained_variance_ratio_), color='k', lw=2)\nplt.xlabel('Number of components')\nplt.ylabel('Total explained variance')\nplt.xlim(0, 12)\nplt.yticks(np.arange(0, 1.1, 0.1)) \nplt.axvline(8.2, c='b') # Tune this so that you obtain at least a 95% total variance explained\nplt.axhline(0.95, c='r') # 95% cut-off threshold \nplt.show();","1f1cf61d":"#looking at the graph, the optimal nb of components ( intersection between the cumulative sum od PCA explained variance and horiz + vertical lines )\n# Fit your dataset to the optimal pca\npca1 = decomposition.PCA(n_components=8)\nX_pca = pca1.fit_transform(X_scaled)","ead1ef79":"# You may want to check the results of TSNE also\nfrom sklearn.manifold import TSNE\n\ntsne = TSNE(random_state=17)\nX_tsne = tsne.fit_transform(X_scaled)","eae0ccde":"from scipy.sparse import csr_matrix, hstack\n\nX_train_last = csr_matrix(hstack([X_pca, X_names_sparse])) # Check with X_tsne + X_names_sparse also","a7fee585":"from sklearn.model_selection import StratifiedKFold, GridSearchCV\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Initialize a stratified split for the validation process\nskf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)","3cae0203":"\nfrom sklearn.tree import DecisionTreeClassifier\n\ntree = DecisionTreeClassifier()\n\ntree_params = {'max_depth': range(1,11), 'max_features': range(4,19)}\n\ntree_grid = GridSearchCV(tree, tree_params, cv=skf, n_jobs=-1, verbose=True)\n\ntree_grid.fit(X_train_last, y_train)\ntree_grid.best_estimator_, tree_grid.best_score_","1bba323b":"\n\nparameters = {'max_features': [4, 7, 8, 10], 'min_samples_leaf': [1, 3, 5, 8], 'max_depth': [3, 5, 8]}\nrfc = RandomForestClassifier(n_estimators=100, random_state=42, \n                             n_jobs=-1, oob_score=True)\ngcv1 = GridSearchCV(rfc, parameters, n_jobs=-1, cv=skf, verbose=1)\ngcv1.fit(X_train_last, y_train)\ngcv1.best_estimator_, gcv1.best_score_\n\n#possibility of tuning this model by picking other values for max_features, min_samle_leaf ....","c3cb711d":"\nfrom sklearn.neighbors import KNeighborsClassifier\n\nknn_params = {'n_neighbors': range(1, 10)}\nknn = KNeighborsClassifier(n_jobs=-1)\n\nknn_grid = GridSearchCV(knn, knn_params, cv=skf, n_jobs=-1, verbose=True)\nknn_grid.fit(X_train_last, y_train)\nknn_grid.best_params_, knn_grid.best_score_","7206e1ec":"# Now build your test set;\n# Generate a new dataframe for recommended tracks\n# Set recommendation limit as half the Playlist Length per track, you may change this as you like\n# Check documentation for  recommendations; https:\/\/beta.developer.spotify.com\/documentation\/web-api\/reference\/browse\/get-recommendations\/\n\nrec_tracks = []\nfor i in playlist_df['id'].values.tolist():\n    rec_tracks += sp.recommendations(seed_tracks=[i], limit=int(len(playlist_df)\/4))['tracks'];\n\nrec_track_ids = []\nrec_track_names = []\nfor i in rec_tracks:\n    rec_track_ids.append(i['id'])\n    rec_track_names.append(i['name'])\n\nrec_features = []\nfor i in range(0,len(rec_track_ids)):\n    rec_audio_features = sp.audio_features(rec_track_ids[i])\n    for track in rec_audio_features:\n        rec_features.append(track)\n        \nrec_playlist_df = pd.DataFrame(rec_features, index = rec_track_ids)\nrec_playlist_df.head()","e30e6bb6":"rec_tracks","4c7bb6c5":"X_test_names = v.transform(rec_track_names)","1cbd86a3":"X_test_names","3df84b40":"rec_playlist_df=rec_playlist_df[[\"acousticness\", \"danceability\", \"duration_ms\", \n                         \"energy\", \"instrumentalness\",  \"key\", \"liveness\",\n                         \"loudness\", \"mode\", \"speechiness\", \"tempo\", \"valence\"]]","077cde21":"# Make predictions\ntree_grid.best_estimator_.fit(X_train_last, y_train)\nrec_playlist_df_scaled = StandardScaler().fit_transform(rec_playlist_df)\nrec_playlist_df_pca = pca1.transform(rec_playlist_df_scaled)\nX_test_last = csr_matrix(hstack([rec_playlist_df_pca, X_test_names]))\ny_pred_class = tree_grid.best_estimator_.predict(X_test_last)","e0b5313b":"rec_playlist_df","8b7bdc2b":"rec_playlist_df['ratings']=y_pred_class\nrec_playlist_df = rec_playlist_df.sort_values('ratings', ascending = False)\nrec_playlist_df = rec_playlist_df.reset_index()\n\n# Pick the top ranking tracks to add your new playlist 9, 10 will work\nrecs_to_add = rec_playlist_df[rec_playlist_df['ratings']>=9]['index'].values.tolist()\n","c9707370":"# No ratings of 9 or 10 this case try adding 8's only\nrecs_to_add = rec_playlist_df[rec_playlist_df['ratings']==8]['index'].values.tolist()","8eaeaca6":"recs_to_add# a list of the recommended songs","d64b7eca":"recs_to_add=recs_to_add[0:53]","4c1211ab":"# Check what is about to happen :)\nlen(rec_tracks), rec_playlist_df.shape, len(recs_to_add)","10d4598f":"rec_array = np.reshape(recs_to_add, (1, 53))","9dee0d8c":"# Create a new playlist for tracks to add - you may also add these tracks to your source playlist and proceed\nplaylist_recs = sp.user_playlist_create(username, \n                                        name='Recommended_playlist for - {}'.format(sourcePlaylist['name']))\n","e78a9909":"# Add tracks to the new playlist\nfor i in rec_array:\n    sp.user_playlist_add_tracks(username, playlist_recs['id'], i);","80c0370b":"# This performed really well for my case, and I am pretty satisfied with the resulting playlist -more than the default recommendations","07a5a45d":"## TFIDF on tracks names","bc3a1e63":"## Let's try different ML models and see the results of each one of them ","4d5d74cc":"### KNN","53eac3ad":"Principal Components Analysis (PCA) is an algorithm to transform the columns of a dataset into a new set of features called Principal Components. By doing this, a large chunk of the information across the full dataset is effectively compressed in fewer feature columns. This enables dimensionality reduction and ability to visualize the separation of classes or clusters if any.","53fd7681":"### Random Forest ","6dbd0abc":"Grid search makes the training process more optimized ","a9f09b1d":"## Apply pca to the scaled train set ","6c42fd5a":"## Matrix with the new components ( PCA ) ","4814276c":"Difference between PCA and t-SNE :\n    ","ab3c5a3a":"### Decision Tree","3deb7ca2":"It seems like acousticness and danceability are very important features in our case ","cb24a0f5":"## Analyze feature importances"}}