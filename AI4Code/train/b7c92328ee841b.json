{"cell_type":{"0ea84ed5":"code","ce3d0e1e":"code","cd530672":"code","31f85b9a":"code","17907a5f":"code","86288b2c":"code","5d99d104":"code","4cb3a98d":"code","857a21dd":"code","4312f221":"code","83da2a28":"code","45b6fc6d":"code","d8f73e5e":"code","5630c890":"code","dff3f70f":"code","dddeb0b4":"code","aadb42ea":"code","974a306a":"code","86bd8bda":"code","d8d82540":"code","05b67743":"code","31094117":"code","d00eee8d":"code","92c43fd0":"markdown","1bbfaef0":"markdown","329ab735":"markdown","f6259eed":"markdown","5f7e0889":"markdown","a6eee7c3":"markdown","cc1169fd":"markdown","faa56649":"markdown","cca8162f":"markdown","9b7104d9":"markdown","38a6571e":"markdown"},"source":{"0ea84ed5":"import pandas  as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n%matplotlib inline","ce3d0e1e":"data = pd.read_csv('..\/input\/creditcardfraud\/creditcard.csv')","cd530672":"data['V1'].describe()","31f85b9a":"data['V2'].describe()","17907a5f":"# Undersample the majority - Non Fraud \n# Oversample the minority calss - Fraud\n\n# Balance the dataset","86288b2c":"pd.value_counts(data['Class']).plot.bar()\nplt.title('Fraud class histogram')\nplt.xlabel('Class')\nplt.ylabel('Frequency')\ndata['Class'].value_counts()","5d99d104":"# Standard and Robust Scaler\n# Min Max scaler","4cb3a98d":"# Preprocessing data in scikit\n# Trained and evaluated the model performance","857a21dd":"from sklearn.preprocessing import StandardScaler\n\ndata['normAmount'] = StandardScaler().fit_transform(data['Amount'].values.reshape(-1, 1))\ndata = data.drop(['Time', 'Amount'], axis=1)\ndata.head()","4312f221":"X = np.array(data.iloc[:, data.columns != 'Class'])\ny = np.array(data.iloc[:, data.columns == 'Class'])\nprint('Shape of X: {}'.format(X.shape))\nprint('Shape of y: {}'.format(y.shape))","83da2a28":"from imblearn.over_sampling import SMOTE\n\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)\n\nprint(\"Number transactions X_train dataset: \", X_train.shape)\nprint(\"Number transactions y_train dataset: \", y_train.shape)\nprint(\"Number transactions X_test dataset: \", X_test.shape)\nprint(\"Number transactions y_test dataset: \", y_test.shape)","45b6fc6d":"print(\"Before OverSampling, counts of label '1': {}\".format(sum(y_train==1)))\nprint(\"Before OverSampling, counts of label '0': {} \\n\".format(sum(y_train==0)))\n\nsm = SMOTE(random_state=2)\nX_train_res, y_train_res = sm.fit_sample(X_train, y_train.ravel())\n\nprint('After OverSampling, the shape of train_X: {}'.format(X_train_res.shape))\nprint('After OverSampling, the shape of train_y: {} \\n'.format(y_train_res.shape))\n\nprint(\"After OverSampling, counts of label '1': {}\".format(sum(y_train_res==1)))\nprint(\"After OverSampling, counts of label '0': {}\".format(sum(y_train_res==0)))","d8f73e5e":"from sklearn.model_selection import GridSearchCV\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, precision_recall_curve, auc, roc_auc_score, roc_curve, recall_score, classification_report\n\nparameters = {\n    'C': np.linspace(1, 10, 10)\n             }\nlr = LogisticRegression()\nclf = GridSearchCV(lr, parameters, cv=5, verbose=5, n_jobs=3)\nclf.fit(X_train_res, y_train_res.ravel())","5630c890":"clf.best_params_","dff3f70f":"lr1 = LogisticRegression(C=9,penalty='l2', verbose=5)\nlr1.fit(X_train_res, y_train_res.ravel())","dddeb0b4":"import itertools\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=0)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        #print(\"Normalized confusion matrix\")\n    else:\n        1#print('Confusion matrix, without normalization')\n\n    #print(cm)\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","aadb42ea":"y_train_pre = lr1.predict(X_train)\n\ncnf_matrix_tra = confusion_matrix(y_train, y_train_pre)\n\nprint(\"Recall metric in the train dataset: {}%\".format(100*cnf_matrix_tra[1,1]\/(cnf_matrix_tra[1,0]+cnf_matrix_tra[1,1])))\n\n\nclass_names = [0,1]\nplt.figure()\nplot_confusion_matrix(cnf_matrix_tra , classes=class_names, title='Confusion matrix')\nplt.show()","974a306a":"cnf_matrix_tra","86bd8bda":"y_pre = lr1.predict(X_test)\n\ncnf_matrix = confusion_matrix(y_test, y_pre)\n\nprint(\"Recall metric in the testing dataset: {}%\".format(100*cnf_matrix[1,1]\/(cnf_matrix[1,0]+cnf_matrix[1,1])))\n#print(\"Precision metric in the testing dataset: {}%\".format(100*cnf_matrix[0,0]\/(cnf_matrix[0,0]+cnf_matrix[1,0])))\n# Plot non-normalized confusion matrix\nclass_names = [0,1]\nplt.figure()\nplot_confusion_matrix(cnf_matrix , classes=class_names, title='Confusion matrix')\nplt.show()","d8d82540":"cnf_matrix","05b67743":"tmp = lr1.fit(X_train_res, y_train_res.ravel())","31094117":"y_pred_sample_score = tmp.decision_function(X_test)\n\n\nfpr, tpr, thresholds = roc_curve(y_test, y_pred_sample_score)\n\nroc_auc = auc(fpr,tpr)\n\n# Plot ROC\nplt.title('Receiver Operating Characteristic')\nplt.plot(fpr, tpr, 'b',label='AUC = %0.3f'% roc_auc)\nplt.legend(loc='lower right')\nplt.plot([0,1],[0,1],'r--')\nplt.xlim([-0.1,1.0])\nplt.ylim([-0.1,1.01])\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')\nplt.show()","d00eee8d":"roc_auc","92c43fd0":"# AUROC","1bbfaef0":"# Scaling of Features","329ab735":"# Performance of the Model","f6259eed":"# Fit the Model","5f7e0889":"# Class Imbalance","a6eee7c3":"# Performance on Testing Data","cc1169fd":"# Performance on Training Data","faa56649":"# Load Data","cca8162f":"# SMOTE: Synthetic Minority Over-sampling Technique","9b7104d9":"# Load Libraries","38a6571e":"# Seperate X and y"}}