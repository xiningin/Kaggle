{"cell_type":{"5daac7a3":"code","737d877c":"code","887d8526":"code","4ce2759c":"code","482c1996":"code","4894b289":"code","abbabe82":"code","ee3bc7c8":"code","683027d3":"code","e777ef3a":"code","b3147aca":"code","d77c3970":"code","38adea08":"code","924a3120":"code","56728086":"code","dbd2d63e":"code","20e7d589":"code","82d9c2b6":"code","09ff7ecf":"code","faee67a7":"code","b882b41c":"code","dc00de5d":"code","01e8a94f":"code","6a2d71ce":"code","7a962ff7":"code","68ad0888":"code","77eb45c2":"code","6e7cd98f":"code","674efea1":"markdown","9125db74":"markdown","f93b6715":"markdown","3756be53":"markdown","30e1cb0b":"markdown","1e27ff5d":"markdown","16ecf20f":"markdown","c4b0c53d":"markdown","b15177dd":"markdown","d891c5c9":"markdown","3200ed1a":"markdown"},"source":{"5daac7a3":"# Bibliotecas necess\u00e1rias\n# Manipula\u00e7\u00e3o de dados\nimport pandas as pd\n# Redes Neurais\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten\nfrom tensorflow.keras.optimizers import RMSprop\n# Plot\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# Avalia\u00e7\u00e3o\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom tensorflow.keras.models import load_model\nimport numpy as np\n\n\n","737d877c":"# Lendo o dataset Kaggle\ntrain = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")","887d8526":"# Analisando o dataset\nprint(\"Quantidade de elementos de treino: {}\". format(len(train)))\nprint(train.head())","4ce2759c":"# Separando x_train e y_train\nY = train[\"label\"]\nX = train.drop(labels = [\"label\"],axis = 1)\nprint(X.shape)","482c1996":"# Transformando a imagem 2d em um numpy array (imagem 28*28)\nx = X.values.reshape(42000, 28, 28, 1)\n\n#Normalizando para valores entre 0 e 1\nx = x.astype('float32')\nx \/= 255","4894b289":"# Vamos ajustar o formato da saida\nnum_classes = 10\n\n# Convertendo para um vetor de saida com 10 dimensoes\n# ex. 8 => [0,0,0,0,0,0,0,0,1,0]\ny = keras.utils.to_categorical(Y, num_classes)\nprint(y[0])","abbabe82":"# Separando uma parte para treino (90%) e outra para valida\u00e7\u00e3o (10%)\nfrom sklearn.model_selection import train_test_split\nx_train, x_val, y_train, y_val = train_test_split(x, y, test_size = 0.1, random_state=5)\nprint('Qtde de treino: {}'.format(len(x_train)))\nprint('Qtde de valida\u00e7\u00e3o: {}'.format(len(x_val)))","ee3bc7c8":"def create_model_pattern_without_dp(act_func):\n    model = Sequential()\n    model.add(Conv2D(20, kernel_size=(3, 3),activation=act_func,input_shape=(28,28,1)))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Conv2D(40, kernel_size=(3,3), activation=act_func))\n    model.add(MaxPooling2D(pool_size=(2, 2)))    \n    model.add(Flatten())\n    model.add(Dense(30, activation=act_func))\n    model.add(Dense(num_classes, activation='softmax'))\n    model.summary()\n    return model\n\ndef create_model_pattern_with_dp(act_func):\n    model = Sequential()\n    model.add(Conv2D(20, kernel_size=(3, 3),activation=act_func,input_shape=(28,28,1)))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Dropout(0.2))\n    model.add(Conv2D(40, kernel_size=(3,3), activation=act_func))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Dropout(0.2))\n    model.add(Flatten())\n    model.add(Dropout(0.2))\n    model.add(Dense(30, activation=act_func))\n    model.add(Dense(num_classes, activation='softmax'))\n    model.summary()\n    return model\n\nmodel_r = create_model_pattern_without_dp('relu')\nmodel_s = create_model_pattern_without_dp('sigmoid')\n\nmodel_rdp = create_model_pattern_without_dp('relu')\nmodel_sdp = create_model_pattern_without_dp('sigmoid')\n\n# model_r, model_s, model_rdp, model_sdp","683027d3":"# Compilando os modelos\ndef compile_model(model, loss_func='categorical_crossentropy'):\n    model.compile(loss=loss_func,\n              optimizer=RMSprop(),\n              metrics=['accuracy'])\n    return model\n\nmodel_r = compile_model(model_r)\nmodel_s = compile_model(model_s)\nmodel_rdp = compile_model(model_rdp)\nmodel_sdp = compile_model(model_sdp)\n\nmodel_r_sp = compile_model(model_r, 'sparse_categorical_crossentropy')\nmodel_s_sp = compile_model(model_s, 'sparse_categorical_crossentropy')\nmodel_rdp_sp = compile_model(model_rdp, 'sparse_categorical_crossentropy')\nmodel_sdp_sp = compile_model(model_sdp, 'sparse_categorical_crossentropy')","e777ef3a":"def train_model(model, name, batch_size=10, epochs=5):\n    #Salvar o melhor modelo\n    callbacks_list = [\n        keras.callbacks.ModelCheckpoint(\n            filepath=f'model.{name}',\n            monitor='val_loss', save_best_only=True, verbose=1),\n        keras.callbacks.EarlyStopping(monitor='val_loss', patience=10,verbose=1)\n    ]\n\n    modelo_test = models[1]\n    history = models[1].fit(x_train, y_train,\n                        batch_size=batch_size,\n                        epochs=epochs,\n                        callbacks = callbacks_list,\n                        verbose=1,\n                        validation_data=(x_val, y_val))\n\nmodel_r = train_model(model=model_r, name='model_r')\nmodel_s = train_model(model=model_s, name='model_s')\nmodel_rdp = train_model(model=model_rdp, name='model_rdp')\nmodel_sdp = train_model(model=model_sdp, name='model_sdp')\n\nmodel_r_sp = train_model(model=model_r, name='model_r_sp')\nmodel_s_sp = train_model(model=model_s, name='model_s_sp')\nmodel_rdp_sp = train_model(model=model_rdp, name='model_rdp_sp')\nmodel_sdp_sp = train_model(model=model_sdp, name='model_sdp_sp')","b3147aca":"model_r = load_model('model.model_r')\nmodel_s = load_model('model.model_s')\nmodel_rdp = load_model('model.model_rdp')\nmodel_sdp = load_model('model.model_sdp')\nmodel_r_sp = load_model('model.model_r_sp')\nmodel_s_sp = load_model('model.model_s_sp')\nmodel_rdp_sp = load_model('model.model_rdp_sp')\nmodel_sdp_sp = load_model('model.model_sdp_sp')","d77c3970":"loss = [model_r.evaluate(x_val, y_val, verbose=0)[0],\n        model_s.evaluate(x_val, y_val, verbose=0)[0],\n        model_rdp.evaluate(x_val, y_val, verbose=0)[0],\n        model_sdp.evaluate(x_val, y_val, verbose=0)[0],\n        model_r_sp.evaluate(x_val, y_val, verbose=0)[0],\n        model_s_sp.evaluate(x_val, y_val, verbose=0)[0],\n        model_rdp_sp.evaluate(x_val, y_val, verbose=0)[0],\n        model_sdp_sp.evaluate(x_val, y_val, verbose=0)[0]\n]\naccu = [model_r.evaluate(x_val, y_val, verbose=0)[1],\n        model_s.evaluate(x_val, y_val, verbose=0)[1],\n        model_rdp.evaluate(x_val, y_val, verbose=0)[1],\n        model_sdp.evaluate(x_val, y_val, verbose=0)[1],\n        model_r_sp.evaluate(x_val, y_val, verbose=0)[1],\n        model_s_sp.evaluate(x_val, y_val, verbose=0)[1],\n        model_rdp_sp.evaluate(x_val, y_val, verbose=0)[1],\n        model_sdp_sp.evaluate(x_val, y_val, verbose=0)[1]\n]\nlabel = ['activation:relu, sem dropup, Loss:categorical_crossentropy',\n         'activation:sigmoid, sem dropup, Loss:categorical_crossentropy',\n         'activation:relu, com dropup, Loss:categorical_crossentropy',\n         'activation:sigmoid, com dropup, Loss:categorical_crossentropy',\n         'activation:relu, sem dropup, Loss:sparse_categorical_crossentropy',\n         'activation:sigmoid, sem dropup, Loss:sparse_categorical_crossentropy',\n         'activation:relu, com dropup, Loss:sparse_categorical_crossentropy',\n         'activation:sigmoid, com dropup, Loss:sparse_categorical_crossentropy',\n         ]\n\nfrom tabulate import tabulate\nimport pandas as pd\n\ndf = pd.DataFrame({'Test loss' : loss,\n                   'Test accuracy:' : accu},\n                  index=label)\nprint(tabulate(df, headers='keys', tablefmt='psql'))","38adea08":"def report_model(model, name=''):\n    # Classificando toda base de teste\n    y_pred = model.predict_classes(x_val)\n    # voltando pro formato de classes\n    y_test_c = np.argmax(y_val, axis=1)\n    target_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n    print(f'Classification Report {name}')\n    print(classification_report(y_test_c, y_pred, target_names=target_names))\n    print('\\n\\n')\n    \nreport_model(model_r, 'activation:relu, sem dropup, Loss:categorical_crossentropy')\nreport_model(model_s, 'activation:sigmoid, sem dropup, Loss:categorical_crossentropy')\nreport_model(model_rdp, 'activation:relu, com dropup, Loss:categorical_crossentropy')\nreport_model(model_sdp, 'activation:sigmoid, com dropup, Loss:categorical_crossentropy')\nreport_model(model_r_sp, 'activation:relu, sem dropup, Loss:sparse_categorical_crossentropy')\nreport_model(model_s_sp, 'activation:sigmoid, sem dropup, Loss:sparse_categorical_crossentropy')\nreport_model(model_rdp_sp, 'activation:relu, com dropup, Loss:sparse_categorical_crossentropy')\nreport_model(model_sdp_sp, 'activation:sigmoid, com dropup, Loss:sparse_categorical_crossentropy')","924a3120":"model_1 = Sequential()\nmodel_1.add(Conv2D(20, kernel_size=(3, 3),activation='sigmoid',input_shape=(28,28,1)))\nmodel_1.add(MaxPooling2D(pool_size=(2, 2)))\nmodel_1.add(Dropout(0.2))\nmodel_1.add(Conv2D(40, kernel_size=(3,3), activation='sigmoid'))\nmodel_1.add(MaxPooling2D(pool_size=(2, 2)))\nmodel_1.add(Dropout(0.2))\nmodel_1.add(Flatten())\nmodel_1.add(Dropout(0.2))\nmodel_1.add(Dense(30, activation='sigmoid'))\nmodel_1.add(Dense(num_classes, activation='softmax'))\nmodel_1.summary()\n\n# Compilando os modelos\nmodel_1.compile(loss='sparse_categorical_crossentropy',\n          optimizer=RMSprop(),\n          metrics=['accuracy'])\n\ndef train_model_1(model, name, batch_size=10, epochs=5):\n    #Salvar o melhor modelo\n    callbacks_list = [\n        keras.callbacks.ModelCheckpoint(\n            filepath=f'model.{name}',\n            monitor='val_loss', save_best_only=True, verbose=1),\n        keras.callbacks.EarlyStopping(monitor='val_loss', patience=10,verbose=1)\n    ]\n\n    modelo_test = models[1]\n    history = models[1].fit(x_train, y_train,\n                        batch_size=batch_size,\n                        epochs=epochs,\n                        callbacks = callbacks_list,\n                        verbose=1,\n                        validation_data=(x_val, y_val))\n","56728086":"train_model_1(model, 'test1', batch_size=10, epochs=10)\ntrain_model_1(model, 'test2', batch_size=20, epochs=10)\ntrain_model_1(model, 'test3', batch_size=20, epochs=20)","dbd2d63e":"model_test1 = load_model('model.test1')\nmodel_test2 = load_model('model.test2')\nmodel_test3 = load_model('model.test3')\n\nloss = [model_test1.evaluate(x_val, y_val, verbose=0)[0],\n        model_test2.evaluate(x_val, y_val, verbose=0)[0],\n        model_test3.evaluate(x_val, y_val, verbose=0)[0]\n]\naccu = [model_test1.evaluate(x_val, y_val, verbose=0)[1],\n        model_test2.evaluate(x_val, y_val, verbose=0)[1],\n        model_test3.evaluate(x_val, y_val, verbose=0)[1]\n]\n\nlabel = ['test1', 'test2', 'test3']\n\nfrom tabulate import tabulate\nimport pandas as pd\n\ndf = pd.DataFrame({'Test loss' : loss,\n                   'Test accuracy:' : accu},\n                  index=label)\nprint(tabulate(df, headers='keys', tablefmt='psql'))\n","20e7d589":"def report_model_1(model, name=''):\n    # Classificando toda base de teste\n    y_pred = model.predict_classes(x_val)\n    # voltando pro formato de classes\n    y_test_c = np.argmax(y_val, axis=1)\n    target_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n    print(f'Classification Report {name}')\n    print(classification_report(y_test_c, y_pred, target_names=target_names))\n    print('\\n\\n')\n    \nreport_model_1(model_test1, 'Test1')\nreport_model_1(model_test2, 'Test2')\nreport_model_1(model_test3, 'Test3')","82d9c2b6":"# Criando o modelo Sequential\n# Sequential: Modelo Keras de ir adicionando camadas (como um lego)\n# Conv2D: Camada com kernels (filtros) que percorrem a imagem extraindo caracter\u00edsitcas (mapas de caracte\u00edsticas)\n# MaxPooling2D: Camada que reduz a dimensionalidade dos mapas de caracter\u00edsticas 2D\n# Flatten: Camada que transforma um mapa de caracter\u00edsticas 2D num vetor para classficador final\n# Dense: Camada onde todas as entradas est\u00e3o conectadas em cada neur\u00f4nio (totalmente conectada)\n# Dropout: Camada usa durante treino que descarta aleatoriamente um percentual de conex\u00f5es (reduz overfitting)\n\nmodel = Sequential()\nmodel.add(Conv2D(20, kernel_size=(3, 3),\n                 activation='relu',\n                 input_shape=(28,28,1)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(40, kernel_size=(3,3), activation='relu'))\nmodel.add(Flatten())\nmodel.add(Dense(50, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(num_classes, activation='softmax'))\nmodel.summary()\n","09ff7ecf":"# Compila o modelo\ndef compile_model(loss_func):\n    model.compile(loss=loss_func,\n                  optimizer=RMSprop(),\n                  metrics=['accuracy'])\n    \n# categorical_crossentropy","faee67a7":"# Treina com os parte dos dados\nbatch_size = 32\nepochs = 5\n\n#Salvar o melhor modelo\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model.h5',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=10,verbose=1)\n]\n\nhistory = model.fit(x_train, y_train,\n                    batch_size=batch_size,\n                    epochs=epochs,\n                    callbacks = callbacks_list,\n                    verbose=1,\n                    validation_data=(x_val, y_val))","b882b41c":"#Vamos ver como foi o treino?\nfig, ax = plt.subplots(1,2, figsize=(16,8))\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","dc00de5d":"from tensorflow.keras.models import load_model\n# Load the best saved model\nmodel = load_model('model.h5')","01e8a94f":"# Testa\nscore = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","6a2d71ce":"# Testando uma entrada qualquer\nprint(y_train[10])\nprint(model.predict(x_train[10].reshape((1,28,28,1))))\nprint(model.predict_classes(x_train[10].reshape((1,28,28,1))))","7a962ff7":"import itertools\n\n#Plot the confusion matrix. Set Normalize = True\/False\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","68ad0888":"# Vendo alguns reports# Vendo alguns reports\n# Usando sklearn\nimport numpy as np\n\n# Classificando toda base de teste\ny_pred = model.predict_classes(x_val)\n# voltando pro formato de classes\ny_test_c = np.argmax(y_val, axis=1)\ntarget_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n#Confution Matrix\ncm = confusion_matrix(y_test_c, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(y_test_c, y_pred, target_names=target_names))","77eb45c2":"# Gerando sa\u00edda para dataset de teste\n\n#Carrega dataset de teste\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\nprint(\"Qtde de testes: {}\".format(len(test)))\n# Bota no formato numpy e normaliza\nx_test = test.values.reshape(len(test),28,28,1)\nx_test = x_test.astype('float32')\nx_test \/= 255\n\n# Faz classifica\u00e7\u00e3o para dataset de teste\ny_pred = model.predict_classes(x_test)\n\n# Verficando algum exemplo\ni = 0\nplt.imshow(test.values[i].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Previsto: {}'.format(y_pred[i]))\n\n# Botando no formato de sa\u00edda (competi\u00e7\u00e3o Kaggle)\nresults = pd.Series(y_pred,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,len(y_pred)+1),name = \"ImageId\"),results],axis = 1)\nprint(submission.head(10))\n#Salvando Arquivo\nsubmission.to_csv(\"mlp_mnist_v1.csv\",index=False)","6e7cd98f":"#introduzindo ruido\nimport numpy as np\nmean = 0.\nstddev = 0.2\nnoise = np.random.normal(mean, stddev, (4200, 28, 28,1))\nx_te = x_val + noise\nx_te = np.clip(x_te, 0., 1.)\n\nplt.imshow(x_te.reshape(4200, 28,28)[0], cmap=plt.cm.binary)\nplt.show()\n\n# Testa\nscore = model.evaluate(x_te, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","674efea1":"# Teste Adicional: Com ru\u00eddo","9125db74":"**Resumo:**\n\nO exemplo aqui desenvolvido tem como objetivo apresentar conceitos iniciais de implementa\u00e7\u00e3o de redes neurais com python e tensorflow\/keras. Esse modelo apresenta um modelo de Rede Neural Convolucional (CNN) b\u00e1sico que pode ser expandido mudando o n\u00famero de neur\u00f4nios e camadas. Em adapta\u00e7\u00f5es mais avan\u00e7adas, pode-se estudar possibilidade de otimiza\u00e7\u00e3o de hyperpar\u00e2metros e outras t\u00e9cnincas como aumento de dados.\n\n**N\u00e3o \u00e9 objetivo nosso desenvolver e otimizar o modelo de classifica\u00e7\u00e3o**. O exemplo tem objetivo meramente did\u00e1tico.\n\n---\n\n**Para saber mais:**\n* [Palestras e cursos do Ocean](http:\/\/www.oceanbrasil.com\/)\n* Fran\u00e7ois Chollet. Deep Learning with Python. Manning Publications, 2017.\n* Ian Goodfellow and Yoshua Bengio and Aaron Courville. [Deep Learning](https:\/\/www.deeplearningbook.org\/). MIT Press, 2016.","f93b6715":"# Avaliando o Modelo","3756be53":"# Gerando Sa\u00edda","30e1cb0b":"# Bibliotecas e Dados","1e27ff5d":"## Ajustandando fun\u00e7\u00e3o de ativa\u00e7\u00e3o e loss","16ecf20f":"# Criando e treinando o Modelo - base","c4b0c53d":"# Introdu\u00e7\u00e3o","b15177dd":"## Ajustandando batch_size e epochs","d891c5c9":"Com ru\u00eddo, percebemos que a acur\u00e1cia dos exemplos de valida\u00e7\u00e3o caiu, mas muito menos que o modelo MLP cl\u00e1ssico (ver exemplo de MLP).\nUm modelo Convolucional (CNN) captura melhor regi\u00f5es, ou padr\u00f5es espaciais de pixels, tornando o modelo mais robusto.","3200ed1a":"# Criando e treinando Modelos -  alterados"}}