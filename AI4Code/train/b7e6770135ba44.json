{"cell_type":{"82d98b5f":"code","1329448c":"code","25fb2653":"code","886d3768":"code","ea5f4e17":"code","09af1c43":"code","a5d717d5":"code","bc3bcb03":"code","f06cc699":"code","dd56d647":"code","da3b3163":"code","f8f419c6":"code","96edc806":"code","98379e64":"code","796f79b8":"code","78102151":"code","7b5d5ac5":"code","4c6143d6":"code","a5f07a93":"code","d9469a82":"code","f9a30aec":"code","725c68b9":"code","f012d7a6":"code","e23f9429":"code","8c7b0c9c":"code","a9c19069":"code","003c1d77":"code","b85ac706":"code","ac2168f6":"code","6bb5330b":"code","43aa440b":"code","53807a36":"code","98ec702c":"code","be5ac826":"code","55e60358":"code","e9405e0a":"code","46a46289":"code","4ebfbe56":"markdown","d89e23bb":"markdown","d45cc558":"markdown","e6cd9d26":"markdown","f97b188f":"markdown","5e67a5f5":"markdown","039645ce":"markdown","cc2fe260":"markdown","75484c6c":"markdown","574754a3":"markdown","167e919c":"markdown","53d7a266":"markdown","7343f65b":"markdown","f70f0ec9":"markdown","f6abbec1":"markdown","f458d970":"markdown","4cd23937":"markdown","2955c7f8":"markdown","4fb291a4":"markdown","bd732570":"markdown","ff072e31":"markdown","9236c408":"markdown","402a153c":"markdown","8fde9621":"markdown","1e495f00":"markdown","fc7d6c08":"markdown","c08f304f":"markdown","5b076d60":"markdown","2b551f3a":"markdown","ac29f95d":"markdown","52e4f5e3":"markdown","309f5928":"markdown","5db93392":"markdown","0adba204":"markdown","bf8891d7":"markdown","e3dcf78c":"markdown","99972f2a":"markdown","1fbd3fcb":"markdown","bb4e3f43":"markdown","b84fa7d4":"markdown","f2099c19":"markdown","96c1e18c":"markdown","870427da":"markdown","e766f1f3":"markdown"},"source":{"82d98b5f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","1329448c":"pip install six","25fb2653":"pip install mlrose","886d3768":"#sklearn.externals.six paketinin hatas\u0131n\u0131n \u00e7\u00f6z\u00fcm\u00fc maksad\u0131yla ayr\u0131ca mod\u00fcl indirimi yap\u0131lm\u0131\u015ft\u0131r.\nimport six\nimport sys\nsys.modules['sklearn.externals.six'] = six\nimport mlrose\nimport pandas as pd\nfrom geopy import distance\nimport requests # to call the openmap\/google apis\nimport json\nimport datetime\nimport math\nimport itertools\n\n# E\u011fer sklearn.external six paketi ile problemle kar\u015f\u0131la\u015f\u0131r iseniz yard\u0131mc\u0131 link: https:\/\/stackoverflow.com\/questions\/61867945\/python-import-error-cannot-import-name-six-from-sklearn-externals\n# Normalde original paket indirimi \u015f\u00f6yle yap\u0131l\u0131r:\n#from sklearn.external import six\n# to:\n# import six\nimport mlrose #travelling salesman problem \u00e7\u00f6z\u00fcm\u00fc i\u00e7in\n\n# that was fixed in mlrose_hiive, though the outputs are different\n#import mlrose_hiive\nimport numpy as np\nimport six\nimport sys\nimport six\nimport sys\nsys.modules['sklearn.externals.six'] = six\nimport mlrose\nimport pandas as pd\nfrom geopy import distance\nimport six\n# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport random\nimport numpy as np\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nimport math\nimport pandas as pd\nfrom sympy import isprime\nfrom multiprocessing import Pool\n","ea5f4e17":"df_cities= pd.read_csv('..\/input\/traveling-santa-2018-prime-paths\/cities.csv')\ndf_cities.head()","09af1c43":"fig = plt.figure(figsize=(10,10))\n#cmap, norm = from_levels_and_colors([0.0, 0.5, 1.5], ['red', 'black'])\nplt.scatter(df_cities['X'],df_cities['Y'],marker = '.',\n            c=(df_cities.CityId != 0).astype(int), cmap='Set1', \n            alpha = 0.6, s = 500*(df_cities.CityId == 0).astype(int)+1)\nplt.show()","a5d717d5":"# The function to get the distance between the cities.\ndef distance(x1, y1, x2, y2, prev_is_prime, is_10th):\n    # Every 10th step is 10% more lengthy unless coming from a prime CityId.\n    cost_factor = 1.1 if is_10th and not prev_is_prime else 1.0\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) * cost_factor\n\n# The function to calculate score.\n\ndef calculate_score(path, cities_df_dict):\n    # The beginning and end of the paths must be City'0'.\n    paths = [0]\n    paths.extend(path)\n    paths.extend([0])\n\n    sum_distance = 0\n    prev_x, prev_y = cities_df_dict['X'][0], cities_df_dict['Y'][0]\n    prev_is_prime = False\n\n    for i, city in enumerate(paths):\n        x, y = cities_df_dict['X'][city], cities_df_dict['Y'][city]\n        is_prime = cities_df_dict['IsPrime'][city]\n\n        sum_distance += distance(prev_x, prev_y, x, y, prev_is_prime, i % 10 == 0)\n        prev_x, prev_y = x, y\n        prev_is_prime = is_prime\n\n    return sum_distance","bc3bcb03":"df_cities['IsPrime'] = df_cities.CityId.apply(isprime)\ncities_df_dict       = df_cities.to_dict()\n\ndf_cities.head(4)","f06cc699":"%%time\n# test time in calc\nsample_path = df_cities.CityId[:].values[1:]\nfor i in range(100):\n    score = calculate_score(sample_path, cities_df_dict)","dd56d647":"# start and end in the nort (0)\npath  = df_cities.CityId[:].values[1:]\nscore = calculate_score(path, cities_df_dict)\nprint('Total distance with the dumbest path is '+ \"{:,}\".format(score))\n#446884407.52","da3b3163":"dumbest_path = path\n\ndef plot_sample_path(path):\n    df_path = pd.merge_ordered(pd.DataFrame({'CityId':path}),df_cities,on=['CityId'])\n    fig, ax = plt.subplots(figsize=(10,10))\n    ax.plot(df_path.iloc[0:100,]['X'], df_path.iloc[0:100,]['Y'],marker = 'o')\n    for i, txt in enumerate(df_path.iloc[0:100,]['CityId']):\n        ax.annotate(txt, (df_path.iloc[0:100,]['X'][i], df_path.iloc[0:100,]['Y'][i]),size = 15)\n        \nplot_sample_path(dumbest_path)","f8f419c6":"df_cities.head(5)","96edc806":"print(\"All cities: \", df_cities.shape)\nprint(\"Prime cities: \", df_cities[df_cities.IsPrime].shape)","98379e64":"\"\"\"Genetic Algorithmn Implementation\nsee:\nhttp:\/\/www.obitko.com\/tutorials\/genetic-algorithms\/ga-basic-description.php\n\"\"\"\nclass GeneticAlgorithm(object):\n    def __init__(self, genetics):\n        self.genetics       = genetics\n        self.best_solution  = None\n        self.avg_fitness    = []\n        pass\n\n    def fitness(self, ch):\n        return (self.genetics.fitness(ch),  ch)\n    \n    def run(self, processes=4):\n        population = self.genetics.initial()\n        pool       = Pool(processes=processes)\n        \n        while True:\n            fits_pops = [self.fitness(ch) for ch in population]\n            fits_pops = list(sorted(fits_pops))\n            #fits_pops   = pool.map(self.fitness, population)\n\n            # Log\n            self.avg_fitness.append(np.mean([f for f, ch in fits_pops]))\n            self.best_solution = fits_pops[0][1]\n            \n            if self.genetics.check_stop(fits_pops): \n                break\n            \n            population = self.next(fits_pops)\n            pass\n        return population\n\n    def next(self, fits):\n        parents_generator = self.genetics.parents(fits)\n        size  = len(fits)\n        nexts = [self.best_solution.copy()]\n        while len(nexts) < size:\n            parents  = next(parents_generator)\n            cross    = random.random() < self.genetics.probability_crossover()\n            children = self.genetics.crossover(parents) if cross else parents\n\n            for ch in children:\n                mutate = random.random() < self.genetics.probability_mutation()\n                nexts.append(self.genetics.mutation(ch) if mutate else ch)\n                pass\n            pass\n        return nexts[0:size]\n    pass","796f79b8":"class TravelingSanta():\n    def __init__(self, df_cities, generation=10, size=5,\n                 prob_crossover=0.9, \n                 prob_mutation=0.2):\n        self.df_cities  = df_cities\n        \n        self.counter   = 0\n        \n        self.generation = generation\n        self.size  = size        \n        self.prob_crossover = prob_crossover\n        self.prob_mutation  = prob_mutation\n        self.cities_df_dict = df_cities.to_dict()\n\n    # GeneticFunctions interface impls\n    def probability_crossover(self):\n        return self.prob_crossover\n\n    def probability_mutation(self):\n        return self.prob_mutation\n\n    # Initial population based in s0\n    def initial(self):\n        population = [self.random_chromo() for j in range(self.size)]\n        return population\n\n    def fitness(self, chromo):\n        score = calculate_score(chromo, self.cities_df_dict)\n        \n        return score\n\n    def check_stop(self, fits_populations):\n        self.counter += 1\n        \n        if self.counter % 2 == 0:\n\n            fits  = [f for f, ch in fits_populations]\n            best  = min(fits)\n            worst = max(fits)\n            ave   = sum(fits) \/ len(fits)\n            print(\n                \"[G %3d] score=(%2f, %2f, %2f, %2f): %r\" %\n                (self.counter, best, ave, worst, len(fits), []))\n            pass\n\n        return self.counter >= self.generation\n\n    def parents(self, fits_populations):\n        while True:\n            father = self.tournament(fits_populations)\n            mother = self.tournament(fits_populations)\n            yield (father, mother)\n            pass\n        pass\n\n    def crossover(self, parents):\n        ind1, ind2 = parents\n        \n        size = min(len(ind1), len(ind2))\n        a, b = random.sample(range(size), 2)\n        if a > b:\n            a, b = b, a\n\n        holes1, holes2 = [True]*size, [True]*size\n        for i in range(size):\n            if i < a or i > b:\n                holes1[ind2[i]-1] = False\n                holes2[ind1[i]-1] = False\n\n        # We must keep the original values somewhere before scrambling everything\n        temp1, temp2 = ind1, ind2\n        k1 , k2 = b + 1, b + 1\n        for i in range(size):\n            if not holes1[temp1[(i + b + 1) % size]-1]:\n                ind1[k1 % size] = temp1[(i + b + 1) % size]\n                k1 += 1\n\n            if not holes2[temp2[(i + b + 1) % size]-1]:\n                ind2[k2 % size] = temp2[(i + b + 1) % size]\n                k2 += 1\n\n        # Swap the content between a and b (included)\n        for i in range(a, b + 1):\n            ind1[i], ind2[i] = ind2[i], ind1[i]\n\n        return ind1, ind2\n\n    def mutation(self, chromosome):\n        mutated = chromosome\n        \n        for i in range(int(len(chromosome)*0.05)):\n            i1 = random.randint(0, len(chromosome)-1)\n            i2 = random.randint(0, len(chromosome)-1)\n        \n            origin       = mutated[i1]\n            mutated[i1]  = mutated[i2]\n            mutated[i2]  = origin\n\n        return mutated\n\n    def tournament(self, fits_populations):\n        alicef, alice = self.select_random(fits_populations)\n        bobf, bob = self.select_random(fits_populations)\n        return alice if alicef < bobf else bob\n\n    def select_random(self, fits_populations):\n        return fits_populations[random.randint(0, len(fits_populations)-1)]\n\n    def random_chromo(self):\n        chromo = list(df_cities.CityId.sample(frac=1).values)\n        return chromo\n    pass","78102151":"%%time\n\ngeneration      = 100\npopulation_size = 100\nprob_crossover  = 0.9\nprob_mutation   = 0.2\n\nga = GeneticAlgorithm(\n    TravelingSanta(df_cities, generation=generation, size=population_size, \n                   prob_crossover=prob_crossover, prob_mutation=prob_mutation)\n)\n\nbest_solution = ga.run()","7b5d5ac5":"fig, ax = plt.subplots(figsize=(10,6))\nax.plot(ga.avg_fitness)","4c6143d6":"path       = [0] + ga.best_solution + [0]\nsubmission = pd.DataFrame({\"Path\": path})\nsubmission.to_csv(\"gezgin_sat\u0131c\u0131_problemi_output_ga.csv\", index=None)","a5f07a93":"%matplotlib inline\nfrom matplotlib import pyplot as plt","d9469a82":"from matplotlib import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport random \n","f9a30aec":"df_cities= pd.read_csv('..\/input\/traveling-santa-2018-prime-paths\/cities.csv')\ndf_cities.head()","725c68b9":"fig = plt.figure(figsize=(20,20))\n#cmap, norm = from_levels_and_colors([0.0, 0.5, 1.5], ['red', 'black'])\nplt.scatter(df_cities['X'],df_cities['Y'],marker = '.',c=(df_cities.CityId != 0).astype(int), cmap='Set1', alpha = 0.6, s = 500*(df_cities.CityId == 0).astype(int)+1)\nplt.show()","f012d7a6":"# pozisyona g\u00f6re asal olup olmad\u0131\u011f\u0131. \n\n# eratosten elek metodu kullanarak\ndef sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)] # Start assuming all numbers are primes\n    primes[0] = False # 0 is not a prime\n    primes[1] = False # 1 is not a prime\n    for i in range(2,int(np.sqrt(n)) + 1):\n        if primes[i]:\n            k = 2\n            while i*k <= n:\n                primes[i*k] = False\n                k += 1\n    return(primes)\nprime_cities = sieve_of_eratosthenes(max(df_cities.CityId))","e23f9429":"def total_distance(dfcity,path):\n    prev_city = path[0]\n    total_distance = 0\n    step_num = 1\n    for city_num in path[1:]:\n        next_city = city_num\n        total_distance = total_distance + \\\n            np.sqrt(pow((dfcity.X[city_num] - dfcity.X[prev_city]),2) + pow((dfcity.Y[city_num] - dfcity.Y[prev_city]),2)) * \\\n            (1+ 0.1*((step_num % 10 == 0)*int(not(prime_cities[prev_city]))))\n        prev_city = next_city\n        step_num = step_num + 1\n    return total_distance\n\ndumbest_path = list(df_cities.CityId[:].append(pd.Series([0])))\nprint('Total distance with the dumbest path is '+ \"{:,}\".format(total_distance(df_cities,dumbest_path)))","8c7b0c9c":"df_path = pd.merge_ordered(pd.DataFrame({'CityId':dumbest_path}),df_cities,on=['CityId'])\nfig, ax = plt.subplots(figsize=(20,20))\nax.plot(df_path.iloc[0:100,]['X'], df_path.iloc[0:100,]['Y'],marker = 'o')\nfor i, txt in enumerate(df_path.iloc[0:100,]['CityId']):\n    ax.annotate(txt, (df_path.iloc[0:100,]['X'][i], df_path.iloc[0:100,]['Y'][i]),size = 15)","a9c19069":"sorted_cities = list(df_cities.iloc[1:,].sort_values(['X','Y'])['CityId'])\nsorted_cities = [0] + sorted_cities + [0]\nprint('Total distance with the sorted city path is '+ \"{:,}\".format(total_distance(df_cities,sorted_cities)))","003c1d77":"df_path = pd.DataFrame({'CityId':sorted_cities}).merge(df_cities,how = 'left')\nfig, ax = plt.subplots(figsize=(20,20))\nax.set_xlim(0,10)\nax.plot(df_path.iloc[0:100,]['X'], df_path.iloc[0:100,]['Y'],marker = 'o')\nfor i, txt in enumerate(df_path.iloc[0:100,]['CityId']):\n    ax.annotate(txt, (df_path.iloc[0:100,]['X'][i], df_path.iloc[0:100,]['Y'][i]),size = 15)","b85ac706":"df_cities['Ycuts'] = pd.cut(df_cities.Y,300)\ndf_cities['Xcuts'] = pd.cut(df_cities.X,300)\ngrid_sorted_cities = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'])['CityId'])\ngrid_sorted_cities =  [0] + grid_sorted_cities + [0]\nprint('Total distance with the sorted cities with a grid path is '+ \"{:,}\".format(total_distance(df_cities,grid_sorted_cities)))","ac2168f6":"df_path = pd.DataFrame({'CityId':grid_sorted_cities}).merge(df_cities,how = 'left')\nfig, ax = plt.subplots(figsize=(20,20))\nax.plot(df_path.iloc[0:1000,]['X'], df_path.iloc[0:1000,]['Y'],marker = 'o')","6bb5330b":"zigzag_sorted_cities1 = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'])['CityId'])\nzigzag_sorted_cities2 = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'], ascending = [True,False,True,True])['CityId'])\nchooser_pattern = list(df_cities.iloc[1:].sort_values(['Xcuts']).groupby(['Xcuts']).ngroup()%2)\n\nzigzag_cities = [zigzag_sorted_cities1[i] if chooser_pattern[i] == 0 else zigzag_sorted_cities2[i] for i in range(len(chooser_pattern))]\nzigzag_cities =  [0] + zigzag_cities + [0]\nprint('Total distance with the Zig-Zag with grid city path is '+ \"{:,}\".format(total_distance(df_cities,zigzag_cities)))","43aa440b":"df_path = pd.DataFrame({'CityId':zigzag_cities}).merge(df_cities,how = 'left')\nfig, ax = plt.subplots(figsize=(20,20))\nax.plot(df_path.iloc[0:1000,]['X'], df_path.iloc[0:1000,]['Y'],marker = 'o')","53807a36":"for i in range(100,600,100):\n    for j in range(100,600,100):\n        df_cities['Ycuts'] = pd.cut(df_cities.Y,j)\n        df_cities['Xcuts'] = pd.cut(df_cities.X,i)\n        zigzag_sorted_cities1 = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'])['CityId'])\n        zigzag_sorted_cities2 = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'], ascending = [True,False,True,True])['CityId'])\n        chooser_pattern = list(df_cities.iloc[1:].sort_values(['Xcuts']).groupby(['Xcuts']).ngroup()%2)\n\n        zigzag_cities = [zigzag_sorted_cities1[i] if chooser_pattern[i] == 0 else zigzag_sorted_cities2[i] for i in range(len(chooser_pattern))]\n        zigzag_cities =  [0] + zigzag_cities + [0]\n        print('Total distance with the Zig-Zag with grid city path with grid size (' + str(i) + ',' + str(j) + \") is {:,}\".format(total_distance(df_cities,zigzag_cities)))","98ec702c":"df_path = pd.DataFrame({'CityId':zigzag_cities}).merge(df_cities,how = 'left')\nfig, ax = plt.subplots(figsize=(20,20))\nax.plot(df_path['X'], df_path['Y'])","be5ac826":"def nearest_neighbour():\n    \n    cities= pd.read_csv('..\/input\/traveling-santa-2018-prime-paths\/cities.csv')\n    ids = cities.CityId.values[1:]\n    xy = np.array([cities.X.values, cities.Y.values]).T[1:]\n    path = [0,]\n    while len(ids) > 0:\n        last_x, last_y = cities.X[path[-1]], cities.Y[path[-1]]\n        dist = ((xy - np.array([last_x, last_y]))**2).sum(-1)\n        nearest_index = dist.argmin()\n        path.append(ids[nearest_index])\n        ids = np.delete(ids, nearest_index, axis=0)\n        xy = np.delete(xy, nearest_index, axis=0)\n    path.append(0)\n    return path\n\nnnpath = nearest_neighbour()\nprint('Total distance with the Nearest Neighbor path '+  \"is {:,}\".format(total_distance(df_cities,nnpath)))","55e60358":"df_path = pd.DataFrame({'CityId':nnpath}).merge(df_cities,how = 'left')\nfig, ax = plt.subplots(figsize=(20,20))\nax.plot(df_path['X'], df_path['Y'])","e9405e0a":"nnpath_with_primes = nnpath.copy()\nfor index in range(20,len(nnpath_with_primes)-30):\n    city = nnpath_with_primes[index]\n    if (prime_cities[city] &  ((index+1) % 10 != 0)):        \n        for i in range(-1,3):\n            tmp_path = nnpath_with_primes.copy()\n            swap_index = (int((index+1)\/10) + i)*10 - 1\n            tmp_path[swap_index],tmp_path[index] = tmp_path[index],tmp_path[swap_index]\n            if total_distance(df_cities,tmp_path[min(swap_index,index) - 1 : max(swap_index,index) + 2]) < total_distance(df_cities,nnpath_with_primes[min(swap_index,index) - 1 : max(swap_index,index) + 2]):\n                nnpath_with_primes = tmp_path.copy() \n                break\nprint('Total distance with the Nearest Neighbor With Prime Swaps '+  \"is {:,}\".format(total_distance(df_cities,nnpath_with_primes)))","46a46289":"pd.DataFrame({'Path':nnpath_with_primes}).to_csv('M.Kutlu_SENGUL_TSP3_NN_Prime.csv',index  = False)","4ebfbe56":" ### Genetik Algoritma Hesaplama","d89e23bb":" \u00c7al\u0131\u015fmaya, NP-Complete problemini daha iyi anlayabilmek amac\u0131yla ilk \u00f6nce baz\u0131 basit aptal yakla\u015f\u0131mlarla ba\u015flan\u0131lm\u0131\u015ft\u0131r  ve hangi a\u015famaya g\u00f6t\u00fcrd\u00fckleri test edilmi\u015ftir.","d45cc558":"Dumbest pat'in (En aptal yolun) ilk 100 ad\u0131m\u0131na bir g\u00f6z atal\u0131m","e6cd9d26":"#### Basit bir s\u0131ralama kullanarak toplam mesafemizi zaten yar\u0131dan fazla azaltt\u0131k !! Haritada nas\u0131l g\u00f6r\u00fcnd\u00fc\u011f\u00fcne bakal\u0131m (yak\u0131nla\u015ft\u0131r\u0131lm\u0131\u015f).","f97b188f":"#### Yukar\u0131daki yolda g\u00f6rebilece\u011fimiz yukar\u0131daki sorunlardan biri, Sat\u0131c\u0131n\u0131n(Noel Baba'n\u0131n) en y\u00fcksek Y'ye sahip \u015fehre ula\u015ft\u0131\u011f\u0131nda, en d\u00fc\u015f\u00fck Y'ye sahip \u015fehre geri d\u00f6nmesi ve bunun aksine zikzak bir desen izleyerek yukar\u0131 do\u011fru hareket etmeye ba\u015flamas\u0131d\u0131r. hangisi daha verimli olmal\u0131d\u0131r.","5e67a5f5":"## ### Prime Swapl\u0131 En Yak\u0131n Kom\u015fu \/ A\u00e7g\u00f6zl\u00fc Algoritma(Greedy Algoritma)","039645ce":"### #### En yak\u0131n kom\u015fu algiritmas\u0131 ile \u00e7\u00f6z\u00fclm\u00fc\u015f veri setini olu\u015ftural\u0131m.\n","cc2fe260":"En yak\u0131n kom\u015fu algoritmas\u0131 ile yolun nas\u0131l g\u00f6r\u00fcnd\u00fc\u011f\u00fcne bakal\u0131m.","75484c6c":"Tek yapmam\u0131z gereken, k\u0131rm\u0131z\u0131 noktadan giden, di\u011fer t\u00fcm noktalara dokunan ve kat edilen minimum toplam mesafe ile k\u0131rm\u0131z\u0131 noktaya geri d\u00f6nen bir yol bulmakt\u0131r.","574754a3":"#### En aptal yolun ilk 100 ad\u0131m\u0131na bir g\u00f6z atal\u0131m.","167e919c":"Asal say\u0131l\u0131 \u015fehri \u015fehri, mevcut \u015fehirden \u00f6nce gelen ve endeksi 9 ile biten iki \u015fehirle veya mevcut \u015fehirden sonra gelen ve endeksi 9 ile biten iki \u015fehirle de\u011fi\u015ftirmeye \u00e7al\u0131\u015f\u0131yoruz.","53d7a266":"#### Biraz daha iyi yol ara\u015ft\u0131rmas\u0131 i\u00e7in: \u015fehirler X,Y koordinatlar\u0131nda s\u0131ralanm\u0131\u015ft\u0131r.","7343f65b":"## ## En Yak\u0131n Kom\u015fu Algoritmas\u0131\/Greedy Sezgiseli","f70f0ec9":"#### \u00d6nceki Yolda g\u00f6rebildi\u011fimiz sorunlardan biri, Sat\u0131c\u0131n\u0131n(Noel Baba'n\u0131n) sistematik bir soldan sa\u011fa hareket etmesine ra\u011fmen, bunu yaparken Y ekseninin u\u00e7 noktalar\u0131 aras\u0131nda hareket etmesidir.","f6abbec1":"### Genetik Algoritma(Genetic Algorithm)","f458d970":"1-Bu yolun ne kadar iyi oldu\u011funu g\u00f6rmek i\u00e7in birka\u00e7 i\u015fleve ihtiyac\u0131m\u0131z var:","4cd23937":"#### Dumbest Path(En Aptal Yol)","2955c7f8":"2-Bir dizi say\u0131 verilen toplam mesafeyi hesaplamak i\u00e7in ba\u015fka bir i\u015flev","4fb291a4":"\u015eimdiye kadar optimizasyon i\u00e7in yolda asal say\u0131larla ilgili k\u0131s\u0131tlamay\u0131 kullanmad\u0131k. \"Asal bir CityId'den gelmedik\u00e7e her 10. ad\u0131m %10 daha uzundur\" diyor. Bu nedenle, asal say\u0131lar\u0131n her 10. ad\u0131m\u0131n ba\u015f\u0131nda bitmesini sa\u011flayarak algoritmam\u0131z\u0131 kurguluyoruz.","bd732570":"K\u0131rm\u0131z\u0131 nokta Kuzey Kutbu'nu g\u00f6sterir (CityId = 0).S\u00fcre\u00e7, k\u0131rm\u0131z\u0131 noktadan giden, di\u011fer t\u00fcm noktalara dokunan ve kat edilen minimum toplam mesafe ile k\u0131rm\u0131z\u0131 noktaya geri d\u00f6nen bir yol bulma s\u00fcreci olarak belirlenmi\u015ftir.","ff072e31":"\u00d6rne\u011fin 76. s\u0131rada bir asal \u015fehrimiz varsa, bunun 59., 69., 79. ve 89. s\u0131radaki \u015fehirlerden herhangi biriyle de\u011fi\u015ftirilip de\u011fi\u015ftirilemeyece\u011fini g\u00f6rmeye \u00e7al\u0131\u015faca\u011f\u0131z ve daha k\u0131sa bir yol ile sonu\u00e7lanacakt\u0131r.","9236c408":"Soruna g\u00f6re: \"g\u00f6nderim, g\u00f6nderdi\u011finiz yolun \u00d6klid mesafesine g\u00f6re puanlan\u0131r, birincil CityId'den gelmedik\u00e7e her 10. ad\u0131m\u0131n %10 daha uzun olmas\u0131 k\u0131s\u0131tlamas\u0131na tabidir.\"","402a153c":"En yak\u0131n kom\u015fu algoritmas\u0131, yakla\u015f\u0131k 2,2 milyon maliyetten 1,8 milyona \u00f6nemli bir geli\u015fme sa\u011flad\u0131.","8fde9621":"T\u00fcm \u015fehirlerin da\u011f\u0131l\u0131m grafi\u011finin \u00e7\u0131kt\u0131s\u0131 al\u0131yoruz.","1e495f00":"## Paketlerin ve K\u00fct\u00fcphanelerin \u0130ndirilmesi","fc7d6c08":"## Gezgin Sat\u0131c\u0131 Probleminin Basit Genetik Algoritma \u0130le \u00c7\u00f6z\u00fclmesi (Populer Travelling Santa \u00d6rnek Verisi ile Dumbest(Aptal yakla\u015f\u0131mlarla ilerleyerek Sonuca Ula\u015f\u0131lm\u0131\u015ft\u0131r)","c08f304f":"### Gezgin Sat\u0131c\u0131 Probleminin En Yak\u0131n Kom\u015fuluk Algorithmas\u0131 ile \/Greedy \u00c7\u00f6z\u00fcme Ula\u015ft\u0131r\u0131lmas\u0131---Genetik Algortima \u0130le Ayn\u0131 Veri Setine Sahip \u00c7al\u0131\u015fmad\u0131r.Populer Harita Gezgin Santa Harita Verileri Kullan\u0131lm\u0131\u015ft\u0131r","5b076d60":"#### Yukar\u0131daki \u00e7izimden, \u015fimdi Sat\u0131c\u0131n\u0131n(Noel Baba)'n\u0131n bir sonraki X'e ge\u00e7meden \u00f6nce ayn\u0131 X de\u011feri (X ekseninin yaln\u0131zca 0-10 aras\u0131nda de\u011fi\u015fti\u011fine dikkat edin) etraf\u0131nda yukar\u0131 ve a\u015fa\u011f\u0131 gitti\u011fini g\u00f6rebiliriz. Bu biraz daha verimli bir yoldur.","2b551f3a":"\u015eehirleri de\u011fi\u015ftirerek yolun k\u0131sal\u0131p k\u0131salmad\u0131\u011f\u0131n\u0131 kontrol ederken, sadece takasa kar\u015f\u0131l\u0131k gelen alt yolun uzunlu\u011funu kontrol edece\u011fiz. T\u00fcm yolun uzunlu\u011funu kontrol etmeye gerek yok. Bu, aramay\u0131 \u00e7ok daha verimli hale getirecektir.","ac29f95d":" #### Zig-zag yolu y\u00f6netmini  uygulayabiliyor muyuz ve biraz daha iyile\u015ftirme elde ediyor muyuz?","52e4f5e3":"300x300 \u0131zgara boyutunu keyfi olarak se\u00e7tik. \u015eimdi \u0131zgara boyutunun bir fark yarat\u0131p yaratmad\u0131\u011f\u0131n\u0131 g\u00f6relim","309f5928":"### \u00c7\u0131kt\u0131 ","5db93392":"\u015eehirler bir ren geyi\u011fi d\u00fczeninde d\u00fczenlenmi\u015f gibi g\u00f6r\u00fcn\u00fcyor.","0adba204":"Yol boyunca d\u00f6ng\u00fc yap\u0131yoruz, ne zaman asal CityId'ye sahip bir \u015fehirle kar\u015f\u0131la\u015f\u0131rsak, toplam yolu k\u00fc\u00e7\u00fclt\u00fcrse, onu 9 ile biten bir dizine sahip (yani 10. ad\u0131m) yak\u0131ndaki \u015fehirle de\u011fi\u015ftirmeye \u00e7al\u0131\u015faca\u011f\u0131z.","bf8891d7":"G\u00f6rd\u00fc\u011f\u00fcm\u00fcz gibi, en aptal yol olduk\u00e7a k\u00f6t\u00fc g\u00f6r\u00fcn\u00fcyor. Sat\u0131c\u0131y\u0131 veya Noel Baba'y\u0131 hi\u00e7 d\u00fc\u015f\u00fcnmeden haritan\u0131n her yerine g\u00f6ndermi\u015f oluyoruz.","e3dcf78c":"#### T\u00fcm haritay\u0131 X'ler ve Y'lerden olu\u015fan bir \u0131zgaraya b\u00f6lersek, Sat\u0131c\u0131(Noel Baba) bir sonraki kareye ge\u00e7meden \u00f6nce \u0131zgaradaki her kareyi kaplayabilir. A\u015fa\u011f\u0131da g\u00f6sterildi\u011fi gibi daha verimli olmal\u0131d\u0131r.","99972f2a":"#### Dumbest Path-Dumbest g\u00fczergah(En Sa\u00e7ma-aptal Yol): CityID'lerin s\u0131ras\u0131na g\u00f6re gidin: 0, 1, 2 .. vs. ve sona ula\u015ft\u0131\u011f\u0131n\u0131zda s\u0131f\u0131ra geri d\u00f6n\u00fcn.","1fbd3fcb":"K\u0131rm\u0131z\u0131 nokta Kuzey Kutbu'nu g\u00f6sterir (CityId = 0).","bb4e3f43":"Birincil takaslarla toplam mesafeyi 650 birim daha azaltt\u0131k.","b84fa7d4":"#### Yukar\u0131daki algoritma ile son grafi\u011fin nas\u0131l g\u00f6r\u00fcnd\u00fc\u011f\u00fcne bir g\u00f6z atal\u0131m.","f2099c19":"Izgara d\u00fczeyinde bir zikzak yolu getirerek, Sat\u0131c\u0131 (Noel Baba) i\u00e7in en y\u00fcksek Y'den en d\u00fc\u015f\u00fck Y'ye olan uzun yolculuklar\u0131 ortadan kald\u0131rd\u0131k ve puan\u0131 3,2 milyondan 2,2 milyona daha da y\u00fckselttik.","96c1e18c":"(300.500), (300.300) 'den daha iyi \u0131zgara boyutu gibi g\u00f6r\u00fcn\u00fcyor, ama benim pek de\u011fil. Eh, t\u00fcm deneyler \u00e7al\u0131\u015fm\u0131yor.","870427da":"#### Puan a\u00e7\u0131s\u0131ndan dilimlenmi\u015f, s\u0131ralanm\u0131\u015f \u015fehirler ile b\u00fcy\u00fck geli\u015fme ger\u00e7ekle\u015fmi\u015ftir.","e766f1f3":"Genetik algoritmalar, Darwin'in evrim teorisinden esinlenmi\u015ftir. Genetik algoritmalarla \u00e7\u00f6z\u00fclen bir soruna \u00e7\u00f6z\u00fcm geli\u015ftirilir.Algoritma, pop\u00fclasyon ad\u0131 verilen bir dizi \u00e7\u00f6z\u00fcmle (kromozomlarla temsil edilir) ba\u015flat\u0131l\u0131r. Bir pop\u00fclasyondan \u00e7\u00f6z\u00fcmler al\u0131n\u0131r ve yeni bir pop\u00fclasyon olu\u015fturmak i\u00e7in kullan\u0131l\u0131r. Bu, yeni n\u00fcfusun eskisinden daha iyi olaca\u011f\u0131 umuduyla motive edilir. Yeni \u00e7\u00f6z\u00fcmler (yavrular) olu\u015fturmak i\u00e7in se\u00e7ilen \u00e7\u00f6z\u00fcmler uygunluklar\u0131na g\u00f6re se\u00e7ilir - ne kadar uygun olurlarsa \u00fcreme \u015fanslar\u0131 o kadar artar.\n\n[Ba\u015flat] Rastgele n kromozom pop\u00fclasyonu olu\u015fturun (soruna uygun \u00e7\u00f6z\u00fcmler).\n\u200b\n[Uygunluk] Pop\u00fclasyondaki her bir x kromozomunun uygunlu\u011funu f (x) de\u011ferlendirin\n\n[Yeni pop\u00fclasyon] Yeni pop\u00fclasyon tamamlanana kadar a\u015fa\u011f\u0131daki ad\u0131mlar\u0131 tekrarlayarak yeni bir pop\u00fclasyon olu\u015fturun\n\n[Se\u00e7im] Bir pop\u00fclasyondan uygunluklar\u0131na g\u00f6re iki ebeveyn kromozomu se\u00e7in (daha iyi uygunluk, daha b\u00fcy\u00fck se\u00e7ilme \u015fans\u0131) \n\u200b\n[\u00c7aprazlama] \u00c7aprazlama olas\u0131l\u0131\u011f\u0131 ile yeni bir yavru (\u00e7ocuklar) olu\u015fturmak i\u00e7in ebeveynleri \u00e7aprazlay\u0131n. \u00c7aprazlama yap\u0131lmad\u0131ysa, yavrular ebeveynlerin tam bir kopyas\u0131d\u0131r.\n\n[Mutasyon] Bir mutasyon olas\u0131l\u0131\u011f\u0131 ile her lokusta yeni yavrular\u0131 mutasyona u\u011frat\u0131n (kromozomdaki konum).\n\n[Kabul] Yeni yavrular\u0131 yeni bir pop\u00fclasyona yerle\u015ftirin\n\n[De\u011fi\u015ftirin] Daha sonraki bir algoritma \u00e7al\u0131\u015fmas\u0131 i\u00e7in yeni olu\u015fturulan pop\u00fclasyonu kullan\u0131n\n\n[Test] Son ko\u015ful kar\u015f\u0131lan\u0131rsa, durdurun ve mevcut pop\u00fclasyondaki en iyi \u00e7\u00f6z\u00fcm\u00fc geri verin\n\n[D\u00f6ng\u00fc] 2. ad\u0131ma gidin.\n[D\u00f6ng\u00fc] 2. ad\u0131ma gidin."}}