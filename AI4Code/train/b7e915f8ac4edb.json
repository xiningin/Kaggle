{"cell_type":{"25fe0212":"code","b32a3b75":"code","c7acbe0d":"code","d9de5b5d":"code","9d9d86e2":"code","7f1d62f6":"code","4a11f81c":"code","1635d5a7":"code","a685fa65":"code","f78bbc61":"code","804ccbd6":"code","37d15d85":"code","d954715e":"code","1d0120c8":"code","18d5829d":"code","e1402767":"code","0da9a161":"code","aa49a09e":"code","648a4e5b":"code","a549ef40":"code","cd2b4f48":"code","cf26df9a":"code","e5bffc6d":"code","aeae3781":"code","d7b9304f":"code","8a3bfdeb":"code","5c22cf26":"code","4d984db9":"code","9bf9a258":"code","f60f3f52":"code","d8962f23":"code","219aacfe":"code","6869f267":"code","5af937a6":"code","7a7684fa":"code","7e985af0":"markdown","019dc06f":"markdown","cc1e8ba0":"markdown","5c17c4c8":"markdown","bd70e392":"markdown","4241a7b1":"markdown","37b73a71":"markdown","2498649d":"markdown","0c46a8b5":"markdown","11842a5c":"markdown","668a2794":"markdown","9eeb60ae":"markdown","913c9e82":"markdown","7f3215e1":"markdown"},"source":{"25fe0212":"!conda install -y graphviz pygraphviz","b32a3b75":"!pip install -qq celluloid","c7acbe0d":"%matplotlib inline\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom IPython.display import Image, display, SVG, clear_output\nplt.rcParams[\"figure.figsize\"] = (6, 6)\nplt.rcParams[\"figure.dpi\"] = 125\nplt.rcParams[\"font.size\"] = 14\nplt.rcParams['font.family'] = ['sans-serif']\nplt.rcParams['font.sans-serif'] = ['DejaVu Sans']\nplt.style.use('ggplot')\nsns.set_style(\"whitegrid\", {'axes.grid': False})\nplt.rcParams['image.cmap'] = 'gray' # grayscale looks better","d9de5b5d":"import inspect\nimport doctest\nimport copy\nimport functools\ndef autotest(func):\n    globs = copy.copy(globals())\n    globs.update({func.__name__: func})\n    doctest.run_docstring_examples(\n        func, globs, verbose=True, name=func.__name__)\n    return func\n\n@autotest\ndef retrieve_name(var, back_step=None):\n    # type: (Any, Optional[int]) -> str\n    \"\"\"Gets the name of the parent variable (if exists).\n    Params:\n        back_step is the number of steps to go back (None or <0 triggers deepest possible)\n    \n    >>> f = lambda x, n: retrieve_name(x, n)\n    >>> a = (None, '')\n    >>> f(a, 0)\n    'var'\n    >>> f(a, 1)\n    'x'\n    >>> f(a, 2)\n    'a'\n    \"\"\"\n    \n    if back_step is None:\n        i = 1\n        while len(retrieve_name(var, i))>0:\n            i+=1\n        return retrieve_name(var, i-1)\n    \n    c_frame = inspect.currentframe()\n    for _ in range(back_step):\n        c_frame = c_frame.f_back\n    \n    callers_local_vars = c_frame.f_locals.items()\n    valid_list = [var_name for var_name, var_val in callers_local_vars if var_val is var]\n    if len(valid_list)>0:\n        return valid_list[-1]\n    else:\n        return ''","9d9d86e2":"from typing import List, Optional\nfrom networkx.drawing.nx_agraph import to_agraph \nclass GraphNode:\n    _cur_graph = None\n    def __init__(self, \n                 value, # type: Any\n                 children=None, # type: Optional[List[GraphNode]]\n                 siblings=None, # type: Optional[List[GraphNode]]\n                 verbose=True\n                ):\n        if children is None:\n            self._children = []\n        elif isinstance(children, GraphNode):\n            self._children = [children]\n        else:\n            self._children = children\n        if siblings is None:\n            self._siblings = []\n        elif isinstance(siblings, GraphNode):\n            self._siblings = [siblings]\n        else:\n            self._siblings = siblings\n        self._value = value\n        self.verbose = True\n    \n    def _record_read(self, name, desc):\n        if self._cur_graph is not None:\n            self._cur_graph.nodes[self._value]['color'] = 'red'\n            old_label = self._cur_graph.nodes[self._value].get('label', self._value)\n            new_label = f'*{name}={self._value}'\n            if old_label!=self._value:\n                new_label = '\\n'.join(set([old_label, new_label]))\n            self._cur_graph.nodes[self._value]['label'] = new_label\n        if self.verbose:\n            print(f'Read {desc} from {name}')\n        \n    @property\n    def value(self):\n        self._record_read(name=retrieve_name(self), desc='value')\n        return self._value\n    \n    @property\n    def children(self):\n        self._record_read(name=retrieve_name(self), desc='children')\n        return self._children\n    \n    def add_child(self, child):\n        if not isinstance(child, GraphNode):\n            child = GraphNode(child)\n        self._children.append(child)\n        return child\n    \n    def add_siblings(self, siblings):\n        if isinstance(siblings, list):\n            return [self.add_siblings(c_sibling) for c_sibling in siblings]\n        if not isinstance(siblings, GraphNode):\n            siblings = GraphNode(siblings)\n        self._siblings.append(siblings)\n        return siblings\n    \n    def create_graph(self):\n        # type: (GraphNode) -> nx.Graph\n        G = nx.MultiDiGraph()\n        visisted_nodes = set()\n        c_sibling_pairs = [(None, self)]+[(None, c_node) for c_node in self._siblings]\n        while len(c_sibling_pairs)>0:\n            c_parent_node, c_active_node = c_sibling_pairs.pop()\n            if self.verbose:\n                print(c_parent_node, c_active_node)\n            if c_parent_node is not None:\n                G.add_edge(c_parent_node._value, c_active_node._value)\n            else:\n                G.add_node(c_active_node._value)\n\n            if (c_active_node not in visisted_nodes) or (c_parent_node is None):\n                # only traverse children if we haven't been here before\n                for c_child in c_active_node._children:\n                    c_sibling_pairs.append((c_active_node, c_child))\n                visisted_nodes.add(c_active_node)\n        return G\n    \n    @property\n    def graph(self):\n        if GraphNode._cur_graph is None:\n            GraphNode._cur_graph = self.create_graph()\n        return GraphNode._cur_graph\n    \n    def clear(self):\n        g = self.graph\n        for k in g.nodes():\n            g.nodes[k]['color'] = 'green'\n            g.nodes[k]['label'] = k\n        GraphNode._cur_graph = g\n    \n    def reset(self):\n        GraphNode._cur_graph = None\n        \n    def __repr__(self):\n        return f'GraphNode ({self._value}): {len(self._children)}'\n    \n    ","7f1d62f6":"def build_graph():\n    head = GraphNode('head')\n    body = head.add_child('body')\n    for k in 'RL':\n        body.add_child(f'arm_{k}').add_child(f'hand_{k}').add_child(f'finger_{k}')\n        foot = body.add_child(f'leg_{k}').add_child(f'foot_{k}')\n        foot.add_child(f'toe_{k}').add_child(head) # a few weird loops\n    return head\na = build_graph()\n    ","4a11f81c":"_graph_count = 0\ndef draw_graph_dot(g):\n    global _graph_count\n    if isinstance(g, GraphNode):\n        g = g.graph\n    g.graph['edge'] = {'arrowsize': '1', 'splines': 'curved'}\n    A = to_agraph(g) \n    A.layout('dot')  \n    graph_name = '{:04d}.svg'.format(_graph_count)\n    A.draw(graph_name)   \n    _graph_count+=1\n    return SVG(graph_name)\ndef draw_graph_mpl(g, pos = None, ax=None, layout_func=nx.drawing.layout.kamada_kawai_layout):\n    if isinstance(g, GraphNode):\n        g = g.graph\n    if ax is None:\n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    else:\n        fig = None\n    if pos is None:\n        pos = layout_func(g)\n    node_color = []\n    node_labels = {}\n    shift_pos = {}\n    for k in g:\n        node_color.append(g.nodes[k].get('color', 'green'))\n        node_labels[k] = g.nodes[k].get('label', k)\n        shift_pos[k] = [pos[k][0], pos[k][1]-0.1]\n    \n    nx.draw_networkx_edges(g, pos, font_weight='bold', ax=ax)\n    nx.draw_networkx_nodes(g, pos, node_color=node_color, node_shape='p', node_size=300, alpha=0.75)\n    nx.draw_networkx_labels(g, shift_pos, labels=node_labels, ax=ax, arrows=True)\n    ax.autoscale()\n    return fig, ax, pos\nGraphNode.draw = draw_graph_mpl\nGraphNode.dot = draw_graph_dot","1635d5a7":"a.draw();","a685fa65":"a.value\nb = a.children[-1]\nb.value","f78bbc61":"b.dot()","804ccbd6":"b.draw();","37d15d85":"from celluloid import Camera\nclass Iterator:\n    def __init__(self, in_gn, max_value=None, **kwargs):\n        self._gn = in_gn\n        self._fig, self._ax, self._pos = in_gn.draw(**kwargs)\n        self._cam = Camera(self._fig)\n        self.idx = 0\n        self._max_value = max_value\n        self.increment()\n    \n    def increment(self):\n        #self._ax.clear()\n        self._gn.draw(ax=self._ax, pos=self._pos)\n        self._ax.set_title(f'Frame: {self.idx}')\n        self._cam.snap()\n        self._gn.clear()\n        self.idx+=1\n        if self._max_value is not None:\n            if self.idx>=self._max_value:\n                raise ValueError(f'Iteration count exceeded {self.idx}')\n        return self.idx\n    \n    def __iadd__(self, value):\n        for i in range(value):\n            self.increment()\n        return self\n    \n    def show(self, **kwargs):\n        return self._cam.animate(**kwargs)\n    \n    def _repr_html_(self):\n        return self._cam.animate(interval=750).to_jshtml()\n    \n    def as_gif(self, gif_name):\n        self.show(interval=760, blit=True, repeat=True).save(gif_name)\n        return Image(gif_name)\n\ndef get_animation_iter(in_gn, max_value=None, **kwargs):\n    in_gn.reset()\n    in_gn._iter = Iterator(in_gn, max_value=max_value, **kwargs)\n    return in_gn._iter\n\nGraphNode.get_iter = get_animation_iter","d954715e":"i = a.get_iter(max_value=15)\nnext_nodes = [a]\nwhile len(next_nodes)>0:\n    c_node = next_nodes.pop()\n    for i_node in c_node.children:\n        next_nodes.append(i_node)\n    i+=1","1d0120c8":"a._iter.as_gif('dump_traverse.gif')\na._iter","18d5829d":"from networkx.drawing.nx_agraph import graphviz_layout\ndef _split_and_sub(in_node_list):\n    if len(in_node_list)>2:\n        mid_point = len(in_node_list)\/\/2\n        head = in_node_list.pop(mid_point)\n        \n        left_side = _split_and_sub(in_node_list[:mid_point])\n        if left_side is not None:\n            head.add_child(left_side)\n            \n        right_side = _split_and_sub(in_node_list[mid_point:])\n        if right_side is not None:\n            head.add_child(right_side)\n        return head\n    \n    elif len(in_node_list)>0:\n        head = in_node_list.pop(0)\n        while len(in_node_list)>0:\n            head.add_child(in_node_list.pop(0))\n        return head\n    else:\n        raise ValueError('Empty node list')\ndef build_btree(max_index):\n    all_nodes = [GraphNode(i) for i in range(max_index)]\n    all_nodes[0].reset()\n    return _split_and_sub(all_nodes)","e1402767":"sample_btree = build_btree(31)\nsample_btree.draw(pos=graphviz_layout(sample_btree.graph, prog='dot'));","0da9a161":"def depth_first_search(head_node, idx):\n    pos = graphviz_layout(head_node.graph, prog='dot')\n    i = head_node.get_iter(max_value=32, pos=pos)\n    next_nodes = [head_node]\n    while len(next_nodes)>0:\n        c_node = next_nodes.pop(-1)\n        if c_node.value==idx:\n            return c_node\n        next_nodes += c_node.children\n        i+=1\n    return None","aa49a09e":"depth_first_search(head_node=sample_btree, idx=4)","648a4e5b":"sample_btree._iter.as_gif('dfs_search.gif')\nsample_btree._iter","a549ef40":"def breadth_first_search(head_node, idx):\n    pos = graphviz_layout(head_node.graph, prog='dot')\n    i = head_node.get_iter(max_value=32, pos=pos)\n    next_nodes = [head_node]\n    while len(next_nodes)>0:\n        c_node = next_nodes.pop(0)\n        if c_node.value==idx:\n            return c_node\n        next_nodes += c_node.children\n        i+=1\n    return None","cd2b4f48":"breadth_first_search(head_node=sample_btree, idx=4)","cf26df9a":"sample_btree._iter.as_gif('bfs_search.gif')\nsample_btree._iter","e5bffc6d":"def bt_search(head_node, idx):\n    pos = graphviz_layout(head_node.graph, prog='dot')\n    i = head_node.get_iter(max_value=32, pos=pos)\n    c_node = head_node\n    while True:\n        i+=1\n        if c_node.value==idx:\n            \n            return c_node\n        \n        c_children = c_node.children\n        if len(c_children)==0:\n            return None\n        elif idx>c_node.value:\n            c_node = c_children[-1]\n        else:\n            c_node = c_children[0]","aeae3781":"bt_search(head_node=sample_btree, idx=4)","d7b9304f":"sample_btree._iter.as_gif('bt_search.gif')\nsample_btree._iter","8a3bfdeb":"class LinkedList(GraphNode):\n    def add_next(self, name):\n        n_node = self.add_child(name)\n        n_node.__class__ = LinkedList\n        return n_node\n    \n    @property\n    def next(self):\n        children = self.children\n        if len(children)>0:\n            return children[0]\n        else:\n            return None","5c22cf26":"head = LinkedList('head')\nhead2 = head.add_next('head_next')\nhead.reset()\nc_node = head2\nfor i in range(10):\n    c_node = c_node.add_next('node-{}'.format(i))\nc_node.add_next(head2)\nhead.draw();","4d984db9":"def check_for_loop(list_head):\n    i = list_head.get_iter()\n    t1 = list_head\n    t2 = list_head.next\n    while(t1!=t2):\n        if t1 is None: return False\n        if t2 is None: return False\n        t1 = t1.next\n        t2 = t2.next\n        if t2 is None: return False\n        t2 = t2.next\n        i+=1\n    return True # they do match \/ is a loop","9bf9a258":"check_for_loop(head)","f60f3f52":"head._iter.as_gif('loop_check.gif')\nhead._iter","d8962f23":"def graph_list_to_node(in_list):\n    g_dict = {idx: GraphNode(f'Node:{idx}') \n              for idx, links in enumerate(in_list)}\n    for idx, links in enumerate(in_list):\n        for k in links:\n            g_dict[idx].add_child(g_dict[k])\n    head = g_dict.pop(0)\n    head.add_siblings(list(g_dict.values()))\n    head.reset()\n    return head","219aacfe":"g_list = [[1,2],[2,3],[5],[0],[5],[],[]]\nhead = graph_list_to_node(g_list)\nhead.draw();","6869f267":"def find_safe_state(in_nodes):\n    i = in_nodes[0].get_iter(max_value=100)\n    safe_nodes = set()\n    \n    while len(in_nodes)>0:\n        nodes_to_check = [in_nodes.pop()]\n        visited_nodes = set()\n        is_safe = True\n        while len(nodes_to_check)>0:\n            c_node = nodes_to_check.pop()\n            visited_nodes.add(c_node)\n            for i_node in c_node.children:\n                i_node.value\n                if i_node in visited_nodes:\n                    nodes_to_check = []\n                    is_safe = False\n                elif i_node in safe_nodes:\n                    pass\n                elif len(i_node.children)<1:\n                    safe_nodes.add(i_node)\n                else:\n                    nodes_to_check.append(i_node)\n                i+=1\n        if is_safe:\n            for i_node in visited_nodes:\n                safe_nodes.add(i_node)\n    return safe_nodes","5af937a6":"find_safe_state([head]+head._siblings)","7a7684fa":"head._iter.as_gif('eventual_safe.gif')\nhead._iter","7e985af0":"## Simple Reading Example\nWe read a few nodes and values and then show the result","019dc06f":"## Basic Graph Class\nHere we have the basic graph class consisting of just a node and children. We add instrumentation to the `.value` and `.children` functions so we can keep track of when they are accessed","cc1e8ba0":"# Find Eventual Safe States\nThe leetcode problem to [find eventually save states](https:\/\/leetcode.com\/problems\/find-eventual-safe-states\/): \n\n\nIn a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.\n\nNow, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.\n\nWhich nodes are eventually safe?  Return them as an array in sorted order.\n\nThe directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.\n\n```\nExample:\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\nOutput: [2,4,5,6]\n```","5c17c4c8":"## Binary Tree Search\nNow that we have tried two horrendous methods for searching a binary tree we can use the actual approach","bd70e392":"## Breadth First Search","4241a7b1":"# Cycle Detection\nWe can check for cycles by making two pointers and having them proceed at different speeds until they collide","37b73a71":"## Utility Functions","2498649d":"## Graph Visualization Code\nWe build methods to visual the graphs using `dot` and `matplotlib` we then add them to the main functions","0c46a8b5":"# Simple Depth First Search","11842a5c":"## Visualization Tools","668a2794":"# Overview\nGraph traversal problems can be notoriously difficult to code well and visualize, here is a set of tools to make that easier. In particular I show a few cases with breadth-first-search, depth-first-search and possibly Dijkstra","9eeb60ae":"## Depth First Search","913c9e82":"# Binary Tree Search\nHere we show 3 different ways of 'searching' a binary tree for a given key.","7f3215e1":"## Animation Code\nWe can now add some animation code to watch as we traverse through a graph"}}