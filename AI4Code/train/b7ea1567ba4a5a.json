{"cell_type":{"6f5c8bbb":"code","d69ca5a0":"code","735a01b2":"code","cf862137":"code","c6b727c8":"code","72040910":"code","4c0ab86b":"code","aa1f458d":"code","81b76399":"code","6ac9d203":"code","bef9e768":"code","bb2dcbd9":"code","b9f367cc":"code","14960433":"code","46387ddf":"code","4e181779":"code","0291b59f":"code","53113ebf":"code","96272e35":"code","757f86af":"code","be78b62c":"code","5c7ab25b":"code","8e989500":"code","18d97342":"code","9cbffcc1":"code","db10d5f8":"code","51e88c0d":"code","d1d9e009":"code","9e093988":"markdown","7d334637":"markdown","1bd4585d":"markdown","5d359cba":"markdown","4235d23d":"markdown","02fa10f4":"markdown","a007e8b6":"markdown","5485da4d":"markdown","7b7cc929":"markdown","f7c6e676":"markdown","1067c66d":"markdown","89950880":"markdown","efe64b1a":"markdown","7f3d00a6":"markdown","f97a93ff":"markdown","9c290145":"markdown","8238a0d2":"markdown","9920d27c":"markdown","d5ac7e2f":"markdown","f87c88c4":"markdown","49637e4a":"markdown","8f49f1d8":"markdown","91d5e093":"markdown","01ef961e":"markdown","91fcfd8b":"markdown","aa675970":"markdown"},"source":{"6f5c8bbb":"import pandas as pd\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nsns.set()","d69ca5a0":"import os\nprint(os.listdir(\"..\/input\"))","735a01b2":"train = pd.read_csv(\"..\/input\/titanicdivethrough\/prepared_train.csv\", index_col=0)\ntest = pd.read_csv(\"..\/input\/titanicdivethrough\/prepared_test.csv\", index_col=0)\ntrain.head()","cf862137":"class MyClassifier:\n    \n    def __init__(self, n_features):\n        self.n_features = n_features\n        np.random.seed(0)\n        self.w = np.random.normal(loc=0, scale=0.01, size=n_features)\n        self.losses = []\n    \n    def predict(self, x):\n        y = sigmoid(np.sum(self.w*x, axis=1))\n        return y\n    \n    def loss(self, y, t):\n        E = - np.sum(t * np.log(y) + (1-t) * np.log(1-y))\n        return E\n        \n    def gradient(self, x, y, t):\n        grad = np.zeros(self.w.shape[0])\n        for d in range(self.w.shape[0]):\n            grad[d] = np.sum((y-t)*x[:, d])\n        return grad\n        \n    def update(self, eta, grad):\n        w_next = np.zeros(self.w.shape) \n        for d in range(self.w.shape[0]):\n            w_next[d] = self.w[d] - eta * grad[d]\n        return w_next\n    \n    def learn(self, x, t, eta, max_steps, tol):\n        y = self.predict(x)\n        for step in range(max_steps):\n            error = self.loss(y, t)\n            grad = self.gradient(x, y, t)\n            self.w = self.update(eta, grad)\n            self.losses.append(error)\n            y = self.predict(x)\n            error_next = self.loss(y, t)\n            if (error - error_next) < tol:\n                break\n                \n    def decide(self, y):\n        decision = np.zeros(y.shape)\n        decision[y >= 0.5] = 1\n        decision[y < 0.5] = 0\n        return decision.astype(np.int)\n    \n    def accuracy(self, y, t):\n        N = y.shape[0]\n        return 1\/N * np.sum(1 - np.abs(t-y))\n        \n    def score(self, x, t):\n        y = self.predict(x)\n        y = self.decide(y)\n        return self.accuracy(y, t)\n\ndef sigmoid(x):\n    result = 1\/(1+np.exp(-x))\n    return result","c6b727c8":"from sklearn.model_selection import train_test_split\n\nfeatures = train.drop([\"PassengerId\", \"Survived\"], axis=1).columns\n\nX = train[features].values\nY = train.Survived.values\n\nx_train, x_val, t_train, t_val = train_test_split(X, Y, random_state=0)","72040910":"# your task: call the score method to find out how well your model performs \n# on the train and validation data\nclassifier = MyClassifier(x_train.shape[1])\nclassifier.learn(x_train, t_train, 0.000001, 100000, 0.00001)\n#train_score = <your code>\n#test_score = <your code>","4c0ab86b":"#assert(np.round(train_score, 4) == 0.7994)\n#assert(np.round(test_score, 4) == 0.7803)","aa1f458d":"plt.figure(figsize=(15,5))\nplt.plot(classifier.losses)\nplt.xlabel(\"Iteration steps\")\nplt.ylabel(\"cross entropy loss\")","81b76399":"x_sex_train = x_train[:, 1].reshape(-1,1)\nx_sex_val = x_val[:, 1].reshape(-1,1)\n\nclassifier = MyClassifier(1)\nclassifier.learn(x_sex_train, t_train, 0.000001, 100000, 0.00001)\nprint(classifier.score(x_sex_train, t_train))\nprint(classifier.score(x_sex_val, t_val))","6ac9d203":"classifier.accuracy(x_val[:,1], t_val)","bef9e768":"predictions = classifier.predict(x_sex_train)\n# It's your turn now: Plot the survival probabilites given by the predictions our classifier made:\nplt.figure(figsize=(15,4))\n#<your code>\nplt.xlabel(\"predicted survival probability\")\nplt.ylabel(\"frequency\")\nplt.title(\"Distribution of predictions\")","bb2dcbd9":"class ImprovedClassifier(MyClassifier):\n    \n    def __init__(self, n_features):\n        super().__init__(n_features)\n        np.random.seed(0)\n        self.w = np.random.normal(loc=0, scale=0.01, size=n_features + 1)\n    \n    def predict(self, x):\n        # your task: replace the compuation of y by including the bias term self.w[-1] * 1\n        y = sigmoid(np.sum(self.w[:-1]*x, axis=1))\n        return y\n        \n    def gradient(self, x, y, t):\n        grad = np.zeros(self.w.shape[0])\n        for d in range(self.w.shape[0]):\n            if d == self.n_features:\n                # replace the computation of the gradient of E with respect to the bias term\n                grad[d] = 0\n            else:\n                grad[d] = np.sum((y-t)*x[:, d])\n        return grad","b9f367cc":"iclassifier = ImprovedClassifier(1)\niclassifier.learn(x_sex_train, t_train, 0.000001, 100000, 0.00001)\ntrain_score = iclassifier.score(x_sex_train, t_train)\nval_score = iclassifier.score(x_sex_val, t_val)\nprint(\"train accuracy: %f , validation accuracy: %f\" %(train_score, val_score) )","14960433":"#assert(train_score == iclassifier.accuracy(x_train[:,1], t_train))","46387ddf":"train_df = pd.DataFrame(x_train, columns=features)\nval_df = pd.DataFrame(x_val, columns=features)\ntrain_df[\"Survived\"] = t_train","4e181779":"x_embarked_train = train_df.Embarked.values.reshape(-1,1)\nx_embarked_val = val_df.Embarked.values.reshape(-1,1)\n\niclassifier = ImprovedClassifier(1)\niclassifier.learn(x_embarked_train, t_train, 0.000001, 100000, 0.00001)\ntrain_score = iclassifier.score(x_embarked_train, t_train)\nval_score = iclassifier.score(x_embarked_val, t_val)\npredictions_proba = iclassifier.predict(x_embarked_train)\npredictions = iclassifier.decide(predictions_proba)\n\nprint(\"train accuracy: %f , validation accuracy: %f\" %(train_score, val_score))\n\ntrain_df[\"predictions_proba\"] = np.round(predictions_proba, 2)\ntrain_df[\"predictions\"] = predictions","0291b59f":"#assert(np.round(train_score, 4) == 0.6138)\n#assert(np.round(val_score, 4) == 0.6233)","53113ebf":"fig, ax = plt.subplots(1,4, figsize=(20,5))\nsns.countplot(train_df.Embarked, ax=ax[0])\nax[0].set_title(\"Embarkation counts\")\nsns.countplot(x=\"Embarked\", hue=\"Survived\", data=train_df, ax=ax[1])\nax[1].set_title(\"True Survival\")\nsns.countplot(x=\"Embarked\", hue=\"predictions\", data=train_df, ax=ax[2])\nax[2].set_title(\"Predicted Survival\")\nsns.countplot(x=\"Embarked\", hue=\"predictions_proba\", data=train_df, ax=ax[3])","96272e35":"train_df[\"S\"] = train_df.Embarked.apply(lambda l: np.where(l==0, 1, 0))\ntrain_df[\"C\"] = train_df.Embarked.apply(lambda l: np.where(l==1, 1, 0))\ntrain_df[\"Q\"] = train_df.Embarked.apply(lambda l: np.where(l==2, 1, 0))\nval_df[\"S\"] = val_df.Embarked.apply(lambda l: np.where(l==0, 1, 0))\nval_df[\"C\"] = val_df.Embarked.apply(lambda l: np.where(l==1, 1, 0))\nval_df[\"Q\"] = val_df.Embarked.apply(lambda l: np.where(l==2, 1, 0))\n\ntrain_df.drop(\"Embarked\", axis=1, inplace=True)\nval_df.drop(\"Embarked\", axis=1, inplace=True)","757f86af":"x_embarked_train = train_df[[\"S\", \"C\", \"Q\"]].values\nx_embarked_val = val_df[[\"S\", \"C\", \"Q\"]].values\n\niclassifier = ImprovedClassifier(x_embarked_train.shape[1])\niclassifier.learn(x_embarked_train, t_train, 0.000001, 100000, 0.00001)\ntrain_score = iclassifier.score(x_embarked_train, t_train)\nval_score = iclassifier.score(x_embarked_val, t_val)\npredictions_proba = iclassifier.predict(x_embarked_train)\npredictions = iclassifier.decide(predictions_proba)\n\nprint(\"train accuracy: %f , validation accuracy: %f\" %(train_score, val_score))\n\ntrain_df[\"predictions_proba\"] = np.round(predictions_proba, 2)\ntrain_df[\"predictions\"] = predictions","be78b62c":"#assert(np.round(train_score, 4) == 0.6287)\n#assert(np.round(val_score, 4) == 0.6592)","5c7ab25b":"fig, ax = plt.subplots(1,3,figsize=(15,4))\nsns.countplot(x=\"C\", hue=\"Survived\", data=train_df, ax=ax[0])\nax[0].set_title(\"True Survival\")\nsns.countplot(x=\"C\", hue=\"predictions\", data=train_df, ax=ax[1])\nax[1].set_title(\"Predicted Survival\")\nsns.countplot(x=\"C\", hue=\"predictions_proba\", data=train_df, ax=ax[2])","8e989500":"class MyEncoder:\n    \n    def __init__(self, features):\n        self.features = features\n        self.feature_levels = []\n    \n    def fit(self, df):\n        for feature in self.features:\n            levels = df[feature].unique()\n            self.feature_levels.append(levels)\n    \n    def transform(self,df):\n        for f in range(len(self.features)):\n            feature = self.features[f]\n            levels = self.feature_levels[f]\n            for level in levels:\n                new_name = feature + \"_\" + str(level)\n                df[new_name] = df[feature].apply(lambda l: np.where(l==level, 1, 0))\n        return df","18d97342":"combined = train.drop(\"Survived\", axis=1).append(test)\ncombined.head()","9cbffcc1":"to_encode = [\"Embarked\"] # put your categorical features into the list!!!\nencoder = MyEncoder(to_encode)\nencoder.fit(combined)\ntrain = encoder.transform(train)\ntest = encoder.transform(test)","db10d5f8":"for feature in to_encode:\n    train.drop(feature, axis=1, inplace=True)\n    test.drop(feature, axis=1, inplace=True)","51e88c0d":"features = train.drop([\"PassengerId\", \"Survived\"], axis=1).columns\n\nX = train[features].values\nY = train.Survived.values\n\nx_train, x_val, t_train, t_val = train_test_split(X, Y, random_state=0)\n\niclassifier = ImprovedClassifier(x_train.shape[1])\niclassifier.learn(x_train, t_train, 0.000001, 100000, 0.00001)\ntrain_score = iclassifier.score(x_train, t_train)\nval_score = iclassifier.score(x_val, t_val)\nprint(\"train accuracy: %f , validation accuracy: %f\" %(train_score, val_score))","d1d9e009":"#assert(np.round(train_score, 4) == 0.8114)\n#assert(np.round(val_score, 4) == 0.8072)","9e093988":"Yup! :-)\n\nNow, it's your turn: Use binary representation for all remaining categorical features in our data sets! \nEven though there are opensource solutions out there let's use our own encoder that is build on the procedure we used before:","7d334637":"The decisions of our model for embarkation of value zero and two are ok as more passengers in those cases died. But what about embarkation with value one? In this case our model should predict that the passengers survived even though the true distribution shows only slightly differences. \n\nBy considering the bahaviour of the sigmoid function, can you explain what went wrong?\n\n...\n\nWhat would have happend if we would change the original map of:\n\n```python\nembarked_map = {\"S\": 0, \"C\": 1, \"Q\": 2}\n```\n\nto\n\n```python\nembarked_map = {\"S\": 0, \"C\": 2, \"Q\": 1}\n```\n?\n\nBy choosing numerical values we already assumed some kind of order that has to fit to our target variables. That's bad! Let's solve this problem by assigning binary values to each property per categorical variable:","1bd4585d":"## Station 2 - Categorical features\n\nIn the last section we have already seen that we have to take care about our sigmoid function. By playing with a binary categorical feature we have seen that we need to introduce a bias term to shift the sensitive region close to zero of the sigmoid function. But what about categorical features with more than two values? Let's have a look at the Embarked feature:","5d359cba":"What do you observe? The predicted probability is always >= 0.5. Consequently our model always predicts that the passengers survived. To understand why that happened, look closer at the prediction function we used:\n\n$$ y = \\sigma (w_{sex} \\cdot x_{sex}) $$\n\nThis sum has vanished as we only use one feature. Given a male we would have $x_{sex} = 0$ and in this case $y$ would always yield 0.5 due to the sigmoid function. This is of course not what we want. To overcome this problem we need a term that enables us to shif the sigmoid function such that we can map some other value than $x=0$ to $y=0.5$. This can be done by including the so called bias term:\n\n$$ y = \\sigma(w_{sex} \\cdot x_{sex} + w_{bias})$$\n\nThis course already provides a skeleton for an improved classifier. It's your turn now! Add a bias parameter to self.w and adjust the method to make predictions and to compute the gradients. ","4235d23d":"After your improvement the model is as good as if we would directly pass \"0 for males\" and \"1 for females\":","02fa10f4":"If you are not sure taking one feature or not, try:\n\n```python\nsns.countplot(x=featuretotry, hue=\"Survived\", data=train)\n```\n\nDoes the order of the numerical values fit to the target and predictions you would obtain by passing through sigmoid? Hint: There are more than Embarked! ;-)","a007e8b6":"If you have done the bias-term station right, you should see:","5485da4d":"We will use the prepared data we made during the first course:","7b7cc929":"Ok, now let's have a look if we would directly pass 0 for males and 1 for females:","f7c6e676":"Obviously our model is much worst than the example submission even if we use the sex feature alone. Something is wrong here!  Let's have a look at the predictions our model can make after learning:","1067c66d":"## Station 1 - Validation\n\nSo far, we haven't thought about the topic \"how to measure the performance\" of our model. In the last course we used the accuracy score, namely the percentage of right predictions, solely based on the train set. Consequently we can only say: \"We learned how to make more or less good predictions for the passengers in the train set\". Instead we would like to estimate how good our model makes predictions on unseen data. Thus it would be great to split our data into a train and validation set. By looking at the performance on the validation set we can adjust our strategies such that we find an optimal solution for unknown data. But of course this is again some kind of \"fitting\" and the validation data becomes part of the training as well. For this reason we need a third data set where we can measure the final performance of our model: the test data. In our case the test data is already given by the competition. But the validation data is still missing.\n\nDo generate it we will use [train_test_split](http:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.model_selection.train_test_split.html) from scikit-learn (sklearn), an opensource tool for data science and machine learning.   ","89950880":"Let's see how good our model is on the train and validation set. ","efe64b1a":"## Welcome Kaggler!\n\nWith this interactive diving course I invite you to learn some machine learning basics. This course is designed as a series of kernels that guides you through different topics and hopefully you can discover some hidden treasures that push you forward on your data science road. You don't have to pick the courses in sequence if you are only interested in some topics that are covered. If you are new I would recommend you to take them step by step one after another. ;-)\n\nJust fork the kernels and have fun! :-)\n\n* [Prepare to start](https:\/\/www.kaggle.com\/allunia\/titanic-dive-through-prepare-to-start): Within this kernel we will prepare our data such that we can use it to proceed. Don't except nice feature selection or extraction techniques here because we will stay as simple as possible. Without a clear motivation we won't change any features. Consequently we are only going to explore how to deal with missing values and how to turn objects to numerical values. In the end we will store our prepared data as output such that we can continue working with it in the next kernel.\n* [MyClassifier](https:\/\/www.kaggle.com\/allunia\/titanic-dive-through-myclassifier): Are you ready to code your own classifier? Within this kernel you will build logistic regression from scratch. By implementing the model ourselves we can understand the assumptions behind it. This knowledge will help us to make better decisions in the next kernel where we will use this model and build some diagnosis tools to improve its performance.\n* **The feature cave**: By using our own logistic regression model we will explore how we can improve by adding a bias term and why we should encode categorical features. \n* [Feature scaling and outliers](https:\/\/www.kaggle.com\/allunia\/titanic-dive-through-feature-scaling-and-outliers): Why is it important to scale features and to detect outliers? By analyzing the model structure we will discover how our gradients and our model performance are influenced by these topics. ","7f3d00a6":"After extracting the new features clean your data and drop the old ones:","f97a93ff":"Let's pass only the Embarked feature to train our model and have a look at the predictions we can make this way:","9c290145":"If you have done the bias term station right, you should see:","8238a0d2":"Using binary representations per property of embarkation we improved!!! :-) \n\n**This way we made sure that we don't introduce an order of survival by passing the numerical values of a categorical feature through the sigmoid function.**\n\nOur improvement should turn passengers that embarked in Cherbourg from \"not survived - 0\" to \"survived - 1\". Let's check this:","9920d27c":"Now, we are ready to dive! ;-)","d5ac7e2f":"Luckily our predictions are similar good on the train and validation set and we will proceed to measure our performance this way until we run into problems. Let's check if the train loss converged to a minimum during our learning procedure:","f87c88c4":"To make sure that we don't miss any property per categorical feature of train and test, we should fit our encoder on the combined data set and transform train and test separately:","49637e4a":"## Get your equipment\n...\n\nTitanic! \n...\n\nWe are on the way to your wrack!\n...\n\nWith our own classifier at hand we are now able to analyse every step we take while playing with our data. But before doing so, let's get our equipment:","8f49f1d8":"For the next stattion, make sure that you gain the right score:","91d5e093":"## Station 2 - The bias term\n\nThe example submission we have given is based just on one feature: the sex. The submission predicts \"not survived - 0\" if the passenger was a male and \"survived - 1\" otherwise. Let's perform an experiment and make predictions with our model solely on this feature. ","01ef961e":"And of course we will use our own classifier we build during the second course: ","91fcfd8b":"You should obtain:","aa675970":"That's ok for us. We don't expect the classifier to be much better with more iteration steps. "}}