{"cell_type":{"ea8f7f60":"code","ec015bac":"code","a7b9e8f7":"code","1c92f166":"code","d881b251":"code","bc71b57f":"code","5b7e2cd1":"code","e18ddb38":"code","a17d5add":"code","1d7bf899":"code","96ea4747":"code","70d6e8c3":"code","4fe8d443":"code","30a6b6d2":"code","e8b7bd62":"code","5bb59bd0":"code","591f6f3f":"code","8bad1b83":"code","e05c9cc6":"code","71e062bd":"code","dfa746a2":"code","5869148a":"code","e951d5f3":"code","c2a5552a":"code","7c443fbf":"code","036d40dd":"code","ac24e53a":"code","1acc8c35":"code","677c5b09":"code","0567e1d5":"code","41bb3ad9":"code","bd4d2bc9":"code","14f9f790":"code","5537b071":"code","dce380ca":"code","a9f9a07e":"code","dd50f1df":"code","a0aeda31":"code","bb2c23bd":"code","2e4f26fd":"code","3e106295":"code","b546c4c0":"code","492c4306":"code","eb4a7f8d":"code","db72568d":"code","1fc877bd":"markdown","5f4f6599":"markdown","c4a42c5e":"markdown","9020f7aa":"markdown","90115840":"markdown","2de45dcf":"markdown","41d28653":"markdown","5d7d6752":"markdown","21b61661":"markdown","7cadcad4":"markdown","048c5cf3":"markdown","caf5040e":"markdown","aa93722d":"markdown"},"source":{"ea8f7f60":"import pandas as pd\nimport matplotlib.pyplot as plt\n\nimport numpy as np\nimport os\nfrom sklearn.metrics import f1_score\n\nfrom fastai import *\nfrom fastai.vision import *\n\nimport torch\nimport torch.nn as nn\nimport torchvision\nimport cv2\n\nfrom tqdm import tqdm\nfrom skmultilearn.model_selection import iterative_train_test_split\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MultiLabelBinarizer\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n%load_ext autoreload\n%autoreload","ec015bac":"def open_4_channel(self,fname):\n    fname = str(fname)\n    # strip extension before adding color\n    if fname.endswith('.png'):\n        fname = fname[:-4]\n    colors = ['red','green','blue','yellow']\n    flags = cv2.IMREAD_GRAYSCALE\n    img = [cv2.imread(fname+'_'+color+'.png', flags).astype(np.float32)\/255\n           for color in colors]\n\n    x = np.stack(img, axis=-1)\n    return Image(pil2tensor(x, np.float32).float())","a7b9e8f7":"def show_batch_cstm(self, rows:int=5, ds_type:DatasetType=DatasetType.Train, **kwargs)->None:\n        \"Show a batch of data in `ds_type` on a few `rows`.\"\n        x,y = self.one_batch(ds_type, True, True)\n        x=x[:,:3,:,:]\n        \n        if self.train_ds.x._square_show: rows = rows ** 2\n        xs = [self.train_ds.x.reconstruct(grab_idx(x, i, self._batch_first)) for i in range(rows)]\n        #TODO: get rid of has_arg if possible\n        if has_arg(self.train_ds.y.reconstruct, 'x'):\n            ys = [self.train_ds.y.reconstruct(grab_idx(y, i), x=x) for i,x in enumerate(xs)]\n        else : ys = [self.train_ds.y.reconstruct(grab_idx(y, i)) for i in range(rows)]\n        print(ys)\n        self.train_ds.x.show_xys(xs, ys, **kwargs)\n","1c92f166":"path='.'\ninput_fldr=Path('..\/input\/')\ntrn_fldr=f'{input_fldr}\/train\/'\ntest_fldr=f'{input_fldr}\/test\/'\ntrn_lbl=f'{input_fldr}\/train.csv'\nsample_csv = f'{input_fldr}\/sample_submission.csv'\ndf_trn=pd.read_csv(f'{input_fldr}\/train.csv')\ndf_trn.head()\n","d881b251":"sz=512\nbs=16\n","bc71b57f":"targets=[np.array(target.split(' ')).astype(float) for target in df_trn.Target.values]\nmapping=MultiLabelBinarizer()\nmapping.fit(targets)\ntargets_mapped=mapping.transform(targets)","5b7e2cd1":"X_train, y_train, X_test, y_test = iterative_train_test_split(df_trn.Id[:,None], targets_mapped, test_size = 0.5)\nplt.plot(np.sum(y_train,axis=0)-np.sum(y_test,axis=0),label='iterative')\nX_train, X_test,y_train , y_test = train_test_split(df_trn.Id[:,None], targets_mapped, test_size = 0.5)\nplt.plot(np.sum(y_train,axis=0)-np.sum(y_test,axis=0),label='split')\nplt.legend()","e18ddb38":"p=1.\nn=int(p*df_trn.shape[0])\nwhile True:\n    if p<1.0:\n        idx=np.random.choice(len(df_trn.index),n)\n    else:\n        idx=range(len(df_trn.index))\n    X_train, y_train, X_val, y_val = iterative_train_test_split(df_trn.index[idx,None], targets_mapped[idx,:], test_size = 0.2)\n    if (np.sum(targets_mapped[idx,:],axis=0)>0).all() and ((X_train.shape[0]%bs!=1) and (X_val.shape[0]%bs!=1)):\n        break\nX_train.shape,(X_train.shape[0]%bs),X_val.shape,(X_val.shape[0]%bs)","a17d5add":"import numpy as np\n\nname_label_dict = {\n    0:   ('Nucleoplasm', 12885),\n    1:   ('Nuclear membrane', 1254),\n    2:   ('Nucleoli', 3621),\n    3:   ('Nucleoli fibrillar center', 1561),\n    4:   ('Nuclear speckles', 1858),\n    5:   ('Nuclear bodies', 2513),\n    6:   ('Endoplasmic reticulum', 1008),   \n    7:   ('Golgi apparatus', 2822),\n    8:   ('Peroxisomes', 53), \n    9:   ('Endosomes', 45),\n    10:  ('Lysosomes', 28),\n    11:  ('Intermediate filaments', 1093), \n    12:  ('Actin filaments', 688),\n    13:  ('Focal adhesion sites', 537),  \n    14:  ('Microtubules', 1066), \n    15:  ('Microtubule ends', 21),\n    16:  ('Cytokinetic bridge', 530),\n    17:  ('Mitotic spindle', 210),\n    18:  ('Microtubule organizing center', 902),\n    19:  ('Centrosome', 1482),\n    20:  ('Lipid droplets', 172),\n    21:  ('Plasma membrane', 3777),\n    22:  ('Cell junctions', 802),\n    23:  ('Mitochondria', 2965),\n    24:  ('Aggresome', 322),\n    25:  ('Cytosol', 8228),\n    26:  ('Cytoplasmic bodies', 328),   \n    27:  ('Rods &amp; rings', 11)\n    }\n\nn_labels = 50782\n\ndef cls_wts(label_dict, mu=0.5):\n    prob_dict, prob_dict_bal = {}, {}\n    max_ent_wt = 1\/28\n    for i in range(28):\n        prob_dict[i] = label_dict[i][1]\/n_labels\n        if prob_dict[i] > max_ent_wt:\n            prob_dict_bal[i] = prob_dict[i]-mu*(prob_dict[i] - max_ent_wt)\n        else:\n            prob_dict_bal[i] = prob_dict[i]+mu*(max_ent_wt - prob_dict[i])            \n    return prob_dict, prob_dict_bal","1d7bf899":"balance_p=.5\nprob_d,prob_bal=cls_wts(name_label_dict,balance_p)\nalpha=torch.cuda.FloatTensor(1\/np.array([prob_bal[i] for i in prob_bal]))\nalpha_log=torch.cuda.FloatTensor([-np.log(prob_bal[i])\/8 for i in prob_bal])\nplt.plot(to_np(alpha)\/min(to_np(alpha)),label='Linear scaled weights')\nplt.plot(to_np(alpha_log)\/min(to_np(alpha_log)),label='Log scaled weights')\nplt.legend()\n","96ea4747":"alpha_norm=to_np(alpha)\/np.min(to_np(alpha))\nplt.plot(alpha_norm,label='Linear scaled oversampling')\nalpha_norm[alpha_norm<4]=1\nalpha_norm[(alpha_norm>4) & (alpha_norm<6) ]=1.5\nalpha_norm[(alpha_norm>6) & (alpha_norm<7) ]=3\nalpha_norm[alpha_norm>7]=alpha_norm[alpha_norm>7]\nplt.plot(alpha_norm,label='Linear damped oversampling')\n#plt.plot(targets_mapped[:n,:].sum(axis=0)\/1000)\nplt.legend()\nover_sample={i:int(item*alpha_norm[i]) for i,item in enumerate(np.unique(np.argmin(-y_train*(to_np(alpha_log)\/np.min(to_np(alpha_log))),axis=1),return_counts=True)[1])}\n","70d6e8c3":"from imblearn.over_sampling import RandomOverSampler\nros = RandomOverSampler(random_state=42,sampling_strategy=over_sample)\nX_res, y_res = ros.fit_resample(X_train, np.argmin(-y_train*(to_np(alpha_log)\/np.min(to_np(alpha_log))),axis=1))\n","4fe8d443":"ImageItemList.open=open_4_channel\nImageDataBunch.show_batch=show_batch_cstm","30a6b6d2":"tfms = get_transforms(do_flip=True, flip_vert=True, max_rotate=30., max_zoom=1,\n                      max_lighting=0.05, max_warp=0.)","e8b7bd62":"test_ids = list(sorted({fname.split('_')[0] for fname in os.listdir(input_fldr\/'test')}))\ntest_fnames = [input_fldr\/'test'\/test_id for test_id in test_ids]","5bb59bd0":"src = (ImageItemList.from_csv(input_fldr, 'train.csv', folder='train', suffix='.png',num_workers=0)\n        .split_by_idxs(X_res[:,0],X_val[:,0])\n        .label_from_df(sep=' ',  classes=[str(i) for i in range(28)]))\nsrc.add_test(test_fnames, label='0');","591f6f3f":"data = (src.transform(tfms, size=sz)\n        .databunch(num_workers=0))\nstats=data.batch_stats()        \ndata.normalize(stats)","8bad1b83":"data.show_batch(rows=3, figsize=(12,9))","e05c9cc6":"RESNET_ENCODERS = {\n    34: torchvision.models.resnet34,\n    50: torchvision.models.resnet50,\n    101: torchvision.models.resnet101,\n    152: torchvision.models.resnet152,\n}\nclass Resnet4Channel(nn.Module):\n    def __init__(self, encoder_depth=34, pretrained=True, num_classes=28):\n        super().__init__()\n\n        encoder = RESNET_ENCODERS[encoder_depth](pretrained=pretrained)\n        \n        # we initialize this conv to take in 4 channels instead of 3\n        # we keeping corresponding weights and initializing new weights with zeros\n        # this trick taken from https:\/\/www.kaggle.com\/iafoss\/pretrained-resnet34-with-rgby-0-460-public-lb\n        w = encoder.conv1.weight\n        self.conv1 = nn.Conv2d(4, 64, kernel_size=7, stride=2, padding=3,\n                               bias=False)\n        \n        self.conv1.weight = nn.Parameter(torch.cat((w,w[:,:1,:,:]),dim=1))\n        \n        self.bn1 = encoder.bn1\n        self.relu = nn.ReLU(inplace=True) \n        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n\n        self.layer1 = encoder.layer1\n        self.layer2 = encoder.layer2\n        self.layer3 = encoder.layer3\n        self.layer4 = encoder.layer4\n        \n        self.avgpool = encoder.avgpool\n        self.fc = nn.Linear(512 * (1 if encoder_depth==34 else 4), num_classes)\n        \n    def forward(self, x):\n        x = self.conv1(x)\n        x = self.bn1(x)\n        x = self.relu(x)\n        x = self.maxpool(x)\n\n        x = self.layer1(x)\n        x = self.layer2(x)\n        x = self.layer3(x)\n        x = self.layer4(x)\n\n        x = self.avgpool(x)\n        x = x.view(x.size(0), -1)\n        x = self.fc(x)\n\n        return x\n    \n\ndef resnet34(pretrained):\n    return Resnet4Channel(encoder_depth=34)\n\ndef resnet50(pretrained):\n    return Resnet4Channel(encoder_depth=50)\n\n\n\n# copied from https:\/\/github.com\/fastai\/fastai\/blob\/master\/fastai\/vision\/learner.py\ndef _resnet_split(m): return (m[0][6],m[1])\n","71e062bd":"f1_score = partial(fbeta, thresh=0.35, beta=1)","dfa746a2":"def _resnet_split(m): return (m[0][6],m[1])","5869148a":"class FocalLoss(nn.Module):\n    def __init__(self, alpha=1, gamma=2, logits=False, reduce=True):\n        super(FocalLoss, self).__init__()\n        self.alpha = alpha\n        self.gamma = gamma\n        self.logits = logits\n        self.reduce = reduce\n    def forward(self, inputs, targets):\n        if self.logits:\n            BCE_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduce=False)\n        else:\n            BCE_loss = F.binary_cross_entropy(inputs, targets, reduce=False)\n        pt = torch.exp(-BCE_loss)\n        F_loss = self.alpha * (1-pt)**self.gamma * BCE_loss\n\n        if self.reduce:\n            return torch.mean(F_loss)\n        else:\n            return F_loss\n        ","e951d5f3":"learn = create_cnn(\n    data,\n    resnet34,\n    cut=-2,\n    split_on=_resnet_split,\n    loss_func=FocalLoss(logits=True,alpha=alpha_log),\n    path=path,    \n    metrics=[f1_score], \n)","c2a5552a":"learn.lr_find()","7c443fbf":"learn.recorder.plot()","036d40dd":"learn.fit_one_cycle(1,4e-2)","ac24e53a":"learn.recorder.plot_losses()\nlearn.recorder.plot()","1acc8c35":"learn.unfreeze()\nlearn.lr_find(num_it=100)","677c5b09":"learn.recorder.plot()","0567e1d5":"lr=1e-3\nlearn.fit_one_cycle(4, slice(lr\/10,lr))\n","41bb3ad9":"learn.save('4_epochs')","bd4d2bc9":"learn.recorder.plot(skip_start=0,skip_end=0)","14f9f790":"learn.recorder.plot_losses()\n","5537b071":"learn.recorder.plot_lr()\n\n","dce380ca":"pred,y=learn.get_preds()","a9f9a07e":"pred_test,_=learn.get_preds(ds_type=DatasetType.Test)","dd50f1df":"pred_test_tta,_=learn.TTA(ds_type=DatasetType.Test)","a0aeda31":"th_t = np.array([0.565,0.39,0.55,0.345,0.33,0.39,0.33,0.45,0.38,0.39,\n               0.34,0.42,0.31,0.38,0.49,0.50,0.38,0.43,0.46,0.40,\n               0.39,0.505,0.37,0.47,0.41,0.545,0.32,0.1])","bb2c23bd":"from sklearn.metrics import f1_score as f1_sc\n","2e4f26fd":"def eval_pred(pred,y):\n    ths=np.arange(0.001,1,0.01)\n    preds_s=F.sigmoid(pred)\n    th_val=ths[np.argmax([f1_sc(y,preds_s>th,average='macro') for th in ths])]\n    print('F1 macro: ',f1_sc(to_np(y),to_np(preds_s)>th_t,average='macro'))\n    print(f'F1 macro (th = {th_val}): ',f1_sc(to_np(y),to_np(preds_s)>th_val,average='macro'))\n    plt.plot(f1_sc(to_np(y),to_np(preds_s)>th_t,average=None),label='opt')\n    plt.plot(f1_sc(to_np(y),to_np(preds_s)>th_val,average=None),label='valid')\n    plt.legend()","3e106295":"ths=np.arange(0.001,1,0.01)\npreds_s=F.sigmoid(pred)\nth_val=ths[np.argmax([f1_sc(y,preds_s>th,average='macro') for th in ths])]","b546c4c0":"eval_pred(pred,y)","492c4306":"def save_pred(pred, th=0.5, fname='protein_classification.csv'):\n    pred_list = []\n    for line in pred:\n        s = ' '.join(list([str(i) for i in np.nonzero(line>th)[0]]))\n        pred_list.append(s)\n        \n    sample_df = pd.read_csv(sample_csv)\n    sample_list = list(sample_df.Id)\n    #fnames_=[fname.split('\/')[-1] for fname in learn.data.test_ds.fnames]\n    pred_dic = dict((key, value) for (key, value) \n                in zip(test_ids,pred_list))\n    pred_list_cor = [pred_dic[id] for id in sample_list]\n    df = pd.DataFrame({'Id':sample_list,'Predicted':pred_list_cor})\n    df.to_csv(fname, header=True, index=False)","eb4a7f8d":"save_pred(to_np(F.sigmoid(pred_test)), th=th_val, fname=f'protein_classification_{np.around(th_val,decimals=2)}.csv')\n\nsave_pred(to_np(F.sigmoid(pred_test)), th=th_t, fname='protein_classification_customth.csv')","db72568d":"save_pred(to_np(F.sigmoid(pred_test_tta)), th=th_val, fname=f'protein_classification_{np.around(th_val,decimals=2)}_tta.csv')\n\nsave_pred(to_np(F.sigmoid(pred_test_tta)), th=th_t, fname='protein_classification_customth_tta.csv')","1fc877bd":"Focal loss implementation taken from the salt identification challenge","5f4f6599":"### I adapted the open function to load 4 layers and the show batch function to only show 3 layers, the fourth wouldve been interpreted as alpha value (transparency) which looks bad","c4a42c5e":"### The iterative splitting into val and trn set is alot better","9020f7aa":"### Definition of the 4layer resnet, fastai version by W Horton","90115840":"### Here I add the class weighting in the loss function","2de45dcf":"### Now first I predict on the validation set and then fit a threshold for the whole dataset","41d28653":"### These Thresholds are shamelessly stolen from Iafoss kernel**","5d7d6752":"There was a weird bug that if the last batch is size=1 the batchnorm throws an error that took me a way too long to debug so I make sure that the split leads to a size of the last batch larger than 1","21b61661":"# The Idea of this Kernel\nIn this kernel i largely merged the fastai v1 starter by Horton and the fastai rgby by iafoss.\nI (in my opinion) simplified some stuffabout the dataset and loading.\nI added:\n1. Iterative Stratified splitting the dataset into train and validation \n2. Class weighted Focalloss (the alpha parameter)\n3. Oversampling of the dataset\n4. The now standart onecycle instead of multicycle learning\n\nNext I would like to optimize the augmentation. So far TTA also is less performant than the regular predict which I find confusing.\nSo far I got into the top 20% with this which is nice.","7cadcad4":"Load dataset with transformations calculate image stats and then normalize them by it. One should use larger sample sizes since the variance in the dataset is quite large, but my tests show this is not too important so Ill keept it at one batch","048c5cf3":"This is a weird hacky version to the oversampler going. I did not manage to get it to work using the proper y_train nhot encoded targets but I had to throw out all classes except the most imbalanced one. I'll try to do this in a non stupid way later","caf5040e":"## These pictures look awesome","aa93722d":"### The choices for the oversampling and weight scaling parameters are pretty arbitrary.\nFor me the log scaled class weights worked best, the randomoversampling I did not really test yet since I frequently get a CUDA out of memory when the overall dataset is to large (which I dont really understand)\nI scaled the oversampling linearly but cut off the classes that are not too imbalanced to not have too large of a dataset for sampling.\nI initially tried to change the sampler of the training set to torch's weightedrandomsampler but somehow it never sampled as I intended it."}}