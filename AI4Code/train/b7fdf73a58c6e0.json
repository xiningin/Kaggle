{"cell_type":{"10778250":"code","81b83b8c":"code","b83bb54b":"code","0688b4ba":"code","62e48f56":"code","6505b422":"code","d22ee8fa":"code","726d0ef2":"code","2ca0f11e":"code","6c8e5033":"code","67ff8b13":"code","6e6e946f":"code","30cc9c7c":"code","6b4a7912":"code","74d1c50f":"code","708b53f8":"markdown"},"source":{"10778250":"# Ensure plotly==3.10.0 Newer versions have a BUG affecting fbprophet\n\nimport pandas as pd\nimport numpy as np\n\nimport datetime\nimport holidays\n\nfrom fbprophet import Prophet\nfrom fbprophet.make_holidays import make_holidays_df\nfrom fbprophet.plot import add_changepoints_to_plot\n\n\nfrom sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\nplt.rcParams['figure.figsize']=(20,10)\n#plt.style.use('fivethirtyeight')\nplt.style.use('ggplot')","81b83b8c":"#function to remove any negative forecasted values.\ndef remove_negs(ts):\n    ts['yhat'] = ts['yhat'].clip(lower=0)\n    ts['yhat_lower'] = ts['yhat_lower'].clip(lower=0)\n    ts['yhat_upper'] = ts['yhat_upper'].clip(lower=0)","b83bb54b":"# Define dates to exclude i.e. holidays and weekends\n# TO-DO: Figure out Eid al-Fitr and Eid al-Adha\n\n# Holidays not built-in e.g. idd and declared holidays\n#holidays = pd.DataFrame({\n#    'holiday' : 'holiday',\n#    'ds': pd.date_range(start='2019-12-25',end='2019-12-26'),\n#})\n\nyear_list = [2014, 2015, 2016, 2017, 2018, 2019, 2020]\nholidays = make_holidays_df(year_list=year_list, country='KE')\n\n# Get country holidays\n#holidays = pd.DataFrame(holidays.Kenya(years = 2019).items(), columns=['ds', 'holiday'])\nholidays = holidays.append([{'holiday' : 'Moi Day', 'ds' : pd.to_datetime('2018-10-10')}])\nholidays = holidays.append([{'holiday' : 'Moi Day', 'ds' : pd.to_datetime('2019-10-10')}])\nholidays = holidays.append([{'holiday' : 'Moi Day', 'ds' : pd.to_datetime('2020-10-10')}])\n#holidays['ds'] = pd.to_datetime(holidays['ds'])\n#print(holidays)\n\n\n#weekends = pd.DataFrame({\n#    'holiday': 'weekend',\n#    'ds': pd.to_datetime(['2019-12-14','2019-12-15','2019-12-21','2019-12-22','2019-12-28','2019-12-29',\n#                         '2020-01-04','2020-01-05','2020-01-11','2020-01-12']),\n#})\n\n#combine dataframes into one - concatenation of holidays after removing duplicates\nexclude_days = holidays #pd.concat([holidays, weekends], ignore_index=True)\nexclude_days.drop_duplicates(keep='first')\nexclude_days = exclude_days.sort_values(by='ds')\n#print(exclude_days.tail())","0688b4ba":"ticker = 'KCB'\npredict_days = 30\nhistory_5years = 1305  # Use days == Last 5 calendar years data excluding weekends (365*5 - 52*2*5 == 1825-520 = 1305)\n\ndata_folder = 'data\/'\ndata_file = data_folder+ticker+'.csv'\n\n\n\ndata = pd.read_csv(data_file, index_col='Date', parse_dates=True)\ndata.drop(['Open', 'High', 'Low', 'Vol.', 'Change %'], axis=1, inplace=True)\n\ndata = data.tail(history_5years) #exclude 52 weeks weekends for 5 years\ndata = data.dropna() # remove blank\/missing values\n#2014-09-25  14.45\n\n#print(data.head())\n#print(data.shape)\n#data.info()\n\ndata.plot()","62e48f56":"df = data.reset_index().rename(columns={'Date':'ds', 'Close':'y'})\ndf['y'] = np.log(df['y'])\n\n#holidays=holidays #interval_width=0.95 confidence interval default == 80%\n#seasonality_mode='multiplicative'\n\nmodel = Prophet(interval_width=0.95, changepoint_prior_scale=0.01) \n\nmodel.fit(df)\n\nfuture = model.make_future_dataframe(periods=predict_days, freq = 'd') #forecasting for 1 year from now.\nfuture = future[~future['ds'].isin(exclude_days['ds'])] #Exclude days in forecast\nfuture = future[future[\"ds\"].apply(lambda x: x.weekday())<5] #Filter out weekends in predictions\n#print(future.tail())\n\nforecast = model.predict(future)\n\nremove_negs(forecast)\n","6505b422":"#print(future)\nfigure=model.plot(forecast)","d22ee8fa":"model.plot_components(forecast);","726d0ef2":"fig_changes=model.plot(forecast)\na=add_changepoints_to_plot(fig_changes.gca(),model,forecast)","2ca0f11e":"two_years = forecast.set_index('ds').join(data)\ntwo_years = two_years[['Close', 'yhat', 'yhat_upper', 'yhat_lower' ]].dropna().tail(history_5years) #Last 3(1095) years\ntwo_years['yhat']=np.exp(two_years.yhat)\ntwo_years['yhat_upper']=np.exp(two_years.yhat_upper)\ntwo_years['yhat_lower']=np.exp(two_years.yhat_lower)\n\n#print(forecast.tail())\nprint(two_years.tail())\ntwo_years[['Close', 'yhat']].plot()","6c8e5033":"#'average error'\ntwo_years_AE = (two_years.yhat - two_years.Close)\nprint (two_years_AE.describe())","67ff8b13":"# R-squared \/ coefficient of determination\nprint('R2 SCORE == '+str(round(r2_score(two_years.Close, two_years.yhat),4)))\nprint('     MSE == '+str(round(mean_squared_error(two_years.Close, two_years.yhat),4))) #for MSE, closer to zero is better\nprint('     MAE == '+str(round(mean_absolute_error(two_years.Close, two_years.yhat),4)))","6e6e946f":"\nfig, ax1 = plt.subplots()\nax1.plot(two_years.Close)\nax1.plot(two_years.yhat)\nax1.plot(two_years.yhat_upper, color='black',  linestyle=':', alpha=0.5)\nax1.plot(two_years.yhat_lower, color='black',  linestyle=':', alpha=0.5)\n\nax1.set_title('Actual '+ticker+' (Orange) vs Forecasted Upper & Lower Confidence (Black)')\nax1.set_ylabel('Share Price')\nax1.set_xlabel('Date')","30cc9c7c":"full_df = forecast.set_index('ds').join(data)\nfull_df['yhat']=round(np.exp(full_df['yhat']),2)\nfull_df['yhat_upper']=round(np.exp(full_df['yhat_upper']),2)\nfull_df['yhat_lower']=round(np.exp(full_df['yhat_lower']),2)","6b4a7912":"\nfig, ax1 = plt.subplots()\nax1.plot(full_df.Close)\nax1.plot(full_df.yhat, color='black', linestyle=':')\nax1.fill_between(full_df.index, full_df['yhat_upper'], full_df['yhat_lower'], alpha=0.5, color='darkgray')\nax1.set_title('[ '+ticker+' ] - Actual (Orange) vs Forecasted (Black) with Confidence Bands')\nax1.set_ylabel('Share Price')\nax1.set_xlabel('Date')\n\nL=ax1.legend() #get the legend\nL.get_texts()[0].set_text('Actual') #change the legend text for 1st plot\nL.get_texts()[1].set_text('Forecasted') #change the legend text for 2nd plot","74d1c50f":"print('Forecast Data -------------------------------------------')\n#full_df.tail()\n\nprint (full_df[['yhat', 'yhat_lower', 'yhat_upper']].tail(predict_days))","708b53f8":"# Additive Model\n- Uses default additive model as defined in fbprophet. With shares the magnitude of the seasonal effect in the data does not depend on the magnitude of the data.\n\nAdditive: Value = Trend + Cyclical Effect + Seasonal Effect + Error\n\nMultiplicative: Value = Trend \\* Cyclical Effect \\* Seasonal Effect \\* Error\n\n- FBprophet divides a time series into trend and seasonality, which might contain yearly, weekly and daily.\n- \\****** We should not use weekly seasonality since there is no trading on weekend.\n\n# Equation\n\n### y(t) = g(t) + s(t) + h(t) + e(t)\n\ng(t) == growth function which models non-periodic changes\n\ns(t) == periodic changes due to weekly or yearly seasonality\n\nh(t) == effects of holidays\n\ne(t) == error term.\n\n\n# TO-DO\n- How to handle missing days data for days not trade\n- Specific announcement regressors e.g. dividend, share split\/consolidation, rate cap for banking\n- Predictions for stocks below KES. 1bob"}}