{"cell_type":{"feb2eb5e":"code","bb107d03":"code","96faa578":"code","4fc7aa16":"code","45b00b71":"code","fc39b9fb":"code","a6435e13":"code","9b11dddf":"code","61a84303":"code","f89e7e38":"code","144628ba":"code","47f2dbca":"code","53acf4ff":"code","11cb2fc9":"code","4cea6996":"code","86fc4d59":"code","9914a081":"code","1c640d1b":"code","da062c2d":"code","dcb2c54a":"code","f7be5e95":"code","1bffa1cd":"code","685ac6ee":"code","a227647b":"code","10ddfa39":"code","9672866a":"code","b1664371":"code","b7e9e1ff":"code","e23d845d":"code","b5669f91":"code","ada77174":"code","941f1e95":"code","f2247eac":"code","ea0ebed6":"code","74f81756":"markdown","ecc1c95e":"markdown","25bd3693":"markdown","e0a9183f":"markdown","f417dea3":"markdown","8cd16e0c":"markdown","d79f330c":"markdown","c10798c0":"markdown","1b164fe8":"markdown","8873a8eb":"markdown","12915db7":"markdown"},"source":{"feb2eb5e":"import tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers \nimport tensorflow_addons as tfa\n\nfrom kaggle_datasets import KaggleDatasets\nimport matplotlib.pyplot as plt\nimport numpy as np","bb107d03":"try:\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    print(\"Device :\",tpu.master())\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\n    \nexcept:\n    strategy = tf.distribute.get_strategy()\n\nprint(\"Number of replicas : \", strategy.num_replicas_in_sync)\n\n\nAUTO = tf.data.experimental.AUTOTUNE\nprint(tf.__version__)","96faa578":"from kaggle_datasets import KaggleDatasets\nGCS_PATH = KaggleDatasets().get_gcs_path('gan-getting-started')\nGCS_PATH","4fc7aa16":"GCS_PATH_MONET = KaggleDatasets().get_gcs_path('monet-tfrecords-extdata')\nGCS_PATH_MONET","45b00b71":"MONET_FILENAMES = tf.io.gfile.glob(str(GCS_PATH + '\/monet_tfrec\/*.tfrec'))\nprint(\"Monet TFRecord Files : \", len(MONET_FILENAMES))\nprint(MONET_FILENAMES)\n\nPHOTO_FILENAMES = tf.io.gfile.glob(str(GCS_PATH + '\/photo_tfrec\/*.tfrec'))\nprint(\"Photo TFRecord Files : \", len(PHOTO_FILENAMES))","fc39b9fb":"# Version 2\n\nNEW_MONET_FILENAMES = tf.io.gfile.glob(str(GCS_PATH_MONET + '\/monet*.tfrec'))\nprint(\"New Monet TFRecord Files : \", len(NEW_MONET_FILENAMES))\n#print(NEW_MONET_FILENAMES)\n\nTOTAL_MONET_FILES = []\nTOTAL_MONET_FILES.extend(MONET_FILENAMES)\nTOTAL_MONET_FILES.extend(NEW_MONET_FILENAMES)\nprint(len(TOTAL_MONET_FILES))","a6435e13":"TOTAL_MONET_FILES","9b11dddf":"IMAGE_SIZE = [256,256]\n\ndef decode_image(image):\n    \n    image = tf.image.decode_jpeg(image, channels = 3)\n    image = (tf.cast(image, tf.float32) \/ 127.5) - 1\n    image = tf.reshape(image, [*IMAGE_SIZE, 3])\n    \n    return image\n\n\ndef read_tfrecord(example):\n    tfrecord_format = {\n        \"image_name\" : tf.io.FixedLenFeature([], tf.string),\n        \"image\" : tf.io.FixedLenFeature([], tf.string),\n        \"target\" : tf.io.FixedLenFeature([], tf.string)\n    }\n    \n    example = tf.io.parse_single_example(example, tfrecord_format)\n    image = decode_image(example['image'])\n    return image","61a84303":"def load_dataset(filenames, labeled = True, ordered = False):\n    dataset = tf.data.TFRecordDataset(filenames)\n    dataset = dataset.map(read_tfrecord, num_parallel_calls = tf.data.experimental.AUTOTUNE)\n    \n    return dataset","f89e7e38":"import random\nimport tensorflow as tf\nimport math\nimport tensorflow.keras.backend as K \n\n\ndef transform_rotation(image, height, rotation):\n    \n    dim = height\n    xdim = height % 2\n    rotation = rotation * tf.random.uniform([1], dtype = 'float32')\n    rotation = math.pi\/180 * rotation\n    \n    c1 = tf.math.cos(rotation)\n    s1 = tf.math.sin(rotation)\n    one = tf.constant([1], dtype='float32')\n    zero = tf.constant([0], dtype='float32')\n    \n    rotation_matrix = tf.reshape(tf.concat([c1,s1,zero,-s1,c1,zero,zero,zero,one],axis=0),shape=[3,3])\n\n    \n    x = tf.repeat(tf.range(dim\/\/2,-dim\/\/2,-1), dim) # shape like : [111222333]\n    y = tf.tile(tf.range(-dim\/\/2,dim\/\/2), [dim]) #shape like: [123123123]\n    z = tf.ones([dim*dim], dtype='int32')\n    \n    idx = tf.stack([x,y,z])\n    \n    idx2 = K.dot(rotation_matrix, tf.cast(idx, dtype='float32'))\n    idx2 = K.cast(idx2, dtype='int32')\n    idx2 = K.clip(idx2,-dim\/\/2+1+xdim, dim\/\/2)\n    \n    idx3 = tf.stack([dim\/\/2 -idx2[0], dim\/\/2 -1 + idx2[1,]])\n    \n    \n    d = tf.gather_nd(image, tf.transpose(idx3))\n    return tf.reshape(d, shape = [dim, dim, 3])\n    \n    # rotation matrix\n    \ndef data_augment(image):\n    \n    p_rotate = tf.random.uniform([], 0, 1.0, dtype = tf.float32)\n    p_spatial = tf.random.uniform([], 0, 1.0, dtype = tf.float32)\n    p_crop = tf.random.uniform([], 0, 1.0, dtype = tf.float32)\n    \n    if p_crop > 0.5 : \n        temp_size = random.randint(260, 290)\n        image = tf.image.resize(image, size= [temp_size,temp_size])\n        image = tf.image.random_crop(image, size = [256,256,3])\n        \n        if p_crop > 0.9:\n            temp_size2 = random.randint(290, 310)\n            image = tf.image.resize(image, [temp_size2, temp_size2])\n            image = tf.image.random_crop(image, size = [256,256,3])\n            \n        \n    if p_rotate > 0.75:\n        image = tf.image.rot90(image,k=3)\n    elif p_rotate > .5:\n        image = tf.image.rot90(image,k=2)\n    elif p_rotate > 0.25:\n        image = tf.image.rot90(image,k=1)\n\n    if p_rotate >=0.3:\n        image = transform_rotation(image, height=256,rotation=45.)\n        \n        \n    if p_spatial >0.6:\n        image = tf.image.random_flip_left_right(image)\n        image = tf.image.random_flip_up_down(image)\n        if p_spatial >0.85:\n            image = tf.image.transpose(image)\n\n    return image\n    \n    ","144628ba":"AUTO = tf.data.experimental.AUTOTUNE\n\ndef get_gan_dataset(monet_files, photo_files, augment = None, repeat = True, shuffle = True, batch_size = 1):\n    monet_ds = load_dataset(monet_files)\n    photo_ds = load_dataset(photo_files)\n    \n    if augment: \n        monet_ds = monet_ds.map(augment, num_parallel_calls = AUTO)\n        photo_ds = photo_ds.map(augment, num_parallel_calls = AUTO)\n        \n    \n    if repeat:\n        monet_ds = monet_ds.repeat()\n        photo_ds= photo_ds.repeat()\n        \n    if shuffle:\n        monet_ds = monet_ds.shuffle(2048)\n        photo_ds = photo_ds.shuffle(2048)\n        \n    \n    monet_ds = monet_ds.batch(batch_size, drop_remainder = True)\n    photo_ds = photo_ds.batch(batch_size, drop_remainder = True)\n    monet_ds = monet_ds.cache()\n    photo_ds = photo_ds.cache()\n    monet_ds = monet_ds.prefetch(AUTO)\n    photo_ds = photo_ds.prefetch(AUTO)\n    \n    gan_ds = tf.data.Dataset.zip((monet_ds, photo_ds))\n    \n    \n    return gan_ds","47f2dbca":"#gan_dataset = get_gan_dataset(MONET_FILENAMES, PHOTO_FILENAMES, augment = data_augment, repeat = True, shuffle = True, batch_size = 1)","53acf4ff":"# Version 2 update\n\ngan_dataset = get_gan_dataset(TOTAL_MONET_FILES, PHOTO_FILENAMES, augment = data_augment, repeat = True, shuffle = True, batch_size = 1)\n","11cb2fc9":"import matplotlib.pyplot as plt","4cea6996":"a_tuple = None\nfor data in gan_dataset.take(1):\n    a_tuple = data","86fc4d59":"# PAINTING\n\nplt.imshow(np.array(a_tuple[0]).squeeze())","9914a081":"# PHOTO IMAGE\n\nplt.imshow(np.array(a_tuple[1]).squeeze())","1c640d1b":"OUTPUT_CHANNELS = 3\n\ndef downsample(filters, size, apply_instancenorm = True):\n    initializer = tf.random_normal_initializer(0., 0.02)\n    gamma_init = keras.initializers.RandomNormal(mean = 0.0, stddev = 0.02)\n    \n    result = keras.Sequential()\n    result.add(layers.Conv2D(filters, size, strides = 2, padding= 'same', kernel_initializer = initializer, use_bias = False))\n    \n    if apply_instancenorm:\n        result.add(tfa.layers.InstanceNormalization(gamma_initializer = gamma_init))\n        \n    result.add(layers.LeakyReLU())\n    \n    return result","da062c2d":"def upsample(filters, size, apply_dropout = False):\n    \n    initializer = tf.random_normal_initializer(0., 0.02)\n    gamma_init = keras.initializers.RandomNormal(mean = 0.0, stddev = 0.02)\n    \n    result = keras.Sequential()\n    result.add(layers.Conv2DTranspose(filters, size, strides = 2, padding = 'same', kernel_initializer = initializer, use_bias = False))\n    result.add(tfa.layers.InstanceNormalization(gamma_initializer = gamma_init))\n    \n    if apply_dropout:\n        result.add(layers.Dropout(0.5))\n        \n    result.add(layers.ReLU())\n    \n    return result","dcb2c54a":"def Generator():\n    \n    inputs = layers.Input(shape = [256,256,3])\n    \n    down_stack = [\n        downsample(64, 4, apply_instancenorm = False),\n        downsample(128,4),\n        downsample(256,4),\n        downsample(512,4),\n        downsample(512,4),\n        downsample(512,4),\n        downsample(512,4),\n        downsample(512,4),\n    ]\n    \n    \n    up_stack = [\n        upsample(512, 4, apply_dropout=True),\n        upsample(512, 4, apply_dropout=True),  \n        upsample(512, 4, apply_dropout=True),\n        upsample(512, 4),\n        upsample(256, 4),\n        upsample(128, 4),\n        upsample(64, 4)\n    ]\n    \n    initializer = tf.random_normal_initializer(0., 0.02)\n    last = layers.Conv2DTranspose(OUTPUT_CHANNELS, 4, strides = 2, padding = \"same\",kernel_initializer = initializer, \n                                 activation = 'tanh')\n    \n    x = inputs\n    \n    # Downsampling\n    \n    skips = []\n    for down in down_stack:\n        x = down(x)\n        skips.append(x)\n    \n    skips = reversed(skips[:-1])\n    \n    for up, skip in zip(up_stack, skips):\n        \n        x = up(x)\n        x = layers.Concatenate()([x, skip])\n        \n    x = last(x)\n        \n        \n    return keras.Model(inputs = inputs, outputs = x)","f7be5e95":"def Discriminator():\n    \n    initializer = tf.random_normal_initializer(0., 0.02)\n    gamma_init = keras.initializers.RandomNormal(mean = 0.0, stddev = 0.02)\n    \n    inp = layers.Input(shape = [256, 256, 3], name = 'input_image')\n    \n    x = inp\n    \n    down1 = downsample(64, 4, False)(x)\n    down2 = downsample(128, 4)(down1)\n    down3 = downsample(256, 4)(down2)\n    \n    zero_pad1 = layers.ZeroPadding2D()(down3)\n    conv = layers.Conv2D(512, 4, strides = 1, kernel_initializer = initializer, use_bias = False)(zero_pad1)\n    norm1 = tfa.layers.InstanceNormalization(gamma_initializer = gamma_init)(conv)\n    \n    leaky_relu = layers.LeakyReLU()(norm1)\n    \n    zero_pad2 = layers.ZeroPadding2D()(leaky_relu)\n    \n    last = layers.Conv2D(1, 4, strides = 1, kernel_initializer = initializer)(zero_pad2)\n    \n    return tf.keras.Model(inputs = inp, outputs = last)\n    \n    ","1bffa1cd":"with strategy.scope():\n    \n    monet_generator = Generator()\n    photo_generator = Generator()\n    \n    monet_discriminator = Discriminator()\n    photo_discriminator = Discriminator()","685ac6ee":"with strategy.scope():\n    \n    monet_generator_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1= 0.5)\n    photo_generator_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1 = 0.5)\n    \n    monet_discriminator_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1 = 0.5)\n    photo_discriminator_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1 = 0.5)","a227647b":"class CycleGAN(keras.Model):\n    \n    \n    def __init__(self, monet_generator, photo_generator, monet_discriminator, photo_discriminator, lambda_cycle = 10):\n        \n        super(CycleGAN, self).__init__()\n        \n        self.m_gen = monet_generator\n        self.p_gen = photo_generator\n        self.m_disc = monet_discriminator\n        self.p_disc = photo_discriminator\n        self.lambda_cycle = lambda_cycle\n        \n        \n    def compile(self, m_gen_optimizer, p_gen_optimizer, m_disc_optimizer, p_disc_optimizer, gen_loss_fn, disc_loss_fn, cycle_loss_fn, identity_loss_fn):\n        super(CycleGAN, self).compile()\n        \n        self.m_gen_optimizer = m_gen_optimizer\n        self.p_gen_optimizer = p_gen_optimizer\n        self.m_disc_optimizer = m_disc_optimizer\n        self.p_disc_optimizer = p_disc_optimizer\n        \n        self.gen_loss_fn = gen_loss_fn\n        self.disc_loss_fn = disc_loss_fn\n        self.cycle_loss_fn = cycle_loss_fn\n        self.identity_loss_fn = identity_loss_fn\n        \n        \n    def train_step(self, batch_data):\n        \n        \n        real_monet, real_photo = batch_data\n        \n        with tf.GradientTape(persistent = True) as tape:\n            \n            \n            fake_monet = self.m_gen(real_photo, training = True)\n            cycled_photo = self.p_gen(fake_monet, training = True)\n            \n            fake_photo = self.p_gen(real_monet, training = True)\n            cycled_monet = self.m_gen(fake_photo, training = True)\n            \n            # generating itself\n            same_monet = self.m_gen(real_monet, training = True)\n            same_photo = self.p_gen(real_photo, training = True)\n            \n            # discriminator used to check, inputing real images\n            disc_real_monet = self.m_disc(real_monet, training = True)\n            disc_real_photo = self.p_disc(real_photo, training = True)\n            \n            # discriminator used to check, inputing fake images\n            disc_fake_monet = self.m_disc(fake_monet, training = True)\n            disc_fake_photo = self.p_disc(fake_photo, training = True)\n            \n            # evaluates generator loss\n            monet_gen_loss = self.gen_loss_fn(disc_fake_monet)\n            photo_gen_loss = self.gen_loss_fn(disc_fake_photo)\n            \n            # total cycle consistency loss\n            total_cycle_loss = self.cycle_loss_fn(real_monet, cycled_monet, self.lambda_cycle) + self.cycle_loss_fn(real_photo, cycled_photo, self.lambda_cycle)\n            \n            \n            # total generator loss\n            \n            total_monet_gen_loss = monet_gen_loss + total_cycle_loss + self.identity_loss_fn(real_monet, same_monet, self.lambda_cycle)\n            \n            \n            total_photo_gen_loss = photo_gen_loss + total_cycle_loss + self.identity_loss_fn(real_photo, same_photo, self.lambda_cycle)\n            \n            \n            # total discriminator loss\n            monet_disc_loss = self.disc_loss_fn(disc_real_monet, disc_fake_monet)\n            photo_disc_loss = self.disc_loss_fn(disc_real_photo, disc_fake_photo)\n            \n            # gradients for generator & discriminator\n            monet_generator_gradients = tape.gradient(total_monet_gen_loss,\n                                                  self.m_gen.trainable_variables)\n            photo_generator_gradients = tape.gradient(total_photo_gen_loss,\n                                                  self.p_gen.trainable_variables)\n            monet_discriminator_gradients = tape.gradient(monet_disc_loss,\n                                                      self.m_disc.trainable_variables)\n            photo_discriminator_gradients = tape.gradient(photo_disc_loss,\n                                                      self.p_disc.trainable_variables)\n            # gradients to the optimizer\n            self.m_gen_optimizer.apply_gradients(zip(monet_generator_gradients, self.m_gen.trainable_variables))\n            self.p_gen_optimizer.apply_gradients(zip(photo_generator_gradients, self.p_gen.trainable_variables))\n            self.m_disc_optimizer.apply_gradients(zip(monet_discriminator_gradients, self.m_disc.trainable_variables))\n            self.p_disc_optimizer.apply_gradients(zip(photo_discriminator_gradients, self.p_disc.trainable_variables))\n            \n            \n        \n        return {\n            \"monet_gen_loss\" : total_monet_gen_loss,\n            \"photo_gen_loss\" : total_photo_gen_loss,\n            \"monet_disc_loss\" : monet_disc_loss,\n            \"photo_disc_loss\" : photo_disc_loss\n        }","10ddfa39":"\"\"\"class EarlyStopping_custom(tf.keras.callbacks.EarlyStopping):\n    \n    def __init__(self, monitor, mode, patience, restore_best_weights = True):\n        \n        super(EarlyStopping_custom, self).__init__()\n        self.restore_best_weights = restore_best_weights\n        self.monitor = monitor\n        self.mode = mode\n        self.\"\"\"","9672866a":"with strategy.scope():\n    \n    def discriminator_loss(real, generated):\n        \n        real_loss = tf.keras.losses.BinaryCrossentropy(from_logits = True, reduction = tf.keras.losses.Reduction.NONE)(tf.ones_like(real), real)\n        \n        generated_loss = tf.keras.losses.BinaryCrossentropy(from_logits = True, reduction = tf.keras.losses.Reduction.NONE)(tf.zeros_like(generated), generated)\n        \n        total_disc_loss = real_loss + generated_loss\n        \n        return total_disc_loss * 0.5","b1664371":"with strategy.scope():\n    \n    def generator_loss(generated):\n        \n        return tf.keras.losses.BinaryCrossentropy(from_logits = True, reduction = tf.keras.losses.Reduction.NONE)(tf.ones_like(generated), generated)","b7e9e1ff":"with strategy.scope():\n    \n    def calc_cycle_loss(real_image, cycled_image, LAMBDA):\n        loss1 = tf.reduce_mean(tf.abs(real_image - cycled_image))\n        \n        return LAMBDA * loss1","e23d845d":"with strategy.scope():\n    \n    def identity_loss(real_image, same_image, LAMBDA):\n        \n        loss = tf.reduce_mean(tf.abs(real_image - same_image))\n        return LAMBDA * 0.5 * loss","b5669f91":"with strategy.scope():\n    \n    monet_generator_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1 = 0.5)\n    photo_generator_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1 = 0.5)\n    \n    monet_discriminator_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1 = 0.5)\n    photo_discriminator_optimizer = tf.keras.optimizers.Adam(2e-4, beta_1 = 0.5)\n    \n    ","ada77174":"with strategy.scope():\n    \n    cycle_gan_model = CycleGAN(\n        monet_generator, photo_generator, monet_discriminator, photo_discriminator\n    )\n    \n    cycle_gan_model.compile(\n        m_gen_optimizer = monet_generator_optimizer, \n        p_gen_optimizer = photo_generator_optimizer, \n        m_disc_optimizer = monet_discriminator_optimizer, \n        p_disc_optimizer = photo_discriminator_optimizer, \n        gen_loss_fn = generator_loss,\n        disc_loss_fn = discriminator_loss,\n        cycle_loss_fn = calc_cycle_loss,\n        identity_loss_fn = identity_loss\n    )","941f1e95":"EPOCHS_NUM = 31","f2247eac":"BATCH_SIZE = 2\nsteps_per_epoch = (7038\/\/BATCH_SIZE)\n#gan_dataset = get_gan_dataset(MONET_FILENAMES,PHOTO_FILENAMES,augment=data_augument,repeat=True,shuffle=True,batch_size=BATCH_SIZE)","ea0ebed6":"cycle_gan_model.fit(\n    #full_dataset,\n    gan_dataset,\n    epochs = EPOCHS_NUM,\n    #steps_per_epoch = (max(n_monet_samples, n_photo_samples) \/\/ BATCH_SIZE)\n    steps_per_epoch = steps_per_epoch\n)","74f81756":"* IMAGE_SIZE\n* NUMBER OF EPOCHS\n* Optimizer Selected","ecc1c95e":"## Version Log\n\n1. Initial NB\n2. Added [monet-tfrecords-extdata](https:\/\/www.kaggle.com\/doanquanvietnamca\/monet-tfrecords-extdata) & trained for full 31 epochs","25bd3693":"### Train the CycleGAN tutorial","e0a9183f":"Version 2 update....\n\nAdding extra Monet TFRecords Data","f417dea3":"### Necessary Imports","8cd16e0c":"### Developing the GAN Structure","d79f330c":"## Data Augment","c10798c0":"### GAN Dataset","1b164fe8":"### Visualizing the Dataset\n\nVersion 2 Update","8873a8eb":"# Notebook in making...","12915db7":"### Possible Hyperparameters to tune"}}