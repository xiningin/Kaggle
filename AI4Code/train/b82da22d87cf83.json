{"cell_type":{"f52c27cf":"code","9b08e951":"code","b97e75c1":"code","7029ffb0":"code","b9a00e2a":"code","4f9f1117":"code","5897d50c":"code","32c0ead1":"code","bc255941":"code","1e14b4c2":"code","08757ccc":"code","92af2f66":"code","e97e1f82":"code","de975487":"code","6fab825a":"code","82e9f003":"code","e4af6a2c":"code","b5f7641a":"code","e1f6fb3a":"code","b532bdfb":"code","a1b3eb48":"code","330ef89c":"code","3d914be5":"code","1f3ccfd0":"code","a00336dd":"code","76fa9daf":"code","96d83606":"code","daf0f110":"code","ae7142cf":"code","b61ac587":"code","4b06d15a":"code","cee536d9":"markdown","a015a4a3":"markdown","15e4ddd8":"markdown","86f67f1f":"markdown","13cd1362":"markdown","e75a0623":"markdown"},"source":{"f52c27cf":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9b08e951":"import nltk                                # Python library for NLP\nfrom nltk.corpus import twitter_samples    # sample Twitter dataset from NLTK\nimport matplotlib.pyplot as plt            # library for visualization\nimport random                              # pseudo-random number generator\nimport numpy as np\nfrom os import getcwd\nimport pandas as pd  ","b97e75c1":"nltk.download('twitter_samples')","7029ffb0":"all_positive_tweets = twitter_samples.strings('positive_tweets.json')\nall_negative_tweets = twitter_samples.strings('negative_tweets.json')","b9a00e2a":"print('Number of positive tweets: ', len(all_positive_tweets))\nprint('Number of negative tweets: ', len(all_negative_tweets))\n\nprint('\\nThe type of all_positive_tweets is: ', type(all_positive_tweets))\nprint('The type of a tweet entry is: ', type(all_negative_tweets[0]))","4f9f1117":"fig = plt.figure(figsize=(5, 5))\n\n# labels for the two classes\nlabels = 'Positives', 'Negative'\n\n# Sizes for each slide\nsizes = [len(all_positive_tweets), len(all_negative_tweets)] \n\n# Declare pie chart, where the slices will be ordered and plotted counter-clockwise:\nplt.pie(sizes, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=90)\n\n# Equal aspect ratio ensures that pie is drawn as a circle.\nplt.axis('equal')  \n\n# Display the chart\nplt.show()","5897d50c":"# print positive in greeen\nprint('\\201[92m' + all_positive_tweets[random.randint(0,5000)])\n\n# print negative in red\nprint('\\0201[91m' + all_negative_tweets[random.randint(0,5000)])","32c0ead1":"# Our selected sample. Complex enough to exemplify each step\ntweet = all_positive_tweets[2277]\nprint(tweet)","bc255941":"nltk.download('stopwords')","1e14b4c2":"import re                                  # library for regular expression operations\nimport string                              # for string operations\n\nfrom nltk.corpus import stopwords          # module for stop words that come with NLTK\nfrom nltk.stem import PorterStemmer        # module for stemming\nfrom nltk.tokenize import TweetTokenizer","08757ccc":"print('\\201[92m' + tweet)\nprint('\\201[94m')\n\n# remove old style retweet text \"RT\"\ntweet2 = re.sub(r'^RT[\\s]+', '', tweet)\n\n# remove hyperlinks\ntweet2 = re.sub(r'https?:\\\/\\\/.*[\\r\\n]*', '', tweet2)\n\n# remove hashtags\n# only removing the hash # sign from the word\ntweet2 = re.sub(r'#', '', tweet2)\n\nprint(tweet2)","92af2f66":"print()\nprint('\\201[92m' + tweet2)\nprint('\\201[94m')\n\n# instantiate tokenizer class\ntokenizer = TweetTokenizer(preserve_case=False, strip_handles=True,\n                               reduce_len=True)\n\n# tokenize tweets\ntweet_tokens = tokenizer.tokenize(tweet2)\n\nprint()\nprint('Tokenized string:')\nprint(tweet_tokens)","e97e1f82":"#Import the english stop words list from NLTK\nstopwords_english = stopwords.words('english') \n\nprint('Stop words\\n')\nprint(stopwords_english)\n\nprint('\\nPunctuation\\n')\nprint(string.punctuation)","de975487":"print()\nprint('\\201[92m')\nprint(tweet_tokens)\nprint('\\201[94m')\n\ntweets_clean = []\n\nfor word in tweet_tokens: # Go through every word in your tokens list\n    if (word not in stopwords_english and  # remove stopwords\n        word not in string.punctuation):  # remove punctuation\n        tweets_clean.append(word)\n\nprint('removed stop words and punctuation:')\nprint(tweets_clean)","6fab825a":"print()\nprint('\\201[92m')\nprint(tweets_clean)\nprint('\\201[94m')\n\n# Instantiate stemming class\nstemmer = PorterStemmer() \n\n# Create an empty list to store the stems\ntweets_stem = [] \n\nfor word in tweets_clean:\n    stem_word = stemmer.stem(word)  # stemming word\n    tweets_stem.append(stem_word)  # append to the list\n\nprint('stemmed words:')\nprint(tweets_stem)","82e9f003":"def process_tweet(tweet):\n    \"\"\"Process tweet function.\n    Input:\n        tweet: a string containing a tweet\n    Output:\n        tweets_clean: a list of words containing the processed tweet\n\n    \"\"\"\n    stemmer = PorterStemmer()\n    stopwords_english = stopwords.words('english')\n    # remove stock market tickers like $GE\n    tweet = re.sub(r'\\$\\w*', '', tweet)\n    # remove old style retweet text \"RT\"\n    tweet = re.sub(r'^RT[\\s]+', '', tweet)\n    # remove hyperlinks\n    tweet = re.sub(r'https?:\\\/\\\/.*[\\r\\n]*', '', tweet)\n    # remove hashtags\n    # only removing the hash # sign from the word\n    tweet = re.sub(r'#', '', tweet)\n    # tokenize tweets\n    tokenizer = TweetTokenizer(preserve_case=False, strip_handles=True,\n                               reduce_len=True)\n    tweet_tokens = tokenizer.tokenize(tweet)\n\n    tweets_clean = []\n    for word in tweet_tokens:\n        if (word not in stopwords_english and  # remove stopwords\n                word not in string.punctuation):  # remove punctuation\n            # tweets_clean.append(word)\n            stem_word = stemmer.stem(word)  # stemming word\n            tweets_clean.append(stem_word)\n\n    return tweets_clean","e4af6a2c":"def build_freqs(tweets, ys):\n    \"\"\"Build frequencies.\n    Input:\n        tweets: a list of tweets\n        ys: an m x 1 array with the sentiment label of each tweet\n            (either 0 or 1)\n    Output:\n        freqs: a dictionary mapping each (word, sentiment) pair to its\n        frequency\n    \"\"\"\n    # Convert np array to list since zip needs an iterable.\n    # The squeeze is necessary or the list ends up with one element.\n    # Also note that this is just a NOP if ys is already a list.\n    yslist = np.squeeze(ys).tolist()\n\n    # Start with an empty dictionary and populate it by looping over all tweets\n    # and over all processed words in each tweet.\n    freqs = {}\n    for y, tweet in zip(yslist, tweets):\n        for word in process_tweet(tweet):\n            pair = (word, y)\n            if pair in freqs:\n                freqs[pair] += 1\n            else:\n                freqs[pair] = 1    \n    return freqs","b5f7641a":"tweets = all_positive_tweets + all_negative_tweets\nprint(\"Number of tweets: \", len(tweets))","e1f6fb3a":"labels = np.append(np.ones((len(all_positive_tweets))), np.zeros((len(all_negative_tweets))))","b532bdfb":"# create frequency dictionary\nfreqs = build_freqs(tweets, labels)\n\n# check data type\nprint(f'type(freqs) = {type(freqs)}')\n\n# check length of the dictionary\nprint(f'len(freqs) = {len(freqs)}')","a1b3eb48":"keys = ['happi', 'merri', 'nice', 'good', 'bad', 'sad', 'mad', 'best', 'pretti',\n        '\u2764', ':)', ':(', '\ud83d\ude12', '\ud83d\ude2c', '\ud83d\ude04', '\ud83d\ude0d', '\u265b',\n        'song', 'idea', 'power', 'play', 'magnific']\n\n# list representing our table of word counts.\n# each element consist of a sublist with this pattern: [<word>, <positive_count>, <negative_count>]\ndata = []\n\n# loop through our selected words\nfor word in keys:\n    \n    # initialize positive and negative counts\n    pos = 0\n    neg = 0\n    \n    # retrieve number of positive counts\n    if (word, 1) in freqs:\n        pos = freqs[(word, 1)]\n        \n    # retrieve number of negative counts\n    if (word, 0) in freqs:\n        neg = freqs[(word, 0)]\n        \n    # append the word counts to the table\n    data.append([word, pos, neg])\n    \ndata","330ef89c":"fig, ax = plt.subplots(figsize = (8, 8))\n\n# convert positive raw counts to logarithmic scale. we add 1 to avoid log(0)\nx = np.log([x[1] + 1 for x in data])  \n\n# do the same for the negative counts\ny = np.log([x[2] + 1 for x in data]) \n\n# Plot a dot for each pair of words\nax.scatter(x, y)  \n\n# assign axis labels\nplt.xlabel(\"Log Positive count\")\nplt.ylabel(\"Log Negative count\")\n\n# Add the word as the label at the same position as you added the points just before\nfor i in range(0, len(data)):\n    ax.annotate(data[i][0], (x[i], y[i]), fontsize=12)\n\nax.plot([0, 9], [0, 9], color = 'red') # Plot the red line that divides the 2 areas.\nplt.show()\n","3d914be5":"all_positive_tweets = twitter_samples.strings('positive_tweets.json')\nall_negative_tweets = twitter_samples.strings('negative_tweets.json')\n\ntweets = all_positive_tweets + all_negative_tweets ## Concatenate the lists. \nlabels = np.append(np.ones((len(all_positive_tweets),1)), np.zeros((len(all_negative_tweets),1)), axis = 0)\n\n# split the data into two pieces, one for training and one for testing (validation set) \ntrain_pos  = all_positive_tweets[:4000]\ntrain_neg  = all_negative_tweets[:4000]\n\ntrain_x = train_pos + train_neg \n\nprint(\"Number of tweets: \", len(train_x))","1f3ccfd0":"def extract_features(tweet, freqs):\n    '''\n    Input: \n        tweet: a list of words for one tweet\n        freqs: a dictionary corresponding to the frequencies of each tuple (word, label)\n    Output: \n        x: a feature vector of dimension (1,3)\n    '''\n    # process_tweet tokenizes, stems, and removes stopwords\n    word_l = process_tweet(tweet)\n    \n    # 3 elements in the form of a 1 x 3 vector\n    x = np.zeros((1, 3)) \n    \n    #bias term is set to 1\n    x[0,0] = 1 \n    \n    ### START CODE HERE (REPLACE INSTANCES OF 'None' with your code) ###\n    \n    # loop through each word in the list of words\n    for word in word_l:\n        \n        # increment the word count for the positive label 1\n        x[0,1] += freqs.get((word, 1.0),0)\n        \n        # increment the word count for the negative label 0\n        x[0,2] += freqs.get((word, 0.0),0)\n        \n    ### END CODE HERE ###\n    assert(x.shape == (1, 3))\n    return x","a00336dd":"# test 1\ntmp1 = extract_features(train_x[0], freqs)\nprint(tmp1)","76fa9daf":"def sigmoid(z): \n    '''\n    Input:\n        z: is the input (can be a scalar or an array)\n    Output:\n        h: the sigmoid of z\n    '''\n    \n\n    # calculate the sigmoid of z\n    h = 1\/(1+np.exp(-z))\n  \n    \n    return h","96d83606":"theta = [7e-08, 0.0005239, -0.00055517]","daf0f110":"# UNQ_C4 (UNIQUE CELL IDENTIFIER, DO NOT EDIT)\ndef predict_tweet(tweet, freqs, theta):\n    '''\n    Input: \n        tweet: a string\n        freqs: a dictionary corresponding to the frequencies of each tuple (word, label)\n        theta: (3,1) vector of weights\n    Output: \n        y_pred: the probability of a tweet being positive or negative\n    '''\n    \n    \n    # extract the features of the tweet and store it into x\n    x = extract_features(tweet,freqs)\n    \n    # make the prediction using x and theta\n    y_pred =sigmoid(np.dot(x,theta))\n    \n    \n    \n    return y_pred","ae7142cf":"my_tweet = \"Many years onward, Indian media is still trying to prove to their public that they actually did something in February 2019  by using edited clips.  This shows insecurity, their hopelessness and incompetence.  They wouldn't needed it if they had footage but they have potato.\"\n#my_tweet = 'happy birthday to my brother boss'\nprint(process_tweet(my_tweet))\ny_hat = predict_tweet(my_tweet, freqs, theta)\nprint(y_hat)\nif y_hat > 0.5:\n    print('Positive sentiment')\nelse: \n    print('Negative sentiment')","b61ac587":"my_tweet = \"are you loud or quiet\"\n#my_tweet = 'happy birthday to my brother boss'\nprint(process_tweet(my_tweet))\ny_hat = predict_tweet(my_tweet, freqs, theta)\nprint(y_hat)\nif y_hat > 0.5:\n    print('Positive sentiment')\nelse: \n    print('Negative sentiment')","4b06d15a":"my_tweet = \"Nice So sweet and lovely Allah bless protect be happy always and give you long life. Aameen\"\n#my_tweet = 'happy birthday to my brother boss'\nprint(process_tweet(my_tweet))\ny_hat = predict_tweet(my_tweet, freqs, theta)\nprint(y_hat)\nif y_hat > 0.5:\n    print('Positive sentiment')\nelse: \n    print('Negative sentiment')","cee536d9":"# Test on Training Data","a015a4a3":"# Import Libraries","15e4ddd8":"# Predication on Pakistan Random Tweats Data","86f67f1f":"# Data Visualization","13cd1362":"# Data Preprocessing","e75a0623":"# Load Tweat_Sample Dataset"}}