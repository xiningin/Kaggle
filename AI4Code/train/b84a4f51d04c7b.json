{"cell_type":{"50ba6e67":"code","5e476b8e":"code","0116013e":"code","84d35569":"code","30e71cfe":"code","b64189b8":"code","5051f2c0":"code","e691d5da":"code","e48dbc29":"code","28ebb40a":"code","53b9b325":"code","7cdc9f60":"code","3606dfe2":"code","0ced93fb":"code","f040b2a2":"code","9e99557c":"code","0c6ce030":"code","9ff07af5":"code","80cfdf09":"code","fe4337d0":"code","5aaa9acd":"code","77bb256e":"code","9e5614e5":"code","a2bdf4a7":"code","10837cf8":"markdown","d8022f57":"markdown","2435d0c6":"markdown","a610c8a5":"markdown","e02d8bc2":"markdown","faaca831":"markdown","6f5f8703":"markdown","a4fe4a49":"markdown","d314a66a":"markdown"},"source":{"50ba6e67":"import numpy as np\nimport torch","5e476b8e":"tensor = torch.rand(4, 3)\ntensor","0116013e":"type(tensor)","84d35569":"numpy_from_tensor = tensor.numpy()                   \nnumpy_from_tensor","30e71cfe":"type(numpy_from_tensor)","b64189b8":"torch.is_tensor(tensor)","5051f2c0":"torch.is_tensor(numpy_from_tensor)","e691d5da":"numpy_from_tensor[0, 0] = 100.0\n\nnumpy_from_tensor","e48dbc29":"tensor","28ebb40a":"numpy_arr = np.array([[1.0, 2.0, 3.0], \n                      [10.0, 20.0, 30.0],\n                      [100.0, 200.0, 300.0]])\n\nnumpy_arr","53b9b325":"tensor_from_numpy = torch.from_numpy(numpy_arr)\ntensor_from_numpy","7cdc9f60":"type(tensor_from_numpy)","3606dfe2":"torch.is_tensor(tensor_from_numpy)","0ced93fb":"tensor_from_numpy[0] = 1\ntensor_from_numpy","f040b2a2":"numpy_arr","9e99557c":"np_array_one = np.array([4, 8])\nnp_array_one","0c6ce030":"tensor_from_array_one = torch.as_tensor(np_array_one)\ntensor_from_array_one","9ff07af5":"np_array_one[1] = 5\nnp_array_one","80cfdf09":"tensor_from_array_one","fe4337d0":"np_array_two = np.array([2, 2])\nnp_array_two","5aaa9acd":"tensor_from_array_two = torch.tensor(np_array_two)\n\ntensor_from_array_two","77bb256e":"np_array_two[1] = 4\nnp_array_two","9e5614e5":"tensor_from_array_two","a2bdf4a7":"#End of code","10837cf8":"#### The Numpy arrays and Tensor share the same memory\nThe tensor and numpy_from_tensor are shallow copies and share the same memory as the original numpy array. Modifying the original array affects the values of both tensor and numpy_from_tensor","d8022f57":"#### torch.tensor() reads out the data from whatever it is passed, and constructs a leaf variable","2435d0c6":"## Interoperablity between Numpy arrays and Pytorch Tensors","a610c8a5":"#### Converting a numpy array to a Tensor","e02d8bc2":"#### Converting tensor to numpy arrays","faaca831":"### The numpy arrays use the same memory as the PyTorch tensor","6f5f8703":"#### Convert the data into a torch.Tensor. \n\nIf the data is already a Tensor with the same dtype and device, no copy will be performed, otherwise a new Tensor will be returned","a4fe4a49":"#### in this method the tensor and array do not share memory","d314a66a":"#### The NumPy array and the Torch tensor share memory"}}