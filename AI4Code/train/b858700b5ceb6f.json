{"cell_type":{"501c7742":"code","587c71ea":"code","48a306e5":"code","7758d91a":"code","9d8a8b5e":"code","d8d4f174":"code","8ffd2de0":"code","c679a7ca":"code","52a15c17":"code","2a78ff5d":"code","22d74ee0":"code","a2589381":"code","1a1de911":"code","fb9abaa0":"code","a81f86fe":"code","a22105bb":"code","b6f48e69":"code","a331a7fe":"code","97cabcfb":"code","1d45a621":"code","f406690d":"markdown","1ded60f9":"markdown","6c93ea28":"markdown","8a009e89":"markdown","5f1075ef":"markdown","59323f06":"markdown","e8504040":"markdown","9bd81b8e":"markdown","d11b58d3":"markdown","0e267670":"markdown","ac21d103":"markdown","6421b7fa":"markdown","cc8ecee1":"markdown","2969105a":"markdown","655d65be":"markdown","00ccd6ee":"markdown","28f31a13":"markdown","1a416cf2":"markdown","923efed5":"markdown","f1d4d3fb":"markdown","494399fc":"markdown","10bc15a5":"markdown","0e5f2c8a":"markdown","fdf6b3fa":"markdown","4b3e1e76":"markdown","427265eb":"markdown","d008189b":"markdown","4d8deb02":"markdown","1711c038":"markdown","f8356d94":"markdown","4b929548":"markdown"},"source":{"501c7742":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport requests\nimport re\nimport string\nimport random\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nfrom nltk.corpus import stopwords\nfrom sklearn.metrics.pairwise import linear_kernel\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom nltk.tokenize import RegexpTokenizer\nfrom PIL import Image\nfrom io import BytesIO\nfrom sklearn.metrics.pairwise import cosine_similarity\n\npd.set_option('display.max_rows', 500)","587c71ea":"raw_books = pd.read_csv('..\/input\/7k-books-with-metadata\/books.csv')\nraw_books.head(3)","48a306e5":"print('ROWS: ', raw_books.shape[0])\nprint('COLUMNS: ', raw_books.shape[1])","7758d91a":"raw_books['categories'].nunique()","9d8a8b5e":"raw_books['categories'].unique()","d8d4f174":"raw_books['categories'].value_counts().head(10)","8ffd2de0":"books = raw_books.loc[raw_books['categories'].isin(['Fiction', 'Juvenile Fiction', \n                                                    'Biography & Autobiography', 'History'])]","c679a7ca":"books.tail(5)","52a15c17":"plt.figure(figsize=(10, 6))\nsns.set_style('darkgrid')\nsns.countplot(x=books['categories'], palette='Blues_r', edgecolor='black')\n\nplt.show()","2a78ff5d":"print(books['title'] [120])\nprint(books['description'] [120])\nprint('\\n\\n')\nprint(books['title'] [200])\nprint(books['description'] [200])","22d74ee0":"\nbooks.dropna(subset=['description'], inplace=True)","a2589381":"books['description'].isna().sum()","1a1de911":"# USING REGULAR EXPRESSIONS (REGEX)\nbooks = books[~books.description.str.contains('[0-9].*[0-9].*[printing]')]","fb9abaa0":"# CONVERT DESCRIPTION INTO VECTORS AND USE BIGRA,\ntf = TfidfVectorizer(ngram_range=(2, 2), stop_words='english', lowercase=False)\ntfidf_matrix = tf.fit_transform(books['description'])\ntotal_words = tfidf_matrix.sum(axis=0)\n\n# WORK FREQUENCY\nfreq = [(word, total_words[0, index]) for word, index in tf.vocabulary_.items()]\nfreq = sorted(freq, key=lambda x: x[1], reverse=True)\n\n# CREATE A PANDAS DATAFRA,E\nbigram = pd.DataFrame(freq)\nbigram.rename(columns = {0:'bigram', 1: 'count'}, inplace = True) \n\n# TOP 20 BIGRAMS\nbigram = bigram.head(20)\n\n# PLOT BARPLOT\nplt.figure(figsize=(8, 8))\nsns.barplot(x=bigram['count'], y=bigram['bigram'], color='blue')\nplt.show()","a81f86fe":"# REMOVE NON ASCII CHARACTERS\ndef remove_non_ascii(string):\n    return \"\".join(c for c in string if ord(c) < 128)\n\n# MAKE DESCRIPTION TEXT LOWER CASE\ndef make_lower_case(text):\n    return text.lower()\n\n# REMOVE STOP WORDS\ndef remove_stop_words(text):\n    text = text.split()\n    stops = set(stopwords.words('english'))\n    text = [word for word in text if not word in stops]\n    text = \" \".join(text)\n    return text\n\n# REMOVE PUNCTUATIONS\ndef remove_punctuation(text):\n    tokenizer = RegexpTokenizer(r'\\w+')\n    text = tokenizer.tokenize(text)\n    text = \" \".join(text)\n    return text\n\n# REMOVE HTML CODES\ndef remove_html(text):\n    html_pattern = re.compile('<.*?>')\n    return html_pattern.sub(r'', text)","a22105bb":"books['cleaned_description'] = books['description'].apply(remove_non_ascii)\nbooks['cleaned_description'] = books.cleaned_description.apply(make_lower_case)\nbooks['cleaned_description'] = books.cleaned_description.apply(remove_stop_words)\nbooks['cleaned_description'] = books.cleaned_description.apply(remove_punctuation)\nbooks['cleaned_description'] = books.cleaned_description.apply(remove_html)","b6f48e69":"def recommend(title, category):\n    \n    # MATCH THE CATEGORY WITH THE COLUMN \"CATEGORIES\" OF THE DATASET\n    data = books.loc[books['categories'] == category] \n    # RESET INDEX\n    data.reset_index(level = 0, inplace = True) \n    \n    # INDEX TO A PANDAS SERIES\n    indices = pd.Series(data.index, index = data['title'])\n    \n    # CONVERT THE BOOK TITLE INTO VECTORS AND USE BIGRAM\n    tf = TfidfVectorizer(analyzer='word', ngram_range=(2, 2), min_df = 1, stop_words='english')\n    tfidf_matrix = tf.fit_transform(data['title'])\n    \n    # CALCULATE THE SIMILARITY MEASURE\n    similarity = cosine_similarity(tfidf_matrix, tfidf_matrix)\n    \n    # GET THE INDEX OF ORIGINAL TITLE\n    index = indices[title]\n    \n    # PAIRWISE SIMILARITY SCORES\n    similarity = list(enumerate(similarity[index]))\n    # SORT THE BOOKS\n    similarity = sorted(similarity, key=lambda x: x[1], reverse=True)\n    \n    # GET TOP 5 MOST SIMILAR BOOKS\n    similarity  = similarity [1:6]\n    \n    # INDICES OF TOP 5\n    book_indices = [i[0] for i in similarity]\n\n    # TOP 5 RECOMMENDATION\n    rec = data[['title', 'thumbnail']].iloc[book_indices]\n    \n    # PRINT THE BOOKS TITLE\n    print(rec['title'])\n    \n    # PRINT THE TOP 5 BOOK COVER\n    for i in rec['thumbnail']:\n        response = requests.get(i)\n        img = Image.open(BytesIO(response.content))\n        plt.figure()\n        plt.imshow(img)","a331a7fe":"# TEST\nrecommend(\"A People's History of the United States\", \"History\")","97cabcfb":"def recommend(title, category):\n    \n    # MATCH THE CATEGORY WITH THE COLUMN \"CATEGORIES\" OF THE DATASET\n    data = books.loc[books['categories'] == category] \n    # RESET INDEX\n    data.reset_index(level = 0, inplace = True) \n    \n    # INDEX TO A PANDAS SERIES\n    indices = pd.Series(data.index, index = data['title'])\n    \n    # CONVERT THE BOOK TITLE INTO VECTORS AND USE BIGRAM\n    tf = TfidfVectorizer(analyzer='word', ngram_range=(2, 2), min_df = 1, stop_words='english')\n    tfidf_matrix = tf.fit_transform(data['cleaned_description'])\n    \n    # CALCULATE THE SIMILARITY MEASURE\n    similarity = cosine_similarity(tfidf_matrix, tfidf_matrix)\n    \n    # GET THE INDEX OF ORIGINAL TITLE\n    index = indices[title]\n    \n    # PAIRWISE SIMILARITY SCORES\n    similarity = list(enumerate(similarity[index]))\n    # SORT THE BOOKS\n    similarity = sorted(similarity, key=lambda x: x[1], reverse=True)\n    \n    # GET TOP 5 MOST SIMILAR BOOKS\n    similarity  = similarity [1:6]\n    \n    # INDICES OF TOP 5\n    book_indices = [i[0] for i in similarity]\n\n    # TOP 5 RECOMMENDATION\n    rec = data[['title', 'thumbnail']].iloc[book_indices]\n    \n    # PRINT THE BOOKS TITLE\n    print(rec['title'])\n    \n    # PRINT THE TOP 5 BOOK COVER\n    for i in rec['thumbnail']:\n        response = requests.get(i)\n        img = Image.open(BytesIO(response.content))\n        plt.figure()\n        plt.imshow(img)","1d45a621":"# TEST\nrecommend(\"Taken at the Flood\", \"Fiction\")","f406690d":"# Reference","1ded60f9":"**Content-based recommendation systems** recommends items to a user by taking similarity of items, based on the description or features. It identifies the similarity between the products based on its description. It also considers the user previous history in order to recommend a similar product.","6c93ea28":"**According to the dataset author**: The dataset provides close to seven thousand books containing identifiers, title, subtitle, authors, categories, thumbnail url, description, published year, average rating, and number of ratings. The dataset is provided as comma-delimited CSV. ","8a009e89":"Exclude books whose description contains the number of print runs. For example: **\"15,000 printing\"**.","5f1075ef":"### Top 10 categories (genres)","59323f06":"Select only the books with four genres (**Fiction, Juvenile Fiction, Biography & Autobiography, History**) most present in the dataset.","e8504040":"### Select genres","9bd81b8e":"# Data Wrangling","d11b58d3":"The function below does the same thing as the previous one, but this time the **book descriptio**n is used to make the recommendations.","0e267670":"### Categories (genres)","ac21d103":"This notebook is inspired by [Building a Content-Based Book Recommendation Engine](https:\/\/towardsdatascience.com\/building-a-content-based-book-recommendation-engine-9fd4d57a4da) article from the medium.","6421b7fa":"### Create new column called \"cleaned_description\" and apply all functions","cc8ecee1":"As stated earlier, there are names in the categories (genres) column that are not real genres.","2969105a":"### View title and description of two random examples","655d65be":"The genre \"Fiction\" has almost 5x more examples than the second place \"Juvenile Fiction\"","00ccd6ee":"![](https:\/\/www.researchgate.net\/profile\/Barthelemy_Durette2\/publication\/275954089\/figure\/tbl2\/AS:614304592166937@1523473036482\/Formulae-of-the-similarity-and-distance-measures.png)\n <center> \n    <a href=\"https:\/\/www.researchgate.net\/figure\/Formulae-of-the-similarity-and-distance-measures_tbl2_275954089\">Source<\/a> \n<\/center> ","28f31a13":"### Shape","1a416cf2":"This dataset contains a considerable amount of books.","923efed5":"# Top 20 bigrams","f1d4d3fb":"For more information about this theme, click [here](https:\/\/medium.com\/@gshriya195\/top-5-distance-similarity-measures-implementation-in-machine-learning-1f68b9ecb0a3)","494399fc":"- **isbn13**: ISBN 13 Identifier\n- **isbn10**: ISBN 10 Identifier\n- **title**: Title of book\n- **subtitle**: Subtitle of book\n- **authors**: Authors of book separated by \";\"\n- **categories**: Categories separated by \";\"\n- **thumbnail**: URL of thumbnail\n- **description**: Description of book\n- **published_year**: Year of publication\n- **average_rating**: Average rating in Goodreads","10bc15a5":"# Preprocessing","0e5f2c8a":"There are 567 different types of categories (genres) of books, which leads one to suspect that this dataset has genres written in the wrong way.","fdf6b3fa":"# Make recommendations by title","4b3e1e76":"# Make recommendations by description","427265eb":"The dataset is unbalanced, however there is no problem for now, since we will only calculate the similarity distance.","d008189b":"# Content-based recommendation system\n","4d8deb02":"# EDA","1711c038":"### Drop other rows","f8356d94":"# Load data","4b929548":"### Drop rows with **null values** in description"}}