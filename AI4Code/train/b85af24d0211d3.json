{"cell_type":{"02521839":"code","e692675e":"code","485e932b":"code","5195a6e0":"code","c15d4cda":"code","1ca80393":"code","86529fd5":"code","9e9bfdf8":"code","22e9d3ad":"markdown","64a57300":"markdown","7145acf0":"markdown","c22b586d":"markdown","f7603bda":"markdown"},"source":{"02521839":"import numpy as np \nimport pandas as pd\nimport os\nfrom csv import DictReader\nfrom vowpalwabbit import pyvw\nfrom datetime import datetime","e692675e":"class CFG:\n    roundoff = 4\n    cutoff_point = 1200\n    nof_cols = 300","485e932b":"\ndef process_line(row, train = True):\n    \n    # initialize the strings for the categorical and numerical\n    # variables namespaces, respectively\n    n_c = ''; n_n = ''; result = ''\n    \n    # loop over entries in our dictionary representing a row\n    for k,v in row.items():\n        if k in num_cols:\n            n_n += \" %s\" % str(k.replace('_', '')) + ':' \n            n_n += str(np.round(np.float(v ), CFG.roundoff))\n        if k in cat_cols:\n            n_c += \" %s\" % 'invid' + '_' + str(v)   \n \n    if train: \n        label = row['target']\n    else:\n        label = '-1'\n        \n    result = label + ' ' + row['row_id'] + '|' + n_n + '|' + n_c\n        \n    return result","5195a6e0":"# read the first few rows so we get an idea of the columns\nxdat = pd.read_csv('..\/input\/ubiquant-market-prediction\/train.csv', nrows = 10)\nxdat.head(5)","c15d4cda":"# f_0, ..., f_299 are the numerical ones\n# num_cols = ['f_' + str(i) for i in range(300)]\nnum_cols = ['f_' + str(i) for i in range(CFG.nof_cols)]\n\n# investment_id is the only categorical one that makes sense as model input - time_id does not overlap anyway, since we are dealing with a time series problem\ncat_cols = ['investment_id']\n","1ca80393":"# vw = pyvw.vw(b=21, random_seed=17, loss_function='squared', passes = 1, learning_rate=0.7, k=True, \n#              c=True,  quiet= False)\n\n# start_time = datetime.now()\n# for e, row in enumerate( DictReader(open('..\/input\/ubiquant-market-prediction\/train.csv')) ):\n#     if e % 1e5 == 0: print(\"{}\\t{} passed.\".format(e, datetime.now() - start_time))\n#     # training Vowpal Wabbit with current example\n#     vw.learn(process_line(row))\n    \n    \nvw = pyvw.vw(initial_regressor = '..\/input\/vw-models\/xmodel_full_v1.vw')    ","86529fd5":"# we skip evaluation for now ;-) \n\nimport ubiquant\n","9e9bfdf8":"env = ubiquant.make_env()  \niter_test = env.iter_test()\nfor (test_df, sample_prediction_df) in iter_test:\n    \n    # build predictions for this segment\n    predictions = []\n\n    # build predictions using the same logic as above for training,\n    # i.e. creating VW-formatted lines on the fly\n    # the only change - for consistency - is to_dict(), \n    # since we are iterating over a pandas dataframe\n    # and not reading line-by-line from a file.\n    for row in test_df.iterrows():    \n        predictions.append(vw.predict(process_line(row[1].to_dict(), train = False)))\n    \n    sample_prediction_df['target'] = predictions    \n    sample_prediction_df['target'].fillna(0, inplace = True)\n    env.predict(sample_prediction_df)  ","22e9d3ad":"Vowpal input format requires defining which columns are numeric and categorical. For faster iteration, we only use a subset of the numerical columns - checking if we can get away with using everything and staying within Kaggle kernel execution time is on my TODO list ;-) ","64a57300":"# Functions\n\nOur workhorse function: take a single line from the train \/ test file,\nread it as a dictionary and create a string matching the VW input format:\nhttps:\/\/github.com\/VowpalWabbit\/vowpal_wabbit\/wiki\/Input-format","7145acf0":"# Data\n","c22b586d":"# Eval and submit","f7603bda":"# Model\n\nFor a full overview of command line arguments: https:\/\/github.com\/VowpalWabbit\/vowpal_wabbit\/wiki\/Command-Line-Arguments\n\nWe will train a linear model (no interactions), optimising MSE:"}}