{"cell_type":{"62d5bc92":"code","52648333":"code","551c7d9f":"code","447816f0":"code","475e9545":"code","234baabd":"code","ce67d33d":"code","5af74b5f":"code","684a248d":"code","bd4a88c5":"code","b012d484":"code","ef3194b3":"code","af42fa85":"code","c53bc809":"code","5e5206a8":"code","4849b983":"code","dc51f2c9":"code","85b8277e":"code","fa26928a":"code","541b71cb":"code","b744a1a8":"code","d380d80a":"code","4eeb9f46":"code","f6a19873":"code","2ead634b":"code","ebc1007e":"code","e9b7a8f2":"code","0b0ed993":"code","a01bc71a":"code","f8251c70":"code","e9eb5607":"code","4e3c2302":"markdown","61c60191":"markdown","58d5f554":"markdown","0d488a04":"markdown","2d74e005":"markdown","92dd440d":"markdown","fb2eec92":"markdown","6ad1d3f8":"markdown","0d352272":"markdown","32264a7a":"markdown","5ce8fcc1":"markdown","6ab9e6b9":"markdown","1d944287":"markdown","43dd11a1":"markdown","d03bab4d":"markdown","63c26d91":"markdown","afa60022":"markdown","d28f427b":"markdown","7122d5c7":"markdown"},"source":{"62d5bc92":"import pandas as pd","52648333":"df = pd.read_csv('..\/input\/parks.csv', index_col=['Park Code'])","551c7d9f":"df.head(3)","447816f0":"df.iloc[2]","475e9545":"df.iloc[[2]]","234baabd":"type(df.iloc[[2]])","ce67d33d":"df.loc['BADL']","5af74b5f":"type(df.loc['BADL'])","684a248d":"type(df.loc[['BADL']])","bd4a88c5":"df.loc[['BADL']]","b012d484":"df.loc[['BADL', 'ARCH', 'ACAD']]","ef3194b3":"df.iloc[[2, 1, 0]]","af42fa85":"df[:3]","c53bc809":"df[3:6]","5e5206a8":"df['State'].head(4)","4849b983":"type(df['State'])","dc51f2c9":"df.State.head(3)","85b8277e":"df.Park Code","fa26928a":"df.columns = [col.replace(' ', '_').lower() for col in df.columns]\nprint(df.columns)","541b71cb":"df[['state', 'acres']][:3]","b744a1a8":"df.state[:3]","d380d80a":"df.state.iloc[2]","4eeb9f46":"type(df.state.iloc[2])","f6a19873":"df.state.iloc[[2]]","2ead634b":"type(df.state.iloc[[2]])","ebc1007e":"(df.state == 'UT').head(3)","e9b7a8f2":"type((df.state == 'UT').head(3))","0b0ed993":"df[df.state == 'UT']","a01bc71a":"df[(df.latitude > 60) | (df.acres > 10**6)].head(3)","f8251c70":"df[df['park_name'].str.split().apply(lambda x: len(x) == 3)].head(3)","e9eb5607":"df[df.state.isin(['WA', 'OR', 'CA'])].head()","4e3c2302":"### Indexing: Multiple Rows\nIf we need multiple rows, we can pass in multiple index values. Note that this changes the order of the results!","61c60191":"We get a series of the results of the boolean. Passing that series into a dataframe gives us the subset of the dataframe where the boolean evaluates to `True`.","58d5f554":"You can also use more complicated expressions, including lambdas.","0d488a04":"### Indexing: Columns\nWe can access a subset of the columns in a dataframe by placing the list of columns in brackets like so:","2d74e005":"but `df.Park Code` will fail as there's a space in the name:","92dd440d":"### Indexing: Columns and Rows\nIf we need to subset by both columns and rows, you can stack the commands we've already learned.","fb2eec92":"### Key Companion Methods: `isin` and `isnull`\nThese methods make it much easier and faster to perform some very common tasks. Suppose we wanted to find all parks on the West coast. `isin` makes that simple:","6ad1d3f8":"### Indexing: Single Rows\nThe simplest way to access a row is to pass the row number to the `.iloc` method. Note that first row is zero, just like list indexes.","0d352272":"We can only access the 'Park Code' column by passing its name as a string in brackets, like `df['Park Code']`. I recommend either always using that approach or always converting your column names into a valid format as soon as you read in the data so that you don't have to mix the two methods. It's just a bit tidier.\n\nIt's a good practice to clean your column names to prevent this sort of error. I'll use a very short cleaning function here since the names don't have any odd characters. By convention, the names should also be converted to lower case. Pandas is case sensitive, so future calls to all of the columns will need to be updated.","32264a7a":"The main method for subsetting data in Pandas is called [boolean indexing](http:\/\/pandas.pydata.org\/pandas-docs\/stable\/indexing.html#boolean-indexing). First, let's take a look at what pandas does when we ask it to evaluate a boolean:","5ce8fcc1":"### Less Common Methods\nPandas offers many more indexing methods. You should probably stick to a few of them for the sake of keeping your code readable, but it's worth knowing they exist in case you need to read other people's code or have an unusual use case:\n\n- There are other ways to slice data with brackets. For the sake of readability, please don't use of them.\n- `.at` and `.iat`: like `.loc` and `.iloc` but much faster in exchange for only working on a single column and only returning a single result.\n- `.eval`: fast evaluation of a limited set of simple operators. `.query` works by calling this.\n- `.ix`: deprecated method that tried to determine if an index should be evaluated with .loc or .iloc. This led to a lot of subtle bugs! If you see this, you're looking at old code that won't work any more.\n- `.get`: like `.loc`, but will return a default value if the key doesn't exist in the index. Only works on a single column\/series.\n- `.lookup`: Not recommended. It's in the documentation, but it's unclear if this is actually still supported.\n- `.mask`: like boolean indexing, but returns a dataframe\/series of the same size as the original and anywhere that the boolean evaluates to `True` is set to `nan`.\n- `.query`: similar to boolean indexing. Faster for large dataframes. Only supports a restricted set of operations; don't use if you need `isnull()` or other dataframe methods.\n- `.take`: equivalent to `.iloc`, but can operate on either rows or columns.\n- `.where`: like boolean indexing, but returns a dataframe\/series of the same size as the original and anywhere that the boolean evaluates to `False` is set to `nan`.\n- [Multi-indexing](http:\/\/pandas.pydata.org\/pandas-docs\/stable\/advanced.html): potentially useful for small to mid sized heirarchical datasets. Slow on larger datasets.","6ab9e6b9":"### Indexing: Scalar Values\nAs you may have noticed, everything we've tried so far returns a small dataframe or series. If you need a single value, simply pass in a single column and index value.","1d944287":"Some of the logical operators are different:\n- `~` replaces `not`\n- `|` replaces `or`\n- `&` replaces `and`\n\nIf you have multiple arguments they'll need to be wrapped in parentheses. For example:","43dd11a1":"### Selecting a Subset of the Data","d03bab4d":"You can also access a single column as if it were an attribute of the dataframe, but only if the name has no spaces, uses only basic characters, and doesn't share a name with a dataframe method. So, `df.State` works:","63c26d91":"The other main approach is to pass a value from your dataframe's index to the `.loc` method:","afa60022":"Note that you will get a different return type if you pass a single value in a list.","d28f427b":"This tutorial will walk you through the essentials of how to index & filter data with Pandas. Think of it as a greatly condensed, opinionated, version of [the official indexing documentation.](http:\/\/pandas.pydata.org\/pandas-docs\/stable\/indexing.html#).\n\nWe'll start by loading Pandas and the data:","7122d5c7":"Slicing the dataframe just as if it were a list also works."}}