{"cell_type":{"13ee0e8f":"code","da6d3d67":"code","f86ad8f8":"code","c7a1c619":"code","16d0af13":"code","c2dce867":"code","0a05ee71":"code","71da9873":"code","f45a62c2":"code","8e519aaa":"markdown","3d03becc":"markdown","cdcd4672":"markdown","a041982e":"markdown","f32c9b10":"markdown","6a75e011":"markdown","86638c55":"markdown","d0bb4357":"markdown","f7c64b9f":"markdown","d0f8722b":"markdown"},"source":{"13ee0e8f":"import pandas as pd\nimport numpy as np\n\ndf = pd.read_csv(\"..\/input\/fifa-20-complete-player-dataset\/players_20.csv\")\n\ndf = df[['short_name','age', 'height_cm', 'weight_kg', 'overall', 'potential',\n       'value_eur', 'wage_eur', 'international_reputation', 'weak_foot',\n       'skill_moves', 'release_clause_eur', 'team_jersey_number',\n       'contract_valid_until', 'nation_jersey_number', 'pace', 'shooting',\n       'passing', 'dribbling', 'defending', 'physic', 'gk_diving',\n       'gk_handling', 'gk_kicking', 'gk_reflexes', 'gk_speed',\n       'gk_positioning', 'attacking_crossing', 'attacking_finishing',\n       'attacking_heading_accuracy', 'attacking_short_passing',\n       'attacking_volleys', 'skill_dribbling', 'skill_curve',\n       'skill_fk_accuracy', 'skill_long_passing', 'skill_ball_control',\n       'movement_acceleration', 'movement_sprint_speed', 'movement_agility',\n       'movement_reactions', 'movement_balance', 'power_shot_power',\n       'power_jumping', 'power_stamina', 'power_strength', 'power_long_shots',\n       'mentality_aggression', 'mentality_interceptions',\n       'mentality_positioning', 'mentality_vision', 'mentality_penalties',\n       'mentality_composure', 'defending_marking', 'defending_standing_tackle',\n       'defending_sliding_tackle', 'goalkeeping_diving',\n       'goalkeeping_handling', 'goalkeeping_kicking',\n       'goalkeeping_positioning', 'goalkeeping_reflexes']]\n\ndf = df[df.overall > 86] # extracting players with overall above 86\n\ndf = df.fillna(df.mean())\n\nnames = df.short_name.tolist() # saving names for later\n\ndf = df.drop(['short_name'], axis = 1) # drop the short_name column\ndf.head()","da6d3d67":"from sklearn import preprocessing\n\nx = df.values # numpy array\nscaler = preprocessing.MinMaxScaler()\nx_scaled = scaler.fit_transform(x)\nX_norm = pd.DataFrame(x_scaled)","f86ad8f8":"from sklearn.decomposition import PCA\n\npca = PCA(n_components = 2) # 2D PCA for the plot\nreduced = pd.DataFrame(pca.fit_transform(X_norm))","c7a1c619":"from sklearn.cluster import DBSCAN\n\n# train the model using DBSCAN\ndb = DBSCAN(eps=1, min_samples=5)\n\n# prediction for dbscan clusters\ndb_clusters = db.fit_predict(reduced)","16d0af13":"reduced['cluster'] = db_clusters\nreduced['name'] = names\nreduced.columns = ['x', 'y', 'cluster', 'name']\nreduced.head()","c2dce867":"import matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\nsns.set(style=\"white\")\n\nax = sns.lmplot(x=\"x\", y=\"y\", hue='cluster', data = reduced, legend=False,\n                   fit_reg=False, size = 10, scatter_kws={\"s\": 250})\n\ntexts = []\nfor x, y, s in zip(reduced.x, reduced.y, reduced.name):\n    texts.append(plt.text(x, y, s))\n\nax.set(ylim=(-2, 2))\nplt.tick_params(labelsize=15)\nplt.xlabel(\"PC 1\", fontsize = 20)\nplt.ylabel(\"PC 2\", fontsize = 20)\n\nplt.show()","0a05ee71":"from sklearn.neighbors import NearestNeighbors\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\n# calculate the distance from each point to its closest neighbor\nnn = NearestNeighbors(n_neighbors = 2)\n\n# fit the nearest neighbor\nnbrs = nn.fit(reduced)\n\n# returns two arrays - distance to the closest n_neighbors points and index for each point\ndistances, indices = nbrs.kneighbors(reduced)\n\n# sort the distance and plot it\ndistances = np.sort(distances, axis=0)\ndistances = distances[:,1]\nplt.plot(distances)","71da9873":"from sklearn.cluster import DBSCAN\n\n# train the model using DBSCAN\ndb= DBSCAN(eps=0.3, min_samples=4)\n\n# prediction for dbscan clusters\ndb_clusters = db.fit_predict(reduced)\n\nreduced['cluster'] = db_clusters\nreduced['name'] = names\nreduced.columns = ['x', 'y', 'cluster', 'name']\nreduced.head()","f45a62c2":"import matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\nsns.set(style=\"white\")\n\nax = sns.lmplot(x=\"x\", y=\"y\", hue='cluster', data = reduced, legend=False,\n                   fit_reg=False, size = 9, scatter_kws={\"s\": 250})\n\ntexts = []\nfor x, y, s in zip(reduced.x, reduced.y, reduced.name):\n    texts.append(plt.text(x, y, s))\n\nax.set(ylim=(-2, 2))\nplt.tick_params(labelsize=10)\nplt.xlabel(\"PC 1\", fontsize = 20)\nplt.ylabel(\"PC 2\", fontsize = 20)\n\nplt.show()","8e519aaa":"# Find an Optimal Epsilon Using Nearest Neighbors\n\n- find an optimal epsilon by calculating the distance to the nearest n points for each point, sorting and plotting the results.","3d03becc":"# **Grouping Soccer Players with Similar Skillsets in FIFA 20**\n# DBSCAN (Density-Based Spatial Clustering of Applications with Noise)\n\n- Author: Jaemin Lee (aka. Import Data)\n\n- [Import Data YouTube Channel](https:\/\/www.youtube.com\/channel\/UCYDacpfRrCX6_8oDDlzTgFw)\n- [Video Explanation](https:\/\/youtu.be\/r3qDEoi6RmI)","cdcd4672":"# Make a new data frame by adding players' names and their cluster","a041982e":"# Apply DBSCAN again with a New Eps","f32c9b10":"# Apply DBSCAN","6a75e011":"# Plotting DBSCAN","86638c55":"# Use PCA to reduce 60 columns into 2","d0bb4357":"#Data Cleaning\/Pre-processing (code from part 1 & 2)\n\n\n","f7c64b9f":"# Standardizing data","d0f8722b":"# Plot again with a new Eps = 0.3"}}