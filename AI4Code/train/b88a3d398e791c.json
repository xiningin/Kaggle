{"cell_type":{"5ae15c9d":"code","ac6f984c":"code","5e06a84c":"code","bd6b9a13":"code","0f2d291b":"code","d499c47e":"code","4e63f518":"code","93f3847b":"code","6a968a63":"code","fed99410":"code","afaaaeae":"code","81d5404a":"code","4ec982c6":"code","17270739":"code","0c79ef6a":"code","acb86ddc":"code","6a2f8dfc":"code","5472f530":"code","13062fd3":"code","5403ef43":"code","9b977cca":"code","a27735eb":"code","3393240f":"code","78f83249":"code","635a74dd":"code","75a4c573":"code","55b69f51":"code","1752fda1":"code","5e2a885f":"code","57a4eb22":"code","21b0d383":"code","e095ce4f":"code","63eded19":"code","812469ca":"code","3d73dae1":"code","b57c06ea":"code","e0d6b5af":"code","8eae57e1":"code","0395963d":"code","0f67c53d":"markdown","597eb49a":"markdown","b8c088ab":"markdown","34f3ecd2":"markdown","58c8feab":"markdown","02254f0e":"markdown","db045be7":"markdown","d8305afe":"markdown","060cfa03":"markdown","40796ad7":"markdown","c7428450":"markdown","35a07826":"markdown","266626f6":"markdown","df6c9f4a":"markdown","3e204ad2":"markdown","17f22f10":"markdown","f34fc11b":"markdown","182d40af":"markdown","d2f165a9":"markdown","3e9dfbb9":"markdown","39bcb45f":"markdown","e81a1153":"markdown","4d9b0379":"markdown","e24f00e2":"markdown","082d9f72":"markdown"},"source":{"5ae15c9d":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom tqdm import tqdm\n\nfrom sklearn.feature_extraction.text import CountVectorizer\n\nfrom sklearn import preprocessing\nimport scipy\nimport random\n\nfrom surprise import AlgoBase, Reader\nfrom surprise import Dataset\nfrom surprise.model_selection import cross_validate,train_test_split, GridSearchCV\n\nfrom sklearn.model_selection import train_test_split as sklearn_train_test_split\n\n# models\nfrom surprise import KNNWithZScore, SVD\n\n\npd.set_option('display.max_colwidth', None)","ac6f984c":"movies_data = pd.read_csv(\"..\/input\/movielens100k\/movies.csv\")\nmovies_data.drop_duplicates(subset =\"title\",keep='first',inplace=True,ignore_index=True) \nmovies_data.shape","5e06a84c":"# we check if there's empty values\nplt.figure(figsize=(8,4))\nsns.heatmap(movies_data.isna(), cbar=False, yticklabels=False)","bd6b9a13":"# we remove ('no genre listed') from the genres list.\nNO_GENRE_LISTED = \"(no genres listed)\"\nmovies_data[\"genres\"] = movies_data[\"genres\"].apply(lambda genres: [ genre for genre in genres.split('|') if genre != NO_GENRE_LISTED ])","0f2d291b":"# we drop rows with na values.\nmovies_data = movies_data.dropna()\nmovies_data.shape","d499c47e":"genres_merged = movies_data[\"genres\"].apply(lambda genres: \" \".join(genres))\ngenres_vectorizer = CountVectorizer(token_pattern=\"(?u)\\\\b[\\\\w-]+\\\\b\")\ngenres_count_matrix = genres_vectorizer.fit_transform(genres_merged.tolist())","4e63f518":"print(\"there are {} genres of movies\".format(len(genres_vectorizer.vocabulary_)))","93f3847b":"summed_movie_genres = genres_vectorizer.vocabulary_\nplt.figure(figsize=(40,10))\nplt.bar(summed_movie_genres.keys(), summed_movie_genres.values())","6a968a63":"ratings_data = pd.read_csv(\"..\/input\/movielens100k\/ratings.csv\")\nratings_data.columns","fed99410":"ratings_data.shape","afaaaeae":"ratings_data = ratings_data[ratings_data[\"movieId\"].isin(movies_data[\"movieId\"])]\nratings_data.shape","81d5404a":"movies_mean_ratings = ratings_data.groupby(['movieId'],as_index=False)[\"rating\"].mean()\nplt.figure(figsize=(12, 6))\nsns.distplot(movies_mean_ratings[\"rating\"], bins=10)","4ec982c6":"user_interactions = pd.DataFrame(columns=['userId','interactions'])\n\nuser_interactions[\"userId\"] = ratings_data[\"userId\"]\nuser_interactions[\"interactions\"] = 0\n\nuser_interactions = user_interactions.groupby(['userId'],as_index=False).agg({ 'userId' : 'first' , 'interactions': 'count' }) ","17270739":"plt.figure(figsize=(15, 5))\nsns.distplot(user_interactions[\"interactions\"])","0c79ef6a":"EVAL_RANDOM_SAMPLE_NON_INTERACTED_ITEMS = 50\n\nclass RecallEvaluator:\n    \n    def __init__(self,items,trainset,testset):\n        self.items = items\n        self.trainset = trainset\n        self.testset = testset\n        \n    def get_favorite_items_from_testset(self,user_id):\n        \n        # calculate them mean rating of the user from the test set.\n        mean_rating = np.mean([rating for (_,rating) in self.trainset.ur[user_id]])\n        return [item for (user,item,rating) in self.testset if rating > mean_rating and user == user_id]\n\n    def get_interacted_items_from_testset(self,user_id):\n        return [item for (user,item,_) in testset if user == user_id]\n    \n    def get_interacted_items_from_trainset(self,user_id):\n        return [item for (item,_) in trainset.ur[user_id]]\n    \n    def get_not_interacted_items(self, user_id, size, seed=42):\n            \n        interacted_items = self.get_interacted_items_from_testset(user_id)\n        non_interacted_items = list(set(self.items) - set(interacted_items))\n        random.seed(seed)\n        non_interacted_items = random.sample(non_interacted_items,size)\n        return set(non_interacted_items)\n    \n    def verify_top_n_hits(self, item_id, recommendations, topn):    \n            try:\n                index = recommendations.index(item_id)\n            except:\n                index = -1\n            hit = int(index in range(0, topn))\n            return hit\n    \n    def recommend_to_evaluate(self,user_id,model):\n         \n            # get all the items that the user didn't interact with YET from the full item list\n            non_interacted_items = list(set(self.items) - set(self.get_interacted_items_from_trainset(user_id)))\n            recommendations = [model.predict(user_id,item) for item in non_interacted_items]\n            recommendations.sort(key=lambda x: x.est, reverse=True)\n            return recommendations\n            \n    \n    def evaluate_model_for_user(self,user_id,model,topn):\n        \n        #Getting the items in test set that the user \"like\"\n        favorite_items_testset = self.get_favorite_items_from_testset(user_id)\n        \n        favorite_items_count_testset = len(favorite_items_testset)\n        \n        if favorite_items_count_testset == 0:\n            return [(0,0,0)] * len(topn)\n        \n        user_recommendations = [prediction.iid for prediction in self.recommend_to_evaluate(user_id,model)]        \n        \n        # we initialize our hits count\n        hits_count = [0] * len(topn)\n        \n        #For each item the user likes in the test set\n        for item_id in favorite_items_testset:\n            \n            # we generate a random sample of #EVAL_RANDOM_SAMPLE_NON_INTERACTED_ITEMS movies that the user didn't interact with.\n            non_interacted_items = self.get_not_interacted_items(user_id,size=EVAL_RANDOM_SAMPLE_NON_INTERACTED_ITEMS,seed=item_id%(2**32))\n            \n            # we combine them with the relevant item.\n            items_to_filter_recs = non_interacted_items.union(set([item_id]))\n            \n            # we recommend movies to the user, these recommendations are sorted, we pick only the X+1 items.\n            valid_recommendations = [recommended_item for recommended_item in user_recommendations if recommended_item in items_to_filter_recs]\n                        \n            #Verifying if the current interacted item is among the Top-N recommended items\n            hits = [self.verify_top_n_hits(item_id,valid_recommendations,t) for t in topn]\n            hits_count = np.add(hits_count, hits)\n            \n            \n        recall = [hit_count\/float(favorite_items_count_testset) for hit_count in hits_count]\n        return [(rec,hit_count,favorite_items_count_testset) for rec,hit_count in zip(recall,hits_count)]\n    \n    \n    def evaluate_model(self,model,topn,model_name):\n            \n        #key names of the user metrics\n        keys = ['recall@{}'.format(t) for t in topn]\n        users_metrics = []\n        users_in_testset = set([user for (user,_,_) in self.testset])\n        \n        for user_id in tqdm(users_in_testset,total=len(users_in_testset)-1):\n          \n            user_metrics = [user_id] + self.evaluate_model_for_user(user_id,model,topn)  \n            users_metrics.append(user_metrics)\n            \n        user_recalls = pd.DataFrame(users_metrics,columns=[\"user_id\"] + keys)\n        \n        global_recall = {}\n        \n        for key in keys:\n            \n            hits_sum = np.sum([hit_count for _,(_,hit_count,_) in user_recalls[key].items()])\n            interaction_counts = np.sum([interaction_count for _,(_,_,interaction_count) in user_recalls[key].items()])\n            global_recall[key] = hits_sum \/ float(interaction_counts)\n            \n        global_metrics = {**{'model': model_name}, **global_recall} \n        return global_metrics, user_recalls","acb86ddc":"reader = Reader(rating_scale=(1, 5))\ndata = Dataset.load_from_df(ratings_data[['userId', 'movieId', 'rating']], reader)\n\ntraindf, testdf = sklearn_train_test_split(ratings_data[['userId', 'movieId', 'rating']],\n                                   stratify=ratings_data['userId'], \n                                   test_size=0.25,\n                                   random_state=42)\n\n\ntrain = Dataset.load_from_df(traindf, reader)\ntest = Dataset.load_from_df(testdf, reader)\n\ntrainset = train.build_full_trainset()\n_,testset = train_test_split(test,train_size=None)\n\nmovies_id = movies_data[\"movieId\"].unique().tolist()","6a2f8dfc":"recall_evaluator = RecallEvaluator(movies_id,trainset,testset)","5472f530":"class PopularRecSys(AlgoBase):\n\n    def __init__(self):\n        AlgoBase.__init__(self)\n\n    def fit(self, trainset):\n        \n        AlgoBase.fit(self, trainset)\n        # we compute the ratings mean for each item.\n        # the results are stored in a top_rating attribute\n        \n        self.popular = {}  # a tuple where the key is the item raw id, the value is the views count\n        \n        for item_id in trainset.all_items():\n\n            views = len(trainset.ir[item_id])\n            self.popular[item_id] = views\n\n        return self\n\n    def estimate(self, u, i):\n\n        if self.trainset.knows_item(i):\n            return self.popular[i]\n        return 0","13062fd3":"popularRecSys = PopularRecSys()\npopularRecSys.fit(trainset)","5403ef43":"popularRecSys_metrics,_ = recall_evaluator.evaluate_model(topn=[5,8,10],model=popularRecSys,model_name='popular')","9b977cca":"print(popularRecSys_metrics)","a27735eb":"class TopRatedRecSys(AlgoBase):\n\n    def __init__(self):\n        AlgoBase.__init__(self)\n\n    def fit(self, trainset):\n        \n        AlgoBase.fit(self, trainset)\n        # we compute the ratings mean for each item.\n        # the results are stored in a top_rating attribute\n        \n        self.top_rating = {}  # a tuple where the key is the item raw id, the value is the estimated rating\n        \n        for item_id in trainset.all_items():\n\n            adjusted_mean = (np.sum([r for (_,r) in trainset.ir[item_id]]) + 5) \/ (len([r for (_,r) in trainset.ir[item_id]]) + 5)\n            self.top_rating[item_id] = adjusted_mean\n\n        return self\n\n    def estimate(self, u, i):\n\n        if self.trainset.knows_item(i) and self.trainset.knows_user(u) :\n            return self.top_rating[i]\n        return 0","3393240f":"topRatedRS = TopRatedRecSys()\ntopRatedRS.fit(trainset)\ntopRatedRS_metrics , _ = recall_evaluator.evaluate_model(topn=[5,8,10],model=topRatedRS,model_name='top rated')","78f83249":"print(topRatedRS_metrics)","635a74dd":"topRatedRS_cv = cross_validate(topRatedRS, data, measures=['RMSE', 'MAE'], cv=5, verbose=True)","75a4c573":"sim_options_ub = {'name': 'cosine','user_based': True}","55b69f51":"KNNWithZscore_ub = KNNWithZScore(k=4,min_k=3,sim_options=sim_options_ub)\nKNNWithZscore_ub.fit(trainset)","1752fda1":"KNNWithZscore_ub_metrics , _ = recall_evaluator.evaluate_model(topn=[5,8,10],model=KNNWithZscore_ub,model_name='K-NN with z-score [user-based]')","5e2a885f":"print(KNNWithZscore_ub_metrics)","57a4eb22":"KNNWithZscore_ub_cv = cross_validate(KNNWithZscore_ub, data, measures=['RMSE', 'MAE'], cv=3, verbose=True)","21b0d383":"sim_options_ib = {'name': 'cosine','user_based': False}\nKNNWithZscore_ib = KNNWithZScore(k=4,min_k=3,sim_options=sim_options_ib)\nKNNWithZscore_ib.fit(trainset)","e095ce4f":"KNNWithZscore_ib_metrics , _ = recall_evaluator.evaluate_model(topn=[5,8,10],model=KNNWithZscore_ib,model_name='K-NN with z-score [item-based]')","63eded19":"print(KNNWithZscore_ib_metrics)","812469ca":"KNNWithZscore_ib_cv = cross_validate(KNNWithZscore_ib, data, measures=['RMSE', 'MAE'], cv=3, verbose=True)","3d73dae1":"param_grid = {'n_epochs': [10,20,30], 'lr_all': [0.002, 0.005]}\ngrid_search = GridSearchCV(SVD, param_grid,measures=['MAE','RMSE'],cv=3,refit=True)\ngrid_search.fit(data)","b57c06ea":"svd_metrics , _ = recall_evaluator.evaluate_model(topn=[5,8,10],model=grid_search,model_name='SVD')","e0d6b5af":"print(svd_metrics)","8eae57e1":"global_metrics = pd.DataFrame([popularRecSys_metrics,topRatedRS_metrics,KNNWithZscore_ub_metrics,KNNWithZscore_ib_metrics,svd_metrics]).set_index('model')","0395963d":"%matplotlib inline\nax = global_metrics.transpose().plot(kind='bar', figsize=(15,8))\nfor p in ax.patches:\n    ax.annotate(\"%.2f\" % p.get_height(), (p.get_x() + p.get_width() \/ 2., p.get_height()), ha='center', va='center', xytext=(0, 10), textcoords='offset points')","0f67c53d":"# RECOMMENDATIONS MODELS AND EVALUATIONS","597eb49a":"we then initialize our evaluator.","b8c088ab":"# FINAL RESULTS\n\nlet's plot the algorithms along with their recall values","34f3ecd2":"## THE MOVIES DATASET\n\nlets start exploring our movies dataset.\nfirst we check if there's any NaN value.","58c8feab":"now, let's implement the item-to-item model","02254f0e":"# TOP-RATED BASED MODEL","db045be7":"# EXPLORATORY DATA ANALYSIS","d8305afe":"# CONCLUSION\n\nin this notebook we explored different algorithms using the **surprise** library and we concluded that:\n\n- K-NN algorithms performed poorly.\n- the top-rating algorithm has the highest recall because we have a small dataset (only 9k movies and 100k).\n\nwhat to do now?\n\n- create a content-based model and compare it to others\n- create a hybrid model by combining different algorithms\n- take rating time into consideration ( time-aware RecSys ). more infos on this [paper](https:\/\/www.scitepress.org\/Papers\/2017\/63126\/63126.pdf)","060cfa03":"how the top rating model works?\n\n```\n- we get the top rating movies and we recommend them to the user\n\n- to get the top rated movies:\n    - we calculate the adjusted average.\n    - we rank them.\n```","40796ad7":"to evaluate recommender systems, we will use the **Recall@N** evaluation metric used in this [paper](https:\/\/www.researchgate.net\/publication\/221141030_Performance_of_recommender_algorithms_on_top-N_recommendation_tasks)\n\nthis is how will we proceed:\n\n```\n- for each user\n\n    - for each item rated as \"good\" from our test set\n    \n        - sample X other items the user has never interacted with ( we assume that they are irrelevant).\n        - we merge the X items and the targeted item in one list.\n        - using the model, we rank our X+1 items.\n        - we form top-N recommendations.\n        - if our target item belongs to the top-N recommendation, it's a hit, otherwise it's a miss.\n    \n    - calculate the metric for the user\n    \n- calculate the mean metric of all users.\n\n```\n\nlet's code our evaluator class","c7428450":"# EVALUATING OUR MODELS, HOW?","35a07826":"# WHAT'S THIS NOTEBOOK ABOUT?\n\n\nThis notebook is a practical introduction to the main Recommender System (RecSys) techniques. The objective of a RecSys is to recommend relevant items for users, based on their preference. Preference and relevance are subjective, and they are generally inferred by items users have consumed previously.\n\nthe dataset i'm using is a popular one called [movielens100k](https:\/\/www.kaggle.com\/rajmehra03\/movielens100k) that contains 3 tables: movies,ratings,tags.\n\nsince the data is **explicit**, for simplicity we will use the python package [Surprise](http:\/\/http:\/\/surpriselib.com\/)\n\nfirst, we will explore our data just to get an idea about it. We will define a class to evaluate our models and finally, we will train every model and compare them at then end.","266626f6":"as we can see, the user-based CF performed better than the item-based one.","df6c9f4a":"since this model doesn't estimate ratings, we won't show the accuracy.","3e204ad2":"as we can see, most of the movies are rated between 3 and 4.\n\nlet's finish this data analysis by exploring user's interactions distribution.","17f22f10":"# COLLABORATIVE FILTERING\n\n\nbased on this [website](https:\/\/www.sciencedirect.com\/topics\/computer-science\/collaborative-filtering) there are 2 CF RecSys approaches ( memory-based & model-based )","f34fc11b":"let's start with the user to user method. to calculate similarity\/distance we will use cosine.","182d40af":"## MODEL-BASED CF\n\none the most popular model-based algorithms is SVD. more information about this algorithm [here](https:\/\/developers.google.com\/machine-learning\/recommendation\/collaborative\/matrix)\n\nthanks to the surprise library, we can test with different parameters and pick the best.","d2f165a9":"## SPLITTING THE DATA\n\nlet's first split our data using the surprise built-in method **train_test_split**","3e9dfbb9":"## THE RATINGS DATASET\n\nlet's explore the ratings data set.","39bcb45f":"# POPULARITY BASED MODEL","e81a1153":"this model recommends the most popular movies to all users.","4d9b0379":"## MEMORY-BASED CF\n\nwe will implement 2 types of memory based CF : user-to-user and item-to-item. both are based on the K-NN with rating means. you check about it in this [article](https:\/\/towardsdatascience.com\/machine-learning-basics-with-the-k-nearest-neighbors-algorithm-6a6e71d01761)","e24f00e2":"as we can see, the SVD algorithm performed better than both versions of KNN with 63% of recall@8 and 68% recall@10","082d9f72":"let's see the distribution of mean ratings in our dataset"}}