{"cell_type":{"f623196b":"code","5148e131":"code","05cbf957":"code","4a3c93a8":"code","988a7f69":"code","c3a0f4f4":"code","893c56f2":"code","4b8b8764":"code","06bf0105":"code","7bbae06c":"code","65fcacd8":"code","1060b8aa":"code","79c8f9db":"code","13d10a73":"code","ff54c298":"code","6ed0d3e1":"code","80a69e61":"code","d216d27f":"code","f4b99197":"code","05952eeb":"code","ff509263":"code","7fd3dfa5":"code","5d55119f":"code","289b6060":"code","ff0c5a13":"code","0d475e04":"code","60ea723b":"code","0b0caed6":"code","e3a630cc":"code","e8a608ca":"markdown","d5f23b04":"markdown","5f5838a3":"markdown","9a331d0b":"markdown"},"source":{"f623196b":"import pandas as pd \nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline \nimport plotly.graph_objs as go\nimport plotly.figure_factory as ff\nfrom plotly import tools\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\ninit_notebook_mode(connected=True)","5148e131":"import gc\nfrom datetime import datetime \nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.ensemble import AdaBoostClassifier\nfrom sklearn import svm\nimport xgboost as xgb","05cbf957":"RFC_METRIC = 'gini'\nNUM_ESTIMATORS = 100\nNO_JOBS = 4\nVALID_SIZE = 0.20\nTEST_SIZE = 0.20\nNUMBER_KFOLDS = 5\nRANDOM_STATE = 2018\nMAX_ROUNDS = 1000\nEARLY_STOP = 50\nOPT_ROUNDS = 1000\nVERBOSE_EVAL = 50\nIS_LOCAL = False\nimport os","4a3c93a8":"data = pd.read_csv(\"creditcard.csv\")","988a7f69":"print(data.columns)\n","c3a0f4f4":"print(data.shape)","893c56f2":"print(data.describe())\n","4b8b8764":"data.info()","06bf0105":"data.head(10)","7bbae06c":"data.hist(figsize=(20,20))\nplt.show()","65fcacd8":"corrmat = data.corr()\nfig = plt.figure(figsize =(12,9))\n\nsns.heatmap(corrmat, vmax = 0.8, square = True)\nplt.show()","1060b8aa":"#Determine the number of fraud cases in dataset\nFraud = data[data['Class']==1]\nValid = data[data['Class']==0]\n\noutlier_fraction = len(Fraud)\/float(len(Valid))\nprint(outlier_fraction)\n\nprint('Fraud cases: {}'.format(len(Fraud)))\nprint('Valid cases: {}'.format(len(Valid)))","79c8f9db":"target = 'Class'\npredictors = ['Time', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10',\\\n       'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19',\\\n       'V20', 'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28',\\\n       'Amount']","13d10a73":"train_data, test_data = train_test_split(data, test_size=TEST_SIZE, random_state=RANDOM_STATE, shuffle=True )\ntrain_data, valid_data = train_test_split(train_data, test_size=VALID_SIZE, random_state=RANDOM_STATE, shuffle=True )","ff54c298":"clf = RandomForestClassifier(n_jobs=NO_JOBS, \n                             random_state=RANDOM_STATE,\n                             criterion=RFC_METRIC,\n                             n_estimators=NUM_ESTIMATORS,\n                             verbose=False)","6ed0d3e1":"clf.fit(train_data[predictors], train_data[target].values)","80a69e61":"preds = clf.predict(valid_data[predictors])","d216d27f":"clf.score(test_data[predictors],test_data[target])","f4b99197":"RanFC = roc_auc_score(valid_data[target].values, preds)\nRanFC","05952eeb":"clf = AdaBoostClassifier(random_state=RANDOM_STATE,\n                         algorithm='SAMME.R',\n                         learning_rate=0.8,\n                             n_estimators=NUM_ESTIMATORS)","ff509263":"clf.fit(train_data[predictors], train_data[target].values)","7fd3dfa5":"preds = clf.predict(valid_data[predictors])","5d55119f":"clf.score(test_data[predictors],test_data[target])","289b6060":"ADaBoost = roc_auc_score(valid_data[target].values, preds)\nADaBoost","ff0c5a13":"# Prepare the train and valid datasets\ndtrain = xgb.DMatrix(train_data[predictors], train_data[target].values)\ndvalid = xgb.DMatrix(valid_data[predictors], valid_data[target].values)\ndtest = xgb.DMatrix(test_data[predictors], test_data[target].values)\n\n#What to monitor (in this case, **train** and **valid**)\nwatchlist = [(dtrain, 'train'), (dvalid, 'valid')]\n\n# Set xgboost parameters\nparams = {}\nparams['objective'] = 'binary:logistic'\nparams['eta'] = 0.039\nparams['silent'] = True\nparams['max_depth'] = 2\nparams['subsample'] = 0.8\nparams['colsample_bytree'] = 0.9\nparams['eval_metric'] = 'auc'\nparams['random_state'] = RANDOM_STATE","0d475e04":"model = xgb.train(params, \n                dtrain, \n                MAX_ROUNDS, \n                watchlist, \n                early_stopping_rounds=EARLY_STOP, \n                maximize=True, \n                verbose_eval=VERBOSE_EVAL)","60ea723b":"fig, (ax) = plt.subplots(ncols=1, figsize=(8,5))\nxgb.plot_importance(model, height=0.8, title=\"Features importance (XGBoost)\", ax=ax, color=\"green\") \nplt.show()","0b0caed6":"preds = model.predict(dtest)","e3a630cc":"xgboost = roc_auc_score(test_data[target].values, preds)\nxgboost","e8a608ca":"# XGBoost","d5f23b04":"# AdaBoostClassifier","5f5838a3":"# Defining predictors and target values","9a331d0b":"Random Forest Classifier"}}