{"cell_type":{"f578d3a3":"code","24259d44":"code","df86923a":"code","f4a36357":"code","50e8446a":"code","fa00ea92":"code","f93609fd":"code","37ac1343":"code","f87e1c5c":"code","b45cc407":"code","40fc7e2b":"code","03931be3":"code","5b58514f":"code","64b75956":"code","7ba266f5":"code","e5604ba4":"code","dde21ca1":"code","cd645752":"code","e6714132":"code","64d14cf8":"markdown","40c2d5cb":"markdown","ea4649ec":"markdown","1c31fd68":"markdown","83bca06c":"markdown","8ec5e3b0":"markdown","f6c0bfba":"markdown","cf5f5db6":"markdown","01d31f6f":"markdown","95b8277d":"markdown","0a0dfd90":"markdown","6111e461":"markdown","cea9d7da":"markdown","e20f7c4b":"markdown","3a2f9d43":"markdown","38a0b8f1":"markdown","9623ad47":"markdown"},"source":{"f578d3a3":"import time\nimport pandas as pd\nimport torch","24259d44":"torch.backends.cudnn.benchmark = True\ntorch.backends.cudnn.deterministic = False","df86923a":"N = 25  # grid dimension\ndevice = 'cuda'\nTEST_CSV = '..\/input\/conways-reverse-game-of-life-2020\/test.csv'\nOUTPUT_CSV = 'submission.csv'","f4a36357":"cv = torch.nn.Conv2d(1, 1, kernel_size=3, padding=1, padding_mode='circular', bias=False)\ncv.requires_grad=False\ncv.weight = torch.nn.Parameter(\n    torch.tensor(\n        [[[[ 1., 1., 1.],\n           [ 1., 0., 1.],\n           [ 1., 1., 1.]]]],\n        device=device,\n        dtype=torch.float16\n    ),\n    requires_grad=False,\n)\n\n\n@torch.jit.script\ndef forward(grid, delta: int):\n    N=25\n    g = grid.reshape(-1, 1, N, N)\n    for _ in torch.arange(delta):\n        g = g.to(torch.float16)\n        neighbor_sum = cv(g)\n        g = ((neighbor_sum == 3) | ((g == 1) & (neighbor_sum == 2)))\n    return g.reshape(-1, N, N)","50e8446a":"@torch.jit.script\ndef random_parents(n_parents: int, device: str):\n    N = 25\n    RANDOM_ALIVE = .2\n    return torch.rand((n_parents, N, N), device=device) > (1-RANDOM_ALIVE)","fa00ea92":"@torch.jit.script\ndef loss(input, target):\n    return torch.sum(input ^ target, dim=(-1,-2))","f93609fd":"@torch.jit.script\ndef select_best(parents, delta: int, target, n_best: int):\n    scores = loss(forward(parents, delta), target)\n    best_values, best_indices = torch.topk(scores, n_best, dim=0, largest=False, sorted=True)\n    new_parents = parents[best_indices, ...]\n    return new_parents, best_values[0], new_parents[0, ...]","37ac1343":"@torch.jit.script\ndef random_combine(parents, n_offsprings: int, device: str, pre_masks):\n    N = 25\n    \n    dads = torch.randint(low=0, high=parents.shape[0], size=(n_offsprings,),\n                         device=device, dtype=torch.long)\n    dads = parents[dads, ...]\n    \n    moms = torch.randint(low=0, high=parents.shape[0], size=(n_offsprings,),\n                         device=device, dtype=torch.long)\n    moms = parents[moms, ...]\n    \n    masks = pre_masks[torch.randint(low=0, high=pre_masks.shape[0], size=(n_offsprings,),\n                                    device=device, dtype=torch.long)]\n\n    return torch.where(masks, dads, moms)","f87e1c5c":"def precomputes_masks():\n    N = 25\n    BLOCK_SIZE = 17\n\n    block = torch.nn.Conv2d(1, 1, kernel_size=BLOCK_SIZE, padding=BLOCK_SIZE\/\/2,\n                            padding_mode='circular', bias=False)\n    block.requires_grad=False\n    block.weight = torch.nn.Parameter(\n        torch.ones((1, 1, BLOCK_SIZE, BLOCK_SIZE),\n            device=device,\n            dtype=torch.float16\n        ),\n        requires_grad=False,\n    )\n\n    masks = torch.zeros((N * N, 1, N, N), device=device, dtype=torch.float16)\n    \n    for x in range(N):\n        for y in range(N):\n            masks[x * N + y, 0, x, y] = 1.\n    masks = block(masks)\n    \n    return masks[:, 0, ...] > .5","b45cc407":"@torch.jit.script\ndef mutate(parents, device: str):\n    MUTATION = .0016  # .005 \n    mutations = torch.rand(parents.shape, device=device) < MUTATION\n    return parents ^ mutations","40fc7e2b":"@torch.jit.script\ndef optimize_one_puzzle(delta: int, data, device: str, pre_masks):\n    N = 25\n    N_GENERATION = 30  # Number of generations\n    P = 4_500  # population\n    N_BEST = P \/\/ 30  # best to keep as new parents\n    N_ELITES = 8  # parents unchanged for next generation\n    \n    best_score = torch.tensor([N*N], device=device)\n    best = torch.zeros((N,N), device=device).to(torch.bool)\n    parents = random_parents(P, device)\n\n    elites = torch.empty((1, N, N), dtype=torch.bool, device=device)\n    elites[0, ...] = data  # set target as potential dad ;)\n\n    for i in range(N_GENERATION):\n        parents = random_combine(parents, P, device, pre_masks)\n        parents = mutate(parents, device)\n        parents[:N_ELITES, ...] = elites\n        parents, best_score, best = select_best(parents, delta, data, N_BEST)\n        # Some of the individuals in the current population that have lower fitness are chosen as elite.\n        # These elite individuals are passed to the next population.\n        elites = parents[:N_ELITES, ...]\n        if best_score == 0:  # early stopping\n            break\n\n    return best_score, best","03931be3":"@torch.jit.script\ndef optimize_all_puzzles(deltas, df, device: str, pre_masks):\n    sub = df.clone()\n    \n    for n in torch.arange(df.shape[0]):\n        delta = deltas[n]\n        data = df[n, ...]\n        _, sub[n, ...] = optimize_one_puzzle(delta, data, device, pre_masks)\n\n    return sub","5b58514f":"df = pd.read_csv(TEST_CSV, index_col='id')","64b75956":"submission = df.copy()\nsubmission.drop(['delta'], inplace=True, axis=1)","7ba266f5":"indexes = df.index\ndeltas = torch.from_numpy(df.delta.values).to(device)\ndf = torch.BoolTensor(df.values[:, 1:].reshape((-1, N, N))).to(device)","e5604ba4":"start_time = time.time()\npre_masks = precomputes_masks()\nsub = optimize_all_puzzles(deltas, df, device, pre_masks)\nprint(f'Processed {sub.shape[0]:,} puzzles in {time.time() - start_time:.2f} seconds \ud83d\udd25\ud83d\udd25\ud83d\udd25')","dde21ca1":"submission.rename(columns={f'stop_{x}': f'start_{x}' for x in range(N*N)}, inplace=True)\nsubmission.iloc[:sub.shape[0], :] = sub.reshape((-1, N*N)).cpu().numpy().astype(int)\nsubmission.to_csv(OUTPUT_CSV)","cd645752":"def leaderboard_score(deltas, df, sub, device: str):\n    result = torch.empty(sub.shape[0], device=device, dtype=torch.long)\n    for delta in range(1, 6):\n        start = sub[deltas == delta]\n        end   = df[deltas == delta]\n        result[deltas == delta] = loss(forward(start, delta), end)\n    print('Leaderboard score:', torch.sum(result).item() \/ (result.shape[0]*N*N))","e6714132":"leaderboard_score(deltas, df, sub, device)","64d14cf8":"### Save our submission","40c2d5cb":"`optimize_all_puzzles`: It tries to find approximate solution for all puzzles \ud83d\ude03","ea4649ec":"# Conclusion\n\nI learned a lot along the way about Genetic Algorithm, pytorch and how to optimize computation on the GPU.\n\nIf you like this notebook, please leave a comment \ud83d\udd8a, upvote \ud83d\udc4d, and put a smile on your face \ud83d\ude00.","1c31fd68":"`mutate`: makes random changes on parents.","83bca06c":"### Genetic algorithm\n\nI highly suggest to read [How the Genetic Algorithm works](https:\/\/www.mathworks.com\/help\/gads\/how-the-genetic-algorithm-works.html) webpage as it explains many concepts mentionned in following sections of this notebook.\n\n`random_parents` : create a random initial population made of `n_parents` NxN grids","8ec5e3b0":"`optimize_one_puzzle`: runs our genetic algorithm on one puzzle","f6c0bfba":"### Use final state as our baseline for submission","cf5f5db6":"### Constants","01d31f6f":"`random_combine`: combining the vector entries of a pair of parents. It is also called _crossover_.","95b8277d":"`precomputes_masks`: pre-computes masked used for combining the vector entries of a pair of parents in `random_combine`.","0a0dfd90":"### Apply Game Of Life steps\n\n`forward` : applies Game Of Life rules `delta` times on a board of cells (`grid`).\n\nThe rules are simple and are defined in the [Kaggle competition description](https:\/\/www.kaggle.com\/c\/conways-reverse-game-of-life-2020\/overview\/description):\n\n> The Game of Life is a cellular automaton created by mathematician John Conway in 1970. The game consists of a board of cells that are either on or off. One creates an initial configuration of these on\/off states and observes how it evolves. There are four simple rules to determine the next state of the game board, given the current state:\n>\n>    - *Overpopulation*: if a living cell is surrounded by more than three living cells, it dies.\n>    - *Stasis*: if a living cell is surrounded by two or three living cells, it survives.\n>    - *Underpopulation*: if a living cell is surrounded by fewer than two living cells, it dies.\n>    - *Reproduction*: if a dead cell is surrounded by exactly three cells, it becomes a live cell.\n","6111e461":"# Top 10 Position with First Genetic Algorithm on GPU! \ud83d\udd25\n\n\n## How I came up with this solution?\n\nFor the Kaggle [Conway's Reverse Game of Life 2020](https:\/\/www.kaggle.com\/c\/conways-reverse-game-of-life-2020\/overview) competition, I tried many approaches and I also wanted to try something new for me: **Genetic Algorithm**. \n\nI looked up existing Kaggle notebooks using Genetic Algorithm, but none of them were using a GPU accelerator (sorry if I am wrong and missed one). It puzzled me as the GPU is faster than the CPU. I told myself \"challenge accepted, let's make a genetic algorithm on the GPU!\".\n\nImplementing this genetic algorithm from scratch was tought but I learned a lot in the process about genetic algorithm (first purpose), but also on `pytorch` and how to optimize using `NVIDIA Nsight`.\n\n\n## Results\n\nThis solution performed very well during this competition as this present notebook alone [scores in the top-10 leaderboard](https:\/\/www.kaggle.com\/c\/conways-reverse-game-of-life-2020\/leaderboard). This new approach helped improving final solution of our team `Under a Penny`.\n\nI noticed the algorithm is running faster on RTX-2080 than Kaggle's P-100, probably thanks to the newer version of tensor-cores.\n\n\n## Requirements\n\nAll we need are :\n\n - `pytorch` to implement the Genetic Algorithm on GPU\n - `pandas` to load and write .csv files\n\n## Implementation","cea9d7da":"### Compute leaderboard score","e20f7c4b":"`select_best`: Scores each member of the current population `parents` by computing its fitness value. For this competition, the fitness value is the number of errors between a `target` and a population individual after applying `delta` time the Game Of Live rules. The functions returns the `n_best` best performing individuals.","3a2f9d43":"### Let's optimize puzzles!","38a0b8f1":"### Load Puzzles to solve","9623ad47":"### Push data to GPU"}}