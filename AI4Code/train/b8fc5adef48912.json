{"cell_type":{"296274d3":"code","9f22ff12":"code","1a6694d3":"code","684eefce":"code","5d509b1d":"code","de7f316c":"code","2be947dd":"code","5a3b3102":"code","be61bdce":"code","582eb324":"code","1594057e":"code","69bda141":"code","80f7c5c0":"code","6cf46a7d":"code","ee214af1":"code","d0cc899a":"code","c0fb50c5":"code","9522bf93":"code","25ccc4e4":"code","d165c5ff":"code","ca4ff501":"code","088aed39":"code","a4a47681":"code","64231410":"markdown","3cd6f6f1":"markdown","949ebc34":"markdown","1c6765dc":"markdown","bf9b6855":"markdown","93b2f327":"markdown","e9bc8058":"markdown","325fb48d":"markdown","7842b2d1":"markdown","4c9e8686":"markdown","ee78b252":"markdown","aade25bc":"markdown","1dd36f18":"markdown","247aa1c3":"markdown","4d7e9174":"markdown","14eb4df1":"markdown","f9676a52":"markdown","2bf6dcd6":"markdown","1131707b":"markdown"},"source":{"296274d3":"from IPython.core.display import HTML\nHTML(\"\"\"\n<style>\n.output_png, .img {\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n    horizontal-align: middle;\n}\nh1,h2 {\n    text-align: center;\n    background-color: pink;\n    padding: 20px;\n    margin: 0;\n    color: white;\n    font-family: ariel;\n    border-radius: 80px\n}\n\nh3 {\n    text-align: center;\n    border-style: solid;\n    border-width: 3px;\n    padding: 12px;\n    margin: 0;\n    color: black;\n    font-family: ariel;\n    border-radius: 80px;\n    border-color: gold;\n}\n\nbody, p {\n    font-family: ariel;\n    font-size: 15px;\n    color: charcoal;\n}\ndiv {\n    font-size: 14px;\n    margin: 0;\n\n}\n\nh4 {\n    padding: 0px;\n    margin: 0;\n    font-family: ariel;\n    color: purple;\n}\n<\/style>\n\"\"\")","9f22ff12":"import itertools\nimport numpy as np\nimport pandas as pd\nimport random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.graph_objects as go","1a6694d3":"solution = \"12345671234561723456127345612374561327456137245613742561374526137456213745612347561324756134275613472561347526134756213475612345761234516723451627345162374516234751623457162345176234512673451263745126347512634571263451726345127634512367451236475123645712364517236451273645123764512346751234657123465172346512734651243765124367512436571243651724365127436512473651246375124635712463517246351274635124763512467351426735146273514672351467325146735216473521674352167345216374521634752163457216345271634521764352176453271645327614532764153276451326745132647513264571326451732645137264531726453712645372164537261453726415372645132764531276453217645231764521376452173654217365241736521473652174365217346521736452176345216735421637542163574216354721635427163542176354216735241637524163572416352741635247163524176352416735214673512465371246531724653127465312476531246753142675314627531467253146752316475321647531264753162475316427531647253164752316745321674531267453162745316724531674253167452316754231675243167523416752314675321467531246573124651372465132746513247651324671532467135246713254671235467125346712543671524367154236715432675143267541326754312675432167543261745362174536127453617245361742536174523617453261743526174325617432651742365174263517426531742651374265173426157342617534216753421765342175634217536421753462175342617354261734526173425617342651743261574362157436125743162574312657413265741236574126357412653741265734126574312567413256741235674125367412563741256734125674312576413257614325761342576132457613254761325746132576412357641253761425376124537612543761524376154237615432761543726154376215437612534761253746125376412573641257634125764312574631257436152743615724361574236157432617543621754361275436172543617524361754236175432671543627154367215436712546371254673125476312547361524736154273615472361547326145736214576321475632147653214763521476325147632154763214576231457621345762143576214537621457361245736142573614527361457236145732614753621475361247536142753614725361475236147532614735261473256147326514723651472635147265314726513472651437265147326154736215473612547316254731265471326547123654712635471265347126543716253471625374162537146253716425371624537162543716524371654237165432716543721654371265473125647132564712356471253647125634712564372156437251643275614327564132756431275643217564327156432751643257163425176342516734251637425163472516342751634257163245176324516732451637245163274516324751632457163254716325741632571463275146327154632714563271465327146352714632571643527164357216435712643517264351276435126743512647351264375126435716243517624351672435162743516247351624375162435716423517642351674235164723516427351642375146237514263751423675142376514273651427635142765314276513427651432765142375614235761423567143256714352671435627143567214356712435617243561274356124735612437561243576124356714235617423561472356142735614237516423571643251764325167432516473251643725614372564137256431725643712564731254671324567132465713246751324615732461753246173524617325416723541762354716235476123547621354762315467231546273154623715462317564231576421356742135647213564271356421735624137562413576241356724135627413562471356241735621473562174356217345621735462173564213756421357642153746215374261537421653742156374215367421537642157364215763421576432157642315674231564723156427315642371564231756243157624315672431562743156247315624371562431756234157623415672341562734156237415623471562341756231475623174562317546321745632174653217463521746325174632157463217546312754631725463175246315724631527463152476315246731524637152463175426315742631547263154276315426731542637154263175462315746235174623571462357416235746123574621357462315476235147623541726354172365417235641723546172354167253417625314762531746253176425317624531762543176524317654231765432176543127654317265431762534172653417256341725364172534617253416725431672541367251436725134672153476215347261534721653472156347215364721534672135467213456721346572136457213654721365742136572413657214365721346752136475213674521367542136752413675214376521437562143752614375216437521463725146372154637214563721465372146357214637521436752134672513647251367425136724513672541637254167325417632541736251473625174362517346257136425713624571362547136257413625714362571346275136427513624751362745136275416327541623754126375412367541237654132765413726541376251437625134762513746251376425137624513762541376524137654213765412375641237546132754613725461375246137542613754621375461237541627354126735412763541273654127356412735461273541627534126753412765341275634127536412753461275341627543162754136275143627513462715342671354267134526713425671342657143265714236571426357142653714265731426571342675134267153427615342716534271563427153642715346271354627134562713465271364527136542713652471365274136527143652713462573146257341625734612573462157346251736425173624517362541732654173256417325461732456173246517324615372461532746153247615324167532416573214657321645731264573162457316425731645273165427316524731652743165273416527314652731645723165472316574231657243165723416572314657231645732165473216574321657342165732416537241653274165324716532417653241567321456731245637124563172456312745631247563124576312456731425637142563174256314725631427563142576314256731452637145236714532671453627145367214536712453671425367145237614523716452371465237416523746152347651234765213476523147652341765234716523476152346715234617523461572346152734615237465123746521374652317465237145623714526317452631475263145726314527631452673145627314567231456732154673215647321567432156734215673241563724156327415632471563241756324157632415367241536274153624715362417536241573624153762415326741532647153264175326415732641523764152367415236471523641752364157236415273641526374152634715263417526341572634152763415267341526437152643175264315726431527643152674315264731526413752641357261435726134572613547261357426135724613572641352761435276134527613542761352476135274613527641352674135264713526417352641\"\nlen(solution)","684eefce":"split_id = [len(solution) \/\/ 3, len(solution)*2\/\/3]","5d509b1d":"t1, t2 = split_id\nstrings = [solution[:t1+7], solution[t1-7:t2+7], solution[t2-7:]]","de7f316c":"for s in strings:\n    print(len(s))","2be947dd":"required_permutaions = ['12' + ''.join(x) for x in itertools.permutations(['3','4','5','6','7'], 5)]\nprint(len(required_permutaions))","5a3b3102":"for i in range(3):\n    for permutation in required_permutaions:\n        if permutation not in strings[i]:\n            strings[i]+=permutation","be61bdce":"for s in strings:\n    print(len(s))","582eb324":"all_permutations = [''.join(x) for x in itertools.permutations(['1','2','3','4','5','6','7'], 7)]\n\nfor p in all_permutations:\n    if p not in strings[0] and p not in strings[1] and p not in strings[2]:\n        print(p)","1594057e":"# best_len = 10000\n# best_ij = []\n# for i in (range(1,8):\n#     for j in range(1,8):\n#         for t1 in range(2000, 3000, 1):\n#             if j==i:\n#                 continue\n#             else:\n\n#                 adj1= 3\n\n#                 t2 = t1*2\n\n#                 strings = [solution[:t1+adj1], solution[t1-adj1:t2+adj2], solution[t2-adj2:]]\n#                 all_strings = ['1', '2', '3','4','5','6','7']\n#                 all_strings.remove(str(i))\n#                 all_strings.remove(str(j))\n#                 required_permutaions = [str(i)+str(j) + ''.join(x) for x in itertools.permutations(['3','4','5','6','7'], 5)]\n\n#                 for i in range(3):\n#                     for permutation in required_permutaions:\n#                         if permutation not in strings[i]:\n#                             strings[i]+=permutation\n#                 all_lens = []\n\n\n#                 for p in permutations:\n#                     if p not in strings[0] and p not in strings[1] and p not in strings[2]:\n#                         continue\n\n#                 for s in strings:\n#                     all_lens.append(len(s))\n\n#                 if max(all_lens)<best_len:\n#                     best_len=max(all_lens)\n#                     best_ij = [i, j]\n#                     best_strings = strings\n#                     print(best_len, [t1, t2], best_ij)\n            \n# print('Done....')","69bda141":"class PSO:\n    def __init__(self, iterations=10, swarm_size=10, w=1, c1=2.05, c2=2.05, chi=0.729, UB=None, LB=None, logging_steps=10, obj_fun=None):\n        self.iterations = iterations\n        self.swarm_size = swarm_size\n        self.w = w\n        self.c1 = c1\n        self.c2 = c2\n        self.chi = chi\n        self.best_params = None\n        self.logging_steps = logging_steps\n        self.fun = obj_fun\n        self.UB = UB\n        self.LB = LB\n        \n        if self.fun is None:\n            raise AttributeError('Must define a objective function to optimize')\n\n    \n    def optimize(self):\n        \n        def Individual(particle):\n            f=self.fun(particle)\n            particle['fx']=f\n            return particle\n        \n        def random_particle():\n            pos=[]\n            velocity=[]\n\n#             i = random.randint(1, 7)\n#             j = random.randint(1, 7)\n#             while(i!=j):\n#                 j = random.randint(1, 7)\n\n#             t1 = random.randint(2000, 2700)\n#             t2 = random.randint(t1+1, 5000)\n\n#             adj1 = random.randint(0,20)\n#             adj2 = random.randint(0,20)\n\n#             pos = [i, j, t1, t2, adj1, adj2]\n\n            for i in range(len(self.UB)):\n                pos.append(random.randint(self.LB[i], self.UB[i]))\n                velocity.append(random.randint(0, 10))\n\n            return {'pos':pos, 'vel':velocity}\n        \n        def update(particle):\n            vel=particle['vel']\n            pos=particle['pos']\n            pbest=particle['pbest']\n            gbest=particle['gbest']\n            #position update\n\n            new_pos=[]\n            for i in range(6):\n                op = [1, -1]\n                temp=pos[i]+vel[i]* (op[random.randint(0,1)])\n                if temp>self.UB[i]:\n                    new_pos.append(self.LB[i])\n        #             new_pos.append(random.randint(LB[i], UB[i]))\n                elif temp<self.LB[i]:\n                    new_pos.append(self.LB[i])\n        #             new_pos.append(random.randint(LB[i], UB[i]))\n                else:\n                    new_pos.append(temp)\n\n            #vel update\n            new_vel=[]\n            for i in range(len(vel)):\n                new_vel.append( int(self.chi * ((self.w * vel[i]) + self.c1 * np.random.random() * (pbest[i]-pos[i]) + \\\n                               self.c2 * np.random.random() * (gbest[i]-pos[i]))))\n\n\n            return new_pos, new_vel\n    \n\n        \n        \n        SWARM=[Individual(random_particle()) for i in range(self.swarm_size)]\n\n        gbest=sorted(SWARM, key=lambda x: x['fx'])[0]['pos']\n\n        for particle in SWARM:\n            particle['gbest']=gbest\n            particle['pbest']=particle['pos']\n\n        F=[]\n        I=[]\n        \n        for i in range(self.iterations):\n            for particle in SWARM:\n\n                old_fx=particle['fx']\n\n                new_pos, new_vel=update(particle)\n                updated_fx = self.fun({'pos':new_pos})\n                particle['pos']=new_pos\n                particle['vel']=new_vel\n\n                if old_fx<updated_fx:\n                    particle['pbest']=new_pos\n\n                particle['fx']=updated_fx\n\n\n            new_gbest=sorted(SWARM, key=lambda x: x['fx'])[0]['pos']\n            new_gbest_fx=self.fun({'pos':new_gbest})\n\n            old_gbest_fx=self.fun({'pos':SWARM[0]['gbest']})\n\n            if new_gbest_fx<old_gbest_fx:\n                for particle in SWARM:\n                    particle['gbest']=new_gbest\n\n            if i%self.logging_steps == 0:\n                best_score = self.fun({'pos':SWARM[0]['gbest']})\n                self.best_params = SWARM[0]['gbest']\n                print(f'Iteration: {i} | Best params: {self.best_params} | Max len : {best_score}')\n\n            I.append(i+1)\n            F.append(self.fun({'pos':particle['gbest']})) \n        \n        print('\\n'*2)\n        fig = go.Figure(go.Scatter(x=I, y=F, mode='lines'))\n        fig.show()\n\n        \n    def best_params(self):\n        return self.best_params","80f7c5c0":"permutations = [''.join(x) for x in itertools.permutations(['1','2','3','4','5','6','7'], 7)]\n\n\ndef fun(particle):\n    pos = particle['pos']\n    i, j, t1, t2, adj1, adj2 = pos\n    \n    if j==i:\n        return 10000\n\n    if t1>t2:\n        return 10000\n    \n    strings = [solution[:t1+adj1], solution[t1-adj1:t2+adj2], solution[t2-adj2:]]\n    all_strings = ['1', '2', '3','4','5','6','7']\n    all_strings.remove(str(i))\n    all_strings.remove(str(j))\n    required_permutaions = [str(i)+str(j) + ''.join(x) for x in itertools.permutations(all_strings, 5)]\n\n    for i in range(3):\n        for permutation in required_permutaions:\n            if permutation not in strings[i]:\n                strings[i]+=permutation\n    all_lens = []\n\n\n    for p in permutations:\n        if p not in strings[0] and p not in strings[1] and p not in strings[2]:\n            return 10000\n\n    for s in strings:\n        all_lens.append(len(s))\n\n    return max(all_lens)","6cf46a7d":"# Let's define the bounds and the pso optimizer\n\n#  [i, j, t1, t2, adj1, adj2]\nUB=[7, 7, 3000, 5000, 20, 20]\nLB=[1, 1, 2000, 3000, 0, 0]\n\n\n# The PSO optimizer\npso = PSO(UB=UB, LB=LB, iterations=1000, swarm_size=100, logging_steps=100, obj_fun=fun)","ee214af1":"pso.optimize()","d0cc899a":"best_params = pso.best_params\nbest_params","c0fb50c5":"def get_strings(params):\n    i, j, t1, t2, adj1, adj2 = params\n    \n    if j==i:\n        return 10000\n\n    if t1>t2:\n        return 10000\n    \n    strings = [solution[:t1+adj1], solution[t1-adj1:t2+adj2], solution[t2-adj2:]]\n    all_strings = ['1', '2', '3','4','5','6','7']\n    all_strings.remove(str(i))\n    all_strings.remove(str(j))\n    required_permutaions = [str(i)+str(j) + ''.join(x) for x in itertools.permutations(all_strings, 5)]\n\n    for i in range(3):\n        for permutation in required_permutaions:\n            if permutation not in strings[i]:\n                strings[i]+=permutation\n    all_lens = []\n\n\n    for p in permutations:\n        if p not in strings[0] and p not in strings[1] and p not in strings[2]:\n            print('Wrong..')\n            return None\n        \n    replace_dict = {\n    str(i): '\ud83c\udf85', \n    str(j): '\ud83e\udd36', \n    all_strings[0]: '\ud83e\udd8c', \n    all_strings[1]: '\ud83e\udddd', \n    all_strings[2]: '\ud83c\udf84', \n    all_strings[3]: '\ud83c\udf81', \n    all_strings[4]: '\ud83c\udf80', \n    }\n\n    ans = strings.copy()\n    for i in range(3):\n        for k,v in replace_dict.items():\n            ans[i] = ans[i].replace(k, v)\n    \n    return ans","9522bf93":"[string1, string2, string3] = get_strings(best_params)","25ccc4e4":"len(string1)","d165c5ff":"len(string2)","ca4ff501":"len(string3)","088aed39":"strings = [string1, string2, string3]","a4a47681":"sub = pd.DataFrame()\nsub['schedule'] = strings\nsub.to_csv('submission.csv', index=False)","64231410":"# Taking the best solution\n\nThe best minimal superpemutation for n=7 is taken here.\n\nThe steps that are followed are defined under:\n\n* Dividing the solution into 3 equal parts first\n* Adding the mandatory permutation of string containing()","3cd6f6f1":"### Optimize","949ebc34":"# Optimising using loops will take forever \nTotal iterations : (7x7x1000 iterations) with 3 variables (i, j, t1)\n\nWe also need to optimise t2 adj1 and adj2.\n\nThat will be (7x7x1000x2000x10x10) combinations. :)","1c6765dc":"### The best parameters","bf9b6855":"## Let's see the lengths again","93b2f327":"# Particle Swarm Optimization\n\n\nIn computational science, particle swarm optimization (PSO) is a computational method that optimizes a problem by iteratively trying to improve a candidate solution with regard to a given measure of quality. It solves a problem by having a population of candidate solutions, here dubbed particles, and moving these particles around in the search-space according to simple mathematical formula over the particle's position and velocity. Each particle's movement is influenced by its local best known position, but is also guided toward the best known positions in the search-space, which are updated as better positions are found by other particles. This is expected to move the swarm toward the best solutions.\n\nHere is the link of the research paper : [Particle swarm optimization](https:\/\/ieeexplore.ieee.org\/abstract\/document\/488968) by J. Kennedy and R. Eberhart\n\nThere are many variations of PSO. I will be using the simplest form of PSO.\n\n## Here is a visualization of the working of PSO algorithm\n\n![PSO](https:\/\/upload.wikimedia.org\/wikipedia\/commons\/e\/ec\/ParticleSwarmArrowsAnimation.gif)\n\nThe XY represents the search space.\nIt is a contour plot where the colour shows the values of the objective funtion (here minimization)\nand the particles try and find the optimal solution and all the particles in the swarm converges to the optimal solution.","e9bc8058":"# The Upper and the Lower bounds\n\nWe need to define the upper and lower bounds of the variables.","325fb48d":"# Let us define the PSO algorithm\n\n### The main steps of the PSO algorithm for optimization are:\n1. Initialization of the initial swarm population\n2. Assign their inital positions in the search space randomly.\n3. Assign their initial velocities randomly\n4. Calculate the `local best` (the best solution for that individual in the swarm)\n5. Calculate the `global best` (the best solution of the entire swarm)\n6. Update the position for each step (`final_pos = inital_pos + vel`)\n7. Update the velocity using the formula (used in the program)\n8. Update the `local best` and the `global best`\n9. Repeat from step 6 until iterations end or objective is fulfilled.","7842b2d1":"# Let's make the simple answer:\n\nThe simple answer as required by the competition (described in the Evaluation page of the competition) is that:\n* The 3 strings, when combined together must contain all the permutations for n=7\n* The 3 strings must contain all the permutations starting with ","4c9e8686":"## Printing out the lengths","ee78b252":"## Let's check if all the permutations are present or not","aade25bc":"### Seems like we aren't missing out on any permutation","1dd36f18":"# Let us now find out the mandatory permutation:\n\nThe mandatory permutation must contain symbol : and ","247aa1c3":"## Splitting into 3 parts \nSplitting the solution into 3 parts with an overlap of 7 symbols so that any permutaion isn't missed out. We can tune the overlap later","4d7e9174":"# And there goes the baseline solution with PSO","14eb4df1":"# Let's try to optimize.\nThere are several ways to optimize this problem. One proposed by the competition host is the Travelling Sales Man Porblem. \n\nBut here I will be testing with another meta-heurestic algorithm called the **Particle Swarm Optimization**\n","f9676a52":"### Remember:\n\nThis is a meta-heurestic process. These methods are used when calculation of the actual optimal solution requires way too computational power and cannot be achieved. That is the reason the solution isn't the same always. \n\nGot 2550 on the first run\n\nGot 2549 on the second run","2bf6dcd6":"# Define Objective function (must)\n\nWe need to pass a objective function that return the value we want to optimize.\n\nLet use now define the objective function.\n\nHere the objective function is returning the max length of the 3 strings. There are several parameters like changing the symbol values of )()(  (i and j), selecting good split points (t1 and t2) and selecting the overlap length (adj1 and adj2)","1131707b":"The maximum of length of the 3 strings is our answer"}}