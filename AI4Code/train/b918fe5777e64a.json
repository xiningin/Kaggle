{"cell_type":{"f1a14468":"code","9c300c08":"code","02b7a6f4":"code","bb46d89e":"code","5da3ddf0":"code","9edc7f9a":"code","29885c3e":"code","6b83ae4f":"code","27300dc9":"code","0f37999d":"code","c97d3b33":"code","7684b91d":"code","a6666036":"code","0f0d2109":"code","40b4457f":"code","bcd43534":"code","15943c4d":"code","4a2f9beb":"code","943eb71c":"code","eaa7254f":"code","79046c9e":"code","cdc55e0e":"code","75a132a0":"code","f5fff998":"code","1315861b":"code","79f5fd58":"code","7183378f":"code","044bbb06":"code","2f26c35d":"code","2de71d8b":"code","1064f632":"code","05cf462d":"code","56962df3":"code","037fdc99":"code","53dc287d":"code","8e877093":"code","de403b98":"code","7e804e8b":"code","7173e7d0":"code","b3d7ba0e":"code","abfff88f":"code","39fbcfd9":"code","0576ddb8":"code","d1102c1f":"code","bdba1389":"code","35148cc4":"code","c5364166":"code","1a5a3959":"code","28e530d1":"code","550e5012":"code","6a652814":"code","488953d5":"code","c3e7aff8":"code","da55647e":"code","257f7e12":"code","f4c97490":"code","9b166d83":"code","15074bbb":"code","765dd8ca":"code","3f05340c":"code","96216b33":"code","52b7bcc5":"code","f77a55be":"code","28d8a391":"code","e894ad81":"code","f46bec08":"code","5c976aa7":"code","32d161fb":"code","c65310f9":"code","e6d938f7":"code","f5e4c870":"code","4793ce3a":"code","3ee2cd74":"code","6bf4a275":"code","edabe83d":"code","933d2dda":"code","129b9612":"code","f549a093":"code","da70a83a":"code","b40fcadc":"code","e326eaa5":"markdown","6d7e6527":"markdown","701604f5":"markdown","1e0dc742":"markdown","94acda8d":"markdown","487fd715":"markdown","16885e3b":"markdown","d39c4ef2":"markdown","2a96b1c6":"markdown","59fd696c":"markdown","4a9eb359":"markdown","9185e042":"markdown","297c4631":"markdown","ad69341c":"markdown","0ff760dd":"markdown","52dc1ae7":"markdown","117c0f57":"markdown","8def2706":"markdown","8b798011":"markdown","76cfd992":"markdown","c6102411":"markdown","78898ca7":"markdown","3fe92789":"markdown","ac2e96e1":"markdown","37c797c8":"markdown","c5de0b96":"markdown","23fc91c3":"markdown","7f350ade":"markdown","312f7991":"markdown","ff10266e":"markdown","4e50b75b":"markdown","c0adf694":"markdown","2e99d583":"markdown","17b63ccd":"markdown","9e5bf0d2":"markdown","7f5831d7":"markdown","f670ef7e":"markdown","afd61869":"markdown","c7bbc175":"markdown","5b5c56d5":"markdown","c91e982a":"markdown","ca6858d0":"markdown","52b8254f":"markdown","a9ef3092":"markdown","0dc43d3e":"markdown","1361e012":"markdown","d25325a7":"markdown","35dde37f":"markdown","0db42263":"markdown","478701ea":"markdown","3a80f1b2":"markdown","45ba2dad":"markdown","051dce5d":"markdown","81b5bf4d":"markdown","807e6f48":"markdown","f802e518":"markdown","4d805f79":"markdown","c82af593":"markdown","ee7ca955":"markdown","6b5b24da":"markdown","ff02225d":"markdown"},"source":{"f1a14468":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9c300c08":"# Seaborn is a Python data visualization library based on matplotlib. It provides a high-level interface for drawing attractive and informative statistical graphics.\nimport seaborn as sns","02b7a6f4":"import matplotlib.pyplot as plt\nfrom collections import deque\n%matplotlib inline\n\n# Set multiple theme parameters in one step.\n# Each set of parameters can be set directly or temporarily, see the referenced functions below for more information.\n# color_codes: bool\n# If True and palette is a seaborn palette, remap the shorthand color codes (e.g. \u201cb\u201d, \u201cg\u201d, \u201cr\u201d, etc.) to the colors from this palette.\nsns.set(color_codes=True)","bb46d89e":"# Print the Dataset out\ndataset = pd.read_csv(\"..\/input\/new-york-city-airbnb-open-data\/AB_NYC_2019.csv\")\ndataset.head()\n","5da3ddf0":"# Display the number of null values can be found in each column \ndataset.isnull().sum()","9edc7f9a":"# The codes below returns the dimension of the dataset which is a tuple (a,b) where a is the total number of row and b is the total number of column\ndataset.shape","29885c3e":"# Find out the null percentage of name and host_name\nprint(\"Percentage of null name: \", 16\/48895*100, \"%\")\nprint(\"Percentage of null name: \", 21\/48895*100, \"%\")","6b83ae4f":"# replace all null host_name with \"No information provided\"\ndataset.host_name.fillna(\"No information provided\", inplace = True)","27300dc9":"# replace all null name with \"No Name provided\"\ndataset.name.fillna(\"No Name provided\" , inplace = True)","0f37999d":"# Check for null again\ndataset.isnull().sum()","c97d3b33":"# describe() is used to view some basic statistical details like percentile, mean, std etc. of a data frame or a series of numeric values.\ndataset.describe()","7684b91d":"# print total unique neighbourhoods count\nprint (\"Total Neighbourhoods:\", len(np.unique(dataset.neighbourhood)))","a6666036":"# print total unique neighbourhood group\nprint (\"Total Listing group:\", len(np.unique(dataset.neighbourhood_group)))","0f0d2109":"# Print the percentage of neighbourhood group and the total neighbourhoods count\nprint(\"% of neighbourhood group & the total neighbourhoods count: \", 5\/221*100, \"%\")","40b4457f":"# print total unique roomtype\nprint (\"Total Listing room type:\", len(np.unique(dataset.room_type)))","bcd43534":"# Print room type distribution\ndataset['room_type'].value_counts()","15943c4d":"fig = plt.figure(figsize=(10,10), dpi=100)\ndataset['room_type'].value_counts().plot(kind='pie',  autopct='%1.0f%%', startangle=360, fontsize=16)","4a2f9beb":"# Initiate Hash Table class\n\nclass HashTable:\n    def __init__(self, length):\n       # Initiate our array with empty values.\n        self.array = [None] * length\n    \n    def hash(self, key):\n        \"\"\"Get the index of our array for a specific string key\"\"\"\n        length = len(self.array)\n        return hash(key) % length\n        \n    def add(self, key, value):\n        \"\"\"Add a value to our array by its key\"\"\"\n        index = self.hash(key)\n        if self.array[index] is not None:\n            # This index already contain some values.\n            # This means that this add MIGHT be an update\n            # to a key that already exist. Instead of just storing\n            # the value we have to first look if the key exist.\n            for kvp in self.array[index]:\n                # If key is found, then update\n                # its current value to the new value.\n                if kvp[0] == key:\n                    kvp[1] = value\n                    break\n            else:\n                # If no breaks was hit in the for loop, it \n                # means that no existing key was found, \n                # so we can simply just add it to the end.\n                self.array[index].append([key, value])\n        else:\n            # This index is empty. We should initiate \n            # a list and append our key-value-pair to it.\n            self.array[index] = []\n            self.array[index].append([key, value])\n        if self.is_full():\n            self.double()\n    \n    def get(self, key):\n        \"\"\"Get a value by key\"\"\"\n        index = self.hash(key)\n        if self.array[index] is None:\n            return \"No value can be found\"\n        else:\n            # Loop through all key-value-pairs\n            # and find if our key exist. If it does \n            # then return its value.\n            for kvp in self.array[index]:\n                if kvp[0] == key:\n                    return kvp[1]\n            \n            # If no return was done during loop,\n            # it means key didn't exist.\n            return \"No value can be found\"\n    def is_full(self):\n        \"\"\"Determines if the HashTable is too populated.\"\"\"\n        items = 0\n        # Count how many indexes in our array\n        # that is populated with values.\n        for item in self.array:\n            if item is not None:\n                items += 1\n        # Return bool value based on if the \n        # amount of populated items are more \n        # than half the length of the list.\n        return items > len(self.array)\/2\n        \n    def double(self):\n        \"\"\"Double the list length and re-add values\"\"\"\n        ht2 = HashTable(length=len(self.array)*2)\n        for i in range(len(self.array)):\n            if self.array[i] is None:\n                continue\n            \n            # Since our list is now a different length,\n            # we need to re-add all of our values to \n            # the new list for its hash to return correct\n            # index.\n            for kvp in self.array[i]:\n                ht2.add(kvp[0], kvp[1])\n        \n        # Finally we just replace our current list with \n        # the new list of values that we created in ht2.\n        self.array = ht2.array\n    def print_items(self):\n        \"\"\"Print Method for the class\"\"\"\n        index = len(self.array)\n        for kvp in range(index):\n                return self.array[kvp]","943eb71c":"print(np.unique(dataset.neighbourhood_group))","eaa7254f":"datasetBronx = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Bronx\":\n        datasetBronx.append(dataset.host_name[i])\n        \n","79046c9e":"datasetBronx_id = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Bronx\":\n        datasetBronx_id.append(dataset.id[i])","cdc55e0e":"hashtableBronx = HashTable(len(datasetBronx))","75a132a0":"\nfor i in range(len(datasetBronx)):\n    hashtableBronx.add(datasetBronx_id[i],datasetBronx[i])","f5fff998":"datasetBrooklyn = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Brooklyn\":\n        datasetBrooklyn.append(dataset.host_name[i])\ndatasetBrooklyn_id = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Brooklyn\":\n        datasetBrooklyn_id.append(dataset.id[i])\nprint(len(datasetBrooklyn))\nprint(len(datasetBrooklyn_id))","1315861b":"hashtableBrooklyn = HashTable(len(datasetBrooklyn))\nfor i in range(len(datasetBrooklyn)):\n    hashtableBrooklyn.add(datasetBrooklyn_id[i],datasetBrooklyn[i])","79f5fd58":"datasetManhattan = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Manhattan\":\n        datasetManhattan.append(dataset.host_name[i])\ndatasetManhattan_id = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Manhattan\":\n        datasetManhattan_id.append(dataset.id[i])\nprint(len(datasetManhattan))\nprint(len(datasetManhattan_id))","7183378f":"hashtableManhattan = HashTable(len(datasetManhattan))\nfor i in range(len(datasetManhattan)):\n    hashtableManhattan.add(datasetManhattan_id[i],datasetManhattan[i] )","044bbb06":"datasetQueens = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Queens\":\n        datasetQueens.append(dataset.host_name[i])\ndatasetQueens_id = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Queens\":\n        datasetQueens_id.append(dataset.id[i])\nprint(len(datasetQueens))\nprint(len(datasetQueens_id))","2f26c35d":"hashtableQueens = HashTable(len(datasetQueens))\nfor i in range(len(datasetQueens)):\n    hashtableQueens.add(datasetQueens_id[i],datasetQueens[i] )","2de71d8b":"datasetStatenIslands = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Staten Island\":\n        datasetStatenIslands.append(dataset.host_name[i])\ndatasetStatenIslands_id = []\nfor i in range (len(dataset.neighbourhood_group)):\n    if dataset.neighbourhood_group[i] == \"Staten Island\":\n        datasetStatenIslands_id.append(dataset.id[i])\nprint(len(datasetStatenIslands))\nprint(len(datasetStatenIslands_id))","1064f632":"hashtableStatenIsland = HashTable(len(datasetQueens))\nfor i in range(len(datasetStatenIslands)):\n    hashtableStatenIsland.add(datasetStatenIslands_id[i],datasetStatenIslands[i] )","05cf462d":"print(\"total number of airbnb houses in Bronx: \",len(datasetBronx))\nprint(\"total number of airbnb houses in Brooklyn:\",len(datasetBrooklyn))\nprint(\"total number of airbnb houses in Manhattan:\",len(datasetManhattan))\nprint(\"total number of airbnb houses in Queens: \", len(datasetQueens))\nprint(\"total number of airbnb houses in Staten Islands: \", len(datasetStatenIslands))\n\n","56962df3":"fig = plt.figure()\nax = fig.add_axes([0,0,1,1])\nArea = ['Bronx', 'Brooklyn', 'Manhattan', 'Queens', 'Staten Islands']\nHouses = [1091,20104,21661,5666,373]\nax.bar(Area,Houses)\nplt.show()","037fdc99":"fig = plt.figure(figsize=(10,10), dpi=100)\ndataset['neighbourhood_group'].value_counts().plot(kind='pie',  autopct='%1.0f%%', startangle=360, fontsize=16)","53dc287d":"# Binary Search Tree class implementation\nclass BinarySearchTree:\n    \n    def __init__(self, val=None):\n        \"\"\"Initiate The tree with __init__\"\"\"\n        self.left = None\n        self.right = None\n        self.val = val\n    \n    def insert(self, val):\n        \"\"\"Method for data insertion \"\"\"\n        if not self.val:\n            self.val = val\n            return\n\n        if self.val == val:\n            return\n    # Make sure that the data is inserted correctly for the tree to be balanced\n        if val < self.val:\n            if self.left:\n                self.left.insert(val)\n                return\n            self.left = BinarySearchTree(val)\n            return\n\n        if self.right:\n            self.right.insert(val)\n            return\n        self.right = BinarySearchTree(val)\n\n    def get_min(self):\n        \"\"\"Get minimum value stored in the tree\"\"\"\n        current = self\n        while current.left is not None:\n            current = current.left\n        return current.val\n\n    def get_max(self):\n        \"\"\"Get minimum value stored in the tree\"\"\"\n        current = self\n        while current.right is not None:\n            current = current.right\n        return current.val\n\n    def delete(self, val):\n        \"\"\"Delete data from the Tree\"\"\"\n        if self == None:\n            return self\n        if val < self.val:\n            if self.left:\n                self.left = self.left.delete(val)\n            return self\n        if val > self.val:\n            if self.right:\n                self.right = self.right.delete(val)\n            return self\n        if self.right == None:\n            return self.left\n        if self.left == None:\n            return self.right\n        min_larger_node = self.right\n        while min_larger_node.left:\n            min_larger_node = min_larger_node.left\n        self.val = min_larger_node.val\n        self.right = self.right.delete(min_larger_node.val)\n        return self\n\n    def exists(self, val):\n        \"\"\"Check wether a specific data is already existed in a Tree. This function returns a Boolean of True or False\"\"\"\n        if val == self.val:\n            return True\n\n        if val < self.val:\n            if self.left == None:\n                return False\n            return self.left.exists(val)\n\n        if self.right == None:\n            return False\n        return self.right.exists(val)\n\n    def preorder(self, vals):\n        \"\"\"Print out the tree with preorder traversing\"\"\"\n        if self.val is not None:\n            vals.append(self.val)\n        if self.left is not None:\n            self.left.preorder(vals)\n        if self.right is not None:\n            self.right.preorder(vals)\n        return vals\n\n    def inorder(self, vals):\n        \"\"\"Print out the tree with inorder traversing\"\"\"\n        if self.left is not None:\n            self.left.inorder(vals)\n        if self.val is not None:\n            vals.append(self.val)\n        if self.right is not None:\n            self.right.inorder(vals)\n        return vals\n\n    def postorder(self, vals):\n        \"\"\"Print out the tree with postorder traversing\"\"\"\n        if self.left is not None:\n            self.left.postorder(vals)\n        if self.right is not None:\n            self.right.postorder(vals)\n        if self.val is not None:\n            vals.append(self.val)\n        return vals","8e877093":"print(len(dataset.price))","de403b98":"print(dataset.price)","7e804e8b":"# initiate the Binary Search Tree into bst_price\nbst_price = BinarySearchTree()\nfor i in range(len(dataset.price)):\n    bst_price.insert(dataset.price[i])\n    ","7173e7d0":"# Traver the tree in preorder\nbst_price.inorder([])","b3d7ba0e":"# Get the maximum price\nbst_price.get_max()","abfff88f":"# get the id of the max price\nfor i in range(len(dataset.price)):\n    if dataset.price[i] == bst_price.get_max():\n        print(dataset.id[i])\n       ","39fbcfd9":"hashtableBronx.get(7003697)","0576ddb8":"hashtableBrooklyn.get(7003697)","d1102c1f":"hashtableManhattan.get(7003697)","bdba1389":"hashtableQueens.get(7003697)","35148cc4":"hashtableStatenIsland.get(7003697)","c5364166":"hashtableBronx.get(13894339)","1a5a3959":"hashtableBrooklyn.get(13894339)","28e530d1":"hashtableBronx.get(22436899)","550e5012":"hashtableBrooklyn.get(22436899)","6a652814":"hashtableManhattan.get(22436899)","488953d5":"# get the minimum price \nbst_price.get_min()","c3e7aff8":"# get the id of the min price\n# store all the minimum value inside list \"min\"\nmin = []\nfor i in range(len(dataset.price)):\n    if dataset.price[i] == bst_price.get_min():\n        print(dataset.id[i])\n        min.append(dataset.id[i])\nprint(\"number of min value found: \", len(min))\n       ","da55647e":"print(len(min))","257f7e12":"for i in min:\n    print(hashtableBronx.get(i),\"with id\", i, \"in Bronx\")\nprint(\"-\" * 20)    \nfor i in min:\n    print(hashtableBrooklyn.get(i),\"with id\", i, \"in Brooklyn\")\nprint(\"-\" * 20)\nfor i in min:\n    print(hashtableManhattan.get(i), \"with id\", i, \"in Manhanttan\")\nprint(\"-\" * 20)\nfor i in min:\n    print(hashtableQueens.get(i), \"with id\", i, \"in Queens\")\nprint(\"-\" * 20)\nfor i in min:\n    print(hashtableStatenIsland.get(i), \"with id\", i, \"in Staten Island\")\n    \n    \n    ","f4c97490":"# All datas from minimum_nights\nprint(dataset.minimum_nights)","9b166d83":"# Print all unique data in minimum_nights\nprint(dataset.minimum_nights.unique())","15074bbb":"minimum_night_list = []\nfor i in dataset.minimum_nights.unique():\n    minimum_night_list.append(i)\nprint(len(minimum_night_list))    ","765dd8ca":"# Initiate Merge Sort Algorithm\ndef mergeSort(arr):\n    if len(arr) > 1:\n \n         # Finding the mid of the array\n        mid = len(arr)\/\/2\n \n        # Dividing the array elements\n        L = arr[:mid]\n \n        # into 2 halves\n        R = arr[mid:]\n \n        # Sorting the first half\n        mergeSort(L)\n \n        # Sorting the second half\n        mergeSort(R)\n \n        i = j = k = 0\n \n        # Copy data to temp arrays L[] and R[]\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n \n        # Checking if any element was left\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n \n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1","3f05340c":"mergeSort(minimum_night_list)","96216b33":"print(minimum_night_list)","52b7bcc5":"dataset['minimum_nights'].value_counts()\n    \n    ","f77a55be":"print(dataset.calculated_host_listings_count)","28d8a391":"# Put all calculated_host_listings_counts variables into Binary Tree Data Structure to implement the Binary Tree Search Algorithm\nbst_listings_count = BinarySearchTree()\nfor i in range(len(dataset.calculated_host_listings_count)):\n    bst_listings_count.insert(dataset.calculated_host_listings_count[i])","e894ad81":"# Inorder traverse of the Tree\nbst_listings_count.inorder([])","f46bec08":"# Get the maximum listing_counts\nbst_listings_count.get_max()","5c976aa7":"# Find all the houses associated with this host through host id\nhouse_list = []\nfor i in range(len(dataset.calculated_host_listings_count)):\n    if dataset.calculated_host_listings_count[i] == bst_listings_count.get_max():\n        house_list.append(dataset.id[i])\n       \n","32d161fb":"print(len(house_list))","c65310f9":"# finding the host name and the area his\/her houses are located by the get() method from Hash Table\nfor i in house_list:\n    if hashtableBronx.get(i) != \"No value can be found\":\n        print(hashtableBronx.get(i),\"with id\", i, \"in Bronx\")\nprint(\"-\" * 20)    \nfor i in house_list:\n    if hashtableBrooklyn.get(i) != \"No value can be found\":\n        print(hashtableBrooklyn.get(i),\"with id\", i, \"in Brooklyn\")\nprint(\"-\" * 20)\nfor i in house_list:\n    if hashtableManhattan.get(i) != \"No value can be found\":\n        print(hashtableManhattan.get(i), \"with id\", i, \"in Manhanttan\")\nprint(\"-\" * 20)\nfor i in house_list:\n    if hashtableQueens.get(i) != \"No value can be found\":\n        print(hashtableQueens.get(i), \"with id\", i, \"in Queens\")\nprint(\"-\" * 20)\nfor i in house_list:\n    if hashtableStatenIsland.get(i) != \"No value can be found\":\n        print(hashtableStatenIsland.get(i), \"with id\", i, \"in Staten Island\")","e6d938f7":"# Find all the houses associated with this second host through host id\nhouse_list_2 = []\nfor i in range(len(dataset.calculated_host_listings_count)):\n    if dataset.calculated_host_listings_count[i] == 232:\n        house_list_2.append(dataset.id[i])\n       \n","f5e4c870":"print(len(house_list_2))","4793ce3a":"# finding the host name and the area his\/her houses are located by the get() method from Hash Table\nfor i in house_list_2:\n    if hashtableBronx.get(i) != \"No value can be found\":\n        print(hashtableBronx.get(i),\"with id\", i, \"in Bronx\")\nprint(\"-\" * 20)    \nfor i in house_list_2:\n    if hashtableBrooklyn.get(i) != \"No value can be found\":\n        print(hashtableBrooklyn.get(i),\"with id\", i, \"in Brooklyn\")\nprint(\"-\" * 20)\nfor i in house_list_2:\n    if hashtableManhattan.get(i) != \"No value can be found\":\n        print(hashtableManhattan.get(i), \"with id\", i, \"in Manhanttan\")\nprint(\"-\" * 20)\nfor i in house_list_2:\n    if hashtableQueens.get(i) != \"No value can be found\":\n        print(hashtableQueens.get(i), \"with id\", i, \"in Queens\")\nprint(\"-\" * 20)\nfor i in house_list_2:\n    if hashtableStatenIsland.get(i) != \"No value can be found\":\n        print(hashtableStatenIsland.get(i), \"with id\", i, \"in Staten Island\")","3ee2cd74":"print(dataset.availability_365)","6bf4a275":"# Put all availability_365 variables into Binary Tree Data Structure to implement the Binary Tree Search Algorithm\nbst_availability_365 = BinarySearchTree()\nfor i in range(len(dataset.availability_365)):\n    bst_availability_365.insert(dataset.availability_365[i])","edabe83d":"# Get the maximum availability_365\nbst_availability_365.get_max()","933d2dda":"# Find all the houses associated with this busiest hostthrough host id\navailability_list = []\nfor i in range(len(dataset.availability_365)):\n    if dataset.availability_365[i] == bst_availability_365.get_max():\n        availability_list.append(dataset.id[i])\n       ","129b9612":"print(len(availability_list))","f549a093":"# finding the host names and the area there houses are located by the get() method from Hash Table\nfor i in availability_list:\n    if hashtableBronx.get(i) != \"No value can be found\":\n        print(hashtableBronx.get(i),\"with id\", i, \"in Bronx\")\nprint(\"-\" * 20)    \nfor i in availability_list:\n    if hashtableBrooklyn.get(i) != \"No value can be found\":\n        print(hashtableBrooklyn.get(i),\"with id\", i, \"in Brooklyn\")\nprint(\"-\" * 20)\nfor i in availability_list:\n    if hashtableManhattan.get(i) != \"No value can be found\":\n        print(hashtableManhattan.get(i), \"with id\", i, \"in Manhanttan\")\nprint(\"-\" * 20)\nfor i in availability_list:\n    if hashtableQueens.get(i) != \"No value can be found\":\n        print(hashtableQueens.get(i), \"with id\", i, \"in Queens\")\nprint(\"-\" * 20)\nfor i in availability_list:\n    if hashtableStatenIsland.get(i) != \"No value can be found\":\n        print(hashtableStatenIsland.get(i), \"with id\", i, \"in Staten Island\")","da70a83a":"dataset['number_of_reviews'].value_counts()","b40fcadc":"dataset[dataset['number_of_reviews'] == 607]","e326eaa5":"As we can see earlier, we have a total of 5 main neighbourhood, we will spread the dataset into smaller subsets of 5 main neighbourhood","6d7e6527":"There are 16 null name and 21 null host_name","701604f5":"## Adding all data within neighbourhood group of Staten Island to Hash Table: hashtableStatenIsland with key of id and value of host name","1e0dc742":"\"Great Bedroom in Manhattan\" in Manhattan owned by Ji has the most reviews. It has a private room type with the price of 49 Dollars per night","94acda8d":"Time complexity already explained for the Hash Table get() algorithm above","487fd715":"Manhattan has the total houses of 44%, largest compare to Bronx, Queens, Brooklyn and Staten Island","16885e3b":"Because we have a huge dataset with 48895 rows and 16 column. And this data research project requires us to read and visualize multiple datas as once. Hash Table data structure comes in handy since they are very fast with the access time of an element is on average O(1). We can easily search for any host name with time complexity of O(1) with just the provided id","d39c4ef2":"Most homes are for rent for only 1 and 2 night stay because the value count for 1 and 2 is the highest with 12720 and 11696 respectively","2a96b1c6":"### 7003697","59fd696c":"Brooklyn and Manhattan both has houses with the highest price and the lowest price. the price difference is huge for these two areas. They are also the area which has the most airbnb houses for rent (has already been shown above)","4a9eb359":"Surprisingly for us, in this dataset the lowest price for a house rent is 0! And there are a total of 11 house for rent like that!","9185e042":"We got 3 ids of 3 Airbnb house with the largest price value. Now we will pass these ids into our 5 hash tables to search for the host names","297c4631":"last_review and reviews_per_month are variables that considered to be not much necessary toward this data research","ad69341c":"The busiest hosts are the hosts with rooms that listing is always available for booking in a year as the get_max() return the value of 365","0ff760dd":"Merge sort Algorithm analysis\n\nTime complexity: \n* Best Case Time Complexity: O(n*log n)\n\n* Worst Case Time Complexity: O(n*log n)\n\n* Average Time Complexity: O(n*log n)","52dc1ae7":"Surprisingly, there are house for rent with the price of 0! ","117c0f57":"### 13894339 (same as going with 7003697)","8def2706":"## Conclusion of price research","8b798011":"Katherine, who is a host in Queens neighbourhood area, has an Airbnb house with a highest price of 10000. We can easily see that by a get() method from Hash Table with a fast time complexity of O(1). Because id is unique so that Hash Tables associated with a wrong neighbourhood group will not find any value, they will throw an error report as \"No value can be found\" as seen above.","76cfd992":"We can see that there are people who rent the Airbnb house for 1250 days!","c6102411":"### 22436899","78898ca7":"# Area with most Airbnb houses","3fe92789":"****Sonder (NYC) is the most houses owned host we are looking for and all of her houses are located in only Manhanttan as the result you can see above****","ac2e96e1":"***Use Merge Sort Algorithm to sort minimum_nights***","37c797c8":"## Number of reviews research","c5de0b96":"The most-owned-house host has 327 different houses!","23fc91c3":"## Finding the hosts with most houses owned with calculated_host_listings_count","7f350ade":"## Price research","312f7991":"# Use Binary Search Tree to sort, find and get value of price, minimum_nights, number_of_reviews, reviews_per_month and availability_365, calculated_host_listings_count","ff10266e":"We will initiated the Hashtable and store our dataset inside it","4e50b75b":"Then we put 5 smaller subsets into 5 hash tables","c0adf694":"# Name: Nguyen Quoc Minh Quan\n# Student ID: 13740328\n# James Cook University Singapore\n# Lecturer: Shailey Chawla","2e99d583":"### Adding all data within neighbourhood group of Bronx to Hash Table: hashtableBronx with key of id and value of host name","17b63ccd":"# Data scanning, Data cleaning and basic understandings of the dataset","9e5bf0d2":"## Minimum Night research","7f5831d7":"There are a total of 48895 rows, which means there are a total of 48895 host_id and host_name","f670ef7e":"We can see from the inorder traverse algorithm of the Binary Tree, the second largest number is 232","afd61869":"## Finding the busiest hosts with availability_365","c7bbc175":"***Note:  For the implementation of the Binary Search Tree class, we must always make sure that the tree is balanced. If the tree becomes unbalanced all the fast O(log(n)) operations will quickly degrade to O(n).**","5b5c56d5":"### Finding the second most houses owned host","c91e982a":" ## Adding all data within neighbourhood group of Queens to Hash Table: hashtableQueens with key of id and value of host name","ca6858d0":"First, we implement the datas into the Binary Search Tree Data Structure. Binary Search Tree is defined as a tree data structure with nodes store a key greater than all their left child nodes and less than all of their right child nodes. \n\nBinary search tree algorith provide an average Big-O complexity of O(log(n)) for retrieval, insertion, update, and delete operations. Log(n) is much faster than the linear O(n) time required to find items in an unsorted array. \n\nSince BST is super fast in terms of data retrieval with the time complexity of O(log(n)), It is very useful for the finding and the sorting of ours dataset.\n\n","52b8254f":"The last person to join the '10000 - club' is Jelena and she has a home in Manhattan","a9ef3092":"There are around 10000 of airbnb houses that don't receive any reviews users","0dc43d3e":"These are the list of busiest hosts in different areas determined by the number of days when listing is available for booking. The highest number of days when listing is available for booking is 365","1361e012":"There are only three main room types in this dataset","d25325a7":"The Inorder traverse of the Binary Search Tree gives us an array of price range price from lowest to highest\nIn order to analyse the time complexity of a tree traversal you have to think in the terms of number of nodes visited. If a tree has n nodes, then each node is visited only once in inorder traversal and hence the complexity is O(n).","35dde37f":"# Use Hash Table to store id and name of airbnb host of the dataset\n","0db42263":"Erin, who is a host in Brooklyn neighbourhood area, also has an Airbnb house with a highest price of 10000.","478701ea":"We can easily observer that minimum_night list has been sorted from the lowest to the highest value. Many people rent the Airbnb houses for a vary range of days","3a80f1b2":"There is one Airbnb house that receive the most number of 607 reviews","45ba2dad":"Manhattan, Queens and Brooklyn are areas which has house that are for rent with the highest price (1000 Dollars)","051dce5d":"The null percentage is much much lower than 0,1%, but they are vitals data to this research so we need to fill them up with some temp data in order for the research algorithms to work","81b5bf4d":" ## Adding all data within neighbourhood group of Manhattan to Hash Table: hashtableManhattan with key of id and value of host name","807e6f48":"We can see here that 221 neighbourhoods are part of 5 main major neighbourhood group","f802e518":"The Inorder traverse of the Binary Search Tree gives us an array of listing_counts price from lowest to highest.\n\nIn order to analyse the time complexity of a tree traversal you have to think in the terms of number of nodes visited. If a tree has n nodes, then each node is visited only once in inorder traversal and hence the complexity is O(n).\n","4d805f79":"****Blueground is the second host we are looking for, most of Blueground's houses are in Manhanttan just like Sonder (NYC). But unlike Sonder, he\/she has  houses from other area, which is Brooklyn  ****","c82af593":" ## Adding all data within neighbourhood group of Brooklyn to Hash Table: hashtableBrooklyn with key of id and value of host name","ee7ca955":"Which mean the most houses owned busiest host has 232 different houses","6b5b24da":"We can easily see that Manhattan has the most airbnb houses of 21661","ff02225d":"Houses with the surpiringly low price at 0 cannot be found at Staten Island and Queens, but instead only in Manhanttan, Brooklyn and Bronx. Adeyemi is the host with the biggest number of lowest-price-house with 3 houses of id 20639628, 20639792 and 20639792 and all of them are located in Brooklyn, following Adeyemi is Sergii with 2 houses with id 21291569  and 21304320 . Brooklyn is the area with the most lowest price house (9 houses)"}}