{"cell_type":{"f509ccea":"code","40f77bce":"code","e666d395":"code","52abdb69":"code","c192673f":"code","ed05be25":"code","8076a5fe":"code","db4fdbde":"code","93889151":"code","b83257e9":"code","704006bc":"code","47a5f903":"code","3e62891e":"code","e81c9758":"code","96f2aef7":"markdown","08fad582":"markdown","1b0e63cd":"markdown","d22d9fa9":"markdown","90e706c5":"markdown","a27918e1":"markdown"},"source":{"f509ccea":"import numpy as np\nimport pandas as pd\npd.set_option('max_columns', None)\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import OrdinalEncoder, OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\n\nfrom sklearn.ensemble import RandomForestRegressor","40f77bce":"data = pd.read_json('..\/input\/netherlands-rent-properties\/properties.json', lines=True)","e666d395":"data","52abdb69":"data.info()","c192673f":"data['crawlStatus'].value_counts()","ed05be25":"def preprocess_inputs(df):\n    df = df.copy()\n    \n    # Drop bad rows\n    bad_rows = df.query(\"crawlStatus == 'unavailable'\").index\n    df = df.drop(bad_rows, axis=0).reset_index(drop=True)\n    \n    # Use only select features\n    df = df[[\n        'areaSqm',\n        'city',\n        'furnish',\n        'latitude',\n        'longitude',\n        'propertyType',\n        'rent',\n        'internet',\n        'kitchen',\n        'living',\n        'pets',\n        'shower',\n        'smokingInside',\n        'toilet'\n    ]]\n    \n    # Encode improper values\n    df = df.replace({'': np.NaN, 'Unknown': np.NaN})\n    \n    # Fill missing values\n    missing_value_columns = df.columns[df.isna().sum() > 0]\n    for column in missing_value_columns:\n        df[column] = df[column].fillna(df[column].mode()[0])\n    \n    # Split df into X and y\n    y = df['rent']\n    X = df.drop('rent', axis=1)\n    \n    # Train-test split\n    X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.7, shuffle=True, random_state=1)\n    \n    return X_train, X_test, y_train, y_test, X","8076a5fe":"X_train, X_test, y_train, y_test, X = preprocess_inputs(data)","db4fdbde":"X_train","93889151":"y_train","b83257e9":"X_train","704006bc":"{column: len(X[column].unique()) for column in X.select_dtypes('object').columns}","47a5f903":"nominal_features = [\n    'city',\n    'furnish',\n    'propertyType',\n    'kitchen',\n    'living',\n    'pets',\n    'shower',\n    'smokingInside',\n    'toilet'\n]\n\nbinary_transformer = Pipeline(steps=[\n    ('ordinal', OrdinalEncoder())\n])\n\nnominal_transformer = Pipeline(steps=[\n    ('onehot', OneHotEncoder(sparse=False, handle_unknown='ignore'))\n])\n\npreprocessor = ColumnTransformer(transformers=[\n    ('binary', binary_transformer, ['internet']),\n    ('nominal', nominal_transformer, nominal_features)\n], remainder='passthrough')\n\n\nmodel = Pipeline(steps=[\n    ('preprocessor', preprocessor),\n    ('regressor', RandomForestRegressor())\n])","3e62891e":"model.fit(X_train, y_train)","e81c9758":"y_pred = model.predict(X_test)\n\nrmse = np.sqrt(np.mean((y_test - y_pred)**2))\nr2 = 1 - (np.sum((y_test - y_pred)**2) \/ np.sum((y_test - y_test.mean())**2))\n\nprint(\"     RMSE: {:.2f}\".format(rmse))\nprint(\"R^2 Score: {:.5f}\".format(r2))","96f2aef7":"# Data Every Day  \n\nThis notebook is featured on Data Every Day, a YouTube series where I train models on a new dataset each day.  \n\n***\n\nCheck it out!  \nhttps:\/\/youtu.be\/grd1W0HBdlk","08fad582":"# Task for Today  \n\n***\n\n## Netherlands Rent Prediction  \n  \nGiven *data about properties in the Netherlands*, let's try to predict the **rent** for a given property.  \n  \nWe will use a random forest pipeline regression model to make our predictions.","1b0e63cd":"# Preprocessing","d22d9fa9":"# Building Pipeline and Training","90e706c5":"# Results","a27918e1":"# Getting Started"}}