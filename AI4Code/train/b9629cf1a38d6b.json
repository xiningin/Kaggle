{"cell_type":{"5aa962fb":"code","703e9898":"code","737f56cc":"code","a7f43f26":"code","6eb70cf3":"code","1fea9c66":"code","fb5b2ec8":"code","4da5c72e":"code","f3b087ed":"code","df8927c4":"code","040d428a":"code","548eeb2e":"code","07801bc1":"code","c198d661":"code","190291fe":"code","4e51bb11":"code","4f928b9b":"code","5b5c4117":"code","2b1b52b4":"code","a843663c":"code","b6163a00":"markdown","28e84895":"markdown","f7149a14":"markdown","580acd62":"markdown","e5791f7e":"markdown","50a49ac9":"markdown","b8f8dde9":"markdown","b9280ddc":"markdown","7c4d18f0":"markdown","5e7bb11f":"markdown","b5808f59":"markdown","807ed963":"markdown","0401bc5f":"markdown","b7c0ed76":"markdown","19cfc122":"markdown"},"source":{"5aa962fb":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# geospatial frameworks\nimport rasterio as rs\nfrom rasterio.plot import show  # imshow for raster\nimport geopandas as gpd\nfrom shapely.geometry import Polygon, box  # for geometry processing","703e9898":"def get_filepath(image_id, mode='PS-RGB'):\n    return f'{ROOT_DIR}{mode}\/SN6_Train_AOI_11_Rotterdam_{mode}_{image_id}.tif'\n\ndef get_raster(image_id, mode='PS-RGB'):\n    return rs.open(get_filepath(image_id, mode))","737f56cc":"ROOT_DIR = '..\/input\/spacenet-6-multisensor-allweather-mapping\/AOI_11_Rotterdam\/'\n\n# grab unique image_id from the annotation csv\ndf = pd.read_csv(ROOT_DIR+'SummaryData\/SN6_Train_AOI_11_Rotterdam_Buildings.csv')\nimage_ids = df.ImageId.unique()\n\n# we'll use the tile boundaries\nex_image_id = image_ids[0]\nex_raster = get_raster(ex_image_id)\nshow(ex_raster)\n\nprint(f'Coordinate system: {ex_raster.crs}')\nprint(f'Tile boundaries: {ex_raster.bounds}')\n\n# convert to corner coordinates\nlbox, bbox, rbox, tbox = ex_raster.bounds\ngeometry = Polygon([(lbox,tbox),\n                  (rbox,tbox),\n                  (rbox,bbox),\n                  (lbox,bbox)])\nprint(geometry)","a7f43f26":"geometry = box(*ex_raster.bounds)\nprint(geometry)","6eb70cf3":"# create geodataframe\nd = {'tile': [ex_image_id], 'geometry': [geometry]}\ngdf = gpd.GeoDataFrame(d, crs='epsg:32631')\n\ndisplay(gdf)\n\n# we can easily plot a geodataframe using .plot() method\ngdf.plot(); plt.show()","1fea9c66":"%%time\n# I anticipated adding mode options, but I think the tile boundaries are the same for each mode\ndef create_geometry(mode, image_ids):\n    geometry = []\n\n    for image_id in image_ids:\n        # read the raster\n        ex_raster = rs.open(get_filepath(image_id, mode))\n        \n        # grab its boundaries and convert to box coordinates\n        geometry.append(box(*ex_raster.bounds))\n\n    # create geodataframe\n    d = {'image_id': image_ids, 'geometry': geometry}\n    gdf = gpd.GeoDataFrame(d, crs='epsg:32631')\n\n    # saving to geojson file\n    gdf.to_file(f'{mode}.geojson', driver='GeoJSON')\n    print(f'{mode}.geojson saved successfully!')\n    \ncreate_geometry('PS-RGB', image_ids)","fb5b2ec8":"gdf = gpd.read_file('PS-RGB.geojson')\ndisplay(gdf.head())\ndisplay(gdf.crs)","4da5c72e":"# return a geodataframe where image_id contains the following tile id\nodd_gdf = gdf[gdf['image_id'].str.contains('3721|3723|3725')]\neven_gdf = gdf[gdf['image_id'].str.contains('3720|3722|3724')]\n\n# plot all tile boundaries and highlight odd and even tiles\nfig, ax1 = plt.subplots(figsize=(10,10))\ngdf.plot(color='grey', alpha=0.3, edgecolor='black', ax=ax1)\nodd_gdf.plot(color='green', alpha=0.7, edgecolor='white', ax=ax1)\neven_gdf.plot(color='red', alpha=0.7, edgecolor='white', ax=ax1)\n\nplt.title('All tile boundaries');plt.show()","f3b087ed":"print(odd_gdf.total_bounds)\n# make a polygon as our AOI\nlbox, bbox, rbox, tbox = odd_gdf.total_bounds\next = 100\ngeometry = Polygon([\n            (lbox-ext,tbox+ext),\n            (rbox+ext,tbox+ext),\n            (rbox+ext,bbox-ext),\n            (lbox-ext,bbox-ext)])\n\nd = {'tile': 1, 'geometry': geometry}\naoi_df = gpd.GeoDataFrame(d, crs='epsg:32631', index=[0])\n\nf,ax = plt.subplots()\naoi_df.plot(color='blue', alpha=0.7, edgecolor='white', ax=ax)\nodd_gdf.plot(color='green', edgecolor='white', ax=ax)\nplt.show()","df8927c4":"# use overlay\naoi_overlay = gpd.overlay(gdf, aoi_df, how='intersection')\naoi_overlay.plot(color='grey', alpha=0.3, edgecolor='black')\nplt.show()\nprint(f'{aoi_overlay.shape[0]} filtered tiles')","040d428a":"# using geopandas cx index\nlbox, bbox, rbox, tbox = odd_gdf.total_bounds\next = 100\naoi_df_cx = gdf.cx[lbox-ext:rbox+ext, bbox-ext:tbox+ext]\n\nfig, ax1 = plt.subplots(figsize=(10,10))\naoi_df_cx.plot(color='grey', alpha=0.3, edgecolor='black', ax=ax1)\naoi_df.plot(color='blue', alpha=0.7, edgecolor='white', ax=ax1)\nplt.show()\nprint(f'{aoi_df_cx.shape[0]} filtered tiles')","548eeb2e":"# percentage of remaining area\naoi_overlay['Area'] = aoi_overlay.area  # calculates area of each polygon\nmax_area = aoi_overlay.Area.max()  # max area of 1 tile\naoi_overlay['Per_Area'] = aoi_overlay['Area'].apply(lambda x: x\/max_area*100)\naoi_overlay.head()","07801bc1":"# filter only tiles that has high percentage of remaining area\naoi_overlay_filt = aoi_overlay[aoi_overlay.Per_Area > 50.1]\n# grab the image_id of the filtered tiles\ngdf_filt = aoi_overlay_filt.image_id.values\n# grab original the original tile boundaries of filtered image_ids\ngdf_filt = gdf[gdf.image_id.isin(gdf_filt)]\n\nfig, ax = plt.subplots(figsize=(10,10))\ngdf_filt.plot(color='grey', alpha=0.3, edgecolor='black', ax=ax)\naoi_df.plot(color='blue', alpha=0.7, edgecolor='white', ax=ax)\nplt.show()\nprint(aoi_overlay_filt.shape)","c198d661":"# get total bounds of gdf\ndef generate_AOI(split, gdf):\n    lbox, bbox, rbox, tbox = gdf.total_bounds\n    # horizontal stripes divides top-bot\n    unit = (tbox-bbox)\/split\n    geometry = []\n    for i in range(split):\n        u_bbox = bbox+(unit*i)  # i starts at 0, so u_bbox=bbox, then adds unit for each iter\n        u_tbox = u_bbox+unit\n        stripe = Polygon([\n            (lbox,u_tbox),\n            (rbox,u_tbox),\n            (rbox,u_bbox),\n            (lbox,u_bbox)])\n        geometry.append(stripe)\n        \n    # create geodataframe\n    df = gpd.GeoDataFrame({'geometry':geometry}, crs='epsg:32631')\n    return df\n\n\nSPLIT = 10\nAOI_stripes_gdf = generate_AOI(SPLIT, gdf)\nAOI_stripes_gdf.plot(color='grey', alpha=0.3, edgecolor='black')\nplt.show()","190291fe":"def filter_tile(aoi_df, gdf):\n    # overlay\n    aoi_overlay = gpd.overlay(gdf, aoi_df, how='intersection')\n    \n    # count percentage remaining area\n    aoi_overlay['Area'] = aoi_overlay.area\n    max_area = aoi_overlay.Area.max()\n    aoi_overlay['Per_Area'] = aoi_overlay['Area'].apply(lambda x: x\/max_area*100)\n    \n    # grab tiles that are more than half in the AOI\n    aoi_overlay_filt = aoi_overlay[aoi_overlay.Per_Area > 50.1]\n    return aoi_overlay_filt.image_id.values","4e51bb11":"filtered_tiles = []\n\n# iterate through all rows\nfor idx,rows in AOI_stripes_gdf.iterrows():\n    aoi_df = gpd.GeoDataFrame({'geometry': rows}, crs='epsg:32631')\n    filtered_tiles.append(filter_tile(aoi_df, gdf))\n\nprint(f'num of splits: {len(filtered_tiles)}')\nprint(filtered_tiles[0][:5])","4f928b9b":"col_map = ['aqua','beige','brown','coral','fuchsia','green','lime','orange','tan','tomato']\nfig, ax = plt.subplots(figsize=(10,10))\n\n# color tiles based on it's AOI stripe\nfor i,stripe in enumerate(filtered_tiles):\n    stripe_gdf = gdf[gdf['image_id'].isin(stripe)]\n    stripe_gdf.plot(\n        color=col_map[i], alpha=0.6, edgecolor='black', ax=ax\n    )\n    \nAOI_stripes_gdf.plot(color='grey', alpha=0.2, edgecolor='grey', ax=ax)\nplt.show()","5b5c4117":"# how many tiles in each stripe?\ntotal_split_tiles = 0\nfor i,stripes in enumerate(filtered_tiles):\n    print(f'stripe {i}: {len(stripes)} tiles')\n    total_split_tiles += len(stripes)\n\n# total split tiles vs total tiles in dataset\nprint(f'{total_split_tiles} tiles in split vs {gdf.shape[0]} total tiles available')","2b1b52b4":"# save the filtered image ids, convert to np array with dtype object for nested array with different shapes\nnp.save(f'SN6_{SPLIT}_splits.npy', np.array(filtered_tiles,dtype='object'))","a843663c":"# make sure to load using allow_pickle\nfil = np.load('.\/SN6_10_splits.npy', allow_pickle=True)\nfil[0][:5]","b6163a00":"As shown in figure below, odd tile numbers are adjacent with each other, and the same with even tiles","28e84895":"# Saving Filtered Tiles\nLet's make sure we don't leave out any tiles. Each stripe has different number of tiles, to make this the same size we could add a flag where it populates the next stripe when it reaches a certain number of tile, but it's something for another day","f7149a14":"# Load all tiles\n- Total of 3401 image tiles\n- Tile boundaries can be read using .geojson file for each image_id\n- we'll grab the tile's boundaries then create a POLYGON object containing coordinates for each corner\n- loop through all tiles and save into a geodataframe as .geojson file\n- when creating geodataframe, make sure we use the coordinate system (crs) used in this dataset","580acd62":"## Generate AOI Stripes\nwe'll divide the whole region with 10 stripes and split image_ids based on which AOI they are located in","e5791f7e":"# Previewing tiles","50a49ac9":"## Create AOI\nthe `.total_bounds` method calculates boundaries for the gdf. we can create a area of interest (AOI) with for example, the combined 3 odd tiles above (colored green), extended by 100 in all sides (colored blue)","b8f8dde9":"- compared using the cx method, this only grab tiles if they have half it's area in the ROI\n- returns less number of tiles, but ensures no tiles will be present in a nearby ROI","b9280ddc":"## Grab tiles for each AOI stripe\n`filter_tile` basically does all done in previous section. It returns the image_id of each tile contained in each AOI stripe which will be stored in `filtered_tiles`. In figure below we can see each AOI stripe in gray, and tiles are colored based on it's stripe","7c4d18f0":"# Strategy\n- I'm not sure if this is the best approach, but it worked for me\n- Tiles have lots of overlap between each other, making it difficult to split data for training and validation\n- My strategy is to create 10 splitting area over the region, and grab image_ids that have minimum of 50.1% intersection withing that region\n- This way, no tile will be present in multiple splits. 10 splits can also be used for cross-validation training","5e7bb11f":"# Selecting tiles","b5808f59":"later on, I found out there's a `box` function from shapely that creates a box polygon very easily. the `*` operator is to unpack the list and feed as input to `box` function","807ed963":"As shown in table above, tiles completely within the ROI should show 100% in `Per_Area` column, while tiles with some portion inside the ROI should show the percentage of its intersection","0401bc5f":"### Creating geojson of all boundaries\n- I anticipated adding mode options, but I think the tile boundaries are the same for each mode\n- This takes a while to process since it basicall loads all 3401 raster only to take the boundary information","b7c0ed76":"## Using percentage of remaining area\n- overlay clips tiles, but the ones included remains with smaller tile area.\n- assuming all tiles have the same sq area, percentage of remaining area can be calculated by comparing with the max area\n- when filtering tiles with >99 % remaining area, it does guarentee no tiles overlap to another AOI stripe, but it removes most of the tiles valuable as training data\n- if filtering with >50.1% remaining area, that tile should meet the minimum amount to be inside one AOI stripe, and excluded from the next stripe","19cfc122":"## Clipping method\n- overlay clips the tiles, while cx returns all that touches the given area [[source](https:\/\/gis.stackexchange.com\/questions\/266730\/filter-by-bounding-box-in-geopandas)]\n- both returns the same number of tiles\n- but how do we select tiles that intersects for a given area of overlap?"}}