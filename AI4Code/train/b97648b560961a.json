{"cell_type":{"da4478a9":"code","443b26f8":"code","44db98f2":"code","75152f7a":"code","c29a511e":"code","4713692c":"code","177bb2de":"code","7e6da8a3":"code","774fa99c":"code","38ee8b00":"code","258f2cc4":"code","3505c5ff":"code","b56a2f6e":"code","f266234b":"code","5f67fba8":"code","e1842f03":"code","d3d4d75d":"code","e224c0d9":"code","49bee377":"code","b405251f":"code","5510e260":"code","f1688cbc":"code","dc3a6baa":"code","f43bdfc6":"code","f9f9a6ae":"code","7814b2a5":"code","df00fa35":"code","894a6f4d":"code","dfa5612d":"code","7e4fce3f":"code","00ca5d97":"code","b8611508":"code","0634a86c":"code","b9973c87":"code","23e34295":"code","a51ece89":"code","2b21751b":"code","74d36417":"code","6c09e2f2":"code","dafaf7ce":"code","c95ffdf6":"code","b5941cd0":"code","3d66e76b":"code","2d3a371b":"code","087bbfcf":"code","dd934ed5":"code","1a845b3a":"code","ac2b2a7a":"code","9787fa87":"code","d4eab481":"code","ca859f12":"code","d4be2eab":"code","734e857e":"code","c3c97a32":"code","b721e051":"code","af2ee1f7":"code","0b1f701a":"code","e831cafe":"code","f6b6fe9c":"code","a51d3cea":"code","eb078be4":"code","0a7081b5":"code","6e8d0797":"code","4f33ceba":"code","39ea316e":"code","5e29eb8d":"code","7270ccaf":"code","976f1204":"code","c9ca678b":"code","557947b1":"code","f163c284":"markdown","41797512":"markdown","9e666299":"markdown","ff30ab3c":"markdown","75e6d241":"markdown","fd3a582e":"markdown","6c6e1522":"markdown","2e328d18":"markdown","a04480af":"markdown","6c441c79":"markdown","a525950c":"markdown","1718e53e":"markdown","71822643":"markdown","a55438c6":"markdown","4715a7db":"markdown","4f533c40":"markdown","4fdde2cd":"markdown","f049e5c2":"markdown","a747f0a6":"markdown","77ab15d1":"markdown","5123915c":"markdown","b7f3b682":"markdown","b5fc21f4":"markdown","2d475dac":"markdown","516a4b1c":"markdown","83e7dd26":"markdown","60b822b9":"markdown","f6b42991":"markdown","76b12940":"markdown"},"source":{"da4478a9":"# Importing Useful Libraries\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')\n%matplotlib inline","443b26f8":"df_train = pd.read_csv('\/kaggle\/input\/mobile-price-classification\/train.csv')\ndf_test = pd.read_csv('\/kaggle\/input\/mobile-price-classification\/test.csv')\ndf_train.head(3).transpose()","44db98f2":"df_test.head()","75152f7a":"print('Train set shape ->', df_train.shape)\nprint('Test set shape ->', df_test.shape)","c29a511e":"df_train.describe().transpose()","4713692c":"df_train.info()","177bb2de":"# Checking NaN value in the dataset\ndf_train.isnull().sum()","7e6da8a3":"# Let's Find out how many categories of Price Range\nsns.countplot(x = 'price_range' , data = df_train)\nplt.show()","774fa99c":"# Let's checck the Distribution of the data and Relationship between the Predictors\n\nsns.pairplot(df_train , hue = 'price_range' , diag_kind= 'kde')\nplt.show()","38ee8b00":"sns.pairplot(df_train , diag_kind = 'kde')\nplt.show()","258f2cc4":"sns.distplot(df_train['ram'])\nplt.show()","3505c5ff":"sns.histplot(df_train , x = 'ram' , hue = 'price_range' , kde = True)\nplt.show()","b56a2f6e":"sns.histplot(df_train , x = 'ram' , hue = 'price_range' , multiple = 'dodge')\nplt.show()","f266234b":"sns.boxplot(x = 'price_range' , y = 'ram' , data = df_train)\nplt.show()","5f67fba8":"from statsmodels.stats.oneway import anova_oneway\n\nresult = anova_oneway(df_train['ram'] , groups= df_train['price_range'] , use_var='bf')\nresult","e1842f03":"sns.displot( x = 'int_memory' , data = df_train , kind = 'kde')\nplt.show()","d3d4d75d":"sns.histplot(df_train , x = 'int_memory' , hue = 'price_range' , multiple = 'dodge')\nplt.show()","e224c0d9":"sns.histplot(df_train , x = 'int_memory' , hue = 'price_range' , kde = True , multiple = 'dodge')\nplt.show()","49bee377":"sns.boxplot(data = df_train , x = 'price_range' , y = 'int_memory')\nplt.show()","b405251f":"# let's see the scatter plot of the int_memory and the ram\nplt.figure(figsize=(12,8))\nsns.scatterplot(data = df_train , x = 'ram' , y = 'int_memory' , hue = 'price_range')\nplt.show()","5510e260":"from mpl_toolkits import mplot3d\n\nfig = plt.figure(figsize=(15 , 10))\nax = plt.axes(projection = '3d')\n\nax.scatter(df_train['battery_power'] , df_train['ram'] , df_train['int_memory'] , c = df_train['price_range'])\nax.set_xlabel('Battery Power')\nax.set_ylabel('Ram')\nax.set_zlabel('Internal Memory')\nax.legend()\nplt.show()","f1688cbc":"sns.distplot(df_train['fc'])\nplt.show()","dc3a6baa":"sns.boxplot(x = 'price_range' , y = 'fc' , data = df_train)\nplt.show()","f43bdfc6":"from sklearn.cluster import KMeans\nfrom sklearn import metrics\nfrom scipy.spatial.distance import cdist\n\n\n\ndf = df_train.drop('price_range',axis = 1)\n\ndistortions = []\ninertias = []\nmapping1 = {}\nmapping2 = {}\nK = range(1, 10)\n \nfor k in K:\n    # Building and fitting the model\n    kmeanModel = KMeans(n_clusters=k).fit(df)\n    kmeanModel.fit(df)\n \n    distortions.append(sum(np.min(cdist(df, kmeanModel.cluster_centers_,\n                                        'euclidean'), axis=1)) \/ df.shape[0])\n    inertias.append(kmeanModel.inertia_)\n \n    mapping1[k] = sum(np.min(cdist(df, kmeanModel.cluster_centers_,\n                                   'euclidean'), axis=1)) \/ df.shape[0]\n    mapping2[k] = kmeanModel.inertia_","f9f9a6ae":"for key, val in mapping1.items():\n    print(f'{key} : {val}')","7814b2a5":"plt.plot(K, distortions, 'bx-')\nplt.xlabel('Values of K')\nplt.ylabel('Distortion')\nplt.title('The Elbow Method using Distortion')\nplt.show()","df00fa35":"# Let's find out the Correlation between columns\n\ncor = df_train.corr()","894a6f4d":"cor","dfa5612d":"cor.style.background_gradient(cmap = 'coolwarm').set_precision(2)","7e4fce3f":"sns.lmplot(x = 'pc' , y = 'fc' , data = df_train , hue = 'price_range')\nplt.show()","00ca5d97":"plt.figure(figsize = (12,8))\n\nplt.subplot(121)\nsns.histplot(data = df_train, x = 'pc' , hue = 'price_range' , kde = True , multiple = 'dodge')\nplt.subplot(122)\nsns.histplot(data = df_train , x = 'fc' , hue = 'price_range' , kde =True , multiple = 'dodge')\nplt.tight_layout()\nplt.show()","b8611508":"plt.subplot(121)\nsns.boxplot(x = 'price_range' , y = 'fc' , data = df_train)\nplt.subplot(122)\nsns.boxplot(x = 'price_range' , y = 'pc' , data = df_train)\nplt.tight_layout()\nplt.show()","0634a86c":"df_train ['total_mp'] = df_train['pc'] + df_train['fc']\ndf_train.head(1)","b9973c87":"# Now lets see the distribution\n\nsns.distplot(df_train['total_mp'])\nplt.show()","23e34295":"sns.boxplot(x = 'price_range' , y = 'total_mp' ,  data = df_train)\nplt.show()","a51ece89":"sns.lmplot(x = 'total_mp' , y = 'fc' , data = df_train , hue = 'price_range')\nplt.show()","2b21751b":"sns.lmplot(x = 'total_mp' , y = 'pc' , data = df_train , hue = 'price_range')\nplt.show()","74d36417":"sns.histplot(data = df_train , x = 'total_mp' , hue = 'price_range'  , kde = True , multiple = 'dodge')\nplt.show()","6c09e2f2":"sns.countplot(df_train['three_g'])\nplt.show()","dafaf7ce":"sns.countplot(df_train['four_g'])\nplt.show()","c95ffdf6":"sns.lmplot(x = 'three_g' , y = 'price_range' , data = df_train)\nplt.show()","b5941cd0":"sns.lmplot(x = 'four_g' , y = 'price_range' , data = df_train)\nplt.show()","3d66e76b":"# Let's Combine the Two columns\n\n#df_train['sim_setting'] = df_train['three_g'].cat(df_train['four_g'] , sep = '_')\ndf_train['sim_setting'] = df_train[['three_g' , 'four_g']].astype('str').apply(lambda x : '_'.join(x) , axis = 1)\ndf_train.head()","2d3a371b":"sns.countplot(df_train['sim_setting'])\nplt.show()","087bbfcf":"pd.pivot_table(df_train , index = ['sim_setting'] , columns = ['price_range'] , aggfunc= 'count').T","dd934ed5":"sns.countplot(x = 'sim_setting' , hue = 'price_range' , data = df_train)\nplt.show()","1a845b3a":"# First let's test the \"Mean\" of the \"sc_h\"  & \"px_height\" whether Mean is same or different\n# To do that we be using t-Test Hypothesis,\n# The Null Hypothesis is that \"the Mean of both Columns are Same\"\n# The Alternate Hypothesis will be that \" they are not the same\"\nfrom  scipy.stats import ttest_rel\n\nstats , p_value = ttest_rel(df_train['sc_h'] , df_train['px_height'])\n\nprint('p-value of the Paired t-Test of sc_h  , px_height ->>' , p_value)","ac2b2a7a":"stats ,  P_value = ttest_rel(df_train['sc_w'] , df_train['px_width'])\nprint('p-value of the Paired t-Test of sc_h  , px_height ->>' , p_value)","9787fa87":"# we will be using \"One way ANOVA\" hypothesis\nfrom statsmodels.stats.oneway import anova_oneway\n\nresult  = anova_oneway( df_train['px_width'], groups = df_train['price_range'], use_var= 'bf')","d4eab481":"result","ca859f12":"sns.histplot(data = df_train , x = 'px_width' ,hue =  'price_range' , multiple = 'dodge')\nplt.show()","d4be2eab":"sns.histplot(data = df_train, x = 'px_width' , hue = 'price_range' , multiple = 'dodge' , kde = True)\nplt.show()","734e857e":"result  = anova_oneway( df_train['px_height'], groups = df_train['price_range'], use_var= 'bf')\nresult","c3c97a32":"plt.figure(figsize=(10,8))\nsns.histplot(df_train , x = 'px_height' , hue = 'price_range' , multiple= 'dodge')\nplt.show()","b721e051":"sns.histplot(data = df_train , x = 'px_height' , hue = 'price_range' , kde = True , multiple = 'dodge')\nplt.show()","af2ee1f7":"df_train['resolution'] = df_train['px_width'] + df_train['px_height']\ndf_train.head()","0b1f701a":"result = anova_oneway(df_train['resolution'] , groups= df_train['price_range'] , use_var= 'bf')\nresult","e831cafe":"plt.figure(figsize = (10, 8))\nsns.histplot(data = df_train ,  x = 'resolution' , hue = 'price_range' , kde = True , multiple = 'dodge')\nplt.show()","f6b6fe9c":"# Mobile Height\nanova_oneway(df_train['sc_h'] , groups = df_train['price_range'] , use_var= 'bf')","a51d3cea":"# Mobile weight\nanova_oneway(df_train['sc_w'] , groups = df_train['price_range'] , use_var= 'bf')","eb078be4":"# Mobile depth\nanova_oneway(df_train['m_dep'] , groups = df_train['price_range'] , use_var = 'bf')","0a7081b5":"# Mobile weight\nanova_oneway(df_train['mobile_wt'] , groups = df_train['price_range'] , use_var = 'bf')","6e8d0797":"# Distribution of weight of the mobile\nplt.figure(figsize = (12,8))\nsns.histplot(data = df_train , x = 'mobile_wt' , hue = 'price_range' , kde = True , multiple = 'dodge')\nplt.show()","4f33ceba":"# Let's Find out the volume of the mobile \n\ndf_train['volume'] = df_train['sc_h'] * df_train['sc_w'] * df_train['mobile_wt']\ndf_train.head()","39ea316e":"# Let's see the mean and p-value of the \"Volume\" column\n\nanova_oneway(df_train['volume'] , groups = df_train['price_range'] , use_var= 'bf')","5e29eb8d":"# Let's find out the volume\/weight of the Mobile\ndf_train['density'] = round(df_train['volume'] \/ df_train['mobile_wt'])\ndf_train.head()","7270ccaf":"# Now let's see the Mean and P-value of the density Column\nanova_oneway(df_train['density'] , groups = df_train['price_range'] , use_var='bf')","976f1204":"plt.figure(figsize=(12,8))\nsns.histplot(data = df_train , x = 'density' , hue = 'price_range' , kde = True , multiple = 'dodge') ","c9ca678b":"plt.figure(figsize=(12 , 8))\nsns.scatterplot(data = df_train , x = 'mobile_wt' , y = 'battery_power' , hue = 'price_range')\nplt.show()","557947b1":"df_train.head().T\n","f163c284":"The distribution of the Mobile weight columns ovarlaps each other in the groups","41797512":"## Let's see the \"FC\" column","9e666299":"Let's see how many classes with in the data itself Using `Kmeans`","ff30ab3c":"The `fc` Columns have distribution skewed to left, so first let's find out the distribution","75e6d241":"There is no relationship between Mobile weight and Battery Power","fd3a582e":"As we can see that the mean of column `ram` in the dataset in the `price_range` group Significate as the P-Value is `0` and from distribution of the Column we can conclude that the `ram` column devides data clearly in the Four Price range, So this column will be important in the classification process","6c6e1522":"Let's check the \"Mean\" values of these four columns whether their Mean together have some Significance","2e328d18":"**Let's First see the `pc` and `fc` Columns**","a04480af":"## Internal Memory","6c441c79":"**From the Correlation Co-efficient we can conclude following points.**\n1. `PC` (Prime Camera Mega pixel) and `FC` (Front camera Mega pixel are strongly corelated, we have to see how this is affecting `Price_range`\n2. `three_g` and `four_g` are also correlated that means when a Mobile has `3G` there is a probability that it also have `4G`, Now we have to find out how  having `3G` and `4G` connectivity together in the handset affect the price range\n3. `sc_h` (screen height) and `sc_w` (screen width) also have a strong correlation, that means when height increase width also increse. Also `px_height` (pixel height) and `px_width` (pixel width) have strong correlation and the value of correlation coefficient is same as in `sc_h` and `sc_w` so there might be possibility that four column might be correlate to each other that we will find out with the help of `VIF`\n","a525950c":"Let's See the distribution of the data in the dataset","1718e53e":"# Let's See the physical features of the mobile i.e \"sc_h\" , \"sc_w\" , \"m_dep\" , \"mobile_wt\"","71822643":"if you see the pair plot of the dataset along the Diagonally you will find the Distribution plot of the dataset You can see that only \"Ram\" Column Seperating Mobile price range to different classes, and every other data in ovelapping and also there is not normal distribution of data in dataset","a55438c6":"Let's also find out that whether Mobile's Weight and Battery power are related or not ","4715a7db":"After seeing the correlation between `sc_w` & `sc_h` and `px_width` & `px_height` it seems that the `sc_w` and `px_width` and `sc_h` & `px_height` varies together.\nSo, test some whether the these are true or not","4f533c40":"Let's add both the Column and create a seperate column called `total_mp`","4fdde2cd":"From the scatter plot we can say that there is not Relationship between the internal memory and ram","f049e5c2":"If we see the P-Value of the Columns `sc_h` , `sc_w` & `m_dep` in ANOVA Oneway Hypothesis test we found out that these 3 column's mean is not significantly different from the each other in `price_range` so, they cannot help in dividing the dataset in different price range","a747f0a6":"**Let's analyze the columns `sc_w` , `sc_h` , `px_width` , `px_height`**","77ab15d1":"As we can see that By `KMeans` The Elbow curve Sharply Decreases when value of K=2, That means data can be culster into 2 Group, i.e, It represents 2 Categories, But we have to Divide data into 4 categories","5123915c":"### ram","b7f3b682":"Now that P-Value for the mobile weight is 1% which is below the Significance Level and therefore the column `mobile_wt` can be an important column for the classification of mobile phones based on price ","b5fc21f4":"As we can see From distribution of the column `int_memory` that the Distribution overlap to each-other in and it cannot classify the data in the give price range","2d475dac":"As the Mean of the Column `sc_h` in the group of `price_range` is not significant as the P-value is 8% which is greater than significance level","516a4b1c":"## Let's the Hardware of the Mobile phones i.e \"Battery_power\", \"clock_speed\", \"int_memory\", \"n_cores\", \"ram\"","83e7dd26":"As we can see that the P-Value is of the both Paired test is `0.0` which is less than significance level, Hence we reject the Null Hypothesis that the \"Mean\" values are not same","60b822b9":"As you can see, the sim Configuaration do not have a much more affect on the price range. Though if `Mobile` has No `3G` or `4G` it's more likely to be in `0` Price range, If a Mobile have Only `3G` Sim confi. it more likely to come under the `2` Price range and If a Mobile Has Both `3G` & `4G` confi. It more likly to come Under `3` Price range then Others, Though the Number is not that significant.","f6b42991":"**Let's see the `four_g` and `three_g` Column**","76b12940":"# Mobile Price Classifications"}}