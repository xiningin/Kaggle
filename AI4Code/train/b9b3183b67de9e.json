{"cell_type":{"e98861b4":"code","a4e7083f":"code","e78cdc8f":"code","e45d3da2":"code","54ba5eca":"code","0f73faaf":"code","4490b576":"code","1668290c":"code","ce17924b":"code","55a7b5ad":"markdown","8c0edde8":"markdown","549f0213":"markdown","9ecc3b29":"markdown","61c0c5a6":"markdown","2604f1a6":"markdown","6d7f0c29":"markdown","bce5b83a":"markdown","982f7173":"markdown","c6cd8793":"markdown","2dd14cc1":"markdown","1ea86162":"markdown","0d7d7059":"markdown","00eb0331":"markdown","2743b6ae":"markdown","c44f0b47":"markdown","bf6894fe":"markdown","d577c9ed":"markdown","0d1127b7":"markdown","d5ce4187":"markdown"},"source":{"e98861b4":"from __future__ import absolute_import, division, print_function\nimport tensorflow as tf\ntf.logging.set_verbosity(tf.logging.ERROR)\n\nimport numpy as np","a4e7083f":"celsius_q    = np.array([-40, -10,  0,  8, 15, 22,  38],  dtype=float)\nfahrenheit_a = np.array([-40,  14, 32, 46, 59, 72, 100],  dtype=float)\n\nfor i,c in enumerate(celsius_q):\n  print(\"{} degrees Celsius = {} degrees Fahrenhet\".format(c, fahrenheit_a[i]))","e78cdc8f":"l0 = tf.keras.layers.Dense(units=1, input_shape=[1]) ","e45d3da2":"model = tf.keras.Sequential([l0])","54ba5eca":"model.compile(loss='mean_squared_error',\n              optimizer=tf.keras.optimizers.Adam(0.1))","0f73faaf":"history = model.fit(celsius_q, fahrenheit_a, epochs=500, verbose=False)\nprint(\"Finished training the model\")","4490b576":"print(model.predict([100.0]))","1668290c":"print(\"These are the layer variables: {}\".format(l0.get_weights()))","ce17924b":"l0 = tf.keras.layers.Dense(units=4, input_shape=[1])  \nl1 = tf.keras.layers.Dense(units=4)  \nl2 = tf.keras.layers.Dense(units=1)  \nmodel = tf.keras.Sequential([l0, l1, l2])\nmodel.compile(loss='mean_squared_error', optimizer=tf.keras.optimizers.Adam(0.1))\nmodel.fit(celsius_q, fahrenheit_a, epochs=500, verbose=False)\nprint(\"Finished training the model\")\nprint(model.predict([100.0]))\nprint(\"Model predicts that 100 degrees Celsius is: {} degrees Fahrenheit\".format(model.predict([100.0])))\nprint(\"These are the l0 variables: {}\".format(l0.get_weights()))\nprint(\"These are the l1 variables: {}\".format(l1.get_weights()))\nprint(\"These are the l2 variables: {}\".format(l2.get_weights()))","55a7b5ad":"## Compile the model, with loss and optimizer functions\n\nAfter defining and before training, the model has to be compiled. \n\nOnce compiled for the training, the model is given:\n\n- **Loss function** : A way to measure the distance between forecasts and the desired result. (The measured difference is called \"loss\").\n\n- **Optimizer function** :  A way of adjusting internal values in order to minimize the loss.","8c0edde8":"# The Basics: Training Your First Model\n","549f0213":"import matplotlib.pyplot as plt\nplt.xlabel('Epoch Number')\nplt.ylabel(\"Loss Magnitude\")\nplt.plot(history.history['loss'])","9ecc3b29":"The correct answer is $100 \\times 1.8 + 32 = 212$. So our model is doing really well.\n\n### To review\n\n\n*   We created a model with a Dense layer (Only One Layer )\n*   We trained it with 3500 (7*500) examples (with : 7 pairs, over 500 epochs).\n\nOur model modified the variables (weight) of the dense layer until it was able to return the correct Fahrenheit value to any Celius value. (Remember that 100 \u00b0 C was not part of our training data, it can be called a Test dataset ).\n","61c0c5a6":"These are used during training (`model.fit()`)  to first calculate the loss at each point, and then improve it. \n\nDuring training, the optimizer function is used to calculate adjustments to the model's internal variables. The goal is to adjust the internal variables until the model (which is really a math function) mirrors the actual equation for converting Celsius to Fahrenheit.\n\nWhat is useful to know about these parameters are:\n\nThe loss function ([mean squared error](https:\/\/en.wikipedia.org\/wiki\/Mean_squared_error)) and the optimizer ([Adam](https:\/\/machinelearningmastery.com\/adam-optimization-algorithm-for-deep-learning\/)) used here are standard for simple models like this one, but many others are available. It is not important to know how these specific functions work at this point.\n\n**Note Very Important** : One  part of the Optimizer you may need to think about when building your own models is the learnign rate (`0.1` in the code above). This is the step size taken when adjusting values in the model. If the value is too small, it will take too many iterations to train the model. Too large, and accuracy goes down. Finding a good value often involves some trial and error, but the range is usually within 0.001 (default), and 0.1","2604f1a6":"## Looking at the layer weights\n\nFinally, let's print the internal variables of the Dense layer using the `get_weights()` method. ","6d7f0c29":"## Train the model\n\nTrain the model by calling the ***`fit`***    method. \n\nDuring training, the model takes the Input Data :  values in degrees Celsius, performs a calculation using the current internal variables (called \"**weights**\"), and generates values  that are supposed to be the equivalent in Fahrenheit. \n\nSince the weights are initially randomly defined, the output will not be close to the correct value. The difference between the actual output and the desired output is calculated using the loss function (mean squared error), and the optimization function indicates how the weights should be adjusted. \n\nThis cycle is controlled by calculation, comparison and modification in a `fit` method. The first argument is the input data, and the second argument is the desired output. The `epochs` argument specifies the number of times this session should be run, and the verbose modulus controls the amount of output produced by the method.","bce5b83a":"**Note**\n\nWe can define our layers inside the model definition as shown below : \n\n```python\nmodel = tf.keras.Sequential([\n  tf.keras.layers.Dense(units=1, input_shape=[1])\n])\n```","982f7173":"## Use the model to predict values\n\nNow we  have a model that has been trained to detect  the relationshop between `celsius_q` and `fahrenheit_a`. \n\nSo we can use the prediction method to make it calculate degrees Fahrenheit to previously unknown degrees.\n\nSo, for example, if the Celsius value is 100, what do you think the Fahrenheit result will be? (Take a guess before you run this following code ) ","c6cd8793":"## Create the model\n\nNow we will create the model. We will use the simplest  model  called  ***Dense network*** : This kind of model will require only a single layer, with a single neuron ( Since the problem is so simple )\n\n### Build a layer : `l0`\n\nWe'll call the layer `l0` and create it by this function  `tf.keras.layers.Dense` with the following configuration:\n\n*   `input_shape=[1]` : This specifies that the entry in this layer is a single value. That is, the shape is a one-dimensional array with a member. Since this is the first (and only) layer, this input form is the input form of the entire model. The unique value is a floating point number representing degrees Celsius.\n\n*   `units=1` : This determines the number of neurons in the class. The number of neurons determines how many internal variables the class should attempt to learn how to solve the problem (later). Since this is the last layer, it is also the output size of the model: a single float value that represents a degree of Fahrenheit.","2dd14cc1":"\nWelcome to this *Kernel* where you will train your first Machine Learning model. We will try to keep things simpler here, and we will only provide basic concepts.\n\nThe problem we will solve is to convert from Celsius to Fahrenheit, where the approximate formula is:\n\n $$ F = C\\times 1.8 + 32 $$\n\n**Notice:** it would be simple enough to create a simple Python function that directly performs this calculation (Traditional Software Development):\n```\ndef FtoC(C):\n    F = C*1.8 + 32\n  return F\n```\nbut that wouldn't be machine learning. The main goal of this Notebook is show the main difference between the tow approachs : ML & Traditional Software Development ( you can find more in this [link](https:\/\/www.facebook.com\/timopyr\/posts\/549152712236919))\n\n**Let's start** : So for build our Ml's model, we will give ***TensorFlow*** some sample Celsius values (0, 8, 15, 22, 38) ( called **Input Data**) and their corresponding Fahrenheit values (32, 46, 59, 72, 100) (Called **Output Data**).\n\nThen, we will train ( with the **Training Dataset** ) a model that figures out the above formula through the training process.\n","1ea86162":"<table class=\"tfo-notebook-buttons\" align=\"left\">\n  <td>\n    <a target=\"_blank\" href=\"https:\/\/www.linkedin.com\/in\/thamer-saraei-472300124\/\"><img src=\"http:\/\/icons.iconarchive.com\/icons\/limav\/flat-gradient-social\/32\/Linkedin-icon.png\" \/>Join me <\/a>\n  <\/td>\n  <td>\n    <a target=\"_blank\" href=\"https:\/\/www.youtube.com\/channel\/UC8Dt8pO_EqhP9unfnMd-64A?view_as=subscriber\"><img src=\"http:\/\/icons.iconarchive.com\/icons\/emey87\/social-button\/32\/youtube-icon.png\" \/>Join me <\/a>\n  <\/td>\n  <td>\n    <a target=\"_blank\" href=\"https:\/\/www.facebook.com\/timopyr\/\"><img src=\"https:\/\/cdn.icon-icons.com\/icons2\/642\/PNG\/64\/facebook_icon-icons.com_59205.png\" \/>Join me<\/a>\n  <\/td>\n<\/table>","0d7d7059":"## Import Packages \n\nFirst and to keep things so simple, we import **[TensorFlow](https:\/\/www.tensorflow.org\/)** as `tf` for ease of use. \n\nNext, import [NumPy](http:\/\/www.numpy.org\/) as `np` : Numpy helps us to represent our data as highly performant lists.","00eb0331":"As we can see, this model is also able to predict the corresponding Fahrenheit value really well. But when you look at the variables (weights) in the `l0` and `l1` layers, they are nothing even close to ~1.8 and ~32. **The added complexity hides the \"simple\" form of the conversion equation.**","2743b6ae":"**Thanks for your attention **\n\nI wish that you enjoyed this Notebook. ","c44f0b47":"The first variable is close to 1.8 and the second to 32. These values (1.8 and 32) are the actual variables in the real conversion formula.\n\nSince the form is the same, the variables should converge on the standard values of 1.8 and 32, which is exactly what happened.\n\nWith additional neurons, additional inputs, and additional outputs, the formula becomes much more complex, but the idea is the same. \n\nJust for fun, what if we created more Dense layers with different units, which therefore also has more variables? (Show below )","bf6894fe":"## Display training statistics\n\nThe `fit` method returns a history object. We can use this object to plot how the loss of our model goes down after each training epoch. \n\n***P.S :***  A high loss means that the Fahrenheit degrees the model predicts is far from the corresponding value in `fahrenheit_a`. \n\nWe'll use [Matplotlib](https:\/\/matplotlib.org\/) to visualize this .\n\n***As we can see, our model improves very quickly at the beginning, then progresses slowly and gradually until it is almost \"perfect\" towards the end. **\n","d577c9ed":"### Assemble layers into the model\n\nAfter defined our layers, we need to group these layers to create the model. The ***Sequential model *** definition takes a list of layers as argument, specifying the calculation order from the input to the output.\n\nThis model has just a single layer, \n`l0\n`","0d1127b7":"## Set up training data\n\nAs we knew, [supervised machine learning](https:\/\/machinelearningmastery.com\/supervised-and-unsupervised-machine-learning-algorithms\/) essentially consists of looking for a performance algorithm from a set of **inputs and outputs**.\n\nAs the objective of this Codelab is to create a model that can convert temperature in degrees Fahrenhet to degrees Celsius, we should create two lists *celsius_q* and *fahrenheit_a* that we can use to build our model.","d5ce4187":"### Some *IMPORTANT* Machine Learning terminology\n\n - **Feature** : The inputs to our model. In our case, a single value : the degrees in Celsius.\n\n - **Labels** : The output of our model predicts. In our case, a single value : the degrees in Fahrenhet.\n \n - **Example** : A pair of inputs\/outputs used during training. In our case a pair of values from `celsius_q` and `fahrenhet_a` to a particular pointer, such as`(38,100)`.\n"}}