{"cell_type":{"a2d29c99":"code","4d7e259b":"code","72aa79c5":"code","9f0435ef":"code","7047138b":"code","c07cc972":"code","853955ae":"code","4108dc4f":"code","5c032e1d":"code","aebe6522":"code","357faae2":"code","fe1a9083":"code","b602d7c5":"code","c07142ff":"code","375ff5a3":"code","0c440d13":"code","3ff98876":"code","6ffc15a9":"code","6a2c2569":"code","4eb43bae":"code","85ec209f":"code","8e0bf539":"code","64dd32fb":"code","31ef1b9e":"code","4743d558":"code","440ef942":"code","0d98f7ea":"code","02a67a72":"markdown","7c9f3071":"markdown","dd82232f":"markdown","bd885d47":"markdown","5e8dfac2":"markdown","b4322db4":"markdown","c4f847cf":"markdown","342ad916":"markdown","c71b0a86":"markdown","bdbf1eb6":"markdown"},"source":{"a2d29c99":"#importing basic libraries\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nimport warnings\nwarnings.filterwarnings('ignore')","4d7e259b":"#loading the dataset\ndf = pd.read_csv('..\/input\/creditcardfraud\/creditcard.csv')","72aa79c5":"df.head()","9f0435ef":"df.shape","7047138b":"#concise summary of the dataset\ndf.info()","c07cc972":"#descriptive statistics of the dataset\ndf.describe().T","853955ae":"# checking for null values\ndf.isna().sum()","4108dc4f":"fig = sns.countplot(x = 'Class', data = df)\nfig.set_xticklabels(labels=['Not Fraud', 'Fraud'], rotation=0);","5c032e1d":"#visualizing in pie chart\nlabels = 'Not Fraud', 'Fraud'\nexplode = (0, 0.2)\n\nfig1, ax1 = plt.subplots()\nax1.pie(df['Class'].value_counts(), explode=explode, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=60)\nax1.axis('equal')\nplt.show()","aebe6522":"#distribution plot for 'Amount' w.r.t 'Time'\nsns.displot(x = 'Time', y = 'Amount', data = df, color = 'orange')\nplt.title('Distribution plot for Amount w.r.t Time');","357faae2":"# kdeplot for not frauds class\nsns.displot(x = 'Amount', data=df[df.Class == 0], kind = 'kde')\nplt.title(\"kdeplot for not Fraud class\");","fe1a9083":"# kdeplot for frauds class \nsns.displot(x = 'Amount', data=df[df.Class == 1], kind = 'kde', color = 'Orange')\nplt.title(\"kdeplot for Fraud class\");","b602d7c5":"sns.boxplot(x=\"Class\", y=\"Amount\", hue=\"Class\",data = df, palette=\"PRGn\",showfliers=False);","c07142ff":"#plotting the values for fraud class\nplt.scatter(df.Time[df.Class == 1], \n            df.Amount[df.Class == 1], \n            marker = '^',\n            c = \"salmon\")\nplt.xlabel('Time')\nplt.ylabel('Amount');","375ff5a3":"#plotting the values for not fraud class\nplt.scatter(df.Time[df.Class==0], \n            df.Amount[df.Class==0],\n            marker = '>',\n            c=\"lightgreen\")\nplt.xlabel('Time')\nplt.ylabel('Amount');","0c440d13":"column_names = list(df.columns.values)\nfrauds = df[df['Class'] == 1]\nno_frauds = df[df['Class'] == 0]\n\nplt.figure()\nfig, ax = plt.subplots(8,4,figsize=(16,28))\ni = 0\nfor feature in column_names:\n    i += 1\n    plt.subplot(8,4,i)\n    sns.kdeplot(frauds[feature])\n    sns.kdeplot(no_frauds[feature])\n    plt.xlabel(feature, fontsize=10)\n    locs, labels = plt.xticks()\n    plt.tick_params(axis='both', which='major', labelsize=12)\nplt.show();","3ff98876":"# correlation\ncorrelation_matrix = df.corr()\nplt.figure(figsize=(15, 10))\nsns.heatmap(correlation_matrix, \n            annot=False, \n            linewidths=0.5, \n            fmt= \".2f\", \n            cmap=\"YlGnBu\");","6ffc15a9":"# creating independent and dependent matrix of features\nx = df.drop('Class', axis = 1)\ny = df['Class']","6a2c2569":"x.head()","4eb43bae":"# creating training and test sets\nfrom sklearn.model_selection import train_test_split\nx_train,x_test,y_train,y_test = train_test_split(x,y, test_size = 0.10, random_state = 31)","85ec209f":"len(x_train), len(x_test), len(y_train), len(y_test)","8e0bf539":"%%time\nfrom imblearn.combine import SMOTEENN \n\nsme = SMOTEENN(random_state=42)\nx_somteenn, y_somteenn = sme.fit_resample(x_train, y_train)","64dd32fb":"labels = 'Not Fraud', 'Fraud'\nexplode = (0, 0)\n\nfig1, ax1 = plt.subplots()\nax1.pie(y_somteenn.value_counts(), explode=explode, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=60)\nax1.axis('equal')\nplt.show()","31ef1b9e":"%%time\nfrom sklearn.ensemble import RandomForestClassifier\n\nrand_clf = RandomForestClassifier(n_estimators=1000, random_state = 35)\nrand_clf.fit(x_train, y_train)\nranf_score = rand_clf.score(x_test, y_test)\nranf_score","4743d558":"# classification report\nfrom sklearn.metrics import classification_report\ny_preds = rand_clf.predict(x_test)\nprint(classification_report(y_test, y_preds))","440ef942":"# confusion matrix\nfrom sklearn.metrics import plot_confusion_matrix\nplot_confusion_matrix(rand_clf, x_test, y_test,\n                     cmap=plt.cm.Blues);","0d98f7ea":"# ROC curve\nfrom sklearn.metrics import plot_roc_curve\nplot_roc_curve(rand_clf, x_test, y_test)\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('Receiver Operating Characteristic Curve');","02a67a72":"### If you find this notebook useful, consider upvotting. Thanks","7c9f3071":"# Modeling","dd82232f":"Hello!\n\nIn this notebook I will make a simple model with very high **accuracy**, **precision** and **F1-score** for detecting frauds. People often use very complex algorithms in this dataset but while experimenting I found out a simple model like this do quite well. It saves both time and computation cost.","bd885d47":"counting number of samples in each class","5e8dfac2":"# Evaluation","b4322db4":"**This dataset is severly imbalanced. We will take care of this before training**","c4f847cf":"Let's apply **SMOTEENN** on train set.\n\nSMOTEENN does Over-sampling using SMOTE and clean noise samples using ENN.","342ad916":"# Modeling","c71b0a86":"Great! We don't have any null values","bdbf1eb6":"# EDA"}}