{"cell_type":{"09ffec8f":"code","aa36abb8":"code","17d20ae5":"code","ac606002":"code","8eb4f76f":"code","23fec19a":"code","bdc05e01":"code","2fc77073":"code","446872ee":"code","a0ea47f9":"code","675b5ee2":"code","10d84a0f":"code","4aed5c2f":"code","4cb05e07":"code","a8da56f9":"code","1e00f96e":"code","5d3bf28c":"code","1c563714":"code","d8174a86":"code","977b59b7":"code","5136ccf5":"code","1a74223f":"code","c7789d90":"code","7310e755":"code","435cb8b3":"code","a530793b":"code","823ac5f3":"code","45cf0ab3":"code","23f8cbe7":"code","0314baa2":"code","d13e5648":"code","84fa8110":"code","510f048b":"code","c6d49913":"code","2183df42":"markdown","907cac59":"markdown","90eecbfe":"markdown","259ac77c":"markdown","dd6350c3":"markdown","2414cb1d":"markdown","73801569":"markdown","ad103c59":"markdown","1f713894":"markdown","807d640b":"markdown","e57bd2cf":"markdown","01ef769f":"markdown","60160f82":"markdown","97d502d2":"markdown","0ff2f538":"markdown","f2b85d76":"markdown","60b3478c":"markdown","da8fbcd4":"markdown","14ac62ff":"markdown","f63bc837":"markdown","b5f98299":"markdown","fc7cc371":"markdown"},"source":{"09ffec8f":"!# Download models\n!git clone --depth 1 https:\/\/github.com\/tensorflow\/models\n\n!# Compile proto files \n! # sudo apt install -y protobuf-compiler # Already present\n%cd models\/research\n!protoc object_detection\/protos\/*.proto --python_out=.\n%cd ..\n%cd ..\n\n!# Install cocoapi\n!pip install cython \n!git clone https:\/\/github.com\/cocodataset\/cocoapi.git\n%cd cocoapi\/PythonAPI\n!make\n%cd ..\n%cd ..\n!cp -r cocoapi\/PythonAPI\/pycocotools models\/research\/\n\n!# Install object detection api\n%cd models\/research\n!cp object_detection\/packages\/tf2\/setup.py .\n!python -m pip install .\n%cd ..\n%cd ..","aa36abb8":"!pip install tensorflow_io\n!pip install ensemble-boxes","17d20ae5":"import os\nimport pandas as pd\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom ensemble_boxes import *\nfrom tqdm.notebook import tqdm\n\nimport pydicom\nfrom pydicom.tag import Tag\n\nimport tensorflow as tf\nimport tensorflow_io as tfio\n\nfrom object_detection.protos.string_int_label_map_pb2 import StringIntLabelMap, StringIntLabelMapItem\nfrom object_detection.dataset_tools import tf_record_creation_util\nfrom object_detection.utils import dataset_util\nimport contextlib2\n\nfrom google.protobuf import text_format","ac606002":"# Reading dataset of annotations\npath = \"..\/input\/vinbigdata-chest-xray-abnormalities-detection\"\ndf = pd.read_csv(os.path.join(path, \"train.csv\"))","8eb4f76f":"# Reading DICOM images\ndef read_dicom(path, max_dim):\n    image_bytes = tf.io.read_file(path)\n    image = tfio.image.decode_dicom_image(\n        image_bytes, \n        dtype = tf.uint16\n    )\n    \n    image = tf.squeeze(image, axis = 0)\n    \n    h, w, _ = image.shape\n    \n    image = tf.image.resize(\n        image, \n        (max_dim, max_dim), \n        preserve_aspect_ratio = True\n    )\n    \n    image = image - tf.reduce_min(image)\n    image = image \/ tf.reduce_max(image)\n    image = tf.cast(image * 255, tf.uint8)\n    \n    return image, h, w","23fec19a":"temp = df[[\"image_id\", \"rad_id\"]].drop_duplicates().reset_index(drop = True)\ntemp = temp.groupby([\"rad_id\"]).agg(\n    count = pd.NamedAgg(\"image_id\", \"count\")\n).reset_index()","bdc05e01":"%matplotlib inline\n\nfig, ax = plt.subplots(1, 2, figsize = (15, 5))\n\nsns.countplot(\n    df[\"rad_id\"], \n    palette = \"tab10\", \n    order = list(temp[\"rad_id\"]), \n    ax = ax[0]\n)\nax[0].set_title(\"Number of annotations by radiologists\")\n\nsns.barplot(\n    x = \"rad_id\", \n    y = \"count\", \n    data = temp, \n    palette = \"tab10\", \n    ax = ax[1]\n)\nax[1].set_title(\"Number of x-rays seen by radiologists\")\n\nfig.show()","2fc77073":"temp = df[[\"image_id\", \"class_name\"]].drop_duplicates().reset_index(drop = True)\ntemp = temp.groupby([\"class_name\"]).agg(\n    count = pd.NamedAgg(\"image_id\", \"count\")\n).reset_index()","446872ee":"%matplotlib inline\n\nsns.barplot(\n    x = \"class_name\", \n    y = \"count\", \n    data = temp, \n    palette = \"tab10\"\n)\nplt.xticks(rotation = 90)\nplt.show()","a0ea47f9":"%matplotlib inline\n\nmax_dim = 500\ndemo_image = \"6d5acf3f8a973a26844d617fffe72998.dicom\"\nimage, h, w = read_dicom(os.path.join(path, \"train\", demo_image), max_dim)\n\nplt.figure(figsize = (5, 5))\nplt.imshow(tf.squeeze(image), 'gray')","675b5ee2":"def CLAHE(image):\n    clahe = cv2.createCLAHE(\n        clipLimit = 2., \n        tileGridSize = (10, 10)\n    )\n    \n    image = clahe.apply(image.numpy()) \n    image = tf.expand_dims(image, axis = 2)\n    \n    return image","10d84a0f":"%matplotlib inline\n\nfig = plt.figure(figsize = (8, 8))\n\naxes = fig.add_subplot(1, 2, 1)\nplt.imshow(tf.squeeze(image), cmap = \"gray\")\naxes.set_title(\"Original\")\n\naxes = fig.add_subplot(1, 2, 2)\nimage = CLAHE(image)\nplt.imshow(tf.squeeze(image), cmap = \"gray\")\naxes.set_title(\"Post CLAHE\")","4aed5c2f":"# Creating LabelMap\ndf[\"class_id\"] = df[\"class_id\"] + 1 # Incrementing by 1\nLabelMap = df.loc[df[\"class_name\"] != \"No finding\", [\"class_name\", \"class_id\"]] # Removing the examples with no finding\nLabelMap = LabelMap.drop_duplicates().reset_index(drop = True)\nLabelMap","4cb05e07":"# Using 14 unique colors to annotate the abnormalities.\nLABEL_COLORS = [\n    (230, 25, 75), (60, 180, 75), (255, 225, 25), (0, 130, 200), (245, 130, 48), (145, 30, 180), (70, 240, 240), \n    (240, 50, 230), (210, 245, 60), (250, 190, 212), (0, 128, 128), (220, 190, 255), (170, 110, 40), (255, 250, 200), \n]\nLabelMap[\"colors\"] = LABEL_COLORS","a8da56f9":"# Save mappings as .pbtxt\ndef save_mapping(LabelMap):\n    msg = StringIntLabelMap()\n    \n    for i, row in LabelMap.iterrows():\n        msg.item.append(StringIntLabelMapItem(id = row[\"class_id\"], name = row[\"class_name\"]))\n    \n    text = str(text_format.MessageToBytes(msg, as_utf8 = True), 'utf-8')\n    \n    f = open(\"LabelMap.pbtxt\", \"w\")\n    f.write(text)\n    f.close()\n    \nsave_mapping(LabelMap)","1e00f96e":"# Remove examples with no findings (won't be used for training)\ndf = df.dropna().reset_index(drop = True)\n\n# Change data types\ndf = df.astype({\n    \"x_min\": int, \n    \"y_min\": int, \n    \"x_max\": int, \n    \"y_max\": int,\n    \"class_id\": str\n})","5d3bf28c":"def plot_boxes(image, data, title):    \n    img = cv2.cvtColor(image.numpy(), cv2.COLOR_GRAY2RGB)\n    \n    for i, row in data.iterrows():\n    \n        x1, y1 = row[\"x_min\"], row[\"y_min\"]\n        x2, y2 = row[\"x_max\"], row[\"y_max\"]\n    \n        cv2.rectangle(\n            img,\n            pt1 = (x1, y1),\n            pt2 = (x2, y2),\n            color = row[\"colors\"],\n            thickness = 2\n        )\n    \n        cv2.putText(\n            img, \n            row[\"class_name\"], \n            (x1, y1-5), \n            cv2.FONT_HERSHEY_SIMPLEX, \n            0.5, \n            row[\"colors\"], \n            1\n        )\n\n    plt.figure(figsize = (8, 8))\n    plt.imshow(img) \n    plt.title(title)","1c563714":"# Selecting a particular radiologist\ndemo_rad = \"R9\"\n\n# Preprocessing metadata to suit needs\ndata = df.loc[\n    (df[\"image_id\"] == demo_image[:-6]) & (df[\"rad_id\"] == demo_rad),\n    [\"class_name\", \"x_min\", \"y_min\", \"x_max\", \"y_max\"]\n]\n\nH, W, _ = image.shape\ndata[[\"x_min\", \"x_max\"]] = (data[[\"x_min\", \"x_max\"]]* W\/w).astype(int)\ndata[[\"y_min\", \"y_max\"]] = (data[[\"y_min\", \"y_max\"]]* H\/h).astype(int)\n\ndata = pd.merge(data, LabelMap)\n\n# Plotting annotation by radiologist\nplot_boxes(image, data, \"Labels for \" + demo_image + \" by \" + demo_rad)","d8174a86":"# Preprocessing metadata to suit needs\ndata = df.loc[\n    (df[\"image_id\"] == demo_image[:-6]),\n    [\"class_name\", \"x_min\", \"y_min\", \"x_max\", \"y_max\"]\n]\n\nH, W, _ = image.shape\ndata[[\"x_min\", \"x_max\"]] = (data[[\"x_min\", \"x_max\"]]* W\/w).astype(int)\ndata[[\"y_min\", \"y_max\"]] = (data[[\"y_min\", \"y_max\"]]* H\/h).astype(int)\n\ndata = pd.merge(data, LabelMap)\n\n# Plotting annotation by all radiologists\nplot_boxes(image, data, \"Labels for \" + demo_image + \" by all radiologists\")","977b59b7":"# Preprocessing as needed for WBF\ndata = df.loc[\n    (df[\"image_id\"] == demo_image[:-6]),\n    [\"class_name\", \"x_min\", \"y_min\", \"x_max\", \"y_max\"]\n]\n\ndata[[\"x_min\", \"x_max\"]] = data[[\"x_min\", \"x_max\"]]\/w\ndata[[\"y_min\", \"y_max\"]] = data[[\"y_min\", \"y_max\"]]\/h\n\ndata = pd.merge(data, LabelMap)\n\nboxes_list = data[[\"x_min\", \"y_min\", \"x_max\", \"y_max\"]].values.tolist()\nscores_list = [1]*len(boxes_list)\nlabels_list = list(data[\"class_id\"])\n\n# Applying WBF\nboxes, _, labels = weighted_boxes_fusion(\n    boxes_list = [boxes_list],\n    scores_list = [scores_list],\n    labels_list = [labels_list],\n    weights = None, \n    iou_thr = 0.3, \n    skip_box_thr = 0.0001\n)","5136ccf5":"# Postprocessing after applying WBF \ndata = pd.DataFrame(boxes, columns = [\"x_min\", \"y_min\", \"x_max\", \"y_max\"])\n\nH, W, _ = image.shape\ndata[[\"x_min\", \"x_max\"]] = (data[[\"x_min\", \"x_max\"]]* W).astype(int)\ndata[[\"y_min\", \"y_max\"]] = (data[[\"y_min\", \"y_max\"]]* H).astype(int)\n\ndata[\"class_id\"] = labels.astype(int)\n\ndata = pd.merge(data, LabelMap)\n\n# Plotting annotation by all radiologists\nplot_boxes(image, data, \"Labels for \" + demo_image + \" post WBF\")","1a74223f":"# Dropping rad_id as it is not required for training\ndf = df.drop(columns = [\"rad_id\"])\n\n# Obtaining set of x-rays with at least one finding\nxrays = set(df[\"image_id\"]) # Only 4394 x-rays, not 15000. Roughly 30% of the x-rays remain.","c7789d90":"dimensions = []\nfor i, xray in tqdm(enumerate(xrays)):\n    ds = pydicom.dcmread(\n        os.path.join(path, \"train\", xray + \".dicom\"), \n        specific_tags = [\n            Tag(\"0028\", \"0010\"), # Tag for Rows (Height)\n            Tag(\"0028\", \"0011\")  # Tag for Columns (Width)\n        ]\n    )\n    \n    dimensions.append([xray, ds.Rows, ds.Columns])","7310e755":"dimensions = pd.DataFrame(dimensions, columns = [\"image_id\", \"height\", \"width\"])\ndf = pd.merge(dimensions, df)","435cb8b3":"# Normalize coordinates\ndf[\"x_min\"], df[\"x_max\"] = df[\"x_min\"]\/df[\"width\"], df[\"x_max\"]\/df[\"width\"]\ndf[\"y_min\"], df[\"y_max\"] = df[\"y_min\"]\/df[\"height\"], df[\"y_max\"]\/df[\"height\"]","a530793b":"# Before applying WBF we had 36096 rows\ndf_list = []\nfor i, xray in tqdm(enumerate(xrays)):\n    data = df[df[\"image_id\"] == xray]\n\n    boxes_list = data[[\"x_min\", \"y_min\", \"x_max\", \"y_max\"]].values.tolist()\n    scores_list = [1]*len(boxes_list)\n    labels_list = list(data[\"class_id\"])\n\n    # Applying WBF\n    boxes, _, labels = weighted_boxes_fusion(\n        boxes_list = [boxes_list],\n        scores_list = [scores_list],\n        labels_list = [labels_list],\n        weights = None, \n        iou_thr = 0.3, \n        skip_box_thr = 0.0001\n    )\n    \n    data = pd.DataFrame(boxes, columns = [\"x_min\", \"y_min\", \"x_max\", \"y_max\"]) \n    # Leaving the coordinates normalized since the API expects them to be so. \n    \n    data[\"class_id\"] = labels.astype(int)\n    \n    data[\"image_id\"] = xray \n    \n    df_list.append(data)","823ac5f3":"df = pd.concat(df_list) # After applying WBF we have 21836 rows\ndf = pd.merge(df, LabelMap)\ndf = df.drop(columns = [\"colors\"])","45cf0ab3":"# Stratified K-Fold Sharding\n\nnum_shards = 25\n\nskf = StratifiedKFold(\n    n_splits = num_shards, \n    shuffle = True, \n    random_state = 0\n)\n\ndf_folds = df[['image_id']].copy()\n\ndf_folds.loc[:, 'bbox_count'] = 1\ndf_folds = df_folds.groupby('image_id').count()   # Number of bounding boxes in the image\ndf_folds.loc[:, 'object_count'] = df.groupby('image_id')['class_id'].nunique() # Number of classes in the image\n\n# Preparing stratify groups\ndf_folds.loc[:, 'stratify_group'] = np.char.add(\n    df_folds['object_count'].values.astype(str),\n    df_folds['bbox_count'].apply(lambda x: f'_{x \/\/ 15}').values.astype(str)\n)\n\n# Determining which fold the x-ray will fall in\ndf_folds.loc[:, 'fold'] = 0\nskf_split = skf.split(\n    X = df_folds.index, \n    y = df_folds['stratify_group']\n)\n\nfor fold_number, (train_index, val_index) in enumerate(skf_split):\n    df_folds.loc[df_folds.iloc[val_index].index, 'fold'] = fold_number\n    \ndf_folds.reset_index(inplace = True)","23f8cbe7":"df = pd.merge(df, df_folds)\n\ntemp = df.groupby([\"fold\", \"class_name\"]).agg(\n    count = pd.NamedAgg(\"class_name\", \"count\")\n).reset_index()\n\ntemp = temp.pivot_table(\n    index = \"class_name\",\n    columns = \"fold\",\n    values = \"count\"\n)","0314baa2":"plt.figure(figsize = (20, 10))\nsns.heatmap(\n    temp,\n    annot = True,\n    cmap = \"YlGnBu\",\n    fmt = \"g\"\n)\nplt.title(\"Heatmap of class distribution\")","d13e5648":"def create_tf_record(img_path, max_dim, img_df):\n    \n    filename = img_path.split(\"\/\")[-1].encode()\n    source_id = img_path.encode()\n    \n    # Preprocess image \n    img, _, _ = read_dicom(img_path, max_dim)\n    height, width, _ = img.shape\n    img = CLAHE(img)\n    \n    # Encode as JPEG (Lossy compression)\n    img = tf.io.encode_jpeg(\n        img, \n        quality = 100, \n        format = 'grayscale'\n    )\n    \n    img_bytes = img.numpy()\n    \n    img_format = b'jpeg'\n\n    xmin_list = list(img_df[\"x_min\"])\n    xmax_list = list(img_df[\"x_max\"])\n    ymin_list = list(img_df[\"y_min\"])\n    ymax_list = list(img_df[\"y_max\"])\n    \n    class_name_list = list(img_df[\"class_name\"])\n    class_name_list = [c.encode() for c in class_name_list]\n    \n    class_id_list = list(img_df[\"class_id\"])\n    \n    # Creating TFRecord\n    tf_record = tf.train.Example(\n        features = tf.train.Features(\n            feature = {\n                'image\/height': dataset_util.int64_feature(height),\n                'image\/width': dataset_util.int64_feature(width),\n                'image\/filename': dataset_util.bytes_feature(filename),\n                'image\/source_id': dataset_util.bytes_feature(source_id),\n                'image\/encoded': dataset_util.bytes_feature(img_bytes),\n                'image\/format': dataset_util.bytes_feature(img_format),\n                'image\/object\/bbox\/xmin': dataset_util.float_list_feature(xmin_list),\n                'image\/object\/bbox\/xmax': dataset_util.float_list_feature(xmax_list),\n                'image\/object\/bbox\/ymin': dataset_util.float_list_feature(ymin_list),\n                'image\/object\/bbox\/ymax': dataset_util.float_list_feature(ymax_list),\n                'image\/object\/class\/text': dataset_util.bytes_list_feature(class_name_list),\n                'image\/object\/class\/label': dataset_util.int64_list_feature(class_id_list),\n            }\n        )\n    )\n    \n    return tf_record","84fa8110":"annot_path = \"workspace\/annotations\" \nos.makedirs(annot_path, exist_ok = True) ","510f048b":"img_cnt = np.zeros(num_shards, dtype = int)\n\nwith contextlib2.ExitStack() as tf_record_close_stack:\n    output_tfrecords = tf_record_creation_util.open_sharded_output_tfrecords(\n        tf_record_close_stack, \n        annot_path, \n        num_shards\n    )\n    \n    for i in tqdm(range(num_shards)):\n        df_shard = df[df[\"fold\"] == i]\n        xrays = set(df_shard[\"image_id\"])\n        \n        for xray in xrays:\n            df_image = df_shard[df_shard[\"image_id\"] == xray]\n            \n            img_path = os.path.join(path, \"train\", xray + \".dicom\")\n            tf_record = create_tf_record(img_path, max_dim, df_image)\n            output_tfrecords[i].write(tf_record.SerializeToString())\n            \n            img_cnt[i] += 1\n\nprint(\"Converted {} images\".format(np.sum(img_cnt)))\nprint(\"Images per shard: {}\".format(img_cnt))","c6d49913":"# Save dataframe\ndf.to_csv(\"data.csv\", index = False)","2183df42":"3. Exploring x-rays","907cac59":"Before visualizing the abnormalities on the x-rays, let's perform some preprocessing.\n\n**IMPORTANT**\n\nThe API requires the classes to be from 1 to n and outputs 0 when no class is found. Since our labels start with 0, we make unit increment to the class_id and use the new label-map.","90eecbfe":"1. Exploring distribution of radiologists","259ac77c":"## Read data\n1. Chest X-Ray annotations by radiologists (metadata)\n2. Sample Chest X-Ray (DICOM image)","dd6350c3":"Let's now explore annotations by other radiologists for this x-ray.","2414cb1d":"TFRecords created! We are now ready to use these for training, validation and testing. Jump to my [second notebook](https:\/\/www.kaggle.com\/bhallaakshit\/training-evaluation-with-tf2-object-detection-api). ","73801569":"Let's improve the contrast of this image using CLAHE (Contrast Limited Adaptive Histogram Equalization). Such image pre-processing redistributes the lightness values of the image making patterns more apparent.","ad103c59":"Radiologists 9, 10 and 8 saw most number of x-rays and made most annotations.","1f713894":"Looks like most x-rays have no finding. Aortic enlargement is the most common abnormality. At least one occurrence was found in about 3000 x-rays. Cardiomegaly, Pleural thickening and Pulmonary fibrosis follow.","807d640b":"## CREDITS\n### I'm a novice TensorFlow developer. This notebook would not have been possible without the following:\n1. https:\/\/www.kaggle.com\/mistag\/data-create-tfrecords-of-vinbigdata-chest-x-rays\n2. https:\/\/www.kaggle.com\/backtracking\/smart-data-split-train-eval-for-object-detection\/comments\n\n\nPlease consider upvoting these notebooks as well. :D","e57bd2cf":"# VinBigData Chest X-ray Abnormalities Detection\nAutomatically localize and classify thoracic abnormalities from chest radiographs\n\n### The aim of this notebook is to: \n1. Read DICOM x-ray images efficiently.\n2. Explore and visualize images and annotation metadata.\n3. Apply suitable Image Enhancement techniques to images.\n4. Preprocess annotation metadata.\n5. Perform Stratified K-Fold Sharding to create training and validation sets.\n6. Encode images as JPEG and store them along with annotations as TFRecords.","01ef769f":"The TFRecord format is a simple format for storing a sequence of binary records. This format is efficient in terms of storage and retrieval. It is the desired input format for the API. But before creating TFRecords, we must first apply WBF to the metadata. To apply WBF we must normalize the coordinates. Reading each image to extract dimensions can be time consuming. Using PyDICOM we can obtain x-ray metadata from which dimensions can be quickly extracted. ","60160f82":"Notice how color is similar along a row. The color distribution indicates the similar class disturbution across all folds (shards).\n\nOnce sharding is done, it is important to create TFRecords after applying CLAHE to each x-ray. We must remember to apply the same transformations to the x-rays we intend to make predictions for.","97d502d2":"## Install TF 2 Object Detection API\n1. TF Model Garden\n2. Protobuf\n3. COCO API\n4. Object Detection API ","0ff2f538":"That's cluttered. We need not train our model on multiple annotations of the same abnormality. We shall use a technique called Weighted Boxes Fusion (WBF) to provide us with the best annotation. This will definitely reduce the metadata size by a lot.","f2b85d76":"## TFRecord Creation","60b3478c":"## Visualize and preprocess data","da8fbcd4":"## Import libraries\n1. **NumPy:** Numerical computing\n2. **Pandas:** Data manipulation \n3. **Open-CV:** Computer Vision\n4. **Matplotlib:** Plotting\n5. **Scikit-learn:** Machine Learning\n6. **TensorFlow:** Deep Learning\n7. **Miscellaneous**","14ac62ff":"Awesome. We successfully eliminated multiple annotations for the same abnormality.","f63bc837":"Let's also save the label mapping as .pbtxt (required). With that we can now visualize the abnormalities on the x-rays.","b5f98299":"Since we have more than a few thousand examples, it is beneficial to shard the dataset into multiple files:\n* Parallel reading improves throughput.\n* Easy shuffling improves performance.\n\nSharding is cool but you know what's cooler? Stratified K-Fold Sharding. Basically we break down our dataset into multiple (\"K\") TFRecords (each is a shard) in such a way that: \n* The distribution of abnormalities remains the same in each shard.\n* Each x-ray is part of exactly one shard (to avoid information leak). \n\nWe can conveniently use these shards for training, validation and testing.","fc7cc371":"2. Exploring distribution of thoracic abnormalities"}}