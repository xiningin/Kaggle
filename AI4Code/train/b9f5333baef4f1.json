{"cell_type":{"477f0c23":"code","c83a44c5":"code","71ad55da":"code","f9aa0113":"code","f5abd6a6":"code","8a518412":"code","ed545a04":"code","43ed85ad":"code","0eacdffc":"code","4552e55c":"code","4ad10c8c":"code","29a183ca":"code","024ea8e2":"code","48eeeba6":"code","d4ac4f16":"code","6c50c10f":"code","85f3ff37":"code","bb535552":"code","f6fad15b":"code","b55004d3":"code","d1c516d2":"code","e270205e":"code","f36551e0":"code","b4f01591":"code","474bd5b4":"code","ebc139e8":"markdown","3b89b87e":"markdown","f7ad2886":"markdown","54d08a49":"markdown","19776c2d":"markdown","ddf917c7":"markdown","ec1e0fe3":"markdown"},"source":{"477f0c23":"# \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\nimport numpy as np # \u884c\u5217\u6f14\u7b97\nimport pandas as pd # \u30c6\u30fc\u30d6\u30eb\u30c7\u30fc\u30bf\u3092\u6271\u3046\npd.set_option(\"display.max_columns\", 100) # \u30ab\u30e9\u30e0\u6570\u8868\u793a\u306e\u4e0a\u9650\u3092100\u306b\u7de9\u548c\n\nimport matplotlib.pyplot as plt # \u53ef\u8996\u5316\u30e9\u30a4\u30d6\u30e9\u30ea\nplt.style.use('ggplot')\n%matplotlib inline\n\nfrom category_encoders import CountEncoder # \u30ab\u30c6\u30b4\u30ea\u3092\u6570\u5024\u306b\u5909\u63db\uff08\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\uff09\nfrom sklearn.feature_extraction.text import TfidfVectorizer # scikit-learn\u3000python\u3067ML\u3084\u308b\u4e0a\u3067\u306e\u30c7\u30d5\u30a1\u30af\u30c8\u30e9\u30a4\u30d6\u30e9\u30ea\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.model_selection import KFold\n\nfrom tqdm.notebook import tqdm # \u30d7\u30ed\u30b0\u30ec\u30b9\u30d0\u30fc\nfrom xgboost import XGBRegressor # \u5b66\u7fd2\u5668\uff08\u5f37\u3044\u3084\u3064\uff09\nimport cv2 #opencv, \u753b\u50cf\u30c7\u30fc\u30bf\u306e\u5404\u7a2e\u51e6\u7406\u306b\u4f7f\u3046","c83a44c5":"# lightGBM\u7528\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u307e\u3059\u3002\nfrom lightgbm import LGBMRegressor","71ad55da":"# \u30e1\u30a4\u30f3\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u3093\u3067\u898b\u307e\u3059\ndf_train = pd.read_csv('\/kaggle\/input\/data-science-autumn-2021\/train.csv', parse_dates=['latest_saledate'])\ndf_test = pd.read_csv('\/kaggle\/input\/data-science-autumn-2021\/test.csv', parse_dates=['latest_saledate'])\npredict = pd.read_csv('..\/input\/datascienceautumn2021\/DataScienceAutumn2021_submit.csv') #\u3053\u3053\u306b\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u3057\u305fcsv\u306e\u30d1\u30b9\u3092\u5165\u308c\u308b","f9aa0113":"# \u5b66\u7fd2\u30c7\u30fc\u30bf\u3001\u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\u3001\u4e88\u6e2c\u7d50\u679c\u306e\u884c\u6570\u3068\u5217\u6570\u3092\u898b\u3066\u307f\u307e\u3057\u3087\u3046\ndf_train.shape, df_test.shape, predict.shape","f5abd6a6":"#\u7d50\u5408\u3057\u307e\u3059\ndf_train2 = pd.merge(df_test, predict, on='zpid')\ndf_train = pd.concat([df_train, df_train2], axis=0)","8a518412":"#\u7d50\u5408\u3067\u304d\u3066\u3044\u308b\u304b\u78ba\u8a8d\uff01\ndf_train.shape","ed545a04":"# \u5b66\u7fd2\u30c7\u30fc\u30bf\u306e\u5148\u982d\uff15\u884c\u3092\u898b\u3066\u307f\u307e\u3057\u3087\u3046\n# \u3056\u3063\u3068\u307f\u305f\u3068\u3053\u308d\u3067\u306f\u3001\u6570\u5024\u3001\u30ab\u30c6\u30b4\u30ea\u3001\u65e5\u4ed8\u306e\u4ed6\u306b\u3001\u30c6\u30ad\u30b9\u30c8\uff08description\uff09\u3001\u5730\u7406\u7a7a\u9593\uff08latitude\/longitude\u306a\u3069\uff09\u3001\u753b\u50cf(homeImage)\u304c\u542b\u307e\u308c\u308b\u3088\u3046\u3067\u3059\u306d\u3002\n# \u753b\u50cf\u306ffile path\u304c\u5165\u3063\u3066\u3044\u307e\u3059\u3002\ndf_train.head()","43ed85ad":"# \u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\u306e\u5148\u982d\uff15\u884c\u3092\u898b\u3066\u307f\u307e\u3057\u3087\u3046\ndf_test.head()","0eacdffc":"df_train['homeImage'] # Series","4552e55c":"# \u5b66\u7fd2\u30c7\u30fc\u30bf\u306b\u5bfe\u5fdc\u3059\u308b\u753b\u50cf\u3092\u5148\u982d12\u679a\u307f\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n# \u7dba\u9e97\u306a\u304a\u5bb6\u3067\u3059\u306d\u3002\u65e5\u672c\u3067\u306f\u306a\u304b\u306a\u304b\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\nn=12\nfiles = df_train['homeImage'].values[:n]\n\nplt.figure(figsize=[30,30])\nfor i, file in enumerate(files):\n    plt.subplot(n\/\/3,3,i+1)\n    img = cv2.imread('\/kaggle\/input\/data-science-autumn-2021\/train\/%s'%file)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    plt.title(file)\n    plt.imshow(img)\nplt.show()","4ad10c8c":"# 2021-10-14 updated:\u5bfe\u6570\u5909\u63db\ndf_train['latestPrice'] = np.log(df_train['latestPrice'])","29a183ca":"# \u8aac\u660e\u5909\u6570\u3068\u30bf\u30fc\u30b2\u30c3\u30c8\u5909\u6570\u306b\u5206\u5272\u3057\u3066\u304a\u304d\u307e\u3059\n# \u30c6\u30ad\u30b9\u30c8\u3068\u753b\u50cf\u4e00\u65e6\u9664\u3044\u3066\u304a\u304d\u307e\u3057\u3087\u3046\u3002\u3053\u308c\u3089\u306e\u6271\u3044\u306b\u3064\u3044\u3066\u306f\u672c\u30b3\u30f3\u30da\u3092\u901a\u3058\u3066\u5b66\u3093\u3067\u3044\u304d\u307e\u3057\u3087\u3046\u3002\u307e\u305f\u3001\u65e5\u4ed8\u3082year\u3068month\u304c\u65e2\u306b\u542b\u307e\u308c\u3066\u3044\u308b\u306e\u3067\u4e00\u65e6\u4f7f\u308f\u306a\u3044\u3067\u3084\u3063\u3066\u307f\u307e\u3059\u3002\ny_train = df_train.latestPrice\nX_train = df_train.drop(['latestPrice', 'description', 'homeImage', 'latest_saledate'], axis=1)\nX_test = df_test.drop(['description', 'homeImage', 'latest_saledate'], axis=1)","024ea8e2":"# dtype\u304cobject\uff08\u6570\u5024\u3067\u306a\u3044\u3082\u306e\uff09\u306e\u30ab\u30e9\u30e0\u540d\u3068\u30e6\u30cb\u30fc\u30af\u6570\u3092\u78ba\u8a8d\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n# streetAddress\u304c\u30e6\u30cb\u30fc\u30af\u306b\u8fd1\u3044\u3067\u3059\u306d\u3002\ncats = []\nfor col in X_train.columns:\n    if X_train[col].dtype == 'object':\n        cats.append(col)\n        \n        print(col, X_train[col].nunique())","48eeeba6":"# streetAddress\u3082\u3042\u3068\u3067\u8003\u3048\u308b\u3053\u3068\u306b\u3057\u3066\u4e00\u65e6\u9664\u3044\u3066\u304a\u304d\u307e\u3059\u3002\n# 2\u5ea6\u3042\u308b\u3053\u3068\u306f3\u5ea6\u3042\u308b\u65b9\u5f0f\u3067\u5b66\u7fd2\u3059\u308b\u306e\u304c\u6a5f\u68b0\u5b66\u7fd2\u3067\u3059\u306e\u3067\u3001\u5168\u90e81\u56de\u3057\u304b\u89b3\u6e2c\u3055\u308c\u306a\u3044\u73fe\u72b6\u306e\u307e\u307e\u3067\u306f\u76f4\u63a5\u306f\u610f\u5473\u3092\u306a\u3055\u306a\u3044\u304b\u3089\u3067\u3059\u3002\nX_train = X_train.drop(['streetAddress'], axis=1)\nX_test = X_test.drop(['streetAddress'], axis=1)","d4ac4f16":"# \u305d\u306e\u4ed6\u306b\u3082\u8272\u3005\u3084\u308c\u308b\u3053\u3068\u304c\u3042\u308a\u307e\u3059\u304c\u3001\u3053\u3053\u3067\u306f\u3082\u3046\u4e00\u62ec\u3057\u3066\u30a8\u30a4\u30e4\u3067Count Encoding\u3057\u3066\u3057\u307e\u3044\u307e\u3059\ncats = []\n\nfor col in X_train.columns:\n    if X_train[col].dtype == 'object':\n        cats.append(col)\n        \nce = CountEncoder(cols=cats)\n\nX_train = ce.fit_transform(X_train)\nX_test = ce.transform(X_test)","6c50c10f":"# \uff15\u5206\u5272\u4ea4\u5dee\u691c\u5b9a\u3067\u4e88\u6e2c\u30b9\u30b3\u30a2\u3092\u898b\u7a4d\u3082\u3063\u3066\u307f\u307e\u3057\u3087\u3046\nscores = []\n\n# 2021-10-20 updated: 5 split to 4\ncv = KFold(n_splits=4, random_state=71, shuffle=True)\n# cv = KFold(n_splits=5, random_state=71, shuffle=True)\n\nfor i, (train_ix, val_ix) in tqdm(enumerate(cv.split(X_train, y_train))):\n    X_train_, y_train_ = X_train.iloc[train_ix], y_train.iloc[train_ix]\n    X_val, y_val = X_train.iloc[val_ix], y_train.iloc[val_ix]\n\n#   2021-10-13 updated\n#     model = XGBRegressor(n_estimators=9999, learning_rate=0.05, random_state=71)\n    model = LGBMRegressor(n_estimators=9999, learning_rate=0.05, random_state=71, objective='mae')\n    model.fit(X_train_, y_train_, eval_set=[(X_val, y_val)], eval_metric='mae', early_stopping_rounds=30)\n    y_pred = model.predict(X_val)\n    score = mean_absolute_error(y_val, y_pred)\n    scores.append(score)\n    print('CV Score of Fold_%d is %f' % (i, score))","85f3ff37":"# \u5e73\u5747\u30b9\u30b3\u30a2\u3092\u7b97\u51fa\nnp.array(scores).mean()","bb535552":"# \u3067\u306f\u3001\u5168\u30c7\u30fc\u30bf\u3067\u518d\u5b66\u7fd2\u3057\u3066\u307f\u307e\u3057\u3087\u3046\n# \u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u6570\u306f\u5148\u307b\u3069\u306e\u6700\u9069\u5024\u3092\u7528\u3044\u3066\u307f\u307e\u3059\n\n# \u3053\u3053\u3082\u5c11\u3057\u3060\u3051\u5909\u3048\u307e\u3059\u3002\n# best_iter = model.best_iteration\nbest_iter = model.best_iteration_\n\n# 2021-10-13 updated\n# model = XGBRegressor(learning_rate=0.05, n_estimators=best_iter, random_state=71)\nmodel = LGBMRegressor(learning_rate=0.05, n_estimators=best_iter, random_state=71, objective='mae')\nmodel.fit(X_train, y_train)","f6fad15b":"from catboost import CatBoostRegressor, FeaturesData, Pool\n\n# \uff15\u5206\u5272\u4ea4\u5dee\u691c\u5b9a\u3067\u4e88\u6e2c\u30b9\u30b3\u30a2\u3092\u898b\u7a4d\u3082\u3063\u3066\u307f\u307e\u3057\u3087\u3046\nscores2 = []\n\n# 2021-10-20 updated: 5 split to 4\ncv = KFold(n_splits=4, random_state=71, shuffle=True)\n# cv = KFold(n_splits=5, random_state=71, shuffle=True)\n\nfor i, (train_ix, val_ix) in tqdm(enumerate(cv.split(X_train, y_train))):\n    X_train_, y_train_ = X_train.iloc[train_ix], y_train.iloc[train_ix]\n    X_val, y_val = X_train.iloc[val_ix], y_train.iloc[val_ix]\n\n#   2021-10-23 updated \u5b66\u7fd2\u7387\u3082\u3055\u3052\u3066\u307f\u305f\n    model2 = CatBoostRegressor(loss_function='MAE', learning_rate=0.01, random_state=71, num_boost_round=3000, early_stopping_rounds=20, eval_metric='MAE')\n    model2.fit(X_train_, y_train_, eval_set=[(X_val, y_val)], early_stopping_rounds=30)\n    y_pred2 = model2.predict(X_val)\n    score2 = mean_absolute_error(y_val, y_pred2)\n    scores2.append(score)\n    print('CV Score of Fold_%d is %f' % (i, score2))","b55004d3":"# \u5e73\u5747\u30b9\u30b3\u30a2\u3092\u7b97\u51fa\nnp.array(scores2).mean()","d1c516d2":"# \u3067\u306f\u3001\u5168\u30c7\u30fc\u30bf\u3067\u518d\u5b66\u7fd2\u3057\u3066\u307f\u307e\u3057\u3087\u3046\n# \u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u6570\u306f\u5148\u307b\u3069\u306e\u6700\u9069\u5024\u3092\u7528\u3044\u3066\u307f\u307e\u3059\n\n# \u3053\u3053\u3082\u5c11\u3057\u3060\u3051\u5909\u3048\u307e\u3059\u3002\n# best_iter = model.best_iteration\nbest_iter2 = model2.best_iteration_\n\n#  2021-10-23 updated\nmodel2 = CatBoostRegressor(loss_function='MAE', n_estimators=best_iter, random_state=71, eval_metric='MAE')\nmodel2.fit(X_train, y_train)","e270205e":"# \u3044\u3088\u3044\u3088\u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\u306b\u5bfe\u3057\u3066\u4e88\u6e2c\u3057\u307e\u3059\ny_pred_test = model.predict(X_test)*0.5 + model2.predict(X_test)*0.5\ny_pred_test","f36551e0":"# \u63d0\u51fa\u7528\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3092\u8aad\u307f\u8fbc\u3093\u3067\u4e88\u6e2c\u5024\u3092\u4ee3\u5165\u3057\u307e\u3059\u3002\nsubmission = pd.read_csv('\/kaggle\/input\/data-science-autumn-2021\/sample_submission.csv', index_col=0)\n# submission.latestPrice = y_pred_test\nsubmission.latestPrice = np.exp(y_pred_test) * 1.1 #\u4f4f\u5b85\u4e0d\u52d5\u7523\u4fa1\u683c\u306e\u5e74\u95938~12%\u306e\u4fa1\u683c\u4e0a\u6607\u30022021\u306e\u30c7\u30fc\u30bf\u306f\u5c11\u306a\u3044\u305f\u3081\u3001\u7c21\u6613\u7684\u306a\u51e6\u7406\u3092\u8ffd\u52a0","b4f01591":"submission","474bd5b4":"# csv\u30d5\u30a1\u30a4\u30eb\u3068\u3057\u3066\u4fdd\u5b58\u3057\u307e\u3059\nsubmission.to_csv('submission.csv')","ebc139e8":"**\u4ee5\u4e0b\u306e2\u70b9\uff08\u8a13\u7df4\u30c7\u30fc\u30bf\u306e\u30bf\u30fc\u30b2\u30c3\u30c8\u3092\u5bfe\u6570\u5909\u63db\u3001submission\u306f\u5143\u306e\u30b9\u30b1\u30fc\u30eb\u306b\u623b\u3059\u305f\u3081\u6307\u6570\u5909\u63db\uff09\u3092\u5909\u66f4**\n* df_train['latestPrice'] = np.log(df_train['latestPrice'])\n* submission.latestPrice = np.exp(y_pred_test)","3b89b87e":"### **2021-10-13\u8ffd\u52a0**\n### \u30d9\u30fc\u30b9\u30e9\u30a4\u30f3\u306e\u30e2\u30c7\u30eb\u3092XGBoost\u21d2LightGBM\u306b\u5909\u66f4\u3057\u307e\u3059\u3002\n\n\u8a73\u7d30\u306f\u3053\u3061\u3089\u306e\u30ea\u30f3\u30af\u3092\u898b\u3066\u304f\u3060\u3055\u3044\uff01\nhttps:\/\/www.codexa.net\/lightgbm-beginner\/","f7ad2886":"### **2021-10-14\u8ffd\u52a0**\n### \u30bf\u30fc\u30b2\u30c3\u30c8\uff08latestPrice\uff09\u3092\u5bfe\u6570\u5909\u63db\u3057\u307e\u3059\u3002\n\n**\u5909\u66f4\uff08\u8ffd\u52a0\u70b9\uff09\u70b9\u306f\u4ee5\u4e0b\u306e3\u70b9**\n* lightGBM\u7528\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\n* XGBRegressor\u21d2LGBMRegressor\u306b\u5909\u66f4\n* best_iter = model.best_iteration\u21d2best_iter = model.best_iteration_\u3000\u306b\u5909\u66f4","54d08a49":"# 2021-10-23 CatBoost\u306b\u5909\u66f4","19776c2d":"# 2021-11-8\u8ffd\u52a0\n\n\u5f8c\u51e6\u7406\u3068\u3057\u3066\u3001\u68ee\u3055\u3093\u306e\u5185\u5bb9\u3092\u8ffd\u52a0\u3057\u307e\u3057\u305f\u3002\n\n\u4f55\u304b\u306e\u8a18\u4e8b\u306b\n\u300c\u30aa\u30fc\u30b9\u30c6\u30a3\u30f3\u5e02\u5185\u3068\u5468\u8fba\u5730\u57df\u3067\u306f\u3001\u4f4f\u5b85\u4e0d\u52d5\u7523\u4fa1\u683c\u306e\u5e74\u95938~12%\u306e\u4fa1\u683c\u4e0a\u6607\u304c\u4e88\u60f3\u3055\u308c\u308b\u3002\u300d\n\u3068\u304b\u304b\u308c\u3066\u3044\u307e\u3057\u305f\u3002","ddf917c7":"# 2021-11-8 \u5f8c\u51e6\u7406\u8ffd\u52a0","ec1e0fe3":"### **2021-10-20\u8ffd\u52a0**\n### CV\u65705->4\u306b\u5909\u66f4\u3057\u307e\u3059\u3002\n(5\u304c\u9069\u5207\u304b\u306f\u308f\u304b\u3089\u306a\u3044\u306e\u3067\u3002)\n\n\u5909\u66f4\u524d\u306e\u30d9\u30fc\u30b9\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\nhttps:\/\/www.kaggle.com\/yoshikazuajisawa\/simplebaseline-lightgbm-log\n\n"}}