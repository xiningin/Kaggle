{"cell_type":{"8fc3753a":"code","9fddb85b":"code","8b579125":"code","3649b745":"code","a7d4d963":"code","442f7d0e":"code","cb4c84c8":"code","06816d1c":"code","806c44e0":"code","80e2fd3b":"code","a5a7061c":"code","5f2ccba3":"code","6999d420":"code","74991113":"code","58fc173f":"code","b961f705":"code","78a6f114":"code","4d4e9edd":"code","b8f179b9":"code","f54f5c0b":"markdown","64decf85":"markdown","ab01cdb0":"markdown","b11509bb":"markdown","0a409828":"markdown"},"source":{"8fc3753a":"import pandas as pd\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\n\nmovie = pd.read_csv('..\/input\/movielense20m\/movie.csv')\nrating = pd.read_csv('..\/input\/movielense20m\/rating.csv')\ndf = movie.merge(rating, how=\"left\", on=\"movieId\")","9fddb85b":"# Data Preparation\n# we specify the parantheses so we don't conflict with movies that have years in their titles\ndf['year_movie'] = df.title.str.extract('(\\(\\d\\d\\d\\d\\))', expand=False)\n#Removing the parentheses\ndf['year_movie'] = df.year_movie.str.extract('(\\d\\d\\d\\d)', expand=False)\n\n#Removing the years from the 'title' column\ndf['title'] = df.title.str.replace('(\\(\\d\\d\\d\\d\\))', '',regex=True)\n# To get rid of all the ending white space characters that might have appeared \ndf['title'] = df['title'].apply(lambda x: x.strip())\n\na = pd.DataFrame(df[\"title\"].value_counts())\nrare_movies = a[a[\"title\"] <= 1000].index\ncommon_movies = df[~df[\"title\"].isin(rare_movies)]\nuser_movie_df = common_movies.pivot_table(index=[\"userId\"], columns=[\"title\"], values=\"rating\")","8b579125":"# genres\n# Every genre is separated by a | so we simply have to call the split function on |\ndf[\"genre\"] = df[\"genres\"].apply(lambda x: x.split(\"|\")[0])\ndf.drop(\"genres\", inplace=True, axis=1)\ndf.head()","3649b745":"# editting the date format \ndf[\"timestamp\"] = pd.to_datetime(df[\"timestamp\"], format='%Y-%m-%d')\ndf[\"year\"] = df[\"timestamp\"].dt.year\ndf[\"month\"] = df[\"timestamp\"].dt.month\ndf[\"day\"] = df[\"timestamp\"].dt.day\ndf.head()\n","a7d4d963":"# choosing random a user\nuser_id = int(pd.Series(user_movie_df.index).sample(1).values)\nuser_id","442f7d0e":"# Determining the movies watched by the recommended user\nuser_df = user_movie_df[user_movie_df.index == user_id]\n\nmovies_watched = user_df.columns[user_df.notna().any()].tolist()\nlen(movies_watched)\n# the number of movies the user has watched ","cb4c84c8":"# Accessing data and Ids of other users watching the same movies \nmovies_watched_df = user_movie_df[movies_watched]\nmovies_watched_df.head()\nmovies_watched_df.shape\n# There are 138493 users who watched at least one of the movies the user watched.","06816d1c":"# each user watched how many of these 455 movies\nuser_movie_count = movies_watched_df.T.notnull().sum()\nuser_movie_count.head()","806c44e0":"user_movie_count = user_movie_count.reset_index()\nuser_movie_count.columns = [\"userId\", \"movie_count\"]\nm_count = movies_watched_df.shape[1]   # 455\n\n# choosen a ratio of 0.60. User ids who watched at least percent of 60 these movies \nusers_same_movies=user_movie_count[user_movie_count[\"movie_count\"]\/m_count > 0.6].sort_values(\"movie_count\", ascending=False)\nusers_same_movies.nunique()","80e2fd3b":"users_same_movies.head(10)","a5a7061c":"# We bring together users who watch the same movies with the user. (not overlook the above ratio)\nfinal_df = pd.concat([movies_watched_df[movies_watched_df.index.isin(users_same_movies.index)],\n                      user_df[movies_watched]])\n\nfinal_df.head()","5f2ccba3":"corr_df = final_df.T.corr().unstack().sort_values().drop_duplicates()\ncorr_df = pd.DataFrame(corr_df, columns=[\"corr\"])\ncorr_df.index.names = ['user_id_1', 'user_id_2']\ncorr_df = corr_df.reset_index()\ncorr_df.head()","6999d420":"top_users = corr_df[(corr_df[\"user_id_1\"] == user_id) & (corr_df[\"corr\"] >= 0.60)][\n    [\"user_id_2\", \"corr\"]].reset_index(drop=True)\n\ntop_users = top_users.sort_values(by='corr', ascending=False)\n\n# Users who have more than 0.60 corr with the user\ntop_users.rename(columns={\"user_id_2\": \"userId\"}, inplace=True) \ntop_users.T","74991113":"# Calculation weighted rating\nrating = pd.read_csv('..\/input\/movielense20m\/rating.csv')\ntop_users_ratings = top_users.merge(rating[[\"userId\", \"movieId\", \"rating\"]], how='inner')\ntop_users_ratings['weighted_rating'] = top_users_ratings['corr'] * top_users_ratings['rating']\ntop_users_ratings.head()","58fc173f":"# Calculating the weighted average recommendation score and keeping the top ten films\n# Unique rating for movieId \ntemp = top_users_ratings.groupby('movieId').sum()[['corr', 'weighted_rating']]\ntemp.columns = ['sum_corr', 'sum_weighted_rating']\ntemp.head()","b961f705":"# Calculating weighted average recommendation score and keeping top five films based on scores\nrecommendation_df = pd.DataFrame()\nrecommendation_df['weighted_average_recommendation_score'] = temp['sum_weighted_rating'] \/ temp['sum_corr']\nrecommendation_df['movieId'] = temp.index\nrecommendation_df = recommendation_df.sort_values(by='weighted_average_recommendation_score', ascending=False)\nrecommendation_df.head(7)","78a6f114":"# movies that the user may like\nmovie = pd.read_csv('..\/input\/movielense20m\/movie.csv')\nmovie.loc[movie['movieId'].isin(recommendation_df.head(10)['movieId'])]","4d4e9edd":"user_df = df.loc[df[\"userId\"]==user_id]\nuser_df.head()","b8f179b9":"user_df.groupby(\"title\").agg({\"rating\": \"max\", \"timestamp\": \"max\"}).sort_values(\"timestamp\", ascending=False)","f54f5c0b":"Movie Recommendation System\n\nCollaborative filtering recommendation systems with MovieLens 20m Datasets\nThis dataset was constructed to support participants in the Netflix Prize","64decf85":"Collaborative Filtering\n\n* This filtering method is usually based on collecting and analyzing information on user\u2019s behaviors, \ntheir activities or preferences and predicting what they will like based on the similarity with other\nusers.\n\nUser-User Collaborative Filtering: Here, we try to search for lookalike customers and offer products \nbased on what his\/her lookalike has chosen. This algorithm is very effective but takes \na lot of time and resources.\n","ab01cdb0":"We are interested in users who have a high correlation with the user_id.\nCould analysis it by entering a value","b11509bb":"Determining the most similar users to the user to be recommended ","0a409828":"Recommandation system passed to users suggestions on what they might like according to their preferences\nis a machine learning application that offers."}}