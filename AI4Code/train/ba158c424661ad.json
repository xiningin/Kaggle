{"cell_type":{"b632ff52":"code","06bff43d":"code","94e655bd":"code","82999ff6":"code","30c9ded5":"code","38f1ead8":"code","9024b684":"code","8308d98a":"code","3e5aeed6":"code","7324f594":"code","d9fe3e1d":"code","81e39622":"markdown","d0cd443c":"markdown","bda4e781":"markdown","c0c190c5":"markdown","9f572232":"markdown","a8fa35cf":"markdown","13134345":"markdown"},"source":{"b632ff52":"!pip install git+https:\/\/github.com\/EasyArray\/phosphorus#egg=phosphorus\n%load_ext phosphorus\nfrom IPython.core.display import display, HTML\ndef header(s, size=\"h3\"): display(HTML(f\"<{size}>{s}<\/{size}>\"))","06bff43d":"Rule.deregister()\nrule I: M\u03b1I => M\u03b1IU\nrule II: M\u03b1 => M\u03b1\u03b1\nrule III: M\u03b1III\u03b2 => M\u03b1U\u03b2\nrule IV: M\u03b1UU\u03b2 => M\u03b1\u03b2","94e655bd":"header(\"MIUIU\", \"h2\")\n\nheader(\"STEP-1: Axiom\")\nMI\n\nheader(\"STEP-2: Rule I applied to MI\")\nrules[I].run(MI)\n\nheader(\"STEP-3: Rule II applied to MIU\")\nrules[II].run(MIU)\n\n\n\nheader(\"MUIU\", \"h2\")\n\nheader(\"STEP-1: Axiom\")\nMI\n\nheader(\"STEP-2: Rule REPLACE applied to MI\")\n\nheader(\"STEP-3: REPLACE\")\n\n\nheader(\"MIIIII\", \"h2\")\n\nheader(\"STEP-1: Axiom\")\nMI\n\nheader(\"STEP-2: \")\n\nheader(\"STEP-3: \")\n\n","82999ff6":"rule MU: M\u03b1 => MU    \n\nheader(\"STEP-1: Rule REPLACE applied to REPLACE\")\n#This step should evaluate to MU:\nrules[MU].run(MI)\n\nheader(\"STEP-2: Rule REPLACE applied to REPLACE\")","30c9ded5":"# This cell checks for new theorems given the new rule above\n# n is how many steps to check for the new MU theorem\n# change to a higher number if needed, but it will slow things down\nn = 5 \n\n# Store all theorems of the new system\nmun = repeat(step,MI,n,True)\n\n# Store all theorems of the old system\nmu = rules[MU] # save the old rule\nRule.deregister(MU) # remove it\nmiun = repeat(step,MI,n,True) # store the theorems\nmu.register() # add the new rule back in\n\nheader(\"NEW in n Steps\")\nnew = {x | x\u2208mun, not (x\u2208miun)}\nsorted(new,key=len)\nDERIVED_MU if MU\u2208new else FAILED_TO_DERIVE_MU","38f1ead8":"Rule.deregister()\naxiom = REPLACE\nrule TQ1 \u03b1t\u03b2q\u03b3 => \"\u03b1-t\u03b2q\u03b3\"\nrule TQ2 \u03b1t\u03b2q\u03b3 => \"\u03b1t\u03b2-q\u03b3\"\n\nn = 10 \nrepeat(step,axiom,n,True)","9024b684":"test = {A:1, B:2, C:3}\ntest[A]\ntest[B]","8308d98a":"lex.update({ #Individuals\n        Arthur : A, Beth : B, Charlie : C, Diana : D, \n        Edward : E, Frida : F, George : G,\n        \n        #Properties, aka one-place predicates\n        drives  : {B, C, E, F},\n        walks   : {A, B, C, D, E, F, G},\n    \n        #Two-place predicates\n        likes   : {A:{A,G}, B:{A}, C:{A,B,C}, D:{A,C}, \n                   E:{A}, F:{A,F}, G: {A,G}},\n        loves   : {A:{A,G}, B:{}, C:{C}, D:{C}, \n                   E:{}, F:{F}, G:{}},\n    \n        #Zero-place predicates\n        raining : {REPLACE},\n        sunny   : {REPLACE},\n    \n        #Operators\/other\n        AND : {True: {}, False: {}},\n        OR  : {True: {}, False: {True}}, #Exclusive OR\n        its : REPLACE\n    })\n\n#Rules\nRule.deregister()\nrule LEX  \u27e6\u03b1\u27e7 = lex[\u03b1] || \u03b1\u2208lex\nrule S    \u27e6tree[_S \u03b1 \u03b2]\u27e7  = \u27e6\u03b1\u27e7 \u2208 \u27e6\u03b2\u27e7\nrule VP   \u27e6tree[_VP \u03b1 \u03b2]\u27e7 = \u27e6\u03b1\u27e7[ \u27e6\u03b2\u27e7 ]","3e5aeed6":"header(\"Initial Tests\")\nwalks\n\u27e6 walks \u27e7\ntree[_S Arthur walks] \n\u27e6tree[_S Arthur walks] \u27e7\ntree[_S Arthur drives]\n\u27e6tree[_S Arthur drives] \u27e7\ntree[_VP likes Arthur] \n\u27e6tree[_VP likes Arthur] \u27e7\ntree[_S Diana [_VP likes Arthur]]\n\u27e6tree[_S Diana [_VP likes Arthur]] \u27e7\ntree[_S George [_VP likes Arthur]] \n\u27e6tree[_S George [_VP likes Arthur]] \u27e7","7324f594":"header(\"Conjunctions\")\ntree[_S [_S Arthur walks] [_VP OR [_S Arthur drives]]] \n\u27e6tree[_S [_S Arthur walks] [_VP OR [_S Arthur drives]]], True \u27e7\ntree[_S [_S Beth walks] [_VP AND [_S Arthur drives]]] \n\u27e6tree[_S [_S Beth walks] [_VP AND [_S Arthur drives]]] \u27e7\ntree[_S [_S Arthur walks] [_VP AND [_S Beth drives]]]\n\u27e6tree[_S [_S Arthur walks] [_VP AND [_S Beth drives]]] \u27e7\n\nheader(\"Zero-place predicates\")\ntree[_S its raining] \n\u27e6tree[_S its raining] \u27e7\ntree[_S its sunny] \n\u27e6tree[_S its sunny] \u27e7","d9fe3e1d":"#Space for your new trees and rules to answer #7 above\nrule SOMEBODY  \u27e6tree[_S somebody \u03b2]\u27e7  = len(\u27e6\u03b2\u27e7)\nrule EVERYBODY \u27e6tree[_S everybody \u03b2]\u27e7 = REPLACE\nrule NOBODY    \u27e6tree[_S nobody \u03b2]\u27e7    = REPLACE","81e39622":"**<mark>Problem 2<\/mark>**\n    \n**<mark>A. (5 pts)<\/mark>** Fix the `MU` rule where it says `REPLACE` and `HERE` to allow the (thus altered) **MIU** system to generate **MU**. Try for a rule that also generates many *other* new theorems, not derivable in the original **MIU** system. (Some of these new theorems should appear in the \"NEW in n Steps\" section below.)\n    \n**<mark>B. (10 pts)<\/mark>** Provide a <mark style=\"background-color:lightgreen\">top-down derivation<\/mark> for **MU** both in phosphorus (below) and markdown (here). \n    \n\\# | Step | Justification\n-- | -- | --\n1 | **MU** is theorem if ... | ...","d0cd443c":"# Homework \\#1: Phosphorus and (other) Formal Systems\n\n<mark style=\"background-color:lightgreen\">Be sure to rename your copy of this notebook to include your name and share it with Prof Keshet.<\/mark>  In your  copy, answer the questions below by entering either phosphorus code, markdown code, or both, as requested. You can double-click to edit any cell, then use Ctrl-Enter to run\/compile again. To submit, use \"Save Version\" and then print the output from your browser as a pdf (see the manual for details).\n\nThe first cell defines the MIU system:","bda4e781":"**<mark>Problem 7 (15 pts)<\/mark>** Describe (in this cell here) in words how to handle the English words *somebody*, *everybody*, and *nobody* in subject position. Write test trees in the final cell below that show these words in subject, with correctly labelled branching nodes. Then, implement your solution below.\n\n**Hints:** \n* Simply write three new rules for these three new words, as begun below.\n* Recall that `len(\u27e6\u03b2\u27e7)` will be the size of the (value for the) the VP in these rules.","c0c190c5":"Notes\/Hints:\n+ In this sytem, names denote individuals, which we are representing as capital letters.\n+ The `||` notation at the end of a rule limits when it applies\n+ Properties are most directly manipulated by the **S** rule.\n+ Two-place predicates like `likes` combine *first* with their objects, via the **VP** rule. (Check out the tree structures below.) This determines how they are written: the keys `A`...`G` for these predicates represent the *objects* of the sentence, not the subjects.\n+ The zero-place predicates `raining` and `sunny` will have to combine with `its` via the **S** rule. Therefore, their denotations have to look very similar to those of the (one-place) properties: they will be sets. They do not have to be (and probably shouldn't be) sets of individuals, though.\n+ The operators `AND` and `OR` are written in all caps, because the lowercase versions are special python keywords. These should mimic the definitions of the two-place predicates and combine with their first arguments via the **VP** rule as shown in the trees below. Again, though, the values inside their denotations will not be individuals.\n\n\n**<mark>Problem 4 (5 pts)<\/mark>** Explain (in this markdown cell here) in clear English what the three rules do.\n\n**<mark>Problem 5 (20 pts)<\/mark>** Complete the definitions of the additional terminal nodes **AND** and **OR**. Define these so that the test sentences in the last cell below get the correct truth values. \n\n**<mark>Problem 6 (5 pts)<\/mark>** Complete the definition of the terminal node **its** (for *it's*), **raining**, and **sunny** in such a way that *It's raining* comes out as True and *It's sunny* comes out as False.\n\n(There is one more problem at the bottom of this notebook.)","9f572232":"### Formal Languages\n\nThe next problems relate to an interpretation of a formal language based on English. In the cell below, there are three fully defined types of terminal nodes: \n1. *individuals* denoting capital letters\n2. *properties* denoting sets of individuals\n3. *two-place predicates* denoting dictionaries mapping individuals to properties. \n\nThere also five lexical items whose definitions you will define below. As for rules, there are three defined below: **LEX** for lexical items, **S** for sentences and **VP** for verb phrases (and related clauses). You will not be required to write more for this assignment.","a8fa35cf":"### Formal Systems: MIU\n\n**<mark>Problem 1<\/mark>** For each theorem below, complete <mark style=\"background-color:lightgreen\">bottom-up derivations<\/mark> *both* in markdown (in this cell) and in phosphorus (in the next cell). Complete the phosphorus derivation, following the format as started for you. For your phosphorus derivation in the next cell, please use the individual rules of **MIU**, as shown below, instead of employing the full system via the `step` function. For the markdown derivation in this cell, follow the same format as in the classroom exercises, remembering to correctly use boldface as appropriate. Make sure the variable values in your justifications match the variables as used in the rules above: \u03b1 or \u03b2 as appropriate.\n\n**<mark>A. (10pts)<\/mark>** **MIUIU**\n    \n\\# | Step | Justification\n-- | -- | --\n1 | **MI** | Axiom\n2 | **MIU** | Rule I (&alpha;=**&epsilon;**)\n\n**<mark>B. (10pts)<\/mark>** **MUIU**\n\n**<mark>C. (10pts)<\/mark>** **MIIIII**","13134345":"### Formal Systems: **p,q**\n\n**<mark>Problem 3 (10 pts)<\/mark>**  Write an axiom and rules for a **t,q** system that models multiplication. (Try to use only 2 rules, if possible.) Allow all multiplications by zero. Be sure to test many plausible multiplications to ensure your system works!"}}