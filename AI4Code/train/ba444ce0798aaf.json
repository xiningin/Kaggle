{"cell_type":{"1a5caeef":"code","ce19e1ca":"code","12dc16ec":"code","c9b05f75":"code","b438ab49":"code","7326eb48":"code","902a8731":"code","3f24ea13":"code","e09954ad":"code","0821860f":"code","434431e8":"code","4e94fb72":"code","5a80979d":"code","e1505e5c":"code","384c69ca":"code","3d84ab34":"code","f6c0e820":"code","d58a8f49":"code","49c95d49":"code","535232f2":"code","fceb1d87":"code","6ce1617e":"code","57745644":"code","2803b4f0":"code","81f623f0":"code","9baadaad":"code","e0251542":"code","28904a9d":"code","03226fec":"code","39541f26":"code","c35bf52f":"code","dba9ebec":"code","67e03713":"code","0d75e5c2":"markdown","a217ad8e":"markdown","d0ef6caf":"markdown","fc12a3d7":"markdown","eee90a51":"markdown","ab340fee":"markdown","cdc1e7df":"markdown","4b024c27":"markdown","e80285a2":"markdown","22a65ac5":"markdown","22012576":"markdown","c57b1af4":"markdown","f4c9750d":"markdown","c7ec0f8d":"markdown","d8cc3b5e":"markdown"},"source":{"1a5caeef":"import warnings \nwarnings.filterwarnings('ignore')\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n%matplotlib inline\nimport matplotlib.pyplot as plt  # Matlab-style plotting\nimport seaborn as sns\nimport statsmodels.api as sm\n\ncolor = sns.color_palette()\nsns.set_style('darkgrid')\n","ce19e1ca":"from subprocess import check_output\nprint(check_output(['ls', '..\/input']).decode('utf-8'))","12dc16ec":"train = pd.read_csv('..\/input\/demand-forecasting-kernels-only\/train.csv')\ntrain['date'] = pd.to_datetime(train['date'], format=\"%Y-%m-%d\")\n\ntrain.head()","c9b05f75":"# per 1 store, 1 item\ntrain_df = train[train['store']==1]\ntrain_df = train_df[train['item']==1]\n# train_df = train_df.set_index('date')\ntrain_df['year'] = train['date'].dt.year\ntrain_df['month'] = train['date'].dt.month\ntrain_df['day'] = train['date'].dt.dayofyear\ntrain_df['weekday'] = train['date'].dt.weekday\n\ntrain_df.head()","b438ab49":"sns.lineplot(x=\"date\", y=\"sales\",legend = 'full' , data=train_df)","7326eb48":"sns.lineplot(x=\"date\", y=\"sales\",legend = 'full' , data=train_df[:28])","902a8731":"sns.boxplot(x=\"weekday\", y=\"sales\", data=train_df)","3f24ea13":"train_df = train_df.set_index('date')\ntrain_df['sales'] = train_df['sales'].astype(float)\n\ntrain_df.head()","e09954ad":"from statsmodels.tsa.seasonal import seasonal_decompose\nresult = seasonal_decompose(train_df['sales'], model='additive', freq=365)\n\nfig = plt.figure()  \nfig = result.plot()  \nfig.set_size_inches(15, 12)","0821860f":"from statsmodels.tsa.stattools import adfuller\ndef test_stationarity(timeseries, window = 12, cutoff = 0.01):\n\n    #Determing rolling statistics\n    rolmean = timeseries.rolling(window).mean()\n    rolstd = timeseries.rolling(window).std()\n\n    #Plot rolling statistics:\n    fig = plt.figure(figsize=(12, 8))\n    orig = plt.plot(timeseries, color='blue',label='Original')\n    mean = plt.plot(rolmean, color='red', label='Rolling Mean')\n    std = plt.plot(rolstd, color='black', label = 'Rolling Std')\n    plt.legend(loc='best')\n    plt.title('Rolling Mean & Standard Deviation')\n    plt.show()\n    \n    #Perform Dickey-Fuller test:\n    print('Results of Dickey-Fuller Test:')\n    dftest = adfuller(timeseries, autolag='AIC', maxlag = 20 )\n    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\n    for key,value in dftest[4].items():\n        dfoutput['Critical Value (%s)'%key] = value\n    pvalue = dftest[1]\n    if pvalue < cutoff:\n        print('p-value = %.4f. The series is likely stationary.' % pvalue)\n    else:\n        print('p-value = %.4f. The series is likely non-stationary.' % pvalue)\n    \n    print(dfoutput)\n","434431e8":"test_stationarity(train_df['sales'])","4e94fb72":"first_diff = train_df.sales - train_df.sales.shift(1)\nfirst_diff = first_diff.dropna(inplace = False)\ntest_stationarity(first_diff, window = 12)","5a80979d":"import statsmodels.api as sm\n\nfig = plt.figure(figsize=(12,8))\nax1 = fig.add_subplot(211)\nfig = sm.graphics.tsa.plot_acf(train_df.sales, lags=40, ax=ax1) # \nax2 = fig.add_subplot(212)\nfig = sm.graphics.tsa.plot_pacf(train_df.sales, lags=40, ax=ax2)# , lags=40","e1505e5c":"fig = plt.figure(figsize=(12,8))\nax1 = fig.add_subplot(211)\nfig = sm.graphics.tsa.plot_acf(first_diff, lags=40, ax=ax1)\nax2 = fig.add_subplot(212)\nfig = sm.graphics.tsa.plot_pacf(first_diff, lags=40, ax=ax2)\n\n# Here we can see the acf and pacf both has a recurring pattern every 7 periods. Indicating a weekly pattern exists. \n# Any time you see a regular pattern like that in one of these plots, you should suspect that there is some sort of \n# significant seasonal thing going on. Then we should start to consider SARIMA to take seasonality into accuont","384c69ca":"arima_mod6 = sm.tsa.ARIMA(train_df.sales, (6,1,0)).fit(disp=False)\nprint(arima_mod6.summary())","3d84ab34":"from scipy import stats\nfrom scipy.stats import normaltest\n\nresid = arima_mod6.resid\nprint(normaltest(resid))\n# returns a 2-tuple of the chi-squared statistic, and the associated p-value. the p-value is very small, meaning\n# the residual is not a normal distribution\n\nfig = plt.figure(figsize=(12,8))\nax0 = fig.add_subplot(111)\n\nsns.distplot(resid ,fit = stats.norm, ax = ax0) # need to import scipy.stats\n\n# Get the fitted parameters used by the function\n(mu, sigma) = stats.norm.fit(resid)\n\n#Now plot the distribution using \nplt.legend(['Normal dist. ($\\mu=$ {:.2f} and $\\sigma=$ {:.2f} )'.format(mu, sigma)], loc='best')\nplt.ylabel('Frequency')\nplt.title('Residual distribution')\n\n\n# ACF and PACF\nfig = plt.figure(figsize=(12,8))\nax1 = fig.add_subplot(211)\nfig = sm.graphics.tsa.plot_acf(arima_mod6.resid, lags=40, ax=ax1)\nax2 = fig.add_subplot(212)\nfig = sm.graphics.tsa.plot_pacf(arima_mod6.resid, lags=40, ax=ax2)","f6c0e820":"sarima_mod6 = sm.tsa.statespace.SARIMAX(train_df.sales, trend='n', order=(6,1,0)).fit()\nprint(sarima_mod6.summary())","d58a8f49":"resid = sarima_mod6.resid\nprint(normaltest(resid))\n\nfig = plt.figure(figsize=(12,8))\nax0 = fig.add_subplot(111)\n\nsns.distplot(resid ,fit = stats.norm, ax = ax0) # need to import scipy.stats\n\n# Get the fitted parameters used by the function\n(mu, sigma) = stats.norm.fit(resid)\n\n#Now plot the distribution using \nplt.legend(['Normal dist. ($\\mu=$ {:.2f} and $\\sigma=$ {:.2f} )'.format(mu, sigma)], loc='best')\nplt.ylabel('Frequency')\nplt.title('Residual distribution')\n\n\n# ACF and PACF\nfig = plt.figure(figsize=(12,8))\nax1 = fig.add_subplot(211)\nfig = sm.graphics.tsa.plot_acf(arima_mod6.resid, lags=40, ax=ax1)\nax2 = fig.add_subplot(212)\nfig = sm.graphics.tsa.plot_pacf(arima_mod6.resid, lags=40, ax=ax2)","49c95d49":"start_index = 1730\nend_index = 1826\ntrain_df['forecast'] = sarima_mod6.predict(start = start_index, end= end_index, dynamic= True)  \ntrain_df[start_index:end_index][['sales', 'forecast']].plot(figsize=(12, 8))","535232f2":"def smape_kun(y_true, y_pred):\n    mape = np.mean(abs((y_true-y_pred)\/y_true))*100\n    smape = np.mean((np.abs(y_pred - y_true) * 200\/ (np.abs(y_pred) + np.abs(y_true))).fillna(0))\n    print('MAPE: %.2f %% \\nSMAPE: %.2f'% (mape,smape), \"%\")","fceb1d87":"smape_kun(train_df[1730:1825]['sales'],train_df[1730:1825]['forecast'])","6ce1617e":"# per 1 store, 1 item\nstoreid = 1\nitemid = 1\ntrain_df = train[train['store']==storeid]\ntrain_df = train_df[train_df['item']==itemid]\n\n# train_df = train_df.set_index('date')\ntrain_df['year'] = train_df['date'].dt.year - 2012\ntrain_df['month'] = train_df['date'].dt.month\ntrain_df['day'] = train_df['date'].dt.dayofyear\ntrain_df['weekday'] = train_df['date'].dt.weekday\n\nstart_index = 1730\nend_index = 1826\n\n# train_df.head()","57745644":"holiday = pd.read_csv('..\/input\/holiday\/USholidays.csv',header=None, names = ['date', 'holiday'])\nholiday['date'] = pd.to_datetime(holiday['date'], yearfirst = True, format = '%y\/%m\/%d')\nholiday.head()","2803b4f0":"train_df = train_df.merge(holiday, how='left', on='date')\ntrain_df['holiday_bool'] = pd.notnull(train_df['holiday']).astype(int)\ntrain_df = pd.get_dummies(train_df, columns = ['month','holiday','weekday'] , prefix = ['month','holiday','weekday'])\n# train_df.head()\n# train_df.shape\n# train_df.columns","81f623f0":"ext_var_list = ['date','year', 'day', 'holiday_bool',\n       'month_1', 'month_2', 'month_3', 'month_4', 'month_5', 'month_6',\n       'month_7', 'month_8', 'month_9', 'month_10', 'month_11', 'month_12',\n       'holiday_Christmas Day', 'holiday_Columbus Day',\n       'holiday_Independence Day', 'holiday_Labor Day',\n       'holiday_Martin Luther King Jr. Day', 'holiday_Memorial Day',\n       'holiday_New Year Day', 'holiday_Presidents Day (Washingtons Birthday)',\n       'holiday_Thanksgiving Day', 'holiday_Veterans Day', 'weekday_0',\n       'weekday_1', 'weekday_2', 'weekday_3', 'weekday_4', 'weekday_5',\n       'weekday_6']","9baadaad":"exog_data = train_df[ext_var_list]\nexog_data = exog_data.set_index('date')\nexog_data.head()","e0251542":"train_df = train_df.set_index('date')\n# train_df = train_df.reset_index()\ntrain_df.head()\n","28904a9d":"start_index = '2017-10-01'\nend_index = '2017-12-31'\n# exog_data.head()","03226fec":"%%time\nsarimax_mod6 = sm.tsa.statespace.SARIMAX(endog = train_df.sales[:start_index],\n                                        exog = exog_data[:start_index],  \n                                        trend='n', order=(6,1,0), seasonal_order=(0,1,1,7)).fit()\nprint(sarimax_mod6.summary())","39541f26":"start_index = '2017-10-01'\nend_index = '2017-12-30'\nend_index1 = '2017-12-31'","c35bf52f":"sarimax_mod6.forecast(steps = 121,exog = exog_data[start_index:end_index])","dba9ebec":"train_df['forecast'] = sarimax_mod6.predict(start = pd.to_datetime(start_index), end= pd.to_datetime(end_index1),\n                                            exog = exog_data[start_index:end_index], \n                                            dynamic= True)  \n\ntrain_df[start_index:end_index][['sales', 'forecast']].plot(figsize=(12, 8))","67e03713":"smape_kun(train_df[start_index:end_index]['sales'],train_df[start_index:end_index]['forecast'])","0d75e5c2":"the smaller p-value, the more likely it's stationary. Here our p-value is 0.036. It's actually not bad, if we use a 5% Critical Value(CV), this series would be considered stationary. But as we just visually found an upward trend, we want to be more strict, we use 1% CV.  \nTo get a stationary data, there's many techiniques. We can use log, differencing etc... ","a217ad8e":"Although the graph looks very like a normal distribution. But it failed the test. Also we see a recurring correlation exists in both ACF and PACF. So we need to deal with seasonality.\n\n### Consider seasonality affect by SARIMA\n\n\nhttps:\/\/www.statsmodels.org\/dev\/examples\/notebooks\/generated\/statespace_sarimax_stata.html  \nhttps:\/\/barnesanalytics.com\/sarima-models-using-statsmodels-in-python","d0ef6caf":"After differencing, the p-value is extremely small. Thus this series is very likely to be stationary.  \n\n\n## ACF and PACF\n\nThe partial autocorrelation at lag k is the correlation that results after removing the effect of any correlations due to the terms at shorter lags.\n\n### Autoregression Intuition\nConsider a time series that was generated by an autoregression (AR) process with a lag of k.\n\nWe know that the ACF describes the autocorrelation between an observation and another observation at a prior time step that includes direct and indirect dependence information.\n\nThis means we would expect the ACF for the AR(k) time series to be strong to a lag of k and the inertia of that relationship would carry on to subsequent lag values, trailing off at some point as the effect was weakened.\n\nWe know that the PACF only describes the direct relationship between an observation and its lag. This would suggest that there would be no correlation for lag values beyond k.\n\nThis is exactly the expectation of the ACF and PACF plots for an AR(k) process.\n\n### Moving Average Intuition\nConsider a time series that was generated by a moving average (MA) process with a lag of k.\n\nRemember that the moving average process is an autoregression model of the time series of residual errors from prior predictions. Another way to think about the moving average model is that it corrects future forecasts based on errors made on recent forecasts.\n\nWe would expect the ACF for the MA(k) process to show a strong correlation with recent values up to the lag of k, then a sharp decline to low or no correlation. By definition, this is how the process was generated.\n\nFor the PACF, we would expect the plot to show a strong relationship to the lag and a trailing off of correlation from the lag onwards.\n\nAgain, this is exactly the expectation of the ACF and PACF plots for an MA(k) process.\n### Summary\nFrom the autocorrelation plot we can tell whether or not we need to add MA terms. From the partial autocorrelation plot we know we need to add AR terms.\n\n### References:  \nhttps:\/\/machinelearningmastery.com\/gentle-introduction-autocorrelation-partial-autocorrelation\/\n","fc12a3d7":"## SARIMAX: adding external variables ","eee90a51":"## Make prediction and evaluation\n\nTake the last 30 days in training set as validation data","ab340fee":"## Decompose the time series\nTo start with, we want to decompose the data to seperate the seasonality, trend and residual. Since we have 5 years of sales data. We would expect there's a yearly or weekly pattern. Let's use a function in statsmodels to help us find it. ","cdc1e7df":"Playing with a few frequency, the yearly pattern is very obvious. and also we can see a upwards trend. Which means this data is not stationary.","4b024c27":"## Introduction\n\nARIMA is one of the most classic time series forecasting models. During the modeling process, we mainly want to find 3 parameters. Auto-regression(AR) term, namly the lags of previous value; Integral(I) term for non-stationary differencing and Moving Average(MA) for error term.  \n\nI'm a newbie in this field. Found many online tutorials used grid search technique(auto.arima in R). Meanwhile I also found many hypothesis test to validate the time series, i.e. see if it's stationary, looking at ACF and PACF to suggest a AR term etc... \n\nFacebook has a package called prophet, which is quite complex and consider many things automaticlly. But out of curiosity, I want to understand what's the reasoning behind the model. ARIMA is definitely a good starting point.\n\n### My goal for this notebook:\n1. Understand ARIMA, SARIMA, ARIMAX  \n2. Walkthrough the necessary tests that ARIMA needs to statisfy\n3. Find a set of reasonable parameters base on a statistic tests and visualizations   \n\n### Notebook Outline:\n* ARIMA introduction  \n* Decompose the ts\n* Stationarize the data  \n* Interpret ACF and PACF  \n* Determine p, d, q\n* Adding seasonality: S-ARMIA\n* Adding holiday factors to be SARIMA-X\n\n\n#### A few things on my TODO list:\n- mulitple seasonality\n- outlier detection","e80285a2":"###  Stationarize the data:\n\nWhat does it mean for data to be stationary?\n\nThe mean of the series should not be a function of time. The red graph below is not stationary because the mean increases over time. \n![alt text](https:\/\/imgur.com\/LjtBXwf.png)\n\nThe variance of the series should not be a function of time. This property is known as homoscedasticity. Notice in the red graph the varying spread of data over time. \n![alt text](https:\/\/imgur.com\/v2Uye7X.png)\n\nFinally, the covariance of the i th term and the (i + m) th term should not be a function of time. In the following graph, you will notice the spread becomes closer as the time increases. Hence, the covariance is not constant with time for the \u2018red series\u2019. \n![Imgur](https:\/\/i.imgur.com\/6HVlvg2.png)  \nWhy is this important? When running a linear regression the assumption is that all of the observations are all independent of each other. In a time series, however, we know that observations are time dependent. It turns out that a lot of nice results that hold for independent random variables (law of large numbers and central limit theorem to name a couple) hold for stationary random variables. So by making the data stationary, we can actually apply regression techniques to this time dependent variable.\n\nThere are two ways you can check the stationarity of a time series. The first is by looking at the data. By visualizing the data it should be easy to identify a changing mean or variation in the data. For a more accurate assessment there is the Dickey-Fuller test. I won\u2019t go into the specifics of this test, but if the \u2018Test Statistic\u2019 is greater than the \u2018Critical Value\u2019 than the time series is stationary. Below is code that will help you visualize the time series and test for stationarity.\n\n","22a65ac5":"### Analyze the result\nTo see how our first model perform, we can plot the residual distribution. See if it's normal dist. And the ACF and PACF. For a good model, we want to see the residual is normal distribution. And ACF, PACF has not significant terms.","22012576":"Monday=0, Sunday=6.  \nHere we can find the weekends(5,6) has a larger sales, weekdays(0-4) are smaller. There's a few outliers on Monday, Wed.","c57b1af4":"# Forecast modeling - ARIMA\n\nwe want to start with some basic\/classic model like armia. \nHere is a list of online tutorials that helps me get started:  \nhttp:\/\/www.statsmodels.org\/dev\/examples\/notebooks\/generated\/tsa_arma_0.html  \nhttp:\/\/www.seanabu.com\/2016\/03\/22\/time-series-seasonal-ARIMA-model-in-python\/  \nhttp:\/\/barnesanalytics.com\/basics-of-arima-models-with-statsmodels-in-python\n\nARIMA model includes the AR term, the I term, and the MA term. Let\u2019s actually start with the I term, as it is the easiest to explain. The I term is a full difference. That is today\u2019s value minus yesterday\u2019s value. That\u2019s it.  \nThe way that I like to think of the AR term is that it is a partial difference. The coefficient on the AR term will tell you the percent of a difference you need to take.   \n**MA**  \nA moving average term in a time series model is a past error (multiplied by a coefficient).The label \"moving average\" is is somewhat misleading because the weights 1,\u2212\u03b81,\u2212\u03b82,\u2026,\u2212\u03b8q, which multiply the a's, need not total unity nor need that be positive.  \nXt=\u03b5t+\u03b81\u03b5t\u22121+\u22ef+\u03b8q\u03b5t\u2212q  as akin to a weighted moving average of the \u03b5 terms,\n","f4c9750d":"These model coefficients are not very reliable as most of them are not significant. This would imply a high collinearity between the data.  ","c7ec0f8d":"Because the autocorrelation of the differenced series is negative at lag 7, 14, 21 etc.. (every week), I should an SMA term to the model.   \n## Build the model\n\n### How to determin p, d, q\n\nIt's easy to determin I. In our case, we see the first order differencing make the ts stationary. **I = 1**.\n\nAR model might be investigated first with lag length selected from the PACF or via empirical investigation. In our case, it's clearly that within 6 lags the AR is significant. Which means, we can use ** AR = 6** \n\nTo avoid the potential for incorrectly specifying the MA order (in the case where the MA is first tried then the MA order is being set to 0),  it may often make sense to extend the lag observed from the last significant term in the PACF.\n\nWhat is interesting is that when the AR model is appropriately specified, the the residuals from this model can be used to directly observe the uncorrelated error. This residual can be used to further investigate alternative MA and ARMA model specifications directly by regression.\n\nAssuming an AR(s) model were computed, then I would suggest that the next step in identification is to estimate an MA model with s-1 lags in the uncorrelated errors derived from the regression. The parsimonious MA specification might be considered and this might be compared with a more parsimonious AR specification. Then ARMA models might also be analysed.\n### Reference:\nhttps:\/\/www.researchgate.net\/post\/How_does_one_determine_the_values_for_ARp_and_MAq   \nhttps:\/\/stats.stackexchange.com\/questions\/281666\/how-does-acf-pacf-identify-the-order-of-ma-and-ar-terms\/281726#281726  \nhttps:\/\/stats.stackexchange.com\/questions\/134487\/analyse-acf-and-pacf-plots?rq=1  ","d8cc3b5e":"### Some last words:\n\nARIMA makes much more sense to me now. ACF and PACF are useful to determine the p, d, q. And each test is indeed helping me to justify whether I'm getting a better model or worse one. \n\n\nPros:  \n* Intepretability: Each coefficient means a specific thing\n* ts key elements understanding: the concept of lags, and error lag terms are very unique, ARIMA gave a comprehensive cover on them. So even in the future I want to try some other regression model. I would add the lag terms and consider the error term. \n\nCons:  \n* Inefficiency: ARIMA needs to be run on each time series, since we have 500 store\/item combinations, it needs to run 500 times. Every time we want to forecast the future, say on Jan 2, 2018, we want to forecast next 90 days. We need to re-run ARIMA. \n\n"}}