{"cell_type":{"44de9e09":"code","02125b06":"code","9f01e6d2":"code","dedd8e4c":"code","5fddcad8":"code","2d7a6012":"code","7a3d8b86":"markdown"},"source":{"44de9e09":"# default library for data handling\nimport numpy as np \nimport pandas as pd \nimport seaborn as sns\n\n# matplotlib series\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nimport random\n\n# HTML \nfrom IPython.display import HTML\n\n#image saving\nimport os\nimport imageio","02125b06":"# Constants\nboxLength = 200 #defines how fine of a mesh to use\n\ngifTitle = 'simulationGif.gif' #title for the gif\n\n# Nucleation and Growth Constants\nTemp = 430\n\nz = 400 # pre-exponential\nK1 = 200 # pre-exponential\nG_nucleation = 0.2 #Nucleation energy eV\/K\nQdiff = 0.1 #Activation energy for diffusion eV\/K\nk = 8.617*10**-5 # Boltzmann constant eV\/K\nTm=500 #Melting Temp\nC = 340 # pre-exponential (temperature independent)\nQgrowth = 0.2 # activation energy for boundary motion\/growth eV\/K\n\nGstar = K1*1\/(Tm-Temp)**2 #driving force for nucleation due to undercooling\nNhomo=z*np.exp(-Gstar\/(Temp*k))*np.exp(-Qdiff\/(Temp*k)) #homogeneous nucleation rate\n\nnucleationRate = Nhomo #3 #per unit time\nnucleationRateSTD = 0.1 #nucleation rate STD to use during sampling\nshapeFactor = 0.2 #heterogeneous nucleation shape factor. If set to anything above 1 then heterogeneous nucleation is suspended\n\ngrowthRate = C*np.exp(-Qgrowth\/(k*Temp))\n\n# Timing Constants\ntotalTime = 25\ndt = 0.5\n\n#Grid to hold the positions\n#each x,y position will either be 1 (indicating empty or uncrystallizated space) or a number which indicates the nuclei it is a part of.\ngrid = np.zeros([boxLength,boxLength])\n\nnuclei = [] \n#each row will consist of a unique nuclei\n#0: x center position\n#1: y center position\n#2: time of initilization of nucleiand time of initialization for the nuclei\n#3: color\/number assignment of nuclei\n#4: binary indicator of whether the nuclei is still growing or not. 1==growing 0==stopped growing, totally impinged\n\n#Generate Random Colormap to color the grains\nvals = np.linspace(0,1,256)\nnp.random.shuffle(vals)\nmyCmap = plt.cm.colors.ListedColormap(plt.cm.jet(vals))\nmyCmap.set_under(color='black')","9f01e6d2":"def grainSize(grid,numBins=20):\n    #Fucntion to calculate the grain size distribution\n    \n    grainSizes = []\n    \n    #Cycle through each unique grain\n    for g in range(int(np.amax(grid))):\n        \n        gridCount = np.count_nonzero(grid == g)\n        \n        if gridCount>0: \n            grainSizes.append((gridCount\/3.1415)**0.5)\n            \n    ax = sns.histplot(data=grainSizes, bins=numBins)\n    ax.set(xlabel='Grain Size [A.U.]')\n    \n    return grainSizes\n\ndef newNucleiPos(grid,nucleationRate,nucleationRateSTD,dt,boxLength,shapeFactor=1):\n    #Function to return the positions of the new nuclei given the current state fo the simulation\n    \n    #Calc total number of new nuclei from homogenous nucleation\n    newNuclei=round(np.random.normal(nucleationRate,nucleationRateSTD)*dt)\n    centers = np.zeros([1,1]).astype(int)\n    \n    if newNuclei>0 and 0 in grid:\n        \n        centers = np.zeros([newNuclei,2]).astype(int)\n\n        for i in range(newNuclei):\n            notFound = 1\n            #Loop until a fresh site is found\n            while notFound==1:         \n                    \n                cent = np.array([random.randint(0, boxLength-1),random.randint(0, boxLength-1)])\n                #cent = cent.round()   \n                cent = cent.astype(int)\n                if grid[cent[0],cent[1]]==0:\n                    notFound=0\n                    centers[i] = cent\n                    \n    #Calc total number of new nuclei from heterogenous nucleation\n    if shapeFactor<1:\n        \n        newHeteroNuclei=round(np.random.normal(nucleationRate\/shapeFactor,nucleationRateSTD)*dt)\n        \n        #Specify all the edge locations\n        edgeLocs = []\n        numEmptyEdges=0\n        \n        for pos in range(boxLength):\n            if grid[boxLength-1,pos]==0:\n                edgeLocs.append([boxLength-1,pos])\n                numEmptyEdges=numEmptyEdges+1\n            if grid[pos,0]==0:\n                edgeLocs.append([pos,0])\n                numEmptyEdges=numEmptyEdges+1\n            if grid[pos,boxLength-1]==0:\n                edgeLocs.append([pos,boxLength-1])\n                numEmptyEdges=numEmptyEdges+1\n                \n        #Use the edge locations\n        if newHeteroNuclei>0 and numEmptyEdges>1:\n        \n            #Only create as many hetergenous nuclei as are edge spaces available\n            if newHeteroNuclei>numEmptyEdges:\n                newHeteroNuclei=numEmptyEdges\n                \n            Hetcenters = np.zeros([newHeteroNuclei,2]).astype(int)\n\n            for i in range(newHeteroNuclei):\n                \n                #Select a random index and then add it as a grain center\n                \n                randIndex = random.randint(0, len(edgeLocs)-1)\n                cent = np.array([edgeLocs[randIndex][0],edgeLocs[randIndex][1]])\n                Hetcenters[i] = cent\n                \n                #Remove the position from the list as a nucleation site\n                edgeLocs.remove([edgeLocs[randIndex][0],edgeLocs[randIndex][1]])\n                \n            #Concatenate the points\n            if len(centers)>1:\n                centers=np.concatenate((centers, Hetcenters), axis=0)\n            else:\n                centers=Hetcenters    \n            \n    return centers\n\ndef findGrowthSlice(gridLength,growthRate,pos,dt,currentTime,nucleationTime):\n    #Function to find the matrix positions that the the grain should grow into during the timestep\n    \n    #Center position\n    x = pos[0]\n    y = pos[1]\n    \n    posArray = []\n    \n    #Do not grow the nuclei during the the step they are initialized\n    if (currentTime-nucleationTime>0): \n        \n        #Find the start and end radius for the growth slice\n        startRadii = growthRate*(currentTime-nucleationTime-dt)\n        endRadii = growthRate*(currentTime-nucleationTime)\n        \n        for dy in range(0,int(endRadii)+1):\n            for dx in range(0,int(endRadii)+1):\n                radialdist = ((dx)**2 + (dy)**2 )**0.5\n                \n                #Add the dx\/dy combination is within the slice add the position\n                if (radialdist < endRadii): #and (radialdist>startRadii):\n                    \n                    if (x-dx)>-1 and (x-dx)<gridLength and (y-dy)>-1 and (y-dy)<gridLength:\n                        posArray.append([x-dx,y-dy])\n                        \n                    if (x+dx)>-1 and (x+dx)<gridLength and (y-dy)>-1 and (y-dy)<gridLength:\n                        posArray.append([x+dx,y-dy])\n                        \n                    if (x-dx)>-1 and (x-dx)<gridLength and (y+dy)>-1 and (y+dy)<gridLength:\n                        posArray.append([x-dx,y+dy])\n                        \n                    if (x+dx)>-1 and (x+dx)<gridLength and (y+dy)>-1 and (y+dy)<gridLength:\n                        posArray.append([x+dx,y+dy])\n\n    return posArray\n\ndef growNuclei(grid,growthRate,nuclei,dt,totalTime):\n    #Function to grow each of the nuclei\n    theGrid = grid.shape\n    gridLen = theGrid[0]\n    \n    for nuc in nuclei:\n        \n        #Grow the nuclei if it isn't completely impinged\n        if nuc[4]==1:\n            #Find the new positions that the nuclei will grow into\n            growthPositions = findGrowthSlice(gridLen,growthRate,nuc[0:2],dt,totalTime,nuc[2])\n            \n            #Take an initial count of the number of nuclei positions\n            #initialCount = np.count_nonzero(grid == nuc[3])\n            anyAdded=0\n\n            #Grow the nucli if the space is unoccupied\n            for newPos in growthPositions:\n                if grid[newPos[0],newPos[1]]==0:\n                    grid[newPos[0],newPos[1]]=nuc[3] #set the color\n                    anyAdded=1\n                    \n            #If the growth is complete impinged then stop further growth\n            #if len(growthPositions)>0 and initialCount == np.count_nonzero(grid == nuc[3]) and totalTime-nuc[2]>0:\n            \n            if anyAdded==0 and len(growthPositions)>0 and totalTime-nuc[3]-dt>0:\n                nuc[4]=0\n                \n    return grid\n            ","dedd8e4c":"def mainSolidify(nucleationRate,nucleationRateSTD,dt,totalTime,boxLength,shapeFactor,myCmap,plotGrains=True):\n    #Function to facilitate a solidification simulation\n    \n    #Filenames of all the images\n    filenames = []\n    \n    grid = np.zeros([boxLength,boxLength]) #Empty grid\n    nuclei = []  #Empty list for the nuclei\n    \n    #Figure to plot\n    fig, ax = plt.subplots(1, 1)\n    \n    iter=0 #counts the number of simulation iterations\n    nucColorIter=0 #counts the number of nuclei and also assigns color\n    \n    #Main loop to run simulation\n    for t in np.arange(0,totalTime,dt):\n\n        #Find the new nuclei positions\n        newNuclei = newNucleiPos(grid,nucleationRate,nucleationRateSTD,dt,boxLength,shapeFactor)\n\n        #Find whether or not new nuclei were added\n        nucliShape = newNuclei.shape\n\n        areNewNucli=nucliShape[1] #will be 1 if no new nuclei, 2 if so\n        numNewNuclei = nucliShape[0]\n\n        #Update the array if there are new nuclei\n        if areNewNucli==2:\n            for i in range(numNewNuclei):  \n                nucColorIter=nucColorIter+1\n                grid[newNuclei[i,0],newNuclei[i,1]]=nucColorIter\n\n                #Update the list the holds all the nuclei positions\n                nuclei.append([newNuclei[i,0],newNuclei[i,1],t,nucColorIter,1])\n\n        #Grow the nuclei\n        grid=growNuclei(grid,growthRate,nuclei,dt,t)\n\n        ## Save the images as the figure is updated\n        if plotGrains:\n            #plt.imshow(grid,cmap=\"inferno\")\n            plt.imshow(grid,cmap=myCmap, vmin=1, vmax=300,interpolation='none')\n            plt.title(\"t={}\".format(t))\n\n            # create file name and append it to a list\n            filename = f'{iter}.png'\n            iter=iter+1\n            filenames.append(filename)\n\n            # save frame\n            plt.savefig(filename)\n            plt.close()\n            \n            # Optional: Progress Printing\n            #print(\"Iteration: {}\".format(iter))\n            #print(\"Time: {}\/{}\".format(t,totalTime))\n            #print(\"Nuclei: {}\".format(iter))\n            \n            # Optional: Early stop:check to see if all spaces have been consumed - if so, end the simulation\n            #if (grid==0).any()==False:\n            #         np.savetxt(\"grid.csv\", grid, delimiter=\",\")\n            #         return filenames\n            \n    #Calculate the final grain sizes\n    gSize = grainSize(grid) #plots the grain size distribution\n\n    # Save final grid as textfile\n    np.savetxt(\"grid.csv\", grid, delimiter=\",\")\n    \n    return filenames\n    ","5fddcad8":"fnames=mainSolidify(nucleationRate,nucleationRateSTD,dt,totalTime,boxLength,shapeFactor,myCmap,plotGrains=True)","2d7a6012":"#Generate the gif \nwith imageio.get_writer(gifTitle, mode='I') as writer:\n    for filename in fnames:\n        image = imageio.imread(filename)\n        writer.append_data(image)\n        \n# Remove files\nfor filename in set(fnames):\n    os.remove(filename)","7a3d8b86":"![](.\/simulationGif.gif)"}}