{"cell_type":{"5aca77bd":"code","44fc1585":"code","ee03e76b":"code","ed8237a2":"code","95143956":"code","757b8cc5":"code","ee0caa14":"code","18d84125":"code","d6ab5059":"code","00cbdec5":"code","7188778c":"code","a4d66009":"code","25d91228":"code","47c7c1aa":"code","29f568da":"code","0840c6e2":"code","74628b91":"code","9ec0a14c":"code","437b46ef":"code","fa2e762d":"code","bb1f06ac":"code","22b66f93":"code","af6dafab":"code","4c876830":"code","0a08f95c":"code","f36dc5ac":"code","dc4046b5":"code","983ab6cf":"code","f37001fb":"code","1618c895":"code","8952e4e0":"code","8d1f99c7":"code","f71e7d29":"code","504edbe4":"code","e15acd1a":"code","ea1f076e":"code","5af7dae3":"code","b5f807c6":"code","39bd0fff":"code","48f3891f":"code","30432008":"code","cf2265ce":"code","1efdd450":"code","f7807452":"code","7f49887b":"code","6abaf805":"code","7b61201e":"code","d85a3834":"code","03d5fd2e":"code","3e104db9":"code","2b2ef459":"code","185cef1f":"code","55e8edd4":"code","0e26d1c3":"code","0b4ff267":"code","d2e84ab9":"code","794160ae":"code","27e7372a":"code","e2dfd1b6":"code","e5d51032":"code","5b4b10d3":"code","cd1c2272":"code","d3f7e6ee":"code","9999bcd0":"code","ce74dda9":"code","55c449f0":"code","82bf6826":"code","e40b94c4":"code","58238a54":"code","e2b41736":"code","8bc33f33":"code","ab11b84c":"code","8dffbae3":"code","e2cc92fa":"markdown"},"source":{"5aca77bd":"import warnings\nwarnings.filterwarnings(\"ignore\")\nfrom sklearn import preprocessing\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom prettytable import PrettyTable\nfrom sklearn.linear_model import SGDRegressor\nfrom sklearn.metrics import mean_squared_error\nfrom numpy import random\nfrom sklearn.model_selection import train_test_split\nimport os\nfrom matplotlib import cm\nfrom matplotlib.ticker import LinearLocator, FormatStrFormatter\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.utils import resample\nfrom sklearn.metrics import r2_score\nfrom random import seed\nfrom random import randrange\nimport timeit\nimport tensorflow as tf\nfrom sklearn.metrics import fbeta_score\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import accuracy_score","44fc1585":"%load_ext autoreload\n%autoreload \n%reload_ext autoreload\nimport utility_script_multi_sklearn as us","ee03e76b":"SNOMED_scored=pd.read_csv(\"..\/input\/featurized-physionet-challenge-2020-data\/SNOMED_mappings_scored.csv\", sep=\";\")\nSNOMED_unscored=pd.read_csv(\"..\/input\/featurized-physionet-challenge-2020-data\/SNOMED_mappings_unscored.csv\", sep=\";\")","ed8237a2":"data = pd.read_csv('..\/input\/featurized-physionet-challenge-2020-data\/ecg_data_with_labels.csv')","95143956":"conf_weights = pd.read_csv(\"..\/input\/featurized-physionet-challenge-2020-data\/weights.csv\", sep=\",\", header= 0, index_col=0 )","757b8cc5":"data.head()","ee0caa14":"print(np.where(data.iloc[:,:-1].isna()))\nprint(data.index[np.isinf(data.iloc[:,:-1]).any(1)])\n#print(data.columns.to_series()[np.isinf(data.iloc[:,:-1]).any()])","18d84125":"data.shape","d6ab5059":"data = data.dropna()","00cbdec5":"#data = data.replace([np.inf, -np.inf], 0)","7188778c":"data.shape","a4d66009":"print(np.where(data.iloc[:,1:-1].isna()))\nprint(data.index[np.isinf(data.iloc[:,1:-1]).any(1)])\n#print(data.columns.to_series()[np.isinf(data.iloc[:,1:-1]).any()])","25d91228":"y_data = data['labels']","47c7c1aa":"X_data = data.iloc[:,1:-1]","29f568da":"data.iloc[:,1:]","0840c6e2":"import seaborn as sns\nplt.figure(figsize=(30,30))\ncor = data.iloc[:,1:].corr()\nsns.heatmap(cor, cmap=\"rocket_r\", annot=True,cbar=False, annot_kws={\"size\": 3})\nplt.show()","74628b91":"def making_undef_class(labels):\n    df_labels = pd.DataFrame(labels)\n    for i in range(len(SNOMED_unscored.iloc[0:,1])):\n        df_labels.replace(to_replace=str(SNOMED_unscored.iloc[i,1]), inplace=True ,value=\"undefined class\", regex=True)\n    return df_labels\n\n  \ndf_y = making_undef_class(y_data)","9ec0a14c":"y_data.unique()","437b46ef":"from sklearn.preprocessing import MultiLabelBinarizer\none_hot = MultiLabelBinarizer()\ny=one_hot.fit_transform(df_y['labels'].str.split(pat=','))\nprint(one_hot.classes_)\nprint(\"classes: {}\".format(y.shape[1]))","fa2e762d":"y = np.delete(y, -1, axis=1)","bb1f06ac":"norsk_liste = ['pacing-rytme', 'forlenget qt-intervall', 'atrieflimmer','atrieflutter','venstre grenblokk','unormal Q-b\u00f8lge','unormal T-b\u00f8lge','forlenget PR-intervall', 'ventrikul\u00e6re premature slag','lav QRS-spenning','1.grads AV-blokk','prematur atriell kontraksjon',\n               'venstre akse avvik','sinusbradykardi','bradykardi','sinus rytme', 'sinus takykardi', 'prematur ventrikul\u00e6r kontraksjon','sinusarytmi','venstre fremre fascikul\u00e6rblokk','h\u00f8yre akse avvik','h\u00f8yre grenblokk','invertert T-b\u00f8lge','supraventrikul\u00e6re premature slag',\n               'uspesifikk intraventrikul\u00e6r ledningsforstyrrelse','ufullstendig h\u00f8yre grenblokk','komplett h\u00f8yre grenblokk']","22b66f93":"us.plot_classes(one_hot.classes_[0:-1],SNOMED_scored, y)","af6dafab":"#@title Transform our One Hot encoded multilabel output to a new type of label where all can be represented by a number:\nfrom sklearn.preprocessing import LabelEncoder\n\ndef get_new_labels(y):\n    y_new = LabelEncoder().fit_transform([''.join(str(l)) for l in y])\n    return y_new\n\ny_temp_new = get_new_labels(y)\nprint(\"Total number of unique combinations of diagnosis: {}\".format(len(np.unique(y_temp_new))))","4c876830":"us.plot_classes_2(one_hot.classes_[0:-1],y,SNOMED_scored,norsk_liste)","0a08f95c":"one_hot.classes_[0:-1][26]","f36dc5ac":"abbrev=[]\nfor i in one_hot.classes_[0:-1]:\n    for j,k in enumerate(SNOMED_scored.iloc[:,0]):\n        if i == k:\n            abbrev.append(SNOMED_scored.iloc[j,2])\nabbrev = np.asarray(abbrev)","dc4046b5":"#test_index = []\n#for i in range(len(y.T)):\n#    test_index.append(np.random.choice(np.where(y.T[i] == 1)[0],size = 110, replace=False))\n#test_index = np.unique(np.array(test_index).ravel())","983ab6cf":"#X_train_val = X_data.drop(X_data.iloc[test_index].index)\n#y_train_val = np.delete(y,test_index,axis=0)\n#X_test = X_data.iloc[test_index]\n#y_test = y[test_index]","f37001fb":"#print(X_train_val.shape)\n#print(y_train_val.shape)\n#print(X_test.shape)\n#print(y_test.shape)","1618c895":"#us.plot_classes_2(one_hot.classes_[0:-1],y_test,SNOMED_scored,norsk_liste)","8952e4e0":"#us.plot_classes_2(one_hot.classes_[0:-1],y_train_val,SNOMED_scored,norsk_liste)","8d1f99c7":"#@title Transform our One Hot encoded multilabel output to a new type of label where all can be represented by a number:\nfrom sklearn.preprocessing import LabelEncoder\n\ndef get_new_labels(y):\n    y_new = LabelEncoder().fit_transform([''.join(str(l)) for l in y])\n    return y_new\n\ny_new = get_new_labels(y)\nprint(\"Total number of unique combinations of diagnosis in train set: {}\".format(len(np.unique(y_new))))","f71e7d29":"#@title K-fold, 10 splits, Shuffle=True and random_state = 42. The distribution of Training and Val data in each fold is now:\nfrom sklearn.model_selection import StratifiedKFold\nfolds = list(StratifiedKFold(n_splits=10, shuffle=True, random_state=42).split(y,y_new))\nprint(\"Training split: {}\".format(len(folds[0][0])))\nprint(\"Validation split: {}\".format(len(folds[0][1])))","504edbe4":"#@title The distribution of diagnosis in each Fold:\nX_axis_labels=one_hot.classes_[0:-1]\nplt.figure(figsize=(20,100))\nh=1\nfor i in range(len(folds)):\n    plt.subplot(10,2,h)\n    plt.subplots_adjust(hspace=1.0)\n    plt.bar(x= X_axis_labels, height=y[folds[i][0]].sum(axis=0))\n    plt.title(\"Distribution of Diagnosis - Training set - Fold {}\".format(i+1) ,fontsize=\"20\", color = \"black\")\n    plt.tick_params(axis=\"both\", colors = \"black\")\n    plt.xticks(rotation=90, fontsize=10)\n    plt.yticks(fontsize = 10)\n    #plt.xlabel(\"Diagnosis\", color = \"white\")\n    plt.ylabel(\"Count\", color = \"black\")\n    h=h+1\n    plt.subplot(10,2,h)\n    plt.subplots_adjust(hspace=1.0)\n    plt.bar(x= X_axis_labels, height=y[folds[i][1]].sum(axis=0))\n    plt.title(\"Distribution of Diagnosis - Validation set - Fold {}\".format(i+1) ,fontsize=\"20\", color = \"black\")\n    plt.tick_params(axis=\"both\", colors = \"black\")\n    #plt.xlabel(\"Diagnosis\", color = \"white\")\n    plt.ylabel(\"Count\", color = \"black\")\n    plt.xticks(rotation=90, fontsize=10)\n    plt.yticks(fontsize = 10)\n    h=h+1","e15acd1a":"!pip install scikit-multilearn","ea1f076e":"import seaborn as sns\nconf_weights.columns = SNOMED_scored.iloc[:,0]\nconf_weights.index = SNOMED_scored.iloc[:,0]\n\nconf_weights = pd.DataFrame(conf_weights, columns=SNOMED_scored.iloc[:,0], index = SNOMED_scored.iloc[:,0])\n\nconf_weights.columns=abbrev\nconf_weights.index = abbrev\nconf_weights.index.name = 'Virkelig'\nconf_weights.columns.name = 'Predikert'\n\nplt.figure(figsize = (12,10))\nsns.set(font_scale=1.4)#for label size\nsns.heatmap(conf_weights, cmap=\"rocket_r\", annot=True,cbar=False, annot_kws={\"size\": 10})# font size\nplt.savefig(\".\/confmatrix_weights.png\",dpi=300)","5af7dae3":"!pip install arff","b5f807c6":"my_cluster = []\nfor i in range(len(y.T)):\n    my_cluster.append(np.unique(np.where(y[np.where(y.T[i]==1)])[1]))","39bd0fff":"from skmultilearn.ensemble import LabelSpacePartitioningClassifier\nfrom skmultilearn.cluster import FixedLabelSpaceClusterer\nfrom skmultilearn.problem_transform import LabelPowerset\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.neural_network import MLPClassifier\n\nclassifier_MLP = LabelSpacePartitioningClassifier(\n    classifier = LabelPowerset(\n        classifier= MLPClassifier(solver='adam', alpha=0.0001, hidden_layer_sizes=(100,100,100,100,100), verbose=1, max_iter=10, batch_size=100, learning_rate='adaptive', activation='relu',learning_rate_init=0.0001),\n        require_dense = [False, True]\n    ),\n    require_dense = [True, True],\n    clusterer = FixedLabelSpaceClusterer(clusters=my_cluster)\n)","48f3891f":"from skmultilearn.problem_transform import ClassifierChain\nfrom skmultilearn.ensemble import LabelSpacePartitioningClassifier\nfrom skmultilearn.cluster import FixedLabelSpaceClusterer\nfrom skmultilearn.problem_transform import LabelPowerset\nfrom sklearn.ensemble import RandomForestClassifier\nfrom skmultilearn.ensemble import MajorityVotingClassifier\n\nclassifier_cluster_chain = LabelSpacePartitioningClassifier(\n    classifier = ClassifierChain(\n        classifier= RandomForestClassifier(n_jobs=-1,n_estimators=3, verbose=1,class_weight=None),\n        require_dense = [False, True]\n    ),\n    require_dense = [True, True],\n    clusterer = FixedLabelSpaceClusterer(clusters=my_cluster)\n)","30432008":"from skmultilearn.ensemble import LabelSpacePartitioningClassifier\nfrom skmultilearn.cluster import FixedLabelSpaceClusterer\nfrom skmultilearn.problem_transform import LabelPowerset\nfrom sklearn.ensemble import RandomForestClassifier\nfrom skmultilearn.ensemble import MajorityVotingClassifier\n\nclassifier_rf_lb_cluster = LabelSpacePartitioningClassifier(\n    classifier = LabelPowerset(\n        classifier= RandomForestClassifier(n_jobs=-1,n_estimators=5, verbose=1),\n        require_dense = [False, True]\n    ),\n    require_dense = [True, True],\n    clusterer = FixedLabelSpaceClusterer(clusters=my_cluster)\n)","cf2265ce":"from skmultilearn.ensemble import LabelSpacePartitioningClassifier\nfrom skmultilearn.cluster import FixedLabelSpaceClusterer\nfrom skmultilearn.problem_transform import LabelPowerset\nfrom sklearn.ensemble import RandomForestClassifier\nfrom skmultilearn.ensemble import MajorityVotingClassifier\n\nclassifier_rf_lb_cluster_bal = LabelSpacePartitioningClassifier(\n    classifier = LabelPowerset(\n        classifier= RandomForestClassifier(n_jobs=-1,n_estimators=3, verbose=1, class_weight=\"balanced\"),\n        require_dense = [False, True]\n    ),\n    require_dense = [True, True],\n    clusterer = FixedLabelSpaceClusterer(clusters=my_cluster)\n)\n# Score : 0.4961250109543675","1efdd450":"from sklearn.neural_network import MLPClassifier\nclf_mlp = MLPClassifier(solver='adam', alpha=0.0001, hidden_layer_sizes=(200,200,200,200,200), verbose=1, max_iter=10, batch_size=100, learning_rate='adaptive', activation='relu',learning_rate_init=0.0001)","f7807452":"train_index = folds[0][0] \nval_index = folds[0][1]\n    \nX_train, X_val = np.asarray(X_data)[train_index], np.asarray(X_data)[val_index]\ny_train, y_val = y[train_index], y[val_index]\n\n\nscaler = StandardScaler()\nscaler.fit(X_train)\nX_train_scaled = scaler.transform(X_train)\nX_val_scaled = scaler.transform(X_val)\nprint(\"Making a cluster\")\nmy_cluster = []\nfor i in range(len(y_train.T)):\n    my_cluster.append(np.unique(np.where(y_train[np.where(y_train.T[i]==1)])[1]))\nprint(\"Making the model\")\nclassifier = LabelSpacePartitioningClassifier(\n    classifier = ClassifierChain(\n        classifier= RandomForestClassifier(n_jobs=-1,n_estimators=5, verbose=1),\n        require_dense = [False, True]\n    ),\n    require_dense = [True, True],\n    clusterer = FixedLabelSpaceClusterer(clusters=my_cluster)\n)\nclassifier.fit(X_train_scaled,y_train)","7f49887b":"from joblib import dump\ndump(classifier, 'rand_forest_cluster_12lead.joblib') ","6abaf805":"y_pred = classifier.predict(X_val_scaled)","7b61201e":"y_pred = y_pred.todense()\ny_pred = np.asarray(y_pred)","d85a3834":"print(np.argmax(y_pred, axis=1)[0:20])\nprint(np.argmax(y_val,axis=1)[0:20])","03d5fd2e":"us.compute_challenge_metric_for_opt(y_val,y_pred)","3e104db9":"conf_matrix = us.compute_modified_confusion_matrix_nonorm(y_val,y_pred)\n\nnorm_conf_matrix = np.zeros((conf_matrix.shape[0], conf_matrix.shape[1]))\n\nfor i in range(conf_matrix.shape[0]):\n    norm_conf_matrix[i]=conf_matrix[i]\/conf_matrix[i].sum()\n\ndf_conf_matrix = pd.DataFrame(norm_conf_matrix, columns=one_hot.classes_[:-1], index = one_hot.classes_[:-1])\ndf_conf_matrix.index.name = 'y_true'\ndf_conf_matrix.columns.name = 'y_pred'\n\n\nimport seaborn as sns\nplt.figure(figsize = (16,10))\nsns.set(font_scale=1.4)#for label size\nsns.heatmap(df_conf_matrix, cmap=\"rocket_r\", annot=True,annot_kws={\"size\": 10}, fmt=\".2f\", cbar=False)\nplt.title(\"ECG data\", fontsize = 40, color= \"black\")\nplt.xlabel(\"y predicted\",fontsize=30, color= \"black\")\nplt.ylabel(\"y true\",fontsize = 30, color= \"black\")\nplt.yticks(fontsize=20, rotation=0, color= \"black\")\nplt.xticks(fontsize=20, rotation=90, color= \"black\")\nplt.show()","2b2ef459":"'''\nfrom joblib import load\nclf_new = load('\/content\/drive\/My Drive\/logs\/clf_Chain_rand_forest.joblib') \n'''","185cef1f":"!pip install lime","55e8edd4":"import lime\nimport lime.lime_tabular\n","0e26d1c3":"FeatureNames = ['gender','age','R HR STD','R HR median','R HR min', 'R HR max','R HR mean','RMSSD','R amp II std','R amp II min','R amp II min_2', 'R amp leads I', 'R amp leads II', 'R amp lead III', \n                'R amp lead aVR','R amp lead aVL','R amp lead aVF', 'R amp V1','R amp V2','R amp V3','R amp V4','R amp V5','R amp V6','p_offset_std','p_offset_median','p_offset_min','p_offset_max',\n                'mean_p_offset','p_onsets_std','p_onsets_median','p_onsets_min','p_onsets_max','mean_p_onsets','ECG_baseline','p_rate_std','p_rate_median','p_rate_min','p_rate_max','mean_p_rate', \n                'P amp leads I', 'P amp leads II', 'P amp lead III', 'P amp lead aVR','P amp lead aVL','P amp lead aVF', 'P amp V1','P amp V2','P amp V3','P amp V4','P amp V5','P amp V6','q_rate_std',\n                'q_rate_median','q_rate_min','q_rate_max','mean_q_rate','Q amp leads I', 'Q amp leads II', 'Q amp lead III', 'Q amp lead aVR','Q amp lead aVL','Q amp lead aVF', 'Q amp V1','Q amp V2',\n                'Q amp V3','Q amp V4','Q amp V5','Q amp V6','s_rate_std','s_rate_median','s_rate_min','s_rate_max','mean_s_rate','S amp leads I', 'S amp leads II', 'S amp lead III', 'S amp lead aVR',\n                'S amp lead aVL','S amp lead aVF', 'S amp V1','S amp V2','S amp V3','S amp V4','S amp V5','S amp V6','t_rate_std','t_rate_median','t_rate_min','t_rate_max','mean_t_rate',\n                'T amp leads I', 'T amp leads II', 'T amp lead III', 'T amp lead aVR','T amp lead aVL','T amp lead aVF', 'T amp V1','T amp V2','T amp V3','T amp V4','T amp V5','T amp V6','t_offset_std',\n                't_offset_median','t_offset_min','t_offset_max','mean_t_offset','t_onsets_std','t_onsets_median','t_onsets_min','t_onsets_max','mean_t_onsets']","0b4ff267":"explainer = lime.lime_tabular.LimeTabularExplainer(X_train_scaled,training_labels=y_train, mode='classification',feature_names=FeatureNames,class_names=abbrev)","d2e84ab9":"class model_wrapper:\n    # drf is the h2o distributed random forest object, the column_names is the\n    # labels of the X values\n    def __init__(self,model,column_names):\n            \n            self.model = model\n            self.column_names = column_names\n \n    def predict_proba(self,this_array):        \n        # If we have just 1 row of data we need to reshape it\n        shape_tuple = np.shape(this_array)        \n        if len(shape_tuple) == 1:\n            this_array = this_array.reshape(1, -1)\n            \n        # We convert the numpy array that Lime sends to a pandas dataframe and\n        # convert the pandas dataframe to an h2o frame\n        self.pandas_df = pd.DataFrame(data = this_array,columns = self.column_names)\n\n        # Predict with the h2o drf\n        self.predictions = self.model.predict(self.pandas_df).todense()\n        # the first column is the class labels, the rest are probabilities for\n        # each class\n        self.predictions =  np.asarray(self.predictions)\n        return self.predictions","794160ae":"classifier_wrapped_ =  model_wrapper(classifier,FeatureNames) ","27e7372a":"one_hot.classes_[np.where(y_val[5]==1)]","e2dfd1b6":"X_val_scaled = scaler.transform(X_val)","e5d51032":"one_hot.classes_[np.where(y_val[689]==1)]","5b4b10d3":"np.where(y_val[:,24]==1)[0][1]","cd1c2272":"one_hot.classes_[15]","d3f7e6ee":"#i = np.random.randint(0, X_test_scaled.shape[0])\nexp = explainer.explain_instance(X_val_scaled[689], classifier_wrapped_.predict_proba, num_features=10, top_labels=27,num_samples=5000)","9999bcd0":"exp.show_in_notebook(show_table=True, show_all=True)","ce74dda9":"exp.predict_proba","55c449f0":"exp.as_map()","82bf6826":"exp.as_list(label=)","e40b94c4":"exp.as_pyplot_figure(label=24)\nplt.savefig(\"conduction_disorder_12lead.png\", dpi=300, bbox_inches=\"tight\")","58238a54":"exp.as_pyplot_figure(label=6)\n#plt.savefig(\"atrialfib_atrialfib.png\", dpi=300, bbox_inches=\"tight\")","e2b41736":"exp.as_pyplot_figure(label=26)\nplt.savefig(\"atrialfib_crbbb.png\", dpi=300, bbox_inches=\"tight\")","8bc33f33":"exp.as_pyplot_figure(label=2)\nexp.as_pyplot_figure(label=26)\nexp.as_pyplot_figure(label=12)\nplt.show()","ab11b84c":"exp.save_to_file(\"explaination.html\")","8dffbae3":"SNOMED_scored","e2cc92fa":"About 150 ECG-recordings removed"}}