{"cell_type":{"3d1634da":"code","26841a62":"code","0cf8e426":"code","3233acbd":"code","d8e79d91":"code","34c6d8c5":"code","6f77be0a":"code","3dcbd29d":"code","2309c1b4":"code","62f75e93":"code","355af1fd":"markdown"},"source":{"3d1634da":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nfrom datetime import datetime\n\nimport os\n\ndataFiles = list()\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        printName = os.path.join(dirname, filename)\n        print(printName)\n        dataFiles.append(printName)\n\nprint(len(dataFiles))","26841a62":"dataDF = list()\n\nfor idx in range(len(dataFiles)):\n    try:\n\n        dataDict = dict()\n        filename = dataFiles[idx]\n        \n        if 'AllDates' in filename:\n            dataDict['Date'] = 'AllDates'\n        else:\n            dataDict['Date'] = filename.split('_')[-1].split('.')[0]\n        \n        if 'xlsx' in filename:\n            dataDict['Data'] = pd.read_excel(filename)\n        else:\n            dataDict['Data'] = pd.read_csv(filename)\n\n        dataDF.append(dataDict)\n        \n    except:\n        print(f\"Error in {idx}# \", filename.split('\/')[-1])","0cf8e426":"april15Idx = None\nmar30Idx = None\n\nfor idx in range(len(dataDF)):\n    print(f\"{idx}# \", dataDF[idx]['Date'])\n    if '15Apr' in dataDF[idx]['Date']:\n        april15Idx = idx\n        \n    print(dataDF[idx]['Data'].columns)\n    print(\"#####################################\")\n    ","3233acbd":"#Adjusting for 15th April\n\nif april15Idx:\n    dataDF[april15Idx]['Data']['Tests'] = round(dataDF[april15Idx]['Data']['Tests\u2009\/millionpeople']*(dataDF[april15Idx]['Data']['Positive']\/dataDF[april15Idx]['Data']['Positive\u2009\/millionpeople']), 0)\n","d8e79d91":"dataDF[april15Idx]['Data'].head()","34c6d8c5":"\nfor idx in range(len(dataDF)):\n    if dataDF[idx]['Date'] == 'AllDates':\n        continue\n        \n    dataDF[idx]['Data'].rename(columns={'Country or region': 'Country', 'Country or territory': 'Country',\n                         'As of': 'Date', \n                         'Total tests': 'Tested', 'Tests': 'Tested',\n                        'Positive\/ thousands': 'Positive \/millionpeople', 'Positive\u2009\/millionpeople': 'Positive \/millionpeople',\n                        'Tests\u2009\/millionpeople': 'Tested\u2009\/millionpeople', 'Tests\/ million': 'Tested\u2009\/millionpeople',\n                                       'Source': 'Source_1'}, inplace=True)\n    try:\n        dataDF[idx]['Data']['Positive\/Tested %'] = round(100*(dataDF[idx]['Data']['Positive'] \/ dataDF[idx]['Data']['Tested']),2)\n    except:\n        print(f\"ERROR: In calculating %age {idx}# \", dataDF[idx]['Date'])\n    \n    if 'Units' not in list(dataDF[idx]['Data'].columns):\n        dataDF[idx]['Data']['Units'] = 'NA'\n    \n    if dataDF[idx]['Date'] == 'Conducted':\n        # For the 30March File\n        dataDF[idx]['Data'] = dataDF[idx]['Data'][['Country', 'Date', 'Tested','Source_1']]\n    else:\n\n        try:\n            dataDF[idx]['Data'] = dataDF[idx]['Data'][['Country', 'Date', 'Tested', 'Units','Positive', 'Positive\/Tested %','Source_1', 'Source_2']]\n        except:\n            print(f\"ERROR: In subsetting columns {idx}# \", dataDF[idx]['Date'])\n\n    # Normalize the dates to the same format %d %b %Y ie 26 Apr 2020 (final expected)\n    \n    splitDate = dataDF[idx]['Data']['Date'].str.split().loc[0]\n    if len(splitDate) == 2:\n        dataDF[idx]['Data']['Date'] = dataDF[idx]['Data']['Date'].str.split().str.join(' ') + ' 2020' \n    else:\n        dataDF[idx]['Data']['Date'] = dataDF[idx]['Data']['Date'].str.split().str.join(' ')\n    \n    dataDF[idx]['Data']['FileDate'] = dataDF[idx]['Date']\n    \n    dataDF[idx]['Data'].reset_index(inplace=True, drop=True)\n    \n#     if 'Positive \/millionpeople' in dataDF[idx]['Data'].columns.to_list():\n#         dataDF[idx]['Data']['Tests_calculated'] = (dataDF[idx]['Data']['Positive']\/ dataDF[idx]['Data']['Positive \/millionpeople'])","6f77be0a":"dataDF[1]['Data'].columns","3dcbd29d":"completeDF = pd.DataFrame()\n\nfor idx in range(len(dataDF)):\n    if dataDF[idx]['Date'] == 'AllDates':\n        continue\n    completeDF = pd.concat([completeDF, dataDF[idx]['Data']])\n\ncompleteDF.dropna(subset=['Date'], inplace=True)\n\ncompleteDF.reset_index(inplace=True, drop=True)\nprint(completeDF.shape)\ncompleteDF.head()","2309c1b4":"# Uncomment if you are not comfortable with using the 15th April 2020 data\n# completeDF = completeDF.drop(completeDF[completeDF['FileDate'] == '15April2020'].index)\n# completeDF['FileDate'].value_counts()","62f75e93":"completeDF.to_csv('TestsConducted_AllDates_11May2020.csv', index=False)","355af1fd":"*Note:\nRealized that no data was captured during the 15th April 2020 run. Have updated the sheet with calculated values from the other fields. \n*\n\n1. Files are concatenated on the following fields: \n2. Calculated fields like `Tested \/millionpeople` & `Positive \/millionpeople` are removed. *I suggest those values are calculated from the actual population values, will be updating the dataset with a separate table for a country's population*\n3. Columns are normalized across all the files\n4. The following fields are subset -> `Country`, `Date`, `Tested`, `Positive`, `Positive\/Tested %`,`Source_1`, `Source_2`\n5. A new field `FileDate` has been added, so that the data can be referred back to the source file\n\nModification for file for 15th April 2020\n\n1. Most of the values in the `Tests` column were missing.\n2. The value is calculated by using the following formula:\n\nTests conducted = ((Positives)\/(Positive \/millionpeople))* (Tests \/millionpeople)\n"}}