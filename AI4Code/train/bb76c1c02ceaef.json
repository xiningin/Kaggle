{"cell_type":{"f8c538db":"code","4c5528b2":"code","ca4e9d3c":"code","0587e6e2":"code","beab4e12":"code","61273ebe":"code","4390e099":"code","0ace37f9":"code","7d507c3f":"code","b4aa4a66":"code","2d342741":"code","85b744e2":"code","65548154":"code","8a5a94f9":"code","2083df6a":"code","78599265":"code","4c57ed49":"code","d4ce5321":"code","775b5336":"markdown","42349d47":"markdown","53d7335a":"markdown","d413e70b":"markdown","b2ebb1df":"markdown","415d5298":"markdown","f4d10896":"markdown","d7237dee":"markdown","7f4dfca2":"markdown","fcfe4ebc":"markdown","fc7c15a2":"markdown","aadc930a":"markdown","2a926b4b":"markdown"},"source":{"f8c538db":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","4c5528b2":"import numpy as np \nimport pandas as pd #CSV file I\/O (e.g. pd.read_csv)\n\n#Read the csv file and create a data frame\ntrain_df = pd.read_csv('\/kaggle\/input\/ph-recognition\/ph-data.csv',dtype=int)\ntrain_df.head()","ca4e9d3c":"import csv\nwith open('\/kaggle\/input\/ph-recognition\/ph-data.csv', newline='') as csvfile:\n     d = list(csv.reader(csvfile))\ndata = np.array(d)\n\nrows=len(d) \ncols=(len(d[0]))","0587e6e2":"filtered_data=np.zeros((rows,cols-1))\nfor i in range(rows):\n    if(i==0):\n        continue\n    else:\n        for j in range(cols-1):\n            filtered_data[i][j]=data[i][j]\nfiltered_data=filtered_data[1:154] # this is our training dataset but we limit it for the first 153 element for calculation purposes only\nprint(\"An Example for filtered_data will be index 100:\",filtered_data[100])","beab4e12":"numOutput=4\nnumHidden=45\nnumInputs=24\nnumEpochs=1000\nnumTraining=153\nlearnrate=0.05","61273ebe":"def decimal2Binary(n):  \n    b=bin(int(n)).replace(\"0b\", \"\")\n    #print(len(b))\n    if(len(b)==1):\n        b='0000000'+b\n    elif(len(b)==2):\n        b='000000'+b    \n    elif(len(b)==3):\n        b='00000'+b \n    elif(len(b)==4):\n        b='0000'+b \n    elif(len(b)==5):\n        b='000'+b\n    elif(len(b)==6):\n        b='00'+b \n    elif(len(b)==7):\n        b='0'+b \n    elif(len(b)==8):\n        b=b \n    #print(b)\n    return b","4390e099":"def dec2Bipolar(index):   \n    #print(filtered_data[index])\n    intArray=np.zeros(24)#Binary Form\n    output=np.zeros(24)#Bipolar Form\n    stringForm=\"\"\n    if(index>652):\n        return \"Error in index Bounds\"\n    else:\n        stringForm=decimal2Binary(filtered_data[index][0])+decimal2Binary(filtered_data[index][1])+decimal2Binary(filtered_data[index][2])\n        \n        array=list(stringForm)\n        for p in range(0, len(array)): \n                intArray[p] = int(array[p])\n        k = 0\n        for h,v in enumerate (intArray):\n\n            if int(intArray[h]) == 0 :\n                output [k] = -1\n            elif int(intArray[h]) == 1 :\n                output [k] = 1\n            k = k+1\n        return output","0ace37f9":"def getBipolar():\n    final=np.zeros((numTraining,24))\n    for i in range(0,numTraining):\n        final[i]=dec2Bipolar(i)\n    return final","7d507c3f":"training_input=getBipolar()\nprint(\"Our Training Set becomes: \\n\",training_set)\ninputB = np.insert(training_input, 0,np.ones(numTraining),1)\nprint(\"Our Training Set with bias becomes: \\n\",inputB)","b4aa4a66":"label=np.zeros((rows,4))\ndesired = np.zeros((654,4))\nfor i in range(rows):\n    if(i==0):#First row contains string values(Blue,Green,....)\n        continue\n    else:    \n        \n        label[i][0]=data[i][3]\n        \n        if(label[i][0]==0.0):\n            desired[i]=[-1,-1,-1,-1]\n        elif(label[i][0]==1.0):\n            desired[i]=[-1,-1,-1,+1]\n        elif(label[i][0]==2.0):\n            desired[i]=[-1,-1,+1,-1]\n        elif(label[i][0]==3.0):\n            desired[i]=[-1,-1,+1,+1]\n        elif(label[i][0]==4.0):\n            desired[i]=[-1,+1,-1,-1]\n        elif(label[i][0]==5.0):\n            desired[i]=[-1,+1,-1,+1]\n        elif(label[i][0]==6.0):\n            desired[i]=[-1,+1,+1,-1]\n        elif(label[i][0]==7.0):\n            desired[i]=[-1,+1,+1,+1]\n        elif(label[i][0]==8.0):\n            desired[i]=[+1,-1,-1,-1]\n        elif(label[i][0]==9.0):\n            desired[i]=[+1,-1,-1,+1]\n        elif(label[i][0]==10.0):\n            desired[i]=[+1,-1,+1,-1]\n        elif(label[i][0]==11.0):\n            desired[i]=[+1,-1,+1,+1]\n        elif(label[i][0]==12.0):\n            desired[i]=[+1,+1,-1,-1]\n        elif(label[i][0]==13.0):\n            desired[i]=[+1,+1,-1,+1]\n        elif(label[i][0]==14.0):\n            desired[i]=[+1,+1,+1,-1]\n    \n#Use only the first 153 element of the desired array\ndesired=desired[1:numTraining+1]","2d342741":"w1=np.zeros((numEpochs*numTraining,numHidden,numInputs+1))\nw2=np.zeros((numEpochs*numTraining,numOutput,numHidden+1))\n\nw1[0,:,:] = np.random.uniform(-0.1, 0.1,size=[numHidden,numInputs+1])\nw2[0,:,:] = np.random.uniform(-0.1, 0.1,size=[numOutput,numHidden+1])","85b744e2":"V1=np.zeros((numEpochs,numTraining,numHidden+1))\nY1=np.zeros((numEpochs,numTraining,numHidden+1))\nV2=np.zeros((numEpochs,numTraining,numOutput))\nY2=np.zeros((numEpochs,numTraining,numOutput))\n\nV1Test=np.zeros((numEpochs,numTraining,numHidden+1))\nY1Test=np.zeros((numEpochs,numTraining,numHidden+1))\nV2Test=np.zeros((numEpochs,numTraining,numOutput))\nY2Test=np.zeros((numEpochs,numTraining,numOutput))\ne=np.zeros((numEpochs,numTraining,numOutput))\nE=np.zeros((numEpochs,numTraining,numOutput))\nderActiv1=np.zeros((numEpochs,numTraining,numOutput))\ndelt1=np.zeros((numEpochs,numTraining,numOutput))\nderActiv2=np.zeros((numEpochs,numTraining,numHidden))\ndelt2=np.zeros((numEpochs,numTraining,numHidden))\na=1\nb=1","65548154":"kk=0\nfor k in range(numEpochs-1):\n        for l in range(numTraining):\n            for j in range(numHidden):\n                for i in range(numInputs+1):\n                    V1[k,l,j+1] = V1[k,l,j+1]+w1[kk,j,i]*inputB[l,i]\n                    Y1[k,l,j+1]=a*np.tanh(b*V1[k,l,j+1])\n                Y1[k,l,0]=1 # add bias\n             # output Layer\n            for j in range(numOutput):\n                for i in range(numHidden+1):\n                    V2[k,l,j] = V2[k,l,j]+ w2[kk,j,i]*Y1[k,l,i]\n                    Y2[k,l,j]=a*np.tanh(b*V2[k,l,j])\n            # Calculate error\n            for j in range (numOutput):\n                e[k,l,j]=desired[l,j]-Y2[k,l,j]\n                E[k,l,j]= 1\/2*((e[k,l,j])**2)\n            # output layer\n            for j in range (numOutput):\n                derActiv1[k,l,j] = (b\/a)*(a+Y2[k,l,j])*(a-Y2[k,l,j])\n                delt1[k,l,j]=e[k,l,j]*derActiv1[k,l,j]\n            #update weights between hidden and output\n            for j in range(numOutput):\n                for i in range(numHidden+1):\n                    w2[kk+1,j,i]=w2[kk,j,i]+learnrate*delt1[k,l,j]*Y1[k,l,i]\n            # hidden layer\n            for i in range (numHidden):\n                derActiv2[k,l,i] = (b\/a)*(a+Y1[k,l,i+1])*(a-Y1[k,l,i+1])# start from 1 dont take bias input\n            tempdel=0;\n            for j in range(numOutput):\n                tempdel=tempdel+delt1[k,l,j]*w2[kk,j,i]\n                delt2[k,l,i]=derActiv2[k,l,i]*tempdel\n            # update weights\n            for j in range(numHidden):\n                for i in range(numInputs+1):\n                    w1[kk+1,j,i]=w1[kk,j,i]+learnrate*delt2[k,l,j]*inputB[l,i]\n            kk=kk+1\n#print(e)","8a5a94f9":"V1Test=np.zeros((numTraining,numHidden+1))\nY1Test=np.zeros((numTraining,numHidden+1))\nV2Test=np.zeros((numTraining,numOutput))\nY2Test=np.zeros((numTraining,numOutput))\neTest=np.zeros((numTraining,numOutput))\nETest=np.zeros((numTraining,numOutput))\n\ntotalError=0\ntotalMSE=0\n\nfor l in range(numTraining):\n    for j in range(numHidden):\n        for i in range(numInputs+1):\n            V1Test[l,j+1] = V1Test[l,j+1]+w1[kk-1,j,i]*inputB[l,i]\n            Y1Test[l,j+1]=a*np.tanh(b*V1Test[l,j+1])\n            Y1Test[l,0]=1 # add bias\n            \n    # output Layer\n    for j in range(numOutput):\n        for i in range(numHidden+1):\n            V2Test[l,j] = V2Test[l,j]+ w2[kk,j,i]*Y1Test[l,i]\n            Y2Test[l,j]=a*np.tanh(b*V2Test[l,j])\n    # Calculate error\n    for j in range (numOutput):\n        eTest[l,j]=desired[l,j]-Y2Test[l,j]\n        ETest[l,j]= 1\/2*((eTest[l,j])**2)\n        totalMSE=totalMSE+ETest[l,j]\n    print(\"testing Sample \", l, \" Output = \", desired[l,:], \" Predicted =\", Y2Test[l,:])\n    \nAverageMSE=totalMSE\/(numTraining*numOutput)\nprint(\"Average Mean sqaured Error= \", AverageMSE)","2083df6a":"numTesting=3 \ninp=24\ntesting=np.zeros((3,3))\ntarget=np.zeros((3,4))\n#Green (7): \ntesting[0]=np.array([[0,153,0]])#B,G,R\ntarget[0]=np.array([[-1,1,1,1]])#Green is ph=7\n#Red (0): \ntesting[1]=np.array([[36,84,250]])\ntarget[1]=np.array([[-1,-1,-1,-1]])#Red is ph=0\n#Dark Violet(14)\ntesting[2]=np.array([[131,47,78]])\ntarget[2]=np.array([[1,1,1,-1]])\n\nprint(\"Testing DataSet is: \\n\",testing)","78599265":"def convertTesting2Bipolar(index):   \n    #print(filtered_data[index])\n    intArray=np.zeros(24)#Binary Form\n    output=np.zeros(24)#Bipolar Form\n    stringForm=\"\"\n    if(index>652):\n        return \"Error in index Bounds\"\n    else:\n        stringForm=decimal2Binary(testing[index][0])+decimal2Binary(testing[index][1])+decimal2Binary(testing[index][2])        \n        array=list(stringForm)\n        for p in range(0, len(array)): \n                intArray[p] = int(array[p])\n        k = 0\n        for h,v in enumerate (intArray):\n\n            if int(intArray[h]) == 0 :\n                output [k] = -1\n            elif int(intArray[h]) == 1 :\n                output [k] = 1\n            k = k+1\n        return output","4c57ed49":"test=np.zeros((len(testing),24))\n#Create 2D array of all testing values\nfor i in range(len(testing)):\n        test[i]=convertTesting2Bipolar(i)\ntesting_data = np.insert(test, 0,np.ones(1),1)\ntesting_data","d4ce5321":"V1Test=np.zeros((numTesting,numHidden+1))\nY1Test=np.zeros((numTesting,numHidden+1))\nV2Test=np.zeros((numTesting,numOutput))\nY2Test=np.zeros((numTesting,numOutput))\neTest=np.zeros((numTesting,numOutput))\nETest=np.zeros((numTesting,numOutput))\n\ntotalError=0\ntotalMSE=0\n\nfor l in range(numTesting):\n    for j in range(numHidden):\n        for i in range(inp+1):\n            V1Test[l,j+1] = V1Test[l,j+1]+w1[kk-1,j,i]*testing_data[l,i]\n            Y1Test[l,j+1]=a*np.tanh(b*V1Test[l,j+1])\n        Y1Test[l,0]=1 # add bias\n            \n    # output Layer\n    for j in range(numOutput):\n        for i in range(numHidden+1):\n            V2Test[l,j] = V2Test[l,j]+ w2[kk,j,i]*Y1Test[l,i]\n            Y2Test[l,j]=a*np.tanh(b*V2Test[l,j])\n    # Calculate error\n    for j in range (numOutput):\n        eTest[l,j]=target[l,j]-Y2Test[l,j]\n        ETest[l,j]= 1\/2*((eTest[l,j])**2)\n        totalMSE=totalMSE+ETest[l,j]\n    print(\"Actual = \",target[l,:],\" Predicted =\", Y2Test[l,:])\n    \nAverageMSE=totalMSE\/(numTesting*numOutput)\nprint(\"Average Mean sqaured Error in Testing Phase= \", AverageMSE)","775b5336":"### We notice approximately correct predictions and classifications without the need to have a huge dataset of 16 million RGB possible combinations.Result will not be 100% correct but at least they are produced with small error rate","42349d47":"**Define Variable now needed for initiating the training method**","53d7335a":"**Now it is time to apply our BP algorithm with its forward and backward phases:**","d413e70b":"**After Getting the file path ,paste it here in the read_csv function**","b2ebb1df":"# pH Recognition Using BP algorithm\n# Yasser Haidar","415d5298":"# Testing Phase (Using Random RGB Values)","f4d10896":"# **Testing Convergence**","d7237dee":"As we have said we have 24 inputs and 153 sample(we will not use the whole 653 sample)","7f4dfca2":"First Step is to get the dataset file path.The dataset used is in csv format and found on kaggle:\n[https:\/\/www.kaggle.com\/robjan\/ph-recognition](http:\/\/)","fcfe4ebc":"Now call the above function for every array element in testing_set array to convert it to bipolar form","fc7c15a2":"* First create your own testing array,We will try it with only 3 RGB combinations with known pH label","aadc930a":"Now we want to divide our data to training set and a desired label so filtered_data will be the training set","2a926b4b":"The target variable will looks like:\n*     [-1,-1,-1,-1],#pH=0\n*     [-1,-1,-1,+1],#pH=1\n*     [-1,-1,+1,-1],#pH=2\n*     [-1,-1,+1,+1],#pH=3\n*     [-1,+1,-1,-1],#pH=4\n*     [-1,+1,-1,+1],#pH=5\n*     [-1,+1,+1,-1],#pH=6\n*     [-1,+1,+1,+1],#pH=7\n*     [+1,-1,-1,-1],#pH=8\n*     [+1,-1,-1,+1],#pH=9\n*     [+1,-1,+1,-1],#pH=10\n*     [+1,-1,+1,+1],#pH=11\n*     [+1,+1,-1,-1],#pH=12\n*     [+1,+1,-1,+1],#pH=13\n*     [+1,+1,+1,-1],#pH=14"}}