{"cell_type":{"28e2436b":"code","32a29d94":"code","c7a63037":"code","6f643bd0":"code","57350015":"code","04b000e3":"code","b330d27b":"code","b423bce8":"code","5cb7df66":"code","4dbf6d36":"markdown","9068307c":"markdown","e58e8e5b":"markdown","f294b6ce":"markdown","f364a0ea":"markdown","7ce9865a":"markdown","1ac16409":"markdown","63e9d29b":"markdown","98db8d06":"markdown"},"source":{"28e2436b":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom pathlib import Path\nfrom glob import glob\n\n\ndef get_groundtruth(path: Path) -> pd.DataFrame:\n    output_df = pd.DataFrame()\n    \n    for path in glob(str(path \/ 'train\/*\/*\/ground_truth.csv')):\n        _df = pd.read_csv(path)\n        output_df = pd.concat([output_df, _df])\n    output_df = output_df.reset_index(drop=True)\n    \n    _columns = ['latDeg', 'lngDeg', 'heightAboveWgs84EllipsoidM']\n    output_df[['t_'+col for col in _columns]] = output_df[_columns]\n    output_df = output_df.drop(columns=_columns, axis=1)\n    return output_df\n\n\ndef calc_haversine(lat1, lon1, lat2, lon2):\n    \"\"\"Calculates the great circle distance between two points\n    on the earth. Inputs are array-like and specified in decimal degrees.\n    \"\"\"\n    lat1, lon1, lat2, lon2 = map(np.radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = np.sin(dlat\/2.0)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon\/2.0)**2\n\n    c = 2 * np.arcsin(a**0.5)\n    dist = 6_367_000 * c\n    return dist\n\n\ndef check_score(input_df: pd.DataFrame) -> pd.DataFrame:\n    output_df = input_df.copy()\n    \n    output_df['meter'] = input_df.apply(\n        lambda r: calc_haversine(\n            r.latDeg, r.lngDeg, r.t_latDeg, r.t_lngDeg\n        ),\n        axis=1\n    )\n\n    meter_score = output_df['meter'].mean()\n    print(f'error meter: {meter_score}')\n\n    scores = []\n    for phone in output_df['phone'].unique():\n        _index = output_df['phone']==phone\n        p_50 = np.percentile(output_df.loc[_index, 'meter'], 50)\n        p_95 = np.percentile(output_df.loc[_index, 'meter'], 95)\n        scores.append(p_50)\n        scores.append(p_95)\n\n    score = sum(scores) \/ len(scores)\n    print(f'score: {score}')\n    \n    return output_df","32a29d94":"# read data\nBASE_DIR = Path('..\/input\/google-smartphone-decimeter-challenge')\ntrain_base = pd.read_csv(BASE_DIR \/ 'baseline_locations_train.csv')\ntest_base = pd.read_csv(BASE_DIR \/ 'baseline_locations_test.csv')\n\n# merge graoundtruth\ntrain_base = train_base.merge(\n    get_groundtruth(BASE_DIR),\n    on=['collectionName', 'phoneName', 'millisSinceGpsEpoch']\n)","c7a63037":"# check score\ntrain_base = check_score(train_base)","6f643bd0":"# show boxplot\nfor name, df in train_base.groupby('collectionName'):    \n    sns.boxplot(data=df, x='phoneName', y='meter', width=0.5)\n    plt.title(name)\n    plt.ylim(0, 20)\n    plt.show()","57350015":"# show describe\ntrain_base.groupby('phoneName')['meter'].describe().T","04b000e3":"def get_removedevice(input_df: pd.DataFrame, divece: str) -> pd.DataFrame:\n    input_df['index'] = input_df.index\n    input_df = input_df.sort_values('millisSinceGpsEpoch')\n    input_df.index = input_df['millisSinceGpsEpoch'].values\n\n    output_df = pd.DataFrame() \n    for _, subdf in input_df.groupby('collectionName'):\n\n        phones = subdf['phoneName'].unique()\n\n        if (len(phones) == 1) or (not divece in phones):\n            output_df = pd.concat([output_df, subdf])\n            continue\n\n        origin_df = subdf.copy()\n        \n        _index = subdf['phoneName']==divece\n        subdf.loc[_index, 'latDeg'] = np.nan\n        subdf.loc[_index, 'lngDeg'] = np.nan\n        subdf = subdf.interpolate(method='index', limit_area='inside')\n\n        _index = subdf['latDeg'].isnull()\n        subdf.loc[_index, 'latDeg'] = origin_df.loc[_index, 'latDeg'].values\n        subdf.loc[_index, 'lngDeg'] = origin_df.loc[_index, 'lngDeg'].values\n\n        output_df = pd.concat([output_df, subdf])\n\n    output_df.index = output_df['index'].values\n    output_df = output_df.sort_index()\n\n    del output_df['index']\n    \n    return output_df","b330d27b":"train_remove = get_removedevice(train_base, 'SamsungS20Ultra')","b423bce8":"\"\"\"\ncheck_score(train_base):\n    error meter: 3.846848374995186\n    score: 5.287970649047862\n\"\"\"\n\ntrain_remove = check_score(train_remove)","5cb7df66":"submission = pd.read_csv('..\/input\/baseline-post-processing-by-outlier-correction\/submission.csv')\nsubmission['collectionName'] = submission['phone'].map(lambda x: x.split('_')[0])\nsubmission['phoneName'] = submission['phone'].map(lambda x: x.split('_')[1])\nsubmission = get_removedevice(submission, 'SamsungS20Ultra')\n\nsubmission = submission.drop(columns=['collectionName', 'phoneName'], axis=1)\nsubmission.to_csv('submission.csv', index=False)","4dbf6d36":"You can only process the submission file, but be sure to process the train data as well to check the score.  \nThank you for reading to the end. I look forward to your questions and comments.\n\n\u30b5\u30d6\u30df\u30c3\u30b7\u30e7\u30f3\u30d5\u30a1\u30a4\u30eb\u306b\u5bfe\u3057\u3066\u306e\u307f\u51e6\u7406\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3067\u3059\u304c\u3001\u78ba\u5b9f\u306btrain\u30c7\u30fc\u30bf\u306b\u5bfe\u3057\u3066\u3082\u51e6\u7406\u3092\u884c\u3044\u30b9\u30b3\u30a2\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002  \n\u6700\u5f8c\u307e\u3067\u8aad\u3093\u3067\u3044\u305f\u3060\u304d\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3057\u305f\uff01\u8cea\u554f\u3068\u30b3\u30e1\u30f3\u30c8\u304a\u5f85\u3061\u3057\u3066\u3044\u307e\u3059\u3002","9068307c":"# Method","e58e8e5b":"# Reference\n\nI used these notebooks as a reference in creating this. Thank you very much!\n\n* [Baseline post-processing by outlier correction](https:\/\/www.kaggle.com\/dehokanta\/baseline-post-processing-by-outlier-correction) created by [dehokanta](https:\/\/www.kaggle.com\/dehokanta).","f294b6ce":"Let's look at the accuracy for each device. You can see that the accuracy varies from device to device.\n\ndevice\u3054\u3068\u306e\u7cbe\u5ea6\u3092\u898b\u3066\u307f\u307e\u3057\u3087\u3046\u3002device\u9593\u3067\u7cbe\u5ea6\u304c\u7570\u306a\u308b\u306e\u304c\u308f\u304b\u308a\u307e\u3059\u3002","f364a0ea":"As described above, I was able to increase the accuracy easily.  \nThis is a post processing step, so you can improve the accuracy even without train data. To try it out, let's use [Baseline post-processing by outlier correction](https:\/\/www.kaggle.com\/dehokanta\/baseline-post-processing-by-outlier-correction) created by [dehokanta](https:\/\/www.kaggle.com\/dehokanta).\n\n\u4ee5\u4e0a\u306e\u3088\u3046\u306b\u7c21\u5358\u306b\u7cbe\u5ea6\u3092\u5411\u4e0a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3057\u305f\u3002  \n\u3053\u308c\u306f\u5f8c\u51e6\u7406\u306a\u306e\u3067train\u30c7\u30fc\u30bf\u304c\u306a\u304f\u3066\u3082\u7cbe\u5ea6\u304c\u5411\u4e0a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u8a66\u3057\u306b[dehokanta](https:\/\/www.kaggle.com\/dehokanta)\u3055\u3093\u306e[Baseline post-processing by outlier correction](https:\/\/www.kaggle.com\/dehokanta\/baseline-post-processing-by-outlier-correction)\u306b\u5bfe\u3057\u3066\u4f7f\u3063\u3066\u307f\u307e\u3057\u3087\u3046\u3002","7ce9865a":"# EDA","1ac16409":"Score(Public Leaderboard)  \n[Baseline post-processing by outlier correction](https:\/\/www.kaggle.com\/dehokanta\/baseline-post-processing-by-outlier-correction) by [dehokanta](https:\/\/www.kaggle.com\/dehokanta) : 6.164  \nthis notebook: 6.089\n\n**0.075 up!**","63e9d29b":"In this notebook I do EDA on devices. After that, I show you how to improve the accuracy by removing location information from devices with poor accuracy and interpolate it from other devices.\n\n\u3053\u306e\u30ce\u30fc\u30c8\u30d6\u30c3\u30af\u3067\u306fdevice\u306b\u95a2\u3059\u308bEDA\u3092\u884c\u3044\u3001\u7cbe\u5ea6\u304c\u9ad8\u304f\u306a\u3044device\u306e\u4f4d\u7f6e\u60c5\u5831\u3092\u53d6\u308a\u9664\u304d\u4ed6\u306edevice\u304b\u3089\u306e\u4f4d\u7f6e\u60c5\u5831\u3092\u88dc\u9593\u3059\u308b\u3053\u3068\u3067\u7cbe\u5ea6\u3092\u5411\u4e0a\u3055\u305b\u308b\u65b9\u6cd5\u3092\u7d39\u4ecb\u3057\u307e\u3059\u3002","98db8d06":"If you look at the data, you can see that the error is different for devices with the same collectionName.  \nNow, let's interpolate the location information from other devices except for SamsungS20Ultra which has a lot of errors.\n\n\u30c7\u30fc\u30bf\u3092\u898b\u3066\u307f\u308b\u3068\u3001\u540c\u3058collectionName\u3067\u3082device\u306b\u3088\u3063\u3066\u8aa4\u5dee\u304c\u7570\u306a\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u307e\u3059\u3002  \n\u4eca\u56de\u306f\u8aa4\u5dee\u3092\u591a\u304f\u542b\u3080SamsungS20Ultra\u306e\u9664\u3044\u3066\u307b\u304b\u306edevice\u306e\u4f4d\u7f6e\u60c5\u5831\u304b\u3089\u88dc\u9593\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002"}}