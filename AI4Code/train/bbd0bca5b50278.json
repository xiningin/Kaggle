{"cell_type":{"1ff05aba":"code","11c91d02":"code","b1985a4f":"code","26945c19":"code","ad1dba8b":"code","1c687adb":"code","119ed15d":"code","719bcdf3":"markdown","1bf3c0b5":"markdown","0caae9ff":"markdown","00c2ffd3":"markdown","724adada":"markdown","ea494c5d":"markdown","fc232fbc":"markdown","685b6f68":"markdown"},"source":{"1ff05aba":"import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n%matplotlib inline","11c91d02":"np.random.seed(20)  # for generating similar random data\ndef generate_data(num_features,num_examples=1000):\n    x=np.random.randn(num_features,num_examples)\n    w=np.random.randn(num_features,1)\n    b=np.random.randn()\n    y=np.dot(w.T,x)+b\n    return x,y","b1985a4f":"class MultipleLinearRegression():\n    def __init__(self):\n        self.W=None\n        self.b=None\n        self.m=None\n        \n    def predict(self,X):\n        try:\n            y_pred=np.dot(self.W.T,X)+self.b\n            return y_pred\n        except AttributeError:\n            print('First train your data using fit function and then predict')\n    \n    def compute_loss(self,y_pred,y_true):\n        loss=np.sum(np.square(y_pred-y_true))\/(2*self.m)\n        return loss\n    \n    def fit(self,X,y,learning_rate=0.00001,iterations=1000):\n        self.m=X.shape[0]\n        self.W=np.random.randn(self.m,1)\n        self.b=np.random.randn()\n        y_pred=self.predict(X)\n        loss=self.compute_loss(y_pred,y)\n        losses=[]\n        losses.append(loss)\n        for i in range(iterations):\n            dw=np.dot(X,(y_pred-y).T)\/self.m\n            db=np.sum(y_pred-y)\/self.m\n            self.W=self.W-(learning_rate*dw)\n            self.b=self.b-(learning_rate*db)\n            y_pred=self.predict(X)\n            loss=self.compute_loss(y_pred,y)\n            losses.append(loss)\n            \n            if (i+1)%100==0:\n                print('loss at iteration number '+str(i+1)+' is : ',losses[i])\n        \n        plt.title('Multiple Linear Regression')\n        plt.plot(losses)\n        plt.xlabel('no. of iterations')\n        plt.ylabel('loss')\n        plt.show()\n            \n        ","26945c19":"x_train,y_train=generate_data(num_features=4)","ad1dba8b":"model=MultipleLinearRegression()","1c687adb":"model.fit(x_train,y_train,iterations=2000)","119ed15d":"y_predict=model.predict(x_train)\ny_predict.shape","719bcdf3":"# Generating data\n* x -> input matrix of shape (number_of_features, number_of_examples)\n* w -> parameter of shape (number_of_features, 1)\n* b -> parameter\n* y -> output vector of shape(1, number_of_examples)","1bf3c0b5":"# Importing Libraries\n* numpy -> deals with multidimentional array\n* matplotlib and seaborn -> used for data visualization","0caae9ff":"# Predicting output","00c2ffd3":"# Fitting data","724adada":"# Model\n### Multiple Linear Regression Class consists of three functions:-\n1. predict:\n   * input -> X, returns -> predicted output y.\n2. compute_loss:\n   * input -> 'predicted y' and 'true y' , returns -> loss \n3. fit:\n   * input -> 'X',  'y' and optional arguments learning_rate and number of iterations.\n   * fit function works as follows:-\n    1. intializes parameters.\n    2. predicts output and computes loss.\n    3. uses gradient descent algorithm to optimise.\n    4. plots graph, loss v\/s iterations","ea494c5d":"# Instantiating Model","fc232fbc":"# Generating data using generate_data function","685b6f68":"### If this notebook was helpful to you please do upvote and comment suggestions if any."}}