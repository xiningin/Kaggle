{"cell_type":{"5299dbce":"code","ad01f216":"code","eaf0fbe6":"code","199cc629":"code","369d7159":"code","8c846238":"code","129ffb6d":"code","871c1011":"code","46b26e9c":"code","aed0f775":"code","5f2656c8":"code","1ef63769":"code","85ebdc38":"markdown","b62080ae":"markdown","ae33c11a":"markdown","2d44a5e1":"markdown"},"source":{"5299dbce":"# Importing libraries\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom numpy import load, expand_dims, asarray, savez_compressed\nfrom keras.models import load_model\nfrom os import listdir\nfrom PIL import Image\nimport heapq\nfrom random import shuffle","ad01f216":"# Helper Functions\ndef get_encoding(model, arr):\n    arr = (arr - arr.mean()) \/ arr.std()\n    x = np.expand_dims(arr, axis=0)\n    y = model.predict(x)\n    return y[0]\n\n\ndef format_image(filename):\n    img = Image.open(filename)\n    img = img.convert('RGB')\n    img = img.resize((160,160))\n    img_arr = np.asarray(img)\n    return img_arr\n\n\ndef get_n_closest(image_path, database, model, n):\n    img_array = format_image(image_path)\n    encoding = get_encoding(model, img_array)\n    \n    dist_idx = [] \n    for (idx, db_enc) in database.items():\n        dist_idx.append((np.linalg.norm(encoding-db_enc), idx))\n                    \n    min_dist_idx = heapq.nsmallest(n, dist_idx, key=lambda x: x[0])    \n    return min_dist_idx, img_array","eaf0fbe6":"# Loading Facenet model\nmodel = load_model('\/kaggle\/input\/facenet-keras\/facenet_keras.h5')\nprint(model.inputs)\nprint(model.outputs)","199cc629":"# Celebrities image dataset\ndata = load('\/kaggle\/input\/face-extracted-from-celeba-dataset\/img_celeba.npz')\nlst = data.files\nitem = lst[0]\narr = data[item]\nprint (\"Image dataset size: \", arr.shape)","369d7159":"# Image encoding database\n# Database generation for 50k images may take about an hour. \n# To use pre-generated database set GET_DATABASE_FROM_DISK to 1\n\nGET_DATABASE_FROM_DISK = 1\n\ndatabase = {}\nif (GET_DATABASE_FROM_DISK is not 1):\n    for i in range(arr.shape[0]):\n        img = np.reshape(arr[i,:,:,:],(80,80,3))\n\n        image = Image.fromarray(img)\n        image = image.convert('RGB')\n        image = image.resize((160,160))\n        img_array = asarray(image)\n\n        database[i] = get_encoding(model, img_array)\n        if (i%1000 == 0):\n            print (\"Step: \", i)\n\n    np.save('database.npy', database)\n    \nelse:\n    # Loading database from disk\n    database = np.load('\/kaggle\/input\/data4celeb\/database.npy', allow_pickle='TRUE').item()","8c846238":"# Finding n closest match to image from database\nimg_path = \"\/kaggle\/input\/data4celeb\/ManFace.jpg\"\nnMatch = 3\nmin_dist_idx, img_array = get_n_closest(img_path, database, model, nMatch)\n\nfor (dist,idx) in min_dist_idx:\n    print (dist,idx)\n    \nfig = plt.figure(figsize=(nMatch*4,4))\nplt.suptitle(\"Celebrities Match\", fontsize=16, fontweight='bold', y=0.92)\nplt.subplot(1,nMatch+1,1)\nimg = Image.fromarray(img_array).resize((80,80))\nplt.imshow(img)\nimg.save(\"Image_0.png\")\nplt.axis('off');\nplt.title(\"Input Image\")\nfor i,(dist,idx) in enumerate(min_dist_idx):\n    plt.subplot(1,nMatch+1,i+2)\n    plt.imshow(np.reshape(arr[idx,:,:,:],(80,80,3)))\n    Image.fromarray(np.reshape(arr[idx,:,:,:],(80,80,3))).save('Image_' + str(i+1) + '.png')\n    plt.axis('off');\n    plt.title(\"Match #\"+str(i+1))","129ffb6d":"import os\nos.system('cp \/kaggle\/input\/data4celeb\/style_transfer_utils.py \/kaggle\/working\/')\nfrom style_transfer_utils import *\n# Source for style_transfer_utils \n# https:\/\/colab.research.google.com\/github\/tensorflow\/models\/blob\/master\/research\/nst_blogpost\/4_Neural_Style_Transfer_with_Eager_Execution.ipynb#scrollTo=y9r8Lyjb_m0u","871c1011":"# Neural Style Transfer for image provided and matches found\nnst_arr = np.empty((nMatch+1,11), dtype=object)\nstyle_path = \"\/kaggle\/input\/data4celeb\/ma-jolie.jpg\"\nfor i in range(nMatch+1):\n    content_path = 'Image_' + str(i) + '.png'    \n    # increase iterations appropriately\n    best, best_loss, imgs = run_style_transfer(content_path, style_path, num_iterations=100) \n\n    content = asarray(Image.open(content_path))\n    nst_arr[i,0] = content    \n    for j,img in enumerate(imgs):\n        nst_arr[i,j+1] = img","46b26e9c":"img_path = '\/kaggle\/input\/data4celeb\/inputs.png'\nimg = Image.open(img_path)\nplt.imshow(img)\nplt.title(\"Input Image & Picasso Painting\", fontsize=20, fontweight='bold', y=1.04)","aed0f775":"img_path = '\/kaggle\/input\/data4celeb\/potrait.jpg'\nimg = Image.open(img_path)\nplt.imshow(img)\nplt.title(\"Picasso Style Potrait Using Neural Style Transfer\", fontsize=20, fontweight='bold', y=1.04)","5f2656c8":"# Helper functions for game\ndef showMatchLayer(nst_arr, layer):\n    positions = [i for i in range(nMatch+1)]\n    if (layer > 0):\n        shuffle(positions)   \n    for i,pos in enumerate(positions):\n        plt.subplot(1, nMatch+1, pos+1)\n        plt.imshow(nst_arr[i,layer])\n        plt.xticks([])\n        plt.yticks([])\n    plt.show()\n    return positions[0]\n\n\ndef play_game(nst_arr, layer):\n    print (\"Let The Game Begin !!\")\n    print (\"Please try finding your picture.\")    \n    layer_step = 4\n    \n    while True:\n        currPos = showMatchLayer(nst_arr, layer) \n        if (layer == 0):\n            break\n        \n        selection = 0\n        print (\"Select (1-\", nMatch+1, \"): \", sep=\"\", end=\"\")\n        while True:\n            try:\n                selection = int(input())\n                assert 1 <= selection <= nMatch+1\n            except ValueError:\n                print(\"Invalid entry! Please enter an integer.\")\n            except AssertionError:\n                print(\"Invalid entry! Please enter an integer between 1 and \", nMatch+1, \".\", sep='')\n            else:\n                break\n\n        selection -= 1\n        if (selection == currPos):\n            print (\"That's correct. Good job!\")\n            currPos = showMatchLayer(nst_arr, 0)\n            break           \n        \n        layer -= layer_step\n        if (layer < 1):\n            print (\"Game over. Good bye!\")\n            layer = 0\n        else:\n            print (\"That's not correct. Try little easier one!\")","1ef63769":"# Let the game begin\nplay_game(nst_arr, 10)","85ebdc38":"# **3. Game: Which one is you?**","b62080ae":"DESCRIPTION\n\nInterested in knowing your celebrity lookalikes and how today\u2019s AI savvy Picasso would have potraited you \nand them? Here an application using deep learning techniques is presented where your multiple lookalikes are searched from the database of 50k celebrities. Then Picasso style potraits are generated of you and your celetrity counterparts. Next a small fun game is played, where you are put to task to find your Picasso potrait among all generated potraits.\n\nMETHODOLOGY\n\nLookalikes are searched in the celebrity database using Face Recognition system with pretrained ConvNet \u201cVGG19\u201d \nmodel. The content of the matches found are then combined with the style of the Picasso painting \u201cMa-Jolie\u201d using deep learning technique, Neural Style Transfer (NST).","ae33c11a":"# **2. Neural Style Transfer**","2d44a5e1":"# **1. Celebrity Look Alike**"}}