{"cell_type":{"e4023b8e":"code","20f97483":"code","62ac33f9":"code","6837b756":"code","a55e78d8":"code","8fefd0dd":"code","2e419f2d":"code","97dc0c48":"code","aa6ce493":"code","d2e03988":"code","39986358":"code","4abb250c":"code","eeb914fb":"code","c20d387f":"code","c51546ae":"code","3e12a2b9":"code","3f5bec9d":"code","271194ed":"code","7cf794ef":"code","f989f7e1":"code","90f401b8":"code","0536a147":"code","df43531f":"code","4947a406":"code","b62bc847":"code","627c33bc":"code","9320dc1c":"code","7405c16d":"markdown","b857738f":"markdown","58ca7ee2":"markdown","e35b8e9b":"markdown","0eef8cdd":"markdown","081246a6":"markdown","0a2855c4":"markdown","1e46be32":"markdown","fa302911":"markdown","fdadc2e8":"markdown"},"source":{"e4023b8e":"!pip install -qq git+https:\/\/www.github.com\/keras-team\/keras-contrib.git","20f97483":"from IPython.display import clear_output\nimport scipy\nfrom keras_contrib.layers.normalization.instancenormalization import InstanceNormalization\nfrom keras.layers import Input, Dense, Reshape, Flatten, Dropout, Concatenate\nfrom keras.layers import BatchNormalization, Activation, ZeroPadding2D\nfrom keras.layers.advanced_activations import LeakyReLU\nfrom keras.layers.convolutional import UpSampling2D, Conv2D\nfrom keras.models import Sequential, Model\nfrom keras.optimizers import Adam\nimport datetime\nimport matplotlib.pyplot as plt\nimport sys\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\nfrom skimage.io import imread\nimport os\nfrom IPython.display import Image\nfrom keras.utils.vis_utils import model_to_dot\nfrom tqdm import tqdm_notebook\nclear_output()","62ac33f9":"!ls ..\/input\/chest-xray-masks-and-labels\/data\/Lung\\ Segmentation","6837b756":"base_path = Path('..') \/ 'input' \/ 'chest-xray-masks-and-labels'\nall_images_df = pd.DataFrame({'path': list(base_path.glob('**\/*.*p*g'))})\nall_images_df.sample(3)","a55e78d8":"all_images_df['modality'] = all_images_df['path'].map(lambda x: x.parent.stem)\nall_images_df['source'] = all_images_df['path'].map(lambda x: x.stem.split('_')[0])\nall_images_df['image_id'] = all_images_df['path'].map(lambda x: '_'.join(x.stem.split('_')[1:2]))\nall_images_df = all_images_df[all_images_df['modality'].isin(['masks', 'CXR_png'])]\nprint(all_images_df['modality'].value_counts())\nall_images_df.sample(3)","8fefd0dd":"all_images_df['path'].values[:4]","2e419f2d":"flat_images_df = all_images_df.pivot_table(index=['source', 'image_id'], \n                          columns='modality', \n                          values='path', \n                          aggfunc='first').\\\n    reset_index().\\\n    sort_values('image_id').\\\n    dropna()\nprint(flat_images_df.shape[0])\nflat_images_df.sample(3)","97dc0c48":"fig, (a_axs, b_axs) = plt.subplots(2, 4, figsize=(20, 5))\nfor a_ax, b_ax, (_, c_row) in  zip(a_axs, b_axs, flat_images_df.sample(20).iterrows()):\n    a_img = imread(c_row['CXR_png'])\n    a_ax.imshow(a_img)\n    a_ax.set_title(c_row['source'])\n    b_img = imread(c_row['masks'])\n    b_ax.imshow(b_img)","aa6ce493":"fig, (a_axs, b_axs) = plt.subplots(2, 4, figsize=(20, 5))\nfor a_ax, b_ax, (_, c_row) in  zip(a_axs, b_axs, flat_images_df.sample(20).iterrows()):\n    a_img = imread(c_row['CXR_png'])\n    a_ax.hist(a_img.ravel())\n    a_ax.set_title(c_row['source'])\n    b_img = imread(c_row['masks'])\n    b_ax.hist(b_img.ravel())","d2e03988":"#all_images_df = all_images_df.sample(4096)\nimages_a_df = all_images_df[all_images_df['modality']=='CXR_png'].copy()\nimages_a_df['image_path'] = images_a_df['path'].map(str)\nimages_b_df = all_images_df[all_images_df['modality']=='masks'].copy()\nimages_b_df['image_path'] = images_b_df['path'].map(str)","39986358":"class CycleGAN():\n    def __init__(self,\n                 img_rows,\n                 img_cols,\n                 channels_A,\n                 channels_B,\n                 parallel_channels=True,\n                 ):\n        \"\"\"\n        args:\n          parallel_channels: process each input and output channel on its own\n        \"\"\"\n        # Input shape\n        self.img_rows = img_rows\n        self.img_cols = img_cols\n        self.channels_A = channels_A\n        self.channels_B = channels_B\n        self.parallel_channels = parallel_channels\n        self.img_shape_A = (self.img_rows, self.img_cols, self.channels_A)\n        self.img_shape_B = (self.img_rows, self.img_cols, self.channels_B)\n        # Calculate output shape of D (PatchGAN)\n        patch_r = int(self.img_rows \/ 2**4)\n        patch_c = int(self.img_cols \/ 2**4)\n        self.disc_patch = (patch_r, patch_c, 1)\n\n        # Number of filters in the first layer of G and D\n        self.gf = 32\n        self.df = 64\n\n        # Loss weights\n        self.lambda_cycle = 10.0                    # Cycle-consistency loss\n        self.lambda_id = 0.1 * self.lambda_cycle    # Identity loss\n\n        optimizer = Adam(0.0002, 0.5)\n\n        # Build and compile the discriminators\n        self.d_A = self.build_discriminator(self.img_shape_A, suffix='A')\n        self.d_B = self.build_discriminator(self.img_shape_B, suffix='B')\n        self.d_A.compile(loss='mse',\n                         optimizer=optimizer,\n                         metrics=['accuracy'])\n        self.d_B.compile(loss='mse',\n                         optimizer=optimizer,\n                         metrics=['accuracy'])\n\n        # -------------------------\n        # Construct Computational\n        #   Graph of Generators\n        # -------------------------\n\n        # Build the generators\n        self.g_AB = self.build_generator(\n            self.img_shape_A, self.img_shape_B, suffix='AB')\n        self.g_BA = self.build_generator(\n            self.img_shape_B, self.img_shape_A, suffix='BA')\n\n        # Input images from both domains\n        img_A = Input(shape=self.img_shape_A, name='ImageA')\n        img_B = Input(shape=self.img_shape_B, name='ImageB')\n\n        # Translate images to the other domain\n        fake_B = self.g_AB(img_A)\n        fake_A = self.g_BA(img_B)\n        # Translate images back to original domain\n        reconstr_A = self.g_BA(fake_B)\n        reconstr_B = self.g_AB(fake_A)\n        # Identity mapping of images\n        img_A_id = self.g_BA(img_B)\n        img_B_id = self.g_AB(img_A)\n\n        # For the combined model we will only train the generators\n        self.d_A.trainable = False\n        self.d_B.trainable = False\n\n        # Discriminators determines validity of translated images\n        valid_A = self.d_A(fake_A)\n        valid_B = self.d_B(fake_B)\n\n        # Combined model trains generators to fool discriminators\n        self.combined = Model(inputs=[img_A, img_B],\n                              outputs=[valid_A, valid_B,\n                                       reconstr_A, reconstr_B,\n                                       img_A_id, img_B_id])\n        self.combined.compile(loss=['mse', 'mse',\n                                    'mae', 'mae',\n                                    'mae', 'mae'],\n                              loss_weights=[1, 1,\n                                            self.lambda_cycle, self.lambda_cycle,\n                                            self.lambda_id, self.lambda_id],\n                              optimizer=optimizer)\n\n    def build_generator(self, in_img_shape, out_img_shape, suffix=''):\n        \"\"\"U-Net Generator\"\"\"\n        in_chan = in_img_shape[-1]\n        out_chan = out_img_shape[-1]\n        gf_down = self.gf \/\/ in_chan if self.parallel_channels else self.gf\n        gf_up = self.gf \/\/ in_chan if self.parallel_channels else self.gf\n\n        def conv2d(layer_input, filters, f_size=4):\n            \"\"\"Layers used during downsampling\"\"\"\n            d = Conv2D(filters, kernel_size=f_size,\n                       strides=2, padding='same')(layer_input)\n            d = LeakyReLU(alpha=0.2)(d)\n            d = InstanceNormalization()(d)\n            return d\n\n        def deconv2d(layer_input, skip_input, filters, f_size=4, dropout_rate=0):\n            \"\"\"Layers used during upsampling\"\"\"\n            u = UpSampling2D(size=2)(layer_input)\n            u = Conv2D(filters, kernel_size=f_size, strides=1,\n                       padding='same', activation='relu')(u)\n            if dropout_rate:\n                u = Dropout(dropout_rate)(u)\n            u = InstanceNormalization()(u)\n            u = Concatenate()([u, skip_input])\n            return u\n\n        # Image input\n        d0 = Input(shape=in_img_shape)\n        # Downsampling\n\n        def _ds_pipe(in_d0):\n            d1 = conv2d(in_d0, gf_down)\n            d2 = conv2d(d1, gf_down*2)\n            d3 = conv2d(d2, gf_down*4)\n            d4 = conv2d(d3, gf_down*8)\n            return d1, d2, d3, d4\n\n        if (in_chan > 1) and self.parallel_channels:\n            chan_list = []\n            for i in range(in_chan):\n                c_d0 = layers.Lambda(\n                    lambda x: x[:, :, :, i:(i+1)],\n                    name='InSel{}_{}'.format(suffix, i))(d0)\n                chan_list.append(_ds_pipe(c_d0))\n            d1, d2, d3, d4 = [\n                layers.concatenate(list(c_outs))\n                for c_outs in zip(*chan_list)]\n        else:\n            d1, d2, d3, d4 = _ds_pipe(d0)\n\n        # Upsampling\n        def _us_pipe(chan_count, d1, d2, d3, d4):\n            u1 = deconv2d(d4, d3, gf_up*4)\n            u2 = deconv2d(u1, d2, gf_up*2)\n            u3 = deconv2d(u2, d1, gf_up)\n\n            u4 = UpSampling2D(size=2)(u3)\n            output_img = Conv2D(chan_count, kernel_size=4, strides=1,\n                            padding='same', activation='sigmoid')(u4)\n            return output_img\n        \n        \n        if (out_chan > 1) and self.parallel_channels:\n            chan_list = []\n            for i in range(out_chan):\n                chan_list.append(_us_pipe(1, d1, d2, d3, d4))\n            output_img = layers.concatenate(chan_list)\n        else:\n            output_img = _us_pipe(out_chan, d1, d2, d3, d4)\n        \n\n        return Model(d0, output_img, name='Gen{}_{}_{}_{}-{}'.format(suffix, *in_img_shape, out_img_shape[-1]))\n\n    def build_discriminator(self, img_shape, suffix=''):\n        in_chan = img_shape[-1]\n        df = self.df \/\/ in_chan if self.parallel_channels else self.df\n\n        def d_layer(layer_input, filters, f_size=4, normalization=True):\n            \"\"\"Discriminator layer\"\"\"\n            d = Conv2D(filters, kernel_size=f_size,\n                       strides=2, padding='same')(layer_input)\n            d = LeakyReLU(alpha=0.2)(d)\n            if normalization:\n                d = InstanceNormalization()(d)\n            return d\n\n        img = Input(shape=img_shape)\n\n        def _disc_block(in_img):\n            d1 = d_layer(in_img, df, normalization=False)\n            d2 = d_layer(d1, df*2)\n            d3 = d_layer(d2, df*4)\n            d4 = d_layer(d3, df*8)\n            return d4\n\n        if (in_chan > 1) or not self.parallel_channels:\n            chan_list = []\n            for i in range(in_chan):\n                c_img = layers.Lambda(\n                    lambda x: x[:, :, :, i:(i+1)],\n                    name='DiscSelect{}_{}'.format(suffix, i))(img)\n                chan_list.append(_disc_block(c_img))\n            d4 = layers.concatenate(chan_list)\n        else:\n            d4 = _disc_block(img)\n\n        validity = Conv2D(1, kernel_size=4, strides=1, padding='same')(d4)\n\n        return Model(img, validity, name='Disc{}_{}_{}_{}'.format(suffix, *img_shape))","4abb250c":"IMAGE_SIZE = 128, 128\nIMAGE_A_CHANNELS = 1 # X-ray\nIMAGE_B_CHANNELS = 1 # Segmentation","eeb914fb":"cg = CycleGAN(IMAGE_SIZE[0], IMAGE_SIZE[1], IMAGE_A_CHANNELS, IMAGE_B_CHANNELS)","c20d387f":"Image(model_to_dot(cg.combined, show_shapes=True).create_png())","c51546ae":"Image(model_to_dot(cg.g_AB, show_shapes=True).create_png())","3e12a2b9":"Image(model_to_dot(cg.d_A, show_shapes=True).create_png())","3f5bec9d":"from keras.preprocessing.image import ImageDataGenerator\ndg_args = dict(featurewise_center = False, \n                  rotation_range = 10, \n                  width_shift_range = 0.1, \n                  height_shift_range = 0.1, \n                  shear_range = 0.01,\n                  zoom_range = [0.9, 1.25],  \n                  brightness_range = [0.7, 1.3],\n                  horizontal_flip = True, \n                  vertical_flip = False,\n                  fill_mode = 'reflect',\n                   data_format = 'channels_last',\n              preprocessing_function=lambda x: x\/255.0)\n\ncore_idg = ImageDataGenerator(**dg_args)","271194ed":"from sklearn.model_selection import train_test_split\n\nclass loader_class():\n    def __init__(self, a_df, b_df, goal_size):\n        self.goal_size = goal_size\n        self.a_df = a_df\n        self.b_df = b_df\n        self._a_gen = None\n        self._b_gen = None\n        self.n_batches = 0\n\n    def _make_gen(self, batch_size, use_cached):\n        if use_cached and (self._a_gen is not None):\n            return self._a_gen, self._b_gen\n        \n            \n        a_gen = core_idg.flow_from_dataframe(self.a_df,\n                                               x_col='image_path',\n                                               y_col='image_path',\n                                               class_mode=None,\n                                               target_size=self.goal_size,\n                                               color_mode='grayscale',\n                                               batch_size=batch_size)\n        b_gen = core_idg.flow_from_dataframe(self.b_df,\n                                                 x_col='image_path',\n                                                 y_col='image_path',\n                                                 class_mode=None,\n                                                 target_size=self.goal_size,\n                                                 color_mode='grayscale',\n                                                 batch_size=batch_size)\n        if use_cached:\n            self._a_gen = a_gen\n            self._b_gen = b_gen\n        \n        return a_gen, b_gen\n\n    def load_batch(self, batch_size):\n        a_gen, b_gen = self._make_gen(batch_size, use_cached=False)\n        for a_x, b_x in zip(a_gen, b_gen):\n            if (a_x.shape[0]==batch_size) and (b_x.shape[0]==batch_size):\n                yield a_x, b_x\n            else:\n                yield None, None\n\n    def load_data(self, domain=\"A\", batch_size=1, is_testing=False):\n        a_gen, b_gen = self._make_gen(batch_size, use_cached=True)\n        if domain == \"A\":\n            return next(a_gen)\n        elif domain == \"B\":\n            return next(b_gen)\n        else:\n            raise ValueError(\"Unknown domain\")\n\n\nloader_obj = loader_class(\n    a_df=images_a_df, \n    b_df=images_b_df, \n    goal_size=IMAGE_SIZE\n)\nloader_obj.load_data(domain=\"A\", batch_size=1, is_testing=True).shape","7cf794ef":"# sanity check on the tool\nfor _, (a, b) in zip(range(2), loader_obj.load_batch(8)):\n    print(a.shape, b.shape)","f989f7e1":"def sample_images(cyc_gan, data_loader, epoch, batch_i):\n    plt.close('all')\n    r, c = 2, 3\n\n    imgs_A = data_loader.load_data(domain=\"A\", batch_size=1, is_testing=True)\n    imgs_B = data_loader.load_data(domain=\"B\", batch_size=1, is_testing=True)\n\n    # Translate images to the other domain\n    fake_B = cyc_gan.g_AB.predict(imgs_A)\n    fake_A = cyc_gan.g_BA.predict(imgs_B)\n    # Translate back to original domain\n    reconstr_A = cyc_gan.g_BA.predict(fake_B)\n    reconstr_B = cyc_gan.g_AB.predict(fake_A)\n\n    gen_imgs = [imgs_A, fake_B, reconstr_A, imgs_B, fake_A, reconstr_B]\n\n    titles = ['Original', 'Translated', 'Reconstructed']\n    fig, axs = plt.subplots(r, c, figsize=(10, 5))\n    cnt = 0\n    for i in range(r):\n        for j in range(c):\n            c_img = np.clip(0.5 * gen_imgs[cnt][0]+0.5, 0, 1)\n            axs[i,j].imshow(c_img.squeeze(), cmap='gray', vmin=0, vmax=1)\n            axs[i, j].set_title('{} {}'.format(titles[j], 'A' if i==0 else 'B'))\n            axs[i,j].axis('off')\n            cnt += 1\n    fig.savefig(\"{:03d}_{:03d}.png\".format(epoch, batch_i))\nsample_images(cg, loader_obj, 0, 0)","90f401b8":"BATCH_SIZE = 64\nEPOCHS = 30","0536a147":"start_time = datetime.datetime.now()\n\n# Adversarial loss ground truths\nvalid = np.ones((BATCH_SIZE,) + cg.disc_patch)\nfake = np.zeros((BATCH_SIZE,) + cg.disc_patch)\n\nfor epoch in tqdm_notebook(range(EPOCHS), desc='Epochs'):\n    for batch_i, (imgs_A, imgs_B) in tqdm_notebook(enumerate(loader_obj.load_batch(BATCH_SIZE)), desc='Batch'):\n        #  Train Discriminators\n        if imgs_A is None:\n            break\n        # Translate images to opposite domain\n        fake_B = cg.g_AB.predict(imgs_A)\n        fake_A = cg.g_BA.predict(imgs_B)\n\n        # Train the discriminators (original images = real \/ translated = Fake)\n        dA_loss_real = cg.d_A.train_on_batch(imgs_A, valid)\n        dA_loss_fake = cg.d_A.train_on_batch(fake_A, fake)\n        dA_loss = 0.5 * np.add(dA_loss_real, dA_loss_fake)\n\n        dB_loss_real = cg.d_B.train_on_batch(imgs_B, valid)\n        dB_loss_fake = cg.d_B.train_on_batch(fake_B, fake)\n        dB_loss = 0.5 * np.add(dB_loss_real, dB_loss_fake)\n\n        # Total disciminator loss\n        d_loss = 0.5 * np.add(dA_loss, dB_loss)\n        \n        #  Train Generators\n        # Train the generators\n        g_loss = cg.combined.train_on_batch([imgs_A, imgs_B],\n                                                [valid, valid,\n                                                imgs_A, imgs_B,\n                                                imgs_A, imgs_B])\n\n        elapsed_time = datetime.datetime.now() - start_time\n    \n    # Plot the progress at each epoch\n    print (\"[Epoch %d\/%d] [Batch %d\/%d] [D loss: %f, acc: %3d%%] [G loss: %05f, adv: %05f, recon: %05f, id: %05f] time: %s \" \\\n                                                            % ( epoch, EPOCHS,\n                                                                batch_i, loader_obj.n_batches,\n                                                                d_loss[0], 100*d_loss[1],\n                                                                g_loss[0],\n                                                                np.mean(g_loss[1:3]),\n                                                                np.mean(g_loss[3:5]),\n                                                                np.mean(g_loss[5:6]),\n                                                                elapsed_time))\n    \n    clear_output()\n    sample_images(cg, loader_obj, epoch, batch_i)\n","df43531f":"sample_images(cg, loader_obj, EPOCHS, 1)","4947a406":"sample_images(cg, loader_obj, EPOCHS, 2)","b62bc847":"sample_images(cg, loader_obj, EPOCHS, 3)","627c33bc":"sample_images(cg, loader_obj, EPOCHS, 4)","9320dc1c":"sample_images(cg, loader_obj, EPOCHS, 5)","7405c16d":"# Goal\nHere we try an experiment to see if we can take unpaired (they happen to be paired in this dataset but we ignore that) images of chest x-rays and segmentations of lungs and learn a forward (X-Ray$\\rightarrow$ Lungs) and reverse (Lungs $\\rightarrow$ X-ray) mapping using the CycleGAN approach. The basic idea is we have generators for both of the mappings with a U-Net style architecture (which forces them to learn something from the original pixels). We then have discriminators which determine if the images we have created are real or fake. Finally we have the cycle-consistent loss of using both the forward and backward back-to-back which should give us the original images. \n\nIf this works well it could be applied to lots of issues where paired training data are not available. It should also produce more 'realistic' segmentations since the discriminator is actively trying to determine if the image output is discernible real data.","b857738f":"## Setup and Data","58ca7ee2":"# Model Parameters","e35b8e9b":"## Preview Model Output","0eef8cdd":"# Build Models","081246a6":"# Train Model","0a2855c4":"## Generators\nWe just show one and the other can be inferred","1e46be32":"## Discriminator","fa302911":"# Data Loaders\nHere we setup the data-loaders","fdadc2e8":"# Setup CycleGAN Code\nThe code below has been lightly adapted from the code at https:\/\/github.com\/eriklindernoren\/Keras-GAN\/tree\/master\/cyclegan by @eriklindernoren"}}