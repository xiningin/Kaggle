{"cell_type":{"e62765a3":"code","f7a89726":"code","4814d2f1":"code","91338a24":"code","e5cb92da":"code","1fc53ec6":"code","2575e4c4":"code","a6ae1432":"code","b6aa7b07":"code","b25ce0bf":"code","2413c516":"code","9243fff4":"code","f04e6bc8":"code","03074694":"code","82b22aa1":"code","91ff1dc5":"code","b8a949ef":"code","507e468c":"code","4cb580af":"code","20ed8304":"code","f053cff4":"code","c1b33e01":"code","0f51cd3e":"code","89ef0467":"code","ebe68d99":"code","9529fe28":"code","dbdaba61":"code","4f022025":"code","952532ba":"code","77a40cbb":"code","f3e8b1d8":"code","7e73ef4a":"code","1482e7c1":"code","489553c5":"code","53ac1077":"code","750303cf":"code","edcebcc1":"code","a44baa4b":"code","17db2010":"code","f45aba55":"code","6162d7fb":"code","638cc38d":"code","72e67f65":"code","d95e9815":"code","b169b0c4":"markdown"},"source":{"e62765a3":"import numpy as np\nimport pandas as pd\nimport os\nprint(os.listdir(\"\/kaggle\/input\/tgs-salt-identification-challenge\/\"))\n#os.getcwd()","f7a89726":"from fastai.conv_learner import *\nfrom fastai.dataset import *\n\nfrom pathlib import Path\nimport json\ntorch.cuda.set_device(0)","4814d2f1":"PATH = Path('\/kaggle\/input\/tgs-salt-identification-challenge\/train')\nlist(PATH.iterdir())","91338a24":"MASKS_FN = 'train.csv'\nTRAIN_DN = 'images'\nMASKS_DN = 'masks'\n\nPATH1 = Path('\/kaggle\/input\/tgs-salt-identification-challenge')\nmasks_csv = pd.read_csv(PATH1\/MASKS_FN)\nmasks_csv.head()","e5cb92da":"#https:\/\/realpython.com\/python-pathlib\/\nimport collections\nPATH1 = Path('\/kaggle\/input\/tgs-salt-identification-challenge\/train\/masks')\ncollections.Counter(p.suffix for p in PATH1.iterdir())","1fc53ec6":"PATH2 = Path('\/kaggle\/input\/tgs-salt-identification-challenge\/train\/images')\ncollections.Counter(p.suffix for p in PATH2.iterdir())","2575e4c4":"PATH3 = Path('\/kaggle\/input\/tgs-salt-identification-challenge\/test\/images')\ncollections.Counter(p.suffix for p in PATH3.iterdir())","a6ae1432":"masks_csv.isnull().sum()","b6aa7b07":"#masks_csv=masks_csv.dropna()\nmasks_csv['id']=masks_csv['id']+\".png\"","b25ce0bf":"masks_csv.count()","2413c516":"def show_img(im, figsize=None, ax=None, alpha=None):\n    if not ax: fig,ax = plt.subplots(figsize=figsize)\n    ax.imshow(im, alpha=alpha)\n    ax.set_axis_off()\n    return ax","9243fff4":"#Image.open(PATH\/TRAIN_DN\/f'4875705fb0.png')#.size","f04e6bc8":"!rm -rf \/tmp\/mask_128\n!rm -rf \/tmp\/train_128 \n!rm -rf \/tmp\/test_128 \n!mkdir -p \/tmp\/mask_128\n!mkdir -p \/tmp\/train_128\n!mkdir -p \/tmp\/test_128\nPATH4 = Path('\/kaggle\/input\/tgs-salt-identification-challenge\/train\/masks')\ni=os.listdir(PATH4)\nfor j in range(4000):\n     Image.open(PATH4\/i[j]).resize((128,128)).save('\/tmp\/mask_128\/'+i[j])\n        \nPATH4=Path('\/kaggle\/input\/tgs-salt-identification-challenge\/train\/images')\nfor j in range(4000):\n     Image.open(PATH4\/i[j]).resize((128,128)).save('\/tmp\/train_128\/'+i[j])\n\nPATH4=Path('\/kaggle\/input\/tgs-salt-identification-challenge\/test\/images')\ni=os.listdir(PATH4)\nfor j in range(18000):\n     Image.open(PATH4\/i[j]).resize((128,128)).save('\/tmp\/test_128\/'+i[j])\n\nTRAIN_DN=Path('\/tmp\/train_128')\nMASKS_DN=Path('\/tmp\/mask_128')\nTEST_DN=Path('\/tmp\/test_128')\n","03074694":"ims = [open_image(PATH\/TRAIN_DN\/f'{i}') for i in masks_csv['id'].head(30)]\nim_masks = [open_image(PATH\/MASKS_DN\/f'{i}') for i in masks_csv['id'].head(30)]\nfig, axes = plt.subplots(5, 6, figsize=(18, 12))\n\nfor i,ax in enumerate(axes.flat):\n    ax = show_img(ims[i], ax=ax)\n    show_img(im_masks[i][...,0], ax=ax, alpha=0.5)\nplt.tight_layout(pad=0.1)","82b22aa1":"x_names = np.array([Path(TRAIN_DN)\/o for o in masks_csv['id']])\ny_names = np.array([Path(MASKS_DN)\/o for o in masks_csv['id']])\nlen(x_names)\/\/5","91ff1dc5":"a=os.listdir('\/tmp\/test_128')\ntest_names = np.array([Path(TEST_DN)\/o for o in a])\ntest_name = (test_names ,test_names)","b8a949ef":"val_idxs = list(range(len(x_names)\/\/5))\n((val_x,trn_x),(val_y,trn_y)) = split_by_idx(val_idxs, x_names, y_names)\nlen(val_x),len(trn_x)","507e468c":"sz = 128\nbs = 64","4cb580af":"class MatchedFilesDataset(FilesDataset):\n    def __init__(self, fnames, y, transform, path):\n        self.y=y\n        assert(len(fnames)==len(y))\n        super().__init__(fnames, transform, path)\n    def get_y(self, i): return open_image(os.path.join(self.path, self.y[i]))\n    def get_c(self): return 0\n\n\naug_tfms = [RandomRotate(4, tfm_y=TfmType.CLASS),\n            RandomFlip(tfm_y=TfmType.CLASS),\n            RandomLighting(0.05, 0.05)]\n\ntfms = tfms_from_model(resnet34, sz, crop_type=CropType.NO, tfm_y=TfmType.CLASS, aug_tfms=aug_tfms)\ndatasets = ImageData.get_ds(MatchedFilesDataset, (trn_x,trn_y), (val_x,val_y), tfms,test = test_name, path=PATH)\nmd = ImageData(PATH, datasets, bs, num_workers=8, classes=None)","20ed8304":"denorm = md.trn_ds.denorm\nx,y = next(iter(md.aug_dl))\nx = denorm(x)","f053cff4":"fig, axes = plt.subplots(5, 6, figsize=(12, 10))\nfor i,ax in enumerate(axes.flat):\n    ax=show_img(x[i], ax=ax)\n    show_img(y[i], ax=ax, alpha=0.5)\nplt.tight_layout(pad=0.1)","c1b33e01":"# Copy resnet34 model\n!mkdir -p \/tmp\/.torch\/models\n!cp \/kaggle\/input\/resnet34\/resnet34.pth \/tmp\/.torch\/models\/resnet34-333f7ec4.pth ","0f51cd3e":"# Model\nclass StdUpsample(nn.Module):\n    def __init__(self, nin, nout):\n        super().__init__()\n        self.conv = nn.ConvTranspose2d(nin, nout, 2, stride=2)\n        self.bn = nn.BatchNorm2d(nout)\n        \n    def forward(self, x): return self.bn(F.relu(self.conv(x)))\n\nflatten_channel = Lambda(lambda x: x[:,0])\nsimple_up = nn.Sequential(\n    nn.ReLU(),\n    StdUpsample(512,256),\n    StdUpsample(256,256),\n    StdUpsample(256,256),\n    StdUpsample(256,256),\n    nn.ConvTranspose2d(256, 1, 2, stride=2),\n    flatten_channel\n)","89ef0467":"# IOU\/Jaccard index - metrics\ndef jacc(pred, targs):\n    pred = (pred>0).float()\n    dice = 2. * (pred*targs).sum() \/ (pred+targs).sum()\n    return dice\/(2-dice)","ebe68d99":"md.path = Path('\/tmp')\nmodels =  ConvnetBuilder (resnet34, 0, 0, 0, custom_head=simple_up)\nlearn = ConvLearner(md, models)\nlearn.opt_fn=optim.Adam\nlearn.crit=nn.BCEWithLogitsLoss()\nlearn.metrics=[accuracy_thresh(0.5)\n              # ,jacc\n              ]","9529fe28":"learn.summary()","dbdaba61":"learn.lr_find()\nlearn.sched.plot()","4f022025":"lr=1e-1\nlearn.fit(lr,1,cycle_len=5,use_clr=(10,5))","952532ba":"learn.save('tmp')\nlearn.load('tmp')\npy,ay = learn.predict_with_targs()\nay.shape","77a40cbb":"show_img(ay[8]);","f3e8b1d8":"show_img(py[8]>0);","7e73ef4a":"learn.unfreeze()\n#learn.bn_freeze(True)\nlrs = np.array([lr\/100,lr\/10,lr])\/10\nlearn.fit(lrs,1,cycle_len=10,use_clr=(10,10))","1482e7c1":"learn.save('0')\nx,y = next(iter(md.val_dl))\npy = to_np(learn.model(V(x)))","489553c5":"i=52\nax = show_img(denorm(x)[i])\nshow_img(py[i]>0, ax=ax, alpha=0.5);","53ac1077":"ax = show_img(denorm(x)[i])\nshow_img(y[i], ax=ax, alpha=0.5);","750303cf":"# Predict on Test data\nout=learn.predict(is_test=True)\nout.shape","edcebcc1":"#j=452\nj=14550\nImage.open(PATH\/TEST_DN\/a[j])","a44baa4b":"columns = ['id']\nb= pd.DataFrame(a,columns=columns)\nshow_img(out[j]>0)\n#a[1]","17db2010":"# Resize Predictions to 101x101\nresult_array = np.zeros((18000,101,101),dtype=float)\n\nimport cv2\nfor i in range(18000):\n    img = out[i]\n    result_array[i] = cv2.resize(img, dsize=(101, 101), interpolation=cv2.INTER_CUBIC)>0\n","f45aba55":"# Save Predications to disk\n!rm -rf \/tmp\/output1\/*\n!mkdir -p \/tmp\/output1\n\nfor i in range(18000):\n    plt.imsave('\/tmp\/output1\/'+a[i], result_array[i])\n","6162d7fb":"OUT_PATH = Path('\/tmp\/output1')\nims = [open_image(TEST_DN\/f'{i}') for i in b['id'].head(40)]\nim_masks = [open_image(OUT_PATH\/f'{i}')  for i in b['id'].head(40)]\nfig, axes = plt.subplots(5, 8, figsize=(18, 12))\n\nfor i,ax in enumerate(axes.flat):\n    ax = show_img(ims[i], ax=ax)\n    show_img(im_masks[i][...,0], ax=ax, alpha=0.5)\nplt.tight_layout(pad=0.1)","638cc38d":"def rle_encode(im):\n    '''\n    im: numpy array, 1 - mask, 0 - background\n    Returns run length as string formated\n    '''\n    pixels = im.flatten()\n    pixels = np.concatenate([[0], pixels, [0]])\n    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1\n    runs[1::2] -= runs[::2]\n    return ' '.join(str(x) for x in runs)","72e67f65":"#Write encoded value to list\ntemp_list = []\nfor i in range(18000):\n    temp_list.append(rle_encode(result_array[i]))","d95e9815":"# Merge mask with Dataframe and write csv to disk\nb['rle_mask']=pd.Series(temp_list).values\nb['id'] = b['id'].astype(str).str.replace(r\".png\", '')\nb.to_csv('\/kaggle\/working\/submission.csv', index = False, header = True)","b169b0c4":"**Plese Up-Vote if you find the kernel to be useful !**"}}