{"cell_type":{"125f497a":"code","d97cde8f":"code","0c81b9d4":"code","c2677015":"code","781dbaa7":"code","c085e0fd":"code","bf9921bf":"code","918fbafe":"code","f28af504":"code","08b0c9a7":"code","f50993b0":"code","b3ca3978":"code","4ff67f7c":"code","ae68f197":"code","257cb9e1":"code","7a811ece":"code","c7d29268":"code","ab61f376":"code","80e29cc6":"code","e497c670":"code","2b3c33cd":"code","575cd04e":"code","463d4331":"code","6a463efa":"code","f4dc1f6d":"code","56bcee91":"code","947d864d":"code","c675f425":"code","c0ebbacd":"code","75a6b100":"code","93888b42":"code","1249953d":"code","a87617e2":"code","0a4ba099":"code","a1329c40":"code","f0fca80d":"code","b160640e":"code","b80c8b4a":"code","1b5b63de":"code","78643b5c":"code","95e713f9":"code","74489714":"code","c9d086ee":"code","5d76c3a9":"code","4d8612f0":"code","fb311993":"code","e34653bd":"code","e56cff6a":"code","3680467f":"code","d70dca96":"markdown","1bf191cd":"markdown","00398818":"markdown","7706cd84":"markdown","e30f1b23":"markdown","e948a2a4":"markdown","2fef52b6":"markdown","c2c7951a":"markdown","ac2ca7a7":"markdown","0ec49646":"markdown","136f45d5":"markdown","9569cfda":"markdown","9cf10963":"markdown","34f8801b":"markdown","1382fdb7":"markdown","36dbcbe5":"markdown","03c15b64":"markdown","076cf65d":"markdown","f1979fcf":"markdown","10c0f954":"markdown","3b6c5be4":"markdown","509cf7a3":"markdown","c5015cad":"markdown","ef4ae185":"markdown","5911e4f4":"markdown","60f07489":"markdown","3f79ace6":"markdown","353ae5f8":"markdown","0fdc74a1":"markdown","1f79f66b":"markdown","e1494bc6":"markdown","204fe32e":"markdown","9f3218bc":"markdown","4b334f4a":"markdown","8b0ff248":"markdown","17de3ac4":"markdown","9032e6bd":"markdown","293c2420":"markdown"},"source":{"125f497a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d97cde8f":"import matplotlib as mpl\nimport matplotlib.pyplot as plt \nimport matplotlib.dates as md\n%matplotlib inline\nimport seaborn as sns\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.model_selection import cross_val_predict\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.metrics import make_scorer\nimport ast\nfrom scipy import stats\nfrom sklearn.linear_model import LinearRegression\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\nplt.style.use('seaborn')\nmpl.rcParams['figure.figsize'] = (15,5)\nfrom collections import Counter","0c81b9d4":"# data from https:\/\/www.kaggle.com\/c\/tmdb-box-office-prediction\/data\ndf_train = pd.read_csv('\/kaggle\/input\/tmdb-box-office-prediction\/train.csv')\ndf_test = pd.read_csv('\/kaggle\/input\/tmdb-box-office-prediction\/test.csv')","c2677015":"print(df_train.shape)\ndf_train.head()","781dbaa7":"print(df_test.shape)\ndf_test.head(3)","c085e0fd":"df_train.describe()","bf9921bf":"df_train.info()","918fbafe":"df_test.describe()","f28af504":"col_vary = []\ntest_col = df_test.columns\ntrain_col = df_train.columns\nvar = list(set(df_train)-set(df_test))\n\nprint(\"The Training DataFrame contains all the same Headers as the Testing DataFrame except \" + str(var[0])) ","08b0c9a7":"sns.boxplot(x=df_train['runtime'])\nplt.title('Boxplot of Runtime')","f50993b0":"sns.boxplot(x=df_train['budget'])\nplt.title('Boxplot of Budget')","b3ca3978":"df_train_na = df_train.isna().sum().sort_values(ascending=True)\ndf_train_na.plot(kind='barh')\nplt.title(\"Distribution of NA\")\n\nfor i, v in enumerate(sorted(df_train_na)):\n    plt.text(v, i, str(v), va=\"center\")","4ff67f7c":"bq_low = df_train['budget'].quantile(0.01)\nbq_hi  = df_train['budget'].quantile(0.99)\nrq_low = df_train['runtime'].quantile(0.01)\nrq_hi  = df_train['runtime'].quantile(0.99)\ndf_train_filtered = df_train[(df_train['budget'] < bq_hi) & (df_train['budget'] > bq_low) & (df_train['runtime'] < rq_hi) & (df_train['runtime'] > rq_low)]\ndf_train_filtered.shape","ae68f197":"sns.boxplot(x=df_train_filtered['runtime'])\nplt.title('Boxplot of Runtime(Outliers Removed)')","257cb9e1":"sns.boxplot(x=df_train_filtered['budget'])\nplt.title('Boxplot of Budget(Outliers Removed)')","7a811ece":"len(df_train) - len(df_train_filtered)","c7d29268":"# from this kernel: https:\/\/www.kaggle.com\/gravix\/gradient-in-a-box\ndict_columns = ['belongs_to_collection', 'genres', 'production_companies',\n                'production_countries', 'spoken_languages', 'Keywords', 'cast', 'crew']\n\ndef text_to_dict(df):\n    for column in dict_columns:\n        df[column] = df[column].apply(lambda x: {} if pd.isna(x) else ast.literal_eval(x) )\n    return df\n        \ndf_train = text_to_dict(df_train)\ndf_test = text_to_dict(df_test)","ab61f376":"df_train.head(2)","80e29cc6":"# original code from: https:\/\/www.kaggle.com\/artgor\/eda-feature-engineering-and-model-interpretation\n\n# creates a new column with collection name\ndf_train['collection_name'] = df_train['belongs_to_collection'].apply(lambda x: x[0]['name'] if x != {} else 0)\ndf_train['collection_name'].head()","e497c670":"# creates a bool val if in collection or not\ndf_train['has_collection'] = df_train['belongs_to_collection'].apply(lambda x: len(x) if x != {} else 0)\ndf_train['has_collection'].head()","2b3c33cd":"col_count = df_train['has_collection'].value_counts()\nprint(\" In the Trainining data there are \" + str(col_count[0])+\" Films in a collection\")","575cd04e":"# creates a new column with collection name for Testing df\ndf_test['collection_name'] = df_test['belongs_to_collection'].apply(lambda x: x[0]['name'] if x != {} else 0)\ndf_test['collection_name'].head()","463d4331":"# creates a bool val if in collection or not for Testing df\ndf_test['has_collection'] = df_test['belongs_to_collection'].apply(lambda x: len(x) if x != {} else 0)\ndf_test['has_collection'].head()","6a463efa":"# original code from: https:\/\/www.kaggle.com\/artgor\/eda-feature-engineering-and-model-interpretation\n\n# creates a list of all the possible genres\nlist_of_genres = list(df_train['genres'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_genres column on the train df that has the number of genres that a movie has.\ndf_train['num_genres'] = df_train['genres'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the train df that takes all the genres out of the Dictionary \ndf_train['all_genres'] = df_train['genres'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\n# create a list of unique genres for Training dataframe\nunique_genres = []\nfor l in list_of_genres:\n    for g in l:\n        if g not in unique_genres:\n            unique_genres.append(g)\n        else:\n            pass\n# create a separate column for all the genres with bool values if true\nfor g in unique_genres:\n    df_train['genre_' + g] = df_train['all_genres'].apply(lambda x: 1 if g in x else 0)\ndf_train.head(3)","f4dc1f6d":"# creates a list of all the possible genres for Testing df\nlist_of_genres = list(df_test['genres'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_genres column on the test df that has the number of genres that a movie has.\ndf_test['num_genres'] = df_test['genres'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the test df that takes all the genres out of the Dictionary \ndf_test['all_genres'] = df_test['genres'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\n\n\n# create a separate column for all the genres with bool values if true\nfor g in unique_genres:\n    df_test['genre_' + g] = df_test['all_genres'].apply(lambda x: 1 if g in x else 0)\n        \ndf_test.head(3)","56bcee91":"# creates a list of all the possible production companies\nlist_of_production = list(df_train['production_companies'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_prod_co column on the train df that has the number of genres that a movie has.\ndf_train['num_prod_co'] = df_train['production_companies'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the train df that takes all the production companies out of the Dictionary \ndf_train['all_prod_co'] = df_train['production_companies'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\n# create a list of unique genres for Training dataframe\nunique_prod_co = []\nfor l in list_of_production:\n    for g in l:\n        if g not in unique_prod_co:\n            unique_prod_co.append(g)\n        else:\n            pass\nprint(\" There are \"+ str(len(unique_prod_co)) + \" unique Production Companies\")\n# creates a boolean column on the train df for each of the possible production co\ntop_prod_co = [m[0] for m in Counter([i for j in list_of_production for i in j]).most_common(15)]\nfor g in top_prod_co:\n    df_train['prod_co_' + g] = df_train['all_prod_co'].apply(lambda x: 1 if g in x else 0)\n    \ntop_prod_co","947d864d":"list_of_production = list(df_test['production_companies'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_prod_co column on the train df that has the number of genres that a movie has.\ndf_test['num_prod_co'] = df_test['production_companies'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the train df that takes all the production companies out of the Dictionary \ndf_test['all_prod_co'] = df_test['production_companies'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\n# creates a boolean column on the train df for each of the possible production co\ntop_prod_co = [m[0] for m in Counter([i for j in list_of_production for i in j]).most_common(15)]\nfor g in top_prod_co:\n    df_test['prod_co_' + g] = df_test['all_prod_co'].apply(lambda x: 1 if g in x else 0)","c675f425":"# creates a list of all the possible keywords\nlist_of_keywords = list(df_train['Keywords'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_keywords column on the train df that has the number of keywords.\ndf_train['num_keywords'] = df_train['Keywords'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the train df that takes all the keywords out of the Dictionary \ndf_train['all_keywords'] = df_train['Keywords'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\n# create a list of unique keywords for Training dataframe\nunique_keywords = []\nfor l in list_of_keywords:\n    for g in l:\n        if g not in unique_keywords:\n            unique_keywords.append(g)\n        else:\n            pass\nprint(\" There are \"+ str(len(unique_keywords)) + \" unique Keywords\")\n# creates a boolean column on the train df for each of the possible keywords\ntop_keywords = [m[0] for m in Counter([i for j in list_of_keywords for i in j]).most_common(15)]\nfor g in top_keywords:\n    df_train['keyword_' + g] = df_train['all_keywords'].apply(lambda x: 1 if g in x else 0)\n    \ntop_keywords\n","c0ebbacd":"# creates a list of all the possible keywords\nlist_of_keywords = list(df_test['Keywords'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_keywords column on the train df that has the number of keywords.\ndf_test['num_keywords'] = df_test['Keywords'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the train df that takes all the keywords out of the Dictionary \ndf_test['all_keywords'] = df_test['Keywords'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\nfor g in top_keywords:\n    df_test['keyword_' + g] = df_test['all_keywords'].apply(lambda x: 1 if g in x else 0)\n","75a6b100":"# creates a list of all the possible cast\nlist_of_cast = list(df_train['cast'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_keywords column on the train df that has the number of keywords.\ndf_train['num_cast'] = df_train['cast'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the train df that takes all the keywords out of the Dictionary \ndf_train['all_cast'] = df_train['cast'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\n# create a list of unique keywords for Training dataframe\nunique_cast = []\nfor l in list_of_cast:\n    for g in l:\n        if g not in unique_cast:\n            unique_cast.append(g)\n        else:\n            pass\nprint(\" There are \"+ str(len(unique_cast)) + \" unique cast\")\n# creates a boolean column on the train df for each of the possible keywords\ntop_cast = [m[0] for m in Counter([i for j in list_of_cast for i in j]).most_common(15)]\nfor g in top_cast:\n    df_train['cast_' + g] = df_train['all_cast'].apply(lambda x: 1 if g in x else 0)\ntop_cast","93888b42":"# creates a list of all the possible cast\nlist_of_cast = list(df_test['cast'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_keywords column on the train df that has the number of keywords.\ndf_test['num_cast'] = df_test['cast'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the train df that takes all the keywords out of the Dictionary \ndf_test['all_cast'] = df_test['cast'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\nfor g in top_cast:\n    df_test['cast_' + g] = df_test['all_cast'].apply(lambda x: 1 if g in x else 0)","1249953d":"# creates a list of all the possible cast\nlist_of_crew = list(df_train['crew'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_keywords column on the train df that has the number of keywords.\ndf_train['num_crew'] = df_train['crew'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the train df that takes all the keywords out of the Dictionary \ndf_train['all_crew'] = df_train['crew'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\n# create a list of unique keywords for Training dataframe\nunique_crew = []\nfor l in list_of_crew:\n    for g in l:\n        if g not in unique_crew:\n            unique_crew.append(g)\n        else:\n            pass\nprint(\" There are \"+ str(len(unique_crew)) + \" unique cast\")\n# creates a boolean column on the train df for each of the possible keywords\ntop_crew = [m[0] for m in Counter([i for j in list_of_crew for i in j]).most_common(15)]\nfor g in top_crew:\n    df_train['crew_' + g] = df_train['all_crew'].apply(lambda x: 1 if g in x else 0)\ntop_crew","a87617e2":"# creates a list of all the possible cast\nlist_of_crew = list(df_test['crew'].apply(lambda x: [i['name'] for i in x] if x != {} else []).values)\n# creates a num_keywords column on the train df that has the number of keywords.\ndf_test['num_crew'] = df_test['crew'].apply(lambda x: len(x) if x != {} else 0)\n# creates a column on the train df that takes all the keywords out of the Dictionary \ndf_test['all_crew'] = df_test['crew'].apply(lambda x: ' '.join(sorted([i['name'] for i in x])) if x != {} else '')\nfor g in top_crew:\n    df_test['crew_' + g] = df_test['all_crew'].apply(lambda x: 1 if g in x else 0)","0a4ba099":"df_train['release_date'] = pd.DataFrame(pd.to_datetime(df_train['release_date'],dayfirst=True))\ndf_train['release_month'] = df_train['release_date'].dt.month\ndf_train['release_DOW'] = df_train['release_date'].dt.dayofweek","a1329c40":"df_test['release_date'] = pd.DataFrame(pd.to_datetime(df_test['release_date'],dayfirst=True))\ndf_test['release_month'] = df_test['release_date'].dt.month\ndf_test['release_DOW'] = df_test['release_date'].dt.dayofweek","f0fca80d":"fig = plt.figure(figsize=(15, 20))\ndf_train_corr = df_train.corr()\nax = sns.heatmap(df_train_corr)","b160640e":"df_train_corr[['revenue']].sort_values(by=['revenue'],ascending = False)","b80c8b4a":"slope, intercept, r_value, p_value, std_err = stats.linregress(df_train['budget'],df_train['revenue'])\nax = sns.regplot(data=df_train, x='budget',y='revenue',line_kws={'label':\"y={0:.1f}x+{1:.1f}\".format(slope,intercept)})\nax.legend()\nplt.show()","1b5b63de":"X_linear = np.array(df_train['budget']).reshape(-1,1)\ny_linear = np.array(df_train['revenue']).reshape(-1,1)\nmodel_linear=LinearRegression()\nmodel_linear.fit(X_linear,y_linear)\ny_pred = model_linear.predict(X_linear)\nval_mae = mean_absolute_error(y_linear,y_pred)\nval_mape = np.mean(np.abs((y_linear - y_pred) \/ y_linear)) * 100\nprint( 'MAE: ' + str(val_mae))\nprint('MAPE: '+ str(val_mape))\n","78643b5c":"col_vary = []\ntest_col = df_test.columns\ntrain_col = df_train.columns\nvar = list(set(df_train)-set(df_test))\n\nprint(\"The Training DataFrame contains all the same Headers as the Testing DataFrame except \" + str(var[0])) \n","95e713f9":"drop_col = [\n    'id',\n    'imdb_id',\n    'original_title',\n    'belongs_to_collection',\n    'genres',\n    'homepage',\n    'overview',\n    'poster_path',\n    'production_countries',\n    'production_companies',\n    'spoken_languages',\n    'status',\n    'tagline',\n    'title',\n    'Keywords',\n    'cast',\n    'crew',\n    'revenue',\n    'collection_name'  \n]\nfeatures = []\nfor i in df_train.columns:\n    if i not in drop_col:\n        features.append(i)\n    else:\n        pass\n    \nfeatures\n        ","74489714":"X=df_train[features].copy()\ny=df_train['revenue'].copy()\nX_test = df_test[features].copy()","c9d086ee":"X.info()","5d76c3a9":"# Select categorical columns with relatively low cardinality (convenient but arbitrary)\ncategorical_cols = [cname for cname in X.columns if\n                    X[cname].nunique() < 10 and \n                    X[cname].dtype == \"object\"]\n\n# Select numerical columns\nnumerical_cols = [cname for cname in X.columns if \n                X[cname].dtype in ['int64', 'float64']]\n\n# Preprocessing for numerical data\nnumerical_transformer = SimpleImputer(strategy='constant')\n\n# Preprocessing for categorical data\ncategorical_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='most_frequent')),\n    ('onehot', OneHotEncoder(handle_unknown='ignore'))\n])\n\n# Bundle preprocessing for numerical and categorical data\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', numerical_transformer, numerical_cols),\n        ('cat', categorical_transformer, categorical_cols)\n    ])\n\ndef rmsle_error(y_true, y_pred): \n    assert len(y_true) == len(y_pred)\n    return np.sqrt(np.mean((np.log1p(y_pred) - np.log1p(y_true))**2))\n\nrmsle_score = make_scorer(rmsle_error, greater_is_better=False)\n\nmy_pipeline = Pipeline(steps=[('preprocessor', preprocessor),\n                      ('model', RandomForestRegressor(n_estimators=5,n_jobs=-1,min_samples_split=6, random_state=0))\n                             ])\nscores = -1 * cross_val_score(my_pipeline, X, y,\n                              cv=5,\n                              scoring=rmsle_score)\nresults = scores.mean()\nresults","4d8612f0":"\npred = cross_val_predict(my_pipeline,X,y,cv=5)\ncol = ['id','revenue']\ndf_compare = df_train[col].copy()\ndf_compare['predicted'] = pred\ndf_compare['residual'] = df_compare['revenue'] - df_compare['predicted']\n","fb311993":"plt.scatter(df_compare['predicted'],df_compare['revenue'])\nplt.plot(df_compare['revenue'],df_compare['revenue'])\nplt.show()","e34653bd":"weights = np.ones_like(df_compare['residual']) \/ (len(df_compare['residual']))\nplt.hist(df_compare['residual'],bins = 10,weights = weights)\nplt.ylabel('Probability')\nplt.xlabel('Residual');\n","e56cff6a":"my_pipeline.fit(X,y)\ny_pred = my_pipeline.predict(X_test)\ny_pred\n","3680467f":"submission = pd.DataFrame(df_test['id'].copy())\nsubmission['revenue'] = y_pred\nsubmission.to_csv(\"submission.csv\",index=False)","d70dca96":"---","1bf191cd":" ### <font color = 'blue'> Outliers Summary<\/font>\nRemoving Outliers removes 885 rows. If the dataset was larger it may be useful to remove outliers but since the Dataset is so small it may be useful to keep the outliers in training our model","00398818":"First we need to confirm Training and Testing Dataframe contain all the same columns besides revenue","7706cd84":"> #### <font color = 'blue'>Testing Dataframe<\/font>","e30f1b23":"## Outliers\n\nFrom Reading our data we noticed Outlier values. Here we will create a secondary Dataframe that will remove outliers for both <b>Runtime<\/b> and <b>Budget<\/b>","e948a2a4":"#### <font color = 'blue'>Testing Dataframe<\/font>","2fef52b6":"#### <font color ='blue'>Testing Dataframe<\/font>","c2c7951a":"# <u>**TMDB BOX OFFICE PREDICTION**<\/u>","ac2ca7a7":"## Dictionary Columns\nReading our data we noticed that there were Dictionaries in our data frame. we need to convert columns with Dictionaries into actual dictionaries that we can use.","0ec49646":"#### <font color = 'blue'>Training Dataframe<\/font>\n","136f45d5":"From our initial look of the data we see that we have 2 diffent data sets. \n\n<b>Training:<\/b> \n<ul>\n    <li>Has 3000 rows of data and 23 columns <\/li>\n    <li>Looking at the Medium and the Mean there seems to be some outliers with the <b>Budget<\/b> and <b>Runtime<\/b><\/li>\n    <li>It is odd that there are runtime and budgets of 0<\/li>            \n<\/ul>\n<b>Test:<\/b>\n<ul>\n    <li>This will be used to run our analysis on to predict <b>Revenue<\/b> <\/li>\n    <li>Has 4398 Rows of Data <\/li>\n<\/ul>\n      ","9569cfda":"## Read Data","9cf10963":"---","34f8801b":"#### <font color = 'blue'>Testing Dataframe<\/font>","1382fdb7":"### <font color = 'green'>Cross Validation with Random Forrest<\/font>","36dbcbe5":"With Linear Regression we get a Mean Absolute Error value of <b>45M<\/b>. While the R value is pretty high, such a high MAE is not a great predictor of Box office revenue.","03c15b64":"## Describe the Datasets\n### <font color = 'blue'>Training Dataframe <\/font>","076cf65d":"## Introduction\n\nIn a world\u2026 where movies made an estimated $41.7 billion in 2018, the film industry is more popular than ever. But what movies make the most money at the box office? How much does a director matter? Or the budget? For some movies, it's \"You had me at 'Hello.'\" For others, the trailer falls short of expectations and you think \"What we have here is a failure to communicate.\"","f1979fcf":"### <font color = 'blue'>Read Data Summary <\/font>","10c0f954":" ### <font color = 'blue'>Remove Outliers<\/font>","3b6c5be4":"#### <font color ='blue'>Testing Dataframe<\/font>","509cf7a3":"### Crew\n#### <font color = 'blue'> Training Dataframe<\/font>","c5015cad":"### Keywords\n#### <font color = 'blue'>Training Dataframe<\/font>","ef4ae185":"## Predictions\n### <font color = 'green'>Linear Regression<\/font>\nWith the R value for budget and revenue being pretty high at  0.75 we want to find a model that produces better results than relying on a linear regression model. ","5911e4f4":"### Belongs to Collection\n#### <font color = 'blue'>Training Dataframe<\/font>","60f07489":"### Cast\n#### <font color = 'blue'>Training Dataframe<\/font>","3f79ace6":"### <font color = 'blue'>Runtime<\/font>","353ae5f8":"#### <font color = 'blue'>Testing Dataframe<\/font>","0fdc74a1":"### <font color = 'blue'>Testing Dataframe <\/font>","1f79f66b":"---","e1494bc6":"## Analysis","204fe32e":"---","9f3218bc":"## Manipulating Data","4b334f4a":"## Import Libraries","8b0ff248":" ### <font color = 'blue'>Budget<\/font>","17de3ac4":"### Month \/ DOW\n#### <font color = 'blue'> Training Dataframe<\/font>","9032e6bd":"### Production Company\n#### <font color = 'blue'>Training Dataframe<\/font>","293c2420":"### Genres\n#### <font color = 'blue'>Training Dataframe<\/font>"}}