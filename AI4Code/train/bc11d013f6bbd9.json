{"cell_type":{"40f48486":"code","a6d9ad83":"code","6d837634":"code","19500a2c":"code","9eedc5b8":"code","29d95480":"code","9f597a62":"code","3e643181":"code","9c9c3bb5":"code","a694bcad":"code","43c6183b":"code","5109209f":"code","f719d692":"code","cc1c21eb":"code","ba7dbb21":"code","9c3facc5":"code","08e41169":"code","0440fe17":"code","d0433624":"code","112939cf":"code","2ea87c98":"code","210c4ee6":"code","75e52bf3":"code","66ba0540":"markdown","8f509a82":"markdown","8d582511":"markdown","47c761f5":"markdown","6b1bc8ce":"markdown","49d73451":"markdown","25789405":"markdown","c5f3a011":"markdown","7955195d":"markdown","1f0431d7":"markdown","f8402c90":"markdown","c5998e6d":"markdown","93b35a18":"markdown","2eaadce7":"markdown","d0ac9baa":"markdown","3f6211cc":"markdown","cd692922":"markdown","f4b8c15e":"markdown","4af739a3":"markdown","bf1a4824":"markdown"},"source":{"40f48486":"import numpy as np\nimport matplotlib.pyplot as plt\nimport torch\nimport opt_einsum as oe\nfrom torch.utils.checkpoint import checkpoint","a6d9ad83":"class EigenSolver(torch.autograd.Function):\n    @staticmethod\n    def forward(self, A):\n        w, v = torch.symeig(A, eigenvectors=True)\n\n        self.save_for_backward(w, v)\n        return w, v\n\n    @staticmethod\n    def backward(self, dw, dv):\n        w, v = self.saved_tensors\n        dtype, device = w.dtype, w.device\n        N = v.shape[0]\n\n        F = w - w[:,None]\n        F.diagonal().fill_(np.inf)\n        # safe inverse\n        msk = (torch.abs(F) < 1e-12)\n        F[msk] += 1e-12\n        F = 1.\/F  \n\n        vt = v.t()\n        vdv = vt@dv\n\n        return v@(torch.diag(dw) + F*(vdv-vdv.t())\/2) @vt\n\nsymeig = EigenSolver.apply","6d837634":"# -*- coding=utf-8 -*-\n\ndef model_contract(beta, h):\n    W = torch.stack([torch.cat([torch.sqrt(torch.cosh(beta)),  torch.sqrt(torch.sinh(beta))]),\n                     torch.cat([torch.sqrt(torch.cosh(beta)), -torch.sqrt(torch.sinh(beta))])\n                     ])\n    \n    M = torch.cat([torch.exp(beta*h), torch.exp(-beta*h)])\n\n    T = oe.contract('ai,aj,ak,al,am,an,a->ijklmn', W, W, W, W, W, W, M)\n    return T\n\ndef impurity_model_contract(beta, h, type='M'):\n    W = torch.stack([torch.cat([torch.sqrt(torch.cosh(beta)),  torch.sqrt(torch.sinh(beta))]),\n                     torch.cat([torch.sqrt(torch.cosh(beta)), -torch.sqrt(torch.sinh(beta))])\n                     ])\n    \n    M = torch.cat([torch.exp(beta*h), torch.exp(-beta*h)])\n\n    if(type=='M'):\n        m = torch.Tensor([1.0, -1.0])\n        T = oe.contract('ai,aj,ak,al,am,an,a,a->ijklmn', W, W, W, W, W, W, M, m)\n    elif(type=='U'):\n        W0 = torch.stack([torch.cat([-torch.exp(beta+beta*h\/3),  torch.exp(-beta)]),\n                     torch.cat([torch.exp(-beta), -torch.exp(beta-beta*h\/3)])])\n        W  = torch.stack([torch.cat([torch.exp(beta+beta*h\/3),  torch.exp(-beta)]),\n                     torch.cat([torch.exp(-beta), torch.exp(beta-beta*h\/3)])])\n        \n        u,s,v = torch.svd(W)\n        \n        L = u*torch.sqrt(s)\n        R = v*torch.sqrt(s)\n        \n        im_bond = W0@u\/torch.sqrt(s)\n\n        \n        T = oe.contract('ai,aj,ak,al,am,an->ijklmn', L, L, L, im_bond, R, R) + \\\n            oe.contract('ai,aj,ak,al,am,an->ijklmn', L, L, L, R, im_bond, R) + \\\n            oe.contract('ai,aj,ak,al,am,an->ijklmn', L, L, L, R, R, im_bond)\n\n    return T\n\n\ndef getU(MMdagger, Dcut, Di_2):\n\n    cut = min(Di_2, Dcut)\n    \n    MMdagger = MMdagger + MMdagger.t()\n    \n    lam, U = symeig(-MMdagger)\n\n    with torch.no_grad():\n        U = U[:, :cut]\n        loss = torch.norm(lam[cut:])\n\n    return U, loss\n\ndef update_Tk(Tk1,Tk2,Dcut,needs_u=False):\n    Dx1 = Tk1.shape[0]\n    Dy1 = Tk1.shape[1]\n    \n    Dx2 = Tk2.shape[0]\n    Dy2 = Tk2.shape[1]\n\n    # ******----x direction----*******\n    MMdagger = oe.contract(\n        'abcdef,xyflij,mbcdeg,nyglij->axmn',\n        Tk1, Tk2, Tk1, Tk2\n    ).reshape(Dx1*Dx2, -1)\n\n    U1x, loss1 = getU(MMdagger, Dcut, Dx1*Dx2)\n\n    MMdagger = oe.contract(\n        'abcdef,xyflij,abcmeg,xygnij->dlmn',\n        Tk1, Tk2, Tk1, Tk2\n    ).reshape(Dx1*Dx2, -1)\n    U2x, loss2 = getU(MMdagger, Dcut, Dx1*Dx2)\n\n    if (loss1 < loss2):\n        Ux = U1x.reshape(Dx1, Dx2, -1)\n    else:\n        Ux = U2x.reshape(Dx1, Dx2, -1)\n\n    # ******----y direction----*******\n    MMdagger = oe.contract(\n        'abcdef,xyflij,amcdeg,xnglij->bymn',\n        Tk1, Tk2, Tk1, Tk2\n    ).reshape(Dy1*Dy2, -1)\n    U1y, loss1 = getU(MMdagger, Dcut, Dy1*Dy2)\n\n    MMdagger = oe.contract(\n        'abcdef,xyflij,abcdmg,xyglnj->eimn',\n        Tk1, Tk2, Tk1, Tk2\n    ).reshape(Dy1*Dy2, -1)\n    U2y, loss2 = getU(MMdagger, Dcut, Dy1*Dy2)\n\n\n    if (loss1 < loss2):\n        Uy = U1y.reshape(Dy1, Dy2, -1)\n    else:\n        Uy = U2y.reshape(Dy1, Dy2, -1)\n\n    Tk = oe.contract(\n        'xyzabc,ijcopq,xim,aon,bpf,yjg->gzmfqn',\n        Tk1, Tk2, Ux, Ux, Uy, Uy\n    )  # mgz nfq-> gzm fqn\n    \n    if(needs_u):\n        return Tk,Ux,Uy\n    else:\n        return Tk\ndef calculate_partition_function(beta, h, Dcut, num, check_point):\n    lnZ = 0\n    \n    Tk = model_contract(beta, h)\n    \n    for i in range(num):\n        Ck = torch.norm(Tk)\n        Tk = Tk\/Ck\n        \n        lnZ += torch.log(Ck)\/2**i\n        \n        if(check_point):\n            Tk = checkpoint(update_Tk,Tk,Tk,torch.IntTensor([Dcut]))\n        else:\n            Tk = update_Tk(Tk,Tk,Dcut)\n\n    tr = oe.contract('xyzxyz->',Tk)\n    lnZ+=tr\/2**num\n\n\n    return lnZ","19500a2c":"def plot_M(T,M,Dcut):\n    plt.title(\"$3DIsing - Magnetization - (D_{cut}=%s,k=\\mu=1)$\"%Dcut)\n    plt.xlabel(\"$Temperature$\")\n    plt.ylabel(\"$Magnetization$\")\n    plt.plot(T, M, marker='o',markerfacecolor='none')\n    plt.show()\n    plt.savefig('3DIsing_Magnetization_D%d.svg'%Dcut,format='svg')\n    \ndef plot_U(T,U,Dcut):\n    plt.title(\"$3DIsing - Internal Energy - (D_{cut}=%s,k=\\mu=1)$\"%Dcut)\n    plt.xlabel(\"$Temperature$\")\n    plt.ylabel(\"$Internal Energy$\")\n    plt.plot(T_list, U, marker='o',markerfacecolor='none')\n    plt.show()\n    plt.savefig('3DIsing_internalEnergy_D%d.png'%Dcut,format='svg')","9eedc5b8":"def compare(T,*args):\n    base = np.array(args[0])\n    index = 1\n    for arg in args[1:]:\n        arg = np.array(arg)\n        plt.plot(T,np.abs((arg-base)\/base),label=\"index:%d\"%index)\n        index+=1\n        \n\n    plt.yscale(\"log\")\n    plt.ylabel(\"relative err\")\n    plt.xlabel(\"T\")\n    plt.legend()\n    plt.show()","29d95480":"torch.backends.cudnn.benchmark = True\n\nif(torch.cuda.is_available()):\n    torch.set_default_tensor_type(torch.cuda.DoubleTensor)\nelse:\n    torch.set_default_tensor_type(torch.DoubleTensor)","9f597a62":"num = 30\n\nT_list = torch.linspace(4.5,4.55,51,device='cpu')","3e643181":"import numpy as np\ndef calculate_quantities(T_list,Dcut,num=60,dx=1e-7,save_data = True,mode='ND',check_point=False,h=1e-6):\n    M = []\n    U = []\n    for T in T_list:\n        torch.cuda.empty_cache()\n\n        beta = 1\/T\n        \n        if(mode=='ND'):\n            # U\n            partion_func_U_0 = calculate_partition_function(torch.Tensor([beta-dx]), 0, Dcut, num, check_point)\n            partion_func_U_1 = calculate_partition_function(torch.Tensor([beta+dx]), 0, Dcut, num, check_point)\n            U.append(\n                float(-(partion_func_U_1-partion_func_U_0)\/(2*dx))\n            )\n\n            # M\n            partion_func_M_0 = calculate_partition_function(torch.Tensor([beta]), 0, Dcut, num, check_point)\n            partion_func_M_1 = calculate_partition_function(torch.Tensor([beta]), dx, Dcut, num, check_point)\n            M.append(\n                float((partion_func_M_1-partion_func_M_0)\/(dx)*T)\n            )\n        else:\n            beta = torch.Tensor([beta]).requires_grad_()\n            h = torch.Tensor([h]).requires_grad_()\n            \n            part_func = calculate_partition_function(beta, h, Dcut, num, check_point) \n            part_func.backward()\n            U.append(float(-beta.grad))\n            M.append(float(h.grad*T))\n\n        \n        print(\"T = %f, U = %f, M = %.10f\"%(float(T),float(U[-1]),float(M[-1])))\n        \n    \n    if(save_data):\n        np.savez('3D_ising_quantities_D_%d.npz'%Dcut,T=T_list,U=U,M=M)\n    \n    return U,M","9c9c3bb5":"def calculate_quantities_phy(T_list, h, Dcut, err=1e-3,min_loop_times = 50, max_loop_times = 1000):\n    \n    M = []\n    U = []\n    \n    \n    for T in T_list:\n        \n        \n        torch.cuda.empty_cache()\n\n        cnt = 0\n        beta = 1\/T\n        beta = torch.Tensor([beta])\n        h = torch.Tensor([0])\n        \n\n        Tk = model_contract(beta, h)\n        Tk_m = impurity_model_contract(beta, h, type='M')\n        Tk_u = impurity_model_contract(beta, h, type='U')\n\n        m = 0;last_m = 0\n        u = 0;last_u = 0\n        eps_1 = 1;eps_2 = 1\n\n        while(cnt < min_loop_times or (max(eps_1,eps_2) > err and cnt < max_loop_times)):\n\n            Ck = torch.norm(Tk)\n\n            Tk = Tk\/Ck\n            Tk_m = Tk_m\/Ck\n            Tk_u = Tk_u\/Ck\n\n            Tk_t = Tk.clone()\n\n            Tk,Ux,Uy = update_Tk(Tk,Tk,Dcut,needs_u=True)\n            \n            Tk_m_1 = oe.contract('xyzabc,ijcopq,xim,aon,bpf,yjg->gzmfqn',Tk_m, Tk_t, Ux, Ux, Uy, Uy)\n            Tk_m_2 = oe.contract('xyzabc,ijcopq,xim,aon,bpf,yjg->gzmfqn',Tk_t, Tk_m, Ux, Ux, Uy, Uy)\n            Tk_m   = (Tk_m_1 + Tk_m_2)\/2\n\n            Tk_u_1 = oe.contract('xyzabc,ijcopq,xim,aon,bpf,yjg->gzmfqn',Tk_u, Tk_t, Ux, Ux, Uy, Uy)\n            Tk_u_2 = oe.contract('xyzabc,ijcopq,xim,aon,bpf,yjg->gzmfqn',Tk_t, Tk_u, Ux, Ux, Uy, Uy)\n            Tk_u   = (Tk_u_1 + Tk_u_2)\/2\n\n            tr_p  = oe.contract('xyzxyz->',Tk)\n            tr_ip_m = oe.contract('xyzxyz->',Tk_m)\n            tr_ip_u = oe.contract('xyzxyz->',Tk_u)\n\n            last_m = m\n            m = tr_ip_m\/tr_p\n            eps_1 = torch.abs(last_m - m)\n\n            last_u = u\n            u = tr_ip_u\/tr_p\n            eps_2 = torch.abs(last_u - u)\n\n            cnt+=1\n            \n\n        U.append(float(u))\n        M.append(float(abs(m)))\n        print(\"T = %f, U = %f, M = %.10f\"%(float(T),float(U[-1]),float(M[-1])))\n\n    return U,M\n","a694bcad":"U_6,M_6 = calculate_quantities(T_list,6,num=30,save_data = True,mode='ND',check_point=False,dx=1e-6)\n\nplot_U(T_list,U_6,6)\nplot_M(T_list,M_6,6)","43c6183b":"U_6_AD,M_6_AD = calculate_quantities(T_list,6,num=30,save_data = True,mode='AD',check_point=False,h=1e-6)\n\nplot_U(T_list,U_6_AD,6)\nplot_M(T_list,M_6_AD,6)","5109209f":"U_6_phy,M_6_phy=calculate_quantities_phy(T_list, 0, 6, err=1e-4)\nplot_U(T_list,U_6_phy,6)\nplot_M(T_list,M_6_phy,6)","f719d692":"compare(T_list,M_6_phy,M_6,M_6_AD)\ncompare(T_list,U_6_phy,U_6,U_6_AD)","cc1c21eb":"U_7_AD,M_7_AD = calculate_quantities(T_list,10,num,save_data = True,mode='AD',check_point=True,h=1e-7)\n\nplot_U(T_list,U_7_AD,7)\nplot_M(T_list,M_7_AD,7)","ba7dbb21":"U_7,M_7 = calculate_quantities(T_list,10,num,save_data = True,mode='ND',check_point=False,dx=1e-4)\n\nplot_U(T_list,U_7,7)\nplot_M(T_list,M_7,7)","9c3facc5":"U_7_phy,M_7_phy=calculate_quantities_phy(T_list, 0, 10, err=1e-4)\nplot_U(T_list,U_7_phy,7)\nplot_M(T_list,M_7_phy,7)","08e41169":"compare(T_list,U_7_phy,U_7_AD)","0440fe17":"U_8,M_8 = calculate_quantities(T_list,8,num,save_data = True,mode='AD',check_point=False,h=1e-7)\n\nplot_U(T_list,U_8,8)\nplot_M(T_list,M_8,8)","d0433624":"U_9,M_9 = calculate_quantities(T_list,9,num,save_data = True,mode='AD',check_point=True)\n\nplot_U(T_list,U_9,9)\nplot_M(T_list,M_9,9)","112939cf":"U_10,M_10 = calculate_quantities(T_list,10,num,save_data = True,mode='AD',check_point=True)\n\nplot_U(T_list,U_10,10)\nplot_M(T_list,M_10,10)","2ea87c98":"U_11,M_11 = calculate_quantities(T_list,11,num,save_data = True,mode='AD',check_point=True)\n\nplot_U(T_list,U_11,11)\nplot_M(T_list,M_11,11)","210c4ee6":"T_list = torch.linspace(4.500,4.508,9,device='cpu')\n\ntorch.set_default_tensor_type(torch.cuda.FloatTensor)\n\nU_12,M_12 = calculate_quantities(T_list,12,num=30,save_data = True,mode='AD',check_point=True, h=1e-10)\n\nplot_U(T_list,U_12,12)\nplot_M(T_list,M_12,12)","75e52bf3":"D = [6,7,8,9,10,11,12]\nTc = [4.543,4.526,4.517,4.508,4.502,4.507,4.508]\n\nplt.figure()\nplt.ylabel('$T_c$',fontsize=16)\nplt.xlabel('$D$',fontsize=16)\n\nplt.plot(D,Tc,label='from M',marker='o',markersize=8)\n\nfor a, b in zip(D, Tc):\n    plt.text(a, b, b, ha='center', va='bottom', fontsize=14)\n    \nplt.legend()\nplt.show()\nplt.savefig('D-Tc.svg',format='svg')\n\n","66ba0540":"## \u6570\u636e\u8f93\u51fa","8f509a82":"\u4e34\u754c\u70b9\uff1a\n+ 4.517 (from M)\n+ 4.517 (from U)","8d582511":"\u4e34\u754c\u70b9\uff1a\n+ 4.507 (from M)\n+ 4.507 (from U)","47c761f5":"\u4e34\u754c\u70b9\uff1a\n+ 4.508 (from M)\n+ 4.508 (from U)","6b1bc8ce":"### 3.4 $D=9$","49d73451":"\u4e34\u754c\u70b9\uff1a\n+ 4.502 (from M)\n+ 4.502 (from U)","25789405":"### 3.3 $D=8$","c5f3a011":"## 4 \u7269\u7406\u91cf\u7684\u8ba1\u7b97","7955195d":"### 3.1 $D=6$","1f0431d7":"\u4e34\u754c\u70b9\uff1a\n+ 4.508 (from M)\n+ 4.508 (from U)","f8402c90":"## 2 Utils","c5998e6d":"\u4e34\u754c\u70b9\uff1a\n+ 4.543 (from M)\n+ 4.543 (from U)","93b35a18":"## 3 \u5168\u5c40\u53c2\u6570\u8bbe\u7f6e","2eaadce7":"### 3.7 $D=12$","d0ac9baa":"## 4 \u4e34\u754c\u6e29\u5ea6$T_c$\u4e0e$D$\u7684\u5173\u7cfb","3f6211cc":"\u4e34\u754c\u70b9\uff1a\n+ 4.526 (from M)\n+ 4.526 (from U)","cd692922":"### 3.6 $D=11$","f4b8c15e":"### 3.2 $D=7$","4af739a3":"### 3.5 $D=10$","bf1a4824":"# 3DIsing-\u6570\u503c\u5bfc\u6570\u8ba1\u7b97\u7269\u7406\u91cf\n## 1 HOTRG\u4e3b\u7a0b\u5e8f"}}