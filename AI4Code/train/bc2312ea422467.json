{"cell_type":{"e581853e":"code","3aa19680":"code","876996ed":"code","8fc1e620":"code","9e86b326":"code","307e50af":"code","6f46ed41":"code","90ecd221":"code","b88b3fcb":"code","7302dc0e":"code","2078e250":"code","dc56502b":"code","e4310f63":"code","240b52ed":"code","6f06ecc5":"code","bd622f66":"code","b1622029":"code","12d83f77":"code","021ff0bd":"code","f1b400c8":"markdown","848ba1b3":"markdown","0df4c36d":"markdown","d7d0d4c0":"markdown","0b85777e":"markdown","96441f4b":"markdown","b5693961":"markdown","c34c30e2":"markdown","f3f7c33c":"markdown","1515291c":"markdown","51b9f081":"markdown","4eb15b96":"markdown","f944cfa0":"markdown","65c51d1c":"markdown","b50808c6":"markdown","3ffadcb8":"markdown","9e6cc218":"markdown"},"source":{"e581853e":"import pandas as pd","3aa19680":"df_dados = pd.read_csv('..\/input\/lab8_neuro.txt', header=None, sep=' ' ) # nosso dado n\u00e3o possui cabe\u00e7alho.","876996ed":"df_dados.head()","8fc1e620":"df_dados.tail()","9e86b326":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nimport numpy as np\n\n# Essa fun\u00e7\u00e3o apenas prepara a exibi\u00e7\u00e3o de nossos gr\u00e1ficos\ndef preparePlot(xticks, yticks, figsize=(10.5, 6), hideLabels=False, gridColor='#999999',\n                gridWidth=1.0):\n\n    plt.close()\n    fig, ax = plt.subplots(figsize=figsize, facecolor='white', edgecolor='white')\n    ax.axes.tick_params(labelcolor='#999999', labelsize='10')\n    for axis, ticks in [(ax.get_xaxis(), xticks), (ax.get_yaxis(), yticks)]:\n        axis.set_ticks_position('none')\n        axis.set_ticks(ticks)\n        axis.label.set_color('#999999')\n        if hideLabels: axis.set_ticklabels([])\n    plt.grid(color=gridColor, linewidth=gridWidth, linestyle='-')\n    map(lambda position: ax.spines[position].set_visible(False), ['bottom', 'top', 'left', 'right'])\n    return fig, ax","307e50af":"# recuperamos a coluna de indice 2, que contem os dados em t0 e depois \n# redimensionamos para o formato original da imagem 230 x 202\nimagem_t0 = df_dados[2].values.reshape(230,202).T\n\n# generate layout and plot data\nfig, ax = preparePlot(np.arange(0, 10, 1), np.arange(0, 10, 1), figsize=(9.0, 7.2), hideLabels=True)\nax.grid(False)\nax.set_title('Imagem em t=0', color='#888888')\nimage = plt.imshow(imagem_t0,interpolation='nearest', aspect='auto', cmap=cm.gray)\npass","6f46ed41":"#calculamos o desvio padr\u00e3o da luminosidade em cada linha (axis=1).\nstd_por_pixel = np.std(df_dados.values[:,2:], axis=1) \n#aqui selecionamos os pontos cujo desvio padr\u00e3o \u00e9 maior que 100. a Vari\u00e1vel guarda os indices.\npontos_alto_std = np.where(std_por_pixel>100)[0]","90ecd221":"pixel_escolhido =  df_dados.iloc[np.random.choice(pontos_alto_std)][2:].values","b88b3fcb":"# generate layout and plot data\nfig, ax = preparePlot(np.arange(0, 300, 50), np.arange(300, 800, 100))\nax.set_xlabel(r'tempo'), ax.set_ylabel(r'luminosidade')\nax.set_xlim(-20, 270), ax.set_ylim(270, 900)\nplt.plot(range(len(pixel_escolhido)), pixel_escolhido, c='#8cbfd0', linewidth='3.0')\npass","7302dc0e":"dados = df_dados.values[:,2:]\nprint(dados)\nprint(dados.shape)","2078e250":"#calculamos a m\u00e9dia da luminosidade em cada linha (axis=1).\nmedia_por_pixel = np.mean(dados, axis=1) \n\n#Agora ajustamos os dados\ndados_reescalonados = ((dados.T - media_por_pixel)\/media_por_pixel).T","dc56502b":"pixel_escolhido =  dados_reescalonados[np.random.choice(pontos_alto_std)]","e4310f63":"# generate layout and plot data\nfig, ax = preparePlot(np.arange(0, 300, 50), np.arange(-.1, .6, .1))\nax.set_xlabel(r'tempo'), ax.set_ylabel(r'luminosidade')\nax.set_xlim(-20, 260), ax.set_ylim(-.30, .80)\nplt.plot(range(len(pixel_escolhido)), pixel_escolhido, c='#8cbfd0', linewidth='3.0')","240b52ed":"from sklearn.decomposition import PCA\npca = PCA(n_components=3)\ncomponentes = pca.fit(dados_reescalonados).transform(dados_reescalonados)","6f06ecc5":"print(pca.explained_variance_ratio_) ","bd622f66":"primeiro_componente = componentes[:,0].reshape(230,202).T\n\n# generate layout and plot data\nfig, ax = preparePlot(np.arange(0, 10, 1), np.arange(0, 10, 1), figsize=(9.0, 7.2), hideLabels=True)\nax.grid(False)\nax.set_title('Primeiro componente principal', color='#888888')\nimage = plt.imshow(primeiro_componente,interpolation='nearest', aspect='auto', cmap=cm.gray)","b1622029":"segundo_componente = componentes[:,1].reshape(230,202).T\n\n# generate layout and plot data\nfig, ax = preparePlot(np.arange(0, 10, 1), np.arange(0, 10, 1), figsize=(9.0, 7.2), hideLabels=True)\nax.grid(False)\nax.set_title('Segundo componente principal', color='#888888')\nimage = plt.imshow(segundo_componente,interpolation='nearest', aspect='auto', cmap=cm.gray)\npass","12d83f77":"def polarTransform(scale, img):\n    \"\"\"Convert points from cartesian to polar coordinates and map to colors.\"\"\"\n    from matplotlib.colors import hsv_to_rgb\n\n    img = np.asarray(img)\n    dims = img.shape\n\n    phi = ((np.arctan2(-img[0], -img[1]) + np.pi\/2) % (np.pi*2)) \/ (2 * np.pi)\n    rho = np.sqrt(img[0]**2 + img[1]**2)\n    saturation = np.ones((dims[1], dims[2]))\n\n    out = hsv_to_rgb(np.dstack((phi, saturation, scale * rho)))\n\n    return np.clip(out * scale, 0, 1)\n\n# Show the polar mapping from principal component coordinates to colors.\nx1AbsMax = np.max(np.abs(primeiro_componente))\nx2AbsMax = np.max(np.abs(segundo_componente))\n\nnumOfPixels = 300\nx1Vals = np.arange(-x1AbsMax, x1AbsMax, (2 * x1AbsMax) \/ numOfPixels)\nx2Vals = np.arange(x2AbsMax, -x2AbsMax, -(2 * x2AbsMax) \/ numOfPixels)\nx2Vals.shape = (numOfPixels, 1)\n\nx1Data = np.tile(x1Vals, (numOfPixels, 1))\nx2Data = np.tile(x2Vals, (1, numOfPixels))\n\n# Try changing the first parameter to lower values\npolarMap = polarTransform(2.0, [x1Data, x2Data])\n\ngridRange = np.arange(0, numOfPixels + 25, 25)\nfig, ax = preparePlot(gridRange, gridRange, figsize=(9.0, 7.2), hideLabels=True)\nimage = plt.imshow(polarMap, interpolation='nearest', aspect='auto')\nax.set_xlabel('Primeiro componente principal'), ax.set_ylabel('Segundo componente principal')\ngridMarks = (2 * gridRange \/ float(numOfPixels) - 1.0)\nx1Marks = x1AbsMax * gridMarks\nx2Marks = -x2AbsMax * gridMarks\nax.get_xaxis().set_ticklabels(map(lambda x: '{0:.1f}'.format(x), x1Marks))\nax.get_yaxis().set_ticklabels(map(lambda x: '{0:.1f}'.format(x), x2Marks))","021ff0bd":"brainmap = polarTransform(2.0, [primeiro_componente, segundo_componente])\n\n# generate layout and plot data\nfig, ax = preparePlot(np.arange(0, 10, 1), np.arange(0, 10, 1), figsize=(9.0, 7.2), hideLabels=True)\nax.grid(False)\nimage = plt.imshow(brainmap,interpolation='nearest', aspect='auto')\npass","f1b400c8":"### Reescalonando os dados","848ba1b3":"Note que cada linha possui nas duas primeiras colunas (\u00edndice 0 e 1 do dataframe) as coordenadas na imagem. Por exemplo, a primeira linha refere-se \u00e0s intensidades de luz nas coordenadas 0,0 da imagem. A \u00faltima linha, das coordenadas 202,230 (come\u00e7a em zero) da imagem. Ou seja, temo suma imagem de 202x230 pixels. Na verdade 230 x 202 (ela est\u00e1 transposta).\n\nAs outras colunas s\u00e3o a medida de luminosidade naquele ponto do tempo. Coluna 2 \u00e9 o t0, coluna 3 o t1 e assim por diante. Nesse caso, temos 240 medidas de luminosidade do zebrafish.","0df4c36d":"Nesse laborat\u00f3rio, analisaremos dados de atividade cerebral de um [zebrafish](http:\/\/en.wikipedia.org\/wiki\/Zebrafish), que \u00e9 um animal interessante para se estudar, pois ele \u00e9 transparente e \u00e9 poss\u00edvel capturar sua atividade cerebral pela t\u00e9cnica de [light-sheet microscopy](http:\/\/en.wikipedia.org\/wiki\/Light_sheet_fluorescence_microscopy). \n\nOs dados que analisaremos s\u00e3o o registro da varia\u00e7\u00e3o da atividade cerebral do zebrafish ao longo do tempo, pixel por pixel.\n\nA ideia desse laborat\u00f3rio foi tirada do curso de [Spark da EDX](https:\/\/www.edx.org\/course\/distributed-machine-learning-apache-uc-berkeleyx-cs120x).","d7d0d4c0":"Agora imprimimos o segundo componente","0b85777e":"Veja que para valores altos de ambos componentes teremos a cor rosa. Para valores altos do componente 1 e baixos do 2, amarelo e valores baixos do 1 azul.\nAgora combinamos essas varia\u00e7\u00f5es numa nova imagem.","96441f4b":"### Carregando os dados","b5693961":"Aqui podemos ver o percentual de varia\u00e7\u00e3o dos dados \u00e9 explicado por cada componente principal dos 3 que escolhemos","c34c30e2":"Agora vamos imprimir o primeiro componente principal","f3f7c33c":"Agora que temos nossos dados prontos, vamos utilizar o PCA para transformar nossa s\u00e9rie temporal de 240 medidas em 3 imagens que explicam a maior parte da varia\u00e7\u00e3o de luminosidade da imagem durante todo o experimento. Com isso poderemos identificar na imagem, quais \u00e1reas do c\u00e9rebro do zebrafish foram mais ativadas durante todo o processo.","1515291c":"# Laborat\u00f3rio 8 - Redu\u00e7\u00e3o de dimensionalidade com PCA","51b9f081":"Primeiro vamos retirar s\u00f3 os dados do dataframe.","4eb15b96":"Por fim, vamos combinar as duas imagens criando um mapa de cor. N\u00e3o se preocupe em entender o c\u00f3digo. Focar na imagem gerada","f944cfa0":"Para trabalhar com o PCA, vamos primeiro reescalonar nossos dados em torno da m\u00e9dia de cada pixel. Vamos subtrair e depois dividir cada uma das linhas (luminosidades medidas em cada pixel), pela m\u00e9dia dos valores nessa linha.","65c51d1c":"### Visualizando os dados","b50808c6":"### Aplicando o PCA","3ffadcb8":"A nossa primeira visualiza\u00e7\u00e3o ser\u00e1 imprimir a imagem no instante t0, ou seja, as luminosidades registradas na coluna 2 dos dados. Novamente, n\u00e3o se preocupe em entender o c\u00f3digo do matplotlib.","9e6cc218":"No c\u00f3digo abaixo, podemos visualizar a varia\u00e7\u00e3o da luminosidade de um determinado pixel qualquer que tenha varia\u00e7\u00e3o alta. Vamos escolher um pixel que tenha uma boa varia\u00e7\u00e3o (as bordas provavelmente n\u00e3o variam muito, pois n\u00e3o representam pontos onde o zebrafish estava."}}