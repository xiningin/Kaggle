{"cell_type":{"e7971495":"code","18b56589":"code","b47baadc":"code","bf907c9f":"code","b30a3ec9":"code","465b68e1":"code","0b809c3f":"code","207d9af8":"code","35fd3b81":"code","57c0ba5f":"code","abbc12ed":"code","75e09344":"code","501a4418":"code","bd51cbec":"code","8e7a7573":"code","4a4ad46e":"code","67fcda4a":"code","0592e333":"code","2b6b520a":"markdown","9829f478":"markdown","9d8578b5":"markdown","b64119a4":"markdown","34fe444d":"markdown","1aa3c9d1":"markdown","8809907a":"markdown"},"source":{"e7971495":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport shutil\nimport random\nimport torch\nimport torchvision\nfrom PIL import Image\nfrom matplotlib import pyplot as plt\n\ntorch.manual_seed(0)\n\nprint('Using PyTorch version', torch.__version__)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","18b56589":"class_names = ['normal', 'viral', 'covid']\nroot_dir = 'COVID-19 Radiography Database'\nsource_dirs = ['NORMAL', 'Viral Pneumonia', 'COVID-19']\n\nif os.path.isdir(os.path.join(root_dir, source_dirs[1])):\n    os.mkdir(os.path.join(root_dir, 'test'))\n    \n    for i, d in enumerate(source_dirs):\n        s.rename(os.path.join(root_dir, d), os.path.join(root_dir, class_names[i]))\n     \n    for c in class_names:\n        os.mkdir(os.path.join(root_dir, 'test', c))\n        \n    for c in class_names:\n        images = [x for x in os.listdir(os.path.join(root_dir, c)) if x.lower().endswith('png')]\n        selected_images = random.sample(images, 30)\n        for image in selected_images:\n            source_path = os.path.join(root_dir,c, image)\n            target_path = os.path.join(root_dir, 'test', c, image)\n            shutil.move(source_path, target_path)","b47baadc":"class ChestXRayDataset(torch.utils.data.Dataset):\n    def __init__(self, image_dirs, transform):\n        def get_images(class_name):\n            images = [x for x in os.listdir(image_dirs[class_name]) if x.lower().endswith('png')]\n            print(f'Found {len(images)} {class_name} examples')\n            return images\n        \n        self.images = {}\n        self.class_names = ['normal', 'viral', 'covid']\n        \n        for c in self.class_names:\n            self.images[c] = get_images(c)\n            \n        self.image_dirs = image_dirs\n        self.transform = transform\n        \n    def __len__(self):\n        return sum([len(self.images[c]) for c in self.class_names])\n    \n    def __getitem__(self, index):\n        class_name = random.choice(self.class_names)\n        index = index % len(self.images[class_name])\n        image_name = self.images[class_name][index]\n        image_path = os.path.join(self.image_dirs[class_name], image_name)\n        image = Image.open(image_path).convert('RGB')\n        return self.transform(image), self.class_names.index(class_name)\n                                        ","bf907c9f":"train_transform = torchvision.transforms.Compose([\n    torchvision.transforms.Resize(size = (224,224)),\n    torchvision.transforms.RandomHorizontalFlip(),\n    torchvision.transforms.ToTensor(),\n    torchvision.transforms.Normalize(mean = [0.485, 0.456, 0.406],\n                                    std = [0.229, 0.224, 0.225])\n])","b30a3ec9":"test_transform = torchvision.transforms.Compose([\n    torchvision.transforms.Resize(size = (224,224)),\n    torchvision.transforms.ToTensor(),\n    torchvision.transforms.Normalize(mean = [0.485, 0.456, 0.406],\n                                    std = [0.229, 0.224, 0.225])\n])","465b68e1":"train_dirs = {\n    'normal': '..\/input\/covid19-radiography-database\/COVID-19 Radiography Database\/NORMAL',\n    'viral': '..\/input\/covid19-radiography-database\/COVID-19 Radiography Database\/Viral Pneumonia',\n    'covid': '..\/input\/covid19-radiography-database\/COVID-19 Radiography Database\/COVID-19'\n}\ntrain_dataset = ChestXRayDataset(train_dirs, train_transform)","0b809c3f":"test_dirs = {\n    'normal': '..\/input\/test-set-for-covid19-chest-xray\/test\/normal',\n    'viral': '..\/input\/test-set-for-covid19-chest-xray\/test\/viral',\n    'covid': '..\/input\/test-set-for-covid19-chest-xray\/test\/covid'\n}\ntest_dataset = ChestXRayDataset(test_dirs, test_transform)","207d9af8":"batch_size = 6\n\ndl_train = torch.utils.data.DataLoader(train_dataset, batch_size = batch_size,\n                                      shuffle = True) #Shuffles the indices\ndl_test = torch.utils.data.DataLoader(test_dataset, batch_size = batch_size,\n                                      shuffle = True)\n\nprint(\"Number of training batches \", len(dl_train))\nprint(\"Number of test batches \", len(dl_test))\n\n# 37 test examples and 7 multiplied by batch_size 6 is 42","35fd3b81":"class_names = train_dataset.class_names\n\ndef show_images(images, labels, preds):\n    plt.figure(figsize=(8,4))\n    for i, image in enumerate(images):\n        plt.subplot(1,6,i+1, xticks=[], yticks=[])\n        image = image.numpy().transpose((1,2,0))\n        mean = np.array([0.485, 0.456, 0.406])\n        std = np.array([0.229, 0.224, 0.225])\n        image = image * std + mean\n        image = np.clip(image, 0., 1.)\n        plt.imshow(image)\n        \n        col = 'green' if preds[i] == labels[i] else 'red'\n        \n        plt.xlabel(f'{class_names[int(labels[i].numpy())]}')\n        plt.ylabel(f'{class_names[int(preds[i].numpy())]}', color=col)\n    plt.tight_layout()\n    plt.show()","57c0ba5f":"images, labels = next(iter(dl_train))\nshow_images(images, labels, labels)","abbc12ed":"images, labels = next(iter(dl_test))\nshow_images(images, labels, labels)","75e09344":"resnet18 = torchvision.models.resnet18(pretrained = True)\nprint(resnet18)","501a4418":"resnet18.fc = torch.nn.Linear(in_features=512, out_features=3)\nloss_fn = torch.nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(resnet18.parameters(), lr=3e-5)","bd51cbec":"def show_preds():\n    resnet18.eval()\n    images, labels = next(iter(dl_test))\n    outputs = resnet18(images)\n    _, preds = torch.max(outputs, 1)\n    show_images(images, labels, preds)","8e7a7573":"show_preds()","4a4ad46e":"def train(epochs):\n    print(\"Starting training...\")\n    for e in range(0, epochs):\n        print('='*20)\n        print(f'Starting epoch{e+1}\/{epochs}')\n        print('='*20)\n        \n        train_loss = 0\n        \n        resnet18.train()\n        \n        for train_step, (images, labels) in enumerate(dl_train):\n            optimizer.zero_grad()\n            outputs = resnet18(images)\n            loss = loss_fn(outputs, labels)\n            loss.backward()\n            optimizer.step()\n            train_loss += loss.item()\n            if train_step % 20 == 0:\n                print(\"Evaluating at step\", train_step)\n                acc = 0.    #accuracy\n                val_loss = 0.\n                resnet18.eval()\n                \n                for val_step, (images, labels) in enumerate(dl_test):\n                    outputs = resnet18(images)\n                    loss = loss_fn(outputs, labels)\n                    val_loss += loss.item()\n                    \n                    _,preds = torch.max(outputs, 1)\n                    acc += sum((preds == labels).numpy())\n                    \n                val_loss \/= (val_step + 1)\n                acc = acc\/len(test_dataset)\n                print(f'Val loss: {val_loss:.4f}, Acc: {acc:.4f}')\n                show_preds()\n                \n                resnet18.train()\n                \n                if acc > 0.95:\n                    print('Performance condition satified...')\n                    return \n            train_loss \/= (train_step + 1)\n            print(f'Training loss: {train_loss:.4f}')","67fcda4a":"train(epochs=1)","0592e333":"show_preds()","2b6b520a":"# Final Result","9829f478":"# Creating Custom Dataset","9d8578b5":"# Creating the Model ","b64119a4":"# Image Transformations","34fe444d":"# Training the Model","1aa3c9d1":"# Prepare DataLoader","8809907a":"# Data Visualizaion"}}