{"cell_type":{"63e0d833":"code","2fbc5621":"code","a9742873":"code","5322b5e2":"code","6821b15e":"code","b567775a":"code","41624ebd":"code","51732e35":"code","43555585":"code","addae9b8":"code","6b97bafd":"code","88473dc9":"code","622b2e89":"code","86c1105d":"code","d8745d24":"code","30570847":"code","4aa855fd":"code","6a3b7f77":"code","01f618e2":"code","1d131f8a":"code","0c7e5dba":"code","a0972ae8":"code","24a8f780":"code","7ad59c08":"code","62027e9f":"code","f2c2d1cd":"code","b0fe7aa4":"code","aa7bfa8e":"code","2fe69f66":"code","6ac89430":"code","529742d3":"code","4ca03bc3":"code","9d2ddcf7":"code","fbf3a97c":"code","88664ab0":"markdown","6a2983d9":"markdown","89c7dd56":"markdown","f5131cde":"markdown","52e220ba":"markdown","03ba1ec5":"markdown","bb737e3a":"markdown","155dc44b":"markdown","1f6e2fe0":"markdown","43979ac5":"markdown","6f4d8cf3":"markdown","d97b3321":"markdown","ea3cce51":"markdown","48dc746b":"markdown","58d7d5eb":"markdown","ed310391":"markdown","e80f5d05":"markdown","8b5c3d69":"markdown","50f7ec0e":"markdown"},"source":{"63e0d833":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport pyarrow.parquet as pq\nimport matplotlib.pyplot as plt\nfrom scipy import signal\n\nsns.set_style(\"whitegrid\")","2fbc5621":"import warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)","a9742873":"signals = pq.read_table('..\/input\/train.parquet', columns=[str(i) for i in range(999)]).to_pandas()\nsignals = signals.values.T.reshape((999\/\/3, 3, 800000))","5322b5e2":"train_df = pd.read_csv('..\/input\/metadata_train.csv')\ntrain_df.head()","6821b15e":"target = train_df['target'][::3]\ntarget.value_counts()","b567775a":"def apply_convolution(sig, window):\n    \"\"\"Apply a simple same-size convolution with a given window size\"\"\"\n    conv = np.repeat([0., 1., 0.], window)\n    filtered = signal.convolve(sig, conv, mode='same') \/ window\n    return filtered","41624ebd":"plt.figure(figsize=(15, 10))\nwindow = 10\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    convolved = apply_convolution(sig, window)\n    plt.plot(convolved, label=f'Phase {phase} Convolved')\n\nplt.legend()\nplt.title(f\"Applying convolutions - Window Size {window}\", size=15)\nplt.show()","51732e35":"plt.figure(figsize=(15, 10))\nwindow = 100\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    convolved = apply_convolution(sig, window)\n    plt.plot(convolved, label=f'Phase {phase} Convolved')\n\nplt.legend()\nplt.title(f\"Applying convolutions - Window Size {window}\", size=15)\nplt.show()","43555585":"plt.figure(figsize=(15, 10))\nwindow = 1000\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    convolved = apply_convolution(sig, window)\n    plt.plot(convolved, label=f'Phase {phase} Convolved')\n\nplt.legend()\nplt.title(f\"Applying convolutions - Window Size {window}\", size=15)\nplt.show()","addae9b8":"plt.figure(figsize=(15, 10))\nwindow = 10\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    convolved = apply_convolution(sig, window)\n    plt.plot(convolved, label=f'Phase {phase} Convolved')\n\nplt.legend()\nplt.title(f\"Applying convolutions - Window Size {window}\", size=15)\nplt.show()","6b97bafd":"plt.figure(figsize=(15, 10))\nwindow = 100\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    convolved = apply_convolution(sig, window)\n    plt.plot(convolved, label=f'Phase {phase} Convolved')\n\nplt.legend()\nplt.title(f\"Applying convolutions - Window Size {window}\", size=15)\nplt.show()","88473dc9":"plt.figure(figsize=(15, 10))\nwindow = 1000\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    convolved = apply_convolution(sig, window)\n    plt.plot(convolved, label=f'Phase {phase} Convolved')\n\nplt.legend()\nplt.title(f\"Applying convolutions - Window Size {window}\", size=15)\nplt.show()","622b2e89":"%%time\nsmoothing = 0\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    filtered = signal.cspline1d(sig, smoothing)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Cubic Spline, Smoothing: {smoothing}\", size=15)\nplt.show()","86c1105d":"smoothing = 1\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    filtered = signal.cspline1d(sig, smoothing)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Cubic Spline, Smoothing: {smoothing}\", size=15)\nplt.show()","d8745d24":"smoothing = 10\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    filtered = signal.cspline1d(sig, smoothing)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Cubic Spline, Smoothing: {smoothing}\", size=15)\nplt.show()","30570847":"smoothing = 0\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    filtered = signal.cspline1d(sig, smoothing)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Cubic Spline, Smoothing: {smoothing}\", size=15)\nplt.show()","4aa855fd":"smoothing = 1\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    filtered = signal.cspline1d(sig, smoothing)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Cubic Spline, Smoothing: {smoothing}\", size=15)\nplt.show()","6a3b7f77":"smoothing = 10\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    filtered = signal.cspline1d(sig, smoothing)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Cubic Spline, Smoothing: {smoothing}\", size=15)\nplt.show()","01f618e2":"%%time\n# Start with negative target.\nsmoothing = 0\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    filtered = signal.qspline1d(sig, smoothing)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Quadratic Spline, Smoothing: {smoothing}\", size=15)\nplt.show()","1d131f8a":"smoothing = 0\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    filtered = signal.qspline1d(sig, smoothing)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Quadratic Spline, Smoothing: {smoothing}\", size=15)\nplt.show()","0c7e5dba":"%%time\nkernel_size = 1\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    filtered = signal.medfilt(sig, kernel_size)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Median Filters, Kernel Size: {kernel_size}\", size=15)\nplt.show()","a0972ae8":"kernel_size = 11\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    filtered = signal.medfilt(sig, kernel_size)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Median Filters, Kernel Size: {kernel_size}\", size=15)\nplt.show()","24a8f780":"kernel_size = 51\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    filtered = signal.medfilt(sig, kernel_size)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Median Filters, Kernel Size: {kernel_size}\", size=15)\nplt.show()","7ad59c08":"kernel_size = 101\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    filtered = signal.medfilt(sig, kernel_size)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Median Filters, Kernel Size: {kernel_size}\", size=15)\nplt.show()","62027e9f":"kernel_size = 1\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    filtered = signal.medfilt(sig, kernel_size)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Median Filters, Kernel Size: {kernel_size}\", size=15)\nplt.show()","f2c2d1cd":"kernel_size = 11\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    filtered = signal.medfilt(sig, kernel_size)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Median Filters, Kernel Size: {kernel_size}\", size=15)\nplt.show()","b0fe7aa4":"kernel_size = 51\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    filtered = signal.medfilt(sig, kernel_size)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Median Filters, Kernel Size: {kernel_size}\", size=15)\nplt.show()","aa7bfa8e":"kernel_size = 101\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    filtered = signal.medfilt(sig, kernel_size)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying Median Filters, Kernel Size: {kernel_size}\", size=15)\nplt.show()","2fe69f66":"%%time\nWn = 0.50\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    \n    b, a = signal.butter(3, Wn)\n    filtered = signal.filtfilt(b, a, sig)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying IIR Filtering with Butterworth, Wn: {Wn}\", size=15)\nplt.show()","6ac89430":"Wn = 0.05\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    \n    b, a = signal.butter(3, Wn)\n    filtered = signal.filtfilt(b, a, sig)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying IIR Filtering with Butterworth, Wn: {Wn}\", size=15)\nplt.show()","529742d3":"Wn = 0.01\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[0, phase, :]\n    \n    b, a = signal.butter(3, Wn)\n    filtered = signal.filtfilt(b, a, sig)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying IIR Filtering with Butterworth, Wn: {Wn}\", size=15)\nplt.show()","4ca03bc3":"%%time\nWn = 0.50\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    \n    b, a = signal.butter(3, Wn)\n    filtered = signal.filtfilt(b, a, sig)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying IIR Filtering with Butterworth, Wn: {Wn}\", size=15)\nplt.show()","9d2ddcf7":"Wn = 0.05\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    \n    b, a = signal.butter(3, Wn)\n    filtered = signal.filtfilt(b, a, sig)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying IIR Filtering with Butterworth, Wn: {Wn}\", size=15)\nplt.show()","fbf3a97c":"Wn = 0.01\nplt.figure(figsize=(15, 10))\n\nfor phase in range(3):\n    sig = signals[1, phase, :]\n    \n    b, a = signal.butter(3, Wn)\n    filtered = signal.filtfilt(b, a, sig)\n    \n    plt.plot(sig, label=f'Phase {phase} Raw')\n    plt.plot(filtered, label=f'Phase {phase} Filtered')\n\nplt.legend()\nplt.title(f\"Applying IIR Filtering with Butterworth, Wn: {Wn}\", size=15)\nplt.show()","88664ab0":"### Negative Target","6a2983d9":"### Positive Target","89c7dd56":"### Positive Example","f5131cde":"# Signal processing with Scipy\nBelow, we will explore different methods for processing and cleaning signal with Scipy. I haven't worked extensively with signal processing, so if there is any expert out there who would have insight or suggestion in improving this work, please let me know!\n\n## About Scipy\n> SciPy (pronounced \u201cSigh Pie\u201d) is open-source software for mathematics, science, and engineering.\n\n![scipy](https:\/\/docs.scipy.org\/doc\/scipy\/reference\/_static\/img\/scipy_org_logo.gif)\n\nScipy is an extremely useful library for scientific and numerical computing in Python. It contains very useful submodules for Optimization, Fast Fourier Transform, Linear Algebra, Matrix Encoding, and Image Processing. In fact, Scikit-learn uses it extensively for maniputating large sparse matrix, and for algorithms such as Ordinary Least Square!\n\nWe will focus on the `signal` processing submodule for this exploration notebook.\n\nThis is a work in progress, so please tune in for more updates!\n\n### References:\n* Loading data (signal and target): https:\/\/www.kaggle.com\/theoviel\/fast-fourier-transform-denoising\n* Read data: https:\/\/www.kaggle.com\/sohier\/reading-the-data-with-python\n\n### Recommendations:\nFFT Kernel (We won't cover this since the following notebook cover it extensively):\n* https:\/\/www.kaggle.com\/theoviel\/fast-fourier-transform-denoising\n\nOfficial Scipy Tutorial on Signal Processing:\n* https:\/\/docs.scipy.org\/doc\/scipy\/reference\/tutorial\/signal.html\n","52e220ba":"### Negative Target","03ba1ec5":"Now, let's see a positive target.","bb737e3a":"### Negative Example","155dc44b":"## 4. Median Filtering","1f6e2fe0":"# Importing and Preprocessing","43979ac5":"### Positive Target","6f4d8cf3":"### Positive Target","d97b3321":"## 2. C-Spline","ea3cce51":"Here, we take an example with negative target.","48dc746b":"### Negative Example","58d7d5eb":"### Negative Example","ed310391":"## 1. Applying Convolutions","e80f5d05":"## 3. Q-Spline\n\nScipy does not support smoothing Q-Spline yet, so we set it to be 0. ","8b5c3d69":"## 5. Digital Filters (IIR)\n\n#### Butter Filter Design\n\nThis is what we will be using:\n\n> Butterworth digital and analog filter design.\n> Design an Nth-order digital or analog Butterworth filter and return the filter coefficients.\n\nIn this case the Numerator (b) and denominator (a) polynomials of the IIR filter are returned. The following describes the Wn parameter:\n\n> A scalar or length-2 sequence giving the critical frequencies. For a Butterworth filter, this is the point at which the gain drops to 1\/sqrt(2) that of the passband (the \u201c-3 dB point\u201d).\n> For digital filters, Wn are in the same units as fs. By default, fs is 2 half-cycles\/sample, so these are normalized from 0 to 1, where 1 is the Nyquist frequency. (Wn is thus in half-cycles \/ sample.)\n> For analog filters, Wn is an angular frequency (e.g. rad\/s).\n\nIs Butterworth good for Time Series? Check out [this paper](https:\/\/amstat.tandfonline.com\/doi\/abs\/10.1198\/073500101681019909). Here's the abstract:\n\n> Long-term trends and business cycles are usually estimated by applying the Hodrick and Prescott (HP) filter to X-11 seasonally adjusted data. A two-stage procedure is proposed in this article to improve this methodology. The improvement is based on (a) using Butterworth or band-pass filters specifically designed for the problem at hand as an alternative to the HP filter, (b) applying the selected filter to estimated trend cycles instead of to seasonally adjusted series, and (c) using autoregressive integrated moving average models to extend the input series with forecasts and backcasts.","50f7ec0e":"### Negative Target"}}