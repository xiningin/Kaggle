{"cell_type":{"f361818c":"code","839723fc":"code","45259642":"code","6716e0e0":"code","ee5404a4":"code","3a36b295":"code","abf48d58":"code","fac1fbec":"code","5768e0f0":"code","366392df":"code","614d65e4":"code","617238f6":"code","4ff5067e":"code","ff4caf39":"code","1aa2f15a":"code","7f624bc3":"code","f8ec51a2":"code","be519aad":"code","246bcab2":"code","764a90eb":"code","3a76c613":"code","6e95e395":"code","8c019f82":"code","6335967c":"code","706076a3":"code","beb74477":"code","c9312375":"code","98f14eb4":"code","9030d1b4":"code","b46a65bb":"code","9a164645":"markdown","80839692":"markdown","178c4276":"markdown","f8ea25a7":"markdown"},"source":{"f361818c":"import sys\nimport os.path\nimport pandas as pd\nimport numpy as np\nimport time\nimport seaborn as sns\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib.patches as mpatches\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.linear_model import Perceptron\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import Lasso\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom collections import defaultdict\nfrom mpl_toolkits.mplot3d import Axes3D\n\n%matplotlib inline\nplt.style.use('ggplot')\nseed = 1\nnp.random.seed(seed)\nprint(sys.version)\nprint(matplotlib.__version__)","839723fc":"def line():\n    print(\"\\n----------------------------------------------------------------\\n\")","45259642":"# pokemon_df = pd.read_csv('.\/input\/pokemon.csv')\n# combat_df = pd.read_csv('.\/input\/combats.csv')\n\npokemon_df = pd.read_csv(\"..\/input\/pokemon.csv\")\ncombat_df = pd.read_csv(\"..\/input\/combats.csv\")","6716e0e0":"print('pokemon_df')\ndisplay(pokemon_df.head())\ndisplay(pokemon_df.describe())\ndisplay(pokemon_df.shape)\npokemon_df.info()\nline()\n\nprint('combat_df')\ndisplay(combat_df.head())\ndisplay(combat_df.describe())\ndisplay(combat_df.shape)\ncombat_df.info()","ee5404a4":"\"\"\"\n1.1 Replace missing data\n\nfrom point 1.1 we saw 1 row that have missing name, we'll fill it\n@see https:\/\/bulbapedia.bulbagarden.net\/wiki\/List_of_Pok%C3%A9mon_by_National_Pok%C3%A9dex_number\n\"\"\"\n\ndisplay(pokemon_df.loc[pokemon_df['Name'].isnull()==True])\nname = 'Primeape'\npokemon_df.loc[62, 'Name'] = name\ndisplay(pokemon_df[pokemon_df['Name']==name])","3a36b295":"\"\"\"\n1.2 Rename columns\n\"\"\"\n\npokemon_df.columns = ['#', 'name', 'type1', 'type2', 'hp', 'atk', 'def', 'sp.atk', 'sp.def', 'speed', 'generation', 'legendary']\ncombat_df.columns = ['first', 'second', 'winner']\n\ndisplay(pokemon_df.head())\ndisplay(combat_df.head())","abf48d58":"\"\"\"\n1.3 Create new attrs\n\"\"\"\n\n# pokemon\n# - total, total stat attr\npokemon_df['total'] = pokemon_df['hp'] + pokemon_df['atk'] + pokemon_df['def'] + \\\n    pokemon_df['sp.atk'] + pokemon_df['sp.def'] + pokemon_df['speed']\n\n# combat\n# - loser, loser Pokemon id\n# - is_first_win, boolean\n# - diff_stat, between first and second\nno_total_dict = dict(zip(pokemon_df['#'], pokemon_df['total']))\ncols = ['first', 'second', 'winner']\ncombat_stat_df = combat_df[cols].replace(no_total_dict)\ncombat_df['loser'] = combat_df.apply(lambda x: x['first'] if x['first'] !=  x['winner'] else x['second'], axis=1)\ncombat_df['is_first_win'] = combat_df['first'] == combat_df['winner']\ncombat_df['diff_stat'] = combat_stat_df['first'] - combat_stat_df['second']\n\nprint('pokemon')\ndisplay(pokemon_df.head())\nline()\n\nprint('combat')\ndisplay(combat_stat_df.head())\ndisplay(combat_df.head())","fac1fbec":"\"\"\"\n1.4 Create new DataFrame (fight_df)\n\"\"\"\n\n# fight_df, to see \"win_ratio\"\nnfirsts = combat_df['first'].value_counts()\nnseconds = combat_df['second'].value_counts()\nnfights = nfirsts + nseconds\nfight_df = pd.DataFrame({\n    'nfights': nfights,\n    'nwins': combat_df['winner'].value_counts()\n}, columns=['nfights', 'nwins'])\nfight_df['win_ratio'] = fight_df['nwins'] \/ fight_df['nfights']\nfight_df = fight_df.sort_values(by='win_ratio')\n\nprint('fight_df example, data structure')\ndisplay(fight_df.head())\nfight_df.info()\nline()\n\nprint('fight_df example, check missing \/ incorrect data')\ndisplay(fight_df.loc[fight_df['win_ratio'].isnull() | (fight_df['win_ratio'] > 1)])\nline()\n\nprint('fight_df, fill missing data with 0')\nfight_df.loc[231, ['nfights', 'nwins', 'win_ratio']] = 0\ndisplay(fight_df.tail())","5768e0f0":"\"\"\"\n1.5 Merge new DataFrame (fight_df) into main DataFrame\n\"\"\"\n\nprint('Merge into main DataFrame, to see \"win_ratio\" for each Pokemon')\nfight_df['#'] = fight_df.index\npokemon_fight_df = pokemon_df.copy()\nwin_ratio_dict = dict(zip(fight_df['#'], fight_df['win_ratio']))\npokemon_fight_df['win_ratio'] = pokemon_fight_df['#'].replace(win_ratio_dict)\ndisplay(pokemon_fight_df.head())\nline()\n\n# check Pokemon that have no fight\nno_fight_pokemon_df = pokemon_fight_df.loc[(pokemon_fight_df['win_ratio'] > 1) | pokemon_fight_df['win_ratio'].isnull()]\nprint('Pokemon that have no fight: %d' % no_fight_pokemon_df.shape[0])\ndisplay(no_fight_pokemon_df)\nline()\n\n# interpolation on missing \"win_ratio\"\nprint('Interpolation on missing \"win_ratio\"')\nprint('for no-fight-pokemon based on \"total\" attr with \"LinearRegression\" model')\nprint('no_fight_pokemon_df, before interpolation')\ndisplay(no_fight_pokemon_df)\n\nlinreg = LinearRegression() # create LinearRegression model for interpolation\nlinreg.fit(have_fight_pokemon_df['total'].values.reshape(-1, 1), have_fight_pokemon_df['win_ratio'].values.reshape(-1, 1))\nno_fight_pokemon_df['win_ratio'] = linreg.predict(no_fight_pokemon_df['total'].values.reshape(-1, 1))\nprint('no_fight_pokemon_df, after interpolation')\ndisplay(no_fight_pokemon_df)\nline()\n\nprint('have_fight_pokemon_df, visualize data pattern')\nhave_fight_pokemon_df = pokemon_fight_df.loc[pokemon_fight_df['win_ratio'] <= 1] # only pokemon that have fight\nsns.lmplot(x='total', y='win_ratio', data=have_fight_pokemon_df)","366392df":"\"\"\"\n2.1 Top 5 percent of high-stats Pokemon\n\"\"\"\n\n# top 5\nn_top5_percent = round(0.05 * pokemon_df.shape[0])\ntop_five_df = pokemon_df.sort_values(['total'], ascending=False)[:n_top5_percent]\n\n# print and plot\nprint('Number of top 5 percent: %d' % n_top5_percent)\nplt.figure()\nsns.barplot(x='total', y='name', data=top_five_df, estimator=sum)\ntop_five_df.head()","614d65e4":"\"\"\"\n2.2 In top 5 percent of highest-stats, how many legendary in there ?\n\"\"\"\n\nlegendary_df = pokemon_df.loc[pokemon_df['legendary'] == True]\nn_legendary = legendary_df.shape[0]\n\ntop5_legendary_df = top_five_df.loc[top_five_df['legendary'] == True]\nn_top5_legendary = top5_legendary_df.shape[0]\n\nprint('Top highest stats')\nprint('Number of top 5%:', n_top5_percent)\nprint('Number of legendary in top 5%%: %d' % n_top5_legendary)\nprint('Percentage of legendary in top 5%%: %.2f %%' % (n_top5_legendary * 100 \/ n_top5_percent))","617238f6":"\"\"\"\n2.3 Attribute distribution & correlation, pokemon that have high def-stat, also have high hp-stat ?\n\"\"\"\n\ndrop_columns = ['#', 'name', 'type1', 'type2', 'generation', 'legendary']\n\n # hp vs def\nsns.jointplot(x='hp', y='def', data=pokemon_df)\n\n # eacho\nsns.pairplot(pokemon_df.drop(drop_columns, 1))\n\n# corr\nplt.figure(figsize=(20, 9))\nsns.heatmap(pokemon_fight_df.drop(drop_columns, 1).corr(), annot=True)\nplt.show()","4ff5067e":"\"\"\"\n2.4 Most powerful type of pokemon based on type\n\"\"\"\n\nf, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 8), sharex=True)\nsns.barplot(x='total', y='type1', data=pokemon_df, ax=ax1)\nsns.barplot(x='total', y='type2', data=pokemon_df, ax=ax2)","ff4caf39":"\"\"\"\n2.5 Number of Pokemon for each type\n\"\"\"\n\n# type1 and typ2 in same graph\nframe = pokemon_df.copy()\nvals1 = [frame['type1'].value_counts()[key] for key in frame['type1'].value_counts().index]\nvals2 = [frame['type2'].value_counts()[key] for key in frame['type1'].value_counts().index]\ninds = np.arange(len(frame['type1'].value_counts().index))\nwidth = .45\ncolor1 = np.random.rand(3)\ncolor2 = np.random.rand(3)\nhandles = [patches.Patch(color=color1, label='type1'), patches.Patch(color=color2, label='type2')]\nplt.bar(inds, vals1, width, color=color1)\nplt.bar(inds + width, vals2, width, color=color2)\nplt.gca().set_xticklabels(frame['type1'].value_counts().index)\nplt.gca().set_xticks(inds + width)\nplt.xticks(rotation=90)\nplt.legend(handles=handles)\n\n# type1 and type2\nf, ax = plt.subplots(2, 1, figsize=(15, 8))\nsns.countplot('type1', data=pokemon_df, ax=ax[0], order=pokemon_df['type1'].value_counts().index)\nsns.countplot('type2', data=pokemon_df, ax=ax[1], order=pokemon_df['type2'].value_counts().index)\n\n# type1 and type2 (crosstab)\n# pokemon_df['type2'] = pokemon_df['type2'].fillna(\"None\")\ntype_cross = pd.crosstab(pokemon_df['type1'], pokemon_df['type2'])\ntype_cross.plot.bar(stacked=True, figsize=(14, 4))\nplt.legend(bbox_to_anchor=(0.01, 0.99), loc='upper left', ncol=5, fontsize=8, title='type2')\nplt.show()","1aa2f15a":"\"\"\"\n2.6 Stats distribution\n\"\"\"\n\nstats = pokemon_df.dtypes[pokemon_df.dtypes=='int64'].index\nstats = stats[1:]\nfig = plt.figure(figsize=(13, 8))\nfor i, stat in enumerate(stats):\n    fig.add_subplot(3, 3, i + 1)\n    plt.hist(pokemon_df[stat], bins=60)\n    plt.title(stat)\n\nprint('stats', stats)\nplt.show()\n\n# only \"total\"\nprint('\"total\" attr')\nprint(pokemon_df['total'].describe())\nsns.distplot(pokemon_df['total'])","7f624bc3":"\"\"\"\n2.7 Stats distribution (per each type1)\n\"\"\"\n\ntypes = pokemon_df['type1'].unique()\nstats = pokemon_df.dtypes[pokemon_df.dtypes=='int64'].index\nstats = stats[1:]\nfig = plt.figure(figsize=(13, 15))\nfor j, typ in enumerate(types):\n    for i, stat in enumerate(stats):\n        fig.add_subplot(20, 8, (j * 8) + i + 1)\n        tmp_df = pokemon_df[pokemon_df['type1']==typ]\n        plt.hist(tmp_df[stat], bins=10)\n        if (((j * 8) + i) % 8 == 0):\n            plt.ylabel(typ)\n        if (j == 0):\n            plt.title(stat)\n\nprint('types', types)\nprint('stats', stats)\nplt.show()","f8ec51a2":"\"\"\"\n2.8 Average stat per each type1\n\"\"\"\n\ntmp_df = pokemon_df.groupby(['type1'])['total'].mean()\ntmp_df.plot(kind='bar')","be519aad":"\"\"\"\n2.9 Average stat per each generation\n\"\"\"\n\npokemon_groups = pokemon_df.groupby('generation')\npokemon_groups_mean = pokemon_groups.mean()\n\n# total\nsns.pointplot(x=pokemon_groups_mean.index.values, y=pokemon_groups_mean['total'])\n\n# other stats\nfig, axes = plt.subplots(ncols=2, nrows=3, figsize=(15, 10))\nsns.pointplot(x=pokemon_groups_mean.index.values, y=pokemon_groups_mean['atk'], color='red', ax=axes[0][0])\nsns.pointplot(x=pokemon_groups_mean.index.values, y=pokemon_groups_mean['def'], color='blue', ax=axes[0][1])\nsns.pointplot(x=pokemon_groups_mean.index.values, y=pokemon_groups_mean['hp'], color='black', ax=axes[1][0])\nsns.pointplot(x=pokemon_groups_mean.index.values, y=pokemon_groups_mean['speed'], color='green', ax=axes[1][1])\nsns.pointplot(x=pokemon_groups_mean.index.values, y=pokemon_groups_mean['sp.atk'], color='orange', ax=axes[2][0])\nsns.pointplot(x=pokemon_groups_mean.index.values, y=pokemon_groups_mean['sp.def'], color='purple', ax=axes[2][1])","246bcab2":"\"\"\"\n3.1 Create train data\n\"\"\"\n\ntrain_df = combat_df.copy()\nhp_dict = dict(zip(pokemon_fight_df['#'], pokemon_fight_df['hp']))\natk_dict = dict(zip(pokemon_fight_df['#'], pokemon_fight_df['atk']))\ndef_dict = dict(zip(pokemon_fight_df['#'], pokemon_fight_df['def']))\nsp_atk_dict = dict(zip(pokemon_fight_df['#'], pokemon_fight_df['sp.atk']))\nsp_def_dict = dict(zip(pokemon_fight_df['#'], pokemon_fight_df['sp.def']))\nspeed_dict = dict(zip(pokemon_fight_df['#'], pokemon_fight_df['speed']))\ntotal_dict = dict(zip(pokemon_fight_df['#'], pokemon_fight_df['total']))\nwin_ratio_dict = dict(zip(pokemon_fight_df['#'], pokemon_fight_df['win_ratio']))\n\n# create attrs\ntrain_df['first_hp'] = train_df['first'].replace(hp_dict)\ntrain_df['first_atk'] = train_df['first'].replace(atk_dict)\ntrain_df['first_def'] = train_df['first'].replace(def_dict)\ntrain_df['first_sp.atk'] = train_df['first'].replace(sp_atk_dict)\ntrain_df['first_sp.def'] = train_df['first'].replace(sp_def_dict)\ntrain_df['first_speed'] = train_df['first'].replace(speed_dict)\ntrain_df['first_total'] = train_df['first'].replace(total_dict)\ntrain_df['first_win_ratio'] = train_df['first'].replace(win_ratio_dict)\ntrain_df['second_hp'] = train_df['second'].replace(hp_dict)\ntrain_df['second_atk'] = train_df['second'].replace(atk_dict)\ntrain_df['second_def'] = train_df['second'].replace(def_dict)\ntrain_df['second_sp.atk'] = train_df['second'].replace(sp_atk_dict)\ntrain_df['second_sp.def'] = train_df['second'].replace(sp_def_dict)\ntrain_df['second_speed'] = train_df['second'].replace(speed_dict)\ntrain_df['second_total'] = train_df['second'].replace(total_dict)\ntrain_df['second_win_ratio'] = train_df['second'].replace(win_ratio_dict)\n\n# create label\ntrain_df['is_first_win'] = train_df.apply(lambda x: 1 if x['is_first_win'] == True else 0, axis=1)\n\n# remove no need attrs\nno_need_columns = ['first', 'second', 'winner', 'loser']\ntrain_df = train_df.drop(no_need_columns, axis=1)\n\n# split train & test data\ny = train_df['is_first_win']\ndrop_columns = ['is_first_win', 'first_win_ratio', 'second_win_ratio', 'diff_stat']\nx = train_df.drop(drop_columns, axis=1)\nx_train, x_test, y_train, y_test = train_test_split(x, y, train_size=0.8, random_state=seed)\n\n# create result\nacc = {}\n\n# display\nprint('train_df')\ndisplay(train_df.head())\nline()\n\nprint('x_train', x_train.shape)\ndisplay(x_train.head())\nline()\n\nprint('x_test', x_test.shape)\ndisplay(x_test.head())\nline()\n\nprint('y_train', y_train.shape)\ndisplay(y_train.head())\nline()\n\nprint('y_test', y_test.shape)\ndisplay(y_test.head())\nline()\n\nprint('visualize correlation between \"win_ratio\" and \"other attributes\"')\nprint('we notice that \"speed\" is seems to be a significant attribute to win')\ntmp_df = train_df.copy()\ndrop_columns = [c for c in tmp_df.columns if c.lower()[:6] == 'second'] + ['is_first_win', 'diff_stat']\ntmp_df = tmp_df.drop(drop_columns, 1)\nprint(tmp_df.corr().sort_values(by='first_win_ratio', ascending=False)['first_win_ratio'])\nplt.figure(figsize=(18, 8))\nsns.heatmap(tmp_df.corr(), annot=True)\nplt.show()","764a90eb":"\"\"\"\n3.2 Perform model & evaluation\n\"\"\"","3a76c613":"\"\"\"\nmodel: LogisticRegression\n\"\"\"\n\nlogreg = LogisticRegression()\nlogreg.fit(x_train, y_train)\n\nname = 'LogisticRegression'\nacc[name] = round(logreg.score(x_test, y_test) * 100, 2)\nacc[name]","6e95e395":"\"\"\"\nmodel: kNN\n\"\"\"\n\nknn = KNeighborsClassifier(n_neighbors=3)\nknn.fit(x_train, y_train)\n\nname = 'kNN'\nacc[name] = round(knn.score(x_test, y_test) * 100, 2)\nacc[name]","8c019f82":"\"\"\"\nmodel: GaussianNB\n\"\"\"\n\ngaussian = GaussianNB()\ngaussian.fit(x_train, y_train)\n\nname = 'GaussianNB'\nacc[name] = round(gaussian.score(x_test, y_test) * 100, 2)\nacc[name]","6335967c":"\"\"\"\nmodel: Perceptron\n\"\"\"\n\nperceptron = Perceptron()\nperceptron.fit(x_train, y_train)\n\nname = 'Perceptron'\nacc[name] = round(perceptron.score(x_test, y_test) * 100, 2)\nacc[name]","706076a3":"\"\"\"\nmodel: DecisionTreeClassifier\n\"\"\"\n\ndecision_tree = DecisionTreeClassifier()\ndecision_tree.fit(x_train, y_train)\n\nname = 'DecisionTreeClassifier'\nacc[name] = round(decision_tree.score(x_test, y_test) * 100, 2)\nacc[name]","beb74477":"\"\"\"\nmodel: RandomForestClassifier\n\"\"\"\n\nrandom_forest = RandomForestClassifier(n_estimators=100)\nrandom_forest.fit(x_train, y_train)\n\nname = 'RandomForestClassifier'\nacc[name] = round(random_forest.score(x_test, y_test) * 100, 2)\nacc[name]","c9312375":"\"\"\"\nmodel: Ridge\n\"\"\"\n\nclf = Ridge(alpha=1.0)\nclf.fit(x_train, y_train)\n\nname = 'Ridge'\nacc[name] = round(clf.score(x_test, y_test) * 100, 2)\nacc[name]","98f14eb4":"\"\"\"\nmodel: Lasso\n\"\"\"\n\nclf = Lasso(alpha=0.1)\nclf.fit(x_train, y_train)\n\nname = 'Lasso'\nacc[name] = round(clf.score(x_test, y_test) * 100, 2)\nacc[name]","9030d1b4":"\"\"\"\nmodel: LinearDiscriminantAnalysis\n\"\"\"\n\nclf = LinearDiscriminantAnalysis()\nclf.fit(x_train, y_train)\n\nname = 'LinearDiscriminantAnalysis'\nacc[name] = round(clf.score(x_test, y_test) * 100, 2)\nacc[name]","b46a65bb":"\"\"\"\n3.3. Model summary\n\"\"\"\n\n# we got RandomForestClassifier as a winner\nacc_df = pd.DataFrame(list(acc.items()), columns=['name', 'acc'])\nacc_df = acc_df.sort_values(by='acc', ascending=False)\ndisplay(acc_df)\n\n# but we want to know more about the importance features\neffective = pd.DataFrame()\neffective['feature_name'] = x.columns.tolist()\neffective['feature_importance'] = random_forest.feature_importances_\neffective = effective.sort_values(by='feature_importance', ascending=False)\ndisplay(effective)","9a164645":"## 2. Analyze \/ visualize data","80839692":"## 3. Model","178c4276":"## 1. Data preparation","f8ea25a7":"Original code: https:\/\/github.com\/jojoee\/pokemon-winner-prediction\n\n# Pokemon winner prediction\n\nGoal: to predict which Pokemon will win the fight\n\n## This notebook splits into 3 parts\n\n```\n1. Data preparation\n2. Analyze \/ visualize data, to find insight\n3. Model\n- 3.1 Create train data\n- 3.2 Perform model & evaluation\n- 3.3 Model summary\n```"}}