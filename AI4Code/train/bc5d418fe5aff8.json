{"cell_type":{"b9d510c1":"code","ca31b62c":"code","8e3673f8":"code","1246b113":"code","ba4ab1f7":"code","af06219d":"code","ebbd57f8":"code","dcfcf7be":"code","7cb6f754":"code","44d3aed3":"code","bb6bec94":"code","0a66c64b":"code","b4e43356":"code","efe1592e":"code","a2e2344e":"code","05099f49":"code","cf4e6f98":"code","f94548f5":"code","b85d48c4":"code","90d5f95d":"code","c11f38bd":"code","766016ee":"code","60d2cf1e":"code","93847c50":"code","2ab7004e":"code","821bf2aa":"code","958466b4":"code","3c7b7572":"code","d3f2ed5e":"code","1232b5b3":"code","96e7b001":"markdown","b903a279":"markdown","fe5f4d0c":"markdown","a3644305":"markdown","1f7f3733":"markdown","6838dac0":"markdown","144ce805":"markdown","d9da86c3":"markdown","8003940a":"markdown","d4545a78":"markdown","385a3f8f":"markdown","29432cef":"markdown","62f7534d":"markdown","d6ad4891":"markdown","9fc8bd82":"markdown","4a40339e":"markdown","2d854f53":"markdown","67aff4c9":"markdown","2fe48fd9":"markdown","4c40c917":"markdown","2f032b41":"markdown","a2b3b91b":"markdown"},"source":{"b9d510c1":"\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport gc\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","ca31b62c":"train=pd.read_csv('..\/input\/learn-together\/train.csv')\ntest=pd.read_csv('..\/input\/learn-together\/test.csv')\nsample_submission=pd.read_csv('..\/input\/learn-together\/sample_submission.csv')","8e3673f8":"plt.figure(figsize=(20,30))\nplt.subplot(5, 2, 1)\nfig = train.boxplot(column='Elevation')\nfig.set_title('')\nfig.set_ylabel('Elevation')\n \nplt.subplot(5, 2, 2)\nfig = train.boxplot(column='Aspect')\nfig.set_title('')\nfig.set_ylabel('Aspect')\n\nplt.subplot(5, 2, 3)\nfig = train.boxplot(column='Slope')\nfig.set_title('')\nfig.set_ylabel('Slope')\n \nplt.subplot(5, 2, 4)\nfig = train.boxplot(column='Horizontal_Distance_To_Hydrology')\nfig.set_title('')\nfig.set_ylabel('Horizontal_Distance_To_Hydrology')\n\nplt.subplot(5, 2, 5)\nfig = train.boxplot(column='Vertical_Distance_To_Hydrology')\nfig.set_title('')\nfig.set_ylabel('Vertical_Distance_To_Hydrology')\n \nplt.subplot(5, 2, 6)\nfig = train.boxplot(column='Horizontal_Distance_To_Roadways')\nfig.set_title('')\nfig.set_ylabel('Horizontal_Distance_To_Roadways')\n\nplt.subplot(5, 2, 7)\nfig = train.boxplot(column='Hillshade_9am')\nfig.set_title('')\nfig.set_ylabel('Hillshade_9am')\n \nplt.subplot(5, 2, 8)\nfig = train.boxplot(column='Hillshade_Noon')\nfig.set_title('')\nfig.set_ylabel('Hillshade_Noon')\n\nplt.subplot(5, 2, 9)\nfig = train.boxplot(column='Hillshade_3pm')\nfig.set_title('')\nfig.set_ylabel('Hillshade_3pm')\n \nplt.subplot(5, 2, 10)\nfig = train.boxplot(column='Horizontal_Distance_To_Fire_Points')\nfig.set_title('')\nfig.set_ylabel('Horizontal_Distance_To_Fire_Points')","1246b113":"X_train=train.copy()\nx_test=test.copy()","ba4ab1f7":"\nIQR = X_train.Slope.quantile(0.75) - X_train.Slope.quantile(0.25) #finding interquantile range\nLower_fence = X_train.Slope.quantile(0.25) - (IQR * 1.5)          #lower value\nUpper_fence = X_train.Slope.quantile(0.75) + (IQR * 1.5)          #upper value\nprint('slope number outliers are values < {lowerboundary} or > {upperboundary}'.format(lowerboundary=Lower_fence, upperboundary=Upper_fence))\nSlope = len(X_train[X_train.Slope>Upper_fence]) \/ np.float(len(X_train))\nprint('Number of Slope with values higher than {upperboundary}: {slope}'.format(upperboundary=Upper_fence, slope=Slope))","af06219d":"def top_code(df, variable, top):                            #function to top_code values\n    return np.where(df[variable]>top, top, df[variable])\nX_train['Slope']= top_code(X_train, 'Slope', 40)            #train_set is top_coded\nx_test['Slope']= top_code(x_test,'Slope',40)        #test set is top_coded","ebbd57f8":"\nIQR2 = X_train.Hillshade_3pm.quantile(0.75) - X_train.Hillshade_3pm.quantile(0.25)\nLower_fence = X_train.Hillshade_3pm.quantile(0.25) - (IQR2 * 1.5)\nUpper_fence = X_train.Hillshade_3pm.quantile(0.75) + (IQR2 * 1.5)\nprint('Hillshade_3pm number outliers are values < {lowerboundary} or > {upperboundary}'.format(lowerboundary=Lower_fence, upperboundary=Upper_fence))\nHillshades_3pm = len(X_train[X_train.Hillshade_3pm<Lower_fence]) \/ np.float(len(X_train))\nprint('Number of Hillshade_3pm with values lower than {lowerboundary}: {Hillshade_3pm}'.format(lowerboundary=Lower_fence, Hillshade_3pm=Hillshades_3pm))","dcfcf7be":"def bottom_code(df, variable, bottom):                      #function to bottom values\n    return np.where(df[variable]<bottom, bottom, df[variable])\n\n#bottom coding Hillshade_3pm\nX_train['Hillshade_3pm']=bottom_code(X_train,'Hillshade_3pm',14)\nx_test['Hillshade_3pm']=bottom_code(x_test,'Hillshade_3pm',14)","7cb6f754":"def discretise(var,X_train,x_test):\n    #ploting figure before discritisation\n    fig = plt.figure()\n    fig = X_train.groupby([var])['Cover_Type'].mean().plot(figsize=(12,6))\n    fig.set_title('relationship between variable and target before discretisation')\n    fig.set_ylabel('Cover_Type')\n    \n    # find quantiles and discretise train set\n    \n    X_train[var], bins = pd.qcut(x=X_train[var], q=8, retbins=True, precision=3, duplicates='raise')\n    x_test[var] = pd.cut(x = x_test[var], bins=bins, include_lowest=True)\n    \n    t1 = X_train.groupby([var])[var].count() \/ np.float(len(X_train))\n    t3 = x_test.groupby([var])[var].count() \/ np.float(len(x_test))\n    \n    \n    #plot to show distribution of values\n    temp = pd.concat([t1,t3], axis=1)\n    temp.columns = ['train', 'test']\n    temp.plot.bar(figsize=(12,6))\n    \n    #plot after discretisation\n    fig = plt.figure()\n    fig = X_train.groupby([var])['Cover_Type'].mean().plot(figsize=(12,6))\n    fig.set_title('Normal relationship between variable and target after discretisation')\n    fig.set_ylabel('Cover_Type')\n    \n#     return X_train,x_test","44d3aed3":"try:\n    X_train,x_test=discretise('Horizontal_Distance_To_Hydrology',X_train,x_test)\nexcept TypeError:\n    pass","bb6bec94":"try:\n    X_train,x_test=discretise('Vertical_Distance_To_Hydrology',X_train,x_test)\nexcept TypeError:\n    pass","0a66c64b":"try:\n    X_train,x_test=discretise('Horizontal_Distance_To_Roadways',X_train,x_test)\nexcept TypeError:\n    pass","b4e43356":"try:\n    X_train,x_test=discretise('Hillshade_9am',X_train,x_test)\nexcept TypeError:\n    pass","efe1592e":"try:\n    X_train,x_test=discretise('Hillshade_Noon',X_train,x_test)\nexcept TypeError:\n    pass","a2e2344e":"try:\n    X_train,x_test=discretise('Horizontal_Distance_To_Fire_Points',X_train,x_test)\nexcept TypeError:\n    pass","05099f49":"def inpute(var,X_train,x_test):\n    if x_test[var].isnull().sum()>0:\n        x_test.loc[x_test[var].isnull(), var] = X_train[var].unique()[0]\n        print(\"inputed column :: \",var)\n    ","cf4e6f98":"inpute('Hillshade_3pm',X_train,x_test)","f94548f5":"for col in X_train.columns:\n    if col !='Cover_Type':\n        inpute(col,X_train,x_test)\n","b85d48c4":"X_train.head()","90d5f95d":"for df in [X_train, x_test]:\n    df.Horizontal_Distance_To_Hydrology = df.Horizontal_Distance_To_Hydrology.astype('O')\n    df.Vertical_Distance_To_Hydrology = df.Vertical_Distance_To_Hydrology.astype('O')\n    df.Horizontal_Distance_To_Roadways = df.Horizontal_Distance_To_Roadways.astype('O')\n    df.Hillshade_9am = df.Hillshade_9am.astype('O')\n    df.Hillshade_Noon = df.Hillshade_Noon.astype('O')\n    df.Horizontal_Distance_To_Fire_Points = df.Horizontal_Distance_To_Fire_Points.astype('O')","c11f38bd":"def encode_categorical_variables(var, target):\n        # make label to risk dictionary\n        ordered_labels = X_train.groupby([var])[target].mean().to_dict()\n        \n        # encode variables\n        X_train[var] = X_train[var].map(ordered_labels)\n        x_test[var] = x_test[var].map(ordered_labels)","766016ee":"for var in ['Horizontal_Distance_To_Hydrology', 'Vertical_Distance_To_Hydrology','Horizontal_Distance_To_Roadways','Hillshade_9am','Hillshade_Noon','Horizontal_Distance_To_Fire_Points']:\n    print(var)\n    encode_categorical_variables(var, 'Cover_Type')","60d2cf1e":"X_train.head()","93847c50":"import warnings\nwarnings.filterwarnings(\"ignore\")\n\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import RandomizedSearchCV\nfrom sklearn.model_selection import GridSearchCV\nimport gc","2ab7004e":"def model_training(model,X_train,y_train):\n    scores =  cross_val_score(model, X_train, y_train,\n                              cv=5)\n    return scores.mean()","821bf2aa":"X_train.drop(['Id','Cover_Type'],axis=1,inplace=True)\nx_test.drop(['Id'],axis=1,inplace=True)\ny_train=train['Cover_Type']","958466b4":"model_training(RandomForestClassifier(n_estimators=885,min_samples_split=2,min_samples_leaf=1,max_features='sqrt',max_depth=110,bootstrap=False),X_train,y_train)","3c7b7572":"my_model=RandomForestClassifier(n_estimators=885,min_samples_split=2,min_samples_leaf=1,max_features='sqrt',max_depth=110,bootstrap=False)\nmy_model.fit(X_train,y_train)","d3f2ed5e":"test_preds=my_model.predict(x_test)","1232b5b3":"output = pd.DataFrame({'Id': test.Id,\n                      'Cover_Type': test_preds})\noutput.to_csv('sample_submission.csv', index=False)","96e7b001":"**Discretisation :: Horizontal_Distance_To_Fire_Points**","b903a279":"**the relationship the variable and the target can be clearly seen after discretisation**\n\n**as the value of distance increses the cover_type of forest is lowered and after 457 the cover increases conversly**","fe5f4d0c":"**now thier are few missing values in the test set and we have to inpute them**","a3644305":"**1.Top_coding: Slope**\n\n**2.Bottom_coding:Hillshade_3pm**\n\n**3.Discretisation: all other columns**","1f7f3733":"**now the intervals are formed **\n\n**before encoding them we have change their data type to object**","6838dac0":"**Slope:**\n\n**now i have to calculate the interquantile range(IQR) for the column **","144ce805":"**cover type is decreases till the distance of 16 and than it increases after 16**","d9da86c3":"**Bottom_coding : Hillshade_3pm**","8003940a":"**i have seen lots of people are using random forest but their model is overfitting very badly\n\nhere is my notebook where i am getting (76%)accuracy on cross validation and 73% on test**\n\n**so clearly this has reduce overfiting in random forest **\n\n**though the accuracy is low but atleast their is no overfitting and it is better than a overfitted model because when the private leaderboard will be evaluated than the accuracy will fall drastically **","d4545a78":"**now we have top_coded and bottom coded respective columns \n**","385a3f8f":"**Discretisation :: Vertical_Distance_To_Hydrology**","29432cef":"**data after encoding**","62f7534d":"**Discretisation :: Horizontal_Distance_To_Roadways**","d6ad4891":"**Ploting the boxplot of all continues variable **","9fc8bd82":"**Discretisation : Horizontal_Distance_To_Hydrology**","4a40339e":"**now i will use discretisation for the other columns which have outliers**","2d854f53":"the lower value in inter quantile range is 14(approx)\n\nwe we have to cap the values lower than 14 to 14","67aff4c9":"**Discretisation :: Hillshade_Noon**","2fe48fd9":"**Discretisation :: Hillshade_9am**","4c40c917":"**Clearly the columns other than elevation and aspect have outliers in them**\n\n**i will be using 2 techniques for outliers handling**\n\n**1.top_coding and bottom_coding: in this the values which are out of the range are caped within it**\n\n**2.Discretisation: the intervals of all values are formed so that outliers could come in some interval**","2f032b41":"the uppervalue of the quantile in slope is 40\n\nnow we have to cap all the values which are above 40 to 40","a2b3b91b":"**the cover type is stable till distance of 1695 and than it increase till 2270 and the cover type falls down after 2270**"}}