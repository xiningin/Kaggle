{"cell_type":{"1e62b64d":"code","bc15c8b5":"code","4a9e3806":"code","c4ebd989":"code","79ad198d":"code","8f91a8f6":"code","fac7ae08":"code","4eb91cb3":"code","cec401c3":"code","236fdef8":"code","da7204c0":"code","af3ec664":"code","650039f6":"code","e436c6b5":"code","35a819b8":"code","4aa00325":"code","69b233b0":"code","7bbe249f":"code","b66bfa28":"code","e387d498":"markdown","824a53d6":"markdown","20a85fc3":"markdown","9eb18ed9":"markdown","5cbfb4d2":"markdown","8626da91":"markdown","a2c8bebd":"markdown","b4081ca8":"markdown","15f2fb1f":"markdown","4d18cb55":"markdown","a4d5a830":"markdown","7701c361":"markdown","ba6d216b":"markdown"},"source":{"1e62b64d":"%matplotlib inline\n\nimport os\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport lightgbm\n\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.metrics import f1_score, make_scorer\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.impute import SimpleImputer\nfrom matplotlib import pyplot as plt","bc15c8b5":"# To remove the limit on the number of rows displayed by pandas\npd.set_option(\"display.max_rows\", None)\n\n# Read csv files in pandas dataframe\ntestDf = pd.read_csv('..\/input\/test.csv')\ntrainDf = pd.read_csv('..\/input\/train.csv')\nprint(\"Training dataset basic information\")\nprint(\"Rows: {}\".format(len(trainDf)))\nprint(\"Columns: {}\".format(len(trainDf.columns)))\ntrainDf.head()","4a9e3806":"print(\"Test dataset basic information\")\nprint(\"Rows: {}\".format(len(testDf)))\nprint(\"Columns: {}\".format(len(testDf.columns)))\ntestDf.head()","c4ebd989":"# Add null Target column to test\ntestDf['Target'] = np.nan\ndata = trainDf.append(testDf, ignore_index = True)","79ad198d":"# 1. Find missing values in training and test dataset\ndef findColumnsWithNan(df):\n    cols = df.columns[df.isna().any()]\n    print(\"Number of columns with Nan: {}\".format(len(cols)))\n    print(\"Column names: {}\".format(cols))\n    print(\"-\" * 80)\n    for col in cols:\n        print(\"Column: [{}] missing {} values.\".format(col, len(df[df[col].isna() == True])))\n\nprint(\"Analysis of training dataset...\")\nfindColumnsWithNan(trainDf)","8f91a8f6":"print()\nprint(\"Analysis of test dataset...\")\nfindColumnsWithNan(testDf)","fac7ae08":"data.loc[(data['tipovivi1'] == 1) & (data['v2a1'].isna()), 'v2a1'] = 0\nprint(\"Missing values after replacing: {}\".format(len(data.loc[data['v2a1'].isna()])))","4eb91cb3":"data.loc[data['v18q1'].isna(), 'v18q1'] = 0\nprint(\"Missing values after replacing: {}\".format(len(data.loc[data['v18q1'].isna()])))","cec401c3":"data.loc[(data['age'] < 7) & (data['rez_esc'].isna()), 'rez_esc'] = 0\ndata.loc[(data['age'] > 19) & (data['rez_esc'].isna()), 'rez_esc'] = 0\nprint(\"Missing values after replacing: {}\".format(len(data.loc[data['rez_esc'].isna()])))","236fdef8":"data.loc[data['age'] < 19 & data['meaneduc'].isna(), 'meaneduc'] = 0\nprint(\"Missing values after replacing: {}\".format(len(data.loc[data['meaneduc'].isna()])))","da7204c0":"data.drop('SQBmeaned', inplace=True, axis=1)\nprint(\"Total number of columns left: {}\".format(len(data.columns)))","af3ec664":"for cols in data.columns[1:]:\n    if cols in ['idhogar', 'dependency', 'edjefe', 'edjefa']:\n        continue\n    percentile75 = np.percentile(data[cols].fillna(0), 75)\n    percentile25 = np.percentile(data[cols].fillna(0), 25)\n    threshold = (percentile75 - percentile25) * 1.5\n    lower, upper = (percentile25 - threshold), (percentile75 + threshold)\n    # identify outliers\n    outliers = data.loc[(data[cols] < lower) & (data[cols] > upper)]\n    if len(outliers) > 0:\n        print('Feature: {}. Identified outliers: {}'.format(cols, len(outliers)))","650039f6":"for col in ['dependency', 'edjefe', 'edjefa']:\n    data.loc[data[col] == 'yes', col] = 1.0\n    data.loc[data[col] == 'no', col] = 0.0\n    data[col] = pd.to_numeric(data[col])","e436c6b5":"corrMat = data.corr()\nplt.figure(figsize=(30, 10))\nsns.heatmap(corrMat.iloc[:10, :10])","35a819b8":"def featuresToDrop(corrMatrix):\n    \"\"\"\n    To remove correlated features, used this gem of a code from here:\n    https:\/\/chrisalbon.com\/machine_learning\/feature_selection\/drop_highly_correlated_features\n    \"\"\"\n    # Select upper triangle of correlation matrix\n    upper = corrMatrix.where(np.triu(np.ones(corrMatrix.shape), k=1).astype(np.bool))\n\n    # Find index of feature columns with correlation greater than 0.95\n    return [column for column in upper.columns if any(upper[column] > 0.95)]\n\ntoDrop = featuresToDrop(corrMat)\ndata.drop(toDrop, inplace=True, axis=1)\nprint(\"Correlated features which are dropped: {}\".format(toDrop))","4aa00325":"features = list(data.drop(columns = ['Id', 'idhogar', 'Target']).columns)\naggDf = data.drop(columns='Target').groupby('idhogar').agg(['min', 'max', 'sum', 'count', 'std'])\n# Rename the columns\nnew_col = []\nfor c in aggDf.columns.levels[0]:\n    for stat in aggDf.columns.levels[1]:\n        new_col.append('{}-{}'.format(c, stat))\n        \naggDf.columns = new_col\ntoDrop = featuresToDrop(aggDf.corr())\naggDf.drop(toDrop, inplace=True, axis=1)\ndata = data.merge(aggDf, on='idhogar', how ='left')\nprint('Training feature shape: ', data.shape)","69b233b0":"data['phones-per-capita'] = data['qmobilephone'] \/ data['tamviv']\ndata['tablets-per-capita'] = data['v18q1'] \/ data['tamviv']\ndata['rooms-per-capita'] = data['rooms'] \/ data['tamviv']\ndata['rent-per-capita'] = data['v2a1'] \/ data['tamviv']","7bbe249f":"# Labels for training\ntrainTarget = np.array(list(data[data['Target'].notnull()]['Target'].astype(np.uint8)))\nsubmission = data.loc[data['Target'].isnull(), 'Id'].to_frame()\n\n# Extract the training data\ntrainData = data[data['Target'].notnull()].drop(columns = ['Id', 'idhogar', 'Target'])\ntestData = data[data['Target'].isnull()].drop(columns = ['Id', 'idhogar', 'Target'])\n\n# Impute training and test data\nimputer = SimpleImputer(missing_values=np.nan, strategy='median')\ntrainData = imputer.fit_transform(trainData)\ntestData = imputer.transform(testData)\n\n# Scale training and test data\nscaler = MinMaxScaler()\ntrainData = scaler.fit_transform(trainData)\ntestData = scaler.transform(testData)","b66bfa28":"model = lightgbm.LGBMClassifier(max_depth=-1, learning_rate=0.1, objective='multiclass',\n                             random_state=None, silent=True, metric='None', \n                             n_jobs=4, n_estimators=5000, class_weight='balanced',\n                             colsample_bytree =  0.93, min_child_samples = 95, num_leaves = 14, subsample = 0.96)\nkfold = 5\nkf = StratifiedKFold(n_splits=kfold, shuffle=True)\n\npredicts_result = []\nfor idx, (train_index, test_index) in enumerate(kf.split(trainData, trainTarget)):\n    print(\"Fold: {}\".format(idx))\n    X_train, X_val = trainData[train_index], trainData[test_index]\n    y_train, y_val = trainTarget[train_index], trainTarget[test_index]\n    model.fit(X_train, y_train, verbose=100)\n    predicts_result.append(model.predict(testData))\nsubmission['Target'] = np.array(predicts_result).mean(axis=0).round().astype(int)\nsubmission.to_csv('submission.csv', index=False)\nprint(\"Completed!\")","e387d498":"### 7. Machine Learning model","824a53d6":"#### 1.4 Fix missing values of meaneduc\nIt means average years of education for adults (18+). This implies that if the age of an individual is less than 18 and the value is NaN, then we can replace it with 0. Other NaN are left to be imputed.","20a85fc3":"#### 1.3 Fix missing values of rez_esc\nIt means years behind in school. From the discussions on Kaggle, it can be concluded that this value is defined only for people whose age is between 7 and 19. So the missing values can be updated to 0 using this criteria. Age of an individual is in the column appropriately named 'age'.","9eb18ed9":"### 6. Feature imputing and scaling\nScaling means to transform data in such a way that they fit within a range say 0-100 or 0-1. We will be using min-max scaler to transform the feature to be in the range 0-1.","5cbfb4d2":"### 3. Find incosistent values\nWhen finding outliers, following three features ('dependency', 'edjefe', 'edjefa') were found to have incosistent values. To take care of this, 'yes' is replaced with 1 and 'no' is replaced with 0. Also, to make sure each value in the feature are of the same data type, features are converted to float.","8626da91":"### 5. Feature engineering\nDefinition: \"Feature engineering is the process of using domain knowledge of the data to create features that make machine learning algorithms work.\"\n\n5.1 Add aggregated features (min, max, std, sum)\n5.2 Add features per household\n5.3 Explore features","a2c8bebd":"### 2. Find outliers\nInter-quartile range(IQR) is used to identify outliers in the dataset. IQR is the difference between the 75th and 25th percentile of the data. It is measure of dispersion along the lines of standard deviation. During this analysis, features were found which had incosistent values like integer and boolean string (yes\/no) mixed together. These needs to be removed and is the main focus of the next step.","b4081ca8":"### 4. Remove correlated features\nHighly correlated feature pairs are redundant, one of the pairs is selected to be removed.","15f2fb1f":"#### 1.1. Fix missing values of v2a1 \nIt means Monthly rent payment. To find what Nan means, v2a1 is compared with 'tipovivi' feature which gives information whether the house is rented\/completely paid off etc. <br>\n\ntipovivi1 =1 own and fully paid house <br>\ntipovivi2 =1 own,  paying in installments\" <br>\ntipovivi3 =1 rented <br>\ntipovivi4 =1 precarious <br>\ntipovivi5 =1 other(assigned,  borrowed)\" <br>\n\n'v2a1' is replaced with 0, wherever tipovivi1=1, and all other missing values are left which will be imputed later. This means that if the house is fully owned by household then they don't pay any rent.","4d18cb55":"#### Exploratory Data Analysis (EDA)\n1. Find missing values\n2. Find outliers\n3. Find incosistent values\n4. Remove correlated features\n5. Feature engineering\n6. Feature scaling\n7. Impute missing values","a4d5a830":"#### 1.5 Fix missing values of SQBmeaned\nIt means square of the mean years of education of adults (>=18) in the household. It is highly correlated with feature 'age' and there is no real need of it. Hence, this feature is dropped from the dataset.","7701c361":"### 1. Find and fix missing feature values","ba6d216b":"#### 1.2. Fix missing values of v18q1\nIt means number of tablets household owns. After careful analysis of household members, it can concluded that NaN means household does not own a tablet. We replace NaN with 0."}}