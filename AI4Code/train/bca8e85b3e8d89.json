{"cell_type":{"a31162e3":"code","1e26ef5b":"code","9d297792":"markdown","453d05f5":"markdown","798d473e":"markdown","df3f1040":"markdown","6e429d0d":"markdown","a8bdf9aa":"markdown","15cb3f4e":"markdown","4564e730":"markdown","ab7a11ca":"markdown","27888c87":"markdown","9b869f90":"markdown"},"source":{"a31162e3":"# Needed to conduct the arithmetic functions\nimport math\n\n# Start of function \"bearing\" and establish requirement for four inputs\ndef bearing (x1, y1, x2, y2):\n    # assign dx and dy -- this will calculate change in x and change in y needed for algorithm later\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    #IF\/ELIF\/ELSE statements needed specifically here to account for \"dividing by zero\" error when dy=0. Three possisble cases:\n    if dy == 0:\n        if dx > 0:\n            res = 90 #Special case 1, result is \"East\"\n            \n        elif dx < 0:\n            res = 270 #Special case 2, result is \"West\"\n            \n        else:\n            res = 'Stationary'# Special case 3, no change in dx or dy\n            \"\"\"\n            Don't return string when usually a number - we can create an ERROR (see later) or just return 0\n            \"\"\"\n            \n    else:\n        \n        # Python for bearing = tan-1(dx\/dy)\n        res = math.atan(dx\/dy)\n        # Result from above is in radians, script below converts to degrees\n        res = math.degrees(res)\n\n        if dx > 0 and dy > 0:\n            res = res \n\n        elif dx > 0 and dy < 0:\n            res = res + 180\n\n        elif dx < 0 and dy < 0:\n            res = res + 180\n\n        elif dx < 0 and dy > 0:\n            res = res + 360\n\n        elif dx == 0 and dy > 0:\n            res = 0\n            # Special case 4, Bearing is North\n\n        elif dx == 0 and dy < 0:\n            res = 180\n            #Special case 5, Bearing is South\n        \n    return res # close out of function","1e26ef5b":"print(bearing(1,1,5,5))\n# Test A -- angle was 45 degrees, dx > 0 and dy > 0 so no adjustment is needed, WCB is 45 degrees (NE)\n\nprint(bearing(1,5,5,1))\n# Test B -- angle was -45 degrees, dx > 0 and dy < 0, so add an adjustment of 180 degrees, WCB is 135 degrees (SE)\n\nprint(bearing(0,0,-5,-5))\n# Test C -- angle was 45 dx < 0 and dy < 0, so add an adjustment of of 180, WCB is 225 degrees (SW)\n\nprint(bearing(0,0,-5,5))\n# Test D -- angle was -45 degrees, dx < 0 and dy > 0, so add an adjustment of 360 to get the WCB of 315 degrees (NW)\n\nprint(bearing(10,2,10,6))\n# Test E -- dx = 0 and dy is positive so it is known the WCB is 0 degrees (North)\n\nprint(bearing(10,0,12,0))\n# Test F -- dx is positive and dy = 0, so it is known that the WCB is 90 degrees (East)\n\nprint(bearing(10,6,10,2))\n#Test G -- dx = 0 and dy is negative so it is known the WCB is 180 degrees (South)\n\nprint(bearing(12,0,10,0))\n# Test H -- dx is negative and dy = 0, so it is known that the WCB is 270 degrees (West)\n\nprint (bearing (0,0,0,0))\n# Test I -- dx = 0 and dy = 0, so it is known that there is no movement in any direction, therefore it is stationary with no bearing\n\nprint(bearing (7, 1, -5, 9))\n#Test J -- angle of -56.31, dx < 0 and dy > 0 so add 360 degree adjustment, WCB is 303.69 (NW)\n\nprint(bearing(4, 4, 6, 8))\n#Test K -- Produced angle of 26.56, dx > 0 and dy > 0 so no adjustment needed, WCB is 26.56 (NE)\n\nprint(bearing(-5, 6, 1, 1))\n#Test L -- angle of -50.19, dx > 0 and dy < 0, so add 180 adjustment, WCB is 129.80 (SE)\n\nprint(bearing(2, -3, -3, -3))\n#Test M -- dx > 0 and dy = 0, therefore it is known that the WCB is 270 (West)","9d297792":"# References for Graphics\n\n#### Graphic 1.1:\n\nRajput, K. (2021) What is Whole Circle Bearing (WCB). Available at https:\/\/civiljungle.com\/wcb-vs-qb\/ (Accessed: 9 November 2021).\n\n#### Graphic 1.2:\n\nJames, P. (2021) 'Coursework 1 -- Whole Circle Bearings in Python'  [Powerpoint Presentation] CEG 1713: Data Science 1. Available at: https:\/\/ncl.instructure.com\/courses\/39142\/files\/4872776?module_item_id=2002876 (Accessed: 9 November 2021).","453d05f5":"<font size='+2' color='ff0000'>\n \n* Great report and well tested.  Don't return text when you usually return numbers - it causes problems\n* Keep it up!","798d473e":"# Test Results\n\n#### Test Script","df3f1040":"#### Test Results\n\n|Name|Inputs (X1, Y1) (X2, Y2)|Expected Output|Actual Output|Pass\/Fail|\n|---|---|---|---|---|\n|A|(1, 1) (5, 5)|45|45 |Pass|\n|B|(1, 5) (5, 1)|135|135|Pass|\n|C|(0, 0) (-5, -5)|225|225|Pass|\n|D|(0, 0) (-5, 5)|315|315|Pass|\n|E|(10, 2) (10, 6)|0|0|Pass|\n|F|(10, 0) (12, 0)|90|90|Pass|\n|G|(10, 6) (10, 2)|180|180|Pass|\n|H|(12, 0) (10, 0)|270|270|Pass|\n|I|(0, 0) (0, 0)|0 (Stationary)|0 (Stationary)|\tPass|\n|J|(7, 1) (-5, 9)|303.69|303.69|Pass|\n|K|(4, 4) (6, 8)|26.56|26.56|Pass|\n|L|(-5, 6) (1, 1)|129.80|129.80|Pass|\n|M|(2, -3) (- 3, -3)|270|270|Pass|\n","6e429d0d":"<font size='+2' color='ff0000'>\n \n* We would customarily also include a function description as below\n\n<font size='+1' color='ffffff'>\n<code>\n    def bearing(x1, y1, x2, y2):\n        \"\"\"\n        Summary: calculates whole circle bearings between 0 ansd 360 degrees\n        ------------------\n        arguments:\n        x1: x value of the from coordinate\n        y1: y value of the y coordinate\n        x2: x value to the to coordinate\n        y2: y value of the to coordinate\n        ------------------\n        returns:\n        bearing in decimal degrees\n        ------------------\n        notes:\n        coordinates with matching x and y returns a bearing of 0\n        \"\"\"\n\n        #code here\n    <\/code>","a8bdf9aa":"# Introduction\n\nThe purpose of this assignment is to create a program that will output a whole circle bearing when given any two sets of cartesian coordinates. A whole circle bearing (WCB) is an angle between 0 and 360 degrees when measured clockwise between \"North\" (0\/360 degrees, the starting reference point) and any direction that is established between at least two points. See graphic 1.1.\n\n#### Graphic 1.1\n\n![image.png](attachment:ea408bbb-6378-4bae-85be-428e87853269.png)\n\nMany people will recognize whole circle bearings when looking at a compass. Whole circle bearing is different from a generic \"angle\" which does not take into account the direction with respect to north. \n\nWCBs are important for many reasons, but especially for surveyors. While angles are useful for surveyors, oftentimes a bearing with respect to north is needed. A surveyor needs to know in what direction to run a line level or how one point is spatially related to another point (i.e. point A is located northeast of benchmark X at a bearing of 60 degrees.)\n\nThis notebook will include a description of the code that was used to solve the assignment problem, the code itself, tests that prove that the code will work for any cartesian coordinates, and the results of those tests.","15cb3f4e":"# Description of the Code\n\nThe code is essentially one big function that includes several IF, ELIF, and ELSE statements, Boolean operators such as <,>,==, and some mathematical algorithms.\n\nThe function in the code, named \"bearing\", requires four numerical inputs: x1, y1, x2, y2. These inputs correspond to x,y coordinates of two points normally written as (x1, y1) (x2, y2). The inputs must be written in this exact order, but for the purpose of the code, the coordinates are not separated into the usual two parenthesis.\n\nThe function also includes the terms dx (the difference between the x-coordinates) and dy (the difference between the y-coordinates). These are important in order to conduct the trigonometric algorithm to determine a bearing.\n\n**Important note**-- Before getting to the algorithm, a nested IF statement is needed to address an error that will arise when dividing by \"dy\" when \"dy\" equals zero. Mathematically that is not possible, but for a WCB it is possible and can correspond to two possible directions: \"east\" or \"west\". The IF statements addresses these special cases by assigning the proper bearing based off of the value of \"dx\" when \"dy\" equals zero.\n\nThe algorithm needed to compute the bearing when given two sets of coordinates is: bearing = tan-1(dx\/dy). In python this is math.atan(dx\/dy). Dx and dy are already going to be calculated based on the given x,y coordinate inputs, so the user is not required to do any math, the script will do it all. The output of this algorithm will be in radians, so another function called math.degrees() will convert that into degrees. \n\nThe rest of the function is IF\/ELIF statements that look at whether the value of dx and dy is positive or negative. This positive or negative value tells the script the direction and therefore what adjustment, if any, is needed to produce the WCB. See graphic 1.2 of different dx and dy value combinations and the associated adjustment for that quadrant.\n\n#### Graphic 1.2\n\n![image.png](attachment:6df40c58-ffc5-4e08-bbdc-16300ac91646.png)\n\nThe adjustment is needed because otherwise all outputs would be between -90 and 90, which are not WCBs. The adjustment will convert to the correct whole circle bearing. An example from Graphic 1.2 above: if dx was negative and dy was negative, the user knows that the WCB should be between 180 and 270 degrees. Without the adjustment, the output may falsely show 45 degrees. Add  the associated adjustment for that quadrant (+180 in this case) to 45 and the user will get the correct WCB of 225 degrees.","4564e730":"# Conclusion\n\nThe goal of this notebook was to create a program script that was able to take (x,y) coordinate inputs for any two points and generate an accurate whole circle bearing. That aim was achieved. The program script functioned as intended without errors and the testing phase produced the expected results for each scenario. Markdowns and python comments explain what is done at each step, why it was done a specific way, and hopefully provides a good example for other programmers to examine. It was extremely beneficial as a learning exercise and was even a bit enjoyable.\n","ab7a11ca":"<font size='+2' color='ff0000'>\n    \n* Very good intro","27888c87":"# Test Methodology\n\nThe program script was ran and checked against several known outcomes to see if the code functioned as designed. Known values were found independent from the code by using trigonometry and a calculator. There are 13 tests that were used. The input values for first four tests (A-D) were consciously selected to evaluate bearings from each quadrant. Test E through test I evaluated the special cases, meaning those cases where dx, dy, or both equalled zero. Four additional tests with randomly chosen inputs were included for added fun and further evaluation. The resulting output from the script was checked against the pre-determined WCBs for correctness. \n","9b869f90":"# The Code\n\nThe code to calculate the whole circle bearing between two points:\n"}}