{"cell_type":{"f6a06ded":"code","a9d1e593":"code","dd05aab4":"code","c3597b6b":"code","d0e926b8":"code","d84ab492":"code","2384c3b3":"code","81c40348":"code","8cd422d0":"code","7aab6dcf":"code","62635726":"code","c01ea04e":"code","4166a5f8":"code","8b461c86":"code","4780f715":"code","ab96756f":"code","4a0a4bf2":"code","b46c3ba8":"code","cbebb25b":"code","a683cda0":"code","753915c9":"code","72c2218a":"code","081e307d":"code","fe3c73ea":"code","6b548986":"code","ec469378":"code","f078c415":"code","7c35da0b":"code","192d8671":"code","33f90fc4":"code","fd452cfb":"code","1680ba41":"code","484936e4":"code","5298cc4a":"code","e3d67239":"code","a29324af":"code","2b3d41c9":"code","a7edba72":"code","94dd4be0":"code","e8ef5cce":"code","f627c486":"code","1ea15cbd":"code","fc67a353":"code","67cbc58e":"code","7c6a5ea1":"code","97cb23f7":"code","86db2ac3":"code","3805194c":"code","53e489e7":"code","83a590c2":"code","aa2b56e7":"code","a359ca35":"code","eecb445a":"code","449259d0":"code","1960f863":"code","4225322e":"code","6b617950":"code","30c949ac":"code","924a5314":"code","8c50f695":"code","653ffc9c":"code","57ce7200":"code","8c3d200e":"code","90c6d43e":"code","aa2a655f":"code","6b81471a":"code","7bb1bed4":"code","eaf8586d":"code","e28919ed":"code","b9486d85":"code","07377220":"code","6dd4b9b1":"code","f611650f":"code","99ee7b5b":"code","1be59fb0":"code","13c46550":"code","60c39aec":"code","d4aaacab":"markdown","d643cb5e":"markdown","ca1d3a11":"markdown","65427166":"markdown","c7b0a396":"markdown","7893e1cc":"markdown","16bc3218":"markdown","3a849af4":"markdown","eb8d2cc3":"markdown","403db960":"markdown","b48024d5":"markdown","32517a6b":"markdown","f45a67f4":"markdown","f0cb3797":"markdown","6259c38b":"markdown","f7cb62d9":"markdown","e853cc41":"markdown","76a860e3":"markdown","4b867208":"markdown","d31b9c8b":"markdown","85c0748d":"markdown","463acde6":"markdown","a3313e2d":"markdown","3ec72816":"markdown"},"source":{"f6a06ded":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","a9d1e593":"#Import all the required libraries\n\n#System libraries\nimport os, time\nfrom tqdm import tqdm\nimport glob\n\n# Data manipulation\nimport numpy as np\nimport pandas as pd\nimport collections, random, re\nfrom collections import Counter\n\n# Model building \nfrom sklearn.model_selection import train_test_split\nfrom sklearn.utils import shuffle\n\n\n#Read\/Display  images\nfrom skimage import io\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom PIL import Image\nfrom nltk.translate.bleu_score import sentence_bleu\nfrom nltk.translate.bleu_score import SmoothingFunction\n\n# import tensorflow libraries\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers, Model\nfrom tensorflow.keras.preprocessing.image import load_img, img_to_array\nfrom tensorflow.keras.utils import plot_model\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","dd05aab4":"print(\"Tensorflow Version:\",tf.__version__)\nprint(\"Keras Version     :\",keras.__version__)","c3597b6b":"## Global Variables\nINPUT_PATH = \"..\/input\/flickr8k\/\"\nIMAGE_PATH = INPUT_PATH+'Images\/'\nCAPTIONS_FILE = INPUT_PATH+'captions.txt'\nOUTPUT_IMAGE_PATH = \"..\/working\/Image_rishu\/\"","d0e926b8":"#Import the dataset and read the image into a seperate variable\n\nimages='\/kaggle\/input\/flickr8k\/Images'\n\nall_imgs = glob.glob(images + '\/*.jpg',recursive=True)\nprint(\"The total images present in the dataset: {}\".format(len(all_imgs)))","d84ab492":"#Visualise both the images & text present in the dataset\nImage.open(all_imgs[369])","2384c3b3":"all_imgs[369]","81c40348":"def load_doc(filename):\n    \n    text=open(filename).read() ## Read the file\n    \n    return text\n\ndef get_img_ids_and_captions(text): ## To get image ids and captions\n    keys=[]\n    values=[]\n    key_paths=[]\n    text=text.splitlines()[1:]\n    for line in text:\n        com_idx=line.index(\",\")\n        im_id,im_cap=line[:com_idx],line[com_idx+1:]\n        keys.append(im_id)\n        values.append(im_cap)\n        key_paths.append(images+'\/'+im_id)\n    return keys,values,key_paths\n\ntext_file=\"\/kaggle\/input\/flickr8k\/captions.txt\"\n# text_file = 'C:\/Users\/Rishabh\/Desktop\/UPGRAD\/CAPSTONE PROJECT\/EYE FOR BLIND\/archive - Eye for blind\/Flickr8K\/captions.txt'\ndoc = load_doc(text_file)\nprint(doc[:600], \"........\")\ndoc = load_doc(text_file)\nprint(doc[:300])","8cd422d0":"all_img_ids,annotations,all_img_vector= get_img_ids_and_captions(doc)#store all the image id here\n\n## zip is used to map the smilar index of multiple containers\ndf = pd.DataFrame(list(zip(all_img_ids, all_img_vectors,annotations)),columns =['ID','Path', 'Captions']) \n    \ndf","7aab6dcf":"Image.open(all_img_vector[1729])","62635726":"df.info()","c01ea04e":"## Function to visualize images and their respective captions\ndef plot_image_captions(Pathlist,captionsList,fig,count=2,npix=299,nimg=2): \n        image_load = load_img(Path,target_size=(npix,npix,3))\n        ax = fig.add_subplot(nimg,2,count,xticks=[],yticks=[])\n        ax.imshow(image_load)\n        \n        count +=1\n        ax = fig.add_subplot(nimg,2,count)\n        plt.axis('off')\n        ax.plot()\n        ax.set_xlim(0,1)\n        ax.set_ylim(0,len(captions))\n        for i, caption in enumerate(captions):\n            ax.text(0,i,caption,fontsize=20)","4166a5f8":"# Images \nfig = plt.figure(figsize=(10,20))\ncount = 1\n    \nfor Path in df[20:40].Path.unique():\n    captions = list(df[\"Captions\"].loc[df.Path== Path].values)\n    plot_image_captions(Path,captions,fig,count,299,5) ## Because there are 5 captions for each image\n    count +=2\nplt.show()\n","8b461c86":"## Check the number of images and associated captions with an image\nuni_filenames= np.unique(df.ID.values)\nprint(\"The number of unique file names : {}\".format(len(uni_filenames)))\nprint(\"The distribution of the number of captions for each image:\", Counter(Counter(df.ID.values).values()))","4780f715":"# Create the vocabulary & the counter for the captions\ndef voc_fetcher(frame,column):\n    out=[]\n    for i in frame[column]:\n        out+=i.split(\" \")\n    return out\n\nvocabulary=voc_fetcher(df,\"Captions\")\nval_count=Counter(vocabulary)\nval_count","ab96756f":"#Visualise the top 30 occuring words in the captions\nmost_occur = val_count.most_common(30)\nprint(most_occur)","4a0a4bf2":"df_word = pd.DataFrame.from_dict(val_count, orient = 'index')\ndf_word = df_word.sort_values(by = [0], ascending=False).reset_index()\ndf_word = df_word.rename(columns={'index':'word', 0:'count'})\n\ndf_word.head()","b46c3ba8":"#Visualise the top 30 occuring words in the captions\ndef get_top_words_based_on_cnt(words_dict,n_words):\n    n_words+=1\n    keys=list(words_dict.keys())\n    values=list(words_dict.values())\n    sorted_values=sorted(values,reverse=True)[:n_words]\n    sorted_keys=[]\n    for i in sorted_values:\n        if sorted_values.count(i)==1:\n            sorted_keys.append(keys[values.index(i)])\n        elif sorted_values.count(i)==2:\n            f_idx=values.index(i)\n            s_idx=values[f_idx+1:].index(i)\n            s_idx+=f_idx+1\n            a,b=keys[f_idx],keys[s_idx]\n            if a not in sorted_keys and b not in sorted_keys:\n                sorted_keys.append(a)\n                sorted_keys.append(b)\n    plt.figure(figsize=(10,6))\n    sns.barplot(x=sorted_keys,y=sorted_values)\n    plt.xticks(rotation=60)\n    plt.show()\n    #write your code here\nget_top_words_based_on_cnt(val_count,30)","cbebb25b":"#Create a list which contains all the captions\nannotations=df.Captions.apply(lambda z:\"<start>\"+\" \"+z+\" \"+\"<end>\")\n\n#add the <start> & <end> token to all those captions as well\n\n\n#Create a list which contains all the path to the images\nall_img_path=df.Path.to_list()#write your code here\n\nprint(\"Total captions present in the dataset: \"+ str(len(annotations)))\nprint(\"Total images present in the dataset: \" + str(len(all_img_path)))","a683cda0":"# create the tokenizer\n## oov_token - out of vacabulary\ntop_word_cnt = 5000\nspecial_chars = '!\"#$%&()*+.,-\/:;=?@[\\]^_`{|}~ '\ntokenizer = tf.keras.preprocessing.text.Tokenizer(num_words=top_word_cnt,\n                                                  oov_token=\"<unk>\",\n                                                  filters=special_chars)\ntokenizer.fit_on_texts(annotations)\ntrain_seqs = tokenizer.texts_to_sequences(annotations)","753915c9":"train_seqs[:10]","72c2218a":"annotations[:10]","081e307d":"# Create word-to-index and index-to-word mappings.\ntokenizer.word_index['<pad>'] = 0\ntokenizer.index_word[0] = '<pad>'\ntrain_seqs = tokenizer.texts_to_sequences(annotations)","fe3c73ea":"tokenizer.word_counts","6b548986":"# Create a word count of your tokenizer to visulize the Top 30 occuring words after text processing\nget_top_words_based_on_cnt(tokenizer.word_counts,30)","ec469378":"max_len = max([len(cap) for cap in train_seqs])\nprint(\"shape of caption vector: \", len(train_seqs))\nprint(\"Maximum length of sequence: \",max_len)","f078c415":"# Pad each vector to the max_length of the captions ^ store it to a vairable\n## Padding - Pad before(\"pre\") or after(\"post\") each sequence.\ncap_vector= tf.keras.preprocessing.sequence.pad_sequences(train_seqs,\n                                                          padding='post',\n                                                          maxlen=max_len)\n\nprint(\"The shape of Caption vector is :\" + str(cap_vector.shape))","7c35da0b":"cap_vector","192d8671":"#write your code here\ndef preprocess_image(image_path, shape = (299, 299)):\n    image = tf.io.read_file(image_path)\n    image = tf.image.decode_jpeg(image,channels=3)\n    image = tf.image.resize(image,shape)\n    image = tf.keras.applications.inception_v3.preprocess_input(image)\n    return image, image_path","33f90fc4":"print(\"Shape after resize :\", preprocess_image(all_img_path[0])[0].shape)\nplt.imshow(preprocess_image(all_img_path[0])[0])","fd452cfb":"encode_train_set = sorted(set(all_img_vector))\n\nimage_dataset = tf.data.Dataset.from_tensor_slices(encode_train_set)\nimage_dataset = image_dataset.map(preprocess_image, num_parallel_calls=tf.data.experimental.AUTOTUNE).batch(32)\nimage_dataset","1680ba41":"# train-test split\nimage_train, image_test, caption_train, caption_test = train_test_split(all_img_vector,cap_vector,\n                                                                        test_size=0.2,random_state=42)","484936e4":"print(\"Training data for images: \" + str(len(image_train)))\nprint(\"Testing data for images: \" + str(len(image_test)))\nprint(\"Training data for Captions: \" + str(len(caption_train)))\nprint(\"Testing data for Captions: \" + str(len(caption_test)))","5298cc4a":"sample_img_batch, sample_cap_batch = next(iter(image_dataset))\nprint(sample_img_batch.shape) #(batch_size, 299, 299, 3)\nprint(sample_cap_batch.shape) #(batch_size, max_len)","e3d67239":"image_model = tf.keras.applications.InceptionV3(include_top=False,weights='imagenet')\n\nimage_model = tf.keras.applications.InceptionV3(include_top=False,weights='imagenet')\n\nnew_input = image_model.input  # get the input of the image_model\nhidden_layer = image_model.layers[-1].output  # get the output of the image_model\n\nimage_features_extract_model = keras.Model(new_input, hidden_layer)  # build the final model using both input & output layer","a29324af":"image_features_extract_model.summary()","2b3d41c9":"plot_model(image_model, to_file='image_model.png',show_shapes=True)","a7edba72":"# write your code to extract features from each image in the dataset\nfeature_dict = {}\nfor image,path in tqdm(image_dataset):\n    batch_features = image_features_extract_model(image)\n    batch_features = tf.reshape(batch_features,(batch_features.shape[0], -1, batch_features.shape[3]))\n    for batch_f, p in zip(batch_features, path):\n        path_of_feature = p.numpy().decode(\"utf-8\")\n        feature_dict[path_of_feature] =  batch_f.numpy()","94dd4be0":"batch_f.shape","e8ef5cce":"# Create a function which maps the image path to their feature. \n# This function will take the image_path & caption and return it's feature & respective caption.\ndef map_function(image_name,capt):\n    image_tensor = feature_dict[image_name.decode('utf-8')]\n    return image_tensor,capt","f627c486":"## Prefetch can be used to decouple the time when data is produced from the time when data is consumed.\n\nBATCH_SIZE = 32\nBUFFER_SIZE = 1000\ndef generate_dataset(images_data, captions_data):\n    \n    dataset = tf.data.Dataset.from_tensor_slices((images_data, captions_data))\n    dataset = dataset.shuffle(BUFFER_SIZE)\n\n    dataset = dataset.map(lambda item1, item2: tf.numpy_function(\n          map_function, [item1, item2], [tf.float32, tf.int32]),\n          num_parallel_calls=tf.data.experimental.AUTOTUNE).batch(BATCH_SIZE)\n\n\n    dataset = dataset.prefetch(buffer_size=tf.data.experimental.AUTOTUNE)\n    return dataset","1ea15cbd":"train_dataset=generate_dataset(image_train,caption_train)\ntest_dataset=generate_dataset(image_test,caption_test)","fc67a353":"sample_img_batch, sample_cap_batch = next(iter(train_dataset))\nprint(sample_img_batch.shape)  #(batch_size, 8*8, 2048)\nprint(sample_cap_batch.shape) #(batch_size,40)","67cbc58e":"BATCH_SIZE = 32\nembedding_dim = 256 \nunits = 512\nvocab_size = 5001 #top 5,000 words +1\ntrain_num_steps = len(image_train) \/\/ BATCH_SIZE\ntest_num_steps = len(image_test) \/\/ BATCH_SIZE\n","7c6a5ea1":"class Encoder(Model):\n    def __init__(self,embed_dim):\n        super(Encoder, self).__init__()\n        self.dense = tf.keras.layers.Dense(embed_dim)\n        self.dropout = tf.keras.layers.Dropout(0.5) ## Taking dropouts as 0.5\n        \n    def call(self, features):\n        # extract the features from the image shape: (batch, 8*8, embed_dim)\n        features =  self.dense(features) \n        features = tf.nn.relu(features)\n        \n        return features","97cb23f7":"encoder=Encoder(embedding_dim)","86db2ac3":"class Attention_model(Model):\n    def __init__(self, units):\n        super(Attention_model, self).__init__()\n        self.W1 = tf.keras.layers.Dense(units)\n        self.W2 = tf.keras.layers.Dense(units) #build your Dense layer\n        self.V = tf.keras.layers.Dense(1) #build your final Dense layer with unit 1\n        self.units=units\n\n    def call(self, features, hidden):\n        #features shape: (batch_size, 8*8, embedding_dim)\n        # hidden shape: (batch_size, hidden_size)\n        hidden_with_time_axis = tf.expand_dims(hidden, 1) # Expand the hidden shape to shape: (batch_size, 1, hidden_size)\n        score = tf.keras.activations.tanh(self.W1(features) + self.W2(hidden_with_time_axis)) # build your score funciton to shape: (batch_size, 8*8, units)\n        attention_weights =  tf.keras.activations.softmax(self.V(score), axis=1) # extract your attention weights with shape: (batch_size, 8*8, 1)\n        context_vector = attention_weights * features #shape: create the context vector with shape (batch_size, 8*8,embedding_dim)\n        context_vector = tf.reduce_sum(context_vector, axis = 1) # reduce the shape to (batch_size, embedding_dim)\n        \n\n        return context_vector, attention_weights","3805194c":"## Defining a GRU Decoder without dropouts\nclass RNN_Decoder(Model):\n    def __init__(self, embedding_dim, units, vocab_size):\n\n        super(RNN_Decoder, self).__init__()\n        self.units = units\n\n        self.embedding = layers.Embedding(vocab_size, embedding_dim)\n        self.gru = layers.GRU(self.units,\n                                   return_sequences=True,\n                                   return_state=True,\n                                   recurrent_initializer='glorot_uniform')\n        \n        self.fc1 = layers.Dense(self.units)\n        self.fc2 = layers.Dense(vocab_size)\n\n        self.attention = Attention_model(self.units)\n\n    def call(self, x, features, hidden):\n    # defining attention as a separate model\n        context_vector, attention_weights = self.attention(features, hidden)\n\n    # x shape after passing through embedding == (batch_size, 1, embedding_dim)\n        x = self.embedding(x)\n\n    # x shape after concatenation == (batch_size, 1, embedding_dim + hidden_size)\n        x = tf.concat([tf.expand_dims(context_vector, 1), x], axis=-1)\n\n    # passing the concatenated vector to the GRU\n        output, state = self.gru(x)\n\n    # shape == (batch_size, max_length, hidden_size)\n        x = self.fc1(output)\n\n    # x shape == (batch_size * max_length, hidden_size)\n        x = tf.reshape(x, (-1, x.shape[2]))\n\n    # output shape == (batch_size * max_length, vocab)\n        x = self.fc2(x)\n\n        return x, state, attention_weights\n\n    def init_state(self, batch_size):\n        return tf.zeros((batch_size, self.units))","53e489e7":"class Decoder(Model):\n    def __init__(self, embed_dim, units, vocab_size):\n        super(Decoder, self).__init__()\n        self.units=units\n        self.attention = Attention_model(self.units) #iniitalise your Attention model with units\n        self.embed = tf.keras.layers.Embedding(vocab_size, embed_dim, mask_zero =  False) #build your Embedding layer\n        self.gru = tf.keras.layers.GRU(self.units,\n                                       return_sequences=True,\n                                       return_state=True,\n                                       recurrent_initializer='glorot_uniform')\n        self.d1 = tf.keras.layers.Dense(self.units) #build your Dense layer\n        self.d2 = tf.keras.layers.Dense(vocab_size) #build your Dense layer\n        self.dropout = tf.keras.layers.Dropout(0.5)\n        \n\n    def call(self,x,features, hidden):\n        context_vector, attention_weights = self.attention(features, hidden) #create your context vector & attention weights from attention model\n        embed =  self.dropout(self.embed(x)) # embed your input to shape: (batch_size, 1, embedding_dim)\n        mask = self.embed.compute_mask(x)\n        embed = tf.concat([tf.expand_dims(context_vector, 1), embed], axis=-1) # Concatenate your input with the context vector from attention layer. Shape: (batch_size, 1, embedding_dim + embedding_dim)\n        output,state = self.gru(embed, mask = mask) # Extract the output & hidden state from GRU layer. Output shape : (batch_size, max_length, hidden_size)\n        output = self.d1(output)\n        output = tf.reshape(output, (-1, output.shape[2])) # shape : (batch_size * max_length, hidden_size)\n        output = self.d2(output) # shape : (batch_size * max_length, vocab_size)\n        \n        return output,state, attention_weights\n    \n    def init_state(self, batch_size):\n        return tf.zeros((batch_size, self.units))","83a590c2":"decoder=Decoder(embedding_dim, units, vocab_size)","aa2b56e7":"features=encoder(sample_img_batch)\n\nhidden = decoder.init_state(batch_size=sample_cap_batch.shape[0])\ndec_input = tf.expand_dims([tokenizer.word_index['<start>']] * sample_cap_batch.shape[0], 1)\n\npredictions, hidden_out, attention_weights= decoder(dec_input, features, hidden)\nprint('Feature shape from Encoder: {}'.format(features.shape)) #(batch, 8*8, embed_dim)\nprint('Predcitions shape from Decoder: {}'.format(predictions.shape)) #(batch,vocab_size)\nprint('Attention weights shape from Decoder: {}'.format(attention_weights.shape)) #(batch, 8*8, embed_dim)","a359ca35":"optimizer = tf.keras.optimizers.RMSprop() #define the optimizer\nloss_object = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True, reduction='none') #define your loss object","eecb445a":"def loss_function(real, pred):\n    mask = tf.math.logical_not(tf.math.equal(real, 0))\n    loss_ = loss_object(real, pred)\n\n    mask = tf.cast(mask, dtype=loss_.dtype)\n    loss_ *= mask\n\n    return tf.reduce_mean(loss_)","449259d0":"checkpoint_path = \".\/CHECKPOINTS\/train\"\nckpt = tf.train.Checkpoint(encoder=encoder,\n                           decoder=decoder,\n                           optimizer = optimizer)\nckpt_manager = tf.train.CheckpointManager(ckpt, checkpoint_path, max_to_keep=5)","1960f863":"start_epoch = 0\nif ckpt_manager.latest_checkpoint:\n    start_epoch = int(ckpt_manager.latest_checkpoint.split('-')[-1])","4225322e":"@tf.function\ndef train_step(img_tensor, target):\n    loss = 0\n    hidden = decoder.init_state(batch_size=target.shape[0])\n    dec_input = tf.expand_dims([tokenizer.word_index['<start>']] * target.shape[0], 1)\n    \n    with tf.GradientTape() as tape:\n        features = encoder(img_tensor)\n        for i in range(1, target.shape[1]):\n            predictions, hidden, _ = decoder(dec_input, features, hidden)\n            loss += loss_function(target[:, i], predictions)\n            dec_input = tf.expand_dims(target[:, i], 1)\n        avg_loss = (loss\/int(target.shape[1]))\n        trainable_variables = encoder.trainable_variables + decoder.trainable_variables\n        gradients = tape.gradient(loss, trainable_variables)\n        optimizer.apply_gradients(zip(gradients, trainable_variables))\n        \n    return loss, avg_loss","6b617950":"@tf.function\ndef test_step(img_tensor, target):\n    loss = 0\n    hidden = decoder.init_state(batch_size=target.shape[0])\n    dec_input = tf.expand_dims([tokenizer.word_index['<start>']] * target.shape[0], 1)\n\n    with tf.GradientTape() as tape:\n        features = encoder(img_tensor)\n\n        for i in range(1, target.shape[1]):\n            predictions, hidden, _ = decoder(dec_input, features, hidden)\n            loss += loss_function(target[:, i], predictions)\n            dec_input = tf.expand_dims(target[:, i], 1)\n\n        avg_loss = (loss \/ int(target.shape[1]))\n\n        trainable_variables = encoder.trainable_variables + decoder.trainable_variables\n        gradients = tape.gradient(loss, trainable_variables)\n        optimizer.apply_gradients(zip(gradients, trainable_variables))\n        \n    return loss, avg_loss","30c949ac":"def test_loss_cal(test_dataset):\n    total_loss = 0\n    \n    total_loss = 0\n    for (batch, (img_tensor, target)) in enumerate(test_dataset):\n        batch_loss, t_loss = test_step(img_tensor, target)\n        total_loss += t_loss\n    avg_test_loss=total_loss\/test_num_steps\n    \n    return avg_test_loss","924a5314":"loss_plot = []\ntest_loss_plot = []\nEPOCHS = 50\n\nbest_test_loss=100\nfor epoch in tqdm(range(0, EPOCHS)):\n    start = time.time()\n    total_loss = 0\n\n    for (batch, (img_tensor, target)) in enumerate(train_dataset):\n        batch_loss, t_loss = train_step(img_tensor, target)\n        total_loss += t_loss\n        avg_train_loss=total_loss \/ train_num_steps\n        \n    loss_plot.append(avg_train_loss)    \n    test_loss = test_loss_cal(test_dataset)\n    test_loss_plot.append(test_loss)\n    \n    print ('For epoch: {}, the train loss is {:.3f}, & test loss is {:.3f}'.format(epoch+1,avg_train_loss,test_loss))\n    print ('Time taken for 1 epoch {} sec\\n'.format(time.time() - start))\n    \n    if test_loss < best_test_loss:\n        print('Test loss has been reduced from %.3f to %.3f' % (best_test_loss, test_loss))\n        best_test_loss = test_loss\n        ckpt_manager.save()","8c50f695":"plt.plot(loss_plot)\nplt.plot(test_loss_plot)\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.title('Loss Plot')\nplt.legend([\"Train\", \"Test\"], loc =\"best\")\nplt.show()","653ffc9c":"def evaluate(image):\n    max_length=max_len\n    attention_plot = np.zeros((max_length, attention_features_shape))\n\n    hidden = decoder.init_state(batch_size=1)\n\n    temp_input = tf.expand_dims(preprocess_image(image)[0], 0) #process the input image to desired format before extracting features\n    img_tensor_val = image_features_extract_model(temp_input)\n    img_tensor_val = tf.reshape(img_tensor_val, (img_tensor_val.shape[0], -1, img_tensor_val.shape[3]))\n\n    features = encoder(img_tensor_val)\n\n    dec_input = tf.expand_dims([tokenizer.word_index['<start>']], 0)\n    result = []\n\n    for i in range(max_length):\n        predictions, hidden, attention_weights = decoder(dec_input, features, hidden)\n\n        attention_plot[i] = tf.reshape(attention_weights, (-1, )).numpy()\n\n        predicted_id = tf.argmax(predictions[0]).numpy()\n        result.append(tokenizer.index_word[predicted_id])\n\n        if tokenizer.index_word[predicted_id] == '<end>':\n            return result, attention_plot,predictions\n\n        dec_input = tf.expand_dims([predicted_id], 0)\n\n    attention_plot = attention_plot[:len(result), :]\n    return result, attention_plot,predictions","57ce7200":"def beam_evaluate(image, beam_index = 3):\n    max_length=max_len\n    start = [tokenizer.word_index['<start>']]\n    result = [[start, 0.0]]\n\n    attention_plot = np.zeros((max_length, attention_features_shape))\n\n    hidden = decoder.init_state(batch_size=1)\n\n    temp_input = tf.expand_dims(preprocess_image(image)[0], 0)\n    img_tensor_val = image_features_extract_model(temp_input)\n    img_tensor_val = tf.reshape(img_tensor_val, (img_tensor_val.shape[0], -1, img_tensor_val.shape[3]))\n\n    features = encoder(img_tensor_val)\n\n    dec_input = tf.expand_dims([tokenizer.word_index['<start>']], 0)\n\n    while len(result[0][0]) < max_length:\n        i=0\n        temp = []\n        for s in result:\n            predictions, hidden, attention_weights = decoder(dec_input, features, hidden)\n            attention_plot[i] = tf.reshape(attention_weights, (-1, )).numpy()\n            i=i+1\n            word_preds = np.argsort(predictions[0])[-beam_index:]\n          \n            for w in word_preds:\n                next_cap, prob = s[0][:], s[1]\n                next_cap.append(w)\n            \n                prob += np.log(predictions[0][w])\n                    \n                temp.append([next_cap, prob])\n        result = temp\n        result = sorted(result, reverse=False, key=lambda l: l[1])\n        result = result[-beam_index:]\n        \n        \n        predicted_id = result[-1]\n        pred_list = predicted_id[0]\n        \n        prd_id = pred_list[-1] \n        if(prd_id!=3):\n            dec_input = tf.expand_dims([prd_id], 0)  \n        else:\n            break\n    \n    \n    result2 = result[-1][0]\n    \n    intermediate_caption = [tokenizer.index_word[i] for i in result2]\n    final_caption = []\n    for i in intermediate_caption:\n        if i != '<end>':\n            final_caption.append(i)\n            \n        else:\n            break\n\n    attention_plot = attention_plot[:len(result), :]\n    final_caption = ' '.join(final_caption[1:])\n    return final_caption","8c3d200e":"def plot_attmap(caption, weights, image):\n\n    fig = plt.figure(figsize=(10, 10))\n    temp_img = np.array(Image.open(image))\n    \n    len_cap = len(caption)\n    for cap in range(len_cap):\n        weights_img = np.reshape(weights[cap], (8,8))\n        weights_img = np.array(Image.fromarray(weights_img).resize((224, 224), Image.LANCZOS))\n        \n        ax = fig.add_subplot(len_cap\/\/2, len_cap\/\/2, cap+1)\n        ax.set_title(caption[cap], fontsize=15)\n        \n        img=ax.imshow(temp_img)\n        \n        ax.imshow(weights_img, cmap='gist_heat', alpha=0.6,extent=img.get_extent())\n        ax.axis('off')\n    plt.subplots_adjust(hspace=0.2, wspace=0.2)\n    plt.show()","90c6d43e":"from nltk.translate.bleu_score import sentence_bleu","aa2a655f":"def filt_text(text):\n    filt=['<start>','<unk>','<end>'] \n    temp= text.split()\n    [temp.remove(j) for k in filt for j in temp if k==j]\n    text=' '.join(temp)\n    return text","6b81471a":"features_shape = batch_f.shape[1]\nattention_features_shape = batch_f.shape[0]","7bb1bed4":"rid = np.random.randint(0, len(image_test))\nprint(rid)\ntest_image = image_test[rid]\n\nreal_caption = ' '.join([tokenizer.index_word[i] for i in caption_test[rid] if i not in [0]])\nresult, attention_plot,pred_test = evaluate(test_image)\n\n\nreal_caption=filt_text(real_caption)      \n\n\npred_caption=' '.join(result).rsplit(' ', 1)[0]\n\nreal_appn = []\nreal_appn.append(real_caption.split())\nreference = real_appn\ncandidate = pred_caption.split()\n\nscore = sentence_bleu(reference, candidate, weights=(0.25, 0.25, 0.25, 0.25))\nprint(f\"BELU score: {score*100}\")\n\nprint('Real Caption:', real_caption)\nprint('Prediction Caption:', pred_caption)\nplot_attmap(result, attention_plot, test_image)\n\n\nImage.open(test_image)","eaf8586d":"print ('Real Caption      :', real_caption)\nprint ('Prediction Caption:', pred_caption)\n\nscore1 = sentence_bleu(reference, candidate, weights=(1,0,0,0))\nscore2 = sentence_bleu(reference, candidate, weights=(0,1,0,0))\nscore3 = sentence_bleu(reference, candidate, weights=(0,0,1,0))\nscore4 = sentence_bleu(reference, candidate, weights=(0,0,0,1))\n\nprint(\"\\nBELU score: \")\nprint(f\"Individual 1-gram: {score1*100}\")\nprint(f\"Individual 2-gram: {score2*100}\")\nprint(f\"Individual 3-gram: {score3*100}\")\nprint(f\"Individual 4-gram: {score4*100}\")","e28919ed":"score1 = sentence_bleu(reference, candidate, weights=(1,0,0,0))\nscore2 = sentence_bleu(reference, candidate, weights=(0.5, 0.5, 0, 0))\nscore3 = sentence_bleu(reference, candidate, weights=(0.33,0.33,0.33,0))\nscore4 = sentence_bleu(reference, candidate, weights=(0.25,0.25,0.25,0.25))\n\nprint(f\"BELU score: \")\nprint(f\"Cumumlative 1-gram: {score1*100}\")\nprint(f\"Cumumlative 2-gram: {score2*100}\")\nprint(f\"Cumumlative 3-gram: {score3*100}\")\nprint(f\"Cumumlative 4-gram: {score4*100}\")","b9486d85":"## Evaluation Using Beam Search\ncaptions=beam_evaluate(test_image)\nprint(captions)","07377220":"# install required library\n!pip install gTTS","6dd4b9b1":"# Import the required module for text to speech conversion\nfrom gtts import gTTS\n# Importing display \nfrom IPython import display\n\n# Language in which you want to convert\nlanguage = 'en'\n  \n# Passing the text and language to the engine, \nmyobj = gTTS(text=pred_caption, lang=language, slow=False)\n  \n# Saving the converted audio in a mp3 file named\nmyobj.save(\"Predicted_caption.mp3\")\n  \n# Playing the converted file\n#os.system(\".\/Predicted_caption.mp3\")\nsound_file = 'Predicted_caption.mp3'\ndisplay.display(display.Audio(sound_file))","f611650f":"# converting text-to-speach using beam_search\ntts = gTTS(captions, slow = False)\ntts.save('beam_caption.mp3')\n\nsound_file = 'beam_caption.mp3'\ndisplay.display(display.Audio(sound_file))","99ee7b5b":"## Testing the same Image Before Using Adam Optimizer with 15 epochs.","1be59fb0":"df.info()","13c46550":"df.loc[df['Path'].isin(['\/kaggle\/input\/flickr8k\/Images\/3551170666_01df31412d.jpg'])]","60c39aec":"rid_1 = np.random.randint(0, len(image_test))\nprint(rid_1)\ntest_image_1 = image_test[rid_1]\n\n## 3551003620_0b02d76f65.jpg\ntest_image_1 = '\/kaggle\/input\/flickr8k\/Images\/3551170666_01df31412d.jpg'\nreal_caption_1 = '<start> a golden retriever nurses puppies <end>'\nresult, attention_plot,pred_test = evaluate(test_image_1)\n\n\nreal_caption=filt_text(real_caption_1)      \n\n\npred_caption=' '.join(result).rsplit(' ', 1)[0]\n\nreal_appn_1 = []\nreal_appn_1.append(real_caption.split())\nreference = real_appn_1\ncandidate = pred_caption.split()\n\nscore = sentence_bleu(reference, candidate, weights=(0.25, 0.25, 0.25, 0.25))\nprint(f\"BELU score: {score*100}\")\n\nprint('Real Caption:', real_caption)\nprint('Prediction Caption:', pred_caption)\nplot_attmap(result, attention_plot, test_image)\n\n\nImage.open(test_image_1)","d4aaacab":"### Beam Search(optional)","d643cb5e":"## Converting Text to Speech","ca1d3a11":"### Encoder","65427166":"## Pre-processing the images\n\n1.Resize them into the shape of (299, 299)\n\n3.Normalize the image within the range of -1 to 1, such that it is in correct format for InceptionV3.","c7b0a396":"Let's read the dataset","7893e1cc":"### 3.Create word-to-index and index-to-word mappings.","16bc3218":"### Greedy Search","3a849af4":"### 5.Visualise the top 30 occuring words in the captions","eb8d2cc3":"Create a dataframe which summarizes the image, path & captions as a dataframe\n\nEach image id has 5 captions associated with it therefore the total dataset should have 40455 samples.","403db960":"### 2.Visualise both the images & text present in the dataset","b48024d5":"## Model training & optimization\n1.Set the optimizer & loss object\n\n2.Create your checkpoint path\n\n3.Create your training & testing step functions\n\n4.Create your loss function for the test dataset","32517a6b":"### 6.Create a list which contains all the captions & path","f45a67f4":"### Decoder","f0cb3797":"## Model Building\n1.Set the parameters\n\n2.Build the Encoder, Attention model & Decoder","6259c38b":"## Data Understanding\n    1.Import the dataset and read image & captions into two seperate variables\n    2.Visualise both the images & text present in the dataset\n    3.Create word-to-index and index-to-word mappings.\n    4.Create a dataframe which summarizes the image, path & captions as a dataframe\n    5.Visualise the top 30 occuring words in the captions\n    6.Create a list which contains all the captions & path","f7cb62d9":"## Dataset Creation\n\n1.Combine both images & captions to create the train & test dataset using tf.data.Dataset API. Create the train-test spliit using 80-20 ratio & random state = 42\n\n2.Make sure you have done Shuffle and batch while building the dataset\n\n3.The shape of each image in the dataset after building should be (batch_size, 299, 299, 3)\n\n4.The shape of each caption in the dataset after building should be(batch_size, max_len)","e853cc41":"### 1.Import the dataset and read image & captions into two seperate variables","76a860e3":"* While creating the test step for your model, you will pass your previous prediciton as the next input to the decoder.","4b867208":"## Pre-Processing the captions\n1.Create the tokenized vectors by tokenizing the captions fore ex :split them using spaces & other filters. \nThis gives us a vocabulary of all of the unique words in the data. Keep the total vocaublary to top 5,000 words for saving memory.\n\n2.Replace all other words with the unknown token \"UNK\" .\n\n3.Create word-to-index and index-to-word mappings.\n\n4.Pad all sequences to be the same length as the longest one.","d31b9c8b":"### 4.Create a dataframe which summarizes the image, path & captions as a dataframe","85c0748d":"### Attention model","463acde6":"## Load the pretrained Imagenet weights of Inception net V3\n\n1.To save the memory(RAM) from getting exhausted, extract the features of thei mage using the last layer of pre-trained model. Including this as part of training will lead to higher computational time.\n\n2.The shape of the output of this layer is 8x8x2048. \n\n3.Use a function to extract the features of each image in the train & test dataset such that the shape of each image should be (batch_size, 8*8, 2048)","a3313e2d":"## Model Evaluation\n\n1.Define your evaluation function using greedy search\n\n2.Define your evaluation function using beam search ( optional)\n\n3.Test it on a sample data using BLEU score","3ec72816":"* While creating the training step for your model, you will apply Teacher forcing.\n* Teacher forcing is a technique where the target\/real word is passed as the next input to the decoder instead of previous prediciton."}}