{"cell_type":{"982a983b":"code","a530e32a":"code","9ddc170c":"code","580344ac":"code","bc70e67b":"code","cb8fcec2":"code","25d0f27d":"code","9d6a253a":"code","66feca74":"code","64a88797":"code","eb06944b":"code","b03ccb56":"code","b1827abb":"code","96708361":"code","c764abc2":"code","e4cdb283":"code","37603916":"code","99200cf9":"code","890942a2":"code","5bfc0847":"code","81e43dd6":"markdown","7b1c419c":"markdown","53f97be2":"markdown","c2fd75bc":"markdown","f0076637":"markdown","5ff50b21":"markdown","25581fe9":"markdown"},"source":{"982a983b":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport datetime\nimport random\nimport operator\nimport math\n\n\nfrom collections import defaultdict\n\n\nfrom sklearn import datasets\nfrom sklearn.datasets import make_blobs\n\n# ignoring warnings\nimport warnings\nwarnings.simplefilter(\"ignore\")\n\nimport os, cv2, json\n\n\nnp.random.seed(42)","a530e32a":"WORK_DIR='..\/input\/spectf\/'\nos.listdir(WORK_DIR)","9ddc170c":"test=pd.read_csv(os.path.join(WORK_DIR,\"SPECTF_test.csv\"))\ntest","580344ac":"target_values = test['Class'].copy()\ntest.drop('Class', axis=1, inplace=True, errors=\"ignore\")\n","bc70e67b":"target_values","cb8fcec2":"test","25d0f27d":"X=test\ny=target_values","9d6a253a":"clusters=len(np.unique(y))","66feca74":"X=X.values","64a88797":"X","eb06944b":"class_yes=[]\nclass_no=[]\n\ndata=X.tolist()\ny\nfor i in range(len(y)):\n    if(y[i]=='Yes'):\n        class_yes.append(data[i])\n    elif(y[i]=='No'):\n        class_no.append(data[i])","b03ccb56":"X\n","b1827abb":"y","96708361":"class_yes","c764abc2":"def euclidean_distance(point1,point2):\n    dis=0\n    for i in range(len(point1)):\n        dis+=(point1[i]-point2[i])**2\n    return dis**0.5","e4cdb283":"# utility values\nm=2\nn=len(test)\nc=2\np=len(data[0])\nmax_iter=100\n","37603916":"def initialize_membership_matrix(n,c):\n    member_mat=list()\n    for i in range(n):\n        random_list=[random.random() for x in range(c)]\n        summation=sum(random_list)\n        for i in range(len(random_list)):\n            random_list[i]=random_list[i]\/summation\n        member_mat.append(random_list)\n    return member_mat\n\ndef update_centroid(member_mat):\n    centroids={}\n\n    for j in range(c):\n        temp=[]\n        for k in range(p):\n            \n            add=0\n            for i in range(n):\n                add+=member_mat[i][j]**m\n            x=0\n            for i in range(n):\n                x+=(member_mat[i][j]**m)*(data[i][k])\n            val=x\/add\n            temp.append(val)\n        centroids[j]=temp\n    return centroids\n\ndef update_membership_matrix(member_mat,centroids):\n    ratio=float(2\/(m-1))\n\n    for i in range(n):\n        distances=list()\n        for j in range(c):\n            distances.append(euclidean_distance(data[i],centroids[j]))\n        for j in range(c):\n            den = sum([math.pow(float(distances[j]\/distances[q]), ratio) for q in range(c)])\n            member_mat[i][j] = float(1\/den) \n           \n            \n    return member_mat\n        \n                \n    \ndef find_cluster(member_mat):\n    clusters=list()\n    for i in range(n):\n        max_val, idx = max((val, idx) for (idx, val) in enumerate(member_mat[i]))\n        clusters.append(idx)\n    return clusters\n\ndef check(old_member_mat,member_mat):\n    diff=0\n    for i in range(n):\n        for j in range(c):\n            diff+=old_member_mat[i][j]-member_mat[i][j]\n    if(diff<0.01):\n        return True\n    return False\n\ndef fuzzy_c_mean():\n    \n    member_mat=initialize_membership_matrix(n,c)\n\n\n    for i in range(max_iter):\n        centroids=update_centroid(member_mat)\n        old_member_mat=member_mat\n        member_mat=update_membership_matrix(member_mat,centroids)\n        cluster=find_cluster(member_mat)\n   \n\n    return cluster,centroids\n\n\n\n\n        \n          ","99200cf9":"clusters,centroids=fuzzy_c_mean()\nprint(\"Final Centroid points are:\")\nprint(centroids)\n","890942a2":"def confusion_matrix(clusters,y):\n    c_matrix=[[0 for i in range(2)] for j in range(2)]\n    tp = [0, 0]\n    tn = [0, 0]\n    fp = [0, 0]\n    fn = [0, 0]\n    for i in range(len(y)):\n        if clusters[i] == 1 and y[i] == 'Yes':\n            tp[0] = tp[0] + 1\n        if clusters[i] == 0 and y[i] == 'No':\n            tn[0] = tn[0] + 1\n        if clusters[i] == 1 and y[i] == 'No':\n            fp[0] = fp[0] + 1\n        if clusters[i] == 0 and y[i] == 'Yes':\n            fn[0] = fn[0] + 1\n        \n    for i in range(len(y)):\n        \n        if clusters[i] == 0 and y[i] == 'Yes':\n            tp[1] = tp[1] + 1\n        if clusters[i] == 1 and y[i] == 'No':\n            tn[1] = tn[1] + 1\n        if clusters[i] == 0 and y[i] == 'No':\n            fp[1] = fp[1] + 1\n        if clusters[i] == 1 and y[i] == 'Yes':\n            fn[1] = fn[1] + 1\n      \n    x=max((tp[0]+tn[0]),(tp[1]+tn[1]))\n    if x==tp[0]+tn[0]:\n            c_matrix[0][0]=tp[0]\n            c_matrix[1][1]=tn[0]\n            c_matrix[0][1]=fn[0]\n            c_matrix[1][0]=fp[0]\n            return c_matrix\n    else:\n            c_matrix[0][0]=tp[1]\n            c_matrix[1][1]=tn[1]\n            c_matrix[0][1]=fn[1]\n            c_matrix[1][0]=fp[1]\n            return c_matrix\n\n\n# performance metrics\n            \nclass Metrics:\n    \n    def __init__(self,confusion_m):\n        self.confusion_m=confusion_m\n        self.total=np.sum(confusion_m)\n        self.diagonal=np.sum(np.diag(confusion_m))\n    \n    def accuracy(self):\n        accuracy=(self.diagonal\/self.total)\n        return accuracy\n    \n    def recall(self):\n        recall=np.diag(self.confusion_m)\/np.sum(self.confusion_m,axis=1)\n        recall=np.mean(recall)\n        return recall\n    \n    def precision(self):\n        precision=np.diag(self.confusion_m)\/np.sum(self.confusion_m,axis=0)\n        precision=np.mean(precision)\n        return precision\n    \n    def f1_score(self,precision,recall):\n        f1_score=(2*precision*recall)\/(precision+recall)\n        \n        return f1_score\n","5bfc0847":"matrix=confusion_matrix(clusters,y)\nperformance=Metrics(matrix)\n\naccuracy=performance.accuracy()\nrecall=performance.recall()\nprecision=performance.precision()\nf1_score=performance.f1_score(precision,recall)\n\nprint('confusion matrix is:',end='\\n')\nprint(np.array(matrix),end='\\n')\n\nprint(\"Accuracy of the model is {}\".format(accuracy*100))\nprint(\"Recall of the model is {}\".format(recall*100))\nprint(\"Precision of the model is {}\".format(precision*100))\nprint(\"F1-Score of the model is {}\".format(f1_score*100))","81e43dd6":"> # load the dataset","7b1c419c":"# Function to calculate euclidean distance","53f97be2":"# performance metrics","c2fd75bc":"# fuzzyCmeans Implementation from scratch on cardiac spectf imaging dataset","f0076637":"# prediction","5ff50b21":"# confusion matrix","25581fe9":"# fuzzyCMeans Implementation"}}