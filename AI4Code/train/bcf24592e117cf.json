{"cell_type":{"9a8ca0e5":"code","6ad0d5cc":"code","dc330ec8":"markdown","6407ee5b":"markdown","18a7f466":"markdown","19c7f2cf":"markdown"},"source":{"9a8ca0e5":"import numpy as np\n# get \ud835\udf03\ud835\udc59 (Counter clockwise is positive)\ndef get_alpha(rot):\n  # output: (Batch, 8) [bin1_cls[0], bin1_cls[1], bin1_sin, bin1_cos, \n  #                     bin2_cls[0], bin2_cls[1], bin2_sin, bin2_cos]\n  # return rot[:, 0]\n    idx = rot[:, 1] > rot[:, 5]\n    \n    # alpha1 is relative to -90\u00ba\n    alpha1 = np.arctan(rot[:, 2] \/ rot[:, 3]) + (-0.5 * np.pi)\n    \n    # alpha2 is relative to +90\u00ba\n    alpha2 = np.arctan(rot[:, 6] \/ rot[:, 7]) + ( 0.5 * np.pi)\n    \n    return alpha1 * idx + alpha2 * (1 - idx)","6ad0d5cc":"# you need to do some finetune to get real \ud835\udf03ray\n# np.arctan2(x, z)","dc330ec8":"**If you think it's useful, please give me an upvote, thanks.**","6407ee5b":"![1](https:\/\/img-blog.csdnimg.cn\/20190608110711257.jpg?x-oss-process=image\/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NDYyODQ5,size_16,color_FFFFFF,t_70)","18a7f466":"# 2 - \n**Apparently it's easier to learn the orientation as a classification problem (eg. is the object facing forward\/backward) then finetune the angle within the classified orientation than it is to just regress the angle.**\n\n**Centernet splits the orientation angle in two overlapping 240\u00ba bins centered at -90\u00ba and 90\u00ba. **\n\n**For each bin, two scalars + softmax are used to predict if the angle falls into the bin, then two more scalars are used to encode the angle as sin(angle) and cos(angle).**\n\n**thanks for your explanation @ Prof.Bacterio**","19c7f2cf":"## 1 - \n**Because predicting the local orientation (\ud835\udf03\ud835\udc59) is better than predicting global (\ud835\udf03) directly******\n\n**We let the \ud835\udf03 = \ud835\udf03\ud835\udc59 +  \ud835\udf03**ray"}}