{"cell_type":{"f4ade77c":"code","e8d95adf":"code","d18d99b4":"code","9b9badde":"code","71f63700":"code","df4a26fc":"code","21f10e1b":"markdown","17874319":"markdown","9bf7d9cd":"markdown","4765b451":"markdown","9dea4d11":"markdown","3fb3f758":"markdown"},"source":{"f4ade77c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","e8d95adf":"from kaggle_environments import evaluate, make, utils\n\nenv = make(\"connectx\", debug=True)\nenv.render()","d18d99b4":"def my_agent(observation, configuration):\n    \n    import numpy as np\n    max_depth = 4\n    \n    def check_win(bord):\n        for y in range(bord.shape[0]):\n            for x in range(bord.shape[1]):\n                # right direction\n                if x+3 < bord.shape[1] and bord[y, x] != 0:\n                    if bord[y, x  ] == bord[y, x+1] and \\\n                       bord[y, x+1] == bord[y, x+2] and \\\n                       bord[y, x+2] == bord[y, x+3]:\n                        return bord[y, x]\n                # upward\n                if y+3 < bord.shape[0] and bord[y, x] != 0:\n                    if bord[y  , x] == bord[y+1, x] and \\\n                       bord[y+1, x] == bord[y+2, x] and \\\n                       bord[y+2, x] == bord[y+3, x]:\n                        return bord[y, x]\n                # upper right diagonal\n                if x+3 < bord.shape[1] and y+3 < bord.shape[0] and bord[y, x] != 0:\n                    if bord[y  , x  ] == bord[y+1, x+1] and \\\n                       bord[y+1, x+1] == bord[y+2, x+2] and \\\n                       bord[y+2, x+2] == bord[y+3, x+3]:\n                        return bord[y, x]\n                # lower right diagonal\n                if x+3 < bord.shape[1] and y+3 < bord.shape[0] and bord[y+3, x] != 0:\n                    if bord[y+3, x  ] == bord[y+2, x+1] and \\\n                       bord[y+2, x+1] == bord[y+1, x+2] and \\\n                       bord[y+1, x+2] == bord[y  , x+3]:\n                        return bord[y+3, x]\n        return 0\n    \n    def make_score(bord):\n        \"\"\"\n        If the game does not advance to the conclusion even after calculating up to max_depth, \n        a score is obtained from the board. Here, the score is simply set to be advantageous \n        to the side where the stones are gathered.\n        \"\"\"\n        d = np.where(bord == 1)\n        s = -np.std(d[1])\n        if d[0].shape[0] > 0:\n            mx, my = np.mean(d[0]), np.mean(d[1])\n            s -= np.std([np.sqrt(((x-mx)*(x-mx))+((y-my)*(y-my))) for x, y in zip(d[0], d[1])])\n        d = np.where(bord == 2)\n        s += np.std(d[1])\n        if d[0].shape[0] > 0:\n            mx, my = np.mean(d[0]), np.mean(d[1])\n            s += np.std([np.sqrt(((x-mx)*(x-mx))+((y-my)*(y-my))) for x, y in zip(d[0], d[1])])\n        return s\n    \n    def drop_one(c, b, stack_bord):\n        nonlocal configuration\n        bord = stack_bord.copy()\n        d = np.where(bord[:,c] != 0)[0]\n        p = bord.shape[0] if d.shape[0] == 0 else min(d)\n        if p == 0:\n            return None\n        else:\n            bord[p-1,c] = b\n            return bord\n        \n    def grow_tree(selection, tree, depth, current_bord, b):\n        nonlocal configuration, max_depth\n        if depth >= max_depth:\n            return\n        w = check_win(current_bord)\n        if w != 0:\n            s = np.inf if b == 2 else -np.inf\n        else:\n            s = make_score(current_bord)\n        leaf = {'root':tree,'selection':selection,'bord':current_bord,'score':s,'next':[]}\n        tree['next'].append(leaf)\n        if w != 0:\n            return\n        k = 1 if b==2 else 2\n        for i in range(configuration.columns):\n            t = drop_one(i, b, current_bord)\n            if t is not None:\n                grow_tree(i, leaf, depth+1, t, k)\n    \n    game_tree = {'next':[]}\n    current_bord = np.array(observation['board'], dtype=np.uint8).reshape((6,7))\n    if observation.mark == 2:\n        # Decide that I am 1\n        current_bord[current_bord==2] = 255\n        current_bord[current_bord==1] = 2\n        current_bord[current_bord==255] = 1\n    grow_tree(0, game_tree, 0, current_bord, 1)\n    game_tree = game_tree['next'][0]\n    \n    def minmax(b, tree):\n        nonlocal configuration, max_depth\n        if len(tree['next']) == 0:\n            return tree\n        if b == 2:\n            #return sorted(tree['next'], key=lambda x: minmax(1, x)['score'])[0]\n            return sorted(tree['next'], key=lambda x: -minmax(1, x)['score'])[0]\n        else:\n            #return sorted(tree['next'], key=lambda x: -(minmax(2, x)['score']))[0]\n            return sorted(tree['next'], key=lambda x: (minmax(2, x)['score']))[0]\n    r = minmax(1, game_tree)\n    while r['root'] != game_tree:\n        r = r['root']    \n    return r['selection']","9b9badde":"def mean_reward(rewards):\n    return sum(r[0] for r in rewards) \/ sum(r[0] + r[1] for r in rewards)\nprint(\"My Agent vs Random Agent: \", mean_reward(evaluate(\"connectx\", [my_agent, \"random\"], num_episodes=10)))\nprint(\"My Agent vs Negamax Agent:\", mean_reward(evaluate(\"connectx\", [my_agent, \"negamax\"], num_episodes=10)))","71f63700":"#env.play([my_agent, None], width=500, height=450)","df4a26fc":"import inspect\nimport os\n\ndef write_agent_to_file(function, file):\n    with open(file, \"a\" if os.path.exists(file) else \"w\") as f:\n        f.write(inspect.getsource(function))\n        print(function, \"written to\", file)\n\nwrite_agent_to_file(my_agent, \"submission_weakest_1.py\")","21f10e1b":"# Create ConnectX environments","17874319":"# Create an agent (https:\/\/www.kaggle.com\/tanreinama\/simple-game-tree-max-depth-4)","9bf7d9cd":"# Install kaggle environments","4765b451":"# Run the agent","9dea4d11":"# Play the agent","3fb3f758":"# Write Submission File"}}