{"cell_type":{"61998a73":"code","aff894a9":"code","41c1afe1":"code","0f8ac3e7":"code","c6161a6d":"code","210b0320":"code","65f85806":"code","3ddc40d8":"code","aeb9496e":"code","45a77095":"code","f3640d5d":"code","a3cb0de5":"markdown","814774b1":"markdown","00e47747":"markdown"},"source":{"61998a73":"import numpy as np\nimport pandas as pd\nimport random as rd\nimport struct\nfrom PIL import Image","aff894a9":"def readMNISTdata(ubyte_file, status):\n    with open(ubyte_file, 'rb') as f:\n        buf = f.read()\n    offset = 0\n\n    if status == 'data':\n        magic, imageNum, rows, cols = struct.unpack_from('>IIII', buf, offset)\n        offset += struct.calcsize('>IIII')\n        imageSize = rows * cols\n        images = np.empty((imageNum,imageSize))\n        fmt = '>' + str(imageSize) + 'B'\n        for i in range(imageNum):\n            images[i] = np.array(struct.unpack_from(fmt, buf, offset))\n            offset += struct.calcsize(fmt)\n        return images\n    elif status == 'label':\n        magic, LabelNum = struct.unpack_from('>II', buf, offset)\n        offset += struct.calcsize('>II')\n        Labels = np.zeros((LabelNum))\n        for i in range(LabelNum):\n            Labels[i] = np.array(struct.unpack_from('>B', buf, offset))\n            offset += struct.calcsize('>B')\n        return Labels\n    else: return -1","41c1afe1":"train_images = readMNISTdata('..\/input\/train-images-idx3-ubyte','data')\ntrain_labels = readMNISTdata('..\/input\/train-labels-idx1-ubyte','label')\ntest_images =  readMNISTdata('..\/input\/t10k-images-idx3-ubyte','data')\ntest_labels = readMNISTdata('..\/input\/t10k-labels-idx1-ubyte','label')","0f8ac3e7":"train_ind = np.arange(0,60000)\nrd.shuffle(train_ind)\ntest_ind = np.arange(0,10000)\nrd.shuffle(test_ind)\ntrain_size = 500\ntest_size = 500\ntrain_images = train_images[train_ind[0:train_size],...]\ntrain_labels = train_labels[train_ind[0:train_size]]\ntest_images = test_images[test_ind[0:test_size],...]\ntest_labels = test_labels[test_ind[0:test_size]]","c6161a6d":"def Euc_distance(x,y):\n    dist = np.linalg.norm(x-y)\n    return dist","210b0320":"def Man_distance(x,y):\n    dist = np.linalg.norm(x-y, ord=1)\n    return dist","65f85806":"def Cos_distance(x,y):\n    dist = np.dot(x,y)\/np.linalg.norm(x)\/np.linalg.norm(y)\n    return dist","3ddc40d8":"def KNN(train_images, train_labels, test_images, test_labels):\n    train_size = train_labels.size\n    test_size = test_labels.size\n    count = 0\n    distance = np.zeros(train_size)\n    for i in range(test_size):\n        for j in range(train_size):\n            distance[j] = Euc_distance(test_images[i,...],train_images[j,...])\n        index = np.argsort(distance)\n        predict = train_labels[index[0]]\n        if predict == test_labels[i]:\n            count = count + 1\n    acc = count \/ test_size\n    return acc","aeb9496e":"def KNN_tangent(train_images, train_labels, test_images, test_labels):\n    train_size = train_labels.size\n    test_size = test_labels.size\n    count = 0\n    learning_rate = 6e-7\n    training_epochs = 50\n    for i in range(test_size):\n        # Unit vector for each test point\n        #Tr=np.zeros((784,3))\n        pattern = test_images[i,...].reshape((28,28))\n        pattern_x = np.hstack((np.zeros((28,1)),pattern[...,0:27]))\n        pattern_y = np.vstack((pattern[1:,...],np.zeros((1,28))))\n        #Rotate the image by 3 degrees\n        img = pattern.astype(np.uint8)\n        img = Image.fromarray(img)\n        pattern_r = np.array(img.rotate(3))\n        Tr = np.hstack((pattern_x.reshape((784,1))-test_images[i,...].reshape((784,1)), \\\n                              pattern_y.reshape((784,1))-test_images[i,...].reshape((784,1)), \\\n                              pattern_r.reshape((784,1))-test_images[i,...].reshape((784,1))))\n        # Tangent distance\n        distances = np.zeros(train_size)\n        for j in range(train_size):\n            alpha = np.zeros((3,1))\n            # Gradient descent\n            for ite in range(training_epochs):\n                alpha = alpha - learning_rate*np.matmul(Tr.T,(test_images[i,...].reshape((784,1))+np.matmul(Tr,alpha)-train_images[j,...].reshape((784,1))))\n            distances[j] = Euc_distance(test_images[i,...].T+np.matmul(Tr,alpha), train_images[j,...].T)\n        index = np.argsort(distances)\n        predict = train_labels[index[0]]\n        if predict == test_labels[i]:\n            count = count + 1\n    acc = count \/ test_size\n    return acc","45a77095":"acc = KNN(train_images, train_labels, test_images, test_labels)\nprint(acc)","f3640d5d":"acc = KNN_tangent(train_images,train_labels,test_images,test_labels)\nprint(acc)","a3cb0de5":"Read data from the original data file. The image data and label data have different format.","814774b1":"Define different metrics of distance:","00e47747":">  Original dataset: http:\/\/yann.lecun.com\/exdb\/mnist\/"}}