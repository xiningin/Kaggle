{"cell_type":{"bb4ba30c":"code","239a79d7":"code","fc78de5f":"code","9fb25cde":"code","24b47515":"code","58316445":"code","106b4931":"code","fd0a41b4":"code","182be48e":"code","b0638101":"code","599d35cd":"code","3fdc294f":"code","421432ab":"code","fec350ee":"code","9289deae":"code","c8d4cba6":"code","d46eb7f4":"code","de551eb1":"code","95225e55":"code","9be655ab":"code","18c9f958":"code","1274bcb8":"code","66f3c8fa":"code","17c1694b":"code","af062c8d":"code","1df1781c":"code","26ac307f":"code","dc287a0c":"code","f3bf081b":"code","fdbbcdd4":"code","4e623ba9":"code","ecb9f478":"code","9b1cf6c6":"code","09d8c557":"code","36f6bbcd":"code","a6ad750f":"code","1bd49d9a":"code","d583989e":"markdown","16d15c90":"markdown","0e07792f":"markdown","9d60baee":"markdown","d2b25670":"markdown","ec42c1ed":"markdown","d05407a4":"markdown","d17d1627":"markdown","439edbe9":"markdown","cf78235c":"markdown","2b3a9f76":"markdown","237cb404":"markdown","0f6d0bbe":"markdown","84cbbfbe":"markdown","b302d41d":"markdown","77cd1428":"markdown","8a27a77f":"markdown","0b34f5de":"markdown"},"source":{"bb4ba30c":"# importing modules\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport missingno as msno\nfrom imblearn.over_sampling import SMOTE\nimport warnings\nwarnings.filterwarnings(action=\"ignore\")\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom lightgbm import LGBMClassifier\nfrom xgboost import XGBClassifier\nfrom sklearn.metrics import accuracy_score, confusion_matrix,classification_report,roc_curve, roc_auc_score","239a79d7":"df = pd.read_csv(\"\/kaggle\/input\/weather-dataset-rattle-package\/weatherAUS.csv\")\ndf.head()","fc78de5f":"# Info of data\ndf.info()","9fb25cde":"# shape of data:\nprint(f'Number of columns: { df.shape[0]} and Number of rows: {df.shape[1]}')","24b47515":"# Checking for null values\ndf.isna().sum()","58316445":"# statistical info of dataset\ndf.describe().T","106b4931":"# Identifying Continuous and Categorical Columns\ncategory=[]\ncontin = []\n\nfor i in df.columns:\n    if df[i].dtype ==\"object\":\n        category.append(i)\n        \n    else:\n        contin.append(i)\n\nprint(\"Categorical:\",category)\nprint(\"Continuous:\", contin)","fd0a41b4":"msno.matrix(df)","182be48e":"msno.heatmap(df)","b0638101":"df.head()","599d35cd":"df['RainTomorrow'] = df['RainTomorrow'].map({'Yes': 1, 'No': 0})\ndf['RainToday'] = df['RainToday'].map({'Yes': 1, 'No': 0})","3fdc294f":"df[\"RainToday\"].unique()\ndf[\"RainTomorrow\"].unique()","421432ab":"from sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()","fec350ee":"df[[\"RainToday\",\"RainTomorrow\"]]","9289deae":"(df.isnull().sum()\/len(df))*100","c8d4cba6":"df.head().T","d46eb7f4":"df.columns","de551eb1":"# filling the missing values for continuous variables with mean\ndf[\"MinTemp\"]= df[\"MinTemp\"].fillna(df[\"MinTemp\"].mean())\ndf[\"MaxTemp\"]= df[\"MaxTemp\"].fillna(df[\"MaxTemp\"].mean())\ndf[\"Evaporation\"]= df[\"Evaporation\"].fillna(df[\"Evaporation\"].mean())\ndf[\"Sunshine\"]= df[\"Sunshine\"].fillna(df[\"Sunshine\"].mean())\ndf[\"WindGustSpeed\"]= df[\"WindGustSpeed\"].fillna(df[\"WindGustSpeed\"].mean())\ndf[\"Rainfall\"]= df[\"Rainfall\"].fillna(df[\"Rainfall\"].mean())\ndf[\"WindSpeed9am\"]= df[\"WindSpeed9am\"].fillna(df[\"WindSpeed9am\"].mean())\ndf[\"WindSpeed3pm\"]= df[\"WindSpeed3pm\"].fillna(df[\"WindSpeed3pm\"].mean())\ndf[\"Humidity9am\"]= df[\"Humidity9am\"].fillna(df[\"Humidity9am\"].mean())\ndf[\"Humidity3pm\"]= df[\"Humidity3pm\"].fillna(df[\"Humidity3pm\"].mean())\ndf[\"Pressure9am\"]= df[\"Pressure9am\"].fillna(df[\"Pressure9am\"].mean())\ndf[\"Pressure3pm\"]= df[\"Pressure3pm\"].fillna(df[\"Pressure3pm\"].mean())\ndf[\"Cloud9am\"]= df[\"Cloud9am\"].fillna(df[\"Cloud9am\"].mean())\ndf[\"Cloud3pm\"]= df[\"Cloud3pm\"].fillna(df[\"Cloud3pm\"].mean())\ndf[\"Temp9am\"]= df[\"Temp9am\"].fillna(df[\"Temp9am\"].mean())\ndf[\"Temp3pm\"]= df[\"Temp3pm\"].fillna(df[\"Temp3pm\"].mean())","95225e55":"#Filling the missing values for continuous variables with mode\ndf['RainToday']=df['RainToday'].fillna(df['RainToday'].mode()[0])\ndf['RainTomorrow']=df['RainTomorrow'].fillna(df['RainTomorrow'].mode()[0])\ndf['WindDir9am'] = df['WindDir9am'].fillna(df['WindDir9am'].mode()[0])\ndf['WindGustDir'] = df['WindGustDir'].fillna(df['WindGustDir'].mode()[0])\ndf['WindDir3pm'] = df['WindDir3pm'].fillna(df['WindDir3pm'].mode()[0])","9be655ab":"df.head()","18c9f958":"# again checking for null values\n(df.isnull().sum()\/len(df))*100","1274bcb8":"fig, ax =plt.subplots(1,2)\nplt.figure(figsize=(8,5))\nsns.countplot(df[\"RainToday\"],ax=ax[0])\nsns.countplot(df[\"RainTomorrow\"],ax = ax[1])","66f3c8fa":"#heatmap\nplt.figure(figsize=(18,12))\nsns.heatmap(df.corr(), annot=True)\nplt.xticks(rotation=90)\nplt.show()","17c1694b":"#encoding remaining columns\ndf[\"Location\"] = le.fit_transform(df[\"Location\"])\ndf[\"WindDir9am\"]= le.fit_transform(df[\"WindDir9am\"])\ndf[\"WindDir3pm\"]= le.fit_transform(df[\"WindDir3pm\"])\ndf[\"WindGustDir\"] = le.fit_transform(df[\"WindGustDir\"])","af062c8d":"df.head()","1df1781c":"# Dropping highly correlated columns\ndf=df.drop(['Temp3pm','Temp9am','Humidity9am',\"Date\"],axis=1)\ndf.columns","26ac307f":"from collections import Counter\nos = SMOTE()\nx, y = os.fit_resample(df.iloc[:,:-1], df.iloc[:,-1])\ncount = Counter(y)\nprint(count)","dc287a0c":"X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)","f3bf081b":"xgbc = XGBClassifier(objective='binary:logistic')\nxgbc.fit(X_train,y_train)","fdbbcdd4":"# accuracy of XGBoost Model\ny_predxgb = xgbc.predict(X_test)\nreport = classification_report(y_test, y_predxgb)\nprint(report)\nprint(\"Accuracy of the XGBoost Model is:\",accuracy_score(y_test,y_predxgb)*100,\"%\")\ncm = confusion_matrix(y_test, y_predxgb)\nsns.heatmap(cm, annot=True,cmap=\"YlGnBu\")\nplt.title(\"Confusion Matrix for XGBoost Model\")\nplt.show()","4e623ba9":"lightgbmc = LGBMClassifier(n_estimators=500,max_depth=6)\nlightgbmc.fit(X_train, y_train)","ecb9f478":"# accuracy of LightGBM Model\ny_pred = lightgbmc.predict(X_test)\nreport2 = classification_report(y_test, y_pred)\nprint(report2)\nprint(\"Accuracy of the LightGBM Model is:\",accuracy_score(y_test,y_pred)*100,\"%\")\ncm2 = confusion_matrix(y_test, y_pred)\nsns.heatmap(cm2, annot=True,cmap=\"Blues\")\nplt.title(\"Confusion Matrix for LightGBM Model\")\nplt.show()","9b1cf6c6":"classifier = RandomForestClassifier(n_estimators=300) # increasing number of trees for better accuracy\nclassifier.fit(X_train, y_train)","09d8c557":"# accuracy of Random Forest Classifier Model\ny_pred2 = classifier.predict(X_test)\nreport3 = classification_report(y_test, y_pred2)\nprint(report3)\nprint(\"Accuracy of the Random Forest Model is:\",accuracy_score(y_test,y_pred2)*100,\"%\")\ncm3 = confusion_matrix(y_test, y_pred2)\nsns.heatmap(cm3, annot=True)\nplt.title(\"Confusion Matrix for Random Forest Classifier Model\")\nplt.show()","36f6bbcd":"y_pred_proba = classifier.predict_proba(X_test)\npos_proba = y_pred_proba[:,1]","a6ad750f":"fpr, tpr, thresholds = roc_curve(y_test, pos_proba)\nplt.plot(fpr, tpr, '*-')\nplt.plot([0, 1], [0, 1], 'r--')\nplt.legend(['Logistic regression', 'Random chance'])\nplt.xlabel('FPR')\nplt.ylabel('TPR')\nplt.title('ROC curve for Random Forest Classifier')","1bd49d9a":"# this score helps in identifying efficiency of classifier\nroc_auc_score(y_test, pos_proba)","d583989e":"Author: Purvit Vashishtha","16d15c90":"**Inferences from Heatmap**:\n* MinTemp and Temp9am highly correlated.\n* MinTemp and Temp3pm highly correlated.\n* MaxTemp and Temp9am highly correlated.\n* MaxTemp and Temp3pm highly correlated.\n* Temp3pm and Temp9am highly correlated.\n* Humidity9am and Humidity3pm highly correlated.","0e07792f":"### XGBoost Model\n* XGBoost is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM) that solve many data science problems in a fast and accurate way.","9d60baee":"## ROC_AUC Score and Curve\n* The receiver operating characteristic (ROC) curve is a plot of the pairs of true positive rates (y-axis) and false positive rates (x-axis) that result from lowering the threshold down from 1, all the way to 0.","d2b25670":"### Handling Null values","ec42c1ed":"### Heatmap showing **Correlation** among attributes of data","d05407a4":"* Values closer to 1 in roc_auc_score shows that classifier is efficient and gives better performance.","d17d1627":"#### Visualizing **Missing values** in dataset","439edbe9":"### LightGBM Model\n* LightGBM is a gradient boosting framework that uses tree based learning algorithms. It is designed to be distributed and efficient with the following advantages:\n\n1. Faster training speed and higher efficiency.\n2. Lower memory usage.\n3. Better accuracy.\n4. Support of parallel and GPU learning.\n5. Capable of handling large-scale data.","cf78235c":"### Random Forest Classifier Model","2b3a9f76":"### Splitting data into Training and Testing Set","237cb404":"### **Countplot** for RainToday and Raintomorrow:","0f6d0bbe":"# Model Selection","84cbbfbe":"Percentage of **Null values in dataset**","b302d41d":"Please UPVOTE if you find this Notebook insightful.\n\nThanks in advance.","77cd1428":"**Encoding RainToday and RainTomorrow Columns** using LabelEncoder","8a27a77f":"### Importing Modules","0b34f5de":"### Importing Dataset"}}