{"cell_type":{"03f982a3":"code","2ecce123":"code","4da1fb80":"code","bb585587":"code","a76f004c":"code","7a764f82":"code","5182643b":"code","ee895b13":"code","0ae31b6f":"code","fcd3b234":"code","e0a75e36":"code","fd04a4e2":"code","af75ddcd":"code","01eaf76e":"code","19c45797":"code","a96c8c4e":"code","21c99dc8":"markdown","ee794b0c":"markdown","e13c8953":"markdown","3664df92":"markdown","647fe30c":"markdown","5a152e62":"markdown","986d3353":"markdown","aa2ca33c":"markdown","7e489b6a":"markdown","3d217489":"markdown","b5f73375":"markdown","5a160fc1":"markdown","3d1d4c87":"markdown","786c54d4":"markdown","30d73c40":"markdown"},"source":{"03f982a3":"!pip install git+https:\/\/github.com\/dstl\/Stone-Soup.git@e550d5cb5e6dd3086164e2ae4a2a1664eaf1867a#egg=stonesoup git+https:\/\/github.com\/sdhiscocks\/stonesoup-kaggle-drone-tracking.git@7e3b64135dff6c8c5fdfb559a5dd689d85f25acf#egg=stonesoup_kaggle_drone_tracking","2ecce123":"import datetime\nimport os\nfrom math import ceil\nfrom io import StringIO\n\nimport pandas as pd\nimport numpy as np\n\nfrom stonesoup.dataassociator.neighbour import GNNWith2DAssignment\nfrom stonesoup.deleter.error import CovarianceBasedDeleter\nfrom stonesoup.deleter.multi import CompositeDeleter\nfrom stonesoup.deleter.time import UpdateTimeDeleter\nfrom stonesoup.feeder.multi import MultiDataFeeder\nfrom stonesoup.feeder.time import TimeBufferedFeeder\nfrom stonesoup.hypothesiser.distance import DistanceHypothesiser\nfrom stonesoup.initiator.simple import MultiMeasurementInitiator\nfrom stonesoup.measures import Mahalanobis\nfrom stonesoup.models.transition.linear import CombinedLinearGaussianTransitionModel, ConstantVelocity\nfrom stonesoup.predictor.kalman import ExtendedKalmanPredictor\nfrom stonesoup.tracker.simple import MultiTargetTracker\nfrom stonesoup.types.array import StateVector, CovarianceMatrix\nfrom stonesoup.types.state import GaussianState\nfrom stonesoup.updater.kalman import ExtendedKalmanUpdater\n\n# Custom components created for this dataset\nfrom stonesoup.plugins.kaggle_drone.dejup_feeder import Uniqueificator\nfrom stonesoup.plugins.kaggle_drone.initiator import AlviraAndArcusInitiator\nfrom stonesoup.plugins.kaggle_drone.sensor_location_gater import SensorLocationGater\nfrom stonesoup.plugins.kaggle_drone.reader import DroneGroundTruthReader, ALVIRAReader, ARCUSReader, DIANAReader, VENUSReader\nfrom stonesoup.plugins.kaggle_drone.writer import write_output_csv, generate_timestamps, scenario_timestamps","4da1fb80":"scenario = \"\/kaggle\/input\/icmcis-drone-tracking\/icmcis-drone-detection (2)\/train\/train\/Scenario_1_1\/\"\n\narcus = ARCUSReader( # Elevation, bearing, range\n    scenario,\n    pos_noise_diag=[(np.pi\/4)**2, np.radians(1)**2, 25**2], vel_noise_diag=[1, 1, 1],\n    min_reflection=-25, max_reflection=-10,\n)\nalvira = ALVIRAReader( # Bearing, range\n    scenario,\n    pos_noise_diag=[np.radians(1)**2, 25**2], vel_noise_diag=[1, 1],\n    min_reflection=-np.inf, max_reflection=35,\n)\ndiana = DIANAReader( # Bearing, range\n    scenario,\n    pos_noise_diag=[np.radians(3)**2, 1000],\n)\nvenus = VENUSReader( # Bearing\n    scenario,\n    pos_noise_diag=[np.radians(3)**2],\n)\n\n# Use this for plotting later.\nsensor_positions = {\n    'arcus': arcus.model.model_list[0].translation_offset[[0, 1], 0],\n    'alvira': alvira.model.model_list[0].translation_offset[[0, 1], 0],\n    'diana': diana.model.translation_offset[[0, 1], 0],\n    'venus': venus.model.translation_offset[[0, 1], 0],\n}\n\n# Remove duplicates\narcus = Uniqueificator(arcus)\nalriva = Uniqueificator(alvira)\n\n# Buffer and sort; ensure input data in time order\narcus = TimeBufferedFeeder(arcus)\nalvira = TimeBufferedFeeder(alvira)\ndiana = TimeBufferedFeeder(diana)\nvenus = TimeBufferedFeeder(venus)\n\n# Combine into single stream of detections, in time order.\ndetector = MultiDataFeeder([alvira, arcus, diana, venus])","bb585587":"transition_model = CombinedLinearGaussianTransitionModel([ConstantVelocity(0.6)]*3)\npredictor = ExtendedKalmanPredictor(transition_model)","a76f004c":"updater = ExtendedKalmanUpdater(measurement_model=None)","7a764f82":"hypothesiser = DistanceHypothesiser(predictor, updater, measure=Mahalanobis(), missed_distance=4)\n\n# This is reducing missed distance to 2 units of Mahalanobis i.e. std. deviation, for initialisation\ninit_hypothesiser = DistanceHypothesiser(predictor, updater, measure=Mahalanobis(), missed_distance=2)\n\n# This will ignore sensor data when drone within min. distance. Avoids bad bearing\/elevation measurements\n# causing issues in particular with rapid changes in velocity.\nhypothesiser = SensorLocationGater(hypothesiser, min_distance_from_sensor=80)\ninit_hypothesiser = SensorLocationGater(init_hypothesiser, min_distance_from_sensor=80)\n\ndata_associator = GNNWith2DAssignment(hypothesiser)\ninit_data_associator = GNNWith2DAssignment(init_hypothesiser)","5182643b":"deleter = CompositeDeleter(\n    [\n        UpdateTimeDeleter(time_since_update=datetime.timedelta(seconds=30), delete_last_pred=True),\n         CovarianceBasedDeleter(covar_trace_thresh=5000, mapping=[0, 2], delete_last_pred=True),\n    ],\n    intersect=False)\n\n# More aggressive deletion when trying to initalise a track\ninit_deleter = CompositeDeleter(\n    [\n        UpdateTimeDeleter(time_since_update=datetime.timedelta(seconds=15), delete_last_pred=True),\n         CovarianceBasedDeleter(covar_trace_thresh=3000, mapping=[0, 2], delete_last_pred=True),\n    ],\n    intersect=False)","ee895b13":"prior = GaussianState([0, 0, 0, 0, 50, 0], np.diag([0, 0, 0, 0, 1000, 100]))\n\nbase_initiator = MultiMeasurementInitiator(\n    prior_state=prior,\n    measurement_model=None,\n    deleter=init_deleter,\n    data_associator=init_data_associator,\n    updater=updater,\n    min_points=6,\n)","0ae31b6f":"initiator = AlviraAndArcusInitiator(base_initiator)","fcd3b234":"tracker = MultiTargetTracker(\n    detector=detector,\n    initiator=initiator,\n    deleter=deleter,\n    data_associator=data_associator,\n    updater=updater,\n)","e0a75e36":"tracks = set()\ndetections = set()\nfor time, ctracks in tracker:\n    tracks |= ctracks\n    detections |= tracker.detector.detections\nlen(tracks)","fd04a4e2":"ground_truth_reader = DroneGroundTruthReader(scenario, \"2020\")\nground_truth = set()\nfor time, truths in ground_truth_reader:\n    ground_truth.update(truths)\n    \ngt_timestamps = {state.timestamp for truth in ground_truth for state in truth}","af75ddcd":"from stonesoup.plotter import Plotter\n\nplotter = Plotter()\nplotter.plot_ground_truths(ground_truth, [0, 2], color='black')\nplotter.plot_tracks(tracks, [0,2], uncertainty=True)\nfor name, position in sensor_positions.items():\n    plotter.ax.scatter(*position, label=name, marker='X')\n    plotter.ax.text(*position+20, name.title())\ntrack_xlim = plotter.ax.get_xlim()\ntrack_ylim = plotter.ax.get_ylim()","01eaf76e":"for sensor, color in {('Arcus', 'g'), ('Alvira', 'r')}:\n    plotter.plot_measurements(\n        {detection for detection in detections if detection.metadata['sensor'] == sensor}, [0, 2],\n        measurements_label=sensor, color=color, marker='.', zorder=10)\nplotter.fig","19c45797":"plotter.ax.set_xlim(track_xlim)\nplotter.ax.set_ylim(track_ylim)\nplotter.fig","a96c8c4e":"if not ground_truth: # Test\n    timestamps = scenario_timestamps[os.path.basename(scenario)]\nelse: # Train\n    timestamps = generate_timestamps(min(gt_timestamps).replace(microsecond=0), max(gt_timestamps))\noutput = StringIO() # use StringIO so we can use with Pandas to visualise, rather than write to disk\nwrite_output_csv(output, tracks, timestamps, min_track_points=20)\noutput.seek(0)\npd.read_csv(output)","21c99dc8":"Chaning limits to around tracks again.","ee794b0c":"Also read in ground truth data, if available.","e13c8953":"### Create Readers\n\nCreate readers to read in the detections. These readers also create the measurement models which are linked to each detection, and such we also define noise parameters of expcted model uncertainty. Additional feeders are also used to handle duplicates and ensuring data is yeilded in time order.\n\nThese readers convert input detections to elevation, bearing and range (as appropriate) in a Cartesian coordinate space of east, north, up\/altitude, relative to position of Diana sensor and 0 altitude (sea level). This is to better model the sensors' uncertainty.","3664df92":"### Create Track Initiators and Deleters\n\nThe deleters in this example will remove tracks where no detections have been associated for a period of time,\nor uncertainty in position has grown too large.","647fe30c":"### Create Predictor and Updater\n\nCreate our model used for prediction, using 3 CV models, making state space $ x, \\dot x, y, \\dot y, z, \\dot z $; where $x$ is east, $y$ is north, and $z$ is altitude.","5a152e62":"### Create Hypothesiser and Data Associator\n\nThis create hypothesier and data associator componets used for associating tracks and detections. Also create slightly stricter versions of these to limit track initiation.","986d3353":"We only want to use radar sensors, and this also limits to where radar classifies target as DRONE\/SUSPECTED_DRONE.","aa2ca33c":"Our initiator will use the detections position\/velocity from the radar for easting\/northing $x$\/$y$ (hence just leaving prior state vector and covariance `0` for those elements), but use a  prior value for altitude where Alvria 2D Radar initialises the track.","7e489b6a":"# Drone Tracking with Stone Soup\n\nThis notebook is looking at the [Kaggle Drone Identification and Tracking dataset](https:\/\/www.kaggle.com\/c\/icmcis-drone-tracking) using [Stone Soup](https:\/\/stonesoup.rtfd.io\/).\n\nThis example implements a base tracker with a set of standard components, as well as some [custom components](https:\/\/github.com\/sdhiscocks\/stonesoup-kaggle-drone-tracking) for the data set, and initial estimates of parameters. Different parameters, combinations of standard components and possibly additional custom compents, may wish to be considered to improve tracking performance.\n\nThis example focuses on the tracking element, with classification currently simply using the mode of associated detections from the tracking process.","3d217489":"And plot tracks (in different colours) with their associated uncertainty, against ground truth if available, and sensor locations.","b5f73375":"## Run Tracker and Plot Results","5a160fc1":"Create our updater. We won't define a model here, as we'll used the ones assigned to detections.","3d1d4c87":"## Create tracker\n### Imports","786c54d4":"And adding radar sensor detections to the plot. Note that these detections are ones filtered by the readers (min\/max reflection parameters).","30d73c40":"## Generate Output File\n\nThe output file includes interpolating tracks to specified timestamps (based on ground truth in this example), with classification\/identification simply using mode of associated detections from all sensors."}}