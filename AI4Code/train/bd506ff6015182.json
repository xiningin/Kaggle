{"cell_type":{"261f200f":"code","b81e2533":"code","3ce9155c":"code","00dd3e8d":"code","921fb766":"code","1796088b":"code","eeda0479":"code","da54446e":"code","fe43156c":"code","b72796d4":"code","eaa82bdf":"code","b7e3f8cd":"code","336b74c5":"code","c910ee3b":"code","dd1f6d47":"code","0dae76dc":"code","4c896256":"code","61d3f94f":"markdown","455106db":"markdown","163f2e6c":"markdown","47570e2d":"markdown","49f44d60":"markdown","95d13d85":"markdown","63b48e73":"markdown","a785bed2":"markdown","64b37a9d":"markdown","17625271":"markdown","ed073ef1":"markdown","0ea2665a":"markdown","64f0a611":"markdown"},"source":{"261f200f":"import numpy as np \nimport pandas as pd\nimport seaborn as sns\n\nimport matplotlib.pyplot as plt\n%matplotlib inline","b81e2533":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","3ce9155c":"df1 = pd.read_csv('..\/input\/tabular-playground-series-jun-2021\/train.csv')\ndf2 = pd.read_csv('..\/input\/tabular-playground-series-jun-2021\/test.csv')\nsam = pd.read_csv('..\/input\/tabular-playground-series-jun-2021\/sample_submission.csv')","00dd3e8d":"sub1 = pd.read_csv('..\/input\/1-tps-jun-21-histgradient-catboost-nn\/submission1.csv')\n# Public Score: 1.75770\n# HistGradientBoostingClassifier\n# display(sub1)","921fb766":"sub2 = pd.read_csv('..\/input\/1-tps-jun-21-histgradient-catboost-nn\/submission2.csv')\n# Public Score: 1.75011\n# CatBoostClassifier\n# display(sub2)","1796088b":"sub3 = pd.read_csv('..\/input\/1-tps-jun-21-histgradient-catboost-nn\/submission3.csv')\n# Public Score: 1.74587\n# Neural Networks\n# display(sub3)","eeda0479":"sub4 = pd.read_csv('..\/input\/1-tps-jun-21-histgradient-catboost-nn\/submission4.csv')\n# Public Score: 1.74522\n# tabular residual network\n# display(sub4)","da54446e":"sub5 = pd.read_csv('..\/input\/1-tps-jun-21-histgradient-catboost-nn\/submission5.csv')\n# Public Score: 1.74456\n# EDA + Models\n# display(sub5)","fe43156c":"sub6 = pd.read_csv('..\/input\/1-tps-jun-21-histgradient-catboost-nn\/submission6.csv')\n# Public Score: 1.74442\n# Residual network\n# display(sub6)","b72796d4":"def generate(main, support, coeff):\n    \n    g = main.copy()    \n    for i in main.columns[1:]:\n        \n        res = []\n        lm, Is = [], []        \n        lm = main[i].tolist()\n        ls = support[i].tolist()  \n        \n        for j in range(len(main)):\n            res.append((lm[j] * coeff) + (ls[j] * (1.- coeff)))            \n        g[i] = res\n        \n    return g","eaa82bdf":"sub = generate(sub2, sub1, 0.85)\n\nsub = generate(sub3, sub , 0.85)\n\nsub = generate(sub4, sub , 0.85)\n\nsub = generate(sub5, sub , 0.85)\n\nsub = generate(sub6, sub , 0.55)\n\nsub_ens = sub","b7e3f8cd":"display(sub_ens, sub_ens.describe().transpose())","336b74c5":"sub_ens.to_csv(\"submission_ens.csv\",index=False)\n# Public Score: 1.74415\n!ls","c910ee3b":"def improve(sub1, sub2, sub3, sub4, sub5, sub6, sub_ens, majority, m_majority):  \n    \n    sub1v = sub1.values\n    sub2v = sub2.values\n    sub3v = sub3.values\n    sub4v = sub4.values\n    sub5v = sub5.values \n    sub6v = sub6.values\n    \n    imp = sub_ens.copy()\n    impv = imp.values\n    NCLASS = 9\n    number = 0\n\n    for i in range (len(sub_ens)):\n        c_count = 0  \n        row = impv[i,1:]\n        row_sort = np.sort(row)        \n        \n        row1 = sub1v[i,1:]\n        row2 = sub2v[i,1:]\n        row3 = sub3v[i,1:]\n        row4 = sub4v[i,1:]\n        row5 = sub5v[i,1:]    \n        row6 = sub6v[i,1:] \n        row1_sort = np.sort(row1)\n        row2_sort = np.sort(row2)\n        row3_sort = np.sort(row3)\n        row4_sort = np.sort(row4)\n        row5_sort = np.sort(row5)\n        row6_sort = np.sort(row6)\n                      \n        for j in range (NCLASS): \n            count = 0\n            \n            for k in range (NCLASS):                \n                if (row6[j] == row6_sort[k]): \n                    \n                    if (row1[j] == row1_sort[k]):\n                        count = count + 1\n                    if (row2[j] == row2_sort[k]):\n                        count = count + 1                   \n                    if (row3[j] == row3_sort[k]):\n                        count = count + 1   \n                    if (row4[j] == row4_sort[k]):\n                        count = count + 1 \n                    if (row5[j] == row5_sort[k]):\n                        count = count + 1 \n                        \n            if (count >= majority):\n                c_count = c_count + 1\n        \n        if ((c_count >= m_majority) and (row6_sort[8] >= row_sort[8])): \n            impv[i, 1:] = row6            \n            number = number + 1            \n#           print (number, i, c_count)                         \n                    \n    imp.iloc[:, 1:] = impv[:, 1:]\n    p_number = round(((number \/ 100000) * 100),2)\n    print('>>>  R  E  T  U  R  N  S  <<<')\n    print(30 * '=')\n    print(f'Number of changes: {number}\\n')\n    print(f'Percentage of changes: {p_number} %')\n    print(30 * '=')\n    return imp      ","dd1f6d47":"sub_imp = improve(sub1, sub2, sub3, sub4, sub5, sub6, sub_ens, 5, 7)","0dae76dc":"display(sub_imp, sub_imp.describe().transpose())","4c896256":"sub_imp.to_csv(\"submission_imp.csv\",index=False)\n# Public Score: 1.74408\n!ls","61d3f94f":"Thanks to: @fusioncenter https:\/\/www.kaggle.com\/fusioncenter\/residual-network-for-tabular-data","455106db":"<div class=\"alert alert-success\">  \n<\/div>","163f2e6c":"## Description:\n\n#### In Kaggle challenges as well as real projects, we usually calculate the average (Weighted average) of the results of several different methods  to get a better score. This method is called \"Ensembling\" and is very common.\n\n#### **What does it mean if the new results get a better score? Did all the hundreds of thousands of rows get better results? Certainly not.**\n\n#### The fact is that only the results of some rows are better and the results of others are worse. However, we see that the overall result has improved.\n\n#### Here we want to identify rows whose new results are probably not better. Of course, after identifying these rows, we return the results to their pre-\"Ensembling\" state and we will see that by doing so, our score will be even better.\n\n#### We call this method \"Comparative Method\" and it is our initiative. The \"Comparative Method\" can be used for both regression and classifier. But of course there are differences in the way it is done on different issues.\n\n#### For more information, refer to the following address:\n\n#### https:\/\/www.kaggle.com\/c\/tabular-playground-series-jun-2021\/discussion\/246031\n","47570e2d":"<div class=\"alert alert-success\">  \n<\/div>","49f44d60":"## Import & Data Set","95d13d85":"<div class=\"alert alert-success\">  \n<\/div>","63b48e73":"Thanks to: @oxzplvifi https:\/\/www.kaggle.com\/oxzplvifi\/tabular-residual-network","a785bed2":"## Comparative Method for Classifier","64b37a9d":"Thanks to: @bhavikjain https:\/\/www.kaggle.com\/bhavikjain\/tps-june-21-eda-models","17625271":"## Ensembling","ed073ef1":"<div>\n    <h1 align=\"center\">Tabular Playground Series - Jun 2021<\/h1>\n    <h2 align=\"center\">Ensembling & Comparative Method for Classifier<\/h2>\n    <h4 align=\"center\">By: Somayyeh Gholami & Mehran Kazeminia<\/h4>\n<\/div>","0ea2665a":"<div class=\"alert alert-success\">  \n<\/div>","64f0a611":"<div class=\"alert alert-success\">\n    <h1 align=\"center\">If you find this work useful, please don't forget upvoting :)<\/h1>\n<\/div>"}}