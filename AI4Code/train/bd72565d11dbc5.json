{"cell_type":{"c11240cf":"code","46e42214":"code","0085345a":"code","e8c7fa53":"code","c83c24c6":"markdown","0d3d93a0":"markdown","f86e9585":"markdown","0ea6f5c6":"markdown","51cb8c24":"markdown","57824e14":"markdown","f8e951a9":"markdown","99eeaf62":"markdown","d602cb01":"markdown"},"source":{"c11240cf":"%%writefile submission.py\n\n# Imports helper functions\nfrom kaggle_environments.envs.halite.helpers import *\n\n# Directions a ship can move\ndirections = [ShipAction.NORTH, ShipAction.EAST, ShipAction.SOUTH, ShipAction.WEST]\n\ninit_Controller = False\n#controller = None","46e42214":"%%writefile -a submission.py\n\nclass Controller():\n        \n    def __init__(self, obs, config):\n        #Initialise Instance Independent Constants\n        self.size = config.size\n        # Will keep track of whether a ship is collecting halite or carrying cargo to a shipyard\n        self.ship_states = {}\n        self.ships_in_last_turn = []\n        \n    def next_actions(self, obs, config):\n        #Initialise Instance Specific Variables\n        self.board = Board(obs, config)\n        self.me = self.board.current_player\n        self.steps = self.board.step\n        self.ships = self.me.ships\n        self.shipyards = self.me.shipyards  \n\n        # If there are no ships, use first shipyard to spawn a ship.\n        if len(self.ships) == 0 and len(self.shipyards) > 0:\n            self.shipyards[0].next_action = ShipyardAction.SPAWN\n\n        # If there are no shipyards, convert first ship into shipyard.\n        if len(self.shipyards) == 0 and len(self.ships) > 0:\n            self.ships[0].next_action = ShipAction.CONVERT\n\n        for ship in self.ships:\n            if ship.id not in self.ships_in_last_turn:\n                print(\"New ship {} Added to {} in step : {}\".format(ship.id,self.ships_in_last_turn,self.steps))\n                self.ships_in_last_turn.append(ship.id)\n                \n            if ship.next_action == None:\n\n                ### Part 1: Set the ship's state \n                if ship.halite < 200: # If cargo is too low, collect halite\n                    self.ship_states[ship.id] = \"COLLECT\"\n                if ship.halite > 500: # If cargo gets very big, deposit halite\n                    self.ship_states[ship.id] = \"DEPOSIT\"\n\n                ### Part 2: Use the ship's state to select an action\n                if self.ship_states[ship.id] == \"COLLECT\":\n                    # If halite at current location running low, \n                    # move to the adjacent square containing the most halite\n                    if ship.cell.halite < 100:\n                        neighbors = [ship.cell.north.halite, ship.cell.east.halite, \n                                     ship.cell.south.halite, ship.cell.west.halite]\n                        best = max(range(len(neighbors)), key=neighbors.__getitem__)\n                        ship.next_action = directions[best]\n                if self.ship_states[ship.id] == \"DEPOSIT\":\n                    # Move towards shipyard to deposit cargo\n                    direction = self.getDirTo(ship.position, self.shipyards[0].position, self.size)\n                    if direction: ship.next_action = direction\n\n        return self.me.next_actions\n\n    # Returns best direction to move from one position (fromPos) to another (toPos)\n    # Example: If I'm at pos 0 and want to get to pos 55, which direction should I choose?\n    def getDirTo(self, fromPos, toPos, size):\n        fromX, fromY = divmod(fromPos[0],size), divmod(fromPos[1],size)\n        toX, toY = divmod(toPos[0],size), divmod(toPos[1],size)\n        if fromY < toY: return ShipAction.NORTH\n        if fromY > toY: return ShipAction.SOUTH\n        if fromX < toX: return ShipAction.EAST\n        if fromX > toX: return ShipAction.WEST","0085345a":"%%writefile -a submission.py\n\n# Returns the commands we send to our ships and shipyards\ndef agent(obs, config):\n    global init_Controller\n    global controller\n    if not init_Controller:\n        controller = Controller(obs, config) \n        init_Controller = True\n    return controller.next_actions(obs, config)   ","e8c7fa53":"from kaggle_environments import make\nenv = make(\"halite\", debug=True)\nenv.run([\"submission.py\", \"random\", \"random\", \"random\"])\nenv.render(mode=\"ipython\", width=800, height=600)","c83c24c6":"### Let's go ahead and implement our class. ","0d3d93a0":"### Lets define our agent with our class based controller implementation","f86e9585":"### Now we are ready to get our code up and running. Explore the leaderboard by replacing the class method with your own implementation of the agent.","0ea6f5c6":"### This notebook is for illustrative purposes and hence you are encouraged to modify the agent and climb up the leaderboard.","51cb8c24":"### A sample use case that is implemented here for illustrative purposes is to keep track of current player's ships between steps of the game. Whenever a ship is created it is added to the list and a message is displayed. Go ahead and modify to update list when a ship is deleted in a turn as well. Repeat the same for shipyards and you are good to go with a stateful Halite Bot in a class.","57824e14":"### You can model complex logics with you own classes modelled around actual scenarios to get effective, clean and readable code.","f8e951a9":"# Getting Started with Halite - Bot in a Class Boilerplate","99eeaf62":"### I believe that to harness the full power of object oriented programming paradigm, you need to structure your code as against procedural oriented programming paradigm. In this notebook, a scalable class based starter code is provided for Halite simulation that you can copy and modify to implement complex stateful logics in a structured manner.","d602cb01":"### Refer [Getting Started with Halite](https:\/\/www.kaggle.com\/alexisbcook\/getting-started-with-halite) for the agent implementation used in this notebook. "}}