{"cell_type":{"959e0249":"code","1212782d":"code","b2c59ea6":"code","9382a9b8":"code","2a3bd0bd":"code","5847d7c6":"code","3e4d270a":"code","3223ce60":"code","5e3f9f76":"code","bc8aeec1":"code","82c2ba71":"code","87b1476c":"code","a680539c":"code","9b2de40e":"code","d1cfe756":"code","0d2969c8":"code","26b60e36":"code","00888ec5":"code","3afae698":"code","92575059":"code","4e6b3370":"code","3429b7a8":"code","1ccaf8c5":"code","fe0fc4f2":"code","ec1ffa5c":"code","7ab63ff8":"code","d806c328":"code","a6347f21":"markdown","bd1f245a":"markdown","dfa76c1f":"markdown","75fa1fe6":"markdown","d8044b11":"markdown","37df51b6":"markdown","6597e876":"markdown","c9d50779":"markdown","e7984bf1":"markdown","2f683921":"markdown","7bf4d6e5":"markdown","5ee135ae":"markdown","f7942d08":"markdown","207f0ca5":"markdown","1f7fceca":"markdown","236c6bcb":"markdown"},"source":{"959e0249":"from IPython.display import Image\nImage(\"..\/input\/banner\/banner.png\")","1212782d":"import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt","b2c59ea6":"def prepro(img):\n    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\n    mask = np.zeros((gray.shape),np.uint8)\n    kernel1 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(11,11))\n\n    close = cv2.morphologyEx(gray,cv2.MORPH_CLOSE,kernel1)\n    div = np.float32(gray)\/(close)\n    res = np.uint8(cv2.normalize(div,div,0,255,cv2.NORM_MINMAX))\n    res2 = cv2.cvtColor(res,cv2.COLOR_GRAY2BGR)\n    plt.imshow(res2)\n    return res2, res, mask\n    ","9382a9b8":"m = cv2.imread(\"..\/input\/sample1\/s4.jpeg\")\nref = cv2.imread(\"..\/input\/sample1\/s4.jpeg\")\ndisplay(type(ref))\nref_g = cv2.cvtColor(ref,cv2.COLOR_BGR2GRAY)","2a3bd0bd":"mo, mg, mask = prepro(m)","5847d7c6":"plt.imshow(mask)","3e4d270a":"plt.imshow(mg)\n","3223ce60":"plt.imshow(ref_g)","5e3f9f76":"thresh = cv2.adaptiveThreshold(mg,255,0,1,19,2)\ncontour,hier = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)\nplt.imshow(thresh)\nmax_area = 0\nbest_cnt = None\nfor cnt in contour:\n    area = cv2.contourArea(cnt)\n    if area > 1000:\n        if area > max_area:\n            max_area = area\n            best_cnt = cnt\n\nt1 = cv2.drawContours(mask,[best_cnt],0,255,-1)\n\nt2 = cv2.drawContours(mask,[best_cnt],0,0,2)\n\n\nres = cv2.bitwise_and(mg,mask)","bc8aeec1":"plt.imshow(mask)","82c2ba71":"plt.imshow(res)","87b1476c":"type(best_cnt)","a680539c":"uwu = mo.copy()\nfor i in best_cnt:\n    #print(i[0])\n    cv2.circle(uwu,(i[0][0], i[0][1]), 5, (0,255,0), -1)\n    \nplt.imshow(uwu)","9b2de40e":"canny = cv2.Canny(mask, 120, 255, 1)\nplt.imshow(canny)","d1cfe756":"corners = cv2.goodFeaturesToTrack(canny,4,0.5,50)","0d2969c8":"uwu2 = mo.copy()\nfor corner in corners:\n    x,y = corner.ravel()\n    cv2.circle(uwu2,(x,y),5,(36,255,12),-1)\n    cv2.putText(uwu2,'{},{}'.format(int(x),int(y)),(x,y),2,2,(255,0,0))\n    print(x,y)\n\nplt.imshow(uwu2)","26b60e36":"pA = corners[0][0]\npB = corners[1][0]\npC = corners[2][0]\npD = corners[3][0]\n","00888ec5":"m.shape\nmH = m.shape[0]\nmW = m.shape[1]","3afae698":"Image(\"..\/input\/corners\/index2.png\")","92575059":"def closest_node(node, nodes):\n    nodes = np.asarray(nodes)\n    dist_2 = (nodes - node)**2\n    print(dist_2.reshape(4,2))\n    n = np.sum(dist_2.astype(\"int\"),axis=-1)\n\n    return np.argmin(n)\n","4e6b3370":"pA = corners[closest_node([0,0],corners)]\npB = corners[closest_node([0,mH-1],corners)]\npC = corners[closest_node([mW-1,mH-1],corners)]\npD = corners[closest_node([mW-1,0],corners)]","3429b7a8":"H = W = 252","1ccaf8c5":"output_pts = np.float32([[0, 0],\n                        [0, H - 1],\n                        [W - 1, H - 1],\n                        [W - 1, 0]])\n\n","fe0fc4f2":"input_pts = np.float32([pA, pB, pC, pD])","ec1ffa5c":"M = cv2.getPerspectiveTransform(input_pts,output_pts)","7ab63ff8":"out = cv2.warpPerspective(mo,M,(W, H),flags=cv2.INTER_LINEAR)","d806c328":"plt.imshow(out)","a6347f21":"## Find closest corner point.\n\n","bd1f245a":"## Extracted contour","dfa76c1f":"### In this guide, i'll be performing edge detection and wrap perspective methods on clicked sudoku image and extract the needed part.","75fa1fe6":"## Apply Contour to mask we created earlier.","d8044b11":"## Show points","37df51b6":"### Find all corner points using (cv2.goodFeaturesToTrack()) ","6597e876":"# Preprocessing\n\nIncludes morphology, normalization etc.","c9d50779":"## Contour Points","e7984bf1":"## Zero mask of same Image size (use np.zeros)","2f683921":"# Canny edge detection","7bf4d6e5":"# Wrap perspective\n\nprepare Input and Output points.","5ee135ae":"# Grayscale Output","f7942d08":"## Preprocessed Image","207f0ca5":"# Contour Detection\n\nWe will find all the contours in the image, and select the largest one which covers the Puzzle.","1f7fceca":"# Final Image","236c6bcb":"# Read Image"}}