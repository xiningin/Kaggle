{"cell_type":{"7e64aea4":"code","56b2ce77":"code","49dced7d":"code","a14d78a7":"code","acc88605":"code","2f4ec40b":"code","6e3ba0fa":"code","753649d6":"code","780a5efe":"code","d7eea693":"code","d5d08aba":"code","b2bb5233":"code","6b20bc8a":"code","cc77baf7":"code","f1762eb2":"code","46987b5e":"code","9e6c8420":"code","4851dcb9":"code","dd7100f1":"code","8cc0b44c":"code","c6aff75d":"code","896d2d95":"code","aeb9dffc":"code","9627cb9f":"code","2fdba11f":"code","f8020224":"code","911b5273":"code","3f705cf6":"markdown","d6052450":"markdown","bfe22d6c":"markdown","2e505a8d":"markdown","acb20bd0":"markdown","6021ce25":"markdown","ecbbd845":"markdown","84ce394a":"markdown"},"source":{"7e64aea4":"import numpy as np\nimport pandas as pd\n\n# Visualization\nimport matplotlib.pyplot as plt\n","56b2ce77":"mydata = pd.read_csv(\"..\/input\/Pokemon.csv\")\nmydata = mydata.set_index(\"#\")\nmydata.head()","49dced7d":"#we can see every column and raw\nmydata[\"HP\"][1]","a14d78a7":"#we can see the same result \nmydata.HP[1]","acc88605":"# using loc accessor (location of ...)\nmydata.loc[1,[\"Speed\"]]","2f4ec40b":"# Selecting only some columns\nmydata[[\"Speed\",\"Defense\"]]","6e3ba0fa":"# if we make one square braket, data will be series and \n#if we make 2 , data will be dataframes\nprint(type(mydata[\"Sp. Def\"]))     # series\nprint(type(mydata[[\"Sp. Def\"]]))   # data frames","753649d6":"# Slicing and indexing series\nmydata.loc[1:7,\"Sp. Def\":\"Speed\"]   # 7 columns and \"Sp.Def\", \"Speed\"","780a5efe":"# Reverse slicing \nmydata.loc[7:1:-1,\"Sp. Def\":\"Speed\"] ","d7eea693":"# From specific point to the end of data's value\nmydata.loc[3:7,\"Sp. Def\":] ","d5d08aba":"bl=mydata.Speed>150\nmydata[bl]","b2bb5233":"# Combining filters\nfilter1 = mydata.Speed > 130\nfilter2 = mydata.Generation > 2\nmydata[filter1 & filter2]","6b20bc8a":"# Nested Filters\nmydata\nmydata.Speed[mydata.Generation>2]","cc77baf7":"# Plain python functions\ndef divition(n):\n    return n\/2\nmydata.Speed.apply(divition)","f1762eb2":"# Or we can use lambda function (it is the same with last divition function)\nmydata.Speed.apply(lambda n : n\/2)","46987b5e":"# Defining new column using other columns\nmydata[\"new\"] = (mydata.Speed + mydata.Defense)\/2\nmydata.head()","9e6c8420":"dictionary = {\"Group\":[\"A\",\"A\",\"B\",\"B\"],\"gender\":[\"Female\",\"Male\",\"Female\",\"Male\"],\"count\":[10,45,5,9],\"age\":[15,4,72,65]}\ndf = pd.DataFrame(dictionary)\ndf","4851dcb9":"# pivoting\ndf.pivot(index=\"Group\",columns = \"gender\",values=\"count\")","dd7100f1":"df1 = df.set_index([\"Group\",\"gender\"])\ndf1\n","8cc0b44c":"#unstack\n# level determines indexes\ndf1.unstack(level=0)","c6aff75d":"df1.unstack(level=1) # level number change the place of Group and gender. we select in df1 function","896d2d95":"# we can change inner and outer level of the index positions\ndf2 = df1.swaplevel(0,1)\ndf2","aeb9dffc":"df\n# df.pivot(index=\"treatment\",columns = \"gender\",values=\"response\")\npd.melt(df,id_vars=\"Group\",value_vars=[\"age\",\"count\"])","9627cb9f":"# according to treatment take means of other features\ndf.groupby(\"count\").mean()   # mean is aggregation \/ reduction method\n# there are other methods like sum, std,max or min","2fdba11f":"# we can only choose one of the feature\ndf.groupby(\"count\").age.max() ","f8020224":"# Or we can choose multiple features\ndf.groupby(\"Group\")[[\"age\",\"count\"]].min() ","911b5273":"df.info()","3f705cf6":"MELTING DATA FRAMES\n* Reverse of pivoting","d6052450":"STACKING and UNSTACKING DATAFRAME","bfe22d6c":"TRANSFORMING DATA","2e505a8d":"CATEGORICALS AND GROUPBY","acb20bd0":"PIVOTING DATA FRAMES","6021ce25":"Importing Data","ecbbd845":"thank you for look, your comment and your vote\nthanks to DATAI Team","84ce394a":"FILTERING DATA FRAMES"}}