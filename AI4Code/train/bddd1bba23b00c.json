{"cell_type":{"00073640":"code","44d8a7e1":"code","117dfa0d":"code","80671a8d":"code","4d167b4c":"code","5cb1546e":"code","b761f4f3":"code","b3da8f54":"code","9b431c27":"code","26841afe":"code","d52e1af9":"code","2002875d":"code","f61f9a3e":"markdown","a4bd6e22":"markdown","b9d37e37":"markdown","aa735de7":"markdown"},"source":{"00073640":"# Install \"TA-Lib\"\n!cp ..\/input\/talib\/ta-lib-0.4.0-src.tar.gzh  .\/ta-lib-0.4.0-src.tar.gz\n!tar -xzvf ta-lib-0.4.0-src.tar.gz > null\n!cd ta-lib && .\/configure --prefix=\/usr > null && make  > null && make install > null\n\n!cp ..\/input\/talib\/TA-Lib-0.4.21.tar.gzh TA-Lib-0.4.21.tar.gz\n!pip install TA-Lib-0.4.21.tar.gz\n!pip install ..\/input\/talib\/numpy-1.21.4-cp37-cp37m-manylinux_2_12_x86_64.manylinux2010_x86_64.whl\nimport talib as ta","44d8a7e1":"!pip install mplfinance","117dfa0d":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nfrom tqdm.auto import tqdm\nimport time\n\nimport datetime\nimport math\n\nimport mplfinance as mpf\nimport talib as ta\nfrom decimal import Decimal, ROUND_HALF_UP\n\n# Warning\u306e\u7121\u52b9\u5316\nimport warnings\nwarnings.simplefilter(\"ignore\")\n\n# \u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0colum\u306e\u5168\u8868\u793a\npd.set_option(\"display.max_columns\", None)","80671a8d":"df_asset_details = pd.read_csv(r\"..\/input\/g-research-crypto-forecasting\/asset_details.csv\").sort_values(\"Asset_ID\")\ndf_asset_details","4d167b4c":"def reduce_mem_usage(df):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.        \n    \"\"\"\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    print(\"Memory usage of dataframe is {:.2f} MB\".format(start_mem))\n    \n    for col in df.columns:\n        col_type = df[col].dtype\n        \n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == \"int\":\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        # else:\n            # df[col] = df[col].astype('category')\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print(\"Memory usage after optimization is: {:.2f} MB\".format(end_mem))\n    print(\"Decreased by {:.1f}%\".format(100 * (start_mem - end_mem) \/ start_mem))\n    \n    return df","5cb1546e":"def read_csv_strict(file_name=\"\/kaggle\/input\/g-research-crypto-forecasting\/train.csv\"):\n    df = pd.read_csv(file_name).pipe(reduce_mem_usage)\n    df[\"datetime\"] = pd.to_datetime(df[\"timestamp\"], unit=\"s\")\n    df = df[\"2021-01-01 00:00:00\" <= df[\"datetime\"]]\n    df = df[df[\"datetime\"] < \"2021-06-13 00:00:00\"]\n    df = df.sort_values(\"datetime\")\n    date = df[\"datetime\"]\n    df[\"day\"] = date.dt.strftime(\"%Y-%m-%d\")\n    #date = df.index\n    return df","b761f4f3":"df_train = read_csv_strict()","b3da8f54":"df_train","9b431c27":"def convert_ohclv(df):\n\n    # \u307e\u3068\u3081\u308b\u8db3\uff1a\u5206\u5358\u4f4d\n    chart_term = 1440    # \n\n    # \u65e5\u4ed8\u306e\u30ea\u30b9\u30c8\n    origin_day = df.groupby(\"day\").mean().index\n\n    # \u7d50\u679c\u30ea\u30b9\u30c8\n    result_list = []\n\n    # \u65e5\u4ed8\u306e\u7e70\u308a\u8fd4\u3057\n    for day in origin_day:\n\n        day_df = df[df[\"day\"] == day]\n\n        start_time = pd.to_datetime(day)\n        for i in range(math.ceil(len(day_df) \/ chart_term)):\n            end_time = start_time + datetime.timedelta(minutes=chart_term-1)\n            term_df = day_df[(day_df[\"datetime\"]>=start_time) & (day_df[\"datetime\"]<=end_time)]\n            if len(term_df) == 0:\n                continue\n\n            # \u5217\u3054\u3068\u306e\u30c7\u30fc\u30bf\n            open = term_df[\"Open\"].values[0]\n            close = term_df[\"Close\"].values[-1]\n            high = term_df.max()[\"High\"]\n            low = term_df.min()[\"Low\"]\n            volume = term_df.sum()[\"Volume\"]\n\n            result_list.append([start_time, open, high, low, close, volume])\n\n            # \u6b21\u30eb\u30fc\u30d7\u306e\u305f\u3081\u306b\u958b\u59cb\u6642\u9593\u8ffd\u52a0\n            start_time = start_time + datetime.timedelta(minutes=chart_term)\n\n    # \u7d50\u679c\n    result_df = pd.DataFrame(result_list)\n    result_df.columns = [\"datetime\", \"Open\", \"High\", \"Low\", \"Close\", \"Volume\"]\n    result_df = result_df.sort_values(\"datetime\")\n\n    # CSV\u66f8\u304d\u8fbc\u307f\n    #result_df.to_csv(\"\u66f8\u304d\u51fa\u3059CSV\u30d5\u30a1\u30a4\u30eb\u306e\u30d1\u30b9\")\n    return result_df","26841afe":"def generate_stock_chart_image(df, asset_name):\n    # \u57fa\u6e96\u7dda\n    high = df[\"High\"]\n    low = df[\"Low\"]\n\n    max26 = high.rolling(window=26).max()\n    min26 = low.rolling(window=26).min()\n\n    df[\"basic_line\"] = (max26 + min26) \/ 2\n\n    # \u8ee2\u63db\u7dda\n    high9 = high.rolling(window=9).max()\n    low9 = low.rolling(window=9).min()\n\n    df[\"turn_line\"] = (high9 + low9) \/ 2\n\n    # \u96f2\u5f62\n    df[\"span1\"] = (df[\"basic_line\"] + df[\"turn_line\"]) \/ 2\n\n    high52 = high.rolling(window=52).max()\n    low52 = low.rolling(window=52).min()\n\n    df[\"span2\"] = (high52 + low52) \/ 2\n\n    # \u9045\u884c\u7dda\n    df[\"slow_line\"] = df[\"Close\"].shift(-25)\n\n    # \u30dc\u30ea\u30f3\u30b8\u30e3\u30fc\u30d0\u30f3\u30c9\u7528\u306edataframe\u8ffd\u52a0\n    df[\"upper\"], df[\"middle\"], df[\"lower\"] = ta.BBANDS(\n        df[\"Close\"], timeperiod=25, nbdevup=2, nbdevdn=2, matype=0)\n\n    # MACD\u7528\u306edataframe\u8ffd\u52a0\n    df[\"macd\"], df[\"macdsignal\"], df[\"macdhist\"] = ta.MACD(\n        df[\"Close\"], fastperiod=12, slowperiod=26, signalperiod=9)\n\n    # RSI\u30c7\u30fc\u30bf\u30d5\u30ec\u30fc\u30e0\u8ffd\u52a0\n    df[\"RSI\"] = ta.RSI(df[\"Close\"], timeperiod=25)\n\n    # \u57fa\u6e96\u7dda\u3001\u8ee2\u63db\u7dda\u3001\u96f2\u3001\u9045\u884c\u7dda\u306e\u8ffd\u52a0\n    apds = [mpf.make_addplot(df[\"upper\"], color=\"g\"),\n            mpf.make_addplot(df[\"middle\"], color=\"b\"),\n            mpf.make_addplot(df[\"lower\"], color=\"r\"),\n            mpf.make_addplot(df[\"macdhist\"], type=\"bar\",\n                             width=1.0, panel=1, color=\"gray\", alpha=0.5, ylabel=\"MACD\"),\n            mpf.make_addplot(df[\"RSI\"], panel=2,\n                             type=\"line\", ylabel=\"RSI\"),\n            mpf.make_addplot(df[\"basic_line\"]),  # \u57fa\u6e96\u7dda\n            mpf.make_addplot(df[\"turn_line\"]),  # \u8ee2\u63db\u7dda\n            mpf.make_addplot(df[\"slow_line\"]),  # \u9045\u884c\u7dda\n            ]\n\n    labels = [\"basic\", \"turn\", \"slow\", \"span\"]\n\n    fig, ax = mpf.plot(df, type=\"candle\", figsize=(16, 9), title=(asset_name),\n                       style=\"yahoo\", xrotation=0, volume=True, addplot=apds, returnfig=True,\n                       volume_panel=3, panel_ratios=(5, 2, 2, 1),\n                       fill_between=dict(\n                           y1=df[\"span1\"].values, y2=df[\"span2\"].values, alpha=0.5, color=\"gray\"),\n                       #savefig=f\"chart_{asset_id}.png\"\n                       )\n    ax[0].legend(labels)\n    plt.grid()\n    plt.show()","d52e1af9":"def get_Xy_and_model_for_asset(df_train, asset_id, asset_name):\n    df = df_train[df_train[\"Asset_ID\"] == asset_id]\n    df = convert_ohclv(df)\n    df = df.set_index(\"datetime\")\n    date = df.index\n    generate_stock_chart_image(df, asset_name)","2002875d":"for asset_id, asset_name in zip(df_asset_details[\"Asset_ID\"], df_asset_details[\"Asset_Name\"]):\n    print(f\"Visualizing for  {asset_name:<16} (ID={asset_id:<2})\")\n    get_Xy_and_model_for_asset(df_train, asset_id, asset_name)","f61f9a3e":"## Libraries","a4bd6e22":"## Data Visualization","b9d37e37":"# \u5404\u6697\u53f7\u8cc7\u7523\u306b\u3064\u304d\u4e00\u76ee\u5747\u8861\u8868\u3092\u4f5c\u6210\u3059\u308b\uff08\u65e5\u8db3\uff1a2021\/01\/01-2021\/06\/13\uff09","aa735de7":"## Load Data"}}