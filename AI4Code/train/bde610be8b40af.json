{"cell_type":{"04ed69ed":"code","fbb9e0ba":"code","edf3387c":"code","99a8d9bf":"code","b541638c":"code","cb8c1005":"code","07f768fe":"code","ba2ef4f1":"code","36ccdd85":"code","a41ce60c":"code","b9e824ae":"code","ebfcfb28":"code","42d43425":"code","aace2ccd":"code","0352b97c":"code","c46decae":"code","25440d64":"code","0d858300":"markdown","6ba67706":"markdown","e85823fb":"markdown"},"source":{"04ed69ed":"!pip install trimesh ipyvolume==0.6.0a2 ","fbb9e0ba":"from itertools import cycle\nimport plotly_express as px\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport bqplot\nimport ipyvolume as ipv\nimport trimesh\nimport numpy as np  # linear algebra\nimport pandas as pd  # data processing, CSV file I\/O (e.g. pd.read_csv)\n%matplotlib inline\nplt.rcParams[\"figure.figsize\"] = (15, 10)\nplt.rcParams[\"figure.dpi\"] = 125\nplt.rcParams[\"font.size\"] = 14\nplt.rcParams['font.family'] = ['sans-serif']\nplt.rcParams['font.sans-serif'] = ['DejaVu Sans']\nplt.style.use('ggplot')\nsns.set_style(\"whitegrid\", {'axes.grid': False})\nplt.rcParams['image.cmap'] = 'gray'  # grayscale looks better\nprop_cycle = plt.rcParams['axes.prop_cycle']\ncolors = prop_cycle.by_key()['color']","edf3387c":"corona_df = pd.read_csv(\"..\/input\/corona-virus-report\/covid_19_clean_complete.csv\")\ncorona_df['DateCode'] = pd.to_datetime(corona_df['Date'])\ncorona_df.head(5)","99a8d9bf":"date_country_df = corona_df.\\\n    groupby(['DateCode', 'Country\/Region']).\\\n    agg({'Confirmed': 'sum', 'Deaths': 'sum', 'Recovered': 'sum'}).\\\n    reset_index()\ndate_country_df.head(3)","b541638c":"px.line(date_country_df.query('Confirmed>0'),\n        x='DateCode',\n        y='Confirmed',\n        color='Country\/Region',\n        log_y=True)","cb8c1005":"fig, ax1 = plt.subplots(1, 1, figsize=(15, 15))\nsns.heatmap(\n    corona_df.\n    pivot_table(index='Country\/Region', columns='Date', values='Confirmed', aggfunc='sum').\n    sort_values('2020-04-05').\n    applymap(lambda x: np.log(x) if x > 0 else -1),\n    ax=ax1\n)","07f768fe":"px.scatter_geo(corona_df.\n               assign(grp=lambda c_df: c_df.apply(lambda c_row: '{Lat}-{Long}'.format(**c_row), axis=1),\n                      size=lambda c_df: np.sqrt(\n                          np.clip(c_df['Active'], 0, 1e6))+1\n                      ),\n               lat='Lat',\n               lon='Long',\n               color='Deaths',\n               range_color=[0, 100_000],\n               animation_frame='Date',\n               animation_group='grp',\n               hover_data=['Active', 'Confirmed', 'Deaths', 'Recovered'],\n               size='size')","ba2ef4f1":"filt_rows = lambda x: x[(x['Date'] > '2020-02-20') & (x['Country\/Region'].isin(['Canada']))]\nfilt_rows = lambda x: x\npv_df = filt_rows(corona_df).pivot_table(index=['Lat', 'Long'],\n                                                                columns='Date', values='Active',\n                                                                aggfunc='sum').\\\n    applymap(lambda x: np.log(np.clip(x, 1, 10000))).\\\n    reset_index()\npv_df.head(3)","36ccdd85":"# lat\/long offsets were guessed and checked to match the weird globe model I had\ntheta = (90-pv_df['Lat'].values) * np.pi\/180.0 \nphi = (pv_df['Long'].values+90) * np.pi\/180.0\nbase_radius = 100\nrad_values = pv_df.iloc[:, 2:].values.T","a41ce60c":"interval_ms = 100\nzs = base_radius * np.cos(phi) * np.sin(theta)\nxs = base_radius * np.sin(phi) * np.sin(theta)\nys = base_radius * np.cos(theta)\n\nvz = np.cos(phi) * np.sin(theta)\nvx = np.sin(phi) * np.sin(theta)\nvy = np.cos(theta)\n\n# Now also include, color, which containts rgb values\ncolor = plt.cm.magma((rad_values)\/(rad_values.mean()+rad_values.std())).swapaxes(1, 2)\ncolor = np.transpose(color, (0, 2, 1))  # flip the last axes\n\n# the aux range is from -1 to 1, but if we put 0 as min, negative values will go inside\n# the max determines the 'height' of the bars\naux_scale = bqplot.LinearScale(min=0, max=rad_values.max())","b9e824ae":"c_mesh = trimesh.load('..\/input\/globe-model\/Globe.obj')\nfig = ipv.figure()\n# we use the coordinates as the normals, and thus direction\nfor c_color, (k, v) in zip([None, 'green', 'blue'], c_mesh.geometry.items()):\n    if c_color is not None:\n        ipv.plot_trisurf(*v.vertices.T, triangles=v.faces, color=c_color)\ns = ipv.scatter(xs, ys, zs, vx=vx, vy=vy, vz=vz, color=color,\n                aux=rad_values, marker=\"cylinder_hr\")\nipv.xyzlim(base_radius+rad_values.max())\nipv.animation_control(s, interval=interval_ms)\ns.aux_scale = aux_scale\ns.shader_snippets = {'size':\n                     '''float sc = (SCALE_AUX(aux_current) - SCALE_AUX(0.0)); size_vector.y = sc;\n '''}\ns.material.side = \"DoubleSide\"\ns.size = 1\ns.geo_matrix = [1, 0, 0, 0,   0, 1, 0, 0,   0, 0, 1, 0,  0.0, 0.5, 0, 1]\nipv.squarelim()\nipv.style.use(\"nobox\")\nipv.style.box_off()\nipv.style.axes_off()\nipv.show()","ebfcfb28":"\ndef set_view(figure, framenr, fraction):\n    s.sequence_index = framenr-1\nif False: # gif export doesn't work well on kaggle\n    ipv.movie('covid_spread.gif', set_view, fps=1000\/interval_ms, frames=rad_values.shape[0])","42d43425":"ipv.pylab.save('covid_spread.html')","aace2ccd":"corona_df['QLat'] = pd.cut(corona_df['Lat'], 100)\ncorona_df['QLong'] = pd.cut(corona_df['Long'], 100)","0352b97c":"def summarize_grid(in_rows):\n    return in_rows.\\\n        groupby('DateCode').\\\n        agg({'Confirmed': 'sum', 'Deaths': 'sum', 'Recovered': 'sum',\n             'Country\/Region': 'first', 'Province\/State': 'first'}).\\\n        reset_index()\n\n\ndef cut_to_num(in_str: str) -> float:\n    \"\"\"Takes the middle of qcut range\"\"\"\n    clean_str = str(in_str).replace('(', '').replace(\n        '[', '').replace(']', '').replace(')', '')\n    return np.mean([float(x) for x in clean_str.split(',')])\n\n\ndate_grid_df = corona_df.\\\n    groupby(['QLat', 'QLong']).\\\n    apply(summarize_grid).\\\n    reset_index().\\\n    dropna().\\\n    assign(Lat=lambda x: x['QLat'].astype(str).map(cut_to_num),\n           Long=lambda x: x['QLong'].astype(str).map(cut_to_num))\ndate_grid_df.head(3)","c46decae":"sum_grid_df = date_grid_df.groupby(['Lat', 'Long']).agg(\n    {'Confirmed': 'sum'}).reset_index().query('Confirmed>0')","25440d64":"from mpl_toolkits.basemap import Basemap\nworld_map = Basemap(projection='ortho', lat_0=45, lon_0=100, resolution='l')\nworld_map.drawcoastlines(linewidth=0.25)\nworld_map.drawcountries(linewidth=0.25)\nworld_map.fillcontinents(color='lightgreen', lake_color='aqua', alpha=0.25)\n\nworld_map.scatter(sum_grid_df['Long'].values,\n                  sum_grid_df['Lat'].values,\n                  s=10*np.log10(sum_grid_df['Confirmed']),\n                  c='r',\n                  latlon=True)","0d858300":"# Overview\n- Basically trying to reproduce this graph: https:\/\/twitter.com\/MarkJHandley\/status\/1237119688578138112\/photo\/1 showing a linear (on a semilog scale) growth and a particularly slow\/quick peaking growth in Japan.\n- I try to also see how number of people infected relates to the average spread in a country\n- Finally I drop the country pretense and just look at grids of latitute and longitude","6ba67706":"## Big Summary Table\nThis should show all the countries, not sure why they are missing","e85823fb":"# LatLong Grids\nSince confirmed infections are a fairly difficult to measure number (and highly depenedent on testing). Using deaths as an end-point is probably more reliable"}}