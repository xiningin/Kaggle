{"cell_type":{"26918b46":"code","9005f595":"code","3c180918":"code","2de56f57":"code","08593077":"code","6c0354c9":"code","7d116f16":"code","ae218f15":"code","59347fc5":"code","a4eff830":"code","bdcaa153":"code","f554fb99":"code","70293504":"code","2e04144d":"code","ca913da1":"code","f696b046":"code","964f885d":"code","f759ad37":"markdown","2809d1ed":"markdown","b2ca2875":"markdown","917f5379":"markdown"},"source":{"26918b46":"import numpy as np \nimport pandas as pd \nimport warnings\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nfrom datetime import datetime\nimport scipy.optimize as opt\n\nwarnings.filterwarnings('ignore')\n\nsub0 = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-4\/submission.csv')\ntrain = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-4\/train.csv', parse_dates=['Date'])\ntest = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-4\/test.csv', parse_dates=['Date'])\ntrain.shape, test.shape","9005f595":"print (train.Date.min(), train.Date.max())\nprint (test.Date.min(), test.Date.max())","3c180918":"# Get the results we already have\nknow = test[test.Date <= train.Date.max()]\nnot_know = test[test.Date > train.Date.max()]\n\nknow = know.merge(train, on=['Date','Country_Region','Province_State'], how='left')\nknow.head()","2de56f57":"# Add columns\ntrain['days'] = (train['Date'] - train.Date.min()).dt.days\ntrain['location'] = train['Country_Region'] + train['Province_State'].fillna('')\nnot_know['days'] = (not_know['Date'] - train.Date.min()).dt.days\nnot_know['location'] = not_know['Country_Region'] + not_know['Province_State'].fillna('')","08593077":"# Fit logistic curve\ndef log_curve(x, k, x_0, ymax):\n    return ymax \/ (1 + np.exp(-k*(x-x_0))) \n\n# Plot hypothetical logistic curve\nx_hat = np.arange(0, 115)\ny_hat = log_curve(x_hat, 0.2, 60, 1000)\nfig, ax = plt.subplots(1, 1, figsize=(6, 4))\nax.plot(x_hat, y_hat, '-')","6c0354c9":"# Plot cases by each country\n\nmonths_fmt = mdates.DateFormatter('%b-%e')\n\ndef plot_cty(num, evo_col, title):\n    ax[num].plot(evo_col, lw=3)\n    ax[num].set_title(title)\n    ax[num].xaxis.set_major_locator(plt.MaxNLocator(7))\n    ax[num].xaxis.set_major_formatter(months_fmt)\n    ax[num].grid(True)\n\ndef evo_cty(country):\n    evo_cty = train[train.Country_Region==country].groupby('Date')[['ConfirmedCases','Fatalities']].sum()\n    evo_cty['Death Rate'] = evo_cty['Fatalities'] \/ evo_cty['ConfirmedCases'] * 100\n    plot_cty(0, evo_cty['ConfirmedCases'], 'Confirmed cases')\n    plot_cty(1, evo_cty['Fatalities'], 'Death cases')\n    plot_cty(2, evo_cty['Death Rate'], 'Death rate')\n    fig.suptitle(country, fontsize=13)\n    plt.show()\n    \nfig, ax = plt.subplots(1, 3, figsize=(17,5))\nevo_cty('US')","7d116f16":"# Get initial parameter estimates\ndef get_param(loc):\n    _ = train[train.location == loc]\n    _['diff'] = _.ConfirmedCases.diff()\n    _['pct'] = _.ConfirmedCases.pct_change()\n    initial_speed = _.loc[_.ConfirmedCases.diff().argmax(),'pct']\n    initial_mid = _.loc[_.ConfirmedCases.diff().argmax(), 'days']\n    initial_max = _.ConfirmedCases.max() * 2\n    return initial_speed, initial_mid, initial_max\n\nget_param('Italy')","ae218f15":"# Forecast confirmed cases\n\nloc_list = train.location.unique()\nall_param = pd.DataFrame(index=loc_list, columns=['k','x_0','y_max'])\n\nfor loc in loc_list:\n    _ = train[train.location == loc]\n    nn = not_know[not_know.location == loc]\n    initial_max = _.ConfirmedCases.max()*2\n    x = _.days\n    y1 = _.ConfirmedCases\n    try:\n        popt, pcov = opt.curve_fit(log_curve, x, y1, p0 = get_param(loc))\n        popt[2] = max(popt[2],get_param(loc)[2]\/2) # y_max must be at least the latest confirmed cases\n    except RuntimeError:\n        popt = get_param(loc)    \n    # print(loc, round(popt[0],2), round(popt[1], 0), round(popt[2],0))\n    y1_hat = log_curve(nn.days, *popt)\n    not_know.loc[y1_hat.index, 'ConfirmedCases'] = y1_hat\n    all_param.loc[loc, 'k'] = popt[0]\n    all_param.loc[loc, 'x_0'] = popt[1]\n    all_param.loc[loc, 'y_max'] = popt[2]\n\nprint('Done!')","59347fc5":"# Plot prediction vs actual data\ndef plot_log_curve(location):\n    _ = train[train.location == location]\n    nn = not_know[not_know.location == location]\n    x = _.days\n    y1 = _['ConfirmedCases']\n    # (k, x_0, ymax), _a = opt.curve_fit(log_curve, x, y1)\n    # print(k, x_0, ymax)\n    x_hat = pd.concat([x, nn['days']])\n    y1_hat = log_curve(x_hat, all_param.loc[location, 'k'], all_param.loc[location, 'x_0'], all_param.loc[location, 'y_max'])\n    fig, ax = plt.subplots(1, 1, figsize=(7, 4))\n    ax.plot(x, y1, 'o', markersize=3)\n    ax.plot(x_hat, y1_hat, '-', lw=2)\n\nplot_log_curve('Turkey')","a4eff830":"plot_log_curve('United Kingdom')","bdcaa153":"# Forecast deaths\nlatest = train[train.Date == train.Date.max()]\nlatest['DeathRate'] = latest['Fatalities'] \/ latest['ConfirmedCases']\nnot_know2 = not_know.merge(latest[['location','DeathRate']], on='location')\nnot_know2['Fatalities'] = not_know2['ConfirmedCases'] * not_know2['DeathRate']","f554fb99":"# Plot prediction vs actual data - deaths\ndef plot_log_curve(location):\n    _ = train[train.location == location]\n    nn = not_know2[not_know2.location == location]\n    x = _.days\n    y = _['Fatalities']\n    x_hat = nn.days\n    y_hat = nn.Fatalities\n    fig, ax = plt.subplots(1, 1, figsize=(7, 4))\n    ax.plot(x, y, '-', lw=2)\n    ax.plot(x_hat, y_hat, 'o', markersize=3)\n\nplot_log_curve('Russia')","70293504":"plot_log_curve('USNew York')","2e04144d":"# Rounding to integer\nnot_know2['ConfirmedCases'] = not_know2['ConfirmedCases'].round()\nnot_know2['Fatalities'] = not_know2['Fatalities'].round()","ca913da1":"not_know2.head()","f696b046":"# Predicted cases on Apr 30\nnot_know2.loc[not_know2.Date=='2020-04-30', \n              ['location','ConfirmedCases','Fatalities']].sort_values('ConfirmedCases', ascending=False).head(20)","964f885d":"# Submission\nsub1 = pd.concat([know[['ForecastId', 'ConfirmedCases','Fatalities']], \n                 not_know2[['ForecastId', 'ConfirmedCases','Fatalities']]])\nsub1=sub1.sort_values('ForecastId').reset_index(drop=True)\nsub1.to_csv('submission.csv', index=False)","f759ad37":"We fit a curve for each location (mostly by country, if data is available for regions of a country, we fit by each region) in two steps:\n- Get an initial estimate of parameters from historical data\n- Use curve_fit() function from scipy to fit the curve using above initial parameter estimate. If fitting does not go through (with error), we use initial parameter estimates ","2809d1ed":"# Predicting Coronavirus Cases\n\nThis notebook uses a very simple logistic curve approach to predict the coronavirus cases in the future. ","b2ca2875":"FYI here is what a logistic curve looks like:","917f5379":"For death cases, the growth is less like the logistic curve. As a simple base case, we use the latest death rate times predicted comfirmed cases as death cases estimates."}}