{"cell_type":{"178d4f0a":"code","b11ef2ca":"code","12d553cd":"code","e46701ec":"code","8cc32bc2":"code","0998f37d":"code","1b49c475":"code","d773a2cb":"code","c2557182":"code","bab40059":"code","75b8636e":"code","47958c27":"code","00947d04":"code","71a62b00":"code","98c7271e":"code","c1854f59":"code","fe2b0054":"code","1717f134":"code","ec5d2b9a":"code","8d369569":"code","eb78c0ae":"code","b8f28360":"markdown","b3fba708":"markdown","2da90480":"markdown","4585cfcc":"markdown","42cf77fc":"markdown","90bdc388":"markdown","f59125db":"markdown","1e142ba2":"markdown","12895c21":"markdown","be10611c":"markdown","acae371d":"markdown","2ef049c2":"markdown","495d1985":"markdown","d52e31a8":"markdown","b0f89cb0":"markdown"},"source":{"178d4f0a":"!pip install mygene","b11ef2ca":"import mygene\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\nimport statsmodels.api as sm\nfrom sklearn.decomposition import PCA\n%matplotlib inline","12d553cd":"path_to_transcriptomics_data = '..\/input\/end-als\/end-als\/transcriptomics-data\/L3_counts\/'\nall_samples = os.listdir(path_to_transcriptomics_data)\nprint(f'Number of samples: {len(all_samples)}')","e46701ec":"# load indnvidual example\ndef get_single_example_path(samplename):\n    # not the best code to iterate over subfolders\n    for root, dirs, files in os.walk(path_to_transcriptomics_data+samplename):\n        for name in files:\n            # whatever, pick first\n            return(root+'\/'+name)\n\ndef load_single_example(samplename):\n    path_to_case_counts = get_single_example_path(samplename)\n    # also remove CASE- and CONTROL- from samplename\n    samplename = samplename.split('-')[1]\n    data = pd.read_csv(path_to_case_counts, sep='\\t', skiprows=1)\n    # we want to make out life simple for now and take only first columns (geneid)\n    # and last column\n    data = data.rename(columns={data.columns.values[-1]: samplename})\n    data.index = data['Geneid']\n    # I should probably cast gene counts to uint8 or something...\n    data = data.drop(['Geneid'], axis=1)\n    return data[[samplename]]","8cc32bc2":"# simple load everything\ncount_table = [load_single_example(sample) for sample in all_samples]\ncount_table = pd.concat(count_table, axis=1)","0998f37d":"# just remove some low expressed genes\nmin_count_thrs = 100\ncount_table = count_table.loc[count_table.sum(axis=1) >= min_count_thrs, :]","1b49c475":"samples_classes = pd.read_csv('..\/input\/end-als\/end-als\/clinical-data\/filtered-metadata\/metadata\/aals_participants.csv')\ndataportal_datatable = pd.read_csv('..\/input\/end-als\/end-als\/clinical-data\/filtered-metadata\/metadata\/aals_dataportal_datatable.csv')\nsamples_classes = pd.merge(dataportal_datatable, samples_classes)\nsamples_classes = samples_classes.loc[samples_classes['GUID'].isin(count_table.columns.values), :]\nsamples_classes.index = samples_classes['GUID']\nsamples_classes = samples_classes.loc[count_table.columns, :]\nsamples_classes.head()","d773a2cb":"# simple normalization\ncount_table = 10000*count_table.apply(lambda x: x\/sum(x), axis=0)\n# inspired by http:\/\/pklab.med.harvard.edu\/scw2014\/subpop_tutorial.html\nmean_expression = count_table.mean(axis=1)\nvar_expression = count_table.var(axis=1)\nsd_expression = count_table.std(axis=1)\ncoeffient_variation = sd_expression \/ mean_expression\nplt.scatter(np.log(mean_expression), np.log(coeffient_variation), s=0.05)\nplt.xlabel('log_mean_expression')\nplt.ylabel('log_coeffient_variation')","c2557182":"# simple split into bins\nupper_bound = np.round(np.max(np.log(mean_expression)))\nlower_bound = np.round(np.min(np.log(mean_expression)))\nn_bins = 5\nsplit_bins = np.linspace(lower_bound, upper_bound, n_bins)\n# make DF with cv - expression\ngene_variance_df = pd.DataFrame({\n    'log_mean_expression': np.log(mean_expression), \n    'log_coeffient_variation': np.log(coeffient_variation), \n    'predicted_log_coeffient_variation': 0})\ngene_variance_df = gene_variance_df.sort_values(['log_mean_expression'])\n# assign bin to each gene\ngene_variance_df['bin'] = gene_variance_df['log_mean_expression'].apply(lambda x: sum(x>split_bins))\nbins_total = gene_variance_df['bin'].unique()","bab40059":"bins_to_keep = []\nplt.scatter(np.log(mean_expression), np.log(coeffient_variation), s=0.05)\nfor bin_idx in bins_total:\n    # fit individual model for each bin\n    exog = sm.add_constant(gene_variance_df['log_mean_expression'][gene_variance_df['bin']==bin_idx], prepend=False)\n    mod = sm.GLM(gene_variance_df['log_coeffient_variation'][gene_variance_df['bin']==bin_idx], exog)\n    res = mod.fit()\n    # get predictins for some examples of mean expression, just to plot the line\n    expression_space = np.linspace(split_bins[bin_idx-1], split_bins[bin_idx])\n    predicted_line = mod.predict(res.params,  sm.add_constant(expression_space, prepend=False))\n    # and plot them\n    plt.plot(expression_space, predicted_line, '--', c='k')\n    # in case we are not happy with the slope (no different from zero), we ignore that bin\n    pvalue_slope = res.pvalues['log_mean_expression']\n    if pvalue_slope <= 0.001:\n        print(f'bin {bin_idx}, pvalue {pvalue_slope} - is good')\n        bins_to_keep.append(bin_idx)\n    else:\n        print(f'bin {bin_idx}, pvalue {pvalue_slope} - drop')\n    # get predictions for each bin\n    log_cv_predicted_by_model = mod.predict(res.params)\n    gene_variance_df.loc[gene_variance_df['bin']==bin_idx, 'predicted_log_coeffient_variation'] = log_cv_predicted_by_model\nplt.xlabel('log_mean_expression');\nplt.ylabel('log_coeffient_variation');\nplt.title('Predicted values and observed');","75b8636e":"gene_variance_df['residual'] = gene_variance_df['log_coeffient_variation'] - gene_variance_df['predicted_log_coeffient_variation']\ngene_variance_df = gene_variance_df.loc[gene_variance_df['bin'].isin(bins_to_keep), :]\ngene_variance_df = gene_variance_df.sort_values(['residual'], ascending=False)\ngene_variance_df.head()","47958c27":"exog = sm.add_constant(gene_variance_df['log_mean_expression'], prepend=False)\nmod = sm.GLM(gene_variance_df['residual'], exog)\nres = mod.fit()\nprint(res.summary())","00947d04":"plt.scatter(gene_variance_df['log_mean_expression'], gene_variance_df['residual'], s=0.05)\nplt.xlabel('log_mean_expression');\nplt.ylabel('coeffient_variation_residuals');","71a62b00":"gene_variance_df['residual'].hist()","98c7271e":"cut_off = 1.0\nn_selected_genes = sum(gene_variance_df['residual']>=cut_off)\nprint(f'pick {n_selected_genes} genes with cut off of {cut_off}')","c1854f59":"gene_variance_df_selected = gene_variance_df.loc[gene_variance_df['residual']>=cut_off, :]\n# annotate genes!\nmg = mygene.MyGeneInfo()\ngene_annotations = [mg.getgene(x, fields='symbol') for x in gene_variance_df_selected.index.values]\ngene_variance_df_selected.loc[:, 'symbol'] = [x['symbol'] if x is not None else None for x in gene_annotations]\ngene_variance_df_selected.head()","fe2b0054":"# https:\/\/www.kaggle.com\/alsgroup\/end-als\/discussion\/231731\nurl_known_markers = 'https:\/\/raw.githubusercontent.com\/chervov\/genes\/main\/genes_ALS_from_alsod_ac_uk.csv'\nknown_markers = pd.read_csv(url_known_markers)\n# any in know ones?\nprint(sum(gene_variance_df_selected['symbol'].isin(known_markers['Gene symbol'])))","1717f134":"count_table_tr = count_table.loc[gene_variance_df_selected.index, :]\npca = PCA(n_components=2)\nprojections = pca.fit_transform(count_table_tr.values.T)\nsns.scatterplot(x=projections[:, 0], y=projections[:, 1], hue=samples_classes['Subject Group']);","ec5d2b9a":"samples_classes.loc[:, 'is_case'] = 0\nsamples_classes.loc[samples_classes['Case_Control']=='Case', 'is_case'] = 1\n\nsamples_classes.loc[:, 'is_male'] = 0\nsamples_classes.loc[samples_classes['Sex']=='Male', 'is_male'] = 1\n\nage_fill_value = np.round(np.nanmean(samples_classes['Age at Sample Collection']))\nage_fill_mask = pd.isna(samples_classes['Age at Sample Collection'])\nsamples_classes.loc[age_fill_mask, 'Age at Sample Collection'] = age_fill_value","8d369569":"exog_s = samples_classes[['is_case', 'is_male', 'Age at Sample Collection']]\nexog = sm.add_constant(exog_s, prepend=False)\n\nfor gene in count_table_tr.index.values:\n    mod = sm.GLM(count_table_tr.loc[gene, :], exog_s)\n    res = mod.fit()\n    pvalue_case = res.pvalues['is_case']\n    if pvalue_case <= 0.05:\n        print(gene, pvalue_case, res.params['is_case'])","eb78c0ae":"# to do","b8f28360":"Now iterate over all genes and see if any coefficient for `is_case` is different from zero","b3fba708":"We fit a piece-wise function log(coeffient_variation) ~ log(mean_log_expression) and look at the residuals for each gene - genes with large residuals will be our higly variable genes. They can be variable purely due to techical reasons (batch effect), confounding factors (sex? race? age?) and so on but we can deal with that\n(inspired by https:\/\/rawgit.com\/ChristophH\/sctransform\/supp_html\/supplement\/variance_stabilizing_transformation.html and http:\/\/pklab.med.harvard.edu\/scw2014\/subpop_tutorial.html)","2da90480":"Now fit these piece-wise regression, control the value for slope in each case. We will also keep all predicted values so we can compare them with observed","4585cfcc":"We really see only a few genes with non-zero coefficient for `is_case`.\nCan we think about a different approach? We can take initial count data and run DESeq\\limma to find DE genes","42cf77fc":"We are interested in genes with overdispersion => high residuals. We can think about distribution of residuals... and come up with a stat test to find residuals > 0. But for now we can simply look at their distrubution and come up with a trehshold","90bdc388":"Ok, make some PCA projections","f59125db":"Find genes with overdispersion - genes which have high variance for their mean expression. That helps in scRNA data to find potential genes of interest, maybe it can help here","1e142ba2":"What we see us quite poor separation of ALS - non-ALS. Well, it was expected after all","12895c21":"Ideally, now residuals shouldn't depend on the mean expression","be10611c":"We can generate a huge count matrix with all participants","acae371d":"Do we have any known markers?","2ef049c2":"Good thing is that we are already provided with it!","495d1985":"# Let's focus on transcriptomics data first. We can compare gene expression across patients with and without ALS; Bulbar onset vs limbs onset patients; Rapid vs slow progress.","d52e31a8":"Can we fit a linear model to account for effects of age, sex, race, case-control and so on?","b0f89cb0":"first, make dummy variables"}}