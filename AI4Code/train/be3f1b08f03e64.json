{"cell_type":{"8adb5ab8":"code","6b952533":"code","70b6e3a9":"code","d040c15d":"code","ed15948b":"code","adfdeaad":"code","3e55c433":"code","3d8b8774":"code","8d3b6ebf":"code","54f7b679":"code","cdf7ee36":"code","ded48ab8":"code","446a53b0":"code","273022ba":"code","049ddc5a":"code","4d543e4e":"code","a811deaa":"code","8a87e992":"code","8a1426c3":"code","29972202":"code","2eb61a82":"code","af8bd369":"markdown","6399f3a2":"markdown","faa755bc":"markdown","b9b917e3":"markdown","6e895ffb":"markdown","5ab203c4":"markdown","0be41b6f":"markdown","a7c2a8a5":"markdown","915e90b4":"markdown","4e1aee9c":"markdown","5f7cb90b":"markdown","30b6d38b":"markdown","eec2d757":"markdown","e82dc39b":"markdown","792994f7":"markdown","aad66c60":"markdown","3be30575":"markdown","b09a84cc":"markdown","1b7c9f2d":"markdown","359a3924":"markdown"},"source":{"8adb5ab8":"# Imagine I come up with a function...\n\ndef sum1(n):\n    '''\n    Take an input of n and return the sum of th numbers from 0 to n\n    '''\n    final_sum = 0\n    for x in range(n+1):\n        final_sum += x\n    \n    return final_sum ","6b952533":"sum1(5)","70b6e3a9":"# And you came up with this function...\n\ndef sum2(n):\n    '''\n    Take an input of n and rturn the sum of the numbers from 0 to n\n    '''\n    return (n*(n+1))\/2","d040c15d":"# built in magic commands in notebook\n%timeit sum1(100)\n# result in microseconds","ed15948b":"%timeit sum2(100)\n# result in nanoseconds","adfdeaad":"def Bigo(n):\n    return 45*n**3 + 20*n**2 + 19","3e55c433":"Bigo(1)","3d8b8774":"Bigo(2)\n# starting to see that the 19 will not be a scaling or limiting factor","8d3b6ebf":"Bigo(10)","54f7b679":"from math import log\nimport numpy as np\nimport matplotlib.pyplot as plt \n%matplotlib inline \nplt.style.use('bmh')\n\n# Set up runtime comparisons\nn = np.linspace(1, 10)\nlabels = ['Constant', 'Logarthmic', 'Linear', 'Log Linear', 'Quadratic', 'Cubic', 'Exponential']\nbig_o = [np.ones(n.shape), np.log(n), n, n*np.log(n), n**2, n**3, 2**n]\n\n# Plot\nplt.figure(figsize = (12,10))\nplt.ylim(0,50)\n\nfor i in range(len(big_o)):\n    plt.plot(n, big_o[i], label = labels[i])\n    \nplt.legend(loc = 0)\nplt.ylabel('Relative Runtime')\nplt.xlabel('n')","cdf7ee36":"def func_constant(values):\n    '''\n    Prints first item in the list of values\n    '''\n    print (values[0])\n    \nfunc_constant([1,2,3])","ded48ab8":"def func_quad(lst):\n    '''\n    Prints pairs for every item in list\n    '''\n    for item_1 in lst:\n        for item_2 in lst:\n            print(item_1, item_2)\n            \nlst = [1, 2, 3]\n\nfunc_quad(lst)","446a53b0":"def print_1(lst):\n    '''\n    Prints all items once\n    '''\n    for val in lst:\n        print(val)\n        \nprint_1(lst)\n\n# can you see how this growth is linear to the input?\n# O(n)","273022ba":" def print_3(lst):\n        '''\n        Print all items three times\n        '''\n        for val in lst:\n            print(val)\n            \n        for val in lst:\n            print(val)\n            \n        for val in lst:\n            print(val)\n\nprint_3(lst)","049ddc5a":"def comp(lst):\n    '''\n    This function prints the first item O(1) it is a constant\n    Then it prints the first 1\/2 of the list O(n\/2)\n    Then prints a string 10 times O(10) ti is a constant\n    '''\n    print(lst[0])\n    \n    midpoint = len(lst)\/\/2\n    \n    for val in lst[:midpoint]:\n        print(val)\n        \n    for x in range(10):\n        print('number')","4d543e4e":"lst = [1,2,3,4,5,6,7,8,9,10]\ncomp(lst)","a811deaa":"def matcher(lst, match):\n    '''\n    Given a list lst, return a boolean indicating if match item is in the list\n    '''\n    for item in lst:\n        if item == match:\n            return True\n    return False","8a87e992":"lst","8a1426c3":"matcher(lst, 1) # this is best case because item seeked is index 0, O(1) Best case becoms a constant","29972202":"matcher(lst, 20) # worst case, entire list must be searched, n element, O(n) Worst case becomes linear","2eb61a82":"def memory(n = 10):\n    '''\n    Prints \"Memory!\" n times\n    '''\n    for x in range(n): # TIME COMPLEXITY O(n)\n        print('Memory!') # SPACE COMPLEXITY O(1)\n\nmemory(10)","af8bd369":"## Space Complexity\nAlso concerned with how much memory\/space an algorithm uses. The notation of space complexity is the same, but instead of checking the time of operations, we check the size of the allocation of memory","6399f3a2":"## Worst Case vs Best Case\nMany times we are only concerned with the worst possible case of the algorithm, but in an interview setting its is important to keep in mind that worst case and best caes scenarios may be completely different Big-O times","faa755bc":"# Why Analyze Algorithm?\n* Procedure or formula for solving a problem\n* Some are so useful they have names:<br>merge sort, bubble sort etc...\n* How can we compare the algos to know which is better","b9b917e3":"## Calculating Scale of Big-O\ninsignificant terms drop out of Big-O notation\n\nWhen it comes to Big-O notation we only care about the most significant terms, remember as the input grows larger only the fastest growing term will matter.\n* Like taking limit towards Infinity","6e895ffb":"### O(n^2) Quadratic","5ab203c4":"# Big O\nobjectively compare th efficinty of these two algorithm\n* compare the number of assignments each algorithm makes\nThe original `sum1` function will create an assignment `n+1` times, we can see this from the range based function. This means it will assign the `final_sum` variable n+1 times, We can say that for a problem of n size (in this case just a number n) this function will take `1+n` steps\n\nThis `n` notation allows us to compare solutions and algorithm relative to the size of the problem, since `sum1(10)` and `sum1(1000000)` would take very different times to run but be using the same algorithm. We can note that as n grows very large, the +1 won't have much effect. So let's begin discussing how to build a syntax for this notation.\n\nBig-O notation dscribes **how quickly runtime will gro relative to the input as the input get arbitrarily large**","0be41b6f":"This algo will run `3` times for each `n`, so this becomes an order of `3(n)`. It is still linear.<br>More importantly, `1(infinity)` is not really differnt than `(infinity)` and We can drop insignificant constants.\n\nSo this too is `O(n)`","a7c2a8a5":"Clearly we want to choose algorithm that stays away from any exponntial, quadratic, or cubic behavior!","915e90b4":"* two loops, one nested inside another\n* For a list of `n` items, we will have to perform `n` opreations for every item in the list! This means in total, we will perform `n` times `n` assignment, or `n^2`.So a list of `10` items have `100` operations. you can see how dengerous this can get for a large inputs! This is why Big-O is so important to be aware of!\n* hence, the input of `3` gives us `9` output iterations","4e1aee9c":"Function sum1 uses for loop to iteratively add across range 0 to n<br>\nFunction sum2 uses formula to solve the problem","5f7cb90b":"## Big-O complexity chart","30b6d38b":"MICRO = `10^-6`<br>\nNANO = `10^-9`\n\nSmaller number is obviously better\n\n* **Cannot simply rely on time to  run because all computers are different and some faster than others**\n* **To be hardware independent = Big O**","eec2d757":"## Big-O Examples","e82dc39b":"### O(1) Constant","792994f7":"## HOW WELL IT CAN SCALE as data increases?\nRemember, we want to **compare how quickly runtime will grow**, not compare exact runtime, since those can vary depending on hardware\n\nSince we want to compare for a variety of input sizesm we are only concerned with the runtime grow relative to the input. This is why we use `n` for notation.\n\nAs `n` gets arbitrarily large we only worry ablut terms that grow the fastest as `n` gets large, to this point, Big-O analysis is also known as **asymptotic analysis**.\n\nIn maths, asymptotic analysis = **describing limiting behavior**\n* which part of the algorithm has the GREATEST effect on the final answer, which part of algo is the real bottleneck, which part is the limiting factor.\n\nAs of the syntax sum1() can be said to be O(n) since its runtime grows linearly with the input size\n","aad66c60":"It doesn't matter how large my values list becomes, the function\/algo will only grab the indexed position `0` in that list","3be30575":"`O(n)` for time complexity but what about space complexity<br>\nIn memory it doesn't need to store `10` Versions of \"Memory!\". It only need to store one string. `O(1)`","b09a84cc":"### O(1 + n\/2 + 10)\nAs `n` gets larger and larger (scales up) you can see rasily how the `1` and the `10` quickly begin to mean nothing.<br>\nAnd the `\/\/2` will begin to hav no effect either<br>\nEnd up with `O(n)`","1b7c9f2d":"* It can be seen that the `19` doesn't hold much weight anymore\n* The `20n**2` in this case is *2000*\n* The `45n**3` in this case is *45,000*\n\n### The part of the algo that really has a lot to do with the final answer as data scales, will not be the 45 but the n3. So this algo has an order of O(n**3)","359a3924":"## Objectively Compare Them\n* memory space\n* time to run"}}