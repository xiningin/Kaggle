{"cell_type":{"b0b2389c":"code","3872d7f1":"code","61915a99":"code","4885f591":"code","5361394a":"code","1a579927":"code","fc0ee511":"code","9777788f":"code","adff76d6":"code","0906fe89":"code","777d423d":"code","1d7e5dce":"code","dfe7b206":"code","2fb2c340":"markdown"},"source":{"b0b2389c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","3872d7f1":"from tensorflow.keras import layers, callbacks\nfrom tensorflow import keras\nimport pandas as pd\nfrom sklearn.utils import shuffle\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split","61915a99":"water_quality_raw = pd.read_csv(\"..\/input\/water-potability\/water_potability.csv\")\nwater_quality = water_quality_raw.copy()\nwater_quality.head()","4885f591":"good_water_quality = water_quality[water_quality['Potability'] == 1]\ngood_water_quality = good_water_quality.copy()\nbad_water_quality = water_quality[water_quality['Potability'] == 0]\nbad_water_quality = good_water_quality.copy()\n\ngood_water_quality['ph'] = good_water_quality['ph'].fillna(good_water_quality['ph'].mean())\ngood_water_quality['Sulfate'] = good_water_quality['Sulfate'].fillna(good_water_quality['Sulfate'].mean())\ngood_water_quality['Trihalomethanes'] = good_water_quality['Trihalomethanes'].fillna(good_water_quality['Trihalomethanes'].mean())\n\nbad_water_quality['ph'] = bad_water_quality['ph'].fillna(bad_water_quality['ph'].mean())\nbad_water_quality['Sulfate'] = bad_water_quality['Sulfate'].fillna(bad_water_quality['Sulfate'].mean())\nbad_water_quality['Trihalomethanes'] = bad_water_quality['Trihalomethanes'].fillna(bad_water_quality['Trihalomethanes'].mean())\n\n\nwater_quality = pd.concat([good_water_quality, bad_water_quality])\nwater_quality = shuffle(water_quality)\n","5361394a":"x = water_quality.drop('Potability', axis = 1)\ny = water_quality['Potability']\n\nscaler = StandardScaler()\nx_scaled = scaler.fit_transform(x)\nx_scaled = pd.DataFrame(x_scaled, columns=x.columns.values)","1a579927":"x_train, x_test, y_train, y_test = train_test_split(x_scaled, y, test_size = 0.3)\nx_train.shape","fc0ee511":"model = keras.Sequential([\n    layers.Dense(input_shape = [9], units= 250, activation = 'relu'),\n    layers.Dense(units= 250, activation = 'relu'),\n    layers.Dense(units= 250, activation = 'relu'),\n    layers.Dense(units= 250, activation = 'relu'),\n    layers.Dense(units= 250, activation = 'relu'),\n    layers.Dense(units= 250, activation = 'relu'),\n    layers.Dense(units= 250, activation = 'relu'),\n    layers.Dense(units= 250, activation = 'relu'),\n    layers.Dense(units= 1, activation = 'sigmoid')\n])","9777788f":"model.compile(\n    loss='binary_crossentropy',\n    metrics=['binary_accuracy'],\n    optimizer = 'adam'\n)","adff76d6":"call_back = callbacks.EarlyStopping(\n    min_delta=0.001,\n    patience= 15,\n    restore_best_weights=True\n)","0906fe89":"history = model.fit(\n        x_train, y_train,\n        validation_data=(x_test, y_test),\n        epochs=20,\n        batch_size = 100\n)","777d423d":"history = pd.DataFrame(history.history)\nhistory.head()","1d7e5dce":"history[['loss', 'val_loss']].plot()","dfe7b206":"print('The mean validation accuracy is {}%'.format(history['val_binary_accuracy'].mean() * 100))","2fb2c340":"## Model"}}