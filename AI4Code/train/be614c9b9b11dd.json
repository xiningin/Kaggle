{"cell_type":{"d708b7b7":"code","785bc98d":"code","3f7e036f":"code","29d8e544":"code","e60e978c":"code","803cad58":"code","382afe6e":"code","48a10a4e":"code","030ee40c":"code","8eadcb0c":"code","62dee681":"code","4f8c0cd2":"code","522e0bee":"code","e841af88":"code","15227c0e":"code","40420b20":"code","b9b8dbfe":"code","10383f5e":"code","519429b4":"code","c576fe35":"code","c1c73845":"code","a1d336f7":"code","7e227e80":"code","d990626b":"code","ed83d85f":"code","523036bf":"code","7d4f81e3":"code","542e6065":"code","02894ea6":"code","a6955f89":"markdown","6786ded8":"markdown","0b1647fc":"markdown","7498d904":"markdown","a5981c0e":"markdown","b19bd755":"markdown","dfaa321b":"markdown","3d542073":"markdown","7d396a74":"markdown","124261e4":"markdown","1f4fd886":"markdown","8615c457":"markdown","b804d709":"markdown","0339b454":"markdown","56293e46":"markdown","c6ab343d":"markdown","a490eeea":"markdown","feb5d4ca":"markdown","069b7223":"markdown","7696510c":"markdown","f321b19c":"markdown","2fee5387":"markdown","3198a777":"markdown","1b081085":"markdown","4bea8bd1":"markdown","77a8ee3b":"markdown","51038d94":"markdown","f7777854":"markdown","1c4acddd":"markdown"},"source":{"d708b7b7":"#import libraries and list the files in the input directory\nimport os\nprint(os.listdir(\"..\/input\")) #list the docs\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt #plot graphs\nimport seaborn as sns #plotting interactive graphs\nimport random #to use in random choices\nfrom datetime import datetime as dt #for date conversion\n%matplotlib inline \n#to include graphs inline within the frontends next to code","785bc98d":"df = pd.read_csv(\"..\/input\/googleplaystore.csv\") #load googleplaystore data in a dataframe(df)\nprint(df.head()) #have a look at the first 5 columns","3f7e036f":"print(df.shape) #gives number of rows and columns","29d8e544":"print(\"Name of the columns are:\", \"\\n\", df.columns) #look at the column names","e60e978c":"print(\"Dataframe has following datatypes:\", \"\\n\", df.dtypes) #look at the datatypes in the dataframe\nprint(\"Number of null values per column:\", \"\\n\", df.isnull().sum()) #look at # of null values per column","803cad58":"#look at the App name column if they have unique values\nprint(\"Statistics of App Column:\", df[\"App\"].describe().to_dict())\n\n#drop NA values of the df:\ndf.dropna(axis=0, how='any', inplace=True)\nprint(\"After the clean-up:\",df.shape)","382afe6e":"#look at the distribution of app ratings in a distplot\nsns.set(font_scale=1.5, style = \"whitegrid\") #set the font size and background\nf, axes = plt.subplots(figsize=(8,6), sharex=True) #set the plotsize\n\ng = sns.distplot(df.Rating, hist=False, color=\"g\", kde_kws={\"shade\": True})\nplt.ylabel(\"Frequency\")\nplt.title(\"Distribution of App Ratings\")","48a10a4e":"plt.figure(figsize=(8,6))\nplt.hist(df.Rating, range=(1,5), bins=16)\nplt.axvline(x=df.Rating.mean(), linewidth=4, color='g', label=\"mean\")\nplt.axvline(x=df.Rating.median(), linewidth=4, color='r', label=\"median\")\nplt.xlabel(\"App Ratings\")\nplt.ylabel(\"Count\")\nplt.title(\"Histogram of App Ratings\")\nplt.legend([\"mean\", \"median\"])\nplt.show()","030ee40c":"#look at the ratings per app category in a sequential order\n\n#prepare data and sort\nnew_df = df.groupby(\"Category\").Rating.mean().reset_index() #average ratings per category\nsorted_df = new_df.sort_values(by=[\"Rating\"], ascending=True)  #sort by rating in descending order\n\nsns.set(font_scale=1.5, style=\"whitegrid\")\nf, axes = plt.subplots(figsize=(15, 6), sharex=True)\n\n#since we have categorical data in the x axis, we will look data with a barplot\nax = sns.barplot(x=\"Category\", y=\"Rating\", data=sorted_df, palette=\"Blues\") \nfor item in ax.get_xticklabels():\n    item.set_rotation(90) #rotate every xticklabels for readability\nax.set(ylim=(3.5,5)) #zoom in y axes since values are distributed around 4\nplt.xlabel(\"Average Rating\")\nplt.title(\"Average Rating per Category\", size=20)\n\n#look at the number of apps per category\nf, axes = plt.subplots(figsize=(15, 6), sharex=True)\n\n#since we are going to count # of apps per each category we are going to use barplot\nax = sns.countplot(x=\"Category\", data=df, palette=\"Set3\")\nplt.ylabel(\"Number of Apps\")\nplt.title(\"Number of Apps per Category\", size=20)\nfor item in ax.get_xticklabels():\n    item.set_rotation(90)","8eadcb0c":"#load data into numpy arrays\nbusiness = list(df[df.Category == \"BUSINESS\"].Rating)\ndating = list(df[df.Category == \"DATING\"].Rating)\n\n# 1) samples should be normally distributed: two samples resembles normal distribution\nsns.kdeplot(business)\nsns.kdeplot(dating)\nplt.title(\"Rating distributions\")\n\n# 2) 2 populations standard deviations must be equal: standard deviations are equal\nbusiness_array = np.asarray(business)\ndating_array = np.asarray(dating)\n\nprint(\"Standard deviation of business app ratings:\", business_array.std())\nprint(\"Standard deviation of dating app ratings:\", dating_array.std())\n\n# 3) two distributions are already independent from each other","62dee681":"from scipy.stats import ttest_ind #import statistics library to run the tests\n#confidence interval: 95%\n#setting confidence interval sets our alpha (treshold value) = 1-0.95 = 0.05\n\n#Null Hypothesis: Difference in the mean rating of Business and Dating apps are due to a random chance\n#Alternative Hypothesis: Mean rating of Business and Dating apps are significantly different\n\n#p-value = when it is assumed that our null hypothesis is correct, p value gives us the probability of\n#getting a sample with the results we assumed.\n\n#run the 2 sample test:\n\n_, pvalue = ttest_ind(business, dating)\nif pvalue <= 0.05:\n    print(\"Reject Null Hypothesis\")\nelse:\n    print(\"Accept Null Hypothesis\") ","4f8c0cd2":"#remember that # of reviews are in object dtype\ndf.Reviews = df.Reviews.apply(lambda x: int(x)) #convert object into int\n\n#look at the total reviews per install category\ntotal_reviews = df.groupby('Installs').Reviews.sum().reset_index()\nsorted_total_reviews = total_reviews.sort_values(by='Reviews', ascending=False).reset_index(drop=True)\nprint(sorted_total_reviews.head(5))","522e0bee":"#look at the distribution of the reviews per top-review install category\n#since this a distribution per categorical data boxplot will be plotted\ng = sns.catplot(x=\"Installs\",\n                y=\"Reviews\",\n                data=df[(df.Installs == \"1,000,000,000+\") | (df.Installs == \"500,000,000+\") | \n                        (df.Installs == \"100,000,000+\")], \n                kind=\"box\", height = 8 ,palette = \"Set2\")\nplt.ticklabel_format(style='plain', axis='y')\n#g.set_yticklabels([\"0\",\"10M\", \"20M\", \"30M\", \"40M\", \"50M\", \"60M\", \"70M\", \"80M\"])\nplt.title(\"Distribution of Reviews for Popular Apps\", size=20)","e841af88":"print(df.App[df.Reviews>60000000].unique())","15227c0e":"#we are going to look the ratio of installs to review per app\n\ndf['Int_installs'] = df.Installs.replace(to_replace = ['\\,','\\+'], value=['',''], regex=True) \n#create new column, remove special characters for integer conversion\n\ndf.Int_installs = df.Int_installs.astype('int64') \n#change data type from string to integer\n\ndf['Review_to_Install_Ratio'] = df.Reviews \/ df.Int_installs","40420b20":"#then plot the distribution per each popular install category\nf, axes = plt.subplots(1, 3, figsize=(35, 10), sharex=True) #set the plotsize, divide plot into 3 columns\n\ng1 = sns.kdeplot(df.Review_to_Install_Ratio[df.Installs == \"1,000,000,000+\"], shade=True, ax=axes[0], color=\"blue\")\ng1.title.set_text(\"Distriution of Reviews per Download in 1 Billion Installed Apps\")\n\ng2 = sns.kdeplot(df.Review_to_Install_Ratio[df.Installs == \"500,000,000+\"], shade=True, ax=axes[1], color=\"green\")\ng2.title.set_text(\"Distriution of Reviews per Download in 500 Million Installed Apps\")\n\ng3 = sns.kdeplot(df.Review_to_Install_Ratio[df.Installs == \"100,000,000+\"], shade=True, ax=axes[2],color=\"red\")\ng3.title.set_text(\"Distriution of Reviews per Download in 100 Million Installed Apps\")","b9b8dbfe":"#plot a swarmplot since there are multiple categories (Installs and Type)\nsns.set(font_scale=1.5, style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(30,20))\nax = sns.swarmplot(x=\"Installs\", y=\"Rating\", data=df, hue=\"Type\", palette=\"Set2\", dodge=True)\nfor item in ax.get_xticklabels():\n    item.set_rotation(45)\nplt.title(\"Ratings per Type and Install Category\", size=20)","10383f5e":"# plot a pie chart\nlabels = df.Type.unique() #set labels\nsizes = [len(df[df.Type == \"Free\"]), len(df[df.Type == \"Paid\"])] #count the number of free and paid apps\nexplode = (0, 0.2) #emphasize \"Paid\" apps\n\nfig1, ax1 = plt.subplots()\nax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=90, colors=[\"palegreen\",\"orangered\"]) #plot pie chart\nax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.\n\nplt.show() #render plot\n","519429b4":"#we are going to plot multiple linear regressions to answer this question\n#linear regression looks for the correlation between continuous variables\n#price was string so change it to integer\n\ndf['Decimal_price'] = df.Price.replace(to_replace = '\\$', value='', regex=True)\n#add new column and remove special characters\n\ndf.Decimal_price = df.Decimal_price.astype('float')\n#change to float\n\nfig, ax = plt.subplots(figsize=(14,8))\nsns.regplot(x=\"Decimal_price\", y=\"Rating\", data=df)\nplt.title(\"Price VS Rating\", size=20)","c576fe35":"#look at the price distribution to determine price bins\ng2 = sns.distplot(df.Decimal_price, hist=False, color=\"orange\", kde_kws={\"shade\": True})\nplt.axvline(x=df.Decimal_price.mean(), c=\"g\", linewidth=1)\nplt.title(\"Price Distribution\")\nprint(\"Mean price in the dataframe is:\", df.Decimal_price.mean())","c1c73845":"#price shows a bimodal distribution around 0 and 400 with a right-skew\n#we are going to group price data into 10 categories\n#I am going to create more categories around 0\ndef categorize(x):\n    if x==0:\n        return 0\n    if (x > 0) & (x < 0.5):\n        return 1\n    if (x >= 0.5) & (x < 1):\n        return 2\n    if (x>=1) &  (x < 2):\n        return 3\n    if (x>=2) &  (x < 3):\n        return 4\n    if (x>=3) &  (x < 5):\n        return 5\n    if (x>=5) &  (x < 10):\n        return 6\n    if (x>=10) &  (x < 25):\n        return 7\n    if (x>=25) &  (x < 100):\n        return 8\n    else:\n        return 9","a1d336f7":"#change price data into categorical data\n#plot lmplot since we have changed the data into categorical data\ndf[\"Categorical_price\"] = df.Decimal_price.apply(categorize)\nsns.lmplot(x=\"Categorical_price\", y=\"Rating\", data=df, height=8.27, aspect=14.1\/8.27)\nplt.title(\"Categorical Price VS Rating\")","7e227e80":"#look at the last updated column\nprint(df['Last Updated'].head())\n\n#change the date column to a date format from object type\ndf[\"Update_date\"] = df['Last Updated'].apply(lambda x: dt.strptime(x, '%B %d, %Y').date()) \n\n#fetch update year from date\ndf[\"Update_year\"] = df[\"Update_date\"].apply(lambda x: x.strftime('%Y')).astype('int64') \n\nfig, ax = plt.subplots(figsize=(14,8))\nsns.regplot(x=\"Update_year\", y=\"Rating\", data=df)\nplt.title(\"Update Year VS Rating\")","d990626b":"print(len(df.Genres.unique()))\nprint(df.Genres.unique())\n#looks like we have genres and its sub genre seperated by semi colons, format is:\n#main_genre; sub_genre\n\nprint(df[\"Content Rating\"].unique())\n#we have 5 content ratings and one not categorized:\n#unrated","ed83d85f":"#divide genre columns and clean Content Rating\ndf[\"Main_genre\"] = df.Genres.apply(lambda x: x.split(\";\")[0])\ndf[\"Sub_genre\"] = df.Genres.apply(lambda x: x.split(\";\")[1] if x.find(\";\")>0 else \"NA\")\ndf[\"Content Rating\"] =df[\"Content Rating\"].replace(to_replace = 'Unrated', value='Everyone', regex=True)","523036bf":"#we are going to look at the data with the stacked bars with pandas dataframe\n#create count view per main_genre and content rating\ndf_by_main_genre = df.groupby([\"Main_genre\", \"Content Rating\"]).count().reset_index().sort_values(\n    by=[\"App\"], ascending=False).reset_index()\n\n#select relevant columns\ndf_by_main_genre= df_by_main_genre[[\"Main_genre\", \"Content Rating\", \"App\"]]\n\n#reshape data to plot stacked bars\ndf_pivoted = df_by_main_genre.pivot(columns=\"Content Rating\", index=\"Main_genre\", values=\"App\")\ncolors = [\"#9b59b6\", \"#3498db\", \"#95a5a6\", \"#e74c3c\", \"#34495e\", \"#2ecc71\"]\ndf_pivoted.loc[:,df[\"Content Rating\"].unique()].plot.bar(stacked=True, color=colors, figsize=(20,10))\nplt.ylabel(\"Count\")\nplt.title(\"Genre and Content Rating\")","7d4f81e3":"#remember that size column was string object type\nprint(df.Size.unique())\n#sizes differs between KBs and MBs and we have one object column \"varies with device\"","542e6065":"def convert_to_MB(df_column):\n    if df_column == \"Varies with device\":\n        result = np.NaN\n    elif \"k\" in df_column:\n        result = float(df_column.split(\"k\")[0])*0.001 \n    elif \"M\" in df_column:\n        result = float(df_column.split(\"M\")[0]) \n    return result","02894ea6":"# \"varies with device\" column will be replaced with NA values for now\n# convert every size to MB and float number\n#fill NA sizes wtih average size\n\ndf[\"Size_in_MB\"]=df.Size.apply(convert_to_MB)\ndf[\"Size_in_MB\"].fillna(value=df.Size_in_MB.mean(), inplace=True)\n\n#plot boxplot bacause we are interested in the distribution of each app per main genre\nfig, ax = plt.subplots(figsize=(20,16))\nsns.boxenplot(x='Main_genre', y='Size_in_MB', data=df, palette=\"Set2\")\nfor item in ax.get_xticklabels():\n    item.set_rotation(90)\nplt.title(\"Distribution of App Sizes per Genre\", size=20)\n","a6955f89":"## App Size - Genre\n\nLooks like following genres' apps differs in size in a wider range\n\n* Action\n* Strategy\n* Role Playing\n* Educational\n* Strategy","6786ded8":"## Rating per Install Category and Type\n* Looks like rating is distributed around 4.5 when its categorized per install category\n* Google play store have very few paid apps","0b1647fc":"# 12) How sizes per genre differ?","7498d904":"Apps having reviews greater than 60M","a5981c0e":"# 6) What is the distribution of rating per number of installs and type (paid or free) ?","b19bd755":"# 1) How the ratings of the Apps look like?","dfaa321b":"## Price VS Rating\n* Yes, as the price increases ratings received seems to decrease even below the average rating in the appstore\n* Looks like apps either has a price lower than 100, or price greater than 300","3d542073":"## Categorical Price - Rating\nWhen we approach prices with categories, we cannot achieve a signifcant correlation between price and rating","7d396a74":"## Reviews - Installs for popular apps\n* Since the distribution is concantrated around 0, we cannot conclude that every downloader leaves a review for a popular app\n* In the 100 Million Install Category, there are more reviews per download compared to other categories","124261e4":"# 8) Do we have a correlation between price of the app and rating?","1f4fd886":"# First glance of Google Play Store data","8615c457":"# 3) Business and Dating apps, is the average rating signifcantly different in each category?\n\n## To answer this we are going to look at following conditions:\n1. samples should be normally distributed\n2. 2 populations standard deviations must be equal\n3. Samples must be independent","b804d709":"# 7) What is the percentage of paid and free apps in Play Store?","0339b454":"## Apps - Reviews\n* Popular apps (apps having more than 100M installs) received more reviews in total\n* 1,000,000,000+ apps have more ditributed reviews\n* Apps downloaded more than 100M received more attention\n* 100M+ apps have more apps having outlier reviews","56293e46":"## Update Year - Rating\nlooks like as the app gets more recent updates chances of getting a higher rating increases","c6ab343d":"## Load data into a dataframe and observe initial rows","a490eeea":"# 4) If an app has high number of installs, does it mean that it gets the more reviews from the users?","feb5d4ca":"## Ratings - App Counts\n* App ratings per categpory are distributed between 4.0 and 4.5\n* Art_And_Design and Events category is having the least number of apps but they have the highest average rating\n* Game and Family category apps have outnumbered the other apps","069b7223":"# 5)  Does every popular app (Installs 100M+) receives a review from each download ? \n### Since we dont know the exact number of downloads this will be an approximate answer\n\n","7696510c":"# 10) Does the last update date has an effect on rating?","f321b19c":"# 2) What is the average rating per category, how many apps are there in each category?\n","2fee5387":"# 9) What if we only look price as a categorical data, does the price-rating correlation change?","3198a777":"## Ratings of Business and Dating Apps\nSince our p-value is less then our alpha(treshold) value, we are going to reject our null hypothesis concluding us, average rating of two categories are significantly different than each other.","1b081085":"# 11) Which genres addresses which audience ?","4bea8bd1":"## I asked several questions and searched for an answer for them, using:\n\n* Data reshaping and manipulation\n* Data cleaning\n* Data visualization","77a8ee3b":"# Exploratory Data Analysis Project on Google Play Store","51038d94":"## Observations from the first glance\n* None of the columns of the dataframe represents primary key\n* Dataframe had some NA values, those values are dropped\n* After the clean up data has 9360 rows and 13 columns\n* Columns have mixed data types, we might convert some of them in the coming steps\n\/n E.g. Last Updated is not a date type\n\n","f7777854":"## App Genre and Audience\n* Almost every app genre is for everyone\n* But dating apps are for mostly for mature individuals rather than everyone :)\n* Actions genre is mostly for Teens\n","1c4acddd":"## Import relevant Python libraries"}}