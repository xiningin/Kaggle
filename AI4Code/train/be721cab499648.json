{"cell_type":{"93dd029f":"code","8006f38f":"code","68c002ae":"code","769eb163":"code","31bb3f1d":"code","11206040":"code","a9374c91":"code","62386661":"code","98b253c1":"code","fac850bb":"code","337a68d0":"code","1148534c":"code","fb00abe3":"code","0a883bb3":"code","edb248c2":"code","298c858f":"code","00687960":"code","d4d86d90":"markdown","3962d833":"markdown","5e2b1b39":"markdown","bead563f":"markdown","7feb54d0":"markdown"},"source":{"93dd029f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8006f38f":"import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom sklearn.preprocessing import StandardScaler","68c002ae":"from sklearn.datasets import load_boston\n\nboston = load_boston()","769eb163":"df = pd.DataFrame(boston.data, columns=boston.feature_names)\ndf['TARGET'] = boston.target\ndf.tail()","31bb3f1d":"scaler = StandardScaler()\n# fit = train mu, sigma\nscaler.fit(df.values[:, :-1]) # get numpy.ndarray values except TARGET(y)\n# transfor = apply mu, sigma then make it to unit gausian N(0, 1)\ndf.values[:, :-1] = scaler.transform(df.values[:, :-1])\n\ndf.tail()","11206040":"import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim","a9374c91":"data = torch.from_numpy(df.values).float()\n\ndata.shape","62386661":"x = data[:, :-1] # Except the last column\ny = data[:, -1:] # The last column\n\nprint(x.shape, y.shape)","98b253c1":"n_epochs = 100000\nlearning_rate = 1e-4\nprint_interval = 5000","fac850bb":"relu = nn.ReLU()\nleaky_relu = nn.LeakyReLU(0.1)","337a68d0":"class MyModel(nn.Module):\n    \n    def __init__(self, input_dim, output_dim):\n        self.input_dim = input_dim\n        self.output_dim = output_dim\n        \n        super().__init__()\n        \n        # 2 hidden Layers, 3 linears\n        \n        self.linear1 = nn.Linear(input_dim, 3)\n        self.linear2 = nn.Linear(3, 3)\n        self.linear3 = nn.Linear(3, output_dim)\n        self.act = nn.ReLU()\n        \n        def forward(self, x):\n            # \/x\/ = (batch_size, input_dim)\n            h = self.act(self.linear1(x)) # \/h\/ = (batch_size, 3)\n            h = self.act(self.linear2(h))\n            y = self.linear3(h)\n            # \/y\/ = (batch_size, output_dim)\n            \n            return y","1148534c":"model = MyModel(x.size(-1), y.size(-1)) # input are dimension of x, y\nmodel","fb00abe3":"# simple define for simple model (6 Layers)\nmodel = nn.Sequential(\n    nn.Linear(x.size(-1), 3),\n    nn.LeakyReLU(),\n    nn.Linear(3, 3),\n    nn.LeakyReLU(),\n    nn.Linear(3, 3),\n    nn.LeakyReLU(),\n    nn.Linear(3, 3),\n    nn.LeakyReLU(),\n    nn.Linear(3, 3),\n    nn.LeakyReLU(),\n    nn.Linear(3, y.size(-1)) # skip activation function\n)","0a883bb3":"model","edb248c2":"optimizer = optim.SGD(model.parameters(),\n                      lr=learning_rate)","298c858f":"for i in range(n_epochs):\n    y_hat = model(x)\n    loss = F.mse_loss(y_hat, y)\n    \n    optimizer.zero_grad() # parameter initialize\n    loss.backward() # differential\n    \n    optimizer.step() # parmeter update\n    \n    if (i + 1) % print_interval == 0:\n        print('Epoch %d: loss=%.4e ' % (i + 1, loss))","00687960":"df = pd.DataFrame(torch.cat([y, y_hat], dim=1).detach().numpy(),\n                  columns=['y', 'y_hat'])\n\nsns.pairplot(df, size=5)\nplt.show()\n","d4d86d90":"# **Regression using Deep Neural Networks**\n\n### Load Dagaset from sklearn","3962d833":"## Train Model with PyTorch","5e2b1b39":"## Build Models\n\n### Build Model using nn.Module","bead563f":"## Build Model with LeakyReLU using nn.Sequential","7feb54d0":"## Let's see the result"}}