{"cell_type":{"140e8808":"code","547ee363":"code","4d8528a2":"code","dee6985e":"code","290b395e":"code","8f1bf403":"code","428963af":"code","5366ed0a":"code","ec516fdd":"code","8226b577":"code","a9940609":"code","29193deb":"code","c4853a41":"code","a4e4bde0":"code","a8b7cbce":"code","9d04ed00":"code","c0ebd0d3":"code","4df4059f":"code","361f88f5":"code","37e79a65":"code","f3b6e1f5":"code","3c10892c":"markdown","1c5a4f77":"markdown","9859ccbc":"markdown","ae9c59bd":"markdown","bf160f69":"markdown","daece51e":"markdown","87cd87f8":"markdown","c9117058":"markdown","0939c246":"markdown","dd77a05a":"markdown","79092d6a":"markdown","6c34cfa1":"markdown","886d2df3":"markdown","a258eaa3":"markdown","f9c2234e":"markdown","6c9862ba":"markdown"},"source":{"140e8808":"import pandas as pd \nimport cv2                 \nimport numpy as np         \nimport os                  \nfrom random import shuffle\nfrom tqdm import tqdm  \nimport scipy\nimport skimage\nfrom skimage.transform import resize\nfrom keras.utils.np_utils import to_categorical\nimport matplotlib.pyplot as plt\n# deep learning stuff\nfrom keras.models import Sequential , Model\nfrom keras.layers import Dense , Activation\nfrom keras.layers import Dropout , GlobalAveragePooling2D\nfrom keras.layers import Flatten\nfrom keras.constraints import maxnorm\nfrom keras.optimizers import SGD , RMSprop , Adadelta , Adam\nfrom keras.layers import Conv2D , BatchNormalization\nfrom keras.layers import MaxPooling2D\nfrom keras.utils import np_utils\nfrom keras import backend as K\nK.set_image_dim_ordering('th')\nfrom sklearn.model_selection import GridSearchCV\nfrom keras.wrappers.scikit_learn import KerasClassifier\nfrom keras.callbacks import ReduceLROnPlateau , ModelCheckpoint , LearningRateScheduler\nfrom keras.applications.inception_v3 import InceptionV3 # for transfer learning\nprint(os.listdir(\"..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/\"))\n\n","547ee363":"TRAIN_DIR = \"..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/train\/\"\nTEST_DIR =  \"..\/input\/chest-xray-pneumonia\/chest_xray\/chest_xray\/test\/\"\n","4d8528a2":"def get_label(Dir):\n    for nextdir in os.listdir(Dir):\n        if not nextdir.startswith('.'):\n            if nextdir in ['NORMAL']:\n                label = 0\n            elif nextdir in ['PNEUMONIA']:\n                label = 1\n            else:\n                label = 2\n    return nextdir, label","dee6985e":"def preprocessing_data(Dir):\n    X = []\n    y = []\n    \n    for nextdir in os.listdir(Dir):\n        nextdir, label = get_label(Dir)\n        temp = Dir + nextdir\n        \n        for image_filename in tqdm(os.listdir(temp)):\n            path = os.path.join(temp + '\/' , image_filename)\n            img = cv2.imread(path,cv2.IMREAD_GRAYSCALE)\n            if img is not None:\n                img = skimage.transform.resize(img, (150, 150, 3))\n                img = np.asarray(img)\n                X.append(img)\n                y.append(label)\n            \n    X = np.asarray(X)\n    y = np.asarray(y)\n    \n    return X,y","290b395e":"def get_data(Dir):\n    X = []\n    y = []\n    for nextDir in os.listdir(Dir):\n        if not nextDir.startswith('.'):\n            if nextDir in ['NORMAL']:\n                label = 0 # Normal class, image is okay\n            elif nextDir in ['PNEUMONIA']:\n                label = 1 #abnormal Image has pneumonia\n            else:\n                label = 2\n                \n            temp = Dir + nextDir\n                \n            for file in tqdm(os.listdir(temp)):\n                img = cv2.imread(temp + '\/' + file)\n                if img is not None:\n                    img = skimage.transform.resize(img, (150, 150, 3))\n                    #img_file = scipy.misc.imresize(arr=img_file, size=(299, 299, 3))\n                    img = np.asarray(img)\n                    X.append(img)\n                    y.append(label)\n                    \n    X = np.asarray(X)\n    y = np.asarray(y)\n    return X,y","8f1bf403":"X_train, y_train = get_data(TRAIN_DIR)\n","428963af":"X_test , y_test = get_data(TEST_DIR)","5366ed0a":"\n\nprint(X_train.shape,'\\n',X_test.shape)\nprint(y_train.shape,'\\n',y_test.shape)","ec516fdd":"y_train = to_categorical(y_train, 2)\ny_test = to_categorical(y_test, 2)","8226b577":"pneumonia_images = os.listdir(TRAIN_DIR + \"PNEUMONIA\")\nNormal_images = os.listdir(TRAIN_DIR + \"NORMAL\")","a9940609":"def plotter(i):\n    imagep1 = cv2.imread(TRAIN_DIR+\"PNEUMONIA\/\"+pneumonia_images[i])\n    imagep1 = skimage.transform.resize(imagep1, (150, 150, 3) , mode = 'reflect')\n    imagen1 = cv2.imread(TRAIN_DIR+\"NORMAL\/\"+Normal_images[i])\n    imagen1 = skimage.transform.resize(imagen1, (150, 150, 3))\n    pair = np.concatenate((imagen1, imagep1), axis=1)\n    print(\"(Left) - No Pneumonia Vs (Right) - Pneumonia\")\n    print(\"-----------------------------------------------------------------------------------------------------------------------------------\")\n    plt.figure(figsize=(10,5))\n    plt.imshow(pair)\n    plt.show()\nfor i in range(5,10):\n    plotter(i)","29193deb":"lr_reduce = ReduceLROnPlateau(monitor='val_acc', factor=0.1, min_delta=0.0001, patience=1, verbose=1)","c4853a41":"filepath=\"transferlearning_weights.hdf5\"\ncheckpoint = ModelCheckpoint(filepath, monitor='val_acc', verbose=1, save_best_only=True, mode='max')","a4e4bde0":"X_train=X_train.reshape(5216,3,150,150)\nX_test=X_test.reshape(624,3,150,150)","a8b7cbce":"base_diagnosis_model = InceptionV3(weights=None, include_top=False , input_shape=(3, 150, 150)) # dont include top to allow transfer \n# learning and allow custom clasification\nx = base_diagnosis_model.output\nx = Dropout(0.5)(x)\nx = GlobalAveragePooling2D()(x)\nx = Dense(128, activation='relu')(x)\nx = BatchNormalization()(x)\npredictions = Dense(2, activation='sigmoid')(x)","9d04ed00":"base_diagnosis_model.load_weights(\"..\/input\/inception-weights-no-top\/inception_v3_weights_notop.h5\")","c0ebd0d3":"model = Model(inputs=base_diagnosis_model.input, outputs=predictions)\n#   for layer in base_model.layers:\n#         layer.trainable = False\n        \n        \nfor layer in model.layers[:200]:\n    layer.trainable = False\nfor layer in model.layers[200:]:\n    layer.trainable = True\n    \nmodel.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\nprint(model.summary())","4df4059f":"batch_size = 64\nepochs = 10\nhistory = model.fit(X_train, y_train, validation_data = (X_test , y_test) ,callbacks=[lr_reduce,checkpoint] ,\n          epochs=epochs)","361f88f5":"model.load_weights(\"transferlearning_weights.hdf5\")","37e79a65":"\nplt.plot(history.history['acc'])\nplt.plot(history.history['val_acc'])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()\n# summarize history for loss\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.legend(['train', 'test'], loc='upper left')\nplt.show()","f3b6e1f5":"from sklearn.metrics import confusion_matrix, classification_report\npred = model.predict(X_test)\npred = np.argmax(pred,axis = 1) \ny_true = np.argmax(y_test,axis = 1)\ncls_report = classification_report(y_true, pred)\n# print classification report\nprint(\"\\n\\n\")\nprint(\"-\"*50)\nprint(\"Report for Transfer Learning Task: \")\nprint(\"-\"*50)\nprint(cls_report)\nprint(\"-\"*50)","3c10892c":"Import the Inception V3 model without weights to allow transfer learning. Define the input shape of the images","1c5a4f77":"Define Image set","9859ccbc":"Save the best model(highest validation acc) in a .h5 file using the Model checkpoint callback.","ae9c59bd":"Load the best weights attained and stored in h5. Loading the weights from the weights='imagenet' parameter was not possible hence, download weights independently and load the file.\nDownload link at [here](https:\/\/github.com\/fchollet\/deep-learning-models\/releases\/download\/v0.5\/inception_v3_weights_tf_dim_ordering_tf_kernels_notop.h5)\n","bf160f69":"There are 3 possible approaches. Allow the whole network to train,\nMake the whole of the inception network non trainable and only train the top layer\nCombine the upper 2 and train only the last layers plus the added layers on the inception model\nDefine model and compile. Display model summary","daece51e":"Retrieve Data","87cd87f8":"Plot the images for visualization","c9117058":"Define a get label function","0939c246":"Load the best weights saved by the ModelCheckPoint callback","dd77a05a":"Plot confudion matrix to determine false +ves and false -ves\nWe are using np.argmax since the output will be a 2x1 vector of probabilities and the index chosen is the class label which the model thinks it is the right answer.","79092d6a":"View Loaded data","6c34cfa1":"Plot model metrics during training and testing for visualization","886d2df3":"Since we have set the dimension ordering to th(Theano), we will have to reshape our dataset to a channel first order","a258eaa3":"Define epochs and batch size then train the model","f9c2234e":"Convert labels to categorical data type","6c9862ba":"Data Pre-processing"}}