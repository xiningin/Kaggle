{"cell_type":{"7d8ea190":"code","bb8edd82":"code","629e03b1":"code","8ecd8c01":"code","e061a614":"code","dad3e684":"code","44e0e911":"code","58748389":"code","dc4bf1e1":"code","59a046e3":"code","28a09ca0":"code","f7c026f1":"code","a4f6a9e3":"code","1926709f":"code","47889f33":"code","95a6d6f7":"code","fbe2892a":"code","7619fe07":"code","4eaa1791":"code","0b75017f":"code","dbbda25e":"code","0fd87612":"code","1726f708":"code","4caf93bb":"code","9eaddf75":"code","a5e11b54":"code","adc9be79":"code","ca1a9ca4":"code","61f1fbde":"code","4b173401":"code","f1e7df7c":"code","45330755":"code","0908b890":"code","d9e1155f":"code","edd645fa":"code","d9feacee":"code","220a71e9":"code","98b190cf":"code","7db6c069":"code","ac415f13":"code","9cf4c323":"code","1705c127":"markdown","15f0b154":"markdown","c32c937e":"markdown"},"source":{"7d8ea190":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os","bb8edd82":"from pathlib import Path\nimport json\nfrom random import randint\nfrom collections import Counter\nfrom collections import defaultdict","629e03b1":"import json \nfrom PIL import Image, ImageDraw\nfrom IPython.display import display\nfrom shapely import wkt\nfrom shapely.geometry.multipolygon import MultiPolygon","8ecd8c01":"import matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nfrom matplotlib import rcParams\nfrom copy import copy \n\n%matplotlib inline\n# figure size in inches optional\nrcParams['figure.figsize'] = 30, 30\nplt.rcParams['legend.title_fontsize'] = 14","e061a614":"# CODE FOR THIS CELL IS TAKEN FROM https:\/\/www.kaggle.com\/alexisbcook\/interactive-maps\nimport folium\nfrom folium import Choropleth, Circle, Marker\nfrom folium.plugins import HeatMap, MarkerCluster","dad3e684":"# CODE FOR THIS CELL IS TAKEN FROM https:\/\/www.kaggle.com\/alexisbcook\/interactive-maps\n# Function for displaying the map\ndef embed_map(m, file_name):\n    from IPython.display import IFrame\n    m.save(file_name)\n    return IFrame(file_name, width='100%', height='500px')","44e0e911":"# Fetch all post disaster json files\nlabels_generator = Path('..\/input').rglob(pattern=f'*post_*.json')","58748389":"# Group json files by disaster\ndef get_disaster_dict(labels_generator):    \n    disaster_dict = defaultdict(list)\n    for label in labels_generator:\n        disaster_type = label.name.split('_')[0]\n        disaster_dict[disaster_type].append(str(label))\n    return disaster_dict","dc4bf1e1":"disaster_dict = get_disaster_dict(labels_generator)","59a046e3":"# List of Disasters present in the dataset\ndisaster_dict.keys()","28a09ca0":"# Select a particular disaster\ndisaster_labels = disaster_dict['joplin-tornado']","f7c026f1":"def read_label(label_path):\n    with open(label_path) as json_file:\n        image_json = json.load(json_file)\n        return image_json","a4f6a9e3":"# Color codes for polygons\ndamage_dict = {\n    \"no-damage\": (0, 255, 0, 50),\n    \"minor-damage\": (0, 0, 255, 50),\n    \"major-damage\": (255, 69, 0, 50),\n    \"destroyed\": (255, 0, 0, 50),\n    \"un-classified\": (255, 255, 255, 50)\n}","1926709f":"def get_damage_type(properties):\n    if 'subtype' in properties:\n        return properties['subtype']\n    else:\n        return 'no-damage'","47889f33":"def annotate_img(draw, coords):\n        wkt_polygons = []\n\n        for coord in coords:\n            damage = get_damage_type(coord['properties'])\n            wkt_polygons.append((damage, coord['wkt']))\n\n        polygons = []\n\n        for damage, swkt in wkt_polygons:\n            polygons.append((damage, wkt.loads(swkt)))\n\n        for damage, polygon in polygons:\n            x,y = polygon.exterior.coords.xy\n            coords = list(zip(x,y))\n            draw.polygon(coords, damage_dict[damage])\n\n        del draw","95a6d6f7":"def display_img(json_path, time='post', annotated=True):\n    if time=='pre':\n        json_path = json_path.replace('post', 'pre')\n        \n    img_path = json_path.replace('labels', 'images').replace('json','png')\n        \n    image_json = read_label(json_path)\n    img_name = image_json['metadata']['img_name']\n        \n    print(img_name)\n    \n    img = Image.open(img_path)\n    draw = ImageDraw.Draw(img, 'RGBA')\n    \n    if annotated:\n        annotate_img(draw, image_json['features']['xy'])\n\n    return img","fbe2892a":"def plot_image(label):\n\n    # read images\n    img_A = display_img(label, time='pre', annotated=False)\n    img_B = display_img(label, time='post', annotated=False)\n    img_C = display_img(label, time='pre', annotated=True)\n    img_D = display_img(label, time='post', annotated=True)\n\n\n    # display images\n    fig, ax = plt.subplots(2,2)\n    fig.set_size_inches(30, 30)\n    TITLE_FONT_SIZE = 24\n    ax[0][0].imshow(img_A);\n    ax[0][0].set_title('Pre Diaster Image (Not Annotated)', fontsize=TITLE_FONT_SIZE)\n    ax[0][1].imshow(img_B);\n    ax[0][1].set_title('Post Diaster Image (Not Annotated)', fontsize=TITLE_FONT_SIZE)\n    ax[1][0].imshow(img_C);\n    ax[1][0].set_title('Pre Diaster Image (Annotated)', fontsize=TITLE_FONT_SIZE)\n    ax[1][1].imshow(img_D);\n    ax[1][1].set_title('Post Diaster Image (Annotated)', fontsize=TITLE_FONT_SIZE)\n    plt.savefig('split_image.png', dpi = 100)\n    plt.show()","7619fe07":"disaster_labels[0]","4eaa1791":"# Display a single image using label path. \n# `time` argument shows post or pre disaster images\n# `annotated` argument labels images\ndisplay_img(disaster_labels[0], time='post', annotated=True)","0b75017f":"# Get polygons center coords (lat, long)\ndef get_centroid(coords):\n    polygons = [ wkt.loads(polygon['wkt']) for polygon in coords ]\n    centroid =  MultiPolygon(polygons).centroid\n    try:\n        return {'centroid_x': centroid.x, 'centroid_y': centroid.y, 'latlong': centroid }\n    except IndexError as e:\n        return {'centroid_x': None, 'centroid_y': None, 'latlong': None }","dbbda25e":"def get_damage_dict(coords):\n    damage_list = [ get_damage_type(coord['properties']) for coord in coords]\n    return Counter(damage_list)","0fd87612":"# Add centroid and damage dict to metadata\ndef metadata_with_damage(label_path):\n    data = read_label(label_path)\n    coords = data['features']['lng_lat']\n    \n    damage_dict = get_damage_dict(coords)\n    centroid = get_centroid(coords)\n    \n    data['metadata'].update(centroid)\n    data['metadata']['path'] = label_path\n    data['metadata'].update(damage_dict)\n    return data['metadata']\n        \n    ","1726f708":"def generate_metadata_df(disaster_labels):\n    metadata_list = [metadata_with_damage(label_path) for label_path in disaster_labels]\n    df = pd.DataFrame(metadata_list)\n    return df.fillna(df.mean())","4caf93bb":"# Sort df by destroyed count\ndf = generate_metadata_df(disaster_labels)\nsorted_df = df.sort_values(by=['destroyed'], ascending=False)","9eaddf75":"sorted_df","a5e11b54":"df_generator = sorted_df.iterrows()","adc9be79":"# Generate Google Maps link to location\nfrom IPython.core.display import display, HTML\ndef generate_gmaps_link(lat, long):\n    link = f\"https:\/\/www.google.com\/maps\/@?api=1&map_action=map&center={lat},{long}&zoom=18&basemap=satellite\"\n    return HTML(f\"\"\"<a href=\"{link}\" target=\"_blank\">{link}<\/a>\"\"\")","ca1a9ca4":"# fetch first row (most damaged location)\nindex, row = next(df_generator)","61f1fbde":"# provides google maps link\ngenerate_gmaps_link(row.centroid_y, row.centroid_x)","4b173401":"# Shows damage polygon counts for image\nrow[['no-damage', 'minor-damage', 'major-damage', 'destroyed', 'un-classified']]","f1e7df7c":"# shows pre disaster image\ndisplay_img(row.path, time='pre', annotated=True)","45330755":"# shows post disaster image\ndisplay_img(row.path, time='post', annotated=True)","0908b890":"# plots pre and post disaster images with annotations\nplot_image(row.path)","d9e1155f":"def generate_circle(row):\n    \n    COLOR_MAP = {\n        \"no-damage\": 'green',\n        \"minor-damage\": 'blue',\n        \"major-damage\": '#ffff00',\n        \"destroyed\": 'red',\n        \"un-classified\": 'black'\n    }\n    \n    for damage_type, color in COLOR_MAP.items():\n        yield Circle(\n            location=row.loc[['centroid_y','centroid_x']].tolist(),\n            radius=row.loc[damage_type],\n            color=color)","edd645fa":"location = df.mean().loc[['centroid_y','centroid_x']].tolist()","d9feacee":"# CODE FOR THIS CELL IS TAKEN FROM https:\/\/www.kaggle.com\/alexisbcook\/interactive-maps\n\n# mean latitude and longitude\n# Create a map\nm_2 = folium.Map(location=location, tiles='openstreetmap', zoom_start=13)\n\n# Add points to the map\nfor idx, row in df.iterrows():\n    generator = generate_circle(row)\n    for circle in generator:\n        circle.add_to(m_2)\n\n# Display the map\nembed_map(m_2, 'm_2.html')","220a71e9":"labels_generator = Path('..\/input').rglob(pattern=f'*.json')\nfull_df = generate_metadata_df(labels_generator)","98b190cf":"# plot bargraph based on an agg_func\ndef plot_bargraph(df, x, y, agg_func):\n  new_df = df.groupby('disaster', as_index=False).agg(agg_func)\n\n  for index, row in new_df.iterrows():\n    plt.bar(row.disaster, row.gsd, label=row.disaster, align='center')\n    \n#   plt.legend(loc=1,prop={'size':18})\n\n  plt.xticks(fontsize=22, rotation=90)\n  fig = plt.gcf()\n  fig.set_size_inches(30, 30)\n  plt.savefig(f'{agg_func}.png', dpi=100)\n  plt.show()","7db6c069":"plot_bargraph(full_df, x='disaster', y='gsd', agg_func='mean')","ac415f13":"# Mean GSD for dataset\nfull_df['gsd'].mean()","9cf4c323":"plot_bargraph(full_df, x='disaster', y='gsd', agg_func='count')","1705c127":"**Damaged Locations on Map**\n\nThis Map displays the affected locations by their damage type","15f0b154":"**Mean GSD by grouped by Disater**\n\nThe Ground Sampling Distance will help us get an idea on the spatial resolution of the images per disaster. This has help us normalize the images to a specific resolution during training.","c32c937e":"**Number of images per Disaster**\n\nThe number of datapoints per dataset will give us an idea on which disaster to focus on while training our model."}}