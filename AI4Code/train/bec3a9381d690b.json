{"cell_type":{"b3ea4f25":"code","16996ba6":"code","59bd50b5":"code","5f729e6a":"code","f2566be0":"code","0fec04f8":"code","75de80d6":"code","74b3d7b3":"code","e578d3ce":"code","df1b5d34":"code","404f85f1":"code","90226df3":"code","d3b3256d":"markdown","e26658e8":"markdown","350ac9b0":"markdown","9b30098a":"markdown","c134d95a":"markdown","ab13ef68":"markdown","ef27d67b":"markdown","58d03ddf":"markdown","7c65bb68":"markdown","8ffeedac":"markdown","d45c2e03":"markdown","cef71f84":"markdown","ac7b0664":"markdown","49c1b4b3":"markdown","36477e9c":"markdown"},"source":{"b3ea4f25":"class BinaryTree:\n    _value = None\n    _left = None\n    _right = None\n    \n    def __init__(self, value):\n        self._value = value\n        \n    def set_left(self, node):\n        self._left = node\n    \n    def set_right(self, node):\n        self._right = node\n        \n    def get_left(self):\n        return self._left\n    \n    def get_right(self):\n        return self._right\n    \n    def get_value(self):\n        return self._value\n     \n    def set_value(self, value):\n        self._value = value\n    ","16996ba6":"A9 = BinaryTree(9)\nA10 = BinaryTree(10)\nA14 = BinaryTree(14)\nA19 = BinaryTree(19)\nA20 = BinaryTree(20)\nA23 = BinaryTree(23)\nA25 = BinaryTree(25)\nA29 = BinaryTree(29)\nA27 = BinaryTree(27)\nA36 = BinaryTree(36)\nA39 = BinaryTree(39)\n\nra\u00edz = A25\nra\u00edz.set_left(A14)\nA25.set_right(A36)\nA14.set_left(A9)\nA14.set_right(A19)\nA36.set_left(A29)\nA36.set_right(A39)\nA9.set_right(A10)\nA19.set_right(A23)\nA29.set_left(A27)\nA23.set_left(A20)\n","59bd50b5":"# R\/ ","5f729e6a":"# R\/","f2566be0":"# R\/","0fec04f8":"# R\/","75de80d6":"# R\/","74b3d7b3":"# R\/","e578d3ce":"# R\/","df1b5d34":"# R\/","404f85f1":"# R\/","90226df3":"# R\/","d3b3256d":"# \u00c1rboles\n\nEl \u00e1rbol es una de las estructuras no lineales m\u00e1s usada en ciencia de la computaci\u00f3n, es una estructura jer\u00e1rquica, donde un nodo padre tiene varios hijos.\n\nLo interesante es que cada hijo a su vez puede ser padre de otros hijos y as\u00ed sucesivamente.\n\nCada nodo representa un valor o un objeto en la estructura.\n\nLa ra\u00edz del \u00e1rbol es el nodo con m\u00e1s jerarqu\u00eda, es decir; el nodo que tiene hijos y no tiene un padre.\n\nCada nodo hijo es la ra\u00edz de un sub\u00e1rbol.\n\nSe le llama hoja a los nodos del \u00e1rbol que se ubican en la parte inferior del mismo, es decir; que no tengan hijos.\n\nSe le llama nodo interno a todos los nodos que tienen al menos un hijo, inclu\u00eddo el nodo ra\u00edz.\n\nCamino, es la secuencia de nodos por la cual se debe pasar para llegar desde un nodo a otro.\n\n![arboles.png](attachment:arboles.png)\n\n\n# \u00c1rboles Binarios\n\nUn \u00e1rbol binario es un \u00e1rbol de grado 2, es decir; es aquel donde se limita la cantidad de hijos que puede tener un nodo a m\u00e1ximo 2, un hijo al lado izquierdo y uno al lado derecho.\n\n![arbolbinario.png](attachment:arbolbinario.png)\n\nNativamente en python, no hay una representaci\u00f3n de \u00e1rboles, ni de \u00e1rboles binarios, por lo tanto se debe crear de cero una clase que lo represente.","e26658e8":"**Ejercicio 9.6.** Teniendo en cuanta la particularidad detectada, implemente el m\u00e9todo, insertar.","350ac9b0":"**Ejercicio 9.4.** Analice la funci\u00f3n del arbol creado de ejemplo. \u00bfNota alguna particularidad en los nodos?","9b30098a":"**R\/**","c134d95a":"**Ejercicio 9.7.** Realice un m\u00e9todo que busque un elemento en el \u00e1rbol.","ab13ef68":"**Ejercicio 9.9.** Implemente un esquema de clases que permita la eliminaci\u00f3n de nodos y modifique los m\u00e9todos creados con la nueva implementaci\u00f3n.","ef27d67b":"**Ejercicio 9.2.** Implementar un metodo donde se impriman los nodos del \u00e1rbol en *in-orden*, es decir, primero el nodo de la izquierda, luego el nodo actual y luego el nodo de la derecha.","58d03ddf":"**Ejercicio 9.1.** Implementar un metodo donde se impriman los nodos del \u00e1rbol en *pre-orden*, es decir, primero el valor del nodo actual, despu\u00e9s el nodo de la izquierda y luego el nodo de la derecha.","7c65bb68":"**Ejercicio 9.5.** Modifique la clase para que soporte de manera nativa, la particularidad detectada.","8ffeedac":"**Ejercicio 9.12.** Note que el \u00e1rbol del ejemplo est\u00e1 *desbalanceado*; es decir, hay nodos que tienen un solo hijo y este a su vez tiene uno o m\u00e1s hijos.  Esto suele ser un problema por que puede aumentar la complejidad en la b\u00fasqueda de un elemento a orden lineal.  Implemente un m\u00e9todo que cuando se inserte un elemento nuevo, el \u00e1rbol est\u00e9 balanceado.  Nota: Un \u00e1rbol balanceado es aquel que todos los nodos, exepto los del \u00faltimo nivel, tienen 2 nodos hijos.","d45c2e03":"**Ejercicio 9.10.** Implemente un m\u00e9todo que permita cambiar el valor de un elemento por otro.","cef71f84":"**Ejercicio 9.8.** Con la implementaci\u00f3n de arboles, \u00bfse puede eliminar cualquier nodo del \u00e1rbol? \u00bfPor qu\u00e9?","ac7b0664":"**R\/**","49c1b4b3":"**Ejercicio 9.11.** Implemente un m\u00e9todo que calcule el m\u00ednimo y otro que c\u00e1lcule el m\u00e1ximo.","36477e9c":"**Ejercicio 9.3.** Implementar un metodo donde se impriman los nodos del \u00e1rbol en *post-orden*, es decir, primero el nodo de la izquierda, despu\u00e9s el nodo de la derecha y finalmente el valor del nodo actual."}}