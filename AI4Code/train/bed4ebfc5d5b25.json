{"cell_type":{"c96a2040":"code","09c6eafb":"code","4b1ee3ab":"code","40334669":"code","a9f314bf":"code","2affc15b":"code","75aef8ef":"code","92c816e3":"code","0af036d6":"code","c6cab4f4":"code","3ec05c00":"code","d1999081":"code","0b17df19":"code","a9b91282":"code","a0128a7a":"code","0f408683":"code","c06da35c":"code","2abf0cab":"code","1db04a53":"code","af3ae3a4":"code","cd4663de":"code","7a665f22":"code","25c469dc":"code","a815c1db":"code","73c6e48f":"code","746cdb26":"code","c1c960a9":"code","085b40fc":"code","b32ffe24":"code","988fa75b":"code","6705573e":"code","3e609112":"code","6e271b72":"code","6d012e39":"code","4457029a":"code","9ab43d93":"code","5c973064":"code","44648abe":"code","a0a4ed3e":"code","49113b16":"code","7dad42cf":"code","6e838d95":"code","c0a1dea1":"code","d097a1a9":"code","72d913c2":"code","fdbd7ecd":"code","ac3081b3":"code","cc35937f":"code","b1f19adc":"code","c0247818":"code","d3b7e075":"code","9e241776":"markdown","3fe0b32e":"markdown","e6baf693":"markdown","fa76aecd":"markdown","7164c78f":"markdown","672f5f97":"markdown","59df72e2":"markdown","253809db":"markdown","0c83761c":"markdown","98f8400b":"markdown","7d20ce8a":"markdown","d98a6efa":"markdown","1db59e92":"markdown","94d1d8ce":"markdown","17d4aa5d":"markdown","84a5ea6d":"markdown","c1dd44c1":"markdown","ed4f57cc":"markdown","4def155c":"markdown","d01e3d03":"markdown","554752ad":"markdown","da1b3731":"markdown","c43ea61e":"markdown","b6336547":"markdown","671d31b2":"markdown","d48fe076":"markdown","54e99b59":"markdown","9806325d":"markdown","4a6c61e6":"markdown"},"source":{"c96a2040":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport random\nfrom scipy import stats","09c6eafb":"pd.options.display.float_format='{:.2f}'.format","4b1ee3ab":"spotify = pd.read_csv('..\/input\/spotify-dataset\/Spotify_dataset.csv')\nspotify = spotify.drop(columns = ['Unnamed: 0'])\n\n#duplicate\nspotify_testsub = pd.DataFrame(spotify)","40334669":"# Separating target subset by 0 and 1\ndef target_var(spotify_testsub):\n    if spotify_testsub['speechiness'] < 0.66 and (spotify_testsub[\"decade\"] == \"2010s\" or spotify_testsub[\"decade\"] == \"2000s\") and spotify_testsub[\"target\"] == 1: return 1\n    else: return 0\nspotify_testsub[\"target_var\"] = spotify_testsub.apply(target_var, axis = 1)","a9f314bf":"# Creating feature that measures how close a song is to 4 minutes in relation to 4 minutes.\ndef proximity_to4(spotify_testsub):\n    return (240000-abs(240000-spotify_testsub['duration_ms']))\/240000\nspotify_testsub['proximity_to4'] = spotify_testsub.apply(proximity_to4, axis = 1)","2affc15b":"# Combining two target features into one by using their average.\ndef dancy_short(spotify_testsub):\n    return (spotify_testsub['danceability'] + spotify_testsub['proximity_to4'])\/2\nspotify_testsub['danceability_proximity'] = spotify_testsub.apply(dancy_short, axis = 1)","75aef8ef":"spotify_testsub.head()","92c816e3":"spotify_testsub.describe()[[\"target_var\",\"proximity_to4\",\"danceability_proximity\"]]","0af036d6":"print('The dimensions are', spotify.shape)\nprint(\"Info on the dataset\")\nspotify.info()","c6cab4f4":"spotify.head()","3ec05c00":"spotify_testsub.info()","d1999081":"spotify_testsub.groupby('uri')['uri'].agg('count').describe()","0b17df19":"spotify_droptest = pd.DataFrame(spotify)","a9b91282":"spotify_droptest1 = spotify_droptest.drop_duplicates(subset = [\"track\", \"artist\"])","a0128a7a":"spotify_droptest1.info()","0f408683":"spotify_droptesturi = spotify_droptest.drop_duplicates(subset = [\"uri\"])","c06da35c":"spotify_droptesturi.info()","2abf0cab":"spotify_testsub.describe()","1db04a53":"spotify_testsub['decade'].value_counts(normalize = True)","af3ae3a4":"spotify_testsub.groupby('uri')['uri'].agg('count').describe()","cd4663de":"# Cleaning data from duplicates based on \"track\" and \"artist\" features.\nspotify_testsub = spotify_testsub.drop_duplicates(subset = [\"track\", \"artist\"])","7a665f22":"spotify_testsub.info()","25c469dc":"spotify_testsub.describe()","a815c1db":"spotify_testsub['decade'].value_counts(normalize = True)","73c6e48f":"spotify_testsub.groupby('uri')['uri'].agg('count').describe()","746cdb26":"spotify_testsub.describe()","c1c960a9":"#Checking distribution of generated target variable.\nspotify_testsub['danceability_proximity'].describe()","085b40fc":"# Creating labeled buckets for target varible and generating a graph\ndef dancproxgroups(spotify_testsub):\n    if spotify_testsub['danceability_proximity'] < 0: return '-8 to 0'\n    elif spotify_testsub['danceability_proximity'] > 0 and spotify_testsub['danceability_proximity'] <= 0.1: return \"0 to 0.1\" \n    elif spotify_testsub['danceability_proximity'] > 0.1 and spotify_testsub['danceability_proximity'] <= 0.2: return \"0.1 to 0.2\"\n    elif spotify_testsub['danceability_proximity'] > 0.2 and spotify_testsub['danceability_proximity'] <= 0.3: return \"0.2 to 0.3\" \n    elif spotify_testsub['danceability_proximity'] > 0.3 and spotify_testsub['danceability_proximity'] <= 0.4: return \"0.3 to 0.4\" \n    elif spotify_testsub['danceability_proximity'] > 0.4 and spotify_testsub['danceability_proximity'] <= 0.5: return \"0.4 to 0.5\" \n    elif spotify_testsub['danceability_proximity'] > 0.5 and spotify_testsub['danceability_proximity'] <= 0.6: return \"0.5 to 0.6\" \n    elif spotify_testsub['danceability_proximity'] > 0.6 and spotify_testsub['danceability_proximity'] <= 0.7: return \"0.6 to 0.7\" \n    elif spotify_testsub['danceability_proximity'] > 0.7 and spotify_testsub['danceability_proximity'] <= 0.8: return \"0.7 to 0.8\" \n    elif spotify_testsub['danceability_proximity'] > 0.8 and spotify_testsub['danceability_proximity'] <= 0.9: return \"0.8 to 0.9\" \n    elif spotify_testsub['danceability_proximity'] > 0.9: return \"0.9 to 1\"\n    else: return 99\nspotify_testsub['target_groups'] = spotify_testsub.apply(dancproxgroups, axis=1)","b32ffe24":"spotify_testsub.groupby('target_groups')['target_groups'].agg('count')\n","988fa75b":"fig=plt.figure()\n\nspotify_testsub.groupby('target_groups')['target_groups'].agg('count').plot(kind = 'bar')\ncap=\"Figure 1: This is the distribution of our target variable.\\nAs we can see, rows are concentrated in higher values,\\ntherefore, this distribution is positively skewed.\"\nfig.text(1,.4,cap)\nplt.savefig(\"dist_targ.jpg\",bbox_inches='tight')","6705573e":"# Creating a column for danceability proximity values above 0.7 for analysis and plotting.\ndef target_grouping(spotify_testsub):\n    if spotify_testsub[\"danceability_proximity\"] > 0.7: return \"Above 0.7\"\n    elif spotify_testsub[\"danceability_proximity\"] <= 0.7: return \"0.7 or less\"\n    else: return 99\nspotify_testsub[\"target_label\"] = spotify_testsub.apply(target_grouping, axis = 1)","3e609112":"# Creating subset with target population.\nspotify_hit_recent_songs = spotify_testsub[spotify_testsub[\"target_var\"] == 1]","6e271b72":"# Analyzing target variable distribution in target population subset.\nspotify_hit_recent_songs[\"danceability_proximity\"].describe(percentiles = [.1, .2, .3, .4, .5, .6, .7, .8, .9])","6d012e39":"fig = plt.figure()\nspotify_hit_recent_songs['target_groups'].value_counts(normalize = True).plot(kind = \"bar\", stacked = True)\ncap=\"Figure 2: Distribution of our target variable, danceability_prximity, organized from\\nhighest proportion to smallest.\"\nfig.text(1,.4,cap)","4457029a":"distribution = pd.DataFrame(spotify_hit_recent_songs['target_label'].value_counts(normalize = True))\ndistribution","9ab43d93":"fig=plt.figure()\n# Demonstrate proportions through a staked bar plot\nplt.bar(\"proportion\", distribution.iloc[1],  color = \"b\")\nplt.bar(\"proportion\", distribution.iloc[0], bottom =  distribution.iloc[1], color = \"c\")\nplt.legend([\"0.7 or less\", \"more than 0.7\"])\n\ncap=\"Figure 3: Proportion of target variable in our target population.\\nThese distributions suport our null hypothesis and reject\\nour alternative as we can see that danceability_proximity values\\nabove 0.7 comprise aproximately 73% of our target population of recent hit songs.\"\nfig.text(1,.4,cap)\nplt.savefig(\"prop_targ.jpg\",bbox_inches='tight')","5c973064":"# Extracting non hit subset.\nnon_hits = spotify_testsub[(spotify_testsub['target'] == 0) & (spotify_testsub['speechiness'] < 0.66)]\nnon_hits.head()","44648abe":"# Checking distribution of target variable based on threshold.\nnon_distribution = pd.DataFrame(non_hits['target_label'].value_counts(normalize= True))\nnon_distribution","a0a4ed3e":"# Extracting recent non-hit song subset.\nrecent_non_hits = spotify_testsub[(spotify_testsub['target'] == 0) & (spotify_testsub['speechiness'] < 0.66) & ((spotify_testsub['decade'] == \"2010s\") | (spotify_testsub['decade'] == \"2000s\"))]\nrecent_non_hits.head()","49113b16":"# Checking distribution of target variable based on threshold.\nrec_non_distribution = pd.DataFrame(recent_non_hits['target_label'].value_counts(normalize = True))\nrec_non_distribution","7dad42cf":"fig=plt.figure()\n\nplt.bar(\"recent hit songs\", distribution.iloc[1], color = \"b\")\nplt.bar(\"recent hit songs\", distribution.iloc[0], bottom = distribution.iloc[1], color = \"c\")\nplt.bar(\"non hit songs\", non_distribution.iloc[0], color = \"b\")\nplt.bar(\"non hit songs\", non_distribution.iloc[1], bottom = non_distribution.iloc[0], color = \"c\")\nplt.bar(\"non hit recent songs\", rec_non_distribution.iloc[0], color = \"b\")\nplt.bar(\"non hit recent songs\", rec_non_distribution.iloc[1], bottom = rec_non_distribution.iloc[0], color = \"c\")\nplt.xlabel(\"Populations\")\nplt.ylabel(\"Distribution\")\nplt.legend([\"0.7 or less\", \"More than 0.7\"])\ncap=\"Figure 4: Proportions of target variable and respective population whose\\nvalue is greater than or less than 0.7.\"\nfig.text(1,.4,cap)\nplt.savefig(\"prop_targ_3plots.jpg\",bbox_inches='tight')","6e838d95":"#running 2 ttest: comparing targert population to other two populations\n#target population vs recent non hits\nstats.ttest_ind(spotify_hit_recent_songs.danceability_proximity.sample(frac=0.1),\n                recent_non_hits.danceability_proximity.sample(frac=0.1))","c0a1dea1":"#target population vs non hits\nstats.ttest_ind(spotify_hit_recent_songs.danceability_proximity.sample(frac=0.1),\n                non_hits.danceability_proximity.sample(frac=0.1))","d097a1a9":"#using the prearsonr to find correlation (which is two tailed)\n#for target population and recent non hits\nstats.pearsonr(spotify_hit_recent_songs.danceability_proximity.sample(25),\n                recent_non_hits.danceability_proximity.sample(25))","72d913c2":"#for target population and non hits\nstats.pearsonr(spotify_hit_recent_songs.danceability_proximity.sample(25),\n                non_hits.danceability_proximity.sample(25))","fdbd7ecd":"#setting seed\nrandom.seed(0)\nsample_hit_recent_songs=spotify_hit_recent_songs.sample(5000)\nsample_recentNonHit=recent_non_hits.sample(5000)\nsample_nonHit=non_hits.sample(5000)\n\n#removing outliers through greater than 0\nsample_nonHitL=sample_nonHit.danceability_proximity.squeeze()\nsample_recentNonHitL=sample_recentNonHit.danceability_proximity.squeeze()\n#box plot to check for outliers\nfig,ax=plt.subplots()\n\ncolors = ['blue', 'green']\ndata=[sample_nonHitL,sample_recentNonHitL]\n#creating axis intance for color application to boxes\nboxplot = ax.boxplot(data, patch_artist = True, vert = 0)\n#coloring boxplot\nfor patch, color in zip(boxplot['boxes'], colors):\n    patch.set_facecolor(color)\n\nxlabel=[\"Sample Non Hit\",\"Sample Recent Non Hit\"]\nplt.title(\"Non Target Populations Target Variable\")\nax.boxplot([sample_nonHit.danceability_proximity,sample_recentNonHit.danceability_proximity],vert=False)\nplt.yticks(ticks=[1,2],labels=xlabel)\n\ncap=\"Figure 5: Boxplot of target variable in non target populations with all outliers.\"\nfig.text(1,.4,cap)\nplt.show()","ac3081b3":"#removing values below zero\nsample_nonHitL= [ num for num in sample_nonHit.danceability_proximity if num > 0]\nsample_recentNonHitL= [ num for num in sample_recentNonHit.danceability_proximity if num > 0]\n\nfig,ax=plt.subplots()\n#adding color\ncolors = ['blue', 'green']\ndata=[sample_nonHitL,sample_recentNonHitL]\n\nboxplot = ax.boxplot(data, patch_artist = True, vert = 0)\n#coloring boxplot\nfor patch, color in zip(boxplot['boxes'], colors):\n    patch.set_facecolor(color)\n#creating axis intance for color application to boxes\nax.boxplot([sample_nonHitL,sample_recentNonHitL],vert=False)\nplt.title(\"Non Target Populations Target Variable > 0\")\nplt.yticks(ticks=[1,2],labels=xlabel)\n\ncap = \"Figure 5: Boxplot transformed, all values are greater than 0.\"\nfig.text(1,.4,cap)\nplt.show()","cc35937f":"#creating sample models\nresult_recentNonHit = stats.linregress(sample_hit_recent_songs.danceability_proximity,sample_recentNonHit.danceability_proximity)\nresult_nonHit = stats.linregress(sample_hit_recent_songs.danceability_proximity,sample_nonHit.danceability_proximity)","b1f19adc":"#subplot reigion for side comparison\nfig, axis = plt.subplots(1,2,constrained_layout=True)\n\n#plotting linear regression for recent nonhit songs\naxis[1].set_title(\"Model 2\")\naxis[1].scatter(sample_hit_recent_songs.danceability_proximity,sample_recentNonHit.danceability_proximity,color=\"green\",edgecolors='w')\nreg_line = result_recentNonHit.intercept + result_recentNonHit.slope*sample_recentNonHit.danceability_proximity\naxis[1].plot(sample_recentNonHit.danceability_proximity,reg_line,color=\"grey\")\naxis[1].set_xlabel(\"Sample Non Hit Target Variable\")\n\n#plotting linear regression for sample nonhit songs\naxis[0].scatter(sample_hit_recent_songs.danceability_proximity,sample_nonHit.danceability_proximity,color=\"blue\",edgecolors='w')\nreg_line = result_nonHit.intercept + result_nonHit.slope*sample_nonHit.danceability_proximity\naxis[0].plot(sample_nonHit.danceability_proximity,reg_line,color=\"grey\")\naxis[0].set_title(\"Model 1\")\naxis[0].set_xlabel(\"Sample Non Hit Target Variable\")\naxis[0].set_ylabel(\"Sample Recent Hit Target Variable\")\n\ncap=\"Figure 6: Scatter plot with linear regression line. Plotting the target population\\n\"\nc2=\"by non target population to visualize their correlation. It shows that there\\n\"\nc3=\"is a negative correlation in both plots proving that the target variables\\n\"\nc4=\"do in the non target populatios do not match with those in the target.\"\nfig.text(1.1,.4,cap+c2+c3+c4)\n\nplt.savefig(\"models.jpg\",bbox_inches='tight')\nplt.show()\n","c0247818":"#taking sample of equal sizes because of possible unequal list sizes\nsample_nonHitEven=random.sample(sample_recentNonHitL,4000)\nsample_recentNonHitEven=random.sample(sample_nonHitL,4000)\n#removing values less than 0\nsample_hit_recent_songsEven=[num for num in sample_hit_recent_songs.danceability_proximity if num > 0]\nsample_hit_recent_songsEven=random.sample(sample_hit_recent_songsEven,4000)\n\n#creating sample models\nresult_recentNonHitEven = stats.linregress(sample_hit_recent_songsEven,sample_recentNonHitEven)\nresult_nonHitEven = stats.linregress(sample_hit_recent_songsEven,sample_nonHitEven)","d3b7e075":"#subplot reigion for side comparison\nfig, axis = plt.subplots(1,2,constrained_layout=True)\n\n#plotting linear regression for recent nonhit songs\naxis[1].set_title(\"Model 2\")\naxis[1].scatter(sample_hit_recent_songsEven,sample_recentNonHitEven,color=\"green\",edgecolors='w')\nreg_line = result_recentNonHitEven.intercept + result_recentNonHitEven.slope*np.array(sample_recentNonHitEven)\naxis[1].plot(sample_recentNonHitEven,reg_line,color=\"grey\")\naxis[1].set_xlabel(\"Sample Non Hit Target Variable\")\n\n#plotting linear regression for sample nonhit songs\naxis[0].scatter(sample_hit_recent_songsEven,sample_nonHitEven,color=\"blue\",edgecolors='w')\nreg_line = result_nonHit.intercept + result_nonHit.slope*np.array(sample_nonHitEven)\naxis[0].plot(sample_nonHitEven,reg_line,color=\"grey\")\naxis[0].set_title(\"Model 1\")\naxis[0].set_xlabel(\"Sample Non Hit Target Variable\")\naxis[0].set_ylabel(\"Sample Recent Hit Target Variable\")\nfig.suptitle(\"Models Transformed (greater than 0)\")\n\nplt.savefig(\"models_even.jpg\",bbox_inches='tight')\nplt.show()\n","9e241776":"*CONTRIBUTERS: CHRISTINO L BARBOSA, BRAHIM NID-YOUSSEF, RYAN I PUPIA, ENRIQUE REYES*","3fe0b32e":"# 2 - QA","e6baf693":"Here we kept 40003 rows meaning a thorough deletion of tracks.","fa76aecd":"We then create a variable that allows us to look at how proximity to 4 minutes and danceability work in tandem in a single feature that averages both. Therefore, both features have an equal weight in analysis.","7164c78f":"## 2 - B\n### Cleaning data from duplicates","672f5f97":"Here we kept more rows, which means a less thorough but safer deletion.","59df72e2":"We decided to go with the more thorough option as the diference in row amounts was not considerable enough for us to consider this method unsafe and we would prefer to keep our data as clean as possible. We favoured this method because two different  tracks having the same name and being by the same artist is very uncommon.","253809db":"Since our cleaning affected the data mininmaly, we decided to accept this method and move on to analysis.","0c83761c":"### Applying our cleaning to the dataset and verifying it's effects","98f8400b":"## 2 - A\n### Managing Nulls","7d20ce8a":"#### Testing dropping methods\nby uri or by track and artist","d98a6efa":"## 4 - Deep dive\/Modeling","1db59e92":"### Modeling","94d1d8ce":"### Exploring Hypothesis","17d4aa5d":"## 3 - Exploratory Data Analysis","84a5ea6d":"## 2 - C\n### Gathering pre-QA distribution of features for QA analysis","c1dd44c1":"## 1 - B\n## Generating target variables","ed4f57cc":"We will investigate how our variable is distributed among other populations, such as non-hit songs or recent non-hit songs.","4def155c":"## Generating data specifics","d01e3d03":"# 1 - Hypothesize","554752ad":"- H0: If p-value is larger than 5% then population means are NOT equal\n- H1: Other wise population means differ","da1b3731":"Because there are only a few Nulls in the genres column, we decided not to fill them since the column is not related to the testable Hypothesis.","c43ea61e":"## Configuring notebook and reading in dataset","b6336547":"#### Testing for duplicates","671d31b2":"We can see that 30% of the population has danceability_proximity values up to 0.71, which indicates that the remaining 70% has values above that, suporting our null hypothesis.","d48fe076":"### Analyzing new columns","54e99b59":"As we can see, our dataset contains multiple instances of the same track ID. This is justifiable when tracks are by different artists, but should never occur if they are by the same artist. ","9806325d":"## 1 - A\n## Testable Null and Alternate Hypothesis\n### Null: 60% or more of hit songs from 2000s and 2010s have a target variable value of 0.7 or more\n### Alternate: 55% or less of hit songs from 2000s and 2010s have a target variable of 0.7 or more","4a6c61e6":"From analysis, we concluded that we must accept the Null and reject the Alternate."}}