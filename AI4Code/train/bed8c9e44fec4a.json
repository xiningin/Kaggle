{"cell_type":{"b11208a4":"code","4bf6696f":"code","ddebc284":"code","48193bf8":"code","cf7a5852":"code","ddfe6310":"code","26231a1d":"code","6b0b3312":"code","e0c97ff3":"code","999e19ce":"code","b88ae65c":"code","da468cb5":"code","2b8b6e10":"code","f100a760":"code","9e711cd0":"code","2c2d1f45":"code","29307da6":"code","f58522d0":"code","f3f86b98":"code","2d9ec6d0":"code","9ad2bd90":"code","a8b21f37":"code","b8b2e132":"code","2bd8c78d":"code","369b64b3":"code","a8e0d9e9":"code","c22d3312":"code","f6a6a90d":"code","7a16d273":"code","751743af":"code","ec0a549b":"code","50ffc800":"code","82d6d24c":"markdown"},"source":{"b11208a4":"import pandas as pd\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\nfrom collections import Counter\nfrom xgboost import XGBRegressor\nimport lightgbm as lgb\n\nfrom sklearn.model_selection import train_test_split, KFold\nfrom sklearn.metrics import mean_squared_error","4bf6696f":"train = pd.read_json(\"..\/input\/stanford-covid-vaccine\/train.json\",lines=True)\ntest = pd.read_json(\"..\/input\/stanford-covid-vaccine\/test.json\",lines=True)\nss = pd.read_csv(\"..\/input\/stanford-covid-vaccine\/sample_submission.csv\")","ddebc284":"train = train.set_index('index')\ntest = test.set_index('index')","48193bf8":"ss","cf7a5852":"train.head(3)","ddfe6310":"test.seq_length.value_counts()","26231a1d":"test.head(3)","6b0b3312":"print(\"Size of training examples: \",np.shape(train))\nprint(\"Size of test examples: \",np.shape(test))","e0c97ff3":"print('========= train columns ==========')\nprint([c for c in train.columns])\n\nprint('========= test columns ==========')\nprint([c for c in test.columns])","999e19ce":"train.info()","b88ae65c":"# read npy data file\nbpps_list = os.listdir('..\/input\/stanford-covid-vaccine\/bpps\/')\nbpps_npy = np.load(f'..\/input\/stanford-covid-vaccine\/bpps\/{bpps_list[25]}')\nprint('Count of npy files: ', len(bpps_list))\nprint('Size of image: ', bpps_npy.shape)\n#Size of all .npy files are not same","da468cb5":"NO_OF_EXAMPLES = 15\nfig = plt.figure(figsize=(15, 15))\nfor i in range(NO_OF_EXAMPLES):\n    bpps_eg = np.load(f'..\/input\/stanford-covid-vaccine\/bpps\/{bpps_list[i]}')\n    sub = fig.add_subplot(5,5, i + 1)\n    sub.imshow(bpps_eg)","2b8b6e10":"Counter(train['sequence'].values[0])","f100a760":"Counter(train['predicted_loop_type'].values[0])","9e711cd0":"def featurize(df):\n    \n    df['A_percent'] = df['sequence'].apply(lambda s: s.count('A'))\/107\n    df['G_percent'] = df['sequence'].apply(lambda s: s.count('G'))\/107\n    df['U_percent'] = df['sequence'].apply(lambda s: s.count('U'))\/107\n    df['C_percent'] = df['sequence'].apply(lambda s: s.count('C'))\/107\n    \n    df['total_dot_count'] = df['structure'].apply(lambda s: s.count('.'))\/107\n    df['total_ob_count'] = df['structure'].apply(lambda s: s.count('('))\/107\n    df['total_cb_count'] = df['structure'].apply(lambda s: s.count(')'))\/107\n    \n    df['pair_rates'] = (df['total_ob_count'] + df['total_cb_count'])\/df['total_dot_count']\n    \n    df['S_percent'] = df['sequence'].apply(lambda s: s.count('S'))\/107\n    df['M_percent'] = df['sequence'].apply(lambda s: s.count('M'))\/107\n    df['I_percent'] = df['sequence'].apply(lambda s: s.count('I'))\/107\n    df['X_percent'] = df['sequence'].apply(lambda s: s.count('X'))\/107\n    df['B_percent'] = df['sequence'].apply(lambda s: s.count('B'))\/107\n    df['H_percent'] = df['sequence'].apply(lambda s: s.count('H'))\/107\n    \n    return df","2c2d1f45":"train = featurize(train)\ntest = featurize(test)","29307da6":"train['reactivity_error'] = train['reactivity_error'].apply(lambda x: np.mean(x))\ntrain['deg_error_Mg_pH10'] = train['deg_error_Mg_pH10'].apply(lambda x: np.mean(x))\ntrain['deg_error_Mg_50C'] = train['deg_error_Mg_50C'].apply(lambda x: np.mean(x))","f58522d0":"required_mean = train['reactivity_error'][train['reactivity_error'] <= 1].mean()\ntrain['reactivity_error'][train['reactivity_error'] > 1] = required_mean\n\nrequired_mean = train['deg_error_Mg_pH10'][train['deg_error_Mg_pH10'] <= 1].mean()\ntrain['deg_error_Mg_pH10'][train['deg_error_Mg_pH10'] > 1] = required_mean\n\nrequired_mean = train['deg_error_Mg_50C'][train['deg_error_Mg_50C'] <= 1].mean()\ntrain['deg_error_Mg_50C'][train['deg_error_Mg_50C'] > 1] = required_mean","f3f86b98":"train['reactivity_error'].describe()","2d9ec6d0":"train['mean_reactivity'] = train['reactivity'].apply(lambda x: np.mean(x))# + train['reactivity_error']\ntrain['mean_deg_Mg_pH10'] = train['deg_Mg_pH10'].apply(lambda x: np.mean(x))# + train['deg_error_Mg_pH10']\ntrain['mean_deg_Mg_50C'] = train['deg_Mg_50C'].apply(lambda x: np.mean(x))# + train['deg_error_Mg_50C']","9ad2bd90":"# Expand Sequence Features\nfor n in range(107):\n    train[f'sequence_{n}'] = train['sequence'].apply(lambda x: x[n]).astype('category')\n    test[f'sequence_{n}'] = test['sequence'].apply(lambda x: x[n]).astype('category')","a8b21f37":"# Expand Structure Features\nfor n in range(107):\n    train[f'structure_{n}'] = train['structure'].apply(lambda x: x[n]).astype('category')\n    test[f'structure_{n}'] = test['structure'].apply(lambda x: x[n]).astype('category')","b8b2e132":"# Expand predicted_loop_type Features\nfor n in range(107):\n    train[f'predicted_loop_type_{n}'] = train['predicted_loop_type'].apply(lambda x: x[n]).astype('category')\n    test[f'predicted_loop_type_{n}'] = test['predicted_loop_type'].apply(lambda x: x[n]).astype('category')","2bd8c78d":"train = train[train.SN_filter == 1]","369b64b3":"train","a8e0d9e9":"SEQUENCE_COLS = [c for c in train.columns if 'sequence_' in c]\nSTRUCTURE_COLS = [c for c in train.columns if 'structure_' in c]\nPREDICTED_LOOP_COLS = [c for c in train.columns if 'predicted_loop_type_' in c]\nOTHERS = ['A_percent','G_percent','C_percent','U_percent', 'pair_rates',\n          'S_percent','B_percent','X_percent','H_percent','I_percent','M_percent']\nMY_COLS = SEQUENCE_COLS + STRUCTURE_COLS + PREDICTED_LOOP_COLS + OTHERS","c22d3312":"oof_error = 0\nfor target in ['reactivity','deg_Mg_pH10','deg_Mg_50C']:\n\n    X = train[MY_COLS]\n    y = train[f'mean_{target}']\n    X_test = test[MY_COLS]\n    \n    N_SPLITS = 7\n    target_error = 0\n    \n    test[f'mean_{target}_pred'] = 0\n    \n    for fn, (trn_idx, val_idx) in enumerate(KFold(n_splits = N_SPLITS, shuffle = True).split(X)):\n        print('Fold: ', fn+1)\n        X_train, X_val = X.iloc[trn_idx], X.iloc[val_idx]\n        y_train, y_val = y.iloc[trn_idx], y.iloc[val_idx]\n\n        reg = lgb.LGBMRegressor()\n        reg.fit(X_train, y_train)\n        pred = reg.predict(X_val)\n        loss = np.sqrt(mean_squared_error(y_val,pred))\n        total_error += loss\/N_SPLITS\n        test[f'mean_{target}_pred'] += reg.predict(X_test)\/N_SPLITS\n    \n    \n    oof_error += total_error\n    \nprint(\"mean columnwise root mean squared error:\",oof_error\/3)","f6a6a90d":"test","7a16d273":"ss['id'] = 'id_' + ss['id_seqpos'].str.split('_', expand=True)[1]\n\n# Merge my predicted average values\nss_new = ss. \\\n    drop(['reactivity','deg_Mg_pH10','deg_Mg_50C'], axis=1) \\\n    .merge(test[['id',\n               'mean_reactivity_pred',\n               'mean_deg_Mg_pH10_pred',\n               'mean_deg_Mg_50C_pred']] \\\n               .rename(columns={'mean_reactivity_pred' : 'reactivity',\n                                'mean_deg_Mg_pH10_pred': 'deg_Mg_pH10',\n                                'mean_deg_Mg_50C_pred' : 'deg_Mg_50C'}\n                      ),\n         on='id',\n        validate='m:1')","751743af":"ss_new[ss.columns]","ec0a549b":"# Make Submission\nss = pd.read_csv('..\/input\/stanford-covid-vaccine\/sample_submission.csv')\nss_new[ss.columns].to_csv('submission_lgbm_v1.csv', index=False)","50ffc800":"ss","82d6d24c":"* using lgb with traintest split: CV-0.08574868231714827 LB-0.47402\n* using lgb with kfold split: 0.26668349917066164\n* using lgb with kfold split applied sn filter with 5 fold: 0.6407461658322643"}}