{"cell_type":{"03fb447f":"code","d166ee0f":"code","08b40abf":"code","d3aa2e60":"code","7b8e210e":"code","3ef4bb17":"code","d8b6f512":"code","078e5c8b":"code","0c87a1eb":"code","5a0eeecb":"code","09a47011":"code","82a755a5":"code","128d3638":"code","b42e09d1":"code","ef638fef":"code","7c7c99de":"code","08e5e816":"code","d521f36d":"code","2b087d2d":"code","4c0de95e":"code","7e4a7595":"markdown","404205df":"markdown","aa6377c9":"markdown","944e6f20":"markdown","87c7cc29":"markdown","2f2bf944":"markdown","c23752f0":"markdown","6db51b2a":"markdown","c3f4fe4d":"markdown","cfc1a9ab":"markdown","18b731d1":"markdown","77dac98e":"markdown","889c1583":"markdown","4f14aca3":"markdown"},"source":{"03fb447f":"\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d166ee0f":"data = pd.read_csv('..\/input\/churn-modelling\/Churn_Modelling.csv')","08b40abf":"print(data.head)","d3aa2e60":"req_col = ['CreditScore','Geography','Gender','Age','NumOfProducts','Exited']\ndata = data[req_col]","7b8e210e":"data.head","3ef4bb17":"data.info()","d8b6f512":"#assign an arbitrary value according to the size of the dataset to get appropriate sections of the dataset\nval = 5\nprob = pd.DataFrame(columns = ['Attr','Value','C1','C2','P1','P2'])","078e5c8b":"target = 'Exited'","0c87a1eb":"#Exited\nex = data[data[target]==1]\n#Did Not Exit\nnex = data[data[target]==0]","5a0eeecb":"print(nex.shape,ex.shape)","09a47011":"# For input as Did Not Exit\n#input_val = nex.iloc[7005,:]\n#print(input_val)\n\n\n## For input as Exited\ninput_val = ex.iloc[2005,:]\nprint(input_val)","82a755a5":"nex = nex.iloc[0:2040,:]","128d3638":"print(nex.shape,ex.shape)\nnex_sh = nex.shape[0]\/(ex.shape[0]+nex.shape[0])\nex_sh = ex.shape[0]\/(ex.shape[0]+nex.shape[0])\nprint(\"P(C1) = {} \\n P(C2) = {}\".format(ex_sh, nex_sh))","b42e09d1":"C1 = []\nC2 = []","ef638fef":"for x in req_col:\n    \n    if (data[x].dtype == np.float64 or data[x].dtype == np.int64):\n        if(len(pd.unique(data[x]))>(val)):\n            m = data[x].value_counts(bins=3).reset_index().rename(columns={'index':'bin'})\n            C1 = []\n            C2 = []\n            P1 = []\n            P2 = []\n            \n            \n            for check in m['bin']:\n               \n                \n                t_c1 = int(ex[(check.left <= ex[x]) & (ex[x] <= check.right)].shape[0])\n                t_p1 = int(ex[(check.left <= ex[x]) & (ex[x] <= check.right)].shape[0])\/ex.shape[0]\n                t_c2 = int(nex[(check.left <= nex[x]) & (nex[x] <= check.right)].shape[0])\n                t_p2 = int(nex[(check.left <= nex[x]) & (nex[x] <= check.right)].shape[0])\/nex.shape[0]\n    \n                C1.append(t_c1)\n                C2.append(t_c2)\n                P1.append(t_p1)\n                P2.append(t_p2)\n            #print(C1,C2,P1,P2)\n\n            inc = pd.DataFrame({\"Attr\" : [x,x,x], \"Value\" : m['bin'], \"C1\" : C1, \"C2\" : C2, \"P1\" : P1, \"P2\" : P2})\n            #print(inc)\n            prob = prob.append(inc)\n        else:\n            C1 = []\n            C2 = []\n            P1 = []\n            P2 = []\n            uni = data[x].unique()\n            for check in uni:\n                if (check in ex[x].value_counts()):\n                    C1.append(ex[x].value_counts()[check])\n                    #print(C1)\n                    P1.append(ex[x].value_counts()[check]\/ex.shape[0])\n                    \n                else:\n                    C1.append(0)\n                    P1.append(0)\n                    \n                if (check in nex[x].value_counts()):\n                    C2.append(nex[x].value_counts()[check])\n                    #print(C2)\n                    P2.append(nex[x].value_counts()[check]\/nex.shape[0])\n                    \n                else:\n                    C2.append(0)\n                    P2.append(0)\n                    \n                \n                    \n            inc = pd.DataFrame({\"Attr\" : [x]*len(uni), \"Value\" : uni, \"C1\" : C1, \"C2\" : C2, \"P1\" : P1, \"P2\" : P2})\n            prob = prob.append(inc)\n                \n    else:\n        C1 = []\n        C2 = []\n        P1 = []\n        P2 = []\n        uni = data[x].unique()\n        for check in uni:\n            C1.append(ex[x].value_counts()[check])\n            #print(C1)\n            C2.append(nex[x].value_counts()[check])\n            #print(C2)\n            P1.append(ex[x].value_counts()[check]\/ex.shape[0])\n            P2.append(nex[x].value_counts()[check]\/nex.shape[0])    \n        inc = pd.DataFrame({\"Attr\" : [x]*len(uni), \"Value\" : uni, \"C1\" : C1, \"C2\" : C2, \"P1\" : P1, \"P2\" : P2})\n        prob = prob.append(inc)\n        ","7c7c99de":"prob = prob.reset_index().drop(['index'],axis = 1)","08e5e816":"print(\"\\nInput Value:\")\nprint(input_val)\nprint(\"\\nExpected Value:\")\ninput_val = input_val.drop(['Exited'])\nprint(\"\\nRevised DataFrame\")\nprint(input_val)","d521f36d":"fin_P1 = 1\nfin_P2 = 1\nfor inin in input_val.index:\n    answer = prob[(prob['Attr'] == inin)]\n    #print(answer)\n    #print(inin)\n    \n    for val in answer['Value']:\n        #print(type(val))\n        if(isinstance(val, int)):\n            if(input_val[inin] == val):\n                ind = answer.index[answer.Value == val]\n                fin_P2*=float(answer['P2'].loc[ind])\n                #print(float(answer['P2'].loc[ind]))\n                fin_P1*=float(answer['P1'].loc[ind])\n                #print(float(answer['P1'].loc[ind]))\n            \n        else:\n            if(input_val[inin] in val):\n                ind = answer.index[answer.Value == val]\n                fin_P2*=float(answer['P2'].loc[ind])\n                #print(float(answer['P2'].loc[ind]))\n                fin_P1*=float(answer['P1'].loc[ind])\n                #print(float(answer['P1'].loc[ind]))\nprint(\"P(X\/C1) = {}\".format(fin_P1))         \nprint(\"P(X\/C2) = {}\".format(fin_P2))        ","2b087d2d":"print(\"P(C1\/X) = {} * {} = {}\".format(fin_P1, ex_sh,fin_P1*ex_sh ))\nprint(\"P(C2\/X) = {} * {} = {}\".format(fin_P2, nex_sh,fin_P2*nex_sh))","4c0de95e":"if(fin_P1 * ex_sh > fin_P2 * nex_sh):\n    print(\"Conclusion: Since P(X) is constant and common for both the classes and the maximum posterior is P(C1\/X) = {}. Hence tuple\/unknown sample gets classified as Exited\".format(fin_P1*ex_sh))\nelse:\n    print(\"Conclusion: Since P(X) is constant and common for both the classes and the maximum posterior is P(C2\/X) = {}. Hence tuple\/unknown sample gets classified as Did Not Exit\".format(fin_P2*nex_sh))","7e4a7595":"### Checking and Editing the Input Values to remove the Target Column","404205df":"# Conclusion:","aa6377c9":"### Checking the first 5 rows of the DataSet","944e6f20":"# Step 2: Calculating P(X\/Ci) for classes","87c7cc29":"### Checking the shape of both the dataframes","2f2bf944":"### Calculating the value of P(Ci\/X)","c23752f0":"### Setting the required columns","6db51b2a":"# <center>***Posterior Probability*** <br>\n<center>(coding from scratch)\n","c3f4fe4d":"# Step 3: Calculating Posterior Probability","cfc1a9ab":"### Choose your input. Uncomment the desired input and Comment the desired one","18b731d1":"### Setting the target\nWe choose Exited as the target since we are classifying the data into Exited or Did Not Exit the Bank","77dac98e":"### We use this method to gather information about the DataSet","889c1583":"### Splitting the dataset into Exited and Did Not Exit","4f14aca3":"# Preparing the Dataset for classification"}}