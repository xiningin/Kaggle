{"cell_type":{"d00340a0":"code","e60e13d5":"code","75eb8bab":"code","3ad2202a":"code","0374d525":"code","b7fa2ce2":"code","69de7682":"code","911b547b":"code","a185573f":"code","4f336bc4":"code","9c7346c3":"code","7f8cd75c":"code","6cce538a":"code","9ac7d9b5":"code","5ac78329":"code","ee29d182":"code","93a858a0":"code","d7af9ee6":"code","a3c4bf4a":"code","9d484ac2":"code","d3d3e3b7":"code","571d5ef6":"code","9f2b1a54":"code","373cbaee":"code","75a293ee":"code","f21878d9":"code","5d6bf01a":"markdown","111394b4":"markdown","95197aa0":"markdown","a7e811a3":"markdown","b219955d":"markdown","72d9688f":"markdown","1c12cb4d":"markdown","d1502ccb":"markdown","84619429":"markdown","543f4f1b":"markdown","93187230":"markdown","7b94f233":"markdown","5ba91d7e":"markdown","bc5f92d2":"markdown","113dabd3":"markdown","98e4dd7a":"markdown","af483759":"markdown","7eeea440":"markdown","9fd6f4b9":"markdown","bd7b8fa1":"markdown","25e89dec":"markdown","caf7d3db":"markdown","0d88380e":"markdown","4b9b90c1":"markdown","bf81dc93":"markdown","86ecf088":"markdown","867f7f57":"markdown","9fa00182":"markdown","f5ac96d8":"markdown","eeeadc56":"markdown"},"source":{"d00340a0":"import os\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nsns.set()","e60e13d5":"plt.rcParams['figure.figsize'] = (16, 4)","75eb8bab":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","3ad2202a":"soil_type_vars = [f'Soil_Type{i}' for i in range(1, 41)]\nwilderness_area_vars = [f'Wilderness_Area{i}' for i in range(1, 5)]\nbinary_vars = soil_type_vars + wilderness_area_vars\nnumerical_vars = ['Elevation', 'Aspect', 'Slope', 'Horizontal_Distance_To_Hydrology', 'Vertical_Distance_To_Hydrology', 'Horizontal_Distance_To_Roadways', 'Hillshade_9am', 'Hillshade_Noon', 'Hillshade_3pm', 'Horizontal_Distance_To_Fire_Points']\nfeatures = numerical_vars + binary_vars\ntarget = 'Cover_Type'","0374d525":"dtypes = {\n    'Id': np.int32,\n    'Elevation': np.int16,\n    'Aspect': np.int16,\n    'Slope': np.int8,\n    'Horizontal_Distance_To_Hydrology': np.int16,\n    'Vertical_Distance_To_Hydrology': np.int16,\n    'Horizontal_Distance_To_Roadways': np.int16,\n    'Hillshade_9am': np.int16,\n    'Hillshade_Noon': np.int16,\n    'Hillshade_3pm': np.int16,\n    'Horizontal_Distance_To_Fire_Points': np.int16,\n    'Cover_Type': np.int8,\n}\nbinary_vars_dtypes = {c: np.int8 for c in binary_vars}\ndtypes.update(binary_vars_dtypes)","b7fa2ce2":"train = pd.read_csv('\/kaggle\/input\/tabular-playground-series-dec-2021\/train.csv', dtype=dtypes)\ntest = pd.read_csv('\/kaggle\/input\/tabular-playground-series-dec-2021\/test.csv', dtype=dtypes)\n\n# I created some sampled dataframes to use with some visualizations that would take too long to process\n# if I were to use all the data.\ntrain_50k = train.sample(n=50_000, random_state=42)\ntest_50k = test.sample(n=50_000, random_state=42)","69de7682":"train.info()","911b547b":"test.info()","a185573f":"train_na_count = train.isna().sum().to_frame('na_count')\ntest_na_count = test.isna().sum().to_frame('na_count')\npd.concat([train_na_count, test_na_count], axis=1, keys=['train', 'test'], names=['set'])","4f336bc4":"fig, axs = plt.subplots(1, 2)\nsns.countplot(x=train[target], ax=axs[0])\nsns.countplot(x=train[target], ax=axs[1])\naxs[0].set(title='Target Distribution', yscale='linear');\naxs[1].set(title='Target Distribution (Log scale on y axis)', yscale='log');","9c7346c3":"target_count = train[target].value_counts().to_frame('count')\ntarget_count['ratio'] = target_count['count'] \/ target_count['count'].sum()\ntarget_count.style.format('{:.4%}', subset='ratio').background_gradient('YlGn')","7f8cd75c":"train_bin_counts = [train[c].value_counts().to_frame(c).sort_index() for c in binary_vars]\ntest_bin_counts = [test[c].value_counts().to_frame(c).sort_index() for c in binary_vars]\ntrain_bin_counts_df = pd.concat(train_bin_counts, axis=1)\ntest_bin_counts_df = pd.concat(test_bin_counts, axis=1)\nall_bin_counts_df = pd.concat([train_bin_counts_df.T, test_bin_counts_df.T], keys=['train', 'test'], names=['set'], axis=1)\nall_bin_counts_df.style.background_gradient('YlGn').format(precision=0)","6cce538a":"train.groupby(target)[binary_vars].mean().T.style.background_gradient('YlGn', axis=1).format('{:.4%}'.format)","9ac7d9b5":"train[numerical_vars].describe(percentiles=[.01, .25, .50, .75, .99]).T","5ac78329":"plt.figure(figsize=(16, 6), dpi=100)\nsns.boxplot(data=train_50k[numerical_vars], orient='h', showfliers=False);","ee29d182":"fig, axs = plt.subplots(3, 4, figsize=(16, 10), dpi=100)\naxs = axs.ravel()\nfor i, col_name in enumerate(numerical_vars):\n    sns.kdeplot(data=train_50k, x=col_name, color='tab:blue', ax=axs[i])\n    sns.kdeplot(data=test_50k, x=col_name, color='tab:orange', ax=axs[i])\nfor i in [10, 11]:\n    axs[i].remove()\nfig.tight_layout()","93a858a0":"fig, axs = plt.subplots(3, 4, figsize=(16, 10), dpi=200)\naxs = axs.ravel()\ncommon_kwargs = {'stat': 'percent', 'element': 'step'}\nextra_kwargs = {\n    'Slope': {'binwidth': 1},\n    'Hillshade_Noon': {'binwidth': 1},\n    'Horizontal_Distance_To_Hydrology': {'binwidth': 10},\n    'Horizontal_Distance_To_Roadways': {'binwidth': 25},\n    'Hillshade_9am': {'binwidth': 5},\n    'Horizontal_Distance_To_Fire_Points': {'binwidth': 25},\n}\nfor i, col_name in enumerate(numerical_vars):\n    kwargs = common_kwargs\n    if col_name in extra_kwargs:\n        kwargs.update(extra_kwargs[col_name])\n    sns.histplot(data=train_50k, x=col_name, color='tab:blue', ax=axs[i], **kwargs)\n    sns.histplot(data=test_50k, x=col_name, color='tab:orange', ax=axs[i], **kwargs)\nfor i in [10, 11]:\n    axs[i].remove()\nfig.tight_layout()","d7af9ee6":"g = sns.PairGrid(train_50k, vars=numerical_vars, hue=target, palette='tab10', diag_sharey=False)\ng.map_upper(sns.scatterplot, alpha=0.2)\ng.map_diag(sns.kdeplot)\ng.map_lower(sns.histplot, hue=None)\ng.fig.set_dpi(200)","a3c4bf4a":"fig, axs = plt.subplots(5, 2, figsize=(16, 16))\naxs = axs.ravel()\nfor i, col_name in enumerate(numerical_vars):\n    sns.boxplot(data=train, x=col_name, y=target, palette='tab10', orient='h', ax=axs[i])\nfig.tight_layout()","9d484ac2":"corr = train.drop(columns='Id').corr()\nmask = np.zeros_like(corr, dtype=bool)\nmask[np.triu_indices_from(mask)] = True\nplt.figure(figsize=(18, 12))\n_ = sns.heatmap(corr, mask=mask, square=True, center=0, cmap='bwr')","d3d3e3b7":"corr[mask] = np.nan\nimportant_correlations = corr.stack().to_frame().reset_index()\nimportant_correlations.columns = ['var_1', 'var_2', 'corr']\nimportant_correlations.dropna(inplace=True)\nimportant_correlations['corr_abs'] = np.abs(important_correlations['corr'])\nimportant_correlations.sort_values('corr_abs', ascending=False, inplace=True)\nimportant_correlations.query('corr_abs > 0.1').style.background_gradient('YlGn', subset=['corr_abs'])","571d5ef6":"numeric_corr = train[numerical_vars].corr()\nmask = np.zeros_like(numeric_corr, dtype=bool)\nmask[np.triu_indices_from(mask)] = True\nplt.figure(figsize=(16, 10))\n_ = sns.heatmap(numeric_corr, mask=mask, square=True, annot=True, fmt='.2%', center=0, cmap='bwr')","9f2b1a54":"train[wilderness_area_vars].sum(axis=1).value_counts().to_frame('wilderness_count')","373cbaee":"train[soil_type_vars].sum(axis=1).value_counts().to_frame('soil_count')","75a293ee":"soil_target = train[[target]].copy()\nsoil_target['wilderness_count'] = train[wilderness_area_vars].sum(axis=1)\n_ = sns.boxplot(data=soil_target, y='wilderness_count', x=target)","f21878d9":"soil_target = train[[target]].copy()\nsoil_target['soil_count'] = train[soil_type_vars].sum(axis=1)\n_ = sns.boxplot(data=soil_target, y='soil_count', x=target)","5d6bf01a":"## Sum of wilderness areas or soil types","111394b4":"**Table with the stronger correlations.** Seeing it as a table can help pick up important correlations you didn't notice on the heatmap.","95197aa0":"The description of the soil types could be worth some feature engineering perhaps. For example, how stony the soil is, or what family it belongs to, etc. I intend to explore this in the future.","a7e811a3":"## Missing Values\n\nNumber of missing values for each column in the train and test sets.","b219955d":"**Univariate analysis using Histograms.** Basically, the same thing. Just a different view.","72d9688f":"> The study area includes four wilderness areas located in the Roosevelt National Forest of northern Colorado. Each observation is a 30m x 30m patch. You are asked to predict an integer classification for the forest cover type. The seven types are:\n> \n>  - 1 - Spruce\/Fir\n>  - 2 - Lodgepole Pine\n>  - 3 - Ponderosa Pine\n>  - 4 - Cottonwood\/Willow\n>  - 5 - Aspen\n>  - 6 - Douglas-fir\n>  - 7 - Krummholz\n> \n> The training set (15120 observations) contains both features and the Cover_Type. The test set contains only the features. You must predict the Cover_Type for every row in the test set (565892 observations).\n> \n> Data Fields:\n>  - **Elevation** - Elevation in meters\n>  - **Aspect** - Aspect in degrees azimuth\n>  - **Slope** - Slope in degrees\n>  - **Horizontal_Distance_To_Hydrology** - Horz Dist to nearest surface water features\n>  - **Vertical_Distance_To_Hydrology** - Vert Dist to nearest surface water features\n>  - **Horizontal_Distance_To_Roadways** - Horz Dist to nearest roadway\n>  - **Hillshade_9am** - Hillshade index at 9am, summer solstice (0 to 255 index)\n>  - **Hillshade_Noon** - Hillshade index at noon, summer solstice (0 to 255 index)\n>  - **Hillshade_3pm** - Hillshade index at 3pm, summer solstice (0 to 255 index)\n>  - **Horizontal_Distance_To_Fire_Points** - Horz Dist to nearest wildfire ignition points\n>  - **Wilderness_Area** - Wilderness area designation (4 binary columns, 0 = absence or 1 = presence)\n>  - **Soil_Type** - Soil Type designation (40 binary columns, 0 = absence or 1 = presence)\n>  - **Cover_Type** - Forest Cover Type designation (7 types, integers 1 to 7)\n> \n> The wilderness areas are:\n> \n>  - 1 - Rawah Wilderness Area\n>  - 2 - Neota Wilderness Area\n>  - 3 - Comanche Peak Wilderness Area\n>  - 4 - Cache la Poudre Wilderness Area\n> \n> The soil types are:\n> \n>  - 1 Cathedral family - Rock outcrop complex, extremely stony.\n>  - 2 Vanet - Ratake families complex, very stony.\n>  - 3 Haploborolis - Rock outcrop complex, rubbly.\n>  - 4 Ratake family - Rock outcrop complex, rubbly.\n>  - 5 Vanet family - Rock outcrop complex complex, rubbly.\n>  - 6 Vanet - Wetmore families - Rock outcrop complex, stony.\n>  - 7 Gothic family.\n>  - 8 Supervisor - Limber families complex.\n>  - 9 Troutville family, very stony.\n>  - 10 Bullwark - Catamount families - Rock outcrop complex, rubbly.\n>  - 11 Bullwark - Catamount families - Rock land complex, rubbly.\n>  - 12 Legault family - Rock land complex, stony.\n>  - 13 Catamount family - Rock land - Bullwark family complex, rubbly.\n>  - 14 Pachic Argiborolis - Aquolis complex.\n>  - 15 unspecified in the USFS Soil and ELU Survey.\n>  - 16 Cryaquolis - Cryoborolis complex.\n>  - 17 Gateview family - Cryaquolis complex.\n>  - 18 Rogert family, very stony.\n>  - 19 Typic Cryaquolis - Borohemists complex.\n>  - 20 Typic Cryaquepts - Typic Cryaquolls complex.\n>  - 21 Typic Cryaquolls - Leighcan family, till substratum complex.\n>  - 22 Leighcan family, till substratum, extremely bouldery.\n>  - 23 Leighcan family, till substratum - Typic Cryaquolls complex.\n>  - 24 Leighcan family, extremely stony.\n>  - 25 Leighcan family, warm, extremely stony.\n>  - 26 Granile - Catamount families complex, very stony.\n>  - 27 Leighcan family, warm - Rock outcrop complex, extremely stony.\n>  - 28 Leighcan family - Rock outcrop complex, extremely stony.\n>  - 29 Como - Legault families complex, extremely stony.\n>  - 30 Como family - Rock land - Legault family complex, extremely stony.\n>  - 31 Leighcan - Catamount families complex, extremely stony.\n>  - 32 Catamount family - Rock outcrop - Leighcan family complex, extremely stony.\n>  - 33 Leighcan - Catamount families - Rock outcrop complex, extremely stony.\n>  - 34 Cryorthents - Rock land complex, extremely stony.\n>  - 35 Cryumbrepts - Rock outcrop - Cryaquepts complex.\n>  - 36 Bross family - Rock land - Cryumbrepts complex, extremely stony.\n>  - 37 Rock outcrop - Cryumbrepts - Cryorthents complex, extremely stony.\n>  - 38 Leighcan - Moran families - Cryaquolls complex, extremely stony.\n>  - 39 Moran family - Cryorthents - Leighcan family complex, extremely stony.\n>  - 40 Moran family - Cryorthents - Rock land complex, extremely stony.","1c12cb4d":"## Original dataset description\n\nI modified the formatting of the text a little. **Please notice that some of this info does not apply to the the data in this competition (TPS Dec)**, such as the number of observations in train and test sets; also the range of the hillshades; etc.","d1502ccb":"## Binary variables","84619429":"No missing values. `Cover_Type` is missing from the test set, obviously, as it's the target.","543f4f1b":"## Numerical variables","93187230":"## Preparation","7b94f233":"**Univariate analysis using KDE.** Both train and test have very similar distribution, except for `Elevation`, I would say... but I don't know what this could mean.","5ba91d7e":"## Correlation","bc5f92d2":"**Pairplot.** The upper triangle is made of scatter plots with the target as hue. It's very messy, but we can see that Cover Type 1, 2, and 3, are very linearly separable by `Elevation`. (More on this next.). KDEs with target as hue on the diagonals, `Elevation` is the most interesting. And I made 2D histograms for the bottom triangle to help identify relantionships between predictor variables. I don't see anything interesting in them, though. I believe if there was an interesting relationship (linear, for example) we would see it pop out in the darker colors.","113dabd3":"**Description of numerical variables.** We can see the ranges of some variables don't match the description of the original dataset (beggining of this notebook). E.g., `Hillshade_3pm` is extrapolating the [0, 255] range.","98e4dd7a":"**Range comparison of each numeric variable.** This box plot helps visualize the ranges of each variable, and how they compare to each other. Normalization will be very important for some algorithms.","af483759":"I was curious if there were observations with multiple wilderness areas. And indeed there are (table below). But I wonder if this exists in the original dataset and can be meaningful, or (my guess) if this was something introduced by the GAN.","7eeea440":"Below, I made some box plots to compare the ranges that each feature assumes for each class. Looking at the first subplot, we can see that Cover Type 1 likes high elevations (> 3000). Cover Type 2 likes intermediate heights (between 2500 and 3000). Cover Type 3 likes lower elevations (< 2500). Cover Type 6 and 7 also have there own preferance. And just a reminder that there are very few observations for Cover Type 4 and 5.","9fd6f4b9":"## Loading the data","bd7b8fa1":"TODO: I wish I'd do some contour plots with target as hue, but I had problems generating it. Maybe, later.","25e89dec":"By couting the occurrences for each binary variable, both in train and test data, we can see that most of them are predominantly **0**, except for: `Wilderness_Area1`, which is more balanced; and `Wilderness_Area3`, which is mostly **1**. Also, `Soil_Type7` and `Soil_Type15` are always **0**, so they bring no value, and can be safely dropped.","caf7d3db":"## Target distribution","0d88380e":"**Correlation between numeric variables only.**","4b9b90c1":"Classes 1 and 2 account for 93.25% of all data. Class 5 only has a single observation. \ud83d\ude31","bf81dc93":"This December's TPS competition is a multiclass classification task, with a very imbalanced target. The dataset is composed of data synthetically generated from the [Forest Cover Type Prediction](https:\/\/www.kaggle.com\/c\/forest-cover-type-prediction).","86ecf088":"From the count plot below, we can see that the target (`Cover_Type`) has 7 classes and is very imbalanced.","867f7f57":"## Introduction","9fa00182":"I think it's just some noise\/artifact introduced by the GAN, and doesn't contribute with predictions, as can be seen below.","f5ac96d8":"**Distribution of binary features per class.** The table below shows, for each pair of feature and target class, how much of the values are **1**. So, for example, in the first cell, we can see that only 1.52% of `Sail_Type1` are **1** for Cover Type 1.","eeeadc56":"**Heatmap of correlations.** My thoughts:\n - `Elavation` and `Cover_Type` have a very negative correlation, because of the preferred range of Cover Type 1, 2, and 3.\n - `Wilderness_Area4` and `Elevation` are somewhat correlated. I imagine this area exists mostly at a certain elevation.\n - `Wilderness_Area3` and `Wilderness_Area1` are very correlated."}}