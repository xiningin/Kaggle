{"cell_type":{"ebb0b41c":"code","028cd765":"code","1f3fabee":"code","d6ba4a73":"code","751f59fa":"code","e316aad4":"code","730775e2":"code","2ad38dcd":"code","99a2ba92":"markdown","263c4651":"markdown","8454b56d":"markdown","2328cd54":"markdown","b649ffa7":"markdown","1499c0eb":"markdown","1419e630":"markdown","70c5b130":"markdown"},"source":{"ebb0b41c":"from math import sin\nfrom math import pi\nfrom matplotlib import pyplot\n# create sequence\nlength = 100\nfreq = 5\nsequence = [sin(2 * pi * freq * (i\/float(length))) for i in range(length)]\n# plot sequence\npyplot.plot(sequence)\npyplot.show()","028cd765":"from math import sin\nfrom math import pi\nfrom math import exp\nfrom matplotlib import pyplot\n# create sequence\nlength = 100\nperiod = 10\ndecay = 0.05\nsequence = [0.5 + 0.5 * sin(2 * pi * i \/ period) * exp(-decay * i) for i in range(length)]\npyplot.plot(sequence)\npyplot.show()","1f3fabee":"import numpy as np\nfrom math import sin, pi, exp\nfrom random import randint, uniform\nimport matplotlib.pyplot as plt\nfrom keras.models import Sequential\nfrom keras.layers import LSTM, Dense","d6ba4a73":"# generate damped sine wave in [0,1]\ndef generate_sequence(length, period, decay):\n    return [0.5 + 0.5 * sin(2 * pi * i \/ period) * exp(-decay * i) for i in range(length)]\n# generate input and output pairs of damped sine waves\ndef generate_examples(length, n_patterns, output):\n    X, y = list(), list()\n    for _ in range(n_patterns):\n        p = randint(10, 20)\n        d = uniform(0.01, 0.1)\n        sequence = generate_sequence(length + output, p, d)\n        X.append(sequence[:-output])\n        y.append(sequence[-output:])\n    X = np.array(X).reshape(n_patterns, length, 1)\n    y = np.array(y).reshape(n_patterns, output)\n    \n    return X, y\n\n# test problem generation\nX, y = generate_examples(50, 5, 5)\nfor i in range(len(X)):\n    plt.plot([x for x in X[i, :, 0]] + [x for x in y[i]], '-o')\nplt.show()","751f59fa":"# configure problem\nlength = 50\noutput = 5\n\n# define model\nmodel = Sequential()\nmodel.add(LSTM(20,return_sequences=True, input_shape=(length,1)))\nmodel.add(LSTM(20))\n#The output layer will use the linear activation function\nmodel.add(Dense(output))\nmodel.compile(loss='mae', optimizer='adam')\nmodel.summary()","e316aad4":"# fit model\nX, y = generate_examples(length, 50000, output)\nmodel.fit(X, y, batch_size=10, epochs=3)","730775e2":"# evaluate model\nX, y = generate_examples(length, 1000, output) \nloss = model.evaluate(X, y, verbose=0) \nprint('MAE: %f' % loss)","2ad38dcd":"# prediction on new data\nX, y = generate_examples(length, 1, output) \nyhat = model.predict(X, verbose=0) \nplt.plot(y[0], label='y') \nplt.plot(yhat[0], label='yhat') \nplt.legend()\nplt.show()","99a2ba92":"<center><h3>Modelling","263c4651":"<center><h3>Many-to-one model<\/h3><\/center><br>\n<div style=\"font-family:verdana; word-spacing:1.5px;\">\nTechnically this is a many-to-one sequence prediction problem. This may be confusing because we clearly intend to predict a sequence of output time steps. The reason that this is a many-to-one prediction problem is because the model will not predict the output time steps piecewise; the whole prediction will be produced at once.\nFrom a model perspective, a sequence of n time steps is fed in, then at the end of the sequence a single prediction is made; it just so happens that the prediction is a vector of n features that we will interpret as time steps. We could adapt the model to be many-to-many with architectural changes to the proposed LSTM.\n<\/div>\n\n![image.png](attachment:image.png)","8454b56d":"<center><h3>Sequences of Damped Sine Waves<\/h3><\/center><br>\n<div style=\"font-family:verdana; word-spacing:1.5px;\">\nWe need a function to generate sequences with a randomly selected period and decay. We will select a uniformly random period between 10 and 20 using the randint() function and a uniformly random decay between. 0.01 and 0.1 using the uniform() function.\n    <\/div>","2328cd54":"<div style=\"font-family:verdana; word-spacing:1.5px;\">\nWe will generate 50,000 random damped sine wave examples to fit the model and fit the model using one epoch of this dataset. This is like fitting the model for 50,000 epochs. Ideally, we would reset the internal state of the model after each sample by setting the batch size to 1. In this case, we will trade-off purity for training speed and set the batch size to 10. This will mean that the model weights will be updated and the LSTM memory cell internal state will be reset after each 10 samples.","b649ffa7":"<div style=\"font-family:verdana; word-spacing:1.5px;\">\nRunning the example creates 5 damped sine wave sequences each with 50 time steps. An additional 5 time steps are generated at the end of the sequence that will be held back as test data.\n<br><br>\nThis is a regression type sequence prediction problem. It may also be considered a time series forecasting regression problem. In time series forecasting, it is good practice to make the series stationary, that is remove any systematic trends and seasonality from the series before modeling the problem. This is recommended when working with LSTMs.\n<br><br>\nWe are intentionally not making the series stationary to demonstrate the capability of the Stacked LSTM.\n    <\/div>","1499c0eb":"<center><h2>Damped Sine Wave Prediction Problem<\/h2><\/center>\n<br>\n\n<h3>Sine Wave<\/h3>\n<div style=\"font-family:verdana; word-spacing:1.5px;\">\nA sine wave describes an oscillation over time that has a consistent amplitude (movement from baseline) and frequency (time steps between minimum and maximum values).\n<\/div>","1419e630":"<center><h3>Importing Libraries","70c5b130":"<h3>Damped Sine Wave<\/h3>\n<div style=\"font-family:verdana; word-spacing:1.5px;\">\n\nThere is a type of sine wave that decreases with time. The decrease in amplitude provides an additional longer term movement that may require an additional level of abstraction in the LSTM to learn.\n<\/div>"}}