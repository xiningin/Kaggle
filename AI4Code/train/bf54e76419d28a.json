{"cell_type":{"6d8d4932":"code","8531ad7b":"code","87a1b6c0":"code","2f80b320":"code","1ebdff2a":"code","d451e561":"code","80ee3c4e":"code","e91df87b":"code","81de7d2b":"code","2c8973bd":"code","13e0d064":"code","480f976d":"code","47ff04db":"code","0ccc4961":"code","8d915310":"code","2d242b35":"code","0a4ae598":"code","6eee249b":"markdown","d51ae5fe":"markdown","bf7c7d08":"markdown"},"source":{"6d8d4932":"## pd and np to begin with\nimport pandas as pd\nimport numpy as np \n\n## old plots\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n## my sea horse seaborn\nimport seaborn as sns\nsns.set()\n\n### HTML hmm\nfrom IPython.display import HTML\n\n### Check the files\nfrom os import listdir\nprint(listdir(\"..\/input\"))\n\n## supress those annyoing warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\nwarnings.filterwarnings(\"ignore\", category=FutureWarning)","8531ad7b":"train = pd.read_csv(\"..\/input\/train.csv\", nrows=10000000)\n","87a1b6c0":"train.head(2)","2f80b320":"train.rename({\"acoustic_data\" : \"sig\",\"time_to_failure\" : \"qtime\"}, axis = \"columns\", inplace=True)","1ebdff2a":"### lets see the values in such sensitive data\nprint(range(3))\nfor n in range(3):\n    print(train.qtime.values[n])","d451e561":"fig, ax = plt.subplots(2,1, figsize=(20,12))\n\nax[0].plot(train.index.values, train.sig.values, c=\"blue\")\nax[0].set_title(\"Sig of 10 M rows\")\nax[0].set_xlabel(\"Index\")\nax[0].set_ylabel(\"Signal\");\n\nax[1].plot(train.index.values, train.qtime.values, c=\"green\")\nax[1].set_title(\"Qtime of 10 M rows\")\nax[1].set_xlabel(\"Index\")\nax[1].set_ylabel(\"Qtime in ms\");","80ee3c4e":"fig, ax = plt.subplots(3,1,figsize=(20,18))\nax[0].plot(train.index.values[0:50000], train.qtime.values[0:50000], c=\"Red\")\nax[0].set_xlabel(\"Index\")\nax[0].set_ylabel(\"Time to quake\")\nax[0].set_title(\"How does the second quaketime pattern look like?\")\nax[1].plot(train.index.values[0:49999], np.diff(train.qtime.values[0:50000]))\nax[1].set_xlabel(\"Index\")\nax[1].set_ylabel(\"Difference between quaketimes\")\nax[1].set_title(\"Are the jumps always the same?\")\nax[2].plot(train.index.values[0:4000], train.qtime.values[0:4000])\nax[2].set_xlabel(\"Index from 0 to 4000\")\nax[2].set_ylabel(\"Quaketime\")\nax[2].set_title(\"How does the quaketime changes within the first block?\");","e91df87b":"test_path = \"..\/input\/test\/\"","81de7d2b":"test_files = listdir(\"..\/input\/test\")\nsample_submission = pd.read_csv(\"..\/input\/sample_submission.csv\")\n","2c8973bd":"fig, ax = plt.subplots(4,1, figsize=(20,25))\n\nfor n in range(4):\n    seg = pd.read_csv(test_path  + test_files[n])\n    ax[n].plot(seg.acoustic_data.values, c=\"Red\")\n    ax[n].set_xlabel(\"Index\")\n    ax[n].set_ylabel(\"Signal\")\n    ax[n].set_ylim([-300, 300])\n    ax[n].set_title(\"Test {}\".format(test_files[n]));","13e0d064":"fig, ax = plt.subplots(1,2, figsize=(20,5))\nsns.distplot(train.sig.values, ax=ax[0], color=\"Green\", bins=100, kde=False)\nax[0].set_xlabel(\"Signal\")\nax[0].set_ylabel(\"Density\")\nax[0].set_title(\"Signal distribution\")\n\nlow = train.sig.mean() - 3 * train.sig.std()\nhigh = train.sig.mean() + 3 * train.sig.std() \nsns.distplot(train.loc[(train.sig >= low) & (train.sig <= high), \"sig\"].values,\n             ax=ax[1],\n             color=\"Red\",\n             bins=150, kde=False)\nax[1].set_xlabel(\"Signal\")\nax[1].set_ylabel(\"Density\")\nax[1].set_title(\"Signal distribution without peaks\");","480f976d":"stepsize = np.diff(train.qtime)\ntrain = train.drop(train.index[len(train)-1])\ntrain[\"stepsize\"] = stepsize\ntrain.head(5)","47ff04db":"train.stepsize = train.stepsize.apply(lambda l: np.round(l, 10))","0ccc4961":"stepsize_counts = train.stepsize.value_counts()\nstepsize_counts","8d915310":"from sklearn.model_selection import TimeSeriesSplit\n\ncv = TimeSeriesSplit(n_splits=5)","2d242b35":"### Rolling Window Approach \nwindow_sizes = [10, 50, 100, 1000]\nfor window in window_sizes:\n    train[\"rolling_mean_\" + str(window)] = train.sig.rolling(window=window).mean()\n    train[\"rolling_std_\" + str(window)] = train.sig.rolling(window=window).std()","0a4ae598":"fig, ax = plt.subplots(len(window_sizes),1,figsize=(20,6*len(window_sizes)))\n\nn = 0\nfor col in train.columns.values:\n    if \"rolling_\" in col:\n        if \"mean\" in col:\n            mean_df = train.iloc[4435000:4445000][col]\n            ax[n].plot(mean_df, label=col, color=\"Green\")\n        if \"std\" in col:\n            std = train.iloc[4435000:4445000][col].values\n            ax[n].fill_between(mean_df.index.values,\n                               mean_df.values-std, mean_df.values+std,\n                               facecolor='Orange',\n                               alpha = 0.5, label=col)\n            ax[n].legend()\n            n+=1\n","6eee249b":"## The P (python) Packages :D","d51ae5fe":"**BE HOLD THE TIME  SERIES SPLIT**","bf7c7d08":"## Through this competition I am trying to learn on : \n\nGiven seismic signals, predict the time until the onset of laboratory earthquakes.\n* The training data is a single sequence of signal\n* In contrast the test data is called segments\n* For each seg_id, predict it's  time until the  earthquake"}}