{"cell_type":{"ad54fff1":"code","6f5fdead":"code","61ee68e1":"code","18221d2a":"code","306d9c2b":"code","e78ca61c":"code","b097d811":"code","7aa41b68":"markdown","3cc746ae":"markdown","ff580c89":"markdown","9db91e70":"markdown","b2b89165":"markdown","03f542e0":"markdown","47f4642a":"markdown"},"source":{"ad54fff1":"%%capture\nimport torch\nimport numpy as np\nimport pandas as pd\nfrom sklearn.cluster import KMeans\nfrom statsmodels.discrete.discrete_model import Probit\nimport patsy\nimport matplotlib.pylab as plt\nimport tqdm\nimport itertools\n\nax = np.newaxis","6f5fdead":"\n!pip install pygrpfe\nimport pygrpfe as gfe","61ee68e1":"def dgp_simulate(ni,nt,gamma=2.0,eps_sd=1.0):\n    \"\"\" simulates according to the model \"\"\"\n    alpha = np.random.normal(size=(ni))\n    eps   = np.random.normal(size=(ni,nt))\n    v     = np.random.normal(size=(ni,nt))\n    \n    # non-censored outcome\n    W = alpha[:,ax] + eps*eps_sd\n    \n    # utility\n    U = (np.exp( alpha * (1-gamma)) - 1)\/(1-gamma)\n    U = U - U.mean()\n    \n    # costs\n    C1 = -1; C0=0;\n    \n    # binary decision\n    Y = np.ones((ni,nt))\n    Y[:,0] = U.squeeze() > C1 + v[:,0]\n    for t in range(1,nt): \n        Y[:,t] = U > C1*Y[:,t-1] + C0*(1-Y[:,t-1]) + v[:,t]\n    W =  W * Y\n        \n    return(W,Y)","18221d2a":"ni = 1000\nnt = 20\nY,D = dgp_simulate(ni,nt,2.0)","306d9c2b":"# we create the moments\n# this has dimension ni x nt x nm \nM_itm = np.stack([Y,D],axis=2)\n\n# we use our sugar function to get the groups\nG_i,_  = gfe.group(M_itm)\n\nprint(\"Number of groups = {:d}\".format(G_i.max()))","e78ca61c":"dd = pd.DataFrame({'Y':Y.mean(1),'G':G_i,'D':D.mean(1)})\nplt.scatter(dd.Y,dd.D,c=dd.G*1.0)\nplt.show()","b097d811":"ni,nt = D.shape\n\n# next we minimize using groups as FE\ndd = pd.DataFrame({\n    'd': D[:,range(1,nt)].flatten(), \n    'dl':D[:,range(nt-1)].flatten(), \n    'gi':np.broadcast_to(G_i[:,ax], (ni,nt-1)).flatten()})\n\nyv,Xv = patsy.dmatrices(\"d ~ 0 + dl + C(gi)\", dd, return_type='matrix')\nmod = Probit(dd['d'], Xv)\nres = mod.fit(maxiter=2000,method='bfgs') \n\nprint(\"Estimated cost parameters = {:.3f}\".format(res.params[-1]))","7aa41b68":"The following command makes sure the pygfe package is installed. It provides a small set of helper functions. You can view it online at [pygrpfe](https:\/\/github.com\/tlamadon\/pygrpfe). Here we install it using a shell pip command:","3cc746ae":"We can plot the grouping:","ff580c89":"## Step 2: Estimate the likelihood model with group specific parameters\n\nIn the model we proposed, this second step is a probit. We can then directly use the python probit routine with group dummies.","9db91e70":"## Step 1: grouping observations\n\nWe group individuals based on their outcomes. We consider as moments the average value of $DY$ and the average value of $D$. We give our gfe function the $t$-specific values so that it can compute the within individual variation. This is a measure used to pick the nubmer of groups.\n\nThe `group` function chooses the number of groups based on the rule described in the paper. ","b2b89165":"# Discretizing Unobserved Heterogeneity: A Step-by-Step Example\n\nWelcome to the example on using the estimator proposed in [Bonhomme, Lamadon and Manresa (2021)](https:\/\/www.econometricsociety.org\/system\/files\/15238-5.pdf). This notebook provides the code to reproduce the first example of the paper. \n\nWe will simulate from a model and estimate the main parameters by grouping individuals first.\n\nYou can run the code in this notebook by selecting `Runtime > Run all` in the menu bar.\n\n","03f542e0":"# Simulating and estimating the model\n\nWe show the steps to estimating the model. \n\nWe simulate from the DGP we have defined.","47f4642a":"# A simple model of wage and participation\n\n\\begin{align*}\nY^*_{it} & = \\alpha_i + \\epsilon_{it} \\\\\nD_{it} &= 1\\big[ u(\\alpha_i) \\geq c(D_{it-1}) + V_{it}  \\big] \\\\\nY_{it} &= D_{it} Y^*_{it} \\\\\n\\end{align*}\n\nwhere we use \n\n$$u(\\alpha) = \\frac{e^{(1-\\gamma) \\alpha } -1}{1-\\gamma}$$\n\nand use as initial conditions $D_{i1} = 1\\big[ u(\\alpha_i) \\geq c(1) + V_{i1}  \\big]$."}}