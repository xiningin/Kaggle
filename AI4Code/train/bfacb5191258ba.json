{"cell_type":{"eb229c6d":"code","ae2d7acf":"code","ac3af491":"code","f115cf2d":"code","96d9af69":"code","9fc31fec":"code","70bc67f7":"code","9f6c3cb7":"code","ccc39a22":"code","9aec5e70":"markdown","7061e039":"markdown","ed2ee0fe":"markdown","c63d20f0":"markdown","a1a11d2a":"markdown","f6c6d517":"markdown","1d0b3fcd":"markdown","a1dc2e24":"markdown","a329f6ef":"markdown","26b5ac5d":"markdown","1a8d87e2":"markdown","6e1966d1":"markdown"},"source":{"eb229c6d":"import numpy as np\nimport pandas as pd\nimport os\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","ae2d7acf":"def get_df(target_csv, category):\n        #raw_df is a DataFrame that contains all the messy data in the original .csv file\n    raw_df = pd.read_csv(target_csv,names = list(range(9)), skip_blank_lines = False)\n    \n        #\"start\" denotes the index where the data in the desired category begins\n    start = int(np.where(raw_df[0] == category)[0] + 1)\n    \n        #\"blank_separators\" is a list of indices where the first column value is null, meaning the end of a category\n    blank_separators = np.where(raw_df[0].isnull())[0]\n        #\"stop\" finds the first value in this list comprehension of \"blank_separators\" that comes after the \"start\" index\n    stop = [x for x in blank_separators if x > start][0] - 1\n    return(pd.read_csv(target_csv, skiprows = start, nrows = stop-start))","ac3af491":"def combine(category):\n    combined_df = pd.DataFrame()\n    for filename in os.listdir(folder_path):\n        combined_df = combined_df.append(get_df((folder_path +\"\/\" + filename), category))\n    return(combined_df)","f115cf2d":"folder_path = r'..\/input\/d\/jakebaisden\/fitbit-exports'\ncombine('Activities').info()","96d9af69":"folder_path = r'..\/input\/d\/jakebaisden\/fitbit-exports'\ncombine('Sleep').head()[['Start Time', 'End Time']]","9fc31fec":"def clean_types(df):\n    for column in df:\n        if df.dtypes[column] == 'object':\n            try:\n                df[column] = pd.to_numeric(df[column].str.replace(\",\", \"\"))\n            except ValueError:\n                df[column] = (df[column].str.split(n=1, expand = True))[0]\n                df[column] = pd.to_datetime(df[column], format = '%Y-%m-%d')\n            except ValueError:\n                df[column] = pd.to_datetime(df[column], format = '%Y-%m-%d')\n    return(df)\n","70bc67f7":"def create_full_df():\n    sleep_df = clean_types(combine('Sleep'))\n    activities_df = clean_types(combine('Activities'))\n    body_df = clean_types(combine('Body'))\n\n    sleep_df['Date'] = sleep_df['End Time']\n    sleep_df.drop(columns = ['Start Time', 'End Time'], inplace = True)\n    full_df = sleep_df.merge(activities_df, on = 'Date').merge(body_df, on = 'Date')\n\n    return(full_df.sort_values(by = 'Date'))","9f6c3cb7":"create_full_df().info()","ccc39a22":"create_full_df().head()","9aec5e70":"# Combining data\nThe method combine() takes the desired category as an argument, walks through each month's .csv file in our directory, and finally returns just that category's data for every month combined into one DataFrame using our previously defined get_df() method.","7061e039":"The first function we need will be called get_df, and will return a DataFrame object from the original .csv file that only contains the desired category (Sleep, Activities, etc.)","ed2ee0fe":"# Start\nThe only libraries we need are numpy, pandas and os.","c63d20f0":"# Goals\n* Import every .csv file from a single folder in a directory\n* Separate the monthly data from each csv file by category\n* Combine the category's data from each month into a single file  \n\n    \n      \n      ","a1a11d2a":"# Conclusion\nAs you can see, we have taken many messy csv files from different months and were able to combine them into a single and clean dataframe with the desired data types. If we wanted, we could convert this back into a .csv file to open in Excel, or just keep the dataframe object to analyze with Python. ","f6c6d517":"To begin with, in our 'Sleep' category, instad of the variable 'Date' we unfortunately have 'Start Time' and 'End Time' variables stored as strings like this:","1d0b3fcd":"Second, after the month's data is downloaded, each category is stacked on top of each other in the same .csv file, with differing numbers of columns and data formats:  \n  \n  \n![FitbitDataPic.PNG](attachment:6f63661d-ee0d-4229-a084-3293595eaa1d.PNG)","a1dc2e24":"Now that we have methods for separating the category's data from each month's messy .csv file, combining them into single dataframes, and cleaning their data types to make them easier to work with, we can write our main method that returns the full data frame using those three methods. The different categories will join based on their datetime values.","a329f6ef":"Let's see what our final dataframe looks like!","26b5ac5d":"Now we need to clean up the data types. In our 'Activities' category, the variables Calories Burned, Steps, Activity calories, and Minutes Sedentary\/Lightly active\/Very active are stored as objects instead of integers. This will make it difficult if we want to analyze this data. We'd also like to change the 'Date' variable to a datetime object. Take a look at the data types below:","1a8d87e2":"To fix this, the clean_types() method below loops through each column with an \"object\" data type in a given DataFrame. Some of the values greater than 999 are stored as strings with a comma (1,000 for example). If the column's values have commas anywhere, they'll be removed and the values will be converted to integers. When the method finds the 'Start Time' and 'End Time' columns, it will strip the time from the string and convert them to datetime objects.","6e1966d1":"# Challenges\n\n Analyzing Fitbit data on your own can be a little tricky, and they don't make it easy. \n First, you can only download up to 31 days worth of data at a time using the Fitbit website's UI:  \n  \n  ![Export_UI.PNG](attachment:5e8c2624-af81-4667-a3b4-354e4927ee8c.PNG)"}}