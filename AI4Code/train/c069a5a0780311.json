{"cell_type":{"afc32aea":"code","a7ff2ad6":"code","75097818":"code","3ebc9924":"code","37fe2457":"code","4222ffbe":"code","e7ecd2aa":"code","e23f0f08":"code","09f65e82":"code","0ab279aa":"code","c24d8345":"code","d8532f71":"code","7670205f":"code","4bf191d7":"code","5729efaf":"code","5882cda8":"code","61eaa93c":"code","a4beca85":"code","90996b1b":"code","8b06c457":"code","cd282ab5":"code","d0e5d973":"code","bcd9ab1b":"code","e7ed14c5":"code","2b5b27e2":"code","c3521b1b":"code","73b6ed02":"code","279b99c7":"code","ba118d16":"code","e421eb63":"code","540df151":"code","932f4875":"code","7b7df4ce":"code","3a43fbbf":"code","01cc7da2":"code","0b3217f3":"code","5b4dcb7f":"code","98e93424":"code","819205ef":"code","2fc52cb5":"markdown","b90829c8":"markdown","6dea02f2":"markdown","492d6915":"markdown","a20bf911":"markdown","a9f11523":"markdown","0b90caf7":"markdown","803c54c1":"markdown","1c2663e6":"markdown","92347f44":"markdown","50a922b2":"markdown","71639e1f":"markdown","b8976903":"markdown","74732873":"markdown","5d5b6e77":"markdown","9497731d":"markdown","65948da4":"markdown","bd09b4fc":"markdown","6baf768d":"markdown","15ae0473":"markdown","af7106a9":"markdown","949ec598":"markdown","8a77825a":"markdown","f9665f20":"markdown","368cd72c":"markdown","e3e2724f":"markdown","9661ae8b":"markdown","71a21b6a":"markdown","9c26b5be":"markdown","aff2424a":"markdown"},"source":{"afc32aea":"import math\n\nclass City:   \n    def __init__(self, id_, x, y):\n        self.x = x\n        self.y = y\n        self.coord = (x, y)\n        self.id = id_\n        self.is_visited = False\n        self.is_prime = self.check_prime()\n        \n    def check_prime(self):\n        \"\"\"\n        Checks if a city is prime\n        \"\"\"\n        if self.id % 2 == 0 and self.id > 2: \n            return False\n        return all(self.id % i for i in range(3, int(math.sqrt(self.id)) + 1, 2))\n    \n    def visit(self):\n        \"\"\"\n        Mark city as visited\n        \"\"\"\n        self.is_visited = True\n        \n    def __repr__(self):\n        '''\n        Prints all the properties of the object. idea is to be as verbose as possible.\n        Implementing __repr__ or __str__ will make it easy to print and inspect in the notebook.\n        '''\n        fmt_str = 'CityId: {} \\nCoordinates: {}\\nIs prime: {}\\nIs visited: {}'\n        return fmt_str.format(self.id, self.coord, self.is_prime, self.is_visited)","a7ff2ad6":"foo = City(2, 1, 1) # a city object with id=2, x=1 and y=1\nfoo","75097818":"foo.visit()\nfoo","3ebc9924":"# creating another City\nbar = City(4, 3, 0)\nbar","37fe2457":"import matplotlib.pyplot as plt\n\nclass World:\n    def __init__(self):\n        self.cities = dict()\n    \n    def add(self, city):\n        \"\"\"\n        Adds a single city to the world\n        \"\"\"\n        if isinstance(city, City):\n            # checks if the object type added to the world is correct\n            self.cities[city.id] = city\n        else:\n            raise TypeError ('city must be a \"__main__.City\" object!')","4222ffbe":"# Creating an empty world\nworld = World()\n# Getting the list of cities\nworld.cities","e7ecd2aa":"# adding the foo city\nworld.add(foo)\n# adding the bar city\nworld.add(bar)\nworld.cities","e23f0f08":"# adding the bar city again should trow an error\nworld.add(bar)\nworld.cities","09f65e82":"for id_, c in world.cities.items():\n    print(c, '\\n')","0ab279aa":"class World:\n    def __init__(self):\n        self.cities = dict()\n        self.df = pd.DataFrame()\n    \n    def add(self, city):\n        \"\"\"\n        Adds a single city to the world\n        \"\"\"\n        if isinstance(city, City):\n            # checks if the object type added to the world is correct\n            self.cities[city.id] = city\n        else:\n            raise TypeError ('city must be a \"__main__.City\" object!')\n        self.update_df()\n    \n    def remove_by_id(self, id_):\n        \"\"\"\n        Removes a single city from the world\n        \"\"\"\n        self.cities.pop(id_)\n    \n    def bulk_add_city(self, dataframe):\n        \"\"\"\n        Adds cities in bulk from a DataFrame\n        \"\"\"\n        dataframe['city'] = dataframe.apply(lambda x: City(x.iloc[0], x.iloc[1], x.iloc[2]), axis=1)\n        dataframe = dataframe.drop(['X','Y'], axis=1)\n        dataframe = dataframe.set_index('CityId')\n        cities = dataframe.to_dict()['city']\n        self.cities.update(cities)\n        self.update_df()\n    \n    def size(self):\n        \"\"\"\n        Gets the quantity of cities in the world\n        \"\"\"\n        return self.df.shape[0]\n    \n    def primes(self):\n        \"\"\"\n        Gets the world prime cities\n        \"\"\"\n        return [c for idx, c in self.cities.items() if c.is_prime]\n    \n    def nonprimes(self):\n        \"\"\"\n        Gets the world nonprime cities\n        \"\"\"\n        return [c for idx, c in self.cities.items() if not c.is_prime]\n    \n    def north_pole(self):\n        \"\"\"\n        Gets the North Pole\n        \"\"\"\n        return self.cities[0]\n                \n    def ids(self):\n        \"\"\"\n        Gets all world cities ids\n        \"\"\"\n        return list(self.cities.keys())\n    \n    def get_city(self, id_):\n        \"\"\"\n        Get a city by id\n        \"\"\"\n        return self.cities[id_]\n    \n    def update_df(self):\n        \"\"\"\n        Get cities coordinates as a dataframe\n        \"\"\"\n        dataframe = pd.DataFrame.from_dict(world.cities, orient='index', columns=['city'])\n        dataframe['x'] = dataframe.apply(lambda x: x.iloc[0].x, axis=1)\n        dataframe['y'] = dataframe.apply(lambda x: x.iloc[0].y, axis=1)\n        dataframe['id'] = dataframe.apply(lambda x: x.iloc[0].id, axis=1)\n        dataframe['is_prime'] = dataframe.apply(lambda x: x.iloc[0].is_prime, axis=1)\n        self.df = dataframe\n    \n    def plot(self, show_primes=False):\n        \"\"\"\n        Creates a world plot, mark the north pole. Option to show primes in different collor\n        \"\"\"\n        self.df.plot.scatter(x='x', y='y', s=0.07, figsize=(15, 10), c='green', alpha=0.6)\n\n        if show_primes:\n            coords = self.df[self.df['is_prime']]\n            plt.scatter(x=coords.x, y=coords.y, c='red', s=0.1, alpha=0.6)\n        \n        plt.scatter(self.north_pole().x, self.north_pole().y, c='blue', s=16)\n        plt.axis('off')\n        \n        return plt.show()","c24d8345":"import pandas as pd\ndf = pd.read_csv('..\/input\/cities.csv')\ndf.head()","d8532f71":"df.shape # the dataset shape","7670205f":"world = World() # creates a new empty world\nworld.cities","4bf191d7":"world.bulk_add_city(df) # adds all cities from the dataframe into the world","5729efaf":"world.size()","5882cda8":"world.north_pole().coord","61eaa93c":"len(world.primes())","a4beca85":"world.plot()","90996b1b":"world.plot(show_primes=True)","8b06c457":"import io\nimport base64\nimport time\n\nimport numpy as np\n\nfrom concorde.tsp import TSPSolver\n\nimport pylab as pl\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nfrom matplotlib import collections  as mc\n\nfrom IPython.display import display, HTML\n\nclass Route():\n    def __init__(self, world):\n        # Init path with just the North Pole\n        self.world = world\n        self.stops = [self.world.north_pole()]\n        self.tenth_steps = []\n        self.prime_tenth_steps = self.get_prime_tenth_steps()\n        \n    @staticmethod\n    def distance(a, b):\n        \"\"\"\n        calculates the euclidian distance between 2 cities\n        \"\"\"\n        return math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2)\n    \n    def size(self):\n        \"\"\"\n        Calculates the number of stops in the path\n        \"\"\"\n        return len(self.stops)\n    \n    def add(self, ids):\n        \"\"\"\n        Add stop to path\n        \"\"\"\n        if isinstance(ids, type(list())):\n            for id_ in ids:\n                self.stops.append(self.world.get_city(id_))\n        elif isinstance(ids, type(int())):\n            self.stops.append(self.world.get_city(ids))\n    \n    def add_world(self):\n        \"\"\"\n        Adds all cities in the world to the route\n        \"\"\"\n        self.add(list(range(1, self.world.size())))\n        \n    def cost(self):\n        \"\"\"\n        Calculates the Path Cost Function - penalized distance of the full path\n        \"\"\"\n        dist = 0\n        l = self.size()\n        for idx, stop in enumerate(self.stops):\n            curr_ = stop\n            step_number = idx + 1\n            if step_number < l:\n                next_ = self.stops[step_number]\n            if step_number % 10 == 0 and not curr_.is_prime:\n                dist += self.distance(curr_, next_) * 1.1\n            else:\n                dist += self.distance(curr_, next_)\n        return dist\n    \n    def euclidian_cost(self):\n        \"\"\"\n        Calculates the Path Cost Function - without penalties\n        \"\"\"\n        dist = 0\n        l = self.size()\n        for idx, stop in enumerate(self.stops):\n            curr_ = stop\n            step_number = idx + 1\n            if step_number < l:\n                next_ = self.stops[step_number]\n            dist += self.distance(curr_, next_)\n        return dist\n    \n    def penalty(self):\n        \"\"\"\n        Total penalty by not going to prime cities\n        \"\"\"\n        return self.cost() - self.euclidian_cost()\n    \n    def get_tenth_steps(self):\n        \"\"\"\n        Get the cities of all 10th steps\n        \"\"\"\n        self.tenth_steps = [c for s,c in enumerate(self.stops) if (s + 1) % 10 == 0]\n        return self.tenth_steps\n    \n    def get_prime_tenth_steps(self):\n        \"\"\"\n        Get cities in 10th steps that are prime \n        \"\"\"\n        primes = self.world.primes()\n        self.prime_tenth_steps = [c for c in self.tenth_steps if c in primes]\n        return self.prime_tenth_steps\n    \n    def get_ids(self):\n        \"\"\"\n        Get a ordered list of all city ids in the path.\n        \"\"\"\n        return [c.id for c in self.stops]\n\n    def concorde(self, time):\n        \"\"\"\n        Solve the problem with concorde solver. Without penalization of prime cities.\n        \"\"\"\n        x = [c.x for c in self.stops[:-1]]\n        y = [c.y for c in self.stops[:-1]]\n\n        # Instantiate solver\n        solver = TSPSolver.from_data(x, y, norm=\"EUC_2D\")\n        \n        # solve\n        tour_data = solver.solve(time_bound=float(time), verbose=True, random_seed=42)\n        \n        # Reorder the route with concorde solution\n        order = np.append(tour_data.tour,[0])\n        new_route = [self.stops[i] for i in order]\n        self.stops = new_route\n    \n    def plot(self, show_primes=False, show_10th_step=False, show_intersection=False):\n        \"\"\"\n        Plot the route\n        \"\"\"\n        lwidth, lalpha = 0.4, 0.6\n        lines = [[self.stops[i].coord,self.stops[i + 1].coord] for i in range(0, self.size() - 1)]\n        lc = mc.LineCollection(lines, linewidths=lwidth, alpha=lalpha, colors='red')\n        fig, ax = pl.subplots(figsize=(20,20))\n        \n        ax.set_aspect('equal')\n        ax.add_collection(lc)\n        ax.autoscale()   \n        \n        if show_primes:\n            # get coords of prime cities\n            coords = self.world.df[self.world.df['is_prime']]\n            # plot\n            pc = plt.scatter(x=coords.x, y=coords.y, c='green', s=3, alpha=0.3) \n            ax.add_collection(pc)\n        \n        if show_10th_step:\n            # get coords of each 10th stop\n            coords = [c.coord for c in self.tenth_steps]\n            coords = pd.DataFrame(coords, columns=['x','y'])\n            # plot \n            pc = plt.scatter(x=coords.x, y=coords.y, c='blue', s=3, alpha=0.3) \n            ax.add_collection(pc)\n        \n        if show_intersection:\n            # get coords of each 10th stop\n            coords = [c.coord for c in self.prime_tenth_steps]\n            coords = pd.DataFrame(coords, columns=['x','y'])\n            # plot \n            pc = plt.scatter(x=coords.x, y=coords.y, c='black', s=4, alpha=0.5) \n            ax.add_collection(pc)\n            return\n            \n    def animation(self, steps=500):\n        \"\"\"\n        Creates a route animation\n        \"\"\"\n        lwidth, lalpha = 0.4, 0.6\n        lines = [[self.stops[i].coord,self.stops[i + 1].coord] for i in range(0, self.size() - 1)]\n        fig, ax = pl.subplots(figsize=(15,15))\n        line, = ax.plot([], [], linewidth=lwidth, alpha=lalpha, color='red')\n        ax.set_ylim(0, 3650)\n        ax.set_xlim(0, 5250)\n        \n        def animate(i):\n            s = int(i+1) * steps\n            try:\n                data = lines[s - steps:s]\n            except IndexError:\n                data = lines\n            lc = mc.LineCollection(data, linewidths=lwidth, alpha=lalpha, colors='red')\n            ax.add_collection(lc)\n        \n        ani = animation.FuncAnimation(fig, animate, frames=int(len(lines) \/ steps), repeat=True)\n        ani.save('test.gif', writer='imagemagick', fps=20)\n        plt.close(1)\n        filename = 'test.gif'\n        video = io.open(filename, 'r+b').read()\n        encoded = base64.b64encode(video)\n        return HTML(data='''<img src=\"data:image\/gif;base64,{0}\" type=\"gif\" \/>'''.format(encoded.decode('ascii')))            \n    \n    def load(self, path):\n        \"\"\"\n        Loads external solution from csv file\n        \"\"\"\n        df = pd.read_csv(path)\n        ids = df['Path'].values.tolist()\n        self.stops = []\n        for id_ in ids:\n            self.stops.append(self.world.get_city(id_))\n        \n    def submit(self, filename):\n        \"\"\"\n        Export the path as a csv, on the required submission format\n        \"\"\"\n        dataframe = pd.DataFrame(self.stops, columns=['city'])\n        dataframe['Path'] = dataframe.apply(lambda x: x.iloc[0].id, axis=1).astype(int)\n        dataframe[['Path']].to_csv(filename, index=False)","cd282ab5":"route = Route(world)\nroute.stops","d0e5d973":"route.stops[0].id, route.stops[0].coord","bcd9ab1b":"# adding all cities ordered by id\nroute.add_world()\n# adding north pole at the end of \nroute.add(0)","e7ed14c5":"route.cost()","2b5b27e2":"route.animation()","c3521b1b":"route.plot()","73b6ed02":"route.submit('index_submission.csv')","279b99c7":"route.concorde(60)","ba118d16":"route.cost()","e421eb63":"route.euclidian_cost()","540df151":"route.penalty()","932f4875":"route.get_tenth_steps()\nroute.get_prime_tenth_steps()\nlen(route.prime_tenth_steps) \/ len(route.tenth_steps)","7b7df4ce":"route.plot()","3a43fbbf":"route.plot(show_primes=True)","01cc7da2":"route.plot(show_10th_step=True)","0b3217f3":"route.plot(show_primes=True, show_10th_step=True)","5b4dcb7f":"route.plot(show_intersection=True)","98e93424":"route.animation()","819205ef":"route.submit('concorde_submission.csv')","2fc52cb5":"Or Only the 10th steps that are primes:","b90829c8":"Or showing every 10th step:","6dea02f2":"Let's check how many cities we have in the Santa's World (the size of the world). We should have the same number of cities as the number of lines in the dataframe.","492d6915":"Now we may add the two cities that we had created before to the world:","a20bf911":"Or get the percentage of cities in tenth steps that are primes.","a9f11523":"Or get the simple euclidian cost:","0b90caf7":"## The Route\nNext we will create a route to guide Rudolf during the Christmas Eve. A route is a collection of cities, or stops, that are visited in sequence by Santa Claus and his reindeers. We may represent it by a list. Let's implement that.","803c54c1":"Ok! We have a really basic implementation of the world. Let's add some other methods to be able to load the Santa's world.","1c2663e6":"Plot the path:","92347f44":"Or both:","50a922b2":"Checking the first city id and coordinates.","71639e1f":"Good! We have cities! Now let's start building the world.\n\n## The World\nFirst of all, the world is simply a collection of unique cities. So... we may represent the world by a dict of cities! (we are using a dict, with city ids as keys, for the purpose of easy indexin and searching cities in the world. It would be inneficient to scan the whole world to find a city.\n\nSanta's world has one basic property that is listing all cities that are part of it. Let's first implement two methods in the world, one to add a new city, another one to remove an existing city.\n\n### Let's create the world","b8976903":"We can also show all primes cities in red.","74732873":"Let's plot an animation to see how santa would visit the cities:","5d5b6e77":"Now we can solve the path using concorde solver:","9497731d":"Or count the number of prime cities in the world:","65948da4":"Let's visit the city now!","bd09b4fc":"Then calculate its cost:","6baf768d":"We can access each city properties by doing a for loop:","15ae0473":"\nNow we can bulk insert all cities from a dataframe into our world. Let's do that","af7106a9":"We can easily get the North Pole coordinates:","949ec598":"Let's try to add the bar city again to the same world. Because bar already exists in the world, we shouldn't see a new city added to the world.","8a77825a":"Finally we can plot all cities in a map. North Pole in blue.","f9665f20":"To create a city object we just have to call ```City(id, x, y)``` passing the apropriate parameters:","368cd72c":"Now we may create a different city.","e3e2724f":"Our route starts with just one city: the North Pole.","9661ae8b":"Or plot the path showing the prime cities:","71a21b6a":"## Concorde Solver","9c26b5be":"Or the penalty by not visiting prime cities at the 10th steps.","aff2424a":"# Object Oriented Santa's Route\n\nSanta Claus lives in a wonderfull world! Let's implement his world with object oriented programming? This migh help us develop cleaner code when searching for the best path for his deliveries.\n\n## The City\nThe lowest level we can get in his world are the cities. They have some properties:\n* ```x```: the horizontal location on a map\n* ```y```: the vertical location on a map\n* ```id```: the city id, corresponds to the city name\n\nFrom those basic properties we may create another one:\n* ```coord```:  the tuple ```(x, y)```\n\nThen we may chek if a city is prime or not:\n* ```is_prime```:  Boolean indication if is prime\n\n### Let's implement all that and see how it works:"}}