{"cell_type":{"496d7385":"code","04bd7fb9":"code","7f3f3d43":"code","7acd9977":"code","b58fc58f":"code","90b98079":"code","1bd6bf3c":"markdown","2144fb0c":"markdown","829ae326":"markdown","00550e1c":"markdown","abe27881":"markdown"},"source":{"496d7385":"import cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd","04bd7fb9":"img = cv2.imread('..\/input\/sartorius-cell-instance-segmentation\/train\/13325f865bb0.png')\n_=plt.imshow(img[50:150, 160:310])\n","7f3f3d43":"mask = np.load('..\/input\/sample-mask\/mask.npy')\ncont, hier = cv2.findContours(mask,cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n_=plt.imshow(cv2.drawContours(np.zeros_like(mask), cont, -1, 1, 1))","7acd9977":"convex_mask = cv2.fillConvexPoly(np.zeros_like(mask),points=cont[0], color=1)\n_=plt.imshow(convex_mask)","b58fc58f":"def rle_decode(mask_rle, shape):\n    s = mask_rle.split()    \n    starts = list(map(lambda x: int(x) - 1, s[0::2]))\n    lengths = list(map(int, s[1::2]))\n    ends = [x + y for x, y in zip(starts, lengths)]\n    img = np.zeros((shape[0] * shape[1]), dtype=np.uint8)\n    for start, end in zip(starts, ends):\n        img[start : end] = 1\n    return img.reshape(shape)","90b98079":"df_train = pd.read_csv('..\/input\/sartorius-cell-instance-segmentation\/train.csv')\nlabel = df_train.iloc[4899][\"annotation\"]\nmask = rle_decode(label, shape=(520, 704))\n_=plt.imshow(mask[50:150, 160:310])","1bd6bf3c":"## And here is the actual mask found in the competition training data","2144fb0c":"## Here is a hypotetical polygon annotation of that cell","829ae326":"## Here is a sample cell","00550e1c":"## Here is the polygon above converted to bitmask with `cv2.fillConvexPoly` - leading to a clearly broken mask","abe27881":"# This notebook hypothesizes that broken masks found in the dataset are caused by incorrect polygon->bitmask conversion\n\nThis was originally found by @bakeryproducts \nI hadn't seen his notebook before it was removed, but I imagine it went something like this"}}