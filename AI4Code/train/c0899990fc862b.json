{"cell_type":{"7fc68f80":"code","85b1271a":"code","4ae580fe":"code","9aef6956":"code","783ebc1f":"code","3fb1f1e9":"code","1672523b":"code","b221e074":"code","24be51e9":"code","34b3c299":"code","2dd9c6bf":"code","3a065c44":"code","1dc94d05":"code","d549995b":"code","7fd92e62":"code","e7b06a53":"code","8a4beca3":"code","57df345d":"code","6c3e1717":"code","257ce67d":"code","ce46d3c5":"code","962cecaf":"code","79396d6c":"code","ffc95dc0":"code","0c99bf4e":"code","71930b05":"markdown","45e407a4":"markdown","9c32eddf":"markdown","a4f67835":"markdown","7cb35f09":"markdown","be43ee34":"markdown","72399a10":"markdown","65b19c01":"markdown","173d2373":"markdown","8e7b1883":"markdown","389046d7":"markdown","1d4e2cae":"markdown","f840471b":"markdown","b48dd81c":"markdown","e640dc78":"markdown","8fa0a627":"markdown"},"source":{"7fc68f80":"import numpy as np\nimport pandas as pd\n\n%matplotlib inline\nimport plotly.figure_factory as ff\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom catboost import CatBoostClassifier\nfrom xgboost import XGBClassifier\n\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.decomposition import PCA\nfrom sklearn.feature_selection import mutual_info_regression\nfrom sklearn.cluster import KMeans","85b1271a":"train = pd.read_csv(\"\/kaggle\/input\/tabular-playground-series-sep-2021\/train.csv\", index_col=0)\ntest = pd.read_csv(\"\/kaggle\/input\/tabular-playground-series-sep-2021\/test.csv\", index_col=0)\nsample_submission = pd.read_csv(\"..\/input\/tabular-playground-series-sep-2021\/sample_solution.csv\")","4ae580fe":"train.hist(figsize=(20,15), grid=False, ylabelsize=5, xlabelsize=5)\nplt.show()","9aef6956":"feature_cols = [col for col in test.columns.tolist()]\n\nscaler = StandardScaler()\n\ntrain[feature_cols] = scaler.fit_transform(train[feature_cols])\ntest[feature_cols] = scaler.transform(test[feature_cols])","783ebc1f":"def add_feature(df):\n    df['n_nans'] = df[feature_cols].isnull().sum(axis=1)\n    df['std']    = df[feature_cols].std(axis=1)\n    df['mean']   = df[feature_cols].mean(axis=1)\n    df['max']    = df[feature_cols].max(axis=1)\n    df['skew']   = df[feature_cols].skew(axis=1)\n    df['sum']    = df[feature_cols].sum(axis=1)\n    df['var']    = df[feature_cols].var(axis=1)\n    return df\n        \ntrain = add_feature(train).copy()\ntest = add_feature(test).copy()\n\nfeature_cols += ['n_nans', 'std', 'mean', 'max', 'skew', 'sum', 'var']","3fb1f1e9":"imp = SimpleImputer(strategy=\"median\")\ntrain[feature_cols] = imp.fit_transform(train[feature_cols])\ntest[feature_cols] = imp.transform(test[feature_cols])","1672523b":"corrs = train.corr()\ncorrs = corrs.sort_values(by=['claim'],ascending=False)","b221e074":"fig = plt.figure(figsize = (15,20))\nsns.barplot(y=corrs.index[1:], x=corrs['claim'].values[1:], orient=\"h\")\nplt.title(\"Correlation Between Feature Columns and Target Column (Claim)\")\nplt.xlabel(\"Correlation with Target\")\nplt.ylabel(\"Feature Columns\")\nplt.show()","24be51e9":"x = train.iloc[:5000,:][feature_cols].copy()\ny = train.iloc[:5000,:]['claim'].copy()\nmi_scores = mutual_info_regression(x, y)\nmi_scores = pd.Series(mi_scores, name=\"MI Scores\", index=x.columns)\nmi_scores = mi_scores.sort_values(ascending=False)","34b3c299":"top = 10\nfig = px.bar(mi_scores, x=mi_scores.values[:top], y=mi_scores.index[:top])\nfig.update_layout(\n    title=f\"Top {top} Strong Relationships Between Feature Columns and Claim Column\",\n    xaxis_title=\"Relationship with Claim\",\n    yaxis_title=\"Feature Columns\",\n    yaxis={'categoryorder':'total ascending'},\n    colorway=[\"blue\"]\n)\nfig.show()","2dd9c6bf":"n_clusters = 8\nkmeans = KMeans(n_clusters=n_clusters, random_state=42)\ntrain[\"cluster\"] = kmeans.fit_predict(train[feature_cols])\n\ntrain.head()","3a065c44":"test[\"cluster\"] = kmeans.predict(test[feature_cols])\n\nfeature_cols += [\"cluster\"]","1dc94d05":"fig = plt.figure(figsize = (10,5))\nsns.barplot(data=train, x='cluster', y='claim')\nplt.show()","d549995b":"ohe = OneHotEncoder()\nX_ohe = ohe.fit_transform(np.array(train[\"cluster\"]).reshape(-1,1)).toarray()\nT_ohe = ohe.transform(np.array(test[\"cluster\"]).reshape(-1,1)).toarray()\n\nohe_cols = [f\"cluster{i+1}\" for i in range(n_clusters)]\n\nX_ohe = pd.DataFrame(X_ohe, columns=ohe_cols, index=train.index)\nT_ohe = pd.DataFrame(T_ohe, columns=ohe_cols, index=test.index)\n\ntrain = pd.concat([train, X_ohe],axis=1)\ntest = pd.concat([test, T_ohe],axis=1)\n\ntrain.head()","7fd92e62":"feature_cols.pop(-1)\nfeature_cols += ohe_cols\n\ntrain.drop(\"cluster\", axis=1, inplace=True)\ntest.drop(\"cluster\", axis=1, inplace=True)","e7b06a53":"pca = PCA(n_components=2)\nX_pca = pca.fit_transform(train[feature_cols])\nT_pca = pca.transform(test[feature_cols])\n\npca_cols = [\"PC1\",\"PC2\"]\n\nX_pca = pd.DataFrame(X_pca, columns=pca_cols, index=train.index)\nT_pca = pd.DataFrame(T_pca, columns=pca_cols, index=test.index)\n\ntrain = pd.concat([train, X_pca], axis=1)\ntest = pd.concat([test, T_pca], axis=1)\ntrain.head()","8a4beca3":"fig = plt.figure(figsize = (15,10))\nsns.scatterplot(data=train, x=\"PC1\", y=\"PC2\", hue=\"claim\")\nplt.show()","57df345d":"feature_cols += pca_cols","6c3e1717":"# pca_features = [\"f43\", \"f80\", \"f27\", \"f20\"]\n\n# pca = PCA()\n# X_pca = pca.fit_transform(train[pca_features])\n# T_pca = pca.transform(test[pca_features])\n\n# pca_cols = [f\"PC{i+1}\" for i in range(X_pca.shape[1])]\n\n# X_pca = pd.DataFrame(X_pca, columns=pca_cols, index=train.index)\n# T_pca = pd.DataFrame(T_pca, columns=pca_cols, index=test.index)\n\n# train = pd.concat([train, X_pca], axis=1)\n# test = pd.concat([test, T_pca],axis=1)\n\n# feature_cols += pca_cols\n\n# train.head()","257ce67d":"x = train.iloc[:5000,:][feature_cols].copy()\ny = train.iloc[:5000,:]['claim'].copy()\nmi_scores = mutual_info_regression(x, y)\nmi_scores = pd.Series(mi_scores, name=\"MI Scores\", index=x.columns)\nmi_scores = mi_scores.sort_values(ascending=False)","ce46d3c5":"top = 10\nfig = px.bar(mi_scores, x=mi_scores.values[:top], y=mi_scores.index[:top])\nfig.update_layout(\n    title=f\"Top {top} Strong Relationships Between Feature Columns and Claim Column\",\n    xaxis_title=\"Relationship with Claim\",\n    yaxis_title=\"Feature Columns\",\n    yaxis={'categoryorder':'total ascending'},\n    colorway=[\"blue\"]\n)\nfig.show()","962cecaf":"train[\"kfold\"] = -1\nkf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n\nfor fold, (train_indicies, valid_indicies) in enumerate(kf.split(train,train[\"claim\"])):\n    train.loc[valid_indicies, \"kfold\"] = fold","79396d6c":"final_test_predictions = []\nscores = []\n\nfor fold in range(5):\n    x_train = train[train.kfold != fold].copy()\n    x_valid = train[train.kfold == fold].copy()\n    x_test  = test.copy()\n    \n    y_train = x_train['claim']\n    y_valid = x_valid['claim']\n    \n    x_train = x_train[feature_cols]\n    x_valid = x_valid[feature_cols]\n    \n    valid_ids = x_valid.index\n    xgb_params = {\n          'max_depth': 2, \n          'learning_rate': 0.021537077920105466, \n          'n_estimators': 10606, \n          'min_child_weight': 150, \n          'gamma': 0.11611920725914951, \n          'alpha': 0.0021839958087869794, \n          'lambda': 0.0018567979557499344, \n          'colsample_bytree': 0.7139742731494992, \n          'subsample': 0.6258627743440968,\n          'tree_method': 'gpu_hist',\n          'booster': 'gbtree',\n          'seed': 42,\n          'use_label_encoder': False,\n          'eval_metric': 'auc'\n    }\n    \n    xgb_model = XGBClassifier(**xgb_params)\n    xgb_model.fit(x_train, y_train, eval_set=[(x_valid, y_valid)], verbose=False)\n    \n    preds_valid = xgb_model.predict_proba(x_valid)[:,1]\n    auc = roc_auc_score(y_valid, preds_valid)\n    print(\"Fold\",fold, \", AUC:\", auc)\n    scores.append(auc)\n    \n    preds_test = xgb_model.predict_proba(test)[:,1]\n    final_test_predictions.append(preds_test)\n    \n    \nprint(\"AVG AUC:\",np.mean(scores))","ffc95dc0":"labels = [f'fold {i}' for i in range(5)]\n\nfig = ff.create_distplot(final_test_predictions, labels, bin_size=.3, show_hist=False, show_rug=False)\nfig.show()","0c99bf4e":"sample_submission['claim'] = np.mean(np.column_stack(final_test_predictions), axis=1)\nsample_submission.to_csv(\"submission.csv\", index=False)","71930b05":"## Scale Data","45e407a4":"## Add Some Features","9c32eddf":"# KFold Data","a4f67835":"# K-Means Clustering\n\nLet's add clusters generated by K-Means (unsupervised algorithm) to see the effect.","7cb35f09":"# Correlation\nCorrelation can only detect **linear relationship** between columns","be43ee34":"# Submission","72399a10":"## One-Hot Encode Cluster Column","65b19c01":"# Data Preprocessing","173d2373":"## Load Data","8e7b1883":"## Plot Data","389046d7":"## MI Score for New Features?","1d4e2cae":"## Simple Imputation","f840471b":"# XGBoost","b48dd81c":"# Plot Test Predictions","e640dc78":"# PCA","8fa0a627":"# Mutual Information\nUnlike the Correlation, **Mutual information** is not limited to linear relationship. It can detect any types of relationship between columns.\n\nI had to get a subset of samples (5000 samples) in order to avoid getting OOM error."}}