{"cell_type":{"65135b1e":"code","3d9eb960":"code","3bf0f67e":"code","01f705bd":"code","b6482a38":"code","621e74b3":"code","5a101a32":"code","af512025":"code","0891f06b":"code","23ffb89e":"code","6ae0c8a7":"code","679efc90":"code","c7ca22da":"code","d6bbb4f4":"code","e9952882":"code","df077dee":"code","a8882232":"code","ea8c80e0":"code","f24c5701":"code","1620d603":"markdown","746f8c35":"markdown","9932d8df":"markdown","01456fa6":"markdown","791dc805":"markdown","5a842461":"markdown","2b0be382":"markdown","c44eb547":"markdown","edcf03ca":"markdown","cd8cc503":"markdown","f28ea72e":"markdown"},"source":{"65135b1e":"import gc\nimport warnings","3d9eb960":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.offline import plot, iplot, init_notebook_mode\ninit_notebook_mode(connected=True)\nimport tensorflow as tf\nimport statsmodels.api as sm\nfrom pylab import rcParams\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nimport time\nimport datetime","3bf0f67e":"def collect_gc():\n    i = 0\n    while i <= 6:\n        print('collecting garbage...')\n        print(gc.collect())\n        i = i + 1\n        \nwarnings.filterwarnings('ignore')","01f705bd":"folder = '..\/input\/g-research-crypto-forecasting\/'\n\n# Train data\nbase_train = pd.read_csv(folder+'train.csv', low_memory=False)\n\n# Assets\nasset_mapping = pd.read_csv(folder+'asset_details.csv', index_col=0)\nasset_mapping = asset_mapping.reindex([i for i in range(14)])\nasset_mapping","b6482a38":"# converting the timestamp to minutes\nbase_train['time'] = pd.to_datetime(base_train['timestamp'], unit='s')\nbase_train.head(50)\n\nbase_train.isnull().sum()","621e74b3":"bin_coin, btc, btc_cash, card, doge, eos_io, eth, eth_class, iota, ltc, maker, mon, stela, tron = [\n    base_train.loc[base_train.Asset_ID == i] for i in range(14)]\n\nassets = [bin_coin, btc, btc_cash, card, doge, eos_io, eth, eth_class, iota, ltc, maker, mon, stela, tron]","5a101a32":"print(\"--> Checking for physical Tensorflow devices\")\nfor device in tf.config.list_physical_devices():\n    print(\": {}\".format(device.name))\n\nbtc.set_index(btc.time, drop=True, inplace=True)","af512025":"print(btc.info())\nbtc_plt = btc.iloc[-8000:]\n\nwith tf.device('\/GPU:0'):\n    fig = go.Figure(data=go.Ohlc(x=btc_plt.time,\n                open=btc_plt.Open,\n                high=btc_plt.High,\n                low=btc_plt.Low,\n                close=btc_plt.Close))\n    fig.show()","0891f06b":"# Handling missing Values\neth = base_train.loc[base_train['Asset_ID'] == 6]\neth.set_index(eth.time, drop=True, inplace=True)\n\nbtc.isnull().sum()\n\nbtc.fillna(method='ffill', inplace=True)\neth.fillna(method='ffill', inplace=True)\neth.isnull().sum()","23ffb89e":"def decompose(price):\n    rcParams['figure.figsize'] = 15, 7\n    decomp_series = sm.tsa.seasonal_decompose(price, model='addictive')\n    decomp_series.plot()\n    plt.show()\n\nfor count, asset in enumerate(assets):\n    asset2 = asset.set_index(asset.time)\n    print(f' \\033[92m \\033[1m{asset_mapping.Asset_Name[count]}\\033[1m \\033[92m ')\n    decompose(asset2.Close.resample('M').mean())\n    print('\\n');print('\\n')","6ae0c8a7":"def stationarity_test(col):\n    \n    print('--------------Stationarity Test--------------')\n    adf_result = adfuller(col)\n    print('ADF Statistic:', adf_result[0])\n    print('p-value:', adf_result[1])\n    print('No. of lags used:', adf_result[2])\n    print('No. of observations used :', adf_result[3])\n    if adf_result[1] < 0.05:\n        print('TSD is Stationary')\n    else:\n        print('TSD is not Stationary')\n    print( 'Critical Values:' )\n    for k, v in adf_result[4].items():\n        print( f' {k} : {v} ' )\n    print('\\n')\n\nto_datetime = lambda s: pd.to_datetime(s, unit='s')\nfor a in assets:\n    a.index = to_datetime(a.index)\n    \nfor count, asset in enumerate(assets):\n    print(asset_mapping.Asset_Name[count])\n    stationarity_test(asset.Close.resample('D').mean())","679efc90":"collect_gc()","c7ca22da":"def get_cmap(n, name='hsv'):\n    return plt.cm.get_cmap(name, n)\ncmap = get_cmap(len(assets))\n\ndef diff(tsd, periods=1):\n    return np.log(tsd).diff(periods=periods)\n\nfig, ax = plt.subplots(len(assets), 1, figsize=(17, 25))\nfor count, asset in enumerate(assets):\n    ax[count].plot(asset.time[1:], diff(asset.Close)[1:], c=cmap(count))\n    ax[count].set_title(asset_mapping.Asset_Name[count])\n\nplt.suptitle('Price Change \\n')\nplt.tight_layout()\nplt.show()","d6bbb4f4":"for count, asset in enumerate(assets):\n    print(asset_mapping.Asset_Name[count])\n    stationarity_test(diff(asset.Close).resample('D').mean())","e9952882":"fig, axes = plt.subplots(len(assets), 2, figsize=(15, 35))\n\nfor count, asset in enumerate(assets):\n    fig = plot_acf(diff(asset.Close)[1:].resample('D').mean(), lags=20, ax=axes[count, 0])\n    fig = plot_pacf(diff(asset.Close)[1:].resample('D').mean(), lags=20, ax=axes[count, 1])\n    axes[count, 0].set_title(f'{asset_mapping.Asset_Name[count]} ACF')\n    axes[count, 1].set_title(f'{asset_mapping.Asset_Name[count]} PACF')\n\nplt.tight_layout()\nplt.show()","df077dee":"fig, axes = plt.subplots(len(assets), 1, figsize=(20, 40))\n\nfor count, asset in enumerate(assets):\n    axes[count].plot(asset.time, asset.Close, color=cmap(count))\n    axes[count].set_title(asset_mapping.Asset_Name[count])\n\nplt.tight_layout()\nplt.show()","a8882232":"# 1 Month Plot\nbtc_sep = btc.loc['2021-09-01 00:01:00':'2021-09-30 00:01:00']\neth_sep = eth.loc['2021-09-01 00:01:00':'2021-09-30 00:01:00']\n\nfig = plt.figure(figsize=(20, 8))\nfig.add_subplot(121)\nplt.title('Ethereum (September)')\nplt.xlabel('Time')\nplt.ylabel('Price')\nplt.plot(eth_sep.time, eth_sep.Close)\n\nfig.add_subplot(122)\nplt.title('Bitcoin (September)')\nplt.plot(btc_sep.time, btc_sep.Close, color='r')\nplt.xlabel('Time')\nplt.ylabel('Price')\nplt.tight_layout()\nplt.show()","ea8c80e0":"collect_gc()","f24c5701":"btc_change = diff(btc.Close)[1:].rename('Bitcoin')\neth_change = diff(eth.Close)[1:].rename('Etheruem')\nasset_corr = pd.concat([btc_change, eth_change], axis=1)\n\nto_timestamp = lambda a: [time.mktime(t.timetuple()) for t in a]\nasset_corr.index = to_timestamp(asset_corr.index)\ncorr = asset_corr.groupby(asset_corr.index\/\/(10000*60)).corr().loc[:,\"Bitcoin\"].loc[:,\"Etheruem\"]\nrcParams['figure.figsize'] = 15, 8\ncorr.plot()\nplt.title('Bitcoin and Ethereum Correlation since 2018')\nplt.show()","1620d603":"### Price Change","746f8c35":"## Loading the Data","9932d8df":"## Preprocessing Data","01456fa6":"### Checking for correlation between assets","791dc805":"### Seasonality and Trend","5a842461":"#### September 2021","2b0be382":"#### 2018-2021","c44eb547":"### Autocorrelation and Partial Autocorrelation","edcf03ca":"## Analysis and Visualization","cd8cc503":"### Stationarity Test","f28ea72e":"## Dependencies"}}