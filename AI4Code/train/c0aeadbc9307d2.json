{"cell_type":{"7aabe2c5":"code","2924b254":"code","81e413c0":"code","84cf56a4":"code","94271d2e":"code","36a839b7":"code","f048ea60":"code","3bd0fcc9":"code","8ad92933":"code","5d73ca92":"code","c17667cd":"code","e2c3a077":"code","64097f47":"code","6ad28d3a":"markdown","fae6561d":"markdown","856c0761":"markdown","6542fe5c":"markdown","a229088c":"markdown"},"source":{"7aabe2c5":"!pip install lmfit","2924b254":"\n# libraries to manage number\nimport numpy as np\nimport pandas as pd\n# libraries to plotting\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# libraries to model\n\n# Libraries to metrics\nfrom sklearn import metrics\n\n\n# libraries to optimize model\nfrom lmfit import Model","81e413c0":"def sigmoid(x, b, r, t):\n    z = (t * (b + x))\n    sig = 1\/(1 + np.exp( -z ))*r\n    return sig\n#http:\/\/www.edscave.com\/forecasting---time-series-metrics.html\ndef mean_absolute_percentage_error(y_true, y_pred): \n    #y_true, y_pred = y_true, y_pred)\n\n    ## Note: does not handle mix 1d representation\n    #if _is_1d(y_true): \n    #    y_true, y_pred = _check_1d_array(y_true, y_pred)\n\n    return np.mean(np.abs((y_true - y_pred) \/ y_true)) * 100","84cf56a4":"#df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_deaths_global.csv')\ndf = pd.read_csv('..\/input\/Global_Covid-19-05-04-2020.csv',index_col=0)","94271d2e":"df = df.groupby(by='Country\/Region',).sum()\ndf.reset_index(inplace=True)\ndays = len(df.columns[3:])\ndays = np.arange(days)\ndf.columns[days.max()+3]\ndf.sort_values(df.columns[days.max()+3],ascending=False)['Country\/Region']\ncountry_list = df.sort_values(df.columns[days.max()+3],ascending=False)['Country\/Region']","36a839b7":"fig, ax = plt.subplots(nrows=16, ncols=2, figsize=(16,80))\nn = 0\nc1 = ['Italy', 'Spain', 'US', 'Germany', 'Belgium', 'Switzerland', 'Iran',\n      'Turkey', 'Brazil', 'Sweden', 'Portugal', 'Indonesia', 'Austria',\n      'Korea, South', 'Ecuador', 'Romania']\ndf_coeff = pd.DataFrame()\nfor reg in c1:\n    y = df.loc[df['Country\/Region']== reg,'1\/22\/20':]\n    ax[n][0].set_title('Current situation {}'.format(reg))\n    sns.scatterplot(x=days, y=y.iloc[0,:],ax=ax[n][0])    \n           \n    model = Model(sigmoid)\n    pred = model.fit(y.iloc[0,:], x=days, b= 500, r=y.iloc[0,:].max()\/4, t= 0.0001)  # b= 0, r=, t= 0.001\n\n    x_ideal = np.linspace(np.min(days), np.max(days)*2)\n    ideal = pred.eval(x=x_ideal)\n    sns.scatterplot(x_ideal, ideal, label='forecasting model', ax=ax[n][1])\n    \n\n    sns.scatterplot(x=days, y=y.iloc[0,:], label='deaths in {} until now'.format(reg), s=100, color='red', ax=ax[n][1])\n\n    ax[n][1].grid()\n    ax[n][1].set_title('{} model'.format(reg))\n    ax[n][1].set_xlim(0)\n    \n    df_coeff = df_coeff.append(pred.values, ignore_index=True)\n    #df_coeff.loc[n, 'MAPE'] = mean_absolute_percentage_error(ideal[:len(y)],y)\n    df_coeff.loc[n,'Regions'] = reg\n    n+=1","f048ea60":"fig, ax = plt.subplots(nrows=16, ncols=2, figsize=(16,80))\nn = 0\nc1 = ['Philippines', 'Ireland', 'India','Japan', 'Peru', 'Egypt', 'Greece', 'Dominican Republic', 'Norway', 'Czechia', 'Morocco', 'Malaysia', 'Iraq',\n       'Israel', 'Serbia', 'Germany']\nfor reg in c1:\n    y = df.loc[df['Country\/Region']== reg,'1\/22\/20':]\n    ax[n][0].set_title('Current situation {}'.format(reg))\n    sns.scatterplot(x=days, y=y.iloc[0,:],ax=ax[n][0])    \n           \n    model = Model(sigmoid)\n    pred = model.fit(y.iloc[0,:], x=days, b= 500, r=y.iloc[0,:].max()\/4, t= 0.0001)  # b= 0, r=, t= 0.001\n\n    x_ideal = np.linspace(np.min(days), np.max(days)*2)\n    ideal = pred.eval(x=x_ideal)\n    sns.scatterplot(x_ideal, ideal, label='forecasting model', ax=ax[n][1])\n    \n\n    sns.scatterplot(x=days, y=y.iloc[0,:], label='deaths in {} until now'.format(reg), s=100, color='red', ax=ax[n][1])\n\n    ax[n][1].grid()\n    ax[n][1].set_title('{} model'.format(reg))\n    ax[n][1].set_xlim(0)\n    \n    df_coeff = df_coeff.append(pred.values, ignore_index=True)\n    #df_coeff.loc[n, 'MAPE'] = mean_absolute_percentage_error(ideal[:len(y)],y)\n    df_coeff.loc[16+n,'Regions'] = reg\n    n+=1","3bd0fcc9":"fig, ax = plt.subplots(nrows=3, ncols=2, figsize=(16,20))\nn = 0\nc1 = ['Mexico','Netherlands', 'Denmark']\nfor reg in c1:\n    y = df.loc[df['Country\/Region']== reg,'1\/22\/20':]\n    ax[n][0].set_title('Current situation {}'.format(reg))\n    sns.scatterplot(x=days, y=y.iloc[0,:],ax=ax[n][0])    \n           \n    model = Model(sigmoid)\n    pred = model.fit(y.iloc[0,:], x=days, b=0, r=y.iloc[0,:].max()\/4, t= -0.05)  # b= 0, r=, t= 0.001 r=y.iloc[0,:].max()\/4\n\n    x_ideal = np.linspace(np.min(days), np.max(days)*2)\n    ideal = pred.eval(x=x_ideal)\n    sns.scatterplot(x_ideal, ideal, label='forecasting model', ax=ax[n][1])\n    \n\n    sns.scatterplot(x=days, y=y.iloc[0,:], label='deaths in {} until now'.format(reg), s=100, color='red', ax=ax[n][1])\n\n    ax[n][1].grid()\n    ax[n][1].set_title('{} model'.format(reg))\n    ax[n][1].set_xlim(0)\n    \n    df_coeff = df_coeff.append(pred.values, ignore_index=True)\n    #df_coeff.loc[n, 'MAPE'] = mean_absolute_percentage_error(ideal[:len(y)],y)\n    df_coeff.loc[32+n,'Regions'] = reg\n    n+=1\n","8ad92933":"fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(20,10))\nn = 0\nc1 = ['United Kingdom','France']\nfor reg in c1:\n    y = df.loc[df['Country\/Region']== reg,'1\/22\/20':]\n    ax[n][0].set_title('Current situation {}'.format(reg))\n    sns.scatterplot(x=days, y=y.iloc[0,:],ax=ax[n][0])    \n           \n    model = Model(sigmoid)\n    pred = model.fit(y.iloc[0,:], x=days, b=-1, r=y.iloc[0,:].max()\/2, t= -0.005,)  # b= 0, r=, t= 0.001 r=y.iloc[0,:].max()\/4\n\n    x_ideal = np.linspace(np.min(days), np.max(days)*2)\n    ideal = pred.eval(x=x_ideal)\n    sns.scatterplot(x_ideal, ideal, label='forecasting model', ax=ax[n][1])\n    \n\n    sns.scatterplot(x=days, y=y.iloc[0,:], label='deaths in {} until now'.format(reg), s=100, color='red', ax=ax[n][1])\n\n    ax[n][1].grid()\n    ax[n][1].set_title('{} model'.format(reg))\n    ax[n][1].set_xlim(0)\n\n    df_coeff = df_coeff.append(pred.values, ignore_index=True)\n    df_coeff.loc[35+n,'Regions'] = reg\n    n+=1","5d73ca92":"df_coeff","c17667cd":"df_coeff.columns=['beta', 'cap', 'theta', 'Regions']\ndf_coeff['cap'] = df_coeff['cap'].apply(lambda x: int(x))\ndf_coeff[['cap','Regions']].rename(columns={'cap':'Assumed number of deaths','Regions':'Regions'})","e2c3a077":"from scipy.spatial import ConvexHull\ndef encircle(x,y, ax=None, **kw):\n    if not ax: ax=plt.gca()\n    p = np.c_[x,y]\n    hull = ConvexHull(p)\n    poly = plt.Polygon(p[hull.vertices,:], **kw)\n    ax.add_patch(poly)","64097f47":"plt.figure(figsize=(10,10))\nsns.scatterplot(data=df_coeff, x='beta', y='theta', s=100,)\nn = list(np.concatenate( (df_coeff.sort_values('theta', ascending=False).head(3).index.values,df_coeff[df_coeff.beta<-77].index.values,df_coeff[df_coeff.beta>-65].index.values), axis=0))\n\nfor i in n:\n    plt.annotate(df_coeff.Regions[i], (df_coeff.beta[i], df_coeff.theta[i]*1.01),size=20)\n\nN = list(df_coeff.index.values)\nN = [x for x in N if x not in n]\n\nencircle(df_coeff[df_coeff.index.isin(N)].beta, df_coeff[df_coeff.index.isin(N)].theta, ec=\"orange\", fc=\"none\")","6ad28d3a":"# Coefficent sigmoid functions","fae6561d":"I use the sigmoid function which often works well in epidemiological situations.\nThe function is as follow: \n\n$$\n    z = \\theta_0 + \\theta_1*x\\\\\n    g(z) = \\frac {1}{(1 + e^{-z})} \n$$\n\nSigmoid funtion works between 0 and 1, if I do not change the formula, it simply tells us that the end of the event has been reached, through the number 1. For this reason we must multiply the result of the sigmoid function by the maximum number reached by the series\n","856c0761":"I block the update of data to April 5, 2020 to check, in two weeks, if the forecasts are correct. The following graphs represent the situation and possible evolution of the main countries with the highest number of deaths until now.","6542fe5c":"Here a scatterplot that show countries with values a little bit different from others, The values obtained could be either overestimated or underestimated and should be checked more carefully.","a229088c":"# Death Forecasting\nAbove a small table with death forecasting, some country haven't a lot of days to analyse data and the result can be unreliable."}}