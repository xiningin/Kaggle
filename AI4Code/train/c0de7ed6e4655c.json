{"cell_type":{"0de23b26":"code","02783a45":"code","5a16f5ec":"code","7e442051":"code","9cbe9af1":"code","eb13b354":"code","2be7ac4a":"code","02f711f3":"code","94b1293d":"code","d085e762":"code","a5fe2c71":"code","b62aa21a":"code","ae8904af":"code","82949f9b":"code","486047e7":"code","2b5dbe86":"code","de2b644c":"code","5637ee71":"code","b8d6096e":"code","cefd449a":"code","6e902a63":"code","cf1f2183":"code","2f5b1cbc":"markdown","d9a002bb":"markdown","409fa19c":"markdown","511e995e":"markdown","c750c19b":"markdown","914c8f8e":"markdown"},"source":{"0de23b26":"import os\nfrom os.path import isdir, join\nfrom pathlib import Path\nimport pandas as pd\n\n# Math\nimport numpy as np\nfrom scipy.fftpack import fft\nfrom scipy import signal\nfrom scipy.io import wavfile\nimport librosa\n\nfrom sklearn.decomposition import PCA\n\n# Visualization\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport IPython.display as ipd\nimport librosa.display\n\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls\nimport pandas as pd\n\nplt.style.use('dark_background')\n\n%matplotlib inline\n\n\nimport librosa\nimport librosa.filters\nimport scipy\nimport scipy.fftpack as fft\nfrom scipy import signal\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n!pip install spectrum\nimport spectrum","02783a45":"filepaths = []\nfor file1 in os.listdir('..\/input\/speech-activity-detection-datasets\/Data\/Audio\/Noizeus'):\n    filename = '..\/input\/speech-activity-detection-datasets\/Data\/Audio\/Noizeus'+'\/'+file1\n    for file2 in os.listdir(filename):\n        filepaths.append(filename+'\/'+file2)\n        \nfilepaths","5a16f5ec":"from tqdm import tqdm_notebook as tqdm","7e442051":"wav_flpath = []\nsample_rate_flpath = []\nfor name in tqdm(filepaths):\n    sample_rate_flpath.append((np.array(wavfile.read(name)[0])).astype(np.float))\n    wav_flpath.append((np.array(wavfile.read(name)[1])).astype(np.float))\n\nwav_flpath\n\n# sample_rate, samples = wavfile.read('..\/input\/speech-activity-detection-datasets\/Data\/Audio\/Noizeus\/Babble\/sp01_babble_sn5.wav')\n# np.asarray(wavfile.read('..\/input\/speech-activity-detection-datasets\/Data\/Audio\/Noizeus\/Babble\/sp01_babble_sn5.wav')[1]).astype(np.float)","9cbe9af1":"# From this tutorial\n# https:\/\/github.com\/librosa\/librosa\/blob\/master\/examples\/LibROSA%20demo.ipynb\n\nmfcc_arr = []\nfor path,sample_rate in zip(wav_flpath[:30],sample_rate_flpath[:30]):    \n    S = librosa.feature.melspectrogram(path, sr=sample_rate, n_mels=128)\n    # Convert to log scale (dB). We'll use the peak power (max) as reference.\n    log_S = librosa.power_to_db(S, ref=np.max)\n    mfcc = librosa.feature.mfcc(S=log_S, n_mfcc=13)\n    mfcc_arr.append(np.array(mfcc).ravel())\n\n# plt.figure(figsize=(12, 4))\n# librosa.display.specshow(log_S, sr=sample_rate, x_axis='time', y_axis='mel')\n# plt.title('Mel power spectrogram ')\n# plt.colorbar(format='%+02.0f dB')\n# plt.tight_layout()","eb13b354":"mfcc_df = pd.DataFrame(mfcc_arr)\nmfcc_df = mfcc_df.fillna(0)\nmfcc_df","2be7ac4a":"def rastaplp(x, fs = 16000, win_time = 0.040, hop_time = 0.020, dorasta = True, modelorder = 8):\n    \n    \n    # first compute power spectrum\n    p_spectrum, _ = powspec(x, fs, win_time, hop_time)\n    # next group to critical bands\n    aspectrum = audspec(p_spectrum, fs)\n    nbands = aspectrum.shape[0]\n    \n    if dorasta:\n        # put in log domain\n        nl_aspectrum = np.log(aspectrum)\n        # next do rasta filtering\n        ras_nl_aspectrum = rastafilt(nl_aspectrum)\n        # do inverse log\n        aspectrum = np.exp(ras_nl_aspectrum)\n    \n    postspectrum, _ = postaud(aspectrum, fs \/ 2)\n    \n    lpcas = dolpc(postspectrum, modelorder);\n    cepstra = lpc2cep(lpcas, modelorder + 1);\n    \n    if modelorder > 0:\n        lpcas = dolpc(postspectrum, modelorder);\n        cepstra = lpc2cep(lpcas, modelorder + 1);\n        spectra,F,M = lpc2spec(lpcas, nbands);\n    else:\n        spectra = postspectrum\n        cepstra = spec2cep(spectra)\n    \n    cepstra = lifter(cepstra, 0.6)\n    \n    return cepstra\n\ndef powspec(x, fs = 16000, window_time = 0.040, hop_time = 0.020, dither = 1):\n    win_length = int(np.round(window_time * fs))\n    hop_length = int(np.round(hop_time * fs))\n    fft_length = int(np.power(2, np.ceil(np.log2(window_time * fs))))\n    \n    X = librosa.stft(np.multiply(32768, x), n_fft = fft_length, hop_length = hop_length, \n                     win_length = win_length, window='hann', center = False)\n    pow_X = np.power(np.abs(X), 2)\n    if dither:\n        pow_X = np.add(pow_X, win_length)\n    e = np.log(np.sum(pow_X, axis = 0))\n    return pow_X, e\n\ndef hz2bark(f):\n    z = np.multiply(6, np.arcsinh(np.divide(f, 600)))\n    return z\n\ndef bark2hz(z):\n    hz = np.multiply(600, np.sinh(np.divide(z, 6)))\n    return hz\n\ndef fft2barkmx(fft_length, fs, nfilts = 0, band_width = 1, min_freq = 0, max_freq = 0):\n    if max_freq == 0:\n        max_freq = fs \/ 2\n        \n    min_bark = hz2bark(min_freq)\n    nyqbark = hz2bark(max_freq) - min_bark\n    \n    if nfilts == 0 :\n        nfilts = np.add(np.ceil(nyqbark), 1)\n    \n    wts = np.zeros((int(nfilts), int(fft_length)))\n    step_barks = np.divide(nyqbark, np.subtract(nfilts, 1))\n    binbarks = hz2bark(np.multiply(np.arange(0, np.add(np.divide(fft_length, 2),1)), np.divide(fs, fft_length)))\n    \n    for i in range (int(nfilts)):\n        f_bark_mid = min_bark + np.multiply(i, step_barks)\n        lof = np.subtract(np.subtract(binbarks, f_bark_mid), 0.5)\n        hif = np.add(np.subtract(binbarks, f_bark_mid), 0.5)\n        wts[i, 0 : int(fft_length \/ 2) + 1] = np.power(10, np.minimum(0, np.divide(np.minimum(hif, np.multiply(-2.5, lof)), band_width)))\n    return wts\n\ndef rastafilt(x):\n    numer = np.arange(-2, 3)\n    numer = np.divide(-numer, np.sum(np.multiply(numer, numer)))\n    denom = np.array([1, -0.94])\n    \n    zi = signal.lfilter_zi(numer,1)\n    y = np.zeros((x.shape))\n    for i in range(x.shape[0]):\n        y1, zi = signal.lfilter(numer, 1, x[i, 0:4], axis = 0, zi = zi * x[i, 0])\n        y1 = y1*0\n        y2, _ = signal.lfilter(numer, denom, x[i, 4:x.shape[1]], axis = 0, zi = zi)\n        y[i, :] = np.append(y1, y2)    \n    return y\n\n\ndef dolpc(x, modelorder = 8):\n    nbands, nframes = x.shape\n    ncorr = 2 * (nbands - 1)\n    R = np.zeros((ncorr, nframes))\n    \n    R[0:nbands, :] = x\n    for i in range(nbands - 1):\n        R[i + nbands - 1, :] = x[nbands - (i + 1), :]\n    \n    r = fft.ifft(R.T).real.T\n    r = r[0:nbands, :]\n    \n    y = np.ones((nframes, modelorder + 1))\n    e = np.zeros((nframes, 1))\n    \n    if modelorder == 0:\n        for i in range(nframes):\n            _ , e_tmp, _ = spectrum.LEVINSON(r[:, i], modelorder, allow_singularity = True)\n            e[i, 0] = e_tmp\n    else:\n        for i in range(nframes):\n            y_tmp, e_tmp, _ = spectrum.LEVINSON(r[:, i], modelorder, allow_singularity = True)\n            y[i, 1:modelorder + 1] = y_tmp\n            e[i, 0] = e_tmp\n    \n    y = np.divide(y.T, np.add(np.tile(e.T, (modelorder + 1, 1)), 1e-8))\n    \n    return y\n\ndef lpc2cep(a, nout = 0):\n    nin, ncol = a.shape\n    \n    order = nin - 1\n    \n    if nout == 0:\n        nout = order + 1\n        \n    cep = np.zeros((nout, ncol))\n    cep[0, :] = -np.log(a[0, :])\n    \n    norm_a = np.divide(a, np.add(np.tile(a[0, :], (nin, 1)), 1e-8))\n    \n    for n in range(1, nout):\n        sum = 0\n        for m in range(1, n):\n            sum = np.add(sum, np.multiply(np.multiply((n - m), norm_a[m, :]), cep[(n - m), :]))\n        \n        cep[n, :] = -np.add(norm_a[n, :], np.divide(sum, n))\n    \n    return cep\n\ndef lifter(x, lift = 0.6, invs = False):\n    ncep = x.shape[0]\n    \n    if lift == 0:\n        y = x\n    else:\n        if lift < 0:\n            warnings.warn('HTK liftering does not support yet; default liftering')\n            lift = 0.6\n        liftwts = np.power(np.arange(1, ncep), lift)\n        liftwts = np.append(1, liftwts)\n        \n        if (invs):\n            liftwts = np.divide(1, liftwts)\n        \n        y = np.matmul(np.diag(liftwts), x)\n    \n    return y\n\ndef melfcc(x, fs = 16000, min_freq = 50, max_freq = 6500, n_mfcc = 13, n_bands = 40, lifterexp = 0.6,\n          fbtype = 'fcmel', dcttype = 1, usecmp = True, window_time = 0.040, hop_time = 0.020,\n          preemph = 0.97, dither = 1, sumpower = 1, band_width = 1, modelorder = 0,\n           broaden = 0, useenergy = False):\n    \n    if preemph != 0:\n        b = [1, -preemph]\n        a = 1\n        x = signal.lfilter(b, a, x)\n        \n    pspectrum, logE = powspec(x, fs = fs, window_time = window_time, hop_time = hop_time, dither = dither)\n    aspectrum = audspec(pspectrum, fs = fs, nfilts = n_bands, fbtype = fbtype, \n                        min_freq = min_freq, max_freq = max_freq)\n    \n    if usecmp:\n        aspectrum, _ = postaud(aspectrum, fmax = max_freq, fbtype = fbtype)\n    \n    if modelorder > 0:\n        lpcas = dolpc(aspectrum, modelorder)\n        cepstra = lpc2cep(lpcas, nout = n_mfcc)\n\n    else:\n        cepstra, _ = spec2cep(aspectrum, ncep = n_mfcc, dcttype = dcttype)\n        \n    cepstra = lifter(cepstra, lift = lifterexp);\n    \n    if useenergy == True:\n        cepstra[0, :] = logE\n    \n    return cepstra\n\n\ndef hz2mel(f, htk = False):\n    if htk:\n        z = np.multiply(2595, np.log10(np.add(1, np.divide(f, 700))))\n    else:\n        f_0 = 0.0\n        f_sp = 200 \/ 3\n        brkfrq = 1000\n        brkpt = (brkfrq - f_0) \/ f_sp\n        logstep = np.exp(np.log(6.4) \/ 27.0)\n        \n        f = np.array(f, ndmin = 1)\n        z = np.zeros((f.shape[0], ))\n        \n        for i in range(f.shape[0]):\n            if f[i] < brkpt:\n                z[i] = (f[i] - f_0) \/ f_sp\n            else:\n                z[i] = brkpt + (np.log(f[i] \/ brkfrq) \/ np.log(logstep))\n    return z\n\ndef mel2hz(z, htk = False):\n    if htk:\n        f = np.multiply(700, np.subtract(np.power(10, np.divide(z, 2595)), 1))\n    else:\n        f_0 = 0\n        f_sp = 200\/3\n        brkfrq = 1000\n        brkpt = (brkfrq - f_0) \/ f_sp\n        logstep = np.exp(np.log(6.4) \/ 27.0)\n        \n        z = np.array(z, ndmin = 1)\n        f = np.zeros((z.shape[0], ))\n        \n        for i in range(z.shape[0]):\n            if z[i] < brkpt:\n                f[i] = f_0 + f_sp * z[i]\n            else:\n                f[i] = brkfrq * np.exp(np.log(logstep) * (z[i] - brkpt))\n    return f\n\ndef fft2melmx(fft_length, fs, nfilts = 0, band_width = 1, min_freq = 0, max_freq = 0, \n              htk = False, constamp = False):\n    if nfilts == 0 :\n        nfilts = np.ceil(hz2mel(max_freq, htk) \/ 2)\n    if max_freq == 0:\n        max_freq = fs \/ 2\n        \n    wts = np.zeros((int(nfilts), int(fft_length)))\n    fftfrqs = np.multiply(np.divide(np.arange(0,fft_length \/ 2 + 1), fft_length), fs)\n    \n    min_mel = hz2mel(min_freq, htk)\n    max_mel = hz2mel(max_freq, htk)\n    binfrqs = mel2hz(np.add(min_mel, np.multiply(np.arange(0, nfilts + 2),\n                                                 (max_mel - min_mel) \/ (nfilts + 1))), htk)\n\n    for i in range (int(nfilts)):\n        fs_tmp = binfrqs[np.add(np.arange(0,3), i)]\n        fs_tmp = np.add(fs_tmp[1], np.multiply(band_width, np.subtract(fs_tmp, fs_tmp[1])))\n        loslope = np.divide(np.subtract(fftfrqs, fs_tmp[0]), np.subtract(fs_tmp[1], fs_tmp[0]))\n        hislope = np.divide(np.subtract(fs_tmp[2], fftfrqs), np.subtract(fs_tmp[2], fs_tmp[1]))\n        wts[i, 0 : int(fft_length \/ 2) + 1] = np.maximum(0, np.minimum(loslope, hislope))\n    \n    if constamp == False:\n        wts = np.matmul(np.diag(np.divide(2, np.subtract(binfrqs[2 : int(nfilts) + 2],\n                                                         binfrqs[0 : int(nfilts)]))), wts)\n    \n    return wts\n\ndef audspec(p_spectrum, fs = 16000, nfilts = 0, fbtype = 'bark', \n            min_freq = 0, max_freq = 0, sumpower = 1, band_width = 1):\n    if nfilts == 0:\n        np.add(np.ceil(hz2bark(fs \/ 2)), 1)\n    if max_freq == 0:\n        max_freq = fs \/ 2\n    nfreqs = p_spectrum.shape[0]\n    nfft = (int(nfreqs) - 1) * 2\n    \n    if fbtype == 'bark':\n        wts = fft2barkmx(nfft, fs, nfilts, band_width, min_freq, max_freq)\n    elif fbtype == 'mel':\n        wts = fft2melmx(nfft, fs, nfilts, band_width, min_freq, max_freq)\n    elif fbtype == 'htkmel':\n        wts = fft2melmx(nfft, fs, nfilts, band_width, min_freq, max_freq, htk = True, constamp = True)\n    elif fbtype == 'fcmel':\n        wts = fft2melmx(nfft, fs, nfilts, band_width, min_freq, max_freq, htk = True, constamp = False)\n        \n    wts = wts[:, 0 : nfreqs]\n    \n    if sumpower:\n        aspectrum = np.matmul(wts, p_spectrum)\n    else:\n        aspectrum = np.power(np.matmul(wts, np.sqrt(p_spectrum)), 2)\n    return aspectrum\n\ndef postaud(x, fmax, fbtype = 'bark', broaden = 0):\n    nbands, nframes = x.shape\n    nfpts = int(nbands + 2 * broaden)\n    \n    if fbtype == 'bark':\n        bandcfhz = bark2hz(np.linspace(0, hz2bark(fmax), nfpts))\n    elif fbtype == 'mel':\n        bandcfhz = mel2hz(np.linspace(0, hz2mel(fmax), nfpts))\n    elif fbtype == 'htkmel' or fbtype == 'fcmel':\n        bandcfhz = mel2hz(np.linspace(0, hz2mel(fmax, htk = True), nfpts), htk = True)\n        \n    bandcfhz = bandcfhz[broaden : (nfpts - broaden)];\n    \n    fsq = np.power(bandcfhz, 2)\n    ftmp = np.add(fsq, 1.6e5)\n    eql = np.multiply(np.power(np.divide(fsq, ftmp), 2), np.divide(np.add(fsq, 1.44e6), np.add(fsq, 9.61e6)))\n    \n    z = np.multiply(np.tile(eql, (nframes, 1)).T, x)\n    z = np.power(z, 0.33)\n    \n    if broaden:\n        y = np.zeros((z.shape[0] + 2, z.shape[1]))\n        y[0, :] = z[0, :]\n        y[1:nbands + 1, :] = z\n        y[nbands + 1, :] = z[z.shape[0] - 1, :]\n    else:\n        y = np.zeros((z.shape[0], z.shape[1]))\n        y[0, :] = z[1, :]\n        y[1:nbands - 1, :] = z[1:z.shape[0] - 1, :]\n        y[nbands - 1, :] = z[z.shape[0] - 2, :]\n    \n    return y, eql\n\ndef spec2cep(spec, ncep, dcttype):\n    nrow, ncol = spec.shape[0], spec.shape[1]\n    dctm = np.zeros((ncep, nrow))\n    \n    if dcttype == 2 or dcttype == 3:\n        for i in range(ncep):\n            dctm[i, :] = np.multiply(np.cos(np.multiply(np.divide(np.multiply(i, np.arange(1, 2 * nrow, 2)), (2 * nrow)), np.pi)), np.sqrt(2 \/ nrow))\n        \n        if dcttype == 2:\n            dctm[0, :] = np.divide(dctm[0, :], np.sqrt(2))\n            \n    elif dcttype == 4:\n        for i in range(ncep):\n            dctm[i, :] = np.multiply(np.cos(np.multiply(np.divide(np.multiply(i, np.arange(1, nrow + 1)), (nrow + 1)), np.pi)), 2)\n            dctm[i, 0] = np.add(dctm[i, 0], 1)\n            dctm[i, int(nrow - 1)] = np.multiply(dctm[i, int(nrow - 1)], np.power(-1, i))\n        dctm = np.divide(dctm, 2 * (nrow + 1))\n    \n    else:\n        for i in range(ncep):\n            dctm[i, :] = np.divide(np.multiply(np.cos(np.multiply(np.divide(np.multiply(i, np.arange(0, nrow)), (nrow - 1)), np.pi)), 2), 2 * (nrow - 1))\n        dctm[:, 0] = np.divide(dctm[:, 0], 2)\n        dctm[:, int(nrow - 1)] = np.divide(dctm[:, int(nrow - 1)], 2)\n    \n    cep = np.matmul(dctm, np.log(np.add(spec, 1e-8)))\n    \n    return cep, dctm\n\ndef lpc2spec(lpcas, nout = 17, FMout = False):\n    \n    rows, cols = lpcas.shape\n    order = rows - 1\n    \n    gg = lpcas[0, :]\n    aa = np.divide(lpcas, np.tile(gg, (rows, 1)))\n    \n#    Calculate the actual z-plane polyvals: nout points around unit circle\n    tmp_1 = np.array(np.arange(0, nout), ndmin = 2).T\n    tmp_1 = np.divide(np.multiply(-1j, np.multiply(tmp_1, np.pi)), (nout - 1))\n    tmp_2 = np.array(np.arange(0, order + 1), ndmin = 2)\n    zz = np.exp(np.matmul(tmp_1, tmp_2))\n#    Actual polyvals, in power (mag^2)    \n    features = np.divide(np.power(np.divide(1, np.abs(np.matmul(zz, aa))), 2), np.tile(gg, (nout, 1)))\n    F = np.zeros((cols, int(np.ceil(rows \/ 2))))\n    M = F\n    \n    if FMout == True:\n        for c in range(cols):\n            aaa = aa[:, c]\n            rr = np.roots(aaa)\n            ff_tmp = np.angle(rr)\n            ff = np.array(ff_tmp, ndmin = 2).T\n            zz = np.exp(np.multiply(1j, np.matmul(ff, np.array(np.arange(0, aaa.shape[0]), ndmin = 2))))\n            mags = np.sqrt(np.divide(np.power(np.divide(1, np.abs(np.matmul(zz, np.array(aaa, ndmin = 2).T))), 2), gg[c]))\n            \n            ix = np.argsort(ff_tmp)\n            dummy = np.sort(ff_tmp)\n            mp_F_list = []\n            tmp_M_list = []\n            \n            for i in range(ff.shape[0]):\n                if dummy[i] > 0:\n                    tmp_F_list = np.append(tmp_F_list, dummy[i])\n                    tmp_M_list = np.append(tmp_M_list, mags[ix[i]])\n            \n            M[c, 0 : tmp_M_list.shape[0]] = tmp_M_list\n            F[c, 0 : tmp_F_list.shape[0]] = tmp_F_list\n        \n    return features, F, M\n\ndef deltas(x, w = 9):\n    rows, cols = x.shape\n    hlen = np.floor(w \/ 2)\n    win = np.arange(hlen,-(hlen + 1),-1, dtype = 'float32')\n\n    xx = np.append(np.append(np.tile(x[:, 0], (int(hlen), 1)).T, x, axis = 1), \n               np.tile(x[:, cols - 1], (int(hlen), 1)).T, axis = 1)\n    \n    d = signal.lfilter(win, 1, xx, axis = 1)\n    d = d[:, int(2 * hlen) : int(2 * hlen + cols)]\n    return d\n\ndef cep2spec(cep, nfreq, dcttype = 2):\n    ncep, ncol = cep.shape\n    \n    dctm  = np.zeros((ncep, nfreq))\n    idctm = np.zeros((nfreq, ncep))\n    \n    if dcttype == 2 or dcttype == 3:\n        for i in range(ncep):\n            dctm[i, :] = np.multiply(np.cos(np.multiply(np.divide(np.multiply(i, np.arange(1, 2 * nfreq, 2)),\n                                                                  (2 * nfreq)), np.pi)), np.sqrt(2 \/ nfreq))        \n            \n        if dcttype == 2:\n            dctm[0, :] = np.divide(dctm[0, :], np.sqrt(2))\n        else:\n            dctm[0, :] = np.divide(dctm[0, :], 2)\n                \n        idctm = dctm.T\n        \n    elif dcttype == 4:\n        for i in range(ncep):\n            idctm[:, i] = np.multiply(np.cos(np.multiply(np.divide(np.multiply(i, np.arange(1, nfreq + 1).T), (nfreq + 1)), np.pi)), 2)\n            \n        idctm[:, 0:ncep] = np.divide(idctm[:, 0:ncep], 2)    \n    \n    else:\n        for i in range(ncep):\n            idctm[:, i] = np.multiply(np.cos(np.multiply(np.divide(np.multiply(i, np.arange(0, nfreq).T), (nfreq - 1)), np.pi)), 2)\n            \n        idctm[:, [0, -1]] = np.divide(idctm[:, [0, -1]], 2)\n        \n    spec = np.exp(np.matmul(idctm, cep))\n    \n    return spec, idctm\n\ndef invpostaud(y, fmax, fbtype = 'bark', broaden = 0):\n    \n    nbands, nframes = y.shape\n    \n    if fbtype == 'bark':\n        bandcfhz = bark2hz(np.linspace(0, hz2bark(fmax), nbands))\n    elif fbtype == 'mel':\n        bandcfhz = mel2hz(np.linspace(0, hz2mel(fmax), nbands))\n    elif fbtype == 'htkmel' or fbtype == 'fcmel':\n        bandcfhz = mel2hz(np.linspace(0, hz2mel(fmax, htk = True), nbands), htk = True)\n        \n    bandcfhz = bandcfhz[broaden : (nbands - broaden)]\n    \n    fsq = np.power(bandcfhz, 2)\n    ftmp = np.add(fsq, 1.6e5)\n    eql = np.multiply(np.power(np.divide(fsq, ftmp), 2), \n                      np.divide(np.add(fsq, 1.44e6), np.add(fsq, 9.61e6)))\n    \n    x = np.power(y, np.divide(1, 0.33))\n    \n    if eql[0] == 0:\n        eql[0] = eql[1]\n        eql[-1] = eql[-2]\n        \n    x = np.divide(x[broaden : (nbands - broaden + 1), :], np.add(np.tile(eql.T, (nframes, 1)).T, 1e-8))\n    \n    return x, eql\n\ndef invpowspec(y, fs, win_time, hop_time, excit = []):\n    nrow, ncol = y.shape\n    r = excit\n    \n    winpts = int(np.round(np.multiply(win_time, fs)))\n    steppts = int(np.round(np.multiply(hop_time, fs)))\n    nfft = int(np.power(2, np.ceil(np.divide(np.log(winpts), np.log(2)))))\n    \n    # Can't predict librosa stft length...\n    tmp = librosa.istft(y, hop_length = steppts, win_length = winpts, \n                      window='hann', center = False)\n    xlen = len(tmp)\n    # xlen = int(np.add(winpts, np.multiply(steppts, np.subtract(ncol, 1))))\n    # xlen = int(np.multiply(steppts, np.subtract(ncol, 1)))\n    \n    if len(r) == 0:\n        r = np.squeeze(np.random.randn(xlen, 1))\n    r = r[0:xlen]\n    \n    R = librosa.stft(np.divide(r, 32768 * 12), n_fft = nfft, hop_length = steppts,\n                     win_length = winpts, window = 'hann', center = False)\n\n    R = np.multiply(R, np.sqrt(y))\n    x = librosa.istft(R, hop_length = steppts, win_length = winpts, \n                      window = 'hann', center = False)\n                     \n    return x\n\ndef invaudspec(aspectrum, fs = 16000, nfft = 512, fbtype = 'bark', \n               min_freq = 0, max_freq = 0, sumpower = True, band_width = 1):\n    \n    if max_freq == 0:\n        max_freq = fs \/ 2\n    nfilts, nframes = aspectrum.shape\n    \n    if fbtype == 'bark':\n        wts = fft2barkmx(nfft, fs, nfilts, band_width, min_freq, max_freq)\n    elif fbtype == 'mel':\n        wts = fft2melmx(nfft, fs, nfilts, band_width, min_freq, max_freq)\n    elif fbtype == 'htkmel':\n        wts = fft2melmx(nfft, fs, nfilts, band_width, min_freq, max_freq, htk = True, constamp = True)\n    elif fbtype == 'fcmel':\n        wts = fft2melmx(nfft, fs, nfilts, band_width, min_freq, max_freq, htk = True, constamp = False)\n    \n    wts = wts[:, 0:int(nfft \/ 2 + 1)]\n    \n    ww = np.matmul(wts.T, wts)\n    itws = np.divide(wts.T, np.tile(np.maximum(np.divide(np.mean(np.diag(ww)), 100), \n                                               np.sum(ww, axis = 0)), (nfilts, 1)).T)\n    if sumpower == True:\n        spec = np.matmul(itws, aspectrum)\n    else:\n        spec = np.power(np.matmul(itws, np.sqrt(aspectrum)))\n   \n    return spec, wts, itws\n\ndef invmelfcc(cep, fs, win_time = 0.040, hop_time = 0.020, lifterexp = 0.6, sumpower = True,\n             preemph = 0.97, max_freq = 6500, min_freq = 50, n_bands = 40, band_width = 1,\n             dcttype = 2, fbtype = 'mel', usecmp = False, modelorder = 0, broaden = 0, excitation = []):\n    \n    winpts = int(np.round(np.multiply(win_time, fs)))\n    nfft = int(np.power(2, np.ceil(np.divide(np.log(winpts), np.log(2)))))\n    \n    cep = lifter(cep, lift = lifterexp, invs = True)\n    \n    pspc, _ = cep2spec(cep, nfreq = int(n_bands + 2 * broaden), dcttype = dcttype)\n    \n    if usecmp == True:\n        aspc, _ = invpostaud(pspc, fmax = max_freq, fbtype = fbtype, broaden = broaden)\n    else:\n        aspc = pspc\n        \n    spec, _, _ = invaudspec(aspc, fs = fs, nfft = nfft, fbtype = fbtype, min_freq = min_freq,\n                            max_freq = max_freq, sumpower = sumpower, band_width = band_width)\n    \n    x = invpowspec(spec, fs, win_time = win_time, hop_time = hop_time, excit = excitation)\n    \n    if preemph != 0:\n        b = [1, -preemph]\n        a = 1\n        x = signal.lfilter(b, a, x)\n    \n    return x, aspc, spec, pspc   ","02f711f3":"rasta_plp_arr = []\nfor path in tqdm(wav_flpath[:30]):    \n    x = rastaplp(path)\n    rasta_plp_arr.append(np.array(x).ravel())                                                ","94b1293d":"rasta_plp_arr[18].shape","d085e762":"rasta_plp_df = pd.DataFrame(rasta_plp_arr)\nrasta_plp_df = rasta_plp_df.fillna(0)\nrasta_plp_df","a5fe2c71":"gt_64 = []\nfor file in tqdm(os.listdir('..\/input\/babble-gammatone64-csv')):\n    filename = '..\/input\/babble-gammatone64-csv'+'\/'+file\n    df = pd.read_csv(filename)\n    sub_arr = [float(cols) for cols in list(df.columns)]\n    sub_arr.extend(df.values.ravel())\n    gt_64.append(sub_arr)","b62aa21a":"gt_64_df = pd.DataFrame(gt_64)\ngt_64_df = gt_64_df.fillna(0)\ngt_64_df","ae8904af":"def generateSignalAM(t,data):\n    #sample rate is 44100 Hz\n    TWO_PI = 2 * np.pi\n    fc = 10000\n    ac = 0.00005\n    carrier_wave = np.cos(t * fc * TWO_PI)\n    am = carrier_wave * (1 + data\/ac)\n\n#     plt.plot(t,am)\n#     #plt.plot(time,data)\n#     plt.xlabel(\"Time(s)\")\n#     plt.ylabel(\"Amplitude\")\n#     #plt.legend(['AM Signal', 'Original Signal'])\n#     plt.show()\n    return am\n\nams_arr = []\n\nfor path in tqdm(filepaths[:30]):      \n    samplerate, data = wavfile.read(path)\n    duration = len(data)\/samplerate\n    time = np.arange(0,duration,1\/samplerate) #time vector\n    x = generateSignalAM(time,data)    \n    ams_arr.append(np.array(x).ravel())       ","82949f9b":"ams_df = pd.DataFrame(ams_arr)\nams_df = ams_df.fillna(0)\nams_df","486047e7":"feature_df = [mfcc_df, rasta_plp_df, ams_df,gt_64_df]\n\nfeature_df = pd.concat(feature_df,axis=1)\n\nfeature_df","2b5dbe86":"from sklearn.decomposition import PCA\npca = PCA().fit(feature_df)\nplt.figure(figsize=(150,20)) \nplt.plot(np.cumsum(pca.explained_variance_ratio_))\nplt.xlabel('number of components')\nplt.ylabel('cumulative explained variance')\nplt.title('Cumulative Explained Variance')","de2b644c":"test_arr = []\nfor file in tqdm(os.listdir('..\/input\/test-gammatone64-csv')):\n    filename = '..\/input\/test-gammatone64-csv'+'\/'+file\n    df = pd.read_csv(filename)\n    sub_arr = [float(cols) for cols in list(df.columns)]\n    sub_arr.extend(df.values.ravel())\n    test_arr.append(sub_arr)","5637ee71":"test_df = pd.DataFrame(test_arr)\ntest_df = test_df.fillna(0)\ntest_df","b8d6096e":"import tensorflow as tf\nimport keras","cefd449a":"from keras.models import Sequential\nfrom keras.layers import InputLayer, Dense","6e902a63":"# input_shape = feature_df.shape[1]\ninput_shape = 200000\n# output_shape = test_df.shape[1]\noutput_shape = 200000","cf1f2183":"model = Sequential()\nmodel.add(InputLayer(input_shape = (input_shape,)))\nmodel.add(Dense(units = 1024,activation = 'relu'))\nmodel.add(Dense(units = 1024,activation = 'relu'))\nmodel.add(Dense(units = 1024,activation = 'relu'))\nmodel.add(Dense(units=output_shape,activation='linear'))","2f5b1cbc":"# Gammatone Filter 64","d9a002bb":"# Modelling","409fa19c":"# Training Set","511e995e":"# RASTA PLP","c750c19b":"# Test Set","914c8f8e":"# AMPLITUDE MODULATION ANALYSIS"}}