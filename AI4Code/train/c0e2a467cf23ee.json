{"cell_type":{"0cb1e574":"code","1a24f4a0":"code","22e595fb":"code","c16ddcf6":"code","641ba296":"code","50f68873":"code","c6f9a3c4":"code","1166e740":"code","f7ce2ce9":"markdown","5d7f9907":"markdown","000dec1c":"markdown","f5e6cc31":"markdown"},"source":{"0cb1e574":"from concorde.tsp import TSPSolver\nfrom tqdm import tqdm_notebook\nimport numpy as np\nimport pandas as pd\nimport time","1a24f4a0":"cities = pd.read_csv('..\/input\/cities.csv')","22e595fb":"cities_scaled = cities.copy()\ncities_scaled.iloc[:, 1:] *= 1000","c16ddcf6":"solver = TSPSolver.from_data(\n    cities_scaled.X,\n    cities_scaled.Y,\n    norm=\"EUC_2D\"\n)\n\nt = time.time()\ntour_data = solver.solve(time_bound = 60.0, verbose = True, random_seed = 42) # solve() doesn't seem to respect time_bound for certain values?\nprint(time.time() - t)\nprint(tour_data.found_tour)\n","641ba296":"# function to get simple numbers\ndef primes(n):\n    a = [0] * n \n    for i in range(n):\n        a[i] = i \n        \n    a[1] = 0\n     \n    m = 2 \n    while m < n: \n        if a[m] != 0: \n            j = m * 2\n            while j < n:\n                a[j] = 0\n                j = j + m\n        m += 1\n    \n    b = []\n    for i in a:\n        if a[i] != 0:\n            b.append(a[i])\n    \n    del a\n    return b","50f68873":"# route length calculation\ndef route_len(tour_data, cities):\n    route = tour_data.tour\n    prime_nums = primes(route.shape[0])\n    coords = cities.iloc[route, 1:].values\n    coord_diff = coords[1:] - coords[:-1]\n    coeffs = np.ones((coord_diff.shape[0], ))\n    for idx in tqdm_notebook(range(9, coord_diff.shape[0], 10)):\n        if route[idx] not in prime_nums:\n            coeffs[idx] += 0.1\n    length = np.sum(np.sqrt(np.power(coord_diff[:, 0], 2) + np.power(coord_diff[:, 1], 2)) *  coeffs.T)\n    return length","c6f9a3c4":"length = route_len(tour_data, cities)\nlength_scaled = route_len(tour_data, cities_scaled)\nprint('Length: {}, Scaled length: {}'.format(length, length_scaled))","1166e740":"pd.DataFrame({'Path': np.append(tour_data.tour,[0])}).to_csv('submission_scaled.csv', index=False)","f7ce2ce9":"Euclidean norm in Concorde rounds the distance to integer, so it is reasonable to scale city's coordinates.","5d7f9907":"Scaling coordinates improved the result from **1532958.68** to **1524756.18**.","000dec1c":"This kernel is a modification of the kernel \"Concorde solver\" (https:\/\/www.kaggle.com\/wcukierski\/concorde-solver)","f5e6cc31":"The following functions allow to calculate the route length"}}