{"cell_type":{"2ac177e2":"code","976c0157":"code","9798e9f2":"code","a4e68c99":"code","7e7e3740":"code","4c63a56e":"code","8ba67a67":"code","ded7e419":"code","269fbd62":"code","97c38c30":"code","182e7f6c":"code","9d9d6121":"code","8da82103":"code","bd84ee46":"code","76818d6e":"code","bd6d474c":"code","12427346":"code","26b77411":"code","c6ca4224":"code","6af5d28e":"code","1d23c97c":"code","ae20db10":"code","7b093ba0":"code","5efcf4f1":"code","9ea935f4":"code","37ec8dc3":"code","5ba94e6e":"code","3e5f0054":"code","5e84a501":"code","8e8f8016":"code","814dfa3e":"code","c45a1846":"code","651cd54d":"code","01b14b51":"code","9e22a7b3":"code","4d90a3ef":"code","d82e04c1":"code","ebbbf1f7":"code","62e4eb63":"code","6bb18502":"code","e40d3e49":"code","9f62bb0f":"code","9b74efda":"code","6281d88b":"code","ce33c3b8":"code","9e3af92d":"code","d5ea6510":"code","68b573df":"code","8ac9ba1b":"code","7a1eb875":"code","c509ed7d":"code","66f2a0ab":"code","6f3dda74":"code","485fe3c0":"code","f74f4245":"code","7db11ef3":"code","8055f475":"code","fe8f46eb":"code","3b9f63e5":"code","04b6fd92":"markdown","ff9852b2":"markdown","b6e0054f":"markdown","e8d0ec1d":"markdown","bc711b3f":"markdown","b862cd3d":"markdown","1cdef59b":"markdown","d60a5f7e":"markdown","075b566c":"markdown","efc815a5":"markdown","b36a82ef":"markdown","b16ee0ce":"markdown","aa349e1c":"markdown","34df2862":"markdown","ae124ef0":"markdown","d85bffcc":"markdown","32433940":"markdown","0c745867":"markdown","f1e2194b":"markdown","90a79d16":"markdown","9dc3415d":"markdown","72e71745":"markdown","8915ae7c":"markdown","c630b7c3":"markdown","efb9da30":"markdown","c7dd15b5":"markdown","7150c21d":"markdown","5f2e44bb":"markdown","8a566fa3":"markdown","3a257ca2":"markdown","771d0d7b":"markdown","e03e2809":"markdown","6965ea67":"markdown"},"source":{"2ac177e2":"import pandas as pd\nimport numpy as np\nfrom sklearn import tree\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.model_selection import KFold\nimport seaborn as sns\nimport matplotlib.pyplot as plt","976c0157":"df_original = pd.read_csv('\/kaggle\/input\/titanic\/train.csv')\ndf = df_original.copy()","9798e9f2":"df.head(10)","a4e68c99":"df.info()","7e7e3740":"df.describe()","4c63a56e":"n_row, n_col = df.shape\n\nprint(\"Number of row: \",n_row)\nprint(\"Number of column: \",n_col)","8ba67a67":"fig = plt.subplots(figsize = (12,5))\nsns.countplot(x = 'Survived', hue = 'Pclass', data = df_original)","ded7e419":"fig = plt.subplots(figsize = (12,5))\nsns.countplot(x = 'Survived', hue = 'Sex', data = df_original)","269fbd62":"fig = plt.subplots(figsize = (12,5))\nsns.countplot(x = 'Survived', hue = 'Embarked', data = df_original)","97c38c30":"df.Age.quantile(.99)","182e7f6c":"plt.figure(figsize = (16,12))\ntemp = df[df.Age < 65.87]\nsns.violinplot(x = 'Survived', y = 'Age', data = temp)","9d9d6121":"df.Fare.quantile(.99)","8da82103":"plt.figure(figsize = (16,12))\ntemp = df[df.Fare < 249.006]\nsns.violinplot(x = 'Survived', y = 'Fare', data = temp)","bd84ee46":"corrMatrix = df.corr()\nsns.heatmap(corrMatrix, annot=True)\nplt.show()","76818d6e":"df.isna().sum()","bd6d474c":"df.Age.plot.hist()","12427346":"np.random.seed(0)\nnan_rows = df['Age'].isna()\nrandom_age = np.random.choice(df['Age'][~nan_rows], replace=True, size=sum(nan_rows))","26b77411":"df.loc[nan_rows,'Age'] = random_age","c6ca4224":"df.Age.plot.hist()","6af5d28e":"df.Embarked.value_counts()","1d23c97c":"df.Embarked.mode()[0]","ae20db10":"df.Embarked.fillna(df.Embarked.mode()[0], inplace=True)","7b093ba0":"df = df.drop(['Ticket','Cabin','PassengerId','Name'],axis=1)","5efcf4f1":"mean = df['Age'].mean()\nstd = df['Age'].std()\n   \n# Any value higher than upper limit or below lower limit is an outlier\nupper_limit = mean + 3*std\nlower_limit = mean - 3*std\nupper_limit, lower_limit","9ea935f4":"outlier_rows = (df['Age'] > upper_limit) | (df['Age'] < lower_limit)  \ndf['Age'][outlier_rows]","37ec8dc3":"df.loc[outlier_rows, 'Age'] = df['Age'][~outlier_rows].mean()","5ba94e6e":"condition = (df['Age']>60) & (df['Sex'] == 'male')\ncondition_2 = (df['Age']>60) & (df['Sex'] == 'female')\ndf['ElderMale'] = np.where(condition, 1, 0)\ndf['ElderFemale'] = np.where(condition_2, 1, 0)\ndf.head()","3e5f0054":"dummy = pd.get_dummies(df['Embarked'], prefix='Embarked')","5e84a501":"df = pd.concat([df, dummy], axis=1)\ndf = df.drop(['Embarked'], axis=1)\ndf.head(10)","8e8f8016":"dummy = pd.get_dummies(df['Pclass'], prefix='Pclass')","814dfa3e":"df = pd.concat([df, dummy], axis=1)\ndf = df.drop(['Pclass'], axis=1)\ndf.head(10)","c45a1846":"dummy = pd.get_dummies(df['Sex'], prefix='Sex')","651cd54d":"df = pd.concat([df, dummy], axis=1)\ndf = df.drop(['Sex'], axis=1)\ndf.head(10)","01b14b51":"from sklearn.preprocessing import MinMaxScaler\n\nscaler = MinMaxScaler()\nscaler.fit(df['Age'].values.reshape(-1,1))","9e22a7b3":"df['Age'] = scaler.transform(df['Age'].values.reshape(-1,1))\ndf['Age'].describe()","4d90a3ef":"scaler.fit(df['Fare'].values.reshape(-1,1))\ndf['Fare'] = scaler.transform(df['Fare'].values.reshape(-1,1))\ndf['Fare'].describe()","d82e04c1":"test_size = int(df.shape[0]*0.1)","ebbbf1f7":"train_df = df.iloc[:-test_size].copy()\ntest_df = df.iloc[-test_size:].copy()","62e4eb63":"X = train_df.loc[:, df.columns != 'Survived']\nY = train_df.loc[:, 'Survived']","6bb18502":"X.head(10)","e40d3e49":"Y.head(10)","9f62bb0f":"# K = 5\nK = 5\nkf = KFold(n_splits=5,random_state=2020,shuffle=True)","9b74efda":"K_Fold_list = []\nfor train_index,test_index in kf.split(X):\n    X_train, X_test = X.iloc[train_index], X.iloc[test_index]\n    y_train, y_test = Y.iloc[train_index], Y.iloc[test_index]\n    K_Fold_list.append([[X_train,y_train],[X_test,y_test]])","6281d88b":"K_Fold_list[0][0][0]","ce33c3b8":"K_Fold_list[0][0][1]","9e3af92d":"from sklearn.metrics import recall_score\nfrom sklearn.metrics import precision_score\n\ndef evaluate(y_true,y_pred,label=1):\n    precision = precision_score(y_true, y_pred, pos_label=label)\n    recall = recall_score(y_true, y_pred, pos_label=label)\n    f1 = 2 * (precision * recall) \/ (precision + recall)\n    return {\"precision\": precision, \"recall\": recall, \"f1\": f1}","d5ea6510":"def show_result(clf, K_Fold_list):\n    c = 1\n    f1_list_class_survived = []\n    f1_list_class_not_survived = []\n    model_list = []\n    for fold in K_Fold_list:\n        print(\"#\"*50)\n        print(\"Fold #{}\".format(c))\n        print(\"#\"*50)\n        clf = clf.fit(fold[0][0], fold[0][1])\n        model_list.append(clf)\n        y_pred = clf.predict(fold[1][0]) # Predict\n        y_true = fold[1][1]\n\n        print(\"Class survived\")\n        metrics = evaluate(y_pred,y_true,label=1) # Lable 1 positive\n        print(\"Precision survived:\",metrics['precision'])\n        print(\"Recall survived:\",metrics['recall'])\n        print(\"F1 survived:\",metrics['f1'])\n        f1_list_class_survived.append(metrics['f1'])\n\n        print(\"\")\n        print(\"Class not survived\")\n        metrics = evaluate(y_pred,y_true,label=0) # Lable 0 positive\n        print(\"Precision not survived:\",metrics['precision'])\n        print(\"Recall not survived:\",metrics['recall'])\n        print(\"F1 not survived:\",metrics['f1'])\n        f1_list_class_not_survived.append(metrics['f1'])\n        print(\"#\"*50)\n        print(\"\")\n        c+=1\n\n    avg_f1_class_survived = sum(f1_list_class_survived)\/len(f1_list_class_survived)\n    avg_f1_class_not_survived = sum(f1_list_class_not_survived)\/len(f1_list_class_not_survived)\n\n    print(\"#\"*50)\n    print(\"Summary\")\n    print(\"#\"*50)\n    print(\"Average F1 survived:\",avg_f1_class_survived)\n    print(\"Average F1 not survived:\",avg_f1_class_not_survived)\n    return {\"Average_F1_survived\":avg_f1_class_survived,\n            \"Average_F1_not_survived\":avg_f1_class_not_survived\n           },model_list\n            ","68b573df":"clf_tree = tree.DecisionTreeClassifier()\nclf_tree = clf_tree.fit(K_Fold_list[0][0][0], K_Fold_list[0][0][1])","8ac9ba1b":"import graphviz \ndot_data = tree.export_graphviz(clf_tree,out_file=None,\n                        feature_names = K_Fold_list[0][0][0].columns.to_list(),\n                        class_names = ['Survived','No Survived'],\n                        filled=True, rounded=True,special_characters=True)  \ngraph = graphviz.Source(dot_data) \ngraph","7a1eb875":"clf_tree = tree.DecisionTreeClassifier()\nf1_DT_avg,model_DT = show_result(clf_tree,K_Fold_list)","c509ed7d":"gnb = GaussianNB()\nf1_NB_avg,model_NB = show_result(gnb,K_Fold_list)","66f2a0ab":"clf_NN = MLPClassifier(random_state=2020, max_iter=5000, hidden_layer_sizes = 7)\nf1_NN_avg,model_NN = show_result(clf_NN,K_Fold_list)","6f3dda74":"df_Average_F1 = pd.DataFrame([f1_DT_avg,f1_NB_avg,f1_NN_avg])\ndf_Average_F1['Name'] = ['Decision Tree', ' Naive Bayes', 'Neural Network']","485fe3c0":"ax = sns.barplot(x = 'Name', y = 'Average_F1_survived', data = df_Average_F1)\nax.set(xlabel='Name', ylabel='Average F1')\nax.set_title(\"Average F1 Predict Survived\")","f74f4245":"ax = sns.barplot(x = 'Name', y = 'Average_F1_not_survived', data = df_Average_F1)\nax.set(xlabel='Name', ylabel='Average F1')\nax.set_title(\"Average F1 Predict Not Survived\")","7db11ef3":"def print_result(clfs, Xs):\n    probs = np.zeros(shape=(Xs.shape[0], 2))\n\n    for fold_id in range(len(clfs)):\n        probs += clfs[fold_id].predict_proba(Xs.loc[:, df.columns != 'Survived']) \/ K\n    preds = np.argmax(probs, axis=1)\n    return preds\n","8055f475":"pred = print_result(model_DT, test_df)\ny_true = test_df.loc[:, 'Survived']\nevaluate(y_true,pred)","fe8f46eb":"pred = print_result(model_NB, test_df)\ny_true = test_df.loc[:, 'Survived']\nevaluate(y_true,pred)","3b9f63e5":"pred = print_result(model_NN, test_df)\ny_true = test_df.loc[:, 'Survived']\nevaluate(y_true,pred)","04b6fd92":"### Fare","ff9852b2":"## Fare violinplot","b6e0054f":"## Neural Network","e8d0ec1d":"### Elder","bc711b3f":"## Count Survived and Not Survived per Sex","b862cd3d":"## Add more feture","1cdef59b":"## One-Hot-Encoding\n### Embarked","d60a5f7e":"## Identify outliers with mean & std.","075b566c":"## Show result","efc815a5":"# Import","b36a82ef":"## Import Library","b16ee0ce":"## Clean data\n### Fill num value \n#### Age","aa349e1c":"## Age violinplot","34df2862":"# Test ","ae124ef0":"## Decision Tree","d85bffcc":"## Na\u00efve Bayes","32433940":"## Neural Network","0c745867":"#### Embarked","f1e2194b":"## Na\u00efve Bayes","90a79d16":"# Preprocess data","9dc3415d":"### Sex","72e71745":"## Count Survived and Not Survived per Embarked","8915ae7c":"## Count Survived and Not Survived per Class group","c630b7c3":"# Model\n## Define metrics","efb9da30":"## Decision Tree","c7dd15b5":"# Summary","7150c21d":"# Prepare Data\n## K-Flod cross validation","5f2e44bb":"## Correlation Matrix","8a566fa3":"# Visualization","3a257ca2":"## MinMax scaler \n### Age","771d0d7b":"### Drop some col\n- Ticket\n- Cabin\n- PassengerId","e03e2809":"### Pclass","6965ea67":"## Load Data"}}