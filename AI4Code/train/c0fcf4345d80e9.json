{"cell_type":{"2f22a03a":"code","1383b78f":"code","ac8a93ec":"code","a883ef50":"code","41eddfc9":"code","43c17fbb":"code","cdfdd932":"code","5ad819cb":"code","0ca43229":"code","f0e5fc66":"code","cfe61ec7":"code","4b7c44bc":"code","bc4c81be":"code","6abc0525":"code","5b8b7235":"code","6b2a938d":"code","4d511a33":"code","aa2aa050":"code","f4e416f4":"code","b54e9361":"code","a102668c":"code","a9c56ec1":"code","7dc01431":"code","b5b03b05":"code","c53a9bf7":"code","7dae4d6d":"code","7430d897":"code","2450f7de":"code","eedbe3f9":"markdown","afd2393f":"markdown","b9486651":"markdown","ef476ad7":"markdown","f5cdd7d6":"markdown","4235a270":"markdown","9c926f25":"markdown","d5b82ce5":"markdown","b386054b":"markdown","e9918848":"markdown","976162b7":"markdown","97d13ba6":"markdown","f8ee041f":"markdown","1cd9ef9f":"markdown","877611d1":"markdown","b9684447":"markdown","b61b22d2":"markdown","f5e7b853":"markdown","8883da60":"markdown","1c139fb8":"markdown","d1826f13":"markdown","43fffad1":"markdown","b9372892":"markdown","7222eb51":"markdown"},"source":{"2f22a03a":"# import the necessary libraries\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.linear_model import LinearRegression, LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor, AdaBoostClassifier,AdaBoostRegressor, GradientBoostingClassifier, GradientBoostingRegressor\nfrom sklearn.svm import SVC, SVR\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score","1383b78f":"kopa = pd.read_csv(\"..\/input\/kopacsv\/KOPA.csv\")\n\nkopa.head()","ac8a93ec":"# Check info\n\nkopa.info()","a883ef50":"# Checking for duplicates\n\nkopa.duplicated().sum()","41eddfc9":"# How many products are there?\n\n# Set size of plot\nsns.set(rc={'figure.figsize':(15,10)})\n\n# Plot a bar plot,\nsns.countplot(x='Product', data=kopa, palette='husl').set(title='No. of Products')","43c17fbb":"sns.countplot(x='Region' , hue = 'Product', data = kopa).set(title='Product vs Region')","cdfdd932":"# Product and Customer Gender\n\nsns.countplot(x='CustomerGender' , hue = 'Product', data = kopa).set(title='Product vs Gender')","5ad819cb":"# Gender and Region\nsns.countplot(x='Region' , hue = 'CustomerGender', data = kopa).set(title='Gender vs Region')","0ca43229":"# Ditribution of the classes\n\nsns.countplot(x='LoanStatus360', data=kopa, palette='husl')","f0e5fc66":"# Check distribution\n\nkopa['LoanStatus360'].value_counts(normalize=True)","cfe61ec7":"# Define a function\n\ndef time_column_generator(time_column, data, to_drop=False):\n\n# It extracts information from the time column to return a new dataset with new columns consisting of year, month, day, holiday, weekend, hour and minute.\n\n# Import Datetime module\n\n    from datetime import datetime\n\n    # Extract values of time\n\n    time_values = data[time_column].values\n    # Extract month, year, day and day of week from startdate\n    month = [datetime.strptime(value, '%m\/%d\/%Y').month for value in time_values]\n    year = [datetime.strptime(value, '%m\/%d\/%Y').year for value in time_values]\n    day = [datetime.strptime(value, '%m\/%d\/%Y').day for value in time_values]\n    day_of_week = [datetime.strptime(value, '%m\/%d\/%Y').isoweekday() for value in time_values]\n    \n    # create columns\n    data['Month'] = month\n    data['Year'] = year\n    data['Day'] = day\n    data['Day_of_week'] = day_of_week\n\n    # drop original column\n    if to_drop:\n       new_data = data.drop(time_column, axis=1)\n    else:\n       new_data = data.copy()\n\n    return new_data","4b7c44bc":"# Extract columns\n\nkopa_new = time_column_generator('StartDate', kopa, True)","bc4c81be":"# View kopa new\n\nkopa_new.head()","6abc0525":"# Let's create two datasets\n\nkopa_regression = kopa_new.copy()\nkopa_classification = kopa_new.copy()","5b8b7235":"# Use the label encoder\n# Instantiate the encoder\nencoder = LabelEncoder()\n\n# Encode categorical columns\ncat_columns = [column for column in kopa_regression.columns if kopa_regression[column].dtype == 'O']\n\nfor column in cat_columns:\n    kopa_regression[column] = encoder.fit_transform(kopa_regression[column])\n    kopa_classification[column] = encoder.fit_transform(kopa_classification[column])","6b2a938d":"# Heatmap\n\n# Corr matrix\ncorr_matrix = kopa_regression.corr()\n\n# Plot heatmap\nsns.heatmap(corr_matrix, cmap='magma', annot=True)","4d511a33":"# To drop columns\n\nreg_drop = ['CustomerGender', 'AmountPaid30', 'DailyRate', 'Day_of_week', 'TotalDays']\nclass_drop = ['Location', 'AmountPaid30', 'DailyRate', 'Day_of_week', 'TotalDays']\n\n# Drop columns\nkopa_regression.drop(reg_drop, axis=1, inplace=True)\nkopa_classification.drop(class_drop, axis=1, inplace=True)","aa2aa050":"# Split the data\n\nx = kopa_regression.drop('AmountPaid360', axis=1)\ny = kopa_regression['AmountPaid360']","f4e416f4":"# split into train and test and validation\n\n# Splt into train and a preliminary dataset which we shall split into test and validate\nx_train, x_hold, y_train, y_hold = train_test_split(x, y, train_size=0.7, random_state=42)\n\nx_val, x_test, y_val, y_test = train_test_split(x_hold, y_hold, test_size=0.5, random_state=42)","b54e9361":"# Model trainer\n\ndef model_trainer(models, x_train, x_val, y_train, y_val):\n    for model in models:\n        model.fit(x_train, y_train)\n        predictions = model.predict(x_val)\n        mae = mean_absolute_error(y_val, predictions)\n        rmse = mean_squared_error(y_val, predictions, squared=False)\n        r2 = r2_score(y_val, predictions)\n        print(f'Model {model} , rmse: {rmse}, r2_score: {r2}, mae: {mae}')","a102668c":"# Define models\n\nlr = LinearRegression()\ndt = DecisionTreeRegressor()\nrf = RandomForestRegressor()\nadaboost = AdaBoostRegressor()\ngb = GradientBoostingRegressor()\nsv = SVR()\n\nreg_models = [lr, dt, rf, adaboost, gb, sv]","a9c56ec1":"# Train and evaluate\n\nmodel_trainer(reg_models, x_train, x_val, y_train, y_val)","7dc01431":"# final evaluation with test data set\n\npredictions = gb.predict(x_test)\nrmse = mean_squared_error(y_test, predictions, squared=False)\nprint(rmse)","b5b03b05":"# Split the data\n\nx = kopa_classification.drop('LoanStatus360', axis=1)\ny = kopa_classification['LoanStatus360']","c53a9bf7":"# split into train and test and validation\n\n# Splt into train and a preliminary dataset which we shall split into test and validate\nx_train, x_hold, y_train, y_hold = train_test_split(x, y, train_size=0.7, random_state=42, stratify=y)\n\nx_val, x_test, y_val, y_test = train_test_split(x_hold, y_hold, test_size=0.5, random_state=42, stratify=y_hold)","7dae4d6d":"def model_trainer(models, x_train, x_val, y_train, y_val):\n    for model in models:\n        model.fit(x_train, y_train)\n        predictions = model.predict(x_val)\n        print(model)\n        print(classification_report(y_val, predictions))\n        print('-'*50)","7430d897":"# Define models\n\nlr = LogisticRegression()\ndt = DecisionTreeClassifier()\nrf = RandomForestClassifier()\nadaboost = AdaBoostClassifier()\ngb = GradientBoostingClassifier()\nsv = SVC()\n\nclass_models = [lr, dt, rf, adaboost, gb, sv]","2450f7de":"# Train and evaluate\n\nmodel_trainer(class_models, x_train, x_val, y_train, y_val)","eedbe3f9":"Here, we split the data three way. 70% train, 15% validation set and 15% test set","afd2393f":"Region 6 consumed the highest amount of total products followed by Region 3. With the product pattern remaining the same. Except for regions with low product sales","b9486651":"> **Loan Status**","ef476ad7":"Stratify enables the split to contain the same proportion of active, blocked and complete in all the splits.","f5cdd7d6":"There are none. Hence we proceed to engineering our features","4235a270":"# Data Cleaning, Feature Engineering & Exploration","9c926f25":"## Classification","d5b82ce5":"### Drop Unnecessary columns","b386054b":"The best model is the Gradient Boosting Regressor","e9918848":"The disparity isn't too big compared to 2571 meaning that the model isn't overfitting.","976162b7":"> **Gender**","97d13ba6":"### Regression","f8ee041f":"The aim of this project is to build a regression model to predict **AmountPaid360** and **LoanStatus360.** We shall start with the regression bit then the classification","1cd9ef9f":"In our case we use the label encoder by sklearn","877611d1":"## Feature Engineering","b9684447":"From the info, we can see that the data does not have any missing values. However, we can check for duplicates and engineer our features","b61b22d2":">**Start Date**\n\nWe can extract date, month and year and see whether they will be of importance","f5e7b853":"Product B sold the most , followed by product A. product F was the least bought","8883da60":"The input variables in play are described below:\n\n    * Product : The product type purchased by the customer,\n    * CustomerGender : Self-explanatory\n    * Location : The location where the loan was issued. (Also includes a long-tail of legacy locations)\n    * Region : The sales region where the device was purchased. Includes many regions which have since been changed. The current set of main sales regions are Regions 1-7.\n    * TotalPrice : The total amount to-be-paid by the customer over the course of the loan (including deposit and daily payments)\n    * StartDate : The day on which the customer's loan became active\n    * Deposit : The initial deposit required from the customer prior to loan activation\n    * DailyRate : The amount that the customer must pay daily in order to continue to use their device\n    * TotalDays : The number of days for which the customer is expected to continue paying the daily rate\n    * AmountPaid30 : The amount that the customer had repaid as of the 30th day of their loan\n    * AmountPaid60 : The amount that the customer had repaid as of the 60th day of their loan\n    \nThe outcome variables are as follows:\n\n    * AmountPaid360 : The amount that the customer had repaid as of the 360th day of their loan\n    * LoanStatus360 : The status of the loan as of day 360\n    * Active : The customer is still actively repaying their loan\n    * Blocked : The customer has had their account blocked after more than 30 days without a payment\n    * Finished Payment : The customer has successfully repaid their loan","1c139fb8":"# Modelling","d1826f13":"### Convert Categorical data to Numerical data","43fffad1":"> **Product and Region**","b9372892":"> **Product**","7222eb51":"The data is a bit imbalanced hence we will have to cater for that"}}