{"cell_type":{"a2591d15":"code","3792b0c6":"code","dc9238d8":"code","61a9f12f":"code","9a7a8064":"code","2e78e879":"code","cbba3ea4":"code","2449b039":"code","4f531c2d":"code","1dd73645":"code","e04b715a":"code","6407cc64":"code","3af54962":"code","0898421c":"code","1f7348d8":"code","f9edb41f":"code","216a79c9":"code","58abe45b":"code","a3e51b4d":"markdown","eca88cda":"markdown"},"source":{"a2591d15":"!pip install kaggle-environments -U > \/dev\/null 2>&1\n!cp -r ..\/input\/lux-ai-2021\/* .","3792b0c6":"import numpy as np\nimport json\nfrom pathlib import Path\nimport os\nimport random\nfrom tqdm.notebook import tqdm\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset, DataLoader\nimport torch.optim as optim\nfrom sklearn.model_selection import train_test_split","dc9238d8":"def seed_everything(seed_value):\n    random.seed(seed_value)\n    np.random.seed(seed_value)\n    torch.manual_seed(seed_value)\n    os.environ['PYTHONHASHSEED'] = str(seed_value)\n    \n    if torch.cuda.is_available(): \n        torch.cuda.manual_seed(seed_value)\n        torch.cuda.manual_seed_all(seed_value)\n        torch.backends.cudnn.deterministic = True\n        torch.backends.cudnn.benchmark = True\n\nseed = 42\nseed_everything(seed)","61a9f12f":"def to_label_ct(action, obs):\n    width, height = obs['width'], obs['height']\n    x_shift = (32 - width) \/\/ 2\n    y_shift = (32 - height) \/\/ 2   \n    strs = action.split(' ')\n    if strs[0] == 'r':\n        label = 0\n        unit_pos = (int(strs[1]) + x_shift, int(strs[2]) + y_shift)\n    elif strs[0] == 'bw': \n        label = 1\n        unit_pos = (int(strs[1]) + x_shift, int(strs[2]) + y_shift)\n    else:\n        label = None\n        unit_pos = None\n    \n    return label, unit_pos\n\ndef depleted_resources(obs):\n    for u in obs['updates']:\n        if u.split(' ')[0] == 'r':\n            return False\n    return True\n\ndef create_dataset_from_json_ctile(episode_dir, team_name='Toad Brigade'): \n    obses = {}\n    samples = []\n    append = samples.append\n    \n    episodes = [path for path in Path(episode_dir).glob('*.json') if 'output' not in path.name]\n#     episodes = episodes[:len(episodes)\/\/2]\n    for filepath in tqdm(episodes): \n        with open(filepath) as f:\n            json_load = json.load(f)\n\n        ep_id = json_load['info']['EpisodeId']\n        index = np.argmax([r or 0 for r in json_load['rewards']])\n        if json_load['info']['TeamNames'][index] != team_name:\n            continue\n\n        for i in range(len(json_load['steps'])-1):\n            if json_load['steps'][i][index]['status'] == 'ACTIVE':\n                actions = json_load['steps'][i+1][index]['action']\n                obs = json_load['steps'][i][0]['observation']\n                \n                if depleted_resources(obs):\n                    break\n                \n                obs['player'] = index\n                obs = dict([\n                    (k,v) for k,v in obs.items() \n                    if k in ['step', 'updates', 'player', 'width', 'height']\n                ])\n                \n                obs_id = f'{ep_id}_{i}'\n                obses[obs_id] = obs\n                \n                action_map = np.zeros((2,32,32))\n                mask = np.zeros((2,32,32))\n                \n                for action in actions:\n                    label, unit_pos = to_label_ct(action, obs)\n                    if label is not None:\n                        action_map[label, unit_pos[0], unit_pos[1]] = 1\n                        mask[:, unit_pos[0], unit_pos[1]] = 1\n                mask = mask.astype('bool')\n                action_map = action_map.astype('bool')\n                append((obs_id, action_map, mask))\n\n    return obses, samples","9a7a8064":"episode_dir = '..\/input\/simulations-episode-scraper-match-downloader\/'\nobses, samples = create_dataset_from_json_ctile(episode_dir)\nprint('obses:', len(obses), 'samples:', len(samples))","2e78e879":"# Input for Neural Network \n# Feature map size [14,32,32] and global features size [14,4,4]\ndef make_input(obs):\n    width, height = obs['width'], obs['height']\n    x_shift = (32 - width) \/\/ 2\n    y_shift = (32 - height) \/\/ 2\n    cities = {}\n    global_features = np.zeros((14,4,4))\n    \n    b = np.zeros((14, 32, 32), dtype=np.float32)\n    \n    friendly_unit_cnt = 0\n    opponent_unit_cnt = 0\n    friendly_ctile_cnt = 0\n    opponent_ctile_cnt = 0\n    total_wood = 0\n    total_coal = 0\n    total_uranium = 0\n    \n    can_mine_coal = 0\n    can_mine_uranium = 0\n    \n    for update in obs['updates']:\n        strs = update.split(' ')\n        input_identifier = strs[0]\n        \n        if input_identifier == 'u':\n            \n            x = int(strs[4]) + x_shift\n            y = int(strs[5]) + y_shift\n            wood = int(strs[7])\n            coal = int(strs[8])\n            uranium = int(strs[9])\n            \n            # Units\n            team = int(strs[2])\n            \n            if (team - obs['player']) % 2 == 0:\n                friendly_unit_cnt += 1\n            else:\n                opponent_unit_cnt += 1\n            \n            cooldown = float(strs[6])\n            idx = (team - obs['player']) % 2 * 3\n            b[idx:idx + 3, x, y] = (\n                1,\n                cooldown \/ 6,\n                (wood + coal + uranium) \/ 100\n            )\n        elif input_identifier == 'ct':\n            # CityTiles\n            \n            team = int(strs[1])\n            \n            if (team - obs['player']) % 2 == 0:\n                friendly_ctile_cnt += 1\n            else:\n                opponent_ctile_cnt += 1\n            \n            city_id = strs[2]\n            x = int(strs[3]) + x_shift\n            y = int(strs[4]) + y_shift\n            idx = 6 + (team - obs['player']) % 2 * 2\n            b[idx:idx + 2, x, y] = (\n                1,\n                cities[city_id]\n            )\n        elif input_identifier == 'r':\n            # Resources\n            r_type = strs[1]\n            x = int(strs[2]) + x_shift\n            y = int(strs[3]) + y_shift\n            amt = int(float(strs[4]))\n            b[{'wood': 10, 'coal': 11, 'uranium': 12}[r_type], x, y] = amt \/ 800\n            if r_type == 'wood': total_wood += amt\n            elif r_type == 'coal': total_coal += amt\n            elif r_type == 'uranium': total_uranium += amt\n            \n        elif input_identifier == 'rp':\n            # Research Points\n            team = int(strs[1])\n            rp = int(strs[2])\n            if team - obs['player'] % 2 == 0:\n                if rp >= 50:\n                    can_mine_coal = 1\n                if rp >= 200:\n                    can_mine_uranium = 1\n            \n            global_features[(team - obs['player']) % 2, :] = min(rp, 200) \/ 200\n        elif input_identifier == 'c':\n            # Cities\n            city_id = strs[2]\n            fuel = float(strs[3])\n            lightupkeep = float(strs[4])\n            cities[city_id] = min(fuel \/ lightupkeep, 10) \/ 10\n    \n    # Day\/Night Cycle\n    global_features[2, :] = obs['step'] % 40 \/ 40\n    # Turns\n    global_features[3, :] = obs['step'] \/ 360\n    # Number of friendly unit \n    global_features[4, :] = friendly_unit_cnt \/ 50\n    # Number of opponent unit\n    global_features[5, :] = opponent_unit_cnt \/ 50\n    # Number of friendly ctiles\n    global_features[6, :] = friendly_ctile_cnt \/ 50\n    # Number of opponent unit\n    global_features[7, :] = opponent_ctile_cnt \/ 50\n    # Total Wood\n    global_features[8, :] = total_wood \/ 24000\n    # Total Coal\n    global_features[9, :] = total_coal \/ 24000\n    # Total Uranium\n    global_features[10, :] = total_uranium \/ 12000\n    global_features[11, :] = can_mine_coal\n    global_features[12, :] = can_mine_uranium\n    # Map Size\n    global_features[13, :] = width \n    \n    # Map Size\n    b[13, x_shift:32 - x_shift, y_shift:32 - y_shift] = 1\n\n    return b, global_features\n\n\nclass LuxDataset(Dataset):\n    def __init__(self, obses, samples):\n        self.obses = obses\n        self.samples = samples\n        \n    def __len__(self):\n        return len(self.samples)\n\n    def __getitem__(self, idx):\n        obs_id, action_map, mask = self.samples[idx]\n        obs = self.obses[obs_id]\n        state_1, state_2 = make_input(obs)\n        \n        return state_1, state_2, action_map, mask","cbba3ea4":"# copied from https:\/\/github.com\/milesial\/Pytorch-UNet\/blob\/master\/unet\/unet_parts.py\n\n\"\"\" Parts of the U-Net model \"\"\"\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass DoubleConv(nn.Module):\n    \"\"\"(convolution => [BN] => ReLU) * 2\"\"\"\n\n    def __init__(self, in_channels, out_channels, mid_channels=None):\n        super().__init__()\n        if not mid_channels:\n            mid_channels = out_channels\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, mid_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(mid_channels),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(mid_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            nn.ReLU(inplace=True)\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\n\nclass Down(nn.Module):\n    \"\"\"Downscaling with maxpool then double conv\"\"\"\n\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.maxpool_conv = nn.Sequential(\n            nn.MaxPool2d(2),\n            DoubleConv(in_channels, out_channels)\n        )\n\n    def forward(self, x):\n        return self.maxpool_conv(x)\n\n\nclass Up(nn.Module):\n    \"\"\"Upscaling then double conv\"\"\"\n\n    def __init__(self, in_channels, out_channels, bilinear=True):\n        super().__init__()\n\n        # if bilinear, use the normal convolutions to reduce the number of channels\n        if bilinear:\n            self.up = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)\n            self.conv = DoubleConv(in_channels, out_channels, in_channels \/\/ 2)\n        else:\n            self.up = nn.ConvTranspose2d(in_channels, in_channels \/\/ 2, kernel_size=2, stride=2)\n            self.conv = DoubleConv(in_channels, out_channels)\n\n    def forward(self, x1, x2):\n        x1 = self.up(x1)\n        # input is CHW\n        diffY = x2.size()[2] - x1.size()[2]\n        diffX = x2.size()[3] - x1.size()[3]\n\n        x1 = F.pad(x1, [diffX \/\/ 2, diffX - diffX \/\/ 2,\n                        diffY \/\/ 2, diffY - diffY \/\/ 2])\n        # if you have padding issues, see\n        # https:\/\/github.com\/HaiyongJiang\/U-Net-Pytorch-Unstructured-Buggy\/commit\/0e854509c2cea854e247a9c615f175f76fbb2e3a\n        # https:\/\/github.com\/xiaopeng-liao\/Pytorch-UNet\/commit\/8ebac70e633bac59fc22bb5195e513d5832fb3bd\n        x = torch.cat([x2, x1], dim=1)\n        return self.conv(x)\n\n\nclass OutConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super(OutConv, self).__init__()\n        self.conv = nn.Conv2d(in_channels, out_channels, kernel_size=1)\n\n    def forward(self, x):\n        return self.conv(x)","2449b039":"class UNet(nn.Module):\n    def __init__(self, n_channels, n_classes, n_channels_b, bilinear=True):\n        super(UNet, self).__init__()\n        self.n_channels = n_channels\n        self.n_classes = n_classes\n        self.bilinear = bilinear\n        \n        self.inc = DoubleConv(n_channels, 64)\n        self.down1 = Down(64,128)\n        self.down2 = Down(128,256)\n#         self.down3 = Down(256,512)\n        \n        factor = 2 if bilinear else 1\n        self.down3 = Down(256, 512\/\/factor)\n        self.up1 = Up(512 + n_channels_b, 256, bilinear)\n        self.up2 = Up(256+128, 128, bilinear)\n        self.up3 = Up(128+64, 64, bilinear)\n#         self.up4 = Up(128, 64, bilinear)\n        self.outc = OutConv(64, n_classes)\n        \n    def forward(self, x, x_features):\n        x1 = self.inc(x)\n        x2 = self.down1(x1)\n        x3 = self.down2(x2)\n        x4 = self.down3(x3)\n        #print(x4.size())\n        x = torch.cat((x4, x_features),1)\n        #print(x.size())\n        x = self.up1(x,x3)\n        #print(x.size())\n        x = self.up2(x,x2)\n        x = self.up3(x,x1)\n        logits = self.outc(x)\n        \n        return logits","4f531c2d":"def train_model(model, dataloaders_dict, optimizer, num_epochs):\n    \n    for epoch in range(num_epochs):\n        model.cuda()\n        \n        for phase in ['train', 'val']:\n            if phase == 'train':\n                model.train()\n            else:\n                model.eval()\n                \n            epoch_loss = 0.0\n            \n            dataloader = dataloaders_dict[phase]\n            for item in tqdm(dataloader, leave=False):\n                states_1 = item[0].cuda().float()\n                states_2 = item[1].cuda().float()\n                actions = item[2].cuda().float()\n                mask = item[3].cuda().float()\n                \n                optimizer.zero_grad()\n                criterion = nn.BCEWithLogitsLoss(weight=mask)\n                \n                with torch.set_grad_enabled(phase == 'train'):\n                    policy = model(states_1, states_2)\n                    loss = criterion(policy, actions)\n                    _, preds = torch.max(policy, 1)\n\n                    if phase == 'train':\n                        loss.backward()\n                        optimizer.step()\n                    \n                    epoch_loss += loss.item() * len(policy) * mask[mask==0].size()[0]\/mask[mask==1].size()[0]\n\n\n            data_size = len(dataloader.dataset)\n            epoch_loss = epoch_loss \/ data_size\n\n            print(f'Epoch {epoch + 1}\/{num_epochs} | {phase:^5} | Loss: {epoch_loss:.4f}')\n        ","1dd73645":"model = UNet(14, 2, 14)\ntrain, val = train_test_split(samples, test_size = 0.1, random_state = 42)\nbatch_size = 256\ntrain_loader = DataLoader(\n    LuxDataset(obses, train),\n    batch_size=batch_size,\n    shuffle=True,\n    num_workers=2\n)\nval_loader = DataLoader(\n    LuxDataset(obses, val),\n    batch_size=batch_size,\n    shuffle=False,\n    num_workers=2\n)\ndataloaders_dict = {\"train\": train_loader, \"val\": val_loader}\n#criterion = nn.BCEWithLogitsLoss()\n#optimizer = torch.optim.AdamW(model.parameters(), lr=1e-3)","e04b715a":"# model = torch.jit.load(f'..\/input\/luxai-models\/submission_unet_with_ctile\/model_ct.pth')","6407cc64":"optimizer = torch.optim.AdamW(model.parameters(), lr=1e-3)\ntrain_model(model, dataloaders_dict, optimizer, num_epochs=5)\noptimizer = torch.optim.AdamW(model.parameters(), lr=1e-4)\ntrain_model(model, dataloaders_dict, optimizer, num_epochs=5)\noptimizer = torch.optim.AdamW(model.parameters(), lr=1e-5)\ntrain_model(model, dataloaders_dict, optimizer, num_epochs=2)","3af54962":"traced = torch.jit.trace(model.cpu(), (torch.rand(1, 14, 32, 32), torch.rand(1,14,4,4)))\ntraced.save('model_ct.pth')","0898421c":"model = torch.jit.load(f'..\/input\/luxai-models\/submission_unet_v6_updated\/model.pth')\ntraced = torch.jit.trace(model.cpu(), (torch.rand(1, 14, 32, 32), torch.rand(1,14,4,4)))\ntraced.save('model.pth')","1f7348d8":"%%writefile agent.py\nimport os\nimport numpy as np\nimport torch\nfrom lux.game import Game\n\npath = '\/kaggle_simulations\/agent' if os.path.exists('\/kaggle_simulations') else '.'\n#path = '..\/input\/luxai-unet-immitationlearning\/'\nmodel = torch.jit.load(f'{path}\/model.pth')\nmodel.eval()\n\nmodel_ct = torch.jit.load(f'{path}\/model_ct.pth')\nmodel_ct.eval()\n\n# Input for Neural Network \n# Feature map size [14,32,32] and global features size [4,4,4]\ndef make_input(obs):\n    width, height = obs['width'], obs['height']\n    x_shift = (32 - width) \/\/ 2\n    y_shift = (32 - height) \/\/ 2\n    cities = {}\n    global_features = np.zeros((14,4,4))\n    \n    b = np.zeros((14, 32, 32), dtype=np.float32)\n    \n    friendly_unit_cnt = 0\n    opponent_unit_cnt = 0\n    friendly_ctile_cnt = 0\n    opponent_ctile_cnt = 0\n    total_wood = 0\n    total_coal = 0\n    total_uranium = 0\n    \n    can_mine_coal = 0\n    can_mine_uranium = 0\n    \n    for update in obs['updates']:\n        strs = update.split(' ')\n        input_identifier = strs[0]\n        \n        if input_identifier == 'u':\n            \n            x = int(strs[4]) + x_shift\n            y = int(strs[5]) + y_shift\n            wood = int(strs[7])\n            coal = int(strs[8])\n            uranium = int(strs[9])\n            \n            # Units\n            team = int(strs[2])\n            \n            if (team - obs['player']) % 2 == 0:\n                friendly_unit_cnt += 1\n            else:\n                opponent_unit_cnt += 1\n            \n            cooldown = float(strs[6])\n            idx = (team - obs['player']) % 2 * 3\n            b[idx:idx + 3, x, y] = (\n                1,\n                cooldown \/ 6,\n                (wood + coal + uranium) \/ 100\n            )\n        elif input_identifier == 'ct':\n            # CityTiles\n            \n            team = int(strs[1])\n            \n            if (team - obs['player']) % 2 == 0:\n                friendly_ctile_cnt += 1\n            else:\n                opponent_ctile_cnt += 1\n            \n            city_id = strs[2]\n            x = int(strs[3]) + x_shift\n            y = int(strs[4]) + y_shift\n            idx = 6 + (team - obs['player']) % 2 * 2\n            b[idx:idx + 2, x, y] = (\n                1,\n                cities[city_id]\n            )\n        elif input_identifier == 'r':\n            # Resources\n            r_type = strs[1]\n            x = int(strs[2]) + x_shift\n            y = int(strs[3]) + y_shift\n            amt = int(float(strs[4]))\n            b[{'wood': 10, 'coal': 11, 'uranium': 12}[r_type], x, y] = amt \/ 800\n            if r_type == 'wood': total_wood += amt\n            elif r_type == 'coal': total_coal += amt\n            elif r_type == 'uranium': total_uranium += amt\n            \n        elif input_identifier == 'rp':\n            # Research Points\n            team = int(strs[1])\n            rp = int(strs[2])\n            if team - obs['player'] % 2 == 0:\n                if rp >= 50:\n                    can_mine_coal = 1\n                if rp >= 200:\n                    can_mine_uranium = 1\n            \n            global_features[(team - obs['player']) % 2, :] = min(rp, 200) \/ 200\n        elif input_identifier == 'c':\n            # Cities\n            city_id = strs[2]\n            fuel = float(strs[3])\n            lightupkeep = float(strs[4])\n            cities[city_id] = min(fuel \/ lightupkeep, 10) \/ 10\n    \n    # Day\/Night Cycle\n    global_features[2, :] = obs['step'] % 40 \/ 40\n    # Turns\n    global_features[3, :] = obs['step'] \/ 360\n    # Number of friendly unit \n    global_features[4, :] = friendly_unit_cnt \/ 50\n    # Number of opponent unit\n    global_features[5, :] = opponent_unit_cnt \/ 50\n    # Number of friendly ctiles\n    global_features[6, :] = friendly_ctile_cnt \/ 50\n    # Number of opponent unit\n    global_features[7, :] = opponent_ctile_cnt \/ 50\n    # Total Wood\n    global_features[8, :] = total_wood \/ 24000\n    # Total Coal\n    global_features[9, :] = total_coal \/ 24000\n    # Total Uranium\n    global_features[10, :] = total_uranium \/ 12000\n    global_features[11, :] = can_mine_coal\n    global_features[12, :] = can_mine_uranium\n    # Map Size\n    global_features[13, :] = width \n    \n    # Map Size\n    b[13, x_shift:32 - x_shift, y_shift:32 - y_shift] = 1\n\n    return b, global_features\n\n\ngame_state = None\ndef get_game_state(observation):\n    global game_state\n    \n    if observation[\"step\"] == 0:\n        game_state = Game()\n        game_state._initialize(observation[\"updates\"])\n        game_state._update(observation[\"updates\"][2:])\n        game_state.id = observation[\"player\"]\n    else:\n        game_state._update(observation[\"updates\"])\n    return game_state\n\ndef get_shift(observation):\n    width, height = observation['width'], observation['height']\n    shift = (32 - width) \/\/ 2\n    return shift\n\ndef in_city(pos):    \n    try:\n        city = game_state.map.get_cell_by_pos(pos).citytile\n        return city is not None and city.team == game_state.id\n    except:\n        return False\n\n\ndef call_func(obj, method, args=[]):\n    return getattr(obj, method)(*args)\n\n\nunit_actions = [('move', 'n'), ('move', 's'), ('move', 'w'), ('move', 'e'), ('build_city',)]\ndef get_action(policy, unit, dest, shift):\n    action = unit_actions[ np.argmax( policy[:, unit.pos.x + shift, unit.pos.y + shift] )]\n    pos = unit.pos.translate(action[-1], 1) or unit.pos\n    if pos not in dest or in_city(pos):\n        return call_func(unit, *action), pos\n    \n    return unit.move('c'), unit.pos\n\n\ndef agent(observation, configuration):\n    global game_state\n    game_state = get_game_state(observation)    \n    shift = get_shift(observation)\n    player = game_state.players[observation.player]\n    actions = []\n    \n    state_1, state_2 = make_input(observation)\n    with torch.no_grad():\n        p_ct = model_ct(torch.from_numpy(state_1).unsqueeze(0).float(), torch.from_numpy(state_2).unsqueeze(0).float())\n        policy_ct = p_ct.squeeze(0).numpy()\n        \n    # City Actions\n    unit_count = len(player.units)\n    for city in player.cities.values():\n        for city_tile in city.citytiles:\n            if city_tile.can_act():\n                action = np.argmax( policy_ct[:, city_tile.pos.x + shift, city_tile.pos.y + shift] )\n                if action == 0:\n                    actions.append(city_tile.research())\n                    player.research_points += 1\n                elif action == 1:\n                    actions.append(city_tile.build_worker())\n                    unit_count += 1\n#                 if unit_count < player.city_tile_count: \n#                     actions.append(city_tile.build_worker())\n#                     unit_count += 1\n#                 elif not player.researched_uranium():\n#                     actions.append(city_tile.research())\n#                     player.research_points += 1\n    \n    # Worker Actions\n    state_1, state_2 = make_input(observation)\n    dest = []\n    with torch.no_grad():\n        p = model(torch.from_numpy(state_1).unsqueeze(0).float(), torch.from_numpy(state_2).unsqueeze(0).float())\n        policy = p.squeeze(0).numpy()\n    for unit in player.units:\n        if unit.can_act() and (game_state.turn % 40 < 30 or not in_city(unit.pos)):\n            action, pos = get_action(policy, unit, dest, shift)\n            actions.append(action)\n            dest.append(pos)\n\n    return actions","f9edb41f":"from kaggle_environments import make\n\nenv = make(\"lux_ai_2021\", configuration={\"width\": 24, \"height\": 24, \"annotations\": True}, debug=True)\nsteps = env.run(['.\/agent.py', '.\/agent.py'])","216a79c9":"env.render(mode=\"ipython\", width=1200, height=800)","58abe45b":"!tar -czf submission.tar.gz *","a3e51b4d":"# Submission","eca88cda":"# UNet"}}