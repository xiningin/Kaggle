{"cell_type":{"7de33c99":"code","2878b6ae":"code","27cb1402":"code","87392c98":"code","aacce7a7":"markdown","d902f5b1":"markdown","93c11505":"markdown"},"source":{"7de33c99":"from keras.models import Sequential\nimport numpy as np\nfrom keras.layers.core import Dense, Dropout, Activation\nfrom keras.layers import Conv2D, MaxPooling2D, Flatten\nfrom keras.optimizers import SGD, Adam\nfrom keras.utils import np_utils\n#from keras.datasets import mnist\nimport pandas as pd","2878b6ae":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","27cb1402":"def load_data():\n    train = pd.read_csv('\/kaggle\/input\/digit-recognizer\/train.csv')\n    test = pd.read_csv('\/kaggle\/input\/digit-recognizer\/test.csv').values\n\n    x_train = train.iloc[:,1:].values.astype('float32')\n\n    # y_train is the label for each of x_train data\n    y_train = train.iloc[:,0].values.astype('float32')\n\n    x_test = test.astype('float32')\n\n    # our training data are the images that need to be transfromed as numpy array (two-dimension matrix)\n    # each of (28* 28) image will be saved as a vector that only has one row \n    # the number of rows of training data depends on how many data we have\n    # the number of columns of training data depends on the dimension of the image (in this case are 28 * 28 = 784)\n    x_train = x_train.reshape(x_train.shape[0], 28 * 28)\n    x_test = x_test.reshape(x_test.shape[0], 28 * 28)\n\n    # convert class vectors to binary class matrices \n    y_train = np_utils.to_categorical(y_train,10)\n    x_train = x_train\n    x_test = x_test\n\n    # add some noises\n    x_test = np.random.normal(x_test) \n\n    # the inputs need to be divided by 255 since they are image pixel so as to ensure the value is between 0 ~ 1\n    x_train = x_train \/ 255\n    x_test = x_test \/ 255 \n    \n    return x_train, y_train, x_test","87392c98":"if __name__ == '__main__':\n    # load training data and testing data\n    x_train, y_train, x_test = load_data()\n    # input channels: x_train.shape[0]\n    x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)\n    x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)\n\n    model = Sequential()\n    model.add(Conv2D(100, (3, 3), input_shape = (28, 28, 1)))\n    model.add(MaxPooling2D((2, 2)))\n    model.add(Dropout(0.5))\n\n    model.add(Conv2D(100, (3, 3)))\n    model.add(MaxPooling2D((2, 2)))\n    model.add(Dropout(0.5))\n\n    model.add(Flatten())\n    model.add(Dense(units = 200, activation = 'relu'))\n    model.add(Dense(units = 10, activation='softmax'))\n    model.summary()\n\n    model.compile(loss = 'categorical_crossentropy', optimizer = 'adam', metrics = ['accuracy'])\n\n    model.fit(x_train, y_train, batch_size = 100, epochs = 30)\n\n    result_train = model.evaluate(x_train, y_train)\n    pred_result = model.predict_classes(x_test,verbose=0)\n\n    submission = pd.DataFrame({'ImageId': list(range(1,len(pred_result)+1)), 'Label': pred_result}).to_csv('Digit Recognizer.csv', index=False, header=True)\n    print('Training Accuracy:',result_train[1])\n","aacce7a7":"# 1. Load data","d902f5b1":"# 2. Preprocess","93c11505":"# 3. Model Building"}}