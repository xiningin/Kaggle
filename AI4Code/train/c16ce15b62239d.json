{"cell_type":{"bc21a20b":"code","dd0487ae":"code","ecdf6b6f":"code","bbb70912":"code","51ece833":"code","8d67f6b5":"code","5d95db7e":"code","f1e2e5ee":"code","d604710f":"code","ef5de9d1":"code","c4abbca6":"code","e846ba74":"code","4bde9188":"code","a9e344e1":"code","6c8d7e4f":"code","d5361630":"code","e2f60f9f":"code","d48d7e90":"code","3ca5022e":"code","dffd5f23":"code","05ece4ee":"code","c9ffb3b9":"code","fee3ff90":"code","8ab599c1":"code","5b10c885":"code","0fd2006d":"code","49d2e9d5":"code","4de80690":"code","b5618275":"code","40afa1dd":"code","77e3aa32":"code","4854462d":"code","8919b746":"code","ec84dd38":"code","21aae29e":"code","a0581a0c":"code","910bcdc8":"code","75a258c5":"code","0a62c430":"code","69d5c39c":"code","3e647c89":"code","67e0bec8":"code","937f5b4d":"code","488330b9":"code","997723f2":"code","9cf374e7":"code","91d474e7":"code","4ca9f8d1":"code","e2a69935":"code","867b2b36":"code","0d985476":"code","dae70584":"code","028391d5":"code","50378161":"code","6b61acf4":"code","9fc511e6":"code","310ca8e5":"code","14016ca9":"code","8388ffaa":"code","1667c9e2":"code","b4f430c6":"code","11049971":"code","01c35123":"code","420fe825":"code","07e0778e":"code","52cecede":"code","d9f5f0d3":"code","0385b87d":"code","5443032d":"code","18fe3181":"code","e3824aa2":"code","06dcb3e7":"code","7e59830a":"code","54e29de1":"code","cf32e079":"code","3a373fa5":"code","3ee9fa1e":"code","6ccccdb7":"code","f900e0c1":"code","7e77728b":"code","27e17a66":"code","4ef9589c":"code","629131da":"code","4754fba8":"code","3dc458ce":"code","dcdde90d":"code","de53ef0b":"code","29e74f0a":"code","e53f604f":"code","8e8bd7b1":"code","9e14d7b2":"code","2efd2fb9":"code","2a7451f9":"code","549943a3":"code","0aa2daca":"code","bc5c7ea8":"code","8497ed5f":"code","6008cdcc":"code","17df87c2":"code","46e2a1cd":"code","33936056":"code","8ab816f7":"code","a98ef44d":"code","5324d013":"code","97b6bffc":"code","005d3a85":"code","b26d4b2c":"code","a728a1a2":"code","966e4a6b":"code","5088e749":"code","2babb3b2":"code","489bc5a1":"code","e260e4a7":"code","afde1d05":"code","4f3b7564":"code","d89e69ef":"code","a2b5b87f":"code","d617695e":"code","3f9e563b":"code","4b4695b3":"code","156dee03":"code","bf6dfed3":"code","cf049240":"code","12a3745a":"code","9ef06cfb":"code","e1f9fb20":"code","f795c02e":"code","294131a4":"code","ffb792aa":"code","9470345b":"code","8ef34fe9":"code","3425b2ee":"code","725eebca":"code","2ccd5393":"code","b9b9ef3c":"code","644464fd":"code","37839b6d":"code","036c69d6":"code","308b51a8":"code","752bdf8d":"code","496824bb":"code","94c18817":"markdown","bcdec3cc":"markdown","40f77095":"markdown","dc085d01":"markdown","4de17b7e":"markdown","16395ee7":"markdown","fa4430f6":"markdown","b55bcb12":"markdown","7246eb64":"markdown","fb8dcb60":"markdown","829237e3":"markdown","85d4562b":"markdown","8e5f0ff0":"markdown","87f1ad9a":"markdown","24a4f75f":"markdown","52f5cbd6":"markdown","d2969b74":"markdown","6fca917b":"markdown","2552bc71":"markdown","8bf531cd":"markdown","9410265e":"markdown","8a924005":"markdown","940928ac":"markdown","809f2ed4":"markdown","c07d4d97":"markdown","381d3e7d":"markdown","1a65b374":"markdown","a857e9d5":"markdown","cb633fee":"markdown","812ab362":"markdown","f00f246c":"markdown","372363f1":"markdown","7c2dbd2d":"markdown","0b8f5c28":"markdown","f5798e00":"markdown","72ba22cf":"markdown","d35f4d4e":"markdown","3bf90b9f":"markdown","357bf2b8":"markdown","4f1062ae":"markdown","9074b12b":"markdown","33d15162":"markdown","359da332":"markdown","269aaae1":"markdown","261fb197":"markdown","c5a6c8c9":"markdown"},"source":{"bc21a20b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nfrom subprocess import check_output\nprint(check_output([\"ls\", \"..\/input\"]).decode(\"utf8\"))\n\n# Any results you write to the current directory are saved as output.","dd0487ae":"import pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns","ecdf6b6f":"data = pd.read_csv(\"..\/input\/mushrooms.csv\")\ndata.head(6)","bbb70912":"data.isnull().sum()","51ece833":"data['class'].unique()","8d67f6b5":"data.shape","5d95db7e":"from sklearn.preprocessing import LabelEncoder\nlabelencoder=LabelEncoder()\nfor col in data.columns:\n    data[col] = labelencoder.fit_transform(data[col])\n \ndata.head()","f1e2e5ee":"data['stalk-color-above-ring'].unique()","d604710f":"print(data.groupby('class').size())","ef5de9d1":"'''\n# Create a figure instance\nfig, axes = plt.subplots(nrows=2 ,ncols=2 ,figsize=(9, 9))\n\n# Create an axes instance and the boxplot\nbp1 = axes[0,0].boxplot(data['stalk-color-above-ring'],patch_artist=True)\n\nbp2 = axes[0,1].boxplot(data['stalk-color-below-ring'],patch_artist=True)\n\nbp3 = axes[1,0].boxplot(data['stalk-surface-below-ring'],patch_artist=True)\n\nbp4 = axes[1,1].boxplot(data['stalk-surface-above-ring'],patch_artist=True)\n'''\nax = sns.boxplot(x='class', y='stalk-color-above-ring', \n                data=data)\nax = sns.stripplot(x=\"class\", y='stalk-color-above-ring',\n                   data=data, jitter=True,\n                   edgecolor=\"gray\")\nsns.plt.title(\"Class w.r.t stalkcolor above ring\",fontsize=12)","c4abbca6":"X = data.iloc[:,1:23]  # all rows, all the features and no labels\ny = data.iloc[:, 0]  # all rows, label only\nX.head()\ny.head()","e846ba74":"X.describe()","4bde9188":"y.head()","a9e344e1":"data.corr()","6c8d7e4f":"# Scale the data to be between -1 and 1\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nX=scaler.fit_transform(X)\nX","d5361630":"from sklearn.decomposition import PCA\npca = PCA()\npca.fit_transform(X)","e2f60f9f":"covariance=pca.get_covariance()\n#covariance","d48d7e90":"explained_variance=pca.explained_variance_\nexplained_variance","3ca5022e":"with plt.style.context('dark_background'):\n    plt.figure(figsize=(6, 4))\n    \n    plt.bar(range(22), explained_variance, alpha=0.5, align='center',\n            label='individual explained variance')\n    plt.ylabel('Explained variance ratio')\n    plt.xlabel('Principal components')\n    plt.legend(loc='best')\n    plt.tight_layout()","dffd5f23":"N=data.values\npca = PCA(n_components=2)\nx = pca.fit_transform(N)\nplt.figure(figsize = (5,5))\nplt.scatter(x[:,0],x[:,1])\nplt.show()","05ece4ee":"from sklearn.cluster import KMeans\nkmeans = KMeans(n_clusters=2, random_state=5)\nX_clustered = kmeans.fit_predict(N)\n\nLABEL_COLOR_MAP = {0 : 'g',\n                   1 : 'y'\n                  }\n\nlabel_color = [LABEL_COLOR_MAP[l] for l in X_clustered]\nplt.figure(figsize = (5,5))\nplt.scatter(x[:,0],x[:,1], c= label_color)\nplt.show()","c9ffb3b9":"pca_modified=PCA(n_components=17)\npca_modified.fit_transform(X)","fee3ff90":"from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=4)","8ab599c1":"from sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn import metrics\n\nmodel_LR= LogisticRegression()","5b10c885":"model_LR.fit(X_train,y_train)","0fd2006d":"y_prob = model_LR.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nmodel_LR.score(X_test, y_pred)","49d2e9d5":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","4de80690":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","b5618275":"from sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nroc_auc","40afa1dd":"import matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","77e3aa32":"from sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn import metrics\n\nLR_model= LogisticRegression()\n\ntuned_parameters = {'C': [0.001, 0.01, 0.1, 1, 10, 100, 1000] ,\n              'penalty':['l1','l2']\n                   }","4854462d":"data.corr()","8919b746":"from sklearn.model_selection import GridSearchCV\n\nLR= GridSearchCV(LR_model, tuned_parameters,cv=10)","ec84dd38":"LR.fit(X_train,y_train)","21aae29e":"print(LR.best_params_)","a0581a0c":"y_prob = LR.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nLR.score(X_test, y_pred)","910bcdc8":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","75a258c5":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","0a62c430":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","69d5c39c":"from sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nroc_auc","3e647c89":"\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","67e0bec8":"LR_ridge= LogisticRegression(penalty='l2')\nLR_ridge.fit(X_train,y_train)","937f5b4d":"y_prob = LR_ridge.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nLR_ridge.score(X_test, y_pred)","488330b9":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","997723f2":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","9cf374e7":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","91d474e7":"\nfrom sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nroc_auc","4ca9f8d1":"\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","e2a69935":"from sklearn.naive_bayes import GaussianNB\nmodel_naive = GaussianNB()\nmodel_naive.fit(X_train, y_train)","867b2b36":"y_prob = model_naive.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nmodel_naive.score(X_test, y_pred)","0d985476":"print(\"Number of mislabeled points from %d points : %d\"\n      % (X_test.shape[0],(y_test!= y_pred).sum()))","dae70584":"scores = cross_val_score(model_naive, X, y, cv=10, scoring='accuracy')\nprint(scores)","028391d5":"scores.mean()","50378161":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","6b61acf4":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","9fc511e6":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","310ca8e5":"from sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nroc_auc","14016ca9":"import matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","8388ffaa":"from sklearn.svm import SVC\nsvm_model= SVC()","1667c9e2":"tuned_parameters = {\n 'C': [1, 10, 100,500, 1000], 'kernel': ['linear','rbf'],\n 'C': [1, 10, 100,500, 1000], 'gamma': [1,0.1,0.01,0.001, 0.0001], 'kernel': ['rbf'],\n #'degree': [2,3,4,5,6] , 'C':[1,10,100,500,1000] , 'kernel':['poly']\n    }","b4f430c6":"from sklearn.grid_search import RandomizedSearchCV\n\nmodel_svm = RandomizedSearchCV(svm_model, tuned_parameters,cv=10,scoring='accuracy',n_iter=20)","11049971":"model_svm.fit(X_train, y_train)\nprint(model_svm.best_score_)","01c35123":"print(model_svm.grid_scores_)","420fe825":"print(model_svm.best_params_)","07e0778e":"\ny_pred= model_svm.predict(X_test)\nprint(metrics.accuracy_score(y_pred,y_test))","52cecede":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","d9f5f0d3":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","0385b87d":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","5443032d":"from sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_pred)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nroc_auc","18fe3181":"import matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","e3824aa2":"tuned_parameters = {\n 'C': [1, 10, 100,500, 1000], 'kernel': ['linear','rbf'],\n 'C': [1, 10, 100,500, 1000], 'gamma': [1,0.1,0.01,0.001, 0.0001], 'kernel': ['rbf'],\n 'degree': [2,3,4,5,6] , 'C':[1,10,100,500,1000] , 'kernel':['poly']\n    }","06dcb3e7":"from sklearn.grid_search import RandomizedSearchCV\n\nmodel_svm = RandomizedSearchCV(svm_model, tuned_parameters,cv=10,scoring='accuracy',n_iter=20)","7e59830a":"model_svm.fit(X_train, y_train)\nprint(model_svm.best_score_)","54e29de1":"print(model_svm.grid_scores_)","cf32e079":"print(model_svm.best_params_)","3a373fa5":"y_pred= model_svm.predict(X_test)\nprint(metrics.accuracy_score(y_pred,y_test))","3ee9fa1e":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","6ccccdb7":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","f900e0c1":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","7e77728b":"from sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_pred)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nroc_auc","27e17a66":"import matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","4ef9589c":"from sklearn.ensemble import RandomForestClassifier\n\nmodel_RR=RandomForestClassifier()\n\n#tuned_parameters = {'min_samples_leaf': range(5,10,5), 'n_estimators' : range(50,200,50),\n                    #'max_depth': range(5,15,5), 'max_features':range(5,20,5)\n                    #}\n               ","629131da":"model_RR.fit(X_train,y_train)","4754fba8":"y_prob = model_RR.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nmodel_RR.score(X_test, y_pred)","3dc458ce":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","dcdde90d":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","de53ef0b":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","29e74f0a":"from sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)","e53f604f":"import matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","8e8bd7b1":"from sklearn.ensemble import RandomForestClassifier\n\nmodel_RR=RandomForestClassifier()\n\ntuned_parameters = {'min_samples_leaf': range(10,100,10), 'n_estimators' : range(10,100,10),\n                    'max_features':['auto','sqrt','log2']\n                    }\n    ","9e14d7b2":"from sklearn.grid_search import RandomizedSearchCV\n\nRR_model= RandomizedSearchCV(model_RR, tuned_parameters,cv=10,scoring='accuracy',n_iter=20,n_jobs= -1)","2efd2fb9":"RR_model.fit(X_train,y_train)","2a7451f9":"print(RR_model.grid_scores_)","549943a3":"print(RR_model.best_score_)","0aa2daca":"print(RR_model.best_params_)","bc5c7ea8":"y_prob = RR_model.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nRR_model.score(X_test, y_pred)","8497ed5f":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","6008cdcc":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","17df87c2":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","46e2a1cd":"\nfrom sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nroc_auc","33936056":"import matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","8ab816f7":"from sklearn.tree import DecisionTreeClassifier\n\nmodel_tree = DecisionTreeClassifier()","a98ef44d":"model_tree.fit(X_train, y_train)","5324d013":"y_prob = model_tree.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nmodel_tree.score(X_test, y_pred)","97b6bffc":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","005d3a85":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","b26d4b2c":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","a728a1a2":"from sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)","966e4a6b":"import matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","5088e749":"from sklearn.tree import DecisionTreeClassifier\n\nmodel_DD = DecisionTreeClassifier()\n\n\ntuned_parameters= {'criterion': ['gini','entropy'], 'max_features': [\"auto\",\"sqrt\",\"log2\"],\n                   'min_samples_leaf': range(1,100,1) , 'max_depth': range(1,50,1)\n                  }\n           ","2babb3b2":"from sklearn.grid_search import RandomizedSearchCV\nDD_model= RandomizedSearchCV(model_DD, tuned_parameters,cv=10,scoring='accuracy',n_iter=20,n_jobs= -1,random_state=5)","489bc5a1":"DD_model.fit(X_train, y_train)","e260e4a7":"print(DD_model.grid_scores_)","afde1d05":"print(DD_model.best_score_)","4f3b7564":"print(DD_model.best_params_)","d89e69ef":"y_prob = DD_model.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nDD_model.score(X_test, y_pred)","a2b5b87f":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","d617695e":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","3f9e563b":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","4b4695b3":"from sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nroc_auc","156dee03":"import matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","bf6dfed3":"from sklearn.neural_network import MLPClassifier","cf049240":"mlp = MLPClassifier()\nmlp.fit(X_train,y_train)","12a3745a":"y_prob = mlp.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nmlp.score(X_test, y_pred)","9ef06cfb":"confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\nconfusion_matrix","e1f9fb20":"auc_roc=metrics.classification_report(y_test,y_pred)\nauc_roc","f795c02e":"auc_roc=metrics.roc_auc_score(y_test,y_pred)\nauc_roc","294131a4":"from sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)\nroc_auc","ffb792aa":"import matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')","9470345b":"'''\nfrom sklearn.neural_network import MLPClassifier\n\nmlp = MLPClassifier()\n\ntuned_parameters={'hidden_layer_sizes': range(1,200,10) , 'activation': ['tanh','logistic','relu'],\n                  'alpha':[0.0001,0.001,0.01,0.1,1,10], 'max_iter': range(50,200,50)\n    \n}\n'''","8ef34fe9":"#from sklearn.grid_search import RandomizedSearchCV\n#model_mlp= RandomizedSearchCV(mlp_model, tuned_parameters,cv=10,scoring='accuracy',n_iter=5,n_jobs= -1,random_state=5)","3425b2ee":"#model_mlp.fit(X_train, y_train)","725eebca":"#print(model_mlp.grid_scores_)","2ccd5393":"#print(model_mlp.best_score_)","b9b9ef3c":"#print(model_mlp.best_params_)","644464fd":"'''\ny_prob = model_LR.predict_proba(X_test)[:,1] # This will give you positive class prediction probabilities  \ny_pred = np.where(y_prob > 0.5, 1, 0) # This will threshold the probabilities to give class predictions.\nmodel_LR.score(X_test, y_pred)\n'''","37839b6d":"#confusion_matrix=metrics.confusion_matrix(y_test,y_pred)\n#confusion_matrix","036c69d6":"#auc_roc=metrics.classification_report(y_test,y_pred)\n#auc_roc","308b51a8":"#auc_roc=metrics.roc_auc_score(y_test,y_pred)\n#auc_roc","752bdf8d":"'''\nfrom sklearn.metrics import roc_curve, auc\nfalse_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)\nroc_auc = auc(false_positive_rate, true_positive_rate)\n'''","496824bb":"'''\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(10,10))\nplt.title('Receiver Operating Characteristic')\nplt.plot(false_positive_rate,true_positive_rate, color='red',label = 'AUC = %0.2f' % roc_auc)\nplt.legend(loc = 'lower right')\nplt.plot([0, 1], [0, 1],linestyle='--')\nplt.axis('tight')\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')\n'''","94c18817":"### Reading the file ","bcdec3cc":"**B) n_estimators** : This is the number of trees you want to build before taking the maximum voting or averages of predictions. Higher number of trees give you better performance but makes your code slower. You should choose as high value as your processor can handle because this makes your predictions stronger and more stable.","40f77095":"**Thus we have two claasification. Either the mushroom is poisonous or edible**","dc085d01":"**C)min_sample_leaf**:  Leaf is the end node of a decision tree. A smaller leaf makes the model more prone to capturing noise in train data. Hence it is important to try different values to get good estimate.","4de17b7e":"### Let us take only first two principal components and visualise it using K-means clustering","16395ee7":"**There are 3 features which can be tuned to improve the performance of Random Forest**    \n\n**1) max_features 2) n_estimators  3) min_sample_leaf**","fa4430f6":"### Trying default model","b55bcb12":"### Tuning the hyperparameters of the neural network","7246eb64":"### Taking a look at the correlation ","fb8dcb60":"# Gaussian Naive Bayes","829237e3":"**We can see that the last 4 components has less amount of variance  of the data.The 1st 17 components retains more than 90% of the data.**","85d4562b":"# Logistic Regression(Tuned model)","8e5f0ff0":"### Plotting boxplot to see the distribution of the data","87f1ad9a":"## Neural Network","24a4f75f":"**Separating features and label**","52f5cbd6":"**L1 and L2 are regularization parameters.They're used to avoid overfiting.Both L1 and L2 regularization prevents overfitting by shrinking (imposing a penalty) on the coefficients.**  \n    **L1 is the first moment norm |x1-x2| (|w| for regularization case) that is simply the absolute d\u0131stance between two points where L2 is second moment norm corresponding to Eucledian Distance that is  |x1-x2|^2 (|w|^2 for regularization case).**     \n       **In simple words,L2 (Ridge) shrinks all the coefficient by the same proportions but eliminates none, while L1 (Lasso) can shrink some coefficients to zero, performing variable selection.\nIf all the features are correlated with the label, ridge outperforms lasso, as the coefficients are never zero in ridge. If only a subset of features are correlated with the label, lasso outperforms ridge as in lasso model some coefficient can be shrunken to zero.**","d2969b74":"### Let us check if there is any null values","6fca917b":"### Thus using K-means we are able segregate 2 classes well using the first two components with maximum variance.","2552bc71":"**Note**: We can avoid PCA here since the dataset is very small.","8bf531cd":"# Support Vector Machine","9410265e":"### Thus default decision tree model is giving us best accuracy score","8a924005":"I am  going to apply 6 Supervised machine learning models on the given dataset.The strategy is to apply default model first with no tuning of the hyperparameter and then tuned them with different hyperparameter values and then I'll plot ROC curve to select the best machine learning model.The models used are as follows:\n**1) Principal Component Analysis\n**2)Logistic Regression**\n **3)Gaussian Naive Bayes**\n  **4)Support Vector Machine**\n  **5)Random Forest Classifier** \n  **6)Decision trees**\n   **7)Simple neural network**","940928ac":"**1) hidden_layer_sizes**  : Number of hidden layers in the network.(default is 100).Large number may overfit the data.\n\n**2)activation**: Activation function for the hidden layer.\nA)\u2018logistic\u2019, the logistic sigmoid function, returns f(x) = 1 \/ (1 + exp(-x)).\nB)\u2018tanh\u2019, the hyperbolic tan function, returns f(x) = tanh(x).\nC)\u2018relu\u2019, the rectified linear unit function, returns f(x) = max(0, x)\n\n**3)alpha:** L2 penalty (regularization term) parameter.(default 0.0001)\n\n**4)max_iter:** Maximum number of iterations. The solver iterates until convergence (determined by \u2018tol\u2019) or this number of iterations.(default 200)","809f2ed4":"# Standardising the data","c07d4d97":"### Let us tuned the parameters of Random Forest just for the purpose of knowledge","381d3e7d":"# Support Vector machine with polynomial Kernel","1a65b374":" **A)max_features**: These are the maximum number of features Random Forest is allowed to try in individual tree.\n**1)Auto** : This will simply take all the features which make sense in every tree.Here we simply do not put any restrictions on the individual tree.\n**2)sqrt** : This option will take square root of the total number of features in individual run. For instance, if the total number of variables are 100, we can only take 10 of them in individual tree.\n**3)log2**:It  is another option which takes log to the base 2 of the features input.\n\n**Increasing max_features generally improves the performance of the model as at each node now we have a higher number of options to be considered.But, for sure, you decrease the speed of algorithm by increasing the max_features. Hence, you need to strike the right balance and choose the optimal max_features.**","a857e9d5":"# Default Logistic Regression","cb633fee":"### Thus default Random forest model is giving us best accuracy.","812ab362":"**1)Criterion:** Decision trees use multiple algorithms to decide to split a node in two or more sub-nodes.Decision tree splits the nodes on all available variables and then selects the split which results in most homogeneous sub-nodes. The details of Gini and entropy needs detail explanation.\n\n2)**max_depth(Maximum depth of tree (vertical depth)):**\nUsed to control over-fitting as higher depth will allow model to learn relations very specific to a particular sample.\n\n**max_features** and **min_samples_leaf** is same as Random Forest classifier","f00f246c":"**The grid search provided by GridSearchCV exhaustively generates candidates from a grid of parameter values specified with the tuned_parameter.The GridSearchCV instance implements the usual estimator API: when \u201cfitting\u201d it on a dataset all the possible combinations of parameter values are evaluated and the best combination is retained.**","372363f1":"# Support Vector Machine without polynomial kernel","7c2dbd2d":"It is turning out to be computationally expensive for me with tuned model. Hence I am not running this. Also any suggestion to improvise it is welcome. :)","0b8f5c28":"### Checking the encoded values","f5798e00":"### Default Decision Tree model","72ba22cf":"###  Importing all the libraries","d35f4d4e":"The **gamma** parameter defines how far the influence of a single training example reaches, with low values meaning \u2018far\u2019 and high values meaning \u2018close\u2019. The **gamma** parameters can be seen as the inverse of the radius of influence of samples selected by the model as support vectors.\n\nThe **C** parameter trades off misclassification of training examples against simplicity of the decision surface. A low **C** makes the decision surface smooth, while a high **C** aims at classifying all training examples correctly by giving the model freedom to select more samples as support vectors.","3bf90b9f":"### Splitting the data into training and testing dataset","357bf2b8":"The grid search provided by GridSearchCV exhaustively generates candidates from a grid of parameter values specified with the tuned_parameter**.The GridSearchCV instance implements the usual estimator API: when \u201cfitting\u201d it on a dataset all the possible combinations of parameter values are evaluated and the best combination is retained.\nBut it is proving computationally expensive here.So I am opting for RandomizedSearchCV.\n\nRandomizedSearchCV implements a randomized search over parameters, where each setting is sampled from a distribution over possible parameter values. This has two main benefits over an exhaustive search:\n1)A budget can be chosen independent of the number of parameters and possible values.\n2)Adding parameters that do not influence the performance does not decrease efficiency.","4f1062ae":"# Principal Component Analysis","9074b12b":"### Let us tune the hyperparameters of the Decision tree model","33d15162":"**We can see that the dataset has values in strings.We need to convert all the unique values to integers. Thus we perform label encoding on the data.**","359da332":"**Thus we have 22 features(1st one is label)  and 8124 instances.Now let us check which features constitutes maximum information.** ","269aaae1":"# Performing PCA by taking 17 components with maximum Variance","261fb197":"### Applying default Neural Network model","c5a6c8c9":"### n_jobs\n**This parameter tells the engine how many processors is it allowed to use. A value of \u201c-1\u201d means there is no restriction whereas a value of \u201c1\u201d means it can only use one processor.**"}}