{"cell_type":{"e8521a86":"code","8004712a":"code","6346f0d3":"code","c48793f6":"code","10fba1cc":"code","b94388fa":"markdown","ee156d15":"markdown","c91027d2":"markdown","4aa001cb":"markdown"},"source":{"e8521a86":"from multiprocessing import Pool, cpu_count\nimport glob, zipfile, os, itertools\nfrom PIL import Image, ImageStat\nfrom sklearn import *\nimport pandas as pd\nimport numpy as np\n\ndef get_features(path):\n    try:\n        st = []\n        img = Image.open(path)\n        im_stats_ = ImageStat.Stat(img)\n        st += im_stats_.sum\n        st += im_stats_.mean\n        st += im_stats_.rms\n        st += im_stats_.var\n        st += im_stats_.stddev\n    except:\n        print(path)\n    return [path, st]\n\ndef normalize_img(paths):\n    imf_d = {}\n    p = Pool(cpu_count())\n    ret = p.map(get_features, paths)\n    for i in range(len(ret)):\n        imf_d[ret[i][0]] = ret[i][1]\n    ret = []\n    fdata = [imf_d[f] for f in paths]\n    return pd.DataFrame(fdata)\n\ndog_bytes = pd.DataFrame(glob.glob('..\/input\/all-dogs\/all-dogs\/**'), columns=['Path'])\ndog_bytes = pd.concat((dog_bytes, normalize_img(dog_bytes.Path.values)), axis=1)\ndog_bytes.head()","8004712a":"dog_bytes['Group'] = cluster.KMeans(n_clusters=100, random_state=3, n_jobs=-1).fit_predict(dog_bytes[list(range(15))])\ndog_bytes['Group'].value_counts()[:5]","6346f0d3":"import matplotlib.pyplot as plt\n%matplotlib inline\nfig = plt.figure(figsize=(8, 80))\nsamples = []\nfor i in range(100):\n    g = dog_bytes[dog_bytes['Group'] == i]\n    if len(g) >= 5:\n        samples += list(g['Path'].values[:5])\n\nfor i in range(len(samples))[:50]:\n    ax = fig.add_subplot(len(samples)\/5, 5, i+1, xticks=[], yticks=[])\n    img = Image.open(samples[i])\n    img = img.resize((100,int(img.size[1]\/(img.size[0]\/100))), Image.ANTIALIAS)\n    img = img.crop((0, 0, 64, 64))\n    plt.imshow(img)","c48793f6":"def sim_img(path):\n    img = Image.open(path).convert('RGB')\n    img = img.resize((100,int(img.size[1]\/(img.size[0]\/100))), Image.ANTIALIAS)\n    img = img.crop((0, 0, 64, 64))\n    return img\n\nsamples = []\nfor i in range(100):\n    g = dog_bytes[dog_bytes['Group'] == i]\n    if len(g) >= 23:\n        s = g['Path'].values[:23]\n        s = list([p for p,_ in itertools.groupby(sorted([sorted(p) for p in list(itertools.permutations(s, 2))]))])\n        samples += s\nprint(len(samples))","10fba1cc":"z = zipfile.PyZipFile('images.zip', mode='w')\nfor i in range(10_000):\n    p1, p2 = samples[i]\n    try:\n        im = Image.blend(sim_img(p1), sim_img(p2), alpha=0.20)\n        f = str(i)+'.png'\n        im.save(f,'PNG'); z.write(f); os.remove(f)\n        if i % 500==0:\n            print(i)\n    except:\n        print(p1, p2)\n\nprint (len(z.namelist()))\nz.close()","b94388fa":"Submission\n=============","ee156d15":"Motivation\n==============","c91027d2":"Inspiration\n===========","4aa001cb":"# This Kernel is not allowed to use as a final submission. Use at your own risk.\n# This Kernel was forked from the original Imitation Game.\n# The only change it the blending alpha weight.\n"}}