{"cell_type":{"edc6fadd":"code","d1ef558e":"code","9fe09918":"code","0e116fdd":"code","475ced8c":"code","da67cfb1":"code","076a7c13":"code","6131f3ad":"code","98cd3e2b":"code","7865d084":"code","2f0467d3":"code","0d557785":"code","3769990f":"code","1a9e911f":"code","675b55ea":"code","48580181":"code","d11375c2":"code","2c762209":"code","8f77f232":"code","328afcb0":"code","c43b9d54":"code","6989732f":"code","e9f634e3":"code","5fffdbd9":"code","1bd0f46f":"code","00dc4e53":"code","74d8b669":"code","2c20decb":"code","79021cae":"code","2196e53d":"code","a79ddbf6":"code","5b3d529e":"code","bec56a33":"markdown","2af1524b":"markdown"},"source":{"edc6fadd":"# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.\nfrom time import time\nfrom tqdm import tqdm_notebook as tqdm\nfrom collections import Counter\nfrom scipy import stats\nimport lightgbm as lgb\nfrom sklearn.metrics import cohen_kappa_score, mean_squared_error\nfrom sklearn.model_selection import GroupKFold, KFold\nimport gc\nimport json\npd.set_option('display.max_columns', 1000)\nfrom sklearn import metrics\nimport warnings\nwarnings.filterwarnings('ignore')\nimport random","d1ef558e":"def read_data():\n    print('Reading train.csv file....')\n    train = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/train.csv')\n    print('Training.csv file have {} rows and {} columns'.format(train.shape[0], train.shape[1]))\n\n    print('Reading test.csv file....')\n    test = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/test.csv')\n    print('Test.csv file have {} rows and {} columns'.format(test.shape[0], test.shape[1]))\n\n    print('Reading train_labels.csv file....')\n    train_labels = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/train_labels.csv')\n    print('Train_labels.csv file have {} rows and {} columns'.format(train_labels.shape[0], train_labels.shape[1]))\n\n    print('Reading specs.csv file....')\n    specs = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/specs.csv')\n    print('Specs.csv file have {} rows and {} columns'.format(specs.shape[0], specs.shape[1]))\n\n    print('Reading sample_submission.csv file....')\n    sample_submission = pd.read_csv('\/kaggle\/input\/data-science-bowl-2019\/sample_submission.csv')\n    print('Sample_submission.csv file have {} rows and {} columns'.format(sample_submission.shape[0], sample_submission.shape[1]))\n    return train, test, train_labels, specs, sample_submission","9fe09918":"def encode_title(train, test, train_labels):\n    # encode title\n    train['title_event_code'] = list(map(lambda x, y: str(x) + '_' + str(y), train['title'], train['event_code']))\n    test['title_event_code'] = list(map(lambda x, y: str(x) + '_' + str(y), test['title'], test['event_code']))\n    all_title_event_code = list(set(train[\"title_event_code\"].unique()).union(test[\"title_event_code\"].unique()))\n    # make a list with all the unique 'titles' from the train and test set\n    list_of_user_activities = list(set(train['title'].unique()).union(set(test['title'].unique())))\n    # make a list with all the unique 'event_code' from the train and test set\n    list_of_event_code = list(set(train['event_code'].unique()).union(set(test['event_code'].unique())))\n    list_of_event_id = list(set(train['event_id'].unique()).union(set(test['event_id'].unique())))\n    # make a list with all the unique worlds from the train and test set\n    list_of_worlds = list(set(train['world'].unique()).union(set(test['world'].unique())))\n    # create a dictionary numerating the titles\n    activities_map = dict(zip(list_of_user_activities, np.arange(len(list_of_user_activities))))\n    activities_labels = dict(zip(np.arange(len(list_of_user_activities)), list_of_user_activities))\n    activities_world = dict(zip(list_of_worlds, np.arange(len(list_of_worlds))))\n    assess_titles = list(set(train[train['type'] == 'Assessment']['title'].value_counts().index).union(set(test[test['type'] == 'Assessment']['title'].value_counts().index)))\n    # replace the text titles with the number titles from the dict\n    train['title'] = train['title'].map(activities_map)\n    test['title'] = test['title'].map(activities_map)\n    train['world'] = train['world'].map(activities_world)\n    test['world'] = test['world'].map(activities_world)\n    train_labels['title'] = train_labels['title'].map(activities_map)\n    win_code = dict(zip(activities_map.values(), (4100*np.ones(len(activities_map))).astype('int')))\n    # then, it set one element, the 'Bird Measurer (Assessment)' as 4110, 10 more than the rest\n    win_code[activities_map['Bird Measurer (Assessment)']] = 4110\n    # convert text into datetime\n    train['timestamp'] = pd.to_datetime(train['timestamp'])\n    test['timestamp'] = pd.to_datetime(test['timestamp'])\n    return train, test, train_labels, win_code, list_of_user_activities, list_of_event_code, activities_labels, assess_titles, list_of_event_id, all_title_event_code","0e116fdd":"def get_data(user_sample, test_set=False):\n    '''\n    The user_sample is a DataFrame from train or test where the only one \n    installation_id is filtered\n    And the test_set parameter is related with the labels processing, that is only requered\n    if test_set=False\n    '''\n    # Constants and parameters declaration\n    last_activity = 0\n    \n    user_activities_count = {'Clip':0, 'Activity': 0, 'Assessment': 0, 'Game':0}\n    \n    # new features: time spent in each activity\n    last_session_time_sec = 0\n    accuracy_groups = {0:0, 1:0, 2:0, 3:0}\n    all_assessments = []\n    accumulated_accuracy_group = 0\n    accumulated_accuracy = 0\n    accumulated_correct_attempts = 0 \n    accumulated_uncorrect_attempts = 0\n    accumulated_actions = 0\n    counter = 0\n    time_first_activity = float(user_sample['timestamp'].values[0])\n    durations = []\n    last_accuracy_title = {'acc_' + title: -1 for title in assess_titles}\n    last_game_time_title = {'lgt_' + title: 0 for title in assess_titles}\n    ac_game_time_title = {'agt_' + title: 0 for title in assess_titles}\n    ac_true_attempts_title = {'ata_' + title: 0 for title in assess_titles}\n    ac_false_attempts_title = {'afa_' + title: 0 for title in assess_titles}\n    event_code_count: Dict[str, int] = {ev: 0 for ev in list_of_event_code}\n    event_id_count: Dict[str, int] = {eve: 0 for eve in list_of_event_id}\n    title_count: Dict[str, int] = {eve: 0 for eve in activities_labels.values()} \n    title_event_code_count: Dict[str, int] = {t_eve: 0 for t_eve in all_title_event_code}\n    \n    # itarates through each session of one instalation_id\n    for i, session in user_sample.groupby('game_session', sort=False):\n        # i = game_session_id\n        # session is a DataFrame that contain only one game_session\n        \n        # get some sessions information\n        session_type = session['type'].iloc[0]\n        session_title = session['title'].iloc[0]\n        session_title_text = activities_labels[session_title]\n                    \n            \n        # for each assessment, and only this kind off session, the features below are processed\n        # and a register are generated\n        if (session_type == 'Assessment') & (test_set or len(session)>1):\n            # search for event_code 4100, that represents the assessments trial\n            all_attempts = session.query(f'event_code == {win_code[session_title]}')\n            # then, check the numbers of wins and the number of losses\n            true_attempts = all_attempts['event_data'].str.contains('true').sum()\n            false_attempts = all_attempts['event_data'].str.contains('false').sum()\n            # copy a dict to use as feature template, it's initialized with some itens: \n            # {'Clip':0, 'Activity': 0, 'Assessment': 0, 'Game':0}\n            features = user_activities_count.copy()\n            features.update(last_accuracy_title.copy())\n            features.update(event_code_count.copy())\n            features.update(title_count.copy())\n            features.update(event_id_count.copy())\n            features.update(title_event_code_count.copy())\n            features.update(last_game_time_title.copy())\n            features.update(ac_game_time_title.copy())\n            features.update(ac_true_attempts_title.copy())\n            features.update(ac_false_attempts_title.copy())\n            # get installation_id for aggregated features\n            features['installation_id'] = session['installation_id'].iloc[-1]\n            # add title as feature, remembering that title represents the name of the game\n            features['session_title'] = session['title'].iloc[0]\n            # the 4 lines below add the feature of the history of the trials of this player\n            # this is based on the all time attempts so far, at the moment of this assessment\n            features['accumulated_correct_attempts'] = accumulated_correct_attempts\n            features['accumulated_uncorrect_attempts'] = accumulated_uncorrect_attempts\n            accumulated_correct_attempts += true_attempts \n            accumulated_uncorrect_attempts += false_attempts\n            \n            # ----------------------------------------------\n            ac_true_attempts_title['ata_' + session_title_text] += true_attempts\n            ac_false_attempts_title['afa_' + session_title_text] += false_attempts\n            \n            \n            last_game_time_title['lgt_' + session_title_text] = session['game_time'].iloc[-1]\n            ac_game_time_title['agt_' + session_title_text] += session['game_time'].iloc[-1]\n            # ----------------------------------------------\n            \n            # the time spent in the app so far\n            if durations == []:\n                features['duration_mean'] = 0\n            else:\n                features['duration_mean'] = np.mean(durations)\n            durations.append((session.iloc[-1, 2] - session.iloc[0, 2] ).seconds)\n            # the accurace is the all time wins divided by the all time attempts\n            features['accumulated_accuracy'] = accumulated_accuracy\/counter if counter > 0 else 0\n            accuracy = true_attempts\/(true_attempts+false_attempts) if (true_attempts+false_attempts) != 0 else 0\n            accumulated_accuracy += accuracy\n            last_accuracy_title['acc_' + session_title_text] = accuracy\n            # a feature of the current accuracy categorized\n            # it is a counter of how many times this player was in each accuracy group\n            if accuracy == 0:\n                features['accuracy_group'] = 0\n            elif accuracy == 1:\n                features['accuracy_group'] = 3\n            elif accuracy == 0.5:\n                features['accuracy_group'] = 2\n            else:\n                features['accuracy_group'] = 1\n            features.update(accuracy_groups)\n            accuracy_groups[features['accuracy_group']] += 1\n            # mean of the all accuracy groups of this player\n            features['accumulated_accuracy_group'] = accumulated_accuracy_group\/counter if counter > 0 else 0\n            accumulated_accuracy_group += features['accuracy_group']\n            # how many actions the player has done so far, it is initialized as 0 and updated some lines below\n            features['accumulated_actions'] = accumulated_actions\n            \n            # there are some conditions to allow this features to be inserted in the datasets\n            # if it's a test set, all sessions belong to the final dataset\n            # it it's a train, needs to be passed throught this clausule: session.query(f'event_code == {win_code[session_title]}')\n            # that means, must exist an event_code 4100 or 4110\n            if test_set:\n                all_assessments.append(features)\n            elif true_attempts+false_attempts > 0:\n                all_assessments.append(features)\n                \n            counter += 1\n        \n        # this piece counts how many actions was made in each event_code so far\n        def update_counters(counter: dict, col: str):\n                num_of_session_count = Counter(session[col])\n                for k in num_of_session_count.keys():\n                    x = k\n                    if col == 'title':\n                        x = activities_labels[k]\n                    counter[x] += num_of_session_count[k]\n                return counter\n            \n        event_code_count = update_counters(event_code_count, \"event_code\")\n        event_id_count = update_counters(event_id_count, \"event_id\")\n        title_count = update_counters(title_count, 'title')\n        title_event_code_count = update_counters(title_event_code_count, 'title_event_code')\n\n        # counts how many actions the player has done so far, used in the feature of the same name\n        accumulated_actions += len(session)\n        if last_activity != session_type:\n            user_activities_count[session_type] += 1\n            last_activitiy = session_type \n                        \n    # if it't the test_set, only the last assessment must be predicted, the previous are scraped\n    if test_set:\n        return all_assessments[-1]\n    # in the train_set, all assessments goes to the dataset\n    return all_assessments","475ced8c":"def get_train_and_test(train, test):\n    compiled_train = []\n    compiled_test = []\n    for i, (ins_id, user_sample) in tqdm(enumerate(train.groupby('installation_id', sort = False)), total = 17000):\n        compiled_train += get_data(user_sample)\n    for ins_id, user_sample in tqdm(test.groupby('installation_id', sort = False), total = 1000):\n        test_data = get_data(user_sample, test_set = True)\n        compiled_test.append(test_data)\n    reduce_train = pd.DataFrame(compiled_train)\n    reduce_test = pd.DataFrame(compiled_test)\n    categoricals = ['session_title']\n    return reduce_train, reduce_test, categoricals","da67cfb1":"# thank to Bruno\ndef eval_qwk_lgb_regr(y_pred, train_t):\n    \"\"\"\n    Fast cappa eval function for lgb.\n    \"\"\"\n    dist = Counter(train_t['accuracy_group'])\n    for k in dist:\n        dist[k] \/= len(train_t)\n    \n    acum = 0\n    bound = {}\n    for i in range(3):\n        acum += dist[i]\n        bound[i] = np.percentile(y_pred, acum * 100)\n\n    def classify(x):\n        if x <= bound[0]:\n            return 0\n        elif x <= bound[1]:\n            return 1\n        elif x <= bound[2]:\n            return 2\n        else:\n            return 3\n\n    y_pred = np.array(list(map(classify, y_pred)))\n    \n    return y_pred\n\n\ndef predict(sample_submission, y_pred):\n    \n    \"\"\"\n    Fast cappa eval function for lgb.\n    \"\"\"\n    dist = Counter(reduce_train['accuracy_group'])\n    for k in dist:\n        dist[k] \/= len(reduce_train)\n    \n    acum = 0\n    bound = {}\n    for i in range(3):\n        acum += dist[i]\n        bound[i] = np.percentile(y_pred, acum * 100)\n\n    def classify(x):\n        if x <= bound[0]:\n            return 0\n        elif x <= bound[1]:\n            return 1\n        elif x <= bound[2]:\n            return 2\n        else:\n            return 3\n\n    y_pred = np.array(list(map(classify, y_pred)))\n\n    sample_submission['accuracy_group'] = y_pred\n    sample_submission['accuracy_group'] = sample_submission['accuracy_group'].astype(int)\n    sample_submission.to_csv('submission.csv', index = False)\n    print(sample_submission['accuracy_group'].value_counts(normalize = True))","076a7c13":"def get_random_assessment(reduce_train):\n    used_idx = []\n    for iid in tqdm(set(reduce_train['installation_id'])):\n        list_ = list(reduce_train[reduce_train['installation_id']==iid].index)\n        cur = random.choices(list_, k = 1)[0]\n        used_idx.append(cur)\n    reduce_train_t = reduce_train.loc[used_idx].reset_index(drop = True)\n    return reduce_train_t","6131f3ad":"def run_lgb(reduce_train, reduce_test, features):\n    \n    # features found in initial bayesian optimization\n    params = {'boosting_type': 'gbdt', \n              'metric': 'rmse', \n              'objective': 'regression', \n              'n_jobs': -1, \n              'seed': 42, \n              'num_leavs': 21, \n              'learning_rate': 0.027091035494468625, \n              'max_depth': 22, \n              'lambda_l1': 0.0609996908935434, \n              'lambda_l2': 1.0970788941187797, \n              'bagging_fraction': 0.7525277174040448, \n              'bagging_freq': 1, \n              'colsample_bytree': 0.8488159181363383}\n    \n    # define a GroupKFold strategy because we are predicting unknown installation_ids\n    kf = GroupKFold(n_splits = 5)\n    target = 'accuracy_group'\n    oof_pred = np.zeros(len(reduce_train))\n    y_pred = np.zeros(len(reduce_test))\n    \n    # train a baseline model and record the cohen cappa score as our best score\n    for fold, (tr_ind, val_ind) in enumerate(kf.split(reduce_train, groups = reduce_train['installation_id'])):\n        print('Fold:', fold + 1)\n        x_train, x_val = reduce_train[features].iloc[tr_ind], reduce_train[features].iloc[val_ind]\n        y_train, y_val = reduce_train[target][tr_ind], reduce_train[target][val_ind]\n        train_set = lgb.Dataset(x_train, y_train, categorical_feature = ['session_title'])\n        val_set = lgb.Dataset(x_val, y_val, categorical_feature = ['session_title'])\n        \n        model = lgb.train(params, train_set, num_boost_round = 100000, early_stopping_rounds = 100, \n                         valid_sets = [train_set, val_set], verbose_eval = 100)\n        \n        oof_pred[val_ind] = model.predict(x_val)\n        y_pred += model.predict(reduce_test[features]) \/ kf.n_splits\n        \n    # calculate loss\n    oof_rmse_score = np.sqrt(mean_squared_error(reduce_train[target], oof_pred))\n    oof_cohen_score = cohen_kappa_score(reduce_train[target], eval_qwk_lgb_regr(oof_pred, reduce_train), weights = 'quadratic')\n    print('Our oof rmse score is:', oof_rmse_score)\n    print('Our oof cohen kappa score is:', oof_cohen_score)\n    \n    return y_pred, oof_rmse_score, oof_cohen_score","98cd3e2b":"# read data\ntrain, test, train_labels, specs, sample_submission = read_data()\n# get usefull dict with maping encode\ntrain, test, train_labels, win_code, list_of_user_activities, list_of_event_code, activities_labels, assess_titles, list_of_event_id, all_title_event_code = encode_title(train, test, train_labels)\n# tranform function to get the train and test set\nreduce_train, reduce_test, categoricals = get_train_and_test(train, test)","7865d084":"# extracted from feature elimination first round script\nold_features = ['Activity', 'Assessment', 'Clip', 'Game', 'acc_Bird Measurer (Assessment)', 'acc_Cart Balancer (Assessment)', \n                'acc_Cauldron Filler (Assessment)', 'acc_Chest Sorter (Assessment)', 'acc_Mushroom Sorter (Assessment)', 2050, \n                4100, 2060, 4110, 2070, 2075, 2080, 2081, 2083, 3110, 3120, 3121, 4220, 4230, 5000, 4235, 5010, 4010, 4020, \n                4021, 4022, 4025, 4030, 4031, 3010, 4035, 4040, 3020, 3021, 4045, 2000, 4050, 2010, 2020, 4070, 2025, 2030, \n                4080, 2035, 2040, 4090, 4095, 'Cauldron Filler (Assessment)', 'Leaf Leader', 'Welcome to Lost Lagoon!', \n                'Lifting Heavy Things', 'Sandcastle Builder (Activity)', 'Crystal Caves - Level 3', \n                'Chest Sorter (Assessment)', 'Crystal Caves - Level 2', 'Slop Problem', 'Magma Peak - Level 2', \n                'All Star Sorting', 'Chow Time', 'Tree Top City - Level 1', 'Fireworks (Activity)', 'Dino Dive', \n                'Scrub-A-Dub', 'Tree Top City - Level 2', 'Bug Measurer (Activity)', 'Crystals Rule', \n                'Flower Waterer (Activity)', 'Tree Top City - Level 3', 'Crystal Caves - Level 1', \"Pirate's Tale\", \n                'Watering Hole (Activity)', 'Bird Measurer (Assessment)', 'Treasure Map', 'Happy Camel', \n                'Chicken Balancer (Activity)', 'Dino Drink', 'Air Show', 'Mushroom Sorter (Assessment)', 'Ordering Spheres', \n                'Cart Balancer (Assessment)', 'Rulers', 'Bubble Bath', 'Balancing Act', 'Bottle Filler (Activity)', \n                'Honey Cake', '12 Monkeys', 'Pan Balance', 'Costume Box', 'Egg Dropper (Activity)', 'Magma Peak - Level 1', \n                'lgt_Mushroom Sorter (Assessment)', 'lgt_Cauldron Filler (Assessment)', 'lgt_Cart Balancer (Assessment)', \n                'lgt_Bird Measurer (Assessment)', 'lgt_Chest Sorter (Assessment)', 'agt_Mushroom Sorter (Assessment)', \n                'agt_Cauldron Filler (Assessment)', 'agt_Cart Balancer (Assessment)', 'agt_Bird Measurer (Assessment)', \n                'agt_Chest Sorter (Assessment)', 'ata_Mushroom Sorter (Assessment)', 'ata_Cauldron Filler (Assessment)', \n                'ata_Cart Balancer (Assessment)', 'ata_Bird Measurer (Assessment)', 'ata_Chest Sorter (Assessment)', \n                'afa_Mushroom Sorter (Assessment)', 'afa_Cauldron Filler (Assessment)', 'afa_Cart Balancer (Assessment)', \n                'afa_Bird Measurer (Assessment)', 'afa_Chest Sorter (Assessment)', 'session_title', \n                'accumulated_correct_attempts', 'accumulated_uncorrect_attempts', 'duration_mean', 'accumulated_accuracy', \n                0, 1, 2, 3, 'accumulated_accuracy_group', 'accumulated_actions']\n\nevent_id_features = list(reduce_train.columns[95:479])\ntitle_event_code_cross = list(reduce_train.columns[479:882])\nfeatures = old_features + event_id_features + title_event_code_cross\n\ndef remove_correlated_features(reduce_train):\n    counter = 0\n    to_remove = []\n    for feat_a in features:\n        for feat_b in features:\n            if feat_a != feat_b and feat_a not in to_remove and feat_b not in to_remove:\n                c = np.corrcoef(reduce_train[feat_a], reduce_train[feat_b])[0][1]\n                if c > 0.995:\n                    counter += 1\n                    to_remove.append(feat_b)\n                    print('{}: FEAT_A: {} FEAT_B: {} - Correlation: {}'.format(counter, feat_a, feat_b, c))\n    return to_remove\nto_remove = remove_correlated_features(reduce_train)\nfeatures = [col for col in features if col not in to_remove]\nfeatures = [col for col in features if col not in ['Heavy, Heavier, Heaviest_2000']]\nprint('Training with {} features'.format(len(features)))","2f0467d3":"reduce_train_t_1 = get_random_assessment(reduce_train)\nreduce_train_t_2 = get_random_assessment(reduce_train)\nreduce_train_t_3 = get_random_assessment(reduce_train)\nreduce_train_t_4 = get_random_assessment(reduce_train)\nreduce_train_t_5 = get_random_assessment(reduce_train)\nreduce_train_t_6 = get_random_assessment(reduce_train)\nreduce_train_t_7 = get_random_assessment(reduce_train)\nreduce_train_t_8 = get_random_assessment(reduce_train)\nreduce_train_t_9 = get_random_assessment(reduce_train)\nreduce_train_t_10 = get_random_assessment(reduce_train)\nreduce_train_t_11 = get_random_assessment(reduce_train)\nreduce_train_t_12 = get_random_assessment(reduce_train)\nreduce_train_t_13 = get_random_assessment(reduce_train)\nreduce_train_t_14 = get_random_assessment(reduce_train)\nreduce_train_t_15 = get_random_assessment(reduce_train)\nreduce_train_t_16 = get_random_assessment(reduce_train)\nreduce_train_t_17 = get_random_assessment(reduce_train)\nreduce_train_t_18 = get_random_assessment(reduce_train)\nreduce_train_t_19 = get_random_assessment(reduce_train)\nreduce_train_t_20 = get_random_assessment(reduce_train)","0d557785":"y_pred_1, oof_rmse_score_1, oof_cohen_score_1 = run_lgb(reduce_train_t_1, reduce_test, features)","3769990f":"y_pred_2, oof_rmse_score_2, oof_cohen_score_2 = run_lgb(reduce_train_t_2, reduce_test, features)","1a9e911f":"y_pred_3, oof_rmse_score_3, oof_cohen_score_3 = run_lgb(reduce_train_t_3, reduce_test, features)","675b55ea":"y_pred_4, oof_rmse_score_4, oof_cohen_score_4 = run_lgb(reduce_train_t_4, reduce_test, features)","48580181":"y_pred_5, oof_rmse_score_5, oof_cohen_score_5 = run_lgb(reduce_train_t_5, reduce_test, features)","d11375c2":"y_pred_6, oof_rmse_score_6, oof_cohen_score_6 = run_lgb(reduce_train_t_6, reduce_test, features)","2c762209":"y_pred_7, oof_rmse_score_7, oof_cohen_score_7 = run_lgb(reduce_train_t_7, reduce_test, features)","8f77f232":"y_pred_8, oof_rmse_score_8, oof_cohen_score_8 = run_lgb(reduce_train_t_8, reduce_test, features)","328afcb0":"y_pred_9, oof_rmse_score_9, oof_cohen_score_9 = run_lgb(reduce_train_t_9, reduce_test, features)","c43b9d54":"y_pred_10, oof_rmse_score_10, oof_cohen_score_10 = run_lgb(reduce_train_t_10, reduce_test, features)","6989732f":"y_pred_11, oof_rmse_score_11, oof_cohen_score_11 = run_lgb(reduce_train_t_11, reduce_test, features)","e9f634e3":"y_pred_12, oof_rmse_score_12, oof_cohen_score_12 = run_lgb(reduce_train_t_12, reduce_test, features)","5fffdbd9":"y_pred_13, oof_rmse_score_13, oof_cohen_score_13 = run_lgb(reduce_train_t_13, reduce_test, features)","1bd0f46f":"y_pred_14, oof_rmse_score_14, oof_cohen_score_14 = run_lgb(reduce_train_t_14, reduce_test, features)","00dc4e53":"y_pred_15, oof_rmse_score_15, oof_cohen_score_15 = run_lgb(reduce_train_t_15, reduce_test, features)","74d8b669":"y_pred_16, oof_rmse_score_16, oof_cohen_score_16 = run_lgb(reduce_train_t_16, reduce_test, features)","2c20decb":"y_pred_17, oof_rmse_score_17, oof_cohen_score_17 = run_lgb(reduce_train_t_17, reduce_test, features)","79021cae":"y_pred_18, oof_rmse_score_18, oof_cohen_score_18 = run_lgb(reduce_train_t_18, reduce_test, features)","2196e53d":"y_pred_19, oof_rmse_score_19, oof_cohen_score_19 = run_lgb(reduce_train_t_19, reduce_test, features)","a79ddbf6":"y_pred_20, oof_rmse_score_20, oof_cohen_score_20 = run_lgb(reduce_train_t_20, reduce_test, features)","5b3d529e":"mean_rmse_score = (oof_rmse_score_1 + oof_rmse_score_2 + oof_rmse_score_3 + oof_rmse_score_4 + oof_rmse_score_5 + \\\n                   oof_rmse_score_6 + oof_rmse_score_7 + oof_rmse_score_8 + oof_rmse_score_9 + oof_rmse_score_10 + \\\n                   oof_rmse_score_11 + oof_rmse_score_12 + oof_rmse_score_13 + oof_rmse_score_14 + oof_rmse_score_15 + \\\n                   oof_rmse_score_16 + oof_rmse_score_17 + oof_rmse_score_18 + oof_rmse_score_19 + oof_rmse_score_20) \/ 20\nmean_cappa_score = (oof_cohen_score_1 + oof_cohen_score_2 + oof_cohen_score_3 + oof_cohen_score_4 + oof_cohen_score_5 + \\\n                    oof_cohen_score_6 + oof_cohen_score_7 + oof_cohen_score_8 + oof_cohen_score_9 + oof_cohen_score_10 + \\\n                    oof_cohen_score_11 + oof_cohen_score_12 + oof_cohen_score_13 + oof_cohen_score_14 + oof_cohen_score_15 + \\\n                    oof_cohen_score_16 + oof_cohen_score_17 + oof_cohen_score_18 + oof_cohen_score_19 + \\\n                    oof_cohen_score_20) \/ 20\nprint('Our mean rmse score for our ensemble is: ', mean_rmse_score)\nprint('Our mean cappa score for our ensemble is: ', mean_cappa_score)\ny_final = (y_pred_1 + y_pred_2 + y_pred_3 + y_pred_4 + y_pred_5 + y_pred_6 + y_pred_7 + y_pred_8 + y_pred_9 + y_pred_10 + \\\n           y_pred_11 + y_pred_12 + y_pred_13 + y_pred_14 + y_pred_15 + y_pred_16 + y_pred_17 + y_pred_18 + y_pred_19 + \\\n           y_pred_20) \/ 20\ny_final = np.array(y_final)\npredict(sample_submission, y_final)","bec56a33":"# Objective","2af1524b":"Truncate train set and perform an ensemble. When you truncate the training set the adversarial validation auc roc is 0.5 (aprox), test set is also truncated (don't know about private, it should be the same). This notebook shows how we can truncate the train set a lot of times (get 1 observation of each installation id random) and train 20 models and then take the average of their predictions.\n\n* This method aligns well with the lb. Check mean cv score for the 20 models and the lb(we have a lower cohen kappa cv)"}}