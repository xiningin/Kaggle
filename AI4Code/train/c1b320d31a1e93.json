{"cell_type":{"88ffd74b":"code","9b00c079":"code","0b96a66f":"code","6d352ccc":"code","772d6784":"code","e420bfc9":"code","fcda6a0c":"code","050921ba":"code","592a5c50":"code","31d12a68":"code","a4805942":"code","4466328d":"markdown","5e0d72f0":"markdown","4bbdfb66":"markdown","61e66f7d":"markdown","e99b45d7":"markdown","37ef99ea":"markdown","b8e3fa8d":"markdown"},"source":{"88ffd74b":"import numpy as np\nfrom numpy import sin, cos, pi\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nplt.style.use('seaborn-whitegrid')","9b00c079":"def solve(initial_state, times, integrate_func, derivative_func):\n    \"\"\"\n    Solves the initial-value problem of the first order ODEs\n    :param initial_state: initial state\n    :param times: a sequence of time points for which to solve\n    :param integrate_func: calculates the next state\n    :param derivative_func: computes derivatives of each state component\n    :return:\n    \"\"\"\n    dt = times[1] - times[0]\n    states = [initial_state]\n    for step, t in enumerate(times):\n        states.append(integrate_func(states[-1], step, t, dt, derivative_func))\n    return np.array(states)\n\ndef integrate_rk4(state, step, t, dt, dydx_func):\n    \"\"\"\n    Fourth-order Runge-Kutta method.\n    Source: https:\/\/www.geeksforgeeks.org\/runge-kutta-4th-order-method-solve-differential-equation\/\n    :param step:\n    :param state:\n    :param t:\n    :param dt:\n    :param dydx_func:\n    :return:\n    \"\"\"\n    k1 = dydx_func(state, step, t, dt)\n    k2 = dydx_func([v + d * dt \/ 2 for v, d in zip(state, k1)], step, t, dt)\n    k3 = dydx_func([v + d * dt \/ 2 for v, d in zip(state, k2)], step, t, dt)\n    k4 = dydx_func([v + d * dt for v, d in zip(state, k3)], step, t, dt)\n    return [v + (k1_ + 2 * k2_ + 2 * k3_ + k4_) * dt \/ 6 for v, k1_, k2_, k3_, k4_ in zip(state, k1, k2, k3, k4)]","0b96a66f":"r = 0.25\nl = 1.0\nM = 0.25\nm = 0.3\ng = 9.8\n\nI = 0.5 * M * r\n\ndef derivate(state, step, t, dt):\n    dth, th, dphi, phi = state\n\n    _dphi = (m * l * r * dth ** 2 * sin(th) - m * g * r * sin(th) * cos(th)) \/ (m * r ** 2 * sin(th) ** 2 + I)\n    _dth = (g * sin(th) - r * _dphi * cos(th)) \/ l\n\n    return [_dth, dth, _dphi, dphi]","6d352ccc":"times = np.linspace(0, 10, 500)\nsolution = solve([0.0, pi \/ 12, .0, .0], times, integrate_rk4, derivate)\n\ndef render(solution):\n    theta = solution[:, 1]\n    phi = solution[:, 3]\n\n    wheel_x = phi * r\n\n    spot_r = 0.7 * r\n    wheel_spot_x = wheel_x + spot_r * cos(phi - pi \/ 2)\n    wheel_spot_y = r - spot_r * sin(phi - pi \/ 2)\n\n    mass_x = wheel_x + l * cos(theta - pi \/ 2)\n    mass_y = r - l * sin(theta - pi \/ 2)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, autoscale_on=False, xlim=(-1.5, 1.5), ylim=(-1.5, 1.5))\n    ax.set_aspect('equal')\n    ax.grid(True)\n\n    line, = ax.plot([], [], 'k-', lw=2)\n    wheel = plt.Circle((0.0, r), r, color='black', fill=False, lw=2)\n    wheel_spot = plt.Circle((0.0, spot_r), 0.02, color='red')\n    mass = plt.Circle((0.0, 0.0), 0.1, color='black')\n\n\n    def init():\n        return []\n\n\n    def animate(i):\n        wheel.set_center((wheel_x[i], r))\n        wheel_spot.set_center((wheel_spot_x[i], wheel_spot_y[i]))\n        mass.set_center((mass_x[i], mass_y[i]))\n        line.set_data([wheel_x[i], mass_x[i]], [r, mass_y[i]])\n        patches = [line, ax.add_patch(wheel), ax.add_patch(wheel_spot), ax.add_patch(mass)]\n        return patches\n\n\n    ani = animation.FuncAnimation(fig, animate, np.arange(1, len(solution)),interval=25, blit=True, init_func=init)    \n    plt.close(fig)\n    return ani\n\nani = render(solution)","772d6784":"%time ani.save('free_robot.gif', writer='imagemagick', fps=24)","e420bfc9":"class PIDController:\n    def __init__(self, k_p, k_d, k_i, target, init_value=0.0):\n        self.Kp = k_p\n        self.Kd = k_d\n        self.Ki = k_i\n        self.target = target\n        self.lastValue = init_value\n        self.integral_error = 0.0\n\n    def get_control(self, value, dt):\n        \"\"\"\n            Returns PID control.\n            Derivative spike is mitigated by dError\/dt = -dInput\/dt\n            see: http:\/\/brettbeauregard.com\/blog\/2011\/04\/improving-the-beginner%e2%80%99s-pid-derivative-kick\/\n        \"\"\"\n        error = self.target - value\n\n        derivative = -(value - self.lastValue) \/ dt\n\n        self.lastValue = value\n        self.integral_error += error * dt\n        return self.Kp * error + self.Kd * derivative + self.Ki * self.integral_error\n\n    def set_target(self, target):\n        self.target = target","fcda6a0c":"b1 = 0.01 # Friction coefficient due to rotation of the body\nb2 = 0.01 # Friction coefficient due to rotation of the wheel\n\nth_pid = PIDController(k_p=10.0, k_d=2.5, k_i=0.0, target=0.0)\nvelocity_pid = PIDController(k_p=0.002, k_d=0.0, k_i=0.001, target=0.0)\n\ndef limit(v, lim):\n    if v > lim:\n        return lim\n    elif v < -lim:\n        return -lim\n    else:\n        return v\n\ndef derivate_velocity_pid(state, step, t, dt):\n    dth, th, dphi, phi = state\n\n    th_target = velocity_pid.get_control(dphi, dt)\n    th_pid.set_target(th_target)\n    u = -th_pid.get_control(th, dt)\n    u = limit(u, 10)\n\n    s = sin(th)\n    c = cos(th)\n\n    _dphi = (m * r * (l * dth ** 2 * s + b1 * dth * c - g * s * c) - b2 * dphi + u) \/ (I + m * r ** 2 * s ** 2)\n    _dth = (g * s - r * _dphi * c - b1 * dth) \/ l\n\n    return [_dth, dth, _dphi, dphi]\n","050921ba":"solution = solve([0.0, pi \/ 12, .0, .0], times, integrate_rk4, derivate_velocity_pid)\nani = render(solution)","592a5c50":"%time ani.save('velocity_pid.gif', writer='imagemagick', fps=24)","31d12a68":"th_pid = PIDController(k_p=40.0, k_d=20.0, k_i=0.0, target=0.0)\nposition_pid = PIDController(k_p=0.07, k_d=0.07, k_i=0.0, target=0.0)\n\ndef derivate_position_pid(state, step, t, dt):\n    dth, th, dphi, phi = state\n\n    th_target = position_pid.get_control(phi, dt)\n    th_pid.set_target(th_target)\n    u = -th_pid.get_control(th, dt)\n    u = limit(u, 10)\n\n    s = sin(th)\n    c = cos(th)\n\n    _dphi = (m * r * (l * dth ** 2 * s + b1 * dth * c - g * s * c) - b2 * dphi + u) \/ (I + m * r ** 2 * s ** 2)\n    _dth = (g * s - r * _dphi * c - b1 * dth) \/ l\n\n    return [_dth, dth, _dphi, dphi]\n\nsolution = solve([0.0, pi \/ 12, .0, .0], times, integrate_rk4, derivate_position_pid)\nani = render(solution)\n","a4805942":"%time ani.save('position_pid.gif', writer='imagemagick', fps=24)","4466328d":"![](.\/position_pid.gif)","5e0d72f0":"## Position control\n\nThe diagram below shows how to control robot's position\n\n![position-control-loop.png](attachment:c4db288a-9457-4ce2-89f9-74b332917837.png)","4bbdfb66":"## Adding feedback loop for angle and velocity control\n\nUpright position and the velocity can be controlled with the following feedback loops.\n\n![velocity-control-loop.png](attachment:8845f7a5-791a-4330-adfe-eb5b9ce114e2.png)\n\n\nIn this setup it finds new balance point if the velocity keeps being different for a long time.","61e66f7d":"![](.\/free_robot.gif)","e99b45d7":"# Self-balancing robot simulation\n\nThis notebook contains equations and controller design necessary to stabilize a self-balancing robot, contor it's velocity and position.\n\nThe model considered below looks as follows:\n\n![model.png](attachment:8f10e3f1-6700-462b-8adc-612571ce6664.png)\n\n## Free fall model\nLet's start with a frictionless model allowing free motion. A mass (m) is attached to a wheel (mass: M, radius: R, moment of inertia $ I = \\frac{1}{2} \\cdot M \\cdot R $) with the rod of length (L).\n\nThe governing equations looks as follows:\n$$\n\\begin{cases}\n\\ddot{\\phi} = \\frac{mLR\\dot{\\theta}^2sin(\\theta) - mgRsin(\\theta)cos(\\theta)}{mR^2sin(\\theta)^2 + I},\\\\\n\\ddot{\\theta} = \\frac{gsin(\\theta) - R\\phi^2cos(\\theta)}{L}\n\\end{cases}\n$$\n\nReusing solver from one of the [prevoius notebooks](https:\/\/www.kaggle.com\/zjor86\/ode-solver)","37ef99ea":"Feel free to create your own controller by implementing `derivate_XXX` function\n\n## References\n- [Source code of a real robot](https:\/\/github.com\/zjor\/balancing-robot)\n- [Project description](https:\/\/hackaday.io\/project\/180126-self-balancing-robot-for-humans)\n- [Video of a balancing robot](https:\/\/www.youtube.com\/watch?v=1LGBiAcChJg)\n- [Python code for simulations](https:\/\/github.com\/zjor\/snippets\/tree\/master\/python\/ode_solver)","b8e3fa8d":"![](.\/velocity_pid.gif)"}}