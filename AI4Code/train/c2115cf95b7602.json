{"cell_type":{"4e70bd7a":"code","7fbe3bac":"code","d50432ea":"code","22418712":"code","263e153a":"code","8a1ed09e":"code","44726ec6":"code","bea482a4":"code","aa223786":"code","65077646":"code","9f1ed5fc":"code","601ef1a3":"code","c7edf8fe":"code","6e7a4cd1":"code","a74873df":"code","2fa8a0b5":"code","94bba3cc":"code","4591f5fd":"code","9a19505f":"code","146344b1":"code","2664197a":"code","9581a365":"code","928926f6":"code","92a09505":"code","7200a286":"code","1f1e7c35":"code","68a6e660":"code","243bf05c":"code","892a914f":"code","e56d5890":"markdown","29fdccd8":"markdown","5e803968":"markdown","ce38b92f":"markdown","c25e22ef":"markdown","c06a3acf":"markdown","14376864":"markdown","f1f89558":"markdown","b80df7de":"markdown","7d52cea8":"markdown","c5dc18c5":"markdown","ec7b591b":"markdown","948dee3f":"markdown","fe8af712":"markdown","8870686a":"markdown","e1191541":"markdown","485829d1":"markdown","5e7dc302":"markdown","15823aa2":"markdown","60372336":"markdown","ab4d3ef1":"markdown"},"source":{"4e70bd7a":"import numpy as np # linear algebra\nimport pandas as pd # data processing\n\nfrom sklearn.model_selection import train_test_split\nimport lightgbm as lgb\nfrom catboost import CatBoostClassifier\nfrom sklearn import metrics\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn import metrics\nimport matplotlib.pyplot as plt\nimport os\nimport gc\nimport datetime\nfrom pandas.tseries.holiday import USFederalHolidayCalendar as calendar\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.metrics import classification_report, accuracy_score  \nfrom sklearn.metrics import precision_score, recall_score \nfrom sklearn.metrics import f1_score, matthews_corrcoef \nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.model_selection import KFold","7fbe3bac":"def reduce_mem_usage(df):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.        \n    \"\"\"\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage of dataframe is {:.2f} MB'.format(start_mem))\n    \n    for col in df.columns:\n        col_type = df[col].dtype\n        \n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        else:\n            df[col] = df[col].astype('category')\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))\n    print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) \/ start_mem))\n    \n    return df\n\ndef import_data(file):\n    \"\"\"create a dataframe and optimize its memory usage\"\"\"\n    df = pd.read_csv(file, parse_dates=True, keep_date_col=True, index_col='TransactionID')\n    df = reduce_mem_usage(df)\n    return df\n\n\ndef aggreg(columns, userid, aggr='mean'):\n    \"\"\"\n       Grouping the selected variables according to \"userids\", taking the averages and \n       assigning them to the new variable according to userids\n       \n    \"\"\"\n    \n    \n    for col in columns:\n        # create the new colunm name\n        new_col_name = col+'_'+userid+'_'+aggr \n        df_temp = pd.concat([X_train[[userid, col]], X_test[[userid,col]]]) \n        df_temp.loc[df_temp[col]==-1,col] = np.nan \n        \n        # grouping column by userid\n        df_temp = df_temp.groupby(userid)[col].agg([aggr]).reset_index().rename(columns={aggr: new_col_name})\n        df_temp.index = list(df_temp[userid]) \n        df_temp = df_temp[new_col_name].to_dict()  \n        \n        # Add these average values to Train and Test sets according to userid with the name \"new_col_name\"\n        X_train[new_col_name] = X_train[userid].map(df_temp).astype('float32')\n        X_test[new_col_name]  = X_test[userid].map(df_temp).astype('float32')\n        \n        # Writes -1 instead of \"nan\" values in newly created variables.\n        X_train[new_col_name].fillna(-1,inplace=True)\n        X_test[new_col_name].fillna(-1,inplace=True)\n      \n\n\n    \ndef aggreg_uniq(columns, userid):\n    \n    \"\"\"\n        Variables in columns are grouped by userid and unique values \u200b\u200bin this column are counted and\n        the total number of each unique value is assigned across the \"userid\" in Test and Train sets.\n    \"\"\"\n    for col in columns:  \n        df = pd.concat([X_train[[userid,col]],X_test[[userid,col]]],axis=0)\n        uniq = df.groupby(userid)[col].agg(['nunique'])['nunique'].to_dict()\n        \n        X_train[col+'_count'] = X_train[userid].map(uniq).astype('float32')\n        X_test[col+'_count'] = X_test[userid].map(uniq).astype('float32')\n    \n    \ndef num_positiv(X_train,X_test):\n    \n    \"\"\"\n       We increase each value by the minimum value in the Train and Test set, so there is no negative value \n       and the minimum value becomes 0. The purpose in doing this is when we assign -1 to NAN values, \n       it can be perceived as a separate class.\n    \"\"\"\n    for f in X_train.columns:  \n        \n        if f not in ['TransactionAmt','TransactionDT',\"isFraud\"]: \n            mn = np.min((X_train[f].min(),X_test[f].min())) \n            X_train[f] -= np.float32(mn)  \n            X_test[f] -= np.float32(mn)\n            \n            X_train[f].fillna(-1,inplace=True)  \n            X_test[f].fillna(-1,inplace=True)  \n            \n\ndef class_freq(cols):\n    \"\"\" \n       The \"class_freq\" function normalizes the specified columns in the entered data sets,\n       converts their types to \"float32\" and adds them to the data sets as a new variable with \"_freq\" extension.\n    \"\"\"\n    \n    for col in cols:\n        df = pd.concat([X_train[col],X_test[col]])\n        vc = df.value_counts(dropna=True).to_dict()  \n        vc[-1] = -1  \n        nm = col+'_freq' \n        X_train[nm] = X_train[col].map(vc)  \n        X_test[nm] = X_test[col].map(vc) \n        del df; x=gc.collect()\n        \n\n        \ndef factorize_categoric():    \n    \n    \"\"\"\n       Factorizing process is performed for all categoric (object) variables, and\n       factorize function keeps nan values as -1.\n    \"\"\"\n    for col in X_train.select_dtypes(include=['category','object']).columns:\n        df = pd.concat([X_train[col],X_test[col]])\n        df,_ = df.factorize(sort=True)\n        X_train[col] = df[:len(X_train)].astype('int32')\n        X_test[col] = df[len(X_train):].astype('int32')\n        del df; x=gc.collect()        \n        \n\n        \n\ndef user_id(col1,col2):\n    \n    \"\"\"\n       Converts the values \u200b\u200bin 2 columns to string and combines them \n       with \"_\" to create a string type new variable.\n       \n    \"\"\"\n    us_id = col1+'_'+col2\n    \n    X_train[us_id] = X_train[col1].astype(str)+'_'+X_train[col2].astype(str)\n    X_test[us_id] = X_test[col1].astype(str)+'_'+X_test[col2].astype(str)","d50432ea":"%%time\n\nprint('Loading data...')\n\ntrain_id = import_data(\"..\/input\/ieee-fraud-detection\/train_identity.csv\")\nprint('\\tSuccessfully loaded train_identity!')\n\nX_train = import_data('..\/input\/ieee-fraud-detection\/train_transaction.csv')\nprint('\\tSuccessfully loaded train_transaction!')\n\n# Merging Train set and train_id\nX_train = X_train.merge(train_id, how='left', left_index=True, right_index=True)\ntest_id = import_data('..\/input\/ieee-fraud-detection\/test_identity.csv')\nprint('\\tSuccessfully loaded test_identity!')\n\nX_test = import_data('..\/input\/ieee-fraud-detection\/test_transaction.csv')\nprint('\\tSuccessfully loaded test_transaction!')\n\ntest_id.columns = train_id.columns\n\n# Merging Test set and test_id \nX_test = X_test.merge(test_id, how='left', left_index=True, right_index=True)  \n\n\n# TARGET\ny_train = X_train['isFraud'].copy()  \n\npd.set_option('max_columns', None)\n\nprint('Data was successfully loaded!\\n')","22418712":"nan_groups={}\nv_cols = ['V'+str(i) for i in range(1,340)]\nfor i in X_train.columns:\n    nan_sum = X_train[i].isna().sum()\n    try:\n        nan_groups[nan_sum].append(i)\n    except:\n        nan_groups[nan_sum]=[i]\n\nfor i,j in nan_groups.items():\n    print('The Sum of the NaN Values =',i)\n    print(j)\n    \n    \n\nnon_group_list=list()\nfor i,j in nan_groups.items():\n    if len(j)>5:\n        if i != 0:\n            non_group_list.append(i)\n            \n            \n# Variable groups with a correlation value of more than 0.70 within the groups\n\n# V1 - V11 \ngrp1 = [[1],[2,3],[4,5],[6,7],[8,9],[10,11]]\n# V12 - V34\ngrp2 = [[12,13],[14],[15,16,17,18,21,22,31,32,33,34],[19,20],[23,24],[25,26],[27,28],[29,30]]\n# V35 - V52\ngrp3 = [[35,36],[37,38],[39,40,42,43,50,51,52],[41],[44,45],[46,47],[48,49]]\n# V53 - V74\ngrp4 = [[53,54],[55,56],[57,58,59,60,63,64,71,72,73,74],[61,62],[65],[66,67],[68],[69,70]]\n# V74 - V94\ngrp5 = [[75,76],[77,78],[79,80,81,84,85,92,93,94],[82,83],[86,87],[88],[89],[90,91]]\n# V95 - V107\ngrp6 = [[95,96,97,101,102,103,105,106],[98],[99,100],[104]]\n# V107 - V123\ngrp7 = [[107],[108,109,110,114],[111,112,113],[115,116],[117,118,119],[120,122],[121],[123]]\n# V124 - V137\ngrp8 = [[124,125],[126,127,128,132,133,134],[129],[130,131],[135,136,137]]\n# V138 - V163\ngrp9 = [[138],[139,140],[141,142],[146,147],[148,149,153,154,156,157,158],[161,162,163]]\n# V167 - V183\ngrp10 = [[167,168,177,178,179],[172,176],[173],[181,182,183]]\n# V184 - V216\ngrp11 = [[186,187,190,191,192,193,196,199],[202,203,204,211,212,213],[205,206],[207],[214,215,216]]\n# V217 - V238\ngrp12 = [[217,218,219,231,232,233,236,237],[223],[224,225],[226],[228],[229,230],[235]]\n# V240 - V262\ngrp13 = [[240,241],[242,243,244,258],[246,257],[247,248,249,253,254],[252],[260],[261,262]]\n# V263 - V278\ngrp14 = [[263,265,264],[266,269],[267,268],[273,274,275],[276,277,278]]\n# V220 - V272\ngrp15 = [[220],[221,222,227,245,255,256,259],[234],[238,239],[250,251],[270,271,272]]\n# V279 - V299\ngrp16 = [[279,280,293,294,295,298,299],[284],[285,287],[286],[290,291,292],[297]]\n# V302 - V321\ngrp17 = [[302,303,304],[305],[306,307,308,316,317,318],[309,311],[310,312],[319,320,321]]\n# V281 V315\ngrp18 = [[281],[282,283],[288,289],[296],[300,301],[313,314,315]]\n# V322 - V339\ngrp19 = [[322,323,324,326,327,328,329,330,331,332,333],[325],[334,335,336],[337,338,339]]\n\n\ngrp_list = [grp1,grp2,grp3,grp4,grp5,grp6,grp7,grp8,grp9,grp10,\n            grp11,grp12,grp13,grp14,grp15,grp16,grp17,grp18,grp19]\n\n\n\n\ndef clip_group(group,df):\n    \"\"\"\n      Selects the higher number of unique values from the same correlated variables\n      \n    \"\"\"\n    clipped_list = []\n    for i in group:\n        maximum = 0; \n        V_num = i[0]\n        for j in i:\n            n = df['V'+str(j)].value_counts().count()\n            if n>maximum:\n                maximum = n\n                V_num = j\n            \n        clipped_list.append(V_num)\n    \n        \n    print('Variables in the clipped_list: ',clipped_list)\n    return clipped_list\n\n\n\n# V variables that were decided to be used in the model as a result of the correlation were kept in the V_clipped_cols variable.\nV_clipped_cols = list()\nfor i in grp_list:\n    for j in clip_group(i,X_train):\n        V_clipped_cols.append(\"V\"+str(j))\n        \n\nfor i in range (1, 339):\n    name = \"V\"+str(i)\n    if name not in V_clipped_cols:\n        X_train.drop(\"V\"+str(i),axis=1, inplace=True)\n        X_test.drop(\"V\"+str(i),axis=1, inplace=True)","263e153a":"valid_card = pd.concat([X_train[['card1']], X_test[['card1']]])\nvalid_card = valid_card['card1'].value_counts()\nvalid_card_std = valid_card.values.std()\n\ninvalid_cards = valid_card[valid_card<=2]\n\nvalid_card = valid_card[valid_card>2]\nvalid_card = list(valid_card.index)\n\nX_train['card1'] = np.where(X_train['card1'].isin(X_test['card1']), X_train['card1'], np.nan)\nX_test['card1']  = np.where(X_test['card1'].isin(X_train['card1']), X_test['card1'], np.nan)\n\nX_train['card1'] = np.where(X_train['card1'].isin(valid_card), X_train['card1'], np.nan)\nX_test['card1']   = np.where(X_test['card1'].isin(valid_card), X_test['card1'], np.nan)\n\n\n# Making values \"nan\" if a value is not common in the Train and Test set\nfor col in ['card2','card3','card4','card5','card6']: \n    X_train[col] = np.where(X_train[col].isin(X_test[col]), X_train[col], np.nan)\n    X_test[col]  = np.where(X_test[col].isin(X_train[col]), X_test[col], np.nan)\n","8a1ed09e":"col_1 = 'card1'\ncol_2 = 'P_emaildomain'\ncol_3 = 'addr1'\n\n\nuser_id(col_1,col_2)\nuser_id(col_1+'_'+col_2,col_3)\nX_train.drop(col_1+'_'+col_2, axis = 1, inplace=True)\nX_test.drop(col_1+'_'+col_2, axis = 1, inplace=True)\n\nus_id = col_1 + '_' + col_2 + '_' + col_3\nX_train.rename(columns={us_id: 'userid'}, inplace=True)\nX_test.rename(columns={us_id: 'userid'}, inplace=True)","44726ec6":"for df in [X_train,X_test]:\n\n    df['OS_id_30'] = df['id_30'].str.split(' ', expand=True)[0]\n    df['version_id_30'] = df['id_30'].str.split(' ', expand=True)[1]\n\n    df['browser_id_31'] = df['id_31'].str.split(' ', expand=True)[0]\n    df['version_id_31'] = df['id_31'].str.split(' ', expand=True)[1]","bea482a4":"for df in [X_train,X_test]:\n\n    df['TransactionAmt'] = df['TransactionAmt'].astype('float32')\n    df['Trans_min_std'] = (df['TransactionAmt'] - df['TransactionAmt'].mean()) \/ df['TransactionAmt'].std()","aa223786":"X_train[\"lastest_browser\"] = np.zeros(X_train.shape[0])\nX_test[\"lastest_browser\"] = np.zeros(X_test.shape[0])\n\ndef setBrowser(df):\n    \n    df.loc[df[\"id_31\"]==\"samsung browser 7.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"opera 53.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"mobile safari 10.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"google search application 49.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"firefox 60.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"edge 17.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 69.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 67.0 for android\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 63.0 for android\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 63.0 for ios\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 64.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 64.0 for android\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 64.0 for ios\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 65.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 65.0 for android\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 65.0 for ios\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 66.0\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 66.0 for android\",'lastest_browser']=1\n    df.loc[df[\"id_31\"]==\"chrome 66.0 for ios\",'lastest_browser']=1\n    return df\n\nX_train=setBrowser(X_train)\nX_test=setBrowser(X_test)","65077646":"us_emails = ['gmail', 'net', 'edu']\n\nfor df in [X_train,X_test]:\n    for c in ['P_emaildomain', 'R_emaildomain']:\n\n        df[c + '_suffix'] = df[c].map(lambda x: str(x).split('.')[-1])\n        df[c + '_suffix'] = df[c + '_suffix'].map(lambda x: x if str(x) not in us_emails else 'us')","9f1ed5fc":"# Predicting foreign countries by exchange rate\nfor df in [X_train,X_test]:\n    \n    df['TransactionAmt_decimal_lenght'] = df['TransactionAmt'].astype(str).str.split('.', expand=True)[1].str.len()\n    df['cents'] = (df['TransactionAmt'] - np.floor(X_train['TransactionAmt'])).astype('float32')","601ef1a3":"p = 'P_emaildomain'\nr = 'R_emaildomain'\nunknown = 'email_not_provided'\n\ndef setDomain(df):\n    df[p] = df[p].astype('str')\n    df[r] = df[r].astype('str')\n    \n    df[p] = df[p].fillna(unknown)\n    df[r] = df[r].fillna(unknown)\n    \n    df['email_check'] = np.where((df[p]==df[r])&(df[p]!=unknown),1,0)\n\n    df[p+'_prefix'] = df[p].apply(lambda x: x.split('.')[0])\n    df[r+'_prefix'] = df[r].apply(lambda x: x.split('.')[0])\n    \n    return df\n    \nX_train=setDomain(X_train)\nX_test=setDomain(X_test)","c7edf8fe":"# Listing dates between '2017-10-01' and '2019-01-01 \ndates_range = pd.date_range(start='2017-10-01', end='2019-01-01')\n\n# US national holidays are listed between '2017-10-01' and '2019-01-01 \nus_holidays = calendar().holidays(start=dates_range.min(), end=dates_range.max())\n\nSTART_DATE = '2017-12-01'\nstartdate = datetime.datetime.strptime(START_DATE, \"%Y-%m-%d\")\n\n\n# The variable of the hour of day, day of week and day of month and month of year were created.\nfor df in [X_train,X_test]:\n    \n    df[\"Date\"] = df['TransactionDT'].apply(lambda x: (startdate + datetime.timedelta(seconds=x)))\n    df['_Weekdays'] = df['Date'].dt.dayofweek\n    df['_Dayhours'] = df['Date'].dt.hour\n    df['_Monthdays'] = df['Date'].dt.day\n    df['_Yearmonths'] = (df['Date'].dt.month).astype(np.int8) \n\n    \n    # Is the transaction done on holiday?\n    df['is_holiday'] = (df['Date'].dt.date.astype('datetime64').isin(us_holidays)).astype(np.int8)\n\n    df.drop(\"Date\", axis=1,inplace=True)","6e7a4cd1":"for col in ['ProductCD','M4']:\n    temp_dict = X_train.groupby([col])['isFraud'].agg(['mean']).reset_index().rename(columns={'mean': col+'_target_mean'})\n    temp_dict.index = temp_dict[col].values\n    temp_dict = temp_dict[col+'_target_mean'].to_dict()\n    \n    if col=='ProductCD':\n        X_train['ProductCD_1'] = X_train[col].map(temp_dict)\n        X_test['ProductCD_1']  = X_test[col].map(temp_dict)\n    else:\n        X_train['M4_1'] = X_train[col].map(temp_dict)\n        X_test['M4_1']  = X_test[col].map(temp_dict)\n        \n        \n# Dropping 'ProductCD' and 'M4'\nX_train.drop(['ProductCD','M4'], axis=1,inplace=True)\nX_test.drop(['ProductCD','M4'], axis=1,inplace=True)","a74873df":"for i in range(1,16):\n    if i in [1,2,3,5,9]:\n        continue\n    X_train['D'+str(i)] =  X_train['D'+str(i)] - X_train.TransactionDT\/np.float32(24*60*60)\n    X_test['D'+str(i)] = X_test['D'+str(i)] - X_test.TransactionDT\/np.float32(24*60*60)","2fa8a0b5":"for df in [X_train,X_test]:\n\n    df['mean_last'] = df['TransactionAmt'] - df.groupby('userid')['TransactionAmt'].transform(lambda x: x.rolling(10, 1).mean())\n    df['min_last'] = df.groupby('userid')['TransactionAmt'].transform(lambda x: x.rolling(10, 1).min())\n    df['max_last'] = df.groupby('userid')['TransactionAmt'].transform(lambda x: x.rolling(10, 1).max())\n    df['std_last'] = df['mean_last'] \/ df.groupby('userid')['TransactionAmt'].transform(lambda x: x.rolling(10, 1).std())\n\n    df['mean_last'].fillna(0, inplace=True, )\n    df['std_last'].fillna(0, inplace=True)\n\n    df['TransactionAmt_to_mean_card_id'] = df['TransactionAmt'] - df.groupby(['userid'])['TransactionAmt'].transform('mean')\n    df['TransactionAmt_to_std_card_id'] = df['TransactionAmt_to_mean_card_id'] \/ df.groupby(['userid'])['TransactionAmt'].transform('std')\n    \n    \n    # Replaces infinite values with 999\n    df = df.replace(np.inf,999)","94bba3cc":"factorize_categoric()\n\nnum_positiv(X_train,X_test)\n\nclass_freq(['addr1','card1','card2','card3','P_emaildomain'])\n\naggreg(['TransactionAmt','D4','D9','D10','D11','D15'],'userid','mean')\n\naggreg(['TransactionAmt','D4','D9','D10','D11','D15','C14'],'userid','std')\n\naggreg(['C'+str(x) for x in range(1,15) if x!=3],'userid','mean')\n\naggreg(['M'+str(x) for x in range(1,10) if x!=4],'userid','mean')\n\naggreg_uniq(['P_emaildomain','dist1','id_02','cents','C13','V314','V127','V136','V309','V307','V320'],'userid')","4591f5fd":"# Reducing the memory usage\nX_train = reduce_mem_usage(X_train)\nX_test = reduce_mem_usage(X_test)","9a19505f":"# Dropping userid to prevent overfitting\nX_train.drop(\"userid\", axis=1, inplace=True)\nX_test.drop(\"userid\", axis=1, inplace=True)\n\n# Dropping target variable from Train set\nX_train.drop(\"isFraud\", axis=1, inplace=True)","146344b1":"# Splitting Train set\nX_train1, X_test1, y_train1, y_test1 = train_test_split(X_train, y_train, test_size=0.33, random_state=42)","2664197a":"# Parameter Tuning\nmodel = CatBoostClassifier(task_type=\"GPU\")\n\ngrid = {'learning_rate': [0.1, 0.3],\n        'depth': [10, 12, 14],\n        'l2_leaf_reg': [9, 11, 13]}\n\ngrid_search_result = model.grid_search(grid, \n                                       X=X_train1, \n                                       y=y_train1)","9581a365":"# To use categoric features in Catboost\ncategoric_features = ['card1','card2','card3','card4','card5','card6','addr1','addr2',\n                      'P_emaildomain','R_emaildomain',\n                      'M1','M2','M3','M5','M6','M7','M8','M9',\n                      'id_01','id_02','id_03','id_04','id_05','id_06','id_07','id_08','id_09','id_10','id_11','id_12','id_13','id_14','id_15','id_16','id_17','id_18','id_19',\n                      'id_20','id_21','id_22','id_23','id_24','id_25','id_26','id_27','id_28','id_29','id_30','id_31','id_32','id_33','id_34','id_35','id_36','id_37','id_38',\n                      'DeviceType','DeviceInfo',\n                      'OS_id_30','version_id_30','browser_id_31','version_id_31','lastest_browser','P_emaildomain_suffix','R_emaildomain_suffix','email_check',\n                      'P_emaildomain_prefix','R_emaildomain_prefix','_Weekdays','_Dayhours','_Monthdays','_Yearmonths','is_holiday','ProductCD_1','M4_1','TransactionAmt_decimal_lenght','cents']\n\ncategoric_features_index = [X_train.columns.get_loc(c) for c in categoric_features if c in X_train]\n\nX_train[categoric_features] = X_train[categoric_features].astype('int')\n\nX_test[categoric_features] = X_test[categoric_features].astype('int')","928926f6":"# To use for KFOLD\nSTART_DATE = datetime.datetime.strptime('2017-11-30', '%Y-%m-%d')\nX_train['DT_M'] = X_train['TransactionDT'].apply(lambda x: (START_DATE + datetime.timedelta(seconds = x)))\nX_train['DT_M'] = (X_train['DT_M'].dt.year-2017)*12 + X_train['DT_M'].dt.month \n\nX_test['DT_M'] = X_test['TransactionDT'].apply(lambda x: (START_DATE + datetime.timedelta(seconds = x)))\nX_test['DT_M'] = (X_test['DT_M'].dt.year-2017)*12 + X_test['DT_M'].dt.month ","92a09505":"# To divide data for same shape in KFOLD\ndf_train = X_train.drop(X_train.index[590520:])\ny_train_drop = y_train.drop(y_train.index[590520:])","7200a286":"groups = df_train['DT_M']\nkf = KFold(n_splits=6, random_state=42)\nkf.get_n_splits(df_train, y_train_drop, groups)\n\npreds = np.zeros(len(X_test))\n\npred_fet = np.empty((0))\n\ncount = 0\n\nfor train_index, test_index in kf.split(df_train, y_train_drop, groups):\n    print(\"\\nTRAIN:\", train_index, \"TEST:\", test_index)\n    X_train_df, X_test_df = df_train.iloc[train_index], df_train.iloc[test_index]\n    y_train_df, y_test_df = y_train_drop.iloc[train_index], y_train_drop.iloc[test_index]\n    \n    clf = CatBoostClassifier(eval_metric = \"AUC\",\n                             use_best_model = True,\n                             depth = 10,\n                             iterations = 1500,\n                             l2_leaf_reg = 5, \n                             learning_rate = 0.15, \n                             task_type = \"GPU\",\n                             devices = \"0:1\",\n                             one_hot_max_size = 40)\n\n    h = clf.fit(X_train_df,y_train_df,\n                eval_set=[(X_test_df,y_test_df)],\n                cat_features= categoric_features_index)\n    \n    preds += clf.predict_proba(X_test)[:,1]\/kf.n_splits\n    \n    pred_fet_ite = clf.predict(X_test_df)\n    \n    pred_fet = np.concatenate((pred_fet, pred_fet_ite))\n    \n    count = count + 1\n   \n    if count <=5:\n        del h, clf\n    \n        x = gc.collect()\n    print('#'*20)","1f1e7c35":"#\u00a0Confusion matrix and Classification report\npred = clf.predict(X_test1)\n\nfpr, tpr, thresholds = metrics.roc_curve(y_train_drop, pred_fet, pos_label=2)\n\nmetrics.auc(fpr, tpr)\n\nprint(metrics.confusion_matrix(y_train_drop, pred_fet))\nprint(metrics.classification_report(y_train_drop, pred_fet))","68a6e660":"preds1 = clf.predict_proba(X_test)[:,1]","243bf05c":"sample_submission = pd.read_csv('..\/input\/ieee-fraud-detection\/sample_submission.csv')\nsample_submission.isFraud = preds1\nsample_submission.to_csv('sub_catboost.csv',index=False)","892a914f":"import matplotlib.pyplot as plt\nimport seaborn as sns\n\nfeature_imp = pd.DataFrame(sorted(zip(clf.feature_importances_,X_train.columns)), columns=['Value','Feature'])\n\nplt.figure(figsize=(20, 10))\nsns.barplot(x=\"Value\", y=\"Feature\", data=feature_imp.sort_values(by=\"Value\", ascending=False).iloc[:50])\nplt.title('Catboost Model Most Important Features')\nplt.tight_layout()\nplt.show()","e56d5890":"# Model ","29fdccd8":"# Model  and Hyperparameters Tuning","5e803968":"#\u00a0Creating New Features by Using Aggregation Functions","ce38b92f":"# Rolling Window Aggregations of Last Transactions\n\nRolling window aggregations of window size 10 for the transaction amount are performed using these formulas. These \nfeatures are important as they give almost all the necessary information about the distribution of the user\u2019s last 10\ntransaction amounts. Setting minimum acceptable window size as 1 provides us not to have too many missing values for \nthese features, as there is the observation itself in case all the previous observations are missing.","c25e22ef":"# Functions","c06a3acf":"# Grouping the V-variables \n\nWe grouped the V variables according to the NaN values they contained and looked at the correlations of the V variables in the same group. we determined 70% as the correlation value.  Re-grouped those with the same correlations. We selected variables with the highest number of unique value among the variables with the same correlation and removed the others from the data set.","14376864":"### Country Extraction\n\nDetermining the countries where the transactions are made according to the mail extensions.","f1f89558":"### Rescaling D columns\n\nThe D Columns are \"time deltas\" belong to the past. Therfore they are normalized to  transform the D Columns into their point in the past.","b80df7de":"### Standardization of TransactionAmt\nConverts the type of TransactionAmt to float32. Subtracts the mean from the values in TransactionAmt and divides it by its standard deviation. In this way, standardization has been made.","7d52cea8":"### Mean Encoding\n\nFraud ratios with respect to ProductCD and M4 categories. By doing this we used the target variable as the basis to generate the new encoded feature. ","c5dc18c5":"# Feature Importances","ec7b591b":"### Valid and invalid cards\nCards with less than 2 frequencies are defined as invalid cards while those with more than 2 were defined as valid. If a value is not common in the Train and Test set, these values were named as \"nan\". Finally, we named all invalid and \"nan\" values as \"nan\" while the others were valid.","948dee3f":"### Extracting browser and versions\nIt separates the browser, device and versions of the processes and assigns them to new variables.","fe8af712":"# Feature Engineering ","8870686a":"### Latest Version Control\nChecking the devices if they have the latest version or not. If they use the latest version, they are assigned as 1 otherwise 0.","e1191541":"# Predicting Probabilities of Test Set","485829d1":"#\u00a0Importing Data","5e7dc302":"### Defining Time Variable and US Holidays","15823aa2":"### Matching Receiver and Purchaser Email Domains\n\nR_emaildomain and p_emaildomain were compared. If P_emaildomain and R_emaildomain are the same and are not null, we assign 1. Otherwise we assign 0.","60372336":"### Creating Userid\nDetermining the person to whom each process belongs to similar values by converting the features to string and combining them with \"_\".","ab4d3ef1":"# Submitting the Predicted Values"}}