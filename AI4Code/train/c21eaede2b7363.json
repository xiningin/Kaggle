{"cell_type":{"df55ec44":"code","035cff34":"code","418ed236":"code","1731e1a7":"code","176e7730":"code","7385b760":"code","a1d40953":"code","f51a5bb2":"markdown","a6affdae":"markdown","acd3ee4a":"markdown","de2934b2":"markdown","304916af":"markdown","8d4b31ba":"markdown","281811d4":"markdown"},"source":{"df55ec44":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","035cff34":"data = pd.read_csv('\/kaggle\/input\/weather-dataset-rattle-package\/weatherAUS.csv')\ndata","418ed236":"# Map rain data\nyes_no = {\"Yes\": 1, \"No\": 0}\ndata['RainToday'] = data['RainToday'].map(yes_no)\ndata['RainTomorrow'] = data['RainTomorrow'].map(yes_no)\n\ncategorical = []\ncontinuous = []\n\n# Seperate data by type\nfor col in data.columns:\n    if(data[col].dtype == 'float64'):\n        continuous.append(col)\n    else:\n        categorical.append(col)\n\nprint(categorical)\nprint(continuous)","1731e1a7":"import matplotlib.pyplot as plt\n\n'''\nfor type in continuous:\n    rain_count = {}\n    dry_count = {}\n    for pair in data[[type, 'RainTomorrow']].values:\n        if pair[0] in rain_count:\n            rain_count[pair[0]] += pair[1]\n        else:\n            rain_count[pair[0]] = pair[1]\n\n        if pair[0] in dry_count:\n            dry_count[pair[0]] += int(pair[1] == 0)\n        else:\n            dry_count[pair[0]] = int(pair[1] == 0)\n\n\n    x_rain = []\n    y_rain = []\n\n    for t in sorted(list(rain_count.keys())):\n        x_rain.append(t)\n        y_rain.append(rain_count[t])\n\n    x_dry = []\n    y_dry = []\n\n    for t in sorted(list(dry_count.keys())):\n        x_dry.append(t)\n        y_dry.append(dry_count[t])\n\n    plt.title('Distribution Dry\/Rain Tomorrow Against ' + str(type))\n    plt.xlabel(type)\n    plt.ylabel('Frequency')\n    plt.bar(x_dry,y_dry, color='grey', label='Dry', width=1.0)\n    plt.bar(x_rain,y_rain, color='blue', label='Rain', width=1.0)\n    plt.legend()\n    plt.show()\n'''","176e7730":"# Get Temperature difference between min temp and max temp\nimport numpy as np\nto_replace = np.full(len(data.index), 'NA')\nfor i in data[['MaxTemp', 'MinTemp']].index:\n    to_replace[i] = data['MaxTemp'][i] - data['MinTemp'][i]\n\n# Put new col in dataframe\ndata['TempDiff'] = to_replace","7385b760":"# Drop NA and the Temperatures we replaced with their difference\ndata = data.dropna(how='any')\ndata = data.drop(['MinTemp','MaxTemp'], axis=1)\n\n# Save output values to split later\ny = data['RainTomorrow'].values\ndel data['RainTomorrow']\ncontinuous.remove('RainTomorrow')\n\ndata = data.drop(categorical, axis=1)","a1d40953":"from sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix\n\n# Use train_test_split to get test and training data\nX_train, X_test, Y_train, Y_test = train_test_split(data, y, test_size=0.3)\n\n# Scale our data\nscaler = StandardScaler()\nX_train = scaler.fit_transform(X_train)\nX_test = scaler.transform(X_test)\n\nclassifier = LogisticRegression(random_state=1)\nclassifier.fit(X_train,Y_train)\n\npredictions = classifier.predict(X_test)\nconfusion = confusion_matrix(Y_test, predictions)\n\n# Accuracy is correct guesses \/ total guesses\nprint(\"Accuracy: \" + str(confusion[0][0]\/(confusion[0][0] + confusion[1][0])))\n","f51a5bb2":"# Data Cleaning\nFirst, I loaded the dataframe from the csv.","a6affdae":"Next, I mapped RainToday and RainTomorrow to 0 and 1 and seperated categorical data from continuous data.","acd3ee4a":"# Exploratory Data Analysis\nNext, I took a look at the distributions of the continuous data, seperating dry (RainTomorrow = 0) from rain (RainTomorrow = 1) days.","de2934b2":"# Predictions\nI then scaled my continuous data and used logistical regression to make predictions on whether or not it will rain tomorrow.","304916af":"![1.png](attachment:1.png)\n![2.png](attachment:2.png)\n![3.png](attachment:3.png)\n![4.png](attachment:4.png)\n![5.png](attachment:5.png)\n![6.png](attachment:6.png)\n![7.png](attachment:7.png)\n![8.png](attachment:8.png)\n![9.png](attachment:9.png)\n![10.png](attachment:10.png)\n![11.png](attachment:11.png)\n![12.png](attachment:12.png)\n![13.png](attachment:13.png)","8d4b31ba":"I then dropped the NA values and saved RainTommorow to use in the testing phase. Later I plan on incorporating categorical data in the predictions, but for know I just ignored them.","281811d4":"I replaced the Max and Min temperatures with the temperature difference between these two values in order to take drastic temperature changes into account when making the predictions."}}