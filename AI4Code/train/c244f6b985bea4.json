{"cell_type":{"f0e5ca0b":"code","38e1696c":"code","ad91b93c":"code","be089e81":"code","ff08280b":"code","83dcebb7":"code","8c2ef34f":"code","e952e442":"code","02c6a000":"code","8a11426b":"code","5e6784e0":"code","efde4e73":"code","a32ac3d6":"code","e60cd64e":"code","368da3ea":"code","46e00ffb":"code","568ae7ec":"code","a65f6bc3":"code","91f204b4":"code","8cd9038f":"code","fb92038c":"code","05aa53df":"code","a95f3b9e":"code","8bc1a098":"markdown","b6a3cbb0":"markdown","90ba7aa7":"markdown","b152f9e4":"markdown","6dc06bc6":"markdown","9aae3105":"markdown","0868185e":"markdown","6fe22e63":"markdown","561d2fe6":"markdown","fc8644da":"markdown","12fc0fdf":"markdown","5205c039":"markdown","6880628d":"markdown","811b2555":"markdown","02ed47d3":"markdown","96cc9748":"markdown","515ea173":"markdown","0f9a3c99":"markdown","cda61e87":"markdown"},"source":{"f0e5ca0b":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport matplotlib.colors as mcolors\nimport seaborn as sns\nimport random\nfrom IPython.display import set_matplotlib_formats\nimport matplotlib as mpl\nfrom PIL import Image\nfrom wordcloud import WordCloud, STOPWORDS, ImageColorGenerator\nimport requests\nfrom io import BytesIO\nimport folium\nstopwords = set(STOPWORDS)\n\nmpl.style.use('ggplot') # optional: for ggplot-like style\n%matplotlib inline\nfrom matplotlib.lines import Line2D\ncolor_pie = ['#132743','#d7385e','#edc988']\ncustom_lines = [Line2D([0], [0], color=\"#00587a\", lw=4),\n                Line2D([0], [0], color=\"#206a5d\", lw=4),\n                Line2D([0], [0], color=\"#61b15a\", lw=4)]\n\n","38e1696c":"def get_tweets(month):\n    \"\"\"\n    get_tweets: access a Repos and get data\n    Parameters:\n        month: str\n            Month number From 01 to 31.\n        cols: list-like or callable, optional\n            Return a subset of the columns.\n            It's an alice of usecols in pandas read_csv func.\n        name: array-like, optional\n            List of column names to use.\n            It's an alice of names in pandas read_csv func.\n        \n    Return: DataFrame.\n    Need more update\n    \"\"\"\n    repos_path = \"https:\/\/raw.githubusercontent.com\/lopezbec\/COVID19_Tweets_Dataset\/master\/{f}\/2020_{m}\/2020_{m}_{d}_{p}_{f}.csv\"\n    folders= {'Summary_Details':{'col':['Tweet_ID','Language','Country','Date Created']\n                                 ,'name':None}\n              ,'Summary_Hashtag':{'col':['Hashtag','Tweet_ID']\n                                  ,'name':['Tweet_ID','Hashtag']}\n              ,'Summary_Sentiment':{'col':['Tweet_ID','Sentiment_Label']\n                                    ,'name':None}\n             }\n\n    days= [str(i).zfill(2) for i in range(1,31)]\n    parts= [str(i).zfill(2) for i in range(0,24)]\n    part_df= pd.DataFrame()\n    day_df = pd.DataFrame()\n    month_df = pd.DataFrame()\n    for day in days:\n        day_df.drop(day_df.index,inplace=True)\n        for part in parts:\n            part_df.drop(part_df.index,inplace=True)\n            i=0\n            for folder,arg in folders.items():\n                i+=1\n                try:\n                    print('start merge parts')\n                    if i==1:\n                        part_df = pd.read_csv(repos_path.format(f= folder,m= month,d= day,p= part),\n                                              header=0\n                                              ,encoding = \"ISO-8859-1\"\n                                              ,names=arg['name']\n                                              ,usecols=arg['col']\n                                              ,dtype={'Tweet_ID':str} \n                                              ,na_values=''\n                                              ,keep_default_na=False\n                                              ,low_memory=False)\n                    else:\n                        part_df = part_df.merge(pd.read_csv(repos_path.format(f= folder,m= month,d= day,p= part),\n                                                            header=0\n                                                            ,encoding = \"ISO-8859-1\"\n                                                            ,names=arg['name']\n                                                            ,usecols=arg['col']\n                                                            ,dtype={'Tweet_ID':str} \n                                                            ,na_values=''\n                                                            ,keep_default_na=False\n                                                            ,low_memory=False\n                                                           ),\n                                                 how='outer',on='Tweet_ID'\n                                               ).drop_duplicates()\n                        \n                #except AssertionError as error:\n                except:\n                    print('error')\n                    del(part_df)\n                    break\n\n                \n            print('append {p} to {d} day'.format(p=part,d=day))\n            day_df = day_df.append(part_df, ignore_index=True)\n        print('save {d} day to kaggle work'.format(d=day))\n        #df_day.to_csv('\/kaggle\/working\/covid19_{d}_{m}.csv'.format(d=day,m=month),index=False)\n        print('start append to df_month')\n        month_df = month_df.append(day_df,ignore_index=True)\n    month_df.to_csv('\/kaggle\/working\/covid19_{m}.csv'.format(m=month),index=False)\n    del(month_df)\n    del(day_df)\n    del(part_df)","ad91b93c":"jul_df = pd.read_csv('..\/input\/covid19-dataset\/covid19_07.csv',parse_dates=True)\njul_df.head()","be089e81":"aug_df = pd.read_csv('..\/input\/covid19-dataset\/covid19_08.csv',parse_dates=True)\naug_df.head()\n","ff08280b":"country_df = pd.read_csv(\"..\/input\/countries-coord\/countries_coord.csv\")\ncountries_name= country_df.name.str.capitalize().tolist()\ncountries_lang= country_df.lang.tolist()\ncountries_lat= country_df.lat.tolist()\ncountries_code= country_df.code2.str.upper().tolist()\ncountries_name_dict = dict(zip(countries_code,countries_name))\ncountries_lang_dict = dict(zip(countries_code,countries_lang))\ncountries_lat_dict = dict(zip(countries_code,countries_lat))","83dcebb7":"country_df.head()","8c2ef34f":"def sent_countries(df,countries='all'):\n    \"\"\"\n    sent_countries(df,countries):\n    return sentiment level for each country\n    Parameters:\n        df: DataFrame\n            dataframe to work on.\n        countries: str, list-like, optional\n            if countries= 'all', no filter will done on df.\n            if countries is a list type, filter a df on it, value in the list in country codes format\n                like {\"EG\":\"Egypt\", \"AU\":\"Australia\"}\n            this is url that may help you to find your country code \"https:\/\/countrycode.org\/\"\n                    \n    Return: DataFrame\n        sentiment level for your criteria    \n    \"\"\"  \n    if type(countries) is list:\n        countries = [str(country).upper() for country in countries]\n        filtered_df= df.query('Country in @countries')\n    elif countries==5:\n        top5_countries = df.groupby('Country')[['Tweet_ID']].count()\\\n                           .sort_values(by='Tweet_ID', ascending=False).index[:countries]\n        filtered_df = df.query('Country in @top5_countries')\n    else:\n        filtered_df = df.copy()\n    \n    filtered_df = filtered_df.groupby(['Country','Sentiment_Label'],as_index=False)['Tweet_ID'].count()\n    filtered_df.rename(columns={'Tweet_ID':'Num_of_tweets'}, inplace=True)\n    filtered_df['Country_lat'] = filtered_df['Country'].map(countries_lat_dict,na_action=np.nan)\n    filtered_df['Country_lang'] = filtered_df['Country'].map(countries_lang_dict,na_action=np.nan)\n    filtered_df['Country_name'] = filtered_df['Country'].map(countries_name_dict,na_action=np.nan)\n    filtered_df.dropna(inplace=True)\n    return filtered_df","e952e442":"def sent_languages(df,lang='all'):\n    \"\"\"\n    sent_languages(df,lang):\n    return sentiment level for each country\n    Parameters:\n        df: DataFrame\n            dataframe to work on.\n        lang: str, list-like, optional\n            if lang= 'all', no filter will done on df.\n            if lang is a list type, fillter a df on it, value in the list in shortcut format\n                like {\"en\":\"English\", \"ar\":\"Arabic\"}\n    Return: DataFrame\n        sentiment level for your criteria    \n    \"\"\"  \n    filtered_df= df.copy()\n    if type(lang) is list:\n        lang = [str(i).lower() for i in lang]\n        filtered_df= filtered_df.query('Language in @lang')\n    elif lang==5:\n        top5_lang = df.groupby('Language')[['Tweet_ID']].count()\\\n                           .sort_values(by='Tweet_ID', ascending=False).index[:lang]\n        filtered_df = df.query('Language in @top5_lang')\n    else:\n        filtered_df = df.copy()\n        \n    filtered_df = filtered_df.groupby(['Language','Sentiment_Label'],as_index=False)['Tweet_ID'].count()\n    filtered_df.rename(columns={'Tweet_ID':'Num_of_tweets'}, inplace=True)\n    filtered_df.dropna(inplace=True)\n    return filtered_df","02c6a000":"\ndef add_value_labels(ax,rot=0,ha='center'):\n    \"\"\"\n    add_value_labels(ax, spacing=5):\n        Add labels to the end of each bar in a bar chart.\n\n    Parameters:\n        ax: (matplotlib.axes.Axes)\n            The matplotlib object containing the axes of the plot to annotate.\n        spacing: (int)\n            The distance between the labels and the bars.\n    Return: None\n    \"\"\"\n\n    # For each bar: Place a label\n    for rect in ax.patches:\n        # Get X and Y placement of label from rect.\n        y_value = rect.get_height()\n        x_value = rect.get_x() + rect.get_width()\/2\n\n        # Number of points between bar and label.\n        space = 2\n        # Vertical alignment for positive values\n        va = 'bottom'\n\n        # If value of bar is negative: Place label below bar\n        if y_value < 0:\n            # Invert space to place label below\n            space *= -1\n            # Vertically align label at top\n            va = 'top'\n\n        # Use Y value as label\n        label =  y_value.astype('int64') \n        #\"{:.1f}\".format(y_value)  format number with one decimal place\n        \n        # Create annotation\n        ax.annotate(\n            label,                      # Use `label` as label\n            (x_value, y_value),         # Place label at end of the bar\n            fontsize=12,\n            xytext=(0, space),          # Vertically shift label by `space`\n            textcoords=\"offset points\", # Interpret `xytext` as offset in points\n            rotation=rot,\n            ha=ha,                # Horizontally center label\n            va=va)                      # Vertically align label differently for positive and negative values.","8a11426b":"def timeline(df):\n    \"\"\"\n    timeline(df):\n        Handle datetime and prepair a dataframe to be drawn as lineplot\n    Prameters:\n        df: DataFrame\n    Return:\n        Dataframe with percent of sentiment\n    \"\"\"\n    df['Date Created']= pd.to_datetime(df['Date Created'],format=\"%a %b %d %X %z %Y\")\n    df = df[['Date Created','Sentiment_Label']].value_counts()\n    df =df.unstack(level='Sentiment_Label')\n    df = df.resample('D').sum()\n    return df","5e6784e0":"def word_cloud(df,path=None,bg_color=\"black\"):\n    \"\"\"\n    word_cloud(df,path=None,bg_color=\"black\")\n        plot wordcloud\n    parameters:\n        df: (pandas sereis)\n            dataframe to draw\n        path: (str) optional\n            path of mask img\n        bg_color:(str)\n            background color\n    return:\n        None\n    \"\"\"\n    # read the mask \/ color image taken from\n    if path is None:\n        path = \"https:\/\/i.imgur.com\/u94Fxd3.jpg\"\n    response = requests.get(path)\n    img = Image.open(BytesIO(response.content))\n    mask_coloring = np.array(img)\n\n    \n    text= ' '.join(df.to_list())\n    wc = WordCloud(background_color=bg_color, max_words=None, mask=mask_coloring,\n                   stopwords=stopwords, contour_width=1, contour_color='steelblue')\n\n    # generate word cloud\n    wc.generate(text)\n\n    # create coloring from image\n    image_colors = ImageColorGenerator(mask_coloring)\n\n    # show\n    plt.figure(figsize=(16,10))\n    # recolor wordcloud and show\n    plt.imshow(wc.recolor(color_func=image_colors), interpolation=\"bilinear\")\n\n    #plt.imshow(wc, interpolation='bilinear')\n\n    plt.axis('off')\n    plt.show()","efde4e73":"def world_map(df):\n    \"\"\"\n    world_map(df)\n        plot word map\n    parameters:\n        df: (dataFrame)\n            dataframe to draw\n    return:\n        map object\n    \"\"\"\n    max_num = df['Num_of_tweets'].max()\n    \n    world_map = folium.Map((0,0),zoom_start=2)\n\n    fg_1 = folium.FeatureGroup(name=\"Negative\").add_to(world_map)\n    fg_2 = folium.FeatureGroup(name=\"Positive\").add_to(world_map)\n    fg_3 = folium.FeatureGroup(name=\"Neutral\").add_to(world_map)\n\n    for index, row in df.iterrows():\n        if row['Sentiment_Label']=='negative':\n            folium.CircleMarker(\n                [row['Country_lang'],row['Country_lat']],\n                radius=5 + 5*(row['Num_of_tweets']\/max_num), # define how big you want the circle markers to be\n                popup=\"{n} \\n Negative: {v}\".format(n=row['Country_name'],v=row['Num_of_tweets']),\n                color='red',\n                fill=True\n                ,fill_color='red'\n                ).add_to(fg_1)\n        elif row['Sentiment_Label']=='positive':\n            folium.CircleMarker(\n                [row['Country_lang'],row['Country_lat']],\n                radius=5 + 5*(row['Num_of_tweets']\/max_num), # define how big you want the circle markers to be\n                popup=\"{n} \\n Positive: {v}\".format(n=row['Country_name'],v=row['Num_of_tweets']),\n                color='blue',\n                fill=True\n                ,fill_color='blue'\n                ).add_to(fg_2)\n        else:\n            folium.CircleMarker(\n                [row['Country_lang'],row['Country_lat']],\n                radius=5 + 5*(row['Num_of_tweets']\/max_num), # define how big you want the circle markers to be\n                popup=\"{n} \\n Neutral: {v}\".format(n=row['Country_name'],v=row['Num_of_tweets']),\n                color='green',\n                fill=True\n                ,fill_color='green'\n                ).add_to(fg_3)\n\n\n    # display world map\n    folium.LayerControl(collapsed=False).add_to(world_map)\n\n    return world_map","a32ac3d6":"df = sent_countries(jul_df,5)\nplt.figure(figsize=(12,8))\nax = sns.barplot(x='Country',y='Num_of_tweets',hue= 'Sentiment_Label',data=df,palette = 'viridis')\n\nadd_value_labels(ax)\nax.set_yscale('log')\nax.set_xlabel(xlabel = 'Countries', fontsize = 16)\nax.set_ylabel(ylabel = 'Number of tweets', fontsize = 16)\nax.set_title(label = 'sentimental analysis for top 5 countries at july 2020', fontsize = 20)\nplt.show()","e60cd64e":"df = sent_languages(jul_df,lang=5)\n\n\nplt.figure(figsize=(12,8))\nax = sns.barplot(x='Language',y='Num_of_tweets',hue= 'Sentiment_Label',data=df,palette = 'magma')\nadd_value_labels(ax)\nplt.xlabel( 'Language', fontsize = 16)\nplt.ylabel('Number of tweets', fontsize = 16)\nplt.title(label = 'sentimental analysis for top 5 language at july 2020', fontsize = 20)\nplt.show()\n","368da3ea":"df_sent = jul_df['Sentiment_Label'].value_counts()\nax = df_sent.plot(kind='pie',\n            figsize=(15, 6)\n            ,fontsize=16\n            ,colors=color_pie\n            ,autopct='%1.1f%%' \n            ,startangle=90\n            ,shadow=True       \n            ,labels=None         # turn off labels on pie chart\n            ,pctdistance=1.2    # the ratio between the center of each pie slice and the start of the text generated by autopct \n            )\n# scale the title up by 12% to match pctdistance\nplt.title('Sentiment of covid19 tweets at july 2020', y=1.12, fontsize = 20) \nplt.axis('equal') \nplt.ylabel('')\n# add legend\nplt.legend(labels=df_sent.index,title='Sentiment_label', loc='upper right') \n\nplt.show()","46e00ffb":"time_jul_df = timeline(jul_df)\nplt.figure(figsize=(12,8))\nsns.lineplot(data = time_jul_df,dashes=True, linewidth=2.5,palette=\"viridis\")\nplt.xticks(rotation=90)\nplt.xlabel(\"\", fontsize = 16)\nplt.ylabel(\"# of tweets\", fontsize = 16)\nplt.legend(loc='best',title='Sentiment_label')\nplt.title(\"Timeline for covid19's sentiment at july 2020\", fontsize = 20)\nplt.show()","568ae7ec":"hash_df = jul_df.copy()\nstop_covid=['covid','covid19','covid-19','corona','coronavirus']\nhash_df['Hashtag'] = hash_df['Hashtag'].astype(str)\nhash_df.loc[:,'Hashtag'] = hash_df.loc[:,'Hashtag'].apply(lambda x: x[1:].lower() if len(x)>1 else '')\nhashtags = hash_df.query('Hashtag not in @stop_covid').reset_index(drop=True)\npos_hash = hashtags.loc[hashtags['Sentiment_Label']=='positive','Hashtag']\nneg_hash = hashtags.loc[hashtags['Sentiment_Label']=='negative','Hashtag']\nneut_hash = hashtags.loc[hashtags['Sentiment_Label']=='neutral','Hashtag']\npos = set(pos_hash.values)\nneg = set(neg_hash.values)\nneut = set(neut_hash.values)\nresult = pos.intersection(neg, neut)\n","a65f6bc3":"pos_hash = pos_hash[~pos_hash.isin(result)]\nneg_hash = neg_hash[~neg_hash.isin(result)]\nneut_hash = neut_hash[~neut_hash.isin(result)]","91f204b4":"word_cloud(neg_hash)","8cd9038f":"word_cloud(neut_hash)","fb92038c":"word_cloud(pos_hash)","05aa53df":"world_map(sent_countries(jul_df))","a95f3b9e":"time_aug_df = timeline(aug_df)\ntime_line_df = pd.concat([time_jul_df,time_aug_df])\nplt.figure(figsize=(12,8))\nsns.lineplot(data = time_line_df,dashes=True, linewidth=2.5,palette=\"viridis\")\nplt.xticks(rotation=90)\nplt.xlabel(\"\", fontsize = 16)\nplt.ylabel(\"# of tweets\", fontsize = 16)\nplt.legend(loc='best',title='Sentiment_label')\nplt.title(\"Timeline for covid19's sentiment from July to August 2020\", fontsize = 20)\nplt.show()","8bc1a098":"<div><img src=\"https:\/\/i.imgur.com\/hfaK7bu.jpeg\" ><\/div>","b6a3cbb0":"<h3 style=\"color:#61b15a\"> Postive tags:<\/h3>\n","90ba7aa7":"get_tweets('07')\nget_tweets('08')\nget_tweets('09')\nget_tweets('10')","b152f9e4":"<h2> Data preprocessing","6dc06bc6":"## World map","9aae3105":"## wordcloud","0868185e":"<h1 style=\"color:red;text-align: center;\"> Covid-19 Analysis <\/h1>","6fe22e63":"### 3. Summary_Hashtag:\n![image.png](attachment:image.png)","561d2fe6":"# Read Covid19's tweets from Github repos\n    This is the link from which we will collect covid19's tweets dataset:\n* [github.com\/lopezbec\/COVID19_Tweets_Dataset](http:\/\/)\n<p>This repository contains an ongoing collection of tweets associated with the novel<br> coronavirus COVID-19 since January 22nd, 2020.<\/p>\n<h3>We will work on just 2 months[Jul,Aug], and only three datasets:<\/h3>\n<ol> \n<li>Summry_Details.<\/li>\n<li>Summry_Sentiment.<\/li>\n<li>Summry_Hashtag.<\/li>\n<\/ol>\nYou can edit the code and run any # months you want.","fc8644da":"<h3 style=\"color:#206a5d\"> Neutral tags:<\/h3>\n","12fc0fdf":"## Helping libs","5205c039":"<p> <span style=\"color:red\">Coronaviruses<\/span> are a group of related RNA viruses that cause diseases in mammals and birds.<br> In humans and birds, they cause respiratory tract infections that can range from mild to lethal<\/p>","6880628d":"<h3> Read countries' coordinates and name <\/h2>\n<p>To map it with country code<p>","811b2555":"<h2> Data analysis in July <\/h2>","02ed47d3":"## Read, manipulate and write the Datasets to kaggle after mergeing it, so we can download it later.","96cc9748":"<h3 style=\"color:#00587a\"> Negative tags:<\/h3>\n","515ea173":"## Read Covid19 data","0f9a3c99":"### 2. Summary_Sentiment:\n![image.png](attachment:image.png)","cda61e87":"<h2> Features Description:<\/h2>\n<ol>\n<li>Summary_Details:<\/li>\n\n![image.png](attachment:image.png)"}}