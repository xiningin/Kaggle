{"cell_type":{"9490d4c6":"code","6e6e01c8":"code","d64fb6e6":"code","3ca1698b":"code","6ccc1017":"code","971f9291":"code","ad00bc9c":"code","d1b62ff4":"code","fe592366":"code","b7385b16":"code","3a596fdd":"code","baa44fc2":"code","d3c38b43":"markdown","1806c601":"markdown","4b561639":"markdown","33303862":"markdown","37ff1a7a":"markdown","dc16a34b":"markdown","ff3a3d7e":"markdown"},"source":{"9490d4c6":"from math import pi, sqrt\n\nimport numpy as np # we will use this later, so import it now\n\nfrom bokeh.io import output_notebook, show\nfrom bokeh.plotting import figure","6e6e01c8":"class propellent:\n    def __init__( self ):\n        self.density = None # g\/mm3\n        self.a = None # mm\/s\n        self.n = None # is exponential no units \n        self.k = None # ratio of specific heats\n        self.isp = None # seconds\n        \n    def check( self ):\n        if None in self.__dict__.values():\n            raise AttributeError(\"All Attributes of the propellent class must be defined\")\n            \n    def burnRate( self, pressure ):\n        return( self.a * pressure ** self.n )","d64fb6e6":"kickstart = propellent()\n\nkickstart.density = 0.001689 # g\/mm3\nkickstart.a = 3.0412 # mm\/s\nkickstart.n = 0.36915 # is exponential no units \nkickstart.k = 1.4 # ratio of specific heats\nkickstart.c_star = 1844 # m\/s\nkickstart.isp = 225 # s\n\nkickstart.check()","3ca1698b":"class casing:\n    def __init__( self ):\n        self.inner_diam = None # mm\n        \n    def check( self ):\n        if None in self.__dict__.values():\n            raise AttributeError(\"All Attributes of the casing class must be defined\")","6ccc1017":"myCasing = casing()\nmyCasing.inner_diam = 95 # mm","971f9291":"class grain:\n    def __init__( self, prop, casing ):\n        \n        self.prop = prop # propellent object | what prop is this grain made of\n        self.outt_diam = casing.inner_diam # mm\n        \n        # input variables\n        self.core_diam = None # mm\n        self.leng = None # mm\n        \n        self.area_min = 7\/8*pi*self.outt_diam**2\n        self.area_max = 2*pi*self.outt_diam**2\n        \n    def check( self ):\n        if None in self.__dict__.values():\n            raise AttributeError(\"All Attributes of the casing class must be defined\")\n            \n    def solveLengNeutral( self ):\n        self.leng = ( 3*self.outt_diam + self.core_diam )\/2\n    \n    def solveCoreDiam( self, max_area_burn ):\n        self.core_diam = sqrt( 12*pi*(2*max_area_burn - pi*self.outt_diam**2) )\/(3*pi) - self.outt_diam\n    \n    def calcVolume( self ):\n        self.volume = pi\/4*( self.outt_diam**2 - self.core_diam**2 )\n    \n    def calculateWeb( self ):\n        self.web_thickness = min( (self.outt_diam - self.core_diam)\/2 , self.leng\/2 )\n        if self.web_thickness == self.leng\/2: \n            import warnings\n            warning.warn(\"Current grain geometry produces behavior where ends burn through before core does.\\\n            This is not typical and can be solved by increasing the length\")\n            \n    def area( self, web_regress ):\n        if web_regress < 0: web_regress = 0\n        elif web_regress > self.web_thickness: return 0\n        return pi*(self.core_diam + 2*web_regress)*(self.leng-2*web_regress)\\\n        + pi\/2 * ( self.outt_diam**2 - ( self.core_diam + 2 * web_regress)**2 )\n    \n    def solveParameters( self, max_area_burn ):\n        self.solveCoreDiam(max_area_burn)\n        self.solveLengNeutral()\n        self.calcVolume()\n        self.calculateWeb()\n        return( self.volume )\n        ","ad00bc9c":"myGrain = grain( kickstart, myCasing )\n\nmyGrain.core_diam = 56 # mm\nmyGrain.solveLengNeutral()\nmyGrain.calculateWeb()\n\nprint(\"web = {}\".format(myGrain.web_thickness))\nprint()\nprint(myGrain.area(0))\nprint(myGrain.area(myGrain.web_thickness\/2))\nprint(myGrain.area(myGrain.web_thickness))\nprint(myGrain.area(myGrain.web_thickness+.01))","d1b62ff4":"output_notebook()","fe592366":"p = figure(plot_width=800, plot_height=400, title=\"Area of Grain\")\n# add a line renderer\nx_data = np.linspace(myGrain.web_thickness, 0)\nvfunc = np.vectorize(myGrain.area)\ny_data = vfunc(x_data)\np.line(x_data, y_data, line_width=2)\np.y_range.start=0\n\nshow(p) # show the results","b7385b16":"def MotorClass2Impulse( code, percent=0 ):\n    return (1+percent) * 1.25 * 2**( ord(code.upper()) - 65 )\n\nimpulse_target = MotorClass2Impulse( 'M', percent=0.7 ) # Ns\nthrust_target = 3000 # N\n\n# Isp*g is the ratio of Impulse per Prop Mass\n\nn = 25\nbrun_area = np.linspace(myGrain.area_min, myGrain.area_max, n)\nvolume = np.zeros( n )\ncore_diam = np.zeros( n )\nlength = np.zeros( n )\nfor i in range( n ):\n    volume[i] = myGrain.solveParameters(brun_area[i])\n    core_diam[i] = myGrain.core_diam\n    length[i] = myGrain.leng\n\n\np = figure(plot_width=800, plot_height=400, title=\"Vol of Grain\")\np.line(brun_area, volume, line_width=2)\np.y_range.start=0\nshow(p) # show the results\n\n","3a596fdd":"from tabulate import tabulate\nprint( \\\n      tabulate( \\\n                np.array([brun_area, volume, volume*kickstart.density, volume*kickstart.density*9.81*kickstart.isp, core_diam, length]).T ,\\\n                headers = [\"max area burn\", \"volume\", \"prop mass\", \"Impulse\", \"core diam\", \"length\"],\\\n                colalign=(\"left\",)\\\n               )\\\n     )","baa44fc2":"print( MotorClass2Impulse( 'M', percent=0.7 ) )\nprint(MotorClass2Impulse( 'M', percent=0.7 ) \/(120*9.81))","d3c38b43":"## Kickstart Propellent\nKickstart is the MIT Rocket Teams current formulation of an AP-HTPB propellent.\n### Overview\nKickstart is the team's fourth propellant formula. It is a minor modification of Cherry Limeade, with the goals of making us less dependent on single chemical suppliers, lowering cost, and slightly improving our density. We are moving towards making monolithic motors, so the formula should also have the same or better pourability than CL. As has been the trend with our previous formulas, we are reducing the number of ingredients. This time, we are removing Triton X100 because it should not be used with strong oxidizers according to its data sheet, and castor oil, as discussed in results section for Cherry Limeade. Castor oil requires a lot of MDI to bond with its many OH groups, so the amount of MDI needed has dropped significantly. The missing castor oil was mostly replaced with HTPB while the difference in MDI has been put towards IDP in the hopes of further lowering our viscosity to help with pouring large monolithic motors. The amount of aluminum is also being increased slightly as we target larger motors that can consume more Al, and also to slightly reduce burn rate and increase density. This will likely be the last formulation we characterize of this series, unless our requirements change significantly.\n\n### Formula\n*Assuming a binder plasticizer percentage of 27, EW of 1219.5 for HTPB and 185 for MDI.\n\n| Ingreadient | Percentage |\n| ----------- | ----------- |\n| 200 AP | 65.5 % |\n| HTPB | 10.744 % |\n| 90 AP | 9.5 % |\n| Al | 8 % |\n| IDP | 4.577 % |\n| MDI | 1.629 % |\n| PDMS | 0.05 % |\n\n### Performace\n\n| Metric | Value |\n| ----------- | ----------- |\n| Density | 0.001689 g\/mm3 |\n| a | 3.0412 mm\/s |\n| n | 0.36915 |\n| k | 1.4?? |\n| c* | 1844 m\/s |\n| Isp | 225? s |","1806c601":"# Defining the Casing Characteristics\n\nThe casing is a tube that contains the grains of the propellent. \nTODO: implement a calculator that can take an outer diameter, a material property, and a MOP and return the required thickness (with a fos)\n\ncurrently the casing will only be the internal diamenter, length targets must be delt with via iterations\n","4b561639":"# Defining the Propellent","33303862":"## Objectives of Grain Design\n\n- Total Impulse\n- Thrust\n\nThrust is propotional to Burning Area\nImpulse is proportional to volume wich is inversly proportional to burning Area\n\n\nIf two targets are supplied, along with weights, it should be possible to minimize the error ","37ff1a7a":"At this point in order to optimize both parameters diffrent numbers of grains can be analized","dc16a34b":"# Defining the Grian Parameters\nUltimately most grain characteristics will be optimized numerically, however to start all characteristics will be supplied by the user. \nCurrently the grain class is only for bates grains\n","ff3a3d7e":"The propellent class holds all of the data of a given propellent"}}