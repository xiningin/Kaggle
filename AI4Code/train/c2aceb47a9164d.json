{"cell_type":{"fd4892eb":"code","c52d1536":"code","44536baf":"code","9884c142":"code","f62c91e1":"code","4dd9dc0c":"code","a43e165a":"code","18bd3b0f":"code","c28b5896":"code","36858dcd":"code","6460ef04":"code","5540040f":"code","e30427ec":"code","13bf7d79":"code","dedf0c0b":"code","9840cd9e":"code","6f962daa":"code","c19a9d31":"code","2090f8ae":"code","63196cbe":"code","fdcb9380":"code","7e8f79dc":"code","2108f700":"markdown","71fc75bc":"markdown","6c51426d":"markdown","56cd2ac9":"markdown","b049f2f6":"markdown","733218ba":"markdown","d61f0876":"markdown","88c11a3e":"markdown","94add836":"markdown","22ec4006":"markdown","226112dd":"markdown","470bd522":"markdown","41071061":"markdown","af13455c":"markdown","a752359e":"markdown","173f58dc":"markdown","241e661a":"markdown","cffa782e":"markdown","9dcc8592":"markdown","dc7d7030":"markdown","8245ef89":"markdown","6d5169c3":"markdown","708944ff":"markdown","7400200c":"markdown","3f5f7f3b":"markdown","b38b89e8":"markdown","e339cd90":"markdown","ffbf5d7d":"markdown"},"source":{"fd4892eb":" \nimport zipfile\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport plotly.graph_objs as go\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nfrom collections import Counter\nimport matplotlib.pyplot as plt\n#import seaborn as sns\n%matplotlib inline\nimport seaborn as sns # for making plots with seaborn\ncolor = sns.color_palette()\n\nfrom sklearn.decomposition import PCA\nfrom sklearn import ensemble\nfrom sklearn.ensemble import RandomForestClassifier\n\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nprint (\"Setup Complete\")","c52d1536":"# Path of the file to read\ntrain_filepath = 'kaggle\/input\/Forest\/train.csv'\ntest_filepath = 'kaggle\/input\/Forest\/train.csv'\n\n\nimport zipfile\nzf = zipfile.ZipFile('\/kaggle\/input\/forest-cover-type-kernels-only\/train.csv.zip')\nzf1 = zipfile.ZipFile('\/kaggle\/input\/forest-cover-type-kernels-only\/test.csv.zip')\ntrain= pd.read_csv(zf.open('train.csv'),index_col=0)\ntest = pd.read_csv(zf1.open('test.csv'),index_col=0)","44536baf":"print(\"The number of traning examples(data points) = %i \" % train.shape[0])\nprint(\"The number of features we have = %i \" % train.shape[1])","9884c142":"train.head()","f62c91e1":"Distinct_Val_in_CoverType= train.Cover_Type.unique()","4dd9dc0c":"print(\"Minimum_Number_Assigned:\",train['Cover_Type'].min(), \"Maximum_Number_Assigned:\",train['Cover_Type'].max())","a43e165a":"train.Cover_Type.value_counts()","18bd3b0f":"train.describe(include = 'all')","c28b5896":"\ncol_uni_val={}\nfor i in train.columns:\n    col_uni_val[i] = len(train[i].unique())\n\nimport pprint\npprint.pprint(col_uni_val)","36858dcd":"train.isnull().sum()","6460ef04":"import seaborn as sns\nimport matplotlib.pyplot as plt\n\ncorr = train.corr()\nf, ax = plt.subplots(figsize=(25, 25))\n#cmap = sns.diverging_palette(220, 10, as_cmap=True)\nsns.heatmap(corr,linewidths=.5)","5540040f":"\nSoil_Type_Corr= corr.loc[corr.index[14:54], 'Cover_Type']\nprint( Soil_Type_Corr)","e30427ec":"print(\"The above values proved that Soil_Type7 and Soil_Type15 have NaN values (null)\")\nprint(Soil_Type_Corr.idxmax(),\"has the maximum positive correlation value of \",Soil_Type_Corr.max())\nprint(Soil_Type_Corr.idxmin(),\"has the maximum positive correlation value of \",Soil_Type_Corr.min())","13bf7d79":" train.drop([\"Soil_Type7\", \"Soil_Type15\"], axis = 1, inplace = True)","dedf0c0b":"import matplotlib.pyplot as plt\nclasses = np.array(list(train.Cover_Type.values))\n\ndef plotRelation(first_feature, sec_feature):\n\n    plt.scatter(first_feature, sec_feature, c = classes, s=10)\n    plt.xlabel(first_feature.name)\n    plt.ylabel(sec_feature.name)\n    \nf = plt.figure(figsize=(15,15))\nf.add_subplot(331)\nplotRelation(train.Horizontal_Distance_To_Hydrology, train.Horizontal_Distance_To_Fire_Points)\nf.add_subplot(332)\nplotRelation(train.Horizontal_Distance_To_Hydrology, train.Horizontal_Distance_To_Roadways)\nf.add_subplot(333)\nplotRelation(train.Horizontal_Distance_To_Hydrology, train.Vertical_Distance_To_Hydrology)","9840cd9e":"train[\"Vertical_Distance_To_Hydrology\"] = abs(train['Vertical_Distance_To_Hydrology'])\n\nsns.FacetGrid(train, hue=\"Cover_Type\", size=10).map(plt.scatter, \"Horizontal_Distance_To_Hydrology\", \"Vertical_Distance_To_Hydrology\").add_legend()","6f962daa":"print(\"The correlation value between Vertical_Distance_To_Hydrology and Horizontal_Distance_To_Hydrology is \",corr.loc['Vertical_Distance_To_Hydrology', 'Horizontal_Distance_To_Hydrology'])","c19a9d31":"f = plt.figure(figsize=(15,15))\nf.add_subplot(331)\nplotRelation( train.Horizontal_Distance_To_Fire_Points,train.Horizontal_Distance_To_Roadways)\nf.add_subplot(333)\nplotRelation(train.Horizontal_Distance_To_Fire_Points,train.Vertical_Distance_To_Hydrology )\nf.add_subplot(332)\nplotRelation( train.Horizontal_Distance_To_Roadways,train.Vertical_Distance_To_Hydrology)","2090f8ae":"train.boxplot( fontsize=15, grid=True, figsize=(25,25),vert=False)","63196cbe":"\nQ1 = train['Horizontal_Distance_To_Fire_Points'].quantile(0.25)\nQ3 = train['Horizontal_Distance_To_Fire_Points'].quantile(0.75)\nIQR = Q3 - Q1    #IQR is interquartile range. \n\n\n\ntrain.drop(train[(train['Horizontal_Distance_To_Fire_Points'] >= Q1 - 1.5 * IQR) & (train['Horizontal_Distance_To_Fire_Points'] <= Q3 + 1.5 *IQR)].index)","fdcb9380":"train.head()\n## ( addition and subtraction)\ntrain['HorizontalHydrology_HorizontalFire'] = (train['Horizontal_Distance_To_Hydrology']+train['Horizontal_Distance_To_Fire_Points'])\ntrain['Neg_HorizontalHydrology_HorizontalFire'] = (train['Horizontal_Distance_To_Hydrology']-train['Horizontal_Distance_To_Fire_Points'])\n\ntrain['HorizontalHydrology_HorizontalRoadways'] = (train['Horizontal_Distance_To_Hydrology']+train['Horizontal_Distance_To_Roadways'])\ntrain['Neg_HorizontalHydrology_HorizontalRoadways'] = (train['Horizontal_Distance_To_Hydrology']-train['Horizontal_Distance_To_Roadways'])\n\ntrain['HorizontalFire_Points_HorizontalRoadways'] = (train['Horizontal_Distance_To_Fire_Points']+train['Horizontal_Distance_To_Roadways'])\ntrain['Neg_HorizontalFire_Points_HorizontalRoadways'] = (train['Horizontal_Distance_To_Fire_Points']-train['Horizontal_Distance_To_Roadways'])\n\n##(mean)\ntrain['Mean_HorizontalHydrology_HorizontalFire'] = (train['Horizontal_Distance_To_Hydrology']+train['Horizontal_Distance_To_Fire_Points'])\/2\ntrain['MeanNeg_Mean_HorizontalHydrology_HorizontalFire'] = (train['Horizontal_Distance_To_Hydrology']-train['Horizontal_Distance_To_Fire_Points'])\/2\n\ntrain['Mean_HorizontalHydrology_HorizontalRoadways'] = (train['Horizontal_Distance_To_Hydrology']+train['Horizontal_Distance_To_Roadways'])\/2\ntrain['MeanNeg_HorizontalHydrology_HorizontalRoadways'] = (train['Horizontal_Distance_To_Hydrology']-train['Horizontal_Distance_To_Roadways'])\/2\n\ntrain['Mean_HorizontalFire_Points_HorizontalRoadways'] = (train['Horizontal_Distance_To_Fire_Points']+train['Horizontal_Distance_To_Roadways'])\/2\ntrain['MeanNeg_HorizontalFire_Points_HorizontalRoadways'] = (train['Horizontal_Distance_To_Fire_Points']-train['Horizontal_Distance_To_Roadways'])\/2\n\n## mean of all three distances \ntrain['Mean_Fire_Hydrology_Roadways']=(train['Horizontal_Distance_To_Fire_Points'] + train['Horizontal_Distance_To_Hydrology'] + train['Horizontal_Distance_To_Roadways']) \/ 3\n\n## mean of hillshade \ntrain['mean_hillshade'] = (train['Hillshade_9am']  + train['Hillshade_Noon']  + train['Hillshade_3pm'] ) \/ 3\n\ntrain.head()\n## ( addition and subtraction)\ntest['HorizontalHydrology_HorizontalFire'] = (test['Horizontal_Distance_To_Hydrology']+test['Horizontal_Distance_To_Fire_Points'])\ntest['Neg_HorizontalHydrology_HorizontalFire'] = (test['Horizontal_Distance_To_Hydrology']-test['Horizontal_Distance_To_Fire_Points'])\n\ntest['HorizontalHydrology_HorizontalRoadways'] = (test['Horizontal_Distance_To_Hydrology']+test['Horizontal_Distance_To_Roadways'])\ntest['Neg_HorizontalHydrology_HorizontalRoadways'] = (test['Horizontal_Distance_To_Hydrology']-test['Horizontal_Distance_To_Roadways'])\n\ntest['HorizontalFire_Points_HorizontalRoadways'] = (test['Horizontal_Distance_To_Fire_Points']+test['Horizontal_Distance_To_Roadways'])\ntrain['Neg_HorizontalFire_Points_HorizontalRoadways'] = (test['Horizontal_Distance_To_Fire_Points']-test['Horizontal_Distance_To_Roadways'])\n\n##(mean)\ntest['Mean_HorizontalHydrology_HorizontalFire'] = (test['Horizontal_Distance_To_Hydrology']+test['Horizontal_Distance_To_Fire_Points'])\/2\ntest['MeanNeg_Mean_HorizontalHydrology_HorizontalFire'] = (test['Horizontal_Distance_To_Hydrology']-test['Horizontal_Distance_To_Fire_Points'])\/2\n\ntest['Mean_HorizontalHydrology_HorizontalRoadways'] = (test['Horizontal_Distance_To_Hydrology']+test['Horizontal_Distance_To_Roadways'])\/2\ntest['MeanNeg_HorizontalHydrology_HorizontalRoadways'] = (test['Horizontal_Distance_To_Hydrology']-test['Horizontal_Distance_To_Roadways'])\/2\n\ntest['Mean_HorizontalFire_Points_HorizontalRoadways'] = (test['Horizontal_Distance_To_Fire_Points']+test['Horizontal_Distance_To_Roadways'])\/2\ntest['MeanNeg_HorizontalFire_Points_HorizontalRoadways'] = (test['Horizontal_Distance_To_Fire_Points']-test['Horizontal_Distance_To_Roadways'])\/2\n\n## mean of all three distances \ntest['Mean_Fire_Hydrology_Roadways']=(test['Horizontal_Distance_To_Fire_Points'] + test['Horizontal_Distance_To_Hydrology'] + test['Horizontal_Distance_To_Roadways']) \/ 3\n\ntest['mean_hillshade'] = (test['Hillshade_9am']  + test['Hillshade_Noon']  + test['Hillshade_3pm'] ) \/ 3","7e8f79dc":"from sklearn.datasets import make_classification\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.model_selection import train_test_split\nX, y = make_classification(random_state=0) \nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, random_state=0,test_size=0.05,)\nclf = GradientBoostingClassifier(random_state=0)\nclf.fit(X_train, y_train)\nprint('Accuracy of classifier on training set: {:.2f}'.format(clf.score(X_train, y_train) * 100))\nprint('Accuracy of classifier on test set: {:.2f}'.format(clf.score(X_test, y_test) * 100))\n\n","2108f700":"In this tutorial our goal is to predict the forest cover type. This can be achieved by analysing the dataset provided. We will be using pandas library to help with determining the main factors that are correlated with forest cover type.","71fc75bc":"Now we can check the count of each element in Cover_Type column.","6c51426d":"It seems that the only significant correlation was between Horizontal_Distance_To_Hydrology and Vertical_Distance_To_Hydrology, so we can drop one of them.","56cd2ac9":"It seems that the cover type is assigned a value. We can determine the range of values that the cover type can take. We will figure that the values range between 1 and 7.","b049f2f6":"Now I will add some extra features that combine several of the existing features and the next step would be to determine whether this new feature is reasonable enough that it could be replace the features that it was created from.","733218ba":"First, I will check the relation between Horizontal_Distance_To_Hydrology and the remaining distances.","d61f0876":"Now we'll do the same for the other distance features to finish comparing all of the distance features together.","88c11a3e":"Obviously, Soil_Type7 and Soil_Type15 do not seem to have any effect on the Cover_Type(no correlation). \nSoil_Type38 and Soil_Type39 have the largest +ve correlation, while Soil_Type22 and Soil_Type29 have the lowest -ve correlation between Cover Type.\nHowever, we need to check the actual correlation values to avoid making wrong assumptions.","94add836":"The three most popular tools used by data scientists are decision trees, random forest and gradient boosting. \nI tried Gradient Boosting first. Gradient boosting also combine decision trees, but unlike random forests, they start the combining process at the beginning, instead of at the end.","22ec4006":"It seems that there is a positive correlation between Vertical_Distance_To_Hydrology and Horizontal_Distance_To_Hydrology. It might be useful to note that Vertical Distance has some negative values, hence taking the absolute of this column might give better results.","226112dd":"Perhaps examining other columns might assist in finding a pattern.","470bd522":"Our focus this time will be on distances: Horizontal_Distance_To_Hydrology, Vertical_Distance_To_Hydrology, Horizontal_Distance_To_Roadways, and Horizontal_Distance_To_Fire_points.","41071061":"This is an overview of the correlation values between all the features available in the data set. Our main focus is on the column 'Cover Type' as we need to determine which features have the greatest effect on the Cover Type.","af13455c":"As we can see, it seems that all Soil Type columns can take up to two values only. This might be a sign that the type of soil is of boolean type, either 'yes' or 'no'. Further investigation is needed here to determine whether a forest can be of several types and whether a certain combination of soil types can affect Forest Cover Type.","a752359e":"# Feature Engineering","173f58dc":"I will start with the Soil_Type columns in the data set and see if it is possible to deduce any strong relationship between the 'Cover_Type' and some Soil Types.","241e661a":"Alright, so there are no null values!","cffa782e":"The next step would be to search for outliers; this is best done through boxplots.","9dcc8592":"Here I will focus on the features that have larger values such as the distance features and check the nature of their outliers. The outliers can be a result of a mistake during data collection or it can be just an indication of variance in the data, so I will remove the rows where there are outliers in distance columns. I chose to remove the rows where Horizontal_Distance_To_Fire_Points have outliers because this is the column which has the largest number of outliers and its outliers are also overlapping with that in the Horizontal_Distance_To_Roadways column.","dc7d7030":"Note that in the code above I have not mentioned Vertical_Distance_To_Hydrology because I used Horizontal_Distance_To_Hydrology which is highly correlated with it and so I will drop it.","8245ef89":"The results above may indicate that each Cover Type has equal chance, however further examination is needed.","6d5169c3":"Removing the columns for Soil_Type7 and Soil_Type15 would be the best way to deal with them in order to eliminate unuseful data. As for the correlation values of Soil_Type38 and Soil_Type29, the values are small (might not be very significant ) but we might need them later on for further exploration.","708944ff":"#  Data Exploration and Feature Engineering","7400200c":"The result of the gradient boosting algorithm can be further enhanced if we tuned the parameters more.","3f5f7f3b":"We can still see that there is some correlation between the two variables\/ features.","b38b89e8":"Another important factor to check for is whether there are any null values. Null values need to be filled with other reasonable of values or removed if they are very few.","e339cd90":"After having finished analysing the direct relationship between Soil Type and Cover Type, we can move on to the other features.\nAccording to the overview graph shown earlier, there isn't a strong correlation between one specific feature of the remaining features (Soil type not included) and Cover Type, hence it might be wise to check whether there is a correlation between the remaining features with each other and see if we can remove some features completely or remove some features but replace them with a new feature that combines several features together to improve the performance of the model.","ffbf5d7d":"First it might be useful to get an idea of the size of dataset available.\nAs shown, our train dataFrame has around 15000 records split across 56 different columns. \nWe will also examine the cells by printing the first 5 rows."}}