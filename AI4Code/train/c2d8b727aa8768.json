{"cell_type":{"d94a01c8":"code","7f550c03":"code","c1ea6d41":"code","13d07b1b":"code","44ed1fcf":"code","d46cd28d":"code","fafb8d9d":"code","57d9c0eb":"code","cb60ebb6":"code","ea1bfdbb":"code","61e6a091":"code","7f804997":"code","ff8373cb":"code","e58e2604":"code","54cb36b3":"code","7048e47a":"code","96012c1b":"code","60beefa2":"code","3a431e69":"code","9adb9bc0":"code","e2dd39e9":"markdown","f79547ef":"markdown","599f0875":"markdown","bf88a0bd":"markdown","c54cfe87":"markdown","8bebc5d8":"markdown","0c00e868":"markdown"},"source":{"d94a01c8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \nimport warnings\nwarnings.filterwarnings('ignore')\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn import preprocessing,cross_decomposition,model_selection,metrics\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport xgboost as xgb\n%matplotlib inline\nimport dateutil\nfrom tqdm import tqdm\nfrom sklearn import linear_model\nimport datetime\nimport numpy as np\nimport pandas as pd\n\nimport plotly.graph_objects as go\nfrom ipywidgets import widgets\nimport statsmodels.api as sm\nimport statsmodels.formula.api as smf\nfrom statsmodels import tsa\nimport numpy as np\nimport pandas as pd\n\nimport plotly.graph_objects as go\nfrom ipywidgets import widgets\n# Any results you write to the current directory are saved as output.","7f550c03":"confirmedGlobal=pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_confirmed_global.csv',encoding='utf-8',na_values=None)\ndeathGLobal=pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_deaths_global.csv')\nrecoverGlobal=pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_recovered_global.csv')\nconfirmedGlobal['NewContryCode']=confirmedGlobal['Country\/Region']+confirmedGlobal['Province\/State'].fillna('')\ndeathGLobal['NewContryCode']=deathGLobal['Country\/Region']+deathGLobal['Province\/State'].fillna('')\nrecoverGlobal['NewContryCode']=recoverGlobal['Country\/Region']+recoverGlobal['Province\/State'].fillna('')","c1ea6d41":"confirmedGlobal.head()","13d07b1b":"#Considering day0 when atleast 5 cases has been declared\ndef getStartPoint(country):\n    for num,i in enumerate(confirmedGlobal[confirmedGlobal['NewContryCode']==country].values[0][4:]):\n        if i >= 5:\n#             print (num,i)\n            break\n    return 4+num\n\ndef getSlope(dataSet):\n    df=pd.DataFrame(dataSet)\n    df=df.reset_index()\n    df.columns=['x','y']\n    model=linear_model.LinearRegression(fit_intercept=False).fit(df[['x']],df[['y']])\n    return model.coef_[0][0]\n\n'''This code returns:\n1. The original data based on the new D0 day.\n2. absolute values of any country from given cumulated data, \n3. scaled absolute values  with MinMax method, \n4. standard deviation of the absolute values so that we can compare between countries, \n5. the function also provides the slope of the absolute data to find the rate of change over the given period of time, slope I am calculating using Linear regresion by not\nconsidering the intercept which will give me y=mx+c and we needed m from this equation, some data might not have a linear relation but at the end of the day this\nvalue would point the direction and a magintude of increment over a period of time.\n6. Logarithimic values of the cumulated values''' \ndef getDataArranged(country):\n    temp={}\n    startPoint=getStartPoint(country)\n    temp['logValues']=[np.log(i) if i !=0  else 0 for i in confirmedGlobal[confirmedGlobal['NewContryCode']==country].values[0][startPoint:-1]]\n    temp['actualValues']=[i for i in confirmedGlobal[confirmedGlobal['NewContryCode']==country].values[0][startPoint:-1]]\n    countryData=confirmedGlobal[confirmedGlobal['NewContryCode']==country].values[0][startPoint:-1]\n    datesOfInfections=[str(dateutil.parser.parse(i))[:10] for i in confirmedGlobal[confirmedGlobal['NewContryCode']==country].columns[startPoint:-1]]\n    dayIndex=['D_'+str(i).zfill(3) for i in range(len(countryData))]\n    temp['countryData']=countryData\n    pp=list(countryData[:-1])\n    pp.insert(0,0)\n    absInfected=countryData-pp\n    temp['absInfected']=absInfected\n    lbl=preprocessing.MinMaxScaler()\n    temp['minMaxScaledval']=np.ravel(lbl.fit_transform(absInfected.reshape(len(absInfected),1)))\n    temp['stdVal']=np.std(temp['absInfected'])\n    temp['slopeData']=getSlope(absInfected)\n    temp['datesOfInfections']=datesOfInfections\n    temp['dayIndex']=dayIndex\n    temp['lastValue']=countryData[-1]\n    return temp","44ed1fcf":"countryDataDict={}\nfor con in tqdm(confirmedGlobal['NewContryCode']):\n    try:\n        countryDataDict[con]=getDataArranged(con)    \n    except:\n        pass","d46cd28d":"dfList=[]\nfor i in countryDataDict:\n    tmp=pd.DataFrame({'logVals':countryDataDict[i]['logValues'],'infected':countryDataDict[i]['countryData']}).reset_index()\n    tmp.columns=['dayInfo','logVals','infected']\n    tmp['Country']=i\n    dfList.append(tmp)","fafb8d9d":"dfList=[]\nfor i in countryDataDict:\n    tmp=pd.DataFrame(countryDataDict[i]['logValues'])\n    tmp.columns=[i]\n    dfList.append(tmp)\n    \ndfLinePlotD0=pd.concat(dfList,axis=1)\ndfLinePlotD0[list(dfLinePlotD0.columns.values[np.where(dfLinePlotD0.max() >9)]) +['India']].plot(figsize=(20,10))\nfilteredDFForLinePlot=dfLinePlotD0#[list(dfLinePlotD0.columns.values[np.where(dfLinePlotD0.max() >9)]) +['India','Japan']]\ndfList=[]\nfor i in countryDataDict:\n    tmp=pd.DataFrame(data={'logValues':countryDataDict[i]['logValues'],'countryData':countryDataDict[i]['countryData']})\n    tmp['CountryName']=i\n    dfList.append(tmp)\n    \nallDaatForLineG=pd.concat(dfList)\nallDaatForLineG=allDaatForLineG.reset_index()\nallDaatForLineG.columns=['DayIndex', 'logValues', 'countryData', 'CountryName']","57d9c0eb":"filtCountry=list(dfLinePlotD0.columns.values[np.where(dfLinePlotD0.max() >9)]) +['India','Japan']","cb60ebb6":"textbox = widgets.Dropdown(\n    description='Country:   ',\n    value='India',\n    options=filtCountry\n)\n\ntextbox2 = widgets.Dropdown(\n    description='Country2:   ',\n    value='Japan',\n    options=filtCountry\n)\n\ncontainer = widgets.HBox(children=[textbox,textbox2])\n# container = widgets.HBox(children=[daySLider])\n# from plotly.subplots import make_subplots\ntempDFFOrSlider=allDaatForLineG[allDaatForLineG['CountryName']=='India']\ntrace1 = go.Scatter(\n    x=tempDFFOrSlider['DayIndex'],\n    y=tempDFFOrSlider['logValues'],\n#     mode='markers',\n     mode=\"markers+text+lines\",\n#     marker=dict(size=list(tempDFFOrSlider['countryData'].values),sizemode='area',\n#         sizeref=2.*max(list(tempDFFOrSlider['countryData'].values))\/(40.**2),\n# #                 color=tempDFFOrSlider['clusterInfo'],\n#         sizemin=4),\n    showlegend=False,\n    fill='tozeroy',\n    text=tempDFFOrSlider['countryData'])\n\ntempDFFOrSlider2=allDaatForLineG[allDaatForLineG['CountryName']=='Germany']\ntrace2 = go.Scatter(\n    x=tempDFFOrSlider2['DayIndex'],\n    y=tempDFFOrSlider2['logValues'],\n#     mode='markers',\n     mode=\"markers+text+lines\",\n#     marker=dict(size=list(tempDFFOrSlider2['countryData'].values),sizemode='area',\n#         sizeref=2.*max(list(tempDFFOrSlider2['countryData'].values))\/(40.**2),\n# #                 color=tempDFFOrSlider['clusterInfo'],\n#         sizemin=4),\n    showlegend=False,\n    fill='tozeroy',\n    text=tempDFFOrSlider2['countryData'])\n\ng = go.FigureWidget(data=[trace1,trace2],layout=go.Layout(title=dict(text='Covid19'),barmode='overlay'))\n\ndef response(change):\n    vaL=textbox.value\n    vaL2=textbox2.value\n    tempDFFOrSlider=allDaatForLineG[allDaatForLineG['CountryName']==vaL]\n    tempDFFOrSlider2=allDaatForLineG[allDaatForLineG['CountryName']==vaL2]\n    x1 = tempDFFOrSlider['DayIndex'].values\n    x2 = tempDFFOrSlider['logValues'].values\n    x3 = tempDFFOrSlider2['DayIndex'].values\n    x4 = tempDFFOrSlider2['logValues'].values\n\n    with g.batch_update():\n        g.data[0].x = x1\n        g.data[0].y = x2\n#         g.data[0].marker['size']= list(tempDFFOrSlider['countryData'].values)\n#         g.data[0].marker['color']= tempDFFOrSlider['clusterInfo'].values\n        g.data[0].text = tempDFFOrSlider['countryData']\n    \n        g.data[1].x = x3\n        g.data[1].y = x4\n#         g.data[1].marker['size']= list(tempDFFOrSlider2['countryData'].values)\n#         g.data[0].marker['color']= tempDFFOrSlider['clusterInfo'].values\n        g.data[1].text = tempDFFOrSlider2['countryData']\n    \n        g.layout.barmode = 'overlay'\n# daySLider.observe(response, names=\"value\")\ntextbox.observe(response, names=\"value\")\ntextbox2.observe(response, names=\"value\")\nwidgets.VBox([container,g])","ea1bfdbb":"import numpy as np\nfrom sklearn.cluster import KMeans\nfrom sklearn import metrics\nfrom sklearn.metrics import pairwise_distances\n\n''' Clustering the data using the scaled values of stdDev and Slope values calculated earlier'''\n\ndef kmeanCluster(df):\n    tempClusterOutput=[]\n    metricOutput=[]\n    for j in range(3,8):\n        kmeans_model = KMeans(n_clusters=j, random_state=1)#.fit(overallSpacingDF[['varianceVal','scaledSlope']])\n        tempClusterOutput.append(kmeans_model.fit_predict(df[['stdVal','scaledSlope']]))\n        metricOutput.append(metrics.silhouette_score(df[['stdVal','scaledSlope']], kmeans_model.labels_, metric='euclidean'))\n    \n    return tempClusterOutput[np.argmax(np.array(metricOutput))]","61e6a091":"countryOverallSpcaing=[]\nfor i in countryDataDict:\n    temp={}\n    temp['stdVal']=countryDataDict[i]['stdVal']\n    temp['slopeData']=countryDataDict[i]['slopeData']\n    temp['lastValue']=countryDataDict[i]['lastValue']\n    temp['countryName']=i\n    countryOverallSpcaing.append(temp)","7f804997":"overallSpacingDF=pd.DataFrame(countryOverallSpcaing)\noverallSpacingDF['scaledSlope']=preprocessing.MinMaxScaler().fit_transform(overallSpacingDF[['slopeData']])\noverallSpacingDF['stdVal']=preprocessing.MinMaxScaler().fit_transform(overallSpacingDF[['stdVal']])\noverallSpacingDF.head()\noverallSpacingDF['clusterInfo']=kmeanCluster(overallSpacingDF)","ff8373cb":"import plotly.express as px\nfig = px.scatter(overallSpacingDF, x=\"scaledSlope\", y=\"stdVal\",\n\t         size=\"lastValue\", color=\"clusterInfo\",\n                 hover_name=\"countryName\", log_x=True, size_max=60,text='countryName')\nfig.update_layout(showlegend=False)\nfig.update_layout(\n    title=\"ALl Countries Cluster Variance vs Slope\",\n  \n)\nfig.show()","e58e2604":"filoverallSpacingDF=overallSpacingDF[overallSpacingDF['lastValue']>800]\nfiloverallSpacingDF=filoverallSpacingDF[~filoverallSpacingDF['countryName'].str.contains('ina')]\nfiloverallSpacingDF.shape\nimport plotly.express as px\nfig = px.scatter(filoverallSpacingDF, x=\"scaledSlope\", y=\"stdVal\",\n\t         size=\"lastValue\", color=\"clusterInfo\",\n                 hover_name=\"countryName\", log_x=True, size_max=60,text='countryName')\nfig.update_layout(showlegend=False)\nfig.update_layout(\n    title=\"Filtered List of Countries Cluster Variance vs Slope\",\n  \n)\nfig.show()","54cb36b3":"'''This function calculates the Std Deviation and Slope of the actual data over the nth day of the infection not using cumulated data '''\n\ndef getCountryDayWiseDetails(country):\n    indiCountyDaywise=[]\n    tempX=countryDataDict[country]\n    for i in range(0,len(tempX['countryData'])):\n        try:\n            tempDict={'stdVal':np.std(tempX['absInfected'][:i]),\n                  'dayInfo':i,#'D_'+str(i).zfill(3),\n                  'slopeVal':getSlope(tempX['absInfected'][:i]),\n                'infected':tempX['countryData'][i]}\n        except:\n            tempDict={'stdVal':None,\n                  'dayInfo':i,#'D_'+str(i).zfill(3),\n                  'slopeVal':None,\n                     'infected':tempX['countryData'][i]}\n\n        indiCountyDaywise.append(tempDict)\n    tempDWiseData=pd.DataFrame(indiCountyDaywise)\n    tempDWiseData['CountryName']=country\n    return tempDWiseData","7048e47a":"countryDataDictDayWise=[]\nfor con in tqdm(countryDataDict):\n    countryDataDictDayWise.append(getCountryDayWiseDetails(con))\n    \nallCOuntryDayWiseDataDF=pd.concat(countryDataDictDayWise)\nallCOuntryDayWiseDataDF.head()","96012c1b":"'''Creating cluster for each Nth day to observe how the pattern is among the countries on the respective Nth day '''\nmoreDataFrameForSlider=[]\nfor indDate in tqdm(pd.unique(allCOuntryDayWiseDataDF['dayInfo'])):\n    try:\n        tempDF=allCOuntryDayWiseDataDF[allCOuntryDayWiseDataDF['dayInfo']==indDate]\n    #     tempDF=allCOuntryDayWiseDataDF[allCOuntryDayWiseDataDF['dayInfo']==21]\n        tempDF['scaledSlope']=preprocessing.MinMaxScaler().fit_transform(tempDF[['slopeVal']])\n        tempDF['scaledstdVal']=preprocessing.MinMaxScaler().fit_transform(tempDF[['stdVal']])\n        tempDF['clusterInfo']=kmeanCluster(tempDF)\n        moreDataFrameForSlider.append(tempDF)\n    except:\n        pass\n    \nallDFWithCluster=pd.concat(moreDataFrameForSlider)\nallDFWithCluster.head()","60beefa2":"daySLider = widgets.IntSlider(\n    value=1,\n    min=1.0,#min(allDFWithCluster['dayInfo']),\n    max=max(allDFWithCluster['dayInfo']),\n    step=1.0,\n    description='Day:',\n    continuous_update=False\n)\n\n# textbox = widgets.Dropdown(\n#     description='Country:   ',\n#     value='India',\n#     options=allCOuntryData.columns.tolist()\n# )\ncontainer = widgets.HBox(children=[daySLider])\n# from plotly.subplots import make_subplots\n\ntempDFFOrSlider=allDFWithCluster[allDFWithCluster['dayInfo']==59]\ntrace1 = go.Scatter(\n    x=tempDFFOrSlider['slopeVal'],\n    y=tempDFFOrSlider['stdVal'],\n#     mode='markers',\n     mode=\"markers+text\",\n    marker=dict(size=tempDFFOrSlider['infected'],sizemode='area',\n        sizeref=3.*max(tempDFFOrSlider['infected'])\/(40.**2),\n                color=tempDFFOrSlider['clusterInfo'],\n        sizemin=4),\n    showlegend=False,\n    text=tempDFFOrSlider['CountryName'])\ng = go.FigureWidget(data=[trace1],layout=go.Layout(title=dict(text='Covid19'),barmode='overlay'))\n\ndef response(change):\n    vaL=daySLider.value\n    tempDFFOrSlider=allDFWithCluster[allDFWithCluster['dayInfo']==vaL]\n    x1 = tempDFFOrSlider['slopeVal'].values\n    x2 = tempDFFOrSlider['stdVal'].values\n    with g.batch_update():\n        g.data[0].x = x1\n        g.data[0].y = x2\n        g.data[0].marker['size']= tempDFFOrSlider['infected'].values\n        g.data[0].marker['color']= tempDFFOrSlider['clusterInfo'].values\n        g.layout.barmode = 'overlay'\n        g.data[0].text = tempDFFOrSlider['CountryName']\ndaySLider.observe(response, names=\"value\")\n# textbox.observe(response, names=\"value\")\n\nwidgets.VBox([container,g])","3a431e69":"filtCountry=list(allDFWithCluster.groupby(['CountryName']).agg({'infected':'max'})\\\n     .reset_index().sort_values(by='infected',ascending=False).head(20)['CountryName'].values)\\\n    + ['India','Japan']\n\n# filallCOuntryDayWiseDataDF=allCOuntryDayWiseDataDF[]\nfilterNextForIndia=allDFWithCluster[allDFWithCluster['CountryName'].isin(filtCountry)]\n# filterNextForIndia=allDFWithCluster[~allDFWithCluster['CountryName'].str.contains('ina')]","9adb9bc0":"daySLider1 = widgets.IntSlider(\n    value=59,\n    min=1,#min(filterNextForIndia['dayInfo']),\n    max=max(filterNextForIndia['dayInfo']),\n    step=1.0,\n    description='Day:',\n    continuous_update=False\n)\n\ncontainer1 = widgets.HBox(children=[daySLider1])\n# from plotly.subplots import make_subplots\n\ntempDFFOrSlider=filterNextForIndia[filterNextForIndia['dayInfo']==59]\ntrace11 = go.Scatter(\n    x=tempDFFOrSlider['slopeVal'],\n    y=tempDFFOrSlider['stdVal'],\n#     mode='markers',\n     mode=\"markers+text\",\n    marker=dict(size=tempDFFOrSlider['infected'],sizemode='area',\n        sizeref=3.*max(tempDFFOrSlider['infected'])\/(40.**2),\n                color=tempDFFOrSlider['clusterInfo'],\n        sizemin=4),\n    showlegend=False,\n    text=tempDFFOrSlider['CountryName'])\ng2 = go.FigureWidget(data=[trace11],layout=go.Layout(title=dict(text='Covid19'),barmode='overlay'))\n\ndef response(change):\n    vaL=daySLider1.value\n    tempDFFOrSlider=filterNextForIndia[filterNextForIndia['dayInfo']==vaL]\n    x1 = tempDFFOrSlider['slopeVal'].values\n    x2 = tempDFFOrSlider['stdVal'].values\n    with g.batch_update():\n        g2.data[0].x = x1\n        g2.data[0].y = x2\n        g2.data[0].marker['size']= tempDFFOrSlider['infected'].values\n        g2.data[0].marker['color']= tempDFFOrSlider['clusterInfo'].values\n        g2.data[0].text = tempDFFOrSlider['CountryName']\n        g2.layout.barmode = 'overlay'\ndaySLider1.observe(response, names=\"value\")\n# textbox.observe(response, names=\"value\")\n\nwidgets.VBox([container1,g2])","e2dd39e9":"# Creating a slider for observing the change over time for All countries behavior on Infection over the the day from which it started","f79547ef":"This notebook has below mentioned Dashboard features:\n\n1. New definition for calling D0 for any Nation > atleast 5 cases has been confirmed (The reason: observing it from the very 1st case of infection, does give true picture of spread, at some country the spread was kind of increasing day by day, but in some countries the value of infected people didn't blow up instatly, but took its time where the spread was unstoppable over the next 2 weeks, so idea is to start with when the spread started growing and through that not infected countries can take appropriate decisions)\n2. Dashboard which compares any 2 combination of Nation's COVID infections confirmed cases in Log values.\n3. Overall clustering of Nations at current states (X: Slope of the Infected (Non cumulated) values, Y: Standard Deviation of the data Infected (Non cumulated) values)\n4. Same analysis over a period of time, same calculations on cumulated steps of values and cluster\n5. Looking India's number makes a alarming suggestion, if all the things are as it shuold be then we are in controlled state,\n    but if it errupts or we get leakage in our behaviour, we might have severe infections in coming days (If you are looking at this notebook, try to play with the 1st dashboard \n    and let me know your thoughts.)\n6. I will add my observations on this slide in some time, But I think it's a good dashboard to play and observer your country and take action\n\nFeel free to suggest me anything which I have done wrong or any thing by which I can improve my analysis","599f0875":"# Part 1","bf88a0bd":"## Dashboard 2 with filter countries","c54cfe87":"# Part 2","8bebc5d8":"# Dashboard 2 cluster","0c00e868":"## Adding filters > 800  and Removing China"}}