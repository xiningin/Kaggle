{"cell_type":{"ced39b60":"code","de8c2b90":"code","baca2922":"code","2b107d61":"code","f5169540":"code","b45142b3":"code","596b65ab":"code","ffc7907b":"code","272b7a2a":"code","b4d0a350":"code","0fa8b766":"code","f5503697":"code","9eef265d":"code","6d4edb38":"code","cb67a9ee":"code","a564ef13":"code","cf9c8874":"code","98b10d89":"code","3c56d3de":"code","44d52099":"code","93bcd87b":"code","0a37078f":"code","d5363e6e":"code","bb09cf49":"code","d39bcb97":"code","6b4c09e8":"code","1795a09d":"code","0fe0be5d":"code","20da1030":"code","b01ce744":"code","ef67641a":"code","3639d674":"code","657daf89":"code","f76930ab":"code","297011c9":"code","7f0642d4":"code","e4a288f7":"code","cc3f8d7a":"code","0eba20f1":"code","51c98fe4":"code","f07771bb":"code","1a0b4620":"code","645eaeea":"code","bc5a9c68":"code","931d42ad":"code","e087c988":"code","e0eb0bb0":"code","a9a771ea":"code","05aa1bde":"code","48239723":"markdown","75a82da1":"markdown","06ec4a26":"markdown","fb669121":"markdown","612ef636":"markdown","8f20c51a":"markdown","be28e064":"markdown","6283eeb4":"markdown","03a765f1":"markdown","e9cd0b3c":"markdown","026e8d7d":"markdown","7370daac":"markdown","c2ce5515":"markdown"},"source":{"ced39b60":"! wget https:\/\/repo.anaconda.com\/miniconda\/Miniconda3-py37_4.8.2-Linux-x86_64.sh\n! chmod +x Miniconda3-py37_4.8.2-Linux-x86_64.sh\n! bash .\/Miniconda3-py37_4.8.2-Linux-x86_64.sh -b -f -p \/usr\/local\n! conda install -c rdkit rdkit -y\nimport sys \nsys.path.append('\/usr\/local\/lib\/python3.7\/site-packages\/')\nimport warnings\nwarnings.filterwarnings('ignore')","de8c2b90":"! wget https:\/\/pubs.acs.org\/doi\/suppl\/10.1021\/ci034243x\/suppl_file\/ci034243xsi20040112_053635.txt","baca2922":"! wget https:\/\/raw.githubusercontent.com\/dataprofessor\/data\/master\/delaney.csv","2b107d61":"import pandas as pd\nimport numpy as np\ndata=pd.read_csv('delaney.csv')\ndata.head()","f5169540":"data_slice=data[['measured log(solubility:mol\/L)','ESOL predicted log(solubility:mol\/L)']]","b45142b3":"data_slice2=data_slice[['measured log(solubility:mol\/L)']]","596b65ab":"from rdkit import Chem\nmol_lst=[]\nfor i in data.SMILES:\n    mol=Chem.MolFromSmiles(i)\n    mol_lst.append(mol)","ffc7907b":"from rdkit.Chem import Descriptors","272b7a2a":"\nfrom rdkit.ML.Descriptors import MoleculeDescriptors","b4d0a350":"desc_lst=[i[0] for i in Descriptors._descList]\ndescriptor=MoleculeDescriptors.MolecularDescriptorCalculator(desc_lst)","0fa8b766":"descrs = []\nfor i in range(len(mol_lst)):\n    descrs.append(descriptor.CalcDescriptors(mol_lst[i]))","f5503697":"len(descrs)","9eef265d":"df=pd.DataFrame(descrs,columns=desc_lst)\n","6d4edb38":"df.head()","cb67a9ee":"import numpy as np\nfrom scipy.stats import mannwhitneyu","a564ef13":"Stat,p=mannwhitneyu(data_slice[['measured log(solubility:mol\/L)']], df[['MolLogP']])\nprint(\"Statistics=%.3f, p=%.3f\"%(Stat,p))\nalpha=0.05\nif p>alpha:\n    print(\"reject to fail the null hypothesis(same distributation)\")\nelse:\n    print(\"reject the null hypothesis(different hypothesis)\")","cf9c8874":"data_slice2.rename(columns = {'measured log(solubility:mol\/L)':'ground_sol'}, inplace = True) ","98b10d89":"#it shows the two samples does not belongs to same population\n#or\n#the probability is 50% that a randomly drawn member of the first population will not exceed a member of the second population.\n#form this we can infer that MolLogP ","3c56d3de":"from sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor\nfrom sklearn.metrics import roc_auc_score, mean_squared_error","44d52099":"data_slice2.shape","93bcd87b":"df.shape","0a37078f":"X=df\nY=data_slice2","d5363e6e":"X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2)","bb09cf49":"X_train.shape, Y_train.shape","d39bcb97":"# loop to build a tree, make predictions and get the roc-auc\n# for each feature of the train set\n# Regression is used for feature selection and model selection","6b4c09e8":"mse_values = []\nfor feature in X_train.columns:\n    clf = DecisionTreeRegressor()\n    clf.fit(X_train[feature].fillna(0).to_frame(), Y_train)\n    Y_scored = clf.predict(X_test[feature].fillna(0).to_frame())\n    mse_values.append(mean_squared_error(Y_test, Y_scored))","1795a09d":"mse_values = pd.Series(mse_values)\nmse_values.index = X_train.columns\nmse_values.sort_values(ascending=False)","0fe0be5d":"mse_values.sort_values(ascending=True).head(20)","20da1030":"df_temp=pd.DataFrame(mse_values.sort_values(ascending=True).head(20))","b01ce744":"df_temp.index","ef67641a":"df_feature=df[['MolLogP', 'ExactMolWt', 'HeavyAtomMolWt', 'PEOE_VSA6', 'Kappa1',\n       'MolWt', 'SMR_VSA7', 'SMR_VSA10', 'HallKierAlpha', 'Chi0v', 'MolMR',\n       'LabuteASA', 'fr_benzene', 'NumAromaticCarbocycles', 'Chi0',\n       'FpDensityMorgan1', 'NumValenceElectrons', 'EState_VSA9', 'SlogP_VSA8',\n       'HeavyAtomCount']]","3639d674":"df_feature.shape","657daf89":"X=df_feature\nY=data_slice2","f76930ab":"X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2)","297011c9":"X_train.shape, Y_train.shape","7f0642d4":"from sklearn.ensemble import RandomForestRegressor\nmodel = RandomForestRegressor(n_estimators=100)\nmodel.fit(X_train, Y_train)\nr2 = model.score(X_test, Y_test)\nr2","e4a288f7":"Y_pred = model.predict(X_test)","cc3f8d7a":"import seaborn as sns\nimport matplotlib.pyplot as plt\n","0eba20f1":"Y_pred.max()","51c98fe4":"ax = sns.regplot(Y_test, Y_pred, scatter_kws={'alpha':0.5})\nax.set_xlabel('experimental solubuility values: RandomFor')\nax.set_ylabel('predicted solubuility values: RandomFor')\nax.set_xlim(-9, 2)\nax.set_ylim(-9, 2)\nplt.show()","f07771bb":"from sklearn import linear_model\nclf = linear_model.Lasso(alpha=0.1)\nclf.fit(X_train, Y_train)\nr2 = clf.score(X_test, Y_test)\nr2","1a0b4620":"Y_predlaso = clf.predict(X_test)","645eaeea":"ax = sns.regplot(Y_test, Y_predlaso, scatter_kws={'alpha':0.5})\nax.set_xlabel('experimental solubuility values: LASSO')\nax.set_ylabel('predicted solubuility values: LASSO')\nax.set_xlim(-9, 2)\nax.set_ylim(-9, 2)\nplt.show()","bc5a9c68":"import xgboost as xgb","931d42ad":"xgb_model = xgb.XGBRegressor(objective=\"reg:linear\", random_state=50)","e087c988":"xgb_model.fit(X_train, Y_train)","e0eb0bb0":"Y_predxgb = xgb_model.predict(X_test)","a9a771ea":"mse=mean_squared_error(Y_test, Y_predxgb)\n\nprint(np.sqrt(mse))","05aa1bde":"ax = sns.regplot(Y_test, Y_predxgb, scatter_kws={'alpha':0.5})\nax.set_xlabel('experimental solubuility values: xgb')\nax.set_ylabel('predicted solubuility values: xgb')\nax.set_xlim(-9, 2)\nax.set_ylim(-9, 2)\nplt.show()","48239723":"## regression model with  random forest","75a82da1":"**Selecting the features**","06ec4a26":"**Downloading the dataset**","fb669121":"## For regression, the smaller the mse, the better the model performance is.\n\n## For the mse, where to put the cut-off is arbitrary as well. It depends on how many features you would like to end up with.\n\n## we are taking the min 20 values as our feature.","612ef636":"**Xgboost**","8f20c51a":"## regression model with LASSO\n","be28e064":"**Calculating the descriptors**","6283eeb4":"**Cheminformatics project**","03a765f1":"**Converting SMILES object to mol object for better calculation**","e9cd0b3c":"# Installing rdkit","026e8d7d":"**Reading the dataset**","7370daac":"## From the above three model we can infer that the score of the Random Forest is highest w.r.t the LASSO and XGBoost.\n\n## So, on the basis of the model score I will go with the RANDOM FOREST MODEL.\n\n## Here the feature selection is is based on the Univariate roc-auc. it is a regression model.\n\n### ***please upvote this notebook if it is helpful, thanks *** ","c2ce5515":"**for feature selection we are using Univariate roc-auc**"}}