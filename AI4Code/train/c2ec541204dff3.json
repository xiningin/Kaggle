{"cell_type":{"85ac4357":"code","7f1805b3":"code","f6e1a7a5":"code","9f553766":"code","daf4d2f7":"code","23b6b93e":"code","b999e2ad":"code","d7b1e0fa":"code","18a1b73d":"code","d65d2d87":"code","2d9b9619":"code","bb725c41":"code","7b8d21f6":"code","7fbe9d98":"code","26a84e47":"code","137b3647":"code","3345f17f":"code","5c78e69a":"code","f34989e7":"code","f210bc48":"code","f7509635":"code","e5924322":"code","f10f15e3":"code","b2a2dba3":"code","159811ee":"code","22e074b2":"code","e731b0d9":"code","2a5b80b2":"code","c2d51d5b":"code","2d554ad4":"markdown","27450083":"markdown","36cb2360":"markdown","4d91e29c":"markdown","056fa2fe":"markdown","659e3040":"markdown"},"source":{"85ac4357":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport cv2\nimport random\nfrom tqdm import tqdm\nfrom sklearn.metrics import roc_curve, auc\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom itertools import cycle\nfrom sklearn import svm, datasets\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import label_binarize\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom scipy import interp\nfrom sklearn.metrics import roc_auc_score\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\ndf = pd.read_csv(\"\/kaggle\/input\/ocular-disease-recognition-odir5k\/full_df.csv\")\ndf.head()","7f1805b3":"def has_cataract(text):\n    if \"cataract\" in text:\n        return 1\n    else:\n        return 0\ndf[\"left_cataract\"] = df[\"Left-Diagnostic Keywords\"].apply(lambda x: has_cataract(x))\ndf[\"right_cataract\"] = df[\"Right-Diagnostic Keywords\"].apply(lambda x: has_cataract(x))\n\nleft_cataract = df.loc[(df.C ==1) & (df.left_cataract == 1)][\"Left-Fundus\"].values\nprint(left_cataract[:10])\nright_cataract = df.loc[(df.C ==1) & (df.right_cataract == 1)][\"Right-Fundus\"].values\nprint(right_cataract[:15])","f6e1a7a5":"print(\"Number of images in left cataract: {}\".format(len(left_cataract)))\nprint(\"Number of images in right cataract: {}\".format(len(right_cataract)))","9f553766":"left_normal = df.loc[(df.C ==0) & (df[\"Left-Diagnostic Keywords\"] == \"normal fundus\")][\"Left-Fundus\"].sample(300,random_state=42).values\nright_normal = df.loc[(df.C ==0) & (df[\"Right-Diagnostic Keywords\"] == \"normal fundus\")][\"Right-Fundus\"].sample(300,random_state=42).values\nright_normal[:15]","daf4d2f7":"cataract = np.concatenate((left_cataract,right_cataract),axis=0)\nnormal = np.concatenate((left_normal,right_normal),axis=0)","23b6b93e":"print(len(cataract),len(normal))","b999e2ad":"from tensorflow.keras.preprocessing.image import load_img,img_to_array\ndataset_dir = \"\/kaggle\/input\/ocular-disease-recognition-odir5k\/preprocessed_images\/\"\nimage_size=224\nlabels = []\ndataset = []\ndef create_dataset(image_category,label):\n    for img in tqdm(image_category):\n        image_path = os.path.join(dataset_dir,img)\n        try:\n            image = cv2.imread(image_path,cv2.IMREAD_COLOR)\n            image = cv2.resize(image,(image_size,image_size))\n        except:\n            continue\n        \n        dataset.append([np.array(image),np.array(label)])\n    random.shuffle(dataset)\n    return dataset\n        ","d7b1e0fa":"dataset = create_dataset(cataract,1)","18a1b73d":"len(dataset)","d65d2d87":"dataset = create_dataset(normal,0)","2d9b9619":"len(dataset)","bb725c41":"plt.figure(figsize=(12,7))\nfor i in range(10):\n    sample = random.choice(range(len(dataset)))\n    image = dataset[sample][0]\n    category = dataset[sample][1]\n    if category== 0:\n        label = \"Normal\"\n    else:\n        label = \"Cataract\"\n    plt.subplot(2,5,i+1)\n    plt.imshow(image)\n    plt.xlabel(label)\nplt.tight_layout()    ","7b8d21f6":"x = np.array([i[0] for i in dataset]).reshape(-1,image_size,image_size,3)\ny = np.array([i[1] for i in dataset])","7fbe9d98":"from sklearn.model_selection import train_test_split\nx_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2)","26a84e47":"from keras.applications.vgg16 import VGG16, preprocess_input\nvgg16_weight_path = '..\/input\/keras-pretrained-models\/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'\nvgg = VGG16(\n    weights=vgg16_weight_path,\n    include_top=False, \n    input_shape=(224,224,3)\n)","137b3647":"for layer in vgg.layers:\n    layer.trainable = False","3345f17f":"from tensorflow.keras import Sequential\nfrom keras import layers\nfrom tensorflow.keras.layers import Flatten,Dense\nmodel = Sequential()\nmodel.add(vgg)\nmodel.add(Dense(256, activation='relu'))\nmodel.add(layers.Dropout(rate=0.5))\nmodel.add(Dense(128, activation='sigmoid'))\nmodel.add(layers.Dropout(rate=0.2))\nmodel.add(Dense(128, activation='relu'))\nmodel.add(layers.Dropout(0.1))\nmodel.add(Flatten())\nmodel.add(Dense(1,activation=\"sigmoid\"))","5c78e69a":"model.summary()","f34989e7":"model.compile(optimizer=\"adam\",loss=\"binary_crossentropy\",metrics=[\"accuracy\"])","f210bc48":"history = model.fit(x_train,y_train,batch_size=32,epochs=80,validation_data=(x_test,y_test))","f7509635":"loss,accuracy = model.evaluate(x_test,y_test)\nprint(\"loss:\",loss)\nprint(\"Accuracy:\",accuracy)","e5924322":"from sklearn.metrics import confusion_matrix,classification_report,accuracy_score\ny_pred = model.predict_classes(x_test)","f10f15e3":"accuracy_score(y_test,y_pred)","b2a2dba3":"print(classification_report(y_test,y_pred))","159811ee":"plt.figure(figsize=(12,7))\nfor i in range(10):\n    sample = random.choice(range(len(x_test)))\n    image = x_test[sample]\n    category = y_test[sample]\n    pred_category = y_pred[sample]\n    \n    if category== 0:\n        label = \"Normal\"\n    else:\n        label = \"Cataract\"\n        \n    if pred_category== 0:\n        pred_label = \"Normal\"\n    else:\n        pred_label = \"Cataract\"\n        \n    plt.subplot(2,5,i+1)\n    plt.imshow(image)\n    plt.xlabel(\"Actual:{}\\nPrediction:{}\".format(label,pred_label))\nplt.tight_layout() ","22e074b2":"clf=model\np=0\nq=1\nprediction_train = clf.predict(x_train)\nprediction_test = clf.predict(x_test)\n# prediction_train = [1 if x>0.5 else 0 for x in prediction_train]\nfor i in range(len(prediction_train)):\n    if(prediction_train[i]>0.5):\n        prediction_train[i]=1\n    else:\n        prediction_train[i]=0\n        \nfor i in range(len(prediction_test)):\n    if(prediction_test[i]>0.5):\n        prediction_test[i]=1\n    else:\n        prediction_test[i]=0     ","e731b0d9":"from sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, confusion_matrix\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import precision_score\nfrom sklearn.metrics import recall_score\nfrom sklearn.metrics import accuracy_score\nevaluation = pd.DataFrame({'Model': [],\n                           'Accuracy(train)':[],\n                           'Precision(train)':[],\n                           'Recall(train)':[],\n                           'F1_score(train)':[],\n                           'Specificity(train)':[],\n                           'Accuracy(test)':[],\n                           'Precision(test)':[],\n                           'Recalll(test)':[],\n                           'F1_score(test)':[],\n                           'Specificity(test)':[],\n                          })\nprint(x_train.shape)\nclf=model\nacc_train=format(accuracy_score(prediction_train, y_train),'.3f')\nprecision_train=format(precision_score(y_train, prediction_train, average='binary'),'.3f')\nrecall_train=format(recall_score(y_train,prediction_train, average='binary'),'.3f')\nf1_train=format(f1_score(y_train,prediction_train, average='binary'),'.3f')\ntn, fp, fn, tp = confusion_matrix(prediction_train, y_train).ravel()\nspecificity = tn \/ (tn+fp)\nspecificity_train=format(specificity,'.3f')\n\nacc_test=format(accuracy_score(prediction_test, y_test),'.3f')\nprecision_test=format(precision_score(y_test, prediction_test, average='binary'),'.3f')\nrecall_test=format(recall_score(y_test,prediction_test, average='binary'),'.3f')\nf1_test=format(f1_score(y_test,prediction_test, average='binary'),'.3f')\ntn, fp, fn, tp = confusion_matrix(prediction_test, y_test).ravel()\nspecificity = tn \/ (tn+fp)\nspecificity_test=format(specificity,'.3f')\n\nr = evaluation.shape[0]\nevaluation.loc[r] = ['Neural Network',acc_train,precision_train,recall_train,f1_train,specificity_train,acc_test,precision_test,recall_test,f1_test,specificity_test]\nevaluation.sort_values(by = 'Accuracy(test)', ascending=False)","2a5b80b2":"import scikitplot as skplt\np=y_train\nq=y_test\n\ny_train = pd.DataFrame(y_train)\ny_train=y_train.replace([0,1], [\"Negative\",\"Positive\"])\n\n\npred_train=prediction_train\npred_train=pd.DataFrame(pred_train)\npred_train=pred_train.replace([0,1], [\"Negative\",\"Positive\"])\n\n\npred_test=prediction_test\ny_test = pd.DataFrame(y_test)\ny_test=y_test.replace([0,1], [\"Negative\",\"Positive\"])\npred_test=pd.DataFrame(pred_test)\n\npred_test=pred_test.replace([0,1], [\"Negative\",\"Positive\"])\n\nskplt.metrics.plot_confusion_matrix(\n    y_train, \n    pred_train,\n    figsize=(7,4),\n    title_fontsize='18',\n    text_fontsize='16',\n    title =' ',\n    cmap='BuGn'\n    )\n\nskplt.metrics.plot_confusion_matrix(\n    y_test, \n    pred_test,\n    figsize=(7,4),\n    title_fontsize='18',\n    text_fontsize='16',\n    title =' ',\n    cmap='BuGn'\n    )\ny_train=p\ny_test=q","c2d51d5b":"# n_samples, n_features = X.shape\ny_score = prediction_test\nn_classes = 2\n#Create another array arr2 with size of arr1    \nroc_y_test = prediction_test\n    \ny_score[50]=2\nroc_y_test[50]=2\ny_test\nfrom sklearn.preprocessing import label_binarize\ny_score = label_binarize(y_score, classes=[1, 0])\nroc_y_test = label_binarize(roc_y_test, classes=[1, 0])\nfpr = dict()\ntpr = dict()\nroc_auc = dict()\nfor i in range(n_classes):\n    fpr[i], tpr[i], _ = roc_curve(roc_y_test[:, i], y_score[:, i])\n    roc_auc[i] = auc(fpr[i], tpr[i])\n# Compute micro-average ROC curve and ROC area\nfpr[\"micro\"], tpr[\"micro\"], _ = roc_curve(roc_y_test.ravel(), y_score.ravel())\nroc_auc[\"micro\"] = auc(fpr[\"micro\"], tpr[\"micro\"])\n\n\n\n\n# First aggregate all false positive rates\nlw = 2\nall_fpr = np.unique(np.concatenate([fpr[i] for i in range(n_classes)]))\n\n# Then interpolate all ROC curves at this points\nmean_tpr = np.zeros_like(all_fpr)\nfor i in range(n_classes):\n    mean_tpr += interp(all_fpr, fpr[i], tpr[i])\n\n# Finally average it and compute AUC\nmean_tpr \/= n_classes\n\nfpr[\"macro\"] = all_fpr\ntpr[\"macro\"] = mean_tpr\nroc_auc[\"macro\"] = auc(fpr[\"macro\"], tpr[\"macro\"])\n\n# Plot all ROC curves\nplt.figure()\nplt.plot(fpr[\"micro\"], tpr[\"micro\"],\n         label='micro-average ROC curve (area = {0:0.2f})'\n               ''.format(roc_auc[\"micro\"]),\n         color='deeppink', linestyle=':', linewidth=4)\n\nplt.plot(fpr[\"macro\"], tpr[\"macro\"],\n         label='macro-average ROC curve (area = {0:0.2f})'\n               ''.format(roc_auc[\"macro\"]),\n         color='navy', linestyle=':', linewidth=4)\n\ncolors = cycle(['aqua', 'darkorange', 'cornflowerblue'])\nfor i, color in zip(range(n_classes), colors):\n    plt.plot(fpr[i], tpr[i], color=color, lw=lw,\n             label='ROC curve of class {0} (area = {1:0.2f})'\n             ''.format(i, roc_auc[i]))\n\nplt.plot([0, 1], [0, 1], 'k--', lw=lw)\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('ROC Curve for CNN')\nplt.legend(loc=\"lower right\")\nplt.show()","2d554ad4":">Normal Images","27450083":"><h3>Creating Dataset from images<\/h3>","36cb2360":"><h3>Prediction:<\/h3>","4d91e29c":"><h3>Creating Model<\/h3>","056fa2fe":"><h3>Dividing dataset into x(features) & y(target)<\/h3>","659e3040":" <h3> Extracting Cataract & Normal information from the Dataset <\/h3>"}}