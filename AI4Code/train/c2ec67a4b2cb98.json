{"cell_type":{"b998add9":"code","62ef81c6":"code","e2a151bf":"code","525333ae":"code","5d6486ff":"code","5bc51455":"code","2255aecd":"code","537b904c":"code","b29dcb29":"code","5a2a6e16":"code","bcaf611d":"code","f5e136b2":"code","1d52bcba":"code","33c6acda":"code","d0210d7a":"code","e554b044":"code","b5103733":"code","fd741665":"markdown","ad2c6247":"markdown","d7edc665":"markdown","85e07e99":"markdown","1312ac4b":"markdown","3d6ba990":"markdown","9f07ed2d":"markdown","2b67b4bf":"markdown","322ec8bf":"markdown","d2360058":"markdown","b3b91732":"markdown","d93d23a5":"markdown","dc3b1471":"markdown","bd7f0794":"markdown","7854c552":"markdown"},"source":{"b998add9":"import numpy as np\nimport matplotlib.pyplot as plt\n\n\nfig = plt.figure()\nx = np.arange(10)\ny = 2.5 * np.sin(x \/ 20 * np.pi)\nyerr = np.linspace(0.05, 0.2, 10)\n\nplt.errorbar(x, y + 3, yerr=yerr, label='both limits (default)')\n\nplt.errorbar(x, y + 2, yerr=yerr, uplims=True, label='uplims=True')\n\nplt.errorbar(x, y + 1, yerr=yerr, uplims=True, lolims=True,\n             label='uplims=True, lolims=True')\n\nupperlimits = [True, False] * 5\nlowerlimits = [False, True] * 5\nplt.errorbar(x, y, yerr=yerr, uplims=upperlimits, lolims=lowerlimits,\n             label='subsets of uplims and lolims')\n\nplt.legend(loc='lower right')","62ef81c6":"import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef koch_snowflake(order, scale=10):\n    \"\"\"\n    Return two lists x, y of point coordinates of the Koch snowflake.\n\n    Arguments\n    ---------\n    order : int\n        The recursion depth.\n    scale : float\n        The extent of the snowflake (edge length of the base triangle).\n    \"\"\"\n    def _koch_snowflake_complex(order):\n        if order == 0:\n            # initial triangle\n            angles = np.array([0, 120, 240]) + 90\n            return scale \/ np.sqrt(3) * np.exp(np.deg2rad(angles) * 1j)\n        else:\n            ZR = 0.5 - 0.5j * np.sqrt(3) \/ 3\n\n            p1 = _koch_snowflake_complex(order - 1)  # start points\n            p2 = np.roll(p1, shift=-1)  # end points\n            dp = p2 - p1  # connection vectors\n\n            new_points = np.empty(len(p1) * 4, dtype=np.complex128)\n            new_points[::4] = p1\n            new_points[1::4] = p1 + dp \/ 3\n            new_points[2::4] = p1 + dp * ZR\n            new_points[3::4] = p1 + dp \/ 3 * 2\n            return new_points\n\n    points = _koch_snowflake_complex(order)\n    x, y = points.real, points.imag\n    return x, y","e2a151bf":"x, y = koch_snowflake(order=5)\n\nplt.figure(figsize=(8, 8))\nplt.axis('equal')\nplt.fill(x, y)\nplt.show()","525333ae":"x, y = koch_snowflake(order=2)\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(9, 3),\n                                    subplot_kw={'aspect': 'equal'})\nax1.fill(x, y)\nax2.fill(x, y, facecolor='lightsalmon', edgecolor='orangered', linewidth=3)\nax3.fill(x, y, facecolor='none', edgecolor='purple', linewidth=3)\n\nplt.show()","5d6486ff":"from cycler import cycler\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\n# Define a list of markevery cases and color cases to plot\ncases = [None,\n         8,\n         (30, 8),\n         [16, 24, 30],\n         [0, -1],\n         slice(100, 200, 3),\n         0.1,\n         0.3,\n         1.5,\n         (0.0, 0.1),\n         (0.45, 0.1)]\n\ncolors = ['#1f77b4',\n          '#ff7f0e',\n          '#2ca02c',\n          '#d62728',\n          '#9467bd',\n          '#8c564b',\n          '#e377c2',\n          '#7f7f7f',\n          '#bcbd22',\n          '#17becf',\n          '#1a55FF']\n\n# Configure rcParams axes.prop_cycle to simultaneously cycle cases and colors.\nmpl.rcParams['axes.prop_cycle'] = cycler(markevery=cases, color=colors)\n\n# Create data points and offsets\nx = np.linspace(0, 2 * np.pi)\noffsets = np.linspace(0, 2 * np.pi, 11, endpoint=False)\nyy = np.transpose([np.sin(x + phi) for phi in offsets])\n\n# Set the plot curve with markers and a title\nfig = plt.figure()\nax = fig.add_axes([0.1, 0.1, 0.6, 0.75])\n\nfor i in range(len(cases)):\n    ax.plot(yy[:, i], marker='o', label=str(cases[i]))\n    ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)\n\nplt.title('Support for axes.prop_cycle cycler with markevery')\n\nplt.show()","5bc51455":"import numpy as np\nimport matplotlib.pyplot as plt\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# the random data\nx = np.random.randn(1000)\ny = np.random.randn(1000)\n\n# definitions for the axes\nleft, width = 0.1, 0.65\nbottom, height = 0.1, 0.65\nspacing = 0.005\n\n\nrect_scatter = [left, bottom, width, height]\nrect_histx = [left, bottom + height + spacing, width, 0.2]\nrect_histy = [left + width + spacing, bottom, 0.2, height]\n\n# start with a rectangular Figure\nplt.figure(figsize=(8, 8))\n\nax_scatter = plt.axes(rect_scatter)\nax_scatter.tick_params(direction='in', top=True, right=True)\nax_histx = plt.axes(rect_histx)\nax_histx.tick_params(direction='in', labelbottom=False)\nax_histy = plt.axes(rect_histy)\nax_histy.tick_params(direction='in', labelleft=False)\n\n# the scatter plot:\nax_scatter.scatter(x, y)\n\n# now determine nice limits by hand:\nbinwidth = 0.25\nlim = np.ceil(np.abs([x, y]).max() \/ binwidth) * binwidth\nax_scatter.set_xlim((-lim, lim))\nax_scatter.set_ylim((-lim, lim))\n\nbins = np.arange(-lim, lim + binwidth, binwidth)\nax_histx.hist(x, bins=bins)\nax_histy.hist(y, bins=bins, orientation='horizontal')\n\nax_histx.set_xlim(ax_scatter.get_xlim())\nax_histy.set_ylim(ax_scatter.get_ylim())\n\nplt.show()","2255aecd":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# the bar\nx = np.random.rand(500) > 0.7\n\nbarprops = dict(aspect='auto', cmap='binary', interpolation='nearest')\n\nfig = plt.figure()\n\n# a vertical barcode\nax1 = fig.add_axes([0.1, 0.1, 0.1, 0.8])\nax1.set_axis_off()\nax1.imshow(x.reshape((-1, 1)), **barprops)\n\n# a horizontal barcode\nax2 = fig.add_axes([0.3, 0.4, 0.6, 0.2])\nax2.set_axis_off()\nax2.imshow(x.reshape((1, -1)), **barprops)\n\nplt.show()","537b904c":"import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\n\nw = 3\nY, X = np.mgrid[-w:w:100j, -w:w:100j]\nU = -1 - X**2 + Y\nV = 1 + X - Y**2\nspeed = np.sqrt(U**2 + V**2)\n\nfig = plt.figure(figsize=(7, 9))\ngs = gridspec.GridSpec(nrows=3, ncols=2, height_ratios=[1, 1, 2])\n\n#  Varying density along a streamline\nax0 = fig.add_subplot(gs[0, 0])\nax0.streamplot(X, Y, U, V, density=[0.5, 1])\nax0.set_title('Varying Density')\n\n# Varying color along a streamline\nax1 = fig.add_subplot(gs[0, 1])\nstrm = ax1.streamplot(X, Y, U, V, color=U, linewidth=2, cmap='autumn')\nfig.colorbar(strm.lines)\nax1.set_title('Varying Color')\n\n#  Varying line width along a streamline\nax2 = fig.add_subplot(gs[1, 0])\nlw = 5*speed \/ speed.max()\nax2.streamplot(X, Y, U, V, density=0.6, color='k', linewidth=lw)\nax2.set_title('Varying Line Width')\n\n# Controlling the starting points of the streamlines\nseed_points = np.array([[-2, -1, 0, 1, 2, -1], [-2, -1,  0, 1, 2, 2]])\n\nax3 = fig.add_subplot(gs[1, 1])\nstrm = ax3.streamplot(X, Y, U, V, color=U, linewidth=2,\n                     cmap='autumn', start_points=seed_points.T)\nfig.colorbar(strm.lines)\nax3.set_title('Controlling Starting Points')\n\n# Displaying the starting points with blue symbols.\nax3.plot(seed_points[0], seed_points[1], 'bo')\nax3.axis((-w, w, -w, w))\n\n# Create a mask\nmask = np.zeros(U.shape, dtype=bool)\nmask[40:60, 40:60] = True\nU[:20, :20] = np.nan\nU = np.ma.array(U, mask=mask)\n\nax4 = fig.add_subplot(gs[2:, :])\nax4.streamplot(X, Y, U, V, color='r')\nax4.set_title('Streamplot with Masking')\n\nax4.imshow(~mask, extent=(-w, w, -w, w), alpha=0.5,\n          interpolation='nearest', cmap='gray', aspect='auto')\nax4.set_aspect('equal')\n\nplt.tight_layout()\nplt.show()","b29dcb29":"import matplotlib.pyplot as plt\nfrom matplotlib.patches import ConnectionPatch\nimport numpy as np\n\n# make figure and assign axis objects\nfig = plt.figure(figsize=(9, 5.0625))\nax1 = fig.add_subplot(121)\nax2 = fig.add_subplot(122)\nfig.subplots_adjust(wspace=0)\n\n# pie chart parameters\nratios = [.27, .56, .17]\nlabels = ['Approve', 'Disapprove', 'Undecided']\nexplode = [0.1, 0, 0]\n# rotate so that first wedge is split by the x-axis\nangle = -180 * ratios[0]\nax1.pie(ratios, autopct='%1.1f%%', startangle=angle,\n        labels=labels, explode=explode)\n\n# bar chart parameters\n\nxpos = 0\nbottom = 0\nratios = [.33, .54, .07, .06]\nwidth = .2\ncolors = [[.1, .3, .5], [.1, .3, .3], [.1, .3, .7], [.1, .3, .9]]\n\nfor j in range(len(ratios)):\n    height = ratios[j]\n    ax2.bar(xpos, height, width, bottom=bottom, color=colors[j])\n    ypos = bottom + ax2.patches[j].get_height() \/ 2\n    bottom += height\n    ax2.text(xpos, ypos, \"%d%%\" % (ax2.patches[j].get_height() * 100),\n             ha='center')\n\nax2.set_title('Age of approvers')\nax2.legend(('50-65', 'Over 65', '35-49', 'Under 35'))\nax2.axis('off')\nax2.set_xlim(- 2.5 * width, 2.5 * width)\n\n# use ConnectionPatch to draw lines between the two plots\n# get the wedge data\ntheta1, theta2 = ax1.patches[0].theta1, ax1.patches[0].theta2\ncenter, r = ax1.patches[0].center, ax1.patches[0].r\nbar_height = sum([item.get_height() for item in ax2.patches])\n\n# draw top connecting line\nx = r * np.cos(np.pi \/ 180 * theta2) + center[0]\ny = np.sin(np.pi \/ 180 * theta2) + center[1]\ncon = ConnectionPatch(xyA=(- width \/ 2, bar_height), xyB=(x, y),\n                      coordsA=\"data\", coordsB=\"data\", axesA=ax2, axesB=ax1)\ncon.set_color([0, 0, 0])\ncon.set_linewidth(4)\nax2.add_artist(con)\n\n# draw bottom connecting line\nx = r * np.cos(np.pi \/ 180 * theta1) + center[0]\ny = np.sin(np.pi \/ 180 * theta1) + center[1]\ncon = ConnectionPatch(xyA=(- width \/ 2, 0), xyB=(x, y), coordsA=\"data\",\n                      coordsB=\"data\", axesA=ax2, axesB=ax1)\ncon.set_color([0, 0, 0])\nax2.add_artist(con)\ncon.set_linewidth(4)\n\nplt.show()","5a2a6e16":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# radar green, solid grid lines\nplt.rc('grid', color='#316931', linewidth=1, linestyle='-')\nplt.rc('xtick', labelsize=15)\nplt.rc('ytick', labelsize=15)\n\n# force square figure and square axes looks better for polar, IMO\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8],\n                  projection='polar', facecolor='#d5de9c')\n\nr = np.arange(0, 3.0, 0.01)\ntheta = 2 * np.pi * r\nax.plot(theta, r, color='#ee8d18', lw=3, label='a line')\nax.plot(0.5 * theta, r, color='blue', ls='--', lw=3, label='another line')\nax.legend()\n\nplt.show()","bcaf611d":"#polar axis\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Compute areas and colors\nN = 150\nr = 2 * np.random.rand(N)\ntheta = 2 * np.pi * np.random.rand(N)\narea = 200 * r**2\ncolors = theta\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)","f5e136b2":"#Scatter plot on polar axis, with offset origin\nfig = plt.figure()\nax = fig.add_subplot(111, polar=True)\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\nax.set_rorigin(-2.5)\nax.set_theta_zero_location('W', offset=10)","1d52bcba":"#Scatter plot on polar axis confined to a sector\nfig = plt.figure()\nax = fig.add_subplot(111, polar=True)\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\nax.set_thetamin(45)\nax.set_thetamax(135)\n\nplt.show()","33c6acda":"# This import registers the 3D projection, but is otherwise unused.\nfrom mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import\n\nfrom matplotlib import cm\n#from matplotlib.ticker import LinearLocator, FixedLocator, FormatStrFormatter\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\n\nax = fig.add_subplot(1, 2, 1, projection='3d')\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\nsurf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.viridis,\n                       linewidth=0, antialiased=False)\nax.set_zlim3d(-1.01, 1.01)\n\n#ax.w_zaxis.set_major_locator(LinearLocator(10))\n#ax.w_zaxis.set_major_formatter(FormatStrFormatter('%.03f'))\n\nfig.colorbar(surf, shrink=0.5, aspect=5)\n\nfrom mpl_toolkits.mplot3d.axes3d import get_test_data\nax = fig.add_subplot(1, 2, 2, projection='3d')\nX, Y, Z = get_test_data(0.05)\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\nplt.show()","d0210d7a":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import Axes3D\n\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\nfig = plt.figure()\nax = Axes3D(fig)\nax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.viridis)\n\nplt.show()","e554b044":"# This import registers the 3D projection, but is otherwise unused.\nfrom mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef randrange(n, vmin, vmax):\n    '''\n    Helper function to make an array of random numbers having shape (n, )\n    with each number distributed Uniform(vmin, vmax).\n    '''\n    return (vmax - vmin)*np.random.rand(n) + vmin\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nn = 100\n\n# For each set of style and range settings, plot n random points in the box\n# defined by x in [23, 32], y in [0, 100], z in [zlow, zhigh].\nfor m, zlow, zhigh in [('o', -50, -25), ('^', -30, -5)]:\n    xs = randrange(n, 23, 32)\n    ys = randrange(n, 0, 100)\n    zs = randrange(n, zlow, zhigh)\n    ax.scatter(xs, ys, zs, marker=m)\n\nax.set_xlabel('X Label')\nax.set_ylabel('Y Label')\nax.set_zlabel('Z Label')\n\nplt.show()","b5103733":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# This import registers the 3D projection, but is otherwise unused.\nfrom mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import\n\n\ndef explode(data):\n    size = np.array(data.shape)*2\n    data_e = np.zeros(size - 1, dtype=data.dtype)\n    data_e[::2, ::2, ::2] = data\n    return data_e\n\n# build up the numpy logo\nn_voxels = np.zeros((4, 3, 4), dtype=bool)\nn_voxels[0, 0, :] = True\nn_voxels[-1, 0, :] = True\nn_voxels[1, 0, 2] = True\nn_voxels[2, 0, 1] = True\nfacecolors = np.where(n_voxels, '#FFD65DC0', '#7A88CCC0')\nedgecolors = np.where(n_voxels, '#BFAB6E', '#7D84A6')\nfilled = np.ones(n_voxels.shape)\n\n# upscale the above voxel image, leaving gaps\nfilled_2 = explode(filled)\nfcolors_2 = explode(facecolors)\necolors_2 = explode(edgecolors)\n\n# Shrink the gaps\nx, y, z = np.indices(np.array(filled_2.shape) + 1).astype(float) \/\/ 2\nx[0::2, :, :] += 0.05\ny[:, 0::2, :] += 0.05\nz[:, :, 0::2] += 0.05\nx[1::2, :, :] += 0.95\ny[:, 1::2, :] += 0.95\nz[:, :, 1::2] += 0.95\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\nax.voxels(x, y, z, filled_2, facecolors=fcolors_2, edgecolors=ecolors_2)\n\nplt.show()","fd741665":"### 3D voxel plot of the numpy logo","ad2c6247":"### Streamplot","d7edc665":"### Whats New 0.99 Mplot3d","85e07e99":"### Whats New 1 Subplot3d","1312ac4b":"### Errorbar limit selection","3d6ba990":"### Scatter plot","9f07ed2d":"### 3D scatterplot","2b67b4bf":"### Barcode ","322ec8bf":"### Scatter plot with histograms","d2360058":"### prop_cycle property markevery in rcParams","b3b91732":"### Polar Legend","d93d23a5":"### Filled polygon","dc3b1471":"### Bar of pie","bd7f0794":"# matplotlib\nMatplotlib is a plotting library for the Python programming language and its numerical mathematics extension NumPy. It provides an object-oriented API for embedding plots into applications using general-purpose GUI toolkits like Tkinter, wxPython, Qt, or GTK+. There is also a procedural \"pylab\" interface based on a state machine (like OpenGL), designed to closely resemble that of MATLAB, though its use is discouraged. SciPy makes use of Matplotlib.\n\nMatplotlib was originally written by John D. Hunter, since then it has an active development community, and is distributed under a BSD-style license. Michael Droettboom was nominated as matplotlib's lead developer shortly before John Hunter's death in August 2012, and further joined by Thomas Caswell.","7854c552":"Reference: https:\/\/matplotlib.org\/3.1.0\/api\/_as_gen\/matplotlib.pyplot.figure.html"}}