{"cell_type":{"610f553e":"code","fcc0c206":"code","7d1e4ac8":"code","9ddc962b":"code","f8687d5d":"code","f22ff1fa":"code","7b225803":"code","38e3dc19":"code","eeef11bb":"code","3c143526":"code","e8ed0e4e":"code","c2fe9f50":"code","6fa353a5":"code","a594774c":"code","8f090840":"code","e9ab0342":"code","d461bd71":"code","5101248d":"code","e65a10ba":"code","8ab14f9d":"code","aada3ba9":"code","154e5df3":"code","2b4ed1b6":"code","2b8bba4c":"code","b5e15834":"code","8a79dd9e":"code","63356488":"code","dd255281":"code","15af7a99":"code","95846140":"code","ab2aa5de":"code","8a045d7f":"code","2feeaf92":"code","fac1827e":"code","3c5de9ca":"code","a1865965":"code","5093be52":"code","897d7c13":"markdown","4d279a83":"markdown","78d2546b":"markdown","5a82a2f3":"markdown","076ab42e":"markdown","f8f98f00":"markdown","3158584d":"markdown","c8d5c02e":"markdown","d99ef51d":"markdown","e2c36466":"markdown","e9e3109f":"markdown","07dea748":"markdown","e8d308ed":"markdown","584da85f":"markdown","1190cf3d":"markdown","9cfd4307":"markdown","56013f14":"markdown","67216d6b":"markdown","5b91fb80":"markdown","874281b4":"markdown","38438a45":"markdown","e17c8759":"markdown","ace0a17b":"markdown","d9a0884e":"markdown"},"source":{"610f553e":"import os\nimport sys \nfrom tqdm import tqdm\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport pydicom\n\nimport numpy as np\nimport nibabel as nib\nimport matplotlib.pyplot as plt\nimport SimpleITK as sitk\n\ntrain_path = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train\/'","fcc0c206":"train_dirs = os.listdir(train_path)","7d1e4ac8":"plt.figure(figsize=(14,7))\nplt.subplot(121)\nplt.imshow(pydicom.dcmread(f'{train_path + train_dirs[0]}\/T2w\/Image-111.dcm').pixel_array)\nplt.subplot(122)\nplt.imshow(pydicom.dcmread(f'{train_path + train_dirs[0]}\/T1w\/Image-111.dcm').pixel_array)","9ddc962b":"reader = sitk.ImageSeriesReader()\nreader.LoadPrivateTagsOn()","f8687d5d":"filenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{train_dirs[2]}\/T1w')\nreader.SetFileNames(filenamesDICOM)\nt1_sitk = reader.Execute()","f22ff1fa":"sitk.WriteImage(t1_sitk,'t1.nii')","7b225803":"t1_nib = nib.load('t1.nii')\nt1_nib","38e3dc19":"t1_nib_array = t1_nib.get_fdata() #the voxel array\nt1_nib_array[:3]","eeef11bb":"t1_nib_array.shape","3c143526":"plt.imshow(t1_nib_array[:,:,t1_nib_array.shape[2]\/\/2])","e8ed0e4e":"np.set_printoptions(precision=4, suppress=True)\nt1_nib.affine","c2fe9f50":"t1_nib.affine[:3,:3] @ np.array([2,5,10]) + t1_nib.affine[:3,3]","6fa353a5":"t1_nib.affine @ np.array([2,5,10,1]) #(add 1 as a fourth coordinate)","a594774c":"filenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{train_dirs[2]}\/FLAIR')\nreader.SetFileNames(filenamesDICOM)\nflair_sitk = reader.Execute()\nsitk.WriteImage(flair_sitk,'flair.nii')\n\nflair_nib = nib.load('flair.nii')\nflair_nib_array = flair_nib.get_fdata()","8f090840":"plt.figure(figsize=(12,6))\nplt.subplot(121)\nplt.imshow(t1_nib_array[:,:,t1_nib_array.shape[2]\/\/2])\nplt.subplot(122)\nplt.imshow(flair_nib_array[:,:,flair_nib_array.shape[2]\/\/2])","e9ab0342":"from nilearn.image import resample_img","d461bd71":"%%time \nflair_resampled = resample_img(flair_nib, target_affine=t1_nib.affine, target_shape=t1_nib.shape)\nflair_resampled_array = flair_resampled.get_fdata()","5101248d":"plt.figure(figsize=(12,6))\nplt.subplot(121)\nplt.imshow(t1_nib_array[:,:,t1_nib_array.shape[2]\/\/2])\nplt.subplot(122)\nplt.imshow(flair_resampled_array[:,:,flair_resampled_array.shape[2]\/\/2])","e65a10ba":"filenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{train_dirs[2]}\/T1w')\nreader.SetFileNames(filenamesDICOM)\nt1_sitk = reader.Execute()\nt1_sitk","8ab14f9d":"t1_sitk.GetOrigin() # which is a translation column from the affine matrix, but negative","aada3ba9":"t1_sitk.GetSpacing() # which is how far away the voxel centers are from one another along each of the axes","154e5df3":"t1_sitk.GetDirection() # a flatten cosine matrix which shows rotation of voxel space axes relative to scanner space","2b4ed1b6":"x_scale = np.linalg.norm(t1_nib.affine[:,0])\ny_scale = np.linalg.norm(t1_nib.affine[:,1])\nz_scale = np.linalg.norm(t1_nib.affine[:,2])\nprint(x_scale, y_scale, z_scale)","2b8bba4c":"t1_pure_rotation = np.hstack((t1_nib.affine[:,0].reshape(-1,1)\/x_scale,\n                   t1_nib.affine[:,1].reshape(-1,1)\/y_scale,\n                   t1_nib.affine[:,2].reshape(-1,1)\/z_scale,\n                   t1_nib.affine[:,3].reshape(-1,1)))\nt1_pure_rotation[:3,:3]","b5e15834":"cosine_from_dcm = pydicom.dcmread(filenamesDICOM[1]).ImageOrientationPatient\ncosine_from_dcm","8a79dd9e":"np.cross(cosine_from_dcm[:3], cosine_from_dcm[3:])","63356488":"def resample(image, ref_image):\n\n    resampler = sitk.ResampleImageFilter()\n    resampler.SetReferenceImage(ref_image)\n    resampler.SetInterpolator(sitk.sitkLinear)\n    \n    resampler.SetTransform(sitk.AffineTransform(image.GetDimension()))\n\n    resampler.SetOutputSpacing(ref_image.GetSpacing())\n\n    resampler.SetSize(ref_image.GetSize())\n\n    resampler.SetOutputDirection(ref_image.GetDirection())\n\n    resampler.SetOutputOrigin(ref_image.GetOrigin())\n\n    resampler.SetDefaultPixelValue(image.GetPixelIDValue())\n\n    resamped_image = resampler.Execute(image)\n    \n    return resamped_image","dd255281":"flair_resampled = resample(flair_sitk, t1_sitk)","15af7a99":"t1_sitk_array = sitk.GetArrayFromImage(t1_sitk)\nflair_resampled_array = sitk.GetArrayFromImage(flair_resampled)","95846140":"plt.figure(figsize=(12,6))\nplt.subplot(121)\nplt.imshow(t1_sitk_array[t1_sitk_array.shape[0]\/\/2,:,:])\nplt.subplot(122)\nplt.imshow(flair_resampled_array[flair_resampled_array.shape[0]\/\/2,:,:])","ab2aa5de":"def normalize(data):\n    return (data - np.min(data)) \/ (np.max(data) - np.min(data))","8a045d7f":"%%time\nfilenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{train_dirs[2]}\/T1w')\nreader.SetFileNames(filenamesDICOM)\nt1_sitk = reader.Execute()\n\nfilenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{train_dirs[2]}\/FLAIR')\nreader.SetFileNames(filenamesDICOM)\nflair_sitk = reader.Execute()\n\nfilenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{train_dirs[2]}\/T2w')\nreader.SetFileNames(filenamesDICOM)\nt2_sitk = reader.Execute()\n\nflair_resampled = resample(flair_sitk, t1_sitk)\nt2_resampled = resample(t2_sitk, t1_sitk)\n\nt1_sitk_array = normalize(sitk.GetArrayFromImage(t1_sitk))\nflair_resampled_array = normalize(sitk.GetArrayFromImage(flair_resampled))\nt2_resampled_array = normalize(sitk.GetArrayFromImage(t2_resampled))\n\nstacked = np.stack([t1_sitk_array, t2_resampled_array, flair_resampled_array,])\n\nto_rgb = stacked[:,t1_sitk_array.shape[0]\/\/2,:,:].transpose(1,2,0)\nim = Image.fromarray((to_rgb * 255).astype(np.uint8))","2feeaf92":"im","fac1827e":"reader = sitk.ImageSeriesReader()\nreader.LoadPrivateTagsOn()\nfilenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{train_dirs[20]}\/T1w')\nreader.SetFileNames(filenamesDICOM)\nt1_reference = reader.Execute()","3c5de9ca":"sitk.GetArrayFromImage(t1_reference).shape","a1865965":"plt.imshow(sitk.GetArrayFromImage(t1_reference)[15,:,:])","5093be52":"fig, axs = plt.subplots(5,4, figsize=(12, 18), facecolor='w', edgecolor='k', dpi=100)\naxs = axs.ravel()\n\nfor i, folder in enumerate(train_dirs[:20]):\n    filenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{folder}\/FLAIR')\n    reader.SetFileNames(filenamesDICOM)\n    flair = reader.Execute()\n    \n    flair_resampled = resample(flair, t1_reference)\n    flair_resampled = normalize(sitk.GetArrayFromImage(flair_resampled))\n        \n    filenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{folder}\/T1wCE')\n    reader.SetFileNames(filenamesDICOM)\n    t1 = reader.Execute()\n\n    filenamesDICOM = reader.GetGDCMSeriesFileNames(f'{train_path}\/{folder}\/T2w')\n    reader.SetFileNames(filenamesDICOM)\n    t2 = reader.Execute()\n        \n    t1_resampled = resample(t1, t1_reference)\n    t1_resampled = normalize(sitk.GetArrayFromImage(t1_resampled))\n\n    t2_resampled = resample(t2, t1_reference)\n    t2_resampled = normalize(sitk.GetArrayFromImage(t2_resampled))\n        \n    stacked = np.stack([t1_resampled, t2_resampled, flair_resampled])\n         \n    to_rgb = stacked[:,18,:,:].transpose(1,2,0)\n    im = Image.fromarray((to_rgb * 255).astype(np.uint8))\n    axs[i].imshow(im)","897d7c13":"$$ 1) \\,\\,\\,\\,\\, \n    \\begin{bmatrix} \n        { A }_{ 00 } & { A }_{ 01 } & { A }_{ 02 }\\\\ \n        { A }_{ 10 } & { A }_{ 11 } & { A }_{ 12 }\\\\ \n        { A }_{ 20 } & { A }_{ 21 } & { A }_{ 22 }\\end{bmatrix} \\cdot\n   \\begin{bmatrix} \n        { b_0 } \\\\ { b_1 }  \\\\ { b_2 } \\end{bmatrix} =\n   \\begin{bmatrix}      \n        { A }_{ 00 } \\\\ { A }_{ 10 } \\\\ { A }_{ 20 } \\end{bmatrix} \\cdot { b_0 } + \n   \\begin{bmatrix}      \n        { A }_{ 01 } \\\\ { A }_{ 11 } \\\\ { A }_{ 21 } \\end{bmatrix} \\cdot { b_1 } +    \n   \\begin{bmatrix}      \n        { A }_{ 02 } \\\\ { A }_{ 12 } \\\\ { A }_{ 22 } \\end{bmatrix} \\cdot { b_2 } =    \n   \\begin{bmatrix}   \n   { A }_{ 00 } { b_0 } + { A }_{ 01 } { b_1 } + { A }_{ 02 } { b_2 } \\\\\n   { A }_{ 10 } { b_0 } + { A }_{ 11 } { b_1 } + { A }_{ 12 } { b_2 } \\\\\n   { A }_{ 20 } { b_0 } + { A }_{ 21 } { b_1 } + { A }_{ 22 } { b_2 } \\end{bmatrix} = \n   \\begin{bmatrix} \n        { x_0 } \\\\ { x_1 }  \\\\ { x_2 } \\end{bmatrix} $$ <br\/>\n\n\n$$ 2) \\,\\,\\,\\,\\, \n    \\begin{bmatrix} \n        { x_0 } \\\\ { x_1 }  \\\\ { x_2 } \\end{bmatrix}  + \n    \\begin{bmatrix} \n        { t_0 } \\\\ { t_1 }  \\\\ { t_2 } \\end{bmatrix} = \n    \\begin{bmatrix} \n        { x_0+t_0 } \\\\ { x_1+t_1 }  \\\\ { x_2+t_2 } \\end{bmatrix} = \n    \\begin{bmatrix} \n        { a } \\\\ { b }  \\\\ { c } \\end{bmatrix}\n        $$","4d279a83":"Apparently, as all series in the study have their affines linked to the same scanner space, we can resample them all into the same voxel space. ","78d2546b":"So, if we want to know the coordinates of a voxel b=[2,5,10] in the scanner space, we can just calculate its dot product with upper left 3\u04453 corner of the affine matrix, and then sum the result with the translation vector \ud835\udc61 (which is the forth column of the affine matrix).","5a82a2f3":"The last row in the affine matrix is always the [0,0,0,1] like in the identity matrix, it's just there to make the matrix square so we could use it as a linear operator. Therefore we can also just do this:","076ab42e":"It works rather slowly, but there is a faster way. ","f8f98f00":"Let's convert one of the DICOM-series to a NIfTI file to see it most clearly. There are numerous ways to do it, we'll use the functionality of the SimpleITK library. ","3158584d":"Back to resampling. It's a bit more complicated but still pretty straightforward:","c8d5c02e":"The first two rows differ in sign from the SimpleITK cosine matrix, I'm not sure why. It has something to do with a rotation direction. ","d99ef51d":"Also, if we divide each column by the corresponding spacing number, we'll get a cosine matrix.","e2c36466":"Each DICOM file stores information about its orientation in the scanner space (which is basically the real world, with the center of the coordinate system in the magnet isocenter). ","e9e3109f":"Now we can load it with Nibabel. There's a lot of stuff in the `nibabel.nifti1.Nifti1Image` object, but the two essential things are voxel array and affine matrix. ","07dea748":"# 2. SimpleITK resampling","e8d308ed":"Btw, this information can be acquired from DICOM files. There's a tag for this:","584da85f":"It works **much** faster. ","1190cf3d":"We could actually extract all that information from the previously seen affine matrix. For example, knowing that each column affects one of the resulting voxel coordinates, we could get information about scaling (aka spacing, in this case).","9cfd4307":"The first 3\u04453 part of the matrix provides information about rotation and scaling. The fourth column tells us about translation.","56013f14":"So, this is the voxel array. Its orientation in scanner space is encoded in the affine matrix:","67216d6b":"So, the `SimpleITK.SimpleITK.Image` also contains information about voxel space orientation in the real world. It's not stored by the means of affine matrix though. Here, it goes in a few pieces:","5b91fb80":"You can also resample these images into coronal plane or saggital plane. Or resample them into axial plane, but using another patient as reference (who knows, maybe it's a good way to augment the data). ","874281b4":"Let's resample some more volumes and look at some more pictures. ","38438a45":"As you can see, it has information only about two rows (6 numbers instead of 9). We can calculate the third row though. It's perpendicular two the first two row vectors, so we can calculate their cross product:","e17c8759":"# 1. (not really important part) Affine matrix and simple resampling","ace0a17b":"<div style=\"text-align:center\"> <img src=\"https:\/\/sun9-45.userapi.com\/impg\/Flbnug2OUli1ecXsoIKeUasIGXGj_5hqjX4cRg\/z2nfz8-b3a0.jpg?size=2560x1153&quality=96&sign=0536543610f1655d967af88dbc775e98&type=album\" width=\"800\">","d9a0884e":"Different spatial orientation of images is inconvinient. But we can make it the same. "}}