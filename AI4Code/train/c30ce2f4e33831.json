{"cell_type":{"e3aa4bc7":"code","4c14e9c0":"code","6bb40776":"code","7a87617d":"code","9e0b6558":"code","b2a1a1e4":"code","8be52a9f":"code","07186560":"code","4010e843":"code","374050a8":"code","b0408ae6":"code","c7bb3fb1":"code","10990e5f":"code","9204e6d6":"code","0a506c95":"code","c1bb006b":"code","1dcc24f1":"code","c364cc6c":"code","6867e581":"code","b62649b5":"code","d9fe1b09":"code","4e133c7b":"code","9d682314":"code","5da3b236":"code","8cbf91f0":"code","d5a21855":"code","2e73bf42":"code","054d342d":"code","4e42ad8d":"code","8678def8":"code","ff6fe785":"code","897b6872":"code","71595267":"code","36afb1e9":"markdown","ff9afd9e":"markdown"},"source":{"e3aa4bc7":"# Math Imports\nimport numpy as np  # linear algebra\n# fix random seed for reproducibility\nnp.random.seed(0)\n\nimport pandas as pd  # data processing, CSV file I\/O (e.g. pd.read_csv)\n# from tqdm import tqdm\nimport hashlib\nimport gc\n\nimport matplotlib as mp\nimport matplotlib.pyplot as plt","4c14e9c0":"# See https:\/\/www.tensorflow.org\/tutorials\/using_gpu#allowing_gpu_memory_growth\nimport tensorflow as tf \nconfig = tf.ConfigProto()\nconfig.gpu_options.allow_growth = True\nprint(tf.test.gpu_device_name())\nsess = tf.Session()","6bb40776":"# Keras Imports\nfrom keras.models import Sequential\nfrom keras.layers import Dense, BatchNormalization, Dropout\nfrom keras.callbacks import EarlyStopping, ModelCheckpoint, Callback","7a87617d":"# https:\/\/github.com\/keras-team\/keras\/issues\/2768\nclass GetBest(Callback):\n\n    def __init__(self, monitor='val_loss', verbose=0,\n                 mode='auto', period=1):\n        super(GetBest, self).__init__()\n        self.monitor = monitor\n        self.verbose = verbose\n        self.period = period\n        self.best_epochs = 0\n        self.epochs_since_last_save = 0\n\n        if mode not in ['auto', 'min', 'max']:\n            warnings.warn('GetBest mode %s is unknown, '\n                          'fallback to auto mode.' % (mode),\n                          RuntimeWarning)\n            mode = 'auto'\n\n        if mode == 'min':\n            self.monitor_op = np.less\n            self.best = np.Inf\n        elif mode == 'max':\n            self.monitor_op = np.greater\n            self.best = -np.Inf\n        else:\n            if 'acc' in self.monitor or self.monitor.startswith('fmeasure'):\n                self.monitor_op = np.greater\n                self.best = -np.Inf\n            else:\n                self.monitor_op = np.less\n                self.best = np.Inf\n                \n    def on_train_begin(self, logs=None):\n        self.best_weights = self.model.get_weights()\n\n    def on_epoch_end(self, epoch, logs=None):\n        logs = logs or {}\n        self.epochs_since_last_save += 1\n        if self.epochs_since_last_save >= self.period:\n            self.epochs_since_last_save = 0\n            #filepath = self.filepath.format(epoch=epoch + 1, **logs)\n            current = logs.get(self.monitor)\n            if current is None:\n                warnings.warn('Can pick best model only with %s available, '\n                              'skipping.' % (self.monitor), RuntimeWarning)\n            else:\n                if self.monitor_op(current, self.best):\n                    if self.verbose > 0:\n                        print('\\nEpoch %05d: %s improved from %0.5f to %0.5f,'\n                              ' storing weights.'\n                              % (epoch + 1, self.monitor, self.best,\n                                 current))\n                    self.best = current\n                    self.best_epochs = epoch + 1\n                    self.best_weights = self.model.get_weights()\n                else:\n                    if self.verbose > 0:\n                        print('\\nEpoch %05d: %s did not improve' %\n                              (epoch + 1, self.monitor))            \n                    \n    def on_train_end(self, logs=None):\n        if self.verbose > 0:\n            print('Using epoch %05d with %s: %0.5f' % (self.best_epochs, self.monitor,\n                                                       self.best))\n        self.model.set_weights(self.best_weights)","9e0b6558":"%%time\ndataframe = pd.read_csv('..\/input\/rockyou.txt',\n                        delimiter = \"\\n\", \n                        header = None, \n                        names = [\"Passwords\"],\n                        encoding = \"ISO-8859-1\",\n                        nrows = 100000)\n\n# BUG: ord throws error due to malformed data near 900000 row","b2a1a1e4":"%%time\n# # delete all rows with password over 25 letters and less than 3\n# -> testing at 8 char password\nclutter = dataframe[ (dataframe['Passwords'].str.len() >= 9) \n                   | (dataframe['Passwords'].str.len() <= 7) ].index\n# print(dataframe[ (dataframe['Passwords'].str.len() >= 26) ])\ndataframe.drop(clutter, inplace=True)\n\ndataframe = dataframe.reset_index(drop=True)","8be52a9f":"%%time\n# Drop duplicate password\ndataframe.drop_duplicates(subset=['Passwords'], keep=False, inplace=True)\n\ndataframe = dataframe.reset_index(drop=True)","07186560":"dataframe['MD5'] = [hashlib.md5(str.encode(str(i))).hexdigest() \n                    for i in dataframe['Passwords'].fillna(0).astype(str)]","4010e843":"# training data and keys\npasswords = pd.DataFrame(dataframe['Passwords'])\nhashes = pd.DataFrame(dataframe['MD5'])\n\nhashes.head()\n","374050a8":"# Digest MD5 Hash to decimal array converter  \n\n# split 32 chr hash into 16 hexadecimal pairs\nh01 = dataframe['MD5'].str[:2].apply(int, base=16).astype(float)\/256\nh02 = dataframe['MD5'].str[2:4].apply(int, base=16).astype(float)\/256\nh03 = dataframe['MD5'].str[4:6].apply(int, base=16).astype(float)\/256\nh04 = dataframe['MD5'].str[6:8].apply(int, base=16).astype(float)\/256\n\nh05 = dataframe['MD5'].str[8:10].apply(int, base=16).astype(float)\/256\nh06 = dataframe['MD5'].str[10:12].apply(int, base=16).astype(float)\/256\nh07 = dataframe['MD5'].str[12:14].apply(int, base=16).astype(float)\/256\nh08 = dataframe['MD5'].str[14:16].apply(int, base=16).astype(float)\/256\n\nh09 = dataframe['MD5'].str[16:18].apply(int, base=16).astype(float)\/256\nh10 = dataframe['MD5'].str[18:20].apply(int, base=16).astype(float)\/256\nh11 = dataframe['MD5'].str[20:22].apply(int, base=16).astype(float)\/256\nh12 = dataframe['MD5'].str[22:24].apply(int, base=16).astype(float)\/256\n\nh13 = dataframe['MD5'].str[24:26].apply(int, base=16).astype(float)\/256\nh14 = dataframe['MD5'].str[26:28].apply(int, base=16).astype(float)\/256\nh15 = dataframe['MD5'].str[28:30].apply(int, base=16).astype(float)\/256\nh16 = dataframe['MD5'].str[30:32].apply(int, base=16).astype(float)\/256\n# convert hex to dec and divide by 255 to normalize\n\ntrain = np.column_stack((h01, h02, h03, h04,\n                         h05, h06, h07, h08,\n                         h09, h10, h11, h12,\n                         h13, h14, h15, h16))\n\ntrain[1:3]","b0408ae6":"# Digest password into encoded decimal array.\n\n#df['ascii'] = [ord(x) for x in df['label']]\n\n# ascii ord values can be as high as\n\nxp01 = [ord(x) for x in dataframe['Passwords'].str[0:1]]\np01 = np.array(xp01, dtype=np.float32)\/128\nxp02 = [ord(x) for x in dataframe['Passwords'].str[1:2]]\np02 = np.array(xp02, dtype=np.float32)\/128\nxp03 = [ord(x) for x in dataframe['Passwords'].str[2:3]]\np03 = np.array(xp03, dtype=np.float32)\/128\nxp04 = [ord(x) for x in dataframe['Passwords'].str[3:4]]\np04 = np.array(xp04, dtype=np.float32)\/128\nxp05 = [ord(x) for x in dataframe['Passwords'].str[4:5]]\np05 = np.array(xp05, dtype=np.float32)\/128\nxp06 = [ord(x) for x in dataframe['Passwords'].str[5:6]]\np06 = np.array(xp06, dtype=np.float32)\/128\nxp07 = [ord(x) for x in dataframe['Passwords'].str[6:7]]\np07 = np.array(xp07, dtype=np.float32)\/128\nxp08 = [ord(x) for x in dataframe['Passwords'].str[7:8]]\np08 = np.array(xp08, dtype=np.float32)\/128\n\nkey = np.column_stack((p01, p02, p03, p04, p05, p06, p07, p08))\n\nkey[1:5]","c7bb3fb1":"hashcode = train[0:1]\nplt.imshow(np.reshape(hashcode,[4,4]), interpolation=\"nearest\", cmap=\"gray\")","10990e5f":"password = key[0:1]\nkey_shape = key.shape[1]\nplt.imshow(np.reshape(password,[1,key_shape]), interpolation=\"nearest\", cmap=\"gray\")","9204e6d6":"# Set input shape based on training data. \n# Digested hash shape = 16.\ntrain_dim = train.shape[1]","0a506c95":"# Fuzzy dropout model to force learning.\n# Fuzz disabled for testing.\nmodel = Sequential()\n\nmodel.add(Dense(256, input_dim=train_dim, activation='relu'))\n# model.add(BatchNormalization())\n# model.add(Dropout(0.5))\n# model.add(Dense(256, activation='relu'))\n# model.add(BatchNormalization())\n# model.add(Dropout(0.5))\n\nmodel.add(Dense(128, activation='relu'))\n# model.add(BatchNormalization())\n# model.add(Dropout(0.5))\nmodel.add(Dense(128, activation='relu'))\n# model.add(BatchNormalization())\n# model.add(Dropout(0.5))\n\n\nmodel.add(Dense(64, activation='relu'))\n# model.add(BatchNormalization())\n# model.add(Dropout(0.5))\n# model.add(Dense(64, activation='relu'))\n# model.add(BatchNormalization())\n# model.add(Dropout(0.5))\n\nmodel.add(Dense(32, activation='relu'))\n# model.add(BatchNormalization())\n# model.add(Dropout(0.5))\n# model.add(Dense(32, activation='relu'))\n# model.add(BatchNormalization())\n# model.add(Dropout(0.5))\n\nmodel.add(Dense(16, activation='relu'))\nmodel.add(Dense(8, activation='sigmoid'))","c1bb006b":"# Compile Model \/\/ \nmodel.compile(loss='categorical_crossentropy',\n              metrics=['accuracy'],\n              optimizer='adam')\n\ncallbacks = [EarlyStopping(monitor='val_acc', patience=100),\n             GetBest(monitor='val_acc', verbose=1, mode='max')]\n\nmodel.summary()","1dcc24f1":"history = model.fit(train, key,\n                    callbacks=callbacks,\n                    epochs=3000,\n                    batch_size=128,\n                    # shuffle=True,\n                    validation_split=0.1,\n                    verbose=2)","c364cc6c":"# Plot training & validation accuracy values\nplt.plot(history.history['acc'])\nplt.plot(history.history['val_acc'])\nplt.title('Model accuracy')\nplt.ylabel('Accuracy')\nplt.xlabel('Epoch')\nplt.legend(['Train', 'Test'], loc='upper left')\nplt.show()","6867e581":"# evaluate model\nscore = model.evaluate(train, key, verbose=0)\n\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","b62649b5":"# MD5 test array\n\ntest = ('test1234','test2345','testtest','password')\n\ntest[0]","d9fe1b09":"# Digest MD5 hashes to test.\n","4e133c7b":"# Predict password decimal array from unique MD5.\npredictions = model.predict(train, batch_size=None, verbose=0)","9d682314":"predictions[0]","5da3b236":"# predictions = predictions*128","8cbf91f0":"# predictions[0:10].astype(int)","d5a21855":"passes = (key[0:17000]*128).astype(int)\n\npasses[1:10]","2e73bf42":"drift=1\nguess = ((predictions[0:17000]*128)\/drift).astype(int)\n\nguess[1:10]","054d342d":"key_id = 7\n\ndecoded = [chr(x) for x in passes[key_id]]\n\nprint(decoded)\n\ndecrypt = [chr(x) for x in guess[key_id]]\n\nprint(decrypt)","4e42ad8d":"# set(decoded) & set(decrypt)\n\nanswers = set(decoded).intersection(decrypt)\n\nprint (answers)","8678def8":"[x for x in decoded if x in decrypt]","ff6fe785":"list(set(decoded).intersection(set(decrypt)))","897b6872":"# Decode predicted decimal array into characters.\n# ascii ord values can be as high as\n\n# p01 = np.array(xp01, dtype=np.float32)*255\n# xp01 = [chr(x) for x in predictions['Passwords'].str[0:1]]\n# p02 = np.array(xp02, dtype=np.float32)*255\n# xp02 = [chr(x) for x in predictions['Passwords'].str[1:2]]\n# p03 = np.array(xp03, dtype=np.float32)*255\n# xp03 = [chr(x) for x in predictions['Passwords'].str[2:3]]\n# p04 = np.array(xp04, dtype=np.float32)*255\n# xp04 = [chr(x) for x in predictions['Passwords'].str[3:4]]\n# p05 = np.array(xp05, dtype=np.float32)*255\n# xp05 = [chr(x) for x in predictions['Passwords'].str[4:5]]\n# p06 = np.array(xp06, dtype=np.float32)*255\n# xp06 = [chr(x) for x in predictions['Passwords'].str[5:6]]\n# p07 = np.array(xp07, dtype=np.float32)*255\n# xp07 = [chr(x) for x in predictions['Passwords'].str[6:7]]\n# p08 = np.array(xp08, dtype=np.float32)*255\n# xp08 = [chr(x) for x in predictions['Passwords'].str[7:8]]\n\n\n# test_key = np.column_stack((p01, p02, p03, p04, p05, p06, p07, p08))\n\n# test_key[1:5]","71595267":"# submission = pd.DataFrame({'Hash': test_id, 'Password': predictions})\n\n# submission.head()","36afb1e9":"GetBest(Callback) class hidden, used to track and reload best model weights.","ff9afd9e":"**Using Keras to Decrypt MD5.**\n\nCurrent results is 16% accuracy.\n\nWhile this prediction rate is extremely low, it proves hash decryption is possible.\n\nFurther refinement should improve accuracy.\n\nAdditional features have been streamlined to increase dev speed.\n\nTesting has been limited to 8 character passwords."}}