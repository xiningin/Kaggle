{"cell_type":{"35a82626":"code","050148a2":"code","e68d5887":"code","d62871dc":"code","d0a2ef88":"code","5ef7f192":"code","de053413":"code","d62bdb04":"code","b68a5cb0":"code","379b9b20":"code","795ba445":"code","1b22daac":"code","b4809271":"code","f8598939":"code","d76b5795":"code","ba6afbf4":"code","af1c8697":"code","6b1c726e":"code","17711dad":"code","229b59e4":"code","59a04fc5":"code","d442d180":"code","58625370":"code","c4017abd":"code","d9966cd6":"code","636c7890":"code","0595588a":"code","a77d4f03":"markdown","89d41d11":"markdown","7de25212":"markdown","40cf5d81":"markdown","bb96639a":"markdown","e1f33fc7":"markdown","fe38079c":"markdown","4da4286e":"markdown","0424cda6":"markdown","746feec0":"markdown","178413d8":"markdown","6f1013bf":"markdown"},"source":{"35a82626":"import numpy as np\nfrom numpy import array","050148a2":"# Creating an Array (Key data structure in NumPy)\na = array([1,2,3,4,5])\na","e68d5887":"type(a)\n# ndarray is a fixed-sized array in memory that contains data of the same type.","d62871dc":"#combining Array's:\na = array([1,2,3,4,5])\nb = array([6,7,8,9,10])\nnp.vstack((a,b))\n# np.hstack : stacks the array horizontally.","d0a2ef88":"# Let's see how to manipulate and access your data correctly in NumPy arrays:\n# You can convert list or list of lists into an ndarray just by calling array(list_name).\n\narr = array([[1, 2],[3, 4],[5, 6]])\narr","5ef7f192":"# accessing the 1st row 1st element\narr[0,0]","de053413":"# accessing the 3rd row 1st element\narr[2,0]","d62bdb04":"# So you get the idea of indexing, let's look at slicing (Var[from:to]):\n\n# You can access all data in an array dimension by specifying the slice \u2018:\u2019 with no indexes.\narr[:]","b68a5cb0":"# negative slicing of a one-dimensional array\narr = array([11, 12, 13, 14, 15])\nprint(arr[-2:])","379b9b20":"# split input and output data\narr = array([\n[1,2,3],\n[4,5,6],\n[7,8,9]])\n\n# separate data\nX, y = arr[:, :-1], arr[:, -1]\nprint('Input data: \\n',X)\nprint('Output data:')\nprint(y)\n","795ba445":"# shape of the 2D array:\narr.shape","1b22daac":"# reshape 1D array to 2D\narr = array([11, 22, 33, 44, 55])\nprint(arr.shape)\n# reshape\narr = arr.reshape((arr.shape[0], 1))\nprint(arr.shape)\n","b4809271":"# reshape 2D array to 3D\n# list of data\narr = [[11, 22],[33, 44],[55, 66]]\n# array of data\narr = array(arr)\nprint(arr.shape)\n# reshape\narr = arr.reshape((arr.shape[0], arr.shape[1], 1))\nprint(arr.shape)","f8598939":"# broadcast scalar to two-dimensional array\n# define array\nA = array([\n[1, 2, 3],\n[1, 2, 3]])\nprint(A)\n# define scalar\nb = 2\nprint(b)\n# broadcast\nC = A + b\nprint(C)","d76b5795":"# vector multiplication\n# define first vector\na = array([1, 2, 3])\nprint(a)\n# define second vector\nb = array([1, 2, 3])\nprint(b)\n# multiply vectors\nc = a * b\nprint(c)","ba6afbf4":"# vector dot product\na = array([1, 2, 3])\nprint(a)\nb = array([1, 2, 3])\nprint(b)\n\n# multiply vectors\nc = a.dot(b)\nprint(c)","af1c8697":"# Vector L1 Norm:\nfrom numpy.linalg import norm\n# defining a vector:\na = array([1, 2, 3])\nprint(a)\n# calculate norm\nl1 = norm(a, 1)\nprint(l1)","6b1c726e":"# Vector L2 Norm:\n# define vector\na = array([1, 2, 3])\nprint(a)\n# calculate norm\nl2 = norm(a)\nprint(l2)","17711dad":"# define first matrix\nA = array([\n[1, 2, 3],\n[4, 5, 6]])\nprint(A)\nprint('------')\n# define second matrix\nB = array([\n[1, 2, 3],\n[4, 5, 6]])\nprint(B)\nprint('------')","229b59e4":"# add matrices\nprint(\"Addition of two matrices: \")\nC = A + B # sub matrices, C = A - B\nprint(C)\nprint(\"\\nMultiplication of two matrices: \") # also called Hadamard Product (element-wise multiplication)\nMul = A * B\nprint(Mul)\nprint(\"\\nDivision of two matrices: \") \nDiv = A * B\nprint(Div)","59a04fc5":"# matrix dot product\nA = array([\n[1, 2],\n[3, 4],\n[5, 6]])\nprint(A)\nprint('------')\nB = array([\n[1, 2],\n[3, 4]])\nprint(B)\nprint('------')\n# multiply matrices\nC = A.dot(B)       # you can also multiply matrices with @ operator , C = A @ B\nprint(C)","d442d180":"# Creating diagonal matrix\nfrom numpy import array\nfrom numpy import diag\n# define square matrix\nM = array([\n[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\nprint(M)\nprint('------')\n# extract diagonal vector\nd = diag(M)\nprint(d)\nprint('------')\n# create diagonal matrix from vector\nD = diag(d)\nprint(D)","58625370":"# Creating triangular matrices\nfrom numpy import array\nfrom numpy import tril\nfrom numpy import triu\n# define square matrix\nM = array([\n[1, 2, 3],\n[1, 2, 3],\n[1, 2, 3]])\nprint(M)\nprint('------')\n# lower triangular matrix\nlower = tril(M)\nprint(lower)\nprint('------')\n# upper triangular matrix\nupper = triu(M)\nprint(upper)","c4017abd":"# Creating identity matrix\nfrom numpy import identity\nI = identity(3)\nprint(I)","d9966cd6":"# Transpose\nA = array([[1, 2],[3, 4],[5, 6]])\nprint('A:\\n',A)\nprint('-----')\n# calculate transpose\nC = A.T\nprint('Transpose of A: \\n',C)\n","636c7890":"# inverse of a  matrix\nfrom numpy.linalg import inv\n# define matrix\nA = array([\n[1.0, 2.0],\n[3.0, 4.0]])\nprint(A)\nprint('------')\n# invert matrix\nB = inv(A)\nprint(B)","0595588a":"# Determinant: The determinant of a square matrix is a scalar representation of the volume of the matrix.\n# creating a 2X2 Numpy matrix\nn_array = np.array([[50, 29], [30, 44]])\n  \n# Displaying the Matrix\nprint(\"Numpy Matrix is:\")\nprint(n_array)\n  \n# calculating the determinant of matrix\ndet = np.linalg.det(n_array)\n  \nprint(\"\\nDeterminant of given 2X2 matrix:\")\nprint(int(det))","a77d4f03":"> So that's it , hope this Notebook helped you in your learning journey !\n> \n> \n> Resources: -> https:\/\/numpy.org\/learn\/  -> https:\/\/docs.python.org\/3\/library\/index.html\n> \n> \n> References: -> https:\/\/machinelearningmastery.com\/linear_algebra_for_machine_learning\/\n> \n> \n> P.S -> This was my First Kaggle Notebook , Please leave your critics in the comment section for further improvement.\n\n> Cheers!!","89d41d11":"We can also use negative indexes in slices. For example, we can slice the last two items in\nthe list by starting the slice at -2 (the second last item) and not specifying a to index; that\ntakes the slice to the end of the dimension.","7de25212":"*Array Broadcasting:*\n\nArithmetic operations can only be performed on arrays that have the same dimensions and same size.\n\nThis limitation on array arithmetic is quite limiting.\n\nThankfully, NumPy provides a built-in workaround to allow arithmetic between arrays with differing sizes.\n","40cf5d81":"> *Operation's on Matrix:*\n    1) Transpose\n    2) Inverse\n    3) Determinant","bb96639a":"We can calculate the dot product between two vectors in Python using the dot() function\non a NumPy array.\n","e1f33fc7":"After slicing your data, you may need to reshape it. For example, some libraries, such as\nscikit-learn, may require that a one-dimensional array of output variables (y) be shaped as a\ntwo-dimensional array with one column and outcomes for each column.\n\nIt is common to need to reshape a one-dimensional array into a two-dimensional array with\none column and multiple arrays. NumPy provides the reshape() function on the NumPy array\nobject that can be used to reshape the data.","fe38079c":"#### Linear Algebra:  is the important key to understand calculus and statistics needed for machine learning. Understanding linear algebra will lift your game across the board. \n#### Deeper Intuition: If you can understand machine learning methods at the level of vectors and matrices you will improve your intuition for how and when they work.\n\n* **Matrix** is a key data structure in linear algebra. When you fit a supervised machine learning model,you have a matrix (X) and a vector (y). \n* The **Vector** is another key data structure in linear algebra. Each row has the same length, i.e. the same number of columns, therefore we can say that the data is vectorized where rows can be provided to a model one at a time or in batch and the model can be pre-configured to expect rows of a fixed width.\n\nIn this notebook we will see how to deal with Array ,Matrix, Vectors and much more using NumPy.","4da4286e":"It is common to split your loaded data into input variables (X) and the output variable (y). We\ncan do this by slicing all rows and all columns up to, but before the last column, then separately\nindexing the last column. For the input features, we can select all rows and all columns except\nthe last one by specifying ':' for in the rows index, and :-1 in the columns index.\n","0424cda6":"Calculating the size or length of a vector is often required either directly or as part of a broader\nvector or vector-matrix operation. \n\n* The length of the vector is referred to as the vector norm or\n    the vector\u2019s magnitude.\n    \n* The length of a vector can be calculated using the L\n  1 norm, where the 1 is a superscript of the L.\n\n* The length of a vector can be calculated using the L\n  2 norm, where the 2 is a superscript of the L. \n","746feec0":"Vectors are used throughout the field of machine learning in the description of algorithms and processes such as the target variable (y)\nwhen training an algorithm.\n\nA vector is a tuple of one or more values called scalars.\nWe can represent a vector in Python as a NumPy array. A NumPy array can be created from\na list of numbers.\n\nSo Vectors and Matrix are just ndarray.\n","178413d8":"> Types of Matrix:\n    Square Matrix \n    ,Symmetric Matrix \n    ,Triangular Matrix \n    ,Diagonal Matrix \n    ,Identity Matrix \n    and Orthogonal Matrix ","6f1013bf":"**Matrices:**"}}