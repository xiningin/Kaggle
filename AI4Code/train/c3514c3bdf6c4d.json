{"cell_type":{"233a5e81":"code","61f9e3da":"code","04493043":"code","28876a30":"code","286c48ab":"code","449f3e06":"code","8e00e1a5":"code","30b5367f":"code","b354c655":"code","c5e75d65":"code","8746494c":"code","f1f31629":"code","99f82870":"code","8143c415":"code","392a1d25":"code","4f023e6f":"code","27ec6559":"code","75351025":"code","893adf51":"code","2a6732cf":"code","45dcacfd":"code","7cf23dc5":"code","a7d60184":"code","0b30f50c":"code","1d5f04ac":"markdown","cead43ff":"markdown","5975aa9a":"markdown","c3870de1":"markdown","7206c153":"markdown","4da60a2d":"markdown","dcebd303":"markdown","8801ffd0":"markdown","9fcef8d4":"markdown"},"source":{"233a5e81":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#     for filename in filenames:\n#         print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","61f9e3da":"from fastai.vision import *","04493043":"data_path = Path('\/kaggle\/input\/intel-image-classification')\ndata_path.ls()","28876a30":"# get image data using fastai's data block api\ndata_sz64 = ImageList.from_folder(data_path)\\\n.split_by_folder(train='seg_train', valid='seg_test')\\\n.label_from_folder()\\\n.add_test_folder(test_folder='seg_pred')\\\n.transform(get_transforms(), size=64)\\\n.databunch()\\\n.normalize(imagenet_stats)\nlearner_sz64 = cnn_learner(data_sz64, models.resnet34, metrics=[accuracy, error_rate])\nlearner_sz64.fit_one_cycle(16)","286c48ab":"# get image data using fastai's data block api\ndata = ImageList.from_folder(data_path)\\\n.split_by_folder(train='seg_train', valid='seg_test')\\\n.label_from_folder()\\\n.add_test_folder(test_folder='seg_pred')\\\n.transform(get_transforms(), size=150)\\\n.databunch()\\\n.normalize(imagenet_stats)","449f3e06":"data.show_batch(rows=3, figsize=(7,7))","8e00e1a5":"print(data.c, data.classes)","30b5367f":"# create CNN using resnet model & train the model with defaults\nlearner_default = cnn_learner(data, models.resnet34, metrics=[accuracy, error_rate])\nlearner_default.fit_one_cycle(16)","b354c655":"learner_default.recorder.plot_losses()","c5e75d65":"np.random.seed(4)\nlearner = cnn_learner(data, models.resnet34, metrics=[accuracy, error_rate])","8746494c":"# train only the weights of newly introduced layers, using default learning_rate\nlearner.freeze()\nlearner.fit_one_cycle(8)","f1f31629":"# save model\nlearner.model_dir = '\/kaggle\/working\/'\nlearner.save('learner_v1')","99f82870":"learner.recorder.plot_losses()","8143c415":"# let us try experimenting more on our model, but from the initially training model, 'learner_v1' to save the computational time\n# create new CNN model & load a previous model version\nlearner = cnn_learner(data, models.resnet34, metrics=[accuracy, error_rate])\nlearner.load('\/kaggle\/working\/learner_v1')","392a1d25":"# here, now that the newly added layers are having proper weights, we are trying to train all the layers in resnet model\nlearner.unfreeze()\nlearner.fit_one_cycle(5)","4f023e6f":"learner.model_dir='\/kaggle\/working\/'\nlearner.save('learner_v2')","27ec6559":"interp = ClassificationInterpretation.from_learner(learner)","75351025":"interp.plot_top_losses(9, figsize=(10, 10))","893adf51":"interp.plot_confusion_matrix(figsize=(10,10), dpi=75)","2a6732cf":"interp.most_confused(min_val=2)","45dcacfd":"learner.export('\/kaggle\/working\/export.pkl')","7cf23dc5":"pred_list = ImageList.from_folder(data_path\/'seg_pred')\nlearner_inference = load_learner('\/kaggle\/working\/', test=pred_list)","a7d60184":"preds, _ = learner_inference.get_preds(ds_type=DatasetType.Test)","0b30f50c":"import random\nrand_max = len(preds)\nfor i in range(10):\n    j = random.randint(0, rand_max)\n    pred_name = data.classes[np.argmax(np.array(preds[j]))]\n    print(pred_name, '--', preds[j])\n    show_image(pred_list[j])","1d5f04ac":"**Model with defaults**","cead43ff":"***Default learning rate 1e-3 looks good - as the loss curve is quickly on downside***","5975aa9a":"**Experimenting & fine tuning**","c3870de1":"**Note: Improved accuracy when compared to learner_v1**","7206c153":"**Note: With change in transforms 'size' attribute, accuracy improved by ~3%**\n\nWith 10 epochs, we got an accuracy of ~93.33%.\n\nI think, from 11th cycle, the error rate is kind of increasing (varying upwards) & towards the end, we ran into overfitting.","4da60a2d":"**Look into model results**","dcebd303":"**Predicting on seg_pred data using 'learner_v2**","8801ffd0":"**Why freeze? What does it do?**\n\nAll thanks to Jeremy & the fastai course, for very nice explaination on this.\n\nWhen CNN model is created, we are using resnet34 architecture pretrained for imagenet. The data & the classification targetted here need not be same as that of in imagenet. So, when creating the new model, the fastai library identifies the number of classes involved and introduces 2 new layers (towards the end), with new random weights.\n\nfreeze() ensures that only the weights of new layers are updated, but not those of existing resnet layers.","9fcef8d4":"Key things to note:\n1. train_loss > valid_loss => underfitting\n2. error_rate improving with each epoch => maybe, we can try running more epochs to make it better & closely monitor train_loss, valid_loss & error_rate"}}