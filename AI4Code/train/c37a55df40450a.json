{"cell_type":{"57a1c413":"code","d862d570":"code","215a4a69":"code","98c5edb7":"code","9a8158dd":"code","e6308dab":"code","21da23ba":"code","eb927982":"code","d485bf54":"code","74fbe167":"code","bb8c8bb4":"code","e4904074":"code","63ce8f26":"code","e8eddc5d":"code","9caba0f3":"code","fbce4d00":"code","5f2315c7":"code","56eeacb4":"code","b3b9b065":"code","7f0753d0":"code","7735e501":"code","e4bd9c9e":"code","7def5076":"code","059eda91":"code","3b9bb8ef":"markdown","ed882917":"markdown","f9eae22f":"markdown","f5421e89":"markdown","3f401c1a":"markdown","2d5fe778":"markdown","ac784ae8":"markdown","64cc2fc2":"markdown","dd2396da":"markdown","ae3bf3be":"markdown","02ccc3a4":"markdown","8f659f63":"markdown","f4ab8c0b":"markdown","25c74705":"markdown","bd6d4c1a":"markdown","92c9d56e":"markdown","31385df2":"markdown","2ffdc7b5":"markdown","f130c304":"markdown","8c5f3863":"markdown","69202142":"markdown","7dc06245":"markdown","9a11b05e":"markdown","84568894":"markdown","fe967f6b":"markdown","1c8642ac":"markdown","dd407b14":"markdown","7d67d42d":"markdown","4c57c356":"markdown","a88bbe70":"markdown","314a539b":"markdown"},"source":{"57a1c413":"# Manipula\u00e7\u00e3o de dados\nimport pandas as pd\n# Redes Neurais\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten\nfrom tensorflow.keras.optimizers import RMSprop\n# Plot\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# Avalia\u00e7\u00e3o\nfrom sklearn.metrics import classification_report, confusion_matrix","d862d570":"train = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")","215a4a69":"# Analisando o dataset\nprint(\"Quantidade de elementos de treino: {}\". format(len(train)))\nprint(train.head())","98c5edb7":"plt.imshow(train.drop(labels = [\"label\"],axis = 1).values[3].reshape(28,28), \n           cmap=plt.cm.binary)\nplt.show()","9a8158dd":"# Separando x_train e y_train\nY = train[\"label\"]\nX = train.drop(labels = [\"label\"],axis = 1)\nprint(X.head())","e6308dab":"# Transformando a imagem 2d em um numpy array (imagem 28*28)\nx = X.values.reshape(42000, 28, 28, 1)\n\n#Normalizando para valores entre 0 e 1\nx = x.astype('float32')\nx \/= 255","21da23ba":"# Existem 10 d\u00edgitos, logo, 10 classes para representar cada um deles\nnum_classes = 10\n\n# Convertendo para um vetor de saida com 10 dimensoes\n# ex. 8 => [0,0,0,0,0,0,0,0,1,0]\ny = keras.utils.to_categorical(Y, num_classes)\nprint(\"Classifica\u00e7\u00e3o do quarto exemplo: \",y[3])","eb927982":"# Separando uma parte para treino (85%) e outra para valida\u00e7\u00e3o (15%)\nfrom sklearn.model_selection import train_test_split\nx_train, x_val, y_train, y_val = train_test_split(x, y, test_size = 0.25, random_state=6)\nprint('Qtde de treino: {}'.format(len(x_train)))\nprint('Qtde de valida\u00e7\u00e3o: {}'.format(len(x_val)))","d485bf54":"# Criando o modelo Sequential\n# Sequential: Modelo Keras de ir adicionando camadas (como um lego)\n# Conv2D: Camada com kernels (filtros) que percorrem a imagem extraindo caracter\u00edsitcas (mapas de caracte\u00edsticas)\n# MaxPooling2D: Camada que reduz a dimensionalidade dos mapas de caracter\u00edsticas 2D\n# Flatten: Camada que transforma um mapa de caracter\u00edsticas 2D num vetor para classficador final\n# Dense: Camada onde todas as entradas est\u00e3o conectadas em cada neur\u00f4nio (totalmente conectada)\n\n# \nmodel = Sequential()\n\nmodel.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)))\n\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\nmodel.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Flatten())\nmodel.add(Dense(100, activation='relu'))\nmodel.add(Dropout(0.2))\n\nmodel.add(Dense(num_classes, activation='softmax'))\n\nmodel.summary()\n\n","74fbe167":"#Compila o modelo escolhendo a fun\u00e7\u00e3o de loss e o otimizador\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=RMSprop(),\n              metrics=['accuracy'])","bb8c8bb4":"batch_size = 32\nepochs = 10","e4904074":"callbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model.h5',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=10,verbose=1)\n]","63ce8f26":"history = model.fit(x_train, y_train,\n                    batch_size=batch_size,\n                    epochs=epochs,\n                    callbacks = callbacks_list,\n                    verbose=1,\n                    validation_data=(x_val, y_val))","e8eddc5d":"fig, ax = plt.subplots(1,2, figsize=(16,8))\nax[0].plot(history.history['loss'], color='b', label=\"Training loss\")\nax[0].plot(history.history['val_loss'], color='r', label=\"validation loss\",axes =ax[0])\nlegend = ax[0].legend(loc='best', shadow=True)\n\nax[1].plot(history.history['accuracy'], color='b', label=\"Training accuracy\")\nax[1].plot(history.history['val_accuracy'], color='r',label=\"Validation accuracy\")\nlegend = ax[1].legend(loc='best', shadow=True)","9caba0f3":"from tensorflow.keras.models import load_model\nmodel = load_model('model.h5')","fbce4d00":"score = model.evaluate(x_val, y_val, verbose=0)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","5f2315c7":"import itertools\n\n#Plot the confusion matrix. Set Normalize = True\/False\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n","56eeacb4":"import numpy as np\n\n# Classificando toda base de teste\n#y_pred = model.predict_classes(x_val)\ny_pred = np.argmax(model.predict(x_val), axis=-1)\n\n# voltando pro formato de classes\ny_test_c = np.argmax(y_val, axis=1)\ntarget_names = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n#Matrix de confus\u00e3o\ncm = confusion_matrix(y_test_c, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\n\nprint('Classification Report')\nprint(classification_report(y_test_c, y_pred, target_names=target_names))\n","b3b9b065":"test = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")\nprint(\"Qtde de testes: {}\".format(len(test)))","7f0753d0":"x_test = test.values.reshape(len(test),28,28,1)\nx_test = x_test.astype('float32')\nx_test \/= 255","7735e501":"y_pred = np.argmax(model.predict(x_test), axis=-1)","e4bd9c9e":"i = 0\nplt.imshow(test.values[i].reshape(28,28), cmap=plt.cm.binary)\nplt.show()\nprint('Previsto pelo modelo: {}'.format(y_pred[i]))","7def5076":"results = pd.Series(y_pred,name=\"Label\")\nsubmission = pd.concat([pd.Series(range(1,len(y_pred)+1),name = \"ImageId\"),results],axis = 1)\nprint(\"O formato segue o padr\u00e3o abaixo:\\n\")\nprint(submission.head(10))","059eda91":"submission.to_csv(\"mlp_mnist_v1.csv\",index=False)","3b9bb8ef":"## Submiss\u00e3o para a competi\u00e7\u00e3o","ed882917":"<div style=\"text-align: justify\"> \n\u00c9 necess\u00e1rio retirar o index para a submiss\u00e3o, por isso foi utilizado index=False na fun\u00e7\u00e3o abaixo.\n<\/div>","f9eae22f":"#### Verificando um deles","f5421e89":"#### Definindo crit\u00e9rios de parada antecipada (early stopping)","3f401c1a":"### Compilar o modelo","2d5fe778":"### Defini\u00e7\u00e3o de par\u00e2metros e o treino do modelo em si","ac784ae8":"### Ajustes dos dados","64cc2fc2":"#### Visualizando um dos exemplos","dd2396da":"### Visualizando o treino","ae3bf3be":"### Salvando o melhor resultado","02ccc3a4":"### Leitura dos dados","8f659f63":"### Separando os dados de treino\n* x_train: caracter\u00edsticas dos exemplos\n* y_train: label de cada exemplos","f4ab8c0b":"### Carregar o dataset de teste","25c74705":"## Dataset \n","bd6d4c1a":"### Relat\u00f3rio de m\u00e9tricas por classe e matriz de confus\u00e3o","92c9d56e":"## Avaliando o Modelo","31385df2":"### Resultado do treino","2ffdc7b5":"Esta atividade tem por objetivo, utilizar redes neurais convolucionais para o reconhecimento de d\u00edgitos escritos \u00e0 m\u00e3o ","f130c304":"### Classificando os exemplos do dataset de teste","8c5f3863":"### Colocando no formato aceito pela competi\u00e7\u00e3o","69202142":"### Arquitetura do modelo","7dc06245":"### Formatando e normalizando o dataset de teste","9a11b05e":"## Bibliotecas","84568894":"#### Treino","fe967f6b":"#### Tamanho do batch e \u00e9pocas","1c8642ac":"### Visualiza\u00e7\u00e3o dos dados","dd407b14":"<div style=\"text-align: justify\"> \n    Melhorias no modelo: eu aumentei o n\u00famero de camadas convolucionais, assim como, mais kernels(3, 3) nessas camadas. Optei por dobrar a quantidade de kernels da segunda e terceira camada em rela\u00e7\u00e3o a primeira (de 32 para 64). Tamb\u00e9m adicionei mais uma camada de pooling(max pooling), o que deixa o modelo um pouco mais a prova contra varia\u00e7\u00f5es nas posi\u00e7\u00f5es das caracter\u00edsitcas, al\u00e9m de aumentar o n\u00famero de neur\u00f4nios da pen\u00faltima camada.\n<\/div>","7d67d42d":"### Distribui\u00e7\u00e3o entre treino e valida\u00e7\u00e3o","4c57c356":"## Treino","a88bbe70":"<div style=\"text-align: justify\">  \nOptei por reduzir um pouco, mais precisamente de 90% para 85%, a parte dos dados para treino, para tentar uma melhor generaliza\u00e7\u00e3o (menos overfitting) e com isso obter uma melhor acur\u00e1cia nos dados de valida\u00e7\u00e3o.\n<\/div>","314a539b":"### Salvando o arquivo"}}