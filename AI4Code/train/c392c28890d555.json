{"cell_type":{"97bc6110":"code","36f1c165":"code","e382545e":"code","17320aab":"code","5fa13be8":"code","35ebe5a9":"markdown","3fc9352c":"markdown","35d7ad4f":"markdown","f2f2807b":"markdown","7c8d6113":"markdown"},"source":{"97bc6110":"import numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\n\nfrom sklearn.cluster import KMeans, DBSCAN, OPTICS\nfrom sklearn.datasets import make_blobs\nfrom kmodes.kmodes import KModes\nfrom sklearn.preprocessing import StandardScaler","36f1c165":"\"\"\"Gaussian blobs for clustering\"\"\"\nX_kmeans, y = make_blobs(n_samples=500, random_state=250)\nX_kmeans = pd.DataFrame(StandardScaler().fit_transform(X_kmeans))\n'''Apply K-Means'''\nkmean_clusters =  KMeans(n_clusters=3, random_state=250).fit_predict(X_kmeans)\n\nplt.figure(figsize = (8,8))\nplt.title('K-Means Clustering',fontsize= 20)\nplt.xlabel('Feature 1', fontsize=18)\nplt.ylabel('Feature 2', fontsize=18)\nf = plt.scatter(X_kmeans[0],X_kmeans[1],c=kmean_clusters)","e382545e":"\"\"\"Random categorical data\"\"\"\ncategorical_data = pd.DataFrame(np.random.choice(54, size = (200, 2)))\n'''Apply K-Modes'''\nkm = KModes(n_clusters=3)\nkmode_clusters = km.fit_predict(categorical_data)\nkmode_clusters","17320aab":"centers = [[1, 1], [-1, -1], [1, -1]]\nX_dbscan, labels_true = make_blobs(n_samples=500, centers=centers, cluster_std=0.4, random_state=2)\nX_dbscan = pd.DataFrame(StandardScaler().fit_transform(X_dbscan))\n'''Apply DBSCAN'''\ndb = DBSCAN(eps=0.3, min_samples=10).fit(X_dbscan)\nlabels = db.labels_\n\nplt.figure(figsize=(8,8))\nplt.title('DBSCAN',fontsize= 20)\nplt.xlabel('Feature 1',fontsize= 18)\nplt.ylabel('Feature 2',fontsize= 18)\nfig = plt.scatter(X_dbscan[0], X_dbscan[1], c= labels)","5fa13be8":"centers = [[1, 1], [-1, -1], [1, -1]]\nX_optics, labels_true = make_blobs(n_samples=500, centers=centers, cluster_std=0.4,random_state=2)\nX_optics = pd.DataFrame(StandardScaler().fit_transform(X_optics))\n'''Apply OPTICS'''\noptics = OPTICS(xi=.05, min_cluster_size=.05, min_samples=30).fit(X_optics)\nlabels_optics = optics.labels_\n\nplt.figure(figsize=(8,8))\nplt.title('OPTICS',fontsize= 20)\nplt.xlabel('Feature 1',fontsize= 18)\nplt.ylabel('Feature 2',fontsize= 18)\nfig = plt.scatter(X_optics[0], X_optics[1], c= labels_optics)","35ebe5a9":"# K-Modes Algorithm\nK-Modes algorithm is used for categorical data. It is very similar to K-Means. Instead of using Means for selecting the next cluster centre, K-Modes uses mode to find the next Cluster center.\n","3fc9352c":"# Clustering\nClustering is a form of unsupervised learning. The process of grouping similar data points is called Clustering. Clustering is also a form of data compression since a cluster can be treated as a single group. The data points inside a cluster are similar and the data points outside a cluster are dissimilar. Although classification is an effective means to distinguishing groups but requires labeling to perform analysis. Clustering attempts to cluster similar data points without the help of target labels.\n\nMost commonly used algorithms are,\n* K-Means\n* K-Modes\n* DBSCAN (Density-Based Spatial Clustering of Applications with Noise)\n* OPTICS (Ordering Points To Identify Cluster Structures)","35d7ad4f":"# OPTICS\nAlthough DBSCAN can cluster objects given input parameters such as $\\epsilon$ and MinPts, it still leaves the user with the responsibility of selecting parameter values that will lead to the discovery of acceptable clusters. To help overcome this difficulty, a cluster analysis method called OPTICS was proposed.\n* The core-distance of an object p is the smallest $\\epsilon'$ value that makes {p} a core object. If p is not a core object, the core-distance of p is undefined.\n* The reachability-distance of an object q with respect to another object p is the greater value of the core-distance of p and the Euclidean distance between p and q. If p is not a core object, the reachability-distance between p and q is undefined.\n ","f2f2807b":"# K-Means Algorithm\nThe k-means algorithm takes the input parameter, k, and partitions a set of n objects into k clusters so that the resulting intracluster similarity is high but the intercluster similarity is low. Cluster similarity is measured in regard to the mean value of the objects in a cluster, which can be viewed as the cluster\u2019s centroid or center of gravity.\n\n* First, it randomly selects k of the objects, each of which initially represents a cluster mean or center. \n* For each of the remaining objects, an object is assigned to the cluster to which it is the most similar, based on the distance between the object and the cluster mean. \n* It then computes the new mean for each cluster. This process iterates until the criterion function converges.","7c8d6113":"# DBSCAN \nDBSCAN (Density-Based Spatial Clustering of Applications with Noise) is a density- based clustering algorithm. The algorithm grows regions with sufficiently high density into clusters and discovers clusters of arbitrary shape in spatial databases with noise. It defines a cluster as a maximal set of density-connected points.\n\nThe basic ideas of density-based clustering involve a number of new definitions. \n\n* The neighborhood within a radius $\\epsilon$ of a given object is called the $\\epsilon$-neighborhood of the object.\n* If the $\\epsilon$-neighborhood of an object contains at least a minimum number, MinPts, of objects, then the object is called a core object.\n* Given a set of objects, D, we say that an object p is directly density-reachable from object q if p is within the $\\epsilon$-neighborhood of q, and q is a core object.\n* An object p is density-reachable from object q with respect to $\\epsilon$ and MinPts in a set of objects, D, if there is a chain of objects $p_1$,..., $p_n$, where $p_1$= q and $p_n$ = p such that $p_i+1$ is directly density-reachable from $p_i$ with respect to e and MinPts, for 1 $\\leq$ i $\\leq$ n, $p_i \\in$ D.\n* An object p is density-connected to object q with respect to $\\epsilon$ and MinPts in a set of objects, D, if there is an object o $\\in$ D such that both p and q are density-reachable from o with respect to $\\epsilon$ and MinPts.\n\n\u201cHow does DBSCAN find clusters?\u201d DBSCAN searches for clusters by checking the $\\epsilon$-neighborhood of each point in the database. If the $\\epsilon$-neighborhood of a point p contains more than MinPts, a new cluster with p as a core object is created. DBSCAN then iteratively collects directly density-reachable objects from these core objects, which may involve the merge of a few density-reachable clusters. The process terminates when no new point can be added to any cluster.\n\n**Reference**: Data Mining:Concepts and Techniques Second Edition, Jiawei Han, Micheline Kamber."}}