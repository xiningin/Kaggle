{"cell_type":{"616273d1":"code","559a8036":"code","884d8da6":"code","6052c980":"code","917aaf05":"code","af0d7c27":"code","7eb5db98":"markdown","63894584":"markdown","16d250d4":"markdown","69651b33":"markdown","061c7338":"markdown","35be117b":"markdown","af6ea9df":"markdown","1934eb51":"markdown","6dc0e876":"markdown","7f6dac00":"markdown","58581f58":"markdown","150110cc":"markdown","bbde1195":"markdown","bbc69c4c":"markdown","63e9e271":"markdown","1b28bf08":"markdown","2fbf22b2":"markdown","a17be218":"markdown","d45402b7":"markdown","74ac7a1a":"markdown","54002d05":"markdown","09677708":"markdown","39dccf36":"markdown","75f569e3":"markdown","d55baafb":"markdown","6c685dc0":"markdown","038b3869":"markdown","2466c9c0":"markdown"},"source":{"616273d1":"from math import *","559a8036":"def fakultaet(n):\n    prod = 1\n    for i in range(1, n+1):\n        prod *= i\n    return prod\n\ndef binom(n, k):\n    return fakultaet(n)\/(fakultaet(k) * fakultaet(n-k))","884d8da6":"def stirling(n, k, kind, check):\n    if k > n or (k == 0 and n > 0):\n        return 0\n    elif k == 0 and n == 0:\n        return 1\n    else:\n        first = \"-\".join([str(n-1), str(k-1)])\n        second = \"-\".join([str(n-1), str(k)])\n        try:\n            result_first = check[first]\n        except:\n            result_first = stirling(n-1, k-1, kind, check)\n            check.update({first: result_first})\n        try:\n            result_second = check[second]\n        except:\n            result_second = stirling(n-1, k, kind, check)\n            check.update({second: result_second})\n        if kind == 1:\n            factor = n-1\n        elif kind == 2:\n            factor = k\n        else:\n            return \"Error\"\n        result = result_first + factor * result_second\n        print (f\"s{kind}({n}, {k}) = s{kind}({n-1}, {k-1}) + {factor}*s{kind}({n-1}, {k}) = {result_first} + {factor}*{result_second} = {result}\")\n        return result\n    \ndef calculate_stirling():\n    n = int(input(\"n: \"))\n    k = int(input(\"k: \"))\n    kind = int(input(\"1. (enter 1) or 2 (enter 2).\"))\n    check = {}\n    print(\"-------------------------------------\")\n    result = stirling(n, k, kind, check)\n    print(\"-------------------------------------\")\n    print(\"Result: \", result)","6052c980":"def bell(n):\n    check = {}\n    summ = 0\n    for k in range(n+1):\n        summ += stirling(n, k, kind=2, check=check)\n    return summ","917aaf05":"def pq(p, q):\n    first = -p\/2\n    second = sqrt(first**2 - q)\n    return first + second, first - second\ndef rekursion(b0, b1, a1, a2=0):\n    if a2 == 0:\n        # 1. Grades\n        if a1 == 1:\n            if b0 == 0:\n                if b1 == 1:\n                    print(f\"f(n) = n\")\n                else:\n                    print(f\"f(n) = {b1} * n\")\n            else:\n                if b1 == 1:\n                    print(f\"f(n) = {b0} + n\")\n                else:\n                    print(f\"f(n) = {b0} + {b1} * n\")\n        else:\n            if b0 == 0:\n                if b1 == 1:\n                    if a1 == 2:\n                        print(f\"f(n) = {a1}^n - 1\")\n                    else:\n                        print(f\"f(n) = ({a1}^n - 1)\/{a1 - 1}\")\n                else:\n                    if a1 == 2:\n                        print(f\"f(n) = {b1} * {a1}^n - 1\")\n                    else:\n                        print(f\"f(n) = {b1} * ({a1}^n - 1)\/{a1 - 1}\")\n            else:\n                if b1 == 1:\n                    if a1 == 2:\n                        print(f\"f(n) = {b0} * {a1}^n + {a1}^n - 1\")\n                    else:\n                        print(f\"f(n) = {b0} * {a1}^n + ({a1}^n - 1)\/({a1 - 1})\")\n                else:\n                    if a1 == 2:\n                        print(f\"f(n) = {b0} * {a1}^n + {b1} * {a1}^n - 1\")\n                    else:\n                        print(f\"f(n) = {b0} * {a1}^n + {b1} * ({a1}^n - 1)\/({a1 - 1})\")\n        return lambda n: b0 * a1**n + b1 * (a1**n - 1)\/(a1 - 1) if a1 != 1 else b0 + n * b1\n    else:\n        # 2. Grades\n        alpha, beta = pq(-a1, -a2)\n        if alpha == beta: print(\"Alpha und Beta m\u00fcssen unterschiedlich sein!\")\n        alpha_coef = (b1 - b0*beta)\/(alpha - beta)\n        beta_coef = (b1 - b0*alpha)\/(alpha - beta)\n        print(f\"f(n) = {int(round(alpha_coef - beta_coef))} wenn n == 0\")\n        print(f\"f(n) = {int(round(alpha_coef * alpha - beta_coef * beta))} wenn n == 1\")\n        print(f\"f(n) = {round(alpha_coef, 2)} * {round(alpha, 2)}^n - {round(beta_coef, 2)} * {round(beta, 2)}^n sonst\")\n        return lambda n: int(round(alpha_coef * alpha**n - beta_coef * beta**n))\n    \ndef calculate_rekursion():\n    op = int(input(\"Enter either one of these: Hanoi(1), Fib(2), Other(3)\"))\n    if op == 1:\n        return rekursion(0, 1, 2, 0)\n    elif op == 2:\n        return rekursion(0, 1, 1, 1)\n    b0 = int(input(\"Enter b0: \"))\n    b1 = int(input(\"Enter b1: \"))\n    a1 = int(input(\"Enter a1: \"))\n    a2 = int(input(\"Enter a2: \"))\n    print(f\"Es ist eine Rekursionsgleichung {1 + a2 != 0}. Art\")\n    return rekursion(b0, b1, a1, a2)","af0d7c27":"def master(a, b, d):\n    print(\"T(n) = {a} * T(ceil(n, {b})) + O(n^{d})\")\n    if d > log(a, b):\n        if d == 1:\n            return f\"O(n)\"\n        else:\n            return f\"O(n^{d})\"\n    elif d < log(a, b):\n        if log(a, b) == 1:\n            return f\"O(n)\"\n        else:\n            return f\"O(n^{int(round(log(a, b)))})\"\n    else:\n        if d == 0:\n            return f\"O(log(n))\"\n        elif d == 1:\n            return f\"O(n log(n))\"\n        else:\n            return f\"O(n^{d} log(n))\"\n        \ndef calculate_master():\n    op = int(input(\"Enter either one of these: BinarySearch(1), MergeSort(2), Other(3)\"))\n    if op == 1:\n        return master(1, 2, 0)\n    elif op == 2:\n        return master(2, 2, 1)\n    else:\n        a = int(input(\"Enter a: \"))\n        b = int(input(\"Enter b: \"))\n        d = int(input(\"Enter d: \"))\n        return master(a, b, d)","7eb5db98":"**Verallgemeinerte Schubfachprinzip**\n\nIst $f : X \\to Y$ eine Abbildung, so gibt es ein $y \\in Y$ mit $|f^{-1}(y)| \\ge \\lceil \\frac{|X|}{|Y|} \\rceil$","63894584":"**Fakult\u00e4t**\n\n$n! = \\begin{cases}1 &\\text{ wenn }n = 0 \\\\ n * (n-1)! &\\text{ sonst} \\end{cases}$","16d250d4":"**Erzeugende Funktionen**\n\n$A(x) = \\overset{\\infty}{\\underset{k = 0}{\\sum}} a_k * x^k$\n\nWenn $k \\in \\Bbb{N}, \\forall i \\in \\Bbb{N} . a_i = 1$: $A_k(x) = \\frac{x^{k+1}-1}{x-1}\\$\n\nWenn $\\forall i \\in \\Bbb{N} . a_i = i+1$: $A(x) = \\frac{1}{(1-x)^2}$","69651b33":"**Catalan-Zahlen**\n\nAuf wieviele Weisen l\u00e4sst sich das Produkt von n+1 Zahlen $x_0, x_1, \\dots, x_n$ klammern?\n\n$C_n = \\overset{n-1}{\\underset{k=0}{\\sum}} C_k * C_{n-k-1}$","061c7338":"**Ordnungen**\n\nEine bin\u00e4re Relation $R \\subseteq S \\times T$\n\nEine Relation R auf S ist:\n* reflexiv, wenn $\\forall x \\in S : (x, x) \\in R$\n* antisymmetrisch, wenn $\\forall x, y \\in S : (x, y) \\in R \\land (y, x) \\in R \\implies x = y$\n* transitiv, wenn $\\forall x, y, z \\in S : (x, y) \\in R \\land (y, z) \\in R \\implies (x, z) \\in R$","35be117b":"**Lineare Ordnung**\n\nLinear: $\\forall x, y \\in S . (x, y), (y, x) \\in R \\implies x = y$\n\nAnders gesagt: Alle Elemente der R sind vergleichbar.","af6ea9df":"**Zweiten Grades L\u00f6sung**\n\n$x_n = \\begin{cases}b_n &\\text{ wenn }n \\in \\{0, 1\\} \\\\ a_1 x_{n-1} + a_2 * x_{n-2} &\\text{ sonst} \\end{cases}$\n\nSeien $\\alpha, \\beta \\in \\Bbb{R}$ zwei L\u00f6sungen der Gleichung $t^2 - a_1 t - a_2 = 0$ mit $\\alpha \\ne \\beta$\n\nDann gilt $x_n = \\frac{b_1 - b_0 \\beta}{\\alpha - \\beta} \\alpha^n - \\frac{b_1 - b_0 \\alpha}{\\alpha - \\beta} \\beta^n$","1934eb51":"**Zyklus**\n\nEin Zyklus $(i_1, i_2, \\dots, i_t)$ der L\u00e4nge $t \\ge 1$ einer Permutation $\\pi$ ist eine Folge $i_1, i_2, \\dots, i_t$, so dass $\\forall j \\in [t] . \\pi(i_j) = i_{j+1 \\mod t}$","6dc0e876":"**Divide-and-Conquer-Rekursionsgleichungen**\n\nDie meisten Gleichungen in Form von $t(n) = a * t(n\/b) + g(n)$","7f6dac00":"**Tabelle f\u00fcr Kombinatorik**\n\n| n B\u00e4lle, m Urnen | Allgemein                          | Injektiv            | Subjektiv          | Bijektiv |\n|------------------|------------------------------------|---------------------|--------------------|----------|\n| Alle anders      | $m^n$                              | $m^{\\underline{n}}$ | $m!S(n, m)$        | $n!$     |\n| B\u00e4lle anders     | $\\binom{m+n-1}{n}$                 | $\\binom{m}{n}$      | $\\binom{n-1}{m-1}$ | $1$      |\n| Urnen anders     | $\\underset{k\\in [m]}{\\sum}S(n, k)$ | $1$                 | $S(n, m)$          | $1$      |\n| Alle gleich      | $\\underset{k\\in [m]}{\\sum}P(n, k)$ | $1$                 | $P(n, m)$          | $1$      |","58581f58":"R ist eine Relation auf S.\n\nAnalog: R ist eine nat\u00fcrliche Zahl, z.B. 1\n\n**Transitive H\u00fclle**\n\n $R^+ = R \\bigcup \\{(x, y) | \\exists k \\in \\Bbb{N}, s_1, \\dots, s_k \\in S . (x, s1), (s1, s2), \\dots, (s_k, y) \\in R\\}$\n\n Analog: Dann kann man alle anderen positiven nat\u00fcrlichen Zahlen aus 1 berechnen\n\n**Reflexiv-Transitive H\u00fclle**\n\n$R^* = R^+ \\bigcup \\{(x, x) | x \\in S\\}$\n\nAnalog: Dann erh\u00e4lt man die Menge der nat\u00fcrlichen Zahlen, wenn man 0 hinzuf\u00fcgt","150110cc":"**Satz von Pascal-Dreieck**\n\nF\u00fcr alle $k, n \\in \\Bbb{N}$ mit $k < n$ gilt $\\binom{n}{k} = \\binom{n-1}{k-1} + \\binom{n-1}{k}$","bbde1195":"**L\u00f6sen von Rekursionsgleichungen**\n\nMan kann die Rekursionsgleichungen als eine lineare Kombination vom Koeffizientenvektor a und Vektor von Zwischenergebnissen x erzeugen.\n\nAngenommen: $n \\ge k, b_k$ ist Inhomogenit\u00e4t, $\\forall i \\in [k] x_{i-1} = b_{i-1}$\n\n$x_n = \\begin{bmatrix} a_1 & a_2 & \\dots & a_k\\end{bmatrix} \\begin{bmatrix} x_{n-1} \\\\ x_{n-2} \\\\ \\dots \\\\ x_{n-k} \\end{bmatrix} + b_k$ hei\u00dft lineare Rekursionsgleichung k-ten Grades","bbc69c4c":"**Binomial-Koeffizient**\n\n$\\binom{n}{k} = \\frac{n!}{k! * (n-k)!}$","63e9e271":"**T\u00fcrme von Hanoi**\n\n$H_n = H_{n-1} + 1 + H_{n-1} = 2H_{n-1} + 1$","1b28bf08":"**Bell-Zahlen**\n\n$B_n = \\overset{n}{\\underset{k=0}{\\sum}} S(n, k)$","2fbf22b2":"**Rekursionsgleichungen**\n\nEine Rekursionsgleichung f\u00fcr eine Folge von Zahlen $(a_n)_{n \\ge 0}$ ist eine Gleichung, die $a_n$ in Abh\u00e4ngigkeit von allen $a_i$ f\u00fcr $i \\in [0, n-1]$ f\u00fcr alle $n \\ge n_0$ ausdr\u00fcckt. Es gibt immer eine Anfangsbedingung und weitere Schritte.","a17be218":"**K-Zahlpartition**\n\nEine k-Partition der Zahl n ist eine Zerlegung von n in k Summanden: $n = \\overset{k}{\\underset{i=1}{\\sum}} n_i$\n\n$P(n, k) = \\begin{cases} 0 &\\text{ wenn }k > n \\text{ oder }n > 0 \\text{ und }k = 0 \\\\ 1 &\\text{ wenn }n = 0 \\text{ und }k = 0\\end{cases}$\n\nUngeordnete Zahlpartitionen: \nDie Summandenreihenfolge ist egal\n\n$\\underset{k=1}{\\overset{r}{\\sum}} P(n, k) = P(n + r , r)$\n\nGeordnete Zahlpartitionen: Die Summandenreihenfolge ist wichtig\n\n$\\binom{n-1}{k-1}$","d45402b7":"**Master-Theorem**\n\n$a > 0, b > 1, d \\ge 0 \\implies T(n) = aT(\\lceil \\frac{n}{b} \\rceil) + O(n^d)  = \\begin{cases} O(n^d) &\\text{ falls }d > \\log_ba \\\\ O(n^d \\log n) &\\text{ falls }d = \\log_ba \\\\ O(n^{\\log_ba}) &\\text{ falls }d < \\log_ba\\end{cases}$\n","74ac7a1a":"| Ordnungen         | Reflexiv | Transitiv | Antisymmetrisch | Linear |\n|-------------------|----------|-----------|-----------------|--------|\n| Quasiordnung      | X        | X         |                 |        |\n| Partielle Ordnung | X        | X         | X               |        |\n| Totale Ordnung    | X        | X         | X               | X      |","54002d05":"**Hasse Diagramm**: Graphische Darstellung von partiellen Ordnungen. Zwei Elemente sind inzident zu einer Kante, wenn ein Element in h\u00f6herer Ordnung liegt als das andere. Transitivit\u00e4t zwischen zwei Elementen gilt, wenn es einen ungerichteten Pfad gibt, und man kann die Elemente vergleichen. \n\n**Maximales Element**: Falls es kein $y \\in S$ mit $y \\ne x$ und $x \\le y$ gibt.\n\n**Minimales Element**: Falls es kein $y \\in S$ mit $y \\ne x$ und $x \\ge y$ gibt.\n\n**Untere Schranke**: Falls f\u00fcr alle $x_i$ mit $i \\in [n]$ gilt: $x_i \\le a$\n\n**Obere Schranke**: Falls f\u00fcr alle $x_i$ mit $i \\in [n]$ gilt: $x_i \\ge a$\n\n**Supremum**: Die kleinste obere Schranke\n\n**Infimum**: Die gr\u00f6\u00dfte untere Schranke\n\n**Kette**: Eine Menge $K \\subseteq S$, so dass alle $a, b \\in K$ vergleichbar sind\n\n**Antikette**: Eine Menge $L \\subseteq S$, so dass alle $a, b \\in L$ mit $a \\ne b$ unvergleichbar sind. Man kann eine partielle Ordnung in Antiketten zerlegen (wie z.B. Stufe 1, Stufe 2, ...)\n\n**Partitionierung**\n\nEs sei S eine endliche, nicht-leere Menge und $(S, \\preccurlyeq)$ eine partielle Ordnung. \n* Die minimale Anzahl von Antiketten aus $(S, \\preccurlyeq)$, mit denen man S partitionieren kann, ist gleich der maximalen Anzahl von Elementen in einer Kette von $(S, \\preccurlyeq)$\n\n* Die maximale Anzahl von Elementen in einer Antikette von $(S, \\preccurlyeq)$ ist gleich der minimalen Anzahl von Ketten aus $(S, \\preccurlyeq)$, mit denen man S partitionieren kann.\n\n**H\u00f6he**: Die Anzahl der Elemente einer gr\u00f6\u00dften Kette\n\n**Weite**: Die Anzahl der Elemente einer gr\u00f6\u00dften Antikette\n\n**Inklusionsrelation detaillierter**: \n$(P([n]), \\preccurlyeq)$ sei die partielle Ordnung.\n\nDie H\u00f6he ist $n+1$:\n* Es gibt eine Kette der Gr\u00f6\u00dfe $n+1$\n* Es gibt eine Partition in $n+1$ Antiketten\n\nDie Weite ist $\\binom{n}{\\lceil\\frac{n}{2}\\rceil}$:\n* Es gibt eine Antikette der Gr\u00f6\u00dfe $\\binom{n}{\\lceil\\frac{n}{2}\\rceil}$\n* Es gibt eine Partition in $\\binom{n}{\\lceil\\frac{n}{2}\\rceil}$ Ketten \n","09677708":"**K-Partition**\n\n$X = \\overset{k}{\\underset{i=1}{\\dot\\bigcup}} X_i$ wobei $\\forall i, j \\in [k]. i \\ne j \\implies X_i \\ne X_j$ und $X_i \\ne \\{\\}$","39dccf36":"**Ersten Grades L\u00f6sung**\n\n$x_n = \\begin{cases}b_0 &\\text{ wenn }n = 0 \\\\ a * x_{n-1} + b_1 &\\text{ sonst} \\end{cases}$\n\n$x_n = \\begin{cases} b_0 * a^n + b_1 * \\frac{a^n-1}{a-1} &\\text{ falls }a \\ne 1 \\\\ b_0 + n * b_1 &\\text{ falls }a = 1\\end{cases}$","75f569e3":"**Permutation**\n\n$\\pi = \\begin{pmatrix} a_1 & a_2 & \\dots & a_n \\\\ \\pi(a_1) & \\pi(a_2) & \\dots & \\pi(a_n) \\end{pmatrix}$","d55baafb":"**Vandermondesche Identit\u00e4t**\n\nF\u00fcr alle $k, m, n \\ge 0$ gilt $\\binom{n+m}{k} = \\underset{l=0}{\\overset{k}{\\sum}} \\binom{n}{l} \\binom{m}{k-l}$","6c685dc0":"**Fibonacci-Zahlen**\n\nEs ist eine Rekursionsgleichung zweiten Grades. $f_n = a_{1}f(n-1) + a_{2}f(n-2)$ wobei f\u00fcr Fibonacci-Zahlen $a_{n-1} = a_{n-2} = 1$\n\n$f(n) = \\begin{cases} 1 &\\text{ wenn }n \\in \\{0, 1\\} \\\\ f(n-2) + f(n-1) &\\text{ sonst}\\end{cases}$","038b3869":"**Prinzip der Inklusion und Exklusion**\n\n$|\\underset{i=1}{\\overset{n}{\\bigcup}} A_i| = \\underset{r=1}{\\overset{n}{\\sum}} [(-1)^{r-1} \\underset{I\\subseteq [n]:|I| = r}{\\sum} |\\underset{j\\in I}{\\bigcup A_j}|]$\n","2466c9c0":"**Stirlingzahlen**\n\n2. Art:\n\n$S(n, k) = \\begin{cases} 0 &\\text{ wenn } k > n \\text{ oder }n > 0 \\text{ und }k = 0 \\\\ 1 &\\text{ wenn } n = 0 \\text{ und } k = 0 \\\\ S(n-1, k-1) + k * S(n-1, k) &\\text{ sonst} \\end{cases}$\n\n1. Art:\n\n$s(n, k) = \\begin{cases} 0 &\\text{ wenn } k > n \\text{ oder }n > 0 \\text{ und }k = 0 \\\\ 1 &\\text{ wenn } n = 0 \\text{ und } k = 0 \\\\ s(n-1, k-1) + (n-1) * s(n-1, k) &\\text{ sonst} \\end{cases}$"}}