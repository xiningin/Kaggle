{"cell_type":{"9791c403":"code","405ee1a3":"code","b091a4f4":"code","278fb538":"code","623cbe72":"code","728c447f":"code","6393ede1":"code","2ea9c15a":"code","4faf0d21":"markdown"},"source":{"9791c403":"import matplotlib.pyplot as plt\nimport pickle\nimport numpy as np\nimport geoplot as gplt\nimport geopandas as gpd\nimport gc\nfrom shapely.geometry import Point\nimport pandas as pd\nimport zipfile\nfrom matplotlib.colors import LogNorm, TwoSlopeNorm, Normalize, SymLogNorm\nimport matplotlib.ticker as ticker\n\nepsg = 4289\nlasPath = '.\/USGS_LPC_LA_UpperDeltaPlain_2017_LAS_2018\/las\/tiled\/'\nextent = (-90.14003111,  29.86560481, -89.87, 30.08)","405ee1a3":"def nameReplace(name):\n    outName = name.title().replace(' ',\"\\n\").split('-')[0]\n    outName = outName.replace(\"St.\\n\",'St.') #Fix Saint abrevation problem\n    return outName\n\n#neighborhoodDf = gpd.read_file('zip:\/\/.\/NewOrleansShapeFiles\/Neighborhood_Statistical_Areas.zip!Neighborhood_Statistical_Areas.shp').to_crs(epsg=epsg)\nneighborhoodDf = gpd.read_file('..\/input\/geospatial-sets-for-new-orleans\/Neighborhood_Statistical_Areas\/Neighborhood_Statistical_Areas.shp').to_crs(epsg=epsg)\nneighborhoodDf['Name'] = neighborhoodDf['GNOCDC_LAB'].map(nameReplace)\n#waterDf = gpd.read_file('zip:\/\/.\/NewOrleansShapeFiles\/water.zip!WATER2.SHP')\nwaterDf = gpd.read_file('..\/input\/geospatial-sets-for-new-orleans\/water\/WATER2.SHP')\n#roadsDf = gpd.read_file('zip:\/\/.\/NewOrleansShapeFiles\/Road_Centerline.zip!Road_Centerline.shp')\nroadsDf = gpd.read_file('..\/input\/geospatial-sets-for-new-orleans\/Road_Centerline\/Road_Centerline.shp')\nroadsDf = roadsDf[roadsDf['geometry'].apply(lambda x: x != None)]\ninterstateDf = roadsDf[np.logical_or(roadsDf['FEDROUTE'] =='10', roadsDf['FEDROUTE'] =='610')].to_crs(epsg=epsg)","b091a4f4":"lasDf = gpd.GeoDataFrame(pd.read_pickle('..\/input\/processed-lidar-data-for-new-orleans\/processedData.pickle'))\nlasDf = lasDf[lasDf['intersectsCity']]\ngroundMask = lasDf['pointType']==2\nwaterMask = lasDf['pointType']==9\nlasDf['elevationFeet'] = 3.28084 * lasDf['elevation']\nnorm = Normalize(vmin=-10, vmax=10, clip=True)\nlasDf['elevationNorm'] = norm(lasDf['elevationFeet'], clip=True)\n\ngroundMask = np.logical_and( groundMask, ~np.isnan(lasDf['elevationNorm']) )","278fb538":"lasDf['aboveSea'] = 1 * (lasDf['elevation'] > 0)","623cbe72":"lasDf.head()","728c447f":"lasPointDf = gpd.GeoDataFrame(lasDf[['pointType','intersectsCity', 'elevationFeet','elevationNorm','aboveSea']], geometry=lasDf.representative_point() )\nlasPointDf.head()","6393ede1":"extent = (-90.14003111,  29.86560481, -89.87, 30.08)\n\n@ticker.FuncFormatter\ndef formatter(x, pos):\n    outLabel = int(norm.inverse(x))\n    \n    if outLabel == 10:\n        outLabel = '>= 10 feet'\n    elif outLabel == -10:\n        outLabel = '<= -10 feet'\n    else:\n        outLabel = str(outLabel) + ' feet'\n        \n    return outLabel\n\n\ndef graphMap(saveFig = False,\n             showLidar = True,\n             extent=extent,\n             annotate=True,\n             webMerc= False,\n             cmap='seismic_r',\n             figSize=(28,16),\n             showInterstates=False,\n             showNeighborHood=True,\n             showWater=True,\n             showPointLidar=True,\n             alpha=0.5):\n    \n    projection = gplt.Mercator() if not webMerc else gplt.WebMercator()\n    epsgCode = 3395 if not webMerc else 3857\n\n    title='Feet Above Sea Level'\n    \n    fig, ax = plt.subplots(figsize=figSize, subplot_kw={'projection': projection})\n\n    if webMerc:\n        gplt.webmap(neighborhoodDf, projection=projection,ax=ax, extent=extent, zorder=19)\n        \n    else:\n        gplt.polyplot(neighborhoodDf, edgecolor='black', facecolor='white', projection=projection, ax=ax, extent=extent, zorder=19)    \n        \n    \n    if showWater:\n        gplt.polyplot(waterDf,ax=ax, projection=projection, edgecolor='#abd3df', facecolor='#abd3df', extent=extent, zorder=22)\n    \n    if showNeighborHood:\n        gplt.polyplot(neighborhoodDf, edgecolor='black', facecolor=(1,0,0,0), projection=projection, ax=ax, extent=extent, zorder=24)\n    \n    if showInterstates:\n        gplt.sankey(interstateDf,ax=ax, projection=projection, extent=extent, linewidth=5, zorder=25, color='#606060')\n    \n    #currently this doesnt work\n    if annotate:\n        centers = neighborhoodDf.to_crs(epsgCode).centroid\n        for point, name in zip(centers, neighborhoodDf['Name']):\n            ax.annotate(name, xy=(point.x,point.y), xycoords='data', zorder=100,\\\n                        ha='center', va='center',fontsize=8, color='#000000',\\\n                        xytext=(-20, -20), textcoords=\"offset points\",\\\n                        bbox=dict(boxstyle='round',facecolor='#ffffce', alpha=0.4))\n            \n\n    if showLidar and not showPointLidar:\n        gplt.choropleth(lasDf[groundMask],hue='elevationNorm', legend=True, ax=ax, projection=projection, zorder=20, extent=extent, cmap=cmap, alpha=alpha)\n        gplt.polyplot(lasDf[waterMask],facecolor='#abd3df',edgecolor='#abd3df',ax=ax, projection=projection, zorder=21, extent=extent, alpha=alpha)\n        cbar = fig.get_axes()[-1]\n        cbar.yaxis.set_major_formatter(formatter)\n        cbar.set_title('Feet Above Sea Level')\n    \n    #much faster\n    if showPointLidar:\n        gplt.pointplot(lasPointDf[groundMask],hue='elevationNorm', legend=True, ax=ax, projection=projection, zorder=20, extent=extent, cmap=cmap, alpha=alpha, marker='s',s=3.75)\n\n    ax.set_facecolor('#ffffce')\n    ax.set_title(title)\n    fig.tight_layout()\n    \n    \n\n    if saveFig:\n        fig.savefig(saveFig)","2ea9c15a":"graphMap(saveFig = '.\/NewOrleansElevation1.png',\n             showPointLidar = True,\n             extent=extent,\n             annotate=True,\n             webMerc= True,\n             cmap='seismic_r',\n             figSize=(28,16),\n             showInterstates=True,\n             showNeighborHood=True,\n             showWater=True,\n             alpha=1\n             )","4faf0d21":"# Elevation Map Rough Draft\n\nThis is a rough draft of the elevation map.  Just proving the concepts really making sure everything is on the correct path"}}