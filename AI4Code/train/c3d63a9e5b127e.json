{"cell_type":{"715fa670":"code","2c2289b4":"code","c3ef892a":"code","4cf21f0d":"code","4e77344d":"code","fae4cfce":"code","43dffd3a":"code","e7c7277e":"code","94e296f3":"code","98a4ec69":"code","07c916b0":"code","b64ba080":"markdown","42cdd8e6":"markdown","5ae86042":"markdown","53a3f4b3":"markdown","485e07dd":"markdown","71c2c627":"markdown","4a8fdece":"markdown","e9b62d91":"markdown","300ee5d3":"markdown","60082155":"markdown","72da5020":"markdown","05a8a611":"markdown","207a0c19":"markdown"},"source":{"715fa670":"!pip install git+https:\/\/github.com\/matheusgmaia\/kaggle-environments","2c2289b4":"from kaggle_environments import evaluate, make, utils\nimport numpy as np\nimport random\nfrom prettytable import PrettyTable\n\n# Imports do algor\u00edtmo gen\u00e9tico\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom matplotlib import lines\n\nfrom ipywidgets import interact\nimport ipywidgets as widgets\n\nfrom collections import deque\nimport math\nimport heapq\n\nimport time\nimport bisect","c3ef892a":"class Log:\n    moves = []\n    \n    def add_move(pieces, fit_list):\n        move = [pieces, fit_list]\n        self.moves.append(move)\n\n    def show_log():\n        t = PrettyTable(['Column', 1, 2, 3, 4, 5, 6, 7])\n        for move in moves:\n            t.add_row(['Pieces'].append(move[0]))\n            t.add_row(['Fit list'].append(move[1]))\n        print(t)\n\ndef show_board(board):\n    for row in reversed(board):\n        print (row)","4cf21f0d":"def is_adversary_in_mid_spaces(mid_spaces, board, adversary):\n    print(\"-------------\")\n    print(list(mid_spaces))\n    for mid_space in mid_spaces:\n        print (mid_space)\n        if board[int(mid_space[0])][int(mid_space[1])] == adversary:\n            return True\n\ndef evaluation(state_space, board, fit=0):\n    ones, twos = state_space\n\n    for i in range(len(ones)):\n        for j in range(i+1, len(ones)):\n            distance = np.array(ones[i]) - np.array(ones[j])\n            if abs(distance[0]) == abs(distance[1]) and abs(distance[0]) < 4: # Diagonal\n                step_x = 1 if distance[0] > 0 else -1\n                step_y = 1 if distance[1] > 0 else -1\n                mid_spaces = map(lambda x: (ones[i][0]+x*step_x, ones[i][1]+x*step_y), range(1, abs(distance[0])))\n\n                adversary_in_mid_spaces = is_adversary_in_mid_spaces(mid_spaces, board, 2)\n\n                if not adversary_in_mid_spaces:\n                    fit += 2\n            if (distance[0] == 0 or distance[1] == 0) and (abs(distance[0] + distance[1]) < 4): # Horizontal e Vertical\n                if distance[0] == 0:\n                    x_array = np.zeros(abs(distance[1])-1)\n                    y_array = range(1, abs(distance[1]))\n                else:\n                    x_array = range(1, abs(distance[0]))\n                    y_array = np.zeros(abs(distance[0])-1)\n                mid_spaces = map(lambda x, y: (x+ones[i][0], y+ones[i][1]), x_array, y_array)\n\n                adversary_in_mid_spaces = is_adversary_in_mid_spaces(mid_spaces, board, 2)\n\n                fit += 2\n\n    return fit","4e77344d":"def disturb_oponent_evaluation(state_space, board, target, fit=0):\n    r, c = target\n    \n    # -- Horizontal --\n    if c < 6:\n        if board[r][c+1] == 2:\n            if c > 0:\n                if board[r][c-1] == 2:\n                    fit += 2\n                    if c < 5:\n                        if board[r][c+2] == 2:\n                            fit += 40\n                    if c > 1:\n                        if board[r][c-2] == 2:\n                            fit += 40\n                elif c > 4:\n                    pass\n                elif board[r][c+2] == 2:\n                    fit += 2\n                    if c < 4:\n                        if board[r][c+3] == 2:\n                            fit += 20\n            else: \n                if board[r][c+2] == 2:\n                    fit += 2\n                    if board[r][c+3] == 2:\n                        fit += 40\n\n    if c > 1:\n        if board[r][c-1] == 2 and board[r][c-2] == 2:\n            fit += 2\n            if c > 2:\n                if board[r][c-3] == 2:\n                    fit += 40\n    \n    # -- Vertical --\n    if r > 1:\n        if board[r-1][c] == 2 and board[r-2][c] == 2:\n            fit += 2\n            if r > 2:\n                if board[r-3][c] == 2:\n                    fit += 40\n    \n    # -- Diagonal --\n\n    # Diagonal secund\u00e1ria\n    if not (c > 5 or r > 4):\n        if board[r+1][c+1] == 2:\n            if not (c < 1 or r < 1):\n                if board[r-1][c-1] == 2:\n                    fit +=2\n                    if not (c > 4 or r > 3):\n                        if board[r+2][c+2] == 2:\n                            fit += 20\n                    if not (c < 2 or r < 2):\n                        if board[r-2][c-2] == 2:\n                            fit += 20\n                elif not (c < 5 and r < 4):\n                    pass\n                elif board[r+2][c+2] == 2:\n                    fit += 2\n                    if not (c > 3 or r > 2):\n                        if board[r+3][c+3] == 2:\n                            fit += 40\n            elif not (c > 3 or r > 2):\n                if board[r+2][c+2] == 2:\n                    fit += 2\n                    if board[r+3][c+3] == 2:\n                        fit += 40\n                 \n    if not (c < 2 or r < 2):\n        if board[r-1][c-1] == 2 and board[r-2][c-2] == 2:\n            fit += 2\n            if not (c < 3 or r < 3):\n                if board[r-3][c-3] == 2:\n                    fit += 40\n\n    # Diagonal prim\u00e1ria\n    if not (c > 5 or r < 1):\n        if board[r-1][c+1] == 2:\n            if not (c < 1 or r > 4):\n                if board[r+1][c-1] == 2:\n                    fit +=2\n                    if not (c < 2 or r > 3):\n                        if board[r+2][c-2] == 2:\n                            fit += 40\n                    if not (c > 4 or r < 2):\n                        if board[r-2][c+2] == 2:\n                            fit += 40\n                elif not (c < 5 and r > 1):\n                    pass\n                elif board[r-2][c+2] == 2:\n                    fit += 2\n                    if not (c > 3 or r < 3):\n                        if board[r-3][c+3] == 2:\n                            fit += 40\n            elif not (c > 3 or r < 3):\n                if board[r-2][c+2] == 2:\n                    fit += 2\n                    if board[r-3][c+3] == 2:\n                        fit += 40\n\n    if not (c > 4 or r < 2):\n        if board[r-1][c+1] == 2 and board[r-2][c+2] == 2:\n            fit += 2\n            if not (c > 3 or r < 3):\n                if board[r-3][c+3] == 2:\n                    fit += 40\n\n    return fit","fae4cfce":"weights = [2, 6, 100, 100]\n\ndef find_seven_row(step, board, target):\n    seven_row = [0, 0, 0, 0, 0, 0, 0]\n\n    begin = (target[0] - step[0]*3, target[1] - step[1]*3)\n\n    row_locations = map(lambda x: (begin[0]+step[0]*x, begin[1]+step[1]*x), range(7))\n\n    for row_location, i in zip(row_locations, range(7)):\n        if row_location[0] < 0 or row_location[1] < 0 or row_location[0] > 5 or row_location[1] > 6:\n            seven_row[i] = -1\n        else:\n            seven_row[i] = board[row_location[0]][row_location[1]]\n\n    return seven_row\n\ndef evaluate_seven_row(seven_row, player, non_valid=-1, fit=0): # Avalia\u00e7\u00e3o do seven row por meio de filtros de 4 espa\u00e7os\n    oponent = 2 if player == 1 else 1\n    w = weights[0:4]\n    \n    for i in range(4):\n        four_filter = seven_row[i:i+4]\n        #print(four_filter, four_filter.count(1))\n\n        if oponent in four_filter or non_valid in four_filter:\n            pass\n        elif four_filter.count(player) == 2:\n            fit += w[0]\n        elif four_filter.count(player) == 3:\n            fit += w[1]\n        elif four_filter.count(player) == 4:\n            fit += w[2]\n            if player == 1:\n                fit += w[3]\n\n    return fit\n\ndef alternate_evaluation(state_space, board, target, player=1, fit=0):\n    possibilities = [(1, 0), (0, 1), (1, 1), (-1, 1)]\n\n    for possibilitie in possibilities:\n        # Linhas de 7 com o target no centro\n        seven_row = find_seven_row(possibilitie, board, target)\n\n        fit += evaluate_seven_row(seven_row, player)\n    \n    return fit","43dffd3a":"# Functions to perception of the ambient\n\ndef fill_piece_lists(piece_list, piece, row, r):\n    temp = [i for i,x in enumerate(row) if x==piece]\n\n    for c in temp:\n        piece_list += [(r, c)]\n\ndef perception(board):\n    ones, twos = [], []\n\n    r = -1\n\n    for row in (board):\n        r += 1\n        if (1 in row) or (2 in row):\n            # Tem pe\u00e7as nessa linha e vamos registrar quais s\u00e3o elas\n\n            fill_piece_lists(ones, 1, row, r)\n            fill_piece_lists(twos, 2, row, r)\n\n    return (ones, twos)\n\n# Agent\n\ndef my_agent(observation, configuration):\n    columns, rows, inarow = configuration.columns, configuration.rows, configuration.inarow\n\n    first_play = 1 not in observation.board\n\n    board = [observation.board[:7]] + [observation.board[7:14]] + [observation.board[14:21]] + [observation.board[21:28]] + [observation.board[28:35]] + [observation.board[35:42]]\n    board = list(reversed(board))\n\n    state_space = perception(board)\n    fit = []\n\n    for c in range(columns):\n        # Encontra a linha livre para a coluna selecionada\n        r = 0\n        while board[r][c] != 0:\n            r += 1\n            if r == rows:\n                break\n\n        if (r < rows):\n            temp_fit = 0\n            # Colocando uma pe\u00e7a no tabuleiro na coluna c\n            state_space[0].append((r, c))\n            board[r][c] = 1\n\n            # Avaliar o quanto a jogada leva a vit\u00f3ria\n            #temp_fit += evaluation(state_space, board)\n\n            temp_fit += alternate_evaluation(state_space, board, (r, c))\n            \n            # Evitar que a jogada beneficie o oponente na pr\u00f3xima rodada checando se ele ganha por causa dela\n            if r + 1 < 6: \n                board[r+1][c] = 2 \n                temp_fit -= alternate_evaluation(state_space, board, (r+1, c), 2)\n                board[r+1][c] = 0\n\n            # Tirando pe\u00e7a\n            state_space[0].pop()\n            board[r][c] = 0\n\n            # Avaliar como a jogada afeta o oponente\n            temp_fit += disturb_oponent_evaluation(state_space, board, (r, c))\n\n            # Colocando pe\u00e7a oponente\n            board[r][c] = 2\n            temp_fit += alternate_evaluation(state_space, board, (r, c), 2)\n\n            # Tirando pe\u00e7a\n            board[r][c] = 0\n\n            fit.append(temp_fit)\n        else:\n            fit.append(-100)\n\n    decision = fit.index(max(fit))\n\n    if first_play:\n        #decision = random.choice([2, 3, 4])\n        decision = 2\n        first_play = False\n\n    #print (\"---- Fit list ----\")\n    #print (observation.board)\n    #print (fit)\n    #print (decision)\n\n    return decision","e7c7277e":"class ObservationTest:\n    def __init__(self):\n        self.board = [0, 0, 0, 0, 0, 0, 0,\n                      0, 0, 0, 0, 0, 0, 0,\n                      0, 0, 2, 0, 0, 0, 1,\n                      0, 0, 1, 0, 0, 0, 2,\n                      0, 1, 1, 1, 2, 2, 2,\n                      0, 1, 1, 2, 1, 2, 2]\n\nclass ConfigurationTest:\n    def __init__(self):\n        self.columns = 7\n        self.rows = 6\n        self.inarow = 4\n\nobs, config = ObservationTest(), ConfigurationTest()\nresult = my_agent(obs, config)\n\nprint (\"\\nResult: \" + str(result))","94e296f3":"env.reset()\n# Play as the first agent against default \"random\" agent.\nenv.run([my_agent, \"negamax\"])\nenv.render(mode=\"ipython\", width=500, height=450)","98a4ec69":"def mean_win_draw(rewards):\n    return sum( 1 for r in rewards if (r[0] == 1 or r[0] == 0.)) \/ len(rewards)\n\n# Run multiple episodes to estimate its performance.\nvs_random = mean_win_draw(evaluate(\"connectx\", [my_agent, \"random\"], num_episodes=10))\nprint(\"My Agent vs Random Agent:\", vs_random)\n\nvs_negamax = mean_win_draw(evaluate(\"connectx\", [my_agent, \"negamax\"], num_episodes=10))\nprint(\"My Agent vs Negamax Agent:\", vs_negamax)\n\nvs_rules = mean_win_draw(evaluate(\"connectx\", [my_agent, \"rules\"], num_episodes=10))\nprint(\"My Agent vs Rule Agent:\", vs_rules)\n\nvs_greedy = mean_win_draw(evaluate(\"connectx\", [my_agent, \"greedy\"], num_episodes=10))\nprint(\"My Agent vs Greedy Agent:\", vs_greedy)","07c916b0":"import csv\n\nseu_nome = \"LUCAS_FERNANDO\"\n\nrows = [['Id', 'Predicted'],['random',vs_random],[ 'negamax', vs_negamax],[ 'rules', vs_rules],[ 'greedy', vs_greedy]]\nf = open(seu_nome+'-ConnectX.csv', 'w')\nwith f:\n    writer = csv.writer(f)\n    for row in rows:\n        writer.writerow(row)","b64ba080":"First heuristic (Without success).","42cdd8e6":"# Create ConnectX Environment","5ae86042":"#### Final heuristic that is used to evaluate both self agent and oponent.\n\nThe heusristic consists in take the seven spaces around the target (play piece) in every diretion generating 4 arrays like in the image below: \n\n![](https:\/\/raw.githubusercontent.com\/luccosta\/ConnectX-VirtusUP\/master\/strategy.png)\n\nAnd evaluate each array traversing every 4 spaces:\n\n![](https:\/\/raw.githubusercontent.com\/luccosta\/ConnectX-VirtusUP\/master\/four-filter.png)\n\nWhen traversing the array, 5 situations are perceived:\n\n* In the four spaces is there one opponent piece: Makes impossible any try of an 4 connection, so it not rewards the piece placement\n* In the four spaces is just one piece: The piece is the one that is been placed, so this situation is also not rewarded\n* In the four spaces are there two pieces: Brings some value to the piece placement, but not help so much to win the game\n* In the four spaces are there three pieces: Indicates that the piece placement help the agent to win the game\n* In the four spaces are there four pieces: The piece placement win the game\n\n","53a3f4b3":"Heuristic to evaluate the influence of the play in the oponent (Without success).","485e07dd":"Functions to help the development","71c2c627":"# Install kaggle-environments","4a8fdece":"# Evaluate your Agent","e9b62d91":"# Test your Agent","300ee5d3":"#### Genetic algorithm\n\nThe weights used in the final heuristic can be obtained in the genetic algorithm optimization.\n\nWas not possible to run in Colab, to run locally: [Genetic algorithm python file](https:\/\/github.com\/luccosta\/ConnectX-VirtusUP\/blob\/master\/connectx_virtusup_genetic_algorithm.py)","60082155":"# Write Submission File\n\n","72da5020":"# Create an Agent\n\n","05a8a611":"#### The agent","207a0c19":"# Test your Algorithm"}}