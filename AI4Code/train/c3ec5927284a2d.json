{"cell_type":{"24e31461":"code","5eb56678":"code","73538cf9":"code","d04fe9a8":"code","f308dc13":"code","012ab81d":"code","607d71cf":"code","e8edd7b0":"code","0f6a283c":"code","1674be01":"code","09ab634a":"code","2edd322e":"code","2969a68f":"code","1b0522fb":"markdown","5194ea17":"markdown","1bdc62c5":"markdown","f9a5b6a7":"markdown","27b75719":"markdown","5d6e43c3":"markdown","1c59ef3e":"markdown","cbc14fb5":"markdown","0c6ce455":"markdown","11eb725e":"markdown","ffbeff1f":"markdown","608777d9":"markdown","5f1aa25b":"markdown"},"source":{"24e31461":"from kaggle_environments import make, evaluate\nimport numpy as np\nimport random","5eb56678":"class Connect_four:\n    def __init__(self):\n        super(Connect_four, self).__init__()\n        self.env = make(\"connectx\", debug=True)\n        self.n_rounds = 100\n        self.config = {'rows': 6, 'columns': 7, 'inarow': 4}\n\n    def run(self, agent1, agent2):\n        self.env.run([agent1, agent2])\n        self.env.render(mode='ipython')\n\n    def get_win_percentages(self, agent1, agent2):\n        # Agent 1 goes first (roughly) half the time\n        outcomes = evaluate(\"connectx\", [agent1, agent2], self.config, [], self.n_rounds \/\/ 2)\n        # Agent 2 goes first (roughly) half the time\n        outcomes += [[b, a] for [a, b] in\n                     evaluate(\"connectx\", [agent2, agent1], self.config, [], self.n_rounds - self.n_rounds \/\/ 2)]\n        print(\"Agent 1 Win Percentage:\", np.round(outcomes.count([1, -1]) \/ len(outcomes), 2))\n        print(\"Agent 2 Win Percentage:\", np.round(outcomes.count([-1, 1]) \/ len(outcomes), 2))\n        print(\"Number of Invalid Plays by Agent 1:\", outcomes.count([None, 0]))\n        print(\"Number of Invalid Plays by Agent 2:\", outcomes.count([0, None]))\n","73538cf9":"def drop_piece(grid, col, piece, config):\n    next_grid = grid.copy()\n    for row in range(config.rows - 1, -1, -1):\n        if next_grid[row][col] == 0:\n            break\n    next_grid[row][col] = piece\n    return next_grid\n\n\n# Returns True if dropping piece in column results in game win\ndef check_winning_move(obs, config, col, piece):\n    \"\"\"\n    The check_winning_move() function takes four required arguments: the first two (obs and config) should be familiar, and:\n\n    col:col is any valid move\n    piece:piece is either the agent's mark or the mark of its opponent.\n\n    The function returns True if dropping the piece in the provided column wins the game\n    (for either the agent or its opponent), and otherwise returns False.\n\n    To check if the agent can win in the next move,you should set piece=obs.mark.\n    To check if the opponent can win in its next move, use the same check_winning_move() function, and set piece=obs.mark%2+1.\n    \"\"\"\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    next_grid = drop_piece(grid, col, piece, config)\n    # horizontal\n    for row in range(config.rows):\n        for col in range(config.columns - (config.inarow - 1)):\n            window = list(next_grid[row, col:col + config.inarow])\n            if window.count(piece) == config.inarow:\n                return True\n    # vertical\n    for row in range(config.rows - (config.inarow - 1)):\n        for col in range(config.columns):\n            window = list(next_grid[row:row + config.inarow, col])\n            if window.count(piece) == config.inarow:\n                return True\n    # positive diagonal(\u6b63\u5bf9\u89d2\u7ebf)\n    for row in range(config.rows - (config.inarow - 1)):\n        for col in range(config.columns - (config.inarow - 1)):\n            window = list(next_grid[range(row, row + config.inarow), range(col, col + config.inarow)])\n            if window.count(piece) == config.inarow:\n                return True\n    # negative diagonal(\u8d1f\u5bf9\u89d2\u7ebf)\n    for row in range(config.inarow - 1, config.rows):\n        for col in range(config.columns - (config.inarow - 1)):\n            window = list(next_grid[range(row, row - config.inarow, -1), range(col, col + config.inarow)])\n            if window.count(piece) == config.inarow:\n                return True\n    return False\n","d04fe9a8":"# Helper function for get_heuristic: checks if window satisfies heuristic conditions\ndef check_window(window, num_discs, piece, config):\n    return window.count(piece) == num_discs and window.count(0) == config.inarow - num_discs\n\n\n# Helper function for get_heuristic: counts number of windows satisfying specified heuristic conditions\ndef count_windows(grid, num_discs, piece, config):\n    num_windows = 0\n    # horizontal\n    for row in range(config.rows):\n        for col in range(config.columns - (config.inarow - 1)):\n            window = list(grid[row, col:col + config.inarow])\n            if check_window(window, num_discs, piece, config):\n                num_windows += 1\n    # vertical\n    for row in range(config.rows - (config.inarow - 1)):\n        for col in range(config.columns):\n            window = list(grid[row:row + config.inarow, col])\n            if check_window(window, num_discs, piece, config):\n                num_windows += 1\n    # positive diagonal\n    for row in range(config.rows - (config.inarow - 1)):\n        for col in range(config.columns - (config.inarow - 1)):\n            window = list(grid[range(row, row + config.inarow), range(col, col + config.inarow)])\n            if check_window(window, num_discs, piece, config):\n                num_windows += 1\n    # negative diagonal\n    for row in range(config.inarow - 1, config.rows):\n        for col in range(config.columns - (config.inarow - 1)):\n            window = list(grid[range(row, row - config.inarow, -1), range(col, col + config.inarow)])\n            if check_window(window, num_discs, piece, config):\n                num_windows += 1\n    return num_windows","f308dc13":"# Helper function for score_move: calculates value of heuristic for grid\ndef get_heuristic(grid, mark, config):\n    num_threes = count_windows(grid, 3, mark, config)\n    num_fours = count_windows(grid, 4, mark, config)\n    num_threes_opp = count_windows(grid, 3, mark % 2 + 1, config)\n    score = num_threes - 1e2 * num_threes_opp + 1e6 * num_fours\n    return score\n\n# original heuristic function\ndef get_heuristic_plus(grid, mark, config, w_list=None):\n    if w_list is None:\n        w_list = [150000, 25, 5, -4, -100, -100000]\n    num_twos = count_windows(grid, 2, mark, config)\n    num_threes = count_windows(grid, 3, mark, config)\n    num_fours = count_windows(grid, 4, mark, config)\n    num_twos_opp = count_windows(grid, 2, mark % 2 + 1, config)\n    num_threes_opp = count_windows(grid, 3, mark % 2 + 1, config)\n    num_fours_opp = count_windows(grid, 4, mark % 2 + 1, config)\n    score = w_list[0] * num_fours + w_list[1] * num_threes + w_list[2] * num_twos + w_list[3] * num_twos_opp + w_list[\n        4] * num_threes_opp + w_list[5] * num_fours_opp\n    return score\n\n\ndef get_heuristic_test(grid, mark, config, w_list=None):\n    if w_list is None:\n        w_list = [1500000, 150, 1, -2, -135, -100000]\n    num_twos = count_windows(grid, 2, mark, config)\n    num_threes = count_windows(grid, 3, mark, config)\n    num_fours = count_windows(grid, 4, mark, config)\n    num_twos_opp = count_windows(grid, 2, mark % 2 + 1, config)\n    num_threes_opp = count_windows(grid, 3, mark % 2 + 1, config)\n    num_fours_opp = count_windows(grid, 4, mark % 2 + 1, config)\n    score = w_list[0] * num_fours + w_list[1] * num_threes + w_list[2] * num_twos + w_list[3] * num_twos_opp + w_list[\n        4] * num_threes_opp + w_list[5] * num_fours_opp\n    return score","012ab81d":"# Calculates score if agent drops piece in selected column\ndef score_move(grid, col, mark, config):\n    next_grid = drop_piece(grid, col, mark, config)\n    score = get_heuristic_plus(next_grid, mark, config)\n    return score\n\n\ndef score_move_ns(grid, col, mark, config, nsteps):\n    next_grid = drop_piece(grid, col, mark, config)\n    score = minimax(next_grid, nsteps - 1, False, mark, config)\n    return score\n\n\ndef score_move_ns_test(grid, col, mark, config, nsteps):\n    next_grid = drop_piece(grid, col, mark, config)\n    score = minimax_test(next_grid, nsteps - 1, False, mark, config)\n    return score\n","607d71cf":"# Helper function for minimax: checks if agent or opponent has four in a row in the window\ndef is_terminal_window(window, config):\n    return window.count(1) == config.inarow or window.count(2) == config.inarow\n\n\n# Helper function for minimax: checks if game has ended\ndef is_terminal_node(grid, config):\n    # Check for draw\n    if list(grid[0, :]).count(0) == 0:\n        return True\n    # Check for win: horizontal, vertical, or diagonal\n    # horizontal\n    for row in range(config.rows):\n        for col in range(config.columns - (config.inarow - 1)):\n            window = list(grid[row, col:col + config.inarow])\n            if is_terminal_window(window, config):\n                return True\n    # vertical\n    for row in range(config.rows - (config.inarow - 1)):\n        for col in range(config.columns):\n            window = list(grid[row:row + config.inarow, col])\n            if is_terminal_window(window, config):\n                return True\n    # positive diagonal\n    for row in range(config.rows - (config.inarow - 1)):\n        for col in range(config.columns - (config.inarow - 1)):\n            window = list(grid[range(row, row + config.inarow), range(col, col + config.inarow)])\n            if is_terminal_window(window, config):\n                return True\n    # negative diagonal\n    for row in range(config.inarow - 1, config.rows):\n        for col in range(config.columns - (config.inarow - 1)):\n            window = list(grid[range(row, row - config.inarow, -1), range(col, col + config.inarow)])\n            if is_terminal_window(window, config):\n                return True\n    return False","e8edd7b0":"# Minimax implementation\ndef minimax(node, depth, maximizingPlayer, mark, config):\n    is_terminal = is_terminal_node(node, config)\n    valid_moves = [c for c in range(config.columns) if node[0][c] == 0]\n    if depth == 0 or is_terminal:\n        return get_heuristic_plus(node, mark, config)\n    if maximizingPlayer:\n        value = -np.Inf\n        for col in valid_moves:\n            child = drop_piece(node, col, mark, config)\n            value = max(value, minimax(child, depth - 1, False, mark, config))\n        return value\n    else:\n        value = np.Inf\n        for col in valid_moves:\n            child = drop_piece(node, col, mark % 2 + 1, config)\n            value = min(value, minimax(child, depth - 1, True, mark, config))\n        return value\n\n\ndef minimax_test(node, depth, maximizingPlayer, mark, config):\n    is_terminal = is_terminal_node(node, config)\n    valid_moves = [c for c in range(config.columns) if node[0][c] == 0]\n    if depth == 0 or is_terminal:\n        return get_heuristic_test(node, mark, config)\n    if maximizingPlayer:\n        value = -np.Inf\n        for col in valid_moves:\n            child = drop_piece(node, col, mark, config)\n            value = max(value, minimax(child, depth - 1, False, mark, config))\n        return value\n    else:\n        value = np.Inf\n        for col in valid_moves:\n            child = drop_piece(node, col, mark % 2 + 1, config)\n            value = min(value, minimax(child, depth - 1, True, mark, config))\n        return value\n","0f6a283c":"def agent_random(obs, config):\n    valid_moves = [col for col in range(config.columns) if obs.board[col] == 0]\n    return random.choice(valid_moves)\n\n\n# Selects middle column\ndef agent_middle(obs, config):\n    return config.columns \/\/ 2\n\n\n# Selects leftmost valid column\ndef agent_leftmost(obs, config):\n    valid_moves = [col for col in range(config.columns) if obs.board[col] == 0]\n    return valid_moves[0]\n\n\ndef smarter_agent(obs, config):  # \u80fd\u591f\u4ece\u6210\u529f\u7ecf\u9a8c\u4e2d\u5b66\u4e60\n    valid_moves = [col for col in range(config.columns) if obs.board[col] == 0]\n    for col in valid_moves:\n        if check_winning_move(obs, config, col, obs.mark):\n            return col  # \u9009\u62e9\u5bfc\u81f4\u83b7\u80dc\u7684col\n    return random.choice(valid_moves)\n\n\n# \u4e00\u4e2a\u80fd\u591f\u963b\u6b62\u5bf9\u624b\u6210\u529f\u7684agent\n# Start with the code from the agent you created above. To check if the opponent can win in its next\n# move, use the same check_winning_move() function, and set piece=obs.mark%2+1.\ndef smarter_agent_plus(obs, config):\n    valid_moves = [col for col in range(config.columns) if obs.board[col] == 0]\n    for col in valid_moves:\n        if check_winning_move(obs, config, col, obs.mark):\n            return col  # \u5148\u9009\u62e9\u5bfc\u81f4\u83b7\u80dc\u7684col\n    for col in valid_moves:\n        if check_winning_move(obs, config, col, obs.mark % 2 + 1):\n            return col  # \u7136\u540e\u4ece\u4e2d\u9009\u62e9\u80fd\u591f\u963b\u6b62\u5bf9\u624b\u80dc\u5229\u7684col\n    return random.choice(valid_moves)\n","1674be01":"def standard_agent(obs, config):\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next turn\n    scores = dict(zip(valid_moves, [score_move(grid, col, obs.mark, config) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)\n\n\ndef standard_agent_plus(obs, config):  # \u4f7f\u7528\u542f\u53d1\u5f0f\u540c\u65f6\u963b\u6b62\u5bf9\u624b\u884c\u52a8\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    for col in valid_moves:\n        if check_winning_move(obs, config, col, obs.mark):\n            return col  # \u5148\u9009\u62e9\u5bfc\u81f4\u83b7\u80dc\u7684col\n    for col in valid_moves:\n        if check_winning_move(obs, config, col, obs.mark % 2 + 1):\n            return col  # \u7136\u540e\u4ece\u4e2d\u9009\u62e9\u80fd\u591f\u963b\u6b62\u5bf9\u624b\u80dc\u5229\u7684col\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next turn\n    scores = dict(zip(valid_moves, [score_move(grid, col, obs.mark, config) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)\n","09ab634a":"def nstep_agent3_bl(obs, config):\n    N_STEPS = 3\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    for col in valid_moves:\n        if check_winning_move(obs, config, col, obs.mark):\n            return col  # \u5148\u9009\u62e9\u5bfc\u81f4\u83b7\u80dc\u7684col\n    for col in valid_moves:\n        if check_winning_move(obs, config, col, obs.mark % 2 + 1):\n            return col  # \u7136\u540e\u4ece\u4e2d\u9009\u62e9\u80fd\u591f\u963b\u6b62\u5bf9\u624b\u80dc\u5229\u7684col\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next step\n    scores = dict(zip(valid_moves, [score_move_ns(grid, col, obs.mark, config, N_STEPS) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)\n\n\n# \u53ea\u5b58\u5728\u4e8e\u7406\u8bba\u4e2d\u7684agent\ndef nstep_agent4(obs, config):\n    N_STEPS = 4\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next step\n    scores = dict(zip(valid_moves, [score_move_ns(grid, col, obs.mark, config, N_STEPS) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)\n\n\ndef nstep_agent3_standard(obs, config):\n    N_STEPS = 3\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next step\n    scores = dict(zip(valid_moves, [score_move_ns(grid, col, obs.mark, config, N_STEPS) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)\n\n\ndef nstep_agent3_test(obs, config):\n    N_STEPS = 3\n    valid_moves = [c for c in range(config.columns) if obs.board[c] == 0]\n    # Convert the board to a 2D grid\n    grid = np.asarray(obs.board).reshape(config.rows, config.columns)\n    # Use the heuristic to assign a score to each possible board in the next step\n    scores = dict(zip(valid_moves, [score_move_ns_test(grid, col, obs.mark, config, N_STEPS) for col in valid_moves]))\n    # Get a list of columns (moves) that maximize the heuristic\n    max_cols = [key for key in scores.keys() if scores[key] == max(scores.values())]\n    # Select at random from the maximizing columns\n    return random.choice(max_cols)\n","2edd322e":"game=Connect_four()\nagent1=nstep_agent3_test\nagent2=nstep_agent3_standard\ngame.run(agent1=agent1,agent2=agent2)","2969a68f":"#game.n_rounds=50\n#game.get_win_percentages(agent1=agent1,agent2=agent2)","1b0522fb":"**Although we have game AI now, we don't have agent with reinforcement technique applied so far. That's because when I take lesson 4, I find out that the algorithm 'stable_baselines' has no moudule named 'utils' as the course mentions. Thus I need time to learn other algorithms and design agents in my own way. It's very pity, but I will try to add this part some day. Thank you for reading my notebook!**","5194ea17":"**3 heuristic functions. The first one is the original function in the lesson, the second one is function with improved parameters which you may use in the exercise, the last one is a function to for testing parameters. (you may use it if you want to improve your agents)**","1bdc62c5":"**After preparing all the functions, we can design our agents now. Here are 5 simple agents in lesson 1. The last two agents show some kinds of intelligence while selecting moves.(They 'know' to choose a winning move and block the opponent, although this kind of intelligence is based on mathematic calculation)**","f9a5b6a7":"**The next part is some functions. In this cell there are functions you will use to write 'smarter agents' in the exercise of lesson 1.**","27b75719":"**This notebook is about codes in kaggle course Intro to Game AI and Reinforcement Learning.   \nFirst of all, let's import python libraries we need.**","5d6e43c3":"**The class Connect_four consists of 3 parameters and 2 functions. You can write:\ngame= Connect_four\ngame.run(agent1,agent2)\ngame.get_win_percentages(agent1,agent2)\nto build a environment and run your agents.**","1c59ef3e":"**We use score to evaluate each possible move our agent might choose. Our agents will always choose moves with a highest score and assume the opponent will counteract this by choosing moves to force the score to be as low as possible.**","cbc14fb5":"**We want our agents to perform better by looking further. Here are agents for this purpose( Only able to look 3 steps ahead ). We can modify N_STEPS to design n steps look ahead agents, but one thing to know is : Your computation will grow exponentially while N is growing.**","0c6ce455":"**Also, we want to see the performance of the two agents in multiple games. Let's suppose the game number is 50. We can use get_win_percentages to show the win percentage of the two agents. Of course, it really takes some time to show the result.**","11eb725e":"**Finally, set up environment and play the game!**","ffbeff1f":"**Then, we have agents that can look one step forward(I call them standard_agent). We use heuristic instead of check_winning_move to guide our agents.**","608777d9":"**This cell contains helper functions for heuristic.**","5f1aa25b":"**We use minimax\uff08a zero sum algorithm\uff09 to guide our agent. In order to use this algorithm, we need to prepare the following helper functions.**"}}