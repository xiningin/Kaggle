{"cell_type":{"67ec5586":"code","9ba7070a":"code","a5ebec32":"code","c3732c69":"code","5bb78306":"code","96cf9a01":"code","16b61537":"code","36669110":"code","f3e58748":"code","c3182790":"code","f1fa0652":"code","a4ee7c44":"code","41e0d9cb":"code","3ff3700d":"code","3a3b535f":"code","c6d60233":"code","12918e7a":"code","d3b50586":"code","b18f4987":"code","ffa6408b":"code","693beacf":"markdown","3185e1d0":"markdown","94602454":"markdown","8dbab03b":"markdown","b7c52950":"markdown","a693209c":"markdown","9375974a":"markdown","c4708ee9":"markdown","b48db6be":"markdown","ad411466":"markdown","ed0d1fbe":"markdown","3123eb00":"markdown","3efa86ec":"markdown","8bf3856c":"markdown","1de8bd2a":"markdown","9f12b4c3":"markdown","f894ba7b":"markdown","7648db96":"markdown","804575d1":"markdown"},"source":{"67ec5586":"import pandas as pd \nimport numpy as np \nimport requests \nimport json\nimport matplotlib.pyplot as plt\nfrom kaggle_secrets import UserSecretsClient\nuser_secrets = UserSecretsClient()\nsecret_value_0 = user_secrets.get_secret(\"myapikey\")\n\nresponses = [] \nmovie_ids = ['tt0096874','tt0482571','tt0497465','tt0325980','tt0383574','tt0449088','tt0407887',\n'tt0431308','tt2872732','tt0120855','tt0892769','tt4633694',\n'tt1646971','tt0097165','tt0362227','tt1979320','tt2322441',\n'tt1411238','tt1727824','tt6105098','tt0808151','tt0172495',\n'tt0974661','tt0443706','tt1403981','tt3890160','tt0092890',\n'tt3521164','tt0332379','tt3606756','tt7286456','tt1059955',\n'tt1424432','tt9243946','tt7455754','tt0114369','tt4729430','tt1950186','tt7139936']\n\n\nfor movie in movie_ids:\n   rr = requests.get(secret_value_0.format(movie))\n   data=json.loads(rr.text)\n   responses.append(data)","9ba7070a":"movies_df = pd.DataFrame(responses)\nmovies_df","a5ebec32":"movies_df.dtypes","c3732c69":"#Dropping unnecessary columns \nmovies_df = movies_df.drop(columns = ['Year','Website', 'Response', 'Ratings', 'Type' ])\n\n#Removing 'min' from 'Runtime' column and '$' from 'BoxOffice' in order to convert them into integers and floats respectively.\nmovies_df['Runtime'] = movies_df['Runtime'].str.replace('min','')\nmovies_df['BoxOffice'] = movies_df['BoxOffice'].str.replace('$','')\n\n#Removing ',' from 'BoxOffice' and 'imdbVotes' in order to be able to convert them into numeric values.\nmovies_df['BoxOffice'] = movies_df['BoxOffice'].str.replace(',','')\nmovies_df['imdbVotes'] = movies_df['imdbVotes'].str.replace(',','')\nmovies_df = movies_df.replace('N\/A', np.nan)\n\n#Renaming the two columns to make the values interpretable. \nmovies_df.rename(columns={'Runtime': 'Runtime (min)', 'BoxOffice': 'BoxOffice($)'}, inplace=True)\n\n#Converting the columns that contain numeric values to integers or floats. First we have to fill all the NaN values \n#with 0 because the 'pd.to_numeric' function will convert columns with NaN values to floats. \n\nmovies_df[['imdbRating', 'imdbVotes', 'BoxOffice($)', 'Runtime (min)', 'Metascore']] = movies_df[['imdbRating', \n                                                                                                  'imdbVotes', \n                                                                                                  'BoxOffice($)', \n                                                                                                  'Runtime (min)', \n                                                                                                  'Metascore']].fillna(0).apply(pd.to_numeric)\n\nmovies_df['Released'] = pd.to_datetime(movies_df['Released'])\nmovies_df['DVD'] = pd.to_datetime(movies_df['DVD'])\nmovies_df['Rated'] = movies_df['Rated'].astype('category')","5bb78306":"movies_df.dtypes","96cf9a01":"#Turning strings into lists. \nmovies_df['Genres_new'] = movies_df['Genre'].str.split(', ')   ","16b61537":"#Counting the number of times each genre appears in the list \ngenres_count = pd.Series(sum([item for item in movies_df.Genres_new], [])).value_counts()","36669110":"genres_count.plot(kind='barh', figsize = (10,10), xticks = range(0 ,21, 2))\nplt.xlabel('Count')\nplt.ylabel('Genres')\nplt.title('Most preferred genres')\nplt.gca().invert_yaxis()\nplt.show()","f3e58748":"movies_df['Actors_new'] = movies_df['Actors'].str.split(', ')   ","c3182790":"actors_count = pd.Series(sum([item for item in movies_df.Actors_new], [])).value_counts()","f1fa0652":"actors_count[0:20].plot(kind='barh', figsize=(10,10), xticks= range(0,4,1))\nplt.xlabel('Count')\nplt.ylabel('Genres')\nplt.title('Actors we watched the most')\nplt.gca().invert_yaxis()\nplt.show()","a4ee7c44":"movies_df['Runtime (min)'].mean()","41e0d9cb":"movies_df['imdbRating'].mean()","3ff3700d":"movies_df[movies_df['imdbRating'] == movies_df['imdbRating'].max()]","3a3b535f":"movies_df[movies_df['imdbRating'] == movies_df['imdbRating'].min()]","c6d60233":"plt.scatter('Runtime (min)', 'imdbRating', data=movies_df)\nplt.xlabel('Runtime (min)')\nplt.ylabel('IMDB Rating')\nplt.show()","12918e7a":"plt.scatter('Metascore', 'imdbRating', data=movies_df)\nplt.xlabel('Metascore')\nplt.ylabel('IMDB Rating')\nplt.show()","d3b50586":"plt.scatter('imdbVotes', 'imdbRating', data=movies_df)\nplt.xlabel('Number of votes on IMDB')\nplt.ylabel('IMDB Rating')\nplt.show()","b18f4987":"plt.scatter('Released', 'imdbRating', data=movies_df)\nplt.xlabel('Year of release')\nplt.ylabel('IMDB Rating')\nplt.show()","ffa6408b":"movies_df['Production'].value_counts()","693beacf":"Just out of curiosity, I wanted to see if there is a relationship between ratings and runtime. Of course, we need a larger dataset to notice if there is some sort of a pattern. ","3185e1d0":"# Cleaning # ","94602454":"The first couple of places are taken by the main actors in Pirates of the Caribbean because we watched the first three movies. I didn't expect to see Gerard Butler in there but he is a voice actor in How To Train Your Dragon and plays in P.S. I Love You. ","8dbab03b":"The highest rated movie from our list according to IMDB votes is Se7en with an average of 8.6 and the least liked is Fifty Shades of Grey with an average of 4.1. (If you haven't seen the latter - just don't.)","b7c52950":"# Exploring #\n\nAs you can see from the column 'Genre', movies could have mutiple genres associated with them. I want to understand which is our favorite genre. First I have to create a new column 'Genres_new' which stores a list of genres for each movie. Then I have to count how many times each genre appears in the dataframe. ","a693209c":"# Introduction and obtaining the data# \n\nThis project is based on a list of movies my girlfriend and I watched in 2019. The exploratory analysis is simple but this is my very first project. I wanted to share it here on Kaggle because I feel like it is a promising starting point for more complicated analyses.","9375974a":"The columns have the appropriate formats now. We can continue with the exploratory analysis. You can find this version of the dataset on my Kaggle profile. ","c4708ee9":"Seems like all the columns in this dataset are strings and I don't really need all of them. I will now clean the data to prepare it for analysis. ","b48db6be":"10 of the movies are produced by Disney (Buena Vista is part of Disney). 3 of them are made by 20th Century Fox which is now owned by Disney.  ","ad411466":"From all the movies we have watched 20 were classified as dramas. Interestingly, my girlfriend says \"she hates comedies\", however 12 movies were comedies according to the dataset. All 3 movies which have the 'Sport' tag are about motorsport - Rush, Senna and Le Mans '66 (Ford v Ferrari). ","ed0d1fbe":"# Final words # \n\nThank you for reading through my first project here on Kaggle! In the future, I would definitely apply some of the ideas from this analysis to a larger dataset of movies. I would try to do more complex tasks and improve my skills with each upload. ","3123eb00":"I also want to understand which are our favourite actors. I will use the same method as with the Genres.","3efa86ec":"It seems that IMDB Rating increases with the number of votes but this could just mean that good movies are more likely to become popular. ","8bf3856c":"Obviously, the relationship between IMDB Rating and Metascore seems linear and positive - if IMDB Rating is high, Metascore is also high. ","1de8bd2a":"The average length of the movies we have watched in 2019 is a little less than 2 hours. ","9f12b4c3":"Let's load the data into a DataFrame and take a look at it:","f894ba7b":"I took the IMDB movie IDs from the URLs for each movie. Then I used OMDb API to get data for the titles. I was stuck on this part because it is not possible to make requests from OMDb with multiple IDs. I found the following solution to iterate over all the IDs' with a for loop. \n\nI had to hide my API key with the Secrets function from Kaggle. The skeleton that hides behind the 'secret_value_0' variable is 'http:\/\/www.omdbapi.com\/?apikey=yourapikey&i={}'. You can get a key from [here](hhttp:\/\/www.omdbapi.com\/).","7648db96":"There seems to be no relationhip between year of release and IMDB Rating. However, this could  also be a good question to ask about a larger dataset of movies. ","804575d1":"The average IMDB rating is 7.5."}}