{"cell_type":{"258794ce":"code","f36e31f8":"code","f03a0ff8":"code","90ad7ad8":"code","1c1b398f":"code","77614296":"markdown","af1e7515":"markdown","3954470d":"markdown","1be76e3c":"markdown","f3156548":"markdown"},"source":{"258794ce":"import numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('bmh')\n\nclass ChargedParticle:\n    def __init__(self, pos, charge):\n        self.pos = np.asarray(pos)\n        self.charge = charge\n        \n    def compute_field(self, x, y):\n        X, Y = np.meshgrid(x, y)\n        u_i = np.hstack((X.ravel()[:, np.newaxis],  Y.ravel()[:, np.newaxis])) - self.pos\n        r = np.sqrt((X - self.pos[0])**2 + (Y - self.pos[1])**2)\n        field = ((self.charge \/ r**2).ravel()[:, np.newaxis] * u_i).reshape(X.shape + (2,))\n        return field\n    \n    def compute_potential(self, x, y):\n        X, Y = np.meshgrid(x, y)\n        r = np.sqrt((X - self.pos[0])**2 + (Y - self.pos[1])**2)\n        potential = self.charge \/ r\n        return potential","f36e31f8":"x = np.linspace(-5, 5, 100)\ny = np.linspace(-4, 4, 80)\n\nY, X = np.meshgrid(x, y)\n\nq1 = ChargedParticle((-1, 0), -1)\nq2 = ChargedParticle((1, 0), 1)\n\nfield1 = q1.compute_field(x, y)\nfield2 = q2.compute_field(x, y)","f03a0ff8":"field1 = q1.compute_field(x, y)\nfield2 = q2.compute_field(x, y)\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(5, 10))\nax1.streamplot(x, y, u=field1[:, :, 0], v=field1[:, :, 1])\nax1.set_title(\"particle with negative charge\");\nax1.axis('equal')\nax2.streamplot(x, y, u=field2[:, :, 0], v=field2[:, :, 1])\nax2.set_title(\"particle with positive charge\");\nax2.axis('equal');","90ad7ad8":"def compute_resulting_field(particles, x, y):\n    fields = [p.compute_field(x, y) for p in particles]\n    total_field = np.zeros_like(fields[0])\n    for field in fields:\n        total_field += field\n    return total_field\n\ntotal_field = compute_resulting_field([q1, q2], x, y)\n\nplt.streamplot(x, y, total_field[:, :, 0], total_field[:, :, 1])\nplt.xlim(x.min(), x.max())\nplt.ylim(y.min(), y.max());","1c1b398f":"lw = np.linalg.norm(total_field, axis=2)\nlw \/= lw.max()\nplt.streamplot(x, y, total_field[:, :, 0], total_field[:, :, 1], linewidth=10*lw, density=2)\nplt.xlim(x.min(), x.max())\nplt.ylim(y.min(), y.max());","77614296":"We can even explore some options regarding the streamplot.","af1e7515":"We can test it by creating **two particles with opposite charge**.","3954470d":"## The static electric field and forces\nThe static electric force created by a single fixed charge q<sub>1<\/sub> on another one q<sub>2<\/sub> is a vector force (**Coulomb's law**) usually written as:\n\n$$ \\vec{F}=\\frac{1}{4\\pi \\varepsilon _{0}}\\frac{q_{1}q_{2}}{r^{2}}\\vec{e_{12}} $$\n\n(with the vector e<sub>12<\/sub> pointing from 2 to 1)\n\nThis lets us define a field which is related to the above force by the relationship:\n\n$$ \\vec{F}=q_{1}\\vec{E}  $$\n\nFrom the first formula, it follows that the field can be computed from a single charge's location with:\n\n$$ \\vec{E}=\\frac{1}{4\\pi \\varepsilon _{0}}\\frac{q_{2}}{r^{2}}\\vec{e_{12}} $$\n\nAnd if you have multiple charges, you just sum over these to get the total field:\n\n$$ \\vec{E_{total}}=\\sum \\frac{1}{4\\pi \\varepsilon _{0}}\\frac{q_{i}}{r_{i}^{2}}\\vec{e_{i}} $$\n\n## Implementation using Python\nLet's first define a charged particle class that allows us to compute the field and the potential.","1be76e3c":"Let's plot their **fields**:","f3156548":"As expected, field lines are **converging** towards the negative charge and **diverging** from the posive charge. We can now compute the whole field by summing over the individual electric fields."}}