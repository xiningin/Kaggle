{"cell_type":{"21990ef6":"code","2c7d71e2":"code","2635df6f":"code","6f74238b":"code","42e53b10":"code","e15789c1":"code","171e66f0":"code","1267cdab":"code","7b85c79a":"code","d51a8745":"code","e57b415f":"code","2bf1f1ca":"code","399ad47d":"code","43119637":"code","dd87d075":"code","1fc724bc":"code","9a1a55a9":"code","4d76e406":"code","06e1091c":"code","04a7cfb6":"code","90617c9e":"code","e62b4742":"code","b326c515":"markdown","4ba661c1":"markdown","9b206f49":"markdown","516472f3":"markdown","45590c08":"markdown","0de0a8a7":"markdown","6d9a5eba":"markdown","4e3bb794":"markdown","40e58511":"markdown","b35783ea":"markdown","107a1b55":"markdown","3bc5437c":"markdown","3d076b15":"markdown","afc3d028":"markdown","485bcedc":"markdown","c532b9de":"markdown","dc5ab3a9":"markdown","ead86d4a":"markdown"},"source":{"21990ef6":"#!pip install nbconvert  # already-installed (most probably)\n#!apt install pandoc  # already-installed\n#!apt install texlive-xetex -y  # this'll take a long time","2c7d71e2":"#import IPython\n#IPython.display.IFrame(<iframe width=\"650\" height=\"400\" frameborder=\"0\" scrolling=\"no\" marginheight=\"0\" marginwidth=\"0\" title=\"2019-nCoV\" src=\"\/gisanddata.maps.arcgis.com\/apps\/Embed\/index.html?webmap=14aa9e5660cf42b5b4b546dec6ceec7c&extent=77.3846,11.535,163.5174,52.8632&zoom=true&previewImage=false&scale=true&disable_scroll=true&theme=light\"><\/iframe>)","2635df6f":"from IPython.display import HTML\n\nHTML('<div style=\"position:relative;height:0;padding-bottom:56.25%\"><iframe src=\"https:\/\/www.youtube.com\/embed\/jmHbS8z57yI?ecver=2\" width=\"640\" height=\"360\" frameborder=\"0\" style=\"position:absolute;width:100%;height:100%;left:0\" allowfullscreen><\/iframe><\/div>')","6f74238b":"## install calmap\n#! pip install calmap","42e53b10":"# essential libraries\nimport json\nimport random\nfrom urllib.request import urlopen\n\n# storing and anaysis\nimport numpy as np\nimport pandas as pd\n\n# visualization\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.express as px\nimport plotly.graph_objs as go\nimport plotly.figure_factory as ff\n#import calmap\nimport folium\nimport plotly.io as pio\npio.templates.default = \"plotly_dark\"\nfrom plotly.subplots import make_subplots\n\n# color pallette\ncnf = '#393e46' # confirmed - grey\ndth = '#ff2e63' # death - red\nrec = '#21bf73' # recovered - cyan\nact = '#fe9801' # active case - yellow\n\n# converter\nfrom pandas.plotting import register_matplotlib_converters\nregister_matplotlib_converters()   \n\n# hide warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# html embedding\nfrom IPython.display import Javascript\nfrom IPython.core.display import display\nfrom IPython.core.display import HTML","e15789c1":"# list files\n#!ls ..\/input\/corona-virus-report","171e66f0":"# importing datasets\nfull_table = pd.read_csv('\/kaggle\/input\/novel-corona-virus-2019-dataset\/covid_19_data.csv',parse_dates = ['ObservationDate'])\n#full_table = pd.read_csv('..\/input\/corona-virus-report\/covid_19_clean_complete.csv', \n#                         parse_dates=['Date'])\n","1267cdab":"print ('Last update of this dataset was ' + str(full_table.loc[len(full_table)-1]['Last Update']))","7b85c79a":"full_table.columns = ['SNo', 'Date', 'Province\/State', 'Country\/Region',\n       'Last Update', 'Confirmed', 'Deaths', 'Recovered']\nfull_table.head(10)","d51a8745":"### Cleaning Data\n\n# cases \ncases = ['Confirmed', 'Deaths', 'Recovered', 'Active']\n\n# Active Case = confirmed - deaths - recovered\nfull_table['Active'] = full_table['Confirmed'] - full_table['Deaths'] - full_table['Recovered']\n\n# replacing Mainland china with just China\nfull_table['Country\/Region'] = full_table['Country\/Region'].replace('Mainland China', 'China')\n\n# filling missing values \nfull_table[['Province\/State']] = full_table[['Province\/State']].fillna('')\nfull_table[cases] = full_table[cases].fillna(0)","e57b415f":"# cases in the ships\nship = full_table[full_table['Province\/State'].str.contains('Grand Princess')|full_table['Country\/Region'].str.contains('Cruise Ship')]\n\n# china and the row\nchina = full_table[full_table['Country\/Region']=='China']\nus = full_table[full_table['Country\/Region']=='US']\nskorea  = full_table[full_table['Country\/Region']=='South Korea']\nhot_europe = full_table[full_table['Country\/Region'].isin(['Italy,Spain','Germany','France','UK','Switzerland','Netherlands','Belgium','Austria','Norway','Sweeden','Denmark','Portugal']) ]\nitaly = full_table[full_table['Country\/Region']=='Italy']\niran = full_table[full_table['Country\/Region']=='Iran']\nspain = full_table[full_table['Country\/Region']=='Spain']\nfrance = full_table[full_table['Country\/Region']=='France']\nuk = full_table[full_table['Country\/Region']=='UK']\nswitzerland = full_table[full_table['Country\/Region']=='Switzerland']\nsweden = full_table[full_table['Country\/Region']=='Sweden']\nindia = full_table[full_table['Country\/Region']=='India']\nsingapore = full_table[full_table['Country\/Region']=='Singapore']\nrow = full_table[full_table['Country\/Region']!='China']\n#rest of China\nroc = china[china['Province\/State'] != 'Hubei']\ngermany = full_table[full_table['Country\/Region']=='Germany']\nca = us[us['Province\/State'] == 'California']\nny = us[us['Province\/State'] == 'New York']\nwa = us[us['Province\/State'] == 'Washington']\nco = us[us['Province\/State'] == 'Colorado']\nnj = us[us['Province\/State'] == 'New Jersey']\nla = us[us['Province\/State'] == 'Louisiana']\nma = us[us['Province\/State'] == 'Massachusetts']\nfl = us[us['Province\/State'] == 'Florida']\nmi = us[us['Province\/State'] == 'Michigan']\nil = us[us['Province\/State'] == 'Illinois']\n\n\n# latest\nfull_latest = full_table[full_table['Date'] == max(full_table['Date'])].reset_index()\nchina_latest = full_latest[full_latest['Country\/Region']=='China']\nrow_latest = full_latest[full_latest['Country\/Region']!='China']\n\n# latest condensed\nfull_latest_grouped = full_latest.groupby('Country\/Region')['Confirmed', 'Deaths', 'Recovered', 'Active'].sum().reset_index()\nchina_latest_grouped = china_latest.groupby('Province\/State')['Confirmed', 'Deaths', 'Recovered', 'Active'].sum().reset_index()\nrow_latest_grouped = row_latest.groupby('Country\/Region')['Confirmed', 'Deaths', 'Recovered', 'Active'].sum().reset_index()","2bf1f1ca":"def country_info (country, dt, incl_state=False):\n    \n    if incl_state:\n        print ('Rates for states\/province in ' + pd.unique(country['Country\/Region']))\n        by_state = country.groupby(['Date', 'Province\/State'])['Date','Confirmed', 'Deaths', 'Recovered', 'Active'].max()\n        by_state.active = by_state\n        by_state = by_state.sort_values(by='Confirmed', ascending=False)\n        by_state.reset_index(drop=True)\n        by_state.style.background_gradient(cmap='Pastel1_r')\n        print (by_state)\n    by_date = country.groupby (['Date'])[['Confirmed', 'Deaths', 'Recovered', 'Active']].sum()\n    by_date = by_date.reset_index()\n    by_date = by_date[by_date.Date>=dt]\n    #print (len(by_date))\n\n    #print ('Rates for country\/region : ' + pd.unique(country['Country\/Region']))\n\n    #print (by_date)\n    \n    \n    # Add need fields\n    \n    by_date ['prior_confirmed'] = 0\n    by_date ['prior_deaths'] = 0\n    by_date ['prior_recovered'] = 0\n    by_date ['daily_confirmed'] = 0\n    by_date ['daily_deaths'] = 0\n    by_date ['daily_recovered'] = 0\n    p_confirmed = 0\n    p_deaths = 0\n    p_recovered = 0\n   \n    for i, row in by_date.iterrows():\n        #print (by_date.loc[i])\n        by_date.loc[i,'prior_confirmed'] = p_confirmed \n        by_date.loc[i,'prior_deaths'] = p_deaths \n        by_date.loc[i,'prior_recovered'] = p_recovered\n        p_confirmed = by_date.loc[i,'Confirmed']\n        p_deaths = by_date.loc[i,'Deaths']\n        p_recovered = by_date.loc[i,'Recovered']\n        \n        \n    \n    by_date ['delta_confirmed'] = by_date.Confirmed - by_date.prior_confirmed\n    by_date ['delta_deaths'] = by_date.Deaths - by_date.prior_deaths\n    by_date ['delta_recovered'] = by_date.Recovered - by_date.prior_recovered\n    \n    return by_date\n\nus_by_date = country_info(us,'2020-03-04', False)\nchina_by_date = country_info(china,'2020-01-01', False)\nhot_europe_by_date = country_info(hot_europe,'2020-02-20',) \nitaly_by_date = country_info(italy,'2020-02-20',)\nskorea_by_date = country_info(skorea,'2020-02-17')\niran_by_date = country_info(iran,'2020-02-23')\nspain_by_date = country_info(spain,'2020-02-23')\nrow['Country\/Region'] = 'Rest of World'\nrow_by_date = country_info(row,'2020-02-17')\nroc_by_date = country_info (roc, '2020-01-01')\ngermany_by_date = country_info (germany, '2020-02-23')\nfrance_by_date = country_info (france, '2020-02-23')\nuk_by_date = country_info (uk, '2020-02-23')\nsweden_by_date = country_info (sweden, '2020-02-23')\nindia_by_date = country_info (india, '2020-02-23')\nswitzerland_by_date = country_info(switzerland,'2020-02-23')\nsingapore_by_date = country_info(singapore,'2020-02-05')\nca['Country\/Region'] = 'California'\nny['Country\/Region'] = 'New York'\nwa['Country\/Region'] = 'Washington'\nca_by_state = country_info(ca,'2020-03-09')\nny_by_state = country_info(ny,'2020-03-09')\nwa_by_state = country_info(wa,'2020-03-09')\nco_by_state = country_info(co,'2020-03-09')\nnj_by_state = country_info(nj,'2020-03-09')\nla_by_state = country_info(la,'2020-03-09')\nma_by_state = country_info(ma,'2020-03-09')\nfl_by_state = country_info(fl,'2020-03-09')\nmi_by_state = country_info(mi,'2020-03-09')\nil_by_state = country_info(il,'2020-03-09')\n\n","399ad47d":"dict = {'United States':us_by_date,\n        'California':ca_by_state,\n        'Washington':wa_by_state,\n        'New York':ny_by_state,\n        'Colorado':co_by_state,\n        'New Jersey': nj_by_state,\n        'Louisiana': la_by_state,\n        'Massachusetts': ma_by_state,\n        'Florida': fl_by_state,\n        'Michigan': mi_by_state,\n        'Illinois': il_by_state,\n\n        'China':china_by_date,\n        'Rest of world -w\/o China':row_by_date,        \n        'Hot European Countries':hot_europe_by_date,\n        'Italy':italy_by_date,   \n        'Iran':iran_by_date,\n        'South Korea':skorea_by_date,\n        'Spain':spain_by_date,\n        'France':france_by_date,\n        'Germany':germany_by_date,        \n        'United Kingdom':uk_by_date,\n        'Switzerland':switzerland_by_date,\n        'Sweden':sweden_by_date,\n        'Singapore':singapore_by_date,\n        'India':india_by_date,\n\n        'Rest of China w\/o Hubei': roc_by_date,\n        }\n\ndict_sigmoid = {\n        'China':china_by_date,\n        'South Korea': skorea_by_date,\n        'Rest of China w\/o Hubei': roc_by_date,\n        'Rest of world -w\/o China':row_by_date,\n        'Iran':iran_by_date,\n        'Hot European Countries':hot_europe_by_date,\n        'Italy':italy_by_date,\n        'Switzerland':switzerland_by_date,\n        'Spain':spain_by_date,\n        'Germany':germany_by_date,\n        'United States':'us_by_date',\n        'New York':ny_by_state,\n        'Washington':wa_by_state,\n        'California':ca_by_state,\n        'Colorado':co_by_state,\n        'Louisiana': la_by_state,\n        'Massachusetts': ma_by_state,\n        'Florida': fl_by_state,\n\n}","43119637":"def plots_by_country (country, country_name):\n\n    temp = country\n\n    # adding two more columns\n    temp['No. of Deaths to 100 Confirmed Cases'] = round(temp['Deaths']\/temp['Confirmed'], 3)*100\n    temp['No. of Recovered to 100 Confirmed Cases'] = round(temp['Recovered']\/temp['Confirmed'], 3)*100\n    # temp['No. of Recovered to 1 Death Case'] = round(temp['Recovered']\/temp['Deaths'], 3)\n    #print (temp)\n\n    \n    #print (temp.iloc[13]['Date'])\n    last_date = temp.iloc[len(temp)-1]['Date']\n    death_rate = temp[temp.Date ==last_date]['No. of Deaths to 100 Confirmed Cases']\n    recovered_rate = temp[temp.Date ==last_date]['No. of Recovered to 100 Confirmed Cases']\n    temp = temp.melt(id_vars='Date', value_vars=['No. of Deaths to 100 Confirmed Cases', 'No. of Recovered to 100 Confirmed Cases'], \n                     var_name='Ratio', value_name='Value')\n\n    #str(full_table.loc[len(full_table)-1]['Date'])\n\n    fig = px.line(temp, x=\"Date\", y=\"Value\", color='Ratio', log_y=True, width=1000, height=700,\n                  title=country_name + ' Recovery and Mortality Rate Over Time', color_discrete_sequence=[dth, rec])\n    fig.show()\n    return death_rate, recovered_rate\n        \nrates = []\nfor key, value in dict.items():\n    death_rate, recovered_rate  = plots_by_country (value,key)\n    rates.append ([key,np.float(death_rate),np.float(recovered_rate)]) \n    ","dd87d075":"def plots_of_daily (country, country_name):\n\n    temp = country\n    #print (temp.columns)\n    temp.columns = ['Date', 'Confirmed', 'Deaths', 'Recovered', 'Active', 'prior_confirmed',\n       'prior_deaths', 'prior_recovered', 'daily_confirmed', 'daily_deaths',\n       'daily_recovered', 'New Daily Confirmed', 'delta_deaths', 'delta_recovered',\n       'No. of Deaths to 100 Confirmed Cases',\n       'No. of Recovered to 100 Confirmed Cases']\n    #print (temp.iloc[13]['Date'])\n    last_date = temp.iloc[len(temp)-1]['Date']\n\n    #str(full_table.loc[len(full_table)-1]['Date'])\n\n    fig = px.line(temp, x=\"Date\", y=\"New Daily Confirmed\", log_y=False, width=800, height=800,\n                  title=country_name + ' New Daily Cases' , color_discrete_sequence=[dth, rec])\n    fig.show()\n\n        \nrates = []\nfor key, value in dict.items():\n    plots_of_daily (value,key)\n    #rates.append ([key,np.float(death_rate),np.float(recovered_rate)]) ","1fc724bc":"#rates\n","9a1a55a9":"import pylab\nfrom scipy.optimize import curve_fit\n\ndef sigmoid(x, x0, k, ymax):\n     y = ymax \/ (1 + np.exp(-k*(x-x0)))\n     return y\n\ndef exp (x,a,b):\n    y = a* np.exp(x*b)\n    return y\n\ndef gaussian(x, a, x0, sigma):\n    return a*np.exp(-(x-x0)**2\/(2*sigma**2))\n\ndef growth_rate_over_time (f, country, attribute, title):\n    ydata = country[attribute]\n    \n\n    xdata = list(range(len(ydata)))\n\n    rates = []\n    for i, x in enumerate(xdata):\n        if i > 2:\n#            print (xdata[:x+1])\n#            print (ydata[:x+1])\n\n            popt, pcov = curve_fit(f, xdata[:x+1], ydata[:x+1],)\n            if popt[1] < 0:\n                rates.append (0.0)\n            else:    \n                rates.append (popt[1])\n    rates = np.array(rates) \n    pylab.style.use('dark_background')\n    pylab.figure(figsize=(12,8))\n    xdata = np.array(xdata)\n    #pylab.grid(True, linestyle='-', color='0.75')\n    pylab.plot(xdata[3:]+1, 100*rates, 'o', linestyle='solid', label=attribute)\n    #if fit_good:\n    #    pylab.plot(x,y, label='fit')\n    #pylab.ylim(0, ymax*1.05)\n    #pylab.legend(loc='best')\n    pylab.xlabel('Days Since Start')\n    pylab.ylabel('Growth rate percentage ' + attribute)\n    pylab.title(title + attribute, size = 15)\n    pylab.show()\n    \n        \n    \n\ndef plot_curve_fit (f, country, attribute, title, normalize = False, curve = 'Exp'):\n    #country = country[10:]\n    fit_good = True\n    ydata = country[attribute]\n    #ydata = np.array(ydata)\n    xdata = range(len(ydata))\n    mu = np.mean(ydata)\n    sigma = np.std(ydata)\n    ymax = np.max(ydata)    \n    if normalize:\n        ydata_norm = ydata\/ymax\n    else:\n        ydata_norm = ydata\n    #f = sigmoid\n    try:\n        if curve == 'Gauss': # pass the mean and stddev\n            popt, pcov = curve_fit(f, xdata, ydata_norm, p0 = [1, mu, sigma])\n        elif curve == 'Sigmoid':\n            popt, pcov = curve_fit(f, xdata, ydata_norm, bounds = ([0,0,0],np.inf),maxfer=1000)\n        else:    \n            popt, pcov = curve_fit(f, xdata, ydata_norm,)\n    except RuntimeError:\n        print ('Exception - RuntimeError - could not fit curve')\n        fit_good = False\n    else:\n\n        fit_good = True\n        \n    if fit_good:\n        if curve == 'Exp':\n            if popt[1] < 0.9: # only print if we have a growth rate\n                \n                print (key + ' -- Coefficients for y = a * e^(x*b)  are ' + str(popt))\n                print ('Growth rate is now ' + str(round(popt[1],2)))\n                print ('...This doubles in ' + str (round(0.72\/popt[1] , 1) ) +' days')\n            else:\n                fit_good = False\n        elif curve == 'Gauss':\n            print (key + ' -- Coefficients are ' + str(popt))\n        else:   # sigmoid \n            print (key + ' -- Coefficients for y = 1\/(1 + e^(-k*(x-x0)))  are ' + str(popt))\n            \n        if fit_good:\n            print ('Mean error for each coefficient: ' + str(np.sqrt(np.diag(pcov))\/popt))\n    else:\n        print (key + ' -- Could not resolve coefficients ---')\n    x = np.linspace(-1, len(ydata), 100)\n    if fit_good:\n        y = f(x, *popt)\n        if normalize:\n            y = y * ymax\n        plt.style.use('dark_background')\n        pylab.figure(figsize=(15,12)) \n        #pylab.grid(True, linestyle='-', color='0.75')\n        pylab.plot(xdata, ydata, 'o', label=attribute)\n        #if fit_good:\n        pylab.plot(x,y, label='fit')\n        pylab.ylim(0, ymax*1.05)\n        pylab.legend(loc='best')\n        pylab.xlabel('Days Since Start')\n        pylab.ylabel('Number of ' + attribute)\n        pylab.title(title + attribute, size = 15)\n        pylab.show()\n","4d76e406":"for key, value in dict.items():\n    if key in [\"China\",'Rest of China w\/o Hubei']:\n        pass\n    else:\n        #growth_rate_over_time (exp, value, 'Confirmed', \"Growth Rate Percentage - \")\n        growth_rate_over_time (exp, value, 'Confirmed', key + ' - Growth Rate Percentage for ',)\n        #growth_rate_over_time (exp, value, 'Deaths', key + ' - Growth Curve for ',)\n        #growth_rate_over_time (exp, value, 'Recovered', key + ' - Growth Curve for ',False)","06e1091c":"round (72\/35,2)","04a7cfb6":"for key, value in dict.items():\n    if key in [\"China\",'Rest of China w\/o Hubei']:\n        pass\n    else:\n        plot_curve_fit (exp, value, 'Confirmed', key + ' - Growth Curve for ',False)\n        plot_curve_fit (exp, value, 'Deaths', key + ' - Growth Curve for ',False)\n        plot_curve_fit (exp, value, 'Recovered', key + ' - Growth Curve for ',False)","90617c9e":"for key, value in dict_sigmoid.items():\n    plot_curve_fit (sigmoid, value, 'Confirmed', key + ' - Logistic Growth Curve for ',True, 'sigmoid')\n    plot_curve_fit (sigmoid, value, 'Deaths', key + ' - Logistic Growth Curve for ',True, 'sigmoid')\n    #plot_curve_fit (sigmoid, value, 'Recovered', key + ' - Logistic Growth Curve for ',True, 'sigmoid')","e62b4742":"plot_curve_fit (gaussian, roc_by_date, 'Active', 'China w\/o Hubei' + ' - Curve for Cases ',False,'Gauss')\nplot_curve_fit (gaussian, china_by_date, 'Active', 'China' + ' - Curve for Cases ',False,'Gauss')\nplot_curve_fit (gaussian, skorea_by_date, 'Active', 'South Korea' + ' - Curve for Cases ',False,'Gauss')\n#plot_curve_fit (gaussian, iran_by_date, 'Active', 'Iran' + ' - Curve for Cases ',False,'Gauss')\nplot_curve_fit (gaussian, switzerland_by_date, 'Active', 'Switzerland' + ' - Curve for Cases ',False,'Gauss')","b326c515":"https:\/\/www.kaggle.com\/imdevskp\/mers-outbreak-analysis  \nhttps:\/\/www.kaggle.com\/imdevskp\/sars-2003-outbreak-analysis  \nhttps:\/\/www.kaggle.com\/imdevskp\/western-africa-ebola-outbreak-analysis\n","4ba661c1":"## Most Recent Update","9b206f49":"## Gaussian Approximation of Active Cases\n\nThe active cases should fairly clossly resemble a Gaussian distribution. While the derivate of a sigmoid function is not the Gaussian function, a Gaussian distribution is a close approximation.","516472f3":"### Import Libraries","45590c08":"### Growth Rates of Confirmed, Deaths, \n\nThere are three graphs in this section which show exponential growth rate of confirmed, deaths, and recovered. The head shows the current growth rate.\n\nYou can use the rule of 72 to find the doubling rate. As of March 20th, the confirmed growth rate for the United States is around 0.35. That means that the number of confirmed cases will double in just 2 days. *( 72\/35 = 2.06 )*","0de0a8a7":"## New Daily Cases\nThis is a new graph which shows the new confirmed cases on a daily basis. When this curve turns down, it indicates an inflection point. Currently, nearly all countries and states are still showing increasing daily rates.","6d9a5eba":"# Corona Growth Patterns in Critical Countries\n\nI think it is important for everyone to understand the nature of the growth patterns of pandemics. There is an excellent Youtube video from [3Blue1Brown](https:\/\/www.youtube.com\/channel\/UCYO_jab_esuFRV4b17AJtAw) that offers a great explanation.\n\n### Understanding Growth Video Link\n\n![image.png](attachment:image.png)\n\nhttps:\/\/www.youtube.com\/watch?v=Kas0tIxDvrg&t=35s","4e3bb794":"# Preprocessing","40e58511":"# Libraries","b35783ea":"### Install","107a1b55":"# Purpose of This Document\nThe purpose of this notebook is to provide tracking of the COVID-19 virus in specific countries and regions that have seen severe growth rates. Currently, the following countries and regions are included:\n* China\n* All China excluding the original Hubei province\n* Rest of the world\n* United States\n* Italy\n* Iran\n* Spain\n* More (see below in the Change History section)\n\nThere are two phases to the growth rate, an exponential phase, and then a flattening, downward turning of the curve. This is a sigmoid curve. The sigmoid curve is include only in the cases where the inflection point has been crossed (as of 3\/15\/20, all China and remainder of China excluding Hubei. \n\nBecause I live in the United States, The report now includes US states which have very active growth rates.\n\nOverall, it is hopeful that the exponential graphs will help us define the inflection point for each separate population grouping. \n\n## Observation Log\n\n* On 3\/18, South Korea was moved to the sigmoid tracking group. The sigmoid curves now converge.\n*          Italy's exponential curve began to tilt slightly. That may signal the start of an inflection point.\n*          Italy's mortality rate is extremely high and still climbing.\n*          Washington State also seems to be flattening.\n* 3\/20\/20 - For the third day in a row, the confirmed rate in Iran is to the right of the curve. **Iran may be reaching an inflection** point after around 25 days. **Italy also seems close** to an inflection point\n* 3\/23\/20 - Most of the European countries seem to be flattening on the exponential growth curve. However, South Korea now seems to have a spike in new cases. Iran now has curve fitting available for the logistic curve.\n* 3\/27\/20 - All the European country growth curves are flattening. This means we are reaching an inflection point at around day 32. Italy still does not fit a logistic curve. The exponential growth curve for both South Korea and Iran has started to turn up again, indicating that there are new cases showing up after the inflection point. The inflection point may be further out than we thought. Both Iran and South Korea has an increase in exponential growth rate, reversing the logistic curve. Did they stop their containment program too soon? While not on these graphs, Los Angeles now has over 1100 cases. It seems to be another very hot area. The new cases daily tracking show some disturbing information that **Iran's rate is still growing exponentially, a reversal over the last few days.** Iran has been removed from the logistic plots.\n* 3\/28\/20 - The good news is that the daily number of new cases turned down in the US and almost every state. On the other hand, Iran has had an uptick in new cases, and has been removed from the logistic plots.\n* 3\/30\/20 - The daily number of new cases is turning down in European countries and nearly all US states. Colorado and Illinois still are showing increases. Switzerland is at or past an inflection point. Iran now shows a continuing upward growth pattern. Either there is more testing or a relaxed social distance policy. That country should be carefully watched for the next 2 weeks. Sweden has the lowest growth rate in Europe at 11%.\n* 3\/31\/20 - As of 3\/30, Italy, Spain, Hot European, and New York all now have logistic curve form and are being plotted. In New York, the k parameter is 16, which might indicate a false positive. The inflection point in Europe seems to be around 33 days. \n* 4\/2\/20  - Most states in the US are beginning to reach inflection. Washington now fits a logistic curve.\n* 4\/5\/20  - All US states except Michigan seemed to have reached inflection point. European countres UK and France are still showing exponential growth. Iran has reached another inflection point. Once we are able to plot the logistic curve, we can see where the inflection points are. The European points seem to be further out, between 33 and 40 days. The points for the two US states, New York and Washington are around 24 days. This will push out a bit further probably, because growth is almost linear in the US states. \n* 4\/6\/20 - Louisiana, Massachusetts, Florida, and the rest of the world without China all seemed to have reached an inflection point. They are being moved to the logistic tracking graph.\n\n## Change History\n\n* 2020-03-18 - Addressed a problem with some of the curve fitting not converging. Because some of the countries, like the US, had a long period of days with no increases of cases, the tracking start date.\n* 2020-03-18 - Added US \"hot\" states, NY, CA, and WA. Also added Germany, which has shown rapid recent growth.\n* 2020-03-19 - Added Colorado, per friend request. Also added France and 2 high density countries, Monaco and Singapore\n* 2020-03-20 - Removed Monaco, not enough cases\n* 2020-03-21 - Added Switzerland, New Jersey, Louisiana, and 12 'hot' European countries as a group\n* 2020-03-22 - Added United Kingdom and UK to hot European group\n* 2020-03-23 - Changed South Korea extract, due to a data change in source; moved Iran to the logistic curve section;\n* 2020-03-24 - Changed dataset source due to issues with corona-virus-report\/covid_19_clean_complete.csv; United Kingdom is called UK on this dataset\n* 2020-03-27 - Added more US states: Massachusetts, Florida, Michigan, Illinois. Add new cases tracking graph. Removed Iran from logistic graph. \n* 2020-03-30 - Added Sweden to country tracking because they are not enforcing any social distancing rules. Also added India because of population size.\n* 2020-03-31 - Moved Italy, Spain, Hot European, and New York to the logistic plot.\n* 2020-04-02 - Added Washington to logistic plot. Corrected error with negative growth rates.\n* 2020-04-05 - Added Germany, California, Washington to logistic plot. Corrected error with negative growth rates.\n* 2020-04-06 - Added Louisiana, Massachusetts, Florida, and the rest of the world without China to logistic plots.\n* 2020-04-08 - Added United States to logistic plots.\n*   -- planned -- extract all growth rates into a separate table for comparison; add additional hot countries\n\n\n## About Coronavirus\n\n* Coronaviruses are **zoonotic** viruses (means transmitted between animals and people).  \n* Symptoms include from fever, cough, respiratory symptoms, and breathing difficulties. \n* In severe cases, it can cause pneumonia, severe acute respiratory syndrome (SARS), kidney failure and even death.\n* Coronaviruses are also asymptomatic, means a person can be a carrier for the infection but experiences no symptoms\n\n## Novel coronavirus (nCoV)\n* A **novel coronavirus (nCoV)** is a new strain that has not been previously identified in humans.\n\n## COVID-19 (Corona Virus Disease 2019)\n* Caused by a **SARS-COV-2** corona virus.  \n* First identified in **Wuhan, Hubei, China**. Earliest reported symptoms reported in **November 2019**. \n* First cases were linked to contact with the Huanan Seafood Wholesale Market, which sold live animals. \n* On 30 January the WHO declared the outbreak to be a Public Health Emergency of International Concern ","3bc5437c":"Based on the above curves, it seems that South Korea's growth rate has reached an inflection point. The sigmoid function does now fit without error, so it is included in the next section.\n\n## Logistic Growth Curves\n\nChina and the subset of China outside Hubei now have resonable sigmoid growth curves. Here are their plots.","3d076b15":"# Dataset","afc3d028":"## Examining the Growth Curves\n\nThese distributions start off exponentially, but eventually become a logistic curve. We can plot them both ways, and then fit a linear regression to the log of the value to determine the rate.\n\nFirst we look at mortality curves. The trend to what for is an increasing mortality curve. This means that medical treatments are not controlling the virus well. This is true in Italy, which has an older population and seemed to be slow to respond in social distancing efforts. Compare Italy to South Korea, which had an agressive testing and treatment program.\n\n### What these curves show\n\nThere are several groups of curves shown. They show:\n\n* Death and recovery rates for each region - these are on a log scale and show rates of death and recovery per confirmed cases \n* Growth rate over time - this shows the daily growth rate for each \n* Exponential growth for each region - there are separate plots for confirmed cases, deaths, and recovered\n* Sigmoid growth curves - these are for only the countries that have reached an inflection point\n* Gaussian curves - these are an approximation of the derivative of the sigmoid curve, which is the number of daily new cases over time \n\nThe growth and normal curves also have the coefficents and errors for each coeffients. The second coefficient is the growth rate.","485bcedc":"# Analysis on similar epidemics","c532b9de":"## Exponential Growth Curves\n\nThere are two sets of graphs in this section. \n\n### Growth Rate Percentage Over Time\n\nThe first is a plot of growth rate percentage over time. The graph starts on the 4th day because initial rates cannot be extimated. This graph is produced by generating curve fittings iteratively for the n days. This means that the a separate is calulated for days 1-4, 1-5, 1-6,...1-n. These calculated rates are then plotted over the number of days since the localized start.\n","dc5ab3a9":"Next, let's review some of the grow curves.\n\n","ead86d4a":"# Acknowledgements\n\nThis effort was inspired by an excellent Youtube video from [3Blue1Brown](https:\/\/www.youtube.com\/channel\/UCYO_jab_esuFRV4b17AJtAw)\n\n* Video - https:\/\/www.youtube.com\/watch?v=Kas0tIxDvrg&t=35s \n* Starting kernel - https:\/\/www.kaggle.com\/imdevskp\/covid-19-analysis-viz-prediction-comparisons\n* https:\/\/github.com\/CSSEGISandData\/COVID-19\n* https:\/\/arxiv.org\/ftp\/arxiv\/papers\/2003\/2003.05681.pdf\n\n"}}