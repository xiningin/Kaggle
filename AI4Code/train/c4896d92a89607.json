{"cell_type":{"e9246366":"code","4a82ea20":"code","fbad3b79":"code","a944f936":"code","e455ef2e":"code","71800442":"code","a508f6a8":"code","23ead104":"code","f0e1ca66":"code","bca1a71b":"code","d3d693af":"code","460804b8":"code","9fd9c401":"markdown","3835c3ca":"markdown"},"source":{"e9246366":"import matplotlib.pyplot as plt\nimport numpy as np\nimport os\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.decomposition import PCA \nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import classification_report\nimport random\nimport sympy as sm\nfrom scipy import optimize\nfrom matplotlib import cm\nimport matplotlib.mlab as mlab\n\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n","4a82ea20":"def images_to_ndarray(images_dir: str, label: int):\n  folder_path = '\/kaggle\/input\/medical-mnist\/' + images_dir + '\/'\n  images_names = sorted(os.listdir(folder_path))\n  np_no_label_images = np.array([plt.imread(folder_path + img).flatten() for img in images_names])\n  np_label_images = np.zeros((np_no_label_images.shape[0],np_no_label_images.shape[1] + 1),dtype=int)\n  np_label_images[:,-1] = np.ones(np_no_label_images.shape[0], dtype=int) * label\n  np_label_images[:,:-1] = np_no_label_images\n  return np_label_images","fbad3b79":"labels_dict = {0 : 'AbdomenCT', 1 : 'BreastMRI', 2 : 'CXR', 3 : 'ChestCT', 4 : 'Hand', 5 : 'HeadCT'}\nlabel_data_0 = images_to_ndarray(labels_dict.get(0), 0)\nlabel_data_1 = images_to_ndarray(labels_dict.get(1), 1)\nlabel_data_2 = images_to_ndarray(labels_dict.get(2), 2)\nlabel_data_3 = images_to_ndarray(labels_dict.get(3), 3)\nlabel_data_4 = images_to_ndarray(labels_dict.get(4), 4)\nlabel_data_5 = images_to_ndarray(labels_dict.get(5), 5)\ndata = np.r_[label_data_0, label_data_1, label_data_2, label_data_3, label_data_4, label_data_5]","a944f936":"# scaling data for faster processing\nlabels = data[:,-1]\nnp_data_no_labels = data[:,:-1]\nscaler = MinMaxScaler()\n# Fit on training set only.\nscaler.fit(np_data_no_labels)\n# Apply transform to both the training set and the test set.\nnp_data_no_labels = scaler.transform(np_data_no_labels)","e455ef2e":"# PCA on 95% of the features\npca = PCA(.95)\nnp_data_no_labels = pca.fit_transform(np_data_no_labels)\n\n\n# Adding labels back after PCA\npca_data_with_label= np.zeros((np_data_no_labels.shape[0],np_data_no_labels.shape[1] + 1),dtype=int)\npca_data_with_label[:,-1] = labels\npca_data_with_label[:,:-1] = np_data_no_labels\n\n\nX = pca_data_with_label[:,:-1]\ny = pca_data_with_label[:,-1]","71800442":"# spliting to train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)","a508f6a8":"def model_accuracy(model, X_test, y_test):\n  y_predicted = model.predict(X_test)\n  conf = confusion_matrix(y_test, y_predicted)\n  print(conf)\n  print(classification_report(y_test, y_predicted))\n  print(\"Total error rate in %: \")\n  print((len(y_predicted) - sum(np.diag(conf))) \/ len(y_predicted) * 100)\n  # add how to find missclassification items\n  X_missclassification = X_test[y_test != y_predicted]","23ead104":"#KNN\nmodel_knn = KNeighborsClassifier(n_neighbors=6)\nmodel_knn.fit(X_train, y_train)","f0e1ca66":"# Taking partial part of test data\nnum_of_elements = X_test.shape[0]\nX_test_partial = X_test[0:num_of_elements,:]\ny_test_partial = y_test[0:num_of_elements]","bca1a71b":"model_accuracy(model_knn, X_test_partial, y_test_partial)\ny_predicted = model_knn.predict(X_test)","d3d693af":"def show_image(X_missclassification, ground_truth, predicted):\n  invereted = pca.inverse_transform(X_missclassification).reshape(64,64)\n  plt.imshow(invereted,cmap='gray')\n  print(type(ground_truth))\n  print(\"Ground Truth: \" + str(labels_dict.get(ground_truth)))\n  print(\"Predicted: \" + str(labels_dict.get(predicted)))\n","460804b8":"X_missclassification = X_test[y_test != y_predicted]\ny_test_missclassification = y_test[y_test != y_predicted]\ny_predicted_missclassification = y_predicted[y_test != y_predicted]\nn = random.randint(0,len(X_missclassification))\nshow_image(X_missclassification[n,:],y_predicted_missclassification[n],y_test_missclassification[n])","9fd9c401":"Converting images into CSV file","3835c3ca":"# Scale, PCA, Train Test Split, Model"}}