{"cell_type":{"bb149eff":"code","87a3be50":"code","7c23d287":"code","2efe6ae2":"code","fe7a78ce":"code","7de84fc5":"code","8ab8a1aa":"code","927c7049":"code","7fe6ed92":"code","d6ea6367":"code","a3960bf5":"code","12286919":"code","5389d051":"code","9f3720e2":"code","4bb924aa":"code","1087a0bd":"code","98961c92":"code","2bf5465b":"code","1fb64580":"code","8e59f023":"code","7f3f9db8":"code","1dbe242f":"code","21f2899c":"code","d643323a":"code","ae82dc95":"code","0d54df11":"code","a8d4f241":"code","60feee42":"code","9c027b78":"code","0516b982":"code","42886227":"code","65653061":"code","2890f4e7":"markdown","73de1d71":"markdown","5a600a34":"markdown","68c15848":"markdown","7eab5a8f":"markdown","3e91691a":"markdown","a1e9a710":"markdown","45f11b7d":"markdown","a290b6e3":"markdown","3e2ad4e8":"markdown"},"source":{"bb149eff":"import os\nimport gc\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import KFold\n\nimport lightgbm as lgb\n\nimport warnings\nwarnings.simplefilter('ignore', FutureWarning)\n\nprint(os.listdir(\"..\/input\"))","87a3be50":"train = pd.read_csv('..\/input\/train.csv', parse_dates=[\"first_active_month\"])\ntest = pd.read_csv('..\/input\/test.csv', parse_dates=[\"first_active_month\"])\nsample_submission = pd.read_csv('..\/input\/sample_submission.csv')","7c23d287":"train.shape, test.shape, sample_submission.shape","2efe6ae2":"train.head(10)","fe7a78ce":"test.head(10)","7de84fc5":"merchants = pd.read_csv('..\/input\/merchants.csv')\nhistorical_transactions = pd.read_csv('..\/input\/historical_transactions.csv')\nnew_merchant_transactions = pd.read_csv('..\/input\/new_merchant_transactions.csv')","8ab8a1aa":"merchants.shape, historical_transactions.shape, new_merchant_transactions.shape","927c7049":"merchants.head()","7fe6ed92":"historical_transactions.head()","d6ea6367":"new_merchant_transactions.head()","a3960bf5":"def missing_impute(df):\n    for i in df.columns:\n        if df[i].dtype == \"object\":\n            df[i] = df[i].fillna(\"other\")\n        elif (df[i].dtype == \"int64\" or df[i].dtype == \"float64\"):\n            df[i] = df[i].fillna(df[i].mean())\n        else:\n            pass\n    return df","12286919":"def datetime_extract(df, dt_col='first_active_month'):\n    # df['date'] = df[dt_col].dt.date \n    df['day'] = df[dt_col].dt.day \n    df['dayofweek'] = df[dt_col].dt.dayofweek\n    df['dayofyear'] = df[dt_col].dt.dayofyear\n    df['days_in_month'] = df[dt_col].dt.days_in_month\n    df['daysinmonth'] = df[dt_col].dt.daysinmonth \n    df['month'] = df[dt_col].dt.month\n    df['week'] = df[dt_col].dt.week \n    df['weekday'] = df[dt_col].dt.weekday\n    df['weekofyear'] = df[dt_col].dt.weekofyear\n    # df['year'] = train[dt_col].dt.year\n\n    return df","5389d051":"# Do impute missing values\nfor df in [train, test, merchants, historical_transactions, new_merchant_transactions]:\n    missing_impute(df)","9f3720e2":"# Do extract datetime values\ntrain = datetime_extract(train, dt_col='first_active_month')\ntest = datetime_extract(test, dt_col='first_active_month')","4bb924aa":"train.shape, test.shape","1087a0bd":"# Define the aggregation procedure outside of the groupby operation\naggregations = {\n    'purchase_amount': ['sum', 'mean', 'std', 'min', 'max', 'size', 'median']\n}\n\ngrouped = historical_transactions.groupby('card_id').agg(aggregations)\ngrouped.columns = grouped.columns.droplevel(level=0)\ngrouped.rename(columns={\n    \"sum\": \"sum_purchase_amount\", \n    \"mean\": \"mean_purchase_amount\",\n    \"std\": \"std_purchase_amount\", \n    \"min\": \"min_purchase_amount\",\n    \"max\": \"max_purchase_amount\", \n    \"size\": \"num_purchase_amount\",\n    \"median\": \"median_purchase_amount\"\n}, inplace=True)\ngrouped.reset_index(inplace=True)\n\ntrain = pd.merge(train, grouped, on=\"card_id\", how=\"left\")\ntest = pd.merge(test, grouped, on=\"card_id\", how=\"left\")\n\ndel grouped\ngc.collect()","98961c92":"train.head()","2bf5465b":"train.shape, test.shape","1fb64580":"# Define the aggregation procedure outside of the groupby operation\naggregations = {\n    'purchase_amount': ['sum', 'mean', 'std', 'min', 'max', 'size', 'median']\n}\n\ngrouped = new_merchant_transactions.groupby('card_id').agg(aggregations)\ngrouped.columns = grouped.columns.droplevel(level=0)\ngrouped.rename(columns={\n    \"sum\": \"sum_purchase_amount\", \n    \"mean\": \"mean_purchase_amount\",\n    \"std\": \"std_purchase_amount\", \n    \"min\": \"min_purchase_amount\",\n    \"max\": \"max_purchase_amount\", \n    \"size\": \"num_purchase_amount\",\n    \"median\": \"median_purchase_amount\"\n}, inplace=True)\ngrouped.reset_index(inplace=True)\n\ntrain = pd.merge(train, grouped, on=\"card_id\", how=\"left\")\ntest = pd.merge(test, grouped, on=\"card_id\", how=\"left\")\n\ndel grouped\ngc.collect()","8e59f023":"train.head()","7f3f9db8":"train.shape, test.shape","1dbe242f":"# One-hot encode features\nohe_df_1 = pd.get_dummies(train['feature_1'], prefix='f1_')\nohe_df_2 = pd.get_dummies(train['feature_2'], prefix='f2_')\nohe_df_3 = pd.get_dummies(train['feature_3'], prefix='f3_')\n\nohe_df_4 = pd.get_dummies(test['feature_1'], prefix='f1_')\nohe_df_5 = pd.get_dummies(test['feature_2'], prefix='f2_')\nohe_df_6 = pd.get_dummies(test['feature_3'], prefix='f3_')\n\n# Numerical representation of the first active month\ntrain = pd.concat([train, ohe_df_1, ohe_df_2, ohe_df_3], axis=1, sort=False)\ntest = pd.concat([test, ohe_df_4, ohe_df_5, ohe_df_6], axis=1, sort=False)\n\ndel ohe_df_1, ohe_df_2, ohe_df_3\ndel ohe_df_4, ohe_df_5, ohe_df_6\ngc.collect()","21f2899c":"train.shape, test.shape","d643323a":"excluded_features = ['first_active_month', 'card_id', 'target', 'date']\ntrain_features = [c for c in train.columns if c not in excluded_features]","ae82dc95":"for f in train_features:\n    print(f)","0d54df11":"train.isnull().sum()","a8d4f241":"for col in train_features:\n    for df in [train, test]:\n        if df[col].dtype == \"float64\":\n            df[col] = df[col].fillna(df[col].mean())","60feee42":"# Prepare data for training\nX = train.copy()\ny = X['target']\n\n# Split data with kfold\nkfolds = KFold(n_splits=5, shuffle=True, random_state=2018)\n\n# Make importance dataframe\nimportances = pd.DataFrame()\n\noof_preds = np.zeros(X.shape[0])\nsub_preds = np.zeros(test.shape[0])\n\nfor n_fold, (trn_idx, val_idx) in enumerate(kfolds.split(X, y)):\n    X_train, y_train = X[train_features].iloc[trn_idx], y.iloc[trn_idx]\n    X_valid, y_valid = X[train_features].iloc[val_idx], y.iloc[val_idx]\n    \n    # LightGBM Regressor estimator\n    model = lgb.LGBMRegressor(\n        num_leaves = 31,\n        learning_rate = 0.03,\n        n_estimators = 1000,\n        subsample = .9,\n        colsample_bytree = .9,\n        random_state = 100,\n        booster = \"gbtree\",\n        eval_metric = \"rmse\",\n        nthread = 4,\n        nrounds = 1500,\n        max_depth = 7\n    )\n    \n    # Fit\n    model.fit(\n        X_train, y_train,\n        eval_set=[(X_train, y_train), (X_valid, y_valid)],\n        verbose=None, eval_metric='rmse',\n        early_stopping_rounds=100\n    )\n    \n    # Feature importance\n    imp_df = pd.DataFrame()\n    imp_df['feature'] = train_features\n    imp_df['gain'] = model.booster_.feature_importance(importance_type='gain')\n    imp_df['fold'] = n_fold + 1\n    importances = pd.concat([importances, imp_df], axis=0, sort=False)\n    \n    oof_preds[val_idx] = model.predict(X_valid, num_iteration=model.best_iteration_)\n    test_preds = model.predict(test[train_features], num_iteration=model.best_iteration_)\n    sub_preds += test_preds \/ kfolds.n_splits\n    \nmean_squared_error(y, oof_preds) ** .5","9c027b78":"importances['gain_log'] = importances['gain']\nmean_gain = importances[['gain', 'feature']].groupby('feature').mean()\nimportances['mean_gain'] = importances['feature'].map(mean_gain['gain'])\n\nplt.figure(figsize=(8, 12))\nsns.barplot(x='gain_log', y='feature', data=importances.sort_values('mean_gain', ascending=False))","0516b982":"sub_preds","42886227":"# Length of submission\nlen(sub_preds)","65653061":"# Make submission\nsample_submission['target'] = sub_preds\nsample_submission.to_csv(\"submission.csv\", index=False)\nsample_submission.head()","2890f4e7":"# Make submission","73de1d71":"**Merge train and test with historical transactions**","5a600a34":"--> Still missing values. So need to fill NA again","68c15848":"# Load packages","7eab5a8f":"# Load datasets","3e91691a":"# Preprocessing","a1e9a710":"# Display feature importances","45f11b7d":"**Merge train and test with new_merchant_transactions**","a290b6e3":"# Modeling with LightGBM","3e2ad4e8":"# Featuring"}}