{"cell_type":{"39160092":"code","a7c4cac6":"code","af9565c6":"code","ec79be6e":"code","605aac1d":"code","41d6c7ff":"code","a06bbd10":"code","7abd4c9e":"code","c367ff5c":"code","ad46cc01":"markdown","1ec32d41":"markdown"},"source":{"39160092":"import multiprocessing as mp\nfrom typing import Tuple\n\nimport numpy as np\nimport pandas as pd\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset, DataLoader, random_split\nfrom tqdm.auto import tqdm","a7c4cac6":"TRAIN_FILES = \"\/kaggle\/input\/digit-recognizer\/train.csv\"\nTRAIN_LEN = 0.8\nIMAGE_SIZE = (28, 28)\nBATCH_SIZE = 64\nEPOCHS = 10\nLEARNING_RATE = 1e-4","af9565c6":"class MNISTData(Dataset):\n    def __init__(self, path: str):\n        df = pd.read_csv(path)\n        self.x = df.iloc[:, 1:].values \/ 255.0\n        self.y = df.iloc[:, 0].values \/ 10.0 - 0.5\n        \n    def __len__(self):\n        return len(self.y)\n    \n    def __getitem__(self, i: int) -> Tuple[np.array, np.array]:\n        return self.x[i], self.y[i]","ec79be6e":"mnist = MNISTData(TRAIN_FILES)\ntrain_len = int(len(mnist) * TRAIN_LEN)\nvalid_len = len(mnist) - train_len\ntrain_ds, valid_ds = random_split(mnist, [train_len, valid_len])\n\ntrain_dl = DataLoader(\n    train_ds,\n    BATCH_SIZE,\n    num_workers=mp.cpu_count(),\n    shuffle=True,\n    drop_last=True,\n)\n\nvalid_dl = DataLoader(\n    valid_ds,\n    BATCH_SIZE,\n    num_workers=mp.cpu_count(),\n    shuffle=False,\n    drop_last=False,\n)","605aac1d":"x, y = next(iter(train_dl))\nx.shape, y.shape, x.dtype, y.dtype","41d6c7ff":"class Model(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = nn.Linear(784, 100)\n        self.linear2 = nn.Linear(100, 1)\n        self.bn1 = nn.BatchNorm1d(100)\n        \n    def forward(self, x: torch.FloatTensor) -> torch.FloatTensor:\n        breakpoint()\n        x = self.bn1(nn.ReLU()(self.linear1(x)))\n        return self.linear2(x)","a06bbd10":"model = Model()\nloss_fn = nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), LEARNING_RATE)\nfor _ in range(EPOCHS):\n    pbar = tqdm(train_dl)\n    for x, y in pbar:\n        y_pred = model(x.float())\n        loss = loss_fn(y_pred.squeeze(), y.float().squeeze())\n        loss.backward()\n        optimizer.step()\n        optimizer.zero_grad()\n        pbar.set_description(f\"Loss is {loss.item():.4f}\")\n#         print(f\"\\r\", end=\"\")","7abd4c9e":"y_preds = []\nys = []\nmodel = model.eval()\nwith torch.inference_mode():\n    for x, y in tqdm(valid_dl):\n        y_preds.extend(model(x.float()))\n        ys.extend(y.float())\n        \ny_preds = 10.0 * (torch.stack(y_preds) + 0.5)\nys = 10.0 * (torch.stack(ys) + 0.5)","c367ff5c":"(y_preds.round().squeeze() == ys).float().mean()","ad46cc01":"## Model","1ec32d41":"## Data"}}