{"cell_type":{"fd7abfcb":"code","97973fb9":"code","bd6737f5":"code","be7e85d4":"code","73ef30a8":"code","756f894e":"code","c363fff8":"code","c351aed7":"markdown","ad847e9f":"markdown","226099e9":"markdown","1794b29e":"markdown","59ad43cd":"markdown","005fdda2":"markdown","b79ec6c4":"markdown"},"source":{"fd7abfcb":"import numpy as np\nimport pandas as pd \nimport cv2\nimport os\nimport matplotlib.pyplot as plt\nfrom PIL import Image, ImageOps\nimport albumentations","97973fb9":"work_path = \"..\/input\/ranzcr-clip-catheter-line-classification\/\"\ndf = pd.read_csv(work_path+'train.csv')\nfile_names = df['StudyInstanceUID'].values","bd6737f5":"class ImageContraster():\n    def __init__(self):\n        pass\n    \n    def enhance_contrast(self, img, method = \"HE\", level = 256, window_size = 32, affect_size = 16, blocks = 8, threshold = 10.0):\n        ### equalize the histogram\n        ### @params img : Image type\n        ### @params method : Histogram Equalization Method\n        ### @params level : color or gray scale\n        ### @params window_size : in AHE, the window to calculate Histogram CDF size\n        ### @params affect_size : in AHE, the affected pixels size\n        ### @params blocks : in CLAHE, split how many times in row and col\n        ### @params threshold : in CLAHE, if threshold times higher then the mean value, clip \n        ### @return img_res : equalized result\n        \n        # choose algorithms\n        if method in [\"HE\", \"FHE\", \"he\", \"fhe\"]:\n            he_func = self.histogram_equalization     # HE\n        elif method in [\"AHE\", \"ahe\"]:\n            he_func = self.adaptive_histequal         # AHE\n        elif method in [\"CLAHE\", \"clahe\"]:\n            he_func = self.contrast_limited_ahe       # CLAHE\n        elif method in [\"standard\", \"STANDARD\", \"Standard\"]:\n            he_func = self.standard_histogram_equalization   # ImageOps HE\n        elif method in [\"Bright\", \"bright\", \"bright_level\"]: \n            he_func = self.bright_wise_histequal      # Local Region Stretch\n        \n        # process gray and color images\n        img_arr = np.array(img)\n        if len(img_arr.shape) == 2:\n            channel_num = 1\n        elif len(img_arr.shape) == 3:\n            channel_num = img_arr.shape[2]\n        \n        if channel_num == 1:\n            # gray image\n            arr = he_func(img_arr, level = level, window_size = window_size, affect_size = affect_size, blocks = blocks, threshold = threshold)\n            img_res = Image.fromarray(arr)\n        elif channel_num == 3 or channel_num == 4:\n            # RGB image or RGBA image(such as png)\n            rgb_arr = [None] * 3\n            rgb_img = [None] * 3\n            # process dividely\n            for k in range(3):\n                rgb_arr[k] = he_func(img_arr[:,:,k], level = level, window_size = window_size, affect_size = affect_size, blocks = blocks, threshold = threshold)\n                rgb_img[k] = Image.fromarray(rgb_arr[k])\n            img_res = Image.merge(\"RGB\", tuple(rgb_img))\n        \n        return img_res\n    \n    def histogram_equalization(self, img_arr, level = 256, **args):\n        ### equalize the distribution of histogram to enhance contrast\n        ### @params img_arr : numpy.array uint8 type, 2-dim\n        ### @params level : the level of gray scale\n        ### @return arr : the equalized image array\n        \n        # calculate hists\n        hists = self.calc_histogram_(img_arr, level)\n        \n        # equalization\n        (m, n) = img_arr.shape\n        hists_cdf = self.calc_histogram_cdf_(hists, m, n, level)  # calculate CDF\n        \n        arr = np.zeros_like(img_arr)\n        arr = hists_cdf[img_arr]        # mapping\n        \n        return arr\n    \n    def adaptive_histequal(self, img_arr, level = 256, window_size = 32, affect_size = 16, **args):\n        ### using AHE to enhance contrast\n        ### @params img_arr : numpy.array uint8 type, 2-dim\n        ### @params level : the level of gray scale\n        ### @params window_size : calculate the histogram mapping function in a window of (window_size, window_size)\n        ### @params affect_size : the real affected pixels by a mapping function\n        ### @return arr : the equalized image array\n        arr = img_arr.copy()\n        \n        # calculate how many blocks needed in row-axis and col-axis\n        (m, n) = img_arr.shape\n        if (m - window_size) % affect_size == 0:\n            rows = int((m - window_size)\/affect_size + 1)\n        else:\n            rows = int((m - window_size)\/affect_size + 2)\n        if (n - window_size) % affect_size == 0:\n            cols = int((n - window_size)\/affect_size + 1)\n        else:\n            cols = int((n - window_size)\/affect_size + 2)\n        \n        # equalize histogram of every block image\n        for i in range(rows):\n            for j in range(cols):\n                # offset\n                off = int((window_size - affect_size) \/ 2)\n                \n                # affect region border\n                asi, aei = i * affect_size + off, (i + 1) * affect_size + off\n                asj, aej = j * affect_size + off, (j + 1) * affect_size + off\n                \n                # window region border\n                wsi, wei = i * affect_size, i * affect_size + window_size\n                wsj, wej = j * affect_size, j * affect_size + window_size\n                \n                # equalize the window region\n                window_arr = img_arr[wsi : wei, wsj : wej]\n                block_arr = self.histogram_equalization(window_arr, level)\n                \n                # border case\n                if i == 0:\n                    arr[wsi : asi, wsj : wej] = block_arr[0 : asi - wsi, :]\n                elif i >= rows - 1:\n                    arr[aei : wei, wsj : wej] = block_arr[aei - wsi : wei - wsi, :]\n                if j == 0:\n                    arr[wsi : wei, wsj : asj] = block_arr[:, 0 : asj - wsj]\n                elif j >= cols - 1:\n                    arr[wsi : wei, aej : wej] = block_arr[: , aej - wsj : wej - wsj]\n                arr[asi : aei, asj : aej] = block_arr[asi - wsi : aei - wsi, asj - wsj : aej - wsj]\n                \n        return arr\n    \n    def contrast_limited_ahe(self, img_arr, level = 256, blocks = 8, threshold = 10.0, **args):\n        ### equalize the distribution of histogram to enhance contrast, using CLAHE\n        ### @params img_arr : numpy.array uint8 type, 2-dim\n        ### @params level : the level of gray scale\n        ### @params window_size : the window used to calculate CDF mapping function\n        ### @params threshold : clip histogram by exceeding the threshold times of the mean value\n        ### @return arr : the equalized image array\n        (m, n) = img_arr.shape\n        block_m = int(m \/ blocks)\n        block_n = int(n \/ blocks)\n        \n        # split small regions and calculate the CDF for each, save to a 2-dim list\n        maps = []\n        for i in range(blocks):\n            row_maps = []\n            for j in range(blocks):\n                # block border\n                si, ei = i * block_m, (i + 1) * block_m\n                sj, ej = j * block_n, (j + 1) * block_n\n                \n                # block image array\n                block_img_arr = img_arr[si : ei, sj : ej]\n                \n                # calculate histogram and cdf\n                hists = self.calc_histogram_(block_img_arr)\n                clip_hists = self.clip_histogram_(hists, threshold = threshold)     # clip histogram\n                hists_cdf = self.calc_histogram_cdf_(clip_hists, block_m, block_n, level)\n                \n                # save\n                row_maps.append(hists_cdf)\n            maps.append(row_maps)\n        \n        # interpolate every pixel using four nearest mapping functions\n        # pay attention to border case\n        arr = img_arr.copy()\n        for i in range(m):\n            for j in range(n):\n                r = int((i - block_m \/ 2) \/ block_m)      # the row index of the left-up mapping function\n                c = int((j - block_n \/ 2) \/ block_n)      # the col index of the left-up mapping function\n                \n                x1 = (i - (r + 0.5) * block_m) \/ block_m  # the x-axis distance to the left-up mapping center\n                y1 = (j - (c + 0.5) * block_n) \/ block_n  # the y-axis distance to the left-up mapping center\n                \n                lu = 0    # mapping value of the left up cdf\n                lb = 0    # left bottom\n                ru = 0    # right up\n                rb = 0    # right bottom\n                \n                # four corners use the nearest mapping directly\n                if r < 0 and c < 0:\n                    arr[i][j] = maps[r + 1][c + 1][img_arr[i][j]]\n                elif r < 0 and c >= blocks - 1:\n                    arr[i][j] = maps[r + 1][c][img_arr[i][j]]\n                elif r >= blocks - 1 and c < 0:\n                    arr[i][j] = maps[r][c + 1][img_arr[i][j]]\n                elif r >= blocks - 1 and c >= blocks - 1:\n                    arr[i][j] = maps[r][c][img_arr[i][j]]\n                # four border case using the nearest two mapping : linear interpolate\n                elif r < 0 or r >= blocks - 1:\n                    if r < 0:\n                        r = 0\n                    elif r > blocks - 1:\n                        r = blocks - 1\n                    left = maps[r][c][img_arr[i][j]]\n                    right = maps[r][c + 1][img_arr[i][j]]\n                    arr[i][j] = (1 - y1) * left + y1 * right\n                elif c < 0 or c >= blocks - 1:\n                    if c < 0:\n                        c = 0\n                    elif c > blocks - 1:\n                        c = blocks - 1\n                    up = maps[r][c][img_arr[i][j]]\n                    bottom = maps[r + 1][c][img_arr[i][j]]\n                    arr[i][j] = (1 - x1) * up + x1 * bottom\n                # bilinear interpolate for inner pixels\n                else:\n                    lu = maps[r][c][img_arr[i][j]]\n                    lb = maps[r + 1][c][img_arr[i][j]]\n                    ru = maps[r][c + 1][img_arr[i][j]]\n                    rb = maps[r + 1][c + 1][img_arr[i][j]]\n                    arr[i][j] = (1 - y1) * ( (1 - x1) * lu + x1 * lb) + y1 * ( (1 - x1) * ru + x1 * rb)\n        arr = arr.astype(\"uint8\")\n        return arr\n    \n    def bright_wise_histequal(self, img_arr, level = 256, **args):\n        ### split the image to three level accoding brightness, equalize histogram dividely\n        ### @params img_arr : numpy.array uint8 type, 2-dim\n        ### @params level : gray scale\n        ### @return arr : the equalized image array\n        def special_histogram(img_arr, min_v, max_v):\n            ### calculate a special histogram with max, min value\n            ### @params img_arr : 1-dim numpy.array\n            ### @params min_v : min gray scale\n            ### @params max_v : max gray scale\n            ### @return hists : list type, length = max_v - min_v + 1\n            hists = [0 for _ in range(max_v - min_v + 1)]\n            for v in img_arr:\n                hists[v - min_v] += 1\n            return hists\n        def special_histogram_cdf(hists, min_v, max_v):\n            ### calculate a special histogram cdf with max, min value\n            ### @params hists : list type\n            ### @params min_v : min gray scale\n            ### @params max_v : max gray scale\n            ### @return hists_cdf : numpy.array\n            hists_cumsum = np.cumsum(np.array(hists))\n            hists_cdf = (max_v - min_v) \/ hists_cumsum[-1] * hists_cumsum + min_v\n            hists_cdf = hists_cdf.astype(\"uint8\")\n            return hists_cdf\n        def pseudo_variance(arr):\n            ### caluculate a type of variance\n            ### @params arr : 1-dim numpy.array\n            arr_abs = np.abs(arr - np.mean(arr))\n            return np.mean(arr_abs)\n            \n        # search two grayscale level, which can split the image into three parts having approximately same number of pixels\n        (m, n) = img_arr.shape\n        hists = self.calc_histogram_(img_arr)\n        hists_arr = np.cumsum(np.array(hists))\n        hists_ratio = hists_arr \/ hists_arr[-1]\n        \n        scale1 = None\n        scale2 = None\n        for i in range(len(hists_ratio)):\n            if hists_ratio[i] >= 0.333 and scale1 == None:\n                scale1 = i\n            if hists_ratio[i] >= 0.667 and scale2 == None:\n                scale2 = i\n                break\n        \n        # split images\n        dark_index = (img_arr <= scale1)\n        mid_index = (img_arr > scale1) & (img_arr <= scale2)\n        bright_index = (img_arr > scale2)\n        \n        # variance\n        dark_variance = pseudo_variance(img_arr[dark_index])\n        mid_variance = pseudo_variance(img_arr[mid_index])\n        bright_variance = pseudo_variance(img_arr[bright_index])\n        \n        # build three level images\n        dark_img_arr = np.zeros_like(img_arr)\n        mid_img_arr = np.zeros_like(img_arr)\n        bright_img_arr = np.zeros_like(img_arr)\n        \n        # histogram equalization individually\n        dark_hists = special_histogram(img_arr[dark_index], 0, scale1)\n        dark_cdf = special_histogram_cdf(dark_hists, 0, scale1)\n        \n        mid_hists = special_histogram(img_arr[mid_index], scale1, scale2)\n        mid_cdf = special_histogram_cdf(mid_hists, scale1, scale2)\n        \n        bright_hists = special_histogram(img_arr[bright_index], scale2, level - 1)\n        bright_cdf = special_histogram_cdf(bright_hists, scale2, level - 1)\n        \n        \n        def plot_hists(arr):\n            hists = [0 for i in range(256)]\n            for a in arr:\n                hists[a] += 1\n            self.draw_histogram_(hists)\n        \n        # mapping\n        dark_img_arr[dark_index] = dark_cdf[img_arr[dark_index]]\n        mid_img_arr[mid_index] = mid_cdf[img_arr[mid_index] - scale1]\n        bright_img_arr[bright_index] = bright_cdf[img_arr[bright_index] - scale2]\n        \n        # weighted sum\n        #fractor = dark_variance + mid_variance + bright_variance\n        #arr = (dark_variance * dark_img_arr + mid_variance * mid_img_arr + bright_variance * bright_img_arr)\/fractor\n        arr = dark_img_arr + mid_img_arr + bright_img_arr\n        arr = arr.astype(\"uint8\")\n        return arr\n    \n    def standard_histogram_equalization(self, img_arr, level = 256, **args):\n        ### equalize the distribution of histogram to enhance contrast, using PIL.ImageOps\n        ### @params img_arr : numpy.array uint8 type, 2-dim\n        ### @params level : the level of gray scale\n        ### @return arr : the equalized image array\n        \n        # ImageOps.equalize\n        img = Image.fromarray(img_arr)\n        img_res = ImageOps.equalize(img)\n        arr = np.array(img_res)\n        return arr\n    \n    def calc_histogram_(self, gray_arr, level = 256):\n        ### calculate the histogram of a gray scale image\n        ### @params gray_arr : numpy.array uint8 type, 2-dim\n        ### @params level : the level of gray scale\n        ### @return hists : list type\n        hists = [0 for _ in range(level)]\n        for row in gray_arr:\n            for p in row:\n                hists[p] += 1\n        return hists\n    \n    def calc_histogram_cdf_(self, hists, block_m, block_n, level = 256):\n        ### calculate the CDF of the hists\n        ### @params hists : list type\n        ### @params block_m : the histogram block's height\n        ### @params block_n : the histogram block's width\n        ### @params level : the level of gray scale\n        ### @return hists_cdf : numpy.array type\n        hists_cumsum = np.cumsum(np.array(hists))\n        const_a = (level - 1) \/ (block_m * block_n)\n        hists_cdf = (const_a * hists_cumsum).astype(\"uint8\")\n        return hists_cdf\n    \n    def clip_histogram_(self, hists, threshold = 10.0):\n        ### clip the peak of histogram, and separate it to all levels uniformly\n        ### @params hists : list type\n        ### @params threshold : the top ratio of hists over mean value\n        ### @return clip_hists : list type\n        all_sum = sum(hists)\n        threshold_value = all_sum \/ len(hists) * threshold\n        total_extra = sum([h - threshold_value for h in hists if h >= threshold_value])\n        mean_extra = total_extra \/ len(hists)\n        \n        clip_hists = [0 for _ in hists]\n        for i in range(len(hists)):\n            if hists[i] >= threshold_value:\n                clip_hists[i] = int(threshold_value + mean_extra)\n            else:\n                clip_hists[i] = int(hists[i] + mean_extra)\n        \n        return clip_hists\n    \n    def draw_histogram_(self, hists):\n        ### draw a bar picture of the given histogram\n        plt.figure()\n        plt.bar(range(len(hists)), hists)\n        plt.show()\n    \n    def plot_images(self, img1, img2):\n        ### draw two images\n        ### @params img1 : Image type\n        ### @params img2 : Image type\n        plt.figure()\n        plt.subplot(121)\n        plt.imshow(img1)\n        plt.subplot(122)\n        plt.imshow(img2)\n        plt.show()\n\nicter = ImageContraster()","be7e85d4":"for i in range(3):\n    path = os.path.join(work_path,\"train\",file_names[i]+\".jpg\")\n    img = cv2.imread(path)\n    img  = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = Image.fromarray(img)\n    he_eq_img = icter.enhance_contrast(img, method = \"HE\")\n    icter.plot_images(img, he_eq_img)","73ef30a8":"for i in range(3):\n    path = os.path.join(work_path,\"train\",file_names[i]+\".jpg\")\n    img = cv2.imread(path)\n    img  = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = Image.fromarray(img)\n    ahe_eq_img = icter.enhance_contrast(img, method = \"AHE\", window_size = 200, affect_size = 50)\n    icter.plot_images(img, ahe_eq_img)","756f894e":"for i in range(3):\n    path = os.path.join(work_path,\"train\",file_names[i]+\".jpg\")\n    img = cv2.imread(path)\n    img  = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img = Image.fromarray(img)\n    clahe_eq_img = icter.enhance_contrast(img, method = \"CLAHE\", blocks = 9, threshold = 10.0)\n    icter.plot_images(img, clahe_eq_img)","c363fff8":"aug = albumentations.CLAHE(clip_limit=(1,4), p=1)\nfor i in range(3):\n    path = os.path.join(work_path,\"train\",file_names[i]+\".jpg\")\n    img = cv2.imread(path)\n    img  = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    clahe = aug(image = img)[\"image\"]\n    icter.plot_images(img, clahe)","c351aed7":"# **Loading data**","ad847e9f":"![fig1.JPG](attachment:fig1.JPG)","226099e9":"# CLAHE in Albumentations","1794b29e":"#  AHE\uff1aAdaptive Histogram Equalization\n\n#  Divided  original image into sub regions, and each sub region using Histogram Equalization","59ad43cd":"If the histogram pixels of an image are distributed in a very narrow range, then under normal circumstances, the effect of the image will be very bad. The direct impression is that the dynamic range is small and the contrast is poor; on the contrary, if the histogram is evenly extended to In the entire distribution area, the contrast of the image will be very strong.\n\n\n\nThe \"central idea\" of the histogram equalization processing is to change the grayscale histogram of the original image from a relatively concentrated grayscale interval to a uniform distribution in the entire grayscale range. Histogram equalization is to stretch the image non-linearly and redistribute the image pixel values \u200b\u200bso that the number of pixels within a certain grayscale range is approximately the same. The histogram equalization finally changes the histogram distribution of a given image into a \"uniform\" histogram distribution.","005fdda2":"# CLAHE:Contrast Limited Adaptive Histogram Equalization","b79ec6c4":"# HE\uff1aHistogram Equalization \n# Adjust the brightness distribution of pixels to ensure that the histogram has the maximum dynamic range,, make the gray histogram a rectangle as much as possible"}}