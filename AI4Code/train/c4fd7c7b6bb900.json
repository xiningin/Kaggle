{"cell_type":{"1abc769c":"code","2dae4437":"code","c2dd5365":"code","e45766f2":"code","dfc887c3":"code","119d12e0":"code","ba789fdb":"code","faac7850":"code","106ea77e":"code","26eea6a1":"code","0bd585d8":"code","13a06133":"code","f2aa47ed":"markdown","a9beb4d5":"markdown","e8b50f6f":"markdown","b8edbbb3":"markdown","fbcbe456":"markdown","b8ef40a6":"markdown","24b92226":"markdown","1ddd8f10":"markdown","dfa40793":"markdown","3dc3a09b":"markdown","819044ef":"markdown"},"source":{"1abc769c":"import os\nimport cv2\nimport numpy as np\nfrom skimage import feature\nimport random\nimport matplotlib.pyplot as plt\n%matplotlib inline","2dae4437":"def quantify_image(image):\n    features = feature.hog(image, orientations=9,\n                           pixels_per_cell=(10, 10), cells_per_block=(2, 2),\n                           transform_sqrt=True, block_norm=\"L1\")\n    return features","c2dd5365":"def load_split(path):\n    # grab the list of images in the input directory, then initialize\n    # the list of data (i.e., images) and class labels\n    imagePaths = list(paths.list_images(path))\n    data = []\n    labels = []\n    # loop over the image paths\n    for imagePath in imagePaths:\n        # extract the class label from the filename\n        label = imagePath.split(os.path.sep)[-2]\n        # load the input image, convert it to grayscale, and resize\n        # it to 200x200 pixels, ignoring aspect ratio\n        image = cv2.imread(imagePath)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        image = cv2.resize(image, (200, 200))\n        # threshold the image such that the drawing appears as white\n        # on a black background\n        image = cv2.threshold(image, 0, 255,\n                              cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]\n        # quantify the image\n        features = quantify_image(image)\n        # update the data and labels lists, respectively\n        data.append(features)\n        labels.append(label)\n    return (np.array(data), np.array(labels))","e45766f2":"!pip install imutils\nfrom imutils import paths\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.ensemble import RandomForestClassifier\nfrom xgboost import XGBClassifier\nfrom sklearn.metrics import confusion_matrix","dfc887c3":"def train_models(dataset):\n    # initialize the models\n    models = {\n        \"Rf\": {\n            \"classifier\": RandomForestClassifier(random_state=1),\n            \"accuracy\": 0,\n            \"sensitivity\": 0,\n            \"specificity\": 0,\n        },\n        \"Xgb\": {\n            \"classifier\": XGBClassifier(),\n            \"accuracy\": 0,\n            \"sensitivity\": 0,\n            \"specificity\": 0,\n        }\n    }\n    # define the path to the testing and training directories\n    path = \"..\/input\/parkinsons-drawings\/\" + dataset\n    trainingPath = os.path.sep.join([path, \"training\"])\n    testingPath = os.path.sep.join([path, \"testing\"])\n    # load the data\n    (trainX, trainY) = load_split(trainingPath)\n    (testX, testY) = load_split(testingPath)\n    # encode the labels\n    le = LabelEncoder()\n    trainY = le.fit_transform(trainY)\n    testY = le.transform(testY)\n\n    # train each model and calculate its metrics\n    for model in models:\n        models[model][\"classifier\"].fit(trainX, trainY)\n        predictions = models[model][\"classifier\"].predict(testX)\n        cm = confusion_matrix(testY, predictions).ravel()\n        tn, fp, fn, tp = cm\n        models[model][\"accuracy\"] = (tp + tn) \/ float(cm.sum())\n        models[model][\"sensitivity\"] = tp \/ float(tp + fn)\n        models[model][\"specificity\"] = tn \/ float(tn + fp)\n\n    return models","119d12e0":"# Train the models on the spiral drawings\nspiralModels = train_models('spiral')","ba789fdb":"# train the model on the wave-form drawings\nwaveModels = train_models('wave')","faac7850":"print(\"Random Forrest vs XGBoost Classifier\\n\\n\")\nfor metric in (\"accuracy\", \"sensitivity\", \"specificity\"):\n    print(f\"{metric.capitalize()}: \")\n    print(\"Random Forrest={:.2f}%, XGBoost={:.2f}% \\n\".format(\n        spiralModels['Rf'][metric]*100, spiralModels['Xgb'][metric]*100))","106ea77e":"print(\"Random Forrest vs XGBoost Classifier\\n\\n\")\nfor metric in (\"accuracy\", \"sensitivity\", \"specificity\"):\n    print(f\"{metric.capitalize()}: \")\n    print(\"Random Forrest={:.2f}%, XGBoost={:.2f}% \\n\".format(\n        waveModels['Rf'][metric]*100, waveModels['Xgb'][metric]*100))","26eea6a1":"def test_prediction(model, testingPath):\n    # get the list of images\n    testingPaths = list(paths.list_images(testingPath))\n    output_images = []\n    # pick 15 images at random\n    for _ in range(15):\n        image = cv2.imread(random.choice(testingPaths))\n        output = image.copy()\n        output = cv2.resize(output, (128, 128))\n        # pre-process the image\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        image = cv2.resize(image, (200, 200))\n        image = cv2.threshold(image, 0, 255,\n                              cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]\n        # quantify the image and make predictions based on the extracted features\n        features = quantify_image(image)\n        preds = model.predict([features])\n        label = \"Parkinsons\" if preds[0] else \"Healthy\"\n\n        # draw the colored class label on the output image and add it to\n        # the set of output images\n        color = (0, 255, 0) if label == \"Healthy\" else (0, 0, 255)\n        cv2.putText(output, label, (3, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5,\n                    color, 2)\n        output_images.append(output)\n    plt.figure(figsize=(20, 20))\n    for i in range(len(output_images)):\n        plt.subplot(5, 5, i+1)\n        plt.imshow(output_images[i])\n        plt.axis(\"off\")\n    plt.show()","0bd585d8":"testingPath = os.path.sep.join([\"..\/input\/parkinsons-drawings\/spiral\", \"testing\"])\ntest_prediction(spiralModels['Rf']['classifier'], testingPath)","13a06133":"testingPath = os.path.sep.join([\"..\/input\/parkinsons-drawings\/wave\", \"testing\"])\ntest_prediction(waveModels['Rf']['classifier'], testingPath)","f2aa47ed":"# **Training the Models**","a9beb4d5":"# **Models Performance**","e8b50f6f":"**Spiral Drawings**","b8edbbb3":"**Wave Drawings**","fbcbe456":"**Wave Images**","b8ef40a6":"**Quantify the image using a HOG Descriptor**\n\nHOG is a structural descriptor that will capture and quantify changes in local gradient in the input image. HOG will naturally be able to quantify how the directions of a both spirals and waves change. And furthermore, HOG will be able to capture if these drawings have more of a \u201cshake\u201d to them, as we might expect from a Parkinson\u2019s patient.\n\nThe resultant feature vector will then be used to train the classifier","24b92226":"**Spiral images**","1ddd8f10":"# **Introduction**\n\nWhat is Parkinson's Disease?\n\nParkinson's disease (PD), or simply Parkinson's is a long-term degenerative disorder of the central nervous system that mainly affects the motor system. The symptoms usually emerge slowly and, as the disease worsens, non-motor symptoms become more common. The most obvious early symptoms are tremor, rigidity, slowness of movement, and difficulty with walking,but cognitive and behavioral problems may also occur. Parkinson's disease dementia becomes common in the advanced stages of the disease. Depression and anxiety are also common, occurring in more than a third of people with PD. Other symptoms include sensory, sleep, and emotional problems. The main motor symptoms are collectively called \"parkinsonism\", or a \"parkinsonian syndrome\n\n![](https:\/\/camo.githubusercontent.com\/be21545deabab1e7257c04182b631f6f34ebae4b\/68747470733a2f2f7061726b696e736f6e736e65627261736b612e6f72672f77702d636f6e74656e742f75706c6f6164732f323032302f30332f50442d4d414e2d31303234783532322e706e67)\n\nWhile Parkinson\u2019s disease cannot be cured, early detection along with proper medication can significantly improve symptoms and quality of life, making it an important topic for research especially in the creation of new diagnostic tools.\n\nA 2017 study by Zham et al. found that it was possible to detect Parkinson\u2019s by asking the patient to draw a spiral and then track:\n\n 1. Speed of drawing\n 2. Pen pressure\n\nThe researchers found that the drawing speed was slower and the pen pressure lower among Parkinson\u2019s patients \u2014 this was especially pronounced for patients with a more acute\/advanced forms of the disease.\n\nWe\u2019ll be leveraging the fact that two of the most common Parkinson\u2019s symptoms include tremors and muscle rigidity which directly impact the visual appearance of a hand drawn spiral and wave.\n\nThe variation in visual appearance will enable us to train a computer vision + machine learning algorithm to automatically detect Parkinson\u2019s disease.\n","dfa40793":"# **Load the data and extract the features**","3dc3a09b":"# **Dataset Description**\n\nThe dataset we\u2019ll be using here today was curated by Adriano de Oliveira Andrade and Joao Paulo Folado from the NIATS of Federal University of Uberla\u0302ndia.\n\nThe dataset itself consists of images and is pre-split into a training set and a testing set, consisting of:\n\nSpiral: training, and testing\n\nWave: training, and testing\n\n![](https:\/\/camo.githubusercontent.com\/454ee9a31a3b087992584258f97b5b4a77d87dc7\/68747470733a2f2f7079696d6167657365617263682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30342f6465746563745f7061726b696e736f6e735f646174617365742e6a7067)\n\n**Approach**\n\nAlthough Deep learning with Convolutional Neural networks seems to be the best approach for this computer vision problem, we have a limited amount of training data and we cannot apply data augmentation as it will lead to a distortion of the results. With this in mind we will rather apply the Histogram of Oriented Gradients Image Descriptor with an ensemble method i.e., Random Forest Classifier and Xgboost","819044ef":"# **Testing On Sample Images and Visualize the predictions**"}}