{"cell_type":{"117c342b":"code","8192c783":"code","804fead6":"code","6c010c89":"code","9728814d":"code","ed6b98df":"code","374da4ca":"code","c7b8935a":"code","98e15294":"code","67f7c8e7":"code","dd56d2e1":"code","e47ffe23":"code","f58bc124":"code","498ee679":"code","05c67e92":"code","6c172d67":"code","6d77c85d":"code","d5fecf97":"code","7d39516c":"code","57c63bb5":"code","62dbbe4c":"code","34a3a47c":"code","49b028c2":"code","61272f19":"code","ff8bbfba":"code","4bcdc8cb":"code","30713b38":"code","f8e82e36":"code","37a61e5a":"code","33b6638f":"code","06dcff3e":"code","225d9886":"code","12f263e7":"code","34df95b7":"code","f889e852":"code","570fd474":"markdown","9796d480":"markdown","6dde5582":"markdown","37733514":"markdown","f856b62c":"markdown","d2540597":"markdown","8816f57f":"markdown","7e67d7a7":"markdown","adaa698d":"markdown","5d6514e0":"markdown","81d37363":"markdown","58669274":"markdown","f49925dd":"markdown","95181910":"markdown","499a1e9b":"markdown"},"source":{"117c342b":"%reset -sf","8192c783":"%%time\n# to make animation module work\n!apt-get -y install ffmpeg > \/dev\/null\n\nimport secrets  # python 3.6 necessary\nimport random\nimport numpy as np\nimport pandas as pd  # we try not to depend on pandas, to better translate later?\nfrom copy import deepcopy\nfrom IPython.display import display, HTML\nfrom tqdm import tqdm_notebook\nimport matplotlib\nmatplotlib.use('Agg')\nimport matplotlib.animation as animation\nimport matplotlib.colors as colors\nimport matplotlib.pyplot as plt  # for viz\nimport matplotlib.path as path  # for histogram\nimport matplotlib.patches as patches  # for histogram\nfrom sklearn.linear_model import LinearRegression\ndef displayer(df): display(HTML(df.head(2).to_html()))\n\npd.set_option('display.max_rows', 100)\npd.options.mode.chained_assignment = None","804fead6":"# city coefficients\nCITY_X, CITY_Y = 5.3,5.3\nAMENITIES_COEF = 500\nLOC_COEF = 500\nINITIAL_PRICE = lambda: 1\nINTIAL_AMENITIES = lambda: np.random.uniform() \n\n# individual perferences\nPREFERRED_LOCATION_X = lambda: 10*np.random.uniform()\nPREFERRED_LOCATION_Y = lambda: 10*np.random.uniform()\n\n# initialisation variables for people\nINITIAL_AGE = lambda: 20\nINITIAL_WEALTH = lambda: 100 + 100*np.random.uniform()\nINCOME = lambda: 10\nSTARTING_POPULATION = 10\n\n# random variable of number of people born per timeframe\nNUM_BORN = lambda: np.random.binomial(10, 0.2)\n\n# death probability function\nDYING_PROB_FUNCTION = lambda age: 1.\/(1.+np.exp(-(0.2*(age-50))))\n\n# individual preferences\nIDIO_COEF = 0.2\n\n# market transaction model variables\nPROBA_BUY = 0.8\nPROBA_SELL_NO_LOSS = 0.8 # update(weets, 191128)\nPROBA_SELL_WITH_LOSS = 0.4 # update(weets, 191128)\nMIN_TXN_VOL = 5 # update(weets, 191202)\n\n# current affairs # update(weets,191202)\nPROBA_CA_GOOD = 0.025\nPROBA_CA_BAD = 0.1\nFAIR_UB = 1.05\nFAIR_LB = 0.95\nCA_MULTIPLIER_FAIR = lambda: np.random.uniform(FAIR_LB,FAIR_UB)\nCA_MULTIPLIER_GOOD = lambda: np.random.uniform(FAIR_UB,1.20)\nCA_MULTIPLIER_BAD = lambda: np.random.uniform(0.75,FAIR_LB)\n\n# plotting variables\nNUM_FRAMES = 2000\nMILLISECS_PER_FRAME = 50","6c010c89":"# defining utility functions which forms the basis of housing valuation\ndef utility_general(house):\n    '''\n    Every person considers a house to have a certain utility.\n    This is not based on personal perferences.\n    '''\n    utility_due_to_location = 2\/(1 + (house[\"location\"][0] - CITY_X)**2 \n                                   + (house[\"location\"][1] - CITY_Y)**2)\n\n    return utility_due_to_location + house[\"amenities\"] # UPDATE(weets, 191125)\n\ndef utility_function(person, house):\n    '''\n    A person considers each house to have a different utility.\n    This assigns an additional utility of each house based on personal preferences.\n    '''\n    \n    # UPDATE(weets, 191125) - made preferred_location a column var instead of nesting in idio dict\n    utility_due_to_person = 1\/(1 + (house[\"location\"][0] - person[\"preferred_location\"][0])**2 \n                                 + (house[\"location\"][1] - person[\"preferred_location\"][1])**2)\n    return utility_general(house) + utility_due_to_person\n\n### Weets' Vectorised Utility Functions (works with pd.Series) ###\n# mere translation of above functions\n# its quite hardcoded so not comfortable rofl\n\ndef utility_general_vectorised(house):\n    '''\n    Every person considers a house to have a certain utility.\n    This is not based on personal perferences.\n    '''\n    utility_due_to_location = 2\/(1 + (house[\"location\"].apply(lambda tup: tup[0]) - CITY_X)**2 \n                                   + (house[\"location\"].apply(lambda tup: tup[1]) - CITY_Y)**2)\n    \n    global AMENITIES_COEF\n    AMENITIES_COEF = AMENITIES_COEF\n    global LOC_COEF\n    LOC_COEF = LOC_COEF # UPDATE(weets, 191126)\n    return LOC_COEF*utility_due_to_location + AMENITIES_COEF*house[\"amenities\"] # UPDATE(weets, 191125)\n\ndef utility_function_vectorised(person, house):\n    '''\n    A person considers each house to have a different utility.\n    This assigns an additional utility of each house based on personal preferences.\n    Input\n        person: a dict or pandas df row\n    '''\n    \n    # UPDATE(weets, 191125) - made preferred_location_? a column var instead of nesting in idio dict\n    xloc = (house[\"location\"].apply(lambda tup: tup[0]) - person[\"preferred_location_x\"])\n    yloc = (house[\"location\"].apply(lambda tup: tup[1]) - person[\"preferred_location_y\"])\n    \n    utility_due_to_person = 1\/(1 + xloc**2 + yloc**2)\n    global IDIO_COEF\n    IDIO_COEF = IDIO_COEF # UPDATE(weets, 191126)\n    return utility_general_vectorised(house) + IDIO_COEF * utility_due_to_person","9728814d":"# defining a template person and generate persons\ndef generate_person():\n    person = {\n        \"age\": INITIAL_AGE(),\n        \"income\": INCOME(),\n        \"wealth\": INITIAL_WEALTH(),\n        \"house_staying\": np.NaN,\n        \"house_selling\": np.NaN,\n        \"utility\": 0, # WEETS: utility here is the utility of the current staying house to the person. It will be swapped for the utility of the new house if this person buys new house.\n        # the true 'score' of a person is wealth + utility\n        'preferred_location_x': PREFERRED_LOCATION_X(), # UPDATE(weets, 191125)\n        'preferred_location_y': PREFERRED_LOCATION_Y() # UPDATE(weets, 191125)\n    }\n    return person\n\npersons = None\n\ndef initialise_persons():\n    global STARTING_POPULATION, persons\n    persons = {}\n    for _ in range(STARTING_POPULATION):\n        persons[secrets.token_hex(4)] = generate_person()\n    persons = pd.DataFrame.from_dict(persons, orient='index')\n\ninitialise_persons()\n\npersons['house_staying'] = persons['house_staying'].astype(object)\npersons['house_selling'] = persons['house_selling'].astype(object)\n\npersons.head()","ed6b98df":"# defining a template house and generate houses\nhouses = None\ndef initialise_houses():\n    global houses\n    houses = {}\n    for x in range(10):\n        for y in range(10):\n            houses[(x,y)] = {\n                \"location\": (x,y),  # also the key \n                \"last_bought_price\": INITIAL_PRICE(),\n                \"status\": \"empty\",  # \"empty\", \"occupied\", \"selling\" \n                'amenities': INTIAL_AMENITIES(), # UPDATE(weets, 191125)\n                \"occupant\": np.NaN,\n                \"last_updated\": 0,\n                \"distance_to_city\":((x-CITY_X)**2+(y-CITY_Y)**2)**(0.5) # update(weets,191202) -- euclidean dist\n            }\n            houses[(x,y)][\"market_price\"] = houses[(x,y)][\"last_bought_price\"]\n\n    houses = pd.DataFrame.from_dict(houses, orient='index')\n    houses[\"utility_general\"] = utility_general_vectorised(houses)\n\ndef status_to_float(status):  # for visualisation\n    if status == \"empty\": return 0 \n    if status == \"occupied\": return 1 \n    if status == \"selling\": return 2\n    \ninitialise_houses()\nhouses.head()","374da4ca":"def aging(verbose = False): # change this a function of age\n    persons[\"age\"] += 1\n    persons[\"wealth\"] += persons[\"income\"]\n    houses[\"last_updated\"] += 1","c7b8935a":"plt.figure(figsize = (14,2))\nplt.plot([DYING_PROB_FUNCTION(age) for age in np.arange(100)])\nplt.title(\"death probability over age\")\nplt.show()","98e15294":"def dying(verbose = False): # change this a function of age\n    persons_id_dead = []\n    for person_id in persons.index:\n        if np.random.uniform() < DYING_PROB_FUNCTION(persons.loc[person_id,\"age\"]):\n            if verbose: print(person_id, \" died\")\n            dead_person = persons.loc[person_id]\n            if dead_person[\"house_staying\"] != None:\n                if verbose: print(\"vacated \", dead_person[\"house_staying\"])\n                houses.loc[dead_person[\"house_staying\"],\"status\"] = \"empty\"\n                houses.loc[dead_person[\"house_staying\"],\"occupant\"] = None\n                houses.loc[dead_person[\"house_selling\"],\"status\"] = \"empty\"\n                houses.loc[dead_person[\"house_selling\"],\"occupant\"] = None\n            persons_id_dead.append(person_id)\n    persons.drop(persons_id_dead, inplace=True)","67f7c8e7":"def birth(verbose = False):\n    born = NUM_BORN()\n    for _ in range(born):\n        persons.loc[secrets.token_hex(4)] = generate_person()","dd56d2e1":"from collections import defaultdict\nhistory = defaultdict(list)\n\ndef update_history(verbose = False):\n    history[\"popn_with_zero_house\"].append((persons.house_staying.values != persons.house_staying.values).sum())\n    history[\"popn_with_one_house\"].append((persons.house_selling.values != persons.house_selling.values).sum())\n    history[\"popn_with_two_house\"].append((persons.house_selling.values == persons.house_selling.values).sum())\n    history[\"total_houses_empty\"].append((houses.status == \"empty\").sum())\n    history[\"total_houses_occupied\"].append((houses.status == \"occupied\").sum())\n    history[\"total_houses_selling\"].append((houses.status == \"selling\").sum())\n    history[\"average_wealth\"].append(np.mean(persons[\"wealth\"]))\n    history[\"average_utility\"].append(np.mean(persons[\"utility\"]))\n    history[\"average_price\"].append(np.mean(houses[\"last_bought_price\"]))\n    history[\"average_market\"].append(np.mean(houses[\"market_price\"]))\n    return None","e47ffe23":"### Phase 2: ASK -> BID -> MATCH -> UPDATE\n# this is meant to be ran just once at the start\nask_df = pd.DataFrame(columns = ['location','occupant_id','amenities', 'distance_to_city', 'ask_price']) # init empty ask_df with col\n            \ndef gen_asks():\n    ''' phase 2 bid-ask\n    1. Refresh ask_df pd.DataFrame()\n    2. Add empty houses from `houses` to ask_df\n    3. Add more listings from persons who can and want to sell houses\n    '''\n    global ask_df # may not be necessary\n    ask_df_columns = ask_df.columns.to_list() # ['house_pos','current_occupant_id','amenities', 'ask_price']\n    \n    # 1. Refresh ask_df pd.DataFrame()\n    ask_df.drop(ask_df.index, inplace=True) # drops all rows\n    \n    # 2. Add empty houses from `houses` to ask_df\n    empty_houses = houses[houses['status']=='empty']\n    \n    ## 2.1 Rename, reorder into ask_df column mold\n    ## ask_df column order: ['house_pos','current_occupant_id','amenities', 'ask_price']\n    empty_houses_listing = empty_houses.rename(columns={\n        'occupant':'occupant_id',\n        'last_bought_price':'ask_price',\n    })\n    empty_houses_listing = empty_houses_listing[ask_df_columns] # reorder and subset columns\n    \n    ask_df = ask_df.append(empty_houses_listing, ignore_index=True) # TODO: optimise\n    \n    # 3. Add more listings from `persons` who can and want to sell houses\n    ## 3.1 get sub df of persons who have a second house to sell\n    COND_have_house_selling = persons['house_selling'] != None\n    potential_sellers = persons[COND_have_house_selling] # a persons sub df\n    \n    ## 3.2 Get potential sellable houses\n    potential_house_selling_loc = potential_sellers['house_selling']\n    potential_house_selling = houses[houses['location'].isin(potential_house_selling_loc.values)]\n    \n    ## 3.3 Random decide if want to sell or not given market_price vs last_bought_price\n    global PROBA_SELL_NO_LOSS, PROBA_SELL_WITH_LOSS # update(weets,191128)\n    \n    ### 3.3.1 Build conditionals to identify houses poorly affected by market but want to sell anyway\n    COND_poor_market = potential_house_selling['market_price'] < potential_house_selling['last_bought_price'] # expect loss\n    COND_want_sell_with_loss = potential_house_selling['status'].apply(lambda runif: np.random.uniform()) <= PROBA_SELL_WITH_LOSS # lower proba of selling\n    \n    ### 3.3.2 Build conditionals to identify houses well affected by market and want to sell anyway\n    COND_good_market = potential_house_selling['market_price'] >= potential_house_selling['last_bought_price'] # no loss\n    COND_want_sell_no_loss = potential_house_selling['status'].apply(lambda runif: np.random.uniform()) <= PROBA_SELL_NO_LOSS # higher proba of selling\n    \n    ### 3.3.3 Get subdf of actual houses to be listed\n    actual_house_selling = potential_house_selling[(COND_poor_market & COND_want_sell_with_loss) | (COND_good_market & COND_want_sell_no_loss)]\n    \n    ## 3.4 Rename, reorder actual_house_selling into ask_df column mold\n    ## ask_df column order: ['house_pos','current_occupant_id','amenities', 'ask_price']\n    main_listing = actual_house_selling.rename(columns={'market_price':'ask_price',\n                                               'occupant':'occupant_id'})\n    main_listing = main_listing[ask_df_columns]\n    \n    ask_df = ask_df.append(main_listing, ignore_index=True)\n    \n    # strangely, there's a row with nan value in location appearing\n    # this chunk fixes that\n    if any(ask_df['location'].apply(lambda loc: type(loc)!=tuple)):\n        ori_len = len(ask_df)\n        ask_df = ask_df[~ask_df['location'].isna()]\n        # print('Change in len', len(ask_df)-ori_len)\n    \n    \n# test run\n# gen_asks()\n# ask_df.sample(10)","f58bc124":"### Phase 2: ASK -> BID -> MATCH -> UPDATE\n# init empty ask_df with col\nbid_df = pd.DataFrame(columns = ['location', 'bidder_id', 'utility_to_buyer', 'max_bid_price', 'bid_price','buying_second_house']) # not impt actually\n    \ndef gen_bids():\n    ''' phase 2 bid-ask\n    1. Refresh bid_df pd.DataFrame()\n    2. Generate subdf of persons who can and want to buy houses\n    3. For each eligible person, iterate over ask, grow person_bids list of dict\n    4. Merge \n    '''\n    global bid_df # may not be necessary\n    bid_df_columns = bid_df.columns.to_list() # ['location', 'bidder_id', 'utility_to_buyer', 'max_bid_price', 'bid_price']\n    \n    # 1. Refresh bid_df pd.DataFrame()\n    bid_df.drop(bid_df.index, inplace=True) # drops all rows\n    \n    # 2. Screen viable bidders\n    ## 2.1 Does not own a second house (can have 1 or 0 houses)\n    COND_no_second_house = persons['house_selling'].isna() # NOTE: do not use `persons['house_selling'] == None` to check\n    potential_buyers = persons[COND_no_second_house]\n    \n    ## 2.2 Random decide if want to seek or not\n    global PROBA_BUY\n    PROBA_BUY = PROBA_BUY # arbitrary threshold; TODO: turn into adjustable param\n    COND_want_buy = potential_buyers['age'].apply(lambda runif: np.random.uniform()) <= PROBA_BUY\n    eligible_and_seeking_buyers = potential_buyers[COND_want_buy] # these are the eligible people who want to buy houses\n    \n    # 3. Each eligible buyer makes a bid for each house on sale\n    list_of_bid_sets = [] # to be populated with df corr. to each person's bids\n    \n    ## 3.1 Define helper fn\n    def _gen_bid_price(listing_row):\n        max_bid_price = listing_row['max_bid_price']\n        ask_price = listing_row['ask_price']\n        if  max_bid_price >= ask_price:\n            surplus = max_bid_price - ask_price\n            return ask_price + np.random.uniform() * surplus\n        else:\n            return max_bid_price\n    \n    ## 3.2 Iterate over buyers\n    for idx, buyer in eligible_and_seeking_buyers.iterrows():\n        buyer_view_of_ask_df = ask_df.copy()\n        \n        ###  3.2.1 Calculate each listing's utility to buyer\n        buyer_view_of_ask_df['bidder_id'] = idx\n        buyer_view_of_ask_df['utility_to_buyer'] = utility_function_vectorised(buyer, buyer_view_of_ask_df) # person, house\n        # NOTE: utility_to_buyer is partial -- it only consider's a houses's general and locational utility and buyer idio\n        \n        ### 3.2.2 Calculate bid_price\n        buyer_view_of_ask_df['max_bid_price'] = buyer['wealth'] - buyer['utility'] + buyer_view_of_ask_df['utility_to_buyer'] # TODO: double check if this is a good rule\n        # utility came from preceding iter(s). If utility fromp previous is very high, the buyer's max bid price will be lower, all else equal.\n        # if bid is successful, the utility_to_buyer of new house will replace previous utility value (from old house)\n        buyer_view_of_ask_df['max_bid_price'] = buyer_view_of_ask_df['max_bid_price'].apply(lambda mbp: min(mbp, buyer['wealth']))\n        # mbp must be capped at buyer's wealth\n        buyer_view_of_ask_df['max_bid_price'] = buyer_view_of_ask_df['max_bid_price'].apply(lambda mbp: max(0,mbp))\n        # mbp must be non-negative\n        \n        bid_price = buyer_view_of_ask_df.apply(_gen_bid_price, axis=1)\n        buyer_view_of_ask_df['bid_price'] = bid_price\n        \n        ### 3.2.3 Mark out second house buyers - updated(weets, 191125)\n        buyer_view_of_ask_df['buying_second_house'] = type(buyer['house_staying']) == tuple # if have house_staying location tuple, then is buying second house\n        \n        ### 3.2.4 Append specific columns of buyer_view_of_ask_df to list_of_bid_sets\n        select_columns = ['location', 'bidder_id', 'utility_to_buyer', 'max_bid_price', 'bid_price', 'buying_second_house']\n        list_of_bid_sets.append(buyer_view_of_ask_df[select_columns])\n    \n    # 4. Concatenate list of dataframes into one dataframe\n    if list_of_bid_sets: # possible that no bids take place\n        bid_df = pd.concat(list_of_bid_sets)\n    return bid_df\n\n# bid_df = gen_bids()\n# print(bid_df['bidder_id'].nunique())\n# bid_df.head()","498ee679":"### Phase 2: ASK -> BID -> MATCH -> UPDATE\nmatch_df = pd.DataFrame(columns = ['location','amenities','distance_to_city','ask_price','num_bids','highest_bid_value','mean_bid_value','winning_bidder_id','winning_bid_value'])\ndef match_ask_bid():\n    '''\n    1. Create a container list to store dicts of info relating to bidding for each listing\n    2. Iterate over listings in ask_df, find best bid - is successful match\n    3. For each successful match\n        1. Create and append dict of info relating to bids for the listing\n        2. Remove all bids for same listing\n        3. Remove all other bids by same bidder\n        4. Update asker and bidder\n    4. For each unsuccessful match\n        1. Create and append dict of info relating to bids for the listing\n        2. Remove all bids for same listing\n    5. Make match_df\n    '''\n    global bid_df, persons, houses, match_df\n    # 1. Create a container list to store dicts of info relating to bidding for each listing\n    list_of_matches = [] # contains info on winning bid\n    \n    # 2. Iterate over listings in ask_df, find best bid - is successful match\n    for idx, listing in ask_df.sample(frac=1).iterrows(): # shuffles ask_df\n        match_info_dict = {} # stats for each listing match\n        \n        ## 2.1 Get general data\n        listing_loc = listing['location']\n        match_info_dict['location'] = listing_loc\n        \n        match_info_dict['amenities'] = listing['amenities']\n        match_info_dict['distance_to_city'] = listing['distance_to_city']\n        \n        match_info_dict['ask_price'] = listing['ask_price']\n        \n        relevant_bids = bid_df[bid_df['location']==listing_loc]\n        match_info_dict['num_bids'] = len(relevant_bids) # expect 0 or more\n        \n        highest_bid_value = relevant_bids['bid_price'].max() # might be NaN if len(relevant_bids) == 0\n        match_info_dict['highest_bid_value'] = highest_bid_value\n        \n        match_info_dict['mean_bid_value'] = relevant_bids['bid_price'].mean() # might be NaN if len(relevant_bids) == 0\n        \n        # 3. Found winning bid(s)\n        if highest_bid_value >= listing['ask_price']: # there exists a successful match; NaN compatible\n            ## 3.1 Create and append dict of info relating to bids for the listing\n            ### 3.1.1 Check for ties among highest bid\n            highest_bids = relevant_bids[relevant_bids['bid_price']==highest_bid_value]\n            num_highest_bid = len(highest_bids) # expect at least 1, unlikely but possibly more\n            assert num_highest_bid >= 1, 'ERR: num_highest_bid must be >= 1'\n            \n            ### 3.1.2 Get the winner\n            winning_bid = highest_bids.sample(1) # tie-breaker: randomly choose one highest bidder to win\n            \n            winning_bidder_id = winning_bid['bidder_id'].iloc[0]\n            match_info_dict['winning_bidder_id'] = winning_bidder_id\n            match_info_dict['winning_bid_value'] = highest_bid_value # obviously; but stated explicitly as highest_bid_value may not win for the `else` case\n            \n            ### 3.1.3 Append match info\n            list_of_matches.append(match_info_dict)\n            \n            ## 3.2 Remove all corresponding bids, 3.3 Remove all other bids by same bidder\n            bid_df = bid_df.drop(relevant_bids.index, axis=0)\n            bid_df = bid_df[~(bid_df['bidder_id']==winning_bidder_id)]\n            \n            ## 3.4 Update asker and bidder\n            asker_id = listing['occupant_id']\n            \n            ### 3.4.1 Update asker\n            if type(asker_id) is str: # if str, then not empty house\n                persons['wealth'].loc[asker_id] += highest_bid_value\n                persons['house_selling'].loc[asker_id] = np.NaN # check for error here\n                # weets: asker utility does not increase on sale of house. Utility will be utility of the house staying, given the price the person bought it at.\n                # thus, sales of second house does not affect asker's utility\n                \n            ### 3.4.2 Update bidder\n            winning_bidder = persons.loc[winning_bidder_id]\n            persons['wealth'].loc[winning_bidder_id] -= highest_bid_value\n            \n            #### Additional updates for bidder if second house buyer\n            if winning_bid['buying_second_house'].iloc[0]: # first house exists, buyer is buying second house\n            # if type(winning_bidder['house_staying']) is tuple: # first house exists, buyer is buying second house\n                persons['house_selling'].loc[winning_bidder_id] = \"random string to recast type\"\n                persons['house_selling'].loc[winning_bidder_id] = winning_bidder['house_staying'] # set current house_staying to be house_selling\n                houses['status'].loc[winning_bidder['house_staying']] = 'selling' # set that same current house to 'selling' status\n            persons['house_staying'].loc[winning_bidder_id] = \"random string to recast type\"\n            persons['house_staying'].loc[winning_bidder_id] = listing_loc\n            \n            prev_utility =  persons['utility'].loc[winning_bidder_id] # get old\n            persons['utility'].loc[winning_bidder_id] = winning_bid['utility_to_buyer'].iloc[0] # set new utility\n            \n            # print('Utility change:',persons['utility'].loc[winning_bidder_id] - prev_utility) # should be non-negative\n            # TODO: check where to update 'utility' (person's simulation score) -- here or elsewhere?\n            # ENSURE: asker['utility'] increase or stay the same\n            \n            ### 3.4.3 Update house\n            houses['last_bought_price'].loc[listing_loc] = highest_bid_value\n            houses['status'].loc[listing_loc] = 'occupied'\n            # Note: for second house buyers, their first house's status has already been updated\n            houses['occupant'].loc[listing_loc] = winning_bidder_id\n            houses['last_updated'].loc[listing_loc] = 0\n            # TODO: update houses['market_price'] at the end of each time step, somewhere else perhaps\n            \n        # 4. No successful match   \n        else:\n            ## 4.1 Create and append dict of info relating to bids for the listing\n            match_info_dict['winning_bidder_id'] = np.NaN\n            match_info_dict['winning_bid_value'] = np.NaN\n            list_of_matches.append(match_info_dict)\n            \n            ## 4.2 Remove all bids for same listing\n            bid_df = bid_df.drop(relevant_bids.index, axis=0)\n            \n    # 5. Make match_df\n    match_df = pd.DataFrame(list_of_matches)\n    \n    ## 5.1 Additional calculations\n    def _get_dist(loc):\n        return ((loc[0]-CITY_X)**2 + (loc[1]-CITY_Y)**2)**(0.5)\n    \n    match_df['distance_to_city'] = match_df['location'].apply(_get_dist)\n    return match_df\n\n\n# gen_asks()\n# bid_df = gen_bids()\n# match_df = match_ask_bid() # Note: changes bid_df each time it is called\n# match_df.head(10)","05c67e92":"def update_market_price():\n    global houses, match_df, MIN_TXN_VOL\n    \n    # 1. Update market price using info from bid-ask-match data\n    clean_matches = match_df[~match_df['highest_bid_value'].isna()]\n    if len(clean_matches):\n        ## 1.1 build linear regression model for market_price\n        X = clean_matches[['amenities','distance_to_city']]\n        \n        Y = clean_matches['highest_bid_value'].values\n        lm = LinearRegression().fit(X,Y)\n        \n        if DEBUG:\n            print('score {} m {} c {}'.format(lm.score(X, Y),\n                                           lm.coef_,\n                                           lm.intercept_))\n        \n        ## 1.2 Build market pricer function \n        def cal_market_price(houses_df): # update(weets,191202)\n            '''Applies linear predictor model\n            '''\n            X = houses_df[['amenities','distance_to_city']].values.reshape(1, -1)\n            pred_market_price = max(lm.predict(X).item(),0)\n            return pred_market_price\n            \n        def _choose_market_pricer():\n            if len(clean_matches) >= MIN_TXN_VOL: # update(weets,191202)\n                # if sufficient transactions occur, use linear model\n                return cal_market_price # update(weets, 191202)\n            else: return lambda _: clean_matches['highest_bid_value'].median() #  if not, just use median of highest bid values\n        \n        market_pricer = _choose_market_pricer()\n            \n        ## 1.3 Update market prices\n        houses = houses[~houses['amenities'].isna()] # drops any rows from houses that do not have an amenities data\n        houses['market_price'] = houses.apply(market_pricer, axis=1) # update(weets,191202)\n    \n    # 2. Update market price given current affairs\n    def gen_current_affair_multiplier():\n        global PROBA_CA_GOOD, PROBA_CA_BAD, CA_MULTIPLIER_GOOD, CA_MULTIPLIER_BAD, CA_MULTIPLIER_FAIR\n        u = np.random.uniform(0,1)\n        if u < PROBA_CA_GOOD: return CA_MULTIPLIER_GOOD()\n        elif u < PROBA_CA_GOOD+PROBA_CA_BAD: return CA_MULTIPLIER_BAD()\n        else: return CA_MULTIPLIER_FAIR()\n    \n    current_affairs_multipler = gen_current_affair_multiplier() # ranges from BAD_LB to GOOD_UB\n    print('CAM', current_affairs_multipler)\n    houses['market_price'] = houses['market_price'].apply(lambda mp: mp*current_affairs_multipler)\n        \n# update_market_price() ","6c172d67":"DEBUG = False\ndebug_run = 100\nif DEBUG:\n    for i in range(debug_run):\n        aging()\n        birth()\n        dying()\n        print('persons',len(persons))\n        print(persons['wealth'].max())\n        gen_asks()\n        print('ask',len(ask_df))\n        print('min ask',ask_df['ask_price'].min())\n        gen_bids()\n        print('bid',len(bid_df))\n        print(bid_df['bid_price'].max())\n        match_ask_bid()\n        print('successful match',len(match_df[~match_df['winning_bidder_id'].isna()]))\n        update_market_price()","6d77c85d":"if DEBUG: match_df[~match_df['highest_bid_value'].isna()].plot(kind='scatter',x='amenities',y='highest_bid_value')","d5fecf97":"if DEBUG: match_df[~match_df['highest_bid_value'].isna()].plot(kind='scatter',x='distance_to_city',y='highest_bid_value')","7d39516c":"if DEBUG: houses[~houses['market_price'].isna()].plot(kind='scatter',x='amenities',y='market_price')","57c63bb5":"if DEBUG: houses[~houses['market_price'].isna()].plot(kind='scatter',x='distance_to_city',y='market_price')","62dbbe4c":"# hotfix as NaN row appears in houses\n# somehow NaN is introduced to the dataframe index\n# this converts the index to a numpy float which I need to reconvert back\n\ndef drop_NaN_row(df):\n    if np.NaN in df.index:\n        df = df.drop([np.NaN])\n    return df\n\ndef convert_to_tuple_int(index):\n    return (int(index[0]), int(index[1]))\nhouses = drop_NaN_row(houses)\nhouses.index = houses.index.map(convert_to_tuple_int)","34a3a47c":"%%time\nsnapshots = []\nsnapshot = {}\nsnapshot[\"houses\"] = houses.copy()\nsnapshot[\"persons\"] = persons.copy()\nsnapshot[\"ask_df\"] = ask_df.copy()\nsnapshot[\"bid_df\"] = bid_df.copy()\nsnapshot[\"match_df\"] = match_df.copy()\nsnapshot[\"history\"] = deepcopy(history)\nsnapshots.append(deepcopy(snapshot))\n\ndef simulate():\n    aging()\n    birth()\n    dying()\n    gen_asks()\n    gen_bids()\n    match_ask_bid()\n    update_history()\n    update_market_price()\n    \n    # hotfix as NaN row appears in houses\n    global houses\n    houses = drop_NaN_row(houses)\n    houses.index = houses.index.map(convert_to_tuple_int)\n    \nfor _ in tqdm_notebook(range(NUM_FRAMES)):\n    simulate()\n    snapshot[\"houses\"] = houses.copy()\n    snapshot[\"persons\"] = persons.copy()\n    snapshot[\"ask_df\"] = ask_df.copy()\n    snapshot[\"bid_df\"] = bid_df.copy()\n    snapshot[\"match_df\"] = match_df.copy()\n    snapshot[\"history\"] = deepcopy(history)\n    snapshots.append(deepcopy(snapshot))","49b028c2":"%%time\n# save data (and an example to load the data)\nimport pickle\nwith open('snapshots.pkl', 'wb') as handle: pickle.dump(snapshots, handle, protocol=pickle.HIGHEST_PROTOCOL)\nwith open('snapshots.pkl', 'rb') as handle: unserialized_data = pickle.load(handle)\nprint(str(snapshots) == str(unserialized_data))","61272f19":"%%time\n# retrieve snapshots\nhouses = snapshots[0][\"houses\"]\npersons = snapshots[0][\"persons\"]\nhistory = snapshots[0][\"history\"]\n\nzero_house = persons[persons[\"house_staying\"]!=persons[\"house_staying\"]]\ntwo_houses = persons[persons[\"house_selling\"]==persons[\"house_selling\"]]\none_houses = persons[(persons[\"house_staying\"]==persons[\"house_staying\"]) & \n                     (persons[\"house_selling\"]!=persons[\"house_selling\"])]\n\nhouse_empty = houses[houses[\"status\"]==\"empty\"]\nhouse_occu  = houses[houses[\"status\"]==\"occupied\"]\nhouse_sell  = houses[houses[\"status\"]==\"selling\"]\n\n# initialise graphs\nfig, ax = plt.subplots(nrows=5, ncols=5,figsize=(12,12),\n                       gridspec_kw={\"height_ratios\":[0.8, 0.05, 1.5, 1.5, 1.5]})\nplt.subplots_adjust(wspace=0.4)","ff8bbfba":"%%time\n# colormaps\nim0 = ax[0,0].imshow(np.random.randn(10,10), vmin=0, vmax=1000, cmap=\"inferno_r\")\nim1 = ax[0,1].imshow(np.random.randn(10,10), cmap=\"inferno_r\",\n                     norm=colors.LogNorm(vmin=10, vmax=1000))\nim2 = ax[0,2].imshow(np.random.randn(10,10), cmap=\"inferno_r\",\n                     norm=colors.LogNorm(vmin=10, vmax=1000))\nim3 = ax[0,3].imshow(np.random.randn(10,10), cmap=\"inferno_r\", vmin=0, vmax=100)\nim4 = ax[0,4].imshow(np.random.randn(10,10), cmap=colors.ListedColormap(['blue','orange','green']), \n                     vmin=0, vmax=2)\nax[0,0].set_title(\"utility_general\")\nax[0,1].set_title(\"market_price\")\nax[0,2].set_title(\"last_bought_price\")\nax[0,3].set_title(\"last_updated\")\nax[0,4].set_title(\"occupancy status\")\n\nfig.colorbar(im0, cax=ax[1,0], orientation=\"horizontal\")\nfig.colorbar(im1, cax=ax[1,1], orientation=\"horizontal\")\nfig.colorbar(im2, cax=ax[1,2], orientation=\"horizontal\")\nfig.colorbar(im3, cax=ax[1,3], orientation=\"horizontal\")\nfig.colorbar(im4, cax=ax[1,4], orientation=\"horizontal\")\nax[1,4].set_xticklabels(['Empty', 'Occupied', 'Selling'])\npass","4bcdc8cb":"%%time\n# plots on wealth\nline_pop_0, = ax[2,0].plot([], lw=3, label=\"zero houses\")\nline_pop_1, = ax[2,0].plot([], lw=3, label=\"one house\")\nline_pop_2, = ax[2,0].plot([], lw=3, label=\"two houses\")\nmax_plot_pop = 60\nax[2,0].set_ylim((0, max_plot_pop))\nax[2,0].set_xlim((-20, 0))\nax[2,0].set_title(\"population\")\nax[2,0].legend(loc=\"upper right\")\n\nline_wealth_0, = ax[2,1].plot([], lw=3, label=\"average wealth\")\nmax_plot_wealth = 600\nax[2,1].set_ylim((0, max_plot_wealth))\nax[2,1].set_xlim((-20, 0))\nax[2,1].set_title(\"average wealth\")\nax[2,1].legend(loc=\"upper right\")\n\nscat_wealth_age_zero = ax[2,2].scatter([], [], s=20, label=\"zero houses\", color=\"blue\")\nscat_wealth_age_one = ax[2,2].scatter([], [], s=20, label=\"one house\", color=\"orange\")\nscat_wealth_age_two = ax[2,2].scatter([], [], s=20, label=\"two house\", color=\"green\")\nax[2,2].set_ylim((0, max_plot_wealth))\nax[2,2].set_xlim((20, 60))\nax[2,2].set_title(\"wealth against age\")\nax[2,2].legend(loc=\"upper right\")\n\nax[2,3].hist([], color=\"green\")\nax[2,3].set_title(\"histogram of wealth\")\nax[2,3].set_xlim((0, max_plot_wealth))\nax[2,3].set_ylim((0, 20))\n\nline_house_0, = ax[2,4].plot([], lw=3, label=\"empty\", color=\"blue\")\nline_house_1, = ax[2,4].plot([], lw=3, label=\"occupied\", color=\"orange\")\nline_house_2, = ax[2,4].plot([], lw=3, label=\"selling\", color=\"green\")\nax[2,4].set_ylim((0, 100))\nax[2,4].set_xlim((-20, 0))\nax[2,4].set_title(\"housing occupancy\")\nax[2,4].legend(loc=\"upper right\")\npass","30713b38":"%%time\nax[3,0].set_axis_off()\n# plots on utility\nline_utility_0, = ax[3,1].plot([], lw=3, label=\"average utility\")\nmax_plot_utility = 600\nax[3,1].set_ylim((0, max_plot_utility))\nax[3,1].set_xlim((-20, 0))\nax[3,1].set_title(\"average utility\")\nax[3,1].legend(loc=\"upper right\")\n\nscat_utility_age_zero = ax[3,2].scatter([], [], s=20, label=\"zero houses\", color=\"blue\")\nscat_utility_age_one = ax[3,2].scatter([], [], s=20, label=\"one house\", color=\"orange\")\nscat_utility_age_two = ax[3,2].scatter([], [], s=20, label=\"two house\", color=\"green\")\nax[3,2].set_ylim((0, max_plot_utility))\nax[3,2].set_xlim((20, 60))\nax[3,2].set_title(\"utility against age\")\nax[3,2].legend(loc=\"upper right\")\n\nscat_utility_wealth_zero = ax[3,4].scatter([], [], s=20, label=\"zero houses\", color=\"blue\")\nscat_utility_wealth_one = ax[3,4].scatter([], [], s=20, label=\"one house\", color=\"orange\")\nscat_utility_wealth_two = ax[3,4].scatter([], [], s=20, label=\"two house\", color=\"green\")\nax[3,4].set_ylim((0, max_plot_utility))\nax[3,4].set_xlim((0, max_plot_wealth))\nax[3,4].set_title(\"utility against wealth\")\nax[3,4].legend(loc=\"upper right\")\n\nax[3,3].hist([], color=\"green\")\nax[3,3].set_title(\"histogram of utility\")\nax[3,3].set_xlim((0, max_plot_wealth))\nax[3,3].set_ylim((0, 20))\npass","f8e82e36":"%%time\nax[4,0].set_axis_off()\n# plots on housing\nline_price_0, = ax[4,1].plot([], lw=3, label=\"price\", color=\"red\")\nmax_plot_price = 200\nax[4,1].set_ylim((0, max_plot_price))\nax[4,1].set_xlim((-20, 0))\nax[4,1].set_title(\"average last bought price\")\nax[4,1].legend(loc=\"upper right\")\n\nscat_price_util_empty = ax[4,2].scatter([], [], s=20, marker=\"s\", label=\"empty\", color=\"blue\")\nscat_price_util_occu  = ax[4,2].scatter([], [], s=20, marker=\"s\", label=\"occupied\", color=\"orange\")\nscat_price_util_sell  = ax[4,2].scatter([], [], s=20, marker=\"s\", label=\"selling\", color=\"green\")\nax[4,2].set_xlim((0, max(houses[\"utility_general\"])))\nax[4,2].set_ylim((0, max_plot_price))\nax[4,2].set_title(\"last price against utility\")\nax[4,2].legend(loc=\"upper right\")\n\nline_market_0, = ax[4,3].plot([], lw=3, label=\"price\", color=\"red\")\nax[4,3].set_ylim((0, max_plot_price))\nax[4,3].set_xlim((-20, 0))\nax[4,3].set_title(\"average market price\")\nax[4,3].legend(loc=\"upper right\")\n\nscat_market_util_empty = ax[4,4].scatter([], [], s=20, marker=\"s\", label=\"empty\", color=\"blue\")\nscat_market_util_occu  = ax[4,4].scatter([], [], s=20, marker=\"s\", label=\"occupied\", color=\"orange\")\nscat_market_util_sell  = ax[4,4].scatter([], [], s=20, marker=\"s\", label=\"selling\", color=\"green\")\nax[4,4].set_xlim((0, max(houses[\"utility_general\"])))\nax[4,4].set_ylim((0, max_plot_price))\nax[4,4].set_title(\"market price against utility\")\nax[4,4].legend(loc=\"upper right\")\npass\n# to add - ask_df and bid_df","37a61e5a":"%%time\nplt.tight_layout()\npatch = [im0, im1, im2, im3, im4]\na1,a2,a3,a4,a5 = tuple([np.empty((10,10,)) for _ in range(5)])\n\ndef update_plot():\n    a1[:], a2[:], a3[:], a4[:], a5[:] = (np.NaN,)*5\n    for index in list(houses.index):\n        a1[index[0], index[1]] = houses.loc[index,\"utility_general\"]\n        a2[index[0], index[1]] = houses.loc[index,\"market_price\"]\n        a3[index[0], index[1]] = houses.loc[index,\"last_bought_price\"]\n        a4[index[0], index[1]] = houses.loc[index,\"last_updated\"]\n        a5[index[0], index[1]] = status_to_float(houses.loc[index,\"status\"])\n    im0.set_data(a1)\n    im1.set_data(a2)\n    im2.set_data(a3)\n    im3.set_data(a4)\n    im4.set_data(a5)\n\n    line_pop_0.set_data(range(0,-len(history[\"popn_with_zero_house\"][-20:]),-1), \n                        history[\"popn_with_zero_house\"][-20:][::-1])\n    line_pop_1.set_data(range(0,-len(history[\"popn_with_one_house\"][-20:]),-1), \n                        history[\"popn_with_one_house\"][-20:][::-1])\n    line_pop_2.set_data(range(0,-len(history[\"popn_with_two_house\"][-20:]),-1), \n                        history[\"popn_with_two_house\"][-20:][::-1])\n    global max_plot_pop\n    max_plot_pop = max(max_plot_pop, \n                       history[\"popn_with_zero_house\"][-1], \n                       history[\"popn_with_one_house\"][-1], \n                       history[\"popn_with_two_house\"][-1])\n    ax[2,0].set_ylim(0, max_plot_pop)\n    \n    line_house_0.set_data(range(0,-len(history[\"total_houses_empty\"][-20:]),-1), \n                          history[\"total_houses_empty\"][-20:][::-1])\n    line_house_1.set_data(range(0,-len(history[\"total_houses_occupied\"][-20:]),-1), \n                          history[\"total_houses_occupied\"][-20:][::-1])\n    line_house_2.set_data(range(0,-len(history[\"total_houses_selling\"][-20:]),-1), \n                          history[\"total_houses_selling\"][-20:][::-1])\n    \n    line_wealth_0.set_data(range(0,-len(history[\"average_wealth\"][-20:]),-1), \n                           history[\"average_wealth\"][-20:][::-1])\n    line_utility_0.set_data(range(0,-len(history[\"average_utility\"][-20:]),-1), \n                            history[\"average_utility\"][-20:][::-1])\n    line_price_0.set_data(range(0,-len(history[\"average_price\"][-20:]),-1), \n                          history[\"average_price\"][-20:][::-1])\n    line_market_0.set_data(range(0,-len(history[\"average_market\"][-20:]),-1), \n                          history[\"average_market\"][-20:][::-1])\n    \n    zero_house = persons[persons[\"house_staying\"]!=persons[\"house_staying\"]]\n    two_houses = persons[persons[\"house_selling\"]==persons[\"house_selling\"]]\n    one_houses = persons[(persons[\"house_staying\"]==persons[\"house_staying\"]) & \n                         (persons[\"house_selling\"]!=persons[\"house_selling\"])]\n    \n    house_empty = houses[houses[\"status\"]==\"empty\"]\n    house_occu  = houses[houses[\"status\"]==\"occupied\"]\n    house_sell  = houses[houses[\"status\"]==\"selling\"]\n\n    \n    global max_plot_wealth, max_plot_utility, max_plot_price\n    max_plot_wealth = max(max_plot_wealth, max(persons[\"wealth\"]))\n    max_plot_utility = max(max_plot_utility, max(persons[\"utility\"]))\n    max_plot_price = max(max_plot_price, max(houses[\"last_bought_price\"]))\n    ax[2,1].set_ylim(0, max_plot_wealth)\n    ax[2,2].set_ylim(0, max_plot_wealth)\n    ax[3,1].set_ylim(0, max_plot_utility)\n    ax[3,2].set_ylim(0, max_plot_utility)\n    ax[3,4].set_xlim(0, max_plot_wealth)\n    ax[3,4].set_ylim(0, max_plot_utility)\n    ax[4,1].set_ylim(0, max_plot_price)\n    ax[4,2].set_ylim(0, max_plot_price)\n    \n    scat_wealth_age_zero.set_offsets(np.transpose((zero_house[\"age\"], zero_house[\"wealth\"])))\n    scat_wealth_age_one.set_offsets(np.transpose((one_houses[\"age\"], one_houses[\"wealth\"])))\n    scat_wealth_age_two.set_offsets(np.transpose((two_houses[\"age\"], two_houses[\"wealth\"])))\n    \n    scat_utility_age_zero.set_offsets(np.transpose((zero_house[\"age\"], zero_house[\"utility\"])))\n    scat_utility_age_one.set_offsets(np.transpose((one_houses[\"age\"], one_houses[\"utility\"])))\n    scat_utility_age_two.set_offsets(np.transpose((two_houses[\"age\"], two_houses[\"utility\"])))\n\n    scat_utility_wealth_zero.set_offsets(np.transpose((zero_house[\"wealth\"], zero_house[\"utility\"])))\n    scat_utility_wealth_one.set_offsets(np.transpose((one_houses[\"wealth\"], one_houses[\"utility\"])))\n    scat_utility_wealth_two.set_offsets(np.transpose((two_houses[\"wealth\"], two_houses[\"utility\"])))\n\n    scat_price_util_empty.set_offsets(np.transpose((house_empty[\"utility_general\"], house_empty[\"last_bought_price\"])))\n    scat_price_util_occu.set_offsets(np.transpose((house_occu[\"utility_general\"], house_occu[\"last_bought_price\"])))\n    scat_price_util_sell.set_offsets(np.transpose((house_sell[\"utility_general\"], house_sell[\"last_bought_price\"])))\n    \n    scat_market_util_empty.set_offsets(np.transpose((house_empty[\"utility_general\"], house_empty[\"market_price\"])))\n    scat_market_util_occu.set_offsets(np.transpose((house_occu[\"utility_general\"], house_occu[\"market_price\"])))\n    scat_market_util_sell.set_offsets(np.transpose((house_sell[\"utility_general\"], house_sell[\"market_price\"])))\n    \n    # histograms\n    ax[2,3].cla()\n    ax[2,3].hist(persons[\"wealth\"], bins=np.linspace(0,max_plot_wealth,15), color=\"green\")\n    ax[2,3].set_title(\"histogram of wealth\")\n    ax[2,3].set_xlim((0, max_plot_wealth))\n    ax[2,3].set_ylim((0, 20))\n\n    ax[3,3].cla()\n    ax[3,3].hist(persons[\"utility\"], bins=np.linspace(0,max_plot_utility,15), color=\"green\")\n    ax[3,3].set_title(\"histogram of utility\")\n    ax[3,3].set_xlim((0, max_plot_utility))\n    ax[3,3].set_ylim((0, 20))\n    \ndef init():\n    return patch\n\ndef animate(i):\n    global houses, persons, history\n    houses  = snapshots[i+1][\"houses\"]\n    persons = snapshots[i+1][\"persons\"]\n    history = snapshots[i+1][\"history\"]\n    update_plot()\n    print(\"*\", end=\"\")\n    return patch\n\n# call the animator. blit=True means only re-draw the parts that have changed.\nanim = animation.FuncAnimation(fig, animate, init_func=init,\n                               frames=NUM_FRAMES, interval=MILLISECS_PER_FRAME, blit=True)\n\nvid = anim.to_html5_video()\nplt.close()\nprint()","33b6638f":"HTML(vid)","06dcff3e":"persons","225d9886":"houses","12f263e7":"%%time\nimport plotly.figure_factory as ff\n# reference https:\/\/plot.ly\/python\/annotated_heatmap\/#custom-hovertext\n\nz = np.empty([10, 10])\nz[:] = np.nan\nhover = [[None for _ in range(10)] for _ in range(10)]\nann = [[\"\" for _ in range(10)] for _ in range(10)]\n\nfor addr in houses.index:\n    z[addr] = status_to_float(houses.loc[addr,\"status\"])\n    displayed = \"<br>\".join([\"{}: {}\".format(k,v) for k,v in houses.loc[addr].to_dict().items()])\n    occupant = houses.loc[addr,\"occupant\"]\n    if occupant:\n        try:\n            displayed += \"<br><br>Tenant information<br>\"\n            displayed += \"<br>\".join([\"{}: {}\".format(k,v) for k,v in persons.loc[occupant].to_dict().items()])\n        except:\n            pass\n#             print(occupant, \" not found\")\n    hover[addr[0]][addr[1]] = displayed\n\n\ncolorscale=[[0.00, 'rgb{}'.format(matplotlib.cm.get_cmap('viridis', 12)(0.0)[:3])],\n            [0.50, 'rgb{}'.format(matplotlib.cm.get_cmap('viridis', 12)(0.5)[:3])],\n            [1.00, 'rgb{}'.format(matplotlib.cm.get_cmap('viridis', 12)(1.0)[:3])]]\n\n# Make Annotated Heatmap\nfig = ff.create_annotated_heatmap(z, text=hover, hoverinfo='text', annotation_text=ann,\n                                  colorscale=colorscale, font_colors=['black'])\nfig.update_layout(title_text='Occupancy Status',\n                  yaxis = dict(scaleanchor = \"x\", scaleratio = 1),\n                  template=\"plotly_white\")\nfig.update_xaxes(showgrid=False, zeroline=False)\nfig.update_yaxes(showgrid=False, zeroline=False)\nfig.show()","34df95b7":"# results = []\n# for i in range(0):\n#     global NUM_BORN, NUM_FRAMES\n#     snapshots = []\n#     snapshot = {}\n#     NUM_BORN = lambda: 1 + i*5\n#     initialise_persons()\n#     initialise_houses()\n    \n#     global history\n#     history = defaultdict(list)\n    \n#     global ask_df, bid_df, match_df\n#     ask_df = pd.DataFrame(columns = ['location','occupant_id','amenities', 'ask_price']) # init empty ask_df with col\n#     bid_df = pd.DataFrame(columns = ['location', 'bidder_id', 'utility_to_buyer', 'max_bid_price', 'bid_price','buying_second_house']) # not impt actually\n#     match_df = pd.DataFrame(columns = ['location','amenities','ask_price','num_bids','highest_bid_value','mean_bid_value','winning_bidder_id','winning_bid_value'])\n\n#     for _ in tqdm_notebook(range(NUM_FRAMES)):\n#         simulate()\n#         snapshot[\"houses\"] = houses.copy()\n#         snapshot[\"persons\"] = persons.copy()\n#         snapshot[\"history\"] = deepcopy(history)\n#         snapshots.append(deepcopy(snapshot))\n#     results.append(np.mean(history[\"popn_with_zero_house\"]))","f889e852":"# plt.figure(figsize=(14,5))\n# plt.plot(results)","570fd474":"### Aging\nAt every time step, people get old, had wealth increased due to income. \nThe last transcation time of the house is updated for visualisation.","9796d480":"# Simulation process\nWe first simulate, then we animate.","6dde5582":"### Death\nWe define a probability of dying, which is dependent on age.","37733514":"### Update history\nFor trend visualisation at the dashboard.","f856b62c":"### Birth\nAt every time period, a random number of people enters the system.","d2540597":"To run this notebook, **you have to enable the Internet connection**","8816f57f":"# Initial state","7e67d7a7":"# Read dataframes","adaa698d":"# Visualise simulation","5d6514e0":"# Multiple simulations","81d37363":"# Transactions\nWe generate two dataframes - asking and buying.","58669274":"# Inspect housing characteristics","f49925dd":"# Input parameters","95181910":"# Animation generation\nWe are using Matplotlib animation module to visualise the simulation.\n\nVisualisations include line graph, scatter plot, histogram and heatmaps.\n\nAt each time step, `simulate()` is called, carries out the changes and updates the dashboard.","499a1e9b":"# Activities in timestep\nIn every time step, people age, people die, and people get born. Transactions then occur."}}