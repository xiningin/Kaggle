{"cell_type":{"63a4d4e7":"code","ab09779f":"code","191e5e5c":"code","33dcf85f":"code","7e392bcc":"code","a7ccf19c":"code","9eddd420":"code","27eacf49":"markdown","64e033df":"markdown","ab03ef36":"markdown","92602006":"markdown","40dafe8a":"markdown","0b673765":"markdown","7f4ae74b":"markdown"},"source":{"63a4d4e7":"!pip install ..\/input\/sartorius-segmentation-mask-rcnn-tf-requirements\/grpcio-1.32.0-cp37-cp37m-manylinux2014_x86_64.whl\n!pip install ..\/input\/sartorius-segmentation-mask-rcnn-tf-requirements\/gast-0.3.3-py2.py3-none-any.whl\n!pip install ..\/input\/sartorius-segmentation-mask-rcnn-tf-requirements\/six-1.15.0-py2.py3-none-any.whl\n!pip install ..\/input\/sartorius-segmentation-mask-rcnn-tf-requirements\/tensorflow_estimator-2.4.0-py2.py3-none-any.whl\n!pip install ..\/input\/sartorius-segmentation-mask-rcnn-tf-requirements\/h5py-2.10.0-cp37-cp37m-manylinux1_x86_64.whl\n!pip install ..\/input\/sartorius-segmentation-mask-rcnn-tf-requirements\/typing_extensions-3.7.4.3-py3-none-any.whl\n!pip install ..\/input\/sartorius-segmentation-mask-rcnn-tf-requirements\/tensorflow-2.4.0-cp37-cp37m-manylinux2010_x86_64.whl\n!pip install ..\/input\/sartorius-segmentation-mask-rcnn-tf-requirements\/Keras-2.4.0-py2.py3-none-any.whl\n!pip install ..\/input\/leekunhee-mask-rcnn\/Mask_RCNN-master","ab09779f":"import os\nimport cv2\nimport shutil\nimport pandas as pd\nimport numpy as np\nfrom numpy import zeros, asarray\nimport matplotlib.pyplot as plt \n%matplotlib inline\n\nfrom mrcnn import utils\nimport mrcnn.config\nimport mrcnn.model as modellib\nimport keras\nimport tensorflow as tf\n\n\nseed=42\nnp.random.seed(seed)\ntf.random.set_seed(seed)\nos.environ['PYTHONHASHSEED'] = str(seed)\n\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\ntest_fol = '..\/input\/sartorius-cell-instance-segmentation\/test'\nsub = pd.read_csv('..\/input\/sartorius-cell-instance-segmentation\/sample_submission.csv')\ntf.__version__, keras.__version__, tf.keras.__version__","191e5e5c":"# Model Configuration\nclass KaggleSartoriusConfig(mrcnn.config.Config):\n    NAME = \"kaggle_Sartorius_cfg\"\n    GPU_COUNT = 1\n    IMAGES_PER_GPU = 1 \n    NUM_CLASSES = 2\n    USE_MINI_MASK = False\n    \nkaggle_sartorius_model_config = KaggleSartoriusConfig()\n\ndef rle_encode(img):\n    '''\n    img: numpy array, 1 - mask, 0 - background\n    Returns run length as string formated\n    '''\n    pixels = img.flatten()\n    pixels = np.concatenate([[0], pixels, [0]])\n    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1\n    runs[1::2] -= runs[::2]\n    return ' '.join(str(x) for x in runs)","33dcf85f":"# Build the Mask R-CNN Model Architecture\nmodel = mrcnn.model.MaskRCNN(mode='inference', \n                             model_dir='.\/infer__mask_rcnn\/', \n                             config=kaggle_sartorius_model_config)\n#load trained-weights from the Train Notebook\n'''\n    WE ARE LOADING THE WEIGHTS OF EPOCH 5\n'''\nmodel.load_weights(filepath='..\/input\/epochs-710\/mask_rcnn_kaggle_sartorius_cfg_0010.h5', \n                   by_name=True)","7e392bcc":"#import cupy as cp\nimport gc\n\ndef fix_overlap(msk):\n    \"\"\"\n    Args:\n        mask: multi-channel mask, each channel is an instance of cell, shape:(520,704,None)\n    Returns:\n        multi-channel mask with non-overlapping values, shape:(520,704,None)\n    \"\"\"\n    msk = np.array(msk)\n    msk = np.pad(msk, [[0,0],[0,0],[1,0]])\n    ins_len = msk.shape[-1]\n    msk = np.argmax(msk,axis=-1)\n    msk = tf.keras.utils.to_categorical(msk, num_classes=ins_len)\n    msk = msk[...,1:]\n    msk = msk[...,np.any(msk, axis=(0,1))]\n    return msk\n\ndef check_overlap(msk):\n    msk = msk.astype(np.bool).astype(np.uint8) # binary mask\n    return np.any(np.sum(msk, axis=-1)>1) # only one channgel will contain value\n","a7ccf19c":"%%time\nimport skimage\n\nimage_names, pred_annots = [],[]\nfor s in sub['id']:\n    img_name, prd=[],[]\n    image = skimage.io.imread(os.path.join(test_fol, s)+'.png')\n    if image.ndim != 3:\n        image = skimage.color.gray2rgb(image)\n    if image.shape[-1] == 4:\n        image = image[..., :3]\n    results = model.detect([image])[0]['masks']\n    print(image.shape, results.shape)\n    if results.shape[-1]==0:\n        img_name.append(s)\n        prd.append('')\n    else:\n        if check_overlap(results): # if mask instances have overlap then fix it\n            print(\"Overlap Found!\")\n            results = fix_overlap(results)\n        for r in range(results.shape[2]):\n            pred_mask = results[:, :, r]\n            pred_mask = pred_mask.astype(np.uint8)\n            \n            img_name.append(s)\n            prd.append(rle_encode(pred_mask))\n        \n    image_names.extend(img_name)\n    pred_annots.extend(prd)","9eddd420":"assert len(os.listdir('..\/input\/sartorius-cell-instance-segmentation\/test'))==len(np.unique(image_names))\n\npd.DataFrame({'id':image_names, 'predicted':pred_annots}).sort_values(['id']).to_csv('submission.csv', index=False)\npd.read_csv('submission.csv').head(20)","27eacf49":"**<h2>Imports<\/h2>**","64e033df":"**<h2>Fix Overlaps<\/h2>**","ab03ef36":"\n**<h2>Submission<\/h2>**","92602006":"**<h2>Load Model<\/h2>**","40dafe8a":"**<h2>Training Notebook:<\/h2>**\nhttps:\/\/www.kaggle.com\/susnato\/sartorius-segmentation-mask-rcnn-tf-train\n**<h1><font color='red'>If You Find This Useful Then Please upvote<\/h1>**","0b673765":"**<h2>Prediction<\/h2>**","7f4ae74b":"**<h2>Load Test Dataset<\/h2>**"}}