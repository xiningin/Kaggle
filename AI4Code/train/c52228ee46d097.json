{"cell_type":{"05fc1d81":"code","36dc3bc8":"code","a76ac4a2":"code","b31c4b91":"code","04d5a82e":"code","cd288e98":"code","3de838df":"code","99c4c274":"code","e343bc64":"code","096f483f":"code","9386234c":"code","52326a79":"code","e30cb434":"code","977eb492":"code","0fd2cafc":"code","b8dd3a63":"code","68d3eb05":"code","388522db":"code","0379fe37":"code","3580691e":"code","5b56ad55":"code","01cb993d":"code","9abdd30b":"code","10269c42":"code","9fa3dd2b":"code","f4a7d5a7":"code","00a7d28a":"markdown","7d165e58":"markdown","8474ce96":"markdown"},"source":{"05fc1d81":"## Making essential imports\nimport os\nimport numpy as np\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\nimport cv2\nimport tensorflow as tf\nfrom tqdm import tqdm","36dc3bc8":"## defining data Loader function\ndef LoadData( frameObj = None, init=None, end=None,withpath=None,withoutpath=None, shape = 256):\n    with_mask = os.listdir(withpath)\n    with_mask.sort()\n\n    without_mask = os.listdir(withoutpath)\n    without_mask.sort()\n    \n    #clean frameObj\n    frameObj = {'without' : [],\n           'with' : []\n          }   \n    \n    withAddr = withpath + '\/'\n    withoutAddr = withoutpath + '\/'\n          \n    for i in tqdm(range(init, end)):      \n        #Read path + File\n        img = plt.imread(withAddr + with_mask[i])\n        mask = plt.imread(withoutAddr + without_mask[i])\n        #print(with_mask[i])\n        \n        withh = cv2.resize(img, (shape, shape)) \n        without = cv2.resize(mask, (shape, shape))\n        \n        frameObj['with'].append(withh[:,:,0])\n        frameObj['without'].append(without)      \n    return frameObj","a76ac4a2":"## defining a frame for image and mask storage\nframObjTrain = {'without' : [],\n           'with' : []\n          }\nwithpath='..\/input\/face-mask-lite-dataset\/with_mask'\nwithoutpath='..\/input\/face-mask-lite-dataset\/without_mask'\n\n#Init at end from the data \ninit_train=0\nend_train=200\nframObjTrain = LoadData( framObjTrain, init=init_train\n                        , end= end_train,withpath=withpath,withoutpath=withoutpath\n                        , shape = 256)","b31c4b91":"## displaying data loaded by our function\nplt.subplot(1,2,1)\nplt.imshow(framObjTrain['with'][0])\nplt.subplot(1,2,2)\nplt.imshow(framObjTrain['without'][0])\nplt.show()","04d5a82e":"def Conv2dBlock(inputTensor, numFilters, kernelSize = 3, doBatchNorm = True):\n    #first Conv\n    x = tf.keras.layers.Conv2D(filters = numFilters, kernel_size = (kernelSize, kernelSize),\n                              kernel_initializer = 'he_normal', padding = 'same') (inputTensor)\n    \n    if doBatchNorm:\n        x = tf.keras.layers.BatchNormalization()(x)\n        \n    x =tf.keras.layers.Activation('relu')(x)\n    \n    #Second Conv\n    x = tf.keras.layers.Conv2D(filters = numFilters, kernel_size = (kernelSize, kernelSize),\n                              kernel_initializer = 'he_normal', padding = 'same') (x)\n    if doBatchNorm:\n        x = tf.keras.layers.BatchNormalization()(x)\n        \n    x = tf.keras.layers.Activation('relu')(x)\n    \n    return x","cd288e98":"# Now defining Unet \ndef GiveMeUnet(inputImage, numFilters = 16, droupouts = 0.1, doBatchNorm = True):\n    # defining encoder Path\n    c1 = Conv2dBlock(inputImage, numFilters * 1, kernelSize = 3, doBatchNorm = doBatchNorm)\n    p1 = tf.keras.layers.MaxPooling2D((2,2))(c1)\n    p1 = tf.keras.layers.Dropout(droupouts)(p1)\n    \n    c2 = Conv2dBlock(p1, numFilters * 2, kernelSize = 3, doBatchNorm = doBatchNorm)\n    p2 = tf.keras.layers.MaxPooling2D((2,2))(c2)\n    p2 = tf.keras.layers.Dropout(droupouts)(p2)\n    \n    c3 = Conv2dBlock(p2, numFilters * 4, kernelSize = 3, doBatchNorm = doBatchNorm)\n    p3 = tf.keras.layers.MaxPooling2D((2,2))(c3)\n    p3 = tf.keras.layers.Dropout(droupouts)(p3)\n    \n    c4 = Conv2dBlock(p3, numFilters * 8, kernelSize = 3, doBatchNorm = doBatchNorm)\n    p4 = tf.keras.layers.MaxPooling2D((2,2))(c4)\n    p4 = tf.keras.layers.Dropout(droupouts)(p4)\n    \n    c5 = Conv2dBlock(p4, numFilters * 16, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    # defining decoder path\n    u6 = tf.keras.layers.Conv2DTranspose(numFilters*8, (3, 3), strides = (2, 2), padding = 'same')(c5)\n    u6 = tf.keras.layers.concatenate([u6, c4])\n    u6 = tf.keras.layers.Dropout(droupouts)(u6)\n    c6 = Conv2dBlock(u6, numFilters * 8, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    u7 = tf.keras.layers.Conv2DTranspose(numFilters*4, (3, 3), strides = (2, 2), padding = 'same')(c6)\n    \n    u7 = tf.keras.layers.concatenate([u7, c3])\n    u7 = tf.keras.layers.Dropout(droupouts)(u7)\n    c7 = Conv2dBlock(u7, numFilters * 4, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    u8 = tf.keras.layers.Conv2DTranspose(numFilters*2, (3, 3), strides = (2, 2), padding = 'same')(c7)\n    u8 = tf.keras.layers.concatenate([u8, c2])\n    u8 = tf.keras.layers.Dropout(droupouts)(u8)\n    c8 = Conv2dBlock(u8, numFilters * 2, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    u9 = tf.keras.layers.Conv2DTranspose(numFilters*1, (3, 3), strides = (2, 2), padding = 'same')(c8)\n    u9 = tf.keras.layers.concatenate([u9, c1])\n    u9 = tf.keras.layers.Dropout(droupouts)(u9)\n    c9 = Conv2dBlock(u9, numFilters * 1, kernelSize = 3, doBatchNorm = doBatchNorm)\n    \n    output = tf.keras.layers.Conv2D(3, (1, 1), activation = 'sigmoid')(c9)\n    model = tf.keras.Model(inputs = [inputImage], outputs = [output])\n    return model","3de838df":"inputs = tf.keras.layers.Input((256, 256, 1))\n#You can change the dropout\nmyTransformer = GiveMeUnet(inputs, droupouts= 0.1)\nmyTransformer.compile(optimizer = 'Adam', loss = tf.compat.v1.losses.mean_pairwise_squared_error, metrics = ['accuracy'] )","99c4c274":"retVal = myTransformer.fit(np.array(framObjTrain['with']), np.array(framObjTrain['without']), epochs = 3, verbose = 1)","e343bc64":"import gc\ngc.collect()","096f483f":"plt.plot(retVal.history['loss'], label = 'training_loss')\nplt.plot(retVal.history['accuracy'], label = 'training_accuracy')\nplt.legend()\nplt.grid(True)","9386234c":"## function for getting  predictions\ndef predict (valMap, model, shape = 256, num=1):\n    ## getting and proccessing val data\n    \n    predictwith = valMap['with']\n    predictwithout = valMap['without']\n    \n    #Num Predictions\n    predictwith = predictwith[0:num]\n    predictwithout = predictwithout[0:num] \n          \n    print(\"Shape of predictwith is : \"+str(np.shape(predictwith)))\n    print(\"Shape of predictwithout is : \"+str(np.shape(predictwithout)))\n     \n    conProc = np.array(predictwith)\n    print(\"Shape of new np is : \"+str(np.shape(conProc)))\n    \n    predictions = model.predict(conProc) \n    \n    for i in range(len(predictions)):\n        predictions[i] = cv2.merge((predictions[i,:,:,0],predictions[i,:,:,1],predictions[i,:,:,2]))    \n    return predictions, conProc, predictwithout","52326a79":"Prediction, actuals, masks = predict(framObjTrain, myTransformer,num=10)","e30cb434":"#Plotter(actuals[1], sixteenPrediction[1], masks[1])\n\ndef Plotter(img, predMask, groundTruth):\n    plt.figure(figsize=(20,10))\n    \n    plt.subplot(1,3,1)\n    plt.imshow(img, cmap = 'gray')\n    plt.title('Image base')\n    \n    ## Adding Image sharpening step here\n    ## it is a sharpening filter\n    filter = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]]) \n    imgSharpen = cv2.filter2D(predMask,-1,filter)\n    \n    plt.subplot(1,3,2)\n    plt.imshow(imgSharpen)\n    plt.title('Prediction ')\n    \n    plt.subplot(1,3,3)\n    plt.imshow(groundTruth)\n    plt.title('true')","977eb492":"print(\"Shape of Prediction is : \"+str(np.shape(Prediction[1])))\nprint(\"Shape of Original is   : \"+str(np.shape(actuals[1])))\nprint(\"Shape of Mask is      : \"+str(np.shape(masks[1])))","0fd2cafc":"Plotter(actuals[1], Prediction[1], masks[1])","b8dd3a63":"## defining a frame for image and mask storage\nframObjTest = {'without' : [],\n           'with' : []\n          }\n\ninit_test=200\nend_test=220","68d3eb05":"framObjTest = LoadData( framObjTest, init=init_test\n                        , end= end_test,withpath=withpath,withoutpath=withoutpath\n                        , shape = 256)","388522db":"## displaying data loaded by our function\nplt.subplot(1,2,1)\nplt.imshow(framObjTest['with'][0])\nplt.subplot(1,2,2)\nplt.imshow(framObjTest['without'][0])\nplt.show()","0379fe37":"Prediction, test, maskstest = predict(framObjTest, myTransformer,num=10)","3580691e":"Plotter(test[7], Prediction[7], maskstest[7])","5b56ad55":"! conda install -y gdown","01cb993d":"!gdown --id 1_YdXDKBJhib_R6aHMi-SwUedzwkMLa_4 --folder ","9abdd30b":"## defining a frame for image and mask storage\nframObjExt = {'without' : [],\n           'with' : []\n          }\nwithpathFiles='.\/images'\nwithoutpathFiles ='.\/images'\n\n#Init at end from the data \ninit_train=0\nend_train=5\nframObjExt = LoadData( framObjExt, init=init_train\n                        , end= end_train,withpath=withpathFiles,withoutpath=withoutpathFiles\n                        , shape = 256)","10269c42":"plt.subplot(1,2,1)\nplt.imshow(framObjExt['with'][4])\nplt.subplot(1,2,2)\nplt.imshow(framObjExt['without'][4])\nplt.show()","9fa3dd2b":"Prediction, test, maskstest = predict(framObjExt, myTransformer,num=5)","f4a7d5a7":"numimage=4\nPlotter(test[numimage], Prediction[numimage], maskstest[numimage])","00a7d28a":"#  ------------------------External data --------------------------------------","7d165e58":"**** It does not work correctly with external data, the shape of the mask was learned ****","8474ce96":"# --------------------------------- Test---------------------------------------------"}}