{"cell_type":{"b9f1cd7e":"code","e01a710a":"code","8c05bc11":"code","1edc048e":"code","094b5874":"code","5be8ad68":"code","43ecf6d8":"code","55ea399e":"code","517ce769":"code","d84f4482":"code","1374f38c":"code","d05173b4":"code","12c2e7ac":"code","a5b32b73":"code","c10a1ba5":"code","5c0eac4d":"code","0df4bfbe":"code","7653478c":"code","3f048166":"code","2fae0c58":"code","8874be2a":"markdown","8f7ccec2":"markdown","4b0b087b":"markdown","9ccf4caf":"markdown","5438133d":"markdown","4d563384":"markdown","cf1c6d56":"markdown","8a96ee76":"markdown","68159b6b":"markdown","213f71e6":"markdown","9d9236c0":"markdown","9248c8e0":"markdown","b0d65931":"markdown","d20fe201":"markdown","3c84565b":"markdown","0989ebaa":"markdown"},"source":{"b9f1cd7e":"from pathlib import Path\nimport numpy as np\nimport pandas as pd\nfrom tqdm.notebook import tqdm\nfrom skimage import io\nfrom multiprocessing import  Pool\nfrom functools import partial\nfrom timeit import default_timer as timer\ntqdm.pandas()","e01a710a":"annotations_path = Path('..\/input\/spacenet-7-change-detection-chips-and-masks\/annotations.csv')\nroot_dir = Path('..\/input\/spacenet-7-change-detection-chips-and-masks\/chip_dataset\/chip_dataset\/change_detection')","8c05bc11":"df = pd.read_csv(annotations_path)","1edc048e":"df.head()","094b5874":"def get_number_of_activated_pixels(mask_path,root_dir=root_dir):\n    # for optimization purposes,\n    # if path has 'blank' in it then number of activated pixels = 0\n    if 'blank' in mask_path:\n        return 0\n    \n    path = Path(root_dir\/mask_path)\n    im = io.imread(path)\n    n_activated = (im > 0).sum()\n    return n_activated","5be8ad68":"blank_mask_path = df[(df['is_blank'] == 'blank')]['mask_path'].iloc[0]\nblank_mask_path","43ecf6d8":"non_blank_mask_path = df[(df['is_blank'] != 'blank')]['mask_path'].iloc[0]\nnon_blank_mask_path","55ea399e":"get_number_of_activated_pixels(blank_mask_path)","517ce769":"get_number_of_activated_pixels(non_blank_mask_path)","d84f4482":"test_df = df[df['is_blank'] != 'blank']['mask_path'][0:10000]","1374f38c":"start = timer()\ntest = test_df.map(get_number_of_activated_pixels)\nend = timer()\nprint(end - start) # Time in seconds","d05173b4":"len(df)","12c2e7ac":"def parallelize(data, func, num_of_processes=8):\n    data_split = np.array_split(data, num_of_processes)\n    pool = Pool(num_of_processes)\n    data = pd.concat(pool.map(func, data_split))\n    pool.close()\n    pool.join()\n    return data\n\ndef run_on_subset(func, data_subset):\n    return data_subset.map(func)\n\ndef parallelize_on_rows(data, func, num_of_processes=8):\n    return parallelize(data, partial(run_on_subset, func), num_of_processes)","a5b32b73":"start = timer()\ntest = parallelize_on_rows(test_df, get_number_of_activated_pixels);\nend = timer()\nprint(end - start)","c10a1ba5":"df['n_change_pix'] = parallelize_on_rows(df['mask_path'], get_number_of_activated_pixels);","5c0eac4d":"df['period_1'] = df.progress_apply(lambda x: pd.Period(year=x['year1'],month=x['month1'],freq='M'),axis=1)","0df4bfbe":"df['period_2'] = df.progress_apply(lambda x: pd.Period(year=x['year2'],month=x['month2'],freq='M'),axis=1)","7653478c":"df.head()","3f048166":"df['month_diff'] = df.progress_apply(lambda x: abs((x['period_1']-x['period_2']).n), axis=1)","2fae0c58":"df.to_csv('annotations.csv',index=False)","8874be2a":"## Read CSV into Pandas Dataframe","8f7ccec2":"Our time is not too great. It took us more than 100 seconds to process 10000 images, we have a total of more than 3 million images.\nLet's make our programme faster by parellelizing our programe with the helper functions below.","4b0b087b":"#### Example Path for Non-Blank Mask","9ccf4caf":"# Calculating Number of Pixels in Change\nIn our previous notebooks we augmented our dataset by obtaining the difference of 2 satellite images capturing the same location but different times.\nIn order to further our understanding of the our dataset we will calculate the number of pixels that actaully have change in them for all of our images, and we will store them in our annotations csv.\n\nThis can help us determine the conditions for our models performance in the evaluation phase.","5438133d":"#### Example Path for Blank Mask","4d563384":"## Calculating the Number of Months Apart for Each Image Couple\nBelow we will loop over the entire dataframe and use the time periods that we created earlier in order to calculate the number of months that the images are apart.","cf1c6d56":"Let's compare the time taken to process the same 10000 images.","8a96ee76":"## Obtaining the number of pixels for all the rows\nBelow we use the function we created earlier to extract the number of pixels containing change from each image in the dataset.","68159b6b":"## Saving the Output Dataframe as a CSV","213f71e6":"## Import Dependencies","9d9236c0":"Great!!\n\nThat's over a 20 times increase in performance, and the gap in performance will only widen as we increase the number of images we are processing.","9248c8e0":"Below we check that the masks obtained are indeed correct.","b0d65931":"Let's check how long it takes to process 10000 images by using the python timeit module imported earlier. We wil time how long it takes to read the non-blank images as they are more cpu intensive.","d20fe201":"## Creating Time Periods\nBelow we will create columns for the time periods that each image was caputered in. This will be helpful later on in case we need to calculate time based statistics. \n`period_1` and `period_2` are the dates in which the first image and second image were captured respectively.","3c84565b":"## Set Paths","0989ebaa":"### Obtain Number of Activated Pixels\nThe helper function below accepts the path to the mask that we want to extract the number of pixels from. Since the mask if either positive or blank, we can simply calculate the number of pixels by summing the values that return true when they are greater than 0."}}