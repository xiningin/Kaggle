{"cell_type":{"36022336":"code","0c984e45":"code","ad7e7435":"code","21d11ff5":"code","70ec78c9":"code","f95e6b6d":"code","19c012fb":"code","32164a92":"code","b0ea77d2":"code","50a793e0":"code","1bda9770":"code","22472edc":"code","35c79d71":"code","b3ffeb89":"code","b1f357bb":"code","cff1d7fe":"code","9cb5b875":"code","97f7f922":"code","903167d2":"code","da7a8ce2":"code","168970aa":"code","de8a0bd7":"code","e768b810":"code","0494cca1":"code","05661e18":"code","e6fc6bc6":"code","efae255f":"code","0e62eec3":"code","916be0fa":"code","697e8065":"code","e3cb1502":"code","792fde24":"code","b841bfe6":"code","b43719dc":"code","c2a42b50":"code","ffd838c5":"code","b4ca0376":"code","68614cde":"code","26be4adf":"code","b1d190d2":"code","f7007cce":"code","eb6ed972":"code","4f2a2e50":"code","3fd715fb":"code","4bdd81b0":"code","806a5b3e":"code","10170abf":"code","158e46d6":"code","dbdd14e0":"code","477fb1ee":"code","7b35fdee":"code","1f6a1859":"code","e05c1352":"markdown","3ab7ce5e":"markdown","87580666":"markdown","4d2fc7a8":"markdown","c1daddd1":"markdown","10fadea7":"markdown","dae779cf":"markdown","782d4607":"markdown","14c6b1f2":"markdown","f29bf219":"markdown","ddede597":"markdown","ac35d842":"markdown","9346a43b":"markdown","cd52ea53":"markdown","ba3f0324":"markdown","fca299fa":"markdown","43d6e212":"markdown","90570184":"markdown","ecc98b4d":"markdown","bb97104a":"markdown","032428fa":"markdown","93946896":"markdown","8c6a944b":"markdown","32f019e6":"markdown","6b2f08fe":"markdown","3a2e8bd0":"markdown","35b3eb5e":"markdown","c3cab87a":"markdown","6362bd11":"markdown","34b57d37":"markdown","0f27c14a":"markdown","cea429c3":"markdown","ae5e78cb":"markdown","3849362b":"markdown","45d4326f":"markdown"},"source":{"36022336":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np\nimport pandas as pd\n\npd.set_option('display.max_rows', 500)\npd.set_option('display.max_columns', 500)\npd.set_option('display.width', 1000)\n\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\n\n# Data Viz\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# sklearn\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\n\n# Modelling\nfrom xgboost import XGBRegressor\nimport lightgbm as lgb\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","0c984e45":"train = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')\nsubmission = pd.read_csv('..\/input\/sample_submission.csv')","ad7e7435":"train.head(3)","21d11ff5":"print(f'Shape of Train Set: {train.shape}')\nprint(f'Shape of Test Set : {test.shape}')","70ec78c9":"def plot_dtypes(df):\n    # Get dataframe with count of each dtype\n    dtypes = pd.DataFrame(df.dtypes, columns = ['dtype'])\n    dtypes = dtypes.groupby('dtype').size().rename('count').reset_index()\n    \n    # Plot resulting dataframe\n    ax = dtypes.sort_values('count').plot(\n        'dtype',\n        kind = 'barh', \n        figsize=(8,6), \n        title='Number of Distinct Data Types in Dataset', \n        legend = None, \n        color = '#c19a6b'\n        )\n    \n    # List that will hold plt.patches data\n    totals = []\n\n    # Append patch values to list\n    for i in ax.patches:\n        totals.append(i.get_width())\n\n    # Denominator for percentage\n    total = sum(totals)\n\n    # Set individual bar lables\n    for i in ax.patches:\n        # get_width to move left or right; get_y to move up or down\n        # For regular bar, switch get_width and get_y \n        # Change get_width to get_height, get_y to get_x\n        ax.text(\n            i.get_width() + .3, i.get_y() + .2,\n            str(round((i.get_width() \/ total)*100, 2))+'%', \n            fontsize=12,\n            color='blue'\n        )\n    \n    plt.style.use('ggplot')\n    plt.show()","f95e6b6d":"plot_dtypes(train)","19c012fb":"def plot_missing(df, showplot = True):\n    \n    # Get dataframe with percentage of missing values\n    missing = pd.DataFrame(df.isnull().sum(), columns = ['perc_missing'])\n    missing = missing.loc[missing['perc_missing'] > 0]\n    missing = (missing\/len(df))*100\n    \n    # Plot resulting dataframe\n    missing = missing.sort_values('perc_missing')\n    if(showplot):\n        ax = missing.plot(\n            kind = 'barh',\n            figsize=(10,8),\n            title = 'Percentage of Missing Values in Dataset by Feature',\n            legend = None,\n            color = 'coral'\n        )\n\n        # Set individual bar lables\n        for i in ax.patches:\n            # get_width to move left or right; get_y to move up or down\n            ax.text(\n                i.get_width()+.3, i.get_y(),\n                str(round(i.get_width(), 2)), \n                fontsize=12,\n                color='blue'\n            )\n\n        plt.style.use('ggplot')\n        plt.show()\n    \n    return missing","32164a92":"missing_train = plot_missing(train)\nmissing_test = plot_missing(test)","b0ea77d2":"def plot_categorical_column(df, col, target, size, *subcols):\n    num_subcols = len(subcols) \n    # Two charts per subcolumn\n    rows_subcols = num_subcols*2\n    # Two charts for required categorical feature\n    plots_total = 2 + rows_subcols\n    \n    fig_shape = (plots_total, 1)\n    # Height should be a factor of total plots\n    fig = plt.figure(figsize=(18, 4*plots_total*size))\n    plt.subplots_adjust(hspace=0.5)\n    \n    # First plot for required categorical feature\n    # Plot distribution\n    ax1 = plt.subplot2grid(fig_shape, (0,0))\n    df[col].value_counts(dropna = False, sort = True).plot(\n        kind = 'barh', \n        ax = ax1, \n        title = 'Categorical Count for ' + col\n    )\n    \n    # Second plot for required categorical feature\n    # Plot median of target variable for each unique value in main categorical feature\n    ax2 = plt.subplot2grid(fig_shape, (1,0))\n    df[[col, target]].groupby(col).median().plot(\n        kind = 'barh', \n        ax = ax2, \n        title = 'Median of ' + target + ' with respect to ' + col, \n        legend = None\n    )\n    \n    # Generate two plots for subcolumns\n    for i, subcol in zip(range(num_subcols), subcols):\n        \n        # First subcolumn plot\n        ax = plt.subplot2grid(fig_shape, (2*i + 2,0))\n        # If subcolumn has null values, plot interaction of null values\n        if df[subcol].isnull().sum():\n            df[[col, subcol]].loc[df[subcol].isnull() == True].groupby(col).size().plot(\n                kind = 'barh', \n                ax = ax, \n                title = 'Amount of Nulls in ' + subcol + ' with respect to ' + col\n            )\n        else:\n            if df[subcol].dtype != 'O':\n                # If no null values, and a number, plot histogram\n                df[subcol].plot(\n                    kind = 'hist', \n                    bins = 100,\n                    ax = ax, \n                    title = 'Histogram for ' + subcol, \n                    color = 'orange'\n                )\n            else:\n                # If no null values, and an object (categorical feature), plot distribution\n                df[subcol].value_counts().plot(\n                    kind = 'barh', \n                    ax = ax, \n                    title = 'Categorical counts for ' + subcol\n                )\n                \n        # Second subcolumn plot \n        ax = plt.subplot2grid(fig_shape, (2*i + 3,0))\n        # If numeric field, plot median for each unique value in main categorical feature\n        if df[subcol].dtype != 'O':\n            df[[col, subcol]].groupby(col).median().plot(\n                kind = 'barh', \n                ax = ax, \n                title = 'Median Value of ' + subcol + ' with respect to ' + col, \n                legend = None\n            )\n        else:\n            # If categorical field, plot stacked interactions of both categories\n            df.groupby([col, subcol]).size().unstack().plot(\n                kind = 'barh', \n                ax = ax, \n                title = 'Stacked category interactions for ' + col + ' ' + subcol, \n                cmap = plt.get_cmap('tab20')\n            )\n        \n    plt.style.use('ggplot')\n    plt.show()","50a793e0":"plot_categorical_column(train, 'MSZoning', 'SalePrice', 1, 'LotFrontage', 'LotArea')","1bda9770":"plot_categorical_column(train, 'Neighborhood', 'SalePrice', 2, 'LotFrontage')","22472edc":"fig = plt.figure(figsize = (24, 12))\n\ncorr = train.corr()\n\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\nsns.heatmap(\n    corr, \n    mask = mask, \n    cmap = 'PiYG', \n    annot = True, \n    fmt=\".2f\")\n\nplt.yticks(rotation=0) \nplt.xticks(rotation=90)\nplt.title('Correlation Matrix for Train Data', fontsize = 15)\nplt.show()","35c79d71":"new_train = train.copy()\nnew_test = test.copy()\n\nnew_train.drop('Id', axis = 1, inplace = True)\nnew_test.drop('Id', axis = 1, inplace = True)","b3ffeb89":"fig = plt.figure(figsize = (24, 9))\nsns.boxplot(\n    x = new_train['Neighborhood'],\n    y = new_train['LotFrontage'],\n)\nplt.show()","b1f357bb":"lotfrontage_by_neighborhood = new_train.groupby(['Neighborhood'])['LotFrontage'].agg({\n    'median': np.median,\n    'count': np.size,\n    'std': np.std,\n}).reset_index()\nlotfrontage_by_neighborhood.T","cff1d7fe":"def fill_lot_frontage(row):\n    return lotfrontage_by_neighborhood[lotfrontage_by_neighborhood['Neighborhood'] == row['Neighborhood']]['median'].values[0]","9cb5b875":"new_train['LotFrontage'] = new_train.apply(lambda row: fill_lot_frontage(row) if np.isnan(row['LotFrontage']) else row['LotFrontage'], axis=1)\nnew_test['LotFrontage'] = new_test.apply(lambda row: fill_lot_frontage(row) if np.isnan(row['LotFrontage']) else row['LotFrontage'], axis=1)","97f7f922":"fig = plt.figure(figsize = (8, 6))\nplt.subplots_adjust(hspace=0.5)\n\nfig_shape = (2,2)\n\nax1 = plt.subplot2grid(fig_shape, (0,0))\ntrain.LotFrontage.plot(\n    kind = 'hist',\n    ax = ax1, \n    bins = 40,\n    title = 'Original Distribution: Train'\n)\n\n\nax1 = plt.subplot2grid(fig_shape, (0,1))\nnew_train.LotFrontage.plot(\n    kind = 'hist', \n    ax = ax1, \n    bins = 40,\n    title = 'Without missing values: Train'\n)\n\nax1 = plt.subplot2grid(fig_shape, (1,0))\ntest.LotFrontage.plot(\n    kind = 'hist',\n    ax = ax1, \n    bins = 40,\n    title = 'Original Distribution: Test'\n)\n\n\nax1 = plt.subplot2grid(fig_shape, (1,1))\nnew_test.LotFrontage.plot(\n    kind = 'hist', \n    ax = ax1, \n    bins = 40,\n    title = 'Without missing values: Test'\n)\n\n\nplt.show()","903167d2":"new_train[\"PoolQC\"] = new_train[\"PoolQC\"].fillna(\"None\")\nnew_test[\"PoolQC\"] = new_test[\"PoolQC\"].fillna(\"None\")","da7a8ce2":"new_train[\"MiscFeature\"] = new_train[\"MiscFeature\"].fillna(\"None\")\nnew_test[\"MiscFeature\"] = new_test[\"MiscFeature\"].fillna(\"None\")","168970aa":"new_train[\"Alley\"] = new_train[\"Alley\"].fillna(\"None\")\nnew_test[\"Alley\"] = new_test[\"Alley\"].fillna(\"None\")","de8a0bd7":"new_train[\"Fence\"] = new_train[\"Fence\"].fillna(\"None\")\nnew_test[\"Fence\"] = new_test[\"Fence\"].fillna(\"None\")","e768b810":"new_train[\"FireplaceQu\"] = new_train[\"FireplaceQu\"].fillna(\"None\")\nnew_test[\"FireplaceQu\"] = new_test[\"FireplaceQu\"].fillna(\"None\")","0494cca1":"# Categorical\nfor col in ('GarageType', 'GarageFinish', 'GarageQual', 'GarageCond'):\n    new_train[col] = new_train[col].fillna('None')\n    new_test[col] = new_test[col].fillna('None')\n    \n# Numeric\nfor col in ('GarageYrBlt', 'GarageArea', 'GarageCars'):\n    new_train[col] = new_train[col].fillna(0)\n    new_test[col] = new_test[col].fillna(0)","05661e18":"# Categorical\nfor col in ('BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2'):\n    new_train[col] = new_train[col].fillna('None')\n    new_test[col] = new_test[col].fillna('None')\n    \n# Numeric\nfor col in ('BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF','TotalBsmtSF', 'BsmtFullBath', 'BsmtHalfBath'):\n    new_train[col] = new_train[col].fillna(0)\n    new_test[col] = new_test[col].fillna(0)","e6fc6bc6":"# Categorical\nnew_train[\"MasVnrType\"] = new_train[\"MasVnrType\"].fillna(\"None\")\nnew_test[\"MasVnrType\"] = new_test[\"MasVnrType\"].fillna(\"None\")\n\n#Numeric\nnew_train[\"MasVnrArea\"] = new_train[\"MasVnrArea\"].fillna(0)\nnew_test[\"MasVnrArea\"] = new_test[\"MasVnrArea\"].fillna(0)","efae255f":"new_test['MSZoning'] = new_test['MSZoning'].fillna(train['MSZoning'].mode()[0])","0e62eec3":"missing_new_train = plot_missing(new_train, showplot = False)\nmissing_new_train","916be0fa":"missing_new_test = plot_missing(new_test, showplot = False)\nmissing_new_test","697e8065":"cols_to_drop = []\ncols_to_clean = []","e3cb1502":"def handle_na(train, test, cols_to_clean, cols_to_drop):\n    if(cols_to_drop):\n        train.drop(cols_to_drop, axis = 1, inplace = True)\n        test.drop(cols_to_drop, axis = 1, inplace = True)\n    \n    if(cols_to_clean):\n        for col in cols_to_clean:\n            train[col+'_is_na'] = train[col].isnull()\n            test[col+'_is_na'] = test[col].isnull()\n        \n    for col in test.columns:\n        # If numeric, fill with median\n        if np.issubdtype(train[col].dtype, np.number):\n            train.loc[train[col].isnull() == True, col] = train[col].median()\n            test.loc[test[col].isnull() == True, col] = train[col].median()\n\n        # If object, fill with mode\n        if (train[col].dtype == 'O'):\n            train.loc[train[col].isnull() == True, col] = train[col].mode().iloc[0]\n            test.loc[test[col].isnull() == True, col] = train[col].mode().iloc[0]\n            \n    print(f'Shape of Train Set: {train.shape}')\n    print(f'Shape of Test Set : {test.shape}')\n\n    return train, test","792fde24":"new_train, new_test = handle_na(new_train, new_test, cols_to_clean, cols_to_drop)","b841bfe6":"def label_encode(train, test):\n    combined = train.append(test, sort = False)\n    for col in test.columns:\n        if (train[col].dtype == 'O'):\n            le = LabelEncoder()\n            le.fit(combined[col])\n            train[col] = le.transform(train[col])\n            test[col] = le.transform(test[col])\n            \n    return train, test","b43719dc":"new_train, new_test = label_encode(new_train, new_test)","c2a42b50":"new_train['TotalSF'] = new_train['TotalBsmtSF'] + new_train['1stFlrSF'] + new_train['2ndFlrSF']\nnew_test['TotalSF'] = new_test['TotalBsmtSF'] + new_test['1stFlrSF'] + new_test['2ndFlrSF']","ffd838c5":"new_train['SalePrice'] = np.log(new_train['SalePrice'])","b4ca0376":"def split(df, target, test_size = 0.1):\n    X_train, X_valid, y_train, y_valid = train_test_split(df.drop(target, axis = 1), df[target], test_size = test_size, random_state = 42)\n    print(f'Shape of Train Set: {X_train.shape}')\n    print(f'Shape of Valid Set: {X_valid.shape}')\n    return X_train, X_valid, y_train, y_valid","68614cde":"X_train, X_valid, y_train, y_valid = split(new_train, 'SalePrice')","26be4adf":"def xgtrain(X_train, X_valid, y_train, y_valid):\n    regressor = XGBRegressor(\n        n_estimators = 50000, \n        learning_rate = 0.01,\n        max_depth = 3, \n        subsample = 0.5, \n        colsample_bytree = 0.2\n        )\n    \n    regressor_ = regressor.fit(\n        X_train.values, y_train.values, \n        eval_metric = 'rmse', \n        eval_set = [\n            (X_train.values, y_train.values), \n            (X_valid.values, y_valid.values)\n        ],\n        verbose = 1000,\n        early_stopping_rounds = 500,\n        )\n    \n    return regressor_","b1d190d2":"%%time\nregressor_ = xgtrain(X_train, X_valid, y_train, y_valid)","f7007cce":"def lgbtrain(X_train, y_train, X_valid, y_valid):\n    lgb_train = lgb.Dataset(X_train, y_train)\n    lgb_eval = lgb.Dataset(X_valid, y_valid, reference=lgb_train)\n\n    params = {\n        'boosting_type': 'gbdt',\n        'objective': 'regression',\n        'metric': {'l2_root'},\n        'max_depth': 3,\n        'learning_rate': 0.01,\n        'feature_fraction': 0.2,\n        'bagging_fraction': 0.8,\n        'bagging_freq': 5,\n        'num_leaves': 5\n    }\n    \n    gbm = lgb.train(\n        params,\n        lgb_train,\n        valid_sets = lgb_eval,\n        num_boost_round=50000,\n        early_stopping_rounds=100,\n        verbose_eval = 250\n    )\n    \n    return gbm","eb6ed972":"%%time\ngbm = lgbtrain(X_train, y_train, X_valid, y_valid)","4f2a2e50":"def plot_feature_importance():\n    df_fi = pd.DataFrame(columns = ['features', 'importance'])\n    df_fi['features'] = new_test.columns \n    df_fi['importance'] = regressor_.feature_importances_\n    \n    ax = df_fi.sort_values('importance').plot(\n        'features',\n        kind = 'barh',\n        legend = None,\n        title = 'Feature Importances',\n        figsize = (18, 25),\n        color = 'crimson'\n       )\n    \n    \n    # List that will hold plt.patches data\n    totals = []\n\n    # Append patch values to list\n    for i in ax.patches:\n        totals.append(i.get_width())\n    \n    # Set individual bar lables\n    for i in ax.patches:\n        # get_width to move left or right; get_y to move up or down\n        ax.text(\n            i.get_width() + 0.001, i.get_y(),\n            str(round(i.get_width(), 3)), \n            fontsize=14,\n            color='blue'\n        )\n    \n    plt.style.use('ggplot')\n    plt.yticks(fontsize=14)\n    plt.show()","3fd715fb":"plot_feature_importance()","4bdd81b0":"def prepare_submission(comment = 'latest'):\n    xgb_preds = np.exp(regressor_.predict(new_test.values))\n    lgb_preds = np.expm1(gbm.predict(new_test.values))\n    submission['SalePrice'] = 0.75*xgb_preds + 0.25*lgb_preds\n    submission.to_csv('submission' + comment + '.csv', index=False)\n    print(submission.head())","806a5b3e":"prepare_submission('_ensemble')","10170abf":"from IPython.display import FileLinks\nFileLinks('.')","158e46d6":"new_train.to_feather('new_train')\nnew_test.to_feather('new_test')","dbdd14e0":"# train[['GarageType', 'GarageYrBlt', 'GarageFinish', 'GarageCars', 'GarageArea', 'GarageQual', 'GarageCond', 'YearBuilt']]","477fb1ee":"train['GarageYrBlt'].plot(kind = 'hist')\nplt.show()","7b35fdee":"train['YearBuilt'].plot(kind = 'hist')\nplt.show()","1f6a1859":"(train['GarageYrBlt'] - train['YearBuilt']).plot(kind = 'hist')\nplt.show()","e05c1352":"#### Plotting features with missing values","3ab7ce5e":"Preserve original train and test dataframe","87580666":"#### PoolQC","4d2fc7a8":"#### Masonry veneer Features","c1daddd1":"#### MSZoning","10fadea7":"The distribution of missing values in train set and test set are quite similar. We will deal with these missing values in the data cleaning section.","dae779cf":"## Training","782d4607":"### XGBoost","14c6b1f2":"#### Remaining Features","f29bf219":"The function *plot_missing* identifies the percentage of missing rows for every feature in our dataset.","ddede597":"## EDA","ac35d842":"#### Alley","9346a43b":"Let's take a quick look at the dataset","cd52ea53":"## Reading Data","ba3f0324":"## Prepare Submission","fca299fa":"#### Fence","43d6e212":"## Data Cleaning","90570184":"#### Plotting features and their interactions","ecc98b4d":"#### FireplaceQu","bb97104a":"In our EDA section, we found the relationship between *Neighborhood* and *LotFrontage*. To handle missing values, we can use the median *LotFrontage* for each neighborhood. To dig into this idea a little more, let's draw a boxplot for these two features.","032428fa":"### LightGBM","93946896":"The function *plot_dtypes* identifies the number of distinct data types in our dataset.","8c6a944b":"#### Plotting Data Types","32f019e6":"## Feature Engineering","6b2f08fe":"### Label Encoding","3a2e8bd0":"#### Total Square Footage","35b3eb5e":"The funciton *plot_categorical_column* allows us to observe a distribution for the categorical variable and its interactions with the target variable and other subcolumns.","c3cab87a":"#### Basement Features","6362bd11":"#### Garage Features","34b57d37":"### Feature Importances","0f27c14a":"### Generating Validation Set","cea429c3":"### Handle Missing Values","ae5e78cb":"#### Lot Frontage","3849362b":"#### MiscFeature","45d4326f":"#### Correlation Matrix"}}