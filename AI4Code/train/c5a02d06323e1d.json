{"cell_type":{"2dc8e612":"code","f8bcfe09":"code","0ec10f9e":"code","26ca607b":"code","9a0824bd":"code","0971db04":"code","a52b9d87":"code","1c9011fb":"code","ca99aeeb":"code","6cf253d7":"code","d3979785":"code","d78ed582":"code","45c13dd6":"code","fae32181":"markdown","5b7c115d":"markdown"},"source":{"2dc8e612":"!pip install pulp","f8bcfe09":"import itertools\n\nimport numpy as np\nimport pandas as pd\nfrom scipy.spatial import distance_matrix\nimport matplotlib\nimport matplotlib.pylab as plt\nimport seaborn as sns\nimport pulp\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","0ec10f9e":"# define TSP\n\nn_customer = 9\nn_point = n_customer + 1\n\ndf = pd.DataFrame({\n    'x': np.random.randint(0, 100, n_point),\n    'y': np.random.randint(0, 100, n_point),\n})\n\ndf.iloc[0]['x'] = 0\ndf.iloc[0]['y'] = 0\n\ndf","26ca607b":"# get distance matrix\n\ndistances = pd.DataFrame(distance_matrix(df[['x', 'y']].values, df[['x', 'y']].values), index=df.index, columns=df.index).values\n\nfig, ax = plt.subplots(figsize=(8, 7))\nsns.heatmap(distances, ax=ax, cmap='Blues', annot=True, fmt='.0f', cbar=True, cbar_kws={\"shrink\": .3}, linewidths=.1)\nplt.title('distance matrix')\nplt.show()","9a0824bd":"# check TSP state\n\nplt.figure(figsize=(5, 5))\n\n# draw problem state\nfor i, row in df.iterrows():\n    if i == 0:\n        plt.scatter(row['x'], row['y'], c='r')\n        plt.text(row['x'] + 1, row['y'] + 1, 'depot')\n    else:\n        plt.scatter(row['x'], row['y'], c='black')\n        plt.text(row['x'] + 1, row['y'] + 1, f'{i}')\n        \nplt.xlim([-10, 110])\nplt.ylim([-10, 110])\nplt.title('points: id')\nplt.show()","0971db04":"%%time\n\n# set problem\nproblem = pulp.LpProblem('tsp_mip', pulp.LpMinimize)\n\n# set valiables\nx = pulp.LpVariable.dicts('x', ((i, j) for i in range(n_point) for j in range(n_point)), lowBound=0, upBound=1, cat='Binary')\n# we need to keep track of the order in the tour to eliminate the possibility of subtours\nu = pulp.LpVariable.dicts('u', (i for i in range(n_point)), lowBound=1, upBound=n_point, cat='Integer')\n\n# set objective function\nproblem += pulp.lpSum(distances[i][j] * x[i, j] for i in range(n_point) for j in range(n_point))\n\n# set constrains\nfor i in range(n_point):\n    problem += x[i, i] == 0\n\nfor i in range(n_point):\n    problem += pulp.lpSum(x[i, j] for j in range(n_point)) == 1\n    problem += pulp.lpSum(x[j, i] for j in range(n_point)) == 1\n\n# eliminate subtour\nfor i in range(n_point):\n    for j in range(n_point):\n        if i != j and (i != 0 and j != 0):\n            problem += u[i] - u[j] <= n_point * (1 - x[i, j]) - 1\n            \n# solve problem\nstatus = problem.solve()\n\n# output status, value of objective function\nstatus, pulp.LpStatus[status], pulp.value(problem.objective)","a52b9d87":"# check TSP problem and optimized route\n\nplt.figure(figsize=(5, 5))\n\n# draw problem state\nfor i, row in df.iterrows():\n    if i == 0:\n        plt.scatter(row['x'], row['y'], c='r')\n        plt.text(row['x'] + 1, row['y'] + 1, 'depot')\n        \n    else:\n        plt.scatter(row['x'], row['y'], c='black')\n        plt.text(row['x'] + 1, row['y'] + 1, f'{i}')\n        \nplt.xlim([-10, 110])\nplt.ylim([-10, 110])\nplt.title('points: id')\n\n# draw optimal route\nroutes = [(i, j) for i in range(n_point) for j in range(n_point) if pulp.value(x[i, j]) == 1]\narrowprops = dict(arrowstyle='->', connectionstyle='arc3', edgecolor='blue')\nfor i, j in routes:\n    plt.annotate('', xy=[df.iloc[j]['x'], df.iloc[j]['y']], xytext=[df.iloc[i]['x'], df.iloc[i]['y']], arrowprops=arrowprops)\n                \nplt.show()","1c9011fb":"# define VRP\n\nn_customer = 9\nn_point = n_customer + 1\nvehicle_capacity = 8\n\ndf = pd.DataFrame({\n    'x': np.random.randint(0, 100, n_point),\n    'y': np.random.randint(0, 100, n_point),\n    'demand': np.random.randint(1, 5, n_point),\n})\n\ndf.iloc[0]['x'] = 0\ndf.iloc[0]['y'] = 0\ndf.iloc[0]['demand'] = 0\n\ndf","ca99aeeb":"# get distance matrix\n\ndistances = pd.DataFrame(distance_matrix(df[['x', 'y']].values, df[['x', 'y']].values), index=df.index, columns=df.index).values\n\nfig, ax = plt.subplots(figsize=(8, 7))\nsns.heatmap(distances, ax=ax, cmap='Blues', annot=True, fmt='.0f', cbar=True, cbar_kws={\"shrink\": .3}, linewidths=.1)\nplt.title('distance matrix')\nplt.show()","6cf253d7":"# check VRP state\n\nplt.figure(figsize=(5, 5))\n\n# draw problem state\nfor i, row in df.iterrows():\n    if i == 0:\n        plt.scatter(row['x'], row['y'], c='r')\n        plt.text(row['x'] + 1, row['y'] + 1, 'depot')\n    else:\n        plt.scatter(row['x'], row['y'], c='black')\n        demand = row['demand']\n        plt.text(row['x'] + 1, row['y'] + 1, f'{i}({demand})')\n        \nplt.xlim([-10, 110])\nplt.ylim([-10, 110])\nplt.title('points: id(demand)')\nplt.show()","d3979785":"%%time\n\ndemands = df['demand'].values\n\n# set problem\nproblem = pulp.LpProblem('cvrp_mip', pulp.LpMinimize)\n\n# set variables\nx = pulp.LpVariable.dicts('x', ((i, j) for i in range(n_point) for j in range(n_point)), lowBound=0, upBound=1, cat='Binary')\nn_vehicle = pulp.LpVariable('n_vehicle', lowBound=0, upBound=100, cat='Integer')\n\n# set objective function\nproblem += pulp.lpSum([distances[i][j] * x[i, j] for i in range(n_point) for j in range(n_point)])\n\n# set constrains\nfor i in range(n_point):\n    problem += x[i, i] == 0\n    \nfor i in range(1, n_point):\n    problem += pulp.lpSum(x[j, i] for j in range(n_point)) == 1\n    problem += pulp.lpSum(x[i, j] for j in range(n_point)) == 1\n        \nproblem += pulp.lpSum(x[i, 0] for i in range(n_point)) == n_vehicle\nproblem += pulp.lpSum(x[0, i] for i in range(n_point)) == n_vehicle\n\n# eliminate subtour\nsubtours = []\nfor length in range(2, n_point):\n     subtours += itertools.combinations(range(1, n_point), length)\n\nfor st in subtours:\n    demand = np.sum([demands[s] for s in st])\n    arcs = [x[i, j] for i, j in itertools.permutations(st, 2)]\n    problem += pulp.lpSum(arcs) <= np.max([0, len(st) - np.ceil(demand \/ vehicle_capacity)])\n\n# solve problem\nstatus = problem.solve()\n\n# output status, value of objective function\nstatus, pulp.LpStatus[status], pulp.value(problem.objective)","d78ed582":"pulp.value(n_vehicle)","45c13dd6":"# check TSP problem and optimized route\n\nplt.figure(figsize=(5, 5))\n\n# draw problem state\nfor i, row in df.iterrows():\n    if i == 0:\n        plt.scatter(row['x'], row['y'], c='r')\n        plt.text(row['x'] + 1, row['y'] + 1, 'depot')\n    else:\n        plt.scatter(row['x'], row['y'], c='black')\n        demand = row['demand']\n        plt.text(row['x'] + 1, row['y'] + 1, f'{i}({demand})')\n        \nplt.xlim([-10, 110])\nplt.ylim([-10, 110])\nplt.title('points: id(demand)')\n\n# draw optimal route\ncmap = matplotlib.cm.get_cmap('Dark2')\nroutes = [(i, j) for i in range(n_point) for j in range(n_point) if pulp.value(x[i, j]) == 1]\n\nfor v in range(int(pulp.value(n_vehicle))):\n    \n    # identify the route of each vehicle\n    vehicle_route = [routes[v]]\n    while vehicle_route[-1][1] != 0:\n        for p in routes:\n            if p[0] == vehicle_route[-1][1]:\n                vehicle_route.append(p)\n                break\n\n    # draw for each vehicle\n    arrowprops = dict(arrowstyle='->', connectionstyle='arc3', edgecolor=cmap(v))\n    for i, j in vehicle_route:\n        plt.annotate('', xy=[df.iloc[j]['x'], df.iloc[j]['y']], xytext=[df.iloc[i]['x'], df.iloc[i]['y']], arrowprops=arrowprops)\n                \nplt.show()","fae32181":"## Traveling Salesman Problem; TSP","5b7c115d":"## Vehicle Routing Problem; VRP"}}