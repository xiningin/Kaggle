{"cell_type":{"6f1064a7":"code","5e4afbde":"code","2d5c79bf":"code","426a7adc":"code","e4959608":"code","09ace2b4":"markdown"},"source":{"6f1064a7":"import numpy as np # linear algebra\nimport pandas as pd  # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom tqdm.notebook import tqdm; tqdm.pandas()\nimport matplotlib.pyplot as plt\nimport os\nimport ast","5e4afbde":"TRAIN_OUTPUT_DIR = \"\/kaggle\/working\/hpa_cell_mask\/train\"\nos.makedirs(TRAIN_OUTPUT_DIR, exist_ok=True)\n\nTEST_OUTPUT_DIR = \"\/kaggle\/working\/hpa_cell_mask\/test\"\nos.makedirs(TEST_OUTPUT_DIR, exist_ok=True)\n\nTRAIN_CSV = os.path.join(\"\/kaggle\/input\", \"hpa-train-data-with-additional-metadata\", \"updated_train.csv\")\nSS_CSV = os.path.join(\"\/kaggle\/input\",\"hpa-sample-submission-with-extra-metadata\", \"updated_sample_submission.csv\")\n\ntrain_df = pd.read_csv(TRAIN_CSV)\nss_df = pd.read_csv(SS_CSV)\n\ntrain_df.mask_rles = train_df.mask_rles.progress_apply(lambda x: ast.literal_eval(x))\nss_df.mask_rles = ss_df.mask_rles.progress_apply(lambda x: ast.literal_eval(x))\n\ndisplay(train_df)\ndisplay(ss_df)","2d5c79bf":"def rle_to_mask(rle_string, height, width, output_val=1):\n    \"\"\" Convert RLE sttring into a binary mask \n    \n    Args:\n        rle_string (rle_string): Run length encoding containing \n            segmentation mask information\n        height (int): Height of the original image the map comes from\n        width (int): Width of the original image the map comes from\n    \n    Returns:\n        Numpy array of the binary segmentation mask for a given cell\n    \"\"\"\n\n    rle_numbers = [int(num_string) for num_string in rle_string.split(' ')]\n    rle_pairs = np.array(rle_numbers).reshape(-1,2)\n    img = np.zeros(height*width,dtype=np.uint8)\n    for index,length in rle_pairs:\n        index -= 1\n        img[index:index+length] = output_val\n    img = img.reshape(width,height).T\n    return img\n\ndef flatten_list_of_lists(l_o_l):\n    return [item for sublist in l_o_l for item in sublist]","426a7adc":"def save_masks_to_numpy(df, output_dir):\n    mask_rles = df.mask_rles.values\n    shapes = df.ImageWidth.values\n    ids = df.ID.values\n\n    for _id, shape, mask_list in tqdm(zip(ids, shapes, mask_rles), total=len(df)):\n        cell_mask = sum([\n            np.array(rle_to_mask(rle_string, shape, shape, output_val=i+1)) \\\n            for i,rle_string in enumerate(mask_list)\n        ])\n        np.savez_compressed(os.path.join(output_dir, _id), cell_mask)\n        \nprint(\"\\n... TRAINING CONVERSION ...\\n\")\nsave_masks_to_numpy(train_df, TRAIN_OUTPUT_DIR)\n\nprint(\"\\n... TESTING CONVERSION ...\\n\")\nsave_masks_to_numpy(ss_df, TEST_OUTPUT_DIR)","e4959608":"def compare_tito_and_darien(img_id=None, tito_root=\"\/kaggle\/input\/hpa-mask\/hpa_cell_mask\", darien_root=\"\/kaggle\/working\/hpa_cell_mask\/train\"):\n    # Get random if None is passed\n    if img_id is None:\n        img_id = train_df.ID.sample(1).values[0]\n    \n    # Load\n    tito_img = np.load(os.path.join(tito_root, img_id+\".npz\"))[\"arr_0\"]\n    darien_img = np.load(os.path.join(darien_root, img_id+\".npz\"))[\"arr_0\"]\n\n    plt.figure(figsize=(18,19))\n    \n    # SETUP SUBPLOT 1\n    plt.subplot(1,2,1)\n    plt.title(f\"TITOS \u2013 {img_id}\")\n    plt.axis(False)\n    plt.imshow(tito_img)\n\n    # SETUP SUBPLOT 2\n    plt.subplot(1,2,2)\n    plt.title(f\"DARIENS \u2013 {img_id}\")\n    plt.axis(False)\n    plt.imshow(darien_img)\n    \n    plt.show()\n    \n\nfor _ in range(25):\n    compare_tito_and_darien()","09ace2b4":"# Create Numpy Arrays and Compare w\/ Tito Mask Dataset\n\n---"}}