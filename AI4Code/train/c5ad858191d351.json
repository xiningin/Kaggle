{"cell_type":{"25c1cb08":"code","73956043":"code","7ab5ad34":"code","e852ee4e":"code","5bc97d41":"code","2e1bea02":"code","d4b8b13a":"code","038430ec":"code","33817abc":"code","4c2ce810":"markdown","89fdd8f1":"markdown"},"source":{"25c1cb08":"import pandas as pd\nimport numpy as np\nimport random\nimport time\nimport os\nimport gc","73956043":"%%time \n\ndf_train = pd.read_csv(r\"..\/input\/tabular-playground-series-oct-2021\/train.csv\", index_col=0)\ndf_test = pd.read_csv(r\"..\/input\/tabular-playground-series-oct-2021\/test.csv\", index_col=0)","7ab5ad34":"del df_train\ndel df_test\ngc.collect()","e852ee4e":"%%time\n\nX = pd.read_parquet(r\"..\/input\/tps-10-21-dataset-parquet\/X.parquet\")\ny = pd.read_parquet(r\"..\/input\/tps-10-21-dataset-parquet\/y.parquet\")\nX_test = pd.read_parquet(r\"..\/input\/tps-10-21-dataset-parquet\/X_test.parquet\")","5bc97d41":"INT8_MIN    = np.iinfo(np.int8).min\nINT8_MAX    = np.iinfo(np.int8).max\nINT16_MIN   = np.iinfo(np.int16).min\nINT16_MAX   = np.iinfo(np.int16).max\nINT32_MIN   = np.iinfo(np.int32).min\nINT32_MAX   = np.iinfo(np.int32).max\n\nFLOAT16_MIN = np.finfo(np.float16).min\nFLOAT16_MAX = np.finfo(np.float16).max\nFLOAT32_MIN = np.finfo(np.float32).min\nFLOAT32_MAX = np.finfo(np.float32).max\n\n\ndef memory_usage(data, detail=1):\n    if detail:\n        display(data.memory_usage())\n    memory = data.memory_usage().sum() \/ (1024*1024)\n    print(\"Memory usage : {0:.2f}MB\".format(memory))\n    return memory\n\n\ndef compress_dataset(data):\n    memory_before_compress = memory_usage(data, 0)\n    print()\n    length_interval      = 50\n    length_float_decimal = 4\n\n    print('='*length_interval)\n    for col in data.columns:\n        col_dtype = data[col][:100].dtype\n\n        if col_dtype != 'object':\n            print(\"Name: {0:24s} Type: {1}\".format(col, col_dtype))\n            col_series = data[col]\n            col_min = col_series.min()\n            col_max = col_series.max()\n\n            if col_dtype == 'float64':\n                print(\" variable min: {0:15s} max: {1:15s}\".format(str(np.round(col_min, length_float_decimal)), str(np.round(col_max, length_float_decimal))))\n#                 if (col_min > FLOAT16_MIN) and (col_max < FLOAT16_MAX):\n#                     data[col] = data[col].astype(np.float16)\n#                     print(\"  float16 min: {0:15s} max: {1:15s}\".format(str(FLOAT16_MIN), str(FLOAT16_MAX)))\n#                     print(\"compress float64 --> float16\")\n                if (col_min > FLOAT32_MIN) and (col_max < FLOAT32_MAX):\n                    data[col] = data[col].astype(np.float32)\n                    print(\"  float32 min: {0:15s} max: {1:15s}\".format(str(FLOAT32_MIN), str(FLOAT32_MAX)))\n                    print(\"compress float64 --> float32\")\n                else:\n                    pass\n                memory_after_compress = memory_usage(data, 0)\n                print(\"Compress Rate: [{0:.2%}]\".format((memory_before_compress-memory_after_compress) \/ memory_before_compress))\n                print('='*length_interval)\n\n            if col_dtype == 'int64':\n                print(\" variable min: {0:15s} max: {1:15s}\".format(str(col_min), str(col_max)))\n                type_flag = 64\n                if (col_min > INT8_MIN\/2) and (col_max < INT8_MAX\/2):\n                    type_flag = 8\n                    data[col] = data[col].astype(np.int8)\n                    print(\"     int8 min: {0:15s} max: {1:15s}\".format(str(INT8_MIN), str(INT8_MAX)))\n                elif (col_min > INT16_MIN) and (col_max < INT16_MAX):\n                    type_flag = 16\n                    data[col] = data[col].astype(np.int16)\n                    print(\"    int16 min: {0:15s} max: {1:15s}\".format(str(INT16_MIN), str(INT16_MAX)))\n                elif (col_min > INT32_MIN) and (col_max < INT32_MAX):\n                    type_flag = 32\n                    data[col] = data[col].astype(np.int32)\n                    print(\"    int32 min: {0:15s} max: {1:15s}\".format(str(INT32_MIN), str(INT32_MAX)))\n                    type_flag = 1\n                else:\n                    pass\n                memory_after_compress = memory_usage(data, 0)\n                print(\"Compress Rate: [{0:.2%}]\".format((memory_before_compress-memory_after_compress) \/ memory_before_compress))\n                if type_flag == 32:\n                    print(\"compress (int64) ==> (int32)\")\n                elif type_flag == 16:\n                    print(\"compress (int64) ==> (int16)\")\n                else:\n                    print(\"compress (int64) ==> (int8)\")\n                print('='*length_interval)\n\n    print()\n    memory_after_compress = memory_usage(data, 0)\n    print(\"Compress Rate: [{0:.2%}]\".format((memory_before_compress-memory_after_compress) \/ memory_before_compress))\n    \n    return data","2e1bea02":"print(\"==== X ====\")\nX = compress_dataset(X)\nprint(\"==== y ====\")\ny = compress_dataset(y)\nprint(\"==== X_test ====\")\nX_test = compress_dataset(X_test)","d4b8b13a":"X.to_parquet(\"X.parquet\")\nX_test.to_parquet(\"X_test.parquet\")\ny.to_parquet(\"y.parquet\")","038430ec":"del X, X_test, y\ngc.collect()","33817abc":"%%time\n\nX = pd.read_parquet(r\".\/X.parquet\")\ny = pd.read_parquet(r\".\/y.parquet\")\nX_test = pd.read_parquet(r\".\/X_test.parquet\")","4c2ce810":"**Data compression:** \n\n\nhttps:\/\/www.kaggle.com\/dlaststark\/tps-1021-la-dee-da?kernelSessionId=76105013 by DLASTSTARK\n\n* removed the f16 option to keep it compatible with parquet format","89fdd8f1":"Considering **the size** of this month dataset and **the number of time** you're going to load the data during the competition you might consider switching to parquet format ...\n\n[Parquet documentation](http:\/\/https:\/\/parquet.apache.org\/documentation\/latest\/)"}}