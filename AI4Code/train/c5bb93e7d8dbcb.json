{"cell_type":{"5fffb96a":"code","915e90a1":"code","c296ac78":"code","c87d8e49":"code","6c677904":"code","129ec82f":"code","c7b5605c":"code","d52778dd":"code","14eb983f":"code","6d490379":"code","90dc653c":"code","afb1e84f":"code","fa208cf5":"code","53c33c6b":"markdown","b195e4e1":"markdown","3dbb2296":"markdown","bf798b1b":"markdown","cb0eddc9":"markdown","9a02e529":"markdown"},"source":{"5fffb96a":"import os\nGPU_id = 0\nos.environ['CUDA_VISIBLE_DEVICES'] = str(GPU_id)","915e90a1":"import warnings\nwarnings.filterwarnings(\"ignore\")\n\nfrom numba import jit \nimport numpy as np\nfrom sklearn.metrics import cohen_kappa_score, confusion_matrix\nimport cupy as cp\nimport time\nimport matplotlib.pyplot as plt","c296ac78":"def cupy_hist_int(x,n):\n    bins = cp.arange(n+1)-0.5\n    hist,_ = cp.histogram(x,bins=bins)\n    return hist\n\ndef cupy_confusion_matrix(true,pred,n):\n    cf = true*n+pred\n    cf = cupy_hist_int(cf,n*n)\n    return cf.reshape([n,n])\n\ndef cupy_quadKappa(act,pred,n=4,hist_range=(0,3)):\n    act = cp.asarray(act,dtype=cp.int32)\n    pred = cp.asarray(pred,dtype=cp.int32)\n    O = cupy_confusion_matrix(act,pred,n)\n    O = cp.divide(O,cp.sum(O))\n    \n    W = cp.zeros((n,n))\n    for i in range(n):\n        for j in range(n):\n            W[i][j] = ((i-j)**2)\/((n-1)**2)\n            \n    act_hist = cupy_hist_int(act,n)\n    prd_hist = cupy_hist_int(pred,n)\n    \n    E = cp.outer(act_hist,prd_hist)\n    E = cp.divide(E,cp.sum(E))\n    \n    num = cp.sum(cp.multiply(W,O))\n    den = cp.sum(cp.multiply(W,E))\n        \n    return 1-np.divide(num,den)","c87d8e49":"def quadKappa(act,pred,n=4,hist_range=(0,3)):\n    \n    O = confusion_matrix(act,pred)\n    O = np.divide(O,np.sum(O))\n    \n    W = np.zeros((n,n))\n    for i in range(n):\n        for j in range(n):\n            W[i][j] = ((i-j)**2)\/((n-1)**2)\n            \n    act_hist = np.histogram(act,bins=n,range=hist_range)[0]\n    prd_hist = np.histogram(pred,bins=n,range=hist_range)[0]\n    \n    E = np.outer(act_hist,prd_hist)\n    E = np.divide(E,np.sum(E))\n    \n    num = np.sum(np.multiply(W,O))\n    den = np.sum(np.multiply(W,E))\n        \n    return 1-np.divide(num,den)","6c677904":"@jit\ndef qwk3(a1, a2, max_rat=3):\n    assert(len(a1) == len(a2))\n    a1 = np.asarray(a1, dtype=np.int32)\n    a2 = np.asarray(a2, dtype=np.int32)\n\n    hist1 = np.zeros((max_rat + 1, ))\n    hist2 = np.zeros((max_rat + 1, ))\n\n    o = 0\n    for k in range(a1.shape[0]):\n        i, j = a1[k], a2[k]\n        hist1[i] += 1\n        hist2[j] += 1\n        o +=  (i - j) * (i - j)\n\n    e = 0\n    for i in range(max_rat + 1):\n        for j in range(max_rat + 1):\n            e += hist1[i] * hist2[j] * (i - j) * (i - j)\n\n    e = e \/ a1.shape[0]\n\n    return 1 - o \/ e","129ec82f":"size = 1000000\na = np.random.randint(0, 4, size)\np = np.random.randint(0, 4, size)\na.size, p.size","c7b5605c":"%%time\nquadKappa(a,p)","d52778dd":"%%time\nqwk3(a,p)","14eb983f":"%%time\nqwk3(a,p)","6d490379":"%%time\ncupy_quadKappa(a,p)","90dc653c":"%%time\ncupy_quadKappa(a,p)","afb1e84f":"cupy_time = []\nnumpy_time = []\nnumba_time = []\nfor i in range(5,9):\n    size = 10**i\n    a = np.random.randint(0, 4, size)\n    p = np.random.randint(0, 4, size)\n    \n    start = time.time()\n    quadKappa(a,p)\n    numpy_time.append(time.time()-start)\n    \n    start = time.time()\n    cupy_quadKappa(a,p)\n    cupy_time.append(time.time()-start)\n    \n    start = time.time()\n    qwk3(a,p)\n    numba_time.append(time.time()-start)","fa208cf5":"plt.figure(figsize=(15,5))\ncolors = ['b','g','r']\nxs = [10**i for i in range(5,9)]\nplt.yscale('log')\nplt.xlim(5*10**4,5*10**8)\nplt.ylim(10**(-5),10**3)\nplt.xscale('log')\nplt.xlabel('number of sample')\nplt.ylabel('run time: seconds')\nplt.grid()\n\nplt.scatter(xs,numpy_time,c='b',label='numpy')  \nplt.scatter(xs,cupy_time,c='g',label='cupy') \nplt.scatter(xs,numba_time,c='r',label='numba') \n\nplt.plot(xs,numpy_time,c='b')  \nplt.plot(xs,cupy_time,c='g') \nplt.plot(xs,numba_time,c='r') \nplt.legend(loc='upper left')\nplt.title('qwk: cupy vs numpy vs numba')","53c33c6b":"### @afajohn Method\u00b6\nhttps:\/\/www.kaggle.com\/afajohn\/quadratic-weighted-kappa-with-numpy-flavor","b195e4e1":"### numba relies on just in time compiler so the running time for the first execution will be slower.","3dbb2296":"### cupy implementation\nCuPy is an open-source matrix library accelerated with NVIDIA CUDA. https:\/\/cupy.chainer.org\/\n\nIn this notebook, we show how simple it is to drop-in replace numpy functions with cupy and deliver 100x speedup.","bf798b1b":"### cupy uses on-the-fly kernel synthesis so the running time for the first execution will also be slower.","cb0eddc9":"### It is amazing that numba is slightly faster than cupy despite it's on cpu. Both are about 100x faster than numpy. Cupy is still convenient without much code change if your baseline code is in numpy.","9a02e529":"### @cpmpml\nhttps:\/\/www.kaggle.com\/cpmpml\/ultra-fast-qwk-calc-method"}}