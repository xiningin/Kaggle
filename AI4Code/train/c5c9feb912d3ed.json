{"cell_type":{"9c823bf2":"code","15656648":"code","676de3f1":"code","7ec6bb12":"code","6a644159":"code","849b8f19":"code","c495fc39":"code","e9200d37":"code","af7b45d2":"code","5868a1cf":"code","c158c9fb":"code","91a601ea":"code","d39c7876":"code","16b7f0b3":"code","7df548c4":"code","4b466183":"code","bb551fe2":"code","b0ad1f4f":"markdown","973f0edf":"markdown","1f34a68d":"markdown","945f150a":"markdown","31a0fa56":"markdown","b26b42cc":"markdown","c46c8c2e":"markdown","e3e7db29":"markdown","f0980533":"markdown","f8b55b2c":"markdown","5997b6f6":"markdown","25d805a7":"markdown","67864712":"markdown","ff424d2f":"markdown","3df7f699":"markdown","ec8d05e4":"markdown"},"source":{"9c823bf2":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn import metrics","15656648":"train_file = \"..\/input\/pima-indians-diabetes-database\/diabetes.csv\"\nX_train = pd.read_csv(train_file)","676de3f1":"# Training data inspection\n# X_train.head()\nprint(\"Shape of the training data: \", X_train.shape)\nprint(\"- \" * 70)\nprint(X_train.info())\nprint(\"- \" * 70)\nX_train.describe(include = \"all\")","7ec6bb12":"# Using isnull()\nmissing_val_count_by_column_train = (X_train.isnull().sum())\nprint(missing_val_count_by_column_train[missing_val_count_by_column_train > 0])","6a644159":"# using sns heatmap\nsns.heatmap(X_train.isnull(), cbar = False);","849b8f19":"diabetes_data_copy = X_train.copy()\ndiabetes_data_copy[['Glucose','BloodPressure','SkinThickness','Insulin','BMI']] = diabetes_data_copy[['Glucose','BloodPressure','SkinThickness','Insulin','BMI']].replace(0,np.NaN)\n\n# showing the count of Nans\nprint(diabetes_data_copy.isnull().sum())","c495fc39":"sns.heatmap(diabetes_data_copy.isnull(), cbar = False);","e9200d37":"p = X_train.hist(figsize = (20,20))","af7b45d2":"diabetes_data_copy['Glucose'].fillna(diabetes_data_copy['Glucose'].mean(), inplace = True)\ndiabetes_data_copy['BloodPressure'].fillna(diabetes_data_copy['BloodPressure'].mean(), inplace = True)\ndiabetes_data_copy['SkinThickness'].fillna(diabetes_data_copy['SkinThickness'].median(), inplace = True)\ndiabetes_data_copy['Insulin'].fillna(diabetes_data_copy['Insulin'].median(), inplace = True)\ndiabetes_data_copy['BMI'].fillna(diabetes_data_copy['BMI'].median(), inplace = True)","5868a1cf":"p = diabetes_data_copy.hist(figsize = (20,20))","c158c9fb":"plt.figure(figsize=(12,10))\np=sns.heatmap(diabetes_data_copy.corr(), annot=True, cmap ='RdYlGn');","91a601ea":"sc_X = StandardScaler()\nX = pd.DataFrame(sc_X.fit_transform(diabetes_data_copy.drop([\"Outcome\"],axis = 1),),\n        columns=['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin',\n       'BMI', 'DiabetesPedigreeFunction', 'Age'])\n\ny = diabetes_data_copy.Outcome\n\nX.head()","d39c7876":"# Split the data into train test set\nX_train, X_test, y_train, y_test = train_test_split(X, y, train_size = 0.7, test_size = 0.3, random_state = 0)","16b7f0b3":"test_scores = []\ntrain_scores = []\n\nfor i in range(1, 27):\n\n    knn = KNeighborsClassifier(i)\n    knn.fit(X_train, y_train)\n    \n    train_scores.append(knn.score(X_train, y_train))\n    test_scores.append(knn.score(X_test, y_test))\n\n\n# score that comes from testing on the datapoints that were split in the beginning to be used for testing solely\nmax_test_score = max(test_scores)\ntest_scores_ind = [i for i, v in enumerate(test_scores) if v == max_test_score]\n\nprint('Max test score {} % and k = {}'.format(max_test_score * 100, list(map(lambda x: x + 1, test_scores_ind))))","7df548c4":"plt.figure(figsize=(12, 5))\np = sns.lineplot(range(1, 27), train_scores, marker = '*', label = 'Train Score');\np = sns.lineplot(range(1, 27), test_scores, marker = 'o', label = 'Test Score');","4b466183":"knn = KNeighborsClassifier(9)\n\nknn.fit(X_train, y_train)\nknn.score(X_test, y_test)","bb551fe2":"y_pred = knn.predict(X_test)\n\ncnf_matrix = metrics.confusion_matrix(y_test, y_pred)\np = sns.heatmap(pd.DataFrame(cnf_matrix), annot = True, cmap = \"YlGnBu\", fmt = 'g');\nplt.title('Confusion matrix', y = 1.1)\nplt.ylabel('Actual label')\nplt.xlabel('Predicted label')","b0ad1f4f":"#### Step 2: Finding K ####","973f0edf":"## 4.2 Finding Pearson's Correlation Coefficient Using A Heatmap ##\n\n\n---\n\n","1f34a68d":"**To fill these Nan values the data distribution needs to be understood**","945f150a":"## 4.3 Normalization ##","31a0fa56":"# 4. Data Preprocessing #\n- Missing Values\n- Calculating The Correlation\n- Normalization\n---\n\n","b26b42cc":"## 4.1 Missing Values ##\n\n---\n\n","c46c8c2e":"#### Step 5: Building The Final Model ####\nSince the best result were found on k = 9, Then we will build the model using this value for k","e3e7db29":"#### Step 1: Splitting The Data ####","f0980533":"# 2. Loading The Data #","f8b55b2c":"#### Dataset Description ####\nThis dataset is originally from the National Institute of Diabetes and Digestive and Kidney Diseases. The objective of the dataset is to diagnostically predict whether or not a patient has diabetes, based on certain diagnostic measurements included in the dataset. Several constraints were placed on the selection of these instances from a larger database. In particular, all patients here are females at least 21 years old of Pima Indian heritage.","5997b6f6":"#### Step 3: Result Visualisation ####","25d805a7":"# 3. Inspecting The Data #","67864712":"# 1. Importing Libraries #","ff424d2f":"**Aiming to impute nan values for the columns in accordance with their distribution**\n","3df7f699":"# 5. Preparing The Data And Finding The best Value For K #\n\n---\n\n","ec8d05e4":"On these columns, a value of zero does not make sense and thus indicates missing value.\n\nFollowing columns or variables have an invalid zero value:\n\n- Glucose\n- BloodPressure\n- SkinThickness\n- Insulin\n- BMI"}}