{"cell_type":{"ca007928":"code","c3e1fdf8":"code","c0d53933":"code","ebb1d35c":"code","771a8645":"code","e0bdc344":"code","8feec0cd":"code","e54ce9ef":"code","c999643d":"code","e22f6f17":"code","188a8ba6":"code","b9832bb0":"code","b0e00efd":"markdown","933dad01":"markdown","2d5b37fe":"markdown","93b9c70c":"markdown","9fd5897e":"markdown","71578ad8":"markdown","8b81ad80":"markdown","20ab6585":"markdown","d7692aae":"markdown","ce637399":"markdown","5fe55b99":"markdown","fd7f8cc4":"markdown","0a36a453":"markdown"},"source":{"ca007928":"\nimport pandas as pd\nimport geopandas as gpd\nimport numpy as np\nimport folium\nfrom folium import Marker\nimport warnings \nwarnings.filterwarnings('ignore')","c3e1fdf8":"from geopy.geocoders import Nominatim","c0d53933":"geolocator = Nominatim(user_agent=\"kaggle_learn\")\nlocation = geolocator.geocode(\"Pyramid of Khufu\")\n\nprint(location.point)\nprint(location.address)","ebb1d35c":"point = location.point\nprint(\"Latitude:\", point.latitude)\nprint(\"Longitude:\", point.longitude)","771a8645":"universities = pd.read_csv(\"..\/input\/geospatial-learn-course-data\/top_universities.csv\")\nuniversities.head()","e0bdc344":"def my_geocoder(row):\n    try:\n        point = geolocator.geocode(row).point\n        return pd.Series({'Latitude': point.latitude, 'Longitude': point.longitude})\n    except:\n        return None\n\nuniversities[['Latitude', 'Longitude']] = universities.apply(lambda x: my_geocoder(x['Name']), axis=1)\n\nprint(\"{}% of addresses were geocoded!\".format(\n    (1 - sum(np.isnan(universities[\"Latitude\"])) \/ len(universities)) * 100))\n\n# Drop universities that were not successfully geocoded\nuniversities = universities.loc[~np.isnan(universities[\"Latitude\"])]\nuniversities = gpd.GeoDataFrame(\n    universities, geometry=gpd.points_from_xy(universities.Longitude, universities.Latitude))\nuniversities.crs = {'init': 'epsg:4326'}\nuniversities.head()","8feec0cd":"# Create a map\nm = folium.Map(location=[54, 15], tiles='openstreetmap', zoom_start=2)\n\n# Add points to the map\nfor idx, row in universities.iterrows():\n    Marker([row['Latitude'], row['Longitude']], popup=row['Name']).add_to(m)\n\n# Display the map\nm","e54ce9ef":"\nworld = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))\neurope = world.loc[world.continent == 'Europe'].reset_index(drop=True)\n\neurope_stats = europe[[\"name\", \"pop_est\", \"gdp_md_est\"]]\neurope_boundaries = europe[[\"name\", \"geometry\"]]","c999643d":"europe_boundaries.head()","e22f6f17":"europe_stats.head()","188a8ba6":"# Use an attribute join to merge data about countries in Europe\neurope = europe_boundaries.merge(europe_stats, on=\"name\")\neurope.head()","b9832bb0":"# Use spatial join to match universities to countries in Europe\neuropean_universities = gpd.sjoin(universities, europe)\n\n# Investigate the result\nprint(\"We located {} universities.\".format(len(universities)))\nprint(\"Only {} of the universities were located in Europe (in {} different countries).\".format(\n    len(european_universities), len(european_universities.name.unique())))\n\neuropean_universities.head()","b0e00efd":"The spatial join above looks at the \"geometry\" columns in both GeoDataFrames.  If a Point object from the `universities` GeoDataFrame intersects a Polygon object from the `europe` DataFrame, the corresponding rows are combined and added as a single row of the `european_universities` DataFrame.  Otherwise, countries without a matching university (and universities without a matching country) are omitted from the results.\n\nThe `gpd.sjoin()` method is customizable for different types of joins, through the `how` and `op` arguments.  For instance, you can do the equivalent of a SQL left (or right) join by setting `how='left'` (or `how='right'`).  We won't go into the details in this course, but you can learn more in [the documentation](https:\/\/geopandas.org\/en\/stable\/docs\/reference\/api\/geopandas.sjoin.html).\n\n# Your turn\n\n**[Use geocoding and table joins](https:\/\/www.kaggle.com\/kernels\/fork\/5832170)** to identify suitable locations for the next Starbucks Reserve Roastery.","933dad01":"Next, we visualize all of the locations that were returned by the geocoder.  Notice that a few of the locations are certainly inaccurate, as they're not in Europe!","2d5b37fe":"# Introduction\n\nIn this tutorial, you'll learn about two common manipulations for geospatial data: **geocoding** and **table joins**.","93b9c70c":"We'll join it with a DataFrame `europe_stats` containing the estimated population and gross domestic product (GDP) for each country.","9fd5897e":"---\n\n\n\n\n*Have questions or comments? Visit the [course discussion forum](https:\/\/www.kaggle.com\/learn\/geospatial-analysis\/discussion) to chat with other learners.*","71578ad8":"It's often the case that we'll need to geocode many different addresses.  For instance, say we want to obtain the locations of 100 top universities in Europe.","8b81ad80":"The value for the \"point\" attribute is a `geopy.point.Point` object, and we can get the latitude and longitude from the `latitude` and `longitude` attributes, respectively.","20ab6585":"### Spatial join\n\nAnother type of join is a **spatial join**.  With a spatial join, we combine GeoDataFrames based on the spatial relationship between the objects in the \"geometry\" columns.  For instance, we already have a GeoDataFrame `universities` containing geocoded addresses of European universities.  \n\nThen we can use a spatial join to match each university to its corresponding country.  We do this with `gpd.sjoin()`.","d7692aae":"# Table joins\n\nNow, we'll switch topics and think about how to combine data from different sources.  \n\n### Attribute join\n\n[You already know](https:\/\/www.kaggle.com\/residentmario\/renaming-and-combining) how to use `pd.DataFrame.join()` to combine information from multiple DataFrames with a shared index.  We refer to this way of joining data (by simpling matching values in the index) as an **attribute join**.\n\nWhen performing an attribute join with a GeoDataFrame, it's best to use the `gpd.GeoDataFrame.merge()`.  To illustrate this, we'll work with a GeoDataFrame `europe_boundaries` containing the boundaries for every country in Europe.  The first five rows of this GeoDataFrame are printed below.","ce637399":"We do the attribute join in the code cell below.  The `on` argument is set to the column name that is used to match rows in `europe_boundaries` to rows in `europe_stats`.","5fe55b99":"Then we can use a lambda function to apply the geocoder to every row in the DataFrame.  (We use a try\/except statement to account for the case that the geocoding is unsuccessful.)","fd7f8cc4":"In the code cell above, [`Nominatim`](https:\/\/nominatim.openstreetmap.org\/) refers to the geocoding software that will be used to generate locations. \n\nWe begin by instantiating the geocoder.  Then, we need only apply the name or address as a Python string. (In this case, we supply `\"Pyramid of Khufu\"`, also known as the Great Pyramid of Giza.)\n\nIf the geocoding is successful, it returns a `geopy.location.Location` object with two important attributes:\n- the \"point\" attribute contains the (latitude, longitude) location, and\n- the \"address\" attribute contains the full address.","0a36a453":"# Geocoding\n\n**Geocoding** is the process of converting the name of a place or an address to a location on a map.  If you have ever looked up a geographic location based on a landmark description with [Google Maps](https:\/\/www.google.com\/maps), [Bing Maps](https:\/\/www.bing.com\/maps), or [Baidu Maps](https:\/\/map.baidu.com\/), for instance, then you have used a geocoder!\n\n![](https:\/\/i.imgur.com\/1IrgZQq.png)\n\nWe'll use geopy to do all of our geocoding."}}