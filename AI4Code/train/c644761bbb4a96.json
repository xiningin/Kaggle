{"cell_type":{"d9b9200b":"code","1003e589":"code","cd3a470b":"code","461154c8":"code","746e8ecc":"code","ab98558b":"code","7c880327":"code","6d21ddca":"code","f7de577a":"code","b725c785":"code","84f08c0f":"code","416a9ee8":"code","c6229de1":"code","16a7c312":"code","e00a23be":"code","ea55abfa":"code","d21c8208":"code","9ed67920":"code","c57c0f48":"code","ec8b59c0":"code","4e79e280":"code","f9761fb7":"code","a515ecd6":"code","603d6fc9":"code","decb0ca7":"code","393f4ebe":"code","d10face7":"code","b26f00e5":"code","1d902dca":"code","545571b5":"code","f2a9306f":"code","8a29cb39":"code","17543375":"code","29b6d705":"markdown","89cb8ac9":"markdown","56f82d45":"markdown","854c1b1f":"markdown","f5107fdd":"markdown","6d11bc57":"markdown","d21a09f1":"markdown","4a4b6a04":"markdown","0ae95bcd":"markdown","d9a85557":"markdown","70ebdd9d":"markdown","078860a5":"markdown","7e5c615e":"markdown","3c96778e":"markdown","418cfa36":"markdown","a6c7e538":"markdown","9a89edf4":"markdown","7ccd471b":"markdown","afe796e2":"markdown","345e1791":"markdown","808dd0e2":"markdown","01853827":"markdown","5ccf031d":"markdown"},"source":{"d9b9200b":"import numpy as np\nimport pandas as pd\nimport time\n\n# data visualization libraries\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport seaborn as sns\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# model selection and building libraries\nfrom sklearn.model_selection import train_test_split \nfrom sklearn import metrics\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import BaggingRegressor\nfrom sklearn.multioutput import MultiOutputRegressor\n\n# data preprocessing libraries\nfrom sklearn.preprocessing import MaxAbsScaler\nfrom sklearn.preprocessing import PolynomialFeatures\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nRANDOM_STATE = 21","1003e589":"# read data from csv\nraw_data = pd.read_csv('..\/input\/electric-motor-temperature\/measures_v2.csv')\nraw_data.head()","cd3a470b":"raw_data.shape","461154c8":"columns_to_drop = ['pm', 'profile_id']\nraw_data.drop(columns_to_drop, axis=1, inplace=True)\nraw_data.shape","746e8ecc":"columns_old = raw_data.columns.tolist()\nprint(f'Columns in old order:\\n\\n {columns_old}\\n')\n\ncolumns_new = [\n    'u_q', \n    'u_d', \n    'i_q',\n    'i_d',\n    'coolant',\n    'ambient',\n    'stator_winding',  \n    'stator_tooth',  \n    'stator_yoke',\n    'motor_speed',\n    'torque']\n\nraw_data = raw_data[columns_new]\nprint('Dataframe with columns in new order:')\nraw_data.head(1)","ab98558b":"column_titles = {\n    'u_q': 'Voltage q-component', \n    'u_d': 'Voltage d-component', \n    'i_q': 'Current q-component', \n    'i_d': 'Current d-component', \n    'coolant': 'Coolant temperature', \n    'ambient': 'Ambient temperature', \n    'stator_winding': 'Stator winding temperature', \n    'stator_tooth': 'Stator tooth temperature', \n    'stator_yoke': 'Stator yoke temperature', \n    'motor_speed': 'Motor speed', \n    'torque': 'Motor torque' \n}","7c880327":"input_variables = [\n    'u_q', \n    'u_d', \n    'i_q',\n    'i_d',\n    'coolant',\n    'ambient'\n]","6d21ddca":"raw_data.info()","f7de577a":"# check duplicates and drop if exist\nduplicated_rows = raw_data[raw_data.duplicated().values == True]\nprint(f'Number of duplicates: {len(duplicated_rows)}')","b725c785":"raw_data.describe().T","84f08c0f":"# Set the width and height of the figure\nplt.figure(figsize=(15,15))\n\n# show a heatmap of the column variables\nplt.title('Correlation of variables')\nsns.heatmap(data=raw_data.corr(), annot=True)","416a9ee8":"def observe_relationships_with_scatterplot(variable_x, variable_y, ax):\n    \n    sns.scatterplot(data=raw_data, x=variable_x, y=variable_y, ax=ax)\n    \n    plt.title(\n        f'Relationship of variables:'\n    )\n    plt.xlabel(column_titles[variable_x])\n    plt.ylabel(column_titles[variable_y])","c6229de1":"# explore relationship of highly correlated variables\n\nfig = plt.figure(figsize=(10,10))\nfig.subplots_adjust(hspace=0.4, wspace=0.4)\n\nax = fig.add_subplot(2, 2, 1)\nobserve_relationships_with_scatterplot('torque', 'i_q', ax)\n\nax = fig.add_subplot(2, 2, 2)\nobserve_relationships_with_scatterplot('u_d', 'i_q', ax)\n\nplt.show()","16a7c312":"def observe_3d_relationships(variable_x, variable_y, variable_z, ax):\n\n    ax.set_xlabel(column_titles[variable_x])\n    ax.set_ylabel(column_titles[variable_y])\n    ax.set_zlabel(column_titles[variable_z])\n\n    x = raw_data[variable_x]\n    y = raw_data[variable_y]\n    z = raw_data[variable_z]\n\n    ax.scatter(x, y, z)","e00a23be":"fig = plt.figure(figsize=(20,20))\nfig.subplots_adjust(hspace=0.2, wspace=0.2)\n\n# =============\n# First subplot\n# =============\nax = fig.add_subplot(3, 2, 1, projection='3d')\nobserve_3d_relationships('u_d', 'torque', 'i_q', ax)\n\n# =============\n# Second subplot\n# =============\nax = fig.add_subplot(3, 2, 2, projection='3d')\nobserve_3d_relationships('i_d', 'motor_speed', 'u_q', ax)\n\n# =============\n# Third subplot\n# =============\nax = fig.add_subplot(3, 2, 3, projection='3d')\nobserve_3d_relationships('i_d', 'stator_tooth', 'coolant', ax)\n\n# =============\n# Forth subplot\n# =============\nax = fig.add_subplot(3, 2, 4, projection='3d')\nobserve_3d_relationships('i_d', 'stator_winding', 'coolant', ax)\n\n# =============\n# Fifth subplot\n# =============\nax = fig.add_subplot(3, 2, 5, projection='3d')\nobserve_3d_relationships('ambient', 'stator_yoke', 'coolant', ax)\n\n# =============\n# Sixth subplot\n# =============\nax = fig.add_subplot(3, 2, 6, projection='3d')\nobserve_3d_relationships('stator_tooth', 'stator_winding', 'stator_yoke', ax)\n\nplt.show()","ea55abfa":"fig = plt.figure(figsize=(10,15))\nfig.subplots_adjust(hspace=0.4, wspace=0.4)\n\nax = fig.add_subplot(3, 2, 1)\nsns.histplot(data=raw_data, x='u_q', kde=True, ax=ax)\n\nax = fig.add_subplot(3, 2, 2)\nsns.histplot(data=raw_data, x='u_d', kde=True, ax=ax)\n\nax = fig.add_subplot(3, 2, 3)\nsns.histplot(data=raw_data, x='i_q', kde=True, ax=ax)\n\nax = fig.add_subplot(3, 2, 4)\nsns.histplot(data=raw_data, x='i_d', kde=True, ax=ax)\n\nax = fig.add_subplot(3, 2, 5)\nsns.histplot(data=raw_data, x='coolant', kde=True, ax=ax)\n\nax = fig.add_subplot(3, 2, 6)\nsns.histplot(data=raw_data, x='ambient', kde=True, ax=ax)\n\nplt.show()","d21c8208":"fig = plt.figure(figsize=(10,15))\nfig.subplots_adjust(hspace=0.4, wspace=0.4)\n\nax = fig.add_subplot(3, 2, 1)\nsns.boxplot(x=raw_data['u_q'], palette='Blues', ax=ax)\n\nax = fig.add_subplot(3, 2, 2)\nsns.boxplot(x=raw_data['u_d'], palette='Blues', ax=ax)\n\nax = fig.add_subplot(3, 2, 3)\nsns.boxplot(x=raw_data['i_q'], palette='Blues', ax=ax)\n\nax = fig.add_subplot(3, 2, 4)\nsns.boxplot(x=raw_data['i_d'], palette='Blues', ax=ax)\n\nax = fig.add_subplot(3, 2, 5)\nsns.boxplot(x=raw_data['coolant'], palette='Blues', ax=ax)\n\nax = fig.add_subplot(3, 2, 6)\nsns.boxplot(x=raw_data['ambient'], palette='Blues', ax=ax)\n\nplt.show()","9ed67920":"work_data = raw_data\ntraining_set, testing_set = train_test_split(\n    work_data, test_size = 0.2, random_state = RANDOM_STATE, shuffle=True)\ntesting_set.shape","c57c0f48":"i_u_variables = ['u_q', 'u_d', 'i_q', 'i_d']\n\nma_scaler = MaxAbsScaler()\ntraining_set[i_u_variables] = ma_scaler.fit_transform(training_set[i_u_variables])\ntesting_set[i_u_variables] = ma_scaler.transform(testing_set[i_u_variables])","ec8b59c0":"training_set[['coolant', 'ambient']].max()","4e79e280":"testing_set[['coolant', 'ambient']].max()","f9761fb7":"temperature_ma_scaler = MaxAbsScaler()\n\ntraining_set['coolant'] = temperature_ma_scaler.fit_transform(training_set[['coolant']])\ntesting_set['coolant'] = temperature_ma_scaler.transform(testing_set[['coolant']])\n\ntraining_set['ambient'] = temperature_ma_scaler.transform(training_set[['ambient']])\ntesting_set['ambient'] = temperature_ma_scaler.transform(testing_set[['ambient']])\n\ntraining_set.describe()","a515ecd6":"# Get dataset with input variables\ntraining_x = training_set[input_variables]\ntesting_x = testing_set[input_variables]\ntesting_x.head(1)","603d6fc9":"# Get dataset with output variables\nall_variables = work_data.columns.tolist()\ntarget_variables = [c for c in all_variables if c not in input_variables]\nprint(f'Target variables: {\" \".join(target_variables)}\\n')\n\ntraining_y = training_set[target_variables]\ntesting_y = testing_set[target_variables]\ntesting_y.head(1)","decb0ca7":"stator_training_y = training_y[['stator_winding', 'stator_tooth', 'stator_yoke']]\nstator_testing_y = testing_y[['stator_winding', 'stator_tooth', 'stator_yoke']]","393f4ebe":"poly = PolynomialFeatures(5)\n\npoly_training_x = poly.fit_transform(training_x)\npoly_testing_x = poly.transform(testing_x)\n\npd.DataFrame(poly_testing_x).head(1)","d10face7":"# Linear Regrassion applied to polynomial features gives polynomial regression\nlr = LinearRegression()\nmodel_stator = MultiOutputRegressor(estimator=lr)\nprint(model_stator)\n\n# Now, we can fit the model with train data and check the training score\nstart_time = time.perf_counter()\nmodel_stator.fit(poly_training_x, stator_training_y)\nprint(f'Stator model fitting time: {time.perf_counter() - start_time} s\\n')\n\nscore = model_stator.score(poly_training_x, stator_training_y)\nprint(f'R squared training score: {score}')","b26f00e5":"# testing prediction of starter target variables\nstator_predicted_y = model_stator.predict(poly_testing_x)\n\nr2_score = metrics.r2_score(stator_testing_y, stator_predicted_y)\nmse = metrics.mean_squared_error(stator_testing_y, stator_predicted_y)\nmae = metrics.mean_absolute_error(stator_testing_y, stator_predicted_y)\n\nprint('Error for predicting stator target variables on the testing set:\\n')\nprint(f'R squared score: {r2_score}')\nprint(f'Mean square error: {mse}')\nprint(f'Mean absolute error: {mae}')","1d902dca":"torque_training_y = training_y['torque']\ntorque_testing_y = testing_y['torque']","545571b5":"poly = PolynomialFeatures(2)\n\npoly_training_x = poly.fit_transform(training_x)\npoly_testing_x = poly.transform(testing_x)\n\npd.DataFrame(poly_testing_x).head(1)","f2a9306f":"model_torque = LinearRegression()\nprint(model_torque)\n\n# Now, we can fit the model with train data and check the training score\nstart_time = time.perf_counter()\nmodel_torque.fit(poly_training_x, torque_training_y)\nprint(f'Torque model fitting time: {time.perf_counter() - start_time} s\\n')\n\nscore = model_torque.score(poly_training_x, torque_training_y)\nprint(f'R squared training score: {score}\\n')\n\n# testing prediction of torque target variable\ntorque_predicted_y = model_torque.predict(poly_testing_x)\n\nr2_score = metrics.r2_score(torque_testing_y, torque_predicted_y)\nmse_score = metrics.mean_squared_error(torque_testing_y, torque_predicted_y)\nmae_score = metrics.mean_absolute_error(torque_testing_y, torque_predicted_y)\n\nprint('Error for predicting torque target variable on the testing set:\\n')\nprint(f'R squared score: {r2_score}')\nprint(f'Mean square error: {mse_score}')\nprint(f'Mean absolute error: {mae_score}')","8a29cb39":"motor_speed_training_y = training_y['motor_speed']\nmotor_speed_testing_y = testing_y['motor_speed']","17543375":"model_motor_speed = BaggingRegressor(random_state=RANDOM_STATE)\nprint(model_motor_speed)\n\n# Now, we can fit the model with train data and check the training score\nstart_time = time.perf_counter()\nmodel_motor_speed.fit(training_x, motor_speed_training_y)\nprint(f'Motor_speed model fitting time: {time.perf_counter() - start_time} s\\n')\n\nscore = model_motor_speed.score(training_x, motor_speed_training_y)\nprint(f'R squared training score: {score}\\n')\n\n# testing prediction of torque target variable\nmotor_speed_predicted_y = model_motor_speed.predict(testing_x)\n\nr2_score = metrics.r2_score(motor_speed_testing_y, motor_speed_predicted_y)\nmse_score = metrics.mean_squared_error(motor_speed_testing_y, motor_speed_predicted_y)\nmae_score = metrics.mean_absolute_error(motor_speed_testing_y, motor_speed_predicted_y)\n\nprint('Error for predicting motor speed target variable on the testing set:\\n')\nprint(f'R squared score: {r2_score}')\nprint(f'Mean square error: {mse_score}')\nprint(f'Mean absolute error: {mae_score}')","29b6d705":"I will create a list of input variabes","89cb8ac9":"There are no missing values or duplicates in this dataset and all variables are of type float","56f82d45":"Basic domain knowledge: <\/br>\nOhm's law: I = U\/R\n\nThe [Direct-quadrature-zero transformation](https:\/\/en.wikipedia.org\/wiki\/Direct-quadrature-zero_transformation) transformation can be thought of in geometric terms as the projection of the three separate sinusoidal phase quantities onto two axes rotating with the same angular velocity as the sinusoidal phase quantities.","854c1b1f":"I will keep only the columns described in the task above and remove other columns","f5107fdd":"Observations:\n- **stator_tooth**, **stator_winding** and **stator_yoke** are correlated between themselfs\n- **torque** has the maximum correlation coeff - 1 with **i_q**, and strong negative correlation with **u_d**\n- **motor_speed** has strong positive correlation with **u_q** and strong negative correlation with **i_d**\n- **stator_yoke** is significantly correlated with **coolant** and less significantly with **ambient**\n- **stator_tooth** and **stator_winding** have positive correlation with **coolant** and negative correlation with **i_d**\n- **i_q** and **u_d** have strong negative correlation\n","6d11bc57":"I will match column names with the titles in the task description by creating a dictionary. Later I will use the titles for Data Visualization","d21a09f1":"I am using **polynomial features** because of non-linearity in relationship of stator parameters and input variables","4a4b6a04":"## Train regression model\n\n**Stator target variables** are dependent upon the input and upon each other. Because of that, I am using **multi-output regression**. This means that a model predicts both outputs together or each output contingent upon the other outputs","0ae95bcd":"## Load the data","d9a85557":"**Motor speed**: I decided to use the power of of ensemble methods. \nA Bagging regressor is an ensemble meta-estimator that fits base regressors each on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction","70ebdd9d":"## Goal\nI do this work as a test task for a Data Scientist role in a Financial Domain. I am not familiar with the Electric Motor domain area. I have 3-4 days to complete the task working part time\n\nThe main objective is to create an AI-based model, which can work with the data in the form presented below, describing the work of the motor in the most accurate way.\n\nThe output data is described by:\n- Motor speed\n- Motor torque\n- Stator tooth temperature\n- Stator yoke temperature\n- Stator winding temperature\n\nThe intput data is described by:\n- Voltage q-component\n- Voltage d-component\n- Current d-component\n- Current q-component\n- Coolant temperature\n- Ambient temperature\n\nThe form, structure, and other parameters of the model are adjustable and should be defined by the applicant. The end-version of the model should have 5 output parameters listed above. The model should be trained with 80% of the available data, while remaining 20% of the dataset should be used for model accuracy and adequacy testing.","078860a5":"Let's get idea of distribution of independent variables by looking at their histplots","7e5c615e":"## Visualize data","3c96778e":"## Split data\n\n\"The model should be trained with 80% of the available data, while remaining 20% of the dataset should be used for model accuracy and adequacy testing.\" - from the task requirements","418cfa36":"## Exploratory data analysis","a6c7e538":"I see that \n- **stator yoke** has non linear relationship with ambient and coolant temperature\n- **stator tooth**, **stator winding** and **stator yoke** are highly dependent between themselvs\n- **Motor torque** has linear dependence upon i_q and u-d components\n","9a89edf4":"**Coolant** and **ambient** are measurments of temperature and are in the same units. I want to scale them between -1 and 1 as features for current and ambient. But I want to keep accordance with temperature values of both variables. Because the max of coolant is much higher then the max of ambient I will apply transformation of the coolant on ambient to keep the accordance","7ccd471b":"Then I will rearrange the columns and put independent input columns first","afe796e2":"I observe that zero value appears most frequently in columns representing coordinates for current and voltage\n\nCoolant and ambient are measured in the same units. The highest peak of coolant is at the value 20 and the highest peak of of ambient is at the value 26. Values 20, 23 and 25 of ambient and 50 of coolant also have peaks ","345e1791":"## Data Preprocessing\n\nI see that current and voltage variables have peaks at zero. I want to scale data around zero. For this purpose I will use MaxAbsScaler. The method scales each feature by its maximum absolute value. The result is in the interval [-1, 1]","808dd0e2":"**Torque target variable**: I decided to use **linear regression** because torque has linear dependence and maximum correlation with the current q component. But I tried a second order polynomial regression to improve the result and it worked even better. Torque might have non-linear dependence with some input coordinates","01853827":"## Import the required libraries","5ccf031d":"I see outliers in coolant, ambient, i_q and u_d"}}