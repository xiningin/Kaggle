{"cell_type":{"ffafc26f":"code","5db81b37":"code","099ef303":"code","ce5ae514":"code","0a59a6c4":"code","5210f8ac":"code","5a6e41b8":"code","e9b82684":"code","9826f74d":"code","bbfcd6c2":"code","d9e31fbc":"code","e7b4a6d2":"code","81b3c1c0":"code","cfdf7752":"code","3e435dee":"code","48828250":"markdown","012b0f0c":"markdown","e17a56ec":"markdown","194aa600":"markdown","22658175":"markdown","1a07d715":"markdown","b6aced16":"markdown","00a11349":"markdown","895b18c6":"markdown","23f46d7a":"markdown"},"source":{"ffafc26f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in\n\nfrom pathlib import Path\nimport torch\nfrom torch.utils.data import TensorDataset ,DataLoader\nfrom torch import nn,optim\nimport torch.nn.functional as F\nimport numpy as np\nimport pandas as pd\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfrom sklearn.model_selection import train_test_split\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","5db81b37":"train=pd.read_csv('\/kaggle\/input\/train.csv')\ntest=pd.read_csv('\/kaggle\/input\/test.csv')\ntrain.shape,test.shape","099ef303":"x=train.drop(\"label\",axis=1)\ny=np.array(train['label'])\nx.shape,y.shape","ce5ae514":"torch_X_train = torch.from_numpy(x.values).type(torch.FloatTensor)\/255\ntorch_y_train = torch.from_numpy(y).type(torch.LongTensor)\nmyDataset = torch.utils.data.TensorDataset(torch_X_train,torch_y_train)\nvalid_no  = int(0.2 * len(myDataset))\n# so divide the data into trainset and testset\ntrainSet,testSet = torch.utils.data.random_split(myDataset,(len(myDataset)-valid_no,valid_no))\nprint(f\"len of trainSet {len(trainSet)} , len of testSet {len(testSet)}\")\nbatch_size=64\ntrain_loader  = DataLoader(trainSet , batch_size=batch_size ,shuffle=True) \ntest_loader  = DataLoader(testSet , batch_size=batch_size ,shuffle=True)","0a59a6c4":"from torch import nn, optim\nclass Network(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fc1 = nn.Linear(784, 256)\n        self.fc2 = nn.Linear(256, 128)\n        self.fc3 = nn.Linear(128, 64)\n        self.fc4 = nn.Linear(64, 10)\n\n        # Dropout module with 0.2 drop probability\n        self.dropout = nn.Dropout(p=0.2)\n\n    def forward(self, x):\n        # make sure input tensor is flattened\n        x = x.view(x.shape[0], -1)\n\n        # Now with dropout\n        x = self.dropout(F.relu(self.fc1(x)))\n        x = self.dropout(F.relu(self.fc2(x)))\n        x = self.dropout(F.relu(self.fc3(x)))\n\n        # output so no dropout here\n        x = F.log_softmax(self.fc4(x), dim=1)\n\n        return x\n        \nmodel=Network()\noptimizer=torch.optim.SGD(model.parameters(), lr=0.04, weight_decay= 1e-7, momentum = 0.9, nesterov = True)\ncriterion=nn.CrossEntropyLoss()","5210f8ac":"epochs=25\ntrain_losses,test_losses=[],[]\nfor e in range(epochs):\n    running_loss=0\n    for images,labels in train_loader:\n        optimizer.zero_grad()\n        log_ps=model(images)\n        loss=criterion(log_ps,labels)\n        loss.backward()\n        optimizer.step()\n        running_loss+=loss.item()\n        \n    else:\n        test_loss=0\n        accuracy=0\n        \n        with torch.no_grad():\n            model.eval()\n            for images,labels in test_loader:\n                log_ps=model(images)\n                test_loss+=criterion(log_ps,labels)\n                ps=torch.exp(log_ps)\n                top_p,top_class=ps.topk(1,dim=1)\n                equals=top_class==labels.view(*top_class.shape)\n                accuracy+=torch.mean(equals.type(torch.FloatTensor))\n        model.train()\n        train_losses.append(running_loss\/len(train_loader))\n        test_losses.append(test_loss\/len(test_loader))\n\n        print(\"Epoch: {}\/{}.. \".format(e+1, epochs),\n              \"Training Loss: {:.3f}.. \".format(running_loss\/len(train_loader)),\n              \"Test Loss: {:.3f}.. \".format(test_loss\/len(test_loader)),\n              \"Test Accuracy: {:.3f}\".format(accuracy\/len(test_loader)))    ","5a6e41b8":"print(\"Our model: \\n\\n\", model, '\\n')\nprint(\"The state dict keys: \\n\\n\", model.state_dict().keys())","e9b82684":"torch.save(model.state_dict(), 'checkpoint.pth')","9826f74d":"state_dict = torch.load('checkpoint.pth')\nprint(state_dict.keys())","bbfcd6c2":"model.load_state_dict(state_dict)","d9e31fbc":"checkpoint = {'input_size': 784,\n              'output_size': 10,\n              'hidden_layers': [256,128,64],\n              'state_dict': model.state_dict()}\n\ntorch.save(checkpoint, 'checkpoint.pth')","e7b4a6d2":"test_images = pd.read_csv(\"\/kaggle\/input\/test.csv\")\ntest_image = test_images.loc[:,test_images.columns != \"label\"].values\ntest_dataset = torch.from_numpy(test_image).type(torch.FloatTensor)\/255\nprint(test_dataset.shape)\n#test_dataset = torch.utils.data.TensorDataset(test_dataset)\nnew_test_loader = torch.utils.data.DataLoader(test_dataset, batch_size = 100, shuffle = False)","81b3c1c0":"results = []\nwith torch.no_grad():\n    model.eval()\n    for images in new_test_loader:\n        output = model(images)\n        ps = torch.exp(output)\n        top_p, top_class = ps.topk(1, dim = 1)\n        results += top_class.numpy().tolist()","cfdf7752":"predictions = np.array(results).flatten()\nprint(predictions[:5])\nprint(predictions.shape)","3e435dee":"submissions=pd.DataFrame({\"ImageId\": list(range(1,len(predictions)+1)),\n                         \"Label\": predictions})\nsubmissions.to_csv(\"my_submissions.csv\", index=False, header=True)","48828250":"## Load Data ","012b0f0c":"## Check the results","e17a56ec":"## Extracting Input and Target Variable","194aa600":"![](images\/mlp.png)","22658175":"## Save the model","1a07d715":"## Network","b6aced16":"## Load Test Data","00a11349":"## Submit for Scoring","895b18c6":"## Train -Test Split -Pytorch","23f46d7a":"## Train "}}