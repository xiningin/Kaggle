{"cell_type":{"e881c6ba":"code","0ee62dd9":"code","8ea7701e":"code","0b00e674":"code","694e1f08":"code","abdb5e9d":"code","81eb425d":"code","4b7d327c":"code","13e5784c":"code","5f8cd1c9":"code","d9fa3a9a":"code","40ac8135":"code","9fc0984b":"code","7b57b46c":"code","65ce1e25":"code","5932d9c2":"code","925e04b7":"code","b52933ca":"code","bd0c3be2":"code","64707712":"code","90d15218":"code","5002b637":"code","1862f729":"code","247fe733":"code","80aa41c1":"code","4bf1669e":"markdown","4ce6c82d":"markdown","c1757842":"markdown","54b32095":"markdown","cbc1a76a":"markdown","bf5b9ab2":"markdown","c6c952d1":"markdown","213d9ad5":"markdown","361e862a":"markdown","e65594da":"markdown","ffa75b07":"markdown","914c3227":"markdown","215cf468":"markdown","40ef5075":"markdown","08cf1b6e":"markdown","56ea857e":"markdown","1dd18ca4":"markdown","683d0875":"markdown","9f0f79af":"markdown","da1b8d72":"markdown","de41f695":"markdown","f1f0b51e":"markdown","94fe7a96":"markdown","f20fd136":"markdown","f0700e2e":"markdown","121810c8":"markdown","224455d4":"markdown","b5a2c22c":"markdown","a5ae5615":"markdown"},"source":{"e881c6ba":"# Import necessary libraries\nimport numpy as np\nfrom numpy import median\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nfrom sklearn.preprocessing import StandardScaler, RobustScaler\nfrom sklearn.model_selection import train_test_split, StratifiedKFold, RepeatedStratifiedKFold, cross_val_score, GridSearchCV, RandomizedSearchCV, KFold\nfrom scipy import stats\nfrom sklearn.pipeline import Pipeline, make_pipeline\nfrom imblearn.pipeline import make_pipeline, Pipeline\nfrom sklearn.metrics import f1_score, confusion_matrix, classification_report, recall_score, precision_score, plot_precision_recall_curve\nfrom sklearn.model_selection import learning_curve\nfrom sklearn.feature_selection import RFECV, SelectKBest, f_classif\nfrom imblearn.over_sampling import SMOTE, RandomOverSampler\nfrom collections import Counter\nfrom imblearn.under_sampling import RandomUnderSampler\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC","0ee62dd9":"# Ignore warnings\nwarnings.filterwarnings(\"ignore\") \n# Import data\ndata = pd.read_csv('..\/input\/company-bankruptcy-prediction\/data.csv')","8ea7701e":"# Inspect data\ndata.head()","0b00e674":"# Create copy of df\ndf = data.copy()\n# Check Missing data\ndf.isnull().sum().any()","694e1f08":"# Shape of df\nprint(\"Number of rows : {}\".format(df.shape[0]), '\\n'\n      \"Number of cols : {}\".format(df.shape[1]))","abdb5e9d":"# Set X and y \nX = df.iloc[:, 1:].values\ny = df.iloc[:, 0].values\n# Set training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)","81eb425d":"# Set RandomForestClassifier as estimator for RFECV\ncart = RandomForestClassifier(random_state=42)\n# Minimum number of features to consider\nmin_features_to_select = 1  \n# Set number of folds\ncv = RepeatedStratifiedKFold(n_splits=5, n_repeats=1, random_state=1) \n# Set cross-validation process\nrfecv = RFECV(estimator=cart, step=1, cv=cv,\n              scoring='accuracy',\n              min_features_to_select=min_features_to_select, n_jobs=1)\n# Fit the model\nrfecv.fit(X_train, y_train)\n\nprint(\"Optimal number of features : %d\" % rfecv.n_features_)\n\n# Plot number of features VS. cross-validation scores\nplt.figure()\nplt.xlabel(\"Number of features selected\")\nplt.ylabel(\"Cross validation score (nb of correct classifications)\")\nplt.plot(range(min_features_to_select,\n               len(rfecv.grid_scores_) + min_features_to_select),\n         rfecv.grid_scores_)\nplt.show()","4b7d327c":"# Display features' names\nmost_relevent_cols = df.iloc[:, 1:].columns[np.where(rfecv.support_ == True)]\nprint(\"Most relevant features are: \")\nprint(most_relevent_cols)","13e5784c":"# Append target\nmost_relevent_cols = list(most_relevent_cols)\nmost_relevent_cols.append(\"Bankrupt?\")","5f8cd1c9":"# Display df\nrfecv_df = df[most_relevent_cols]\nrfecv_df.head()","d9fa3a9a":"# Descriptive stats\nrfecv_df.describe()","40ac8135":"# Analyse target var\nsns.countplot(rfecv_df['Bankrupt?'])\n# Target \nprint(\"% of Data\") \nprint(df['Bankrupt?'].value_counts(normalize=True))\nprint(\"Count\")\nprint(df['Bankrupt?'].value_counts())","9fc0984b":"# Looking at the histograms of numerical data\nrfecv_df.hist(figsize = (35,30), bins = 50)\nplt.show()","7b57b46c":"# Correlations\nrfecv_df.corr('spearman')[\"Bankrupt?\"].sort_values() \n# Correlation Heatmap (Spearman)\nf, ax = plt.subplots(figsize=(30, 25))\nmat = rfecv_df.corr('spearman')  \nmask = np.triu(np.ones_like(mat, dtype=bool))\ncmap = sns.diverging_palette(230, 20, as_cmap=True)\nsns.heatmap(mat, mask=mask, cmap=cmap, vmax=1, center=0,# annot = True,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})\nplt.show()","65ce1e25":"# Seperate dfs\nbankrupt_df = rfecv_df[rfecv_df['Bankrupt?']==True]\nnot_bankrupt_df = rfecv_df[rfecv_df['Bankrupt?']==False]\n\n# Analyze distributions of selected features using rfecv\ncols = rfecv_df.drop(\"Bankrupt?\", axis=1).columns\n\nfor feature in cols:\n  a = bankrupt_df[feature]\n  b = not_bankrupt_df[feature]\n  b = b.sample(n=len(a), random_state=42) # Take random sample from each feature to match length of target\n  # Running t-tests\n  test = stats.ttest_ind(a,b)   \n  plt.figure() \n  sns.distplot(bankrupt_df[feature], kde=True, label=\"Bankrupt\")\n  sns.distplot(not_bankrupt_df[feature], kde=True, label=\"Not Bankrupt\") \n  plt.title(\"{} \/ p-value of t-test = :{}\".format(feature, test[1]))\n  plt.legend()","5932d9c2":"# Visulize outliers using boxplots\nplt.figure(figsize = (20,20))\nax =sns.boxplot(data= rfecv_df, orient=\"h\")\nax.set_title('Features_selected Boxplots', fontsize = 18)\nax.set(xscale=\"log\")\nplt.show()","925e04b7":"# Evaluation function \ndef evaluation(model):\n  model.fit(X_train, y_train)\n  ypred = model.predict(X_test)\n  print(confusion_matrix(y_test, ypred))\n  print(classification_report(y_test, ypred))\n    \n  N, train_score, val_score = learning_curve(model, X_train, y_train,\n                                              cv=5, scoring='f1',\n                                               train_sizes=np.linspace(0.1, 1, 10))\n    \n    \n  plt.figure(figsize=(12, 8))\n  plt.plot(N, train_score.mean(axis=1), label='train score')\n  plt.plot(N, val_score.mean(axis=1), label='validation score')\n  plt.legend()","b52933ca":"# Set X and y \nX = rfecv_df.iloc[:, :-1]\ny = rfecv_df.iloc[:, -1]\n# Set training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)","bd0c3be2":"# Set models with default params\nRandomForest = RandomForestClassifier(random_state=0)\nAdaBoost = AdaBoostClassifier(random_state=0)\nKNN = make_pipeline(StandardScaler(), KNeighborsClassifier())\n# Set dictionary of models\ndict_of_models = {'RandomForest': RandomForest,\n                  'AdaBoost' : AdaBoost,\n                  'KNN': KNN\n                  \n                 }","64707712":"# Evaluate models\nfor name, model in dict_of_models.items():\n    print(name)\n    evaluation(model)","90d15218":"# USING OVERSAMPLING ONLY\nkf = RepeatedStratifiedKFold(n_splits=5)\n# Set empty lists to store key metrics\naccuracy = []\nf1 = []\nrecall =[]\nprecision = []\n# Loop over kfolds\nfor kf, (train_index, test_index) in enumerate(kf.split(X, y), 1):\n    X_train = X[train_index, :]\n    y_train = y[train_index]  \n    X_test = X[test_index, :]\n    y_test = y[test_index]  \n    # Set pipeline where SMOTE with oversampling is applied before model fitting\n    model = make_pipeline(SMOTE() ,RandomForestClassifier(random_state=0))\n    # Fit model\n    model.fit(X_train, y_train)\n    # Predict on original test set  \n    y_pred = model.predict(X_test)\n    # Compute key metrics for target \"Bankrupt = 1\"\n    accuracy.append(model.score(X_test, y_test))\n    f1.append(f1_score(y_test, y_pred))\n    recall.append(recall_score(y_test, y_pred))\n    precision.append(precision_score(y_test, y_pred))\n# Print key metrics      \nprint(\"Mean accuracy:\", np.mean(accuracy))\nprint(\"Mean f1\", np.mean(f1))\nprint(\"Mean recall\", np.mean(recall))\nprint(\"Mean precision\", np.mean(precision))","5002b637":"# SMOTE startegy with both over and undersampling\nover = SMOTE(sampling_strategy=0.1)\nunder = RandomUnderSampler(sampling_strategy=0.5)","1862f729":"# USING BOTH OVER AND UNDERSAMPLING\nkf = RepeatedStratifiedKFold(n_splits=5)\n# Set empty lists to store key metrics\naccuracy = []\nf1 = []\nrecall =[]\nprecision = []\n# Loop over kfolds\nfor kf, (train_index, test_index) in enumerate(kf.split(X, y), 1):\n    X_train = X[train_index, :]\n    y_train = y[train_index]  \n    X_test = X[test_index, :]\n    y_test = y[test_index]  \n    # Set pipeline where SMOTE is applied before model fitting\n    model = make_pipeline(over, under ,RandomForestClassifier(random_state=0))\n    # Fit model\n    model.fit(X_train, y_train)\n    # Predict on original test set  \n    y_pred = model.predict(X_test)\n    # Compute key metrics for target \"Bankrupt = 1\"\n    accuracy.append(model.score(X_test, y_test))\n    f1.append(f1_score(y_test, y_pred))\n    recall.append(recall_score(y_test, y_pred))\n    precision.append(precision_score(y_test, y_pred))\n# Print key metrics      \nprint(\"Mean accuracy:\", np.mean(accuracy))\nprint(\"Mean f1\", np.mean(f1))\nprint(\"Mean recall\", np.mean(recall))\nprint(\"Mean precision\", np.mean(precision))","247fe733":"# USING OVERSAMPLING ONLY\nkf = RepeatedStratifiedKFold(n_splits=5)\n# Set empty lists to store key metrics\naccuracy = []\nf1 = []\nrecall =[]\nprecision = []\n# Loop over kfolds\nfor kf, (train_index, test_index) in enumerate(kf.split(X, y), 1):\n    X_train = X[train_index, :]\n    y_train = y[train_index]  \n    X_test = X[test_index, :]\n    y_test = y[test_index]  \n    # Set pipeline where SMOTE is applied before model fitting\n    model = make_pipeline(SMOTE() ,AdaBoostClassifier(random_state=0))\n    # Fit model\n    model.fit(X_train, y_train)\n    # Predict on original test set  \n    y_pred = model.predict(X_test)\n    # Compute key metrics for target \"Bankrupt = 1\"\n    accuracy.append(model.score(X_test, y_test))\n    f1.append(f1_score(y_test, y_pred))\n    recall.append(recall_score(y_test, y_pred))\n    precision.append(precision_score(y_test, y_pred))\n# Print key metrics      \nprint(\"Mean accuracy:\", np.mean(accuracy))\nprint(\"Mean f1\", np.mean(f1))\nprint(\"Mean recall\", np.mean(recall))\nprint(\"Mean precision\", np.mean(precision))","80aa41c1":"# # USING BOTH OVER AND UNDERSAMPLING\nkf = RepeatedStratifiedKFold(n_splits=5)\n# Set empty lists to store key metrics\naccuracy = []\nf1 = []\nrecall =[]\nprecision = []\n# Loop over kfolds\nfor kf, (train_index, test_index) in enumerate(kf.split(X, y), 1):\n    X_train = X[train_index, :]\n    y_train = y[train_index]  \n    X_test = X[test_index, :]\n    y_test = y[test_index]  \n    # Set pipeline where SMOTE is applied before model fitting\n    model = make_pipeline(over, under ,AdaBoostClassifier(random_state=0))\n    # Fit model\n    model.fit(X_train, y_train)\n    # Predict on original test set  \n    y_pred = model.predict(X_test)\n    # Compute key metrics for target \"Bankrupt = 1\"\n    accuracy.append(model.score(X_test, y_test))\n    f1.append(f1_score(y_test, y_pred))\n    recall.append(recall_score(y_test, y_pred))\n    precision.append(precision_score(y_test, y_pred))\n# Print key metrics      \nprint(\"Mean accuracy:\", np.mean(accuracy))\nprint(\"Mean f1\", np.mean(f1))\nprint(\"Mean recall\", np.mean(recall))\nprint(\"Mean precision\", np.mean(precision))","4bf1669e":"  ## Final Conclusion","4ce6c82d":"## Introduction","c1757842":"RFC and AdaBoost seem to yield highest f1 score. We'll continue using these models. But since the data is very imbalanced, the model will obviously be biased towards the majority class. We'll use SMOTE in order to rebalance the data. SMOTE works by selecting examples that are close in the feature space, drawing a line between the examples in the feature space and drawing a new sample at a point along that line.","54b32095":"Most of the values in the data range between 0 and 1. But we can see that there are some extreme values (outliers). ","cbc1a76a":"Since this is a binary classification problem, we are more interested by predicting the positive value namely the Bankrupt category = 1. The positive category is our minority class and this will pose a real challenge for machine learning models. The best way to measure the performance of our models in this case is by computing the f1 score which is the average of our recall and precision. Recall or also called sensitivity is the metric that gives us true positive rate which is the correctly classified positives out of all possible positives, while precision will tell us what is the proportion of correctly classified positive out of all predicted positives. Recall has as main goal to minimize false negatives while precision aims to minimize false positives. ","bf5b9ab2":"In this part, I'm going to do some Exploratory Data Analysis on the features previously selected by RFECV. Understanding our features is key for building more accurate machine learning models.","c6c952d1":"### b) SMOTE & RandomForestClassifier","213d9ad5":"## C) Outliers's Analysis","361e862a":"### a) Descriptive statistics","e65594da":"Adaboost yielded lower f1 score, although the recall drastically improved. This model will have a quite high sensitivity meaning it will correctly detect True Positives namely companies that will go bankrupt but will also give high proportion of False Positives (around 80%). ","ffa75b07":"This data has a large number of features. In order to make the EDA easier and improve the accuracy of machine learning models, we need to reduce the dimensionality of the data. For this purpose, I'm going to use a famous feature selection method named Recursive Feature Elimination. Recursive feature elimination is an example of backward feature elimination in which we essentially first fit our model using all the features in a given set, then progressively one by one we remove the least significant features, each time re-fitting, until we are left with the desired number of features","914c3227":"We can observe that our dataset is very imbalanced. The minority class which is the one we're most interested by predicting represents about 3% of total observations. This can pose a real challenge to machine learning models.","215cf468":"### a) Testing models","40ef5075":"Adaboost seem to yield slightly better f1 score with this SMOTE startegy. ","08cf1b6e":"We can see that most features don't follow a normal distribution and many of them have very skwed distribution. This might be solved by applying a log transformation but as you'll see later in the notebook, I'll chose to simply replace extreme positive values with the median of the target group. ","56ea857e":"## B) EDA","1dd18ca4":"The data contains no missing values. ","683d0875":"In this notebook, we're going to predict companies that go bankrupt. I'm new here on Kaggle and I'd really like an upvote from your part if you liked this work, this will really encourage me to keep doing projects like that. Also if you have any suggestions or remarks please let me know on the comment section. Thanks ! \n\nDataset description provided: \"The data were collected from the Taiwan Economic Journal for the years 1999 to 2009. Company bankruptcy was defined based on the business regulations of the Taiwan Stock Exchange.\"","9f0f79af":"### **Conclusions:** \nThe following are some features that significantly differentiate the two groups of our target. The definitions of these indicators were all taken from Investopedia which is a widely known finance website.\n\n- **ROA (C) + ROA(A)** : Companies that encounter financial difficulties  tend to have lower ROA. ROA is an indicator of how profitable a company is relative to its total assets. ROA gives a manager, investor, or analyst an idea as to how efficient a company's management is at using its assets to generate earnings. ROA is displayed as a percentage; the higher the ROA the better.\n\n- **Net Value per Share** : This is the ratio of equity available to common shareholders divided by the number of outstanding shares. This figure represents the minimum value of a company's equity and measures the book value of a firm on a per-share basis. \n\n- **Persistent EPS & Per Share Net Profit**  : Earnings per share (EPS) is calculated as a company's profit divided by the outstanding shares of its common stock. The resulting number serves as an indicator of a company's profitability. \n\n- **Net worth\/Total Assets** : The higher the equity-to-asset ratio, the less leveraged the company is, meaning that a larger percentage of its assets are owned by the company and its investors.\n\n- **Cash\/Totat Assets** : This figure is used to measure a firm's liquidity or its ability to pay its short-term obligations. The higher the better.\n","da1b8d72":"### Conclusion:\n\nRandomForestClasifier + Oversampling gave us the highest f1 score of about 43% with 58% Recall and 34% Precision. ","de41f695":"### b) Analysis of variance and hypothesis testing","f1f0b51e":"We can use SMOTE to either oversample the minority class or undersample the majority class in order to rebalance the data. Other strategies of rebalancing the data are possible for example using both oversampling and undersampling at the same time. In our approach we'll test both the oversampling and over\/undersampling strategy. Since machine learning models are automatically biased towards the majority class, using SMOTE will hopefully make the training process of the model more reliable.","94fe7a96":"## D) Predicting Bankruptcy","f20fd136":"This dataset contains too many outliers. ","f0700e2e":"### c) SMOTE & AdaBoost","121810c8":"We can see that by applying oversampling, the f1 score slightly improve. We sig improved our recall but our precision went down. ","224455d4":"Using both over and undersampling yielded a less greater f1 score but the recall increased sharply.","b5a2c22c":"I'll first use the features selected by the RFECV to test the models on. Later on, I'll use the SelectKbest features' selection.","a5ae5615":"## A) Recursive Feature Elimination with Cross-validation (RFECV):\n\n\n"}}