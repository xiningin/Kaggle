{"cell_type":{"2b7d8e4e":"code","8c172dc9":"code","9026f5c2":"code","9917778c":"code","69feca0a":"code","d50129f8":"code","1c6879ce":"code","fbae17c9":"code","560bf649":"code","b4f95f0d":"code","5e53d54f":"code","5918310b":"code","997b3b7c":"code","a9baadae":"markdown","17d4474f":"markdown","c1fb88de":"markdown","cb2b354c":"markdown","cd78dbad":"markdown","40f5f57a":"markdown","a704d3f8":"markdown","cc6efad1":"markdown","c4f7de78":"markdown","48c3153b":"markdown","94718f12":"markdown","31f25710":"markdown","eb454d2e":"markdown","94327a30":"markdown","4a9d2fa6":"markdown"},"source":{"2b7d8e4e":"!pip install staircase==2.0.0rc1","8c172dc9":"import staircase as sc\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.dates import MonthLocator, DateFormatter\n\n\nmelbourne_file_path = '..\/input\/melbourne-housing-snapshot\/melb_data.csv'\nmelbourne_data = pd.read_csv(melbourne_file_path, parse_dates=[\"Date\"]) \nmelbourne_data.head()","9026f5c2":"fig, ax = plt.subplots(figsize=(20,4))\nax.xaxis.set_major_locator(MonthLocator())\nax.xaxis.set_major_formatter(DateFormatter(\"%b-%y\"))\n\nhouses_sold = sc.Stairs(melbourne_data, start=\"Date\")\nhouses_sold.plot(ax)\n\nax.set_title(\"Number of houses sold over time\")","9917778c":"sc.Stairs?","69feca0a":"fig, ax = plt.subplots(figsize=(20,4))\nax.xaxis.set_major_locator(MonthLocator())\nax.xaxis.set_major_formatter(DateFormatter(\"%b-%y\"))\n\nsum_houses_prices = sc.Stairs(melbourne_data, start=\"Date\", value=\"Price\")\nsum_houses_prices.plot(ax)\n\nax.set_title(\"Sum of houses prices sold over time\")","d50129f8":"fig, ax = plt.subplots(figsize=(20,4))\nax.xaxis.set_major_locator(MonthLocator())\nax.xaxis.set_major_formatter(DateFormatter(\"%b-%y\"))\n\nav_house_prices = sum_houses_prices\/houses_sold\nav_house_prices.plot(ax)\n\nax.set_title(\"Average houses prices over time\")","1c6879ce":"sample_times = melbourne_data[\"Date\"] - pd.Timedelta(0.5, \"day\")  # half a day earlier\nsample_times","fbae17c9":"av_price_samples = av_house_prices(sample_times)\nav_price_samples","560bf649":"melbourne_data[\"average_price\"] = av_price_samples\nmelbourne_data.head()","b4f95f0d":"pd.Series(\n    av_house_prices.limit(sample_times, side=\"left\")\n)","5e53d54f":"def create_av_price_step_function(df):\n    sum_prices = sc.Stairs(df, start=\"Date\")\n    count = sc.Stairs(df, start=\"Date\", value=\"Price\")\n    return sum_prices\/count\n\nmelbourne_data.groupby(\"Suburb\").apply(create_av_price_step_function)","5918310b":"time_window = pd.Timedelta(12, \"W\")  # 12 weeks\nexpiry = melbourne_data[\"Date\"] + time_window\nsc.Stairs(melbourne_data, start=\"Date\", value=\"Price\")\n\nsum_prices = sc.Stairs(melbourne_data, start=\"Date\", end=expiry)\ncount = sc.Stairs(melbourne_data, start=\"Date\", end=expiry, value=\"Price\")\nav_house_prices = sum_prices\/count","997b3b7c":"fig, ax = plt.subplots(figsize=(20,4))\nax.xaxis.set_major_locator(MonthLocator())\nax.xaxis.set_major_formatter(DateFormatter(\"%b-%y\"))\n\nav_house_prices.plot(ax)\n\nax.set_title(\"Average houses prices over time (12 week rolling window)\")","a9baadae":"### Rolling average using time window\n\nIn this example the calculate the average house price, however it only takes into account houses from the past 12 weeks.","17d4474f":"Now, for the houses sold on the earliest date in this dataset there will be no average house price data, and there will be missing values in the average_price column for these houses.  These values would need to be imputed before proceeding.  The average_price column can then be used as an input to a machine learning model.\n\nLater in the *Intermediate Machine Learning* Kaggle course target leakage is discussed in the context of surgery success rates.  Applying staircase there is semantically the same.  Calculate a step function which counts successful surgeries over time (per surgeon).  Calculate a step function which counts all surgeries over time (per surgeon).  Divide the step functions to obtain an average success rate.  Target leakage is just one application for staircase, it also makes quick work of queue counts, machine utilisations - anything where a state alters over time.\n\nSo what's next?  We'll quickly run through advanced usage.  Explanations are beyond the scope of this tutorial, however please see links to documentation at the bottom of the page.","c1fb88de":"We can see that one of the columns is *Price* and one of the columns is *Date*.  The date column does not appear to have a time component (i.e. hour\/minute\/second) but staircase could have handled this too.\n\nstaircase is built around the concept of mathematical step functions.  A [step function](https:\/\/en.wikipedia.org\/wiki\/Step_function) is piecewise constant.  This means it is made up of horizontal lines.  Whenever there is date\/time data in a dataset there are immediately step functions which spring to life.  For example, in this dataset the following are variables:\n\n* the number of houses sold, up to a particular point in time\n* the number of houses sold in Abbotsford, up to a particular point in time\n* the number of houses with more than 2 bathrooms sold, up to a particular point in time\n* the total sum of house prices, up to a particular point in time\n\nAs these variables change as time moves along, they give rise to step functions:\n\n* the number of houses sold over time\n* the number of houses sold in Abbotsford over time\n* the number of houses with more than 2 bathrooms sold over time\n* the total sum of house prices over time\n\nYou get the idea... each time a house is sold the value of \"number of houses sold\" increases by one, and the value of \"total sum of house prices\" increases by the price of the house.  We can take these two step functions and divide them to get another step function.  That step function will correspond to \"the average house price over time\", and that is what we are aiming to calculate.","cb2b354c":"## Installing staircase\n\nIn the cell below we install the staircase package via pip.  Note that we are specifying the lastest pre-release version 2.0.0rc1.  If we just used *pip install staircase* it would install the version 1.6.6 which is not suitable for this exercise.  The first official version of 2.0.0 will be released in late August 2021.\n\nYou will make sure that *internet* is set to *ON* in your notebook settings (under data section) otherwise you will not be able to retrieve the staircase package.","cd78dbad":"As you can see as time goes on the average is less variable.  It settles down as more and more houses are taken into account when calculating the average.  It is also possible to calculate rolling averages too, whether by a fixed number of previous houses, or with a time based rolling window, eg \"previous month\".  This will be discussed later.\n\nSo how do we get use this information in our training set?  If a house is sold on a particular date then we want to know the average house price up until that point.  Given the date in our dataset are at the day level it is sufficient to examine the value of the step function the day before.\n\nFor each of our houses, we can calculate this date like so:","40f5f57a":"![staircase](https:\/\/raw.githubusercontent.com\/staircase-dev\/staircase-logo\/c8b0ef63616f1362fe210e874f0fd44f47d927f4\/staircase.svg)\n\nThis notebook has been created to demonstrate a handy addition to your python toolkit: **staircase**\n\nIn particular we will use staircase to help us set up our dataset to use pricing as a input to machine learning, while avoiding *target leakage*.  \n\n**All links to documentation are at the bottom of the notebook.**\n\n## Introduction\n\nThe following is taken from the [Intermediate Machine Learning](https:\/\/www.kaggle.com\/learn\/intro-to-machine-learning) Kaggle course:\n\n> Target leakage occurs when your predictors include data that will not be available at the time you make predictions. It is important to think about target leakage in terms of the timing or chronological order that data becomes available, not merely whether a feature helps make good predictions.\n\nOne of the corresponding exercises discusses how target leakage can occur when predicting house prices, if average price data is used as an input to the machine learning model.  The problem is that when predicting a price for a particular house in reality, we will not know the price it sold for (obviously) or the price for any house sold after it.  The data used to train a machine learning model must reflect this.  Target leakage can be avoided by calculating average house prices for only houses sold prior to the one we are predicted for.  By Kaggle's own admission, this can be tricky, however staircase can make light work of this.\n\nThe demo will utilise the [Melbourne housing snapshot dataset](https:\/\/www.kaggle.com\/dansbecker\/melbourne-housing-snapshot) introduced in the [Intro to Machine Learning](https:\/\/www.kaggle.com\/learn\/intro-to-machine-learning) Kaggle course.","a704d3f8":"Next we calculate the sum of house prices.  We do this much the same way as constructing the step function for the count of houses sold, except now each sale is associated with a price via the use of the *value* parameter.","cc6efad1":"If you appreciate the tutprial and want to keep up to date with releases please head to [staircase on github](https:\/\/github.com\/staircase-dev\/staircase\/tree\/Version2) and \"star\" the repository.  You can also click \"watch\" to ensure you are kept up to date with new releases.\n\n![](https:\/\/i.imgur.com\/X5L3elG.png)\n\nYou can also see the documentation for [Version 2 here](https:\/\/www.staircase.dev\/en\/version2\/), which is currently undergoing construction.\n\nAnd don't forget until version 2 is officially released, you will need to install using\n\n`pip install staircase==2.0.0rc1`","c4f7de78":"## Importing packages and data","48c3153b":"houses_sold is an object of class *staircase.Stairs*.  The Stairs class is to staircase what Series is to pandas, and is used synonymously with \"step function\" throughout this tutorial.  The Stairs class contains a rich variety of arithmetic operations, relational operations, logical operations and statistical operations which we can use with step functions.  We show the constructor method signature below.  The parameters *start* and *end* are typically datetimes at which an event starts and ends.  In the case of houses sold, there is no corresponding *end* event - once sold a house remains in that state, it never becomes *unsold*.","94718f12":"This works because when we imported the data we indicated to pandas that \"Date\" was a datetime column with the parameter *parse_dates*.\n\nSo these are the times at which we need to know the value of our av_house_prices step function.   We can get these values by simply \"calling\" our step function as if it was a method:","31f25710":"At the moment this data is a numpy array, but we can add it to our original dataset.","eb454d2e":"We are now in a position to divide these step functions to obtain one for average house prices over time","94327a30":"### A step function per suburb\n\nWe calculate a *pandas.Series* indexed by suburb, whose values are step functions.  Using this we can calculate average house prices (up to a certain point in time) for each suburb.","4a9d2fa6":"### Sampling the step function \"immediately to the left\"\n\nWe took a shortcut above, by the fact that our dates were at the day-frequency level, and we sampled the step function the day before each sale.  What if we wanted the values of the step function up until the exact date?  This can be done with the *limit* method, which takes sample points and a *side* parameter."}}