{"cell_type":{"5d7e2e7b":"code","9a45f999":"code","c01d302f":"code","1ad6b2eb":"code","98d1d4b0":"code","b4e45fde":"code","16823c52":"code","f5f5b741":"code","d2834956":"code","0bef40a9":"code","6099b4eb":"code","aecf1e82":"code","02f37839":"markdown","fbed157a":"markdown","86734400":"markdown","32227f69":"markdown","13237037":"markdown"},"source":{"5d7e2e7b":"import numpy as np \nimport pandas as pd \nimport pymc3 as pm\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport theano.tensor as tt","9a45f999":"pitches = pd.read_csv('..\/input\/pitches.csv')\natbats = pd.read_csv('..\/input\/atbats.csv', index_col='ab_id')\ngames = pd.read_csv('..\/input\/games.csv', index_col='g_id')\nej = pd.read_csv('..\/input\/ejections.csv')","c01d302f":"pitches.dropna(inplace=True)\ncalled_pitches = pitches[pitches.code.isin(['C', 'B'])].copy()\ncalled_pitches['k'] = (called_pitches.code=='C').astype(int)\ncalled_pitches = called_pitches[(called_pitches.k == 0) | \n                                ((np.abs(called_pitches.px) < 2) & (called_pitches.pz > 0.2) &\n                                 (called_pitches.pz < 4.5))]\n\ncalled_pitches = called_pitches.join(atbats, on='ab_id')\ncalled_pitches['lefty'] = (called_pitches.stand == 'L')*1\n\nballs_strikes_ejs = ej[~(ej['BS'].isna())].groupby('g_id').head(n=1)\nballs_strikes_ejs = balls_strikes_ejs.set_index('g_id')\nballs_strikes_ejs.rename(columns={'event_num': 'ej_event_num', \n                                  'ab_id': 'ej_ab_id'}, inplace=True)\n\nej_pitches = called_pitches[['pz', 'px', 'ab_id', 'code', 'k',\n                             'event_num', 'top', 'g_id', \n                             'lefty', 'p_throws']].join(balls_strikes_ejs, how='right', on='g_id')\nej_pitches['d'] = ej_pitches.ej_event_num - ej_pitches.event_num\nej_pitches['after_ej'] = ej_pitches.d < 0\nej_pitches['ej_team_batting'] = ~(ej_pitches.top == ej_pitches.is_home_team)","1ad6b2eb":"X = ej_pitches[ej_pitches['ej_team_batting'] & ~ej_pitches['after_ej']][['px', 'pz', 'lefty', 'k']].dropna().values","98d1d4b0":"edge_means = [-1, 1, 3.5, 1.5]\nside_names = ['left', 'right', 'up', 'down']\n\nwith pm.Model() as model:\n    \n    edges = pm.Normal('edges', mu=edge_means, sd=0.2, shape=4)\n    coefs = pm.TruncatedNormal('coefs', mu=10, sd=2, lower=1, shape=4)\n    parabs = pm.Normal('parabs', mu=1, sd=1, shape=4)\n    lefty_adj = pm.Normal('lefty_adj', mu=0, sd=0.1)\n    mid_x = (edges[0] + edges[1])\/2\n    mid_y = (edges[2] + edges[3])\/2\n    \n    def calc_strike_proba(data):\n        xdata = data[:,0] + data[:,2]*lefty_adj\n        left_logodds = (xdata - edges[0])*coefs[0] + ((data[:,1] - mid_y)**2)*parabs[0]\n        right_logodds = - (xdata - edges[1])*coefs[1] - ((data[:,1] - mid_y)**2)*parabs[1]\n        up_logodds = - (data[:, 1] - edges[2])*coefs[2] - ((xdata - mid_x)**2)*parabs[2]\n        down_logodds = (data[:, 1] - edges[3])*coefs[3] + ((xdata - mid_x)**2)*parabs[3]\n\n        logodds = [left_logodds, right_logodds, up_logodds, down_logodds]\n        odds = [np.exp(lo) for lo in logodds]\n        probs = [o\/(o+1) for o in odds]\n        out_proba = probs[0]*probs[1]*probs[2]*probs[3]\n        return out_proba\n    \n    pitch_preds = calc_strike_proba(X)\n    strike_proba = pm.Bernoulli('strike_proba', p=pitch_preds, observed=X[:,3])\n    \n    res=0.05\n    xx, yy = np.meshgrid(np.arange(-1.5, 1.5, res),\n                         np.arange(1, 4.5, res))\n    grid_preds = calc_strike_proba(np.c_[xx.ravel(), yy.ravel(), xx.ravel()*0])\n    zone_size = pm.Deterministic('size_of_zone', grid_preds.sum()*(res**2)*144)\n    \n    #incon_actual = pm.Deterministic('incon_actual', \n    #                                ((1 - pitch_preds)**X[:,3]) * \n    #                                        (pitch_preds**(1-X[:,3])))\n    #incon_expected = pm.Deterministic('incon_expected', \n    #                                  ((1 - pitch_preds)**pitch_preds) * \n    #                                          (pitch_preds**(1-pitch_preds)))\n    \n    #incon_score = pm.Deterministic('incon_score', incon_actual - incon_expected)\n    \n    trace = pm.sample(1000, init='advi')","b4e45fde":"pm.plot_posterior(trace, ['size_of_zone', 'lefty_adj']);","16823c52":"pm.plot_posterior(trace);","f5f5b741":"ej_pitches['group_num'] = 2*ej_pitches['ej_team_batting'] + ej_pitches['after_ej']\nej_pitches['prob_keep'] = ej_pitches['group_num']*0 + 0.1\nej_pitches.loc[(ej_pitches.pz > 1.3) & (ej_pitches.pz < 3.7) &\n              (ej_pitches.px > -1.2) & (ej_pitches.px < 1.2), 'prob_keep'] = 1\nej_pitches.loc[(ej_pitches.pz > 1.7) & (ej_pitches.pz < 3.3) &\n              (ej_pitches.px > -.8) & (ej_pitches.px < .8), 'prob_keep'] = 0.1\nej_pitches['kept'] = np.random.uniform(size=len(ej_pitches)) < ej_pitches.prob_keep\n\nsubsamp = ej_pitches[ej_pitches['kept']].dropna()\nX = subsamp[['px', 'pz', 'lefty', 'k']].values\ngroup_nums = subsamp['group_num'].values","d2834956":"edge_means = [-1, 1, 3.5, 1.5]\nside_names = ['left', 'right', 'up', 'down']\nngroups = 4\n\nwith pm.Model() as model:\n\n    edges = pm.Normal('edges', mu=np.tile(edge_means, (ngroups,1)).T, sd=0.2, shape=(4, ngroups))\n    coefs = pm.TruncatedNormal('coefs', mu=10, sd=2, lower=1, shape=(4, ngroups))\n    parabs = pm.Normal('parabs', mu=1, sd=1, shape=(4, ngroups))\n    lefty_adj = pm.Normal('lefty_adj', mu=0, sd=0.1, shape=ngroups)\n\n    \n    def calc_strike_proba(data, gn):\n        mid_x = (edges[0][gn] + edges[1][gn])\/2\n        mid_y = (edges[2][gn] + edges[3][gn])\/2\n        xdata = data[:,0] + data[:,2]*lefty_adj[gn]\n        \n        left_logodds = (xdata - edges[0][gn])*coefs[0][gn] + ((data[:,1] - mid_y)**2)*parabs[0][gn]\n        right_logodds = - (xdata - edges[1][gn])*coefs[1][gn] - ((data[:,1] - mid_y)**2)*parabs[1][gn]\n        up_logodds = - (data[:, 1] - edges[2][gn])*coefs[2][gn] - ((xdata - mid_x)**2)*parabs[2][gn]\n        down_logodds = (data[:, 1] - edges[3][gn])*coefs[3][gn] + ((xdata - mid_x)**2)*parabs[3][gn]\n\n        logodds = [left_logodds, right_logodds, up_logodds, down_logodds]\n        odds = [np.exp(lo) for lo in logodds]\n        probs = [o\/(o+1) for o in odds]\n        out_proba = probs[0]*probs[1]*probs[2]*probs[3]\n        return out_proba\n    \n    strike_proba = []\n    for i in range(ngroups):\n        Xg = subsamp.loc[subsamp.group_num==i, ['px', 'pz', 'lefty', 'k']].values\n        pitch_preds = calc_strike_proba(Xg, i)\n        strike_proba.append(pm.Bernoulli('strike_proba_group_' + str(i), p=pitch_preds, observed=Xg[:,3]))\n    #pitch_preds = calc_strike_proba(X, group_nums)\n    #strike_proba = pm.Bernoulli('strike_proba', p=pitch_preds, observed=X[:,3])\n    \n    res=0.05\n    xx, yy = np.meshgrid(np.arange(-1.5, 1.5, res),\n                         np.arange(1, 4.5, res))\n    grid_preds_func = lambda x: calc_strike_proba(np.c_[xx.ravel(), yy.ravel(), xx.ravel()*0], (xx.ravel()*0 + x).astype(int))*(res**2)*144\n    zone_preds = [grid_preds_func(i) for i in range(ngroups)]\n    zonegray_by_group = [(4*ele*(1 - ele)).sum() for ele in zone_preds]\n    zonesize_by_group = [ele.sum() for ele in zone_preds]\n    #print(grid_preds([0,1])[0])\n    #zone_size = pm.Deterministic('size_of_zone', tt.as_tensor_variable(grid_preds([0, 1])))\n    zone_sizes = []\n    zone_grays = []\n    group_names = ['other_before', 'other_after', 'ejteam_before', 'ejteam_after']\n    for i in range(ngroups):\n        zone_sizes.append(pm.Deterministic('size_' + group_names[i], zonesize_by_group[i]))\n        zone_grays.append(pm.Deterministic('gray_' + group_names[i], zonegray_by_group[i]))\n        \n    comparisons = [pm.Deterministic('comp_size_before', zonesize_by_group[2] - zonesize_by_group[0]),\n                   pm.Deterministic('comp_size_after', zonesize_by_group[3] - zonesize_by_group[1]),\n                   pm.Deterministic('comp_size_ejteam', zonesize_by_group[3] - zonesize_by_group[2]),\n                   pm.Deterministic('comp_size_other', zonesize_by_group[1] - zonesize_by_group[0])]\n    \n    #incon_actual = pm.Deterministic('incon_actual', \n    #                                ((1 - pitch_preds)**X[:,3]) * \n    #                                        (pitch_preds**(1-X[:,3])))\n    #incon_expected = pm.Deterministic('incon_expected', \n    #                                  ((1 - pitch_preds)**pitch_preds) * \n    #                                          (pitch_preds**(1-pitch_preds)))\n    \n    #incon_score = pm.Deterministic('incon_score', incon_actual - incon_expected)\n    \n    trace = pm.sample(1000, init='advi')","0bef40a9":"pm.plot_posterior(trace, ['comp_size_before', 'comp_size_after', 'comp_size_ejteam', 'comp_size_other']);","6099b4eb":"pm.plot_posterior(trace, ['size_other_before', 'size_other_after', 'size_ejteam_before', 'size_ejteam_after']);","aecf1e82":"pm.plot_posterior(trace, ['gray_other_before', 'gray_other_after', 'gray_ejteam_before', 'gray_ejteam_after']);","02f37839":"## Now that the model's been sampled, we can just plot the posteriors and see the best-fit parameters, with built-in error bars\n\nAnd this isn't just for the specific parameters of the model: notice that we told the model how to calculate the size of the strike zone given those parameters. PyMC3 automatically finds the posterior of this variable as well.","fbed157a":"# Bayesian inference for strike zone analysis\n\nThe logistic regression model used in [this notebook](https:\/\/www.kaggle.com\/pschale\/player-ejections-and-strike-zone-size?scriptVersionId=13002959) was trained using a simple scipy.minimize function. But this can't deal with smaller datasets well, and doesn't come with built-in error analysis. In this notebook, I'll fit that model with Bayesian statistics, and end by quantify the difference between a left-handed hitter's strike zone and a righty's. It may surprise most non-baseballs fans to learn that the strike zone isn't called the same way, but it's true: it's like the plate moves an inch and a half when a lefty comes up.\n\nFirst we import the data, try to cut out clear outliers, and grab 10,000 random pitches.","86734400":"Finally, we can use this Bayesian framework to verify the trend found [using the simpler optimize method](https:\/\/www.kaggle.com\/pschale\/player-ejections-and-strike-zone-size?scriptVersionId=13002959): that the strike zone changes after ejections.","32227f69":"So even though our prior on lefty_adjustment_(x) was a mean of 0 and standard deviation of 0.1, we can see a clear preference for a value of about 0.1 (in feet, so a bit over an inch). I've plotted all of the posteriors below","13237037":"# Building the model\n\nThis model is essentially the same one as in the prior notebook, but we must define it using PyMC3. Once it's defined, PyMC3 does everything by just calling .sample().\n\nOne complication with Bayesian statistics is that it requires priors. Here I've used fairly generous priors; with 10,000 data points those priors aren't extremely important. But if we tried to run on a single game, for example, the choice of priors would have a large impact on the output results."}}