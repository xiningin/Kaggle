{"cell_type":{"a967e044":"code","2de7d370":"code","4d9ac799":"code","c4d4b193":"code","3bc122e5":"code","62a6366a":"code","ec665799":"code","5b7a9c66":"code","9efda5fc":"code","6dddf9d4":"code","4222e7a6":"code","cb03e292":"code","c2dd95b4":"code","4e1f28d1":"code","fd22a15d":"code","46382442":"code","8f8df8b4":"code","84c3afbd":"code","de4832c7":"code","140f08a3":"code","03b6cfe1":"code","76d15b4d":"code","95d0b3ec":"code","3f6ade9f":"code","9c712664":"code","0799978a":"code","3c142f38":"code","8de85896":"code","700fb791":"code","eddf3320":"code","a1f449d8":"code","59bef5ae":"code","0986322c":"markdown","3cdd05bc":"markdown","47535a2b":"markdown","5fae4786":"markdown","a3202885":"markdown","bc08f057":"markdown","5ca96e74":"markdown","f837a26d":"markdown","0debcfc0":"markdown","7bb13790":"markdown","344b0829":"markdown","13936f55":"markdown","4b15f233":"markdown","d5287e58":"markdown","36c46f33":"markdown","30971fb2":"markdown","d1d7dbd3":"markdown","062d56dc":"markdown","b12ab5c6":"markdown","178564cc":"markdown","61dece63":"markdown"},"source":{"a967e044":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.tri as mtri\nfrom IPython.display import Image, display, SVG, clear_output, HTML\nplt.rcParams[\"figure.figsize\"] = (6, 6)\nplt.rcParams[\"figure.dpi\"] = 125\nplt.rcParams[\"font.size\"] = 14\nplt.rcParams['font.family'] = ['sans-serif']\nplt.rcParams['font.sans-serif'] = ['DejaVu Sans']\nplt.style.use('ggplot')\nsns.set_style(\"whitegrid\", {'axes.grid': False})\nplt.rcParams['image.cmap'] = 'viridis' # viridis looks better","2de7d370":"import numpy as np\nfrom scipy import signal","4d9ac799":"def compare_signal(raw_signal, **kwargs):\n    fig, ax1 = plt.subplots(1, 1)\n    ax1.plot(raw_signal, 'k-', label='Raw Signal')\n    for i, (sig_name, sig_value) in enumerate(kwargs.items()):\n        ax1.plot(sig_value, '-.', lw=4, alpha=0.5, label=sig_name)\n    ax1.legend()","c4d4b193":"simple_1d = np.arange(0, 1024, 4)\nsimple_1d_wrapped = simple_1d % 255\ncompare_signal(simple_1d, Wrapped=simple_1d_wrapped)","3bc122e5":"compare_signal(simple_1d, Wrapped=simple_1d_wrapped, Unwrapped=np.unwrap(simple_1d_wrapped, discont=127))","62a6366a":"complex_1d = 768*np.sin(np.linspace(0, np.pi, 100))\ncomplex_1d_wrapped = complex_1d % 255\ncompare_signal(complex_1d, Wrapped=complex_1d_wrapped, Unwrapped=np.unwrap(complex_1d_wrapped, discont=127))","ec665799":"np.random.seed(2019)\nnoisy_1d = complex_1d+np.random.uniform(-50, 50, size=complex_1d.shape)\nnoisy_1d_wrapped = noisy_1d % 255\ncompare_signal(noisy_1d, Wrapped=noisy_1d_wrapped, Unwrapped=np.unwrap(noisy_1d_wrapped, discont=127))","5b7a9c66":"xx, yy = np.meshgrid(np.linspace(0, 1, 100), np.linspace(0, 1, 100))\ndef compare_2d(raw_image, **kwargs):\n    fig, m_axs = plt.subplots(1, 2+len(kwargs), figsize=(8*(2+len(kwargs)), 8))\n    r_img_ax = m_axs[0].imshow(raw_image)\n    m_axs[0].set_title('Raw Image')\n    m_axs[0].axis('off')\n    clim = r_img_ax.get_clim()\n    for c_ax, (sig_name, sig_value) in zip(m_axs[1:], kwargs.items()):\n        c_ax.imshow(sig_value, vmin=clim[0], vmax=clim[1])\n        c_ax.set_title(sig_name.replace('_', ' '))\n    m_axs[-1].axis('off')\n    plt.colorbar(r_img_ax)","9efda5fc":"simple_2d = 512*xx*yy\nsimple_2d_wrapped = simple_2d % 255\ncompare_2d(simple_2d, Wrapped=simple_2d_wrapped, Unwrapped=np.unwrap(simple_2d_wrapped, discont=127))","6dddf9d4":"complex_2d = 768*(1-4*np.abs(0.5-xx)*np.abs(0.5-yy))\ncomplex_2d_wrapped = complex_2d % 255\ncompare_2d(complex_2d, Wrapped=complex_2d_wrapped, Unwrapped=np.unwrap(complex_2d_wrapped, discont=127))","4222e7a6":"Unwrapped_X=np.unwrap(complex_2d_wrapped, discont=127, axis=0)\nUnwrapped_Y=np.unwrap(complex_2d_wrapped, discont=127, axis=1)\ncompare_2d(complex_2d, \n           Unwrapped_X=Unwrapped_X,\n          Unwrapped_Y=Unwrapped_Y)","cb03e292":"compare_2d(complex_2d, \n           Unwrapped_X=Unwrapped_X,\n          Unwrapped_Y=Unwrapped_Y,\n          Unwrapped_Avg = 0.5*Unwrapped_X+0.5*Unwrapped_Y)","c2dd95b4":"Offset_X = Unwrapped_X-complex_2d_wrapped\nOffset_Y = Unwrapped_Y-complex_2d_wrapped\nOffset_Max = np.max(np.stack([Offset_X, Offset_Y],0), axis=0)\ncompare_2d(complex_2d, \n           Offset_X=Offset_X,\n           Offset_Y=Offset_Y,\n          Offset_Max=Offset_Max,\n          Unwrapped_Max=Offset_Max+complex_2d_wrapped)","4e1f28d1":"import doctest\nimport copy\nimport functools\nfrom itertools import cycle\ndef autotest(func):\n    globs = copy.copy(globals())\n    globs.update({func.__name__: func})\n    doctest.run_docstring_examples(\n        func, globs, verbose=True, name=func.__name__)\n    return func\n@autotest\ndef unwrap(p, discont=127, axis=0, njumps_up=None, njumps_down=None):\n    \"\"\"A more generic unwrap function\n    Parameters\n    ----------\n    p : array_like\n        Input array.\n    discont : float, optional\n        Maximum discontinuity between values, default is ``127``.\n    axis : int, optional\n        Axis along which unwrap will operate, default is the last axis.\n    njumps : int, optional\n        Maximum number of discrepencies to correct\n\n    >>> unwrap([0, 1, 2, 0], discont=1.5)\n    array([0., 1., 2., 3.])\n    >>> unwrap([2, 1, 0, 2], discont=1.5)\n    array([ 2.,  1.,  0., -1.])\n    >>> unwrap([0, 1, 2, 0, 1, 2, 0], discont=1.5)\n    array([0., 1., 2., 3., 4., 5., 6.])\n    >>> unwrap([0, 1, 2, 0, 1, 2, 0], discont=1.5, njumps_up=1)\n    array([0., 1., 2., 3., 4., 5., 3.])\n    >>> unwrap([2, 1, 0, 2], discont=1.5, njumps_down=0)\n    array([2., 1., 0., 2.])\n    \"\"\"\n    p = np.asarray(p)\n    out = np.array(p, copy=True, dtype='d')\n    # find the jumps\n    dd = np.diff(p, axis=axis)\n    ph_correct = np.zeros_like(dd)\n    # undo the points that are too extreme\n    \n    if (njumps_up is not None) or (njumps_down is not None):\n        ph_update = np.zeros(dd.shape)\n        for i, idx in enumerate(zip(*np.where(dd<-discont))):\n            if (njumps_up is not None) and (i>=njumps_up):\n                break\n            ph_update[idx] = 2*discont\n        \n        for i, idx in enumerate(zip(*np.where(dd>discont))):\n            if (njumps_down is not None) and (i>=njumps_down):\n                break\n            ph_update[idx] = -2*discont\n            \n    else:\n        dd[np.abs(dd)<discont] = 0\n        ph_update = dd.copy()\n        ph_update[dd>0] = -2*discont\n        ph_update[dd<0] = 2*discont\n    \n    # update the right part of the array\n    slice1 = [slice(None, None)]*p.ndim     # full slices\n    slice1[axis] = slice(1, None)\n    out[tuple(slice1)] = p[tuple(slice1)] + ph_update.cumsum(axis)\n    return out","fd22a15d":"Unwrapped_X=unwrap(complex_2d_wrapped, discont=127, axis=0)\nUnwrapped_Y=unwrap(complex_2d_wrapped, discont=127, axis=1)\nOffset_Max = np.max(np.stack([Unwrapped_X-complex_2d_wrapped, Unwrapped_Y-complex_2d_wrapped],0), axis=0)\ncompare_2d(complex_2d, \n           Unwrapped_X=Unwrapped_X,\n          Unwrapped_Y=Unwrapped_Y,\n          Unwrapped_Max=Offset_Max+complex_2d_wrapped)","46382442":"from tqdm import tqdm\ndef iterative_max_unwrap(in_img, iterations=1000):\n    cur_image = in_img\n    for i in tqdm(range(iterations)):\n        Unwrapped_X=unwrap(cur_image, discont=127, axis=0, njumps_up=1)\n        Unwrapped_Y=unwrap(cur_image, discont=127, axis=1, njumps_up=1)\n        Offset_X = Unwrapped_X-cur_image\n        Offset_Y = Unwrapped_Y-cur_image\n        combo_offset = np.stack([Offset_X, Offset_Y], 0)\n        Offset_Max = np.max(combo_offset, axis=0)\n        Unwrapped_Max = Offset_Max+cur_image\n        if np.allclose(cur_image, Unwrapped_Max, atol=0.25):\n            break\n        else:\n            cur_image = Unwrapped_Max\n    return cur_image","8f8df8b4":"compare_2d(complex_2d, \n               Wrapped=complex_2d_wrapped,\n               Unwrapped_Iterative_Max=iterative_max_unwrap(complex_2d_wrapped))","84c3afbd":"complexer_2d = 350*(1+np.sin(3*np.pi*xx+0.1)*np.cos(2*np.pi*yy))\ncomplexer_2d_wrapped = complexer_2d % 255\ncompare_2d(complexer_2d,\n           Wrapped=complexer_2d_wrapped, \n           Unwrapped=np.unwrap(complexer_2d_wrapped, discont=127),\n          Unwrapped_Iterative_Max=iterative_max_unwrap(complexer_2d_wrapped, 5000)\n          )","de4832c7":"def fixwrap(in_img, discont, axis=0):\n    slice1 = [slice(None, None)]*in_img.ndim # full slices\n    slice1[axis] = slice(0, 1)\n    slice1 = tuple(slice1)\n    diff_img = np.diff(in_img, n=1, axis=axis, prepend=in_img[slice1])\n    diff_img[np.abs(diff_img)>discont] = 0\n    diff_img[slice1] = in_img[slice1]\n    return diff_img.cumsum(axis)","140f08a3":"from numba import jit\n@jit(nopython=True)\ndef conv_cumsum(border_img, dx_img, dy_img, scale_factor=8.0):\n    out = np.zeros_like(border_img)\n    out[:, 0] = border_img[:, 0]\n    out[0, :] = border_img[0, :]\n    w_bx = np.abs(dx_img[1:, :]).mean()\n    w_by = np.abs(dy_img[:, 1:]).mean()\n    for i in range(1, out.shape[0]):\n        for j in range(1, out.shape[1]):\n            pred_x = out[i-1, j]+dx_img[i,j]\n            pred_y = out[i, j-1]+dy_img[i,j]\n            pred_xy = out[i-1, j-1]+dx_img[i,j]+dy_img[i,j]\n            w_x = np.abs(dx_img[i,j])\/w_bx\n            w_y = np.abs(dy_img[i,j])\/w_by\n            out[i,j] = (scale_factor*w_x*pred_x+scale_factor*w_y*pred_y+pred_xy)\/(1+scale_factor*w_x+scale_factor*w_y)\n    return out","03b6cfe1":"def fixwrap_2d(in_img, discont, scale_factor=8):\n    diff_img_list = []\n    for axis in range(2):\n        slice1 = [slice(None, None)]*in_img.ndim\n        slice1[axis] = slice(0, 1)\n        slice1 = tuple(slice1)\n        diff_img = np.diff(in_img, n=1, axis=axis, prepend=in_img[slice1])\n        diff_img[np.abs(diff_img)>discont] = 0\n        diff_img[slice1] = 0\n        diff_img_list.append(diff_img)\n    return conv_cumsum(in_img, diff_img_list[0], diff_img_list[1], scale_factor=scale_factor)","76d15b4d":"compare_2d(complex_2d,\n           Wrapped=complex_2d_wrapped, \n          Fix_Wrap_Function=fixwrap(complex_2d_wrapped, 127, axis=1),\n        Fix_Wrap_2D=fixwrap_2d(complex_2d_wrapped, 127, 4)\n          )","95d0b3ec":"param_sweep = {f\"Fix_Wrap_2D_{a:2.2f}\":fixwrap_2d(complex_2d_wrapped, 127, a) for a in np.logspace(-1.5, 3, 8)}\ncompare_2d(complex_2d,**param_sweep)","3f6ade9f":"compare_2d(complexer_2d,\n           Wrapped=complexer_2d_wrapped, \n          Fix_Wrap_Function=fixwrap(complexer_2d_wrapped, 127, axis=1),\n        Fix_Wrap_2D=fixwrap_2d(complexer_2d_wrapped, 127, 4)\n          )","9c712664":"np.random.seed(2019)\nnoisy_2d = complex_2d+np.random.uniform(-30, 30, size=complex_2d.shape)\nnoisy_2d_wrapped = noisy_2d % 255\ncompare_2d(noisy_2d,\n           Wrapped=noisy_2d_wrapped, \n          Fix_Wrap_Function=fixwrap(noisy_2d_wrapped, 127, axis=1),\n        Fix_Wrap_2D=fixwrap_2d(noisy_2d_wrapped, 127)\n          )","0799978a":"def _xy_cumsum(in_img, discont, verbose=False):\n    diff_img_list = []\n    for axis in range(2):\n        slice1 = [slice(None, None)]*in_img.ndim\n        slice1[axis] = slice(0, 1)\n        slice1 = tuple(slice1)\n        diff_img = np.diff(in_img, n=1, axis=axis, prepend=in_img[slice1])\n        diff_img[np.abs(diff_img)>discont] = 0\n        diff_img_list.append(diff_img.cumsum(axis))\n    if verbose:\n        fig, (ax1, ax2) = plt.subplots(1, 2)\n        ax1.imshow(diff_img_list[0])\n        ax2.imshow(diff_img_list[1])\n    return diff_img_list\n\ndef wrap_avg(in_img, discont, verbose=False):\n    int_img_list = _xy_cumsum(in_img, discont, verbose=verbose)\n    int_img_list += [c_img[::-1, ::-1] for c_img in _xy_cumsum(in_img[::-1, ::-1], discont, verbose=verbose)]\n    int_img_list.append(in_img)\n    return np.median(int_img_list, 0)","3c142f38":"compare_2d(complexer_2d,\n           Wrapped=complexer_2d_wrapped, \n        Fix_Wrap_2D=wrap_avg(complexer_2d_wrapped, 64, True)\n          )","8de85896":"from skimage.transform import radon, iradon\ntheta=np.linspace(0, 180, 360)\nrad_data = radon(complexer_2d_wrapped, theta=theta, preserve_range=False)\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(21, 7))\nax1.imshow(rad_data)\ndrad_data = np.diff(rad_data,axis=1)\nprint(drad_data.shape)\ndrad_data[np.abs(drad_data)>1500] = 0\nax2.imshow(drad_data)\nrad_data[:, 1:] = drad_data.cumsum(1)\nax3.imshow(iradon(rad_data, theta=theta))","700fb791":"from skimage.transform import rotate\nfrom scipy.ndimage import zoom\ndef rot_clean_irot(raw_img, angle, discont):\n    rot_args = {'preserve_range': True, 'order': 0, 'mode': 'edge', 'clip': False}\n    in_img = rotate(raw_img, angle=angle, **rot_args)\n    slice1 = [slice(None, None)]*in_img.ndim\n    slice1[0] = slice(0, 1)\n    slice1 = tuple(slice1)\n    diff_img = np.diff(in_img, n=1, axis=0, prepend=in_img[slice1])\n    diff_img[np.abs(diff_img)>discont] = 0\n    diff_img[slice1] = in_img[slice1]\n    return rotate(diff_img.cumsum(0), angle=-angle, **rot_args)\n\ndef multi_angle(in_img, discont, steps=10):\n    return np.max([rot_clean_irot(in_img, discont=discont, angle=angle) \n             for angle in np.linspace(0, 270, steps)], \n            axis=0)\ncompare_2d(complexer_2d,\n           Wrapped=complexer_2d_wrapped, \n        Rotate_Clean=rot_clean_irot(complexer_2d_wrapped, angle=15, discont=127),\n           Multi_Clean=multi_angle(complexer_2d_wrapped, discont=127, steps=256)\n          )","eddf3320":"compare_2d(noisy_2d,\n           Wrapped=noisy_2d_wrapped, \n          Fix_Wrap_Function=fixwrap(noisy_2d_wrapped, 127, axis=1),\n        Fix_Wrap_2D=fixwrap_2d(noisy_2d_wrapped, 127),\n           Multi_Clean=multi_angle(noisy_2d_wrapped, discont=127, steps=128)\n          )","a1f449d8":"fig, ((ax1, ax2, ax2i), (ax3, ax4, ax5), (ax6, ax7, ax8)) = plt.subplots(3, 3, figsize=(15, 15))\nax1.imshow(complexer_2d_wrapped, cmap='viridis')\nax1.set_title('Raw Signal')\ndiff_x = np.diff(complexer_2d_wrapped, axis=1)\nax2.imshow(diff_x, cmap='RdBu')\nax2.set_title('Numerical Derivative')\n# remove extremes and reintegrate\ndiff_x[np.abs(diff_x)>127] = 0\n\nax2i.imshow(np.cumsum(diff_x, axis=1))\nax2i.set_title('Integrated')\n\ndiff_fft_image = np.fft.fft2(complexer_2d_wrapped)\nax3.imshow(np.log(np.abs(np.fft.fftshift(diff_fft_image))), cmap='viridis')\nax3.set_title('FFT2')\n_xx, _yy = np.meshgrid(np.linspace(-1, 1, diff_fft_image.shape[0]), \n                     np.linspace(-1, 1, diff_fft_image.shape[1]), \n                     indexing='ij')\nrr = np.fft.fftshift(np.sqrt(np.square(_xx)+np.square(_yy)))\ncropped_fft_image = (rr<0.9)*diff_fft_image\ndiff_fft_image = cropped_fft_image*(1j*np.clip(np.fft.fftshift(_xx), 1e-3, 10))\nax4.set_title('Filtered, Differentiated Spectra')\nax4.imshow(np.log(np.abs(np.fft.fftshift(diff_fft_image))), cmap='viridis')\nint_fft_image = diff_fft_image\/(1j*np.clip(np.fft.fftshift(_xx), 1e-3, 10))\nint_image = np.fft.ifft2(int_fft_image)\nax5.imshow(np.abs(int_image), cmap='viridis')\nax5.set_title('Integrated')\n\n\nax7.imshow(np.log(np.abs(np.fft.fftshift(int_fft_image))), cmap='viridis')\nax7.set_title('Filtered Spectra')","59bef5ae":"conv_cumsum.inspect_types()","0986322c":"## More Complex Signals","3cdd05bc":"### Even more complexity?","47535a2b":"### Noisy Images","5fae4786":"## Just Look at Offsets","a3202885":"## X vs Y unwrapping","bc08f057":"## Iterative Single Jump Unwrapping\nHere we unwrap the image by doing single jumps up in X and Y and keep going until the image stops changing","5ca96e74":"# Optional\nLets look at the generated assembly from numba","f837a26d":"# Hacky Functions\nWe can try to make hacky functions to add offsets to regions, but that is also not so trivial","0debcfc0":"# Numpy Unwrap\nWe can use the unwrap function in numpy as a first approach for dealing with the problem","7bb13790":"# 2D Signals\nWith 2D signals everything gets more complicated","344b0829":"### Different Scalar Factors","13936f55":"# Fourier Methods\nWe can integrate and differentiate quite easily in fourier space\n$$\\widehat{f'\\;}(\\xi)=2\\pi i\\xi\\hat{f}(\\xi).$$\nso we can apply these approaches to reconstructing the signals without the large jumps\n","4b15f233":"# Radon-Transform\nThis seems like it should be useful, but doesn't quite work","d5287e58":"# Overview\n## Wrapping?\nThe core problem that frequently comes up with digital and optical systems is when values increase beyond a certain point $a$ instead of going to $a+\\epsilon$ they go to $b$ (often $=-a$ or 0) + $\\epsilon$. \n- Digital Sytems\n - When using quantized numbers after reaching the maximum value they often wrap around to the minimum\n - for 8-bit unsigned integers in this example\n - $254+1 = 0$\n- Optics\n - This happens with phase where upon reaching a phase shift of $2\\pi$ the value is the same as a phase shift of 0\n - $a = 2\\pi-\\epsilon$\n - $a+\\epsilon \\rightarrow 0$\n\n## 2D?\nUnwrapping is a straightforward enough problem in 1D since it just involves finding jumps and offsetting the curve (see below), but 2D signals are significantly more complicated since the result needs to be consistent in multiple directions. \n# Outline\nWe create some simple enough test sets and try different methods for unwrapping 1D and 2D signals","36c46f33":"# Handmade Rotations \nHere we take another approach\n- rotate image at arbitrary angle\n- calculate the difference along the x-axis\n- remove any outlier values\n- unrotate the image\n- take the maximum value over all angles","30971fb2":"## Improved Unwrap","d1d7dbd3":"## Noise","062d56dc":"#### Ensure it still works as before","b12ab5c6":"### Median over multiple directions","178564cc":"## 1D Simple Example","61dece63":"### More Complexity"}}