{"cell_type":{"728b482d":"code","14c37e4c":"code","461a0b7d":"code","2dfdd2df":"code","25a9e8cb":"code","5d88d652":"code","d6a647a4":"code","1bdff6b3":"code","0b107bae":"code","032202ed":"code","f4c8f172":"code","863ba4f1":"markdown","9bc40597":"markdown","70b1da3a":"markdown","46007b3d":"markdown","29445a9a":"markdown","632dad67":"markdown","a43eabef":"markdown"},"source":{"728b482d":"import os\nimport pandas as pd\nimport numpy as np\nimport pickle \nimport tensorflow as tf \nimport librosa\n\nfrom tensorflow_addons.metrics import F1Score","14c37e4c":"RANDOM_SEED = 1337\nSAMPLE_RATE = 32000\nSIGNAL_LENGTH = 5 # seconds\nSPEC_SHAPE = (48, 128) # height x width\nFMIN = 500\nFMAX = 12500\n","461a0b7d":"test_dir='..\/input\/birdclef-2021\/test_soundscapes'\ntest=pd.read_csv('..\/input\/birdclef-2021\/test.csv')\nsample_sub=pd.read_csv('..\/input\/birdclef-2021\/sample_submission.csv')\n\ntest","2dfdd2df":"sample_sub","25a9e8cb":"#loading presaved pickle\ndef load_pickle(path):\n    with open(path,'rb') as f:\n        file=pickle.load(f)\n        \n    return file\n","5d88d652":"#labels:\n\nLABELS=load_pickle('..\/input\/birdclef2021-model-training\/LABELS.pkl')\n\nf1_score=F1Score(num_classes=len(LABELS),average='macro',name='f1_score')","d6a647a4":"#loading pretrained models:\n\nmodel1=tf.keras.models.load_model('..\/input\/birdclef2021-model-training\/best_model.h5')\nmodel2=tf.keras.models.load_model('..\/input\/birdclef2021-model-training\/best_model2.h5')\n","1bdff6b3":"def list_files(path):\n    '''get test sound files'''\n    return [os.path.join(path, f) for f in os.listdir(path) if f.rsplit('.', 1)[-1] in ['ogg']]\n\ntest_audio=list_files(test_dir)\n\n# test files are hidden,  hence checking on train_soundscapes\nif len(test_audio) == 0:\n    test_audio = list_files('..\/input\/birdclef-2021\/train_soundscapes')\n    \nprint('{} FILES IN TEST SET.'.format(len(test_audio)))","0b107bae":"def predict(threshold):\n    row_id=[]\n    preds=[]\n    \n    for file_path in test_audio[:2]:\n        # Open it with librosa\n        sig, rate = librosa.load(file_path, sr=SAMPLE_RATE)\n\n        sig_splits = []\n        for i in range(0, len(sig), int(SIGNAL_LENGTH * SAMPLE_RATE)):\n            split = sig[i:i + int(SIGNAL_LENGTH * SAMPLE_RATE)]\n\n            # End of signal?\n            if len(split) < int(SIGNAL_LENGTH * SAMPLE_RATE):\n                break\n\n            sig_splits.append(split)\n\n        seconds= 0\n        for chunk in sig_splits:\n\n            # Keep track of the end time of each chunk\n            seconds += 5\n\n            # Get the spectrogram\n            hop_length = int(SIGNAL_LENGTH * SAMPLE_RATE \/ (SPEC_SHAPE[1] - 1))\n            mel_spec = librosa.feature.melspectrogram(y=chunk, \n                                                      sr=SAMPLE_RATE, \n                                                      n_fft=1024, \n                                                      hop_length=hop_length, \n                                                      n_mels=SPEC_SHAPE[0], \n                                                      fmin=FMIN, \n                                                      fmax=FMAX)\n\n            mel_spec = librosa.power_to_db(mel_spec, ref=np.max) \n\n            # Normalize to match the value range we used during training.\n            # That's something you should always double check!\n            mel_spec -= mel_spec.min()\n            mel_spec \/= mel_spec.max()\n\n            # Add channel axis to 2D array\n            mel_spec = np.expand_dims(mel_spec, -1)\n\n            # Add new dimension for batch size\n            mel_spec = np.expand_dims(mel_spec, 0)\n\n            # Predict\n            p = 0.5*model1.predict(mel_spec)[0] + 0.5* model2.predict(mel_spec)[0]\n\n            # Get highest scoring species\n            idx = p.argmax()\n            species = LABELS[idx]\n            score = p[idx]\n\n            # Prepare submission entry\n            row_id.append(file_path.split(os.sep)[-1].rsplit('_', 1)[0] + \n                                  '_' + str(seconds))    \n\n            # Decide if it's a \"nocall\" or a species by applying a threshold\n            if score > threshold:\n                preds.append(species)\n            else:\n                preds.append('nocall')\n                \n    result=pd.DataFrame({'row_id': row_id, 'birds': preds})\n\n    return result","032202ed":"submission=predict(0.6)\n\nsubmission.head()","f4c8f172":"submission.to_csv('submission.csv',index=False)","863ba4f1":"# Imports","9bc40597":"# Test data ","70b1da3a":"# Prediction","46007b3d":"**Test audio data**","29445a9a":"# Loading pretrained models","632dad67":"**Labels from model training**","a43eabef":"# Important Params"}}