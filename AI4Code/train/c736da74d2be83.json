{"cell_type":{"60ed5e7d":"code","ed41151b":"code","d7629f8c":"code","d14a9bef":"code","cc50c703":"code","b1a99437":"code","054140be":"code","2b1c91c5":"code","83b59138":"code","ce703e96":"code","4c34bc38":"code","11813907":"code","3d05787b":"code","f0c88021":"code","69e8d1d4":"code","a69fcbec":"code","08a28998":"code","adab74e0":"code","784bd38f":"code","94b5255f":"code","e5057699":"code","e3719ed6":"code","36a1e903":"code","b3bb69fc":"code","ead4a63f":"code","f8dc630c":"code","487bc880":"markdown","d87d0900":"markdown","18fda4d5":"markdown","fc82fc1a":"markdown","06656b56":"markdown","aab1348d":"markdown","20c97059":"markdown","56548aa6":"markdown","ae0823ee":"markdown","6cbeaded":"markdown","0d07e6a8":"markdown","0a6b83b0":"markdown","2b418e46":"markdown","1c3b3b55":"markdown","69aced60":"markdown","1d61c130":"markdown","09ec5464":"markdown"},"source":{"60ed5e7d":"import os\nimport glob\nfrom joblib import Parallel, delayed\nimport pandas as pd\nimport numpy as np\nimport scipy as sc\nfrom sklearn.model_selection import KFold\nimport lightgbm as lgb\nimport warnings\nwarnings.filterwarnings('ignore')\npd.set_option('max_columns', 300)\nimport pickle\nimport matplotlib.pyplot as plt\nimport seaborn as sns","ed41151b":"import torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.optim.lr_scheduler import ReduceLROnPlateau\nimport torch.nn.functional as F\n\nimport random","d7629f8c":"SEED = 42\n\ndef random_seed(SEED):\n    \n    random.seed(SEED)\n    os.environ['PYTHONHASHSEED'] = str(SEED)\n    np.random.seed(SEED)\n    torch.manual_seed(SEED)\n    \n    if torch.cuda.is_available():\n        torch.cuda.manual_seed(SEED)\n        torch.cuda.manual_seed_all(SEED)\n        torch.backends.cudnn.deterministic = True\n        torch.backends.cudnn.benchmark = False\n\nrandom_seed(SEED)","d14a9bef":"train = pd.read_pickle(\"..\/input\/optiverlgbbase\/train.pkl\")\ntrain","cc50c703":"for col in train.columns.to_list()[4:]:\n    train[col] = train[col].fillna(train[col].mean())","b1a99437":"scales = train.drop(['row_id', 'target', 'time_id',\"stock_id\"], axis = 1).columns.to_list()","054140be":"from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(train[scales])","2b1c91c5":"import pickle\n\nscaler_name = \"scaler\"\n\n# saving model\npickle.dump(scaler, open(scaler_name, 'wb'))","83b59138":"from sklearn.preprocessing import LabelEncoder \nimport pickle","ce703e96":"le=LabelEncoder()\nle.fit(train[\"stock_id\"])\ntrain[\"stock_id\"] = le.transform(train[\"stock_id\"])\n\nwith open( 'stock_id_encoder.txt', 'wb') as f:\n    pickle.dump(le, f)","4c34bc38":"train[\"stock_id\"]","11813907":"from sklearn import datasets\nfrom sklearn import model_selection\n\ndef create_folds(data, num_splits,target):\n    # we create a new column called kfold and fill it with -1\n    data[\"kfold\"] = -1\n    \n    # the next step is to randomize the rows of the data\n    data = data.sample(frac=1).reset_index(drop=True)\n\n    # calculate number of bins by Sturge's rule\n    # I take the floor of the value, you can also\n    # just round it\n    num_bins = int(np.floor(1 + np.log2(len(data))))\n    \n    # bin targets\n    data.loc[:, \"bins\"] = pd.cut(\n        data[target], bins=num_bins, labels=False\n    )\n    \n    # initiate the kfold class from model_selection module\n    kf = model_selection.StratifiedKFold(n_splits=num_splits)\n    \n    # fill the new kfold column\n    # note that, instead of targets, we use bins!\n    for f, (t_, v_) in enumerate(kf.split(X=data, y=data.bins.values)):\n        data.loc[v_, 'kfold'] = f\n    \n    # drop the bins column\n    data = data.drop(\"bins\", axis=1)\n\n    # return dataframe with folds\n    return data\n\ntrain = create_folds(train, 5,\"target\")","3d05787b":"!pip install ..\/input\/pytorchtabnet\/pytorch_tabnet-3.1.1-py3-none-any.whl","f0c88021":"from pytorch_tabnet.pretraining import TabNetPretrainer\nfrom pytorch_tabnet.tab_model import TabNetRegressor\nfrom pytorch_tabnet.metrics import Metric\nimport torch\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.metrics import mean_squared_error\n\nimport pandas as pd\nimport numpy as np\nnp.random.seed(0)\n\n\nimport os\nfrom pathlib import Path","69e8d1d4":"def rmspe(y_true, y_pred):\n    '''\n    Compute Root Mean Square Percentage Error between two arrays.\n    '''\n    \n    if (y_true == 0).any():\n        raise ValueError(\"Root Mean Square Percentage Error cannot be used when \"\n                         \"targets contain zero values.\")\n        \n    loss = np.sqrt(np.mean(np.square(((y_true - y_pred) \/ y_true)), axis=0)).item()\n\n    return loss","a69fcbec":"class RMSPE(Metric):\n    def __init__(self):\n        self._name = \"rmspe\"\n        self._maximize = False\n\n    def __call__(self, y_true, y_score):\n        return rmspe(y_true, y_score)","08a28998":"tabnet_params = dict(\n    n_d = 32,\n    n_a = 32,\n    n_steps = 3,\n    gamma = 1.7,\n    lambda_sparse = 0,\n    optimizer_fn = optim.Adam,\n    optimizer_params = dict(lr = 1e-3, weight_decay = 1e-5),\n    mask_type = \"entmax\",\n    scheduler_params = dict(\n        mode = \"min\", patience = 5, min_lr = 1e-7, factor = 0.9),\n    scheduler_fn = ReduceLROnPlateau,\n    seed = 29,\n    #verbose = 5,\n    cat_dims=[len(le.classes_)], cat_emb_dim=[10], cat_idxs=[-1] # define categorical features\n)","adab74e0":"# tabnet model\n\nclf = TabNetRegressor(**tabnet_params)","784bd38f":"# data directory\ndata_dir = '..\/input\/optiver-realized-volatility-prediction\/'\n\n# Function to calculate first WAP\ndef calc_wap1(df):\n    wap = (df['bid_price1'] * df['ask_size1'] + df['ask_price1'] * df['bid_size1']) \/ (df['bid_size1'] + df['ask_size1'])\n    return wap\n\n# Function to calculate second WAP\ndef calc_wap2(df):\n    wap = (df['bid_price2'] * df['ask_size2'] + df['ask_price2'] * df['bid_size2']) \/ (df['bid_size2'] + df['ask_size2'])\n    return wap\n\n# Function to calculate the log of the return\n# Remember that logb(x \/ y) = logb(x) - logb(y)\ndef log_return(series):\n    return np.log(series).diff()\n\n# Calculate the realized volatility\ndef realized_volatility(series):\n    return np.sqrt(np.sum(series**2))\n\n# Function to count unique elements of a series\ndef count_unique(series):\n    return len(np.unique(series))\n\n# Function to read our base train and test set\ndef read_train_test():\n    train = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/train.csv')\n    test = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/test.csv')\n    # Create a key to merge with book and trade data\n    train['row_id'] = train['stock_id'].astype(str) + '-' + train['time_id'].astype(str)\n    test['row_id'] = test['stock_id'].astype(str) + '-' + test['time_id'].astype(str)\n    print(f'Our training set has {train.shape[0]} rows')\n    return train, test\n\n# Function to preprocess book data (for each stock id)\ndef book_preprocessor(file_path):\n    df = pd.read_parquet(file_path)\n    # Calculate Wap\n    df['wap1'] = calc_wap1(df)\n    df['wap2'] = calc_wap2(df)\n    # Calculate log returns\n    df['log_return1'] = df.groupby(['time_id'])['wap1'].apply(log_return)\n    df['log_return2'] = df.groupby(['time_id'])['wap2'].apply(log_return)\n    # Calculate wap balance\n    df['wap_balance'] = abs(df['wap1'] - df['wap2'])\n    # Calculate spread\n    df['price_spread'] = (df['ask_price1'] - df['bid_price1']) \/ ((df['ask_price1'] + df['bid_price1']) \/ 2)\n    df['bid_spread'] = df['bid_price1'] - df['bid_price2']\n    df['ask_spread'] = df['ask_price1'] - df['ask_price2']\n    df['total_volume'] = (df['ask_size1'] + df['ask_size2']) + (df['bid_size1'] + df['bid_size2'])\n    df['volume_imbalance'] = abs((df['ask_size1'] + df['ask_size2']) - (df['bid_size1'] + df['bid_size2']))\n    \n    # Dict for aggregations\n    create_feature_dict = {\n        'wap1': [np.sum, np.mean, np.std],\n        'wap2': [np.sum, np.mean, np.std],\n        'log_return1': [np.sum, realized_volatility, np.mean, np.std],\n        'log_return2': [np.sum, realized_volatility, np.mean, np.std],\n        'wap_balance': [np.sum, np.mean, np.std],\n        'price_spread':[np.sum, np.mean, np.std],\n        'bid_spread':[np.sum, np.mean, np.std],\n        'ask_spread':[np.sum, np.mean, np.std],\n        'total_volume':[np.sum, np.mean, np.std],\n        'volume_imbalance':[np.sum, np.mean, np.std]\n    }\n    \n    # Function to get group stats for different windows (seconds in bucket)\n    def get_stats_window(seconds_in_bucket, add_suffix = False):\n        # Group by the window\n        df_feature = df[df['seconds_in_bucket'] >= seconds_in_bucket].groupby(['time_id']).agg(create_feature_dict).reset_index()\n        # Rename columns joining suffix\n        df_feature.columns = ['_'.join(col) for col in df_feature.columns]\n        # Add a suffix to differentiate windows\n        if add_suffix:\n            df_feature = df_feature.add_suffix('_' + str(seconds_in_bucket))\n        return df_feature\n    \n    # Get the stats for different windows\n    df_feature = get_stats_window(seconds_in_bucket = 0, add_suffix = False)\n    df_feature_450 = get_stats_window(seconds_in_bucket = 450, add_suffix = True)\n    df_feature_300 = get_stats_window(seconds_in_bucket = 300, add_suffix = True)\n    df_feature_150 = get_stats_window(seconds_in_bucket = 150, add_suffix = True)\n    \n    # Merge all\n    df_feature = df_feature.merge(df_feature_450, how = 'left', left_on = 'time_id_', right_on = 'time_id__450')\n    df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n    df_feature = df_feature.merge(df_feature_150, how = 'left', left_on = 'time_id_', right_on = 'time_id__150')\n    # Drop unnecesary time_ids\n    df_feature.drop(['time_id__450', 'time_id__300', 'time_id__150'], axis = 1, inplace = True)\n    \n    # Create row_id so we can merge\n    stock_id = file_path.split('=')[1]\n    df_feature['row_id'] = df_feature['time_id_'].apply(lambda x: f'{stock_id}-{x}')\n    df_feature.drop(['time_id_'], axis = 1, inplace = True)\n    return df_feature\n\n# Function to preprocess trade data (for each stock id)\ndef trade_preprocessor(file_path):\n    df = pd.read_parquet(file_path)\n    df['log_return'] = df.groupby('time_id')['price'].apply(log_return)\n    \n    # Dict for aggregations\n    create_feature_dict = {\n        'log_return':[realized_volatility],\n        'seconds_in_bucket':[count_unique],\n        'size':[np.sum],\n        'order_count':[np.mean],\n    }\n    \n    # Function to get group stats for different windows (seconds in bucket)\n    def get_stats_window(seconds_in_bucket, add_suffix = False):\n        # Group by the window\n        df_feature = df[df['seconds_in_bucket'] >= seconds_in_bucket].groupby(['time_id']).agg(create_feature_dict).reset_index()\n        # Rename columns joining suffix\n        df_feature.columns = ['_'.join(col) for col in df_feature.columns]\n        # Add a suffix to differentiate windows\n        if add_suffix:\n            df_feature = df_feature.add_suffix('_' + str(seconds_in_bucket))\n        return df_feature\n    \n    # Get the stats for different windows\n    df_feature = get_stats_window(seconds_in_bucket = 0, add_suffix = False)\n    df_feature_450 = get_stats_window(seconds_in_bucket = 450, add_suffix = True)\n    df_feature_300 = get_stats_window(seconds_in_bucket = 300, add_suffix = True)\n    df_feature_150 = get_stats_window(seconds_in_bucket = 150, add_suffix = True)\n\n    # Merge all\n    df_feature = df_feature.merge(df_feature_450, how = 'left', left_on = 'time_id_', right_on = 'time_id__450')\n    df_feature = df_feature.merge(df_feature_300, how = 'left', left_on = 'time_id_', right_on = 'time_id__300')\n    df_feature = df_feature.merge(df_feature_150, how = 'left', left_on = 'time_id_', right_on = 'time_id__150')\n    # Drop unnecesary time_ids\n    df_feature.drop(['time_id__450', 'time_id__300', 'time_id__150'], axis = 1, inplace = True)\n    \n    df_feature = df_feature.add_prefix('trade_')\n    stock_id = file_path.split('=')[1]\n    df_feature['row_id'] = df_feature['trade_time_id_'].apply(lambda x:f'{stock_id}-{x}')\n    df_feature.drop(['trade_time_id_'], axis = 1, inplace = True)\n    return df_feature\n\n# Function to get group stats for the stock_id and time_id\ndef get_time_stock(df):\n    # Get realized volatility columns\n    vol_cols = ['log_return1_realized_volatility', 'log_return2_realized_volatility', 'log_return1_realized_volatility_450', 'log_return2_realized_volatility_450', \n                'log_return1_realized_volatility_300', 'log_return2_realized_volatility_300', 'log_return1_realized_volatility_150', 'log_return2_realized_volatility_150', \n                'trade_log_return_realized_volatility', 'trade_log_return_realized_volatility_450', 'trade_log_return_realized_volatility_300', 'trade_log_return_realized_volatility_150']\n\n    # Group by the stock id\n    df_stock_id = df.groupby(['stock_id'])[vol_cols].agg(['mean', 'std', 'max', 'min', ]).reset_index()\n    # Rename columns joining suffix\n    df_stock_id.columns = ['_'.join(col) for col in df_stock_id.columns]\n    df_stock_id = df_stock_id.add_suffix('_' + 'stock')\n\n    # Group by the stock id\n    df_time_id = df.groupby(['time_id'])[vol_cols].agg(['mean', 'std', 'max', 'min', ]).reset_index()\n    # Rename columns joining suffix\n    df_time_id.columns = ['_'.join(col) for col in df_time_id.columns]\n    df_time_id = df_time_id.add_suffix('_' + 'time')\n    \n    # Merge with original dataframe\n    df = df.merge(df_stock_id, how = 'left', left_on = ['stock_id'], right_on = ['stock_id__stock'])\n    df = df.merge(df_time_id, how = 'left', left_on = ['time_id'], right_on = ['time_id__time'])\n    df.drop(['stock_id__stock', 'time_id__time'], axis = 1, inplace = True)\n    return df\n    \n# Funtion to make preprocessing function in parallel (for each stock id)\ndef preprocessor(list_stock_ids, is_train = True):\n    \n    # Parrallel for loop\n    def for_joblib(stock_id):\n        # Train\n        if is_train:\n            file_path_book = data_dir + \"book_train.parquet\/stock_id=\" + str(stock_id)\n            file_path_trade = data_dir + \"trade_train.parquet\/stock_id=\" + str(stock_id)\n        # Test\n        else:\n            file_path_book = data_dir + \"book_test.parquet\/stock_id=\" + str(stock_id)\n            file_path_trade = data_dir + \"trade_test.parquet\/stock_id=\" + str(stock_id)\n    \n        # Preprocess book and trade data and merge them\n        df_tmp = pd.merge(book_preprocessor(file_path_book), trade_preprocessor(file_path_trade), on = 'row_id', how = 'left')\n        \n        # Return the merge dataframe\n        return df_tmp\n    \n    # Use parallel api to call paralle for loop\n    df = Parallel(n_jobs = -1, verbose = 1)(delayed(for_joblib)(stock_id) for stock_id in list_stock_ids)\n    # Concatenate all the dataframes that return from Parallel\n    df = pd.concat(df, ignore_index = True)\n    return df\n\n# Function to calculate the root mean squared percentage error\ndef rmspe(y_true, y_pred):\n    return np.sqrt(np.mean(np.square((y_true - y_pred) \/ y_true)))\n\n# Function to early stop with root mean squared percentage error\ndef feval_rmspe(y_pred, lgb_train):\n    y_true = lgb_train.get_label()\n    return 'RMSPE', rmspe(y_true, y_pred), False\n\ndef train_and_evaluate(train, test):\n    # Hyperparammeters (just basic)\n    params = {\n      'objective': 'rmse',  \n      'boosting_type': 'gbdt',\n      'num_leaves': 100,\n      'n_jobs': -1,\n      'learning_rate': 0.1,\n      'feature_fraction': 0.8,\n      'bagging_fraction': 0.8,\n      'verbose': -1\n    }\n    \n    # Split features and target\n    x = train.drop(['row_id', 'target', 'time_id'], axis = 1)\n    y = train['target']\n    x_test = test.drop(['row_id', 'time_id'], axis = 1)\n    # Transform stock id to a numeric value\n    x['stock_id'] = x['stock_id'].astype(int)\n    x_test['stock_id'] = x_test['stock_id'].astype(int)\n    \n    # Create out of folds array\n    oof_predictions = np.zeros(x.shape[0])\n    # Create test array to store predictions\n    test_predictions = np.zeros(x_test.shape[0])\n    # Create a KFold object\n    kfold = KFold(n_splits = 15, random_state = 29, shuffle = True)\n    # Iterate through each fold\n    for fold, (trn_ind, val_ind) in enumerate(kfold.split(x)):\n        print(f'Training fold {fold + 1}')\n        x_train, x_val = x.iloc[trn_ind], x.iloc[val_ind]\n        y_train, y_val = y.iloc[trn_ind], y.iloc[val_ind]\n        # Root mean squared percentage error weights\n        train_weights = 1 \/ np.square(y_train)\n        val_weights = 1 \/ np.square(y_val)\n        train_dataset = lgb.Dataset(x_train, y_train, weight = train_weights, categorical_feature = ['stock_id'])\n        val_dataset = lgb.Dataset(x_val, y_val, weight = val_weights, categorical_feature = ['stock_id'])\n        model = lgb.train(params = params, \n                          train_set = train_dataset, \n                          valid_sets = [train_dataset, val_dataset], \n                          num_boost_round = 10000, \n                          early_stopping_rounds = 200, \n                          verbose_eval = 50,\n                          feval = feval_rmspe)\n        # Add predictions to the out of folds array\n        oof_predictions[val_ind] = model.predict(x_val)\n        # Predict the test set\n        test_predictions += model.predict(x_test) \/ 15\n        \n    rmspe_score = rmspe(y, oof_predictions)\n    print(f'Our out of folds RMSPE is {rmspe_score}')\n    # Return test predictions\n    return test_predictions\n","94b5255f":"path = \"..\/input\/optivertabnetmodels\"\n\nfor fold in range(5):\n    !cp -r ..\/input\/optivertabnetmodels\/tabnet_model_test_{str(fold)}\/* .\n    !zip tabnet_model_test_{str(fold)}.zip model_params.json network.pt\n\n","e5057699":"modelpath = [os.path.join(\".\/\",s) for s in os.listdir(\".\/\") if (\"zip\" in s)]\nmodelpath","e3719ed6":"# Read train and test\ntrain2, test = read_train_test()\n\n# Get unique stock ids \n#train_stock_ids = train['stock_id'].unique()\n# Preprocess them using Parallel and our single stock id functions\n#train_ = preprocessor(train_stock_ids, is_train = True)\n#train = train.merge(train_, on = ['row_id'], how = 'left')\n\n# Get unique stock ids \ntest_stock_ids = test['stock_id'].unique()\n# Preprocess them using Parallel and our single stock id functions\ntest_ = preprocessor(test_stock_ids, is_train = False)\ntest = test.merge(test_, on = ['row_id'], how = 'left')\n\n# Get group stats of time_id and stock_id\n#train = get_time_stock(train)\ntest = get_time_stock(test)\n\n#train.to_pickle(\"train.pkl\")\n\n# Traing and evaluate\n#test_predictions = train_and_evaluate(train, test)\n\n\n## fillna for test data ##\n\ntrain=train.drop(\"kfold\",axis=1)\n        \nfor col in train.columns.to_list()[4:]:\n    test[col] = test[col].fillna(train[col].mean())\n\n\n### normarize ###    \n\nx_test = test.drop(['row_id', 'time_id',\"stock_id\"], axis = 1).values\n    # Transform stock id to a numeric value\n\nx_test = scaler.transform(x_test)\nX_testdf = pd.DataFrame(x_test)\n\nX_testdf[\"stock_id\"]=test[\"stock_id\"]\n\n# Label encoding\nX_testdf[\"stock_id\"] = le.transform(X_testdf[\"stock_id\"])\n\n\n\n\nx_test = X_testdf.values\n    \n    \npreds=[]\nfor path in modelpath:\n    \n    clf.load_model(path)\n    preds.append(clf.predict(x_test).squeeze(-1))\n    \npreds = np.mean(preds,axis=0)\n\n\n#test['target'] = preds\n#test[['row_id', 'target']].to_csv('submission.csv',index = False)\n","36a1e903":"path2 = \"..\/input\/optiverlgbbase\"\n\n\ntarget_models2 = [pickle.load(open(os.path.join(path2,s), 'rb')) for s in os.listdir(path2) if (\".bin\" in s)]","b3bb69fc":"# Read train and test\ntrain, test = read_train_test()\n\n# Get unique stock ids \n#train_stock_ids = train['stock_id'].unique()\n# Preprocess them using Parallel and our single stock id functions\n#train_ = preprocessor(train_stock_ids, is_train = True)\n#train = train.merge(train_, on = ['row_id'], how = 'left')\n\n# Get unique stock ids \ntest_stock_ids = test['stock_id'].unique()\n# Preprocess them using Parallel and our single stock id functions\ntest_ = preprocessor(test_stock_ids, is_train = False)\ntest = test.merge(test_, on = ['row_id'], how = 'left')\n\n# Get group stats of time_id and stock_id\n#train = get_time_stock(train)\ntest = get_time_stock(test)\n\n#train.to_pickle(\"train.pkl\")\n\n# Traing and evaluate\n#test_predictions = train_and_evaluate(train, test)\n# Save test predictions\n#################            \n        ### model A #####\n        #################\n\n\nx_test = test.drop(['row_id', 'time_id'], axis = 1)\n    # Transform stock id to a numeric value\nx_test['stock_id'] = x_test['stock_id'].astype(int)\n\npreds2=[]\nfor model in target_models2:\n    preds2.append(model.predict(x_test))\npreds2 = np.mean(preds2,axis=0)\n\n","ead4a63f":"# finpreds = np.mean([preds,preds2],axis=0)\nfinpreds = preds*0.375 + preds2*0.625\n\ntest['target'] = finpreds\ntest[['row_id', 'target']].to_csv('submission.csv',index = False)","f8dc630c":"test[['row_id', 'target']]","487bc880":"## 0.4 : Label Encoder \nmaybe stock id shoud be sequencial value when using categorical features.","d87d0900":"## 0.2 Fillna","18fda4d5":"# 0. Preparation","fc82fc1a":"\n### If this notebook helpful for you, I would be glad if you **upvote** !\n#### \u203b Thank you for those who upvoted my EDA and other notebooks.\n\nmy EDA : https:\/\/www.kaggle.com\/chumajin\/optiver-realized-eda-for-starter-english-version\n","06656b56":"## **Thanks for** :https:\/\/www.kaggle.com\/chumajin\/optiver-realized-ensamble-tabnet-and-lgbm","aab1348d":"# About this notebook\n\n## \u30fb This is an ensambled result of my TabNet models and the already public LGBM models.\n## \u30fb My TabNet training notebook is at the following site.\n\n### https:\/\/www.kaggle.com\/chumajin\/optiver-realized-tabnet-baseline\n\n## \u30fb In this version, the already public LGBM models are as follows. \n\nhttps:\/\/www.kaggle.com\/felipefonte99\/optiver-lgb-with-optimized-params Thank you for Felipe Loque. please upvote his work.\n\n\n## This is work in progress, I may change the ensemble models and other parameters depending on the situation.\n","20c97059":"tabnet model load is written on this discussion\nhttps:\/\/www.kaggle.com\/c\/lish-moa\/discussion\/196625","56548aa6":"# 2.2 LGBM","ae0823ee":"## 0.5 Kfold\nreffered by https:\/\/www.kaggle.com\/abhishek\/step-1-create-folds \n\n\nthis is just I like it.","6cbeaded":"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n## Other reference\n\nThe features used are the same as the LGBM notebook below. Thank you for ragnar and A.sato. please upvote his work.\n\nhttps:\/\/www.kaggle.com\/ragnar123\/optiver-realized-volatility-lgbm-baseline\n\nhttps:\/\/www.kaggle.com\/tommy1028\/lightgbm-starter-with-feature-engineering-idea\n\nI respect them. please upvote their great work.\n\n---------------------------------------------------------","0d07e6a8":"# 1. TabNet","0a6b83b0":"# This is work in progress. I hope it is helpful for you. Thank you !","2b418e46":"This metric is from https:\/\/www.kaggle.com\/atamazian\/optiver-tabnet-training\nThank you and please upvote his work.","1c3b3b55":"# 2.3 Merge","69aced60":"## 0.1 Load train data : \n\nI just folk, save and making dataset from public notebooks. This is origined by\n* https:\/\/www.kaggle.com\/ragnar123\/optiver-realized-volatility-lgbm-baseline \n* https:\/\/www.kaggle.com\/tommy1028\/lightgbm-starter-with-feature-engineering-idea\n \nThank you very much.\n\nIf you want to see feature engineering, please refer his work (this is very clean code.)","1d61c130":"# 2. Inference\n# 2.1 TabNet","09ec5464":"## 0.3 Making Standardscaler for Normalization"}}