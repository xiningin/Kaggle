{"cell_type":{"c3db07f0":"code","97d58061":"code","fb978e90":"code","a52c8527":"code","5e8fb3d3":"code","30d09059":"code","0fdb038e":"code","4874dcc5":"code","53e4cb43":"code","841137d1":"code","12b3ef02":"code","9ee868a9":"code","b27c3f70":"code","ca5a9aa0":"code","3c91a1ae":"code","4771617a":"code","cf9302b7":"code","490d175e":"code","52b3dd72":"code","dc5b897f":"code","7f05e47e":"code","d5a09ea9":"code","d521cb93":"code","acb0631f":"markdown"},"source":{"c3db07f0":"!pip install --no-warn-conflicts -q tensorflow-addons","97d58061":"from tensorflow.keras.layers import (Dropout, BatchNormalization, Flatten, Convolution1D, Activation, Input, Dense, LSTM, Lambda, Bidirectional,\n                                     Add, AveragePooling1D, Multiply, GRU, GRUCell, LSTMCell, SimpleRNNCell, SimpleRNN, TimeDistributed, RNN,\n                                     RepeatVector, Conv1D, MaxPooling1D, Concatenate, GlobalAveragePooling1D, UpSampling1D)\nfrom tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, Callback, ReduceLROnPlateau, LearningRateScheduler\nfrom tensorflow.keras.losses import binary_crossentropy, categorical_crossentropy, mean_squared_error\nfrom tensorflow.keras.optimizers import Adam, RMSprop, SGD\nfrom tensorflow.keras.utils import Sequence, to_categorical\nfrom tensorflow.keras import losses, models, optimizers\nfrom tensorflow.keras import backend as K\nimport tensorflow as tf\nfrom typing import List, NoReturn, Union, Tuple, Optional, Text, Generic, Callable, Dict\nfrom sklearn.metrics import f1_score, cohen_kappa_score, mean_squared_error\nfrom logging import getLogger, Formatter, StreamHandler, FileHandler, INFO\nfrom sklearn.model_selection import KFold, GroupKFold\nfrom tqdm import tqdm_notebook as tqdm\nfrom contextlib import contextmanager\nfrom joblib import Parallel, delayed\nfrom IPython.display import display\nfrom sklearn import preprocessing\nimport tensorflow_addons as tfa\nimport scipy.stats as stats\nimport random as rn\nimport pandas as pd\nimport numpy as np\nimport scipy as sp\nimport itertools\nimport warnings\nimport time\nimport pywt\nimport os\nimport gc\n\n\nwarnings.simplefilter('ignore')\nwarnings.filterwarnings('ignore')\npd.set_option('display.max_columns', 1000)\npd.set_option('display.max_rows', 500)\n%matplotlib inline","fb978e90":"EPOCHS=120\nNNBATCHSIZE=16\nBATCHSIZE = 50000\nSEED = 321\nSELECT = True\nSPLITS = 5\nLR = 0.001\nfe_config = [\n    (True, 4000),\n]","a52c8527":"\ndef init_logger():\n    handler = StreamHandler()\n    handler.setLevel(INFO)\n    handler.setFormatter(Formatter(LOGFORMAT))\n    fh_handler = FileHandler('{}.log'.format(MODELNAME))\n    fh_handler.setFormatter(Formatter(LOGFORMAT))\n    logger.setLevel(INFO)\n    logger.addHandler(handler)\n    logger.addHandler(fh_handler)\n    ","5e8fb3d3":"\n@contextmanager\ndef timer(name : Text):\n    t0 = time.time()\n    yield\n    logger.info(f'[{name}] done in {time.time() - t0:.0f} s')\n\nCOMPETITION = 'ION-Switching'\nlogger = getLogger(COMPETITION)\nLOGFORMAT = '%(asctime)s %(levelname)s %(message)s'\nMODELNAME = 'WaveNet'\n","30d09059":"\ndef seed_everything(seed : int) -> NoReturn :\n    \n    rn.seed(seed)\n    np.random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    tf.random.set_seed(seed)\n\nseed_everything(SEED)\n","0fdb038e":"\ndef read_data(base : os.path.abspath) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:\n    \n    train = pd.read_csv('..\/input\/data-without-drift\/train_clean.csv', dtype={'time': np.float32, 'signal': np.float32, 'open_channels':np.int32})\n    test  = pd.read_csv('..\/input\/data-without-drift\/test_clean.csv', dtype={'time': np.float32, 'signal': np.float32})\n    sub  = pd.read_csv(os.path.join(base + '\/sample_submission.csv'), dtype={'time': np.float32})\n    \n    return train, test, sub\n\n\n","4874dcc5":"\ndef batching(df : pd.DataFrame,\n             batch_size : int) -> pd.DataFrame :\n    \n    df['group'] = df.groupby(df.index\/\/batch_size, sort=False)['signal'].agg(['ngroup']).values\n    df['group'] = df['group'].astype(np.uint16)\n        \n    return df\n","53e4cb43":"\ndef reduce_mem_usage(df: pd.DataFrame,\n                     verbose: bool = True) -> pd.DataFrame:\n    \n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2\n\n    for col in df.columns:\n        col_type = df[col].dtypes\n\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n\n            if str(col_type)[:3] == 'int':\n\n                if (c_min > np.iinfo(np.int32).min\n                      and c_max < np.iinfo(np.int32).max):\n                    df[col] = df[col].astype(np.int32)\n                elif (c_min > np.iinfo(np.int64).min\n                      and c_max < np.iinfo(np.int64).max):\n                    df[col] = df[col].astype(np.int64)\n            else:\n                if (c_min > np.finfo(np.float16).min\n                        and c_max < np.finfo(np.float16).max):\n                    df[col] = df[col].astype(np.float16)\n                elif (c_min > np.finfo(np.float32).min\n                      and c_max < np.finfo(np.float32).max):\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    reduction = (start_mem - end_mem) \/ start_mem\n\n    msg = f'Mem. usage decreased to {end_mem:5.2f} MB ({reduction * 100:.1f} % reduction)'\n    if verbose:\n        print(msg)\n\n    return df\n","841137d1":"\ndef lag_with_pct_change(df : pd.DataFrame,\n                        shift_sizes : Optional[List]=[1, 2],\n                        add_pct_change : Optional[bool]=False,\n                        add_pct_change_lag : Optional[bool]=False) -> pd.DataFrame:\n    \n    for shift_size in shift_sizes:    \n        df['signal_shift_pos_'+str(shift_size)] = df.groupby('group')['signal'].shift(shift_size).fillna(0)\n        df['signal_shift_neg_'+str(shift_size)] = df.groupby('group')['signal'].shift(-1*shift_size).fillna(0)\n\n    if add_pct_change:\n        df['pct_change'] = df['signal'].pct_change()\n        if add_pct_change_lag:\n            for shift_size in shift_sizes:    \n                df['pct_change_shift_pos_'+str(shift_size)] = df.groupby('group')['pct_change'].shift(shift_size).fillna(0)\n                df['pct_change_shift_neg_'+str(shift_size)] = df.groupby('group')['pct_change'].shift(-1*shift_size).fillna(0)\n    return df\n","12b3ef02":"\ndef run_feat_enginnering(df : pd.DataFrame,\n                         create_all_data_feats : bool,\n                         batch_size : int) -> pd.DataFrame:\n    \n    df = batching(df, batch_size=batch_size)\n    if create_all_data_feats:\n        df = lag_with_pct_change(df, [1, 2, 3],  add_pct_change=False, add_pct_change_lag=False)\n    \n    return df\n","9ee868a9":"def feature_selection(df : pd.DataFrame,\n                      df_test : pd.DataFrame) -> Tuple[pd.DataFrame , pd.DataFrame, List]:\n    use_cols = [col for col in df.columns if col not in ['index','group', 'open_channels', 'time']]\n    df = df.replace([np.inf, -np.inf], np.nan)\n    df_test = df_test.replace([np.inf, -np.inf], np.nan)\n    for col in use_cols:\n        col_mean = pd.concat([df[col], df_test[col]], axis=0).mean()\n        df[col] = df[col].fillna(col_mean)\n        df_test[col] = df_test[col].fillna(col_mean)\n   \n    gc.collect()\n    return df, df_test, use_cols\n","b27c3f70":"\ndef run_cv_model_by_batch(train : pd.DataFrame,\n                          test : pd.DataFrame,\n                          splits : int,\n                          batch_col : Text,\n                          feats : List,\n                          sample_submission: pd.DataFrame,\n                          nn_epochs : int,\n                          nn_batch_size : int) -> NoReturn:\n    seed_everything(SEED)\n    K.clear_session()\n    config = tf.compat.v1.ConfigProto(intra_op_parallelism_threads=1,inter_op_parallelism_threads=1)\n    sess = tf.compat.v1.Session(graph=tf.compat.v1.get_default_graph(), config=config)\n    tf.compat.v1.keras.backend.set_session(sess)\n    oof_ = np.zeros((len(train), 11))\n    preds_ = np.zeros((len(test), 11))\n    target = ['open_channels']\n    group = train['group']\n    kf = GroupKFold(n_splits=5)\n    splits = [x for x in kf.split(train, train[target], group)]\n\n    new_splits = []\n    for sp in splits:\n        new_split = []\n        new_split.append(np.unique(group[sp[0]]))\n        new_split.append(np.unique(group[sp[1]]))\n        new_split.append(sp[1])    \n        new_splits.append(new_split)\n    tr = pd.concat([pd.get_dummies(train.open_channels), train[['group']]], axis=1)\n\n    tr.columns = ['target_'+str(i) for i in range(11)] + ['group']\n    target_cols = ['target_'+str(i) for i in range(11)]\n    train_tr = np.array(list(tr.groupby('group').apply(lambda x: x[target_cols].values))).astype(np.float32)\n    train = np.array(list(train.groupby('group').apply(lambda x: x[feats].values)))\n    test = np.array(list(test.groupby('group').apply(lambda x: x[feats].values)))\n\n    for n_fold, (tr_idx, val_idx, val_orig_idx) in enumerate(new_splits[0:], start=0):\n        train_x, train_y = train[tr_idx], train_tr[tr_idx]\n        valid_x, valid_y = train[val_idx], train_tr[val_idx]\n\n        gc.collect()\n        shape_ = (None, train_x.shape[2])\n        model = Classifier(shape_)\n        cb_schedule = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=1, verbose=0, mode='auto', min_delta=0.0001, cooldown=0, min_lr=0)\n        cb_Early_Stop=EarlyStopping(monitor='val_loss',patience=10)\n        cb_clr = CyclicLR(base_lr=1e-7, max_lr = 1e-4, step_size= int(1.0*(test.shape[0])\/(nn_batch_size*4)) , mode='exp_range', gamma=1.0, scale_fn=None, scale_mode='cycle')\n        cb_prg = tfa.callbacks.TQDMProgressBar(leave_epoch_progress=False,leave_overall_progress=False, show_epoch_progress=False,show_overall_progress=True)\n        cb_lr_schedule = LearningRateScheduler(lr_schedule)\n        model.fit(train_x,train_y,\n                  epochs=nn_epochs,\n                  callbacks=[cb_prg, cb_lr_schedule, MacroF1(model, valid_x,valid_y)],\n                  batch_size=nn_batch_size,verbose=0,\n                  validation_data=(valid_x,valid_y))\n        preds_f = model.predict(valid_x)\n        f1_score_ = f1_score(np.argmax(valid_y, axis=2).reshape(-1),  np.argmax(preds_f, axis=2).reshape(-1), average = 'macro')\n        logger.info(f'Training fold {n_fold + 1} completed. macro f1 score : {f1_score_ :1.5f}')\n        preds_f = preds_f.reshape(-1, preds_f.shape[-1])\n        oof_[val_orig_idx,:] += preds_f\n        te_preds = model.predict(test)\n        te_preds = te_preds.reshape(-1, te_preds.shape[-1])           \n        preds_ += te_preds \/ SPLITS\n    f1_score_ =f1_score(np.argmax(train_tr, axis=2).reshape(-1),  np.argmax(oof_, axis=1), average = 'macro')\n    logger.info(f'Training completed. oof macro f1 score : {f1_score_:1.5f}')\n    sample_submission['open_channels'] = np.argmax(preds_, axis=1).astype(int)\n    sample_submission.to_csv('submission.csv', index=False, float_format='%.4f')\n    display(sample_submission.head())\n    np.save('oof.npy', oof_)\n    np.save('preds.npy', preds_)\n\n    return \n","ca5a9aa0":"def lr_schedule(epoch):\n    if epoch<30:\n        lr = LR\n    elif epoch<60:\n        lr = LR\/5\n    elif epoch<90:\n        lr = LR\/10\n    else:\n        lr = LR\/100\n    return lr  ","3c91a1ae":"class CyclicLR(tf.keras.callbacks.Callback):\n\n    def __init__(self, base_lr=0.001, max_lr=0.006, step_size=2000., mode='triangular',\n                 gamma=1., scale_fn=None, scale_mode='cycle'):\n        super(CyclicLR, self).__init__()\n\n        self.base_lr = base_lr\n        self.max_lr = max_lr\n        self.step_size = step_size\n        self.mode = mode\n        self.gamma = gamma\n        if scale_fn == None:\n            if self.mode == 'triangular':\n                self.scale_fn = lambda x: 1.\n                self.scale_mode = 'cycle'\n            elif self.mode == 'triangular2':\n                self.scale_fn = lambda x: 1 \/ (2. ** (x - 1))\n                self.scale_mode = 'cycle'\n            elif self.mode == 'exp_range':\n                self.scale_fn = lambda x: gamma ** (x)\n                self.scale_mode = 'iterations'\n        else:\n            self.scale_fn = scale_fn\n            self.scale_mode = scale_mode\n        self.clr_iterations = 0.\n        self.trn_iterations = 0.\n        self.history = {}\n\n        self._reset()\n\n    def _reset(self, new_base_lr=None, new_max_lr=None,\n               new_step_size=None):\n        \"\"\"Resets cycle iterations.\n        Optional boundary\/step size adjustment.\n        \"\"\"\n        if new_base_lr != None:\n            self.base_lr = new_base_lr\n        if new_max_lr != None:\n            self.max_lr = new_max_lr\n        if new_step_size != None:\n            self.step_size = new_step_size\n        self.clr_iterations = 0.\n\n    def clr(self):\n        cycle = np.floor(1 + self.clr_iterations \/ (2 * self.step_size))\n        x = np.abs(self.clr_iterations \/ self.step_size - 2 * cycle + 1)\n        if self.scale_mode == 'cycle':\n            return self.base_lr + (self.max_lr - self.base_lr) * np.maximum(0, (1 - x)) * self.scale_fn(cycle)\n        else:\n            return self.base_lr + (self.max_lr - self.base_lr) * np.maximum(0, (1 - x)) * self.scale_fn(\n                self.clr_iterations)\n\n    def on_train_begin(self, logs={}):\n        logs = logs or {}\n\n        if self.clr_iterations == 0:\n            K.set_value(self.model.optimizer.lr, self.base_lr)\n        else:\n            K.set_value(self.model.optimizer.lr, self.clr())\n\n    def on_batch_end(self, epoch, logs=None):\n\n        logs = logs or {}\n        self.trn_iterations += 1\n        self.clr_iterations += 1\n\n        K.set_value(self.model.optimizer.lr, self.clr())\n","4771617a":"def categorical_focal_loss(gamma=2.0, alpha=0.25):\n    \"\"\"\n    Implementation of Focal Loss from the paper in multiclass classification\n    Formula:\n        loss = -alpha*((1-p)^gamma)*log(p)\n    Parameters:\n        alpha -- the same as wighting factor in balanced cross entropy\n        gamma -- focusing parameter for modulating factor (1-p)\n    Default value:\n        gamma -- 2.0 as mentioned in the paper\n        alpha -- 0.25 as mentioned in the paper\n    \"\"\"\n    def focal_loss(y_true, y_pred):\n        # Define epsilon so that the backpropagation will not result in NaN\n        # for 0 divisor case\n        epsilon = K.epsilon()\n        # Add the epsilon to prediction value\n        #y_pred = y_pred + epsilon\n        # Clip the prediction value\n        y_pred = K.clip(y_pred, epsilon, 1.0-epsilon)\n        # Calculate cross entropy\n        cross_entropy = -y_true*K.log(y_pred)\n        # Calculate weight that consists of  modulating factor and weighting factor\n        weight = alpha * y_true * K.pow((1-y_pred), gamma)\n        # Calculate focal loss\n        loss = weight * cross_entropy\n        # Sum the losses in mini_batch\n        loss = K.sum(loss, axis=1)\n        return loss\n    \n    return focal_loss\n","cf9302b7":"import tensorflow as tf\nfrom tensorflow.keras.layers import Layer\nfrom tensorflow.keras import initializers\nfrom tensorflow.keras import regularizers\nfrom tensorflow.keras import constraints\n\nclass Attention(Layer):\n    \"\"\"Multi-headed attention layer.\"\"\"\n    \n    def __init__(self, hidden_size, \n                 num_heads = 4, \n                 attention_dropout=.1,\n                 trainable=True,\n                 name='Attention'):\n        \n        if hidden_size % num_heads != 0:\n            raise ValueError(\"Hidden size must be evenly divisible by the number of heads.\")\n            \n        self.hidden_size = hidden_size\n        self.num_heads = num_heads\n        self.trainable = trainable\n        self.attention_dropout = attention_dropout\n        self.dense = tf.keras.layers.Dense(self.hidden_size, use_bias=False)\n        super(Attention, self).__init__(name=name)\n\n    def split_heads(self, x):\n        \"\"\"Split x into different heads, and transpose the resulting value.\n        The tensor is transposed to insure the inner dimensions hold the correct\n        values during the matrix multiplication.\n        Args:\n          x: A tensor with shape [batch_size, length, hidden_size]\n        Returns:\n          A tensor with shape [batch_size, num_heads, length, hidden_size\/num_heads]\n        \"\"\"\n        with tf.name_scope(\"split_heads\"):\n            batch_size = tf.shape(x)[0]\n            length = tf.shape(x)[1]\n\n            # Calculate depth of last dimension after it has been split.\n            depth = (self.hidden_size \/\/ self.num_heads)\n\n            # Split the last dimension\n            x = tf.reshape(x, [batch_size, length, self.num_heads, depth])\n\n            # Transpose the result\n            return tf.transpose(x, [0, 2, 1, 3])\n    \n    def combine_heads(self, x):\n        \"\"\"Combine tensor that has been split.\n        Args:\n          x: A tensor [batch_size, num_heads, length, hidden_size\/num_heads]\n        Returns:\n          A tensor with shape [batch_size, length, hidden_size]\n        \"\"\"\n        with tf.name_scope(\"combine_heads\"):\n            batch_size = tf.shape(x)[0]\n            length = tf.shape(x)[2]\n            x = tf.transpose(x, [0, 2, 1, 3])  # --> [batch, length, num_heads, depth]\n            return tf.reshape(x, [batch_size, length, self.hidden_size])        \n\n    def call(self, inputs):\n        \"\"\"Apply attention mechanism to inputs.\n        Args:\n          inputs: a tensor with shape [batch_size, length_x, hidden_size]\n        Returns:\n          Attention layer output with shape [batch_size, length_x, hidden_size]\n        \"\"\"\n        # Google developper use tf.layer.Dense to linearly project the queries, keys, and values.\n        q = self.dense(inputs)\n        k = self.dense(inputs)\n        v = self.dense(inputs)\n\n        q = self.split_heads(q)\n        k = self.split_heads(k)\n        v = self.split_heads(v)\n        \n        # Scale q to prevent the dot product between q and k from growing too large.\n        depth = (self.hidden_size \/\/ self.num_heads)\n        q *= depth ** -0.5\n        \n        logits = tf.matmul(q, k, transpose_b=True)\n        # logits += self.bias\n        weights = tf.nn.softmax(logits, name=\"attention_weights\")\n        \n        if self.trainable:\n            weights = tf.nn.dropout(weights, 1.0 - self.attention_dropout)\n        \n        attention_output = tf.matmul(weights, v)\n        attention_output = self.combine_heads(attention_output)\n        attention_output = self.dense(attention_output)\n        return attention_output\n        \n    def compute_output_shape(self, input_shape):\n        return tf.TensorShape(input_shape)","490d175e":"def Classifier(shape_):\n    \n    def wave_block(x,filters,kernel_size,n):\n        dilation_rates = [2**i for i in range(n)]\n        x = Conv1D(filters=filters,\n                    kernel_size=1, \n                    padding='same')(x)\n        res_x = x\n        for dilation_rate in dilation_rates:\n            tanh_out = Conv1D(filters=filters,\n                    kernel_size=kernel_size, \n                    padding='same',\n                    activation = 'tanh',\n                    dilation_rate=dilation_rate)(x)\n            sigm_out = Conv1D(filters=filters,\n                    kernel_size=kernel_size, \n                    padding='same',\n                    activation = 'sigmoid',\n                    dilation_rate=dilation_rate)(x)\n            x = Multiply()([tanh_out,sigm_out])\n            x = Conv1D(filters = filters,\n                           kernel_size = 1,\n                          padding='same')(x)\n\n            res_x = Add()([res_x,x])\n        return res_x\n        \n    \n    inp = Input(shape=(shape_))\n\n    x = wave_block(inp,16,3,12)\n    x = wave_block(x,  32,3,8)\n    x = wave_block(x,  64,3,4)\n    x = wave_block(x, 128,3,1)\n\n    out = Dense(11, activation='softmax', name='out')(x)\n    \n    model = models.Model(inputs=inp, outputs=out) \n    \n    opt = Adam(lr=LR)\n    opt = tfa.optimizers.SWA(opt)\n    model.compile(loss=losses.CategoricalCrossentropy(), optimizer=opt, metrics=['accuracy'])\n    return model","52b3dd72":"class MacroF1(Callback):\n    def __init__(self, model, inputs, targets):\n        self.model = model\n        self.inputs = inputs\n        self.targets = np.argmax(targets, axis=2).reshape(-1)\n\n    def on_epoch_end(self, epoch, logs):\n        pred = np.argmax(self.model.predict(self.inputs), axis=2).reshape(-1)\n        score = f1_score(self.targets, pred, average=\"macro\")\n        print(f' F1Macro: {score:.5f}')    \n    ","dc5b897f":"def normalize(train, test):\n    \n    train_input_mean = train.signal.mean()\n    train_input_sigma = train.signal.std()\n    train['signal'] = (train.signal-train_input_mean)\/train_input_sigma\n    test['signal'] = (test.signal-train_input_mean)\/train_input_sigma\n\n    return train, test","7f05e47e":"from pykalman import KalmanFilter\n\ndef Kalman1D(observations,damping=1):\n    # To return the smoothed time series data\n    observation_covariance = damping\n    initial_value_guess = observations[0]\n    transition_matrix = 1\n    transition_covariance = 0.1\n    initial_value_guess\n    kf = KalmanFilter(\n            initial_state_mean=initial_value_guess,\n            initial_state_covariance=observation_covariance,\n            observation_covariance=observation_covariance,\n            transition_covariance=transition_covariance,\n            transition_matrices=transition_matrix\n        )\n    pred_state, state_cov = kf.smooth(observations)\n    return pred_state","d5a09ea9":"\ndef run_everything(fe_config : List) -> NoReturn:\n    not_feats_cols = ['time']\n    target_col = ['open_channels']\n    init_logger()\n    with timer(f'Reading Data'):\n        logger.info('Reading Data Started ...')\n        base = os.path.abspath('\/kaggle\/input\/liverpool-ion-switching\/')\n        train, test, sample_submission = read_data(base)\n        observation_covariance = .0015\n        train['signal'] = Kalman1D(train.signal.values,observation_covariance)\n        test['signal'] = Kalman1D(test.signal.values,observation_covariance)\n        train, test = normalize(train, test)    \n        logger.info('Reading and Normalizing Data Completed ...')\n    with timer(f'Creating Features'):\n        logger.info('Feature Enginnering Started ...')\n        for config in fe_config:\n            train = run_feat_enginnering(train, create_all_data_feats=config[0], batch_size=config[1])\n            test  = run_feat_enginnering(test,  create_all_data_feats=config[0], batch_size=config[1])\n        train, test, feats = feature_selection(train, test)\n        logger.info('Feature Enginnering Completed ...')\n\n    with timer(f'Running Wavenet model'):\n        logger.info(f'Training Wavenet model with {SPLITS} folds of GroupKFold Started ...')\n        run_cv_model_by_batch(train, test, splits=SPLITS, batch_col='group', feats=feats, sample_submission=sample_submission, nn_epochs=EPOCHS, nn_batch_size=NNBATCHSIZE)\n        logger.info(f'Training completed ...')\n","d521cb93":"run_everything(fe_config)","acb0631f":"The validation scheme is based on [seq2seq-rnn-with-gru](https:\/\/www.kaggle.com\/brandenkmurray\/seq2seq-rnn-with-gru\/output), and cleaned data is from [data-without-drift](https:\/\/www.kaggle.com\/cdeotte\/data-without-drift) "}}