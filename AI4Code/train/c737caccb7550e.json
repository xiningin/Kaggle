{"cell_type":{"ab25eb7a":"code","f76634a2":"code","8a37d34c":"code","1f913b3a":"markdown","1ec662dd":"markdown","db3b0d44":"markdown"},"source":{"ab25eb7a":"import numpy as np\nimport math\n\ninputfile = '\/kaggle\/input\/hashcode-2021-oqr-extension\/hashcode.in'\noutputfile = 'submission.csv'\n\nalpha = 4\n\ninput = open(inputfile, 'r')\nline = input.readline()\nsettings = line.split()\nduration = int(settings[0])\nintersections = int(settings[1])\nstreets = int(settings[2])\ncars = int(settings[3])\nreward = int(settings[4])\n\n#We collect information about incomming and outgoing streets for each intersection in a form of matrix\nstreet_matrix = np.empty(shape=(intersections,intersections),dtype='object')\n\nfor i in range(streets):\n    line = input.readline()\n    street = line.split()\n    beginning = int(street[0])\n    end = int(street[1])\n    name = street[2]\n    length = int(street[3])\n    street_matrix[beginning,end] = {'name':name, 'length':length}\n    #We retain both name and length for each street\n    #this version of the solution does not use the length yet, but we wil expand on this later\n\n\n#We collect information about each car's route in a vector\n#this version of the solution does not use the car information yet, but we wil expand on this later\ncar_matrix = np.empty(shape=(cars),dtype='object')\n\nused_streets = {}\n\nfor i in range(cars):\n    line = input.readline()\n    car = line.split()\n    new_car = {'length':int(car[0])}\n    for j in range(1, len(car)-1):\n        new_car[j-1] = car[j]\n        if car[j] not in used_streets.keys():\n            used_streets[car[j]] = 1 * (int(car[0]) - (j - 1))\n        else:\n            used_streets[car[j]] += 1 * (int(car[0]) - (j - 1))\n        \n    new_car[len(car)-2] = car[len(car)-1]       \n    car_matrix[i] = new_car\n    \ninput.close()","f76634a2":"for i in range(intersections):\n    for j in range(intersections):\n        if street_matrix[i,j]:\n            if not (street_matrix[i,j]['name'] in used_streets.keys()):\n                street_matrix[i,j] = None\n                \nnumber_of_schedules = 0\nschedules = list()\nfor j in range(intersections):\n    endings = 0\n    sequence = {}\n    for i in range(intersections):\n        if street_matrix[i,j]:\n            endings += 1\n            sequence[street_matrix[i,j]['name']] = 1\n    if endings > 0:\n        total_usage = 0\n        for key in sequence:\n            total_usage += used_streets[key]\n        for key in sequence:\n            sequence[key] = math.ceil (alpha *  used_streets[key] \/ float(total_usage))\n        number_of_schedules += 1\n        light_shedule = {'id':j}\n        light_shedule['length'] = endings\n        light_shedule['sequence'] = sequence\n        schedules.append(light_shedule)","8a37d34c":"with open(outputfile, 'w') as writefile:\n    writefile.write(str(number_of_schedules))\n    for i in range(number_of_schedules):\n        writefile.write('\\n'+ str(schedules[i]['id']))\n        writefile.write('\\n'+ str(schedules[i]['length']))\n        for key in schedules[i]['sequence']:\n            writefile.write('\\n' + key + ' ' + str(schedules[i]['sequence'][key]))","1f913b3a":"This is a simple and straightforward solution that assigns schedule to each traffic light that has incomming streets and allocates exactly one second to each incomming street.","1ec662dd":"![](http:\/\/)We use the Schedules dictionary to form the output file","db3b0d44":"We go through the street matrix finding all Traffic lights that have incomming streets and createing a dictionary of schedules for them"}}