{"cell_type":{"76fa697d":"code","72b60272":"code","7f23e4d4":"code","46a621fe":"code","f7a01efd":"code","5311aa21":"code","01ec8fd0":"code","80d205a5":"code","9df387a8":"code","0a8f9ff7":"code","f02ada6f":"code","3ddac855":"code","ae6df205":"code","99463368":"code","a9eb1767":"code","19100da5":"code","7d8b3be7":"code","6f784052":"code","df9fd056":"code","16e6db21":"code","696130a2":"code","22cf1ee8":"code","3f2b1f36":"code","8d5e238e":"code","71235e34":"code","620a21fe":"code","8725f192":"code","cec6f919":"code","2b05fafb":"code","3a58f2a5":"code","9e95c824":"code","009d94a0":"code","75ca1173":"code","29add42a":"code","84bb4e05":"code","ba98895f":"code","95625722":"code","bf42a276":"code","3239f025":"code","ef97754e":"code","474d7da6":"code","c0938966":"code","35d3305b":"code","a8d827ea":"code","60839e5f":"code","28a5b273":"code","5fe7b316":"code","7fb9f785":"code","550def4a":"code","2d6d3344":"code","ee73209b":"code","88566f17":"markdown","19830fd0":"markdown","74da2ba2":"markdown","04bbd55b":"markdown","d53373b3":"markdown","caab2d63":"markdown","1df30d4c":"markdown","3dca58de":"markdown","acd5281e":"markdown","8c6989da":"markdown","370dcdef":"markdown"},"source":{"76fa697d":"import numpy as np\nimport pandas as pd\nimport os\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom imageio import imread\nfrom skimage.transform import resize\nfrom keras.models import load_model\nfrom tqdm._tqdm_notebook import tqdm_notebook\nfrom sklearn.model_selection import GroupKFold\n\nfrom sklearn.model_selection import cross_validate\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import roc_auc_score","72b60272":"import warnings\ndef ignore_warn(*args, **kwargs):\n    pass\nwarnings.warn = ignore_warn #ignore annoying warning (from sklearn and seaborn)\nwarnings.filterwarnings('ignore') #this one works good!","7f23e4d4":"train_df = pd.read_csv(\"..\/input\/recognizing-faces-in-the-wild\/train_relationships.csv\")\ntrain_df.head()","46a621fe":"# Find all the train images\n\ndef findAllTrain(train_folder):\n    train_li=[]\n    for fam in os.listdir(train_folder):\n        for pers in os.listdir(os.path.join(train_folder,fam)):\n            for pic in os.listdir(os.path.join(train_folder,fam,pers)):\n                train_li.append(os.path.join(fam,pers,pic))\n    \n    return train_li\n\ntrain_fd = '..\/input\/recognizing-faces-in-the-wild\/train'\n\ntrain_file_li=findAllTrain(train_fd)\n\nprint('There are {} images in the train dataset.'.\n      format(len(train_file_li)))\n\n#Create a dict to store all the train images\ntrain_file_dict=dict(zip(train_file_li,range(len(train_file_li))))\n\n# Create a DataFrame to store all the train images\ntrain_file_df = pd.DataFrame()\ntrain_file_df['image_fp']=train_file_li\ntrain_file_df.sample(5)","f7a01efd":"# Find all the image pairs with kinship\n\ntrain_fd = '..\/input\/recognizing-faces-in-the-wild\/train'\n\nindex_p1_li=[]\nindex_p2_li=[]\n\nfor idx, row in tqdm_notebook(train_df.iterrows(), total=len(train_df)):\n    if os.path.isdir(os.path.join(train_fd,row['p1'])) and os.path.isdir(os.path.join(train_fd,row['p2'])): # some folders do not exist !!\n        for p1_pic in os.listdir(os.path.join(train_fd,row['p1'])):\n            for p2_pic in os.listdir(os.path.join(train_fd,row['p2'])):\n                index_f1=train_file_dict[os.path.join(row['p1'].split('\/')[0],row['p1'].split('\/')[1],p1_pic)]\n                index_f2=train_file_dict[os.path.join(row['p2'].split('\/')[0],row['p2'].split('\/')[1],p2_pic)]\n                if index_f1<index_f2: # force the image pairs to have the same order of persons\n                    index_p1_li.append(index_f1)\n                    index_p2_li.append(index_f2)\n                else:\n                    index_p1_li.append(index_f2)\n                    index_p2_li.append(index_f1)\n                    \ntrain_pairs_kinship=pd.DataFrame()\ntrain_pairs_kinship['p1']=index_p1_li\ntrain_pairs_kinship['p2']=index_p2_li\n\nindex_p1_li=[]\nindex_p2_li=[]\n\nprint('Total image pairs with kinship: {}'.format(len(train_pairs_kinship)))\ntrain_pairs_kinship.sample(5)","5311aa21":"# make image pairs of the same person\n# for example: for this person \"F0002\\MID1\", there are 10 images in the folder, so it can make 10*9\/2=45 pairs.\n\ndef make_pair_same_person(source,pre_path):\n    res_p1_li = []\n    res_p2_li = []\n    for p1 in range(len(source)):\n        for p2 in range(p1+1,len(source)):\n            index_f1=train_file_dict[os.path.join(pre_path,source[p1])]\n            index_f2=train_file_dict[os.path.join(pre_path,source[p2])]\n            if index_f1<index_f2: # force the image pairs to have the same order of persons\n                res_p1_li.append(index_f1)\n                res_p2_li.append(index_f2)\n            else:\n                res_p1_li.append(index_f2)\n                res_p2_li.append(index_f1)\n            \n    return (res_p1_li,res_p2_li)\n\nindex_p1_li = []\nindex_p2_li = []\nfor fam in os.listdir(train_fd):\n    for pers in os.listdir(os.path.join(train_fd,fam)):\n        res_temp = make_pair_same_person([pic for pic in os.listdir(os.path.join(train_fd,fam,pers))],os.path.join(fam,pers))\n        index_p1_li.extend(res_temp[0])\n        index_p2_li.extend(res_temp[1])\n\ntrain_pairs_same=pd.DataFrame()\ntrain_pairs_same['p1']=index_p1_li\ntrain_pairs_same['p2']=index_p2_li\n\nindex_p1_li = []\nindex_p2_li = []\n\nprint('Total image pairs of same person: {}'.format(len(train_pairs_same)))\n\ntrain_pairs_same.sample(5)","01ec8fd0":"fig, ax = plt.subplots(figsize=(12,2))\ny2show=[len(train_pairs_kinship),len(train_pairs_same)]\nplt.barh(range(2),y2show,0.35)\nplt.title('Image pair number')\nplt.yticks(range(2), ('With kinship', 'From same person'),)\nplt.box(on=None)\nplt.xticks([], [])\nfor i, v in enumerate(y2show):\n    ax.text(v+1000, i-0.05, str(v), color='blue', fontweight='bold')","80d205a5":"train_pairs_kinship=pd.concat([train_pairs_kinship,train_pairs_same],ignore_index=True) # Combine them together\ntrain_pairs_same=None # to free RAM\nprint('Total POSITIVE image pairs: {}'.format(len(train_pairs_kinship)))","9df387a8":"# Get all the possible image pairs\n\nindex_p1_li = []\nindex_p2_li = []\n\nfor p1 in tqdm_notebook(range(len(train_file_li))):    \n    for p2 in range(p1+1,len(train_file_li)):\n        index_p1_li.append(p1)\n        index_p2_li.append(p2)\n\ntrain_pairs_all=pd.DataFrame()\ntrain_pairs_all['p1']=index_p1_li\nindex_p1_li = []\ntrain_pairs_all['p2']=index_p2_li\nindex_p2_li = []\n\nprint('Total image pairs: {}'.format(len(train_pairs_all)))\n\ntrain_pairs_all.sample(5)","0a8f9ff7":"# Add a col \"is_related\": 1 if POS, 0 if NEG\n\nkin_index=np.arange(len(train_pairs_all))[train_pairs_all.merge(train_pairs_kinship, on=['p1','p2'],how='left', indicator=True)['_merge']=='both']\ntrain_pairs_all['is_related']=0\ntrain_pairs_all.loc[kin_index,'is_related']=1\nkin_index=None # to free RAM\ntrain_pairs_kinship=None # to free RAM","f02ada6f":"fig, ax = plt.subplots(figsize=(12,2))\ny2show=[train_pairs_all.query('is_related == 0').shape[0],train_pairs_all.query('is_related == 1').shape[0]]\nplt.barh(range(2),y2show,0.35)\nplt.title('Image pair number')\nplt.yticks(range(2), ('No Kinship (NEG)','With kinship (POS)'))\nplt.box(on=None)\nplt.xticks([], [])\nfor i, v in enumerate(y2show):\n    ax.text(v+1000, i-0.05, str(v), color='blue', fontweight='bold')","3ddac855":"print(\"The number of negative samples is {:.0f} times of positive samples!\".\n      format(train_pairs_all.query('is_related == 0').shape[0]\/train_pairs_all.query('is_related == 1').shape[0]))","ae6df205":"# Get family ID for each image\n\ntrain_file_df['fam']=-1\ntrain_file_df['fam']=train_file_df['image_fp'].apply(lambda x: int(x[1:5]))\ntrain_file_df.reset_index(inplace=True)\ntrain_file_df.head()","99463368":"print('There are {} families in the train set.'.format(len(train_file_df.fam.unique())))","a9eb1767":"# Get family ID for each POSimage pair (use p1 only)\ntrain_pairs_kinship = train_pairs_all.query('is_related == 1')\ntrain_pairs_kinship=train_pairs_kinship.merge(train_file_df[['index','fam']], left_on='p1',right_on='index',how='left').drop(columns=['index'])\ntrain_pairs_kinship.sample(5)","19100da5":"fig, ax = plt.subplots(figsize=(12,5))\nsns.countplot(x='fam',data=train_pairs_kinship,\n              order=train_pairs_kinship.fam.value_counts().iloc[:20].index)\nplt.title('Top 20 families (image pair with kinship | POS samples)')\nax.text(12, 30000, 'Average POS samples per family is {:.0f}'.format(len(train_pairs_kinship)\/len(train_pairs_kinship.fam.unique())),fontsize=12)\nfor i, v in enumerate(train_pairs_kinship['fam'].value_counts()[:20]):\n    ax.text(i-0.4, v+500, str(v),color='gray')\nplt.box(on=None)\nplt.yticks([]);","7d8b3be7":"print('Family 601 contains {:.0f}% of image pair of all the POS samples!'.format(train_pairs_kinship['fam'].value_counts().tolist()[0]\/len(train_pairs_kinship)*100))\nprint('Family 9 contains {:.0f}% of image pair of all the POS samples.'.format(train_pairs_kinship['fam'].value_counts().tolist()[1]\/len(train_pairs_kinship)*100))","6f784052":"limit_number = 3000\n\nindex_li = train_pairs_kinship['fam'].value_counts()[lambda x:x<=limit_number].index\ntrain_fam_lim_df = train_pairs_kinship[train_pairs_kinship['fam'].isin(index_li)]\n\nfor i in train_pairs_kinship['fam'].value_counts()[lambda x:x>limit_number].index:\n    df_temp = train_pairs_kinship.query('fam == {}'.format(i)).sample(limit_number,replace=False,random_state=2019)\n    train_fam_lim_df = pd.concat([train_fam_lim_df, df_temp])\n    \ntrain_fam_lim_df=train_fam_lim_df.reset_index() # Reset index for GroupKFold method\n\nprint('Number of POS samples in the selected dataset: {}'.format(len(train_fam_lim_df)))","df9fd056":"fig, ax = plt.subplots(figsize=(12,5))\nsns.countplot(x='fam',data=train_fam_lim_df,order=train_fam_lim_df.fam.value_counts().iloc[:20].index)\nplt.title('Top 20 families (image pair with kinship | POS samples)')\nax.text(12, 2500, 'Average POS samples per family is {:.0f}'.format(len(train_pairs_kinship)\/len(train_fam_lim_df.fam.unique())),fontsize=12)\nfor i, v in enumerate(train_fam_lim_df['fam'].value_counts()[:20]):\n    ax.text(i-0.4, v+100, str(v),color='gray')\nplt.box(on=None)\nplt.yticks([]);","16e6db21":"gkf = GroupKFold(n_splits=6) # Group 6 as test set, Group0-5 as CV folders.\n\ntrain_fam=train_fam_lim_df['fam']\n\nfam_group=np.ones(max(train_fam_lim_df['fam'])+1)*(-1)\nfam_group=fam_group.astype(int)\n\nfor idx,( _, test_index) in enumerate(gkf.split(X=train_fam,groups=train_fam)):\n    print(\"Group {}: {}\".format(idx,np.unique(train_fam[test_index])))\n    fam_group[np.unique(train_fam[test_index])]=idx\n    print('-'*85)","696130a2":"# Get group ID for each image\n\ntrain_file_df['group']=train_file_df['fam'].apply(\n    lambda x: fam_group[x])\n\ntrain_file_df.sample(5)","22cf1ee8":"# Get group ID for each image pair\n\ntqdm_notebook.pandas()\ngroup_li=train_file_df['group'].tolist()\n\ntrain_pairs_all['group1']=train_pairs_all['p1'].progress_apply(lambda x: group_li[x])\ntrain_pairs_all['group2']=train_pairs_all['p2'].progress_apply(lambda x: group_li[x])\ntmp_li = (train_pairs_all['group1']==train_pairs_all['group2'])*(train_pairs_all['group1']+1)-1\ntrain_pairs_all.drop(columns=['group1','group2'],inplace=True)\ntrain_pairs_all['group']=tmp_li\ntmp_li=None # to free RAM\ntrain_pairs_all.sample(5)","3f2b1f36":"fig, ax = plt.subplots(figsize=(12,5))\nsns.countplot(y='group',data=train_pairs_all,orient='v')\nplt.title('Number of image pair in each group')\nax.text(30000000,1, '\"-1\" means no group is assigned.',fontsize=16)\nax.text(25000000,2,\n        '{:.0f}% of image pairs have no group assigned.'.format(train_pairs_all.query('group == -1').shape[0]\/len(train_pairs_all)*100),\n        fontsize=16)\nplt.box(on=None)\nplt.xticks([]);","8d5e238e":"# Drop group==-1\ntrain_pairs_all = train_pairs_all[train_pairs_all['group']!=-1]\n# Shuffle\ntrain_pairs_all = train_pairs_all.sample(frac=1,random_state=2019)","71235e34":"train_dataset_df=train_fam_lim_df\ntrain_dataset_df['group']=train_dataset_df['fam'].apply(lambda x: fam_group[x])\ntrain_dataset_df.drop(columns=['index','fam'],inplace=True)\ntrain_dataset_df.head()","620a21fe":"group_num = train_fam_lim_df.groupby('group')['is_related'].count().tolist()\nportion=1 # get equal number of NEG \/ POS\ndf_temp = pd.concat(\n    [t.head(int(group_num[g]*portion)) for g, t in train_pairs_all.query('is_related == 0').groupby('group', sort=False, as_index=False)],\n    ignore_index=True)\n\ntrain_dataset_df=pd.concat([train_dataset_df,df_temp],ignore_index=True)\ntrain_dataset_df.shape","8725f192":"# to free RAM\ntrain_pairs_all=None\ntrain_pairs_kinship=None","cec6f919":"fig, ax = plt.subplots(figsize=(12,5))\nsns.countplot(y='group',data=train_dataset_df,orient='v',hue='is_related')\nplt.title('Number of image pair in each group')\nplt.box(on=None)\nplt.xticks([]);","2b05fafb":"train_dataset_df.head()","3a58f2a5":"model_path = '..\/input\/facenet-keras\/facenet_keras.h5'\nmodel_facenet_keras = load_model(model_path)","9e95c824":"def prewhiten(x):\n    if x.ndim == 4:\n        axis = (1, 2, 3)\n        size = x[0].size\n    elif x.ndim == 3:\n        axis = (0, 1, 2)\n        size = x.size\n    else:\n        raise ValueError('Dimension should be 3 or 4')\n\n    mean = np.mean(x, axis=axis, keepdims=True)\n    std = np.std(x, axis=axis, keepdims=True)\n    std_adj = np.maximum(std, 1.0\/np.sqrt(size))\n    y = (x - mean) \/ std_adj\n    return y\n\ndef l2_normalize(x, axis=-1, epsilon=1e-10):\n    output = x \/ np.sqrt(np.maximum(np.sum(np.square(x), axis=axis, keepdims=True), epsilon))\n    return output\n\ndef load_and_align_images(filepaths, margin,image_size = 160):\n    \n    aligned_images = []\n    for filepath in filepaths:\n        img = imread(filepath)\n        aligned = resize(img, (image_size, image_size), mode='reflect')\n        aligned_images.append(aligned)\n            \n    return np.array(aligned_images)","009d94a0":"def calc_embs(filepaths, margin=10, batch_size=512):\n    pd = []\n    for start in tqdm_notebook(range(0, len(filepaths), batch_size)):\n        aligned_images = prewhiten(load_and_align_images(filepaths[start:start+batch_size], margin))\n        pd.append(model_facenet_keras.predict_on_batch(aligned_images))\n    embs = l2_normalize(np.concatenate(pd))\n\n    return embs","75ca1173":"# Calculate embs for train images\n\ntrain_embs = calc_embs([os.path.join(\"..\/input\/recognizing-faces-in-the-wild\/train\", f) for f in train_file_df['image_fp']])\ntrain_file_df=pd.concat([train_file_df, pd.DataFrame(train_embs,columns=['fe'+str(i) for i in range(128)])],axis=1)\ntrain_file_df.head()","29add42a":"# Use absolute distance as final features\n\np1_df = train_dataset_df.merge(train_file_df, left_on='p1',right_on='index',how='left').iloc[:,8:]\np2_df = train_dataset_df.merge(train_file_df, left_on='p2',right_on='index',how='left').iloc[:,8:]\n\ntrain_dataset_df = pd.concat([train_dataset_df, abs(p1_df-p2_df)],axis=1)\np1_df=None\np2_df=None\ntrain_dataset_df.head()","84bb4e05":"# shuffle the dataset\ntrain_dataset_df=train_dataset_df.sample(frac=1,random_state=2019).reset_index(drop=True)\ntrain_dataset_df.head()","ba98895f":"X=train_dataset_df.iloc[:,4:]\ny=train_dataset_df.iloc[:,2]\nX.shape, y.shape","95625722":"X_train=X[train_dataset_df['group']!=5]\nX_test=X[train_dataset_df['group']==5]\ny_train=train_dataset_df['is_related'][train_dataset_df['group']!=5]\ny_test=train_dataset_df['is_related'][train_dataset_df['group']==5]\n\ny_train_group=train_dataset_df['group'][train_dataset_df['group']!=5]\n\nX_train.shape,X_test.shape,y_train.shape,y_test.shape,y_train_group.shape","bf42a276":"# group kfolder\ngroup_kfold = GroupKFold(n_splits=5)","3239f025":"# this is a check of GroupKFold result\n\nfor train_index, test_index in group_kfold.split(X_train, y_train, y_train_group):\n    #print(\"TRAIN:\", train_index, \"TEST:\", test_index)\n    print(np.unique(y_train_group.as_matrix()[train_index]))\n    print(np.unique(y_train_group.as_matrix()[test_index]))\n    print('-'*20)","ef97754e":"model=LogisticRegression(random_state=2019)\nres=cross_validate(model,X_train,y_train,cv=group_kfold,n_jobs=1,groups=y_train_group,scoring=('accuracy', 'roc_auc'))\nprint(\"Mean ROC_AUC score: {:.4f} (std: {:.4f})\".format(res['test_roc_auc'].mean(),res['test_roc_auc'].std()))","474d7da6":"# test on Test Set\nmodel.fit(X_train,y_train)\nprint(\"ROC_AUC socre on test set: {:.3f}\".format(roc_auc_score(y_test,model.predict_proba(X_test)[:,1])))","c0938966":"# Calculate embs for test images\ntest_images = os.listdir(\"..\/input\/recognizing-faces-in-the-wild\/test\/\")\ntest_embs = calc_embs([os.path.join(\"..\/input\/recognizing-faces-in-the-wild\/test\/\", f) for f in test_images])","35d3305b":"img2idx = dict()\nfor idx, img in enumerate(test_images):\n    img2idx[img] = idx","a8d827ea":"test_df = pd.read_csv(\"..\/input\/recognizing-faces-in-the-wild\/sample_submission.csv\")\ntest_df.head()","60839e5f":"test_np = []\nfor idx, row in tqdm_notebook(test_df.iterrows(), total=len(test_df)):\n    imgs = [test_embs[img2idx[img]] for img in row.img_pair.split(\"-\")]\n    test_np.append(abs(imgs[0]-imgs[1]))\ntest_np = np.array(test_np)","28a5b273":"# Predict\nmodel.fit(X,y)\nprobs = model.predict_proba(test_np)[:,1]\n\nsub_df = pd.read_csv(\"..\/input\/recognizing-faces-in-the-wild\/sample_submission.csv\")\nsub_df.is_related = probs","5fe7b316":"sub_df.hist();","7fb9f785":"# use this function to show some image pairs.\ndef show2pic(fd,paire):\n    plt.figure(figsize=(7,10))\n    plt.subplot(121)\n    plt.imshow(imread(os.path.join(fd,paire.split('-')[0])))\n    plt.axis('off')\n    plt.title(paire.split('-')[0])\n    plt.subplot(122)\n    plt.imshow(imread(os.path.join(fd,paire.split('-')[1])))\n    plt.axis('off')\n    plt.title(paire.split('-')[1])","550def4a":"sub_df.sort_values('is_related',ascending=False).head(10)","2d6d3344":"# here is an example of the top 5th result.\n\nshow2pic('..\/input\/recognizing-faces-in-the-wild\/test\/',sub_df.loc[4636,'img_pair'])","ee73209b":"# export result to csv file\nsub_df.to_csv(\"submission.csv\", index=False)","88566f17":"# Introduction\n\n> This is my first kernel shared :)\n\n- The main idea of this kernel is to share some observations on the dataset and some recommandations on the cross-validation folders. \n- The Pipeline is: firstly use FaceNet to have features extracted, then use these features to train a traditional machine learning model, and use this model to predict on test set.\n\nThe FaceNet idea was inspired by [Khoi Nguyen](https:\/\/www.kaggle.com\/suicaokhoailang) and his [kernel](https:\/\/www.kaggle.com\/suicaokhoailang\/facenet-baseline-in-keras-0-749-lb). \n\nI am new to Deep Learning, so firstly I only used deep net as feature extractor, then use traditional way to train the model. Here we can use other deep net, like VGGFace, to replace FaceNet as feature extractor. After feature extraction, we can test on very different traditional machine learning models.","19830fd0":"# Train model","74da2ba2":"# Load useful libraries","04bbd55b":"# Predict and Export result","d53373b3":"Only LogisticRegression model is tested. You can use other more advanced model, like lightgbm, to train on the same dataset. And use GridSearchCV to tweat super parameters.","caab2d63":"# Create folders for cross-validation\n\nIt is very important to have good cross-validation folders, in order to:\n- Avoid data leakage\n- Optimize model parameters\n- Close the gap between your validation set and LB score\n\nThe main idea is: **The same family does NOT appear in two different folds!** \n\nThis is the same as **GroupKFold** in Scikit-Learn. However, we can not use GroupKFold directly in this case. If we define one \"family\" as one \"group\", then it will be difficult to define the family ID for negative samples (image pair with NO kinship), because the 2 persons in negative image pairs can be from 2 different families.\n\nSo we have to create our own group number for NEG samples. Firstly, use GroupKFold to seperate POS samples into N folders (use family ID as group). Then we can get a family list for each folder. And this family list can be used to get NEG samples for each folders. For example, the 2 persons in a NEG sample are from family-1 and family-2, and both families are in folder-A's family list, then this NEG sample can be assigned to folder-A.\n\nHowever, this method has a problem on this dataset!! Let's see below:","1df30d4c":"# Get image pairs\n\nFind all the possible image pairs for training.","3dca58de":"# Use Facenet to calculate 128 features","acd5281e":"**How about the image pairs from the same person? Should they be used as positive samples (with kinship)? I think YES.**\n\nBecause basicly we are training a model to identify the similarity of two images, the same person's images can bring us more postive samples. ","8c6989da":"6 groups have been created, now it's time to add NEG samples to each group.\n\nIs it the best to have the equal number of POS and NEG samples? Or shall we have more portion for NEG samples, like 2:1? I will test other portions later.","370dcdef":"As shown above, **the family 601 represents 35% of POS samples**.\n\nWhat happens? If you open the family folder, you'll find that it's **British Royal Family** ! Of course!\n\nThis kernel [EDA with Plotly-Smart, Cute and Pretty People](https:\/\/www.kaggle.com\/gowrishankarin\/eda-with-plotly-smart-cute-and-pretty-people) by [Gowri Shankar](https:\/\/www.kaggle.com\/gowrishankarin) shows great visualizations on this.\n\nWhy does it cause a problem to create our CV folders? \n\nWe want each folder to have equivalent number of samples. If we cut our samples into 3 or more folders, and we don't want the same family appears in two different folds (to avoid data leakage), so the British Royal Family will take one whole folder. It will bias the cross validation score. \n\nSo, we may reduce the POS sample number per family to a certain limit, like 3000. If the number is above the limit, only use 3000 random samples from tha family. "}}