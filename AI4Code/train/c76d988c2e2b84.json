{"cell_type":{"cdcc3963":"code","cf3f17b8":"code","8ae30aa0":"code","dfd29d1b":"code","7f253a6c":"code","2f5236bb":"code","6435bab1":"code","3633be3e":"code","934c2c6a":"code","f1e21633":"code","259f73a0":"code","31549da9":"code","c6d9820d":"markdown","6e0efa20":"markdown","370f3750":"markdown","e23094fc":"markdown","bdb29022":"markdown","508b9332":"markdown","01a9cb74":"markdown","19ca3256":"markdown","34de7d18":"markdown","8d8edee0":"markdown","797fd795":"markdown","b970eb9f":"markdown","41f403ce":"markdown","83364758":"markdown","932e26bb":"markdown","71755aaf":"markdown","f37c8331":"markdown","f4cfa706":"markdown","08ffe1b5":"markdown","e9abf6b3":"markdown","8b7b6038":"markdown","617741f9":"markdown","268230f7":"markdown","cc245b36":"markdown","650f2937":"markdown"},"source":{"cdcc3963":"import numpy as np\nfrom numba import jit","cf3f17b8":"x = np.arange(102).reshape(17, 6)","8ae30aa0":"x","dfd29d1b":"@jit(nopython=True)\ndef example1(a): # Function is compiled to machine code when called the first time\n    trace = 0\n    for i in range(a.shape[0]):   \n        trace += np.tanh(a[i, i]) \n    return a + trace              \n\nprint(example1(x))","7f253a6c":"x = {'a': [1, 2, 3], 'b': [20, 30, 40]}\n\nimport pandas as pd\n@jit\ndef use_pandas(a): \n    df = pd.DataFrame.from_dict(a) # Numba doesn't know about pd.DataFrame\n    df += 1                        # Numba doesn't understand what this is\n    return df.cov()                # or this!\n\nprint(use_pandas(x))","2f5236bb":"import time\n\nx = np.arange(100).reshape(10, 10)\n\n@jit(nopython=True)\ndef go_fast(a): # Function is compiled and runs in machine code\n    trace = 0\n    for i in range(a.shape[0]):\n        trace += np.tanh(a[i, i])\n    return a + trace\n\n# DO NOT REPORT THIS... COMPILATION TIME IS INCLUDED IN THE EXECUTION TIME!\nstart = time.time()\ngo_fast(x)\nend = time.time()\nprint(\"Elapsed (with compilation) = %s\" % (end - start))\n\n# NOW THE FUNCTION IS COMPILED, RE-TIME IT EXECUTING FROM CACHE\nstart = time.time()\ngo_fast(x)\nend = time.time()\nprint(\"Elapsed (after compilation) = %s\" % (end - start))","6435bab1":"from numba import vectorize, float64, int32, int64, float32\n\n@vectorize([float64(float64, float64)])\ndef example2(x, y):\n    return x + y","3633be3e":"@vectorize([int32(int32, int32),\n            int64(int64, int64),\n            float32(float32, float32),\n            float64(float64, float64)])\ndef f(x, y):\n    return x + y","934c2c6a":"start = time.time()\nf(9, 9.9)\nend = time.time()\nprint(\"Elapsed (after compilation) = %s\" % (end - start))","f1e21633":"import numpy as np\nfrom numba import jitclass          # import the decorator\n\nspec = [\n    ('value', int32),               # a simple scalar field\n    ('array', float32[:]),          # an array field\n]\n\n@jitclass(spec)\nclass Bag(object):\n    def __init__(self, value):\n        self.value = value\n        self.array = np.zeros(value, dtype=np.float32)\n\n    @property\n    def size(self):\n        return self.array.size\n\n    def increment(self, val):\n        for i in range(self.size):\n            self.array[i] = val\n        return self.array","259f73a0":"from numba import cfunc\n\n@cfunc(\"float64(float64, float64)\")\ndef add(x, y):\n    return x + y\n","31549da9":"from numba import stencil\n\n@stencil\ndef kernel1(a):\n    return 0.25 * (a[0, 1] + a[1, 0] + a[0, -1] + a[-1, 0])","c6d9820d":"The vectorize() decorator has two modes of operation:\n\n* Eager, or decoration-time, compilation\n* Lazy, or call-time, compilation","6e0efa20":"Numba works with:\n* Windows, OS X and Linux (OS)\n* x86, x86_64 (architecture)\n* Nvidia CUDA (GPU)\n* Latest version of NumPy\n* CPython","370f3750":"Stencils are  common computational patters where array elements are updated according to a **stencil kernel**. Numba provides `@stencil` so users can specify a stencil kernel and then Numba will update the array elements with accordance to the stencil kernels.","e23094fc":"The `@cfunc` decorator has a similar usage to `@jit`, but with an important difference: **a single signature is mandatory**. It determines the signature of the C callback:","bdb29022":"# 1. How to use it (basic)","508b9332":"Numba supports code generation for classes via the `numba.jitclass()` decorator. A class can be marked for optimization using this decorator along with a specification of the types of each field. We call the resulting class object a `jitclass`. \n\nAll methods of a `jitclass` are compiled into nopython functions. The data of a `jitclass` instance is allocated on the heap as a C-compatible structure so that any compiled functions can have direct access to the underlying data, bypassing the interpreter.","01a9cb74":"# 2. How to measure the performance of Numba?","19ca3256":"**Numba\u2019s vectorize allows Python functions taking scalar input arguments to be used as NumPy ufuncs** <br><br> NumPy ufuncs are not the most straightforward process and involves writing C code. Numba makes this easy. Using the vectorize() decorator, Numba can compile a pure Python function into a ufunc that operates over NumPy arrays as fast as traditional C ufuncs.","34de7d18":"If you pass several signatures:","8d8edee0":"If your code involves a lot of mathematical heavy lifting, or involves a ton of NumPy arrays, then Numba is perfectly suited to run. In this example, we'll use the `@jit` decorator, Numba's most basic.","797fd795":"But Numba is horrid on this:","b970eb9f":"Once the compilation has taken place Numba runs the machine code version of your function. If it is called again the with same types, it can reuse the cached version instead of having to compile again.\n\nA common mistake when measuring performance is not accounting for the above behaviour and to time code once with a simple timer that includes the time taken to compile your function in the execution time.\n\nFor example:","41f403ce":"* At SciPy 2017: https:\/\/www.youtube.com\/watch?v=1AwG0T4gaO0\n* By EuroPython: https:\/\/www.youtube.com\/watch?v=UaFSnaYh2b8\n* Medium: https:\/\/towardsdatascience.com\/speed-up-your-algorithms-part-2-numba-293e554c5cc1","83364758":"# A detailed Guide to Numba","932e26bb":"I can hear you guys \"What's that `nopython=True` do?\"\n\nWell, `nopython=True` allows Numba to compile your code **without** the interference of the Python interpreter, allowing your code to clock C++-level speeds (take that, you `cpp` bullies)","71755aaf":"In the basic case, only one signature will be passed:","f37c8331":"You can see that Numba does not understand Pandas, which means that Pandas will not benefit from `@jit`.","f4cfa706":"NUmba is a just-in-time Python compiler to get back at those C++ bullies. It is really helpful with code that uses NumPy arrays.\n\nNumba contains a huge amount of decorators, which can be applied to your functions to instruct Numba to get that compiling done. When a call is made to Numba decorators, it is compiled to machine code and can run at the speed of **machine code**.","08ffe1b5":"# 5. cfunc","e9abf6b3":"# 7. Resources","8b7b6038":"Here's an example of `jitclass`:","617741f9":"Watch `@jit` in work now:","268230f7":"# 6. Stencil","cc245b36":"# 4. @jitclass","650f2937":"# 3. @vectorize"}}