{"cell_type":{"2824d2fd":"code","4e9020d6":"code","1568721d":"code","1eb69986":"code","24f26ec9":"code","ed2ad3a6":"code","da0c6ca1":"code","d1866069":"code","66af254d":"code","6ba5e600":"code","2d78961e":"code","ddc84b32":"code","b11b5cbe":"code","9f02da01":"code","798fdd74":"code","71684732":"code","fc6fa149":"code","6854d8cb":"code","4553f01d":"markdown","4ca7d307":"markdown","28c49d45":"markdown","3cd7b43a":"markdown","7946369e":"markdown","994e2a8a":"markdown","a367e1f1":"markdown","96c6801e":"markdown"},"source":{"2824d2fd":"!pip install -U transformers","4e9020d6":"import os\nimport gc\n\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\nfrom tensorflow.keras.layers import Dense, Input\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.callbacks import ModelCheckpoint\nfrom kaggle_datasets import KaggleDatasets\nimport transformers\nfrom transformers import TFAutoModel, AutoTokenizer\nfrom tqdm.notebook import tqdm\nfrom tokenizers import Tokenizer, models, pre_tokenizers, decoders, processors","1568721d":"def regular_encode(texts, tokenizer, maxlen=512):\n    enc_di = tokenizer.batch_encode_plus(\n        texts, \n        return_attention_mask=False, \n        return_token_type_ids=False,\n        pad_to_max_length=True,\n        max_length=maxlen,\n        truncation=True\n    )\n    \n    return np.array(enc_di['input_ids'])","1eb69986":"def dict_encode(texts, tokenizer, maxlen=512):\n    enc_di = tokenizer.batch_encode_plus(\n        texts, \n        return_attention_mask=True, \n        return_token_type_ids=False,\n        pad_to_max_length=True,\n        max_length=maxlen,\n        truncation=True\n    )\n    \n    return {\n        \"input_ids\": np.array(enc_di['input_ids']),\n        \"attention_mask\": np.array(enc_di['attention_mask'])\n    }","24f26ec9":"def build_model(transformer, max_len=512):\n    \"\"\"\n    https:\/\/www.kaggle.com\/xhlulu\/jigsaw-tpu-distilbert-with-huggingface-and-keras\n    \"\"\"\n    input_word_ids = Input(shape=(max_len,), dtype=tf.int32, name=\"input_ids\")\n    attention_mask = Input(shape=(max_len,), dtype=tf.int32, name=\"attention_mask\")\n    sequence_output = transformer({\"input_ids\": input_word_ids, \"attention_mask\": attention_mask})[0]\n    cls_token = sequence_output[:, 0, :]\n    out = Dense(1, activation='sigmoid')(cls_token)\n    \n    model = Model(inputs={\n        \"input_ids\": input_word_ids,\n        \"attention_mask\": attention_mask\n    }, outputs=out)\n    model.compile(Adam(lr=1e-5), loss='binary_crossentropy', metrics=['accuracy'])\n    \n    return model","ed2ad3a6":"# Detect hardware, return appropriate distribution strategy\ntry:\n    # TPU detection. No parameters necessary if TPU_NAME environment variable is\n    # set: this is always the case on Kaggle.\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    print('Running on TPU ', tpu.master())\nexcept ValueError:\n    tpu = None\n\nif tpu:\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\nelse:\n    # Default distribution strategy in Tensorflow. Works on CPU and single GPU.\n    strategy = tf.distribute.get_strategy()\n\nprint(\"REPLICAS: \", strategy.num_replicas_in_sync)","da0c6ca1":"MAX_LEN = 192\nMODEL = 'jplu\/tf-xlm-roberta-large'\nAUTO = tf.data.experimental.AUTOTUNE\nBATCH_SIZE = 16 * strategy.num_replicas_in_sync\ntokenizer = AutoTokenizer.from_pretrained(MODEL)","d1866069":"train1 = pd.read_csv(\"\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/jigsaw-toxic-comment-train.csv\")\ntrain2 = pd.read_csv(\"\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/jigsaw-unintended-bias-train.csv\")\ntrain2.toxic = train2.toxic.round().astype(int)\n\nvalid = pd.read_csv('\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/validation.csv').sample(frac=1.0)\nn_valid_steps = valid.shape[0] \/\/ BATCH_SIZE\ntest = pd.read_csv('\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/test.csv')\nsub = pd.read_csv('\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/sample_submission.csv')","66af254d":"# Combine train1 with a subset of train2\ntrain = pd.concat([\n    train1[['comment_text', 'toxic']],\n    train2[['comment_text', 'toxic']].query('toxic==1'),\n    train2[['comment_text', 'toxic']].query('toxic==0').sample(n=100000, random_state=0)\n]).sample(frac=1.0)\nn_train_steps = train.shape[0] \/\/ BATCH_SIZE\ndel train1, train2\ngc.collect()","6ba5e600":"!free -h","2d78961e":"%%time \nx_train = dict_encode(train.comment_text.values, tokenizer, maxlen=MAX_LEN)\ny_train = train.toxic.values\n\ndel train\ngc.collect()\n\nx_valid = dict_encode(valid.comment_text.values, tokenizer, maxlen=MAX_LEN)\ny_valid = valid.toxic.values\ndel valid\ngc.collect()\nx_test = dict_encode(test.content.values, tokenizer, maxlen=MAX_LEN)","ddc84b32":"!free -h","b11b5cbe":"train_dataset = (\n    tf.data.Dataset\n    .from_tensor_slices((x_train, y_train))\n    .repeat()\n    .shuffle(4096)\n    .batch(BATCH_SIZE)\n    .prefetch(AUTO)\n)\n\nvalid_dataset = (\n    tf.data.Dataset\n    .from_tensor_slices((x_valid, y_valid))\n    .batch(BATCH_SIZE)\n    .cache()\n    .prefetch(AUTO)\n)\n\ntest_dataset = (\n    tf.data.Dataset\n    .from_tensor_slices(x_test)\n    .batch(BATCH_SIZE)\n)\ndel x_train, x_valid, y_train, y_valid\ngc.collect()","9f02da01":"%%time\nwith strategy.scope():\n    transformer_layer = TFAutoModel.from_pretrained(MODEL)\n    model = build_model(transformer_layer, max_len=MAX_LEN)\nmodel.summary()","798fdd74":"# Configuration\nEPOCHS = 2\n\ntrain_history = model.fit(\n    train_dataset,\n    steps_per_epoch=n_train_steps,\n    validation_data=valid_dataset,\n    epochs=EPOCHS\n)","71684732":"train_history_2 = model.fit(\n    valid_dataset.repeat(),\n    steps_per_epoch=n_valid_steps,\n    epochs=EPOCHS\n)","fc6fa149":"model.save_weights(\"final_weights.h5\")","6854d8cb":"sub['toxic'] = model.predict(test_dataset, verbose=1)\nsub.to_csv('submission.csv', index=False)","4553f01d":"## Helper Functions","4ca7d307":"## Load model into the TPU","28c49d45":"## Submission","3cd7b43a":"## TPU Configs","7946369e":"Now that we have pretty much saturated the learning potential of the model on english only data, we train it for one more epoch on the `validation` set, which is significantly smaller but contains a mixture of different languages.","994e2a8a":"## Train Model","a367e1f1":"## About this notebook\n\n*[Jigsaw Multilingual Toxic Comment Classification](https:\/\/www.kaggle.com\/c\/jigsaw-multilingual-toxic-comment-classification)* is the 3rd annual competition organized by the Jigsaw team. It follows *[Toxic Comment Classification Challenge](https:\/\/www.kaggle.com\/c\/jigsaw-toxic-comment-classification-challenge)*, the original 2018 competition, and *[Jigsaw Unintended Bias in Toxicity Classification](https:\/\/www.kaggle.com\/c\/jigsaw-unintended-bias-in-toxicity-classification)*, which required the competitors to consider biased ML predictions in their new models. This year, the goal is to use english only training data to run toxicity predictions on many different languages, which can be done using multilingual models, and speed up using TPUs.\n\nMany awesome notebooks has already been made so far. Many of them used really cool technologies like [Pytorch XLA](https:\/\/www.kaggle.com\/theoviel\/bert-pytorch-huggingface-starter). This notebook instead aims at constructing a **fast, concise, reusable, and beginner-friendly model scaffold**. \n\n**THIS DOES NOT USE ANY TRANSLATED DATA, BUT IT DOES TRAIN ON THE VALIDATION SET.**\n\n\n### References\n* Original Author: [@xhlulu](https:\/\/www.kaggle.com\/xhlulu\/)\n* Original notebook: [Link](https:\/\/www.kaggle.com\/xhlulu\/jigsaw-tpu-distilbert-with-huggingface-and-keras)","96c6801e":"First, we train on the subset of the training set, which is completely in English."}}