{"cell_type":{"e1eeaaf9":"code","a56abaa7":"code","b50f52e5":"code","0441042c":"code","e923f44f":"code","8326a579":"code","5175973d":"code","54a56554":"code","a75ae2bd":"code","3d2a34ac":"markdown","40d47fe1":"markdown","4e7aa1d7":"markdown","d7df3866":"markdown","77b68c35":"markdown","8b9598de":"markdown","f0441209":"markdown","cf2a3c28":"markdown"},"source":{"e1eeaaf9":"import numpy as np","a56abaa7":"arr2d = np.array([[0,0,0,0,0,0],\n                  [0,0,0,0,0,0],\n                  [0,1,1,1,0,0],\n                  [0,1,1,1,0,0],\n                  [0,1,1,1,1,0],\n                  [0,1,1,1,1,0],\n                  [0,1,1,1,1,0],\n                  [0,0,0,0,0,0]])","b50f52e5":"encoded_str = \"11 5 19 5 27 5 37 3\"","0441042c":"def rle_decode(mask_rle, shape):\n    '''\n    mask_rle: run-length as string formated (start length)\n    shape: (height,width) of array to return \n    Returns numpy array, 1 - mask, 0 - background\n\n    '''\n    s = mask_rle.split()\n    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0:][::2], s[1:][::2])]\n    starts -= 1\n    ends = starts + lengths\n    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)\n    for lo, hi in zip(starts, ends):\n        img[lo:hi] = 1\n    return img.reshape(shape)  ","e923f44f":"mask = rle_decode(encoded_str, shape=(8,6))\nmask","8326a579":"# chec if mask == arr2d\n(mask == arr2d).all()","5175973d":"def rle_decode_top_to_bot_first(mask_rle, shape):\n    '''\n    mask_rle: run-length as string formated (start length)\n    shape: (height,width) of array to return \n    Returns numpy array, 1 - mask, 0 - background\n\n    '''\n    s = mask_rle.split()\n    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0:][::2], s[1:][::2])]\n    starts -= 1\n    ends = starts + lengths\n    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)\n    for lo, hi in zip(starts, ends):\n        img[lo:hi] = 1\n    return img.reshape(shape, order='F')  # Reshape from top -> bottom first","54a56554":"mask = rle_decode_top_to_bot_first(encoded_str, shape=(8,6))\nmask","a75ae2bd":"# chec if mask == arr2d\n(mask == arr2d).all()","3d2a34ac":"### Proposed reshape (column-by-column):\n- I think it should be","40d47fe1":"### Also see the explanation here:\nhttps:\/\/www.kaggle.com\/c\/sartorius-cell-instance-segmentation\/discussion\/278936\n- The  first comment demonstrates how RLE works","4e7aa1d7":"### Compare the 2 types of reshaping using the above example","d7df3866":"There are 48 pixels. The top left is numbered 1 then you go down that column until you hit number 8. The top of the next column starts number 9, then down to 16, etc.\n\nIf walk the pixels from 1 to 48, a line of yellow begins at pixel 11 for length 5, then another begins at 19 for length 5, then another begins at 27 for length 5 and the last begins at 37 for length 3.\n\nSo the RLE is \"11 5 19 5 27 5 37 3\".","77b68c35":"### Default reshape (row-by-row)\n- From notebook: https:\/\/www.kaggle.com\/dschettler8845\/sartorius-segmentation-eda-efficientdet-tf\/notebook#helper_functions","8b9598de":"## Notebook purpose:\n- The purpose of this notebook is to ask: when projecting 1D coordinates to 2D one, how np.reshape should be use\n- In my idea:\n    - **np.reshape()** (default) chunk the 1D array row-by-row, which means left-> right then top -> bottom.\n    - However, it should be instead, **np.reshape(order='F')**, column-by-column, which means from top -> bottom then left to right","f0441209":"### According to evaluation page:\nhttps:\/\/www.kaggle.com\/c\/sartorius-cell-instance-segmentation\/overview\/evaluation\n- The competition format requires a space delimited list of pairs. For example, '1 3 10 5' implies pixels 1,2,3,10,11,12,13,14 are to be included in the mask. The pixels are one-indexed\nand numbered from **top to bottom, then left to right**: 1 is pixel 1,1; 2 is pixel 2,1, etc.","cf2a3c28":"![](https:\/\/user-images.githubusercontent.com\/17668390\/137576003-a887b201-7cc0-4e22-975f-d7727094d1d0.png)"}}