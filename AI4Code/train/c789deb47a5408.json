{"cell_type":{"e27b6d84":"code","7a852c47":"code","0d5fd30d":"code","8be455c2":"code","dff0ea78":"code","7899d5ee":"code","51c4dec2":"code","45aa08bc":"code","107a549b":"code","cadb3a48":"code","97fab556":"code","fffb3808":"code","43aee9d5":"code","67d2d70d":"code","03f7550e":"code","cd370499":"code","6707ad7a":"code","4367a9ba":"code","f6745854":"code","c6c84205":"code","4e07f440":"code","fc1ade29":"markdown","183bd467":"markdown","a666935c":"markdown","522615f6":"markdown","7c5e9f80":"markdown","1a71cf68":"markdown","b93bb7a0":"markdown","6dc75916":"markdown"},"source":{"e27b6d84":"import pandas as pd\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport spacy\nimport random\nimport tqdm","7a852c47":"dataset = pd.read_csv('..\/input\/sms_spam.csv')","0d5fd30d":"dataset.head()","8be455c2":"from sklearn.preprocessing import LabelEncoder\nlabel_encoder = LabelEncoder()\ntypes = label_encoder.fit_transform(dataset['type'])","dff0ea78":"from sklearn.model_selection import train_test_split\ntrain_x, test_x, train_y, test_y = train_test_split(dataset['text'], types, test_size = 0.1, random_state = 1 )","7899d5ee":"train_x, val_x, train_y, val_y = train_test_split(train_x, train_y, test_size = 0.1, random_state = 1)","51c4dec2":"len(train_x), len(test_x), len(val_x)","45aa08bc":"class SpamClassifier(nn.Module):\n    def __init__(self, embedding_size, hidden_size, output_size, batch_size):\n        super(SpamClassifier, self).__init__()\n        \n        self.batch_size = batch_size\n        self.hidden_size = hidden_size\n        self.lstm = nn.LSTM(embedding_size, hidden_size)\n        self.linear = nn.Linear(hidden_size, output_size)\n        self.sigmoid = nn.Sigmoid()\n        \n    def forward(self, embeddings, hidden):\n        output, hidden = self.lstm(embeddings.view(len(inputs), self.batch_size, -1))\n        output = self.linear(output)\n        output = self.sigmoid(output)\n        \n        return output, hidden\n        \n    def init_hidden(self):\n        return (torch.zeros(1, self.batch_size, self.hidden_size), torch.zeros(1, self.batch_size, self.hidden_size))\n        ","107a549b":"nlp = spacy.load('en_core_web_lg')","cadb3a48":"processed_text = []\nfor course in dataset['text']:\n    doc = nlp(course.lower())\n    words = [word.lemma_ for word in doc if not word.is_punct | word.is_space | word.is_stop]\n    processed_text.append(words)","97fab556":"print(len(processed_text))\nfor i in range(5):\n    print(processed_text[i])\n","fffb3808":"def seq(sent):\n    inputs = []\n    for word in sent:\n        inputs.append(list(nlp(word).vector))\n        \n    return inputs","43aee9d5":"EMBEDDING_SIZE = 300\nHIDDEN_SIZE = 100\nOUTPUT_SIZE = 1\nBATCH_SIZE = 1\n\nmodel = SpamClassifier(EMBEDDING_SIZE, HIDDEN_SIZE, OUTPUT_SIZE, BATCH_SIZE)","67d2d70d":"model","03f7550e":"lr = 1e-3\ncriterion = nn.BCELoss()\noptimizer = optim.Adam(model.parameters(), lr)","cd370499":"with torch.no_grad():\n    inputs = seq(processed_text[0])\n    inputs = torch.tensor(inputs, dtype=torch.float)\n    hidden = model.init_hidden()\n    outputs, hidden = model(inputs,hidden)\n    print(outputs[-1])","6707ad7a":"train_loss = []\nval_loss = []","4367a9ba":"EPOCHS = 1\nhidden = model.init_hidden()\n\nfor epoch in range(EPOCHS):\n    for i in range(len(train_x)):\n        inputs = seq(processed_text[i])\n        if len(inputs) >= 1:\n            inputs = torch.tensor(inputs, dtype=torch.float)       \n            target = types[i]\n            target = torch.tensor(target, dtype=torch.float)\n            outputs, hidden = model(inputs, hidden)\n            loss = loss_fn(outputs[-1].squeeze(), target)\n            train_loss.append(loss.item())\n            model.zero_grad()\n            loss.backward()\n            optimizer.step()\n    print(loss.item())\n    for i in range()\n","f6745854":"y_pred = []\ny_actual = []\nids = []\ntest_processed = processed_text[-len(test_x):]\ntest_types = types[-len(test_x):]\nfor i in range(500):\n    inputs = seq(test_processed[i])\n    inputs = torch.tensor(inputs, dtype=torch.float)\n    targets = test_types[i]\n    targets = torch.tensor(targets, dtype=torch.float)\n    outputs, h = model(inputs, hidden)\n    y_pred.append(outputs[-1].squeeze().item())\n    y_actual.append(targets)\n    ","c6c84205":"y_pred = [1 if i>=0.5 else 0 for i in y_pred]","4e07f440":"from sklearn.metrics import confusion_matrix\nconfusion_matrix(y_pred, y_actual)","fc1ade29":"# Encoding outputs","183bd467":"# Splitting the dataset","a666935c":"# Importing the dataset","522615f6":"# Preparing data","7c5e9f80":"#### Creating sequences","1a71cf68":"# Training","b93bb7a0":"# Defining Model","6dc75916":"# Importing the libraries"}}