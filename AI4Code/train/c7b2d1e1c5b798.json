{"cell_type":{"b7d82770":"code","b85ce033":"code","8a15219c":"code","1f910cc4":"code","f9207d23":"code","223b3559":"code","48f795ae":"code","fd86d8a8":"code","c76083c6":"code","e0e027e4":"code","bbc651ca":"code","6edbeae9":"code","fb43e400":"code","79ca35dd":"markdown","75e2523a":"markdown","b2708974":"markdown","78681b16":"markdown","f12b12df":"markdown","7e92364c":"markdown","af264e51":"markdown","143673af":"markdown"},"source":{"b7d82770":"import cv2 as cv\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import ndimage\nfrom skimage.color import rgb2gray\n","b85ce033":"image = plt.imread(\"..\/input\/1.jpeg\")\nimage.shape\nplt.imshow(image)","8a15219c":"gray = rgb2gray(image)\nplt.imshow(gray, cmap = 'gray')","1f910cc4":"gray.shape","f9207d23":"gray_r = gray.reshape(gray.shape[0]*gray.shape[1])\n# mean = gray_r.mean()\n# print(mean)\nfor i in range(gray_r.shape[0]):\n    if gray_r[i] > gray_r.mean():\n        gray_r[i] = 1\n    else:\n        gray_r[i] = 0\ngray = gray_r.reshape(gray.shape[0],gray.shape[1])\nret,thresh1 = cv.threshold(image,127,255,cv.THRESH_BINARY)\nret,thresh2 = cv.threshold(image,127,255,cv.THRESH_BINARY_INV)\nret,thresh3 = cv.threshold(image,127,255,cv.THRESH_TRUNC)\nret,thresh4 = cv.threshold(image,127,255,cv.THRESH_TOZERO)\nret,thresh5 = cv.threshold(image,127,255,cv.THRESH_TOZERO_INV)\n\ntitles = ['Mean','BINARY','BINARY_INV','TRUNC','TOZERO','TOZERO_INV']\nimages = [gray, thresh1, thresh2, thresh3, thresh4, thresh5]\n\nfor i in range(6):\n    plt.subplot(2,3,i+1),plt.imshow(images[i],'gray')\n    plt.title(titles[i])\n    plt.xticks([]),plt.yticks([])\nplt.show()","223b3559":"gray = rgb2gray(image)\ngray_r = gray.reshape(gray.shape[0]*gray.shape[1])\nfor i in range(gray_r.shape[0]):\n    if gray_r[i] > gray_r.mean():\n        gray_r[i] = 3\n    elif gray_r[i] > 0.5:\n        gray_r[i] = 2\n    elif gray_r[i] > 0.25:\n        gray_r[i] = 1\n    else:\n        gray_r[i] = 0\ngray_l = gray_r.reshape(gray.shape[0],gray.shape[1])\nsrc = cv.cvtColor(image, cv.COLOR_BGR2GRAY)\nret,th1 = cv.threshold(image,127,255,cv.THRESH_BINARY)\nth2 = cv.adaptiveThreshold(src,255,cv.ADAPTIVE_THRESH_MEAN_C,\\\n            cv.THRESH_BINARY,11,2)\nth3 = cv.adaptiveThreshold(src,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,\\\n            cv.THRESH_BINARY,11,2)\ntitles = ['Local Method', 'Global Thresholding (v = 127)',\n            'Adaptive Mean Thresholding', 'Adaptive Gaussian Thresholding']\nimages = [gray_l, th1, th2, th3]\nfor i in range(4):\n    plt.subplot(2,2,i+1),plt.imshow(images[i],'gray')\n    plt.title(titles[i])\n    plt.xticks([]),plt.yticks([])\nplt.show()","48f795ae":"#same image - \nimg = (plt.imread(\"..\/input\/1.jpeg\"))\/255 #dividing by 255 to bring the pixel values between 0 and 1\nprint(img.shape)\n# 3 is the number of channels","fd86d8a8":"'''Covert the image into 2-D array'''\nimg1 = img.reshape(img.shape[0]*img.shape[1], img.shape[2])\nimg1.shape","c76083c6":"'''Fit the k-means algo on our converted image'''\nfrom sklearn.cluster import KMeans\n\nkmeans = KMeans(n_clusters=4, random_state=0).fit(img1)\nimg2 = kmeans.cluster_centers_[kmeans.labels_]","e0e027e4":"cluster_img = img2.reshape(img.shape[0], img.shape[1], img.shape[2])\nplt.imshow(cluster_img)","bbc651ca":"img = cv.imread('..\/input\/1.jpeg')\ngray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)\nret, thresh = cv.threshold(gray, 0, 255, \n                            cv.THRESH_BINARY_INV +\n                            cv.THRESH_OTSU) \nplt.imshow(thresh, 'gray')","6edbeae9":"# Noise removal using Morphological \n# closing operation \nkernel = np.ones((5, 5), np.uint8) \nclosing = cv.morphologyEx(thresh, cv.MORPH_CLOSE, kernel, iterations = 2) \nopening = cv.morphologyEx(thresh, cv.MORPH_OPEN, kernel, iterations = 2)\n# Background area using Erosion \nbg1 = cv.erode(closing, kernel, iterations = 1) \n\n#Background using dilation\nbg2 = cv.dilate(closing, kernel, iterations = 1)\n\n#Background using opening\nbg3 = cv.erode(opening, kernel, iterations = 1) \nbg4 = cv.dilate(opening, kernel, iterations = 1) \ntitles = ['ErosionClose', 'DilationCLose', 'ErosionOpen', 'DilationOpen']\nimages = [bg1, bg2, bg3, bg4]\nfor i in range(4):\n    plt.subplot(2,2,i+1),plt.imshow(images[i],'gray')\n    plt.title(titles[i])\n    plt.xticks([]),plt.yticks([])\nplt.show()","fb43e400":"img = cv.imread('..\/input\/1.jpeg')\ngray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)\nret, thresh = cv.threshold(gray,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU)\n# noise removal\nkernel = np.ones((5,5),np.uint8)\nclosing = cv.morphologyEx(thresh, cv.MORPH_CLOSE, kernel, iterations = 2) \n# sure background area\nsure_bg = cv.dilate(closing,kernel,iterations=3)\n# Finding sure foreground area\ndist_transform = cv.distanceTransform(closing,cv.DIST_L2,5)\nret, sure_fg = cv.threshold(dist_transform,0.7*dist_transform.max(),255,0)\n# Finding unknown region\nsure_fg = np.uint8(sure_fg)\nunknown = cv.subtract(sure_bg,sure_fg)\n\n# Marker labelling\nret, markers = cv.connectedComponents(sure_fg)\n# Add one to all labels so that sure background is not 0, but 1\nmarkers = markers+1\n# Now, mark the region of unknown with zero\nmarkers[unknown==255] = 0\n\nmarkers = cv.watershed(img,markers)\nimg[markers == -1] = [255,0,0]\n#plt.imshow(markers)\nplt.imshow(img)","79ca35dd":"Now for the adaptive thresholding methods, if an image has different lighting in different areas, the global thresholding may not provide a good enough insight.\n\n**Adaptive Threshold methods work only on the gray-scale images**","75e2523a":"A good enough try :(, but at least better than morphological functions :).\n\nNext version- \nUsing R-CNN, Mask-RCNN","b2708974":"Now let's set a Threshold value to distinguish our image into foreground and background. Acc. to Wikipedia- The simplest thresholding methods replace each pixel in an image with a black pixel if the image intensity I(i,j) is less than some fixed value T, or into a white pixel if the I(i, j) is more than some fixed value T. Trying various methods for thresholing:\n\n1. mean of the pixel values as the Threshold\n2. cv2 global thresholding methods\n3. local thresholding\n4. cv2 adaptive thresholding methods","78681b16":"k-means gives impressive results with small datasets, but when the dataset increases, it hits a roadblock.\n\n***Next Technique- using morphological operations Erosion and Dilation***","f12b12df":"Image Segmentation based on k-means clustering-\n\nAssign the points to the clusters which are closest to them.\nHow does k-means clustering works-\n\n1. We select a random number,k initial clusters.\n2. We assign the data points to any of the clusters randomly.\n3. We calculate the centre of the clusters.\n4. We calculate the distance of the points from each of the clusters, and assign the point to the nearest cluster.\n5. We then repeat the steps and find the center until the cenetr does not change or we run out of iterations.","7e92364c":"So, as you can see we have messed up the image when we use Opening Morphological function. Now, lets try Watershed Algo.-","af264e51":"## Image Segmentation\n\nI really hope that this kernel is helpful to someone out there, who is just starting to grasp the concepts of image-processing and also to the pros to give a quick revision.\n\nImage Segmentation- As the name suggests, partitioning of the image into different segments, to help with various operations on the images.\n\n***Lets just dive into the code*** ","143673af":"'cluster_centers' function returns us the centers of the clusters,\n'labels_' function tells us pixel belongs to which cluster"}}