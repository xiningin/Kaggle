{"cell_type":{"22c0079a":"code","a8eea0e5":"code","671ac854":"code","d52635f5":"code","a5049e79":"code","906c8eae":"markdown","e96496c5":"markdown","346273ab":"markdown","5cde87b5":"markdown","3773e587":"markdown"},"source":{"22c0079a":"try:\n    import igraph # igraph is already preinstalled on kaggle, but not colab  \nexcept:    \n    !pip install python-igraph # Pay attention: not just \"pip install igraph\" \n    !pip install cairocffi # Module required for plots \n    import igraph # igraph is already preinstalled on kaggle, but not colab  \n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time \n\nfrom sklearn.neighbors import NearestNeighbors\nfrom sklearn.neighbors import kneighbors_graph\nfrom scipy.sparse.csgraph import minimum_spanning_tree\n\n","a8eea0e5":"import igraph\n#n = 5242;  m = 14484\n#n = 5 ; k = 2  \ndef create_toy_knn_graph(n,k):\n  g = igraph.Graph( directed=True)#  G = snap.TUNGraph.New(n,m) # Allocate memory for UNdirected graph n-nodes, m-edges\n  g.add_vertices(n)\n  \n  for i in range(n): # Add m edges connected at random \n    list_target_nodes = []\n    while True: # technical loop - check we are not adding already existing edges \n      v2 = np.random.randint(0,n )\n      if i == v2:         continue\n      if v2 in list_target_nodes:   continue\n      list_target_nodes.append(v2)\n      g.add_edge(i,v2)\n      if len(list_target_nodes) >= k: \n        break\n  return g\n\nn = 45 ; k = 1 \ng =  create_toy_knn_graph(n,k)\nh = g.degree_distribution(bin_width=1, mode = \"out\", )\n#print(h)\n\nprint(\" Random graph is created by the rule - each node has one random out-going edge to other node. As you can see from the plots typically the graph falls into one connected component or one big and 1-2 small\" )\n\nr = g.clusters(mode='WEAK') # Returns list of lists like [ [1,2],[3,4]] - means [1,2] - first connected comp., [3,4] - second , here 1,2,3,4 - nodes ids\nlist_components_sizes = [ len(t) for t in r  ]\nprint(\"Sizes of connected components\")\nprint(list_components_sizes)\n            \nigraph.plot(g, bbox = (600,500))","671ac854":"\nk = 1\nfor n in [1e1, 1e3,1e4,1e5]:\n    n = int(n)\n    t0 = time.time()\n    g =  create_toy_knn_graph(n,k)\n    r = g.clusters(mode='WEAK') # Returns list of lists like [ [1,2],[3,4]] - means [1,2] - first connected comp., [3,4] - second , here 1,2,3,4 - nodes ids\n    print(\"n_nodes = \", n, \"seconds passed\", time.time()-t0,  \"Connected component sizes:\" )\n    list_components_sizes = [ len(t) for t in r  ]\n    print(list_components_sizes)\n    print()","d52635f5":"dim = 100\n        \nt0 = time.time()    \nc = 0        \nfor n in [1e4]:\n    n = int(n)    \n    X = np.random.randn(n, dim)\n    print(\"Dimension\",dim,\" n \", n)\n    nbrs = NearestNeighbors(n_neighbors=2  ).fit(X) # 'ball_tree'\n    distances, indices = nbrs.kneighbors(X)\n    g = igraph.Graph( directed = True )\n    g.add_vertices(range(n))\n    g.add_edges(indices )\n    r = g.clusters(mode='WEAK') # Returns list of lists like [ [1,2],[3,4]] - means [1,2] - first connected comp., [3,4] - second , here 1,2,3,4 - nodes ids\n    list_components_sizes = [ len(t) for t in r  ]\n    print(\"10 largest components sizes\")\n    print(np.sort(list_components_sizes)[::-1][:10])    \n    print(\"Maximum size of the connected component\")\n    print(np.max(list_components_sizes)    )\n    print(time.time() - t0 , \"seconds passed\" )\n    plt.hist(list_components_sizes)\n    plt.title(\"Histogram of components sizes\")\n    plt.show()","a5049e79":"dim = 2\n        \nt0 = time.time()    \nc = 0        \nfor n in [1e2]:\n    n = int(n)    \n    X = np.random.randn(n, dim)\n    print(\"Dimension\",dim,\" n \", n)\n    nbrs = NearestNeighbors(n_neighbors=2  ).fit(X) # 'ball_tree'\n    distances, indices = nbrs.kneighbors(X)\n    g = igraph.Graph( directed = True )\n    g.add_vertices(range(n))\n    g.add_edges(indices )\n    r = g.clusters(mode='WEAK') # Returns list of lists like [ [1,2],[3,4]] - means [1,2] - first connected comp., [3,4] - second , here 1,2,3,4 - nodes ids\n    list_components_sizes = [ len(t) for t in r  ]\n    print(\"10 largest components sizes\")\n    print(np.sort(list_components_sizes)[::-1][:10])    \n    print(\"Maximum size of the connected component\")\n    print(np.max(list_components_sizes)    )\n    print(time.time() - t0 , \"seconds passed\" )\n    plt.hist(list_components_sizes)\n    plt.title(\"Histogram of components sizes\")\n    plt.show()\n    \n    \nigraph.plot(g)    ","906c8eae":"# Example small n=45 and plot","e96496c5":"# Actual 1-NN graphs do NOT have \"giant component\" phenomena\n\nGenerate some data cloud - say  Gaussian d-dimensional sample,\nconstruct 1-Nearest neigbour graph\n(https:\/\/en.wikipedia.org\/wiki\/Nearest_neighbor_graph )\n\nWe will see NO giant component phenomenta, i.e. graph has many connected components, and the largest size is not big comparing with the others neigbour sizes, and quite small comparing with total node number\n\nFor example  for the case above we have seen largest component size  9800 for 10 000 nodes, but in simulation below we will see 288 for 10 000 nodes,\n9800 vs 288 is strikind difference.\n\nActually number of connected components for nearest neigbour graphs grows approximately linearly with sample size, moreover coefficient of linear dependence is theoretically known\n(from 1997 ) for dimension 2. There is also theoretical proposal for higher dimensions https:\/\/cstheory.stackexchange.com\/a\/47039\/2408 , but it is not yet fit with simulation results (June 2020).\n**\n","346273ab":"# What is about ? \n\nExamples for \"giant connected component\" phenomena are given here.\nhttps:\/\/en.wikipedia.org\/wiki\/Giant_component\n\nIt is dicussed in Lecture 2 slides 20 (MSN), 23 (PPI), 33 (Erdos-Renyi)  http:\/\/web.stanford.edu\/class\/cs224w\/slides\/02-gnp-smallworld.pdf\n\nGiant connected component phenomena occurs for some random graphs like Erdos-Renyi and real life networks like web.\nIt means that most of nodes of graph are connected with each other, and only small part of nodes falls into several much smaller by size connected components.\n\nHere we will consider the simplest version of graph where each point has one outgoing edge.\nIt is NOT Erdos-Renyi.  It is rather a model of the nearest-neigbour graph in degenerate situation where all points on the same distance, so one just randomly choose neigbour.\n\n\nFinally the example of real nearest neigbour graph is considered and there is NO giant component phenomena for it.\n\n\nPreliminary draft \nAlexander Chervov July 2020\n","5cde87b5":"# Example statistics for large n = 1000, 10 000, 100 000\n\n\nHere are examples (each run generates different number but phenomena does not change) : \n\nn_nodes =  1000 Connected component sizes:\n[355, 79, 90, 359, 94, 10, 9, 4]\n\nn_nodes =  10000 Connected component sizes:\n[9800, 197, 3]\n\nn_nodes =  100000 Connected component sizes:\n[98714, 1246, 40]\n\nwe can see that always largest component size **is much much large than the second size**, especially for larger graphs\n\n","3773e587":"# Plotting graph example with small number of points - 100 for NN graph, it is striking different from the model above"}}