{"cell_type":{"8ca7c592":"code","2af0580a":"code","01cfe9a1":"code","d8c0646a":"code","43f2ce73":"code","14f7d79a":"code","06444600":"code","4a06eae1":"code","d96e90e9":"code","95b8be62":"code","ed79bbc9":"code","48329c7b":"code","da365987":"code","0da4ab39":"code","61a91648":"code","d8a3a00d":"code","c35a424f":"code","6c4f2b39":"markdown","c69c68d9":"markdown","f9bdcc2c":"markdown","06abfff8":"markdown","1d75958b":"markdown","b7f87530":"markdown","601f1fbd":"markdown","0b296851":"markdown"},"source":{"8ca7c592":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom sklearn.preprocessing import StandardScaler\n\nfrom keras.models import Sequential, Model\nfrom keras.layers import Dense, BatchNormalization, Dropout, Flatten, Input\nfrom keras import backend as K\nimport keras\nfrom matplotlib.colors import LogNorm","2af0580a":"folder_path = '\/kaggle\/input\/ieee-fraud-detection\/'","01cfe9a1":"train = pd.read_csv(f'{folder_path}train_transaction.csv')\ntest = pd.read_csv(f'{folder_path}test_transaction.csv')","d8c0646a":"cats = ['ProductCD',\n    'card1',\n    'card2',\n    'card3',\n    'card4',\n    'card5',\n    'card6',\n    'P_emaildomain',\n    'R_emaildomain',\n    'M1',\n    'M2',\n    'M3',\n    'M4',\n    'M5',\n    'M6',\n    'M7',\n    'M8',\n    'M9',\n    'addr1',\n    'addr2']\n\ncols = list(train.columns)[3:]\nnocats = [c for c in cols if (not c in cats)]","43f2ce73":"%%time\nss = StandardScaler(copy=False)\ndata_ss = ss.fit_transform(np.nan_to_num(train[nocats].values))","14f7d79a":"n_features = data_ss.shape[1]\n\ndim = 15\n\ndef build_model(dropout_rate=0.15, activation='tanh'):\n    main_input = Input(shape=(n_features, ), name='main_input')\n    \n    x = Dense(dim*2, activation=activation)(main_input)\n    x = BatchNormalization()(x)\n    x = Dropout(dropout_rate)(x)\n    \n    x = Dense(dim*2, activation=activation)(x)\n    x = BatchNormalization()(x)\n    x = Dropout(dropout_rate\/2)(x)\n    \n    x = Dense(dim, activation=activation)(x)\n    x = Dropout(dropout_rate\/4)(x)\n\n    encoded = Dense(2, activation='tanh')(x)\n\n    input_encoded = Input(shape=(2, ))\n    \n    x = Dense(dim, activation=activation)(input_encoded)\n    x = Dense(dim, activation=activation)(x)\n    x = Dense(dim*2, activation=activation)(x)\n    \n    decoded = x = Dense(n_features, activation='linear')(x)\n\n    encoder = Model(main_input, encoded, name=\"encoder\")\n    decoder = Model(input_encoded, decoded, name=\"decoder\")\n    autoencoder = Model(main_input, decoder(encoder(main_input)), name=\"autoencoder\")\n    return encoder, decoder, autoencoder\n\nK.clear_session()\nc_encoder, c_decoder, c_autoencoder = build_model()\nc_autoencoder.compile(optimizer='nadam', loss='mse')\n\nc_autoencoder.summary()","06444600":"data_ss = np.clip(data_ss, -10, 10)","4a06eae1":"%%time\nepochs = 50\nbatch_size = 9548\nhistory = c_autoencoder.fit(data_ss, data_ss,\n                    epochs=epochs,\n                    batch_size=batch_size,\n                    shuffle=True,\n                    verbose=1)\n\nloss_history = history.history['loss']\nplt.figure(figsize=(10, 5))\nplt.plot(loss_history);","d96e90e9":"%%time\nemb = c_encoder.predict(data_ss)","95b8be62":"plt.figure(figsize=(10, 10))\nplt.hist2d(emb[:, 0], emb[:, 1], bins=256, norm=LogNorm());","ed79bbc9":"plt.figure(figsize=(20, 20))\nplt.scatter(emb[:, 0], emb[:, 1], c=train['isFraud'].values,\n           marker='.', alpha=0.1);","48329c7b":"plt.figure(figsize=(20, 20))\nplt.scatter(emb[:, 0], emb[:, 1], c=train['TransactionDT'].values,\n           marker='.', alpha=0.1, cmap='jet');","da365987":"prd_d = {p: i for i, p in enumerate(train['ProductCD'].unique())}","0da4ab39":"plt.figure(figsize=(20, 20))\nplt.scatter(emb[:, 0], emb[:, 1],\n            c=train['ProductCD'].apply(lambda x: prd_d[x]).values,\n           marker='.', alpha=0.1, cmap='jet');","61a91648":"%%time\ntest_ss = ss.transform(np.nan_to_num(test[nocats].values))","d8a3a00d":"%%time\ntest_emb = c_encoder.predict(test_ss)","c35a424f":"plt.figure(figsize=(20, 20))\nplt.scatter(test_emb[:, 0], test_emb[:, 1],\n            c=test['TransactionDT'].values,\n           marker='.', alpha=0.1, cmap='jet');","6c4f2b39":"# What about test?\nAll the same.","c69c68d9":"### How fraudent transactions is distributed?\nLooks like fraud is distributed almost like normal transactions, but there is some regions where fraudent transactions appear more often.","f9bdcc2c":"### What causes clustering?\nColouring by ProductCD gives answer for this question. Remember that categorical features was not included in visualization. It means that numerical features distribution in different categories is different. I think, we need to separate models for different ProductCD.","06abfff8":"### Is there time leak in numerical features?\nObviously there is information about time.","1d75958b":"### Model\nTanh in the output of the decoder is good choice for visualisation: all objects will be projected on square from -1 to 1.","b7f87530":"# Let's look at 2d density\nIt seems like there is some clusters","601f1fbd":"# THAT'S ALL, FOLKS!","0b296851":"# Prepare data and model\nI use only numeric cols. In order to use categorical features we need to get their embeddings first. \nTime and ID is not included, because I want to check is there information about time in other features."}}