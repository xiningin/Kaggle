{"cell_type":{"2ec20441":"code","8117da44":"code","95485471":"code","2dae247c":"code","d534b725":"code","23d8fff3":"code","79139976":"code","29ed1062":"code","2b0b236c":"code","64729064":"code","8a37794e":"code","9ca88284":"code","3743c48d":"code","c990a81b":"code","073c8f05":"code","01c0c4c6":"code","47d69430":"code","d830e528":"code","63da2a02":"code","13ad46af":"code","ae788671":"code","ff7b3252":"code","0a509125":"code","82e07c53":"code","7eeec46f":"code","2f858f4e":"code","03afe046":"code","66630dde":"code","3aafe9ba":"code","e1b3b56d":"code","59fead59":"code","94fea61e":"code","f8856224":"code","2640ca47":"code","3b297a39":"code","a258abc9":"code","10e87803":"code","3041ea3f":"markdown","a6967182":"markdown"},"source":{"2ec20441":"# !pip install torchsummary","8117da44":"import pandas as pd\nimport numpy as np\nimport random\nimport math\n\nimport os\nimport tqdm\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\n\nfrom IPython.display import display\n\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nfrom torch.utils.data.sampler import SubsetRandomSampler\nimport torch.nn as nn\nimport torch.optim as optim\nimport torchvision.transforms as transforms\nfrom torchvision.models import vgg19\n\n# from torchsummary import summary\n\nfrom pathlib import Path\nimport PIL\nfrom PIL import Image\n\n\n\n","95485471":"def seed_all(seed):\n    \"\"\"Utility function to set seed across all pytorch process for repeatable experiment\n    \"\"\"\n    if not seed:\n        seed = 10\n\n    print(\"[ Using Seed : \", seed, \" ]\")\n\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.cuda.manual_seed(seed)\n    np.random.seed(seed)\n    random.seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\nseed_all(100)","2dae247c":"def seed_worker(worker_id):\n    \"\"\"Utility function to set random seed for DataLoader\n    \"\"\"\n    worker_seed = torch.initial_seed() % 2**32\n    numpy.random.seed(worker_seed)\n    random.seed(worker_seed)","d534b725":"data_dir = Path(\"..\/input\/landmark-recognition-2021\/\")\ntrain_dir = data_dir \/ \"train\"\ntest_dir = data_dir \/ \"test\"\ntrain_file = data_dir \/ \"train.csv\"\nsub_file = data_dir \/ \"sample_submission.csv\"","23d8fff3":"train_df = pd.read_csv(train_file)\nsub_df = pd.read_csv(sub_file)","79139976":"display(train_df.head())\ndisplay(sub_df.head())","29ed1062":"## landmark_id value > number of classes, this leads to error during training pytorch model\nlandmark_id_map = {lid:i for i, lid in enumerate(train_df.landmark_id.unique())}\ntrain_df['landmark_id'] = train_df['landmark_id'].map(landmark_id_map)","2b0b236c":"## Building a custom data loader to load the data in batches for pytorch\n\nclass LandMarkData(Dataset):\n    \n    def __init__(self, data_file, data_dir, transform=None, data_type=\"train\"):\n        \"\"\"\n        data_file str: file which contains image_id and its class\n        data_dir str: directory where data is present\n        \"\"\"\n        \n        self.data_file = pd.read_csv(data_file)\n        ## landmark_id value > number of classes, this leads to error during training pytorch model\n        if data_type == \"train\":\n            self.landmark_id_map = {lid:i for i, lid in enumerate(self.data_file.landmark_id.unique())}\n            self.data_file['landmark_id'] = self.data_file['landmark_id'].map(self.landmark_id_map)\n        elif data_type == \"test\":\n            print(\"Test data will not have landmarkd id, hence no mapping\")\n        self.data_dir = data_dir\n        self.transform = transform\n    \n    def __len__(self):\n        return len(self.data_file)\n    \n    def __getitem__(self, idx):\n        if torch.is_tensor(idx):\n            idx = idx.tolist()\n        img_id = self.data_file.iloc[idx, 0]\n        img_class = self.data_file.iloc[idx, 1]\n        img_path = os.path.join(self.data_dir, img_id[0], img_id[1], img_id[2], f'{img_id}.jpg')\n        img = Image.open(img_path)\n        if self.transform is not None:\n            img = transform(img)\n        sample = [img, img_class, img_id]\n        \n        return sample","64729064":"## define basic transforms\n\ntransform = transforms.Compose([ transforms.CenterCrop(224), \n                               transforms.ToTensor()])","8a37794e":"train_data = LandMarkData(train_file, train_dir, transform, \"train\")\ntest_data = LandMarkData(sub_file, test_dir, transform, \"test\")","9ca88284":"## Manually Checking if dataloader and transforms are getting applied or not.\n## All images should be 224*224\nprint(f\"Image Shape               || Image Class|| Image Id\")\nprint(\"-\"*60)\nsamples = train_df['id'].sample(10, random_state=100).index\nfor sample in samples:\n    img_sample = train_data[sample]\n    print(f\"{img_sample[0].shape} || {img_sample[1]}      || {img_sample[2]}\")","3743c48d":"## Manually Checking if dataloader and transforms are getting applied or not.\n## All images should be 224*224\nprint(f\"Image Shape               || Image Class|| Image Id\")\nprint(\"-\"*60)\nsamples = sub_df['id'].sample(10, random_state=100).index\nfor sample in samples:\n    img_sample = test_data[sample]\n    print(f\"{img_sample[0].shape} || {img_sample[1]} || {img_sample[2]}\")","c990a81b":"## Taking 20% as valid data\nvalid_size = 0.2\nbatch_size = 8","073c8f05":"## Splitting train data into valid data. Please note this is vanila split, \n# we need to have better split or agumentation as many landmarks have very few images\nnum_train = len(train_data)\nindices = list(range(num_train))\nnp.random.seed(100)\nnp.random.shuffle(indices)\nsplit = int(np.floor(num_train*valid_size))\nvalid_idx, train_idx = indices[:split], indices[split:]\nassert len(valid_idx) + len(train_idx) == num_train","01c0c4c6":"train_sampler = SubsetRandomSampler(train_idx)\nvalid_sampler = SubsetRandomSampler(valid_idx)\ntrain_loader = DataLoader(train_data, batch_size=batch_size, sampler=train_sampler, num_workers=0, worker_init_fn=seed_worker)\nvalid_loader = DataLoader(train_data, batch_size=batch_size, sampler=valid_sampler, num_workers=0, worker_init_fn=seed_worker)\ntest_loader = DataLoader(test_data, batch_size=batch_size, num_workers=0, worker_init_fn=seed_worker)","47d69430":"def plot_images(loader, num_images=5):\n    images, label, img_id = next(iter(loader))\n    # convert to numpy and transpose as (Batch Size, Height, Width, Channel) as needed by matplotlib\n    images = images.numpy().transpose(0, 2, 3, 1)\n    \n    # Analysing images of a train batch\n    num_cols = 5\n    num_rows = 1\n    if num_images > 5:\n        num_cols = 5\n        num_rows = math.ceil(num_images \/ 5)\n    np.random.seed(100)\n    indices = np.random.choice(range(len(label)), size=num_images, replace=False)\n    width = 20\n    height = 5*num_rows\n    plt.figure(figsize=(width, height))\n    for i, idx in enumerate(indices):\n        plt.subplot(num_rows, num_cols, i + 1)\n        image = images[idx]\n        plt.imshow(image);\n        plt.title(f'label: {label[idx]}\\n img_id: {img_id[idx]}');\n        plt.axis(\"off\")\n    plt.show()\n","d830e528":"#plotting one batch of images from train\nplot_images(train_loader, batch_size)","63da2a02":"#plotting one batch images from valid\nplot_images(valid_loader, batch_size)","13ad46af":"plot_images(test_loader, batch_size)","ae788671":"def get_pretrained_model(model_name=vgg19, num_class=10, use_gpu=False):\n    \"\"\" Wrapper function to get pre-trained model \n    \"\"\"\n    model_transfer = model_name(pretrained=True)\n    for params in model_transfer.features.parameters():\n        params.requires_grad=False\n\n    in_features = model_transfer.classifier[6].in_features\n    last_layer = nn.Linear(in_features, num_class)\n    model_transfer.classifier[6] = last_layer\n    if use_gpu:\n        model_transfer.cuda()\n    return model_transfer","ff7b3252":"use_cuda = torch.cuda.is_available()","0a509125":"model = get_pretrained_model(vgg19, train_df.landmark_id.nunique(), use_cuda)","82e07c53":"## Checking model summary using torchsummary\n# summary(model, (3,224,224))","7eeec46f":"# Using Vanilla CrossEntropyLoss, it would be better to give the weight for each class due to high imbalance\ncriteria = nn.CrossEntropyLoss()\noptimizer = optim.Adam(model.parameters(), lr=0.001)","2f858f4e":"loaders = {'train': train_loader, 'valid': valid_loader, 'test': test_loader}","03afe046":"save_path = \"..\/working\/\"","66630dde":"from time import time","3aafe9ba":"def train(n_epochs, loaders, model, optimizer, criterion, use_cuda, save_path, num_batch=1, verbose=False):\n    \"\"\"returns trained model\"\"\"\n    # initialize tracker for minimum validation loss\n    valid_loss_min = np.Inf \n    \n    for epoch in range(1, n_epochs+1):\n        # initialize variables to monitor training and validation loss\n        train_loss = 0.0\n        valid_loss = 0.0\n        start_time = time()\n        \n        ###################\n        # train the model #\n        ###################\n        # set the module to training mode\n        model.train()\n#         import pdb; pdb.set_trace()\n        for batch_idx, (data, target, img_id) in enumerate(loaders['train']):\n            # move to GPU\n            if use_cuda:\n                data, target = data.cuda(), target.cuda()\n\n            ## TODO: find the loss and update the model parameters accordingly\n            ## record the average training loss, using something like\n            ## train_loss = train_loss + ((1 \/ (batch_idx + 1)) * (loss.data.item() - train_loss))\n            optimizer.zero_grad()\n            out = model(data)\n            loss = criterion(out, target)\n            loss.backward()\n            optimizer.step()\n            train_loss = train_loss + ((1 \/ (batch_idx + 1)) * (loss.data.item() - train_loss))\n            train_loss += loss.data.item()*data.size(0)\n            if verbose:\n                print(f\"idx: {batch_idx} Train Loss:{train_loss\/(data.size(0) * (batch_idx + 1)) : .6f}\")\n            if batch_idx > num_batch:\n                train_images_used = data.size(0)*(batch_idx + 1)\n                break\n\n            \n        torch.cuda.empty_cache()\n        ######################    \n        # validate the model #\n        ######################\n        # set the model to evaluation mode\n        model.eval()\n        for batch_idx, (data, target, img_id) in enumerate(loaders['valid']):\n            # move to GPU\n            if use_cuda:\n                data, target = data.cuda(), target.cuda()\n\n            ## TODO: update average validation loss \n            out = model(data)\n            loss = criterion(out, target)\n            valid_loss += loss.data.item()*data.size(0) \n            if verbose:\n                print(f\"idx: {batch_idx} Valid Loss:{valid_loss \/ (data.size(0) * (batch_idx + 1)) : .6f}\")\n            if batch_idx > num_batch:\n                valid_images_used = data.size(0)*(batch_idx + 1)\n                break\n        train_loss = train_loss\/ train_images_used\n        valid_loss = valid_loss \/ valid_images_used\n\n            \n            \n        end_time = time()\n        time_taken = end_time - start_time\n        # print training\/validation statistics \n        print('Epoch: {} \\t Time: {:.2f} \\tTraining Loss: {:.6f} \\tValidation Loss: {:.6f}'.format(\n            epoch, \n            time_taken,\n            train_loss,\n            valid_loss\n            ))\n\n        ## TODO: if the validation loss has decreased, save the model at the filepath stored in save_path\n        if valid_loss < valid_loss_min:\n            if verbose:\n                print(f\"Valid loss reduced from {valid_loss_min :.6f} to {valid_loss :.6f}, saving model\")\n            valid_loss_min = valid_loss\n            torch.save(model.state_dict(), save_path)\n              \n    return model","e1b3b56d":"import tqdm","59fead59":"def predict(loaders, model, use_cuda, landmark_reverse_map):\n    \n    \n    # set the module to evaluation mode\n    model.eval()\n    sf = nn.Softmax(dim=1)\n    img_id_list = []\n    confidence_list = []\n    label_list = []\n    tot_batch = len(loaders['test'])\n    for batch_idx, (data, _, img_id) in enumerate(tqdm.tqdm(loaders['test'])):\n        # move to GPU\n        if use_cuda:\n            data = data.cuda()\n        # forward pass: compute predicted outputs by passing inputs to the model\n        output = model(data)\n        output = sf(output)\n        output = torch.max(output, dim=1)\n        confidence = output[0].cpu().detach().numpy()\n        label=output[1].cpu().detach().numpy()\n        \n        img_id_list.extend(list(img_id))\n        confidence_list.extend(confidence.tolist())\n        label_list.extend(label.tolist())\n    \n    predict_df = pd.DataFrame({'id': img_id_list, \n                               'landmarks': label_list, \n                               'conf': confidence_list})\n    predict_df['landmarks'] = predict_df['landmarks'].map(landmark_reverse_map)\n    predict_df['landmarks'] = predict_df['landmarks'].astype(str) +\" \" + predict_df['conf'].round(6).astype(str)\n\n    predict_df.drop(\"conf\", axis=1, inplace=True)\n    return predict_df\n        \n\n        \n        ","94fea61e":"# data is huge, running 1000 batches for 10 epoch, with an assumption that atleast model will see each class once\n\nnum_epochs = 20\nmodel_transfer = train(num_epochs, loaders, model, optimizer, \n                      criteria, use_cuda, os.path.join(save_path,'model_transfer.pt'),num_batch=10, verbose=False)","f8856224":"# Loading the best model\nmodel.load_state_dict(torch.load(os.path.join(save_path,'model_transfer.pt')))","2640ca47":"landmark_reverse_map = dict(zip(train_data.landmark_id_map.values(), train_data.landmark_id_map.keys()))","3b297a39":"out = predict(loaders, model, use_cuda, landmark_reverse_map)","a258abc9":"display(out.tail())","10e87803":"out.to_csv(\"submission.csv\")","3041ea3f":"In this notebook, we perform below steps to understand the modeling challenges\n1. Create custom data loader. \n    \n    This is required to read id from train.csv and then load the image, transform it. We also re-do the class labels, as class id is greater than number of unique classes\n\n2. Custom function to visulaize images of one batch\n3. Function to create pre-trained model\n4. Training loop\n\nDue to huge amount of data, its difficult to complete training for one epoch. We probably need some data cleaning to reduce the number of images being sent to training","a6967182":"Post plotting images from test set, where out of 8 images probably 4 are for landmark and rest are human faces and fish, this shows that lot of images in test data are out of sample. Hence, even before we predict on test set, we need to run some similarity check and not predict for out of sample images"}}