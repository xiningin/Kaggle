{"cell_type":{"09fb6cfc":"code","71902e55":"code","aef477cd":"code","c0a6997c":"code","1261ac37":"code","3c4ebe8b":"code","b406ab65":"code","d4e5364f":"code","ff12634f":"code","0ee14620":"code","efa03f4a":"code","89c20e77":"code","1dee2dad":"code","c205a95f":"code","dca5c9b3":"code","cc4eefac":"code","390bb315":"code","9418bcd7":"code","4c0062fc":"code","d57d4ec5":"code","44d69a1b":"code","fa6b305c":"code","43932f70":"code","93e7736d":"code","9a5ed44b":"code","1b381345":"code","926105b5":"code","ffbbb9de":"markdown","f3694172":"markdown","8fed2b8d":"markdown","f5506513":"markdown","ba592bc4":"markdown","402c3e75":"markdown","1be33339":"markdown","ec3d5a01":"markdown","90077bd0":"markdown","88565c33":"markdown","52de44ba":"markdown","5bfdacb5":"markdown"},"source":{"09fb6cfc":"import pandas as pd\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import KFold, StratifiedKFold, GroupKFold\nfrom tqdm import tqdm_notebook as tqdm\nimport datetime\nfrom sklearn.metrics import roc_auc_score\nimport xgboost as xgb\nimport gc\nimport os\n\n\n\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","71902e55":"train = pd.read_csv(\"..\/input\/cat-in-the-dat-ii\/train.csv\")\ntest = pd.read_csv(\"..\/input\/cat-in-the-dat-ii\/test.csv\")","aef477cd":"train.head()","c0a6997c":"test.head()","1261ac37":"train.loc[:,['ord_1', 'ord_2', 'ord_3', 'ord_4', 'ord_5']]","3c4ebe8b":"def ret_ord_1(ord_1_data):\n    \"\"\"\n    convert index from sorted ord_1 data.\n    if data is np.nan, return -1.\n    \"\"\"\n    try:\n        if (math.isnan(ord_1_data)):\n            return -1 #np.nan\n    except TypeError:\n        ord_1_list = ['Novice', 'Contributor', 'Expert', 'Master', 'Grandmaster']\n        indexes = [ i for i in range(len(ord_1_list))]\n        num_index = ord_1_list.index(ord_1_data)\n        return indexes[num_index]","b406ab65":"def ret_ord_2(ord_2_data):\n    \"\"\"\n    convert index from sorted ord_2 data.\n    if data is np.nan, return -1.\n    \"\"\"\n    \n    try:\n        if math.isnan(ord_2_data):\n            return -1 #np.nan\n    \n    except TypeError:\n            ord_2_list = ['Freezing', 'Cold', 'Warm', 'Hot','Boiling Hot', 'Lava Hot']\n            indexes = [ i for i in range(len(ord_2_list))]\n            num_index = ord_2_list.index(ord_2_data)\n            return indexes[num_index]","d4e5364f":"def ret_ord_3(ord_3_data):\n    \"\"\"\n    convert index from sorted ord_3 data.\n    if data is np.nan, return -1.\n    \"\"\"\n    try:\n        if math.isnan(ord_3_data):\n            return -1 #np.nan\n    \n    except TypeError:\n            ord_3_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o']\n            indexes = [ i for i in range(len(ord_3_list))]\n            num_index = ord_3_list.index(ord_3_data)\n            return indexes[num_index]","ff12634f":"def ret_ord_4(ord_4_data):\n    \"\"\"\n    convert index from sorted ord_4 data.\n    if data is np.nan, return -1.\n    \"\"\"\n    try:\n        if math.isnan(ord_4_data):\n            return -1 #np.nan\n    \n    except TypeError:\n            ord_4_list = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n            indexes = [ i for i in range(len(ord_4_list))]\n            num_index = ord_4_list.index(ord_4_data)\n            return indexes[num_index]","0ee14620":"def ret_ord_5(ord_5_data):\n    \"\"\"\n    convert index from sorted ord_5 data.\n    if data is np.nan, return -1.\n    \"\"\"\n    \n    try:\n        if math.isnan(ord_5_data):\n            return -1 #np.nan\n    \n    except TypeError:\n            ord_5_list = ['AG','AI','AU','AW','Ay','BL','BX','Bx','CN','CU','Cn','DI','DN','DR','DT','Dj','Dn',\n                          'EC','Ey','FB','FH','Fl','GZ','HF','HK','HO','Hk','IA','IS','Ib','In','Io','Iq','JQ',\n                          'JT','Ji','Kq','LS','LY','Lo','MF','MU','MV','MX','Mg','Mq','NS','NT','Nh','OM','OZ',\n                          'Oe','Ox','PG','PS','Pk','Pw','QV','Qm','RB','RD','RT','RV','Re','Rj','Ro','Rv','Rz',\n                          'SL','SS','Sk','Sz','TH','TL','TP','TZ','Tg','Ty','Tz','US','UV','WC','WW','Wr','XC',\n                          'XI','XM','XR','XU','YJ','Yb','Yi','Yr','Zv','aA','aE','al','be','cR','cY','cg','cy',\n                          'dh','dp','eA','eN','ep','fF','fO','fV','fe','gK','gL','gV','gc','gj','gt','hG','hT',\n                          'ht','hx','iS','iv','ja','jf','jp','kB','kP','kT','kv','lA','lR','lS','ly','mD','mP',\n                          'mX','mi','mo','nS','ne','nf','nj','nn','oI','oJ','oU','oh','ok','pB','pE','pT','pZ',\n                          'pl','qN','qP','rA','rM','rg','rl','sF','sY','sc','sf','tT','th','tn','uI','uP','uQ',\n                          'uW','uZ','ur','us','vQ','vq','vw','vx','wJ','wU','wa','xB','xF','xG','yE','yK','zc',\n                          'ze','zf','zp']\n            \n            ord_5_list = list(set([ i for i in ord_5_list]))\n            indexes = [ i for i in range(len(ord_5_list))]\n            num_index = ord_5_list.index(ord_5_data)\n            return indexes[num_index]\n","efa03f4a":"train['ord_1'] = train['ord_1'].map(ret_ord_1)\ntrain['ord_2'] = train['ord_2'].map(ret_ord_2)\ntrain['ord_3'] = train['ord_3'].map(ret_ord_3)\ntrain['ord_4'] = train['ord_4'].map(ret_ord_4)\ntrain['ord_5'] = train['ord_5'].map(ret_ord_5)","89c20e77":"train.loc[:,['ord_0','ord_1', 'ord_2', 'ord_3', 'ord_4', 'ord_5']]","1dee2dad":"test['ord_1'] = test['ord_1'].map(ret_ord_1)\ntest['ord_2'] = test['ord_2'].map(ret_ord_2)\ntest['ord_3'] = test['ord_3'].map(ret_ord_3)\ntest['ord_4'] = test['ord_4'].map(ret_ord_4)\ntest['ord_5'] = test['ord_5'].map(ret_ord_5)","c205a95f":"test.loc[:,['ord_0','ord_1', 'ord_2', 'ord_3', 'ord_4', 'ord_5']]","dca5c9b3":"cat_cols = [\"bin_3\", \"bin_4\", \"nom_0\", \"nom_1\", \"nom_2\", \"nom_3\", \"nom_4\", \"nom_5\", \"nom_6\", \n            \"nom_7\", \"nom_8\", \"nom_9\"]\nfor c in cat_cols:\n    le = LabelEncoder()\n    tmp = []\n    train[c][pd.isnull(train)[c]]= 'NaN'\n    test[c][pd.isnull(test)[c]]= 'NaN'\n    \n    \n    for i in train[c]:\n        tmp.append(i)\n    for i in test[c]:\n        tmp.append(i)\n        \n    \n    le.fit(tmp)\n    train[c] = le.transform(train[c])\n    test[c] = le.transform(test[c])\n    \n    del tmp\n    gc.collect()","cc4eefac":"from sklearn.preprocessing import StandardScaler\ncol_StandardScale=['bin_0','bin_1', 'bin_2', 'bin_3', 'bin_4', \n                   'nom_0','nom_1','nom_2', 'nom_3', 'nom_4', \n                   'nom_5','nom_6', 'nom_7', 'nom_8','nom_9' ,\n                   'ord_0', 'ord_1', 'ord_2','ord_3', 'ord_4', \n                   'ord_5', 'day', 'month']\nobj=StandardScaler()\ntrain[col_StandardScale]=obj.fit_transform(train[col_StandardScale])\ntest[col_StandardScale]=obj.transform(test[col_StandardScale])","390bb315":"train.head()","9418bcd7":"test.head()","4c0062fc":"categorical = ['bin_0', 'bin_1', 'bin_2', 'bin_3', 'bin_4', 'nom_0', 'nom_1',\n       'nom_2', 'nom_3', 'nom_4' ,'nom_5', 'nom_6','nom_7', 'nom_8', 'nom_9']\nnumeric_cols = [col for col in train.columns if col not in categorical + ['target','id']]\nfeatures = categorical + numeric_cols","d57d4ec5":"def search_XGBoost(max_depth,subsample,colsample_bytree,lr):\n    folds = 3\n    scores = []\n\n    kf = StratifiedKFold(n_splits=folds, shuffle=True)\n    for tr_idx, val_idx in tqdm(kf.split(train[features], train['target']), total = folds):\n        X_train = train[features].iloc[tr_idx] \n        y_train = train['target'].iloc[tr_idx]\n        X_test = train[features].iloc[val_idx]\n        y_test = train['target'].iloc[val_idx]\n    \n        model = xgb.XGBClassifier(objective ='binary:logistic',\n                      colsample_bytree = colsample_bytree,\n                      learning_rate = lr,\n                      max_depth = max_depth,\n                      n_estimators = 400,\n                      eta = 0.25,\n                      scale_pos_weight = 2,\n                      random_state = 2020,\n                      subsample = subsample)\n    \n        model.fit(X_train, y_train, eval_set=[(X_test, y_test)], verbose=False,)\n    \n        preds_val = model.predict_proba(X_test)[:,1]\n        score = roc_auc_score(y_test ,preds_val)\n        print(\"score: %f\" % (score))\n        scores.append(score)\n    \n    print(\"CV score: \",sum(scores)\/len(scores))\n    return sum(scores)\/len(scores)","44d69a1b":"max_depths =[16]#14, 16, 18, 20 ]\nsubsamples = [0.86]\ncolsample_bytrees = [0, 0.05, 0.1, 0.15]\nlrs = [0.25]\n\nmax_auc = 0\n\nfor i in max_depths:\n    for j in subsamples:\n        for k in colsample_bytrees:\n            for l in lrs:          \n                tauc = search_XGBoost(i, j, k, l)\n                print(\"max_depth,ubsample,colsample_bytree,learning_rate: \", i,j,k,l)\n                if max_auc < tauc:\n                    max_auc = tauc\n                    best_max_depths = i\n                    best_subsamples = j\n                    best_colsample_bytrees = k\n                    best_learning_rate = l","fa6b305c":"model = xgb.XGBClassifier(objective ='binary:logistic',\n                      colsample_bytree = best_colsample_bytrees,\n                      learning_rate = best_learning_rate,\n                      max_depth = best_max_depths,\n                      n_estimators = 400,\n                      eta=0.25,\n                      scale_pos_weight = 2,\n                      random_state = 2020,\n                      subsample = best_subsamples)\nmodel.fit(train[features], train['target'])","43932f70":"pred = model.predict_proba(test[features])[:,1]","93e7736d":"submit = pd.read_csv(\"..\/input\/cat-in-the-dat-ii\/sample_submission.csv\")","9a5ed44b":"submit[\"target\"] = pred","1b381345":"submit.head()","926105b5":"submit.to_csv(\".\/submit.csv\", index=False)","ffbbb9de":"**2. Label encording**\n\nI'll apply Label encording to \"bin_3\", \"bin_4\", \"nom_0\", \"nom_1\", \"nom_2\", \"nom_3\", \"nom_4\", \"nom_5\", \"nom_6\", \"nom_7\", \"nom_8\" and \"nom_9\".\nThese columns look categolical.","f3694172":"# Submit","8fed2b8d":"# Training & Prediction\n\nI refered https:\/\/www.kaggle.com\/drcapa\/categorical-feature-engineering-2-xgb for decide hyperparameters.\nThank you so mutch.","f5506513":"**1.Grid Search**","ba592bc4":"**3.Standard Scale**","402c3e75":"**2.Train Model for Prediction**","1be33339":"# Required Library","ec3d5a01":"**4.Check data for training & prediction.**","90077bd0":"**3.Prediction**","88565c33":"**1. Ordinal data**\n\nConvert Ordinal data to numbers representing order.\n\nBecause ord_0 looks already done, I'll try 'ord_1', 'ord_2', 'ord_3', 'ord_4' and 'ord_5'.","52de44ba":"# Preprocessing","5bfdacb5":"# Load data"}}