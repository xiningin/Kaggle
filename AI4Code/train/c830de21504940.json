{"cell_type":{"23baa69e":"code","1a949147":"code","f2e9fbe4":"code","52231f9e":"code","4cf14217":"code","ab0885e5":"code","e570c8f7":"code","cabc2e85":"code","897d9b45":"code","4c2ed9d7":"code","c9e28eb0":"code","89cdfe80":"code","2ea0c887":"code","9d2f4d5e":"code","5c764a85":"code","51cd26dd":"code","a12c913c":"code","b6704bb2":"code","360921ab":"code","a9a02a2e":"code","8ee8fd86":"code","2043e6d4":"code","963c2445":"code","37dd9a3f":"code","786c65d8":"code","c201d8c6":"code","8407a889":"code","1da28859":"code","f27c974e":"code","3ec6ca06":"code","ae3557d5":"code","297fd637":"code","a168b0f8":"code","a06ceaee":"code","f4c76ac6":"code","6f21acfb":"code","9fe68b6e":"code","6e41d4d4":"code","88ea8df0":"code","6c5818cf":"code","8e48ab12":"code","32ae7dd6":"code","1ca97e53":"code","f42202b2":"code","ae1f2068":"code","e71e0fa7":"code","1c00e5d9":"code","f692aefd":"code","38c1ea37":"code","9df9b794":"code","64c266b5":"code","984dca5a":"code","4c56ceb4":"code","c3362af7":"code","ea963068":"code","5f50e333":"code","71cfef2c":"code","13c0c809":"code","a1f839b0":"code","09bbe5b9":"code","767798b1":"code","e5d4a775":"code","7fd72439":"code","7f0d23b1":"code","de292b46":"code","75045762":"code","ee34355d":"code","23286f8c":"code","332b5199":"code","edecdb5c":"code","175fff08":"code","a706caf3":"code","65302a1a":"code","7a98f94d":"code","05b378ca":"code","b857f267":"code","704d2669":"code","527886d3":"code","fa4556ad":"code","d940ef00":"code","a513970b":"code","034978ef":"code","8141ee58":"code","f1c32427":"code","0e25dba6":"code","1e0ca903":"code","b0f25d90":"markdown","1ed55d61":"markdown","74238190":"markdown","13840a29":"markdown","3ae51088":"markdown","e2795977":"markdown","247a6783":"markdown","1b695e34":"markdown","af08183d":"markdown","c34c3905":"markdown","b3738821":"markdown","c525042a":"markdown","eafbd67b":"markdown","030a646c":"markdown","5518bab6":"markdown","2d36adb7":"markdown","784855f9":"markdown","93666b67":"markdown","44d2fefd":"markdown","b20842a0":"markdown","2e41e70a":"markdown","f745d00e":"markdown","54a25af4":"markdown","ccabfca6":"markdown","f84aa08e":"markdown","31ba0d42":"markdown","d2cb4405":"markdown","61f5e3a7":"markdown","be80237f":"markdown","513f4ff7":"markdown","85454e9f":"markdown","9d915d12":"markdown","995cea40":"markdown","8a9aae5a":"markdown","2bc9ae1e":"markdown","208c9414":"markdown","d93649e6":"markdown","b53d7a3e":"markdown"},"source":{"23baa69e":"country_main = 'US'\nrolling_window = True","1a949147":"!pip install openpyxl","f2e9fbe4":"import os\nimport io\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport openpyxl\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\n\nfrom PIL import Image\nfrom IPython.display import FileLink\n\nfrom datetime import date, timedelta, datetime\nfrom fbprophet import Prophet\nfrom fbprophet.make_holidays import make_holidays_df\nfrom fbprophet.diagnostics import cross_validation, performance_metrics\nfrom fbprophet.plot import plot_cross_validation_metric\nimport holidays\nfrom collections import Counter\nimport pycountry\n\nfrom sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error\n\nimport warnings\nwarnings.simplefilter('ignore')","52231f9e":"# Thanks https:\/\/github.com\/CSSEGISandData\/COVID-19\nmyfile = requests.get('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_confirmed_global.csv')\nopen('data', 'wb').write(myfile.content)\nconfirmed_global_df = pd.read_csv('data')\nconfirmed_global_df","4cf14217":"confirmed_global_df = confirmed_global_df[confirmed_global_df['Country\/Region'] == country_main].reset_index(drop=True)\nconfirmed_global_df","ab0885e5":"# Thanks to https:\/\/www.kaggle.com\/corochann\/covid-19-current-situation-on-august\ndef _convert_date_str(df):\n    try:\n        df.columns = list(df.columns[:4]) + [datetime.strptime(d, \"%m\/%d\/%y\").date().strftime(\"%Y-%m-%d\") for d in df.columns[4:]]\n    except:\n        print('_convert_date_str failed with %y, try %Y')\n        df.columns = list(df.columns[:4]) + [datetime.strptime(d, \"%m\/%d\/%Y\").date().strftime(\"%Y-%m-%d\") for d in df.columns[4:]]\n\n_convert_date_str(confirmed_global_df)\nconfirmed_global_df","e570c8f7":"# Thanks to https:\/\/www.kaggle.com\/corochann\/covid-19-current-situation-on-august\ndf = confirmed_global_df.melt(\n    id_vars=['Province\/State', 'Country\/Region', 'Lat', 'Long'], value_vars=confirmed_global_df.columns[4:], var_name='Date', value_name='ConfirmedCases')\ndf2 = df.groupby([\"Date\", \"Country\/Region\"])[['Date', 'Country\/Region', 'ConfirmedCases']].sum().reset_index()\ndf2.columns = ['Date', 'Country', 'Confirmed']","cabc2e85":"df2","897d9b45":"df2['Confirmed'] = df2['Confirmed'].diff()\ndf2.loc[0,'Confirmed'] = 0\ndf2","4c2ed9d7":"latest_date = df2['Date'].max()\nlatest_date","c9e28eb0":"df2 = df2[['Date','Confirmed']].dropna()\ndf2 = df2[df2['Confirmed'] > 10].reset_index(drop=True)\ndf2['Confirmed'].plot()","89cdfe80":"if rolling_window:\n    df2['Confirmed'] = df2['Confirmed'].rolling(7).mean()\n    df2['Confirmed'].plot()","2ea0c887":"df2.columns = ['Date', 'Confirmed']\ndf2['Country'] = 'US'","9d2f4d5e":"latest_date = df2['Date'].max()\nlatest_date","5c764a85":"df2.tail(5)","51cd26dd":"def cut_df(date0: str, \n           df:pd.DataFrame(), \n           col: str):\n    # Deletes all rows of dataframe df with df[col] < date0\n    format0 = '%Y-%m-%d'\n    df_temp = df.copy()\n    df_temp['col_dt'] = pd.to_datetime(df_temp[col], format=format0, errors='coerce')\n    date0_dt = datetime.strptime(date0, format0)\n    df_temp = df_temp[df_temp['col_dt'] >= date0_dt]\n    \n    return df_temp","a12c913c":"# Thanks to dataset https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries\nholidays_df = pd.read_csv('..\/input\/covid19-holidays-of-countries\/holidays_df_of_70_countries_for_covid_19_2021.csv')\nholidays_df[holidays_df['country'] == country_main]","b6704bb2":"holidays_df_code_countries = holidays_df['code'].unique()\nholidays_df_code_countries","360921ab":"# From notebook https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef dict_code_countries_with_holidays(list_name_countries: list,\n                                      holidays_df: pd.DataFrame()):\n        \n    \"\"\"\n    Defines a dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    in the dataset \"COVID-19: Holidays of countries\" \n    \n    Returns: \n    - countries: dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    - holidays_df_identificated: DataFrame with holidays data for countries from dictionary 'countries'\n    \n    Args: \n    - list_name_countries: list of the name of countries (name or common_name or official_name or alha2 or alpha3 codes from ISO 3166)\n    - holidays_df: DataFrame with holidays \"COVID-19: Holidays of countries\"\n    \"\"\"\n    \n    import pycountry\n    \n    # Identification of countries for which there are names according to ISO\n    countries = {}\n    dataset_all_countries = list(holidays_df['code'].unique())\n    list_name_countries_identificated = []\n    list_name_countries_not_identificated = []\n    for country in list_name_countries:\n        try: \n            country_id = pycountry.countries.get(alpha_2=country)\n            if country_id.alpha_2 in dataset_all_countries:\n                countries[country] = country_id.alpha_2\n        except AttributeError:\n            try: \n                country_id = pycountry.countries.get(name=country)\n                if country_id.alpha_2 in dataset_all_countries:\n                    countries[country] = country_id.alpha_2\n            except AttributeError:\n                try: \n                    country_id = pycountry.countries.get(official_name=country)\n                    if country_id.alpha_2 in dataset_all_countries:\n                        countries[country] = country_id.alpha_2\n                except AttributeError:\n                    try: \n                        country_id = pycountry.countries.get(common_name=country)\n                        if country_id.alpha_2 in dataset_all_countries:\n                            countries[country] = country_id.alpha_2\n                    except AttributeError:\n                        try: \n                            country_id = pycountry.countries.get(alpha_3=country)\n                            if country_id.alpha_2 in dataset_all_countries:\n                                countries[country] = country_id.alpha_2\n                        except AttributeError:\n                            list_name_countries_not_identificated.append(country)\n    holidays_df_identificated = holidays_df[holidays_df['code'].isin(countries.values())]\n    \n    print(f'Thus, the dataset has holidays in {len(countries)} countries from your list with {len(list_name_countries)} countries')\n#     if len(countries) == len(dataset_all_countries):\n#         print('All available in this dataset holiday data is used')\n#     else:\n#         print(\"Holidays are available in the dataset for such countries (if there are countries from your list, then it's recommended making changes to the list)\")\n#         print(np.array(holidays_df[~holidays_df['code'].isin(countries.values())].country_official_name.unique()))\n        \n    return countries, holidays_df_identificated.reset_index(drop=True)","a9a02a2e":"countries_dict, holidays_df_base = dict_code_countries_with_holidays([country_main],holidays_df)\ncountries_dict","8ee8fd86":"holidays_df_base['type'] = 'holiday'\nholidays_df = holidays_df_base.copy()\nholidays_df","2043e6d4":"# From https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef adaption_df_to_holidays_df_for_prophet(df, col, countries_dict):\n    # Adaptation the dataframe df (by column=col) to holidays_df by list of countries in dictionary countries_dict\n    \n    # Filter df for countries which there are in the dataset with holidays\n    df = df[df[col].isin(list(countries_dict.keys()))].reset_index(drop=True)\n    \n    # Add alpha_2 (code from ISO 3166) for each country\n    df['iso_alpha'] = None\n    for key, value in countries_dict.items():\n        df.loc[df[col] == key, 'iso_alpha'] = value    \n    \n    return df","963c2445":"df2 = adaption_df_to_holidays_df_for_prophet(df2, 'Country', countries_dict)\ndf2.columns = ['Date', 'Confirmed', 'Country', 'iso_alpha']\ndf2","37dd9a3f":"country_iso_alpha = df2.loc[0,'iso_alpha']\ncountry_iso_alpha","786c65d8":"def aux_holidays_df_generator(holidays_df, dates_list, name, source, window_size, shift7=True):\n    # Add dates from dates_list with anomalies of various kinds to the holiday dataset holidays_df\n    # name - the name of the anomaly\n    # source - the source of the primary information used for processing\n    \n    last_row = len(holidays_df)\n    if shift7:\n        holidays_dates = holidays_df['ds_holidays'].tolist()\n    else: holidays_dates = holidays_df['ds'].tolist()\n    common_dates = list(set(holidays_dates).intersection(set(dates_list)))\n    dates_list = list(set(dates_list).difference(set(common_dates)))\n        \n    for i in range(len(dates_list)):\n        holidays_df = holidays_df.append([holidays_df.loc[last_row-1,:]], ignore_index=True)\n        ds_dt = datetime.strptime(dates_list[i], '%Y-%m-%d')\n        holidays_df.loc[last_row+i, 'ds_holidays'] = dates_list[i]\n        holidays_df.loc[last_row+i, 'holiday'] = name\n        holidays_df.loc[last_row+i, 'source'] = source\n        holidays_df.loc[last_row+i, 'lower_window'] = -window_size\n        holidays_df.loc[last_row+i, 'upper_window'] = window_size\n    \n        # Type of holidays or pseudo-holidays\n        if name == 'the weakening of quarantine':\n            holidays_df.loc[last_row+i, 'type'] = 'SI'\n        elif name == 'Very comfortable conditions for rest':\n            holidays_df.loc[last_row+i, 'type'] = 'meteo'\n        elif name == 'Holidays as days of less efficient work of laboratories':\n            holidays_df.loc[last_row+i, 'type'] = 'lab'\n            holidays_df.loc[last_row+i, 'ds'] = (ds_dt + timedelta(days=2)).strftime('%Y-%m-%d')\n        elif name == 'Weekend quarantine as holidays':\n            holidays_df.loc[last_row+i, 'type'] = 'weekend'\n            \n        if shift7:\n            # Make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = (ds_dt + timedelta(days=7)).strftime('%Y-%m-%d')\n        else:\n            # Don't make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = ds_dt.strftime('%Y-%m-%d')\n                    \n    return holidays_df.sort_values(by=['ds'])","c201d8c6":"def plot_with_anomalies(df, cols_y_list, cols_y_list_name, dates_x, col_anomalies, val_anomal, log_y=False):\n    # Draws a plot with title - the features cols_y_list (y) and dates_x (x) from the dataframe df\n    # and with vertical lines in the date with col_anomalies == 1 \n    # with the length between the minimum and maximum of feature cols_y_list[0]\n    # with log_y = False or True\n    # cols_y_list - dictionary of the names of cols from cols_y_list (keys - name of feature, value - it's name for the plot legend), \n    # name of cols_y_list[0] is the title of the all plot\n    \n    fig = px.line(df, x=dates_x, y=cols_y_list[0], title=cols_y_list_name[cols_y_list[0]], log_y=log_y, template='gridon',width=700, height=800)\n    y_max = df[cols_y_list[0]].max()\n    for i in range(len(cols_y_list)-1):\n        fig.add_trace(go.Scatter(x=df[dates_x], y=df[cols_y_list[i+1]], mode='lines', name=cols_y_list_name[cols_y_list[i+1]]))\n        max_i = df[cols_y_list[i+1]].max()\n        y_max = max_i if max_i > y_max else y_max\n    \n    anomal_dates_list = df[df[col_anomalies] == val_anomal][dates_x].tolist()\n    y_min = min(df[cols_y_list[0]].min(),0)\n    for i in range(len(anomal_dates_list)):\n        anomal_date = anomal_dates_list[i]\n        fig.add_shape(dict(type=\"line\", x0=anomal_date, y0=y_min, x1=anomal_date, y1=y_max, line=dict(color=\"red\", width=1)))\n    fig.show()","8407a889":"# Thank to https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data\ndata = pd.read_csv(f\"https:\/\/storage.googleapis.com\/covid19-open-data\/v2\/UA\/main.csv\")","1da28859":"data['stringency_index_jump'] = 0\nfor i in range(len(data)-1):\n    if (data.loc[i+1,'stringency_index'] is not None) and (data.loc[i,'stringency_index'] is not None) and \\\n    (data.loc[i+1,'stringency_index'] < data.loc[i,'stringency_index']):\n        data.loc[i+1, 'stringency_index_jump'] = 1\nsource_gov = 'https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker'\ndates_gov_list = data[data['stringency_index_jump'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_gov_list, 'the weakening of quarantine', source_gov, 2)\nplot_with_anomalies(data, [\"stringency_index\"], {\"stringency_index\" : \"Stringency index and dates of the weakening of quarantine in \" + country_main}, 'date', 'stringency_index_jump', 1)","f27c974e":"data.columns.tolist()","3ec6ca06":"data['rest_comfort'] = 0\ndata.loc[(data['average_temperature'] >= data['average_temperature'].quantile(.95)) & (data['rainfall'] <= data['rainfall'].quantile(.05)), 'rest_comfort'] = 1\ndates_weather_list = data[data['rest_comfort'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_weather_list, 'Very comfortable conditions for rest', 'https:\/\/www.ncei.noaa.gov\/', 2)\nplot_with_anomalies(data, [\"average_temperature\", \"rainfall\"], {\"average_temperature\" : \"Average temperature over time in \" + country_main, \"rainfall\" : \"rainfall\"}, 'date', 'rest_comfort', 1)","ae3557d5":"df2.info()","297fd637":"# Removing the holidays for the period when there were still diseases < 10\nholidays_df['ds_dt'] = pd.to_datetime(holidays_df['ds'], format='%Y-%m-%d', errors='ignore')\ndate_the_first_many_cases = datetime.strptime(df2[df2.Confirmed >= 10].bfill(axis=1)['Date'].tolist()[0], '%Y-%m-%d')\nholidays_df = holidays_df[holidays_df['ds_dt'] >= date_the_first_many_cases]\nholidays_df","a168b0f8":"fig = px.line(df2, x=\"Date\", y=\"Confirmed\", \n              title=\"Confirmed cases in \" + country_main, \n              log_y=False,template='gridon',width=700, height=600)\nfig.show()","a06ceaee":"fig = px.line(df2, x=\"Date\", y=\"Confirmed\", \n              title=\"Confirmed cases (logarithmic scale) in \" + country_main, \n              log_y=True,template='gridon',width=700, height=600)\nfig.show()","f4c76ac6":"df2['holiday'] = 0\nholidays_df_dates = holidays_df['ds'].tolist()\ndf2.loc[df2['Date'].isin(holidays_df_dates), 'holiday'] = 1\nplot_with_anomalies(df2, [\"Confirmed\"], {\"Confirmed\" : \"Confirmed cases and holidays data in \" + country_main}, 'Date', 'holiday', 1)\ndf2 = df2.drop(columns=['holiday'])","6f21acfb":"holidays_df_dates","9fe68b6e":"df2.describe()","6e41d4d4":"df2.head()","88ea8df0":"df2.tail()","6c5818cf":"# For stage 1 of tuning\nchangepoint_prior_scale_initial_level = 0.15\nweekly_season_reg_coef = 1\nlower_window_list = [0, -1, -2, -3] # must be exactly 4 values (identical allowed)\nupper_window_list = [0, 1, 2, 3] # must be exactly 4 values (identical allowed)\nprior_scale_list = [2, 2.5, 3, 5] # must be exactly 4 values (identical allowed)\nholidays_adaptive = ['holiday', 'SI', 'meteo'] # holidays with adaptive window\n\n# For stage 2 of tuning\nseveral_days_period = 480\nseveral_days_season_reg_coef = 2\nseveral_days_short_period = 4\nseveral_days_short_days_fourier_order = 10\nseveral_days_short_days_season_reg_coef = 0.5\nchangepoint_prior_scale_list = [0.2, 0.3, 0.4, 0.5] # must be exactly 4 values (identical allowed)\nweekly_fourier_order_list = [3, 4, 5, 9] # must be exactly 4 values (identical allowed), \nseveral_days_fourier_order_list = [5, 6, 7, 9] # must be exactly 4 values (identical allowed)\n# 0 in fourier_order lists means the absence of this component\n\n# Check length of lists\nif (len(lower_window_list) != 4) or (len(upper_window_list) != 4) or \\\n   (len(prior_scale_list) != 4) or (len(weekly_fourier_order_list) != 4) or (len(several_days_fourier_order_list) != 4):\n    print('Number of data is wrong!')","8e48ab12":"df2 = df2.drop(columns = ['Country', 'iso_alpha'])\ndf2.columns = ['ds','y']\ndf2.tail(14)","32ae7dd6":"days_to_forecast = 14 # in future (after training data)\ndays_to_forecast_for_evalution = 14 # on the latest training data - for model training\nfirst_forecasted_date = sorted(list(set(df2['ds'].values)))[-days_to_forecast_for_evalution]\nend_forecasted_date = (datetime.strptime(df2['ds'].max(), \"%Y-%m-%d\")+timedelta(days = days_to_forecast)).strftime(\"%Y-%m-%d\")\nfirst_data_date = df2['ds'].min()\n\nprint('The first date of data for modeling is: ' + first_data_date)\nprint('The first date to perform forecasts for evaluation is: ' + first_forecasted_date)\nprint('The end date to perform forecasts in future for is: ' + end_forecasted_date)","1ca97e53":"def convert10_base4(n):\n    # convert decimal to base 4\n    alphabet = \"0123\"\n    if n < 4:\n        return alphabet[n]\n    else:\n        return (convert10_base4(n \/\/ 4) + alphabet[n % 4]).format('4f')","f42202b2":"def export_plot_to_tiff(plot, fig_name):\n    DPI = 100 # this value controls the quality of final image\n    fig_name = \"{}.tiff\".format(fig_name)\n    buf = io.BytesIO()\n    try:\n        plot.figure.savefig(buf, format=\"png\", dpi=DPI)\n    except AttributeError:\n        plot.savefig(buf, format=\"png\", dpi=DPI)\n    else:\n        print(\"Function supports only objects that have savefig() method.\")\n        return\n    buf.seek(0)\n    im = Image.open(buf)\n    im.save(fig_name)\n    im.save(buf, format=\"tiff\")\n    buf.close()\n    return FileLink(fig_name)","ae1f2068":"def export_df_to_excel(df, sheet_name):\n    sheet_name = \"{}.xlsx\".format(sheet_name)\n    with pd.ExcelWriter(sheet_name, engine='openpyxl', date_format='yyyy-mm-dd') as writer:\n        df.to_excel(writer, index=False)\n    return FileLink(sheet_name)","e71e0fa7":"def export_forecast_to_excel(df, sheet_name):\n    df.ds = df.ds.apply(lambda row: row.strftime(\"%Y-%m-%d\"))\n    df.rename(columns={\n        \"ds\": \"\u0414\u0430\u0442\u0430\",\n        \"yhat_lower\": \"\u041d\u0438\u0436\u043d\u044f \u043c\u0435\u0436\u0430 \u0434\u043e\u0432\u0456\u0440\u0447\u043e\u0433\u043e \u0456\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0443, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\",\n        \"yhat\": \"\u041f\u0440\u043e\u0433\u043d\u043e\u0437\u043e\u0432\u0430\u043d\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\",\n        \"yhat_upper\":  \"\u0412\u0435\u0440\u0445\u043d\u044f \u043c\u0435\u0436\u0430 \u0434\u043e\u0432\u0456\u0440\u0447\u043e\u0433\u043e \u0456\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0443, \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0432\u0438\u043f\u0430\u0434\u043a\u0456\u0432\"\n    }, inplace=True)\n    return export_df_to_excel(df, sheet_name)","1c00e5d9":"first_eval_index = len(df2)-days_to_forecast_for_evalution\nsecond_eval_index = len(df2)\ny_real = df2.tail(days_to_forecast_for_evalution)['y']\ny_real_sum = df2.tail(days_to_forecast_for_evalution)['y'].sum()\ncountry_df_val = df2.copy()\ncountry_df_val['ds'] = pd.to_datetime(country_df_val['ds'])\ncountry_df_val = country_df_val[(country_df_val['ds'] >= pd.to_datetime(first_forecasted_date))]\ncountry_df_val","f692aefd":"def eval_error(forecast_df, title):\n    # Evaluate forecasts with validation set val_df and calculaction and printing with title the relative error\n    forecast_df[forecast_df['yhat'] < 0]['yhat'] = 0\n    result_df = forecast_df[(forecast_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n    result_val_df = result_df.merge(country_df_val, on=['ds'])\n    result_val_df['rel_diff'] = (result_val_df['y'] - result_val_df['yhat'].round()).abs()\n    return (result_val_df['rel_diff'].sum())*100\/y_real_sum\n    #relative_error = sum(result_val_df['rel_diff'].values)*100\/y_real_sum\n    #return (forecast_df[first_eval_index:second_eval_index]['yhat'].sum())*100\/y_real_sum\n    #return mean_absolute_error(y_real, forecast_df[first_eval_index:second_eval_index]['yhat'])","38c1ea37":"def make_forecasts(country_df, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date):\n    \n    def model_training_forecasting(df, forecast_days, holidays_df=None, mode_main='multiplicative'):\n        # Prophet model training and forecasting\n        \n        model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False,\n                        holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale_initial_level,\n                        seasonality_mode = mode_main)\n        model.add_seasonality(name='weekly', period=7, fourier_order=8, mode = 'multiplicative', \n                              prior_scale = changepoint_prior_scale_initial_level\/weekly_season_reg_coef)\n        model.add_seasonality(name='several_days', period=620, fourier_order=4, mode = 'multiplicative', prior_scale = 0.3)\n        #model.add_seasonality(name='2 weeks', period=14, fourier_order=1, mode = 'multiplicative', prior_scale = 0.15)\n        model.fit(df)\n        future = model.make_future_dataframe(periods=forecast_days)\n        forecast = model.predict(future)\n        forecast[forecast['yhat'] < 0]['yhat'] = 0\n        return model, forecast\n\n    cols_w = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper', 'weekly', 'weekly_lower', 'weekly_upper']\n    cols_h = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'holidays', 'holidays_lower', 'holidays_upper', 'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper', 'weekly',\n              'weekly_lower', 'weekly_upper']\n    #mode_main_list = ['additive', 'multiplicative']\n    mode_main_list = ['multiplicative'] # take only this mode\n    relative_errors_holidays = []\n    counter = 0\n    results = pd.DataFrame(columns=['Conf_real', 'Conf_pred', 'Conf_pred_h', 'mode', 'n_h', 'err', 'err_h', 'prior_scale', 'how_less, %'])\n    \n    country_holidays_df = holidays_df[holidays_df['code'] == country_iso_alpha][['ds', 'holiday', 'lower_window', 'upper_window', 'prior_scale', 'type']].reset_index(drop=True)\n    country_dfs = []            \n\n    # Data preparation for forecast with Prophet\n    country_df['ds'] = pd.to_datetime(country_df['ds'])\n\n    # Set training and validation datasets\n    country_df_future = country_df.copy()\n    #country_df_val = country_df[(country_df['ds'] >= pd.to_datetime(first_forecasted_date))].copy()\n    country_df = country_df[(country_df['ds'] < pd.to_datetime(first_forecasted_date))]\n\n    n = 64 # number of combination of parameters lower_window \/ upper_window \/ prior_scale\n    for k in range(len(mode_main_list)):\n        # 'additive' and 'multiplicative' mode tuning\n        # Without holidays\n        # Model training and forecasting without holidays\n        model, forecast = model_training_forecasting(country_df, days_to_forecast_for_evalution, mode_main=mode_main_list[k])\n        #fig = model.plot_components(forecast)\n\n        # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n        forecast_df = forecast[['ds', 'yhat']].copy()\n        relative_error = eval_error(forecast_df, 'without holidays')\n\n        # With holidays\n        # Model training with tuning prior_scale and forecasting\n        for i in range(n):\n            parameters_iter = convert10_base4(i).zfill(3)\n            lower_window_i = lower_window_list[int(parameters_iter[0])]\n            upper_window_i = upper_window_list[int(parameters_iter[1])]\n            prior_scale_i = prior_scale_list[int(parameters_iter[2])]\n            country_holidays_df.loc[country_holidays_df['type'].isin(holidays_adaptive), 'lower_window'] = lower_window_i\n            country_holidays_df.loc[country_holidays_df['type'].isin(holidays_adaptive), 'upper_window'] = upper_window_i\n            country_holidays_df.loc[country_holidays_df['type'].isin(holidays_adaptive), 'prior_scale'] = prior_scale_i\n            country_holidays_df.loc[country_holidays_df['type'] == 'lab', 'upper_window'] = upper_window_i\n            number_holidays = len(country_holidays_df[(country_holidays_df['ds'] > first_data_date) & (country_holidays_df['ds'] < end_forecasted_date)])\n            model_holidays, forecast_holidays = model_training_forecasting(country_df, days_to_forecast_for_evalution, country_holidays_df, \n                                                                           mode_main=mode_main_list[k])\n\n            # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n            forecast_holidays_df = forecast_holidays[['ds', 'yhat']].copy()\n            relative_error_holidays = eval_error(forecast_holidays_df, 'with holidays impact')\n\n            # Save results\n            if (k == 0) and (i == 0):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                lower_window_best = lower_window_i\n                upper_window_best = upper_window_i\n                prior_scale_best = prior_scale_i\n                mode_best = mode_main_list[k]\n\n            elif (relative_error_holidays < relative_error_holidays_min):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                lower_window_best = lower_window_i\n                upper_window_best = upper_window_i\n                prior_scale_best = prior_scale_i\n                mode_best = mode_main_list[k]\n\n            # Save results to dataframe with result for the last date\n            confirmed_real_last = country_df.tail(1)['y'].values[0].astype('int')\n            results.loc[i+n*k,'Conf_real'] = confirmed_real_last if confirmed_real_last > 0 else 0\n            confirmed_pred_last = int(round(forecast_df.tail(1)['yhat'].values[0]))\n            results.loc[i+n*k,'Conf_pred'] = confirmed_pred_last if confirmed_pred_last > 0 else 0\n            confirmed_pred_holidays_last = int(round(forecast_holidays_df_best.tail(1)['yhat'].values[0],0))\n            results.loc[i+n*k,'Conf_pred_h'] = confirmed_pred_holidays_last if confirmed_pred_holidays_last > 0 else 0\n            results.loc[i+n*k,'mode'] = mode_main_list[k]\n            results.loc[i+n*k,'n_h'] = number_holidays\n            results.loc[i+n*k,'err'] = relative_error\n            results.loc[i+n*k,'err_h'] = relative_error_holidays\n            results.loc[i+n*k,'lower_window'] = lower_window_i\n            results.loc[i+n*k,'upper_window'] = upper_window_i\n            results.loc[i+n*k,'prior_scale'] = prior_scale_i\n            results.loc[i+n*k,'how_less, %'] = round((relative_error-relative_error_holidays)*100\/relative_error,1)\n\n            print('i =',i+n*k,' from',len(mode_main_list)*n-1,':  lower_window =', lower_window_i, 'upper_window =',upper_window_i, 'prior_scale =', prior_scale_i)\n            print(f'relative_error_holidays = {relative_error_holidays}%, relative_error_holidays_min = {relative_error_holidays_min}\\n')\n\n        # Results visualization\n        print('Seasonality mode is', mode_main_list[k])\n        print('The best errors of model with holidays is', relative_error_holidays_min, 'with lower_window =', str(lower_window_best),\n              ' upper_window =', str(upper_window_best), ' prior_scale =', str(prior_scale_best))\n        print(f'The error of model without holidays is {relative_error}%\\n')\n\n    # Save results to dataframe with all dates\n    forecast_holidays_df_best['country'] = country_main\n    forecast_holidays_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)\n    forecast_holidays_dfs = forecast_holidays_df_best.tail(days_to_forecast_for_evalution)\n\n    # Forecasting the future\n    if relative_error < relative_error_holidays_min:\n        # The forecast without taking into account the holidays is the best\n        model_future_best, forecast_future_best = model_training_forecasting(country_df_future, days_to_forecast, mode_main=mode_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting without holidays) - ' + mode_main_list[k])\n        cols = cols_w\n        print('The best model is model without holidays')\n    else:\n        # The forecast taking into account the holidays is the best\n        print('The best model is model with holidays')\n        model_future_best, forecast_future_best = model_training_forecasting(country_df_future, days_to_forecast, holidays_df,\n                                                                             mode_main=mode_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting with holidays) - ' + mode_best)\n        cols = cols_h\n    # Save forecasting results \n    forecast_future_df_best = forecast_future_best[cols]\n    forecast_future_df_best['country'] = country_main\n    forecast_future_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)    \n    forecast_future_dfs = forecast_future_df_best.tail(days_to_forecast)\n    fig = model_future_best.plot_components(forecast_future_best)\n    return forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results","9df9b794":"%%time\nforecast_holidays_dfs, relative_errors_holidays, \\\n            forecast_future_dfs, results = make_forecasts(df2, holidays_df, \n                                                          days_to_forecast, \n                                                          days_to_forecast_for_evalution, \n                                                          first_forecasted_date)","64c266b5":"forecast_future_dfs.head(3)","984dca5a":"forecast_holidays_dfs.head(3)","4c56ceb4":"# Visualization or results\nprint(f'5D plot of Prophet model parameters and COVID-19 error of forecasting to {str(days_to_forecast_for_evalution)} days')","c3362af7":"# Determination of the best parameters\nresults['err_h'] = results['err_h'].astype('float')\nresults['lower_window'] = results['lower_window'].astype('int')\nresults['upper_window'] = results['upper_window'].astype('int')\nresults_m = results[results['mode'] == 'multiplicative']","ea963068":"# Interactive plot with results of parameters tuning\nfig = px.scatter_3d(results_m, x='lower_window', y='upper_window', z='err_h',\n                     color='prior_scale', color_discrete_sequence= px.colors.sequential.Plasma_r, opacity=1,\n                    title='Interactive plot with results of parameters tuning for multiplicative mode')\nfig.update(layout=dict(title=dict(x=0.5)))","5f50e333":"#display(results_a.nsmallest(5, 'err_h'))\ndisplay(results_m.nsmallest(5, 'err_h'))","71cfef2c":"# The smallest error:\nbest_result = results.nsmallest(1, 'err_h').reset_index(drop=True)\nlower_window_opt = best_result.lower_window[0]\nupper_window_opt = best_result.upper_window[0]\nprior_scale_opt = best_result['prior_scale'][0]\nmode_opt = best_result['mode'][0]","13c0c809":"print(f\"Thus, for {country_main} the optimal parameters of Prophet model that gave an error = {best_result['err_h'][0]} are:\")\nprint(\"* lower_window =\", lower_window_opt)\nprint(\"* upper_window =\", upper_window_opt)\nprint(\"* prior_scale =\", prior_scale_opt)\nprint(\"* mode_opt =\", mode_opt)","a1f839b0":"holidays_df.loc[holidays_df['type'].isin(holidays_adaptive), 'lower_window'] = lower_window_opt\nholidays_df.loc[holidays_df['type'].isin(holidays_adaptive), 'upper_window'] = upper_window_opt\nholidays_df.loc[holidays_df['type'].isin(holidays_adaptive), 'prior_scale'] = prior_scale_opt\nholidays_df.loc[holidays_df['type'] == 'lab', 'upper_window'] = upper_window_opt","09bbe5b9":"holidays_df","767798b1":"# The smallest error:\ndisplay(best_result)","e5d4a775":"def make_forecasts_stage2(country_df, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date,\n                          mode_main='multiplicative'):\n    \n    def model_training_forecasting(df, forecast_days, holidays_df=None, mode_main='multiplicative', \n                                  weekly_fourier_order=10, several_days_fourier_order=10,\n                                  changepoint_prior_scale = changepoint_prior_scale_initial_level, mode_seasonality = 'additive'):\n        # Prophet model training and forecasting\n        \n        model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, interval_width=0.9,\n                        holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale,\n                        seasonality_mode = mode_main)\n        if weekly_fourier_order > 0:\n            model.add_seasonality(name='weekly', period=7, fourier_order=weekly_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale\/weekly_season_reg_coef)\n        if several_days_fourier_order > 0:\n            model.add_seasonality(name='several_days', period=several_days_period-(several_days_fourier_order-3)*7,\n                                  fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                                  prior_scale = changepoint_prior_scale\/several_days_season_reg_coef)\n        model.add_seasonality(name='4 days', period=several_days_short_period, fourier_order=several_days_short_days_fourier_order, \n                              mode = 'multiplicative', prior_scale = several_days_short_days_season_reg_coef)\n        #model.add_seasonality(name='2 weeks', period=14, fourier_order=1, mode = 'multiplicative', prior_scale = 0.15)\n        model.fit(df)\n        future = model.make_future_dataframe(periods=forecast_days)\n        forecast = model.predict(future)\n        forecast[forecast['yhat'] < 0]['yhat'] = 0\n        return model, forecast\n\n    \n    cols_w = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper']\n    cols_h = ['ds', 'trend', 'yhat', 'yhat_lower', 'yhat_upper', 'trend_lower', 'trend_upper', 'additive_terms', 'additive_terms_lower', 'additive_terms_upper',\n              'holidays', 'holidays_lower', 'holidays_upper', 'multiplicative_terms','multiplicative_terms_lower', 'multiplicative_terms_upper']\n    #mode_seasonality_list = ['additive', 'multiplicative']\n    mode_seasonality_list = ['multiplicative'] # take only this mode\n    relative_errors_holidays = []\n    counter = 0\n    results = pd.DataFrame(columns=['Conf_real', 'Conf_pred', 'Conf_pred_h', 'mode_s', 'err', 'err_h', 'weekly_fn', 'several_days_fn', 'ch_p_s_fn', 'how_less, %'])\n    \n    country_dfs = []\n    # Data preparation for forecast with Prophet\n    country_df['ds'] = pd.to_datetime(country_df['ds'])\n\n    # Set training and validation datasets\n    country_df_future = country_df.copy()\n    #country_df_val = country_df[(country_df['ds'] >= pd.to_datetime(first_forecasted_date))].copy()\n    country_df = country_df[(country_df['ds'] < pd.to_datetime(first_forecasted_date))]\n\n    n = 64 # number of combination of parameters weekly_fourier_order \/ several_days_fourier_order\n    relative_error_min = 100\n    for k in range(len(mode_seasonality_list)):\n        # 'additive' and 'multiplicative' mode tuning\n        # Without holidays\n        # Model training and forecasting without holidays\n        model, forecast = model_training_forecasting(country_df, days_to_forecast_for_evalution, mode_main=mode_main,\n                                                     mode_seasonality = mode_seasonality_list[k])\n        #fig = model.plot_components(forecast)\n\n        # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n        forecast_df = forecast[['ds', 'yhat']].copy()\n        relative_error = eval_error(forecast_df, 'without holidays')\n        #mode_seasonality_w_best = mode_seasonality_list[1] if relative_error < relative_error_min else mode_seasonality_list[0]\n        mode_seasonality_w_best = mode_seasonality_list[0]\n\n        # With holidays\n        # Model training with tuning prior_scale and forecasting\n        for i in range(n):\n            parameters_iter = convert10_base4(i).zfill(3)\n            weekly_fourier_order_i = weekly_fourier_order_list[int(parameters_iter[0])]\n            several_days_fourier_order_i = several_days_fourier_order_list[int(parameters_iter[1])]\n            changepoint_prior_scale_i = changepoint_prior_scale_list[int(parameters_iter[2])]\n            model_holidays, forecast_holidays = model_training_forecasting(country_df, days_to_forecast_for_evalution, \n                                                                           holidays_df, mode_main=mode_main,\n                                                                           weekly_fourier_order = weekly_fourier_order_i, \n                                                                           several_days_fourier_order = several_days_fourier_order_i,\n                                                                           changepoint_prior_scale = changepoint_prior_scale_i,\n                                                                           mode_seasonality = mode_seasonality_list[k])\n            \n            # Evaluate forecasts with validation set val_df and calculaction and printing the relative error\n            forecast_holidays_df = forecast_holidays[['ds', 'yhat']].copy()\n            relative_error_holidays = eval_error(forecast_holidays_df, 'with holidays impact')\n\n            # Save results\n            if (k == 0) and (i == 0):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                weekly_fourier_order_best = weekly_fourier_order_i\n                several_days_fourier_order_best = several_days_fourier_order_i\n                changepoint_prior_scale_best = changepoint_prior_scale_i\n                mode_seasonality_best = mode_seasonality_list[k]\n\n            elif (relative_error_holidays < relative_error_holidays_min):\n                relative_error_holidays_min = relative_error_holidays\n                forecast_holidays_df_best = forecast_holidays[cols_h]\n                model_holidays_best = model_holidays\n                weekly_fourier_order_best = weekly_fourier_order_i\n                several_days_fourier_order_best = several_days_fourier_order_i\n                changepoint_prior_scale_best = changepoint_prior_scale_i\n                mode_seasonality_best = mode_seasonality_list[k]\n\n            # Save results to dataframe with result for the last date\n            confirmed_real_last = country_df.tail(1)['y'].values[0].astype('int')\n            results.loc[i+n*k,'Conf_real'] = confirmed_real_last if confirmed_real_last > 0 else 0\n            confirmed_pred_last = int(round(forecast_df.tail(1)['yhat'].values[0]))\n            results.loc[i+n*k,'Conf_pred'] = confirmed_pred_last if confirmed_pred_last > 0 else 0\n            confirmed_pred_holidays_last = int(round(forecast_holidays_df_best.tail(1)['yhat'].values[0],0))\n            results.loc[i+n*k,'Conf_pred_h'] = confirmed_pred_holidays_last if confirmed_pred_holidays_last > 0 else 0\n            results.loc[i+n*k,'mode_s'] = mode_seasonality_list[k]\n            results.loc[i+n*k,'err'] = relative_error\n            results.loc[i+n*k,'err_h'] = relative_error_holidays\n            results.loc[i+n*k,'weekly_fn'] = weekly_fourier_order_i\n            results.loc[i+n*k,'several_days_fn'] = several_days_fourier_order_i\n            results.loc[i+n*k,'ch_p_s_fn'] = changepoint_prior_scale_i\n            results.loc[i+n*k,'how_less, %'] = round((relative_error-relative_error_holidays)*100\/relative_error,1)\n\n            print('i =',i+n*k,' from',len(mode_seasonality_list)*n-1,':  weekly_fourier_order =', weekly_fourier_order_i, 'several_days_fourier_order =', several_days_fourier_order_i,\n                  'changepoint_prior_scale =', changepoint_prior_scale_i)\n            print(f'relative_error_holidays = {relative_error_holidays}%, relative_error_holidays_min = {relative_error_holidays_min}\\n')\n\n        # Results visualization\n        print('Seasonality mode is', mode_seasonality_list[k])\n        print('The best errors of model with holidays is', relative_error_holidays_min,\n              'weekly_fourier_order =', weekly_fourier_order_i, 'several_days_fourier_order =', several_days_fourier_order_i,\n              'changepoint_prior_scale =', changepoint_prior_scale_i)\n        print('The error of model without holidays is', relative_error, '\\n')\n\n    # Save results to dataframe with all dates\n    forecast_holidays_df_best['country'] = country_main\n    forecast_holidays_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)\n    forecast_holidays_dfs = forecast_holidays_df_best.tail(days_to_forecast_for_evalution)\n\n    # Forecasting the future\n    if relative_error < relative_error_holidays_min:\n        # The forecast without taking into account the holidays is the best\n        model_future_best, forecast_future_best = model_training_forecasting(country_df, days_to_forecast_for_evalution, mode_main=mode_main,\n                                                                             mode_seasonality = mode_seasonality_w_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting without holidays) - ' + mode_seasonality_w_best)\n        cols = cols_w\n        print('The best model is model without holidays')\n    else:\n        # The forecast taking into account the holidays is the best\n        print('The best model is model with holidays')\n        model_future_best, forecast_future_best = model_training_forecasting(country_df, days_to_forecast_for_evalution, \n                                                                             holidays_df, mode_main=mode_main,\n                                                                             weekly_fourier_order = weekly_fourier_order_best, \n                                                                             several_days_fourier_order = several_days_fourier_order_best,\n                                                                             changepoint_prior_scale = changepoint_prior_scale_i,\n                                                                             mode_seasonality = mode_seasonality_best)\n        forecast_plot = model_future_best.plot(forecast_future_best, ylabel='Confirmed in '+ country_main + ' (forecasting with holidays) - ' + mode_seasonality_best)\n        cols = cols_h\n    # Save forecasting results \n    forecast_future_df_best = forecast_future_best[cols]\n    forecast_future_df_best['country'] = country_main\n    forecast_future_df_best.rename(columns={'yhat':'confirmed'}, inplace=True)    \n    forecast_future_dfs = forecast_future_df_best.tail(days_to_forecast)\n    fig = model_future_best.plot_components(forecast_future_best)\n    return forecast_future_df_best, forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results","7fd72439":"%%time\nforecast_future_df_best, forecast_holidays_dfs, relative_errors_holidays, forecast_future_dfs, results = make_forecasts_stage2(df2, holidays_df, days_to_forecast, days_to_forecast_for_evalution, first_forecasted_date, mode_main=mode_opt)","7f0d23b1":"results.to_csv('results.csv', index=False)","de292b46":"results","75045762":"# Visualization or results\nprint(f'3D plot of Prophet model parameters and COVID-19 error of forecasting to {str(days_to_forecast_for_evalution)} days')","ee34355d":"# Determination of the best parameters\nresults['err_h'] = results['err_h'].astype('float')\nresults['weekly_fn'] = results['weekly_fn'].astype('int')\nresults['several_days_fn'] = results['several_days_fn'].astype('int')\nresults_m = results[results['mode_s'] == 'multiplicative']","23286f8c":"# Interactive plot with results of parameters tuning - multiplicative\nfig = px.scatter_3d(results_m, x='weekly_fn', y='several_days_fn', z='err_h',\n                    color='ch_p_s_fn', color_discrete_sequence= px.colors.sequential.Plasma_r, opacity=1,\n                    title='Interactive plot with results of parameters tuning for multiplicative mode')\nfig.update(layout=dict(title=dict(x=0.5)))","332b5199":"#display(results_a.nsmallest(5, 'err_h'))\ndisplay(results_m.nsmallest(5, 'err_h'))","edecdb5c":"# The smallest error:\nbest_result2 = results.nsmallest(1, 'err_h').reset_index(drop=True)\nweekly_fourier_order_opt = best_result2.weekly_fn[0]\nseveral_days_fourier_order_opt = best_result2.several_days_fn[0]\nmode_seasonality_opt = mode_seasonality_weekly_opt = mode_seasonality_several_days_opt = best_result2['mode_s'][0]\nchangepoint_prior_scale_opt = best_result2['ch_p_s_fn'][0]\nweekly_seasonality_prior_scale_opt = changepoint_prior_scale_opt\/weekly_season_reg_coef\nseveral_days_seasonality_prior_scale_opt = changepoint_prior_scale_opt\/several_days_season_reg_coef","175fff08":"# The smallest error:\ndisplay(best_result2)","a706caf3":"best_result_all = round(best_result2.err_h[0], 2)\nprint(f\"Thus, for {country_main} the optimal 11 parameters of Prophet model that gave an error = {best_result_all}% are:\")\nprint(\"* lower_window =\", lower_window_opt)\nprint(\"* upper_window =\", upper_window_opt)\nprint(\"* prior_scale =\", prior_scale_opt)\nprint(\"* changepoint_prior_scale =\", changepoint_prior_scale_opt)\nprint(\"* mode_opt =\", mode_opt)\nprint(\"* weekly_fourier_order =\", weekly_fourier_order_opt)\nprint(\"* mode_seasonality_weekly =\", mode_seasonality_weekly_opt)\nprint(\"* weekly_seasonality_prior_scale =\", weekly_seasonality_prior_scale_opt)\nprint(\"* several_days_fourier_order =\", several_days_fourier_order_opt)\nprint(\"* mode_seasonality_several_days =\", mode_seasonality_several_days_opt)\nprint(\"* several_days_seasonality_prior_scale =\", several_days_seasonality_prior_scale_opt)","65302a1a":"def model_training_forecasting(df, forecast_days, holidays_df=None, mode_main='multiplicative', \n                               weekly_fourier_order=10, several_days_fourier_order=10, \n                               changepoint_prior_scale = changepoint_prior_scale_initial_level, mode_seasonality = 'additive'):\n    # Optimal Prophet model training and forecasting\n\n    model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, interval_width=0.9,\n                    holidays=holidays_df, changepoint_range=1, changepoint_prior_scale = changepoint_prior_scale,\n                    seasonality_mode = mode_main)\n    if weekly_fourier_order > 0:\n        model.add_seasonality(name='weekly', period=7, fourier_order=weekly_fourier_order, mode = mode_seasonality, \n                              prior_scale = changepoint_prior_scale\/weekly_season_reg_coef)\n    if several_days_fourier_order > 0:\n        model.add_seasonality(name='several_days', period=several_days_period-(several_days_fourier_order-3)*7,\n                              fourier_order=several_days_fourier_order, mode = mode_seasonality, \n                              prior_scale = changepoint_prior_scale\/several_days_season_reg_coef)\n    model.add_seasonality(name='4 days', period=several_days_short_period, fourier_order=several_days_short_days_fourier_order, \n                          mode = 'multiplicative', prior_scale = several_days_short_days_season_reg_coef)\n    #model.add_seasonality(name='2 weeks', period=14, fourier_order=1, mode = 'multiplicative', prior_scale = 0.15)\n    model.fit(df)\n    future = model.make_future_dataframe(periods=forecast_days)\n    forecast = model.predict(future)\n    \n    # Make values integer, and replace negative values with zero\n    feature_all = ['yhat_lower', 'yhat', 'yhat_upper']\n    forecast[feature_all] = forecast[feature_all].round().astype('int')\n    for feature in feature_all:\n        forecast.loc[forecast[feature] < 0, feature] = 0\n    \n    return model, forecast","7a98f94d":"model_future_opt, forecast_future_opt = model_training_forecasting(df2, days_to_forecast, holidays_df, mode_main=mode_opt,\n                                                                   weekly_fourier_order = weekly_fourier_order_opt, \n                                                                   several_days_fourier_order = several_days_fourier_order_opt,\n                                                                   changepoint_prior_scale = changepoint_prior_scale_opt,\n                                                                   mode_seasonality = mode_seasonality_opt)","05b378ca":"fig_opt = model_future_opt.plot(forecast_future_opt)\nexport_plot_to_tiff(fig_opt, 'fig_forecast_future_opt_all')","b857f267":"fig_opt_components = model_future_opt.plot_components(forecast_future_opt)\nexport_plot_to_tiff(fig_opt_components, 'fig_forecast_future_opt_components_all')","704d2669":"forecast_future_opt_future = forecast_future_opt[['ds', 'yhat_lower', 'yhat', 'yhat_upper']]\nforecast_future_opt_future_days = forecast_future_opt_future.tail(days_to_forecast)\nforecast_future_opt_future_days","527886d3":"forecast_future_opt_future_len=len(forecast_future_opt_future)\nforecast_future_opt_future[len(df2)-days_to_forecast_for_evalution:len(df2)][['ds', 'yhat']]","fa4556ad":"df2.tail(days_to_forecast_for_evalution)","d940ef00":"y_val = forecast_future_opt_future[len(df2)-days_to_forecast_for_evalution:len(df2)]['yhat']\ny = df2.tail(days_to_forecast_for_evalution)['y']\nprint(f\"r2_score - {r2_score(y, y_val)}, mean_absolute_error - {mean_absolute_error(y, y_val)}, root_mean_squared_error - {(mean_squared_error(y, y_val))**(.5)}\")","a513970b":"export_forecast_to_excel(forecast_future_opt_future_days, 'forecast_future_opt_future_14_days')","034978ef":"forecast_future_opt_future.to_csv('forecast_future_opt_future.csv', index=False)\nbest_result2.to_csv('best_result2.csv', index=False)\nholidays_df.to_csv('holidays_df_all.csv', index=False)","8141ee58":"forecast_future_opt_future.tail(days_to_forecast)","f1c32427":"def comparing_plot(df_new, df, num, name_plot_start):\n    # Drawing plots \n    \n    def plot_draw(labels_list, name_plot):\n        # Drawing plot \n        \n        fig = plt.figure(facecolor='w', figsize=(16,8))\n        \n        # New forecast\n        t_new = pd.to_datetime(df_new['ds'].tolist())\n        plt.plot(t_new, df_new['yhat'], ls='-', c='#0072B2', label = labels_list[0])\n        if not rolling_window:\n            plt.fill_between(t_new, df_new['yhat_lower'], df_new['yhat_upper'], color='#0072B2', alpha=0.2)\n\n        # Observation data\n        t = pd.to_datetime(df['ds'].tolist())\n        plt.scatter(t, df['y'], c='k', label = labels_list[-1])\n\n        plt.legend(loc='best')\n        plt.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n        fig.tight_layout()\n        \n        export_plot_to_tiff(fig, name_plot)\n    \n    \n    # Prepare dates for plots\n    date_today = date.today().strftime(\"%d.%m.%Y\")\n    forecast_today = f\"Forecast at {date_today}\"\n    labels_list = [forecast_today]\n    labels_list.append(\"Official data\")\n    \n    # Draw plot\n    plot_draw(labels_list, name_plot_start + 'forecast_today_all')","0e25dba6":"# Visualization\ncomparing_plot(forecast_future_opt_future, df2, 0, 'All_')","1e0ca903":"print(f\"Thus, for {country_main} the optimal Prophet model has the forecasting errors:\")\nprint(f\"- r2_score - {round(r2_score(y, y_val),2)} (the best value - 1.0)\")\nprint(f\"- MSE (mean_absolute_error) - {int(round(mean_absolute_error(y, y_val),0))} cases\")\nprint(f\"- RMSE (root_mean_squared_error) - {int(round((mean_squared_error(y, y_val))**(.5), 0))} cases\")\nprint(f\"- the main error (WAPE - relative error) = {best_result_all} % (the best value - 0.0 %).\")","b0f25d90":"## 7. Visualization <a class=\"anchor\" id=\"7\"><\/a>\n\n\n[Back to Table of Contents](#0.1)","1ed55d61":"# Dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries\nMy changes:\n\nlayers of the CNN\nepochs_num, validation_split_part\ndifferent font used for recognition (Franklin_Gothic_Book_italic.png)\nepochs_num, validation_split_part","74238190":"## 5.2.2. Results visualization<a class=\"anchor\" id=\"5.2.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","13840a29":"### 3.2.1. The weakening of quarantine<a class=\"anchor\" id=\"3.2.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","3ae51088":"## 2. Download data<a class=\"anchor\" id=\"2\"><\/a>\n\n[Back to Table of Contents](#0.1)","e2795977":"There are many studies in the field of coronavirus forecasting. Many researchers use **Prophet** (from Facebook). But for some reason, no one takes into account the holidays impact. After all, despite all the prohibitions, it is difficult for people to stay at home and they still somehow celebrate the **holidays** to which they are accustomed. The desire to celebrate is especially strong when people are sitting at home all the time looking for something to do. In my opinion, the impact of the holidays is manifested in the fact that within 4-10 days after these holidays there may be a jump in the number of confirmed cases, due to the fact that people went shopping, and even visiting each other, perhaps even in violation of quarantine requirements. \n\nThe Prophet uses the library [holidays](https:\/\/github.com\/dr-prodigy\/python-holidays) with information about the main holidays of 67 countries (at 2020), but and its package has some disadvantages. That's why I created a more perfect own dataset and plan to update it periodically. Now **my dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) has holidays for 70 countries** and more adapted for use in the prediction of coronavirus diseases.\n\nHolidays and pseudo-holidays (**anomalies dates**) are defined in three ways:\n- dates of official public holidays;\n- the weakening of quarantine according to open data;\n- dates of very comfortable conditions for rest (there are more 95% quantile on average temperature and not more 5% quantile of rainfall) - for each country it should be adapted individually (open data NOAA are used)\n\nThe model is **tuning in two stages** - makes a complete search of values from 4 possible for each feature at first for one part of parameters, then - for another. In the second stage, the optimal parameters determined in the first stage are used. Each stage ends with an interactive graph (library \"plotly\"), which clearly shows the error for each combination of parameters.\n\nThe Prophet model with all optimized parameters and holidays is used for **forecasting** future data for the next days and visualization of forecasting results. The data is taken from [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data) (usually this dataset are updated there daily and are available as of yesterday), so the next days are counted from the date of the last committee of this notebook.\n\n**This notebook analyzes and predicts the weekly moving average of the daily number of new confirmed covid patients in the United States.**","247a6783":"#### Thanks to [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker)","1b695e34":"### Thank to dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries)","af08183d":"## Earliest Cases","c34c3905":"<a class=\"anchor\" id=\"0\"><\/a>\n# COVID-19 in USA: EDA & Forecasting with holidays impact for confirmed cases. Prophet with holidays and pseudo-holidays - 11 parameters tuning:\n* lower_window\n* upper_window\n* prior_scale\n* mode\n* changepoint_prior_scale\n* weekly_fourier_order\n* mode_seasonality_weekly\n* weekly_seasonality_prior_scale\n* several_days_fourier_order (for period = n days, n = 2, 3, ... 6)\n* mode_seasonality_several_days\n* several_days_seasonality_prior_scale","b3738821":"## 4.2. Statistics<a class=\"anchor\" id=\"4.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","c525042a":"#### Thanks to:\n* [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data)\n* [NOAA](https:\/\/www.ncei.noaa.gov\/)","eafbd67b":"### Calculation of forecasting errors","030a646c":"## 5.1.2. Results visualization<a class=\"anchor\" id=\"5.1.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","5518bab6":"## 5.2.1. Model training, forecasting and evaluation<a class=\"anchor\" id=\"5.2.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","2d36adb7":"## Describe statistics","784855f9":"## 5.1. Stage 1 - Tuning holiday parameters<a class=\"anchor\" id=\"5.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","93666b67":"# Acknowledgements\n\n### Datasets:\n- dataset [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data) (including dataset [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker) and dataset [NOAA](https:\/\/www.ncei.noaa.gov\/)) : @article{Wahltinez2020,author = \"Oscar Wahltinez and Matt Lee and Anthony Erlinger and Mayank Daswani and Pranali Yawalkar and Kevin Murphy and Michael Brenner\", year = 2020, title = \"COVID-19 Open-Data: curating a fine-grained, global-scale data repository for SARS-CoV-2\", note = \"Work in progress\",  url = {https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data},} \n- my dataset with holidays data [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) - it is recommended to follow the updates\n\n### Notebooks:\n- [COVID in USA: Daily New Cases prediction (Prophet)](https:\/\/www.kaggle.com\/vbmokin\/covid-in-usa-daily-new-cases-prediction-prophet)\n- [COVID-19-in-USA: Prophet with holidays tuning](https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-usa-prophet-with-holidays-tuning)\n- [COVID in UA: Prophet with 4, Nd seasonality](https:\/\/www.kaggle.com\/vbmokin\/covid-in-ua-prophet-with-4-nd-seasonality)\n- [COVID-19 in 70 countries: daily Prophet forecast](https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-70-countries-daily-prophet-forecast)\n- [COVID-19-in-Ukraine: Prophet & holidays tuning](https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-ukraine-prophet-holidays-tuning)\n- [COVID-19 Novel Coronavirus EDA & Forecasting Cases](https:\/\/www.kaggle.com\/khoongweihao\/covid-19-novel-coronavirus-eda-forecasting-cases) from [@Wei Hao Khoong](https:\/\/www.kaggle.com\/khoongweihao)\n\n### Libraries from GitHub:\n- https:\/\/facebook.github.io\/prophet\/\n- https:\/\/facebook.github.io\/prophet\/docs\/\n- https:\/\/github.com\/facebook\/prophet\n- https:\/\/github.com\/dr-prodigy\/python-holidays","44d2fefd":"Thanks to Kaggle GM, Prof. @vbmokin https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries","b20842a0":"## 3.3. Removing the holidays for the period when there were still diseases < 10<a class=\"anchor\" id=\"3.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","2e41e70a":"## 4. EDA<a class=\"anchor\" id=\"4\"><\/a>\n\n[Back to Table of Contents](#0.1)","f745d00e":"## 1. Import libraries<a class=\"anchor\" id=\"1\"><\/a>\n\n[Back to Table of Contents](#0.1)","54a25af4":"### 3.2.2. Very comfortable conditions for rest <a class=\"anchor\" id=\"3.2.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","ccabfca6":"## Latest Cases","f84aa08e":"<a class=\"anchor\" id=\"0.1\"><\/a>\n## Table of Contents\n\n1. [Import libraries](#1)\n1. [Download data](#2)\n1. [Selection data with holidays](#3)\n    - [Holidays with a shift](#3.1)\n    - [Additional dates of anomalies as holidays](#3.2)\n        - [The weakening of quarantine](#3.2.1)\n        - [Very comfortable conditions for rest](#3.2.2)\n    - [Removing the holidays for the period when there were still diseases < 10](#3.3)       \n1. [EDA](#4)\n    - [Plots - Confirmed cases over time](#4.1)\n    - [Statistics](#4.2)\n    - [Set initial values for tuning](#4.3)\n1. [Tuning Prophet model and holidays parameters](#5)\n    - [Stage 1 - Tuning holiday parameters](#5.1)\n        - [Model training, forecasting and evaluation](#5.1.1)\n        - [Results visualization](#5.1.2)\n    - [Stage 2 - Tuning seasonality parameters](#5.2)\n        - [Model training, forecasting and evaluation](#5.2.1)\n        - [Results visualization](#5.2.2)\n    - [Results of all tuning](#5.3)\n1. [Prediction](#6)\n1. [Visualization](#7)","31ba0d42":"## 3.1. Holidays with a shift<a class=\"anchor\" id=\"3.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","d2cb4405":"## 6. Prediction <a class=\"anchor\" id=\"6\"><\/a>\n\n[Back to Table of Contents](#0.1)","61f5e3a7":"## 5.1.1. Model training, forecasting and evaluation<a class=\"anchor\" id=\"5.1.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","be80237f":"I hope you find this notebook useful and enjoyable.\n\nYour comments and feedback are most welcome.","513f4ff7":"## 4.3. Set initial values for tuning<a class=\"anchor\" id=\"4.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","85454e9f":"## 5.3. Results of all tuning<a class=\"anchor\" id=\"5.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","9d915d12":"## 4.1. Plots - Confirmed cases over time<a class=\"anchor\" id=\"4.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","995cea40":"## 3.2. Additional dates of anomalies as holidays<a class=\"anchor\" id=\"3.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","8a9aae5a":"## 5. Tuning Prophet model and holidays parameters<a class=\"anchor\" id=\"5\"><\/a>\n\n[Back to Table of Contents](#0.1)","2bc9ae1e":"[Go to Top](#0)","208c9414":"## 3. Selection data with holidays<a class=\"anchor\" id=\"3\"><\/a>\n\n[Back to Table of Contents](#0.1)","d93649e6":"Import libraries","b53d7a3e":"## 5.2. Stage 2 - Tuning seasonality parameters<a class=\"anchor\" id=\"5.2\"><\/a>\n\n[Back to Table of Contents](#0.1)"}}