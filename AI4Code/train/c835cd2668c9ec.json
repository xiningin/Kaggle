{"cell_type":{"f18802f6":"code","4932e433":"code","f11ae6da":"code","8c89d119":"code","a2b9cdff":"code","53e7d8e7":"code","a43a13c5":"code","917b19d0":"code","ac8f9bc1":"code","cf4efdac":"code","61fc512b":"code","c2b50fe6":"code","c9657894":"code","8c65106c":"code","4dd19a55":"code","606be08e":"code","8ca77277":"code","d3ae0219":"code","e03d9569":"code","2df3858e":"code","b91937ff":"code","222a1d05":"code","20deeb8e":"code","c3ab2815":"code","b0199e2e":"markdown","c5ed2286":"markdown"},"source":{"f18802f6":"!pip install git+https:\/\/github.com\/tensorflow\/docs","4932e433":"# Ignore warnings :\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Data Handling\nimport pandas as pd\n\n# Visualisation\nimport missingno as msno\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Tensorflow for regression\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nimport tensorflow_docs as tfdocs\nimport tensorflow_docs.plots\nimport tensorflow_docs.modeling","f11ae6da":"df = pd.read_csv('..\/input\/diamonds\/diamonds.csv')\ndiamondData = df.copy()\ndiamondData.head()","8c89d119":"diamondData = diamondData.drop(['Unnamed: 0'], axis=1)\ndiamondData.describe()","a2b9cdff":"# Remove the rows that have x, y , z equal to zero\ndiamondData = diamondData[(diamondData[['x', 'y', 'z']] != 0).all(axis=1)]\n\n# Use x,y,z to create a sythetic feature -- volume\ndiamondData['volume'] = diamondData['x'] * diamondData['y'] *diamondData['z']\n# diamondData['carat_volume'] = diamondData['volume'] * diamondData['carat']","53e7d8e7":"# Correlation Map\nplt.figure(figsize=(10,10))\ncorr = diamondData.corr()\nsns.heatmap(data=corr, square=True, annot=True, cmap='RdYlGn')","a43a13c5":"#pairplotting all the features\nsns.pairplot(diamondData, diag_kind=\"kde\")","917b19d0":"# Check for NaN\ndiamondData.isnull().sum()","ac8f9bc1":"sns.factorplot(x='cut', data=diamondData , kind='count', aspect= 3)","cf4efdac":"sns.factorplot(x='cut', y='price',data=diamondData , kind='box', aspect= 3)","61fc512b":"sns.factorplot(x='color', data=diamondData , kind='count', aspect= 3)","c2b50fe6":"sns.factorplot(x='color', y='price',data=diamondData , kind='box', aspect= 3)","c9657894":"sns.factorplot(x='clarity', data=diamondData , kind='count', aspect= 3)","8c65106c":"sns.factorplot(x='clarity', y='price',data=diamondData , kind='box', aspect= 3)","4dd19a55":"#One-Hot Encoding for Categorical columns\ndiamondFeaturesDF =  pd.get_dummies(diamondData)\n\n# Dropping depth , table due to lack of corelation with price\n# Dropping x, y, z due to having intercorelation with each other\ndiamondFeaturesDF = diamondFeaturesDF.drop(columns=['depth', 'table', 'x', 'y', 'z'])\ndiamondFeaturesDF","606be08e":"# Divide the dataset to train and test sets\ntrain_dataset = diamondFeaturesDF.sample(frac=0.8,random_state=0)\ntest_dataset = diamondFeaturesDF.drop(train_dataset.index)\n\n#Take out the labels\ntrain_labels = train_dataset.pop('price')\ntest_labels = test_dataset.pop('price')\n\n# Z-score Normalization\ntrain_dataset_normalized = (train_dataset - train_dataset.mean())\/train_dataset.std()\ntest_dataset_normalized = (test_dataset - test_dataset.mean())\/test_dataset.std()","8ca77277":"train_dataset_normalized.head()","d3ae0219":"# Build a sequential model\ndef build_model():\n  model = keras.Sequential([\n                            layers.Dense(64, activation='relu', input_shape=[len(train_dataset_normalized.keys())]),\n                            layers.Dense(64, activation='relu'),\n                            layers.Dense(1)\n  ])\n\n  optimizer = tf.keras.optimizers.RMSprop(0.001)\n\n  model.compile(loss='mse',\n                optimizer=optimizer,\n                metrics=['mae', 'mse'])\n  \n  return model\n\nmodel = build_model()\nmodel.summary()","e03d9569":"# Train the model\nEPOCHS = 500\n\n# The patience parameter is the amount of epochs to check for improvement\nearly_stop = keras.callbacks.EarlyStopping(monitor='val_loss', patience=3000)\n\nhistory = model.fit(\n  train_dataset_normalized, train_labels,\n  batch_size=100, epochs=EPOCHS, validation_split = 0.3, verbose=0,\n  callbacks=[early_stop, tfdocs.modeling.EpochDots()])","2df3858e":"hist = pd.DataFrame(history.history)\nhist['epoch'] = history.epoch\nhist.tail()\n\nplotter = tfdocs.plots.HistoryPlotter(smoothing_std=2)\n\nplotter.plot({'Basic': history}, metric = \"mae\")\nplt.ylabel('MAE [Price]')","b91937ff":"plotter.plot({'Basic': history}, metric = \"mse\")\nplt.ylabel('MSE [Price^2]')","222a1d05":"loss, mae, mse = model.evaluate(test_dataset_normalized, test_labels, verbose=2)\nprint(\"Testing set loss: {:5.2f}\".format(loss))\nprint(\"Testing set Mean Abs Error: {:5.2f}\".format(mae))\nprint(\"Testing set Mean Sqr Error: {:5.2f}\".format(mse))","20deeb8e":"test_predictions = model.predict(test_dataset_normalized).flatten()\n\na = plt.axes(aspect='equal')\nplt.scatter(test_labels, test_predictions)\nplt.xlabel('True Values [Price]')\nplt.ylabel('Predictions [Price]')\nlims = [0, 22000]\nplt.xlim(lims)\nplt.ylim(lims)\n_ = plt.plot(lims, lims)","c3ab2815":"error = test_predictions - test_labels\nplt.hist(error, bins = 25)\nplt.xlabel(\"Prediction Error [Price]\")\n_ = plt.ylabel(\"Count\")","b0199e2e":"1.   You can see that the min values of **x, y and z are 0** which is practically impossible. These are the missing values and have to be discarded\n2.   **Categorical Features** : cut, color, clarity\n3. **Numerical Feature** : carat, depth, table, x, y, z, price","c5ed2286":"# Price Prediction Using Keras Sequential Model and Feature Engineering\n* The complete project with model and predictor wrapper api is available in the link below\n* Github link - **https:\/\/github.com\/chetansb77\/Diamond-Price-Predictor**"}}