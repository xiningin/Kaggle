{"cell_type":{"c799c5e9":"code","931c96f1":"code","695da01f":"code","ea12f072":"code","40448d07":"code","53c3a5ad":"code","835820ff":"code","6093f9cf":"code","30a13183":"code","12fa78bc":"code","688056d1":"code","9229c409":"code","f625a401":"code","6930e7b6":"code","c40bc39a":"code","fc6ff414":"code","0ac60b17":"code","05cd1491":"code","44226297":"code","27802619":"code","94b10d31":"code","ccd474f1":"code","de3ec767":"code","43b4f2b6":"code","61fb1728":"code","9d775c9b":"code","21951ccd":"code","03dcb9d9":"code","43130cfa":"code","5f383b8c":"code","08c28f38":"code","9c90e6f2":"code","fff7d39b":"code","be2bae55":"code","904709bf":"code","bba3e6ba":"code","5198e487":"code","f42bbd95":"code","c944ea26":"code","7d8b2c6b":"markdown","9a58e7e2":"markdown","88fe0a7f":"markdown","419a8302":"markdown","182b900c":"markdown","ef5002b2":"markdown","4f008d85":"markdown","6b60f78b":"markdown","54adabc2":"markdown","c0b9d5eb":"markdown","aa0f15b1":"markdown","2785c03b":"markdown","4e88d4b9":"markdown","d2e4bef1":"markdown","fc06d689":"markdown","bf0eb55f":"markdown","e0770a14":"markdown","e299c283":"markdown","8703af74":"markdown","e5ec9ffd":"markdown","90846565":"markdown","21b28da6":"markdown","727240d5":"markdown","0147e453":"markdown","023cce9f":"markdown","d44bd583":"markdown","8e6b339b":"markdown","5dd6804f":"markdown","b6b25b56":"markdown","0531a53a":"markdown","8b2d34a1":"markdown","26a676f8":"markdown","573c0915":"markdown","af7b2717":"markdown","76fd6f38":"markdown","24812f7b":"markdown","a7434009":"markdown","2d7ff950":"markdown","09979273":"markdown","1c94525d":"markdown","bcf4ef12":"markdown","385eabe5":"markdown","c0834e02":"markdown","3246912b":"markdown","2995e39e":"markdown","10720683":"markdown","bb6d0bf3":"markdown","bd0245c8":"markdown","b3f8802e":"markdown","4781f81b":"markdown"},"source":{"c799c5e9":"import numpy as np\nimport pandas as pd\nimport sqlite3\nimport matplotlib.pyplot as plt","931c96f1":"pd.options.display.max_rows = 50 # maximum number of rows to display","695da01f":"database_path = \"..\/input\/sqlite-sakila-sample-database\/sqlite-sakila.db\"","ea12f072":"connection = sqlite3.connect(database_path)","40448d07":"tables = pd.read_sql(\"\"\"\n\nSELECT *\nFROM sqlite_master\nWHERE type = 'table';\n\n\"\"\", connection)\n\ntables","53c3a5ad":"pd.read_sql(\"\"\"\n\nSELECT *\nFROM actor;\n\n\"\"\", connection)","835820ff":"pd.read_sql(\"\"\"\n\nSELECT *\nFROM film;\n\n\"\"\", connection)","6093f9cf":"pd.read_sql(\"\"\"\n\nSELECT \n    payment_id\n    ,payment_date\n    ,amount\nFROM payment;\n\n\"\"\", connection)","30a13183":"pd.read_sql(\"\"\"\n\nSELECT COUNT(*)\nFROM payment;\n\n\"\"\", connection)","12fa78bc":"pd.read_sql(\"\"\"\n\nSELECT COUNT(rental_id)\nFROM payment;\n\n\"\"\", connection)","688056d1":"pd.read_sql(\"\"\"\n\nSELECT *\nFROM payment\nWHERE rental_id IS NULL;\n\n\"\"\", connection)","9229c409":"pd.read_sql(\"\"\"\n\nSELECT COUNT(return_date) \nFROM rental\nWHERE return_date IS NULL;\n\n\"\"\", connection)","f625a401":"pd.read_sql(\"\"\"\n\nSELECT COUNT(*) \nFROM rental\nWHERE return_date IS NULL;\n\n\"\"\", connection)","6930e7b6":"pd.read_sql(\"\"\"\n\nSELECT\n    rating\n    ,MIN(length)\n    ,MAX(length)\nFROM film\nWHERE rating = 'PG';\n\n\"\"\", connection)","c40bc39a":"pd.read_sql(\"\"\"\n\nSELECT \n    rating\n    ,MIN(length)\n    ,MAX(length)\n    ,ROUND(AVG(length), 0) AS Average\nFROM film\nGROUP BY rating;\n\n\"\"\", connection)","fc6ff414":"\nfilms_per_rating = pd.read_sql(\"\"\"\n\nSELECT \n    rating AS Rating\n    ,COUNT(title) AS Count\nFROM film\nGROUP BY rating\nORDER BY Count DESC\n\n\"\"\", connection)\n\nfilms_per_rating","0ac60b17":"fig, ax = plt.subplots(figsize = (10,5))\n\nypos = np.arange(len(films_per_rating[\"Count\"]))\nbars = ax.bar(ypos, films_per_rating[\"Count\"], width = 0.50)\nax.set_xticks(ypos)\nax.set_xticklabels(films_per_rating[\"Rating\"])\nax.set_ylim(ymax = 250)\nax.set_title(\"Number of Movies in Each Category\", fontsize = 14)\nax.set_ylabel(\"Number of Movies\", fontsize = 12)\n\nfor bar in bars: # add data labels\n    height = bar.get_height()\n    ax.annotate(f\"{height}\",\n                    xy=(bar.get_x() + bar.get_width() \/ 2, height),\n                    xytext=(0, 3),  # 3 points vertical offset\n                    textcoords=\"offset points\",\n                    ha=\"center\", va=\"bottom\",\n                    fontweight=\"semibold\")\n\nplt.show()","05cd1491":"\nfilms_in_inv = pd.read_sql(\"\"\"\n\nSELECT\n    rating AS Rating\n    ,COUNT(title) AS Count\nFROM inventory AS i\nJOIN film as f\nON i.film_id = f.film_id\nGROUP BY rating\nORDER BY Count DESC\n\n\"\"\", connection)\n\nfilms_in_inv","44226297":"fig, ax = plt.subplots(figsize = (10,5))\n\nypos = np.arange(len(films_in_inv[\"Count\"]))\nbars = ax.bar(ypos, films_in_inv[\"Count\"], width = 0.50)\nax.set_xticks(ypos)\nax.set_xticklabels(films_in_inv[\"Rating\"])\nax.set_ylim(ymax = 1100)\nax.set_title(\"Number of Movies in Each Category Held in Inventory\", fontsize = 14)\nax.set_ylabel(\"Number of Movies Held in Inventory\", fontsize = 12)\n\nfor bar in bars: # add data labels\n    height = bar.get_height()\n    ax.annotate(f\"{height}\",\n                    xy=(bar.get_x() + bar.get_width() \/ 2, height),\n                    xytext=(0, 3),  # 3 points vertical offset\n                    textcoords=\"offset points\",\n                    ha=\"center\", va=\"bottom\")\n\nplt.show()","27802619":"\npd.read_sql(\"\"\"\n\nSELECT \n    f.title AS Title\n    ,COUNT(*) AS Count\n    ,f.rating\nFROM inventory AS i\nJOIN film AS f\nON i.film_id = f.film_id\nWHERE rating = 'PG'\nGROUP BY f.title\nORDER BY Count DESC, Title ASC;\n\n\"\"\", connection)","94b10d31":"pd.read_sql(\"\"\"\n\nSELECT *\nFROM film_actor\nLIMIT 5;\n\n\"\"\", connection)","ccd474f1":"pd.read_sql(\"\"\"\n\nSELECT\n    f.title AS FilmTitle\n    ,a.first_name || ' ' || a.last_name AS Name\nFROM film_actor AS fa\nJOIN film AS f\nON fa.film_id = f.film_id\n\nJOIN actor AS a\nON fa.actor_id = a.actor_id;\n\n\"\"\", connection)","de3ec767":"pd.read_sql(\"\"\"\n\nSELECT\n    a.first_name || ' ' || a.last_name AS Name\n    ,COUNT(f.title) AS Performances\nFROM film_actor AS fa\nJOIN film AS F\nON fa.film_id = f.film_id\n\nJOIN actor AS a\nON fa.actor_id = a.actor_id\nGROUP BY f.title\nORDER BY Performances DESC, Name ASC\n\n\"\"\", connection)","43b4f2b6":"pd.read_sql(\"\"\"\n\nSELECT\n    a.first_name || ' ' || a.last_name AS Name\n    ,COUNT(f.title) AS Performances\nFROM film_actor AS fa\nJOIN film AS F\nON fa.film_id = f.film_id\n\nJOIN actor AS a\nON fa.actor_id = a.actor_id\nGROUP BY f.title\nHAVING Performances > 10\nORDER BY Performances DESC, Name ASC\n\n\"\"\", connection)","61fb1728":"pd.read_sql(\"\"\"\n\nSELECT\n    r.rental_id AS Rental_ID\n    ,f.title AS Title\n    ,strftime('%Y-%m-%d', r.rental_date) AS Rent\n    ,strftime('%Y-%m-%d', r.return_date) AS Return\n    ,ROUND(JULIANDAY(r.return_date) - JULIANDAY(r.rental_date), 2) AS HoldPeriod\n    ,f.rental_duration AS RentalDuration\nFROM rental AS r\nJOIN inventory AS i ON r.inventory_id = i.inventory_id\nJOIN film AS f ON i.film_id = f.film_id\nWHERE r.return_date IS NOT NULL;\n\n\"\"\", connection)","9d775c9b":"pd.read_sql(\"\"\"\n\nSELECT\n    r.rental_id AS Rental_ID\n    ,c.last_name || ', ' || c.first_name AS Name\n    ,c.email\n    ,f.title As Film\n    ,ROUND(JULIANDAY(r.return_date) - JULIANDAY(r.rental_date), 2) - f.rental_duration AS Overdue_Days\nFROM rental AS r\nJOIN inventory AS i ON r.inventory_id = i.inventory_id\nJOIN film AS f ON i.film_id = f.film_id\nJOIN customer AS c ON r.customer_id = c.customer_id\nWHERE r.return_date IS NOT NULL\nAND Overdue_Days > 0;\n\n\"\"\", connection)","21951ccd":"pd.read_sql(\"\"\"\n\nSELECT\n    c.customer_id AS Customer_ID\n    ,c.last_name || ', ' || c.first_name AS Name\n    ,c.email\n    ,COUNT(*) AS Overdue_Count\nFROM rental AS r\nJOIN inventory AS i ON r.inventory_id = i.inventory_id\nJOIN film AS f ON i.film_id = f.film_id\nJOIN customer AS c ON r.customer_id = c.customer_id\nWHERE r.return_date IS NOT NULL\nAND ROUND(JULIANDAY(r.return_date) - JULIANDAY(r.rental_date), 2) - f.rental_duration > 0\nGROUP BY Name\nORDER BY Overdue_Count DESC, Name ASC;\n\n\"\"\", connection)","03dcb9d9":"pd.read_sql(\"\"\"\n\nSELECT \n    customer.customer_id AS Customer_ID\n    ,COUNT(*) AS Total_Count\nFROM rental\nJOIN customer ON rental.customer_id = customer.customer_id\nWHERE return_date IS NOT NULL\nGROUP BY rental.customer_id\nORDER BY Total_Count DESC;\n\n\"\"\", connection)","43130cfa":"pd.read_sql(\"\"\"\n\nSELECT\n    Overdue_Table.Name\n    ,Overdue_Table.email\n    ,ROUND(Overdue_Table.Overdue_Count * 1.0 \/ Total_Table.Total_Count, 2) AS PercentOverdue\n\n-- FIRST TABLE\nFROM (SELECT \n    customer.customer_id AS Customer_ID\n    ,COUNT(*) AS Total_Count\nFROM rental\nJOIN customer ON rental.customer_id = customer.customer_id\nWHERE return_date IS NOT NULL\nGROUP BY rental.customer_id\nORDER BY Total_Count DESC) AS Total_Table\n\n--SECOND TABLE\nJOIN (SELECT\n    c.customer_id AS Customer_ID\n    ,c.last_name || ', ' || c.first_name AS Name\n    ,c.email\n    ,COUNT(*) AS Overdue_Count\nFROM rental AS r\nJOIN inventory AS i ON r.inventory_id = i.inventory_id\nJOIN film AS f ON i.film_id = f.film_id\nJOIN customer AS c ON r.customer_id = c.customer_id\nWHERE r.return_date IS NOT NULL\nAND ROUND(JULIANDAY(r.return_date) - JULIANDAY(r.rental_date), 2) - f.rental_duration > 0\nGROUP BY Name\nORDER BY Overdue_Count DESC, Name ASC) AS Overdue_Table\nON Total_Table.Customer_ID = Overdue_Table.Customer_ID\nORDER BY PercentOverdue DESC;\n\n\"\"\", connection)","5f383b8c":"pd.read_sql(\"\"\"\n\nSELECT \n    r.rental_id\n    ,COUNT(*) AS Count_Payments\nFROM payment AS p\nLEFT JOIN rental AS r\nON p.rental_id = r.rental_id\nGROUP BY p.rental_id\nORDER BY Count_Payments DESC\nLIMIT 10;\n\n\"\"\", connection)","08c28f38":"sales_per_month = pd.read_sql(\"\"\"\n\nSELECT  \n    strftime('%Y-%m', payment_date) AS Date\n    ,ROUND(SUM(amount), 0) AS Sales\nFROM payment\nGROUP BY Date\nORDER BY Date ASC\n\n\"\"\", connection)\n\nsales_per_month","9c90e6f2":"sales_per_month = sales_per_month.iloc[0:4].set_index(\"Date\") # drop the last row and make Date the index","fff7d39b":"fig, ax = plt.subplots(figsize = (10,5))\nax.plot(sales_per_month,\"bo-\")\nax.set_ylim(ymin = 0, ymax = 32000)\nax.set_title(\"Sales Per Month\")\nax.set_ylabel(\"Sales\")\n\nfor date, sales in sales_per_month[\"Sales\"].items():\n    ax.annotate(str(\"${:,.0f}\".format(sales)),\n                xy=(date, sales+1000),\n               fontweight = \"semibold\",\n               fontsize = 12)\n\nplt.show()","be2bae55":"sales_per_store = pd.read_sql(\"\"\"\n\nSELECT  \n    s.store_id\n    ,ROUND(SUM(p.amount), 0) AS Sales\nFROM payment AS p\nJOIN staff AS s\nON p.staff_id = s.staff_id\nGROUP BY p.staff_id\n\n\"\"\", connection).set_index(\"store_id\")\n\nsales_per_store","904709bf":"plt.style.use(\"seaborn\")\nfig, ax = plt.subplots(figsize = (10,5))\n\ndef func(pct, allvals):\n    absolute = int(pct\/100.*np.sum(allvals))\n    return \"${:,.0f}\\n({:.1f}%)\".format(absolute, pct)\n\n\nwedges, texts, autotexts = ax.pie(sales_per_store[\"Sales\"],\n       labels = sales_per_store.index,\n       autopct=lambda pct: func(pct, sales_per_store[\"Sales\"]),\n       textprops=dict(color=\"w\", fontsize = 15, fontweight = \"semibold\"))\nax.legend(wedges, sales_per_store.index,\n          title=\"Store\",\n          fontsize = 12,\n          loc=\"center left\",\n          bbox_to_anchor=(1, 0.2, 0.5, 1))\nax.set_title(\"Sales Per Store\", fontsize = 18)\nplt.rcParams['legend.title_fontsize'] = 18\n\n\nplt.show()","bba3e6ba":"table1 = pd.read_sql(\"\"\"\n\nSELECT \n    inventory_id\n    ,film_id\nFROM inventory;\n\n\"\"\", connection)\n\ntable1.head(10)","5198e487":"table2 = pd.read_sql(\"\"\"\n\nSELECT \n    film_id\n    ,title AS Title\nFROM film\nWHERE rating = 'PG'; \n\n\"\"\", connection)\n\ntable2","f42bbd95":"table3 = table1.merge(table2, on = \"film_id\", how =\"inner\").drop(\"film_id\", axis = 1)\n# once the merge is done on the film_id column, it is not needed and is thus dropped\ntable3.head(20)","c944ea26":"table3.groupby(\"Title\").count().rename(columns = {\"inventory_id\": \"Count\"}).sort_values(by = [\"Count\", \"Title\"], ascending=[False, True]).reset_index()","7d8b2c6b":"<a id=\"subsection-twelve\"><\/a>\n### Overdue rentals \nIn our rental table we have the dates when a movie has been rented and the date when it has been returned. Therefore, we can calculate how many days the customer has held the movie and compare this with the maximum rental duration for the movie , in order to see if they have held it more than \"allowed\" -> was it overdue?\n\nLet's first query this information, before making the comparisons. For the rental and return dates we use the `srtftime()` function to show just the year-month-day i.e. without the exact time. For the holding period we use the `JULIANDAY()` function to calculate the differences between the two dates, because this function calculates fractions of days, which is what we are after in this case. `ROUND()` is used to round the difference to 2 decimal places and `WHERE r.return_date IS NOT NULL` is used because when the return_date is NULL, that means the movie has not been returned yet.","9a58e7e2":"We can now group by the title and get the corresponding count of items. Columns are renamed to create the same table as above.","88fe0a7f":"As we see, this query now returns only 27 rows","419a8302":"<a id=\"subsection-eleven\"><\/a>\n### What movies has each actor starred in and who has starred in the most movies?\nTo answer these questions, we will need information from 3 tables. In this database the film_actor table is used to show which actor has starred in which movie, but only using the actor_id and film_id. Here we use the `LIMIT 5` keyword to retrieve only the top 5 rows of the film_actor table:","182b900c":"Finally, since there are two stores, let's see how much sales each store has generated:","ef5002b2":"As we see, there haven't been multiple payments for one rental and hence no extra has been charged for overdue rentals. Once again, note that this is a sample database. The count of 5 for the NaN are simply the rows we retrieved in an earlier query.\n\nLet's now calculate the total payments i.e. sales for each month. We use `strftime()` to retrieve only the year and month and use the `SUM()` function on the data grouped by Date:","4f008d85":"Although above we saw that there were more R rated movies than there are and PG rated movies (195 vs 194), they change places in this graph, so a higher quanitiy of PG movies are held in inventory relative to R movies (924 vs 904).","6b60f78b":"As we can see, we will have to conduct 2 JOINs on this table to match the actor_id with the corresponding actor name and to match the film_id with the corresponding film title. The || sign is used to concatenate the first and last name of the actor with a space inbetween: ","54adabc2":"<a id=\"subsection-five\"><\/a>\n## Basic SQL Functions","c0b9d5eb":"<a id=\"subsection-thirteen\"><\/a>\n### Payments per rental, payments per date, payments per store\nSince we saw that there have been a lot of overdue rentals, let's now check if there have been extra payments or overdue taxes in cases when a movie has been returned after the maximum rental duration.\n\nHere we use a `LEFT JOIN` because we want to return all payments even if for some reason they are not associated with a rental. Let's group by rental to see if there have been multiple payments for 1 rental:","aa0f15b1":"However, using this method to chech all the categories, one would have to call a number of queries equal to the number of categories, which might be a huge number. \n\nInstead, we can group films of different categories together based on their category and call functions which will work on the different groups separately. Here, we will look at an example using `MIN()`, `MAX()` and `AVG()` on the different rating category groups. For this purpose, we use a `GROUP BY` clause:","2785c03b":"<a id=\"subsection-seven\"><\/a>\n### MIN(), MAX(), AVERAGE() and Aggregation","4e88d4b9":"<a id=\"subsection-nine\"><\/a>\n### What is the total number of movies in each category held in inventory?\nTo answer this question, we will use a concept known as 'joining' tables, using the `JOIN` keyword. What this basically does, is it takes the values from a column in one table and matches them with the corresponding values from a column in another table, thus creating a new merged table.\n\nThere is a plethora of tutorials explaining JOINs, so I will not explain all details and types of JOINs here (like LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN etc.), but I refer you to this short (10-minute) video by [Socratica](https:\/\/www.youtube.com\/channel\/UCW6TXMZ5Pq6yL6_k5NZ2e0Q), which I found was particularly good at explaining JOINs, the different types of JOINs and visualising how they work: [SQL Joins Explained](https:\/\/www.youtube.com\/watch?v=9yeOJ0ZMUYw)\n\nIn our case, we want to take the film_id from the inventory table and match them with the corresponding film_id from the film table. Then we can access the ratings from the film table and group by them. Note the use of aliases for the tables which shortens the query:","d2e4bef1":"We will now use Python's merge() function to JOIN these two tables on a specified column, in this case film_id.\nIn case the names of the columns are different in the two tables, we can specify left_on and right_on.","fc06d689":"We can see that Daisy Bates has had the most overdue rentals, but if she has had, for example, 1000 rentals, this would be proportionally a small number. Therefore, we would need to calculate the percentage of total rentals, which are overdue. Let's first look at the total rentals per customer. Here we query only the customer_id because we will use this table to JOIN with the table above.","bf0eb55f":"We can see that this returns 16044 rows, which is with 5 lower than the previous query. This is because the `COUNT()` function excludes any missing values, that is NULL values, so it appears that there are 5 payments, which do not have a corresponding rental recorded in the database. Let us see how large these payments are. For this purpose, we will use `WHERE` clause and match values which are NULL as follows:","e0770a14":"One additional keyword I would like to discuss here is `HAVING`. `HAVING` can be used to filter aggregated queries, that is: queries which use GROUP BY. `HAVING` is used in SQL because the `WHERE` keyword cannot be used on aggregated queries. Remember the orded of SQL queries explained above: the `WHERE` keyword comes before GROUP BY and the `HAVING` keyword comes after `GROUP BY`. Let's query only the actors who have starred in movies more than 10 times. The following query is the same as the one above except for the addition of `HAVING Performances > 10`:","e299c283":"<a id=\"subsection-six\"><\/a>\n### COUNT()\nWe can use `COUNT()` to count the number of rows in a certain table or a specific column:","8703af74":"## Thank you for reading my notebook!\nI would appreciate any comments and suggestions regarding the contents of this notebook.\n\nHappy SQL learning!","e5ec9ffd":"Or if we wanted to access only specific columns, we could specify this in the `SELECT` clause. I prefer  placing the comma sign at the beginning of each new specified column to make it clear that this is selecting a field instead of calling a new clause, but this is simply personal preference. You can place the comma signs at the end of each row. Indentation also improves readability, so it is a good practice to use it as appropriate:","90846565":"We already knew that the payment table contians 16049 rows, but let's investigate a bit furher. We can `COUNT()` the number of rows in a specific column:","21b28da6":"We can now query the database directly in this environment using pandas' read_sql method.\nWe will first see what tables are available in the dataset. This can be done by accessing the sqlite_master table, which is a table containing the information about the database schema. The * in the `SELECT` clause is used to select all rows, the `FROM` clause specifies which table to select from, and the WHERE clause filters the rows to display only those whose 'type' column is table:","727240d5":"Let's have a look at the film table and see what the minimum and maximum lengths for a movie in each rating category are.\n\nOne way to go about this is to query the table for `MIN(length)` and `MAX(length)` of each rating category (for example 'PG') using a `WHERE` clause:","0147e453":"<a id=\"section-four\"><\/a>\n## Demonstration of Python's merge - equivalent to SQL's JOIN\nFinally, I want to show you the equivalent way to `JOIN` tables in Python. We will again answer a question from above, this time in Python:","023cce9f":"<a id=\"subsection-four\"><\/a>\n### Querying a specific table\nLet's check what data the actor table contains:","d44bd583":"This returns 0 and one might wrongly conclude that no movies are currently out on rent.\n\nHowever, when instead of counting the rows in the return_date column specifically, we count the rows of the entire table using `COUNT(*)` we get a different result, as shown below.\n\nThis is the apporopriate way to go about it, because `WHERE return_date IS NULL` already guarantees that we are counting rows with missing values in the return_date column:","8e6b339b":"We see very big numbers for overdue percentages, but once again, I remind you that this is a fictitious sample database, so the data is likely unrealisic. Note that even though Daisy Bates had the highest number of overdue rentals, she is fourth when percentages of overdue rentals are considered.","5dd6804f":"# SQL Queries, Analysis and Visualization\nThis notebook is intended to provide an overview of SQL - queries, functions, keywords and concepts, and to demonstrate how SQLite3 queries can be executed using Python in a notebook environment.\n\nThe notebook is beginner friendly and queries become progressively more complicated, starting from the SQL fundamentals. The SQL implementation used for this notebook is SQLite3, however, note that different implementations of SQL (MySQL, Oracle, PosgreSQL etc.) use different syntax, therefore, you should refer to the documentation of the specific SQL implementation you are using. Although the syntax differs across platforms, the concepts of using the SQL language are the same, so you can benefit from understanding different SQL implementations.\n\nThe database used is the SQLite version of the Sakila Sample Database, which is an excellent dataset for practicing SQL. You can find detailed information about the database [here](https:\/\/www.kaggle.com\/atanaskanev\/sqlite-sakila-sample-database).","b6b25b56":"We can see that a great number of rentals have been overdue, in fact more than half. This might seem like a huge number and an inadequate result, note, however, that this is a simple fictitious sample database, so the data might not be very realisic.\n\nAnyway, let's now see which customers have had the most overdue rentals. Once again, we group by the customer name and use a `COUNT()` function on the grouped data. Note that the Overdue_Days in this case have been used as a filter in the `WHERE` clause:","0531a53a":"We get the same result as above. As we see, JOINing in SQL and merge()ing in Python are equivalent ways to combine data from two tables together.","8b2d34a1":"Note that the payment table contains 16049 rows.","26a676f8":"Let's now look at some more examples of queries, which will introduce concepts such as ordering, JOINs, subqueries, dates, rounding and more.","573c0915":"<a id=\"section-two\"><\/a>\n## SQL Basics","af7b2717":"Here we have the complete list of film titles matching the actors. Now to answer the second question, we will group by the actor name and count the number of movies they have starred in (we call this Performances):","76fd6f38":"Simply going over the results for HoldPeriod and RentalDuration, we can see that there have been overdue rentals.\n\nLet's now calculate the difference between HoldPeriod and RentalDuration and retrive only these rows which show overdue rentals and query the corresponding customers. To query the corresponding customers, we `JOIN` with the customer table as well:","24812f7b":"<a id=\"subsection-two\"><\/a>\n### Importing libraries","a7434009":"What we see is that there is data only for May, June, July and August 2005 and February 2006. Perhaps the stores were being renovated and hence the business operations were closed for several months and reopened in February 2006, which is considered the \"present\" date.\n\nLet's now visualise these results, excluding the last row for February 2006:","2d7ff950":"# Table of Contents\nClick on any heading to jump straight to the content\n\n[<font size=\"5\">Preparation<\/font>](#subsection-one)\n* [SQL Overview](#subsection-one)\n* [Importing libraries](#subsection-two)\n* [Connecting to the database](#subsection-three)\n\n[<font size=\"5\">SQL Basics<\/font>](#section-two)\n* [Querying a specific table](#subsection-four)\n* [Basic SQL Functions](#subsection-five)\n* [COUNT()](#subsection-six)\n* [MIN(), MAX(), AVERAGE() and Aggregation](#subsection-seven)\n\n[<font size=\"5\">More functions, keywords and concepts (examples)<\/font>](#section-three)\n* [How many movies are there in each rating category?](#subsection-eight)\n* [What is the total number of movies in each category held in inventory?](#subsection-nine)\n* [Which movies of rating 'PG' are held in highest quantity in the inventory?](#subsection-ten)\n* [What movies has each actor starred in and who has starred in the most movies?](#subsection-eleven)\n* [Overdue rentals](#subsection-twelve)\n* [Payments per rental, payments per date, payments per store](#subsection-thirteen)\n\n[<font size=\"5\">Demonstration of Python's merge - equivalent to SQL's JOIN<\/font>](#section-four)\n* [Which movies of rating 'PG' are held in highest quantity in the inventory? (Python version)](#subsection-fourteen)","09979273":"<a id=\"subsection-ten\"><\/a>\n### Which movies of rating 'PG' are held in highest quantity in the inventory?\nLet's look at one more example, for which we include the `WHERE` clause and the `ORDER BY` takes two arguments: it first orders by the Count from highest to lowest and in case there are movies of the same count, they are ordered alphabetically. Once again, note the order of the clauses:","1c94525d":"Now let's calculate the percentage of overdue rentals. The following query might seem very long but it is in fact just the same two tables from above used as subqueries and JOINed together. Subqueries are simply the results from one query used in another query. In this case we use two queries, which we JOIN together on the customer_id, and retrieve columns from the resulting JOINed table. In SQL `--` is used for comments and I have used `-- FISRT TABLE` and `-- SECOND TABLE` to highlight where the tables start.","bcf4ef12":"<a id=\"subsection-fourteen\"><\/a>\n### Which movies of rating 'PG' are held in highest quantity in the inventory? (Python version)\nFirst get the inventory_id and film_id from the inventory table:","385eabe5":"<a id=\"section-three\"><\/a>\n## More functions, keywords and concepts","c0834e02":"As we can see, 183 films are currently out on rent","3246912b":"<a id=\"subsection-three\"><\/a>\n### Connecting to the database","2995e39e":"This is much quicker and automatically shows us the results for all groups present in the data, instead of us having to manually call functions on each individual group.\n\nSomething else you can see from the example is the `AS` keyword. This is used to rename the displayed column or what is known as creating an 'alias'. This helps with readability and can significantly help when writing more complex queries (more on this later).","10720683":"<a id=\"subsection-eight\"><\/a>\n### How many movies are there in each rating category?\nTo answer this question we will once again group by the film's rating and `COUNT()` how many films are in each category. Notice the `ORDER BY` clause, combined with the `DESC` keyword, which stands for \"descending\". This is used to order the results in the query by the Count with the highest count at the top. Also notice the use of aliases to give our results columns appropriate names. We save the query in a variable `films_per_rating` to use it for visualising.","bb6d0bf3":"We can see these are only small payments and the None values in the rental_id column.\n\nNow, caution is required when using `COUNT()` and IS NULL together, because queries including both these clauses might lead to confusion if not understood properly.\n\nIn the rental table when a rented film has not been returned yet, this is represented with a NULL value in the return_date column, logically.\n\nOne might assume that `COUNT()` can be used to retrieve the number of missing values in this column to check how many movies are currently in customers, but note what happens if `COUNT()` and IS NULL are used together: \n","bd0245c8":"<a id=\"subsection-one\"><\/a>\n## SQL Overview\n\nSQL is the language used to interact with relational databases. Relational databases store data in tables (rows and columns), which are connected to each other based on some relationship, hence \"relational\". There is a huge variety of online sources to learn about SQL, so I will not go into all the details. I refer you to this [short 4-minute video](https:\/\/www.youtube.com\/watch?v=27axs9dO7AE) if you want a quick overview of SQL.\n\nThere are a few things I want to mention:\n* First, readability is very important when writing SQL and especially when queries become longer and more complicated. Thefore, it is a good practice to have all SQL keywords capitalized, so they can be easiliy distinguished from column names or tables.\n* It is also a good practice to include ; at the end of the SQL queries, even if the specific SQL implementation does not require it. For example, SQLite3, which is used in this notebook does not require ; at the end of the queries, but it is still placed.\n* The order of SQL clauses is important and if clauses are not ordered as required in a query(e.g. placing WHERE after GROUP BY), this will produce an error. Here is a list with the order in which SQL clauses are to be used. Note that the list does not include all the possible clauses, only those used in this notebook:\n<center>\n <br>SELECT<br>\nFROM<br>\nJOIN ON<br>\nWHERE<br>\nGROUP BY<br>\nHAVING<br>\nORDER BY<br>\nLIMIT\n;","b3f8802e":"And we visualize the results using matplotlib:","4781f81b":"And the film table:"}}