{"cell_type":{"9bce6e7c":"code","057ef752":"code","6b41cdcc":"code","efa22cf7":"code","787fd2ce":"code","2cd5b76a":"code","0ddaf8f3":"code","1c3f21dc":"code","f2071bad":"markdown","fc32bbe6":"markdown","55088c43":"markdown","0a4df535":"markdown","ffa296ad":"markdown","28bc9a79":"markdown","48c37f61":"markdown","d487f09c":"markdown","d77d2101":"markdown","95b71d38":"markdown","81372c38":"markdown","3b07cab4":"markdown","a5a6ab8a":"markdown"},"source":{"9bce6e7c":"import numpy as np\nfrom scipy.stats import skew, kurtosis\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nimport plotly.plotly as py\nimport plotly.graph_objs as go\n\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\n\nfrom html.parser import HTMLParser","057ef752":"class RankParser(HTMLParser):\n\n    def __init__(self):\n        self.entered = False\n        self.sign = ''\n        self.data = []\n        \n        super().__init__()\n    \n    def handle_starttag(self, tag, attrs):\n        if tag == 'td' and ('data-th', 'Change') in attrs:\n            self.entered = True\n            \n        if self.entered and tag == 'span':\n            if len(attrs) > 0 and len(attrs[0]) > 1 and attrs[0][1].startswith('position-change'):\n                direction = attrs[0][1][len('position-change__'):]\n                if direction == 'fallen':\n                    self.sign = '-'                    \n\n    def handle_endtag(self, tag):\n        if self.entered and tag == 'td':\n            self.entered = False\n            self.sign = ''\n\n    def handle_data(self, data):\n        if self.entered:\n            data = '0' if data == '\u2014' else data\n            self.data.append(int(self.sign+data.strip()))\n    \n    def get_data(self):\n        return self.data\n\ndef read_html(file_path):\n    content = open(file_path, encoding='utf-8').read()    \n    parser = RankParser()\n    parser.feed(content)\n    return parser.get_data()","6b41cdcc":"files = [('santander', 'Santander Customer Transaction Prediction _ Kaggle.html'),\n         ('vsb', 'VSB Power Line Fault Detection _ Kaggle.html'),\n         ('malware', 'Microsoft Malware Prediction _ Kaggle.html'),\n         ('whale', 'Humpback Whale Identification _ Kaggle.html'),\n         ('elo', 'Elo Merchant Category Recommendation _ Kaggle.html'),\n         ('quora', 'Quora Insincere Questions Classification _ Kaggle.html'),\n         ('protein', 'Human Protein Atlas Image Classification _ Kaggle.html'),\n         ('plasticc', 'PLAsTiCC Astronomical Classification _ Kaggle.html'),\n         ('quickdraw', 'Quick Draw Doodle Recognition Challenge _ Kaggle.html'),\n         ('salt', 'TGS Salt Identification Challenge _ Kaggle.html'),]\n\nfiles = [(f[0], f'..\/input\/{f[1]}') for f in files]\n\nrank_diff = []\n          \nfor f in files:          \n    rank_diff.append((f[0], read_html(f[1])))","efa22cf7":"def plot_hist(title, diff):\n    stats = \"\"\n    stats += \"count = %d\\n\" % len(diff)\n    stats += \"mean = %.2f\\n\" % np.mean(diff) # always zero because the data are zero-sum\n    stats += \"std = %.4f\\n\" % np.std(diff)\n    stats += \"skew = %.4f\\n\" % skew(diff)\n    stats += \"kurtosis = %.4f\\n\" % kurtosis(diff)\n    \n    fig = plt.figure(figsize=(16, 4))\n    sns.distplot(diff, bins=100)\n    plt.text(0.05, 0.5, stats, transform=plt.gca().transAxes)\n    plt.title(title)\n    plt.show()","787fd2ce":"for rd in rank_diff:\n    plot_hist(rd[0], rd[1])","2cd5b76a":"fig = plt.figure(figsize=(15, 6))  \nsns.barplot([rd[0] for rd in rank_diff], [np.std(rd[1]) for rd in rank_diff])\n#plt.xticks(rotation=90)\nplt.show()","0ddaf8f3":"def plot_candle(title, diff):\n    closes = np.array(range(len(diff)))+1\n    opens = closes + np.array(diff)\n    highs = np.where(np.array(diff)<0, closes, opens)\n    lows =  np.where(np.array(diff)>=0, closes, opens)\n    \n    hovertext = ['private lb: '+str(c)+'<br>public lb: '+str(o) for o, c in zip(opens, closes)]\n\n    trace = go.Ohlc(x=list(range(1, len(diff)+1)), open=opens, high=highs, low=lows, close=closes,\n                    increasing=dict(line=dict(color='#FF6699')), decreasing=dict(line=dict(color='#66DD99')),\n                    text=hovertext, hoverinfo='text')\n    \n    layout = go.Layout(\n        title = \"<b>%s<\/b>\" % title,\n        xaxis = dict(\n            title='final ranks',\n            rangeslider = dict(visible=False)\n        ), \n        yaxis=dict(\n            title='shakeups',\n            autorange='reversed'\n        )\n    )\n    \n    fig = go.Figure(data=[trace], layout=layout)    \n    iplot(fig, filename='shakeup_candlestick')","1c3f21dc":"for rd in rank_diff:\n    plot_candle(rd[0], rd[1])","f2071bad":"# Plot Candlesticks","fc32bbe6":"This section shows histograms of changes from public ranks.","55088c43":"# Visualize the Shakeups of 10 Recent Competitions","0a4df535":"So, in many competitions we can count on our results. However, at the end of some competitions, we might have to expect that the shakeup is near.","ffa296ad":"![title](https:\/\/habrastorage.org\/webt\/vd\/go\/zs\/vdgozs9pbyoroboyjfgup-rw5ju.jpeg)\n<center>(Image from https:\/\/www.kaggle.com\/general\/76963)<\/center>","28bc9a79":"* The shakeups of competitions related to computer vision are significantly smaller comparing to others. This maybe because a mapping from images to labels are well-defined (from human eyes) and the field of computer vision is matured enough to handle overfitting.\n\n\n* There are very small shakeups in Quick, Draw! competition. This is an image classification task with a large amount of data, around 50 million images. It may follow the learning theory which shows that the difference of generalization error and empirical error ($\\triangle R$) is inverse proportion to the size of training data ($N$), or $\\triangle R \\propto \\sqrt{1\/N}$.\n\n\n* In some competitions, such as Quora, the shakeups are also huge but they can be anticipated from reliable local validation.\n\n\n* There are some noticeable patterns in candlestick charts, for example:\n    - The groups of bars that begin and end together may come from the same public kernels.\n    - Some participants that fall heavily maybe because severe overfitting, runtime problems in kernel competitions or other mistakes.\n    - In Santander competition, the top few hundreds have little changes compared to the next portion.\n    - In VSB competition, many top-ranked participants come from the bottom of the public leaderboard. Their methods may be quite similar and do not fit the public data but well suit the private data.","48c37f61":"# Parse Raw Data","d487f09c":"I am relatively new to Kaggle and quite surprised on the huge shakeups of Malware and VSB competions. So I made some visualizations to compare how public and private leaderboards are different in the 10 recent competitions, which were active around the end of the year 2018 and the beginning of the year 2019.","d77d2101":"# Remarks","95b71d38":"Unlike public leaderboards, Kaggle does not provide structured data of private leaderboards. So, I downloaded private leaderboard pages in html and parsed those files to extract relevant information. Here, this kernel uses only change from public rank of each team to visualize.","81372c38":"# Compare Standard Deviations","3b07cab4":"The movement of each team can be shown using candlestick charts. The horizontal axis represents participants ordered by their private ranks. The vertical axis reveals which public ranks they come from. The green bars indicate that the private ranks move up from the public ones, while the red bars point out the opposite.","a5a6ab8a":"# Plot Histograms"}}