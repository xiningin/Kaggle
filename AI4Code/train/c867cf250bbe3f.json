{"cell_type":{"6366eb09":"code","002058ed":"code","e379b8bf":"code","680b7b5d":"code","d1de604c":"code","53d72f2a":"code","d1f4054e":"code","3316f6c2":"code","46664fdf":"code","dd0e548e":"code","4891c2f5":"code","8f1e553e":"code","5e387a5c":"code","beb6af75":"code","1b19fd60":"code","b994831e":"code","3d9ea4cb":"code","1cf41ca5":"code","c0d64e90":"code","d75d066f":"code","1a479741":"code","880825d2":"code","5b3623c6":"code","5cc5e95b":"code","7eaca10b":"code","a17255af":"code","39855a54":"code","c4e19838":"code","e3041108":"code","ca340cd9":"code","625ec3f0":"code","91732db1":"code","5ae66194":"code","fcc0078f":"code","6de02e9c":"code","eab268d1":"code","6d95dbd9":"code","549bfef6":"code","404ac46e":"code","99062a33":"code","db70d0c7":"code","c8c69f39":"markdown","3f6c5502":"markdown","7fc3deef":"markdown","dfe17533":"markdown","26d11fd6":"markdown","789de8b5":"markdown","dc569e45":"markdown","cd558b1f":"markdown","0f29eaad":"markdown","b5a01430":"markdown","89c3a907":"markdown","17b8dccf":"markdown"},"source":{"6366eb09":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib\n%matplotlib inline","002058ed":"import matplotlib.pyplot as plt \nimport seaborn as sns    ","e379b8bf":"df = pd.read_csv('..\/input\/body-fat-prediction-dataset\/bodyfat.csv')","680b7b5d":"df.head()","d1de604c":"df['Weight'] = df['Weight'] * 0.45\ndf['Height'] = df['Height'] * 2.54","53d72f2a":"df","d1f4054e":"df.info()","3316f6c2":"df.corr()","46664fdf":"plt.figure(figsize=(15,15))\nsns.heatmap(data = df.corr(), annot=True, fmt = '.2f', linewidths=.5, cmap='Blues')","dd0e548e":"df.describe()","4891c2f5":"def plot_hist(variables):\n    df[variables].plot.hist()\n    print(variables)\n    plt.show()\n","8f1e553e":"for c1 in list(df.columns):\n    plot_hist(c1)","5e387a5c":"sns.pairplot(df)","beb6af75":"plt.figure(figsize=(15,15))\nsns.boxplot(data=df,color=\"white\",linewidth=3)\nsns.swarmplot(data=df,s=5,alpha=0.65)\nplt.show()","1b19fd60":"def show_feature_importanse(df):\n    plt.figure(figsize=(10,7))\n    lin_imp = abs(df.corr().BodyFat).sort_values(ascending=False).iloc[1:]\n    sns.barplot(lin_imp.index,lin_imp.values,palette=\"Blues_r\")\n    plt.title(\"Feature importances\",fontsize=15)\n    plt.show()","b994831e":"show_feature_importanse(df)","3d9ea4cb":"del df['Density']","1cf41ca5":"df[\"BMI\"] = df.Weight\/(df.Height**2)\ndf.BMI.describe()","c0d64e90":"sns.boxplot(df.BMI)\nplt.title(\"Outlier?\")\nplt.show()","d75d066f":"print(df.shape)\ndf = df.query(\"BMI<0.01\")\nprint(df.shape)","1a479741":"del df['BMI']","880825d2":"df.info()","5b3623c6":"import tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nfrom sklearn.preprocessing import StandardScaler\nimport tensorflow_addons as tfa\nfrom keras.callbacks import EarlyStopping\nfrom keras.callbacks import ModelCheckpoint\nfrom keras.models import load_model","5cc5e95b":"from sklearn.model_selection import train_test_split\n\nx = np.array(df.drop(['BodyFat'], axis=1))\ny = np.array(df['BodyFat'])\n\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.25)","7eaca10b":"scalerX = StandardScaler()\nscalerY = StandardScaler()\n\nx_train_scaled = scalerX.fit_transform(x_train)\nx_test_scaled = scalerX.transform(x_test)","a17255af":"from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import r2_score, mean_squared_error\n\nlr = LinearRegression()\nlr = lr.fit(x_train_scaled, y_train)\n\ny_pred = lr.predict(x_test_scaled)\n\nr2_score_lr = r2_score(y_test, y_pred)\nrmse_lr = mean_squared_error(y_test, y_pred, squared = False)\n\nprint(f'R2 : {r2_score_lr}')\nprint(f'RMSE: {rmse_lr}')\n\nplt.scatter(y_pred, y_test, marker=\"1\")\nplt.xlabel='Predicted BodyFat'\nplt.ylabel='Real BodyFat'","39855a54":"from sklearn.linear_model import Lasso\n\nlasso = Lasso(alpha = 0.5).fit(x_train_scaled, y_train)\n\ny_pred = lasso.predict(x_test_scaled)\n\nr2_score_lasso = r2_score(y_test, y_pred)\nrmse_lasso = mean_squared_error(y_test, y_pred, squared = False)\n\n\nprint(f'R2 : {r2_score_lasso}')\nprint(f'RMSE: {rmse_lasso}')\n\nplt.scatter(y_pred, y_test, marker=\"1\")\nplt.xlabel='Predicted BodyFat'\nplt.ylabel='Real BodyFat'","c4e19838":"from sklearn.linear_model import BayesianRidge\n\nbr = BayesianRidge().fit(x_train_scaled, y_train)\n\ny_pred = br.predict(x_test_scaled)\n\nr2_score_br = r2_score(y_test, y_pred)\nrmse_br = mean_squared_error(y_test, y_pred, squared = False)\n\n\nprint(f'R2 : {r2_score_br}')\nprint(f'RMSE: {rmse_br}')\n\nplt.scatter(y_pred, y_test, marker=\"1\")\nplt.xlabel='Predicted BodyFat'\nplt.ylabel='Real BodyFat'","e3041108":"from sklearn.linear_model import Ridge\n\nridge = Ridge().fit(x_train_scaled, y_train)\n\ny_pred = ridge.predict(x_test_scaled)\n\nr2_score_ridge = r2_score(y_test, y_pred)\nrmse_ridge = mean_squared_error(y_test, y_pred, squared = False)\n\nprint(f'R2 : {r2_score_ridge}')\nprint(f'RMSE: {rmse_ridge}')\n\nplt.scatter(y_pred, y_test, marker=\"1\")\nplt.xlabel='Predicted BodyFat'\nplt.ylabel='Real BodyFat'","ca340cd9":"model = keras.Sequential([\n    layers.InputLayer(input_shape=[13]),\n    layers.Dense(128, activation='relu'),\n    layers.Dropout(0.1),\n    layers.Dense(64, activation='relu'),\n    layers.Dropout(0.1),\n    layers.Dense(32, activation='relu'),\n    layers.Dropout(0.1),\n    layers.Dense(1)\n])\n\nmodel.compile(optimizer=keras.optimizers.Adam(learning_rate=0.001), loss=keras.losses.MeanSquaredError())\nmodel.summary()\n\nmodel_checkpoint = ModelCheckpoint('best_model.h5', monitor='val_loss', mode='min', save_best_only=True)\n\nhistory = model.fit(\n    x_train_scaled, \n    y_train, \n    epochs=200, \n    validation_data=(x_test_scaled, y_test),\n    callbacks=[model_checkpoint]\n)\n\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\n","625ec3f0":"def evaluation(x_test, y_test):\n    model = load_model('best_model.h5')\n    \n    y_pred = model(x_test_scaled)\n    \n    r2_score_lr = r2_score(y_test, y_pred)\n    rmse_lr = mean_squared_error(y_test, y_pred, squared = False)\n\n    print(f'R2 : {r2_score_lr}')\n    print(f'RMSE: {rmse_lr}')\n    \n    plt.scatter(y_pred, y_test, marker=\"1\")\n    plt.xlabel='Predicted BodyFat'\n    plt.ylabel='Real BodyFat'\n        \nevaluation(x_test_scaled, y_test)","91732db1":"model = keras.Sequential([\n    layers.InputLayer(input_shape=[13]),\n    layers.Dense(128, activation='sigmoid'),\n    layers.Dropout(0.1),\n    layers.Dense(64, activation='sigmoid'),\n    layers.Dropout(0.1),\n    layers.Dense(32, activation='relu'),\n    layers.Dropout(0.1),\n    layers.Dense(1)\n])\n\nmodel.compile(optimizer=keras.optimizers.Adam(learning_rate=0.001), loss=keras.losses.MeanSquaredError())\nmodel.summary()\n\nmodel_checkpoint = ModelCheckpoint('best_model.h5', monitor='val_loss', mode='min', save_best_only=True)\n\nhistory = model.fit(\n    x_train_scaled, \n    y_train, \n    epochs=200, \n    validation_data=(x_test_scaled, y_test),\n    callbacks=[model_checkpoint]\n)\n\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])","5ae66194":"evaluation(x_test_scaled, y_test)","fcc0078f":"leaky_relu = tf.nn.leaky_relu\n\nmodel = keras.Sequential([\n    layers.InputLayer(input_shape=[13]),\n    layers.Dense(128, activation=leaky_relu),\n    layers.Dropout(0.1),\n    layers.Dense(64, activation=leaky_relu),\n    layers.Dropout(0.1),\n    layers.Dense(32, activation='relu'),\n    layers.Dropout(0.1),\n    layers.Dense(1)\n])\n\nmodel.compile(optimizer=keras.optimizers.Adam(learning_rate=0.01), loss=keras.losses.MeanSquaredError())\nmodel.summary()\n\nmodel_checkpoint = ModelCheckpoint('best_model.h5', monitor='val_loss', mode='min', save_best_only=True)\n\nhistory = model.fit(\n    x_train_scaled, \n    y_train, \n    epochs=200, \n    validation_data=(x_test_scaled, y_test),\n    callbacks=[model_checkpoint]\n)\n\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])","6de02e9c":"evaluation(x_test_scaled, y_test)","eab268d1":"from tensorflow.keras.models import Model\n\ndef multi_head_model(head_size, dropout):\n    x = layers.Input(shape=[13])\n\n    def head():\n        head = keras.Sequential([\n            layers.Dense(128, activation=leaky_relu),\n            layers.Dropout(dropout),\n            layers.Dense(64, activation=leaky_relu),\n            layers.Dropout(dropout),\n            layers.Dense(32, activation='relu'),\n            layers.Dropout(dropout),\n        ])\n    \n        mid = head(x)\n        mid = Model(inputs=x, outputs=mid)\n    \n        return mid\n\n    z = layers.concatenate([head().output for i in range(0, head_size)])\n    z = layers.Dense(1)(z)\n\n    model = Model(inputs=x, outputs=z)\n    return model\n\nmodel = multi_head_model(\n    head_size=4,\n    dropout=0.1\n)\nmodel.compile(optimizer=keras.optimizers.Adam(learning_rate=0.01), loss=keras.losses.MeanSquaredError())\nmodel.summary()\n\nmodel_checkpoint = ModelCheckpoint('best_model.h5', monitor='val_loss', mode='min', save_best_only=True)\n\nhistory = model.fit(\n    x_train_scaled, \n    y_train, \n    epochs=200, \n    validation_data=(x_test_scaled, y_test),\n    callbacks=[model_checkpoint]\n)\n\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])","6d95dbd9":"evaluation(x_test_scaled, y_test)","549bfef6":"model = multi_head_model(\n    head_size=3, \n    dropout=0.1\n)\nmodel.compile(optimizer=keras.optimizers.Adam(learning_rate=0.01), loss=keras.losses.MeanSquaredError())\nmodel.summary()\n\nmodel_checkpoint = ModelCheckpoint('best_model.h5', monitor='val_loss', mode='min', save_best_only=True)\n\nhistory = model.fit(\n    x_train_scaled, \n    y_train, \n    epochs=200, \n    validation_data=(x_test_scaled, y_test),\n    callbacks=[model_checkpoint]\n)\n\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])","404ac46e":"evaluation(x_test_scaled, y_test)","99062a33":"model = multi_head_model(\n    head_size=2, \n    dropout=0.1\n)\nmodel.compile(optimizer=keras.optimizers.Adam(learning_rate=0.01), loss=keras.losses.MeanSquaredError())\nmodel.summary()\n\nmodel_checkpoint = ModelCheckpoint('best_model.h5', monitor='val_loss', mode='min', save_best_only=True)\n\nhistory = model.fit(\n    x_train_scaled, \n    y_train, \n    epochs=200, \n    validation_data=(x_test_scaled, y_test),\n    callbacks=[model_checkpoint]\n)\n\nplt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])","db70d0c7":"evaluation(x_test_scaled, y_test)","c8c69f39":"## change head size","3f6c5502":"## Deep Learning","7fc3deef":"### Change Activation (leaky_relu)","dfe17533":"## Multi Head","26d11fd6":"## Pre Process","789de8b5":"# Analysis","dc569e45":"## Bayesian Ridge","cd558b1f":"### Change Activation (sigmoid)","0f29eaad":"## Lasso","b5a01430":"## Linear Regression","89c3a907":"## Ridge","17b8dccf":"# Modeling"}}