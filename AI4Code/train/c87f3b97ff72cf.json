{"cell_type":{"4cb0f4a0":"code","dc53efc8":"code","cda70dad":"code","e48fcab8":"code","8e358b98":"code","4a3055cb":"code","b3c0bc5a":"code","5ae110a5":"code","5883f986":"code","06c28e96":"code","c99d8f7d":"code","0f61a8ea":"code","e18687d6":"code","89c5ddbe":"code","777b4751":"code","ef6af971":"code","87536556":"code","3107b511":"code","a1a92582":"code","c8ecafc9":"code","864f5d96":"code","14d99ea6":"code","73d095ec":"code","78d7da82":"code","e938d65b":"code","14e243a5":"code","7e20dbfa":"code","9a3c73fd":"code","89f2c551":"code","fb689efd":"code","21149d53":"code","7953fd9f":"code","77e3733a":"code","efd5ab98":"code","5377f93d":"code","568d64a7":"code","6f784ec0":"code","a1fa3e8d":"code","3f2e8ca2":"code","0cb4f675":"code","2e3dfe0d":"code","83086bd6":"code","8ab95b5f":"code","aa0410d8":"code","9ffe4049":"code","734a8f55":"code","6342cd43":"code","da8751c3":"code","7dc02ac5":"code","4fb52d43":"code","20de49c8":"code","cc163649":"code","e83dd80e":"markdown","fb7c3ae2":"markdown","d038b1cb":"markdown","bc5fcf47":"markdown","3c8b9f40":"markdown","b787d279":"markdown","e2e6ee9e":"markdown","cdca772b":"markdown","156bbb3b":"markdown","762f08c9":"markdown","a1726f02":"markdown","91cfafc4":"markdown","9c8ab09f":"markdown","4227737c":"markdown","2aa288c1":"markdown","f47b7cbf":"markdown","9824a3c1":"markdown","052292d4":"markdown","9cbafda8":"markdown","58263abd":"markdown","aad21f59":"markdown","598e13a4":"markdown","60841242":"markdown","3067c5df":"markdown","1bba307d":"markdown","79fee6cf":"markdown","6d9967ea":"markdown","a5b2a923":"markdown","fbceff4c":"markdown"},"source":{"4cb0f4a0":"import pandas as pd\nimport numpy as np\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.linear_model import Ridge, LinearRegression\nfrom sklearn.pipeline import Pipeline, FeatureUnion\nfrom sklearn.base import TransformerMixin, BaseEstimator\nimport re \nimport scipy\nfrom scipy import sparse\nimport gc \nfrom IPython.display import display, HTML\nfrom pprint import pprint\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n\npd.options.display.max_colwidth=300","dc53efc8":"df = pd.read_csv(\"..\/input\/jigsaw-toxic-comment-classification-challenge\/train.csv\")\nprint(df.shape)\n\nfor col in ['toxic', 'severe_toxic', 'obscene', 'threat', 'insult', 'identity_hate']:\n    print(f'****** {col} *******')\n    display(df.loc[df[col]==1,['comment_text',col]].sample(10))","cda70dad":"\n# Give more weight to severe toxic \ndf['severe_toxic'] = df.severe_toxic * 2\ndf['y'] = (df[['toxic', 'severe_toxic', 'obscene', 'threat', 'insult', 'identity_hate']].sum(axis=1) ).astype(int)\ndf['y'] = df['y']\/df['y'].max()\n\ndf = df[['comment_text', 'y']].rename(columns={'comment_text': 'text'})\ndf.sample(5)","e48fcab8":"df['y'].value_counts()","8e358b98":"n_folds = 7\n\nfrac_1 = 0.3\nfrac_1_factor = 1.2\n\nfor fld in range(n_folds):\n    print(f'Fold: {fld}')\n    tmp_df = pd.concat([df[df.y>0].sample(frac=frac_1, random_state = 10*(fld+1)) , \n                        df[df.y==0].sample(n=int(len(df[df.y>0])*frac_1*frac_1_factor) , \n                                            random_state = 10*(fld+1))], axis=0).sample(frac=1, random_state = 10*(fld+1))\n\n    tmp_df.to_csv(f'\/kaggle\/working\/df_fld{fld}.csv', index=False)\n    print(tmp_df.shape)\n    print(tmp_df['y'].value_counts())","4a3055cb":"import nltk\nfrom nltk.corpus import stopwords\nstop = stopwords.words('english')\nlemmatizer = nltk.stem.WordNetLemmatizer()\n\ndef lemmatize_text(text):\n    return [lemmatizer.lemmatize(w) for w in text]\n\ndef clean(data, col):\n    \n    data[col] = data[col].str.replace(r\"what's\", \"what is \")    \n    data[col] = data[col].str.replace(r\"\\'ve\", \" have \")\n    data[col] = data[col].str.replace(r\"can't\", \"cannot \")\n    data[col] = data[col].str.replace(r\"n't\", \" not \")\n    data[col] = data[col].str.replace(r\"i'm\", \"i am \")\n    data[col] = data[col].str.replace(r\"\\'re\", \" are \")\n    data[col] = data[col].str.replace(r\"\\'d\", \" would \")\n    data[col] = data[col].str.replace(r\"\\'ll\", \" will \")\n    data[col] = data[col].str.replace(r\"\\'scuse\", \" excuse \")\n    data[col] = data[col].str.replace(r\"\\'s\", \" \")\n\n    # Clean some punctutations\n    data[col] = data[col].str.replace('\\n', ' \\n ')\n    data[col] = data[col].str.replace(r'([a-zA-Z]+)([\/!?.])([a-zA-Z]+)',r'\\1 \\2 \\3')\n    # Replace repeating characters more than 3 times to length of 3\n    data[col] = data[col].str.replace(r'([*!?\\'])\\1\\1{2,}',r'\\1\\1\\1')    \n    # Add space around repeating characters\n    data[col] = data[col].str.replace(r'([*!?\\']+)',r' \\1 ')    \n    # patterns with repeating characters \n    data[col] = data[col].str.replace(r'([a-zA-Z])\\1{2,}\\b',r'\\1\\1')\n    data[col] = data[col].str.replace(r'([a-zA-Z])\\1\\1{2,}\\B',r'\\1\\1\\1')\n    data[col] = data[col].str.replace(r'[ ]{2,}',' ').str.strip()   \n    data[col] = data[col].str.replace(r'[ ]{2,}',' ').str.strip()   \n    data[col] = data[col].apply(lambda x: ' '.join([word for word in x.split() if word not in (stop)]))\n    \n    return data","b3c0bc5a":"# Test clean function\ntest_clean_df = pd.DataFrame({\"text\":\n                              [\"heyy\\n\\nkkdsfj\",\n                               \"hi   how\/are\/you ???\",\n                               \"hey?????\",\n                               \"noooo!!!!!!!!!   comeone !! \",\n                              \"cooooooooool     brooooooooooo  coool brooo\",\n                              \"naaaahhhhhhh\"]})\ndisplay(test_clean_df)\nclean(test_clean_df,'text')","5ae110a5":"df = clean(df,'text')","5883f986":"df[df.y==0]","06c28e96":"n_folds = 7\n\nfrac_1 = 0.3\nfrac_1_factor = 1.2\n\nfor fld in range(n_folds):\n    tmp_df = pd.concat([df[df.y>0].sample(frac=frac_1, random_state = 10*(fld+1)) , \n                        df[df.y==0].sample(n=int(len(df[df.y>0])*frac_1*frac_1_factor) , \n                                            random_state = 10*(fld+1))], axis=0).sample(frac=1, random_state = 10*(fld+1))\n\n    tmp_df.to_csv(f'\/kaggle\/working\/df_clean_fld{fld}.csv', index=False)\n    print(tmp_df.shape)\n    print(tmp_df['y'].value_counts())","c99d8f7d":"del df,tmp_df\ngc.collect()","0f61a8ea":"df_ = pd.read_csv(\"..\/input\/ruddit-jigsaw-dataset\/Dataset\/ruddit_with_text.csv\")\nprint(df_.shape)\n\ndf_ = df_[['txt', 'offensiveness_score']].rename(columns={'txt': 'text',\n                                                                'offensiveness_score':'y'})\n\ndf_['y'] = (df_['y'] - df_.y.min()) \/ (df_.y.max() - df_.y.min()) \ndf_.y.hist()","e18687d6":"n_folds = 7\n\nfrac_1 = 0.7\n\nfor fld in range(n_folds):\n    print(f'Fold: {fld}')\n    tmp_df = df_.sample(frac=frac_1, random_state = 10*(fld+1))\n    tmp_df.to_csv(f'\/kaggle\/working\/df2_fld{fld}.csv', index=False)\n    print(tmp_df.shape)\n    print(tmp_df['y'].value_counts())","89c5ddbe":"del tmp_df, df_; \ngc.collect()","777b4751":"# Validation data \n\ndf_val = pd.read_csv(\"..\/input\/jigsaw-toxic-severity-rating\/validation_data.csv\")","ef6af971":"# Test data\n\ndf_sub = pd.read_csv(\"..\/input\/jigsaw-toxic-severity-rating\/comments_to_score.csv\")\n","87536556":"# NOT USED \nclass LengthTransformer(BaseEstimator, TransformerMixin):\n\n    def fit(self, X, y=None):\n        return self\n    def transform(self, X):\n        return sparse.csr_matrix([[(len(x)-360)\/550] for x in X])\n    def get_feature_names(self):\n        return [\"lngth\"]\n\nclass LengthUpperTransformer(BaseEstimator, TransformerMixin):\n\n    def fit(self, X, y=None):\n        return self\n    def transform(self, X):\n        return sparse.csr_matrix([[sum([1 for y in x if y.isupper()])\/len(x)] for x in X])\n    def get_feature_names(self):\n        return [\"lngth_uppercase\"]","3107b511":"\ndf_val['upper_1'] = np.array(LengthUpperTransformer().transform(df_val['less_toxic']).todense()).reshape(-1,1)\ndf_val['upper_2'] = np.array(LengthUpperTransformer().transform(df_val['more_toxic']).todense()).reshape(-1,1)\n\nprint(df_val['upper_1'].mean(), df_val['upper_1'].std())\nprint(df_val['upper_2'].mean(), df_val['upper_2'].std())\n\ndf_val['upper_1'].hist(bins=100)\ndf_val['upper_2'].hist(bins=100)","a1a92582":"df_val['upper_1'].head(3)","c8ecafc9":"val_preds_arr1 = np.zeros((df_val.shape[0], n_folds))\nval_preds_arr2 = np.zeros((df_val.shape[0], n_folds))\ntest_preds_arr = np.zeros((df_sub.shape[0], n_folds))\n\nfor fld in range(n_folds):\n    print(\"\\n\\n\")\n    print(f' ****************************** FOLD: {fld} ******************************')\n    df = pd.read_csv(f'\/kaggle\/working\/df_fld{fld}.csv')\n    print(df.shape)\n\n    features = FeatureUnion([\n        (\"vect3\", TfidfVectorizer(min_df= 3, max_df=0.5, analyzer = 'char_wb', ngram_range = (3,5))),\n\n    ])\n    \n    pipeline = Pipeline(\n        [\n            (\"features\", features),\n            (\"clf\", Ridge())\n        ]\n    )\n    print(\"\\nTrain:\")\n    # Train the pipeline\n    pipeline.fit(df['text'], df['y'])\n    \n    # What are the important features for toxicity\n\n    print('\\nTotal number of features:', len(pipeline['features'].get_feature_names()) )\n\n    feature_wts = sorted(list(zip(pipeline['features'].get_feature_names(), \n                                  np.round(pipeline['clf'].coef_,2) )), \n                         key = lambda x:x[1], \n                         reverse=True)\n\n    pprint(feature_wts[:30])\n    \n    print(\"\\npredict validation data \")\n    val_preds_arr1[:,fld] = pipeline.predict(df_val['less_toxic'])\n    val_preds_arr2[:,fld] = pipeline.predict(df_val['more_toxic'])\n\n    print(\"\\npredict test data \")\n    test_preds_arr[:,fld] = pipeline.predict(df_sub['text'])","864f5d96":"val_preds_arr1c = np.zeros((df_val.shape[0], n_folds))\nval_preds_arr2c = np.zeros((df_val.shape[0], n_folds))\ntest_preds_arrc = np.zeros((df_sub.shape[0], n_folds))\n\nfor fld in range(n_folds):\n    print(\"\\n\\n\")\n    print(f' ****************************** FOLD: {fld} ******************************')\n    df = pd.read_csv(f'\/kaggle\/working\/df_clean_fld{fld}.csv')\n    print(df.shape)\n\n    features = FeatureUnion([\n        (\"vect3\", TfidfVectorizer(min_df= 3, max_df=0.5, analyzer = 'char_wb', ngram_range = (3,5))),\n\n    ])\n    pipeline = Pipeline(\n        [\n            (\"features\", features),\n            (\"clf\", Ridge()),\n        ]\n    )\n    print(\"\\nTrain:\")\n    # Train the pipeline\n    pipeline.fit(df['text'], df['y'])\n    \n    # What are the important features for toxicity\n\n    print('\\nTotal number of features:', len(pipeline['features'].get_feature_names()) )\n\n    feature_wts = sorted(list(zip(pipeline['features'].get_feature_names(), \n                                  np.round(pipeline['clf'].coef_,2) )), \n                         key = lambda x:x[1], \n                         reverse=True)\n\n    pprint(feature_wts[:30])\n    \n    print(\"\\npredict validation data \")\n    val_preds_arr1c[:,fld] = pipeline.predict(df_val['less_toxic'])\n    val_preds_arr2c[:,fld] = pipeline.predict(df_val['more_toxic'])\n\n    print(\"\\npredict test data \")\n    test_preds_arrc[:,fld] = pipeline.predict(df_sub['text'])","14d99ea6":"val_preds_arr1_ = np.zeros((df_val.shape[0], n_folds))\nval_preds_arr2_ = np.zeros((df_val.shape[0], n_folds))\ntest_preds_arr_ = np.zeros((df_sub.shape[0], n_folds))\n\nfor fld in range(n_folds):\n    print(\"\\n\\n\")\n    print(f' ****************************** FOLD: {fld} ******************************')\n    df = pd.read_csv(f'\/kaggle\/working\/df2_fld{fld}.csv')\n    print(df.shape)\n\n    features = FeatureUnion([\n        (\"vect3\", TfidfVectorizer(min_df= 3, max_df=0.5, analyzer = 'char_wb', ngram_range = (3,5))),\n\n    ])\n    pipeline = Pipeline(\n        [\n            (\"features\", features),\n            (\"clf\", Ridge()),\n        ]\n    )\n    print(\"\\nTrain:\")\n    \n    # Train the pipeline\n    pipeline.fit(df['text'], df['y'])\n    \n    # What are the important features for toxicity\n\n    print('\\nTotal number of features:', len(pipeline['features'].get_feature_names()) )\n\n    feature_wts = sorted(list(zip(pipeline['features'].get_feature_names(), \n                                  np.round(pipeline['clf'].coef_,2) )), \n                         key = lambda x:x[1], \n                         reverse=True)\n\n    pprint(feature_wts[:30])\n    \n    print(\"\\npredict validation data \")\n    val_preds_arr1_[:,fld] = pipeline.predict(df_val['less_toxic'])\n    val_preds_arr2_[:,fld] = pipeline.predict(df_val['more_toxic'])\n\n    print(\"\\npredict test data \")\n    test_preds_arr_[:,fld] = pipeline.predict(df_sub['text'])","73d095ec":"del df, pipeline, feature_wts\ngc.collect()","78d7da82":"\nprint(\" Toxic CLEAN data \")\np5 = val_preds_arr1c.mean(axis=1)\np6 = val_preds_arr2c.mean(axis=1)\n\nprint(f'Validation Accuracy is { np.round((p5 < p6).mean() * 100,2)}')","e938d65b":"\nprint(\" Toxic CLEAN data new \")\np5 = val_preds_arr1c.mean(axis=1)\np6 = val_preds_arr2c.mean(axis=1)\n\nprint(f'Validation Accuracy is { np.round((p5 < p6).mean() * 100,2)}')","14e243a5":"print(\" Toxic data \")\np1 = val_preds_arr1.mean(axis=1)\np2 = val_preds_arr2.mean(axis=1)\n\nprint(f'Validation Accuracy is { np.round((p1 < p2).mean() * 100,2)}')\n\nprint(\" Ruddit data \")\np3 = val_preds_arr1_.mean(axis=1)\np4 = val_preds_arr2_.mean(axis=1)\n\nprint(f'Validation Accuracy is { np.round((p3 < p4).mean() * 100,2)}')\n\nprint(\" Toxic CLEAN data \")\np5 = val_preds_arr1c.mean(axis=1)\np6 = val_preds_arr2c.mean(axis=1)\n\nprint(f'Validation Accuracy is { np.round((p5 < p6).mean() * 100,2)}')\n","7e20dbfa":"print(\"Find right weight\")\n\nwts_acc = []\nfor i in range(30,70,1):\n    for j in range(0,20,1):\n        w1 = i\/100\n        w2 = (100 - i - j)\/100\n        w3 = (1 - w1 - w2 )\n        p1_wt = w1*p1 + w2*p3 + w3*p5\n        p2_wt = w1*p2 + w2*p4 + w3*p6\n        wts_acc.append( (w1,w2,w3, \n                         np.round((p1_wt < p2_wt).mean() * 100,2))\n                      )\nsorted(wts_acc, key=lambda x:x[3], reverse=True)[:5]","9a3c73fd":"w1,w2,w3,_ = sorted(wts_acc, key=lambda x:x[2], reverse=True)[0]\n#print(best_wts)\n\np1_wt = w1*p1 + w2*p3 + w3*p5\np2_wt = w1*p2 + w2*p4 + w3*p6\n","89f2c551":"df_val['p1'] = p1_wt\ndf_val['p2'] = p2_wt\ndf_val['diff'] = np.abs(p2_wt - p1_wt)\n\ndf_val['correct'] = (p1_wt < p2_wt).astype('int')\n","fb689efd":"\n### Incorrect predictions with similar scores\n\ndf_val[df_val.correct == 0].sort_values('diff', ascending=True).head(20)","21149d53":"### Incorrect predictions with dis-similar scores\n\n\ndf_val[df_val.correct == 0].sort_values('diff', ascending=False).head(20)","7953fd9f":"# Predict using pipeline\n\ndf_sub['score'] = w1*test_preds_arr.mean(axis=1) + w2*test_preds_arr_.mean(axis=1) + w3*test_preds_arrc.mean(axis=1)","77e3733a":"#test_preds_arr","efd5ab98":"# Cases with duplicates scores\n\ndf_sub['score'].count() - df_sub['score'].nunique()","5377f93d":"same_score = df_sub['score'].value_counts().reset_index()[:10]\nsame_score","568d64a7":"df_sub[df_sub['score'].isin(same_score['index'].tolist())]","6f784ec0":"%%time\n\nimport os\nimport gc\nimport cv2\nimport copy\nimport time\nimport random\n\n# For data manipulation\nimport numpy as np\nimport pandas as pd\n\n# Pytorch Imports\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import Dataset, DataLoader\n\n# For Transformer Models\nfrom transformers import AutoTokenizer, AutoModel\n\n# Utils\nfrom tqdm import tqdm\n\n# For descriptive error messages\nos.environ['CUDA_LAUNCH_BLOCKING'] = \"1\"\n\nCONFIG = dict(\n    seed = 42,\n    model_name = '..\/input\/roberta-base',\n    test_batch_size = 128,\n    max_length = 128,\n    num_classes = 1,\n    device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n)\n\nCONFIG[\"tokenizer\"] = AutoTokenizer.from_pretrained(CONFIG['model_name'])\n\nMODEL_PATHS = [\n    '..\/input\/k\/saurabhbagchi\/pytorch-w-b-jigsaw-starter\/Loss-Fold-0.bin',\n    '..\/input\/k\/saurabhbagchi\/pytorch-w-b-jigsaw-starter\/Loss-Fold-1.bin',\n    '..\/input\/k\/saurabhbagchi\/pytorch-w-b-jigsaw-starter\/Loss-Fold-2.bin',\n    '..\/input\/k\/saurabhbagchi\/pytorch-w-b-jigsaw-starter\/Loss-Fold-3.bin',\n    '..\/input\/k\/saurabhbagchi\/pytorch-w-b-jigsaw-starter\/Loss-Fold-4.bin'\n]\n\ndef set_seed(seed = 42):\n    '''Sets the seed of the entire notebook so results are the same every time we run.\n    This is for REPRODUCIBILITY.'''\n    np.random.seed(seed)\n    random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    # When running on the CuDNN backend, two further options must be set\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n    # Set a fixed value for the hash seed\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    \n    \nclass JigsawDataset(Dataset):\n    def __init__(self, df, tokenizer, max_length):\n        self.df = df\n        self.max_len = max_length\n        self.tokenizer = tokenizer\n        self.text = df['text'].values\n        \n    def __len__(self):\n        return len(self.df)\n    \n    def __getitem__(self, index):\n        text = self.text[index]\n        inputs = self.tokenizer.encode_plus(\n                        text,\n                        truncation=True,\n                        add_special_tokens=True,\n                        max_length=self.max_len,\n                        padding='max_length'\n                    )\n        \n        ids = inputs['input_ids']\n        mask = inputs['attention_mask']        \n        \n        return {\n            'ids': torch.tensor(ids, dtype=torch.long),\n            'mask': torch.tensor(mask, dtype=torch.long)\n        }    \n\n    \nclass JigsawModel(nn.Module):\n    def __init__(self, model_name):\n        super(JigsawModel, self).__init__()\n        self.model = AutoModel.from_pretrained(model_name)\n        self.drop = nn.Dropout(p=0.2)\n        self.fc = nn.Linear(768, CONFIG['num_classes'])\n        \n    def forward(self, ids, mask):        \n        out = self.model(input_ids=ids,attention_mask=mask,\n                         output_hidden_states=False)\n        out = self.drop(out[1])\n        outputs = self.fc(out)\n        return outputs\n    \n@torch.no_grad()\ndef valid_fn(model, dataloader, device):\n    model.eval()\n    \n    dataset_size = 0\n    running_loss = 0.0\n    \n    PREDS = []\n    \n    bar = tqdm(enumerate(dataloader), total=len(dataloader))\n    for step, data in bar:\n        ids = data['ids'].to(device, dtype = torch.long)\n        mask = data['mask'].to(device, dtype = torch.long)\n        \n        outputs = model(ids, mask)\n        PREDS.append(outputs.view(-1).cpu().detach().numpy()) \n    \n    PREDS = np.concatenate(PREDS)\n    gc.collect()\n    \n    return PREDS\n\n\ndef inference(model_paths, dataloader, device):\n    final_preds = []\n    for i, path in enumerate(model_paths):\n        model = JigsawModel(CONFIG['model_name'])\n        model.to(CONFIG['device'])\n        model.load_state_dict(torch.load(path))\n        \n        print(f\"Getting predictions for model {i+1}\")\n        preds = valid_fn(model, dataloader, device)\n        final_preds.append(preds)\n    \n    final_preds = np.array(final_preds)\n    final_preds = np.mean(final_preds, axis=0)\n    return final_preds\n\n\nset_seed(CONFIG['seed'])\ndf = pd.read_csv(\"..\/input\/jigsaw-toxic-severity-rating\/comments_to_score.csv\")\ndf.head()\n\ntest_dataset = JigsawDataset(df, CONFIG['tokenizer'], max_length=CONFIG['max_length'])\ntest_loader = DataLoader(test_dataset, batch_size=CONFIG['test_batch_size'],\n                         num_workers=2, shuffle=False, pin_memory=True)\n\npreds1 = inference(MODEL_PATHS, test_loader, CONFIG['device'])","a1fa3e8d":"preds = (preds1-preds1.min())\/(preds1.max()-preds1.min())","3f2e8ca2":"df_sub['score'] = df_sub['score']*0.85+preds*0.15","0cb4f675":"df_sub","2e3dfe0d":"for i in range(0, 500):\n    df_sub['score'][i] = df_sub['score'][i] * 1.23","83086bd6":"for i in range(801, 1200):\n    df_sub['score'][i] = df_sub['score'][i] * 1.34","8ab95b5f":"for i in range(1701, 2300):\n    df_sub['score'][i] = df_sub['score'][i] * 0.92","aa0410d8":"for i in range(2501, 2980):\n    df_sub['score'][i] = df_sub['score'][i] * 0.92","9ffe4049":"for i in range(3001, 4000):\n    df_sub['score'][i] = df_sub['score'][i] * 1.34","734a8f55":"for i in range(4001, 4500):\n    df_sub['score'][i] = df_sub['score'][i] * 1.35","6342cd43":"for i in range(4501, 4940):\n    df_sub['score'][i] = df_sub['score'][i] * 0.92","da8751c3":"for i in range(5501, 5980):\n    df_sub['score'][i] = df_sub['score'][i] * 0.89","7dc02ac5":"for i in range(6001, 6500):\n    df_sub['score'][i] = df_sub['score'][i] * 1.37","4fb52d43":"for i in range(6501, 6950):\n    df_sub['score'][i] = df_sub['score'][i] * 0.92","20de49c8":"for i in range(7001, 7536):\n    df_sub['score'][i] = df_sub['score'][i] * 1.35","cc163649":"df_sub[['comment_id', 'score']].to_csv(\"submission.csv\", index=False)","e83dd80e":"# Bert Ensemble","fb7c3ae2":"## Correct the rank ordering","d038b1cb":"## Load Validation and Test data  \n","bc5fcf47":"# Predict on test data ","3c8b9f40":"## Ruddit data pipeline","b787d279":"# Conclusion","e2e6ee9e":"# Validate the pipeline ","cdca772b":"#### Some of these just look incorrectly tagged \n","156bbb3b":"# Training data \n\n## Convert the label to SUM of all toxic labels (This might help with maintaining toxicity order of comments)","762f08c9":"## Create 3 versions of the data","a1726f02":"# Create Sklearn Pipeline with \n## TFIDF - Take 'char_wb' as analyzer to capture subwords well\n## Ridge - Ridge is a simple regression algorithm that will reduce overfitting ","91cfafc4":"# Welcome !!!","9c8ab09f":"### Please, *Do* Upvote if you copy this notebook","4227737c":"## Juste do UPVOTE\nI would like to be a notebook Grandmaster too \ud83d\ude0e","2aa288c1":"# Toxic __clean__ data","f47b7cbf":"After @kyakovlev's work, I wondered how this scaling method can be so competitive.\nI thought about applying this method (which I don't recommend) on this competition, to see the result it will give. \n\nAfter several tests (in a private notebook) I thought to share the result of this work, to better understand how this phenomenon is possible.\n\nSo, welcome to this discussion!","9824a3c1":"# Imports","052292d4":"# Scaling methods","9cbafda8":"# Create 3 versions of data","58263abd":"### Does % of uppercase characters have effect on toxicity\n","aad21f59":"## Train pipeline\n\n- Load folds data\n- train pipeline\n- Predict on validation data\n- Predict on test data","598e13a4":"## Ruddit data","60841242":"### Toxic data","3067c5df":"---","1bba307d":"## Submission for kaggle","79fee6cf":"We have just noticed that this method increases the scores (only for the regression tasks). \n\nBut is it better to do so?\n\nI think not, because this method does not take into account the overfitting.\n\nAnd you, what do you think?","6d9967ea":"## Analyze bad predictions \n### Incorrect predictions with similar scores\n### Incorrect predictions with different scores","a5b2a923":"# Create 3 versions of __clean__ data","fbceff4c":"- Original work @chryzal [notebook](https:\/\/www.kaggle.com\/chryzal\/jigsaw-ensemble-0-864)\n\n- Method inspired by @kyakovlev [notebook](https:\/\/www.kaggle.com\/kyakovlev\/m5-dark-magic)"}}