{"cell_type":{"e11ab037":"code","335d6464":"code","a1737c47":"code","f6879184":"code","53f26b06":"code","2427d35f":"code","300d0b36":"code","86f4478d":"code","629565cf":"code","a974ec0b":"code","7e83b903":"code","4746d96c":"code","af94227c":"markdown","4ad05432":"markdown","ed61b19f":"markdown","402a7282":"markdown","1ea43072":"markdown","76a0be25":"markdown","9242afe2":"markdown","c261068b":"markdown","d672a36e":"markdown","48412f6e":"markdown"},"source":{"e11ab037":"import numpy as np\nfrom scipy.integrate import odeint\nfrom scipy.optimize import differential_evolution\nfrom matplotlib import pyplot as plt","335d6464":"def force(omega, b):\n    return b * omega ** 2","a1737c47":"def quadrotor_model(X, t, m, g, K, I, Jr, l, b, d, O):\n    x, y, z, vx, vy, vz, phi, theta, psi, vphi, vtheta, vpsi = X\n\n    K1, K2, K3, K4, K5, K6 = K\n    Ix, Iy, Iz = I\n\n    forces = force(O, b)\n    Or = O[0] - O[1] + O[2] - O[3]\n    u1, u2, u3, u4 = [forces.sum(), -forces[1] + forces[3], -forces[0] + forces[2], d * (-forces[0] + forces[1] + forces[2] + forces[3]) \/ b]\n\n    dxdt = vx\n    dvxdt = (1 \/ m) * (np.cos(phi) * np.sin(theta) * np.cos(psi) + np.sin(phi) * np.sin(psi)) * u1 - ((K1 * vx) \/ m)\n\n    dydt = vy\n    dvydt = (1 \/ m) * (np.cos(phi) * np.sin(theta) * np.sin(psi) - np.sin(phi) * np.cos(psi)) * u1 - ((K2 * vy) \/ m)\n\n    dzdt = vz\n    dvzdt = (1 \/ m) * (np.cos(phi) * np.cos(theta)) * u1 - g - ((K3 * vz) \/ m)\n\n    dphidt = vphi\n    dvphidt = (vtheta * vpsi * ((Iy - Iz) \/ Ix)) + ((Jr \/ Ix) * vtheta * Or) + ((l \/ Ix) * u2) - (((K4 * l) \/ Ix) * vphi)\n\n    dthetadt = vtheta\n    dvthetadt = (vpsi * vphi * ((Iz - Ix) \/ Iy)) - ((Jr \/ Iy) * vphi * Or) + ((l \/ Iy) * u3) - (((K5 * l) \/ Iy) * vtheta)\n\n    dpsidt = vpsi\n    dvpsidt = (vphi * vtheta * ((Ix - Iy) \/ Iz)) + ((l \/ Iz) * u4) - ((K6 \/ Iz) * vpsi)\n\n    return dxdt, dydt, dzdt, dvxdt, dvydt, dvzdt, dphidt, dthetadt, dpsidt, dvphidt, dvthetadt, dvpsidt","f6879184":"m = 2.0 # kg\nIx = Iy = 1.25 # Ns^2\/rad\nIz = 2.2 # Ns^2\/rad\nK1 = K2 = K3 = 0.01 # Ns\/m\nK4 = K5 = K6 = 0.012 # Ns\/m\nl = 0.20 # m\nJr = 1 # Ns^2\/rad\nb = 2 # Ns^2\nd = 5 # N ms^2\ng = 9.8 # m\/s^2","53f26b06":"T = 1000\nt = np.linspace(0, 40, T)","2427d35f":"# Set-point\nSP = np.zeros(len(t))\nSP[:round(20 \/ 40 * 1000)] = 5\nSP[round(20 \/ 40 * 1000):round(35 \/ 40 * 1000)] = 10\nSP[round(35 \/ 40 * 1000):] = 0\n# Kp, Ki, Kd\n# K0 = [100, 10, 0]","300d0b36":"def cost(x, t, T, SP):\n    if np.any(x < 0):\n        return np.inf\n\n    # O = np.zeros((len(t), 4))\n    O = np.array([0, 0, 0, 0], dtype=float)\n    y0 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) # initial state\n    e = np.zeros(len(t))\n    I = 0.0\n    D = 0.0\n    Y = np.zeros((T, len(y0)))\n    Y[0] = y0\n\n    Kp, Ki, Kd = x\n\n    for i in range(len(t) - 1):\n        e[i] = SP[i] - y0[2]\n        \n        P = Kp * e[i]\n        I += Ki * e[i] * (t[i + 1] - t[i])\n        if i >= 1:\n            D = Kd * ((e[i] - e[i - 1]) \/ (t[i] - t[i - 1]))\n\n        O += P + I + D\n\n        if np.any(O > 2):\n            O[:] = 2\n            I -= e[i] * (t[i + 1] - t[i])\n        if np.any(O < 0):\n            O[:] = 0\n            I -= e[i] * (t[i + 1] - t[i])\n\n        y_t = odeint(quadrotor_model, y0, [t[i], t[i + 1]], args=(m, g, (K1, K2, K3, K4, K5, K6), (Ix, Iy, Iz), Jr, l, b, d, O))\n        y0 = y_t[1]\n        Y[i + 1] = y0\n    \n    return (e ** 2).sum() \/ len(e)","86f4478d":"res = differential_evolution(cost, ((1, 10000), (1, 10000), (1, 10000)), args=(t, T, SP), disp=True)","629565cf":"res","a974ec0b":"def test(x):\n    O = np.array([0, 0, 0, 0], dtype=float)\n    y0 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) # initial state\n    e = np.zeros(len(t))\n    I = 0.0\n    D = 0.0\n    Y = np.zeros((T, len(y0)))\n    Y[0] = y0\n\n    Kp, Ki, Kd = x\n\n    for i in range(len(t) - 1):\n        e[i] = SP[i] - y0[2]\n        \n        P = Kp * e[i]\n        I += Ki * e[i] * (t[i + 1] - t[i])\n        if i >= 1:\n            D = Kd * ((e[i] - e[i - 1]) \/ (t[i] - t[i - 1]))\n\n        O += P + I + D\n\n        if np.any(O > 2):\n            O[:] = 2\n            I -= e[i] * (t[i + 1] - t[i])\n        if np.any(O < 0):\n            O[:] = 0\n            I -= e[i] * (t[i + 1] - t[i])\n\n        y_t = odeint(quadrotor_model, y0, [t[i], t[i + 1]], args=(m, g, (K1, K2, K3, K4, K5, K6), (Ix, Iy, Iz), Jr, l, b, d, O))\n        y0 = y_t[1]\n        Y[i + 1] = y0\n        \n    return Y, e","7e83b903":"x, y, z, vx, vy, vz, phi, theta, psi, vphi, vtheta, vpsi = np.arange(12)","4746d96c":"Y, e = test(res.x)\nplt.figure(figsize=(20, 5))\nplt.plot(t, Y[:, z], label=\"Process Variable\")\nplt.plot(t, SP, \"--\", label=\"Set-point\")\nplt.legend()\nplt.show()","af94227c":"The optimization results are presented below. The `x` attribute is the tuned PID gains.","4ad05432":"The essential part of every optimization problem is the *cost function*. It may sometimes called as the *loss function* or *objective function*. It is the function to be minimized or maximized. In this case, for the first version, I will only try to maintain a certain altitude. This means that I will only try to get a constant $Z$ coordinate in the space. Thus, I defined my objective funtion as follows:\n\n$$\nSE = \\frac{1}{T} \\int_{0}^{T} e^2(t) dt\n$$\n\nwhere, $T$ is the total simulation time and $e(t)$ is the error defined as:\n\n$$\ne(t) = SP - PV\n$$\n\nwhere, $SP$ is the set-point variable which is the desired value of the PV and PV is the process variable. It is commonly measured by onboard sensors such as Inertial Measurement Units (IMUs).\n\nIn a basic quadrotor, there should be at least 4 controllers to control each of the pitch ($\\phi$), roll ($\\theta$), yaw ($\\psi$), and altitude ($Z$). But, I will use only one controller for the first version of this notebook.\n\nTo calculate the overall cost, one should run all of the simulation. The below function runs the whole simulation, and calculates error for each time step. Then, by using the calculated error each of the Proportional, Integral and Derivative parts of the PID controller is computed. You can see the overall PID equation.\n\n$$\nPID = K_p e(t) + K_i \\int_{t_0}^{t_f} e(t) dt + K_d \\frac{d e(t)}{dt}\n$$","ed61b19f":"# Tuning PID Controller of a Quadcopter Model\n\nThis notebook is a compensation material for the paper of ours which is called [Effect of PSO Tuned P, PD, and PID Controllers on the Stability of a Quadrotor](https:\/\/ieeexplore.ieee.org\/abstract\/document\/8965487) [1]. The original idea of the paper is to tune a PID controller of a quadcopter model via Particle Swarm Optimization (PSO). However, we used the model from a ready-to-use Matlab package which is named as [The qrsim quadrotors simulator](http:\/\/citeseerx.ist.psu.edu\/viewdoc\/download?doi=10.1.1.360.8300&rep=rep1&type=pdf) [2]. Here, I am trying to use a second order ODE to model the behaviour of a quadrotor. The ODE is taken from a paper called [Position and attitude tracking control for a quadrotor UAV](https:\/\/www.sciencedirect.com\/science\/article\/pii\/S0019057814000081?casa_token=iuAAsBb4ejoAAAAA:Ls9xx0qYvLxoZsg1Va5ZW126NZuQifoFy37OgpfHMfcsk387njuzxEGw8hblLgIL1syZUfltpx0) [3].\n\nSo, let's start by importing the necessary packages.\n- The first package we need, of course, *Numpy* since we always need some linear algebra.\n- Second, the `odeint` function from *Scipy* to solve first order system of non-linear ordinary differential equations.\n- Third, a stochastic algorithm called `differential_evolution` from *Scipy* is needed to optimize the controller. In the original paper, we used PSO as the optimizer but here I just used a ready-to-use optimizer. Of course, there are lots of choices. Maybe I will try some of them in the later versions.\n- Finally, the fourth one is the *Matplotlib* to plot some figures.","402a7282":"In the cell below, you can see each of the constants to be used in the above equations and their respected units.","1ea43072":"You can see the quadcopter follows the path exactly.","76a0be25":"The most crucial part of this notebook is the quadcopter model. Below, you can see the second order ODE model of the quadcopter and in the following cell, you can see the equivalent first order system of ODE of the second order ODE model.\n\n$$\n\\ddot{x} = \\frac{1}{m} (\\cos{\\phi} \\sin{\\theta} \\cos {\\psi} + \\sin{\\phi} \\sin {\\psi}) u_1 - \\frac{K_1 \\dot{x}}{m} \\\\\n\\ddot{y} = \\frac{1}{m} (\\cos{\\phi} \\sin{\\theta} \\sin {\\psi} - \\sin{\\phi} \\cos {\\psi}) u_1 - \\frac{K_2 \\dot{y}}{m} \\\\\n\\ddot{z} = \\frac{1}{m} (\\cos{\\phi} \\cos{\\theta}) u_1 - g - \\frac{K_3 \\dot{z}}{m} \\\\\n\\ddot{\\phi} = \\dot{\\theta} \\dot{\\psi} \\frac{I_y - I_z}{I_x} + \\frac{J_r}{I_x} \\dot{\\theta} \\Omega_r + \\frac{l}{I_x} u_2 - \\frac{K_4 l}{I_x} \\dot{\\phi} \\\\\n\\ddot{\\theta} = \\dot{\\psi} \\dot{\\phi} \\frac{I_z - I_x}{I_y} + \\frac{J_r}{I_y} \\dot{\\phi} \\Omega_r + \\frac{l}{I_y} u_3 - \\frac{K_5 l}{I_y} \\dot{\\theta} \\\\\n\\ddot{\\psi} = \\dot{\\phi} \\dot{\\theta} \\frac{I_x - I_y}{I_z} + \\frac{l}{I_z} u_4 - \\frac{K_6}{I_z} \\dot{\\psi}\n$$","9242afe2":"For the path above, one must find the optimum PID gains. The range of the gains are from 1 to 10000. The `differential_evolution` takes care of the optimization part and it generally does a great job.","c261068b":"The force equation is borrowed from [3]. It is actually a constant `b` times the square of angular speed of rotor `i`. Here, $\\Omega_i$ is a vector of 4 dimensions for each of the rotors of a quadrotor. Quadrotor and quadcopter essentially indicate the same things and are used interchangeably. You can see the force equation below.\n\n$$\nF_i = b \\Omega_i^2\n$$","d672a36e":"Below, I draw a altitude path for the quadcopter to fly. For the first 20 seconds of the simulation, quadcopter should fly with an altitude of 5 meters. From 20th second to the 35th second, the quadcopter's altitude should be 10 meters. From 35th second to the end, the quadcopter's altitude should be 0. However, the quadcopter also fall from the 0 meter to the negative infinity. So, it must maintain its altitude all the times.","48412f6e":"Please make a comment, if you see any problems in the code or want to make a suggestion. Thanks."}}