{"cell_type":{"c02cc832":"code","d789f67c":"code","5b573d64":"code","7f440858":"code","90c90e49":"code","89cf243d":"code","829cb372":"code","7da240d3":"code","2d4cdc37":"code","f2a14586":"code","3165739f":"code","b7840e4f":"code","9496cadc":"code","7b4e4e05":"code","eeac8d62":"code","357a91b1":"code","8bdbe7f6":"code","448d2faf":"code","9d882e03":"code","d3a24a9d":"code","be7d0bd2":"code","db7e4296":"code","84cdf7e3":"code","b9760a76":"code","61c5e926":"code","0cce91cc":"code","26903be8":"code","819da195":"code","d5a7a6cf":"code","26bfa581":"code","88af0fbb":"markdown","42aecb18":"markdown","0d492c3c":"markdown","fa60a16a":"markdown","0510c24e":"markdown","38a44b0c":"markdown","49ae56cf":"markdown","c497513c":"markdown","7bb9af71":"markdown","4a735ce6":"markdown","fa8413b1":"markdown","36917798":"markdown"},"source":{"c02cc832":"import numpy as np\nimport pandas as pd","d789f67c":"import PIL\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\nimport tensorflow as tf\n\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D\nfrom tensorflow.keras.preprocessing import image","5b573d64":"## Defining the path to the datasets\nkey_points_data_path = \"..\/input\/celeba-dataset\/list_landmarks_align_celeba.csv\"\nimages_data_path = \"..\/input\/celeba-dataset\/img_align_celeba\/img_align_celeba\"\n\n# Since, the dataset is very huge. Hence, we will only select 10000K images\nimages_data_size = 10000\n\n# Original image dimensions\nx_org = 178    # original x value\ny_org = 218    # original y value\n\n#Let's scale the images to new dimensions\n\n# New image dimensions\nx_ = 100                            # new value of x\nimage_size_ratio = x_org \/ y_org    # dimensions ratio\ny_ = int(image_size_ratio * x_)     # new value of y\n\n# Image Sizes\noriginal_image_size = (x_org, y_org)\nnew_image_size = (x_,y_)\n\n# The image size that will be used in the training process\nimage_size_training = new_image_size\n","7f440858":"# load the dataset (key points)\ndf_org = pd.read_csv(key_points_data_path)\ndf_org = df_org[:images_data_size]","90c90e49":"images_data = list()\nfor idx in range(df_org.shape[0]):\n    # Retrieving the path based upon the index\n    path = \"{}\/{}\".format(str(images_data_path),str(df_org.iloc[idx].image_id))\n    \n    # Reading images using PIL library\n    image = PIL.Image.open(path).resize(image_size_training)\n    image_array = np.asarray(image) \/ 255\n    \n    # Appending the images to a list\n    images_data.append(image_array)\n    \n# Converting images_data to an array from list\nimages_data = np.array(images_data)","89cf243d":"# Plotting a sample image\nplt.imshow(images_data[700])","829cb372":"print(\"Images Data Arrays Shape:\", images_data.shape)\nprint(\"Key Points Data Shape:\", df_org.shape)","7da240d3":"df_org.isnull().sum()","2d4cdc37":"df_org.describe()","f2a14586":"# function to read images based on index\ndef image_array(index, size=image_size_training, path=images_data_path):\n    \"\"\"\n    This functions is for converting images to arrays to deal with it in the model.\n    \n    Input:  index of the image that we want to convert to array\n            size of the image that we want for the array of the image\n            path of the images data to get the image\n            \n    Output: the image array as numpy array\n    \"\"\"\n    # to get the path based on index\n    path = \"{}\/{}\".format(str(path),str(df_org.iloc[index].image_id))\n    \n    # to read the image\n    image = PIL.Image.open(path).resize(size)\n    image_array = np.asarray(image)\n    \n    return image_array","3165739f":"# function to get a list of all key points of the face\ndef image_key_points_list(index, df = df_org):\n    \"\"\"\n    This function for getting the key points on the face as list to deal with it in plotting sections\n    \"\"\"\n    # box dictionary\n    points_list = [df.iloc[index].lefteye_x,\n                   df.iloc[index].lefteye_y,\n                   df.iloc[index].righteye_x,\n                   df.iloc[index].righteye_y,\n                   df.iloc[index].nose_x,\n                   df.iloc[index].nose_y,\n                   df.iloc[index].leftmouth_x,\n                   df.iloc[index].leftmouth_y,\n                   df.iloc[index].rightmouth_x,\n                   df.iloc[index].rightmouth_y]\n    \n    return points_list","b7840e4f":"# function to plot the image with green box around the faces\ndef plotting_image_with_box(index, df = df_org, size=original_image_size):\n    \"\"\"\n    This function for plotting the image with points on facial features and box around the face\n    \"\"\"\n    test_image = image_array(index, size)\n    points_list = image_key_points_list(index, df)\n    \n    # face points\n    le_x, le_y, re_x, re_y = points_list[0], points_list[1], points_list[2], points_list[3]\n    n_x, n_y = points_list[4], points_list[5]\n    lm_x, lm_y, rm_x, rm_y = points_list[6], points_list[7], points_list[8], points_list[9]\n    \n    # Create figure and axes\n    fig, ax = plt.subplots()\n    # plot the image\n    ax.imshow(test_image)\n    # plot the points on the face\n    ax.plot([le_x,re_x,n_x,lm_x,rm_x], [le_y,re_y,n_y,lm_y,rm_y], 'bo-')\n    \n    # plot the box around the face\n    width = abs(le_x-rm_x-60)\n    height = abs(le_y-rm_y-75)\n    rect = patches.Rectangle((le_x-30, le_y-40), width, height, linewidth=4, edgecolor='g', facecolor='none')\n    ax.add_patch(rect);","9496cadc":"#plotting the image with facial key points\nplotting_image_with_box(25)","7b4e4e05":"# copy a version from the data to prepare it for analysis\ndf = df_org.copy()\n\n# check\ndf.head(3)","eeac8d62":"# function for updating key points for a new size\ndef rescale_key_points(oldsize=original_image_size, newsize=image_size_training):\n    \"\"\"\n    This function is for rescaling the key points from the original scale to a nwe scale from our chossen and we reduce\n    the image size to make the analysis faster and using lower memory\n    \"\"\"\n    # old and nwe sizes (x,y) values\n    x_axis_old = oldsize[0]\n    y_axis_old = oldsize[1]\n\n    x_axis_new = newsize[0]\n    y_axis_new = newsize[1]\n\n    x_ratio = x_axis_new \/ x_axis_old\n    y_ratio = y_axis_new \/ y_axis_old\n    \n    # converting the keypoints values to be trained with the new size of the images\n    keypoints_x = ['lefteye_x', 'righteye_x', 'nose_x', 'leftmouth_x', 'rightmouth_x']\n    keypoints_y = ['lefteye_y', 'righteye_y', 'nose_y', 'leftmouth_y', 'rightmouth_y']\n    \n    df[keypoints_x] = (df[keypoints_x] * x_ratio).astype('int')\n    df[keypoints_y] = (df[keypoints_y] * y_ratio).astype('int')\n    \n    return 0\n\n# call the function\nrescale_key_points()\n\n# check\ndf.head()\n","357a91b1":"images=images_data\nlabels=df","8bdbe7f6":"from sklearn.model_selection import train_test_split","448d2faf":"train_images,test_images,train_labels,test_labels=train_test_split(images,labels,\n                                                                  test_size=0.3,random_state=42)","9d882e03":"y_test=test_labels.drop([\"image_id\"],axis=1)\ny_train=train_labels.drop([\"image_id\"],axis=1)\n\nX_test=test_images\nX_train=train_images","d3a24a9d":"X_test, X_val, y_test, y_val=train_test_split(X_test, y_test,\n                                              test_size=0.5,random_state=42)","be7d0bd2":"# diminsions of the image in the traing process\nx_ = image_size_training[0]\ny_ = image_size_training[1]\n\n# build the model\nmodel = Sequential()\n\nmodel.add(Conv2D(filters=8, kernel_size=(3, 3), padding='same', activation=\"relu\", input_shape=(y_,x_,3)))\nmodel.add(Conv2D(filters=8, kernel_size=(3, 3), padding='same', activation='relu'))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Conv2D(filters=16, kernel_size=(3, 3), padding='same', activation='relu'))\nmodel.add(Conv2D(filters=16, kernel_size=(3, 3), padding='same', activation='relu'))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Conv2D(filters=32, kernel_size=(3, 3), padding='same', activation=\"relu\"))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Dropout(0.2))\n\nmodel.add(Conv2D(filters=64, kernel_size=(3, 3), padding='same', activation='relu'))\nmodel.add(MaxPooling2D(pool_size=2))\nmodel.add(Dropout(0.2))\nmodel.add(Flatten())\n\nmodel.add(Dense(64, activation='relu'))\nmodel.add(Dropout(0.2))\n\nmodel.add(Dense(32, activation='relu'))\nmodel.add(Dropout(0.2))\n\nmodel.add(Dense(16, activation='relu'))\nmodel.add(Dropout(0.2))\n\nmodel.add(Dense(10, activation='relu'))\n","db7e4296":"model.summary()","84cdf7e3":"model.compile(optimizer=\"rmsprop\", loss='mean_squared_error',metrics=[\"mae\"])","b9760a76":"# fitting the model with our data\ntraining_process = model.fit(X_train, y_train, epochs=50, validation_data=(X_val, y_val), batch_size=4, shuffle=True)","61c5e926":"model.evaluate(X_test, y_test)","0cce91cc":"def predictions_test_model(index):\n    img = tf.keras.preprocessing.image.load_img(\"{}\/0{}.jpg\".format(images_data_path, index),target_size=(y_,x_,3))\n    img = tf.keras.preprocessing.image.img_to_array(img)\n    img = img\/255\n    points_list = model.predict(img.reshape(1,y_,x_,3)).astype('int')[0]\n    \n    # converting key points values to the original size\n    x_ratio = 1.05 * (original_image_size[0] \/ image_size_training[0])\n    y_ratio = 1.085 * (original_image_size[1] \/ image_size_training[1])\n    \"\"\"\n    In the previous ratios we multiply them by contant to reduce the noise that happened when we rescaled the points in\n    the previous training, there is no meaning for these numbers (i just pick them with trails)\n    \"\"\"\n    \n    points_list[0] = int(points_list[0] * x_ratio)\n    points_list[2] = int(points_list[2] * x_ratio)\n    points_list[4] = int(points_list[4] * x_ratio)\n    points_list[6] = int(points_list[6] * x_ratio)\n    points_list[8] = int(points_list[8] * x_ratio)\n    \n    points_list[1] = int(points_list[1] * y_ratio)\n    points_list[3] = int(points_list[3] * y_ratio)\n    points_list[5] = int(points_list[5] * y_ratio)\n    points_list[7] = int(points_list[7] * y_ratio)\n    points_list[9] = int(points_list[9] * y_ratio)\n    \n    return points_list","26903be8":"# function to plot the image with green box around the faces\ndef test_image_with_box_plot(index, pred_or_actual = 'pred', pointsColor='bo-' ,boxcolor='g'):\n    img = tf.keras.preprocessing.image.load_img(\"{}\/0{}.jpg\".format(images_data_path, index),target_size=(y_org,x_org,3))\n    img = tf.keras.preprocessing.image.img_to_array(img)\n    test_image = img\/255\n    \n    # predictions of key points on the face\n    if pred_or_actual == 'pred':\n        points_list = predictions_test_model(index)        # this for predections of the model\n    elif pred_or_actual == 'actual':\n        points_list = image_key_points_list(index)   # this for the actual labels of the test data\n    \n    # face points\n    le_x, le_y, re_x, re_y = points_list[0], points_list[1], points_list[2], points_list[3]\n    n_x, n_y = points_list[4], points_list[5]\n    lm_x, lm_y, rm_x, rm_y = points_list[6], points_list[7], points_list[8], points_list[9]\n\n    # Create figure and axes\n    fig, ax = plt.subplots()\n    # plot the image\n    ax.imshow(test_image)\n    # plot the points on the face\n    ax.plot([le_x,re_x,n_x,lm_x,rm_x], [le_y,re_y,n_y,lm_y,rm_y], pointsColor)\n    \n    # plot the box around the face\n    width = abs(le_x-rm_x-60)\n    height = abs(le_y-rm_y-75)\n    rect = patches.Rectangle((le_x-30, le_y-40), width, height, linewidth=4, edgecolor=boxcolor, facecolor='none')\n    ax.add_patch(rect);\n    return points_list","819da195":"# Using the model to predict a sample image which doesn't exist in train,test, or validation data\nindex = 34100\nprint('RED box for predections\\n') \nprint('GREEN box for actual labels\\n')\ntest_image_with_box_plot(index, pred_or_actual = 'pred', pointsColor='mo-' ,boxcolor='r')\n","d5a7a6cf":"# losses of both training and validation sets\nloss = training_process.history['loss']\nval_loss = training_process.history['val_loss']\n\n# plot both losses\nplt.plot(loss)\nplt.plot(val_loss)\nplt.legend(['loss', 'val_loss']);","26bfa581":"model.save(\"model.h5\")","88af0fbb":"## Saving the model for future use","42aecb18":"## Further splitting the test data into validation and test data","0d492c3c":"## Converting images into an array","fa60a16a":"## Reading images","0510c24e":"## Loading the key points data","38a44b0c":"### Now, we will rescale the keypoints on the basis of rescaled images","49ae56cf":"## Preparing the data for our Deep Learning","c497513c":"## Building the CNN-based Deep Learning model","7bb9af71":"## Testing the model","4a735ce6":"### Evaluating the model performance on the basis of ","fa8413b1":"## Plotting a sample image","36917798":"## Having a quick view of the model architecture"}}