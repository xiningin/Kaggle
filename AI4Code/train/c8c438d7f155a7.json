{"cell_type":{"04716f66":"code","61dd4706":"code","465e1b29":"code","d2fb81c6":"code","57ec1628":"code","d091d821":"code","3c849526":"markdown","bf27af31":"markdown","7b23294f":"markdown","e1a439e8":"markdown","ec91bfd0":"markdown"},"source":{"04716f66":"import numpy as np\nimport pandas as pd\nimport gc\n\ntr = pd.read_csv('\/kaggle\/input\/ashrae-energy-prediction\/train.csv')\nte = pd.read_csv('\/kaggle\/input\/ashrae-energy-prediction\/test.csv')\n\na = set(tr.building_id)\nb = set(te.building_id)\nlen(a-b), len(b-a)","61dd4706":"del a,b; gc.collect()\ntr.timestamp.min(), tr.timestamp.max()","465e1b29":"tr.timestamp = tr.timestamp.map(lambda x: x[5:])\nte.timestamp = te.timestamp.map(lambda x: x[5:])\nte = te.merge(\n    tr[['building_id','meter','timestamp','meter_reading']],\n    how='left',\n    on=['building_id','meter','timestamp']\n)","d2fb81c6":"del tr; gc.collect()\n(te.meter_reading.isna().sum() \/ te.shape[0] * 100).astype(np.int)","57ec1628":"fillna = te.groupby(['building_id', 'meter']).meter_reading.mean().reset_index()\nfillna.rename(columns={'meter_reading':'missing'}, inplace=True)\nte = te.merge(fillna, how='left', on=['building_id', 'meter'])\n\nmask = te.meter_reading.isna()\nte.loc[mask, 'meter_reading'] = te[mask].missing\n(te.meter_reading.isna().sum() \/ te.shape[0] * 100).astype(np.int)","d091d821":"te[['row_id', 'meter_reading']].to_csv('.\/submission.csv', index=False)","3c849526":"If we drop year, we don't have to worry about collisions... since we only have a max of 1 unique reading per hour per meter per building.","bf27af31":"![Copycat Ken](https:\/\/i.ytimg.com\/vi\/ByH13tdosnM\/maxresdefault.jpg)","7b23294f":"Small amount of nans we need to handle...","e1a439e8":"> Cool, each test building exists in train.","ec91bfd0":"Why is the inclusion of an introductory header image a 'soft requirement' for kernels these days, lol? Guess the anime."}}