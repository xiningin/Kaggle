{"cell_type":{"cfda7877":"code","8755639f":"code","5097ba26":"code","431dbf3d":"code","3649fc9f":"code","9c5b3168":"markdown","7cd8a8a2":"markdown","f10fe94f":"markdown","3cf86b53":"markdown","88918cf3":"markdown","61fe69db":"markdown"},"source":{"cfda7877":"import numpy as np\nimport matplotlib.pyplot as plt\nimport cv2","8755639f":"image = cv2.imread('\/kaggle\/input\/assinment1\/1.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\nplt.subplot(1, 5, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\n\n# Create our shapening kernel, we don't normalize since the \n# the values in the matrix sum to 3\nkernel_sharpening = np.array([[-1,-1,-1], \n                              [-1,9,-1], \n                              [-1,-1,1]])\n\n# applying different kernels to the input image\nsharpened = cv2.filter2D(image, -1, kernel_sharpening)\nplt.subplot(1, 5, 2)\nplt.title(\"Image Sharpening1\")\nplt.imshow(sharpened)\n\n#the values in the matrix sum to 2\nkernel_sharpening = np.array([[-1,-1,-1], \n                              [-1,10,-1], \n                              [-1,-1,-1]])\n# applying different kernels to the input image\nsharpened = cv2.filter2D(image, -1, kernel_sharpening)\nplt.subplot(1, 5, 3)\nplt.title(\"Image Sharpening2\")\nplt.imshow(sharpened)\n\n#the values in the matrix sum to 1\nkernel_sharpening = np.array([[-1,-1,-1], \n                              [-1,9,-1], \n                              [-1,-1,-1]])\n# applying different kernels to the input image\nsharpened = cv2.filter2D(image, -1, kernel_sharpening)\nplt.subplot(1, 5, 4)\nplt.title(\"Image Sharpening3\")\nplt.imshow(sharpened)\n\n#the values in the matrix sum to 0\nkernel_sharpening = np.array([[-2,-1,-1], \n                              [-1,10,-1], \n                              [-1,-1,-2]])\n# applying different kernels to the input image\nsharpened = cv2.filter2D(image, -1, kernel_sharpening)\nplt.subplot(1, 5, 5)\nplt.title(\"Image Sharpening4\")\nplt.imshow(sharpened)\n\n\nplt.show()","5097ba26":"image = cv2.imread('\/kaggle\/input\/assinment1\/2.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(1, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\npoints_A = np.float32([[170,0], [3400,0], [0,4200], [3500,4500]])\npoints_B = np.float32([[0,0], [3700,0], [0,4200], [3600,4400]])\nM = cv2.getPerspectiveTransform(points_A, points_B)\nwarped = cv2.warpPerspective(image, M, (3500,4500))\nplt.subplot(1, 2, 2)\nplt.title(\"warpPerspective\")\nplt.imshow(warped)","431dbf3d":"# Load our new image\nimage = cv2.imread('\/kaggle\/input\/assinment1\/2.jpg', 0)\n\nplt.figure(figsize=(30, 30))\nplt.subplot(3, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\n# Values below 127 goes to 0 (black, everything above goes to 255 (white)\nret,thresh1 = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)\n\nplt.subplot(3, 2, 2)\nplt.title(\"Threshold Binary\")\nplt.imshow(thresh1)\n\n\n# It's good practice to blur images as it removes noise\nimage = cv2.GaussianBlur(image, (3, 3), 0)\n\n# Using adaptiveThreshold\nthresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 3, 5) \n\nplt.subplot(3, 2, 3)\nplt.title(\"Adaptive Mean Thresholding\")\nplt.imshow(thresh)\n\n\n_, th2 = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n\nplt.subplot(3, 2, 4)\nplt.title(\"Otsu's Thresholding\")\nplt.imshow(th2)\n\n\nplt.subplot(3, 2, 5)\n# Otsu's thresholding after Gaussian filtering\nblur = cv2.GaussianBlur(image, (5,5), 0)\n_, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\nplt.title(\"Guassian Otsu's Thresholding\")\nplt.imshow(th3)\nplt.show()","3649fc9f":"image = cv2.imread('\/kaggle\/input\/assinment1\/1.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nheight, width,_ = image.shape\n\n# Extract Sobel Edges\nsobel_x = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=5)\nsobel_y = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=5)\n\nplt.figure(figsize=(20, 20))\n\nplt.subplot(3, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\n\nplt.subplot(3, 2, 2)\nplt.title(\"Sobel X\")\nplt.imshow(sobel_x)\n\n\nplt.subplot(3, 2, 3)\nplt.title(\"Sobel Y\")\nplt.imshow(sobel_y)\n\nsobel_OR = cv2.bitwise_or(sobel_x, sobel_y)\n\nplt.subplot(3, 2, 4)\nplt.title(\"sobel_OR\")\nplt.imshow(sobel_OR)\n\nlaplacian = cv2.Laplacian(image, cv2.CV_64F)\n\nplt.subplot(3, 2, 5)\nplt.title(\"Laplacian\")\nplt.imshow(laplacian)\n\n\n##  Then, we need to provide two values: threshold1 and threshold2. Any gradient value larger than threshold2\n# is considered to be an edge. Any value below threshold1 is considered not to be an edge. \n#Values in between threshold1 and threshold2 are either classi\ufb01ed as edges or non-edges based on how their \n#intensities are \u201cconnected\u201d. In this case, any gradient values below 60 are considered non-edges\n#whereas any values above 120 are considered edges.\n\n\n# Canny Edge Detection uses gradient values as thresholds\n# The first threshold gradient\ncanny = cv2.Canny(image, 50, 120)\n\nplt.subplot(3, 2, 6)\nplt.title(\"Canny\")\nplt.imshow(canny)","9c5b3168":"3.Thresholding, Binarization & Adaptive Thresholding","7cd8a8a2":"1.Sharpening\n","f10fe94f":"# applying different kernels to the input image\n# the values in the matrix sum to 3\n# the values in the matrix sum to 2\n# the values in the matrix sum to 1\n# the values in the matrix sum to 0\n# Complete the adjustment of the brightness of the photo from light to dark\n","3cf86b53":"2  Perpsective Transform \n# According to the coordinates of the four vertices of the picture [170,0], [3400,0], [0,4200], [3500,4500] then adjust the coordinates of the four points to adjust the picture [0,0], [3700,0], [0,4200], [3600,4400]. Better results can be obtained after adjustment\u3002\n\u3002","88918cf3":"4 Edge Detection & Image Gradients","61fe69db":"CSPHDIS1 Assignment 1 - Hejun Lu, Xiaofeng An\n"}}