{"cell_type":{"88b44f15":"code","ad84077b":"code","1b4425f0":"code","a6e8810e":"code","07abd5d3":"code","32fef594":"code","5b0167ba":"code","987ec618":"code","b3655e81":"code","676166d8":"code","3ede563e":"code","44f3e94f":"code","f96967aa":"code","7c95cb69":"code","84c6c19b":"code","64583a7b":"code","4b9cdbbd":"code","211b584b":"code","5236c174":"code","4f68fb6a":"code","dc13cbe5":"code","81ae2aef":"code","1f4a39f7":"code","e1760ffb":"code","29c7a522":"code","0be4e0a5":"code","5f00e364":"code","ce9e0523":"code","9d1b86a4":"code","2103676e":"code","08495756":"code","7041bf35":"code","9807ebb7":"markdown","33e5964b":"markdown","b5722c3a":"markdown","2e74c731":"markdown"},"source":{"88b44f15":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n","ad84077b":"import seaborn as sns\n\nfrom sklearn.preprocessing import scale\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import metrics\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.model_selection import GridSearchCV\n\npd.set_option('display.max_columns',800)","1b4425f0":"df = pd.read_csv(\"\/kaggle\/input\/digit-recognizer\/train.csv\")","a6e8810e":"df_frac = df.sample(frac = 0.2) ","07abd5d3":"df_frac.head()","32fef594":"len(df_frac)","5b0167ba":"sns.countplot(df_frac['label'])","987ec618":"label_means = df_frac.groupby('label').mean()\nlabel_means.head()","b3655e81":"# splitting into X and y\nX = df_frac.drop(\"label\", axis = 1)\ny = df_frac['label']","676166d8":"# scaling the features\nX_scaled = scale(X)\n\n# train test split\nX_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size = 0.3, random_state = 101)","3ede563e":"# linear model\n\nmodel_linear = SVC(kernel='linear')\nmodel_linear.fit(X_train, y_train)\n\n# predict\ny_pred = model_linear.predict(X_test)","44f3e94f":"print(\"accuracy:\", metrics.accuracy_score(y_true=y_test, y_pred=y_pred), \"\\n\")","f96967aa":"# non-linear model\n# using rbf kernel, C=1, default value of gamma\n\n# model\nnon_linear_model = SVC(kernel='rbf')\n\n# fit\nnon_linear_model.fit(X_train, y_train)\n\n# predict\ny_pred = non_linear_model.predict(X_test)","7c95cb69":"print(\"accuracy:\", metrics.accuracy_score(y_true=y_test, y_pred=y_pred), \"\\n\")","84c6c19b":"# creating a KFold object with 5 splits \nfolds = KFold(n_splits = 5, shuffle = True, random_state = 101)\n\n# specify range of hyperparameters\n# Set the parameters by cross-validation\nhyper_params = [ {'gamma': [1e-2, 1e-3, 1e-4],\n                     'C': [1, 10, 100, 1000]}]\n\n\n# specify model\nmodel = SVC(kernel=\"rbf\")\n\n# set up GridSearchCV()\nmodel_cv = GridSearchCV(estimator = model, \n                        param_grid = hyper_params, \n                        scoring= 'accuracy', \n                        cv = folds, \n                        verbose = 1,\n                        return_train_score=True)      \n\n# fit the model\nmodel_cv.fit(X_train, y_train)","64583a7b":"# cv results\ncv_results = pd.DataFrame(model_cv.cv_results_)\ncv_results","4b9cdbbd":"cv_results[['params','mean_test_score','mean_train_score']].sort_values('mean_test_score')","211b584b":"import matplotlib.pyplot as plt","5236c174":"# converting C to numeric type for plotting on x-axis\ncv_results['param_C'] = cv_results['param_C'].astype('int')\n\n# # plotting\nplt.figure(figsize=(16,6))\n\n# subplot 1\/3\nplt.subplot(131)\ngamma_01 = cv_results[cv_results['param_gamma']==0.01]\n\nplt.plot(gamma_01[\"param_C\"], gamma_01[\"mean_test_score\"])\nplt.plot(gamma_01[\"param_C\"], gamma_01[\"mean_train_score\"])\nplt.xlabel('C')\nplt.ylabel('Accuracy')\nplt.title(\"Gamma=0.01\")\nplt.ylim([0.60, 1])\nplt.legend(['test accuracy', 'train accuracy'], loc='upper left')\nplt.xscale('log')\n\n# subplot 2\/3\nplt.subplot(132)\ngamma_001 = cv_results[cv_results['param_gamma']==0.001]\n\nplt.plot(gamma_001[\"param_C\"], gamma_001[\"mean_test_score\"])\nplt.plot(gamma_001[\"param_C\"], gamma_001[\"mean_train_score\"])\nplt.xlabel('C')\nplt.ylabel('Accuracy')\nplt.title(\"Gamma=0.001\")\nplt.ylim([0.60, 1])\nplt.legend(['test accuracy', 'train accuracy'], loc='upper left')\nplt.xscale('log')\n\n\n# subplot 3\/3\nplt.subplot(133)\ngamma_0001 = cv_results[cv_results['param_gamma']==0.0001]\n\nplt.plot(gamma_0001[\"param_C\"], gamma_0001[\"mean_test_score\"])\nplt.plot(gamma_0001[\"param_C\"], gamma_0001[\"mean_train_score\"])\nplt.xlabel('C')\nplt.ylabel('Accuracy')\nplt.title(\"Gamma=0.0001\")\nplt.ylim([0.60, 1])\nplt.legend(['test accuracy', 'train accuracy'], loc='upper left')\nplt.xscale('log')","4f68fb6a":"# printing the optimal accuracy score and hyperparameters\nbest_score = model_cv.best_score_\nbest_hyperparams = model_cv.best_params_\n\nprint(\"The best test score is {0} corresponding to hyperparameters {1}\".format(best_score, best_hyperparams))","dc13cbe5":"# model with optimal hyperparameters\n\n# model\nmodel = SVC(C=10, gamma=0.001, kernel=\"rbf\")\n\nmodel.fit(X_train, y_train)\ny_pred = model.predict(X_test)\n\n# metrics\n","81ae2aef":"print(\"accuracy\", round(metrics.accuracy_score(y_test, y_pred),2), \"\\n\")","1f4a39f7":"from sklearn.decomposition import PCA","e1760ffb":"pca_again = PCA(0.9)","29c7a522":"df_train_pca2 = pca_again.fit_transform(X_train)","0be4e0a5":"df_train_pca2.shape","5f00e364":"df_test_pca2 = pca_again.transform(X_test)","ce9e0523":"df_test_pca2.shape","9d1b86a4":"# creating a KFold object with 5 splits \nfolds = KFold(n_splits = 5, shuffle = True, random_state = 105)\n\n# specify range of hyperparameters\n# Set the parameters by cross-validation\nhyper_params = [ {'gamma': [1e-2, 1e-3, 1e-4],\n                     'C': [1, 10, 100, 1000]}]\n\n\n# specify model\nmodel = SVC(kernel=\"rbf\")\n\n# set up GridSearchCV()\nmodel_cv = GridSearchCV(estimator = model, \n                        param_grid = hyper_params, \n                        scoring= 'accuracy', \n                        cv = folds, \n                        verbose = 1,\n                        return_train_score=True)      \n\n# fit the model\nmodel_cv.fit(df_train_pca2, y_train)","2103676e":"# printing the optimal accuracy score and hyperparameters\nbest_score = model_cv.best_score_\nbest_hyperparams = model_cv.best_params_\n\nprint(\"The best test score is {0} corresponding to hyperparameters {1}\".format(best_score, best_hyperparams))","08495756":"# model with optimal hyperparameters\n\n# model\nmodel = SVC(C=10, gamma=0.001, kernel=\"rbf\")\n\nmodel.fit(df_train_pca2, y_train)\ny_pred = model.predict(df_test_pca2)","7041bf35":"print(\"accuracy\", round(metrics.accuracy_score(y_test, y_pred),2), \"\\n\")","9807ebb7":"## Model Building","33e5964b":"### Splitting into X and Y","b5722c3a":"# PCA","2e74c731":"## Grid Search: Hyperparameter Tuning\n\nLet's now tune the model to find the optimal values of C and gamma corresponding to an RBF kernel. We'll use 5-fold cross validation."}}