{"cell_type":{"8638977d":"code","00e68f48":"code","8c291b24":"code","cb2010f5":"code","692bb1d8":"code","f5c48fc0":"code","20f52d5f":"code","f7e36699":"code","c8df915f":"code","45c103a2":"code","0d1ef66d":"code","eb8ccd7b":"code","11dfb249":"markdown","a22626b9":"markdown","e286d5ca":"markdown","dddf76bf":"markdown","f9703169":"markdown","20cb7faa":"markdown","292ec6e8":"markdown","754f71ad":"markdown","bbc77302":"markdown","0d89459e":"markdown","0aee2c2a":"markdown","f32343c4":"markdown","58f00669":"markdown","a07290cc":"markdown","ec72e6aa":"markdown","dc19cb1b":"markdown","755b8331":"markdown","4dfe84d8":"markdown","8a84b210":"markdown","13de3c91":"markdown","c66572e8":"markdown","e9118079":"markdown"},"source":{"8638977d":"# imports and test of python\nimport numpy as np\nfrom numpy import random\nimport matplotlib.pyplot as plt\nimport matplotlib.axes as axes\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom statistics import mean\nfrom scipy import spatial\n\nprint(\"Python works\")","00e68f48":"#Klasse f\u00fcr Hilfsfunktionen\nclass Pointclouds():\n    def __init__(self):\n        pass\n\n    def createPointcloud(self, roomDimension, numberOfPoints):\n        lenX, lenY, lenZ = roomDimension\n        \n        points = np.column_stack((random.uniform(0.0, lenX, numberOfPoints),random.uniform(0.0, lenY, numberOfPoints),random.uniform(0.0, lenZ, numberOfPoints)))\n        \n        return points\n\n    def addError(self, points, sigma, distribution = 'normal'):\n        # adding some error to the referenc Pointcloud to simulate a second measurement with a less accurate scanner\n        if distribution == 'normal':\n            otherpoints = points + random.normal(0.0, sigma, np.shape(points))\n        elif distribution == 'uniform':\n            otherpoints = points + random.uniform(-sigma, sigma, np.shape(points))\n        return otherpoints\n\n    def addUnevenError(self, points, sigmaX,sigmaY,sigmaZ):\n        n = np.shape(points)[0]\n        noise = np.column_stack((random.normal(0.0, sigmaX, n),random.normal(0.0, sigmaY, n),random.normal(0.0, sigmaZ, n)))\n        otherpoints = points + noise\n        return otherpoints\n\n    def addErrorWithOffset(self, points, sigma, offset):\n        otherpoints = points + random.normal(offset, sigma, np.shape(points))\n        return otherpoints\n\n    def calcErrorDiff(self, PointcloudA, PointcloudB): #return RMSEdiffRelative\n        # Calculate RMSE with both methods\n        # direkt method\n        ## rigid body transform is not needed, because in this simulations the coordinate systems are the same for both scans\n        errorVectors = PointcloudA - PointcloudB                #distances of the coresponding points\n        #calc length of error vector\n        errorDistances = np.linalg.norm(errorVectors, axis=1)              \n\n        RMSE_direct = np.sqrt(mean(pow(errorDistances,2)))                      \n\n        # indirekt method\n        distancesA = spatial.distance.pdist(PointcloudA)\n        distancesB = spatial.distance.pdist(PointcloudB)\n        distErrors =  distancesB - distancesA\n        RMSE_indirect =np.sqrt(mean(pow(distErrors,2)))\n\n        RMSEdiffRelative = (RMSE_indirect - RMSE_direct )\/RMSE_direct  # the RMSE_indirect is (RMSEdiffRelative * 100) % bigger than the RMSE_direct\n        return [RMSEdiffRelative , RMSE_direct, RMSE_indirect]                                        # or return [RMSEdiffRelative , RMSE_direct, RMSE_indirect] \n\ndef rmse(individualErrors):\n    return np.sqrt(mean(individualErrors ** 2))\n\nprint(\"Hilfsklasse erstellt\")\n    ","8c291b24":"\npts = Pointclouds() #objekt for helpfunctions\nnumberOfPoints = 1000 #may be different for different szenarios","cb2010f5":"################ Validation Test\n #   - 10m3Raum\n#       - normalverteilter Fehler 50mm  np.random.normal()\n#       - das gleiche nochmal, kommt das gleiche Ergebnis heraus\n\nnumberOfPoints = 200\nerror = 50    #mm   standardabweichung des normalverteilten Fehlers\n#errors = [50 for _ in range(1, 102, 10)]\nrounds = [x for x in range(1, 101, 1)]  # 100 trys\ndiffs = []\nfor round in rounds: \n    points = pts.createPointcloud((10_000.0, 10_000.0, 10_000.0), numberOfPoints)\n    otherPoints = pts.addError(points, error, distribution = 'normal')\n    diffs.append(pts.calcErrorDiff(points, otherPoints))\ndiffs = np.array(diffs)\n\nplt.figure()\nplt.scatter(rounds, diffs[:, 0])\nplt.title(\"100 times with normal distribution\")\nplt.xlabel('rounds')\nplt.ylabel('diff of the to methods')\nplt.show()","692bb1d8":"print(\"averageRMSE_direct:   \", np.mean(diffs[:, 1]))\nprint(\"averageRMSE_indirect: \", np.mean(diffs[:, 2]))","f5c48fc0":"numberOfValues = 100_000\nstandardabweichung = 50\n\nrmse(np.zeros(numberOfValues) + random.normal(0.0, standardabweichung, numberOfValues))","20f52d5f":"numberOfValues = 100_000\nstandardabweichung = 50\nvaluesA = np.zeros(numberOfValues) + random.normal(0.0, standardabweichung, numberOfValues)\nvaluesB = np.zeros(numberOfValues) + random.normal(0.0, standardabweichung, numberOfValues)\nrmse(valuesA + valuesB)    # hier ist es egal, ob (valuesA + valuesB) oder (valuesA - valuesB)","f7e36699":"################ First Test\n#   - 10m3Raum\n#   - normalverteilter Fehler mit variierender Standardabweichung von 1mm bis 100 mm\n\nnumberOfPoints = 200 \nerrors = [x for x in range(1, 101, 1)] #mm   standardabweichung des normalverteilten Fehlers\ndiffs = []\nfor round in rounds: \n    points = pts.createPointcloud((10_000.0, 10_000.0, 10_000.0), numberOfPoints)\n    otherPoints = pts.addError(points, error, distribution = 'normal')\n    diffs.append(pts.calcErrorDiff(points, otherPoints))\ndiffs = np.array(diffs)\n\nplt.figure()\nplt.scatter(errors, diffs[:, 0])\nplt.title(\"100 times with different sigma\")\nplt.xlabel('sigma in mm')\nplt.ylabel('diff of the to methods')\nplt.show()","c8df915f":"################ Second Test\n#   - Punkte nur auf XY-Ebene 10m^2\n#   - normalverteilter Fehler mit Standardabweichung 50mm\n\nnumberOfPoints = 200\nerror = 50    #mm   standardabweichung des normalverteilten Fehlers\nrounds = [x for x in range(1, 101, 1)]  # 100 rounds\ndiffs = []\nfor round in rounds: \n    points = pts.createPointcloud((10_000.0, 10_000.0, 0), numberOfPoints)\n    otherPoints = pts.addError(points, error, distribution = 'normal')\n    diffs.append(pts.calcErrorDiff(points, otherPoints))\ndiffs = np.array(diffs)\n\nplt.figure()\nplt.scatter(rounds, diffs[:, 0])\nplt.title(\"100 times with points on XY-Plane\")\nplt.xlabel('rounds')\nplt.ylabel('diff of the to methods')\nplt.show()","45c103a2":"################ Third Test\n#   - 10m^3 Raum\n#   - normalverteilter Fehler mit Standardabweichung 50mm\n#   - Fehler in z-Richtung \"faktor\" mal gr\u00f6\u00dfer als der Fehler in x und y Richtung.\n\nnumberOfPoints = 500\nerror = 50    #mm   standardabweichung des normalverteilten Fehlers\nfaktors = [x for x in np.arange(0.1,5,0.1)]\ndiffs = []\nfor faktor in faktors: \n    points = pts.createPointcloud((10_000.0, 10_000.0, 0), numberOfPoints)\n    otherPoints = pts.addUnevenError(points, error, error, error*faktor)\n    diffs.append(pts.calcErrorDiff(points, otherPoints))\ndiffs = np.array(diffs)\n\nplt.figure()\nplt.scatter(faktors, diffs[:, 0])\nplt.title(\"uneven Error in z direction\")\nplt.xlabel('faktor')\nplt.ylabel('diff of the to methods')\nplt.show()","0d1ef66d":"print(\"RMSE_direct   with faktor 5: \", diffs[-1, 1])\nprint(\"RMSE_indirect with faktor 5: \", diffs[-1, 2])","eb8ccd7b":"############### Fourth Test\n\n#   - Punkte nur in XY ebene Verteilt 10m2\n#     - Fehler nur in x Richtung\n#     - Fehler nur in y Richtung\n#     - Fehler nur in z Richtung\n\nnumberOfPoints = 1000\nplt.figure()\nerror = 50\ndiffs = []\nfaktors = range(1, 10, 1)\n\nfor faktor in faktors: \n    points = pts.createPointcloud((10_000.0, 10_000.0, 0.0), numberOfPoints)\n    otherPoints = pts.addUnevenError(points, error*faktor, error, error)\n    diffs.append(pts.calcErrorDiff(points, otherPoints))\nplt.scatter(faktors, np.array(diffs)[:,0], label = '#X', color = 'navy')\n\ndiffs = []\nfor faktor in faktors: \n    points = pts.createPointcloud((10_000.0, 10_000.0, 0.0), numberOfPoints)\n    otherPoints = pts.addUnevenError(points, error, error*faktor, error)\n    diffs.append(pts.calcErrorDiff(points, otherPoints))\nplt.scatter(faktors, np.array(diffs)[:,0], label = '#Y', color = 'red')\n\ndiffs = []\nfor faktor in faktors: \n    points = pts.createPointcloud((10_000.0, 10_000.0, 0.0), numberOfPoints)\n    otherPoints = pts.addUnevenError(points, error, error, error*faktor)\n    diffs.append(pts.calcErrorDiff(points, otherPoints))\nplt.scatter(faktors, np.array(diffs)[:,0], label = '#Z', color = 'darkcyan')\n\n\nplt.scatter(faktors, np.array(diffs)[:,0])\nplt.title(\"1000 Points on XY Plane\")\nplt.xlabel('error in # axes is _ times bigger than other')\nplt.ylabel(r'distRMSE is y% smaller than RMSE')\nplt.legend(loc = \"lower left\")\nplt.show()","11dfb249":"## Die direkte Methode\nBei der direkten Methode wird versucht eine der Punktwolken so zu drehen, dass sie m\u00f6glichst gut mit der anderen \u00fcbereinstimmt.\nEs wird versucht die Distanz zwischen den koresponierenden Punkten der zwei Punktwolken zu minimieren.\nAuf http:\/\/nghiaho.com\/?page_id=671  wird der Algorithmus sehr gut erkl\u00e4rt.([code](https:\/\/github.com\/nghiaho12\/rigid_transform_3D) auf github)\nHierf\u00fcr ist es wichtig, dass die Arrays, in denen die Punkte gespeichert sind gleich sortiert sind. Das bedeutet, die korrespondierenden Punkte haben den gleichen index.\n\nDanach k\u00f6nnen die Positionen der Punkte miteinander verglichen werden.\n\n$ d_i = \\sqrt{ (x_1-x_2)^2+(y_1-x_2)^2+(z_1-z_2)^2  } $\n\ni entspricht dem index des Punktes\n$ (x_1 y_1 z_1) $ ist der ite Punkt der Referenzmessung\n$ (x_2 y_2 z_2) $ ist der ite Punkt der zu untersuchenden Messung\n$d_i $ entspricht dem Abstand des gemessenem Punkts zur wahren Position des Punktes, und damit dem Fehler, den der Scanner gemacht hat\n\nDer RMSE berechnet sich dann wie folgt\n\n$ RMSE = \\sqrt{\\frac{1}{N}\\sum{d_i^2}}  $\n\n\n\n","a22626b9":"Dies ist der gleiche wert, wie bei der indirekten Methode.\nIch kann mir momentan noch nicht erkl\u00e4ren, warum der Wert der direkten Methode gr\u00f6\u00dfer ist.\n\u00c4hm ich meine: \n> Diese Frage zu beantworten, ist offen gelassen als Aufgabe f\u00fcr den Leser!","e286d5ca":"## Szenario 3: ungleichm\u00e4\u00dfig verteilter Fehler\nBei einem realen 3D Scanner kann es vorkommen, dass der Messfehler nicht gleichm\u00e4\u00dfig in alle Richtungen verteilt ist.\n\nIm folgenden Experiment soll also nun der Fehler in z-Richtung \"faktor\" mal gr\u00f6\u00dfer sein als der Fehler in x und y Richtung.","dddf76bf":"## Szenario 2: ungleichm\u00e4\u00dfig verteilte Punkte\nIn Scenario 1 waren die punkte gleichm\u00e4\u00dfig in dem $10m^3$ Raum verteilt.\nIn einem realen Raum aber, ist es viel wahrscheinlicher, dass die gemessenen Punkte auf einer Ebene liegen, wie eben der Decke, oder den W\u00e4nden.\n\nDies soll nun untersucht werden.","f9703169":"# Die Untersuchung\nIm Folgenden soll nun in verschidenen Szenarien die Genauigkeit einer Punktwolke gegen\u00fcber der Referenzmessung mit beiden Methoden bestimmt werden.\nDann kann die Differenz dieser beiden Genauigkeiten gebildet werden. So kann festgestellt werden, ob beide Methoden den gleichen Wert liefern.\n\nEs werden in einem Raum von *$10m^3$* zuf\u00e4llig Punkte genereiert.\nDie Anzahl der Punkte soll m\u00f6glichst gro\u00df sein, jedoch soll die Laufzeit nicht zu lange sein.\nBei der Rechenpower meiner CPU (i5 6600K 4Kerne) (\u00fcbertaktet auf 4,6GHz ;) sind das circa *1000* Punkte.\n\nDiese Punkte stellen den Wahren Wert dar, und damit die Referenzmessung.\nAuf die Punkte der Referenzmessung wird in alle 3 Koordinatenrichtungen ein zuf\u00e4lliger Fehler addiert. Dies Simuliert einen zweiten Scan mit einem ungenaueren 3D Scanner.\n\nDann wird mit beiden, oben beschriebenen Methoden der RMSE (Root Mean Squared Error) berechnet.\n\nNun kann untersucht werden, wie sich dei beiden Methoden unterscheiden.\nDie direkte Methode ist die nat\u00fcrlichere, daher wird sie f\u00fcr den Vergleich als basis gew\u00e4hlt.\n\nF\u00fcr alle folgenden Untersuchungen wird berechnet um wie viel Proztent der berechnete RMSE der indirekten Methode gr\u00f6\u00dfer ist, als der der direkten Methode. Dies geschieht mit der Formel:\n\n$ RMSEdiffRelative = \\frac{ RMSE_{indirect} - RMSE_{direct}}{RMSE_{direct}} $\n\nAlle werte sind in milli Meter (mm).\n\n\n\n## Prognose\nFolgende Effekte k\u00f6nnten eine Auswirkung auf die Differenz haben:\n\n- der Absolute fehler der Untersuchten Punktwolke\n- durch den RMSE werden gr\u00f6\u00dfere Werte st\u00e4rker gewichtet \n- die Punkte sind nicht gleichm\u00e4\u00dfig verteilt (nur in einer Ebene)\n- der Fehler ist nicht gleich gro\u00df in alle Achsrichtungen\n\nIn verschiedenen Szenarios sollen diese Effekte untersucht werden","20cb7faa":"# Einleitung\nBeim Scannen eines physischen Raumes mir einem 3D-Scanner ist das Ergebnis eine Punktwolke. Diese Punktwolke beschreibt dann ausgew\u00e4hlte Punkte im Raum, zum Beispiel auf den W\u00e4nden und der Decke.\n\nUm die Genauigkeit des 3D-Scanners zu ermitteln werden in einem Testraum mehrere Punkte markiert. Diese Punkte befinden sich auf den W\u00e4nden, der Decke, oder auf Schr\u00e4nken. Die Markierten Punkte werden dann mit dem zu untersuchenden Scanner vermessen.\n\nEs soll nun ermittelt werden, wie genau der 3D Scanner die Punkte im Raum vermessen konnte. Es soll bestimmt werden wie weit die Koordinaten des gemessenen Punktes von den orignialen Koordinaten des Scanners ist\n\nUm die waren Koordinaten der Punkte zu ermitteln muss eine Referenzmessung durchgef\u00fchrt werden.\n\nDiese Vermessung sollte mit einem m\u00f6glicht genauen Ger\u00e4t gemacht werden. Eine M\u00f6glichkeit w\u00e4re ein Bau-Tachymeter.\n\nWenn man nun aber die Koordinatender beiden Punktwolken vergleichen will wird ein Problem deutlich.\n\nDie beiden 3D Messger\u00e4te haben kein gemeinsames Koordinatensystem. Durch einen Sensor im Ger\u00e4t kann meist die xy-Ebene waagerecht festgelegt werden. Jedoch muss davon ausgegangen werden , dass sich\nsowohl Zentrum, als auch Ausrichtung unterscheiden.\n\nIm folgenden Bild sind zwei Punktwolken dargestellt. Beide Punktwolken beschreiben die gleichen Messpunkte, gemessen mit zwei unterschidlichen 3D Scannern. Es ist zu erkennen, dass die Ausrichtung und Position der Punktwolken nicht \u00fcbereinstimmt.","292ec6e8":"**Interpr\u00e4tation:** Es scheint, dass die Standardabweichung, in diesem Fall, keinen einfluss auf die Differenz der beiden Methoden hat.","754f71ad":"## Szenario 0: Grunds\u00e4tzliche Untersuchung\nZuerst soll untersucht werden, ob die oben beschriebene Methode gute Werte liefert.\nDaf\u00fcr werden 200 Punkte genereiert.\nDie zweite Punktwolke soll einen normalverteilten Fehler mit der Standardabweichung von 50mm haben.\n\nDer gleiche versuch wird 100 mal durchgef\u00fchrt. \nDas Ergebnis f\u00fcr die Differenz der beiden Methoden sollte ungef\u00e4hr gleich bleiben.\n","bbc77302":"# Die Methoden\nJeder 3D Scanner kann die Koordinaten der Punkte nur relativ zu seinem Internen Koordinatensystem ausgeben. Die Null-koordinaten der zu untersuchenden Scanner sind bei ihren Scans nicht im selben Punkt und auch die Ausrichtung wird sich unterscheiden. Dies stellt ein Problem dar, da die Koordinaten der jeweiligen Punkte so nicht direkt verglichen werden k\u00f6nnen.\n\n## Die indirekte Methode\nUm die Punktwolken trotzdem vergleichen zu k\u00f6nnen wird ein Trick angewendet. Anstatt die XYZ-Koordinaten zu vergleichen werden stattdessen Abst\u00e4nde zwischen allen Punkten innerhalb einer Punktwolke ausgerechnet. Bei 40 Punkten ergeben das dann nach der Formel \n$ N = \\frac{n*(n-1)}{ 2}$\n\n780 Strecken.\n\nMit der Formel \n\n$ d = \\sqrt{ (x_1-x_2)^2+(y_1-x_2)^2+(z_1-z_2)^2  } $\n\nwerden die Distanzen ausgerechnet\n\nUm den Fehler f\u00fcr jede einzelne Strecke ausrechnen zu k\u00f6nnen wird der wahre Wert f\u00fcr die Strecke gebraucht. \nEs wird die Annahme gemacht, dass die Fehler der Referenzmessung viel kleiner sind (<<) als die des Untersuchten Ger\u00e4tes.\n\n$ absoluterFehler_i = berechneteDistanz_i \u2013 wahrererWert_i $\n\nDer gewichtete Fehler f\u00fcr alle Punkte ist damit:\n\n$ RMSE = \\sqrt{\\frac{1}{N}\\sum{absoluterFehler_i^2}}  $\n","0d89459e":"**Interpr\u00e4tation:** Aus dem Graph oben wird sichtbar, dass das untersuchte Ph\u00e4nomen keine Auswirkung auf die Differenz der beiden Methoden hat.","0aee2c2a":"## Szenario 1: Auswirkung des individuellen Fehlers\nF\u00fcr das vorherige Szenario war die Standardabweichung des Fehlers, der auf jeden einzelnen Punkt des zweiten Scanns addiert wird, 50mm.\n\nNun soll untersucht werden, ob diese Standardabweichung einen einfluss auf die differenz der beiden Methoden hat","f32343c4":"![Bild1.png](attachment:Bild1.png)\n\n  *Zwei Punktwolken mit jeweils 40 Punkten*","58f00669":"**Interpr\u00e4tation:** Bei einem Faktor von 1 ist die differenz wie zu erwarten bei ungef\u00e4hr -18%.\n\nBei einem Faktor von 0 (Fehler ist nur in der XY-Ebene)gibt es keinen Unterschied zwischen den beiden Methoden.\n\nWenn der Fehler in Z-Richtung 5 mal gr\u00f6\u00dfer ist, als in der XY-Ebene, dann ergibt sich ein Unterschied von circa -70%.\nDer RMSE der indirekten Methode ist um 70% kleiner, als der der direkten Methode.","a07290cc":"versuche diesen Code auch gerne mal mit nur 200 Werten","ec72e6aa":"**Absoluter Wert der beiden RMSEs**\n\nNun wollen wir uns den Absoluten Wert des RMSE anschauen:\nDa alle werte simuliert werden, kann untersucht werden, was der RMSE der beiden Methoden \u00fcberhaupot bedeutet:\nAuf die zweite Punktwolke wird ein Normalverteilter Fehler, mit einer Standardabweichung von 50mm, in alle drei Achsrichtungen addiert.\nDies entspricht dem Messfehler des 3D-Scanners f\u00fcr jeden einzelnen Punkt.\n\nAls RMSE f\u00fcr die gesamte Messung ergibt sich (in diesem Fall):","dc19cb1b":"**Auswertung:**\nDieser Graph zeigt uns, dass der, mit der indirekten Methode berechnete, RMSE um circa 18 % kleiner ist, als der RMSE, der mit der direkten Methode berechnet wurde.\nBei 200 Punkten liegn alle Punkte in einem Bereich von +-3%\nDiese streuung ist nicht perfekt, aber sie ist ausreichend klein, um weiter zu forschen\n\nDie Anzahl der Punkte sollte aber nicht reduziert werden, denn bei 40 Punkten liegt die streuung schon bei +-6%\n\nMehr Punkte im Raum helfen aber, jedoch ist die Rechenzeit dann deutlich gr\u00f6\u00dfer.","755b8331":"## Szenario 4: Punkte auf Ebene und ungleichm\u00e4\u00dfig verteilter Fehler\nDies ist eine Kombination aus Szenario 2 und Stenario 3\n\nEs soll untersucht werden, was passiert, wenn die gemessenen Punkte nur auf einer Ebene verteilt sind und der Fehler nicht gleichm\u00e4\u00dfig in alle drei Achsen verteilt ist.\n\nEs wird sich ein unterschiedliches Verhalten zeigen, ob der gr\u00f6\u00dfere Fehler innerhalb der Ebene ist , oder ob er orthogonal zur ebene ist.\n\nIm folgenden Versuch sind die Messpunkte im Raum nur auf einer Ebene verteilt.\nDer Fehler in eine bestimmte Achsrichtung wird dann schrittweise um einen gewissen Faktor erh\u00f6ht.","4dfe84d8":"**averageRMSE_direct**     m\u00fcsste ungef\u00e4hr 86mm sein\n\n**averageRMSE_indirect**   m\u00fcsste ungef\u00e4hr 70mm sein\n\nDies ist interessant:\n\nMan nehme ein array aus normalverteiltem Fehler, mit Standardabweichung von *x*. Der RMSE dieses arrays sollte ungef\u00e4hr gleich der Standardabweichung sein. Siehe Python code unterhalb.\n\n","8a84b210":"Um die, vom zu untersuchenden 3DScanner gemessene Punktwolke mit der Referenzpunktwolke vergleichen zu k\u00f6nnen gibt es nun zwei verschiedene Methoden.\n\nIch nenne diese Methoden, die *direkte Methode* und die *indirekte Methode*","13de3c91":"# Abschluss\n**Danke** f\u00fcr das lesen dieses Notebooks.\\\nIch hoffe es hat dir gefallen, und du hast etwas gelernt.\n\nSpiel gerne auch etwas mit dem code herum,\\\nver\u00e4ndere numberOfPoints,\\\noder schaue dir die absoluten Werte f\u00fcr den RMSE an\n\n**Like** wenn es dir gefallen hat\\\n**kommentiere**, wenn du einen Fehler gefunden hast.","c66572e8":"**Erkl\u00e4rung:** Der h\u00f6here Wert kommt daher, dass zwei verrauschte werte addiert werden. Siehe code unten","e9118079":"# Simulationen"}}