{"cell_type":{"860a275f":"code","0d196924":"code","36d31337":"code","44db273f":"code","b6624c40":"code","cab5b0ea":"code","64cc6131":"code","ac9c83db":"code","b7227806":"code","2202c5c1":"code","6121595b":"code","c9349d87":"code","6c08a24e":"code","971f4c7e":"markdown","b22753b1":"markdown","ed627edf":"markdown","998d2131":"markdown","a293d2a1":"markdown","02ea1c28":"markdown","c0df6827":"markdown","be494880":"markdown","42775b31":"markdown","315995b0":"markdown","b68324ca":"markdown"},"source":{"860a275f":"import numpy as np\nimport pandas as pd\nimport numbers\nimport seaborn as sns\nimport matplotlib.pylab as plt","0d196924":"df = pd.read_csv('..\/input\/house-prices-advanced-regression-techniques\/train.csv')\ndf.head()","36d31337":"df.columns","44db273f":"df_numbers = df.select_dtypes([np.number])\ndf_numbers.head()","b6624c40":"df_imp = df_numbers[['LotFrontage', 'LotArea', 'YearBuilt', 'GrLivArea', 'BedroomAbvGr', 'KitchenAbvGr', 'GarageArea', 'PoolArea', 'SalePrice']]","cab5b0ea":"def _covhelper(x, y=None, rowvar=True, allow_masked=True):\n    \"\"\"\n    Private function for the computation of covariance and correlation\n    coefficients.\n    \"\"\"\n    x = np.ma.array(x, ndmin=2, copy=True, dtype=float)\n    xmask = np.ma.getmaskarray(x)\n    # Quick exit if we can't process masked data\n    if not allow_masked and xmask.any():\n        raise ValueError(\"Cannot process masked data.\")\n    #\n    if x.shape[0] == 1:\n        rowvar = True\n    # Make sure that rowvar is either 0 or 1\n    rowvar = int(bool(rowvar))\n    axis = 1 - rowvar\n    if rowvar:\n        tup = (slice(None), None)\n    else:\n        tup = (None, slice(None))\n    #\n    if y is None:\n        xnotmask = np.logical_not(xmask).astype(int)\n    else:\n        y = array(y, copy=False, ndmin=2, dtype=float)\n        ymask = ma.getmaskarray(y)\n        if not allow_masked and ymask.any():\n            raise ValueError(\"Cannot process masked data.\")\n        if xmask.any() or ymask.any():\n            if y.shape == x.shape:\n                # Define some common mask\n                common_mask = np.logical_or(xmask, ymask)\n                if common_mask is not nomask:\n                    xmask = x._mask = y._mask = ymask = common_mask\n                    x._sharedmask = False\n                    y._sharedmask = False\n        x = ma.concatenate((x, y), axis)\n        xnotmask = np.logical_not(np.concatenate((xmask, ymask), axis)).astype(int)\n    x -= x.mean(axis=rowvar)[tup]\n    return (x, xnotmask, rowvar)","64cc6131":"def cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None):\n    \"\"\"\n    Estimate the covariance matrix.\n    Except for the handling of missing data this function does the same as\n    `numpy.cov`. For more details and examples, see `numpy.cov`.\n    By default, masked values are recognized as such. If `x` and `y` have the\n    same shape, a common mask is allocated: if ``x[i,j]`` is masked, then\n    ``y[i,j]`` will also be masked.\n    Setting `allow_masked` to False will raise an exception if values are\n    missing in either of the input arrays.\n    Parameters\n    ----------\n    x : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `x` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same\n        form as `x`.\n    rowvar : bool, optional\n        If `rowvar` is True (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : bool, optional\n        Default normalization (False) is by ``(N-1)``, where ``N`` is the\n        number of observations given (unbiased estimate). If `bias` is True,\n        then normalization is by ``N``. This keyword can be overridden by\n        the keyword ``ddof`` in numpy versions >= 1.5.\n    allow_masked : bool, optional\n        If True, masked values are propagated pair-wise: if a value is masked\n        in `x`, the corresponding value is masked in `y`.\n        If False, raises a `ValueError` exception when some values are missing.\n    ddof : {None, int}, optional\n        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n        the number of observations; this overrides the value implied by\n        ``bias``. The default value is ``None``.\n        .. versionadded:: 1.5\n    Raises\n    ------\n    ValueError\n        Raised if some values are missing and `allow_masked` is False.\n    See Also\n    --------\n    numpy.cov\n    \"\"\"\n    # Check inputs\n    if ddof is not None and ddof != int(ddof):\n        raise ValueError(\"ddof must be an integer\")\n    # Set up ddof\n    if ddof is None:\n        if bias:\n            ddof = 0\n        else:\n            ddof = 1\n\n    (x, xnotmask, rowvar) = _covhelper(x, y, rowvar, allow_masked)\n    if not rowvar:\n        fact = np.dot(xnotmask.T, xnotmask) * 1. - ddof\n        result = (np.ma.dot(x.T, x.conj(), strict=False) \/ fact).squeeze()\n    else:\n        fact = np.dot(xnotmask, xnotmask.T) * 1. - ddof\n        result = (np.ma.dot(x, x.T.conj(), strict=False) \/ fact).squeeze()\n    return result","ac9c83db":"def correlation_from_covariance(covariance):\n    v = np.sqrt(np.diag(covariance))\n    outer_v = np.outer(v, v)\n    correlation = covariance \/ outer_v\n    correlation[covariance == 0] = 0\n    return correlation","b7227806":"masked_A = np.ma.MaskedArray(df_imp.values, np.isnan(df_imp))\ncov_np = cov(masked_A, rowvar=0).data\ncor_np = correlation_from_covariance(cov_np)","2202c5c1":"pd.DataFrame(cor_np,columns=list(df_imp.columns))","6121595b":"def plot_heatmap(array, columns):\n\n    fig, ax = plt.subplots(figsize=(10,10))\n\n    sns.heatmap(pd.DataFrame(array,columns=columns), \n            annot=True,\n            cbar = True,\n            fmt=\"0.2f\",\n            cmap=\"YlGnBu\", \n            ax=ax)","c9349d87":"plot_heatmap(df_imp.corr().values, list(df_imp.columns))","6c08a24e":"plot_heatmap(cor_np, list(df_imp.columns))","971f4c7e":"### Numpy Correlation heatmap","b22753b1":"![variance.png](attachment:variance.png)","ed627edf":"# Mathemtatics","998d2131":"### Pandas Correlation heatmap","a293d2a1":"# Correlation to Covariance","02ea1c28":"# Numpy correlation vs Pandas correlation","c0df6827":"What is the difference between covariance and correlation ?<br>\n\n**Covariance** is a measure of the degree to which returns on two assets move in tandem.<br>\n**Correlation** is a coefficient that determines the degree to which two variables movements are associated.<br>\nAlso the correlation coefficient measures linear relationship between two arrays\/vector\/asset.<br>\n<br>\nThis notebook is not a tutorial, is just open source code for people that are curious on how covariance and correlation are coded (connected)","be494880":"# Covariance implementation with numpy","42775b31":"# Numpy open source code","315995b0":"# Exploratory Data Analysis","b68324ca":"# Conclusion\n\nThe code is open source and all the credits go to Numpy developers.<br>\nhttps:\/\/github.com\/numpy"}}