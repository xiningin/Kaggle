{"cell_type":{"fe6ad618":"code","34f62674":"code","8a99d1dc":"code","62857f08":"code","da3ed825":"code","dcdaa15f":"code","5c216bc7":"code","390fc100":"code","7d00ee4a":"code","0eeaaf2d":"code","e8413d5c":"code","81c19f2d":"code","c84780fd":"code","f821952e":"code","d813edd3":"code","a513a533":"code","369b8b2c":"code","cb67f678":"code","20e0b1d5":"code","24d74704":"code","2f1a385f":"code","9402051e":"code","b9bb5996":"code","dec6812e":"code","8780e924":"code","521058a3":"code","5d6fb4b0":"markdown","df2fa164":"markdown","e4882b4b":"markdown","b5900129":"markdown","581e16f2":"markdown","bf5a0bfd":"markdown","5b441679":"markdown","3772439d":"markdown","24fedab1":"markdown","1d54c2a4":"markdown","4290a721":"markdown","4875cb70":"markdown","614330dc":"markdown","bb36f1d6":"markdown","b0608ba9":"markdown","d573e41a":"markdown"},"source":{"fe6ad618":"import warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nfrom scipy import signal\nfrom biosppy.signals import ecg, eeg, resp, eda\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()","34f62674":"dtypes = {\"crew\": \"int8\",\n          \"experiment\": \"category\",\n          \"time\": \"float32\",\n          \"seat\": \"int8\",\n          \"eeg_fp1\": \"float32\",\n          \"eeg_f7\": \"float32\",\n          \"eeg_f8\": \"float32\",\n          \"eeg_t4\": \"float32\",\n          \"eeg_t6\": \"float32\",\n          \"eeg_t5\": \"float32\",\n          \"eeg_t3\": \"float32\",\n          \"eeg_fp2\": \"float32\",\n          \"eeg_o1\": \"float32\",\n          \"eeg_p3\": \"float32\",\n          \"eeg_pz\": \"float32\",\n          \"eeg_f3\": \"float32\",\n          \"eeg_fz\": \"float32\",\n          \"eeg_f4\": \"float32\",\n          \"eeg_c4\": \"float32\",\n          \"eeg_p4\": \"float32\",\n          \"eeg_poz\": \"float32\",\n          \"eeg_c3\": \"float32\",\n          \"eeg_cz\": \"float32\",\n          \"eeg_o2\": \"float32\",\n          \"ecg\": \"float32\",\n          \"r\": \"float32\",\n          \"gsr\": \"float32\",\n          \"event\": \"category\",\n         }","8a99d1dc":"train_df = pd.read_csv('..\/input\/train.csv', dtype=dtypes)\ntrain_df.info()","62857f08":"test_df = pd.read_csv('..\/input\/test.csv', dtype=dtypes)\ntest_df.info()","da3ed825":"np.unique(train_df['crew'])","dcdaa15f":"np.unique(test_df['crew'])","5c216bc7":"np.unique(train_df['experiment'])","390fc100":"np.unique(test_df['experiment'])","7d00ee4a":"plt.figure(figsize=(15,10))\nsns.countplot(train_df['event'])\nplt.xlabel(\"State\", fontsize=12)\nplt.ylabel(\"Rows Count\", fontsize=12)\nplt.show()","0eeaaf2d":"subset = train_df.loc[(train_df['crew'] == 1) & (train_df['seat'] == 1) & (train_df['experiment'] == 'DA')]\n\nsubset = subset.sort_values(by='time')\nevents = subset['event'].values\n\nevent_dict = {\n    'A': 0,\n    'B': 1,\n    'C': 2,\n    'D': 3\n}\n\nevents = list(map(lambda e:event_dict[e], events))\n\nplt.plot(subset['ecg'].values)\nplt.figure()\nplt.plot(events)","e8413d5c":"ecg_out = ecg.ecg(signal=subset['ecg'].values, sampling_rate=256., show=False)\nplt.plot(ecg_out['heart_rate_ts'], ecg_out['heart_rate'])","81c19f2d":"plt.plot(subset['r'].values)\nplt.figure()\nresp_out = resp.resp(signal=subset['r'].values, sampling_rate=256., show=False)\nplt.plot(resp_out['resp_rate_ts'], resp_out['resp_rate'])","c84780fd":"eeg_features = [\"eeg_fp1\", \"eeg_f7\", \"eeg_f8\", \"eeg_t4\", \"eeg_t6\", \"eeg_t5\", \"eeg_t3\", \"eeg_fp2\", \"eeg_o1\", \"eeg_p3\", \"eeg_pz\", \"eeg_f3\", \"eeg_fz\", \"eeg_f4\", \"eeg_c4\", \"eeg_p4\", \"eeg_poz\", \"eeg_c3\", \"eeg_cz\", \"eeg_o2\"]\n\neeg_out = eeg.get_power_features(signal=subset[eeg_features].values, sampling_rate=256.)\nplt.plot(subset['eeg_fp1'].values)\nplt.title('raw eeg fp1')\nplt.figure()\nplt.plot(eeg_out['ts'], eeg_out['theta'][:,0])\nplt.title('theta eeg fp1')\nplt.figure()\nplt.plot(eeg_out['ts'], eeg_out['alpha_low'][:,0])\nplt.title('alpha_low eeg fp1')\nplt.figure()\nplt.plot(eeg_out['ts'], eeg_out['alpha_high'][:,0])\nplt.title('alpha_high eeg fp1')\nplt.figure()\nplt.plot(eeg_out['ts'], eeg_out['beta'][:,0])\nplt.title('beta eeg fp1')\nplt.figure()\nplt.plot(eeg_out['ts'], eeg_out['gamma'][:,0])\nplt.title('gamma eeg fp1')","f821952e":"plt.plot(subset['gsr'].values)\nplt.title('raw gsr')\nplt.figure()\ngsr_out = eda.eda(signal=subset['gsr'].values, sampling_rate=256., show=False, min_amplitude=0)\nplt.plot(subset['time'].values[gsr_out['onsets']], gsr_out['amplitudes'])\nplt.title('gsr amplitude')","d813edd3":"from scipy.interpolate import interp1d\n\ndef map_timestamped_feature_to_data(df_times, new_feature_ts, new_feature_data):\n    f = interp1d(new_feature_ts, new_feature_data, kind='cubic', fill_value=\"extrapolate\")\n    return f(df_times)","a513a533":"eeg_features = [\"eeg_fp1\", \"eeg_f7\", \"eeg_f8\", \"eeg_t4\", \"eeg_t6\", \"eeg_t5\", \"eeg_t3\", \"eeg_fp2\", \"eeg_o1\", \"eeg_p3\", \"eeg_pz\", \"eeg_f3\", \"eeg_fz\", \"eeg_f4\", \"eeg_c4\", \"eeg_p4\", \"eeg_poz\", \"eeg_c3\", \"eeg_cz\", \"eeg_o2\"]\n\ndef extract_features_for_pilot(data_df, pilot_loc):\n    curr_pilot_values = data_df.loc[pilot_loc][['time', 'ecg', 'r', 'gsr'] + eeg_features].values\n    curr_pilot_values = curr_pilot_values[curr_pilot_values[:,0].argsort()]\n    \n    if np.allclose(curr_pilot_values[:,1], 0, rtol=1e-10):\n        data_df.loc[pilot_loc, 'ecg'] = np.nan\n        print(f'\\tmissing egc')\n    else:\n        try:\n            heart_out = ecg.ecg(signal=curr_pilot_values[:,1], sampling_rate=256., show=False)\n            heart_rate = heart_out['heart_rate']\n            heart_rate_ts = heart_out['heart_rate_ts']\n            data_df.loc[pilot_loc, 'heart_rate'] = map_timestamped_feature_to_data(curr_pilot_values[:,0], heart_rate_ts, heart_rate)\n        except ValueError:\n            print(f'\\tfailed \"heart_rate\" extraction')\n    \n    if np.allclose(curr_pilot_values[:,2], 0, rtol=1e-10):\n        data_df.loc[pilot_loc, 'r'] = np.nan\n        print(f'\\tmissing r')\n    else:\n        try:\n            resp_out = resp.resp(signal=curr_pilot_values[:,2], sampling_rate=256., show=False)\n            resp_rate = resp_out['resp_rate']\n            resp_rate_ts = resp_out['resp_rate_ts']\n            data_df.loc[pilot_loc, 'resp_rate'] = map_timestamped_feature_to_data(curr_pilot_values[:,0], resp_rate_ts, resp_rate)\n        except ValueError:\n            print(f'\\tfailed \"resp_rate\" extraction')\n        \n    if np.allclose(curr_pilot_values[:,3], 0, rtol=1e-10):\n        data_df.loc[pilot_loc, 'gsr'] = np.nan\n        print(f'\\tmissing gsr')\n    else:\n        try:\n            gsr_out = eda.eda(signal=curr_pilot_values[:,3], sampling_rate=256., show=False)\n            gsr_amp = gsr_out['amplitudes']\n            gsr_amp_ts = curr_pilot_values[gsr_out['onsets'], 0]\n            data_df.loc[pilot_loc, 'gsr_amp'] = map_timestamped_feature_to_data(curr_pilot_values[:,0], gsr_amp_ts, gsr_amp)\n        except IndexError:\n            print(f'\\tfailed \"gsr_amp\" extraction')\n        except ValueError:\n            print(f'\\tfailed \"gsr_amp\" extraction')\n        \n    try:\n        eeg_feat_out = eeg.get_power_features(signal=curr_pilot_values[:,4:], sampling_rate=256.)\n        eeg_ts = eeg_feat_out['ts']\n        eeg_theta = eeg_feat_out['theta']\n        eeg_alpha_low = eeg_feat_out['alpha_low']\n        eeg_alpha_high = eeg_feat_out['alpha_high']\n        eeg_beta = eeg_feat_out['beta']\n        eeg_gamma = eeg_feat_out['gamma']\n        for i, eeg_feature in enumerate(eeg_features):\n            data_df.loc[pilot_loc, eeg_feature + '_theta'] = map_timestamped_feature_to_data(curr_pilot_values[:,0], eeg_ts, eeg_theta[:,i])\n            data_df.loc[pilot_loc, eeg_feature + '_alpha_low'] = map_timestamped_feature_to_data(curr_pilot_values[:,0], eeg_ts, eeg_alpha_low[:,i])\n            data_df.loc[pilot_loc, eeg_feature + '_alpha_high'] = map_timestamped_feature_to_data(curr_pilot_values[:,0], eeg_ts, eeg_alpha_high[:,i])\n            data_df.loc[pilot_loc, eeg_feature + '_beta'] = map_timestamped_feature_to_data(curr_pilot_values[:,0], eeg_ts, eeg_beta[:,i])\n            data_df.loc[pilot_loc, eeg_feature + '_gamma'] = map_timestamped_feature_to_data(curr_pilot_values[:,0], eeg_ts, eeg_gamma[:,i])\n    except ValueError:\n        print(f'\\tfailed \"eeg\"')\n","369b8b2c":"enhanced_train_df = train_df.copy()\nenhanced_train_df['heart_rate'] = np.nan\nenhanced_train_df['resp_rate'] = np.nan\nenhanced_train_df['gsr_amp'] = np.nan\n\nfor eeg_feature in eeg_features:\n    enhanced_train_df[eeg_feature + '_theta'] = np.nan\n    enhanced_train_df[eeg_feature + '_alpha_low'] = np.nan\n    enhanced_train_df[eeg_feature + '_alpha_high'] = np.nan\n    enhanced_train_df[eeg_feature + '_beta'] = np.nan\n    enhanced_train_df[eeg_feature + '_gamma'] = np.nan\n\nfor tup in [(c,s,e) for c in np.unique(enhanced_train_df['crew']) for s in np.unique(enhanced_train_df['seat']) for e in np.unique(enhanced_train_df['experiment'])]:\n    c, s, e = tup\n    pilot_loc = (enhanced_train_df['crew'] == c) & (enhanced_train_df['seat'] == s) & (enhanced_train_df['experiment'] == e)\n    print(f'extracting for {tup}')\n    extract_features_for_pilot(enhanced_train_df, pilot_loc)\n    ","cb67f678":"features = [\"eeg_fp1\", \"eeg_f7\", \"eeg_f8\", \"eeg_t4\", \"eeg_t6\", \"eeg_t5\", \"eeg_t3\", \"eeg_fp2\", \"eeg_o1\", \"eeg_p3\", \"eeg_pz\", \"eeg_f3\", \"eeg_fz\", \"eeg_f4\", \"eeg_c4\", \"eeg_p4\", \"eeg_poz\", \"eeg_c3\", \"eeg_cz\", \"eeg_o2\", \"ecg\", \"r\", \"gsr\", 'heart_rate', 'resp_rate', 'gsr_amp']\n\nfor eeg_feature in eeg_features:\n    features += [eeg_feature + '_theta']\n    features += [eeg_feature + '_alpha_low']\n    features += [eeg_feature + '_alpha_high']\n    features += [eeg_feature + '_beta']\n    features += [eeg_feature + '_gamma']\n\nsubset = enhanced_train_df.loc[(enhanced_train_df['crew'] == 5) & (enhanced_train_df['seat'] == 0)]\n\nf, ax = plt.subplots(figsize=(10, 8))\ncorr = subset[features].corr()\nsns.heatmap(corr, mask=np.zeros_like(corr, dtype=np.bool), cmap=sns.diverging_palette(220, 10, as_cmap=True),\n            square=True, ax=ax)","20e0b1d5":"params = {\n    \"objective\" : \"multiclass\",\n    \"num_class\": 4,\n    \"metric\" : \"multi_error\",\n    \"num_leaves\" : 30,\n    \"max_depth\" : 8,\n    \"min_child_weight\" : 50,\n    \"learning_rate\" : 0.1,\n    \"bagging_fraction\" : 0.7,\n    \"feature_fraction\" : 0.7,\n    \"bagging_seed\" : 42,\n    \"verbosity\" : -1,\n    \"n_estimators\": 25\n}\n\nfeatures = [\"eeg_fp1\", \"eeg_f7\", \"eeg_f8\", \"eeg_t4\", \"eeg_t6\", \"eeg_t5\", \"eeg_t3\", \"eeg_fp2\", \"eeg_o1\", \"eeg_p3\", \"eeg_pz\", \"eeg_f3\", \"eeg_fz\", \"eeg_f4\", \"eeg_c4\", \"eeg_p4\", \"eeg_poz\", \"eeg_c3\", \"eeg_cz\", \"eeg_o2\", \"ecg\", \"r\", \"gsr\", 'heart_rate', 'resp_rate', 'gsr_amp']\n\nfor eeg_feature in eeg_features:\n    features += [eeg_feature + '_theta']\n    features += [eeg_feature + '_alpha_low']\n    features += [eeg_feature + '_alpha_high']\n    features += [eeg_feature + '_beta']\n    features += [eeg_feature + '_gamma']","24d74704":"from sklearn import preprocessing as prep\n\nle = prep.LabelEncoder()\nle.fit(enhanced_train_df['event'])","2f1a385f":"from sklearn.model_selection import train_test_split\n# import xgboost as xgb\nimport lightgbm as lgb\nfrom sklearn import metrics\n\nconf_matrix = np.zeros((4,4))\n\nfor tup in [(x,y) for x in np.unique(enhanced_train_df['crew']) for y in np.unique(enhanced_train_df['seat'])]:\n\n    one_pilot_train_df = enhanced_train_df[(enhanced_train_df['crew'] == tup[0]) & (enhanced_train_df['seat'] == tup[1])]\n    temp_train_df, temp_val_df = train_test_split(one_pilot_train_df, test_size=0.4, random_state=42)\n\n    X_train = temp_train_df[features]\n    y_train = le.transform(temp_train_df['event'])\n\n    X_test = temp_val_df[features]\n    y_test = le.transform(temp_val_df['event'])\n    \n    clf = lgb.LGBMClassifier(**params)\n    clf.fit(X_train, y_train)\n    results = clf.predict_proba(X_test)\n    \n    y_pred = np.argmax(results, 1)\n    \n    conf_matrix += metrics.confusion_matrix(y_test, y_pred)\n\n    print(f'pilot {tup} logloss: {metrics.log_loss(y_test, results, eps=1e-15)}')\n","9402051e":"import itertools\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n    plt.tight_layout()\n\nf = plt.figure()\nf.set_figwidth(12)\nplot_confusion_matrix(conf_matrix, le.classes_, normalize=True)","b9bb5996":"one_pilot_train_df = enhanced_train_df[(enhanced_train_df['crew'] == 5) & (enhanced_train_df['seat'] == 0)]\nX_train = one_pilot_train_df[features]\ny_train = le.transform(one_pilot_train_df['event'])\n\nclf = lgb.LGBMClassifier(**params)\nclf.fit(X_train, y_train)\n\nlgb.plot_importance(clf, max_num_features=30, figsize=(20,10))","dec6812e":"all_results = np.zeros((test_df['id'].shape[0], 5))\nall_results[:, 0] = test_df['id']\n\nfor tup in [(x,y) for x in np.unique(test_df['crew']) for y in np.unique(test_df['seat'])]:\n    \n    print(f'pilot {tup}')\n    \n    train_rows = (enhanced_train_df['crew'] == tup[0]) & (enhanced_train_df['seat'] == tup[1])\n    test_rows = (test_df['crew'] == tup[0]) & (test_df['seat'] == tup[1])\n    \n    one_pilot_train_df = enhanced_train_df[train_rows]\n    one_pilot_test_df = test_df[test_rows].copy()\n    extract_features_for_pilot(one_pilot_test_df, one_pilot_test_df.index.values)\n    \n    for f in features:\n        if f not in one_pilot_test_df.columns:\n            one_pilot_test_df[f] = np.nan\n    \n    X_train = one_pilot_train_df[features]\n    y_train = le.transform(one_pilot_train_df['event'])\n    \n    X_test = one_pilot_test_df[features]\n    \n    clf = lgb.LGBMClassifier(**params)\n    clf.fit(X_train, y_train)\n    pilot_results = clf.predict_proba(X_test)\n    \n    all_results[np.where(test_rows), 1:5] = pilot_results","8780e924":"submission = pd.DataFrame(all_results, columns=['id', 'A', 'B', 'C', 'D'])\nsubmission['id'] = submission['id'].astype(int)\n\nsubmission.head()","521058a3":"submission.to_csv(\"submission.csv\", index=False)","5d6fb4b0":"The sensors are: \n* **eeg** - Electroencephalogram - brain electrical activity sensors\n* **ecg** - Electrocardiogram - heart electrical activity sensor, \n* **r** - Respiration - chest movement sensor \n* **gsr** - Galvanic Skin Response - skin reponse sensor.\n\nOur target feature is 'event'. There are 4 events in this test with the labels which we need to learn and predict:\n* **A** - baseline\n* **B** - SS - Startle\/Surprise\n* **C** - CA - Channelized Attention\n* **D** - DA - Diverted Attention","df2fa164":"### Biosppy\nInspired by [Introduction to physiological data](https:\/\/www.kaggle.com\/stuartbman\/introduction-to-physiological-data), we'll look at what biosppy package can offer us.\n\nwe'll look at a single pilot on a single experiment. starting with ecg raw data compared to the target feature","e4882b4b":"And now GSR","b5900129":"same with respiration and it's amplitude","581e16f2":"# Data Exploration\n\nEach row is a set of samples from sensors in a specific timestamp, this row is unique for each pilot (a pilot is determined by the tuple (crew, seat) .<br>\n\nThere are 9 unique crews.<br>\nIn each crew there are two pilots, one on the left seat and one on the right seat.<br>\n\nThe same exact crews are in the test data.<br>\n\nThe train data is collected from experiments where the pilots were given tasks to complete while in different situations.<br>\nThe test data is collected while doing a flight simulation.<br>\n\nTherefore we will not use the 'experiment', 'crew', and 'seat' features, as they will not be useful for the prediction.<br>","bf5a0bfd":"Some pilots have missing sensors, which will read constant 0, we want to set them to np.nan so we can ignore them during learning\/predicting.","5b441679":"# Prediction for Test Data","3772439d":"W'll look at how our target class distribute","24fedab1":"The package biosspy returns timestamped values, so we will use cubic interpolation to give values for timestamps in between.","1d54c2a4":"We can expect issues with classes D and B being under represented","4290a721":"# Feature Engineering","4875cb70":"Loading the data, we chose specific types for the given columns to reduce memory usage","614330dc":"the package allows us to extract the heart rate.","bb36f1d6":"Now the eeg sensors","b0608ba9":"# Choosing a Model\n\nWe're dealing with a multi-class classification problem, we've decided to use boosting of decision trees. More specifically, LightGBM library.<br>\n\nWe're using some basic parameters, using mainly num_leaves and min_child_weight to avoid overfitting, but also subsample and colsample.","d573e41a":"# Reducing Commercial Aviation Fatalities\n"}}