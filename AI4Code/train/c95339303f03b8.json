{"cell_type":{"337c92a7":"code","ae62b0b0":"code","1c2cb18f":"code","085f0e88":"code","476b6cb8":"code","5a14dc80":"code","4004e8f5":"code","34037c9c":"code","b80e2506":"markdown","80a4a63e":"markdown"},"source":{"337c92a7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","ae62b0b0":"import cv2\nimport os\nimport matplotlib.pyplot as plt\nimport random\nimport math\nfrom PIL import Image","1c2cb18f":"def conv(img, kernel):\n    kH,kW = kernel.shape\n    (imH,imW) = img.shape\n    new_img = np.zeros(img.shape)\n    pad = int((kH-1)\/2)\n    \n    for y in range(imH-kH):\n        for x in range(imW-kW):\n            window = img[y:y+kH,x:x+kW]\n            new_img[y+pad,x+pad] = (kernel * window).sum()\n    \n    return new_img\n            \n        \n    \n    ","085f0e88":"def get_image():\n    DATADIR = \"..\/input\/fruit-images-for-object-detection\/test_zip\/test\"\n    \n    \n    selected = False\n    while(selected == False):\n        rand = random.randrange(0,len(os.listdir(DATADIR)))\n        img_name = (os.listdir(DATADIR))[rand]\n        if img_name.endswith(\"jpg\"):\n            img = Image.open(os.path.join(DATADIR, (os.listdir(DATADIR))[rand])).convert('L')\n            img_arr = np.asarray(img)\n            selected = True\n\n    return img_arr","476b6cb8":"def sobel_filter(img):\n    sobelx = np.array([[-1,0,1],\n                     [-2,0,2],\n                     [-1,0,1]])\n\n    sobely = np.array([[-1,-2,-1],\n                     [0,0,0],\n                     [1,2,1]])\n    \n    kH,kW = sobelx.shape\n    (imH,imW) = img.shape\n    new_img = np.zeros(img.shape)\n    theta = np.zeros(img.shape)\n    hsv_img = np.zeros((img.shape[0],img.shape[1],3))\n    nms_img = np.zeros(img.shape)\n    pad = int((kH-1)\/2)\n    \n    for y in range(imH-kH):\n        for x in range(imW-kW):\n            window = img[y:y+kH,x:x+kW]\n            new_img[y+pad,x+pad] = (((sobelx * window).sum())**2 + ((sobely * window).sum())**2)**0.5\n            if(new_img[y+pad,x+pad] > 0):\n                if((sobelx * window).sum() == 0):\n                    theta[y+pad,x+pad] = 90\n                else:\n                    theta[y+pad,x+pad] = (math.degrees(math.atan((sobely * window).sum()\/(sobelx * window).sum())))%180\n                    \n                    \n                    \n                    \n    for i in range(imH-1):\n        for j in range(imW-1):\n            if(theta[i,j] != 0):\n                quad = theta[i,j]\/\/22.5\n                neighborA = 255\n                neighborB = 255\n\n                if quad in [0,8]:\n                    neighborA = new_img[i,j-1] #Left\n                    neighborB = new_img[i,j+1] #Right\n                elif quad in [1,2]:\n                    neighborA = new_img[i-1,j-1] #LowerLeft\n                    neighborB = new_img[i+1,j+1] #UpperRight\n                elif quad in [5,6]:\n                    neighborA = new_img[i-1,j+1] #LowerRight\n                    neighborB = new_img[i+1,j-1] #UpperLeft\n                elif quad in [3,4]:\n                    neighborA = new_img[i-1,j] #Down\n                    neighborB = new_img[i+1,j] #Up\n                if(max([neighborA,new_img[i,j],neighborB]) == new_img[i,j] and new_img[i,j] >= 255 * 0.4):\n                    nms_img[i,j] = new_img[i,j]\n                    hsv_img[i,j,:] = [theta[i,j],255,255]\n                \n             \n            \n            \n    return new_img.astype(np.uint8),hsv_img.astype(np.uint8),nms_img.astype(np.uint8)\n            ","5a14dc80":"img = get_image()\nimg = cv2.GaussianBlur(img,(3,3),0)","4004e8f5":"sobel_img,hsv_img,nms_img = sobel_filter(img)\n\nplt.figure()\nplt.title(\"Original Image (grayscale)\")\nplt.imshow(img,cmap='gray')\nplt.figure()\nplt.title(\"After applying Sobel Filter\")\nplt.imshow(sobel_img,cmap='gray')\nplt.figure()\nplt.title(\"After applying NMS and Double Threshold\")\nplt.imshow(nms_img,cmap='gray')\nplt.figure()\nplt.title(\"Color representation of gradient direction\")\nplt.imshow(cv2.cvtColor(hsv_img,cv2.COLOR_HSV2RGB))","34037c9c":"count = 0\nblur = cv2.GaussianBlur(img,(3,3),0.5)\nplt.figure(figsize=(10,10))\nwhile(True):\n    blur = cv2.GaussianBlur(blur,(3,3),0)\n    new_blur = cv2.GaussianBlur(blur,(3,3),0)\n    count+=1\n    plt.subplot(2,3,count)\n    plt.imshow((blur-new_blur),cmap=\"gray\")\n    if(count == 6):\n        break\n    blur = new_blur\nplt.tight_layout()\nplt.show()","b80e2506":"# Sobel Operator\n\n* Applies convolution with a Sobel filter in both the x and y directions. \n* The filter returns a larger sum (gradient) if the difference in pixel values are larger in the specified direction.\n* Find the magnitude of the resultant gradient\n\n    ","80a4a63e":"# Feature extraction by Differece of Gaussian\n\n1. Apply Gaussian filter on image (results in blurring the image)\n2. Subtract the pixel values of the original image by the image generated from step 1.\n\nWe can repeate the 2 steps successively to produce features that are more distinct. This is due to the loss of less distinct features as the image is blurred.\n"}}