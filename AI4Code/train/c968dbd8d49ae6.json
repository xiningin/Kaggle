{"cell_type":{"ff0c19aa":"code","160df6cb":"code","fe99174e":"code","745139e2":"code","24f0e5b2":"code","e1d35e54":"code","96c0947d":"code","cf06982c":"code","7aac1b75":"code","58755889":"code","d4080587":"code","0e0ad34d":"code","215a0975":"code","2315195a":"code","ad7cbd9a":"code","3cb5b5f7":"code","6c36764e":"code","a5f2408e":"markdown","8cf1aa12":"markdown","024bf791":"markdown","c863d8d7":"markdown","f20bfc5e":"markdown","9459d19c":"markdown","47d7f728":"markdown","7e9d1c7c":"markdown","773cf9a6":"markdown","250a2890":"markdown"},"source":{"ff0c19aa":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","160df6cb":"import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport math","fe99174e":"def mapping(df):\n    \n    mappers = []\n    for col in df.columns:\n        if df[col].dtypes == 'O' and col != 'customerID' and col != 'TotalCharges':\n            dic = {}\n            dic[col] = {}\n            values = df[col].unique()\n            count = 0\n            for value in values:\n                dic[col][value] = count\n                count += 1\n            mappers.append(dic)\n        \n    return mappers     ","745139e2":"def replace_categorical(df, mappers):\n    df_mapped = df.copy()\n    for i in mappers:\n        col = list(i.keys())[0]\n        df_mapped[col] = df_mapped[col].replace(list(i.values())[0])\n\n    return df_mapped","24f0e5b2":"def plot_var_percentages (df, var_list):\n\n    n_rows = math.ceil(len(var_list)\/3)\n    mapper = []\n    count_c = 0\n    count_r = 0\n    for n in range(len(var_list)):\n        if count_c <= 2:\n            mapper.append((count_r,count_c))\n            count_c += 1\n        else:\n            count_r += 1\n            count_c = 0\n            \n    #fig, axes = plt.subplots(nrows = n_rows,ncols = 3,figsize = (15,12))\n    for i,var in enumerate(var_list):\n        \n        labels = list(df[var].value_counts().index)\n        counts = list(df[var].value_counts())\n        \n        plt.figure(i)\n        plt.pie(counts, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)\n        plt.title(var)\n    plt.show    ","e1d35e54":"telecom_cust = pd.read_csv('..\/input\/telco-customer-churn\/WA_Fn-UseC_-Telco-Customer-Churn.csv')\n","96c0947d":"telecom_cust.dtypes","cf06982c":"mappers = mapping(telecom_cust)\ndf = replace_categorical(telecom_cust, mappers)\ndf.TotalCharges = pd.to_numeric(df.TotalCharges, errors='coerce')\ndf.dropna(inplace=True)\ndf.dtypes","7aac1b75":"var_list = telecom_cust.columns[1:-3]\nvar_list = var_list.drop('tenure')\nplot_var_percentages(telecom_cust, var_list)\n","58755889":"corrMatrix = df.corr()\nfig, ax = plt.subplots(figsize=(30,25))\nsns.heatmap(corrMatrix,annot=True, annot_kws={'size':12},cmap=\"GnBu\")\nplt.show();","d4080587":"attrib_variables = ['gender', 'SeniorCitizen', 'Partner', 'Dependents']\n\nfor var in attrib_variables:\n    ax1 = sns.catplot(x=var, kind=\"count\", hue=\"Churn\", data=telecom_cust)","0e0ad34d":"service_variables = ['PhoneService', 'MultipleLines', 'InternetService', 'OnlineSecurity', 'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies']\n\nfor var in service_variables:\n    ax1 = sns.catplot(x=var, kind=\"count\", hue=\"Churn\", data=telecom_cust)","215a0975":"from sklearn.preprocessing import MinMaxScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.ensemble import RandomForestClassifier\nfrom xgboost import XGBClassifier\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import plot_confusion_matrix","2315195a":"def preprocessing(df, corr_limit, vars_to_scale):\n    \n    variables = list(churn_corr.loc[churn_corr>=corr_limit].index)\n    df_set = df.loc[:,variables]\n    \n    for var in vars_to_scale:\n        if var in df_set.columns:\n            scaler = MinMaxScaler()\n            df_set[var] = scaler.fit_transform(df_set[var].values.reshape(-1,1)).reshape(1,-1)[0]\n            \n    X_train, X_test, y_train, y_test = train_test_split(df_set.iloc[:,:-1], df_set.iloc[:,-1], test_size=0.2, random_state=42)\n        \n    return X_train, X_test, y_train, y_test\ncorr_limit = 0.15","ad7cbd9a":"# First, let's see what the balance of the dataset is:\n\nplot_var_percentages(df,['Churn'])","3cb5b5f7":"# Variable selection for training\n# As seen above, all services have strong correlation with each other. \n# We'll select the strongest one of them, ad forget about the others\ncorrMatrix = df.corr()\nchurn_corr = corrMatrix['Churn'].abs()\n\ntech_variables = ['InternetService', 'OnlineSecurity', 'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies']\nvars_to_scale  = ['tenure', 'MonthlyCharges', 'TotalCharges']\nhighest_corr_service = 'TechSupport'\ntech_variables.remove(highest_corr_service)\nchurn_corr.drop(tech_variables, inplace=True)\n\n# SET 1.\n# Seleccion of variables with a correlation higher than the 20%\n\n# SET 1: correl >= 0.2\n# RANDOM FOREST:\n#    SCORES:\n#       Default Params: 74.4%\n#       Opt Params.     77.5%\n# XGBoost:\n#    SCORES:\n#       Default Params: 75.4%\n#       Opt Params.     77.8%\n\n# SET 2: corrrel >= 0.15\n# RANDOM FOREST:\n#    SCORES:\n#       Opt Params.     79.3%\n# XGBoost:\n#    SCORES:\n#       Opt Params.     78.7%\n\n# SET 2: corrrel >= 0.10\n# RANDOM FOREST:\n#    SCORES:\n#       Opt Params.     78.8%\n# XGBoost:\n#    SCORES:\n#       Opt Params.     78.7%\n\nX_train, X_test, y_train, y_test = preprocessing(df, 0.15, vars_to_scale)\n\nRF = RandomForestClassifier(n_estimators=100,\n                            criterion='entropy',\n                            max_depth=5,\n                            min_samples_leaf=2,\n                            min_samples_split=2,\n                            class_weight={0:1,1:2})\nRF.fit(X_train, y_train)\nprint('Random Forest\\n')\nprint('RF Score: \\n',RF.score(X_test, y_test))\nprint('F1 Score: \\n',f1_score(y_test,RF.predict(X_test)))\n\nplot_confusion_matrix(RF, X_test, y_test)\n\nXGB = XGBClassifier(objective = 'binary:logistic',\n                    n_estimators = 20,\n                    max_depth = 2,\n                    n_jobs = -1)\nXGB.fit(X_train, y_train,)\nprint('XGBoost\\n')\nprint('XGB Score: \\n',accuracy_score(y_test, XGB.predict(X_test)))\nprint('F1 Score: \\n',f1_score(y_test,XGB.predict(X_test)))\nplot_confusion_matrix(XGB, X_test, y_test)\n\n\n#parameters = {'n_estimators':[10,15,20]}\n#GridSearch = GridSearchCV(XGB, parameters)\n#GridSearch.fit(X_train, y_train)\n#print(GridSearch.score(X_test, y_test))\n#print(GridSearch.best_params_)\n","6c36764e":"X_train, X_test, y_train, y_test = preprocessing(df, 0.15, vars_to_scale)\n\nRF = RandomForestClassifier(n_estimators=100,\n                            criterion='entropy',\n                            max_depth=5,\n                            min_samples_leaf=2,\n                            min_samples_split=2,\n                            class_weight={0:1,1:4})\nRF.fit(X_train, y_train)\nprint('Random Forest\\n')\nprint('RF Score: \\n',RF.score(X_test, y_test))\nprint('F1 Score: \\n',f1_score(y_test,RF.predict(X_test)))\n\nplot_confusion_matrix(RF, X_test, y_test)","a5f2408e":"As seen, the dataset is highly un-balanced. We must take that into account when we look at the results, either giving more weight to one class or by balancing the data.","8cf1aa12":"As we can see, if we change the weights, we can get better results on the false negatives.\nAt this point, it would depend on the companys demands. Wether they want to avoid false negatives at the cost of expending more resources on false positives, or if they want a more balanced result at the cost of losing more clients...","024bf791":"# **Service Atributes of Churn costumers**","c863d8d7":"# **Personal Atributes of Churn costumers**","f20bfc5e":"# **Use of mapping functions and fix of TotalCharges column**","9459d19c":"# **Lets check the Heatmap of correlations. Categorical will be included, although some of them won't be of much use in the study.**","47d7f728":"# **Prediction**","7e9d1c7c":"# **Data exploration**","773cf9a6":"As **Random Forest** works better here, let's try changing the weights a bit in favor of the lower side of the scale.","250a2890":"# **First create the functions to mapp all the categorical variables**"}}