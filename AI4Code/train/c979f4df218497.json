{"cell_type":{"da31c08f":"code","ecb85478":"code","a2e9d802":"code","f6c1b62a":"code","7e921b29":"code","17ce6b59":"code","c8545803":"code","57341d8c":"code","e3f4fffb":"code","eda1b654":"code","9b8e5d45":"code","4f756ae1":"code","40dec46f":"code","1ee6b317":"code","91fdc4a6":"code","63d77fac":"code","1056dd4d":"code","32e456fe":"code","faf8955f":"code","cad6d25b":"code","5477d77d":"code","35f45faa":"code","b0545ab4":"code","839b5cc8":"code","056ef5ef":"code","aa96ffdd":"code","33dc1018":"markdown","457b8d8c":"markdown"},"source":{"da31c08f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","ecb85478":"newfile ='\/kaggle\/input\/santa-workshop-tour-2019\/sample_submission.csv'","a2e9d802":"def FindLoop(Edges, Vertices, n):\n    dist = {}\n    Source = {}\n    for a in Vertices:\n        for t in range(n+1):\n            Source[(a,t)] = a # moving from Source to a at time t\n    for a in Vertices:\n        for t in range(n+2):\n            dist[(a,t)] = 0 # minimal distance to a from root in t steps or less\n    \n    for i in range(n+1):\n        for a in Vertices:\n            dist[(a,i+1)] = dist[(a,i)]\n        for (a, b, w) in Edges:\n                if dist[(b,i+1)] > dist[(a,i)]+w:\n                    dist[(b,i+1)] = dist[(a,i)]+w\n                    Source[(b,i+1)] = a\n    Vert = []\n    for b in Vertices:\n        if dist[(b,n+1)] < dist[(b,n)] - 0.1:\n            Vert.append(b)\n    if Vert == []:\n        return []\n    \n    Loops = []\n    for B in Vert:\n        List = [B]\n        for i in range(n+1,0, -1):\n            b = List[-1]\n            a = Source[(b,i)]\n            if a != b:\n                List.append(a)\n        End = -1\n        for i in range(1,len(List)):\n            if List[i] in List[:i]:\n                End = i\n                break\n        if End == -1:\n            continue\n        for i in range(len(List)):\n            if List[i] == List[End]:\n                Start = i\n                break\n        FinalList = List[Start: End+1]\n        FinalList.reverse()\n        Loops.append(FinalList)\n    return Loops  ","f6c1b62a":"Old = pd.read_csv(newfile)","7e921b29":"fpath = '\/kaggle\/input\/santa-workshop-tour-2019\/family_data.csv'\ndata = pd.read_csv(fpath, index_col='family_id')\n\nfpath = '\/kaggle\/input\/santa-workshop-tour-2019\/sample_submission.csv'\nsubmission = pd.read_csv(fpath, index_col='family_id')","17ce6b59":"family_size_dict = data[['n_people']].to_dict()['n_people']\n\ncols = [f'choice_{i}' for i in range(10)]\nchoice_dict = data[cols].to_dict()\n\nN_DAYS = 100\nMAX_OCCUPANCY = 300\nMIN_OCCUPANCY = 125\n\n# from 100 to 1\ndays = list(range(N_DAYS,0,-1))","c8545803":"GoodDays = {}\nfor i in range(5000):\n    ans = [choice_dict['choice_'+str(j)][i] for j in range(10)]\n    GoodDays[i] = ans\n\n    ","57341d8c":"def cal_cost(n):\n    arr = np.zeros((11,))\n    arr[0] = 0\n    arr[1] = 50\n    arr[2] = 50 + 9 * n\n    arr[3] = 100 + 9 * n\n    arr[4] = 200 + 9 * n\n    arr[5] = 200 + 18 * n\n    arr[6] = 300 + 18 * n\n    arr[7] = 300 + 36 * n\n    arr[8] = 400 + 36 * n\n    arr[9] = 500 + 235 * n\n    arr[10] = 500 + 434 * n\n    return arr","e3f4fffb":"cols = [f'choice_{i}' for i in range(10)]\nchoice = np.array(data[cols])","eda1b654":"cost = np.zeros((5000,101),dtype='int32')\nfor i in range(5000):\n    for j in range(101):\n        cost[i,j]=cal_cost(family_size_dict[i])[10]\nfor i in range(5000):\n    for j in range(10):\n        c = choice[i,j]\n        n = family_size_dict[i]\n        cost[i,c] = cal_cost(n)[j]\n\nprint(cost.shape)","9b8e5d45":"def cost_function(prediction):\n\n    penalty = 0\n\n    # We'll use this to count the number of people scheduled each day\n    daily_occupancy = {}\n    for k in days:\n        daily_occupancy[k] = 0\n  \n    \n    # Looping over each family; d is the day for each family f\n    for f, d in enumerate(prediction):\n\n        # Using our lookup dictionaries to make simpler variable names\n        n = family_size_dict[f]\n        choice_0 = choice_dict['choice_0'][f]\n        choice_1 = choice_dict['choice_1'][f]\n        choice_2 = choice_dict['choice_2'][f]\n        choice_3 = choice_dict['choice_3'][f]\n        choice_4 = choice_dict['choice_4'][f]\n        choice_5 = choice_dict['choice_5'][f]\n        choice_6 = choice_dict['choice_6'][f]\n        choice_7 = choice_dict['choice_7'][f]\n        choice_8 = choice_dict['choice_8'][f]\n        choice_9 = choice_dict['choice_9'][f]\n\n        # add the family member count to the daily occupancy\n        daily_occupancy[d] += n\n\n        # Calculate the penalty for not getting top preference\n        if d == choice_0:\n            penalty += 0\n        elif d == choice_1:\n            penalty += 50\n        elif d == choice_2:\n            penalty += 50 + 9 * n\n        elif d == choice_3:\n            penalty += 100 + 9 * n\n        elif d == choice_4:\n            penalty += 200 + 9 * n\n        elif d == choice_5:\n            penalty += 200 + 18 * n\n        elif d == choice_6:\n            penalty += 300 + 18 * n\n        elif d == choice_7:\n            penalty += 300 + 36 * n\n        elif d == choice_8:\n            penalty += 400 + 36 * n\n        elif d == choice_9:\n            penalty += 500 + 36 * n + 199 * n\n        else:\n            penalty += 500 + 36 * n + 398 * n\n\n    # for each date, check total occupancy\n    #  (using soft constraints instead of hard constraints)\n    for _, v in daily_occupancy.items():\n        if (v > MAX_OCCUPANCY) or (v < MIN_OCCUPANCY):\n            penalty += 300000000\n\n    # Calculate the accounting cost\n    # The first day (day 100) is treated special\n    accounting_cost = (daily_occupancy[days[0]]-125.0) \/ 400.0 * daily_occupancy[days[0]]**(0.5)\n    # using the max function because the soft constraints might allow occupancy to dip below 125\n    accounting_cost = max(0, accounting_cost)\n    \n    # Loop over the rest of the days, keeping track of previous count\n    yesterday_count = daily_occupancy[days[0]]\n    for day in days[1:]:\n        today_count = daily_occupancy[day]\n        diff = abs(today_count - yesterday_count)\n        accounting_cost += max(0, (daily_occupancy[day]-125.0) \/ 400.0 * daily_occupancy[day]**(0.5 + diff \/ 50.0))\n        yesterday_count = today_count\n\n    penalty += accounting_cost\n\n    return penalty","4f756ae1":"cost_function(submission.assigned_day)","40dec46f":"def f(a,b):\n    if a< 125 and a > 0 :\n        return 300000000\n    if b <125 and b >0:\n        return 300000000\n    if a > 300:\n        return 300000000\n    if b >300:\n        return 300000000\n    if a == 0:\n        return 0\n    else :\n        return ((a-125)\/400)*(a**(0.5+ (abs(a-b)\/50)))","1ee6b317":"best = Old['assigned_day'].tolist()\nstart_score = cost_function(best)\nnew = best.copy()","91fdc4a6":"start_score","63d77fac":"V = [[],[],[],[],[],[],[],[],[]]\nfor i in range(5000):\n        b = data['n_people'][i]\n        V[b].append(i)","1056dd4d":"best_score = start_score","32e456fe":"def MakeGraph1(new, k):\n    R = range(1,101)\n    F = {}\n    H = {}\n    for i in R:\n        for j in R:\n            F[(i,j)] = 1000000000\n    for i in range(5000):\n        day1 = new[i]\n        n = data['n_people'][i]\n        if n != k:\n            continue\n        else :\n            for day2 in R:\n                C = cost[i,day2]-cost[i,day1]\n                if  C < F[(day1,day2)]:\n                    F[(day1,day2)] = C\n                    H[(day1,day2)] = i\n   \n    V = list(R)\n    E = []\n    for day1 in R:\n        for day2 in R:\n            if day1 == day2:\n                continue\n            else :\n                E.append((day1,day2,F[(day1,day2)]))\n                \n    \n    \n    x = FindLoop(E,V,len(V))\n    if x != []:\n        x = x[0]\n        for i in range(len(x)-1):\n            day1 = x[i]\n            day2 = x[i+1]\n            family = H[(day1,day2)]\n            new[family]= day2\n    \n    return new","faf8955f":"def MakeGraph2(new,parity, m, M):\n    \n    Daily = np.zeros(102)\n    if parity == -1:\n        R = range(1,101)\n    if parity == 0:\n        R = range(2,102,2)\n    if parity == 1:\n        R = range(1,101,2)\n    if parity == 2:\n        R = list(range(1,51,2)) + list(range(52,102,2))\n    if parity == 3:\n        R = list(range(2,50,2)) + list(range(51,101,2))\n    \n    A1 = list(range(1,25,2))\n    A2 = list(range(2,25,2))\n    B1 = list(range(26,50,2))\n    B2 = list(range(27,50,2))\n    C1 = list(range(51,75,2))\n    C2 = list(range(52,75,2))\n    D1 = list(range(76,101,2))\n    D2 = list(range(77,101,2))\n    if parity == 4:\n        R = A1+B2+C1+D2\n    if parity == 5:\n        R = A1+B2+C2+D1\n    if parity == 6:\n        R = A2+B1+C1+D2\n    if parity == 7:\n        R = A2+B1+C2+D1\n  \n    for i in range(5000):\n        a = new[i]\n        b = data['n_people'][i]\n        Daily[a]+=b\n    Daily[101]=Daily[100]\n    \n    \n    F = {}\n    H = {}\n    \n    F = {}\n    for day1 in R:\n        for day2 in R:\n            for s in range(2,9):\n                F[(day1,day2,s)] = 100000000\n                H[(day1,day2,s)] = []\n    for i in range(5000):\n        day1 = new[i]\n        if day1 not in R:\n            continue\n        else: \n            n = data['n_people'][i]\n            for day2 in R:\n                C = cost[i,day2]-cost[i,day1]\n                if  C < F[(day1,day2,n)]:\n                    F[(day1,day2,n)] = C\n                    H[(day1,day2,n)] = [i]\n                    \n    for day1 in R:\n        for day2 in R:\n            x8 = (day1,day2,8)\n            x7 = (day1,day2,7)\n            x6 = (day1,day2,6)\n            x5 = (day1,day2,5)\n            x4 = (day1,day2,4)\n            x3 = (day1,day2,3)\n            x2 = (day1,day2,2)\n            if F[x2]+F[x6] < F[x8]:\n                F[x8] = F[x2]+F[x6]\n                H[x8] = H[x2]+H[x6]\n            if F[x3]+F[x5] < F[x8]:\n                F[x8] = F[x3]+F[x5]\n                H[x8] = H[x3]+H[x5]\n            if F[x2]+F[x5]< F[x7]:\n                F[x7] = F[x2]+F[x5]\n                H[x7] = H[x2]+H[x5]\n            if F[x3]+F[x4] < F[x7]:\n                F[x7] = F[x3]+F[x4]\n                H[x7] = H[x3] +H[x4]\n            if F[x2]+F[x4] < F[x6]:\n                F[x6] = F[x2]+F[x4]\n                H[x6] = H[x2]+H[x4]\n            if F[x2]+F[x3] < F[x5]:\n                F[x5] = F[x2]+F[x3]\n                H[x5] = H[x2]+H[x3]\n                \n                \n            \n            \n    \n    G = {}\n    for day1 in R:\n        for diff in range(-6,7):\n            x = Daily[day1-1]\n            y = Daily[day1]\n            z = Daily[day1+1]\n            \n            G[(day1,diff)] = f(x, y+diff)+f(y+diff,z)- f(x,y)-f(y,z)\n                    \n    V = []  \n    for day in R:\n        for size in range(m,M+1):\n            V.append((day,size))\n    \n   \n    E = []\n    for day1 in R:\n        for day2 in R:\n            if day1 == day2:\n                continue \n            for s1 in range(m,M+1):\n                for s2 in range(m,M+1):\n                    v1 = (day1,s1)\n                    v2 = (day2,s2)\n                    c = F[(day1,day2,s1)] + G[(day2, s1-s2)]\n                    edge = (v1,v2, c)\n                    E.append(edge)\n                \n    \n    \n    X = FindLoop(E,V,len(V))\n    Best_copy = new.copy()\n    Best = cost_function(new)\n    for x in X:\n        new2 = new.copy()\n        for i in range(len(x)-1):\n            day1, s1 = x[i]\n            day2, s2  = x[i+1]\n            Family = H[(day1,day2, s1)]\n            for family in Family:\n                new2[family]= day2 \n        if cost_function(new2) < Best:\n            Best = cost_function(new2)\n            Best_copy = new2\n        \n    \n    return Best_copy","cad6d25b":"def Loop0(new):\n    Daily = np.zeros(102)\n    R = range(1,101)\n  \n    for i in range(5000):\n        a = new[i]\n        b = data['n_people'][i]\n        Daily[a]+=b\n    Daily[101]=Daily[100]\n   \n    F = {}\n    for day1 in R:\n        for day2 in R:\n            for s in range(2,9):\n                F[(day1,day2,s)] = 100000000\n    for i in range(5000):\n        day1 = new[i]\n        if day1 not in R:\n            continue\n        else: \n            n = data['n_people'][i]\n            for day2 in R:\n                F[(day1,day2,n)] = min(F[(day1,day2,n)], cost[i,day2]-cost[i,day1])\n    G = {}\n    for day1 in R:\n        for diff in range(-6,7):\n            x = Daily[day1-1]\n            y = Daily[day1]\n            z = Daily[day1+1]\n            G[(day1,diff)] = f(x, y+diff)+f(y+diff,z)- f(x,y)-f(y,z)\n            \n    Best = 0\n    Solution = (-1,-1, -1,-1)\n    for i in R:\n        for j in R:\n            if  abs(i-j) <= 1 :\n                continue\n           \n            for a in range(2,9):\n                for b in range(2,9):\n                    C = F[(i,j,a)]+ F[(j,i,b)] \n                    if a == b:\n                        P = 0\n                    else :\n                        P = G[(j,a-b)]+G[(i, b-a)]\n                    if P+C < Best:\n                        Best = P+C\n                        Solution = (i,j,a,b)\n    if Best < -0.1:\n        print(Best)\n        a,b,d,e  = Solution\n        p = -1\n        q = -1\n        \n        \n        for i in range(5000):\n            if new[i] == a and data['n_people'][i] == d and cost[i,b]-cost[i,a] == F[(a,b,d)]:\n                p = i\n          \n        for i in range(5000):\n            if new[i] == b and data['n_people'][i] == e and cost[i,a]-cost[i,b] == F[(b,a,e)]:\n                q = i \n    \n           \n       \n                \n        if  p == -1 or q == -1:\n            print('Problem')\n            \n        new[p] = b\n        new[q] = a\n       \n                \n    return new\n   ","5477d77d":"def Exchange(new):\n    IM = 0\n\n   \n        \n        \n    t = 0\n    for k in range(2,9):\n        for i in V[k]:\n            for j in V[k]:\n                t+=1\n                if t%1000000 == 1:\n                    start_score = cost_function(new)\n                    print(t, start_score)\n                    \n                day1 = new[i]\n                day2 = new[j]\n                if cost[i,day1]+cost[j,day2] > cost[i,day2]+cost[j,day1]:\n                    new[i] = day2\n                    new[j] = day1\n                    IM+=1\n                    \n                elif (cost[i,day1]+cost[j,day2] == cost[i,day2]+cost[j,day1]) and np.random.randint(7) in [0,1,2,3]:\n                    new[i] = day2\n                    new[j] = day1\n    print(IM)\n    return new","35f45faa":"def Move(new):\n    IM = 0\n    Daily = np.zeros(102)\n  \n    for i in range(5000):\n        a = new[i]\n        b = data['n_people'][i]\n        Daily[a]+=b\n    Daily[101] = Daily[100]\n        \n    print(Daily)\n \n   \n    \n    \n    t = 0\n    fam = list(range(5000))\n \n    \n    \n    for fam_id in fam:\n        t+=1\n        if t%1000 == 1:\n            start_score = cost_function(new)\n            print(t, start_score)\n  \n        for pick in range(1,101):\n            new_day = pick\n            \n            old_day = new[fam_id]\n            if new_day == old_day:\n                continue\n            a = data['n_people'][fam_id]\n            C1 = cost[fam_id, old_day]\n            C2 = cost[fam_id, new_day]\n            \n            if abs(old_day-new_day) > 1: \n                x1 = Daily[old_day -1]\n                x2 = Daily[old_day]\n                x3 = Daily[old_day+ 1]\n                y1 = Daily[new_day -1]\n                y2 = Daily[new_day]\n                y3 = Daily[new_day+1]\n                P1 = f(x1,x2)+f(x2,x3)+ f(y1,y2)+f(y2,y3)\n                P2 = f(x1,x2-a)+f(x2-a,x3) + f(y1,y2+a)+f(y2+a,y3)\n            \n            elif new_day == old_day+1:\n                x1 = Daily[old_day -1]\n                x2 = Daily[old_day]\n                x3 = Daily[old_day + 1]\n                x4 = Daily[old_day+2]\n                P1 = f(x1,x2)+f(x2,x3)+f(x3,x4)\n                P2 = f(x1,x2-a)+ f(x2-a,x3+a)+f(x3+a,x4)\n            \n            elif new_day == old_day-1:\n                x1 = Daily[old_day -2]\n                x2 = Daily[old_day -1]\n                x3 = Daily[old_day ]\n                x4 = Daily[old_day+1]\n                P1 = f(x1,x2)+f(x2,x3)+f(x3,x4)\n                P2 = f(x1,x2+a)+ f(x2+a,x3-a)+f(x3-a,x4)  \n                \n                \n            if P1+C1 > P2+C2:\n                new[fam_id] = new_day\n          \n                Daily[old_day]-=a\n                Daily[new_day]+=a\n                Daily[101] = Daily[100]\n                IM+=1\n    print(IM)       \n    return new, IM","b0545ab4":"def Loop3(new):\n    Daily = np.zeros(102)\n    R = range(1,101)\n  \n    for i in range(5000):\n        a = new[i]\n        b = data['n_people'][i]\n        Daily[a]+=b\n    Daily[101]=Daily[100]\n  \n    F = {}\n    for day1 in R:\n        for day2 in R:\n            for s in range(2,9):\n                F[(day1,day2,s)] = 100000000\n    for i in range(5000):\n        day1 = new[i]\n        if day1 not in R:\n            continue\n        else: \n            n = data['n_people'][i]\n            for day2 in R:\n                F[(day1,day2,n)] = min(F[(day1,day2,n)], cost[i,day2]-cost[i,day1])\n    G = {}\n    for day1 in R:\n        for diff in range(-6,7):\n            x = Daily[day1-1]\n            y = Daily[day1]\n            z = Daily[day1+1]\n            G[(day1,diff)] = f(x, y+diff)+f(y+diff,z)- f(x,y)-f(y,z)\n            \n    Best = 0\n    Solution = (-1,-1,-1,-1,-1,-1)\n    for i in R:\n        for j in R:\n            if abs(i-j) <=1 :\n                continue\n            if j < i:\n                continue\n            for k in R:\n                if abs(k-i) <=1 or abs(k-j) <=1:\n                    continue\n                if k < i:\n                    continue\n                for a in range(2,9):\n                    for b in range(2,9):\n                        for c in range(2,9):\n                            C = F[(i,j,a)]+ F[(j,k,b)] + F[(k,i,c)]\n                            P = G[(j,a-b)]+G[(k, b-c)]+ G[(i,c-a )]\n                            if P+C < Best:\n                                Best = P+C\n                                Solution = (i,j,k,a,b,c)\n                                \n    if Best < -0.1:\n        print(Best)\n        a,b,c,d,e,f1 = Solution\n        p = -1\n        q = -1\n        r = -1\n        \n        for i in range(5000):\n            if new[i] == a and data['n_people'][i] == d and cost[i,b]-cost[i,a] == F[(a,b,d)]:\n                p = i\n          \n        for i in range(5000):\n            if new[i] == b and data['n_people'][i] == e and cost[i,c]-cost[i,b] == F[(b,c,e)]:\n                q = i \n    \n           \n        for i in range(5000):\n            if new[i] == c and data['n_people'][i] == f1 and cost[i,a]-cost[i,c] == F[(c,a,f1)]:\n                r = i  \n                \n        if r == -1 or p == -1 or q == -1:\n            print('Problem')\n            \n        new[p] = b\n        new[q] = c\n        new[r] = a\n                \n    return new","839b5cc8":"#Local heuristic changes\nfor i in range(20):\n    print('Epoch: '+ str(i) )\n    new = Exchange(new)\n    new = Loop0(new)\n    for p in range(0,8):\n        new = MakeGraph2(new, p, 2, 8)\n        print(cost_function(new))\n  \n    for S in range(2,9):\n            new = MakeGraph1(new, S)\n            print(cost_function(new))\n\n    new, _ = Move(new)\n   ","056ef5ef":"# Additional (and more time consuming) local changes\nfor i in range(8):\n    print('Epoch: '+ str(i) )\n    new = Exchange(new)\n    new = Loop0(new)\n    for p in range(-1,8):\n        new = MakeGraph2(new, p, 2, 8)\n        print(cost_function(new))\n  \n    for S in range(2,9):\n            new = MakeGraph1(new, S)\n            print(cost_function(new))\n    \n    new = Loop3(new)\n    new, _ = Move(new)\n   ","aa96ffdd":"submission['assigned_day'] = new\nscore = cost_function(new)\nsubmission.to_csv(f'submission_{score}.csv')\nprint(f'Score: {score}')","33dc1018":"The goal is this notebook is to provide a few \"do it yourself\" graph theoretic algorithms.\nA, Moving 1 family. \nB, Exchanging several families of the same sizes. \nC, Moving multiple families of different sizes.\nFrom the sample submission it achives less than 73000. \nWith better initialization one can greatly improve (My best score was 69530) ","457b8d8c":"## Read in the family information and sample submission"}}