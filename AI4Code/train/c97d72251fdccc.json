{"cell_type":{"902bc83f":"code","47d86cb4":"code","503fd133":"code","62a4edfc":"code","1b42a014":"code","4e52e5d7":"code","ad0b5cfc":"code","f1882635":"code","e25136c0":"code","6e2371ac":"code","7f65275c":"code","acfca9c2":"code","26645182":"code","eff8c561":"code","db4d204d":"code","071a326d":"code","776cddc3":"code","39f6493a":"code","37e0dca0":"code","f944d411":"code","f62d4616":"code","4304a4ee":"code","90118286":"code","c9234002":"code","f4032816":"code","827c8293":"markdown","cccce304":"markdown","6500377a":"markdown","e56a1d9e":"markdown","60ae05a4":"markdown","3b6ed471":"markdown","47da517f":"markdown","68e67c8a":"markdown","c143e1f7":"markdown","bd29faef":"markdown","51b54d3d":"markdown","697b29fd":"markdown","3292ba75":"markdown","2de6151b":"markdown","79e75df5":"markdown","8af92353":"markdown","b8eb4499":"markdown","78bb9a7d":"markdown","a6c225ec":"markdown","66dedad4":"markdown"},"source":{"902bc83f":"import os\nimport warnings\n\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\nfrom tensorflow.keras.layers import Dense, Input\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.callbacks import ModelCheckpoint\nfrom kaggle_datasets import KaggleDatasets\nimport transformers\nimport traitlets\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom tqdm.notebook import tqdm\nfrom tokenizers import BertWordPieceTokenizer\nfrom sklearn.metrics import roc_auc_score\n\nwarnings.simplefilter(\"ignore\")","47d86cb4":"class TextTransformation:\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        raise NotImplementedError('Abstarct')   \n        \nclass LowerCaseTransformation(TextTransformation):\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        return text.lower(), lang\n    \n    \nclass URLTransformation(TextTransformation):\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        for url in self.find_urls(text):\n            if url in text:\n                text.replace(url, ' external link ')\n        return text.lower(), lang\n    \n    @staticmethod\n    def find_urls(string): \n        # https:\/\/www.geeksforgeeks.org\/python-check-url-string\/\n        urls = re.findall('http[s]?:\/\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\), ]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', string) \n        return urls \n    \nclass PunctuationTransformation(TextTransformation):\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        for p in '?!.,\"#$%\\'()*+-\/:;<=>@[\\\\]^_`{|}~' + '\u201c\u201d\u2019' +\"\/-'\" + \"&\" + \"\u00a1\u00bf\":\n            if '\u2019' in text:\n                text = text.replace('\u2019', f' \\' ')\n                \n            if '\u2019' in text:\n                text = text.replace('\u2019', f' \\' ')\n              \n            if '\u2014' in text:\n                text = text.replace('\u2014', f' - ')\n                \n            if '\u2212' in text:\n                text = text.replace('\u2212', f' - ')   \n                \n            if '\u2013' in text:\n                text = text.replace('\u2013', f' - ')   \n              \n            if '\u201c' in text:\n                text = text.replace('\u201c', f' \" ')   \n                \n            if '\u00ab' in text:\n                text = text.replace('\u00ab', f' \" ')   \n                \n            if '\u00bb' in text:\n                text = text.replace('\u00bb', f' \" ')   \n            \n            if '\u201d' in text:\n                text = text.replace('\u201d', f' \" ') \n                \n            if '`' in text:\n                text = text.replace('`', f' \\' ')              \n\n            text = text.replace(p, f' {p} ')\n                \n        return text.strip(), lang\n    \n    \nclass NumericTransformation(TextTransformation):\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        for i in range(10):\n            text = text.replace(str(i), f' {str(i)} ')\n        return text, lang\n    \nclass WikiTransformation(TextTransformation):\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        text = text.replace('wikiproject', ' wiki project ')\n        for i in [' vikipedi ', ' wiki ', ' \u0432\u0438\u043a\u0438\u043f\u0435\u0434\u0438\u0438 ', \" \u0432\u0438\u043a\u0438 \", ' \u0432\u0438\u043a\u0438\u043f\u0435\u0434\u0438\u044f ', ' viki ', ' wikipedien ', ' \u0432\u0438\u043a\u0438\u043f\u0435\u0434\u0438\u044e ']:\n            text = text.replace(i, ' wikipedia ')\n        return text, lang\n    \n    \nclass MessageTransformation(TextTransformation):\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        text = text.replace('wikiproject', ' wiki project ')\n        for i in [' msg ', ' msj ', ' mesaj ']:\n            text = text.replace(i, ' message ')\n        return text, lang\n    \n    \nclass PixelTransformation(TextTransformation):\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        for i in [' px ']:\n            text = text.replace(i, ' pixel ')\n        return text, lang\n    \n    \nclass SaleBotTransformation(TextTransformation):\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        text = text.replace('salebot', ' sale bot ')\n        return text, lang\n    \n    \nclass RuTransformation(TextTransformation):\n    def __call__(self, text: str, lang: str = None) -> tuple:\n        if lang is not None and lang == 'ru' and 'http' not in text and 'jpg' not in text and 'wikipedia' not in text:\n            text = text.replace('t', '\u0442')\n            text = text.replace('h', '\u043d')\n            text = text.replace('b', '\u0432')\n            text = text.replace('c', 'c')\n            text = text.replace('k', '\u043a')\n            text = text.replace('e', '\u0435')\n            text = text.replace('a', '\u0430')\n        return text, lang\n    \nclass CombineTransformation(TextTransformation):\n    def __init__(self, transformations: list, return_lang: bool = False):\n        self._transformations = transformations\n        self._return_lang = return_lang\n        \n    def __call__(self, text: str, lang: str = None) -> tuple:\n        for transformation in self._transformations:\n            text, lang = transformation(text, lang)\n        if self._return_lang:\n            return text, lang\n        return text\n    \n    def append(self, transformation: TextTransformation):\n        self._transformations.append(transformation)","503fd133":"def fast_encode(texts, tokenizer, chunk_size=256, maxlen=512):\n    tokenizer.enable_truncation(max_length=maxlen)\n    tokenizer.enable_padding(max_length=maxlen)\n    all_ids = []\n    \n    for i in tqdm(range(0, len(texts), chunk_size)):\n        text_chunk = texts[i:i+chunk_size].tolist()\n        encs = tokenizer.encode_batch(text_chunk)\n        all_ids.extend([enc.ids for enc in encs])\n    \n    return np.array(all_ids)","62a4edfc":"def build_model(transformer, loss='binary_crossentropy', max_len=512):\n    input_word_ids = Input(shape=(max_len,), dtype=tf.int32, name=\"input_word_ids\")\n    sequence_output = transformer(input_word_ids)[0]\n    cls_token = sequence_output[:, 0, :]\n    x = tf.keras.layers.Dropout(0.35)(cls_token)\n    out = Dense(1, activation='sigmoid')(x)\n    \n    model = Model(inputs=input_word_ids, outputs=out)\n    model.compile(Adam(lr=3e-5), loss=loss, metrics=[tf.keras.metrics.AUC()])\n    \n    return model","1b42a014":"# https:\/\/stackoverflow.com\/questions\/8897593\/how-to-compute-the-similarity-between-two-text-documents\nimport nltk, string\nfrom sklearn.feature_extraction.text import TfidfVectorizer\n\nnltk.download('punkt') # if necessary...\n\n\nstemmer = nltk.stem.porter.PorterStemmer()\nremove_punctuation_map = dict((ord(char), None) for char in string.punctuation)\n\ndef stem_tokens(tokens):\n    return [stemmer.stem(item) for item in tokens]\n\n'''remove punctuation, lowercase, stem'''\ndef normalize(text):\n    return stem_tokens(nltk.word_tokenize(text.lower().translate(remove_punctuation_map)))\n\nvectorizer = TfidfVectorizer(tokenizer=normalize, stop_words='english')\n\ndef cosine_sim(text1, text2):\n    tfidf = vectorizer.fit_transform([text1, text2])\n    return ((tfidf * tfidf.T).A)[0,1]","4e52e5d7":"AUTO = tf.data.experimental.AUTOTUNE\n\n# Create strategy from tpu\ntpu = tf.distribute.cluster_resolver.TPUClusterResolver()\ntf.config.experimental_connect_to_cluster(tpu)\ntf.tpu.experimental.initialize_tpu_system(tpu)\nstrategy = tf.distribute.experimental.TPUStrategy(tpu)\n\n# Data access\n#GCS_DS_PATH = KaggleDatasets().get_gcs_path('kaggle\/input\/') ","ad0b5cfc":"# First load the real tokenizer\ntokenizer = transformers.BertTokenizer.from_pretrained('bert-base-cased')\n\n# Save the loaded tokenizer locally\nsave_path = '\/kaggle\/working\/distilbert_base_uncased\/'\nif not os.path.exists(save_path):\n    os.makedirs(save_path)\ntokenizer.save_pretrained(save_path)\n\n# Reload it with the huggingface tokenizers library\nfast_tokenizer = BertWordPieceTokenizer('distilbert_base_uncased\/vocab.txt', lowercase=False)\nfast_tokenizer","f1882635":"transformer = CombineTransformation(\n    [\n        LowerCaseTransformation(),\n        PunctuationTransformation(),\n        NumericTransformation(),\n        PixelTransformation(),\n        MessageTransformation(),\n        WikiTransformation(),\n        SaleBotTransformation()\n    ]\n)","e25136c0":"train1 = pd.read_csv(\"\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/jigsaw-toxic-comment-train.csv\")\ntrain1['comment_text'] = train1.apply(lambda x: transformer(x.comment_text), axis=1)\n#train2 = pd.read_csv(\"\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/jigsaw-unintended-bias-train.csv\")\n\nvalid1 = pd.read_csv('\/kaggle\/input\/val-en-df\/validation_en.csv')\nvalid1['comment_text'] = valid1.apply(lambda x: transformer(x.comment_text_en), axis=1)\nvalid2 = pd.read_csv('\/kaggle\/input\/jigsaw-multilingual-toxic-test-translated\/jigsaw_miltilingual_valid_translated.csv')\nvalid2['comment_text'] = valid2.apply(lambda x: transformer(x.translated), axis=1)\ntest1 = pd.read_csv('\/kaggle\/input\/test-en-df\/test_en.csv')\ntest1['comment_text'] = test1.apply(lambda x: transformer(x.content_en), axis=1)\ntest2 = pd.read_csv('\/kaggle\/input\/jigsaw-multilingual-toxic-test-translated\/jigsaw_miltilingual_test_translated.csv')\ntest2['comment_text'] = test2.apply(lambda x: transformer(x.translated), axis=1)\nsub = pd.read_csv('\/kaggle\/input\/jigsaw-multilingual-toxic-comment-classification\/sample_submission.csv')","6e2371ac":"test1.tail(15)","7f65275c":"plt.figure(figsize=(12, 8))\n\nsns.distplot(train1.comment_text.str.len(), label='train')\nsns.distplot(test1.content_en.str.len(), label='test1')\nsns.distplot(test2.translated.str.len(), label='test2')\nplt.legend();","acfca9c2":"plt.figure(figsize=(12, 8))\n\nsns.distplot(train1.comment_text.str.len(), label='train')\nsns.distplot(test1.content_en.str.len(), label='test1')\nsns.distplot(test2.translated.str.len(), label='test2')\nplt.xlim([0, 512])\nplt.legend();","26645182":"x_train = fast_encode(train1.comment_text.astype(str), fast_tokenizer, maxlen=512)\nx_valid1 = fast_encode(valid1.comment_text_en.astype(str), fast_tokenizer, maxlen=512)\nx_valid2 = fast_encode(valid2.translated.astype(str), fast_tokenizer, maxlen=512)\nx_valid = np.concatenate([x_valid1, x_valid2], axis=0)\nx_test1 = fast_encode(test1.content_en.astype(str), fast_tokenizer, maxlen=512)\nx_test2 = fast_encode(test2.translated.astype(str), fast_tokenizer, maxlen=512)\n\ny_train = train1.toxic.values\ny_valid1 = valid1.toxic.values\ny_valid2 = valid2.toxic.values\ny_valid = np.concatenate([y_valid1, y_valid2], axis=0)","eff8c561":"train_dataset = (\n    tf.data.Dataset\n    .from_tensor_slices((x_train, y_train))\n    .repeat()\n    .shuffle(2048)\n    .batch(64)\n    .prefetch(AUTO)\n)\n\nvalid_dataset = (\n    tf.data.Dataset\n    .from_tensor_slices((x_valid, y_valid))\n    .batch(64)\n    .cache()\n    .prefetch(AUTO)\n)\n\ntest_dataset = [(\n    tf.data.Dataset\n    .from_tensor_slices(x_test1)\n    .batch(64)\n),\n    (\n    tf.data.Dataset\n    .from_tensor_slices(x_test2)\n    .batch(64)\n)]","db4d204d":"from tensorflow.keras import backend as K\n\ndef focal_loss(gamma=2., alpha=.2):\n    def focal_loss_fixed(y_true, y_pred):\n        pt_1 = tf.where(tf.equal(y_true, 1), y_pred, tf.ones_like(y_pred))\n        pt_0 = tf.where(tf.equal(y_true, 0), y_pred, tf.zeros_like(y_pred))\n        return -K.mean(alpha * K.pow(1. - pt_1, gamma) * K.log(pt_1)) - K.mean((1 - alpha) * K.pow(pt_0, gamma) * K.log(1. - pt_0))\n    return focal_loss_fixed","071a326d":"%%time\nwith strategy.scope():\n    transformer_layer = transformers.TFBertModel.from_pretrained('bert-base-cased')\n    model = build_model(transformer_layer, loss=focal_loss(gamma=1.5), max_len=512)\nmodel.summary()","776cddc3":"from tensorflow.keras.callbacks import Callback \n\nclass RocAucCallback(Callback):\n    def __init__(self, test_data, score_thr):\n        self.test_data = test_data\n        self.score_thr = score_thr\n        self.test_pred = []\n        \n    def on_epoch_end(self, epoch, logs=None):\n        if logs['val_auc'] > self.score_thr:\n            print('\\nRun TTA...')\n            for td in self.test_data:\n                self.test_pred.append(self.model.predict(td))","39f6493a":"def build_lrfn(lr_start=0.000001, lr_max=0.000004, \n               lr_min=0.0000001, lr_rampup_epochs=7, \n               lr_sustain_epochs=0, lr_exp_decay=.87):\n    lr_max = lr_max * strategy.num_replicas_in_sync\n\n    def lrfn(epoch):\n        if epoch < lr_rampup_epochs:\n            lr = (lr_max - lr_start) \/ lr_rampup_epochs * epoch + lr_start\n        elif epoch < lr_rampup_epochs + lr_sustain_epochs:\n            lr = lr_max\n        else:\n            lr = (lr_max - lr_min) * lr_exp_decay**(epoch - lr_rampup_epochs - lr_sustain_epochs) + lr_min\n        return lr\n    \n    return lrfn","37e0dca0":"import matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 7))\n\n_lrfn = build_lrfn()\nplt.plot([i for i in range(35)], [_lrfn(i) for i in range(35)]);","f944d411":"roc_auc = RocAucCallback(test_dataset, 0.935)\nlrfn = build_lrfn()\nlr_schedule = tf.keras.callbacks.LearningRateScheduler(lrfn, verbose=1)\n\ntrain_history = model.fit(\n    train_dataset,\n    steps_per_epoch=150,\n    validation_data=valid_dataset,\n    callbacks=[lr_schedule, roc_auc],\n    epochs=35\n)","f62d4616":"import matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 7))\n\nlrfn = build_lrfn(lr_start=0.000001, lr_max=0.0000005, \n               lr_min=0.0000001, lr_rampup_epochs=5, \n               lr_sustain_epochs=0, lr_exp_decay=.87)\nplt.plot([i for i in range(25)], [lrfn(i) for i in range(25)]);","4304a4ee":"from sklearn.model_selection import train_test_split","90118286":"from sklearn.model_selection import train_test_split\n\nx_valid_train1, x_valid_valid1, y_valid_train1, y_valid_valid1 = train_test_split(x_valid1, y_valid1, test_size=0.15, shuffle=True, random_state=123, stratify=y_valid1)\n\nx_valid_train2, x_valid_valid2, y_valid_train2, y_valid_valid2 = train_test_split(x_valid2, y_valid2, test_size=0.15, shuffle=True, random_state=123, stratify=y_valid2)\n\nx_valid_train = np.concatenate([x_valid_train1, x_valid_train2], axis=0)\ny_valid_train = np.concatenate([y_valid_train1, y_valid_train2], axis=0)\n\nx_valid_valid = np.concatenate([x_valid_valid1, x_valid_valid2], axis=0)\ny_valid_valid = np.concatenate([y_valid_valid1, y_valid_valid2], axis=0)\n\nvalid_train_dataset = (\ntf.data.Dataset\n.from_tensor_slices((x_valid_train, y_valid_train))\n.shuffle(2048)\n.batch(64)\n.cache()\n.prefetch(AUTO)\n)\n\nvalid_valid_dataset = (\ntf.data.Dataset\n.from_tensor_slices((x_valid_valid, y_valid_valid))\n.batch(64)\n.cache()\n.prefetch(AUTO)\n)","c9234002":"lr_schedule = tf.keras.callbacks.LearningRateScheduler(lrfn, verbose=1)\n\ntrain_history = model.fit(\nvalid_train_dataset,\nsteps_per_epoch=75,\nvalidation_data=valid_valid_dataset,\ncallbacks=[lr_schedule, roc_auc],\nepochs=25\n)","f4032816":"sub['toxic'] = np.mean(roc_auc.test_pred, axis=0)\nsub.to_csv('submission.csv', index=False)","827c8293":"## About this notebook\n\n*[Jigsaw Multilingual Toxic Comment Classification](https:\/\/www.kaggle.com\/c\/jigsaw-multilingual-toxic-comment-classification)* is the 3rd annual competition organized by the Jigsaw team. It follows *[Toxic Comment Classification Challenge](https:\/\/www.kaggle.com\/c\/jigsaw-toxic-comment-classification-challenge)*, the original 2018 competition, and *[Jigsaw Unintended Bias in Toxicity Classification](https:\/\/www.kaggle.com\/c\/jigsaw-unintended-bias-in-toxicity-classification)*, which required the competitors to consider biased ML predictions in their new models. This year, the goal is to use english only training data to run toxicity predictions on many different languages, which can be done using multilingual models, and speed up using TPUs.\n\nMany awesome notebooks has already been made so far. Many of them used really cool technologies like [Pytorch XLA](https:\/\/www.kaggle.com\/theoviel\/bert-pytorch-huggingface-starter). This notebook instead aims at constructing a **fast, concise, reusable, and beginner-friendly model scaffold**. It will focus on the following points:\n* **Using Tensorflow and Keras**: Tensorflow is a powerful framework, and Keras makes the training process extremely easy to understand. This is especially good for beginners to learn how to use TPUs, and for experts to focus on the modelling aspect.\n* **Using Huggingface's `transformers` library**: [This library](https:\/\/huggingface.co\/transformers\/) is extremely popular, so using this let you easily integrate the end result into your ML pipelines, and can be easily reused for your other projects.\n* **Native TPU usage**: The TPU usage is abstracted using the native `strategy` that was created using Tensorflow's `tf.distribute.experimental.TPUStrategy`. This avoids getting too much into the lower-level aspect of TPU management.\n* **Use a subset of the data**: Instead of using the entire dataset, we will only use the 2018 subset of the data available, which makes this much faster, all while achieving a respectable accuracy.","cccce304":"# Reference\n* [Jigsaw TPU: DistilBERT with Huggingface and Keras](https:\/\/www.kaggle.com\/xhlulu\/jigsaw-tpu-distilbert-with-huggingface-and-keras)\n* [inference of bert tpu model ml w\/ validation](https:\/\/www.kaggle.com\/abhishek\/inference-of-bert-tpu-model-ml-w-validation)\n* [Overview of Text Similarity Metrics in Python](https:\/\/towardsdatascience.com\/overview-of-text-similarity-metrics-3397c4601f50)\n* [test-en-df](https:\/\/www.kaggle.com\/bamps53\/test-en-df)\n* [val_en_df](https:\/\/www.kaggle.com\/bamps53\/val-en-df)\n* [Jigsaw multilingual toxic - test translated](https:\/\/www.kaggle.com\/kashnitsky\/jigsaw-multilingual-toxic-test-translated)","6500377a":"# LrScheduler","e56a1d9e":"## Build datasets objects","60ae05a4":"### First Stage","3b6ed471":"## Helper Functions","47da517f":"## Submission","68e67c8a":"## Create fast tokenizer","c143e1f7":"## Load text data into memory","bd29faef":"## Test dataset comparision","51b54d3d":"### Second Stage","697b29fd":"# Focal Loss","3292ba75":"## TPU Configs","2de6151b":"## Train Model","79e75df5":"test_set_similarity = [cosine_sim(t1, t2) for t1, t2 in tqdm(zip(test1.content_en, test2.translated))]\n\nplt.figure(figsize=(12, 8))\n\nsns.distplot(test_set_similarity);","8af92353":"## Fast encode","b8eb4499":"## RocAuc Callback","78bb9a7d":"Lets calculate cosine similarity two translated test datasets.","a6c225ec":"## Load model into the TPU","66dedad4":"Cosine similarity calculates similarity by measuring the cosine of angle between two vectors. This is calculated as:\n![](https:\/\/miro.medium.com\/max\/426\/1*hub04IikybZIBkSEcEOtGA.png)\n\nCosine Similarity calculation for two vectors A and B [source]\nWith cosine similarity, we need to convert sentences into vectors. One way to do that is to use bag of words with either TF (term frequency) or TF-IDF (term frequency- inverse document frequency). The choice of TF or TF-IDF depends on application and is immaterial to how cosine similarity is actually performed \u2014 which just needs vectors. TF is good for text similarity in general, but TF-IDF is good for search query relevance."}}