{"cell_type":{"f1649117":"code","995056e5":"code","015f81a6":"code","52aabb4d":"code","068dba1e":"code","2f914e74":"code","1cd86b78":"code","2ef93ebb":"code","a05a51c1":"code","c59e66ad":"code","960e95e1":"code","767de14b":"code","85cc66b8":"code","357c32be":"code","25d5c75b":"code","49477c8f":"code","9634041b":"code","8cb48aaf":"code","4e46626d":"code","7b6bfe8b":"code","04f59f99":"code","26092a34":"code","f1b803f0":"code","2310368d":"code","5e73c0b5":"code","3bd4cc36":"code","a1faee80":"code","72a63942":"code","e1e92d5f":"code","67eef107":"code","19bf844b":"code","4047542c":"markdown","5f19c567":"markdown","64f79d6c":"markdown","bd20f6a1":"markdown","d5cbfdc0":"markdown","4315fdb2":"markdown","e9e581f0":"markdown","8b7081a9":"markdown","f0e760b4":"markdown","604d1582":"markdown","b97d4867":"markdown","83a1145b":"markdown","52ecc3e5":"markdown","1b97c90a":"markdown","25c5ddf7":"markdown","9e1a0d3d":"markdown","72baa4b9":"markdown","ce297673":"markdown"},"source":{"f1649117":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# K-Means to cluster the users\nfrom sklearn.cluster import KMeans\n\n# Yellowbrick for Model visualization\nfrom yellowbrick.cluster import KElbowVisualizer","995056e5":"# Define the functions\ndef order_clusters(cluster, target, df, ascending):\n    new_cluster = 'new' + cluster\n    \n    temp = df.groupby(cluster)[target].mean().reset_index()\n    temp = temp.sort_values(by=target, ascending=ascending).reset_index(drop=True)\n    temp['index'] = temp.index\n    \n    cluster_df = pd.merge(df, temp[[cluster, 'index']], on=cluster)\n    cluster_df = cluster_df.drop([cluster], axis=1)\n    cluster_df = cluster_df.rename(columns={'index':cluster})\n    \n    return cluster_df\n\ndef rfm_cluster(df, cluster_variable, n_clusters, ascending):\n    \n    # Create and fit the k-means \n    model = KMeans(n_clusters=n_clusters)\n    model.fit(df[[cluster_variable]])\n    \n    # predict the cluster and pass it to the dataframe\n    df[cluster_variable + 'Cluster'] = model.predict(df[[cluster_variable]])\n    \n    # order the cluster numbers\n    df = order_clusters(cluster_variable + 'Cluster', cluster_variable, df, ascending)\n    \n    return df","015f81a6":"# Import the data\ndf = pd.read_csv(r\"..\/input\/onlineretail\/OnlineRetail.csv\", encoding='cp1252', parse_dates=['InvoiceDate'])\n\n# I'll only keep UK sales\ndf = df[df.Country == 'United Kingdom']","52aabb4d":"df.head()","068dba1e":"df.info()","2f914e74":"maxdate = df['InvoiceDate'].dt.date.max()\nmindate = df['InvoiceDate'].dt.date.min()\ncustomers = df['CustomerID'].nunique()\nstock = df['StockCode'].nunique()\nquantity = df['Quantity'].sum()\n\nprint(f'Transactions timeframe: {mindate} to {maxdate}.')\nprint(f'Unique customers: {customers}.')\nprint(f'Unique items sold: {stock}.')\nprint(f'Quantity sold in period {quantity}')","1cd86b78":"# Create a users dataframe to segment\nusers = pd.DataFrame(df['CustomerID'].unique())\nusers.columns = ['CustomerID']","2ef93ebb":"# Get the latest purchase date for each customer and pass it to a df\nmax_purchase = df.groupby('CustomerID').InvoiceDate.max().reset_index()\nmax_purchase.columns = ['CustomerID', 'MaxPurchaseDate']\nmax_purchase['MaxPurchaseDate'] = max_purchase['MaxPurchaseDate'].dt.date\n\n# Calculate Recency\nmax_purchase['Recency'] = (\n    max_purchase['MaxPurchaseDate'].max() - max_purchase['MaxPurchaseDate']).dt.days \n\n# Merge the dataframe with the users to get the Recency value for each customer\nusers = pd.merge(users, max_purchase[['CustomerID', 'Recency']], on='CustomerID')\nusers.head()","a05a51c1":"# plot a histogram of Recency\nfig = plt.figure(figsize=(10, 6))\nplt.hist(users['Recency']);","c59e66ad":"# Describe Recency\nusers['Recency'].describe()","960e95e1":"# calculate the frequency score, that is how \n# frequently the customer buy from the store\nfrequency_score = df.groupby('CustomerID')['InvoiceDate'].count().reset_index()\nfrequency_score.columns = ['CustomerID', 'Frequency']","767de14b":"users = pd.merge(users, frequency_score, on='CustomerID')\nusers.head()","85cc66b8":"# Plot the distribution \nplt.hist(users['Frequency']);","357c32be":"plt.hist(df['Quantity']);","25d5c75b":"df.drop(df[df['Quantity']<0].index, axis=0, inplace=True)","49477c8f":"# Calculate revenue for each individual customer\ndf['Revenue'] = df['UnitPrice']*df['Quantity']","9634041b":"# Calculate revenue for each individual customer\ndf['Revenue'] = df['UnitPrice']*df['Quantity']\nrevenue = df.groupby('CustomerID')['Revenue'].mean().reset_index()\n\n# Merge the revenue with users dataframe\nusers = pd.merge(users, revenue, on='CustomerID')","8cb48aaf":"# Plot the data\nplt.hist(users['Revenue']);","4e46626d":"model = KMeans()\n\nrecency_score = users[['Recency']]\n\nvisualizer = KElbowVisualizer(model, k=(1, 11))\n\nvisualizer.fit(recency_score)\nvisualizer.show();","7b6bfe8b":"# Create the Recency cluster, smaller recency is \n# better, so we set ascending to False\nusers = rfm_cluster(users, 'Recency', 3, False)\n\n# Check the df with the clusters\nusers.head()","04f59f99":"# Now every customer has been assigned to a cluster based on their Recency\n# and the clusters are ordered from lowest to highest\nusers.groupby('RecencyCluster')['Recency'].describe()","26092a34":"rfm_cluster(users, 'Revenue', 4, True)","f1b803f0":"users.groupby('RevenueCluster')['Revenue'].describe()","2310368d":"# Create the Frequency Clusters\nusers = rfm_cluster(users,'Frequency', 3, True)\n\n# describe the clusters\nusers.groupby('FrequencyCluster')['Frequency'].describe()","5e73c0b5":"# Calculate OverallScore\nusers['OverallScore'] = users['FrequencyCluster'] + users['RevenueCluster'] - users['RecencyCluster'] \n\n# Show the mean of the features for each OverallScore value\nusers.groupby('OverallScore')[['Recency', 'Frequency', 'Revenue']].mean()","3bd4cc36":"# Create the Segment variable based on the OverallScore\nx = users['OverallScore']\nconditions = [x<0, x<2]\nchoices = ['Low', 'Medium']\n\nusers['Segment'] = np.select(conditions, choices, default='High')","a1faee80":"fig = plt.figure(figsize=(10, 6))\nplt.title('Segments')\nplt.xlabel('Revenue')\nplt.ylabel('Frequency')\n    \nplt.scatter(x=users.query(\"Segment == 'Low'\")['Revenue'],\n            y= users.query(\"Segment == 'Low'\")['Frequency'],\n            c='green', alpha=0.7, label='Low')\n\nplt.scatter(x=users.query(\"Segment == 'Medium'\")['Revenue'],\n            y=users.query(\"Segment == 'Medium'\")['Frequency'],\n            c='red', alpha=0.6, label='Medium')\n\nplt.scatter(x=users.query(\"Segment == 'High'\")['Revenue'],\n            y=users.query(\"Segment == 'High'\")['Frequency'],\n            c='blue', alpha=0.5, label='High')\n\nplt.legend();","72a63942":"fig = plt.figure(figsize=(10, 6))\nplt.title('Segments')\nplt.xlabel('Frequency')\nplt.ylabel('Revenue')\n    \nplt.scatter(x=users.query(\"Segment == 'Low'\")['Frequency'],\n            y= users.query(\"Segment == 'Low'\")['Revenue'],\n            c='green', alpha=0.7, label='Low')\n\nplt.scatter(x=users.query(\"Segment == 'Medium'\")['Frequency'],\n            y=users.query(\"Segment == 'Medium'\")['Revenue'],\n            c='red', alpha=0.6, label='Medium')\n\nplt.scatter(x=users.query(\"Segment == 'High'\")['Frequency'],\n            y=users.query(\"Segment == 'High'\")['Revenue'],\n            c='blue', alpha=0.5, label='High')\n\nplt.legend();","e1e92d5f":"fig = plt.figure(figsize=(10, 6))\nplt.title('Segments')\nplt.xlabel('Recency')\nplt.ylabel('Revenue')\n\nplt.scatter(x=users.query(\"Segment == 'Low'\")['Recency'],\n            y= users.query(\"Segment == 'Low'\")['Revenue'],\n            c='green', alpha=0.7, label='Low')\n\nplt.scatter(x=users.query(\"Segment == 'Medium'\")['Recency'],\n            y=users.query(\"Segment == 'Medium'\")['Revenue'],\n            c='red', alpha=0.6, label='Medium')\n\nplt.scatter(x=users.query(\"Segment == 'High'\")['Recency'],\n            y=users.query(\"Segment == 'High'\")['Revenue'],\n            c='blue', alpha=0.5, label='High')\n\nplt.legend();\n","67eef107":"fig = plt.figure(figsize=(10, 6))\nplt.title('Segments')\nplt.xlabel('Recency')\nplt.ylabel('Frequency')\n    \nplt.scatter(x=users.query(\"Segment == 'Low'\")['Recency'],\n            y= users.query(\"Segment == 'Low'\")['Frequency'],\n            c='green', alpha=0.7, label='Low')\n\nplt.scatter(x=users.query(\"Segment == 'Medium'\")['Recency'],\n            y=users.query(\"Segment == 'Medium'\")['Frequency'],\n            c='red', alpha=0.6, label='Medium')\n\nplt.scatter(x=users.query(\"Segment == 'High'\")['Recency'],\n            y=users.query(\"Segment == 'High'\")['Frequency'],\n            c='blue', alpha=0.5, label='High')\n\nplt.legend();","19bf844b":"users.head()","4047542c":"# Segmenting customers by RFM Score\n\nThe purpose of this notebook is to use K-Means Clustering to segment a customer base in 3 groups based on their RFM Score.\n\n\n## RFM\n\nThe RFM Score (Recency, Frequency, Monetary Value) is a metric that analyzes the customer based on three data points:\n\n- **Recency**: How recently the customer made a purchase\n- **Frequency**: How often do they purchase\n- **Monetary Value**: How much they spent\n\nRFM analysis classifies customers with a numerical ranking of the three categories, with the ideal customer earning the highest on each category.\n\n\n## The Data\n\nThe dataset contains about a year worth of transactions (dec-2010 to dec-2011) from an **online retail company** based on in the UK. More information can be found on [Kaggle](https:\/\/www.kaggle.com\/vijayuv\/onlineretail). \n\n\n","5f19c567":"There are negative values for `Quantity` these could be returned goods, but the Kaggle page doesn't say anything about it, so I'll exclude those from the analysis just for demonstration.","64f79d6c":"Now, we'll apply K-means clustering to assign the scores. \n\nTo find out how many clusters we need, we'll apply the Elbow Method on 'Recency' to work as a standard for the entire RFM analysis","bd20f6a1":"### Frequency","d5cbfdc0":"### Monetary Value (Revenue) Cluster","4315fdb2":"### Recency Cluster","e9e581f0":"## Overall RFM Score","8b7081a9":"We can arbitrarily assign labels for the different Overall Score clusters for the sake of simplicity\n\n| Value   | Label  |\n|---------|--------|\n| (-2,-1) | Low    |\n| (0,1)   | Medium |\n| (2,4)   | High   |","f0e760b4":"The optimum amount of clusters is 2, but I'll use 3 for this project","604d1582":"The distribution of Recency is very skewed which, in this case, is actually good. We see that the majority of clients have bought something between 0 and 50 days ago.","b97d4867":"### Frequency cluster","83a1145b":"### Monetary Value (Revenue)","52ecc3e5":"### Recency\nFor the purpose of this project, I'll consider the last day in the dataset as if it were the present day to calculate Recency","1b97c90a":"## Creating the clusters","25c5ddf7":"We can see the segments behave differently so we can apply adequate strategies to the each group.","9e1a0d3d":"For this RFM model, all the features will have the same weight, but this can easily be adjusted in the formula below:","72baa4b9":"The number of optimal clusters seems to be 2, but I'll use 3 just for the sake of demonstration","ce297673":"Unlike the recency cluster, a higher median (50%) frequency indicates a better customer."}}