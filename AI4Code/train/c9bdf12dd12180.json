{"cell_type":{"68e91c19":"code","52d867c1":"code","1469ca8b":"code","b0e94826":"code","406004af":"code","d681c510":"code","b123e0f6":"code","3e5d4263":"code","f293ae64":"code","4b029ca5":"code","7ad3ef23":"code","282a3404":"code","70d32ea6":"code","35074b28":"code","a284eddb":"code","19e1cad0":"code","2651250b":"markdown","e639bd01":"markdown","7d615955":"markdown","eac9218f":"markdown","8545ef29":"markdown","56eb0f13":"markdown","5361d098":"markdown","961da1d0":"markdown","1ed1b63a":"markdown","9356141d":"markdown","488d4767":"markdown"},"source":{"68e91c19":"import numpy as np\nimport pandas as pd\nimport seaborn as sns","52d867c1":"df = pd.read_csv('..\/input\/Iris.csv', index_col='Id')\ndf.info(memory_usage=True)","1469ca8b":"df.describe(include='all')","b0e94826":"types = {'SepalLengthCm': 'float16',\n         'SepalWidthCm': 'float16',\n         'PetalLengthCm': 'float16',\n         'PetalWidthCm': 'float16',\n         'Species': 'category'\n        }\ndf = df.astype(types)\ndf.info()","406004af":"sns.heatmap(df.corr(),cmap='coolwarm', annot=True, vmin=-1, vmax=1, linewidths=.5)","d681c510":"df['SepalArea'] = df.SepalLengthCm * df.SepalWidthCm\ndf['PetalArea'] = df.PetalLengthCm * df.PetalWidthCm\ndf['SepalRatio'] = df.SepalLengthCm \/ df.SepalWidthCm\ndf['PetalRatio'] = df.PetalLengthCm \/ df.PetalWidthCm\ndf['RatioArea'] = df.SepalArea \/ df.PetalArea\ndf.info()","b123e0f6":"label = 'Species'\ndf.describe(include='all')","3e5d4263":"sns.pairplot(df, hue=label, diag_kind='hist')","f293ae64":"from sklearn.preprocessing import LabelBinarizer, StandardScaler\nfrom sklearn.model_selection import train_test_split","4b029ca5":"x = df.drop(label, axis=1)\ny = df[label]","7ad3ef23":"def DataEncoder(df):\n    df['SepalRatio'] = df.SepalLengthCm \/ df.SepalWidthCm\n    df['PetalRatio'] = df.PetalLengthCm \/ df.PetalWidthCm\n    df['SepalArea'] = df.SepalLengthCm * df.SepalWidthCm\n    df['PetalArea'] = df.PetalLengthCm * df.PetalWidthCm\n    df['RatioArea'] = df.SepalArea \/ df.PetalArea\n    return df\n\nle = LabelBinarizer()\nscaler = StandardScaler()\n\nx = scaler.fit_transform(DataEncoder(x))\ny = le.fit_transform(y)\nx.shape, y.shape","282a3404":"x[:5], y[:5]","70d32ea6":"x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state=0)","35074b28":"from keras import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import SGD\nfrom matplotlib.pyplot import *","a284eddb":"model = Sequential()\nmodel.add(Dense(18, activation='tanh', input_dim=9))\nmodel.add(Dense(3, activation='softmax'))\nsgd = SGD(lr=0.1)\nmodel.compile(optimizer=sgd,\n              loss='categorical_crossentropy',\n              metrics=['accuracy'])\nhistory = model.fit(x_train, y_train, epochs = 300)\nfig, ax = subplots()\ndf_resultados = pd.DataFrame.from_dict(history.history)\ndf_resultados['acc'].plot()\ndf_resultados['loss'].plot()\nax.legend()","19e1cad0":"from sklearn.metrics import classification_report, confusion_matrix\nscore, acc = model.evaluate(x_test, y_test)\npred = model.predict(x_test)\npred = le.inverse_transform(np.rint(pred))\ny_test = le.inverse_transform(y_test) if y_test.ndim == 2 else y_test\nprint(classification_report(y_test, pred))\nprint(confusion_matrix(y_test, pred))\nprint('Test score:', score)\nprint('Test accuracy:', acc)","2651250b":"> Utilizamos Multilayer Perceptron como classificador. A camada de entrada possui 9 neur\u00f4nios que corresponde a quantidade de caracter\u00edsticas presentes no dataset. A camada escondida possui o dobro de neur\u00f4nios da primeira e utiliza a fun\u00e7\u00e3o de ativa\u00e7\u00e3o tangente hiperb\u00f3lica, j\u00e1 que o normalizador retorna dados positivos e negativos. Na camada de sa\u00edda foi escolhida a fun\u00e7\u00e3o de ativa\u00e7\u00e3o softmax para mapear os valores entre 0 e 1, para corresponder a sa\u00edda esperada pelo binarizador de r\u00f3tulo.","e639bd01":"Com base nos atributos j\u00e1 existentes foram criados mais 5 novos. Calculou-se as \u00e1reas das p\u00e9talas e s\u00e9palas e tamb\u00e9m a propor\u00e7\u00e3o entre elas, bem como a propor\u00e7\u00e3o entre as laguras e comprimentos.","7d615955":"O dataset possui 150 amostras de flores \u00edris, os quatro primeiros atributos (larguras e comprimentos das p\u00e9talas e s\u00e9palas) foram medidos em cent\u00edmetros e s\u00e3o do tipo flutuante. O \u00faltimo atributo \u00e9 do tipo texto e indica qual a classifica\u00e7\u00e3o daquela amostra. N\u00e3o h\u00e1 dados faltantes neste dataset.","eac9218f":"> \"O dataset Iris foi usado no _paper_ cl\u00e1ssico de R.A. Fisher contendo 150 amostras de 3 classes diferentes (50 cada)  \n> [Link para o dataset](https:\/\/archive.ics.uci.edu\/ml\/datasets\/iris \"UCI Machine Learning Repository\")  \n>  \n> Informa\u00e7\u00f5es de Atributos:\n1. sepal length (cm) (Comprimento da S\u00e9pala) \n2. sepal width (cm) (Largura da S\u00e9pala)\n3. petal length (cm) (Comprimento da P\u00e9tala)\n4. petal width (cm) (Largura da P\u00e9tala)\n5. class (Classe): \n   - Iris Setosa \n   - Iris Versicolour \n   - Iris Virginica\n>\n>\"\n> \n> (Tradu\u00e7\u00e3o Livre)","8545ef29":"Foram escolhidos tipos de dados que representassem melhor cada coluna, \"float16\" por ser suficiente para as colunas flutuantes e \"category\" j\u00e1 que o campo \"Species\" apresenta apenas 3 valores \u00fanicos**.","56eb0f13":"# Matheus Willian Machado Silva\n## RNA","5361d098":"Os comprimentos das s\u00e9palas variam entre 4,3 e 7,9 cm e as larguras entre 2 e 4,4 cm, enquanto que as p\u00e9talas tem seus comprimentos entre 1 e 6,9 cm e larguras entre 0,1 e 2,5 cm.  \nPelos quartis percebemos que as medidas das s\u00e9palas est\u00e3o bem distribuidas enquanto que os valores de p\u00e9talas apresentam um gap entre 25% e 50%.  \nTodos os valores est\u00e3o at\u00e9 (ou muito pr\u00f3ximos de) 3 desvios padr\u00f5es da m\u00e9dia, logo n\u00e3o haver\u00e1 investiga\u00e7\u00e3o de outliers para esta amostra.","961da1d0":"Separamos os atributos entre vari\u00e1veis (x) e r\u00f3tulo (y) e realizamos um preprocessamento dos dados, como binariza\u00e7\u00e3o dos r\u00f3tulos e normaliza\u00e7\u00e3o das vari\u00e1veis. Tamb\u00e9m dividimos os dados em treino e teste numa porpor\u00e7\u00e3o 80\/20 respectivamente. ","1ed1b63a":"Pelo mapa de calor acima, vemos que h\u00e1 uma grande correla\u00e7\u00e3o positiva entre a largura e o comprimento das p\u00e9talas,\ne tamb\u00e9m no comprimento da s\u00e9pala com as medidas da p\u00e9tala.","9356141d":"Na an\u00e1lise multivariada vemos que a classe Iris-setosa \u00e9 facilmente separ\u00e1vel, enquanto que as demais possuem uma \u00e1rea de intersec\u00e7\u00e3o.  \nTamb\u00e9m \u00e9 poss\u00edvel perceber que os novos campos criados ser\u00e3o \u00fateis para auxiliar na separa\u00e7\u00e3o destas classes.","488d4767":"**Trabalho Final**\n\n1. Escolha qualquer problema de classifica\u00e7\u00e3o presente no Kaggle e resolva-o utilizando um MLP;\n1. Prepare um Report em PDF, identificado com seu nome, contendo:\n   - Informa\u00e7\u00f5es sobre o problema: link do dataset, qtd de classe, qtd de caracter\u00edsticas, qtd de amostras;\n   - Informa\u00e7\u00f5es sobre prepara\u00e7\u00e3o dos dados: tamanhos dos conjuntos de treino e teste, normaliza\u00e7\u00f5es, convers\u00f5es, etc.\n   - Informa\u00e7\u00f5es sobre a arquitetura e o treinamento da RNA: Qtd de camadas, neur\u00f4nios, fun\u00e7\u00f5es de ativa\u00e7\u00e3o e otimizador;\n   - Resultados obtidos: Gr\u00e1fico de pelo menos duas m\u00e9tricas ao longo das \u00e9pocas, tanto no treino quanto no teste;\n   - Link para a implementa\u00e7\u00e3o (opcional)."}}