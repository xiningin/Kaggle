{"cell_type":{"45b31eb3":"code","573ec27f":"code","acb58af7":"code","18ef4012":"code","094b82bb":"code","be4b87cb":"code","272efef7":"code","2a2d79d8":"code","74110db1":"code","a510f966":"code","8b808d87":"code","c7c1b252":"code","d8e1165f":"code","3752f530":"code","71d43306":"markdown","56ce65ca":"markdown","dfc40686":"markdown","5b87cdeb":"markdown","57a4f0c2":"markdown","8ce95f85":"markdown","1918a209":"markdown","a010a0b5":"markdown","f1680f63":"markdown","d617a7df":"markdown","2db68e86":"markdown","0c35ca5f":"markdown","10a514b5":"markdown"},"source":{"45b31eb3":"import pandas as pd\nimport numpy as np\nimport re\nfrom sklearn.metrics.pairwise import cosine_similarity\nfrom nltk.corpus import stopwords\nstopwords_english = set(stopwords.words('english'))\nfrom nltk.stem import PorterStemmer\nstemmer = PorterStemmer()\nfrom ast import literal_eval\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","573ec27f":"data = pd.read_csv('..\/input\/the-movies-dataset\/movies_metadata.csv', low_memory = False)[['id','original_title', 'imdb_id', 'genres', 'overview', 'vote_average', 'vote_count']].dropna().set_index('id')\ncredits = pd.read_csv('..\/input\/the-movies-dataset\/credits.csv', low_memory = False).set_index('id').dropna()","acb58af7":"def split_genres(row):\n    row['genres'] = \" \".join([info['name'] for info in literal_eval(row['genres'])])\n    return row\ndata = data.apply(split_genres, axis=1)","18ef4012":"def find_director(row):\n    try:\n        for info in literal_eval(row['crew']):\n            if info['job'] == 'Director':\n                row['director'] = info['name']\n                break\n    except:\n        row['director'] = pd.NA\n    return row\ncredits = credits.apply(find_director, axis=1).drop(['cast', 'crew'], axis=1)\ncredits.index = credits.index.astype(str)","094b82bb":"data = pd.merge(data, credits, left_index = True, right_index = True, how = 'left')\ndata.index = data.index.astype(int)","be4b87cb":"def top_movies(num = 100, quantile = 0.95, data = data):\n    req_votes = np.quantile(data['vote_count'], quantile)\n    \n    new_data = data[data['vote_count']>req_votes]\n    means = new_data['vote_average']\n    tot_mean = new_data['vote_average'].mean()\n    votes = new_data['vote_count']\n    \n    new_data['ratings'] = (votes\/(votes+req_votes)*means + req_votes\/(votes+req_votes)*tot_mean)\n    \n    return new_data.sort_values('ratings', ascending = False).iloc[:num,:].reset_index(drop=True)","272efef7":"def clean(x):\n    res = []\n    for w in x:\n        if w not in stopwords_english:\n            w = stemmer.stem(re.sub('[^a-zA-z0-9]', '', w))\n            if(len(w)>0):\n                res.append(w)\n    return res\n\ndef preprocess(data):\n    stemmer = PorterStemmer()\n    docs = []\n    DF = {}\n    \n    for ind, row in data.iterrows():\n        set_title = set()\n        doc_count = 0\n        title = row['original_title'].lower().strip().split()\n        title += row['genres'].lower().strip().split()\n        title += [row['director'].lower().strip()]\n        body = row['overview'].lower().strip().split()\n        body = clean(body)\n        \n        for word in title+body:\n            if word in DF:\n                if row.name in DF[word]:\n                    DF[word][row.name]+=1\n                else:\n                    DF[word][row.name] = 1\n            else:\n                DF[word] = {}\n                DF[word][row.name] = 1\n            \n            doc_count+=1\n            if word in title:\n                set_title.add(word)\n        docs.append((doc_count, set_title))\n\n    return DF, docs","2a2d79d8":"def generate_cosine_tfidf(data, alpha = 0.6):\n    DF, docs = preprocess(data)\n    tf_idf = np.zeros((len(docs), len(DF)))\n    \n    for i, (word, key) in enumerate(DF.items()):\n        w_count = np.sum([value for _, value in key.items()])\n        for ind, value in key.items():\n            tf = value\/docs[ind][0]\n            idf = np.log(len(docs)\/(w_count+1))\n            tfidf = tf*idf*(1-alpha)\n            if word in docs[ind][1]:\n                tfidf = tf*idf*alpha\n            \n            tf_idf[ind][i] = tfidf\n    return cosine_similarity(tf_idf)","74110db1":"movies = top_movies(500)\ntf_idf = generate_cosine_tfidf(movies, alpha = 0.4)","a510f966":"def predict_movies(movie_name = \"The Dark Knight\", num = 10, verbose = 0, out = True, data = movies, tf_idf = tf_idf):\n    try:\n        ind = data[data['original_title'] == movie_name].index[0]\n        output = data.loc[[val for val in np.argsort(tf_idf[ind])[::-1][1:num+1]]]\n        if verbose == 2:\n            print(\"The TF-IDF Cosine similarity scores for relevant movies are as follows:\\n\")\n            print([round(val,2) for val in np.sort(tf_idf[ind])[::-1][1:num+1]], '\\n')\n        if verbose >= 1:\n            print(f'The top {num} recommended movies for \"{movie_name}\" are as follows:\\n')\n            for ind, row in output.iterrows():\n                print(\"Title: {}\".format(row['original_title']))\n                print(\"Rating: {}\".format(round(row['ratings'], 1)))\n                print(\"Genres: {}\".format(row['genres']))\n                print(\"IMDB Link: https:\/\/www.imdb.com\/title\/{}\".format(row['imdb_id']))\n                print(\"*****************************************************\\n\")\n        if(out):\n            return output\n    except:\n        print(\"MOVIE NOT FOUND!\")","8b808d87":"movies = top_movies(2000)\ntf_idf = generate_cosine_tfidf(movies, alpha = 0.6)","c7c1b252":"predict_movies(\"Moana\", num = 10, verbose = 2, out = False, data = movies, tf_idf = tf_idf)","d8e1165f":"predict_movies(\"The Dark Knight\", num = 10, verbose = 2, out = False, data = movies, tf_idf = tf_idf)","3752f530":"predict_movies(\"The Hobbit: An Unexpected Journey\", num = 10, verbose = 2, out = False, data = movies, tf_idf = tf_idf)","71d43306":"### Cleaning Genres","56ce65ca":"## **Function to predict the top movies given a choice**","dfc40686":"## **Generate the top 2000 movie chart and calculate the Cosine Similarity Matrix**\n#### *Tweak the alpha parameter to lever Title (Movie Title, Genre, Director) vs Body (Movie Description) Bias*","5b87cdeb":"### Merging the two datasets","57a4f0c2":"## **Function to clean the text and create Word-Document-Frequency\/Title-Body Split**","8ce95f85":"## **Data Preporcessing**\n","1918a209":"## **Importing Necessary Libraries**","a010a0b5":"## **Predict the Movies!**","f1680f63":"## **Function to calculate TF-IDF value and generate Pairwise Cosine Similarity Matrix**","d617a7df":"### Finding the Director","2db68e86":"## **Reading the Dataset**","0c35ca5f":"# **TF-IDF Weighted Content and Metadata Movie Recomendation System**","10a514b5":"## **Function to Generate Top Movies Chart**"}}