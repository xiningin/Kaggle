{"cell_type":{"bf904293":"code","721997be":"code","d4f26d80":"code","05c87923":"code","7a76f394":"code","f619ab84":"code","e63a2979":"code","072f446c":"code","833f1423":"code","57ed9c34":"code","0d83b067":"code","da4b9e73":"code","b8065dc7":"code","d54ee050":"code","76ded8da":"code","a539dd15":"code","3cbfebe2":"code","d9b9d9bd":"code","ffb05cee":"code","3f10ff8a":"code","e1d36164":"code","ed57a736":"code","a3acb86f":"code","c6e6d1d3":"code","4b81a39d":"code","dabadc88":"code","ad62e284":"code","365c4786":"code","e0f15971":"markdown","4419509c":"markdown","7f7c4975":"markdown","bfb3fc26":"markdown","866fc0ce":"markdown","b33f2563":"markdown","058e0d31":"markdown","b5c5acdb":"markdown","c100d2ec":"markdown","80238098":"markdown","66fa727e":"markdown","e6e14adc":"markdown","d6639d9e":"markdown","73912656":"markdown","a258094c":"markdown","7a970ddf":"markdown","4a657a44":"markdown","df9a3ce4":"markdown","e20bbda9":"markdown","5ca07ecd":"markdown","3fde2b02":"markdown","da139086":"markdown","7e8e509f":"markdown","870d0f4b":"markdown"},"source":{"bf904293":"solution = \"12345671234561723456127345612374561327456137245613742561374526137456213745612347561324756134275613472561347526134756213475612345761234516723451627345162374516234751623457162345176234512673451263745126347512634571263451726345127634512367451236475123645712364517236451273645123764512346751234657123465172346512734651243765124367512436571243651724365127436512473651246375124635712463517246351274635124763512467351426735146273514672351467325146735216473521674352167345216374521634752163457216345271634521764352176453271645327614532764153276451326745132647513264571326451732645137264531726453712645372164537261453726415372645132764531276453217645231764521376452173654217365241736521473652174365217346521736452176345216735421637542163574216354721635427163542176354216735241637524163572416352741635247163524176352416735214673512465371246531724653127465312476531246753142675314627531467253146752316475321647531264753162475316427531647253164752316745321674531267453162745316724531674253167452316754231675243167523416752314675321467531246573124651372465132746513247651324671532467135246713254671235467125346712543671524367154236715432675143267541326754312675432167543261745362174536127453617245361742536174523617453261743526174325617432651742365174263517426531742651374265173426157342617534216753421765342175634217536421753462175342617354261734526173425617342651743261574362157436125743162574312657413265741236574126357412653741265734126574312567413256741235674125367412563741256734125674312576413257614325761342576132457613254761325746132576412357641253761425376124537612543761524376154237615432761543726154376215437612534761253746125376412573641257634125764312574631257436152743615724361574236157432617543621754361275436172543617524361754236175432671543627154367215436712546371254673125476312547361524736154273615472361547326145736214576321475632147653214763521476325147632154763214576231457621345762143576214537621457361245736142573614527361457236145732614753621475361247536142753614725361475236147532614735261473256147326514723651472635147265314726513472651437265147326154736215473612547316254731265471326547123654712635471265347126543716253471625374162537146253716425371624537162543716524371654237165432716543721654371265473125647132564712356471253647125634712564372156437251643275614327564132756431275643217564327156432751643257163425176342516734251637425163472516342751634257163245176324516732451637245163274516324751632457163254716325741632571463275146327154632714563271465327146352714632571643527164357216435712643517264351276435126743512647351264375126435716243517624351672435162743516247351624375162435716423517642351674235164723516427351642375146237514263751423675142376514273651427635142765314276513427651432765142375614235761423567143256714352671435627143567214356712435617243561274356124735612437561243576124356714235617423561472356142735614237516423571643251764325167432516473251643725614372564137256431725643712564731254671324567132465713246751324615732461753246173524617325416723541762354716235476123547621354762315467231546273154623715462317564231576421356742135647213564271356421735624137562413576241356724135627413562471356241735621473562174356217345621735462173564213756421357642153746215374261537421653742156374215367421537642157364215763421576432157642315674231564723156427315642371564231756243157624315672431562743156247315624371562431756234157623415672341562734156237415623471562341756231475623174562317546321745632174653217463521746325174632157463217546312754631725463175246315724631527463152476315246731524637152463175426315742631547263154276315426731542637154263175462315746235174623571462357416235746123574621357462315476235147623541726354172365417235641723546172354167253417625314762531746253176425317624531762543176524317654231765432176543127654317265431762534172653417256341725364172534617253416725431672541367251436725134672153476215347261534721653472156347215364721534672135467213456721346572136457213654721365742136572413657214365721346752136475213674521367542136752413675214376521437562143752614375216437521463725146372154637214563721465372146357214637521436752134672513647251367425136724513672541637254167325417632541736251473625174362517346257136425713624571362547136257413625714362571346275136427513624751362745136275416327541623754126375412367541237654132765413726541376251437625134762513746251376425137624513762541376524137654213765412375641237546132754613725461375246137542613754621375461237541627354126735412763541273654127356412735461273541627534126753412765341275634127536412753461275341627543162754136275143627513462715342671354267134526713425671342657143265714236571426357142653714265731426571342675134267153427615342716534271563427153642715346271354627134562713465271364527136542713652471365274136527143652713462573146257341625734612573462157346251736425173624517362541732654173256417325461732456173246517324615372461532746153247615324167532416573214657321645731264573162457316425731645273165427316524731652743165273416527314652731645723165472316574231657243165723416572314657231645732165473216574321657342165732416537241653274165324716532417653241567321456731245637124563172456312745631247563124576312456731425637142563174256314725631427563142576314256731452637145236714532671453627145367214536712453671425367145237614523716452371465237416523746152347651234765213476523147652341765234716523476152346715234617523461572346152734615237465123746521374652317465237145623714526317452631475263145726314527631452673145627314567231456732154673215647321567432156734215673241563724156327415632471563241756324157632415367241536274153624715362417536241573624153762415326741532647153264175326415732641523764152367415236471523641752364157236415273641526374152634715263417526341572634152763415267341526437152643175264315726431527643152674315264731526413752641357261435726134572613547261357426135724613572641352761435276134527613542761352476135274613527641352674135264713526417352641\"\nlen(solution)","721997be":"split_id = [len(solution) \/\/ 3, len(solution)*2\/\/3]","d4f26d80":"t1, t2 = split_id\n\nstrings = [solution[:t1+3], solution[t1-3:t2+3], solution[t2-3:]]\nfor s in strings:\n    print(len(s))","05c87923":"import itertools\npermutations = [''.join(x) for x in itertools.permutations(['1','2','3','4','5','6','7'], 7)]\n\nfor p in permutations:\n    if p not in strings[0] and p not in strings[1] and p not in strings[2]:\n        print(p)","7a76f394":"required_permutaions = ['12' + ''.join(x) for x in itertools.permutations(['3','4','5','6','7'], 5)]\nprint(len(required_permutaions))","f619ab84":"for p in required_permutaions:\n    for i in range(3):\n        if p not in strings[i]:\n            strings[i] += p","e63a2979":"for s in strings:\n    print(len(s))","072f446c":"replace_dict = {\n    \"1\": '\ud83c\udf85', \n    \"2\": '\ud83e\udd36', \n    \"3\": '\ud83e\udd8c', \n    \"4\": '\ud83e\udddd', \n    \"5\": '\ud83c\udf84', \n    \"6\": '\ud83c\udf81', \n    \"7\": '\ud83c\udf80', \n}\n\nans = strings.copy()\nfor i in range(3):\n    for k,v in replace_dict.items():\n        ans[i] = ans[i].replace(k, v)","833f1423":"for s in ans:\n    print(s[:30], '...')","57ed9c34":"strings = [solution[:t1+3], solution[t1-3:t2+3], solution[t2-3:]]\nrequired_permutaions = ['42' + ''.join(x) for x in itertools.permutations(['6','7','1','5','3'], 5)]\n\nfor p in required_permutaions:\n    for i in range(3):\n        if p not in strings[i]:\n            strings[i] += p\n            \nfor s in strings:\n    print(len(s))","0d83b067":"strings = [solution[:t1+3], solution[t1-3:t2+3], solution[t2-3:]]\nprint(strings[0][:7])\nprint(strings[0][-7:])","da4b9e73":"# generate a permutation we want to add to each string\ndef get_perm(strings, required_permutaions):\n    ans = [[],[],[]]\n    for i in range(3):\n        for p in required_permutaions:\n            if p not in strings[i]:\n                ans[i].append(p)\n    return ans\n\nto_add = get_perm(strings, required_permutaions)\n\ndef add_suffix(strings, to_add):\n    for i, (s, permutations) in enumerate(zip(strings,to_add)):\n        for l in range(5,0,-1):\n            added = False\n            for p in permutations:\n                if p[-l:] == s[:l]:\n                    strings[i] = p[:-l] + strings[i]\n                    to_add[i].remove(p)\n                    added = True\n                    break\n            if added:\n                break\n\nadd_suffix(strings, to_add)\n\n\ndef add_prefix(strings, to_add):\n    if len(to_add) == 0 or len(to_add[0]) == 0:\n        return\n    start = to_add[0][0][:2]\n    for i,s in enumerate(strings):\n        if s[-1] == start[0]:\n            r = to_add[i].pop(0)\n            strings[i] += r[1:]\n            continue\n        if s[-2:] == start:\n            r = to_add[i].pop(0)\n            strings[i] += r[2:]\n            continue\n        \n        l = s.rfind(start)\n        if len(s) - l > 7 or start[0] in s[l+2:] or start[1] in s[l+2:]:\n            continue\n        overlap = s[l:]\n        for p in to_add[i]:\n            if p[:len(overlap)] == overlap:\n                strings[i] += p[len(overlap):]\n                to_add[i].remove(p)\n                break\n        \nadd_prefix(strings, to_add)\n        \nfor i in range(3):\n    for p in to_add[i]:\n        if p not in strings[i]:\n            strings[i] += p\n\nfor s in strings:\n    print(len(s))","b8065dc7":"for s in strings:\n    print(s[:30], '...')","d54ee050":"strings = [solution[:t1+3], solution[t1-3:t2+3], solution[t2-3:]]\nto_add = get_perm(strings, required_permutaions)\nadd_suffix(strings, to_add)\nadd_prefix(strings, to_add)","76ded8da":"def use_wildcard(strings, to_add):\n    for i in range(3):\n        perm_dict = {}\n        for p in to_add[i]:\n            found = False\n            for j in range(7):\n                for c in ['1','2','3','4','5','6','7']:\n                    string = p[:j] + c + p[j+1:]\n                    pos = strings[i].find(string)\n                    if pos > 0:\n                        strings[i] = strings[i][:pos + j] + '8' + strings[i][pos + j + 1:]\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if found:\n            to_add[i].remove(p)\n        \n            \nuse_wildcard(strings, to_add)\n\nfor i in range(3):\n    for p in to_add[i]:\n        if p not in strings[i]:\n            strings[i] += p\n\nfor s in strings:\n    print(len(s))","a539dd15":"for s in strings:\n    print(s[:30], '...')","3cbfebe2":"import numpy as np","d9b9d9bd":"best_ans = None\nbest_len = 10000\nbest_split = None\nbest_ij = None\n\nt1, t2 = split_id\nfor _ in range(10000):\n    for i in range(1,8):\n        for j in range(1,8):\n            if i == j:\n                continue\n            required_permutaions = [str(i)+str(j) + ''.join(x) for x in itertools.permutations([x for x in ['1','2','3','4','5','6','7'] if x != str(i) and x!=str(j)], 5)]\n\n\n            strings = [solution[:t1+3], solution[t1-3:t2+3], solution[t2-3:]]\n            to_add = get_perm(strings, required_permutaions)\n            add_suffix(strings, to_add)\n            add_prefix(strings, to_add)\n\n            use_wildcard(strings, to_add)\n            use_wildcard(strings, to_add)\n\n            for k in range(3):\n                for p in to_add[k]:\n                    if p not in strings[k]:\n                        strings[k] += p\n\n            l = max([len(s) for s in strings])\n            if l < best_len:\n                best_len = l\n                best_ans = strings.copy()\n                best_split = [t1,t2]\n                best_ij = [str(i),str(j)]\n                print(best_len,best_split,best_ij)\n                    \n    # random step from current optimal split\n    t2 = best_split[1] + np.random.randint(-1,2, 100).sum()\n    t1 = best_split[0] + np.random.randint(-1,2, 100).sum()","ffb05cee":"replace_dict = {\n    best_ij[0]: '\ud83c\udf85', \n    best_ij[1]: '\ud83e\udd36', \n    '8': '\ud83c\udf1f'\n}\n\nother = ['\ud83e\udd8c','\ud83e\udddd','\ud83c\udf84','\ud83c\udf81','\ud83c\udf80']\n\nfor x in ['1','2','3','4','5','6','7']:\n    if x not in best_ij:\n        replace_dict[x] = other.pop(0)\nreplace_dict","3f10ff8a":"ans = best_ans.copy()\nfor i in range(3):\n    for k,v in replace_dict.items():\n        ans[i] = ans[i].replace(k, v)","e1d36164":"for s in ans:\n    print(s[:30], '...')","ed57a736":"import pandas as pd\nsub = pd.DataFrame()\nsub['schedule'] = ans\nsub","a3acb86f":"sub.to_csv('submission.csv', index = False)","c6e6d1d3":"lost_total = []\nfor p in permutations:\n    if p not in best_ans[0] and p not in best_ans[1] and p not in best_ans[2]:\n        print(p)\n        lost_total.append(p)","4b81a39d":"i, j = best_ij\nrequired_permutaions = [str(i)+str(j) + ''.join(x) for x in itertools.permutations([x for x in ['1','2','3','4','5','6','7'] if x != str(i) and x!=str(j)], 5)]","dabadc88":"lost = [[],[],[]]\nfor p in required_permutaions:\n    for i in range(3):\n        if p not in best_ans[i]:\n            lost[i].append(p)\nprint(lost)","ad62e284":"for i in range(3):\n    for c in ['1','2','3','4','5','6','7']:\n        s = best_ans[i].replace('8', c)\n        for p in lost[i]:\n            if p in s:\n                print(f\"{p} found in {i} with wildcard {c}\")","365c4786":"for i in range(3):\n    for c in ['1','2','3','4','5','6','7']:\n        s = best_ans[i].replace('8', c)\n        for p in lost_total:\n            if p in s:\n                print(f\"{p} found in {i} with wildcard {c}\")","e0f15971":"We split the string with 3 symbols overlapping because we don't want to lose any permutation.\nNow the combination of these 3 strings covers all possible permutations. Let's check it.","4419509c":"# Suffix and prefix optimization","7f7c4975":"# Basic straightforward solution","bfb3fc26":"It starts with '123', but all our obligatory permutations start from '42' it means that if the first string doesn't contain some string that looks like: \"42\\*\\*\\*\\*1\" we can concatenate \"42\\*\\*\\*\\*\" at the beginning instead of concatenating the whole additional string to the end and save 1 symbol.\n\nWe can do a similar trick with the end by concatenating only part of '427\\*\\*\\*\\*' and saving three symbols. Sometimes optimization can be even more significant.","866fc0ce":"# Using a wild card","b33f2563":"We can use a wild card to replace any other symbol. Let's use it in the process of adding obligatory permutations. We will try to use wildcard injection instead of adding some new permutations to the string.","058e0d31":"To answer these questions, let's just do some random search.","b5c5acdb":"# Random search","c100d2ec":"Let's look at the beginning and the end of the first string (before we added permutations)","80238098":"Let's double check validity","66fa727e":"Let's convert it to the final submission:","e6e14adc":"# Renaming characters","d6639d9e":"Most of the functions I have used here are extremely slow. I didn't even try to optimize them and wrote everything as straightforward as possible. There is massive room for optimization. The approach can be orders of magnitude faster.","73912656":"So now we have a valid solution: if we replace numbers with emojis, we can submit with a score of 2637.","a258094c":"So far, I have covered some optimization ideas, but they are very sensitive to assumptions. For example, what will happen if we move the split points for the initial strings a bit? What will happen if we will use other symbols to denote \ud83c\udf85\ud83e\udd36? How will these changes influence other optimization steps?","7a970ddf":"Probably these permutations are covered by wildcards:","4a657a44":"We can see that in our previous solution, the length of the first string is much smaller than the two others. Because of the logic of the generation of the initial solution - many \ud83c\udf85\ud83e\udd36 pairs are concentrated in the first third of the string.\nBut all characters in the initial string are equal. We can swap any of them, and it will still be a valid solution. So we can improve our approach by using, for example '4' and '2' to denote \ud83c\udf85 and \ud83e\udd36 (instead of '1' and '2')","df9a3ce4":"We improved our score from 2566 to 2562 as expected.","e20bbda9":"Our best score has improved from 2562 to 2555.","5ca07ecd":"Now we need to add permutations starting from '12' to all strings. The easiest way to do it is just to concatenate the missing permutations to the end of each string.","3fde2b02":"[Wikipedia](https:\/\/en.wikipedia.org\/wiki\/Superpermutation) says that the optimal solution for n = 7 is not known for sure, but the shortest found so far has a length of 5906.\n\nYou can find this solution at https:\/\/www.gregegan.net\/ [here](https:\/\/www.gregegan.net\/SCIENCE\/Superpermutations\/7_5906_nsk666646664466646666_2SYMM_FS.txt)\n\nLet's use it and split it into 3 approximately equal strings.","da139086":"### The Santa 2021 competition is here!\n\nThis year in the Santa competition, we are dealing with some form of a modified Superpermutation problem.\nIn the original minimal superpermutations problem, the goal is to find the shortest string containing all possible permutations of n symbols (n = 7 in this case). This competition introduces some changes:\n1. We need to generate 3 strings that cover all permutations together (instead of 1)\n2. Some subset of permutations (starting from \ud83c\udf85\ud83e\udd36) should be covered by each of these 3 strings\n3. There is a special wildcard that can replace any symbol (\ud83c\udf1f) and allows to optimize the solution further","7e8e509f":"In this notebook, I will share my initial thoughts about a possible approach. It will cover the following steps:\n1. Take some good solutions for the original minimal superpermutation problem for n = 7.\n2. Split it into 3 ~equal parts\n3. Concatenate additional permutations (starting from \ud83c\udf85\ud83e\udd36) to each string\n4. Add (\ud83c\udf1f) to further optimize the length of strings\n5. Apply random search (repeating steps 1-4) to find more optimal splits\n+ some tricks for better optimization\n\nNone of these steps are optimal. I am pretty sure that it can be optimized further, and this is only the basic baseline solution.","870d0f4b":"Now string sizes are closer to each other, and we improved our score from 2640 to 2566."}}