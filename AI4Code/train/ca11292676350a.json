{"cell_type":{"5100728b":"code","074c459a":"code","f74107f2":"code","2663b73c":"code","5a1f74f5":"code","bb18e74b":"code","a13dfb90":"code","af4f1fa2":"code","6e616ea3":"code","31381042":"code","f0762680":"code","d576a671":"code","fa44d752":"code","312f878a":"code","b99fd4fa":"code","c1a82b68":"code","6a16d572":"code","6b1670bc":"code","81231b91":"code","e3fa280c":"code","5468dadb":"code","d50653a8":"code","baada375":"code","9ba0dd4a":"code","df8e754c":"code","c2ff2d48":"code","9ed62b79":"code","0f3a1156":"code","7629a701":"code","edc8476f":"code","023622a1":"code","7569158e":"code","2daaa84f":"code","a0f456d9":"code","941ea0a6":"code","fe053ff4":"code","d0cdc2f5":"code","dbc1d8d2":"code","c2fad01e":"code","447ec9c7":"code","22aaad1d":"code","6e05a1fb":"code","98b84a29":"code","f3c0b68d":"code","5bb4827c":"code","d288ad87":"code","59296cec":"code","1d4d15ea":"code","0ab963c3":"code","2cecc571":"code","aad3a2a8":"code","6d0847ee":"code","8018e4d9":"markdown","1018d2c6":"markdown","5667a329":"markdown","c36e30c3":"markdown","b9dd9fb4":"markdown","3a275f83":"markdown","64e61a40":"markdown","fda667d0":"markdown","f9d9d104":"markdown","2b927aeb":"markdown","6b6ef009":"markdown","3551578d":"markdown","0bba2669":"markdown","100521e6":"markdown","fd0ca098":"markdown","a004e326":"markdown","901698f8":"markdown","3c78d30c":"markdown","d9a03c33":"markdown","2e5b8ee5":"markdown","635c7d3d":"markdown","cd748b0e":"markdown","b50c168e":"markdown","3edf047c":"markdown","e5ba56f9":"markdown","6a3793cf":"markdown","dd19c52d":"markdown","1069eb2c":"markdown","335273d4":"markdown","55398df5":"markdown","c1969fc9":"markdown","47013a00":"markdown","4a32b844":"markdown","c76f2b14":"markdown","624f6a36":"markdown","d7aead71":"markdown","65995d21":"markdown","4a713d7a":"markdown"},"source":{"5100728b":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt # graphs\nimport plotly.offline \nimport plotly.graph_objs as go\nplotly.offline.init_notebook_mode(connected=True)\niplot = plotly.offline.iplot\n\nfrom IPython.display import display","074c459a":"cats = pd.read_csv('..\/input\/item_categories.csv')\nitems = pd.read_csv('..\/input\/items.csv')\nshops = pd.read_csv('..\/input\/shops.csv')\ntrain = pd.read_csv('..\/input\/sales_train.csv')\ntest = pd.read_csv('..\/input\/test.csv')\n\nprint(f'''Shapes:\nItem categories: {cats.shape}\nItems: {items.shape}\nShops: {shops.shape}\nTrain set: {train.shape}\nTest set: {test.shape}''')","f74107f2":"print(cats.info())\ncats.head()","2663b73c":"print(items.info())\nitems.head()","5a1f74f5":"print(shops.info())\nshops.head()","bb18e74b":"print(train.info())\ntrain.head()","a13dfb90":"print(test.info())\ntest.head()","af4f1fa2":"# train['item_cnt_day'].value_counts().sort_index()\npd.cut(train['item_cnt_day'], [-np.inf] + list(range(0, 21)) + [np.inf]).value_counts()\n# items[items.item_id == train.sort_values('item_cnt_day', ascending=False).head()['item_id'].iloc[0]]","6e616ea3":"train['item_sale'] = train['item_price'] * train['item_cnt_day'] # a new feature to calculate total sale for the item\ntrain = pd.merge(train, items[['item_id', 'item_category_id']], how='left', on='item_id') # merge train & items to get item_category_id\ntest = pd.merge(test, items[['item_id', 'item_category_id']], how='left', on='item_id')\ndisplay(train.head(), test.head())","31381042":"train.groupby('item_id')['item_category_id'].agg(lambda x: x.nunique()).value_counts()","f0762680":"train['date'] = pd.to_datetime(train['date'], format='%d.%m.%Y')\n\n# add year and month as they can be useful for future prediction\ntrain['year'] = train['date'].dt.year\ntrain['month'] = train['date'].dt.month\n\n# add date_block_num, year, month for test too\ntest['date_block_num'] = 34 # continue from 33 from train\ntest['year'] = 2015\ntest['month'] = 11","d576a671":"# this code block below plots interactive graphs\ndef groupby(thing,  label = ''):\n    # this function is used by the updatemenus, buttons dict further down in line 26\n    tmp = train.groupby(thing)[['item_cnt_day', 'item_sale']].sum()\n    return dict(\n        args=[{\n            'x': [tmp.index, tmp.index],\n            'y': [tmp['item_cnt_day'], tmp['item_sale']],\n        }],\n        method='update', label=label\n    )\n\ntmp = groupby('date')\ntrace1 = go.Scatter(x=tmp['args'][0]['x'][0], y=tmp['args'][0]['y'][0], opacity=0.75, name='item_cnt_day')\ntrace2 = go.Scatter(x=tmp['args'][0]['x'][1], y=tmp['args'][0]['y'][1], opacity=0.75, name='item_sale', yaxis='y2')\ndata = [trace1, trace2]\nlayout = go.Layout(\n    yaxis=dict(title='Item counts'),\n    yaxis2=dict(title='Item sale', overlaying='y', side='right')\n)\n\n\nfig = go.Figure(data=data, layout=layout)\nfig.layout.updatemenus = list([\n    dict(\n        buttons=[groupby(i, l) for i, l in [\n            (train.date.dt.date, 'date'),\n            (train.date.dt.dayofyear, 'day of year'),\n            (train.date.dt.day, 'day of month'),\n            (train.date.dt.dayofweek, 'day of week'),\n            (train.date.dt.month, 'month'),\n            (train.date.dt.week, 'week'),\n            (train.date.dt.weekofyear, 'week of year'),\n            (train.date.dt.year, 'year')\n        ]] ,\n        direction = 'down',\n        showactive = True,\n        x = 0, xanchor = 'left',\n        y = 1.25, yanchor = 'top' \n    ),\n])\niplot(fig)","fa44d752":"def groupby(thing, sort_values = 'item_cnt_day'):\n    tmp = train.groupby(thing)[['item_cnt_day', 'item_sale']].sum().sort_values(sort_values).reset_index()[:-100:-1]\n    return dict(\n        args=[{\n            'x': [tmp[thing], tmp[thing]],\n            'y': [tmp['item_cnt_day'], tmp['item_sale']],\n        }, {\n            'xaxis': dict(type='category')\n        }],\n        method='update', label=thing + ' sort by ' + sort_values\n    )\n\ntmp = groupby('item_id')\ntrace1 = go.Bar(x=tmp['args'][0]['x'][0], y=tmp['args'][0]['y'][0], opacity=0.5, name='item_cnt_day')\ntrace2 = go.Bar(x=tmp['args'][0]['x'][1], y=tmp['args'][0]['y'][1], opacity=0.5, name='item_sale', yaxis='y2')\ndata = [trace1, trace2]\nlayout = go.Layout(\n    xaxis=dict(type='category'),\n    yaxis=dict(title='Item counts'),\n    yaxis2=dict(title='Item sale', overlaying='y', side='right')\n)\nfig = go.Figure(data=data, layout=layout)\nfig.layout.updatemenus = list([\n    dict(\n        buttons=[groupby(i, s) for i, s in [\n            ('item_id', 'item_cnt_day'),\n            ('item_id', 'item_sale'),\n            ('item_category_id', 'item_cnt_day'),\n            ('item_category_id', 'item_sale'),\n            ('shop_id', 'item_cnt_day'),\n            ('shop_id', 'item_sale'),\n        ]] ,\n        direction = 'down',\n        showactive = True,\n        x = 0, xanchor = 'left',\n        y = 1.25, yanchor = 'top' \n    ),\n])\niplot(fig)","312f878a":"# this code block takes a long time to run, so only selec the top 25 items for displaying\ntraces = []\nfor i in train.groupby('item_id')['item_cnt_day'].sum().sort_values(ascending=False).index[:25]:\n    tmp = train[train['item_id'] == i].groupby('date_block_num')['item_cnt_day'].sum()\n    traces.append(go.Scatter(x = tmp.index, y = tmp, opacity=0.5, name=str(i), visible='legendonly'))\n\niplot({\n    'data': traces,\n    'layout': {\n        'xaxis': { 'title': 'date_block_num' },\n        'yaxis': { 'title': 'item_cnt_day' },\n        'title': 'Number of item_cnt_day per item_id',\n    },\n})","b99fd4fa":"traces = []\nfor i in train.groupby('item_category_id')['item_cnt_day'].sum().sort_values(ascending=False).index:\n    tmp = train[train['item_category_id'] == i].groupby('date_block_num')['item_cnt_day'].sum()\n    traces.append(go.Scatter(x = tmp.index, y = tmp, opacity=0.5, name=str(i), visible='legendonly'))\n\niplot({\n    'data': traces,\n    'layout': {\n        'xaxis': { 'title': 'date_block_num' },\n        'yaxis': { 'title': 'item_cnt_day' },\n        'title': 'Number of item_cnt_day per item_category_id',\n    },\n})","c1a82b68":"traces = []\nfor i in train.groupby('shop_id')['item_cnt_day'].sum().sort_values(ascending=False).index:\n    tmp = train[train['shop_id'] == i].groupby('date_block_num')['item_cnt_day'].sum()\n    traces.append(go.Scatter(x = tmp.index, y = tmp, opacity=0.5, name=str(i), visible='legendonly'))\n\niplot({\n    'data': traces,\n    'layout': {\n        'xaxis': { 'title': 'date_block_num' },\n        'yaxis': { 'title': 'item_cnt_day' },\n        'title': 'Number of item_cnt_day per shop',\n    },\n})","6a16d572":"def count_and_corr(x):\n    count = len(x)\n    corr = np.corrcoef(x['item_cnt_day'], x['item_price'])[0, 1] if count > 1 else np.nan\n    return pd.Series([count, corr], index=['count', 'corr'])\n\ntrain.groupby('item_id').apply(count_and_corr).sort_values('corr', ascending=False)","6b1670bc":"len(set(test['shop_id']).difference(set(train['shop_id']))) # all shop_id in the test set are present in the train set\nlen(set(test['item_category_id']).difference(set(train['item_category_id']))) # all categories are present in both\nlen(set(test['item_id']).difference(set(train['item_id']))) # 363 item_id in the test set are NOT present in the train set","81231b91":"# first we define some helper functions: scoring and saving to csv\n\nfrom sklearn.metrics import mean_squared_error\n\ndef score(*y): return mean_squared_error(*y) ** 0.5\n\n# save to csv for submission\ndef to_csv(predicted_values, filename):\n    pd.DataFrame({\n        'ID': test['ID'],\n        'item_cnt_month': predicted_values.clip(0, 20)\n    }).to_csv(filename, index=False)","e3fa280c":"tmp = train[train['date_block_num'] == 33].groupby(['shop_id', 'item_id'])['item_cnt_day'].sum().reset_index().rename(columns={ 'item_cnt_day': 'item_cnt_month' }) # agg item_cnt_day by shop_id and item_id\ntmp = test.merge(tmp, how='left', on=['shop_id', 'item_id']) # merge test with tmp using shop_id and item_id\n\n# use as is\nto_csv(tmp['item_cnt_month'].fillna(0), 'basic.csv') # there are lots of NaN in item_cnt LB 8.53027\n\n# clip from 0 to 20\nto_csv(tmp['item_cnt_month'].fillna(0).clip(0, 20), 'basic_clipped_0_20.csv') # LB 1.16777\n\n# fill na with median groupby shop\nto_csv(tmp['item_cnt_month'].fillna(tmp.groupby('shop_id')['item_cnt_month'].transform('median')).clip(0, 20), 'basic_fillna_median.csv') # LB 1.41848\n\n# jsut having a look\ntmp.item_cnt_month.describe()","5468dadb":"# we re format the train to aggregate item_cnt_day to item_cnt_month\ntmp = train.groupby(['date_block_num', 'year', 'month', 'shop_id', 'item_id', 'item_category_id']).agg({\n    'item_price': 'median',\n    'item_cnt_day': 'sum',\n}).reset_index().rename(columns={ 'item_cnt_day': 'item_cnt_month' })\n\n# then add the previous item_cnt_month\ntmp = tmp.merge(\n    tmp.assign(date_block_num=tmp['date_block_num'] + 1)[['date_block_num', 'shop_id', 'item_id', 'item_cnt_month']].rename(columns={ 'item_cnt_month': 'item_cnt_month_pre' }),\n    how='left',\n    on=['date_block_num', 'shop_id', 'item_id'],\n)\n\n# remove the date_block_num 0\ntmp = tmp[tmp['date_block_num'] != 0]\n\n# fillna with 0\ntmp['item_cnt_month_pre'].fillna(0, inplace=True)\n\n# train.groupby(['date_block_num', 'year', 'month']).size() # this is to check date_block_num vs year \/ month all agree\n\n# these are our predictor features\ncols = ['date_block_num', 'year', 'month', 'shop_id', 'item_id', 'item_category_id', 'item_price', 'item_cnt_month_pre']\n\n# then create train and val set\nX_train = tmp[tmp['date_block_num'] < 33][cols]\ny_train = tmp[tmp['date_block_num'] < 33]['item_cnt_month']\n\nX_val = tmp[tmp['date_block_num'] == 33][cols]\ny_val = tmp[tmp['date_block_num'] == 33]['item_cnt_month']\n\n# show the data\ndisplay(tmp.head())\n\n# also add extra features to test\ntmp = pd.merge(\n    test,\n    tmp[tmp['date_block_num'] == 33][['shop_id', 'item_id', 'item_price', 'item_cnt_month']].rename(columns={ 'item_cnt_month': 'item_cnt_month_pre' }),\n    how='left',\n    on=['shop_id', 'item_id'],\n    suffixes=['', '_y']\n).fillna(0)[cols]\n\n# then show the data\ndisplay(tmp.head())","d50653a8":"# %%time\n# from sklearn.ensemble import RandomForestRegressor\n\n# model = RandomForestRegressor(n_estimators=100, random_state=0, n_jobs=-1)\n# model.fit(X_train, y_train)\n\n# print(f'''RMSE\n# train: {score(model.predict(X_train), y_train):.4f}\n# val: {score(model.predict(X_val), y_val):.4f}''')\n\n# # save to csv\n# to_csv(model.predict(test[cols]), 'submission_rf.csv')\n\n# # repeat with clipping y\n# model = RandomForestRegressor(n_estimators=100, random_state=0, n_jobs=-1)\n# model.fit(X_train, y_train.clip(0, 20))\n\n# print(f'''RMSE with clipping in y\n# train: {score(model.predict(X_train), y_train.clip(0, 20)):.4f}\n# val: {score(model.predict(X_val), y_val.clip(0, 20)):.4f}''')\n\n# to_csv(model.predict(test[cols]), 'submission_rf2.csv')","baada375":"# run out of memory when n_estimators>=200, so not run this\n# %%time\n# hist = { 'train': [], 'val': [], 'i': [], }\n# for i in [10, 100, 200, 300, 400, 500]:\n#     print(i)\n#     model = RandomForestRegressor(n_estimators=i, max_depth=10, random_state=0, n_jobs=-1)\n#     model.fit(X_train, y_train)\n#     hist['i'].append(i)\n#     hist['train'].append(score(model.predict(X_train), y_train))\n#     hist['val'].append(score(model.predict(X_val), y_val))","9ba0dd4a":"%%time\n\nimport lightgbm as lgb\n\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n    'metric': 'rmse',\n    'seed': 0,\n    'nthread': 4,\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_train, y_train),\n    5000,\n    valid_sets=lgb.Dataset(X_val, y_val),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb1.csv') # this give LB 5.52450","df8e754c":"%%time\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_train, y_train.clip(0, 20)), # clip 0 ~ 20 here\n    5000,\n    valid_sets=lgb.Dataset(X_val, y_val.clip(0, 20)),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb1b.csv') # this give LB 2.78524","c2ff2d48":"%%time\n\nimport xgboost as xgb\n\nmodel = xgb.train(\n    params={ 'eta': 0.15, 'silent': 1,  },\n    dtrain=xgb.DMatrix(X_train, label=y_train, silent=True),\n    num_boost_round=100,\n    evals=[(xgb.DMatrix(X_val, label=y_val, silent=True), 'test')],\n    early_stopping_rounds=10\n)\n\nto_csv(model.predict(xgb.DMatrix(tmp)), 'xgb1.csv') # LB 18.51368","9ed62b79":"%%time\n# clipping y to 0, 20 during training\n\nimport xgboost as xgb\n\nmodel = xgb.train(\n    params={ 'eta': 0.15, 'silent': 1,  },\n    dtrain=xgb.DMatrix(X_train, label=y_train.clip(0, 20), silent=True),\n    num_boost_round=100,\n    evals=[(xgb.DMatrix(X_val, label=y_val.clip(0, 20), silent=True), 'test')],\n    early_stopping_rounds=10\n)\n\n\nto_csv(model.predict(xgb.DMatrix(tmp)), 'xgb1b.csv') # LB is 3.32154","0f3a1156":"# as before, agg item_cnt_month\ntmp = train.groupby(['date_block_num', 'year', 'month', 'shop_id', 'item_id', 'item_category_id']).agg({\n    'item_price': 'median',\n    'item_cnt_day': 'sum',\n}).reset_index().rename(columns={ 'item_cnt_day': 'item_cnt_month' })\n\n# then use item_cnt_month from the previous 6 months\nfor i in range(1, 7):\n    tmpi = tmp[['date_block_num', 'shop_id', 'item_id', 'item_cnt_month']].copy()\n    tmpi['date_block_num'] += i\n    tmpi.rename(columns={ 'item_cnt_month': 'item_cnt_month_pre_' + str(i) }, inplace=True)\n    tmp = tmp.merge(tmpi, how='left', on=['date_block_num', 'shop_id', 'item_id']).fillna(0)\n\n    \n# these are our predictor features\ncols = ['date_block_num', 'year', 'month', 'shop_id', 'item_id', 'item_category_id', 'item_price',\n        'item_cnt_month_pre_1', 'item_cnt_month_pre_2', 'item_cnt_month_pre_3', 'item_cnt_month_pre_4', 'item_cnt_month_pre_5', 'item_cnt_month_pre_6']\n\n# clip the item_cnt_month to 0 to 20\nfor i in ['item_cnt_month', 'item_cnt_month_pre_1', 'item_cnt_month_pre_2', 'item_cnt_month_pre_3', 'item_cnt_month_pre_4', 'item_cnt_month_pre_5', 'item_cnt_month_pre_6']:\n    tmp[i] = tmp[i].clip(0, 20)\n\ndisplay(tmp.head())\n\n# create train and val set\nX_train = tmp[(tmp['date_block_num'] < 33) & (tmp['date_block_num'] > 5)][cols] # remove the first 6 months in the dataset where date_block_num is in 0 to 5\ny_train = tmp[(tmp['date_block_num'] < 33) & (tmp['date_block_num'] > 5)]['item_cnt_month']\n\nX_val = tmp[tmp['date_block_num'] == 33][cols]\ny_val = tmp[tmp['date_block_num'] == 33]['item_cnt_month']\n\n# test set features need to be updated too\ntmp = pd.merge(\n    test[['ID', 'date_block_num', 'year', 'month', 'shop_id', 'item_id', 'item_category_id']],\n    tmp.assign(date_block_num = tmp.date_block_num + 1),\n    how='left',\n    on=['date_block_num', 'shop_id', 'item_id'],\n    suffixes=['', '_y']\n).fillna(0)[cols]\n\nprint(tmp.shape)\ndisplay(tmp.head())","7629a701":"%%time\nimport lightgbm as lgb\n\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n    'metric': 'rmse',\n    'seed': 0,\n    'nthread': 4,\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_train, y_train),\n    5000,\n    valid_sets=lgb.Dataset(X_val, y_val),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb2.csv') # this gives LB 2.89164 sadly","edc8476f":"from hyperopt import hp, tpe, Trials, fmin, STATUS_OK\nfrom time import time\nimport lightgbm as lgb\n\n# iterations\ni = 0\n\n# define spaces to search\nspace = {\n    'num_leaves': hp.quniform('num_leaves', 25, 75, 1),\n    'learning_rate': hp.loguniform('learning_rate', np.log(0.01), np.log(0.05)),\n    'subsample_for_bin': hp.quniform('subsample_for_bin', 20000, 300000, 20000),\n    'min_child_samples': hp.quniform('min_child_samples', 20, 500, 5),\n    'reg_alpha': hp.uniform('reg_alpha', 0.0, 1.0),\n    'reg_lambda': hp.uniform('reg_lambda', 0.0, 1.0),\n    'colsample_bytree': hp.uniform('colsample_by_tree', 0.6, 1.0),\n    'bagging_fraction': hp.uniform('bagging_fraction', 0.75, 1.0),\n}\n\n# objective function: to minimise the cost\ndef objective(params):\n    t = time() # keep track of duration for each iteration\n    global i\n    i += 1 # increase iteration count\n    for j in ['num_leaves', 'subsample_for_bin', 'min_child_samples']: params[j] = int(params[j]) # need to explicitly turn them into int\n\n    model = lgb.train(\n        { **params, 'objective': 'regression', 'metric': 'rmse', 'nthread': 4, 'bagging_freq': 5, 'seed': 0 }, # merge params together\n        lgb.Dataset(X_train, y_train),\n        5000,\n        valid_sets=lgb.Dataset(X_val, y_val),\n        early_stopping_rounds=100,\n        verbose_eval=0\n    )\n    loss = model.best_score['valid_0']['rmse']\n    \n    t = time() - t\n    print(f'{i}) {t:.1f}s, {loss:.4f}, {params}')\n    return loss\n\n# our trial history\ntrials = Trials()\n\n# run the baysian optimisation for params tuning\n# best = fmin(fn=objective, space=space, algo=tpe.suggest, max_evals=1000, trials=trials, rstate=np.random.RandomState(0))","023622a1":"# because it takes so long for tuning, and the kernel can only run for 6 hours, so every now and then I save the params to a pickle file, then upload this file to else where\n# later on, I can download the pickle file again and continue the training where it left.\n# I use https:\/\/file.io for simple file storage.\n\n# import pickle\n# with open('trials.pickle', 'wb') as handle: pickle.dump(trials, handle, protocol=pickle.HIGHEST_PROTOCOL)\n# with open('trials.pickle', 'rb') as handle: trials = pickle.load(handle)\n# !curl -F \"file=@trials.pickle\" https:\/\/file.io\n\n# print(len(trials.trials))\n# sorted(trials, key=lambda k: k['result']['loss'] if 'loss' in k['result'] else np.inf)","7569158e":"%%time\n# we have found the best params\n\nparams = {\n    'objective': 'regression', 'metric': 'rmse', 'nthread': 4, 'bagging_freq': 5, 'seed': 0,\n    'bagging_fraction': 0.9706689662242649,\n    'colsample_by_tree': 0.7315494493281669,\n    'learning_rate': 0.016357695097584456,\n    'min_child_samples': 150,\n    'num_leaves': 65,\n    'reg_alpha': 0.053334028461403574,\n    'reg_lambda': 0.111413264877147,\n    'subsample_for_bin': 240000,\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_train, y_train),\n    5000,\n    valid_sets=lgb.Dataset(X_val, y_val),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb2b.csv') # this gives LB 3.00277, :-(","2daaa84f":"%%time\n\nimport xgboost as xgb\n\nmodel = xgb.train(\n    params={ 'eta': 0.15, 'silent': 1,  },\n    dtrain=xgb.DMatrix(X_train, label=y_train, silent=True),\n    num_boost_round=100,\n    evals=[(xgb.DMatrix(X_val, label=y_val, silent=True), 'test')],\n    early_stopping_rounds=10\n)\n\nto_csv(model.predict(xgb.DMatrix(tmp)), 'xgb2.csv') # LB 2.35866","a0f456d9":"tmp = train.pivot_table(index=['shop_id', 'item_id'], columns=['date_block_num'], values='item_cnt_day', aggfunc=np.sum).fillna(0)\n\ntmp.head()\n\nX_train = tmp.loc[:, :32].values\ny_train = tmp[32].values\n\nX_val = tmp.loc[:, 1:33].values\ny_val = tmp[33].values\n\ntmp = test[['shop_id', 'item_id']].merge(tmp, how='left', on=['shop_id', 'item_id']).fillna(0).loc[:, range(2:34)].values","941ea0a6":"%%time\n\nimport lightgbm as lgb\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n    'metric': 'rmse',\n    'seed': 0,\n    'nthread': -1,\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_train, y_train),\n    5000,\n    valid_sets=lgb.Dataset(X_val, y_val),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb3.csv') # LB 1.08520","fe053ff4":"%%time\n\nimport xgboost as xgb\n\nmodel = xgb.train(\n    params={ 'eta': 0.15, 'silent': 1,  },\n    dtrain=xgb.DMatrix(X_train, label=y_train, silent=True),\n    num_boost_round=100,\n    evals=[(xgb.DMatrix(X_val, label=y_val, silent=True), 'test')],\n    early_stopping_rounds=10\n)\n\nto_csv(model.predict(xgb.DMatrix(tmp)), 'xgb3.csv') # LB 1.05809","d0cdc2f5":"%%time\n\nimport lightgbm as lgb\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n    'metric': 'rmse',\n    'seed': 0,\n    'nthread': -1,\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_train, y_train.clip(0, 20)),\n    5000,\n    valid_sets=lgb.Dataset(X_val, y_val.clip(0, 20)),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb3b.csv') # LB 1.03805","dbc1d8d2":"%%time\n\nimport xgboost as xgb\n\nmodel = xgb.train(\n    params={ 'eta': 0.15, 'silent': 1,  },\n    dtrain=xgb.DMatrix(X_train, label=y_train, silent=True),\n    num_boost_round=100,\n    evals=[(xgb.DMatrix(X_val, label=y_val, silent=True), 'test')],\n    early_stopping_rounds=10\n)\n\nto_csv(model.predict(xgb.DMatrix(tmp)), 'xgb3b.csv') # LB 1.03369","c2fad01e":"tmp = train.pivot_table(index=['shop_id', 'item_id'], columns=['date_block_num'], values='item_cnt_day', aggfunc=np.sum).fillna(0).clip(0, 20)\n\ntmp.head()\n\nX_train = tmp.loc[:, :32].values\ny_train = tmp[32].values\n\nX_val = tmp.loc[:, 1:33].values\ny_val = tmp[33].values\n\ntmp = test[['shop_id', 'item_id']].merge(tmp, how='left', on=['shop_id', 'item_id']).fillna(0).loc[:, range(2:34)].values","447ec9c7":"%%time\n\nimport lightgbm as lgb\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n    'metric': 'rmse',\n    'seed': 0,\n    'nthread': -1,\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_train, y_train),\n    5000,\n    valid_sets=lgb.Dataset(X_val, y_val),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb4.csv') # LB 1.03592\n# to_csv(model.predict(tmp).round(), 'lgb4b.csv') # LB 1.05436","22aaad1d":"%%time\n\nimport lightgbm as lgb\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n    'metric': 'rmse',\n    'seed': 0,\n    'nthread': -1,\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_val, y_val), # swap the X_train and X_val here\n    5000,\n    valid_sets=lgb.Dataset(X_train, y_train),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb4c.csv') # LB 1.02844","6e05a1fb":"from hyperopt import hp, tpe, Trials, fmin, STATUS_OK\nfrom time import time\nimport lightgbm as lgb\n\n# iterations\ni = 0\n\n# define spaces to search\nspace = {\n    'num_leaves': hp.quniform('num_leaves', 25, 75, 1),\n    'learning_rate': hp.loguniform('learning_rate', np.log(0.01), np.log(0.05)),\n    'subsample_for_bin': hp.quniform('subsample_for_bin', 20000, 300000, 20000),\n    'min_child_samples': hp.quniform('min_child_samples', 20, 500, 5),\n    'reg_alpha': hp.uniform('reg_alpha', 0.0, 1.0),\n    'reg_lambda': hp.uniform('reg_lambda', 0.0, 1.0),\n    'colsample_bytree': hp.uniform('colsample_by_tree', 0.6, 1.0),\n    'bagging_fraction': hp.uniform('bagging_fraction', 0.75, 1.0),\n}\n\n# objective function: to minimise the cost\ndef objective(params):\n    t = time() # keep track of duration for each iteration\n    global i\n    i += 1 # increase iteration count\n    for j in ['num_leaves', 'subsample_for_bin', 'min_child_samples']: params[j] = int(params[j]) # need to explicitly turn them into int\n\n    model = lgb.train(\n        { **params, 'objective': 'regression', 'metric': 'rmse', 'nthread': 4, 'bagging_freq': 5, 'seed': 0 }, # merge params together\n        lgb.Dataset(X_val, y_val),\n        5000,\n        valid_sets=lgb.Dataset(X_train, y_train),\n        early_stopping_rounds=100,\n        verbose_eval=0\n    )\n    loss = model.best_score['valid_0']['rmse']\n    \n    t = time() - t\n    print(f'{i}) {t:.1f}s, {loss:.4f}, {params}')\n    return loss\n\n# our trial history\ntrials = Trials()\n\n# run the baysian optimisation for params tuning\n# best = fmin(fn=objective, space=space, algo=tpe.suggest, max_evals=1000, trials=trials, rstate=np.random.RandomState(0))","98b84a29":"%%time\n\nimport lightgbm as lgb\n\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n    'metric': 'rmse',\n    'seed': 0,\n    'nthread': -1,\n    'bagging_fraction': 0.8525450579226199,\n    'colsample_by_tree': 0.9705350658278141,\n    'learning_rate': 0.04395833528778046,\n    'min_child_samples': 460,\n    'num_leaves': 60,\n    'reg_alpha': 0.18424221349470526,\n    'reg_lambda': 0.7506282086709485,\n    'subsample_for_bin': 140000,\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_train, y_train),\n    5000,\n    valid_sets=lgb.Dataset(X_val, y_val),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb4d.csv') # LB\n\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n    'metric': 'rmse',\n    'seed': 0,\n    'nthread': -1,\n    'bagging_fraction': 0.7730681635329509,\n    'colsample_bytree': 0.9440491158187898,\n    'learning_rate': 0.04806809101732328,\n    'min_child_samples': 400,\n    'num_leaves': 69,\n    'reg_alpha': 0.5385150471866715,\n    'reg_lambda': 0.8089922399251372,\n    'subsample_for_bin': 60000\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_val, y_val),\n    5000,\n    valid_sets=lgb.Dataset(X_train, y_train),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb4e.csv') # LB 1.08228, bad","f3c0b68d":"%%time\n\nimport xgboost as xgb\n\nmodel = xgb.train(\n    params={ 'eta': 0.15, 'silent': 1,  },\n    dtrain=xgb.DMatrix(X_train, label=y_train, silent=True),\n    num_boost_round=100,\n    evals=[(xgb.DMatrix(X_val, label=y_val, silent=True), 'test')],\n    early_stopping_rounds=10\n)\n\nto_csv(model.predict(xgb.DMatrix(tmp)), 'xgb4.csv') # LB 1.03369","5bb4827c":"%%time\n\nimport xgboost as xgb\n\nmodel = xgb.train(\n    params={ 'eta': 0.15, 'silent': 1,  },\n    dtrain=xgb.DMatrix(X_val, label=y_val, silent=True), # swap X_train & X_val\n    num_boost_round=100,\n    evals=[(xgb.DMatrix(X_train, label=y_train, silent=True), 'test')],\n    early_stopping_rounds=10\n)\n\nto_csv(model.predict(xgb.DMatrix(tmp)), 'xgb4b.csv') # LB 1.02826","d288ad87":"# simple linear model\nfrom sklearn import linear_model\n\nmodel = linear_model.LinearRegression()\nmodel.fit(X_train, y_train)\nprint(score(model.predict(X_val), y_val))\nto_csv(model.predict(tmp), 'linear_regression4.csv') # LB 1.03363\n\n# repeat again but just swapping the train and val\nmodel = linear_model.LinearRegression()\nmodel.fit(X_val, y_val)\nprint(score(model.predict(X_train), y_train))\nto_csv(model.predict(tmp), 'linear_regression4b.csv') # 1.03111","59296cec":"# Ridge\n\nmodel = linear_model.RidgeCV(alphas=np.logspace(-1, 0, 10), cv=5)\nmodel.fit(X_train, y_train)\nprint(score(model.predict(X_val), y_val))\nto_csv(model.predict(tmp), 'lasso4.csv') # LB 1.03361\n\nmodel = linear_model.RidgeCV(alphas=np.logspace(-1, 0, 10), cv=5)\nmodel.fit(X_val, y_val)\nprint(score(model.predict(X_train), y_train))\nto_csv(model.predict(tmp), 'lasso4b.csv') # LB 1.03111","1d4d15ea":"# Baysian Ridge\n\nmodel = linear_model.BayesianRidge()\nmodel.fit(X_train, y_train)\nprint(score(model.predict(X_val), y_val))\nto_csv(model.predict(tmp), 'BayesianRidge4.csv') # LB 1.03363\n\nmodel = linear_model.BayesianRidge()\nmodel.fit(X_val, y_val)\nprint(score(model.predict(X_train), y_train))\nto_csv(model.predict(tmp), 'BayesianRidge4b.csv') # LB 1.03112","0ab963c3":"# KNN, but this take too long to run, and the LB is bad \n# from sklearn.neighbors import KNeighborsRegressor\n# model = KNeighborsRegressor(n_neighbors=2)\n# model.fit(X_train, y_train)\n# print(score(model.predict(X_val), y_val))\n# to_csv(model.predict(tmp), 'knn4.csv') # LB 1.12914","2cecc571":"from sklearn.model_selection import train_test_split, KFold, cross_val_score\n\n# cv = KFold(n_splits=5, shuffle=True, random_state=0)","aad3a2a8":"tmp = train.pivot_table(index=['shop_id', 'item_id'], columns=['date_block_num'], values='item_cnt_day', aggfunc=np.sum).fillna(0).clip(0, 20)\n\nX_train, X_val, y_train, y_val = train_test_split(tmp[list(range(33))], tmp[33], random_state=0)\n\ntmp = test[['shop_id', 'item_id']].merge(tmp, how='left', on=['shop_id', 'item_id']).fillna(0).loc[:, range(1, 34)].values","6d0847ee":"%%time\n\nimport lightgbm as lgb\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n    'metric': 'rmse',\n    'seed': 0,\n    'nthread': -1,\n}\n\nmodel = lgb.train(\n    params,\n    lgb.Dataset(X_train, y_train),\n    5000,\n    valid_sets=lgb.Dataset(X_val, y_val),\n    early_stopping_rounds=100,\n    verbose_eval=100\n)\n\nto_csv(model.predict(tmp), 'lgb5.csv') # LB 1.05852, no improvement","8018e4d9":"#### Xgb","1018d2c6":"### Trial 5\nSimilar to trial 4, but the X_train and X_val will be split randomly by row instead of by date_block_num","5667a329":"### Trial 3\n\nWe pivot the data, so that columns are date_block_num, row values are item_cnt","c36e30c3":"LightGBM, clip the y_train during training.","b9dd9fb4":"We can also examine the activites of item category.","3a275f83":"### lightGBM\n\nUsing the default parameters","64e61a40":"We can clip the values to 0, 20 during training","fda667d0":"(Work in progress...)\n\nThe first part of this notebook includes exploratory analysis.\n\nThe second part will feature future prediction.","f9d9d104":"Hyperparams tuning for lightbgm models","2b927aeb":"We now want to see the distributions of items and shops in the test set\n- For shop_id, all shop_ids present in the test set are also present in the train set\n- All item_category_id are present in test set and train set.\n- For item_id, there are 363 items present only in the test set but are not in the train set.","6b6ef009":"### XGBoost","3551578d":"### RandomForest\n\nIt takes a long time to run and the results from the default parameters are not great. ","0bba2669":"## Data","100521e6":"## Basic prediction\n\nThe most basic prediction would be to use the result from the previous month. In this case, data from the train set where date_block_num == 33\n\nThis will give a public score of 8.53027, which is really bad.\n\nBut if we clip the item_cnt to 0 ~ 20, the public score will be 1.16777\n\nClipping to -10 ~ 30 gives a public score of 1.23867\n\nNow our goal is to beat the 1.16777","fd0ca098":"Having run the hyperparams optimisation above, we otain the best params and run them as below:","a004e326":"### Shops\n\nThere are 60 shops","901698f8":"We try swapping X_train and X_val during training","3c78d30c":"### Items\n\nThere are 22170 items","d9a03c33":"Similarly, We can examine the activities of individual shops over time.","2e5b8ee5":"### Test set\n214200 entries","635c7d3d":"Now we have date (day, month, year, week, etc) as well as item_id, item_category_id, shop_id. We want to group them and look at the item_cnt_day and item_sale\n\n\nThere is a clear weekly cycle, with more sales on Thu, Fri and Sat\n\nIf we group them by month, we can clearly see that:\n- Dec and Jan had the highest item_cnt_day.\n- Dec also had the highest item_sale (likely Xmas)\n- Nov had the lowest item_cnt_day but Jul had the lowes item_sale\n\nAlso, there are a few peaks over the years, they are:\n- End of Nov 2013, lots of revenues\n- End of Dec 2013, lots of item_cnt_day, but relatively lower item_sale compared to Nov 2013\n- End of Dec 2014, lots of item_cnt_day\n- There are also peaks around the end of May 2014 and 2015\n\nWe also see declines in item_cnt_day and item_sale from 2013 to 2015","cd748b0e":"In total, there were 3.6M items sold, with a combined revenue of \\$3.39 billions.\n\nBy item, the most popular were:\n- By item_cnt_day was: item_id 20949, with 187642 units sold, generated $929K\n- By item_sale was: item_id 6675, worth \\$219M in revenue, with 10289 units sold\n\nThe worst are: item 1590, 11871, 18062, 13474, 13477. Shops lost money on them\n\nBy shop:\n- shop_id 31 had the highest item_cnt_day (310777 items sold), and also the higest item_sale (\\$235M)\n- shop_id 36 had the lowest item_cnt_day (330), with a revenue of \\$377K\n\nItem_category. The most popular:\n- By item_cnt_day is item_category_id 40, with 634171 units sold, generating \\$170M\n- By item_sale is item_category_id 19, with 254887 units sold (\\$412M)\n\nThe worst performers are: item_category_id 51, with only 1 unit sold (\\$129), item_category_id 50, with 3 units sold (\\$24)","b50c168e":"While we are here, we may as well try simpler models such as: linear, Ridge, Bayesian Ridge, and KNN.","3edf047c":"### Trial 4\nWe clip all the values to 0, 20","e5ba56f9":"## Target variable: item_cnt_day\n\nNumber of products sold. We are predicting a monthly amount of this measure.\n\nThe majority of them are just 1 item.\nSome of them are negative (returned items).\nSome of them are over 20 items.\n\nThe maximum is 2169 items, on 28\/10\/2105, shop_id 12, item_id 11373 (Boxberry)\n","6a3793cf":"### date\nConvert from string to datetime type and add year and month column","dd19c52d":"### Train set\n6 features: date, date_block_num, shop_id, item_id, item_price, item_cnt_day\n\n2935849 records","1069eb2c":"### Item categories\n\nThere are 84 categories. They are all in Russian!","335273d4":"Again, we swap X_train and X_val during training","55398df5":"Now we want to explore the correlations between item_cnt_day and item_price. We see that most items do not seem to have a strong correlation of item_cnt_day and item_price","c1969fc9":"We can examine the activities of individual items over time. We can see that some products were popular at the beginning then vanished off. Some products were more popular near the end of the time scale. Some products have peaks at vairous time points.","47013a00":"### Trial 2, use item_cnt up to 6 previous months\n\nInstead of using only previous month item_cnt, we can use more.\n\nBelow, we create a new dataframe, train3 to use item_cnt from previous 6 months","4a32b844":"## Predictor variables\n\nWe are creating a new feature which is item_price \u00d7 item_cnt_day, and call it item_sale\n\nWe will also merge the item_caregory_id from items into the train and test set","c76f2b14":"## Prediction with machine learning\n\nWe are going to try with: RandomForest, lightGBM, XGBoost\n\nFirst, we need to restructure the data and add more features\n\n### Trial 1, add item_cnt from previous month","624f6a36":"Since the defaul paramaters do not give good results, now time for hyperparameter tuning \u2615\ud83c\udf75\n\nWe are going to use hyperopt, a package for automated hyperparameter tuning using Bayesian Optimization (more [details](https:\/\/github.com\/WillKoehrsen\/hyperparameter-optimization)).","d7aead71":"### XGBoost","65995d21":"Now try to run lightGBM again with default parameters","4a713d7a":"We check if each item_id should ONLY belong to 1 item_category_id"}}