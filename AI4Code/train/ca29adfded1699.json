{"cell_type":{"1d717815":"code","6fd5fac6":"code","9dd1a337":"code","c42b7ac4":"code","67f132ec":"code","6bceb86d":"code","a6bebefc":"code","accd05ee":"code","7c3307fe":"code","e8c2d511":"code","a7c426a1":"code","36d6681e":"code","5b99831c":"code","ab4f72a1":"code","ddb75b52":"code","5f69389a":"code","dc309335":"code","df58eed9":"code","ba7737d4":"markdown","5b4ae533":"markdown","7307b0e2":"markdown","56a9c15d":"markdown","0fd1c464":"markdown","29a0247e":"markdown","31d6a23f":"markdown"},"source":{"1d717815":"import torch\nimport torch.optim as optim\nimport torch.nn.functional as F\nimport pandas as pd\nimport numpy as np\nfrom sklearn.preprocessing import MinMaxScaler # For Normalization","6fd5fac6":"device = torch.device(\"cuda\")","9dd1a337":"torch.manual_seed(484)\ntorch.cuda.manual_seed_all(484)","c42b7ac4":"# \ub370\uc774\ud130 \ubd88\ub7ec\uc624\uae30. \ud658\uacbd\uc5d0 \ub530\ub77c \ub2e4\ub97c \uc218 \uc788\uc2b5\ub2c8\ub2e4.\ndir = '\/kaggle\/input\/lol-prediction\/'\n\nx_train = pd.read_csv(dir+'lol.x_train.csv', index_col=0)\ny_train = pd.read_csv(dir+'lol.y_train.csv', index_col=0)\nx_test = pd.read_csv(dir+'lol.x_test.csv', index_col=0)","67f132ec":"x_train.head()","6bceb86d":"y_train.head()","a6bebefc":"x_train = np.array(x_train)\nx_test = np.array(x_test)","accd05ee":"scaler = MinMaxScaler() # Normalizer\nx_train = scaler.fit_transform(x_train)\nx_test = scaler.transform(x_test) # Not Fit Transform!\n\npd.DataFrame(x_train).describe()","7c3307fe":"y_train = np.array(y_train)","e8c2d511":"x_train = torch.FloatTensor(x_train)\ny_train = torch.FloatTensor(y_train)\nx_test = torch.FloatTensor(x_test)","a7c426a1":"from torch.utils.data import TensorDataset\nfrom torch.utils.data import DataLoader","36d6681e":"# \ucee4\uc2a4\ud140 \ub370\uc774\ud130 \uc14b\ntrain_set = TensorDataset(x_train, y_train)","5b99831c":"# 10000 \ud06c\uae30\uc758 \ubc30\uce58\ub85c \ub098\ub204\uc5b4 \ud559\uc2b5\uc2dc\ud0b4\ndata_loader = DataLoader(dataset=train_set,\n                         batch_size=10000,\n                         shuffle=True)","ab4f72a1":"# DNN \ubaa8\ub378 \uad6c\ucd95\nl1 = torch.nn.Linear(48, 32).to(device)\nl2 = torch.nn.Linear(32, 1).to(device)\nrelu = torch.nn.ReLU()\nsigmoid = torch.nn.Sigmoid()\n\nmodel = torch.nn.Sequential(l1, relu, l2, sigmoid)\nmodel","ddb75b52":"cost = torch.nn.BCELoss().to(device)\noptimizer = torch.optim.SGD(model.parameters(), lr=0.1)","5f69389a":"epochs = 60\nfor epoch in range(1, epochs+1):\n    avg_cost = 0\n    total_batch = len(data_loader)\n\n    for x, y in data_loader:    # batch loop\n        x = x.to(device)\n        y = y.to(device)\n\n        optimizer.zero_grad()\n        hypothesis = model(x)\n        cost_val = cost(hypothesis, y)\n        cost_val.backward()\n        optimizer.step()\n\n        avg_cost += cost_val\n    \n    avg_cost \/= total_batch\n\n    if epoch % 10 == 1 or epoch == epochs:\n        print('Epoch {:4d}\/{} Cost: {:.6f}'.format(epoch, epochs, avg_cost.item()))","dc309335":"with torch.no_grad(): # Don't Calculate Gradient\n    x_test = x_test.to(device)\n\n    pred = model(x_test)","df58eed9":"pred[pred>=0.5] = 1.0\npred[pred<=0.5] = 0.0\npred = pred.detach().cpu().numpy()\npred = pred.astype(np.uint32)\nid=np.array([i for i in range(pred.shape[0])]).reshape(-1, 1).astype(np.uint32)\nresult=np.hstack([id, pred])\n\nsubmit = pd.DataFrame(result, columns=['id', 'blueWins'])\nsubmit.to_csv('lol.baseline.csv', index=False)","ba7737d4":"# Train Model\n- \uc774\uc9c4 \uad50\ucc28 \uc5d4\ud2b8\ub85c\ud53c \uc624\ucc28\n- Stochastic Gradient Descent with 0.1 lr","5b4ae533":"# Load Data","7307b0e2":"## Data Loader","56a9c15d":"# Prediction","0fd1c464":"# Build Model","29a0247e":"## Data Normalization\n\uc804\uccb4 \ud589\uc744 0~1\ub85c Normalize","31d6a23f":"# League of Legends Win\/Lose Prediction: BaseLine\nTask: Binary Classification (Logistic Regression)\n\n\ub370\uc774\ud130 \uac00\uacf5: https:\/\/www.kaggle.com\/skyil7\/data-processing-for-regression-tasks"}}