{"cell_type":{"d844b7a2":"code","fe7f4f2a":"code","2cb84943":"code","8dcf022c":"code","0caee991":"code","270416df":"code","cf0fc26b":"code","83e069af":"code","99d2e36e":"code","d6841ba7":"code","e8804599":"code","4deacc87":"code","f844ccfb":"code","309486ce":"code","d10bdd38":"code","b28655cf":"code","39967d90":"code","2fe07f7c":"code","d7f081c7":"code","a282fdf1":"code","1ac7b112":"code","66a0b457":"code","e7e0f282":"code","fdc8e4af":"code","8d57130f":"code","4c7b4158":"code","8f1fd3a1":"code","039ad724":"code","fc2dc12a":"code","3f912ade":"code","dc43cdfd":"code","85a3e630":"code","be1fabca":"code","8b2ebfc3":"code","e4c57f90":"code","ff702108":"code","2ce1a720":"code","17c5cbf7":"code","bae05f70":"code","219318a8":"code","a51064e8":"code","35f704fc":"code","3598c747":"code","abfccf2a":"code","47085148":"code","f3de4a24":"code","ea3837c0":"code","2118dde8":"code","992a8b6b":"code","f2eea2f9":"code","ff8779ea":"code","42cb9dc3":"code","1cbecc9c":"code","7ca1a77d":"code","711966d7":"code","8e2c7b2b":"code","e2c8a793":"code","d909f257":"code","eb521bbf":"code","05bfc73c":"code","c7ab4333":"code","e680e84c":"code","52e29a37":"code","e5424a37":"code","3790022d":"code","bfd8940b":"code","c55082ba":"code","56fd3f8d":"code","33d6426b":"code","64f955d4":"code","d37ea1b0":"code","9eeba833":"code","f6af3c28":"code","1c1fa9f9":"code","74b20869":"code","475ab5d2":"code","4f911393":"code","acb274cd":"code","519e6e42":"code","c50fc423":"code","43acd785":"code","e8577e51":"code","20deaefa":"code","283d84af":"code","8dd7c918":"code","26e7282d":"code","ea6eea2f":"code","ce2fe1b7":"code","b02d8d78":"code","38a7c682":"code","99db98cb":"code","2646550a":"code","f476af23":"code","5af3c9de":"code","a08c33eb":"code","2ce8bd7c":"code","c21ef702":"code","06734010":"code","79ec086c":"code","93ffa568":"code","4bedd282":"code","a74d371b":"code","44fa29c5":"code","d6dbcb44":"code","f0a6f851":"code","b4b26fb4":"code","b8221dcc":"code","95c15d99":"code","439c9e6a":"code","f7275114":"code","2b8404d8":"code","ccb8210b":"code","6a590015":"code","d1ad765b":"code","0773f531":"code","441b19eb":"code","dcfb6765":"code","6781b90b":"code","d0704e16":"code","dce98045":"code","b1f72fb4":"markdown","e8ff0104":"markdown","97473365":"markdown","7334d7b1":"markdown","765d09f0":"markdown","280abccf":"markdown","450251a0":"markdown","20bf01fc":"markdown","63d95dee":"markdown","082d2bdf":"markdown","e16af5cb":"markdown","8e9a662b":"markdown","94b41344":"markdown","9535c225":"markdown","7cc9ee83":"markdown","cbaa6396":"markdown","e2f5c173":"markdown","62d4d96a":"markdown","a5afd91d":"markdown","ed531745":"markdown","424f3640":"markdown","0cb7b626":"markdown","326361d2":"markdown","34aacbf8":"markdown","5422abd4":"markdown","f57cf9a2":"markdown","68c445e0":"markdown","57701771":"markdown","e5b16a7d":"markdown","cde2eeba":"markdown","6beba587":"markdown","7a014037":"markdown","2ec77ae7":"markdown","fa2c4e1f":"markdown","6b810c58":"markdown","e118646b":"markdown","1c977e54":"markdown","e69fc9a5":"markdown","530ad4ca":"markdown","cf22a283":"markdown","a0ceec72":"markdown","8fb49685":"markdown","432ee34e":"markdown","18070962":"markdown","a802c91e":"markdown","38f52eb1":"markdown","7994ae68":"markdown","99f064f9":"markdown","36a77631":"markdown","6f88a037":"markdown","9c63b8ab":"markdown","76fbc3ef":"markdown","fd0c1ced":"markdown","cf45288a":"markdown"},"source":{"d844b7a2":"#!pip -q install --upgrade --ignore-installed numpy pandas scipy sklearn seaborn\n!pip -q install SWMat # You will find out about it in post","fe7f4f2a":"import seaborn as sns\nsns.__version__","2cb84943":"from SWMat.SWMat import SWMat","8dcf022c":"import matplotlib.pyplot as plt\nimport seaborn as sns","0caee991":"import pandas as pd\nimport numpy as np","270416df":"import warnings\nwarnings.filterwarnings(\"ignore\")","cf0fc26b":"from sklearn.datasets import california_housing\n\ndata = california_housing.fetch_california_housing()","83e069af":"data.keys()","99d2e36e":"print(data['DESCR'])","d6841ba7":"X = data['data']\ny = data['target']\ncolumns = data['feature_names']","e8804599":"train_df = pd.DataFrame(X, index=np.arange(len(X)), columns=columns)\ntrain_df['target'] = y\ntrain_df.head()","4deacc87":"N, X, _ = plt.hist(train_df['target'], bins=5, ec='w') # 'ec' (edgecolors) for outline\nX = 0.5*(X[1:]+ X[:-1])\n_ = plt.plot(X, N, '-*', color='orange')","f844ccfb":"from matplotlib.pyplot import figure\nfigure(figsize=(8, 6))\n\ntrain_df['target'].plot.kde(label=\"Density Plot\", color='b') # Or you can use gaussian_kde from scipy.stats as given here: https:\/\/realpython.com\/python-histograms\/\n_ = plt.hist(train_df['target'], bins=10, color='lightblue', label='target', density=True, ec='black')\nplt.legend()\nplt.title(\"Target Histogram\")\nplt.xlabel(\"Target Bins\")\nplt.ylabel(\"Probability\");","309486ce":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\n_ = sns.distplot(train_df['target'], rug=True, hist_kws={'ec':'lightblue', 'color':'blue', 'label':'hist'}, \n                 kde_kws={'color':'b', 'label':'density'}, rug_kws={'color':'orange', 'height':0.02, 'label': 'rug plot'})\nplt.legend();","d10bdd38":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\ntemp = train_df['target'].plot.kde(label=\"Density Plot\", color='b') # Or you can use gaussian_kde from scipy.stats as given here: https:\/\/realpython.com\/python-histograms\/\n_ = plt.hist(train_df['target'], bins=10, color='lightblue', label='target', density=True, ec='white')\nplt.legend()\nplt.title(\"Making Data Talk\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\nplt.xlabel(\"Target Bins\")\nplt.ylabel(\"Probability\")\nplt.text(2.5, 0.3, \"We have a Bi-modal Distribution\\nfor Target variable, with\\nmost Blocks having Target\\nvalue around 1.6 and 5.\", fontsize=14,\n            bbox={'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.5, 'pad': 4})\nplt.scatter([1.6, 5], [0.435, 0.134], s=1500, c='orange', alpha=0.5)\n\nfor p in _[2]:\n    p.set_zorder(0)","b28655cf":"swm = SWMat(plt)\nswm.hist(train_df['target'], bins=10, highlight=[2, 9])\nswm.title(\"Carefully looking at the dependent variable revealed some problems that might occur!\")\nswm.text(\"Target is a bi-modal dependent feature.\\nIt can be <prop fontsize='18' color='blue'> hard to predict.<\\prop>\",btw_text_dist=.5);","39967d90":"from matplotlib.pyplot import figure\nfigure(figsize=(15, 10))\n\nplt.hist(train_df['MedInc'], bins=50, density=True, alpha=0.5, label=\"MedInc\")\nplt.hist(train_df['HouseAge'], bins=50, density=True, alpha=0.5, label=\"HouseAge\")\nplt.hist(train_df['AveRooms'], bins=90, density=True, alpha=0.5, label=\"AveRooms\")\nplt.axis([0, 53, 0, 0.305])\nplt.legend(frameon=False, loc='upper center', ncol=3, fontsize=14);","2fe07f7c":"fig, axs = plt.subplots(1, 4, figsize=(50, 10))\n\nN, X, _ = axs[0].hist(train_df['target'], bins=5, ec='w')\nX = 0.5*(X[1:]+ X[:-1])\naxs[0].plot(X, N, '-*', color='orange')\naxs[0].set_title(\"Normal\", fontdict={'fontsize': 19}, pad=15)\n\nsns.distplot(train_df['target'], rug=True, hist_kws={'ec':'lightblue', 'color':'blue', 'label':'hist'}, \n                 kde_kws={'color':'b', 'label':'density'}, ax=axs[1])\naxs[1].legend()\naxs[1].set_title(\"Seaborn\", fontdict={'fontsize': 19}, pad=15)\n\ntrain_df['target'].plot.kde(label=\"Density Plot\", color='b', ax=axs[2]) # Or you can use gaussian_kde from scipy.stats as given here: https:\/\/realpython.com\/python-histograms\/\nht = axs[2].hist(train_df['target'], bins=10, color='lightblue', label='target', density=True, ec='white')\naxs[2].legend()\naxs[2].set_title(\"Matplotlib Power\", fontdict={'fontsize': 19}, pad=15)\naxs[2].set_xlabel(\"Target Bins\")\naxs[2].set_ylabel(\"Probability\")\naxs[2].text(2.5, 0.3, \"We have a Bi-modal Distribution\\nfor Target variable, with\\nmost Blocks having Target\\nvalue around 1.6 and 5.\", fontsize=14,\n            bbox={'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.5, 'pad': 4})\naxs[2].scatter([1.6, 5], [0.435, 0.134], s=1500, c='orange', alpha=0.5)\nfor p in ht[2]:\n    p.set_zorder(0)\n    \nswm = SWMat(plt, ax=axs[3])\nswm.hist(train_df['target'], bins=10, highlight=[2, 9])\nswm.title(\"Carefully looking at the dependent variable revealed some problems that might occur!\")\nswm.text(\"Target is a bi-modal dependent feature.\\nIt can be <prop fontsize='18' color='blue'> hard to predict.<\\prop>\",btw_text_dist=.5, btw_line_dist=.7);","d7f081c7":"from matplotlib.pyplot import figure\nfigure(figsize=(14, 10))\n\nN, bins, patches = plt.hist(train_df['target'], bins=50, density=True, label=\"Target\")\n# For Density plot:\ntrain_df['target'].plot.kde(label=\"Density Plot\", color=\"b\") # As we increase number of bins, our plot will look more and more like density plot\n\n# For more on histogram with density plots look here: https:\/\/towardsdatascience.com\/histograms-and-density-plots-in-python-f6bda88f5ac0\n# For Grid (for better mapping of heights)\nplt.grid(axis='y', alpha=0.75)\n# Add lines for mean, median and mode:\nplt.vlines(x=train_df['target'].mean(), ymin=0, ymax=0.7, colors='green', linestyle='dashdot', label='mean')\nplt.vlines(x=train_df['target'].median(), ymin=0, ymax=0.7, colors='red', linestyle='dashed', label='median')\nplt.vlines(x=train_df['target'].mode(), ymin=0, ymax=0.7, colors='blue', linestyle='dotted', label='mode')\n# Add text for lines above: (https:\/\/predictablynoisy.com\/matplotlib\/tutorials\/text\/text_intro.html)\nplt.text(x=train_df['target'].mean()+0.03, y=0.6, s='mean', color='green', bbox={'alpha': 0.1, 'pad': 2})\nplt.text(train_df['target'].median()-0.68, 0.6, 'median', color='red', bbox={'alpha': 0.1, 'pad': 2})\nplt.text(train_df['target'].mode()-0.5, 0.6, 'mode', color='blue', bbox={'alpha': 0.1, 'pad': 2})\n\n################################## For colored bins #######################################\n# You can ignore this, but using this way you can map your data to a color palette.\nfrom matplotlib import colors\nnorm = colors.Normalize(N.min(), N.max()) # For mapping whole range values to a colorbar.\n\nfor freq, thispatch in zip(N, patches):\n    color = plt.cm.inferno_r(norm(freq), alpha=0.85) # Pick a color from a palette (here, inferno_r) based on a value between [0, 1]\n    thispatch.set_facecolor(color) # set color of current patch\n    thispatch.set_alpha(0.5)\n# From here: https:\/\/matplotlib.org\/gallery\/statistics\/hist.html\n##################################     End (1)     ########################################\n\nplt.legend()\nplt.xlabel(\"Target  ->\", fontdict={'fontsize': 12,'fontweight': 5})\nplt.ylabel(\"Density  ->\", fontdict={'fontsize': 12,'fontweight': 5})\nplt.title(\"Target Distribution\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\n\n## Adding colorbar: (you can ignore this too)\n# Form here: https:\/\/stackoverflow.com\/questions\/43805821\/matplotlib-add-colorbar-to-non-mappable-object\nimport matplotlib as mpl\ncmap = plt.get_cmap('inferno_r', 20)\nnorm = mpl.colors.Normalize(vmin=0,vmax=0.6)\nsm = plt.cm.ScalarMappable(cmap=cmap, norm=norm) # colorbar needs a Mappable. Contour, Scatter and hist2d gives them by default. There you can simply call plt.colorbar()\nsm.set_array([])\ncb = plt.colorbar(sm, ticks=np.linspace(0,0.6,20))\ncb.set_label(\"Normal density  ->\");","a282fdf1":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.plot('AveRooms', 'AveBedrms', data=train_df.sort_values('AveRooms'), label=\"Average Bedrooms\")\n\nplt.legend()\nplt.title(\"Average Rooms vs Average Bedrooms\")\nplt.xlabel(\"Avg Rooms  ->\")\nplt.ylabel(\"Avg BedRooms  ->\");","1ac7b112":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.scatter('AveRooms', 'AveBedrms', data=train_df)\nplt.plot('AveRooms', 'AveBedrms', data=train_df.sort_values('AveRooms'))\n\nplt.xlabel(\"Avg Rooms  ->\")\nplt.ylabel(\"Avg BedRooms  ->\");","66a0b457":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nsorted_df = train_df.sort_values('AveRooms')\n\nplt.scatter('AveRooms', 'AveBedrms', data=train_df, c='lightgreen')\nplt.scatter('AveRooms', 'AveBedrms', data=train_df[(train_df['AveRooms']>20)], c='y', alpha=0.7)\nplt.scatter('AveRooms', 'AveBedrms', data=train_df[(train_df['AveRooms']>50)], c='r', alpha=0.7)\nplt.plot('AveRooms', 'AveBedrms', data=sorted_df, c='lightgreen')\nplt.plot('AveRooms', 'AveBedrms', data=sorted_df[(sorted_df['AveRooms']>20)], c='yellow', alpha=0.7)\nplt.plot('AveRooms', 'AveBedrms', data=sorted_df[(sorted_df['AveRooms']>50)], c='red', alpha=0.7)\n\n\nplt.title(\"Average Rooms vs Average Bedrooms\")\nplt.xlabel(\"Avg Rooms  ->\")\nplt.ylabel(\"Avg BedRooms  ->\");","e7e0f282":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nsorted_df = train_df.sort_values('AveRooms')\n\nplt.plot('AveRooms', 'AveBedrms', data=sorted_df, c='lightgreen')\nplt.plot('AveRooms', 'AveBedrms', data=sorted_df[(sorted_df['AveRooms']>20)], c='yellow', alpha=0.7)\nplt.plot('AveRooms', 'AveBedrms', data=sorted_df[(sorted_df['AveRooms']>50)], c='red', alpha=0.7)\n\n# Adding text:\nplt.text(40, 2.5, \"Most Blocks have average less than\\n5 bed rooms and 20 rooms.\", fontsize=14,\n        bbox={'facecolor': 'lightgreen', 'edgecolor': 'lightgreen', 'pad': 4})\n\nplt.title(\"Average Rooms vs Average Bedrooms\")\nplt.xlabel(\"Avg Rooms  ->\")\nplt.ylabel(\"Avg BedRooms  ->\");","fdc8e4af":"sorted_df = train_df.sort_values('AveRooms', na_position='first').reset_index(drop=True) # reset is necessary, otherwise original Series will be passed.","8d57130f":"swm = SWMat(plt)\n\nswm.line_plot(sorted_df['AveRooms'], sorted_df['AveBedrms'], line_labels=[\"Average Bedrooms\"], highlight=0, \n              label_points_after=60, xlabel=\"Average Rooms\", highlight_label_region_only=True, point_label_dist=0.9)\nswm.title(\"There are some possible outliers in 'AveRooms' and 'AveBedrms'!\", ttype=\"title+\")\nswm.text(\"This may affect our results. We should\\ncarefully look into these and <prop color='blue'>find a\\n possible resolution.<\\prop>\", \n         position=\"out-mid-right\", fontsize=20, btw_line_dist=2.5, btw_text_dist=2);","4c7b4158":"fig, axs = plt.subplots(1, 4, figsize=(40, 8))\nfig.suptitle(\"Line Plots\", fontsize=28)\n\naxs[0].plot('AveRooms', 'AveBedrms', data=train_df.sort_values('AveRooms'), label=\"Average Bedrooms\")\naxs[0].legend()\naxs[0].set_title(\"Normal\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[0].set_xlabel(\"Average Rooms  ->\")\naxs[0].set_ylabel(\"Average BedRooms  ->\")\n\nsns.lineplot(x='AveRooms', y='AveBedrms', data=train_df, ax=axs[1])\naxs[1].set_title(\"Seaborn\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\n\na = axs[2].plot('AveRooms', 'AveBedrms', data=sorted_df, c='lightgreen', label = \"Normal\")\nb = axs[2].plot('AveRooms', 'AveBedrms', data=sorted_df[(sorted_df['AveRooms']>20)], c='yellow', alpha=0.7, label=\"High\")\nc = axs[2].plot('AveRooms', 'AveBedrms', data=sorted_df[(sorted_df['AveRooms']>50)], c='red', alpha=0.7, label=\"Very High\")\naxs[2].set_title(\"Matplotlib Power\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\n########################### Adding manual legends ########################################\naxs[2].legend(handles=[a[0], b[0], c[0]], ncol=1, frameon=False, fontsize='large')\n##########################################################################################\naxs[2].text(40, 2.5, \"Most Blocks have on average less than\\n5 bed rooms and 20 rooms.\", fontsize=14,\n        bbox={'facecolor': 'lightgreen', 'edgecolor': 'lightgreen', 'pad': 4})\naxs[2].set_xlabel(\"Average Rooms  ->\")\naxs[2].set_ylabel(\"Average BedRooms  ->\")\n\nswm = SWMat(plt, ax=axs[3])\n\nswm.line_plot(sorted_df['AveRooms'], sorted_df['AveBedrms'], line_labels=[\"Average Bedrooms\"], highlight=0, label_points_after=60,\n            xlabel=\"Average Rooms\", highlight_label_region_only=True, point_label_dist=0.9, hide_y=True)\nswm.title(\"There are some possible outliers in 'AveRooms' and 'AveBedrms'!\", ttype=\"title+\")\nswm.text(\"This may affect our results. We should\\ncarefully look into these and, <prop color='blue'>find a\\n possible resolution.<\\prop>\", \n         position=\"out-mid-right\", fontsize=20, btw_line_dist=2.5, btw_text_dist=2);","8f1fd3a1":"# For fitting a linear line:\nfrom numpy.polynomial.polynomial import polyfit\n\nconst, slope = polyfit(train_df['AveRooms'], train_df['AveBedrms'], deg=1)\nY = train_df['AveRooms']*slope + const","039ad724":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.scatter('AveRooms', 'AveBedrms', data=train_df.sort_values('AveRooms'), edgecolors='w', linewidths=0.1)\n\nplt.legend()\nplt.title(\"Scatter Plot of Average Rooms and Average Bedrooms\")\nplt.xlabel(\"Average Bedrooms  ->\")\nplt.ylabel(\"Average Rooms  ->\");","fc2dc12a":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.scatter('AveRooms', 'AveBedrms', data=train_df.sort_values('AveRooms'), edgecolors='w', linewidth=0.2)\nplt.plot(train_df['AveRooms'], Y, linewidth=1, color='red', linestyle='-', alpha=0.8)\n\nplt.xlabel(\"Avg Rooms  ->\")\nplt.ylabel(\"Avg BedRooms  ->\")\n\n# Adding annotations:\nplt.annotate(\"Possible outliers\", xy=(144, 31), xytext=(160, 34),\n             arrowprops={'arrowstyle':'-[,widthB=4.0', 'color': 'black'},\n             bbox={'pad':4, 'edgecolor':'orange', 'facecolor':'orange', 'alpha':0.4})\n\nplt.annotate(\"Regression Line\", xy=(80, 12), xytext=(120, 3),\n             arrowprops={'arrowstyle':'->', 'color': 'black', \"connectionstyle\":\"arc3,rad=-0.2\"},\n             bbox={'pad':4, 'edgecolor':'orange', 'facecolor':'orange', 'alpha':0.4})\nplt.show()","3f912ade":"sample = train_df.sample(frac=0.5) # Gaussian Process taking too much memory...","dc43cdfd":"from sklearn.gaussian_process import GaussianProcessRegressor\n\ngp = GaussianProcessRegressor()","85a3e630":"%%time\n\nprint(\"Fitting...\")\ngp.fit(sample['AveRooms'].values.reshape(-1, 1), sample['AveBedrms'].values)\nprint(\"Fitting Complete.\")\n\nprint(\"Predicting...\")\nx = np.linspace(0, 145, 146)\npreds, std = gp.predict(x.reshape(-1, 1), return_std=True)\nprint(\"Predicted.\")\n\n# For 95% confidence interval:\ndelta = 1.96*std","be1fabca":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.scatter('AveRooms', 'AveBedrms', data=train_df.sort_values('AveRooms'))#, edgecolors='w')\nplt.plot(train_df['AveRooms'], Y, linewidth=1, color='red', linestyle='-', alpha=0.8)\n\nplt.xlabel(\"Avg Rooms  ->\")\nplt.ylabel(\"Avg BedRooms  ->\")\n\n# Adding annotations:\nplt.annotate(\"Possible outliers\", xy=(144, 31), xytext=(160, 34),\n             arrowprops={'arrowstyle':'-[,widthB=4.0', 'color': 'black'},\n             bbox={'pad':4, 'edgecolor':'orange', 'facecolor':'orange', 'alpha':0.4})\n\nplt.annotate(\"Regression Line\", xy=(80, 12), xytext=(120, 3),\n             arrowprops={'arrowstyle':'->', 'color': 'black', \"connectionstyle\":\"arc3,rad=-0.2\"},\n             bbox={'pad':4, 'edgecolor':'orange', 'facecolor':'orange', 'alpha':0.4})\n\n# For confidence interval:\nplt.fill_between(x, preds-delta, preds+delta, color='gray', alpha=0.4)\nplt.ylim(0, 35);","8b2ebfc3":"swm = SWMat(plt)\nplt.scatter('AveRooms', 'AveBedrms', data=train_df.sort_values('AveRooms'), edgecolors='w', linewidths=0.3)\nswm.line_plot(train_df['AveRooms'], Y, highlight=0, alpha=0.7, line_labels=[\"Regression Line\"])\nswm.title(\"'AveBedrms' and 'AveRooms' are highly correlated!\", ttype=\"title+\")\nswm.text(\"Taking both of them in regressioin process\\nmight not be necessary. We can either\\n<prop color='blue'>take one of them<\/prop> or <prop color='blue'>take average.<\/prop>\",\n         position='out-mid-right', btw_line_dist=5)\nswm.axis(labels=[\"Average Rooms\", \"Average Bedrooms\"])","e4c57f90":"fig, axs = plt.subplots(1, 4, figsize=(40, 8))\nfig.suptitle(\"Scatter Plots\", fontsize=28)\n\naxs[0].scatter('AveRooms', 'AveBedrms', data=train_df.sort_values('AveRooms'), edgecolors='w', linewidths=0.3)\naxs[0].set_title(\"Normal\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[0].set_xlabel(\"Average Bedrooms  ->\")\naxs[0].set_ylabel(\"Average Rooms  ->\")\n\nsns.regplot(x='AveRooms', y='AveBedrms', data=train_df, label=\"Average Bedrooms\", ax=axs[1])\naxs[1].set_title(\"Seaborn (regplot)\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\n\n##################### For colors in scatter plot #################################\ndiff = (train_df['AveBedrms'] - Y).abs()\ncolors = []\nfor i in range(len(diff)):\n  if diff[i] <= 0.17: colors.append('g')\n  elif diff[i] > 0.17 and diff[i] <= 2: colors.append('y')\n  else: colors.append('r')\ntrain_df['colors'] = colors\nsorted_df = train_df.sort_values('AveRooms')\n##################################################################################\nsct = axs[2].scatter('AveRooms', 'AveBedrms', data=sorted_df, c=sorted_df['colors'])\ndel train_df['colors']\naxs[2].plot(train_df['AveRooms'], Y, linewidth=1, color='red', linestyle='-', alpha=0.8)\naxs[2].set_title(\"Matplotlib Power\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[2].set_xlabel(\"Avg Rooms  ->\")\naxs[2].set_ylabel(\"Avg BedRooms  ->\")\n###################### Setting legend manually ###################################\none = axs[2].scatter([], [], c='g', label='Low Residual')\ntwo = axs[2].scatter([], [], c='y', label='Med. Residual')\nthree = axs[2].scatter([], [], c='r', label='High Residual')\naxs[2].legend(handles=[one, two, three],)\n##################################################################################\n# Adding annotations:\naxs[2].annotate(\"Possible outliers\", xy=(144, 31), xytext=(150, 34),\n             arrowprops={'arrowstyle':'-[,widthB=4.0', 'color': 'black'},\n             bbox={'pad':4, 'edgecolor':'orange', 'facecolor':'orange', 'alpha':0.4})\naxs[2].annotate(\"Regression Line\", xy=(80, 12), xytext=(120, 3),\n             arrowprops={'arrowstyle':'->', 'color': 'black', \"connectionstyle\":\"arc3,rad=-0.2\"},\n             bbox={'pad':4, 'edgecolor':'orange', 'facecolor':'orange', 'alpha':0.4})\naxs[2].text(26, 25, \"We have a nearly linear\\nrelationship between\\nAverage rooms and Average bed\\nRooms.\", fontsize=16,\n           bbox={'facecolor': 'orange', 'edgecolor': 'orange', 'pad': 4, 'alpha': 0.4});\n\n\nswm = SWMat(plt, ax=axs[3])\naxs[3].scatter('AveRooms', 'AveBedrms', data=train_df.sort_values('AveRooms'), edgecolors='w', linewidths=0.3)\nswm.line_plot(train_df['AveRooms'], Y, highlight=0, alpha=0.7, line_labels=[\"Regression Line\"])\nswm.title(\"'AveBedrms' and 'AveRooms' are highly correlated!\", ttype=\"title+\")\nswm.text(\"Taking both of them in regressioin process\\nmight not be necessary. We can either\\n<prop color='blue'>take one of them<\/prop> or <prop color='blue'>take average.<\/prop>\",\n         position='out-mid-right', btw_line_dist=5)\nswm.axis(labels=[\"Average Rooms\", \"Average Bedrooms\"])","ff702108":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\n#sns.lineplot(x='AveRooms', y='AveBedrms', data=train_df)\nsns.scatterplot(x='AveRooms', y='AveBedrms', data=train_df, label=\"Average Bedrooms\");","2ce1a720":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nsns.regplot('AveRooms', 'AveBedrms', data=train_df);","17c5cbf7":"train_df['target_int'] = train_df['target']\ntrain_df.loc[(train_df['target'] < 1), 'target_int'] = 0\ntrain_df.loc[(train_df['target'] >= 1) & (train_df['target'] < 2), 'target_int'] = 1\ntrain_df.loc[(train_df['target'] >= 2) & (train_df['target'] < 3), 'target_int'] = 2\ntrain_df.loc[(train_df['target'] >=3) & (train_df['target'] < 4), 'target_int'] = 3\ntrain_df.loc[(train_df['target'] >= 4), 'target_int'] = 4","bae05f70":"sns.lmplot('AveRooms', 'AveBedrms', hue='target_int', data=train_df, height=10); # There are many options available here, like row, col etc. You should look into them.","219318a8":"del train_df['target_int']","a51064e8":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\n\nplt.scatter('Latitude', 'target', data=train_df, edgecolors='w', alpha=0.7)\n\nplt.margins(0)\nplt.suptitle(\"Latitude vs Target\", fontsize=19, fontweight=0.5)\nplt.xlabel('Latitude  ->')\nplt.ylabel('Target  ->');","35f704fc":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\n# For filling regions:\nplt.fill_betweenx([0, 5.1], x1=32.5, x2=35.5, facecolor='red', alpha=0.7, edgecolor='w')\nplt.fill_betweenx([0, 5.1], x1=35.5, x2=36.5, facecolor='green', alpha=0.7, edgecolor='w')\nplt.fill_betweenx([0, 5.1], x1=36.5, x2=39.5, facecolor='red', alpha=0.7, edgecolor='w',)\nplt.fill_betweenx([0, 5.1], x1=39.5, x2=42, facecolor='green', alpha=0.7, edgecolor='w')\n\n# Arrow message:\nplt.annotate(\"Mainly near target = 1\", xy=(40, 1), xytext=(40.05, 2.5),\n            arrowprops=dict(arrowstyle='->', facecolor='black'),\n            verticalalignment='top', bbox={'facecolor':'orange', 'alpha':0.7, 'pad':2, 'edgecolor': 'orange'})\nplt.annotate(\"\", xy=(36, 1), xytext=(40.95, 2.3),\n            arrowprops=dict(arrowstyle='->', facecolor='black'))\n\nplt.scatter('Latitude', 'target', data=train_df, edgecolors='w', alpha=0.7)\n\nplt.box(False)\nplt.margins(0)\nplt.legend(['All over the place!', 'Mainly near target = 1'])\nplt.suptitle(\"Latitude vs Target\", fontsize=19, fontweight=0.5)\nplt.title(\"(Green region is mainly near target = 1)\", pad=6)\nplt.xlabel('Latitude  ->')\nplt.ylabel('target  ->');","3598c747":"# Or you could have done something like this:\nfrom matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\n# Arrow message:\n#plt.annotate(\"Mainly near target = 1\", xy=(40, 1), xytext=(40.05, 2.5),\n#            arrowprops=dict(arrowstyle='->', facecolor='black'),\n#            verticalalignment='top', bbox={'facecolor':'orange', 'alpha':0.7, 'pad':2, 'edgecolor': 'orange'})\n#plt.annotate(\"\", xy=(36, 1), xytext=(40.95, 2.3),\n#            arrowprops=dict(arrowstyle='->', facecolor='black'))\n\nplt.scatter(train_df.loc[(train_df['Latitude']<35.5), 'Latitude'], train_df.loc[(train_df['Latitude']<35.5), 'target'], edgecolors='w', alpha=0.7, c='red')\nplt.scatter(train_df.loc[(train_df['Latitude']>=35.5) & (train_df['Latitude']<36.5), 'Latitude'], \n            train_df.loc[(train_df['Latitude']>=35.5) & (train_df['Latitude']<36.5), 'target'], \n            edgecolors='w', alpha=0.7, c='green')\nplt.scatter(train_df.loc[(train_df['Latitude']>=36.5) & (train_df['Latitude']<39.5), 'Latitude'], \n            train_df.loc[(train_df['Latitude']>=36.5) & (train_df['Latitude']<39.5), 'target'], \n            edgecolors='w', alpha=0.7, c='red')\nplt.scatter(train_df.loc[(train_df['Latitude']>39.5), 'Latitude'], train_df.loc[(train_df['Latitude']>39.5), 'target'], edgecolors='w', alpha=0.7, c='green')\n\nplt.margins(0)\nplt.legend(['All over the place!', 'Mainly near target = 1'])\nplt.suptitle(\"Latitude vs Target\", fontsize=19, fontweight=0.5)\nplt.title(\"(Green region is mainly near target = 1)\", pad=6)\nplt.xlabel('Latitude  ->', fontsize=12)\nplt.ylabel('target  ->', fontsize=12);","abfccf2a":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\n# For filling regions:\nplt.fill_betweenx([0, 5.1], x1=-124.5, x2=-123, facecolor='green', alpha=0.7, edgecolor='w')\nplt.fill_betweenx([0, 5.1], x1=-123, x2=-116.6, facecolor='red', alpha=0.7, edgecolor='w')\n#plt.fill_betweenx([0, 5.1], x1=-121.5, x2=-120, facecolor='green', alpha=0.7, edgecolor='w')\n#plt.fill_betweenx([0, 5.1], x1=-120, x2=-116.6, facecolor='red', alpha=0.7, edgecolor='w')\nplt.fill_betweenx([0, 5.1], x1=-116.6, x2=-114, facecolor='green', alpha=0.7, edgecolor='w')\n\n# Arrow message:\n#plt.annotate(\"Mainly near target = 1\", xy=(40, 1), xytext=(40.05, 2.5),\n#            arrowprops=dict(arrowstyle='->', facecolor='black'),\n#            verticalalignment='top', bbox={'facecolor':'orange', 'alpha':0.7, 'pad':2, 'edgecolor': 'orange'})\n#plt.annotate(\"\", xy=(36, 1), xytext=(40.95, 2.3),\n#            arrowprops=dict(arrowstyle='->', facecolor='black'))\n\nplt.scatter('Longitude', 'target', data=train_df, edgecolors='w', alpha=0.7)\n\nplt.box(False)\nplt.margins(0)\nplt.legend(['Mainly near target = 1', 'All over the place!'])\nplt.suptitle(\"Longitude vs Target\", fontsize=19, fontweight=0.5)\nplt.title(\"(Green region is mainly near target = 1)\", pad=6)\nplt.xlabel('Longitude  ->')\nplt.ylabel('target  ->');","47085148":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\n# Colors from RdBu palette\nplt.scatter(train_df.loc[(train_df['target']<1), 'Latitude'], train_df.loc[(train_df['target']<1), 'Longitude'], c='#D1E5F0', alpha=0.7, edgecolors='w')\nplt.scatter(train_df.loc[(train_df['target']>=1) & (train_df['target']<2), 'Latitude'], \n            train_df.loc[(train_df['target']>=1) & (train_df['target']<2), 'Longitude'], c='#FDDBC7', alpha=0.7, edgecolors='w')\nplt.scatter(train_df.loc[(train_df['target']>=2) & (train_df['target']<3), 'Latitude'], \n            train_df.loc[(train_df['target']>=2) & (train_df['target']<3), 'Longitude'], c='#F4A582', alpha=0.7, edgecolors='w')\nplt.scatter(train_df.loc[(train_df['target']>=3) & (train_df['target']<4), 'Latitude'], \n            train_df.loc[(train_df['target']>=3) & (train_df['target']<4), 'Longitude'], c='#D6604D', alpha=0.7, edgecolors='w')\nplt.scatter(train_df.loc[(train_df['target']>=4), 'Latitude'], train_df.loc[(train_df['target']>=4), 'Longitude'], c='#B2182B', alpha=0.7, edgecolors='w');\n\n# Text:\nplt.text(x=35, y=-114.5, s=\"California's Map with Target locations\", fontsize=14, bbox={'facecolor': 'white'})\n\nplt.suptitle(\"Latitude vs Longitude with Target\", fontsize=18)\nplt.legend([\"0-1\", \"1-2\", \"2-3\", \"3-4\", \"4-\"], title='target')\nplt.xlabel(\"Latitude  ->\")\nplt.ylabel(\"Longitude  ->\");","f3de4a24":"# This one is easy with seaborn:\nfrom matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\n_ = sns.scatterplot('Latitude', 'Longitude', hue='target', data=train_df, palette=\"RdBu_r\")","ea3837c0":"fig, axs = plt.subplots(2, 3, figsize=(20, 10))\n\n_ = sns.scatterplot('Latitude', 'Longitude', hue='MedInc', data=train_df, palette=\"RdBu_r\", ax=axs[0][0])\n_ = sns.scatterplot('Latitude', 'Longitude', hue='HouseAge', data=train_df, palette=\"RdBu_r\", ax=axs[0][1])\n_ = sns.scatterplot('Latitude', 'Longitude', hue='AveRooms', data=train_df, palette=\"RdBu_r\", ax=axs[0][2])\n_ = sns.scatterplot('Latitude', 'Longitude', hue='AveBedrms', data=train_df, palette=\"RdBu_r\", ax=axs[1][0])\n_ = sns.scatterplot('Latitude', 'Longitude', hue='Population', data=train_df, palette=\"RdBu_r\", ax=axs[1][1])\n_ = sns.scatterplot('Latitude', 'Longitude', hue='AveOccup', data=train_df, palette=\"RdBu_r\", ax=axs[1][2])","2118dde8":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.hist2d('MedInc', 'target', bins=40, data=train_df)\nplt.xlabel('Median Income  ->')\nplt.ylabel('Target  ->')\nplt.suptitle(\"Median Income vs Target\", fontsize=18);","992a8b6b":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n \nplt.hist2d('MedInc', 'target', bins=40, data=train_df, cmap='gist_heat_r') \nplt.colorbar()\nplt.xlabel('Median Income  ->')\nplt.ylabel('Target  ->')\nplt.suptitle(\"Median Income vs Target\", fontsize=18)\n\n# Adding annotations:\nplt.annotate(\"Most Blocks have low med.\\nincome and lower target.\", xy=(5, 1.5), xytext=(10, 2),\n             arrowprops={'arrowstyle': '->', 'color': 'k'},\n             bbox={'facecolor': 'orange', 'pad':4, 'alpha': 0.5, 'edgecolor': 'orange'});","f2eea2f9":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.hexbin('MedInc', 'target', data=train_df, alpha=1.0, cmap=\"inferno_r\")\n\nplt.margins(0)\nplt.colorbar()\nplt.xlabel('Median Income  ->')\nplt.ylabel('Target  ->')\nplt.suptitle(\"Median Income vs Target\", fontsize=18)\n\n# Adding annotations:\nplt.annotate(\"Most Blocks have low med.\\nincome and lower target.\", xy=(5, 1.5), xytext=(10, 2),\n             arrowprops={'arrowstyle': '->', 'color': 'k'},\n             bbox={'facecolor': 'gray', 'pad':4, 'alpha': 0.5, 'edgecolor': 'gray'});","ff8779ea":"# For indexing in array(np.round) and size considerations(np.log):\nmedi_min = np.round(train_df['MedInc']).min()\nmedi_max = np.round(train_df['MedInc']).max()\npop_min = np.round(np.log(train_df['Population'])).min()\npop_max = np.round(np.log(train_df['Population'])).max()\nmedi_min, medi_max, pop_min, pop_max","42cb9dc3":"Z = np.zeros((16, 10)) # (medi_max+1, pop_max)\ncounts = np.zeros((16, 10))\n\nfor i in range(len(train_df)):\n  a = np.round(train_df.iloc[i,]['MedInc']).astype(np.int)\n  b = np.round(np.log(train_df.iloc[i,]['Population'])).astype(np.int)\n  Z[a][b-1] += train_df.iloc[i,]['target'] # Addding all values of *target* for this point\n  counts[a][b-1] += 1 # Keeping a count of number of points for every location\n  \nZ = Z\/counts # taking average","1cbecc9c":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.contourf(Z, levels=30, cmap=\"gist_heat_r\")\nplt.colorbar()\n\nplt.suptitle(\"Target Contour\", fontsize=16)\nplt.title(\"(with Medium Income and Population)\", position=(0.6, 1.03))\nplt.xlabel(\"Medium Income  ->\")\nplt.ylabel(\"Population  ->\")\n\n# Adding Annotation:\nplt.annotate(\"We don't have data at\\nmany of the points...\", xy=(8, 12), xytext=(11.5, 4),\n             arrowprops={'arrowstyle':'->', 'color':'k'},\n             bbox={'facecolor': 'orange', 'edgecolor':'orange', 'alpha': 0.4, 'pad': 4})\nplt.annotate(\"\", xy=(1, 10), xytext=(11.4, 4),\n             arrowprops={'arrowstyle':'->', 'color':'k'});","7ca1a77d":"sns.pairplot(train_df);","711966d7":"train_df['target_int'] = train_df['target']\ntrain_df.loc[(train_df['target'] < 1), 'target_int'] = 0\ntrain_df.loc[(train_df['target'] >= 1) & (train_df['target'] < 2), 'target_int'] = 1\ntrain_df.loc[(train_df['target'] >= 2) & (train_df['target'] < 3), 'target_int'] = 2\ntrain_df.loc[(train_df['target'] >=3) & (train_df['target'] < 4), 'target_int'] = 3\ntrain_df.loc[(train_df['target'] >= 4), 'target_int'] = 4","8e2c7b2b":"train_df['medInc_int'] = train_df['MedInc']\n# From 0th percentile to 25th percentile of Median Income's Distribution\ntrain_df.loc[(train_df['MedInc'] < 2.56), 'medInc_int'] = train_df.loc[(train_df['MedInc'] < 2.56), 'MedInc'].mean()\n# From 25th percentile to 50th percentile of Median Income's Distribution\ntrain_df.loc[(train_df['MedInc'] >= 2.56) & (train_df['MedInc'] < 3.53), 'medInc_int'] = train_df.loc[(train_df['MedInc'] >= 2.56) & (train_df['MedInc'] < 3.53), 'MedInc'].mean()\n# From 50th percentile to 75th percentile of Median Income's Distribution\ntrain_df.loc[(train_df['MedInc'] >= 3.53) & (train_df['MedInc'] < 4.74), 'medInc_int'] = train_df.loc[(train_df['MedInc'] >= 3.53) & (train_df['MedInc'] < 4.74), 'MedInc'].mean()\n# From 75th percentile to 80th percentile of Median Income's Distribution\ntrain_df.loc[(train_df['MedInc'] >= 4.74) & (train_df['MedInc'] < 7), 'medInc_int'] = train_df.loc[(train_df['MedInc'] >= 4.74) & (train_df['MedInc'] < 7), 'MedInc'].mean()\n# From 80th percentile to 100th percentile of Median Income's Distribution\ntrain_df.loc[(train_df['MedInc'] >= 7), 'medInc_int'] = train_df.loc[(train_df['MedInc'] >= 7), 'MedInc'].mean()","e2c8a793":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.bar(np.sort(train_df['target_int'].unique()), train_df['target_int'].value_counts().sort_index(), alpha=0.7)\n\nplt.xlabel(\"Target  ->\")\nplt.ylabel(\"Frequency  ->\");","d909f257":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.bar(np.sort(train_df['target_int'].unique()), train_df['target_int'].value_counts().sort_index(), alpha=0.7, width=0.6)\n\nplt.grid(True, alpha=0.3)\nplt.xlabel(\"Target  ->\", fontsize=14)\nplt.ylabel(\"Frequency  ->\", fontsize=14)\nplt.title(\"Target Frequencies\", fontsize=18)\n\n# Remove top and left spines:\nax = plt.gca() # Get current axis (gca)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\n\n# Adding annotations:\ncounts = train_df['target_int'].value_counts().sort_index()\nplt.annotate(str(counts[0]), xy=(0, counts[0]), xytext=(0, counts[0]+400), ha = 'center', # horizontalalignment = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\nplt.annotate(str(counts[1]), xy=(1, counts[1]), xytext=(1, counts[1]+400), ha = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\nplt.annotate(str(counts[2]), xy=(2, counts[2]), xytext=(2, counts[2]+400), ha = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\nplt.annotate(str(counts[3]), xy=(3, counts[3]), xytext=(3, counts[3]+400), ha = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\nplt.annotate(str(counts[4]), xy=(4, counts[4]), xytext=(4, counts[4]+400), ha = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\nplt.xticks(ticks=[0, 1, 2, 3, 4], labels=[\"0 - 1\", \"1 - 2\", \"2 - 3\", \"3 - 4\", \"4 - 5\"], fontsize=12)\nplt.ylim([0, 9500])\nplt.text(2, 8000, \"Most Blocks have Target value\\nbetween 1 and 2\", fontsize=16,\n           bbox={'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.5, 'pad': 7});","eb521bbf":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nsns.barplot(np.sort(train_df['target_int'].unique()), train_df['target_int'].value_counts().sort_index())\n\nplt.xlabel(\"Target  ->\")\nplt.ylabel(\"Frequency  ->\");","05bfc73c":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nsns.barplot(\"target_int\", \"medInc_int\", data=train_df)\n\nplt.title(\"Medium Income Avg vs Target Values\", fontsize=16)\nplt.xlabel(\"Target  ->\", fontsize=14)\nplt.ylabel(\"Medium Income Mean ->\", fontsize=14);","c7ab4333":"x, y = np.sort(train_df['target_int'].unique()), train_df['target_int'].value_counts().sort_index()\nswm = SWMat(plt)\nswm.bar(x, y, highlight={\"cat\": [-1]}, highlight_type={\"data_type\": \"incrementalDown\"},\n        cat_labels=[\"0-1\", \"1-2\", \"2-3\", \"3-4\", \"4-5\"], highlight_color={\"cat_color\": \"#FF7700\"}, annotate=True)\nswm.axis(labels=[\"Target values\", \"Frequency\"])\nswm.title(\"About most expensive houses in California...\")\nswm.text(\"California is a sea-side state. As most\\nexpensive houses are at sea-side we\\ncan easily predict these values if we\\nsomehow <prop color='blue'>combine 'Latitude' and\\n'Longitude' variables <\/prop>and separate sea\\nside houses from non-sea-side houses.\",\n        btw_text_dist=.1);","e680e84c":"fig, axs = plt.subplots(1, 4, figsize=(40, 8))\nfig.suptitle(\"Bar Plots\", fontsize=28)\n\naxs[0].bar(np.sort(train_df['target_int'].unique()), train_df['target_int'].value_counts().sort_index(), alpha=0.7)\naxs[0].set_title(\"Normal\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[0].set_xlabel(\"Target  ->\")\naxs[0].set_ylabel(\"Frequency  ->\")\n\nsns.barplot(\"target_int\", \"medInc_int\", data=train_df, ax=axs[1])\naxs[1].set_title(\"Seaborn\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[1].set_xlabel(\"Target  ->\", fontsize=14)\naxs[1].set_ylabel(\"Medium Income Mean ->\", fontsize=14)\n\naxs[2].bar(np.sort(train_df['target_int'].unique()), train_df['target_int'].value_counts().sort_index(), alpha=0.7, width=0.6)\naxs[2].grid(True, alpha=0.3)\naxs[2].set_xlabel(\"Target  ->\", fontsize=14)\naxs[2].set_ylabel(\"Frequency  ->\", fontsize=14)\naxs[2].set_title(\"Matplotlib Power\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\n# Remove top and left spines:\naxs[2].spines['right'].set_visible(False)\naxs[2].spines['top'].set_visible(False)\n# Adding annotations:\ncounts = train_df['target_int'].value_counts().sort_index()\naxs[2].annotate(str(counts[0]), xy=(0, counts[0]), xytext=(0, counts[0]+400), ha = 'center', # horizontalalignment = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\naxs[2].annotate(str(counts[1]), xy=(1, counts[1]), xytext=(1, counts[1]+400), ha = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\naxs[2].annotate(str(counts[2]), xy=(2, counts[2]), xytext=(2, counts[2]+400), ha = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\naxs[2].annotate(str(counts[3]), xy=(3, counts[3]), xytext=(3, counts[3]+400), ha = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\naxs[2].annotate(str(counts[4]), xy=(4, counts[4]), xytext=(4, counts[4]+400), ha = 'center',\n         bbox={'boxstyle': 'round', 'pad': 0.5, 'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.6},\n         arrowprops={'arrowstyle':\"wedge,tail_width=0.5\", 'alpha':0.6, 'color': 'orange'})\naxs[2].set_xticks([0, 1, 2, 3, 4])\naxs[2].set_xticklabels([\"0 - 1\", \"1 - 2\", \"2 - 3\", \"3 - 4\", \"4 - 5\"], fontsize=12)\naxs[2].set_ylim([0, 9500])\n\nx, y = np.sort(train_df['target_int'].unique()), train_df['target_int'].value_counts().sort_index()\nswm = SWMat(plt, ax=axs[3])\nswm.bar(x, y, highlight={\"cat\": [-1]}, highlight_type={\"data_type\": \"incrementalDown\"},\n        cat_labels=[\"0-1\", \"1-2\", \"2-3\", \"3-4\", \"4-5\"], highlight_color={\"cat_color\": \"#FF7700\"}, annotate=True)\nswm.axis(labels=[\"Target values\", \"Frequency\"])\nswm.title(\"About most expensive houses in California...\")\nswm.text(\"California is a sea-side state. As most\\nexpensive houses are at sea-side we\\ncan easily predict these values if we\\nsomehow <prop color='blue'>combine 'Latitude' and\\n'Longitude' variables <\/prop>and separate sea\\nside houses from non-sea-side houses.\",\n        btw_text_dist=.1);","52e29a37":"from matplotlib.pyplot import figure\nfigure(figsize=(15, 7))\n\nplt.boxplot(train_df['target'], vert=False)\n\nplt.xlabel(\"<-  Target Values  ->\")\nplt.ylabel(\"Target\");","e5424a37":"from matplotlib.pyplot import figure\nfigure(figsize=(15, 7))\n\nbp = plt.boxplot([train_df['MedInc'], train_df['target']], vert=False, patch_artist=True) # patch_artist for coloring box plot\n\nplt.grid(True, alpha=0.6)\nplt.title(\"Box Plots\", fontsize=18)\nplt.xlabel(\"Values  ->\", fontsize=14)\nplt.ylabel(\"Features\", fontsize=14)\nplt.yticks(ticks=[1, 2], labels=['MedInc', 'Target'])\n\n# Coloring Box Plots and ...  (https:\/\/stackoverflow.com\/questions\/41997493\/python-matplotlib-boxplot-color)\nfor el in ['boxes', 'whiskers', 'fliers', 'means', 'medians', 'caps']:\n    for i in range(len(bp[el])):\n        plt.setp(bp[el][i], color='#555555')\n        plt.setp(bp[el][i], linewidth=2)\n\nbp['boxes'][0].set(facecolor='#FF5F27')\nbp['boxes'][1].set(facecolor=\"#67FF67\");","3790022d":"from matplotlib.pyplot import figure\nfigure(figsize=(20, 7))\n\nbp = plt.boxplot([train_df['MedInc'], train_df['target']], vert=False, patch_artist=True,\n                flierprops={'alpha':0.6, 'markersize': 6, 'markeredgecolor': '#555555','marker': 'd',\n                           'markerfacecolor': \"#555555\"}, # (https:\/\/stackoverflow.com\/questions\/32480988\/matplotlib-fliers-in-boxplot-object-not-setting-correctly)\n                capprops={'color': '#555555', 'linewidth': 2},\n                boxprops={'color': '#555555', 'linewidth': 2},\n                whiskerprops={'color': '#555555', 'linewidth': 2},\n                medianprops={'color': '#555555', 'linewidth': 2},\n                meanprops={'color': '#555555', 'linewidth': 2}) # outlier are computed but not drawn\n\nplt.grid(True, alpha=0.6)\nplt.title(\"Box Plots\", fontsize=18)\nplt.xlabel(\"Values  ->\", fontsize=14)\nplt.ylabel(\"Features\", fontsize=14)\nplt.yticks(ticks=[1, 2], labels=['MedInc', 'Target'])\n\nbp['boxes'][0].set(facecolor='#727FFF')\nbp['boxes'][1].set(facecolor=\"#97FF67\")\n\n# Adding Text:\nplt.text(11, 1.5, \"There are many potential\\nOutliers with respect to\\nMedian Income\", fontsize=18,\n        bbox={'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.4, 'pad': 8});","bfd8940b":"from matplotlib.pyplot import figure\nfigure(figsize=(15, 7))\n\nsns.boxplot(train_df['MedInc']); # We can only plot one box like this...","c55082ba":"# But we can do something like this with seaborn:\nfrom matplotlib.pyplot import figure\nfigure(figsize=(15, 7))\n\nsns.boxplot(train_df['target_int'], train_df['MedInc']);","56fd3f8d":"# Or ...\nfrom matplotlib.pyplot import figure\nfigure(figsize=(15, 7))\n\nbp = sns.boxplot(train_df['target_int'], train_df['AveRooms'], hue = train_df['medInc_int'])\nplt.ylim([0, 60])\n\n# Changing Legend (with patches):\nps = bp.get_legend_handles_labels()[0] # Patches\nplt.legend(ps, [\"0th-25th percentile of\\n Median Income's Dist.\", \n          \"25th-50th\",\n          \"50th-75th\", \n          \"75th-80th\",\n          \"80th-100th\"])\n\n### Adding Info: (https:\/\/matplotlib.org\/examples\/shapes_and_collections\/artist_reference.html)\n## Adding Circle:\nimport matplotlib.patches as mpatches\n\neps = mpatches.Ellipse(xy=(1.3, 20), width=1.5, height=20, edgecolor=\"#555555\", fill=False)\nax = plt.gca() # get current axes (gca)\nax.add_patch(eps)\n## Adding annotations:\nplt.annotate(\"Many low 'target' value blocks\\nhave many rooms maybe\\nbecause of many multi-story\\nbuildings...\",\n            xy=(1.95, 25), xytext=(4.6, 40),\n            arrowprops={'arrowstyle':'<-', 'color':'k'},\n            bbox={'facecolor': 'orange', 'edgecolor':'orange', 'alpha':0.4, 'pad': 4});","33d6426b":"swm = SWMat(plt)\nbp = plt.boxplot([train_df['MedInc'], train_df['target']], vert=False, patch_artist=True,\n                 # (https:\/\/stackoverflow.com\/questions\/32480988\/matplotlib-fliers-in-boxplot-object-not-setting-correctly)\n                flierprops={'alpha':0.6, 'markersize': 6, 'markeredgecolor': '#555555','marker': 'd',\n                           'markerfacecolor': \"#555555\"}, \n                capprops={'color': '#555555', 'linewidth': 2},\n                boxprops={'color': '#555555', 'linewidth': 2},\n                whiskerprops={'color': '#555555', 'linewidth': 2},\n                medianprops={'color': '#555555', 'linewidth': 2},\n                meanprops={'color': '#555555', 'linewidth': 2}) # outlier are computed but not drawn\nplt.xlabel(\"Values  ->\", fontsize=14)\nplt.ylabel(\"Features\", fontsize=14)\nplt.yticks(ticks=[1, 2], labels=['MedInc', 'Target'])\nbp['boxes'][0].set(facecolor='#727FFF')\nbp['boxes'][1].set(facecolor=\"#97FF67\");\n\nswm.title(\"Many unusual outliers in 'MedInc' variable...\")\nswm.text((\"It may be because of buying of sea side\\n\"\n          \"places by very wealthy people. This <prop color='blue'>buying\\n\"\n          \"by many times greater earners<\/prop> and yet not much\\n\"\n          \"in number might have made box plot like this.\\n\"\n          \"And also because of Hollywood!\"), btw_line_dist=.15, btw_text_dist=.01);","64f955d4":"fig, axs = plt.subplots(1, 4, figsize=(40, 8))\nfig.suptitle(\"Box Plots\", fontsize=28)\n\naxs[0].boxplot(train_df['target'], vert=False)\naxs[0].set_title(\"Normal\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[0].set_xlabel(\"<-  Target Values  ->\")\naxs[0].set_ylabel(\"Target\")\n\nbp = sns.boxplot(train_df['target_int'], train_df['AveRooms'], hue = train_df['medInc_int'], ax=axs[1])\naxs[1].set_title(\"Seaborn\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[1].set_ylim([0, 60])\n# Changing Legend (with patches):\nps = bp.get_legend_handles_labels()[0] # Patches\naxs[1].legend(ps, [\"0th-25th percentile of\\n Median Income's Dist.\", \n          \"25th-50th\",\n          \"50th-75th\", \n          \"75th-80th\",\n          \"80th-100th\"])\n\nbp = axs[2].boxplot([train_df['MedInc'], train_df['target']], vert=False, patch_artist=True) # patch_artist for coloring box plot\naxs[2].grid(True, alpha=0.6)\naxs[2].set_title(\"Matplotlib Power\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[2].set_xlabel(\"Values  ->\", fontsize=14)\naxs[2].set_ylabel(\"Features\", fontsize=14)\naxs[2].set_yticks([1, 2])\naxs[2].set_yticklabels(['MedInc', 'Target'])\n# Coloring Box Plots and ...  (https:\/\/stackoverflow.com\/questions\/41997493\/python-matplotlib-boxplot-color)\nfor el in ['boxes', 'whiskers', 'fliers', 'means', 'medians', 'caps']:\n    for i in range(len(bp[el])):\n        bp[el][i].set_color('#555555')\n        bp[el][i].set_linewidth(2)\nbp['boxes'][0].set(facecolor='#FF5F27')\nbp['boxes'][1].set(facecolor=\"#67FF67\")\n# Adding Text:\naxs[2].text(9, 1.5, \"There are many potential\\nOutliers with respect to\\nMedian Income\", fontsize=14,\n        bbox={'facecolor': 'orange', 'edgecolor': 'orange', 'alpha': 0.4, 'pad': 8});\n\nswm = SWMat(plt, ax=axs[3])\nbp = axs[3].boxplot([train_df['MedInc'], train_df['target']], vert=False, patch_artist=True,\n                 # (https:\/\/stackoverflow.com\/questions\/32480988\/matplotlib-fliers-in-boxplot-object-not-setting-correctly)\n                flierprops={'alpha':0.6, 'markersize': 6, 'markeredgecolor': '#555555','marker': 'd',\n                           'markerfacecolor': \"#555555\"}, \n                capprops={'color': '#555555', 'linewidth': 2},\n                boxprops={'color': '#555555', 'linewidth': 2},\n                whiskerprops={'color': '#555555', 'linewidth': 2},\n                medianprops={'color': '#555555', 'linewidth': 2},\n                meanprops={'color': '#555555', 'linewidth': 2}) # outlier are computed but not drawn\naxs[3].set_xlabel(\"Values  ->\", fontsize=14)\naxs[3].set_ylabel(\"Features\", fontsize=14)\naxs[3].set_yticks(ticks=[1, 2])\naxs[3].set_yticklabels(['MedInc', 'Target'])\nbp['boxes'][0].set(facecolor='#727FFF')\nbp['boxes'][1].set(facecolor=\"#97FF67\");\n\nswm.title(\"Many unusual outliers in 'MedInc' variable...\")\nswm.text((\"It may be because of buying of sea side\\n\"\n          \"places by very wealthy people. This <prop color='blue'>buying\\n\"\n          \"by many times greater earners<\/prop> and yet not much\\n\"\n          \"in number might have made box plot like this.\\n\"\n          \"And also because of Hollywood!\"), btw_line_dist=.15, btw_text_dist=.01);","d37ea1b0":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nplt.violinplot(train_df['target'])\n\nplt.title(\"Target Violin Plot\")\nplt.ylabel(\"Target values  ->\");","9eeba833":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nvp = plt.violinplot(train_df['target'], vert=False, showmeans=True, showmedians=True)\n\n# Returns a dictionary with keys : ['bodies', 'cbars', 'cmaxes', 'cmeans', 'cmedians', 'cmins']\nvp['bodies'][0].set_edgecolor(\"k\")\nvp['bodies'][0].set_linewidth(2)\nvp['bodies'][0].set_alpha(1.0)\nvp['bodies'][0].set_zorder(10)\n\nvp['cmeans'].set_linestyle(\":\")\nvp['cmeans'].set_color(\"r\")\nvp['cmeans'].set_zorder(101)\nvp['cmeans'].set_segments(np.array([[[2.06855817, 0.7], [2.06855817, 1.3]]]))\n\nvp['cmedians'].set_linestyle(\"--\")\nvp['cmedians'].set_color(\"orange\")\nvp['cmedians'].set_zorder(100)\nvp['cmedians'].set_segments(np.array([[[1.797, 0.7], [1.797, 1.3]]]))\n\nvp['cbars'].set_zorder(99)\nvp['cbars'].set_color(\"k\")\nvp['cbars'].set_linewidth(0.5)\n\nvp['cmaxes'].set_visible(False)\nvp['cmins'].set_visible(False)\n\n# Legend:\nplt.legend(handles=[vp['bodies'][0], vp['cmeans'], vp['cmedians']], labels=[\"Target\", \"Mean\", \"Median\"], handlelength=5)\n\nplt.title(\"Target Violin Plot\")\nplt.xlabel(\"Target\")\nplt.yticks([])\nplt.grid(True, alpha=0.8)\n\n# Adding Text\nplt.text(1.797-0.773, 1.15, f\"({train_df['target'].median()}) Median\", fontdict=None,\n         bbox={'facecolor':'orange', 'edgecolor': 'orange', 'pad':4, 'alpha': 0.7}, zorder=12)\nplt.text(2.06855817+0.05, 1.15, f\"Mean ({np.round(train_df['target'].mean(),3)})\", fontdict=None,\n         bbox={'facecolor':'red', 'edgecolor': 'red', 'pad':4, 'alpha': 0.6}, zorder=11);\n#vp['cmeans'].get_segments()","f6af3c28":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 7))\n\nsns.violinplot(train_df['target']);","1c1fa9f9":"from matplotlib.pyplot import figure\nfigure(figsize=(15, 7))\n\nvp = sns.violinplot(train_df['target_int'], train_df['AveRooms'], hue = train_df['medInc_int'])\n\n# Changing Legend (with patches):\nps = vp.get_legend_handles_labels()[0] # Patches\nplt.legend(ps, [\"0th-25th percentile of\\n Median Income's Dist.\", \n          \"25th-50th\",\n          \"50th-75th\", \n          \"75th-80th\",\n          \"80th-100th\"]);","74b20869":"plt.figure(figsize=(15, 7))\n\nvp = sns.violinplot(train_df['target_int'], train_df['AveRooms'], hue = train_df['medInc_int'])\n# Changing Legend (with patches):\nps = vp.get_legend_handles_labels()[0] # Patches\nplt.legend(ps, [\"0th-25th percentile of\\n Median Income's Dist.\", \n          \"25th-50th\",\n          \"50th-75th\", \n          \"75th-80th\",\n          \"80th-100th\"])\nplt.ylim([0, 60])\n### Adding Info: (https:\/\/matplotlib.org\/examples\/shapes_and_collections\/artist_reference.html)\n## Adding Circle:\nimport matplotlib.patches as mpatches\neps = mpatches.Ellipse(xy=(1.3, 20), width=1.5, height=20, edgecolor=\"#555555\", fill=False)\nplt.gca().add_patch(eps)\n## Adding annotations:\nplt.annotate(\"Many low 'target' value blocks\\nhave many rooms maybe\\nbecause of many multi-story\\nbuildings...\",\n            xy=(1.95, 25), xytext=(4.6, 40),\n            arrowprops={'arrowstyle':'<-', 'color':'k'},\n            bbox={'facecolor': 'orange', 'edgecolor':'orange', 'alpha':0.4, 'pad': 4});","475ab5d2":"swm = SWMat(plt)\nswm.violinplot(train_df['target'], highlight={\"0\":[(1, 2), (4, 6)]})\nswm.text(\"Carefully looking at the dependent variable revealed some problems that might occur!\", position=[-.05, 1.0]);\n#swm.text(\"Target is a bi-modal dependent feature.\\nIt can be <prop fontsize='18' color='blue'> hard to predict.<\\prop>\", btw_line_dist=1e-3, btw_text_dist=.01, position=[1.03, 0]);","4f911393":"fig, axs = plt.subplots(1, 4, figsize=(40, 8))\nfig.suptitle(\"Violin Plots\", fontsize=28)\n\naxs[0].set_title(\"Normal\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[0].violinplot(train_df['target'])\naxs[0].set_ylabel(\"Target values  ->\")\n\nvp = sns.violinplot(train_df['target_int'], train_df['AveRooms'], hue = train_df['medInc_int'], ax=axs[1])\n# Changing Legend (with patches):\nps = vp.get_legend_handles_labels()[0] # Patches\naxs[1].legend(ps, [\"0th-25th percentile of\\n Median Income's Dist.\", \n          \"25th-50th\",\n          \"50th-75th\", \n          \"75th-80th\",\n          \"80th-100th\"])\n\naxs[1].set_title(\"Seaborn\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\nvp = axs[2].violinplot(train_df['target'], vert=False, showmeans=True, showmedians=True)\n# Returns a dictionary with keys : ['bodies', 'cbars', 'cmaxes', 'cmeans', 'cmedians', 'cmins']\nvp['bodies'][0].set_edgecolor(\"k\")\nvp['bodies'][0].set_linewidth(2)\nvp['bodies'][0].set_alpha(1.0)\nvp['bodies'][0].set_zorder(10)\nvp['cmeans'].set_linestyle(\":\")\nvp['cmeans'].set_color(\"r\")\nvp['cmeans'].set_zorder(101)\nvp['cmeans'].set_segments(np.array([[[2.06855817, 0.7], [2.06855817, 1.3]]]))\nvp['cmedians'].set_linestyle(\"--\")\nvp['cmedians'].set_color(\"orange\")\nvp['cmedians'].set_zorder(100)\nvp['cmedians'].set_segments(np.array([[[1.797, 0.7], [1.797, 1.3]]]))\nvp['cbars'].set_zorder(99)\nvp['cbars'].set_color(\"k\")\nvp['cbars'].set_linewidth(0.5)\nvp['cmaxes'].set_visible(False)\nvp['cmins'].set_visible(False)\n# Legend:\naxs[2].legend(handles=[vp['bodies'][0], vp['cmeans'], vp['cmedians']], labels=[\"Target\", \"Mean\", \"Median\"], handlelength=5)\naxs[2].set_title(\"Matplotlib Power\", fontdict={'fontsize': 19, 'fontweight':0.5 }, pad=15)\naxs[2].set_xlabel(\"Target\")\naxs[2].set_yticks([])\naxs[2].grid(True, alpha=0.8)\n# Adding Text\naxs[2].text(1.797-0.893, 1.15, f\"({train_df['target'].median()}) Median\", fontdict=None,\n         bbox={'facecolor':'orange', 'edgecolor': 'orange', 'pad':4, 'alpha': 0.7}, zorder=12)\naxs[2].text(2.06855817+0.05, 1.15, f\"Mean ({np.round(train_df['target'].mean(),3)})\", fontdict=None,\n         bbox={'facecolor':'red', 'edgecolor': 'red', 'pad':4, 'alpha': 0.6}, zorder=11)\n\n","acb274cd":"plt.figure(1, figsize=(10, 8))\nplt.suptitle(\"Hist-Distribution\", fontsize=18, y=1)\n\n# Now lets make some axes (diff graphs) in this figure\naxScatter = plt.axes([0.1, 0.1, 0.65, 0.65]) # [left, bottom, width, height] in percent values\naxHistx = plt.axes([0.1, 0.755, 0.65, 0.2])\naxHisty = plt.axes([0.755, 0.1, 0.2, 0.65])\n\naxHistx.set_xticks([])\naxHistx.set_yticks([])\naxHisty.set_xticks([])\naxHisty.set_yticks([])\naxHistx.set_frame_on(False)\naxHisty.set_frame_on(False)\naxScatter.set_xlabel(\"MedInc  ->\")\naxScatter.set_ylabel(\"Population  ->\")\n\n# Lets plot in these axes:\naxScatter.scatter('MedInc', 'Population', data=train_df, edgecolors='w')\naxHistx.hist('MedInc', bins=30, data=train_df, ec='w', density=True, alpha=0.7)\naxHisty.hist('Population', bins=60, data=train_df, ec='w', density=True, alpha=0.7, orientation='horizontal')\n#train_df['MedInc'].plot.kde(ax=axHistx, color='b')\naxHistx.set_ylabel(\"\")\n\n# Adding annotations:\naxScatter.annotate(\"Probably an outlier\", xy=(2.6, 35500), xytext=(7, 28000),\n                   arrowprops={'arrowstyle':'->'}, \n                   bbox={'pad':4, 'facecolor':'orange', 'alpha': 0.4, 'edgecolor':'orange'});","519e6e42":"from matplotlib.pyplot import figure\nfigure(figsize=(10, 8))\n\nsns.jointplot('MedInc', 'Population', data=train_df);","c50fc423":"%matplotlib notebook\n\nclass LineBuilder:\n    def __init__(self, line):\n        self.line = line\n        self.xs = list(line.get_xdata())\n        self.ys = list(line.get_ydata())\n        self.cid = line.figure.canvas.mpl_connect('button_press_event', self)\n\n    def __call__(self, event):\n        print('click', event)\n        if event.inaxes!=self.line.axes: return\n        self.xs.append(event.xdata)\n        self.ys.append(event.ydata)\n        self.line.set_data(self.xs, self.ys)\n        self.line.figure.canvas.draw()\n\nfig = plt.figure()\nax = fig.add_subplot(111)\nax.set_title('click to build line segments')\nline, = ax.plot([0], [0])  # empty line\nlinebuilder = LineBuilder(line)","43acd785":"%matplotlib notebook\n\nclass PointBrowser(object):\n    \"\"\"\n    Click on a point to select and highlight it -- the data that\n    generated the point will be shown in the lower axes.  Use the 'n'\n    and 'p' keys to browse through the next and previous points\n    \"\"\"\n\n    def __init__(self):\n        self.lastind = 0\n\n        self.text = ax.text(0.05, 0.95, 'selected: none',\n                            transform=ax.transAxes, va='top')\n        self.selected, = ax.plot([xs[0]], [ys[0]], 'o', ms=12, alpha=0.4,\n                                 color='yellow', visible=False)\n\n    def onpress(self, event):\n        if self.lastind is None:\n            return\n        if event.key not in ('n', 'p'):\n            return\n        if event.key == 'n':\n            inc = 1\n        else:\n            inc = -1\n\n        self.lastind += inc\n        self.lastind = np.clip(self.lastind, 0, len(xs) - 1)\n        self.update()\n\n    def onpick(self, event):\n\n        if event.artist != line:\n            return True\n\n        N = len(event.ind)\n        if not N:\n            return True\n\n        # the click locations\n        x = event.mouseevent.xdata\n        y = event.mouseevent.ydata\n\n        distances = np.hypot(x - xs[event.ind], y - ys[event.ind])\n        indmin = distances.argmin()\n        dataind = event.ind[indmin]\n\n        self.lastind = dataind\n        self.update()\n\n    def update(self):\n        if self.lastind is None:\n            return\n\n        dataind = self.lastind\n\n        ax2.cla()\n        ax2.plot(X[dataind])\n\n        ax2.text(0.05, 0.9, 'mu=%1.3f\\nsigma=%1.3f' % (xs[dataind], ys[dataind]),\n                 transform=ax2.transAxes, va='top')\n        ax2.set_ylim(-0.5, 1.5)\n        self.selected.set_visible(True)\n        self.selected.set_data(xs[dataind], ys[dataind])\n\n        self.text.set_text('selected: %d' % dataind)\n        fig.canvas.draw()\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nX = np.random.rand(100, 200)\nxs = np.mean(X, axis=1)\nys = np.std(X, axis=1)\n\nfig, (ax, ax2) = plt.subplots(2, 1)\nax.set_title('click on point to plot time series')\nline, = ax.plot(xs, ys, 'o', picker=5)  # 5 points tolerance\n\nbrowser = PointBrowser()\n\nfig.canvas.mpl_connect('pick_event', browser.onpick)\nfig.canvas.mpl_connect('key_press_event', browser.onpress)","e8577e51":"%matplotlib notebook\n\nfigsrc, axsrc = plt.subplots()\nfigzoom, axzoom = plt.subplots()\naxsrc.set(xlim=(0, 1), ylim=(0, 1), autoscale_on=False,\n          title='Click to zoom')\naxzoom.set(xlim=(0.45, 0.55), ylim=(0.4, 0.6), autoscale_on=False,\n           title='Zoom window')\n\nx, y, s, c = np.random.rand(4, 200)\ns *= 200\n\naxsrc.scatter(x, y, s, c)\naxzoom.scatter(x, y, s, c)\n\n\ndef onpress(event):\n    if event.button != 1:\n        return\n    x, y = event.xdata, event.ydata\n    axzoom.set_xlim(x - 0.1, x + 0.1)\n    axzoom.set_ylim(y - 0.1, y + 0.1)\n    figzoom.canvas.draw()\n\nfigsrc.canvas.mpl_connect('button_press_event', onpress)\nplt.show()","20deaefa":"%matplotlib notebook\n\nfig, ax = plt.subplots()\nax.plot(np.random.rand(10))\n\ndef onclick(event):\n    print('%s click: button=%d, x=%d, y=%d, xdata=%f, ydata=%f' %\n          ('double' if event.dblclick else 'single', event.button,\n           event.x, event.y, event.xdata, event.ydata))\n\ncid = fig.canvas.mpl_connect('button_press_event', onclick)","283d84af":"%matplotlib inline","8dd7c918":"from mpl_toolkits import mplot3d","26e7282d":"ax = plt.gca(projection='3d')\n\n# Data for a three-dimensional line\nzline = np.linspace(0, 15, 1000)\nxline = np.sin(zline)\nyline = np.cos(zline)\nax.plot3D(xline, yline, zline, 'gray')\n\n# Data for three-dimensional scattered points\nzdata = 15 * np.random.random(100)\nxdata = np.sin(zdata) + 0.1 * np.random.randn(100)\nydata = np.cos(zdata) + 0.1 * np.random.randn(100)\nax.scatter3D(xdata, ydata, zdata, c=zdata, cmap='Greens');","ea6eea2f":"# This import registers the 3D projection, but is otherwise unused.\nfrom mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import\n\n\n# setup the figure and axes\nplt.figure(figsize=(8, 6))\nax = plt.gca(projection='3d')\n\n# data\n_x = np.arange(4)\n_y = np.arange(5)\n_xx, _yy = np.meshgrid(_x, _y)\nx, y = _xx.ravel(), _yy.ravel()\n\ntop = x + y\nbottom = np.zeros_like(top)\nwidth = depth = 1\n\nax.bar3d(x, y, bottom, width, depth, top, shade=True)\nax.set_title('Bar Plot')","ce2fe1b7":"from matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the 3D surface\nax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3)\n\n# Plot projections of the contours for each dimension.  By choosing offsets\n# that match the appropriate axes limits, the projected contours will sit on\n# the 'walls' of the graph\ncset = ax.contourf(X, Y, Z, zdir='z', offset=-100, cmap=cm.coolwarm)\ncset = ax.contourf(X, Y, Z, zdir='x', offset=-40, cmap=cm.coolwarm)\ncset = ax.contourf(X, Y, Z, zdir='y', offset=40, cmap=cm.coolwarm)\n\nax.set_xlim(-40, 40)\nax.set_ylim(-40, 40)\nax.set_zlim(-100, 100)\n\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')","b02d8d78":"#!conda install -c conda-forge basemap","38a7c682":"from mpl_toolkits.basemap import Basemap","99db98cb":"?Basemap # ['llcrnrlon=None', 'llcrnrlat=None', 'urcrnrlon=None', 'urcrnrlat=None', 'llcrnrx=None', \n         #  'llcrnry=None', 'urcrnrx=None', 'urcrnry=None', 'width=None', 'height=None', \"projection='cyl'\", \n         #  \"resolution='c'\", 'area_thresh=None', 'rsphere=6370997.0', 'ellps=None', 'lat_ts=None', 'lat_1=None', \n         #  'lat_2=None', 'lat_0=None', 'lon_0=None', 'lon_1=None', 'lon_2=None', 'o_lon_p=None', 'o_lat_p=None',\n         #  'k_0=None', 'no_rot=False', 'suppress_ticks=True', 'satellite_height=35786000', 'boundinglat=None', \n         #  'fix_aspect=True', \"anchor='C'\", 'celestial=False', 'round=False', 'epsg=None', 'ax=None']","2646550a":"m = Basemap()\n\nm.drawcoastlines()","f476af23":"m = Basemap(projection='ortho', lat_0=0, lon_0=0)\n\n#Fill the globe with a blue color \nm.drawmapboundary(fill_color='aqua')\n\n#Fill the continents with the land color\nm.fillcontinents(color='coral', lake_color='aqua')\n\nm.drawcoastlines()","5af3c9de":"m = Basemap(projection='ortho', lat_0=0, lon_0=0)\n\nm.drawmapboundary(fill_color='aqua')\nm.fillcontinents(color='coral',lake_color='aqua')\nm.drawcoastlines()\n\nx, y = map(0, 0) # Converts lat, lon to plot's x, y coordinates.\n\nm.plot(x, y, marker='D',color='m')","a08c33eb":"from datetime import datetime\n\nm = Basemap(projection='ortho', lon_0=0, lat_0=0, resolution='c')\n\nm.drawmapboundary(fill_color=\"#7777ff\")\nm.fillcontinents(color=\"#ddaa66\",lake_color=\"#7777ff\")\n\nm.drawcoastlines()\n\nm.nightshade(datetime.now(), delta=0.2)","2ce8bd7c":"m = Basemap(llcrnrlon=-125, llcrnrlat=27, urcrnrlon=-113, urcrnrlat=43,\n             resolution='i', projection='tmerc', lat_0 = 35, lon_0 =-119) # llcrnr: lower left corner; urcrnr: upper right corner\n\nm.drawmapboundary(fill_color='aqua')\nm.fillcontinents(color='#cc9955',lake_color='aqua')\nm.drawcoastlines()\n\nm.drawmapscale(-119, 28.5, -114, 29.5, 500, fontsize = 14);","c21ef702":"m = Basemap(llcrnrlon=3.75 llcrnrlat=39.75, urcrnrlon=4.35, urcrnrlat=40.15, epsg=5520) # EPSG code defining projection (see http:\/\/spatialreference.org for a list of EPSG codes and their definitions).\n#http:\/\/server.arcgisonline.com\/arcgis\/rest\/services\n\nm.arcgisimage(service='ESRI_Imagery_World_2D', xpixels = 1500, verbose= True)","06734010":"m = Basemap(llcrnrlon=-10.5, llcrnrlat=33, urcrnrlon=10., urcrnrlat=46.,\n             resolution='l', projection='cass', lat_0 = 39.5, lon_0 = 0.)\n\nm.bluemarble()\n\nm.drawcoastlines()","79ec086c":"train_df.head()","93ffa568":"colors = []\nfor i in range(train_df.shape[0]):\n    if train_df.iloc[i, -1] > 4.0: colors.append(\"r\")\n    elif train_df.iloc[i, -1] > 3.0: colors.append(\"m\")\n    elif train_df.iloc[i, -1] > 2.0: colors.append(\"y\")\n    else: colors.append(\"gray\")","4bedd282":"from mpl_toolkits.mplot3d import Axes3D\n\nm = Basemap(llcrnrlon=-125, llcrnrlat=27, urcrnrlon=-113, urcrnrlat=43, resolution='i')\n\nfig = plt.figure(figsize=(20, 15))\nax = Axes3D(fig)\n\nax.set_axis_off()\nax.azim = 270 # Azimuth angle\nax.dist = 6   # Distance of eye-viewing point fro object point\n\nax.add_collection3d(m.drawcoastlines(linewidth=0.25))\nax.add_collection3d(m.drawcountries(linewidth=0.35))\nax.add_collection3d(m.drawstates(linewidth=0.30))\n\nx, y = train_df['Longitude'].values, train_df['Latitude'].values\nx, y = m(x, y)\nax.bar3d(x, y, np.zeros(len(x)), 30, 30, np.ones(len(x))\/10, color=colors, alpha=0.8)\n#ax.set_zlim([0, 6]);","a74d371b":"!pip install wordcloud","44fa29c5":"from PIL import Image\nfrom wordcloud import WordCloud, STOPWORDS, ImageColorGenerator","d6dbcb44":"?WordCloud#(font_path=None, width=400, height=200, margin=2, ranks_only=None, prefer_horizontal=0.9, \n          # mask=None, scale=1, color_func=None, max_words=200, min_font_size=4, stopwords=None, \n          # random_state=None, background_color='black', max_font_size=None, font_step=1, mode='RGB', \n          # relative_scaling='auto', regexp=None, collocations=True, colormap=None, normalize_plurals=True, \n          # contour_width=0, contour_color='black', repeat=False)","f0a6f851":"from sklearn.datasets import fetch_20newsgroups\nnewsgroups_train = fetch_20newsgroups(subset='train')","b4b26fb4":"newsgroups_train.keys()","b8221dcc":"print(newsgroups_train['DESCR'][:1463])","95c15d99":"type(newsgroups_train.data)","439c9e6a":"d_ = \"\"\nfor i in range(1000):\n    d_ += newsgroups_train.data[i].replace(\"AX\", \"\")","f7275114":"%matplotlib inline\n\n# Start with one review:\ntext = d_\n\n# Create and generate a word cloud image:\nwordcloud = WordCloud().generate(text)\n\n# Display the generated image:\nplt.imshow(wordcloud, interpolation='bilinear')\nplt.axis(\"off\")","2b8404d8":"# lower max_font_size, change the maximum number of word and lighten the background:\nwordcloud = WordCloud(max_font_size=50, max_words=100, background_color=\"white\").generate(text)\nplt.figure()\nplt.imshow(wordcloud, interpolation=\"bilinear\")\nplt.axis(\"off\")\nplt.show()","ccb8210b":"# Save the image:\nwordcloud.to_file(\"wc1.png\");","6a590015":"mask = np.array(Image.open(\"jour.jpg\")) # Searched \"journalism black png\" on google images...","d1ad765b":"stopwords = set(STOPWORDS)\nwc = WordCloud(background_color=\"white\", max_words=1000, mask=mask,\n               stopwords=stopwords)\n\n# Generate a wordcloud\nwc.generate(text)\n\n# show\nplt.figure(figsize=[20,10])\nplt.imshow(wc, interpolation='bilinear')\nplt.axis(\"off\")\nplt.show()","0773f531":"from matplotlib.animation import FuncAnimation","441b19eb":"?FuncAnimation#(fig, func, frames=None, init_func=None, fargs=None, save_count=None, **kwargs)","dcfb6765":"%matplotlib notebook\n\nfig, ax = plt.subplots()\nxdata, ydata = [], []\nln, = plt.plot([], [], 'ro')\n\ndef init():\n    ax.set_xlim(0, 2*np.pi)\n    ax.set_ylim(-1, 1)\n    return ln,\n\ndef update(frame):\n    xdata.append(frame)\n    ydata.append(np.sin(frame))\n    ln.set_data(xdata, ydata)\n    return ln,\n\nani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 128), init_func=init, blit=True)\n\nani.save('FuncAnim.gif', writer='pillow', fps=60)","6781b90b":"%matplotlib notebook\n\ndef data_gen(t=0):\n    cnt = 0\n    while cnt < 1000:\n        cnt += 1\n        t += 0.1\n        yield t, np.sin(2*np.pi*t) * np.exp(-t\/10.)\n\n\ndef init():\n    ax.set_ylim(-1.1, 1.1)\n    ax.set_xlim(0, 10)\n    del xdata[:]\n    del ydata[:]\n    line.set_data(xdata, ydata)\n    return line,\n\nfig, ax = plt.subplots()\nline, = ax.plot([], [], lw=2)\nax.grid()\nxdata, ydata = [], []\n\n\ndef run(data):\n    # update the data\n    t, y = data\n    xdata.append(t)\n    ydata.append(y)\n    xmin, xmax = ax.get_xlim()\n\n    if t >= xmax:\n        ax.set_xlim(xmin, 2*xmax)\n        ax.figure.canvas.draw()\n    line.set_data(xdata, ydata)\n\n    return line,\n\nani = FuncAnimation(fig, run, data_gen, blit=False, interval=10,\n                              repeat=False, init_func=init)","d0704e16":"%matplotlib notebook\nimport math\n\ndef beta_pdf(x, a, b):\n    return (x**(a-1) * (1-x)**(b-1) * math.gamma(a + b)\n            \/ (math.gamma(a) * math.gamma(b)))\n\n\nclass UpdateDist(object):\n    def __init__(self, ax, prob=0.5):\n        self.success = 0\n        self.prob = prob\n        self.line, = ax.plot([], [], 'k-')\n        self.x = np.linspace(0, 1, 200)\n        self.ax = ax\n\n        # Set up plot parameters\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 15)\n        self.ax.grid(True)\n\n        # This vertical line represents the theoretical value, to\n        # which the plotted distribution should converge.\n        self.ax.axvline(prob, linestyle='--', color='black')\n\n    def init(self):\n        self.success = 0\n        self.line.set_data([], [])\n        return self.line,\n\n    def __call__(self, i):\n        # This way the plot can continuously run and we just keep\n        # watching new realizations of the process\n        if i == 0:\n            return self.init()\n\n        # Choose success based on exceed a threshold with a uniform pick\n        if np.random.rand(1,) < self.prob:\n            self.success += 1\n        y = beta_pdf(self.x, self.success + 1, (i - self.success) + 1)\n        self.line.set_data(self.x, y)\n        return self.line,\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nud = UpdateDist(ax, prob=0.7)\nanim = FuncAnimation(fig, ud, frames=np.arange(100), init_func=ud.init,\n                     interval=100, blit=True)\nplt.show()","dce98045":"%matplotlib notebook\nfrom matplotlib.lines import Line2D\n\n\nclass Scope(object):\n    def __init__(self, ax, maxt=2, dt=0.02):\n        self.ax = ax\n        self.dt = dt\n        self.maxt = maxt\n        self.tdata = [0]\n        self.ydata = [0]\n        self.line = Line2D(self.tdata, self.ydata)\n        self.ax.add_line(self.line)\n        self.ax.set_ylim(-.1, 1.1)\n        self.ax.set_xlim(0, self.maxt)\n\n    def update(self, y):\n        lastt = self.tdata[-1]\n        if lastt > self.tdata[0] + self.maxt:  # reset the arrays\n            self.tdata = [self.tdata[-1]]\n            self.ydata = [self.ydata[-1]]\n            self.ax.set_xlim(self.tdata[0], self.tdata[0] + self.maxt)\n            self.ax.figure.canvas.draw()\n\n        t = self.tdata[-1] + self.dt\n        self.tdata.append(t)\n        self.ydata.append(y)\n        self.line.set_data(self.tdata, self.ydata)\n        return self.line,\n\n\ndef emitter(p=0.03):\n    'return a random value with probability p, else 0'\n    while True:\n        v = np.random.rand(1)\n        if v > p:\n            yield 0.\n        else:\n            yield np.random.rand(1)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nscope = Scope(ax)\n\n# pass a generator in \"emitter\" to produce data for the update func\nani = FuncAnimation(fig, scope.update, emitter, interval=10,\n                              blit=True)","b1f72fb4":"# Import:","e8ff0104":"You can also download map data from APIs in Basemap","97473365":"But this doesn't look that good. What can we do?","7334d7b1":"Now lets plot a point on this globe:","765d09f0":"# 3) Relational Plots","280abccf":"## Animations:","450251a0":"# 5) Multiple Plots:","20bf01fc":"# 6) Interactive Plots:","63d95dee":"Because Latitude and Longitude goes hand in hand, we should look at them together, so we can plot something like this:","082d2bdf":"We can also add confidence interval region for our regression line. We can get confidence interval for our regression like using sklearn's GaussianProcess method. (look [here](https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/04.03-errorbars.html))","e16af5cb":"We can do the same with Latitude vs Longitude:\n\nHere we will use the first one because that is more clear, I think.","8e9a662b":"##### Easy, isn't it?\nYou can actually use most of matplotlib's original functions here like `text`, `plot`, `annotate`, `bar`, `contour`, `hexbin` and even 3D plots on these projections!!\n\nAnd its also has some functions related to geographic plots too like `streamplot`, `quiver` etc.\n\nAnd install this too: `conda install -c conda-forge basemap-data-hires` for 'intermediate', 'high' or 'full' resolution images. Otherwise you have 'crude' and 'low' only.","94b41344":"Word cloud object for generating and drawing.\n\n### Parameters\n\nfont_path : string\n    Font path to the font that will be used (OTF or TTF).\n    Defaults to DroidSansMono path on a Linux machine. If you are on\n    another OS or don't have this font, you need to adjust this path.\n\nwidth : int (default=400)\n    Width of the canvas.\n\nheight : int (default=200)\n    Height of the canvas.\n\nprefer_horizontal : float (default=0.90)\n    The ratio of times to try horizontal fitting as opposed to vertical.\n    If prefer_horizontal < 1, the algorithm will try rotating the word\n    if it doesn't fit. (There is currently no built-in way to get only\n    vertical words.)\n\nmask : nd-array or None (default=None)\n    If not None, gives a binary mask on where to draw words. If mask is not\n    None, width and height will be ignored and the shape of mask will be\n    used instead. All white (#FF or #FFFFFF) entries will be considerd\n    \"masked out\" while other entries will be free to draw on. [This\n    changed in the most recent version!]\n\ncontour_width: float (default=0)\n    If mask is not None and contour_width > 0, draw the mask contour.\n\ncontour_color: color value (default=\"black\")\n    Mask contour color.\n\nscale : float (default=1)\n    Scaling between computation and drawing. For large word-cloud images,\n    using scale instead of larger canvas size is significantly faster, but\n    might lead to a coarser fit for the words.\n\nmin_font_size : int (default=4)\n    Smallest font size to use. Will stop when there is no more room in this\n    size.\n\nfont_step : int (default=1)\n    Step size for the font. font_step > 1 might speed up computation but\n    give a worse fit.\n\nmax_words : number (default=200)\n    The maximum number of words.\n\nstopwords : set of strings or None\n    The words that will be eliminated. If None, the build-in STOPWORDS\n    list will be used. Ignored if using generate_from_frequencies.\n\nbackground_color : color value (default=\"black\")\n    Background color for the word cloud image.\n\nmax_font_size : int or None (default=None)\n    Maximum font size for the largest word. If None, height of the image is\n    used.\n\nmode : string (default=\"RGB\")\n    Transparent background will be generated when mode is \"RGBA\" and\n    background_color is None.\n\nrelative_scaling : float (default='auto')\n    Importance of relative word frequencies for font-size.  With\n    relative_scaling=0, only word-ranks are considered.  With\n    relative_scaling=1, a word that is twice as frequent will have twice\n    the size.  If you want to consider the word frequencies and not only\n    their rank, relative_scaling around .5 often looks good.\n    If 'auto' it will be set to 0.5 unless repeat is true, in which\n    case it will be set to 0.\n\n    .. versionchanged: 2.0\n        Default is now 'auto'.\n\ncolor_func : callable, default=None\n    Callable with parameters word, font_size, position, orientation,\n    font_path, random_state that returns a PIL color for each word.\n    Overwrites \"colormap\".\n    See colormap for specifying a matplotlib colormap instead.\n    To create a word cloud with a single color, use\n    ``color_func=lambda *args, **kwargs: \"white\"``.\n    The single color can also be specified using RGB code. For example\n    ``color_func=lambda *args, **kwargs: (255,0,0)`` sets color to red.\n\nregexp : string or None (optional)\n    Regular expression to split the input text into tokens in process_text.\n    If None is specified, ``r\"\\w[\\w']+\"`` is used. Ignored if using\n    generate_from_frequencies.\n\ncollocations : bool, default=True\n    Whether to include collocations (bigrams) of two words. Ignored if using\n    generate_from_frequencies.\n\n\n    .. versionadded: 2.0\n\ncolormap : string or matplotlib colormap, default=\"viridis\"\n    Matplotlib colormap to randomly draw colors from for each word.\n    Ignored if \"color_func\" is specified.\n\n    .. versionadded: 2.0\n\nnormalize_plurals : bool, default=True\n    Whether to remove trailing 's' from words. If True and a word\n    appears with and without a trailing 's', the one with trailing 's'\n    is removed and its counts are added to the version without\n    trailing 's' -- unless the word ends with 'ss'. Ignored if using\n    generate_from_frequencies.\n\nrepeat : bool, default=False\n    Whether to repeat words and phrases until max_words or min_font_size\n    is reached.\n\n#### Attributes\n\n``words_`` : dict of string to float\n    Word tokens with associated frequency.\n\n    .. versionchanged: 2.0\n        ``words_`` is now a dictionary\n\n``layout_`` : list of tuples (string, int, (int, int), int, color))\n    Encodes the fitted word cloud. Encodes for each word the string, font\n    size, position, orientation and color.\n\n#### Notes\n\nLarger canvases with make the code significantly slower. If you need a\nlarge word cloud, try a lower canvas size, and set the scale parameter.\n\nThe algorithm might give more weight to the ranking of the words\nthan their actual frequencies, depending on the ``max_font_size`` and the\nscaling heuristic.","9535c225":"### c) Violin Plot:","7cc9ee83":"## c) 2d-Hist and Contour Plots:","cbaa6396":"##### That is just too much!! But its not that hard:","e2f5c173":"And likewise you can check distribution of multiple variables:","62d4d96a":"# 4) Categorical Plots:","a5afd91d":"Hmm... cool. I think we are getting somewhere...","ed531745":"### Making Data Talk:","424f3640":"Makes an animation by repeatedly calling a function ``func``.\n\n### Parameters\nfig : matplotlib.figure.Figure\n   The figure object that is used to get draw, resize, and any\n   other needed events.\n\nfunc : callable\n   The function to call at each frame.  The first argument will\n   be the next value in ``frames``.   Any additional positional\n   arguments can be supplied via the ``fargs`` parameter.\n\n   The required signature is::\n\n      def func(frame, *fargs) -> iterable_of_artists:\n\nframes : iterable, int, generator function, or None, optional\n    Source of data to pass ``func`` and each frame of the animation\n\n    If an iterable, then simply use the values provided.  If the\n    iterable has a length, it will override the ``save_count`` kwarg.\n\n    If an integer, then equivalent to passing ``range(frames)``\n\n    If a generator function, then must have the signature::\n\n       def gen_function() -> obj:\n\n    If ``None``, then equivalent to passing ``itertools.count``.\n\n    In all of these cases, the values in *frames* is simply passed through\n    to the user-supplied *func* and thus can be of any type.\n\ninit_func : callable, optional\n   A function used to draw a clear frame. If not given, the\n   results of drawing from the first item in the frames sequence\n   will be used. This function will be called once before the\n   first frame.\n\n   If ``blit == True``, ``init_func`` must return an iterable of artists\n   to be re-drawn.\n\n   The required signature is::\n\n      def init_func() -> iterable_of_artists:\n\nfargs : tuple or None, optional\n   Additional arguments to pass to each call to *func*.\n\nsave_count : int, optional\n   The number of values from *frames* to cache.\n\ninterval : number, optional\n   Delay between frames in milliseconds.  Defaults to 200.\n\nrepeat_delay : number, optional\n   If the animation in repeated, adds a delay in milliseconds\n   before repeating the animation.  Defaults to ``None``.\n\nrepeat : bool, optional\n   Controls whether the animation should repeat when the sequence\n   of frames is completed.  Defaults to ``True``.\n\nblit : bool, optional\n   Controls whether blitting is used to optimize drawing. Note: when using\n   blitting any animated artists will be drawn according to their zorder.\n   However, they will be drawn on top of any previous artists, regardless\n   of their zorder.  Defaults to ``False``.","0cb7b626":"# Others:","326361d2":"Here you can say **seaborn** has taken an edge because of simplisity of making multicategorical box plots.","34aacbf8":"#### Oscilloscope\nEmulates an oscilloscope.","5422abd4":"#### Decay\n\nThis example showcases: \n- using a generator to drive an animation, \n- changing axes limits during an animation.","f57cf9a2":"### a) Histograms \\ KDE:","68c445e0":"## d) Pair Plot:","57701771":"# 2) Distribution Plot","e5b16a7d":"#### Contour plots:","cde2eeba":"### a) Bar plot:","6beba587":"## a) Line Plot (+ Scatter):","7a014037":"## Geographical Plots:","2ec77ae7":"For more cmap's you can look [here](https:\/\/matplotlib.org\/users\/colormaps.html).","fa2c4e1f":"There are only two variables whose relationship is nearly linear. And they are \"AveRooms\" and \"AveBedrms\". And it is obvious.","6b810c58":"There are two types of contour methods available: `plt.contour()` and `plt.contourf()`. First one is for leveled contour and second one is for filled contour. We are using filled contour here.","e118646b":"### b) Box Plot:","1c977e54":"#### Making data talk:","e69fc9a5":"Sets up a basemap with specified map projection.\nand creates the coastline data structures in map projection\ncoordinates.\n\nCalling a Basemap class instance with the arguments lon, lat will\nconvert lon\/lat (in degrees) to x\/y map projection coordinates\n(in meters). The inverse transformation is done if the optional keyword\n``inverse`` is set to True.\n\nThe desired projection is set with the projection keyword. Default is ``cyl``.\nSupported values for the projection keyword are:\n\n`cyl`:              Cylindrical Equidistant  \n\n`merc`:             Mercator                                \n\n`tmerc`:            Transverse Mercator                     \n\n`omerc`:            Oblique Mercator                        \n\n`mill`:             Miller Cylindrical                      \n\n`gall`:             Gall Stereographic Cylindrical          \n\n`cea`:              Cylindrical Equal Area                  \n\n`lcc`:              Lambert Conformal                       \n\n`laea`:             Lambert Azimuthal Equal Area            \n\n`nplaea`:           North-Polar Lambert Azimuthal           \n\n`splaea`:           South-Polar Lambert Azimuthal           \n\n`eqdc`:             Equidistant Conic                       \n\n`aeqd`:             Azimuthal Equidistant                   \n\n`npaeqd`:           North-Polar Azimuthal Equidistant       \n\n`spaeqd`:           South-Polar Azimuthal Equidistant       \n\n`aea`:              Albers Equal Area                       \n\n`stere`:            Stereographic                           \n\n`npstere`:          North-Polar Stereographic               \n\n`spstere`:          South-Polar Stereographic               \n\n`cass`:             Cassini-Soldner                         \n\n`poly`:             Polyconic                               \n\n`ortho`:            Orthographic                            \n\n`geos`:             Geostationary                           \n\n`nsper`:            Near-Sided Perspective                  \n\n`sinu`:             Sinusoidal                              \n\n`moll`:             Mollweide                               \n\n`hammer`:           Hammer                                  \n\n`robin`:            Robinson                                \n\n`kav7`:             Kavrayskiy VII                          \n\n`eck4`:             Eckert IV                               \n\n`vandg`:            van der Grinten                         \n\n`mbtfpq`:           McBryde-Thomas Flat-Polar Quartic       \n\n`gnom`:             Gnomonic                                \n\n`rotpole`:          Rotated Pole                            \n\n---\n---\n\nFor most map projections, the map projection region can either be\nspecified by setting these keywords:\n\n.. tabularcolumns:: |l|L|\n\n`llcrnrlon`:        longitude of lower left hand corner of the desired map\n                 domain (degrees).\n\n`llcrnrlat`:        latitude of lower left hand corner of the desired map\n                 domain (degrees).\n\n`urcrnrlon`:        longitude of upper right hand corner of the desired map\n                 domain (degrees).\n\n`urcrnrlat`:        latitude of upper right hand corner of the desired map\n                 domain (degrees).\n\n---\n---\n\nor these\n\n.. tabularcolumns:: |l|L|\n\n\n`width`:            width of desired map domain in projection coordinates\n                 (meters).\n\n`height`:           height of desired map domain in projection coordinates\n                 (meters).\n\n`lon_0`:            center of desired map domain (in degrees).\n\n`lat_0`:            center of desired map domain (in degrees).\n\n---\n---\n\nFor ``sinu``, ``moll``, ``hammer``, ``npstere``, ``spstere``, ``nplaea``, ``splaea``,\n``npaeqd``, ``spaeqd``, ``robin``, ``eck4``, ``kav7``, or ``mbtfpq``, the values of\nllcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, width and height are ignored\n(because either they are computed internally, or entire globe is\nalways plotted).\n\nFor the cylindrical projections (``cyl``, ``merc``, ``mill``, ``cea``  and ``gall``),\nthe default is to use\nllcrnrlon=-180,llcrnrlat=-90, urcrnrlon=180 and urcrnrlat=90). For all other\nprojections except ``ortho``, ``geos`` and ``nsper``, either the lat\/lon values of the\ncorners or width and height must be specified by the user.\n\nFor ``ortho``, ``geos`` and ``nsper``, the lat\/lon values of the corners may be specified,\nor the x\/y values of the corners (llcrnrx,llcrnry,urcrnrx,urcrnry) in the\ncoordinate system of the global projection (with x=0,y=0 at the center\nof the global projection).  If the corners are not specified,\nthe entire globe is plotted.\n\nFor ``rotpole``, the lat\/lon values of the corners on the unrotated sphere\nmay be provided as llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat, or the lat\/lon\nvalues of the corners on the rotated sphere can be given as\nllcrnrx,llcrnry,urcrnrx,urcrnry.\n\nOther keyword arguments:\n\n.. tabularcolumns:: |l|L|\n\n`resolution`:       resolution of boundary database to use. Can be ``c``\n                 (crude), ``l`` (low), ``i`` (intermediate), ``h``\n                 (high), ``f`` (full) or None.\n                 If None, no boundary data will be read in (and\n                 class methods such as drawcoastlines will raise an\n                 if invoked).\n                 Resolution drops off by roughly 80% between datasets.\n                 Higher res datasets are much slower to draw.\n                 Default ``c``. Coastline data is from the GSHHS\n                 (http:\/\/www.soest.hawaii.edu\/wessel\/gshhs\/gshhs.html).\n                 State, country and river datasets from the Generic\n                 Mapping Tools (http:\/\/gmt.soest.hawaii.edu).\n\n`area_thresh`:      coastline or lake with an area smaller than\n                 area_thresh in km^2 will not be plotted.\n                 Default 10000,1000,100,10,1 for resolution\n                 ``c``, ``l``, ``i``, ``h``, ``f``.\n\n`rsphere`:          radius of the sphere used to define map projection\n                 (default 6370997 meters, close to the arithmetic mean\n                 radius of the earth). If given as a sequence, the\n                 first two elements are interpreted as the radii\n                 of the major and minor axes of an ellipsoid.\n                 Note: sometimes an ellipsoid is specified by the\n                 major axis and an inverse flattening parameter (if).\n                 The minor axis (b) can be computed from the major\n                 axis (a) and the inverse flattening parameter using\n                 the formula if = a\/(a-b).\n\n`ellps`:            string describing ellipsoid ('GRS80' or 'WGS84',\n                 for example). If both rsphere and ellps are given,\n                 rsphere is ignored. Default None. See pyproj.pj_ellps\n                 for allowed values.\n\n`suppress_ticks`:   suppress automatic drawing of axis ticks and labels\n                 in map projection coordinates.  Default True,\n                 so parallels and meridians can be labelled instead.\n                 If parallel or meridian labelling is requested\n                 (using drawparallels and drawmeridians methods),\n                 automatic tick labelling will be supressed even if\n                 suppress_ticks=False.  suppress_ticks=False\n                 is useful if you want to use your own custom tick\n                 formatter, or  if you want to let matplotlib label\n                 the axes in meters using map projection\n                 coordinates.\n\n`fix_aspect`:       fix aspect ratio of plot to match aspect ratio\n                 of map projection region (default True).\n\n`anchor`:           determines how map is placed in axes rectangle\n                 (passed to axes.set_aspect). Default is ``C``,\n                 which means map is centered.\n                 Allowed values are\n                 ``C``, ``SW``, ``S``, ``SE``, ``E``, ``NE``,\n                 ``N``, ``NW``, and ``W``.\n\n`celestial`:        use astronomical conventions for longitude (i.e.\n                 negative longitudes to the east of 0). Default False.\n                 Implies resolution=None.\n\n`ax`:               set default axes instance\n                 (default None - matplotlib.pyplot.gca() may be used\n                 to get the current axes instance).\n                 If you do not want matplotlib.pyplot to be imported,\n                 you can either set this to a pre-defined axes\n                 instance, or use the ``ax`` keyword in each Basemap\n                 method call that does drawing. In the first case,\n                 all Basemap method calls will draw to the same axes\n                 instance.  In the second case, you can draw to\n                 different axes with the same Basemap instance.\n                 You can also use the ``ax`` keyword in individual\n                 method calls to selectively override the default\n                 axes instance.\n\n---\n---\n\nThe following keywords are map projection parameters which all default to\nNone.  Not all parameters are used by all projections, some are ignored.\nThe module variable ``projection_params`` is a dictionary which\nlists which parameters apply to which projections.\n\n.. tabularcolumns:: |l|L|\n\n`lat_ts`:           latitude of true scale. Optional for stereographic,\n                 cylindrical equal area and mercator projections.\n                 default is lat_0 for stereographic projection.\n                 default is 0 for mercator and cylindrical equal area\n                 projections.\n\n`lat_1`:            first standard parallel for lambert conformal,\n                 albers equal area and equidistant conic.\n                 Latitude of one of the two points on the projection\n                 centerline for oblique mercator. If lat_1 is not given, but\n                 lat_0 is, lat_1 is set to lat_0 for lambert\n                 conformal, albers equal area and equidistant conic.\n\n`lat_2`:            second standard parallel for lambert conformal,\n                 albers equal area and equidistant conic.\n                 Latitude of one of the two points on the projection\n                 centerline for oblique mercator. If lat_2 is not\n                 given it is set to lat_1 for lambert conformal,\n                 albers equal area and equidistant conic.\n\n`lon_1`:            Longitude of one of the two points on the projection\n                 centerline for oblique mercator.\n\n`lon_2`:            Longitude of one of the two points on the projection\n                 centerline for oblique mercator.\n\n`k_0`:              Scale factor at natural origin (used\n                 by 'tmerc', 'omerc', 'stere' and 'lcc').\n\n`no_rot`:           only used by oblique mercator.\n                 If set to True, the map projection coordinates will\n                 not be rotated to true North.  Default is False\n                 (projection coordinates are automatically rotated).\n\n`lat_0`:            central latitude (y-axis origin) - used by all\n                 projections.\n\n`lon_0`:            central meridian (x-axis origin) - used by all\n                 projections.\n\n`o_lat_p`:          latitude of rotated pole (only used by 'rotpole')\n\n`o_lon_p`:          longitude of rotated pole (only used by 'rotpole')\n\n`boundinglat`:      bounding latitude for pole-centered projections\n                 (npstere,spstere,nplaea,splaea,npaeqd,spaeqd).\n                 These projections are square regions centered\n                 on the north or south pole.\n                 The longitude lon_0 is at 6-o'clock, and the\n                 latitude circle boundinglat is tangent to the edge\n                 of the map at lon_0.\n\n`round`:            cut off pole-centered projection at boundinglat\n                 (so plot is a circle instead of a square). Only\n                 relevant for npstere,spstere,nplaea,splaea,npaeqd\n                 or spaeqd projections. Default False.\n\n`satellite_height`: height of satellite (in m) above equator -\n                 only relevant for geostationary\n                 and near-sided perspective (``geos`` or ``nsper``)\n                 projections. Default 35,786 km.\n\n---\n---\n\nUseful instance variables:\n\n.. tabularcolumns:: |l|L|\n\n`projection`:       map projection. Print the module variable\n                 ``supported_projections`` to see a list of allowed\n                 values.\n\n`epsg`:             EPSG code defining projection (see\n                 http:\/\/spatialreference.org for a list of\n                 EPSG codes and their definitions).\n\n`aspect`:           map aspect ratio\n                 (size of y dimension \/ size of x dimension).\n\n`llcrnrlon`:        longitude of lower left hand corner of the\n                 selected map domain.\n\n`llcrnrlat`:        latitude of lower left hand corner of the\n                 selected map domain.\n\n`urcrnrlon`:        longitude of upper right hand corner of the\n                 selected map domain.\n\n`urcrnrlat`:        latitude of upper right hand corner of the\n                 selected map domain.\n\n`llcrnrx`:          x value of lower left hand corner of the\n                 selected map domain in map projection coordinates.\n\n`llcrnry`:          y value of lower left hand corner of the\n                 selected map domain in map projection coordinates.\n\n`urcrnrx`:          x value of upper right hand corner of the\n                 selected map domain in map projection coordinates.\n\n`urcrnry`:          y value of upper right hand corner of the\n                 selected map domain in map projection coordinates.\n\n`rmajor`:           equatorial radius of ellipsoid used (in meters).\n\n`rminor`:           polar radius of ellipsoid used (in meters).\n\n`resolution`:       resolution of boundary dataset being used (``c``\n                 for crude, ``l`` for low, etc.).\n                 If None, no boundary dataset is associated with the\n                 Basemap instance.\n\n`proj4string`:      the string describing the map projection that is\n                 used by PROJ.4.\n\n---\n---\n\n**Converting from Geographic (lon\/lat) to Map Projection (x\/y) Coordinates**\n\nCalling a Basemap class instance with the arguments lon, lat will\nconvert lon\/lat (in degrees) to x\/y map projection\ncoordinates (in meters).  If optional keyword ``inverse`` is\nTrue (default is False), the inverse transformation from x\/y\nto lon\/lat is performed.\n\nFor cylindrical equidistant projection (``cyl``), this\ndoes nothing (i.e. x,y == lon,lat).\n\nFor non-cylindrical projections, the inverse transformation\nalways returns longitudes between -180 and 180 degrees. For\ncylindrical projections (self.projection == ``cyl``, ``mill``,\n``cea``, ``gall`` or ``merc``)\nthe inverse transformation will return longitudes between\nself.llcrnrlon and self.llcrnrlat.\n\nInput arguments lon, lat can be either scalar floats, sequences\nor numpy arrays.","530ad4ca":"We are going to make a 2D array and for point in dataframe we will matrix value of that location to average of all target values for that point.","cf22a283":"## Word Cloud Plot:","a0ceec72":"# Dataset:","8fb49685":"This kernel goes with a post I wrote on Towards Data Science:\n\n[Make your Data Talk! - From 0 to Hero in visualization using matplotlib and seaborn](https:\/\/towardsdatascience.com\/make-your-data-talk-13072f84eeac) (Read it before jumping to it)\n\nAnd is a part of series `Tackle` which you can find on Github, [here](https:\/\/github.com\/PuneetGrov3r\/MediumPosts\/tree\/master\/Tackle), and are:\n\n1. [How to learn from BigData Files on low memory\u200a-\u200aIncremental Learning](https:\/\/towardsdatascience.com\/how-to-learn-from-bigdata-files-on-low-memory-incremental-learning-d377282d38ff)\n2. [Make your Data Talk!- From 0 to Hero in visualization with matplotlib and seaborn](https:\/\/medium.com\/@grover.puneet1995\/make-your-data-talk-13072f84eeac)","432ee34e":"For more info look [here](https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/04.09-text-and-annotation.html).","18070962":"## 3D plots:","a802c91e":"#### The Bayes update\nThis animation displays the posterior estimate updates as it is refitted when new data arrives. The vertical line represents the theoretical value to which the plotted distribution should converge.","38f52eb1":"### Scatter Plot (1):","7994ae68":"# Initial:","99f064f9":"Contour plots are mainly used for visualizing a 3D or 4D **function** on 2D or 3D graph.\n\nWe don't have a function for our *target*, but we can still make a contour plot like this:","36a77631":"We will first make our variable's values considerable and convert them to integers, as we will be using these values as indexs in an array (which we will plot as contour).","6f88a037":"Method for joining midpoint of histogram is taken from [here](https:\/\/stackoverflow.com\/questions\/47343096\/joining-midpoints-of-a-histogram-by-line).","9c63b8ab":"## b) Scatter Plot:","76fbc3ef":"Let's first make some categorical variables:","fd0c1ced":"### Line Plot:","cf45288a":"### a) Joint Distribution:"}}