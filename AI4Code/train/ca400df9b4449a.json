{"cell_type":{"33065225":"code","57bf78e6":"code","c4badcb2":"code","0f89c02f":"code","2e810b37":"code","8cb629eb":"code","752b39d1":"code","2236cc54":"code","ba89101d":"code","1462416a":"code","b8f18d1b":"code","e98f1dff":"code","bb5d2182":"code","819b832d":"code","3f988282":"code","079eb4e7":"code","845b7eab":"code","32e651f8":"code","cc3f97e7":"code","305efe98":"code","f1454984":"code","166516ee":"code","0cee4168":"code","ba22bfd4":"code","4b8f6030":"code","d606ed91":"code","5942c5fd":"code","0c79f174":"code","4b539ac8":"code","7712471f":"code","b9debe82":"code","687ad761":"code","0840cd31":"code","4e368928":"code","0a535d1b":"markdown","c2a64245":"markdown","9479a776":"markdown","5989c0dd":"markdown","1d6df84b":"markdown","a6f2f799":"markdown","e78b6d2a":"markdown","97fb8868":"markdown","11140f29":"markdown","cf712134":"markdown","f3f56f3d":"markdown","84545b13":"markdown","c0cdaf72":"markdown","1a4ca8e5":"markdown","8e381c04":"markdown"},"source":{"33065225":"!pip install chart_studio","57bf78e6":"import warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom keras import optimizers\nfrom keras.utils import plot_model\nfrom keras.models import Sequential, Model\nfrom keras.layers.convolutional import Conv1D, MaxPooling1D\nfrom keras.layers import Dense, LSTM, RepeatVector, TimeDistributed, Flatten\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import train_test_split\nimport chart_studio.plotly as py\nimport plotly.graph_objs as go\nfrom plotly.offline import init_notebook_mode, iplot\n\n%matplotlib inline\nwarnings.filterwarnings(\"ignore\")\ninit_notebook_mode(connected=True)\n\n# Set seeds to make the experiment more reproducible.\nimport tensorflow as tf\nfrom numpy.random import seed\ntf.random.set_seed(1)\nseed(1)","c4badcb2":"import numpy as np \ndata = pd.read_csv('..\/input\/climate-hour\/climate_hour.csv', parse_dates=['Date Time'])\ndata = data[['Date Time','T (degC)']]\ntrain, test= np.split(data, [int(.75 *len(data))])","0f89c02f":"#lag_size = (test['Date Time'].max().date() - train['Date Time'].max().date()).days\nlag_size = 24\nprint('Max date from train set: %s' % train['Date Time'].max().date())\nprint('Max date from test set: %s' % test['Date Time'].max().date())\nprint('Forecast lag size', lag_size)","2e810b37":"daily_temperatures = train.groupby('Date Time', as_index=False)['T (degC)'].sum()\ndaily_temp_sc = go.Scatter(x=daily_temperatures['Date Time'], y=daily_temperatures['T (degC)'])\nlayout = go.Layout(title='Daily Temperature', xaxis=dict(title='Date Time'), yaxis=dict(title='Temperature'))\nfig = go.Figure(data=[daily_temp_sc], layout=layout)\niplot(fig)","8cb629eb":"train_gp = train.sort_values('Date Time').groupby(['Date Time','T (degC)'], as_index=False)\ntrain_gp.columns = ['T (degC)']\ntrain_gp.head()","752b39d1":"def series_to_supervised(data, window=1, lag=1, dropnan=True):\n    cols, names = list(), list()\n    # Input sequence (t-n, ... t-1)\n    for i in range(window, 0, -1):\n        cols.append(data.shift(i))\n        names += [('%s(t-%d)' % (col, i)) for col in data.columns]\n    # Current timestep (t=0)\n    cols.append(data)\n    names += [('%s(t)' % (col)) for col in data.columns]\n    # Target timestep (t=lag)\n    cols.append(data.shift(-lag))\n    names += [('%s(t+%d)' % (col, lag)) for col in data.columns]\n    # Put it all together\n    agg = pd.concat(cols, axis=1)\n    agg.columns = names\n    # Drop rows with NaN values\n    if dropnan:\n        agg.dropna(inplace=True)\n    return agg","2236cc54":"window = 24\nlag = lag_size\nseries = series_to_supervised(train.drop('Date Time', axis=1), window=window, lag=lag)\nseries.head()","ba89101d":"# Label\nlabels_col = 'T (degC)(t+%d)' % lag_size\nlabels = series[labels_col]\nseries = series.drop(labels_col, axis=1)\n\nX_train, X_valid, Y_train, Y_valid = train_test_split(series, labels.values, test_size=0.4, random_state=0)\nprint('Train set shape', X_train.shape)\nprint('Validation set shape', X_valid.shape)\nX_train.head()","1462416a":"epochs = 100\nbatch = 254\nlr = 0.0003\nadam = optimizers.Adam(lr)","b8f18d1b":"model_mlp = Sequential()\nmodel_mlp.add(Dense(100, activation='relu', input_dim=X_train.shape[1]))\nmodel_mlp.add(Dense(100, activation='relu', input_dim=X_train.shape[1]))\nmodel_mlp.add(Dense(1))\nmodel_mlp.compile(loss='mse', optimizer=adam, metrics=['accuracy'])\nmodel_mlp.summary()","e98f1dff":"mlp_history = model_mlp.fit(X_train.values, Y_train, validation_data=(X_valid.values, Y_valid), epochs=epochs, verbose=2)","bb5d2182":"import matplotlib.pyplot as plt \nmlp_train_loss = mlp_history.history['loss']\nmlp_test_loss = mlp_history.history['val_loss']\n\nepoch_count = range(1, len(mlp_train_loss)+1)\n\nplt.plot(epoch_count, mlp_train_loss)\nplt.plot(epoch_count, mlp_test_loss)\nplt.title('loss history')\nplt.legend(['train', 'validation'])\nplt.xlabel('Epoch')\nplt.xlabel('Loss')\nplt.show()","819b832d":"import matplotlib.pyplot as plt \nmlp_train_acc = mlp_history.history['accuracy']\nmlp_test_acc = mlp_history.history['val_accuracy']\n\nepoch_count = range(1, len(mlp_train_acc)+1)\n\nplt.plot(epoch_count, mlp_train_acc)\nplt.plot(epoch_count, mlp_test_acc)\nplt.title('accuracy history')\nplt.legend(['train', 'validation'])\nplt.xlabel('Epoch')\nplt.xlabel('Accuracy')\nplt.show()","3f988282":"X_train_series = X_train.values.reshape((X_train.shape[0], X_train.shape[1], 1))\nX_valid_series = X_valid.values.reshape((X_valid.shape[0], X_valid.shape[1], 1))\nprint('Train set shape', X_train_series.shape)\nprint('Validation set shape', X_valid_series.shape)","079eb4e7":"model_cnn = Sequential()\nmodel_cnn.add(Conv1D(filters=64, kernel_size=2, activation='relu', input_shape=(X_train_series.shape[1], X_train_series.shape[2])))\nmodel_cnn.add(MaxPooling1D(pool_size=2))\nmodel_cnn.add(Flatten())\nmodel_cnn.add(Dense(50, activation='relu'))\nmodel_cnn.add(Dense(1))\nmodel_cnn.compile(loss='mse', optimizer=adam, metrics=['accuracy'])\nmodel_cnn.summary()","845b7eab":"cnn_history = model_cnn.fit(X_train_series, Y_train, validation_data=(X_valid_series, Y_valid), epochs=epochs, verbose=2)","32e651f8":"import matplotlib.pyplot as plt \ncnn_train_loss = cnn_history.history['loss']\ncnn_test_loss = cnn_history.history['val_loss']\n\nepoch_count = range(1, len(cnn_train_loss)+1)\n\nplt.plot(epoch_count, cnn_train_loss)\nplt.plot(epoch_count, cnn_test_loss)\nplt.title('loss history')\nplt.legend(['train', 'validation'])\nplt.xlabel('Epoch')\nplt.xlabel('Accuracy')\nplt.show()","cc3f97e7":"import matplotlib.pyplot as plt \ncnn_train_acc = cnn_history.history['accuracy']\ncnn_test_acc = cnn_history.history['val_accuracy']\n\nepoch_count = range(1, len(cnn_train_acc)+1)\n\nplt.plot(epoch_count, cnn_train_acc)\nplt.plot(epoch_count, cnn_test_acc)\nplt.title('accuracy history')\nplt.legend(['train', 'validation'])\nplt.xlabel('Epoch')\nplt.xlabel('Accuracy')\nplt.show()","305efe98":"model_lstm = Sequential()\nmodel_lstm.add(LSTM(50, activation='relu', input_shape=(X_train_series.shape[1], X_train_series.shape[2])))\nmodel_lstm.add(Dense(1))\nmodel_lstm.compile(loss='mse', optimizer=adam, metrics=['accuracy'])\nmodel_lstm.summary()","f1454984":"lstm_history = model_lstm.fit(X_train_series, Y_train, validation_data=(X_valid_series, Y_valid), epochs=epochs, verbose=2)","166516ee":"import matplotlib.pyplot as plt \nlstm_train_loss = lstm_history.history['loss']\nlstm_test_loss = lstm_history.history['val_loss']\n\nepoch_count = range(1, len(lstm_train_loss)+1)\n\nplt.plot(epoch_count, lstm_train_loss)\nplt.plot(epoch_count, lstm_test_loss)\nplt.title('loss history')\nplt.legend(['train', 'test'])\nplt.xlabel('Epoch')\nplt.xlabel('Loss')\nplt.show()","0cee4168":"import matplotlib.pyplot as plt \nlstm_train_acc = lstm_history.history['accuracy']\nlstm_test_acc = lstm_history.history['val_accuracy']\n\nepoch_count = range(1, len(lstm_train_acc)+1)\n\nplt.plot(epoch_count, lstm_train_acc)\nplt.plot(epoch_count, lstm_test_acc)\nplt.title('accuracy history')\nplt.legend(['train', 'validation'])\nplt.xlabel('Epoch')\nplt.xlabel('Accuracy')\nplt.show()","ba22bfd4":"subsequences = 5\ntimesteps = X_train_series.shape[1]\/\/subsequences\nX_train_series_sub = X_train_series.reshape((X_train_series.shape[0], subsequences, timesteps, 1))\nX_valid_series_sub = X_valid_series.reshape((X_valid_series.shape[0], subsequences, timesteps, 1))\nprint('Train set shape', X_train_series_sub.shape)\nprint('Validation set shape', X_valid_series_sub.shape)","4b8f6030":"model_cnn_lstm = Sequential()\nmodel_cnn_lstm.add(TimeDistributed(Conv1D(filters=64, kernel_size=1, activation='relu'), input_shape=(None, X_train_series_sub.shape[2], X_train_series_sub.shape[3])))\nmodel_cnn_lstm.add(TimeDistributed(MaxPooling1D(pool_size=2)))\nmodel_cnn_lstm.add(TimeDistributed(Flatten()))\nmodel_cnn_lstm.add(LSTM(50, activation='relu'))\nmodel_cnn_lstm.add(Dense(1))\nmodel_cnn_lstm.compile(loss='mse', optimizer=adam, metrics=['accuracy'])","d606ed91":"cnn_lstm_history = model_cnn_lstm.fit(X_train_series_sub, Y_train, validation_data=(X_valid_series_sub, Y_valid), epochs=epochs, verbose=2)","5942c5fd":"import matplotlib.pyplot as plt \ncnn_lstm_train_loss = cnn_lstm_history.history['loss']\ncnn_lstm_test_loss = cnn_lstm_history.history['val_loss']\n\nepoch_count = range(1, len(cnn_lstm_train_loss)+1)\n\nplt.plot(epoch_count, cnn_lstm_train_loss)\nplt.plot(epoch_count, cnn_lstm_test_loss)\nplt.title('loss history')\nplt.legend(['train', 'test'])\nplt.xlabel('Epoch')\nplt.xlabel('Loss')\nplt.show()","0c79f174":"import matplotlib.pyplot as plt \ncnn_lstm_train_acc = cnn_lstm_history.history['accuracy']\ncnn_lstm_test_acc = cnn_lstm_history.history['val_accuracy']\n\nepoch_count = range(1, len(cnn_lstm_train_acc)+1)\n\nplt.plot(epoch_count, cnn_lstm_train_acc)\nplt.plot(epoch_count, cnn_lstm_test_acc)\nplt.title('accuracy history')\nplt.legend(['train', 'validation'])\nplt.xlabel('Epoch')\nplt.xlabel('Accuracy')\nplt.show()","4b539ac8":"fig, axes = plt.subplots(2, 2, sharex=True, sharey=True,figsize=(22,12))\nax1, ax2 = axes[0]\nax3, ax4 = axes[1]\n\nax1.plot(mlp_history.history['loss'], label='Train loss')\nax1.plot(mlp_history.history['val_loss'], label='Validation loss')\nax1.legend(loc='best')\nax1.set_title('MLP')\nax1.set_xlabel('Epochs')\nax1.set_ylabel('MSE')\n\nax2.plot(cnn_history.history['loss'], label='Train loss')\nax2.plot(cnn_history.history['val_loss'], label='Validation loss')\nax2.legend(loc='best')\nax2.set_title('CNN')\nax2.set_xlabel('Epochs')\nax2.set_ylabel('MSE')\n\nax3.plot(lstm_history.history['loss'], label='Train loss')\nax3.plot(lstm_history.history['val_loss'], label='Validation loss')\nax3.legend(loc='best')\nax3.set_title('LSTM')\nax3.set_xlabel('Epochs')\nax3.set_ylabel('MSE')\n\nax4.plot(cnn_lstm_history.history['loss'], label='Train loss')\nax4.plot(cnn_lstm_history.history['val_loss'], label='Validation loss')\nax4.legend(loc='best')\nax4.set_title('CNN-LSTM')\nax4.set_xlabel('Epochs')\nax4.set_ylabel('MSE')\n\nplt.show()","7712471f":"fig, axes = plt.subplots(2, 2, sharex=True, sharey=True,figsize=(22,12))\nax1, ax2 = axes[0]\nax3, ax4 = axes[1]\n\nax1.plot(mlp_history.history['accuracy'], label='Train accuracy')\nax1.plot(mlp_history.history['val_accuracy'], label='Validation accuracy')\nax1.legend(loc='best')\nax1.set_title('MLP')\nax1.set_xlabel('Epochs')\nax1.set_ylabel('ACCURACY')\n\nax2.plot(cnn_history.history['accuracy'], label='Train acc')\nax2.plot(cnn_history.history['val_accuracy'], label='Validation acc')\nax2.legend(loc='best')\nax2.set_title('CNN')\nax2.set_xlabel('Epochs')\nax2.set_ylabel('ACCURACY')\n\nax3.plot(lstm_history.history['accuracy'], label='Train acc')\nax3.plot(lstm_history.history['val_accuracy'], label='Validation acc')\nax3.legend(loc='best')\nax3.set_title('LSTM')\nax3.set_xlabel('Epochs')\nax3.set_ylabel('ACCYRACY')\n\nax4.plot(cnn_lstm_history.history['accuracy'], label='Train acc')\nax4.plot(cnn_lstm_history.history['val_accuracy'], label='Validation acc')\nax4.legend(loc='best')\nax4.set_title('CNN-LSTM')\nax4.set_xlabel('Epochs')\nax4.set_ylabel('ACCURACY')\n\nplt.show()","b9debe82":"mlp_train_pred = model_mlp.predict(X_train.values)\nmlp_valid_pred = model_mlp.predict(X_valid.values)\nprint('Train rmse:', np.sqrt(mean_squared_error(Y_train, mlp_train_pred)))\nprint('Validation rmse:', np.sqrt(mean_squared_error(Y_valid, mlp_valid_pred)))","687ad761":"cnn_train_pred = model_cnn.predict(X_train_series)\ncnn_valid_pred = model_cnn.predict(X_valid_series)\nprint('Train rmse:', np.sqrt(mean_squared_error(Y_train, cnn_train_pred)))\nprint('Validation rmse:', np.sqrt(mean_squared_error(Y_valid, cnn_valid_pred)))","0840cd31":"lstm_train_pred = model_lstm.predict(X_train_series)\nlstm_valid_pred = model_cnn.predict(X_valid_series)\nprint('Train rmse:', np.sqrt(mean_squared_error(Y_train, lstm_train_pred)))\nprint('Validation rmse:', np.sqrt(mean_squared_error(Y_valid, lstm_valid_pred)))","4e368928":"cnn_lstm_train_pred = model_cnn_lstm.predict(X_train_series_sub)\ncnn_lstm_valid_pred = model_cnn_lstm.predict(X_valid_series_sub)\nprint('Train rmse:', np.sqrt(mean_squared_error(Y_train, cnn_lstm_train_pred)))\nprint('Validation rmse:', np.sqrt(mean_squared_error(Y_valid, cnn_lstm_valid_pred)))","0a535d1b":"***Transform the data into a time series problem***","c2a64245":"***Train\/validation split***","9479a776":"**MLP on train and validation**","5989c0dd":"**CNN-LSTM for Time Series Forecasting**\n* Input shape **[samples, subsequences, timesteps, features]**.","1d6df84b":"**CNN-LSTM on train and validation**","a6f2f799":"**Comparing models**","e78b6d2a":"**MLP for Time Series Forecasting**\n* First we will use a Multilayer Perceptron model or MLP model, here our model will have input features equal to the window size.\n* The thing with MLP models is that the model don't take the input as sequenced data, so for the model, it is just receiving inputs and don't treat them as sequenced data, that may be a problem since the model won't see the data with the sequence patter that it has.\n* Input shape **[samples, timesteps]**.","97fb8868":"***We will use the current timestep and the last 29 to forecast 90 days ahead***","11140f29":"**LSTM for Time Series Forecasting**\n* Now the LSTM model actually sees the input data as a sequence, so it's able to learn patterns from sequenced data (assuming it exists) better than the other ones, especially patterns from long sequences.\n* Input shape **[samples, timesteps, features]**.","cf712134":"**CNN for Time Series Forecasting**\n* For the CNN model we will use one convolutional hidden layer followed by a max pooling layer. The filter maps are then flattened before being interpreted by a Dense layer and outputting a prediction.\n* The convolutional layer should be able to identify patterns between the timesteps.\n* Input shape **[samples, timesteps, features]**.","f3f56f3d":"**LSTM on train and validation**","84545b13":"**Data preprocess**\n* Reshape from **[samples, timesteps]** into **[samples, timesteps, features]**.\n* This same reshaped data will be used on the CNN and the LSTM model.","c0cdaf72":"Rearrange dataset so we can apply shift methods","1a4ca8e5":"**Data preprocess**\n* Reshape from **[samples, timesteps, features]** into **[samples, subsequences, timesteps, features]**.","8e381c04":"**CNN on train and validation**"}}