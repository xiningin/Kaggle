{"cell_type":{"48d49392":"code","2b93a2b2":"code","141629c8":"code","26f1a3bf":"code","c52659e7":"code","1a051608":"markdown","d8edeff3":"markdown","2b28f1fa":"markdown","c5953066":"markdown","e54c1805":"markdown","c7a20b65":"markdown","7ecaec29":"markdown","338fb519":"markdown","e1356949":"markdown"},"source":{"48d49392":"%%writefile santa2021-2440.cpp\n#include <fstream>\n#include <array>\n#include <string>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    array<string, 3> lines; \/\/ solution under construction (\"01\" is the mandatory starting sequence, '2' to '6' are the other symbols)\n    auto N = 0; \/\/ number of iterations performed, in order to keep track of the jokers count and to balance strings' sizes\n    string table{\"23456\"}; \/\/ We loop through all permutations of this \"table\" starting with '2' (only the \"3456\" part is reordered)\n    do {\n        \/\/ helper to translate \"ABCDE\" -> current \"23456\" table\n        const auto translate = [&](string chunk) {\n            for (auto& c: chunk)\n                if (c > '1')\n                    c = table[c - 'A'];\n            return chunk;\n        };\n        \/\/ Construction of the chunks that will be added to each of the 3 lines for the current table\n        const auto patterns = array{ \n            \/* line 0 *\/ \"01BCDEA10BCDEA1B0CDEA1BC0DEA1BCD0EA1BCDE0A1BCDE\" \/\/ =X(BCDEA), just before \"01ABCDE\" to ensure \"BCDE01ABCD\"\n                         \"01ABCDE10ABCDE1A0BCDE1AB0CDE1ABC0DE1ABCD0E1ABCD\" \/\/ same\n                         \"01EABCD\"\n                         \"01DEABC\"\n                         \"01CDEAB\",\n\n            \/* line 1 *\/ \"01ABCDE\"\n                         \"01EABCD10EABCD1E0ABCD1EA0BCD1EAB0CD1EABC0D1EABC\" \/\/ ...\n                         \"01DEABC10DEABC1D0EABC1DE0ABC1DEA0BC1DEAB0C1DEAB\"\n                         \"01CDEAB\"\n                         \"01BCDEA\", \/\/ make sure that the 3 patterns[i] finish with different strings to ensure the presence of all \"xxxxx01\" in at least one of the lines\n\n            \/* line 2 *\/ \"01ABCDE\"\n                         \"01DEABC\"\n                         \"01CDEAB10CDEAB1C0DEAB1CD0EAB1CDE0AB1CDEA0B1CDEA\"\n                         \"01BCDEA\"\n                         \"01EABCD\" };                \n        \/\/ Append chunks to solution\n        for (auto line_index: {0, 1, 2})\n            lines[(line_index + N) % 3] += translate(patterns[line_index]); \/\/ use N to balance the size of the 3 lines\n        ++N; \/\/ increment the iteration number\n    }\n    while (next_permutation(table.begin() + 1, table.end())); \/\/ End of loop through permutations of table starting with '2'\n\n    \/\/ Write solution to file\n    ofstream file{\"solution-2440.csv\"};\n    file << \"schedule\\n\";\n    for (auto line: lines)\n        file << line << \"\\n\";\n    return 0;\n}","2b93a2b2":"!g++ -s -O3 -std=c++2a santa2021-2440.cpp -o santa2021-2440.exe && .\/santa2021-2440.exe && cat solution-2440.csv","141629c8":"%%writefile santa2021.cpp\n#include <fstream>\n#include <vector>\n#include <array>\n#include <set>\n#include <string>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    vector<string> lines(3); \/\/ solution under construction (\"01\" is the mandatory starting sequence, '2' to '6' are the other symbols)\n    set<string> duplicates; \/\/ to simplify jokers management, some temporary permutations are added ahead of time, they will then be ignored when their time comes\n    auto N = 0; \/\/ number of iterations performed, in order to keep track of the jokers count and to balance strings' sizes\n    string table{\"23456\"}; \/\/ We loop through all permutations of this \"table\" starting with '2' (only the \"3456\" part is reordered)\n    do {\n        \/\/ helper to translate \"ABCDE\" -> current \"23456\" table\n        const auto translate = [&](string chunk) {\n            for (auto& c: chunk)\n                if (c > '1')\n                    c = table[c - 'A'];\n            return chunk;\n        };\n        \/\/ Construction of the chunks that will be added to each of the 3 lines for the current table\n        auto patterns = array{\"\", \"\", \"\"};\n        if (N >= 6) \/\/ General case (the first 6 permutations will handle jokers, cf. else branch)\n            patterns = { \"01BCDEA10BCDEA1B0CDEA1BC0DEA1BCD0EA1BCDE0A1BCDE\" \/\/ just before \"01ABCDE\" to ensure \"BCDE01ABCD\"\n                         \"01ABCDE10ABCDE1A0BCDE1AB0CDE1ABC0DE1ABCD0E1ABCD\" \/\/ same\n                         \"01EABCD\"\n                         \"01DEABC\"\n                         \"01CDEAB\",\n\n                         \"01ABCDE\"\n                         \"01EABCD10EABCD1E0ABCD1EA0BCD1EAB0CD1EABC0D1EABC\" \/\/ ...\n                         \"01DEABC10DEABC1D0EABC1DE0ABC1DEA0BC1DEAB0C1DEAB\"\n                         \"01CDEAB\"\n                         \"01BCDEA\", \/\/ make sure that the 3 patterns[i] finish with different strings to ensure the presence of all \"xxxxx01\" in at least one of the lines\n\n                         \"01ABCDE\"\n                         \"01DEABC\"\n                         \"01CDEAB10CDEAB1C0DEAB1CD0EAB1CDE0AB1CDEA0B1CDEA\"\n                         \"01BCDEA\"\n                         \"01EABCD\" };\n        else { \/\/ if N < 6: one joker for the first 6 permutations\n            if (N % 2 == 0) \/\/ work simultaneously with pairs 01ABCDE\/01ABCED (this was the trick to go from 2430 to 2428)\n                patterns = { \"01BCEDA\"\n                             \"01BCDEA10BCDEA1B0CDEA1BC0DEA1BCD0EA1BCDE0A1BCDE\"\n                             \"01ABCDE10ABCDE1A0BCDE1AB0CDE1ABC0DE1ABCD0*1ABCED\" \/\/ here we lost \"BCD01EABC\" (added as a duplicate below) + \"ABCD01E\"\n                             \"01EABCD10EABCD1E0ABCD1EA0BCD1EAB0CD1EABC0D1EABC\"\n                             \"01DEABC\"\n                             \"01EDABC\"\n                             \"01CEDAB\"\n                             \"01CDEAB\"\n                             \"01DABCE\",\n\n                             \"01CDEAB\"\n                             \"01CEDAB\"\n                             \"01EABCD\"\n                             \"01BCDEA\"\n                             \"01BCEDA10BCEDA1B0CEDA1BC0EDA1BCE0DA1BCED0A1BCED\"\n                             \"01ABCED10ABCED1A0BCED1AB0CED1ABC0ED1ABCE0*1ABCDE\" \/\/ here we lost \"BCE01DABC\" (added as a duplicate below) + \"ABCE01D\"\n                             \"01DABCE10DABCE1D0ABCE1DA0BCE1DAB0CE1DABC0E1DABC\"\n                             \"01EDABC\"\n                             \"01DEABC\",\n\n                    \"01ADBCE\"\"01DABCE\" \/\/ we will need to remove this introduced duplicate \"01ADBCE\"\n                             \"01DEABC10DEABC1D0EABC1DE0ABC1DEA0BC1DEAB0C1DEAB\" \/\/ chaining with previous chunk ensure \"ABCE01D\"\n                             \"01CDEAB10CDEAB1C0DEAB1CD0EAB1CDE0AB1CDEA0B1CDEA\"\n                             \"01BCDEA\"\n                             \"01ABCDE\"\n                             \"01ABCED\"\n                    \"01AEBCD\"\"01EABCD\" \/\/ we will need to remove this introduced duplicate\n                             \"01EDABC10EDABC1E0DABC1ED0ABC1EDA0BC1EDAB0C1EDAB\" \/\/ ensure \"ABCD01E\"\n                             \"01CEDAB10CEDAB1C0EDAB1CE0DAB1CED0AB1CEDA0B1CEDA\"\n                             \"01BCEDA\" };\n\n            duplicates.insert(translate(\"01AEBCD\")); \/\/ will also add \"01ADBCE\" when N % 2 != 0\n        }\n        \/\/ Duplicates removal\n        const auto potential_duplicate = translate(\"01ABCDE\");\n        if (duplicates.contains(potential_duplicate))\n            for (auto i = 2; i >= 0; --i)\n                if (lines[(i + N) % 3].find(potential_duplicate) != string::npos) {\n                    if (i == 0) \/\/ patterns[0] does not start with \"01ABCDE\" which we want to remove\n                        swap (patterns[1], patterns[0]); \/\/ we then swap pattern 1 and 0 which conveniently have the same size\n                    patterns[i] = patterns[i] + 7; \/\/ remove leading \"01ABCDE\"\n                    break;\n                }\n        \/\/ Append chunks to solution\n        for (auto line_index: {0, 1, 2})\n            lines[(line_index + N) % 3] += translate(patterns[line_index]); \/\/ use N to balance the size of the 3 lines\n        ++N; \/\/ increment the iteration number\n    }\n    while (next_permutation(table.begin() + 1, table.end())); \/\/ End of loop through permutations of table starting with '2'\n\n    \/\/ Write solution to file\n    ofstream file{\"solution.csv\"};\n    file << \"schedule\\n\";\n    for (auto line: lines)\n        file << line << \"\\n\";\n    return 0;\n}","26f1a3bf":"!g++ -s -O3 -std=c++2a santa2021.cpp -o santa2021.exe && .\/santa2021.exe && cat solution.csv","c52659e7":"import pandas as pd\n\nSYMBOLS = \"\ud83c\udf85\ud83e\udd36\ud83e\udd8c\ud83e\udddd\ud83c\udf84\ud83c\udf81\ud83c\udf80\"\nWILDCARD = \"\ud83c\udf1f\"\n\nwith open(\"solution.csv\", \"r\") as fin:\n    solution = fin.readlines()\n    \nfor i in range(3):\n    solution[i+1] = solution[i+1].rstrip(\" \\n\").replace(\"*\", WILDCARD)\n    for j in range(7):\n        solution[i+1] = solution[i+1].replace(str(j), SYMBOLS[j])\n    print(\"line %d length %d\" % (i, len(solution[i+1])))\n    \n# generate submission\nsub = pd.DataFrame()\nsub['schedule'] = solution[1:]\nsub.to_csv('submission.csv',index=False)\nsub.head()","1a051608":"# \ud83c\udf85 **Kaggle Santa-2021 - Space Coders - Generating a 2428 solution in 100 lines of code**\n\nMany thanks to the Kaggle team and community for this very interesting optimization competition!  \nAnd congratulations to all, we hope that you enjoyed this puzzle as much as we do \ud83d\ude42.\n\n\nWe present there our mostly analytical solution.","d8edeff3":"Thank you all for reading \ud83d\ude0a  \nAnd again many thanks to the Kaggle team for this very interesting challenge; we will certainly soon try to participate in the more involving machine learning competitions!","2b28f1fa":"# Going further\n\nWe initialized a tool which took various parameters of the problem as inputs to be quickly able to produce a potential solution, should a reset be triggered. Those inputs were:\n- the permutation size\n- the number of lines\n- the number of jokers per line\n\nThis is indeed not so hard, the principles beeing similar to those presented above, balancing the use of **X**, **Y**, and their joker variants.  \nThough this time a final assembly to recover the missing xxxx**01**xxxx is  added as a post-processing step instead of a pre-analysis of the patterns.\n\nWe leave the implementation of such a program as an exercise for the interested reader \ud83d\ude0b.  \nOur take on the similar {8 size permutations \/ 3 lines \/ 2 jokers per line} problem has for instance a score of 18706 \ud83d\ude09. This case is indeed surprisingly simpler in a sense than the original problem as there are here 6 jokers for 6 big chunks per pattern, hence the use of **X'** is sufficient.","c5953066":"# Second step: Let's make good use of these wildcards! (2430, 2429)\n\nThe most efficient way to use a wildcard seems to be the removal of a mandatory **01**ABCDE permutation, as illustrated by the above 2480 -> 2468 transition using **Y**(ABCDE) chunks. And then it becomes quite clear that the joker should take the place of either the **0** or the **1** in this spared mandatory permutation, i.e. **0**\ud83c\udf1f**1**xxxxx or **10**\ud83c\udf1fxxxxx if we apply it inside an **X**(ABCDE). \n\nBut the use of wildcards is a bit trickier with these new 2440 chunks:  \n\n>**01**ABCDE**10**ABCDE**1**A**0**BCDE**1**AB**0**CDE**1**ABC**0**DE**1**ABCD**0**\ud83c\udf1f**1**ABCDE is useless because we would get two occurences of **01**ABCDE in one line...\n\nAnother variant is: **X'**(ABCDE) = **01**ABCDE**10**\ud83c\udf1fBCDEA**1**B**0**CDEA**1**BC**0**DEA**1**BCD**0**EA**1**BCDE**0**A**1**BCDE, which as for the 2480 case also gives a **01**BCDEA from a **01**ABCDE.\nThe only problem is that it removes the **0**ABCDE**1** permutation... unless we apply it to each chunk inside a pattern: then this missing permutation reappears in **X'**(EABCD), and so on, the cycle being closed with **X'**(BCDEA)\\!  \nBut only 5 jokers can be used this way, unless:  \n\n*2430 solution:*\n\n>Here is the repartition we considered for the first pattern on the three lines using 6 jokers for our first 2429\/2430\/2430 solution, admittedly a little contrieved \ud83e\udd2a:   \n>  **01**EABCD**10**\ud83c\udf1fABCDE**1**A**0**BCDE**1**AB**0**CDE**1**ABC**0**DE**1**ABCD**0**E**1**ABCD E *(=**X'**(EABCD) + E)*  \n>  **01**DEABC  \n>  **01**BCDEA**10**\ud83c\udf1fCDEAB**1**C**0**DEAB**1**CD**0**EAB**1**CDE**0**AB**1**CDEA**0**B**1**CDEA *(=**X'**(BCDEA))*  \n>\n>  **01**DEABC**10**\ud83c\udf1fEABCD **1**   \n>  **01**ABCDEA**1**B**0**CDEA**1**BC**0**DEA**1**BCD**0**EA**1**BCDE**0**\ud83c\udf1f**1**BCDEA *(mix)*  \n>  **01**CDEAB  \n>\n>  **01**ABCDE**10**\ud83c\udf1fBCDEA **1**  \n>  **01**CDEAB**10**\ud83c\udf1fDEABC**1**D**0**EABC**1**DE**0**ABC**1**DEA**0**BC**1**DEAB**0**C**1**DEAB *(=**X'**(CDEAB))*  \n>  **01**EABCD**1**E**0**ABCD**1**EA**0**BCD**1**EAB**0**CD**1**EABC**0**D**1**EABCD *(mix)* \n>\n> In fact there is a much simpler 2430 solution using the **X\"** introduced below \ud83d\ude02.\n\n*2429 solution:*\n\n>A much better solution is to use **X\"**(ABCDE) = **01**EABCDE**10**ABCDE**1**A**0**BCDE**1**AB**0**CDE**1**ABC**0**DE**1**ABCD**0**\ud83c\udf1f**1**ABCDE which (contrary to **X'**) is \"compatible\" with the other **X**s.\n>We place 5 **X'** on a first pattern, and one **X\"** for the line with only one joker in the first pattern (accompanied with 4 **X**s). \n\nAnd from here we were stuck for several days... until we saw a 2428 on the leaderboard! Wait, what ?? \ud83e\udd2f","e54c1805":"Let's eventually replace those digits with the pretty themed emojis to create a valid submission file (ok, with this final post-processing step, the full code is indeed more about 120 lines \ud83d\ude07):","c7a20b65":"# First step: ~~2480~~ 2440 without wildcard\n\nWe sensed that the high redundancy implied by the mandatory presence in every line of the various \ud83c\udf85\ud83e\udd36\ud83c\udf1f\ud83c\udf1f\ud83c\udf1f\ud83c\udf1f\ud83c\udf1f sequences makes them act as some kind of firewalls. That is, we do not really care about what immediately precedes them, and they can be considered partition points. The optimization problem is actually symmetric on the 5 others symbols (\ud83e\udd8c, \ud83e\udddd, \ud83c\udf84, \ud83c\udf81 and \ud83c\udf80).\n\n> For the sake of readibility, we denote \ud83c\udf85 and \ud83e\udd36 respectively  **0** and **1**. We also use the seed ABCDE, an arbitrary sequence of these five other symbols. There are 5! = 120 different permutations of these symbols grouping in 24 cycles : \nABCDE, BCDEA, CDEAB, DEABC, EABCD are for example 5 permutations of one cycle.\nWe call **C**(ABCDE), the cycle of the seed ABCDE.\n\n\nFor each ABCDE seed, there is one mandatory permutation to find in every string:\n**M**(ABCDE) = **01**ABCDE\n\nand 41 permutations to find in any string, matching with every relative position of \ud83c\udf85 and \ud83e\udd36 in the seven symbol permutation. Some examples for ABCDE:\n - **0**A**1**BCDE\n - **0**ABCD**1**E\n - **10**ABCDE\n - AB**1**CD**0**E\n\nIt appears quickly that some of these permutations chains very efficiently using only 1 additionnal symbol (or 2 every 8 symbols to prevent repetition):\n\n**01**ABCDE => **1**ABCDE**0** for example. As lot of people solve the problem considering a TSP instance, this would be the distance 1 permutations. \nA**1**BCDE**0** => **1**BCDE**0**A is another interesting example showing that the efficient chaining may be in two different seeds (here ABCDE and BCDEA) but still in the same cycle **C**(ABCDE). Thus, if the five seeds of the same cycle use the same chaining, they compensate each other.\n\namong these 41 permutations, those six have a special status and we call them the **merge permutations** as they can be achieved in any string only by combining the mandatory permutations:\n- **1**ABCDE**0**\n- A**01**BCDE\n- AB**01**CDE\n- ABC**01**DE\n- ABCD**01**E\n- ABCDE**01**\n\nThe 35 others are called **regular permutations** hereinafter.\n\n\n\nFrom this, we assumed that finding an efficient chaining of 35 regular permutations after the mandatory **M**(ABCDE) would let us solve the problem by symmetry. With this assumption, the puzzle then boils down to optimizing smaller subproblems for fixed groups. The merge permutations would be covered on the edges when connecting the different efficient chainings and mandatory sequences.\n\nFocusing on this subproblem, after some trial and error we can quickly find the sequence **01**ABCDE**0**A**1**BCDE**0**AB**1**CDE**0**ABC**1**DE**0**ABCD**1**E**0**ABCDE**10**ABCDE of length 48.\n\n>Such a sequence, which we denote **Y**(ABCDE), considered macroscopically as a **M**(ABCDE) to cover the merge permutation. And it is enough to almost arbitrarily split them equally (one third of the groups per line), to get to a 2480 (= 80 x 7 + 40 x 48) solution.\n>  \n>At first glance this packing seemed optimal without jokers. So given the 2435 LB score of eijirou at the time we reached this score, and as a 45 digits reduction seemed impossible with 2 jokers per line, we initially thought that this simple method using chunks was not appropriate and that we should start to consider this problem as a TSP problem as everyone seemed to do from the early forum posts.\n>  \n>From a 2480 solution, a 6 digits reduction per joker (leading to a score of 2468) could simply be done by the removal of a **01**BCDEA thanks to the use of **01**ABCDE**0**A**1**BCDE**0**AB**1**CDE**0**ABC**1**DE**0**ABCD**1**E**0**ABCDE**10**\ud83c\udf1fBCDEA, denoted **Y'**(ABCDE). This indeed spares the mandatory **M**(BCDEA) of the same string.\n\n\n\nLooking closer however we had our first \"Aha!\" moment: after the first mandatory **01**ABCDE in this sequence we chain 2 unnecessary permutations, which is quite ineffective. These are **1**ABCDE**0** (we already get it for free on the other lines, via **01**ABCDE**01**xxxxx) and ABCDE**0**A (which is not a valid permutation).\n\n![Image1.png](attachment:fc86ba88-b05c-491f-a252-cc3a52400278.png)\n\nThere is a more efficient way to chain the permutations, by reversing the direction of rotation on the above figure.    \n**X**(ABCDE) = **01**ABCDE**10**ABCDE**1**A**0**BCDE**1**AB**0**CDE**1**ABC**0**DE**1**ABCD**0**E**1**ABCD~~(E)~~ is 47 characters if we ignore the trailing E. This last character is indeed unnecessary because the **1**ABCDE**0** permutation will be covered by a **01**ABCDE**01**xxxxx on another line.\n\nWith the same method as before, we now get 3 lines of length 2440 (= 80 x 7 + 40 x 47) without wildcard! \ud83d\ude00\n\n>From this 2440 solution however, the use of wildcard to get a full 6 digits efficiency was trickier, as we describe in the second section of the notebook.\n>\n>*A side note about the number of solutions: we clearly see that we can rearrange most chunks as we wish, and balance them differently among lines. So the cardinal of the 2440 solution space is pretty huge!*","7ecaec29":"# Final step: 2428! \ud83d\ude80\n\nFirst, congratulations to Tim Riggins, we did not see 2428 coming!\n\nIt's impressive the effect of knowing that a solution exists!  \nIn about 15 minutes after realizing that 2428 could be attained, and while we really tried hard for some time and convinced ourselves that it was impossible to get to 2428, we found the trick leading to a 2428 solution \ud83d\ude05\n\n\nHere comes **X'''**(ABCDE) = **01**ABCDE**10**ABCDE**1**A**0**BCDE**1**AB**0**CDE**1**ABC**0**DE**1**ABCD**0**\ud83c\udf1f**1**ABC**ED**!\n\nWe were so focused on separated independent patterns that we did not dig enough another way of combining twin patterns (ABCDE\/ABCED).  \nIf we combine **X'''**(ABCDE) and **X'''**(ABCED) we get back the **0**E**1**ABCD that we lose over **X**(ABCDE).\n\nAnd there is the final 2428 solution: just apply a **X'''**(ABCDE) on the first 6 patterns which, because of the way permutations are visited, conveniently involve compatible pairs \ud83d\ude42.  \nR.I.P. **X'**s.\n","338fb519":"# 2428 solution program\nBelow is a now 100 lines program which adds wildcards to produce a (digits) 2428 solution.\n\nSince the previous 2440 version above, patterns are here modified for the first 6 groups to add one wildcard per group, via **X'''**(ABCDE).\n\nTo simplify things, and to remove the need for a post-processing reassembling the xxxx**01**xxxx missing permutations, the description of consecutive twin joker patterns ABCDE and ABCED are mixed. And finally we pre-insert some targeted **01**xxxxx standalone permutations, which are then filtered when their time comes.","e1356949":"# 2440 no joker solution program\nBelow is a first small program which constructs such a 2440 solution (with digits 0 to 6 in place of the emojis), using the method described above.\n\nAs you can see in the code, we grouped **01**ABCDE and its associated rotations **01**BCDEA, **01**CDEAB, **01**DEABC and **01**EABCD into **patterns** to easily ensure the presence of all permutations containing **01** without the need of a post-processing to rearrange chunks (for instance, not to miss an ABCDE**01** permutation, we have every line finish with a different permutation). The 3 patterns are appended to each line with an iterative shifting, driven by the iteration number, to balance the lengths. \n>Note: in our first submissions, we manually edited the generated \"solution\" to rearrange the chunks in order to recover the missing xx**01**xxx and the like \ud83d\ude05.\n>\n>This grouping into patterns, explicitely expanded into the code, also facilitated our experiments with wildcards."}}