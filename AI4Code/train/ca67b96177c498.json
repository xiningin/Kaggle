{"cell_type":{"8b379011":"code","dd4828b5":"code","6eb49f5f":"code","a285beaa":"code","54fc6869":"code","60ae0d1c":"code","2f49a7ba":"code","04a00659":"code","9bc62045":"code","650c3425":"code","9198b37f":"code","91478bb4":"code","5b9a643a":"code","9c5e2324":"code","b6d1d23a":"code","95087656":"code","fc3ba6cb":"code","074adb44":"markdown","82430060":"markdown"},"source":{"8b379011":"from __future__ import unicode_literals, print_function, division\nfrom io import open\nimport glob\nimport os\nimport unicodedata\nimport string\nimport torch\nimport torch.nn as nn\nimport random\nimport time\nimport math\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker","dd4828b5":"all_letters = string.ascii_letters + \" .,;'-\"\nn_letters = len(all_letters) + 1","6eb49f5f":"def findFiles(path):\n  return glob.glob(path)","a285beaa":"# Turn a Unicode string to plain ASCII, thanks to https:\/\/stackoverflow.com\/a\/518232\/2809427\ndef unicodeToAscii(s):\n    return ''.join(\n        c for c in unicodedata.normalize('NFD', s)\n        if unicodedata.category(c) != 'Mn'\n        and c in all_letters\n    )","54fc6869":"# Read a file and split into lines\ndef readLines(filename):\n    lines = open(filename, encoding='utf-8').read().strip().split('\\n')\n    return [unicodeToAscii(line) for line in lines]\n\n# Build the category_lines dictionary, a list of lines per category\ncategory_lines = {}\nall_categories = []\nfor filename in findFiles('..\/input\/name-languages\/*.txt'):\n    category = os.path.splitext(os.path.basename(filename))[0]\n    all_categories.append(category)\n    lines = readLines(filename)\n    category_lines[category] = lines\n\nn_categories = len(all_categories)","60ae0d1c":"class NameGeneratorModule(nn.Module):\n    def __init__(self, inp_size, hid_size, op_size):\n        super(NameGeneratorModule, self).__init__()\n        self.hid_size = hid_size\n\n        self.i2h = nn.Linear(n_categories + inp_size + hid_size, hid_size)\n        self.i2o = nn.Linear(n_categories + inp_size + hid_size, op_size)\n        self.o2o = nn.Linear(hid_size + op_size, op_size)\n        self.dropout = nn.Dropout(0.1)\n        self.softmax = nn.LogSoftmax(dim=1)\n\n    def forward(self, category, input, hidden):\n        inp_comb = torch.cat((category, input, hidden), 1)\n        hidden = self.i2h(inp_comb)\n        output = self.i2o(inp_comb)\n        op_comb = torch.cat((hidden, output), 1)\n        output = self.o2o(op_comb)\n        output = self.dropout(output)\n        output = self.softmax(output)\n        return output, hidden\n\n    def initHidden(self):\n        return torch.zeros(1, self.hid_size)","2f49a7ba":"# Random item from a list\ndef randomChoice(l):\n    return l[random.randint(0, len(l) - 1)]\n\n# Get a random category and random line from that category\ndef randomTrainingPair():\n    category = randomChoice(all_categories)\n    line = randomChoice(category_lines[category])\n    return category, line","04a00659":"# One-hot vector for category\ndef categoryTensor(category):\n    li = all_categories.index(category)\n    tensor = torch.zeros(1, n_categories)\n    tensor[0][li] = 1\n    return tensor\n\n# One-hot matrix of first to last letters (not including EOS) for input\ndef inputTensor(line):\n    tensor = torch.zeros(len(line), 1, n_letters)\n    for li in range(len(line)):\n        letter = line[li]\n        tensor[li][0][all_letters.find(letter)] = 1\n    return tensor\n\n# LongTensor of second letter to end (EOS) for target\ndef targetTensor(line):\n    letter_indexes = [all_letters.find(line[li]) for li in range(1, len(line))]\n    letter_indexes.append(n_letters - 1) # EOS\n    return torch.LongTensor(letter_indexes)","9bc62045":"# Make category, input, and target tensors from a random category, line pair\ndef randomTrainingExample():\n    category, line = randomTrainingPair()\n    category_tensor = categoryTensor(category)\n    input_line_tensor = inputTensor(line)\n    target_line_tensor = targetTensor(line)\n    return category_tensor, input_line_tensor, target_line_tensor","650c3425":"#Loss\ncriterion = nn.NLLLoss()\n#Learning rate\nlearning_rate = 0.0005\n\ndef train(category_tensor, input_line_tensor, target_line_tensor):\n    target_line_tensor.unsqueeze_(-1)\n    hidden = model.initHidden()\n\n    model.zero_grad()\n\n    loss = 0\n\n    for i in range(input_line_tensor.size(0)):\n        output, hidden = model(category_tensor, input_line_tensor[i], hidden)\n        l = criterion(output, target_line_tensor[i])\n        loss += l\n\n    loss.backward()\n\n    for p in model.parameters():\n        p.data.add_(p.grad.data, alpha=-learning_rate)\n\n    return output, loss.item() \/ input_line_tensor.size(0)","9198b37f":"def timeSince(since):\n    now = time.time()\n    s = now - since\n    m = math.floor(s \/ 60)\n    s -= m * 60\n    return '%dm %ds' % (m, s)","91478bb4":"model = NameGeneratorModule(n_letters, 128, n_letters)","5b9a643a":"print(model)","9c5e2324":"epochs = 100000\nprint_every = 5000\nplot_every = 500\nall_losses = []\ntotal_loss = 0 # Reset every plot_every iters\n\nstart = time.time()\n\nfor iter in range(1, epochs + 1):\n    output, loss = train(*randomTrainingExample())\n    total_loss += loss\n\n    if iter % print_every == 0:\n        print('Time: %s, Epoch: (%d - Total Iterations: %d%%),  Loss: %.4f' % (timeSince(start), iter, iter \/ epochs * 100, loss))\n\n    if iter % plot_every == 0:\n        all_losses.append(total_loss \/ plot_every)\n        total_loss = 0","b6d1d23a":"plt.figure(figsize=(7,7))\nplt.title(\"Loss\")\nplt.plot(all_losses)\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Loss\")\nplt.show()","95087656":"max_length = 20\n\n# Sample from a category and starting letter\ndef sample_model(category, start_letter='A'):\n    with torch.no_grad():  # no need to track history in sampling\n        category_tensor = categoryTensor(category)\n        input = inputTensor(start_letter)\n        hidden = model.initHidden()\n\n        output_name = start_letter\n\n        for i in range(max_length):\n            output, hidden = model(category_tensor, input[0], hidden)\n            topv, topi = output.topk(1)\n            topi = topi[0][0]\n            if topi == n_letters - 1:\n                break\n            else:\n                letter = all_letters[topi]\n                output_name += letter\n            input = inputTensor(letter)\n\n        return output_name\n\n# Get multiple samples from one category and multiple starting letters\ndef sample_names(category, start_letters='ABC'):\n    for start_letter in start_letters:\n        print(sample_model(category, start_letter))","fc3ba6cb":"print(\"Italian:-\")\nsample_names('Italian', 'BPRT')\nprint(\"\\nKorean:-\")\nsample_names('Korean', 'CMRS')\nprint(\"\\nRussian:-\")\nsample_names('Russian', 'AJLN')\nprint(\"\\nVietnamese:-\")\nsample_names('Vietnamese', 'LMT')","074adb44":"In this implementation, we will train a Recurrent Neural Network (RNN) in PyTorch on the names belonging to several languages. After successful training, the RNN model will predict names belonging to a language that start with an input alphabet letter.","82430060":"# Recurrent Neural Network in PyTorch for Text Generation"}}