{"cell_type":{"cb42aa1a":"code","196ef668":"code","8889df2d":"code","0542ed47":"code","0bd50784":"code","ec069df8":"code","244669b7":"code","80310446":"code","bd43c1fa":"code","1d1bd0d6":"code","020e4964":"code","7636423c":"code","9601bed5":"code","ba0baed5":"code","b6886bcd":"code","195346b4":"code","918c6a48":"markdown","144ea953":"markdown","a356ad4a":"markdown","1c2129d7":"markdown","61e94db9":"markdown","b61c10e3":"markdown","3c78dbce":"markdown","e88ded9a":"markdown"},"source":{"cb42aa1a":"# params\nseed = 42\nnfold = 5\ndrop_vehicle = False","196ef668":"import numpy as np \nimport pandas as pd \nimport os\nfrom sklearn.cluster import KMeans\nfrom tqdm import tqdm\nfrom sklearn.preprocessing import LabelEncoder\nfrom collections import Counter, defaultdict\nfrom sklearn.utils import check_random_state","8889df2d":"train = pd.read_csv('..\/input\/lish-moa\/train_features.csv')\ntrain_tar = pd.read_csv('..\/input\/lish-moa\/train_targets_scored.csv')\ndrug = pd.read_csv('..\/input\/lish-moa\/train_drug.csv')","0542ed47":"if drop_vehicle:\n    train = train.query(\"cp_type != 'ctl_vehicle'\")\n    train_tar = train_tar.loc[train.index]\n    train = train.reset_index(drop=True)\n    train_tar = train_tar.reset_index(drop=True)","0bd50784":"combined = train.merge(train_tar, how='inner', on='sig_id')","ec069df8":"class RepeatedStratifiedGroupKFold():\n\n    def __init__(self, n_splits=5, n_repeats=1, random_state=None):\n        self.n_splits = n_splits\n        self.n_repeats = n_repeats\n        self.random_state = random_state\n        \n    def split(self, X, y=None, groups=None):\n        k = self.n_splits\n        def eval_y_counts_per_fold(y_counts, fold):\n            y_counts_per_fold[fold] += y_counts\n            std_per_label = []\n            for label in range(labels_num):\n                label_std = np.std(\n                    [y_counts_per_fold[i][label] \/ y_distr[label] for i in range(k)]\n                )\n                std_per_label.append(label_std)\n            y_counts_per_fold[fold] -= y_counts\n            return np.mean(std_per_label)\n            \n        rnd = check_random_state(self.random_state)\n        for repeat in range(self.n_repeats):\n            labels_num = np.max(y) + 1\n            y_counts_per_group = defaultdict(lambda: np.zeros(labels_num))\n            y_distr = Counter()\n            for label, g in zip(y, groups):\n                y_counts_per_group[g][label] += 1\n                y_distr[label] += 1\n\n            y_counts_per_fold = defaultdict(lambda: np.zeros(labels_num))\n            groups_per_fold = defaultdict(set)\n        \n            groups_and_y_counts = list(y_counts_per_group.items())\n            rnd.shuffle(groups_and_y_counts)\n\n            for g, y_counts in sorted(groups_and_y_counts, key=lambda x: -np.std(x[1])):\n                best_fold = None\n                min_eval = None\n                for i in range(k):\n                    fold_eval = eval_y_counts_per_fold(y_counts, i)\n                    if min_eval is None or fold_eval < min_eval:\n                        min_eval = fold_eval\n                        best_fold = i\n                y_counts_per_fold[best_fold] += y_counts\n                groups_per_fold[best_fold].add(g)\n            \n            all_groups = set(groups)\n            for i in range(k):\n                train_groups = all_groups - groups_per_fold[i]\n                test_groups = groups_per_fold[i]\n\n                train_indices = [i for i, g in enumerate(groups) if g in train_groups]\n                test_indices = [i for i, g in enumerate(groups) if g in test_groups]\n\n                yield train_indices, test_indices","244669b7":"# concat all the labels \n# e.g 000100100100000.....\ntarget_cols = train_tar.drop('sig_id',axis=1).columns.values.tolist()\ntargets = combined[target_cols].astype(str)\n# create a new col to store the label\ncombined['combined_tar'] = ''\nfor i in tqdm(range(targets.shape[1])):\n    combined['combined_tar'] += targets.iloc[:,i]\n# add the categorical features as well\ncombined['combined_tar'] += (combined.cp_time.astype(str) + combined.cp_dose)\n# take a look at it\ncombined.combined_tar.value_counts()[:5]","80310446":"# encode the combined_tar, it's required for RepeatedStratifiedGroupKFold to have numerical targets\ncombined['combined_tar'] = LabelEncoder().fit_transform(combined['combined_tar'])","bd43c1fa":"combined['drug_id'] = drug.drug_id","1d1bd0d6":"combined['fold'] = -1\nrskf = RepeatedStratifiedGroupKFold(n_splits=nfold, random_state=42)\nfor i, (train_idx, valid_idx) in enumerate(rskf.split(combined, combined.combined_tar, combined.drug_id)):\n    combined.loc[valid_idx, 'fold'] = i\ncombined.fold = combined.fold.astype(int)","020e4964":"# sanity check for stratification\ncombined.query('fold==0').combined_tar.value_counts()","7636423c":"# sanity check for stratification\ncombined.query('fold==1').combined_tar.value_counts()","9601bed5":"# sanity check for groups\nnp.intersect1d(combined.query('fold==0').drug_id.unique(), combined.query('fold==1').drug_id.unique())","ba0baed5":"# sanity check for groups\nnp.intersect1d(combined.query('fold==1').drug_id.unique(), combined.query('fold==2').drug_id.unique())","b6886bcd":"combined.head()","195346b4":"if drop_vehicle:\n    combined.to_csv('RSGKF_combined_no_v.csv', index=False)\nelse:\n    combined.to_csv('RSGKF_combined.csv', index=False)","918c6a48":"## Output","144ea953":"## Imports","a356ad4a":"## Sanity Check","1c2129d7":"## RSGKF Util","61e94db9":"## Main Idea\n\n* Stratified kfolds based on **categorical features** and **206 multiple labels**\n* Group kfolds based on **drug_id** \n* Make sure that the different labels and categorical features are spreaded nicely in each fold\n* Make sure that each group(drug) does not appear in the same fold ","b61c10e3":"## Split Folds","3c78dbce":"First, concat all labels into a string to something like **0001000010000100..48D1**","e88ded9a":"## Params"}}