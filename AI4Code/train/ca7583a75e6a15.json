{"cell_type":{"59143dd4":"code","afc2d29a":"code","2454ec95":"code","c80772f5":"code","9dbe38e6":"code","a894bc9f":"code","3dbc8799":"code","81c162f7":"code","c807a3af":"code","111927ff":"code","bc9dda2b":"code","84693214":"code","fbf57d6f":"code","5cefe860":"code","14d63ca1":"code","5fb81244":"code","6d1af56e":"code","219ac2d4":"code","31a1927f":"code","d2258b56":"code","1b2a64fb":"code","1c66d092":"code","3caaa3c9":"code","ec643243":"code","3da5ba9d":"code","10d37120":"code","cd532a01":"code","6aae1450":"code","a86c5d0c":"code","2b77b05c":"code","77f8253d":"code","ab633a5f":"code","9793cbaf":"code","249514de":"code","58850747":"code","f18f2e64":"code","136a7af1":"code","49e6df8e":"code","f676959f":"code","ff56c34f":"code","4d726650":"code","dbabd72a":"code","25bc864b":"markdown","15c1796c":"markdown","b7820773":"markdown","a694f33a":"markdown","8f3cb15e":"markdown","f63798a0":"markdown","c9b45de4":"markdown","87310023":"markdown","b3901228":"markdown","e6a05ca2":"markdown","a319bd02":"markdown","794329ea":"markdown","e515661c":"markdown","3dc42c5a":"markdown","0d5840e1":"markdown","b42c7957":"markdown","83a7728a":"markdown","e47851d1":"markdown","2462c827":"markdown","9a1ac0a5":"markdown","b874dc46":"markdown","8f063513":"markdown","2ad1739b":"markdown","f2e42ed2":"markdown","43b6dece":"markdown","dcf290c3":"markdown","26e547dd":"markdown","2ff8e44b":"markdown","022227c5":"markdown","bae120c5":"markdown"},"source":{"59143dd4":"#Model ID\nModelId='HR_FML_v1'\n\n#Setting the model target variable name\nvar_target = 'target'\n\n#process outputs such as MOJO model, images and performance of tested models\nOutputPath='\/kaggle\/temp'\n\n#If you have a huge dataset, I should consider use a small sample for first execution\npct_sample_size = 1","afc2d29a":"import glob\nimport functools\nimport datetime as dt\nimport pandas as pd\nimport numpy as np\nimport h2o\nimport matplotlib.pyplot as plt\nimport shap\nfrom pandas_profiling import ProfileReport\nfrom collections import defaultdict\nfrom pandas_profiling.model.base import get_var_type\nimport seaborn as sns\nimport os\nimport random","2454ec95":"#List all files under the input directory\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","c80772f5":"#Import bases with features for modeling\n#In this case we will use HR dataset available below\ndataprep_df_full = pd.read_csv('\/kaggle\/input\/hr-analytics-job-change-of-data-scientists\/aug_train.csv')\n#The target variavle must be integer 0 or 1\n\ndataprep_df_full[var_target] = dataprep_df_full[var_target].astype(int)","9dbe38e6":"random.seed(59354518745)\nfor i in range(len(dataprep_df_full)):\n    dataprep_df_full.loc[i, ('random')] = random.random()\ndataprep_df_full['dataset'] = ['train' if x <= 0.85 else 'test' for x in dataprep_df_full['random']]\ndataprep_df_full = dataprep_df_full.drop(columns=['random'])","a894bc9f":"#Work with a sample data if the pct_sample_size is less than 1\nif pct_sample_size == 1:\n    dataprep_df = dataprep_df_full\nelse:    \n    dataprep_df = dataprep_df_full.sample(frac=pct_sample_size, replace=False, random_state=1)","3dbc8799":"# dataprep_df['fareLog'] = np.log(dataprep_df['fare'])\n# dataprep_df['ageLog'] = np.log(dataprep_df['age'])\n\n# dataprep_df['fareX2'] = np.square(dataprep_df['fare'])\n# dataprep_df['ageX2'] = np.square(dataprep_df['age'])","81c162f7":"#Generate report\n#If the database has many records or columns, the report can take a long time\n#If this is the case, disable the explorative, samples, correlations, missing_diagrams, duplicates and interactions options by commenting out\nprofile = ProfileReport(dataprep_df, title=f\"Pandas Profiling Report{ModelId}\"\n                        ,explorative=True\n                        #,samples=None\n                        #,correlations=None\n                        #,missing_diagrams=None\n                        #,duplicates=None\n                        #,interactions=None\n                       )\nprofile.to_file(\"profile.html\")\ndisplay(profile)","c807a3af":"# Get all the types pandas_profiling offers\nlist_columns = dataprep_df.columns.drop('dataset').drop(var_target)\nd = {col: get_var_type(dataprep_df[col])['type'].value for col in list_columns}\nfd = defaultdict(list)\nfor k, v in d.items():\n    fd[v].append(k)\n     \ncols_by_base_type = dict(fd)\n# Group the types pandas_profiling offers to match typical needs\ncat_num_cols = defaultdict(list)\nfor k, v in cols_by_base_type.items():\n    # Treat boolean and unique columns as categorical\n    k = 'CAT' if k in ['BOOL', 'UNIQUE'] else k\n    cat_num_cols[k].extend(v)\ndict(cat_num_cols)","111927ff":"#It is necessary to define the types of variables (cageroric and numeric) to ensure that the type of data used in the modeling will be the most suitable.\n#For example, categorical variables need to be defined as a string because this prevents it from being treated as a numeric variable in H20 modeling\n#Another example is that the string variables will have a missing treatment by placing the missing category for all values found as 'null'\nCAT = ['city',\n  'gender',\n  'relevent_experience',\n  'enrolled_university',\n  'education_level',\n  'major_discipline',\n  'experience',\n  'company_size',\n  'company_type',\n  'last_new_job']\n#float\nNUM = ['city_development_index', 'training_hours']\nselected_features = CAT + NUM","bc9dda2b":"#Numeric features must be float type\nfor col_name in NUM:    \n    dataprep_df[col_name] = dataprep_df[col_name].astype(float)    \n\n#Categorical features must be string type and null values will be filled with \"missing\"\nfor col_name in CAT:        \n    dataprep_df[col_name] = dataprep_df[col_name].astype(str)    \n    dataprep_df = dataprep_df.fillna(value={col_name: 'missing'})","84693214":"def calculate_IV(dataframe, coluna_feature, coluna_target, cat_goods = None, buckets=20):\n    '''\n    Function to calculate the IV.\n         Parameters\n         dataframe: DataFrame with the input and target variables.\n         column_feature (str): Name of the variable that contains the independent variable.\n         column_target (str): Name of the variable that contains the dependent variable or target.\n         cat_goods (str): Level of the target variable that should be considered \"GOOD\", if it is categorical.\n         buckets (int): Number of partitions to be created in numeric variables.\n    \n    Returns\n    stats (list):\n    List with:\n        [1] IV\n        [0] dataframe pandas with statistics table\n    '''\n    \n    # Initial definitions\n    df = dataframe.loc[:,(coluna_feature, coluna_target)]\n    tpVar = 'categorical'    \n    \n    #If the variable is numeric (float or int), it creates a category for discretization\n    if df[coluna_feature].dtype=='float64' or df[coluna_feature].dtype=='int64' or df[coluna_feature].dtype=='int32' or df[coluna_feature].dtype=='float32':\n        tpVar='numeric'\n        coluna_feature_bucket = coluna_feature + \"_bucket\"        \n        #create buckets using qcut\n        df[coluna_feature_bucket] = pd.qcut(df[coluna_feature], buckets, labels=False, duplicates='drop')\n        analyse_df = df.groupby(coluna_feature_bucket).agg({coluna_target: ['count', 'sum'], coluna_feature: ['min', 'max']})\n        analyse_df.columns = ['_'.join(tup).rstrip('_') for tup in analyse_df.columns.values]\n        analyse_df.rename(columns={(coluna_target+'_count'):'qty', (coluna_target+'_sum'):'qty_goods'}, inplace=True)\n        \n    #Categorical variables\n    if tpVar == 'categorical':        \n        analyse_df = df.groupby(coluna_feature).agg({coluna_target: ['count', 'sum']})\n        analyse_df.columns = ['_'.join(tup).rstrip('_') for tup in analyse_df.columns.values]\n        analyse_df.rename(columns={(coluna_target+'_count'):'qty', (coluna_target+'_sum'):'qty_goods'}, inplace=True)\n        \n    #IV Calculation\n    analyse_df.loc[:, 'qty_bads'] = analyse_df.loc[:,'qty'] - analyse_df.loc[:,'qty_goods']\n    analyse_df.loc[:, 'tot_goods'] = analyse_df.loc[:,'qty_goods'].sum()\n    analyse_df.loc[:, 'tot_bads'] = analyse_df.loc[:,'qty_bads'].sum()\n    analyse_df.loc[:, 'perc_goods'] = analyse_df.loc[:,'qty_goods'] \/ analyse_df.loc[:,'tot_goods']\n    analyse_df.loc[:, 'perc_bads'] = analyse_df.loc[:,'qty_bads'] \/ analyse_df.loc[:,'tot_bads']\n    analyse_df.loc[:, 'good_rate'] = analyse_df.loc[:,'qty_goods'] \/ analyse_df.loc[:,'qty']\n    analyse_df.loc[:, 'odds'] = analyse_df.loc[:,'perc_goods'] \/ analyse_df.loc[:,'perc_bads']\n    analyse_df.loc[:, 'ln_odds'] = np.log2(analyse_df['odds'])\n    analyse_df.loc[:, 'iv_cat'] = (analyse_df.loc[:,'perc_goods'] \/ analyse_df.loc[:,'perc_bads']) * analyse_df.loc[:, 'ln_odds']\n    \n    if tpVar == 'numeric':\n        analyse_df.reset_index(inplace=True)\n        tabela_pdf = analyse_df.loc[:, (coluna_feature_bucket, coluna_feature+\"_min\", coluna_feature+\"_max\", 'qty', 'good_rate', 'odds', 'iv_cat')]\n    else:\n        analyse_df.reset_index(inplace=True)\n        tabela_pdf = analyse_df.loc[:, (coluna_feature, 'qty', 'good_rate', 'odds', 'iv_cat')]\n        \n    df_iv = tabela_pdf.query('iv_cat != inf')['iv_cat'].sum()                       \n    resultado = [df_iv, tabela_pdf]\n    return resultado\n\ndef colunas_dataframe(dataframe):\n    lista_colunas = []\n    lista_colunas = [i for i in dataframe.columns if i in selected_features]\n    return lista_colunas\n\ndef table_iv(dataframe):\n    lista_colunas = colunas_dataframe(dataframe)\n    dict_resultados = {}\n    for col in lista_colunas:\n        print(\"{0:.0%}\".format((lista_colunas.index(col)+1) \/ (len(lista_colunas)+1)) + \":\" + col)              \n        dict_resultados[col] = calculate_IV(dataframe=dataframe, coluna_feature=col, coluna_target=var_target, buckets=10)\n    return dict_resultados","fbf57d6f":"start = dt.datetime.now()\n\nresult_data = table_iv(dataprep_df)\nresult_formated = pd.DataFrame.from_dict(data=result_data, orient='index').reset_index().rename(columns={'index': 'Variable', 0: 'IV'}).drop(columns=1)\nresult_formated_graph = result_formated.sort_values(by=['IV'], ascending=False)\n                                                                                                                 \n#Execution time\nstop = dt.datetime.now()\nexecution_time = stop-start\nprint(\"\\n\"+\"Execution time: \" + str (execution_time)+\"\\n\")","5cefe860":"fig = plt.figure(figsize=(10,10))\nsns.barplot(y=\"Variable\", x=\"IV\", data=result_formated_graph.head(40), palette=\"Blues_r\").set_title(\"Information Value (IV)\")\nplt.axvline (x=0.02, linestyle=\"--\", color='r')","14d63ca1":"for i in selected_features:\n    df_plot_tmp = result_data[i][1]\n    df_plot_tmp['Distribution'] = df_plot_tmp.qty \/ df_plot_tmp.qty.sum()\n    if i in CAT:\n#         print('--------------------------------------- ' + str(i))\n        df_plot_tmp = df_plot_tmp.sort_values(by=i)\n        df_plot_t1 = df_plot_tmp.loc[:, (i,'Distribution')]\n        df_plot_t1 = df_plot_t1.set_index(i)\n        df_plot_t2 = df_plot_tmp.loc[:, (i, 'good_rate')]\n        df_plot_t2 = df_plot_t2.set_index(i)\n        df_plot_t1.Distribution.plot(ylim=[0,1], kind='bar', rot=90, figsize=(15,5), linewidth=2, fontsize=12, grid=True, legend=1, title=i)\n        ax = df_plot_t2.good_rate.plot(secondary_y=True, kind=\"line\", rot=90, figsize=(15,5), linewidth=2, fontsize=12\\\n                                       , marker=\"D\", ms=8, grid=True, color='r', legend=1)\n        for p in range(len(df_plot_t2)):\n            ax.annotate(str('{0:.1%}'.format(int(df_plot_t2.reset_index().iloc[p,1]*1000)\/1000))\\\n                            ,(df_plot_t2.reset_index().index.values[p]\\\n                              ,df_plot_t2.reset_index().iloc[p,1]*1))\n        plt.show()\n        #display(ax)\n    else:\n        sort_var = str(i)+\"_max\"\n#         print('--------------------------------------- ' + str(i))\n        df_plot_tmp[sort_var] = df_plot_tmp[sort_var].astype(float)\n        df_plot_tmp = df_plot_tmp.sort_values(by=sort_var)\n        df_plot_tmp[i] = df_plot_tmp[sort_var].fillna(999999999.99).astype(float)\n        df_plot_tmp[i] = (df_plot_tmp[i]*100).astype(int)\/100\n        df_plot_tmp[i] = df_plot_tmp[i].astype(str).replace(\"999999999.99\", \"missing\")\n        df_plot_t1 = df_plot_tmp.loc[:, (i, 'Distribution')]\n        df_plot_t1 = df_plot_t1.set_index(i)\n        df_plot_t2 = df_plot_tmp.loc[:, (i, 'good_rate')]\n        df_plot_t2 = df_plot_t2.set_index(i)\n        df_plot_t1.Distribution.plot(ylim=[0,1], kind='bar', rot=90, figsize=(15,5), linewidth=2, fontsize=12, grid=True, legend=1, title=(i + \": ranges by decile\"))\n        ax = df_plot_t2.good_rate.plot(secondary_y=True, kind=\"line\", rot=90, figsize=(15,5), linewidth=2, fontsize=12, marker=\"D\", ms=8, grid=True, color='r', legend=1)\n        for p in range(len(df_plot_t2)):\n            ax.annotate(str('{0:.1%}'.format(int(df_plot_t2.reset_index().iloc[p,1]*1000)\/1000)), (df_plot_t2.reset_index().index.values[p], df_plot_t2.reset_index().iloc[p,1]*1))        \n        plt.show()\n        #display(ax)","5fb81244":"# Number of threads, nthreads = -1, means use all cores on your machine\n# max_mem_size is the maximum memory (in GB) to allocate to H2O\nh2o.init(nthreads = -1, max_mem_size = 8)","6d1af56e":"#Import TRAINING base to the H20 context\ndata_hdf = h2o.H2OFrame(dataprep_df.query('dataset == \"train\"'))\n\n# Conversion of Target variables and categorical features to factor (enum)\n#no H2O it is necessary that the categorical variables are transformed into a factor\ndata_hdf[var_target] = data_hdf[var_target].asfactor()\nfor col_name in CAT:\n    data_hdf[col_name] = data_hdf[col_name].asfactor()    \n    \n# Partition data into 90%, 10% chunks\n# Setting a seed will guarantee reproducibility\ntrain_hdf, valid_hdf = data_hdf.split_frame(ratios=[0.90], destination_frames=['train_hdf', 'valid_hdf'], seed=1)\n        \n#Notice that `split_frame()` uses approximate splitting not exact splitting (for efficiency), so these are not exactly 90%, 10% of the total rows.\nprint('Training: ' + str(train_hdf.nrow))\nprint('Validation: ' + str(valid_hdf.nrow))","219ac2d4":"#Import TEST base to the H20 context\ntest_hdf = h2o.H2OFrame(dataprep_df.query('dataset == \"test\"'))\n\n# Conversion of Target variables and categorical features to factor (enum)\n#no H2O it is necessary that the categorical variables are transformed into a factor\ntest_hdf[var_target] = test_hdf[var_target].asfactor()\nfor col_name in CAT:\n    test_hdf[col_name] = test_hdf[col_name].asfactor()    \n    \nprint('Training: ' + str(test_hdf.nrow))","31a1927f":"vModel = 'GLM_'\n\nstart = dt.datetime.now()\nfrom h2o.estimators.glm import H2OGeneralizedLinearEstimator\n\n#definir par\u00e1metros\nGLM = H2OGeneralizedLinearEstimator(family= 'binomial',\n                                    seed=1,\n                                    model_id='%s%s%s' % (vModel, ModelId, str(dt.datetime.now())[:19].replace('-',\"\").replace(':',\"\").replace(' ',\"_\")))\n\n#Executar Modelo\nGLM.train(x = selected_features,\n          y = var_target,\n          training_frame = train_hdf,\n          validation_frame = valid_hdf)\n\n#Execution time of the model\nstop = dt.datetime.now()\nexecution_time = stop-start\nprint(\"\\n\"+ \"Execution time: \" + str(execution_time) +\"\\n\")\nprint(GLM)","d2258b56":"#Create empty model list\nlist_models = []\n\n#Define the list of all models that have been executed and should be compared\ntry:\n    list_models.append(GLM)\nexcept NameError:\n    GLM = None","1b2a64fb":"#Compare performance on the TEST dataset for all trained models\nplt.rcParams.update({'font.size': 12})\nfig = plt.figure(figsize=(10, 10))\nfor i in list_models:\n    #Save all models in H20 format\n    h2o.save_model(model=i, path='%s\/models\/todos\/' % OutputPath, force=True)\n    #calculate o KS in test dataset\n    h2o_predict = i.predict(test_hdf)\n    data = h2o_predict.cbind(test_hdf[var_target]).as_data_frame()\n    data['target0'] = 1 - data[var_target]\n    data['bucket'] = pd.qcut(data['p1'], 10, duplicates='drop', labels=False)\n    grouped = data.groupby('bucket', as_index=False)\n    kstable = pd.DataFrame()\n    kstable['min_prob'] = grouped.min()['p1']\n    kstable['max_prob'] = grouped.max()['p1']\n    kstable['events'] = grouped.sum()[var_target]\n    kstable['nonevents'] = grouped.sum()['target0']    \n    kstable = kstable.sort_values(by=\"min_prob\", ascending=False).reset_index(drop=True)\n    kstable['event_rate'] = (kstable.events \/ data[var_target].sum()).apply('{0:.2%}'.format)\n    kstable['nonevent_rate'] = (kstable.nonevents \/ data['target0'].sum()).apply('{0:.2%}'.format)\n    kstable['cum_eventrate'] = (kstable.events \/ data[var_target].sum()).cumsum()\n    kstable['cum_noneventrate'] = (kstable.nonevents \/ data['target0'].sum()).cumsum()\n    kstable['KS'] = np.round(kstable['cum_eventrate'] - kstable['cum_noneventrate'], 3)\n    ks = kstable['KS'].max()\n    \n    #Ascertain the performance of all models on the test base\n    performance = i.model_performance(test_hdf)\n    \n    #Salve metrics\n    f=open(\"%s\/models\/todos\/performance_%s.csv\" % (OutputPath, i.model_id), 'w')\n    f.write(\n        str(i.model_id) + \";\"\n        + str(performance.accuracy()[0][0]) + \";\"\n        + str(performance.auc()) + ';'\n        + str(performance.aucpr()) + ';'\n        + str(performance.logloss()) + ';'\n        + str(ks) + ';'\n        + str(performance.F1()[0][0]))\n    f.write('\\n')\n    f.close()\n\n    #graph with the ROC curve of all models\n    fpr = performance.fprs\n    tpr = performance.tprs\n    plt.plot(fpr, tpr, lw=2, label=i.model_id.split(\"_\")[0]+\"_\"+i.model_id.split(\"_\")[1]+\"_\"+i.model_id.split(\"_\")[2])\n    plt.title(\"ROC Curve for Model (Test dataset)\")    \n    \n    if i.model_id==list_models[0].model_id:\n        df_plot = pd.DataFrame({'Model_id': i.model_id.split(\"_\")[0]+\"_\"+i.model_id.split(\"_\")[1]+\"_\"+i.model_id.split(\"_\")[2],\n                                    'AUROC': int(performance.auc()*100)\/100,\n                                    'AUCPR': int(performance.aucpr()*100)\/100,\n                                    'KS': int(ks*100)\/100\n                                    }, index=[0])\n    else:\n        df_plot = df_plot.append(pd.DataFrame({'Model_id': i.model_id.split(\"_\")[0]+\"_\"+i.model_id.split(\"_\")[1]+\"_\"+i.model_id.split(\"_\")[2],\n                                    'AUROC': int(performance.auc()*100)\/100,\n                                    'AUCPR': int(performance.aucpr()*100)\/100,\n                                    'KS': int(ks*100)\/100\n                                    }, index=[0]))\nplt.plot([0, 1], [0, 1], color='red', lw=2, linestyle='--')\nplt.xlim([0.0, 1.05])\nplt.ylim([0.0, 1.05])\nplt.legend(loc=\"lower right\")\nplt.show()\nplt.close()\nax = df_plot.plot(kind='bar', x=\"Model_id\", title=\"AUROC, AUCPR e KS for Model (Test dataset)\", grid=True, figsize=(10,5), legend=1)\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), (p.get_x() * 1.005, p.get_height() * 1.005))\nplt.legend(loc=3, prop={'size': 10})","1c66d092":"#Consider all models in the history .\/models\/todos\/performance_*.csv. To disregard any old version, set erase_modelos = \"S\":\napagar_modelos = 'N'\nif apagar_modelos == 'S':\n    os.system('rm %s\/models\/todos\/performance_*.csv' % OutputPath)","3caaa3c9":"sort_metric_best_model='AUCPR'\n#importar todos os modelos testados e imprmie na tela os 10 melhores erdedando per AUC\nmodelos_testados = pd.concat(map(functools.partial(pd.read_csv, sep=';', header=None), glob.glob('%s\/models\/todos\/performance_*.csv' % OutputPath)))\nmodelos_testados.columns = ('model_id', 'accuracy', 'AUC', 'AUCPR', 'logloss', 'KS', 'F1')\nmodelos_testados = modelos_testados.sort_values(by=sort_metric_best_model, ascending=False)\nmodelos_testados = modelos_testados.drop_duplicates(subset=[\"model_id\"])\nprint('MBest Models. Sorted by : ' + str(sort_metric_best_model))\nmodelos_testados.reset_index(0).head(30)","ec643243":"#If you want to choose a model other than the first one on the list. Choose the position number:\nposicao_melhor_modelo=0\n\nmelhor_modelo = h2o.load_model('%s\/models\/todos\/%s' % (OutputPath, modelos_testados.iloc[posicao_melhor_modelo, 0]))\n(print(\"\\n\"+ \"BEST MODEL: \" + str(modelos_testados.iloc[posicao_melhor_modelo, 0]) + \"\\n\"))\n\nplt.rcParams.update({'font.size': 10})\ntry:\n    melhor_modelo.varimp_plot(50)\nexcept Exception as e:\n    print(\"Warning: This model doesn't have variable importances\")","3da5ba9d":"#Listar todas as vari\u00e1veis do modelo atual, ordenadas por variable importance\n#Para as variaveis definidas como fator (que possivelmente est\u00e3o como dummys), remover a categoria do nome e deixar apenas o nome orifinal da variavel\n\n#List all variables in the current model, ordered by variable importance\n#For variables defined as a factor (which possibly are like dummys), remove the category from the name and leave only the orifinal name of the variable\ntry:\n    df_features_sorted = melhor_modelo.varimp(True).variable.str.split('.', expand=True).drop_duplicates(subset = 0)[0].reset_index(drop=True)\nexcept Exception as e:\n    #As the model with ensemble in H20 does not show the importance of variables, we will include variables with higher IV first using result_formatado graph of step 5.1\n    df_features_sorted = result_formated_graph.Variable.reset_index(drop=True)","10d37120":"#Define the number of variables to be increased with each new model. Try to put 10% or 20% of the total, as it can take a long time\nqt_var=1\nqt_total_var = len(df_features_sorted)\n\ndict_model_tmp={}\ndict_performance={}\n\nfor i in range(qt_var, qt_total_var+qt_var, qt_var):    \n    df_features_sorted[0:i].values.tolist()    \n    \n    #If no model chosen is not an ensemble of models. Then use the same model for training with increment of variables\n    melhor_modelo_tmp = melhor_modelo\n    if melhor_modelo_tmp.model_id.lower().find(\"ensemble\") == -1:\n        dict_model_tmp[i] = melhor_modelo_tmp\n        dict_model_tmp[i].train(x = df_features_sorted[0:i].values.tolist(),\n                                y = var_target,\n                                training_frame=train_hdf, \n                                validation_frame=valid_hdf)\n    ##If it is not possible, for the home of an ensemble of models, use GradientBoostingEstimator to make the assessment\n    else:\n        dict_model_tmp[i] = H2OGradientBoostingEstimator(seed=1, model_id=str('model_tmp_%s' % i))\n        dict_model_tmp[i].train(x = df_features_sorted[0:i].values.tolist(),\n                                y = var_target,\n                                training_frame=train_hdf, \n                                validation_frame=valid_hdf)       \n\n\n    perform_oot = dict_model_tmp[i].model_performance(test_hdf)\n    dict_performance_tmp = {}\n    dict_performance_tmp['AUC'] = {'qt_var': i, 'medida': 'AUC', 'Validation_Dataset': dict_model_tmp[i].auc(valid=True), 'Test_Dataset': perform_oot.auc()}\n    dict_performance_tmp['accuracy'] = {'qt_var': i, 'medida': 'accuracy', 'Validation_Dataset': dict_model_tmp[i].accuracy(valid=True)[0][0], 'Test_Dataset': perform_oot.accuracy()[0][0]}\n    dict_performance_tmp['AUCPR'] = {'qt_var': i, 'medida': 'AUCPR', 'Validation_Dataset': dict_model_tmp[i].aucpr(valid=True), 'Test_Dataset': perform_oot.aucpr()}\n    dict_performance_tmp['F1'] = {'qt_var': i, 'medida': 'F1', 'Validation_Dataset': dict_model_tmp[i].F1(valid=True)[0][0], 'Test_Dataset': perform_oot.F1()[0][0]}\n    dict_performance_tmp['logloss'] = {'qt_var': i, 'medida': 'logloss', 'Validation_Dataset': dict_model_tmp[i].logloss(valid=True), 'Test_Dataset': perform_oot.logloss()}\n    dict_performance[i] = pd.DataFrame(dict_performance_tmp).transpose()","cd532a01":"##Plot graph comparing the increase in performance with the increase in variables\nfor i in dict_performance.keys():\n    if i == list(dict_performance.keys())[0]:\n        df_performance = dict_performance[i]\n    else:\n        df_performance = df_performance.append(dict_performance[i], ignore_index=True)\n\nlista_metricas_perf = df_performance['medida'].unique()\n\nfor i in range(len(lista_metricas_perf)):   \n    #selects only the metric to be analyzed\n    metrics_df_tmp = df_performance.query('medida == \"%s\"' % lista_metricas_perf[i])\n    metrics_df_tmp = metrics_df_tmp.set_index('qt_var')\n    del metrics_df_tmp['medida']\n    if lista_metricas_perf[i] == 'logloss':\n        max_oot = metrics_df_tmp[metrics_df_tmp['Test_Dataset'] == metrics_df_tmp.Test_Dataset.min()].index.values\n    else:\n        max_oot = metrics_df_tmp[metrics_df_tmp['Test_Dataset'] == metrics_df_tmp.Test_Dataset.max()].index.values\n        \n    if lista_metricas_perf[i] == sort_metric_best_model:\n        max_oot_filtro = max_oot[0]        \n    \n    ax=metrics_df_tmp.plot(figsize=(15,5), linewidth=2, fontsize=10, marker='D', ms=5,\\\n                            title='Best %s with %s Variables' % (lista_metricas_perf[i].upper(), str(max_oot[0])))\n    plt.xlabel('Variables Number')\n    plt.ylabel('%s' % lista_metricas_perf[i].upper())\n    plt.grid(axis='y')\n    plt.legend(loc=0, prop={'size': 12})\n    #display(ax)","6aae1450":"print('Consider removing the following variables: '+ str(df_features_sorted[df_features_sorted.index > int(max_oot_filtro)].values.tolist()))","a86c5d0c":"#Save the H2O model in MOJO format and all the variables of the best model\nmelhor_modelo = h2o.load_model('%s\/models\/todos\/%s' % (OutputPath, modelos_testados.iloc[posicao_melhor_modelo, 0]))\ncaminho_modelo_mojo = melhor_modelo.download_mojo('%s\/models\/melhores\/' % OutputPath, get_genmodel_jar=True)\nprint(caminho_modelo_mojo)\ncaminho_modelo_h2o = h2o.save_model(model=melhor_modelo, path='%s\/models\/melhores\/' % OutputPath, force=True)","2b77b05c":"try:\n    features_names= melhor_modelo.varimp(True)\n    features_names.to_csv('%s\/models\/melhores\/features_names_%s.csv' % (OutputPath, melhor_modelo.model_id), sep=';')\nexcept Exception as e:\n    print(\"Warning: This model doesn't have variable importances\")","77f8253d":"class H2oProbWrapper:\n    def __init__(self, h2o_model, feature_names):\n        self.h2o_model = h2o_model\n        self.feature_names = feature_names\n    def predict_binary_prob(self, X):\n        if isinstance(X, pd.Series):\n            X = X.values.reshape(1,-1) \n        self.dataframe = pd.DataFrame(X, columns=self.feature_names)\n        \n        global NUM\n        #Variaveis explicativas continuas\n        for col_name in NUM:    \n            self.dataframe[col_name] = self.dataframe[col_name].astype(float)\n            \n        global CAT\n        for col_name in CAT:    \n            self.dataframe[col_name] = self.dataframe[col_name].astype(str)\n            self.dataframe = self.dataframe.fillna(value={col_name: 'missing'})\n        \n        self.h2oframe = h2o.H2OFrame(self.dataframe)\n        for col_name in CAT:\n            self.h2oframe[col_name] = self.h2oframe[col_name].asfactor()\n        \n        self.predictions = self.h2o_model.predict(self.h2oframe).as_data_frame().values\n        return self.predictions.astype('float64') [:,-1]","ab633a5f":"#The calculation of the Shapley Value for H20 models takes a while. So it will only be done for 20 records. Increase the sample to deepen your analysis\nshap_sample = dataprep_df.query('dataset == \"test\"').loc[:,(selected_features)].sample(n=20, replace=False, random_state=1)\nshap_sample = shap_sample.fillna(0)","9793cbaf":"h2o_wrapper = H2oProbWrapper(melhor_modelo, selected_features)\nh2o_explainer = shap.KernelExplainer(h2o_wrapper.predict_binary_prob, shap_sample)\nh2o_shap_values = h2o_explainer.shap_values(shap_sample, nsamples=\"auto\")","249514de":"fig = shap.summary_plot(h2o_shap_values, shap_sample, plot_type=\"bar\", show=True)\ndisplay(fig)","58850747":"display(shap.summary_plot(h2o_shap_values, shap_sample, show=False))","f18f2e64":"#sort the features indexes by their importance in the model\n#(sum of SHAP value magnitudes over the validation dataset)\ntop_inds = np.argsort(-np.sum(np.abs(h2o_shap_values),0))\n\n#make SHAP plots of the three most important features\nfor i in range(9):\n    fig=shap.dependence_plot(top_inds[i], h2o_shap_values, shap_sample, show=False)\n#     display(fig)","136a7af1":"df_shap_values = pd.DataFrame(h2o_shap_values)\ndf_shap_values['sum_shap'] = df_shap_values.sum(axis=1)","49e6df8e":"for i in df_shap_values.sort_values(by='sum_shap').iloc[0:3,:].index.values:\n    fig = shap.force_plot(h2o_explainer.expected_value, h2o_shap_values[i,:], shap_sample.iloc[i,:], matplotlib=True, show=True)\n    display(fig)","f676959f":"for i in df_shap_values.sort_values(by='sum_shap').iloc[0:3,:].index.values:\n    fig = shap.plots._waterfall.waterfall_legacy(h2o_explainer.expected_value, h2o_shap_values[i,:], shap_sample.iloc[i,:].to_numpy(), selected_features, show=True)\n    display(fig)","ff56c34f":"submission_df = pd.read_csv('\/kaggle\/input\/hr-analytics-job-change-of-data-scientists\/aug_test.csv')\n\n#Numeric features must be float type\nfor col_name in NUM:    \n    submission_df[col_name] = submission_df[col_name].astype(float)    \n\n#Categorical features must be string type and null values will be filled with \"missing\"\nfor col_name in CAT:        \n    submission_df[col_name] = submission_df[col_name].astype(str)    \n    submission_df = submission_df.fillna(value={col_name: 'missing'})","4d726650":"#Importar MOJO\ntry:\n    test_tmp = h2o.mojo_predict_pandas(submission_df, caminho_modelo_mojo)    \n    predict_df = submission_df.merge(test_tmp, left_index=True, right_index=True)\nexcept:    \n    submission_hdf = h2o.H2OFrame(submission_df)\n    for col_name in CAT:\n        submission_hdf[col_name] = submission_hdf[col_name].asfactor() \n    h2o_predict = melhor_modelo.predict(submission_hdf)\n    predict_df = h2o_predict.cbind(submission_hdf).as_data_frame()\n    \npredict_df.rename(columns={'predict':'target'}, inplace=True)\npredict_df.loc[:, ('enrollee_id', 'target')]","dbabd72a":"predict_df.loc[:, ('enrollee_id', 'target')].to_csv('\/kaggle\/working\/HR_analysis_submission.csv', index=False)","25bc864b":"## 6.3 Compare performance on the TEST dataset for all trained models","15c1796c":"# 1. Parameters and Libraries","b7820773":"# 7. Calculate Shapley Values using SHAP KernelExplainer for H20 models","a694f33a":"# 6. Modeling","8f3cb15e":"# 2. Import Libraries","f63798a0":"## FIM","c9b45de4":"## 3.1 Feature Engineering","87310023":"# This notebook will help you to do:\n* Import training and test data\n* Univariate Analysis\n* Bivariate Analysis\n* Run GLM algorithm using H2O\n* check model performance in test dataset\n* Interpret model output with Shapley Value\n\n## The HR Analytics dataset will be used for this demonstration","b3901228":"# 9. Save final dataset with predictions","e6a05ca2":"## 6.1 Creating context and H2O and Importing data into the H2O context","a319bd02":"# 4. Univariate Analysis","794329ea":"#### The SHAP library calculates the Shaley Value of each variable used in the model and shows the individual impact of each variable on the predicted value for each record. To better understand how the SHAP library works, see the link https:\/\/github.com\/slundberg\/shap","e515661c":"## 6.4 Choose the best model among all tested","3dc42c5a":"### Shap Waterfall Plot","0d5840e1":"## 4.1 Pandas Profiling","b42c7957":"# 5. Bivariate Analysis","83a7728a":"## 6.4 Stepwise for Analysis of the importance of variables","e47851d1":"## 6.5 Exporting the best model to Deploy","2462c827":"## 4.2 Classify the types of variables\n#### list all columns to select the ones to be used","9a1ac0a5":"# 8. Predict test dataset using MOJO or H2O Model","b874dc46":"## 5.2 Charts with the good rate (% of target = 1) by categories or by value range for numeric variables (ranges created by decile)","8f063513":"## 6.2 Using H2O","2ad1739b":"# 3. Importing Data for Modeling","f2e42ed2":"### From the variables listed above you can select which  one will be tested in the model and confirm if the correct type is numeric(NUM) or categorical (CAT). Paste the correct information below:","43b6dece":"## Logistic Regresion (GLM)","dcf290c3":"## Main SHAP Graphics","26e547dd":"### Shap Force Plot","2ff8e44b":"##### For more details on the pandas profiling library see https:\/\/github.com\/pandas-profiling\/pandas-profiling\n","022227c5":"### It is necessary to create a variable to indicate the records used in training and testing. In this case we will use the random variable, but you can use a date variable for exemple if you have a base with a reference date to fix the training base as an out of time validation.","bae120c5":"## 5.1 Calculation of the Information Value for all variables defined as selected features"}}