{"cell_type":{"de476e74":"code","a2eb27da":"code","f3353f78":"code","06354651":"code","e3929065":"code","33da4277":"code","53f649da":"code","6c2dc978":"code","cb78c02e":"code","db42b434":"code","3670237d":"code","dcebba0d":"code","539428c9":"code","789f04b3":"code","824e47e4":"code","b3fa5498":"code","3631d774":"code","37465f47":"code","5fe927d3":"code","e86b8b06":"code","cc447a4f":"code","b1b85c3f":"code","a5c8ec9f":"code","fe9206b0":"code","b5a56a74":"code","72866883":"code","3fb8229e":"code","1e56a2d9":"code","7165b138":"code","509d174a":"code","02b0ce51":"code","9613bb72":"code","7be0ffc7":"code","6ce871a9":"code","95efe7c7":"code","54c21b13":"code","b6e790a0":"code","791d30d2":"code","5f163d66":"markdown","cb31f34a":"markdown","a3720886":"markdown","5eb8ec00":"markdown","8849ea9d":"markdown","9f79b58a":"markdown","70cce4e3":"markdown","557f7673":"markdown","08ec22ec":"markdown","3dc839dd":"markdown","3868c57c":"markdown","71b7e945":"markdown","31883741":"markdown"},"source":{"de476e74":"import pandas as pd \nimport numpy as np\n\nimport matplotlib.pyplot as plt\n%matplotlib inline \n\nimport xgboost as xgb\n\nfrom sklearn.model_selection import KFold\n\nfrom sklearn.metrics import accuracy_score\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\npd.set_option('max_colwidth', 1000)\npd.set_option('max_rows',40)\npd.set_option('max_columns',1000)\n\nimport seaborn as sns \nsns.set_style('darkgrid')","a2eb27da":"data = pd.read_csv(\"..\/input\/loan-prediction-analytics-vidhya\/train_ctrUa4K.csv\")\ntest = pd.read_csv(\"..\/input\/loan-prediction-analytics-vidhya\/test_lAUu6dG.csv\")","f3353f78":"sns.countplot(x=\"Loan_Status\", data=data)","06354651":"num_cols = data.select_dtypes(exclude='object').copy()\ncat_cols = data.select_dtypes(include='object').copy()\ncat_cols = cat_cols.drop('Loan_ID',axis=1)","e3929065":"num_cols.head()","33da4277":"cat_cols.head()","53f649da":"fig = plt.figure(figsize=(12,16))\nfor index,col in enumerate(num_cols):\n    plt.subplot(3,2,index+1)\n    sns.distplot(num_cols.loc[:,col].dropna(),kde=False,bins=30)\nfig.tight_layout(pad=1.0)","6c2dc978":"data['Loan_Amount_Term'].value_counts()","cb78c02e":"fig = plt.figure(figsize=(12,16))\nfor index,col in enumerate(num_cols):\n    plt.subplot(3,2,index+1)\n    sns.boxplot(data=num_cols.dropna(), y=col)\nfig.tight_layout(pad=1.0)","db42b434":"fig = plt.figure(figsize=(18,20))\nfor index in range(len(cat_cols.columns)):\n    plt.subplot(2,4,index+1)\n    sns.countplot(x=cat_cols.iloc[:,index], data=cat_cols.dropna())\n#    plt.xticks(rotation=90)\nfig.tight_layout(pad=1.0)","3670237d":"# Checking Null values  \nplt.figure(figsize=(10,8))\nsns.heatmap(data.isnull(),cmap='plasma')\n\ndef percent_missing(d):\n    percentage = pd.DataFrame(100*(d.isnull().sum()\/len(d)),columns=['Missing_%']).sort_values('Missing_%',ascending=False)\n    return (percentage.head(10))","dcebba0d":"percent_missing(data)","539428c9":"#Mapp the Y\/N to 1\/0\nmapp = {'Y':1,'N':0}\ndata[\"Loan_Status\"] = data[\"Loan_Status\"].map(mapp)","789f04b3":"corr = data.corr()\nsns.heatmap(data=corr.dropna(),cmap='Blues',linewidth=0.5)","824e47e4":"sns.countplot(x='Loan_Status',data=data,hue='Credit_History')","b3fa5498":"corr[\"Loan_Status\"]","3631d774":"fig = plt.figure(figsize=(18,20))\nfor index in range(len(cat_cols.columns)):\n    plt.subplot(2,4,index+1)\n    sns.countplot(x=cat_cols.iloc[:,index], data=cat_cols.dropna(),hue=data['Loan_Status'])\n#    plt.xticks(rotation=90)\nfig.tight_layout(pad=1.0)","37465f47":"data = data[data['ApplicantIncome'] < 50000]\ndata = data[data['LoanAmount'] < 500]","5fe927d3":"mapp_gender = {'Male':0,'Female':1}\nmapp_married = {'No':0,'Yes':1}\nmapp_dep = {'0':0,'1':1,'2':1,'3+':1}\nmapp_edu = {'Not Graduate':0,'Graduate':1}\nmapp_se = {'No':0,'Yes':1}\nmapp_pa = {'Semiurban':1,'Urban':2,'Rural':3}\n\n\ndata['Gender'] = data['Gender'].map(mapp_gender)\ndata['Married'] = data['Married'].map(mapp_married)\ndata['Dependents'] = data['Dependents'].map(mapp_dep)\ndata['Education'] = data['Education'].map(mapp_edu)\ndata['Self_Employed'] = data['Self_Employed'].map(mapp_se)\ndata['Property_Area'] = data['Property_Area'].map(mapp_pa)\n\n\ntest['Gender'] = test['Gender'].map(mapp_gender)\ntest['Married'] = test['Married'].map(mapp_married)\ntest['Dependents'] = test['Dependents'].map(mapp_dep)\ntest['Education'] = test['Education'].map(mapp_edu)\ntest['Self_Employed'] = test['Self_Employed'].map(mapp_se)\ntest['Property_Area'] = test['Property_Area'].map(mapp_pa)\n\nmapp_lt = {360.0 :1,180.0 : 0,480.0:0,300.0:0,84.0: 0,240.0: 0,120.0: 0,36.0: 0,60.0: 0,12.0:0}\ndata['Loan_Amount_Term'] = data['Loan_Amount_Term'].map(mapp_lt)\ntest['Loan_Amount_Term'] = test['Loan_Amount_Term'].map(mapp_lt)","e86b8b06":"corr = data.corr()\nsns.heatmap(data=corr.dropna(),mask = corr < 0.8,cmap='Blues',linewidth=0.5)","cc447a4f":"loan_amt_avg = test.groupby('ApplicantIncome').mean()['LoanAmount']\ndef fill_loan_amt(LoanAmount,ApplicantIncome):\n    if np.isnan(LoanAmount):\n        return loan_amt_avg[ApplicantIncome]\n    else:\n        return LoanAmount\ntest['LoanAmount'] = test.apply(lambda x: fill_loan_amt(x['LoanAmount'], x['ApplicantIncome']), axis=1)\ntest['LoanAmount'] = test['LoanAmount'].fillna(136.9586777)","b1b85c3f":"loan_amt_avg = data.groupby('ApplicantIncome').mean()['LoanAmount']\n\ndef fill_loan_amt(LoanAmount,ApplicantIncome):\n    if np.isnan(LoanAmount):\n        return loan_amt_avg[ApplicantIncome]\n    else:\n        return LoanAmount\ndata['LoanAmount'] = data.apply(lambda x: fill_loan_amt(x['LoanAmount'], x['ApplicantIncome']), axis=1)\ndata['LoanAmount'] = data['LoanAmount'].fillna(146.4121622)","a5c8ec9f":"test['Dependents'] = test['Dependents'].fillna(1)\ndata['Dependents'] = data['Dependents'].fillna(1)","fe9206b0":"def fill_gender(Gender,Married):\n    if np.isnan(Gender):\n        if Married ==1:\n            return (1)\n        else:\n            return (0)\n    else:\n        return Gender\ntest['Gender'] = test.apply(lambda x: fill_gender(x['Gender'], x['Married']), axis=1)\ndata['Gender'] = data.apply(lambda x: fill_gender(x['Gender'], x['Married']), axis=1)","b5a56a74":"def fill_self_emp(Self_Employed,ApplicantIncome):\n    if np.isnan(Self_Employed):\n        if ApplicantIncome >=7380:\n            return (1)\n        else:\n            return (0)\n    else:\n        return Self_Employed\ntest['Self_Employed'] = test.apply(lambda x: fill_self_emp(x['Self_Employed'], x['ApplicantIncome']), axis=1)\ndata['Self_Employed'] = data.apply(lambda x: fill_self_emp(x['Self_Employed'], x['ApplicantIncome']), axis=1)","72866883":"test['Loan_Amount_Term'] = test['Loan_Amount_Term'].fillna(0)\ndata['Loan_Amount_Term'] = data['Loan_Amount_Term'].fillna(0)","3fb8229e":"test['Credit_History'] = test['Credit_History'].fillna(-999)\ndata = data.dropna()","1e56a2d9":"def fill_CoapplicantIncome(CoapplicantIncome):\n    if CoapplicantIncome ==0:\n         return (1)\n    else:\n        return (0)\ndata['CoapplicantIncome'] = data.apply(lambda x: fill_CoapplicantIncome(x['CoapplicantIncome']), axis=1)\ntest['CoapplicantIncome'] = test.apply(lambda x: fill_CoapplicantIncome(x['CoapplicantIncome']), axis=1)","7165b138":"mapp = {1:'Y',0:'N'}\ndata[\"Loan_Status\"] = data[\"Loan_Status\"].map(mapp)\n\nX_train = data.drop(['Loan_ID','Loan_Status'],axis=1)\ny_train = data['Loan_Status']","509d174a":"import optuna\n\ndef objective(trial):\n    params = {\n        'n_estimators': trial.suggest_int('n_estimators', 350, 1000),\n        'max_depth': trial.suggest_int('max_depth', 6, 13),\n        'learning_rate': trial.suggest_uniform('learning_rate', 0.009, 0.10),\n        'subsample': trial.suggest_uniform('subsample', 0.50, 1),\n        'colsample_bytree': trial.suggest_uniform('colsample_bytree', 0.50, 1),\n        'gamma': trial.suggest_int('gamma', 0, 0.05),\n        'missing': -999,\n        #'scale_pos_weight': 0.48,\n       }\n        \n    clf = xgb.XGBClassifier(**params)\n    auccuracies = []\n    X_train_k = X_train.values\n    y_train_k = y_train.values\n    kf = KFold(n_splits=3,random_state=2000,shuffle=True)\n    for train_idx, valid_idx in kf.split(X_train_k,y_train_k):\n#        X_train_k, X_test = X_train[train_index], X_train[test_index]\n#        y_train_k, y_test = y_train[train_index], y_train[test_index]\n        train_data = X_train_k[train_idx, :], y_train_k[train_idx]\n        valid_data = X_train_k[valid_idx, :], y_train_k[valid_idx]\n        \n        clf.fit(X_train_k[train_idx, :], y_train_k[train_idx])\n        pred = clf.predict(X_train_k[valid_idx, :])\n        accuracy = accuracy_score(y_train_k[valid_idx],pred)\n        auccuracies.append(accuracy)\n    print(f'Trial done: Accuracy values on folds: {auccuracies}')\n    return np.average(auccuracies)","02b0ce51":"n_trials = 100\n\nFIT_XGB = True\n\nif FIT_XGB:\n    study = optuna.create_study(direction=\"maximize\")\n    study.optimize(objective, n_trials=n_trials)\n\n    print(\"Number of finished trials: {}\".format(len(study.trials)))\n\n    print(\"Best trial:\")\n    trial = study.best_trial\n\n    print(\"  Value: {}\".format(trial.value))\n\n    print(\"  Params: \")\n    for key, value in trial.params.items():\n        print(\"    {}: {}\".format(key, value))","9613bb72":"best_param = study.best_params\nbest_param['scale_pos_weight'] =0.48\nbest_param['missing'] =-999","7be0ffc7":"import plotly","6ce871a9":"optuna.visualization.plot_slice(study)","95efe7c7":"optuna.visualization.plot_optimization_history(study)","54c21b13":"model = xgb.XGBClassifier(**best_param)\nmodel.fit(X_train,y_train)","b6e790a0":"predictions_final = model.predict(test.drop('Loan_ID',axis=1))","791d30d2":"predictions_final","5f163d66":"No Collinearity btw other features","cb31f34a":"# HyperParameter Tuning","a3720886":"## Outliers","5eb8ec00":"# Uni-variate Analysis","8849ea9d":"**Outliers**","9f79b58a":"**Mapping**","70cce4e3":"# Filling Missing Values","557f7673":"## Missing Values","08ec22ec":"## Cat_columns","3dc839dd":"**Numeric Columns**<br>\n**Categorical Columns**<br>","3868c57c":"## Correlations","71b7e945":"# Target","31883741":"# Data Processing "}}