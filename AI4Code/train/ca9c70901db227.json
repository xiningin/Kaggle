{"cell_type":{"d6e81fa8":"code","1bc96a7b":"code","0dcb353c":"code","0805c46d":"code","be514cbf":"code","e19078c6":"code","af5d0c43":"code","77d1ce3a":"code","59e9b076":"code","b771e615":"code","717f942b":"code","f8af713d":"code","4b46f733":"code","019d1448":"markdown","f73805c5":"markdown","e586f49f":"markdown","75f4605a":"markdown","9e072476":"markdown","23ad18b7":"markdown","afa0c088":"markdown"},"source":{"d6e81fa8":"import numpy as np\nimport matplotlib.pyplot as plt\nimport torch\nimport torchvision\nfrom torchvision import datasets, transforms\nfrom torch.utils import data\nimport torch.optim as optim\nfrom torch import nn\nimport torch.nn.functional as F","1bc96a7b":"torch.device('cuda')","0dcb353c":"train = datasets.MNIST('mnist_data', train=True, transform = transforms.ToTensor(), download=True)\ntest = datasets.MNIST('mnist_data', train=False, transform = transforms.ToTensor(), download=True)","0805c46d":"trainset = data.DataLoader(train, batch_size = 32, shuffle=True)\ntestset = data.DataLoader(test, batch_size = 32, shuffle=False)","be514cbf":"class MyNet(nn.Module):\n  def __init__(self):\n    super().__init__()\n\n    self.fc1 = nn.Linear(28*28, 128)\n    self.fc2 = nn.Linear(128, 128)\n    self.dropout = nn.Dropout(p=0.2)\n    self.fc3 = nn.Linear(128, 128)\n\n    self.fc4 = nn.Linear(128, 10)\n\n  def forward(self, X):\n    X = F.relu(self.fc1(X))\n    X = F.relu(self.fc2(X))\n    X = self.dropout(X)\n    X = F.relu(self.fc3(X))\n    \n\n    X = self.fc4(X)\n\n    return F.log_softmax(X, dim=1)","e19078c6":"net = MyNet()","af5d0c43":"print(net)","77d1ce3a":"optimizator = optim.Adam(net.parameters(), lr=0.001)","59e9b076":"EPOCHS = 4\nfor epoch in range(EPOCHS):\n  for X,y in trainset:\n    net.zero_grad()\n\n    output = net(X.view(-1, 28*28))\n\n    loss = F.nll_loss(output, y)\n    loss.backward()\n    optimizator.step()\n\n  print(loss)","b771e615":"def accuracy(data, net):\n  total = 0\n  correct = 0\n  with torch.no_grad():\n    for X,y in data:\n      output = net(X.view(-1, 784))\n      for i, e in enumerate(output):\n        if torch.argmax(e) == y[i]:\n          correct +=1\n        total+=1\n    print('Accuracy: ', round(correct\/total, 3))","717f942b":"net.eval()","f8af713d":"accuracy(trainset, net)","4b46f733":"accuracy(testset, net)","019d1448":"importing libraries","f73805c5":"in order to perform calculations faster we wanna use cuda device(I tried that on Google Colab)","e586f49f":"I heard today that we have to activate eval mode for our neural net, before calculating metric","75f4605a":"I like simplicity :)","9e072476":"I dont't really like how I calculate accuracy here, but I don't know how to do that more efficiently in pytorch yet","23ad18b7":"## \u041c\u043e\u044f \u043d\u0435\u0439\u0440\u043e\u0441\u0435\u0442\u044c","afa0c088":"The end. You just have seen my first Neural Net. Write your opinion below in comments!"}}