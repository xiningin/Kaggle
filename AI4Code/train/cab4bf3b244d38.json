{"cell_type":{"61f17bc0":"code","d8c639dd":"code","c412aa86":"code","6dfe8fc7":"code","e022aad8":"code","4e59c610":"code","776876eb":"code","30cf0d95":"code","a5fbb997":"code","b670ecc0":"code","2626ead6":"code","02ea4367":"code","6f4a1cff":"code","2458f8bd":"code","c5deaf07":"code","b9cc1ab4":"code","1fffe616":"code","3311c4da":"code","2585dc49":"code","97cc59c4":"code","a5516882":"code","e838532c":"code","756c732d":"code","28ff7404":"code","d6ef40a5":"code","69e4dea0":"code","e7e193b0":"code","e666d766":"code","b9f59795":"code","060ed48e":"code","61755551":"code","6bf5e01c":"code","0ce5af4b":"code","2a488a54":"code","3c4621fc":"code","5b11a758":"code","5963d65e":"code","c8ffc820":"code","2394e141":"code","ada109ee":"code","3dddf239":"code","913316ab":"code","42095dce":"code","1d782d4d":"code","8f27111c":"code","c327cc98":"code","7d915bc5":"code","d0bbd2f0":"code","cb6497c5":"code","5df61197":"code","02f6725e":"code","7442d0d8":"code","d8e2013b":"code","2acee3f8":"code","db9bf56d":"code","29fcb803":"code","4e9b98f4":"code","a6d6dbf8":"code","21d1e9d4":"code","78f23c00":"code","7c19a09e":"code","eb355ba7":"code","d48f6159":"code","3d4ab26f":"code","029d87bf":"code","c8f2d910":"code","6bf2d27a":"code","ccc53bee":"code","0b00d918":"code","a78c50e6":"code","3dbcded8":"code","30fbb80e":"code","903e12cd":"code","79d863a4":"code","0262ba5e":"code","5f444949":"code","f631b22a":"code","419e7294":"code","5d4c16cc":"code","0beeb581":"code","118ce05e":"code","1d9e8f91":"markdown","fbf56bdd":"markdown","2a6f40b7":"markdown","eca0a15a":"markdown","48fc9691":"markdown","9deac8b3":"markdown","b4fcb505":"markdown","70e4b7c7":"markdown","36f93891":"markdown","1575aa71":"markdown","0f149ad4":"markdown","9d9c1d0f":"markdown","75fe226d":"markdown","2677a446":"markdown","20ad6c27":"markdown","4dba3e54":"markdown","c26ff364":"markdown","53d30e0a":"markdown","560ecddb":"markdown","d6fd11ed":"markdown","bfd8371f":"markdown","d64ce65c":"markdown","8b96b8a9":"markdown","a8b35e4b":"markdown","1e8b1e45":"markdown","9f893ce7":"markdown","3b2de8d1":"markdown","b9d9c3a8":"markdown","89b8f41c":"markdown","df714929":"markdown","dafe6731":"markdown","7159ab9c":"markdown","04a98146":"markdown","fbee7432":"markdown","74c82ffc":"markdown","2c85816b":"markdown","5957939e":"markdown","4ca2c785":"markdown","4ef660d5":"markdown","cdeae1bd":"markdown","84ffcdbc":"markdown","49122a69":"markdown","28aa79f0":"markdown","55f32294":"markdown","88a6147f":"markdown","57bbb415":"markdown","9b764394":"markdown","45f3aa5e":"markdown","4d7139ca":"markdown","be153afb":"markdown","a6dd8f90":"markdown","59e54270":"markdown","62ddb96d":"markdown","5034bdf6":"markdown","6a915682":"markdown","a43377fa":"markdown","52ee5dd6":"markdown","11507edd":"markdown","fd4610b5":"markdown","a2d8333e":"markdown","693e8871":"markdown","dab9af27":"markdown","c815b6da":"markdown","742cb471":"markdown","faeef154":"markdown"},"source":{"61f17bc0":"%reload_ext autoreload\n%autoreload 2\n%matplotlib inline","d8c639dd":"#!pip install spacy==3.1.1","c412aa86":"#!pip3 install torch==1.9.0 torchvision==0.10.0\n!pip3 install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio==0.9.0 -f https:\/\/download.pytorch.org\/whl\/torch_stable.html","6dfe8fc7":"#!yes Y|conda install -c fastai fastai=2.5.2\n!pip3 install fastai==2.5.2","e022aad8":"!pip3 install timm","4e59c610":"!pip3 install nnaudio","776876eb":"#export\nfrom typing import Tuple\nfrom collections import namedtuple\nfrom nnAudio.Spectrogram import CQT\nfrom timm import create_model, list_models\nfrom pandas.core.frame import DataFrame\nfrom fastcore.foundation import *\nfrom fastai.vision.all import *\nfrom fastai.torch_core import show_image\nfrom fastai.vision.learner import _update_first_layer","30cf0d95":"path = Path(\"..\/input\")","a5fbb997":"df = pd.read_csv(path\/'g2net-gravitational-wave-detection\/training_labels.csv')","b670ecc0":"df.head(1)","2626ead6":"#export\ndef getfiles(path: Path, ext) -> L:\n    \"Get numpy files in `path` recursively, only in `folders`, if specified.\"\n    return L(path.glob(f'**\/*.{ext}'))","02ea4367":"train_path = path\/'g2net-gravitational-wave-detection\/train'","6f4a1cff":"%%time\ntrain_files = getfiles(train_path, \"npy\")","2458f8bd":"train_files[:2]","c5deaf07":"labels = df.target.to_list()","b9cc1ab4":"#export\ndef map_path_to_labels(data: L, cols: L=None ) -> DataFrame:\n    \"\"\"maps the files to their labels\"\"\"\n    if cols is None: raise ValueError(\"You forgot to provide the columns\")\n    data = dict(zip(cols, data))\n    return pd.DataFrame.from_dict(data)","1fffe616":"%%time\ndf = map_path_to_labels([train_files, labels], cols=[\"id\", \"target\"])","3311c4da":"df.head(1)","2585dc49":"#export\ndef mapxy(df: DataFrame):\n    \"\"\"Create a dictionary of file path and the label from a dataframe\"\"\"\n    return dict(df.values)","97cc59c4":"%%time\nfiles = mapxy(df)","a5516882":"%%time\nfiles[train_files[7]]","e838532c":"def get_label(f: Path):\n    \"\"\"get the label belonging to a file\"\"\"\n    label = None\n    if f in df.values:\n        label = df[df['id'] == f]['target'].values[0]\n    return label","756c732d":"get_label(train_files[0])","28ff7404":"get_label(Path(\"\/ff\/ff.npy\"))","d6ef40a5":"#export\ndef qtfm():\n    \"\"\"convert waves to images\"\"\"\n    cqt = CQT(sr= 2048, fmin= 20, fmax= 1024, hop_length= 32, bins_per_octave=8,verbose=False)\n    return cqt","69e4dea0":"waves = np.load(train_files[0])\nwaves = np.hstack(waves)\nwaves = waves \/ np.max(waves)\nwaves = torch.from_numpy(waves).float()","e7e193b0":"%%time\nqtfm()(waves)","e666d766":"%%time\nfor i in range(5):\n    waves = np.load(df.iloc[i].id)\n    waves = np.hstack(waves)\n    waves = waves \/ np.max(waves)\n    waves = torch.from_numpy(waves).float()\n    image = qtfm()(waves)\n    target = get_label(train_files[i])\n    plt.imshow(image[0])\n    plt.title(f\"target: {target}\")\n    plt.show()","b9f59795":"#export\ndef get_waves(f):\n    \"\"\"read numpy file, stack the timeseries and convert those into a tensor\"\"\"\n    waves = np.load(f)\n    waves = np.hstack(waves)\n    waves = waves \/ np.max(waves)\n    waves = torch.from_numpy(waves).float()\n    return waves\n\ndef create_spectrogram(x: Path):\n    \"\"\"Create an AudioSpectrogram from a torch tensor\"\"\"\n    waves = get_waves(x)\n    return qtfm()(waves)","060ed48e":"#export\nclass AudioImage(fastuple):\n    \"\"\"Custom Image for nnAudio transformed signals\"\"\"\n    def show(self, figsize=None, ctx=None, **kwargs):\n        if len(self) > 1:\n            img,label = self\n        else:\n            img = self\n            label = ''\n    \n        if figsize is None: figsize=(10,10)\n        return show_image(img, \n                          title=label, figsize=figsize, ctx=ctx)","61755551":"image = create_spectrogram(train_files[0])","6bf5e01c":"type(image), image.shape","0ce5af4b":"image","2a488a54":"get_label(train_files[0])","3c4621fc":"s = AudioImage(image, get_label(train_files[0]))\ns.show()","5b11a758":"%%time\nvals = df.target.to_list()","5963d65e":"%%time\nvocab,o2i = uniqueify(vals, sort=True, bidir=True)","c8ffc820":"lbl2path = mapxy(df)","2394e141":"%%time\nlbl2path[train_files[5]]","ada109ee":"#export\n#ItemTransform let's you work with tuple elements\nclass NNAudioTransform(ItemTransform):\n    \"\"\"Custom Transform which uses nnAudio transforms\n    to extract spectogram on the fly\"\"\"\n    def __init__(self, df: DataFrame, col: str = 'target'):\n        self.lbl2files = mapxy(df)\n        vals = df[col].to_list()\n        self.vocab,self.o2i = uniqueify(vals, sort=True, bidir=True)\n        \n    def encodes(self, o): return (create_spectrogram(o), self.o2i.get(self.lbl2files.get(o)))\n    def decodes(self, x): return AudioImage(x[0],self.vocab[x[1]])","3dddf239":"subset_for_dsets = train_files[:20000]","913316ab":"splits = TrainTestSplitter()(subset_for_dsets)\ntfm = NNAudioTransform(df)","42095dce":"%%time\ntls = TfmdLists(subset_for_dsets, tfm, splits=splits)","1d782d4d":"tls.vocab","8f27111c":"show_at(tls.train, 1)","c327cc98":"dls = tls.dataloaders(after_item=[ToTensor()], after_batch=[IntToFloatTensor(), Normalize.from_stats(*imagenet_stats)])","7d915bc5":"#export\n@typedispatch\ndef show_batch(x:AudioImage, y, samples, ctxs=None, max_n=6, nrows=None, ncols=3, figsize=None, **kwargs):\n    if figsize is None: figsize = (ncols*6, max_n\/\/ncols * 3)\n    if ctxs is None: ctxs = get_grid(min(x[0].shape[0], max_n), nrows=None, ncols=ncols, figsize=figsize)\n    for i,ctx in enumerate(ctxs):\n        AudioImage(x[0][i], ['0','1'][x[1][i].item()]).show(ctx=ctx)","d0bbd2f0":"%%time\ndls.show_batch()","cb6497c5":"class Spectrogram(TensorImageBase):\n    \"\"\"Type to represent a spectogram which knows show itself\"\"\"\n    @classmethod\n    def create(cls, o):\n        waves = get_waves(o)\n        return cls(qtfm()(waves))\n    \n    def show(self, figsize=None, ctx=None, **kwargs): \n        t = self\n        if not isinstance(t, Tensor): return ctx\n        if figsize is None: figsize=(10,10)\n        return show_image(t, figsize=figsize, ctx=ctx)","5df61197":"spectrogram = Spectrogram.create(train_files[0])\ntype(spectrogram)","02f6725e":"spectrogram.show()","7442d0d8":"ImageBlock??","d8e2013b":"def SpectrogramBlock(cls=Spectrogram) : \n    \"A `TransformBlock` for spectograms of `cls`\"\n    return TransformBlock(type_tfms=cls.create, batch_tfms=IntToFloatTensor)","2acee3f8":"g2net = DataBlock(blocks=(SpectrogramBlock, CategoryBlock),\n                   splitter=RandomSplitter(),\n                   get_x=ColReader(0),\n                   get_y=ColReader(1),\n                   batch_tfms=aug_transforms())","db9bf56d":"dls = g2net.dataloaders(df.iloc[:2000])","29fcb803":"%%time\ndls.show_batch()","4e9b98f4":"create_cnn_model??","a6d6dbf8":"#export\ndef create_timm_body(arch, n_in=3, pretrained=True, cut=None):\n    \"Cut off the body of a typically pretrained timm library `arch` as determined by `cut`\"\n    model = create_model(arch, pretrained=pretrained, num_classes=0, in_chans=1,global_pool='')\n    _update_first_layer(model, n_in, pretrained)\n    #cut = ifnone(cut, cnn_config(arch)['cut'])\n    if cut is None:\n        ll = list(enumerate(model.children()))\n        cut = next(i for i,o in reversed(ll) if has_pool_type(o))\n    if   isinstance(cut, int):      return nn.Sequential(*list(model.children())[:cut])\n    elif callable(cut): return cut(model)\n    else:  raise NamedError(\"cut must be either integer or a function\")","21d1e9d4":"create_cnn_model??","78f23c00":"create_head?","7c19a09e":"#export\n@delegates(create_head)\ndef create_timm_model(arch, n_out, pretrained=True, cut=None, n_in=3, init=nn.init.kaiming_normal_, custom_head=None,\n                     concat_pool=True, in_chans=1, **kwargs):\n    \"Create custom architecture from the timm library\"\n    body = create_timm_body(arch, n_in, pretrained, None)\n    if custom_head is None:\n        nf = num_features_model(nn.Sequential(*body.children()))\n        head = create_head(nf, n_out, concat_pool=concat_pool, **kwargs)\n    else: head = custom_head\n    model = nn.Sequential(body, head)\n    if init is not None: apply_init(model[1], init)\n    return model","eb355ba7":"# num of classes\nn_out = 2","d48f6159":"model = create_timm_model(\"efficientnet_b3a\", n_out)","3d4ab26f":"L(model.children())","029d87bf":"cnn_learner??","c8f2d910":"#export\n@delegates(create_timm_model)\ndef timm_learner(dls, arch, n_out=None, pretrained=True,\n                # learner args\n                loss_func=None, opt_func=Adam, lr=defaults.lr, splitter=None, cbs=None, metrics=None, path=None,\n                model_dir='models', wd=None, wd_bn_bias=False, train_bn=True, moms=(0.95,0.85,0.95),\n                # other model args\n                **kwargs):\n    \"Build a convnet style learner from `dls` and `timm arch`\"\n\n    kwargs = {**kwargs}\n    if n_out is None: n_out = get_c(dls)\n    assert n_out, \"`n_out` is not defined, and could not be inferred from data, set `dls.c` or pass `n_out`\"\n    model = create_timm_model(arch, n_out, default_split, pretrained, **kwargs)\n\n    learn = Learner(dls=dls, model=model, loss_func=loss_func, opt_func=opt_func, lr=lr, splitter=default_split, cbs=cbs,\n                   metrics=metrics, path=path, model_dir=model_dir, wd=wd, wd_bn_bias=wd_bn_bias, train_bn=train_bn,\n                   moms=moms)\n    if pretrained: learn.freeze()\n    # keep track of args for loggers\n    store_attr('arch,n_out,pretrained', self=learn, **kwargs)\n    return learn","6bf2d27a":"list_models(\"efficient*\")","ccc53bee":"#export\ndef show_me_lrs(learn, num_it:int= 10):\n    Suggested_lrs = namedtuple('Suggested_lrs', [\"min\", \"steep\",\n                                            \"valley\", \"slide\"])\n    lrs = learn.lr_find(suggest_funcs=(minimum, steep,valley, slide))\n    suggested_lrs = Suggested_lrs(lrs[0], lrs[1], lrs[2], lrs[3])\n    \n    print(f\"Minimum\/10:\\t{lrs[0]:.2e}\\\n          \\nSteepest point:\\t{lrs[1]:.2e}\\\n          \\nLongest valley:\\t{lrs[2]:.2e}\\\n          \\nSlide interval:\\t{lrs[3]:.2e}\")\n    \n    return suggested_lrs","0b00d918":"learn = timm_learner(dls, 'efficientnet_b7', loss_func=CrossEntropyLossFlat(), metrics=[RocAucBinary(axis=0)], n_out=2).to_fp16()","a78c50e6":"learn.fit_one_cycle(1, 3e-3)","3dbcded8":"#to recover gpu ram\nlearn.save('epoch1')\nlearn.load('epoch1')","30fbb80e":"import gc; gc.collect()","903e12cd":"suggested_lrs = show_me_lrs(learn)\n#learn.lr_find(suggest_funcs=(minimum, steep,valley, slide))","79d863a4":"learn.unfreeze()\nlearn.fit_one_cycle(3, suggested_lrs.slide)","0262ba5e":"learn.export(\".\/final\")","5f444949":"%%time\ntest_path = path\/'g2net-gravitational-wave-detection\/test'\ntest_files = getfiles(test_path, \"npy\")","f631b22a":"learn = load_learner('.\/final', cpu=False)","419e7294":"test_dls = learn.dls.test_dl(test_files[:100])","5d4c16cc":"test_dls.show_batch()","0beeb581":"preds = learn.get_preds(dl=test_dls)","118ce05e":"preds","1d9e8f91":"Here we go. We have managed to get a port of the learner code which looks the part. Does it work?\n\nLet me find out.\n\n> To find the list of models available in the timm library use `list_models`","fbf56bdd":"Quick test to see if this works.","2a6f40b7":"But first we will create our custom `create_body` and `create_head` functions. the reason for this is that fastai in it's current state is not integrated with the timm library. So, creating custom versions of `create_body` and `create_head` makes the weaving of timm into fastai re-usable.\n\nThe insipration for this is the [post](https:\/\/walkwithfastai.com\/vision.external.timm#create_timm_body) in 'walk with fastai'. Once again the code and the approach is based on this post.\n\n> I am recreating this again here instead of using the 'walk with fastai' library is to drill down into the concept and for my personal learning.","eca0a15a":"## create_timm_body(arch, n_in=3, pretrained=True, cut=None)","48fc9691":"## mapxy(df)","9deac8b3":"Create a test dataloader. This will take in the test files and apply the transforms that we had created during trainign timebut on the inference data and give you a dataloader.","b4fcb505":"## Make your own model\ud83c\udf55\nWe are going to use the timm library as the source of our model. To weave it into fastai, we will create a custom fastai model.\n\nAll the code below is heavily inspired by-->\n\n* [Ayushman's](https:\/\/www.kaggle.com\/benihime91) [notebook](https:\/\/www.kaggle.com\/benihime91\/fastai-timm-efficientnet-train-fold-0).\n* fastai siamese [tutorial](https:\/\/docs.fast.ai\/tutorial.siamese.html).\n\nWe will also take into account the structure of fastai's `create_cnn_model` class. The code for which is as follows","70e4b7c7":"Fit one epoch to see how it behaves","36f93891":"Here we go","1575aa71":"`typedispatch` does something similar to [multi-dispatch](https:\/\/en.wikipedia.org\/wiki\/Multiple_dispatch). So, that whenever we call the `show_batch` on our image type then fastai will call our version of `show_batch` after recognizing our image type.","0f149ad4":"combining all above steps","9d9c1d0f":"but does it work?  let's test it.","75fe226d":"Picking labels from the dataframe. We may need these labels later.","2677a446":"Let's create a type to represent our spectrogram","20ad6c27":"Next, we create the dataloader.","4dba3e54":"Now that we have a way to create a body, we will use the code from `create_cnn_model` to build our custom `create_timm_model`.\n\nThe code for `create_timm_model` is as follows.","c26ff364":"Next, we have to tell fastai to take our 'sample' and apply the transform and the splitter to it.","53d30e0a":"---\n**NOTE**\n\nRemember to set `verbose` False if you don't want all the string output to be displayed everytime dataloader loads the data.\n\n---","560ecddb":"In the above class we use the functions `get_waves` and `qtfm()` defined in the previous sections to create a spectrogram. The `show` method is also similar to the `show` method which we had used in the previous section. The only difference is that in this show method we are not taking the label into account because the `Spectogram` is just a type of a file converted to a spectrogram.","d6fd11ed":"Let's do a quick test to check if our custom model works.","bfd8371f":"## Inference","d64ce65c":"Here we go. Now we have a custom block and we can create a DataBlock as well as dataloaders and then display it.","8b96b8a9":"## Conclusion\nI prepared this post as part of my experimentation for the [g2net-gravitational-wave-detection](https:\/\/www.kaggle.com\/c\/g2net-gravitational-wave-detection) competition. My goal for preparing this notebook was to design an end-to-end flow to learn about extending fastai for a custom new task and how to extend the library to work well with other libraries.\n\nIt took quite a long time to get my head around the low-level and mid level API in fastai.\n\nPart of the reason being that I couldn't spend much time on this competition and the other part was that there are very few resources available at this moment which provide good detail about creating custom bits using fastai's mid-level and low-level APIs. \n\nI would like to say that the effort that it took to complete this post was worth it and I came to know how powerful the modular structure of fastai is.\n\nI would like to create an extension library using the code that I have developed for this post but at this moment I can't say how soon I would be able to do it and when but stay tuned as I would keep posting my progress on this.\n","a8b35e4b":"## Modularity \ud83e\udde9\n\nThe way that we have created the above transform works well for a specific type of task. There are somethings which could not be answered by the above transform.\n\n* What is the categories are other than 0 and 1.\n* What if it's a multicategory problem.\n* How to handle the lack of targets during inference? \n  * This could be handled by having a `setups` method inside the transform and have it accept list of filenames. This could work well when data is small but for huge data mapping the labelling function to all the filenames in order to create a vocab and label maps would take lots of time. In short it doesn't scale well.\n  \nSo what do we do?\n\nThe solution is to create a custom datablock for our type of task which can then be plugged into a `Datablock` like this-->\n\n```\nDataBlock(blocks=(NNAudioBlock, MultiCategoryBlock),\n                   splitter=ColSplitter(),\n                   get_x=lambda x:pascal_source\/\"train\"\/f'{x[0]}',\n                   get_y=lambda x:x[1].split(' '),\n                   item_tfms=Resize(224),\n                   batch_tfms=aug_transforms())\n```","1e8b1e45":"## Inference\ud83e\uddd0\nFor inference you will need to use the previous dataloader to create a test dataloader by passing the test files to it.","9f893ce7":"Have a look at your predictions.","3b2de8d1":"We will also use a 'splitter' which tells fastai the way we want to split our data. For now we will use `RandomSplitter` to do this job. Additionally we will also instantiate the `NNAudioTransform` object.","b9d9c3a8":"Just a quick test to see if we got the correct files.","89b8f41c":"Let's build our own.\n\nWe will cut off the head of a timm pretrained model using `create_body` and take the encoder only as this would be the portion of the pretrained model which I would like to use. Then I will top it off with a custom fastai head using `create_head` that we would need to train on our target data.\n\nTo know more about this flow have a look into the fastai siamese [tutorial](https:\/\/docs.fast.ai\/tutorial.siamese.html).","df714929":"Now, we can create a custom block for our data. A block is a set of default transforms which is supposed to be applied to your data in order to tell fastai about the type of your data. \n\nIn our custom block we will tell fastai how create a Spectrogram block and then apply `IntToFloatTensor` transform.\n\nThe source code an `ImageBlock` is like this-->","dafe6731":"One more thing that we need to do is to make the `show_batch` method aware of the type of our Image. This can be easily done by using `typedispatch` to dispatch our `show_batch` (the one which we will override with our image type). ","7159ab9c":"## Creating the dataset\ud83d\uddab\nIf you want to use fastai's learner to train your model on the transfomed spectograms, you can do so by creating a custom Dataset in pytorch and then feeding that dataset with a dataloader to fastai's learner. However, if you create a pipeline using fastai's internals then you get to use some cool functionalities out-of-box. We will see that in a while.\n\nAll the code below are very heavily insipired by the original inspiration of this notebook (see the very first section), this [post](https:\/\/ohmeow.com\/posts\/2020\/04\/11\/finding-datablock-nirvana-part-1.html) by Wayde Gilliam and the fastai s[iamese tutorial](https:\/\/docs.fast.ai\/tutorial.siamese.html#Writing-your-custom-data-block).","04a98146":"## Installing all the required libraries\u2699\ufe0f\n\ud83d\udc49 Spacy\n\n\ud83d\udc49 Fastai\n\n\ud83d\udc49 nnAudio\n\n\ud83d\udc49 timm","fbee7432":"For inference we first load the learner","74c82ffc":"We will take a few samples only to make our experiment quicker.","2c85816b":"The `tfm` is a transform is would be applied to the input files to generate the spectogram. The second list has the transform which will be applied to our targets. ","5957939e":"cool! so it works.\n\nNow, we will build a learner which would enable us to do transfer learning with timm models. Once again we will port `cnn_learner` for our use and like before let's quickly take a look into the `cnn_learner` code","4ca2c785":"Cool! so we are able to plot the images now. IT is fast too.","4ef660d5":"Use `get_preds` to get predictions in batches.","cdeae1bd":"## What is this? \ud83e\udd14\nExperiment to weave nnaudio, timm and fastai together\n\n## What I have tried to explore here? \ud83d\udd0d\n\ud83d\udc49 Extend Fastai for signal processing and time series: \n\n    * To use nnAudio for faster processing than librosa or other signal\/audio processing methods.\n    * To deal with time series data as images.\n    * To deal with cosmological data like gravitational waves.1\n\n\ud83d\udc49 Create custom Transform.\n\n\ud83d\udc49 Create custom block.\n\n\ud83d\udc49 Create a dataloader.\n\n\ud83d\udc49 Create a custom model with models from the timm library.\n\n\ud83d\udc49 Create custom learner.","84ffcdbc":"I will use the slide algorithm here to get the optimal learning rate.","49122a69":"The `@delegate` macro tells fastai to show the parameters of any `**kwargs` (which we would be using in the `create_body`) during function [introspection](https:\/\/fastcore.fast.ai\/meta.html#delegates).","28aa79f0":"## NNAudioDataset\nYou can create a Dataset in fastai by creating a custom Transform . Creating a `Transform` has come advantages as compared to a pytorch Dataset. For example, you don't need to have a `len` component or a `get_item` component.\n\nOn a very high level a `Transform` has an `encodes`, `decodes` and `setup` methods. For our purpose having an `encodes` methods only would suffice. This is the place where we would be transforming the numpy data into spectograms.\n\nTo know more about `Tranforms` refer these -->\n* [data block nirvana](https:\/\/ohmeow.com\/posts\/2020\/04\/11\/finding-datablock-nirvana-part-1.html)\n* [Siamese tutorial](https:\/\/docs.fast.ai\/tutorial.siamese.html#Writing-your-custom-data-block)\n* [Fastbook chapter-11](https:\/\/github.com\/fastai\/fastbook\/blob\/master\/11_midlevel_data.ipynb)\n* [Albumentation tutorial](https:\/\/docs.fast.ai\/tutorial.albumentations.html)","55f32294":"We will use the source code for `ImageBlock` to create our custom block.","88a6147f":"## Q transform using nnaudio\u2697\ufe0f\nWe will design a function that would get the q transform of the time series on the fly using nnaudio.\nThe result will be similar to converting the time series data into images.\n\nCode taken from [notebook](https:\/\/www.kaggle.com\/yasufuminakama\/g2net-efficientnet-b7-baseline-training) shared by [Y.Nakama](https:\/\/www.kaggle.com\/yasufuminakama)","57bbb415":"## Spectogram","9b764394":"## NNAudioTransform(ItemTransform)","45f3aa5e":"Now that we have our custom block ready, we can test if a DataBlock can now be created.","4d7139ca":"Ok! The performance is not that great but the goal of this exercise was not to have a SOTA model but rather to learn how to create a custom code base by using Fastai internals.\n\nHowever, with proper data augmentation and more data the performance can be much better.","be153afb":"### Get labels\ud83c\udfd7\ufe0f\nTraining labels are in the 'training_labels.csv' file.","a6dd8f90":"check the batch","59e54270":"## The learner\ud83d\udc69\u200d\ud83c\udfeb\nNow that we have the model in place, we can go ahead and create the learner the usual way. We have kept the batch size to default.\n\nThere is one little thing that I would like to do before creating a learner. I will create a helper function which can help me to get the suggested learning rate quickly.","62ddb96d":"## Map path to labels\ud83d\uddfa\ufe0f\nTo make things easier I will try to map the file paths to their respective labels and create a datafrane out of it.","5034bdf6":"## Import all required modules\ud83d\udda5\ufe0f","6a915682":"## getfiles(path: Path, ext)\nGet numpy files in `path` recursively, only in `folders`, if specified.\n\n> The \"#export\" in the function below and all the rest of the functions\/code are there to help me use nbdev to export the required code into a library later.","a43377fa":"`TfmdLists` is a low-level API which creates a pipeline for us. It creates a pipeline that takes in our samples-->splits it --> applies our transform to the items.\n\nMore information on a `TfmdLists` can be found in this [tutorial](https:\/\/docs.fast.ai\/tutorial.pets.html) fromt he official documentation.","52ee5dd6":"## get_label(f: Path)","11507edd":"## Create the Dataloader\ud83d\udda8\ufe0f\nWe can use the `TfmdLists` to create a dataloader by calling `dataloaders()`. Here, we can't apply `item_tfms` or `batch_tfms` but we can get the hooks to different point of the pipeline and can put our transforms there.\n\nFor example, once items are grabbed then that moment is known as \"after_item\". We can use this hook to apply our transforms once items are grabbed.","fd4610b5":"## create_timm_model","a2d8333e":"## NNAudioImage(fastuple)\nFirst of all, we are going to create an \"Image type\" for our transformed object (it's the numpy data transformed into spectrogram). \n\nWe have to do this because our data is not an image data from get-go. Rather it's a signal data which we are transforming into an Image.  So, to tell fastai that this is a custom Image type which we are dealing with and ho we should be displaying it, we have to create an Image type.","693e8871":"Voila! it knows how to show itself.","dab9af27":"I am using the previous function to get all the files under the train folder.","c815b6da":"Let's walk through the code.\n\nIf you inherit from the `Transform` class, the resulting transform is applied to the item as a whole but when you inherit from the `ItemTransform` class then the resulting transform is applied to each element of the input.\n\nFor example, if you have a transform that is inherited from the `Transform` class and you have an input which is a tuple `(\"a\", 1)` then the transform would consider the tuple as a single element. But, when your transform is an `ItemTransform` then the transform is applied to \"a\" as well as \"1\" separately. \n\nThe __init__ method sets up our `mapxy` method as a class property. It then converts the target column values into a list and creates a vocab of our targets and a dictionary mapping our targets to indices.\n\nThe encodes method is where the magic occurs. Here, we return a tuple with our spectogram and the label related to our input. \n\nThe decodes method returns an `AudioImage` type which knows how to show itself whenever a `show` method is invoked.\n\nYou might notice that I have used a dataframe to create a list of our inputs and a dictionary of our labels. This was an engineering choice which I made because creating a list of labels from the input list of filenames was too slow. Doing it this was by using a dataframe  made things faster.\n\n> In deep learning a majority chunk of the speed boost comes from good engineering practices rather than having the best SOTA architectures or a faster computer.","742cb471":"Using the learning rate finder to get the learning rate","faeef154":"## Get the files\ud83c\udfd7\ufe0f\nI will try to grab all the numpy files inside train folder"}}