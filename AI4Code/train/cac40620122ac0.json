{"cell_type":{"e3c55fdf":"code","e0f3e381":"code","37b4cfaa":"code","3ac4661d":"code","a7ba3673":"code","3edee2b9":"code","2df2d163":"code","31a4d92e":"code","1f2e6a43":"code","09ca8d04":"code","d271c6d9":"code","25755274":"code","10d9fb07":"code","dfbfe3e1":"code","cfbd0a1f":"code","a914845d":"code","10b7bc20":"code","58df5afc":"code","03f24425":"code","20532c18":"code","3026bee8":"code","5036b76f":"code","e9bd36b2":"code","46284e43":"code","33637ef1":"code","235ef770":"code","a72be877":"code","24174431":"code","675ccb84":"markdown","10b71ec5":"markdown","a8aed4ae":"markdown"},"source":{"e3c55fdf":"# Arquivo de dados\nimport os\nprint(os.listdir(\"..\/input\"))","e0f3e381":"#carregarando os dados\nimport pandas as pd\nimport numpy as np","37b4cfaa":"df = pd.read_csv('..\/input\/hmeq.csv')\ndf.head()","3ac4661d":"#Preencha os valores de NA \/ NaN usando o m\u00e9todo especificado.\ndf.fillna(df.mean(), inplace=True)","a7ba3673":"df.info()","3edee2b9":"#colocando colunas e nas category converter objetos pandas inteiros no mesmo tipo.\nfor col in df.columns:\n    if df[col].dtype == 'object':\n        df[col]= df[col].astype('category').cat.codes","2df2d163":"df.info()","31a4d92e":"#Pegabdi as 12 primeiras amostras\ndf.sample(12)","1f2e6a43":"#Dividir matrizes ou matrizes em subconjuntos aleat\u00f3rios de trem e teste\nfrom sklearn.model_selection import train_test_split","09ca8d04":"#fazendo o mesmo com matrizes s\u00f3 que usando o teste\ntrain, teste = train_test_split(df, test_size=0.3, random_state=42)","d271c6d9":"#representando a dimensao do nosso train\ntrain.shape","25755274":"#representando a dimensao do nosso train\nteste.shape","10d9fb07":"#representa a propor\u00e7\u00e3o do conjunto de dados e eetornando amostra aleat\u00f3ria de itens de um eixo de objeto \ntrain, teste = train_test_split(df, test_size=0.3, random_state=42)","dfbfe3e1":"#Retornando sem valores nulos\ntrain, valid = train_test_split(train, random_state=42)","cfbd0a1f":"#Verificando a dimen\u00e7\u00e3o do DataFrame\ntrain.shape, valid.shape, teste.shape","a914845d":"#Importando uma arvore de desci\u00e7\u00e3o de regress\u00e3o  \nfrom sklearn.tree import DecisionTreeRegressor","10b7bc20":"#fzdo reprodutibilidade e sendo profundidade m\u00e1xima da \u00e1rvore = 2.\ndt = DecisionTreeRegressor(random_state=42, max_depth=2)","58df5afc":"feats = [c for c in df.columns if c not in ['BAD']]","03f24425":"#Importando um Um classificador de floresta aleat\u00f3rio\nfrom sklearn.ensemble import RandomForestClassifier","20532c18":"clf = RandomForestClassifier(random_state=42)","3026bee8":"clf.fit(train[feats], train['BAD'])","5036b76f":"#Importando o escore de classifica\u00e7\u00e3o de precis\u00e3o.\n\nfrom sklearn.metrics import accuracy_score","e9bd36b2":"accuracy_score(valid['BAD'], clf.predict(valid[feats]))","46284e43":"from sklearn.metrics import confusion_matrix","33637ef1":"confusion_matrix(valid['BAD'],clf.predict(valid[feats]))","235ef770":"cm =confusion_matrix(valid['BAD'],clf.predict(valid[feats]))","a72be877":"import itertools\nimport matplotlib.pyplot as plt\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n #Imprimindo e normalizando\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","24174431":"#Plotando a matrix de confus\u00e3o\nplot_confusion_matrix(cm, ['False', 'True'])","675ccb84":"#BONUS 2 -Explique o que \u00e9 precis\u00e3o na matriz de confus\u00e3o acima e d\u00ea 1 exemplo onde isso pode ser \u00fatil. ->\ncalcula a precis\u00e3o do conjunto \u00e9 a fra\u00e7\u00e3o de inst\u00e2ncias recuperadas que s\u00e3o relevantes sendo calcula a precis\u00e3o do conjunto, entre todas as classifica\u00e7\u00f5es de classe Positivo que o modelo fez, quantas est\u00e3o corretas. Sendo o resultado o mesmo determinado no modelo.","10b71ec5":"#BONUS1 -Plote uma matriz de confus\u00e3o nas previs\u00f5es dos dados de valida\u00e7\u00e3o.","a8aed4ae":"#BONUS 3 -Explique o que \u00e9 recall na matriz de confus\u00e3o acima e d\u00ea 1 exemplo onde isso pode ser \u00fatil. ->\nServe para identificar a sua preci\u00e7\u00e3o para prever, a classe de o que quer prever, sendo a razap entre verdadeiro positivos e soma dos negativos falsos\n"}}