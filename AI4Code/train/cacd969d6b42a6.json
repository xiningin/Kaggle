{"cell_type":{"125aaec3":"code","64b14f5c":"code","95aad6eb":"code","4feab433":"code","f67064a5":"code","2575b3a8":"code","51f3bc72":"code","d0f1332a":"code","009d7ed5":"code","dca3d7f9":"markdown","ca2ea057":"markdown","c24e8642":"markdown","a75a10d7":"markdown","54b19da0":"markdown","7449e592":"markdown","434520b4":"markdown","d666a228":"markdown","70a25e37":"markdown"},"source":{"125aaec3":"import numpy as np\nimport pandas as pd\nimport os, json, gc, re, random\nfrom tqdm.notebook import tqdm\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport plotly.express as px\nimport seaborn as sns\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\ntransformers_logger = logging.getLogger(\"transformers\")\ntransformers_logger.setLevel(logging.WARNING)","64b14f5c":"%%time\n\n!pip uninstall -q torch -y\n!pip install -q torch==1.6.0+cu101 -f https:\/\/download.pytorch.org\/whl\/torch_stable.html\n!pip install -q -U tokenizers==0.7.0 > \/dev\/null\n!pip install -q -U transformers==3.0.2 > \/dev\/null\n!pip install -q -U simpletransformers==0.46.0 > \/dev\/null","95aad6eb":"import torch, transformers, tokenizers\ntorch.__version__, transformers.__version__, tokenizers.__version__","4feab433":"movies_df = pd.read_csv(\"..\/input\/wikipedia-movie-plots\/wiki_movie_plots_deduped.csv\")\nmovies_df","f67064a5":"movies_df = movies_df[(movies_df[\"Origin\/Ethnicity\"]==\"American\") | (movies_df[\"Origin\/Ethnicity\"]==\"British\")]\nmovies_df = movies_df[[\"Plot\", \"Genre\"]]\ndrop_indices = movies_df[movies_df[\"Genre\"] == \"unknown\" ].index\nmovies_df.drop(drop_indices, inplace=True)\n\n# Combine genres: 1) \"sci-fi\" with \"science fiction\" &  2) \"romantic comedy\" with \"romance\"\nmovies_df[\"Genre\"].replace({\"sci-fi\": \"science fiction\", \"romantic comedy\": \"romance\"}, inplace=True)\n\n# Choosing movie genres based on their frequency\nshortlisted_genres = movies_df[\"Genre\"].value_counts().reset_index(name=\"count\").query(\"count > 200\")[\"index\"].tolist()\nmovies_df = movies_df[movies_df[\"Genre\"].isin(shortlisted_genres)].reset_index(drop=True)\n\n# Shuffle DataFrame\nmovies_df = movies_df.sample(frac=1).reset_index(drop=True)\n\n# Sample roughly equal number of movie plots from different genres (to reduce class imbalance issues)\nmovies_df = movies_df.groupby(\"Genre\").head(400).reset_index(drop=True)\n\nlabel_encoder = LabelEncoder()\nmovies_df[\"genre_encoded\"] = label_encoder.fit_transform(movies_df[\"Genre\"].tolist())\n\nmovies_df = movies_df[[\"Plot\", \"Genre\", \"genre_encoded\"]]\nmovies_df","2575b3a8":"%%time\n\nfrom simpletransformers.classification import ClassificationModel\n\nmodel_args = {\n    \"reprocess_input_data\": True,\n    \"overwrite_output_dir\": True,\n    \"save_model_every_epoch\": False,\n    \"save_eval_checkpoints\": False,\n    \"max_seq_length\": 512,\n    \"train_batch_size\": 16,\n    \"num_train_epochs\": 4,\n}\n\n# Create a ClassificationModel\nmodel = ClassificationModel('bert', 'bert-base-cased', num_labels=len(shortlisted_genres), args=model_args)","51f3bc72":"%%time\n\ntrain_df, eval_df = train_test_split(movies_df, test_size=0.2, stratify=movies_df[\"Genre\"], random_state=42)\n\n# Train the model\nmodel.train_model(train_df[[\"Plot\", \"genre_encoded\"]])\n\n# Evaluate the model\nresult, model_outputs, wrong_predictions = model.eval_model(eval_df[[\"Plot\", \"genre_encoded\"]])\nprint(result)","d0f1332a":"predicted_genres_encoded = list(map(lambda x: np.argmax(x), model_outputs))\npredicted_genres = list(label_encoder.inverse_transform(predicted_genres_encoded))\neval_gt_labels = eval_df[\"Genre\"].tolist()\nclass_labels = list(label_encoder.classes_)\n\nplt.figure(figsize=(22,18))\ncf_matrix = confusion_matrix(predicted_genres, eval_gt_labels, class_labels)\nax = sns.heatmap(cf_matrix\/np.sum(cf_matrix), annot=True, cmap=\"YlGnBu\")\nax.set_xlabel('Predicted Genres', fontsize=20)\nax.set_ylabel('True Genres', fontsize=20)\nax.set_title('Confusion Matrix', fontsize=20)\nax.set_xticklabels(class_labels, rotation=90, fontsize=18)\nax.set_yticklabels(class_labels, rotation=0, fontsize=18)\n\nplt.show()","009d7ed5":"for _ in range(100):\n\n    random_idx = random.randint(0, len(eval_df)-1)\n    text = eval_df.iloc[random_idx]['Plot']\n    true_genre = eval_df.iloc[random_idx]['Genre']\n\n    # Predict with trained multiclass classification model\n    predicted_genre_encoded, raw_outputs = model.predict([text])\n    predicted_genre_encoded = np.array(predicted_genre_encoded)\n    predicted_genre = label_encoder.inverse_transform(predicted_genre_encoded)[0]\n\n    print(f'\\nTrue Genre:'.ljust(16,' '), f'{true_genre}\\n')\n    print(f'Predicted Genre: {predicted_genre}\\n')\n    print(f'Plot: {text}\\n')\n    print(\"-------------------------------------------\")","dca3d7f9":"## Plot Heatmap \ud83d\udcc9","ca2ea057":"### Read CSV Data \ud83d\udcdd","c24e8642":"### Heatmap (w. labels & annotations)","a75a10d7":"# Introduction\n\n#### In this notebook, we use [BERT](https:\/\/arxiv.org\/abs\/1810.04805) Transformer model to predict movie genres from wikipedia movie plots","54b19da0":"## Libraries \ud83d\udcda\u2b07","7449e592":"## Prediction \ud83d\udd2e","434520b4":"<h1><center>Movie Genre Prediction from Wiki Movie Plots<\/center><\/h1>","d666a228":"## BERT Training & Evaluation \ud83d\ude9e","70a25e37":"## Data Pre-processing \u2699\ufe0f"}}