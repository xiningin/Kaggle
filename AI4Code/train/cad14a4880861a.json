{"cell_type":{"199774e0":"code","44dd611a":"code","e2b810d6":"code","ffdfb878":"code","a27a27f0":"code","6b0d583c":"code","2ecd85c2":"code","43dbcb4a":"code","4123f074":"code","bff9703a":"code","55dcae56":"code","75dab3a7":"code","5649a391":"code","d9aaf49d":"code","b8059d17":"code","94861757":"code","49cc5db3":"code","44a96ab8":"code","e7180f86":"code","8f17a002":"code","989d5044":"code","edea49e4":"code","9579bfe6":"code","c0578561":"code","f1e2b115":"code","594623f1":"code","4457b54a":"code","1f8606ce":"code","033baa49":"code","2935df4a":"code","f5132198":"code","61dc97b5":"code","476507bf":"code","e73ccf53":"code","705bdd15":"code","3f3fd86d":"code","db14e8d7":"code","bd1f22db":"code","2ad67be1":"code","d8587243":"code","1c3d6be1":"code","9ee695ae":"code","5d9a992d":"code","f7da0939":"code","ca7dfbc9":"code","f4623bd9":"code","e14a122f":"code","6b63e25c":"code","2d515160":"code","6e166a18":"code","2b1c58c5":"code","e5311256":"code","1c6fdf0f":"code","7cc6a0e5":"code","29d0d751":"code","24b78408":"code","f8d9232f":"code","5c780932":"code","37f590cf":"code","c873b65f":"code","26882efd":"code","09405fbe":"code","c89bdb0e":"code","66f6b49b":"code","8ecb480d":"code","61cf06b5":"code","a8abe6ea":"code","99bf2932":"code","f225b01c":"code","fdd45825":"code","6b41e591":"code","495d60eb":"code","92846152":"code","67680e97":"code","aa3990d3":"code","f4adfddd":"code","d4f6a4f7":"code","1b451b9e":"code","d90ae146":"code","18923c19":"code","8ead5885":"code","cad85d34":"code","6daac958":"code","b8088f1e":"code","d52b0ba3":"code","b767efbd":"code","54fbd521":"code","2205e995":"code","233b279c":"code","156f4548":"code","ca679d1f":"code","c10c5d10":"code","53582dcf":"code","3c70002a":"code","49eb0630":"code","b580dfbe":"code","1b7bd865":"code","e2e1ba59":"code","34c2ff21":"code","8ddda3c5":"code","1ea1f148":"code","2c1ea639":"code","4204313a":"code","d494e1c2":"code","0a634dfe":"code","b3b45146":"code","63e0bb03":"code","5f85f228":"code","4aef2b6c":"code","fc6aed56":"code","b67a4459":"code","b7a44d38":"code","e72b39de":"code","ab787603":"code","82bc1ed1":"code","3531349a":"code","e849bbdb":"code","9c616066":"code","64def790":"code","451c7e24":"code","f0a5291f":"code","944368a4":"code","d079da64":"code","3fc3753b":"code","10619010":"code","1682b9d5":"code","70fe6e9a":"code","20f3912c":"code","f7313967":"code","03a4c561":"code","49334011":"code","d825465c":"code","f02a1947":"code","a828f337":"code","3c77e791":"code","642faf24":"code","9085e1d0":"code","65232ab7":"code","955cec29":"code","d1f9123a":"code","33ef9d5e":"code","2ddfe69e":"code","2575b068":"code","433d920d":"code","0d36b906":"code","9571eac1":"code","37077089":"code","520fbd17":"code","90728e39":"code","4db2afc3":"code","e26f394a":"code","8a47141e":"code","9aa8fc94":"code","2ce87506":"code","e5b708ac":"code","2c231ed9":"code","89fa8e03":"code","4a22c4ac":"code","be0f6d35":"code","7d1ee983":"code","3a34fa2c":"code","343a282c":"code","7e465056":"code","9a4de530":"code","964e849b":"code","f78f0a46":"code","6a4ea1c2":"code","a5652b5d":"code","48f3ad8e":"code","996d32ab":"code","958ed488":"code","907b0a7b":"code","fbe8c1ff":"code","f65d155f":"code","96a5cfeb":"code","b803dc91":"code","9795d90e":"code","c98cec81":"code","9082aef5":"code","169affed":"code","b11171ad":"code","23ce658f":"code","e35f024a":"code","6f1c7a6e":"code","268f8226":"code","317a0f01":"code","583a9546":"code","b3a1d9c3":"code","3db43917":"code","08ba41b3":"code","6f9a5394":"code","c3e38552":"code","131654e5":"code","8eaeca93":"code","5b6ae8f3":"code","86fc3c20":"code","e377af64":"code","43d2dcc2":"code","415ddfba":"code","df22fcab":"code","052de234":"code","591d8761":"code","70e0674f":"code","dcf3132c":"code","4d44280e":"code","10576292":"code","2a0d26b6":"code","f43aca40":"code","5e5c8096":"code","d4b080ae":"code","192457eb":"code","23817269":"code","e566dae4":"code","f5d454fa":"code","16214f4e":"markdown","ae4e3bcf":"markdown","a0abe7de":"markdown","bf9b93de":"markdown","f03161c3":"markdown","23823eb7":"markdown","82fb6482":"markdown","6a45de04":"markdown","9464d004":"markdown","160bba67":"markdown","00a36fda":"markdown","b5b3330c":"markdown","b0dae467":"markdown","fa85ca2d":"markdown","1126d2a7":"markdown","82f9a3a2":"markdown","89262d68":"markdown","a00db75a":"markdown","6caab5d6":"markdown","eccad33e":"markdown","7d824266":"markdown","fe3bef65":"markdown","f75d51ea":"markdown","0323dd80":"markdown","89b703ad":"markdown","7ef7e947":"markdown","433bd01a":"markdown","047ffd25":"markdown","f06545ce":"markdown","78a29c61":"markdown","1f4378ee":"markdown","4fee20ff":"markdown","957ca231":"markdown","34cd7bc4":"markdown","e6842103":"markdown","f74502f2":"markdown","a759f6c6":"markdown","0767ad9f":"markdown","c25e3251":"markdown","d16a2bd4":"markdown","33e7fe95":"markdown","4c921126":"markdown","8cd8f31e":"markdown","a3824224":"markdown","018e38d4":"markdown","f12756fa":"markdown","9a736d52":"markdown","52d92f46":"markdown","870a9651":"markdown","914e2be0":"markdown","7f19d6c2":"markdown","618131bd":"markdown","3e928991":"markdown","4a8c7887":"markdown","a6b32c23":"markdown","8930244f":"markdown","c10213a8":"markdown","fafb1259":"markdown","e676d228":"markdown"},"source":{"199774e0":"import pandas as pd","44dd611a":"titanic = pd.read_csv('\/kaggle\/input\/titanic-csv\/titanic.csv')","e2b810d6":"titanic","ffdfb878":"titanic.info()","a27a27f0":"titanic['age']","6b0d583c":"type(titanic['age'])","2ecd85c2":"titanic.age","43dbcb4a":"titanic['age'].equals(titanic.age)","4123f074":"age = titanic['age']","bff9703a":"age.head()","55dcae56":"age.head(2)","75dab3a7":"age.tail()","5649a391":"age.dtype","d9aaf49d":"age.shape","b8059d17":"len(age)","94861757":"age.index","49cc5db3":"#age.info()\n# This raises attribute error","44a96ab8":"#Converting a pandas series to pandas dataframe.\nage.to_frame()","e7180f86":"type(age.to_frame())","8f17a002":"age.to_frame().info()","989d5044":"age","edea49e4":"age.describe()","9579bfe6":"age.count()","c0578561":"age.size","f1e2b115":"len(age)","594623f1":"age.sum()","4457b54a":"sum(age)","1f8606ce":"# The default value of skipna is True\n#i.e. by default pandas skips the missing values.\nage.sum(skipna = True)","033baa49":"# if we include the missing values pandas does not know how to calculate the sum.\nage.sum(skipna = False)","2935df4a":"age.mean()","f5132198":"#Q2 or 50th Percentile\nage.median()","61dc97b5":"age.std()","476507bf":"age.min()","e73ccf53":"age.max()","705bdd15":"# unique values are displayed in their order of appearance\nage.unique()","3f3fd86d":"len(age.unique())","db14e8d7":"#to get the number of unique values\n#excludes na by default\nage.nunique()","bd1f22db":"age.nunique(dropna = False)","2ad67be1":"#returns absolute frequencies of all the values,\nage.value_counts()","d8587243":"age.value_counts(sort = True)","1c3d6be1":"age.value_counts(sort = False)","9ee695ae":"#by default we ignore missing values\nage.value_counts(dropna = True)","5d9a992d":"age.value_counts(dropna = False) ","f7da0939":"titanic.info()","ca7dfbc9":"891- 714","f4623bd9":"# by default most ascending to least ascending\nage.value_counts(ascending = False)","e14a122f":"age.value_counts(ascending = True)","6b63e25c":"age.value_counts(ascending = True)","2d515160":"#with default parameter values\nage.value_counts(sort = True, dropna = True, ascending = False, normalize = False)","6e166a18":"# to get relative frequency make normalize = True\nage.value_counts(sort = True, dropna = True, ascending = False, normalize = True)","2b1c58c5":"# while calculating the relative frequency pandas ignore the missing values.\n# since dropna = True by default\n30 \/ age.count()","e5311256":"# if we change dropna = False then relative frequency changes\nage.value_counts(sort = True, dropna = False, ascending = False, normalize = True)","1c6fdf0f":"30 \/ age.size","7cc6a0e5":"# to organize in equal width bins\nage.value_counts(sort = True, dropna = True, ascending = False, normalize = False, bins = 5)","29d0d751":"# here we are getting absolute frequencies\nage.value_counts(sort = True, dropna = True, ascending = False, normalize = False, bins = 10)","24b78408":"# here we are getting relative frequencies\nage.value_counts(sort = True, dropna = True, ascending = False, normalize = True, bins = 10)","f8d9232f":"# we can chain the pandas methods to get the desired results.\nage.value_counts(sort = True, dropna = False, ascending = False, normalize = True).sum()","5c780932":"summer = pd.read_csv('\/kaggle\/input\/summer-olympics-dataset-18962012\/summer.csv')","37f590cf":"summer.head()","c873b65f":"summer.info()","26882efd":"athlete = summer['Athlete']","09405fbe":"athlete.head()","c89bdb0e":"athlete.tail(5)","66f6b49b":"type(athlete)","8ecb480d":"athlete.dtype","61cf06b5":"athlete.shape","a8abe6ea":"athlete.describe()","99bf2932":"athlete.size","f225b01c":"athlete.count()","fdd45825":"summer.info()","6b41e591":"summer['Country'].count()","495d60eb":"summer['Country'].size","92846152":"athlete","67680e97":"# for non numerical series min() returns the alpabetically minimum value.\nathlete.min()","aa3990d3":"athlete.unique()","f4adfddd":"len(athlete.unique())","d4f6a4f7":"athlete.nunique()","1b451b9e":"# we do not have any missing value in the athlete series therefore the result is same. \nathlete.nunique(dropna = False)","d90ae146":"summer['Country'].nunique()","18923c19":"summer['Country'].nunique(dropna = False)","8ead5885":"athlete.value_counts()","cad85d34":"athlete.value_counts(sort = True, ascending = True)","6daac958":"#relative frequencies.\nathlete.value_counts(sort = True, ascending = False, normalize = True)","b8088f1e":"summer = pd.read_csv('\/kaggle\/input\/summer-olympics-dataset-18962012\/summer.csv')","d52b0ba3":"summer.head()","b767efbd":"summer['Athlete']","54fbd521":"summer.iloc[0]","2205e995":"type(summer.iloc[0])","233b279c":"pd.read_csv('\/kaggle\/input\/summer-olympics-dataset-18962012\/summer.csv', usecols = ['Athlete'], squeeze = True).head()","156f4548":"pd.Series([10, 20, 30, 40, 50, 25, 4, 2, 29, 87, 69, 88, 47])","ca679d1f":"pd.Series([1, 2, 3, 4, 5, 6, 7], index = ['Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat', 'Sun'])","c10c5d10":"pd.Series([1, 2, 3, 4, 5, 6, 7], index = ['Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat', 'Sun'], name = 'Sales')","53582dcf":"import numpy as np","3c70002a":"sales = np.array([10, 23, 56, 12, 4, 5, 16])\nsales","49eb0630":"pd.Series(sales)","b580dfbe":"sales = [10, 23, 56, 12, 4, 5, 16]","1b7bd865":"pd.Series(sales)","e2e1ba59":"sales = (10, 23, 56, 12, 4, 5, 16)","34c2ff21":"pd.Series(sales)","8ddda3c5":"pd.Series(sales, index = ['Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat', 'Sun'], name = 'Sales')","1ea1f148":"dic = {'Mon': 10, 'Tue': 20, 'Thurs': 5, 'Fri': 39, 'Sat':69, 'Sun': 33}\ndic","2c1ea639":"sales = pd.Series(dic)","4204313a":"sales","d494e1c2":"pd.Series(dic, index = ['Wed', 'Mon', 'Jul', 'Aug', 'Thurs', 'Fri'] )","0a634dfe":"pd.Series(dic, index = [1, 2, 3, 4, 5, 6])","b3b45146":"import pandas as pd","63e0bb03":"titanic = pd.read_csv('\/kaggle\/input\/titanic-csv\/titanic.csv')","5f85f228":"titanic.head()","4aef2b6c":"titanic.tail()","fc6aed56":"age = titanic.age","b67a4459":"age.head()","b7a44d38":"age.tail()","e72b39de":"age.index","ab787603":"age[0]","82bc1ed1":"age[2]","3531349a":"#Error: KeyError: -1\n#age[-1]","e849bbdb":"#Earlier pandas did not know how to handle age[-1] but now it does with iloc[]\nage.iloc[-1]","9c616066":"age[890]","64def790":"age[[3, 4]]","451c7e24":"# here it is behaving like position based indexing since 3 is excluded\nage[:3]","f0a5291f":"#Position based indexing\nage.iloc[:3]","944368a4":"#Label based indexing\nage.loc[:3]","d079da64":"summer = pd.read_csv('\/kaggle\/input\/summer-olympics-dataset-18962012\/summer.csv', index_col = 'Athlete')","3fc3753b":"summer.head()","10619010":"event = summer.Event","1682b9d5":"event.head()","70fe6e9a":"event.tail()","20f3912c":"event.index","f7313967":"event[0]","03a4c561":"event[1]","49334011":"event[2]","d825465c":"# Here Pandas is using position based indexing\nevent[-1]","f02a1947":"# we can use iloc[] but the functionality does not change\nevent.iloc[-1]","a828f337":"event[: 3]","3c77e791":"event['DRIVAS, Dimitrios']","642faf24":"event[: 'DRIVAS, Dimitrios']","9085e1d0":"event['PHELPS, Michael']","65232ab7":"event.loc['PHELPS, Michael'].equals(event['PHELPS, Michael'])","955cec29":"#Error: KeyError: \"Cannot get right slice bound for non-unique label: 'PHELPS, Michael'\"\n#event[:'PHELPS, Michael']","d1f9123a":"event[['PHELPS, Michael', 'LEWIS, Carl']]","33ef9d5e":"event.loc[['PHELPS, Michael', 'LEWIS, Carl']]","2ddfe69e":"#Error: KeyError: \"Passing list-likes to .loc or [] with any missing labels is no longer supported.\n#event[['PHELPS, Michael', 'DUCK, Donald']]","2575b068":"import pandas as ps","433d920d":"dic = {1:10, 3:25, 2:6, 4:36, 5:2, 6:0, 7:None}\ndic","0d36b906":"sales = pd.Series(dic)\nsales","9571eac1":"sales.sort_index()","37077089":"sales.sort_index(ascending = True)","520fbd17":"sales.sort_index(ascending = False)","90728e39":"sales","4db2afc3":"sales.sort_index(ascending = True, inplace = True)","e26f394a":"sales","8a47141e":"sales.sort_values(inplace = False)","9aa8fc94":"sales.sort_values(ascending = False, na_position = 'last', inplace = False)","2ce87506":"sales.sort_values(ascending = False, na_position = 'first', inplace = False)","e5b708ac":"sales","2c231ed9":"sales.sort_values(ascending = False, na_position = 'last', inplace = True)","89fa8e03":"sales","4a22c4ac":"dic = {'Mon': 10, 'Tues': 25, 'Wed': 6, 'Thurs': 36, 'Fri': 2}\ndic","be0f6d35":"sales = pd.Series(dic)\nsales","7d1ee983":"sales.sort_index()","3a34fa2c":"sales.sort_index(ascending = False)","343a282c":"import pandas as pd","7e465056":"titanic = pd.read_csv('\/kaggle\/\/input\/titanic-csv\/titanic.csv')","9a4de530":"titanic.head()","964e849b":"age = titanic.age","f78f0a46":"age.head()","6a4ea1c2":"age.size","a5652b5d":"age.count()","48f3ad8e":"age.sort_values(ascending = False)","996d32ab":"age.sort_values(ascending = False).head(3)","958ed488":"age.nlargest()","907b0a7b":"age.nlargest(n = 3)","fbe8c1ff":"age.sort_values(ascending = True)","f65d155f":"age.nsmallest()","96a5cfeb":"age.nsmallest(n = 3)","b803dc91":"age.sort_values(ascending = True).iloc[:3]","9795d90e":"age.nsmallest(n = 3, keep = 'all')","c98cec81":"age.nlargest(n = 3).index[0]","9082aef5":"age.nsmallest(n = 1).index","169affed":"age.nsmallest(n = 1).index[0]","b11171ad":"titanic.head()","23ce658f":"titanic.age.idxmax()","e35f024a":"titanic.age.idxmin()","6f1c7a6e":"#Oldest passenger\ntitanic.loc[630]","268f8226":"#Youngest passenger\ntitanic.loc[803]","317a0f01":"titanic.loc[titanic.age.idxmin()]","583a9546":"dic = {'Mon': 10, 'Tues': 25, 'Wed': 6, 'Thu': 36, 'Fri': 2, 'Sat': 0, 'Sun': None}\ndic","b3a1d9c3":"sales = pd.Series(dic)\nsales","3db43917":"sales.sort_values(ascending = True).index[0]","08ba41b3":"sales.idxmin()","6f9a5394":"sales.sort_values(ascending = False).index[0]","c3e38552":"sales.idxmax()","131654e5":"import pandas as pd","8eaeca93":"sales = pd.Series([10, 25, 6, 36, 2, 0, None, 5], index = ['Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat', 'Sun', 'Mon'])","5b6ae8f3":"sales","86fc3c20":"sales['Sun'] = 0","e377af64":"sales","43d2dcc2":"sales.iloc[3]  = 30","415ddfba":"sales","df22fcab":"#Element wise operation\n(sales\/1.1)","052de234":"sales_EUR = (sales\/1.1).round(2)","591d8761":"sales_EUR","70e0674f":"sales = (sales\/1.1).round(2)","dcf3132c":"sales","4d44280e":"#It overwrites for both index Mon\nsales['Mon'] = 0","10576292":"sales","2a0d26b6":"titanic = pd.read_csv('\/kaggle\/input\/titanic-csv\/titanic.csv')","f43aca40":"titanic.head()","5e5c8096":"age = titanic['age']","d4b080ae":"age.head()","192457eb":"age.tail()","23817269":"age.iloc[1] = 30","e566dae4":"age.head()","f5d454fa":"titanic.head()","16214f4e":"- We can see that all NaN values are counted as a single unique value.","ae4e3bcf":"- NOTE: with loc[right_boundary:left_boundary], left_boundary is included  (label based indexing)\n- whereas in case of iloc[] left_boundary is excluded. (Position based indexing)","a0abe7de":"- We are not sure whether age[2] is being calculated using position based indexing or label based indexing.","bf9b93de":"- This means the average age of a person onborad titanic was 29.","f03161c3":"## from List","23823eb7":"- We can find skipna parameter in many pandas methods and it is typically set to True.","82fb6482":"- descibe() method gives us different summary when applying on non- numerical series as compared to applying it on a numerical series.","6a45de04":"- We have a 1d Array.","9464d004":"## from tuple","160bba67":"- What if we just want to extract the index of the highest and smallest values.","00a36fda":"## Creating pandas series from numpy array","b5b3330c":"- If position based indexing would have been followed then age[-1] would result in last row, however we get an error.\n- Therefore we explicitly use position based indexing using iloc[]","b0dae467":"- There exist 2 alternatives to access a column.","fa85ca2d":"# Analyzing numerical series","1126d2a7":"- Michael Phelps won 22 medals in his olympic career till 2012 London Olympics.","82f9a3a2":"- For most of the summary statistics in describe method we have a special method.","89262d68":"- How does pandas calculate the relative frequency?","a00db75a":"- By default pandas display the absolute frequencies but we have the option to display the relative frequencies as well.","6caab5d6":"- If we select only one row then also we get a pandas series.","eccad33e":"- The values is changed in the Series as well as the original dataframe.","7d824266":" ## Creating from Scratch with pd.Series()","fe3bef65":"# nlargest() and nsmallest()","f75d51ea":"- The info() method is only available for a pandas dataframe.","0323dd80":"# Sorting and introduction to the inplace-parameter","89b703ad":"- The real power of pandas is that it can handle real world data.\n- Real world data is typically messy and unclean, e.g. many real world data contains missing values.\n- Pandas is very helpful when it comes to missing values.","7ef7e947":"- `squeeze = True` parameter : If the parsed data only contains one column then return a Series.","433bd01a":"# idxmin() idxmax()","047ffd25":" - This means 4.2% of all passengers are 24 years old and 3.7% of all ppassengers are 22 years old.","f06545ce":"- Pandas compares our new index to the keys of dictionary.\n- The new index dominates over the existing keys, if a key is not present then NaN becomes the value at that index.","78a29c61":"- Pandas series and Pandas dataframe shares most of the methods and attributes.\n- There exists only few methods that are only available for dataframe and vice versa.","1f4378ee":"- By default we get 5 largest values in our pandas series.","4fee20ff":"- The built in python function sum() does not know how to handle the missing values.","957ca231":"- If from the begining we are sure that we will be working with a single column and not the entire dataset, we can do so at the time of importing the csv.","34cd7bc4":"- Therefore if we have a range index and we slice using just `[] square bracket` Pandas does not know if we intend to use label based or position based indexing.\n- The behaviour is not consistent.\n- The best practice is to use iloc[] operator or loc[] opeartor explicitly.","e6842103":"# Indexing and Slicing","f74502f2":"# Creating Pandas Series","a759f6c6":"- The keys become index and values are treated as values .","0767ad9f":"- There is a better and easier way to do this.","c25e3251":"- If we pass completly different index then no key values matches it and NaN becomes the values of the index.","d16a2bd4":"# Manipulating Series","33e7fe95":"- Therefore by using iloc[] it becomes unambigous that we are using position based indexing and how pandas is going to access the value.","4c921126":"- With Range-index we are not sure whether we are doing position based indexing or label based indexing becuase the range based indexes are identical to the positions.","8cd8f31e":"# Analyzing Non-numerical series","a3824224":"- Extracting the 3 oldest passengers.","018e38d4":"- The difference between count() and size can be noticed in the above example.","f12756fa":"- If we have any missing values then the count() method do not take into account the nan values and hence provide us with a lower value as compared to size attribute.","9a736d52":"# Pandas Series","52d92f46":"## Importing from CSV","870a9651":"- It works in the same way as indexing and slicing pandas dataframe.\n- The only difference is that pandas Series have only one dimension(1 column or 1 Row) therefore we cannot slice for rows and columns as we did with pandas dataframe.","914e2be0":"## First steps with pandas","7f19d6c2":"- datatype is object.","618131bd":"- by default we get range-index.","3e928991":"## From dataframe","4a8c7887":"- A Pandas series is one dimensional labeled array.\n- It is labelled with the same index that we have in dataframe.","a6b32c23":"- Our index is sorted in an alphabetical manner.","8930244f":"- If the index has duplicates then if we use label based indexing to update the value it overwrites all the instances of that index.","c10213a8":"- We can change the index from range-index to index of our choice.","fafb1259":"- If we simply select 1 column or 1 row of dataframe then we automatically have a pandas series.","e676d228":"## From Dictionary"}}