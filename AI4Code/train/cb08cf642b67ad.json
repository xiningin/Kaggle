{"cell_type":{"1bdaf548":"code","9cc35207":"code","105b6b35":"code","cf88847c":"code","e34bad3c":"code","cd2b7065":"code","9bb833dc":"markdown","adc1dbe7":"markdown","48405049":"markdown"},"source":{"1bdaf548":"import torch\nif torch.cuda.is_available():\n    device = torch.device(\"cuda:0\")\nelse:\n    device = \"cpu\"","9cc35207":"import os\nimport pandas as pd\nimport cv2\nimport numpy as np\nfrom tqdm import tqdm\nfrom random import shuffle\nimport torch\n\nnormal_images  = []\npotholes_images = []\npath_normal = '\/kaggle\/input\/pothole-detection-dataset\/normal\/'\npath_potholes = '\/kaggle\/input\/pothole-detection-dataset\/potholes\/'\n\nfor dirname, _, filenames in os.walk(path_normal):\n    for filename in tqdm(filenames):\n        try:\n            img = cv2.imread(os.path.join(path_normal,filename) , cv2.IMREAD_GRAYSCALE)\n            img = cv2.resize(img , (50,50))\n            normal_images.append(np.array(img))\n        except Exception as e:\n            pass\n        \nfor dirname, _, filenames in os.walk(path_potholes):\n    for filename in tqdm(filenames):\n        try:\n            img = cv2.imread(os.path.join(path_potholes,filename) , cv2.IMREAD_GRAYSCALE)\n            img = cv2.resize(img , (50,50))\n            potholes_images.append(np.array(img))\n        except Exception as e:\n            pass\nprint(len(normal_images))\nprint(len(potholes_images))\n\nprocessed_data = []\nfor img in normal_images:\n    t = torch.LongTensor(1)\n    t[0] = 0\n    img = torch.FloatTensor(img)\n    processed_data.append([img\/255,t])\nfor img in potholes_images:\n    t = torch.LongTensor(1)\n    t[0] = 1\n    img = torch.FloatTensor(img)\n    processed_data.append([img\/255,t])\n                           \nprint(len(processed_data))\nshuffle(processed_data)\n\ntrain_data = processed_data[70:]\ntest_data = processed_data[0:70]\n\nprint(f\"size of training data {len(train_data)}\")\nprint(f\"size of testing data {len(test_data)}\")\n\n","105b6b35":"\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Net(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(1,32,5)\n        self.conv2 = nn.Conv2d(32,64,5)\n        self.conv3 = nn.Conv2d(64,128,5)\n        \n        x = torch.rand(1,50,50).view(-1,1,50,50)\n        self.linear_in = None\n        self.convs(x)\n        \n        self.fc1 = nn.Linear(self.linear_in,512)\n        self.fc2 = nn.Linear(512,2)\n        \n    def convs(self,x):\n        x = F.max_pool2d(F.relu(self.conv1(x)) , (2,2))\n        x = F.max_pool2d(F.relu(self.conv2(x)) , (2,2))\n        x = F.max_pool2d(F.relu(self.conv3(x)) , (2,2))\n        \n        if self.linear_in == None:\n            self.linear_in = x[0].shape[0] * x[0].shape[1] * x[0].shape[2]\n        else:\n            return x\n    \n    def forward(self,x):\n        x = self.convs(x)\n        x = x.view(-1,self.linear_in)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return F.log_softmax(x , dim = 1)\n\nnet = Net()\nnet.to(device)\n","cf88847c":"import torch.optim as optim\n\ndef train_model(Net , train_data):\n    optimizer  = optim.Adam(net.parameters(),lr = 0.001)\n    loss_function = nn.CrossEntropyLoss()\n\n    for epoch in tqdm(range(10)):\n        for i in (range(0,610,10)):\n            batch = train_data[i:i+10]\n            batch_x = torch.FloatTensor(10,1,50,50)\n            batch_y = torch.LongTensor(10,1)\n\n            for i in range(10):\n                batch_x[i] = batch[i][0]\n                batch_y[i] = batch[i][1]\n            batch_x.to(device)\n            batch_y.to(device)\n            net.zero_grad()\n            outputs = net(batch_x.view(-1,1,50,50))\n            batch_y = batch_y.view(10)\n            loss = F.nll_loss(outputs , batch_y)\n            loss.backward()\n            optimizer.step()\n        print(f\"epoch : {epoch}  loss : {loss}\")","e34bad3c":"def test_model(Net,test_data):\n    correct = 0\n    total = 0\n\n    with torch.no_grad():\n        for data in tqdm(test_data):\n            x = torch.FloatTensor(data[0])\n            y = torch.LongTensor(data[1])\n\n            x = x.view(-1,1,50,50)\n            x = x.to(device)\n            output = net(x)\n            output = output.view(2)\n            if(max(output[0],output[1]) == output[0]):\n                index = 0\n            else:\n                index = 1\n            if index == y[0]:\n                correct += 1\n            total += 1\n        return round(correct\/total , 5)\n","cd2b7065":"train_model(net,train_data)\nacc = test_model(net,test_data)\nprint(acc)\n","9bb833dc":" trainig model","adc1dbe7":"Processing training and testing data","48405049":"Defining network class"}}