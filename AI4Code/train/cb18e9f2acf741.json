{"cell_type":{"c366546d":"code","e08250db":"code","4de5a959":"code","43733217":"code","7cfe9915":"code","3cb189a1":"code","44b49f06":"code","33ff3a98":"code","583cea5e":"code","b294a19e":"code","580752f6":"code","0ba8dc58":"markdown","68e37ca1":"markdown","dd36861f":"markdown","789d0b90":"markdown","e3d8a4ea":"markdown","cb8a0305":"markdown","b302de1a":"markdown","384acd95":"markdown","832a41a1":"markdown","b3e5320c":"markdown"},"source":{"c366546d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","e08250db":"import cv2\nimport matplotlib.pyplot as plt\nimport numpy as np","4de5a959":"image=cv2.imread('..\/input\/road-lane\/test_image.jpg')\nplt.figure(figsize=(12,7))\nplt.imshow(image)\nplt.show()","43733217":"lane_image=np.copy(image)\ngray=cv2.cvtColor(lane_image,cv2.COLOR_RGB2GRAY)\nplt.figure(figsize=(12,7))\nplt.imshow(gray,cmap='gray')\nplt.show()","7cfe9915":"#using Gausian Blur to reduce the noise\nblur=cv2.GaussianBlur(gray,(5,5),0)\nplt.figure(figsize=(12,7))\nplt.imshow(blur,cmap='gray')\nplt.show()","3cb189a1":"#Edges can be detected by using Canny edge detector\nedge=cv2.Canny(blur,50,150)\nplt.figure(figsize=(12,7))\nplt.imshow(edge,cmap='gray')\nplt.show()","44b49f06":"def regionofinterest(image):\n    height=image.shape[0]\n    ploy=np.array([[(200,height),(1100,height),(550,250)]])\n    mask=np.zeros_like(image)\n    cv2.fillPoly(mask,ploy,255)\n    masked_image=cv2.bitwise_and(edge,mask)\n    return masked_image\nmask=regionofinterest(edge)\nplt.figure(figsize=(12,7))\nplt.imshow(mask,cmap='gray')\nplt.show()\n    ","33ff3a98":"def display_lines(img,lines):\n    line_image = np.zeros_like(img)\n    if lines is not None:\n        for line in lines:\n            for x1, y1, x2, y2 in line:\n                cv2.line(line_image,(x1,y1),(x2,y2),(0,0,255),10)\n    return line_image\nlines = cv2.HoughLinesP(mask, 2, np.pi\/180, 100, np.array([]), minLineLength=40,maxLineGap=5)\nline_image = display_lines(lane_image,lines)\n#combo_image = cv2.addWeighted(lane_image, 0.8, line_image, 1, 0)\nplt.figure(figsize=(12,7))\nplt.imshow(line_image,cmap='gray')\nplt.show()","583cea5e":"def display_lines(img,lines):\n    line_image = np.zeros_like(img)\n    if lines is not None:\n        for line in lines:\n            for x1, y1, x2, y2 in line:\n                cv2.line(line_image,(x1,y1),(x2,y2),(0,0,255),10)\n    return line_image\nlines = cv2.HoughLinesP(mask, 2, np.pi\/180, 100, np.array([]), minLineLength=40,maxLineGap=5)\nline_image = display_lines(lane_image,lines)\ncombo_image = cv2.addWeighted(lane_image, 0.8, line_image, 1, 0)\nplt.figure(figsize=(12,7))\nplt.imshow(combo_image,cmap='gray')\nplt.show()","b294a19e":"def make_points(image, line):\n    slope, intercept = line\n    y1 = int(image.shape[0])# bottom of the image\n    y2 = int(y1*3\/5)         # slightly lower than the middle\n    x1 = int((y1 - intercept)\/slope)\n    x2 = int((y2 - intercept)\/slope)\n    return [[x1, y1, x2, y2]]\n \ndef average_slope_intercept(image, lines):\n    left_fit    = []\n    right_fit   = []\n    if lines is None:\n        return None\n    for line in lines:\n        for x1, y1, x2, y2 in line:\n            fit = np.polyfit((x1,x2), (y1,y2), 1)\n            slope = fit[0]\n            intercept = fit[1]\n            if slope < 0: # y is reversed in image\n                left_fit.append((slope, intercept))\n            else:\n                right_fit.append((slope, intercept))\n    # add more weight to longer lines\n    left_fit_average  = np.average(left_fit, axis=0)\n    right_fit_average = np.average(right_fit, axis=0)\n    left_line  = make_points(image, left_fit_average)\n    right_line = make_points(image, right_fit_average)\n    averaged_lines = [left_line, right_line]\n    return averaged_lines\naveraged_lines = average_slope_intercept(image, lines)\nline_image = display_lines(lane_image, averaged_lines)\nplt.figure(figsize=(12,7))\nplt.imshow(line_image,cmap='gray')\nplt.show()\n","580752f6":"def make_points(image, line):\n    slope, intercept = line\n    y1 = int(image.shape[0])# bottom of the image\n    y2 = int(y1*3\/5)         # slightly lower than the middle\n    x1 = int((y1 - intercept)\/slope)\n    x2 = int((y2 - intercept)\/slope)\n    return [[x1, y1, x2, y2]]\n \ndef average_slope_intercept(image, lines):\n    left_fit    = []\n    right_fit   = []\n    if lines is None:\n        return None\n    for line in lines:\n        for x1, y1, x2, y2 in line:\n            fit = np.polyfit((x1,x2), (y1,y2), 1)\n            slope = fit[0]\n            intercept = fit[1]\n            if slope < 0: # y is reversed in image\n                left_fit.append((slope, intercept))\n            else:\n                right_fit.append((slope, intercept))\n    # add more weight to longer lines\n    left_fit_average  = np.average(left_fit, axis=0)\n    right_fit_average = np.average(right_fit, axis=0)\n    left_line  = make_points(image, left_fit_average)\n    right_line = make_points(image, right_fit_average)\n    averaged_lines = [left_line, right_line]\n    return averaged_lines\naveraged_lines = average_slope_intercept(image, lines)\nline_image = display_lines(lane_image, averaged_lines)\ncombo_image = cv2.addWeighted(lane_image, 0.8, line_image, 1, 0)\nplt.figure(figsize=(12,7))\nplt.imshow(combo_image,cmap='gray')\nplt.show()\n","0ba8dc58":"## Future work: Lane-Detection from a video.\n**I will keep on updating the notebook.Thanks for your time.**","68e37ca1":"## Lets start with reading the image.","dd36861f":"## Lets import necessary libraries","789d0b90":"# Please consider upvoting if you like my work, Happy Kaggling!","e3d8a4ea":"## Converting the image into grayscale.","cb8a0305":"## Optimizing further.","b302de1a":"## Edge detection.","384acd95":"## Lane Detection Using Hough Transform. To know about Hough Transform refer [this](https:\/\/docs.opencv.org\/3.4\/d9\/db0\/tutorial_hough_lines.html)","832a41a1":"## Smoothening image (Reduce noise).","b3e5320c":"## Finding the region of interest(ROI) and creating Mask."}}