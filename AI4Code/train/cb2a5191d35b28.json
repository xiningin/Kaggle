{"cell_type":{"f6388314":"code","6c4b0c0b":"code","e8c4df72":"code","7004d57e":"code","d34cedfe":"code","4aa8b479":"code","58571676":"code","91550ba0":"code","11d792f2":"code","f46d294a":"code","0518f7e2":"code","dd6c0267":"code","e0bc62e8":"code","ced6cb12":"code","208068ea":"code","de95c43a":"code","7a374fe6":"code","a9658739":"code","e928b82b":"code","3c163a6d":"code","0a1b9c77":"code","cd32022f":"code","434ee515":"code","21e14d8e":"code","a8f76379":"code","f0fdaa93":"code","0ee8c6a8":"code","e4d501f0":"code","eda9cd90":"markdown","81000316":"markdown","260f4bf5":"markdown","ca68ee13":"markdown","5ca555e2":"markdown","6aae2e76":"markdown","1e0a3c3f":"markdown","b2b54769":"markdown","def98d67":"markdown","cfb9b592":"markdown","d95790c6":"markdown"},"source":{"f6388314":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nfrom sklearn.decomposition import PCA\nfrom PIL import Image\nimport glob\nimport warnings\nimport shap\nimport lightgbm as lgb\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import KFold\nimport random\n\nwarnings.filterwarnings('ignore')","6c4b0c0b":"filepath1='..\/input\/nfl-make-png-2020-1-w\/'\nlist_2020_1=os.listdir(filepath1)\n\nfilepath2='..\/input\/nfl-make-png-2020-2-w\/'\nlist_2020_2=os.listdir(filepath2)\n\nfilepath3='..\/input\/nfl-make-png-2020-3-w\/'\nlist_2020_3=os.listdir(filepath3)","e8c4df72":"list_2020_1_=[i for i in list_2020_1 if 'png' in i]\nlist_2020_2_=[i for i in list_2020_2 if 'png' in i]\nlist_2020_3_=[i for i in list_2020_3 if 'png' in i]","7004d57e":"#load png data\nimage_size = 64\n\nx = []\npng_data=[]\nfor i in list_2020_1_:\n    image = Image.open(filepath1+i)\n    #image = image.convert('L')  \n    image = image.resize((image_size, image_size)) \n    data = np.asarray(image)\n    x.append(data)\n    png_data.append(i)\n    \nfor i in list_2020_2_:\n    image = Image.open(filepath2+i)\n    #image = image.convert('L')  \n    image = image.resize((image_size, image_size)) \n    data = np.asarray(image)\n    x.append(data)\n    png_data.append(i)\n    \nfor i in list_2020_3_:\n    image = Image.open(filepath3+i)\n    #image = image.convert('L')  \n    image = image.resize((image_size, image_size)) \n    data = np.asarray(image)\n    x.append(data)\n    png_data.append(i)\n    \nX = np.array(x)\nX = X.reshape(X.shape[0], image_size * image_size,4) \nX = X \/ 255.0  \n\n\nprint('X.shape =', X.shape)\nrows, cols = 5, 10  \nfig, aX_invs = plt.subplots(ncols=cols, nrows=rows, figsize=(18, 10)) \nfor i in range(50):\n    r = i \/\/ cols\n    c = i % cols\n    aX_invs[r, c].imshow(X[i].reshape(image_size,image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[r, c].set_title('data %d' % (i+1))\n    aX_invs[r, c].get_xaxis().set_visible(False)\n    aX_invs[r, c].get_yaxis().set_visible(False)\nplt.show()","d34cedfe":"X2=X.reshape(X.shape[0],4096*4)\nX2.shape","4aa8b479":"# PCA(Principal component analysis)\nN = 400  #400 component\npca = PCA(n_components=N)\npca.fit(X2)\nprint('n_components = '+str(N))\nprint('explained_variance_ratio = ', pca.explained_variance_ratio_.sum())\n","58571676":"#Dimensionality reduction and dimension restoration coefficients\nX_trans = pca.transform(X2)\nX_inv = pca.inverse_transform(X_trans)\nprint ('X.shape =', X.shape)\nprint ('X_trans.shape =', X_trans.shape)\nprint ('X_inv.shape =', X_inv.shape)\n\n\nrows, cols = 2, 8  # 2\u884c8\u5217\nfig, aX_invs = plt.subplots(ncols=cols, nrows=rows, figsize=(18,4))\nfor i in range(8):\n    aX_invs[0, i].imshow(X[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[0, i].set_title('original %d' % (i+1))\n    aX_invs[0, i].get_xaxis().set_visible(False)\n    aX_invs[0, i].get_yaxis().set_visible(False)\n    aX_invs[1, i].imshow(X_inv[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[1, i].set_title('restore %d' % (i+1))\n    aX_invs[1, i].get_xaxis().set_visible(False)\n    aX_invs[1, i].get_yaxis().set_visible(False)","91550ba0":"import numpy as np\nimport itertools \n\n#Kmeans\nclass KMeans:\n    def __init__(self, n_clusters, max_iter = 1000, random_seed = 0):\n        self.n_clusters = n_clusters\n        self.max_iter = max_iter\n        self.random_state = np.random.RandomState(random_seed)\n\n    def fit(self, X):\n        cycle = itertools.cycle(range(self.n_clusters))\n        self.labels_ = np.fromiter(itertools.islice(cycle, X.shape[0]), dtype = np.int)\n        self.random_state.shuffle(self.labels_)\n        labels_prev = np.zeros(X.shape[0])\n        count = 0\n        self.cluster_centers_ = np.zeros((self.n_clusters, X.shape[1]))\n\n        \n        while (not (self.labels_ == labels_prev).all() and count < self.max_iter):\n            for i in range(self.n_clusters):\n                XX = X[self.labels_ == i, :]\n                self.cluster_centers_[i, :] = XX.mean(axis = 0)\n            dist = ((X[:, :, np.newaxis] - self.cluster_centers_.T[np.newaxis, :, :]) ** 2).sum(axis = 1)\n            labels_prev = self.labels_\n            self.labels_ = dist.argmin(axis = 1)\n            count += 1\n\n    def predict(self, X):\n        dist = ((X[:, :, np.newaxis] - self.cluster_centers_.T[np.newaxis, :, :]) ** 2).sum(axis = 1)\n        labels = dist.argmin(axis = 1)\n        return labels","11d792f2":"\n#make 8 labels\nmodel =  KMeans(8)\nmodel.fit(X_trans)\n\nprint(model.labels_)","f46d294a":"p_0=X_inv[model.labels_ == 0, :]#label0 no gazou(*4096)\np_1=X_inv[model.labels_ == 1, :]\np_2=X_inv[model.labels_ == 2, :]\np_3=X_inv[model.labels_ == 3, :]\np_4=X_inv[model.labels_ == 4, :]\np_5=X_inv[model.labels_ == 5, :]\np_6=X_inv[model.labels_ == 6, :]\np_7=X_inv[model.labels_ == 7, :]","0518f7e2":"len(model.labels_)","dd6c0267":"rows, cols = 8, 8\nfig, aX_invs = plt.subplots(ncols=cols, nrows=rows, figsize=(18,25))\nfor i in range(8):\n    aX_invs[0, i].imshow(p_0[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[0, i].set_title('label0 %d' % (i+1))\n    aX_invs[0, i].get_xaxis().set_visible(False)\n    aX_invs[0, i].get_yaxis().set_visible(False)\n    aX_invs[1, i].imshow(p_1[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[1, i].set_title('label1 %d' % (i+1))\n    aX_invs[1, i].get_xaxis().set_visible(False)\n    aX_invs[1, i].get_yaxis().set_visible(False)\n    aX_invs[2, i].imshow(p_2[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[2, i].set_title('label2 %d' % (i+1))\n    aX_invs[2, i].get_xaxis().set_visible(False)\n    aX_invs[2, i].get_yaxis().set_visible(False)\n    aX_invs[3, i].imshow(p_3[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[3, i].set_title('label3 %d' % (i+1))\n    aX_invs[3, i].get_xaxis().set_visible(False)\n    aX_invs[3, i].get_yaxis().set_visible(False)\n    aX_invs[4, i].imshow(p_4[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[4, i].set_title('label4 %d' % (i+1))\n    aX_invs[4, i].get_xaxis().set_visible(False)\n    aX_invs[4, i].get_yaxis().set_visible(False)\n    aX_invs[5, i].imshow(p_5[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[5, i].set_title('label5 %d' % (i+1))\n    aX_invs[5, i].get_xaxis().set_visible(False)\n    aX_invs[5, i].get_yaxis().set_visible(False)\n    aX_invs[6, i].imshow(p_6[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[6, i].set_title('label6 %d' % (i+1))\n    aX_invs[6, i].get_xaxis().set_visible(False)\n    aX_invs[6, i].get_yaxis().set_visible(False)\n    aX_invs[7, i].imshow(p_7[i,:].reshape(image_size, image_size,4),vmin=0.0,vmax=1.0, cmap = cm.Greys_r)\n    aX_invs[7, i].set_title('label7 %d' % (i+1))\n    aX_invs[7, i].get_xaxis().set_visible(False)\n    aX_invs[7, i].get_yaxis().set_visible(False)\n\n","e0bc62e8":"label_data=pd.DataFrame(np.arange(len(X)),columns={'number'})\nlabel_data['labels']=model.labels_\nlabel_data['png_data']=png_data\nlabel_data","ced6cb12":"#df=pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2020.csv')\n#df","208068ea":"a_a=label_data['png_data'].str.split('.', expand=True)\na_a.rename(columns={0: 'ID', 1: 'png'}, inplace=True)\nlabel_data['ID']=a_a['ID']","de95c43a":"play=pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/plays.csv')\nplay['gameId']=play['gameId'].astype(str)\nplay['playId']=play['playId'].astype(str)\nplay['ID']=play['gameId'].str.cat(play['playId'], sep='_')","7a374fe6":"pd.set_option('display.max_columns', 50)\ndata_concat=pd.merge(play,label_data, on='ID')\ndata_concat","a9658739":"data_concat['specialTeamsPlayType'].unique()","e928b82b":"plt.style.use('fivethirtyeight')\nplt.figure(figsize=(16,10))\nplt.grid(False)\ndata_ko=data_concat[data_concat['specialTeamsPlayType']=='Kickoff']\ndata_ep=data_concat[data_concat['specialTeamsPlayType']=='Extra Point']\ndata_punt=data_concat[data_concat['specialTeamsPlayType']=='Punt']\ndata_fg=data_concat[data_concat['specialTeamsPlayType']=='Field Goal']\nplt.scatter(x=data_ko['labels'],y=data_ko['playResult'],c='r',label='Kickoff',alpha=0.3)\nplt.scatter(x=data_ep['labels'],y=data_ep['playResult'],c='g',label='Extra Point',alpha=0.3)\nplt.scatter(x=data_punt['labels'],y=data_punt['playResult'],c='y',label='Punt',alpha=0.3)\nplt.scatter(x=data_fg['labels'],y=data_fg['playResult'],c='b',label='Field Goal',alpha=0.3)\nplt.title(\"playResult vs labels of tracking data separate with specialTeamsPlayType\")\nplt.xlabel(\"labels of tracking data\")\nplt.ylabel(\"playResult\")\nplt.legend()","3c163a6d":"data_concat","0a1b9c77":"#Code by rossinEndrew https:\/\/www.kaggle.com\/endrewrossin\/fast-initial-lightgbm-model-to-detect-exam-result\/comments\n\nSEED = 99\nrandom.seed(SEED)\nnp.random.seed(SEED)\n#Code by rossinEndrew https:\/\/www.kaggle.com\/endrewrossin\/fast-initial-lightgbm-model-to-detect-exam-result\/comments\ndata_concat=data_concat.drop(['playDescription','gameClock','playId','png_data','number','ID','gameId'], axis = 1)\nplaysmodel = data_concat.copy()\n\n# read the \"object\" columns and use labelEncoder to transform to numeric\nfor col in playsmodel.columns[playsmodel.dtypes == 'object']:\n    le = LabelEncoder()\n    playsmodel[col] = playsmodel[col].astype(str)\n    le.fit(playsmodel[col])\n    playsmodel[col] = le.transform(playsmodel[col])","cd32022f":"playsmodel","434ee515":"X = playsmodel.drop(['playResult'], axis = 1)\ny = playsmodel['playResult']\nlgb_params = {\n                    'objective':'binary',\n                    'metric':'auc',\n                    'n_jobs':-1,\n                    'learning_rate':0.005,\n                    'num_leaves': 20,\n                    'max_depth':-1,\n                    'subsample':0.9,\n                    'n_estimators':2500,\n                    'seed': SEED,\n                    'early_stopping_rounds':100, \n                }","21e14d8e":"#Code by rossinEndrew https:\/\/www.kaggle.com\/endrewrossin\/fast-initial-lightgbm-model-to-detect-exam-result\/comments\n\n# choose the number of folds, and create a variable to store the auc values and the iteration values.\nK = 5\nfolds = KFold(K, shuffle = True, random_state = SEED)\nbest_scorecv= 0\nbest_iteration=0\n\n# Separate data in folds, create train and validation dataframes, train the model and cauculate the mean AUC.\nfor fold , (train_index,test_index) in enumerate(folds.split(X, y)):\n    print('Fold:',fold+1)\n          \n    X_traincv, X_testcv = X.iloc[train_index], X.iloc[test_index]\n    y_traincv, y_testcv = y.iloc[train_index], y.iloc[test_index]\n    \n    train_data = lgb.Dataset(X_traincv, y_traincv)\n    val_data   = lgb.Dataset(X_testcv, y_testcv)\n    \n    LGBM = lgb.train(lgb_params, train_data, valid_sets=[train_data,val_data], verbose_eval=250)\n    best_scorecv += LGBM.best_score['valid_1']['auc']\n    best_iteration += LGBM.best_iteration\n\nbest_scorecv \/= K\nbest_iteration \/= K\nprint('\\n Mean AUC score:', best_scorecv)\nprint('\\n Mean best iteration:', best_iteration)","a8f76379":"#XLGB SHAP\n#Code by rossinEndrew https:\/\/www.kaggle.com\/endrewrossin\/fast-initial-lightgbm-model-to-detect-exam-result\/comments\n\nlgb_params = {\n                    'objective':'binary',\n                    'metric':'auc',\n                    'n_jobs':-1,\n                    'learning_rate':0.05,\n                    'num_leaves': 20,\n                    'max_depth':-1,\n                    'subsample':0.9,\n                    'n_estimators':round(best_iteration),\n                    'seed': SEED,\n                    'early_stopping_rounds':None, \n                }\n\ntrain_data_final = lgb.Dataset(X, y)\nLGBM = lgb.train(lgb_params, train_data)","f0fdaa93":"# telling wich model to use\nexplainer = shap.TreeExplainer(LGBM)\n# Calculating the Shap values of X features\nshap_values = explainer.shap_values(X)","0ee8c6a8":"shap.summary_plot(shap_values[0], X, plot_type=\"bar\")","e4d501f0":"shap.summary_plot(shap_values[0], X)","eda9cd90":"# ****LGBM and SHAP with labels of tracking datasets****","81000316":"### concat labels that I made and other data\n.","260f4bf5":"It's almost working!","ca68ee13":"confirm how png datasets are labeled.","5ca555e2":"## How to make labels of tracking datasets","6aae2e76":"'playResult' have relations with the 'specialTeamPlayType' the most.\nLabels that I made in this notebook had a little impact.\nBut they are similar to SpecialTeamPlayType.\n\nIf you apply this method,we can label the movements of one player and a ball.\nIt may lead to better results...\n\nThank you for watching this notebook till the end.\n\n","1e0a3c3f":"# PCA","b2b54769":"I tried to make labels of tracking data because I think these have some features.\n\nI changed the tracking datasets to png datasets.\nAnd I made labels of these png datasets eith PCA and KMeans.\n\nI made the png datasets of tracking data only 2020.\nBecause using all datasets needs too big memories.\n\nIf you think that this is useful ,please upvote.\nYour upvote makes me so encouraged.","def98d67":"# KMeans","cfb9b592":"# Conclusion","d95790c6":"## playResult vs labels of tracking data separate with specialTeamsPlayType ****"}}