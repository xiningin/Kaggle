{"cell_type":{"0d709425":"code","5fa07fad":"code","271e1bac":"code","61183b53":"code","18ac5774":"code","30e70bce":"code","456e7cb2":"code","1aee2466":"code","7d3aa3cf":"code","116c412d":"code","0cb85efd":"code","3245a7dd":"code","62aad1d7":"code","55b76760":"code","d6509404":"code","ddaafb19":"code","829c7719":"code","8ea81279":"code","0903d076":"code","b36851a2":"code","d48ab662":"code","d36a0eaa":"code","b589dda0":"code","1a82d020":"code","9da3b3a8":"code","d7b43be9":"code","070e6785":"code","1b72ffec":"code","1ccf9d19":"code","028a1938":"code","65237fd0":"code","5a21ae77":"code","50467958":"code","e9aa468f":"code","1fe69e7e":"code","35bf3748":"code","c22e5c26":"code","88a8d54e":"code","481e0c25":"code","c48f1f14":"code","13355d50":"code","c323f3e6":"code","e243b195":"code","12f917eb":"code","f7cbeb8a":"code","bc632465":"code","8c66e9a7":"code","4aea8079":"code","45c49794":"code","abcc844a":"code","9313560c":"code","16d2a289":"code","ea896c85":"code","2ee2fcaf":"code","a681e9a7":"code","1d5bca64":"code","a58961e4":"code","b5a006d3":"code","52803c9f":"code","16eee89d":"code","0b892638":"code","1fd563f2":"code","8ec880a9":"code","19652f65":"code","73f5b0bb":"code","a2c0170f":"code","1e0979d7":"markdown","fab575be":"markdown","303e13a3":"markdown","53cd7d70":"markdown","a6a24856":"markdown","0ef2e256":"markdown","ac37b202":"markdown","eda794fb":"markdown","c627f56a":"markdown","a777ac16":"markdown","3f41478b":"markdown","1a8f67de":"markdown","ebb5f7b5":"markdown","e8394435":"markdown","b022ba19":"markdown","ee910b02":"markdown","b5e2e269":"markdown","cd38dd1c":"markdown","77fb1318":"markdown","bcc195cf":"markdown","5b4e7653":"markdown","b52bcf9f":"markdown","0889bbf6":"markdown","b4fe1946":"markdown","8012bcdd":"markdown","b93893d3":"markdown","3671be9a":"markdown","bfd23245":"markdown","9d7e0327":"markdown","da2a328b":"markdown","f7269244":"markdown","113a4132":"markdown","492fc8db":"markdown","a8417d5d":"markdown","8be269ae":"markdown","55586fde":"markdown","f391bfdb":"markdown","d2a3ef08":"markdown","193ae040":"markdown","148b853e":"markdown","d8256062":"markdown","2e7f0ba7":"markdown","f6af2da2":"markdown","25698459":"markdown","88548b11":"markdown","ed523548":"markdown","e60d50e1":"markdown","bb9ceded":"markdown","7e7d12c4":"markdown","b061801e":"markdown","e6b05c15":"markdown","56599b65":"markdown","43619628":"markdown","2d8389d1":"markdown","35b4b745":"markdown","caf223a1":"markdown","061be663":"markdown","2181940e":"markdown","080b1790":"markdown","8c612e26":"markdown","6fedc9b5":"markdown","5159c719":"markdown","f42497db":"markdown","88b84bd1":"markdown","a2683dad":"markdown","bcc325bd":"markdown","fa110a1e":"markdown","7b1b3edb":"markdown","dfecf236":"markdown","f5f4312e":"markdown","9b40fd05":"markdown","f930a95a":"markdown","c56993e4":"markdown","64f65e64":"markdown","c2469946":"markdown","06056c54":"markdown","b20bb509":"markdown","a44e1d0e":"markdown","cad5982c":"markdown","16110be8":"markdown","41f9c553":"markdown","3108872a":"markdown","98d95e4a":"markdown"},"source":{"0d709425":"import numpy as np","5fa07fad":"array_1 = np.array([1, 2, 3])  # np.array() takes only one argument\nprint(array_1)\nprint(type(array_1))  # checking the type","271e1bac":"print(array_1.dtype)  # shows the type of elements array has","61183b53":"print(array_1.ndim)  # tells array's dimensions\nprint(array_1.size)  # tells array's length\nprint(array_1.shape)  # tells array's shape","18ac5774":"array_2 = np.array([[2, 4, 6], [3, 6, 9]])  # a nested list is provided as argument\nprint(array_2)","30e70bce":"print(type(array_2))\nprint(array_2.dtype)\nprint(array_2.ndim)\nprint(array_2.size)\nprint(array_2.shape)","456e7cb2":"print(array_1.itemsize)  # defines the size in bytes of each item in the array\nprint(array_2.itemsize)","1aee2466":"array_3 = np.array([[1, 2, 3],[4, 5, 6]])  # with nested list\nprint(array_3)\narray_4 = np.array(((1, 2, 3),(4, 5, 6)))  # with nested tuple\nprint(array_4)\narray_5 = np.array([(1, 2, 3), [4, 5, 6], (7, 8, 9)])  # with combination of lists and tuples in a list\nprint(array_5)","7d3aa3cf":"array_6 = np.array([[\"a\", \"b\"],[\"c\", \"d\"]])\nprint(array_6)\nprint(array_6.dtype)\nprint(array_6.dtype.name)","116c412d":"array_7 = np.array([[9, 8], [7, 6]], dtype = complex)\nprint(array_7)\nprint(array_7.dtype)","0cb85efd":"array_8 = np.zeros((3, 3))  # np.zeros() takes shape(tuple) as argument & creates an array with all zeroes\nprint(array_8)","3245a7dd":"array_9 = np.ones((2, 2))  # similiar to zeroes, but with ones\nprint(array_9)","62aad1d7":"array_10 = np.arange(0, 10)  # np.arrange() creates a single dimensional array, with given range\nprint(array_10)","55b76760":"array_11 = np.arange(0, 16, 5)  # after start and end of range, we can also provide step as an argument\nprint(array_11)","d6509404":"array_12 = np.arange(0, 33, 3.8)  # step can also be a float (start and end can also be floats too)\nprint(array_12)","ddaafb19":"array_13 = np.arange(0, 12).reshape(3, 4)  # np.arrange() can be combined with reshape() to create different shapes\nprint(array_13)  # shape and number of elements must be compatible for this","829c7719":"array_14 = np.linspace(0, 10, 5)  # linspace() takes start & end of array and the number of intervals\nprint(array_14)","8ea81279":"array_15 = np.random.random(3)  # random() takes shape as argument and creates a random array\nprint(array_15)","0903d076":"array_16 = np.random.random((3, 4))  # for 1 dimensional it takes length, for multi - shape as argument\nprint(array_16)","b36851a2":"array_17 = np.arange(4)\nprint(array_17)\narray_17 = array_17 + 4  # adding \/ subtracting scalar value to whole array\nprint(array_17)\narray_17 = array_17 * 3  # multiplying \/ dividing array by a scalar\nprint(array_17)","d48ab662":"array_17 = np.arange(4)\nprint(array_17)\narray_18 = np.arange(8, 12)\nprint(array_18)\nprint(array_17 + array_18)\nprint(array_17 - array_18)\nprint(array_17 * array_18)\nprint(array_17 \/ array_18)","d36a0eaa":"array_19 = np.linspace(0, 100, 5)\nprint(array_19)\narray_19 = np.sin(array_19)  # finding sine of each element of the array\nprint(array_19)","b589dda0":"array_20 = np.array([2, 4, 8, 16, 32, 64])\nprint(array_20)\narray_20 = np.sqrt(array_20)  # finding square root of each element of the array\nprint(array_20)","1a82d020":"array_21 = np.arange(0, 9).reshape(3, 3)\nprint(array_21)\narray_22 = np.ones((3, 3))\nprint(array_22)\nprint(array_21 + array_22)  # element-wise addition\nprint(array_21 - array_22)  # element-wise subtraction\nprint(array_21 * array_22)  # element-wise multiplication","9da3b3a8":"array_23 = np.arange(0, 9).reshape(3, 3)\nprint(array_23)\narray_24 = np.arange(10, 19).reshape(3, 3)\nprint(array_24)\narray_25 = np.dot(array_23, array_24)\nprint(array_25)","d7b43be9":"array_26 = array_23.dot(array_24)\nprint(array_26)","070e6785":"array_27 = np.dot(array_24, array_23)\nprint(array_27)","1b72ffec":"array_28 = np.arange(5)\nprint(array_28)\narray_28 += 2\nprint(array_28)\narray_28 -= 4\nprint(array_28)\narray_28 *= 3  # multiplying an array with a scalar and saving it in same variable\nprint(array_28)","1ccf9d19":"array_29 = np.arange(3, 8)\nprint(array_29)\nprint(np.sqrt(array_29)) # np.sqrt() is ufunc to find square roots of all elements in an array\nprint(np.log(array_29))  # finds logarithm\nprint(np.sin(array_29))  # finds sine\n# there are many other similar functions, that can be applied on an array element-wise","028a1938":"array_30 = np.arange(13, 20)\nprint(array_30)\nprint(array_30.sum())  # finds out sum\nprint(array_30.min())  # finds out minimum value\nprint(array_30.max())  # finds out maximum value\nprint(array_30.mean())  # finds the mean\nprint(array_30.std())  # finds standard deviation","65237fd0":"array_31 = np.arange(10, 20)\nprint(array_31)\nprint(array_31[1])  # indexing is similar to lists in python\nprint(array_31[-2])  # negative indexing also applicable\nprint(array_31[[1, 3, 4, 6, 9]])  # to select multiple indices, we provide list of indices in [<index>]","5a21ae77":"array_32 = np.arange(0, 16).reshape(4, 4)\nprint(array_32)\nprint(array_32[1, 1])  # [row index = 1, col index = 1]\nprint(array_32[-2, -3])  # [row index = -2, col index = -3]","50467958":"array_33 = np.arange(30, 40)\nprint(array_33)\nprint(array_33[1:6])  # [<start index> : <end index>]\nprint(array_33[1:8:2])  # [<start index> : <end index> : <step>]\nprint(array_33[::2])  # if start and\/or end are not provided, it will be 0 and -1 respectively, default step is 1 (i.e. no intervals)","e9aa468f":"array_34 = np.arange(10, 19).reshape(3, 3)\nprint(array_34)\nprint(array_34[0,:])  # printing first row, row = 0, col = all\nprint(array_34[:,1])  # printing second col, row = all, col = 1\nprint(array_34[1:3, 1:3])  # printing a part of matrix, with two rows and two cols\nprint(array_34[[0, 2], 1:3])  # when row\/col we want to select are not consecutive, we use an array of wanted indices","1fe69e7e":"array_35 = np.arange(100, 105)\nprint(array_35)\nfor i in array_35:  # to print all elements in a single dimensional array\n    print(i)","35bf3748":"array_36 = np.arange(100, 109).reshape(3, 3)\nprint(array_36)\nfor i in array_36:  # prints all rows in a double dimensional array\n    print(i)","c22e5c26":"array_37 = np.arange(100, 104).reshape(2, 2)\nprint(array_37)\nfor i in array_37.flat:  # to make element by element iteration in two-dimensional array\n    print(i)","88a8d54e":"array_38 = np.arange(100, 109).reshape(3, 3)\nprint(array_38)\nprint(np.apply_along_axis(np.mean, axis = 0, arr = array_38))  # calculates means of all columns' elements\nprint(np.apply_along_axis(np.mean, axis = 1, arr = array_38))  # calculates means of all rows' elements\nprint(np.apply_along_axis(np.sqrt, axis = 1, arr = array_38))  # ufunc, axis does not matter, both return same results","481e0c25":"array_39 = np.arange(100, 109).reshape(3, 3)\nprint(array_39)\ndef half(x):\n    return x\/2\nprint(np.apply_along_axis(half, axis = 1, arr = array_39))","c48f1f14":"array_40 = np.random.random((4, 4))\nprint(array_40)\nprint(array_40 < 0.5)  # checks whether elements satisfy the condition or not (i.e. are they < 0.5 or not)\nprint(array_40[array_40 < 0.5])  # returns an array with elements that satisfy the condition","13355d50":"array_41 = np.linspace(1, 120, 12)\nprint(array_41)\narray_42 = array_41.reshape(3, 4)  # creates another object\nprint(array_42)","c323f3e6":"array_43 = np.linspace(1, 10, 12)\nprint(array_43)\nprint(array_43.shape)  # printing shape of the array\narray_43.shape = (3, 4)  # assigning new shape to the array\nprint(array_43)\narray_43.shape = (2, 6)  # assigning new shape to the array\nprint(array_43)","e243b195":"array_44 = np.arange(9).reshape(3, 3)\nprint(array_44)\narray_45 = array_44.ravel()\nprint(array_45)","12f917eb":"array_46 = np.arange(10, 19).reshape(3, 3)\nprint(array_46)\narray_47 = array_46.transpose()\nprint(array_47)","f7cbeb8a":"array_48 = np.ones((3, 3))\narray_49 = np.zeros((3, 3))\narray_50 = np.vstack((array_48, array_49))  # vertical stacking of arrays\nprint(array_50)\narray_51 = np.hstack((array_48, array_49))  # horizontal stacking of arrays\nprint(array_51)","bc632465":"array_52 = np.array([0, 1, 2])\narray_53 = np.array([4, 8, 12])\narray_54 = np.array([3, 9, 27])\narray_55 = np.column_stack((array_52, array_53, array_54))  # cols from one-dim arrays make rows for new array\nprint(array_55)\narray_56 = np.row_stack((array_52, array_53, array_54))  # rows from one-dim arrays make rows for new array\nprint(array_56)","8c66e9a7":"array_57 = np.arange(0, 16).reshape((4, 4))\nprint(array_57)\n[array_58, array_59] = np.hsplit(array_57, 2)  # array & no. of parts we want array to divide in as arguments\nprint(array_58)\nprint(array_59)","4aea8079":"array_60 = np.arange(0, 16).reshape((4, 4))\nprint(array_60)\n[array_61, array_62] = np.vsplit(array_57, 2)  # splits vertically, meaning height will be divided\nprint(array_61)\nprint(array_62)","45c49794":"array_63 = np.arange(0, 16).reshape((4, 4))\nprint(array_63)\n[array_64, array_65, array_66] = np.split(array_63, [1, 3], axis = 1)\nprint(array_64)\nprint(array_65)\nprint(array_66)","abcc844a":"[array_67, array_68, array_69] = np.split(array_63, [1, 3], axis = 0)\nprint(array_67)\nprint(array_68)\nprint(array_69)","9313560c":"array_70 = np.array([1, 2, 3, 4])\narray_71 = array_70  # not a copy of an array, just a view\nprint(array_71)\narray_70[2] = 0  # changing an element in array_70\nprint(array_71)  # change mirrored in array_71","16d2a289":"array_72 = np.arange(5)\narray_73 = array_72[1:4]\nprint(array_73)\narray_73[1] = 0\nprint(array_72)","ea896c85":"array_74 = np.array([1, 2, 3, 4, 5])\narray_75 = array_74.copy()  # copying array\nprint(array_75)\narray_74[2:4] = [0, 0]  # making a change in one array\nprint(array_74)  # changed\nprint(array_75)  # unchanged","2ee2fcaf":"array_76 = np.arange(4)  # single dimensional array\narray_77 = np.arange(16).reshape(4, 4)  # two dimensional array\narray_76 + array_77  # addition is possible only if there number of cols are same\n# an array of (3, 3) shape can not add up with array_76 here\n# arrays with (1, 4), (2, 4), (3, 4), etc can","a681e9a7":"array_78 = np.random.random((4, 7))\narray_79 = np.random.random((7, 3))\narray_80 = np.dot(array_78, array_79)\nprint(array_80)","1d5bca64":"array_81 = np.array([(1, \"First\", 1.5, 1 + 5j),\n                    (2, \"Second\", 2.5, 2 + 5j),\n                    (3, \"Third\", 3.5, 3 + 5j)],\n                   dtype = (\"i2, a6, f4, c8\"))\narray_81","a58961e4":"array_82 = np.array([(1, \"First\", 1.5, 1 + 5j),\n                    (2, \"Second\", 2.5, 2 + 5j),\n                    (3, \"Third\", 3.5, 3 + 5j)],\n                   dtype = (\"int16, a6, float32, complex64\"))\narray_82","b5a006d3":"print(array_82[1])  # printing second row which contain a struct of array_82","52803c9f":"print(array_82[\"f1\"])","16eee89d":"array_83 = np.array([(1, \"1st\", 1.5, 1 + 5j),\n                    (2, \"2nd\", 2.5, 2 + 5j),\n                    (3, \"3rd\", 3.5, 3 + 5j)],\n                   dtype = [(\"integers\", \"i2\"), (\"positions\", \"a6\"), (\"floats\", \"f4\"), (\"complex\", \"c8\")])\narray_83","0b892638":"print(array_83[\"positions\"])","1fd563f2":"print(array_83.dtype)  # printing dtypes of the structs\nprint(array_83.dtype.names)  # printing tuple containing names for all dtypes in the structs","8ec880a9":"array_84 = np.array([[0.05512957, 0.73276149, 0.5778144 , 0.70635276],\n                     [0.03092344, 0.99958926, 0.63350008, 0.172151  ],\n                     [0.21842994, 0.26263767, 0.28870111, 0.29177053],\n                     [0.58234664, 0.00869582, 0.69175515, 0.45601734]])\nnp.save(\"saved_array\", array_84) # created file will automatically have '.npy' extension with it.","19652f65":"array_85 = np.load(\"saved_array.npy\")\narray_85","73f5b0bb":"array_86 = np.genfromtxt(\"..\/input\/numpy-as-i-learnt\/numpy_AIL.csv\", delimiter = \",\", names = True)\narray_86  # this will give us an structured array, with dtypes and names for all columns","a2c0170f":"array_87 = np.genfromtxt(\"..\/input\/numpy-as-i-learnt\/numpy_AIL2.csv\", delimiter = \",\", names = True)\narray_87  # genfromtxt() function replaces the blanks in the file with nan values","1e0979d7":"### Vectorization","fab575be":"### apply_along_axis()","303e13a3":"Vectorization is the absence of an explicit loop during the developing of the code. These loops actually cannot be omitted, but are implemented internally and then are replaced by other constructs in the code. The application of vectorization leads to a more concise and readable code.\n\nNumPy allows you to express the multiplication of two arrays as shown:\n\na * b\n\nOr even two matrices:\n\nA * B\n\nIn other languages, such operations would be expressed with many nested loops and the for construct.","53cd7d70":"### reshape()","a6a24856":"### ones()","0ef2e256":"NumPy allows you to create arrays that are much more complex not only in size, but in the structure, called structured arrays. This type of array contains structs or records instead of individual items.\n\nEach struct can contain bunch of elements with different data types and can be called over by using array indexing.\n\nWith the dtype option, you can specify a list of comma-separated specifiers to indicate the elements that will constitute the struct, along with data type and order.","ac37b202":"### Loading and Saving Data in Binary Files","eda794fb":"Stacking (vstack() and hstack()) is used to merge two or more arrays to form a new array which will contain all of the elements of all arrays.","c627f56a":"### Broadcasting","a777ac16":"we can convert two dimensional arrays into single dimentional ones using ravel\n\narray.shape assignment may also do the job here","3f41478b":"### Matrix Product","1a8f67de":"A very important aspect of NumPy that has not been discussed yet is the process of reading data contained in a file. This procedure is very useful, especially when you have to deal with large amounts of data collected in arrays.","ebb5f7b5":"If you want to generate a complete and distinct array, use the copy() function. In this case, if you change one array, other one will remain unchanged.","e8394435":"Arithmatic operations on multi-dimensional arrays","b022ba19":"### Joining Arrays","ee910b02":"## Intrinsic Creation of Array","b5e2e269":"### Universal Functions (ufunc)","cd38dd1c":"### Slicing","77fb1318":"### random.random()","bcc195cf":"## Basic Operations","5b4e7653":"Iterating is possible using for construct(loop).","b52bcf9f":"we can create an array by providing list or tuple to np.array()\n\nthat list may or may not be nested","0889bbf6":"### transpose()","b4fe1946":"We have seen until now element-wise multiplication of arrays\/matrices. We can also perform matrices multiplication in NumPy as well by using np.dot(), that takes two matrices as arguments.","8012bcdd":"Similar is the case when we slice an array and store it in a variable","b93893d3":"One positive aspect of this feature is that if some data are missing, the function can handle them. Let's try to do the same for data that has some removed values.","3671be9a":"now, to load the data from saved file or from any other binary file, we will use load() function. We can save the data we are loading into a variable. load() takes file name as argument, if the file is saved in same directory as the program code.","bfd23245":"Moving on to two-dimensional arrays, to refer an element we use [row index, col index] as element index","9d7e0327":"we have used reshape() above, reshape() returns a new array with shape provided as its argument","da2a328b":"we can also create our own fucntions and apply those in apply_along_axis()","f7269244":"Element-wise operations\n\nit is applied only between corresponding elements of operand arrays","113a4132":"### Arithmatic Operations","492fc8db":"Broadcasting allows an operator or a function to act on two or more arrays to operate even if these arrays do not have the same shape. That said, not all the dimensions can be subjected to broadcasting; they must meet certain rules.","a8417d5d":"### linspace()","8be269ae":"### Iterating an Array","55586fde":"if you want to divide the matrix into three parts, the first of which will include the first column, the second will include the second and the third column, and the third will include the last column, you must specify three indexes in the following way","f391bfdb":"### dtype Option","d2a3ef08":"Note that since the matrix product is not a commutative operation, the order of the operands is important. Indeed, AxB is not equal to BxA.","193ae040":"Stacking (column_stack() and row_stack()) is used generally with one dimensional arrays which are stacked as columns or rows in order to form a new two dimensional array.","148b853e":"### Copies or Views of Object","d8256062":"### Splitting Arrays","2e7f0ba7":"## Indexing, Slicing and Iterating","f6af2da2":"## Structured Arrays","25698459":"Often we need to create arrays by using already created arrays","88548b11":"### array.shape","ed523548":"When you assign one array a to another array b, you are not copying it; array b is just another way to call array a. Any change in one array will mirror in other array also. The object returned is the view of original array.","e60d50e1":"As you have just seen, the names are assigned automatically with an f (which stands for field) and a progressive integer that indicates the position in the sequence. In fact, it would be more useful to specify the names with something more meaningful. This is possible and you can do it at the time of array declaration:","bb9ceded":"functions save() and load() are used to save and later retrieve data stored in binary format.\n\nlet's say, we have an array that we have obtained after some work on it and now we want to save it. For this, we use save() function that takes name of the file(string) we're creating and array we want to save as arguments","7e7d12c4":"### Indexing","b061801e":"if we want to modify the same object, we have to assign a tuple containing the new dimensions directly to its shape attribute","e6b05c15":"split() allows to divide an array into non-symmetrical parts. It takes three arguments, an array, indexes and axis = 1 or 0 to tell indexes are for cols or for rows","56599b65":"A universal function, generally called ufunc, is a function operating on an array in an element-by-element fashion. This means that it acts individually on each single element of the input array to generate a corresponding result in a new output array. In the end, you obtain an array of the same size as the input.","43619628":"You can also use the data type explicitly specifying int8, uint8, float16, complex64, and so forth.","2d8389d1":"#### END NOTE: Thank you so much for choosing this notebook to learn or revise NumPy. I hope you liked it. Please share your comments and suggestions, if you have any. Cheers!\n\n#### Acknowledgement: I used Python Data Analytics by Fabio Nelli to teach myself this library.","35b4b745":"Aggregate functions perform an operation on an array, and produce a single result. Like sum of all elements of the array.","caf223a1":"## Shape Manipulation","061be663":"However, despite all this, NumPy offers an alternative and more elegant solution than the for loop.\n\napply_ along_axis() function takes three arguments: the function, the axis, the array\n\nif we provide a universal function, it will be applied on all the elements of the array seperately","2181940e":"## Creating a New ndarray (N-Dimentional Array)","080b1790":"### zeros()","8c612e26":"Many times, the data that you want to read or save are in textural format (TXT or CSV, for example). You might save the data in this format, instead of binary, because the files can then be accessed outside independently if you are working with NumPy or with any other application.\n\nTo be able to read such files, we use genfromtxt(), which takes file name(str), delimiter and whether the data columns are named or not.","6fedc9b5":"if not provided in array definition, numpy itself assigns a dtype to the ndarry\n\nOR we can also manually define it","5159c719":"## Array Manipulation","f42497db":"### ravel()","88b84bd1":"inverts columns with rows","a2683dad":"The NumPy library provides a set of functions that generate ndarrays with initial content, created with different values depending on the function.","bcc325bd":"### Aggregate Functions","fa110a1e":"### Creating a Two Dimensional Array","7b1b3edb":"For two-dimensional arrays, slicing is applied seperately for rows and for columns","dfecf236":"## Reading and Writing Array Data on File","f5f4312e":"Furthermore, the names assigned to the item of the structs can also be used to call all the elements of similar name in all of the structs. (Like f0, f1, f2 and f3 here)","9b40fd05":"Similarly, matrices with different shapes can also be multiplied. But the number of columns of first matrix must be equal to the number of rows of second matrix.\n\nWhenever, we multiply two matrices with (r1, c1) and (r2, c2) shapes, c1=r2 is must and (r1, c2) is the shape of resulted matrix.","f930a95a":"### Reading Files with Tabular Data","c56993e4":"In order to access a single element of an array, you can refer to its index.","64f65e64":"### Increment and Decrement Operators","c2469946":"An alternative way of performing same multiplication is writing expression like A.dot(B)","06056c54":"## General Concepts","b20bb509":"so far we have seen only integers as array elements\n\nan array might contain wide range of data types in its elements, like strings","a44e1d0e":"## Importing NumPy","cad5982c":"Hello Fellow-Kagglers, I am currently teaching Python libraries to myself. I started off with NumPy and have updated this file as I learnt. If anyone can find this benificial to learn or to revise his NumPy, I will be glad. Thanks.","16110be8":"## Conditions and Boolean Arrays","41f9c553":"### arange().reshape()","3108872a":"### arange()","98d95e4a":"Splitting (vsplit() and hsplit()) is used to divide arrays."}}