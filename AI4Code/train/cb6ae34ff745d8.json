{"cell_type":{"fb1723c9":"code","ca0615e6":"code","c0dda03f":"code","07617b8c":"code","74385a31":"code","7c29d42b":"code","01f4a6a0":"code","6cfba8ca":"code","72957743":"code","e2a9f8af":"code","8f827239":"code","b7634915":"code","201fa476":"code","51d11c79":"code","8f832b5a":"code","824932d3":"code","5fcfdda2":"code","499e694b":"code","6ed18017":"code","7e961654":"code","65710907":"code","51e90586":"code","06580f6b":"code","116b441a":"code","d664e435":"markdown","33b8a82b":"markdown","1277c405":"markdown","5b814874":"markdown","120ce453":"markdown","c00176bf":"markdown","a1bf388c":"markdown","1d71bf61":"markdown","c7cdc041":"markdown","909f64fc":"markdown","f794d260":"markdown","1ae59eab":"markdown","71c32cd4":"markdown","1ac49287":"markdown"},"source":{"fb1723c9":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport datetime\nimport os\n\nfrom matplotlib import pyplot as plt","ca0615e6":"#df_covid_19 = pd.read_csv('..\/input\/corona-virus-report\/covid_19_clean_complete.csv')\ndf_covid_19 = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/covid_19_data.csv\")\ndf_covid_19['Date'] = pd.to_datetime(df_covid_19['ObservationDate'])\ndf_covid_19['Outbreak'] = 'COVID_2019'\ndf_covid_19.columns","c0dda03f":"df_sars_03 = pd.read_csv(\"..\/input\/sars-outbreak-2003-complete-dataset\/sars_2003_complete_dataset_clean.csv\")\ndf_sars_03['Date'] = pd.to_datetime(df_sars_03['Date'])\ndf_sars_03['Province\/State'] = None\ndf_sars_03['Outbreak'] = 'SARS_2003'\nprint(df_sars_03.columns)\ndf_sars_03.rename({'Cumulative number of case(s)':'Confirmed', 'Number of deaths':'Deaths', 'Number recovered':'Recovered', 'Country':'Country\/Region'},axis=1,inplace=True)","07617b8c":"templ_cols = ['Outbreak', 'Province\/State', 'Country\/Region', 'Date', 'Confirmed', 'Deaths', 'Recovered']\ndf = pd.concat([df_covid_19[templ_cols], df_sars_03[templ_cols]])\ndf = df.reset_index(drop=True)","74385a31":"df['Confirmed'] = df['Confirmed'].fillna(0)\ndf['Province\/State'] = df['Province\/State'].fillna('Others')\ndf = df.sort_values(['Country\/Region','Province\/State','Date'])","7c29d42b":"df = df.groupby(['Outbreak','Country\/Region','Province\/State','Date']).agg({'Confirmed':'sum'}).reset_index()\ndf['Province\/State'] = 'all'","01f4a6a0":"t = df.groupby(['Outbreak','Country\/Region','Province\/State']).agg({'Confirmed':'max'})\nt = t.loc[t['Confirmed'] > 50]\ndf = pd.merge(df,t[[]],left_on=['Outbreak','Country\/Region','Province\/State'], right_index=True)","6cfba8ca":"df['Country\/Region'].value_counts()","72957743":"country_data = pd.read_csv(\"..\/input\/countries-of-the-world\/countries of the world.csv\")\ncountry_data['Country'] = country_data['Country'].str.strip()\ncountry_data","e2a9f8af":"df.loc[df['Country\/Region']=='US','Country\/Region'] = 'United States'\ndf.loc[df['Country\/Region']=='Mainland China','Country\/Region'] = 'China'\ndf.loc[df['Country\/Region']=='Viet Nam','Country\/Region'] = 'Vietnam'\ndf.loc[df['Country\/Region']=='UK','Country\/Region'] = 'United Kingdom'\ndf.loc[df['Country\/Region']=='South Korea','Country\/Region'] = 'Korea, South'\ndf.loc[df['Country\/Region']=='Taiwan, China','Country\/Region'] = 'Taiwan'\ndf.loc[df['Country\/Region']=='Hong Kong SAR, China','Country\/Region'] = 'Hong Kong'\n\ndf = pd.merge(df, country_data, how='left', left_on=['Country\/Region'], right_on=['Country'])\ndf['Date'] = pd.to_datetime(df['Date'])","8f827239":"df.loc[df['Country'].isnull()]['Country\/Region'].value_counts()","b7634915":"df.loc[df['Region'].isnull(), 'Region'] = 'Others'\ndf.loc[df['Country'].isnull(), 'Country'] = 'Undefined'","201fa476":"df['Country'].value_counts()","51d11c79":"fix, ax = plt.subplots(figsize=(16,6), ncols=2)\ns0 = df['Confirmed']\ns0.plot.hist(ax=ax[0])\n\n# BoxCox\n#from sklearn.preprocessing import PowerTransformer\n#transformer = PowerTransformer(method='box-cox', standardize=True)\n#s0 = s0+1\n\n# Normalise and reshape\n#from sklearn.preprocessing import FunctionTransformer\n#transformer = FunctionTransformer(np.log1p, inverse_func=np.expm1, validate=True)\n\nfrom sklearn.preprocessing import MinMaxScaler\ntransformer = MinMaxScaler(feature_range=(0,1)).fit(np.asarray([0, 2E5]).reshape(-1,1)) # df['Confirmed'].values.reshape(-1,1)\n\ns1 = pd.Series(transformer.transform(s0.values.reshape(-1,1)).reshape(-1))\ns1.plot.hist(ax=ax[1])\ndf['Confirmed_transformed'] = s1 # make sure that every value is positive","8f832b5a":"df['Month'] = df['Date'].dt.month\ndf['Week'] = df['Date'].dt.week","824932d3":"n_lags = 5\nfor k,v in df.groupby(['Outbreak','Country\/Region','Province\/State']):    \n    for d in range(n_lags,0,-1):                \n        df.loc[v.index, f'Confirmed_Lag_{d}'] = v['Confirmed'].shift(d)\n        #df.loc[v.index, f'Confirmed_Rolling_Mean_Lag{d}'] = v['Confirmed'].shift(d).rolling(n_lags).mean()\n        df.loc[v.index, f'Confirmed_Transformed_Lag_{d}'] = v['Confirmed_transformed'].shift(d)\n\nX_mask_lags = [c for c in df.columns if 'Confirmed_Lag_' in c]# + [c for c in df.columns if 'Confirmed_Rolling_Mean_Lag' in c]\nX_mask_lags_transformed = [c for c in df.columns if 'Confirmed_Transformed_Lag_' in c]\n\ndf[X_mask_lags] = df[X_mask_lags].fillna(0)\ndf[X_mask_lags_transformed] = df[X_mask_lags_transformed].fillna(0)\n\nprint(f'Dataframe shape {df.shape}')","5fcfdda2":"from sklearn.preprocessing import LabelEncoder\nenc_outb = LabelEncoder().fit(df['Outbreak'])\ndf['Outbreak_enc'] = enc_outb.transform(df['Outbreak'])\n\nenc_ctry = LabelEncoder().fit(df['Country\/Region'])\ndf['Country_enc'] = enc_ctry.transform(df['Country\/Region'])\n\nenc_region = LabelEncoder().fit(df['Region'])\ndf['Region_enc'] = enc_region.transform(df['Region'])","499e694b":"from sklearn.model_selection import train_test_split\n\nX_mask_cat = ['Outbreak_enc','Region_enc', 'Month','Week']\ntrain_test = df.loc[df['Confirmed'] > 50].copy()\ns_unique_values = train_test[X_mask_lags].apply(lambda r: len(np.unique(r.values)), axis=1)\ntrain_test = train_test.loc[s_unique_values > 1].copy()\nprint(f'Train\/Test shape {train_test.shape}')\n\ntrain, valid = train_test_split(train_test, test_size=0.2, shuffle=True, random_state=231451)","6ed18017":"from lightgbm import LGBMRegressor    \nmodel_lgbm = LGBMRegressor(n_estimators=200, metric='mae', random_state=1234, min_child_samples=5, min_child_weight=0.000001)\n\nprint(f'Fitting on data with shape {train[X_mask_cat+X_mask_lags].shape} with validation of shape {valid[X_mask_cat+X_mask_lags].shape}')\n\nmodel_lgbm.fit(X=train[X_mask_cat+X_mask_lags], y=train['Confirmed'], \n               eval_set=(valid[X_mask_cat+X_mask_lags], valid['Confirmed']),\n               early_stopping_rounds=50, verbose=10)","7e961654":"from datetime import timedelta\npred_steps = 28\n\nhistory = df.loc[(df['Outbreak']=='COVID_2019') & (df['Confirmed'] > 0) & (df['Country\/Region']=='Germany')]\nhistory0 = history.iloc[-1]\n\ndt_rng = pd.date_range(start=history0['Date']+timedelta(days=1), \n                       end=history0['Date']+timedelta(days=pred_steps),freq='D').values\ndt_rng = pd.to_datetime(dt_rng)\n\npred_months = pd.Series(dt_rng).apply(lambda dt: dt.month)\npred_weeks = pd.Series(dt_rng).apply(lambda dt: dt.week)\n\npred_cat = history0[X_mask_cat].values\npred_lags = history0[X_mask_lags].values\ny = history0['Confirmed']\n\nprint('History 0: ', pred_lags)\npred_lags[:n_lags] = np.roll(pred_lags[:n_lags], -1)\npred_lags[n_lags-1] = y  # Lag\n#pred_lags[n_lags:] = np.roll(pred_lags[n_lags:], -1)\n#pred_lags[-1] = np.mean(pred_lags[:n_lags]) # rolling_mean\nprint('Pred 0: ', pred_lags)\n\npred = np.zeros(pred_steps)\nfor d in range(pred_steps):     \n    pred_cat[1] = pred_months[d]\n    pred_cat[2] = pred_weeks[d]    \n    \n    y = model_lgbm.predict(np.hstack([pred_cat, pred_lags]).reshape(1,-1))[0]\n    #print(f'Prediction body: ', np.hstack([pred_cat, pred_lags]).reshape(1,-1))\n    print(f'Step {d}, predicted for {dt_rng[d].strftime(\"%Y-%m-%d\")} is: {y}')\n    \n    pred_lags[:n_lags] = np.roll(pred_lags[:n_lags], -1)\n    pred_lags[n_lags-1] = y  # Lag    \n #   pred_lags[n_lags:] = np.roll(pred_lags[n_lags:], -1)\n #   pred_lags[-1] = np.mean(pred_lags[n_lags:]) # rolling_mean\n\n    pred[d] = y\n    \npreds = pd.Series(data=pred, index=dt_rng, name='LGBM predicted')","65710907":"from tensorflow.keras.models import Model\nfrom tensorflow.keras.layers import Dense, LSTM, Dropout, TimeDistributed, RepeatVector, Input, Concatenate, Flatten, Reshape, Embedding\nfrom tensorflow.keras.backend import clear_session\n\nclear_session()\n\ninp_outbreak = Input(shape=(1,1))\ninp_country = Input(shape=(1,1))\ninp_lags = Input(shape=(n_lags,1))\n\nemb_outbreak = Embedding(input_dim=2, output_dim=1)(inp_outbreak)\nemb_country = Embedding(input_dim=210, output_dim=2)(inp_country)\n\nlstm1 = LSTM(64, activation='linear', return_sequences=True)(inp_lags)\nlstm2 = LSTM(32, activation='linear', return_sequences=False)(lstm1)\n\nconcat1 = Reshape(target_shape=(1,3))(Concatenate(axis=3)([emb_outbreak, emb_country]))\nconcat2 = Concatenate(axis=1)([Flatten()(concat1), lstm2])\ndense1 = Dense(32, activation='linear')(concat2)\ndense2 = Dense(1, activation='linear')(dense1)\n\nmodel_keras = Model(inputs=[inp_outbreak, inp_country, inp_lags], outputs=[dense2])\nmodel_keras.compile(loss='mean_squared_error', optimizer='adam')\nmodel_keras.summary()\n\n\ndef prepare_keras_input(data):\n    lags = data[X_mask_lags_transformed].values.reshape(-1, 5, 1)\n    y = data['Confirmed_transformed'].values.reshape(-1,1)    \n    \n    return [data['Outbreak_enc'].values.reshape(-1,1,1), \n            data['Country_enc'].values.reshape(-1,1,1), lags], y\n    \ntrain_X, train_y = prepare_keras_input(train)\nmodel_keras.fit(train_X, train_y, validation_data=(prepare_keras_input(valid)), epochs=50, verbose=0)\n","51e90586":"from datetime import timedelta\nfrom tensorflow import convert_to_tensor\n\npred_steps = 28\n\nhistory = df.loc[(df['Outbreak']=='COVID_2019') & (df['Confirmed'] > 0) & (df['Country\/Region']=='Germany')]\nhistory0 = history.iloc[-1]\n\npred_cat_outbreak = convert_to_tensor(history0['Outbreak_enc'].reshape(-1,1,1), np.int32)\npred_cat_country = convert_to_tensor(history0['Country_enc'].reshape(-1,1,1), np.int32)\n\npred_lags = history0[X_mask_lags_transformed].values\ny = history0['Confirmed_transformed']\n\n#print('History 0: ', pred_lags)\npred_lags = np.roll(pred_lags, -1)\npred_lags[-1] = y\n\n#print('Pred 0: ', pred_lags)\npred = np.zeros(pred_steps)\n\ndt_rng = pd.date_range(start=history0['Date']+timedelta(days=1), \n                       end=history0['Date']+timedelta(days=pred_steps),freq='D').values\ndt_rng = pd.to_datetime(dt_rng)\n# Scale\nfor d in range(pred_steps):    \n    y = model_keras.predict([pred_cat_outbreak, pred_cat_country, convert_to_tensor(pred_lags.reshape(-1,5,1), np.float32)])[0][0]\n    #print(f'Pred body: {pred_lags}')\n    print(f'Step {d}, predicted for {dt_rng[d].strftime(\"%Y-%m-%d\")} is: {transformer.inverse_transform(y.reshape(-1,1)).reshape(-1)}')\n    \n    pred_lags = np.roll(pred_lags, -1)\n    pred_lags[-1] = y    \n    pred[d] = y\n    \npred = transformer.inverse_transform(pred.reshape(-1,1)).reshape(-1)\npreds_keras = pd.Series(data=pred, index=dt_rng, name='Keras predicted')","06580f6b":"from matplotlib import pyplot as plt\nfig, ax = plt.subplots(figsize=(16,6))\n\nhist = history.set_index(['Date'])['Confirmed'].plot(ax=ax, marker='o')\npreds.plot(ax=ax, marker='o', linewidth=2)\npreds_keras.plot(ax=ax, marker='.')\nplt.legend()\nplt.tight_layout()\n","116b441a":"ts = datetime.datetime.now().strftime('%Y%m%d')\ndf_out = pd.DataFrame([preds, preds_keras]).T\ndf_out.to_csv(f'{ts}_prediction.csv')","d664e435":"**Addition: We will not focus on provice level because earlier runs showed unsteadiness - not enough data**\n\nHence: group on country","33b8a82b":"### Gather Covid_19 and Sars_2003 data\n\nSARS 2003 outbreak seems to have much in common with current COVID-19 outbreak. Hence, use additional SARS data for training.","1277c405":"## Machine Learning with LGBM","5b814874":"### Feature engineering","120ce453":"### Save results","c00176bf":"Out-of-sample prediction with 28 steps (days)","a1bf388c":"### Remove countries with minor confirmation numbers","1d71bf61":"# Estimate the confirmed covid-19-cases in Germany for up to 4 weeks in future with LGBM and Keras\n\n- based on global (country\/region-wise) developments of confirmation rates including covid_19 and sars_03 outbreaks\n- Updated on 20-03-19","c7cdc041":"Check for a proper normalization in case of an LSTM model","909f64fc":"## Machine Learning via Neural network (KERAS-based)","f794d260":"Use a model which is comprising some categorical informations (via embedding layers) and a LSTM structure to learn the time-dependent behavior.","1ae59eab":"### Encoding","71c32cd4":"Out-of-sample prediction with 28 steps (days)","1ac49287":"**Lags**\n\nWe use a 5-day-lag window to estimate the future development"}}