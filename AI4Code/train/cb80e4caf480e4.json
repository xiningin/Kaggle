{"cell_type":{"7a7035ad":"code","a39c7427":"code","83f5b36f":"code","3b9969f1":"code","e8296bde":"code","78527baf":"markdown","248a5277":"markdown","0eabf642":"markdown","64ba3744":"markdown","8d4b9bd6":"markdown","55eebfeb":"markdown"},"source":{"7a7035ad":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","a39c7427":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline","83f5b36f":"train=pd.read_csv('\/kaggle\/input\/digit-recognizer\/train.csv')","3b9969f1":"class RingCounter():\n    def search(self,i,array,threshold=0):\n        proximal=[]\n        if i==0:\n            if array[i+1]<=threshold:proximal.append(i+1)\n            if array[i+28]<=threshold:proximal.append(i+28)\n        elif i==27:\n            if array[i-1]<=threshold:proximal.append(i-1)\n            if array[i+28]<=threshold:proximal.append(i+28)\n        elif i==756:\n            if array[i+1]<=threshold:proximal.append(i+1)\n            if array[i-28]<=threshold:proximal.append(i-28)\n        elif i==783:\n            if array[i-1]<=threshold:proximal.append(i-1)\n            if array[i-28]<=threshold:proximal.append(i-28)\n        elif i>0 and i<756 and i\/\/28==i\/28:\n            if array[i-28]<=threshold:proximal.append(i-28)\n            if array[i+1]<=threshold:proximal.append(i+1)\n            if array[i+28]<=threshold:proximal.append(i+28)\n        elif i>27 and i<783 and (i+1)\/\/28==(i+1)\/28:\n            if array[i-28]<=threshold:proximal.append(i-28)\n            if array[i-1]<=threshold:proximal.append(i-1)\n            if array[i+28]<=threshold:proximal.append(i+28)\n        elif i>0 and i<27:\n            if array[i-1]<=threshold:proximal.append(i-1)\n            if array[i+1]<=threshold:proximal.append(i+1)\n            if array[i+28]<=threshold:proximal.append(i+28)\n        elif i>756 and i<783:\n            if array[i-28]<=threshold:proximal.append(i-28)\n            if array[i-1]<=threshold:proximal.append(i-1)\n            if array[i+1]<=threshold:proximal.append(i+1)\n        else:\n            if array[i-28]<=threshold:proximal.append(i-28)\n            if array[i-1]<=threshold:proximal.append(i-1)\n            if array[i+1]<=threshold:proximal.append(i+1)\n            if array[i+28]<=threshold:proximal.append(i+28)\n        \n        return proximal\n\n    def remover(self,list_1,list_2):\n        list_1.extend(list_2)\n        list_1,list_2=list(set(list_1)),list(set(list_2))\n        try:\n            for k in list_2:\n                list_1.remove(k)\n        except:pass\n        return list_1\n\n    def recognizer(self,row,threshold=0,min_block=9):\n        array=np.array(row)\n        zeros=np.where(array<=threshold)[0]\n        zeros=zeros.tolist()\n        ring_count=0\n    \n        while True:\n            proximal=[]\n            k=zeros[0]\n            proximal.append(k)\n            p_prox=self.search(k,array,threshold=threshold)\n            proximal.extend(p_prox)\n            new_prox=proximal.copy()\n\n            while True:\n                prox_stock=[]\n                for k in new_prox:\n                    p_prox=self.search(k,array,threshold=threshold)\n                    prox_stock.extend(p_prox)\n\n                new_prox=self.remover(prox_stock,proximal)\n                proximal.extend(prox_stock)\n                proximal=list(set(proximal))\n\n                if new_prox==[]:\n                    if  len(proximal)==len(zeros):\n                        return ring_count\n                        break\n                    elif self.remover(zeros,proximal)!=[]:\n                        if len(proximal)>=min_block:\n                            ring_count+=1\n                            zeros=self.remover(zeros,proximal)\n                            break\n                        else:\n                            zeros=self.remover(zeros,proximal)\n                            break\n                    else:\n                        return ring_count\n                        break\n                else:\n                    pass","e8296bde":"RC=RingCounter()\nplt.figure(figsize=(10,6))\nfor n,i in enumerate(range(10,10+3)):\n    plt.subplot(1,3,n+1)\n    array=np.array(train.iloc[i,1:])\n    print('Recognizer result:',RC.recognizer(array))\n    print('Label:',train.iloc[i,0])\n    print('\\n')\n    plt.imshow(array.reshape(28,28),cmap='gray')","78527baf":"Ring_counting algorithm","248a5277":"Import necessary modules.","0eabf642":"Load data for evaluation.","64ba3744":"The result shows that it has correctly counted the number of rings (8->2, 9->1, 1->0)\n\nI would really appreciate it if you give me any feedbacks!","8d4b9bd6":"**When working on \"Digit Recognizer\" competition without neural networks, it might be useful to add the number of rings (e.g. (1,2,3,5,7)->0, (0,4,6,9)->1, (8)->2 if written as it is) of each digit.**\n\n**For example, it will be helpful when telling 3 and 8 apart.**","55eebfeb":"Evaluation with some train data."}}