{"cell_type":{"153bbb7b":"code","4fc68210":"code","c35025e4":"code","a4434a9a":"code","19da36bd":"code","c2f28cb3":"code","acf1a9f9":"code","384eabf4":"code","3b712941":"code","ccca8196":"code","07225214":"code","fb8fd79a":"code","d84c90d5":"code","89436e84":"code","164ca20c":"markdown"},"source":{"153bbb7b":"import torch\nimport pandas as pd\nimport numpy as np\nfrom sklearn import preprocessing\n\nimport random\nfrom torch.utils.data import DataLoader, TensorDataset\n\ntorch.manual_seed(777)\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\nif device == 'cuda':\n  torch.cuda.manual_seed_all(777)","4fc68210":"scaler = preprocessing.StandardScaler()","c35025e4":"train = pd.read_csv('..\/input\/2020-ai-termproject-18011793\/train.csv', header=None, skiprows=1)\ntest = pd.read_csv('..\/input\/2020-ai-termproject-18011793\/test.csv', header=None, skiprows=1)","a4434a9a":"train[0] = train[0]%10000\/100\nx_train = train.loc[:,0:9]\ny_train = train.loc[:,[10]]\n\nx_train = np.array(x_train)\ny_train = np.array(y_train)\nx_train = scaler.fit_transform(x_train)\n\nx_train = torch.FloatTensor(x_train).to(device)\ny_train = torch.FloatTensor(y_train).to(device)","19da36bd":"y_train","c2f28cb3":"dataset = TensorDataset(x_train, y_train)\ndataloader = DataLoader(dataset, batch_size=8, shuffle=True, drop_last=True)\n\n#model = torch.nn.Linear(10,1).to(device)\n#optimizer = torch.optim.SGD(model.parameters(), lr = 0.0001, momentum=0.8)\n#loss = torch.nn.MSELoss().to(device)","acf1a9f9":"linear1 = torch.nn.Linear(10,512,bias=True)\nlinear2 = torch.nn.Linear(512,512,bias=True)\nlinear3 = torch.nn.Linear(512,1,bias=True)\nrelu = torch.nn.LeakyReLU()","384eabf4":"torch.nn.init.xavier_uniform_(linear1.weight)\ntorch.nn.init.xavier_uniform_(linear2.weight)\ntorch.nn.init.xavier_uniform_(linear3.weight)","3b712941":"model = torch.nn.Sequential(linear1,relu,\n                        linear2,relu,\n                        linear3).to(device)","ccca8196":"optimizer = torch.optim.Adam(model.parameters(), lr = 0.00001)\nloss = torch.nn.MSELoss().to(device)","07225214":"epochs = 1000\ncost_list = []\nfor epoch in range(epochs+1):\n  for x,y in dataloader:\n\n    x = x.to(device)\n    y = y.to(device)\n\n    hypothesis = model(x)\n    cost = loss(hypothesis, y)\n\n    optimizer.zero_grad()\n    cost.backward()\n    optimizer.step()\n\n  if epoch%100 == 0:\n    print('Epoch {} Cost {}'.format(epoch, cost.item()))","fb8fd79a":"with torch.no_grad():\n  test[0] = test[0]%10000\/100\n  x_test = test.loc[:,:]\n  x_test = np.array(x_test)\n  x_test = scaler.transform(x_test)\n  x_test = torch.from_numpy(x_test).float().to(device)\n\n  p = model(x_test)","d84c90d5":"p = p.cpu().numpy().reshape(-1, 1)\nsubmit = pd.read_csv('submit_sample.csv')\nfor i in range(len(p)):\n  submit['Total'][i]=p[i].item()\nsubmit","89436e84":"submit.to_csv('submit.csv', index=False, header=True)\n!kaggle competitions submit -c 2020-ai-termproject-18011793 -f submit.csv -m \"defense\"","164ca20c":"# \uc774\uc804\uacfc \ubcc0\uacbd\ub41c \uc810\n\n* NN \uc7ac\uc124\uacc4 \n- 1 layer -> 3 layer\n> linear1 = torch.nn.Linear(10,512,bias=True)<br>\n> linear2 = torch.nn.Linear(512,512,bias=True)<br>\n> linear3 = torch.nn.Linear(512,1,bias=True)<br>\n- \ucd08\uae30\ud654 \ubc29\ubc95 LeakyReLU() \ucd94\uac00\n> relu = torch.nn.LeakyReLU()<br>\n- torch.optim.SGD -> torch.optim.Adam\n>optimizer = torch.optim.Adam(model.parameters(), lr = 0.00001)\n- lr \uac12 \ubcc0\uacbd\n>lr = 0.0001 --> lr = 0.00001\n"}}