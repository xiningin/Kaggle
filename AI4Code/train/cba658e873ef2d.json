{"cell_type":{"5e4b9151":"code","b2b657c2":"code","005ba851":"code","04faac5f":"code","60e6b3dd":"code","f138c066":"code","a36a98ee":"code","7fa440c8":"code","621772c1":"code","416d7663":"code","5ee88223":"markdown","a69b3b4d":"markdown","38e1894b":"markdown","e936b18a":"markdown","8a1a9e1e":"markdown","2343a006":"markdown","22cc5a73":"markdown","e61a3da3":"markdown","0986f750":"markdown","25dfedbd":"markdown"},"source":{"5e4b9151":"#import necessary libraries\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cv2","b2b657c2":"leo = cv2.imread('..\/input\/test-images\/leonardo.jpg',1)\nteamusa = cv2.imread('..\/input\/test-images\/usa.jpg',1)","005ba851":"plt.figure(figsize=(5,10))\nleo_rgb = cv2.cvtColor(leo, cv2.COLOR_BGR2RGB)\nplt.imshow(leo_rgb);","04faac5f":"face_cascade = cv2.CascadeClassifier('..\/input\/haarcascades\/haarcascade_frontalface_default.xml')","60e6b3dd":"def detect_face (img):\n    face_img = img.copy()\n    detect_img = face_cascade.detectMultiScale(face_img)\n    \n    #get the coordinates and draw a rectangle\n    for (x,y,w,h) in detect_img:\n        cv2.rectangle(face_img, (x,y), (x+w, y+h), (0,255,0), 3)\n    \n    return face_img","f138c066":"#show results\nplt.figure(figsize=(5,10))\nplt.title('FACE DETECTION')\nresult = detect_face(leo_rgb)\nplt.imshow(result);","a36a98ee":"usa_rgb = cv2.cvtColor(teamusa, cv2.COLOR_BGR2RGB)\nresult = detect_face(usa_rgb)\nplt.figure(figsize=(20,8))\nplt.title('TEAM USA')\nplt.imshow(result);","7fa440c8":"#Adjust the detect_face function\ndef detect_face (img):\n    face_img = img.copy()\n    detect_img = face_cascade.detectMultiScale(face_img, scaleFactor=1.3, minNeighbors=3)\n    \n    #get the coordinates and draw a rectangle\n    for (x,y,w,h) in detect_img:\n        cv2.rectangle(face_img, (x,y), (x+w, y+h), (0,255,0), 3)\n    \n    return face_img","621772c1":"# show result\nusa_rgb = cv2.cvtColor(teamusa, cv2.COLOR_BGR2RGB)\nresult = detect_face(usa_rgb)\nplt.figure(figsize=(20,8))\nplt.title('ADJUSTED PARAMETERS')\nplt.imshow(result);","416d7663":"# vid_capture = cv2.VideoCapture(0)\n\n# while True:\n#     #read the frames\n#     ret, frame = vid_capture.read(0)\n    \n#     #detect faces\n#     frame = detect_face(frame)\n#     cv2.imshow('Face Detection', frame);\n    \n#     #press esc key to exit\n#     k = cv2.waitKey(1)\n#     if k==27:\n#         break\n        \n# vid_capture.release()\n# cv2.destroyAllWindows()","5ee88223":"#### SHOW SAMPLE IMAGE","a69b3b4d":"* Currently, Kernels are not able to support cam access. Run the code on your local computer to test it.","38e1894b":"### INTRODUCTION\n\n* In this notebook we will explore face detection using Haar Cascades, Which is a key component of a Viola Jones object detection framework.\n* Keep in mind that this is a face detection, not face recognition.\n\n### What is Haar Cascade?\n\n * Is a machine learning object detection algorithm used to identify objects in an image or video and based on the concept of features proposed by Paul Viola and Michael Jones in their paper \"Rapid Object Detection using a Boosted Cascade of Simple Features\" in 2001.\n\n* Haar-like features are digital image features used in object recognition. They owe their name to their intuitive similarity with Haar wavelets and were used in the first real-time face detector.","e936b18a":"#### DETECT THE FACE","8a1a9e1e":"#### LET'S TRY THE TEAM USA PICTURE","2343a006":"#### GET THE TEST IMAGES","22cc5a73":"* You see now you get a much better and clear detection of actual faces.\n* Go ahead and play of some of these parameters\n* I only use couple of defaults that worked well for me but a lot times is just experimentation.","e61a3da3":"### FACE DETECTION ON VIDEOS","0986f750":"#### GET THE HAAR CASCADE FILE","25dfedbd":"* Right off the bat you will notice that some of these things that it's detecting are not faces, to fix this we're going to add afew parameters specifically scaleFactor and minimumNeighbors.\n* ScaleFactor is a parameter specifying how much the image size is reduced at each image scale\n* minNeighbors is a parameter specifying how many neighbors each candidate rectangle should have to retain it. "}}