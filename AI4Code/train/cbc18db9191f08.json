{"cell_type":{"0d1b8c45":"code","28dad5e1":"code","dd052566":"code","1e3bbe14":"code","262a0d07":"code","cfe21ede":"code","b29d3aa3":"code","a45d3772":"code","57902f99":"code","35a93573":"code","950ef264":"code","e4b3263a":"code","98282ca9":"code","3510a6e0":"code","125cab08":"code","f1d89191":"code","07ed580f":"code","74ad3a65":"code","c533d27c":"code","336089b8":"code","a9615211":"code","22e70589":"code","8b158255":"code","dddbb124":"code","42df3d3b":"code","aa99821f":"code","162ce3a3":"code","e5c039fa":"code","2f369351":"code","19b3fda2":"code","0ff3d631":"code","7eedf150":"code","78b339d2":"code","7fce682a":"code","21f9f2d7":"code","1ab0e89d":"code","7d3587bc":"code","141d61fa":"code","cbd596de":"code","c14ceb45":"code","0a2bd1ae":"code","32534746":"code","6de3c34f":"code","851e7997":"code","93a64b61":"code","683910ed":"code","af16c784":"code","127338c2":"code","a6b18c0d":"code","d0477be9":"code","03035385":"code","8aaf7b9e":"code","afa22eb7":"code","156f493c":"code","1a2a5870":"code","bdca8ac6":"code","84ae6999":"code","c54ea03b":"code","97851583":"code","f1ec9b87":"code","7440cb43":"code","9c052f97":"code","f76783f4":"code","13d707c4":"code","a9305c45":"code","5a88a8bc":"code","851279cd":"code","f1b56f36":"code","b55a5270":"code","fca7d661":"code","8ada3d05":"code","76b559ff":"code","8475e67f":"code","8c3a9c8e":"code","c7b84338":"code","597abc21":"code","891eb9c1":"code","b9e84821":"code","6ae0884c":"code","59567c22":"code","22808a98":"code","f8de91d9":"code","8793679f":"code","499099ad":"code","425e79cd":"code","beda4331":"code","13c7e444":"code","9b11c7ca":"code","a9e32ad9":"code","0783c632":"code","f0718b62":"code","d5e3d609":"code","d0b90fb6":"code","7c9ff076":"code","10a7d353":"code","e784fa56":"code","3e4c2505":"code","d67b9e09":"markdown","9d592e73":"markdown","097fe4a2":"markdown","c357fd48":"markdown","3283d7a2":"markdown","79a49fb0":"markdown","1aeecebe":"markdown","187d7f8b":"markdown","656204de":"markdown","55a34c4e":"markdown","dead5ea6":"markdown","f0a064f4":"markdown","aaddfd08":"markdown","7d19a2e6":"markdown","bf73e122":"markdown","2487d446":"markdown","c813b6dc":"markdown","10da1572":"markdown","76fa049e":"markdown","fc3adcea":"markdown","ed2b7586":"markdown","a5c337de":"markdown","3a284508":"markdown","3739c3e8":"markdown","63545f49":"markdown","ba6e6894":"markdown","5ecf3884":"markdown","440d29e0":"markdown","ac4864fb":"markdown","f39f35bd":"markdown","98054e69":"markdown","b1ff6bfc":"markdown","1245d09e":"markdown"},"source":{"0d1b8c45":"import numpy as np                               # vectors and matrices\nimport pandas as pd                              # tables and data manipulations\nimport matplotlib.pyplot as plt                  # plots\n%matplotlib inline  \nimport seaborn as sns                            # more plots\nfrom datetime import datetime\nfrom matplotlib import pyplot\nplt.style.use('dark_background')\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 14, 5\nfrom pandas.plotting import register_matplotlib_converters\nregister_matplotlib_converters()\n\n\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")    ","28dad5e1":"def parser(s):\n    return datetime.strptime(s, '%y-%m-%d')","dd052566":"train = pd.read_csv(\"..\/input\/daily-delhi-climate-dataset\/DailyDelhiClimateTrain.csv\", header = 0, parse_dates=[0])","1e3bbe14":"test = pd.read_csv(\"..\/input\/daily-delhi-climate-dataset\/DailyDelhiClimateTest.csv\", header = 0, parse_dates=[0])","262a0d07":"df= pd.concat([train,test])","cfe21ede":"df.index = df['date']","b29d3aa3":"df.head()","a45d3772":"df.info()","57902f99":"ts = df['meantemp']\nts","35a93573":"#1. Specify the entire range:\nts['2013-01-01':'2013-01-30']","950ef264":"ts['2013-01-01':'2013-01-30'].plot()","e4b3263a":"ts['2013']","98282ca9":"ts['2013'].plot()","3510a6e0":"ts.plot()","125cab08":"#Determine rolling statistics\nrolmean = ts.rolling(window=365).mean() \nrolstd = ts.rolling(window=365).std()","f1d89191":"#Plot rolling statistics\norig = plt.plot(ts, color='blue', label='Original')\nmean = plt.plot(rolmean, color='red', label='Rolling Mean')\nstd = plt.plot(rolstd, color='yellow', label='Rolling Std')\nplt.legend(loc='best')\nplt.title('Rolling Mean & Standard Deviation')\nplt.show(block=False)","07ed580f":"from statsmodels.tsa.stattools import adfuller\n#Perform Dickey-Fuller test:\nx =ts\nresult = adfuller(x)\nprint ('Results of Dickey-Fuller Test:')\nprint('Test Statistic: %f' %result[0])\nprint('p-value: %f' %result[1])\nprint('Critical values:')\nfor key, value in result[4].items():\n    print('\\t%s: %.3f' %(key, value))","74ad3a65":"month_avg = ts.groupby(ts.index.month).mean()","c533d27c":"ts_month_avg = ts.index.map(lambda d: month_avg.loc[d.month])","336089b8":"ts_month_avg","a9615211":"stationary = ts- ts_month_avg\nstationary.head()","22e70589":"plt.plot(stationary)","8b158255":"from statsmodels.tsa.stattools import adfuller\n#Perform Dickey-Fuller test:\nx =stationary\nresult = adfuller(x)\nprint ('Results of Dickey-Fuller Test:')\nprint('Test Statistic: %f' %result[0])\nprint('p-value: %f' %result[1])\nprint('Critical values:')\nfor key, value in result[4].items():\n    print('\\t%s: %.3f' %(key, value))","dddbb124":"from statsmodels.graphics.tsaplots import plot_acf, plot_pacf","42df3d3b":"acf_plot = plot_acf(stationary, lags= 20)","aa99821f":"pacf_plot = plot_pacf(stationary)","162ce3a3":"from statsmodels.tsa.seasonal import seasonal_decompose\nresult_a = seasonal_decompose(df['meantemp'], model = \"add\", period=365)\nresult_a.plot();","e5c039fa":"result_m = seasonal_decompose(stationary, model = \"add\", period=365)\nresult_m.plot();","2f369351":"!pip install pmdarima","19b3fda2":"from statsmodels.tsa.arima_model import ARMA\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom pmdarima import auto_arima  \nimport pmdarima as pm\nfrom sklearn.metrics import mean_squared_error\nfrom statsmodels.tools.eval_measures import rmse\nfrom sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error\nfrom statsmodels.graphics.gofplots import qqplot\nfrom pandas.plotting import autocorrelation_plot\nfrom statsmodels.tsa.ar_model import AutoReg","0ff3d631":"train, test = stationary[0:df.shape[0]-114], stationary[df.shape[0]-114:]","7eedf150":"model = ARMA(train, order = (2, 0))    \nmodel_fit = model.fit()  ","78b339d2":"print(model_fit.summary().tables[1])","7fce682a":"stationary.plot(figsize = (16,5), label= 'actual', legend=True)\nmodel_fit.fittedvalues.plot(legend = True, label='Forecast')","21f9f2d7":"AR_predict = model_fit.predict(start=len(train), end=len(train)+len(test)-1)\nAR_predict.head()","1ab0e89d":"test.plot( figsize = (16,5), label= 'actual', legend=True)\nAR_predict.plot(legend = True, label='Forecast')","7d3587bc":"mse = ((AR_predict- test) ** 2).mean()\nprint('The Mean Squared Error is {}'.format(round(mse, 2)))\nprint('The Root Mean Squared Error is {}'.format(round(np.sqrt(mse), 2)))","141d61fa":"residulas = model_fit.resid\nresidulas","cbd596de":"residulas.plot()","c14ceb45":"residuals = test-AR_predict\nresiduals","0a2bd1ae":"residuals.plot()","32534746":"residuals.describe()","6de3c34f":"residuals.plot(kind = 'kde', color = 'white')","851e7997":"qqplot(residuals, color = 'white');","93a64b61":"model = ARMA(train, order=(0,7))  \nresults_MA = model.fit()  \nprint(results_MA.summary().tables[1])","683910ed":"stationary.plot(figsize = (16,5), label= 'actual', legend=True)\nresults_MA.fittedvalues.plot(legend = True, label='Forecast')","af16c784":"MA_prediction =results_MA.predict(start=len(train), end=len(train)+len(test)-1)\nMA_prediction.head()","127338c2":"mse = ((MA_prediction- test) ** 2).mean()\nprint('The Mean Squared Error is {}'.format(round(mse, 2)))\nprint('The Root Mean Squared Error is {}'.format(round(np.sqrt(mse), 2)))","a6b18c0d":"test.plot(figsize = (16,5), label= 'actual', legend=True)\nMA_prediction.plot(legend = True, label='Forecast')","d0477be9":"resid = test-MA_prediction\nresid","03035385":"resid.plot()","8aaf7b9e":"resid.describe()","afa22eb7":"\nmodel = pm.auto_arima(train,\n                      test='adf',       # use adftest to find optimal 'd'\n                      seasonal=True,   #  Seasonality\n                      trace=True,       #compile various models\n                      stepwise=True)\n\nprint(model.summary())\n\n","156f493c":"model.plot_diagnostics(figsize=(16,8))\nplt.show()","1a2a5870":"forecast = model.predict(n_periods=len(test))\nfc = pd.DataFrame(forecast, index = test.index, columns = ['prediction'])","bdca8ac6":"mse = ((forecast- test) ** 2).mean()\nprint('The Mean Squared Error is {}'.format(round(mse, 2)))\nprint('The Root Mean Squared Error is {}'.format(round(np.sqrt(mse), 2)))","84ae6999":"import warnings\nimport itertools\nimport matplotlib.pyplot as plt\nwarnings.filterwarnings(\"ignore\")\nimport statsmodels.api as sm\nimport matplotlib\nmatplotlib.rcParams['axes.labelsize'] = 14\nmatplotlib.rcParams['xtick.labelsize'] = 12\nmatplotlib.rcParams['ytick.labelsize'] = 12","c54ea03b":"p = d = q = range(0, 2)\npdq = list(itertools.product(p, d, q))\nseasonal_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]\nprint('Examples of parameter for SARIMA...')\nprint('SARIMAX: {} x {}'.format(pdq[1], seasonal_pdq[1]))\nprint('SARIMAX: {} x {}'.format(pdq[1], seasonal_pdq[2]))\nprint('SARIMAX: {} x {}'.format(pdq[2], seasonal_pdq[3]))\nprint('SARIMAX: {} x {}'.format(pdq[2], seasonal_pdq[4]))","97851583":"for param in pdq:\n    for param_seasonal in seasonal_pdq:\n        try:\n            mod = sm.tsa.statespace.SARIMAX(train, order=param,seasonal_order=param_seasonal,enforce_stationarity=False,enforce_invertibility=False)\n            results = mod.fit()\n            print('ARIMA{}x{}12 - AIC:{}'.format(param,param_seasonal,results.aic))\n        except: \n            continue","f1ec9b87":"result = sm.tsa.statespace.SARIMAX(train, order=(1, 1, 1), seasonal_order = (1,1,1,12))\nresults= result.fit()\n\nprint(results.summary().tables[1])","7440cb43":"results.plot_diagnostics(figsize=(18, 8));","9c052f97":"pred =results.get_prediction(start = pd.to_datetime('2017-01-01'), dynamic = False)","f76783f4":"ax=test.plot(label='observed')\npredu = results.get_forecast(len(test))\npredu.predicted_mean.plot(ax=ax, label = 'forecast')","13d707c4":"predd = pred.predicted_mean\nmse = ((predd- test) ** 2).mean()\nprint('The Mean Squared Error is {}'.format(round(mse, 2)))\nprint('The Root Mean Squared Error is {}'.format(round(np.sqrt(mse), 2)))","a9305c45":"train, test = ts[0:df.shape[0]-114], ts[df.shape[0]-114:]","5a88a8bc":"from statsmodels.tsa.api import ExponentialSmoothing, SimpleExpSmoothing, Holt\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 16,5","851279cd":"# rolling average transformation\nrollingseries = train.rolling(window = 5)          #window is how many past value we consider for creating rolling mean\nrollingmean = rollingseries.mean()              #finding rolling mean\nprint(rollingmean.head(10))","f1b56f36":"#plot transformed dataset\ntest.plot(color = 'yellow', label = 'actual')\nrollingmean.plot(color = 'white',style='--', label = \"smoothed\")\nplt.legend()\nplt.show()","b55a5270":"# Simple Exponential Smoothing\nfit1 = SimpleExpSmoothing(train).fit(smoothing_level=0.2,optimized=False)\nfcast1 = fit1.forecast(114).rename(r'$\\alpha=0.2$')\n# plot\nfcast1.plot(marker='+', color='blue', legend=True)\nfit1.fittedvalues.plot(marker='+',  color='blue')\n\n\n\nfit2 = SimpleExpSmoothing(train).fit(smoothing_level=0.6,optimized=False)\nfcast2 = fit2.forecast(114).rename(r'$\\alpha=0.6$')\n# plot\nfcast2.plot(marker='+', color='red', legend=True)\nfit2.fittedvalues.plot(marker='+', color='red')\n\n\nfit3 = SimpleExpSmoothing(train).fit()\nfcast3 = fit3.forecast(114).rename(r'$\\alpha=%s$'%fit3.model.params['smoothing_level'])\n# plot\nfcast3.plot(marker='+', color='green', legend=True)\nfit3.fittedvalues.plot(marker='+', color='green')\nplt.show()","fca7d661":"test.plot(marker='+',label= 'actual',color= 'white', legend=True)\nfcast1.plot(marker='+', color='blue', legend=True)\n\nmse = ((fcast1 - test) ** 2).mean()\nprint('The Mean Squared Error is {}'.format(round(mse, 2)))\nprint('The Root Mean Squared Error is {}'.format(round(np.sqrt(mse), 2)))","8ada3d05":"fit1 = Holt(train).fit(smoothing_level=0.8, smoothing_slope=0.2, optimized=False)\nfcast1 = fit1.forecast(114).rename(\"Holt's linear trend\")           #model with smoothing parameter also liner model\n\nfit2 = Holt(train, exponential=True).fit(smoothing_level=0.8, smoothing_slope=0.2, optimized=False)\nfcast2 = fit2.forecast(114).rename(\"Exponential trend\")             #holt exponential model\n\nfit3 = Holt(train, damped=True).fit(smoothing_level=0.1, smoothing_slope=0)\nfcast3 = fit3.forecast(114).rename(\"Additive damped trend\")         #dampen version of holt additive model\n\n\nfit1.fittedvalues.plot(style='--', color='blue')\nfcast1.plot(color='blue', marker=\"*\", legend=True)\nfit2.fittedvalues.plot(style='--', color='red')\nfcast2.plot(color='red', marker=\"*\", legend=True)\nfit3.fittedvalues.plot(style='--', color='green')\nfcast3.plot(color='green', marker=\"*\", legend=True)\n\nplt.show()\n","76b559ff":"test.plot(marker='+',label= 'actual', legend=True)\nfcast3.plot(marker='+',legend = True, label='Additive damped Forecast')\n\nmse = ((fcast3 - test) ** 2).mean()\nprint('The Mean Squared Error is {}'.format(round(mse, 2)))\nprint('The Root Mean Squared Error is {}'.format(round(np.sqrt(mse), 2)))","8475e67f":"fit1 = ExponentialSmoothing(train, seasonal_periods=365, trend='add', seasonal='add').fit(use_boxcox=True)\nfcast1 = fit1.forecast(114).rename(\"holt's winter linear trend and seasonal\")\nfit2 = ExponentialSmoothing(train, seasonal_periods=365, trend='add', seasonal='mul').fit(use_boxcox=True)\nfcast2 = fit2.forecast(114).rename(\"additive trend , multiplictive season\")\nfit3 = ExponentialSmoothing(train, seasonal_periods=365, trend='add', seasonal='add', damped=True).fit(use_boxcox=True)\nfcast3 = fit3.forecast(114).rename(\"dampend linear trend, additive seasonal\")\nfit4 = ExponentialSmoothing(train, seasonal_periods=365, trend='add', seasonal='mul', damped=True).fit(use_boxcox=True)\nfcast4 = fit4.forecast(114).rename(\"additive dampend trend, multiplicative seasonal\")\n\nfit1.fittedvalues.plot(style='--', color='red')\nfcast1.plot(color='red', marker=\"o\", legend=True)\nfit3.fittedvalues.plot(style='--', color='yellow')\nfcast3.plot(color='yellow', marker=\"o\", legend=True)\n\n\nplt.title(\"Forecasting meantemp using Holt-Winters method with both additive and multiplicative seasonality.\")\nplt.show()","8c3a9c8e":"test.plot(marker='+',label= 'actual', legend=True)\nfcast3.plot(marker='+',legend = True, label='dampend linear trend, additive seasonal Forecast')\n\nmse = ((fcast3 - test) ** 2).mean()\nprint('The Mean Squared Error is {}'.format(round(mse, 2)))\nprint('The Root Mean Squared Error is {}'.format(round(np.sqrt(mse), 2)))","c7b84338":"###pip install pystan\n###conda install -c conda-forge fbprophet\n\nfrom fbprophet import Prophet\nplt.style.use('bmh')","597abc21":"df.head()","891eb9c1":"train, test =df[0:df.shape[0]-114], df[df.shape[0]-114:]","b9e84821":"train.drop([\"humidity\",\"wind_speed\",\"meanpressure\"],inplace=True,axis=1)\ntest.drop([\"humidity\",\"wind_speed\",\"meanpressure\"],inplace=True,axis=1)","6ae0884c":"train.head()","59567c22":"df= pd.concat([train,test])\ndf.head()","22808a98":"df.rename(columns={'meantemp': 'y', 'date': 'ds'}, inplace=True)\ndf.head()","f8de91d9":"from scipy.stats import boxcox","8793679f":"# Apply Box-Cox Transform to meantemp column and assign to new column y\ndf['y'], lam = boxcox(df['y'])\ndf.head()","499099ad":"train, test =df[0:df.shape[0]-114], df[df.shape[0]-114:]","425e79cd":"test.shape","beda4331":"m = Prophet()\nm.fit(train)","13c7e444":"future = m.make_future_dataframe(periods=len(test))\nfuture.head()","9b11c7ca":"forecast = m.predict(future)\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head()","a9e32ad9":"# Plot the forecast\nf, ax = plt.subplots(1)\nf.set_figheight(6)\nf.set_figwidth(10)\nfig = m.plot(forecast,\n                 ax=ax)\nplt.show()","0783c632":"prophet_pred = pd.DataFrame({\"Date\" : forecast[-len(test):]['ds'], \"Pred\" : forecast[-len(test):][\"yhat\"]})\nprophet_pred.set_index(\"Date\")\nprophet_pred.head()","f0718b62":"plt.figure(figsize=(16,5))\nax = sns.lineplot(x= test.index, y=test[\"y\"])\nsns.lineplot(x=test.index, y = prophet_pred[\"Pred\"]);","d5e3d609":"metric = forecast.set_index('ds')[['yhat']].join(df.set_index('ds').y).reset_index()\nmetric.head()","d0b90fb6":"metric.dropna(inplace = True)","7c9ff076":"MSE = mean_squared_error(metric.y, metric.yhat)\nMAE = mean_absolute_error(metric.y, metric.yhat)\nRMSE = np.sqrt(MSE)\nR2_SCORE= r2_score(metric.y, metric.yhat)\n\nprint(MSE)\nprint(MAE)\nprint(RMSE)\nprint(R2_SCORE)","10a7d353":"fig=m.plot_components(forecast)","e784fa56":"from scipy.special import inv_boxcox","3e4c2505":"# Apply inverse Box-Cox transform to specific forecast columns\nforecast[['yhat','yhat_upper','yhat_lower']] = forecast[['yhat','yhat_upper','yhat_lower']].apply(lambda x: inv_boxcox(x, lam))","d67b9e09":"## MA","9d592e73":"## Moving Avearage Method","097fe4a2":"## seasonal_decompose","c357fd48":"# Time Series Analysis","3283d7a2":"## AR","79a49fb0":" For our time series to be stationary, we need to ensure that both the rolling statistics ie: mean & std. deviation remains constant with time. Thus the curves for both of them have to be parallel to the x-axis.","1aeecebe":"Based on PACF , we should start with an Auto Regressive model with lag 1 only","187d7f8b":"# Visualization","656204de":"### 2.8 Autocorrelation and Partial Autocorrelation\n\n    Autocorrelation : The autocorrelation function (ACF) measures how a series is correlated with itself at different lags\n\n    Partial Autocorrelation : The partial autocorrelation function can be interpreted as a regression of the series against its past lags.The terms can be interpreted the same way as a standard linear regression, that is the contribution of a change in that particular lag while holding others constant.\n","55a34c4e":"## Triple Exponential Smoothing (Holt Winter Method)","dead5ea6":"\n    1. Data Handeling\/Preprocessing\n    2. Data Visualization\n    3. Stationarity\n    4. Augmented Dickey-Fuller (ADF)\n    5. TimeSeries Decomposition\n    6. Auto-correlation & Partial Auto-Correlation(ACF & PACF)\n  \n    7. Models for Univariate Time Series\n           7.1.1 AR model\n            7.1.2 MA model\n            7.1.3 ARIMA model\n            7.1.4 SARIMA model\n    8. Moving Avrage Method\n      8.1 Simple Moving Average\n        8.2 Simple Exponential Smoothing\n        8.3 Double Exponential Smoothing(Holt Liner Trend)\n        8.4 Triple Exponential Smoothing(Holt-Winter)\n    9. FB Prophe(Univariate Prophet)   \n    6. Conclusions\n","f0a064f4":"## ACF","aaddfd08":"###### Here our p-value<0.05 so we reject the null hypothesis that data does not have a unit root and is stationary","7d19a2e6":"based on deminishing behaviour of Acf. we are likely dealing with an Auto Regressive process","bf73e122":"Since Prophet was used on the Box-Cox transformed data, we'll need to transform our forecasted values back to their original units. To transform our new forecasted values back to their original units, we will need to perform an inverse Box-Cox transform.","2487d446":"## Simple Exponential Smoothing","c813b6dc":"There is pattern in residual so our model is not good","10da1572":"now we going to choose power tranformation using Box-Cox transform(However, it can sometimes be difficult to determine which type of power transform is appropriate for your data. This is where the Box-Cox Transform comes in) to the data to remove noise before feeding the data into forecasting","76fa049e":"## AUTO ARIMA","fc3adcea":"If we want to visualize the individual forecast components, you can use Prophet\u2019s built-in plot_components method:","ed2b7586":"## Making Time Series Stationary","a5c337de":"here box-cox test required as input one diamentional array of positive data to tranform. and we give here lamda value for our transformation which we would like to choose(e.g lambda = 0 for log transformation), otherwise we will let the boxcox method determine the optimal lamda to use for our transformation  and we will return that value to a varible named lam: ","3a284508":"To further augment our hypothesis that the time series is not stationary, let us perform the ADCF test.","3739c3e8":"From above graph, we see that rolling mean and rolling std devivation is constant with time. ","63545f49":"## FB Prophet","ba6e6894":"Checking stationarity using Dicker-fuller test","5ecf3884":"## PACF","440d29e0":"Here our p-value is much more than our threshold so we accept the null hypothesis that data have a unit root and is non stationary","ac4864fb":"## SARIMA","f39f35bd":"if we plot our newly transformed data alongside the untransformed data, we can see that the Box-Cox transformation was able to remove much of the increasing variance in our observations over time:","98054e69":"## Holt Method for Double Exponential Smoothing","b1ff6bfc":"The inv_boxcox method has two required inputs; an array of data to transform and a \u03bb value for the transform. We will inverse transform specific columns in our forecast dataframe, and supply the \u03bb value we obtained earlier from our first Box-Cox transform stored in the lam variable:","1245d09e":"## Checking Stationarity"}}