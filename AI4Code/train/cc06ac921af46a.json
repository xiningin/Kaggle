{"cell_type":{"fb92db05":"code","76af900d":"code","1309f37e":"code","ed54a11b":"code","fb82ec55":"code","a46d55a2":"code","8e481082":"code","d704cd59":"code","9dadb12b":"code","733d82b4":"code","c351f5b9":"code","58f79c9c":"code","7758e2fd":"code","b91267a6":"code","4aaac263":"code","ba26b35e":"code","fc70c81f":"code","09a0cdec":"code","c7440eea":"code","5f31c203":"code","06efcfe9":"code","d2af5577":"code","8f575d45":"code","1624fc93":"code","5698214b":"code","e44f74c8":"code","bf2d7e09":"code","6a9c99c0":"code","d7980092":"code","f99f9e4f":"code","85c24bfa":"code","be046d6f":"code","d919107d":"code","c24601cd":"code","c54b9f75":"code","a86707b2":"code","5f9da7ec":"code","45e1da7f":"code","809289c4":"code","895fd9ea":"code","e158216b":"code","f1573a5f":"code","6bc0d33f":"code","a89ed196":"code","e43f9941":"code","9004ac48":"code","012e167e":"code","13d4bfe7":"code","af8da20e":"code","3fc7c9ec":"code","d05351ea":"code","143f2f17":"code","1c64885c":"code","4c8209d7":"code","d7212064":"code","ddce4171":"code","d7a44926":"code","63b3e9cf":"code","c63510c1":"code","ecb1f7e4":"code","6e64b918":"code","f59339cf":"code","7e438260":"code","b9c25e2a":"code","b9167963":"code","8a03f9a9":"code","191e0354":"code","6110e67f":"code","453e2661":"code","98866ab4":"code","e5437789":"code","77cf6d18":"code","6bc85db5":"code","3cb8bcab":"code","9b5db6cc":"code","e752dcb3":"code","4f55ddfb":"code","69521cee":"code","d5d467bb":"code","dd9d1bc3":"code","46f82e8d":"code","394711c0":"code","295c448a":"code","aa4d942c":"code","c4bbc304":"code","570703f2":"markdown","89391509":"markdown","6ba2ee16":"markdown","1bc76414":"markdown","4e83c154":"markdown","1d7ffebb":"markdown","a33e2e59":"markdown","d9409b0d":"markdown","6010243d":"markdown","5fba2cb9":"markdown","d57e6520":"markdown","0cc9ce54":"markdown","07eaf830":"markdown","127d41fd":"markdown","18d37658":"markdown","71042f01":"markdown","a3bb389e":"markdown","76da9bcf":"markdown","15a54c3e":"markdown","dbba3e84":"markdown","6c170cd3":"markdown","ff3dc1eb":"markdown","9f293c47":"markdown","af4e30d1":"markdown","f37e6de5":"markdown","65ce8642":"markdown","4a4343cf":"markdown","36531d5d":"markdown","b0b83b79":"markdown","f5799550":"markdown","46600a08":"markdown","bcc49d3a":"markdown","9250cb95":"markdown","b0054b3e":"markdown","dde0af90":"markdown","faafc1b5":"markdown","7be45a2d":"markdown","08fd07c0":"markdown","da129ac3":"markdown","523ce817":"markdown","d9373c43":"markdown","5193b75d":"markdown","703b1dd4":"markdown","ac6cbd02":"markdown","c10c1360":"markdown","0c86136a":"markdown","02353588":"markdown","43406596":"markdown","0e453d17":"markdown","4fe7c603":"markdown","331e7c35":"markdown"},"source":{"fb92db05":"import os\n\nimport numpy as np\nfrom numpy import convolve\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.mlab as mlab\n\nfrom scipy import signal\nfrom scipy.fftpack import fft\nfrom scipy.signal import butter, filtfilt, freqz, iirdesign, zpk2tf\nimport scipy as scp\nimport scipy.stats as sp\nfrom scipy.interpolate import interp1d\n\nimport math\nimport sklearn\nimport glob","76af900d":"DEBUG = 1\nEPS = 0.00001          #-5dB\n\n#BPF aliasing\nlowcut_alias = 18             #Hz, to remove low freq\nhighcut_alias = 1020          #Hz\nfband_alias =[lowcut_alias,highcut_alias]\norder_bpf_alias = 6          #filter order\n#BPF strain\nlowcut = lowcut_alias+5      #23Hz, to remove low freq\nhighcut = highcut_alias-5    #1015Hz\nfband =[lowcut,highcut]\norder_bpf = 4                #filter order\n\nfs = 2048                    #sample rate, Hz\nnyq = 0.5 * fs               #Nyquist Frequency","1309f37e":"MAIN_DIR = '..\/input\/g2net-gravitational-wave-detection'\nTRAIN_DIR = '..\/input\/g2net-gravitational-wave-detection\/train'\nSUB_DIR = '..\/input\/g2net-gravitational-wave-detection\/test'\n\ntrain = pd.read_csv(MAIN_DIR+'\/training_labels.csv')\ntest = pd.read_csv(MAIN_DIR+'\/sample_submission.csv')\t","ed54a11b":"if DEBUG == 1:\n    #paths = glob.glob(TRAIN_DIR+\"\/0\/0\/*\/*\")\n    paths = glob.glob(TRAIN_DIR+\"\/0\/9\/*\/*\")\nelse:\n    paths = glob.glob(TRAIN_DIR+\"\/*\/*\/*\/*\")\n\nids = [path.split(\"\/\")[-1].split(\".\")[0] for path in paths]\npaths_df = pd.DataFrame({\"path\":paths, \"id\": ids})\ntrain_df = pd.merge(left=train, right=paths_df, on=\"id\")\n\n#paths = glob.glob(SUB_DIR+\"\/*\/*\/*\/*\")\n#ids = [path.split(\"\/\")[-1].split(\".\")[0] for path in paths]\n#paths_df = pd.DataFrame({\"path\":paths, \"id\": ids})\n#test_df = pd.merge(left=test, right=paths_df, on=\"id\")\n\ntrain_df.head(2)","fb82ec55":"train_df.shape","a46d55a2":"df_0     = train_df[train_df['target']==0]\ndf_1     = train_df[train_df['target']==1]\t\n\n#train_df = pd.concat([df_0,df_1])\n#train_df = train_df.reset_index()\n#test_df = test_df[:31].reset_index(drop=True)   ","8e481082":"np.log2(len(df_0)), np.log2(len(df_1))  #19bits","d704cd59":"def numerical_values(dat, gain=1):\n    if gain != 1 :                #avoid multiply by 0.9999..\n        dat = gain*dat\n    dat_min  = np.min(dat)\n    dat_max  = np.max(dat)\n    dat_mean = np.mean(dat)\n    print('len=', len(dat))\n    print('min=', dat_min, 'max=',dat_max, 'mean=',dat_mean)\n    \n    dat_min_bit = np.log2(abs(dat_min))\n    dat_max_bit = np.log2(abs(dat_max))\n    dat_mean_bit = np.log2(abs(dat_mean))\n    dat_range_bit = np.log2(abs(dat_max-dat_min))\n    print('minbit= ',dat_min_bit, 'maxbit= ',dat_max_bit, 'meanbit= ',dat_mean_bit, 'rangebit= ',dat_range_bit )\n    return dat_mean","9dadb12b":"#import sys\n#sys.float_info \nnp.finfo(\"float64\")","733d82b4":"print('closest value to 0 =', np.finfo(\"float64\").tiny, 'smallest value=', 2**-1074, 'smallest round to 0= ',2**-1075)","c351f5b9":"#Checking numerical values\n#LIGO averaged measured noise amplitude of about 10^-23 at 100 Hz, Virgo it is 5 \u00d7 10^-24 at 100 Hz\n#gain_ref_ligo = 1\/(4*10**-24) \n#gain_ref_virgo = 1\/(5*10**-24)\ngain_min = 2**int(np.log2(1\/10**-23))  #power of 2 gain, <<76bits\ngain_ref = 2**int(np.log2(1\/10**-24))  # <<79 bits\ngain_max = 2**int(np.log2(1\/10**-25))  # <<83 bits\n\nfile_path = df_0.iloc[0][\"path\"]\ndat_raw  =  np.load(file_path)\n\n#H1 - LIGO    \ngain_ligo_H1 = 1.0\ndat_mean = numerical_values(dat_raw[0,], gain_ligo_H1)  \n#gain_ligo_H1 = 1\/np.abs(dat_mean)  #\n#gain_ligo_H1 = 2**( int( np.log2(gain_ligo_H1)) )\ndat_mean = numerical_values(dat_raw[0,], gain_ref)  #use reference gain for all, <<79\n\n#L1 - LIGO\ngain_ligo_L1 = 1.0\ndat_mean = numerical_values(dat_raw[1,], gain_ligo_L1)  \n#gain_ligo_L1 = 1\/np.abs(dat_mean)  #\n#gain_ligo_L1 = 2**( int( np.log2(gain_ligo_L1)) )\ndat_mean = numerical_values(dat_raw[1,], gain_ref)  #use reference gain for all, <<79\n\n#V1 - VIRGO\ngain_virgo_V1 = 1.0\ndat_mean = numerical_values(dat_raw[2,], gain_virgo_V1)  \n#gain_virgo_V1 = 1\/np.abs(dat_mean)  #\n#gain_virgo_V1 = 2**( int( np.log2(gain_virgo_V1)) )\ndat_mean = numerical_values(dat_raw[2,], gain_ref)  #use reference gain for all, <<79","58f79c9c":"def butter_bandpass_filter(data, cutoff_low, cutoff_high, fs, order):\n    normal_cutoff_low = cutoff_low \/ nyq\n    normal_cutoff_high = cutoff_high \/ nyq    \n    # Get the filter coefficients \n    # bb, ab = butter(6, [80*2.\/fs, 500*2.\/fs], btype='band')\n    b, a = butter(order, [normal_cutoff_low,normal_cutoff_high], btype='band', analog=False)\n    y = filtfilt(b, a, data)\n    return y\n\n\n#BandPass Filter Frequency Response\nb2, a2 = butter(order_bpf_alias, [lowcut_alias\/nyq, highcut_alias\/nyq], btype='band', analog=False)\nw2,h2 = freqz(b2,a2, fs=fs)\nprint(len(w2))  #len(w2) = 1024Hz\n\nplt.figure(figsize=(18,4))\nplt.subplot(131)\nplt.plot(w2, 20 * np.log10(abs(h2)+2**-31), 'b')  #add 2**-31 to avoid log(0)\nplt.ylabel('Amplitude [dB]', color='b')\nplt.xlabel('Frequency [Hz]')\nplt.grid()\nplt.title('BPF, passband @ 18Hz~1020Hz')\n\nbins=20   # 40Hz = 20*1024\/len(w2)\nplt.subplot(132)\nplt.plot(w2[:bins], 20 * np.log10(abs(h2[:bins])+2**-31), 'b')\nplt.ylabel('Amplitude [dB]', color='b')\nplt.xlabel('Frequency [Hz]')\nplt.grid()\nplt.title('Zoom-In BPF')\n\nbins=15  # -30Hz = 15*1024\/len(w2)\nplt.subplot(133)\nplt.plot(w2[-bins:], 20 * np.log10(abs(h2[-bins:])+2**-31), 'b')\nplt.ylabel('Amplitude [dB]', color='b')\nplt.xlabel('Frequency [Hz]')\nplt.grid()\nplt.title('Zoom-In BPF')","7758e2fd":"#https:\/\/www.uv.es\/virgogroup\/Denoising_ROF.html\n    \n#This filtering method consists in detecting the known spectral lines \n#(e.g. frequency of the normal modes of vibration of the suspended mirrors, \n#frequency of the electric network, etc) to remove them from the data.\n\ndef iir_bandstops(fstops, fs, order=4):\n    \"\"\"ellip notch filter\n    fstops is a list of entries of the form [frequency (Hz), df, df2]                           \n    where df is the pass width and df2 is the stop width (narrower                              \n    than the pass width). Use caution if passing more than one freq at a time,                  \n    because the filter response might behave in ways you don't expect.\n    \"\"\"\n    nyq = 0.5 * fs\n\n    # Zeros zd, poles pd, and gain kd for the digital filter\n    zd = np.array([])\n    pd = np.array([])\n    kd = 1\n\n    # Notches\n    for fstopData in fstops:\n        fstop = fstopData[0]\n        df = fstopData[1]\n        df2 = fstopData[2]\n        low = (fstop - df) \/ nyq\n        high = (fstop + df) \/ nyq\n        low2 = (fstop - df2) \/ nyq\n        high2 = (fstop + df2) \/ nyq\n        z, p, k = iirdesign([low,high], [low2,high2], gpass=1, gstop=6,\n                            ftype='ellip', output='zpk')\n        zd = np.append(zd,z)\n        pd = np.append(pd,p)\n\n    # Set gain to one at 100 Hz...better not notch there                                        \n    bPrelim,aPrelim = zpk2tf(zd, pd, 1)\n    outFreq, outg0 = freqz(bPrelim, aPrelim, 100\/nyq)\n\n    # Return the numerator and denominator of the digital filter                                \n    b,a = zpk2tf(zd,pd,k)\n    return b, a\n\n\ndef get_filter_coefs(fs):\n#def get_filter_coefs():    \n    \n    # assemble the filter b,a coefficients:\n    coefs = []\n\n    # bandpass filter parameters\n    #lowcut=43\n    #highcut=1023  #2047\n    #order = 4\n\n    # bandpass filter coefficients \n    #nyq = 0.5*fs\n    #low = lowcut \/ nyq\n    #high = highcut \/ nyq\n    #bb, ab = butter(order, [low, high], btype='band')\n    #coefs.append((bb,ab))\n\n    # Frequencies of notches at known instrumental spectral line frequencies.\n    # You can see these lines in the ASD above, so it is straightforward to make this list.\n    notchesAbsolute = np.array(\n        [14.0,34.70, 35.30, 35.90, 36.70, 37.30, 40.95, 60.00, \n         120.00, 179.99, 304.99, 331.49, 510.02, 1009.99])\n\n    # notch filter coefficients:\n    for notchf in notchesAbsolute:                      \n        bn, an = iir_bandstops(np.array([[notchf,1,0.1]]), fs, order=4)\n        coefs.append((bn,an))\n\n    # Manually do a wider notch filter around 510 Hz etc.          \n    bn, an = iir_bandstops(np.array([[510,200,20]]), fs, order=4)\n    coefs.append((bn, an))\n\n    # also notch out the forest of lines around 331.5 Hz\n    bn, an = iir_bandstops(np.array([[331.5,10,1]]), fs, order=4)\n    coefs.append((bn, an))\n    \n    return coefs\n\n# Find the coefficients\nnotch_coefs = get_filter_coefs(fs)\n\n\ndef notch_filter_data(data_in,coefs):\n    data = data_in.copy()\n    for coef in coefs:\n        b,a = coef\n        # filtfilt applies a linear filter twice, once forward and once backwards.\n        # The combined filter has linear phase.\n        data = filtfilt(b, a, data)\n    return data","b91267a6":"avg_sample = np.power(2,9)  #512\nmax_31bit  = np.power(2,30)-1  #2**30-1\n\ndef avg_data(df,gain,bpf,noise=np.array([])):\n    max_abs = np.full(3, -np.inf)\n    \n    if gain == 1:  \n        avg_df  = np.zeros((3,4096), dtype = np.float64)  #\n        if(noise.size == 0):\n            noise   = np.zeros((3,4096), dtype = np.float64)  # background-noise\n    else:    \n        avg_df  = np.zeros((3,4096), dtype = np.float32)  #\n        if(noise.size == 0):\n            noise   = np.zeros((3,4096), dtype = np.float32)  # background-noise\n    for i,fn in enumerate(df.path[:avg_sample]):\n        dat_raw   = np.load(fn)                           #3x4096\n        if gain != 1:  #avoid multiply by 0.99...\n            dat_raw   = gain*dat_raw                      # <<79 bits\n          \n                \n        for k in range( len(avg_df) ):\n            if bpf:\n                dat_raw[k,] = butter_bandpass_filter(dat_raw[k,], lowcut_alias, highcut_alias, fs, order=6)  #aliasing filter\n                #dat_raw[k,] = butter_bandpass_filter(dat_raw[k,], lowcut_alias, highcut_alias, fs, order=6)  #serialize double the attenuation\n                \n            if i == 0:\n                avg_df[k,] = dat_raw[k,] - noise[k,]  #remove background noise\n            else:\n                avg_df[k,] = avg_df[k,] + dat_raw[k,] - noise[k,]  #remove background noise\n\n                    \n            if(i%200 == 0):\n                dat_min=np.min(avg_df[k,])\n                dat_max=np.max(avg_df[k,])\n                dat_mean=np.mean(avg_df[k,])\n                max_abs_i = max( np.abs(dat_min), np.abs(dat_max))\n                \n                if max_abs_i > max_abs[k] :\n                    max_abs[k] = max_abs_i\n                    \n                print(k, dat_min, dat_max, dat_mean, max_abs[k])\n\n                if ( max_abs[k] > max_31bit):\n                    print(k,'close to fixed-point overflow')\n                    \n    avg_df = avg_df\/(i+1)\n    return avg_df\t","4aaac263":"df0_avg = avg_data(df_0, gain=1,bpf=False)         #float64","ba26b35e":"#BPF_alias OFF\ndf0_avg_gain = avg_data(df_0, gain_ref,bpf=False)  #float32","fc70c81f":"#BPF_alias ON\ndf0_avg_bpf = avg_data(df_0, gain_ref, bpf=True)  #float32","09a0cdec":"np.shape(df0_avg), df0_avg.dtype, df0_avg_gain.dtype, df0_avg_bpf.dtype","c7440eea":"max_raw = np.abs(np.max(df0_avg))\nmin_raw = np.abs(np.min(df0_avg)) \nabs_max = max( max_raw, min_raw )\nnp.log2(min_raw),np.log2(max_raw),np.log2(np.abs(np.mean(df0_avg))),10*np.log10(abs_max-np.abs(np.mean(df0_avg)))","5f31c203":"max_g = np.abs(np.max(df0_avg_gain))\nmin_g = np.abs(np.min(df0_avg_gain)) \nabs_max_gain = max(max_g,min_g)\nnp.log2(min_g),np.log2(max_g),np.log2(np.abs(np.mean(df0_avg_gain))),10*np.log10(abs_max_gain-np.abs(np.mean(df0_avg_gain)))","06efcfe9":"max_b = np.abs(np.max(df0_avg_bpf))\nmin_b = np.abs(np.min(df0_avg_bpf)) \nabs_max_b = max(max_b,min_b)\nnp.log2(min_b),np.log2(max_b),np.log2(np.abs(np.mean(df0_avg_bpf))),10*np.log10(abs_max_b-np.abs(np.mean(df0_avg_bpf)))","d2af5577":"def plot_time_domain_dat(xt, xtgbpf, xtgbpf_bg):    \n    fig,ax = plt.subplots(nrows=3, ncols=3, figsize=(24,12))\n    all_ones = np.ones(np.shape(xt)[1])\n    #overlay plots of average without gain float64, avg with gain<<79 float32, avg with gain<<79+BPF float32\n    ax[0,0].plot(xt[0,],'b')                  #H1\n    ax[0,0].plot(xtgbpf[0,], 'r--')     #inverse gain >>79bits for comparing\n    ax[0,0].plot(xtgbpf_bg[0,], 'g--')  #inverse gain >>79bits for comparing\n    ax[1,0].plot(xt[1,],'b')                  #L1\n    ax[1,0].plot(xtgbpf[1,], 'r--')     #inverse gain >>79bits for comparing\n    ax[1,0].plot(xtgbpf_bg[1,], 'g--')  #inverse gain >>79bits for comparing\n    ax[2,0].plot(xt[2,],'b')                  #V1\n    ax[2,0].plot(xtgbpf[2,], 'r--')     #inverse gain >>79bits for comparing\n    ax[2,0].plot(xtgbpf_bg[2,], 'g--')  #inverse gain >>79bits for comparing\n    ax[0,0].legend(['H1','H1<<79','H1_bpf'])\n    ax[1,0].legend(['L1','L1<<79','L1_bpf'])\n    ax[2,0].legend(['V1','V1<<79','V1_bpf'])\n    \n    #average with gain<<79, float32\n    ax[0,1].plot(xtgbpf[0,],'r')             #H1\n    ax[0,1].plot(all_ones*np.mean(xtgbpf[0,]),'k')  \n    ax[1,1].plot(xtgbpf[1,],'r')             #L1\n    ax[1,1].plot(all_ones*np.mean(xtgbpf[1,]),'k') \n    ax[2,1].plot(xtgbpf[2,],'r')             #V1\n    ax[2,1].plot(all_ones*np.mean(xtgbpf[2,]),'k') \n    ax[0,1].legend(['H1<<79','mean'])\n    ax[1,1].legend(['L1<<79','mean'])\n    ax[2,1].legend(['V1<<79','mean'])\n    #average with gain<<79 + BPF, float32\n    ax[0,2].plot(xtgbpf_bg[0,],'g')              #H1\n    ax[0,2].plot(all_ones*np.mean(xtgbpf_bg[0,]),'k')  \n    ax[1,2].plot(xtgbpf_bg[1,],'g')              #L1\n    ax[1,2].plot(all_ones*np.mean(xtgbpf_bg[1,]),'k') \n    ax[2,2].plot(xtgbpf_bg[2,],'g')              #V1 \n    ax[2,2].plot(all_ones*np.mean(xtgbpf_bg[2,]),'k') \n    ax[0,2].legend(['H1_bpf','mean'])\n    ax[1,2].legend(['L1_bpf','mean'])\n    ax[2,2].legend(['V1_bpf','mean'])\n    return","8f575d45":"plot_time_domain_dat(df0_avg, df0_avg_gain\/gain_ref, df0_avg_bpf\/gain_ref)  #scale-down for comparison","1624fc93":"def gen_psds(x):\n    s_H1 = x[0,]\n    s_L1 = x[1,]\n    s_V1 = x[2,]\n    # number of sample for the fast fourier transform:\n    #NFFT = 1*fs\n    NFFT = 2 * fs           # Use 2 seconds of data for each fourier transform\n    NOVL = 1 * NFFT \/ 2     # The number of points of overlap between segments used in Tukey averaging\n    psd_window = scp.signal.tukey(NFFT, alpha=1.\/4)\n    \n    #Tukey window\n    Pxx_H, f_ = mlab.psd(s_H1, Fs = fs, NFFT = NFFT,window=psd_window, noverlap=NOVL)\n    Pxx_L, f_ = mlab.psd(s_L1, Fs = fs, NFFT = NFFT,window=psd_window, noverlap=NOVL)\n    Pxx_V, f_ = mlab.psd(s_V1, Fs = fs, NFFT = NFFT,window=psd_window, noverlap=NOVL)\n    \n    # We will use interpolations of the PSDs computed above for whitening:\n    psd_H = interp1d(f_, Pxx_H)\n    psd_L = interp1d(f_, Pxx_L)\n    psd_V = interp1d(f_, Pxx_V)    \n    \n    # Here is an approximate, smoothed PSD for H1 during O1, with no lines. We'll use it later.    \n    Pxx_ref = (1.e-22*(18.\/(0.1+f_))**2)**2+0.7e-23**2+((f_\/2000.)*4.e-23)**2\n    psd_smth = interp1d(f_, Pxx_ref) \n    \n    return Pxx_H,Pxx_L,Pxx_V,f_, psd_H,psd_L,psd_V,Pxx_ref,psd_smth\n\n\ndef plot_psd(xt, xt_gain, xt_bpf, f_min_plt=1,f_max_plt=1024,y_min=1e-27,y_max = 1e-19):\n    '''\n    return xt PSD\n    '''\n    # plot the ASDs, with the template overlaid:\n    f_min = f_min_plt #20.\n    f_max = f_max_plt #2000. \n    s_min = y_min\n    s_max = y_max\n    \n    plt.figure(figsize=(20,8))\n    plt.subplot(1,3,1)\n    Pxx_H1,Pxx_L1,Pxx_V1,freqs_,psd_H1,psd_L1,psd_V1,Pxx,psd_smooth = gen_psds(xt)\n    plt.loglog(freqs_, np.sqrt(Pxx_H1),'b',label='H1 strain')\n    plt.loglog(freqs_, np.sqrt(Pxx_L1),'r',label='L1 strain')\n    plt.loglog(freqs_, np.sqrt(Pxx_V1),'g',label='V1 strain')\n    plt.loglog(freqs_, np.sqrt(Pxx),'k',label='H1 strain, O1 smooth model')\n    plt.axis([f_min, f_max, s_min, s_max])\n    plt.grid('on')\n    plt.ylabel('ASD (strain\/rtHz)')\n    plt.xlabel('Freq (Hz)')\n    plt.legend(loc='upper center')\n    plt.title('Advanced LIGO strain (linear)')\n    \n    plt.subplot(1,3,2)\n    Pxx_g_H1,Pxx_g_L1,Pxx_g_V1,freqs_g,psd_g_H1,psd_g_L1,psd_g_V1,Pxx_g,psd_smooth_g = gen_psds(xt_gain)\n\n    plt.loglog(freqs_g, np.sqrt(Pxx_g_H1),'b',label='H1 strain')\n    plt.loglog(freqs_g, np.sqrt(Pxx_g_L1),'r',label='L1 strain')\n    plt.loglog(freqs_g, np.sqrt(Pxx_g_V1),'g',label='V1 strain')\n    plt.loglog(freqs_g, np.sqrt(Pxx_g),'k',label='H1 strain, O1 smooth model')\n    plt.axis([f_min, f_max, s_min, s_max])\n    plt.grid('on')\n    plt.ylabel('ASD (strain\/rtHz)')\n    plt.xlabel('Freq (Hz)')\n    plt.legend(loc='upper center')\n    plt.title('Advanced LIGO strain <<gain (linear)')\n    \n    plt.subplot(1,3,3)\n    Pxx_bpf_H1,Pxx_bpf_L1,Pxx_bpf_V1,freqs_b,psd_b_H1,psd_b_L1,psd_b_V1,Pxx_b,psd_smooth_b = gen_psds(xt_bpf)\n    plt.loglog(freqs_b, np.sqrt(Pxx_bpf_H1),'b',label='H1 strain')\n    plt.loglog(freqs_b, np.sqrt(Pxx_bpf_L1),'r',label='L1 strain')\n    plt.loglog(freqs_b, np.sqrt(Pxx_bpf_V1),'g',label='V1 strain')\n    plt.loglog(freqs_b, np.sqrt(Pxx_b),'k',label='H1 strain, O1 smooth model')\n    plt.axis([f_min, f_max, s_min, s_max])\n    plt.grid('on')\n    plt.ylabel('ASD (strain\/rtHz)')\n    plt.xlabel('Freq (Hz)')\n    plt.legend(loc='upper center')\n    plt.title('Advanced LIGO strain <<gain+bpf (linear)')\n    #plt.savefig(eventname+'_ASDs.'+plottype)\n    \n    return freqs_,Pxx_H1,Pxx_L1,Pxx_V1,psd_H1,psd_L1,psd_V1","5698214b":"freqs,Pxx_H1,Pxx_L1,Pxx_V1,psd_H1,psd_L1,psd_V1 = plot_psd(df0_avg, df0_avg_gain\/gain_ref, df0_avg_bpf\/gain_ref)  #scale-down >>79 for comparison","e44f74c8":"#Zoom-In\nfmin=10   #Hz\nfmax=1024 #Hz\nymin=1e-26\nymax=1e-21\nfreqs,Pxx_H1,Pxx_L1,Pxx_V1,psd_H1,psd_L1,psd_V1 = plot_psd(df0_avg, df0_avg_gain\/gain_ref, df0_avg_bpf\/gain_ref,fmin,fmax,ymin,ymax)","bf2d7e09":"df = freqs[2]-freqs[1]\n#spike at H1 and L1 around 300Hz -> bin = 300\/0.5 = 600\nspike_h1_bg = np.sqrt(Pxx_H1[550:650]).max()\nspike_l1_bg = np.sqrt(Pxx_L1[550:650]).max()\nspike_v1_bg = np.sqrt(Pxx_V1[550:650]).max()\nbin_spike_h1_bg = np.argmax(np.sqrt(Pxx_H1)==spike_h1_bg)\nbin_spike_l1_bg =np.argmax(np.sqrt(Pxx_L1)==spike_l1_bg)\nbin_spike_v1_bg =np.argmax(np.sqrt(Pxx_V1)==spike_v1_bg)\n\nprint('bin h1=',bin_spike_h1_bg,'(',bin_spike_h1_bg*df,'Hz), spike h1=', spike_h1_bg)\nprint('bin l1=',bin_spike_l1_bg,'(',bin_spike_l1_bg*df,'Hz), spike l1=', spike_l1_bg) \nprint('bin v1=',bin_spike_v1_bg,'(',bin_spike_v1_bg*df,'Hz), spike v1=', spike_v1_bg) ","6a9c99c0":"gw_ids_0=['0980247101']                             #target=0\ngw_ids_1=['00000e74ad','0920c46762','098a464da9' ]  #target=1\n\n#run_id = gw_ids_1[0]\n#file_path=[MAIN_DIR+'\/train\/0\/0\/0\/'+run_id+'.npy'] \n\nrun_id = gw_ids_1[2]\nfile_path=[MAIN_DIR+'\/train\/0\/9\/8\/'+run_id+'.npy']  \n\ntarget = train_df[train_df['id']==run_id].target    #set paths accordingly\n\nx  =  np.load(file_path[0])\n\ntarget","d7980092":"#Load DF_1 data\n'''\ni=0\nfile_path = df_1.iloc[i][\"path\"]\nf_id = df_1.iloc[i][\"id\"]\ntarget = df_1.iloc[i][\"target\"]\n\nf_id, target\n\nx  =  np.load(file_path)\n'''","f99f9e4f":"#remove df_1 background noise\n#if a signal is periodic and stationary, then the noise can be averaged down\n#if a signal is random, it's hard to say, it can be the same as background noise\n#df1_avg_bpf = avg_data(df_1, gain_ref, bpf=True, df0_avg_bpf)  #This is over the entire dataset\n\n#gain+bpf\nx2_H1_gbpf = butter_bandpass_filter(x[0,]*gain_ref, lowcut_alias, highcut_alias, fs, order=6)  #bandpass filter\nx2_L1_gbpf = butter_bandpass_filter(x[1,]*gain_ref, lowcut_alias, highcut_alias, fs, order=6)  #bandpass filter\nx2_V1_gbpf = butter_bandpass_filter(x[2,]*gain_ref, lowcut_alias, highcut_alias, fs, order=6)  #bandpass filter\n\n#gain+bpf-background\nx2_H1_gbpf_bg = x2_H1_gbpf - df0_avg_bpf[0,] #bandpass filter - background\nx2_L1_gbpf_bg = x2_L1_gbpf - df0_avg_bpf[1,] #bandpass filter - background\nx2_V1_gbpf_bg = x2_V1_gbpf - df0_avg_bpf[2,] #bandpass filter - background\n\nxt_gbpf     = np.zeros((3,4096), dtype = np.float64)  #\nxt_gbpf_bg  = np.zeros((3,4096), dtype = np.float64)  #\n\nxt_gbpf[0,],xt_gbpf[1,],xt_gbpf[2,]          = x2_H1_gbpf, x2_L1_gbpf, x2_V1_gbpf \nxt_gbpf_bg[0,],xt_gbpf_bg[1,],xt_gbpf_bg[2,] = x2_H1_gbpf_bg, x2_L1_gbpf_bg, x2_V1_gbpf_bg","85c24bfa":"x[0,:3],xt_gbpf[0,:3],xt_gbpf_bg[0,:3],x[1,:3],xt_gbpf[1,:3],xt_gbpf_bg[1,:3],x[2,:3],xt_gbpf[2,:3],xt_gbpf_bg[2,:3]","be046d6f":"plot_time_domain_dat(x,xt_gbpf\/gain_ref ,xt_gbpf_bg\/gain_ref)     #scale down for comparison\n#plot_time_domain_dat(x*gain_ref, xt_gbpf ,xt_gbpf_bg)            #scale up ","d919107d":"if (run_id == '098a464da9'):\n    #Ring-down\n    plt.figure(figsize=(20,4))\n    plt.plot(xt_gbpf[0,3150:3550])\n    plt.plot(xt_gbpf[1,3150:3550])\n    plt.plot(xt_gbpf[2,3150:3550])\n    plt.legend(['H1','L1','V1'])\n    plt.xticks(np.arange(0,400,10))\n    plt.grid()","c24601cd":"if (run_id == '098a464da9'):\n    #find peaks, time-domain corr is more accurate\n    h1_pk=np.argmax(np.abs(xt_gbpf[0,3150:3550]))\n    l1_pk=np.argmax(np.abs(xt_gbpf[1,3150:3550]))\n    v1_pk=np.argmax(np.abs(xt_gbpf[2,3150:3550]))\n\n    #freq at sample 3150,  0.1387 sec prior to ringdown (H1)\n    f_h1_3150 = fs\/60  #60 samples in one period\n    f_l1_3150 = fs\/60\n    f_v1_3150 = fs\/60\n    \n    #max freq, last cycle prior to ringdown \n    f_h1_max = fs\/(h1_pk-264)  \n    f_l1_max = fs\/(l1_pk-271)\n    f_v1_max = fs\/(v1_pk-316)\n\n    #count 4 cycles before and after their peaks,\n    h1_4cycles_before = h1_pk-162  #samples\n    l1_4cycles_before = l1_pk-180  #samples\n    v1_4cycles_before = v1_pk-215  #samples\n    #4 cycles after peaks\n    h1_4cycles_after = 318-h1_pk  #samples\n    l1_4cycles_after = 318-l1_pk  #samples\n    v1_4cycles_after = 368-v1_pk  #samples\n    print('h1_peak=',h1_pk,' l1_peak=',l1_pk,' v1_peak=',v1_pk)\n    #h1_pk,l1_pk,v1_pk,h1_4cycles_before,l1_4cycles_before,v1_4cycles_before,h1_4cycles_after,l1_4cycles_after,v1_4cycles_after","c54b9f75":"if (run_id == '098a464da9'):\n    #ramp-up dominant freq at sample 3150, 284\/2048 = 0.1387 sec prior to ringdown(H1)\n    print('dominant freq at sample 3150 H1 =',f_h1_3150,'(Hz)')\n    print('dominant freq at sample 3150 L1 =',f_l1_3150,'(Hz)')\n    print('dominant freq at sample 3150 V1 =',f_v1_3150,'(Hz)')\n    print('')\n    print('dominant max freq  H1 =',f_h1_max,'(Hz)')\n    print('dominant max freq  L1 =',f_l1_max,'(Hz)')\n    print('dominant max freq  V1 =',f_v1_max,'(Hz)')\n    print('')\n    print('Ramp up avg 4 cycles dominant freq prior to ringdown H1 =',4*fs\/h1_4cycles_before,'(Hz)')\n    print('Ramp up avg 4 cycles dominant freq prior to ringdown L1 =',4*fs\/l1_4cycles_before,'(Hz)')\n    print('Ramp up avg 4 cycles dominant freq prior to ringdown V1 =',4*fs\/v1_4cycles_before,'(Hz)')\n    print('')\n    print('Ringdown 4 cycles  H1 =',h1_4cycles_after\/fs,'(sec)')\n    print('Ringdown 4 cycles  L1 =',l1_4cycles_after\/fs,'(sec)')\n    print('Ringdown 4 cycles  V1 =',v1_4cycles_after\/fs,'(sec)')\n    print('')\n    print('delay between L1 and H1 peak = ', (l1_pk-h1_pk)\/fs,'(sec)')\n    print('delay between L1 and V1 peak = ', (v1_pk-l1_pk)\/fs,'(sec)')","a86707b2":"#Zoom-In\nfmin=10   #Hz\nfmax=1024 #Hz\nymin=1e-25\nymax=1e-20\n\n#freqs,Pxx_H1,Pxx_L1,Pxx_V1,psd_H1,psd_L1,psd_V1 = plot_psd(x,xt_gbpf\/gain_ref,xt_gbpf_bg\/gain_ref)  #scale-down, full spectrum\nfreqs,Pxx_H1,Pxx_L1,Pxx_V1,psd_H1,psd_L1,psd_V1 = plot_psd(x.copy(),xt_gbpf.copy()\/gain_ref,xt_gbpf_bg.copy()\/gain_ref,fmin,fmax,ymin,ymax)  #scale-down\n#freqs,Pxx_H1,Pxx_L1,Pxx_V1,psd_H1,psd_L1,psd_V1 = plot_psd(x*gain_ref,xt_gbpf,xt_gbpf_bg,fmin,fmax,1e-1,1e4)  #scale-up","5f9da7ec":"df = freqs[2]-freqs[1]\nprint('num of freq bins =',len(freqs),', bin per Hz=', df)  #freq resolution of 0.5Hz","45e1da7f":"#spike at H1 and L1 around 300Hz -> bin = 300\/0.5 = 600\nspike_h1 = np.sqrt(Pxx_H1[550:650]).max()\nspike_l1 = np.sqrt(Pxx_L1[550:650]).max()\nspike_v1 = np.sqrt(Pxx_V1[550:650]).max()\nbin_spike_h1 = np.argmax(np.sqrt(Pxx_H1)==spike_h1)\nbin_spike_l1 =np.argmax(np.sqrt(Pxx_L1)==spike_l1)\nbin_spike_v1 =np.argmax(np.sqrt(Pxx_V1)==spike_v1)\n\nprint('bin h1=',bin_spike_h1,'(',bin_spike_h1*df,'Hz), spike h1=', spike_h1)\nprint('bin l1=',bin_spike_l1,'(',bin_spike_l1*df,'Hz), spike l1=', spike_l1) \nprint('bin v1=',bin_spike_v1,'(',bin_spike_v1*df,'Hz), spike v1=', spike_v1) \n#simultaneous occurred at normal modes of vibration of the suspended mirrors(305Hz)","809289c4":"BNS_range = 1\nif BNS_range:\n    #-- compute the binary neutron star (BNS) detectability range\n\n    #-- choose a detector noise power spectrum:\n    f = freqs.copy()\n    # get frequency step size\n    df = f[2]-f[1]\n\n    #-- constants\n    # speed of light:\n    clight = 2.99792458e8                # m\/s\n    # Newton's gravitational constant\n    G = 6.67259e-11                      # m^3\/kg\/s^2 \n    # one parsec, popular unit of astronomical distance (around 3.26 light years)\n    parsec = 3.08568025e16               # m\n    # solar mass\n    MSol = 1.989e30                      # kg\n    # solar mass in seconds (isn't relativity fun?):\n    tSol = MSol*G\/np.power(clight,3)     # s\n    # Single-detector SNR for detection above noise background: \n    SNRdet = 8.\n    # conversion from maximum range (horizon) to average range:\n    Favg = 2.2648\n    # mass of a typical neutron star, in solar masses:\n    mNS = 1.4\n\n    # Masses in solar masses\n    m1 = m2 = mNS    \n    mtot = m1+m2  # the total mass\n    eta = (m1*m2)\/mtot**2  # the symmetric mass ratio\n    mchirp = mtot*eta**(3.\/5.)  # the chirp mass (FINDCHIRP, following Eqn 3.1b)\n\n    # distance to a fiducial BNS source:\n    dist = 1.0                           # in Mpc\n    Dist =  dist * 1.0e6 * parsec \/clight # from Mpc to seconds\n\n    # We integrate the signal up to the frequency of the \"Innermost stable circular orbit (ISCO)\" \n    R_isco = 6.      # Orbital separation at ISCO, in geometric units. 6M for PN ISCO; 2.8M for EOB \n    # frequency at ISCO (end the chirp here; the merger and ringdown follow) \n    f_isco = 1.\/(np.power(R_isco,1.5)*np.pi*tSol*mtot)\n    # minimum frequency (below which, detector noise is too high to register any signal):\n    f_min = 20. # Hz\n    # select the range of frequencies between f_min and fisco\n    fr = np.nonzero(np.logical_and(f > f_min , f < f_isco))\n    # get the frequency and spectrum in that range:\n    ffr = f[fr]\n\n    # In stationary phase approx, this is htilde(f):  \n    # See FINDCHIRP Eqns 3.4, or 8.4-8.5 \n    htilde = (2.*tSol\/Dist)*np.power(mchirp,5.\/6.)*np.sqrt(5.\/96.\/np.pi)*(np.pi*tSol)\n    htilde *= np.power(np.pi*tSol*ffr,-7.\/6.)\n    htilda2 = htilde**2\n\n    # loop over the detectors\n    dets = ['H1', 'L1']\n    for det in dets:\n        if det is 'L1': sspec = Pxx_L1.copy()\n        else:           sspec = Pxx_H1.copy()\n        sspecfr = sspec[fr]\n        # compute \"inspiral horizon distance\" for optimally oriented binary; FINDCHIRP Eqn D2:\n        D_BNS = np.sqrt(4.*np.sum(htilda2\/sspecfr)*df)\/SNRdet\n        # and the \"inspiral range\", averaged over source direction and orientation:\n        R_BNS = D_BNS\/Favg\n        print(det+' BNS inspiral horizon = {0:.1f} Mpc, BNS inspiral range   = {1:.1f} Mpc'.format(D_BNS,R_BNS))","895fd9ea":"def get_specgram(strain, sample_rate, window_size, step_size,log=False, eps=1e-10):   \n    nperseg = window_size  #samples\n    noverlap = step_size   #samples\n    freqs, times, spec = signal.spectrogram(strain,\n                                    fs=sample_rate,\n                                    #window='hann',      \n                                    window=scp.signal.windows.tukey(nperseg,alpha=1.\/4),\n                                    nperseg=nperseg,   #win_len\n                                    noverlap=noverlap, #win_no_overlap\n                                    detrend=False)\n    spec = np.abs(spec)  #(freq129,time241)\n    if log:\n        return freqs, times, np.log(spec.astype(np.float32) + eps)\n    else:\n        return freqs, times, spec.astype(np.float64)\n\n\n    \ndef plot_spec(x_time_domain, f_min_plt=0,f_max_plt=1024, f_min_prj =0 ):\n    #  plot the whitened data, zooming in on the signal region:\n\n    # pick a shorter FTT time interval, like 1\/16 of a second:\n    #NFFT = int(fs\/16.0)\n    NFFT = int(fs\/8.0)         #256\n    # and with a lot of overlap, to resolve short-time features:\n    NOVL = int(NFFT*15\/16.0)   #240\n    window = np.hanning(NFFT)     #np.blackman(NFFT)\n    #window=scp.signal.windows.tukey(window_len,alpha=1.\/4)\n    spec_cmap='viridis'           #'ocean'  #\n    \n    f_min_plt = f_min_plt   #Hz\n    f_max_plt = f_max_plt   #Hz\n    f_min_prj = f_min_prj   #bin -> bin* Hz\/bin\n    f_max_prj = 129   #bin\n    \n    strn_H1 = x_time_domain[0]\n    strn_L1 = x_time_domain[1]\n    strn_V1 = x_time_domain[2]\n    \n    # Plot the H1 spectrogram  \n    plt.figure(figsize=(20,4))\n    plt.subplot(1,3,2)\n    #spec_H1, freqs, bins, im = plt.specgram(strn_H1, NFFT=NFFT, Fs=fs, window=window,noverlap=NOVL, cmap=spec_cmap)\n    freqs, t_sec, spec_H1 = get_specgram(strn_H1, fs, NFFT, NOVL)\n    #plt.imshow(spec_H1, aspect='auto', origin='lower', extent=[t_sec.min(), t_sec.max(), freqs.min(), freqs.max()])\n    clip_H1 = np.clip(spec_H1, spec_H1.min(), spec_H1.min()+1e8*abs(spec_H1.min()))     # clip values for display only\n    plt.imshow(clip_H1, aspect='auto', origin='lower', extent=[t_sec.min(), t_sec.max(), freqs.min(), freqs.max()])\n    plt.ylabel('Frequency (Hz)')\n    plt.colorbar()\n    plt.axis([0, 2, f_min_plt, f_max_plt])\n    plt.xlabel('time (sec)')\n    plt.title('LIGO H1 strain (linear)') \n    \n    proj_H1_t = np.sum(spec_H1, axis=0)\n    proj_H1_f = np.sum(spec_H1.T, axis=0)\n    #freqs[1]   in 8Hz perbin\n    #f_min_prj = 5   # bin5*(freqs[2]-freqs[1]) = 40Hz\n    #per time-segment = 2.\/(NOVL+1)  in sec\n    \n    #plt.savefig('H1_spectrogram.') \n    plt.subplot(1,3,1)\n    plt.plot(freqs[f_min_prj:f_max_prj], proj_H1_f[f_min_prj:f_max_prj])\n    plt.ylabel('| Strain | ')\n    plt.xlabel('Frequency (Hz)')\n    plt.grid()\n    plt.subplot(1,3,3)\n    plt.plot( np.arange(0,2,2.\/(NOVL+1)),proj_H1_t)\n    plt.ylabel('| Strain |')\n    plt.xlabel('time (sec)')\n    plt.grid()\n    \n    # Plot the L1 spectrogram\n    plt.figure(figsize=(20,4))\n    plt.subplot(1,3,2)\n    #spec_L1, freqs, bins, im = plt.specgram(strn_L1, NFFT=NFFT, Fs=fs, window=window,noverlap=NOVL, cmap=spec_cmap)\n    freqs, t_sec, spec_L1 = get_specgram(strn_L1, fs,NFFT, NOVL)\n    #plt.imshow(spec_L1, aspect='auto', origin='lower', extent=[t_sec.min(), t_sec.max(), freqs.min(), freqs.max()])\n    clip_L1 = np.clip(spec_L1, spec_L1.min(), spec_L1.min()+1e8*abs(spec_L1.min()))     # clip values for display only\n    plt.imshow(clip_L1, aspect='auto', origin='lower', extent=[t_sec.min(), t_sec.max(), freqs.min(), freqs.max()])\n    plt.ylabel('Frequency (Hz)')\n    plt.xlabel('time (sec)')\n    plt.colorbar()\n    plt.axis([0, 2, f_min_plt, f_max_plt])\n    plt.title('LIGO L1 strain (linear)')    \n    proj_L1_t = np.sum(spec_L1, axis=0)\n    proj_L1_f = np.sum(spec_L1.T, axis=0)\n\n    #plt.savefig('L1_spectrogram.') \n    plt.subplot(1,3,1)\n    plt.plot(freqs[f_min_prj:f_max_prj],proj_L1_f[f_min_prj:f_max_prj])\n    plt.ylabel('| Strain |')\n    plt.xlabel('Frequency (Hz)')\n    plt.grid()\n    plt.subplot(1,3,3)\n    plt.plot(np.arange(0,2,2.\/(NOVL+1)), proj_L1_t)\n    plt.ylabel('| Strain |')\n    plt.xlabel('time (sec)')\n    plt.grid()\n    \n    # Plot the V1 spectrogram\n    plt.figure(figsize=(20,4))\n    plt.subplot(1,3,2)\n    #spec_V1, freqs, bins, im = plt.specgram(strn_V1, NFFT=NFFT, Fs=fs, window=window,noverlap=NOVL, cmap=spec_cmap) \n    freqs, t_sec, spec_V1 = get_specgram(strn_V1,fs,NFFT, NOVL)\n    #plt.imshow(spec_V1, aspect='auto', origin='lower', extent=[t_sec.min(), t_sec.max(), freqs.min(), freqs.max()])\n    clip_V1 = np.clip(spec_V1, spec_V1.min(), spec_V1.min()+1e8*abs(spec_V1.min()))     # clip values for display only\n    plt.imshow(clip_V1, aspect='auto', origin='lower', extent=[t_sec.min(), t_sec.max(), freqs.min(), freqs.max()])\n    proj_V1_t = np.sum(spec_V1, axis=0)\n    proj_V1_f = np.sum(spec_V1.T, axis=0)\n    plt.ylabel('Frequency (Hz)')\n    plt.xlabel('time (sec)')\n    plt.colorbar()\n    plt.axis([0, 2, f_min_plt, f_max_plt])\n    plt.title('VIRGO V1 strain (linear)')\n    #plt.savefig('V1_spectrogram.')\n    plt.subplot(1,3,1)\n    plt.plot(freqs[f_min_prj:f_max_prj],proj_V1_f[f_min_prj:f_max_prj])\n    plt.ylabel('| Strain |')\n    plt.xlabel('Frequency (Hz)')\n    plt.grid()\n    plt.subplot(1,3,3)\n    plt.plot(np.arange(0,2,2.\/(NOVL+1)), proj_V1_t)\n    plt.ylabel('| Strain |')\n    plt.xlabel('time (sec)')\n    plt.grid()\n    return spec_H1,spec_L1,spec_V1","e158216b":"# function to whiten data\ndef whiten(strain, interp_psd, dt, phase_shift=0, time_shift=0):\n    Nt = len(strain)\n    freqs = np.fft.rfftfreq(Nt, dt)  #freq resolution is 0.5Hz perbin.\n    \n    # whitening: transform to freq domain,  divide by square root of psd, then transform back, \n    # taking care to get normalization right.\n    hf = np.fft.rfft(strain)  #  \n    # apply time and phase shift\n    hf = hf * np.exp(-1.j * 2 * np.pi * time_shift * freqs - 1.j * phase_shift)\n    print('DC bin =', hf[0], ', Nyquist bin =', hf[-1:])\n    \n    # DC = bin0, brute-force to zero\n    hf[0] = 0     #\n    #hf[1:40] can be linearly interpolate down from 20Hz to DC, y=mx+c, where m is the average slope at bin38-42.\n    \n    # Nyquist = bin2048, brute-force to zero. If DC is non-zero then Nyquist is also non-zero.\n    hf[-1:] = 0   #\n    #hf[2040:2047] can be linearly weighted down from 1020Hz to Nyquist, slope=avg bin2038-2042 from complex number.\n   \n    print('lower band-edge', np.abs(hf[:4]))\n    print('upper band-edge', np.abs(hf[-4:]))\n    \n    norm = 1.\/np.sqrt(1.\/(dt*2))  #0.03125\n    white_hf = hf \/ np.sqrt(interp_psd(freqs)) * norm \n    \n    #Nyquist strain = 1\/N X(N\/2) [cos(n*pi)+ sin(n*pi)]. sin(n*pi)=0 for any integer n. Brute-force X(N\/2)=0.\n    #if Nyquist is none zero, this will create random DC spikes in time-domain with toggle signs\n    white_ht = np.fft.irfft(white_hf, n=Nt) \n    return white_ht","f1573a5f":"time = 1\/fs *np.arange(0, np.shape(x)[1])  #4096\ndt   = time[2]-time[1]   #uniform sample =  0.00048828125 sec\n\ndef whiten_bpf(xt,delta_t,remove_bg=False):\n    \n    #this is aliasing filter\n    bb6, ab6 = butter(6, [fband_alias[0]*2.\/fs, fband_alias[1]*2.\/fs], btype='band')  #bpf  \n    xt[0,] = filtfilt(bb6, ab6, xt[0,]*gain_ref) #scale-up, <<79, since df0_avg_bpf is scale-up\n    xt[1,] = filtfilt(bb6, ab6, xt[1,]*gain_ref) #scale-up, <<79\n    xt[2,] = filtfilt(bb6, ab6, xt[2,]*gain_ref) #scale-up, <<79\n    \n    if remove_bg:\n        #remove background noise(df0_avg_gain)\n        Pxx_H1,Pxx_L1,Pxx_V1,freqs, psd_H1,psd_L1,psd_V1,Pxx_ref,psd_smooth = gen_psds(xt - df0_avg_bpf) #have to match aliasing filter\n        #Pxx_H1,Pxx_L1,Pxx_V1,freqs, psd_H1,psd_L1,psd_V1,Pxx_ref,psd_smooth = gen_psds(xt - df0_avg_gain) #if no aliasing bpf filter  \n    else:\n        Pxx_H1,Pxx_L1,Pxx_V1,freqs, psd_H1,psd_L1,psd_V1,Pxx_ref,psd_smooth = gen_psds(xt)  #with background noise\n    \n    # now whiten the data from H1 and L1, and the template (use H1 PSD):\n    strain_H1_whiten = whiten(xt[0,],psd_H1,delta_t)\n    strain_L1_whiten = whiten(xt[1,],psd_L1,delta_t)\n    strain_V1_whiten = whiten(xt[2,],psd_V1,delta_t)\n    \n    #bb4, ab4 = butter(4, [25*2.\/fs, 500*2.\/fs], btype='band')\n    #normalization = np.sqrt((500-25)\/(fs\/2))\n    bb4, ab4 = butter(order_bpf, [fband[0]*2.\/fs, fband[1]*2.\/fs], btype='band')\n    normalization = np.sqrt((fband[1]-fband[0])\/(fs\/2))\n    strain_H1_whitenbp = filtfilt(bb4, ab4, strain_H1_whiten.copy()) \/ normalization\n    strain_L1_whitenbp = filtfilt(bb4, ab4, strain_L1_whiten.copy()) \/ normalization\n    strain_V1_whitenbp = filtfilt(bb4, ab4, strain_V1_whiten.copy()) \/ normalization\n    \n    #Notch out frequency of the normal modes of vibration of the suspended mirrors, \n    #frequency of the electric network. This is done after whitening, otherwise whitening will bring them back up\n    #strain_H1_whitenbp = notch_filter_data(strain_H1_whitenbp,notch_coefs)\n    #strain_L1_whitenbp = notch_filter_data(strain_L1_whitenbp,notch_coefs)\n    #strain_V1_whitenbp = notch_filter_data(strain_V1_whitenbp,notch_coefs)\n    \n    strain_whiten  = np.zeros((3,4096), dtype = np.float64)  #\n    strain_whiten[0,],strain_whiten[1,],strain_whiten[2,] = strain_H1_whiten,strain_L1_whiten,strain_V1_whiten\n    \n    strain_whitenbp  = np.zeros((3,4096), dtype = np.float64)  #\n    strain_whitenbp[0,],strain_whitenbp[1,],strain_whitenbp[2,] = strain_H1_whitenbp,strain_L1_whitenbp,strain_V1_whitenbp\n    return strain_whiten, strain_whitenbp","6bc0d33f":"#There are 2 BPFs, the first BPF is an aliasing filter. All signal went through the first aliasing BPF.  The Second BPF is for strain BPF.\n\n#Signal is BPF(aliasing) without removing background Spectrum first.\n#Whiten\n\n#strain_x_whiten <- First BPF_alias then whiten and return\n#strain_x_whitenbp <- First BPF_alias then whiten then BPF_strain and return\nstrain_x_whiten, strain_x_whitenbp = whiten_bpf(x.copy(),dt)  #with background noise","a89ed196":"#Plot time-domain signals, raw, whiten, whiten BPF_alias\nplot_time_domain_dat(x, strain_x_whiten, strain_x_whitenbp)","e43f9941":"x[0,:3], strain_x_whiten[0,:3], strain_x_whitenbp[0,:3], \\\nx[1,:3], strain_x_whiten[1,:3], strain_x_whitenbp[1,:3], \\\nx[2,:3], strain_x_whiten[2,:3], strain_x_whitenbp[2,:3]","9004ac48":"#Original raw data Spectrum\n\n#Full Spectrum plot\nspec_H1,spec_L1,spec_V1 = plot_spec(x.copy(),f_min_plt=0,f_max_plt=1024, f_min_prj =0 )","012e167e":"#Original raw data Spectrum\n\n#Zoom-In Spectrum plot\n#f_min_plt=40 Hz on spectrogram\n#f_max_plt=500 Hz on spectrogram\n#f_min_prj = 5 , this is bin5, each bin is 8Hz, so bin5 = 40Hz project onto freq axis\nspec_H1,spec_L1,spec_V1 = plot_spec(x.copy(),f_min_plt=40,f_max_plt=1024, f_min_prj =5 )","13d4bfe7":"#freq-domain\nproj_H1_t = np.sum(spec_H1, axis=0)  #sum over 2sec of data, ringdown is from 1.67sec\nproj_H1_f = np.sum(spec_H1.T, axis=0)\nproj_L1_t = np.sum(spec_L1, axis=0)\nproj_L1_f = np.sum(spec_L1.T, axis=0)\nproj_V1_t = np.sum(spec_V1, axis=0)\nproj_V1_f = np.sum(spec_V1.T, axis=0)\n\nf_min_prj = 0\nf_max_prj = 129\nt_min=0\nt_max=0.5\nplt.figure(figsize=(20,6))\nplt.plot( proj_H1_f*1e42)\nplt.plot(proj_L1_f*1e42)\nplt.plot(proj_V1_f*1e42)\nplt.grid('on')\nplt.xticks(np.arange(f_min_prj,f_max_prj, 5.0))\nplt.axis([f_min_prj, f_max_prj, t_min, t_max])\nplt.xlabel('Freq (x 8Hz)')\nplt.legend(['H1','L1','V1'])","af8da20e":"df_8Hz = 8.   #8Hz per bin\nf_min,f_max = 3,129  #search for very strong low freq strain, ignore below bin3 -> 24Hz\nspike_h1 = np.max(proj_H1_f[f_min:f_max],axis=0)\nspike_l1 = np.max(proj_L1_f[f_min:f_max],axis=0)\nspike_v1 = np.max(proj_V1_f[f_min:f_max],axis=0)\nbin_spike_h1 = np.argmax(proj_H1_f==spike_h1)\nbin_spike_l1 =np.argmax(proj_L1_f==spike_l1)\nbin_spike_v1 =np.argmax(proj_V1_f==spike_v1)\nprint('bin h1=',(bin_spike_h1),'(',(bin_spike_h1)*df_8Hz,'Hz), spike h1=', spike_h1)\nprint('bin l1=',(bin_spike_l1),'(',(bin_spike_l1)*df_8Hz,'Hz), spike l1=', spike_l1) \nprint('bin v1=',(bin_spike_v1),'(',(bin_spike_v1)*df_8Hz,'Hz), spike v1=', spike_v1) ","3fc7c9ec":"f_min,f_max = int(300\/df_8Hz),int(350\/df_8Hz)  #search 250Hz to 350Hz (visible at H1)\nspike_h1 = np.max(proj_H1_f[f_min:f_max],axis=0)\nspike_l1 = np.max(proj_L1_f[f_min:f_max],axis=0)\nspike_v1 = np.max(proj_V1_f[f_min:f_max],axis=0)\nbin_spike_h1 = np.argmax(proj_H1_f==spike_h1)\nbin_spike_l1 =np.argmax(proj_L1_f==spike_l1)\nbin_spike_v1 =np.argmax(proj_V1_f==spike_v1)\nprint('bin h1=',(bin_spike_h1),'(',(bin_spike_h1)*df_8Hz,'Hz), spike h1=', spike_h1)\nprint('bin l1=',(bin_spike_l1),'(',(bin_spike_l1)*df_8Hz,'Hz), spike l1=', spike_l1) \nprint('bin v1=',(bin_spike_v1),'(',(bin_spike_v1)*df_8Hz,'Hz), spike v1=', spike_v1) ","d05351ea":"#search for freq close to Nyquist, \n#ringdown creates transient and looking for potential aliasing signals\nf_min,f_max = int(700\/df_8Hz),int(1024\/df_8Hz)  #search 700Hz to 1024Hz\nspike_h1 = np.max(proj_H1_f[f_min:f_max],axis=0)\nspike_l1 = np.max(proj_L1_f[f_min:f_max],axis=0)\nspike_v1 = np.max(proj_V1_f[f_min:f_max],axis=0)\nbin_spike_h1 = np.argmax(proj_H1_f==spike_h1)\nbin_spike_l1 =np.argmax(proj_L1_f==spike_l1)\nbin_spike_v1 =np.argmax(proj_V1_f==spike_v1)\nprint('bin h1=',(bin_spike_h1),'(',(bin_spike_h1)*df_8Hz,'Hz), spike h1=', spike_h1)\nprint('bin l1=',(bin_spike_l1),'(',(bin_spike_l1)*df_8Hz,'Hz), spike l1=', spike_l1) \nprint('bin v1=',(bin_spike_v1),'(',(bin_spike_v1)*df_8Hz,'Hz), spike v1=', spike_v1) \nprint('')\nprint('potential aliasing bin at:')\nprint('alias bin h1=',(128-bin_spike_h1),'(',(128-bin_spike_h1)*df_8Hz,'Hz)')\nprint('alias bin l1=',(128-bin_spike_l1),'(',(128-bin_spike_l1)*df_8Hz,'Hz)')\nprint('alias bin v1=',(128-bin_spike_v1),'(',(128-bin_spike_v1)*df_8Hz,'Hz)') ","143f2f17":"#Whiten Original data Spectrum\n# strain_x_whiten <- First BPF_alias then whiten and return\n\n#Zoom-In Spectrum plot\n#f_min_plt=40 Hz on spectrogram\n#f_max_plt=500 Hz on spectrogram\n#f_min_prj = 5 , this is bin5, each bin is 8Hz, so bin5 = 40Hz project onto freq axis\nspec_H1,spec_L1,spec_V1 = plot_spec(strain_x_whiten.copy(),f_min_plt=8,f_max_plt=1024, f_min_prj =1)","1c64885c":"#freq-domain, whiten\nproj_H1_t = np.sum(spec_H1, axis=0)\nproj_H1_f = np.sum(spec_H1.T, axis=0)\nproj_L1_t = np.sum(spec_L1, axis=0)\nproj_L1_f = np.sum(spec_L1.T, axis=0)\nproj_V1_t = np.sum(spec_V1, axis=0)\nproj_V1_f = np.sum(spec_V1.T, axis=0)\n\nf_min_prj = 0\nf_max_prj = 129\nt_min=0\nt_max=2\nplt.figure(figsize=(20,4))\nplt.plot( proj_H1_f) #*1e46)\nplt.plot(proj_L1_f) #*1e46)\nplt.plot(proj_V1_f) #*1e46)\nplt.grid('on')\nplt.xticks(np.arange(f_min_prj,f_max_prj, 5.0))\nplt.axis([f_min_prj, f_max_prj, t_min, t_max])\nplt.xlabel('Freq (x 8Hz)')\nplt.legend(['H1','L1','V1'])","4c8209d7":"#time-domain, whiten\nt_min_prj = 0\nt_max_prj = len(proj_H1_t)\nt_min=0\nt_max=45.0 #35\nplt.figure(figsize=(20,4))\nplt.plot( proj_H1_t) #*1e45)\nplt.plot(proj_L1_t) #*1e45)\nplt.plot(proj_V1_t) #*1e45)\nplt.grid('on')\nplt.xticks(np.arange(t_min_prj,t_max_prj, 5.0))\nplt.axis([t_min_prj, t_max_prj, t_min, t_max])\nplt.xlabel('Time segment (x 8.3 ms)')   #each time-segment = 2sec\/241 = 0.008299 sec\nplt.legend(['H1','L1','V1'])","d7212064":"#L1 strain \nsine_period=53-29 #time_segment\n# len(proj_H1_t) = 241 time-segment in 2 sec, each time-segment = 2\/241 = 0.008299 sec\nprint('estimated sine wave freq=', 241.\/(sine_period*2),'Hz')","ddce4171":"#Whiten BPF_strain data Spectrum\n#strain_x_whitenbp <- First BPF_alias then whiten then BPF_strain and return\n\n#Zoom-IN Spectrum plot\nspec_H1_bp,spec_L1_bp,spec_V1_bp = plot_spec(strain_x_whitenbp.copy(),f_min_plt=16,f_max_plt=1024, f_min_prj =2 )","d7a44926":"#freq-domain\nproj_H1_bp_t = np.sum(spec_H1_bp, axis=0)\nproj_H1_bp_f = np.sum(spec_H1_bp.T, axis=0)\nproj_L1_bp_t = np.sum(spec_L1_bp, axis=0)\nproj_L1_bp_f = np.sum(spec_L1_bp.T, axis=0)\nproj_V1_bp_t = np.sum(spec_V1_bp, axis=0)\nproj_V1_bp_f = np.sum(spec_V1_bp.T, axis=0)\n\nf_min_prj = 0\nf_max_prj = 129\nt_min=0\nt_max=2.5\nplt.figure(figsize=(20,6))\nplt.plot( proj_H1_bp_f) #*1e48)\nplt.plot(proj_L1_bp_f) #*1e48)\nplt.plot(proj_V1_bp_f) #*1e48)\nplt.grid('on')\nplt.xticks(np.arange(f_min_prj,f_max_prj, 5.0))\nplt.axis([f_min_prj, f_max_prj, t_min, t_max])\nplt.xlabel('Freq (x 8Hz)')\nplt.legend(['H1','L1','V1'])","63b3e9cf":"#There are 2 BPFs, the first BPF is an aliasing filter. All signals went through the first aliasing BPF.  The Second BPF is for strain BPF.\n#Signal is BPF(aliasing) first then remove background noise\n\n#strain_x_whiten_nobg <- First BPF_alias then remove background then whiten and return\n#strain_x_whitenbp_nobg <- First BPF_alias then remove background then whiten then BPF_strain and return\nstrain_x_whiten_nobg, strain_x_whitenbp_nobg = whiten_bpf(x.copy(),dt,remove_bg=True)  #no background","c63510c1":"#time-domain plot\nplot_time_domain_dat(x*gain_ref, strain_x_whiten_nobg, strain_x_whitenbp_nobg)\nx[0,:3], strain_x_whiten_nobg[0,:3], strain_x_whitenbp_nobg[0,:3], \\\nx[1,:3], strain_x_whiten_nobg[1,:3], strain_x_whitenbp_nobg[1,:3], \\\nx[2,:3], strain_x_whiten_nobg[2,:3], strain_x_whitenbp_nobg[2,:3]","ecb1f7e4":"#freq-domain plot\n#strain_x_whiten_nobg <- First BPF_alias then remove background then whiten and return\n\n#Full Spectrum plot with removed background\nspec_H1_nobg,spec_L1_nobg,spec_V1_nobg = plot_spec(strain_x_whiten_nobg.copy())\n\n#Zoom-In with removed background\nspec_H1_nobg,spec_L1_nobg,spec_V1_nobg = plot_spec(strain_x_whiten_nobg.copy(),f_min_plt=40,f_max_plt=1024, f_min_prj =12 )","6e64b918":"#freq-domain\nproj_H1_t = np.sum(spec_H1_nobg, axis=0)\nproj_H1_f = np.sum(spec_H1_nobg.T, axis=0)\nproj_L1_t = np.sum(spec_L1_nobg, axis=0)\nproj_L1_f = np.sum(spec_L1_nobg.T, axis=0)\nproj_V1_t = np.sum(spec_V1_nobg, axis=0)\nproj_V1_f = np.sum(spec_V1_nobg.T, axis=0)\n\nf_min_prj = 0\nf_max_prj = 129\nt_min=0\nt_max=4\nplt.figure(figsize=(20,6))\nplt.plot( proj_H1_f) #*1e48)\nplt.plot(proj_L1_f) #*1e48)\nplt.plot(proj_V1_f) #*1e48)\nplt.grid('on')\nplt.xticks(np.arange(f_min_prj,f_max_prj, 5.0))\nplt.axis([f_min_prj, f_max_prj, t_min, t_max])\nplt.xlabel('Freq (x 8Hz)')\nplt.legend(['H1','L1','V1'])","f59339cf":"df_8Hz = 8.   #8Hz per bin\nf_min,f_max = 120,129\nspike_h1 = np.max(proj_H1_f[f_min:f_max],axis=0)\nspike_l1 = np.max(proj_L1_f[f_min:f_max],axis=0)\nspike_v1 = np.max(proj_V1_f[f_min:f_max],axis=0)\nbin_spike_h1 = np.argmax(proj_H1_f==spike_h1)\nbin_spike_l1 =np.argmax(proj_L1_f==spike_l1)\nbin_spike_v1 =np.argmax(proj_V1_f==spike_v1)\nprint('bin h1=',(bin_spike_h1),'(',(bin_spike_h1)*df_8Hz,'Hz), spike h1=', spike_h1)\nprint('bin l1=',(bin_spike_l1),'(',(bin_spike_l1)*df_8Hz,'Hz), spike l1=', spike_l1) \nprint('bin v1=',(bin_spike_v1),'(',(bin_spike_v1)*df_8Hz,'Hz), spike v1=', spike_v1) ","7e438260":"#time-domain\nt_min_prj = 0\nt_max_prj = len(proj_H1_t)\nt_min=0\nt_max=35 #0.08\nplt.figure(figsize=(20,4))\nplt.plot( proj_H1_t) #*1e45)\nplt.plot(proj_L1_t) #*1e45)\nplt.plot(proj_V1_t) #*1e45)\nplt.grid('on')\nplt.xticks(np.arange(t_min_prj,t_max_prj, 5.0))\nplt.axis([t_min_prj, t_max_prj, t_min, t_max])\nplt.xlabel('Time segment (x 8.3 ms)')   #each time-segment = 2sec\/241 = 0.008299 sec\nplt.legend(['H1','L1','V1'])","b9c25e2a":"#sq_period=65-30  #time_segment\nh1_sine_period =95-67\nl1_sine_period =53-27\n#v1_sine_period =63-27\n\n#modulation wave\n#h1_mod_period =228-12\n#l1_mod_period =229-12\n#v1_mod_period =232-8\n\n# len(proj_H1_t) = 241 time-segment in 2 sec, each time-segment = 2\/241 = 0.008299 sec\n#print('square wave freq=', 241.\/(sq_period*2),'Hz,','sine wave freq=', 241.\/(sine_period*2),'Hz')\nprint('H1,','estimate sine wave freq=', 241.\/(h1_sine_period*2),'Hz', 'more than one sine wave with damping')\nprint('L1,','estimate sine wave freq=', 241.\/(l1_sine_period*2),'Hz', 'more than one sine wave with damping')\n#print('V1,','sine wave freq=', 241.\/(v1_sine_period*2),'Hz', 'with damping')\nprint('V1, heavily damped')\n#print('')\n#print('H1,','modulation wave freq=', 241.\/(h1_mod_period*2),'Hz')\n#print('L1,','modulation wave freq=', 241.\/(l1_mod_period*2),'Hz')\n#print('V1,','modulation wave freq=', 241.\/(v1_mod_period*2),'Hz')","b9167963":"#strain_x_whitenbp_nobg <- First BPF_alias then remove background then whiten then BPF_strain and return\n\n#Zoom-In strain BPF with removed background\nspec_H1_bpbg,spec_L1_bpbg,spec_V1_bpbg = plot_spec(strain_x_whitenbp_nobg,f_min_plt=16,f_max_plt=1024, f_min_prj =2 )","8a03f9a9":"#Freq-domain\nproj_H1_t = np.sum(spec_H1_bpbg, axis=0)\nproj_H1_f = np.sum(spec_H1_bpbg.T, axis=0)\nproj_L1_t = np.sum(spec_L1_bpbg, axis=0)\nproj_L1_f = np.sum(spec_L1_bpbg.T, axis=0)\nproj_V1_t = np.sum(spec_V1_bpbg, axis=0)\nproj_V1_f = np.sum(spec_V1_bpbg.T, axis=0)\n\nf_min_prj = 0\nf_max_prj = 129\nt_min=0\nt_max=2\nplt.figure(figsize=(20,6))\nplt.plot( proj_H1_f,'b')\nplt.plot(proj_L1_f,'r')\nplt.plot(proj_V1_f,'g')\nplt.grid('on')\nplt.xticks(np.arange(f_min_prj,f_max_prj, 5.0))\nplt.axis([f_min_prj, f_max_prj, t_min, t_max])\nplt.xlabel('Freq (x 8Hz)')\nplt.legend(['H1','L1','V1'])","191e0354":"df_8Hz = 8.   #8Hz per bin\nf_min,f_max = 3,10  #ignore bin3 below -> 24Hz\nspike_h1 = np.max(proj_H1_f[f_min:f_max],axis=0)\nspike_l1 = np.max(proj_L1_f[f_min:f_max],axis=0)\nspike_v1 = np.max(proj_V1_f[f_min:f_max],axis=0)\nbin_spike_h1 = np.argmax(proj_H1_f==spike_h1)\nbin_spike_l1 =np.argmax(proj_L1_f==spike_l1)\nbin_spike_v1 =np.argmax(proj_V1_f==spike_v1)\nprint('bin h1=',(bin_spike_h1),'(',(bin_spike_h1)*df_8Hz,'Hz), spike h1=', spike_h1)\nprint('bin l1=',(bin_spike_l1),'(',(bin_spike_l1)*df_8Hz,'Hz), spike l1=', spike_l1) \nprint('bin v1=',(bin_spike_v1),'(',(bin_spike_v1)*df_8Hz,'Hz), spike v1=', spike_v1) ","6110e67f":"f_min,f_max = 115,129  #bins\nspike_h1 = np.max(proj_H1_f[f_min:f_max],axis=0)\nspike_l1 = np.max(proj_L1_f[f_min:f_max],axis=0)\nspike_v1 = np.max(proj_V1_f[f_min:f_max],axis=0)\nbin_spike_h1 = np.argmax(proj_H1_f==spike_h1)\nbin_spike_l1 =np.argmax(proj_L1_f==spike_l1)\nbin_spike_v1 =np.argmax(proj_V1_f==spike_v1)\nprint('bin h1=',(bin_spike_h1),'(',(bin_spike_h1)*df_8Hz,'Hz), spike h1=', spike_h1)\nprint('bin l1=',(bin_spike_l1),'(',(bin_spike_l1)*df_8Hz,'Hz), spike l1=', spike_l1) \nprint('bin v1=',(bin_spike_v1),'(',(bin_spike_v1)*df_8Hz,'Hz), spike v1=', spike_v1) ","453e2661":"#time-domain\nt_min_prj = 0\nt_max_prj = len(proj_H1_t)\nt_min=0\nt_max=0.7 #0.002\nplt.figure(figsize=(20,4))\nplt.plot( proj_H1_t,'b')\nplt.plot(proj_L1_t,'r')\nplt.plot(proj_V1_t,'g')\nplt.grid('on')\nplt.xticks(np.arange(t_min_prj,t_max_prj, 5.0))\nplt.axis([t_min_prj, t_max_prj, t_min, t_max])\nplt.xlabel('Time segment (x 8.3 ms)')   #each time-segment = 2sec\/241 = 0.008299 sec\nplt.legend(['H1','L1','V1'])","98866ab4":"print('ringdown at', 202*0.0083,'sec')   #compare to time-domain raw signal 2*3434\/4096 = 1.67 sec","e5437789":"#Freq-domain\nf_min_prj = 0\nf_max_prj = 129\n\n#normalize for comparison\nmax_h1_bp_bg = max(proj_H1_bp_f)\nmax_l1_bp_bg = max(proj_L1_bp_f)\nmax_v1_bp_bg = max(proj_V1_bp_f)\nmax_h1_bp_nobg = max(proj_H1_f)\nmax_l1_bp_nobg = max(proj_L1_f)\nmax_v1_bp_nobg = max(proj_V1_f)\n\nproj_H1_bp_bg_f = proj_H1_bp_f\/max_h1_bp_bg\nproj_H1_bp_nobg_f = proj_H1_f\/max_h1_bp_nobg\nproj_L1_bp_bg_f = proj_L1_bp_f\/max_l1_bp_bg\nproj_L1_bp_nobg_f = proj_L1_f\/max_l1_bp_nobg\nproj_V1_bp_bg_f = proj_V1_bp_f\/max_v1_bp_bg\nproj_V1_bp_nobg_f = proj_V1_f\/max_v1_bp_nobg\n\nsf_Hmin=min(min(proj_H1_bp_bg_f),min(proj_H1_bp_nobg_f))\nsf_Hmax=0.002 #0.002\nsf_Lmin=min(min(proj_L1_bp_bg_f),min(proj_L1_bp_nobg_f))\nsf_Lmax=0.002 #0.002\nsf_Vmin=min(min(proj_V1_bp_bg_f),min(proj_V1_bp_nobg_f))\nsf_Vmax=0.002 #0.002\n\nif (run_id == '098a464da9'):\n    sf_Hmin=min(min(proj_H1_bp_bg_f),min(proj_H1_bp_nobg_f))\n    sf_Hmax=1 \n    sf_Lmin=min(min(proj_L1_bp_bg_f),min(proj_L1_bp_nobg_f))\n    sf_Lmax=1\n    sf_Vmin=min(min(proj_V1_bp_bg_f),min(proj_V1_bp_nobg_f))\n    sf_Vmax=1    \n    \nplt.figure(figsize=(20,14))\nplt.subplot(3,2,1)\nplt.plot( proj_H1_bp_bg_f,'b')\nplt.plot( proj_H1_bp_nobg_f,'k--')\nplt.grid('on')\nplt.xticks(np.arange(f_min_prj,f_max_prj, 5.0))\nplt.axis([f_min_prj, f_max_prj, sf_Hmin, sf_Hmax])\n#plt.xlabel('Freq (x 8Hz)')\nplt.legend(['H1','H1 no-bg'])\n\nplt.subplot(3,2,3)\nplt.plot( proj_L1_bp_bg_f,'r')\nplt.plot( proj_L1_bp_nobg_f,'k--')\nplt.grid('on')\nplt.xticks(np.arange(f_min_prj,f_max_prj, 5.0))\nplt.axis([f_min_prj, f_max_prj, sf_Lmin, sf_Lmax])\n#plt.xlabel('Freq (x 8Hz)')\nplt.legend(['L1','L1 no-bg'])\n\nplt.subplot(3,2,5)\nplt.plot( proj_V1_bp_bg_f,'g')\nplt.plot( proj_V1_bp_nobg_f,'k--')\nplt.grid('on')\nplt.xticks(np.arange(f_min_prj,f_max_prj, 5.0))\nplt.axis([f_min_prj, f_max_prj, sf_Vmin, sf_Vmax])\nplt.xlabel('Freq (x 8Hz)')\nplt.legend(['V1','V1 no-bg'])\n\n#time-domain\nt_min_prj = 0\nt_max_prj = len(proj_H1_t)\n\n#normalize for comparison\nmax_h1_bp_bg = max(proj_H1_bp_t)\nmax_l1_bp_bg = max(proj_L1_bp_t)\nmax_v1_bp_bg = max(proj_V1_bp_t)\nmax_h1_bp_nobg = max(proj_H1_t)\nmax_l1_bp_nobg = max(proj_L1_t)\nmax_v1_bp_nobg = max(proj_V1_t)\n\nproj_H1_bp_bg_t = proj_H1_bp_t\/max_h1_bp_bg\nproj_H1_bp_nobg_t = proj_H1_t\/max_h1_bp_nobg\nproj_L1_bp_bg_t = proj_L1_bp_t\/max_l1_bp_bg\nproj_L1_bp_nobg_t = proj_L1_t\/max_l1_bp_nobg\nproj_V1_bp_bg_t = proj_V1_bp_t\/max_v1_bp_bg\nproj_V1_bp_nobg_t = proj_V1_t\/max_v1_bp_nobg\n\nst_Hmin=min(min(proj_H1_bp_bg_t),min(proj_H1_bp_nobg_t))\nst_Hmax=0.005 #0.002 #0.002\nst_Lmin=min(min(proj_L1_bp_bg_t),min(proj_L1_bp_nobg_t))\nst_Lmax=0.01 #0.002 #0.002\nst_Vmin=min(min(proj_V1_bp_bg_t),min(proj_V1_bp_nobg_t))\nst_Vmax=0.1 #0.002 #0.002\n\nif (run_id == '098a464da9'):\n    st_Hmin=min(min(proj_H1_bp_bg_t),min(proj_H1_bp_nobg_t))\n    st_Hmax=0.6 \n    st_Lmin=min(min(proj_L1_bp_bg_t),min(proj_L1_bp_nobg_t))\n    st_Lmax=0.6 \n    st_Vmin=min(min(proj_V1_bp_bg_t),min(proj_V1_bp_nobg_t))\n    st_Vmax=0.6    \n    \nplt.subplot(3,2,2)\nplt.plot( proj_H1_bp_bg_t,'b')\nplt.plot( proj_H1_bp_nobg_t,'k--')\nplt.grid('on')\nplt.xticks(np.arange(t_min_prj,t_max_prj, 10.0))\nplt.axis([t_min_prj, t_max_prj, st_Hmin, st_Hmax])\nplt.legend(['H1','H1 no-bg'])\n\nplt.subplot(3,2,4)\nplt.plot( proj_L1_bp_bg_t,'r')\nplt.plot( proj_L1_bp_nobg_t,'k--')\nplt.grid('on')\nplt.xticks(np.arange(t_min_prj,t_max_prj, 10.0))\nplt.axis([t_min_prj, t_max_prj, st_Lmin, st_Lmax])\nplt.legend(['L1','L1 no-bg'])\n\nplt.subplot(3,2,6)\nplt.plot( proj_V1_bp_bg_t,'g')\nplt.plot( proj_V1_bp_nobg_t,'k--')\nplt.grid('on')\nplt.xticks(np.arange(t_min_prj,t_max_prj, 10.0))\nplt.axis([t_min_prj, t_max_prj, st_Vmin, st_Vmax])\nplt.xlabel('Time segment (x 8.3 ms)')   #each time-segment = 2sec\/241 = 0.008299 sec\nplt.legend(['V1','V1 no-bg'])","77cf6d18":"#strain_x_whiten, strain_x_whitenbp\nstrain_h = strain_x_whiten[0,] #\nstrain_l = strain_x_whiten[1,] #\nstrain_v = strain_x_whiten[2,] #","6bc85db5":"df_fil = pd.DataFrame(index=time)\n\ndf_fil['H1']=strain_h\ndf_fil['L1']=strain_l\ndf_fil['V1']=strain_v","3cb8bcab":"def movingaverage (values, window):\n    weights = np.repeat(1.0, window)\/window\n    sma = np.convolve(values, weights, 'valid')\n    sma = [values[0]]*(window-1)+sma.tolist()\n    return sma\n\nfor ord in [5,10,15,50]:\n    strain_h_mva = movingaverage(strain_h, window=ord)\n    strain_l_mva = movingaverage(strain_l, window=ord)\n    strain_v_mva = movingaverage(strain_l, window=ord)\n    df_fil['H1_mva_'+str(ord)]=strain_h_mva\n    df_fil['L1_mva_'+str(ord)]=strain_l_mva\n    df_fil['V1_mva_'+str(ord)]=strain_v_mva","9b5db6cc":"lowcut, highcut = fband\nprint('Base frequency', fs, 'Band frequency will be applied. Retaining signal between in the range:',lowcut, highcut, 'Hz')","e752dcb3":"for ord in [4,5,6]:\n    strain_h_filtered = butter_bandpass_filter(strain_h, lowcut, highcut, fs, order=ord)\n    strain_l_filtered = butter_bandpass_filter(strain_l, lowcut, highcut, fs, order=ord)\n    strain_v_filtered = butter_bandpass_filter(strain_v, lowcut, highcut, fs, order=ord)\n    df_fil['H1_band_'+str(ord)]=strain_h_filtered\n    df_fil['L1_band_'+str(ord)]=strain_l_filtered\n    df_fil['V1_band_'+str(ord)]=strain_v_filtered\n    \n    \n#for i in [1,2,3]:\n#Aliasing filter\n#    strain_h_filtered = butter_bandpass_filter(strain_h, lowcut_alias, highcut_alias, fs, order=6)\n#    strain_l_filtered = butter_bandpass_filter(strain_l, lowcut_alias, highcut_alias, fs, order=6)\n#    strain_v_filtered = butter_bandpass_filter(strain_v, lowcut_alias, highcut_alias, fs, order=6)\n#strain bpf\n#    strain_h_filtered = butter_bandpass_filter(strain_h_filtered, i*lowcut, highcut-i*200, fs, order=4)\n#    strain_l_filtered = butter_bandpass_filter(strain_l_filtered, i*lowcut, highcut-i*200, fs, order=4)\n#    strain_v_filtered = butter_bandpass_filter(strain_v_filtered, i*lowcut, highcut-i*200, fs, order=4)\n#    df_fil['H1_band_'+str(i)]=strain_h_filtered\n#    df_fil['L1_band_'+str(i)]=strain_l_filtered\n#    df_fil['V1_band_'+str(i)]=strain_v_filtered    ","4f55ddfb":"#https:\/\/github.com\/ibm-watson-data-lab\/ibmseti\n#https:\/\/github.com\/ibm-watson-data-lab\/ibmseti\/blob\/master\/ibmseti\/features.py\n#https:\/\/github.com\/ibm-watson-data-lab\/ibmseti\/blob\/master\/ibmseti\/features.py#L188-L282\n# Copyright (c) 2017 IBM. All rights reserved.\n\n#import scipy.stats\n#import math\n\ndef seti_entropy(p, w):\n    if w is None:\n        w = np.ones(len(p))\n    h_p = np.sum([-x[0]*math.log(x[0]\/x[1]) if x[0] else 0 for x in zip(p, w)])\n    h_max = math.log(np.sum(w))\n    return h_p, h_max\n\ndef entropy(signal):\n        '''\n        function returns entropy of a signal\n        signal must be a 1-D numpy array\n        '''\n        lensig=signal.size\n        symset=list(set(signal))\n        numsym=len(symset)\n        propab=[np.size(signal[signal==i])\/(1.0*lensig) for i in symset]\n        ent=np.sum([p*np.log2(1.0\/p) for p in propab])\n        return ent\t\n    \ndef seti_difference(arr, n=1, axis=0, **kwargs):\n    return np.diff(arr, n=n, axis=axis, **kwargs)\n\ndef seti_projection(arr, axis=0, **kwargs):\n    return np.sum(arr, axis=axis, **kwargs)\n\ndef seti_moment(arr, moment=1, axis=0, **kwargs):\n    return sp.moment(arr, moment=moment, axis=axis, **kwargs)\n\ndef first_order_gradient(arr, axis=0):\n    grad_arr = seti_difference(arr, n=1, axis=axis)\n    return np.insert(grad_arr, grad_arr.shape[axis], 0, axis=axis)\n\ndef seti_total_variation(arr):\n    return np.sum(np.abs(np.diff(arr, axis=0)), axis=0)\n\ndef maximum_variation(arr):\n    return np.max(arr, axis=0) - np.min(arr, axis=0)\n\ndef tv_2d_isotropic(grad_0_arr, grad_1_arr):\n    return np.sqrt(grad_0_arr**2 + grad_1_arr**2).sum()\n\ndef seti_entropy(p, w):\n    if w is None:\n        w = np.ones(len(p))\n        \n    h_p = np.sum([-x[0]*math.log(x[0]\/x[1]) if x[0] else 0 for x in zip(p, w)])\n    h_max = math.log(np.sum(w))\n    return h_p, h_max\n\ndef seti_asymmetry(spectrogram_L, spectrogram_R):\n    return (spectrogram_L - spectrogram_R) \/ (spectrogram_L + spectrogram_R)\n\n###############################################\n# parametric features based on the Spectrogram\n# concate with conv NN\n###############################################\ndef feat_extract(arr):\n        stats_2D_names = ['std_time', 'std_freq', 'std_time_avg', 'std_freq_avg', 'nth_moment_kurt_time', 'nth_moment_kurt_freq',\n                          'nth_moment_skew_time', 'nth_moment_skew_freq', 'nth_moment_kurt_proj_time', 'nth_moment_kurt_proj_freq',\n                          'nth_moment_skew_proj_time','nth_moment_skew_proj_freq', 'tv_for_each_frequency', 'tv', 'fourth_mom',\n                          'variance','excess_kurtosis','p','h_p','h_max','h_normal','max_var_t','max_var_f']\n        data = arr          #\n        \n        #Standard Deviation of the projection of the spectrogram onto the time and frequency axis.\n        std_time = math.sqrt(seti_moment( seti_projection(data, axis=1), moment=2))   #scalar\n        std_freq = math.sqrt(seti_moment( seti_projection(data, axis=0), moment=2))   #scalar\n       \n        #Average Standard Deviation of the spectrogram along each slice of the time and frequency axis.\n        std_time_avg = np.mean(np.sqrt(seti_moment( data, axis=0, moment=2)))\n        std_freq_avg = np.mean(np.sqrt(seti_moment( data, axis=1, moment=2)))\n\n        #Average N-th moment of the spectrogram along each slice of the time and frequency axis.\n        N = 3 #kurtosis \n        nth_moment_kurt_time = np.mean( seti_moment( data, axis=0, moment=N))\n        nth_moment_kurt_freq = np.mean( seti_moment( data, axis=1, moment=N))\n        \n        N = 4 #skewness\n        nth_moment_skew_time = np.mean( seti_moment( data, axis=0, moment=N))\n        nth_moment_skew_freq = np.mean( seti_moment( data, axis=1, moment=N))\n        \n        #N-th moment of the projection of the spectrogram onto the time and frequency axis.\n        N = 3 #kurtosis\n        nth_moment_kurt_proj_time = seti_moment( seti_projection(data, axis=1), moment=N)\n        nth_moment_kurt_proj_freq = seti_moment( seti_projection(data, axis=0), moment=N)\n        \n        N = 4 #skewness\n        nth_moment_skew_proj_time = seti_moment( seti_projection(data, axis=1), moment=N)\n        nth_moment_skew_proj_freq = seti_moment( seti_projection(data, axis=0), moment=N)  \n        \n        #Mean Total Variation (along the time axis) of the spectrogram.\n        tv_for_each_frequency = seti_total_variation(data)\n        tv = np.mean( tv_for_each_frequency )\n        \n        #Excess Kurtosis\n        #Measures the non-guassianity of a distribution. Could be measure after projecting a spectrogram onto it's frequency-axis.\n        fourth_mom = seti_moment( seti_projection(data, axis=0), moment=4)  \n        variance = seti_moment( seti_projection(data, axis=0), moment=2)    \n        excess_kurtosis = fourth_mom\/variance - 3\n            \n        #Entropy (based on histogram of log of power)\n        # Computes the entropy for a discrete probability distribution function, as\n        # represented by a histogram, `p`, with bin sizes `w`,\n        \n        #may set the range equal to the range of the values in the spectrogram\n        max_binning = int(data.max()) + 2  #add 1 to round up, and one to set the right bin edge.\n        \n        bin_edges = range(0,501)\n        #bin_edges = range(0,max_binning)\n        # histogram represents an estimate of the probability distribution function of the observed power in the spectrogram.\n        p, _ = np.histogram(np.clip(data.flatten(), 0, max_binning), bins=bin_edges, density=True)\n        w = np.diff(bin_edges)\n        h_p, h_max = seti_entropy(p,w)\n        h_normal = h_p \/ h_max  #h_normal should range between 0 and 1.\n        # if `p` is a completely flat PDF (a uniform distribution), then\n        #the normalized entropy will equal 1, indicating maximum amount of disorder.\n        #(This is easily shown for the case where w_i = 1.)\n        #If the `p_i` is zero for all i except j and p_j = 1, then the entropy will be 0, indicating no disorder.\n        #For a completely flat distribution, there will only be one bin. If the\n        #data contains significant variation in power levels, the Bayesian Block method will produce morebins.\n        #print(np.shape(data), np.shape(h_normal))\n        \n        #Mean First Difference (along the time axis) of the spectrogram.\n        #fd_mean_along_time = np.mean(first_diff_along_time, axis=0).mean() \n        #fd_mean_along_freq = np.mean(first_diff_along_freq, axis=1).mean()\n\n        #same as first_diff_along_time.mean() because each element of the array is the same size!\n        #the average of the averages is the same as the total average if the sets of averages all have the same cardinality\n        \n        #N-th moment of the first difference\n        N = 2 #variation\n        N = 3 #kurtosis \n        N = 4 #skewness\n        #nth_moment_time = np.mean( moment( first_diff_along_time, axis=0, moment=N))\n        #nth_moment_freq = np.mean( moment( first_diff_along_freq, axis=1, moment=N))     \n\n        #Maximum Variation\n        #This can be calculated for the spectrogram, or for the first-difference, or gradient, along the time- or frequency-axis.\n        max_var_t = np.max(seti_difference(data, axis=0), axis=0)   #241\n        max_var_f = np.max(seti_difference(data, axis=1), axis=1)   #129\n        \n        #Asymmetry\n        #It may be useful to examine the asymmetry of the signal measured in the L and R polarization components. The asymmetry is defined as\n        #spect_L = arr[0,]\n        #spect_R = arr[1,]\n        #A = (spect_L - spect_R) \/ (spect_L + spect_R)\n        \n        #Summation of Polarities\n        #It may be useful to examine the full signal in both polarities by summing them together\n        #S = spect_L + spect_R\n        values = [len(stats_2D_names)]\n        values.append(std_time)\n        values.append(std_freq)\n        values.append(std_time_avg)\n        values.append(std_freq_avg)\n        values.append(nth_moment_kurt_time)\n        values.append(nth_moment_kurt_freq)\n        values.append(nth_moment_skew_time)\n        values.append(nth_moment_skew_freq)\n        values.append(nth_moment_kurt_proj_time)\n        values.append(nth_moment_kurt_proj_freq)\n        values.append(nth_moment_skew_proj_time)\n        values.append(nth_moment_skew_proj_freq)\n        values.append(tv_for_each_frequency)\n        values.append(tv)\n        values.append(fourth_mom)\n        values.append(variance)\n        values.append(excess_kurtosis)\n        values.append(p)\n        values.append(h_p)\n        values.append(h_max)\n        values.append(h_normal)\n        values.append(max_var_t)\n        values.append(max_var_f)\n       \n        return values, stats_2D_names","69521cee":"def percentiles_all(x, iqr=True, amplitude=True, percentiles_list=[5, 10, 25, 40, 50, 60, 75, 90, 95]):\n    names = ['p_' + str(p) for p in percentiles_list]\n    if iqr and 25 in percentiles_list and 75 in percentiles_list:\n        names.append('iqr')\n    if amplitude and 1 in percentiles_list and 99 in percentiles_list:\n        names.append('perc_amp')\n    if len(x) == 0:\n        values = [0 for i in range(len(names))]\n        return values, names\n    if len(percentiles_list) > 0 and all([0 < q < 100 for q in percentiles_list]):\n        values = list(np.percentile(x, percentiles_list))\n    else:\n        values = []\n    if iqr:\n        q1 = percentiles_list.index(25)\n        q3 = percentiles_list.index(75)\n        values.append(values[q3] - values[q1])\n    if amplitude and 1 in percentiles_list and 99 in percentiles_list:\n        q1 = percentiles_list.index(1)\n        q3 = percentiles_list.index(99)\n        values.append(values[q3] - values[q1])\n    return values, names\n\n\ndef stats_calculate_all(x):\n    stats_all_names = ['len', 'min', 'max', 'range', 'mean', 'hmean', 'gmean', 'var', 'std', 'skew', 'kurtosis',\n                       'median', 'mode', 'energy', 'energy_sample', 'snr']\n\n    xnp = np.array(x)\n    n = len(x)\n    if n == 0:\n        values = [0 for i in range(len(stats_all_names))]\n        return values, stats_all_names\n    values = [n]\n    vmin = float(min(xnp))\n    if vmin < 1:\n        offset = 1 + abs(vmin)\n    else:\n        offset = 0\n    vmax = float(max(xnp))\n    vrange = vmax - vmin\n    vmean = float(np.mean(xnp))\n    vstd = float(np.std(xnp))\n    venergy = float(sum(np.array(xnp) ** 2))\n    venergy_sample = venergy \/ n\n    snr = 0.0\n    if vstd != 0:\n        snr = vmean \/ vstd\n    values.append(vmin)\n    values.append(vmax)\n    values.append(vrange)\n    values.append(vmean)\n    values.append(float(sp.hmean(xnp + offset)))\n    values.append(float(sp.gmean(xnp + offset)))\n    values.append(vstd ** 2)\n    values.append(vstd)\n    values.append(sp.skew(xnp))\n    values.append(sp.kurtosis(xnp))\n    values.append(np.median(xnp))\n    \n    vmode = sp.mode(xnp)\n    vmode = float(vmode[0][0])\n    values.append(vmode)\n    values.append(venergy)\n    values.append(venergy_sample)\n    values.append(snr)\n    return values, stats_all_names","d5d467bb":"H1_feat_2D, stats_2D_names = feat_extract(spec_H1) #129x241\nL1_feat_2D, stats_2D_names = feat_extract(spec_L1) #129x241\nV1_feat_2D, stats_2D_names = feat_extract(spec_V1) #129x241","dd9d1bc3":"max_binning = int(spec_H1.max()) + 2\n#bin_edges = range(0,max_binning)\nbin_edges = range(0,501)\np, _ = np.histogram(np.clip(spec_H1.flatten(), 0, max_binning), bins=bin_edges, density=True)\n#w = np.diff(bin_edges)\n#h_p, h_max = seti_entropy(p,w)\n#h_normal = h_p \/ h_max  ","46f82e8d":"plt.plot(spec_H1.flatten()),","394711c0":"plt.plot(p)","295c448a":"#entrp = entropy(spec_H1.flatten())\n#entrp","aa4d942c":"values_perc_h, names_perc_h = percentiles_all(strain_h_filtered)\nvalues_perc_l, names_perc_l = percentiles_all(strain_l_filtered)\nvalues_perc_v, names_perc_v = percentiles_all(strain_v_filtered)","c4bbc304":"values_stats_h, stats_all_names_h = stats_calculate_all(strain_h_filtered)\nvalues_stats_l, stats_all_names_l = stats_calculate_all(strain_l_filtered)\nvalues_stats_v, stats_all_names_v = stats_calculate_all(strain_v_filtered)","570703f2":"BBH range is >> BNS range!\n\nNOTE that, since mass is the source of gravity and thus also of gravitational waves, systems with higher masses (such as the binary black hole merger GW150914) are much \"louder\" and can be detected to much higher distances than the BNS range. \n\nWhitening\n\nWe can \"whiten\" the data (dividing it by the noise amplitude spectrum, in the fourier domain), suppressing the extra noise at low frequencies and at the spectral lines, to better see the weak signals in the most sensitive band.\n\nWhitening is always one of the first steps in astrophysical data analysis (searches, parameter estimation). Whitening requires no prior knowledge of spectral lines, etc; only the data are needed.\n\nTo get rid of remaining high frequency noise, we will also bandpass the data.\n\nThe resulting time series is no longer in units of strain; now in units of \"sigmas\" away from the mean.\n","89391509":"**3. Average DF_0 Background Noise**","6ba2ee16":"**11. Comparing whiten data with removed Background Noise**","1bc76414":"**8. Whitening without removing Background Noise**","4e83c154":"**5. DF_1 Removed Background Noise**","1d7ffebb":"**10. Whitening with Removed Background Noise**","a33e2e59":"Ramp up freq is the average of 4 cycles dominant freq(67.14Hz) prior to ringdown. H1 is slowest.\n\nRingdown 4 cycles time(16.6ms).","d9409b0d":"Freq-domain PSD plot:\n\nLeft figure shows the high strain at low freq above O1 smooth model(GW150914). Middle and right figures are BPF. Low freq and high freq near Nyquist(1024 Hz) are attenuated.\n\nPeak spikes simultaneously occurred at normal modes of vibration(305Hz) of the suspended mirrors! If you see them, it may not be GW but still can't rule out it is not a GW event, even though the background noises are also at the same peaks at H1 and L1.  Simulated dataset happens all the time.","6010243d":"Can't really tell transient creates white noise in the region 1.67sec to 2sec and freq below 300Hz.","5fba2cb9":"Visual inspection: for all strains to be above threshold 0.5.  My guess is GW at 32Hz(dominant) and 1000Hz(weak).  BPF highcut_alias is at 1020Hz.","d57e6520":"\nhttps:\/\/www.gw-openscience.org\/static\/speclines\/o2\/comb_list_O2V_pers0.3_commented.txt\n\n![image.png](attachment:681546e5-a207-427c-a337-e583817621cf.png)\n\nBelow f_min = 20 Hz, the data are not properly calibrated. The noise is so high below f_min that LIGO cannot sense gravitational wave strain from astrophysical sources in that band.\n","0cc9ce54":"Whiten Spectrogram","07eaf830":"**13. Feature Extraction**","127d41fd":"**1.0 Explore Numericals**","18d37658":"**14. Summary:**\n\nThis is the summary of id=098a464da9, the merger dominant freq is 34Hz, the delay between L1 and V1 peaks is about 23.9ms[33-35].  GW emission peaks at this phase. Ringdown lasts about 16.6ms.  Ringdown creates a transient which produces white noise.  I did two additional runs, one with high_cut_alias set to 400Hz to remove the high freq signal.  The other runs by setting low_cut_alias to 300Hz to remove the low freq signal. Additional runs are not shown in the plots.\n\nWhitening function[41]:\n- I found that DC and Nyquist are non-zero, I brute-force them to zero. IFFT with non-zero Nyquist\u2019s  bin will result in DC spikes in time-domain signal. \n\nThe time-domain whiten signal[44] before BPF_strain:\n- Is symmetrical about its center.  \n- It looks like a damped sinusoidal wave. \n- High_cut_alias(400Hz). The whiten signal has impulses at 500 samples intervals, which is 4Hz.  First impulse has the highest strain, then gradually reduces on the sub-sequence impulses. It reaches the minimum at sample 2048, then gradually increases its strain again on the sub-sequence impulses. \n- Low_cut_alias(300Hz). The whiten signal has high freq bursts of 4Hz period with 90% duty cycle.\n- It could be that there are two noise sources at 4Hz.\n\nThe freq-domain whiten signal before BPF_strain:\n- There are 2 versions of this, one in whitening function[41] which has freq resolution of 0.5Hz and spectrogram version[49, 51] that projects onto freq-domain which has freq resolution of 8Hz.\n- Searching for signal freq that is close to Nyquist found H1(1000Hz), L1(952Hz), V1(944Hz) and by calculation, corresponding aliases at H1(24Hz), L1(72Hz), V1(80Hz) respectively.\n- High_cut_alias(400Hz). To prove aliasing, filtered-out high freq signal, then there shouldn\u2019t be any low freq peaks at H1(24Hz), L1(72Hz), V1(80Hz).  If there exists a high peak, then it\u2019s noise sources.\n- Low_cut_alias(300Hz).  In both cases, there are no differences, they all have high peaks below 80Hz, similar characteristics in [48]. I could not draw any aliasing conclusion based on these observations. I think I\u2019ve probed at the wrong place, should have probed before whitening.  \n\nThe whiten signal after BPF_strain:\n- without removing background noise, time-domain(proj_H1\/L1\/V1_bp_t, data only)[57], spectrogram[56], and freq-domain[57] plots.\n- with removing background noise, time-domain[69], spectrogram[65], and freq-domain[66] plots.\n- Overlaid time[57,69]\/freq[57,69] domain plot[71].\n- The frequencies that are common to the background noise, their strains were either reduced or increased. Is it good or bad? I can\u2019t really tell.\n\nBased on [66,68] plots, my guess is GW at 34Hz(dominant) and 1000Hz(weak). The two additional runs, all 4Hz pulses are synchronized in H1,L1, and V1. Same observations in spectrogram projection onto time-domain, 4Hz are aligned.  These led me to believe it\u2019s a pulsar. \n\n","71042f01":"**7. BNS_range**","a3bb389e":"13a. Spectrogram Feature Extraction","76da9bcf":"2a. Band Pass(Butterworth) Filter","15a54c3e":"Time-domain:\nThe ringdown is at time-segments 200-213.\n\nFreq-domain:\nThe frequencies that are common to the background noise, their strains were either reduced or increased. Is it good or bad, i don't know, only the domain expert can tell. \n\nFor example L1. Bin50(400Hz) with background noise removed(dashed black), the peak is reduced, whereas bin80(640Hz), bin85(680Hz), etc are increased w.r.t (Red line)\n\nMaybe this is good for data augmentation with or without background noise removed.  NN will focus on different freq.  The background noise df0_avg_bpf can be averaged at various subfolders and average length.","dbba3e84":"**12. Data Augmentation**\n\na) Inject noise, blip, chirp, etc from\nhttps:\/\/www.zooniverse.org\/projects\/zooniverse\/gravity-spy\/talk\/762\/926241\n\nb) Enable\/Disable notch filter, random select notch filter\n\nc) Change BPF_alias(lowcut_alias,high_cut_alias), BPF_strain(lowcut, highcut). Random set BPF corner freq.\n\nd) Enable\/Disable whitening\n\ne) Enable\/Disable background noise remover. Random average time and different subfolder.\n","6c170cd3":"4b. Freq-domain plot","ff3dc1eb":"**2. Band Pass Filter**","9f293c47":"After whitening, strains are symmetrical about the center of the time-segment frame(120).\n\nAll strains are damped. V1 is the most heavily damped. If the high_cut_alias=400Hz moves further inside the passband, all strains look like square waves at 4Hz. Same thing happens when low_cut_alias=300Hz, I see a 4Hz square wave.","af4e30d1":"I'm not a domain expert and not sure this is done correctly. Numbers seem to be very big.  It's just for my reference.  ","f37e6de5":"13b. Time-domain(1D) Feature Extraction","65ce8642":"**9. Comparing Whiten data**","4a4343cf":"6b. Freq-domain plot","36531d5d":"**6. Comparing Average DF_1**","b0b83b79":"The middle column figure is the whiten strain before BPF_strain.  The L1 is a damped sine wave, symmetry about its center. ","f5799550":"Left column figure, compare all plots\n\nMiddle column figure, strain_x_whiten <- First BPF_alias then whiten.  \n\nMiddle column figure, there are strong low freq noises because the whiten signal is before BPF_strain. By setting high_cut_alias = 400Hz, all strains have impulses on every 500 samples(4Hz) intervals. The first pulse has the highest strain, then gradually reduces on subsequence pulses. It reaches the minimum at sample 2048 then gradually increases again on subsequence pulses.  Symmetry about the center. By setting low_cut_alias = 300Hz, all strains have high freq burst pulses of 4Hz with 90% duty cycle.\n\nRight column figure, strain_x_whitenbp <- First BPF_alias then whiten then BPF_strain.","46600a08":"Left figure, since BPF removed the high amplitude low freq noise, the amplitude of BPF outputs are much smaller compared to unfilter original signal.\n\nMiddle and right figures, at ringdown, a sharp decrease in amplitude is like an impulse, this will create a transient with very high frequencies.\n\nring down peak at 2*(3434\/4096) = 1.677 sec","bcc49d3a":"**4. Comparing Average DF_0**","9250cb95":"9a Time-domain plot","b0054b3e":"https:\/\/www.gw-openscience.org\/O3\/","dde0af90":"Starter EDA.  There are two bandpass filters, BPF_alias and BPF_strain [2,12].\n\nBPF_alias passband is between low_cut_alias =18Hz and high_cut_alias=1020Hz. The raw signal is scaled up and BPF_alias[42] then it is either with or without removing the average background[17]. The signal is then whiten[41], then BPF_strain. The BPF_strain passband is low_cut_strain=low_cut_alias+5 between high_cut_strain=high_cut_alias-5.\n\nThe BPF_alias serves three purposes:\n- Low_cut_alias removes the unwanted signal below 18Hz. This increases the dynamic range of the signal, especially down cast to lower precision.\n- Scaling up the signal gives the maximum float64 precision.\n- High_cut_alias prevents signal freq that is very close to Nyquist from folding back to low frequency.  When the freq is too close to Nyquist, it is difficult to prevent it from aliasing. The only way is to attenuate it. This setting is a trade-off between how much to attenuate the signal and allow aliasing.\n\nAfter BPF_alias, the signal is whiten.  To whiten the signal, its PSD is obtained and transform the signal into freq-domain by FFT it. The freq-domain signal is amplitude equalized, all the weak\/strong amplitudes are equalized to the same level.\n\nAfter whitening, the signal is BPF_strain to remove the out of band signal again since whitening equalizes it or to narrow the band of interest.  The equalized signal is then transformed back to time-domain by IFFT it.  The 1D-time-domain signal can be used for NN or 2D-spectrogram by FFT the signal segment by segment in time.  The noise analysis is based on a spectrogram by projecting it into frequency-domain and time-domain.\n\nThis notebook is about:\n\n- Averaging the background noise(target=0)\n\n- Analyze original raw time\/freq domain signal\n\n- Analyze the whiten signal before BPF_strain, aliasing, and Nyquist\u2019s DC\n- Remove signal from background noise\n- Analyze spectrograms with and without background noise removed.\n- Data augmentation\n- Feature Extraction","faafc1b5":"L1 and V1 have peaks at bin128(Nyquist). The projection onto Freq-domain has a freq resolution of 8Hz.  In the whitening function, the freq resolution is 0.5Hz. If brute-force DC=Nyquist=0 only, peaks will reappear at bin128(Nyquist) again. I've tried to brute-force hf(:8)=hf(-8:)=0 and resulted in L1, V1 peaks moving to bin126.\n\nTo minimize Nyquist's DC, the original raw data need to remove its DC and after averaging DF_0, DC is removed by subtracting its mean value.","7be45a2d":"Whiten Bandpass filter Spectrogram","08fd07c0":"For this 2 seconds instance, there is no significant difference between BPF vs (BPF-Background).","da129ac3":"https:\/\/www.astroml.org\/user_guide\/datasets.html#time-domain-data\n\n\n![image.png](attachment:b8c4ff3f-f42e-4bdc-a7a3-a38f5c3469de.png)\n\nhanning window Strain ~ 1e-44","523ce817":"Blue = H1, Red = L1, Green = V1, Black = O1 smooth Model\n\nNotice that the L1 has either a very strong vibration of the suspended mirrors spike (305Hz) or from the entire data set of event GW. df0_avg is averaged over 512 samples = 512*2\/60 = 17 mins. If each sub-folder is at the proximity of time prior or after the GW event, it can represent a non-stationary background noise.","d9373c43":"Each data sample (npy file) contains 3 time series (1 for each detector) and each spans 2 sec and is sampled at 2,048 Hz.","5193b75d":"2b. Band Pass and Notch Filters","703b1dd4":"9b. Freq-domain plot","ac6cbd02":"Not sure the whiten signal is a weak GW or equipment noise. Now you can see lots of in-band freq.  These are the strains that you want your NN to train on.","c10c1360":"This aliasing bin search is based on 2sec data projection onto freq-domain, \nand should do another search from ringdown to 2sec.","0c86136a":"Freq-domain:\n\nThe dominant freq is 34Hz.  I expect to see some white noise after 1.67sec on the spectrogram, especially freq below 300Hz. Maybe it will show up after whitening. H1 has visible strain at 300Hz. \n\nTime-domain:\n\nAt 1.67sec, L1 has the strongest strain 2e-41. V1 has strain 1.5e-42. All strains are in burst mode with fundamental freq of 4Hz.","02353588":"6a. Time-domian plot","43406596":"References:\n\nhttps:\/\/www.gw-openscience.org\/GW150914data\/LOSC_Event_tutorial_GW150914.html#Whitening\n\nhttps:\/\/github.com\/zerafachris\/g2net_2nd_training_school_malta_mar_2020\/blob\/master\/lectures\/SP_Signal_Processing_Introduction-Eftim_Zdravevski\/signal_processing_2_preparing_GW_data.ipynb\n\n","0e453d17":"1. Explore Numericals\n\n2. Band Pass Filter\n\n3. Average DF_0 Background Noise\n\n    df0_avg = average(df_0) #original data\n\n    df0_avg_gain = average(df_0 << 79 bits) #apply gain on original data\n\n    df0_avg_bpf = average( BPF(df_0 << 79 bits) ) #Band pass filter\n\n4. Comparing Average DF_0\n\n    4a. Time-domain plot\n\n    comparing df0_avg vs (df0_avg_gain >>79) vs (df_0_avg_bpf>>79)\n\n    4b. Freq-domain plot\n\n    comparing df0_avg vs (df0_avg_gain >>79) vs (df_0_avg_bpf>>79)\n\n5. DF_1 Removed Background Noise\n\n    xt_gbpf = BPF(df_1 <<79) #Band pass filter df_1\n\n    xt_gbpf_bg = xt_gbpf - df0_avg_bpf #Removed background noise\n\n6. Comparing Average DF_1\n\n    6a. Time-domain plot\n\n    comparing x(original) vs (xt_gbpf >>79) vs (xt_gbpf_bg>>79)\n\n    6b. Freq-domain plot\n\n    comparing x(original) vs (xt_gbpf >>79) vs (xt_gbpf_bg>>79)\n\n7. BNS_range\n\n8. Whitening without removing Background Noise\n\n    strain_x_whiten, strain_x_whitenbp = whiten_bpf(x,dt) #with background noise\n\n    x = original data\n\n    strain_x_whiten = whiten(x)\n\n    strain_x_whitenbp = BPF(strain_x_whiten)\n\n9. Comparing whiten data without removing Background Noise\n\n    9a. Time-domain plot\n\n    comparing x(original) vs (strain_x_whiten) vs (strain_x_whitenbp)\n\n    9b. Freq-domain plot\n\n    comparing x(original) vs (strain_x_whiten ) vs (strain_x_whitenbp)\n\n10. Whitening with Removed Background Noise\n\n    strain_x_whiten_nobg, strain_x_whitenbp_nobg = whiten_bpf(x,dt,remove_bg=True)\n\n11. Comparing whiten data with removed Background Noise\n\n12. Data Augmentation\n\n13. Feature Extraction\n\n    13a. Spectrogram Feature Extraction\n\n    13b. Time-domain(1D) Feature Extraction\n    \n14. Summary","4fe7c603":"4a. Time-domian plot","331e7c35":"By setting high_cut_alias = 400Hz or low_cut_alias=300Hz, both readings are the same. In both cases, there is a square wave with the fundamental freq of 4Hz. So, I'm confused and cannot draw any conclusion about alias bin3,9 and 10.  There are all harmonics of square wave 4Hz.\n\nbin h1= 125 ( 1000.0 Hz), spike h1= 6.407776294080362e-45\n\nbin l1= 119 ( 952.0 Hz), spike l1= 5.781802511588414e-45\n\nbin v1= 118 ( 944.0 Hz), spike v1= 2.0902274858390353e-44\n\npotential aliasing bin at:\n\nalias bin h1= 3 ( 24.0 Hz)\n\nalias bin l1= 9 ( 72.0 Hz)\n\nalias bin v1= 10 ( 80.0 Hz)"}}