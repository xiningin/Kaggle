{"cell_type":{"24a1cd5c":"code","dc623724":"code","15b6eaed":"code","4df506ff":"code","0ac65767":"code","843d4869":"code","9625ff2b":"code","d12cb984":"code","27adbfa6":"code","5ae3e6b7":"code","e21115c9":"markdown","5d30e8d4":"markdown","4e299a79":"markdown","5d40ca27":"markdown","7accf547":"markdown","f8d19fc4":"markdown","dd7df719":"markdown","f2152652":"markdown","6e4a187f":"markdown","ea91050e":"markdown","fe4a72ed":"markdown","2424ef36":"markdown","0147153b":"markdown","8cc1d4e1":"markdown","b053d186":"markdown","eb1fb327":"markdown","3236fda9":"markdown"},"source":{"24a1cd5c":"my_list = []\n\nfor number in range(0, 101):\n    my_list.append(number)\n    \nprint(my_list)","dc623724":"my_list2 = [number for number in range(0, 101)]\n\nprint(my_list2)","15b6eaed":"my_list3 = [number for number in range(0, 101) if number % 2 == 0]\n\nprint(my_list3)","4df506ff":"combined = [a + b  for a in \"life\" for b in \"study\"]\n\nprint (combined)","0ac65767":"nested = [letters[1] for letters in [a + b  for a in \"life\" for b in \"study\"]]\n\nprint(nested)","843d4869":"combined = [a + b  for a in \"life\" for b in \"study\"]\nnon_nested = [letters[1] for letters in combined]\n\nprint (non_nested)","9625ff2b":"words = [\"life\",\"is\",\"study\"]\n\nword_length_dict = {}\n\nfor word in words:\n    word_length_dict[word] = len(word)\n    \nprint(word_length_dict)","d12cb984":"words = [\"life\",\"is\",\"study\"]\nword_length_dict2 = {word:len(word) for word in words}\n\nprint(word_length_dict2)","27adbfa6":"words = [\"life\",\"is\",\"study\"]\nword_lengths = [4, 2, 5]\npairs = zip(words, word_lengths)\n\nfor item in pairs:\n    print (item)","5ae3e6b7":"words = [\"life\",\"is\",\"study\"]\nword_lengths = [4, 2, 5]\n\nword_length_dict3 = {key:value for (key, value) in zip(words, word_lengths)}\n\nprint( word_length_dict3 )","e21115c9":"We could make the same dictionary using a dictionary comprehension where the key and value come first in the form key:value, followed a for clause that loops over some sequence:","5d30e8d4":"You also can nest one list comprehension inside of another:","4e299a79":"List and dictionary comprehensions provide a convenient syntax for creating lists and dictionaries more efficiently and with less code than standard loops. Once you have data loaded into numpy arrays and pandas DataFrames, however, you can often avoid looping constructs all together by using functions available in those packages that operate on data in a vectorized manner.\n\nNow that we know the basics of Python's data structures and programming constructs, the remainder of this guide will focus on data analysis. In the next lesson, we'll use Python to explore a real-world data set: records of passengers who rode aboard the RMS Titanic on its fateful maiden voyage.","5d40ca27":"You can create dictionaries quickly in one line using a syntax that mirrors list comprehensions. Consider the following dictionary that sets words as keys and their lengths as values:","7accf547":"Python prides itself on its clean, readable code and making it as simple as possible for you to do the things you want to do. Although basic control flow statements and functions have enough power to express virtually any program, Python includes many convenience functions and constructs to let you do things faster and with less code.\n\nPopulating lists and dictionaries is a common task that can be achieved with the loops we learned about in lesson 11. For instance, if we wanted to populate a list with the numbers 0 through 100, we could initialize an empty list as a container, run a for loop over the range of numbers from 0 to 100, and append each number to the list:","f8d19fc4":"## Wrap Up","dd7df719":"## Dictionary Comprehensions","f2152652":"Using zip inside a dictionary comprehension lets you extract key:value pairs from two sequences:","6e4a187f":"## Next Lesson: [Python for Data 14: Data Exploration and Cleaning](https:\/\/www.kaggle.com\/hamelg\/python-for-data-14-data-exploration-and-cleaning)\n[back to index](https:\/\/www.kaggle.com\/hamelg\/python-for-data-analysis-index)","ea91050e":"# Python for Data 13: List Comprehensions\n[back to index](https:\/\/www.kaggle.com\/hamelg\/python-for-data-analysis-index)\n","fe4a72ed":"In a list comprehension, the value that you want to append to the list come first, in this case \"number\", followed by a for statement that mirrors the one we used in the for loop version of the code. You can optionally include if clauses after the for clause to filter the results based on some logical check. For instance, we could add an if statement to filter out odd numbers:","2424ef36":"Notice that while you can nest list comprehensions to achieve a lot in a single line of code, doing so can lead to long, verbose and potentially confusing code. It is often better to avoid the temptation to create convoluted \"one-liners\" when a series of a few shorter, more readable operations will yield the same result:","0147153b":"*Note: range() creates a sequence of numbers from some specified starting number up to but not including an ending number. It also takes an optional argument for the step (counting increment) which defaults to 1.*\n\nThe code above works, but it is unnecessarily verbose. List comprehensions provide a way to do these sorts of constructions efficiently with less code.","8cc1d4e1":"In the code above we take all the numbers in the range for which the number modulus 2 (the remainder when divided by 2) is equal to zero, which returns all the even numbers in the range.\n\n*Note: You could also get even numbers in a range more by including a step argument equal to 2 such as: range(0,101,2)*\n\nIt is possible to put more than one for loop in a list comprehension, such as to construct a list from two different iterables. For instance, if we wanted to make a list of each combination of two letters in two different strings we could do it with a list comprehension over the two strings with two for clauses:","b053d186":"List comprehensions let you populate lists in one line of code by taking the logic you would normally put a for loop and moving it inside the list brackets. We can construct the same list as the one above using the following list comprehension:","eb1fb327":"## List Comprehensions","3236fda9":"It is common to create a dictionary from the items in two different ordered sequences, where one sequence contains the keys you want to use and the other sequence contains the corresponding values. You can pair the items in two sequences into tuples using the built in Python function zip():"}}