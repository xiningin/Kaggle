{"cell_type":{"ee5ad8ee":"code","dfbe1f87":"code","c6af6c87":"code","dbf2ba48":"code","689941ba":"code","09ce74eb":"code","cb56652b":"code","2c742f09":"code","eaac52ee":"code","60b30d2a":"markdown","1efa80fc":"markdown","cb719fa9":"markdown","4ca7f6c4":"markdown","62d57abb":"markdown","a91bafb1":"markdown","ce85f491":"markdown","9eef66c9":"markdown","f571d694":"markdown"},"source":{"ee5ad8ee":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport numpy as np\nimport pandas as pd\nfrom sklearn import metrics\nfrom sklearn import preprocessing\nfrom sklearn.ensemble import RandomForestClassifier, VotingClassifier, GradientBoostingClassifier\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.preprocessing import OneHotEncoder\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","dfbe1f87":"n_test= 49999\nfichero = 'datos_entrenamiento.csv'\ntests = 'entrega_para_predecir.csv'\nresultados_finales = 'resultados_finales_test.csv'\nsample = 'resultados_finales_sampleSubmission.csv'\npath_dir = '..\/input\/'","c6af6c87":"# autor: https:\/\/www.kaggle.com\/terminus7\/pokemon-challenge\ndef calculate_effectiveness(data):\n    '''\n        this function creates a new column of each pokemon's effectiveness against it's enemy.\n        every effectiveness starts with 1, if an effective type is found on enemy's type, effectiveness * 2\n        if not very effective is found on enemy's type, effectiveness \/ 2\n        if not effective is found on enemy's type, effectiveness * 0\n        This function creates 4 new columns\n            1. P1_type1, pokemon 1 first type effectiveness against the enemy's type\n            2. P1_type2, pokemon 1 second type effectiveness against the enemy's type\n            3. P2_type1, pokemon 2 first type effectiveness against the enemy's type\n            4. P2_type2, pokemon 2 second type effectiveness against the enemy's type\n    '''\n\n    very_effective_dict = {'Normal': [],\n                           'Fighting': ['Normal', 'Rock', 'Steel', 'Ice', 'Dark'],\n                           'Flying': ['Fighting', 'Bug', 'Grass'],\n                           'Poison': ['Grass', 'Fairy'],\n                           'Ground': ['Poison', 'Rock', 'Steel', 'Fire', 'Electric'],\n                           'Rock': ['Flying', 'Bug', 'Fire', 'Ice'],\n                           'Bug': ['Grass', 'Psychic', 'Dark'],\n                           'Ghost': ['Ghost', 'Psychic'],\n                           'Steel': ['Rock', 'Ice', 'Fairy'],\n                           'Fire': ['Bug', 'Steel', 'Grass', 'Ice'],\n                           'Water': ['Ground', 'Rock', 'Fire'],\n                           'Grass': ['Ground', 'Rock', 'Water'],\n                           'Electric': ['Flying', 'Water'],\n                           'Psychic': ['Fighting', 'Poison'],\n                           'Ice': ['Flying', 'Ground', 'Grass', 'Dragon'],\n                           'Dragon': ['Dragon'],\n                           'Dark': ['Ghost', 'Psychic'],\n                           'Fairy': ['Fighting', 'Dragon', 'Dark'],\n                           'None': []}\n\n    not_very_effective_dict = {'Normal': ['Rock', 'Steel'],\n                               'Fighting': ['Flying', 'Poison', 'Bug', 'Psychic', 'Fairy'],\n                               'Flying': ['Rock', 'Steel', 'Electric'],\n                               'Poison': ['Poison', 'Rock', 'Ground', 'Ghost'],\n                               'Ground': ['Bug', 'Grass'],\n                               'Rock': ['Fighting', 'Ground', 'Steel'],\n                               'Bug': ['Fighting', 'Flying', 'Poison', 'Ghost', 'Steel', 'Fire', 'Fairy'],\n                               'Ghost': ['Dark'],\n                               'Steel': ['Steel', 'Fire', 'Water', 'Electric'],\n                               'Fire': ['Rock', 'Fire', 'Water', 'Dragon'],\n                               'Water': ['Water', 'Grass', 'Dragon'],\n                               'Grass': ['Flying', 'Poison', 'Bug', 'Steel', 'Fire', 'Grass', 'Dragon'],\n                               'Electric': ['Grass', 'Electric', 'Dragon'],\n                               'Psychic': ['Steel', 'Psychic'],\n                               'Ice': ['Steel', 'Fire', 'Water', 'Psychic'],\n                               'Dragon': ['Steel'],\n                               'Dark': ['Fighting', 'Dark', 'Fairy'],\n                               'Fairy': ['Posion', 'Steel', 'Fire'],\n                               'None': []}\n\n    not_effective_dict = {'Normal': ['Ghost'],\n                          'Fighting': ['Ghost'],\n                          'Flying': [],\n                          'Poison': ['Steel'],\n                          'Ground': ['Flying'],\n                          'Rock': [],\n                          'Bug': [],\n                          'Ghost': ['Normal'],\n                          'Steel': [],\n                          'Fire': [],\n                          'Water': [],\n                          'Grass': [],\n                          'Electric': ['Ground'],\n                          'Psychic': ['Dark'],\n                          'Ice': [],\n                          'Dragon': ['Fairy'],\n                          'Dark': [],\n                          'Fairy': [],\n                          'None': []}\n\n    p1_type1_list = []\n    p1_type2_list = []\n    p2_type1_list = []\n    p2_type2_list = []\n\n    for row in data.itertuples():\n        nested_type = [[1, 1], [1, 1]]\n\n        tipos_pok_1 = [row.tipo1_id1, row.tipo2_id1]\n        tipos_pok_2 = [row.tipo1_id2, row.tipo2_id2]\n\n        # manipulating values if found on dictionary\n        for i in range(0, 2):\n            for j in range(0, 2):\n                if tipos_pok_2[j] in very_effective_dict.get(tipos_pok_1[i]):\n                    nested_type[0][i] *= 2\n                if tipos_pok_2[j] in not_very_effective_dict.get(tipos_pok_1[i]):\n                    nested_type[0][i] \/= 2\n                if tipos_pok_2[j] in not_effective_dict.get(tipos_pok_1[i]):\n                    nested_type[0][i] *= 0\n\n                if tipos_pok_1[j] in very_effective_dict.get(tipos_pok_2[i]):\n                    nested_type[1][i] *= 2\n                if tipos_pok_1[j] in not_very_effective_dict.get(tipos_pok_2[i]):\n                    nested_type[1][i] \/= 2\n                if tipos_pok_1[j] in not_effective_dict.get(tipos_pok_2[i]):\n                    nested_type[1][i] *= 0\n\n        p1_type1_list.append(nested_type[0][0])\n        p1_type2_list.append(nested_type[0][1])\n        p2_type1_list.append(nested_type[1][0])\n        p2_type2_list.append(nested_type[1][1])\n\n    data = data.assign(P1_type1=p1_type1_list, P1_type2=p1_type2_list,\n                       P2_type1=p2_type1_list, P2_type2=p2_type2_list)\n\n    return data","dbf2ba48":"# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------DATASET-----------------------------------------------------------\ndef get_data():\n\n    #-------pokemon.csv\n    df_pokemon = pd.read_csv(path_dir + 'pokemon.csv')\n    df_pokemon = df_pokemon.fillna({'Name': 'None', 'Type 1': 'None', 'Type 2': 'None'})\n    #df_pokemon = df_pokemon.dropna()\n    #cambiando nombre de variable\n    df_pokemon = df_pokemon.rename(index=str, columns={\"#\": \"id_pokemon\"})\n    # encoding\n    df_pokemon['Legendary'] = np.where(df_pokemon['Legendary'] == True, 1, 0)\n    # encoding name, type1 y type2\n    valores_type1 = df_pokemon['Type 1'].values\n    valores_type2 = df_pokemon['Type 2'].values\n    valores_name = df_pokemon['Name'].values\n\n    #print(df_pokemon.isna().sum())\n\n    le1 = preprocessing.LabelEncoder()\n    le2 = preprocessing.LabelEncoder()\n    lename = preprocessing.LabelEncoder()\n    encoding1 = le1.fit_transform(valores_type1)\n    encoding2 = le2.fit_transform(valores_type2)\n    encodingName = lename.fit_transform(valores_name)\n\n    # asignando\n    df_pokemon['Type 1'] = encoding1\n    df_pokemon['Type 2'] = encoding2\n    df_pokemon['Name'] = encodingName\n\n    # rapido -> 1, Lento -> 0\n    sum_speeds = np.sum(df_pokemon['Speed'].values)\n    total_speeds = len(df_pokemon['Speed'])\n    media_speeds = sum_speeds \/ total_speeds\n    df_pokemon['Rapidez'] = np.where(df_pokemon['Speed'] > media_speeds, 1, 0)\n\n    #-------battles.csv\n    df_battles = pd.read_csv(path_dir + 'battles.csv')\n    # quitamos el numero de batalla\n    df_battles = df_battles[['First_pokemon','Second_pokemon', 'Winner']]\n    print(df_battles.columns)\n\n    #winrates\n    #df_pokemon = utils.get_winrate(df_pokemon, df_battles)\n    print(df_pokemon.head())\n\n    #-------test.csv\n    df_test = pd.read_csv(path_dir + 'test.csv')\n\n    return df_pokemon, df_battles, df_test, le1, le2, lename\n\n","689941ba":"# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\ndef juntar_csvs():\n    df_pokemon, df_battles, df_test, le1, le2, lename = get_data()\n\n    #vectorizacion\n    pokemon_values = df_pokemon.values #(800, cols)\n    battles_values = df_battles.values #(50000, 3)\n    \n    ids_pokemon = pokemon_values[:,0]\n    # obtenemos valores unicos y los indices inversos para luego reconstruir el array original\n    ids_pok1, inv1 = np.unique(battles_values[:, 0], return_inverse=True)\n    ids_pok2, inv2 = np.unique(battles_values[:, 1], return_inverse=True)\n    resultados_batallas = battles_values[:, 2]\n\n    # buscamos donde estan las caracteristicas de cada pokemon en las batallas\n    indices1 = np.intersect1d(ids_pok1, ids_pokemon, return_indices=True)\n    indices2 = np.intersect1d(ids_pok2, ids_pokemon, return_indices=True)\n\n    # asignamos las caracteristicas\n    vals_pok1 = pokemon_values[indices1[2], 1:]\n    vals_pok2 = pokemon_values[indices2[2], 1:]\n\n    # pokemons sin batallas\n    sin_battles = pokemon_values[\n        np.where(\n            np.logical_not(\n                np.isin(ids_pokemon, ids_pok1)))]\n    # 16 en total\n    print('Pokemons que no han peleado:', len(sin_battles))\n\n    # y reconstruimos el array original\n    lon_values = len(battles_values)\n    # (50000, 11) cada uno\n    pok1 = vals_pok1[inv1]\n    pok2 = vals_pok2[inv2]\n    #columnas = pok2.shape[1] * 2\n    columnas = pok2.shape[1] + 3 #nombre2,tipo1_id2,tipo2_id2, el mas rapido\n    print(pok2.shape)\n\n    # aplicamos diff\n    pok_final = np.ones((lon_values, columnas))\n    pok_final[:, :3] = pok1[:, :3]#nombre1,tipo1_id1,tipo2_id1\n    pok_final[:, 3:6] = pok2[:, :3]#nombre2,tipo2_id2,tipo2_id2\n    pok_final[:, 6:] = pok1[:, 3:] - pok2[:, 3:]\n    # el mas rapido\n    #pok_final[:, -1] = np.where(pok1[:, -4] > pok2[:, -4], battles_values[:, 0], battles_values[:, 1])\n\n    # aqui juntamos el resto para crear el dataset con el que entrenar\n    #juntar_carac = np.concatenate((pok1, pok2), axis=1)\n    juntar_carac = pok_final\n    caracteristicas_y_resultados = np.ones((lon_values, columnas + 1)) # (50000, 15)\n    caracteristicas_y_resultados[:,:-1] = juntar_carac\n    caracteristicas_y_resultados[:,-1] = resultados_batallas\n\n    # ids contrincante 1, ids contrincante 2 y el que golpea primero (a\u00f1adido)\n    valores = np.array((battles_values[:, 0], battles_values[:, 1], battles_values[:, 0])) #(3, 50000)\n    valores = valores.T #(50000, 3)\n\n    lista = np.concatenate((valores, caracteristicas_y_resultados), axis=1)\n    lista = lista.astype(int)\n\n    # guardo el fichero\n    df_lista = pd.DataFrame(lista, columns=['First_pokemon', 'Second_pokemon', 'id_primer_ataq',\n                                            'nombre1', 'tipo1_id1', 'tipo2_id1',\n                                            'nombre2', 'tipo1_id2', 'tipo2_id2',\n                                            'diff_HP','diff_Attack','diff_Defense','diff_Sp. Atk','diff_Sp. Def','diff_Speed',\n                                            'diff_Generation', 'diff_Legendary',\n                                            'diff_Rapidez',\n                                            'Winner'])\n\n    # efectividad de las habilidades\n    # primero pasamos a las antiguas labels\n    df_lista['tipo1_id1'] = le1.inverse_transform(df_lista['tipo1_id1'])\n    df_lista['tipo2_id1'] = le2.inverse_transform(df_lista['tipo2_id1'])\n    df_lista['tipo1_id2'] = le1.inverse_transform(df_lista['tipo1_id2'])\n    df_lista['tipo2_id2'] = le2.inverse_transform(df_lista['tipo2_id2'])\n    df_lista['nombre1'] = lename.inverse_transform(df_lista['nombre1'])\n    df_lista['nombre2'] = lename.inverse_transform(df_lista['nombre2'])\n\n    # y luego aplicamos los valores\n    df_lista = calculate_effectiveness(df_lista)\n\n    # reordenamos para colocar la columnas Winner al final\n    winners = df_lista['Winner'].values\n    df_lista = df_lista.drop(['Winner'], axis=1)\n    df_lista['Winner'] = winners\n\n    #y volvemos a aplicar los encodings\n    df_lista['tipo1_id1'] = le1.fit_transform(df_lista['tipo1_id1'])\n    df_lista['tipo2_id1'] = le2.fit_transform(df_lista['tipo2_id1'])\n    df_lista['tipo1_id2'] = le1.fit_transform(df_lista['tipo1_id2'])\n    df_lista['tipo2_id2'] = le2.fit_transform(df_lista['tipo2_id2'])\n    df_lista['nombre1'] = lename.fit_transform(df_lista['nombre1'])\n    df_lista['nombre2'] = lename.fit_transform(df_lista['nombre2'])\n\n    # elimino carac que aportan menos --> no aporta\n    #df_lista = df_lista.drop(['diff_Generation', 'diff_Legendary'], axis=1)\n\n    df_lista.to_csv(fichero, index=False)\n    #np.savetxt(fichero, lista)\n\n    return lista","09ce74eb":"# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\ndef preparar_test():\n    df_pokemon, df_battles, df_test, le1, le2, lename = get_data()\n\n    # vectorizacion\n    pokemon_values = df_pokemon.values  # (800, 12)\n    tests_values = df_test.values  # (10000, 3)\n\n    ids_pokemon = pokemon_values[:, 0]\n    # obtenemos valores unicos y los indices inversos para luego reconstruir el array original\n    ids_pok1, inv1 = np.unique(tests_values[:, 1], return_inverse=True)\n    ids_pok2, inv2 = np.unique(tests_values[:, 2], return_inverse=True)\n\n    # buscamos donde estan las caracteristicas de cada pokemon en las batallas\n    indices1 = np.intersect1d(ids_pok1, ids_pokemon, return_indices=True)\n    indices2 = np.intersect1d(ids_pok2, ids_pokemon, return_indices=True)\n\n    # asignamos las caracteristicas\n    vals_pok1 = pokemon_values[indices1[2], 1:]\n    vals_pok2 = pokemon_values[indices2[2], 1:]\n\n    # pokemons sin batallas\n    sin_battles = pokemon_values[\n        np.where(\n            np.logical_not(\n                np.isin(ids_pokemon, ids_pok1)))]\n    # 16 en total\n    print('Pokemons que no han peleado en test:', len(sin_battles))\n\n    # y reconstruimos el array original\n    lon_values = len(tests_values)\n    # (10000, 11) cada uno\n    pok1 = vals_pok1[inv1]\n    pok2 = vals_pok2[inv2]\n    columnas = pok2.shape[1] + 3  # nombre2,tipo1_id2,tipo2_id2, Mas_Winrate\n\n    # aplicamos diff\n    pok_final = np.ones((lon_values, columnas))\n    pok_final[:, :3] = pok1[:, :3]\n    pok_final[:, 3:6] = pok2[:, :3]\n    pok_final[:, 6:] = pok1[:, 3:] - pok2[:, 3:]\n    # winrate\n    #pok_final[:, -2] = np.where(pok1[:, -1] > pok2[:, -1], tests_values[:, 0], tests_values[:, 1])\n    # el mas rapido\n    #pok_final[:, -1] = np.where(pok1[:, -2] > pok2[:, -2], tests_values[:, 0], tests_values[:, 1])\n\n    # aqui juntamos el resto para crear el dataset con el que entrenar\n    # juntar_carac = np.concatenate((pok1, pok2), axis=1)\n    juntar_carac = pok_final\n\n    # ids contrincante 1, ids contrincante 2 y el que golpea primero (a\u00f1adido)\n    valores = np.array((tests_values[:, 1], tests_values[:, 2], tests_values[:, 1]))  # (3, 10000)\n    valores = valores.T  # (10000, 3)\n\n    lista = np.concatenate((valores, juntar_carac), axis=1)\n    lista = lista.astype(int)\n    print(lista.shape)\n    # guardo el fichero\n    df_lista = pd.DataFrame(lista, columns=['First_pokemon', 'Second_pokemon', 'id_primer_ataq',\n                                            'nombre1', 'tipo1_id1', 'tipo2_id1',\n                                            'nombre2', 'tipo1_id2', 'tipo2_id2',\n                                            'HP','Attack','Defense','Sp. Atk','Sp. Def','Speed',\n                                            'Generation', 'Legendary',\n                                            'Rapidez'\n                                            ])\n\n    # efectividad de las habilidades\n    # primero pasamos a las antiguas labels\n    df_lista['tipo1_id1'] = le1.inverse_transform(df_lista['tipo1_id1'])\n    df_lista['tipo2_id1'] = le2.inverse_transform(df_lista['tipo2_id1'])\n    df_lista['tipo1_id2'] = le1.inverse_transform(df_lista['tipo1_id2'])\n    df_lista['tipo2_id2'] = le2.inverse_transform(df_lista['tipo2_id2'])\n    df_lista['nombre1'] = lename.inverse_transform(df_lista['nombre1'])\n    df_lista['nombre2'] = lename.inverse_transform(df_lista['nombre2'])\n\n    # y luego aplicamos los valores\n    df_lista = calculate_effectiveness(df_lista)\n\n    # y volvemos a aplicar los encodings\n    df_lista['tipo1_id1'] = le1.fit_transform(df_lista['tipo1_id1'])\n    df_lista['tipo2_id1'] = le2.fit_transform(df_lista['tipo2_id1'])\n    df_lista['tipo1_id2'] = le1.fit_transform(df_lista['tipo1_id2'])\n    df_lista['tipo2_id2'] = le2.fit_transform(df_lista['tipo2_id2'])\n    df_lista['nombre1'] = lename.fit_transform(df_lista['nombre1'])\n    df_lista['nombre2'] = lename.fit_transform(df_lista['nombre2'])\n\n    # elimino carac que aportan menos --> no aporta\n    #df_lista = df_lista.drop(['Generation', 'Legendary'], axis=1)\n\n    df_lista.to_csv(tests, index=False)","cb56652b":"# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------MODELO EMPLEADOS--------------------------------------------------\ndef GradientBoosting(train_x, train_y, test_x, test_y):\n\n    clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.08, subsample=0.75,max_depth=9, verbose = 1)\n    clf.fit(train_x, train_y)\n\n    y_pred=clf.predict(test_x)\n    print(clf.feature_importances_)\n    print(\"Accuracy random forest:\",metrics.accuracy_score(test_y, y_pred))\n\n    return clf","2c742f09":"# ----------------------------------------------------------------------------------------------------------------------\n# ---------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------RESULTADOS--------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# ---------------------------------------------------------------------------------------------------------\ndef agrupados():\n\n    lista = pd.read_csv(fichero).values\n\n    print(lista.shape)\n\n    X = lista[:, :-1]\n    y = lista[:, -1]\n\n    train_x,train_y = X[:n_test], y[:n_test]\n    test_x, test_y = X[n_test:], y[n_test:]\n\n    rf = GradientBoosting(train_x, train_y, test_x, test_y)\n    #mlp = MLP(train_x, train_y, test_x, test_y)\n    #svm = SVM(train_x, train_y, test_x, test_y)\n\n    return rf\n# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# ------------------------------------------guardar datos finales-------------------------------------------------------\ndef resultado_final():\n\n    lista = pd.read_csv(tests).values\n    print(lista.shape)\n\n    clf = agrupados()\n    y_pred = clf.predict(lista)\n    \n    print(y_pred)\n    y_pred = y_pred.astype(int)\n\n    df_test = pd.read_csv(path_dir + 'test.csv')\n    df_test['Winner'] = y_pred\n    \n    # lo que subo\n    df_sample = df_test[['battle_number', 'Winner']]\n    df_sample.to_csv(sample, index=False)","eaac52ee":"# ----------------------------------------------------------------------------------------------------------------------\n# ----------------------------------------------------------------------------------------------------------------------\n# solo_battles()\njuntar_csvs()\npreparar_test()\n#agrupados()\nresultado_final()","60b30d2a":"Primero establezco las rutas y parametros esenciales del proyecto. Yo sol\u00eda poner el campo *n_test* poner = a 45000 para tener 5000 batallas de testeo.","1efa80fc":"Esta fue la primera soluci\u00f3n que me hizo rascar el 99% de acc. Actualmente estoy probando con LightGBM y Grid Search. Cuando saque algo de tiempo y vea que no se puede mejorar m\u00e1s, subir\u00e9 todo ese c\u00f3digo bien estructurado y ordenado, y publicar\u00e9 el Colab donde lo estoy haciendo :)","cb719fa9":"La siguiente funci\u00f3n la adapt\u00e9 de kaggle y sirve para calcular la efectividad de un pokemon. El rango va de 0 a 4 por cada tipo. Link : https:\/\/www.kaggle.com\/terminus7\/pokemon-challenge ","4ca7f6c4":"La siguiente hace lo mismo que la anterior pero sin la columna \"Winner\": sirve para hacer las **predicciones** del fichero a subir.","62d57abb":"Empleo el algoritmo de **gradient boosting** con scikit. Cuando llegu\u00e9 a* 98,780 *% de acc puse 800 estimadores en lugar de los 100 (para que cuando ejecutes este Kernel no est\u00e9s demasiado rato esperando).","a91bafb1":"Esta funci\u00f3n divide el conjunto de entrenamiento y validaci\u00f3n (para el caso de cuando testeaba, empleo 45k - 5k para cada uno).","ce85f491":"1. Primero se crea el conjunto de entrenamiento.\n2. Luego el conjunto a ser predecido (y posteriormente subido a Kaggle)\n3. Y se entrena y crea el fichero a subir.","9eef66c9":"Esta funci\u00f3n sirve para crear el **conjunto de entrenamiento**:","f571d694":"Aqu\u00ed limpio un poco los CSV's y los preparo para ser juntados (pokemon con battles)."}}