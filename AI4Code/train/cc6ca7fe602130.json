{"cell_type":{"6b22bfb3":"code","2f3cb179":"code","51206c3d":"code","b4927fd4":"code","c94e77f4":"code","8c3f38f0":"code","a092fec9":"code","9c29efcb":"code","7aca3def":"code","f2a3be8b":"code","ba1989a7":"code","66da7a1e":"code","38510257":"code","e57f2260":"code","c4590254":"code","899b44bd":"code","e0078321":"code","94f8a0f3":"code","41ad70d5":"markdown","1d72a823":"markdown","6c582d12":"markdown","e25e75c9":"markdown","37794b84":"markdown","b34bc3e3":"markdown","9cd05178":"markdown","70ff8482":"markdown","d2dd8085":"markdown"},"source":{"6b22bfb3":"import pandas as pd\nimport numpy as np\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.optim import lr_scheduler\nfrom torch.autograd import Variable\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision import transforms\nfrom torchvision.utils import make_grid\n\nimport math, random, numbers\nfrom PIL import Image","2f3cb179":"INPUT_DIR = '..\/input\/digit-recognizer'\nBATCH_SIZE = 64\nN_EPOCHS = 50","51206c3d":"train_df = pd.read_csv(INPUT_DIR + '\/train.csv')\n\nn_train = len(train_df)\nn_pixels = len(train_df.columns) - 1\nn_class = len(set(train_df['label']))\n\nprint('Number of training samples: {0}'.format(n_train))\nprint('Number of training pixels: {0}'.format(n_pixels))\nprint('Number of classes: {0}'.format(n_class))","b4927fd4":"test_df = pd.read_csv(INPUT_DIR + '\/test.csv')\n\nn_test = len(test_df)\nn_pixels = len(test_df.columns)\n\nprint('Number of train samples: {0}'.format(n_test))\nprint('Number of test pixels: {0}'.format(n_pixels))","c94e77f4":"class MNIST_data(Dataset):\n    def __init__(self, file_path, \n                 transform = transforms.Compose([transforms.ToPILImage(), transforms.ToTensor(), \n                     transforms.Normalize(mean=(0.5,), std=(0.5,))])\n                ):\n        \n        df = pd.read_csv(file_path)\n        \n        if len(df.columns) == n_pixels:\n            # test data\n            self.X = df.values.reshape((-1,28,28)).astype(np.uint8)[:,:,:,None]\n            self.y = None\n        else:\n            # training data\n            self.X = df.iloc[:,1:].values.reshape((-1,28,28)).astype(np.uint8)[:,:,:,None]\n            self.y = torch.from_numpy(df.iloc[:,0].values)\n            \n        self.transform = transform\n    \n    def __len__(self):\n        return len(self.X)\n\n    def __getitem__(self, idx):\n        if self.y is not None:\n            return self.transform(self.X[idx]), self.y[idx]\n        else:\n            return self.transform(self.X[idx])","8c3f38f0":"class RandomRotation(object):\n    def __init__(self, degrees, resample=False, expand=False, center=None):\n        if isinstance(degrees, numbers.Number):\n            if degrees < 0:\n                raise ValueError(\"If degrees is a single number, it must be positive.\")\n            self.degrees = (-degrees, degrees)\n        else:\n            if len(degrees) != 2:\n                raise ValueError(\"If degrees is a sequence, it must be of len 2.\")\n            self.degrees = degrees\n\n        self.resample = resample\n        self.expand = expand\n        self.center = center\n\n    @staticmethod\n    def get_params(degrees):\n        angle = np.random.uniform(degrees[0], degrees[1])\n        return angle\n\n    def __call__(self, img):\n        def rotate(img, angle, resample=False, expand=False, center=None):\n            return img.rotate(angle, resample, expand, center)\n        angle = self.get_params(self.degrees)\n        return rotate(img, angle, self.resample, self.expand, self.center)","a092fec9":"class RandomShift(object):\n    def __init__(self, shift):\n        self.shift = shift\n        \n    @staticmethod\n    def get_params(shift):\n        hshift, vshift = np.random.uniform(-shift, shift, size=2)\n        return hshift, vshift \n    \n    def __call__(self, img):\n        hshift, vshift = self.get_params(self.shift)        \n        return img.transform(img.size, Image.AFFINE, (1,0,hshift,0,1,vshift), resample=Image.BICUBIC, fill=1)","9c29efcb":"train_dataset = MNIST_data(INPUT_DIR + '\/train.csv', transform=transforms.Compose(\n                            [transforms.ToPILImage(), RandomRotation(degrees=20), RandomShift(3),\n                             transforms.ToTensor(), transforms.Normalize(mean=(0.5,), std=(0.5,))]))\ntest_dataset = MNIST_data(INPUT_DIR + '\/test.csv')\n\ntrain_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=BATCH_SIZE, shuffle=True)\ntest_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=BATCH_SIZE, shuffle=False)","7aca3def":"class Net(nn.Module):    \n    def __init__(self):\n        super(Net, self).__init__()\n          \n        self.features = nn.Sequential(\n            nn.Conv2d(1, 32, kernel_size=3, stride=1, padding=1),\n            nn.BatchNorm2d(32),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(32, 32, kernel_size=3, stride=1, padding=1),\n            nn.BatchNorm2d(32),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=2, stride=2),\n            nn.Conv2d(32, 64, kernel_size=3, padding=1),\n            nn.BatchNorm2d(64),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(64, 64, kernel_size=3, padding=1),\n            nn.BatchNorm2d(64),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=2, stride=2)\n        )\n          \n        self.classifier = nn.Sequential(\n            nn.Dropout(p = 0.5),\n            nn.Linear(64 * 7 * 7, 512),\n            nn.BatchNorm1d(512),\n            nn.ReLU(inplace=True),\n            nn.Dropout(p = 0.5),\n            nn.Linear(512, 512),\n            nn.BatchNorm1d(512),\n            nn.ReLU(inplace=True),\n            nn.Dropout(p = 0.5),\n            nn.Linear(512, 10),\n        )\n          \n        for m in self.features.children():\n            if isinstance(m, nn.Conv2d):\n                n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels\n                m.weight.data.normal_(0, math.sqrt(2. \/ n))\n            elif isinstance(m, nn.BatchNorm2d):\n                m.weight.data.fill_(1)\n                m.bias.data.zero_()\n        \n        for m in self.classifier.children():\n            if isinstance(m, nn.Linear):\n                nn.init.xavier_uniform_(m.weight)\n            elif isinstance(m, nn.BatchNorm1d):\n                m.weight.data.fill_(1)\n                m.bias.data.zero_()\n\n    def forward(self, x):\n        x = self.features(x)\n        x = x.view(x.size(0), -1)\n        x = self.classifier(x)\n        return x","f2a3be8b":"model = Net()\n\noptimizer = optim.Adam(model.parameters(), lr=0.003)\ncriterion = nn.CrossEntropyLoss()\nexp_lr_scheduler = lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)\n\nif torch.cuda.is_available():\n    model = model.cuda()\n    criterion = criterion.cuda()","ba1989a7":"def train(epoch):\n    model.train()\n    optimizer.step()\n    exp_lr_scheduler.step()\n\n    for batch_idx, (data, target) in enumerate(train_loader):\n        data, target = Variable(data), Variable(target)\n        \n        if torch.cuda.is_available():\n            data = data.cuda()\n            target = target.cuda()\n        \n        optimizer.zero_grad()\n        output = model(data)\n        loss = criterion(output, target)\n        loss.backward()\n        optimizer.step()\n        \n        if (batch_idx + 1)% 100 == 0:\n            print('Train Epoch: {} [{}\/{} ({:.0f}%)]\\tLoss: {:.6f}'.format(\n                epoch, (batch_idx + 1) * len(data), len(train_loader.dataset), 100. * (batch_idx + 1) \/ len(train_loader), loss.item()))","66da7a1e":"def evaluate(data_loader):\n    model.eval()\n    loss = 0\n    correct = 0\n    \n    with torch.no_grad():\n        for data, target in data_loader:\n            data, target = Variable(data), Variable(target)\n            if torch.cuda.is_available():\n                data = data.cuda()\n                target = target.cuda()\n\n            output = model(data)\n            loss += F.cross_entropy(output, target,  reduction='sum').item()\n            pred = output.data.max(1, keepdim=True)[1]\n            correct += pred.eq(target.data.view_as(pred)).cpu().sum()\n        \n    loss \/= len(data_loader.dataset)\n        \n    print('\\nAverage loss: {:.4f}, Accuracy: {}\/{} ({:.3f}%)\\n'.format(\n        loss, correct, len(data_loader.dataset), 100. * correct \/ len(data_loader.dataset)))","38510257":"for epoch in range(N_EPOCHS):\n    train(epoch)\n    evaluate(train_loader)","e57f2260":"def prediciton(data_loader):\n    model.eval()\n    test_pred = torch.LongTensor()\n    \n    with torch.no_grad():\n        for i, data in enumerate(data_loader):\n            data = Variable(data)\n            if torch.cuda.is_available():\n                data = data.cuda()\n\n            output = model(data)\n            pred = output.cpu().data.max(1, keepdim=True)[1]\n            test_pred = torch.cat((test_pred, pred), dim=0)\n        \n    return test_pred","c4590254":"test_pred = prediciton(test_loader)","899b44bd":"out_df = pd.DataFrame(np.c_[np.arange(1, len(test_dataset)+1)[:,None], test_pred.numpy()], columns=['ImageId', 'Label'])","e0078321":"out_df.head()","94f8a0f3":"out_df.to_csv('submission.csv', index=False)","41ad70d5":"## Explore the Data","1d72a823":"### Random Rotation Transformation\nRandomly rotate the image. Available in upcoming torchvision but not now.","6c582d12":"### Train the network\n\nReaches 0.995 accuracy on test set after 50 epochs","e25e75c9":"## Load the Data into Tensors\nFor the training set, apply random rotation within the range of (-45, 45) degrees, shift by (-3, 3) pixels\nand normalize pixel values to [-1, 1].  For the test set, only apply nomalization.","37794b84":"## Data Loader","b34bc3e3":"### Random Vertical and Horizontal Shift","9cd05178":"## Network Structure","70ff8482":"## Prediction on Test Set","d2dd8085":"## Training and Evaluation"}}