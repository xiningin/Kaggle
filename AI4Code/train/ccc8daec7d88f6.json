{"cell_type":{"4102aecd":"code","9a39cd9c":"code","d3a168fe":"code","1a1a4cbf":"code","6e65d199":"code","8697d822":"code","a999a89a":"code","a1413e6d":"code","6e6fa2d7":"code","5f61299f":"code","29d9b01e":"code","6e9e23fe":"code","a916bfd1":"code","b73aa74c":"code","725f3f10":"markdown","c76ac01e":"markdown","b669ef3b":"markdown","1e786cc2":"markdown","881409f1":"markdown","f5825b03":"markdown","4270325c":"markdown","c364a1c3":"markdown","0c8c2ce5":"markdown","07833ed8":"markdown","ddc61c62":"markdown"},"source":{"4102aecd":"import tensorflow as tf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nfrom tensorflow.keras import layers, losses\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras.models import Model","9a39cd9c":"df = pd.read_csv('http:\/\/storage.googleapis.com\/download.tensorflow.org\/data\/ecg.csv', header=None)\ndf.head()","d3a168fe":"#Now we will separate the data and labels so that it will be easy for us\ndata = df.iloc[:,:-1].values\nlabels = df.iloc[:,-1].values\nlabels","1a1a4cbf":"train_data, test_data, train_labels, test_labels = train_test_split(data, labels, test_size = 0.2, random_state = 21)","6e65d199":"#Now lets Normalize the data\n#First we will calculate the maximum and minimum value from the training set \nmin = tf.reduce_min(train_data)\nmax = tf.reduce_max(train_data)\n\n#Now we will use the formula (data - min)\/(max - min)\ntrain_data = (train_data - min)\/(max - min)\ntest_data = (test_data - min)\/(max - min)\n\n#I have converted the data into float\ntrain_data = tf.cast(train_data, dtype=tf.float32)\ntest_data = tf.cast(test_data, dtype=tf.float32)","8697d822":"#The labels are either 0 or 1, so I will convert them into boolean(true or false) \ntrain_labels = train_labels.astype(bool)\ntest_labels = test_labels.astype(bool)\n\n#Now let's separate the data for normal ECG from that of abnormal ones\n#Normal ECG data\nn_train_data = train_data[train_labels]\nn_test_data = test_data[test_labels]\n\n#Abnormal ECG data\nan_train_data = train_data[~train_labels]\nan_test_data = test_data[~test_labels]\n\nprint(n_train_data)","a999a89a":"#Lets plot a normal ECG\nplt.plot(np.arange(140), n_train_data[0])\nplt.grid()\nplt.title('Normal ECG')\nplt.show()","a1413e6d":"#Lets plot one from abnormal ECG\nplt.plot(np.arange(140), an_train_data[0])\nplt.grid()\nplt.title('Abnormal ECG')\nplt.show()","6e6fa2d7":"#Now let's define the model!\n#Here I have used the Model Subclassing API (but we can also use the Sequential API)\n#The model has 2 parts : 1. Encoder and 2. Decoder\n \nclass detector(Model):\n  def __init__(self):\n    super(detector, self).__init__()\n    self.encoder = tf.keras.Sequential([\n                                        layers.Dense(32, activation='relu'),\n                                        layers.Dense(16, activation='relu'),\n                                        layers.Dense(8, activation='relu')\n    ])\n    self.decoder = tf.keras.Sequential([\n                                        layers.Dense(16, activation='relu'),\n                                        layers.Dense(32, activation='relu'),\n                                        layers.Dense(140, activation='sigmoid')\n    ])\n\n  def call(self, x):\n    encoded = self.encoder(x)\n    decoded = self.decoder(encoded)\n    return decoded","5f61299f":"#Let's compile and train the model!!\nautoencoder = detector()\nautoencoder.compile(optimizer='adam', loss='mae')\nautoencoder.fit(n_train_data, n_train_data, epochs = 20, batch_size=512, validation_data=(n_test_data, n_test_data))","29d9b01e":"#Now let's define a function in order to plot the original ECG and reconstructed ones and also show the error\ndef plot(data, n):\n  enc_img = autoencoder.encoder(data)\n  dec_img = autoencoder.decoder(enc_img)\n  plt.plot(data[n], 'b')\n  plt.plot(dec_img[n], 'r')\n  plt.fill_between(np.arange(140), data[n], dec_img[n], color = 'lightcoral')\n  plt.legend(labels=['Input', 'Reconstruction', 'Error'])\n  plt.show()\n\nplot(n_test_data, 0)\nplot(an_test_data, 0)","6e9e23fe":"reconstructed = autoencoder(n_train_data)\ntrain_loss = losses.mae(reconstructed, n_train_data)\nt = np.mean(train_loss) + np.std(train_loss)\n\ndef prediction(model, data, threshold):\n  rec = model(data)\n  loss = losses.mae(rec, data)\n  return tf.math.less(loss, threshold)\nprint(t)","a916bfd1":"pred = prediction(autoencoder, n_test_data, t)\nprint(pred)","b73aa74c":"#Lets see some more result visually !!\nplot(n_test_data, 0)\nplot(n_test_data, 1)\nplot(n_test_data, 3)","725f3f10":"**This model uses an Autoencoder architecture for anomaly detection**\n\nAutoencoders are a specific type of feedforward neural network.It compresess the input into a so-called \"code\" of lower dimensionality and then tries to reconstruct the output from this code.It is an **unsupervised** learning model. \n\nIt consists of two parts:-\n1.Encoder\n2.Decoder\n\n![image.png](attachment:image.png)\n\nSo in simple terms we provide an input to the autoencoder and it tries to re-create it.\n\nFor a detailed information refer to the article in link https:\/\/towardsdatascience.com\/applied-deep-learning-part-3-autoencoders-1c083af4d798\n\n","c76ac01e":"As I mentioned earlier an ECG is anomalous if it is greater than a threshold. We can set the threshold in any way we want. Here I am going to set it to one standard deviation from the mean of normal training data.","b669ef3b":"**NOTE**:\nSee that in fit() both the data are same i.e. n_train_data, the reason is that we will be comparing the original ECG with the reconstructed one to calculate the reconstruction error.\nAutoencoders are unsupervised learning models but here we are training them using supervised method so its more like they are used as **self-supervised**.  ","1e786cc2":"We will use the simple formula :-\n![image.png](attachment:image.png)","881409f1":"As we can see that the dataset has 140 columns which represent the ECG readings and a labels column which has been encoded to 0 or 1 showing whether the ECG is abnormal or normal.","f5825b03":"This model was just the basic model and it can be improved by doing hyperparameter tuning and making the encoder and decoder with DNN. \nThe threshold was determined using a very simple method and it can be also changed for getting better and more accurate results. The criteria for determinig the threshold can make a lot of difference.\n\n","4270325c":"An autoencoder is a special type of neural network that is trained to copy its input to its output. For example, given an image of a handwritten digit, an autoencoder first encodes the image into a lower dimensional representation, then decodes it back to an image. It learns to compress the data while minimizing the reconstruction error. This notebook uses autoencoders for detecting anomaly in ECG(electro cardiogram) readings. This is a very good practical application of autoencoders. So lets begin!\n\nHere is my github profile: https:\/\/github.com\/Devavrata-Tripathy","c364a1c3":"**UPVOTE IF YOU LIKED THE KERNEL. THANK YOU ....**","0c8c2ce5":"Before we make the model another thing that I want to clarify is that I will be using the **Subclassing API** of keras for making the model.\nIn keras there are mainly 3 APIs for defining a model :-\n**1.Sequential API\n2.Functional API\n3.Subclassing API\n\nThe reason I used Subclassing API is that it provides a good control over the model as compared to Sequential API because in sequential API the add funcion implicitly passes the output of one layer into the next and u just get the output from the final layer but in case  of subclassing API the forward pass is explicitly defined as you can see in the **call()** function. For this problem this api suits best. \n\nThe subclassing api is used to create a model class called **detector**(in this case) it inherits from the **Model** class of keras from which both sequential model and functional api also inherit. First using super() we pass the parameters to the parent class then we define out constructor which has the encoder and decoder. Then we implement the forward pass in the call() function. \n\nFor a better understanding refer to this article https:\/\/towardsdatascience.com\/3-ways-to-create-a-machine-learning-model-with-keras-and-tensorflow-2-0-de09323af4d3","07833ed8":"**Lets normalize the data to the range [0-1]**","ddc61c62":"**So how the model will detect anomaly ?**\n\nWe will create an encoder and a decoder using an ANN architecture.We are going to provide the ECG data as input and the model will try to reconstruct it. The error between the original data and reconstructed output will be called the **reconstruction error**.Based on this recostruction error we are going to classify an ECG as anomalous or not.In order to do this we are going to train the model only on the normal ECG data but it will be tested on the full test set, so that when an abnormal ECG is provided in the input the autoencoder will try to reconstruct it but since it has been only trained on normal ECG data the output will have a larger reconstruction error. We will also define a minimum threshold for the error i.e. if the reconstruction error is above the threshold then it will be categorised as anomalous. "}}