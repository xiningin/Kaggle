{"cell_type":{"f05ccac0":"code","37b8a57d":"code","a01a62c9":"code","b0b9ff6e":"code","009d08cd":"code","77ac9848":"code","3a486238":"code","cb7f9e5e":"code","d5f7cde3":"code","abf93b93":"code","5aaf311b":"code","3a58567f":"code","a84cb1f2":"code","ae088bf0":"code","5717424a":"code","e848f636":"code","768cfc20":"code","3ddd6379":"code","2d2a456e":"code","7f0fb602":"code","8919780d":"code","e03b4ab5":"code","8d08cac6":"code","45191a81":"code","effe6da7":"code","d1a9db1d":"code","6164fb20":"code","fb28b394":"code","4bc001f3":"code","9ee3e746":"code","b20de7c0":"code","2fb30f05":"code","d2ff78dc":"code","ab9b8636":"code","6f81e6d5":"code","0f00d718":"code","e3ab7a90":"code","ff7018d0":"code","161241f2":"code","5439cff9":"code","1b7dd3e4":"code","01d61571":"code","9882f26b":"code","9f51986e":"code","a24fd19a":"code","10c21294":"code","4af66882":"code","621267b2":"code","f388eb16":"code","e8d551ea":"code","0b729595":"markdown","ecc19f77":"markdown","63f31ca5":"markdown","0f8ec07e":"markdown","479f9671":"markdown","ccefa246":"markdown","926fb699":"markdown","e8176037":"markdown","754181f5":"markdown"},"source":{"f05ccac0":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.preprocessing import StandardScaler\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.linear_model import Ridge\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nimport xgboost as xgb\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import mean_squared_error as mse","37b8a57d":"import warnings\nwarnings.filterwarnings(\"ignore\")","a01a62c9":"train = pd.read_csv('..\/input\/30-days-of-ml\/train.csv')\ntest = pd.read_csv('..\/input\/30-days-of-ml\/test.csv')\nsub = pd.read_csv('..\/input\/30-days-of-ml\/sample_submission.csv')","b0b9ff6e":"train.head()","009d08cd":"train.info()","77ac9848":"test.head()","3a486238":"test.info()","cb7f9e5e":"train = train.drop('id',axis=1)\ntest = test.drop('id',axis=1)","d5f7cde3":"sub","abf93b93":"print(\"Training Data Shape: \",train.shape)\nprint(\"Testing Data Shape: \",test.shape)","5aaf311b":"cols = test.columns","3a58567f":"X_train = train[cols]\nX_test = test.copy()\ny = train['target']","a84cb1f2":"object_cols = [col for col in cols if 'cat' in col]\n\nordinal_encoder = OrdinalEncoder()\n\nX_train[object_cols] = ordinal_encoder.fit_transform(X_train[object_cols])\nX_test[object_cols] = ordinal_encoder.fit_transform(X_test[object_cols])","ae088bf0":"X_train.head()","5717424a":"X_train.info()","e848f636":"X_test.head()","768cfc20":"X_test.info()","3ddd6379":"ss = StandardScaler()\n\nX_train_scaled = ss.fit_transform(X_train)\nX_test_scaled = ss.fit_transform(X_test)","2d2a456e":"X_train_scaled,X_val_scaled,y_train,y_val = train_test_split(X_train_scaled,y,test_size=0.25,random_state=42)","7f0fb602":"print(\"X_train data shape: \",X_train_scaled.shape)\nprint(\"X_val data shape: \",X_val_scaled.shape)\nprint(\"y_train shape: \",y_train.shape)\nprint(\"y_val shape: \",y_val.shape)","8919780d":"lr = LinearRegression()\nlr.fit(X_train_scaled,y_train)\ny_preds_lr = lr.predict(X_val_scaled)\n\nprint(\"RMSE for Linear Regression Model: \",np.sqrt(mse(y_val,y_preds_lr)))","e03b4ab5":"target_pred_lr = lr.predict(X_test_scaled)","8d08cac6":"target_pred_lr","45191a81":"sub_lr = pd.read_csv('..\/input\/30-days-of-ml\/sample_submission.csv')","effe6da7":"sub_lr['target'] = target_pred_lr\nsub_lr.to_csv('sub_lr.csv',index=False)\nsub_lr.head()","d1a9db1d":"ridge = Ridge()\n\nridge.fit(X_train_scaled,y_train)\ny_preds_ridge = ridge.predict(X_val_scaled)\n\nprint(\"RMSE of Ridge Regression: \",np.sqrt(mse(y_val,y_preds_ridge)))","6164fb20":"target_pred_ridge = ridge.predict(X_test_scaled)","fb28b394":"target_pred_ridge","4bc001f3":"sub_ridge = pd.read_csv('..\/input\/30-days-of-ml\/sample_submission.csv')","9ee3e746":"sub_ridge['target'] = target_pred_ridge\nsub_ridge.to_csv('sub_ridge.csv',index = False)\nsub_ridge.head()","b20de7c0":"tree_reg = DecisionTreeRegressor()\n\ntree_reg.fit(X_train_scaled,y_train)\ny_preds_tree = tree_reg.predict(X_val_scaled)\n\nprint(\"RMSE for Decision Tree Regressor: \",np.sqrt(mse(y_val,y_preds_tree)))","2fb30f05":"y_preds_tree","d2ff78dc":"for_reg = RandomForestRegressor()\n\nfor_reg.fit(X_train_scaled,y_train)\ny_preds_for = for_reg.predict(X_val_scaled)\n\nprint(\"RMSE for Random Forest Regressor: \",np.sqrt(mse(y_val,y_preds_for)))","ab9b8636":"target_pred_for = for_reg.predict(X_test_scaled)\ntarget_pred_for","6f81e6d5":"sub_for = pd.read_csv('..\/input\/30-days-of-ml\/sample_submission.csv')\nsub_for['target'] = target_pred_for\nsub_for.head()","0f00d718":"sub_for.to_csv('sub_for.csv',index=False)","e3ab7a90":"xgb_reg = xgb.XGBRegressor(gpu_id=0,tree_method='gpu_hist')\n\nxgb_reg.fit(X_train_scaled,y_train)\ny_preds_xgb = xgb_reg.predict(X_val_scaled)\n\nprint(\"RMSE for XGBoost Regressor: \",np.sqrt(mse(y_val,y_preds_xgb)))","ff7018d0":"target_pred_xgb = xgb_reg.predict(X_test_scaled)\ntarget_pred_xgb","161241f2":"sub_xgb = pd.read_csv('..\/input\/30-days-of-ml\/sample_submission.csv')\nsub_xgb['target'] = target_pred_xgb\nsub_xgb.head()","5439cff9":"sub_xgb.to_csv('sub_xgb.csv',index=False)","1b7dd3e4":"ss = StandardScaler()\n\nX_scaled = ss.fit_transform(X_train)\nX_test_scaled = ss.fit_transform(X_test)","01d61571":"X_scaled.shape","9882f26b":"train_oof = np.zeros((X_scaled.shape[0],))\ntarget_preds_xgb = np.zeros((X_test_scaled.shape[0],))","9f51986e":"train_oof.shape","a24fd19a":"target_preds_xgb.shape","10c21294":"%%time\nn_splits = 5\n\nkf = KFold(n_splits=n_splits,random_state = 42,shuffle=True)\n\nfor i, (train_index,val_index) in enumerate(kf.split(X_train)):\n    print(\"Fitting Fold: \",i+1)\n    \n    train_features = X_scaled[train_index]\n    train_target = y[train_index]\n    \n    val_features = X_scaled[val_index]\n    val_target = y[val_index]\n    \n    model = xgb.XGBRegressor(gpu_id=0,tree_method='gpu_hist')\n    model.fit(train_features,train_target)\n    val_pred = model.predict(val_features)\n    train_oof[val_index] = val_pred.flatten()\n    target_preds_xgb += model.predict(X_test_scaled).flatten() \/ n_splits","4af66882":"print(\"RMSE for XGBoost Regressor with KFold: \",np.sqrt(mse(y,train_oof)))","621267b2":"target_preds_xgb","f388eb16":"sub_kf_xgb = pd.read_csv('..\/input\/30-days-of-ml\/sample_submission.csv')\nsub_kf_xgb['target'] = target_preds_xgb\nsub_kf_xgb.head()","e8d551ea":"sub_kf_xgb.to_csv('sub_kf_xgb.csv',index=False)","0b729595":"Converting the Categorical variable into the ordinal encoded","ecc19f77":"# Random Forest Regressor","63f31ca5":"****Rescaling the data ****","0f8ec07e":"# Ridge Regression Model","479f9671":"# XGBoost Regressor Model","ccefa246":"Will be using GPU for XGBoost Regressor Model.","926fb699":"# KFold with XGBoost Regressor","e8176037":"# Decision Tree Regressor","754181f5":"# Linear Regression Model"}}