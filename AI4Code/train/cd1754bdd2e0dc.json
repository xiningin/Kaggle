{"cell_type":{"838f5d47":"code","cb82ae7a":"code","87510068":"code","bc9fd382":"code","74ca780a":"code","87519f02":"code","727311a1":"code","7d27b0e4":"markdown","2bd2a935":"markdown"},"source":{"838f5d47":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","cb82ae7a":"from typing import List\nimport math, random\nfrom collections import defaultdict, Counter\n\nVector = List[float]\ndef dot(v: Vector, w: Vector) -> float:\n    \"\"\"Computes v_1 * w_1 + ... + v_n * w_n\"\"\"\n    assert len(v) == len(w), \"vectors must be same length\"\n\n    return sum(v_i * w_i for v_i, w_i in zip(v, w))","87510068":"users_interests = [\n    [\" Hereditary\", \"  The Favourite\", \"Blindspotting\", \" Spider-Man: Into the Spider-Verse\", \"Mission: Impossible - Fallout\", \" Sorry to Bother You\", \"Roma\"],\n    [\"Annihilation\", \"Avengers: Infinity War\", \"Roma\", \"Blindspotting\", \" Under the Silver Lake\"],\n    [\"Upgrade\", \"wrong turn\", \"No Mercy\", \"La la Land\", \"bahubaali 2\", \"BPM\"],\n    [\"Whose Streets? \", \"Upgrade\", \"bahubaali\", \"Nocturama\", \"demons\"],\n    [\"manhunt\", \"Nocturama\", \"River\", \"Brawl in Cell Block 99 \"],\n    [\"Upgrade\", \"Whose Streets? \", \" Spider-Man: Into the Spider-Verse\", \"Hangover\", \" Hangover 2\", \"Leech\"],\n    [\"bahubaali\", \"demons\", \"The man who knew infinity\", \"The Big Sick\"],\n    [\"manhunt\", \"wrong turn\", \"abcd\", \"Pale\"],\n    [\"Pale\", \"deep learning\", \"  The Favourite\", \"Lame\"],\n    [\" Hereditary\", \" Spider-Man: Into the Spider-Verse\", \"I\", \"  The Favourite\"],\n    [\"bahubaali\", \"Whose Streets? \", \"bahubaali 2\"],\n    [\"Hangover\", \"deep learning\", \"Lame\", \"demons\"],\n    [\"BPM\", \"Whose Streets? \", \"Upgrade\"],\n    [\"Guardians of the Galaxy Vol. 2 \", \"Blindspotting\", \" Under the Silver Lake\", \"Columbus\", \"Avengers: Infinity War\"],\n    [\"Brawl in Cell Block 99 \", \"Nocturama\", \"The Post \"]\n]","bc9fd382":"popular_interests = Counter(interest\n                            for user_interests in users_interests\n                            for interest in user_interests).most_common()\n\nprint(\"___________Popular Interests :________________\")\nprint(popular_interests)\n\ndef most_popular_new_interests(user_interests, max_results=5):\n    suggestions = [(interest, frequency)\n                   for interest, frequency in popular_interests\n                   if interest not in user_interests]\n    return suggestions[:max_results]\n\nprint(\"___________Most Popular New Interests___________\")\nprint(\"already like:\", [\"Annihilation\", \"Avengers: Infinity War\", \"Roma\", \"Blindspotting\", \" Under the Silver Lake\"])\nprint(most_popular_new_interests([\"Annihilation\", \"Avengers: Infinity War\", \"Roma\", \"Blindspotting\", \" Under the Silver Lake\"]))\nprint()\nprint(\"___________already like:___________\", [\"Whose Streets? \", \"Upgrade\", \"bahubaali\", \"Nocturama\", \"demons\"])\nprint(most_popular_new_interests([\"Whose Streets? \", \"Upgrade\", \"bahubaali\", \"Nocturama\", \"demons\"]))\nprint()\n","74ca780a":"#\n# user-based filtering\n#\n\ndef cosine_similarity(v, w):\n    return dot(v, w) \/ math.sqrt(dot(v, v) * dot(w, w))\n\nunique_interests = sorted(list({ interest\n                                 for user_interests in users_interests\n                                 for interest in user_interests }))\n\ndef make_user_interest_vector(user_interests):\n    \"\"\"given a list of interests, produce a vector whose i-th element is 1\n    if unique_interests[i] is in the list, 0 otherwise\"\"\"\n    return [1 if interest in user_interests else 0\n            for interest in unique_interests]\n\nuser_interest_matrix = list(map(make_user_interest_vector, users_interests))\n\nuser_similarities = [[cosine_similarity(interest_vector_i, interest_vector_j)\n                      for interest_vector_j in user_interest_matrix]\n                     for interest_vector_i in user_interest_matrix]\n\ndef most_similar_users_to(user_id):\n    pairs = [(other_user_id, similarity)                      # find other\n             for other_user_id, similarity in                 # users with\n                enumerate(user_similarities[user_id])         # nonzero\n             if user_id != other_user_id and similarity > 0]  # similarity\n\n    return sorted(pairs,                                      # sort them\n                  key=lambda pair: pair[1],                   # most similar\n                  reverse=True)                               # first\n\n\ndef user_based_suggestions(user_id, include_current_interests=False):\n    # sum up the similarities\n    suggestions = defaultdict(float)\n    for other_user_id, similarity in most_similar_users_to(user_id):\n        for interest in users_interests[other_user_id]:\n            suggestions[interest] += similarity\n\n    # convert them to a sorted list\n    suggestions = sorted(suggestions.items(),\n                         key=lambda pair: pair[1],\n                         reverse=True)\n\n    # and (maybe) exclude already-interests\n    if include_current_interests:\n        return suggestions\n    else:\n        return [(suggestion, weight)\n                for suggestion, weight in suggestions\n                if suggestion not in users_interests[user_id]]","87519f02":"interest_user_matrix = [[user_interest_vector[j]\n                         for user_interest_vector in user_interest_matrix]\n                        for j, _ in enumerate(unique_interests)]\n\ninterest_similarities = [[cosine_similarity(user_vector_i, user_vector_j)\n                          for user_vector_j in interest_user_matrix]\n                         for user_vector_i in interest_user_matrix]\n\ndef most_similar_interests_to(interest_id):\n    similarities = interest_similarities[interest_id]\n    pairs = [(unique_interests[other_interest_id], similarity)\n             for other_interest_id, similarity in enumerate(similarities)\n             if interest_id != other_interest_id and similarity > 0]\n    return sorted(pairs,\n                  key=lambda pair: pair[1],\n                  reverse=True)\n\ndef item_based_suggestions(user_id, include_current_interests=False):\n    suggestions = defaultdict(float)\n    user_interest_vector = user_interest_matrix[user_id]\n    for interest_id, is_interested in enumerate(user_interest_vector):\n        if is_interested == 1:\n            similar_interests = most_similar_interests_to(interest_id)\n            for interest, similarity in similar_interests:\n                suggestions[interest] += similarity\n\n    suggestions = sorted(suggestions.items(),\n                         key=lambda pair: pair[1],\n                         reverse=True)\n\n    if include_current_interests:\n        return suggestions\n    else:\n        return [(suggestion, weight)\n                for suggestion, weight in suggestions\n                if suggestion not in users_interests[user_id]]","727311a1":"\n    print(\"User based similarity\")\n    print(\"most similar to 0\")\n    print(most_similar_users_to(0))\n\n    print(\"Suggestions for 0\")\n    print(user_based_suggestions(0))\n    print()\n\n    print(\"Item based similarity\")\n    print(\"most similar to '  The Favourite'\")\n    print(most_similar_interests_to(0))\n    print()\n\n    print(\"suggestions for user 0\")\n    print(item_based_suggestions(0))","7d27b0e4":"Now, that we have entered the data we will find the most popular movies. We calculate the most popular interests and then the 'most popular new interests' on the basis of the data using frequency analysis.","2bd2a935":"# Details about the notebook:\n* **Introduction:** The notebook implements a basic recommendation system using the cosine similarity and concepts of linear algebra\n* **Load:** The first step is to import the required libraries and to feed the data\n\n* **Functions:** Next we program our mathematical functions to calculate the cosine similarity in order to make recommendations based on the fed data.\n\n* **Results:** On running the code we see the recommendations for a particular user.\n\n\n"}}