{"cell_type":{"aca79270":"code","550a1b58":"code","618f71eb":"code","004dfe02":"code","c1a2dadc":"code","226227c2":"code","9a232889":"code","c70eae09":"code","b075eb4a":"code","8de08a4d":"code","dce95867":"code","bbe099ab":"code","3b55aacc":"code","917361ed":"code","bf9a2144":"code","537c2dbf":"code","e8c206a4":"code","623a268c":"code","36cde51d":"code","0ca1dbe3":"code","73c1f73d":"code","850c1663":"code","2cb1ad38":"code","4e39046b":"code","508c4fa1":"code","bde8a05d":"code","a93ba966":"code","aa46eb13":"code","21a7aad5":"code","af1b6438":"code","3e8da58d":"code","18685249":"code","e4a58e41":"code","fec819eb":"code","170f02e8":"code","8937a5d9":"code","e3634059":"code","4807a37a":"code","b832562a":"code","4294b3d2":"code","6e0fd6ee":"code","2de7d0c1":"code","3e840677":"code","a6eb2ffe":"code","5f923c1d":"code","e5b1bf99":"code","11851539":"code","1534043d":"code","86e6b6f7":"code","b0c263c6":"code","c3963f95":"code","217b2f4f":"code","00187911":"code","b1088887":"code","1f7f0dfe":"code","061106e0":"code","53e93c33":"code","01c63aef":"code","4d501002":"code","d9ec6991":"code","db2782ab":"code","85a48264":"code","99777184":"code","7db0baf4":"code","f7212bb5":"code","b3463096":"code","9c64c5fc":"code","4fc932b8":"code","34460b8e":"code","f4c0fd33":"code","2fb9774a":"code","0b18bb59":"code","b8ea7332":"code","f6281a7c":"code","feb82b1f":"code","2c268c80":"code","3c687654":"code","810039d0":"code","5d900892":"code","9a13919e":"code","a6844776":"code","64ac7216":"code","3f385903":"code","d76974b0":"code","b1881797":"code","045413dc":"code","d6a5b96a":"code","51aec060":"code","7646eca4":"code","a12529ac":"code","e9e09ebf":"code","68042a87":"code","b5abb697":"code","66684200":"code","80759fff":"code","28ef1b4b":"code","bf3dc765":"code","cfd49c77":"code","f2a9f495":"code","17c25b9c":"code","4979b89c":"markdown","ccc06176":"markdown","bd2d9536":"markdown","1d5a83d6":"markdown","66a36167":"markdown","c9f3d1f6":"markdown","007161b5":"markdown","4160ed5e":"markdown","1dcbf456":"markdown","9ce60844":"markdown","3e0a42db":"markdown","2d620660":"markdown","e3c22e59":"markdown","58b6fa55":"markdown","5feee404":"markdown","5edf3433":"markdown"},"source":{"aca79270":"import os\nimport random\nimport math\nimport time\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt \nimport matplotlib.colors as mcolors\nimport pandas as pd \nfrom sklearn.linear_model import LinearRegression, BayesianRidge\nfrom sklearn.model_selection import RandomizedSearchCV, train_test_split\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.svm import SVR\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\nimport datetime\nimport operator \nplt.style.use('fivethirtyeight')\n%matplotlib inline\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","550a1b58":"confirmed_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_confirmed_global.csv')\ndeaths_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_deaths_global.csv')\nrecoveries_df = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_time_series\/time_series_covid19_recovered_global.csv')\nlatest_data = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_daily_reports\/10-21-2020.csv')\nus_medical_data = pd.read_csv('https:\/\/raw.githubusercontent.com\/CSSEGISandData\/COVID-19\/master\/csse_covid_19_data\/csse_covid_19_daily_reports_us\/10-21-2020.csv')\napple_mobility = pd.read_csv('https:\/\/covid19-static.cdn-apple.com\/covid19-mobility-data\/2019HotfixDev15\/v3\/en-us\/applemobilitytrends-2020-10-21.csv')","618f71eb":"latest_data.head()","004dfe02":"latest_data.tail()","c1a2dadc":"latest_data.describe()","226227c2":"latest_data.corr()","9a232889":"latest_data.columns","c70eae09":"sns.jointplot(x='Incidence_Rate',y='Case-Fatality_Ratio',data=latest_data)","b075eb4a":"sns.jointplot(x='Confirmed',y='Deaths', data=latest_data)","8de08a4d":"sns.jointplot(x='Recovered',y='Confirmed', data=latest_data)","dce95867":"sns.jointplot(x='Active',y='Confirmed', data=latest_data)","bbe099ab":"sns.jointplot(x='Case-Fatality_Ratio',y='Confirmed', data=latest_data)","3b55aacc":"sns.jointplot(x='Deaths',y='Recovered', data=latest_data)","917361ed":"sns.jointplot(x='Deaths',y='Active', data=latest_data)","bf9a2144":"sns.jointplot(x='Case-Fatality_Ratio',y='Recovered', data=latest_data)","537c2dbf":"sns.jointplot(x='Active',y='Recovered', data=latest_data)","e8c206a4":"sns.jointplot(x='Case-Fatality_Ratio',y='Active', data=latest_data)","623a268c":"confirmed_df.head()","36cde51d":"confirmed_df.tail()","0ca1dbe3":"confirmed_df.corr()","73c1f73d":"confirmed_df.columns","850c1663":"confirmed_df.describe()","2cb1ad38":"us_medical_data.head()","4e39046b":"us_medical_data.tail()","508c4fa1":"us_medical_data.describe()","bde8a05d":"us_medical_data.corr()","a93ba966":"us_medical_data.columns","aa46eb13":"cols = confirmed_df.keys()","21a7aad5":"confirmed = confirmed_df.loc[:, cols[4]:cols[-1]]\ndeaths = deaths_df.loc[:, cols[4]:cols[-1]]\nrecoveries = recoveries_df.loc[:, cols[4]:cols[-1]]","af1b6438":"dates = confirmed.keys()\nworld_cases = []\ntotal_deaths = [] \nmortality_rate = []\nrecovery_rate = [] \ntotal_recovered = [] \ntotal_active = [] \n\nfor i in dates:\n    confirmed_sum = confirmed[i].sum()\n    death_sum = deaths[i].sum()\n    recovered_sum = recoveries[i].sum()\n    \n    # confirmed, deaths, recovered, and active\n    world_cases.append(confirmed_sum)\n    total_deaths.append(death_sum)\n    total_recovered.append(recovered_sum)\n    total_active.append(confirmed_sum-death_sum-recovered_sum)\n    \n    # calculate rates\n    mortality_rate.append(death_sum\/confirmed_sum)\n    recovery_rate.append(recovered_sum\/confirmed_sum)","3e8da58d":"def daily_increase(data):\n    d = [] \n    for i in range(len(data)):\n        if i == 0:\n            d.append(data[0])\n        else:\n            d.append(data[i]-data[i-1])\n    return d \n\ndef moving_average(data, window_size):\n    moving_average = []\n    for i in range(len(data)):\n        if i + window_size < len(data):\n            moving_average.append(np.mean(data[i:i+window_size]))\n        else:\n            moving_average.append(np.mean(data[i:len(data)]))\n    return moving_average","18685249":"# window size\nwindow = 7","e4a58e41":"# confirmed cases\nworld_daily_increase = daily_increase(world_cases)\nworld_confirmed_avg= moving_average(world_cases, window)\nworld_daily_increase_avg = moving_average(world_daily_increase, window)","fec819eb":"# deaths\nworld_daily_death = daily_increase(total_deaths)\nworld_death_avg = moving_average(total_deaths, window)\nworld_daily_death_avg = moving_average(world_daily_death, window)","170f02e8":"# recoveries\nworld_daily_recovery = daily_increase(total_recovered)\nworld_recovery_avg = moving_average(total_recovered, window)\nworld_daily_recovery_avg = moving_average(world_daily_recovery, window)","8937a5d9":"# active \nworld_active_avg = moving_average(total_active, window)\ndays_since_1_22 = np.array([i for i in range(len(dates))]).reshape(-1, 1)\nworld_cases = np.array(world_cases).reshape(-1, 1)\ntotal_deaths = np.array(total_deaths).reshape(-1, 1)\ntotal_recovered = np.array(total_recovered).reshape(-1, 1)","e3634059":"days_in_future = 10\nfuture_forcast = np.array([i for i in range(len(dates)+days_in_future)]).reshape(-1, 1)\nadjusted_dates = future_forcast[:-10]","4807a37a":"start = '1\/22\/2020'\nstart_date = datetime.datetime.strptime(start, '%m\/%d\/%Y')\nfuture_forcast_dates = []\nfor i in range(len(future_forcast)):\n    future_forcast_dates.append((start_date + datetime.timedelta(days=i)).strftime('%m\/%d\/%Y'))","b832562a":"# slightly modify the data to fit the model better (regression models cannot pick the pattern)\nX_train_confirmed, X_test_confirmed, y_train_confirmed, y_test_confirmed = train_test_split(days_since_1_22[50:], world_cases[50:], test_size=0.15, shuffle=False) ","4294b3d2":"# svm_confirmed = svm_search.best_estimator_\nsvm_confirmed = SVR(shrinking=True, kernel='poly',gamma=0.01, epsilon=1,degree=3, C=0.1)\nsvm_confirmed.fit(X_train_confirmed, y_train_confirmed)\nsvm_pred = svm_confirmed.predict(future_forcast)","6e0fd6ee":"# check against testing data\nsvm_test_pred = svm_confirmed.predict(X_test_confirmed)\nplt.plot(y_test_confirmed)\nplt.plot(svm_test_pred)\nplt.legend(['Test Data', 'SVM Predictions'])\nprint('MAE:', mean_absolute_error(svm_test_pred, y_test_confirmed))\nprint('MSE:',mean_squared_error(svm_test_pred, y_test_confirmed))","2de7d0c1":"# transform our data for polynomial regression\npoly = PolynomialFeatures(degree=4)\npoly_X_train_confirmed = poly.fit_transform(X_train_confirmed)\npoly_X_test_confirmed = poly.fit_transform(X_test_confirmed)\npoly_future_forcast = poly.fit_transform(future_forcast)\n\nbayesian_poly = PolynomialFeatures(degree=5)\nbayesian_poly_X_train_confirmed = bayesian_poly.fit_transform(X_train_confirmed)\nbayesian_poly_X_test_confirmed = bayesian_poly.fit_transform(X_test_confirmed)\nbayesian_poly_future_forcast = bayesian_poly.fit_transform(future_forcast)","3e840677":"# polynomial regression\nlinear_model = LinearRegression(normalize=True, fit_intercept=False)\nlinear_model.fit(poly_X_train_confirmed, y_train_confirmed)\ntest_linear_pred = linear_model.predict(poly_X_test_confirmed)\nlinear_pred = linear_model.predict(poly_future_forcast)\nprint('MAE:', mean_absolute_error(test_linear_pred, y_test_confirmed))\nprint('MSE:',mean_squared_error(test_linear_pred, y_test_confirmed))","a6eb2ffe":"print(linear_model.coef_)","5f923c1d":"plt.plot(y_test_confirmed)\nplt.plot(test_linear_pred)\nplt.legend(['Test Data', 'Polynomial Regression Predictions'])","e5b1bf99":"# bayesian ridge polynomial regression\ntol = [1e-6, 1e-5, 1e-4, 1e-3, 1e-2]\nalpha_1 = [1e-7, 1e-6, 1e-5, 1e-4, 1e-3]\nalpha_2 = [1e-7, 1e-6, 1e-5, 1e-4, 1e-3]\nlambda_1 = [1e-7, 1e-6, 1e-5, 1e-4, 1e-3]\nlambda_2 = [1e-7, 1e-6, 1e-5, 1e-4, 1e-3]\nnormalize = [True, False]\n\nbayesian_grid = {'tol': tol, 'alpha_1': alpha_1, 'alpha_2' : alpha_2, 'lambda_1': lambda_1, 'lambda_2' : lambda_2, \n                 'normalize' : normalize}\n\nbayesian = BayesianRidge(fit_intercept=False)\nbayesian_search = RandomizedSearchCV(bayesian, bayesian_grid, scoring='neg_mean_squared_error', cv=3, return_train_score=True, n_jobs=-1, n_iter=40, verbose=1)\nbayesian_search.fit(bayesian_poly_X_train_confirmed, y_train_confirmed)","11851539":"bayesian_confirmed = bayesian_search.best_estimator_\ntest_bayesian_pred = bayesian_confirmed.predict(bayesian_poly_X_test_confirmed)\nbayesian_pred = bayesian_confirmed.predict(bayesian_poly_future_forcast)\nprint('MAE:', mean_absolute_error(test_bayesian_pred, y_test_confirmed))\nprint('MSE:',mean_squared_error(test_bayesian_pred, y_test_confirmed))","1534043d":"plt.plot(y_test_confirmed)\nplt.plot(test_bayesian_pred)\nplt.legend(['Test Data', 'Bayesian Ridge Polynomial Predictions'])","86e6b6f7":"def flatten(arr):\n    a = [] \n    arr = arr.tolist()\n    for i in arr:\n        a.append(i[0])\n    return a","b0c263c6":"adjusted_dates = adjusted_dates.reshape(1, -1)[0]\nplt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, world_cases)\nplt.plot(adjusted_dates, world_confirmed_avg, linestyle='dashed', color='orange')\nplt.title('# of Coronavirus Cases Over Time', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.legend(['Worldwide Coronavirus Cases', 'Moving Average {} Days'.format(window)], prop={'size': 20})\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()\n\nplt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, total_deaths)\nplt.plot(adjusted_dates, world_death_avg, linestyle='dashed', color='orange')\nplt.title('# of Coronavirus Deaths Over Time', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.legend(['Worldwide Coronavirus Deaths', 'Moving Average {} Days'.format(window)], prop={'size': 20})\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()\n\nplt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, total_recovered)\nplt.plot(adjusted_dates, world_recovery_avg, linestyle='dashed', color='orange')\nplt.title('# of Coronavirus Recoveries Over Time', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.legend(['Worldwide Coronavirus Recoveries', 'Moving Average {} Days'.format(window)], prop={'size': 20})\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()\n\nplt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, total_active)\nplt.plot(adjusted_dates, world_active_avg, linestyle='dashed', color='orange')\nplt.title('# of Coronavirus Active Cases Over Time', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Active Cases', size=30)\nplt.legend(['Worldwide Coronavirus Active Cases', 'Moving Average {} Days'.format(window)], prop={'size': 20})\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()","c3963f95":"plt.figure(figsize=(16, 10))\nplt.bar(adjusted_dates, world_daily_increase)\nplt.plot(adjusted_dates, world_daily_increase_avg, color='orange', linestyle='dashed')\nplt.title('World Daily Increases in Confirmed Cases', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.legend(['Moving Average {} Days'.format(window), 'World Daily Increase in COVID-19 Cases'], prop={'size': 20})\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()\n\nplt.figure(figsize=(16, 10))\nplt.bar(adjusted_dates, world_daily_death)\nplt.plot(adjusted_dates, world_daily_death_avg, color='orange', linestyle='dashed')\nplt.title('World Daily Increases in Confirmed Deaths', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.legend(['Moving Average {} Days'.format(window), 'World Daily Increase in COVID-19 Deaths'], prop={'size': 20})\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()\n\nplt.figure(figsize=(16, 10))\nplt.bar(adjusted_dates, world_daily_recovery)\nplt.plot(adjusted_dates, world_daily_recovery_avg, color='orange', linestyle='dashed')\nplt.title('World Daily Increases in Confirmed Recoveries', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.legend(['Moving Average {} Days'.format(window), 'World Daily Increase in COVID-19 Recoveries'], prop={'size': 20})\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()","217b2f4f":"plt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, np.log10(world_cases))\nplt.title('Log of # of Coronavirus Cases Over Time', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()\n\nplt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, np.log10(total_deaths))\nplt.title('Log of # of Coronavirus Deaths Over Time', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()\n\nplt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, np.log10(total_recovered))\nplt.title('Log of # of Coronavirus Recoveries Over Time', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()","00187911":"def country_plot(x, y1, y2, y3, y4, country):\n    # window is set as 14 in in the beginning of the notebook \n    confirmed_avg = moving_average(y1, window)\n    confirmed_increase_avg = moving_average(y2, window)\n    death_increase_avg = moving_average(y3, window)\n    recovery_increase_avg = moving_average(y4, window)\n    \n    plt.figure(figsize=(16, 10))\n    plt.plot(x, y1)\n    plt.plot(x, confirmed_avg, color='red', linestyle='dashed')\n    plt.legend(['{} Confirmed Cases'.format(country), 'Moving Average {} Days'.format(window)], prop={'size': 20})\n    plt.title('{} Confirmed Cases'.format(country), size=30)\n    plt.xlabel('Days Since 1\/22\/2020', size=30)\n    plt.ylabel('# of Cases', size=30)\n    plt.xticks(size=20)\n    plt.yticks(size=20)\n    plt.show()\n\n    plt.figure(figsize=(16, 10))\n    plt.bar(x, y2)\n    plt.plot(x, confirmed_increase_avg, color='red', linestyle='dashed')\n    plt.legend(['Moving Average {} Days'.format(window), '{} Daily Increase in Confirmed Cases'.format(country)], prop={'size': 20})\n    plt.title('{} Daily Increases in Confirmed Cases'.format(country), size=30)\n    plt.xlabel('Days Since 1\/22\/2020', size=30)\n    plt.ylabel('# of Cases', size=30)\n    plt.xticks(size=20)\n    plt.yticks(size=20)\n    plt.show()\n\n    plt.figure(figsize=(16, 10))\n    plt.bar(x, y3)\n    plt.plot(x, death_increase_avg, color='red', linestyle='dashed')\n    plt.legend(['Moving Average {} Days'.format(window), '{} Daily Increase in Confirmed Deaths'.format(country)], prop={'size': 20})\n    plt.title('{} Daily Increases in Deaths'.format(country), size=30)\n    plt.xlabel('Days Since 1\/22\/2020', size=30)\n    plt.ylabel('# of Cases', size=30)\n    plt.xticks(size=20)\n    plt.yticks(size=20)\n    plt.show()\n\n    plt.figure(figsize=(16, 10))\n    plt.bar(x, y4)\n    plt.plot(x, recovery_increase_avg, color='red', linestyle='dashed')\n    plt.legend(['Moving Average {} Days'.format(window), '{} Daily Increase in Confirmed Recoveries'.format(country)], prop={'size': 20})\n    plt.title('{} Daily Increases in Recoveries'.format(country), size=30)\n    plt.xlabel('Days Since 1\/22\/2020', size=30)\n    plt.ylabel('# of Cases', size=30)\n    plt.xticks(size=20)\n    plt.yticks(size=20)\n    plt.show()\n      \n# helper function for getting country's cases, deaths, and recoveries        \ndef get_country_info(country_name):\n    country_cases = []\n    country_deaths = []\n    country_recoveries = []  \n    \n    for i in dates:\n        country_cases.append(confirmed_df[confirmed_df['Country\/Region']==country_name][i].sum())\n        country_deaths.append(deaths_df[deaths_df['Country\/Region']==country_name][i].sum())\n        country_recoveries.append(recoveries_df[recoveries_df['Country\/Region']==country_name][i].sum())\n    return (country_cases, country_deaths, country_recoveries)\n    \n    \ndef country_visualizations(country_name):\n    country_info = get_country_info(country_name)\n    country_cases = country_info[0]\n    country_deaths = country_info[1]\n    country_recoveries = country_info[2]\n    \n    country_daily_increase = daily_increase(country_cases)\n    country_daily_death = daily_increase(country_deaths)\n    country_daily_recovery = daily_increase(country_recoveries)\n    \n    country_plot(adjusted_dates, country_cases, country_daily_increase, country_daily_death, country_daily_recovery, country_name)","b1088887":"countries = ['US', 'Russia', 'India', 'Brazil', 'South Africa', 'China', 'Italy',\n             'Germany', 'Spain', 'France', 'United Kingdom', 'Peru', 'Mexico', 'Colombia', 'Saudi Arabia', 'Iran', 'Bangladesh',\n            'Pakistan', 'Turkey', 'Philippines', 'Iraq', 'Indonesia', 'Israel', 'Ukraine', 'Ecuador', 'Bolivia', 'Netherlands', 'Belgium'] \n\nfor country in countries:\n    country_visualizations(country)","1f7f0dfe":"# Country Comparison\n# removed redundant code\n\ncompare_countries = ['US', 'Brazil', 'India', 'Russia', 'South Africa'] \ngraph_name = ['Coronavirus Confirmed Cases', 'Coronavirus Confirmed Deaths', 'Coronavirus Confirmed Recoveries']\n\nfor num in range(3):\n    plt.figure(figsize=(16, 10))\n    for country in compare_countries:\n        plt.plot(get_country_info(country)[num])\n    plt.legend(compare_countries, prop={'size': 20})\n    plt.xlabel('Days since 3\/1', size=30)\n    plt.ylabel('# of Cases', size=30)\n    plt.title(graph_name[num], size=30)\n    plt.xticks(size=20)\n    plt.yticks(size=20)\n    plt.show()","061106e0":"def plot_predictions(x, y, pred, algo_name, color):\n    plt.figure(figsize=(16, 10))\n    plt.plot(x, y)\n    plt.plot(future_forcast, pred, linestyle='dashed', color=color)\n    plt.title('Worldwide Coronavirus Cases Over Time', size=30)\n    plt.xlabel('Days Since 1\/22\/2020', size=30)\n    plt.ylabel('# of Cases', size=30)\n    plt.legend(['Confirmed Cases', algo_name], prop={'size': 20})\n    plt.xticks(size=20)\n    plt.yticks(size=20)\n    plt.show()","53e93c33":"plot_predictions(adjusted_dates, world_cases, svm_pred, 'SVM Predictions', 'purple')","01c63aef":"plot_predictions(adjusted_dates, world_cases, linear_pred, 'Polynomial Regression Predictions', 'orange')","4d501002":"plot_predictions(adjusted_dates, world_cases, bayesian_pred, 'Bayesian Ridge Regression Predictions', 'green')","d9ec6991":"# Future predictions using SVM \nsvm_df = pd.DataFrame({'Date': future_forcast_dates[-10:], 'SVM Predicted # of Confirmed Cases Worldwide': np.round(svm_pred[-10:])})\nsvm_df.style.background_gradient(cmap='Reds')","db2782ab":"# Future predictions using polynomial regression\nlinear_pred = linear_pred.reshape(1,-1)[0]\nlinear_df = pd.DataFrame({'Date': future_forcast_dates[-10:], 'Polynomial Predicted # of Confirmed Cases Worldwide': np.round(linear_pred[-10:])})\nlinear_df.style.background_gradient(cmap='Reds')","85a48264":"# Future predictions using Bayesian Ridge \nbayesian_df = pd.DataFrame({'Date': future_forcast_dates[-10:], 'Bayesian Ridge Predicted # of Confirmed Cases Worldwide': np.round(bayesian_pred[-10:])})\nbayesian_df.style.background_gradient(cmap='Reds')","99777184":"mean_mortality_rate = np.mean(mortality_rate)\nplt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, mortality_rate, color='orange')\nplt.axhline(y = mean_mortality_rate,linestyle='--', color='black')\nplt.title('Worldwide Mortality Rate of Coronavirus Over Time', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('Case Mortality Rate', size=30)\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()","7db0baf4":"mean_recovery_rate = np.mean(recovery_rate)\nplt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, recovery_rate, color='blue')\nplt.title('Worldwide Recovery Rate of Coronavirus Over Time', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('Case Recovery Rate', size=30)\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()","f7212bb5":"plt.figure(figsize=(16, 10))\nplt.plot(adjusted_dates, total_deaths, color='r')\nplt.plot(adjusted_dates, total_recovered, color='green')\nplt.legend(['death', 'recoveries'], loc='best', fontsize=25)\nplt.title('Worldwide Coronavirus Cases', size=30)\nplt.xlabel('Days Since 1\/22\/2020', size=30)\nplt.ylabel('# of Cases', size=30)\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()","b3463096":"plt.figure(figsize=(16, 10))\nplt.plot(total_recovered, total_deaths)\nplt.title('# of Coronavirus Deaths vs. # of Coronavirus Recoveries', size=30)\nplt.xlabel('# of Coronavirus Recoveries', size=30)\nplt.ylabel('# of Coronavirus Deaths', size=30)\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()","9c64c5fc":"unique_countries =  list(latest_data['Country_Region'].unique())","4fc932b8":"country_confirmed_cases = []\ncountry_death_cases = [] \ncountry_active_cases = []\ncountry_recovery_cases = []\ncountry_incidence_rate = [] \ncountry_mortality_rate = [] \n\nno_cases = []\nfor i in unique_countries:\n    cases = latest_data[latest_data['Country_Region']==i]['Confirmed'].sum()\n    if cases > 0:\n        country_confirmed_cases.append(cases)\n    else:\n        no_cases.append(i)\n        \nfor i in no_cases:\n    unique_countries.remove(i)\n    \n# sort countries by the number of confirmed cases\nunique_countries = [k for k, v in sorted(zip(unique_countries, country_confirmed_cases), key=operator.itemgetter(1), reverse=True)]\nfor i in range(len(unique_countries)):\n    country_confirmed_cases[i] = latest_data[latest_data['Country_Region']==unique_countries[i]]['Confirmed'].sum()\n    country_death_cases.append(latest_data[latest_data['Country_Region']==unique_countries[i]]['Deaths'].sum())\n    country_recovery_cases.append(latest_data[latest_data['Country_Region']==unique_countries[i]]['Recovered'].sum())\n    country_active_cases.append(latest_data[latest_data['Country_Region']==unique_countries[i]]['Active'].sum())\n    country_incidence_rate.append(latest_data[latest_data['Country_Region']==unique_countries[i]]['Incidence_Rate'].sum())\n    country_mortality_rate.append(country_death_cases[i]\/country_confirmed_cases[i])","34460b8e":"country_df = pd.DataFrame({'Country Name': unique_countries, 'Number of Confirmed Cases': country_confirmed_cases,\n                          'Number of Deaths': country_death_cases, 'Number of Recoveries' : country_recovery_cases, \n                          'Number of Active Cases' : country_active_cases, 'Incidence Rate' : country_incidence_rate,\n                          'Mortality Rate': country_mortality_rate})\n# number of cases per country\/region\n\ncountry_df.style.background_gradient(cmap='Oranges')","f4c0fd33":"unique_provinces =  list(latest_data['Province_State'].unique())","2fb9774a":"province_confirmed_cases = []\nprovince_country = [] \nprovince_death_cases = [] \n# province_recovery_cases = []\nprovince_active = [] \nprovince_incidence_rate = []\nprovince_mortality_rate = [] \n\nno_cases = [] \nfor i in unique_provinces:\n    cases = latest_data[latest_data['Province_State']==i]['Confirmed'].sum()\n    if cases > 0:\n        province_confirmed_cases.append(cases)\n    else:\n        no_cases.append(i)\n \n# remove areas with no confirmed cases\nfor i in no_cases:\n    unique_provinces.remove(i)\n    \nunique_provinces = [k for k, v in sorted(zip(unique_provinces, province_confirmed_cases), key=operator.itemgetter(1), reverse=True)]\nfor i in range(len(unique_provinces)):\n    province_confirmed_cases[i] = latest_data[latest_data['Province_State']==unique_provinces[i]]['Confirmed'].sum()\n    province_country.append(latest_data[latest_data['Province_State']==unique_provinces[i]]['Country_Region'].unique()[0])\n    province_death_cases.append(latest_data[latest_data['Province_State']==unique_provinces[i]]['Deaths'].sum())\n#     province_recovery_cases.append(latest_data[latest_data['Province_State']==unique_provinces[i]]['Recovered'].sum())\n    province_active.append(latest_data[latest_data['Province_State']==unique_provinces[i]]['Active'].sum())\n    province_incidence_rate.append(latest_data[latest_data['Province_State']==unique_provinces[i]]['Incidence_Rate'].sum())\n    province_mortality_rate.append(province_death_cases[i]\/province_confirmed_cases[i])","0b18bb59":"# number of cases per province\/state\/city top 100 \nprovince_limit = 100 \nprovince_df = pd.DataFrame({'Province\/State Name': unique_provinces[:province_limit], 'Country': province_country[:province_limit], 'Number of Confirmed Cases': province_confirmed_cases[:province_limit],\n                          'Number of Deaths': province_death_cases[:province_limit],'Number of Active Cases' : province_active[:province_limit], \n                            'Incidence Rate' : province_incidence_rate[:province_limit], 'Mortality Rate': province_mortality_rate[:province_limit]})\n# number of cases per country\/region\n\nprovince_df.style.background_gradient(cmap='Oranges')","b8ea7332":"# return the data table with province\/state info for a given country\ndef country_table(country_name):\n    states = list(latest_data[latest_data['Country_Region']==country_name]['Province_State'].unique())\n    state_confirmed_cases = []\n    state_death_cases = [] \n    # state_recovery_cases = []\n    state_active = [] \n    state_incidence_rate = [] \n    state_mortality_rate = [] \n\n    no_cases = [] \n    for i in states:\n        cases = latest_data[latest_data['Province_State']==i]['Confirmed'].sum()\n        if cases > 0:\n            state_confirmed_cases.append(cases)\n        else:\n            no_cases.append(i)\n\n    # remove areas with no confirmed cases\n    for i in no_cases:\n        states.remove(i)\n\n    states = [k for k, v in sorted(zip(states, state_confirmed_cases), key=operator.itemgetter(1), reverse=True)]\n    for i in range(len(states)):\n        state_confirmed_cases[i] = latest_data[latest_data['Province_State']==states[i]]['Confirmed'].sum()\n        state_death_cases.append(latest_data[latest_data['Province_State']==states[i]]['Deaths'].sum())\n    #     state_recovery_cases.append(latest_data[latest_data['Province_State']==states[i]]['Recovered'].sum())\n        state_active.append(latest_data[latest_data['Province_State']==states[i]]['Active'].sum())\n        state_incidence_rate.append(latest_data[latest_data['Province_State']==states[i]]['Incidence_Rate'].sum())\n        state_mortality_rate.append(state_death_cases[i]\/state_confirmed_cases[i])\n        \n      \n    state_df = pd.DataFrame({'State Name': states, 'Number of Confirmed Cases': state_confirmed_cases,\n                              'Number of Deaths': state_death_cases, 'Number of Active Cases' : state_active, \n                             'Incidence Rate' : state_incidence_rate, 'Mortality Rate': state_mortality_rate})\n    # number of cases per country\/region\n    return state_df","f6281a7c":"us_table = country_table('US')\nus_table.style.background_gradient(cmap='Oranges')","feb82b1f":"brazil_table = country_table('Brazil')\nbrazil_table.style.background_gradient(cmap='Oranges')","2c268c80":"india_table = country_table('India')\nindia_table.style.background_gradient(cmap='Oranges')","3c687654":"russia_table = country_table('Russia')\nrussia_table.style.background_gradient(cmap='Oranges')","810039d0":"china_table = country_table('China')\nchina_table.style.background_gradient(cmap='Oranges')","5d900892":"total_world_cases = np.sum(country_confirmed_cases)\nus_confirmed = latest_data[latest_data['Country_Region']=='US']['Confirmed'].sum()\noutside_us_confirmed = total_world_cases - us_confirmed\n\nplt.figure(figsize=(16, 9))\nplt.barh('United States', us_confirmed)\nplt.barh('Outside United States', outside_us_confirmed)\nplt.title('# of Total Coronavirus Confirmed Cases', size=20)\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()\n\n\nplt.figure(figsize=(16, 9))\nplt.barh('United States', us_confirmed\/total_world_cases)\nplt.barh('Outside United States', outside_us_confirmed\/total_world_cases)\nplt.title('# of Coronavirus Confirmed Cases Expressed in Percentage', size=20)\nplt.xticks(size=20)\nplt.yticks(size=20)\nplt.show()","9a13919e":"print('Outside United States {} cases ({}%):'.format(outside_us_confirmed, np.round((outside_us_confirmed\/total_world_cases)*100, 1)))\nprint('United States {} cases ({}%)'.format(us_confirmed, np.round((us_confirmed\/total_world_cases)*100, 1)))\nprint('Total: {} cases'.format(total_world_cases))","a6844776":"# to the other category\nvisual_unique_countries = [] \nvisual_confirmed_cases = []\nothers = np.sum(country_confirmed_cases[10:])\n\nfor i in range(len(country_confirmed_cases[:10])):\n    visual_unique_countries.append(unique_countries[i])\n    visual_confirmed_cases.append(country_confirmed_cases[i])\n    \nvisual_unique_countries.append('Others')\nvisual_confirmed_cases.append(others)","64ac7216":"def plot_bar_graphs(x, y, title):\n    plt.figure(figsize=(16, 12))\n    plt.barh(x, y)\n    plt.title(title, size=20)\n    plt.xticks(size=20)\n    plt.yticks(size=20)\n    plt.show()\n    \n# good for a lot x values \ndef plot_bar_graphs_tall(x, y, title):\n    plt.figure(figsize=(19, 18))\n    plt.barh(x, y)\n    plt.title(title, size=25)\n    plt.xticks(size=25)\n    plt.yticks(size=25)\n    plt.show()","3f385903":"plot_bar_graphs(visual_unique_countries, visual_confirmed_cases, '# of Covid-19 Confirmed Cases in Countries\/Regions')","d76974b0":"log_country_confirmed_cases = [math.log10(i) for i in visual_confirmed_cases]\nplot_bar_graphs(visual_unique_countries, log_country_confirmed_cases, 'Common Log # of Coronavirus Confirmed Cases in Countries\/Regions')","b1881797":"# Only show 10 provinces with the most confirmed cases, the rest are grouped into the other category\nvisual_unique_provinces = [] \nvisual_confirmed_cases2 = []\nothers = np.sum(province_confirmed_cases[10:])\nfor i in range(len(province_confirmed_cases[:10])):\n    visual_unique_provinces.append(unique_provinces[i])\n    visual_confirmed_cases2.append(province_confirmed_cases[i])\n\nvisual_unique_provinces.append('Others')\nvisual_confirmed_cases2.append(others)","045413dc":"plot_bar_graphs(visual_unique_provinces, visual_confirmed_cases2, '# of Coronavirus Confirmed Cases in Provinces\/States')","d6a5b96a":"log_province_confirmed_cases = [math.log10(i) for i in visual_confirmed_cases2]\nplot_bar_graphs(visual_unique_provinces, log_province_confirmed_cases, 'Log of # of Coronavirus Confirmed Cases in Provinces\/States')","51aec060":"def plot_pie_charts(x, y, title):\n    # more muted color \n    c = ['lightcoral', 'rosybrown', 'sandybrown', 'navajowhite', 'gold',\n        'khaki', 'lightskyblue', 'turquoise', 'lightslategrey', 'thistle', 'pink']\n    plt.figure(figsize=(20,15))\n    plt.title(title, size=20)\n    plt.pie(y, colors=c,shadow=True, labels=y)\n    plt.legend(x, loc='best', fontsize=12)\n    plt.show()","7646eca4":"plot_pie_charts(visual_unique_countries, visual_confirmed_cases, 'Covid-19 Confirmed Cases per Country')","a12529ac":"plot_pie_charts(visual_unique_provinces, visual_confirmed_cases2, 'Covid-19 Confirmed Cases per State\/Province\/Region')","e9e09ebf":"# Plotting countries with regional data using a pie chart \n\ndef plot_pie_country_with_regions(country_name, title):\n    regions = list(latest_data[latest_data['Country_Region']==country_name]['Province_State'].unique())\n    confirmed_cases = []\n    no_cases = [] \n    for i in regions:\n        cases = latest_data[latest_data['Province_State']==i]['Confirmed'].sum()\n        if cases > 0:\n            confirmed_cases.append(cases)\n        else:\n            no_cases.append(i)\n\n    # remove areas with no confirmed cases\n    for i in no_cases:\n        regions.remove(i)\n\n    # only show the top 5 states\n    regions = [k for k, v in sorted(zip(regions, confirmed_cases), key=operator.itemgetter(1), reverse=True)]\n\n    for i in range(len(regions)):\n        confirmed_cases[i] = latest_data[latest_data['Province_State']==regions[i]]['Confirmed'].sum()  \n    \n    # additional province\/state will be considered \"others\"\n    \n    if(len(regions)>5):\n        regions_5 = regions[:5]\n        regions_5.append('Others')\n        confirmed_cases_5 = confirmed_cases[:5]\n        confirmed_cases_5.append(np.sum(confirmed_cases[5:]))\n        plot_pie_charts(regions_5,confirmed_cases_5, title)\n    else:\n        plot_pie_charts(regions,confirmed_cases, title)","68042a87":"pie_chart_countries = ['US', 'Brazil', 'Russia', 'India', 'Peru', 'Mexico', 'Canada', \n                       'Australia', 'China', 'Italy', 'Germany', 'France', 'United Kingdom', 'Chile', 'Colombia']\n\nfor i in pie_chart_countries:\n    plot_pie_country_with_regions(i, 'Covid-19 Confirmed Cases in {}'.format(i))","b5abb697":"# Replace nan with 0\nus_medical_data.fillna(value=0, inplace=True)\n\ndef plot_us_medical_data():\n    states = us_medical_data['Province_State'].unique()\n    testing_number = []\n    testing_rate = []\n    \n    for i in states:\n        testing_number.append(us_medical_data[us_medical_data['Province_State']==i]['People_Tested'].sum())\n        testing_rate.append(us_medical_data[us_medical_data['Province_State']==i]['Testing_Rate'].max())\n    \n    # only show the top 15 states\n    testing_states = [k for k, v in sorted(zip(states, testing_number), key=operator.itemgetter(1), reverse=True)]\n    testing_rate_states = [k for k, v in sorted(zip(states, testing_rate), key=operator.itemgetter(1), reverse=True)]\n  \n    for i in range(len(states)):\n        testing_number[i] = us_medical_data[us_medical_data['Province_State']==testing_states[i]]['People_Tested'].sum()\n        testing_rate[i] = us_medical_data[us_medical_data['Province_State']==testing_rate_states[i]]['Testing_Rate'].sum()\n    \n    top_limit = 30 \n    \n    plot_bar_graphs_tall(testing_states[:top_limit], testing_number[:top_limit], 'Total Testing per State (Top 30)')\n    plot_bar_graphs_tall(testing_rate_states[:top_limit], testing_rate[:top_limit], 'Testing Rate per 100,000 People (Top 30)')\nplot_us_medical_data()","66684200":"def get_mobility_by_state(transport_type, state, day):\n    return apple_mobility[apple_mobility['sub-region']==state][apple_mobility['transportation_type']==transport_type].sum()[day]","80759fff":"apple_mobility.head()","28ef1b4b":"# sample testing \nget_mobility_by_state('walking', 'Connecticut', '2020-07-30')","bf3dc765":"# revising date to fit with the mobility format \nrevised_dates = []\nfor i in range(len(dates)):\n    revised_dates.append(datetime.datetime.strptime(dates[i], '%m\/%d\/%y').strftime('%Y-%m-%d'))","cfd49c77":"# returns true if it is a weekend, and false if it is a weekday \ndef weekday_or_weekend(date):\n    date_obj = datetime.datetime.strptime(date, '%Y-%m-%d')\n    day_of_the_week =  date_obj.weekday()\n    if (day_of_the_week+1) % 6 == 0 or (day_of_the_week+1) % 7 == 0:\n        return True \n    else:\n        return False ","f2a9f495":"revised_day_since_1_22 = [i for i in range(len(revised_dates))]","17c25b9c":"import matplotlib.dates as mdates\nstates = ['New York', 'Connecticut', 'Florida', 'California', 'Texas', 'Georgia', 'Arizona', 'Illinois', 'Louisiana', 'Ohio',\n          'Tennessee', 'North Carolina', 'South Carolina', 'Alabama', 'Missouri', 'Kansas', 'Pennsylvania', 'Wisconsin', 'Virginia', 'Massachusetts', 'Utah', 'Minnesota',\n         'Oklahoma', 'Iowa', 'Arkansas', 'Kentucky', 'Puerto Rico', 'Colorado', 'New Jersey', 'Idaho', 'New Jersey', 'Nevada', 'Maryland']\nstates.sort()\n\n# making sure the dates are in sync \nmobility_latest_date = apple_mobility.columns[-1]\nmobility_latest_index = revised_dates.index(mobility_latest_date)\n\nfor state in states:\n    # weekend and weekday mobility are separated \n    weekday_mobility = []\n    weekday_mobility_dates = [] \n    weekend_mobility = [] \n    weekend_mobility_dates = [] \n    \n    for i in range(len(revised_dates)):\n        if i <= mobility_latest_index:\n            if weekday_or_weekend(revised_dates[i]):\n                weekend_mobility.append(get_mobility_by_state('walking', state, revised_dates[i]))\n                weekend_mobility_dates.append(i)\n            else:\n                weekday_mobility.append(get_mobility_by_state('walking', state, revised_dates[i]))\n                weekday_mobility_dates.append(i)\n        else:\n            pass\n        \n    # remove null values (they are counted as 0)\n    for i in range(len(weekend_mobility)):       \n        if weekend_mobility[i] == 0 and i != 0:\n            weekend_mobility[i] = weekend_mobility[i-1]\n        elif weekend_mobility[i] == 0 and i == 0:\n            weekend_mobility[i] = weekend_mobility[i+1]\n        else:\n            pass\n        \n    for i in range(len(weekday_mobility)):       \n        if weekday_mobility[i] == 0 and i != 0:\n            weekday_mobility[i] = weekday_mobility[i-1]\n        elif weekday_mobility[i] == 0 and i == 0:\n            weekday_mobility[i] = weekday_mobility[i+1]\n        else:\n            pass\n    \n    \n    weekday_mobility_average = moving_average(weekday_mobility, 7)\n    weekend_mobility_average = moving_average(weekend_mobility, 7)\n    \n    plt.figure(figsize=(16, 10))\n    plt.bar(weekday_mobility_dates, weekday_mobility, color='cornflowerblue')\n    plt.plot(weekday_mobility_dates, weekday_mobility_average, color='green')\n    \n    plt.bar(weekend_mobility_dates, weekend_mobility, color='salmon')\n    plt.plot(weekend_mobility_dates, weekend_mobility_average, color='black')\n    \n    plt.legend(['Moving average (7 days) weekday mobility', 'Moving Average (7 days) weekend mobility', 'Weekday mobility', 'Weekend mobility'], prop={'size': 25})\n    plt.title('{} Walking Mobility Data'.format(state), size=25)\n    plt.xlabel('Days since 1\/22', size=25)\n    plt.ylabel('Mobility Value', size=25)\n    plt.xticks(size=25)\n    plt.yticks(size=25)\n    plt.show()","4979b89c":"## Importing All Essential Libraries\n1. A (software) library is a collection of files (called modules) that contains functions for use by other programs.\n2. May also contain data values (e.g., numerical constants) and other things.\n3. Library\u2019s contents are supposed to be related, but there\u2019s no way to enforce that.\n4. The Python standard library is an extensive suite of modules that comes with Python itself.\n5. Many additional libraries are available from PyPI (the Python Package Index).","ccc06176":"## Future Forecasting of the COVID 19","bd2d9536":"## Pie-Chart Visualization","1d5a83d6":"## Taking the List of Countries and Specifically Graph them on the Matplotlib","66a36167":"## Get the Daily Increment","c9f3d1f6":"## Getting the table of Contents specifically Countrywise","007161b5":"## Get all the dates for the outbreak of COVID19","4160ed5e":"## Number of confirmed cases, active cases, deaths, recoveries, mortality rate (CFR), and recovery rate","1dcbf456":"## Data Visualization\nData visualization is the discipline of trying to understand data by placing it in a visual context so that patterns, trends and correlations that might not otherwise be detected can be exposed.\n\nPython offers multiple great graphing libraries that come packed with lots of different features. No matter if you want to create interactive, live or highly customized plots python has an excellent library for you.\n\nTo get a little overview here are a few popular plotting libraries:\n- Matplotlib: low level, provides lots of freedom\n- Pandas Visualization: easy to use interface, built on Matplotlib\n- Seaborn: high-level interface, great default styles\n- ggplot: based on R\u2019s ggplot2, uses Grammar of Graphics\n- Plotly: can create interactive plots\n\nIn this article, we will learn how to create basic plots using Matplotlib, Pandas visualization and Seaborn as well as how to use some specific features of each library. This article will focus on the syntax and not on interpreting the graphs, which I will cover in another blog post.\nIn further articles, I will go over interactive plotting tools like Plotly, which is built on D3 and can also be used with JavaScript.","9ce60844":"## Bar Graph Visualization for COVID-19 comparing to USA","3e0a42db":"## Working with Seaborn\n\nMatplotlib has proven to be an incredibly useful and popular visualization tool, but even avid users will admit it often leaves much to be desired. There are several valid complaints about Matplotlib that often come up:\n\n* Prior to version 2.0, Matplotlib's defaults are not exactly the best choices. It was based off of MATLAB circa 1999, and this often shows.\n* Matplotlib's API is relatively low level. Doing sophisticated statistical visualization is possible, but often requires a lot of boilerplate code.\n* Matplotlib predated Pandas by more than a decade, and thus is not designed for use with Pandas DataFrames. In order to visualize data from a Pandas DataFrame, you must extract each Series and often concatenate them together into the right format. It would be nicer to have a plotting library that can intelligently use the DataFrame labels in a plot.\n\n**An answer to these problems is Seaborn. [Seaborn](https:\/\/seaborn.pydata.org\/api.html) provides an API on top of Matplotlib that offers sane choices for plot style and color defaults, defines simple high-level functions for common statistical plot types, and integrates with the functionality provided by Pandas DataFrames.\n\nFor More study on Seaborn, you can go on with the [**`Blog`**](https:\/\/jakevdp.github.io\/PythonDataScienceHandbook\/04.14-visualization-with-seaborn.html) and the [**`Colab Notebook`**](https:\/\/colab.research.google.com\/github\/jakevdp\/PythonDataScienceHandbook\/blob\/master\/notebooks\/04.14-Visualization-With-Seaborn.ipynb) for the Seaborn will be alot helpful.\n\nFor visualization works, we can see the best [`w3schools work`](https:\/\/www.w3schools.com\/python\/numpy_random_seaborn.asp)","2d620660":"### Getting the details of Confirmed cases by Data Frame.","e3c22e59":"## Coronavirus (COVID-19) Visualization & Prediction\nCoronavirus is a family of viruses that are named after their spiky crown. The novel coronavirus, also known as SARS-CoV-2, is a contagious respiratory virus that first reported in Wuhan, China. On 2\/11\/2020, the World Health Organization designated the name COVID-19 for the disease caused by the novel coronavirus. This notebook aims at exploring COVID-19 through data analysis and projections.\n\nCoronavirus Case Data is provided by Johns Hopkins University\n* Mobility data is provided by Apple\n* Learn more from the World Health Organization\n* Learn more from the Centers for Disease Control and Prevention\n![](data:image\/jpeg;base64,\/9j\/4AAQSkZJRgABAQAAAQABAAD\/2wCEAAkGBxAPEBUQEBAWFRUVFRUVFRUWFRUWFRYXFhUWFhcXGBYYHSggGRomHhgXITEhJSkrLi4uFyAzODMtNygtLisBCgoKDg0OGxAQGy0mICUtLy0vMCstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLf\/AABEIAJMBVwMBEQACEQEDEQH\/xAAbAAEAAwEBAQEAAAAAAAAAAAACBAUGAwEHAP\/EADcQAAIBAwMCBQIDBwQDAQAAAAECEQADIQQSMQVBBhMiUWEycRRCgQcjUpGhscFi0eHwcrLxFf\/EABoBAQACAwEAAAAAAAAAAAAAAAADBAECBQb\/xAAyEQACAgEDAgQDBwUBAQAAAAAAAQIDEQQhMRJBBRMiUWFxgTKRobHB0fAUI0Lh8TNS\/9oADAMBAAIRAxEAPwD5EKAQoBCgEKAQoBCgFQCFAICgEKA9AoBAUAhQHoFAICgPQKAsOndPe+dlmC4EmeAKq33dHJ1tFpoyjlck614d1V1jFuIBBPY\/ArWCc1lFm2+FUumRSdQ1zD0XJVgdrT7jEYooYZvPVKUVubTwhqk1Oma3dRQ4DIGXkgYk1XnFqaj2ZmEk4OWF1LJXdc6TcRA12Xs2RIVeZOASfYTV+xPp2OVopQ831lX03UlHZNMvIl2ZoCg8f3\/WoOpxWWzrOmuyTjGOfm+C+0Wvubdu4n1Tj88gcz3+P9J9xUbk8touRprcYqST6SbqvDdm+quV2XOSy4k\/Iq3BZiuo89qLVC1qp+kj3PCF0tlwQeDWXCLIo6myPcrOveG7ukttew6qJPx81mSxHYxVJSszPcp7D2bhUgkz9W0SBUHmTR1Fo9PZJNfgd9Ro2RPMVZyRHcQAZ\/rWrsctmTLRRp\/uRQOma1hLAZHatZRRNTc8NpbnfrFovbS7Edm+9S0S\/wATn+KUtqNuPmU5FWTjHkCDmsGdsANZMBIoDwigDQBNAEigCaAJoAmgCaAJoD8KAQoBCgEKAQoBCgEKAQoBCgEBQCFAIUB0s2ix2jk1hvCyb1wc5KKJRFu20ctHBqu7JPg69ejrrl6t2drVhWSSQGYmB8CtPMkiytFVJZfLF0\/S2\/MU3T+7n1H7cwOa3lc+l45Ka8N9afK7n0TonhG1Zb8VbuHYw9I91Oajhm+vE0az6dLbmD+gfEniizowqgE+4A\/uatRiorCKFk5Tl1M+VdWvNrL7XQm0OwIAE\/ExWHHclhdiGGfTv2d+GrGjRrmpaWYSoyIPJX5+1VtXK2MF5SyyNSzJstdbsLnasoeFP1EfIqejzHWvM5NJNJ7HzDrFkWNWbLoLdtrhcAfm4iT3AM4HzUc4tZZ2dLdGSjFv5\/P4l90fThtSkkoAshIADMu4j5yD9vRUVeG0i7rZSrqlJe2Mffv+JprljahdZJMHOQM\/2q9JbHmINKSyBNddCzeT5AUz2qrXTZCL33Z0LtTTZOOY7Iz\/AFzxJeOmfzLWS+2I\/J8\/pW0YzUMSe5vGdUruqC2RQdIU3PWIRC2FUAACefmoJ7HY0+Z+pbL2RcrdZbW9lbadyg7T7wpI+1a9D5Jv6iC9Le77GftxaEKJYmp4x6t3wcq2\/wAn0w3kIveclYkN2rVNR3RZlGdsema2Zy1WgYDcqnbAqeFqfPJx9XopVvqivSQDUxzzwigCaAJoAmgCaAJoAmgCaAJoDyDQANAfhQCFAIUAhQCFAIUAhQCFAIUAqAQoBCgJGjuhG3e3FR2puJb0M1C1NnPV3ibm4jmq6Wx17J5nklXmUWhcbG0SJmSR\/Yf71qk84JpSiqlJ9is1fUSqhgMMJIPP3FSKHYqW6jCUvc+reHutBtDYRZMWwrTyCBGTU8OMHLvUuvLXJL0ugF22zMquQYKt2FbEJA650jSadvxC3ER0G8W2jaViTAGZIBqOyeFhPcuaXT9bUpxfQ+5F6Z1G5qNUBuhDJ9JAUIBnkyp+R71DCcpTR0tRpaKtO9t0tmWut1TbXhCNgBRpHqnAg\/arZ58+a+I+pNevKly1tNrBkgkqYOI7d60lHJY09qrlvwftF1p7VxhaaHEvuPqG0HJWeSRWkK+l5LOo1qtr6Fnd7n0joF29csq9xVJVyuThrbfTEYmpjnFuunYrsYgtJgD+EMZB9x80Bk\/FXQr7OhtHckFmCZwO8n+1RWwb4L+hvjW2pPCInhvpi2SxvOqruDi2cnHIJ+9QqpyabOhPXQojKNbznj4G\/wBV04G0xX1LEkfBHIq10rBxPMl1dWdz5Z4o6QulYFbkh5IHdahm8ekv6WHU\/Mb3IfR9U3lsyGWGAIx95qvOKydei19Dae5PsW3a35Nwwdskj3+9YUkpZRvZVKyp1y5xkzt22VMEZFX088Hk5wcHiRzNZNQmgCaAJoAmgCaAJoAmgCaAvfDOr09rd56zIxVHV12zx0HT8PtphnzEUuvZWuMUEKTirdaaikyjc4ubceCOK3IhCgGKAQoBCgEKAQoBCgEKAQoBCgOltCxgDNYbxybRg5PEeSVfsLbX1H1e1Qebl7HVjoFCGZv1HbommW7fRGMAt3\/oKXbVtor6ayXmqDZqfEPgl7t5PMvKFYzAXIERHP8AWo9PB9OS3rNVGWxReKvA505Q233oBweamaceCvXOFqSk8Y+4vfCHSUtaddputccEsuNqkMRtH6f2qvHUONjjJE9ul8ylTi+P5gvvEutu2LC\/hQzPthiBuIBycDJP2qR3Kz\/zZrptMqpN3R+WeMnzfXa5tTeXzWcqlsE7gQGZeFbdBjvEZ\/StcNLPcu9UZzUV9lLO3Gfb\/WCy6TdlldAMkTjcQrD6toGZGDHZvvWi2luWJ4spl0pbp\/lyaPU69izAWyADGcDaAPpgZERkVePKFL4k6AmoAvSUdV3TtaGEfm47RTOTLWDPeDVS5qV3qHLLEcIgEeqO+YAFAb\/xh1JdNbFpW2btpIWBChYGf6wPmobnthHR8OglJzmtvjxkmeHuoq9lQX9SCSqyTcCgRyMGcx81iif+LJfE9M01bFbd\/n8ieNULa+hGmS4IG6JHq4PBnj5qwcgzXVtC73vN09s7QzXbiMQsekDbB5mJqGd0INJvksVaeyyLlFbI0PhHq902\/NFoi1O0+YYgd4HtOK2jbGUnFdjFlEoQUn3IHjvwl+IujU6fCN9a\/HuKxZDO6LGk1GPRLgxl\/pd63cGmsrzme2Kgm417yLldsr\/RWsIr3vXbd0235Bj+Va4TWUXVOal0smdasobSXR9RwwqSiTzhlLxamCirFy+SjNWjhhNAE0ATQBNAE0ATQBNAE0ADQHhoDwUAhQCFAIUAxQCFAIUAhQCFAIUAhQEnSsFO4z7CKhue2Do+HwXX154P3UWvC7ken35\/WoIqODqXStVnGxJ6FqtOLyPeb0gzK+496mU+zOdbp4yfXB7n0G\/1UOBcVtwY+knsAKlWMbFGxNS9XJR3bjXL4teZLbhyeQR9IJ+M1HG1OWC5b4fOFXmN\/HHwNL07T3NMHUMH9JMCPSfaSczWfKTn1fDBVWokq\/LXvkz1oXbFx7rEXXMKVBFsKDAyCSJ+cYpXVGtYiL9RO55mcPExtlGuukXAEt7SJWCTywwxjcfiaxZX1bljR6vyvQ0mn79ilt3PKKBFDEsgn1C2pmOe3t\/ioYQcnudLU6quqvEGm2u3Y+hafR27I3C5GxgTLMRmQoI7An2xgVZnHqi0cKuSjJN9iPb0d3UXne5KbXBXfHp9MKIBkksGxIwRVWtf01Tci5c1qrkq+Mf9KO90hNDq2u2zcIKsHPodf42OACoJjj7VYjYpQ6yt5Ddvl574K27dNy4pkxcMKGkgAAyAT8Sf0NVJNttnqK4RrjGC443\/ABK7o18Wt1y2pQ3HKKASpG6cKRkBVEyP81vJvPPBWojWovMftPh\/zsv5ufQrGpsoqMn5iWRgDuJEFgx98n44q1XJSjscPWUSqtaljffbjBws603HNxF2gKVDCGVhM5AyCP8AetZ0xm032NKtROuLjHuWek6ZdewFN9SQw3xEEL6goHz\/AIrdRSeSOU5NJN7I1Whuo079oUqAM49q2NDDdW0C2tXl+QdhHY+01S1kHKOUdXwy2MZOMjLdZ01rT3x6jcZ\/U0xgmo6VKcMvYvWaqFNmMZK27ft3G9cgMYX7\/apYtw4FsK9Qsy2zwV+s0jWjDDng1ZhNS4OHqNNOiWJIimtyuE0ATQBNAE0ATQANAE0ATQBNAeCgGKAQoBCgEKAQoBCgEKAYoBCgJWl0pfPbuajnNRLWm0s7ntwPUKuQvE1Cm5vc6U640RzAjay35gHqII\/rW6ra4K89ZGaWcosR4F1SC26bYuxAJOP6Vs0+5HGyCeYGx1HTvKtppxMgQDyZPNZkko8kVMpWXLbL9jFfii9xrohDbcrMMHGAZAIkSDAqtjp2O31qzLaSxs8mj0vim6LBttZYsgaMKrPkbeO\/I7c1LCzGEyjqdF1ZnBYx2x+X7AsaouN1+3tKwzA5AP1SxiN2OOOO9TnJKPqXVTqbgCbiFWVQ4DHuQOAIP9aAm6USfpUiSBE8jbuwAQ3YjOa0nNQ5LGn0s78qGNjYeHurNfc+YVIQAqRIad0DdnLD59zUdVkpPDLmu0dVMFKD5eDvqr4cNbuXR5iKzEqdhXPpZ\/VDbYHHsTUzSawzmRk4vKIOq0fk6do8xnuW2UlT5xDsYDREqhaSTiJHFZwsYMdTzkyGg6feeyTrIlLosoLiEKsrMqE+oEYBzn3qB0vPpOtX4jFxXmrL+mF+RrekaXS3PMtPaRrmnNswsCEcZXcSc7dpMcn3AraNMUtyK3xK2Uk44SXCx+ZJ1vREJa0nm7Q6hbQYKoMGCCRJTnPuRUkYqKwildfO6XVPkouolbVzzFuOCkIbAhVZoBETzyCePetiIm6PxHcs7T5K7trSCZA\/1YJic1BZb0vCOnpNAro9Ungj9R8Uam9ZupuRdvrVkUiEUSwGf+5+Kidspbe5fjoKa31rt9UWmn6bdvdO81J9Dl1XkyclQfbNb0bp5KviuFKCisPGT54zvduFyD3weRWsnjgloqbSbDpLy3GBY7ShwfmsNNE1co2PfbBd9ZtE2AxJJnmsUP1GfFq80KXJnDV080E0ATQANAE0B+QgEEiR3HvWHwbQaUk2soNwgkkCBOB7UXAk05NpYRzNZNQmgCaA8FAIUAhQCFAIUAxQCFAIUAhQCFATLerNoCO9VrFmR3NFZ5dSx3IL3ne5tH3rCSSybSnKU+lFl0m0GuIrnvLHsAM0U8Gs9KrI47lz1zrd26sbjtSdpUZgfTgTBitHJze5bhRCiL6V9eQnqt17Kvecs4t7c4Mk\/U0ey9+9bynmOCpp9N02ux7bZRVJoWuPc2SbRXLkGN\/cfA4rXdRTwWcxlbKCaxj8RFLzEWltNukKWkCJ4gRPzW0a22Q3a2MYbPf4Gt1GhNywdoV4OZlQkYKS2Af+asZWcHDUXjJnbmkt2tlzcwCybax6oEpt7goff\/eo7LHHZIvaTRxui5ylhL25yc+oakrfVNMFETuUmFVTH8OZLDGDOfmq6WU3I7Em65QhSllc\/L6b8\/Mm2+qvZDecDtIC7lgkNEqV9zg5icxW1LxLYi8Qr66m5LdcP9PuLvS6z1MzoFUW\/MW63lzctkRcV1+piG7dp\/Srh50tOnWrdxVewwV1XaYMF7P5g6gZgBs8xFDBE8QdJbUXU9AazZdHVVQercijbvZto5M47UM8EbTG3Y1abVgFAlq3b2+tLQcMS4MBP3mCckihg0eqtW0Y3H3zdCorbvU8JLOv8IgAcDJmgIniDREoI05bYVHALlSvIEGRJiR8dqA+bdZ0uotXGtlHVrnqG1WKsoGAv8OSarzjh5Z2NPd119EW84+fH5AtLchbWpuC2oA\/djdLie9tSd3Ay2Paom+8S5FSajG17eyzv9F+v3H179nOpGzycbIEAiCQ3Mj4EVLp84eSl4t5fXHpe+OPZdjP+O+l6bS3dtmN1xmJA7e5qO6KTyW\/D7nZDpxsjDa7RLaMm3EESRmfmtVJvuTWVKG+C60mqXUHy0Mwveo8dO5cU43LpXsZnW2Sjsp7HtXQi8rJ4++t12OLIxrYiCaAJoAmgCaABoAmgCaAJoDwUAhQCFAMUAhQCFAIUAhQDFAIUB+dZH24rSUMstU6joWGILkHvWPLQernnKLLpi3HBtWlncQWggHaOc\/7VHOrfKLul1+IuM+5F1xe0u2ySz5OxhOAcwSZ\/vxUUcN+ovXOUI\/2t37c7fz5kS5rSo3KzecMbSDBHBEdiK3UcvHYhnf0x6s+o0PRvMFob7cF2mS\/1dzKxiF\/xViKwsHHvs8yfUabomiDP5iMAFbdLEnIHp\/8YiKg1GoVWMrOSXTaV35w+Cf+KdrX4abe59xMDeiySSADl4GZxE\/FRqCulG2LJJSenUqpRI\/VdFZtIJD3bgQEKnLkkbtsH0gYGO1W3FPkq1X2VZ6HjJQ9b6ANOzNuPnBV3\/uiUVm4iCfpAMj3E4BAqKVXtwdCjxBc2L1e\/wC6\/YqbKzs3fWG9Dz6pB5yOJ5rSMJKZY1Gpqlp3vl9vf6mkt6vT27qW7ykMJvHtuuDuCDBXM4xjn3sN4WWcauDnJRiR9V4je7fewEFsMB6wONo2CW7g4kdxVadjlHY7em0UKrt8t8r2X7nTV6d7el3QpNt7bJuLeXvBCEuQRuWGOIOY9q2062bIfGJZnCPdIj6Cx5D6bz3QX4tOzuZusbjwNOiHhQkmYxNWTjGq0DXL1xtPdRWQKjqs+obiwCBjlcCcGTI+1AddHrtuAzsCAivynoBkLHBEAg\/pQEPrV3U3l8zT7RFsncSPqUtiMCP9XeKw+DeDediT1To\/4vSWG1JC3uQbY+kOv0ZnHuaqRcrvVx+p0o2x0sunkxNzxJd0t1105A2+hGidoByY71um4elEsorUPzZrHw+BT67qt7UAlbhd5ySfUZMmD+nFaY39RYTXQ1Sty10WpV0UFHJiGLAQInvPMSPmonF5L8LVKG6f\/CDo9Va0zF7UyZ54qfyZS5OTHxGqp5gtyu1N4uxc8kzVmKwsHHtsdk3N9ziayRgNAE0ATQBNAE0ATQANAE0B4KAQoDqqekmRggR3zWM74NunbJ+FZNRCgEKAQoBigEKAQoDpbUkwKN4Mxi5PCE6FTBrCknwbzqnD7SNL0MWbSi4HlzAI9pqGM5ubTWxYlVUqVJPc0XUfCHnFbguKgYeqBJ+CPmsyqTeSWnXSrg4vf2Id\/RpbJVEB2+kQJYnH85NSYUUU5WTse7yftWtrzNiqB5YhlBypYZk+\/NE8rKNXFxeJIGlTa6Im6Dt27fqJEk\/qay0nyFJx4eDQWen27e2zu\/eBXJdQdyycgE4YmYH2oklwG5NZY7dtVQXLRFuFALOpa6AXlgeMCFA\/6Tk1Mx4x10gBGyW9TGTBwQAwwSQIjPNAVKEsF23baiVgMd7Hdgxtz3I75oCx6x0y\/cL3APRACjMLCrgIQD9sGq1kJZb7Hb0eoqjUoZxJ7cfmUOs3Xrq20LqysXLpzMQVH+nOWPtEVFH0rJeuTtsUU2sb5X5fu\/wNb0ayzKDKtbW76nD4YAGLZCzJBKHtuKjiKk0\/fYpeLvKj6k3v+P8AwfQugNZt3Ll275mrum4qXCCzKyq22AeWwDHA\/SrRwyV09gmoFsNcuNcUXFlAFItqB6CvLTGTxMd60nZGCzJ4N4Vyn9lFf1e9cvS7WmGzCgnY7OMEttyI7T7n4rZNNZRq008MqNJrmsjy3vPeCoylVX0kEfxT8VrKcY8k9OmttWYI2Ol8aaQJaRhcJ2Dcwt\/SFHqHqO8xB4E1r50c4Jo+H3OOXt8HyZvQ6PRa\/X7rdh1tXWjcHO7dEg7D9IPtUM5JyOlp6JV0OTxnH3Enxp+zP8ADqNDcYmAWtld7c5Kx8H2PFS2RSW\/Bz9NfJy9PLKG9fNqyN87mGNwCsBETAAiq9cOqWUdfWalU09MuZLYoDV48uE0AaAJoAGgCaAJoAmgCaABoAmgPBQDFAIUAhQCFAIUAhQDFAIUAhQE\/pqLli0RxUF0mlhHT8MqjKblLsDUjkg7iaihJo6GoqjYt9yNa6gbZC7PUWXM\/IqZSbZy7NPGCx3PsFqCi3C8gLJHfjtUxSM3o+ot+LGyTG5mgTEA5PtUdnS44l3JKutSzBZaOS2U9Vy2OXBaCTuBWDzWtMFCOEyTVWysn1SWGOxqF37g8JIXg+mIBH3g\/rUxWK7qevdb3mW3DJP1ZCxPqUIuSQZHt3mqTa68pnpYVyemVc4pLGH++3f8AU6aPrQa2VW3v8x2kszL6ipwrk49S8T7\/AKS+c19pFKXhkZLNUvv9\/mZnXanzCfNRraWxLWxcLw2TuDBieIHPftU6ed0cqcHCTjLlFjYvRbRWe3aFxbYACl7zepCEAgxAOPbBrJoa\/pRFxnuFnm2blvc7bSWAAjZwGG3bkZifkgV50NsKbd6PWjFFW2SVAn6mUSxBOJ5j4rRwi9yzXqrIJRT29v0JfTejEodjgqt3IZdkqstCz9L5GfuMTjSupxeWWdZro31qCjjv\/pGhtLbulWZn2G7JUjjbtAJKcASvJzke4Ob1NwahyUqpRUsyJus0lm2iPY8tEskmTJ2AEKyAKZlpBjgFACK08nrrUbOTaF8q5Nw7lN1nTpqlliBcO2CrQVViAu7G04+KmjFRWERSk5PLMHe0rWWa8VKWgzWwQDJI9BVpPPOT3qG6Le51vDboxzFvD\/M8TqK3ArwV8p1yfUxMQAAgJP8AL8vsKr9LWx1ldGe7WMP+cG2\/ZRow2ovahduzcdixEAjkKcgj1D7VNVHMvkc\/XWdNLX\/09vkavx11UWI3PEqxB+YxUt0eqODk6WajPLPhmq1DXWLu0knk1snGKwg67bXl7nJbTFtsVjzEbLRWvsc2EYqQqtYAaGAmgAaAJoAmgCaAJoAGgCaA8FAIUAhQDFAIUAhQCFAMUAhQCFAStJcUTuE1DbFtbHR8PthCTUj9c06Kd+4yeAOKhWeDpuMPt5F0zR7d73BuJwhgmPeAO9YlLsjNFPMp7+xoejeJUtWimp3KVD7WYQGUcA\/6virEJ5WDj6nTyhJtLYz\/AErxO+n1TX0UslwbSJjH+K0urjaulmaHZR60so2WluBlDDGSTHz8d\/8Aipa4KEelFe+52zc2MHYykEH1wTBlWmQ0+wNbkJmfEWie7eZjcwh3PbUblO2TAYNiRuP3qq5Yk0d6ql2URabWN2nnf6\/FHWzYRypTNvbNvaPSD7iP5f8A2ofU9u50W6opTyunt7EK5023f1nruC2nlxAhTcKgnvzwPn01LJ2VwSSyzk2f0+p1Dk5YWF8Mk7wV0W4dQXvXPp\/MApO2TO0n6MRnnNNRZOMU4rkraWmpyl1tbcdsmsTQai5cYu6JbKKtsAvuG12PGAXZcTGBVpN43KUks7FP+F8q47tdcl9xVrZlWSBg5mPYewrJqI9TKkrgGRDksba\/nJLdjAGDJMUMnBPEWnS3dNwqVuMbluzaLJGw4Ag43MNxkR6visDBrtH4l0r2fLuldl9DKqNwHmEhlAAmZ2tuPJ4rR2xjyy1Vor7FmMfv2\/MuUFo7bTbBO1xaBk+UmEuMPj39x3qQqtY2KLqumFxEdI8591xA6SEkx9I9y4OfasSzjY2rx1bvBQ9T8JsujGrtgXLouReKqXUqFYOwRQNx3BY+GNU4xseXJfI7EdRUpRhF\/Xk3HgDpBSwl67aK3ZYZASEYDBQYmpaYf5Mj8S1TeKk01tn5mc\/bYH8y0ADEH39uK3teCtooZk2fMdPYcnP6CoG0dSEJN7mm6AENopcjeD+oqGec5R0dNhw6Z8lBr4W623iTzV+G8UeU1OFdLHuQ63KwTQANAE0ATQBNAE0ADQBNAeCgEKAQoBigEKAQoBCgEKAYoBCgEKBHUo4JIGAJzVVz33O5DTtRTRK0N24yKqELJJIM9onjv\/sajkkmXaZTcUlsG7pLl1wgZWt92YRn4\/5omks9xKuc5KOzj8So1umvOSFEbTtECBzkzVitdzk6yzmP4Gs8PXbwtkMQCB34\/Wpjml\/5kLMqpMmT9PHfORihgg3dHtZNTeWS5G\/asBWfhMEenJM55qv5OZZb2OsvElGpRjH1Yx8CTcsKhKWVhQNotjjdPMc5HczU6SXBzZWTksSbZWdV0ZIlRncjKGG1h6vV7E4\/zWTQ5W+oZu7VMWzkFRLMZiJ9iB8eqsGUm3hFx0XqpjZeX1sP31wYYEjABHPt+pqv\/ULPGx114RNwe\/qXb\/ZG1nUUuowsi4qKxUEDaCQQsSxHMxHt2HFWE88HJlFxeGZvXWri3EtFgu8uShOSexKgmBJ4Ofismpx0Vm9buoHswSABOAAozJ9oB7ck81Dd9k6HhrXn\/H+foW2ivrvBMBwdoWIDA8SZ4qn0nooWJy32ZvdBrXWym7a1xQ9uVEfUQxkZgQRyauUT6o7nn\/E6FXdt3WX82ZTxP4j8hywbIUKBzA44\/n\/Opjmnb9nvi3TaZXTUattrkbVYN6ckmTxmq6i\/M6s7F6TTpUEtz7L0TXWNVaF3TuroeCp4gQRU6afBUlCUPtI+d\/tm6v5b27IAJgsxPYVFbjYvaBySk+x8h0\/UibkHge3etHHYsV3Prx7GlTUC1bNzaAzYX3qKMOqWC\/fqfIqc8bvgobrliSeTV1LCweYlJybbOZrJqA0ATQBNAE0ATQBoAGgPysBMif8AFYaMppcoArJgQoBCgEKAQoBigEKAQoBCgEKAYNDKeNyaWcxEEd6pSSTPR1WSlFYFp33OFuKVQGZGMisNYjlcm3mNz6Wtifb1mluXRaKkA8Gefitqa8r1FfWauVf2ODTNol24A5\/pVtbHEk87vk9XSW2sXbLRLL6TEzzFVdRVOUouJe0V9VcZKfch6fp3kaYWySVMWwuDB7nPAk1K7krFWyBaaUqnauEPpd87V9OFm24YSBtAAIB5+D8GpiqSBfUnfJMwrLIX0mQACJg\/cUMno0t0F9gZV3ghWG\/dbACQoYGCDOQRQELr+isjLqu5QxBJAfdIVTAMxnio7X6WW9DFO+Kf82M\/ptVbO8M3lCQG9UbpOQpnEmeKp9L+Z6KNte6b6frz8i\/6Trbd60Ii2yOoTzELs\/1bSq7gC0qpluwNWKZYzFs5XiNSsxbXF\/H9H\/ssP\/wbdvUC5u22pZVW2suHv7S1y4xPcwJHEiKsHHIfizSlbl60tghXuwtyWJIVQEAjCxGBnuaguk1sdTwyiM25N7rt8+5QjoGoulrWy55qKrqyA7wDO25tGdvI+ePaoo5T2X0OjYoyi8yw08KS9\/5kvui9BuWBOwejFx5BZmgFx9R9oM5OeMGnRZ1ZMLUaVUuDknt8ct\/9M7ruiXtVfZ1XcsFUH8TfBNWbE2tjiaWcIy9fczZ0psmXskETKOCvwTn\/ALionl7F6KjFdaWcdjc9D69qen21v2FHptO7IxPlvuKhZAOTj9J+aihLpmX9VQraFtulki+Nbt7U3Fv6kCbqAhQfp+KkjLzG2ijao6VeXLdFRpOk27ih0EMM\/pUcpNPDLlVELIKcST1vVq4RFGVGalog47so+KamFjjGPYpzVg5ATQBNAE0ATQANAE0ATQBNAE0ARQCFAIUAxQCFAIUAhQCFAIUAxQCFATdFEZ96r38nZ8MfpaYep6qPSOCO1RQiXdRZjZFP5p3IeCrA1NHZnMu9cMH0\/pet820rd+DUyeTnSTi8MleWBxI5ismD9btsQRP5pPJkTPesYXJlSaWM7EfVaQ+ZtRokcgRIjkexFE8iSSeE8mc1Fy45uKlwqAoUMPq3KpIMn5gn4FQWWtPCOtpPD42V9cu6\/wCHLpet1Xllxcd7hNtlBAdssN0A4EAniswm3PBi\/Swhp+rG+34nSxoxcc6IMGe2huXWAwSWkw0+ojA7ZmlkZN5Rror6IVyU9n+fy\/nxJGj8OLddQ1xC1lzJHDkzhWH2OO5+1aKuXqRPZq6V5cnvy9uUXdjp6BixuAlYY2pEIFhwvyfTO73PxR6d7YZtHxeOHmLy849vh\/sv+nP+I1DK13y2JV32MBO3YFWZmfb7U1d8qYdUY5OJCKZbWtbpkv3bdtlM7bm4wdzHA9ZwTjH8zNSUSlOtSmsMZ6Xsyw2osXGcbVOwSBIghSWMSe\/wBUxjLxjsQdbYRmW0dv7xnYxghIOfufetXJJ4bNo1ylFyS2RJs6WzbQwFWCDPMD4+YrKafBhxaxk+aePdYmp148tQQltVYyRvG4wFjg5zVe\/k7PhkW4\/U5afptiw4OolFgfuzKicMu4DDR81WfW9kjpWyprj1Z2\/D6+5muo6gvcJ3lgCQpP8AD2q\/XHpXB5a6xzm23kFrVsiFFxPeseWs5JlrbFX5aIpNSFQJoAmgAaAJoAmgCaAJoAmgCaAFAeCgEKAQoBCgEKAQoBCgGKAQoBCgEKA6W7hHFaTjlE9Fzrl8CJrA5bABFRKONjoTtc\/UuDtdtrtHp+9YaaZtXOM4ln0zxCumDBxj8oFSQexV1VeZ5RoPDPWfxTOSI2QQJ7Go7dR5eNjenQebnD4NFp7nmKSDAP8AirCeVk58o9LaIfW+oJprJYsd8MEEAtJXEkdq1lLCJqKXKe62XJibWrslCLjBSxM21+psEzjMHv25qp0yzlHoY21dPTPbPZdy16RqGCm0LfkW2HlpcDTBfbAZRlDJIn\/VWYYU02zTUKc9O4Rhhdt+3P0LE9Htovk2UkoqWLhI2gofWwEdiTE81dPND6Po707zYt2vJkodrErbnaUHzA59zVeeo6bFDHJcr0vVS7XLg5Xhs+lCvreMTJJJ9RPHfj3qfKzgq9DxnGxR62\/e825ghWCrjgngD7fNZNSObmpe2CX2gekqCQTtkjj47VWnZv0nY0uiTrVjNr4F6zc8tLVx2J830yAS6lSWRmP2Bn4IrNdiTwzGr0cpRVkF8+Db6fp9rcdQLZ8xgJYsfycCPbmtrKI2SUn2KFWplXFxXcxfiHXXkseVZLveuXGOeAsQAPYcVrXVKNjl2ZJdfGyqMe6Pla9X1mnuv+8ZX3eoY5H3reUVLk3otsqjiD2ZdjVam9ba7qH3FwSp\/wDEcfGKhb9ex0K6n5DUuHujlZ0rOiOondx7VKrVnDKU\/D5OKlX3I7ggwe1THNaaeGA0MBNAE0ATQBNAE0ADQBNAE0ATQBNAEUAhQCFAMUAhQCFAIUAhQCFAIUAhQCFAIGhlSaO+mQE+riq9zfB1vDq4tOTIuv0oKntn0jvWkZFm6pNfkSOk9Jfyxc83Yz4UA8j5qSLjKWGuDn3KcIpp8mxta17OnVRHmD6y3b7VGvMdrfYkl5K0yS3l+ILuv0Gq22rrAMCc5GY43D39qnl0yIKnbR6sbezJWg6JaRAXRTBkETMZiTOea08rlE78QxKEkt1yePp7KsdyndgxJgAcQDgD7e9YenT4Ja\/F5Rz1Rzn+L7hJ1HyrkJjeNzEjssSPuasHHbbeWcNV4yt7trBiZE7DCqobIg8mDio3OJahprWse+\/Je6mxZuaffats\/rAAEA4HM9xn+pqGuhKx2Z5JtRqZeUqJRxjB18P9AFxWV02DcVUex\/iDHnmrRzzG+OdNb8wW0hWCqbhUkkFWIEj3H271VseJnb0lfVpsZa3z9PgQLuqNpEvD6rJPkgzL3DiSPYAk\/wD2oorc6NkkoJ844+L4Pp\/hHrep1qOLtoI4VJ2iFyD6YJJDCM\/cfpbrs6zgavRuhRfuSerCx01PxF8BnzsX5qTJSx3PivWXGpvveKgM7Sais2WS7pH1PpLvSKxtIHVRt3cd\/SQDVN4zselrTdaUkjjp7L22VCfQluVjAJrbZkDUq1jslsUlx5JJ7mryPKyfU22A1k1CaAJoAmgCaAJoAmgCaABoAmgCaA8FAIUAhQCFAIUAhQCFAIUAhQCFAIUAj8UMs9FDB3s3duJj5qOyHUXNLqfJeOzDqNKLpDBjI5zz+lQ4cToqdd7TT3O2gfaVZ5IQzHeAe1bzeIY7spVUudra4TL7rXVE1DiyqyGAMxwBkzVetzUMM60qKnemuWip0\/QCb6kZ38D7c1tGfVhGLdOqm7H7FnaXUWbrW3R2k+hQTFW21Fbnn1F2S9KNL0zQG5a3XDlmA9Q47FY960hdCb6US26WyuKlIsdT0Cylt3vXNiok7u8REx71JJ4RDXFykklk+W9M0iXXa6Tgb9xJ+4B+3FU5Sa2PRaeqE25+2T6f4HL3LKE3AqWlGwLOQ0wxnOB2+KnpllY9jmeI0dElYn9o0Jtpbs7EeQXmSe8zIPtUvUs4yUHXNLLWx8+6t0Gz+KcvrFyWeSB+Yk7SZ47fpVZ1vL32OxHWQ6I7PqW2DW+DvB+gvWUvvtuOBl90gQePYxW0K01uR6nWTjZmtbY5xuaG71PS6a1c\/DFCyzIECCK1tujU8JEVNNmpalY3g+Q+LPE93XBVuD6SWB+\/at6ob9eSLWNR\/tpbLv7mdtsAwLCQDMVLOPUsEGnu8qfU1kvLHW0AI2wD2qq9Ozu1+MV43WCBruqbxtUQOJ+KlrpUXllDV+JO1dMNkVgInPFTnLWM7gNDAZoE8BNAE0B5j\/ahlY7gNDATQHiqSYHNYbwZSbeEA1kwE0ATQBFAIUAhQCFAIUAhQCFAIUAhQCBoD0UAhQCBoD2gEpoZTaO1meYxME1HNJ7dy1pbZVyz2fJcaAryzKADiSRIOSDFU5xaPSaeyE84a2PNZ1Q2xvt4M4IGAOMVmCwzGpsUq2vcmdK8abNrXrYciYapbErFiRyK6nU3KG+TQabxdprqLPp9e8\/ea2rhXW8ohud9y3RXeOOvG8dmnJZGWXjMj2EfzpZZnZE+k0rguuS3\/QotOp2M+xmTcFKop9RgwWPYY5+1V2daM0tsc9l8PcsfDVrXJcBLEb3gpEItsjHbBFbeaq91wV7dLK+Ddj3X4I1fV9TaVfJu3lXaQTHJ71vCiLl5kXycqzVSgvLkuD574qFjzAdO5aSdxPHxFZUVFYLMJOb68YOfhzrGoso1u0zQWzB7d5rWbwWdP6lhrOGe6xLpZtjlV3AuATn71qmu5NZXLqfTsu5yW2Xv5EIAJPY1sm0tiKcIzsbktkR9Rt3HbxOKtxzjc8\/b09b6eDiayRnhNAEmgCTQHhoAmgCaAJoAmgCaAJoAmgCaAJoAigEKAQoBCgEKAc1gHorIEKAQoBCgEKA9FAKgPRQCoBhjETj2phZyZy8YOlq4QQAeearWbs7Wi9MFjuTOtnCjtAxAFRQOhqeEiEEGxcVJgpN4aXY5WTyKwySD5RaWHO6JxsrRdiebfS18DY9HvNb6ehQwS+cDOar2pO1ogqnLyoPO5WdL1dw69yWPI\/8AUVia\/tIuU7ylkz\/XXLam4SZO410qViCPM6v\/ANpfMgvkQa1s5LuieYvJ08JIPPP3Pc1DdwX\/AA5f3X8y26v6RcIxNRx7F7UbKWDlq2I04jvzU1K9RzvEpNUpIpTVs88eUATQHhoA0ATQHhoAmgCaAJoAmgCaAJoAmgDQH\/\/Z)","58b6fa55":"## Importing Dataset from Github\npandas is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the Python programming language.\nFor the source file of pandas you can go on the [`Github link`](https:\/\/github.com\/pandas-dev\/pandas)","5feee404":"## Predictions for confirmed coronavirus cases worldwide","5edf3433":"## Model for predicting number of confirmed cases.\n* Support Vector Machine\n* bayesian ridge\n* linear regression"}}