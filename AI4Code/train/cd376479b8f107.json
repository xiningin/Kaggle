{"cell_type":{"0b7fdac6":"code","64df53ed":"code","e6f7c7e3":"code","95776115":"code","2c511c1a":"code","4a91ba2a":"code","d8c68346":"code","8bc3bed8":"code","fb80e2c0":"code","fd06b4f7":"code","0d731bb6":"code","c9a90d67":"code","cb1bb649":"code","4d046103":"markdown","0698f36d":"markdown","470c4c20":"markdown","286d1a9e":"markdown","5ef36417":"markdown"},"source":{"0b7fdac6":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","64df53ed":"! pip install cirpy\nimport cirpy\nimport sys \nsys.path.append('\/usr\/local\/lib\/python3.7\/site-packages\/')\n! wget https:\/\/repo.anaconda.com\/miniconda\/Miniconda3-py37_4.8.2-Linux-x86_64.sh\n! chmod +x Miniconda3-py37_4.8.2-Linux-x86_64.sh\n! bash .\/Miniconda3-py37_4.8.2-Linux-x86_64.sh -b -f -p \/usr\/local\n! conda install -c rdkit rdkit -y\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Descriptors\nfrom rdkit.ML.Descriptors import MoleculeDescriptors\nfrom sklearn.ensemble import RandomForestClassifier\nimport warnings\nwarnings.filterwarnings('ignore')","e6f7c7e3":"df = pd.read_excel('\/kaggle\/input\/803-cpdb\/final_cd.xlsx')\nimport gc\ndf.drop(columns=['ID_v5','  CASRN'],inplace=True)\ndf['SMILES'].replace(['Cbr'],'CBr',inplace=True)\ndf=df[df['SMILES'].notna()]\ngc.collect()\ndf.shape","95776115":"potency={'NP':0,'P':1}\ndf['Carcinogenic Potency Expressed as P or NP']=df['Carcinogenic Potency Expressed as P or NP'].map(potency).astype('int')","2c511c1a":"mol_lst=[]\n\nfor i in df.SMILES:\n    mol=Chem.MolFromSmiles(i)\n    mol_lst.append(mol) # Calculation of Mol Objects\n\ndesc_lst=[i[0] for i in Descriptors._descList]\ndescriptor=MoleculeDescriptors.MolecularDescriptorCalculator(desc_lst)\ndescrs = [] #Calculation of descriptors\n\nfor i in range(len(mol_lst)):\n    descrs.append(descriptor.CalcDescriptors(mol_lst[i]))\nmolDes=pd.DataFrame(descrs,columns=desc_lst)\nmolDes.head(5)","4a91ba2a":"df.head()","d8c68346":"molDes.insert(0,'Name',df['Chemical Name'])","8bc3bed8":"molDes","fb80e2c0":"molDes.to_csv('chemical_properties.csv',index = False)","fd06b4f7":"rfc = RandomForestClassifier(max_depth=9, min_samples_leaf=3, min_samples_split=5,\n                       n_estimators=50)","0d731bb6":"rf_feat = ['MaxEStateIndex', 'MinEStateIndex', 'MaxAbsEStateIndex', 'MinAbsEStateIndex', 'qed', 'MolWt', 'HeavyAtomMolWt',\n            'ExactMolWt', 'NumValenceElectrons', 'MaxPartialCharge', 'MinPartialCharge', 'MaxAbsPartialCharge',\n           'MinAbsPartialCharge', 'FpDensityMorgan1', 'FpDensityMorgan2', 'FpDensityMorgan3', 'BCUT2D_MWHI',\n            'BCUT2D_MWLOW', 'BCUT2D_CHGHI', 'BCUT2D_CHGLO', 'BCUT2D_LOGPHI', 'BCUT2D_LOGPLOW', 'BCUT2D_MRHI',\n            'BCUT2D_MRLOW', 'BalabanJ', 'BertzCT', 'Chi0', 'Chi0n', 'Chi0v', 'Chi1', 'Chi1n', 'Chi1v', 'Chi2n', 'Chi2v',\n            'Chi3n', 'Chi3v', 'Chi4n', 'Chi4v', 'HallKierAlpha', 'Ipc', 'Kappa1', 'Kappa2', 'Kappa3', 'LabuteASA', 'PEOE_VSA1',\n            'PEOE_VSA3', 'PEOE_VSA5', 'PEOE_VSA6', 'PEOE_VSA7', 'PEOE_VSA8', 'PEOE_VSA9',\n           'SMR_VSA1', 'SMR_VSA10', 'SMR_VSA3', 'SMR_VSA5', 'SMR_VSA6', 'SMR_VSA7', 'SlogP_VSA1', 'SlogP_VSA10', 'SlogP_VSA2',\n            'SlogP_VSA3', 'SlogP_VSA4', 'SlogP_VSA5', 'SlogP_VSA6', 'TPSA', 'EState_VSA1', 'EState_VSA10', 'EState_VSA2',\n            'EState_VSA3', 'EState_VSA4', 'EState_VSA5', 'EState_VSA6', 'EState_VSA7', 'EState_VSA8', 'EState_VSA9',\n           'VSA_EState10', 'VSA_EState2', 'VSA_EState3', 'VSA_EState4', 'VSA_EState5', 'VSA_EState6','VSA_EState7',\n           'VSA_EState8', 'FractionCSP3', 'NumHDonors', 'NumRotatableBonds', 'MolLogP', 'MolMR', 'fr_NH0', 'fr_nitroso']\n\n","c9a90d67":"rfc.fit(molDes[rf_feat],df['Carcinogenic Potency Expressed as P or NP'])","cb1bb649":"number = int(input('Enter: '))\nchem_lst = []\nfor i in range(0,number):\n    print('Chemical number',i+1 )\n    chemical  = input('Enter : ')\n    chem_lst.append(chemical)\nsmiles = []\nfor i in chem_lst:\n    che = cirpy.resolve(i,'smiles')\n    smiles.append(che)\n# print('The smiles format of {} is {}'.format(chemical,che))\nmol = []\nfor i in smiles:\n    mol_che = Chem.MolFromSmiles(i)\n    mol.append(mol_che)\nl = []\nfor i in mol:\n    des_che = descriptor.CalcDescriptors(i)\n    l.append(des_che)\nfeatures = pd.DataFrame(l,columns = desc_lst)\nfeatures.fillna(0.0,inplace = True)\narr = rfc.predict(features[rf_feat])\nprob = rfc.predict_proba(features[rf_feat])\nr = []\nfor i in prob:\n    if i[1] > 0.5: # Threshold value set up after trial and error\n        r.append('Carcinogen')\n        \n    else:\n        r.append('Non-Carcinogen')\nresults = pd.DataFrame()\nresults['Chemical'] = chem_lst\nresults['Likely to be'] = r\nresults['Percentage'] = prob[:,1]\nresults","4d046103":"# Fitting model","0698f36d":"# Importing the necessary packages","470c4c20":"# Calculation of descriptors","286d1a9e":"# Prediction","5ef36417":"# Reading the dataset"}}