{"cell_type":{"49fa59a7":"code","6877ba5e":"code","e8e9304b":"code","283d4e88":"code","a1c4abee":"code","8b79bcbd":"code","e3641a35":"markdown","5973f6c8":"markdown","a0065430":"markdown","6656295a":"markdown"},"source":{"49fa59a7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n'''\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n'''\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","6877ba5e":"from torchvision import transforms\nfrom torchvision.datasets import ImageFolder\nfrom torch.utils.data import DataLoader\nimport matplotlib.pyplot as plt\nimport torch\nimport torchvision\n\nnum_classes = 2\ntransform = transforms.Compose([\n    transforms.Resize([224, 224]),\n    transforms.ToTensor(),\n    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n])\n\ntrain_dataset = ImageFolder(root = '..\/input\/chest-xray-pneumonia\/chest_xray\/train', transform = transform)\ntrain_dataset = DataLoader(train_dataset, batch_size = 16, shuffle = True, num_workers = 2)\n\ntest_dataset = ImageFolder(root = '..\/input\/chest-xray-pneumonia\/chest_xray\/test', transform = transform)\ntest_dataset = DataLoader(test_dataset, batch_size = 16, shuffle = True, num_workers = 2)\n\nval_dataset = ImageFolder(root = '..\/input\/chest-xray-pneumonia\/chest_xray\/val', transform = transform)\nval_dataset = DataLoader(val_dataset, batch_size = 16, shuffle = True, num_workers = 2)","e8e9304b":"!pip install efficientnet_pytorch","283d4e88":"import torch.nn as nn\nfrom torchsummary import summary\nfrom efficientnet_pytorch import EfficientNet\nfrom torch.optim import Adam, lr_scheduler\n\ndevice = torch.device('cuda' if torch.cuda.is_available else 'cpu')\nprint(device)\n\nmodel = EfficientNet.from_pretrained('efficientnet-b7', num_classes = num_classes).to(device)\ncriterion = nn.CrossEntropyLoss().to(device)\noptimizer = Adam(model.parameters(), lr = 0.001)\nscheduler = lr_scheduler.StepLR(optimizer, step_size = 7, gamma = 0.1)","a1c4abee":"from tqdm import tqdm\nimport warnings\nwarnings.filterwarnings('ignore')\n\nn_epoch = 20\n\nfor epoch in range(n_epoch) :\n    #train\n    epoch_acc = 0\n    epoch_loss = 0\n    model.train()\n    for x, y in tqdm(train_dataset) :\n        x = x.to(device)\n        y = y.to(device)\n        \n        predict = model(x)\n        loss = criterion(predict, y)\n        epoch_loss += loss\n        correct_pred = torch.argmax(predict, 1) == y\n        correct_pred = correct_pred.sum()\n        epoch_acc += correct_pred \/ len(y)\n        \n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n    \n    epoch_acc = epoch_acc \/ len(train_dataset)\n    epoch_loss = epoch_loss \/ len(train_dataset)\n    \n    #test\n    epoch_val_acc = 0\n    epoch_val_loss = 0\n    model.eval()\n    with torch.no_grad() :\n        for x, y in tqdm(test_dataset) :\n            x = x.to(device)\n            y = y.to(device)\n            \n            predict = model(x)\n            loss = criterion(predict, y)\n            epoch_val_loss += loss\n            correct_pred = torch.argmax(predict, 1) == y\n            correct_pred = correct_pred.sum()\n            epoch_val_acc += correct_pred \/ len(y)\n            \n    epoch_val_acc = epoch_val_acc \/ len(test_dataset)\n    epoch_val_loss = epoch_val_loss \/ len(test_dataset)\n    \n    print('{0} \/ {1} : train_loss : {2:.4f}, train_acc : {3:.4f}, val_loss : {4:.4f}, val_acc : {5:.4f}'.format(epoch+1, n_epoch, epoch_loss, epoch_acc, epoch_val_loss, epoch_val_acc))\n    \n    if (epoch_val_acc > 0.90 or epoch_acc > 0.98) :\n        print('early stop')\n        break\n    scheduler.step()","8b79bcbd":"model.eval()\n\nvalid_acc = 0\nvalid_loss = 0\nwith torch.no_grad() :\n    for x, y in tqdm(val_dataset) :\n        x = x.to(device)\n        y = y.to(device)\n\n        predict = model(x)\n        loss = criterion(predict, y)\n        valid_loss += loss\n        correct_pred = torch.argmax(predict, 1) == y\n        correct_pred = correct_pred.sum()\n        valid_acc += correct_pred \/ len(y)\n    \n    valid_acc = valid_acc \/ len(val_dataset)\n    valid_loss = valid_loss \/ len(val_dataset)\n\nprint('valid_loss : {0:.4f}, valid_acc : {1:.4f}'.format(valid_loss, valid_acc))","e3641a35":"## Construct model by using resnet34 from torchvision","5973f6c8":"## Check the performance using valid_dataset","a0065430":"## Preprocess data using ImageFolder and DataLoader","6656295a":"## train"}}