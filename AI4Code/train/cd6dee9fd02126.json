{"cell_type":{"36e25e5d":"code","01acabcc":"code","c3779b81":"code","573e61dc":"code","c44c88b0":"code","47a0d497":"code","e083aa25":"code","9fc1c868":"code","9b0c5375":"code","5236115f":"code","94e11bef":"code","bfb8bb07":"code","5a1862d0":"code","78860959":"code","fc2ee3e3":"markdown","1f201451":"markdown","7e824be3":"markdown","f351de74":"markdown","35f60270":"markdown","0e9d87bd":"markdown","9b6a751a":"markdown"},"source":{"36e25e5d":"import torch\nfrom torch.autograd import Variable\nfrom torch import nn,optim\nfrom torchvision import transforms\nimport torchvision.datasets as dset\nimport numpy as np\nimport numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\nimport matplotlib.pyplot as plt","01acabcc":"! cp \/kaggle\/input\/* .\/","c3779b81":"\n# Processing Training data\ndef proc_df(train, window_size):\n    train_y = train.iloc[window_size:]\n    \n    train_proc = pd.DataFrame(index=train[\"Date\"][window_size: ], \\\n                          columns=[[ f'day_t-{window_size + 1 - i}'for i in range(1,window_size + 1)] ])\n    \n    for i in range(len(train_proc)):\n\n        train_proc.iloc[i] = train[\"Open\"][i: i + window_size].values\n        \n    train_proc = train_proc.values\n#     test_proc = test_proc.values\n    train_y = train_y[\"Open\"].values \n    train_y = np.reshape(train_y, (-1,1))\n    train_proc = np.reshape(train_proc, (train_proc.shape[0], train_proc.shape[1], 1))\n    train_proc = train_proc.astype(np.float32)\n    train_y = train_y.astype(np.float32)\n    return train_proc, train_y\n\n# Pytorch dataset for processed training data\nclass Stock_DS(torch.utils.data.Dataset):\n    def __init__(self,data, label):\n        self.data = torch.from_numpy(data)\n        self.label = torch.from_numpy(label)\n        \n    def __getitem__(self, index):\n        return (self.data[index], self.label[index])\n    def __len__(self):\n        return len(self.data)\n    \n# Prepare test data\ndef get_test(window_size, sc):\n    test_proc = pd.DataFrame(index=full[\"Date\"][-20:],\\\n                          columns=[[ f'day_t-{window_size + 1 - i}'for i in range(1,window_size + 1)] ])\n\n    for i in range(len(test_proc)):\n            test_proc.iloc[i] = full[\"Open\"][ len(full) - 20 + i - window_size : len(full) - 20 + i].values\n    test_proc = test_proc.values\n    test_proc = sc.transform(test_proc)\n    test_proc = np.reshape(test_proc, (-1,window_size,1))\n    test_proc = test_proc.astype(np.float32)\n    return test_proc\n ","573e61dc":"# Get X_train y_train for keras model\ntrain = pd.read_csv(\"Google_Stock_Price_Train.csv\")[[\"Date\",\"Open\"]]\ntest = pd.read_csv(\"Google_Stock_Price_Test.csv\")[[\"Date\",\"Open\"]]\nsc = MinMaxScaler()\ntrain[\"Open\"] = sc.fit_transform(train[\"Open\"].values.reshape(-1,1))\nX_train, y_train = proc_df(train, window_size=60)\n\n# Get pytorch dataloader for pytorch model\nds = Stock_DS(X_train, y_train)\ndl = torch.utils.data.dataloader.DataLoader(ds, batch_size=32, shuffle=False)\n\n# Get X_test for keras model and X_test_pytorch for pytorch model\ntrain_raw = pd.read_csv(\"Google_Stock_Price_Train.csv\")[[\"Date\",\"Open\"]]\ntest_raw = pd.read_csv(\"Google_Stock_Price_Test.csv\")[[\"Date\",\"Open\"]]\nfull = pd.concat([train_raw, test_raw],axis=0)\nX_test = get_test(60, sc)\nX_test_pytorch = torch.from_numpy(X_test).cuda()","c44c88b0":"from keras.models import Sequential\nfrom keras.layers import Dense \nfrom keras.layers import LSTM\nfrom keras.layers import Dropout","47a0d497":"regressor = Sequential()\n\nregressor.add(LSTM(units=50, return_sequences = True, input_shape = (X_train.shape[1], 1)))\nregressor.add(Dropout(0.2))\n\nregressor.add(LSTM(units=50, return_sequences = True))\nregressor.add(Dropout(0.2))\n\nregressor.add(LSTM(units=50, return_sequences = True))\nregressor.add(Dropout(0.2))\n\nregressor.add(LSTM(units = 50))\nregressor.add(Dropout(0.2))\n\nregressor.add(Dense(units = 1))\n\nregressor.compile(optimizer = \"adam\", loss = 'mean_squared_error')\n\nregressor.summary()\nregressor.fit(X_train,y_train, epochs=100, batch_size = 32)\n","e083aa25":"y_preds_keras = regressor.predict(X_test)\ny_preds_unscaled = sc.inverse_transform(y_preds_keras)","9fc1c868":"plt.plot(test_raw[\"Open\"] )\nplt.xlabel(\"time\")\nplt.ylabel(\"price\")","9b0c5375":"plt.plot(y_preds_unscaled )\nplt.xlabel(\"time\")\nplt.ylabel(\"price\")\n","5236115f":"def my_training_loop(m, dl, epochs):\n    opt = optim.Adam(m.parameters())\n    crit = nn.MSELoss()\n    \n    for epoch in range(epochs):\n        accu_loss = 0\n        batch_count = 0\n        for i, (train_x, train_y) in enumerate(dl):\n\n            x = Variable(train_x.cuda())\n            y = train_y.cuda()\n            opt.zero_grad()\n            preds = m(x)\n            loss = crit(preds, y)\n            accu_loss += loss.item()\n            batch_count += 1\n            loss.backward()\n\n            opt.step()\n        print(f'Epoch: {epoch}. Loss: {accu_loss\/batch_count}')\nclass MyLSTM(nn.Module):\n    \n    def __init__(self, input_dim, hidden_dim, layer_dim, output_dim):\n        \n        super().__init__()\n        self.layer_dim = layer_dim\n        self.hidden_dim = hidden_dim\n        self.lstm = nn.LSTM(input_size=input_dim, hidden_size=hidden_dim,\\\n                          num_layers=layer_dim,bias=True, batch_first = True,dropout=0.2)\n        self.dropout = nn.Dropout(p=0.2)\n        self.fc = nn.Linear(in_features=hidden_dim, out_features=output_dim)\n        \n    def forward(self, x):\n        h0 = Variable(torch.zeros((self.layer_dim, x.size(0), self.hidden_dim)).cuda())\n        c0 = Variable(torch.zeros((self.layer_dim, x.size(0), self.hidden_dim)).cuda())\n\n        o, h = self.lstm(x, (h0,c0))\n        o = self.fc(self.dropout(o[:,-1,:]))\n        return o ","94e11bef":"m = MyLSTM(1, 50, 4, 1)\nm.cuda()\nmy_training_loop(m, dl, 100)","bfb8bb07":"y_preds_torch = m(X_test_pytorch)\ny_preds_torch_unscaled = sc.inverse_transform(y_preds_torch.cpu().data)","5a1862d0":"plt.plot(test_raw[\"Open\"] )\nplt.xlabel(\"time\")\nplt.ylabel(\"price\")","78860959":"plt.plot(y_preds_torch_unscaled)\nplt.xlabel(\"time\")\nplt.ylabel(\"price\")","fc2ee3e3":"# Preprocessing\nEverything in this block should be correct since the Keras model fitted on the data . is behaving correctly","1f201451":"# Pytorch Model","7e824be3":"# Model has learned nothing ...","f351de74":"# Keras Model","35f60270":"# Model prediction","0e9d87bd":"> # Ground Truth","9b6a751a":"# Ground Truth"}}