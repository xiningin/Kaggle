{"cell_type":{"5f747513":"code","74ac2622":"code","8cf89a7f":"code","cf67addf":"code","1b111e0f":"code","5f8542d4":"code","b57b7f20":"code","b66395e6":"code","382f5cd8":"code","87641c67":"code","9ae3843b":"code","c4470e90":"code","9f7dcb8b":"code","d5dae8ea":"code","ca0356ec":"code","54f2beb7":"code","c267596c":"code","d23614a1":"code","87bf6089":"code","72420036":"code","bfab7ff0":"code","0be3a903":"code","041355e0":"code","da3e4f0a":"code","bdac0340":"code","779b188c":"markdown"},"source":{"5f747513":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","74ac2622":"from __future__ import print_function\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.autograd import Variable\nfrom torchvision import datasets,transforms\nfrom torch.utils.data import Dataset,DataLoader","8cf89a7f":"import pandas as pd","cf67addf":"class OttoDataset(Dataset):\n    def __init__(self):\n        xy = np.loadtxt('..\/input\/train.csv',delimiter=',',skiprows = 1, usecols = np.arange(1,94))\n        df = pd.read_csv('..\/input\/train.csv', sep = ',')\n        df['target'] =  df['target'].map({'Class_1': 1, 'Class_2': 2,\n                                          'Class_3': 3, 'Class_4': 4,\n                                          'Class_5': 5, 'Class_6': 6,\n                                          'Class_7': 7, 'Class_8': 8,\n                                          'Class_9': 9})\n        df['target'] = df['target'].astype('float64')\n        self.len = xy.shape[0]\n        self.x_data = torch.from_numpy(xy[:,:])\n        self.y_data = torch.tensor(df['target'].values)\n\n    def __getitem__(self, index):\n        return self.x_data[index], self.y_data[index]\n\n    def __len__(self):\n        return self.len","1b111e0f":"dataset = OttoDataset()\n","5f8542d4":"train_loader = DataLoader(dataset=dataset,\n                          batch_size=32,\n                          shuffle=True,\n                          num_workers=2)","b57b7f20":"class Net(nn.Module):\n    def __init__(self):\n        super(Net,self).__init__()\n        self.l1 = nn.Linear(93, 46)\n        self.l2 = nn.Linear(46,18)\n        self.l3 = nn.Linear(18,9)\n    def forward(self,x):\n        x = F.relu(self.l1(x))\n        x = F.relu(self.l2(x))\n        return self.l3(x)","b66395e6":"model = Net()","382f5cd8":"criterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5)","87641c67":"loss = 1000\nfor epoch in range(10):\n    model.train()\n    for batch_idx, (data,target) in enumerate(train_loader):\n        data, target = Variable(data).float(),Variable(target).type(torch.LongTensor)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = criterion(output, target-1)\n        loss.backward()\n        optimizer.step()","9ae3843b":"  #if batch_idx % 10 == 0:\n            #print('Train Epoch: {} [{}\/{} ({:.0f}%)]\\tLoss: {:.6f}'.format(\n            #    epoch, batch_idx * len(data), len(train_loader.dataset),\n              #  100. * batch_idx \/ len(train_loader), loss.data[0]))\n        #print(data.shape)\n        #print(target.shape)\n        #print(epoch, i, \"inputs\", data, \"\\n labels\", target)","c4470e90":"#loss.item()","9f7dcb8b":"model.eval()","d5dae8ea":"xyTest = np.loadtxt('..\/input\/test.csv',delimiter=',',skiprows = 1, usecols = np.arange(1,94))","ca0356ec":"df1 = pd.read_csv('..\/input\/test.csv',sep=',')","54f2beb7":"#xyTest.shape","c267596c":"xy_pred = torch.from_numpy(xyTest[:,:])","d23614a1":"type(xy_pred)","87bf6089":"id_col = df1['id']\nclass_list = ['id','Class_1','Class_2','Class_3','Class_4','Class_5',\n             'Class_6','Class_7','Class_8','Class_9']\nclass_list2 = ['Class_1','Class_2','Class_3','Class_4','Class_5',\n             'Class_6','Class_7','Class_8','Class_9']\nd = pd.DataFrame(0, index=np.arange(xy_pred.shape[0]), columns=class_list)\nd['id'] = df1['id']","72420036":"d[class_list2] = d[class_list2].astype('float')","bfab7ff0":"d.dtypes","0be3a903":"d.head()","041355e0":"classify = 'Class_'\n#print(df1.iloc[2,1:])\nfor i in range(xy_pred.shape[0]):\n    output = model(Variable(xy_pred[i]).float())\n    row = F.softmax(output).data\n    classes = row.numpy()\n    classes = np.around(classes, decimals=1)\n    print(type(classes))\n    print(classes)\n    d.loc[i,1:] = classes\n    #print(indices.item()+1)\n    #no = indices.item()+1\n    #pred = classify + str(no)\n    #d.iloc[i][pred] = 1","da3e4f0a":"d.head()","bdac0340":"d.to_csv('submission1.csv',index = False)","779b188c":"****need to preprocess and change class1 to 1 and so on"}}