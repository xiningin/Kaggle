{"cell_type":{"84ab0ce8":"code","52d56558":"code","6f777ec8":"code","ce5623af":"code","22810750":"code","432c6144":"code","e5d73207":"code","0ca8261f":"code","72a19b1e":"code","bb84b662":"code","e7f62c57":"code","7b9f5811":"code","c9fda907":"code","81388e36":"code","37844bd8":"code","773d0ef2":"code","587f1e8b":"markdown","fe03d07f":"markdown","ccc29a71":"markdown","e8918ad3":"markdown","61c9f8ce":"markdown","73cb376b":"markdown","acac7783":"markdown","9e49f89c":"markdown","8bc23853":"markdown","4899e029":"markdown","3d6f976a":"markdown","0436512e":"markdown","fcd20e10":"markdown","a03ea066":"markdown"},"source":{"84ab0ce8":"!pip install feyn","52d56558":"import pandas as pd\nimport feyn","6f777ec8":"df = pd.read_csv(\"\/kaggle\/input\/cuneiform-language-identification\/train.csv\")\ndf.sample(10).head()","ce5623af":"df[\"lang\"]=(df[\"lang\"]==\"SUX\").astype(int)","22810750":"for i in range(0, 5):\n    df[f\"c{i}\"] = df[\"cuneiform\"].str[i]","432c6144":"df = df.drop([\"cuneiform\"],axis=1)","e5d73207":"df.head()","0ca8261f":"train,validation = feyn.tools.split(df,ratio=(1,9), random_state=42)","72a19b1e":"ql = feyn.connect_qlattice()","bb84b662":"ql.reset(random_seed=42)","e7f62c57":"stypes={\n    \"c0\": \"cat\",\n    \"c1\": \"cat\",\n    \"c2\": \"cat\",\n    \"c3\": \"cat\",\n    \"c4\": \"cat\",\n}","7b9f5811":"models = ql.auto_run(train, output_name=\"lang\", kind=\"classification\", n_epochs=25, stypes=stypes)","c9fda907":"models[0].plot_roc_curve(train, label=\"Training data\")\nmodels[0].plot_roc_curve(validation, label=\"Validation data\")","81388e36":"models[0].plot_confusion_matrix(validation, threshold=.3)","37844bd8":"models[0].plot_confusion_matrix(validation, threshold=.5)","773d0ef2":"models[0].plot_confusion_matrix(validation, threshold=.8)","587f1e8b":"![image.png](attachment:2eeaa339-dc65-4549-9956-ab524f12b151.png)\n\n# Detect language of Cuneiform text\n\nIn this notebook, I will detect whether the cueniform text is Sumerian or not. As explained in the dataset description, the language can either be Sumerian or a dialect of Akkadian. We will treat all Akkadian dialects as the same language, and therefore train a binary classifier.","fe03d07f":"# Split the dataset in train\/test\n\nFOr now we'll only yuse 10% for training. This leaves a lot of room for validation.","ccc29a71":"# Data types\nAll of the symbols are categorical variables. The QLattice will work fine with these. We just need to tell it about it. We will create a `dict` named `stypes` with this information which we will pass to the QLattice later. Read more about categorical data in the QLattice here: https:\/\/docs.abzu.ai\/docs\/guides\/essentials\/stypes.html\n","e8918ad3":"# Python imports\nIn this notebook we will use only two python modules: the `feyn` module to access the QLattice, and the `pandas` module to access the data","61c9f8ce":"# The QLattice\n\nThe QLattice is a supervised machine learning tool for symbolic regression developed by [Abzu](https:\/\/www.abzu.ai) . It is inspired by Richard Feynman's path integral formulation. That's why the python module to use it is called *Feyn*, and the *Q* in QLattice is for Quantum.\n\nQLattices have been shown in research to perform very well and yield simple and explainable models: [Symbolic regression outperforms other models for small data sets](https:\/\/arxiv.org\/abs\/2103.15147)\n\nAbzu provides free QLattices for non-commercial use to anyone. These free community QLattices gets allocated for us automatically if we use Feyn without an active subscription, as we will do in this notebook. Read more about how it works here: https:\/\/docs.abzu.ai\/docs\/guides\/getting_started\/community.html\n\nThe feyn Python module is not installed on Kaggle by default so we have to pip install it first. \n\n__Note__: the pip install will fail unless you enable *Internet* in the *settings* to the right --->","73cb376b":"# Conclusion\nIn a few lines of code we were able to create a classifier that was quite accurate as measured by AUC. I plan to do several improvements in later versions:\n- Train on more of the data\n- Use sample_weights to balance the training\n- Plot the importance of the individual signs in the text","acac7783":"# Evaluate\nThe QLattice has found a mathematical relationship tha can relate the coneiform symbols to the language. The final step is to evaluate the model on the test and the train set. To do that we plot the *ROC* curve of the classifier on both the test and the training data. You can read more about ROC curves here: https:\/\/docs.abzu.ai\/docs\/guides\/plotting\/roc_curve.html\n\nIn this case they overlap almost perfectly which indicates that the model generalizes to unseen data very well.","9e49f89c":"# Create binary target\nConvert the class label to a binary target. Sumerian or not","8bc23853":"# Resetting and reproducability\nThe QLattice has the potential to store learnings between sessions to enable transfer of learning and federated learning. This is not possible with Community QLattices, since a new one gets allocated whenever we run the notebook, so it is not strictly necessary to call the reset function on our new QLattice. \n\nBut the reset function also allows us to provide a random seed, which will ensure that we get the same results every time we run this notebook","4899e029":"# Search for the best model\nWe are now ready to instruct the QLattice to search for the best mathematical model to explain the data. Here we use the high-level convenience function that does everything with sensible defaults: https:\/\/docs.abzu.ai\/docs\/guides\/essentials\/auto_run.html. \n\nFor more detailed control, we could use the primitives: https:\/\/docs.abzu.ai\/docs\/guides\/primitives\/using_primitives.html\n\nNotice that the `stypes` dictionary we created earlier gets passed to the QLattice here. \n\n__NOTE:__ This will take several minutes to complete. It invoves work done on the QLattice machine remotely as well as in the local notebook. The part that runs locally is slowing things down because of the limited CPU resources on Kaggle. Running the same on my machine locally only takes 20 seconds!","3d6f976a":"# Extract the first 5 symbols\nWe will base the classifier on the first 5 symbols in each text","0436512e":"# Allocate a QLattice\nThe actual QLattice is a quantum simulator that runs on Abzu's hardware, but we can allocate one to use for our analysis with a single line of code. Hopefully the following line will get us one.","fcd20e10":"# Data\nRead in the data and have a quick look at it:","a03ea066":"# Confusion matrix\nA simpler and less powerfull way to evaluate classifiers is a confusion matrix: https:\/\/docs.abzu.ai\/docs\/guides\/plotting\/confusion_matrix.html\n\nLet us see how that looks at various thresholds:"}}