{"cell_type":{"bf1ebb2c":"code","f75160cd":"code","2286796d":"code","62f05a2b":"code","2cb9e203":"code","d11b2e8e":"code","b5ef20b0":"code","be9c012f":"code","0786ee53":"code","977c4622":"code","5b07f692":"code","379ee4da":"code","6a063d68":"markdown","bbc55623":"markdown","b7ab4be9":"markdown","8788c246":"markdown","0a9b9a97":"markdown","cd2fbb9e":"markdown"},"source":{"bf1ebb2c":"import os\nimport numpy as np\nimport pandas as pd\nfrom PIL import Image\nfrom tqdm import tqdm\n\nimport torch\nimport torch.nn as nn\nimport torch.utils.data as D\nfrom torchvision import models, transforms as T\n\nimport warnings\nwarnings.filterwarnings('ignore')","f75160cd":"path_data = '..\/input'\ndevice = 'cuda'\nbatch_size = 16\n# XXX set this to a higher value\nmax_epochs = 3\nimg_size = 384\ntorch.manual_seed(0)\nnp.random.seed(0)","2286796d":"class ImagesDS(D.Dataset):\n    def __init__(self, df, img_dir, mode='train', site=1, channels=[1,2,3,4,5,6]):\n        self.records = df.to_records(index=False)\n        self.channels = channels\n        self.site = site\n        self.mode = mode\n        self.img_dir = img_dir\n        self.len = df.shape[0]\n        train_controls = pd.read_csv(path_data+'\/train_controls.csv')\n        test_controls = pd.read_csv(path_data+'\/test_controls.csv')\n        self.controls = pd.concat([train_controls, test_controls])\n\n    @staticmethod\n    def _load_img_as_tensor(file_name):\n        with Image.open(file_name) as img:\n            return T.ToTensor()(img)\n\n    def _get_img_path(self, experiment, well, plate, channel):\n        if self.mode == 'train':\n            # pick one of the sites randomly\n            site = np.random.randint(1, 3)\n        else:\n            site = self.site\n        return '\/'.join([self.img_dir, self.mode, experiment,\n                        f'Plate{plate}', f'{well}_s{site}_w{channel}.png'])\n\n    def __getitem__(self, index):\n        rec = self.records[index]\n        experiment, well, plate = rec.experiment, rec.well, rec.plate\n        paths = [self._get_img_path(experiment, well, plate, ch) for ch in self.channels]\n\n        df = self.controls\n        negs = df[(df.experiment == experiment) & (df.plate == plate) & (df.sirna == 1138)]\n        well = negs.iloc[np.random.randint(0, len(negs))].well\n        paths.extend([self._get_img_path(experiment, well, plate, ch) for ch in self.channels])\n\n        img = torch.cat([self._load_img_as_tensor(img_path) for img_path in paths])\n        tr_img = torch.empty((12, img_size, img_size), dtype=torch.float32)\n\n        if self.mode == 'train':\n            # randomly crop\n            row, col = np.random.randint(0, 512 - img_size + 1, 2)\n            tr_img[:6] = img[:6, row:row + img_size, col:col + img_size]\n            # randomly crop the negative control image\n            row, col = np.random.randint(0, 512 - img_size + 1, 2)\n            tr_img[6:] = img[6:, row:row + img_size, col:col + img_size]\n            return tr_img, int(self.records[index].sirna)\n\n        # center crop\n        row =  col = (512 - img_size) \/\/ 2\n        tr_img[:] = img[:, row:row + img_size, col:col + img_size]\n        return tr_img, rec.id_code\n\n    def __len__(self):\n        return self.len","62f05a2b":"df = pd.read_csv(path_data+'\/train.csv')\nin_eval = df.experiment.isin(['HEPG2-07', 'HUVEC-16', 'RPE-07'])\ndf_train = df[~in_eval]\ndf_val = df[in_eval]\n\ndf_test = pd.read_csv(path_data+'\/test.csv')","2cb9e203":"ds = ImagesDS(df_train, path_data, mode='train')\nds_val = ImagesDS(df_val, path_data, mode='train')\nds_test = ImagesDS(df_test, path_data, mode='test')","d11b2e8e":"num_classes = 1108\nnum_workers = 4\nmodel = models.resnet18(pretrained=True)\n# add a new layer to combine outputs from two paths.\nmodel.head = torch.nn.Linear(model.fc.out_features, num_classes) \n\n\"\"\"\n                  ________\n                  |      |\n      image ----> |resnet|  \\\n                  ________   \\\n                              \\\n                            ________           _______\n                            | minus |  ---->  | head  | ---->\n                            _________          _______\n                               \/\n                              \/\n                             \/\n                  ________\n                  |      |\n -ve control ---> |resnet|\n                  ________\n\"\"\"\n\n# let's make our model work with 6 channels\ntrained_kernel = model.conv1.weight\nnew_conv = nn.Conv2d(6, 64, kernel_size=7, stride=2, padding=3, bias=False)\nwith torch.no_grad():\n    new_conv.weight[:] = torch.stack([torch.mean(trained_kernel, 1)]*6, dim=1)\nmodel.conv1 = new_conv\nmodel = model.to(device)\n","b5ef20b0":"train_loader = D.DataLoader(ds, batch_size=batch_size, shuffle=True, num_workers=num_workers)\neval_loader = D.DataLoader(ds_val, batch_size=batch_size, shuffle=True, num_workers=num_workers)\ntloader = D.DataLoader(ds_test, batch_size=batch_size, shuffle=False, num_workers=num_workers)","be9c012f":"criterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.0003)\n\ndef train(train_loader, model, criterion, optimizer, epoch):\n    model.train()\n    if epoch == 0:\n        # update only the last two FC layers\n        for name, child in model.named_children():\n            if (name != 'head') and (name != 'fc'):\n                for param in child.parameters():\n                    param.requires_grad = False\n    elif epoch == 3:\n        # enable update on all layers\n        for name, child in model.named_children():\n            for param in child.parameters():\n                param.requires_grad = True\n\n    loss_sum = 0\n    for input, target in tqdm(train_loader):\n        input1, input2 = input[:, :6].to(device), input[:, 6:].to(device)\n        target = target.to(device)\n\n        output = model.head(model(input1) - model(input2))\n        loss = criterion(output, target)\n        loss_sum += loss.data.cpu().numpy()\n\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n    return (loss_sum \/ len(train_loader))\n\ndef evaluate(eval_loader, model, criterion):\n    model.eval()\n    correct = 0\n    with torch.no_grad():\n        for input, target in tqdm(eval_loader):\n            input1, input2 = input[:, :6].to(device), input[:, 6:].to(device)\n            target = target.to(device)\n\n            output = model.head(model(input1) - model(input2))\n            preds = output.argmax(axis=1)\n            correct += (target == preds).sum()\n\n    return correct.cpu().numpy() * 100 \/ len(eval_loader.dataset)","0786ee53":"\nmodel_file = 'model.pth'\nif os.path.exists(model_file):\n    print('loading model from checkpoint...')\n    checkpoint = torch.load(model_file)\n    model.load_state_dict(checkpoint['state_dict'])","977c4622":"for epoch in range(max_epochs):\n    loss = train(train_loader, model, criterion, optimizer, epoch)\n    acc = evaluate(eval_loader, model, criterion)\n    print('epoch %d loss %.2f acc %.2f%%' % (epoch, loss, acc))\n    \n# save checkpoint\ntorch.save({'state_dict': model.state_dict()}, model_file)","5b07f692":"model.eval()\nwith torch.no_grad():\n    preds = np.empty(0)\n    for input, _ in tqdm(tloader):\n        input1, input2 = input[:, :6].to(device), input[:, 6:].to(device)\n        output = model.head(model(input1) - model(input2))\n        idx = output.max(dim=-1)[1].cpu().numpy()\n        preds = np.append(preds, idx, axis=0)","379ee4da":"submission = pd.read_csv(path_data + '\/test.csv')\nsubmission['sirna'] = preds.astype(int)\nsubmission.to_csv('submission.csv', index=False, columns=['id_code','sirna'])","6a063d68":"## Define dataset and model","bbc55623":"## Define functions for training and evaluation","b7ab4be9":"## Load libraries","8788c246":"## Load from checkpoint","0a9b9a97":"## Prediction for test","cd2fbb9e":"## Train the model"}}