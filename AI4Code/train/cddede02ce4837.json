{"cell_type":{"96f42142":"code","a856da74":"code","5a84774f":"code","f5787961":"code","a45823e8":"code","bba04a04":"code","2e3a0ec1":"code","baf62429":"code","69daaed8":"code","2fad948c":"code","e28d262d":"code","05db1ac3":"code","dc1f06e0":"code","498f5096":"code","435f3450":"code","abcd540f":"code","481f819f":"code","32f701fc":"code","6d4fe893":"code","bdf5a85d":"code","dd51b29a":"code","94107a3f":"code","0081638b":"code","748638c7":"code","08bcd07d":"code","156be2bb":"code","a1339008":"code","8eabfde0":"code","d66f8c23":"code","6488b4e3":"code","80dadffc":"code","c4d321e2":"code","5b3b9545":"code","3f563880":"code","a41dffb1":"code","61267b79":"code","851db473":"code","4e12f095":"code","58c56047":"code","c8223798":"code","b32ae39d":"code","0c2b7bee":"code","1b2fe6db":"code","a2861602":"code","540dc3c8":"code","c4900a2e":"code","408b1d4b":"code","91c9b507":"code","6a55a599":"code","56b20f1b":"code","6edfaffb":"code","1cbba7b7":"code","f394603f":"code","44ace354":"code","42b8d447":"code","47608a41":"code","79e359d8":"code","8d14e5a7":"code","6f121b28":"code","df6a915b":"code","82e83b7b":"code","faf13b30":"code","e627e679":"code","89495a3c":"code","199727b5":"code","cf5af9b0":"code","fc5182b3":"code","fc5f6800":"code","5c0981b6":"code","04b05094":"code","99c5502c":"code","96b6b62c":"code","67e0183f":"code","7f13e994":"code","9edcf6bd":"code","6cea876f":"code","7538abb4":"code","264967e8":"code","6880d158":"code","e5636691":"code","bd636904":"code","d18da706":"code","bb6d5a2c":"code","f67c41ce":"code","667f92b6":"code","9842ccce":"code","0ea0c3dc":"code","e6afea00":"code","5ce82b37":"code","631edfe9":"code","b8ef6975":"code","977b9558":"code","4a0c6f26":"code","1e368443":"code","937076e0":"code","ae0a2df7":"markdown","d57262c6":"markdown","e9fc1992":"markdown","1e4a315e":"markdown","e112eded":"markdown","369263fb":"markdown","5fd4faf9":"markdown","ba5d7458":"markdown","c733adf1":"markdown","e32d86ed":"markdown","36ba413a":"markdown","f484751f":"markdown","db29f1d5":"markdown","f8fea420":"markdown","609142bd":"markdown","179ce272":"markdown","0aa381f4":"markdown","938b753a":"markdown","db6f8047":"markdown","2ed043d1":"markdown","e3537792":"markdown","076346c1":"markdown","dac89708":"markdown","21390ce5":"markdown"},"source":{"96f42142":"nr_examples_to_prepare = 2000\nwindow_width_input_minutes = 60\nwindow_width_output_minutes = 60*24","a856da74":"import pandas\nprint(\"Your Pandas version is \", pandas.__version__)\nfname = \"\/kaggle\/input\/pump-sensor-data\/sensor.csv\"\ndf = pandas.read_csv( fname )","5a84774f":"type(df)","f5787961":"# The first column has no name. Give it a name!\ndf.rename(columns={ df.columns[0]: \"Samplenr\" }, inplace = True)","a45823e8":"df[:5]","bba04a04":"df.head(7)","2e3a0ec1":"df.tail(3)","baf62429":"df.dtypes","69daaed8":"df.describe()","2fad948c":"possible_machine_states = list(df.machine_status.unique())","e28d262d":"possible_machine_states","05db1ac3":"# Get all rows where machine status was \"NORMAL\"\ndf_status_NORMAL = df[ df[\"machine_status\"] == \"NORMAL\" ]","dc1f06e0":"type(df_status_NORMAL)","498f5096":"df_status_NORMAL.shape","435f3450":"nr_rows_machine_status_NORMAL = df_status_NORMAL.shape[0]","abcd540f":"nr_rows_machine_status_NORMAL","481f819f":"nr_rows_total = df.shape[0]","32f701fc":"nr_rows_total","6d4fe893":"percent_machine_status_NORMAL = \\\n    (nr_rows_machine_status_NORMAL \/ nr_rows_total) * 100.0","bdf5a85d":"percent_machine_status_NORMAL","dd51b29a":"df_status_BROKEN = df[ df[\"machine_status\"] == \"BROKEN\" ]","94107a3f":"df_status_BROKEN","0081638b":"nr_rows_machine_status_BROKEN = df_status_BROKEN.shape[0]","748638c7":"print(\"So {0} times, the pump was broken\".format(nr_rows_machine_status_BROKEN))","08bcd07d":"df_status_RECOVERING = df[ df[\"machine_status\"] == \"RECOVERING\" ]\nnr_rows_machine_status_RECOVERING = df_status_RECOVERING.shape[0]","156be2bb":"percent_machine_status_RECOVERING = \\\n    (nr_rows_machine_status_RECOVERING \/ nr_rows_total) * 100.0","a1339008":"percent_machine_status_RECOVERING","8eabfde0":"import matplotlib.pyplot as plt\n\nxpos = [1,2,3]\ndata = [nr_rows_machine_status_NORMAL,\n        nr_rows_machine_status_BROKEN,\n        nr_rows_machine_status_RECOVERING]\n\nfig, ax = plt.subplots()\nax.bar(xpos,data)\nax.set_xticks(xpos)\nax.set_xticklabels(possible_machine_states)\nax.set_title(\"How often was the machine (pump) in each machine state?\")\nplt.show()","d66f8c23":"df_status_BROKEN","6488b4e3":"row_numbers_machine_BROKEN = list(df_status_BROKEN[\"Samplenr\"].values)","80dadffc":"row_numbers_machine_BROKEN","c4d321e2":"recovering_times_hours = []\n\nfor i in row_numbers_machine_BROKEN:\n    print(\"\\nMachine in status BROKEN in row: {0}\".format(i) )\n    \n    go_further = True\n    j = i\n    while go_further:\n        j += 1\n        machine_status_in_row_j = df.iloc[j][\"machine_status\"]        \n        if machine_status_in_row_j != \"RECOVERING\":\n            go_further = False\n            \n    print(\"Machine went back to status {0} in row: {1}\"\n          .format(machine_status_in_row_j, j-i)\n          )\n    recovering_hours = (j-i)\/60\n    recovering_days  = recovering_hours \/ 24\n    print(\"Machine was in RECOVERING state for {0:.1f} hours \/ {1:.1f} days\"\n          .format( recovering_hours, recovering_days )\n         )\n    \n    recovering_times_hours.append(recovering_hours)","5b3b9545":"recovering_times_hours","3f563880":"import matplotlib.pyplot as plt\nimport numpy as np\n\nxpos = np.arange( len(recovering_times_hours) )\n\nfig, ax = plt.subplots()\nax.bar(xpos,recovering_times_hours)\nax.set_xticks(xpos)\nax.set_xticklabels(xpos)\nax.set_title(\"Duration of RECOVERING phase [in hours] for each of the 7 pump failures\")\nplt.show()","a41dffb1":"min(recovering_times_hours)","61267b79":"max(recovering_times_hours)","851db473":"df[\"sensor_17\"]","4e12f095":"type( df[\"sensor_17\"] )","58c56047":"sensor_values = list( df[\"sensor_17\"] )","c8223798":"type(sensor_values)","b32ae39d":"len(sensor_values)","0c2b7bee":"sensor_values[:10]","1b2fe6db":"import matplotlib.pyplot as plt\n\nsome_few_values = sensor_values[:100]\nmin_val = min(some_few_values)\nmax_val = max(some_few_values)\n\nplt.plot( some_few_values, color=\"green\", linestyle=\"-\",\n          marker=\".\", linewidth=0.5 )\nplt.hlines(min_val, 0,100, color=\"blue\")\nplt.hlines(max_val, 0,100, color=\"red\")\nplt.xlabel(\"Minute\", fontsize=10)\nplt.ylabel(\"Sensor value\", fontsize=10)\nplt.title(\"The first 100 sensor values of Sensor 17\", fontsize=14)\nplt.grid()\n#plt.savefig(\"sensor_17.png\")\nplt.show()","a2861602":"df.isna().sum().sum()","540dc3c8":"df.isna().sum()","c4900a2e":"only_numerical_cols = df.iloc[:,2:54]","408b1d4b":"only_numerical_cols","91c9b507":"df.describe()","6a55a599":"fill_value = -1.0\ndata_with_gaps_filled = df.fillna( fill_value )","56b20f1b":"data_with_gaps_filled.isna().sum()","6edfaffb":"sensordata_cols_only = data_with_gaps_filled.iloc[:,2:54]","1cbba7b7":"sensordata_cols_only","f394603f":"from sklearn.preprocessing import MinMaxScaler\n\n# create a MinMaxScaler with feature range [0,1]\nscaler = MinMaxScaler(feature_range=(0, 1))\n\nscaled_sensor_data = scaler.fit_transform(sensordata_cols_only)","44ace354":"scaled_sensor_data","42b8d447":"window_width_input_minutes = 60\nwindow_width_output_minutes = 60*24","47608a41":"start_minute = 0\na_single_input_window = scaled_sensor_data[start_minute:start_minute+window_width_input_minutes]","79e359d8":"type(a_single_input_window)","8d14e5a7":"# <a_single_input_window> contains the data for 60 minutes\n# for each of the 52 sensors\na_single_input_window.shape","6f121b28":"# Map window to a vector, since we need a 1D input for the MLP\na_single_input_vector = a_single_input_window.flatten()","df6a915b":"a_single_input_vector.shape","82e83b7b":"def check_for_pump_failure(start, stop):\n    \"\"\"\n    Returns 1, if the pump failed in time window\n    (start,stop)\n    \n    Returns 0, else.\n    \"\"\"\n    for minute in range(start,stop):\n        # get the corresponding row from the data\n        machine_state_in_this_minute = df[\"machine_status\"].iloc[minute]\n        if machine_state_in_this_minute in [\"BROKEN\", \"RECOVERING\"]:\n            return 1\n    \n    return 0","faf13b30":"row_numbers_machine_BROKEN","e627e679":"check_for_pump_failure(0,17000)","89495a3c":"check_for_pump_failure(17000,17200)","199727b5":"check_for_pump_failure(20000,30000)","cf5af9b0":"check_for_pump_failure(65000,69318)","fc5182b3":"check_for_pump_failure(65000,69319)","fc5f6800":"# Max row nr such that input window and output window\n# still fit into the time series data?\nmax_row_nr = nr_rows_total-window_width_input_minutes-window_width_output_minutes\n\n# collect the desired number of (input_vec,output_vec) examples\ntraining_pairs = []\nfor example_nr in range(0,nr_examples_to_prepare):\n    \n    # show progress\n    if example_nr % 100 == 0:\n        print(\"Collected examples so far:\", example_nr)\n    \n    # 1. guess a random minute\n    found_example_where_pump_worked_in_input_window = False\n    while not found_example_where_pump_worked_in_input_window:\n    \n        rnd_minute = np.random.randint(0,max_row_nr)\n        \n        # Make sure, the input window does not cover\n        # already a phase where the machine is broken:\n        # We want examples where the input window covers\n        # a normal state and we want to predict whether\n        # the pump will fail or not in the next time window\n        # We do NOT want to collect examples where the machine is\n        # already BROKEN in the input window\n        # (could be too easy to predict whether the machine\n        #  will be broken in the future as well)\n        start = rnd_minute\n        stop  = start+window_width_input_minutes\n        if check_for_pump_failure(start,stop)==0:\n            found_example_where_pump_worked_in_input_window = True\n            \n    \n    # 2. get the input vector from the 2D sensor matrix data\n    a_single_input_window = scaled_sensor_data[rnd_minute:rnd_minute+window_width_input_minutes]\n    a_single_input_vector = a_single_input_window.flatten()\n    \n    # 3. check whether in time range\n    #    (rnd_minute+window_width_input_minutes,\n    #     rnd_minute+window_width_input_minutes+window_width_output_minutes)\n    #    the pump failed\n    start = rnd_minute+window_width_input_minutes\n    stop  = rnd_minute+window_width_input_minutes+window_width_output_minutes\n    output_value = check_for_pump_failure(start,stop)\n    \n    # 4. add a new training pair to list of training pairs\n    training_pairs.append( (a_single_input_vector, output_value) )\n    \n    ","5c0981b6":"len(training_pairs)","04b05094":"input_vec_len = training_pairs[0][0].shape[0]\noutput_vec_len = 1\n\n\nD = np.zeros( (nr_examples_to_prepare, input_vec_len+output_vec_len))\nprint(\"Shape of D is\", D.shape)\n\n# Fill data matrix D with input vec + output vec in each row\nfor nr in range(0,nr_examples_to_prepare):\n    (x,y) = training_pairs[nr]\n    D[nr,0:input_vec_len] = x\n    D[nr,input_vec_len]   = y","99c5502c":"nr_train_samples = int(nr_examples_to_prepare\/2)\nx_train = D[0:nr_train_samples, 0:input_vec_len]\ny_train = D[0:nr_train_samples, input_vec_len]","96b6b62c":"x_train.shape","67e0183f":"y_train.shape","7f13e994":"x_test = D[nr_train_samples:, 0:input_vec_len]\ny_test = D[nr_train_samples:, input_vec_len]","9edcf6bd":"x_test.shape","6cea876f":"y_test.shape","7538abb4":"import tensorflow\ntensorflow.__version__","264967e8":"import tensorflow as tf\nfrom tensorflow.keras import layers\nmodel = tf.keras.Sequential()\nmodel.add(layers.Dense(200, activation='relu', input_shape=(input_vec_len,)) )\nmodel.add(layers.Dense(40, activation='relu'))\nmodel.add(layers.Dense(1))\n\nmodel.compile(optimizer='sgd',               \n              loss=tf.keras.losses.MeanSquaredError(),\n              metrics=['accuracy'])\n\nmodel.build()","6880d158":"model.summary()","e5636691":"history = model.fit(x_train, y_train, epochs=3000)","bd636904":"type(history)","d18da706":"type(history.history)","bb6d5a2c":"history.history[\"loss\"][:20]","f67c41ce":"plt.plot(history.history[\"loss\"])\nplt.show()","667f92b6":"preds = model.predict(x_test)","9842ccce":"preds.shape","0ea0c3dc":"y_test.shape","e6afea00":"preds = preds.flatten()","5ce82b37":"preds.shape","631edfe9":"preds[:20]","b8ef6975":"min(preds)","977b9558":"max(preds)","4a0c6f26":"pump_failure_in_future_window = 0\ncorrectly_predicted_pump_failures = 0\ncorrectly_predicted = 0\nnr_test_samples = preds.shape[0]\n\ntp = 0\ntn = 0\nfp = 0\nfn = 0\n\nfor test_nr in range(0,nr_test_samples):\n    ground_truth_output = y_test[test_nr]\n    if preds[test_nr] < 0.5:\n        predicted_output = 0.0\n    else:\n        predicted_output = 1.0\n    print(\"Test example #{0}: ground truth vs. predicted machine status: {1} vs. {2}\"\n          .format(test_nr, ground_truth_output, predicted_output ))\n    \n    if predicted_output == ground_truth_output:\n        correctly_predicted +=1\n        \n    if ground_truth_output==1:\n        pump_failure_in_future_window += 1\n        if predicted_output == ground_truth_output:\n            correctly_predicted_pump_failures +=1\n            \n    if ground_truth_output==1:\n        if predicted_output == ground_truth_output:\n            # True positive:\n            # There was a pump failure\n            # and the MLP predictor predicted it\n            tp+=1\n        else:\n            # False negative:\n            # There was a pump failure\n            # BUT the MLP predictor predicted it not\n            fn+=1\n            \n    if ground_truth_output==0:        \n        if predicted_output == ground_truth_output:\n            # True negative:\n            # There was no pump failure\n            # and the MLP predictor predicted no pump failure\n            tn+=1\n        else:\n            # False positive:\n            # There was no pump failure\n            # BUT the MLP predictor predicted a pump failure\n            fp+=1\n            \n        \ncorrect_classification_percent = (correctly_predicted\/nr_test_samples)*100.0\nprint(\"\\nCorrectly predicted {0} of {1} test examples --> {2}%\"\n      .format(correctly_predicted, nr_test_samples, correct_classification_percent))\n\nprint(\"\\nIf there was really a pump failure in the future window,\\n\"\n      \"the MLP could predict it in {0} of the {1} pump failure (in future window) example cases.\"\n      .format(correctly_predicted_pump_failures, pump_failure_in_future_window))\n\nprint(\"True positive:\", tp)\nprint(\"True negative:\", tn)\nprint(\"False positive:\", fp)\nprint(\"False negative:\", fn)","1e368443":"precision = tp\/(tp+fp)\nrecall = tp\/(tp+fn)\nprint(\"Precision: {0:.2f}\".format(precision))\nprint(\"Recall   : {0:.2f}\".format(recall))","937076e0":"print(\"The machine status can be predicted with an accuracy of {0}%\".format(correct_classification_percent)) ","ae0a2df7":"Jetzt bauen wir das MLP mit Keras zusammen!","d57262c6":"# Build MLP and train it","e9fc1992":"Jetzt trainieren wir das Modell!","1e4a315e":"# How long did the 7 RECOVERING phases need?","e112eded":"![image.png](attachment:image.png)","369263fb":"## From example data matrix get train and test matrices","5fd4faf9":"# Test the final MLP","ba5d7458":"# Introduction: Predicting pump failures with a MLP","c733adf1":"# Show some of the rows from the .csv file","e32d86ed":"# Sketch of the approach","36ba413a":"## Prepare example data","f484751f":"## Prepare a large example data matrix D from the list of training pairs","db29f1d5":"## How to check whether the pump failed in some time window after the input window","f8fea420":"# Fill data gaps (NaN values)","609142bd":"## How to get an example input window","179ce272":"# Which different machine states are there and how often?","0aa381f4":"# Read in the sensor and machine status data","938b753a":"# Visualize some of the sensor data","db6f8047":"How many missing values are there in total?","2ed043d1":"The MLP will be trained e.g. on 2000\/2=1000 training samples, where the input window covers 60 minutes (1 hour of sensor data).\n\nThe MLP input vector x length will be accordingly 60 minutes x 52 sensor samples\/minute = a 3120-dimensional input vector.\n\nThe MLP output vector y length is 1 (just one output neuron).\nFor checking whether there was a pump failure after the input window (so for generating the teacher vectors y), we check in some time window of length 60 x 24 (i.e. 1 day = 60 minutes * 24 hours), whether the machine went into state \"BROKEN\" or \"RECOVERING\".\n\n1000 randomly extracted samples (x,y) will be used for training.\n\n1000 randomly extracted samples (x,y) will be used for testing.\n\nFor generating one of these 2000 training samples we\n- randomly choose a sample minute\n- compute the input vector x from the input window starting at this minute\n- compute the output vector y by checking whether in the following time window the pump failed\n- combine both the input and output vector into one training sample (x,y)","e3537792":"Scale data column-wise to feature range [0,1]. If all inputs are in the same range, it makes it easier for a MLP to learn.","076346c1":"# Conclusion","dac89708":"Notebook by J\u00fcrgen Brauer, [www.juergenbrauer.org](http:\/\/www.juergenbrauer.org)\n\nIn this notebook we will show that we can learn a MLP for predicting whether a water pump will fail in a future time window or not. The prediction \/ pump failure classification rate is about 97% for the following settings.\n\nThe input for the MLP is a time window of some specified length of the pump sensor data (52 sensors, called \"sensor_00\" till \"sensor_51\").\n\nThe output of the MLP is a single output neuron:\n- 0 means: there will be no failure (machine status \"NORMAL\")\n- 1 means: there will be a pump failure (machine status \"BROKEN\"\/\"RECOVERING\").\n\nThe following settings are used:","21390ce5":"# Prepare data for training and testing"}}