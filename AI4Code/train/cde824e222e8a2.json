{"cell_type":{"a175f4e5":"code","1be8e5c8":"code","b0e11b39":"code","f2976163":"code","72f1aafa":"code","2cb8b870":"code","ae80b22a":"code","451d4cb9":"code","8aa00169":"code","906f7b2f":"code","953fa728":"code","53c0a74b":"code","c60eaf41":"code","b15a9fd4":"code","1f4dad72":"code","094d89ba":"code","bd027814":"markdown","d63a3cf9":"markdown","f8ec311f":"markdown","b76c971c":"markdown","147ba84d":"markdown","0f6e2d42":"markdown","027ff661":"markdown","6826dfda":"markdown"},"source":{"a175f4e5":"%%capture\n!pip install --upgrade pip\n!pip install ChannelAttribution\n\nimport numpy as np\nimport pandas as pd\npd.options.mode.chained_assignment = None\nimport plotly.express as px\n\nfrom ChannelAttribution import *\nimport plotly.io as pio\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.style as style\nimport seaborn as sns\n%matplotlib inline\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename));","1be8e5c8":"#Importing the data\ndf = pd.read_csv('\/kaggle\/input\/attribution-data\/attribution data.csv')\ndf['time'] = pd.to_datetime(df['time'])\ndf.head()","b0e11b39":"#Plotting conversions over time by channel\nconversions = df.loc[df['conversion'] == 1]\nconversions['time'] = conversions['time'].dt.date\nconversions = conversions[conversions['time']< pd.to_datetime(\"2018-7-30\").date()]\nconversions.drop(columns = ['cookie', 'interaction'], inplace = True)\nconversions = conversions.groupby(['time','channel'], as_index=False).sum()\n\nfig = px.line(conversions, x='time', y='conversion', color='channel')\n\nfig.update_layout(title='Channel Conversions over Time',\n                   xaxis_title='Conversions',\n                   yaxis_title='Date')\nfig.show()","f2976163":"#Creating the path order for when users interact with different channels (this is equivalent to SQL window functions)\ndf['path_order'] = df.sort_values(['time']).groupby(['cookie']).cumcount() + 1\ndf.head()","72f1aafa":"#Aggregating the channels a user interacted with into a single row\ndf_paths = df.groupby('cookie')['channel'].agg(lambda x: x.tolist()).reset_index()\ndf_paths = df_paths.rename(columns={\"channel\": \"path\"})\ndf_paths.head()","2cb8b870":"#Looking at the last interaction to see if it led to a user converting\ndf_last_interaction = df.drop_duplicates('cookie', keep='last')[['cookie', 'conversion', 'conversion_value']]\ndf_last_interaction.head()","ae80b22a":"#Concatinating with the dataframes of user path's\ndf_paths = pd.merge(df_paths, df_last_interaction, how='left', on='cookie')\ndf_paths.head()","451d4cb9":"print('Total conversions: {}'.format(sum(df.conversion)))\nprint('Total conversion rate: {}%'.format(round(sum(df.conversion) \/ len(df)*100)))\nprint('Total value of conversions: ${}'.format(round(sum(df.conversion_value))))\nprint('Average conversion value: ${}'.format(round(sum(df.conversion_value) \/ sum(df.conversion))))","8aa00169":"#We will create a variable \u2018path\u2019 in the specific formatrequired by the Attribution Model where the ordered channels a user interacts with are delimited by'>'\ndef listToString(df):  \n    str1 = \"\"  \n    for i in df['path']:  \n        str1 += i + ' > '    \n    return str1[:-3]\n\ndf_paths['path'] = df_paths.apply(listToString, axis=1)\ndf_paths.head()","906f7b2f":"#Removing the user's cookie and grouping by the path to see the how many times a specific combination of channels led to a conversion or null outcome\ndf_paths.drop(columns = 'cookie', inplace = True)\ndf_paths['null'] = np.where(df_paths['conversion'] == 0,1,0)\n\nattribution_df = df_paths.groupby(['path'], as_index = False).sum()\nattribution_df.rename(columns={\"conversion\": \"total_conversions\", \"null\": \"total_null\", \"conversion_value\": \"total_conversion_value\"}, inplace = True)\nattribution_df.sample(10)","953fa728":"#Now, we will use the ChannelAttribution package to create the attribution models described above\n\n#Heuristic models\nH=heuristic_models(attribution_df,\"path\",\"total_conversions\",var_value=\"total_conversion_value\")\n\n#Markov Models\nM=markov_model(attribution_df, \"path\", \"total_conversions\", var_value=\"total_conversion_value\")","53c0a74b":"R=pd.merge(H,M,on=\"channel_name\",how=\"inner\")\nR1=R[[\"channel_name\",\"first_touch_conversions\",\"last_touch_conversions\",\\\n\"linear_touch_conversions\",\"total_conversions\"]]\nR1.columns=[\"channel_name\",\"first_touch\",\"last_touch\",\"linear_touch\",\"markov_model\"]\n\nR1=pd.melt(R1, id_vars=\"channel_name\")\n\ndata = [dict(type = \"histogram\", histfunc=\"sum\",x = R1.channel_name, y = R1.value,\n             transforms = [dict(type = \"groupby\", groups = R1.variable,)],)]\n\nfig = dict({\"data\":data}) \npio.show(fig,validate=False)","c60eaf41":"R2=R[[\"channel_name\",\"first_touch_value\",\"last_touch_value\",\\\n\"linear_touch_value\",\"total_conversion_value\"]]\nR2.columns=[\"channel_name\",\"first_touch\",\"last_touch\",\"linear_touch\",\"markov_model\"]\n\nR2=pd.melt(R2, id_vars=\"channel_name\")\ndata = [dict(type = \"histogram\", histfunc=\"sum\", x = R2.channel_name, y = R2.value,\n             transforms = [dict(type = \"groupby\",groups = R2.variable,)],)]\n\nfig = dict({\"data\":data})\npio.show(fig,validate=False)","b15a9fd4":"transition_matrix = transition_matrix(attribution_df, \"path\", \"total_conversions\", var_null=\"total_null\")","1f4dad72":"matrix = transition_matrix['transition_matrix']\nmatrix = pd.pivot_table(matrix, values='transition_probability', index=['channel_from'],\n                    columns=['channel_to'], aggfunc=np.sum)\n\ncolumn_dict = transition_matrix['channels'].set_index('id_channel')['channel_name'].to_dict()\nkeys_values = column_dict.items()\ncolumn_dict = {str(key): str(value) for key, value in keys_values}\n\nmatrix = matrix.rename(mapper=column_dict, axis=1).rename(mapper=column_dict, axis=0)\nmatrix.fillna(0, inplace = True)","094d89ba":"#Heat map for transition probabilities in the data set\nfig = plt.figure(figsize = (14,9))\nstyle.use('ggplot')\nsns.set_style('whitegrid')\n\nsns.heatmap(matrix, cmap=sns.diverging_palette(20, 220, n=200), annot=True, center = 0,\\\n            annot_kws={'size':12}, cbar=False)\nplt.yticks(rotation=0, fontsize = 12)\nplt.xticks(fontsize = 12)","bd027814":"The bar chart above shows how many conversions were attributed to each channel for each model (i.e. first_touch, last_touch, etc.). Analyzing the graph, specifically the markov_model in comparison to the other methods, you can gain insights as to the relative importance of different marketing channels.\nFor the first touch, last touch and linear touch models, Facebook and Paid Search are the most import channels driving conversions while Instagram and Online Display are the least important. However, according to the Markov Model, Instagram is far more important to our conversions than our simple attribution models suggest - indeed according to the probabilistic model it is infact our third most important channel.\n\nSimilar to the total conversions bar chart, a revenue bar chart can be created highlighting the revenue attributed to each channel.","d63a3cf9":"# Conclusions\n\nUsing the heat map and the plots above we not only gain insights into how each marketing channel is driving conversions, but we also gain critical information around how our  channels are interacting with each other, driving users one channel to another. Given the number of touchpoints a user today typically faces, this information can prove to be extremely valuable and allows us to optimize our multi-channel customer journeys accordingly. Using the Markov Chain approach outlined in this article will allow your attributions to more accurately reflect how your users are interacting with your marketing.","f8ec311f":"Advertisers use a variety of online marketing channels to reach consumers and they typically want to know how much each channel contributes to their marketing success. This is what is known as multi-channel attribution. In many cases, advertisers approach this problem using some simple heuristical models that often  underestimate the importance of different marketing channels.\nIn general, there are different types of attribution models:\n\n* **First Touch Conversion:** A user's conversion is attributed to the first channels\/touchpoints.\n* **Last Touch Conversion:** A user's conversion is attributed to the last channels\/touchpoints.\n* **Linear Touch Conversion:** All channels\/touchpoints are given equal credit to a user's conversion.\n* **Markov chains:** A probabilistic model that represents the buyer's journey as a graph, with the nodes representing different channels\/touchpoints, and the connecting lines being observed transitions between them. The number of times buyers have transitioned between two states is converted into a probability, which can then be used to measure the importance of each channel and the most likely channel paths to success.\n\n*Example Markov Chain where C denotes the marketing channel*:\n\n![image.png](attachment:image.png)","b76c971c":"# Data Pre-processing","147ba84d":"As expected, the total revenue attributed to each channel corresponds to the number of conversions that it generates.\n\nTo get an idea of how the different channels affect a user's journeys we can also look at the transition probability matrix, which can be visualized in a heatmap.","0f6e2d42":"# Attribution Modelling","027ff661":"# Data\nFor this analysis, I used the following [dataset](http:\/\/www.dropbox.com\/sh\/m5d8u7inolw32xu\/AADuHNcGToa7ajTcF_JjEkcca?dl=0), showing digital marketing data that one would typically encounter in a production environment. The data set contains 586,000 marketing touch-points from July (2018), comprising 240,000 unique customers who generated ~18,000 conversions. \n\nA more detailed description of the features is shown below:\n* Cookie: Anonymous customer id enabling us to track the progression of a given customer\n* Timestamp: Date and time when the visit took place\n* Interaction: Categorical variable indicating the type of interaction that took place\n* Conversion: Boolean variable indicating whether a conversion took place\n* Conversion Value: Value of the potential conversion event (revenue)\n* Channel: The marketing channel that brought the customer to our site\n\n","6826dfda":"# Simple EDA"}}