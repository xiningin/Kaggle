{"cell_type":{"68efe987":"code","5a6b66e5":"code","c9c1ef9f":"code","0d3a7a4f":"code","5100a4ec":"code","c077c92f":"code","dafa07eb":"code","a8bcf972":"code","343e7cb2":"code","94e36dae":"code","a45dba35":"code","00bd2719":"code","6c046da7":"code","2578676e":"code","59252932":"code","e49f1144":"code","c2d39186":"code","4687410a":"code","cc020062":"code","93650a35":"code","6fb7cc16":"code","7e2486ca":"code","d1db93b2":"code","eaa65a96":"code","5ed8fe8a":"code","68ede190":"code","381262a5":"code","af32efe6":"code","8c6f1fce":"code","3e56fc11":"code","14ded036":"code","fcf09223":"code","23f65364":"code","8fcd62e3":"code","b7cce970":"code","3ea9a688":"code","687bf277":"code","b888dfbc":"code","7eb5a174":"code","96762510":"code","21ff4742":"code","27eb3f0f":"code","ec0d70c8":"code","2473be4e":"code","c96e64de":"code","3c9e37f7":"code","c3cf80f4":"code","47eedb14":"code","df02ce94":"code","f3a20152":"code","904d0e73":"markdown","27e57e0e":"markdown","bd4e42fe":"markdown","a38329ce":"markdown","eb451a90":"markdown","42eaf015":"markdown","2c451595":"markdown","380108b3":"markdown","0ab5feec":"markdown","eb409c8d":"markdown","7f225cff":"markdown","1b77f4ef":"markdown","4cecd044":"markdown","a5900927":"markdown","775d7f42":"markdown","65b1c4c4":"markdown","25daac49":"markdown"},"source":{"68efe987":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n%matplotlib inline\n\nimport plotly.express as px\nimport plotly.offline as py\nimport plotly.graph_objs as go\nimport plotly.tools as tls\nimport plotly.figure_factory as ff\n\nfrom sklearn.model_selection import train_test_split, GridSearchCV\nfrom sklearn.metrics import (accuracy_score, \n                            classification_report,\n                            roc_auc_score, roc_curve, auc, precision_recall_curve,\n                            confusion_matrix)\n\n# from xgboost import XGBClassifier\nfrom sklearn.ensemble import ExtraTreesClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import StratifiedKFold, KFold\nimport xgboost as xgb\nfrom xgboost import XGBClassifier\n\nfrom tqdm import tqdm\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# import shap\n\npd.set_option('display.max_rows', 250)","5a6b66e5":"raw_data = pd.read_csv(\"..\/input\/patient\/dataset.csv\")\nraw_data","c9c1ef9f":"raw_data.shape","0d3a7a4f":"raw_data.info(verbose=True, null_counts=True)","5100a4ec":"raw_data.describe()","c077c92f":"raw_data.isnull().sum(axis=0).sort_values(ascending=False)","dafa07eb":"print(\"Number of rows with missing values:\", raw_data.isnull().any(axis=1).sum())","a8bcf972":"large_missing = raw_data.isnull().sum(axis=0).sort_values(ascending=False)[raw_data.isnull().sum(axis=0).sort_values(ascending=False) > 25000]\n\nprint(\"\\nTotal features with more than\", 25000, \"missing values:\", len(large_missing))\n\nraw_data.drop(large_missing.index.tolist() + ['encounter_id', 'icu_admit_source', 'icu_id', 'icu_stay_type', 'patient_id', 'hospital_id'], \n              axis=1,\n             inplace = True)\nraw_data","343e7cb2":"raw_data.nunique()","94e36dae":"raw_data = raw_data[raw_data[['bmi', 'weight', 'height']].isna().sum(axis=1) == 0]\nraw_data","a45dba35":"fig = px.histogram(raw_data[['age','gender','hospital_death','bmi']].dropna(), x=\"age\", y=\"hospital_death\", color=\"gender\",\n                   marginal=\"box\", # or violin, rug\n                   hover_data=raw_data[['age','gender','hospital_death','bmi']].columns)\nfig.show()","00bd2719":"age_death_F=raw_data[raw_data['gender']=='F'][['age','hospital_death']].groupby('age').mean().reset_index()\nage_death_M=raw_data[raw_data['gender']=='M'][['age','hospital_death']].groupby('age').mean().reset_index()\nfrom plotly.subplots import make_subplots\nfig = make_subplots()\nfig.add_trace(\n    go.Scatter(x=age_death_F['age'], y=age_death_F['hospital_death'], name=\"Female patients\"))\nfig.add_trace(\n    go.Scatter(x=age_death_M['age'], y=age_death_M['hospital_death'],name=\"Male patients\"))\nfig.update_layout(\n    title_text=\"<b>Average hospital death probability of patients<b>\")\nfig.update_xaxes(title_text=\"<b>patient age<b>\")\nfig.update_yaxes(title_text=\"<b>Average Hospital Death<\/b>\", secondary_y=False)\nfig.show()","6c046da7":"weight_df=raw_data[['weight','hospital_death','bmi']]\nweight_df['weight']=weight_df['weight'].round(0)\nweight_df['bmi']=weight_df['bmi'].round(0)\nweight_death=weight_df[['weight','hospital_death']].groupby('weight').mean().reset_index()\nbmi_death=weight_df[['bmi','hospital_death']].groupby('bmi').mean().reset_index()\nfig = make_subplots(rows=1, cols=2, shared_yaxes=True)\nfig.add_trace(\n    go.Scatter(x=weight_death['weight'], y=weight_death['hospital_death'], name=\"Weight\"),\n   row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(x=bmi_death['bmi'], y=bmi_death['hospital_death'], name=\"BMI\"),\n    row=1, col=2\n)\nfig.update_layout(\n    title_text=\"<b>impacts of BMI and weight over patients<b>\"\n)\nfig.update_yaxes(title_text=\"<b>Average Hospital Death\")\nfig.show()","2578676e":"ICU_type=raw_data[['icu_type','age','hospital_death']]\nICU_type['icu_type']=ICU_type['icu_type'].replace({'CTICU':'CCU-CTICU',\n                                              'Cardiac ICU':'CCT-CTICU',\n                                              'CTICU':'CCT-CTICU',\n                                              'CSICU':'SICU'})\n#ICU_type['pre_icu_los_days']=ICU_type['pre_icu_los_days'].round(0)\nICU_df=ICU_type.groupby(['icu_type','age']).mean().reset_index()\nICU_df['count']=ICU_type.groupby(['icu_type','age']).count().reset_index()['hospital_death']\n\nfig = px.scatter(ICU_df, x=\"age\", y=\"hospital_death\", size=\"count\", color=\"icu_type\",\n           hover_name=\"icu_type\", log_x=False, size_max=60,)\nfig.update_layout(\n    title_text=\"<b>Survival rate at different types of ICU<b>\"\n)\nfig.update_yaxes(title_text=\"<b>Average Hospital Death<b>\")\nfig.update_xaxes(title_text=\"<b>Age<b>\")\nfig.show()","59252932":"apache3=raw_data[['age','apache_3j_bodysystem','hospital_death']]\napache3=apache3.groupby(['apache_3j_bodysystem','age']).agg(['size','mean']).reset_index()\n\napache3['size']=apache3['hospital_death']['size']\napache3['mean']=apache3['hospital_death']['mean']\n\napache3.drop('hospital_death',axis=1,inplace=True)\n\nsystems =list(apache3['apache_3j_bodysystem'].unique())\ndata = []\nlist_updatemenus = []\nfor n, s in enumerate(systems):\n    visible = [False] * len(systems)\n    visible[n] = True\n    temp_dict = dict(label = str(s),\n                 method = 'update',\n                 args = [{'visible': visible},\n                         {'title': '<b>'+s+'<b>'}])\n    list_updatemenus.append(temp_dict)\n    \n\nfor s in systems:\n    mask = (apache3['apache_3j_bodysystem'].values == s) \n    trace = (dict(visible = False,     \n        x = apache3.loc[mask, 'age'],\n        y = apache3.loc[mask, 'mean'],\n        mode = 'markers',\n        marker = {'size':apache3.loc[mask, 'size']\/apache3.loc[mask,'size'].sum()*1000,\n                 'color':apache3.loc[mask, 'mean'],\n                 'showscale': True})\n                   )\n    data.append(trace)\n\ndata[0]['visible'] = True    \n    \nlayout = dict(updatemenus=list([dict(buttons= list_updatemenus)]),\n              xaxis=dict(title = '<b>Age<b>', range=[min(apache3.loc[:, 'age'])-10, max(apache3.loc[:, 'age']) + 10]),\n              yaxis=dict(title = '<b>Average Hospital Death<b>', range=[min(apache3.loc[:, 'mean'])-0.1, max(apache3.loc[:, 'mean'])+0.1]),\n              title='<b>Survival Rate<b>' )\nfig = dict(data=data, layout=layout)\npy.iplot(fig, filename='update_dropdown')","e49f1144":"unpivot = pd.melt(raw_data, raw_data.describe().columns[0], raw_data.describe().columns[1:])\n\ng = sns.FacetGrid(unpivot, col=\"variable\", col_wrap=3, sharex=False, sharey=False)\ng.map(sns.kdeplot, \"value\")\n\nplt.show()","c2d39186":"numerical_cat = [\n 'elective_surgery',\n 'apache_post_operative',\n 'arf_apache',\n 'gcs_unable_apache',\n 'intubated_apache',\n 'ventilated_apache',\n 'aids',\n 'cirrhosis',\n 'diabetes_mellitus',\n 'hepatic_failure',\n 'immunosuppression',\n 'leukemia',\n 'lymphoma',\n 'solid_tumor_with_metastasis']\n\ncategorical = ['ethnicity',\n 'gender',\n 'icu_type',\n 'apache_3j_bodysystem',\n 'apache_2_bodysystem']\n","4687410a":"raw_data.nunique()[raw_data.nunique() == 2].index.tolist()","cc020062":"raw_data.select_dtypes(include='O').columns.values.tolist()","93650a35":"not_numeric = raw_data[numerical_cat + categorical + ['hospital_death']].columns.tolist()\nnumeric_only = raw_data.drop(not_numeric,axis=1).columns.tolist()\nnumeric_only","6fb7cc16":"for col in numerical_cat:\n    raw_data[col] = raw_data[col].astype('Int64')\n    \nfor col in numerical_cat:\n    raw_data[col] = raw_data[col].fillna(raw_data[col].mode()[0])","7e2486ca":"raw_data[numeric_only].isna().sum(axis=0).sort_values(ascending=False)","d1db93b2":"split_one = raw_data[numeric_only].isna().sum(axis=0).sort_values()[raw_data[numeric_only].isna().sum(axis=0) < 11000].index.tolist()\nsplit_two = raw_data[numeric_only].isna().sum(axis=0).sort_values()[raw_data[numeric_only].isna().sum(axis=0) > 11000].index.tolist()","eaa65a96":"split_two","5ed8fe8a":"for col in split_two:\n    raw_data[col] = raw_data[col].fillna(raw_data[col].mean())\n\nprocess_data = raw_data.dropna(axis=0)","68ede190":"process_data[categorical].nunique()","381262a5":"icu_data = pd.get_dummies(process_data,\n    prefix='isin',\n    prefix_sep='_',\n    columns=categorical,\n    drop_first=False)\nicu_data.reset_index(drop = True, inplace = True)\nicu_data","af32efe6":"icu_data.columns = [x.lower() for x in icu_data.columns.tolist()]\nicu_data = icu_data.loc[:,~icu_data.columns.duplicated()]","8c6f1fce":"t = icu_data['arf_apache'].dtype\nfor col in tqdm(icu_data.columns.tolist()):\n    if icu_data[col].values.dtype == 'uint8' or t == icu_data[col].values.dtype:\n        icu_data[col] = icu_data[col].astype(int)","3e56fc11":"icu_data.dtypes","14ded036":"X = icu_data.drop(['hospital_death'], axis=1)\ny = icu_data['hospital_death']\n\nX_new = X[['apache_4a_hospital_death_prob','apache_4a_icu_death_prob','age','d1_spo2_min','d1_resprate_max','d1_heartrate_min']]\n\nX_train, X_test, y_train, y_test = train_test_split(X_new, y, test_size=0.30, \n                                                    random_state=11, \n                                                    stratify = y)","fcf09223":"print(X_train.shape)\nprint(y_train.shape)","23f65364":"import keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense\n\n\n# Neural network\nmodel = Sequential()\nmodel.add(Dense(6, input_dim=6, activation='relu'))\nmodel.add(Dense(3, activation='relu'))\n# model.add(Dense(30, activation='relu'))\nmodel.add(Dense(1,activation='sigmoid'))","8fcd62e3":"import tensorflow as tf\nopt = tf.keras.optimizers.SGD(learning_rate=0.00001)","b7cce970":"model.compile(loss='binary_crossentropy', optimizer=opt, metrics=['accuracy'])","3ea9a688":"history = model.fit(X_train, y_train,validation_data=(X_test,y_test), epochs=20, batch_size=64)\n","687bf277":"from tensorflow import keras","b888dfbc":"# m = keras.models.load_model('..\/input\/patient-survival-pb-files')","7eb5a174":"# m.predict([[1,2,3,4,5,6]])","96762510":"import matplotlib.pyplot as plt\nplt.plot(history.history['accuracy'])\nplt.plot(history.history['val_accuracy'])\nplt.title('model accuracy')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['train', 'val'], loc='upper left')\nplt.show()","21ff4742":"pd.DataFrame(history.history).plot(figsize=(12,8))\nplt.show()","27eb3f0f":"X = icu_data.drop(['hospital_death'], axis=1)\ny = icu_data['hospital_death']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, \n                                                    random_state=11, \n                                                    stratify = y)","ec0d70c8":"y_train.value_counts()","2473be4e":"y_test.value_counts()","c96e64de":"def model_performance(model, y_test, y_hat) : \n    conf_matrix = confusion_matrix(y_test, y_hat)\n    trace1 = go.Heatmap(z = conf_matrix  ,x = [\"0 (pred)\",\"1 (pred)\"],\n                        y = [\"0 (true)\",\"1 (true)\"],xgap = 2, ygap = 2, \n                        colorscale = 'Viridis', showscale  = False)\n\n    #Show metrics\n    tp = conf_matrix[1,1]\n    fn = conf_matrix[1,0]\n    fp = conf_matrix[0,1]\n    tn = conf_matrix[0,0]\n    Accuracy  =  ((tp+tn)\/(tp+tn+fp+fn))\n    Precision =  (tp\/(tp+fp))\n    Recall    =  (tp\/(tp+fn))\n    F1_score  =  (2*(((tp\/(tp+fp))*(tp\/(tp+fn)))\/((tp\/(tp+fp))+(tp\/(tp+fn)))))\n\n    show_metrics = pd.DataFrame(data=[[Accuracy , Precision, Recall, F1_score]])\n    show_metrics = show_metrics.T\n\n    colors = ['gold', 'lightgreen', 'lightcoral', 'lightskyblue']\n    trace2 = go.Bar(x = (show_metrics[0].values), \n                   y = ['Accuracy', 'Precision', 'Recall', 'F1_score'], text = np.round_(show_metrics[0].values,4),\n                    textposition = 'auto',\n                   orientation = 'h', opacity = 0.8,marker=dict(\n            color=colors,\n            line=dict(color='#000000',width=1.5)))\n    \n    #Roc curve\n    model_roc_auc = round(roc_auc_score(y_test, y_hat) , 3)\n    fpr, tpr, t = roc_curve(y_test, y_hat)\n    trace3 = go.Scatter(x = fpr,y = tpr,\n                        name = \"Roc : \" + str(model_roc_auc),\n                        line = dict(color = ('rgb(22, 96, 167)'),width = 2), fill='tozeroy')\n    trace4 = go.Scatter(x = [0,1],y = [0,1],\n                        line = dict(color = ('black'),width = 1.5,\n                        dash = 'dot'))\n    \n    # Precision-recall curve\n    precision, recall, thresholds = precision_recall_curve(y_test, y_hat)\n    trace5 = go.Scatter(x = recall, y = precision,\n                        name = \"Precision\" + str(precision),\n                        line = dict(color = ('lightcoral'),width = 2), fill='tozeroy')\n    \n     \n    #plots\n    model = model\n    \n    #Subplots\n    fig = tls.make_subplots(rows=2, cols=2, print_grid=False, \n                          specs=[ \n#                               [{'colspan': 2}, None],\n                                 [{}, {}],\n                                 [{}, {}],\n                                 \n#                                  [{'colspan': 2}, None]\n                                ],\n                          subplot_titles=('Confusion Matrix',\n                                        'Metrics',\n                                        'ROC curve'+\" \"+ '('+ str(model_roc_auc)+')',\n                                        'Precision - Recall curve',\n                                        ))\n    \n    fig.append_trace(trace1,1,1)\n    fig.append_trace(trace2,1,2)\n    fig.append_trace(trace3,2,1)\n    fig.append_trace(trace4,2,1)\n    fig.append_trace(trace5,2,2)\n    \n    fig['layout'].update(showlegend = False, title = '<b>Model performance report<\/b><br>'+str(model),\n                        autosize = False, height = 1500,width = 830,\n                        plot_bgcolor = 'rgba(240,240,240, 0.95)',\n                        paper_bgcolor = 'rgba(240,240,240, 0.95)',\n                        margin = dict(b = 195))\n#     fig[\"layout\"][\"xaxis2\"].update((dict(range=[0, 1])))\n#     fig[\"layout\"][\"xaxis3\"].update(dict(title = \"false positive rate\"))\n#     fig[\"layout\"][\"yaxis3\"].update(dict(title = \"true positive rate\"))\n#     fig[\"layout\"][\"xaxis4\"].update(dict(title = \"recall\"), range = [0,1.05])\n#     fig[\"layout\"][\"yaxis4\"].update(dict(title = \"precision\"), range = [0,1.05])\n#     fig[\"layout\"][\"xaxis5\"].update(dict(title = \"Percentage contacted\"))\n#     fig[\"layout\"][\"yaxis5\"].update(dict(title = \"Percentage positive targeted\"))\n    fig.layout.titlefont.size = 14\n    \n    py.iplot(fig)","3c9e37f7":"gkf = KFold(n_splits=3, shuffle=True, random_state=42).split(X=X_train, y=y_train)\n\nfit_params_of_xgb = {\n    \"early_stopping_rounds\":100, \n    \"eval_metric\" : 'auc', \n    \"eval_set\" : [(X_test, y_test)],\n    'verbose': 100,\n}\n\n\n# A parameter grid for XGBoost\nparams = {\n    'booster': [\"gbtree\"],\n    'learning_rate': [0.1],\n    'n_estimators': range(100, 500, 100),\n    'min_child_weight': [1],\n    'gamma': [0],\n    'subsample': [0.8],\n    'colsample_bytree': [0.8],\n    'max_depth': [5],\n    \"scale_pos_weight\": [1]\n}\n\nxgb_estimator = XGBClassifier(\n    objective='binary:logistic',\n    # silent=True,\n)\n\ngsearch = GridSearchCV(\n    estimator=xgb_estimator,\n    param_grid=params,\n    scoring='roc_auc',\n    n_jobs=-1,\n    cv=gkf\n)\n\nxgb_model = gsearch.fit(X=X_train, y=y_train, **fit_params_of_xgb)\n(gsearch.best_params_, gsearch.best_score_)","c3cf80f4":"xgb_tuned = XGBClassifier(n_estimators=3000,\n    objective='binary:logistic',\n    booster=\"gbtree\",\n    learning_rate=0.01,\n    scale_pos_weight=1,\n    max_depth=4,\n    min_child_weight=6,\n    gamma=0,\n    subsample=0.4,\n    colsample_bytree=0.8,\n    reg_alpha=0.08,\n    n_jobs=-1)\n\nxgb_tuned.fit(X_train._get_numeric_data(), np.ravel(y_train, order='C'))\ny__hat = xgb_tuned.predict(X_test._get_numeric_data())","47eedb14":"y__hat[21:30]","df02ce94":"model_performance(xgb_tuned,y_test, y__hat)","f3a20152":"X_test_sample = X_test.sample(2500)\nX_test_sample","904d0e73":"### Univariate-Multivariate Analysis\n\nIndividual plots seldom doesn't help in large datasets, in this approach let's look at the variation of instances according to each context of the column\n\n\n<br> <br> \n\nThe death rate for Male-Female patients is shown below. While the rate of **<span style=\"color: deeppink;\"> female deaths<\/span>** are **<span style=\"color: red;\"> higher <\/span>** the youngest person to pass away during one of the case was a **<span style=\"color: royalblue;\">Male<\/span>** of **16yrs** of age","27e57e0e":"# Modelling","bd4e42fe":"**<span style=\"color: midnightblue;\">Survival rate at different types of ICU<\/span>**\n\n*some of the ICU wards have higher death probability pertaining to being surgical wards*","a38329ce":"# Neural Network","eb451a90":"# Import Libraries","42eaf015":"# Preprocessing\n\nconverting categorical values  \ntranforming numerical columns and removing nulls\n\nNull values for *categories* are replaced by **mode**, and those for *numerical* are replaced by **mean**","2c451595":"**<span style=\"color: midnightblue;\">impacts of BMI and weight over patients<\/span>**","380108b3":"**Density Distribution for numerical columns**","0ab5feec":"columns that can be dropped: **'encounter_id', 'hospital_admit_source', 'icu_admit_source', 'icu_id', 'icu_stay_type', 'patient_id', 'hospital_id', 'readmission_status'**\n\n\nNotice the amount of missing values in each row  \nWe decide a threshold value to delete some of the attributes from the dataset (25k in this approach)  \n**74** columns will get deleted in this turn.","eb409c8d":"**<span style=\"color: midnightblue;\">Average hospital death probability of patients<\/span>**  \n*based on age and gender*","7f225cff":"using one-hot encoder because of large range of **unique values** in categories","1b77f4ef":"# Parameter Tuning","4cecd044":"**<span style=\"color: midnightblue;\">Hospital Death Rate, by age and Medical condition<\/span>**\n","a5900927":"# Importing Data","775d7f42":"# EDA","65b1c4c4":"# Final Model Evaluation","25daac49":"*Removing missing values from some of the inter-related columns (bmi, weight and height)*  \nWe cut down almost 3000 instances with this process safely"}}