{"cell_type":{"7d4f05c1":"code","d86f71ef":"code","95a6646c":"code","959b4d7e":"code","8fb17e7c":"code","df021dd4":"code","7970700c":"code","dca1a014":"code","8204218b":"code","631360b6":"code","403aedbe":"code","f4db3b7e":"code","9bb7d453":"code","e6a8bf74":"code","dc187db1":"code","f2dd9f6f":"code","1e809d03":"code","79b664da":"code","c28f1a0b":"code","c4f6aad7":"code","0d58b722":"code","2222a6df":"code","b27785fc":"code","41297b1f":"code","8633ea82":"code","8abf8565":"code","4979e876":"code","ef002f14":"code","8a955b3a":"code","08edcef2":"code","6ae1c4a6":"code","67b77cde":"code","2f3287fe":"code","fc32ee40":"code","17130e0f":"code","c4c4f5c6":"code","365d5160":"code","d60ee0bb":"code","67505d7f":"code","90e21ee6":"code","e4fa54a9":"code","a205ca83":"code","a054b053":"code","72c58da6":"code","1f095cd6":"code","a9037bf3":"code","7534bef0":"code","b5441bf3":"code","4cf3a312":"code","c0e5ad14":"code","ead42a6c":"code","3362598f":"code","837cee9a":"code","27e62f1e":"code","ccca9a16":"code","bc425a62":"code","f5728f3e":"code","fe2f902f":"code","f093cdbe":"code","19c5f6c3":"code","8dbf4341":"code","687869fe":"code","a2d982a0":"code","0795e224":"code","92b886fe":"code","962a5d66":"code","32ad7e97":"code","af981100":"code","9ab8c053":"code","2eee32f2":"code","a8f22bb6":"code","653b4bbb":"code","3fde85cf":"code","10c4dc80":"code","58001e9a":"code","087bba64":"code","87e4e475":"code","d81a11ba":"code","bfddc1d1":"code","c4502f63":"code","5aa68544":"code","0e783184":"code","e0eb664c":"code","3b30a362":"code","d04e85a6":"code","38e50e50":"code","6e420621":"code","1481fca9":"code","74075b58":"markdown","0ae79865":"markdown","f5c34ed7":"markdown","b51af06f":"markdown","6e20adfa":"markdown","8ce450f5":"markdown","c6abe452":"markdown","afb45084":"markdown","67e0495d":"markdown","b2e38d94":"markdown","b34edee7":"markdown","219f0dbc":"markdown","ac47d508":"markdown","f73f94c6":"markdown","10f32d98":"markdown","9b991102":"markdown","83b9a5b5":"markdown","bda509d6":"markdown","2b0cbdff":"markdown","758a39a1":"markdown","e7ba9f5c":"markdown","de12735f":"markdown","f0728184":"markdown","33532241":"markdown","69d78d4b":"markdown","fae7d250":"markdown","97a02e99":"markdown","0dff4199":"markdown","6d6c2688":"markdown","13d28769":"markdown","16f1d1f3":"markdown","4210287d":"markdown","5257b8ad":"markdown","7ddc7fa4":"markdown","b568ec83":"markdown","04afb287":"markdown","0094b6e8":"markdown","c4e8ae8f":"markdown","aec8c1ef":"markdown","6d34f11a":"markdown","14ee88bd":"markdown","31685526":"markdown","2f8dfca6":"markdown"},"source":{"7d4f05c1":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","d86f71ef":"train = pd.read_csv('\/kaggle\/input\/titanic\/train.csv')\ntest = pd.read_csv('\/kaggle\/input\/titanic\/test.csv')","95a6646c":"train.shape","959b4d7e":"test.shape","8fb17e7c":"train.head()","df021dd4":"train.info()","7970700c":"train.info()","dca1a014":"full = pd.concat([train, test], axis=0, ignore_index=True)","8204218b":"num_features = ['SibSp', 'Parch', 'Age', 'Fare']\nfull.loc[:, num_features].describe()","631360b6":"%matplotlib inline\nimport matplotlib.pyplot as plt\nfull.loc[:, num_features].hist(bins=50, figsize=(20, 15))\nplt.show()","403aedbe":"full['SibSp'].value_counts() \/ len(full) * 100","f4db3b7e":"full['Parch'].value_counts() \/ len(full) * 100","9bb7d453":"age_cat = [0., 15, 30, 45, 64, np.inf]\n(full['Age'].value_counts(bins=age_cat) \/ len(full) * 100).sort_index()","e6a8bf74":"full.loc[:, 'Age'].hist(bins=50, figsize=(20, 15))\nplt.show()","dc187db1":"full.loc[:, 'Fare'].hist(bins=50, figsize=(20, 15))\nplt.show()","f2dd9f6f":"train['Survived'].value_counts() \/ len(train) * 100","1e809d03":"full['Sex'].value_counts() \/ len(full) * 100","79b664da":"full['Embarked'].value_counts()","c28f1a0b":"# Ordinal features\nfull['Pclass'].value_counts().sort_index() \/ len(full) * 100","c4f6aad7":"full['Name'].unique().shape","0d58b722":"full['Name'].apply(lambda x: str.split(x, \",\")[0]).value_counts()","2222a6df":"import re\n\ndef extract_title(name):\n    return re.findall(r\"(\\w+\\.)\", name)[0][:-1]\n\nfull['Name'].apply(extract_title).value_counts()","b27785fc":"full['Ticket'].unique().shape","41297b1f":"full['Cabin'].unique().shape","8633ea82":"full['PassengerId'].unique().shape\n","8abf8565":"# Keep train PassengerId for prediction submission later\ntest_passengerid = test['PassengerId']\n# Drop 4 features 'PassengerId' from train & train\nfor dataset in [train, test, full]:\n    dataset.drop(['PassengerId'], axis=1, inplace=True)\n# Now we only have 10 features & 1 target left","4979e876":"train.shape, test.shape","ef002f14":"full.isna().any()","8a955b3a":"full['Age'].isna().value_counts() \/ len(full) * 100","08edcef2":"full['Fare'].isna().value_counts()","6ae1c4a6":"full['Cabin'].isna().value_counts() \/ len(full) * 100","67b77cde":"full['Embarked'].isna().value_counts() \/ len(full) * 100","2f3287fe":"for dataset in [train, test, full]:\n    dataset.drop(['Cabin', 'Embarked'], axis=1, inplace=True)","fc32ee40":"titanic = train.copy()","17130e0f":"titanic['Sex'] = titanic['Sex'].map({'female': 1, 'male': 0})","c4c4f5c6":"titanic.corr()['Survived']","365d5160":"titanic.groupby('Sex')['Survived'].mean()","d60ee0bb":"titanic.groupby('Pclass')['Survived'].mean()","67505d7f":"titanic.groupby(['Sex','Pclass'])['Survived'].mean()","90e21ee6":"titanic['AgePclass'] = titanic['Age'] * titanic['Pclass']","e4fa54a9":"# Create Title\nimport re\n\ndef extract_title(name):\n    return re.findall(r\"(\\w+\\.)\", name)[0][:-1]\n\ntitanic['Title'] = titanic['Name'].apply(extract_title)\ntitanic['Title'].value_counts()","a205ca83":"ages_to_impute = titanic.groupby(['Title'])['Age'].median()\nages_to_impute","a054b053":"# Fill missing values of 'Age' using 'Title'\ntitles = ages_to_impute.index.tolist()\n\nfor title in titles:\n    age_to_impute = ages_to_impute[titles.index(title)]\n    titanic.loc[(titanic['Age'].isna()) &\n                (titanic['Title'] == title), 'Age'] = age_to_impute","72c58da6":"# Also create 'AgeBand' to have a more symmetric 'Age' features\ntitanic['AgeBand'] = pd.qcut(titanic['Age'], q=5, labels=False)\ntitanic.groupby(['Sex', 'AgeBand'])['Survived'].mean()","1f095cd6":"for age in range(5, 60, 5):\n    survive_rate = titanic[(titanic['Sex'] == 0) &\n                           (titanic['Age'] < age)]['Survived'].mean()\n    print(f\"Male aged under {age} survived: {round(survive_rate * 100, 2)} %\")","a9037bf3":"# Replace titles with a more common name (e.g. 'Ms' with 'Miss')\n\ntitanic['Title'].replace(['Capt', 'Col', 'Don', 'Major', 'Rev', 'Sir',\n                          'Jonkheer', 'Don'], 'Mr', inplace=True)\n\ntitanic.loc[(titanic['Title'] == 'Dr') & (titanic['Sex'] == 1), 'Title'] = 'Mr'\ntitanic.loc[(titanic['Title'] == 'Dr') & (titanic['Sex'] == 0), 'Title'] = 'Mrs'\n\ntitanic['Title'].replace(['Ms', 'Mlle'], 'Miss', inplace=True)\ntitanic['Title'].replace(['Dona', 'Countess', 'Lady', 'Mme'], 'Mrs', inplace=True)\ntitanic['Title'].value_counts().sort_values(ascending=False)","7534bef0":"titanic.groupby(['Title'])['Survived'].mean().sort_values(ascending=False)","b5441bf3":"titanic[titanic['Title'] == 'Master']['Sex'].value_counts()","4cf3a312":"titanic[titanic['Title'] == 'Master']['Age'].max()","c0e5ad14":"titanic['Priority'] = 1\ntitanic.loc[titanic['Title'] == 'Mr', 'Priority'] = 0","ead42a6c":"titanic.groupby('Priority')['Survived'].mean()","3362598f":"titanic['Surname'] = titanic['Name'].apply(lambda x: str.split(x, \",\")[0])\ntitanic['Surname'].value_counts()","837cee9a":"titanic[titanic['Surname'] == 'Sage']['Ticket']","27e62f1e":"def ticketid(ticket):\n    try:\n        # All digits part of a ticket except last character\n        id = re.findall(r\"\\d+\", ticket)[-1]\n        if len(id) > 1:\n            return id[:-1]\n        else:  # For ticket id with only 1 digit.\n            return id\n    except:\n        # For LINE tickets\n        return '000'\n\ntitanic['TicketID'] = titanic['Ticket'].apply(ticketid)\ntitanic['TicketID'] = titanic['TicketID'].astype(int)\ntitanic['TicketID'] += titanic['Pclass'] * 1-000-000 * titanic['Fare']","ccca9a16":"x = titanic[['Priority', 'TicketID', 'Fare']].to_string(header=False, index=False,\n                                            index_names=False).split('\\n')\ntitanic['SamePrioGroup'] = ['-'.join(i.split()) for i in x]\ntitanic['SamePrioGroup'].unique().shape","bc425a62":"titanic.groupby('SamePrioGroup')['Survived'].mean().value_counts()","f5728f3e":"count_same_prio_group = titanic.groupby('SamePrioGroup')['SamePrioGroup'].count()\n\nfor group in titanic['SamePrioGroup'].unique():\n    titanic.loc[titanic['SamePrioGroup'] == group,\n               'SamePrioCompanion'] = count_same_prio_group[group]\n    \ntitanic['SamePrioCompanion'].value_counts()","fe2f902f":"titanic['FarePerPerson'] = titanic['Fare'] \/ titanic['SamePrioCompanion']","f093cdbe":"titanic[titanic['SamePrioCompanion'] > 1].groupby(['SamePrioGroup'])['Survived'].mean().value_counts()","19c5f6c3":"titanic[(titanic['SamePrioCompanion'] > 1) & (titanic['Priority'] == 1)].groupby('SamePrioGroup')['Survived'].mean().value_counts()","8dbf4341":"titanic[(titanic['SamePrioCompanion'] > 1) & (titanic['Priority'] == 0)].groupby('SamePrioGroup')['Survived'].mean().value_counts()","687869fe":"titanic.columns","a2d982a0":"titanic.drop(['Surname', 'Name', 'Title'], axis=1, inplace=True)","0795e224":"titanic.corr()['Survived'].sort_values(ascending=False)","92b886fe":"X_full = pd.concat([train, test], axis=0, ignore_index=True)","962a5d66":"X_full.columns","32ad7e97":"X_full['Sex'] = X_full['Sex'].map({'female': 1, 'male': 0})\nX_full['Title'] = X_full['Name'].apply(extract_title)","af981100":"# Fill Age\nages_to_impute = X_full.groupby(['Title'])['Age'].median()\n\ntitles = ages_to_impute.index.tolist()\n\nfor title in titles:\n    age_to_impute = ages_to_impute[titles.index(title)]\n    X_full.loc[(X_full['Age'].isna()) &\n                (X_full['Title'] == title), 'Age'] = age_to_impute\n","9ab8c053":"# Create AgeBand & AgeClass\n\nX_full['AgeBand'] = pd.qcut(X_full['Age'], q=5, labels=False)\nX_full['AgeClass'] = X_full['Age'] * X_full['Pclass']","2eee32f2":"# Fill Fare\nfares_to_impute = X_full.groupby('Pclass')['Fare'].median()\n\npclasses = [1, 2, 3]\nfor pclass in pclasses:\n    fare_to_impute = fares_to_impute[pclasses.index(pclass) + 1]\n    X_full.loc[(X_full['Fare'].isna()) &\n                (X_full['Pclass'] == pclass), 'Fare'] = fare_to_impute","a8f22bb6":"# Create FareBand\n\nX_full['FareBand'] = pd.qcut(X_full['Fare'], q=5, labels=False)","653b4bbb":"X_full.isna().any()","3fde85cf":"# Replace titles with a more common name (e.g. 'Ms' with 'Miss')\n\nX_full['Title'].replace(['Capt', 'Col', 'Don', 'Major', 'Rev', 'Sir',\n                          'Jonkheer', 'Don'], 'Mr', inplace=True)\n\nX_full.loc[(X_full['Title'] == 'Dr') & (X_full['Sex'] == 0), 'Title'] = 'Mr'\nX_full.loc[(X_full['Title'] == 'Dr') & (X_full['Sex'] == 1), 'Title'] = 'Mrs'\n\nX_full['Title'].replace(['Ms', 'Mlle'], 'Miss', inplace=True)\nX_full['Title'].replace(['Dona', 'Countess', 'Lady', 'Mme'], 'Mrs', inplace=True)","10c4dc80":"# Create Priority variable\nX_full['Priority'] = 1\nX_full.loc[X_full['Title'] == 'Mr', 'Priority'] = 0","58001e9a":"# Extract TicketID\n\nX_full['TicketID'] = X_full['Ticket'].apply(ticketid)\nX_full['TicketID'] = X_full['TicketID'].astype(int)\nX_full['TicketID'] += X_full['Pclass'] * 1-000-000 * X_full['Fare']","087bba64":"# Categorize passengers based on 'Priority', 'Fare', 'TicketID'\n\nx = X_full[['Priority', 'TicketID', 'Fare']].to_string(header=False, index=False,\n                                            index_names=False).split('\\n')\nX_full['SamePrioGroup'] = ['-'.join(i.split()) for i in x]\nX_full['SamePrioGroup'].unique().shape","87e4e475":"# Find passengers who had 1+ companions with same priority in his\/her group\n\ncount_same_prio_group = X_full.groupby('SamePrioGroup')['SamePrioGroup'].count()\nsurvived_same_prio_group = X_full.groupby('SamePrioGroup')['Survived'].mean()\n\n\nfor group in X_full['SamePrioGroup'].unique():\n    X_full.loc[X_full['SamePrioGroup'] == group,\n               'SamePrioCompanion'] = count_same_prio_group[group]\n\n    X_full.loc[X_full['SamePrioGroup'] == group,\n               'SamePrioSurvived'] = survived_same_prio_group[group]\n    \n\n# For groups with people inside test set (no Survived information), we \n# set a default rate of group survival rate to the population survival rate\nX_full['SamePrioSurvived'].fillna(722 \/ (722 + 1502), inplace=True, axis=0)\n","d81a11ba":"# Create FarePerPerson\n\nX_full['FarePerPerson'] = X_full['Fare'] \/ X_full['SamePrioCompanion']","bfddc1d1":"# Feature to find passengers with same priority, same group who had same outcomes\ndef same_outcome(survived_rate):\n    if survived_rate == 1 or survive_rate == 0:\n        return 1\n    else:\n        return 0\n\nX_full['SameOutcome'] = X_full['SamePrioSurvived'].apply(same_outcome)","c4502f63":"X_full.drop(['Survived', 'Name', 'Title', \n             'Ticket', 'SibSp', 'Parch'], axis=1, inplace=True)","5aa68544":"# Standardize numerical features\n\nfor col in ['Age', 'Fare', 'AgeClass', 'FarePerPerson', 'TicketID']:\n    mean = X_full[col].mean()\n    std = X_full[col].std()\n    X_full[col] = (X_full[col] - mean) \/ std","0e783184":"X_train = X_full[:891]\ny_train = train['Survived']\nX_test = X_full[891:]\nX_test.reset_index(inplace=True, drop=True)","e0eb664c":"# Oversample perished people to match population ratio of not survived \n\nnp.random.seed(42)\nnot_survived_ix = train['Survived'][train['Survived'] == 0].index.to_numpy()\nrnd_chosen = np.random.choice(not_survived_ix, 163, replace=False)\nnot_survived_ix = np.r_[not_survived_ix, rnd_chosen]\n\nsurvived_ix = train['Survived'][train['Survived'] == 1].index.to_numpy()\n\nrnd_ix = np.r_[survived_ix, not_survived_ix]\nX_train = X_train.loc[rnd_ix]\ny_train = y_train.loc[rnd_ix]","3b30a362":"# We copy a version of datasets that does not have any information related to\n# the passenger groups. We will only fit and predict the model using these sets.\n# \n# Specifically for passengers who were women\/children in the groups where \n# 2+ other women\/children all survived\/perished, we will predict them \n# as survived\/perished based on their same priority-group outcomes.\n\nX_train_all = X_train.drop(['SamePrioGroup', 'SameOutcome', 'SamePrioSurvived'], axis=1)\nX_test_all = X_test.drop(['SamePrioGroup', 'SameOutcome', 'SamePrioSurvived'], axis=1)","d04e85a6":"from sklearn.model_selection import GridSearchCV, RandomizedSearchCV, StratifiedKFold\n\ndef grid_search(model, param_grid, random=False,\n                n_iter=10, scoring='accuracy', verbose=0):\n    model_name = model.__class__.__name__\n    print(f\"Model: {model_name}\")\n    print(\"-\" * 40)\n\n    cv = StratifiedKFold(n_splits=10, shuffle=True,\n                                random_state=42)\n    if random:\n        model_grid = RandomizedSearchCV(model, param_grid, n_iter=n_iter,\n                                        cv = cv, scoring=scoring,\n                                        refit=True, return_train_score=True,\n                                        random_state=42, n_jobs=-1, verbose=verbose)\n    else:\n        model_grid = GridSearchCV(model, param_grid, cv=cv, scoring=scoring,\n                                  refit=True, return_train_score=True, n_jobs=-1, verbose=verbose)\n\n    model_grid.fit(X_train_all, y_train)\n\n    model_cvres = model_grid.cv_results_\n    mean_scores = model_cvres['mean_test_score']\n    best_score = mean_scores.max()\n    params_space = model_cvres['params']\n\n    for mean_score, params in zip(mean_scores, params_space):\n        result = f'{round(mean_score * 100, 2)}% : {params}'\n        if mean_score == best_score:\n            print('* ', result, ' [BEST]')\n        else:\n            print(result)\n\n    return model_grid, {model_name: round(best_score * 100, 2)}\n","38e50e50":"from sklearn.ensemble import ExtraTreesClassifier\n\nxtree_clf = ExtraTreesClassifier(random_state=42, n_jobs=-1)\nxtree_params = [\n    {'n_estimators': [75, 100, 150],\n     'min_samples_leaf': [1, 2, 5, 10],\n     'max_depth': [2, 5],}\n]\n\nxtree_grid, xtree_info = grid_search(xtree_clf, xtree_params, verbose=0)","6e420621":"y_pred_test = xtree_grid.predict(X_test_all)\ny_pred_test = pd.Series(y_pred_test, index=X_test_all.index)\n\ny_pred_full_test = [None] * len(X_test)\n\nfor i in X_test.index:\n    if X_test.loc[i, 'Priority'] == 1 and X_test.loc[i, 'SamePrioCompanion']\\\n            and X_test.loc[i, 'SamePrioCompanion'] > 1:\n        y_pred_full_test[i] = X_test.loc[i, 'SamePrioSurvived'].astype(int)\n    else:\n        y_pred_full_test[i] = y_pred_test[i]\n\nsubmission = pd.DataFrame({\n    \"PassengerId\": test_passengerid,\n    \"Survived\": y_pred_full_test,\n})\nsubmission.PassengerId = submission.PassengerId.astype(int)\nsubmission.Survived = submission.Survived.astype(int)\nsubmission.to_csv(\"submissions.csv\", index=False)","1481fca9":"pd.DataFrame(xtree_grid.best_estimator_.feature_importances_,\n             index=X_train_all.columns, columns=['Imp']).sort_values(by='Imp', ascending=False)","74075b58":"`Parch` (# of parents\/children):\n- Ranging between 0 - 6 in the train set\n- 2 passensers in train set has Parch = 9\n- 76.1% does not have any parents\/children","0ae79865":"## 2. Loading Data","f5c34ed7":"***Text Features***","b51af06f":"- As `SamePrioCompanion` seems to be better to track people who went on the trip together, we do not need the features `SibSp` and `Parch` anymore.\n","6e20adfa":"- As expected, people with `Mrs` or `Miss` are the ones most likely live.\nOn the other hand, most `Mr` cannot survive.\n\n- We found that people with `Master` titles are boys under 12.\n","8ce450f5":"Total of **12 variables** including 1 target variable (`Survived`):\n\n**Numerical**:\n- **Int** (e.g. 25): `PassengerId`, `SibSp` (# of Siblings\/Spouses),\n`Parch` (# of Parents\/Children)\n- **Float** (e.g. 23.0): `Age`, `Fare`\n\n**Categorical**:\n- **Binary** (2 categories): `Sex`, `Survived` (Target Variable)\n- **Nominal** (2+ categories that CANNOT be ordered naturally): `Embarked` (Port of Embarkation)\n- **Ordinal** (2+ categories that CAN be ordered naturally): `Pclass`\n(Proxy for Social Status, 1\/2\/3)\n\n**Text**: `Name`, `Ticket`, `Cabin`","c6abe452":"# III. DATA PREPARATION\n\n## Copy data","afb45084":"- Only 18.9% males survived. On the other hand, 74.2% females survived. So\n`Sex` could be a good indicator for `Survived`.\n- Note that if we predict all females survive and males perish (gender model),\nwe may receive a public leaderboard score of 76.6%. To improve this model,\nwe have to predict accurately which ***females perished*** and which ***males\nsurvived***.","67e0495d":"### Extra Trees","b2e38d94":"- `Survived`: 38.4% passengers survived (train set)\n- `Sex`: The majority of 64.4% passengers are male\n- `Embarked`: The port where most people embarked was 'S'\n- `Pclass`: The majority of 54.16% people belong to the lower class","b34edee7":"# II. DATA EXPLORATION\n\n## 1. A Glimpse at the Datasets","219f0dbc":"***Variable Types***","ac47d508":"- Interestingly, out of these 612 groups, we have 95% ending up with the same outcomes (all perished or all survived). Even if most of them are alone passengers, it is still a very high proportion and promising to work with.\n\n- Let's check out the groups with more than 2 passengers having the same priority. We start by creating a feature called `SamePrioCompanion`.\n","f73f94c6":"# I. PROJECT PREPARATION\n## 1. Import libraries","10f32d98":"***Categorical Features***","9b991102":"- We could see that young men (boys) have much higher survival chance\nthan adult men.\n- We fix the Title columns so our later work will be easier.","83b9a5b5":"- A strong assumption to make here is that women and children in the same passenger group were often rescued together, while men in the same group often perished together. To verify this assumption, passengers will also be grouped based on their `Priority`, `TicketID`, and `Fare`. Let us create a variable named `SamePrioGroup`.\n- We ended up with 612 unique groups including alone passengers.","bda509d6":"***Numerical Features***","2b0cbdff":"- `Name` values are unique, but seem to have similar Titles\n(Mrs, Ms, Mr, etc.) and surnames (before `,`). Let's try to extract `Title`\nand `Surname` and explore more in the ***Exploration Section***.\n- Some passengers have the same tickets and same cabin.\n- `PassengerId` are unique and unrelated to the survival rate so we may\nsafely remove them from both training & train set","758a39a1":"## 3. Relationships between Features and Target","e7ba9f5c":"# IV. MODEL PREDICTION & SUBMISSION","de12735f":"**Plan**:\n1. Copy the full training set so we do not harm it while exploring.\n- Convert `Sex` to numerical dummies.\n- Check the correlation between numerical features with `Survived`.\n- See the relationship between `Sex` and `Pclass` with `Survived`.\n- Extract `Title` and `Surname` from `Name`. Check their relationship with\n`Survived` and other variables.\n- Use `Title` to fill missing values of `Age`. Find relationship between\n`Age` (or `AgeBand`) with `Survived`.\n- See if there is any significant relationship between the other variables\n with `Survived`.","f0728184":"***Relationship between `Surname` and `Ticket`, `Ticket` and `Survived`***","33532241":"- If we look closer, we may see the relationship between `Surname` and `Ticket`\nwhere people with the same surname hold the same tickets with the same fares.\nFor example:","69d78d4b":"***Relationship between `Title` and `Survived`. Fill `Age` using `Title`***","fae7d250":"`SibSp` (# of siblings\/spouses):\n- Ranging between 0 - 8.\n- 68.2% does not have any sibling\/spouses","97a02e99":"## 4. Feature Selection","0dff4199":"## Adding new variables","6d6c2688":"`Fare`:\n- Average at 32.2\n- Ranging from 0 - 512\n\nGeneral conclusions:\n- Some features have very different scales, so we need to scale features later,\nespecially for algorithms requiring it (e.g. SVMs, Neural Nets).\n- Some features are tail-heavy, so we will try transforming these to a more\nbell-shaped distribution (more symmetric) using, e.g. quantile cuts or\nlog() transformation.","13d28769":"- We could separate men from children and women using a variable called `Priority` (`= 0` for all people with title `Mr`, while `= 1` for the others)","16f1d1f3":"- As we can group passengers using `SamePrioGroup`, we won't need to group them based on `Surname` or `Name` anymore. \n\n- Information of `Title` has already been covered in `Sex` and `Priority` so I also won't use this feature to predict `Survived` as using it requires creating 4 dummy variables to match 4 titles.","4210287d":"- Since `Age` and `Pclass` are both negatively correlated to `Survived`, we also have `AgePclass`.","5257b8ad":"- Wow, women and children (`Priority` = 1) in the same group mostly (92.5%) ended up with the same outcomes (all `Survived` = 0 or 1)! On the other hand, men in the same group had more diversified and unpredictable outcomes. \n\n- Thus, it might be a great idea to separate our dataset into 2 parts: the woman-child-group and the rest. We will later predict that all the women and children in the same group will live or die together. The rest will be predicted using the features that we've engineered before.","7ddc7fa4":"* From this part, I will try to create a sklearn.Pipeline later. But for now, we will simply apply the transformations directly on the full dataset to save time. \n\n## Filling NAs","b568ec83":"- Around 82% groups with more than 2 passengers with the same priority had the same outcomes... Not bad! What if we filter them using `Priority`?","04afb287":"- It also make senses to create a feature called `FarePerPerson` since it will display how costly the people paid for the trip more correctly than `Fare`.","0094b6e8":"- `Pclass` and `Fare` have the highest correlations with `Survived`. It is\nreasonably to assume that people with lower `Pclass` will more likely live.\n- `SibSp`, `Age` and `Parch` have low correlation with `Survived`. We may need\nto create new variables that incorporate information from `SibSp` and `Parch`.","c4e8ae8f":"- Around half of the passengers in the training set belong to this group. How about their survival rates?","aec8c1ef":"***Correlation of Numerical Features***","6d34f11a":"- This implies that the tickets were issued for families, not individuals (and also the fares).\n\n- Moreover, some people with the same tickets (same fares) have different last digits. So we have to find a way to extract only the numbers except the last number to group the passengers with the same tickets together.\n\n- To group the ids that are more similar (i.e. same `Pclass`, same `Fare`), the ticket ID will also be multiplied by the 1,000,000 * `Pclass`  and `Fare`. The 1,000,000 number comes from the fact that the largest ticket id has 6 digits.","14ee88bd":"- 20% of `Age` values are missing (263). We may define a way to fill them in\nthe next section where we explore variables.\n- Only 1 value of `Fare` is missing. We may fill it later using median value\nof `Pclass` (passenger class).\n- `Cabin` and `Embarked` are also missing some values, but (according to results\n from other people's notebooks), they are not important variables to\n predict `Survived`, so I may drop it.","31685526":"## 2. Check Missing Features","2f8dfca6":"`Age`:\n - Average at 29.7\n - Only 1% people are older than 64 years old."}}