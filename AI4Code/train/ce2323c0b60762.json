{"cell_type":{"bc3b2b61":"code","bdd18464":"code","f2e893ec":"code","c9deb74b":"code","547a8045":"markdown","ac63e20d":"markdown","49569d02":"markdown","66c635af":"markdown"},"source":{"bc3b2b61":"import torch\nimport torchvision\nimport torchvision.transforms as transforms","bdd18464":"# 0 - Pre-define tranformations\n\n# transform.normalize(seq of means, seq of stds) does this >>> image = (image - mean) \/ std \n# In This normalization mean, std are passed as 0.5, 0.5, This will normalize the image in the range [-1,1]\n# Because >>> The output of torchvision datasets are PILImage images of range [0, 1]. We transform them to Tensors of normalized range [-1, 1]\n# For example, the minimum value 0 will be converted to (0-0.5)\/0.5=-1, the maximum value of 1 will be converted to (1-0.5)\/0.5=1\ntransform = transforms.Compose(\n    [transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])\n\nbatch_size = 4\n\n# 1 - Loading the data\n\ntrainset = torchvision.datasets.CIFAR10(root='.\/data', train=True,\n                                        download=True, transform=transform)\ntrainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,\n                                          shuffle=True, num_workers=2)\n\ntestset = torchvision.datasets.CIFAR10(root='.\/data', train=False,\n                                       download=True, transform=transform)\ntestloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,\n                                         shuffle=False, num_workers=2)\n\nclasses = ('plane', 'car', 'bird', 'cat',\n           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')\n\nprint(\"\\n\\t\\t-------\\n1-trainset:  {}\\n 2-trainloader:  {}\\n 3-testset:  {}\\n 4-testloader:  {}\".format(\ntrainset, trainloader, testset, testloader))","f2e893ec":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# functions to show an image\n\n\ndef imshow(img):\n    img = img \/ 2 + 0.5     # unnormalize\n    npimg = img.numpy()\n    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n    plt.show()\n\n\n# get some random training images\ndataiter = iter(trainloader)\nimages, labels = dataiter.next()\n\n# show images\nimshow(torchvision.utils.make_grid(images))\n# print labels\nprint(' '.join('%5s' % classes[labels[j]] for j in range(batch_size)))","c9deb74b":"import torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Net(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = torch.flatten(x, 1) # flatten all dimensions except batch\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n\nnet = Net()","547a8045":"## - Visualizing some of the images","ac63e20d":"## To train an image classifier from CIFAR10\n1- Load and normalize the CIFAR10 training and test datasets using **torchvision**\n\n2- Define a Convolutional Neural Network\n\n3- Define a loss function\n\n4- Train the network on the training data\n\n5- Test the network on the test data","49569d02":"## 2- Defining a CNN","66c635af":"## 1- Load and normalize the CIFAR10 training and test datasets using **torchvision**"}}