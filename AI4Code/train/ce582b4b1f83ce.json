{"cell_type":{"da2df182":"code","93e8d226":"code","66af46e0":"code","434eab8a":"code","4625eb33":"code","2389b25d":"code","15b7ac89":"code","a70e27a1":"code","f041a20c":"code","44cfb367":"code","6f88a4e0":"code","ab101f2d":"code","84a13556":"markdown"},"source":{"da2df182":"import numpy as np # linear algebra\nfrom utils import *\nimport random\nimport pprint\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\ndata = open('..\/input\/dinosaur-island\/dinos.txt', 'r').read()\ndata= data.lower()\nchars = list(set(data))\ndata_size, vocab_size = len(data), len(chars)\nprint('There are %d total characters and %d unique characters in your data.' % (data_size, vocab_size))","93e8d226":"chars = sorted(chars)\nprint(chars)","66af46e0":"char_to_ix = { ch:i for i,ch in enumerate(chars) }\nix_to_char = { i:ch for i,ch in enumerate(chars) }\npp = pprint.PrettyPrinter(indent=4)\npp.pprint(ix_to_char)","434eab8a":"def clip(gradients, maxValue):\n    '''\n    Clips the gradients' values between minimum and maximum.\n    \n    Arguments:\n    gradients -- a dictionary containing the gradients \"dWaa\", \"dWax\", \"dWya\", \"db\", \"dby\"\n    maxValue -- everything above this number is set to this number, and everything less than -maxValue is set to -maxValue\n    \n    Returns: \n    gradients -- a dictionary with the clipped gradients.\n    '''\n    dWaa, dWax, dWya, db, dby = gradients['dWaa'], gradients['dWax'], gradients['dWya'], gradients['db'], gradients['dby']\n    # clip to mitigate exploding gradients, loop over [dWax, dWaa, dWya, db, dby].\n    for gradient in [dWax, dWaa, dWya, db, dby]:\n        np.clip(gradient, -maxValue, maxValue, out=gradient)    \n    gradients = {\"dWaa\": dWaa, \"dWax\": dWax, \"dWya\": dWya, \"db\": db, \"dby\": dby}\n    return gradients\n# Test with a maxvalue of 10\nmValue = 10\nnp.random.seed(3)\ndWax = np.random.randn(5,3)*10\ndWaa = np.random.randn(5,5)*10\ndWya = np.random.randn(2,5)*10\ndb = np.random.randn(5,1)*10\ndby = np.random.randn(2,1)*10\ngradients = {\"dWax\": dWax, \"dWaa\": dWaa, \"dWya\": dWya, \"db\": db, \"dby\": dby}\ngradients = clip(gradients, mValue)\nprint(\"gradients[\\\"dWaa\\\"][1][2] =\", gradients[\"dWaa\"][1][2])\nprint(\"gradients[\\\"dWax\\\"][3][1] =\", gradients[\"dWax\"][3][1])\nprint(\"gradients[\\\"dWya\\\"][1][2] =\", gradients[\"dWya\"][1][2])\nprint(\"gradients[\\\"db\\\"][4] =\", gradients[\"db\"][4])\nprint(\"gradients[\\\"dby\\\"][1] =\", gradients[\"dby\"][1])","4625eb33":"# Test with a maxValue of 5\nmValue = 5\nnp.random.seed(3)\ndWax = np.random.randn(5,3)*10\ndWaa = np.random.randn(5,5)*10\ndWya = np.random.randn(2,5)*10\ndb = np.random.randn(5,1)*10\ndby = np.random.randn(2,1)*10\ngradients = {\"dWax\": dWax, \"dWaa\": dWaa, \"dWya\": dWya, \"db\": db, \"dby\": dby}\ngradients = clip(gradients, mValue)\nprint(\"gradients[\\\"dWaa\\\"][1][2] =\", gradients[\"dWaa\"][1][2])\nprint(\"gradients[\\\"dWax\\\"][3][1] =\", gradients[\"dWax\"][3][1])\nprint(\"gradients[\\\"dWya\\\"][1][2] =\", gradients[\"dWya\"][1][2])\nprint(\"gradients[\\\"db\\\"][4] =\", gradients[\"db\"][4])\nprint(\"gradients[\\\"dby\\\"][1] =\", gradients[\"dby\"][1])\ndel mValue # avoid common issue","2389b25d":"matrix1 = np.array([[1,1],[2,2],[3,3]]) # (3,2)\nmatrix2 = np.array([[0],[0],[0]]) # (3,1) \nvector1D = np.array([1,1]) # (2,) \nvector2D = np.array([[1],[1]]) # (2,1)\nprint(\"matrix1 \\n\", matrix1,\"\\n\")\nprint(\"matrix2 \\n\", matrix2,\"\\n\")\nprint(\"vector1D \\n\", vector1D,\"\\n\")\nprint(\"vector2D \\n\", vector2D)","15b7ac89":"print(\"Multiply 2D and 1D arrays: result is a 1D array\\n\", \n      np.dot(matrix1,vector1D))\nprint(\"Multiply 2D and 2D arrays: result is a 2D array\\n\", \n      np.dot(matrix1,vector2D))","a70e27a1":"print(\"Adding (3 x 1) vector to a (3 x 1) vector is a (3 x 1) vector\\n\",\n      \"This is what we want here!\\n\", \n      np.dot(matrix1,vector2D) + matrix2)","f041a20c":"print(\"Adding a (3,) vector to a (3 x 1) vector\\n\",\n      \"broadcasts the 1D array across the second dimension\\n\",\n      \"Not what we want here!\\n\",\n      np.dot(matrix1,vector1D) + matrix2)","44cfb367":"def sample(parameters, char_to_ix, seed):\n    \"\"\"\n    Sample a sequence of characters according to a sequence of probability distributions output of the RNN\n\n    Arguments:\n    parameters -- python dictionary containing the parameters Waa, Wax, Wya, by, and b. \n    char_to_ix -- python dictionary mapping each character to an index.\n    seed -- used for grading purposes. Do not worry about it.\n\n    Returns:\n    indices -- a list of length n containing the indices of the sampled characters.\n    \"\"\"\n    # Retrieve parameters and relevant shapes from \"parameters\" dictionary\n    Waa, Wax, Wya, by, b = parameters['Waa'], parameters['Wax'], parameters['Wya'], parameters['by'], parameters['b']\n    vocab_size = by.shape[0]\n    n_a = Waa.shape[1]\n    # Step 1: Create the a zero vector x that can be used as the one-hot vector \n    # representing the first character (initializing the sequence generation).\n    x = np.zeros(( vocab_size, 1))\n    # Step 1': Initialize a_prev as zeros\n    a_prev = np.zeros(( n_a, 1))\n    # Create an empty list of indices, this is the list which will contain the list of indices of the characters to generate\n    indices = []\n    # idx is the index of the one-hot vector x that is set to 1\n    # All other positions in x are zero.\n    # We will initialize idx to -1\n    idx = -1 \n    # Loop over time-steps t. At each time-step:\n    # sample a character from a probability distribution \n    # and append its index (`idx`) to the list \"indices\". \n    # We'll stop if we reach 50 characters \n    # (which should be very unlikely with a well trained model).\n    # Setting the maximum number of characters helps with debugging and prevents infinite loops. \n    counter = 0\n    newline_character = char_to_ix['\\n']\n    while (idx != newline_character and counter != 50):\n        # Step 2: Forward propagate x using the equations (1), (2) and (3)\n        a = np.tanh(np.dot(Wax, x) + np.dot(Waa, a_prev) + b)\n        z = np.dot(Wya, a) + by\n        y = softmax(z)\n        # for grading purposes\n        np.random.seed(counter+seed) \n        # Step 3: Sample the index of a character within the vocabulary from the probability distribution y\n        # (see additional hints above)\n        idx = np.random.choice(list(range(vocab_size)), p = y.ravel())\n        # Append the index to \"indices\"\n        indices.append(idx)\n        # Step 4: Overwrite the input x with one that corresponds to the sampled index `idx`.\n        # (see additional hints above)\n        x = np.zeros((vocab_size, 1))\n        x[idx] = 1\n        # Update \"a_prev\" to be \"a\"\n        a_prev = a\n        # for grading purposes\n        seed += 1\n        counter +=1\n    if (counter == 50):\n        indices.append(char_to_ix['\\n'])\n    return indices\nnp.random.seed(2)\n_, n_a = 20, 100\nWax, Waa, Wya = np.random.randn(n_a, vocab_size), np.random.randn(n_a, n_a), np.random.randn(vocab_size, n_a)\nb, by = np.random.randn(n_a, 1), np.random.randn(vocab_size, 1)\nparameters = {\"Wax\": Wax, \"Waa\": Waa, \"Wya\": Wya, \"b\": b, \"by\": by}\nindices = sample(parameters, char_to_ix, 0)\nprint(\"Sampling:\")\nprint(\"list of sampled indices:\\n\", indices)\nprint(\"list of sampled characters:\\n\", [ix_to_char[i] for i in indices])","6f88a4e0":"def optimize(X, Y, a_prev, parameters, learning_rate = 0.01):\n    \"\"\"\n    Execute one step of the optimization to train the model.\n    \n    Arguments:\n    X -- list of integers, where each integer is a number that maps to a character in the vocabulary.\n    Y -- list of integers, exactly the same as X but shifted one index to the left.\n    a_prev -- previous hidden state.\n    parameters -- python dictionary containing:\n                        Wax -- Weight matrix multiplying the input, numpy array of shape (n_a, n_x)\n                        Waa -- Weight matrix multiplying the hidden state, numpy array of shape (n_a, n_a)\n                        Wya -- Weight matrix relating the hidden-state to the output, numpy array of shape (n_y, n_a)\n                        b --  Bias, numpy array of shape (n_a, 1)\n                        by -- Bias relating the hidden-state to the output, numpy array of shape (n_y, 1)\n    learning_rate -- learning rate for the model.\n    \n    Returns:\n    loss -- value of the loss function (cross-entropy)\n    gradients -- python dictionary containing:\n                        dWax -- Gradients of input-to-hidden weights, of shape (n_a, n_x)\n                        dWaa -- Gradients of hidden-to-hidden weights, of shape (n_a, n_a)\n                        dWya -- Gradients of hidden-to-output weights, of shape (n_y, n_a)\n                        db -- Gradients of bias vector, of shape (n_a, 1)\n                        dby -- Gradients of output bias vector, of shape (n_y, 1)\n    a[len(X)-1] -- the last hidden state, of shape (n_a, 1)\n    \"\"\"\n    # Forward propagate through time\n    loss, cache = rnn_forward(X, Y, a_prev, parameters)\n    # Backpropagate through time\n    gradients, a = rnn_backward(X, Y, parameters, cache)\n    # Clip your gradients between -5 (min) and 5 (max)\n    gradients = clip(gradients, maxValue=5)\n    # Update parameters\n    parameters = update_parameters(parameters, gradients, learning_rate)    \n    return loss, gradients, a[len(X)-1]\nnp.random.seed(1)\nvocab_size, n_a = 27, 100\na_prev = np.random.randn(n_a, 1)\nWax, Waa, Wya = np.random.randn(n_a, vocab_size), np.random.randn(n_a, n_a), np.random.randn(vocab_size, n_a)\nb, by = np.random.randn(n_a, 1), np.random.randn(vocab_size, 1)\nparameters = {\"Wax\": Wax, \"Waa\": Waa, \"Wya\": Wya, \"b\": b, \"by\": by}\nX = [12,3,5,11,22,3]\nY = [4,14,11,22,25, 26]\nloss, gradients, a_last = optimize(X, Y, a_prev, parameters, learning_rate = 0.01)\nprint(\"Loss =\", loss)\nprint(\"gradients[\\\"dWaa\\\"][1][2] =\", gradients[\"dWaa\"][1][2])\nprint(\"np.argmax(gradients[\\\"dWax\\\"]) =\", np.argmax(gradients[\"dWax\"]))\nprint(\"gradients[\\\"dWya\\\"][1][2] =\", gradients[\"dWya\"][1][2])\nprint(\"gradients[\\\"db\\\"][4] =\", gradients[\"db\"][4])\nprint(\"gradients[\\\"dby\\\"][1] =\", gradients[\"dby\"][1])\nprint(\"a_last[4] =\", a_last[4])","ab101f2d":"def model(data, ix_to_char, char_to_ix, num_iterations = 35000, n_a = 50, dino_names = 7, vocab_size = 27, verbose = False):\n    \"\"\"\n    Trains the model and generates dinosaur names. \n    \n    Arguments:\n    data -- text corpus\n    ix_to_char -- dictionary that maps the index to a character\n    char_to_ix -- dictionary that maps a character to an index\n    num_iterations -- number of iterations to train the model for\n    n_a -- number of units of the RNN cell\n    dino_names -- number of dinosaur names you want to sample at each iteration. \n    vocab_size -- number of unique characters found in the text (size of the vocabulary)\n    \n    Returns:\n    parameters -- learned parameters\n    \"\"\"\n    # Retrieve n_x and n_y from vocab_size\n    n_x, n_y = vocab_size, vocab_size\n    # Initialize parameters\n    parameters = initialize_parameters(n_a, n_x, n_y)\n    # Initialize loss (this is required because we want to smooth our loss)\n    loss = get_initial_loss(vocab_size, dino_names)\n    # Build list of all dinosaur names (training examples).\n    with open(\"..\/input\/dinosaur-island\/dinos.txt\") as f:\n        examples = f.readlines()\n    examples = [x.lower().strip() for x in examples]\n    # Shuffle list of all dinosaur names\n    np.random.seed(0)\n    np.random.shuffle(examples)\n    # Initialize the hidden state of your LSTM\n    a_prev = np.zeros((n_a, 1))\n    # Optimization loop\n    for j in range(num_iterations):\n        # Set the index `idx` (see instructions above)\n        idx = j % len(examples)\n        # Set the input X (see instructions above)\n        single_example = examples[idx] \n        single_example_chars = [c for c in single_example]\n        single_example_ix = [char_to_ix[c] for c in single_example_chars]\n        X = [None]+ [single_example_ix]\n        X = [None] + [char_to_ix[ch] for ch in examples[idx]]; \n        # Set the labels Y (see instructions above)\n        ix_newline = char_to_ix[\"\\n\"]\n        Y = X[1:]+[ix_newline]\n        # Perform one optimization step: Forward-prop -> Backward-prop -> Clip -> Update parameters\n        # Choose a learning rate of 0.01\n        curr_loss, gradients, a_prev = optimize(X, Y, a_prev, parameters, learning_rate = 0.01)\n        # debug statements to aid in correctly forming X, Y\n        if verbose and j in [0, len(examples) -1, len(examples)]:\n            print(\"j = \" , j, \"idx = \", idx,) \n        if verbose and j in [0]:\n            print(\"single_example =\", single_example)\n            print(\"single_example_chars\", single_example_chars)\n            print(\"single_example_ix\", single_example_ix)\n            print(\" X = \", X, \"\\n\", \"Y =       \", Y, \"\\n\")\n        # Use a latency trick to keep the loss smooth. It happens here to accelerate the training.\n        loss = smooth(loss, curr_loss)\n        # Every 2000 Iteration, generate \"n\" characters thanks to sample() to check if the model is learning properly\n        if j % 2000 == 0:\n            print('Iteration: %d, Loss: %f' % (j, loss) + '\\n')\n            # The number of dinosaur names to print\n            seed = 0\n            for name in range(dino_names):\n                # Sample indices and print them\n                sampled_indices = sample(parameters, char_to_ix, seed)\n                print_sample(sampled_indices, ix_to_char)\n                seed += 1  # To get the same result (for grading purposes), increment the seed by one. \n            print('\\n')\n    return parameters\nparameters = model(data, ix_to_char, char_to_ix, verbose = True)","84a13556":"Geenrate new dinosaur names!\n\nBuild a character level language model to generate new names.\n\nThe algorithm will learn the different name patterns, and generate new names randomly.\n\nStore text data for processing using an RNN.\n\nSynthesize data by sampling predictions at each time step and pass it to the next RNN-cell unit.\n\nBuild a character-level text generation recurrent neural network.\n\nClipping the gradients.\n\nThe algorithm starts to generate plausible dinosaur names towards the end of the training. \n\nAt first, it was generating random characters, but towards the end you could see dinosaur names with cool endings. \n\nFeel free to run the algorithm even longer and play with hyperparameters to see if you can get even better results. \n\nOur implementation generated some really cool names like maconucon, marloralus and macingsersaurus. \n\nYour model hopefully also learned that dinosaur names tend to end in saurus, don, aura, tor, etc.\n\nIf your model generates some non-cool names, don't blame the model entirely--not all actual dinosaur names sound cool. \n\n(For example, dromaeosauroides is an actual dinosaur name and is in the training set.) But this model should give you a set of candidates from which you can pick the coolest!\n\nThis assignment had used a relatively small dataset, so that you could train an RNN quickly on a CPU. \n\nTraining a model of the english language requires a much bigger dataset, and usually needs much more computation, and could run for many hours on GPUs. \n\nWe ran our dinosaur name for quite some time, and so far our favorite name is the great, undefeatable, and fierce: Mangosaurus!"}}