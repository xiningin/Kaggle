{"cell_type":{"676c87bd":"code","da0b5c9e":"code","85e5f35f":"code","ab921ad2":"code","4b4b738d":"code","d7f0f4e1":"code","4d530f68":"code","37637a57":"code","51f80e30":"code","37a07ae7":"code","f1715d1f":"code","0c063141":"code","088c541b":"code","f4812977":"code","8c6cb552":"code","8c062778":"markdown","16396721":"markdown","ea2d9f7f":"markdown","98eea371":"markdown","a3475476":"markdown"},"source":{"676c87bd":"import numpy as np\nimport pandas as pd \n\nimport os\nimport torch","da0b5c9e":"if torch.cuda.is_available():        \n    device = torch.device(\"cuda\")\nelse:\n    device = torch.device(\"cpu\")\nprint(\"device:\", device)","85e5f35f":"def extract_path(puth):\n    return puth[0]","ab921ad2":"from torchvision import datasets\n\ntrain = datasets.ImageFolder(\"..\/input\/cat-and-dog\/training_set\/training_set\")\ntest = datasets.ImageFolder(\"..\/input\/cat-and-dog\/test_set\/test_set\")\n\ntrain_imgs = pd.Series(train.imgs, name = \"path\").apply(func=extract_path)\ntest_imgs = pd.Series(test.imgs, name = \"path\").apply(func=extract_path)\n\ntrain_target = pd.Series(train.targets, name =\"label\")\ntest_target = pd.Series(test.targets, name =\"label\")","4b4b738d":"from sklearn.model_selection import train_test_split\ntrain_imgs, val_imgs, train_target, val_target = train_test_split(train_imgs, train_target, test_size=0.2, random_state=0, stratify=train_target)","d7f0f4e1":"train = pd.concat([train_imgs,train_target],axis=1)\nval = pd.concat([val_imgs,val_target],axis=1)\ntest = pd.concat([test_imgs,test_target],axis=1)","4d530f68":"train.head()","37637a57":"from torch.utils.data import Dataset\nfrom PIL import Image\n\nclass DataPrepararion(Dataset):\n    \n    def __init__(self, data, transform_pipe, device):\n        self.data = data\n        self.transform_pipe = transform_pipe\n        self.device = device\n        \n    def __len__(self):\n        return len(self.data)\n    \n    def __getitem__(self, idx):\n        item = self.data.iloc[idx, :]\n        image = Image.open(item[\"path\"]).convert(\"RGB\")\n        \n        image = self.transform_pipe(image).to(self.device)\n        if item[\"label\"] == 0:\n            label = torch.zeros(size=(1,1)).to(self.device)\n        else:\n            label = torch.ones(size=(1,1)).to(self.device)\n        return [image, label]","51f80e30":"from torchvision import transforms\n\ntransform_pipe = transforms.Compose([#transforms.RandomCrop(size=[256, 256], pad_if_needed=True),\n                                     transforms.Resize((256,256),interpolation=Image.BILINEAR),\n                                     transforms.ToTensor(),\n                                     transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n                                    ])\n\ntrain_dataset = DataPrepararion(train, transform_pipe, device)\nval_dataset = DataPrepararion(val, transform_pipe, device)\ntest_dataset = DataPrepararion(test, transform_pipe, device)","37a07ae7":"import matplotlib.pyplot as plt\n\n# this converts it from GPU to CPU and selects first image\nimg = train_dataset[1][0].cpu().numpy()\n#convert image back to Height,Width,Channels\nimg = np.transpose(img, (1,2,0))\n#show the image\nplt.imshow(img)\nplt.show()  ","f1715d1f":"from torch.utils.data import DataLoader, RandomSampler\n\nbatch_size = 16\n\ntrain_loader = DataLoader(train_dataset, \n                          batch_size=batch_size, \n                          sampler=RandomSampler(data_source=train_dataset))\nval_loader = DataLoader(val_dataset, \n                        batch_size=batch_size, \n                        sampler=RandomSampler(data_source=val_dataset))\ntest_loader = DataLoader(test_dataset, \n                        batch_size=batch_size, \n                        sampler=RandomSampler(data_source=val_dataset))","0c063141":"import torch.nn as nn\nimport torch.nn.functional as F\n\nclass CatDogClassifier(nn.Module):\n    def __init__(self):\n        \n        super().__init__()\n        self.conv1 = nn.Conv2d(in_channels=3,out_channels=100,kernel_size = 3)\n        self.pool1 = nn.MaxPool2d(2,2)\n        self.batch1=nn.BatchNorm2d(4)\n        self.conv2 = nn.Conv2d(in_channels=100,out_channels=200,kernel_size = 3)\n        self.pool2 = nn.MaxPool2d(kernel_size = 2,stride = 1)\n        self.dropout = nn.Dropout2d(p = 0.1)\n        self.adaptive_pool = nn.AdaptiveMaxPool2d((1,1))\n        self.flatten = nn.Flatten()\n        self.linear1 = nn.Linear(200,100)\n        self.linear2 = nn.Linear(100,10)\n        self.relu = nn.ReLU()\n        self.linear3 = nn.Linear(10,1)\n        self.sigmoid = nn.Sigmoid()\n\n        \n    def forward(self, x):\n        x = self.conv1(x)\n        x = self.relu(x)\n        x = self.pool1(x)\n        #x = self.batch1(x)\n        #x = self.dropout(x)\n        x = self.conv2(x)\n        x = self.relu(x)\n        x = self.pool1(x)\n        #x = self.dropout(x)\n        x = self.adaptive_pool(x)\n        x = self.flatten(x)\n        x = self.linear1(x)\n        x = self.relu(x)\n        x = self.linear2(x)\n        x = self.relu(x)\n        x = self.linear3(x)\n        y = self.sigmoid(x)\n        return y\n\n\nmodel = CatDogClassifier().to(device)\nprint(model)","088c541b":"n_epochs = 15\nlearning_rate = 0.0001\n\n# Cross Entropy Loss \nerror = nn.CrossEntropyLoss()\n\n# SGD Optimizer\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\nloss_func = nn.BCELoss()","f4812977":"from sklearn.metrics import accuracy_score\n\nfor epoch in range(n_epochs):\n    print(\"=== Epoch\", epoch+1, \"===\")\n    acc_train = 0\n    acc_val = 0\n    # train\n    model.train()  # train mode\n    for i, batch in enumerate(train_loader):\n        x = batch[0]\n        y = batch[1].view(-1, 1)\n        \n        optimizer.zero_grad() \n        probas = model(x) \n        loss = loss_func(probas, y) \n        loss.backward()\n        optimizer.step()\n        \n    model.eval()  # evaluation mode\n\n    for i, batch in enumerate(train_loader):\n        x = batch[0]\n        y = batch[1].view(-1, 1)\n        with torch.no_grad():\n            probas = model(x)\n        pred = np.round(probas.cpu().numpy())\n        acc_train += accuracy_score(y_true=y.cpu().numpy(), y_pred=pred)\n    acc_train \/= len(train_loader)\n    print(\"Train Accuracy:\", acc_train)\n    \n    # acc on val\n    for i, batch in enumerate(val_loader):\n        x = batch[0]\n        y = batch[1].view(-1, 1)\n        with torch.no_grad():\n            probas = model(x)\n        pred = np.round(probas.cpu().numpy())\n        acc_val += accuracy_score(y_true=y.cpu().numpy(), y_pred=pred)\n        \n    acc_val \/= len(val_loader)\n    print(\"Val Accuracy:\", acc_val, \"\\n\")","8c6cb552":"acc_test = 0\nfor i, batch in enumerate(test_loader): # test acc\n    x = batch[0]\n    y = batch[1].view(-1, 1)\n    with torch.no_grad():\n        probas = model(x)\n    pred = np.round(probas.cpu().numpy())\n    acc_test += accuracy_score(y_true=y.cpu().numpy(), y_pred=pred)\n\nacc_test \/= len(test_loader)\nprint(acc_test)","8c062778":"# Create model","16396721":"# Train model","ea2d9f7f":"# Load and preparation data","98eea371":"# Test model","a3475476":"# Add device"}}