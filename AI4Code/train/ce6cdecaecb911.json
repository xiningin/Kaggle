{"cell_type":{"44e459d5":"code","3896eecc":"code","df8f0e6d":"code","25b3ee5b":"code","ce29a3b3":"code","0d05e0b9":"code","c9c193e9":"code","4a8e3f34":"code","187460c6":"code","e452f789":"code","e132ed60":"code","f4a491f3":"code","efd14def":"code","10bb790e":"code","58f77504":"code","0bc1fff3":"code","d5a09563":"code","23146851":"code","f9e2d9fa":"code","fd34a1fd":"code","44e85ded":"code","b134847a":"code","5d6bb0ef":"code","2971e782":"code","2fe62629":"markdown","a7927c7c":"markdown","9ad47ca8":"markdown","6b4d04d1":"markdown","0d7035f5":"markdown","bb13215b":"markdown","841826c4":"markdown","269deabe":"markdown","91cda89d":"markdown","7398a908":"markdown"},"source":{"44e459d5":"#Import necessay libraries\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\n#Preprocessing\nfrom sklearn import model_selection,metrics\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split,KFold,StratifiedKFold\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler,RobustScaler\n#Model\nfrom sklearn.metrics import mean_squared_error,roc_auc_score\nfrom xgboost import XGBRegressor\nfrom lightgbm import LGBMRegressor\nfrom catboost import CatBoostRegressor","3896eecc":"#import the data and shape\ntrain = pd.read_csv(\"..\/input\/song-popularity-prediction\/train.csv\")\ntest = pd.read_csv(\"..\/input\/song-popularity-prediction\/test.csv\")\nsample=pd.read_csv(\"..\/input\/song-popularity-prediction\/sample_submission.csv\")\nprint(train.shape,test.shape)\ntrain.describe()\n","df8f0e6d":"train.info()","25b3ee5b":"!git clone https:\/\/github.com\/analokmaus\/kuma_utils.git\nimport sys\nsys.path.append('kuma_utils\/')\nfrom kuma_utils.preprocessing.imputer import LGBMImputer","ce29a3b3":"features=['id','song_duration_ms', 'acousticness', 'danceability', 'energy',\n       'instrumentalness', 'key', 'liveness', 'loudness', 'audio_mode',\n       'speechiness', 'tempo', 'time_signature', 'audio_valence']","0d05e0b9":"lgbm_imter=LGBMImputer(n_iter=1000,verbose=20)\ntrain_imp=lgbm_imter.fit_transform(df[features])\ntest_imp=lgbm_imter.transform(test[features])\n\nlgbm_imp_df = pd.DataFrame(train_imp,columns=features)\ntest=pd.DataFrame(test_imp,columns=features)","c9c193e9":"train=lgbm_imp_df.copy()\ntrain['song_popularity']=df['song_popularity']","4a8e3f34":"#Splliting  the kfold columns\ntrain['kfold'] = -1\n#distributing the data\nkfold = KFold(n_splits = 5,shuffle=True,random_state = 42)\nfor fold, (tr_i,va_i) in enumerate(kfold.split(X=train)):\n    train.loc[va_i,'kfold'] = fold\n    \nprint(train.kfold.value_counts())\ntrain.to_csv(\"folds_5.csv\",index=False)\nprint(\"successfully folds\")\n","187460c6":"train.isnull().sum()","e452f789":"df = pd.read_csv(\".\/folds_5.csv\")\n\n#features taken to train\nfeatures = [f for f in df.columns if f not in(\"id\",\"kfold\",\"song_popularity\")]\ntest= test[features]\n","e132ed60":"#Since the columns are of different size we are scaling them\nlE = RobustScaler()\ndf[features] = lE.fit_transform(df[features])\ntest[features] = lE.transform(test[features])","f4a491f3":"df.head()","efd14def":"final_test_preds=[]\nfinal_valid_preds={}\nscores=[]\n\nfor fold in range(5):\n    xtrain=df[df.kfold != fold].reset_index(drop=True)\n    xvalid=df[df.kfold == fold].reset_index(drop=True)\n    xtest=test.copy()\n    \n    valid_id=xvalid.id.values.tolist()\n    \n    ytrain=xtrain.song_popularity\n    yvalid=xvalid.song_popularity\n    \n    xtrain=xtrain[features]\n    xvalid=xvalid[features]\n    \n    #Model hyperparameter of XGboostRegressor\n    #lgb parameters\n    lgb_params={\n    \"task\": \"train\",\n    \"boosting_type\": \"gbdt\",\n    \"objective\": \"binary\",\n    'subsample': 0.95312,\n    'learning_rate': 0.001635,\n    \"max_depth\": 3,\n    \"feature_fraction\": 0.2256038826485174,\n    \"bagging_fraction\": 0.7705303688019942,\n    \"min_child_samples\": 290,\n    \"reg_alpha\": 14.68267919457715,\n    \"reg_lambda\": 66.156,\n    \"max_bin\": 772,\n    \"min_data_per_group\": 177,\n    \"bagging_freq\": 1,\n    \"cat_smooth\": 96,\n    \"cat_l2\": 17,\n    \"verbosity\": -1,\n    'random_state':42,\n    'n_estimators':5000,\n    'colsample_bytree':0.1107\n    }\n    \n    model =LGBMRegressor(**lgb_params)\n    model.fit(xtrain,ytrain,verbose=20)\n    \n    preds_valid=model.predict(xvalid)\n    preds_test=model.predict(xtest[features])\n    \n    final_test_preds.append(preds_test)\n    final_valid_preds.update(dict(zip(valid_id,preds_valid)))\n    \n    roc1= roc_auc_score(yvalid,preds_valid)\n    #Score \n    scores.append(roc1)\n    print(f\"fold|split:{fold},roc:{roc1}\")\n    \n    \nprint(np.mean(scores))\nfinal_valid_pred1=pd.DataFrame.from_dict(final_valid_preds,orient='index').reset_index()\nfinal_valid_pred1.columns=['id',\"preds_1\"]\nfinal_valid_pred1.to_csv('train_pred_1.csv',index=False)\n    \ny=np.mean(np.column_stack(final_test_preds),axis=1)\ntest_preds1=pd.DataFrame(y,columns=['test_preds1'])\ntest_preds1['id']=test_preds1.index\ntest_preds1.columns=['preds_1','id']\ntest_preds1.to_csv(\"test_preds1.csv\",index=False)\n    ","10bb790e":"final_test_preds=[]\nfinal_valid_preds={}\nscores=[]\n\nfor fold in range(5):\n    xtrain=df[df.kfold != fold].reset_index(drop=True)\n    xvalid=df[df.kfold == fold].reset_index(drop=True)\n    xtest=test.copy()\n    \n    valid_id=xvalid.id.values.tolist()\n    \n    ytrain=xtrain.song_popularity\n    yvalid=xvalid.song_popularity\n    \n    xtrain=xtrain[features]\n    xvalid=xvalid[features]\n    \n    #Model hyperparameter of XGboostRegressor\n    #lgb parameters\n    \n    xgb_params={'max_depth': 12,\n     'n_estimators': 14100,\n     'learning_rate': 0.044007386636126064,\n     'subsample': 0.6000000000000001,\n     'colsample_bytree': 0.8,\n     'colsample_bylevel': 0.2,\n     'min_child_weight': 1.8449117383488298,\n     'reg_lambda': 0.00011083907926362916,\n     'reg_alpha': 0.001115661040317592,\n     'gamma': 3.379722475408119}\n    model =XGBRegressor(**xgb_params)\n    model.fit(xtrain,ytrain,verbose=20)\n    \n    preds_valid=model.predict(xvalid)\n    preds_test=model.predict(xtest[features])\n    \n    final_test_preds.append(preds_test)\n    final_valid_preds.update(dict(zip(valid_id,preds_valid)))\n    \n    roc1= roc_auc_score(yvalid,preds_valid)\n    #Score \n    scores.append(roc1)\n    print(f\"fold|split:{fold},roc:{roc1}\")\n    \n    \nprint(np.mean(scores))\nfinal_valid_pred2=pd.DataFrame.from_dict(final_valid_preds,orient='index').reset_index()\nfinal_valid_pred2.columns=['id',\"preds_2\"]\nfinal_valid_pred2.to_csv('train_pred_2.csv',index=False)\n    \ny=np.mean(np.column_stack(final_test_preds),axis=1)\ntest_preds2=pd.DataFrame(y,columns=['test_preds1'])\ntest_preds2['id']=test_preds2.index\ntest_preds2.columns=['preds_2','id']\ntest_preds2.to_csv(\"test_preds2.csv\",index=False)\n    ","58f77504":"final_test_preds=[]\nfinal_valid_preds={}\nscores=[]\n\nfor fold in range(5):\n    xtrain=df[df.kfold != fold].reset_index(drop=True)\n    xvalid=df[df.kfold == fold].reset_index(drop=True)\n    xtest=test.copy()\n    \n    valid_id=xvalid.id.values.tolist()\n    \n    ytrain=xtrain.song_popularity\n    yvalid=xvalid.song_popularity\n    \n    xtrain=xtrain[features]\n    xvalid=xvalid[features]\n    \n    #Model hyperparameter of catboostRegressor\n    #cat parameters\n    \n    model= CatBoostRegressor()\n    model.fit(xtrain,ytrain,verbose=20)\n    \n    preds_valid=model.predict(xvalid)\n    preds_test=model.predict(xtest[features])\n    \n    final_test_preds.append(preds_test)\n    final_valid_preds.update(dict(zip(valid_id,preds_valid)))\n    \n    roc1= roc_auc_score(yvalid,preds_valid)\n    #Score \n    scores.append(roc1)\n    print(f\"fold|split:{fold},roc:{roc1}\")\n    \n    \nprint(np.mean(scores))\nfinal_valid_pred3=pd.DataFrame.from_dict(final_valid_preds,orient='index').reset_index()\nfinal_valid_pred3.columns=['id',\"preds_3\"]\nfinal_valid_pred3.to_csv('train_pred_3.csv',index=False)\n    \ny=np.mean(np.column_stack(final_test_preds),axis=1)\ntest_preds3=pd.DataFrame(y,columns=['test_preds3'])\ntest_preds3['id']=test_preds3.index\ntest_preds3.columns=['preds_3','id']\ntest_preds3.to_csv(\"test_preds3.csv\",index=False)\n    ","0bc1fff3":"test['id']=test.index","d5a09563":"train1=pd.read_csv(\".\/train_pred_1.csv\")\ntrain2=pd.read_csv(\".\/train_pred_2.csv\")\ntrain3=pd.read_csv(\".\/train_pred_3.csv\")\n\ntest1=pd.read_csv(\".\/test_preds1.csv\")\ntest2=pd.read_csv(\".\/test_preds2.csv\")\ntest3=pd.read_csv(\".\/test_preds3.csv\")\n\n\ndf=df.merge(train1,on=\"id\",how=\"left\")\ndf=df.merge(train2,on=\"id\",how=\"left\")\ndf=df.merge(train3,on=\"id\",how=\"left\")\n\ntest=test.merge(test1,on=\"id\",how=\"left\")\ntest=test.merge(test2,on=\"id\",how=\"left\")\ntest=test.merge(test3,on=\"id\",how=\"left\")","23146851":"final_features=['preds_1','preds_2','preds_3']\ntarget=df['song_popularity']","f9e2d9fa":"lgb_params={\n    \"task\": \"train\",\n    \"boosting_type\": \"gbdt\",\n    \"objective\": \"binary\",\n    'subsample': 0.95312,\n    'learning_rate': 0.001635,\n    \"max_depth\": 3,\n    \"feature_fraction\": 0.2256038826485174,\n    \"bagging_fraction\": 0.7705303688019942,\n    \"min_child_samples\": 290,\n    \"reg_alpha\": 14.68267919457715,\n    \"reg_lambda\": 66.156,\n    \"max_bin\": 772,\n    \"min_data_per_group\": 177,\n    \"bagging_freq\": 1,\n    \"cat_smooth\": 96,\n    \"cat_l2\": 17,\n    \"verbosity\": -1,\n    'random_state':42,\n    'n_estimators':5000,\n    'colsample_bytree':0.1107\n    }\n    \nfinal_model =LGBMRegressor(**lgb_params)\nfinal_model.fit(df[final_features],df['song_popularity'])","fd34a1fd":"final_preds=final_model.predict(test[final_features])","44e85ded":"sub=pd.read_csv(\"..\/input\/song-popularity-prediction\/sample_submission.csv\")\nsub.head()","b134847a":"sub.song_popularity=final_preds","5d6bb0ef":"sub.head()","2971e782":"sub.to_csv(\"model_stacked.csv\",index=False)","2fe62629":"# LGBM","a7927c7c":"## **Feature Separation**","9ad47ca8":"# Importing the libraries","6b4d04d1":"## **Read the Data**","0d7035f5":"# Final model and features","bb13215b":"### Refer to the session by Rob mulla for more info about this imputation","841826c4":"# XGBoost","269deabe":"## **Build_Model**","91cda89d":"# Catboost","7398a908":"## **Applying lgbm_Imputers**"}}