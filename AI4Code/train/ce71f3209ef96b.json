{"cell_type":{"3b76fb79":"code","4de07945":"code","112bec81":"code","8e968667":"code","22c6bfcc":"code","f1d23186":"code","6ddfddde":"code","116ea731":"code","58d1dc98":"code","56bd168d":"code","4252e1ff":"code","b03f822a":"code","d39e007a":"code","2e227b48":"markdown","f4527008":"markdown","3385abae":"markdown","156e0304":"markdown","a0a5c842":"markdown","477756d4":"markdown"},"source":{"3b76fb79":"#1.1\ndef func1(number):\n    newNumber = number + 1\n    return newNumber\n\na = 5\nprint('a =',a)\nprint(func1(a))\n","4de07945":"#1.2\ndef func1(number):\n    newNumber = number + 1\n    return newNumber\n\na = 5\nprint('a =',a)\nprint(func1(a))\nprint('a =',a)","112bec81":"#1.3\ndef func1A(a):\n    a = a + 1\n    return a\n\na = 5\nprint('a =',a)\nprint(func1A(a))\nprint('a =',a)\n","8e968667":"#1.4\ndef func2(number1,number2):\n    if number1>number2:\n        return number1\n    else:\n        return number2\n\nbrian = 6\nprint(func2(3,5))\nprint(func2(5,3))\nprint(func2(-3,-5))\nprint(func2(3,brian))\n","22c6bfcc":"#1.5\ndef func2A(number1,number2):\n    if number1>number2:\n        return number1\n        print('First is larger')\n    else:\n        return number2\n        print('Second is larger')\n\nbrian = 6\nprint(func2A(3,5))\nprint(func2A(5,3))\nprint(func2A(-3,-5))\nprint(func2A(3,brian))","f1d23186":"#1.6\ndef func3(number):\n    a = 6\n    number = 7\n    return 8\n\na = 5\nprint(a)\nprint(func3(a))\nprint(a)\nprint(number)\n","6ddfddde":"#1.7\ndef func4(a):\n    print('in func4 a =',a)\n    b = 100 + a\n    d = 2 * a\n    print('in func4 b =',b)\n    print('in func4 d =',d)\n    print('in func4 c =',c)\n    return b + 10\n\na = 10\nb = 15\nc = 25\nc = func4(b)\nprint('_______')\nprint('a =',a)\nprint('b =',b)\nprint('c =',c)","116ea731":"#1.8\ndef func5a(name):\n    print('func5b(name)')\n    return 'brian'\n\ndef func5b(name):\n    print(func5a(name))\n    return 'fred'\n\nprint(func5a('sue'))\nprint(func5b('betty'))\n","58d1dc98":"#1.9\ndef mysum(list,start,end):\n    index = start\n    answer = list[index]\n    while index<end:\n        index += 1\n        answer += list[index]\n    return answer\n\nlist1 = [1, 3, 5, 7, 9]\nsum1 = mysum(list1,1,3)\nsum2 = mysum(list1,0,4)\nprint(sum1)\nprint(sum2)\nlist2 = [\"are \",\"you \",\"brian \",\"smith \"]\nsum3 = mysum(list2,0,2)\nsum4 = mysum(list2,2,3)\nprint(sum3)\nprint(sum4)\n","56bd168d":"#2.1\ndef func6(message):\n    print(message)\n    if len(message)>1:\n        #Remove last character\n        message = message[:-1]\n        func6(message)\n\nfunc6('Hello World')\n","4252e1ff":"#2.2\ndef func7(message):\n    if len(message)>1:\n        #Remove last character\n        message = message[:-1]\n        func7(message)\n        print(message)\n\nfunc7('Hello World')","b03f822a":"# 3.1\ndef func8(mynum,mylist):\n    mynum = 1000\n    mylist[0] = 1000\n\na = 4\nb = [1, 2, 3, 4, 5]\nfunc8(a,b)\nprint('a=',a)\nprint('b=',b)\n","d39e007a":"#3.2\ndef func9(mylist,a,b):\n    temp = mylist[a]\n    mylist[a] = mylist[b]\n    mylist[b] = temp\n    \nlist1 = [1000, 7, 23.6, 431]\nprint(list1)\nfunc9(list1,0,1)\nprint(list1)\nfunc9(list1,0,3)\nprint(list1)","2e227b48":"# Larn Yersel Python\n## Exercise 3","f4527008":"Comments on individual parts\n\n1. \n   1. `print` calls `func1` on the value 5, `func1` returns `6` and then `print` priunts it out\n   2. Notice that `a` is still `5`, `func1` doesn't change it.\n   3. Even though `func1A` seems to be using `a`, it's a different variable called `a`. Each function has its own set of variables. The value of `a` in the main program is still `5`.\n   4. `func2` is returning the larger of the two numbers.\n   5. It looks like `func2A` should do the same as `func2` but print out messages too. In fact, there are no messages. Functions end as soon as they run a `return` statement. Nothing else is done. There is a school of thought that a function should have a single return statement at the end. You construct an answer via `if` statements etc. and then `return` it at the end. For short functions like these it's often easier, and more readable to just exit with a `return` as soon as you have the answer.\n   6. Did you predict the error? There's a lot going on here. `func3` uses a variable called `number` as its argument. The main program calls `func3` with argument `a`. This does not change `a` in the main program, instead it stores the value from `a` in the variable `number`, but only in the memory allocated for `func3`. There is no variable called `number` in the main program so the last line gives an error. In addition, `func3` sets `a` to be `6`, but this is the `a` in the memory for `func3`. The original `a` is unchanged.\n   7. The strange thing here is line 4 of the output. `func4` contains no variable called `c`, but the line `print('in func4 c =',c)` stil works! In most languages this would give an error message but Python is more forgiving. If it can't find a variable in the current memory space it will jump up a level (in this case to the memory space for the main program) and have another look. For a complicated program you may have functions inside functions etc. It can be hard to predict where Python will find a missing value - a common source of errors and confusion. \n   8. This looks like a an infinite loop, with `func5a` calling `func5b` and `func5b` calling `func5a` ad infinitum, but we are saved by the quotes. `func5a` does nothing with the name it is sent, it prints out `\"func5b(name)\"` and then sends `brian` back to the main program. `func5b` looks like it might do something with the name it is sent, but all it does is send it to `func5a` and this ignores it.\n   9. This function is designed to pick out a partial sum of a list between a given start and end position. Did you spot that it would still work with strings because Python uses `+` to concatenate strings?\n2. \n   1. This is a simple recursion. The function prints out the message and then repeatedly calls itself on a shorter version. Each version does the same thing but with an ever shorter \"message\". Note the `if` statement. This is needed to stop the function calls when we run out of string, otherwise we get an error. A final point to notice is that this function doesn't have a `return` statement. It just does some stuff, without sending any information back to the main program. Older texts call this kind of thing a \"procedure\".\n   2. Putting the print statement after the function call means that the function reapeatedly calls itself until the string is only `H`. Nothing is printed out yet. There are lots of copies of the function running in memory, each with a shorter \"message\".  When the length is down to one, the `if` statement doesn't run. The last version of `func7` now exits without printing. Python jumps back up to the previous version of `func7`, immediately after the line `func7(message)`, this version contains 'H' in its \"message\" variable (that's what it sent on to the next version) so it prints out. Now Python jumps up to the next level. At this level \"message\" contains `He` so that prints out second, and so on.  \n3. \n   1. This is a key feature of Python. The function did not change the value of `a` in the main program, but it did change the value of `b`. Python functions create new copies of any numbers or strings that they are sent. They store the new copies in their memory space and do not change the original variable in the main program. This behaviour is probably not a good idea with data structures for two reasons:\n       * Data structures can be huge. It would use vast amounts of memory\n       * It's actually convenient to have functions that do stuff to your original data, rather than to a copy.\n       \n     This kind of behaviour is standard in most programming languages. Python is designed to be easy to use so it takes the decision out of your hands. A language like C# will allow you to tell a function to create a new version or modify the original. Creating a new version is called *pass by value*, since only the value to be used is sent to the function, not the actual variable. Modifying the original is called *pass by reference*. Python only sends the memory location (reference) of the original variable to the function.\n   2. This is a simple swap function. It swaps the two entries at index `a` and index `b`. This sort of thing is often used as the basis of algorithms that sort lists or more complicated data structures.","3385abae":"This exercise set contains a number of questions. Comments and answers where needed are provided at the end.\n\nIn code sections a hashtag is used for a a *comment*. This is a line of text that is used for explanation. It is not code and is ignored by Python","156e0304":"3) Now lets apply functions to data structures","a0a5c842":"1) Read through the next code blocks. Try to predict what the output will be and then run the code.","477756d4":"2) Now a couple of code fragnents that use recursion. This can be hard to follow. The key thing to remember is that every time Python sees a call to your function it creates a new version with its own set of variables. Each version will have variables with the same names, but they may all contain different values."}}