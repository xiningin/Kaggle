{"cell_type":{"7be7eb4a":"code","a62a072d":"code","29b47a1c":"code","d1500f69":"code","843d8c4b":"code","bbbd1d0b":"code","5195529f":"code","89589466":"code","ffd046e4":"code","fcd9a7d4":"code","31f6e74d":"code","2c9de9dc":"code","f444bdad":"code","8fb5ea04":"code","fca8522a":"code","412a6057":"markdown","db60666a":"markdown","4ad9e362":"markdown","f94cab9f":"markdown","21bb8359":"markdown","7ec3ff86":"markdown","6f666a71":"markdown","1723323d":"markdown","6e0e541e":"markdown","3efb02e9":"markdown","017c01e6":"markdown","36388c9c":"markdown","7bc46561":"markdown","b99a330f":"markdown"},"source":{"7be7eb4a":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","a62a072d":"import geopandas as gpd\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nsns.set()\nimport matplotlib.pyplot as plt\nfrom datetime import date\n\nimport folium\nfrom folium import Choropleth, Circle, Marker\nfrom folium.plugins import HeatMap, MarkerCluster\n\n\nfrom datetime import datetime","29b47a1c":"corona_data = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/2019_nCoV_data.csv\")\ncorona_confirmed = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_confirmed.csv\")\ncorona_deaths = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_deaths.csv\")\ncorona_recovered = pd.read_csv(\"..\/input\/novel-corona-virus-2019-dataset\/time_series_covid_19_recovered.csv\")","d1500f69":"# Check data\ncorona_data.head()","843d8c4b":"corona_data['Date'] = corona_data['Date'].apply(pd.to_datetime)\ncorona_data.drop(['Sno'],axis=1,inplace=True)\ncorona_data = corona_data.set_index('Date')","bbbd1d0b":"corona_data.head()","5195529f":"print(f\"Confirmed case: {corona_data.Confirmed.sum()}\")\nprint(f\"Deaths: {corona_data.Deaths.sum()}\")\nprint(f\"Recovered:{corona_data.Recovered.sum()}\")\n","89589466":"confirm = gpd.GeoDataFrame(corona_confirmed, geometry=gpd.points_from_xy(corona_confirmed.Long, corona_confirmed.Lat))\nconfirm.crs = {'init': 'epsg:4326'}\n\nworld = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))\nworld.head()","ffd046e4":"ax= world.plot(figsize=(20,20), color='whitesmoke', linestyle=\":\", edgecolor='black')\nconfirm.plot(markersize=10, ax=ax)","fcd9a7d4":"death = gpd.GeoDataFrame(corona_deaths, geometry=gpd.points_from_xy(corona_deaths.Long, corona_deaths.Lat))\ndeath.crs = {'init': 'epsg:4326'}\nax= world.plot(figsize=(20,30), color='whitesmoke', linestyle=\":\", edgecolor='black')\ndeath.plot(markersize=10, ax=ax, color='maroon')\n","31f6e74d":"recovered = gpd.GeoDataFrame(corona_recovered, geometry=gpd.points_from_xy(corona_recovered.Long, corona_recovered.Lat))\nrecovered.crs = {'init': 'epsg:4326'}\nax= world.plot(figsize=(20,30), color='whitesmoke', linestyle=\":\", edgecolor='black')\nrecovered.plot(markersize=10, ax=ax, color='black')","2c9de9dc":"China = corona_data[corona_data.Country == 'Mainland China']\nf,ax = plt.subplots(figsize=(15, 10))\n\nsns.barplot(x=\"Confirmed\", y=\"Province\/State\", data=China, label=\"Confirmed\", color=\"r\", ci=0)\nsns.barplot(x=\"Recovered\", y=\"Province\/State\", data=China, label=\"Recovered\", color=\"g\", ci=0)\n\nax.legend(ncol=2, loc=\"lower right\", frameon=True)\nax.set(xlim=(0, 1500), ylabel=\"\",xlabel=\"Stats\")","f444bdad":"cd = corona_data.resample('D').sum()\n\noffset = 10000\ncd['do'] = cd.index.map(lambda date: date.toordinal())\n\nsns.set(rc={'figure.figsize':(20, 6)})\n\nax = sns.regplot(\n    data=cd,\n    x='do',\n    y='Confirmed',\n    label='Confirmed',\n    order=2,\n    scatter_kws={\"s\": 100}\n)\n\nsns.regplot(\n    data=cd,\n    x='do',\n    y='Recovered',\n    color='Green',\n    label='Recovered',\n    order=2,\n    scatter_kws={\"s\": 100}\n)\n\nsns.regplot(\n    data=cd,\n    x='do',\n    y='Deaths',\n    color='Red',\n    label='Deaths',\n    order=1,\n    scatter_kws={\"s\": 100}\n)\n\n\nsns.set(color_codes=True)\n\nax.set_xlim(cd['do'].min() - 1, cd['do'].max() + 1)\nax.set_ylim(0 - offset, cd['Confirmed'].max() + offset)\n\nax.legend(ncol=1, loc=\"upper left\", frameon=True)\n\nnew_labels = [date.fromordinal(int(item)).strftime('%d-%b') for item in ax.get_xticks()]\nax.set_xticklabels(new_labels)\nax.set_ylabel('Total Confirmed Cases')\nax.set_xlabel('Date');","8fb5ea04":"locations = corona_confirmed.groupby('Province\/State')['Lat', 'Long'].mean()\n\nepicenter = 'Hubei'\nepi_lat = locations.loc[epicenter]['Lat']\nepi_long = locations.loc[epicenter]['Long']\n\ndef haversine(lat1, lon1, lat2, lon2, to_radians=True, earth_radius=6371):\n    if to_radians:\n        lat1, lon1, lat2, lon2 = np.radians([lat1, lon1, lat2, lon2])\n\n    a = np.sin((lat2-lat1)\/2.0)**2 + \\\n        np.cos(lat1) * np.cos(lat2) * np.sin((lon2-lon1)\/2.0)**2\n\n    return earth_radius * 2 * np.arcsin(np.sqrt(a))\n\ndef get_dist(incoming):\n    return haversine(epi_lat, epi_long, incoming[0], incoming[1])\n\ntotal_confirmed_by_location = corona_data.groupby(['Province\/State']).sum()\nlocations['distance'] = locations.apply(lambda df:get_dist((df.Lat, df.Long)), axis=1)\n\njoined_agg = total_confirmed_by_location.join(locations, how='inner')\njoined_agg['log_conf'] = np.log2(joined_agg['Confirmed'])\n\nax_dist = sns.jointplot(x=joined_agg['distance'], y=joined_agg['log_conf'], kind='reg', color=\"brown\", space=0)\n\nax_dist_kde = sns.jointplot(x=joined_agg['distance'], y=joined_agg['log_conf'], kind='kde', color=\"brown\", space=0)\nax_dist.set_axis_labels('Distance from Hubei', ' Log of Total Confirmed Cases')\nax_dist_kde.set_axis_labels('Distance from Hubei', ' Log of Total Confirmed Cases');","fca8522a":"fig, ax = plt.subplots(figsize=(25,10))\ngrouped = corona_data.groupby([corona_data.index.to_period('D'), 'Country']).sum()\n\ntop_8_indices = corona_data.groupby('Country').sum().sort_values(by='Confirmed', ascending=False).head(8).index\ntop_8_grouped = grouped.loc[grouped.index.get_level_values('Country').isin(top_8_indices)]\n\ntop_8_log_infections = np.log2(top_8_grouped.Confirmed)\n\nunstacked = top_8_log_infections.unstack().plot(kind='area', ax=ax)\n","412a6057":"## Area Plot","db60666a":"## Confirmed vs Recovered","4ad9e362":"## World map and corona virus records in contect of world","f94cab9f":"### Recovered","21bb8359":"## Daily Aggregation\n\nIn the following cell, we draw a scatter diagram for total number of cases per day.\n\nThe regression function is fit with a second order polynomial.\n","7ec3ff86":"## Import libaries required for Data Exploration","6f666a71":"## Load Data from csv files into variables","1723323d":"# View first few rows of the DataFrame","6e0e541e":"### Confirmed\n","3efb02e9":"## Sum of each cases","017c01e6":"# Simple Data Cleanup Operations\n\n* Change Date column to pandas datetime format\n* Drop Sno column from data\n* Set Date as index\n","36388c9c":"### Deaths","7bc46561":"## Mapping Distance from Hubei Province to number of Confirmations\n\nIn the following cell, we map the relationship between Euledian Distance from the epicenter of the virus, Hubei Province in China, to the number of confirmed infections.\n\nNote: The y-axis, confirmed cases in illustrated using a logarithmic scale.\n\nThe visualization below shows a diminishing rate of confirmed cases as we move away from Hubei. However, perhaps surprisingly there are practically no confirmed cases between 3000 to 7000 km away from the epicenter.\n","b99a330f":"# COVID-19\n\n\n![image.png](attachment:image.png)"}}