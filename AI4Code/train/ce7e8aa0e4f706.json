{"cell_type":{"86ba1166":"code","c867f065":"code","0c96c391":"code","a086b1f3":"code","a5f7b588":"code","95350d24":"code","90f53a57":"code","2a892135":"code","14027e44":"code","f8c00608":"code","3a2903e7":"markdown"},"source":{"86ba1166":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","c867f065":"with open(\"..\/input\/hashcode-drone-delivery\/busy_day.in\") as f:\n    data = f.read().splitlines()","0c96c391":"def dist(A, B):\n    return np.ceil(((A.x - B.x)**2 + (A.y - B.y)**2) ** 0.5)\n\nclass Warehouse():\n    \n    def __init__(self, id_no, row, col, data):\n        '''Personal data of each warehouse.'''\n        self.idn = id_no\n        self.y = row\n        self.x = col\n        self.inv = np.array(data) #An array\n    \n    def __repr__(self):\n        '''A warehouse is represented by its total inventory.'''\n        return \"%i\" %sum(self.inv)\n    \n    def set_distances_orders(self, orders):\n        '''Sets the fixed weights for travel to each orders.'''\n        self.order_distances = [dist(self, o) for o in orders]\n    \n    def set_distances_warehouses(self, warehouses):\n        '''Sets the fixed weights for travel between warehouses.'''\n        self.warehouse_distances = [dist(self, w) for w in warehouses]\n    \n    def check_pickup(self, item, n):\n        '''Check if n inventory item is available. Returns True if available else False.'''\n        if self.inv[item] >= n:\n            self.inv[item] -= n\n            return True\n        \n        else:\n            return False\n\n\nclass Order():\n    \n    def __init__(self, id_no, row, col, data):\n        '''Personal data of each order.'''\n        self.idn = id_no\n        self.y = row\n        self.x = col\n        self.order = data #A list\n        self.finished = False\n        self.finish_time = np.inf\n    \n    def __repr__(self):\n        '''An order is represented by the length of its order.'''\n        return \"%i\" %len(self.order)\n    \n    def set_distances_warehouses(self, warehouses):\n        '''Sets the fixed weights for travel between warehouses.'''\n        self.warehouse_distances = [dist(self, w) for w in warehouses]\n    \n    def check_remaining_order(self):\n        '''Checks if order is still unfinished.'''\n        try:\n            return self.order[0]\n        except:\n            return None\n    \n    def check_drop(self, item, n):\n        '''Updates order for each n units of item type.'''\n        for _ in range(n):\n            self.order.remove(item)\n\n            \nclass Drone():\n    \n    def __init__(self, id_no, row, col):\n        '''Personal properties of each drone.'''\n        self.idn = id_no\n        self.y = row\n        self.x = col\n        self.status = 'wait'\n        \n        self.item_held = [0 for _ in range(NUM_PRODUCTS)] #An array\n        self.action_timer = 0\n        self.actions = []\n    \n    def __repr__(self):\n        \"A drone is represented by its unique ID.\"\n        return \"%i\" %self.idn\n    \n    def get_job(self, orders, warehouses):\n        '''Picks a job to do if status is \"wait\".'''\n        \n        #First, check if not idle:\n        if self.status != 'wait':\n            if self.action_timer <= 0:\n                try: #Try to fetch action\n                    msg = self.actions.pop(0)\n                    \n                except: #If no more actions available, idle\n                    self.status = 'wait'\n                    return\n                \n                _, t, idn, _, _ = msg.split()\n                \n                if t == 'L':\n                    d = dist(self, warehouses[int(idn)])\n                    self.y, self.x = warehouses[int(idn)].y, warehouses[int(idn)].x\n                    \n                else:\n                    self.status = 'deliver'\n                    d = dist(self, orders[int(idn)])\n                    self.y, self.x = orders[int(idn)].y, orders[int(idn)].x\n                    self.item_held = [0 for _ in range(NUM_PRODUCTS)]\n                    \n                self.action_timer = 1 + d\n                return msg\n            else:\n                self.action_timer -= 1\n                \n            return None\n        \n        #Second, if idle, check for nearby order to fulfill\n        d = np.inf\n        o = None\n        for order in orders:\n            dd = dist(self, order)\n            if dd < d:\n                finished = False\n                #Check if item is already being attended to\n                try:\n                    if len(order.order) == len(CURRENT_FINISHED_DELIVERY[order.idn]):\n                        finished = True\n                except:\n                    pass\n                    \n                if not finished:\n                    d = dd\n                    o = order\n        \n        #If no more order\n        if o == None or o.finished:\n            return None\n                \n        #Third, choose items to pickup within capacity\n        picked = {}\n        for item in o.order:\n            #Check if item already attended to\n            try:\n                if o.order.count(item) > CURRENT_FINISHED_DELIVERY[o.idn].count(item):\n                    pass\n                else:\n                    continue #Next item\n            except:\n                pass\n            \n            #Check if any item can still fit\n            if MAX_WEIGHT - sum(self.item_held * PROD_WEIGHTS) < MIN_WEIGHT:\n                break #Escape if full\n\n            #If it can, check if next item can fit\n            self.item_held[item] += 1\n            if sum(self.item_held * PROD_WEIGHTS) > MAX_WEIGHT:\n                self.item_held[item] -= 1\n            else:\n                picked[item] = -1 #Mutates to a list of (dist, wrh.idn, item)\n                try:\n                    CURRENT_FINISHED_DELIVERY[o.idn].append(item)\n                except:\n                    CURRENT_FINISHED_DELIVERY[o.idn] = [item,]\n                \n                \n        #Fourth, check for the nearest path from warehouse pickup to order delivery\n        d = np.inf\n        w = None\n        for w_dist, ids in sorted(zip(o.warehouse_distances, range(10))):\n            wrh = warehouses[ids]\n            dd = dist(self, wrh)\n            \n            #Initialize nearest warehouse to load from\n            for i in picked.keys():\n                if (wrh.inv[i]) and (picked[i] == -1):\n                    picked[i] = [dd, wrh.idn, i]\n            \n            if dd + w_dist < d:\n                d = dd\n                w = wrh\n                #Update nearest warehouse if has stock of item\n                for i in picked.keys():\n                    if wrh.inv[i] >= self.item_held[i]:\n                        picked[i] = [dd, wrh.idn, i]\n        \n        #Save all Load actions\n        for d, idn, i in sorted(picked.values()):\n            self.actions.append(\"%i L %i %i %i\" %(self.idn, idn, i, self.item_held[i]))\n        #Save all Drop actions\n        for d, idn, i in sorted(picked.values()):\n            self.actions.append(\"%i D %i %i %i\" %(self.idn, o.idn, i, self.item_held[i]))\n        \n        self.status = 'load' #To start action again\n        return None","a086b1f3":"NUM_ROWS, NUM_COLS, DRONES, DEADLINE, MAX_WEIGHT = map(int, data.pop(0).split())\nNUM_PRODUCTS = int(data.pop(0))\nPROD_WEIGHTS = np.array(list(map(int, data.pop(0).split())))\nMIN_WEIGHT = np.min(PROD_WEIGHTS)\nWAREHOUSE_NUM = int(data.pop(0))\n\nprint(\"ROWS: %i, COLS: %i, DRONES: %i, DEADLINE: %i, MAX_WEIGHT: %i, NUM_PRODUCTS: %i, WAREHOUSE: %i\" %(\n    NUM_ROWS, NUM_COLS, DRONES, DEADLINE, MAX_WEIGHT, NUM_PRODUCTS, WAREHOUSE_NUM))\n\nall_warehouses = []\nall_orders = []\n\nfor q in range(WAREHOUSE_NUM):\n    r, c = map(int, data.pop(0).split())\n    all_warehouses.append(Warehouse(q, r, c, list(map(int, data.pop(0).split()))))\n    \nCUSTOMERS = int(data.pop(0))\n\nfor cid in range(CUSTOMERS):\n    r, c = map(int, data.pop(0).split())\n    n = int(data.pop(0))\n    orders = list(map(int, data.pop(0).split()))\n    all_orders.append(Order(cid, r, c, orders))\n\nfor w in all_warehouses:\n    w.set_distances_warehouses(all_warehouses)\n    w.set_distances_orders(all_orders)\n\nfor o in all_orders:\n    o.set_distances_warehouses(all_warehouses)\n    \nCURRENT_FINISHED_DELIVERY = {} #For tracking of active deliveries","a5f7b588":"print(\"Warehouses:\", all_warehouses)\nprint(\"Total inventory: %i\" %sum([sum(x.inv) for x in all_warehouses]))\nprint(\"Total Orders: %i\" %sum([len(x.order) for x in all_orders]))","95350d24":"all_drones = []\nfor i in range(DRONES):\n    all_drones.append(Drone(i,\n                            all_warehouses[i%WAREHOUSE_NUM].y,\n                            all_warehouses[i%WAREHOUSE_NUM].x)\n                     )\n\nLIMIT = 5 #Order limit\nall_msg = []\nall_timers = []\nall_done = False\nfor t in range(DEADLINE):\n    #For each loop, update all drones\n    #print(\"Loop: \", t, [x.action_timer for x in all_drones])\n    all_timers.append([x.action_timer for x in all_drones])\n    for i in range(DRONES):\n        msg = all_drones[i].get_job(all_orders[:LIMIT], all_warehouses)\n        \n        if msg:\n            #Check for finished orders:\n            \n            all_done = True\n            for o in all_orders[:LIMIT]:\n                if len(o.order) == len(CURRENT_FINISHED_DELIVERY.get(o.idn, [])):\n                    o.finished = True\n                    o.finish_time = t\n                else:\n                    all_done = False\n                \n            #print(CURRENT_FINISHED_DELIVERY)\n            #print(sum(o.finished for o in all_orders), [o.idn for o in all_orders if o.finished])\n            #print(t, '\\t', all_done, msg)\n            all_msg.append(msg)\n            \n    if all_done:\n        if all(dr.status == 'wait' for dr in all_drones):\n            break\n    ","90f53a57":"with open('submission.csv', 'w') as f:\n    f.write(\"%i\\n\" %len(all_msg))\n    f.write(\"\\n\".join(all_msg))","2a892135":"print(len(all_msg))\nprint('\\n'.join(all_msg[:200]))","14027e44":"import matplotlib.pyplot as plt\n\nplt.plot(all_timers[:5000])\nplt.show()","f8c00608":"s = 0\nfor k in CURRENT_FINISHED_DELIVERY.keys():\n    s += len(CURRENT_FINISHED_DELIVERY[k])\nprint('Total Delivered Items:', s)\nprint(\"Total inventory: %i\" %sum([sum(x.inv) for x in all_warehouses]))\nprint(\"Total Orders: %i\" %sum([len(x.order) for x in all_orders[:LIMIT]]))","3a2903e7":"# Class Definition and Process\n\nNote: I will be trying to do this in a game-like approach where all warehouses and orders are waypoints, while the drones are the players.\n\nThe drone will select the nearest available order and will process it. A delivery under process will be added to a blacklist where items listed will not be selected by other drones."}}