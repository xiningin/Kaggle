{"cell_type":{"97e702b6":"code","4b0bb831":"code","a6a8bdca":"code","a841cbe9":"code","05844f33":"code","be97d644":"code","f8673df7":"code","22cb6b45":"code","e63a7614":"code","7e3b955f":"markdown","1d9aa6c1":"markdown"},"source":{"97e702b6":"#Imports and Pandas Options\n!pip install openpyxl\nimport datetime as dt\nimport pandas as pd\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\npd.set_option('display.width', 400)\npd.set_option('display.float_format', lambda x: '%.5f' % x)","4b0bb831":"# Preparing Dataset\ndf_ = pd.read_excel(\"..\/input\/online-retail\/online_retail_II.xlsx\", sheet_name= \"Year 2010-2011\")\ndf = df_.copy()\ndf.head()\ndf.describe().T # Let's take a glance at descriptive statistics\n# There are some problems with Price and Quantity. We'll take care of them later.","a6a8bdca":"df.isnull().sum()                # Description variable has 1454 and Customer ID variable has 135080 'missing value'\ndf.dropna(inplace=True)          # Let's drop them because we can't fill them. It is illogical.\ndf.isnull().sum()                # Check\ndf['Description'].nunique()      # Number of unique product(3896)\ndf['Description'].value_counts() # How many of each product are there?\ndf.groupby(\"Description\").agg({\"Quantity\": \"sum\"}).sort_values(\"Quantity\", ascending=False).head() # Top 5 selling products","a841cbe9":"# There are some canceled transactions into 'Invoice' variable. It can mislead us. Let's get rid of them.\ndf = df[~df['Invoice'].str.contains('C',na=False)]\n\n# We need a variable for RFM segmentation which represents 'monetary'. So I'll create a new variable called 'TotalPrice'\ndf['TotalPrice'] = df['Quantity'] *  df['Price']\ndf.head()\n","05844f33":"# Creating the RFM Metrics\n# Recency  : Time from customer's last purchase to date\n# Frequency: Total number of purchase\n# Monetary : Total spend by the customer\ndf['InvoiceDate'].max()\ntoday_date = dt.datetime(2011, 12, 11)\nrfm = df.groupby('Customer ID').agg({'InvoiceDate': lambda x: (today_date-x.max()).days,\n                                     'Invoice': lambda y: y.nunique(),\n                                     'TotalPrice': lambda z: z.sum()})\n\nrfm.columns = ['recency','frequency','monetary'] # Rename columns.\nrfm.head()\nrfm.describe().T\nrfm = rfm[(rfm['monetary']>0)]  # Remember! There were minus values in it. Because of the canceled transactions.\nrfm.describe().T # Check\n","be97d644":"# Scoring The Metrics\n# We will turn metrics into scores therefore we'll use qcut function here.(You may use 'Pareto Principle',also)\nrfm['recency_score'] = pd.qcut(rfm['recency'],q=5,labels=[5,4,3,2,1])\nrfm['frequency_score'] = pd.qcut(rfm['frequency'].rank(method=\"first\"),5,labels=[1,2,3,4,5])\nrfm['monetary_score']  = pd.qcut(rfm['monetary'],5,labels=[1,2,3,4,5])\n\n# Various implementations of an RFM analysis system may use slightly different values or scaling, however.\n# The collection of three values for each customer is called an RFM cell but we will use Recency and Frequency here\nrfm['RFM_SCORE'] = rfm['recency_score'].astype('str') + rfm['frequency_score'].astype('str')","f8673df7":"# Creating Segments with Regex\n# Let's create our segments, first I have to create a dictionary\nseg_map = {\n    r'[1-2][1-2]': 'hibernating',\n    r'[1-2][3-4]': 'at_Risk',\n    r'[1-2]5': 'cant_loose',\n    r'3[1-2]': 'about_to_sleep',\n    r'33': 'need_attention',\n    r'[3-4][4-5]': 'loyal_customers',\n    r'41': 'promising',\n    r'51': 'new_customers',\n    r'[4-5][2-3]': 'potential_loyalists',\n    r'5[4-5]': 'champions'\n}\nrfm['segment'] = rfm['RFM_SCORE'].replace(seg_map, regex=True) # Combined scores replaced with seg_map","22cb6b45":"# Interpretation\n# Let's take a (deep) look at our segments and make a decision about 'which segments are important to me to increase sales\nrfm[[\"segment\", \"recency\", \"frequency\", \"monetary\"]].groupby(\"segment\").agg([\"mean\", \"count\"])\n\n# Most important 3 segments to me to increase sales\/efficiency etc. is;\nrfm[rfm['segment']=='new_customers '].head() # We must hold new customers because they are new and extra to us.\nrfm[rfm['segment']=='need_attention'].head() # We must have them continue to buy because they are missing for a while\nrfm[rfm['segment']=='about_to_sleep'].head() # We must remind them ourselves because they are about to drop buying our product.(Potential Churn)","e63a7614":"# Let's create a csv file for 'loyal_customers' if we want to send other department.\nloyal_customers_df = pd.DataFrame()\nloyal_customers_df['loyal_customers_ID'] = rfm[rfm['segment']=='loyal_customers'].index\nloyal_customers_df.to_csv('loyal_customers.csv')","7e3b955f":"***In this project, we perform RFM segmentation for customers with the data of an e-commerce company in the UK.***\n\n***Dataset***\n*******************************************************************************************************************\n***InvoiceNo - Invoice Number (If this code starts with C, it means that the transaction has been cancelled.)***\n*******************************************************************************************************************\n***StockCode - unique number for each product***\n*******************************************************************************************************************\n***Description - Product Name\/Title***\n*******************************************************************************************************************\n***Quantity - It represents how many of the products on the invoices have been sold.***\n*******************************************************************************************************************\n***InvoiceDate - Invoice Date(Transaction Day)***\n*******************************************************************************************************************\n***UnitPrice - Total Invoice Price***\n*******************************************************************************************************************\n***CustomerID - unique Number for each customer***\n*******************************************************************************************************************\n***Country - Country***","1d9aa6c1":"***First I chose the group \"Champions\" because this group brings us the most profit with big monetary and high frequency.***\n\n***Secondly, I chose the \"Can't Loose\" segment because that group is the second group that provides us with the most \"monetary\", we cannot lose them either.***\n\n***Finally, I chose the \"Loyal Customers\" segment because it has low \"recency\" values \u200b\u200band high \"monetary\" values. We should make them feel valuable with some discount campaigns and prevent them from going to our competitors.***\n\n\n***Thanks for your time :).***"}}