{"cell_type":{"a371495f":"code","524af156":"code","1b2aa115":"code","a90cebea":"code","594d835c":"code","e2294c83":"code","e744a086":"code","856f10bf":"code","fc8e6400":"code","7a2d8832":"code","f4d186c5":"markdown","8922f225":"markdown","6d946c51":"markdown","204ad869":"markdown","379d6c7f":"markdown","efb67815":"markdown","722ea44f":"markdown","6cd00029":"markdown","195216c0":"markdown","7e3de6db":"markdown","d5fb30f9":"markdown","53e640df":"markdown","14876461":"markdown","d7636823":"markdown","edd4bfd9":"markdown","3017b4d9":"markdown","be6eeb81":"markdown","a6bffe27":"markdown"},"source":{"a371495f":"import os\nimport json\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as colors\nfrom tqdm import tqdm","524af156":"def get_input_matrix(json_file: dict, index: int) -> np.ndarray:\n    return np.array(json_file['train'][index]['input'])\n\ndef get_input_matrices(json_file: dict) -> list:\n    \"\"\"\n        Get all train input matrices from json file in list format\n\n        Input:\n            json_file: JSON file with 'train' filed\n        Output:\n            list of np.ndarrays, train input\n    \"\"\"\n    res = []\n    count_of_train_samples = len(json_file['train'])\n\n    for index in range(count_of_train_samples):\n        res.append(get_input_matrix(json_file, index))\n\n    return res\n\ndef get_output_matrix(json_file: dict, index: int) -> np.ndarray:\n    return np.array(json_file['train'][index]['output'])\n\ndef get_output_matrices(json_file: dict):\n    \"\"\"\n        Get all train output matrices from json file in list format\n\n        Input:\n            json_file: JSON file with 'train' filed\n        Output:\n            list of np.ndarrays, train outputs\n    \"\"\"\n    res = []\n    count_of_test_samples = len(json_file['train'])\n\n    for index in range(count_of_test_samples):\n        res.append(get_output_matrix(json_file, index))\n\n    return res\n\n\ndef get_input_matrix_test(json_file: dict, index: int) -> np.ndarray:\n    \"\"\"\n        Get input matrix from test\n\n        Input:\n            json_file: json object - python dict\n        Output:\n            numpy ndarray\n    \"\"\"\n    return np.array(json_file['test'][index]['input'])\n\ndef get_output_matrix_test(json_file: dict, index: int) -> np.ndarray:\n    \"\"\"\n        Get output matrix from test\n\n        Input:\n            json_file: json object - python dict\n        Output:\n            numpy ndarray\n    \"\"\"\n    return np.array(json_file['test'][index]['output'])\n\n\ndef get_input_matrices_test(json_file: dict) -> list:\n    \"\"\"\n        Get all test input matrices from json file in list format\n\n        Input:\n            json_file: JSON file with 'train' filed\n        Output:\n            list of np.ndarrays, test inputs\n    \"\"\"\n    res = []\n    count_of_test_samples = len(json_file['test'])\n\n    for index in range(count_of_test_samples):\n        res.append(get_input_matrix_test(json_file, index))\n\n    return res\n\ndef get_output_matrices_test(json_file: dict):\n    \"\"\"\n        Get all test input matrices from json file in list format\n\n        Input:\n            json_file: JSON file with 'train' filed\n        Output:\n            list of np.ndarrays, test inputs\n    \"\"\"\n    res = []\n    count_of_test_samples = len(json_file['test'])\n\n    for index in range(count_of_test_samples):\n        res.append(get_output_matrix_test(json_file, index))\n\n    return res\n\ndef load_task(json_file_path: str) -> tuple:\n    \"\"\"\n        Get train inp\/out matrices and test inp matrices\n\n        Input:\n            json_file_path: full path to json file with task\n        Output:\n            tuple:\n                1. List of train input matrices each matrix np.ndarray\n                2. List of train output matrices each matrix np.ndarray\n                3. List of test input matrices each matrix np.ndarray\n    \"\"\"\n\n\n    with open(json_file_path, 'r') as jfile:\n        json_file = json.load(jfile)\n\n        train_input_matrices  = get_input_matrices(json_file)\n        train_output_matrices = get_output_matrices(json_file)\n        test_input_matrices   = get_input_matrices_test(json_file)\n\n        return (train_input_matrices, train_output_matrices, test_input_matrices)\n    \ncmap = colors.ListedColormap(\n    ['#000000', '#0074D9', '#FF4136', '#2ECC40', '#FFDC00',\n     '#AAAAAA', '#F012BE', '#FF851B', '#7FDBFF', '#870C25'])\n\nnorm = colors.Normalize(vmin=0, vmax=9)\n\ndef plot_matrix(matrix, subplot_num = 111, title = ''):\n    ax = plt.subplot(subplot_num)\n    plt.title(title)\n    ax.imshow(matrix, cmap = cmap, norm = norm)\n    ax.grid(True, which = 'both', color = 'black', linewidth = 0.7)\n    ax.set_yticks([x - 0.5 for x in range(len(matrix) + 1)])\n    ax.set_xticks([x - 0.5 for x in range(len(matrix[0]) + 1)])\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n\ndef make_output(matrix: np.ndarray) -> str:\n    \"\"\" Create output in the right form \"\"\"\n\n    if (matrix is None):\n        return '||'\n\n    rows = ''\n\n    for row in matrix:\n        rows += str(row)\n\n    rows = rows.replace(' ', '')\n    rows = rows.replace('][', '|')\n    rows = rows.replace('[[', '|')\n    rows = rows.replace('[', '|')\n    rows = rows.replace(']]', '|')\n    rows = rows.replace(']', '|')\n\n    return rows\n\ndef check_size_1piece(input_matrices: list, output_matrices: list) -> bool:\n    \"\"\"\n        Check that output matrix has the same size with input\n    \"\"\"\n\n    for inp, out in zip(input_matrices, output_matrices):\n\n        vertical_ratio = out.shape[0] \/ inp.shape[0]\n        horizontal_ration = out.shape[1] \/ inp.shape[1]\n\n        cond1 = vertical_ratio == horizontal_ration and vertical_ratio == 1\n\n        if not cond1:\n            return False\n\n    return True","1b2aa115":"def is_similar(arr1: np.ndarray, arr2: np.ndarray, extra_color: int, min_possible_elements = 9) -> bool:\n    \"\"\"\n        Check that 2 arrays are equal except extra_color\n\n        Actually we try to find is it possible\n        to fill extra color in one array with elements from an other array\n\n        Input:\n            arr1, arr2: numpy arrays which will compare\n            extra_color: int should be in [0-9] this color we don't take into account\n            min_possible_elements:  a minimum number of elements != extra_color which has to be equal\n        Output:\n            False: if array\n\n    \"\"\"\n\n    if (arr1.size != arr2.size or arr1.size == 0 or arr1.ndim != 1 or arr2.ndim != 1):\n        return False\n    if (np.any(arr1 == extra_color) and np.any(arr2 == extra_color)):\n        return False\n\n    count_equal = 0\n\n    for i in range(arr1.shape[0]):\n        if (arr1[i] == extra_color or arr2[i] == extra_color):\n            continue\n        if (arr1[i] != arr2[i]):\n            return False\n\n        count_equal += 1\n\n    return count_equal >= min_possible_elements","a90cebea":"def find_equal_segment(inp: np.ndarray, bad_segment: np.ndarray, extra_color: int) -> np.ndarray:\n    \"\"\"\n        Function tries to find segment similar to bad_segment bad without extra_color\n        we suppose that cells == extra_color are just empty cells\n\n        Input:\n            inp: matrix where we search for good_segment\n            bad_segment: 1d row or col from input matrix where we wanna replace extra_color\n            extra_color: the color which we wanna replace\n        Output:\n            None if found nothing\n            or\n            1d np.ndarray which is equal with bad_segment bad without extra_color\n            size(bad_segment) = size(returned segment)\n    \"\"\"\n\n    segment_len = bad_segment.size\n\n    # trying to find on rows\n    for i in range(inp.shape[0]):\n        for col in range(inp.shape[1] - segment_len + 1):\n            current_segment = inp[i, col:col + segment_len]\n            if (is_similar(current_segment, bad_segment, extra_color)):\n                return current_segment\n\n    # trying to find on columns\n    for j in range(inp.shape[1]):\n        for row in range(inp.shape[0] - segment_len + 1):\n            current_segment = inp[row:row + segment_len, j]\n            if (is_similar(current_segment, bad_segment, extra_color)):\n                return current_segment\n\n    return None","594d835c":"def is_symmetric(matrix: np.ndarray, symmetric_type: int) -> tuple:\n    \"\"\"\n        Check if input matrix has symmetry or not\n        Matrix can have asymmetric parts algo looks on the whole matrix\n\n        Input:\n            matrix: ndarray SQUARE matrix\n            symmetric_type: which kind of symmetry should be in matrix\n                1. Horizontal (left and right cells are equal)\n                2. Vertical (upper and lower cells are equal)\n                3. Main diagonal (only for NxN matrices, cells are equal with respect to main diagonal)\n                4. Side diagoanl (only for NxN matrices, cells are equal with respect to side diagonal)\n        Output\n            Tuple:\n                1) True: if matrix is symmetrical\n                   False: otherwise\n                2) Most popular color for unsymmetric cases\n    \"\"\"\n\n    colors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    # how many elements are symmetric\n    equal = 0\n    # count of all elements\n    total = 0\n\n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n\n            cell = matrix[i][j]\n\n            if (symmetric_type == 1): # horizontal\n                opposite_cell = matrix[matrix.shape[0] - i - 1][j]\n            elif(symmetric_type == 2): #vertical\n                opposite_cell = matrix[i][matrix.shape[1] - j - 1]\n            elif(symmetric_type == 3): # main diagonal\n                opposite_cell = matrix[j][i]\n            else:\n                opposite_cell = matrix[matrix.shape[0] - j - 1][matrix.shape[1] - i - 1]\n\n            if (cell == opposite_cell):\n                equal += 1\n            else:\n                colors[cell] += 1\n                colors[opposite_cell] += 1\n\n            total += 1\n\n    max_color = 0\n\n    for i in range(len(colors)):\n        if (colors[i] > colors[max_color]):\n            max_color = i\n\n    # 0.6 means 60% of equal elements of all, you can change it in [0, 1]\n    if (equal \/ total > 0.6):\n        return (True, max_color)\n    else:\n        return (False, max_color)","e2294c83":"def delete_extra_color(inp: np.ndarray, extra_color: int):\n    \"\"\"\n        [Inplace function]\n    \n        This function tries to replace extra color in the input matrix\n        by finding equal rows and cols\n\n        Input:\n            inp: input matrix with extra_color which we want to replace\n            extra_color: number [0-9] which we want to replace in the input matrix\n        Output:\n            No output, this function directly changes input matrix\n\n    \"\"\"\n\n    bad_rows, bad_cols = np.where(inp == extra_color)\n\n    bad_rows = np.unique(bad_rows)\n    bad_cols = np.unique(bad_cols)\n\n    if (len(bad_rows) > inp.shape[0] \/\/ 2 or len(bad_cols) > inp.shape[0] \/\/ 2):\n        return\n\n    for i in bad_rows:\n        for segment_len in range(10, inp.shape[1] + 1, 1):\n            for col in range(inp.shape[1] - segment_len + 1):\n                bad_segment = inp[i, col: col + segment_len]\n\n                if (not np.any(bad_segment == extra_color)):\n                    continue\n\n                correct_segment = find_equal_segment(inp, bad_segment, extra_color)\n\n                if (correct_segment is not None):\n                    inp[i, col:col + segment_len] = correct_segment\n\n    for j in bad_cols:\n        for segment_len in range(10, inp.shape[0] + 1, 1):\n            for row in range(inp.shape[0] - segment_len + 1):\n                bad_segment = inp[row:row + segment_len, j]\n\n                if (not np.any(bad_segment == extra_color)):\n                    continue\n\n                correct_segment = find_equal_segment(inp, bad_segment, extra_color)\n\n                if (correct_segment is not None):\n                    inp[row:row + segment_len, j] = correct_segment\n","e744a086":"def prediction(inp: np.ndarray,\n                    symmetric_axis_horizontal: list,\n                    symmetric_axis_vertical: list,\n                    symmetric_main_diagonal: bool,\n                    symmetric_side_diagonal: bool,\n                    shift_i: int,\n                    shift_j: int,\n                    size: int,\n                    extra_color: int) -> bool:\n    \"\"\"\n        Make a prediction for one matrix\n\n        Find cells with extra_color and fill them with\n        right color from symmetric cells\n\n        Input:\n            inp: matrix which we want to change\n\n        Output:\n            changed input matrix\n    \"\"\"\n\n    res = inp.copy()\n\n    for i in range(inp.shape[0]):\n        for j in range(inp.shape[1]):\n\n            # it's a good cell\n            if (inp[i][j] != extra_color):\n\n                res[i][j] = inp[i][j]\n                continue\n\n            if symmetric_axis_horizontal is not None:\n                if (symmetric_axis_horizontal[1] != 0):\n                    vertical_len = min(abs(i - symmetric_axis_horizontal[0]), abs(i - symmetric_axis_horizontal[1]))\n\n                    row = i + vertical_len * 2 + 1\n                    if (i >= symmetric_axis_horizontal[1]):\n                        row = i - vertical_len * 2 - 1\n\n                    if (0 <= row and row < inp.shape[0] and inp[row][j] != extra_color):\n                        res[i][j] = inp[row][j]\n                else:\n                    vertical_len = abs(i - symmetric_axis_horizontal[0])\n\n                    row = i + vertical_len * 2\n                    if (i >= symmetric_axis_horizontal[0]):\n                        row = i - vertical_len * 2\n\n                    if (0 <= row and row < inp.shape[0] and inp[row][j] != extra_color):\n                        res[i][j] = inp[row][j]\n\n            if symmetric_axis_vertical is not None:\n                if (symmetric_axis_vertical[1] != 0):\n                    horizontal_len = min(abs(j - symmetric_axis_vertical[0]), abs(j - symmetric_axis_vertical[1]))\n\n                    column = j + horizontal_len * 2 + 1\n\n                    if (j >= symmetric_axis_vertical[1]):\n                        column = j - horizontal_len * 2 - 1\n\n                    if (0 <= column and column < inp.shape[1] and inp[i][column] != extra_color):\n                        res[i][j] = inp[i][column]\n                else:\n                    horizontal_len = abs(j - symmetric_axis_vertical[0])\n\n                    column = j + horizontal_len * 2\n                    if (j >= symmetric_axis_vertical[0]):\n                        column = j - horizontal_len * 2\n\n                    if (0 <= column and column < inp.shape[1] and inp[i][column] != extra_color):\n                        res[i][j] = inp[i][column]\n\n            if (symmetric_main_diagonal):\n\n                if i - shift_i > j - shift_j:\n                    new_i = j + abs(shift_j - shift_i)\n                    new_j = i - abs(shift_j - shift_i)\n                elif i - shift_i < j - shift_j:\n                    new_i = j - abs(shift_j - shift_i)\n                    new_j = i + abs(shift_j - shift_i)\n                else:\n                    new_i, new_j = -1, -1\n\n                if (0 <= new_i and new_i < inp.shape[0] and 0 <= new_j and new_j < inp.shape[1] and inp[new_i][new_j] != extra_color):\n                    res[i][j] = inp[new_i][new_j]\n\n            if (symmetric_side_diagonal):\n\n                side_diag_sum = shift_i + shift_j + size - 1\n                delta = side_diag_sum - i - j\n\n                if (delta % 2 == 0):\n                    if(delta > 0):\n                        delta += 1\n                    elif(delta < 0):\n                        delta -= 1\n\n                new_i = i + delta\n                new_j = j + delta\n\n                if (0 <= new_i and new_i < inp.shape[0] and 0 <= new_j and new_j < inp.shape[1] and\n                        inp[new_i][new_j] != extra_color):\n                    res[i][j] = inp[new_i][new_j]\n\n    if (np.any(res == extra_color)):\n        delete_extra_color(res, extra_color)\n\n    return res","856f10bf":"def find_restored_matrix(inp: np.ndarray, out: np.ndarray, mode = 'train') -> list:\n    \"\"\"\n        This function tries to restore input matrix\n        i.e to fill \"empty\" places where are placed incorrect color\n\n        Input:\n            inp: 2d input matrix\n            out: 2d output matrix how should look input matrix after all manipulations\n            mode: 'train' in this case we also check inp and out\n                  'test' in this case we just return predicted matrix\n\n    \"\"\"\n    \n    # 11 chosen by hands\n    min_possible_size = max(11, inp.shape[0] \/\/ 2)\n\n    # let's try to find maximum size of sub matrix with symmetry\n    for size in range(min_possible_size, inp.shape[0] + 1, 1):\n\n        # for each matrix we should know lines of symmetry\n        symmetric_axis_horizontal = None\n        symmetric_axis_vertical = None\n\n        for i in range(inp.shape[0] - size + 1):\n            for j in range(inp.shape[1] - size + 1):\n\n                sub_matrix = inp[i:i + size, j:j + size].copy()\n\n                result_horizontal = is_symmetric(sub_matrix, 1)\n                result_vertical   = is_symmetric(sub_matrix, 2)\n                result_main_diag  = is_symmetric(sub_matrix, 3)\n                result_side_diag  = is_symmetric(sub_matrix, 4)\n\n                if (result_horizontal[0]):\n                    extra_color = result_horizontal[1]\n                elif (result_vertical[0]):\n                    extra_color = result_vertical[1]\n                elif (result_main_diag[0]):\n                    extra_color = result_main_diag[1]\n                elif (result_side_diag[0]):\n                    extra_color = result_side_diag[1]\n                else:\n                    break\n\n                if (result_horizontal[0] and extra_color != result_horizontal[1]):\n                    break\n                if (result_vertical[0] and extra_color != result_vertical[1]):\n                    break\n                if (result_main_diag[0] and extra_color != result_main_diag[1]):\n                    break\n                if (result_side_diag[0] and extra_color != result_side_diag[1]):\n                    break\n\n                if (size % 2 == 0):\n\n                    vertical_index = [0, 0]\n                    vertical_index[0] = (j + j + size) \/\/ 2 - 1\n                    vertical_index[1] = (j + j + size) \/\/ 2\n\n                    horizontal_index = [0, 0]\n                    horizontal_index[0] = (i + i + size) \/\/ 2 - 1\n                    horizontal_index[1] = (i + i + size) \/\/ 2\n\n                    if (result_horizontal[0]):\n                        symmetric_axis_horizontal = horizontal_index\n                    if (result_vertical[0]):\n                        symmetric_axis_vertical = vertical_index\n                else:\n                    vertical_index = (j + j + size) \/\/ 2\n                    horizontal_index = (i + i + size) \/\/ 2\n\n                    if (result_horizontal[0]):\n                        symmetric_axis_horizontal = [horizontal_index, 0]\n                    if (result_vertical[0]):\n                        symmetric_axis_vertical = [vertical_index, 0]\n\n                cur = prediction(inp, symmetric_axis_horizontal, symmetric_axis_vertical,\n                                    result_main_diag[0], result_side_diag[0], i, j, size, extra_color)\n\n                if (np.any(cur == extra_color)):\n                    continue\n\n                if (mode == 'train' and np.array_equal(cur, out)):\n                    return cur\n                elif (mode == 'test'):\n                    return cur\n\n    return None","fc8e6400":"def symmetry_algo(train_in: list, train_out: list, test_in: list) -> list:\n    \"\"\"\n        Find symmetry and fill empty cells\n\n        Tasks Evalutaion: 47996f11.json 4aab4007.json 903d1b4a.json\n                          929ab4e9.json 981571dc.json af22c60d.json\n                          ca8f78db.json e95e3d8e.json f823c43c.json\n                          f9d67f8b.json\n\n        Input:\n            train_in:  list of np.ndarray train samples\n            train_out: list of np.ndarray train samples output\n            test_in:   list of np.ndarray test sample.\n        Output:\n            test_out: list of np.ndarray test output matrices\n    \"\"\"\n\n    for inp, out in zip(train_in, train_out):\n        \n        # 11 chosen by hands :)\n        if (inp.shape[0] < 11):\n            return None\n\n        predict = find_restored_matrix(inp, out)\n\n        if (predict is None):\n            return None\n\n    result = []\n    \n    for test_inp in test_in:\n\n        if (test_inp.shape[0] < 11):\n            return None\n\n        predict = find_restored_matrix(test_inp, inp, mode = 'test')\n\n        if (predict is None):\n            return None\n\n        result.append(predict)\n\n\n    return result","7a2d8832":"data_folder = '..\/input\/abstraction-and-reasoning-challenge\/evaluation\/'\n\nresults = pd.DataFrame(columns = ('output_id', 'output'))\n\nmode = 'Train' # use 'Train' if wanna see statistics, any other string in case of getting results on the test set\n\ncorrect_predictions = 0\ntotal_predictions = 0\n\n# go through tasks in data_folder\nfor filename in tqdm(os.listdir(data_folder)):\n    \n    full_path = os.path.join(data_folder, filename)\n\n    train_input_matrices, train_output_matrices, test_input_matrices = load_task(full_path)\n    \n    \n    if (mode == 'Train'):\n    \n        with open(full_path, 'r') as jfile:\n            json_file = json.load(jfile)\n    \n        test_output_matrices = get_output_matrices_test(json_file)\n    \n    solution_found = False\n    \n    if (check_size_1piece(train_input_matrices, train_output_matrices)):\n        \n        predictions = symmetry_algo(train_input_matrices, train_output_matrices, test_input_matrices)\n        \n        total_predictions += len(test_input_matrices)\n        \n        if predictions is not None:\n            \n            print('Found for: ', filename)\n            \n            solution_found = True\n            \n            for ind, test_out in enumerate(predictions):\n\n                # separate filename from '.json'\n                filename = filename.split('.')[0]\n                results = results.append({'output_id': filename + '_' + str(ind), 'output': make_output(test_out)}, ignore_index = True)\n                \n                if (mode == 'Train'):\n                    \n                    if (np.array_equal(test_out, test_output_matrices[ind])):\n                        correct_predictions += 1\n                        plt.figure(figsize = (10, 5), dpi = 150)\n                        plot_matrix(test_input_matrices[ind], 131, 'Test input matrix')\n                        plot_matrix(test_output_matrices[ind], 132, 'Test output matrix')\n                        plot_matrix(test_out, 133, 'Test predicted matrix')\n                        plt.show()\n                \n    \n    if (not solution_found):\n\n        # define empty predictions\n        predictions = np.array([])\n\n        for ind in range(len(test_input_matrices)):\n            # we found nothing\n            results = results.append({'output_id': filename.split('.')[0] + '_' + str(ind), 'output': make_output(predictions)}, ignore_index = True)\n\nif (mode == 'Train'):\n    print(f'Solved {correct_predictions} of {total_predictions}')\n            \nresults.to_csv('submission.csv', index = False)","f4d186c5":"# Testing part ","8922f225":"# Main logic of the algo","6d946c51":"In this function we are trying to replace cells with *extra_color*\n\nWe have input matrix and a few extra parameters. ","204ad869":"In this part we are trying to choose submatrix with symmetry and restore the input matrix via \nsymmetry lines","379d6c7f":"# Make a prediction then we know parameters of symmetry","efb67815":"# ARC utils functions (read, plot, etc.)","722ea44f":"**find_equal_segment** It is supposed that bad_segment is 1d array and has some cells with an extra color. We are trying find another 1d array which be the same but without extra color","6cd00029":"# Helper functions for the algorithm","195216c0":"\n\nHere we take data for the current task and apply a few methods to find answer","7e3de6db":"\n\nHere we iterate over all samples and make predictions ","d5fb30f9":"# Iterate over train pairs and apply algo","53e640df":"![symmetry_answer_finding.png](attachment:symmetry_answer_finding.png)\n\n\nFind symmetric parts in the input matrix and replace 'extra' color.\n\n**Main parts:**\n\n1. Find submatrix with at least 1 type of symmetry (vertical, horizontal, main diagonal, side diagonal)\n   We iterate row and column in the original matrix it will be left top corner of submatrix\n   \n   Submatrix always is a square matrix!\n   \n   Pseudo code:\n     \n       for sub_m_size in [min_sub_size, max_sub_size]:\n           for i in [0, height]:\n               for j in [0, width]:\n                  sub_matrix = source_matrix[i: i + sub_m_size, j: j + sub_m_size]\n   \n2. Transfer axis of symmetry from sub matrix into original matrix\n3. Check if we can replace all cells with extra color\n4. Check that all train pairs solved right\n5. In case we found answer apply it to the test, otherwise return None\n6. Get 0 right answer on test \n\n\nI know it is a lot of code and could be solved with more simple algorithm but this approach works quite fast :)\n\nAlso it could be fine tuned because, there are a few samples where it works almost right, but not\n\nProbably idea would be helpful for someone \n","14876461":"**is_similar** function just checks can we create arr2 from arr1 or (arr1 from arr2) if we change cells with an 'extra_color'\n\nOne of two arrays should not have any cells with 'extra_color'","d7636823":"# Score","edd4bfd9":"# Idea","3017b4d9":"\n\nHere we take input and output matrices and do magic","be6eeb81":"**delete_extra_color** We use this function on the final step when we have already applied base algo and have some cells with an extra color. It is brutoforce function which is trying to find equal 1d parts and correct wrong one","a6bffe27":"\n\nTraining: 4 right answers\n\nEvaluation: 10 right answers\n\nTest: 0 right answers\n"}}