{"cell_type":{"1c7bb44a":"code","d14b2655":"code","f62e05c2":"code","1f99b8a2":"code","6fb01cef":"code","b90c1bf6":"code","b771d402":"code","acd1c8f7":"code","52378608":"code","a978fbde":"code","369f75b5":"code","5870335b":"code","8c61ae82":"code","2150e5ad":"code","0c0cf68b":"code","e7b8b567":"code","37d040fc":"code","32ebebf2":"code","2c5fe21a":"code","3c0d4858":"code","b82c5ded":"code","8d806059":"code","879879c8":"code","4ebe839e":"code","a8e4e654":"code","855c2df4":"code","d05b2043":"code","8223e42c":"code","fad3f167":"code","3bfa10e4":"code","48eab21b":"code","8cd7b222":"code","5bd7f1ab":"code","2e784544":"code","ce7b2770":"code","474a16f5":"code","fab31fe5":"code","3f180432":"code","4aa968a6":"code","7d49d92e":"code","e09dc763":"code","d2b460d2":"code","973671e2":"code","f8bf5419":"code","89664b20":"code","9cf48d62":"code","8ee50536":"code","7fcc53fc":"code","bc839625":"code","05c6a761":"code","b72cd188":"code","31e4facf":"code","cbb5462a":"code","2897717d":"code","6d3eb5bd":"code","eea919af":"code","9f63f998":"code","6ccb30de":"code","47918172":"code","4260a96f":"code","c619966e":"code","fb13cda2":"code","7088c562":"code","d2986e04":"code","edacb5f5":"code","5af58d5a":"code","35a4638a":"code","a0bcd1d3":"code","087961ed":"code","de57520c":"code","3c519154":"code","8d64c43b":"code","e39976e1":"markdown","0325dd70":"markdown","13ad3f53":"markdown","43e39c20":"markdown","07466597":"markdown","c11cbdd6":"markdown","204e8e93":"markdown","0f94d91c":"markdown","f9422da0":"markdown","8d91f4a3":"markdown","59dd1859":"markdown","43311272":"markdown","e3c092c0":"markdown","c4708663":"markdown","496d96f4":"markdown","1bf63d48":"markdown","f8ce7f51":"markdown","9c61f339":"markdown","6ea3f467":"markdown","d15dbd93":"markdown","e7dd0adf":"markdown","2673e40e":"markdown","3d82b527":"markdown","9f04d3ec":"markdown","fa2072ec":"markdown","e82ab69b":"markdown","e6ac8137":"markdown","aacdec73":"markdown","feac3ee9":"markdown","acc5d36c":"markdown","d70a17d2":"markdown","61a50d44":"markdown","a10e0a2b":"markdown","e1714799":"markdown","3ca6b38c":"markdown","980c101e":"markdown","cf279bf2":"markdown"},"source":{"1c7bb44a":"from IPython.core.display import display, HTML\nfrom IPython.display import Image\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer\nfrom sklearn.preprocessing import normalize","d14b2655":"# Document and Word Vectors\nImage('https:\/\/mlwhiz.com\/images\/countvectorizer.png',width=800, height=400)","f62e05c2":"# create a list of documents\n# text = ['This is the first document'\n#         , 'This is the second second document'\n#         , 'And the third one'\n#         , 'Is it the first document again']\n\ntext=['This is good',\n     'This is bad',\n     'This is awesome']","1f99b8a2":"from sklearn.feature_extraction.text import CountVectorizer","6fb01cef":"# create an instance of countvectorizer\nvect = CountVectorizer()  # shift tab ","b90c1bf6":"# when we print vect, we see its hyperparameters\nprint(vect)","b771d402":"# The vectorizer learns the vocabulary when we fit it with our documents. \n# This means it learns the distinct tokens (terms) in the text of the documents. \n# We can observe these with the method get_feature_names\n\nvect.fit(text)","acd1c8f7":"print('ORIGINAL_SENTENCES: \\n {} \\n'.format(text))\nprint('FEATURE_NAMES: \\n {}'.format(vect.get_feature_names()))","52378608":"# Transform creates a sparse matrix, identifying the indices where terms are stores in each document\n# This sparse matrix has 4 rows and 11 columns\n\npd.DataFrame(vect.transform(text).toarray(),columns= ['awesome', 'bad', 'good', 'is', 'this'])[ ['this','is','good','bad','awesome']]","a978fbde":"print(vect.transform(text))","369f75b5":"sparse_matrix_url = 'https:\/\/op2.github.io\/PyOP2\/_images\/csr.svg'\niframe = '<iframe src={} width=1000 height=200><\/iframe>'.format(sparse_matrix_url)\nHTML(iframe)","5870335b":"# This is easier to understand when we covert the sparse matrix into a dense matrix or pandas DataFrame\nvect.transform(text).toarray()","8c61ae82":"import pandas as pd\n\n# store the dense matrix\ndata = vect.transform(text).toarray()\n\n# store the learned vocabulary\ncolumns = vect.get_feature_names()\n\n# combine the data and columns into a dataframe\npd.DataFrame(data, columns=columns)[['this','is','good','bad','awesome']]","2150e5ad":"example_text = ['again we observe a document'\n               , 'the second time we have see this text']","0c0cf68b":"# TODO\n","e7b8b567":"vect = CountVectorizer()\nvect.fit_transform(text).toarray()","37d040fc":"Image('http:\/\/karlrosaen.com\/ml\/learning-log\/2016-06-20\/pipeline-diagram.png')","32ebebf2":"text = ['This is the first document'\n        , 'This is the second second document'\n        , 'And the third one'\n        , 'Is it the first document again']","2c5fe21a":"vect = CountVectorizer()","3c0d4858":"# by instantiating CountVectorizer with differnt parameters, we can change the vocabulary\n# lowercase determines if all words should be lowercase, setting it to False includes uppercase words\n\nvect = CountVectorizer(lowercase=False)\nvect.fit(text)\nprint(vect.get_feature_names())","b82c5ded":"# stops words determine if we should include common words (e.g. and, is, the) which show up in most documents\nvect = CountVectorizer(stop_words='english')\nvect.fit(text)\nprint(vect.get_feature_names())","8d806059":"# stops words determine if we should include common words (e.g. and, is, the) which show up in most documents\nvect = CountVectorizer(stop_words=['first','second','third'])\nvect.fit(text)\nprint(vect.get_feature_names())","879879c8":"# stops words determine if we should include common words (e.g. and, is, the) which show up in most documents\nvect = CountVectorizer(vocabulary=['first','second','third'])\nvect.fit(text)\nprint(vect.get_feature_names())","4ebe839e":"vect.transform(text).toarray()","a8e4e654":"vect = CountVectorizer(max_features=5)\nvect.fit(text)\nprint(vect.get_feature_names())","855c2df4":"vect = CountVectorizer(max_df=.5)\nvect.fit(text)\nprint(vect.get_feature_names())","d05b2043":"vect = CountVectorizer(min_df=.5)\nvect.fit(text)\nprint(vect.get_feature_names())","8223e42c":"# max features determines the maximum number of features to display\nvect = CountVectorizer(ngram_range=(1,2), max_features=5)\nvect.fit(text)\nprint(vect.get_feature_names())","fad3f167":"# max features determines the maximum number of features to display\nvect = CountVectorizer(binary=True)\nvect.fit_transform(['Two Two different words words']).toarray()","3bfa10e4":"# max features determines the maximum number of features to display\nvect = CountVectorizer(analyzer='char', ngram_range=(2,2))\nvect.fit(text)\nprint(vect.get_feature_names())","48eab21b":"vect = CountVectorizer(max_features=5)\nvect.fit(text)\nprint(vect.get_feature_names())","8cd7b222":"vect.vocabulary_","5bd7f1ab":"vect.stop_words_","2e784544":"import numpy as np\nfrom sklearn.feature_extraction.text import TfidfVectorizer","ce7b2770":"text","474a16f5":"tfidf_vect = TfidfVectorizer()\npd.DataFrame(tfidf_vect.fit_transform(text).toarray(), columns=tfidf_vect.get_feature_names())","fab31fe5":"vect = CountVectorizer()\ntf = vect.fit_transform(text).toarray()\npd.DataFrame(tf,columns= vect.get_feature_names())","3f180432":"Image('http:\/\/www.science4all.org\/wp-content\/uploads\/2013\/10\/Graph-of-Logarithm-and-Exponential1.png')","4aa968a6":"tf","7d49d92e":"len(tf)","e09dc763":"vect = CountVectorizer(binary=True)\ncount_vec = vect.fit_transform(text).toarray()\npd.DataFrame(count_vec,columns= vect.get_feature_names())","d2b460d2":"len(count_vec)","973671e2":"\n# idf calculation\nprint( np.log(len(count_vec) \/ count_vec.sum(axis=0)) )","f8bf5419":"list(zip(vect.get_feature_names(),np.log(len(count_vec) \/ count_vec.sum(axis=0))))","89664b20":"# when we use sum(axis=0) we take the sum of each column\n# as opposed to a scalar sum (single # result) of all values\ncount_vec.sum(axis=0)","9cf48d62":"idf = np.log( (len(count_vec)+1) \/ (count_vec.sum(axis=0)+1) ) + 1\nprint(idf)","8ee50536":"# value as stored from sklearn in tfidf_vect\nprint(tfidf_vect.idf_)","7fcc53fc":"tfidf = pd.DataFrame(tf*idf,columns=tfidf_vect.get_feature_names())\ntfidf","bc839625":"# tf*idf is equivalent to using TfidfVectorizer without a norm\ntfidf_vect = TfidfVectorizer(norm=None)\npd.DataFrame(tfidf_vect.fit_transform(text).toarray())","05c6a761":"from sklearn.preprocessing import normalize\n\npd.DataFrame(normalize(tfidf, norm='l2'))","b72cd188":"# normalize()","31e4facf":"# TFIDF Weighting in Sklearn\n'http:\/\/scikit-learn.org\/stable\/modules\/feature_extraction.html#tfidf-term-weighting'\n\n# tf*idf is equivalent to using TfidfVectorizer without a norm\ntfidf_vect = TfidfVectorizer(norm='l2')\npd.DataFrame(tfidf_vect.fit_transform(text).toarray())","cbb5462a":"import os\nos.listdir('..\/input')","2897717d":"path='..\/input\/usinlppracticum\/imdb_train.csv'\ndata= pd.read_csv(path)\ndata.head()","6d3eb5bd":"labels=data['sentiment'].unique().tolist()\nlabel2id={ lbl:i for i,lbl in enumerate(labels)}\nid2label={ i:lbl for i,lbl in enumerate(labels)}\nprint(label2id), print(id2label)","eea919af":"data['label']=data['sentiment'].map(label2id)\ndata.head()","9f63f998":"data.shape","6ccb30de":"import spacy, string\nnlp = spacy.load('en')\npunctuations = string.punctuation\nfrom spacy.lang.en.stop_words import STOP_WORDS\ndef cleanup_text(doc):\n    doc = nlp(doc, disable=['parser', 'ner'])\n    tokens = [tok.lemma_.lower().strip() for tok in doc if tok.lemma_ != '-PRON-']\n#   print (tokens)\n    tokens = \" \".join([i for i in tokens if i not in STOP_WORDS and len(i)>2]) \n#     tokens = ' '.join(tokens)\n    return tokens","47918172":"print(cleanup_text(data['review'][1]))","4260a96f":"data= data.sample(1000).reset_index(drop=True)","c619966e":"from tqdm import tqdm\ntqdm.pandas()","fb13cda2":"data['clean_review']=data['review'].progress_apply(lambda x:cleanup_text(x))\ndata.head()","7088c562":"# split the dataset into training and validation datasets \nfrom sklearn import model_selection\ntrain_x, valid_x, train_y, valid_y = model_selection.train_test_split(data['clean_review'], data['label'],test_size=0.2, random_state=42)","d2986e04":"train_x.head()","edacb5f5":"# word level tf-idf\ntfidf_vect = TfidfVectorizer(analyzer='word',max_df=0.95, min_df=5,ngram_range=(1,1),\n                             max_features=1500)\n\ntfidf_vect.fit(train_x) #--- -\nxtrain_tfidf =  tfidf_vect.transform(train_x)\nxvalid_tfidf =  tfidf_vect.transform(valid_x)","5af58d5a":"xtrain_tfidf.shape,xvalid_tfidf.shape","35a4638a":"features_name=tfidf_vect.get_feature_names()\nfeatures_name[:30]","a0bcd1d3":"from sklearn import ensemble\n# RF on Word Level TF IDF Vectors\nmodel=ensemble.RandomForestClassifier(n_estimators=50, random_state=0)\nmodel.fit(xtrain_tfidf, train_y)\n","087961ed":"from sklearn import metrics\npredictions = model.predict(xvalid_tfidf)\naccuracy=metrics.accuracy_score(predictions, valid_y)\nprint (\"Random Forest accuracy for validation: \", accuracy)","de57520c":"Image('http:\/\/cs.carleton.edu\/cs_comps\/0910\/netflixprize\/final_results\/knn\/img\/knn\/cos.png')","3c519154":"from sklearn.metrics.pairwise import linear_kernel\n\ndef find_similar(tfidf_matrix, index, top_n = 5):\n    cosine_similarities = linear_kernel(tfidf_matrix[index:index+1], tfidf_matrix).flatten()\n    related_docs_indices = [i for i in cosine_similarities.argsort()[::-1] if i != index]\n    return [(index, cosine_similarities[index]) for index in related_docs_indices][0:top_n]","8d64c43b":"find_similar(xtrain_tfidf, 1)","e39976e1":"### ngram_range\n\n- tuple (min_n, max_n)\n\n- The lower and upper boundary of the range of n-values for different n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used.","0325dd70":"### lowercase\n- boolean, True by default\n- Convert all characters to lowercase before tokenizing.","13ad3f53":"# Attributes","43e39c20":"#### inverse document frequency (idf)\n\nCalculation: log(\\# document in the corpus \/ # documents where the term appears)\n\n- Numerator: **The # of documents in the corpus has no effect** as it is the same for all terms\n- Denominator: **As the # of documents in which the term appears increases, the idf decreases**; thus terms that show up in many different documents (e.g. stop words) recieve low tfidf scores as they are not important terms to define the meaning of the document \n- As a sub-linear function, we take the **log because the relevance does not increase proportionally with the term frequency**. As an example if a term shows up in 1M docs or in 2M docs, the effect is not the same as if it has shown up in 1 doc or 2 docs times respectively. In other words there is a relative threshold.","07466597":"## Exercise\n\nUse the trained CountVectorizer to vectorize the following sentences. Create a dataframe with the dense results.","c11cbdd6":"#### term frequency * inverse document frequency (tf*idf)","204e8e93":"### Sparsity\n\nAs most documents will typically use a very small subset of the words used in the corpus, the resulting matrix will have many feature values that are zeros (typically more than 99% of them).\n\nFor instance a collection of 10,000 short text documents (such as emails) will use a vocabulary with a size in the order of 100,000 unique words in total while each document will use 100 to 1000 unique words individually.","0f94d91c":"### TFIDF\n\nIn a large text corpus, some words will be very present (e.g. \u201cthe\u201d, \u201ca\u201d, \u201cis\u201d in English) hence carrying very little meaningful information about the actual contents of the document. If we were to feed the direct count data directly to a classifier those very frequent terms would shadow the frequencies of rarer yet more interesting terms.\n\nIn order to re-weight the count features into floating point values suitable for usage by a classifier it is very common to use the tf\u2013idf transform.\nTf means term-frequency while tf\u2013idf means term-frequency times inverse document-frequency: \n\n- tf-idf(t,d) = tf(t,d) * idf(t)","f9422da0":"#### scikit-learn calculation modifications\n\nscikit-learn further modifies the caluclation for adding one to the numerator, denominator, and log to avoid divide by zero errors","8d91f4a3":"### Bag of Words\n\nWe call **vectorization** the general process of turning a collection of text documents into numerical feature vectors. This specific strategy (tokenization, counting and normalization) is called the Bag of Words or \u201cBag of n-grams\u201d representation. Documents are described by word occurrences while `completely ignoring the relative position information of the words in the document.`\n\nA corpus of documents can thus be represented by a **matrix with one row per document and one column per token (e.g. word)** occurring in the corpus.","59dd1859":"### Step 2 - instantiate","43311272":"**preprocessing function**","e3c092c0":"### max_features\n- int or None, default=None\n- If not None, build a vocabulary that only consider the top  max_features ordered by term frequency across the corpus.","c4708663":"**tf-idf on imdb dataset**","496d96f4":"#### term vector normalization\n\nThe use of the simple tfidf does not account for the length of the document. Additionally it provides opportunities for spammers to repeat the term many times to make it seem more important in a specific document (e.g. to improve google search ranking)\n\nTo solve these issues, we normalize each vector. By default TfidfVectorizer uses an 'l2' normalization.","1bf63d48":"#### term frequency (tf)\n\nHow often does each term exist in each document. \n\nTerm frequency is the numerator; thus, the tfidf score for a term increases in documents where it is frequent.","f8ce7f51":"### stop\\__words_\\_ \n- set\n- Terms that were ignored because they either:\n - occurred in too many documents (max_df)\n - occurred in too few documents (min_df)\n - were cut off by feature selection (max_features)","9c61f339":"### vocabulary\n\n- Mapping or iterable, optional\n- Either a Mapping (e.g., a dict) where keys are terms and values are indices in the feature matrix, or an iterable over terms. If not given, a vocabulary is determined from the input documents. ","6ea3f467":"### TFIDF Analysis\nAs we look at the tfidf score (which have a range of 0-1), high score occur for words that show up frequently in specific sentence but infrequenty overall. Low score occur in words that show up frequenty across all documents.\n\n- **'Second' has a high score** as it shows up twice in document two and not in any other documents\n- **'The' has a low score** as it show up in all documents","d15dbd93":"### max_df\n- float in range [0.0, 1.0] or int, default=1.0\n- When building the vocabulary ignore terms that have a document frequency strictly higher than the given threshold (corpus-specific stop words). If float, the parameter represents a proportion of documents, integer absolute counts. This parameter is ignored if vocabulary is not None.","e7dd0adf":"### Step 3 - fit ","2673e40e":"### analyzer\n\n- String, {\u2018word\u2019, \u2018char\u2019, \u2018char_wb\u2019} or callable\n- Specifies whether to use n_grams of words or characters\n- Character n_grams are useful in certain content, such as genomics with DNA sequences (e.g. GCTATCAFF...)","3d82b527":"### Limitations of the Bag of Words representation\n\nA collection of unigrams (what bag of words is) cannot capture phrases and multi-word expressions, effectively disregarding any word order dependence. Additionally, the bag of words model doesn\u2019t account for potential misspellings or word derivations.\n\nN-grams to the rescue! Instead of building a simple collection of unigrams (n=1), one might prefer a collection of bigrams (n=2), where occurrences of pairs of consecutive words are counted.\n\nOne might alternatively consider a collection of character n-grams, a representation resilient against misspellings and derivations.\n\nFor example, let\u2019s say we\u2019re dealing with a corpus of two documents: ['words', 'wprds']. The second document contains a misspelling of the word \u2018words\u2019. A simple bag of words representation would consider these two as very distinct documents, differing in both of the two possible features. A character 2-gram representation, however, would find the documents matching in 4 out of 8 features, which may help the preferred classifier decide better:","9f04d3ec":"### stop_words\n\n- string {\u2018english\u2019}, list, or None (default)\n - If None, no stop words will be used. \n - If \u2018english\u2019, a built-in stop word list for English is used.\n - If list, that list is assumed to contain stop words, all of which will be removed from the resulting tokens.\n- max_df can be set to a value in the range [0.7, 1.0) to automatically detect and filter stop words \n","fa2072ec":"### Step 1 - import from sklearn","e82ab69b":"### binary\n\n- boolean, default=False\n- If True, all non zero counts are set to 1. This is useful for discrete probabilistic models that model binary events rather than integer counts.","e6ac8137":"### Step 4 - transform ","aacdec73":"In scikit-learn attributes are often provided to store information of the instance of the transformer or model. \n\nMany attributes are only available after the model is fit. For instance the learned vocabulary does not exist in Countvectorizer until text data has been provided with the fit method. Until the data is provided these attributes do not exist. The notation for these learned attributes is a trailing underscore after the attribute name (e.g. vocabulary_). ","feac3ee9":"Cosine Similarity\nInformation Retrieval","acc5d36c":"### min_df\n\n- float in range [0.0, 1.0] or int, default=1\n- When building the vocabulary ignore terms that have a document frequency strictly lower than the given threshold. This value is also called cut-off in the literature. If float, the parameter represents a proportion of documents, integer absolute counts. This parameter is ignored if vocabulary is not None.","d70a17d2":"Text Analysis is a major application field for machine learning algorithms. However the raw data, a sequence of symbols cannot be fed directly to the algorithms themselves as most of them expect numerical feature vectors with a fixed size rather than the raw text documents with variable length.\n\nIn order to address this, scikit-learn provides utilities for the most common ways to extract numerical features from text content, namely:\n\n- **tokenizing** strings and giving an integer id for each possible token, for instance by using white-spaces and punctuation as token separators.\n\n- **counting** the occurrences of tokens in each document.\n\n- **normalizing** and weighting with diminishing importance tokens that occur in the majority of samples \/ documents.\n\nSources: http:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.feature_extraction.text.CountVectorizer.html","61a50d44":"### vocabulary_\n\n- dict\n- A mapping of terms to feature indices.","a10e0a2b":"## TFIDF Calculation","e1714799":"## Text Vectorization\n\n##### Author: Alex Sherman (alsherman@deloitte.com) |  Vikas Kumar (vikkumar@deloitte.com)","3ca6b38c":"### Term-Frequency Problems\n\n\"The **main problem with the term-frequency approach is that it scales up frequent terms and scales down rare terms which are empirically more informative than the high frequency terms.**\nThe basic intuition is that a term that occurs frequently in many documents is not a good discriminator; the important question here is: why would you, in a classification problem for instance, emphasize a term which is almost present in the entire corpus of your documents ?\n\nThe tf-idf weight comes to solve this problem. **What tf-idf gives is how important is a word to a document**\nin a collection, and that\u2019s why tf-idf incorporates local and global parameters, because it takes in consideration not only the isolated term but also the term within the document collection. **What tf-idf then does to solve that problem, is to scale down the frequent terms while scaling up the rare terms; a term that occurs 10 times more than another isn\u2019t 10 times more important than it, that\u2019s why tf-idf uses the logarithmic scale to do that.\"**\n\nSource: http:\/\/blog.christianperone.com\/2011\/10\/machine-learning-text-feature-extraction-tf-idf-part-ii\/","980c101e":"### fit_transform\n\n- we can combine the training and transformation into a single method. This is a common process in the sklearn api, as we often want to learn something from a training data set and apply the results to testing or production data\n\nfit().transform()","cf279bf2":"## Customize the Transformer\n\nDuring the process of vectorizing the text, we can apply numerous transformations to modify the text and resulting vectors. "}}