{"cell_type":{"027d8123":"code","ade8e56a":"code","98eb38ad":"code","c875b71f":"code","db541db9":"code","6d27f551":"code","b913e658":"code","d3fa2639":"code","098a6a6a":"code","bae35485":"code","bc65e6a1":"code","13dd561e":"code","56b8532e":"code","8ad9fca2":"code","44b5e4fb":"code","01c59f76":"code","87abcafd":"code","e199f18d":"code","46ef6aba":"markdown","cbb83f96":"markdown","55c63e00":"markdown","23d720b0":"markdown","aa8197e1":"markdown"},"source":{"027d8123":"\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","ade8e56a":"import cv2\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt \nimport seaborn as sns\nimport os\nfrom PIL import Image\n\nfrom keras.preprocessing.image import img_to_array\nfrom keras.preprocessing.image import load_img\nfrom keras.utils import np_utils\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.layers import Input, Lambda, Dense, Flatten\nfrom keras.applications.vgg19 import VGG19\nfrom keras.applications.vgg19 import preprocess_input\nfrom keras import metrics\nfrom keras import Model, layers\nfrom keras.callbacks import *\nfrom keras.models import load_model, model_from_json","98eb38ad":"parasitized_data = os.listdir('..\/input\/cell-images-for-detecting-malaria\/cell_images\/Parasitized\/')\nuninfected_data = os.listdir('..\/input\/cell-images-for-detecting-malaria\/cell_images\/Uninfected\/')","c875b71f":"def plotImages(title,directory):\n    print(title)\n    plt.figure(figsize = (12,12))\n    for i in range(25):\n        plt.subplot(5, 5, i+1)\n        img = cv2.imread( directory+ \"\/\" + parasitized_data[i])\n        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)); plt.axis('off')\n        plt.tight_layout()\n    plt.show()\n        \nplotImages(\"Images of malaria infected cells\",\"..\/input\/cell-images-for-detecting-malaria\/cell_images\/Parasitized\") ","db541db9":"def plotImages(title,directory):\n    print(title)\n    plt.figure(figsize = (12,12))\n    for i in range(25):\n        plt.subplot(5, 5, i+1)\n        img = cv2.imread( directory+ \"\/\" + uninfected_data[i])\n        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)); plt.axis('off')\n        plt.tight_layout()\n    plt.show()\n        \nplotImages(\"Images of Uninfected cells\",\"..\/input\/cell-images-for-detecting-malaria\/cell_images\/Uninfected\") ","6d27f551":"workingDir = \"\/kaggle\/input\/cell-images-for-detecting-malaria\"\n\nPATH = os.path.sep.join([workingDir, \"cell_images\"])\n\n# Getting the path ot the training directory \ntrain_dir = os.path.join(PATH, \"cell_images\")\n\n# Getting the path to the validation directory \nvalidation_dir = os.path.join(PATH, \"cell_images\")","b913e658":"# Getting the path to the directory for the parasitized training cell images and \n# the getting the path to the directory for the uninfected training cell images \nparasitized_train_dir = os.path.join(train_dir, \"Parasitized\")\nuninfected_train_dir = os.path.join(train_dir, \"Uninfected\")\n\n# Getting the path to the directory for the parasitized validation cell images and \n# the path to the directory for the uninfected validation cell images \nparasitized_val_dir = os.path.join(validation_dir, \"Parasitized\") \nuninfected_val_dir = os.path.join(validation_dir, \"Uninfected\")","d3fa2639":"# Getting the number of images present in the parasitized training directory and the \n# number of images present in the uninfected training directory \nparasitized_images = len(os.listdir(parasitized_train_dir))\nuninfected_images = len(os.listdir(uninfected_train_dir))\n\n# Getting the number of images present in the parasitized validation directory and the \n# number of images present in the uninfected validation directory \nparasitized_images_val = len(os.listdir(parasitized_val_dir)) \nuninfected_images_val = len(os.listdir(uninfected_val_dir)) \n\n# Getting the sum of both the training images and validation images \ntotal_train = parasitized_images + uninfected_images  \ntotal_val = parasitized_images_val + uninfected_images_val \n\n# Displaying the results for Training images  \nprint(\"Total Training parasitized images: {}\".format(parasitized_images)); \nprint(\"Total Training uninfected images: {}\".format(uninfected_images)); \nprint(\"__________________________________________________________________________________________________________\\n\");\n\n# Displaying the results for Validation images  \nprint(\"Total Validation parasitized images: {}\".format(parasitized_images_val)); \nprint(\"Total Validation uninfected images: {}\".format(uninfected_images_val)); \nprint(\"__________________________________________________________________________________________________________\\n\"); \n\n# Displaying the total values for the images in both the training and validation directory \nprint(\"Total Train: {}\".format(total_train)); \nprint(\"Total Validation: {}\".format(total_val)); ","098a6a6a":"batch_size = 2000\nepochs = 20 \nIMG_HEIGHT = 98 \nIMG_WIDTH = 98 \n\ntrain_datagen = ImageDataGenerator(rescale=1.\/255,\n                                   shear_range = 0.2,\n                                   zoom_range = 0.2,\n                                   horizontal_flip = True)\n\ntrain_generator = train_datagen.flow_from_directory(directory = train_dir,\n                                                    target_size = (IMG_HEIGHT, IMG_WIDTH),\n                                                    batch_size = batch_size,\n                                                    class_mode = 'binary',\n                                                    shuffle = True\n                                                   )\n\nvalidation_datagen = ImageDataGenerator(rescale=1.\/255)\n\nvalidation_generator = validation_datagen.flow_from_directory(directory = validation_dir,\n                                                  target_size = (IMG_HEIGHT, IMG_WIDTH),\n                                                  batch_size = batch_size,\n                                                  class_mode = 'binary',\n                                                  shuffle = True\n                                                 )","bae35485":"# instantiating the VGG19 model\nvgg19 = VGG19(input_shape=[IMG_HEIGHT, IMG_WIDTH] + [3],\n                  weights='imagenet', # include the pre-trained weights on ImageNet\n                  include_top=False)  # to use our own input and get the desired output\n\n# do not train the existing weights\nfor layer in vgg19.layers:\n  layer.trainable = False\n\n# defining input and output to the model\nx = Flatten()(vgg19.output)\nprediction = Dense(1, activation='sigmoid')(x)","bc65e6a1":"# create a model object\nmodel = Model(inputs = vgg19.input, outputs = prediction)\n\n# view the structure of the model\nmodel.summary()","13dd561e":"# tell the model what cost and optimization method to use\n\nmetrics = ['accuracy',\n           metrics.Precision(name='precision'),\n           metrics.Recall(name='recall')\n          ]\n\nmodel.compile(\n  loss='binary_crossentropy',\n  optimizer='adam',\n  metrics=metrics\n)","56b8532e":"# Training the model on the input data by using the fit_generator function \nhistory = model.fit_generator(train_generator, steps_per_epoch = total_train \/\/ batch_size, \n                       epochs = epochs, \n                       validation_data = validation_generator, \n                       validation_steps = total_val \/\/ batch_size) ","8ad9fca2":"def visualize_training(history, lw = 3):\n    plt.figure(figsize=(10,10))\n    plt.subplot(2,1,1)\n    plt.plot(history.history['accuracy'], label = 'training', marker = '*', linewidth = lw)\n    plt.plot(history.history['val_accuracy'], label = 'validation', marker = 'o', linewidth = lw)\n    plt.title('Accuracy Comparison')\n    plt.xlabel('Epochs')\n    plt.ylabel('Accuracy')\n    plt.grid(True)\n    plt.legend(fontsize = 'x-large')\n    \n\n    plt.subplot(2,1,2)\n    plt.plot(history.history['loss'], label = 'training', marker = '*', linewidth = lw)\n    plt.plot(history.history['val_loss'], label = 'validation', marker = 'o', linewidth = lw)\n    plt.title('Loss Comparison')\n    plt.xlabel('Epochs')\n    plt.ylabel('Loss')\n    plt.legend(fontsize = 'x-large')\n    plt.grid(True)\n    plt.show()\n\n\nvisualize_training(history)\n","44b5e4fb":"model_test_performace = model.evaluate(validation_generator)\n","01c59f76":"# Saving the model for further uses \nmodelName = \"MalariaModel.h5\" \nmodel.save_weights(modelName); ","87abcafd":"img = \"\/kaggle\/input\/cell-images-for-detecting-malaria\/cell_images\/cell_images\/Parasitized\"\n\n# Getting the first Four images \nImgDir = list(os.listdir(img)) \nImgDir = ImgDir[:3] \n\n# Loading Just a random image from the Parasitized images folder. \nimagePath = os.path.join(img, \"C99P60ThinF_IMG_20150918_141001_cell_133.png\")\n\n# Displaying the full path to the parasitized image we want to use for prediction. \nprint(imagePath)","e199f18d":"img = cv2.imread(imagePath); \n\n# Setting the dimensions for the loaded image to be converted into and displaying the shape of the image \nprint(\"Loaded Image Shape: {}\".format(img.shape)); \ndim = (IMG_HEIGHT, IMG_WIDTH); \n\n# Resizing the image \nimg = cv2.resize(img, dim, interpolation = cv2.INTER_AREA); \nplt.grid(False) \nplt.imshow(img) \nplt.show() \n\n# Expanding the image dimensions \nimage = np.expand_dims(img, axis = 0); \n\n# Making Final Predictions \nresult = model.predict(image)\n# Creating a loop to get the actual predicted class \nfor key, value in (train_generator.class_indices.items()): \n    if value == result: \n        print(\"The Predicted Class is: {}\".format(key))","46ef6aba":"### What is Malaria?\n\nMalaria is a potentially life-threatening parasitic disease caused by infection with Plasmodium protozoa transmitted by an infective female Anopheles mosquito. Plasmodium falciparum infection carries a poor prognosis with a high mortality if untreated, but it has an excellent prognosis if diagnosed early and treated appropriately.","cbb83f96":"Dataset can be downloaded from here: https:\/\/www.kaggle.com\/iarunava\/cell-images-for-detecting-malaria","55c63e00":"We can clearly observe from images above the difference between the infected and uninfected cells. We can see a small pink colored clot inside the cellular image for infected while for the uninfected the cellular image is clean without any clots.","23d720b0":"![31-researchersm.jpg](attachment:31-researchersm.jpg)","aa8197e1":"# Detection of Malaria from Cell Images"}}