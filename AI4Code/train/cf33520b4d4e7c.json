{"cell_type":{"043fe803":"code","bff36658":"code","0bf88bbf":"code","5284858e":"markdown"},"source":{"043fe803":"! pip install bloom_filter","bff36658":"# import bloom filters\nfrom bloom_filter import BloomFilter\nfrom nltk.util import ngrams\n\n# bloom filter with default # of max elements and \n# acceptable false positive rate\nbloom = BloomFilter(max_elements=1000, error_rate=0.1)\n\n# sample text\ntext = '''The numpy sieve with trial division is actually a pretty fast Python\nimplementation. I've done some benchmarks in the past and saw around of 2-3x or so slower \nthan a similar C++ implementation and less than an order of magnitude slower than C.'''\ntext = text.lower()\n\n# split by word & add to filter\nfor i in text.split():\n    bloom.add(i)\n\n# check if word in filter\n\"sieve\" in bloom ","0bf88bbf":"# bloom filter to store our ngrams in \nbloom_ngram = BloomFilter(max_elements=1000, error_rate=0.1)\n\n# get 5 grams from our text\ntokens = [token for token in text.split(\" \") if token != \"\"]\noutput = list(ngrams(tokens, 5))\n\n# add each 5gram to our bloom filter\nfor i in output:\n    bloom_ngram.add(\" \".join(i))\n\n# check if word in filter\nprint(\"check unigram:\")\nprint(\"sieve\" in bloom_ngram)\n\n# check if ngram in filter\nprint(\"check 5gram:\")\nprint(\"numpy sieve with trial division\" in bloom_ngram)","5284858e":"Bloom filters are memory efficent & fast ways to check if an item appears in a set. It won't return false negatives (item is in set and it says that it isn't) but does have a chance to return a false positive. You can set your tolerance for this with a specific filter using error_rate.\n\nThis kernel has an example of how to create a bloom filter for both unigrams (aka single words) and 5-grams (five words that occur congruently). "}}