{"cell_type":{"f3f7cbbc":"code","24a42170":"code","4fc765b1":"code","94bd9b5b":"code","72b858f2":"code","11c7bc83":"code","8123e57f":"code","4986e0d3":"code","cea83d94":"code","464590a9":"code","aebf575f":"code","6d5ef919":"code","e9068767":"code","f0e938bb":"code","04650b2f":"code","1ae62476":"code","afbf7e5d":"code","e078af1a":"code","e1271d0d":"markdown"},"source":{"f3f7cbbc":"import torch \nimport torchvision\nimport numpy as np \nimport random\nimport os\nimport glob\nimport copy\n\ndef set_seed(seed):\n    random.seed(seed)\n    os.environ[\"PYTHONHASHSEED\"] = str(seed)\n    np.random.seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.manual_seed(seed)\n\nseed = 42\nset_seed(seed)\ndevice = torch.device('cuda:0')","24a42170":"!ls -l \/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/train\/NORMAL | wc -l\n!ls -l \/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/train\/PNEUMONIA | wc -l","4fc765b1":"!ls -l \/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/val\/NORMAL | wc -l\n!ls -l \/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/val\/PNEUMONIA | wc -l","94bd9b5b":"!ls -l \/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/test\/NORMAL | wc -l\n!ls -l \/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/test\/PNEUMONIA | wc -l","72b858f2":"!nvidia-smi","11c7bc83":"class ChestXRay(torchvision.datasets.ImageFolder):\n    def __getitem__(self, index):\n        sample, target = super().__getitem__(index)\n        path, _ = self.samples[index]\n        \n        target = 0\n        if 'bacteria' in path:\n            target = 1\n        elif 'virus' in path:\n            target = 2\n        \n        return sample, target\n       ","8123e57f":"train_transforms = torchvision.transforms.Compose([\n    torchvision.transforms.Resize(256),\n    torchvision.transforms.RandomAffine(0, translate=(0, 0.1), scale=(1, 1.10)),\n    torchvision.transforms.CenterCrop(224),\n    torchvision.transforms.ToTensor(),\n    torchvision.transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n])\n\ntransforms = torchvision.transforms.Compose([\n    torchvision.transforms.Resize(256),\n    torchvision.transforms.CenterCrop(224),\n    torchvision.transforms.ToTensor(),\n    torchvision.transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n])\n\ntrain_dataset = ChestXRay('\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/train', transform=train_transforms)\nval_dataset = ChestXRay('\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/val', transform=transforms)\ntest_dataset = ChestXRay('\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/test', transform=transforms)\n\ntrain_dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=4, shuffle=True)\nval_dataloader = torch.utils.data.DataLoader(val_dataset, batch_size=4, shuffle=False)\ntest_dataloader = torch.utils.data.DataLoader(test_dataset, batch_size=4, shuffle=False)","4986e0d3":"model = torchvision.models.resnet18(pretrained=True)\nmodel.fc = torch.nn.Linear(in_features=512, out_features=3)\nmodel = model.to(device)\nmodel","cea83d94":"def run_epoch(model, dataloader, criterion, optimizer, lr_scheduler, phase='train'):\n    epoch_loss = 0.\n    epoch_acc = 0.\n    \n    batch_num = 0.\n    samples_num = 0.\n    \n    true_labels = []\n    pred_labels = []\n    \n    for batch_idx, (data, labels) in enumerate(dataloader):\n        data, labels = data.to(device), labels.to(device)\n        \n        optimizer.zero_grad()\n        with torch.set_grad_enabled(phase == 'train'):\n            outputs = model(data)\n            _, preds = torch.max(outputs, 1)\n            loss = criterion(outputs, labels)\n        \n        true_labels.append(labels.detach().cpu())\n        pred_labels.append(preds.detach().cpu())\n        \n        if phase == 'train':\n            loss.backward()\n            optimizer.step()\n        \n        print(f'\\r{phase} batch [{batch_idx}\/{len(dataloader)}]: loss {loss.item()}', end='', flush=True)\n        epoch_loss += loss.detach().cpu().item()\n        epoch_acc += torch.sum(preds == labels.data)\n        batch_num += 1\n        samples_num += len(labels)\n    \n    print()\n    return epoch_loss \/ batch_num, epoch_acc \/ samples_num, torch.cat(true_labels).numpy(), torch.cat(pred_labels).numpy()","464590a9":"criterion = torch.nn.CrossEntropyLoss()\noptimizer = torch.optim.SGD(model.parameters(), lr=1e-2, weight_decay=0.001)\nlr_scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=3, verbose=True)","aebf575f":"best_model = None\nbest_loss = 0.\nbest_test_loss = 0.\nbest_test_acc = 0.\nbest_pred_labels = []\ntrue_labels = []\n\npred_labels = []\ntest_acc = 0.\ntest_loss = 0.","6d5ef919":"train_losses = []\nval_losses = []\ntest_losses = []\n\nfor epoch in range(60):\n    print('='*15, f'Epoch: {epoch}')\n    \n    train_loss, train_acc, _, _ = run_epoch(model, train_dataloader, criterion, optimizer, lr_scheduler)\n    val_loss, val_acc, _, _ = run_epoch(model, val_dataloader, criterion, optimizer, lr_scheduler, phase='val')\n    test_loss, test_acc, true_labels, pred_labels = run_epoch(model, test_dataloader, criterion, optimizer, lr_scheduler, phase='test')\n    \n    print(f'Train loss: {train_loss}, Train accuracy: {train_acc}')\n    print(f'Val loss: {val_loss}, Val accuracy: {val_acc}')\n    print(f'Test loss: {test_loss}, Test accuracy: {test_acc}')\n    print()\n    \n    train_losses.append(train_loss)\n    val_losses.append(val_loss)\n    test_losses.append(test_loss)\n    \n    torch.save({'epoch': epoch, 'model': model.state_dict()}, f'resnet34-mooney-chest-x-ray-{seed}.pt')\n    \n    if best_model is None or val_loss < best_loss:\n        best_model = copy.deepcopy(model)\n        best_loss = val_loss\n        best_test_loss = test_loss\n        best_test_acc = test_acc \n        best_pred_labels = pred_labels\n        torch.save({'epoch': epoch, 'model': model.state_dict()}, f'resnet34-mooney-chest-x-ray-best-{seed}.pt')\n        ","e9068767":"import matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()\n\nplt.figure(figsize=(18, 8))\nplt.plot(train_losses, label='Train loss')\nplt.plot(val_losses, label='Val loss')\nplt.plot(test_losses, label='Test loss')\nplt.legend()\nplt.show()","f0e938bb":"print(f'Best model test accuracy: {best_test_acc}')\nprint(f'Best model test loss: {best_test_loss}')\n\nprint(f'Final model test accuracy: {test_acc}')\nprint(f'Final model test loss: {test_loss}')","04650b2f":"from sklearn.metrics import confusion_matrix\n\ncm = confusion_matrix(true_labels, best_pred_labels)\n#tn, fp, fn, tp = cm.ravel()\nax = sns.heatmap(cm, annot=True, fmt=\"d\")","1ae62476":"#recall = tp\/(tp + fn)\n#precision = tp\/((tp + fp))\n#f1_score = 2 * (recall * precision)\/(precision + recall)\n#print(\"Best model F1 Score:\", f1_score)","afbf7e5d":"cm = confusion_matrix(true_labels, pred_labels)\n#tn, fp, fn, tp = cm.ravel()\nax = sns.heatmap(cm, annot=True, fmt=\"d\")","e078af1a":"#recall = tp\/(tp + fn)\n#precision = tp\/((tp + fp))\n#f1_score = 2 * (recall * precision)\/(precision + recall)\n#print(\"Final model F1 Score:\", f1_score)","e1271d0d":"Test with classes [normal, bacteria, virus] instead of just [normal, pneumonia]"}}