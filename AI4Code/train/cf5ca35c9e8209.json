{"cell_type":{"53598235":"code","0b4b7fe0":"code","1336db46":"code","48f80906":"code","8edb01b8":"code","b73b301f":"code","1256053c":"code","119c7bea":"code","7e3a2764":"code","2d8ca775":"code","a4a68e93":"code","0f789545":"code","bb7a488e":"code","2e1c192d":"code","7dd345c4":"code","80014834":"code","78d78007":"code","68e803f5":"code","02ec0001":"code","cb967dbd":"markdown","0e6f6f8d":"markdown","83c173f7":"markdown","07dd26ae":"markdown","b0b5ee9b":"markdown","127695c1":"markdown","25c4978f":"markdown","694fda7d":"markdown","e830edaa":"markdown","525c87d1":"markdown","507683ab":"markdown","9731a49f":"markdown","d6d8a437":"markdown"},"source":{"53598235":"from IPython.display import display, Markdown\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nmpl.use('Agg')\nimport matplotlib.pylab as plt\nimport seaborn as sns\nsns.set()\nsns.set_style(\"whitegrid\")\nsns.set_color_codes()\nfrom os import listdir\nfrom os.path import isfile, join\n\n%matplotlib inline\n\n# Ignore the warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfontdict = {'fontsize':20, 'fontweight':'bold'}\n\nclass KaggleSurvey:\n    \n    def __init__(self):\n        self.__asset_path = \"..\/input\/\"\n        self.__get_dfs()\n        self.__save_dfs()\n        self.__make_q_list()\n    \n    def __get_dfs(self):\n        path = self.__asset_path\n        dict_2018 = {}\n        files = [f for f in listdir(path) if isfile(join(path, f)) and \"csv\" in f]\n        for idx_, file in enumerate(files):\n            file_path = path + file\n            df = pd.read_csv(file_path, encoding=\"ISO-8859-1\")\n            dict_2018[file.split(\".\")[0]] = df\n\n        self.__dict_2018 = dict_2018\n        \n    def __save_dfs(self):\n        q_list = self.__dict_2018[\"multipleChoiceResponses\"].iloc[0].values.tolist()\n        self.__schema_new = pd.concat(\n            [pd.Series(self.__dict_2018[\"multipleChoiceResponses\"].columns), pd.Series(q_list)], 1\n        )\n        self.__multi_18 = self.__dict_2018[\"multipleChoiceResponses\"].iloc[1:].reset_index(drop=True)\n        self.__free_18 = self.__dict_2018[\"freeFormResponses\"].iloc[1:].reset_index(drop=True)\n        cols = self.__dict_2018[\"SurveySchema\"].columns\n        rearrange_cols = [\"Q\" + str(i) for i in range(len(cols))]\n        rearrange_cols[0], rearrange_cols[-1] = cols[0], cols[-1]\n        self.__survey_schema_18 = self.__dict_2018[\"SurveySchema\"][rearrange_cols]\n    \n    def __make_q_list(self):\n        single_choice, multiple_choice = self.__count_single_multiple_choices()\n        q_list, is_single = self.__make_question_list(single_choice, multiple_choice)\n        self.__q_df = pd.DataFrame({\"question\" : pd.Series(q_list), \"is_single\" : pd.Series(is_single)})\n        self.__q_df.index = range(1, 51)\n        # question 12 has unique column name so I'll mark it as single choice question even though it's not.\n        self.__q_df.at[12, 'is_single'] = 1\n    \n    def __count_single_multiple_choices(self):\n        cols = self.__multi_18.columns\n        single_choice = []\n        multiple_choice = []\n        for col in cols[1:]:\n            tmp = col.split(\"_\")\n            if len(tmp) == 1:\n                single_choice.append(col)\n            elif \"Part\" in tmp:\n                if tmp[0] not in multiple_choice:\n                    multiple_choice.append(tmp[0])\n        return single_choice, multiple_choice\n        \n    def __make_question_list(self, single_choice, multiple_choice):\n        tmp_df = self.__schema_new\n        tmp_df.columns = [\"Column\", \"Question\"]\n        tmp_df = tmp_df.set_index(\"Column\")\n        q_list = []\n        q_len = len(single_choice) + len(multiple_choice)\n        is_single_choice_list = []\n        for i in range(q_len):\n            is_single = 1\n            q_txt = \"Q\" + str(i + 1)\n            if q_txt in multiple_choice:\n                q_txt = q_txt + \"_Part_1\"\n                is_single = 0\n            try:\n                q = tmp_df.loc[q_txt][\"Question\"]\n            except:\n                q_txt = q_txt + \"_TEXT\"\n                q = tmp_df.loc[q_txt][\"Question\"]\n            q_list.append(q)\n            is_single_choice_list.append(is_single)\n        return q_list, is_single_choice_list\n\n    def __get_selections_of_multiple_choice_question_as_list(self, number):\n        tmp_df = self.__schema_new\n        tmp_df.columns = [\"Column\", \"Question\"]\n        tmp_df = tmp_df.set_index(\"Column\")\n        tmp_li = [ \n            q_ for q_ in \n            (q for q in tmp_df.index.tolist() if str(number) in q) \n            if str(number) in q_.split(\"_\")[0]\n        ]\n        return tmp_li\n    \n    def __print_question(self, year, col, cols=[], is_survey_schema=False, is_need_result = False):\n#         if is_survey_schema:\n#             tmp_df = pd.read_csv(self.__asset_path + \"surveySchema_18.csv\")\n#             print(tmp_df[col].iloc[0])\n#             return \n        dir_name = \"kaggle-survey-\"\n        tmp_df = pd.DataFrame([])\n        result = \"\"\n        tmp_df = self.__schema_new\n        tmp_df.columns = [\"Column\", \"Question\"]\n        tmp_df = tmp_df.set_index(\"Column\")\n        result = tmp_df.loc[col][\"Question\"]\n        if is_need_result:\n            return result\n        else:\n            print(col)\n            if len(cols) == 0:\n                print(result)\n        \n    def __get_order_li(self, df, q, question_number):\n        return [str_ for str_ in df[q].unique().tolist() if type(str_) != float]\n    \n    def __get_ax(self, ax, idx, plot_cols, depth_of_dfs):\n        ax_ = None\n        if plot_cols == 1:\n            ax_ = ax[idx] \n        elif plot_cols > 1:\n            ax_ = ax[idx \/\/ plot_cols, idx % plot_cols] if depth_of_dfs > 1 else ax[idx % plot_cols]\n        else:\n            print(\"wrong plot_cols.\")\n        return ax_\n        \n    def __per_df(self, series) :\n        val_cnt = series.values.sum()\n        return series \/ val_cnt\n    \n    def __per_df_single(self, df, col, order_li):\n        series = pd.Series(index = order_li)\n        idx_li = df[col].value_counts().index.tolist()\n        for idx in idx_li:\n            series.at[idx] = df[col].value_counts().loc[idx]\n        return series \/ series.sum()\n    \n    def get_question(self, number, is_need_display_order = False):\n        \"\"\"\n            print the question \n            number : Insert the number of question.\n        \"\"\"\n        df = self.__q_df\n        tmp = df.loc[number]\n        if tmp[\"is_single\"] == 1:\n            q = tmp[\"question\"]\n            print(\"Q\" +str(number) + \".\", df.loc[number][\"question\"])\n        else:\n            tmp_li = self.__get_selections_of_multiple_choice_question_as_list(number)\n            display_order = []\n            for idx, q in enumerate(tmp_li):\n                if \"_OTHER_TEXT\" not in q:                \n                    q_ = self.__print_question(2018, q, is_need_result=True).split(\" - \")\n                    display_order.append(q_[-1].strip())\n                    if idx == 0:\n                        print(q.split(\"_\")[0] + \".\", q_[0])\n                        print(\" \", str(idx + 1) + \".\", q_[-1])\n                    else:\n                        print(\" \", str(idx + 1) + \".\", q_[-1])\n            if is_need_display_order:\n                return display_order\n    \n    def get_q_df(self):\n        \"\"\"\n            return dataframe of survey questions, columns = [\"is_single_choice\", \"question\"]\n        \"\"\"\n        return self.__q_df\n    \n    def get_multiple_choice_responses(self):\n        \"\"\"\n            return multipleChoiceResponses dataframe\n        \"\"\"\n        return self.__multi_18\n    \n    def get_free_form_responses(self):\n        \"\"\"\n            return freeFormResponses dataframe\n        \"\"\"\n        return self.__free_18\n\n    def get_survey_schema(self):\n        \"\"\"\n            return SurveySchema dataframe\n        \"\"\"\n        return self.__survey_schema_18\n    \n    def get_df_saved_in_object(self):\n        \"\"\"\n            return dictionary of dataframes saved in object\n        \"\"\"\n        return self.__dfs\n    \n    def get_df_I_want_by_country_name(self, country, is_false = False):\n        \"\"\"\n            return the dataset of certain ountry\n            country : Insert the country name\n        \"\"\"\n        df = self.__multi_18.copy()\n        col = \"Q3\"\n        countrie_names = df[col].unique().tolist()\n        if country not in countrie_names:\n            print(\"Wrong country name. You can only insert the one of names below.\")\n            print(countrie_names)\n            return\n                \n        return df[df[col] != country] if is_false else df[df[col] == country]\n    \n    def set_df_I_want_by_country_name(self, countries = [], is_need_total = False):\n        \"\"\"\n            To set dictionary of dataframe in the object. This way you can maintain your code more easier.\n            contries : Insert the list of country names\n                example:) [\"Korea\", \"China\", \"India\" ... ]\n            is_need_total : True if you want the full dataset to be in inside of object \n        \"\"\"\n        \n        keys = []\n        values = []\n        if is_need_total:\n            keys.append(\"Total\")\n            values.append(self.__multi_18)\n            \n        countrie_names = self.__multi_18[\"Q3\"].unique().tolist()\n        for country in countries:\n            if country not in countrie_names:\n                print(\"Wrong country name. You can only insert the one of names below.\")\n                print(countrie_names)\n                break\n            df = self.get_df_I_want_by_country_name(country)\n            keys.append(country)\n            values.append(df)\n                                \n        self.__dfs = dict(zip(keys, values))\n\n    def save_csv(self, df, filename, index=False):\n        df.to_csv(self.__asset_path + filename, index = index)\n        \n    def draw_plot(self, question_number, plot_cols = 3, dfs_ = {}, is_need_number_of_respondents = False, order = [], \n                  is_use_the_same_y_lim = True, ylim_offset = 0.1):\n        \"\"\"\n            question_number : Insert the number of question\n            plot_cols : Insert the number of plot's columns, default 3\n            dfs_ : Insert the dictionary of dataframes.\n                Example:) dfs_ = {\n                    \"US\" : ks.get_df_I_want_by_country_name('United States of America'),\n                    'India' : ks.get_df_I_want_by_country_name('India'),\n                    'China' : ks.get_df_I_want_by_country_name('China')\n                }\n            order : Insert the order of xticks.\n            is_use_the_same_y_lim : True\n            ylim_offset : 0.1 (it means 10%)\n        \"\"\"\n        \n        dfs_keys = []\n        dfs = []\n        if len(dfs_) != 0:\n            dfs_keys = list(dfs_.keys())\n            dfs = dfs_.values()\n        elif len(self.__dfs) != 0:\n            dfs_keys = list(self.__dfs.keys())\n            dfs = self.__dfs.values()\n        else:\n            print(\"Insert the dataset or set the dataset into object using set_df_I_want_by_country_name\")\n        \n        is_single_choice_question = self.__q_df.loc[question_number][\"is_single\"]\n        \n        length_of_dfs = len(dfs)\n        depth_of_dfs = int(np.ceil(length_of_dfs \/ float(plot_cols)))\n        if question_number != 3:\n            f, ax = plt.subplots(depth_of_dfs, plot_cols, figsize=(5 * length_of_dfs, 5 * depth_of_dfs))\n        \n        if is_single_choice_question:\n            if question_number == 12:\n                display(Markdown(\"<span style='color: red'>Multiple Choice Question.<\/span>\"))\n            else:\n                display(Markdown(\"<span style='color: red'>Single Choice Question.<\/span>\"))\n            self.get_question(question_number)\n            if question_number == 3:\n                len_li = [len(df) for df in dfs]\n                plt.bar(dfs_keys, len_li)\n                \n            else:        \n                q = \"Q\" + str(question_number) + \"_MULTIPLE_CHOICE\" if question_number == 12 else \"Q\" + str(question_number)\n\n\n                if is_use_the_same_y_lim:\n                    max_value = 0\n                    for df in dfs:\n                        ncount = len(df)\n                        tmp = df.groupby(q).size().values\/ncount\n                        tmp_max_value = (tmp.max() + ylim_offset)\n                        max_value = tmp_max_value if tmp_max_value > max_value else max_value\n                \n                order_li = []\n                print(\"The answers from left to right : \")\n                \n                for idx, df in enumerate(dfs):\n                    \n                    if idx == 0:\n                        if len(order) != 0:\n                            order_li = order\n                        else:\n                            order_li = self.__get_order_li(self.__multi_18, q, question_number)\n                    \n                    ax_ = self.__get_ax(ax, idx, plot_cols, depth_of_dfs)\n                    \n                    self.__per_df_single(df, q, order_li).plot.bar(ax = ax_)\n                    \n                    for p in ax_.patches:\n                        ax_.annotate(str(round(p.get_height() * 100, 2)) + \"%\", (p.get_x() + p.get_width()\/2., p.get_height()), ha='center', va='center', xytext=(0, 10), textcoords='offset points')\n                        \n                    ax_.set_xticklabels(list(range(1, len(order_li) + 1)), rotation=0)\n                    if is_need_number_of_respondents:\n                        ax_.set_title(dfs_keys[idx] + \" (\" + str(len(df)) + \")\", fontdict = fontdict)\n                    else:\n                        ax_.set_title(dfs_keys[idx], fontdict = fontdict)\n\n                    if is_use_the_same_y_lim:\n                        ax_.set_ylim(0, max_value)\n                        \n                for idx, answer in enumerate(order_li):\n                    print(idx + 1, answer)\n                plt.show()\n                \n        else:\n            display(Markdown(\"<span style='color: red'>Multiple Choice Question.<\/span>\"))\n            answers = self.get_question(question_number, is_need_display_order=True)\n            cols = [\n                q for q in self.__get_selections_of_multiple_choice_question_as_list(question_number) if \"_OTHER_TEXT\" not in q\n            ] \n            order_li = []\n            result_dfs = []\n            # 34, 35 answers must add up to 100%\n            if question_number == 34 or question_number == 35:\n                if is_use_the_same_y_lim:\n                    max_value = 0\n                    for df in dfs:\n                        for col in cols:\n                            mean_max = df[cols].astype(float).mean().max()\n                            tmp_max_value = (mean_max + ylim_offset * 100)\n                            max_value = tmp_max_value if tmp_max_value > max_value else max_value\n                \n                for idx, df in enumerate(dfs):\n                    ax_ = self.__get_ax(ax, idx, plot_cols, depth_of_dfs)\n                    sns.barplot(data = df[cols], ax = ax_)\n                    ax_.set_xticklabels(list(range(1, len(df.columns) + 1)), rotation = 0)\n                    if is_need_number_of_respondents:\n                        ax_.set_title(dfs_keys[idx] + \" (\" + str(len(df[cols])) + \")\", fontdict = fontdict)\n                    else:\n                        ax_.set_title(dfs_keys[idx], fontdict = fontdict)\n                    if is_use_the_same_y_lim:\n                        ax_.set_ylim(0, max_value)\n            else:\n                for idx, df in enumerate(dfs):\n                    x_li = []\n                    y_li = []\n                    for i, col in enumerate(cols):\n                        uq_li = df[col].unique().tolist()\n                        if len(uq_li) > 1:\n                            if str(uq_li[0]) == \"nan\":\n                                y_li.append(uq_li[1])\n                                x_li.append(len(df[df[col] == uq_li[1]]))\n                            else:\n                                y_li.append(uq_li[0])\n                                x_li.append(len(df[df[col] == uq_li[0]]))\n                        else:\n                            y_li.append(answers[i])\n                            x_li.append(0)\n                    result_dfs.append(pd.Series(x_li, y_li))\n                    if len(order_li) == 0:\n                        order_li = y_li\n\n                if is_use_the_same_y_lim:\n                    max_value = 0\n                    for df in result_dfs:\n                        tmp = df\/df.sum()\n                        tmp_max_value = (tmp.max() + ylim_offset)\n                        max_value = tmp_max_value if tmp_max_value > max_value else max_value\n\n                for idx, df in enumerate(result_dfs):\n                    if idx == 0:\n                        if len(order) != 0:\n                            order_li = order\n                    ax_ = self.__get_ax(ax, idx, plot_cols, depth_of_dfs)\n                    self.__per_df(df).plot.bar(ax = ax_)\n                    for p in ax_.patches:\n                        ax_.annotate(str(round(p.get_height() * 100, 2)) + \"%\", (p.get_x() + p.get_width()\/2., p.get_height()), ha='center', va='center', xytext=(0, 10), textcoords='offset points')\n                    ax_.set_xticklabels(list(range(1, len(order_li) + 1)), rotation = 0)\n                    if is_need_number_of_respondents:\n                        ax_.set_title(dfs_keys[idx] + \" (\" + str(df.values.sum()) + \")\", fontdict = fontdict)\n                    else:\n                        ax_.set_title(dfs_keys[idx], fontdict = fontdict)\n                    if is_use_the_same_y_lim:\n                        ax_.set_ylim(0, max_value)\n                plt.show()","0b4b7fe0":"ks = KaggleSurvey()\nks_ = KaggleSurvey()","1336db46":"ks.set_df_I_want_by_country_name([\"If you insert the country name not in the dataset\"])","48f80906":"ks.set_df_I_want_by_country_name([\"United States of America\", \"India\", \"China\"], is_need_total=True)\nks_.set_df_I_want_by_country_name([\"South Korea\", \"Germany\", \"Mexico\", \"Italy\", \"Egypt\", \"Canada\"])","8edb01b8":"ks.draw_plot(question_number=1, plot_cols=4, is_need_number_of_respondents=True)","b73b301f":"ks_.draw_plot(question_number=1)","1256053c":"ks.draw_plot(question_number=9, plot_cols=2)","119c7bea":"q9_order = [\n    '0-10,000',\n    '10-20,000',\n    '20-30,000',\n    '30-40,000',\n    '40-50,000',\n    '50-60,000',\n    '60-70,000',\n    '70-80,000',\n    '80-90,000',\n    '90-100,000',\n    '100-125,000',\n    '125-150,000',\n    '150-200,000',\n    '200-250,000',\n    '250-300,000',\n    '300-400,000',\n    '400-500,000',\n    '500,000+',\n    'I do not wish to disclose my approximate yearly compensation'\n]","7e3a2764":"ks.draw_plot(question_number=9, plot_cols=2, order=q9_order)","2d8ca775":"ks.draw_plot(question_number=18, plot_cols=2)","a4a68e93":"ks.draw_plot(question_number=18, plot_cols=2, ylim_offset=0.2)","0f789545":"ks.draw_plot(question_number=28, plot_cols=1, ylim_offset=0.3)","bb7a488e":"ks.draw_plot(question_number=34, plot_cols=4)","2e1c192d":"ks.draw_plot(question_number=35, plot_cols=4)","7dd345c4":"US = ks.get_df_I_want_by_country_name(\"United States of America\")","80014834":"US_MALE = US[US[\"Q1\"] == \"Male\"]\nUS_FEMALE = US[US[\"Q1\"] == \"Female\"]","78d78007":"dfs = {\n    \"US_Total\" : US,\n    \"US_Male\" : US_MALE,\n    \"US_Female\" : US_FEMALE\n}","68e803f5":"ks_new = KaggleSurvey()","02ec0001":"ks_new.draw_plot(35, dfs_ = dfs, ylim_offset=0.2)","cb967dbd":"#### Every graphs represents percentages except question 34, 35.","0e6f6f8d":"## 1. Set the dataset","83c173f7":"## 2. Plot a graph","07dd26ae":"#### You can set the ylim offset when the max values exceeded ylim of the graph like below.","b0b5ee9b":"## And there is another way to use this class!! let's take a look.","127695c1":"#### If there are too many choices like question number 28, you can set 1 to plot_cols.  ","25c4978f":"#### Hey guys, I want to introduce the class I made. I hope it can help you to do some dog works.\nSome part of this article might not be crystal clear because of my poor English. However, it could be very useful if you want to compare how the answers were distributed on each country by plotting them on the graph. Basically that's what this calss can do! so without further ado, let's get into it!","694fda7d":"Copy and paste the codes hide below if you want to use it. :)","e830edaa":"## That was it. it's pretty easy to use! :) \n## I hope you find this helpful! \n## Please leave a comment and let me know what you think!","525c87d1":"#### Boxplot was used on question 34, 35 ","507683ab":"## Initialize object","9731a49f":"#### Parameters : \n- question_number : Insert the number of question\n- plot_cols : Insert the number of plot's columns, default 3\n- dfs_ : Insert the dictionary of dataframes. \n    Example:) dfs_ = {\n        \"US\" : ks.get_df_I_want_by_country_name('United States of America'),\n        'India' : ks.get_df_I_want_by_country_name('India'),\n        'China' : ks.get_df_I_want_by_country_name('China')\n    }\n- order : Insert the order of xticks.\n- is_use_the_same_y_lim : True\n- ylim_offset : 0.1 (it means 10%)\n- is_need_number_of_respondents : False","d6d8a437":"## Question like below, you can set the order of xticks."}}