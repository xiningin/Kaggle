{"cell_type":{"96d9ff23":"code","dec40bbb":"code","17ad5a9a":"code","fb02ef7d":"code","95792ce8":"code","bc0d13f0":"code","b2f524e2":"code","23b039e3":"markdown"},"source":{"96d9ff23":"import pandas as pd\nimport numpy as np\nfrom scipy.spatial.distance import cosine\npd.__version__","dec40bbb":"# custom functions for DataFrame.corr() are only available in pandas>=0.24.0, define a method based on the pandas implementation in 0.24.0\nfrom pandas.core.dtypes.common import _ensure_float64 as ensure_float64\n\nfrom pandas.core import nanops\nfrom pandas import DataFrame\nimport numpy as np\n\ndef corr(df1, method, min_periods=1):\n    numeric_df = df1._get_numeric_data()\n    cols = numeric_df.columns\n    idx = cols.copy()\n    mat = numeric_df.values\n\n    if callable(method):\n        if min_periods is None:\n            min_periods = 1\n        mat = ensure_float64(mat).T\n        K = len(cols)\n        correl = np.empty((K, K), dtype=float)\n        mask = np.isfinite(mat)\n        for i, ac in enumerate(mat):\n            for j, bc in enumerate(mat):\n                if i > j:\n                    continue\n\n                valid = mask[i] & mask[j]\n                if valid.sum() < min_periods:\n                    c = np.nan\n                elif i == j:\n                    c = 1.\n                elif not valid.all():\n                    c = corrf(ac[valid], bc[valid])\n                else:\n                    c = method(ac, bc)\n                correl[i, j] = c\n                correl[j, i] = c\n    return DataFrame(correl, index=idx, columns=cols)","17ad5a9a":"df = pd.read_hdf('..\/input\/painting-to-vector-encoding\/df_with_vectors.h5', key='vectors')","fb02ef7d":"df.head()","95792ce8":"sample = df.sample(30)\nsample.index = sample['file']\nvalues = sample['vector'].apply(lambda x: pd.Series(x)).T","bc0d13f0":"from scipy.spatial.distance import cosine\nimport seaborn as sns\nimport matplotlib.image as mpimg\nimport matplotlib.pyplot as plt\n\nsimilarity = lambda x, y: cosine(x, y)+1\nsimilarity_matrix = corr(values, similarity)\nplt.figure(figsize=(14,14))\nsns.heatmap(similarity_matrix, cmap='BuGn_r')","b2f524e2":"import os\n\ndef plot_top_n_similar_imgs(series, n=3):\n    similar_imgs = series.sort_values(ascending=True)[:n+1]\n    fig, ax = plt.subplots(1, n+1)\n    fig.set_size_inches(h=12, w=14)\n    for idx, (file, score) in enumerate(similar_imgs.items()):\n        ax[idx].imshow(mpimg.imread(file.replace('..\/input\/', '..\/input\/best-artworks-of-all-time\/')))\n        ax[idx].set_title(\"{}:\\n{:.2f}\".format(file.split('\/')[-1], score))\n\n\n_ = similarity_matrix.apply(plot_top_n_similar_imgs, axis=1)\n","23b039e3":"## Can we determine painting similarity using vector representations from an artist classification model?\n\nThe artist classification model in https:\/\/www.kaggle.com\/roccoli\/vector-encoding stores vector representations for paintings in this dataset.\nLet's see if similarity of these vectors translates to visual similarity of the original paintings.\nAssuming that every artist has a somewhat unique style, we should be able to find paintings with similar style, rather than similar content."}}