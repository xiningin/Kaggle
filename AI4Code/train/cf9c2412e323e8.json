{"cell_type":{"ad5dd104":"code","89cd93a8":"code","13355d35":"code","643db57d":"code","9e25d83c":"code","6ace2dbc":"code","3d733436":"code","bc77c971":"code","9a3b34f3":"code","82ee835c":"code","29e40e15":"code","61c68f05":"code","51ee59c3":"code","4f382595":"code","87bc075b":"code","06f909e4":"code","b79d4706":"code","eea59d15":"code","0051b167":"code","2cef79a8":"code","f2d4926f":"code","18e5ee4e":"code","3c6cfb3b":"code","9ea5ee03":"code","7268873c":"markdown","b05f8529":"markdown","4ba70f12":"markdown","823be558":"markdown","274c13c5":"markdown","4ad9107f":"markdown","679b6e03":"markdown","4757b975":"markdown","9e7c02b5":"markdown","5a9f5686":"markdown"},"source":{"ad5dd104":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport tensorflow as tf\nfrom tensorflow import keras\nimport librosa as lb\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import figure\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","89cd93a8":"hbnet=keras.models.load_model('..\/input\/part-3-feature-extraction-modeling-95-acc\/hbNet')\noneD=keras.models.load_model('..\/input\/1dnet-for-rdd\/1Dnet')\nunTuned=keras.models.load_model('..\/input\/hbnet-untuned-for-rdd\/\/hbNet_unTuned\/')","13355d35":"hbnet.compile(\n    loss=keras.losses.SparseCategoricalCrossentropy(),\n    optimizer='nadam',\n    metrics=['sparse_categorical_accuracy']\n)\n\noneD.compile(\n    loss=keras.losses.SparseCategoricalCrossentropy(),\n    optimizer='nadam',\n    metrics=['sparse_categorical_accuracy']\n)\n\nunTuned.compile(\n    loss=keras.losses.SparseCategoricalCrossentropy(),\n    optimizer='nadam',\n    metrics=['sparse_categorical_accuracy']\n)","643db57d":"from sklearn.preprocessing import LabelEncoder\n\ntrain=pd.read_csv('..\/input\/part-2-handel-imbalance-creating-spectrogram\/train.csv')\nval=pd.read_csv('..\/input\/part-2-handel-imbalance-creating-spectrogram\/val.csv')\n                  \nytrain=train.disease\nyval=val.disease\n                  \nle=LabelEncoder()\nytrain=le.fit_transform(ytrain)\nyval=le.transform(yval)","9e25d83c":"def getFeatures_net(path):\n    soundArr,sample_rate=lb.load(path)\n    mfcc=lb.feature.mfcc(y=soundArr,sr=sample_rate)\n    cstft=lb.feature.chroma_stft(y=soundArr,sr=sample_rate)\n    mSpec=lb.feature.melspectrogram(y=soundArr,sr=sample_rate)\n\n    return mfcc,cstft,mSpec\n\nroot='..\/input\/part-1-preprocessing\/processed_audio_files\/'\nmfcc,cstft,mSpec=[],[],[]\n\nfor idx,row in val.iterrows():\n    path=root + row['filename']\n    a,b,c=getFeatures_net(path)\n    mfcc.append(a)\n    cstft.append(b)\n    mSpec.append(c)\n    \nmfcc_val=np.array(mfcc)\ncstft_val=np.array(cstft)\nmSpec_val=np.array(mSpec)","6ace2dbc":"def getFeatures_oneD(path):\n    soundArr,sample_rate=lb.load(path)\n    mfcc=np.mean(lb.feature.mfcc(y=soundArr,sr=sample_rate,n_mfcc=40),axis=0)\n    cstft=np.mean(lb.feature.chroma_stft(y=soundArr,sr=sample_rate,n_chroma=24),axis=0)\n    mSpec=np.mean(lb.feature.melspectrogram(y=soundArr,sr=sample_rate),axis=0)\n    tonnetz=np.mean(lb.feature.tonnetz(y=soundArr,sr=sample_rate),axis=0)\n    specCetroid=np.mean(lb.feature.spectral_centroid(y=soundArr,sr=sample_rate),axis=0)\n\n    return [mfcc,cstft,mSpec,tonnetz,specCetroid]\n\nroot='..\/input\/part-1-preprocessing\/processed_audio_files\/'\nvalFeatures=[]\ni=0\nfor idx,row in val.iterrows():\n    path=root + row['filename']\n    X=np.array(getFeatures_oneD(path))\n    valFeatures.append(X.T)\n\nvalFeatures=np.array(valFeatures)","3d733436":"hbnet.evaluate({\"mfcc\":mfcc_val,\"croma\":cstft_val,\"mspec\":mSpec_val},yval)","bc77c971":"oneD.evaluate(valFeatures,yval)","9a3b34f3":"unTuned.evaluate({\"mfcc\":mfcc_val,\"croma\":cstft_val,\"mspec\":mSpec_val},yval)","82ee835c":"yprob_hbnet=hbnet.predict({\"mfcc\":mfcc_val,\"croma\":cstft_val,\"mspec\":mSpec_val})\nytrue_hbnet = yprob_hbnet.argmax(axis=-1)","29e40e15":"ytrue_oneD=oneD.predict_classes(valFeatures)\nyprob_oneD=oneD.predict_proba(valFeatures)","61c68f05":"yprob_unTuned=unTuned.predict({\"mfcc\":mfcc_val,\"croma\":cstft_val,\"mspec\":mSpec_val})\nytrue_unTuned = yprob_unTuned.argmax(axis=-1)","51ee59c3":"from sklearn.metrics import precision_score,recall_score,f1_score","4f382595":"print('Precision: ',precision_score(yval,ytrue_hbnet,average='weighted'))\nprint('Recall:    ',recall_score(yval,ytrue_hbnet,average='weighted'))\nprint('F1 Score:  ',f1_score(yval,ytrue_hbnet,average='weighted'))","87bc075b":"print('Precision: ',precision_score(yval,ytrue_oneD,average='weighted'))\nprint('Recall:    ',recall_score(yval,ytrue_oneD,average='weighted'))\nprint('F1 Score:  ',f1_score(yval,ytrue_oneD,average='weighted'))","06f909e4":"print('Precision: ',precision_score(yval,ytrue_unTuned,average='weighted'))\nprint('Recall:    ',recall_score(yval,ytrue_unTuned,average='weighted'))\nprint('F1 Score:  ',f1_score(yval,ytrue_unTuned,average='weighted'))","b79d4706":"from sklearn.metrics import roc_curve, auc,roc_auc_score\nfrom sklearn.preprocessing import label_binarize","eea59d15":"yval_b = label_binarize(yval, classes=[0, 1, 2, 3, 4, 5, 6, 7])","0051b167":"n_classes=8\nfpr = dict()\ntpr = dict()\nroc_auc = dict()\nfor i in range(n_classes):\n    fpr[i], tpr[i], _ = roc_curve(yval_b[:, i], yprob_hbnet[:, i])\n    roc_auc[i] = auc(fpr[i], tpr[i])","2cef79a8":"lw = 2\nfigure(num=None, figsize=(15, 6), dpi=100, facecolor='w', edgecolor='k')\nfor i in range(n_classes):\n    plt.plot(fpr[i], tpr[i],lw=lw, label='ROC (class= %d) (area = %0.2f)' % (i,roc_auc[i]))\nplt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('Receiver Operator Characteristics')\nplt.legend(loc=\"lower right\")\nplt.show()","f2d4926f":"n_classes=8\nfpr = dict()\ntpr = dict()\nroc_auc = dict()\nfor i in range(n_classes):\n    fpr[i], tpr[i], _ = roc_curve(yval_b[:, i], yprob_oneD[:, i])\n    roc_auc[i] = auc(fpr[i], tpr[i])","18e5ee4e":"lw = 2\nfigure(num=None, figsize=(15, 6), dpi=100, facecolor='w', edgecolor='k')\nfor i in range(n_classes):\n    plt.plot(fpr[i], tpr[i],lw=lw, label='ROC (class= %d) (area = %0.2f)' % (i,roc_auc[i]))\nplt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('Receiver Operator Characteristics')\nplt.legend(loc=\"lower right\")\nplt.show()","3c6cfb3b":"n_classes=8\nfpr = dict()\ntpr = dict()\nroc_auc = dict()\nfor i in range(n_classes):\n    fpr[i], tpr[i], _ = roc_curve(yval_b[:, i], yprob_unTuned[:, i])\n    roc_auc[i] = auc(fpr[i], tpr[i])","9ea5ee03":"lw = 2\nfigure(num=None, figsize=(15, 6), dpi=100, facecolor='w', edgecolor='k')\nfor i in range(n_classes):\n    plt.plot(fpr[i], tpr[i],lw=lw, label='ROC (class= %d) (area = %0.2f)' % (i,roc_auc[i]))\nplt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('Receiver Operator Characteristics')\nplt.legend(loc=\"lower right\")\nplt.show()","7268873c":"# Comapring Metrics","b05f8529":"# Evaluating Models","4ba70f12":"* oneD","823be558":"* hbnet","274c13c5":"**Reciver Operator Characterstics**","4ad9107f":"* oneD","679b6e03":"* hbNet","4757b975":"# Loading and Preprocessing Data","9e7c02b5":"# Loading Models","5a9f5686":"* unTuned"}}