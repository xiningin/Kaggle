{"cell_type":{"7c29bbf7":"code","0fbe4edf":"code","16fc2d91":"code","4992f997":"code","91abc504":"code","3af73807":"code","236991f6":"code","1ea9f7f6":"code","ac5f60fc":"code","89ed5740":"code","faf3746d":"markdown","b36a221f":"markdown","9cfe7e5c":"markdown","a5933304":"markdown","c5a7d39c":"markdown","9a509fb3":"markdown","57380643":"markdown","15b14d96":"markdown"},"source":{"7c29bbf7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","0fbe4edf":"ds = pd.read_csv('..\/input\/citibike-system-data\/201306-citibike-tripdata.csv')\nds.head()","16fc2d91":"start = ds.groupby(['start station id', 'starttime', 'start station name', 'start station latitude',\n                    'start station longitude'])\\\n          .size().reset_index(name='counts')\nstart = start.sort_values(['start station id', 'starttime'])\nstart.head()","4992f997":"end = ds.groupby(['end station id', 'stoptime', 'end station name', 'end station latitude', 'end station longitude'])\\\n        .size().reset_index(name='counts')\nend = end.sort_values(['end station id', 'stoptime'])\nend.head()","91abc504":"start['counts'] = -start['counts']\nstart.head()","3af73807":"end['end station id'] = end['end station id'].astype('int64')\nend.head()","236991f6":"start = start.rename(columns={\"start station id\":\"station id\", \"starttime\":\"time\", \"start station name\":\"station name\",\n                              \"start station latitude\":\"station latitude\", \"start station longitude\":\"station longitude\"})\nend = end.rename(columns={\"end station id\":\"station id\", \"stoptime\":\"time\", \"end station name\":\"station name\",\n                          \"end station latitude\":\"station latitude\", \"end station longitude\":\"station longitude\"})\nU = start.append(end)\nU.head()","1ea9f7f6":"U = U.sort_values(['station id', 'time'])\nU.head()","ac5f60fc":"U['counts'] = U.groupby('station id')['counts'].cumsum()\nU = U.rename(columns={\"counts\":\"availability\"})\nU.head()","89ed5740":"output = U\noutput.to_csv('CitiBike System Data Stations.csv', index=False)","faf3746d":"As we know the latitude and longitude for each station $s$, we can express $U$ as\n$$U(s,t)=U(x,y,t)$$\nwhere $x,y$ are the geographical coordinates of station $s$.","b36a221f":"As *departures* and *arrivals* now have the same structure, we rename the corresponding columns to common names and append the dataframes.","9cfe7e5c":"We group by station and sort by time (ascending).","a5933304":"We convert each value to its opposite as this will help with later calculations (remember the definition of $U$).","c5a7d39c":"We create a dataframe about $Arrivals(s,t)$ for each station $s$ and time $t$, grouped by station and sorted by time (ascending).","9a509fb3":"Define the *availability* $U(s,t)$ of a station $s$ at a moment in time $t$ as\n* $$U(s,0)=0, \\forall s$$\n* $$U(s,t)=U(s,t-\\delta t)+Arrivals(s,t)-Departures(s,t), \\forall s, \\forall t>0$$\nwhere\n* $Arrivals(s,t)$ is the number of observations with *end station* $s$ and *stoptime* $t$\n* $Departures(s,t)$ is the number of observations with *start station* $s$ and *starttime* $t$","57380643":"We create a dataframe about $Departures(s,t)$ for each station $s$ and time $t$, grouped by station and sorted by time (ascending).","15b14d96":"We calculate the *availability* column as the running sum for each station. (Remember that *departures* were stored as their opposites)"}}