{"cell_type":{"06e13b86":"code","f027249a":"code","8810740a":"code","a4f0c706":"code","25116c8b":"code","4c6f1953":"code","2ddc375b":"code","2f3c63ce":"code","aa463a1c":"code","8d3b3e4b":"code","dad485a2":"code","49867d75":"code","888af5d3":"code","34c44bf6":"code","7ea87916":"code","25bf60e4":"code","ee403f6f":"code","d2dd8a59":"code","d3bf07a0":"code","fb71ae30":"code","0217047f":"code","5fc98193":"code","04b16861":"code","8e36acd7":"code","17342b95":"code","65761111":"code","2cd0e98f":"code","a1b9e8ce":"code","32235266":"code","678b09d9":"code","0411d3b2":"code","f6022310":"code","7544b901":"code","8cb7e4a8":"code","8750b0ff":"code","71e7006d":"code","43617490":"code","6fd9f5cd":"markdown","aa06e4ec":"markdown","70351d0a":"markdown","eab5dc00":"markdown"},"source":{"06e13b86":"%%capture\n!python -m spacy download en\n!python -m spacy download de","f027249a":"import os\nimport re\nimport time\nimport math\nimport random\nimport unicodedata\n\nimport numpy as np\nimport pandas as pd\n\nfrom tqdm import tqdm\n\nimport spacy\n\nfrom sklearn.model_selection import train_test_split\n\nimport torch\nfrom torch import nn, optim\nfrom torch.nn.utils.rnn import pad_sequence\nfrom torch.utils.data import DataLoader, Dataset\nimport torch.nn.functional as F\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker","8810740a":"SEED = 28\n\nrandom.seed(SEED)\nnp.random.seed(SEED)\ntorch.manual_seed(SEED)\ntorch.cuda.manual_seed(SEED)\ntorch.backends.cudnn.deterministic = True","a4f0c706":"data_df = pd.read_csv('..\/input\/english-to-german\/deu.txt', sep='\\t', usecols=[0, 1])\ndata_df.columns = ['en', 'de']\ndata_df.head()","25116c8b":"data_df.shape","4c6f1953":"plt.figure(figsize=(12, 6))\nplt.style.use('ggplot')\nplt.subplot(1, 2, 1)\nsns.distplot(data_df['en'].str.split().apply(len))\nplt.title('Distribution of English sentences length')\nplt.xlabel('Length')\n\nplt.style.use('ggplot')\nplt.subplot(1, 2, 2)\nsns.distplot(data_df['de'].str.split().apply(len))\nplt.title('Distribution of German sentences length')\nplt.xlabel('Length')\nplt.show()","2ddc375b":"seq_len_en = 20\nseq_len_de = 20","2f3c63ce":"train_df, valid_df = train_test_split(data_df, test_size=0.1, shuffle=True, random_state=28)\n\ntrain_df = train_df.reset_index(drop=True)\nvalid_df = valid_df.reset_index(drop=True)\n\nprint(train_df.shape)\nprint(valid_df.shape)","aa463a1c":"for i in range(len(train_df)-5, len(train_df)):\n    print(f'ENGLISH:\\n{train_df.iloc[i][\"en\"]},\\nGERMAN:\\n{train_df.iloc[i][\"de\"]}\\n{\"=\"*92}')","8d3b3e4b":"class Vocabulary:\n    def __init__(self, freq_threshold=2, language='en', preprocessor=None, reverse=False):\n        self.itos = {0: \"<pad>\", 1: \"<sos>\", 2: \"<eos>\", 3: \"<unk>\"}\n        self.stoi = {\"<pad>\": 0, \"<sos>\": 1, \"<eos>\": 2, \"<unk>\": 3}\n        self.tokenizer = spacy.load(language)\n        self.freq_threshold = freq_threshold\n        self.preprocessor = preprocessor\n        self.reverse = reverse\n\n    def __len__(self):\n        return len(self.itos)\n\n    def tokenize(self, text):\n        if self.reverse:\n            return [token.text.lower() for token in self.tokenizer.tokenizer(text)][::-1]\n        else:\n            return [token.text.lower() for token in self.tokenizer.tokenizer(text)]\n\n    def build_vocabulary(self, sentence_list):\n        frequencies = {}\n        idx = len(self.itos)\n\n        for sentence in sentence_list:\n            # Preprocess the sentence using given preprocessor.\n            if self.preprocessor:\n                sentence = self.preprocessor(sentence)\n\n            for word in self.tokenize(sentence):\n                if word in frequencies:\n                    frequencies[word] += 1\n                else:\n                    frequencies[word] = 1\n\n                if frequencies[word] == self.freq_threshold:\n                    self.stoi[word] = idx\n                    self.itos[idx] = word\n                    idx += 1\n\n    def numericalize(self, text):\n        tokenized_text = self.tokenize(text)\n\n        return [\n            self.stoi[token] if token in self.stoi else self.stoi[\"<unk>\"]\n            for token in tokenized_text\n        ]","dad485a2":"# Converts the unicode file to ascii\ndef unicode_to_ascii(s):\n    return ''.join(c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn')\n\ndef preprocess_sentence(w):\n    w = unicode_to_ascii(w.lower().strip())\n\n    # creating a space between a word and the punctuation following it\n    # eg: \"he is a boy.\" => \"he is a boy .\"\n    # Reference:- https:\/\/stackoverflow.com\/questions\/3645931\/python-padding-punctuation-with-white-spaces-keeping-punctuation\n    w = re.sub(r\"([?.!,\u00bf])\", r\" \\1 \", w)\n    w = re.sub(r'[\" \"]+', \" \", w)\n\n    # replacing everything with space except (a-z, A-Z, \".\", \"?\", \"!\", \",\")\n    w = re.sub(r\"[^a-zA-Z?.!,\u00bf]+\", \" \", w)\n\n    w = w.strip()\n    return w","49867d75":"%%time\n# Build vocab using training data\nfreq_threshold = 2\nen_vocab = Vocabulary(freq_threshold=freq_threshold, language=\"en\", preprocessor=preprocess_sentence, reverse=False)\nde_vocab = Vocabulary(freq_threshold=freq_threshold, language=\"de\", preprocessor=preprocess_sentence, reverse=True)\n\n# build vocab for both english and german\nen_vocab.build_vocabulary(train_df[\"en\"].tolist())\nde_vocab.build_vocabulary(train_df[\"de\"].tolist())","888af5d3":"class CustomTranslationDataset(Dataset):    \n    def __init__(self, df, en_vocab, de_vocab):\n        super().__init__()\n        self.df = df\n        self.en_vocab = en_vocab\n        self.de_vocab = de_vocab\n        \n    def __len__(self):\n        return len(self.df)\n    \n    def _get_numericalized(self, sentence, vocab):\n        \"\"\"Numericalize given text using prebuilt vocab.\"\"\"\n        numericalized = [vocab.stoi[\"<sos>\"]]\n        numericalized.extend(vocab.numericalize(sentence))\n        numericalized.append(vocab.stoi[\"<eos>\"])\n        return numericalized\n\n    def __getitem__(self, index):\n        en_numericalized = self._get_numericalized(self.df.iloc[index][\"en\"], self.en_vocab)\n        de_numericalized = self._get_numericalized(self.df.iloc[index][\"de\"], self.de_vocab)\n\n        return torch.tensor(de_numericalized), torch.tensor(en_numericalized)","34c44bf6":"class CustomCollate:\n    def __init__(self, pad_idx):\n        self.pad_idx = pad_idx\n\n    def __call__(self, batch):\n        src = [item[0] for item in batch]\n        src = pad_sequence(src, batch_first=False, padding_value=self.pad_idx)\n        \n        targets = [item[1] for item in batch]\n        targets = pad_sequence(targets, batch_first=False, padding_value=self.pad_idx)\n\n        return src, targets","7ea87916":"BATCH_SIZE = 128\n\n# Define dataset and dataloader\ntrain_dataset = CustomTranslationDataset(train_df, en_vocab, de_vocab)\nvalid_dataset = CustomTranslationDataset(valid_df, en_vocab, de_vocab)\n\ntrain_loader = DataLoader(\n    dataset=train_dataset,\n    batch_size=BATCH_SIZE,\n    num_workers=4,\n    shuffle=False,\n    collate_fn=CustomCollate(pad_idx=en_vocab.stoi[\"<pad>\"])\n)\n\nvalid_loader = DataLoader(\n    dataset=valid_dataset,\n    batch_size=BATCH_SIZE,\n    num_workers=4,\n    shuffle=False,\n    collate_fn=CustomCollate(pad_idx=en_vocab.stoi[\"<pad>\"])\n)","25bf60e4":"fun_de = np.vectorize(lambda x: de_vocab.itos[x])\nfun_en = np.vectorize(lambda x: en_vocab.itos[x])","ee403f6f":"print(f\"Unique tokens in source (de) vocabulary: {len(de_vocab)}\")\nprint(f\"Unique tokens in target (en) vocabulary: {len(en_vocab)}\")","d2dd8a59":"device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\ndevice","d3bf07a0":"class Encoder(nn.Module):\n    def __init__(self, input_dim, emb_dim, hidden_dim, n_layers, dropout=0.2):\n        super().__init__()\n        self.hidden_dim = hidden_dim\n        self.n_layers = n_layers\n        self.embedding = nn.Embedding(input_dim, emb_dim)\n        self.gru = nn.GRU(emb_dim, hidden_dim, n_layers, bidirectional=True, dropout=0.0 if n_layers==1 else dropout)\n        self.fc = nn.Linear(2*hidden_dim, hidden_dim)\n        self.dropout = nn.Dropout(dropout)\n    \n    def forward(self, x):\n        x = self.embedding(x)\n        x = self.dropout(x)\n        outputs, hidden_state = self.gru(x)\n        # Combine the forward and backward RNN's hidden states to be input to decoder\n        hidden_state = torch.tanh(self.fc(torch.cat((hidden_state[-2, :, :], hidden_state[-1, :, :]), dim=1)))\n        return outputs, hidden_state\n\nclass Attention(nn.Module):\n    def __init__(self, hidden_dim):\n        super().__init__()\n        self.attention = nn.Linear(3*hidden_dim, hidden_dim)\n        self.v = nn.Linear(hidden_dim, 1, bias=False)\n    \n    def forward(self, hidden_state, encoder_outputs):\n        batch_size = encoder_outputs.shape[1]\n        src_len = encoder_outputs.shape[0]\n        \n        # repeat decoder hidden state src_len times\n        hidden_state = hidden_state.unsqueeze(1).repeat(1, src_len, 1)\n\n        encoder_outputs = encoder_outputs.permute(1, 0, 2)\n        \n        energy = torch.tanh(self.attention(torch.cat((hidden_state, encoder_outputs), dim = 2))) \n        \n        attention = self.v(energy).squeeze(2)\n        \n        return F.softmax(attention, dim=1)\n\nclass Decoder(nn.Module):\n    def __init__(self, output_dim, emb_dim, hidden_dim, n_layers, attention, dropout=0.2):\n        super().__init__()\n        self.output_dim = output_dim\n        self.hidden_dim = hidden_dim\n        self.attention = attention\n        self.n_layers = n_layers\n        self.embedding = nn.Embedding(output_dim, emb_dim)\n        self.gru = nn.GRU(emb_dim+(hidden_dim*2), hidden_dim, n_layers, dropout=0.0 if n_layers==1 else dropout)\n        self.dropout = nn.Dropout(dropout)\n        self.fc = nn.Linear(hidden_dim*3 + emb_dim, output_dim)\n    \n    def forward(self, input, hidden, encoder_outputs):\n        input = input.unsqueeze(0)\n        \n        #input = [1, batch size]\n        \n        embedded = self.dropout(self.embedding(input))\n        \n        #embedded = [1, batch size, emb dim]\n        \n        a = self.attention(hidden, encoder_outputs)\n                \n        #a = [batch size, src len]\n        \n        a = a.unsqueeze(1)\n        \n        #a = [batch size, 1, src len]\n        \n        encoder_outputs = encoder_outputs.permute(1, 0, 2)\n        \n        #encoder_outputs = [batch size, src len, enc hid dim * 2]\n        \n        weighted = torch.bmm(a, encoder_outputs)\n        \n        #weighted = [batch size, 1, enc hid dim * 2]\n        \n        weighted = weighted.permute(1, 0, 2)\n        \n        #weighted = [1, batch size, enc hid dim * 2]\n        \n        rnn_input = torch.cat((embedded, weighted), dim = 2)\n        \n        #rnn_input = [1, batch size, (enc hid dim * 2) + emb dim]\n            \n        output, hidden = self.gru(rnn_input, hidden.unsqueeze(0))\n        \n        #output = [seq len, batch size, dec hid dim * n directions]\n        #hidden = [n layers * n directions, batch size, dec hid dim]\n        \n        #seq len, n layers and n directions will always be 1 in this decoder, therefore:\n        #output = [1, batch size, dec hid dim]\n        #hidden = [1, batch size, dec hid dim]\n        #this also means that output == hidden\n        assert (output == hidden).all()\n        \n        embedded = embedded.squeeze(0)\n        output = output.squeeze(0)\n        weighted = weighted.squeeze(0)\n        \n        prediction = self.fc(torch.cat((output, weighted, embedded), dim = 1))\n        \n        #prediction = [batch size, output dim]\n        \n        return prediction, hidden.squeeze(0)\n\nclass EncoderDecoder(nn.Module):\n    def __init__(self, encoder, decoder):\n        super().__init__()\n        self.encoder = encoder\n        self.decoder = decoder\n        \n        assert self.encoder.hidden_dim == decoder.hidden_dim\n        assert self.encoder.n_layers == decoder.n_layers\n    \n    def forward(self, x, y, teacher_forcing_ratio=0.75):\n        \n        target_len = y.shape[0]\n        batch_size = y.shape[1]\n        target_vocab_size = self.decoder.output_dim  # Output dim\n        \n        outputs = torch.zeros(target_len, batch_size, target_vocab_size).to(device)\n        \n        # Encode the source text using encoder. Last hidden state of encoder is context vector.\n        encoder_outputs, hidden_state = self.encoder(x)\n        \n        # First input is <sos>\n        input = y[0,:]\n        \n        # Decode the encoded vector using decoder\n        for t in range(1, target_len):\n            output, hidden_state = self.decoder(input, hidden_state, encoder_outputs)\n            outputs[t] = output\n            teacher_force = random.random() < teacher_forcing_ratio\n            pred = output.argmax(1)\n            input = y[t] if teacher_force else pred\n        \n        return outputs","fb71ae30":"# Initialize all models\ninput_dim = len(de_vocab)\noutput_dim = len(en_vocab)\nemb_dim = 256\nhidden_dim = 512\nn_layers = 1\ndropout = 0.5\n\nattention = Attention(hidden_dim)\nencoder = Encoder(input_dim, emb_dim, hidden_dim, n_layers, dropout)\ndecoder = Decoder(output_dim, emb_dim, hidden_dim, n_layers, attention, dropout)\nmodel = EncoderDecoder(encoder, decoder).to(device)","0217047f":"def init_weights(m):\n    for name, param in m.named_parameters():\n        if 'weight' in name:\n            nn.init.normal_(param.data, mean=0, std=0.01)\n        else:\n            nn.init.constant_(param.data, 0)\n            \nmodel.apply(init_weights)","5fc98193":"def count_parameters(model):\n    return sum(p.numel() for p in model.parameters() if p.requires_grad)\n\nprint(f'The model has {count_parameters(model):,} trainable parameters')","04b16861":"optimizer = optim.Adam(model.parameters())\ncriterion = nn.CrossEntropyLoss(ignore_index=en_vocab.stoi[\"<pad>\"])","8e36acd7":"def train(model, iterator, optimizer, criterion, clip):\n    model.train()\n    epoch_loss = 0\n    \n    for i, batch in tqdm(enumerate(iterator), total=len(iterator), position=0, leave=True):\n        src = batch[0].to(device)\n        trg = batch[1].to(device)\n\n        optimizer.zero_grad()\n        \n        output = model(src, trg)\n        \n        #trg = [trg len, batch size]\n        #output = [trg len, batch size, output dim]\n        \n        output_dim = output.shape[-1]\n        output = output[1:].view(-1, output_dim)\n        trg = trg[1:].view(-1)\n        \n        #trg = [(trg len - 1) * batch size]\n        #output = [(trg len - 1) * batch size, output dim]\n        \n        loss = criterion(output, trg)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), clip)\n        optimizer.step()\n        epoch_loss += loss.item()\n        \n    return epoch_loss \/ len(iterator)","17342b95":"def evaluate(model, iterator, criterion):\n    model.eval()    \n    epoch_loss = 0\n\n    with torch.no_grad():\n        for i, batch in tqdm(enumerate(iterator), total=len(iterator), position=0, leave=True):\n            src = batch[0].to(device)\n            trg = batch[1].to(device)\n\n            output = model(src, trg, 0) #turn off teacher forcing\n\n            #trg = [trg len, batch size]\n            #output = [trg len, batch size, output dim]\n\n            output_dim = output.shape[-1]\n            output = output[1:].view(-1, output_dim)\n            trg = trg[1:].view(-1)\n\n            #trg = [(trg len - 1) * batch size]\n            #output = [(trg len - 1) * batch size, output dim]\n\n            loss = criterion(output, trg)\n            epoch_loss += loss.item()\n        \n    return epoch_loss \/ len(iterator)","65761111":"def inference(model, sentence):\n    model.eval()\n    result, attentions = [], []\n\n    with torch.no_grad():\n        sentence = sentence.to(device)\n        \n        encoder_outputs, hidden_state = model.encoder(sentence)\n\n        # First input to decoder is \"<sos>\"\n        inp = torch.tensor([en_vocab.stoi[\"<sos>\"]]).to(device)\n\n        # Decode the encoded vector using decoder until max length is reached or <eos> is generated.\n        for t in range(1, seq_len_en):\n            attention = model.decoder.attention(hidden_state, encoder_outputs)\n            output, hidden_state = model.decoder(inp, hidden_state, encoder_outputs)\n            pred = output.argmax(1)\n            if pred == en_vocab.stoi[\"<eos>\"]:\n                break\n            result.append(en_vocab.itos[pred.item()])\n            inp = pred\n            attentions.append(attention.cpu().detach().numpy().ravel())\n\n    return \" \".join(result), attentions","2cd0e98f":"def epoch_time(start_time, end_time):\n    elapsed_time = end_time - start_time\n    elapsed_mins = int(elapsed_time \/ 60)\n    elapsed_secs = int(elapsed_time - (elapsed_mins * 60))\n    return elapsed_mins, elapsed_secs","a1b9e8ce":"for sample_batch in valid_loader:\n    break","32235266":"N_EPOCHS = 10\nCLIP = 1\n\nbest_valid_loss = float('inf')\n\nsample_source = ' '.join([word for word in fun_de(sample_batch[0][:, 101]) if word not in [\"<pad>\", \"<sos>\", \"<eos>\"]])\nsample_target = ' '.join([word for word in fun_en(sample_batch[1][:, 101]) if word not in [\"<pad>\", \"<sos>\", \"<eos>\"]])\n\nfor epoch in range(N_EPOCHS):\n    \n    start_time = time.time()\n    \n    train_loss = train(model, train_loader, optimizer, criterion, CLIP)\n    valid_loss = evaluate(model, valid_loader, criterion)\n    \n    end_time = time.time()\n    \n    epoch_mins, epoch_secs = epoch_time(start_time, end_time)\n    \n    if valid_loss < best_valid_loss:\n        best_valid_loss = valid_loss\n        torch.save(model.state_dict(), 'best_model.pt')\n    \n    print(f'Epoch: {epoch+1:02} | Time: {epoch_mins}m {epoch_secs}s')\n    print(f'\\t Train Loss: {train_loss:.3f} | Train PPL: {math.exp(train_loss):7.3f}')\n    print(f'\\t Val. Loss: {valid_loss:.3f} |  Val. PPL: {math.exp(valid_loss):7.3f}')\n    print(f'\\t Sample Source (German): {sample_source}')\n    print(f'\\t Sample Target (English): {sample_target}')\n    print(f'\\t Generated: {inference(model, sample_batch[0][:, 101].reshape(-1, 1))[0]}\\n')","678b09d9":"# Load the best model.\nmodel_path = \".\/best_model.pt\"\nmodel.load_state_dict(torch.load(model_path))","0411d3b2":"for idx in range(20):\n    print(f'ACTUAL GERMAN: {\" \".join([word for word in fun_de(sample_batch[0][:, idx]) if word not in [\"<pad>\", \"<sos>\", \"<eos>\"]])}')\n    print(f'ACTUAL: ENGLISH: {\" \".join([word for word in fun_en(sample_batch[1][:, idx]) if word not in [\"<pad>\", \"<sos>\", \"<eos>\"]])}')\n    print(f'GENERATED BY MODEL: {inference(model, sample_batch[0][:, idx].reshape(-1, 1))[0]}')\n    print(\"=\"*92)","f6022310":"def plot_attention_map(sentence):\n    sentence = sentence.reshape(-1, 1)\n    translated, attentions = inference(model, sentence)\n    sentence = sentence.cpu().detach().numpy().ravel()\n    sent_len = len(sentence[sentence != 0])\n    \n    fig, ax = plt.subplots(1, 1)\n    fig.set_figheight(8)\n    fig.set_figwidth(8)\n    ax.imshow(np.array(attentions)[:, :sent_len], cmap='hot', interpolation='nearest')\n    ax.tick_params(labelsize=12)\n    ax.set_xticklabels(['']+[word for word in fun_de(sentence) if word not in [\"<pad>\"]], rotation=45)\n    ax.set_yticklabels(['']+translated.split())\n\n    ax.xaxis.set_major_locator(ticker.MultipleLocator(1))\n    ax.yaxis.set_major_locator(ticker.MultipleLocator(1))\n    ax.grid(False)\n    plt.show()","7544b901":"plot_attention_map(sample_batch[0][:, 0])","8cb7e4a8":"plot_attention_map(sample_batch[0][:, 1])","8750b0ff":"plot_attention_map(sample_batch[0][:, 15])","71e7006d":"plot_attention_map(sample_batch[0][:, 19])","43617490":"plot_attention_map(sample_batch[0][:, 2])","6fd9f5cd":"## Modeling","aa06e4ec":"## Results","70351d0a":"## Attention plots\n\nAttention plot shows the amount of attention paid by the model to the source sequence words at the time of translation of each of the target word.","eab5dc00":"In this notebook, I've implemented the attention based Seq2Seq model. Most of the modeling and training part are referenced from part-III of this great tutorial series: https:\/\/github.com\/bentrevett\/pytorch-seq2seq.\n\nBut in this series, the preprocessed data is being used for training\/evaluation (because pytorch's Multi30k class provides all the heavy lifting), so it's bit difficult to generalize the structure for custom dataset implementation. So in this notebook, I've implemented data preprocessing like tokenization, padding etc. from scratch using spacy and pure pytorch. I've also plotted attention plots for some of the validation sentences. Which seems interesting as it helps us to understand the underlying attention mechanism.\n\nHere are some other references I've used:\n\n* [Original research paper: Neural Machine Translation by Jointly Learning to Align and Translate](https:\/\/arxiv.org\/pdf\/1409.0473.pdf)\n* [Creating custom dataset for NLP tasks](https:\/\/github.com\/aladdinpersson\/Machine-Learning-Collection\/blob\/22635a65d8cf462aa44199357928e61c0ecda000\/ML\/Pytorch\/more_advanced\/image_captioning\/get_loader.py)"}}