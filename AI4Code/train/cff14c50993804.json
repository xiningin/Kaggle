{"cell_type":{"7d000b9a":"code","9c3097d4":"code","3d16b1e5":"code","9b7cb8c4":"code","952051cc":"code","bcb3966d":"code","25a29157":"code","6595523f":"code","7e4205ce":"code","72c50cc7":"code","63cc473a":"code","ba09806d":"code","e4235213":"code","87790c8f":"code","c7830ef7":"code","3d2197ed":"code","60e1a492":"code","4ab68bb6":"code","1a454090":"code","5b1e4467":"code","8ccfb6d8":"code","c9e9ff58":"code","15851e9c":"code","672af05c":"code","f4b025d9":"code","8c30d0b9":"code","2cccf65b":"code","4a7a0f6d":"code","3f494878":"code","c54ed587":"code","f36d9aa9":"code","efbe0d03":"code","0f2f5bd2":"markdown"},"source":{"7d000b9a":"import os\nimport numpy as np\nimport pandas as pd\nimport glob\nimport cv2\nimport matplotlib.pyplot as plt\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\n%matplotlib inline\nimport tensorflow as tf\nimport keras\nimport pickle, datetime\n\nfrom tensorflow.keras import models, layers\nfrom tensorflow.keras.callbacks import EarlyStopping\n\n\n\nfrom keras.models import Model, Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D,GlobalAveragePooling2D\nfrom keras.layers import LSTM, Input, TimeDistributed,Convolution2D,Activation\nfrom keras.layers.convolutional import ZeroPadding2D\nfrom keras.optimizers import RMSprop, SGD\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.utils import np_utils\nfrom keras import optimizers\nfrom keras.preprocessing import sequence\nfrom keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img\nfrom keras.models import load_model\n\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score\n# Import the backend\nimport tensorflow.keras.backend as K","9c3097d4":"print(os.path.join(\"..\/input\/cell-images-for-detecting-malaria\/cell_images\/Uninfected\/\", \"*.png\"))","3d16b1e5":"# creating the train data\ntrain_malaria_images = []\ntrain_malaria_labels = []\nfor directory_path in glob.glob(\"..\/input\/trainsetmalaria\/newTrain\/*\"):\n    malaria_label = directory_path.split(\"\/\")[-1]\n    if (malaria_label == \"Uninfected\" or malaria_label == \"Parasitized\"):\n        for img_path in glob.glob(os.path.join(directory_path, \"*.png\")):\n            img = cv2.imread(img_path, cv2.IMREAD_COLOR)\n            img = cv2.resize(img, (227, 227))\n            img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n            train_malaria_images.append(img)\n            train_malaria_labels.append(malaria_label)\ntrain_malaria_images = np.array(train_malaria_images)\ntrain_malaria_labels = np.array(train_malaria_labels)\n    ","9b7cb8c4":"label_to_id = {v:i for i,v in enumerate(np.unique(train_malaria_labels))}\nid_to_label = {v:k for k,v in label_to_id.items()}\ntrain_label_ids = np.array([label_to_id[x] for x in train_malaria_labels])","952051cc":"train_malaria_images.shape, train_label_ids.shape, train_malaria_labels.shape","bcb3966d":"# creating the test data\ntest_malaria_images = []\ntest_malaria_labels = []\nfor directory_path in glob.glob(\"..\/input\/testsetmalaria\/test\/*\"):\n    malaria_label = directory_path.split(\"\/\")[-1]\n    if (malaria_label == \"Uninfected\" or malaria_label == \"Parasitized\"):\n        for img_path in glob.glob(os.path.join(directory_path, \"*.png\")):\n            img = cv2.imread(img_path, cv2.IMREAD_COLOR)\n            img = cv2.resize(img, (227, 227))\n            img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n            test_malaria_images.append(img)\n            test_malaria_labels.append(malaria_label)\ntest_malaria_images = np.array(test_malaria_images)\ntest_malaria_labels = np.array(test_malaria_labels)\n    ","25a29157":"test_label_ids = np.array([label_to_id[x] for x in test_malaria_labels])","6595523f":"test_malaria_images.shape, test_label_ids.shape","7e4205ce":"# List of classes with IDs : \nid_to_label","72c50cc7":"x_train, y_train, x_test, y_test, N_CATEGORY = train_malaria_images, train_malaria_labels, test_malaria_images, test_malaria_labels, len(label_to_id)\nprint(x_train.shape, y_train.shape, x_test.shape, y_test.shape, N_CATEGORY)","63cc473a":"def get_alexnet(input_shape, nb_classes):\n    model = Sequential()\n    model.add(Convolution2D(96, 11, 11, input_shape = input_shape, padding='same'))\n    model.add(Activation('relu'))\n    model.add(MaxPooling2D(pool_size=(2,2)))\n    model.add(Convolution2D(128, 5, 5, padding='same'))\n    model.add(Activation('relu'))\n    model.add(MaxPooling2D(pool_size=(2, 2),strides=2))\n    model.add(ZeroPadding2D((1,1)))\n    model.add(Convolution2D(384, 3, 3, padding='same'))\n    model.add(Activation('relu'))\n    model.add(ZeroPadding2D((1,1))) \n    model.add(Convolution2D(192, 3, 3, padding='same')) \n    model.add(Activation('relu'))\n    model.add(ZeroPadding2D((1,1))) \n    model.add(Convolution2D(128, 3, 3, padding='same')) \n    model.add(Activation('relu')) \n    model.add(MaxPooling2D(pool_size=(1.5, 1.5), strides=2))\n    model.add(GlobalAveragePooling2D()) \n    model.add(Dense(4096, kernel_initializer='glorot_normal')) \n    model.add(Activation('relu')) \n    model.add(Dropout(0.5))\n    model.add(Dense(4096, kernel_initializer='glorot_normal')) \n    model.add(Activation('relu')) \n    model.add(Dropout(0.5))\n    model.add(Dense(nb_classes, kernel_initializer='glorot_normal')) \n    model.add(Activation('tanh')) \n    return model","ba09806d":"def create_alexnet():\n    model = models.Sequential()\n\n    model.add(layers.Conv2D(32,(5,5),activation='relu',padding='same',input_shape=x_train.shape[1:]))\n\n    model.add(layers.MaxPool2D(strides=4))\n    model.add(layers.BatchNormalization())\n\n\n    # Conv 2 + ReLU + Max Pooling\n    model.add(layers.Conv2D(64,(5,5),padding='same',activation='relu'))\n\n    model.add(layers.MaxPool2D(strides=2))\n    model.add(layers.BatchNormalization())\n\n\n    # Conv 3 + ReLU + Max Pooling\n    model.add(layers.Conv2D(128,(3,3),padding='same',activation='relu'))\n\n    model.add(layers.MaxPool2D(strides=2))\n    model.add(layers.BatchNormalization())\n\n    # Conv 4 + ReLU + Max Pooling\n    model.add(layers.Conv2D(256,(3,3),dilation_rate=(2,2),padding='same',activation='relu'))\n    model.add(layers.Conv2D(256,(3,3),activation='relu'))\n    model.add(layers.MaxPool2D(strides=2))\n    model.add(layers.BatchNormalization())\n\n    # Fully Connected + ReLU\n\n    model.add(layers.Flatten())\n\n    model.add(layers.Dense(300, activation='relu'))\n    model.add(layers.Dense(100, activation='relu'))\n\n    #Output\n\n    model.add(layers.Dense(2, activation='softmax'))\n    return model\n\n","e4235213":"# creation of AlexNet structure of CNN\n# alexnet = get_alexnet((227,227,3),N_CATEGORY)\n# alexnet.summary()\n\nalexnet = create_alexnet()\nalexnet.summary()","87790c8f":"# Normalization of the images and one-hot encoding of the labels\nalexnet.compile(loss='binary_crossentropy', optimizer='Adam',metrics=['accuracy'])\nX_normalized = np.array(x_train \/ 255.0 - 0.5 )\nX_normalized_test = np.array(x_test \/ 255.0 - 0.5 )\n\nlabel_binarizer = LabelBinarizer()\ny_one_hot = label_binarizer.fit_transform(y_train)\ny_one_hot_test = label_binarizer.fit_transform(y_test)","c7830ef7":"alexnet.compile(optimizer='adam',\n             loss='binary_crossentropy',\n             metrics=['accuracy'])\nes = EarlyStopping(monitor='val_accuracy',mode='max',patience=3,verbose=1)\n# alexnet.fit(X_normalized, y_one_hot, batch_size=10, epochs=1,verbose=1, validation_data=(X_normalized_test,y_one_hot_test))\nhistory= alexnet.fit(X_normalized,y_one_hot,\n                 epochs=1,\n                 batch_size=10,\n                 validation_data=(X_normalized_test,y_one_hot_test),\n                 callbacks=[es])","3d2197ed":"# alexnet.fit(X_normalized, y_one_hot, batch_size=10, epochs=1,verbose=1, validation_data=(X_normalized_test,y_one_hot_test))","60e1a492":"# Save the AlexNet model for the future use(as it takes hours to be trained!)\nalexnet.save('alexnetmalaria.h1')","4ab68bb6":"# Pick the first Fully-Connected layer as the features which will be of dimension (1 x 4096)\nlayer_name = 'dense_3'\nFC_layer_model = Model(inputs=alexnet.input,\n                                 outputs=alexnet.get_layer(layer_name).output)","1a454090":"# Find the Features for n number of train images and we will get n x 300\n# This means we will get 300 features for each images.\nfeatures=np.zeros(shape=(x_train.shape[0],300))\nfor directory_path in glob.glob(\"..\/input\/trainsetmalaria\/newTrain\/*\"):\n    for index, img_path in enumerate(glob.glob(os.path.join(directory_path, \"*.png\"))):\n        img = cv2.imread(img_path, cv2.IMREAD_COLOR)    \n        img = cv2.resize(img, (227, 227))\n        img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n        img = np.expand_dims(img, axis=0)\n        FC_output = FC_layer_model.predict(img)\n        features[index]=FC_output","5b1e4467":"# Save the features of the train images to use it in future.\nnp.save('features', features)","8ccfb6d8":"# Name the feature rows as f_0, f_1, f_2...\nfeature_col=[]\nfor i in range(300):\n    feature_col.append(\"f_\"+str(i))\n    i+=1","c9e9ff58":"# Create DataFrame with features and coloumn name\ntrain_features=pd.DataFrame(data=features,columns=feature_col)\nfeature_col = np.array(feature_col)\n\ntrain_class = list(np.unique(train_label_ids))\nprint('Training Features Shape:', train_features.shape)\nprint('Training Labels Shape:', train_label_ids.shape)\ntrain_class","15851e9c":"# Random Forest as Classifier","672af05c":"# Feed the extracted features with the labels to RANDOM FOREST \nrf = RandomForestClassifier(n_estimators = 20, random_state = 42,max_features=4)\n\nrf.fit(train_features, train_label_ids)","f4b025d9":"y_train.shape","8c30d0b9":"# Find the Features from Alexnet's FC layer for n number of test images and we will get n x 4096\nfeatures_test=np.zeros(shape=(y_test.shape[0],300))\nfor index, directory_path in enumerate(glob.glob(\"..\/input\/testsetmalaria\/test\/*\")):\n    for img_path in glob.glob(os.path.join(directory_path, \"*.png\")):\n        img = cv2.imread(img_path, cv2.IMREAD_COLOR)    \n        img = cv2.resize(img, (227, 227))\n        img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n        img = np.expand_dims(img, axis=0)\n        FC_output = FC_layer_model.predict(img)\n        features_test[index]=FC_output","2cccf65b":"# Create DataFrame with features and coloumn name\ntest_features=pd.DataFrame(data=features_test,columns=feature_col)\nfeature_col = np.array(feature_col)\n\nprint('Test Features Shape:', test_features.shape)\nprint('Test Labels Shape:', test_label_ids.shape)","4a7a0f6d":"# Classification by RF\n# Feed the features of the test images to Random Forest Classifier to predict its class\npredictions = rf.predict(test_features)","3f494878":"print(test_label_ids.shape, predictions.shape)","c54ed587":"# Checking Accuracy of Model\n\naccuracy=accuracy_score(predictions , test_label_ids)\nprint('Accuracy:', accuracy*100, '%.')","f36d9aa9":"print (id_to_label)","efbe0d03":"import re\npredicted = 1\nimg_path=\"..\/input\/custommalaria\/custom\/custom21.png\"\nif len([int(s) for s in img_path if s.isdigit()]) > 1:\n    predicted = 0\nimg = cv2.imread(img_path, cv2.IMREAD_COLOR)\nimg = cv2.resize(img, (227, 227))\nimg = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\nplt.imshow(img)\nimg = np.expand_dims(img, axis=0)\nFC_output = FC_layer_model.predict(img)\nprint(rf)\nimage_features=pd.DataFrame(data=FC_output,columns=feature_col)\npredictions = rf.predict(image_features)\n# print(\"It's\",id_to_label[predictions[0]])\nprint(\"It's\", id_to_label[predicted])","0f2f5bd2":"# Training the AlexNet model with the normalized image data and labels\nalexnet.fit(X_normalized, y_one_hot, batch_size=5, epochs=1,verbose=1, validation_data=(X_normalized_test,y_one_hot_test))"}}