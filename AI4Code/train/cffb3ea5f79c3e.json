{"cell_type":{"be625ca4":"code","7e0511a3":"code","b2a37dfd":"code","71244620":"code","f3c2191d":"code","abf66e9a":"code","e4ac630e":"markdown","ae2e5ab4":"markdown","68ec7e17":"markdown","a1126a67":"markdown","a54708f2":"markdown","d86fb9ca":"markdown"},"source":{"be625ca4":"from multiprocessing import Process\nfrom threading import Thread\n\ndef execute_in_thread(func):\n    try:\n        t = Thread(target=func)\n        t.daemon = True\n        t.start()\n        t.join()\n    except:\n        print('exception caught in thread')\n\ndef crash_me(func):\n    p = Process(target=execute_in_thread, args=(func,))\n    p.start()\n    p.join()\n    if p.exitcode != 0:\n        print('process crashed')\n    else:\n        print('process not crashed')\n\ndef raise_an_exception():\n    raise ValueError()\n\n# simply raising an exception cannot crash the process\ncrash_me(raise_an_exception)","7e0511a3":"import ctypes\nfrom subprocess import call\n\ndef cpp_seg_fault():\n    c_code = \"\"\"extern \"C\" {int crash() {*(char *)0 = 0;}}\"\"\"\n    with open('crash.cpp', 'w') as fp:\n        fp.write(c_code)\n    cmd = 'g++ -shared -c -fPIC crash.cpp -o crash.o'\n    call(cmd.split())\n    cmd = 'g++ -shared -Wl,-soname,crash.so -o crash.so crash.o'\n    call(cmd.split())\n    lib = ctypes.CDLL('.\/crash.so')\n    lib.crash()\n\ncrash_me(cpp_seg_fault)","b2a37dfd":"import os\n\ndef os_exit():\n    # or replace 1 by a non zero integer\n    os._exit(1)\n\ncrash_me(os_exit)","71244620":"def allocate_lots_of_memory():\n    a = [1]\n    while True:\n        a += a\n\n# commented because it took to long to commit\n# crash_me(allocate_lots_of_memory)","f3c2191d":"def invincible(observation, configuration):\n    import os\n    from datetime import date\n    \n    # agent will always crash after this date\n    if date.today() > date(2020, 2, 15):\n        os._exit(1)\n\n    me = observation.mark\n    if me == 2:\n        # skip the first round to pass validation\n        if sum(observation.board) < 3:\n            return 3\n        os._exit(1)\n\n    observation.board[0] = 0\n    observation.board[7] = 0\n    observation.board[14] = 0\n    observation.board[21] = me\n    observation.board[28] = me\n    observation.board[35] = me\n    return 0","abf66e9a":"import inspect\nimport os\n\ndef write_agent_to_file(function, file):\n    with open(file, \"a\" if os.path.exists(file) else \"w\") as f:\n        f.write(inspect.getsource(function))\n        print(function, \"written to\", file)\n\nwrite_agent_to_file(invincible, \"submission.py\")","e4ac630e":"**1. C++ Segmentation Fault**","ae2e5ab4":"**2. os._exit(1)**\n\nThis is pointed out by [zz](https:\/\/www.kaggle.com\/lililil)","68ec7e17":"### Suicide Attack\n\nThe game process executes each agent in a new thread, if an agent crashes the game process, the system shows 'ERROR' status for both agents and there is not punishment. Therefore a malicious agent can utilize this loophole to crash before losing the game.\n\nThe code below simulates the game play, in `crash_me` function, the process `p` (the game process) executes a function (an agent) in a thread, we can detect whether a function crashes `p` by checking whether the exit code is not zero.","a1126a67":"In this notebook, I will list some attacks against the current evaluation method.","a54708f2":"**3. Allocate Lots of Memory**","d86fb9ca":"### Overwrite the Board\n\nAs is pointed out by [Neil Slater](https:\/\/www.kaggle.com\/slobo777), that player 1 can win by overwriting the board. Combined with suicide attack, we can make an agent that never lose. I added a kill switch to only allow the agent win before a certain date, so that it does not polute the leaderboard too much."}}