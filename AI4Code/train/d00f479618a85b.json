{"cell_type":{"3069ada4":"code","98a024c9":"code","89009f0e":"code","1d7aaf59":"code","f8712452":"code","c69c39c3":"code","078275b8":"code","528f1c4b":"code","36606a6d":"code","bd71d9e2":"code","be25fed1":"code","2f93b4c6":"code","a3a611fe":"code","d41a2cff":"code","354b96db":"code","b1051e42":"code","ec9b4c43":"code","7862b001":"code","89560a2a":"code","27822782":"code","ba564b62":"code","5bba6e1b":"code","6758e9ca":"code","2c8d4aff":"code","46c2544b":"code","a642fa5e":"code","26d0991c":"code","c19a50f1":"code","7375881d":"code","b2b5171e":"markdown","cacb2cd6":"markdown","33aaf18e":"markdown","60bacb3e":"markdown","96c319a7":"markdown","d5a59b42":"markdown"},"source":{"3069ada4":"!pip install pyfolio","98a024c9":"!pip install quandl","89009f0e":"import numpy as np \nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport scipy.optimize as sco\nimport quandl\nimport pyfolio as pf\nimport os\nfrom kaggle_secrets import UserSecretsClient\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","1d7aaf59":"label = \"QUANDL_KEY\"\nQUANDL_KEY = UserSecretsClient().get_secret(label)\nquandl.ApiConfig.api_key = QUANDL_KEY","f8712452":"# Get only adjusted close\nquandl_df = quandl.get(dataset=['WIKI\/AAPL.4','WIKI\/GOOGL.4', 'WIKI\/MSFT.4', 'WIKI\/NKE.4', 'WIKI\/NVDA.4'],start_date='2010-01-01',end_date='2020-12-31')","c69c39c3":"quandl_df.columns","078275b8":"quandl_df.columns = ['APPl', 'GOOGLE', 'MSFT', 'NKE', 'NVDA']","528f1c4b":"quandl_df.head()","36606a6d":"smp_df = quandl_df.pct_change().dropna()\nsmp_df.head()","bd71d9e2":"log_df = np.log(quandl_df\/quandl_df.shift(1)).dropna()\nlog_df.head()","be25fed1":"def realized_volatility(x):\n    return np.sqrt(np.sum(x**2))","2f93b4c6":"rv_df = log_df.groupby(pd.Grouper(freq='M')).apply(realized_volatility)","a3a611fe":"rv_df = rv_df * np.sqrt(12)","d41a2cff":"rv_df.head()","354b96db":"fig, ax = plt.subplots(2, 1, sharex=True)\nfig.set_size_inches(18.5, 10.5)\nax[0].plot(log_df)\nax[1].plot(rv_df)","b1051e42":"assets_num = len(smp_df.columns)","ec9b4c43":"weights = [1\/assets_num] * assets_num","7862b001":"port_returns = pd.Series(np.dot(weights, smp_df.T), index=smp_df.index)","89560a2a":"port_returns","27822782":"pf.create_simple_tear_sheet(port_returns)","ba564b62":"N_DAYS = 2735","5bba6e1b":"def port_return(w, avg_returns):\n    return np.sum(avg_returns * w)\n\ndef port_vol(w, avg_returns, cov_mat):\n    return np.sqrt(np.dot(w.T, np.dot(cov_mat, w)))","6758e9ca":"def get_efficient_frontier(avg_returns, cov_mat, rtns_range):\n    efficient_portfolios = []\n    n_assets = len(avg_returns)\n    args = (avg_returns, cov_mat)\n    bounds = tuple((0,1) for asset in range(n_assets))\n    initial_guess = n_assets * [1. \/ n_assets, ]\n    for ret in rtns_range:\n        constraints = ({'type': 'eq', 'fun': lambda x: port_return(x, avg_returns) - ret}, {'type': 'eq', 'fun': lambda x: np.sum(x) - 1})\n        efficient_portfolio = sco.minimize(port_vol, initial_guess, args=args, method='SLSQP',\n                                            constraints=constraints,\n                                            bounds=bounds)\n        efficient_portfolios.append(efficient_portfolio)\n    return efficient_portfolios","2c8d4aff":"avg_returns = smp_df.mean() * N_DAYS\ncov_mat = smp_df.cov() * N_DAYS","46c2544b":"rtns_range = np.linspace(-0.2, 3, 2000)","a642fa5e":"efficient_portfolios = get_efficient_frontier(avg_returns, cov_mat, rtns_range)","26d0991c":"vols_range = [x['fun'] for x in efficient_portfolios]","c19a50f1":"min_vol_ind = np.argmin(vols_range)\nmin_vol_portf_rtn = rtns_range[min_vol_ind]\nmin_vol_portf_vol = efficient_portfolios[min_vol_ind]['fun']\nmin_vol_portf = {'Return': min_vol_portf_rtn, 'Volatility': min_vol_portf_vol, 'Sharpe Ratio': (min_vol_portf_rtn \/ min_vol_portf_vol)}","7375881d":"print('Minimum volatility portfolio ----')\nprint('Performance')\nfor index, value in min_vol_portf.items():\n    print(f'{index}: {100 * value:.2f}% ', end=\"\", flush=True)\nprint('\\nWeights')\nfor x, y in zip(smp_df.columns, efficient_portfolios[min_vol_ind]['x']):\n    print(f'{x}: {100*y:.2f}% ', end=\"\", flush=True)","b2b5171e":"# III. Calculate simple return and log return","cacb2cd6":"# II. Load data","33aaf18e":"# I. Install and import necessary libraries","60bacb3e":"# IV. Changing frequency","96c319a7":"# VI. Efficient Frontier for Modern Portfolio Theory","d5a59b42":"# V. 1\/n portfolio"}}