{"cell_type":{"dd8cf475":"code","c75ebae8":"code","1137bb67":"code","46f7b229":"code","82abc7cc":"code","01a5d237":"code","47bdc10c":"code","0bdbbe86":"code","70c2eca5":"code","c1c3dc00":"code","a32f6a86":"code","70f85da1":"code","f4119677":"code","a6527c39":"code","83f861e7":"code","ac1c1eec":"code","47a0144c":"code","64b74c84":"code","4b15f547":"code","5c63853b":"code","702c2ec7":"code","520fcb4b":"code","d0b1c612":"code","4ab14253":"code","61d06d76":"code","371f59f7":"code","58167a62":"code","5f1eff00":"code","7a160946":"code","aebf64e3":"code","3c0011d8":"code","1fa9a5ab":"code","e6458b38":"code","2bc06749":"code","af560677":"markdown","fd2240ec":"markdown","1f882d8e":"markdown","0dc59fe7":"markdown","0f3915d6":"markdown","3c6d9f59":"markdown","08786e2f":"markdown","da58a377":"markdown","416e590a":"markdown"},"source":{"dd8cf475":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\nimport cv2\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n!pip install imutils\nimport os\nimport keras.backend as K\nimport imutils\nimport matplotlib.pyplot as plt\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n#for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#    for filename in filenames:\n#        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","c75ebae8":"import glob\nno_files=[]\nyes_files=[]\nfor file in glob.glob(\"\/kaggle\/input\/brain-mri-images-for-brain-tumor-detection\/no\/*.jpg\"):\n    no_files.append(file)\nfor file in glob.glob(\"\/kaggle\/input\/brain-mri-images-for-brain-tumor-detection\/yes\/*.jpg\"):\n    yes_files.append(file)\n        ","1137bb67":"def crop_brain_contour(image, plot=False):\n    \n    # Convert the image to grayscale, and blur it slightly\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    gray = cv2.GaussianBlur(gray, (5, 5), 0)\n    \n    thresh = cv2.threshold(gray, 45, 255, cv2.THRESH_BINARY)[1]\n    thresh = cv2.erode(thresh, None, iterations=2)\n    thresh = cv2.dilate(thresh, None, iterations=2)\n\n    # Find contours in thresholded image, then grab the largest one\n    cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    cnts = imutils.grab_contours(cnts)\n    c = max(cnts, key=cv2.contourArea)\n    # extreme points\n    extLeft = tuple(c[c[:, :, 0].argmin()][0])\n    extRight = tuple(c[c[:, :, 0].argmax()][0])\n    extTop = tuple(c[c[:, :, 1].argmin()][0])\n    extBot = tuple(c[c[:, :, 1].argmax()][0])\n    \n    # crop new image out of the original image using the four extreme points (left, right, top, bottom)\n    new_image = image[extTop[1]:extBot[1], extLeft[0]:extRight[0]]            \n\n    if plot:\n        plt.figure()\n        plt.subplot(1, 2, 1)\n        plt.imshow(image)\n        plt.tick_params(axis='both', which='both', top=False, bottom=False, left=False, right=False,labelbottom=False, labeltop=False, labelleft=False, labelright=False)\n        plt.title('Original Image')\n        plt.subplot(1, 2, 2)\n        plt.imshow(new_image)\n        plt.tick_params(axis='both', which='both',top=False, bottom=False, left=False, right=False,labelbottom=False, labeltop=False, labelleft=False, labelright=False)\n        plt.title('Cropped Image')\n        plt.show()\n    \n    return new_image","46f7b229":"import os\ntry:\n    os.rmdir('..\/output\/kaggle\/working\/crop\/yes')\nexcept:\n    pass\ntry:\n    os.rmdir('..\/output\/kaggle\/working\/crop\/no')\nexcept:\n    pass\ntry:\n    os.makedirs('..\/output\/kaggle\/working\/crop\/yes')\nexcept:\n    pass\ntry:\n    os.makedirs('..\/output\/kaggle\/working\/crop\/no')\nexcept:\n    pass","82abc7cc":"\n\nex_img = cv2.imread('\/kaggle\/input\/brain-mri-images-for-brain-tumor-detection\/yes\/Y107.jpg')\nex_crop_img = crop_brain_contour(ex_img, True)\n\n\n\nfor file in no_files:\n    \n    ex_img = cv2.imread(file)\n    ex_crop_img = crop_brain_contour(ex_img, False)\n    filename='..\/output\/kaggle\/working\/crop\/no\/'+os.path.basename(file)\n    \n    cv2.imwrite(filename,ex_crop_img)\n    \nfor file in yes_files:\n    ex_img = cv2.imread(file)\n    ex_crop_img = crop_brain_contour(ex_img, False)\n    cv2.imwrite('..\/output\/kaggle\/working\/crop\/yes\/'+os.path.basename(file),ex_crop_img)\n    ","01a5d237":"import glob\nno_files_crop=[]\nyes_files_crop=[]\nfor file in glob.glob(\"..\/output\/kaggle\/working\/crop\/no\/*.jpg\"):\n    no_files_crop.append(file)\nfor file in glob.glob(\"..\/output\/kaggle\/working\/crop\/yes\/*.jpg\"):\n    yes_files_crop.append(file)\n        ","47bdc10c":"df=pd.DataFrame(columns=['filename','class'])\nfor file in no_files_crop:\n    df=df.append({'filename':file,'class':'no'},ignore_index=True)\n\nfor file in yes_files_crop:\n    df=df.append({'filename':file,'class':'yes'},ignore_index=True)","0bdbbe86":"from sklearn.utils import shuffle\ndf_shuffle=shuffle(df)","70c2eca5":"df_shuffle.groupby(['class']).count().hist()","c1c3dc00":"from sklearn.model_selection import train_test_split\n\nX_train,X_=train_test_split(df_shuffle,test_size=0.2,random_state=0)\n\nX_test,X_val=train_test_split(X_,test_size=0.2,random_state=0)\n\n\n","a32f6a86":"X_train.groupby(['class']).count()","70f85da1":"X_val.groupby(['class']).count()","f4119677":"X_train","a6527c39":"from tensorflow.keras.preprocessing.image import ImageDataGenerator\n\nimg_generator=ImageDataGenerator(rescale=1\/255)\n\ntrain_it = img_generator.flow_from_dataframe(X_train, class_mode='binary',\n                                             featurewise_std_normalization=True,\n                                             image_size=(256, 256))\ntest_it = img_generator.flow_from_dataframe(X_test, class_mode='binary',image_size=(256, 256),featurewise_std_normalization=True)\nval_it = img_generator.flow_from_dataframe(X_val, class_mode='binary',image_size=(256, 256),featurewise_std_normalization=True)","83f861e7":"import matplotlib.pyplot as plt\n\nfig,ax=plt.subplots(2,2,figsize=(6,6))\n\nimages,labels = train_it.next()\nx=0\ny=0\nfor i in range(0,16):\n    image = images[i]\n    if y<2 and x<2:\n        ax[y][x].imshow(image)\n    if x>2:\n        y=y+1\n        x=0\n    x=x+1\nplt.show()","ac1c1eec":"\n# example of tending the vgg16 model\nfrom keras.applications.vgg16 import VGG16\nfrom keras.models import Model\nfrom keras.layers import Dense\nfrom keras.layers import Flatten\nfrom keras.layers import BatchNormalization\nfrom keras.layers import Dropout\n\n# load model without classifier layers\nvgg = VGG16(include_top=False, input_shape=(256, 256, 3))\n# add new classifier layers\nflat1 = Flatten()(vgg.output)\ndropout = Dropout(0.5)(flat1)\ndense1 = Dense(1024, activation='relu')(flat1)\nbatch =  BatchNormalization()(dense1)\ndense2 = Dense(1024, activation='relu')(batch)\ndropout = Dropout(0.5)(dense2)\noutput = Dense(1, activation='sigmoid')(dropout)\n# define new model\nmodel = Model(inputs=vgg.inputs, outputs=output)\n# summarize\nmodel.summary()\n\nfor layer in vgg.layers:\n    layer.trainable=False\n\nmodel.compile(loss='binary_crossentropy',optimizer='adam',metrics=['accuracy'])","47a0144c":"from tensorflow.keras.callbacks import ReduceLROnPlateau\nreduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.2,\n                              patience=2)\ncallbacks=[reduce_lr]","64b74c84":"#model.fit_generator(train_it, epochs=30,steps_per_epoch=5, \n#                    validation_data=val_it, validation_steps=3,callbacks=callbacks)","4b15f547":"if os.path.isfile('\/kaggle\/working\/model.h5'):\n    model.load_weights(\"\/kaggle\/working\/model.h5\")\nelse:\n    model.fit_generator(train_it, epochs=180,steps_per_epoch=5, \n                    validation_data=val_it, validation_steps=3,callbacks=callbacks)","5c63853b":"model.save_weights('\/kaggle\/working\/model.h5')","702c2ec7":"scores=model.evaluate_generator(generator=test_it,steps=10)","520fcb4b":"print(\"Accuracy = \", scores[1])","d0b1c612":"df_shuffle","4ab14253":"df_yes=df_shuffle[df_shuffle['class']=='yes']\nname=list(df_yes.iloc[1:2,:]['filename'])[0]\nprint(name)\nex_img = cv2.imread(name)\nex_img = cv2.resize(ex_img,(256,256))\nplt.imshow(ex_img)\n\nfrom tensorflow.keras.preprocessing import image\nfrom keras.applications.vgg16 import preprocess_input\n\nx_reshape = ex_img.reshape((1, ex_img.shape[0],ex_img.shape[1], ex_img.shape[2]))\n\nimage = preprocess_input(x_reshape)\n\nmodel.predict(image)","61d06d76":"df_no=df_shuffle[df_shuffle['class']=='no']\nname=list(df_no.iloc[1:2,:]['filename'])[0]\nprint(name)\nex_img = cv2.imread(name)\nex_img = cv2.resize(ex_img,(256,256))\nplt.imshow(ex_img)\n\nfrom tensorflow.keras.preprocessing import image\nfrom keras.applications.vgg16 import preprocess_input\n\nx_reshape = ex_img.reshape((1, ex_img.shape[0],ex_img.shape[1], ex_img.shape[2]))\n\nimage = preprocess_input(x_reshape)\n\nmodel.predict(image)","371f59f7":"y_pred=[]\ny_true=[]\n\n\nfor i,r in df_shuffle.iterrows():\n    ex_img = cv2.imread(r['filename'])\n    ex_img = cv2.resize(ex_img,(256,256))\n    plt.imshow(ex_img)\n\n    from tensorflow.keras.preprocessing import image\n    from keras.applications.vgg16 import preprocess_input\n\n    x_reshape = ex_img.reshape((1, ex_img.shape[0],ex_img.shape[1], ex_img.shape[2]))\n\n    image = preprocess_input(x_reshape)\n    \n    pred=model.predict(image)\n    \n    y_true.append(r['class'])\n    \n\n    \n \n    y_pred.extend(pred[0])\n   ","58167a62":"y_pred_=[int(y>0.2) for y in y_pred]","5f1eff00":"y_test=[1 if x=='yes' else 0 for x in y_true]","7a160946":"from sklearn.metrics import classification_report\nprint(classification_report(y_test,y_pred_))","aebf64e3":"from sklearn.metrics import confusion_matrix\nconfusion_matrix(y_test,y_pred_)","3c0011d8":"def get_xai(x):\n    \n    \n    x=x\/255\n    x_ = np.expand_dims(x, axis=0)\n        \n\n    y_pred = model.predict(x_)\n    \n    print('pred',y_pred)\n    last_conv_layer = model.get_layer('block5_conv3')\n    argmax = np.argmax(y_pred[0])\n    print(argmax)\n    output = model.output[:, argmax]\n    print(output)\n    print(last_conv_layer.output)\n    grads = K.gradients(output, last_conv_layer.output)[0]\n\n    #tf.print(grads)\n    pooled_grads = K.mean(grads, axis=(0, 1, 2))\n\n\n\n\n    iterate = K.function([model.input], [pooled_grads, last_conv_layer.output[0]])\n\n\n\n    from keras.applications.vgg16 import preprocess_input\n    #x = preprocess_input(x)\n    #print( pooled_grads_value[pooled_grads_value>0])\n\n    pooled_grads_value, conv_layer_output_value = iterate([x_])\n\n\n    for i in range(512):\n        conv_layer_output_value[:, :, i] *= pooled_grads_value[i]\n\n    heatmap = np.mean(conv_layer_output_value, axis=-1)\n    heatmap = np.maximum(heatmap, 0)\n    heatmap \/= np.max(heatmap)\n    #plt.matshow(heatmap)\n    #plt.show()\n    import cv2\n    heatmap = cv2.resize(heatmap, (x.shape[1], x.shape[0]))\n    heatmap = np.uint8(255 * heatmap)\n    heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)\n    hif = .05\n    superimposed_img = heatmap * hif + x\n    from matplotlib.pyplot import figure\n    plt.figure(figsize=(5, 5))\n    #fig, ax =figure(figsize=(10, 2))\n    #ax.imshow(random.rand(8, 90), interpolation='nearest')\n    plt.imshow(superimposed_img)\n    #plt.axis('off')\n    plt.show()\n    \ndef get_heatmap(x):\n    \n    \n    x=x\/255\n    x_ = np.expand_dims(x, axis=0)\n        \n\n    y_pred = model.predict(x_)\n    \n   \n    last_conv_layer = model.get_layer('block5_conv3')\n    argmax = np.argmax(y_pred[0])\n    \n    output = model.output[:, argmax]\n   \n    grads = K.gradients(output, last_conv_layer.output)[0]\n\n    #tf.print(grads)\n    pooled_grads = K.mean(grads, axis=(0, 1, 2))\n\n\n\n\n    iterate = K.function([model.input], [pooled_grads, last_conv_layer.output[0]])\n\n\n\n    from keras.applications.vgg16 import preprocess_input\n    #x = preprocess_input(x)\n    #print( pooled_grads_value[pooled_grads_value>0])\n\n    pooled_grads_value, conv_layer_output_value = iterate([x_])\n\n\n    for i in range(512):\n        conv_layer_output_value[:, :, i] *= pooled_grads_value[i]\n\n    heatmap = np.mean(conv_layer_output_value, axis=-1)\n    heatmap = np.maximum(heatmap, 0)\n    heatmap \/= np.max(heatmap)\n    #plt.matshow(heatmap)\n    #plt.show()\n    import cv2\n    heatmap = cv2.resize(heatmap, (x.shape[1], x.shape[0]))\n    heatmap = np.uint8(255 * heatmap)\n    heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)\n    return heatmap","1fa9a5ab":"df_yes=df_shuffle[df_shuffle['class']=='yes']\nname=list(df_yes.iloc[1:2,:]['filename'])[0]\nprint(name)\nex_img = cv2.imread(name)\nex_img = cv2.resize(ex_img,(256,256))\nplt.imshow(ex_img)\nget_xai(ex_img)","e6458b38":"###from tqdm import tqdm\n\n###images=[]\n###predictions=[]\n\n\n###for i,r in tqdm(df_shuffle.iterrows()):\n###    ex_img = cv2.imread(r['filename'])\n###    ex_img = cv2.resize(ex_img,(256,256))\n###    plt.imshow(ex_img)\n\n###    from tensorflow.keras.preprocessing import image\n###    from keras.applications.vgg16 import preprocess_input\n\n###    x_reshape = ex_img.reshape((1, ex_img.shape[0],ex_img.shape[1], ex_img.shape[2]))\n\n###    image = preprocess_input(x_reshape)\n    \n###    pred=model.predict(image)\n###    images.append(get_heatmap(ex_img).flatten())\n###    predictions.extend(pred[0])","2bc06749":"### import csv\n\n### df_shuffle.to_csv('\/kaggle\/working\/df.csv')\n\n### with open('\/kaggle\/working\/maps.csv', 'wb') as images:\n###    wr = csv.writer(myfile, quoting=csv.QUOTE_ALL)\n###    wr.writerow(mylist)","af560677":"## Class Balance","fd2240ec":"## Saving maps","1f882d8e":"## Train model","0dc59fe7":"## Show images","0f3915d6":"## Crop Image","3c6d9f59":"### Reading Files","08786e2f":"## Test Predictions","da58a377":"## Machine Learning Explainable","416e590a":"## Test Accuracy"}}