{"cell_type":{"ceb3024c":"code","596d67eb":"code","645b8cde":"code","28ccf793":"code","5d776ef3":"code","da5d5cf2":"code","933a1d0c":"code","1c92a1d3":"code","a8aeb893":"code","96c5b5af":"markdown","2e583707":"markdown","b7947bc9":"markdown","ead9a3ac":"markdown","457a5533":"markdown","38e8fd34":"markdown","30d8f9d2":"markdown","69c8226a":"markdown","c73a7a85":"markdown","ea428217":"markdown","6e0cc9fa":"markdown"},"source":{"ceb3024c":"!wget -O weather-stations20140101-20141231.csv https:\/\/cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud\/IBMDeveloperSkillsNetwork-ML0101EN-SkillsNetwork\/labs\/Module%204\/data\/weather-stations20140101-20141231.csv","596d67eb":"import csv\nimport pandas as pd\nimport numpy as np\n\nfilename='weather-stations20140101-20141231.csv'\n\n#Read csv\npdf = pd.read_csv(filename)\npdf.head(5)","645b8cde":"pdf = pdf[pd.notnull(pdf[\"Tm\"])]\npdf = pdf.reset_index(drop=True)\npdf.head(5)","28ccf793":"from mpl_toolkits.basemap import Basemap\nimport matplotlib.pyplot as plt\nfrom pylab import rcParams\n%matplotlib inline\nrcParams['figure.figsize'] = (14,10)\n\nllon=-140\nulon=-50\nllat=40\nulat=65\n\npdf = pdf[(pdf['Long'] > llon) & (pdf['Long'] < ulon) & (pdf['Lat'] > llat) &(pdf['Lat'] < ulat)]\n\nmy_map = Basemap(projection='merc',\n            resolution = 'l', area_thresh = 1000.0,\n            llcrnrlon=llon, llcrnrlat=llat, #min longitude (llcrnrlon) and latitude (llcrnrlat)\n            urcrnrlon=ulon, urcrnrlat=ulat) #max longitude (urcrnrlon) and latitude (urcrnrlat)\n\nmy_map.drawcoastlines()\nmy_map.drawcountries()\n# my_map.drawmapboundary()\nmy_map.fillcontinents(color = 'white', alpha = 0.3)\nmy_map.shadedrelief()\n\n# To collect data based on stations        \n\nxs,ys = my_map(np.asarray(pdf.Long), np.asarray(pdf.Lat))\npdf['xm']= xs.tolist()\npdf['ym'] =ys.tolist()\n\n#Visualization1\nfor index,row in pdf.iterrows():\n#   x,y = my_map(row.Long, row.Lat)\n   my_map.plot(row.xm, row.ym,markerfacecolor =([1,0,0]),  marker='o', markersize= 5, alpha = 0.75)\n#plt.text(x,y,stn)\nplt.show()\n\n","5d776ef3":"from sklearn.cluster import DBSCAN\nimport sklearn.utils\nfrom sklearn.preprocessing import StandardScaler\nsklearn.utils.check_random_state(1000)\nClus_dataSet = pdf[['xm','ym']]\nClus_dataSet = np.nan_to_num(Clus_dataSet)\nClus_dataSet = StandardScaler().fit_transform(Clus_dataSet)\n\n# Compute DBSCAN\ndb = DBSCAN(eps=0.15, min_samples=10).fit(Clus_dataSet)\ncore_samples_mask = np.zeros_like(db.labels_, dtype=bool)\ncore_samples_mask[db.core_sample_indices_] = True\nlabels = db.labels_\npdf[\"Clus_Db\"]=labels\n\nrealClusterNum=len(set(labels)) - (1 if -1 in labels else 0)\nclusterNum = len(set(labels)) \n\n\n# A sample of clusters\npdf[[\"Stn_Name\",\"Tx\",\"Tm\",\"Clus_Db\"]].head(5)","da5d5cf2":"set(labels)","933a1d0c":"from mpl_toolkits.basemap import Basemap\nimport matplotlib.pyplot as plt\nfrom pylab import rcParams\n%matplotlib inline\nrcParams['figure.figsize'] = (14,10)\n\nmy_map = Basemap(projection='merc',\n            resolution = 'l', area_thresh = 1000.0,\n            llcrnrlon=llon, llcrnrlat=llat, #min longitude (llcrnrlon) and latitude (llcrnrlat)\n            urcrnrlon=ulon, urcrnrlat=ulat) #max longitude (urcrnrlon) and latitude (urcrnrlat)\n\nmy_map.drawcoastlines()\nmy_map.drawcountries()\n#my_map.drawmapboundary()\nmy_map.fillcontinents(color = 'white', alpha = 0.3)\nmy_map.shadedrelief()\n\n# To create a color map\ncolors = plt.get_cmap('jet')(np.linspace(0.0, 1.0, clusterNum))\n\n\n\n#Visualization1\nfor clust_number in set(labels):\n    c=(([0.4,0.4,0.4]) if clust_number == -1 else colors[np.int(clust_number)])\n    clust_set = pdf[pdf.Clus_Db == clust_number]                    \n    my_map.scatter(clust_set.xm, clust_set.ym, color =c,  marker='o', s= 20, alpha = 0.85)\n    if clust_number != -1:\n        cenx=np.mean(clust_set.xm) \n        ceny=np.mean(clust_set.ym) \n        plt.text(cenx,ceny,str(clust_number), fontsize=25, color='red',)\n        print (\"Cluster \"+str(clust_number)+', Avg Temp: '+ str(np.mean(clust_set.Tm)))","1c92a1d3":"from sklearn.cluster import DBSCAN\nimport sklearn.utils\nfrom sklearn.preprocessing import StandardScaler\nsklearn.utils.check_random_state(1000)\nClus_dataSet = pdf[['xm','ym','Tx','Tm','Tn']]\nClus_dataSet = np.nan_to_num(Clus_dataSet)\nClus_dataSet = StandardScaler().fit_transform(Clus_dataSet)\n\n# Compute DBSCAN\ndb = DBSCAN(eps=0.3, min_samples=10).fit(Clus_dataSet)\ncore_samples_mask = np.zeros_like(db.labels_, dtype=bool)\ncore_samples_mask[db.core_sample_indices_] = True\nlabels = db.labels_\npdf[\"Clus_Db\"]=labels\n\nrealClusterNum=len(set(labels)) - (1 if -1 in labels else 0)\nclusterNum = len(set(labels)) \n\n\n# A sample of clusters\npdf[[\"Stn_Name\",\"Tx\",\"Tm\",\"Clus_Db\"]].head(5)","a8aeb893":"from mpl_toolkits.basemap import Basemap\nimport matplotlib.pyplot as plt\nfrom pylab import rcParams\n%matplotlib inline\nrcParams['figure.figsize'] = (14,10)\n\nmy_map = Basemap(projection='merc',\n            resolution = 'l', area_thresh = 1000.0,\n            llcrnrlon=llon, llcrnrlat=llat, #min longitude (llcrnrlon) and latitude (llcrnrlat)\n            urcrnrlon=ulon, urcrnrlat=ulat) #max longitude (urcrnrlon) and latitude (urcrnrlat)\n\nmy_map.drawcoastlines()\nmy_map.drawcountries()\n#my_map.drawmapboundary()\nmy_map.fillcontinents(color = 'white', alpha = 0.3)\nmy_map.shadedrelief()\n\n# To create a color map\ncolors = plt.get_cmap('jet')(np.linspace(0.0, 1.0, clusterNum))\n\n\n\n#Visualization1\nfor clust_number in set(labels):\n    c=(([0.4,0.4,0.4]) if clust_number == -1 else colors[np.int(clust_number)])\n    clust_set = pdf[pdf.Clus_Db == clust_number]                    \n    my_map.scatter(clust_set.xm, clust_set.ym, color =c,  marker='o', s= 20, alpha = 0.85)\n    if clust_number != -1:\n        cenx=np.mean(clust_set.xm) \n        ceny=np.mean(clust_set.ym) \n        plt.text(cenx,ceny,str(clust_number), fontsize=25, color='red',)\n        print (\"Cluster \"+str(clust_number)+', Avg Temp: '+ str(np.mean(clust_set.Tm)))","96c5b5af":"### As you can see for outliers, the cluster label is -1\n","2e583707":"# 1-Download data\n\n","b7947bc9":"# 7- Clustering of stations based on their location, mean, max, and min Temperature\n\n### In this section we re-run DBSCAN, but this time on a 5-dimensional dataset:\n","ead9a3ac":"# 4-Visualization\n\n### Visualization of stations on map using basemap package. The matplotlib basemap toolkit is a library for plotting 2D data on maps in Python. Basemap does not do any plotting on it\u2019s own, but provides the facilities to transform coordinates to a map projections. \n\n### Please notice that the size of each data points represents the average of maximum temperature for each station in a year. \n","457a5533":"# 5- Clustering of stations based on their location i.e. Lat & Lon\n\n### **DBSCAN** form sklearn library can runs DBSCAN clustering from vector array or distance matrix. In our case, we pass it the Numpy array Clus_dataSet to find core samples of high density and expands clusters from them. \n","38e8fd34":"<h1 align=center> Weather Station Clustering using DBSCAN  <\/h1>\n<hr>\n\n### DBSCAN is specially very good for tasks like class identification on a spatial context. The wonderful attribute of DBSCAN algorithm is that it can find out any arbitrary shape cluster without getting affected by noise. For example, this following example cluster the location of weather stations in Canada.\n\n### DBSCAN can be used here, for instance, to find the group of stations which show the same weather condition. As you can see, it not only finds different arbitrary shaped clusters, can find the denser part of data-centered samples by ignoring less-dense areas or noises.\n\n\n### -  **Loading data**\n\n### -   **Overview data**\n### -   **Data cleaning**\n### -  **Data selection**\n### -  **Clustering**\n","30d8f9d2":"# 8- Visualization of clusters based on location and Temperture\n","69c8226a":"# About the dataset\n\n<h4 align = \"center\">\nEnvironment Canada    \nMonthly Values for July - 2015\t\n<\/h4>\n<html>\n<head>\n<style>\ntable {\n    font-family: arial, sans-serif;\n    border-collapse: collapse;\n    width: 100%;\n}\n\ntd, th {\n    border: 1px solid #dddddd;\n    text-align: left;\n    padding: 8px;\n}\n\ntr:nth-child(even) {\n    background-color: #dddddd;\n}\n<\/style>\n\n<\/head>\n<body>\n\n<table>\n  <tr>\n    <th>Name in the table<\/th>\n    <th>Meaning<\/th>\n  <\/tr>\n  <tr>\n    <td><font color = \"green\"><strong>Stn_Name<\/font><\/td>\n    <td><font color = \"green\"><strong>Station Name<\/font<\/td>\n  <\/tr>\n  <tr>\n    <td><font color = \"green\"><strong>Lat<\/font><\/td>\n    <td><font color = \"green\"><strong>Latitude (North+, degrees)<\/font><\/td>\n  <\/tr>\n  <tr>\n    <td><font color = \"green\"><strong>Long<\/font><\/td>\n    <td><font color = \"green\"><strong>Longitude (West - , degrees)<\/font><\/td>\n  <\/tr>\n  <tr>\n    <td>Prov<\/td>\n    <td>Province<\/td>\n  <\/tr>\n  <tr>\n    <td>Tm<\/td>\n    <td>Mean Temperature (\u00b0C)<\/td>\n  <\/tr>\n  <tr>\n    <td>DwTm<\/td>\n    <td>Days without Valid Mean Temperature<\/td>\n  <\/tr>\n  <tr>\n    <td>D<\/td>\n    <td>Mean Temperature difference from Normal (1981-2010) (\u00b0C)<\/td>\n  <\/tr>\n  <tr>\n    <td><font color = \"black\">Tx<\/font><\/td>\n    <td><font color = \"black\">Highest Monthly Maximum Temperature (\u00b0C)<\/font><\/td>\n  <\/tr>\n  <tr>\n    <td>DwTx<\/td>\n    <td>Days without Valid Maximum Temperature<\/td>\n  <\/tr>\n  <tr>\n    <td><font color = \"black\">Tn<\/font><\/td>\n    <td><font color = \"black\">Lowest Monthly Minimum Temperature (\u00b0C)<\/font><\/td>\n  <\/tr>\n  <tr>\n    <td>DwTn<\/td>\n    <td>Days without Valid Minimum Temperature<\/td>\n  <\/tr>\n  <tr>\n    <td>S<\/td>\n    <td>Snowfall (cm)<\/td>\n  <\/tr>\n  <tr>\n    <td>DwS<\/td>\n    <td>Days without Valid Snowfall<\/td>\n  <\/tr>\n  <tr>\n    <td>S%N<\/td>\n    <td>Percent of Normal (1981-2010) Snowfall<\/td>\n  <\/tr>\n  <tr>\n    <td><font color = \"green\"><strong>P<\/font><\/td>\n    <td><font color = \"green\"><strong>Total Precipitation (mm)<\/font><\/td>\n  <\/tr>\n  <tr>\n    <td>DwP<\/td>\n    <td>Days without Valid Precipitation<\/td>\n  <\/tr>\n  <tr>\n    <td>P%N<\/td>\n    <td>Percent of Normal (1981-2010) Precipitation<\/td>\n  <\/tr>\n  <tr>\n    <td>S_G<\/td>\n    <td>Snow on the ground at the end of the month (cm)<\/td>\n  <\/tr>\n  <tr>\n    <td>Pd<\/td>\n    <td>Number of days with Precipitation 1.0 mm or more<\/td>\n  <\/tr>\n  <tr>\n    <td>BS<\/td>\n    <td>Bright Sunshine (hours)<\/td>\n  <\/tr>\n  <tr>\n    <td>DwBS<\/td>\n    <td>Days without Valid Bright Sunshine<\/td>\n  <\/tr>\n  <tr>\n    <td>BS%<\/td>\n    <td>Percent of Normal (1981-2010) Bright Sunshine<\/td>\n  <\/tr>\n  <tr>\n    <td>HDD<\/td>\n    <td>Degree Days below 18 \u00b0C<\/td>\n  <\/tr>\n  <tr>\n    <td>CDD<\/td>\n    <td>Degree Days above 18 \u00b0C<\/td>\n  <\/tr>\n  <tr>\n    <td>Stn_No<\/td>\n    <td>Climate station identifier (first 3 digits indicate   drainage basin, last 4 characters are for sorting alphabetically).<\/td>\n  <\/tr>\n  <tr>\n    <td>NA<\/td>\n    <td>Not Available<\/td>\n  <\/tr>\n\n<\/table>\n\n<\/body>\n<\/html>\n","c73a7a85":"# 2- Load the dataset\n\n### We will import the .csv then we creates the columns for year, month and day.\n","ea428217":"# 6- Visualization of clusters based on location\n\n### Now, we can visualize the clusters using basemap:\n","6e0cc9fa":"# 3-Cleaning\n\n### Lets remove rows that dont have any value in the **Tm** field.\n"}}