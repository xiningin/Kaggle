{"cell_type":{"8f40eeb7":"code","e256d43a":"code","47162ca7":"code","3613d5db":"code","7a6cf3a1":"code","45fd0e54":"code","039607cc":"code","dab1b17b":"code","15de4d83":"code","c20600de":"code","a372296d":"code","880bb5e5":"code","0e297c45":"code","9e63c01a":"code","4faf62aa":"code","c5cdaa63":"code","c36e82fb":"code","f6950693":"code","5a6aebf3":"code","86c7be35":"code","9a90f409":"markdown","13467851":"markdown","7fe32587":"markdown","f69d306e":"markdown","9f18b914":"markdown","02d12f88":"markdown","8a6e1b6f":"markdown","e8b26eaa":"markdown","79ea16d3":"markdown","39901847":"markdown","d7f385c2":"markdown","85d9380c":"markdown","f4f8ffab":"markdown","ee3a8417":"markdown","26c51eec":"markdown","e48f4c0a":"markdown","d33f8bc9":"markdown","bcb86f79":"markdown","b3e2be4c":"markdown","1c93b323":"markdown","fd856499":"markdown","00911ddf":"markdown","bd73e098":"markdown","a91197d3":"markdown"},"source":{"8f40eeb7":"import pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom sklearn.utils import shuffle # to shuffle the training and validation data\nimport abc\nfrom abc import ABC # abstract base class (to define interfaces in python)\nimport numpy as np\n\nvoting_mode = \"Democracy\"\n#voting_mode = \"Aristocracy\"\n\nvalidation_ratio = 0.2 # 0<x<1","e256d43a":"data = pd.read_csv(\"..\/input\/titanic\/train.csv\")\ndata = shuffle(data)\nval_off = int(len(data)*(1-validation_ratio))\ntrain_data = data[0:val_off]\nval_data = data[val_off:]\n","47162ca7":"val_target = val_data[\"Survived\"].tolist()\nval_data = val_data.drop([\"Survived\"], axis=1)\n\nprint(\"The labeled data has been randomly distributed to %i datapoints for training, and %i datapoints for validation. A total of %i\/891 with %i duplicates.\"%(len(train_data), len(val_data), len(train_data)+len(val_data), len(pd.merge(train_data, val_data, how='inner'))))","3613d5db":"test_data = pd.read_csv(\"..\/input\/titanic\/test.csv\")\n\nprint(\"Testing data loaded. %i\/418.\" % len(test_data))\n\nprint(\"Loading complete.\")","7a6cf3a1":"votes = []\nvalidation_scores = []\ncomponents = []","45fd0e54":"class ComponentI(ABC):\n    \n    @abc.abstractmethod\n    def _name(self):\n        pass\n    \n    # Gets labeled data\n    # Returns nothing\n    @abc.abstractmethod\n    def train(self, df):\n        pass\n    \n    # Gets unlabeled data\n    # Returns [int] with prediction\n    @abc.abstractmethod\n    def test(self, df):\n        pass","039607cc":"import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch import cuda\nfrom torch.utils.data import Dataset, DataLoader\nimport torch.optim as optim","dab1b17b":"def sex_to_float(sex):\n    ret = 1.\n    if sex == \"male\":\n        ret = 0.\n    return ret\n\ndef float_to_2d(x):\n    #return np.array(x).astype(\"double\").reshape(1)\n    ret = (1.,0.)\n    if x == 1:\n        ret = (0., 1.)\n    return np.array(ret).astype(\"double\")\n\nclass TitanicDataset(Dataset):\n    def __init__(self, df, features, start=0, end=\"none\", indexed=False, labeled=False):\n        data_frame = df[features]\n        labels_frame = \"unknown\"\n        \n        if labeled:\n            labels_frame = df[[\"Survived\"]]\n            \n                \n        if end == \"none\":\n            data_frame = data_frame[start:]\n            labels_frame = labels_frame[start:]\n        else:\n            data_frame = data_frame[start:end]\n            labels_frame = labels_frame[start:end]\n        \n        self.inputs = []\n        self.labels = []\n        \n        for idx in range(len(data_frame)):\n            inputs = data_frame.iloc[idx,0:]\n            inputs[\"Sex\"] = sex_to_float(inputs[\"Sex\"])\n            inputs = np.array(inputs)\n            inputs = np.nan_to_num(inputs.astype(\"double\"))\n            if labeled == False:\n                label = []\n            else:\n                label = float_to_2d(labels_frame.iloc[idx][\"Survived\"])  \n            \n            self.inputs.append(inputs)\n            self.labels.append(label)\n        \n        self.inputs = torch.tensor(self.inputs)\n        self.labels = torch.tensor(self.labels)\n        \n        self.inputs = self.inputs.cuda()\n        self.labels = self.labels.cuda()\n\n            \n        if indexed:\n            self.PassengerId = torch.tensor(pd.read_csv(path)[[\"PassengerId\"]][\"PassengerId\"])\n        \n        \n        \n    def __len__(self):\n        return len(self.inputs)\n    \n    def __getitem__(self, idx):\n    \n        if torch.is_tensor(idx):\n            idx = idx.tolist()\n        \n        return self.inputs[idx], self.labels[idx]\n            ","15de4d83":"class Net1(nn.Module):\n    def __init__(self, input_count):\n        super(Net1, self).__init__()\n        self.fc1 = nn.Linear(input_count, 200)\n        self.fc2 = nn.Linear(200, 100)\n        self.fc3 = nn.Linear(100, 2)\n        self.deepthink = nn.Linear(100,100)\n        self.fc4 = nn.Linear(2,2)\n\n    def forward(self, x):\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = F.relu(self.deepthink(x))\n        x = F.relu(self.fc3(x))            \n        x = F.softmax(self.fc4(x), dim=1)\n        return x\n    \n\n\n","c20600de":"class PytorchSimpleNNComponent(ComponentI):\n    def __init__(self, apx=\"\"):\n        self.name = \"Pytorch Simple NN\" + apx\n        self.epochs = 50\n        self.features = [\"Pclass\", \"Sex\", \"Age\", \"SibSp\", \"Parch\", \"Fare\"]\n        self.net = Net1(len(self.features))\n        self.net = self.net.double()\n        self.net.cuda()\n        self.criterion = nn.MSELoss()\n        self.optimizer = optim.Adam(self.net.parameters(), lr=0.0001)\n        \n    def set_param(self, param, obj):\n        if param == \"net\":\n            self.net = obj\n            self.net.cuda()\n        elif param == \"epochs\":\n            self.epochs = obj\n        elif param == \"criterion\":\n            self.criterion = obj\n        elif param == \"optimizer\":\n            self.optimizer = obj\n        \n        else:\n            raise Exception(\"Invalid Argument\", \"Unknown parameter %s\"%param)\n    \n    def _name(self):\n        return self.name\n    \n    def train(self, df):\n        tds = TitanicDataset(df, self.features, labeled=True)\n        train_loader = torch.utils.data.DataLoader(tds, batch_size=50, shuffle=True)\n\n        for epoch in range(self.epochs):  # loop over the dataset multiple times\n    \n            running_loss = 0.0\n            for i, data in enumerate(train_loader, 0):\n                # get the inputs; data is a list of [inputs, labels]\n                inputs, labels = data\n                inputs = inputs.cuda()\n                labels = labels.cuda()\n                # zero the parameter gradients\n                self.optimizer.zero_grad()\n                # forward + backward + optimize\n                outputs = self.net(inputs)\n                #print(\"o\",outputs)\n                #print(\"l\", labels)\n                loss = self.criterion(outputs, labels)\n                #print(loss)\n                loss.backward()\n                self.optimizer.step()\n\n                # print statistics\n                running_loss += loss.item()\n                if i % 10 == 9 and epoch % 10 == 9:    # print every 100 mini-batches\n                    print('[%d, %5d] loss: %.3f' % (epoch + 1, i + 1, running_loss))\n                    running_loss = 0.0\n    \n    def test(self, df):\n        tds = TitanicDataset(df, self.features)\n        test_loader = torch.utils.data.DataLoader(tds, batch_size=4, shuffle=False)\n        ret = [] \n        \n        for data in test_loader:\n            inputs, _ = data\n            result = [torch.argmax(y) for y in self.net(inputs)]\n            for i in range(len(result)):\n                ret.append(int(result[i].item()))\n        \n        return ret\n    \n","a372296d":"for i in range(50):\n    basic = PytorchSimpleNNComponent(apx=str(i))\n    components.append(basic)","880bb5e5":"class GenderComponent(ComponentI):\n    def __init__(self):\n        pass\n    def _name(self):\n        return \"Genderer\"\n    \n    def train(self, df):\n        pass\n    \n    def test(self, df):\n        ret = []\n        for _, row in df.iterrows():\n            if row[\"Sex\"] == \"male\":\n                ret.append(0)\n            else:\n                ret.append(1)\n        return ret\n    \ngc = GenderComponent()\ncomponents.append(gc)","0e297c45":"class BadComponent(ComponentI):\n    def __init__(self):\n        pass\n    def _name(self):\n        return \"Bad\"\n    \n    def train(self, df):\n        pass\n    \n    def test(self, df):\n        ret = []\n        for _, row in df.iterrows():\n            ret.append(1)\n        return ret\n    \n# bc = BadComponent()\n# components.append(bc)","9e63c01a":"for c in components:\n    if not isinstance(c, ComponentI):\n        raise Exception(\"Error\", \"Component %s is not of interface ComponentI.\" % c._name()) \n        \nprint(\"All components are ok.\")","4faf62aa":"print(\"Begin Training:\")\nfor c in components:\n    print(\"\\tTraining: %s\"%c._name())\n    c.train(train_data)\n    print(\"\\t\\tDone.\")\nprint(\"Training complete\")","c5cdaa63":"print(\"Begin Validation:\")\nfor c in components:\n    res = c.test(val_data)\n    \n    # compute the score as how many percent are correct\n    correct = 0\n    for idx, x in enumerate(res):\n        if x == val_target[idx]:\n            correct += 1\n    score = correct \/ len(res)\n    \n    validation_scores.append(score)\n    print(\"\\t[%f]: %s\"%(score, c._name()))\n    \nprint(\"Validation complete.\")\n    ","c36e82fb":"for c in components:\n    votes.append(c.test(test_data))","f6950693":"if not (voting_mode == \"Democracy\" or voting_mode == \"Aristocracy\"):\n    raise Exception(\"Unknown voting mode.\",\"The voting mode must be Democracy or Aristocracy.\")\n\nif voting_mode == \"Democracy\" and len(components)%2 == 0:\n    idx = np.argmin(validation_scores)\n    votes.pop(idx)\n    print(\"Throwing out %s.\" % components[idx]._name())\n    ","5a6aebf3":"result = []\n\n# go through all passengers in test_data\nfor idx in range(len(test_data)):\n    # counting the votes\n    dead = 0\n    alive = 0\n    \n    # with weigth one on every vote in Democracy mode\n    weight = 1\n    \n    # go through all components asking for their opinion on this passenger\n    for c_idx, vote in enumerate(votes):\n        \n        if voting_mode == \"Aristocracy\":\n            weight = validation_scores[c_idx]\n        \n        if vote[idx] == 0:\n            dead += weight\n        else:\n            alive += weight\n    \n    if dead > alive:\n        result.append(0)\n    elif alive > dead:\n        result.append(1)\n    else:\n        # if the votes are even (only possible but unlikely in Aristocracy), decide randomly.\n        result.append(np.random.choice(1,1))\n        \n","86c7be35":"output = pd.DataFrame({'PassengerId': test_data.PassengerId, 'Survived': result})\noutput.to_csv('voting_submission.csv', index=False)\nprint(\"Your submission was successfully saved!\")\n","9a90f409":"# Validation\n\nRun the val_data and compare the result to val_target. The score is the ratio of correct\/total.","13467851":"# Save for submission","7fe32587":"# Loading\n\nThe data will be presented to you in the following form:\n\n* **train_data** is a pandas DataFrame that contains a subset of the data in train.csv\n* **val_data** is a pandas DataFrame that contains the rest of the data in train.csv without the \"Survived\" column\n* **val_target** is a [int] containing the \"Survived\" column\n* **test_data** is a pandas DataFrame that contains the data in test.csv","f69d306e":"# Defining the ComponentI interface\n\n## _name()\n\nReturns a string with the name of the component for prettier summary at the end.\n\n## train(df)\n\nWill get passed a DataFrame with labeled data for supervised machine learning. Trains the model.\n\n\n## test(df)\n\nWill get passed an unlabeled dataset. Returns the prediciton of the model as [int], with 1 for alive, 0 for dead. This is used for validation and to submit the final prediction on the test data.","9f18b914":"Split the validation data into data and known results.","02d12f88":"## Parsing\nHere the data gets parsed into a neat format for the loaders.","8a6e1b6f":"# Vote\n\n","e8b26eaa":"Load the train.csv, shuffle it and split the entries for training and validation.","79ea16d3":"## Create a bunch of instances for a true democracy voting","39901847":"# Training\n\nHere the modules are trained.","d7f385c2":"## Net1\nDefining some NN","85d9380c":"# Prepare voting system\n\n\n## votes\n**votes** is a [[int]].\nFor every component it holds a list with the components predictions.\nThe prodictions are of the form as asked in the competition: 1 for alive, 0 for dead.\n\n## validation_scores\n**validation_scores** is a [double].\nIt holds the percentage of correct guesses for each component in the validation.\n\n## components\n**components** is a [ComponentI]. \nIt holds objects of the different models partaking in the vote.","f4f8ffab":"# Checkup\n\nTo make sure that all components inherit ComponentI.","ee3a8417":"## Component\n\nThe component is defined with some basic parameters. It can be tuned with the set_param method.","26c51eec":"## Create some instances with different parameters","e48f4c0a":"# Pytorch Linear NN Component, simplified data","d33f8bc9":"<a id=\"mma\"><\/a>\n# Model Making Area\n\nHave fun.\n\n**Remember to add your model to the *components* list. They must inherit ComponentI.**","bcb86f79":"## GenderComponent\n\nExample that rates survival on gender: women survive, men die.","b3e2be4c":"# Titanic voting playground\n\n*Disclaimer: I am new to ML, so take my models with a grain of salt and feel free to give feedback if sth strikes you weird.*\n\nThis is a freely expandable solution to the titanic competition. The idea is to have multiple independent models all making their own predictions, and then merge their solutions to one final result. If you have three models predicting the outcome for passenger 883, and two say \"survives\" and one says \"does not survive\", then the resulting prediction will be \"survives\".\n\nTo add a new model to the voters, go to the [model making area](#mma) and define a new class inheriting ComponentI. This interface must have the following functions:\n* _name():string\n* train(df)\n* test(df):[double]\n\n where df means pandas DataFrame.\n\nAfter defining your component, you must create an instance and add it to the components list. All in all it should look like this:\n\n```python\nimport whatever.you.need\n\ndef MyComponent(ComponentI):\n    # your code here\n    \nc = MyComponent()\ncomponents.append(c)\n```\n\nOnce finished the model will automatically be trained, validated and its vote been taken into account. \n\nI will explain details on the procedure in the course of this notebook. If you have any questions, feel free to ask.","1c93b323":"# Preliminaries\n\n* Libraries needed for the voting system.\n* Flags and parameters.\n\n## voting_mode\n\nThere are two modes of voting:\n\n### Democracy\n\nHere every vote counts the same. The jury is always odd. If there is an even number of components, the weakest component will get kicked out based on its validation score.\n\n### Aristocracy\n\nThe jury members have different weights in their votes, based on their validation score. It does not matter if the number of components is odd or even. When the votes are counted, the validation scores of the members pro and con get summed up respectively, the party with higher resulting score wins. If the votes are equal within an accuracy of 0.00001 (which is eytremely unlikely), the prediction will be done randomly.\n\n\n## validation_ratio\n\nRatio to determine, how many of the data given in train.csv shall be used for training and how many for validation.","fd856499":"## Performing the vote","00911ddf":"## Checking the jury\n\nThe voting depends on the mode.\nIf the mode is democracy and the jury has an even number of member, the weakest member gets kicked out.","bd73e098":"# BadComponent\n\nAlways gives 1. Added for testing, usually not with components.","a91197d3":"# Predict\n\nCollect the votes from everyone."}}