{"cell_type":{"a1bc7ee4":"code","82ccb71a":"code","46ab530f":"code","e6702a86":"code","ef6e0ac4":"code","aae80efb":"code","f0de642a":"markdown","943ff9ac":"markdown","2c45a515":"markdown","22096373":"markdown","a8a03c5c":"markdown","64a7c007":"markdown","659b9729":"markdown","33fb37d7":"markdown"},"source":{"a1bc7ee4":"!python3 -m pip install -U git+https:\/\/github.com\/UCBerkeleySETI\/blimpy\n!python3 -m pip install -U git+https:\/\/github.com\/UCBerkeleySETI\/turbo_seti","82ccb71a":"import os\nimport glob\nfrom shutil import copyfile\nimport pylab as plt\n\nfrom blimpy import Waterfall\nimport turbo_seti.find_doppler.seti_event as turbo\nimport turbo_seti.find_event as find_event\nfrom turbo_seti.find_doppler.find_doppler import FindDoppler\nfrom turbo_seti.find_event.find_event_pipeline import find_event_pipeline\nfrom turbo_seti.find_event.plot_event_pipeline import plot_event_pipeline\n\n%matplotlib inline\n\nprint(\"All packages imported!\")","46ab530f":"### First, create a list of the coarse channel files for turboSETI to use ### \n\n#Location of the single coarse channel files\ninput_data_directory = '..\/input\/'\noutput_data_directory = '\/kaggle\/working\/'\n\nh5_list = []\n\n# Create a simple .lst file of the .h5 files in the data directory\nfor dirname, _, filenames in os.walk(input_data_directory):\n    for filename in filenames:\n        h5_list.append(os.path.join(dirname, filename))\n    \n# This writes the .h5 files into a .lst, as required by the find_event_pipeline:\nh5_list_path = os.path.join(output_data_directory,'h5_files.lst')\nwith open(h5_list_path, 'w') as f:\n    for h5_path in h5_list:\n        f.write(h5_path + '\\n')\n        \n# You don't have to print, but it's a good way to check that your list is in the correct order:\nf = open(h5_list_path, 'r')\nprint(f.read())\n\n### Now REALLY run turboSETI! ###\n\nfor file in h5_list:\n    doppler = FindDoppler(file,\n                      max_drift = 4, # Max drift rate = 4 Hz\/second\n                      snr = 10,      # Minimum signal to noise ratio = 10:1\n                      out_dir = output_data_directory # This is where the turboSETI output files will be stored.\n                     )\n    doppler.search()\n    \nprint('\\n===== All DAT files have been computed and a list of them has been constructed! =====')","e6702a86":"# Create a simple .lst file of the .dat files in the data directory, and \n# copy the .h5 files to the output directory so that find_event_pipeline can access them\ndat_list = []\nfor dirname, _, filenames in os.walk(output_data_directory):\n    for filename in filenames:\n        if filename[-4:] == '.dat':\n            dat_list.append(filename)\n\nfor dirname, _, filenames in os.walk(input_data_directory+'\/mars2020-single-coarse-chan-sequence\/'):\n    for filename in filenames:\n        if filename[-3:] == '.h5':\n            copyfile(input_data_directory+'\/mars2020-single-coarse-chan-sequence\/'+filename, output_data_directory+filename)\n              \n# This writes the .dat files into a .lst, as required by the find_event_pipeline:\ndat_list_path = os.path.join(output_data_directory, 'dat_files.lst')\nwith open(dat_list_path, 'w') as f:\n    for dat_path in dat_list:\n        f.write(dat_path + '\\n')\n\n# You don't have to print, but it's a good way to check that your list is in the correct order:\nwith open(dat_list_path, 'r') as f:\n    print(f.read())\nf.close()\n    \n# Using find_event_pipeline with filter threshold 3 to detect Voyager!\ncsvf_path = os.path.join(output_data_directory, 'found_event_table.csv')\nfind_event_pipeline(dat_list_path, \n                    filter_threshold = 3, \n                    number_in_cadence = len(dat_list), \n                    csv_name=csvf_path, \n                    saving=True)","ef6e0ac4":"plot_event_pipeline(csvf_path, # full path of the CSV file built by find_event_pipeline()\n                    h5_list_path, # full path of text file containing the list of .h5 files\n                    filter_spec='f{}'.format(3), # filter threshold\n                    user_validation=False,\n                    plot_dir=output_data_directory) # Non-interactive","aae80efb":"c = 3.0*(10**8)\nf = 8.4*(10**9)\nv1825 = 1000*18.7636948 #convert the velocities to m\/s \nv1855 = 1000*18.7835798\n\nv_avg = (v1825+v1855)\/2\ndur = 30.0*60.0\nv_dot = (v1855 - v1825)\/dur\ndrift_rate = -(c*v_dot)*(f)\/((c+v_avg)**2)\n    \nprint(\"Drift rate calculated between 18:25 and 18:55 UTC: {} Hz\/s\".format(drift_rate))","f0de642a":"### Data Analysis\n\nOne of the algorithms used by BL researchers is the Doppler drift search, which seeks out narrowband signals that drift in frequency due to relative motion between the Earth and the transmitter we are aiming to detect. This algorithm is implemented in software called turboSETI. For more information about the Doppler drift search technique, what turboSETI is and how to install it, (along with instructions on how to analyze a BL observation of Voyager 1!) check out Elan Lavie's great tutorial here: [Elan's Voyager Tutorial](https:\/\/mybinder.org\/v2\/gh\/elanlavie\/VoyagerTutorialRepository\/master?filepath=VoyagerTutorial.ipynb). \n\nAssuming you have now acquainted yourself with turboSETI and its component parts after reviewing Elan's tutorial, let's now move on to analyzing some Mars data! First let's install the packages **blimpy** (required for turboSETI), and **turboSETI** itself:","943ff9ac":"Now let's import the packages we need: ","2c45a515":"There you have it, a detection of the Mars2020 spacecraft! If you want to go even further with this, you can try calculating the predicted drift rate for the Mars2020 spacecraft based on the published trajectory on the JPL Horizons website, and compare it with the values in the find_event_pipeline() table generated above. Here's how it works...  \n\n###  Calculating Mars2020's Doppler Drift Rate  \n\nThe Doppler-shifted frequency of a source is given by the quation:  \n\n$f_o=\\frac{c+v_o}{c+v_s}f_s$ (1)  \n\nwhere:  \n\n$f_{o}$ = observer frequency of signal  \n$c$ = speed of light  \n$v_{o}$ = observer velocity  \n$v_{s}$ = source velocity  \n$f_{s}$ = actual frequency of signal source\n\nWhen two sources are accelerating relative to each other, they will also display a Doppler *drift* as their relative velocities change, and we can determine the value of the Doppler drift using the following equation, which is the time derivative of our original Doppler *shift* equation:  \n\n$\\frac{df_o}{dt} = \\frac{-c \\cdotp a}{(c + v_s)^2}f_s$ (2)  \n\nwhere the symbols represent the same quantities as in equation 1 except that:  \n\na = the relative acceleration between the two objects.  \n\nTo calculate the predicted value for the drift rate of Mars2020, go to JPL Horizons, and fill in the query fields as follows:  \n\n* Ephemeris Type: OBSERVER\n* Target Body: Mars2020 (spacecraft) (Perserverance)\n* Observer Location: Green Bank (GBT) [-9] ( 280\u00b009'36.7''E, 38\u00b025'59.3''N, 822.34 m )\n* Time Span: Start=2021-02-09, Stop=2021-02-13, Step=5 m\n* Table Settings: QUANTITIES=1,3,20\n* Display\/Output: default (formatted HTML)  \n\nThen press **Generate Ephemeris** and you should have a nice table listing all the information you will need to calculate an approximate drift rate!  \n\nTo calculate the drift rate, you would need to calculate the average velocity and acceleration of Mars2020 relative to Earth; to calculate these values, you need to look up the velocity of Mars2020 relative to Earth at the beginning of the observation and the velocity at the end of the observation. The relative velocities can be obtained by looking at the entries in the **deldot** column of the ephemeris table generated by JPL Horizons. The initial velocity can be found by identifying the deldot value for the row corresponding to Feb. 11, 2021, at 18:25 UTC, and the final velocity can be found in the row for Feb. 11, 2021, at 18:55 UTC. I've pasted below a block of code you can use to quickly calculate the drift rate and thus avoid having to pull out your pocket calculator; I've plugged in the initial and final velocity values to the variables **v1825** and **v1855**, and you can see the result by running the code block below.","22096373":"As you can see, we've calculated a predicted drift rate that agrees quite well with what find_event_pipeline() tells us that our measured drift rates are.  \n\nNow that we've analyzed our Mars2020 data, what's next, you might ask? In addition to detecting Mars2020, we also picked up signals that appear to be coming from spacecraft in orbit around Mars. If you want to try your hand at detecting these, go right ahead! To find the full Mars filterbank files, go here: http:\/\/blpd18.ssl.berkeley.edu\/gb_mars\/splices\/ (note that you will only want the ones ending with \".0000.fil\", as those have the proper frequency resolution), or you can download smaller chunks of data from the **blc** folders here: http:\/\/blpd18.ssl.berkeley.edu\/gb_mars\/ (again note that you will only want the **.0000.fil** files). Follow the instructions in this tutorial to download local copies of blimpy and turboSETI: https:\/\/github.com\/UCBerkeleySETI\/turbo_seti\/blob\/master\/tutorial\/turboSETI_tutorial.ipynb and of course refer to Elan's [Voyager tutorial](https:\/\/hub.gke2.mybinder.org\/user\/elanlavie-voyag-orialrepository-6ggp6578\/notebooks\/VoyagerTutorial.ipynb) (and this one) for instructions on how to analyze your data. Note that if you wish to look for the spacecraft in orbit around Mars, when you call find_event_pipeline(), you will need to add in the keyword argument **on_off_first = 'OFF'** since Mars is the off-source in this sequence of scans.\n\nHopefully you've enjoyed detecting your own \"Martians\" in this tutorial and getting a taste of one way that SETI researchers look for technosignatures. Thanks for reading, and happy alien hunting! \ud83d\udc7d","a8a03c5c":"Great! So now that we have installed and imported all of the packages we need, let's move forward and try some analysis. For our first experiment, we will look for the signal from the Mars2020 spacecraft. Note that when we conduct an observation with the GBT, the data is originally stored in raw format. The .raw files are then processed by a program called \"rawspec\" to produce filterbank files with very high spectral resolution. These files span a large frequency range and as a result, it takes turboSETI a very long time to search through them. Fortunately, the filterbank files are made up of much smaller frequency chunks (\"coarse channels\"), and we can pull out individual coarse channels of interest if we want to search through a smaller range of frequencies. We will be searching through one coarse channel for signs of the Mars2020 spacecraft, and the single coarse channel data files are in the input directory for this notebook.  \n\nOur first step to find Mars2020 is to run turboSETI itself: ","64a7c007":"Now that we've run turboSETI, let's make use of our results! To find out how many promising \"technosignature\" candidates turboSETI has found by performing the Doppler drift search, let's now employ the turboSETI module **find_event_pipeline()** to create a table of candidate signals and their properties:","659b9729":"Now that we have verified that we have, in fact, detected a promising candidate signal, and created a CSV file summarizing the candidates, we can run the module **plot_event_pipeline()** and display our candidate signals! ","33fb37d7":"## \ud83d\ude80\ud83d\udd34 Breakthrough Listen: Mars Tutorial  \n\nOn February 18, 2021, the Mars2020 spacecraft and its occupants -- the Perseverance rover and the helicopter Ingenuity -- touched down on the surface of the Red Planet near Jezero Crater. These two new robotic Martians were ferried to their new home by an Atlas V rocket; it took seven months to complete the journey from Earth to Mars. \n\n![An artist's rendition of Perseverance and Ingenuity on Mars](https:\/\/www.nasa.gov\/sites\/default\/files\/thumbnails\/image\/pia23962-1041.jpg)  \n\n*Fig. 1: An artist's rendition of Perseverance and Ingenuity on Mars. Image credit: NASA.*\n\nSo where does Breakthrough Listen (the most extensive search for extraterrestrial intelligence -- SETI -- project to date) come into the picture? Well, one way that SETI scientists check that their ET signal detection algorithms work properly is to make test observations of human-made \"aliens\" -- aka spacecraft that humans have sent out into the Solar System (and beyond, in the case of the Voyagers). These spacecraft transmit narrowband radio signals -- if ET's technology is anything like our own, perhaps they do too.  \n\nBreakthrough Listen (BL) has access to 20% of the observing time on the Green Bank Telescope (GBT) in WV, the world's largest fully-steerable radio telescope. BL uses its time on the GBT to methodically search thousands of stellar targets for technosignatures (the general scientific term for \"a signal from ET\"), and occasionally conducts test observations of faraway spacecraft like Voyager 1.  \n\nWhile on its way to Mars, the Mars2020 spacecraft maintained contact with Earth via radio transmissions in the X-Band (8-12 GHz) frequency range. On Feb. 11, before its landing, we decided to point the GBT at the spacecraft carrying Perseverance and Ingenuity to their new Martian home to see if we could detect its communication signal. We used the GBT's X-Band receiver and performed the observation following the typical pattern of a SETI search: a series of 3 \"on-off\" measurements. An \"on-off\" observation consists of taking a scan of your desired source first, then moving the telescope to a different (off) source for comparison to ensure signals detected on-source are actually coming from the sky and not local interference. For our Mars2020 observation, we used the Mars2020 spacecraft as our \"on\" source and Mars itself as our \"off\" source, and pointed the telescope alternately between Mars2020 and Mars 3 times, staying on each source for 5 minutes (for a total of 6 scans, taking 30 minutes altogether). We chose Mars as our off source so that in addition to looking for the signal from Mars2020, we could also search for signals from some of the spacecraft currently in orbit around (or on the surface of) Mars as well.  \n\nIn this tutorial, we're going to share the GBT data we obtained during this Mars observation and walk you through the steps needed to analyze it and discover signals from (human-made) Martians on your own computer! "}}