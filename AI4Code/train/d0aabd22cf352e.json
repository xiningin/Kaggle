{"cell_type":{"641add51":"code","6eb823de":"code","79c36af1":"code","3b789f7e":"code","e4234b70":"code","8162d9fc":"code","36c0aa93":"code","83e3b4d6":"code","11e7a875":"code","1f937c27":"code","8e8d010c":"code","0ae492ac":"code","584333d6":"code","72b367dd":"markdown","cd692a22":"markdown","4fb387dc":"markdown","01f0ce9c":"markdown","4e4ec811":"markdown","adc37b89":"markdown","9971ca28":"markdown"},"source":{"641add51":"import numpy as np\nimport pandas as pd\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","6eb823de":"# imports used in this project\n\n# keras\nimport keras\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.callbacks import EarlyStopping, ModelCheckpoint\n# ploting\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg","79c36af1":"# import csv datas\ntrain_data = pd.read_csv(\"\/kaggle\/input\/aerial-cactus-identification\/train.csv\",dtype=\"str\")\ntest_data = pd.read_csv(\"\/kaggle\/input\/aerial-cactus-identification\/sample_submission.csv\",dtype=\"str\")","3b789f7e":"# train csv\ntrain_data.head()","e4234b70":"# unzip the images\n!mkdir \"\/kaggle\/data\/\"\n!mkdir \"\/kaggle\/data\/aerial-cactus-identification\"\n!unzip \"\/kaggle\/input\/aerial-cactus-identification\/train.zip\" -d \"\/kaggle\/data\/aerial-cactus-identification\/train\" > \/dev\/null\n!unzip \"\/kaggle\/input\/aerial-cactus-identification\/test.zip\" -d \"\/kaggle\/data\/aerial-cactus-identification\/test\" > \/dev\/null\n\ntrain_dir = \"\/kaggle\/data\/aerial-cactus-identification\/train\/train\"\ntest_dir = \"\/kaggle\/data\/aerial-cactus-identification\/test\/test\"","8162d9fc":"# show some of the images\nimages_with_cactus = train_data[train_data.has_cactus=='1'][:10]\nimages_without_cactus = train_data[train_data.has_cactus=='0'][:10]\n# plot images with cactus\nfor i in range(10):\n    plt.subplot(4,5,i+1)\n    img_data = mpimg.imread(train_dir+'\/'+images_with_cactus.iloc[i][\"id\"])\n    plt.imshow(img_data)\n# plot images without cactus  \nfor i in range(10):\n    plt.subplot(4,5,10+i+1)\n    img_data = mpimg.imread(train_dir+'\/'+images_without_cactus.iloc[i][\"id\"])\n    plt.imshow(img_data)","36c0aa93":"# create images data\ndatagen = ImageDataGenerator(rescale=1.\/255,# make each pixel 0~1\n    rotation_range=20,# rotate the images\n    width_shift_range=0.2, # shift the images\n    height_shift_range=0.2, # shift the images\n    horizontal_flip=True) # flip the images\n# training data\ntrain_generator = datagen.flow_from_dataframe(\n        dataframe=train_data[:15001],\n        directory=train_dir,\n        x_col='id',\n        y_col='has_cactus',\n        shuffle=True,\n        class_mode='binary',# yes or no problem\n        batch_size=150,\n        target_size=(32, 32))\n# validating data\nvalidation_generator = datagen.flow_from_dataframe(\n        dataframe=train_data[15000:],\n        directory=train_dir,\n        x_col='id',\n        y_col='has_cactus',\n        class_mode='binary',\n        batch_size=50,\n        target_size=(32, 32))\n# testing data\ntest_generator = datagen.flow_from_dataframe(\n        dataframe=test_data,\n        directory=test_dir,\n        x_col='id',\n        y_col='has_cactus',\n        class_mode=None,# no target value\n        shuffle=False,# do not mess the image order\n        target_size=(32, 32)\n)","83e3b4d6":"model = keras.models.Sequential([\n    # input shape 32*32*3\n    # 1st set of layers: Conv2d+BatchNormalization+Relu --> 32*32*3 becomes 32*32*32\n    keras.layers.Conv2D(32,(5,5),padding=\"same\",input_shape=(32,32,3)),\n    keras.layers.BatchNormalization(),\n    keras.layers.Activation('relu'),\n    # 2nd set of layers: Conv2d+BatchNormalization+Relu+MaxPooling2D --> 32*32*32 becomes 16*16*32\n    keras.layers.Conv2D(32,(3,3),padding=\"same\"),\n    keras.layers.BatchNormalization(),\n    keras.layers.Activation('relu'),\n    keras.layers.MaxPooling2D(),\n    # 3rd set of layers: Conv2d+BatchNormalization+Relu --> 16*16*32 becomes 16*16*64\n    keras.layers.Conv2D(64,(3,3),padding=\"same\"),\n    keras.layers.BatchNormalization(),\n    keras.layers.Activation('relu'),\n    # 4th set of layers: Conv2d+BatchNormalization+Relu+MaxPooling2D --> 16*16*64 becomes 8*8*64\n    keras.layers.Conv2D(64,(3,3),padding=\"same\"),\n    keras.layers.BatchNormalization(),\n    keras.layers.Activation('relu'),\n    keras.layers.MaxPooling2D(padding=\"same\"),\n    # 5th set of layers: Conv2d+BatchNormalization+Relu+MaxPooling2D --> 8*8*64 becomes 4*4*128\n    keras.layers.Conv2D(128,(3,3),padding=\"same\"),\n    keras.layers.BatchNormalization(),\n    keras.layers.Activation('relu'),\n    keras.layers.MaxPooling2D(padding=\"same\"),\n    # flatten the image --> 4*4*128 becomes 2048\n    keras.layers.Flatten(),\n    # go through a bunch of neurons and drop some of the links --> 2048 becomes 1024\n    keras.layers.Dense(1024, activation=\"relu\"),\n    keras.layers.Dropout(0.2),\n    # go through another bunch of neurons and drop some of the links --> 1024 becomes 128\n    keras.layers.Dense(128, activation=\"relu\"),\n    keras.layers.Dropout(0.2),\n    # finally go through a single neuron --> 128 becomes 1\n    keras.layers.Dense(1, activation=\"sigmoid\")\n])\n# compile model for binary results\nmodel.compile(optimizer=\"adam\",loss=\"binary_crossentropy\",metrics=[\"accuracy\"])\n# we can get summary of the model\n#model.summary()","11e7a875":"# callback for each epoch\n# model_path = '\/kaggle\/working\/best_model.h5'\nmodel_path = '\/kaggle\/input\/review-of-cactus-recognition-basic-cnn\/best_model.h5'\ncallbacks = [\n    # save model\n    ModelCheckpoint(filepath=model_path, monitor='val_loss', save_best_only=True),\n    # stop when changes become little\n    EarlyStopping(monitor='val_loss',patience=20)\n]","1f937c27":"# training the model\n# training is dealt with in version 4\n# model.fit_generator(\n#     train_generator,\n#     epochs=100,\n#     validation_data=validation_generator,\n#     callbacks=callbacks,\n#     shuffle=True# shuffle data to get more stable fitting\n# )","8e8d010c":"model.load_weights(model_path)\nres = model.predict_generator(test_generator)\ntest_data[\"has_cactus\"] = res\ntest_data.to_csv(\"\/kaggle\/working\/submission.csv\",index=False)","0ae492ac":"test_data.head()","584333d6":"# show some of the images\nimages_with_cactus = np.random.choice(test_data[test_data.has_cactus>=0.5]['id'],10)\nimages_without_cactus = np.random.choice(test_data[test_data.has_cactus<0.5]['id'],10)\n# plot images with cactus\nfor i in range(10):\n    plt.subplot(4,5,i+1)\n    img_data = mpimg.imread(test_dir+'\/'+images_with_cactus[i])\n    plt.imshow(img_data)\n# plot images without cactus  \nfor i in range(10):\n    plt.subplot(4,5,10+i+1)\n    img_data = mpimg.imread(test_dir+'\/'+images_without_cactus[i])\n    plt.imshow(img_data)","72b367dd":"### Get test results","cd692a22":"### Well there are some misjudged images...","4fb387dc":"### Understand the data","01f0ce9c":"### Create CNN model","4e4ec811":"### Create image data using [ImageDataGenerator](https:\/\/www.tensorflow.org\/api_docs\/python\/tf\/keras\/preprocessing\/image\/ImageDataGenerator)","adc37b89":"### What's the problem\nLearn a bunch of pictures to determine whether there is a cactus in the picture.\n### Review point\n* Preparation of CNN input data\n* Basic CNN for **yes or no** problems","9971ca28":"### Fitting the model"}}