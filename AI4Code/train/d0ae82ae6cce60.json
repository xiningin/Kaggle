{"cell_type":{"9fb4f16b":"code","5ac83910":"code","877cdb3f":"code","45aac19e":"code","d680653a":"code","62decdf2":"code","16fb6c8e":"code","adeb693a":"markdown","d50d20bc":"markdown","8590ffe2":"markdown","2733c05b":"markdown"},"source":{"9fb4f16b":"import numpy as np\nimport cv2\nfrom scipy import signal\nimport matplotlib.pyplot as plt","5ac83910":"def gaussian_kernels(size=3, sigma=1):\n\n    upper = size - 1\n    lower = - int(size \/ 2)\n    \n    y, x = np.mgrid[lower:upper, lower:upper]\n    \n    kernel = (1 \/ (2 * np.pi * sigma**2 ) ) * np.exp( -(x**2 + y**2) \/ (2 * sigma**2) )\n    # kernel = kernel \/ kernel.sum()\n    \n    return kernel","877cdb3f":"gaussian_kernels()","45aac19e":"image = cv2.imread('..\/input\/image-filtering-gaussian-filters-lena\/Lena.png', cv2.IMREAD_GRAYSCALE)\n\n# cv2.imshow('image', image)\nprint('image:\\n', image, '\\n')\n\npost_gf_convolution = signal.convolve2d(\n    image, \n    gaussian_kernels( sigma = 1 \/ ( 2 * np.log(2) ) ), \n    mode='same', boundary='fill', fillvalue=0\n)\n# mode='same', boundary='symm'\n# mode='same', boundary='fill', fillvalue=0\npost_gf_convolution = np.round(post_gf_convolution)\npost_gf_convolution = post_gf_convolution.astype(np.uint8)\n\n# cv2.imshow('post_gf_convolution', post_gf_convolution)\nprint('post_gf_convolution:\\n', post_gf_convolution, '\\n')\n\nimages = [image, post_gf_convolution]\nimages_title = ['image', 'post_gf_convolution']\n\nplt.figure(figsize=(12, 6))\nfor i in range(2):\n    plt.subplot(1, 2, i+1)\n    plt.imshow(images[i], cmap=plt.get_cmap('gray'))\n    plt.title(images_title[i], fontsize=20)\n    plt.xticks([]), plt.yticks([])\n\n# cv2.waitKey(0)\n# cv2.destroyAllWindows()","d680653a":"kx = np.array([[-0.5, 0, 0.5]])\nky = np.array([\n    [-0.5],\n    [0],\n    [0.5]\n])\n# kx.shape, ky.shape","62decdf2":"# cv2.imshow('image', image)\nprint('image:\\n', image, '\\n')\n\npost_kx_convolution = signal.convolve(image, kx, mode='same')\npost_kx_convolution = np.round(post_kx_convolution)\npost_kx_convolution = post_kx_convolution.astype(np.uint8)\n\npost_ky_convolution = signal.convolve(image, ky, mode='same')\npost_ky_convolution = np.round(post_ky_convolution)\npost_ky_convolution = post_ky_convolution.astype(np.uint8)\n\n# cv2.imshow('post_kx_convolution', post_kx_convolution)\n# cv2.imshow('post_ky_convolution', post_ky_convolution)\nprint('post_kx_convolution:\\n', post_kx_convolution, '\\n')\nprint('post_ky_convolution\\n', post_ky_convolution, '\\n')\n\nimages = [image, post_kx_convolution, post_ky_convolution]\nimages_title = ['image', 'post_kx_convolution', 'post_ky_convolution']\n\nplt.figure(figsize=(18, 6))\nfor i in range(3):\n    plt.subplot(1, 3, i+1)\n    plt.imshow(images[i], cmap=plt.get_cmap('gray'))\n    plt.title(images_title[i], fontsize=20)\n    plt.xticks([]), plt.yticks([])\n\n# cv2.waitKey(0)\n# cv2.destroyAllWindows()","16fb6c8e":"# gradient_magnitude_original_image\ngradient_magnitude_original_image = (post_kx_convolution**2 + post_ky_convolution**2)**(1\/2)\n\n# gradient_magnitude_post_gf_convolution\npost_kx_convolution_gf = signal.convolve(post_gf_convolution, kx, mode='same')\npost_kx_convolution_gf = np.round(post_kx_convolution_gf)\npost_kx_convolution_gf = post_kx_convolution_gf.astype(np.uint8)\n\npost_ky_convolution_gf = signal.convolve(post_gf_convolution, ky, mode='same')\npost_ky_convolution_gf = np.round(post_ky_convolution_gf)\npost_ky_convolution_gf = post_ky_convolution_gf.astype(np.uint8)\n\ngradient_magnitude_post_gf_convolution = (post_kx_convolution_gf**2 + post_ky_convolution_gf**2)**(1\/2)\n\n# plot them out\nimages = [gradient_magnitude_original_image, gradient_magnitude_post_gf_convolution]\nimages_title = ['GM_original_image', 'GM_post_gf_convolution']\n\nplt.figure(figsize=(12, 6))\nfor i in range(2):\n    plt.subplot(1, 2, i+1)\n    plt.imshow(images[i], cmap=plt.get_cmap('gray'))\n    plt.title(images_title[i], fontsize=20)\n    plt.xticks([]), plt.yticks([])","adeb693a":"# 2. Consider the image I(x, y) as a function I : R2 \u2192 R. \nWhen detecting edges in an image, it is often important to extract information from the derivatives of pixel values. Denote the derivatives as follows: <br>\nIx(x, y) = \u2202I\/\u2202x \u2248 1\/2(I(x + 1, y) \u2212 I(x \u2212 1, y)) <br>\nIy(x, y) = \u2202I\/\u2202y \u2248 1\/2(I(x, y + 1) \u2212 I(x, y \u2212 1)).\n\nImplement the 1D convolution kernels kx \u2208 R1\u00d73 and ky \u2208 R3\u00d71 such that<br>\nIx = kx \u2217 I <br>\nIy = ky \u2217 I.\n\nWrite down your answers of kx and ky. Also, plot the resulting images Ix and Iy using the\nprovided lena.png as input.\n\n","d50d20bc":"# 3. Define the gradient magnitude image Im as\nIm(x, y) = q(Ix(x, y)2 + Iy(x, y)2).\n\nUse both the provided lena.png and the Gaussian-filtered image you obtained in 1. as input images. <br>\nPlot the two output gradient magnitude images in your report. Briefly explain the differences in the results.","8590ffe2":"# 1. Implement a discrete 2D Gaussian filter\nusing a 3 \u00d7 3 kernel with \u03c3 \u2248 1\/2ln2. Use the provided lena.png as input, and plot the output image in your report. Briefly describe the effect of the filter.","2733c05b":"[[Python]Gaussian Filter-\u6982\u5ff5\u8207\u5be6\u4f5c](https:\/\/medium.com\/@bob800530\/python-gaussian-filter-%E6%A6%82%E5%BF%B5%E8%88%87%E5%AF%A6%E4%BD%9C-676aac52ea17)"}}