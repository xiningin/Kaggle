{"cell_type":{"4170346b":"code","9bdfafb2":"code","d67b20b9":"code","7482593d":"code","43940c96":"code","24175f75":"code","02235ce6":"code","d8fb6e90":"code","f007edb4":"code","a5758b36":"code","112624ea":"markdown","323267b8":"markdown","e4d19b70":"markdown","41f580db":"markdown","09cac89c":"markdown","0cafe770":"markdown"},"source":{"4170346b":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\n\nsns.set(rc={'figure.figsize':(14,10)})","9bdfafb2":"path = '..\/input\/cooking-ingredients\/train.csv'\ndf = pd.read_csv(path)\ndf.head()","d67b20b9":"# number of ingredients\nnr_ingredients = len(df.iloc[:,0])\n\nfeatures = df.iloc[:, 1:nr_ingredients]\nlabels = df.iloc[:, 0]\n\nnr_ingredients = len(df.columns) - 1\nprint(\"Number of igredients: \", nr_ingredients)","7482593d":"top_ten_idx = list(features.sum(axis=1).sort_values(ascending=False).index)[:10]\n\nprint(\"Receipes with most ingredients:\")\nfor i,recipe in enumerate(labels[top_ten_idx].values):\n    print('{0}. {1}'.format(i + 1, recipe))","43940c96":"top_receipes_ingredients = [list(features.columns.values[np.where(features.iloc[top_ten_idx[i]] == 1.0)[0]]) for i in range(10)]","24175f75":"class FPTree():\n    \n    class Node:\n        def __init__(self, name_value, num_occur, parent_node):\n            self.name = name_value\n            self.count = num_occur\n            self.node_link = None\n            self.parent = parent_node\n            self.children = {} \n   \n        def inc(self, num_occur):\n            self.count += num_occur\n  \n        def disp(self, ind=1):\n            print ('  '*ind, self.name, ' ', self.count)\n            for child in self.children.values():\n                child.disp(ind+1)\n                \n    def __init__(self, data, min_sup):\n        self.data = self.init_set(data)\n        self.tree, self.header = self.create(self.data, min_sup)\n                \n    def create(self, data, min_sup=1):\n        header = {}\n\n        for trans in data:\n            for item in trans:\n                header[item] = header.get(item, 0) + data[trans]\n        for k in list(header):\n            if header[k] < min_sup: \n                del(header[k])\n        freq_set = set(header.keys())\n\n        if len(freq_set) == 0: return None, None\n        for k in header:\n            header[k] = [header[k], None]\n\n        ret_tree = self.Node('Null Set', 1, None)\n        for tranSet, count in data.items():\n            local_d = {}\n            for item in tranSet:\n                if item in freq_set:\n                    local_d[item] = header[item][0]\n            if len(local_d) > 0:\n                ordered_items = [v[0] for v in sorted(local_d.items(), key=lambda p: p[1], reverse=True)]\n                self.update(ordered_items, ret_tree, header, count)\n        return ret_tree, header\n\n    def update(self, items, tree, header, count):\n        if items[0] in tree.children:\n            tree.children[items[0]].inc(count)\n        else:\n            tree.children[items[0]] = self.Node(items[0], count, tree)\n            if header[items[0]][1] == None:\n                header[items[0]][1] = tree.children[items[0]]\n            else:\n                self.update_header(header[items[0]][1], tree.children[items[0]])\n        if len(items) > 1:\n            self.update(items[1::], tree.children[items[0]], header, count)\n\n    def update_header(self, test_node, target_node):\n        while (test_node.node_link != None):\n            test_node = test_node.node_link\n        test_node.node_link = target_node\n\n    def init_set(self, data):\n        frozen_set = {}\n        for trans in data:\n            frozen_set[frozenset(trans)] = 1\n        return frozen_set\n\n    def ascend_tree(self, leaf_node, prefix_path):\n        if leaf_node.parent != None:\n            prefix_path.append(leaf_node.name)\n            self.ascend_tree(leaf_node.parent, prefix_path)\n            \n    def find_prefix_path(self, tree):\n        cond_pats = {}\n        while tree != None:\n            prefix_path = []\n            self.ascend_tree(tree, prefix_path)\n            if len(prefix_path) > 1: \n                cond_pats[frozenset(prefix_path[1:])] = tree.count\n            tree = tree.node_link\n        return cond_pats","02235ce6":"fptree = FPTree(top_receipes_ingredients, min_sup=3)","d8fb6e90":"fptree.tree.disp()","f007edb4":"fptree.find_prefix_path(fptree.header['olive oil'][1])","a5758b36":"fptree.find_prefix_path(fptree.header['apple cider vinegar'][1])","112624ea":"![fp.png](attachment:fp.png)\n\nFrequent pattern discovery is part of knowledge discovery in databases, Massive Online Analysis, and data mining; it describes the task of finding the most frequent and relevant patterns in large datasets. The concept was first introduced for mining transaction databases.","323267b8":"<div>\n    <img src='https:\/\/storage.googleapis.com\/kaggle-datasets-images\/1080334\/1818399\/4d791ccfa426eb7cb766c08e0b19f359\/dataset-cover.jpg' \/>\n<\/div>","e4d19b70":"<h1 id=\"frequency\" style=\"color:#e26415; background:#c0d3c9;\"> \n    <center>Finding the most frequent ingredients in top 10 receipes\n        <a class=\"anchor-link\" href=\"#frequency\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","41f580db":"<h1 id=\"definition\" style=\"color:#e26415; background:#c0d3c9;\"> \n    <center>Definition\n        <a class=\"anchor-link\" href=\"#definition\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","09cac89c":"<h1 id=\"implementation\" style=\"color:#e26415; background:#c0d3c9;\"> \n    <center>Implementation\n        <a class=\"anchor-link\" href=\"#implementation\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>","0cafe770":"<h1 id=\"dataset\" style=\"color:#e26415; background:#c0d3c9;\"> \n    <center>Dataset\n        <a class=\"anchor-link\" href=\"#dataset\" target=\"_self\">\u00b6<\/a>\n    <\/center>\n<\/h1>"}}