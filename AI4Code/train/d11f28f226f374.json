{"cell_type":{"4573aa15":"code","d086fde6":"code","4f2127ac":"code","9f3e69bf":"code","c229c9f5":"code","7830752d":"code","01db0085":"code","22b3cdf6":"code","9b22abb6":"code","70704654":"code","067628d2":"code","5cb5caff":"code","481b594b":"code","3df98d7a":"code","18d1424d":"code","445de324":"code","0af35768":"code","42946f6b":"code","5df87dbf":"code","cf92298a":"code","4171c2cb":"code","b28d0406":"code","9bba3437":"code","93e50484":"code","f13ad757":"code","1dd48c76":"code","9a6269ba":"code","2c7cf906":"code","d9e9362b":"code","add5323a":"code","d8f06591":"code","014e468a":"code","2d0b653d":"code","421f6dd6":"code","23ddc85b":"code","036020da":"code","1fb76a50":"code","f06d5499":"code","ad39e6a6":"code","2a30ff3d":"code","508c8760":"code","3ac50a8b":"code","76adb263":"code","5b3cfe72":"code","a956dbc3":"code","f960569e":"code","9831d5b6":"code","f4237d52":"code","a9639fd0":"code","79bb4c70":"code","c2a17a3e":"code","ee18053a":"code","a6fff289":"code","ceeb1066":"code","8fac8c58":"code","06e70f13":"code","dc133d00":"code","4d5c69fd":"code","755f86ef":"code","1bb67d71":"code","b9c3b806":"code","2fcaca57":"code","197bbe62":"code","6d1c7d56":"code","1838a5fc":"code","64c24075":"code","57b621e6":"code","d9e5ae09":"code","7228d228":"code","f73cc263":"code","e1470b49":"code","c9446af2":"code","52b8a9a5":"code","cc88135f":"code","5cdb1b5d":"markdown","4cc14f58":"markdown","b8115218":"markdown","e331713f":"markdown","614d116d":"markdown","666f7b0f":"markdown","5b25d561":"markdown","69448ffd":"markdown","dd3aa5a8":"markdown","a14adc9d":"markdown","da1552e4":"markdown","230c41b3":"markdown","95e76214":"markdown","896c6375":"markdown","cb777e99":"markdown","db5797cd":"markdown","6a4db8a7":"markdown","a0bfb959":"markdown","2ae7d1ce":"markdown","6cf91fe3":"markdown","12df3ddd":"markdown","35d64773":"markdown","24b3a8b6":"markdown","2fbfaef1":"markdown","6c3cb93a":"markdown","90c3ec4d":"markdown","12d2b97d":"markdown","0e1675d8":"markdown","c38195d1":"markdown","6cd4b541":"markdown","0f9efa8d":"markdown","8f9ac133":"markdown","4ef9830d":"markdown","ba2ab396":"markdown","187b1fc4":"markdown","1d133fa2":"markdown","f29c0d17":"markdown","b3115d2e":"markdown","50468d5c":"markdown","dd1ad746":"markdown","9a42ede5":"markdown","74fb5407":"markdown","e2ed151e":"markdown","ba849c1f":"markdown","63c9502c":"markdown","2790db33":"markdown","a19e9798":"markdown","e4458581":"markdown","fdd61309":"markdown","1c07d906":"markdown","d27d3f4f":"markdown","62529283":"markdown","6c4b1ac9":"markdown","008a3da5":"markdown","adec6e96":"markdown","f998cc73":"markdown","22b22538":"markdown","b26579bf":"markdown","1cdfcf5a":"markdown","476f2bc4":"markdown","1ee84baf":"markdown","bfe6c571":"markdown","72bc4c8b":"markdown","06234f8c":"markdown","fb7e9c3b":"markdown","6b5ca8bb":"markdown","65073df3":"markdown","d364d342":"markdown","80ad3c6f":"markdown","708f17e9":"markdown","53b2cd7f":"markdown","60f45a14":"markdown","ab9e438e":"markdown","5cf18954":"markdown","e4e43958":"markdown"},"source":{"4573aa15":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns","d086fde6":"import os\nprint(os.listdir(\"..\/input\/\"))","4f2127ac":"df =pd.read_csv(\"..\/input\/Pokemon.csv\")","9f3e69bf":"df.head()","c229c9f5":"df.head(3)","7830752d":"df.columns","01db0085":"df[[\"Name\",\"Type 1\"]]","22b3cdf6":"df = df.set_index('Name')","9b22abb6":"df.head()","70704654":"df=df.drop(['#'],axis=1)\ndf.head()","067628d2":"df[df.index.str.contains(\"Mega\")]","5cb5caff":"df.index.str.contains(\"Mega\")","481b594b":"df[df.index.str.contains(\"Mega\")].head()","3df98d7a":"df.index = df.index.str.replace(\".*(?=Mega)\", \"\")\ndf.head(10)","18d1424d":"df[df.index.str.contains(\"Mega\")].head()","445de324":"df.columns = df.columns.str.upper().str.replace('_', '')\ndf.head()","0af35768":"df[df['LEGENDARY'] == True].head(20)","42946f6b":"print('The columns of the dataset are: ',','.join(list(df.columns)))\nprint('The shape of the dataframe is: ',df.shape)","5df87dbf":"df.describe()","cf92298a":"ser = df['TYPE 1']\nser","4171c2cb":"ser['Bulbasaur']","b28d0406":"ser.index","9bba3437":"ser.values","93e50484":"df['TYPE 2'].fillna(df['TYPE 1'], inplace=True) #fill NaN values in Type2 with corresponding values of Type\ndf.head(100)","f13ad757":"df.loc['Bulbasaur'] #retrieves complete row data from index with value Bulbasaur","1dd48c76":"df.iloc[0] #retrieves complete row date from index 0 ; integer version of loc","9a6269ba":"# df[(df['TYPE 1']=='Fire' or df['TYPE 1']=='Dragon') and (df['TYPE 2']=='Dragon' or df['TYPE 2']=='Fire')].head(3)","2c7cf906":"df[((df['TYPE 1']=='Fire') | (df['TYPE 1']=='Dragon')) & ((df['TYPE 2']=='Dragon') | (df['TYPE 2']=='Fire'))].head(3)","d9e9362b":"print(f'The pokemon with the msot HP is {df[\"HP\"].idxmax()} with {df[\"HP\"].max()} HP')","add5323a":"df.sort_values('TOTAL',ascending=False).head()","d8f06591":"df.sort_values(['TOTAL','ATTACK'],ascending=False).head()","014e468a":"print('The unique  pokemon types are',df['TYPE 1'].unique()) #shows all the unique types in column\nprint('The number of unique types are',df['TYPE 1'].nunique()) #shows count of unique values ","2d0b653d":"df['TYPE 1'].value_counts()","421f6dd6":"df.groupby(['TYPE 1']).size()  #same as value_counts","23ddc85b":"df.groupby(['TYPE 1']).groups # our groups and which pokemon is in which","036020da":"df.groupby(['TYPE 1']).groups.keys() # only the group names","1fb76a50":"df.groupby(['TYPE 1']).first()","f06d5499":"df.groupby(['TYPE 1'])['SPEED'].max() # Highest speed from each group","ad39e6a6":"df.groupby(['TYPE 1'])['HP'].mean() # mean HP per Type 1 group","2a30ff3d":"df.groupby(['TYPE 1'])['LEGENDARY'].sum() # Number of legendaries from each type","508c8760":"df.groupby(['TYPE 1','TYPE 2']).size()","3ac50a8b":"df[\"LEGENDARY\"] == True # the condition","76adb263":"df[df[\"LEGENDARY\"] == True].head()","5b3cfe72":"df.loc[df[\"LEGENDARY\"] == True,\"SPEED\"].head()","a956dbc3":"df.loc[df[\"LEGENDARY\"] == True,\"SPEED\"] += 10","f960569e":"df.loc[df[\"LEGENDARY\"] == True,\"SPEED\"].head()","9831d5b6":"df.loc[df[\"LEGENDARY\"] == True,\"SPEED\"] -= 10","f4237d52":"# get the data ready\npokemon_per_generation = df[\"GENERATION\"].value_counts().sort_index()\npokemon_per_generation","a9639fd0":"pokemon_per_generation.plot.bar()","79bb4c70":"# or, alternatively\npokemon_per_generation.plot(kind='bar')","c2a17a3e":"# Add title\nplt.title('Number of pokemon in each generation')\n\n# Set our x\/y labels\nplt.xlabel('Generation')\nplt.ylabel('Number of pokemon')\n\npokemon_per_generation.plot(kind='bar')\nplt.show()","ee18053a":"legendaries_per_generation = df[df['LEGENDARY'] == True][\"GENERATION\"].value_counts().sort_index()\nnon_legendaries_per_generation = df[df['LEGENDARY'] == False][\"GENERATION\"].value_counts().sort_index()\n\n# Concat 2 series to a dataframe with 2 columns\npd.concat([non_legendaries_per_generation,legendaries_per_generation],axis=1,keys=['non_legendaries','legendaries']).plot.bar()\n\n# Add title\nplt.title('Number of pokemon \/ legendaries in each generation')\n\n# Set our x\/y labels\nplt.xlabel('Generation')\nplt.ylabel('Number of pokemon')\n\n# add legend\nplt.legend(('Normal', 'Legendary'))\n\nplt.show()","a6fff289":"plt.bar(non_legendaries_per_generation.index, non_legendaries_per_generation.values)\n# we use the bottom argument to start the legendaries bar from the end of the non legendaries\nplt.bar(legendaries_per_generation.index, legendaries_per_generation.values,\n             bottom=non_legendaries_per_generation.values)\n\n# Add title\nplt.title('Number of pokemon \/ legendaries in each generation')\n\n# Set our x\/y labels\nplt.xlabel('Generation')\nplt.ylabel('Number of pokemon')\n\n# add legend\nplt.legend(('Normal', 'Legendary'))\n\nplt.show()","ceeb1066":"df[\"TYPE 1\"].value_counts().plot.barh()","8fac8c58":"df.hist(column='ATTACK')","06e70f13":"type_gen_total=df.groupby(['GENERATION','TYPE 1']).count().reset_index()\ntype_gen_total=type_gen_total[['GENERATION','TYPE 1','TOTAL']]\n# pivot is a very useful method, it reshapes our data based on certin columns, we specify which columns will be the index, columns and values\n# in this example we make our generation the row index, the columns are each pokemon type and the values are their total in each generation\ntype_gen_total=type_gen_total.pivot(index='GENERATION',columns='TYPE 1',values='TOTAL')\ntype_gen_total.plot(marker='o')\nfig=plt.gcf()\nfig.set_size_inches(12,6)\nplt.show()","dc133d00":"type_gen_total[[\"Fire\",\"Water\",\"Electric\",\"Grass\",\"Ice\",\"Fighting\",\"Poison\",\"Ground\",\"Flying\",\"Psychic\",\"Bug\",\"Rock\",\"Ghost\",\"Dragon\",\"Dark\",\"Steel\",\"Fairy\"]].plot(marker='o'\n,color=[\"#EE8130\",\"#6390F0\",\"#F7D02C\",\"#7AC74C\",\"#96D9D6\",\"#C22E28\",\"#A33EA1\",\"#E2BF65\",\"#A98FF3\",\"#F95587\",\"#A6B91A\",\"#B6A136\",\"#735797\",\"#6F35FC\",\"#705746\",\"#B7B7CE\",\"#D685AD\"])\nfig=plt.gcf()\nfig.set_size_inches(12,6)\nplt.show()","4d5c69fd":"fire = df[(df['TYPE 1']=='Fire') | ((df['TYPE 2'])==\"Fire\")] #fire contains all fire pokemon\nwater = df[(df['TYPE 1']=='Water') | ((df['TYPE 2'])==\"Water\")]  #all water pokemon\nax = fire.plot.scatter(x='ATTACK', y='DEFENSE', color='Red', label='Fire')\nwater.plot.scatter(x='ATTACK', y='DEFENSE', color='Blue', label='Water', ax=ax);","755f86ef":"strong=df.sort_values(by='TOTAL', ascending=False) #sorting the rows in descending order\nstrong.drop_duplicates(subset=['TYPE 1'],keep='first') #since the rows are now sorted in descending oredr\n#thus we take the first row for every new type of pokemon i.e the table will check TYPE 1 of every pokemon\n#The first pokemon of that type is the strongest for that type\n#so we just keep the first row","1bb67d71":"df['TYPE 1'].value_counts().plot.pie()","b9c3b806":"# Add title\nplt.title('Number of pokemon in each generation')\n\n# Set our x\/y labels\nplt.xlabel('Generation')\nplt.ylabel('Number of pokemon')\nsns.barplot(pokemon_per_generation.index,pokemon_per_generation.values)\n\nplt.show()","2fcaca57":"# Add title\nplt.title('Number of pokemon in each generation')\n\n# Set our x\/y labels\nplt.xlabel('Generation')\nplt.ylabel('Number of pokemon')\n#sns.barplot(pokemon_per_generation.index,pokemon_per_generation.values)\nsns.countplot('GENERATION',data=df,palette='RdYlGn_r',edgecolor=sns.color_palette('dark',7))\n\nplt.show()","197bbe62":"plot_data = df[\"TYPE 1\"].value_counts()\nsns.barplot(plot_data.values,plot_data.index,palette='plasma')","6d1c7d56":"sns.distplot(df['ATTACK'])","1838a5fc":"plot_data = df.groupby(['GENERATION','TYPE 1']).count().reset_index()\nsns.lineplot(x='GENERATION',y='TOTAL',hue='TYPE 1',data=plot_data,marker='o')\nfig=plt.gcf()\nfig.set_size_inches(15,9)\nplt.legend(loc='upper right')\nplt.show()","64c24075":"fire_and_water = df[(df['TYPE 1'].isin(['Fire','Water']))]\nsns.scatterplot(x='ATTACK', y='DEFENSE',data=fire_and_water, hue='TYPE 1')","57b621e6":"df2=df.drop(['GENERATION','TOTAL'],axis=1)\nsns.boxplot(data=df2)\nplt.ylim(0,200)  #change the scale of y axix\nplt.show()","d9e5ae09":"plt.subplots(figsize = (15,5))\nplt.title('Attack by Type1')\nsns.boxplot(x = \"TYPE 1\", y = \"ATTACK\",data = df)\nplt.ylim(0,200)\nplt.show()","7228d228":"plt.subplots(figsize = (15,5))\nplt.title('Attack by Type2')\nsns.boxplot(x = \"TYPE 2\", y = \"ATTACK\",data=df)\nplt.show()","f73cc263":"plt.subplots(figsize = (15,5))\nplt.title('Defence by Type')\nsns.boxplot(x = \"TYPE 1\", y = \"DEFENSE\",data = df)\nplt.show()","e1470b49":"plt.subplots(figsize = (20,10))\nplt.title('Attack by Type1')\nsns.violinplot(x = \"TYPE 1\", y = \"ATTACK\",data = df)\nplt.ylim(0,200)\nplt.show()","c9446af2":"plt.subplots(figsize = (20,10))\nplt.title('Attack by Type1')\nsns.violinplot(x = \"TYPE 1\", y = \"DEFENSE\",data = df)\nplt.ylim(0,200)\nplt.show()","52b8a9a5":"plt.subplots(figsize = (15,5))\nplt.title('Strongest Genaration')\nsns.violinplot(x = \"GENERATION\", y = \"TOTAL\",data = df)\nplt.show()","cc88135f":"plt.figure(figsize=(10,6)) #manage the size of the plot\nsns.heatmap(df.corr(),annot=True) #df.corr() makes a correlation matrix and sns.heatmap is used to show the correlations heatmap\nplt.show()","5cdb1b5d":"### Strongest Pokemons By Types","4cc14f58":" Distribution of various pokemon types","b8115218":"We'll use the **head** method to print the first rows of our data","e331713f":"### boxplot","614d116d":"### violinplot","666f7b0f":"Above is a Histogram showing the distribution of attacks for the Pokemons. The average value is between 75-77","5b25d561":"We can also create a horizontal bar plot, for example: A horizontal bar chart of the number of pokemons for each type 1","69448ffd":"This shows that generation 3  has the better pokemons","dd3aa5a8":"If we want now we can easily plot our result in a barplot","a14adc9d":"### scatter plot","da1552e4":"We can get specific columns from our dataframe","230c41b3":"### Finding any Correlation between the attributes","95e76214":"the **iloc** method is very similar, instead of using the index as the method of accessing the data it uses the serial index, i.e the number of the row we are trying to access.","896c6375":"## POKEMON STATS ANALYSIS","cb777e99":"let's create an histogram, for example: The attack distribution for the pokemons across all the genarations","db5797cd":"### Matplotlib","6a4db8a7":"Lets start of with a simple bar plot","a0bfb959":"But that does not work. to combine filtering conditions in pandas, we need to use bitwise operators instead of normal python ones ('|' instead of **or** and '&' instead of **and**). and we need to surround every condition with brackets","2ae7d1ce":"We can also sort by multipule columns when giving an array, this means that the if two rows have the same value in the first column we sort by, their order will be determined by the value in the second column","6cf91fe3":"We saw how to filter our dataset when we filtered only legendery pokemons. but what if we want to specify multipule filters?","12df3ddd":"List our input files","35d64773":"Read the csv file from our input and save it to a dataframe (df)","24b3a8b6":"Bar plot","2fbfaef1":"### lineplot","6c3cb93a":"Lets get all the values with mega in their name again to see if it worked","90c3ec4d":"We can use the **unique** method to get all the unique values from a series, and the **nunique** to get the number of unique values from a series","12d2b97d":"A bar chart of the number of pokemons from each generation","0e1675d8":"Lets see how we change values in a column, based on condition:\n\nWe will add 10 to speed to all Legedary Pokemons.","c38195d1":"This shows that fire type pokemons have a better attack than water type pokemons but have a lower defence than water type.","6cd4b541":"We can do alot of interesting things with a series. which we will learn about in this tutorial","0f9efa8d":"Filtering to see legendery pokemon","8f9ac133":"We can also plot a group bar plot","4ef9830d":"lets get all the names that contain Mega in their name","ba2ab396":"### CLEANING THE DATAFRAME","187b1fc4":"The name of these pokemon is formatted a bit strangly, we'll use a regular expression to replace their names","1d133fa2":"Import the important packages we are going to need","f29c0d17":"We can even specify the colors of our types to match the type","b3115d2e":"The first intuative way will be like this","50468d5c":"## VISUALISATIONS","dd1ad746":"Seaborn is another visualization and plotting package which is based on matplotlib. then why should we use it and not matplotlib?. well the seaborn library usually produces better looking plots, with the ability to configure color, legends and more easily. we'll see how to create all the plots we created with matplotlib with seaborn and others we have not yet created","9a42ede5":"We can also group by multipule columns","74fb5407":"We can also print a summary of our data, which gives us alot of statistical information about it","e2ed151e":"Group by is a very useful tool, it lets us group based on a column and ask questions about each group individually","ba849c1f":"### Pie chart","63c9502c":"Lets show some more metadata about our dataframe.\nwe already have seen the **columns** attribute. the **shape** attribute retrives us the total mesures of our data set, the number of rows and columns as a tuple ","2790db33":"if we say that a dataframe is a two dimensional array, then a series is a one dimensional array. it has an index and values. we can get a series when retreving a single column from our dataframe","a19e9798":"We can also specify the number of rows to retrive using **head**","e4458581":"we can use the **max** method to get the max item in a series. and the idxmax method the get the id of the max item in a series","fdd61309":"We'll use the **columns** attribute to get the columns for our dataframe","1c07d906":"We know pokemon don't allways have a secondery type, but for the sake of this example let's say we need the fill the **TYPE 2** values of all pokemon with some value. every pokemon which already has a secondery type is fine, dor the ones that don't will fill them with the value of their **TYPE 1** column. for this we'll use the fillna method, which replaces NaN values in the dataset","d27d3f4f":"## Seaborn","62529283":"We can use the **sort_values** method to sort our dataframe by a specific column ","6c4b1ac9":"From the heatmap it can be seen that there is not much correlation between the attributes of the pokemons. The highest we can see is the correlation between Sp.Atk and the Total ","008a3da5":"Lets look at what is a series, how can we get a series and what we can do with it.","adec6e96":"This shows that steel type pokemons have the highest defence but normal type pokemons have the lowest defence","f998cc73":"We can also use a countplot instead of a barplot. a countplot is very simmilar to a histogram, \n*from the seaborn docs:*\nA count plot can be thought of as a histogram across a categorical, instead of quantitative, variable. \nin our case, the catagory is the pokemon generation and we mesure the change between each generation, instead of looking at each generation separately","22b22538":"The **loc** method is our way to access a specifc item in our dataframe, using our index, since our index is the name of the pokemon it is very easy to search for a specific pokemon","b26579bf":"Lets understand what happand:\nThe following line give as array with boolean variables,it tells as if the string in the given place fulfill the condition.","1cdfcf5a":"Lets remove the # column, using the **drop** method","476f2bc4":"The **values_counts** method is very useful. it returns the count of each value in the series (how many times it appered) in descending order","1ee84baf":"What the violinplot actually does is it plots according to the density of a region. This means that the parts of the plot where the width is thicker denotes a region with higher density points whereas regions with thinner area show less densely populated points.","bfe6c571":"Matplotlib is a very easy and intuative library from visualization and ploting of data. let's see what kind of visuallizations we can do with it","72bc4c8b":"using the **set_index** method we can change the index of our dataframe to a specific column[](http:\/\/)","06234f8c":"All stats analysis of the pokemons","fb7e9c3b":"We can also preform some interesting aggregations","6b5ca8bb":"Number of Pokemons by Type And Generation","65073df3":"Lets see some of the options we can use when we plot our data","d364d342":"Or a stacked bar plot","80ad3c6f":"We can access a single element using it's index (similar to loc)","708f17e9":"#### This shows that the Dragon type pokemons have an edge over the other types as they have a higher attacks compared to the other types. Also since the fire pokemons have lower range of values, but higher attacks, they can be preferred over the grass and water types for attacking.\n","53b2cd7f":"Now that we gone through all the plots we learned, lets get into some more complex ones","60f45a14":"Lets revers the changes","ab9e438e":"We can access certin rows from groups","5cf18954":"Lets format the names of our columns, make all of them in capital letters","e4e43958":"When putting it in the '[]' it will return us only the places where there is an True in the given array"}}