{"cell_type":{"1388899b":"code","2135ca87":"code","e1bf9157":"code","35f30065":"code","6a15e764":"code","3790162e":"code","7396dff3":"code","76e9130a":"code","27931074":"code","6719dd7d":"code","e38afd56":"code","e1929715":"code","8c14ec29":"code","323256c4":"code","d2959546":"code","a267a3b0":"code","f88143e6":"code","f6e1b705":"code","001dfe5c":"code","39dbad49":"markdown","d91fedf7":"markdown","0307e76f":"markdown","5aea9167":"markdown","392d6496":"markdown","95fd718a":"markdown","5c169492":"markdown","4fc1038e":"markdown"},"source":{"1388899b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","2135ca87":"from sklearn.model_selection import train_test_split\nimport keras\nfrom keras.layers import Activation\nfrom keras.layers import Conv2D, BatchNormalization, Dense, Flatten, Reshape","e1bf9157":"df = pd.read_csv('\/kaggle\/input\/sudoku\/sudoku.csv')\ndf.head()","35f30065":"que = df['quizzes'].values\nsoln = df['solutions']","6a15e764":"feat = []\nlabel = []\n\nfor i in que:\n\n    x = np.array([int(j) for j in i]).reshape((9,9,1))\n    feat.append(x)\n\nfeat = np.array(feat)\nfeat = feat\/9\nfeat -= .5    \n\nfor i in soln:\n\n    x = np.array([int(j) for j in i]).reshape((81,1)) - 1\n    label.append(x)   \n\nlabel = np.array(label)","3790162e":"X_train, X_test, y_train, y_test = train_test_split(feat,label, test_size=0.33, random_state=42)","7396dff3":"def get_model():\n\n    model = keras.models.Sequential()\n\n    model.add(Conv2D(64, kernel_size=(3,3), activation='relu', padding='same', input_shape=(9,9,1)))\n    model.add(BatchNormalization())\n    model.add(Conv2D(64, kernel_size=(3,3), activation='relu', padding='same'))\n    model.add(BatchNormalization())\n    model.add(Conv2D(128, kernel_size=(1,1), activation='relu', padding='same'))\n\n    model.add(Flatten())\n    model.add(Dense(81*9))\n    model.add(Reshape((-1, 9)))\n    model.add(Activation('softmax'))\n    \n    return model","76e9130a":"model = get_model()","27931074":"adam = keras.optimizers.Adam(lr=.001)\nmodel.compile(loss='sparse_categorical_crossentropy', optimizer=adam)\n\nmodel.fit(X_train, y_train, batch_size=32, epochs=2)","6719dd7d":"def denorm(a):\n    \n    return (a+.5)*9","e38afd56":"\ndef norm(a):\n    \n    return (a\/9)-.5","e1929715":"import copy","8c14ec29":"\ndef inference_sudoku(sample):\n    \n    '''\n        This function solve the sudoku by filling blank positions one by one.\n    '''\n    \n    feat = copy.copy(sample)\n    \n    while(1):\n        \n        #predicting values\n        out = model.predict(feat.reshape((1,9,9,1)))  \n        out = out.squeeze()\n\n        #getting predicted values\n        pred = np.argmax(out, axis=1).reshape((9,9))+1 \n        #getting probablity of each values\n        prob = np.around(np.max(out, axis=1).reshape((9,9)), 2) \n        \n        #creating mask for blank values\n        feat = denorm(feat).reshape((9,9))\n        #i.e it will give you a 2d array with True\/1 and False\/0 where 0 is found and where 0 is not found respectively\n        mask = (feat==0)\n     \n        #if there are no 0 values left than break\n        if(mask.sum()==0):\n            break\n            \n        #getting probablities of values where 0 is present that is our blank values we need to fill\n        prob_new = prob*mask\n    \n        #getting highest probablity index\n        ind = np.argmax(prob_new)\n        #getting row and col \n        x, y = (ind\/\/9), (ind%9)\n        \n        #getting predicted value at that cell\n        val = pred[x][y]\n        #assigning that value\n        feat[x][y] = val\n        #again passing this sudoku with one value added to model to get next most confident value\n        feat = norm(feat)\n    \n    return pred","323256c4":"\ndef test_accuracy(feats, labels):\n    \n    correct = 0\n    \n    for i,feat in enumerate(feats):\n        \n        pred = inference_sudoku(feat)\n        \n        true = labels[i].reshape((9,9))+1\n        \n        if(abs(true - pred).sum()==0):\n            correct += 1\n        \n    print(correct\/feats.shape[0])","d2959546":"test_accuracy(X_test[:100], y_test[:100])\n","a267a3b0":"def solve_sudoku(game):\n    \n    game = game.replace('\\n', '')\n    game = game.replace(' ', '')\n    game = np.array([int(j) for j in game]).reshape((9,9,1))\n    game = norm(game)\n    game = inference_sudoku(game)\n    return game","f88143e6":"\ngame = '''\n          0 8 0 0 3 2 0 0 1\n          7 0 3 0 8 0 0 0 2\n          5 0 0 0 0 7 0 3 0\n          0 5 0 0 0 1 9 7 0\n          6 0 0 7 0 9 0 0 8\n          0 4 7 2 0 0 0 5 0\n          0 2 0 6 0 0 0 0 9\n          8 0 0 0 9 0 3 0 5\n          3 0 0 8 2 0 0 1 0\n      '''\n\ngame = solve_sudoku(game)\n\nprint('solved puzzle:\\n')\n# print(game)","f6e1b705":"for i in game:\n    print(i)","001dfe5c":"np.sum(game, axis=1)","39dbad49":"# Spliting Data","d91fedf7":"# Preprocessing Data","0307e76f":"# Creating Model","5aea9167":"# Loading Data","392d6496":"# Testing Model ","95fd718a":"# Importing Libraries","5c169492":"# Training our model","4fc1038e":"While testing model there is one change, here we are predicting one value at a time that is what human does while solving sudoku."}}