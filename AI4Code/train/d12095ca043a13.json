{"cell_type":{"2b4c1d14":"code","9b4bdce3":"code","e07ae2a9":"code","4290f92e":"code","3423fa02":"code","cd670b04":"code","d6ed1477":"code","0739979d":"code","18b0b8b5":"code","eb0b0ad2":"code","45b15edc":"code","e0d30311":"code","8e24b87f":"code","d05827c5":"code","b9b7c0db":"code","b9cbea68":"code","0c471bf1":"code","ebff2f6e":"code","9cc2d546":"code","436a9c93":"code","f5f50a59":"code","4537e621":"markdown","1d730b61":"markdown","9d896d58":"markdown","beb0af5b":"markdown","287b6023":"markdown","ab2e5577":"markdown","5f4dc374":"markdown","a057aef4":"markdown","d5dc7753":"markdown","621c39e2":"markdown","2bc92548":"markdown","aadd6a72":"markdown","eecea70b":"markdown","c753c634":"markdown","3cb170d2":"markdown","a7c50c06":"markdown","68325c28":"markdown","29f4760b":"markdown","fc61a9fe":"markdown","da6da3f4":"markdown","4522cbf4":"markdown"},"source":{"2b4c1d14":"import pandas as pd # We use the \"as pd\" in order to be able to call pandas with \"pd\" instead of the whole name","9b4bdce3":"# Ill start with a basic example by creating a DataFrame from a python dictionary \n# wich has the name of the column as the key and a list of data points as values.\ntest_dict = {\"ID\":[1,7,3,10],\"AGE\":[32,22,21,23],\"SEX\":[\"M\",\"F\",\"M\",\"M\"]}\n\ntest_df_1 = pd.DataFrame(test_dict)\ntest_df_1","e07ae2a9":"# First option is to set the index after the DataFrame is created using set_index()\n# This will not be saved unless you assign it to a new variable or to itself\ntest_df_1 = test_df_1.set_index(\"ID\")","4290f92e":"# And the second option would be to stablish the values to use as index within the DataFrame creation\ncopy_test_dict = {k:v for k,v in test_dict.items() if k != \"ID\"}\nids_test_dict = test_dict[\"ID\"]\ntest_df_2 = pd.DataFrame(copy_test_dict,index=ids_test_dict)\ntest_df_2","3423fa02":"test_dict\ntest_df_3 = pd.DataFrame(test_dict,index=test_dict[\"ID\"])\ntest_df_3","cd670b04":"# We can Access them directly from the DataFrame with the columns attribute\nprint(test_df_1.columns)\n# We can modify them directly using the same attribute\ntest_df_1.columns = [\"YEARS_OLD\", \"GENDER\"]\nprint(\"\\n\",test_df_1.head(),\"\\n\")\n# If the array we try to use to change the column names is not of the same size of the existent rows we get a Length mismatch error\ntry:\n    test_df_1.columns = [\"YO\"]\nexcept Exception as e:\n    print(e)","d6ed1477":"age = test_df_1[\"YEARS_OLD\"]\n# By accessing the column this way we get a Series\nprint(f\"age is a: {type(age)}\")\n# Wich can then be downcasted into a list\nlist_age = list(age)\nprint(f\"list_age is now a: {type(list_age)}\")","0739979d":"series_index = age[age == 23].index[0]\nplist_index = list_age.index(23)\nprint(f\"Value 23 has an index of {series_index} on the Series\")\nprint(f\"While the same value has an index of {plist_index} on the python list\")","18b0b8b5":"print(\"age \\t\\tSeries: \\t\", end=\"\")\nfor r in age:\n    print(r, end=\" \")\n\nprint(\"\\n\\nlist_age \\tpython list: \\t\", end=\"\")\nfor a in list_age:\n    print(a, end=\" \")","eb0b0ad2":"%%time\nages_under_30_1 = test_df_1.query(\"YEARS_OLD < 30\")\nprint(ages_under_30_1)","45b15edc":"%%time\nages_under_30_2 = test_df_1[test_df_1.YEARS_OLD < 30]\nprint(ages_under_30_2)","e0d30311":"%%time\nages_under_30_3 = test_df_1.loc[test_df_1.YEARS_OLD < 30]\nprint(ages_under_30_3)","8e24b87f":"age","d05827c5":"print(f\"Sum of ages: {age.sum()}\")\nprint(f\"Min of ages: {age.min()}\")\nprint(f\"Index of min of ages: {age.idxmin()}\")\nprint(f\"Max of ages: {age.max()}\")\nprint(f\"Index of max of ages: {age.idxmax()}\")","b9b7c0db":"confirmed_cases_path = '\/kaggle\/input\/covid19-mx\/casos_confirmados.csv'\nconfirmed_cases_df = pd.read_csv(confirmed_cases_path)\nconfirmed_cases_df.columns = ['ID', 'State', 'Sex', 'Age', 'Date', 'Confirmed']\nconfirmed_cases_df = confirmed_cases_df.set_index(\"ID\")\nconfirmed_cases_df.head()","b9cbea68":"covid_mx_path = '\/kaggle\/input\/covid19-mx\/covid-19_general_MX.csv'\ncovid_mx_df = pd.read_csv(covid_mx_path)\ncovid_mx_df.columns = ['ID', 'SECTOR', 'ENTIDAD_UM', 'SEXO', 'ENTIDAD_RES','TIPO_PACIENTE', 'FECHA_INGRESO', 'FECHA_SINTOMAS',\n                       'FECHA_DEF','INTUBADO', 'NEUMONIA', 'EDAD', 'NACIONALIDAD', 'DIABETES', 'EPOC','ASMA', 'INMUSUPR', 'HIPERTENSION',\n                       'OTRA_CON', 'CARDIOVASCULAR','OBESIDAD', 'RENAL_CRONICA', 'TABAQUISMO', 'OTRO_CASO', 'RESULTADO','UCI']\ncovid_mx_df = covid_mx_df.set_index(\"ID\")\ncovid_mx_df.head(3)","0c471bf1":"covid_mx_df[\"FECHA_DEF\"].count()","ebff2f6e":"%%time\ntotal_d = len(covid_mx_df.loc[(covid_mx_df['FECHA_DEF'] != '9999-99-99') & (covid_mx_df.FECHA_DEF.notnull())])\nprint(f\"Total dead: {total_d}\\n\")","9cc2d546":"%%time\ncovid_mx_df.loc[covid_mx_df['FECHA_DEF'] == \"9999-99-99\", \"FECHA_DEF\"] = None\ntotal_d = covid_mx_df['FECHA_DEF'].count()\nprint(f\"Total dead: {total_d}\\n\")","436a9c93":"sliced_df = covid_mx_df[['ENTIDAD_UM', 'SEXO', 'ENTIDAD_RES', 'TIPO_PACIENTE',\n       'FECHA_INGRESO', 'FECHA_SINTOMAS', 'FECHA_DEF', 'INTUBADO', 'NEUMONIA',\n       'EDAD',]]\nsliced_df.head(3)","f5f50a59":"sliced_df.to_csv(\"sliced_dataframe.csv\")","4537e621":"The ID column still exists without being the index column!\n\nThus we would need to drop it and the process gets longer. Because of this I tend to use the first option and simply assign the index column after creation.\n\nBefore moving to using real world data, I'll show some handy features with this simple DataFrame.","1d730b61":"Both ways allow subindexing but pandas Series require you to use the right index value while python lists allow you to access by order.\n \nFor example the value 23 has an index of 10 on the Series while it has an index of 3 on the python list","9d896d58":"### Every time I have to do something with pandas I end up looking across the internet in order to remember different aspects I tend to get stuck with or some that I tend to forget. Because of this I've decided to start writing those things in this notebook to speed up my development process and hoping that they could help others with similar problems. \n\nI'll be updating this notebook whenever I find something interesting I should add. Hope this helps someone else out there.\n\n----","beb0af5b":"---\n## Filtering columns\nSome times we might want to get specific pieces of data from our DataFrame, because of this pandas has multiple ways of retrieving such information. \n\nWe'll se some ways to retrieve the same information in the following parts. Let's try getting all values under 30","287b6023":"### Loading information FAQs:\n\n* **What information can pandas work with?**\n  \n  Pandas works best with tabular data, as said in the [documentation](https:\/\/pandas.pydata.org\/docs\/getting_started\/intro_tutorials\/01_table_oriented.html#min-tut-01-tableoriented): \n> \"When working with tabular data, such as data stored in spreadsheets or databases, Pandas is the right tool for you.\"\n\n* **What is tabular data?**\n  \n  There's a great [article](https:\/\/www.w3.org\/TR\/tabular-data-model\/) about this by the World Wide Web Consortium I'd recommend reading. In this article they state that:\n> Tabular data is data that is structured into rows, each of which contains information about some thing. Each row contains the same number of cells (although some of these cells may be empty), which provide values of properties of the thing described by the row. In tabular data, cells within the same column provide values for the same property of the things described by each row. This is what differentiates tabular data from other line-oriented formats. \n\n* **What file formats does pandas support?**\n\n  Pandas supports a wide range of formats and encodings; for text some of the supported formats are CSV, JSON, HTML, etc. For binary some of the supported formats are OpenDocument, ORC Format, etc. For the full list check the IO tools section of the [documentation](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/io.html)\n  \n  \n### I hope this section can clear some things out, now let's get into it:","ab2e5577":"This time we only displayed the first 3 rows of the DataFrame using the **head()** function, still we can get a sense of the information contained in the dataset, for example we can see that **FECHA_DEF** has some values like \"9999-99-99\" which as stated in the dataset information those mean the patient didn't die.\n\nLet's try to count the amount of people who unfortunately lost their lives using pandas **count()** function.","5f4dc374":"Still we can loop both variables the same way to retrieve the values. Obtaining the same output","a057aef4":"Here you see how I sliced the DataFrame to just the columns I needed, and in the following block you'll see how to save them using the **to_csv** function. you'll be able to find the output file in the \"output\" section of the kaggle kernel.","d5dc7753":"Pandas **count()** function counts non null values on the DataFrame which is why we get a huge number, because instead of having null on the patients that didn't die we have \"9999-99-99\". Let's try two alternatives to count the values and see which one is the fastest.\n\n1. Counting all rows that are not \"9999-99-99\"\n2. Transforming \"9999-99-99\" into null and then using the **count()** function.","621c39e2":"---\n## Simple operations for columns\nPandas has some handy functions that can help us with recurrent operations such as sum, mean, min, max, etc.\n\nThis operations work with DataFrames and Series, to simplify this and be able to validate the results I'll be using the age Series to exeplify them. For more information you can check the [docs](https:\/\/pandas.pydata.org\/docs\/reference\/api\/pandas.DataFrame.sum.html)","2bc92548":"---\n# Loading from file\n\nNow let's see how to load information from a file to a pandas DataFrame and some basic manipulations of the information.\n\nFor this I'll be using a [dataset](https:\/\/www.kaggle.com\/lalish99\/covid19-mx\/) I've uploaded with a now trending topic COVID-19. The dataset is for Mexico's information on the topic.\n\n---\n### The dataset contains .CSV files, because of this we use the read_csv function\nLet's first load the confirmed cases dataset, which is kind if light.","aadd6a72":"# DataFrame functions\n\n---\n## Changing column names:\nThe names of the columns come from an array, in our previous example, pandas detected them from the keys of the dictionary but by they will default to RangeIndex (0, 1, 2, \u2026, n) if no column labels are provided.","eecea70b":"### Hopefully this will help someone :)","c753c634":"# Creating pandas DataFrame\n\nOne of the first and most important things to know is how to load the information into pandas. I'll explain some of the main ways in which you can load information into a pandas DataFrame","3cb170d2":"---\n## Accessing columns\nColumns are accessable by their names or indexes, and we can extract that information by subscripting the DataFrame","a7c50c06":"We can see that all three methods (query, loc, and subindexing) output the same results. But we can see that loc is the fastest reducing the speed by half compared with the function **query**. In such a small dataset this is irrelevant but with larger ones as we'll see this becomes much more important\n\n*For more information related with [query](https:\/\/pandas.pydata.org\/docs\/reference\/api\/pandas.DataFrame.query.html?highlight=query), [loc](https:\/\/pandas.pydata.org\/docs\/reference\/api\/pandas.DataFrame.loc.html?highlight=loc), or other related doubts. Check the [documentation](https:\/\/pandas.pydata.org\/docs\/reference\/frame.html)*","68325c28":"As you can see I used the **head()** function to show a quick view of the csv file loaded into the new DataFrame confirmed_cases_df.\n\nThis function can be used to return the n first rows. By default it returns 5 rows. This function is widely used to get a quick view of the information contained on the DataFrame.\n\nLet's exemplify this with the main file **covid-19_general_MX.csv**","29f4760b":"# Loading the libraries\n\nFirst of all let's load pandas","fc61a9fe":"As we can see pandas automatically used the keys of the dictionary as the names for the columns of the new DataFrame.\n\nThe only problem is that pandas automatically generates an index column and does not automatically use our ID column for the index. We need to specify this manually using one of the two following ways:","da6da3f4":"As we can see we obtained the same output with both methods, and again **loc** with **count** proved to be slightly faster.\n\n---\n# Saving to file\nLastly somthing that might be really usefull is saving your DataFrame into a file, I'll be doing so with a sliced version of the current DataFrame in order to also demonstrate how powerfull is pandas subindexing.","4522cbf4":"The first options required the DataFrame to be created first, but does not requiring slicing the input as the second one does which could hugely improve performance on large datasets given that you'll simply need to load the information and then select the index.\n\nSee what happens if you dont separate the index column from the rest of the data"}}