{"cell_type":{"11e86287":"code","f3c36089":"code","a4f62e49":"code","50e796c6":"code","33b5a4b8":"code","cb0efbfe":"code","cf0504b5":"code","ff5a475b":"code","7188c000":"code","abdd83f9":"code","d33584b8":"code","3d008ec2":"code","7a4bced3":"code","d99b7840":"code","4c45819d":"code","76cdb712":"code","5a9072fa":"code","f2a7b234":"code","958bfb9f":"code","41ac5ecd":"code","8077adba":"markdown","dfa7d3ef":"markdown","dabc7493":"markdown","5661586d":"markdown","81a40393":"markdown","d32d169c":"markdown","f02b6f34":"markdown","b6303a82":"markdown","f60c047b":"markdown","33544fcb":"markdown","c90d23fa":"markdown","f5f7fb32":"markdown","ba35d007":"markdown","d739d056":"markdown","d3650b49":"markdown","46fdc85f":"markdown","e0990066":"markdown","3780d911":"markdown","274feeb0":"markdown"},"source":{"11e86287":"results_of_solutions = []","f3c36089":"def round_by(value, decimal_places):\n    return int(value * (10 ** decimal_places) + 0.5) \/ (10.0 ** decimal_places)","a4f62e49":"class result:\n    name = \"\"\n    results = []\n    needed_time = 0\n    \n    def __init__(self, name, results, needed_time):\n        self.name = name\n        self.results = results\n        self.needed_time = needed_time","50e796c6":"def calculate_results(solution, name):\n    start_time = time.perf_counter()\n    results = []\n    for data in test_data:\n        results.append(round_by(solution.get_guess(data), 1))\n    needed_time = time.perf_counter() - start_time\n    show_results(results)\n    results_of_solutions.append(result(name, results, needed_time))","33b5a4b8":"from prettytable import PrettyTable\nimport time  # import not needed here but already put here so that I don't need to care about it later\n\nclass Final_result:\n    header = []\n    result = []\n    \n    def __init__(self, header):\n        self.header = header\n        \n    def add_entry(self, name_of_solution, results_of_solution, needed_time):\n        output = [name_of_solution]\n        for result in results_of_solution:\n            output.append(result)\n        time_in_ms = needed_time * 1000 * 1000\n        rounded_time = round_by(time_in_ms, 2)\n        output.append(\"%s \u00b5s\" % rounded_time)\n        self.result.append(output)\n    \n    def add_entries(self, results):\n        for result in results:\n            self.add_entry(result.name, result.results, result.needed_time)\n    \n    def change_header(self, header):\n        self.header = header\n        \n    def print_as_table(self):\n        pretty_table = PrettyTable(field_names=self.header)\n        for row in self.result:\n            pretty_table.add_row(row)\n        print(pretty_table.get_string())","cb0efbfe":"# given_data[which_set_of_data][0 = TV_time; 1 = deep_sleep_time]\ngiven_data = [(0.3, 5.8), (2.2, 4.4), (0.5, 6.5), (0.7, 5.8), (1.0, 5.6), (1.8, 5.0), (3.0, 4.8), (0.2, 6.0), (2.3, 6.1)]\nTV = 0\nDEEP_SLEEP = 1\n\ntest_data = [value * 0.5 + 0.5 for value in range(8)]  # all values from 0.5 to 4.0 in steps of 0.5\nprint(test_data)\n\ngiven_data = sorted(given_data, key=lambda x: x[TV])  # sort the list by time that is spend watching TV\nprint(given_data)","cf0504b5":"import matplotlib.pyplot as plt\n\ntv_times_of_given_data = [data[TV] for data in given_data]  # all TV data as List\ndeep_sleep_of_given_data = [data[DEEP_SLEEP] for data in given_data]  # all DEEP_SLEEP data as list\n\ndef show_results(tv_times):\n    plt.scatter(tv_times_of_given_data, deep_sleep_of_given_data)\n    if tv_times != []:\n        plt.scatter(test_data, tv_times)\n    plt.show()\n    \n# only displays the known data\ndef show_given_data():\n    show_results([])","ff5a475b":"show_given_data()","7188c000":"class value_guesser:\n    def __init__(self):\n        raise NotImplementedError\n    \n    def get_guess(self, tv_time):\n        raise NotImplementedError","abdd83f9":"class closest_left_and_right(value_guesser):\n    def __init__(self):\n        pass\n    \n    def get_guess(self, tv_time):\n        first_value_left_and_right = self.get_first_value_left_and_right(tv_time)  # one value per side\n        avg_value = (first_value_left_and_right[0] + first_value_left_and_right[1]) \/ 2\n        avg_value = avg_value\n        return avg_value\n    \n    def get_first_value_left_and_right(self, tv_time):\n        # might be changed later\n        smaller = 0\n        bigger = 0\n        while smaller < len(given_data) and given_data[smaller][TV] < tv_time:\n            smaller += 1\n        if smaller == 0:\n            bigger = 0 if given_data[smaller][TV] else 1\n        else:\n            smaller -= 1\n            if smaller >= len(given_data) - 1:\n                smaller = len(given_data) - 1\n                bigger = smaller\n            else:\n                bigger = smaller + 1\n        return [given_data[smaller][DEEP_SLEEP], given_data[bigger][DEEP_SLEEP]]","d33584b8":"calculate_results(closest_left_and_right(), \"closest left and right\")","3d008ec2":"class closest_dot(value_guesser):\n    def __init__(self):\n        pass\n        \n    def get_guess(self, value):\n        return given_data[self.find_closest(value)][DEEP_SLEEP]\n    \n    def find_closest(self, value):\n        i = 0\n        while i < len(given_data) and given_data[i][TV] < value:\n            i += 1\n        return i - 1 if i == len(given_data) else i","7a4bced3":"calculate_results(closest_dot(), \"closest dot\")","d99b7840":"class average_of_all_dots(value_guesser):\n    average = 0\n    def __init__(self):\n        self.average = sum([data[DEEP_SLEEP] for data in given_data])\n        self.average \/= len(given_data)\n        \n    def get_guess(self, value):\n        return self.average","4c45819d":"calculate_results(average_of_all_dots(), \"average of known dots\")","76cdb712":"class linear_of_two_closest(value_guesser):\n    def __init__(self):\n        pass\n        \n    def get_guess(self, value):\n        (dot1, dot2) = self.get_two_closest_dots(value)\n        m = (dot2[DEEP_SLEEP] - dot1[DEEP_SLEEP]) \/ (dot2[TV] - dot1[TV])\n        b = dot1[DEEP_SLEEP] - m * dot1[TV]\n        return m * value + b\n    \n    def get_two_closest_dots(self, value):\n        indexes_of_the_closest_two = [0, 1]\n        i = 2\n        indexes_of_the_closest_two = self.sort(indexes_of_the_closest_two, value)\n        while i < len(given_data):\n            if abs(given_data[i][TV] - value) < abs(given_data[indexes_of_the_closest_two[1]][TV] - value):\n                indexes_of_the_closest_two[1] = i\n                indexes_of_the_closest_two = self.sort(indexes_of_the_closest_two, value)\n            i += 1\n        return [given_data[indexes_of_the_closest_two[0]], given_data[indexes_of_the_closest_two[1]]]\n            \n    def sort(self, indexes, value):\n        return sorted(indexes, key=lambda x: abs(given_data[x][TV] - value))","5a9072fa":"calculate_results(linear_of_two_closest(), \"linear two closest dots\")","f2a7b234":"class linear_regression(value_guesser):\n    beta = 0\n    alpha = 0\n    def __init__(self):\n        avg_x = sum([data[TV] for data in given_data]) \/ len(given_data)\n        avg_y = sum([data[DEEP_SLEEP] for data in given_data]) \/ len(given_data)\n        for data in given_data:\n            self.beta += (data[TV] - avg_x) * (data[DEEP_SLEEP] - avg_y)\n        self.beta \/= len(given_data)\n        self.alpha = avg_y - self.beta * avg_x\n    \n    def get_guess(self, value):\n        return self.beta * value + self.alpha","958bfb9f":"calculate_results(linear_regression(), \"linear regression\")","41ac5ecd":"table_header = [\"name of solution\"]\nfor data in test_data:\n    table_header.append(data)\ntable_header.append(\"time\")\nresult_table = Final_result(table_header)\nresult_table.add_entries(results_of_solutions)\nresult_table.print_as_table()","8077adba":"# average of the closest dot on the left and the closest one on the right\nif there is no known dot on one of the sides then it uses the closest dot on the otherside twice","dfa7d3ef":"# taking the deep sleep time of the closest dot","dabc7493":"preparing the known data and the test data","5661586d":"a function to round a value by n decimal places","81a40393":"displaying the known data in a graph","d32d169c":"# just use the average deep sleep time for all","f02b6f34":"creates a Diagram showing the given_data in blue and the results of the solution in green","b6303a82":"a function that takes an object of the class that represents a solution with its name<br>\nand from that it creates a diagram and adds the entry to 'results_of_solutions' for the table at the end","f60c047b":"# Solutions are starting here","33544fcb":"is used to print the results table at the end","c90d23fa":"# linear function crossing the two closest known dots\nit looks for the two closest known dots and then calculates a linear function which goes through both of those dots<br>\nafter that it calculates the result of that linear function for the given value (the time spend watching TV to which you want to know the expected deep sleep time)","f5f7fb32":"# Assuming the deepsleep time by using the time that is spend watching TV","ba35d007":"a data structure where I can save the results of each solution<br>\nit includes:\n- name of the used solution\n- results of the solution\n- needed time to execute solution","d739d056":"a list to store all sets of results of all solutions","d3650b49":"basically an abstract class that will be inherited from all classes for the solutions so that I can iterate over all objects of those solutions and get all results with a simple loop","46fdc85f":"# lineare regression","e0990066":"<h3>creating some globaly needed things<\/h3>","3780d911":"ideas:\n- average of closest dot on the left and the closest one on the right\n- closest dot\n- average of all dots\n- using a linear function that crosses the two closest known dots\n- linear regression","274feeb0":"# Result Table"}}