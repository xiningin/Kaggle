{"cell_type":{"daf74960":"code","8823a6cc":"code","9a623e56":"code","1044bde5":"code","c461e138":"code","37f41432":"code","4e2219c8":"code","3b7dbcf7":"code","7e4f8c58":"code","85b17635":"code","4b90666e":"code","18b753e2":"code","745c486a":"code","85f981eb":"code","567593e9":"code","854c92db":"code","4b5583e7":"code","7333b7c5":"code","b85436c7":"code","9636c68a":"code","eb65a8d7":"code","ece41489":"code","13f6a93b":"markdown","7b2b61fd":"markdown","fdbdad18":"markdown","d13ffafc":"markdown","fb532913":"markdown","ea909741":"markdown","4ff48fc8":"markdown","d8f903e6":"markdown","eadad192":"markdown","099ecb4c":"markdown","ad23d5ca":"markdown"},"source":{"daf74960":"from keras.models import Sequential\nfrom keras.layers.core import Dense, Dropout, Activation, Flatten\nfrom keras.layers.convolutional import Conv2D, MaxPooling2D\nfrom keras.utils import np_utils\nfrom keras.utils import to_categorical\nfrom keras.preprocessing.image import  ImageDataGenerator, img_to_array, image, load_img\nfrom keras import backend as K\nfrom keras.optimizers import Adam, SGD\nfrom keras.callbacks import ReduceLROnPlateau, EarlyStopping\nfrom keras.models import load_model\n\nimport os\nimport numpy as np\nimport pandas as pd\nimport csv\nfrom sklearn.model_selection import StratifiedKFold\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\nimport matplotlib.pyplot as plt\nplt.rcParams['figure.figsize'] = [16, 10]\nplt.rcParams['font.size'] = 16\n\n#Variable defining\nSAMPLE_PER_CATEGORY = 200\nSEED = 42\nWIDTH = 64\nHEIGHT = 64\nDEPTH = 3\nINPUT_SHAPE = (WIDTH, HEIGHT, DEPTH)\n\ndata_dir = '..\/input\/plant-seedlings-classification\/'\ntrain_dir = os.path.join(data_dir, 'train')\ntest_dir = os.path.join(data_dir, 'test')\nsample_submission = pd.read_csv(os.path.join(data_dir, 'sample_submission.csv'))","8823a6cc":"!ls ..\/input\/plant-seedlings-classification","9a623e56":"CATEGORIES = ['Black-grass', 'Charlock', 'Cleavers', 'Common Chickweed', 'Common wheat', 'Fat Hen', 'Loose Silky-bent',\n              'Maize', 'Scentless Mayweed', 'Shepherds Purse', 'Small-flowered Cranesbill', 'Sugar beet']\nNUM_CATEGORIES = len(CATEGORIES)\nNUM_CATEGORIES","1044bde5":"for category in CATEGORIES:\n    print('{} {} images'.format(category, len(os.listdir(os.path.join(train_dir, category)))))","c461e138":"def read_img(filepath, size):\n    img = image.load_img(os.path.join(data_dir, filepath), target_size=size) ## https:\/\/www.tensorflow.org\/api_docs\/python\/tf\/keras\/preprocessing\/image\/load_img\n    img = image.img_to_array(img)\n    return img","37f41432":"train = []\nfor category_id, category in enumerate(CATEGORIES):\n    for file in os.listdir(os.path.join(train_dir, category)):\n        train.append(['train\/{}\/{}'.format(category, file), category_id, category])\ntrain = pd.DataFrame(train, columns=['file', 'category_id', 'category'])\ntrain.shape","4e2219c8":"train.head(2)","3b7dbcf7":"train = pd.concat([train[train['category'] == c][:SAMPLE_PER_CATEGORY] for c in CATEGORIES])\ntrain = train.sample(frac=1)\ntrain.index = np.arange(len(train))\ntrain.shape","7e4f8c58":"train","85b17635":"test = []\nfor file in os.listdir(test_dir):\n    test.append(['test\/{}'.format(file), file])\ntest = pd.DataFrame(test, columns=['filepath', 'file'])\ntest.shape","4b90666e":"test.head(2)","18b753e2":"fig = plt.figure(1, figsize=(NUM_CATEGORIES, NUM_CATEGORIES))\ngrid = ImageGrid(fig, 111, nrows_ncols=(NUM_CATEGORIES, NUM_CATEGORIES), axes_pad=0.05)\ni = 0\nfor category_id, category in enumerate(CATEGORIES):\n    for filepath in train[train['category'] == category]['file'].values[:NUM_CATEGORIES]:\n        ax = grid[i]\n        img = read_img(filepath, (WIDTH, HEIGHT))\n        ax.imshow(img \/ 255.)\n        ax.axis('off')\n        if i % NUM_CATEGORIES == NUM_CATEGORIES - 1:\n            ax.text(250, 112, filepath.split('\/')[1], verticalalignment='center')\n        i += 1\nplt.show();","745c486a":"np.random.seed(seed=SEED)","85f981eb":"#create model from scratch\ndef createModel(number_of_hidden_layers, activation, optimizer, learning_rate, epochs):\n    print(\"Create Model\")\n\n    model = Sequential()\n\n    model.add(Conv2D(WIDTH, (3, 3), padding=\"same\", input_shape=INPUT_SHAPE))\n    model.add(Activation(activation))\n    model.add(Conv2D(WIDTH, (3, 3)))\n    model.add(Activation(activation))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Dropout(0.25))\n\n    model.add(Conv2D(2*WIDTH, (3, 3), padding=\"same\"))\n    model.add(Activation(activation))\n    model.add(Conv2D(2*WIDTH, (3, 3)))\n    model.add(Activation(activation))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Dropout(0.25))\n\n    model.add(Flatten())\n    \n    for i in range(0,number_of_hidden_layers):\n        model.add(Dense(512))\n        model.add(Activation(activation))\n        model.add(Dropout(0.5))\n\n    model.add(Dense(12, activation='softmax'))\n\n    if optimizer == 'SGD':\n        opt = SGD(lr=learning_rate, decay=learning_rate \/ epochs)\n    elif optimizer == 'Adam':\n        opt = Adam(lr=learning_rate, decay=learning_rate \/ epochs)\n\n    model.compile(loss=\"categorical_crossentropy\", optimizer=opt, metrics=[\"accuracy\"])\n    return model","567593e9":"def printHistory(history, title, epochs):\n    f, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n    t = f.suptitle(title, fontsize=12)\n    f.subplots_adjust(top=0.85, wspace=0.3)\n\n    epoch_list = list(range(1,epochs+1))\n    ax1.plot(epoch_list, history.history['accuracy'], label='Train Accuracy')\n    ax1.plot(epoch_list, history.history['val_accuracy'], label='Validation Accuracy')\n    ax1.set_xticks(np.arange(0, epochs+1, 5))\n    ax1.set_ylabel('Accuracy Value')\n    ax1.set_xlabel('Epoch')\n    ax1.set_title('Accuracy')\n    l1 = ax1.legend(loc=\"best\")\n\n    ax2.plot(epoch_list, history.history['loss'], label='Train Loss')\n    ax2.plot(epoch_list, history.history['val_loss'], label='Validation Loss')\n    ax2.set_xticks(np.arange(0, epochs+1, 5))\n    ax2.set_ylabel('Loss Value')\n    ax2.set_xlabel('Epoch')\n    ax2.set_title('Loss')\n    l2 = ax2.legend(loc=\"best\")","854c92db":"#callbacks for keras modal\ndef get_callbacks(patience):\n    print(\"Get Callbacks\")\n\n    lr_reduce = ReduceLROnPlateau(monitor='val_acc', factor=0.1, min_delta=1e-5, patience=patience, verbose=1)\n    #msave = ModelCheckpoint(filepath, save_best_only=True)\n    return [lr_reduce, EarlyStopping()]","4b5583e7":"def evaluateModelDFViaCrossValidation(images, epochs, batch_size, learning_rate, cross_validation_folds, activation, number_of_hidden_layers, optimizer):\n    print(\"Train Model\")\n     \n    datagen_train = ImageDataGenerator(rescale=1.\/255)\n\n    datagen_valid = ImageDataGenerator(rescale=1.\/255)\n        \n    print(\"Cross validation\")\n    kfold = StratifiedKFold(n_splits=cross_validation_folds, shuffle=True)\n    cvscores = []\n    iteration = 1\n    \n    t = images.category_id\n    \n    for train_index, test_index in kfold.split(np.zeros(len(t)), t):\n\n        print(\"======================================\")\n        print(\"Iteration = \", iteration)\n\n        iteration = iteration + 1\n\n        train = images.loc[train_index]\n        test = images.loc[test_index]\n\n        print(\"======================================\")\n        \n        model = createModel(number_of_hidden_layers, activation, optimizer, learning_rate, epochs)\n\n        print(\"======================================\")\n        \n        train_generator = datagen_train.flow_from_dataframe(dataframe=train,\n                                                  directory=\"\/kaggle\/input\/plant-seedlings-classification\/\",\n                                                  x_col=\"file\",\n                                                  y_col=\"category\",\n                                                  batch_size=batch_size,\n                                                  seed=SEED,\n                                                  shuffle=True,\n                                                  class_mode=\"categorical\",\n                                                  target_size=(HEIGHT, WIDTH));\n        valid_generator=datagen_valid.flow_from_dataframe(dataframe=test,\n                                                  directory=\"\/kaggle\/input\/plant-seedlings-classification\/\",\n                                                  x_col=\"file\",\n                                                  y_col=\"category\",\n                                                  batch_size=batch_size,\n                                                  seed=SEED,\n                                                  shuffle=False,\n                                                  class_mode=\"categorical\",\n                                                  target_size=(HEIGHT, WIDTH));\n        \n        STEP_SIZE_TRAIN=train_generator.n\/\/train_generator.batch_size\n        STEP_SIZE_VALID=valid_generator.n\/\/valid_generator.batch_size\n\n        #Trains the model on data generated batch-by-batch by a Python generator\n        history = model.fit_generator(generator=train_generator,\\\n                            validation_data = valid_generator, \\\n                            steps_per_epoch=STEP_SIZE_TRAIN, \\\n                            validation_steps=STEP_SIZE_VALID, \\\n                            epochs=epochs, \\\n                            verbose=1)#, \\\n#                             callbacks = get_callbacks(patience=2))\n        \n        scores = model.evaluate_generator(generator=valid_generator, steps=STEP_SIZE_VALID, pickle_safe=True)\n        print(\"Accuarcy %s: %.2f%%\" % (model.metrics_names[1], scores[1]*100))\n        cvscores.append(scores[1] * 100)\n        \n        printHistory(history, \"Basic CNN performance\", epochs)\n\n    accuracy = np.mean(cvscores);\n    std = np.std(cvscores);\n    print(\"Accuracy: %.2f%% (+\/- %.2f%%)\" % (accuracy, std))\n    return accuracy, std","7333b7c5":"# Use different combinations to find the best params.\n# Also change the CreateModel function to change the network architecture\nevaluateModelDFViaCrossValidation(\n    train,\n    batch_size =32,\n    cross_validation_folds = 5,\n    learning_rate = 0.001,\n    activation = 'relu',\n    number_of_hidden_layers = 1,\n    optimizer = 'Adam',\n    epochs = 48\n)","b85436c7":"def trainFinalModel(images, epochs, batch_size, learning_rate, activation, number_of_hidden_layers, optimizer):\n    print(\"Train Model\")\n     \n    datagen_train = ImageDataGenerator(rescale=1.\/255)\n    \n    print(\"======================================\")    \n    model = createModel(number_of_hidden_layers, activation, optimizer, learning_rate, epochs)\n    print(\"======================================\")\n    \n    train_generator = datagen_train.flow_from_dataframe(dataframe=images,\n                                                        directory=\"\/kaggle\/input\/plant-seedlings-classification\/\",\n                                                        x_col=\"file\",\n                                                        y_col=\"category\",\n                                                        batch_size=batch_size,\n                                                        seed=SEED,\n                                                        shuffle=True,\n                                                        class_mode=\"categorical\",\n                                                        target_size=(HEIGHT, WIDTH));\n        \n    print (train_generator.class_indices)\n    \n    STEP_SIZE_TRAIN=train_generator.n\/\/train_generator.batch_size\n    \n    #Trains the model on data generated batch-by-batch by a Python generator\n    model.fit_generator(generator=train_generator,\\\n                            steps_per_epoch=STEP_SIZE_TRAIN, \\\n                            epochs=epochs, \\\n                            verbose=1)#, \\\n#                             callbacks = get_callbacks(patience=2))\n        \n    model.save(\"\/kaggle\/working\/best_model\")\n    \n    return train_generator.class_indices","9636c68a":"#predict values \ndef predict_createSubmission(class_indices):\n    print(\"Predicting......\")\n    \n    datagen_test = ImageDataGenerator(rescale=1.\/255)\n    \n    test_generator = datagen_test.flow_from_dataframe(dataframe=test,\n                                                        directory=\"\/kaggle\/input\/plant-seedlings-classification\/test\/\",\n                                                        x_col=\"file\",\n                                                        y_col=None,\n                                                        batch_size=1,\n                                                        seed=SEED,\n                                                        shuffle=False,\n                                                        class_mode=None,\n                                                        target_size=(HEIGHT, WIDTH));\n        \n    model = load_model('\/kaggle\/working\/best_model')\n    filenames = test_generator.filenames\n    nb_samples = len(filenames)\n\n    predictions = model.predict_generator(test_generator,steps = nb_samples) # return prob of each class per image (softmax)\n    \n    predicted_class_indices=np.argmax(predictions,axis=1)\n       \n    labels = dict((v,k) for k,v in class_indices.items())\n    predicted_labels = [labels[k] for k in predicted_class_indices]\n    \n    results=pd.DataFrame({\"file\":filenames,\n                          \"species\":predicted_labels})\n\n    print (results)\n    \n    results.to_csv(\"submission.csv\",index=False)\n\n    print(\"Prediction Completed\")","eb65a8d7":"# Following model parameters were identified as best by evaluating various combinations above.\nclass_indices = trainFinalModel(\n    train,\n    batch_size =32,\n    learning_rate = 0.001,\n    activation = 'relu',\n    number_of_hidden_layers = 1,\n    optimizer = 'Adam',\n    epochs = 48\n)","ece41489":"predict_createSubmission(class_indices)","13f6a93b":"**Imports and Workspace setting**","7b2b61fd":"**Generating vector for training samples taking equal number of images from each category**","fdbdad18":"**Generating example images**","d13ffafc":"**Build the model with best params and save it**","fb532913":"**Introduction**\n\nThis is a very basic implementation of convolutional neural network (CNN) without using pretrained models. Fully implemented using keras. You can learn following things by reading this.  \n\n1. Keras implementation of a CNN.\n2. StratidiedKFold evaluation.\n3. Utility funcitons required when working with images.\n\n*Comment your improvements and be sure the upvote.*","ea909741":"**Do predictions on given test images and submit predictions**","4ff48fc8":"**Print function for training history**","d8f903e6":"**Understanding test-set**","eadad192":"**Training sample data set info**","099ecb4c":"Used following articles and kernels for this work:\n\n> https:\/\/www.kaggle.com\/chamathsajeewa\/simple-convolution-neural-network    \n> https:\/\/medium.com\/@vijayabhaskar96\/tutorial-on-keras-flow-from-dataframe-1fd4493d237c   \n> https:\/\/www.kaggle.com\/gaborfodor\/seedlings-pretrained-keras-models   \n","ad23d5ca":"**Defining categories**"}}