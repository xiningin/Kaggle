{"cell_type":{"69c6112b":"code","db8c3913":"code","352a511d":"code","2a28a9e1":"code","ce1d0fb0":"code","6734a9c1":"code","139aa3a9":"code","ea6ca706":"code","c3e1ef21":"code","c9912d4b":"code","ebf99036":"code","753a7403":"code","dace16bd":"code","6b7b35b2":"code","6600918d":"code","f4d645ef":"code","75f409ef":"code","d64011aa":"markdown","caa1bb4c":"markdown","b630d943":"markdown","2e2e7355":"markdown","db70817a":"markdown","3a65186b":"markdown","e8a82745":"markdown","c2dd06b2":"markdown","1da80e4a":"markdown","4952b631":"markdown","63dc72b7":"markdown"},"source":{"69c6112b":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nfrom skimage.color import rgb2gray\nimport cv2\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom scipy import ndimage\nfrom sklearn.model_selection import train_test_split\n#from PIL import Image\nimport cv2\nfrom sklearn.preprocessing import LabelBinarizer\nimport keras\nfrom keras import backend as K\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D, Activation\nfrom keras.losses import categorical_crossentropy, binary_crossentropy\nfrom keras.optimizers import Adam\nfrom keras.utils import to_categorical","db8c3913":"path = '..\/input\/understanding_cloud_organization\/'\ndata = pd.read_csv(path + 'train.csv')\ndata = data.fillna(-1)\ntr, test = train_test_split(data, test_size=0.5)\ntr.head(10)","352a511d":"train = tr[tr['EncodedPixels']!= -1]\ntrain['ImageId'] = tr['Image_Label'].apply(lambda x : x.split('_')[0])\ntrain['ClassId'] = tr['Image_Label'].apply(lambda x : x.split('_')[1])\n# train = train[train['ImageId'].unique()]\ntrain = train[['ImageId', 'ClassId', 'EncodedPixels']]\nprint(train.shape)\ntrain.head(10)","2a28a9e1":"images_path = \"..\/input\/understanding_cloud_organization\/train_images\/\"\nimg = train.iloc[0][\"ImageId\"]\nclassId = train.iloc[0][\"ClassId\"]\npixels = train.iloc[0][\"EncodedPixels\"]\n\nprint(\"class\", classId)\nimage = plt.imread(images_path + img)\nimage.shape\nplt.imshow(image)\n\nprint('encoded pixels', image)","ce1d0fb0":"classes = train['ClassId'].value_counts()\nplt.bar(classes.index, classes)\nplt.show()","6734a9c1":"def rle_to_mask(rle_string, img):\n    rows, cols = img.shape[0], img.shape[1]\n    img = np.zeros(rows*cols, dtype=np.uint8)\n    if rle_string == -1:\n        return img\n    else:\n        rle_numbers = [int(x) for x in rle_string.split(' ')]\n        rle_pairs = np.array(rle_numbers).reshape(-1,2)\n\n        for index, length in rle_pairs:\n            index -= 1\n            img[index:index+length] = 255\n        img = img.reshape(cols,rows)\n        img = img.T\n        img = image = np.expand_dims(img, axis=2)\n\n        return img\n\n# print(train.iloc[1]['EncodedPixels'])\n# print(train.iloc[1]['ImageId'])\n\nprint(rle_to_mask(train.iloc[1]['EncodedPixels'], cv2.imread(images_path + train.iloc[1]['ImageId'])))","139aa3a9":"image_ids = list(train['ImageId'])\npixels = []\nprint(len(image_ids))\nc = 0\nfor i in image_ids:\n    c = c + 1\n#     print(c)\n    img = cv2.imread(images_path + i)\n    img = cv2.resize(img, (64, 64))\n    tmp = np.zeros((img.shape[0], img.shape[1], 3), dtype=np.uint8)\n    types = list(train[train['ImageId']==i]['EncodedPixels'])\n    for j in types:\n        tmp = tmp + img + rle_to_mask(j, img)\/255.0\n    pixels.append(tmp)","ea6ca706":"encoder = LabelBinarizer()\ntransfomed_label = encoder.fit_transform(train['ClassId'])\nprint(train['ClassId'][:5])\nprint(transfomed_label[:5])","c3e1ef21":"def dice_coef(y_true, y_pred, smooth=1):\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = K.sum(y_true_f * y_pred_f)\n    return (2. * intersection + smooth) \/ (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)\n\ndef dice_loss(y_true, y_pred):\n    smooth = 1.\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = y_true_f * y_pred_f\n    score = (2. * K.sum(intersection) + smooth) \/ (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)\n    return 1. - score\n\ndef bce_dice_loss(y_true, y_pred):\n    return binary_crossentropy(y_true, y_pred) + dice_loss(y_true, y_pred)","c9912d4b":"model = Sequential()\n\ninput_shape = (64, 64, 3)\n\n\nmodel.add(Conv2D(32, kernel_size=(2, 2), strides=(1, 1), activation='relu', input_shape=input_shape))\nmodel.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))\n\nmodel.add(Conv2D(32, kernel_size=(2, 2), strides=(1, 1), activation='relu', input_shape=input_shape))\nmodel.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))\n\nmodel.add(Conv2D(32, kernel_size=(2, 2), strides=(1, 1), activation='relu', input_shape=input_shape))\nmodel.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))\n\nmodel.add(Conv2D(16, kernel_size=(2, 2), strides=(1, 1), activation='relu', input_shape=input_shape))\nmodel.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))\n\nmodel.add(Conv2D(16, kernel_size=(2, 2), strides=(1, 1), activation='relu', input_shape=input_shape))\nmodel.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))\n\nmodel.add(Conv2D(8, kernel_size=(2, 2), strides=(1, 1), activation='relu', input_shape=input_shape))\nmodel.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))\n\nmodel.add(Flatten())\nmodel.add(Dense(8))\n\nmodel.add(Dense(4, activation='sigmoid'))\n","ebf99036":"model.compile(optimizer='adam', loss=bce_dice_loss, metrics=[dice_coef])\nmodel.fit([pixels], transfomed_label, batch_size=1, epochs=24, validation_split=0.1)","753a7403":"model.summary()","dace16bd":"def rle2mask(rle, width, height):\n    if rle == '-1':\n        return np.zeros((width, height))\n    mask = np.zeros(width * height)\n    array = np.asarray([int(x) for x in rle.split()])\n    starts = array[0::2]\n    lengths = array[1::2]\n\n    current_position = 0\n    for index, start in enumerate(starts):\n        current_position += start\n        mask[current_position:current_position+lengths[index]] = 255\n        current_position += lengths[index]\n\n    return mask.reshape(width, height)","6b7b35b2":"print(test.iloc[77])\npixels_test = []\nimgs = test.iloc[77]['Image_Label'].split('_')\nimg = cv2.imread(images_path + imgs[0])\nimg = cv2.resize(img, (64, 64))\ntmp = np.zeros((img.shape[0], img.shape[1], 3), dtype=np.uint8)\ntypes = list(train[train['ImageId']==i]['EncodedPixels'])\n# print('image', img)\ntmp = tmp + img + rle_to_mask(test.iloc[21]['EncodedPixels'], img)\/255.0\npixels_test.append(tmp)","6600918d":"test_img = cv2.imread(images_path + imgs[0])\ntestimg = cv2.resize(test_img, (64, 64))\nplt.imshow(testimg)\n# tmp =  np.zeros((testimg.shape[0], testimg.shape[1], 1), dtype=np.uint8) + testimg + rle_to_mask(test.iloc[20]['EncodedPixels'], img)\n# plt.imshow(tmp)\n\n# px = rle_to_mask(test.iloc[82]['EncodedPixels'], img)\n# print(px)","f4d645ef":"test_res = model.predict([pixels_test])","75f409ef":"classes = ['fish', 'flower', 'gravel', 'sugar']\n\nprint(classes[np.argmax(test_res)])","d64011aa":"**Load Data**","caa1bb4c":"**Predictors & Targets**","b630d943":"**Data Analysis**","2e2e7355":"**Model Predict**","db70817a":"**Prepare Data**","3a65186b":"**Model**","e8a82745":"**Submission**","c2dd06b2":"**Loss Functions**","1da80e4a":"**Result**","4952b631":"**Load Libraries**","63dc72b7":"**Model Fit**"}}