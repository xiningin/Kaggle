{"cell_type":{"588ec127":"code","f2265d51":"code","946e18bd":"code","db6cd304":"code","51f93a8a":"code","ec52f3b2":"code","39d583f2":"code","762cf683":"code","6e88be47":"code","0b0a4733":"code","0d984ca1":"code","c1eeacae":"code","e51635f2":"code","a0e8d361":"code","c2f95b4d":"code","77d7b686":"code","72c35ff6":"code","9a6b37a4":"code","9c97468d":"code","0696f43f":"markdown","358ca26f":"markdown","12263cc2":"markdown","66d1e07a":"markdown","d564c842":"markdown","986289e9":"markdown","17d3d625":"markdown","628050e8":"markdown","c5e015ba":"markdown","189a0d76":"markdown","3d1bdfc2":"markdown","823e1547":"markdown","65563e90":"markdown","311a3f38":"markdown","60606da7":"markdown","94408084":"markdown","365265db":"markdown"},"source":{"588ec127":"import pandas as pd\nimport numpy as np\nimport os\nimport random\nfrom matplotlib import image as im\nfrom matplotlib import pyplot as plt\nrandom.seed(9876543210)","f2265d51":"DIR = \"..\/input\/minecraft-skins\/skins\"\n\ndef get_max_bound():\n    return len(os.listdir(DIR))\n\ndef get_image(index):\n    try:\n        return im.imread(os.path.join(DIR, os.listdir(DIR)[index]))\n    except Exception as e:\n        return im.imread(os.path.join(DIR, os.listdir(DIR)[index]), 0)\n\ndef get_file(index):\n    return os.listdir(DIR)[index]\n\ndef get_or_none(index):\n    try:\n        img = get_image(index)\n        assert np.equal(img.shape, (64, 64, 4)).all\n        return img\n    except:\n        return None","946e18bd":"plt.imshow(get_image(505))\nplt.show()","db6cd304":"# simple stream object from: https:\/\/gist.github.com\/ye-yu\/26d6806ceb1f7b0712763a1ce6bdac29\n# simple stream object\nclass Stream:\n  def __init__(self, iterable):\n    self.iterable = iterable\n    self.operations = []\n  \n  def filter(self, fn):\n    return self.of(filter(fn, self.iterable))._stamp(self, \"filter \" + fn.__name__)\n\n  def map(self, fn):\n    return self.of(map(fn, self.iterable))._stamp(self, \"map \" + fn.__name__)\n  \n  def map_key(self, fn):\n    '''\n    fn must return tuple length more than 1\n    '''\n    return self.of(self.__map_key(fn, self.collect()))._stamp(self, \"map \" + fn.__name__)\n\n  def reduce(self, fn):\n    iterable = self.iterable\n    result = None\n    try:\n      result = next(iterable)\n      while(True):\n        result = fn(result, next(iterable))\n    except:\n      return result\n    \n  def collect(self):\n    return list(self.iterable)\n  \n  def enumerate(self):\n    return Stream(enumerate(self.iterable))\n  \n  def _stamp(self, streamobj, name):\n    self.operations = streamobj.operations\n    self.operations += [name]\n    return self\n\n  def __str__(self):\n    return self.__repr__() + \"\\n  -> \" + \"\\n  -> \".join(self.operations)\n  \n  def __repr__(self):\n    return \"[Stream object]\"\n  \n  @staticmethod\n  def of(iterable):\n    return Stream(iter(iterable))\n  \n  @staticmethod\n  def __map_key(fn, arr):\n    ref = dict()\n    for i in arr:\n      k = fn(i)\n      if (k[0] not in ref.keys()):\n        ref[k[0]] = []\n      ref[k[0]] += k[1:]\n\n    for k in ref.keys():\n      yield [k] + ref[k]","51f93a8a":"invalid_imgs = Stream\\\n.of(range(get_max_bound()))\\\n.filter(lambda x: get_or_none(x) is None)\\\n.collect()","ec52f3b2":"invalid_imgs","39d583f2":"# utility function from: https:\/\/gist.github.com\/ye-yu\/1f8e5eaa4a6d162d3ee11354c83fe910\nimport numpy as np\n\nclass ImageCapture:\n  def __init__(self, x, y, width, height):\n    assert type(x) is int, f\"x must be int. Got {x}\"\n    assert type(y) is int, f\"y must be int. Got {y}\"\n    assert type(width) is int, f\"width must be int. Got {width}\"\n    assert type(height) is int, f\"height must be int. Got {height}\"\n\n    self.x = x\n    self.y = y\n    self.width = width\n    self.height = height\n\n    \n  def capture(self, arr):\n    if (not isinstance(arr, np.ndarray)):\n      arr = np.array(arr)\n    return arr[\n      self.y:self.y + self.height,\n      self.x:self.x + self.width,\n      :\n    ]\n\nclass Translator(ImageCapture):\n  def __init__(self, sourceX=None, sourceY=None, destX=None, destY=None, width=None, height=None, imageCapture=None):\n    if imageCapture is not None:\n      super().__init__(imageCapture.x, imageCapture.Y, imageCapture.width, imageCapture.height)\n    else:\n      super().__init__(sourceX, sourceY, width, height)\n    \n    assert type(destX) is int, f\"destX must be int. Got {destX}\"\n    assert type(destY) is int, f\"destY must be int. Got {destY}\"\n\n    self.destX = destX\n    self.destY = destY\n\n  def translate(self, source, dest):\n    source = self.capture(source)\n    dest[self.destY:self.destY + self.height, self.destX:self.destX + self.width, :] = source\n    return dest\n  \n  def to_img_capture(self):\n    return ImageCapture(self.x, self.y, self.width, self.height)\n\nclass MinecraftSkin:\n  def __init__(self, arr):\n    if np.equal(arr.shape, (32, 64, 4)).all():\n      self.img32 = arr\n      self.img64 = np.vstack((self.img32, np.zeros((32, 64, 4), dtype=np.uint8)))\n      for translator in MinecraftSkin.__get_translators():\n        self.img64 = translator.translate(self.img32, self.img64)\n    elif np.equal(arr.shape, (64, 64, 4)).all():\n      self.img64 = arr\n      self.img32 = self.img64[:32, :, :]\n    else:\n      raise Exception(\"Invalid shape. Got\", arr.shape)\n      \n    components = {}\n    \n    chunk = 8\n    tops = [ImageCapture(i * chunk, 0, chunk, chunk) for i in range(8)]\n    bots = [ImageCapture(i * chunk, chunk, chunk, chunk) for i in range(8)]\n    \n    components['head_top'] = tops[1]\n    components['head_bottom'] = tops[2]\n    components['head_left'] = bots[0]\n    components['head_front'] = bots[1]\n    components['head_behind'] = bots[2]\n    components['head_right'] = bots[3]\n    \n    components['helm_top'] = tops[5] \n    components['helm_bottom'] = tops[6]\n    components['helm_left'] = bots[4]\n    components['helm_front'] = bots[4]\n    components['helm_behind'] = bots[4]\n    components['helm_right'] = bots[4]\n    \n    mids = [[ImageCapture(0, (i + 1) * 2 * chunk, 2 * chunk, 2 * chunk),\n              ImageCapture(2 * chunk, (i + 1) * 2 * chunk, 3 * chunk, 2 * chunk),\n              ImageCapture(5 * chunk, (i + 1) * 2 * chunk, 2 * chunk, 2 * chunk)]\n              for i in range(2)]\n    \n    components['leg_right'] = mids[0][0]\n    components['leg_right_acc'] = mids[1][0]\n    components['body'] = mids[0][1]\n    components['body_acc'] = mids[1][1]\n    components['arm_right'] = mids[0][2]\n    components['arm_right_acc'] = mids[0][2]\n    \n    last = [ImageCapture(2 * i*chunk, 6 * chunk, 2 * chunk, 2 * chunk) for i in range(4)]\n    \n    components['leg_left_acc'] = last[0]\n    components['leg_left'] = last[1]\n    components['arm_left'] = last[2]\n    components['arm_left_acc'] = last[3]\n    \n    self.components = components\n  \n  def get_keys(self):\n    return self.components.keys()\n  \n  def get_component(self, comp):\n    return self.components[comp].capture(self.img64)\n  \n  def get_folded_component(self, comp):\n    if 'leg' in comp or 'arm' in comp:\n      return MinecraftSkin.fold_limb(self.get_component(comp))\n    return self.get_component(comp)\n  \n  def to_img64(self):\n    return self.img64\n  \n  def to_img32(self):\n    return self.img32\n  \n  def get_deterministic_random(self, params=1):\n    import random\n    random.seed(0)\n    for i in self.to_img64().flatten():\n      random.seed(random.random() + i)\n    return [random.random() for i in range(params)]\n\n  @staticmethod\n  def fold_limb(img):\n    chunk = 4\n    assert np.equal(img.shape, (4 * chunk, 4 * chunk, 4)).all(), f\"Shape must be {(16, 16, 4)}, got {img.shape}\"\n    left  = Translator(        0, chunk,     chunk, 4 * chunk, chunk, 3 * chunk)\n    right = Translator(3 * chunk, chunk, 2 * chunk, 4 * chunk, chunk, 3 * chunk)\n    img = np.vstack((img, np.zeros((3 * chunk, img.shape[1], img.shape[2]), dtype=np.uint8)))\n    img =  left.translate(img, img)\n    img = right.translate(img, img)\n    return img[:, chunk:3 * chunk, :]\n      \n  @staticmethod\n  def unfold_limb(img):\n    assert np.equal(img.shape, (28, 8, 4)).all(), f\"Shape must be {(28, 8, 4)}, got {img.shape}\"\n    chunk = 4\n    left  = Translator(    0, 4 * chunk,         0,     chunk,     chunk, 3 * chunk)\n    right = Translator(chunk, 4 * chunk, 3 * chunk,     chunk,     chunk, 3 * chunk)\n    body  = Translator(    0,         0,     chunk,         0, 2 * chunk, 4 * chunk)\n    out = np.zeros((16, 16, 4), dtype=np.uint8)\n    out = left.translate(img, out)\n    out = body.translate(img, out)\n    out = right.translate(img, out)\n    return out\n\n  @staticmethod\n  def __get_translators():\n    return [\n      Translator(4, 16, 20, 48, 4, 4),\n      Translator(8, 16, 24, 48, 4, 4),\n      Translator(0, 20, 24, 52, 4, 12),\n      Translator(4, 20, 20, 52, 4, 12),\n      Translator(8, 20, 16, 52, 4, 12),\n      Translator(12, 20, 28, 52, 4, 12),\n      Translator(44, 16, 36, 48, 4, 4),\n      Translator(48, 16, 40, 48, 4, 4),\n      Translator(40, 20, 40, 52, 4, 12),\n      Translator(44, 20, 36, 52, 4, 12),\n      Translator(48, 20, 32, 52, 4, 12),\n      Translator(52, 20, 44, 52, 4, 12),\n    ]","762cf683":"ms = MinecraftSkin(get_image(9))\nms.get_deterministic_random(3)","6e88be47":"def get_rgb_histogram(img, channel=0, nbins=np.iinfo(np.uint8).max + 1, clip_low = 1):\n    img = img[:, :, channel].flatten()\n    img = img[img >= clip_low]\n    ratio = (np.iinfo(np.uint8).max + 1) \/ nbins\n    bins = [i * ratio for i in range(nbins)] + [np.iinfo(np.uint8).max + 1]\n    return np.histogram(img, bins=bins, density=True)","0b0a4733":"def get_merged_histogram(img, histogram_fn, **other_params):\n    chnl1 = histogram_fn(img, channel=0,**other_params)\n    chnl2 = histogram_fn(img, channel=1,**other_params)\n    chnl3 = histogram_fn(img, channel=2,**other_params)\n    return np.hstack((chnl1[0], chnl2[0], chnl3[0]))\n","0d984ca1":"mhist_fn = lambda x: get_merged_histogram(x, get_rgb_histogram, nbins=180)\n\nkeep = 0.5\nimgs_hist = Stream.of(range(get_max_bound()))\\\n.filter(lambda x: random.random() < keep)\\\n.map(get_or_none)\\\n.filter(lambda x: x is not None)\\\n.map(mhist_fn)\\\n.filter(lambda x: not np.isnan(np.max(x)))\\\n.collect()","c1eeacae":"np.array(imgs_hist).shape","e51635f2":"from sklearn.cluster import KMeans\nnclusters = 5\nninit = 30\nkmeans = KMeans(n_clusters=nclusters, n_init=ninit, algorithm='elkan', n_jobs=-2).fit(imgs_hist)","a0e8d361":"tst_prob = 0.02\nimg_test = Stream.of(range(get_max_bound()))\\\n.filter(lambda x: random.random() < tst_prob)\\\n.map(get_or_none)\\\n.filter(lambda x: x is not None)\\\n.filter(lambda x: x.shape[2] == 4)\\\n.collect()","c2f95b4d":"predictions = Stream.of(img_test)\\\n.map(lambda x: (x, mhist_fn(x)))\\\n.filter(lambda x: not np.isnan(np.max(x[1])))\\\n.map(lambda x: (x[0], kmeans.predict([x[1]])[0]))\\\n.map_key(lambda x: (x[1], x[0]))\\\n.collect()","77d7b686":"p_sorted = dict(\n  zip(\n    [i[0] for i in predictions],\n    [i[1:] for i in predictions]\n))","72c35ff6":"def stack_images(iterable, ncols=8):\n    dim = iterable[0].shape\n    blank = np.zeros(dim, dtype=np.uint8)\n    a = Stream.of(iterable).enumerate().map(lambda x: (x[0] % ncols, x[1])).map_key(lambda x: (x[0], x[1])).collect()\n    a = [i[1:] for i in a]\n    height = max([len(i) for i in a])\n    for i, v in enumerate(a):\n        if (len(v) == height): continue\n        a[i].append(blank)\n    return np.hstack([np.vstack(i) for i in a])","9a6b37a4":"for i, group in enumerate(p_sorted.keys()):\n    print(f\"Group {i + 1} - Cluster Name: {group}\")\n    stacked = stack_images(Stream.of(p_sorted[group])\n                           .map(lambda x: MinecraftSkin(x).get_component('head_front'))\n                           .collect())\n    ratio = stacked.shape[0] \/ stacked.shape[1]\n    width = 5\n    plt.figure(figsize = (width, width * (ratio)))\n    plt.imshow(stacked)\n    plt.show()","9c97468d":"for i, group in enumerate(p_sorted.keys()):\n    print(f\"Group {i + 1} - Cluster Name: {group}\")\n    stacked = stack_images(Stream.of(p_sorted[group])\n                           .map(lambda x: MinecraftSkin(x).get_component('body'))\n                           .collect())\n    ratio = stacked.shape[0] \/ stacked.shape[1]\n    width = 5\n    plt.figure(figsize = (width, width * (ratio)))\n    plt.imshow(stacked)\n    plt.show()","0696f43f":"In the cluster result, we can observe that there is one cluster has the strongest similarities among their members. All skins in this group are primarily dark. The second best cluster is the one that has the most members of which the skins are all not too bright nor too dark. The third most cluster consists of a number of colourful, high-contrast skins while the rest of the cluster are inconclusive due to small number of samples.","358ca26f":"### Stream functions\n\nThis is a stream class inspired by Java Stream class. This provides better code readability.","12263cc2":"This is one of the example of the output of the `get_deterministic_random`. The parameter for this function is for the number of outputs of this function. ","66d1e07a":"Now, we prepare the validation set to check inspect the output quality using only 2% of the dataset.","d564c842":"## Conclusion\n\nThe training dataset for the clustering is rather sparse because some parts of the skins are not used for skin rendering. This is excluded from the histogram calculation by in the `clip_min` parameters. By normalising the histogram, the values that we removed can be equalised among others.\n\nEven after the features engineering, the clustering quality are not well-defined. `clip_min` also removes the transparent pixels of the actual skin. Perhaps, I should make use of the `MinecraftSkin` class and only crop out the actual skin to compute the histogram without removing the black pixel.\n\nIn the clustering group, there are two performing clusters while the rest are sub-optimal. Perhaps, the best number of clusters is three where the first group are for primarily dark skins, the second group are for normal skins, and the third are for bright skins. Upon completion of the clustering, we can label each cluster for skin suggestion using KNN algorithm.","986289e9":"Here, I perform checking to make sure not many of histogram are the faulty outputs. The sum is still about 50% of the whole dataset, so it is safe to assume that faulty outputs are minimally produced.","17d3d625":"After performing `map_key`, the key of the each grouping is placed at the first of the array. So, we can extract this out and derive a dictionary object.","628050e8":"Here, we can use the `MinecraftSkin` class to view only the front head texture of the skin.","c5e015ba":"# Clustering algorithm\n\nI am trying with 5 clusters for the K-Means algorithm and running 30 reps for different centroid seeds.","189a0d76":"# Simple image analysis\n\n### Check invalid images\n\nI found out that some of the images cannot be read by the `matplotilb` module. We can also see the utilisation of Stream in action. After analysis, there are less than 1% faulty skin files from the whole dataset, and I reckon we can safely discard these.","3d1bdfc2":"The first one is a function for getting RBG histogram of the image. This histogram will be fed into the clustering algorithm. I am planning to experiment with different histogram.","823e1547":"### Import modules and utility functions","65563e90":"# Feature engineering\n\n### Image utility function\n\nThese classes help to extract components of the Minecraft Skin. In the `MinecraftSkin` class, there is a function called `get_deterministic_random` of which the output is unique for each skin. This can be useful for random skin generation using seed.","311a3f38":"From the output, it is hard to tell on what aspect are they clustered together. Afterall, the clustering is taking account of the whole skin file rather than just the heads. So, lets take a look at the skin body of the texture that took larger space of the skin file.","60606da7":"To get random images, we use probability to filter out unneeded images and make use of the stream function. Here, 50% of the dataset will be used for the training of the clustering. Upon collecting the stream, there will be an error log appearing in the output. This is due to error in the histogram function, so we use `np.max` to check if the max can be computed. If the value cannot be computed, `np.isnan` can be used to filter out the faulty output.\n\nI assigned a lambda expression so that we can easily reuse the lambda function. In the lambda functoion, I have set the number of bins to 180 bins.","94408084":"Minecraft Skin Analysis\n===\n\nI am performing simple Minecraft Skin analysis for machine-learning motivated skin program. I am planning to perform skin clustering, skin suggestions, and finally, skin generation using random mix and match and using machine-learning.\n\nIn this part of notebook, I am using K-Means algorithm to perform clustering using RBG histogram image description. I will write out my analysis throughout the notebook.","365265db":"This is the utility function to stack images in rows and columns."}}