{"cell_type":{"face1d9b":"code","ba1ac517":"code","44f5303b":"code","8051e5d8":"code","942eb698":"code","3880820e":"code","58863963":"code","022367e6":"markdown","34e339c4":"markdown","ef44cd3d":"markdown","b3040239":"markdown","82083af8":"markdown","28b33472":"markdown","bb98437a":"markdown","09d86580":"markdown","33a29d96":"markdown","ac989e74":"markdown"},"source":{"face1d9b":"# import packages\nimport cv2\nimport json\nimport os\nimport csv\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom PIL import Image, ImageDraw\n\n# load polygon mask\njson_filename = '..\/input\/hubmap-kidney-segmentation\/train\/0486052bb.json'\nread_file = open(json_filename, \"r\") \ndata = json.load(read_file)\ndata[0]\n\npolys = []\nfor index in range(data.__len__()):\n    geom = np.array(data[index]['geometry']['coordinates'])\n    polys.append(geom)\n\nshape = (18484, 13013)\n\n# convert to pixel mask (method 1)\nmask_1 = np.zeros(shape)\nfor i in range(len(polys)):\n    cv2.fillPoly(mask_1, polys[i], i+1)\n\nplt.imshow(mask_1)\n\nmask_1\n\nrange(len(polys))","ba1ac517":"def rle_encoding(x):\n    '''\n    x: numpy array of shape (height, width), non 0 - mask, 0 - background\n    Returns run length as list\n    '''\n    run_lengths = []\n    for i in range(len(polys)):\n        run_lengths.append([])\n    current = 0\n    count = 0\n    start = 0\n    flat = x.T.flatten()\n    for i in range(len(flat)):\n        dot = flat[i]\n        if dot == 0:\n            if current == 0:\n                continue\n            else:\n                run_lengths[current-1].extend([start, count])\n                current = 0\n                count = 0\n                start = 0\n        else:\n            if dot == current:\n                count += 1\n            elif count != 0:\n                run_lengths[current-1].extend([start, count])\n                current = 0\n                count = 0\n                start = 0\n            else:\n                start = i\n                current = dot\n                count += 1\n    return run_lengths\n\nencoding = rle_encoding(mask_1.astype('uint16'))","44f5303b":"def rle_encoding_2(x):\n    '''\n    x: numpy array of shape (height, width), non 0 - mask, 0 - background\n    Returns run length as list\n    '''\n    run_lengths = []\n    for i in range(len(polys)):\n        run_lengths.append([])\n        dots = np.where(x.T.flatten()==i+1)[0] # .T sets Fortran order down-then-right\n        prev = -2\n        for b in dots:\n            if (b>prev+1): run_lengths[-1].extend((b, 0))\n            run_lengths[-1][-1] += 1\n            prev = b\n    return run_lengths\n\nencoding_2 = rle_encoding_2(mask_1.astype('uint16'))\n","8051e5d8":"# preview the first 10 pairs from method 1\nencoding[0][:20]","942eb698":"# preview the first 10 pairs from method 2\nencoding_2[0][:20]","3880820e":"generated_1d_mask = np.zeros((shape[1]*shape[0]))\n\nfor i in range(len(encoding_2)):\n    for j in range(len(encoding_2[i]) \/\/ 2):\n            generated_1d_mask[encoding[i][j * 2]:encoding[i][j * 2]+encoding[i][j * 2+1]] = i\n        \ngenerated_mask = generated_1d_mask.reshape((shape[1], shape[0])).T\nplt.imshow(generated_mask)","58863963":"file = open('test.csv', 'w', newline ='') \n  \nwith file: \n    # identifying header   \n    header = ['glom', 'pixels'] \n    writer = csv.DictWriter(file, fieldnames = header) \n      \n    # writing data row-wise into the csv file \n    writer.writeheader()\n    for i in range(len(encoding)):\n        writer.writerow({'glom' : i,  \n                         'pixels': ' '.join([str(item) for item in encoding[i]]), \n                        }) \n\nwith open('test.csv', newline='') as testfile:\n    content = testfile.read()\n    print(content[:300])","022367e6":"### Method 1","34e339c4":"# Examples of how to perform run-length encoding.\nBy Leah Scherschel and Yingnan Ju - Indiana University","ef44cd3d":"#### Method 1","b3040239":"## Validation of the encoding\n\n### Restore the image from the encoding","82083af8":"### Method 2","28b33472":"#### Method 2","bb98437a":"### Save the encoding to csv file","09d86580":"## Import packages, load polygon mask, and convert to pixel mask","33a29d96":"### Preview Encoding","ac989e74":"## Run-length encoding\nIn order to reduce the submission file size, teams must submit segmentation results using run-length encoding on the pixel values.  That is, instead of submitting an exhaustive list of indices for your segmentation, you will submit pairs of values that contain a start position and a run length. E.g. '0 3' implies starting at pixel 0 and running a total of 3 pixels (0,1,2).\nThe competition format requires a space delimited list of pairs. For example, '0 3 10 5' implies pixels 0,1,2, and 10,11,12,13,14 are to be included in the mask. The metric checks that the pairs are sorted, positive, and the decoded pixel values are not duplicated. The pixels are numbered from top to bottom, then left to right: 0 is pixel (0,0), 1 is pixel (1,0), and 2 is pixel (2,0) etc., see Figure 1.\n\n![image.png](attachment:image.png)\n*Figure 1: Run Length Encoding for One Object*\n\nFor example, the sample image shown in Figure 1 has 10 rows and 8 columns and the pixels are numbered from 0 to 79 based on the sequence from top to bottom and then left to right. The shaded area is the mask and the encoding of the mask starts from the 18th to the following three pixels (18 3), then from the 25th to the next five pixels (25 5), and etc. Finally the line of the mask encoding of \u201cglom 0\u201d is:\n\n0, 18 3 25 5 33 6 41 7 50 6\n\nThere should be 20 csv files submitted (for 11 fresh frozen and 9 FFPE PAS kidney images). Each file should have the same file name with the image file but ends with \u201c.csv\u201d. For example, if the image file is hackathon_sample.tiff, the result csv file should be hackathon_sample.csv. Each csv file should contain a header and have the following format. Each line is a glomerulus and the line starts with the unique id (starts from 0) of the glomeruli."}}