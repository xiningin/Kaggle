{"cell_type":{"124f6c3e":"code","58810871":"code","5cec42b0":"code","8c9abdee":"code","241b550a":"code","43d5010c":"code","1c9c1ccb":"code","ccaf3074":"code","ca4f3277":"code","8d980b22":"code","21ff16cf":"code","78719e22":"code","ff3cfc20":"code","04928ecb":"code","3199841e":"code","bbb3723e":"code","538e613a":"code","1fb6c909":"markdown","9dee2798":"markdown","61ad7253":"markdown","27c7edb9":"markdown","0c263a24":"markdown","2a87fc7e":"markdown","27b3a60d":"markdown","52c6aa7a":"markdown","5a1d8eed":"markdown","48b5b392":"markdown","0effb7de":"markdown","7676e5cd":"markdown","1c230332":"markdown","cf7d37bb":"markdown","9c71ff60":"markdown","074fc5de":"markdown","53d5b796":"markdown","2f337c95":"markdown","37fc495c":"markdown","f9d0e27f":"markdown","085cfef8":"markdown","429d1be7":"markdown","2c53ded5":"markdown","c3dcf113":"markdown","4dfb8bd4":"markdown","c29b4b86":"markdown","22d68635":"markdown","e243d85d":"markdown","ae8f91b7":"markdown","9b349b2f":"markdown","9e18322a":"markdown","0f27d987":"markdown","b8b21011":"markdown","38b6e56f":"markdown"},"source":{"124f6c3e":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nimport plotly.figure_factory as ff ## For distiribution plot\nimport plotly.offline as py\nimport plotly.express as px\nimport plotly.graph_objects as go\n\n\nimport matplotlib.pylab as plt\nimport seaborn as sns\n\npy.init_notebook_mode(connected=True)","58810871":"# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","5cec42b0":"sample_df  = pd.read_csv(\"\/kaggle\/input\/liverpool-ion-switching\/sample_submission.csv\")\ntest_df = pd.read_csv(\"\/kaggle\/input\/liverpool-ion-switching\/test.csv\")\ntrain_df = pd.read_csv(\"\/kaggle\/input\/liverpool-ion-switching\/train.csv\")","8c9abdee":"train_df.shape , test_df.shape","241b550a":"train_df.isnull().sum()","43d5010c":"train_df.dtypes","1c9c1ccb":"train_df.time.is_monotonic","ccaf3074":"print(\"No of batches in Train Data\",train_df.shape[0]\/500000)\nprint(\"No of batches in Test Data\",test_df.shape[0]\/500000)","ca4f3277":"train_df['batch'] = 0\ntest_df['batch'] = 0\nfor i in range(0, 10):\n    train_df.iloc[i * 500000: 500000 * (i + 1), 3] = i\nfor i in range(0, 4):\n    test_df.iloc[i * 500000: 500000 * (i + 1), 2] = i","8d980b22":"train_df.open_channels.unique()","21ff16cf":"from IPython.display import Image\nImage(\"\/kaggle\/input\/ion-channel\/ion image.jpg\")","78719e22":"temp_df = train_df.groupby([\"open_channels\"])[\"open_channels\"].agg([\"count\"]).reset_index()\n\nfig = px.bar(temp_df, x='open_channels', y='count',\n             hover_data=['count'], color='count',\n             labels={'pop':'Distribtuion of Open Channels'}, height=400)\nfig.show()","ff3cfc20":"temp_df = train_df.groupby([\"open_channels\",\"batch\"])[\"open_channels\"].agg([\"count\"]).reset_index()\ntemp_df.columns = [\"open_channels\",\"batch\",\"count\"]\n#temp_df.Country = temp_df[temp_df.Country != 'United Kingdom']\n\nfig = px.scatter(temp_df, x=\"open_channels\", y=\"batch\", color=\"open_channels\", size=\"count\")\nlayout = go.Layout(\n    title=go.layout.Title(\n        text=\"Ground Truth across each batches\",\n        x=0.5\n    ),\n    font=dict(size=14),\n    width=800,\n    height=600,\n    showlegend=False\n)\nfig.update_layout(layout)\nfig.show()","04928ecb":"fig, axs = plt.subplots(5, 2, figsize=(15, 20))\naxs = axs.flatten()\ni = 0\nfor b, d in train_df.groupby('batch'):\n    sns.violinplot(x='open_channels', y='signal', data=d, ax=axs[i])\n    axs[i].set_title(f'Batch {b:0.0f}')\n    i += 1\nplt.tight_layout()","3199841e":"fig = px.line(train_df[:200000] , x='time', y='signal')\nfig.show()","bbb3723e":"from plotly.subplots import make_subplots\nimport plotly.graph_objects as go\n\n\nfig = make_subplots(rows=5, cols=2,  subplot_titles=tuple([\"Batch No\"+str(i) for i in range(0,10)]))\n\nbatch_no = 0 \nfor i in range(0,5):\n    for j in range(0,2):\n        temp = train_df.loc[train_df[\"batch\"]==batch_no]\n        temp = temp[:10000]\n        batch_no+=1\n        fig.add_trace(\n            go.Scatter(\n            x=temp['time'],\n            y=temp['signal'],\n               ),\n            row=i+1, col=j+1      \n         )\n        fig.update_xaxes(title_text=\"Time\", row=i+1, col=j+1)\n        fig.update_yaxes(title_text=\"Signal\", row=i+1, col=j+1)\n\nfig.update_layout(height=1000, width=1200, title_text=\"Signal spread across the batches\")\n\nfig.show()","538e613a":"from plotly.subplots import make_subplots\nimport plotly.graph_objects as go\n\n\nfig = make_subplots(rows=2, cols=2,  subplot_titles=tuple([\"Batch No\"+str(i) for i in range(0,4)]))\n\nbatch_no = 0 \nfor i in range(0,2):\n    for j in range(0,2):\n        temp = test_df.loc[train_df[\"batch\"]==batch_no]\n        temp = temp[:10000]\n        batch_no+=1\n        fig.add_trace(\n            go.Scatter(\n            x=temp['time'],\n            y=temp['signal'],\n               ),\n            row=i+1, col=j+1      \n         )\n        fig.update_xaxes(title_text=\"Time\", row=i+1, col=j+1)\n        fig.update_yaxes(title_text=\"Signal\", row=i+1, col=j+1)\n\nfig.update_layout(height=1000, width=1200, title_text=\"Signal spread across the batches\")\n","1fb6c909":"**Observation**\n\nFrom this plots, we can clearly see that the distribtuion of channels across the batches ","9dee2798":"**I think,since the data we deal with here are electrophysiological signals from human cells there is no missing data  points.** However it is mentioned that can be chance of biasness since data were monitered by humans. Let's see if there is any...","61ad7253":"As I have mentioned earlier that, the data given is of discrete batch types ranging 0.0001 - 50.0000 of each we can create a new column in both train and test which might support our predicition","27c7edb9":"The above graphs gives a better visualization compared to the pervious one.","0c263a24":"## **Content**\n\n* [**About the Competition**](#1)\n    * Objective of the Competition\n    * About the kernel\n    * Key TakeAways\n* [**Importing the necessary Packages**](#2)\n* [**Initial Data preparation**](#3)\n* [**Exploratory Data Analysis**](#4)\n    * Distribtuion of Open Channels\n    * Ground truth of each batches\n    * Data distribution across each batches\n    * Exploring the test data\n* [**What are predicting?**](#5)    \n","2a87fc7e":"## **What are we Prediciting?** <a id =\"5\"><\/a>","27b3a60d":"**Objective of the Competition**\n\n![](https:\/\/www.nature.com\/scitable\/content\/ne0000\/ne0000\/ne0000\/ne0000\/14707004\/U4CP3-1_IonChannel_ksm.jpg)\n\n\nIn this competition, contestants are challenged to predict the number of open ion channels using electrophysiological signals from human cells. ","52c6aa7a":"**Kernel is under construction please stay tuned for more updates**","5a1d8eed":"## Exploratory Data Analysis <a id =\"4\"><\/a>","48b5b392":"**Please upvote the kernel if you find it useful**","0effb7de":"As I mentioned earlier, we are trying to predict the number of open ion channels using electrophysiological signals from human cells. \n\nThe evaluation metric used in this competition is macro F1 measure.\n\nA macro-average will compute the metric independently for each class and then take the average (hence treating all classes equally)","7676e5cd":"## Importing the necessary Packages <a id=\"2\"><\/a>","1c230332":"**About this kernel**\n\nThis kernel will acts as a guide covering the A-Z topics on this data\n\nIf you don't know about the background, then I would highly recommend you to visit this [kernel](https:\/\/www.kaggle.com\/tarunpaparaju\/ion-switching-competition-signal-eda)","cf7d37bb":"**The plots made are interactive one's feel free to hover over**","9c71ff60":"The open Channels are ranged from 1 - 10 in the datasets each step indicating the state changes","074fc5de":"Since, we have done the inital data preparation let's statring exploring the data ","53d5b796":"**Ion Channels through batches**","2f337c95":"**Time Vs Signal**","37fc495c":"**Key Takeaway's**\n\n* Extensive EDA\n* Understanding the nature of NFL\n* Effective Story Telling\n* Creative Feature Engineering\n* Modelling\n* Ensembling","f9d0e27f":"**Distribution of the data**","085cfef8":"**Creating the new column Batches**","429d1be7":"**Exploring the Test Data**","2c53ded5":"**Micro level view of Signals Batchwise**","c3dcf113":"The given data is time series, just wanted to make sure the time sorted order before creating the new column","4dfb8bd4":"**Note:**\n\nWhile the time series appears continuous, the data is from discrete batches of 50 seconds long 10 kHz samples (500,000 rows per batch). In other words, the data from 0.0001 - 50.0000 is a different batch than 50.0001 - 100.0000, and thus discontinuous between 50.0000 and 50.0001.","c29b4b86":"**References:**\n\n* https:\/\/www.kaggle.com\/robikscube\/liverpool-ion-switching-data-exploration\n* https:\/\/www.kaggle.com\/artgor\/eda-and-model-qwk-optimization\n* https:\/\/www.kaggle.com\/tarunpaparaju\/ion-switching-competition-signal-eda\n\nI would like share my thanks to these people for sharing their wonderful work","22d68635":"**Observations:**\n\nThe signals in the test data resembles the train data","e243d85d":"**Ground truth across each batches**","ae8f91b7":"**Observation**\n\nFrom this graph we are not able understand clearly, so let's go for micro level views for better understanding.","9b349b2f":"**Distribution of the open Channels**","9e18322a":"## Importing Data Preparation <a id=\"3\"><\/a>","0f27d987":"## About the Competition <a id=\"1\"><\/a>\n\nMany diseases, including cancer, are believed to have a contributing factor in common. Ion channels are pore-forming proteins present in animals and plants. They encode learning and memory, help fight infections, enable pain signals, and stimulate muscle contraction. If scientists could better study ion channels, which may be possible with the aid of machine learning, it could have a far-reaching impact.\n\n\n\nWhen ion channels open, they pass electric currents. Existing methods of detecting these state changes are slow and laborious. Humans must supervise the analysis, which imparts considerable bias, in addition to being tedious. These difficulties limit the volume of ion channel current analysis that can be used in research. Scientists hope that technology could enable rapid automatic detection of ion channel current events in raw data.\n","b8b21011":"**Obeservation:**\n\nSupporting the above observation\n\n* As you can, see clearly the distribution of open_channels decreases as the batch number increases\n\n* Open channels are largely populated in range 1 - 5 range","38b6e56f":"**Observation**\n\nDistribtuion of Open Channels decreases with increase in the strength of signal"}}