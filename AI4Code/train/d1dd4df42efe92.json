{"cell_type":{"749d8535":"code","04e40dcf":"code","2b5a18c6":"code","0c15bcf1":"code","d57287c6":"code","68a72681":"code","2e75a75d":"code","26b4f004":"code","088abaad":"code","4559c08b":"code","1f966899":"code","789a1c09":"code","eed3f3c6":"code","7b5cc698":"code","54e50523":"code","fa66c5c2":"code","b8963cd2":"code","000609b4":"code","11de6bac":"code","0fbee0b4":"code","0b50f722":"code","1cdf4597":"code","920107af":"code","7cb709c1":"code","c431c76b":"code","0e5e2913":"code","b8b747fe":"code","a12c8ffa":"code","8bc07397":"code","13a9059f":"code","ffd78cd3":"code","644ed847":"code","ac5c89ce":"code","8f87d36c":"code","0f9189f5":"code","4706b50d":"code","14965b1a":"code","2c42b168":"code","c07c84ce":"code","b8d6d67f":"code","63efa196":"code","39b01ab1":"code","372daff9":"code","b600acc3":"code","be3a77c0":"code","dd9ac026":"markdown","a5386587":"markdown","af7f6511":"markdown","f7a6df68":"markdown","4bf713c7":"markdown","e3487253":"markdown","c0e35b01":"markdown","2334c7ef":"markdown","608b8a26":"markdown","a3e0836d":"markdown","d95df6cf":"markdown","54438821":"markdown"},"source":{"749d8535":"import numpy as np\nimport pandas as pd\nimport gc\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport seaborn as sns\n\nfrom sklearn.model_selection import train_test_split\n\nimport tensorflow as tf\n\nfrom sklearn.metrics import confusion_matrix, classification_report\nimport tensorflow.keras\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Activation, Dropout, Flatten,\\\n Conv2D, MaxPooling2D,BatchNormalization\nimport cv2","04e40dcf":"data= pd.read_csv(\"..\/input\/skin-cancer-mnist-ham10000\/hmnist_28_28_RGB.csv\")","2b5a18c6":"data","0c15bcf1":"y= data['label'].copy()\nX = data.drop('label', axis=1).copy()","d57287c6":"y.shape","68a72681":"y.value_counts()","2e75a75d":"label_mapping = {\n    0: 'nv',\n    1: 'mel',\n    2: 'bkl',\n    3: 'bcc',\n    4: 'akiec',\n    5: 'vasc',\n    6: 'df'\n}","26b4f004":"X= X\/255\nX","088abaad":"X=np.array(X)\nX.shape","4559c08b":"X=X.reshape(-1,28,28,3)\nprint(X.shape)","1f966899":"# del [[data]]\n# gc.collect\n# data= pd.DataFrame()","789a1c09":"# for i in range (9):\nplt.subplot(3,3,1)\nplt.imshow(X[8322])\nimg_label = label_mapping[y[8322]]\nplt.title(img_label)\nplt.axis(\"off\")","eed3f3c6":"## Index Inputs to be augumentd\n## 3 5 0 1\nfor i in range (10015):\n    if(y[i]== 3 or y[i]==1 or y[i]== 5 or y[i]== 0):\n        \n        ## horizontal flip\n        hFlip= np.fliplr(X[i])\n        X= np.append(X, np.array([hFlip]), axis= 0)\n        y= np.append(y,[y[i]])\n        \n        ## horizontal flip-> vertical flip\n        \n        hVFlip= np.flipud(X[-1])\n        X= np.append(X, np.array([hVFlip]), axis=0)\n        y= np.append(y, [y[i]])\n        \n        ## vertical flip\n        vFlip= np.flipud(X[i])\n        X= np.append(X, np.array([vFlip]), axis=0)\n        y= np.append(y,[y[i]])\n        \nprint(\"done\")","7b5cc698":"# X1= []","54e50523":"# sz=(np.size(X,0))\n# print(sz)","fa66c5c2":"# len(X)","b8963cd2":"# shuffled_indices = np.random.permutation(len(X))\n# X= X[shuffled_indices]\n# y= y[shuffled_indices]","000609b4":"# for i in range (0,3000):\n#     res= cv2.resize(X[i], (227,227))\n#     X1.append(res)\n# print(\"done\")","11de6bac":"# y1=[]\n# for i in range (3000):\n#     y1.append([y[i]])\n# print(\"done\")","0fbee0b4":"# y1= np.array(y1)","0b50f722":"# y1.shape","1cdf4597":"# len(X1)","920107af":"# X1= np.array(X1)","7cb709c1":"# X1.shape","c431c76b":"X.shape","0e5e2913":"# X= X1\n# y= y1","b8b747fe":"unique,counts= np.unique(y, return_counts= True)\nprint (np.asarray((unique,counts)).T)","a12c8ffa":"# plt.figure(figsize=(12,12))\n\n# for i in range (9):\n#     plt.subplot(3,3,i+1)\n#     plt.imshow(sample_X[i])\n#     img_label = label_mapping[sample_y[i]]\n#     plt.title(img_label)\n#     plt.axis(\"off\")","8bc07397":"X_train,X_test,y_train,y_test= train_test_split(X,y,train_size=0.8)\nprint(\"done\")","13a9059f":"model = Sequential([\n    Conv2D(8, kernel_size=(3, 3), activation='relu',padding='same',input_shape=(28,28,3)),\n    MaxPooling2D(pool_size=(2, 2),strides=2),\n    Conv2D(16, kernel_size=(5, 5), activation='relu'),\n    MaxPooling2D(pool_size=(2, 2),strides=2),\n    Conv2D(32, kernel_size=(5, 5), activation='relu'),\n    MaxPooling2D(pool_size=(2,2), strides=2),\n    Flatten(),\n    Dense(64, activation='relu'),\n    Dense(32, activation='relu'),\n    Dense(7, activation='softmax')\n])","ffd78cd3":"model.summary()","644ed847":"## uncomment for alex net\n\n# model = Sequential()\n\n# # 1st Convolutional Layer\n# model.add(Conv2D(filters=96, input_shape=(227,227,3), kernel_size=(11,11),\\\n#  strides=(4,4), padding='valid'))\n# model.add(Activation('relu'))\n# # Pooling \n# model.add(MaxPooling2D(pool_size=(2,2), strides=(2,2), padding='valid'))\n# # Batch Normalisation before passing it to the next layer\n# model.add(BatchNormalization())\n\n# # 2nd Convolutional Layer\n# model.add(Conv2D(filters=256, kernel_size=(11,11), strides=(1,1), padding='valid'))\n# model.add(Activation('relu'))\n# # Pooling\n# model.add(MaxPooling2D(pool_size=(2,2), strides=(2,2), padding='valid'))\n# # Batch Normalisation\n# model.add(BatchNormalization())\n\n# # 3rd Convolutional Layer\n# model.add(Conv2D(filters=384, kernel_size=(3,3), strides=(1,1), padding='valid'))\n# model.add(Activation('relu'))\n# # Batch Normalisation\n# model.add(BatchNormalization())\n\n# # 4th Convolutional Layer\n# model.add(Conv2D(filters=384, kernel_size=(3,3), strides=(1,1), padding='valid'))\n# model.add(Activation('relu'))\n# # Batch Normalisation\n# model.add(BatchNormalization())\n\n# # 5th Convolutional Layer\n# model.add(Conv2D(filters=256, kernel_size=(3,3), strides=(1,1), padding='valid'))\n# model.add(Activation('relu'))\n# # Pooling\n# model.add(MaxPooling2D(pool_size=(2,2), strides=(2,2), padding='valid'))\n# # Batch Normalisation\n# model.add(BatchNormalization())\n\n# # Passing it to a dense layer\n# model.add(Flatten())\n# # 1st Dense Layer\n# model.add(Dense(4096, input_shape=(224*224*3,)))\n# model.add(Activation('relu'))\n# # Add Dropout to prevent overfitting\n# model.add(Dropout(0.4))\n# # Batch Normalisation\n# model.add(BatchNormalization())\n\n# # 2nd Dense Layer\n# model.add(Dense(4096))\n# model.add(Activation('relu'))\n# # Add Dropout\n# model.add(Dropout(0.4))\n# # Batch Normalisation\n# model.add(BatchNormalization())\n\n# # 3rd Dense Layer\n# model.add(Dense(1000))\n# model.add(Activation('relu'))\n# # Add Dropout\n# model.add(Dropout(0.4))\n# # Batch Normalisation\n# model.add(BatchNormalization())\n\n# # Output Layer\n# model.add(Dense(7))\n# model.add(Activation('softmax'))\n\n# print(model.summary())\n\n# tf.keras.utils.plot_model(model)","ac5c89ce":"model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])\n\nbatch_size= 32\nepochs= 20\n\nhistory= model.fit(X_train,y_train, validation_split=0.2,\n                    batch_size= batch_size,\n                    epochs=epochs,\n                    callbacks=[\n                      tf.keras.callbacks.EarlyStopping(\n                      monitor='val_loss',\n                      patience=3,\n                      restore_best_weights=True\n                      )\n                  ]\n                  )","8f87d36c":"model_acc = model.evaluate(X_test, y_test, verbose=0)[1]\n\nprint(\"Test Accuracy: {:.3f}%\".format(model_acc * 100))","0f9189f5":"y_true = np.array(y_test)\n\ny_pred = model.predict(X_test)\ny_pred = np.array(list(map(lambda x: np.argmax(x), y_pred)))","4706b50d":"cm = confusion_matrix(y_true, y_pred)\nclr = classification_report(y_true, y_pred, target_names=label_mapping.values())","14965b1a":"plt.figure(figsize=(10, 10))\nsns.heatmap(cm, annot=True, fmt='g', vmin=0, cbar=False, cmap='Blues')\n\nplt.xticks(np.arange(7) + 0.5, label_mapping.values())\nplt.xlabel(\"Predicted\")\n\nplt.yticks(np.arange(7) + 0.5, label_mapping.values())\nplt.ylabel(\"Actual\")\n\nplt.title(\"Confusion Matrix\")\n\nplt.show()","2c42b168":"print(clr)","c07c84ce":"# inputs= tf.keras.Input(shape=(28,28,3), name='input')\n\n# conv1= tf.keras.layers.Conv2D(filters= 16, kernel_size= 3, name= 'conv1')(inputs)\n\n# maxpool1= tf.keras.layers.MaxPooling2D(name= 'maxpool1')(conv1)\n\n# conv2= tf.keras.layers.Conv2D(filters=32, kernel_size=3, name='conv2')(maxpool1)\n\n# maxpool2= tf.keras.layers.MaxPooling2D(name= 'maxpool2')(conv2)\n\n# conv3= tf.keras.layers.Conv2D(filters= 64, kernel_size=3, name='conv3')(maxpool2)\n\n# maxpool3= tf.keras.layers.MaxPooling2D(name='maxpool3')(conv3)\n\n# avgpool= tf.keras.layers.GlobalAveragePooling2D(name='avgpool')(maxpool3)\n\n# outputs= tf.keras.layers.Dense(7, activation='softmax', name='output')(avgpool)\n\n# model= tf.keras.Model(inputs= inputs, outputs= outputs)\n\n# print(model.summary())\n\n# tf.keras.utils.plot_model(model)","b8d6d67f":"# model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])\n\n# batch_size= 32\n# epochs= 20\n\n# history= model.fit(X_train,y_train, validation_split=0.2,\n#                     batch_size= batch_size,\n#                     epochs=epochs,\n#                     callbacks=[\n#                       tf.keras.callbacks.EarlyStopping(\n#                       monitor='val_loss',\n#                       patience=3,\n#                       restore_best_weights=True\n#                       )\n#                   ]\n#                   )","63efa196":"# model_acc = model.evaluate(X_test, y_test, verbose=0)[1]\n\n# print(\"Test Accuracy: {:.3f}%\".format(model_acc * 100))","39b01ab1":"# y_true = np.array(y_test)\n\n# y_pred = model.predict(X_test)\n# y_pred = np.array(list(map(lambda x: np.argmax(x), y_pred)))","372daff9":"# cm = confusion_matrix(y_true, y_pred)\n# clr = classification_report(y_true, y_pred, target_names=label_mapping.values())","b600acc3":"# plt.figure(figsize=(10, 10))\n# sns.heatmap(cm, annot=True, fmt='g', vmin=0, cbar=False, cmap='Blues')\n\n# plt.xticks(np.arange(7) + 0.5, label_mapping.values())\n# plt.xlabel(\"Predicted\")\n\n# plt.yticks(np.arange(7) + 0.5, label_mapping.values())\n# plt.ylabel(\"Actual\")\n\n# plt.title(\"Confusion Matrix\")\n\n# plt.show()","be3a77c0":"# print(clr)","dd9ac026":"# Data Augumentation\n","a5386587":"# Training","af7f6511":"# Don't uncomment if not needed","f7a6df68":"# Visualisation","4bf713c7":"# Alex Net\n![schematic representation of alexNet](https:\/\/analyticsindiamag.com\/wp-content\/uploads\/2020\/06\/Architecture.png)","e3487253":"# Train- Test Split","c0e35b01":"# Image test","2334c7ef":"There are 7 possible labels.\n\nFrom the dataset provider:\n\n0: nv - Melanocytic nevi\n\n1: mel - Melanoma\n\n2: bkl - Benign keratosis-like lesions\n\n3: bcc - Basal cell carcinoma\n\n4: akiec - Actinic keratoses and intraepithelial carcinoma \/ Bowen's disease\n\n5: vasc - Vascular lesions\n\n6: df - Dermatofibroma","608b8a26":"# Resizing the image for AlexNet input\n","a3e0836d":"#  For another model","d95df6cf":"# Modelling","54438821":"# New Model From Scratch"}}