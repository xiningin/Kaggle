{"cell_type":{"528119b2":"code","6b1bdc43":"code","031b37b1":"code","d6ff31fc":"code","96f3ca62":"code","58962c5b":"code","750b2184":"code","42d03180":"code","4b548f63":"code","ecf348e1":"code","e59054d5":"code","21da69d6":"code","9ab31eb3":"code","0709eb2f":"code","aebee500":"code","79de51ae":"code","a6824ce5":"code","2c334e3f":"code","7a524d4e":"code","924f1212":"code","3e024ca9":"code","1c7570e2":"code","7236b11b":"code","aca53462":"code","0481db79":"code","37c104ff":"code","14ca909c":"code","80a4a262":"code","306e69a8":"code","cee5c503":"code","18fe0d94":"code","f3383037":"code","da5a3a54":"code","e8299fbc":"code","027b087a":"code","b90c992e":"code","eb3535e2":"markdown","bc4591a3":"markdown","e32cf307":"markdown","f8e9831d":"markdown","a8579bb7":"markdown","78e332eb":"markdown","555d8b82":"markdown","c7154f63":"markdown","2f4e5b13":"markdown","4444124b":"markdown","851ae246":"markdown","3974a426":"markdown","cf110f97":"markdown","21942b7c":"markdown","8645a709":"markdown","03760fa9":"markdown","e7129f38":"markdown","07a3424e":"markdown","eebf853c":"markdown","13bf72db":"markdown","2afec401":"markdown","75cbe693":"markdown","eed4e3bf":"markdown","338fa4be":"markdown","421f8d41":"markdown"},"source":{"528119b2":"import torch\nimport torchvision\nfrom torchvision.transforms import ToTensor, Normalize, Compose\nfrom torchvision.datasets import MNIST\n\nmnist = MNIST(root='data', \n              train=True, \n              download=True,\n              transform=Compose([ToTensor(), Normalize(mean=(0.5,), std=(0.5,))]))","6b1bdc43":"img, label = mnist[0]\nprint('Label: ', label)\nprint(img[:,10:15,10:15])\ntorch.min(img), torch.max(img)","031b37b1":"def denorm(x):\n    out = (x + 1) \/ 2\n    return out.clamp(0, 1)","d6ff31fc":"import matplotlib.pyplot as plt\n%matplotlib inline\n\nimg_norm = denorm(img)\nplt.imshow(img_norm[0], cmap='gray')\nprint('Label:', label)","96f3ca62":"from torch.utils.data import DataLoader\n\nbatch_size = 100\ndata_loader = DataLoader(mnist, batch_size, shuffle=True)","58962c5b":"for img_batch, label_batch in data_loader:\n    print('first batch')\n    print(img_batch.shape)\n    plt.imshow(img_batch[0][0], cmap='gray')\n    print(label_batch)\n    break","750b2184":"# Device configuration\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')","42d03180":"device","4b548f63":"image_size = 784\nhidden_size = 256","ecf348e1":"import torch.nn as nn\n\nD = nn.Sequential(\n    nn.Linear(image_size, hidden_size),\n    nn.LeakyReLU(0.2),\n    nn.Linear(hidden_size, hidden_size),\n    nn.LeakyReLU(0.2),\n    nn.Linear(hidden_size, 1),\n    nn.Sigmoid())","e59054d5":"D.to(device);","21da69d6":"latent_size = 64","9ab31eb3":"G = nn.Sequential(\n    nn.Linear(latent_size, hidden_size),\n    nn.ReLU(),\n    nn.Linear(hidden_size, hidden_size),\n    nn.ReLU(),\n    nn.Linear(hidden_size, image_size),\n    nn.Tanh())","0709eb2f":"y = G(torch.randn(2, latent_size))\ngen_imgs = denorm(y.reshape((-1, 28,28)).detach())","aebee500":"plt.imshow(gen_imgs[0], cmap='gray');","79de51ae":"plt.imshow(gen_imgs[1], cmap='gray');","a6824ce5":"G.to(device);","2c334e3f":"criterion = nn.BCELoss()\nd_optimizer = torch.optim.Adam(D.parameters(), lr=0.0002)","7a524d4e":"def reset_grad():\n    d_optimizer.zero_grad()\n    g_optimizer.zero_grad()\n\ndef train_discriminator(images):\n    # Create the labels which are later used as input for the BCE loss\n    real_labels = torch.ones(batch_size, 1).to(device)\n    fake_labels = torch.zeros(batch_size, 1).to(device)\n        \n    # Loss for real images\n    outputs = D(images)\n    d_loss_real = criterion(outputs, real_labels)\n    real_score = outputs\n\n    # Loss for fake images\n    z = torch.randn(batch_size, latent_size).to(device)\n    fake_images = G(z)\n    outputs = D(fake_images)\n    d_loss_fake = criterion(outputs, fake_labels)\n    fake_score = outputs\n\n    # Combine losses\n    d_loss = d_loss_real + d_loss_fake\n    # Reset gradients\n    reset_grad()\n    # Compute gradients\n    d_loss.backward()\n    # Adjust the parameters using backprop\n    d_optimizer.step()\n    \n    return d_loss, real_score, fake_score","924f1212":"g_optimizer = torch.optim.Adam(G.parameters(), lr=0.0002)","3e024ca9":"def train_generator():\n    # Generate fake images and calculate loss\n    z = torch.randn(batch_size, latent_size).to(device)\n    fake_images = G(z)\n    labels = torch.ones(batch_size, 1).to(device)\n    g_loss = criterion(D(fake_images), labels)\n\n    # Backprop and optimize\n    reset_grad()\n    g_loss.backward()\n    g_optimizer.step()\n    return g_loss, fake_images","1c7570e2":"import os\n\nsample_dir = 'samples'\nif not os.path.exists(sample_dir):\n    os.makedirs(sample_dir)","7236b11b":"from IPython.display import Image\nfrom torchvision.utils import save_image\n\n# Save some real images\nfor images, _ in data_loader:\n    images = images.reshape(images.size(0), 1, 28, 28)\n    save_image(denorm(images), os.path.join(sample_dir, 'real_images.png'), nrow=10)\n    break\n   \nImage(os.path.join(sample_dir, 'real_images.png'))","aca53462":"sample_vectors = torch.randn(batch_size, latent_size).to(device)\n\ndef save_fake_images(index):\n    fake_images = G(sample_vectors)\n    fake_images = fake_images.reshape(fake_images.size(0), 1, 28, 28)\n    fake_fname = 'fake_images-{0:0=4d}.png'.format(index)\n    print('Saving', fake_fname)\n    save_image(denorm(fake_images), os.path.join(sample_dir, fake_fname), nrow=10)\n    \n# Before training\nsave_fake_images(0)\nImage(os.path.join(sample_dir, 'fake_images-0000.png'))","0481db79":"%%time\n\nnum_epochs = 300\ntotal_step = len(data_loader)\nd_losses, g_losses, real_scores, fake_scores = [], [], [], []\n\nfor epoch in range(num_epochs):\n    for i, (images, _) in enumerate(data_loader):\n        # Load a batch & transform to vectors\n        images = images.reshape(batch_size, -1).to(device)\n        \n        # Train the discriminator and generator\n        d_loss, real_score, fake_score = train_discriminator(images)\n        g_loss, fake_images = train_generator()\n        \n        # Inspect the losses\n        if (i+1) % 200 == 0:\n            d_losses.append(d_loss.item())\n            g_losses.append(g_loss.item())\n            real_scores.append(real_score.mean().item())\n            fake_scores.append(fake_score.mean().item())\n            print('Epoch [{}\/{}], Step [{}\/{}], d_loss: {:.4f}, g_loss: {:.4f}, D(x): {:.2f}, D(G(z)): {:.2f}' \n                  .format(epoch, num_epochs, i+1, total_step, d_loss.item(), g_loss.item(), \n                          real_score.mean().item(), fake_score.mean().item()))\n        \n    # Sample and save images\n    save_fake_images(epoch+1)","37c104ff":"# Save the model checkpoints \ntorch.save(G.state_dict(), 'G.ckpt')\ntorch.save(D.state_dict(), 'D.ckpt')","14ca909c":"Image('.\/samples\/fake_images-0010.png')","80a4a262":"Image('.\/samples\/fake_images-0050.png')","306e69a8":"Image('.\/samples\/fake_images-0100.png')","cee5c503":"Image('.\/samples\/fake_images-0300.png')","18fe0d94":"import cv2\nimport os\nfrom IPython.display import FileLink\n\nvid_fname = 'gans_training.avi'\n\nfiles = [os.path.join(sample_dir, f) for f in os.listdir(sample_dir) if 'fake_images' in f]\nfiles.sort()\n\nout = cv2.VideoWriter(vid_fname,cv2.VideoWriter_fourcc(*'MP4V'), 8, (302,302))\n[out.write(cv2.imread(fname)) for fname in files]\nout.release()\nFileLink('gans_training.avi')","f3383037":"plt.plot(d_losses, '-')\nplt.plot(g_losses, '-')\nplt.xlabel('epoch')\nplt.ylabel('loss')\nplt.legend(['Discriminator', 'Generator'])\nplt.title('Losses');","da5a3a54":"plt.plot(real_scores, '-')\nplt.plot(fake_scores, '-')\nplt.xlabel('epoch')\nplt.ylabel('score')\nplt.legend(['Real Score', 'Fake score'])\nplt.title('Scores');","e8299fbc":"# Install the library\n!pip install jovian --upgrade -q","027b087a":"# Import the library\nimport jovian","b90c992e":"jovian.commit(outputs=['samples\/fake_images-0000.png', \n                       'samples\/fake_images-0010.png', \n                       'samples\/fake_images-0025.png', \n                       'samples\/fake_images-0050.png', \n                       'samples\/fake_images-0100.png', \n                       'samples\/fake_images-0150.png', \n                       'samples\/fake_images-0200.png', \n                       'samples\/fake_images-0250.png', \n                       'samples\/fake_images-0300.png', \n                       'gans_training.avi'], \n              project='06-mnist-gan')","eb3535e2":"Now that we have trained the models, we can save checkpoints.","bc4591a3":"## Discriminator Training\n\nSince the discriminator is a binary classification model, we can use the binary cross entropy loss function to quantify how well it is able to differentiate between real and generated images.\n\n<img src=\"https:\/\/image.slidesharecdn.com\/chrishokamp-dublinnlp3-160805110319\/95\/task-based-learning-for-nlp-going-beyond-cross-entropy-chris-hokamp-10-638.jpg?cb=1470395213\" width=\"420\" >","e32cf307":"# Generative Adverserial Networks in PyTorch\n\nDeep neural networks are used mainly for supervised learning: classification or regression. Generative Adverserial Networks or GANs, however, use neural networks for a very different purpose: Generative modeling\n\n> Generative modeling is an unsupervised learning task in machine learning that involves automatically discovering and learning the regularities or patterns in input data in such a way that the model can be used to generate or output new examples that plausibly could have been drawn from the original dataset. - [Source](https:\/\/machinelearningmastery.com\/what-are-generative-adversarial-networks-gans\/)\n\nWhile there are many approaches used for generative modeling, a Generative Adverserial Network takes the following approach: \n\n![GAN Flowchart](https:\/\/i.imgur.com\/6NMdO9u.png)\n\nThere are two neural networks: a *Generator* and a *Discriminator*. The generator generates a \"fake\" sample given a random vector\/matrix, and the discriminator attempts to detect whether a given sample is \"real\" (picked from the training data) or \"fake\" (generated by the generator). Training happens in tandem: we train the discriminator for a few epochs, then train the generator for a few epochs, and repeat. This way both the generator and the discriminator get better at doing their jobs. This rather simple approach can lead to some astounding results. The following images ([source](https:\/\/machinelearningmastery.com\/resources-for-getting-started-with-generative-adversarial-networks\/)), for instances, were all generated using GANs:\n\n<img src=\"https:\/\/3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com\/wp-content\/uploads\/2019\/04\/Example-of-Photorealistic-Human-Faces-Generated-by-a-GAN.png\" alt=\"gans_results\" width=\"480\">\n\n\nGANs however, can be notoriously difficult to train, and are extremely sensitive to hyperparameters, activation functions and regularization. In this tutorial, we'll train a GAN to generate images of handwritten digits similar to those from the MNIST database.\n\n<img src=\"https:\/\/i.imgur.com\/CAYnuo1.jpg\" width=\"360\" >\n\nMost of the code for this tutorial has been borrowed for this excellent repository of PyTorch tutorials: [github.com\/yunjey\/pytorch-tutorial](https:\/\/github.com\/yunjey\/pytorch-tutorial). Here's what we're going to do:\n\n* Define the problem statement\n* Load the data (with transforms and normalization)\n    * Denormalize for visual inspection of samples\n* Define the Discriminator network\n    * Study the activation function: Leaky ReLU\n* Define the Generator network\n    * Explain the output activation function: TanH\n    * Look at some sample outputs\n* Define losses, optimizers and helper functions for training\n    * For discriminator\n    * For generator\n* Train the model\n    * Save intermediate generated images to file\n* Look at some outputs\n* Save the models\n* Commit to Jovian.ml","f8e9831d":"We are now ready to train the model. In each epoch, we train the discriminator first, and then the generator. The training might take a while if you're not using a GPU.","a8579bb7":"We use the Leaky ReLU activation for the discriminator.\n\n<img src=\"https:\/\/cdn-images-1.medium.com\/max\/1600\/1*ypsvQH7kvtI2BhzR2eT_Sw.png\" width=\"420\">\n\n\n>  Different from the regular ReLU function, Leaky ReLU allows the pass of a small gradient signal for negative values. As a result, it makes the gradients from the discriminator flows stronger into the generator. Instead of passing a gradient (slope) of 0 in the back-prop pass, it passes a small negative gradient.  - [Source](https:\/\/sthalles.github.io\/advanced_gans\/)\n\nJust like any other binary classification model, the output of the discriminator is a single number between 0 and 1, which can be interpreted as the probability of the input image being fake i.e. generated.\n\nLet's move the discriminator model to the chosen device.","78e332eb":"We use the TanH activation function for the output layer of the generator.\n\n<img src=\"https:\/\/nic.schraudolph.org\/teach\/NNcourse\/figs\/tanh.gif\" width=\"420\" >\n\n> \"The ReLU activation (Nair & Hinton, 2010) is used in the generator with the exception of the output layer which uses the Tanh function. We observed that using a bounded activation allowed the model to learn more quickly to saturate and cover the color space of the training distribution. Within the discriminator we found the leaky rectified activation (Maas et al., 2013) (Xu et al., 2015) to work well, especially for higher resolution modeling.\" - [Source](https:\/\/stackoverflow.com\/questions\/41489907\/generative-adversarial-networks-tanh)\n\n\nNote that since the outputs of the TanH activation lie in the range `[-1,1]`, we have applied the same transformation to the images in the training dataset. Let's generate an output vector using the generator and view it as an image by transforming and denormalizing the output.","555d8b82":"Note that we are are transforming the pixel values from the range `[0, 1]` to the range `[-1, 1]`. The reason for doing this will become clear when define the generator network. Let's look at a sample tensor from the data.","c7154f63":"Let's save a batch of real images that we can use for visual comparision while looking at the generated images.","2f4e5b13":"## Generator Training\n\nSince the outputs of the generator are images, it's not obvious how we can train the generator. This is where we employ a rather elegant trick, which is to use the discriminator as a part of the loss function. Here's how it works:\n\n- We generate a batch of images using the generator, pass the into the discriminator.\n\n- We calculate the loss by setting the target labels to 1 i.e. real. We do this because the generator's objective is to \"fool\" the discriminator.\u00c2\u00a0\n\n- We use the loss to perform gradient descent i.e. change the weights of the generator, so it gets better at generating real-like images.\n\nHere's what this looks like in code.","4444124b":"Let's define helper functions to reset gradients and  train the discriminator.","851ae246":"Here are the steps involved in training the discriminator.\n\n- We expect the discriminator to output 1 if the image was picked from the real MNIST dataset, and 0 if it was generated.\u00c2\u00a0\n\n- We first pass a batch of real images, and compute the loss, setting the target labels to 1.\u00c2\u00a0\n\n- Then, we generate a batch of fake images using the generator, pass them into the discriminator, and compute the loss, setting the target labels to 0.\u00c2\u00a0\n\n- Finally we add the two losses and use the overall loss to perform gradient descent to adjust the weights of the discriminator.\n\nIt's important to note that we don't change the weights of the generator model while training the discriminator (`d_optimizer` only affects the `D.parameters()`)","3974a426":"## Training the Model\n\nLet's create a directory where we can save intermediate outputs from the generator to visually inspect the progress of the model","cf110f97":"We'll also define a helper function to save a batch of generated images to disk at the end of every epoch. We'll use a fixed set of input vectors to the generator to see how the individual generated images evolve over time as we train the model.","21942b7c":"## Discriminator Network\n\nThe discriminator takes an image as input, and tries to classify it as \"real\" or \"generated\". In this sense, it's like any other neural network. While we can use a CNN for the discriminator, we'll use a simple feedforward network with 3 linear layers to keep things since. We'll treat each 28x28 image as a vector of size 784.","8645a709":"As one might expect, the output from the generator is basically random noise. Let's define a helper function which can save a batch of outputs from the generator to a file.\n\nLet's move the generator to the chosen device.","03760fa9":"We can visualize the training process by combining the sample images generated after each epoch into a video using OpenCV.","e7129f38":"Here's how the generated images look, after the 10th, 50th, 100th and 300th epochs of training.","07a3424e":"As expected, the pixel values range from -1 to 1. Let's define a helper to denormalize and view the images. This function will also be useful for viewing the generated images.","eebf853c":"## Save and Commit\n\nWe can caputre a snapshot of our work (including the Jupyter notebook, sample images and trained models) using the `jovian` Python library.","13bf72db":"Running `jovian.commit` uploads the Jupyter notebook and the associated files to your [Jovian.ml](https:\/\/www.jovian.ml) account. You can share the project online publicly, or collaborate privately with your friends & colleagues. Jovian also automatically captures the Python environment (dependencies & library versions), so that you & others can reproduce your work easily. Jovian also includes a powerful commenting interface for discussion. To learn more visit [www.jovian.ml](https:\/\/www.jovian.ml).\n\n<img src=\"https:\/\/i.imgur.com\/KVjXpd6.png\">","2afec401":"You can view the animated training video here: https:\/\/www.youtube.com\/watch?v=R7HTX79JlBg\n\nWe can also visualize how the loss changes over time. Visualizing losses is quite useful for debugging the training process. For GANs, we expect the generator's loss to reduce over time, without the discriminator's loss getting too high.","75cbe693":"## Generator Network\n\nThe input to the generator is typically a vector or a matrix which is used as a seed for generating an image. Once again, to keep things simple, we'll use a feedfoward neural network with 3 layers, and the output will be a vector of size 784, which can be transformed to a 28x28 px image.","eed4e3bf":"Finally, let's create a dataloader to load the images in batches.","338fa4be":"We'll also create a `device` which can be used to move the data and models to a GPU, if one is available.","421f8d41":"## Load the Data\n\nWe begin by downloading and importing the data as a PyTorch dataset using the `MNIST` helper class from `torchvision.datasets`."}}