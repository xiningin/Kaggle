{"cell_type":{"fcf6b11c":"code","8101e2a2":"code","934c8077":"code","52d2e9d4":"code","813995be":"code","7eddec12":"code","1afdbdfa":"code","f122987f":"code","b49943af":"code","000a5d94":"code","694c7a10":"code","c8ba1bcf":"code","da7437c2":"code","8b39fc1b":"code","d50d2f8e":"code","74decfdb":"code","5f5c53af":"code","5e0d933e":"code","a7f0f665":"code","b31728b9":"code","895eb7b4":"code","8717c436":"code","10605784":"code","bb744ab5":"code","4418e60f":"code","1178ef16":"code","53559d64":"code","470da229":"code","3a1c0478":"code","25bcf5ae":"code","2040d970":"code","d61a7870":"code","62078f50":"code","49d9da17":"code","94f7beba":"code","9408472a":"code","54d95af4":"code","465d3fbc":"code","a1148d39":"code","77843719":"code","e664a003":"code","6bbb58ea":"code","7e3bac27":"markdown","d14720c0":"markdown","81da8dd3":"markdown","af64b663":"markdown","0b6941c1":"markdown","f326d498":"markdown","733b1f40":"markdown","7814525a":"markdown","b5952c82":"markdown","65e56238":"markdown","3d518001":"markdown","fb57b867":"markdown","ba0b534a":"markdown","3f1d76e1":"markdown","0dc1c5e1":"markdown","b30a6437":"markdown","dca94b59":"markdown","161ffa6f":"markdown","e85551d9":"markdown","5014d629":"markdown","7b8dff2e":"markdown","a7e05e22":"markdown","7c18eafe":"markdown","0e2bd7e2":"markdown","80d3cfd9":"markdown","cc35dcd5":"markdown","7ba23937":"markdown","54cb2b7d":"markdown","ef74265e":"markdown","67f0b7e0":"markdown","67af155d":"markdown","e4ad4348":"markdown","55d5edb0":"markdown","0a7585fd":"markdown","07cf966e":"markdown","20c2f1a1":"markdown","c8c7f6b9":"markdown","03656313":"markdown"},"source":{"fcf6b11c":"!pip install TPOT","8101e2a2":"!pip install pycaret","934c8077":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport missingno as msno\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls\nimport plotly.express as px\n\nimport cufflinks as cf \n\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\n\n%matplotlib inline\nsns.set_style(\"whitegrid\")\nplt.style.use(\"fivethirtyeight\")\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.ensemble import ExtraTreesClassifier\nfrom sklearn.ensemble import AdaBoostClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.neighbors import  RadiusNeighborsClassifier\nfrom sklearn.linear_model import PassiveAggressiveClassifier\nfrom sklearn.naive_bayes import BernoulliNB\nfrom sklearn.svm import NuSVC\nfrom sklearn.svm import LinearSVC\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.ensemble import BaggingClassifier\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nimport xgboost as xgb\nfrom sklearn.linear_model import RidgeClassifier\nfrom catboost import Pool, CatBoostClassifier, cv\nimport lightgbm as lgb\nimport plotly.offline as py\nfrom plotly.offline import init_notebook_mode, iplot\nimport plotly.graph_objs as go\nfrom plotly import tools\ninit_notebook_mode(connected=True)  \nimport plotly.figure_factory as ff\n\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.decomposition import PCA\nimport random\n","52d2e9d4":"def random_colors(number_of_colors):\n    color = [\"#\"+''.join([random.choice('0123456789ABCDEF') for j in range(6)])\n                 for i in range(number_of_colors)]\n    return color","813995be":"train = pd.read_csv(\"\/kaggle\/input\/creditcardfraud\/creditcard.csv\")","7eddec12":"table = ff.create_table(train.head().round(1))\niplot(table,filename='jupyter-table1')","1afdbdfa":"train.columns\n","f122987f":"train.shape\n","b49943af":"iplot(ff.create_table(train.dtypes.to_frame().reset_index().round(3)),filename='jupyter-table2')","000a5d94":"train.describe().reset_index().round(1)","694c7a10":"train.isnull().sum()","c8ba1bcf":"msno.bar(train, color = 'b', figsize = (10,8))","da7437c2":"msno.matrix(train)","8b39fc1b":"species_count = train['Class'].value_counts()\ndata = [go.Bar(\n    x = species_count.index,\n    y = species_count.values,\n    marker = dict(color = random_colors(3),line=dict(color='#000000', width=2))\n)]\n\nlayout = go.Layout(\n   {\n      \"title\":\"Fraudlant VS Non- Fraudlant\",\n   }\n)\n\nfig = go.Figure(data=data,layout = layout)\niplot(fig)","d50d2f8e":"trace = go.Pie(labels = list(train.Class.unique()), values = list(train.Class.value_counts()),\n                            hole = 0.2,\n               marker=dict(colors = random_colors(3), \n                           line=dict(color='#000000', width=2)\n                           ))\ndata = [trace]\nlayout = go.Layout(\n   {\n      \"title\":\"Fraudlant VS Non- Fraudlant\",\n   }\n)\n\nfig = go.Figure(data=data,layout = layout)\niplot(fig)","74decfdb":"data = [go.Heatmap(z = np.array(train.corr().values),\n                   x = np.array(train.corr().columns),\n                   y = np.array(train.corr().columns),\n                     colorscale='Viridis',)\n       ]\nlayout = go.Layout(dict(title = 'Correlation Matrix for variables',\n                            #autosize = False,\n                            #height  = 1400,\n                            #width   = 1600,\n                            margin  = dict(r = 0 ,l = 100,\n                                           t = 0,b = 100,\n                                         ),\n                            yaxis   = dict(tickfont = dict(size = 9)),\n                            xaxis   = dict(tickfont = dict(size = 9)),\n                           )\n                      )\n\nfig = go.Figure(data=data,layout = layout)\niplot(fig)","5f5c53af":"X = train.iloc[:,:-1].values\ny = train.iloc[:,-1].values\nencoder = LabelEncoder()\ny = encoder.fit_transform(y)\n\n# Splitting the dataset into the Training set and Test set\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 42)","5e0d933e":"## Logistic Regression\n\nModel = LogisticRegression()\nModel.fit(X_train, y_train)\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))","a7f0f665":"# K-Nearest Neighbours\n\nModel = KNeighborsClassifier(n_neighbors=8)\nModel.fit(X_train, y_train)\n\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))","b31728b9":"## Decision Tree\n\nModel = DecisionTreeClassifier()\nModel.fit(X_train, y_train)\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))","895eb7b4":"## Naive Bayes\n\nModel = GaussianNB()\nModel.fit(X_train, y_train)\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))","8717c436":"# Linear Discriminant Analysis\n\nModel = LinearDiscriminantAnalysis()\nModel.fit(X_train, y_train)\n\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))","10605784":"## Light GBM\n\nparams = {'objective':'binary', 'metric':'accuracy'}\n  \n# create dataset for lightgbm\nlgb_train = lgb.Dataset(X_train, y_train)\nlgb_test = lgb.Dataset(X_test, y_test, reference=lgb_train)\n\nModel = lgb.train(params, lgb_train, valid_sets=[lgb_train, lgb_test], verbose_eval=10)\ny_pred=Model.predict(X_test)\nprint(classification_report(y_test,y_pred.round()))\n","bb744ab5":"\nModel=CatBoostClassifier(eval_metric='Accuracy',use_best_model=True,random_seed=42)\nModel.fit(X_train,y_train,eval_set=(X_test,y_test))","4418e60f":"## CatBoost\ny_pred=Model.predict(X_test)\nprint(classification_report(y_test,y_pred))\nprint(confusion_matrix(y_pred,y_test))\n#Accuracy Score\nprint('accuracy is ',accuracy_score(y_pred,y_test))","1178ef16":"## XGBoost\n\nModel=xgb.XGBClassifier(max_depth=3, n_estimators=300, learning_rate=0.05)\nModel.fit(X_train,y_train)\ny_pred=Model.predict(X_test)\nprint(classification_report(y_test,y_pred))\nprint(confusion_matrix(y_pred,y_test))\n#Accuracy Score\nprint('accuracy is ',accuracy_score(y_pred,y_test))","53559d64":"## Ridge Classifier\n\nModel=RidgeClassifier()\nModel.fit(X_train,y_train)\ny_pred=Model.predict(X_test)\nprint(classification_report(y_test,y_pred))\nprint(confusion_matrix(y_pred,y_test))\n#Accuracy Score\nprint('accuracy is ',accuracy_score(y_pred,y_test))","470da229":"## Quadratic Discriminant Analysis\n\nModel=QuadraticDiscriminantAnalysis()\nModel.fit(X_train,y_train)\ny_pred=Model.predict(X_test)\nprint(classification_report(y_test,y_pred))\nprint(confusion_matrix(y_pred,y_test))\n#Accuracy Score\nprint('accuracy is ',accuracy_score(y_pred,y_test))","3a1c0478":"## Bagging Classifier\n\nModel=BaggingClassifier()\nModel.fit(X_train,y_train)\ny_pred=Model.predict(X_test)\nprint(classification_report(y_test,y_pred))\nprint(confusion_matrix(y_pred,y_test))\n#Accuracy Score\nprint('accuracy is ',accuracy_score(y_pred,y_test))","25bcf5ae":"## MLPClassifier\n\nModel=MLPClassifier()\nModel.fit(X_train,y_train)\ny_pred=Model.predict(X_test)\n# Summary of the predictions\nprint(classification_report(y_test,y_pred))\nprint(confusion_matrix(y_test,y_pred))\n#Accuracy Score\nprint('accuracy is ',accuracy_score(y_pred,y_test))","2040d970":"## Linear Support Vector Classification\n \nModel = LinearSVC()\nModel.fit(X_train, y_train)\n\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))","d61a7870":"## BernoulliNB\n\nModel = BernoulliNB()\nModel.fit(X_train, y_train)\n\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\nprint('accuracy is',accuracy_score(y_pred,y_test))","62078f50":"## Passive Aggressive Classifier\n\nModel = PassiveAggressiveClassifier()\nModel.fit(X_train, y_train)\n\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\nprint('accuracy is',accuracy_score(y_pred,y_test))","49d9da17":"## Gradient Boosting Machine\nModel = GradientBoostingClassifier(n_estimators=100, random_state=9)\nModel.fit(X_train, y_train)\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))\n","94f7beba":"## Adaboost\n\nModel = AdaBoostClassifier(n_estimators=100, random_state=9)\nModel.fit(X_train, y_train)\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))\n","9408472a":"## Extra Trees\n\nModel = ExtraTreesClassifier(n_estimators=100, max_features=3)\nModel.fit(X_train, y_train)\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))\n","54d95af4":"\n## Random Forest\n\nModel = RandomForestClassifier(n_estimators=100, max_features=3)\nModel.fit(X_train, y_train)\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))","465d3fbc":"## Support Vector Machine\n\nModel = SVC()\nModel.fit(X_train, y_train)\ny_pred = Model.predict(X_test)\n\n# Summary of the predictions made by the classifier\nprint(classification_report(y_test, y_pred))\nprint(confusion_matrix(y_test, y_pred))\n# Accuracy score\n\nprint('accuracy is',accuracy_score(y_pred,y_test))","a1148d39":"! pip install -U pycaret # Quite large depencies to install !","77843719":"from pycaret.classification import *\n\nclf1 = setup(data = train, \n             target = 'Class',\n             silent = True)\n","e664a003":"compare_models()\n","6bbb58ea":"lgbm  = create_model('catboost')      ","7e3bac27":"<a id=\"4.1\"><\/a>\n<font color=\"blue\" size=+2.5><b> Data Handling and Preparation <\/b><\/font>\n","d14720c0":"<a id=\"5.3\"><\/a>\n<font color=\"blue\" size=+2.5><b> Decision Tree (CART) <\/b><\/font>\n\n*Classification and Regression Trees (CART or just decision trees) construct a binary tree from\nthe training data. Split points are chosen greedily by evaluating each attribute and each value\nof each attribute in the training data in order to minimize a cost function (like the Gini index).\nYou can construct a CART model using the DecisionTreeClassifier class*","81da8dd3":"<a id=\"3\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Exploratory Data Analysis <\/center><\/h2>","af64b663":"# Upvote The Kernel If you like my work","0b6941c1":"<a id=\"1.1\"><\/a>\n<font color=\"blue\" size=+2.5><b> About Data<\/b><\/font>\n<br\/>\n<br\/>\nThe datasets contains transactions made by credit cards in September 2013 by european cardholders.\nThis dataset presents transactions that occurred in two days, where we have 492 frauds out of 284,807 transactions. The dataset is highly unbalanced, the positive class (frauds) account for 0.172% of all transactions.Feature 'Class' is the response variable and it takes value 1 in case of fraud and 0 otherwise.\n","f326d498":"<a id=\"5.2\"><\/a>\n<font color=\"blue\" size=+2.5><b> K-Nearest Neighbours <\/b><\/font>\n\n*The k-nearest neighbors (KNN) algorithm is a simple, easy-to-implement supervised machine learning algorithm that can be used to solve both classification and regression problems*","733b1f40":"<a id=\"5.16\"><\/a>\n<font color=\"blue\" size=+2.5><b> Passive Aggressive Classifier <\/b><\/font>\n\n*Like MultinomialNB, this classifier is suitable for **discrete data**. The difference is that while MultinomialNB works with occurrence counts, BernoulliNB is designed for binary\/boolean features.*\nThe Passive-Aggressive algorithms are a family of Machine learning algorithms that are not very well known by beginners and even intermediate Machine Learning enthusiasts. However, they can be very useful and efficient for certain applications.","7814525a":"<a id=\"5.12\"><\/a>\n<font color=\"blue\" size=+2.5><b> MLPClassifier  <\/b><\/font>\n\n*MLPClassifier stands for Multi-layer Perceptron classifier which in the name itself connects to a Neural Network. Unlike other classification algorithms such as Support Vectors or Naive Bayes Classifier, MLPClassifier relies on an underlying Neural Network to perform the task of classification.*","b5952c82":"<a id=\"5.13\"><\/a>\n<font color=\"blue\" size=+2.5><b> Linear Support Vector Classification  <\/b><\/font>\n\n*Similar to **SVC** with parameter kernel=\u2019linear\u2019, but implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples.*","65e56238":"<a id=\"5.11\"><\/a>\n<font color=\"blue\" size=+2.5><b> Bagging classifier  <\/b><\/font>\n\n*A Bagging classifier is an ensemble **meta-estimator** that fits base classifiers each on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator (e.g., a decision tree), by introducing randomization into its construction procedure and then making an ensemble out of it.*","3d518001":"<a id=\"5\"><\/a>\n<font color=\"blue\" size=+2.5><b> Model Training <\/b><\/font>\n","fb57b867":"<a id=\"2\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Load and Check Data  <\/center><\/h2>","ba0b534a":"<a id=\"5.19\"><\/a>\n<font color=\"blue\" size=+2.5><b> \nAdaBoost <\/b><\/font>\n\n*AdaBoost was perhaps the first successful boosting ensemble algorithm. It generally works by weighting instances in the dataset by how easy or difficult they are to classify, allowing the algorithm to pay or less attention to them in the construction of subsequent models. You can construct an AdaBoost model for classification using the AdaBoostClassifier class*","3f1d76e1":"<a id=\"5.18\"><\/a>\n<font color=\"blue\" size=+2.5><b> Stochastic Gradient Boosting <\/b><\/font>\n\n*Stochastic Gradient Boosting (also called Gradient Boosting Machines) are one of the most sophisticated ensemble techniques. It is also a technique that is proving to be perhaps one of the best techniques available for improving performance via ensembles. You can construct a Gradient Boosting model for classification using the GradientBoostingClassifier class*","0dc1c5e1":"<a id=\"top\"><\/a>\n<div class=\"list-group\" id=\"list-tab\" role=\"tablist\">\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center> Table of content <\/center><\/h2>\n\n<font color=\"blue\" size=+1><b>Introduction<\/b><\/font>\n* [About Data ](#1.1)\n* [Data Dictionary ](#1.3)\n* [Data Variable](#1.4)\n    \n<font color=\"blue\" size=+1><b> Load and Check Data <\/b><\/font>\n* [Importing Library](#2.1)\n* [Load Dataset](#2.2)\n\n<font color=\"blue\" size=+1><b> Exploratory Data Analysis <\/b><\/font>\n* [Missing Value Analysis](#3.1)\n* [Target Variable Analysis](#3.2)    \n    \n<font color=\"blue\" size=+1><b> Data Handling and Preparation <\/b><\/font>\n* [Handing Missing Data ](#4.1)\n* [Train Test Split ](#4.2)\n\n<font color=\"blue\" size=+1><b> Model Training <\/b><\/font>\n* [Logistic Regression ](#5.1)\n* [K-Nearest Neighbours ](#5.2)    \n* [Decision Tree ](#5.3)\n* [Naive Bayes ](#5.4)    \n* [Linear Discriminant Analysis ](#5.5)\n* [LightLGM ](#5.6)    \n* [CatBoost ](#5.7)\n* [XGBoost ](#5.8)    \n* [Ridge Classifier ](#5.9)\n* [Quadratic Discriminant Analysis ](#5.10)    \n* [Bagging classifier ](#5.11)\n* [MLPClassifier](#5.12)    \n* [Linear Support Vector Classification ](#5.13)\n* [Nu-Support Vector Classification ](#5.14)    \n* [BernoulliNB ](#5.15)\n* [Passive Aggressive Classifier ](#5.16)    \n* [Stochastic Gradient Boosting ](#5.18)    \n* [AdaBoost ](#5.19)\n* [Extra Trees ](#5.20)    \n* [Random Forest ](#5.21)\n* [SVC ](#5.22)    \n* [PyCaret ](#5.25)\n","b30a6437":"<a id=\"2.1\"><\/a>\n<font color=\"blue\" size=+2.5><b> Import Libraries <\/b><\/font>\n","dca94b59":"<a id=\"5.15\"><\/a>\n<font color=\"blue\" size=+2.5><b> BernoulliNB <\/b><\/font>\n\n*Like MultinomialNB, this classifier is suitable for **discrete data**. The difference is that while MultinomialNB works with occurrence counts, BernoulliNB is designed for binary\/boolean features.*","161ffa6f":"<a id=\"5.20\"><\/a>\n<font color=\"blue\" size=+2.5><b> Extra Trees <\/b><\/font>\n\n*Extra Trees are another modification of bagging where random trees are constructed from samples of the training dataset. You can construct an Extra Trees model for classification using the ExtraTreesClassifier class*","e85551d9":"<a id=\"5.8\"><\/a>\n<font color=\"blue\" size=+2.5><b> XGBoost <\/b><\/font>\n\n*XGBoost stands for Extreme Gradient Boosting, it is a performant machine learning library based on the paper Greedy Function Approximation: A Gradient Boosting Machine, by Friedman. XGBoost implements a Gradient Boosting algorithm based on decision trees.*","5014d629":"![image.png](attachment:image.png)\\","7b8dff2e":"<a id=\"5.4\"><\/a>\n<font color=\"blue\" size=+2.5><b> Naive Bayes <\/b><\/font>\n\n*Naive Bayes calculates the probability of each class and the conditional probability of each class\ngiven each input value. These probabilities are estimated for new data and multiplied together,\nassuming that they are all independent (a simple or naive assumption). When working with\nreal-valued data, a Gaussian distribution is assumed to easily estimate the probabilities for\ninput variables using the Gaussian Probability Density Function. You can construct a Naive\nBayes model using the GaussianNB class*","a7e05e22":"\n\n<a id=\"1\"><\/a>\n<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>  Introduction  <\/center><\/h2>","7c18eafe":"<a id=\"5.10\"><\/a>\n<font color=\"blue\" size=+2.5><b> Quadratic Discriminant Analysis <\/b><\/font>\n\n\n*A classifier with a quadratic decision boundary, generated by fitting class conditional densities to the data and using Bayes\u2019 rule.\nThe model fits a **Gaussian** density to each class.*","0e2bd7e2":"<a id=\"3.1\"><\/a>\n<font color=\"blue\" size=+2.5><b> Missing Value Analysis <\/b><\/font>\n","80d3cfd9":"<a id=\"5.22\"><\/a>\n<font color=\"blue\" size=+2.5><b> Support Vector Machine <\/b><\/font>\n\n*Support Vector Machines (or SVM) seek a line that best separates two classes. Those data instances that are closest to the line that best separates the classes are called support vectors and influence where the line is placed. SVM has been extended to support multiple classes Of particular importance is the use of different kernel functions via the kernel parameter .A powerful Radial Basis Function is used by default. You can construct an SVM model using the SVC class.*","cc35dcd5":"<a id=\"5.25\"><\/a>\n<font color=\"blue\" size=+2.5><b> Pycaret <\/b><\/font>\n","7ba23937":"<font size=\"+2\" color=blue ><b>Please Upvote my kernel and keep it in your favourite section if you think it is helpful.<\/b><\/font>","54cb2b7d":"<a id=\"2.2\"><\/a>\n<font color=\"blue\" size=+2.5><b> Import Dataset <\/b><\/font>\n","ef74265e":"<a id=\"5.21\"><\/a>\n<font color=\"blue\" size=+2.5><b> Random Forest <\/b><\/font>\n\n*Random Forests is an extension of bagged decision trees. Samples of the training dataset are taken with replacement, but the trees are constructed in a way that reduces the correlation between individual classifiers. Specifically, rather than greedily choosing the best split point in the construction of each tree, only a random subset of features are considered for each split. You can construct a Random Forest model for classification using the RandomForestClassifier class.*","67f0b7e0":"<a id=\"5.9\"><\/a>\n<font color=\"blue\" size=+2.5><b> Ridge Classifier <\/b><\/font>\n\n*Classifier using Ridge regression. This classifier first converts the target values into {-1, 1} and then treats the problem as a \nregression task (multi-output regression in the multiclass case).*","67af155d":"<a id=\"3.62\"><\/a>\n<font color=\"blue\" size=+2.5><b> Correlation <\/b><\/font>\n","e4ad4348":"<a id=\"3.2\"><\/a>\n<font color=\"blue\" size=+2.5><b> Target Variable Analysis <\/b><\/font>\n","55d5edb0":"<a id=\"5.1\"><\/a>\n<font color=\"blue\" size=+2.5><b> Logistic Regression <\/b><\/font>\n\n*Logistic regression assumes a Gaussian distribution for the numeric input variables and can\nmodel binary classification problems. You can construct a logistic regression model using the\nLogisticRegression class*","0a7585fd":"<h2 class=\"list-group-item list-group-item-action active\" data-toggle=\"list\"  role=\"tab\" aria-controls=\"home\"> <center>Objective  <\/center><\/h2>\n\nGoal of this kernel is following:\n- Basic Exploratory Data Analysis.\n- Beginners guide on Credit Card Fraud Dataset.\n- Feature Analysis\n- Modelling on 25+ Models","07cf966e":"<a id=\"5.5\"><\/a>\n<font color=\"blue\" size=+2.5><b> Linear Discriminant Analysis <\/b><\/font>\n\n*Linear Discriminant Analysis or LDA is a statistical technique for binary and multiclass\nclassification. It too assumes a Gaussian distribution for the numerical input variables. You can\nconstruct an LDA model using the LinearDiscriminantAnalysis class.*","20c2f1a1":"<a id=\"5.6\"><\/a>\n<font color=\"blue\" size=+2.5><b> LightGBM <\/b><\/font>\n\n*LightGBM is a gradient boosting framework that uses tree based learning algorithms. It is designed to be distributed and efficient with the following advantages:*\n\nFaster training speed and higher efficiency.\nLower memory usage.\nBetter accuracy.\nSupport of parallel and GPU learning.\nCapable of handling large-scale data.","c8c7f6b9":"<font size=\"+3\" color=blue><b> <center><u> Credit Card + EDA + (25+) Models For Beginners <\/u><\/center><\/b><\/font>","03656313":"<a id=\"5.7\"><\/a>\n<font color=\"blue\" size=+2.5><b> CatBoost <\/b><\/font>\n\n*CatBoost is an algorithm for gradient boosting on decision trees. It is developed by Yandex researchers and engineers, and is used for search, recommendation systems, personal assistant, self-driving cars, weather prediction and many other tasks at Yandex and in other companies, including CERN, Cloudflare, Careem taxi. It is in open-source and can be used by anyone.*"}}