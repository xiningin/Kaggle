{"cell_type":{"67f1f052":"code","976c587c":"code","e41c157a":"code","640a484c":"code","7af4b25a":"code","0bcd1258":"code","58d6d762":"code","dcd27536":"code","1a1dd131":"code","d576f98e":"code","56b5fed5":"code","eb2978a9":"code","efd1a67b":"code","fac55e27":"code","83427e13":"code","e8423f85":"code","c8dbb752":"code","846bb5df":"code","697d6618":"code","0aa226cd":"code","f6927180":"code","e287ff03":"code","c233e7fb":"code","292b3acf":"code","62d44fb0":"code","0b5de628":"code","70ef7b91":"code","66f797d2":"code","9d0fd576":"code","41f308a6":"code","d2350de0":"code","afcf1ec2":"code","26be940d":"code","b200a641":"code","ad476fba":"code","a4b237ce":"code","501d82bc":"code","a76c8dda":"code","ba4201c2":"code","56315183":"code","229af2b9":"code","75a17894":"code","c71da050":"code","a4bac62c":"code","5aed25a7":"code","a24b0c9c":"code","a40187cd":"code","2aedc052":"code","f7af7de6":"code","168eae60":"code","5fa9e673":"code","1e93281e":"code","64dce42c":"code","ca75c8da":"code","f3e9f27b":"code","c8c57f84":"code","1e6f5f4e":"code","15d3a4aa":"code","4b6d92e5":"code","b7dede23":"code","9b86d06a":"code","eab7ff49":"code","5e311232":"code","c966e3b4":"code","9407ff56":"code","1ada1daa":"code","79fa7439":"code","2e9156b9":"code","7613c6a1":"code","f228b0c2":"code","b0b0961e":"code","c0334a1a":"code","5950d051":"code","621d2e40":"code","94922f32":"code","ef9fdfa6":"code","b0ed32bc":"code","df01409b":"code","e2232179":"code","5c7643da":"code","dd8ee784":"code","17ac24fe":"code","5bc97789":"code","96d672c2":"code","8a770539":"code","0e4215a2":"code","e2def3d5":"code","f81eebc6":"code","06a9f3ba":"code","f0897735":"code","94a9a770":"code","a9d8fbd7":"code","265cbd68":"code","728e4669":"markdown","e6c004d8":"markdown","2ab6087f":"markdown","4aede29b":"markdown","78c8ebf1":"markdown","1baa047b":"markdown","18217e7f":"markdown","f92e3e63":"markdown","4ce2d3bf":"markdown","15e9daf3":"markdown","85e53414":"markdown","2da02c6a":"markdown","d0df6c87":"markdown"},"source":{"67f1f052":"!pip install -q --upgrade pip","976c587c":"!pip install -q -U albumentations","e41c157a":"# !pip install -q -U efficientnet\n!pip install -q efficientnet","640a484c":"# !pip install -q -U tf-nightly","7af4b25a":"# !pip install -q -U keras-efficientnet-v2","0bcd1258":"!pip install -q -U tensorflow_addons","58d6d762":"!pip install -q -U adabound","dcd27536":"# \u0438\u043c\u043f\u043e\u0440\u0442\u044b\n\nimport os, re, math, random, time, gc, string, pickle, shutil, pathlib, itertools\nimport numpy as np, pandas as pd, matplotlib.pyplot as plt, PIL\n\nimport tensorflow as tf\n#import tensorflow_addons as tfa\nfrom tensorflow import keras\nfrom tensorflow.keras import *\nfrom tensorflow.keras.activations import *\nfrom tensorflow.keras.applications import *\nfrom tensorflow.keras.callbacks import *\nfrom tensorflow.keras.layers import *\nfrom tensorflow.keras.layers.experimental.preprocessing import *\nfrom tensorflow.keras.losses import *\nfrom tensorflow.keras.optimizers import *\nfrom tensorflow.keras.optimizers.schedules import *\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\n\nfrom PIL import Image\nfrom IPython.display import clear_output\nfrom tqdm.notebook import tqdm","1a1dd131":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pickle\nimport zipfile\nimport csv\nimport cv2\nimport sys\nimport os\nimport re, math, random, time, gc, string, pathlib, itertools\n\nimport car_class_kernel_module as km\n\nimport tensorflow as tf\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.callbacks import LearningRateScheduler, ModelCheckpoint\nfrom tensorflow.keras.callbacks import Callback\nfrom tensorflow.keras.regularizers import l2\nfrom tensorflow.keras import optimizers\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.applications.xception import Xception\nfrom tensorflow.keras.layers import *\nimport efficientnet.tfkeras as efn\n\nimport tensorflow.keras as keras\nimport tensorflow.keras.models as M\nimport tensorflow.keras.layers as L\nimport tensorflow.keras.backend as K\n\nfrom IPython.display import clear_output\nfrom tqdm.notebook import tqdm\nfrom pprint import pprint\n\nimport albumentations as A\nimport tensorflow_addons as tfa\n\nfrom adabound import AdaBound\nfrom tensorflow_addons.optimizers import AdamW\n\n# from tensorflow.keras.applications.efficientnet_v2 import *\n\nfrom sklearn.model_selection import train_test_split, StratifiedKFold\n\n# sns.set()\n\nimport PIL\nfrom PIL import ImageOps, ImageFilter\n# \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u043c \u0434\u0435\u0444\u043e\u043b\u0442\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432\nfrom pylab import rcParams\nrcParams['figure.figsize'] = (10, 5)\n# \u0433\u0440\u0430\u0444\u0438\u043a\u0438 \u0432 svg \u0432\u044b\u0433\u043b\u044f\u0434\u044f\u0442 \u0431\u043e\u043b\u0435\u0435 \u0447\u0435\u0442\u043a\u0438\u043c\u0438\n%config InlineBackend.figure_format = 'svg' \n%matplotlib inline\n\nprint(os.listdir(\"..\/input\"))\nprint('Python       :', sys.version.split('\\n')[0])\nprint('Numpy        :', np.__version__)\nprint('Tensorflow   :', tf.__version__)\nprint('Keras        :', tf.keras.__version__)\nprint('PIL          :', PIL.__version__)","d576f98e":"# GPU count and name\n# !nvidia-smi\n!nvidia-smi -L\n# \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0447\u0442\u043e \u0443 \u043d\u0430\u0441 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 GPU\ntf.test.gpu_device_name()","56b5fed5":"!pip freeze > requirements.txt","eb2978a9":"DATA_PATH = '..\/input\/sf-dl-car-classification\/' # \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0441 \u0434\u0430\u043d\u043d\u044b\u043c\u0438\nPATH = '..\/working\/car\/' # \u0440\u0430\u0431\u043e\u0447\u0430\u044f \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f\nPATH_MODELS = '..\/working\/saved_models\/'\nprint(os.listdir('..'))","efd1a67b":"os.makedirs(PATH_MODELS, exist_ok=True, mode=0o777)\nprint(os.path.exists(PATH_MODELS))\n!pwd","fac55e27":"os.makedirs(PATH, exist_ok=True, mode=0o777)\nprint(os.path.exists(PATH))\n!pwd","83427e13":"%%time\nprint('\u0420\u0430\u0441\u043f\u0430\u043a\u043e\u0432\u044b\u0432\u0430\u0435\u043c \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0438')\n# Will unzip the files so that you can see them\nfor data_zip in ['train.zip', 'test.zip']:\n    with zipfile.ZipFile(DATA_PATH+data_zip,\"r\") as z:\n        z.extractall(PATH)\nprint(os.listdir(PATH))","e8423f85":"train_df = pd.read_csv(DATA_PATH+'train.csv')\nsample_submission = pd.read_csv(DATA_PATH+'sample-submission.csv')","c8dbb752":"train_df_init = train_df.copy()","846bb5df":"train_filenames_list = []\ntrain_categories_list = []","697d6618":"train_list = os.listdir(PATH+'train\/')\ntest_list = os.listdir(PATH+'test_upload\/')\nprint(len(train_list), len(test_list), train_df.shape[0])\nprint(train_list)\ntrain_count = 0\nfor dir_path in train_list:\n    train_filenames = os.listdir(PATH+'train\/'+dir_path)\n    train_count += len(train_filenames)\n    train_filenames_list += train_filenames\n    train_categories_list += [int(dir_path)] * len(train_filenames)\n    print(train_filenames[:5])\n    \nprint(train_count == train_df.shape[0])\nprint(test_list[:10])","0aa226cd":"train_df_test = pd.DataFrame({\n    'Id' : train_filenames_list,\n    'Category' : train_categories_list,\n}, columns=['Id', 'Category'])","f6927180":"train_df.sort_values(by=['Id'], inplace=True, ignore_index=True)\ntrain_df_test.sort_values(by=['Id'], inplace=True, ignore_index=True)\ntrain_df.equals(train_df_test)","e287ff03":"train_df.sort_values(by=['Category'], inplace=True, ignore_index=True)\ntrain_df_test.sort_values(by=['Category'], inplace=True, ignore_index=True)\ntrain_df.equals(train_df_test)","c233e7fb":"train_path = PATH + 'train\/'\nsub_path = PATH + 'test_upload\/'","292b3acf":"train_df = train_df_init\n\ndef get_path(row):\n    return 'train\/' + str(row['Category']) + '\/' + row['Id']\n\ntrain_df['Path'] = train_df.apply(get_path, axis=1)","62d44fb0":"train_df.info()","0b5de628":"sample_submission.Category = 0\nsample_submission.head()","70ef7b91":"# \u0412 setup \u0432\u044b\u043d\u043e\u0441\u0438\u043c \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438: \u0442\u0430\u043a \u0443\u0434\u043e\u0431\u043d\u0435\u0435 \u0438\u0445 \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0442\u044c \u0432 \u0434\u0430\u043b\u044c\u043d\u0435\u0439\u0448\u0435\u043c.\n\nEPOCHS               = 5  # 10 \u044d\u043f\u043e\u0445 \u043d\u0430 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u0435\nBATCH_SIZE           = 32 # \u0443\u043c\u0435\u043d\u044c\u0448\u0430\u0435\u043c batch \u0435\u0441\u043b\u0438 \u0441\u0435\u0442\u044c \u0431\u043e\u043b\u044c\u0448\u0430\u044f, \u0438\u043d\u0430\u0447\u0435 \u043d\u0435 \u0432\u043b\u0435\u0437\u0435\u0442 \u0432 \u043f\u0430\u043c\u044f\u0442\u044c \u043d\u0430 GPU\nLR                   = 1e-4\nVAL_SPLIT            = 0.2 # \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0434\u0430\u043d\u043d\u044b\u0445 \u0432\u044b\u0434\u0435\u043b\u044f\u0435\u043c \u043d\u0430 \u0442\u0435\u0441\u0442 = 20%\n\nCLASS_NUM            = 10  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u043b\u0430\u0441\u0441\u043e\u0432 \u0432 \u043d\u0430\u0448\u0435\u0439 \u0437\u0430\u0434\u0430\u0447\u0435\nIMG_SIZE             = (90, 120) # (150, 150) \u043a\u0430\u043a\u043e\u0433\u043e \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043f\u043e\u0434\u0430\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u0441\u0435\u0442\u044c, default size is 224\nIMG_CHANNELS         = 3   # \u0443 RGB 3 \u043a\u0430\u043d\u0430\u043b\u0430\nINPUT_SHAPE          = (*IMG_SIZE, IMG_CHANNELS)\n\n# \u0423\u0441\u0442\u0430\u043d\u0430\u043b\u0438\u0432\u0430\u0435\u043c \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 random seed \u0434\u043b\u044f \u0432\u043e\u0441\u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438\nRANDOM_SEED = 42\nnp.random.seed(RANDOM_SEED)  \nPYTHONHASHSEED = RANDOM_SEED\ntf.random.set_seed(RANDOM_SEED)","66f797d2":"# \u0438\u043c\u0435\u043d\u0430 \u043a\u043b\u0430\u0441\u0441\u043e\u0432\nclass_names = [\n  '\u041f\u0440\u0438\u043e\u0440\u0430', #0\n  'Ford Focus', #1\n  '\u0421\u0430\u043c\u0430\u0440\u0430', #2\n  '\u0412\u0410\u0417-2110', #3\n  '\u0416\u0438\u0433\u0443\u043b\u0438', #4\n  '\u041d\u0438\u0432\u0430', #5\n  '\u041a\u0430\u043b\u0438\u043d\u0430', #6\n  '\u0412\u0410\u0417-2109', #7\n  'Volkswagen Passat', #8\n  '\u0412\u0410\u0417-21099' #9\n]\nclass_names_dict = dict(zip(range(CLASS_NUM), class_names))\n# pprint(class_names_dict)","9d0fd576":"data = train_df\ndisplay(data.info(), data.isna().sum(), data.head())","41f308a6":"train_df.Category.value_counts().sort_index()\n# \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043a\u043b\u0430\u0441\u0441\u043e\u0432 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0440\u0430\u0432\u043d\u043e\u043c\u0435\u0440\u043d\u043e\u0435 - \u044d\u0442\u043e \u0445\u043e\u0440\u043e\u0448\u043e","d2350de0":"km.plot_classes_hist(train_df.Category)","afcf1ec2":"%%time\n\n# image_interpolation = 'box'\n# image_interpolation = 'hamming'\nimage_interpolation = 'hamming'\n\ntrain_datagen = ImageDataGenerator(\n#     rescale=1\/255,\n    validation_split=VAL_SPLIT,\n    # \u043d\u0438\u0436\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0430\u0443\u0433\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0439:\n    horizontal_flip=True,\n    rotation_range=10,\n    shear_range=0.2,\n    brightness_range=(0.8, 1.2),\n    \n#     zoom_range = 0.25,\n#     height_shift_range=0.2,\n\n#     fill_mode='wrap',    \n#     zca_whitening=True,\n)\n\nval_datagen = ImageDataGenerator(\n#     rescale=1\/255,\n    validation_split=VAL_SPLIT,\n)\n\nsub_datagen = ImageDataGenerator(\n#     rescale=1\/255\n)\n\n# train_generator = train_datagen.flow_from_directory(\n#     train_path,\n#     target_size=IMG_SIZE,\n#     batch_size=BATCH_SIZE,\n#     class_mode='categorical',\n#     interpolation=image_interpolation,\n#     shuffle=True,\n#     seed=RANDOM_SEED,\n#     subset='training'\n# )\n\n# val_generator = val_datagen.flow_from_directory(\n#     train_path,\n#     target_size=IMG_SIZE,\n#     batch_size=BATCH_SIZE,\n#     class_mode='categorical',\n#     interpolation=image_interpolation,\n#     shuffle=True,\n#     seed=RANDOM_SEED,\n#     subset='validation'\n# )\n\nsub_generator = sub_datagen.flow_from_dataframe( \n    dataframe=sample_submission,\n    directory=sub_path,\n    x_col='Id',\n    y_col=None,\n    class_mode=None,\n    target_size=IMG_SIZE,\n    batch_size=BATCH_SIZE,\n    interpolation=image_interpolation,\n    shuffle=False\n)","26be940d":"train_df['Category'] = train_df['Category'].astype(str)\n\ntrain_df = train_df.sample(frac=1., random_state=RANDOM_SEED)","b200a641":"img_path = PATH + train_df['Path'].iloc[-1]\nprint(img_path)\nprint(os.path.exists(img_path))","ad476fba":"train_df_2 = train_df.copy()\ndisplay(train_df_2.Category.value_counts(normalize=True).round(3).sort_index())","a4b237ce":"df_train, df_test = train_test_split(train_df_2, test_size=0.2, random_state=0, shuffle=True, stratify=train_df_2.Category)\nprint(type(df_train), type(df_test))\nprint(df_train.shape[0] \/ train_df_2.shape[0], df_test.shape[0] \/ train_df_2.shape[0])","501d82bc":"display(df_train.Category.value_counts(normalize=True).round(3).sort_index())","a76c8dda":"display(df_test.Category.value_counts(normalize=True).round(3).sort_index())","ba4201c2":"# print(abc)","56315183":"train_generator = train_datagen.flow_from_dataframe(\n    dataframe=train_df,\n    directory=PATH,\n    x_col='Path',\n    y_col='Category',\n    class_mode='categorical',\n    target_size=IMG_SIZE,\n    batch_size=BATCH_SIZE,\n    interpolation=image_interpolation,\n    shuffle=True,\n    seed=RANDOM_SEED,\n    subset='training'\n)\n\nval_generator = val_datagen.flow_from_dataframe(\n    dataframe=train_df,\n    directory=PATH,\n    x_col='Path',\n    y_col='Category',\n    class_mode='categorical',\n    target_size=IMG_SIZE,\n    batch_size=BATCH_SIZE,\n    interpolation=image_interpolation,\n    shuffle=True,\n    seed=RANDOM_SEED,\n    subset='validation'\n)","229af2b9":"# %%time\n# train_categories_list = []\n\n# for batch in train_generator:\n#     img_batch, labels_batch = batch\n#     train_categories_list.append(np.argmax(labels_batch, axis=1)[0])","75a17894":"# %%time\n# val_categories_list = []\n\n# for batch in val_generator:\n#     img_batch, labels_batch = batch\n#     val_categories_list.append(np.argmax(labels_batch, axis=1)[0])","c71da050":"# display(train_df.sample(frac=1.))","a4bac62c":"print('Train:')\nkm.show_first_images(train_generator)\n\nprint('Val:')\nkm.show_first_images(val_generator)\n\nsub_generator.reset()\nprint('Sub:')\nkm.show_first_images(sub_generator, labels=False)\n\n# sub_generator.reset()\n# print('Sub:')\n# km.show_first_images(sub_generator, labels=False)","5aed25a7":"for batch in train_generator:\n    print(type(batch), len(batch))\n    print(type(batch[0]), type(batch[1]))\n    print(len(batch[0]), len(batch[1]))\n    print(type(batch[0][0]), type(batch[1][0]))\n    print((batch[0][0].shape), (batch[1][0].shape), np.sum(batch[1][0]))\n    break\n    \nprint()\n\nfor batch in val_generator:\n    print(type(batch), len(batch))\n    print(type(batch[0]), type(batch[1]))\n    print(len(batch[0]), len(batch[1]))\n    print(type(batch[0][0]), type(batch[1][0]))\n    print((batch[0][0].shape), (batch[1][0].shape), np.sum(batch[1][0]))\n    break\n    \nprint()    \n    \nfor batch in sub_generator:\n    print(type(batch), len(batch))\n    print(type(batch[0]))\n    print((batch[0].shape))\n    break","a24b0c9c":"def get_base_model():\n    base_model = EfficientNetB7(\n        weights='imagenet',\n        include_top=False,\n        input_shape=INPUT_SHAPE\n    )\n    print(id(base_model))\n    return base_model\n\n\ndef get_complete_model(base_model):\n    complete_model = Sequential([\n        base_model,\n        GlobalMaxPool2D(),\n\n#   GlobalAveragePooling2D(),    \n#   Dropout(0.5),\n#   Dense(2*512, activation='elu'),\n\n        Dropout(0.5),\n        Dense(10)\n    ])\n    print(id(complete_model))\n    return complete_model\n\n\ndef compile_model(model):\n    model.compile(\n        loss=CategoricalCrossentropy(from_logits=True), # label_smoothing=0.0\n        optimizer=Adam(ExponentialDecay(1e-3, 100, 0.9)), # ExponentialDecay(1e-3, 100, 0.9, staircase=False)\n        metrics='accuracy'\n    )","a40187cd":"# print(abc)","2aedc052":"optimizer_1 = Adam(lr=1e-3)\noptimizer_2 = Adam(ExponentialDecay(1e-3, 100, 0.9))\noptimizer_3 = AdamW(learning_rate=1e-3, weight_decay=1e-5)\noptimizer_4 = AdamW(learning_rate=ExponentialDecay(1e-3, 100, 0.9), weight_decay=1e-5)\n\nloss_1 = CategoricalCrossentropy(from_logits=True)\nmetrics_1 = 'accuracy'\n\n# optimizer_2 = optimizer_1","f7af7de6":"# \u043f\u0440\u0435\u0434\u043e\u0431\u0443\u0447\u0435\u043d\u043d\u0430\u044f \u043d\u0435\u0439\u0440\u043e\u0441\u0435\u0442\u044c \u0438\u0437 \u043c\u043e\u0434\u0443\u043b\u044f keras.applications\n# base_model = EfficientNetB7(weights='imagenet',\n#                             include_top=False,\n#                             input_shape=INPUT_SHAPE)\n\nbase_model = get_base_model()\n\n# first: train only the top layers (which were randomly initialized)\nbase_model.trainable = True","168eae60":"# # Freeze all the layers before the `fine_tune_at` layer\n# fine_tune_at = 50\n\n# for layer in base_model.layers[:fine_tune_at+1]:\n#     print(layer.trainable)\n\n# for layer in base_model.layers[:fine_tune_at]:\n#     layer.trainable = False\n    \n# for layer in base_model.layers[:fine_tune_at+1]:\n#     print(layer.trainable)","5fa9e673":"# # \u0441\u0442\u0440\u043e\u0438\u043c \u043c\u043e\u0434\u0435\u043b\u044c\n# model = Sequential([\n#   base_model, \n#   GlobalMaxPool2D(),\n\n# #   GlobalAveragePooling2D(),    \n# #   Dropout(0.5),\n# #   Dense(2*512, activation='elu'),\n\n#   Dropout(0.5),\n#   Dense(10)\n# ])\n\n# model.summary()\n\nmodel = get_complete_model(base_model)\n\n# \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u043b\u043e\u0435\u0432\nprint(len(model.layers))\n# len(model.trainable_variables)\n\n# Check the trainable status of the individual layers\nfor layer in model.layers:\n    print(layer, layer.trainable)","1e93281e":"# model.compile(loss=CategoricalCrossentropy(from_logits=True, label_smoothing=0.0),\n#               optimizer=Adam(ExponentialDecay(1e-3, 100, 0.9, staircase=False)),\n#               metrics='accuracy')\n\n# model.compile(loss=CategoricalCrossentropy(from_logits=True),\n#               optimizer=Adam(ExponentialDecay(1e-3, 100, 0.9)),\n#               metrics='accuracy')\n\ncompile_model(model)","64dce42c":"checkpoint = ModelCheckpoint(PATH_MODELS+'best_model.h5' , monitor='val_accuracy', verbose=1  , mode='max', save_best_only=True)\nterminate = TerminateOnNaN()\n\ndef do_after_each_epoch(epoch, logs):\n    model_name = 'model_epoch_' + str(epoch) + '.h5'\n    model.save_weights(PATH_MODELS+model_name)\n\neach_epoch = LambdaCallback(on_epoch_end=do_after_each_epoch)\n\ncallbacks_list = [checkpoint, terminate, each_epoch]","ca75c8da":"K.clear_session()\ntrain_generator.reset()\nval_generator.reset()","f3e9f27b":"%%time\n# \u043e\u0431\u0443\u0447\u0430\u0435\u043c \u043c\u043e\u0434\u0435\u043b\u044c\nhistory = model.fit(train_generator,\n                    validation_data=val_generator,\n                    epochs=EPOCHS, # EPOCHS\n                    callbacks=callbacks_list)","c8c57f84":"km.plot_history(history)\nmodel.load_weights(PATH_MODELS+'best_model.h5')\nos.listdir(PATH_MODELS)","1e6f5f4e":"# print(abc)","15d3a4aa":"# model.compile(loss=CategoricalCrossentropy(from_logits=True, label_smoothing=0.0),\n#               optimizer=Adam(ExponentialDecay(1e-3, 100, 0.9, staircase=False)),\n#               metrics='accuracy')\n\n# model.compile(loss=CategoricalCrossentropy(from_logits=True),\n#               optimizer=Adam(ExponentialDecay(1e-3, 100, 0.9)),\n#               metrics='accuracy')\n\ncompile_model(model)","4b6d92e5":"# # Let's take a look to see how many layers are in the base model\n# print(\"Number of layers in the base model: \", len(base_model.layers))","b7dede23":"# base_model.trainable = True\n\n# # Fine-tune from this layer onwards\n# fine_tune_at = len(base_model.layers) \/\/ 2\n\n# # Freeze all the layers before the `fine_tune_at` layer\n# for layer in base_model.layers[:fine_tune_at]:\n#     layer.trainable =  False\n    \n# print(len(base_model.trainable_variables))\n\n# # Check the trainable status of the individual layers\n# for layer in model.layers:\n#     print(layer, layer.trainable)","9b86d06a":"# # LR ????\n# model.compile(\n#     loss=loss_1,\n#     optimizer=optimizer_2,\n#     metrics=metrics_1\n# )","eab7ff49":"# train_generator.reset()\n# val_generator.reset()","5e311232":"# %%time\n# # \u043e\u0431\u0443\u0447\u0430\u0435\u043c \u043c\u043e\u0434\u0435\u043b\u044c\n# history = model.fit(train_generator,\n#                     validation_data=val_generator,\n#                     epochs=EPOCHS, # EPOCHS\n#                     callbacks=callbacks_list)","c966e3b4":"# km.plot_history(history)\n# model.load_weights(PATH_MODELS+'best_model.h5')\n# os.listdir(PATH_MODELS)","9407ff56":"%%time\n# # model = keras.models.load_model(PATH_MODELS+'best_model.h5')\n# model.load_weights(PATH_MODELS+'best_model.h5')\n# model.compile(\n#     loss=CategoricalCrossentropy(from_logits=True),\n#     optimizer=optimizer_2,\n#     metrics='accuracy'\n# )\n\nsub_generator.reset()\npredictions = model.predict(sub_generator, verbose=1)","1ada1daa":"# model_name = 'model_epoch_' + str(4) + '.h5'\n# model.load_weights(PATH_MODELS+model_name)\n# model.compile(\n#     loss=CategoricalCrossentropy(from_logits=True),\n#     optimizer=optimizer_2,\n#     metrics='accuracy'\n# )\n\n# sub_generator.reset()\n\n# predictions += model.predict(sub_generator, verbose=1)\n\n# predictions \/= 2","79fa7439":"# %%time\npredictions = predictions.argmax(axis=1)\nsubmission = pd.DataFrame({\n    'Id': sub_generator.filenames,\n    'Category': predictions\n}, columns=['Id', 'Category'])","2e9156b9":"km.plot_classes_hist(submission.Category)","7613c6a1":"# print(abc)","f228b0c2":"# km.clear_directory(PATH_MODELS)\n# print(os.path.exists(PATH_MODELS))","b0b0961e":"# os.makedirs(PATH_MODELS, exist_ok=True, mode=0o777)\n# print(os.path.exists(PATH_MODELS))\n# !pwd","c0334a1a":"# submission_df = submission.copy()\n\n# def get_path(row):\n#     return 'test_upload\/' + row['Id']\n\n# submission_df['Path'] = submission_df.apply(get_path, axis=1)\n# submission_df['Category'] = submission_df['Category'].astype(str)","5950d051":"# img_path = PATH + submission_df['Path'].iloc[-1]\n# print(img_path)\n# print(os.path.exists(img_path))","621d2e40":"# train_submission_df = pd.concat([train_df, submission_df], axis=0, ignore_index=True)\n# print(train_df.shape)\n# print(submission_df.shape)\n# print(train_submission_df.shape)","94922f32":"# train_submission_df = train_submission_df.sample(frac=1., random_state=1)","ef9fdfa6":"# train_generator = train_datagen.flow_from_dataframe(\n#     dataframe=train_submission_df,\n#     directory=PATH,\n#     x_col='Path',\n#     y_col='Category',\n#     class_mode='categorical',\n#     target_size=IMG_SIZE,\n#     batch_size=BATCH_SIZE,\n#     interpolation=image_interpolation,\n#     shuffle=True,\n#     seed=RANDOM_SEED,\n#     subset='training'\n# )\n\n# val_generator = val_datagen.flow_from_dataframe(\n#     dataframe=train_submission_df,\n#     directory=PATH,\n#     x_col='Path',\n#     y_col='Category',\n#     class_mode='categorical',\n#     target_size=IMG_SIZE,\n#     batch_size=BATCH_SIZE,\n#     interpolation=image_interpolation,\n#     shuffle=True,\n#     seed=RANDOM_SEED,\n#     subset='validation'\n# )","b0ed32bc":"# base_model = EfficientNetB7(weights='imagenet',\n#                             include_top=False,\n#                             input_shape=INPUT_SHAPE)\n\n# base_model.trainable = True\n\n# model = Sequential([\n#   base_model, \n#   GlobalMaxPool2D(),\n#   Dropout(0.5),\n#   Dense(10)\n# ])\n\n# model.compile(loss=CategoricalCrossentropy(from_logits=True),\n#               optimizer=Adam(ExponentialDecay(1e-3, 100, 0.9)),\n#               metrics='accuracy')","df01409b":"# K.clear_session()\n# train_generator.reset()\n# val_generator.reset()","e2232179":"# %%time\n# # \u043e\u0431\u0443\u0447\u0430\u0435\u043c \u043c\u043e\u0434\u0435\u043b\u044c\n# history = model.fit(train_generator,\n#                     validation_data=val_generator,\n#                     epochs=EPOCHS, # EPOCHS\n#                     callbacks=callbacks_list)","5c7643da":"# km.plot_history(history)\n# model.load_weights(PATH_MODELS+'best_model.h5')\n# os.listdir(PATH_MODELS)","dd8ee784":"# model.compile(loss=CategoricalCrossentropy(from_logits=True),\n#               optimizer=Adam(ExponentialDecay(1e-3, 100, 0.9)),\n#               metrics='accuracy')","17ac24fe":"# %%time\n# sub_generator.reset()\n# predictions = model.predict(sub_generator, verbose=1)","5bc97789":"# # %%time\n# predictions = predictions.argmax(axis=1)\n# submission = pd.DataFrame({\n#     'Id': sub_generator.filenames,\n#     'Category': predictions\n# }, columns=['Id', 'Category'])","96d672c2":"# km.plot_classes_hist(submission.Category)","8a770539":"# sub_datagen = ImageDataGenerator(\n# #     rescale=1\/255,\n#     # \u043d\u0438\u0436\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0430\u0443\u0433\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0439:\n#     horizontal_flip=True,\n#     rotation_range=10,\n#     shear_range=0.2,\n#     brightness_range=(0.8, 1.2),\n# )\n\n# sub_generator = sub_datagen.flow_from_dataframe( \n#     dataframe=sample_submission,\n#     directory=sub_path,\n#     x_col='Id',\n#     y_col=None,\n#     class_mode=None,\n#     target_size=IMG_SIZE,\n#     batch_size=BATCH_SIZE,\n#     interpolation=image_interpolation,\n#     shuffle=False\n# )","0e4215a2":"# predictions = []\n# for _ in range(5):\n#     sub_generator.reset()\n#     predictions.append(model.predict(sub_generator, verbose=1))   \n# predictions = np.array(predictions)\n# predictions.shape","e2def3d5":"# final_predictions = predictions.mean(axis=0).argmax(axis=-1)\n# final_predictions","f81eebc6":"# # %%time\n# submission = pd.DataFrame({\n#     'Id': sub_generator.filenames,\n#     'Category': final_predictions\n# }, columns=['Id', 'Category'])","06a9f3ba":"# plt.figure(figsize=(15, 3))\n# plt.imshow(predictions.argmax(axis=-1)[:, :50], cmap='nipy_spectral')\n# plt.xlabel('\u041d\u043e\u043c\u0435\u0440 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f')\n# plt.ylabel('\u041d\u043e\u043c\u0435\u0440 \u043f\u043e\u043f\u044b\u0442\u043a\u0438')\n# plt.show()","f0897735":"# sub_generator.reset()\n# show_first_images(sub_generator, labels=False)\n# sub_generator.reset()\n# show_first_images(sub_generator, labels=False)","94a9a770":"# print(abc)","a9d8fbd7":"km.clear_directory(PATH)\nkm.clear_directory(PATH_MODELS)\nprint(os.listdir('..\/working\/'))","265cbd68":"submission.to_csv('submission.csv', index=False)","728e4669":"\u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440\u044b \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0439","e6c004d8":"## Sub data for model fit","2ab6087f":"# \u041a\u043b\u0430\u0441\u0441\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0439\n\n### \u041e\u0441\u043d\u043e\u0432\u043d\u0430\u044f \u0438\u0434\u0435\u044f \u044d\u0442\u043e\u0433\u043e \u0440\u0435\u0448\u0435\u043d\u0438\u044f: \u0432\u0437\u044f\u0442\u044c \u043f\u0440\u0435\u0434\u043e\u0431\u0443\u0447\u0435\u043d\u0443\u044e \u043d\u0430 ImageNet \u0441\u0435\u0442\u044c \u0438 \u0434\u043e\u043e\u0431\u0443\u0447\u0438\u0442\u044c \u043f\u043e\u0434 \u043d\u0430\u0448\u0443 \u0437\u0430\u0434\u0430\u0447\u0443.","4aede29b":"# \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438","78c8ebf1":"# \u041c\u043e\u0434\u0435\u043b\u044c","1baa047b":"## Test-time augmentations (TTA)","18217e7f":"# \u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u0434\u0430\u043d\u043d\u044b\u0445","f92e3e63":"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u043f\u0430\u043a\u0435\u0442\u044b","4ce2d3bf":"**\u0420\u0430\u0431\u043e\u0442\u0430\u0435\u043c \u0441 Tensorflow v2**","15e9daf3":"## Step 2","85e53414":"# Others","2da02c6a":"# Functions","d0df6c87":"# EDA \/ \u0410\u043d\u0430\u043b\u0438\u0437 \u0434\u0430\u043d\u043d\u044b\u0445"}}