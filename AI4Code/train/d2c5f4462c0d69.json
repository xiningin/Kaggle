{"cell_type":{"8be23f4e":"code","f5184e4a":"code","b8340a6d":"code","ffa91a59":"code","bd9bb71b":"code","5c16e381":"code","44e8de89":"code","fa884002":"code","2cb970ca":"code","ab5fb070":"code","86cd0cec":"code","af8bd381":"code","fcc484bc":"code","3ad623af":"code","429ac4ec":"code","5032f95b":"code","0a6777e5":"code","40c4502f":"code","6d3c0bd5":"markdown","85dae614":"markdown","adc082ae":"markdown"},"source":{"8be23f4e":"import numpy as np\nimport random\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport os\nimport copy\nimport seaborn as sns\n \nfrom sklearn import preprocessing\nfrom sklearn.metrics import log_loss\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import QuantileTransformer\nfrom sklearn.decomposition import PCA\nfrom sklearn.feature_selection import VarianceThreshold\n \nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n \nimport warnings\nwarnings.filterwarnings('ignore')","f5184e4a":"!pip install \/kaggle\/input\/iterative-stratification\/iterative-stratification-master\/\nfrom iterstrat.ml_stratifiers import MultilabelStratifiedKFold","b8340a6d":"seed = 42\n\ndef seed_everything(seed):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    os.environ[\"PYTHONHASHSEED\"] = str(seed)\n    \n    if torch.cuda.is_available():\n        torch.cuda.manual_seed(seed)\n        torch.cuda.manual_seed_all(seed)\n        torch.backends.cudnn.deterministic = True\n        torch.backends.cudnn.benchmark = False\nseed_everything(seed)","ffa91a59":"def preprocessor_nn_transfer():\n    variance_threshould = 0.8\n    ncompo_genes = 600\n    ncompo_cells = 50\n    \n    data_dir = '..\/input\/lish-moa\/'\n    train_features = pd.read_csv(data_dir + 'train_features.csv')\n    train_targets_scored = pd.read_csv(data_dir + 'train_targets_scored.csv')\n    train_targets_nonscored = pd.read_csv(data_dir + 'train_targets_nonscored.csv')\n    train_drug = pd.read_csv(data_dir + 'train_drug.csv')\n    test_features = pd.read_csv(data_dir + 'test_features.csv')\n    sample_submission = pd.read_csv(data_dir + 'sample_submission.csv')\n    \n    \n    train_features = train_features[train_features['cp_type'] != 'ctl_vehicle'].reset_index(drop=True)\n    test_features = test_features[test_features['cp_type'] != 'ctl_vehicle'].reset_index(drop=True)\n    # drop cp_type\n    train_features = train_features.drop('cp_type', axis=1)\n    test_features = test_features.drop('cp_type', axis=1)\n\n    \n    GENES = [col for col in train_features.columns if col.startswith('g-')]\n    CELLS = [col for col in train_features.columns if col.startswith('c-')]\n    \n    # Rank Gauss\n    for col in (GENES + CELLS):\n        transformer = QuantileTransformer(n_quantiles=100,random_state=0, output_distribution=\"normal\")\n        vec_len = len(train_features[col].values)\n        vec_len_test = len(test_features[col].values)\n        raw_vec = train_features[col].values.reshape(vec_len, 1)\n        transformer.fit(raw_vec)\n\n        train_features[col] = transformer.transform(raw_vec).reshape(1, vec_len)[0]\n        test_features[col] = transformer.transform(test_features[col].values.reshape(vec_len_test, 1)).reshape(1, vec_len_test)[0]\n    \n    \n    # PCA\n    # g\n    pca_genes = PCA(n_components = ncompo_genes, random_state = seed)\n    pca_genes_train = pca_genes.fit_transform(train_features[GENES])\n    # c\n    pca_cells = PCA(n_components = ncompo_cells, random_state = seed)\n    pca_cells_train = pca_cells.fit_transform(train_features[CELLS])\n    #train\n    pca_genes_train = pd.DataFrame(pca_genes_train, columns = [f\"pca_g-{i}\" for i in range(ncompo_genes)])\n    pca_cells_train = pd.DataFrame(pca_cells_train, columns = [f\"pca_c-{i}\" for i in range(ncompo_cells)])\n    train_features = pd.concat([train_features, pca_genes_train, pca_cells_train], axis = 1)\n    #test\n    pca_genes_test = pca_genes.transform(test_features[GENES])\n    pca_cells_test = pca_cells.transform(test_features[CELLS])\n    \n    pca_genes_test = pd.DataFrame(pca_genes_test, columns = [f\"pca_g-{i}\" for i in range(ncompo_genes)])\n    pca_cells_test = pd.DataFrame(pca_cells_test, columns = [f\"pca_c-{i}\" for i in range(ncompo_cells)])\n    test_features = pd.concat([test_features, pca_genes_test, pca_cells_test], axis = 1)\n\n    \n    # \u7279\u5f81\u9009\u62e9\n    cols_numeric = [feat for feat in list(train_features.columns) if feat not in [\"sig_id\", \"cp_time\", \"cp_dose\"]]\n    mask = (train_features[cols_numeric].var() >= variance_threshould).values\n    tmp = train_features[cols_numeric].loc[:, mask]\n    train_features = pd.concat([train_features[[\"sig_id\", \"cp_time\", \"cp_dose\"]], tmp], axis = 1)\n    cols_numeric = [feat for feat in list(train_features.columns) if feat not in [\"sig_id\", \"cp_time\", \"cp_dose\"]]\n    test_features = pd.concat([test_features[[\"sig_id\", \"cp_time\", \"cp_dose\"]], test_features.loc[:,cols_numeric]], axis = 1)\n    \n    # \u79bb\u6563\u503c\u5904\u7406\n    train_features = pd.get_dummies(train_features, columns = ['cp_time', 'cp_dose'])\n    test_features = pd.get_dummies(test_features, columns = ['cp_time', 'cp_dose'])\n\n    train = train_features.merge(train_targets_scored, on='sig_id')\n    train = train.merge(train_targets_nonscored, on='sig_id')\n    train = train.merge(train_drug, on='sig_id')\n    test = test_features\n    \n    # \u83b7\u53d6\u76ee\u6807\u7c7b\u578b \u5217\n    target_cols = [x for x in train_targets_scored.columns if x != 'sig_id']\n    num_targets = len(target_cols) # \u76ee\u6807\u7c7b\u578b\u957f\u5ea6\n    \n    return train, test, num_targets, num_aux_targets, num_all_targets, target_cols, aux_target_cols, all_target_cols","bd9bb71b":"train, test, num_targets, num_aux_targets, num_all_targets, target_cols, aux_target_cols, all_target_cols = preprocessor_nn_transfer()","5c16e381":"class MoADataset:\n    def __init__(self, features, targets):\n        self.features = features\n        self.targets = targets\n        \n    def __len__(self):\n        return (self.features.shape[0])\n    \n    def __getitem__(self, idx):\n        dct = {\n            'x' : torch.tensor(self.features[idx, :], dtype=torch.float),\n            'y' : torch.tensor(self.targets[idx, :], dtype=torch.float)}\n        \n        return dct\n    \nclass TestDataset:\n    def __init__(self, features):\n        self.features = features\n        \n    def __len__(self):\n        return (self.features.shape[0])\n    \n    def __getitem__(self, idx):\n        dct = {'x' : torch.tensor(self.features[idx, :], dtype=torch.float)}\n\n        return dct","44e8de89":"# \u8bad\u7ec3\u6570\u636e\ndef train_fn(model, optimizer, scheduler, loss_fn, dataloader, device):\n    model.train()\n    final_loss = 0\n    \n    for data in dataloader:\n        # \u68af\u5ea6\u6e05\u96f6\n        optimizer.zero_grad()\n        # \u8f6c\u79fb\u6570\u636e\u5230GPU\n        inputs, targets = data['x'].to(device), data['y'].to(device)\n        # \u6a21\u578b\u8f93\u51fa\n        outputs = model(inputs)\n        # \u8ba1\u7b97\u635f\u5931\n        loss = loss_fn(outputs, targets)\n        # \u8ba1\u7b97\u68af\u5ea6\n        loss.backward()\n        # \u53cd\u5411\u4f20\u64ad\n        optimizer.step()\n        # \u63d0\u524d\u505c\u6b62\n        scheduler.step()\n        # \u635f\u5931\u503c\u6c42\u548c\n        final_loss += loss.item()\n        \n    final_loss \/= len(dataloader) # \u6c42\u5e73\u5747\n    return final_loss\n\n# \u4ea4\u53c9\u9a8c\u8bc1\ndef valid_fn(model, loss_fn, dataloader, device):\n    model.eval()\n    final_loss = 0\n    valid_preds = []\n    \n    # \u52a0\u8f7d\u6570\u636e\n    for data in dataloader:\n        inputs, targets = data['x'].to(device), data['y'].to(device)\n        outputs = model(inputs)\n        loss = loss_fn(outputs, targets)\n        final_loss += loss.item()\n        valid_preds.append(outputs.sigmoid().detach().cpu().numpy())\n    final_loss \/= len(dataloader)\n    valid_preds = np.concatenate(valid_preds)\n    return final_loss, valid_preds\n\ndef inference_fn(model, dataloader, device):\n    model.eval()\n    preds = []\n    for data in dataloader:\n        inputs = data['x'].to(device)\n        with torch.no_grad():\n            outputs = model(inputs)\n        preds.append(outputs.sigmoid().detach().cpu().numpy())\n        \n    preds = np.concatenate(preds)\n    return preds","fa884002":"# \u6784\u5efa\u795e\u7ecf\u7f51\u7edc\nclass Model(nn.Module):\n    def __init__(self, num_features, num_targets):\n        super(Model, self).__init__()\n        # \u7f51\u7edc\u53c2\u6570\n        self.hidden_size = [1500, 1250, 1000, 750]\n        self.dropout_value = [0.5, 0.35, 0.3, 0.25]\n\n        self.batch_norm1 = nn.BatchNorm1d(num_features)\n        self.dense1 = nn.Linear(num_features, self.hidden_size[0])\n        \n        self.batch_norm2 = nn.BatchNorm1d(self.hidden_size[0])\n        self.dropout2 = nn.Dropout(self.dropout_value[0])\n        self.dense2 = nn.Linear(self.hidden_size[0], self.hidden_size[1])\n\n        self.batch_norm3 = nn.BatchNorm1d(self.hidden_size[1])\n        self.dropout3 = nn.Dropout(self.dropout_value[1])\n        self.dense3 = nn.Linear(self.hidden_size[1], self.hidden_size[2])\n\n        self.batch_norm4 = nn.BatchNorm1d(self.hidden_size[2])\n        self.dropout4 = nn.Dropout(self.dropout_value[2])\n        self.dense4 = nn.Linear(self.hidden_size[2], self.hidden_size[3])\n\n        self.batch_norm5 = nn.BatchNorm1d(self.hidden_size[3])\n        self.dropout5 = nn.Dropout(self.dropout_value[3])\n        self.dense5 = nn.utils.weight_norm(nn.Linear(self.hidden_size[3], num_targets))\n    \n    def forward(self, x):\n        x = self.batch_norm1(x)\n        x = F.leaky_relu(self.dense1(x))\n        \n        x = self.batch_norm2(x)\n        x = self.dropout2(x)\n        x = F.leaky_relu(self.dense2(x))\n\n        x = self.batch_norm3(x)\n        x = self.dropout3(x)\n        x = F.leaky_relu(self.dense3(x))\n\n        x = self.batch_norm4(x)\n        x = self.dropout4(x)\n        x = F.leaky_relu(self.dense4(x))\n\n        x = self.batch_norm5(x)\n        x = self.dropout5(x)\n        x = self.dense5(x)\n        return x","2cb970ca":"feature_cols = [c for c in train.columns if c not in all_target_cols] # \u53d6\u51fa \u975e\u76ee\u6807\u7684 \u7279\u5f81\nfeature_cols = [c for c in feature_cols if c not in ['kfold', 'sig_id', 'drug_id']]\nnum_features = len(feature_cols)","ab5fb070":"# \u8d85\u53c2\u6570\nDEVICE = ('cuda' if torch.cuda.is_available() else 'cpu')\nEPOCHS = 24\nBATCH_SIZE = 128\n\nWEIGHT_DECAY = {'ALL_TARGETS': 1e-5, 'SCORED_ONLY': 3e-6} # \u6743\u91cd\u8870\u51cf\nMAX_LR = {'ALL_TARGETS': 1e-2, 'SCORED_ONLY': 3e-3} # \u6700\u5927\u5b66\u4e60\u7387\nDIV_FACTOR = {'ALL_TARGETS': 1e3, 'SCORED_ONLY': 1e2} # \u6b63\u5219\u56e0\u5b50\nPCT_START = 0.1 ","86cd0cec":"# \u6a21\u578b\u7ed3\u6784\nmodel = Model(num_features, num_all_targets)","af8bd381":"from sklearn.model_selection import KFold\n\n# \u8fdb\u884cK\u6298\u4ea4\u53c9\u9a8c\u8bc1\ndef make_cv_folds(train, SEEDS, NFOLDS, DRUG_THRESH):\n    vc = train.drug_id.value_counts()\n    vc1 = vc.loc[vc <= DRUG_THRESH].index.sort_values()\n    vc2 = vc.loc[vc > DRUG_THRESH].index.sort_values()\n\n    for seed_id in SEEDS:\n        kfold_col = 'kfold_{}'.format(seed_id)\n        \n        dct1 = {}\n        dct2 = {}\n\n        skf = MultilabelStratifiedKFold(n_splits=NFOLDS, shuffle=True, random_state=seed_id)\n        tmp = train.groupby('drug_id')[target_cols].mean().loc[vc1]\n\n        for fold,(idxT, idxV) in enumerate(skf.split(tmp, tmp[target_cols])):\n            dd = {k: fold for k in tmp.index[idxV].values}\n            dct1.update(dd)\n\n        skf = MultilabelStratifiedKFold(n_splits=NFOLDS, shuffle=True, random_state=seed_id)\n        tmp = train.loc[train.drug_id.isin(vc2)].reset_index(drop=True)\n\n        for fold,(idxT, idxV) in enumerate(skf.split(tmp, tmp[target_cols])):\n            dd = {k: fold for k in tmp.sig_id[idxV].values}\n            dct2.update(dd)\n\n        train[kfold_col] = train.drug_id.map(dct1)\n        train.loc[train[kfold_col].isna(), kfold_col] = train.loc[train[kfold_col].isna(), 'sig_id'].map(dct2)\n        train[kfold_col] = train[kfold_col].astype('int8')\n        \n    return train\n\nSEEDS = list(range(42,49))\nNFOLDS = 10\nDRUG_THRESH = 18\n\ntrain = make_cv_folds(train, SEEDS, NFOLDS, DRUG_THRESH)\ntrain.head()","fcc484bc":"# \u5f00\u59cb\u8bad\u7ec3\ndef run_training(fold_id, seed_id):\n    seed_everything(seed_id)\n    \n    train_ = train\n    test_ = test\n    \n    kfold_col = f'kfold_{seed_id}'\n    trn_idx = train_[train_[kfold_col] != fold_id].index\n    val_idx = train_[train_[kfold_col] == fold_id].index\n    \n    train_df = train_[train_[kfold_col] != fold_id].reset_index(drop=True)\n    valid_df = train_[train_[kfold_col] == fold_id].reset_index(drop=True)\n    \n    def train_model(model, tag_name, target_cols_now, fine_tune_scheduler=None):\n        x_train, y_train  = train_df[feature_cols].values, train_df[target_cols_now].values\n        x_valid, y_valid =  valid_df[feature_cols].values, valid_df[target_cols_now].values\n        \n        train_dataset = MoADataset(x_train, y_train)\n        valid_dataset = MoADataset(x_valid, y_valid)\n\n        trainloader = torch.utils.data.DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)\n        validloader = torch.utils.data.DataLoader(valid_dataset, batch_size=BATCH_SIZE, shuffle=False)\n        \n        optimizer = torch.optim.Adam(model.parameters(), lr=1e-3, weight_decay=WEIGHT_DECAY[tag_name])\n        scheduler = optim.lr_scheduler.OneCycleLR(optimizer=optimizer,\n                                                  steps_per_epoch=len(trainloader),\n                                                  pct_start=PCT_START,\n                                                  div_factor=DIV_FACTOR[tag_name], \n                                                  max_lr=MAX_LR[tag_name],\n                                                  epochs=EPOCHS)\n        \n        loss_fn = nn.BCEWithLogitsLoss()\n        loss_tr = SmoothBCEwLogits(smoothing=0.001)\n\n        oof = np.zeros((len(train), len(target_cols_now)))\n        best_loss = np.inf\n        \n        for epoch in range(EPOCHS):\n            if fine_tune_scheduler is not None:\n                fine_tune_scheduler.step(epoch, model)\n\n            train_loss = train_fn(model, optimizer, scheduler, loss_tr, trainloader, DEVICE)\n            valid_loss, valid_preds = valid_fn(model, loss_fn, validloader, DEVICE)\n            print(f\"SEED: {seed_id}, FOLD: {fold_id}, {tag_name}, EPOCH: {epoch}, train_loss: {train_loss:.6f}, valid_loss: {valid_loss:.6f}\")\n\n            if np.isnan(valid_loss):\n                break\n            \n            if valid_loss < best_loss:\n                best_loss = valid_loss\n                oof[val_idx] = valid_preds\n                torch.save(model.state_dict(), f\"{tag_name}_SEED_{seed_id}_FOLD{fold_id}_.pth\")\n\n        return oof\n\n    model = Model(num_features, num_targets)\n    model.load_state_dict(torch.load(f\"..\/input\/nn-transferlearning-7seeds4248-10folds\/SCORED_ONLY_SEED_{seed_id}_FOLD{fold_id}_.pth\"))\n    model.to(DEVICE)\n\n    #--------------------- \u9884\u6d4b ---------------------\n    x_test = test_[feature_cols].values\n    testdataset = TestDataset(x_test)\n    testloader = torch.utils.data.DataLoader(testdataset, batch_size=BATCH_SIZE, shuffle=False)\n    \n    predictions = np.zeros((len(test_), num_targets))\n    predictions = inference_fn(model, testloader, DEVICE)\n    \n    return 0.02, predictions","3ad623af":"def run_k_fold(NFOLDS, seed_id):\n    oof = np.zeros((len(train), len(target_cols)))\n    predictions = np.zeros((len(test), len(target_cols)))\n    \n    for fold_id in range(NFOLDS):\n        oof_, pred_ = run_training(fold_id, seed_id)\n        predictions += pred_ \/ NFOLDS\n        oof += oof_\n        \n    return oof, predictions","429ac4ec":"data_dir = '..\/input\/lish-moa\/'\ntrain_targets_scored = pd.read_csv(data_dir + 'train_targets_scored.csv')","5032f95b":"valid_results = train_targets_scored.drop(columns=target_cols).merge(train[['sig_id']+target_cols], on='sig_id', how='left').fillna(0)\n\ny_true = train_targets_scored[target_cols].values\ny_pred = valid_results[target_cols].values\n\ny_pred = np.clip(y_pred, 0.0005, 0.9995)\n\nscore = 0\n\nfor i in range(len(target_cols)):\n    score += log_loss(y_true[:, i], y_pred[:, i])\n\nprint(\"CV log_loss: \", score \/ y_pred.shape[1])","0a6777e5":"sample_submission = pd.read_csv(data_dir + 'sample_submission.csv')\nsub = sample_submission.drop(columns=target_cols).merge(test[['sig_id']+target_cols], on='sig_id', how='left').fillna(0)\nsub.to_csv('submission.csv', index=False)","40c4502f":"saved_path_name = '..\/input\/nn-transferlearning-7seeds4248-10folds\/'\noof_TabNet_all = np.load(saved_path_name + 'oof_nn_transfer_all.npy')\nprint(oof_TabNet_all.shape)\n","6d3c0bd5":"# Model","85dae614":"# Dataset \u52a0\u8f7d\u7c7b","adc082ae":"# \u5355\u6b21\u8bad\u7ec3"}}