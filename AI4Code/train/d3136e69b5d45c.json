{"cell_type":{"97ad6b6b":"code","c410b813":"code","9c5d79e9":"code","7f4c3cc1":"code","7282ae21":"code","fef91a0f":"code","2eea8b59":"code","ece55206":"code","bc595d8d":"code","7f6abe16":"code","912ad48e":"code","d0a268f6":"markdown","fd88df5b":"markdown","ae2d0c31":"markdown","0e8f6dad":"markdown","51571b5b":"markdown","e2335215":"markdown","20034bc2":"markdown","d9ad4674":"markdown","40fe4ec5":"markdown"},"source":{"97ad6b6b":"import numpy as np                              # import numpy\nfrom numpy.linalg import inv                    # for matrix inverse\nimport matplotlib.pyplot as plt                 # import matplotlib.pyplot for plotting framework\nfrom scipy.stats import multivariate_normal     # for generating pdf\nimport random","c410b813":"m1 = [1,1]                                                \nm2 = [7,7]                                              \ncov1 = [[3, 2], [2, 3]]                                      \ncov2 = [[2, -1], [-1, 2]] # selecting random means and covariances","9c5d79e9":"x = np.random.multivariate_normal(m1, cov1, size=(200,))  # Generating 200 samples for each mean and covariance\ny = np.random.multivariate_normal(m2, cov2, size=(200,))","7f4c3cc1":"d = np.concatenate((x, y), axis=0)","7282ae21":"plt.figure(figsize=(10,10))                                             \nplt.scatter(d[:,0], d[:,1], marker='o')       \nplt.axis('equal')                                                                 \nplt.xlabel('X-Axis', fontsize=16)                                                 \nplt.ylabel('Y-Axis', fontsize=16)                                                 \nplt.title('Ground Truth', fontsize=22)                                            \nplt.grid()                                                                         \nplt.show()","fef91a0f":"m1 = random.choice(d)\nm2 = random.choice(d)\ncov1 = np.cov(np.transpose(d))\ncov2 = np.cov(np.transpose(d))\npi = 0.5","2eea8b59":"x1 = np.linspace(-4,11,200)  \nx2 = np.linspace(-4,11,200)\nX, Y = np.meshgrid(x1,x2) \n\nZ1 = multivariate_normal(m1, cov1)  \nZ2 = multivariate_normal(m2, cov2)\n\npos = np.empty(X.shape + (2,))                # a new array of given shape and type, without initializing entries\npos[:, :, 0] = X; pos[:, :, 1] = Y   \n\nplt.figure(figsize=(10,10))                                                          # creating the figure and assigning the size\nplt.scatter(d[:,0], d[:,1], marker='o')     \nplt.contour(X, Y, Z1.pdf(pos), colors=\"r\" ,alpha = 0.5) \nplt.contour(X, Y, Z2.pdf(pos), colors=\"b\" ,alpha = 0.5) \nplt.axis('equal')                                                                  # making both the axis equal\nplt.xlabel('X-Axis', fontsize=16)                                                  # X-Axis\nplt.ylabel('Y-Axis', fontsize=16)                                                  # Y-Axis\nplt.title('Initial State', fontsize=22)                                            # Title of the plot\nplt.grid()                                                                         # displaying gridlines\nplt.show()","ece55206":"##Expectation step\ndef Estep(lis1):\n    m1=lis1[0]\n    m2=lis1[1]\n    cov1=lis1[2]\n    cov2=lis1[3]\n    pi=lis1[4]\n    \n    pt2 = multivariate_normal.pdf(d, mean=m2, cov=cov2)\n    pt1 = multivariate_normal.pdf(d, mean=m1, cov=cov1)\n    w1 = pi * pt2\n    w2 = (1-pi) * pt1\n    eval1 = w1\/(w1+w2)\n\n    return(eval1)","bc595d8d":"## Maximization step\ndef Mstep(eval1):\n    num_mu1,din_mu1,num_mu2,din_mu2=0,0,0,0\n\n    for i in range(0,len(d)):\n        num_mu1 += (1-eval1[i]) * d[i]\n        din_mu1 += (1-eval1[i])\n\n        num_mu2 += eval1[i] * d[i]\n        din_mu2 += eval1[i]\n\n    mu1 = num_mu1\/din_mu1\n    mu2 = num_mu2\/din_mu2\n\n    num_s1,din_s1,num_s2,din_s2=0,0,0,0\n    for i in range(0,len(d)):\n\n        q1 = np.matrix(d[i]-mu1)\n        num_s1 += (1-eval1[i]) * np.dot(q1.T, q1)\n        din_s1 += (1-eval1[i])\n\n        q2 = np.matrix(d[i]-mu2)\n        num_s2 += eval1[i] * np.dot(q2.T, q2)\n        din_s2 += eval1[i]\n\n    s1 = num_s1\/din_s1\n    s2 = num_s2\/din_s2\n\n    pi = sum(eval1)\/len(d)\n    \n    lis2=[mu1,mu2,s1,s2,pi]\n    return(lis2)","7f6abe16":"def plot(lis1):\n    mu1=lis1[0]\n    mu2=lis1[1]\n    s1=lis1[2]\n    s2=lis1[3]\n    Z1 = multivariate_normal(mu1, s1)  \n    Z2 = multivariate_normal(mu2, s2)\n\n    pos = np.empty(X.shape + (2,))                # a new array of given shape and type, without initializing entries\n    pos[:, :, 0] = X; pos[:, :, 1] = Y   \n\n    plt.figure(figsize=(10,10))                                                          # creating the figure and assigning the size\n    plt.scatter(d[:,0], d[:,1], marker='o')     \n    plt.contour(X, Y, Z1.pdf(pos), colors=\"r\" ,alpha = 0.5) \n    plt.contour(X, Y, Z2.pdf(pos), colors=\"b\" ,alpha = 0.5) \n    plt.axis('equal')                                                                  # making both the axis equal\n    plt.xlabel('X-Axis', fontsize=16)                                                  # X-Axis\n    plt.ylabel('Y-Axis', fontsize=16)                                                  # Y-Axis\n    plt.grid()                                                                         # displaying gridlines\n    plt.show()","912ad48e":"iterations = 20\nlis1=[m1,m2,cov1,cov2,pi]\nfor i in range(0,iterations):\n    lis2 = Mstep(Estep(lis1))\n    lis1=lis2\n    if(i==0 or i == 4 or i == 9 or i == 14 or i == 19):\n        plot(lis1)","d0a268f6":"**Generating our data**","fd88df5b":"**Plotting Initial State**","ae2d0c31":"**Plotting the ground truth**","0e8f6dad":"**Function to plot the EM algorithm**","51571b5b":"**Maximization Step**","e2335215":"**Importing the required packages**","20034bc2":"**Expectation Step**","d9ad4674":"**Calling the functions and repeating until it converges**","40fe4ec5":"**Taking initial guesses for the parameters**"}}