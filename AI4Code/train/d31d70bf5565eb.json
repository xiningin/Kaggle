{"cell_type":{"1318a13d":"code","c4a6862b":"code","9ef5aaca":"code","9e874685":"code","fabe20c4":"code","0c7c4527":"code","b8fe3041":"code","e2d94760":"code","d49ab7e6":"code","6c626bb6":"code","a4f748f1":"code","679802cc":"code","6ea63e5c":"code","6da50e8b":"code","c4578beb":"code","47fd0ed8":"code","878b9a12":"markdown","defdc083":"markdown","f2628b3e":"markdown","6d06f81a":"markdown","0e9900cd":"markdown","6d86151d":"markdown","6a086bd6":"markdown","6d9c7c29":"markdown"},"source":{"1318a13d":"%%capture\n!pip install pycaret[full]\n\nimport pandas as pd\nimport numpy as np \nimport sys\nimport dateutil.easter as easter\nfrom pycaret.regression import *","c4a6862b":"TEST = False\ntrain = pd.read_csv('..\/input\/tabular-playground-series-jan-2022\/train.csv',index_col='row_id')\ntest = pd.read_csv('..\/input\/tabular-playground-series-jan-2022\/test.csv',index_col='row_id')\ntrain['date'] = pd.to_datetime(train.date)\ntrain['year']= train.date.dt.year\nprint(train[['num_sold','year']].groupby('year').mean())\nif TEST:\n    test = train[train.year == 2018].copy()\n    train.drop(test.index,inplace=True)\n    kgroups = 2\nelse:\n    kgroups = 3   ","9ef5aaca":"gdp = pd.read_csv('..\/input\/gdp-20152019-finland-norway-and-sweden\/GDP_data_2015_to_2019_Finland_Norway_Sweden.csv',index_col=0)\ngdp.columns = gdp.columns.str[4:]\ngdp = gdp.apply(lambda x: x**1.21) # see explanation in https:\/\/www.kaggle.com\/ambrosm\/tpsjan22-03-linear-model\/notebook\nscaler = gdp.iloc[kgroups+1]\/gdp\ngdp_map = scaler.stack().to_dict()","9e874685":"train['num_sold']=pd.Series(list(zip(train.date.dt.year,train.country))).map(gdp_map)*train.num_sold\ntrain['num_sold'] = np.log(train.num_sold)","fabe20c4":"def date_process(df):\n    \n    df['date'] = pd.to_datetime(df['date'])\n    df['year'] =  df['date'].dt.year\n    df['wd56'] = (df.date.dt.weekday >= 5).astype(str)+df.country\n    df['wd4'] = (df.date.dt.weekday == 4).astype(str)+df.country\n    df['dayofyear'] = df['date'].dt.dayofyear\n    df.loc[(df.date.dt.is_leap_year) & (df.dayofyear >= 60),'dayofyear'] -= 1\n    \n    # Christmas\n    xmas_date = df.date.dt.year.apply(lambda year: pd.Timestamp(str(year)+'-12-25'))\n    df['xmas_adjust1'] = (df.date - xmas_date).dt.days.clip(lower=1,upper=6)\n    df['xmas_adjust2'] = (df.date - xmas_date).dt.days.clip(lower=-2,upper=20)*1.0\n          \n    # New Year \n    df['newyear_adjust1'] = df.dayofyear.clip(lower=0,upper=15)\n    df['newyear_adjust2'] = df.dayofyear.clip(lower=0,upper=2)\n    \n    # Easter\n    easter_date = df.date.apply(lambda date: pd.Timestamp(easter.easter(date.year)))\n    df['easter_adj']= (df.date - easter_date).dt.days.clip(lower =-3,upper = 60).astype(float)\n    df.loc[df['easter_adj'].isin(range(12, 39)), 'easter_adj'] = 12 \n        \n    # Last Wednesday of June\n    wed_june_date = df.date.dt.year.map({2015: pd.Timestamp(('2015-06-24')),\n                                         2016: pd.Timestamp(('2016-06-29')),\n                                         2017: pd.Timestamp(('2017-06-28')),\n                                         2018: pd.Timestamp(('2018-06-27')),\n                                         2019: pd.Timestamp(('2019-06-26'))})\n    df['days_from_wed_jun'] = (df.date - wed_june_date).dt.days.clip(-5, 5)\n    \n    #First Sunday of November (second Sunday is Father's Day)\n    sun_nov_date = df.date.dt.year.map({2015: pd.Timestamp(('2015-11-1')),\n                                         2016: pd.Timestamp(('2016-11-6')),\n                                         2017: pd.Timestamp(('2017-11-5')),\n                                         2018: pd.Timestamp(('2018-11-4')),\n                                         2019: pd.Timestamp(('2019-11-3'))})\n    df['days_from_sun_nov'] = (df.date - sun_nov_date).dt.days.clip(-1, 9)\n    \n    df.drop(columns=['date'],inplace=True)\n    ","0c7c4527":"date_process(train)\ndate_process(test)","b8fe3041":"train.info()","e2d94760":"def SMAPE(y_true, y_pred):\n    diff = np.abs(y_true - y_pred) \/ (y_true + np.abs(y_pred)) * 200\n    return diff.mean()\n\n\nNUMBER_OF_MODELS = 5\nmodels= []\nfor i in range (NUMBER_OF_MODELS):\n    print ('Fit Model', i)\n    reg = setup(data = train,\n            target = 'num_sold',\n            data_split_shuffle = False, \n            create_clusters = False,\n            fold_strategy = 'groupkfold',\n            fold_groups = 'year',\n            use_gpu = True,\n            silent = True,\n            fold=kgroups,\n            ignore_features = ['country'],\n            n_jobs = -1)\n    add_metric('SMAPE', 'SMAPE', SMAPE, greater_is_better = False)\n    set_config('seed', 123+i*567)\n    models.append(create_model('catboost'))","d49ab7e6":"\nplot_model(models[0],'feature_all')","6c626bb6":"interpret_model(models[0])","a4f748f1":"blend = blend_models(models)","679802cc":"final_blend = finalize_model(blend)","6ea63e5c":"plot_model(final_blend,'error')","6da50e8b":"test['pred'] = np.exp(predict_model(final_blend, data=test)['Label'])\nsub = pd.DataFrame(list(zip(test.index,test.pred.values)),columns = ['row_id', 'num_sold'])\nsub.to_csv('submission.csv', index = False)","c4578beb":"sub.head()","47fd0ed8":"sub.mean()","878b9a12":"# Initial Setup","defdc083":"# TPS Jan 2022 with PyCaret\n\nThis is the second iteration of my notebook to demo how the Pycaret package can be used in this competition. \n\nIdeas from\n\nhttps:\/\/www.kaggle.com\/mfedeli\/tabular-playground-series-jan-2022 - original PyCaret notebook\n\nhttps:\/\/www.kaggle.com\/carlmcbrideellis\/gdp-20152019-finland-norway-and-sweden - country specific GDP deflator\n\nhttps:\/\/www.kaggle.com\/ambrosm\/tpsjan22-06-lightgbm-quickstart - features to capture movable holidays\n\nHope you find it useful!","f2628b3e":"### Blend and finalize","6d06f81a":"### Interpret the model","0e9900cd":"# Feature Engeneering\n### GDP Deflator","6d86151d":"### Date processing","6a086bd6":"# Submission","6d9c7c29":"# Modelling\n### Fit CatBoost model\n\nMany other models are available and can be compared with the compare_models functions"}}