{"cell_type":{"fb924770":"code","29a589cb":"code","173ddba9":"code","54e6844d":"code","59883b7d":"code","3388d2a0":"code","5a57c04e":"code","18a7f785":"code","ba6f5b39":"code","c9e2d80b":"code","aae69a9c":"code","31482026":"code","c887d2cb":"code","5c7fbc5d":"code","db04f272":"code","5a704ebc":"code","a9013cc9":"code","34ab6367":"code","bf0fc6e7":"code","03b79d0b":"code","7ecbd236":"markdown","34922723":"markdown","42759210":"markdown","12d2f260":"markdown","3974461a":"markdown","f5017de6":"markdown","bec88322":"markdown"},"source":{"fb924770":"import numpy as np \nimport pandas as pd \nimport os\nimport warnings \nwarnings.filterwarnings('ignore')       \nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom itertools import combinations\nfrom scipy.sparse import hstack, csr_matrix\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\nPATH_TO_DATA = '..\/input\/mlcourse-dota2-win-prediction\/'\nSEED = 17","29a589cb":"# Train dataset\ndf_train_features = pd.read_csv(os.path.join(PATH_TO_DATA, 'train_features.csv'), \n                                    index_col='match_id_hash')\ndf_train_targets = pd.read_csv(os.path.join(PATH_TO_DATA, 'train_targets.csv'), \n                                   index_col='match_id_hash')\n\ny_train = df_train_targets['radiant_win'].map({True: 1, False: 0})\ny_train.reset_index(drop=True,inplace=True)\n# Test dataset\ndf_test_features = pd.read_csv(os.path.join(PATH_TO_DATA, 'test_features.csv'), \n                                   index_col='match_id_hash')\n","173ddba9":"# from https:\/\/www.kaggle.com\/kuzand kernel\ndef bag_of_heroes(df, N=1, r_val=1, d_val=-1, r_d_val=0, return_as='csr'):\n    '''\n    Bag of Heroes. Returns a csr matrix (+ list of feature names) or dataframe where each column represents\n    a hero (ID) and each row represents a match.\n    \n    The value of a cell (i, j) in the returned matrix is:\n        cell[i, j] = 0, if the hero or combination of heroes of the j-th column is not present in the i-th match\n        cell[i, j] = r_val, if the hero (N = 1) or combination of heroes (N > 1, synergy) of the j-th column is within the Radiant team,\n        cell[i, j] = d_val, if the hero (N = 1) or combination of heroes (N > 1, synergy) of the j-th column is within the Dire team,\n        cell[i, j] = r_d_val, if the combination of heroes of the j-th column is between the Radiant and Dire teams (N>1, anti-synergy).\n    \n    Parameters:\n    -----------\n        df: dataframe with hero IDs, with columns ['r1_hero_id', ..., 'r5_hero_id', 'd1_hero_id', ..., 'd5_hero_id']\n        N: integer 1 <= N <= 10, for N heroes combinations\n        return_as: 'csr' for scipy csr sparse matrix, 'df' for pandas dataframe\n    '''\n    if N < 1 or N > df.shape[1]:\n        raise Exception(f'The number N of hero-combinations should be 1 <= N <= {df.shape[1]}')\n        \n    # Convert the integer IDs to strings of the form id{x}{x}{x}\n    df = df.astype(str).applymap(lambda x: 'id' + '0'*(3 - len(x)) + x)\n    \n    # Create a list of all hero IDs present in df\n    hero_ids = np.unique(df).tolist()\n\n    # Break df into teams Radiant (r) and Dire (d)\n    df_r = df[[col for col in df.columns if col[0] == 'r']]\n    df_d = df[[col for col in df.columns if col[0] == 'd']]\n    \n    # Create a list of all the hero IDs in df, df_r and df_d respectively\n    f = lambda x: ' '.join(['_'.join(c) for c in combinations(sorted(x), N)])\n    \n    df_list = df.apply(f, axis=1).tolist()\n    df_list.append(' '.join(['_'.join(c) for c in combinations(hero_ids, N)]))\n\n    df_r_list = df_r.apply(f, axis=1).tolist()\n    df_r_list.append(' '.join(['_'.join(c) for c in combinations(hero_ids, N)]))\n    \n    df_d_list = df_d.apply(f, axis=1).tolist()\n    df_d_list.append(' '.join(['_'.join(c) for c in combinations(hero_ids, N)]))\n    \n    # Create countvectorizers\n    vectorizer = CountVectorizer()\n    vectorizer_r = CountVectorizer()\n    vectorizer_d = CountVectorizer()\n    \n    X = vectorizer.fit_transform(df_list)[:-1]\n    X_r = vectorizer_r.fit_transform(df_r_list)[:-1]\n    X_d = vectorizer_d.fit_transform(df_d_list)[:-1]\n    X_r_d = (X - (X_r + X_d))  \n    X = (r_val * X_r + d_val * X_d + r_d_val * X_r_d)\n    \n    feature_names = vectorizer.get_feature_names()\n    \n    if return_as == 'csr':\n        return X, feature_names\n    elif return_as == 'df':\n        return pd.DataFrame(X.toarray(), columns=feature_names, index=df.index).to_sparse(0)","54e6844d":"train_boh = df_train_features.copy()\ntest_boh = df_test_features.copy()\n\ndf_full_features = pd.concat([train_boh, test_boh])\n\n# Index to split the training and test data sets\nidx_split = train_boh.shape[0]\n\nheroes_df = df_full_features[[f'{t}{i}_hero_id' for t in ['r', 'd'] for i in range(1, 6)]]","59883b7d":"%%time\nboh = bag_of_heroes(heroes_df, N=1, r_val=1, d_val=-1, return_as='csr')[0]\n\nX_heroes_train = boh[:idx_split]\nX_heroes_test  = boh[idx_split:]","3388d2a0":"def win_rates(X_heroes_train, X_heroes_test,target):\n    # Creating 115 columns of heroes, there '1' - Radiant hero,'-1' - Dire hero \n    X_heroes_train = pd.DataFrame(X_heroes_train.toarray(),\n            columns=['f'+str(i) for i in range(X_heroes_train.shape[1])])\n\n    X_heroes_test = pd.DataFrame(X_heroes_test.toarray(),\n            columns=['f'+str(i) for i in range(X_heroes_test.shape[1])])\n\n    heroes_target = target.reset_index(drop=True)\n\n\n    # count win_prob for every hero ((win as d + win as r)\/ all played games by this hero )\n    X_heroes_train['radiant_win'] = heroes_target['radiant_win']\n\n    \n    hero_win_dict = dict()\n    for i in range(0,115): # 115 Heroes\n        hero_name = 'f'+str(i)\n\n        wins_by_dire = X_heroes_train.radiant_win[(X_heroes_train['f'+str(i)]==-1) \n                                        & (X_heroes_train['radiant_win']==0) ].value_counts().get_values()\n        wins_by_radiant = X_heroes_train.radiant_win[(X_heroes_train['f'+str(i)]==1) \n                                        & (X_heroes_train['radiant_win']==1) ].value_counts().get_values()\n        total_games_by_hero = X_heroes_train.radiant_win[(X_heroes_train['f'+str(i)]==1) \n                                        | (X_heroes_train['f'+str(i)]==-1) ].value_counts().get_values().sum()\n        hero_win_prob = (wins_by_dire+wins_by_radiant)\/total_games_by_hero\n        hero_win_dict[hero_name] = hero_win_prob # {hero: hero_winrate}\n\n    # drop radinat_win\n    X_heroes_train.drop(columns=['radiant_win'],inplace=True)\n    \n    # Now let's count winrate for each team for every game.\n    \n    # train\n    r_win_prob = list()\n    d_win_prob = list()\n    radiant_match_winrate = 0\n    dire_match_winrate = 0\n    for x in range(0,X_heroes_train.shape[0]):\n        radiant_match_winrate=0\n        dire_match_winrate=0\n        r_5_winrates = np.argwhere(X_heroes_train.loc[x].to_numpy()>0).flatten() \n        d_5_winrates = np.argwhere(X_heroes_train.loc[x].to_numpy()<0).flatten()  \n        for x in r_5_winrates:\n            radiant_match_winrate+=float(hero_win_dict['f'+str(x)])\n        for y in d_5_winrates:\n            dire_match_winrate+=float(hero_win_dict['f'+str(y)])\n\n        r_win_prob.append(radiant_match_winrate\/5)\n        d_win_prob.append(dire_match_winrate\/5)\n\n    # test\n    r_win_prob_test = list()\n    d_win_prob_test = list()\n    radiant_match_winrate = 0\n    dire_match_winrate = 0\n    for x in range(0,X_heroes_test.shape[0]):\n        radiant_match_winrate = 0\n        dire_match_winrate = 0\n        r_5_winrates = np.argwhere(X_heroes_test.loc[x].to_numpy()>0).flatten()  \n        d_5_winrates = np.argwhere(X_heroes_test.loc[x].to_numpy()<0).flatten()  \n        for x in r_5_winrates:\n            radiant_match_winrate += float(hero_win_dict['f'+str(x)])\n        for y in d_5_winrates:\n            dire_match_winrate += float(hero_win_dict['f'+str(y)])\n\n        r_win_prob_test.append(radiant_match_winrate\/5)\n        d_win_prob_test.append(dire_match_winrate\/5)\n\n    # features\n    X_heroes_train['r_win_prob'] = pd.Series(r_win_prob, index=X_heroes_train.index)\n    X_heroes_train['d_win_prob'] = pd.Series(d_win_prob, index=X_heroes_train.index)\n\n    X_heroes_test['r_win_prob'] = pd.Series(r_win_prob_test, index=X_heroes_test.index)\n    X_heroes_test['d_win_prob'] = pd.Series(d_win_prob_test, index=X_heroes_test.index)\n\n    X_heroes_train['win_prob'] = X_heroes_train['r_win_prob'] - X_heroes_train['d_win_prob']\n    X_heroes_test['win_prob'] = X_heroes_test['r_win_prob'] - X_heroes_test['d_win_prob']\n    return X_heroes_train, X_heroes_test","5a57c04e":"%%time\nX_heroes_train, X_heroes_test = win_rates(X_heroes_train, X_heroes_test,df_train_targets)","18a7f785":"X_heroes_train.head()","ba6f5b39":"X_heroes_test.head()","c9e2d80b":"X_heroes_train.to_csv('bag_of_heroes_and_win_prob_train.csv',index=False)\nX_heroes_test.to_csv('bag_of_heroes_and_win_prob_test.csv',index=False)","aae69a9c":"train_visual = X_heroes_train[['r_win_prob','d_win_prob','win_prob']].copy()\ntrain_visual['radiant_win'] = y_train.reset_index(drop=True)","31482026":"plt.hist(train_visual.loc[train_visual.radiant_win==1, 'r_win_prob'].values, bins=16, density=True, alpha=0.4,color='green',label='Radiant');\nplt.hist(train_visual.loc[train_visual.radiant_win==0, 'r_win_prob'].values, bins=16, density=True, alpha=0.4,color='red',label='Dire');\nplt.legend()\nplt.title('Distribution of wins by r_win_prob');","c887d2cb":"plt.hist(train_visual.loc[train_visual.radiant_win==1, 'win_prob'].values, bins=16,  density=True, alpha=0.4,color='green', label='Radiant');\nplt.hist(train_visual.loc[train_visual.radiant_win==0, 'win_prob'].values, bins=16, density=True, alpha=0.4,color='red', label='Dire');\nplt.legend()\nplt.title('Distribution of wins by win_prob');","5c7fbc5d":"X_heroes_train_flip = X_heroes_train.copy()","db04f272":"def train_boh_flip(X_heroes_train_flip, X_heroes_train):\n    players = [f'f{i}' for i in range(0, 115)] # r1, r2...\n    for player in players:\n        X_heroes_train_flip[player] = X_heroes_train[player].map({1: -1, -1: 1, 0:0})\n    return X_heroes_train_flip","5a704ebc":"X_heroes_train_flip = train_boh_flip(X_heroes_train_flip, X_heroes_train)","a9013cc9":"def rd_hero_win(X_heroes_train_flip,X_heroes_train):\n    X_heroes_train_flip['r_win_prob'] = X_heroes_train['d_win_prob']\n    X_heroes_train_flip['d_win_prob'] = X_heroes_train['r_win_prob']\n    X_heroes_train_flip['win_prob'] = X_heroes_train_flip['r_win_prob'] - X_heroes_train_flip['d_win_prob']\n    return X_heroes_train_flip","34ab6367":"X_heroes_train_flip = rd_hero_win(X_heroes_train_flip,X_heroes_train)","bf0fc6e7":"X_heroes_train_flip.index = np.arange(39675, 39675 + len(X_heroes_train_flip))\nX_heroes_train_flip.to_csv('bag_of_heroes_and_win_prob_train_flip.csv',index=False)","03b79d0b":"X_heroes_train_flip.head()","7ecbd236":"## We can plot the histograms to see that these features give good seperation of the target.","34922723":"# Now let's make win probability for each team for every game","42759210":"# BONUS. If you are trying to make inverted train...","12d2f260":"# P.S. \n## 'r_win_prob', 'd_win_prob', 'win_prob' are three of the most important (top 5) features in my LGB model (0.85887 On LB) ","3974461a":"# OHE heroes. 1 is Radiant, -1 is Dire\n##### First we need to one-hot-encode the heroes.","f5017de6":"# In this kernel I show you how to make heroes winrates.\n### It's based on [Bag of Heroes + Logistic Regression](https:\/\/www.kaggle.com\/kuzand\/bag-of-heroes-logistic-regression).\n\n### The main idea: \n- heroes have same winrate on dire and radiant side. \n- Every hero has his own winrate.\n- If one team has five 47%-WinRate heroes and the other team has 54%-WinRate heroes, the second one should win almost all games.  \n","bec88322":"### P.P.S. \n#### You can try to do winrates not only with heroes..."}}