{"cell_type":{"c70014e9":"code","6782dc0a":"code","ccb446fe":"code","572c3a68":"code","3c5a96ea":"code","6d6ba113":"code","ed2c5c13":"code","9afd7ba1":"code","dc536a97":"code","81630f9f":"code","5d28cab0":"code","ea92d2a7":"code","a438eb96":"code","42a0824c":"code","9b8db07a":"code","ba9d0515":"code","2d7d508f":"code","f24fa39f":"code","f2658f0d":"code","3a4cb481":"code","91c5d809":"code","584ab3a3":"code","44f6bc37":"code","96f8fe69":"code","e56c3bb8":"code","b494e3ee":"code","5aa7ba98":"code","96c4c1c8":"code","b476cd21":"code","a4810754":"code","fc1c508e":"code","85de1a90":"markdown","a6177351":"markdown","76eaab1f":"markdown","8b40c94f":"markdown","49780af6":"markdown","850c63bb":"markdown","97191caf":"markdown","d6ca6ddf":"markdown","66b8b3b4":"markdown","c2573e31":"markdown","8a7738a3":"markdown","63785737":"markdown","de52be8e":"markdown","f6b4d98a":"markdown","96c53b07":"markdown","c254fc98":"markdown","7ac47058":"markdown","c1a3b91a":"markdown","ca2c5949":"markdown","6f5316da":"markdown","b42fe02a":"markdown","43ab8807":"markdown","f3c6ba4f":"markdown","b69566cc":"markdown","91beba1c":"markdown","d8697d84":"markdown","52bdf710":"markdown","3c590353":"markdown","76f9c9ff":"markdown","e62ba43d":"markdown"},"source":{"c70014e9":"import numpy as np\nimport pandas as pd\nimport scipy.special\nimport matplotlib.pyplot as plt\nimport os\nimport random\n\nfrom sklearn.model_selection import train_test_split, GridSearchCV\nfrom sklearn.preprocessing import LabelEncoder, MinMaxScaler\nfrom sklearn.metrics import accuracy_score\nfrom xgboost import XGBClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.metrics import confusion_matrix\nfrom mlxtend.plotting import plot_confusion_matrix\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","6782dc0a":"def plot_bar_survivor(data, feature, rot=False):\n    \"\"\" Compare the distribution between survived and nor survived \"\"\"\n    \n    df_not_survived = data[data['Survived']==0]\n    df_survived = data[data['Survived']==1]\n    \n    survived_label = df_survived[feature].value_counts().sort_index()\n    dict_survived = dict(zip(survived_label.keys(), ((100*(survived_label)\/len(df_survived.index)).tolist())))\n    survived_names = list(dict_survived.keys())\n    survived_values = list(dict_survived.values())\n    \n    not_survived_label = df_not_survived[feature].value_counts().sort_index()\n    dict_not_survived = dict(zip(not_survived_label.keys(), ((100*(not_survived_label)\/len(df_not_survived.index)).tolist())))\n    not_survived_names = list(dict_not_survived.keys())\n    not_survived_values = list(dict_not_survived.values())\n    \n    fig, axs = plt.subplots(1, 2, figsize=(9, 3), sharey=True)\n    \n    axs[0].bar(survived_names, survived_values, color='yellowgreen')\n    axs[1].bar(not_survived_names, not_survived_values, color='sandybrown')\n    axs[0].grid()\n    axs[1].grid()\n    axs[0].set_title('Survived')\n    axs[1].set_title('Not Survived')\n    axs[0].set_ylabel('%')\n    if(rot==True):\n        axs[0].set_xticklabels(survived_names, rotation=45)\n        axs[1].set_xticklabels(not_survived_names, rotation=45)\n    plt.show()\n    \ndef plot_bar_compare(train, test, name, rot=False):\n    \"\"\" Compare the distribution between train and test data \"\"\"\n    \n    fig, axs = plt.subplots(1, 2, figsize=(9, 3), sharey=True)\n    \n    train_label = train[name].value_counts().sort_index()\n    dict_train = dict(zip(train_label.keys(), ((100*(train_label)\/len(train.index)).tolist())))\n    train_names = list(dict_train.keys())\n    train_values = list(dict_train.values())\n    \n    test_label = test[name].value_counts().sort_index()\n    dict_test = dict(zip(test_label.keys(), ((100*(test_label)\/len(test.index)).tolist())))\n    test_names = list(dict_test.keys())\n    test_values = list(dict_test.values())\n    \n    axs[0].bar(train_names, train_values, color='yellowgreen')\n    axs[1].bar(test_names, test_values, color='sandybrown')\n    axs[0].grid()\n    axs[1].grid()\n    axs[0].set_title('Train data')\n    axs[1].set_title('Test data')\n    axs[0].set_ylabel('%')\n    if(rot==True):\n        axs[0].set_xticklabels(train_names, rotation=45)\n        axs[1].set_xticklabels(test_names, rotation=45)\n    plt.show()","ccb446fe":"path = '\/kaggle\/input\/tabular-playground-series-apr-2021\/'\nos.listdir(path)","572c3a68":"train_data = pd.read_csv(path+'train.csv')\ntest_data = pd.read_csv(path+'test.csv')\nsamp_subm = pd.read_csv(path+'sample_submission.csv')","3c5a96ea":"print('Number train samples:', len(train_data.index))\nprint('Number test samples:', len(test_data.index))","6d6ba113":"train_data.head()","ed2c5c13":"train_data.isnull().sum()","9afd7ba1":"cols_with_missing_train = [col for col in train_data.columns if train_data[col].isnull().any()]\ncols_with_missing_test = [col for col in test_data.columns if test_data[col].isnull().any()]","dc536a97":"print('train columns with missing data:', cols_with_missing_train)\nprint('test columns with missing data:', cols_with_missing_test)","81630f9f":"age_mean = int(train_data[train_data['Age'].notnull()]['Age'].mean())\nage_std = int(train_data[train_data['Age'].notnull()]['Age'].std())\nage_mean, age_std","5d28cab0":"def fill_age(s):\n    if np.isnan(s) == False:\n        return s\n    else:\n        return random.randrange(age_mean-age_std, age_mean+age_std)","ea92d2a7":"train_data['Age'] = train_data['Age'].apply(fill_age)\ntest_data['Age'] = test_data['Age'].apply(fill_age)","a438eb96":"train_data['Cabin'] = train_data['Cabin'].fillna('Unknown', inplace=False)\ntest_data['Cabin'] = test_data['Cabin'].fillna('Unknown', inplace=False)","42a0824c":"train_data['Embarked'] = train_data['Embarked'].fillna('Unknown', inplace=False)\ntest_data['Embarked'] = test_data['Embarked'].fillna('Unknown', inplace=False)","9b8db07a":"mean = train_data['Fare'].mean()\ntrain_data['Fare'] = train_data['Fare'].fillna(mean, inplace=False)\ntest_data['Fare'] = test_data['Fare'].fillna(mean, inplace=False)","ba9d0515":"plot_bar_survivor(train_data, 'Age')","2d7d508f":"plot_bar_survivor(train_data, 'Sex')","f24fa39f":"plot_bar_survivor(train_data, 'Fare')","f2658f0d":"plot_bar_survivor(train_data, 'SibSp')","3a4cb481":"train_data['Cabin'] = train_data['Cabin'].str[0]\ntest_data['Cabin'] = test_data['Cabin'].str[0]","91c5d809":"features_cat = ['Sex', 'Cabin', 'Embarked']\nle = LabelEncoder()\nfor col in features_cat:\n    le.fit(train_data[col])\n    train_data[col] = le.transform(train_data[col])\n    test_data[col] = le.transform(test_data[col])","584ab3a3":"corr = train_data.corr()\ncorr.style.background_gradient(cmap='coolwarm', axis=None).set_precision(2)","44f6bc37":"no_features = ['Survived', 'Name', 'Ticket', 'PassengerId']","96f8fe69":"X_train = train_data[train_data.columns.difference(no_features)].copy(deep=False)\ny_train = train_data['Survived']\nX_test = test_data[test_data.columns.difference(no_features)].copy(deep=False)","e56c3bb8":"min_max = MinMaxScaler()\nX_train_scaled = min_max.fit_transform(X_train)\nX_test_scaled = min_max.transform(X_test)","b494e3ee":"model = XGBClassifier()\nmodel.fit(X_train_scaled, y_train)","5aa7ba98":"importance = model.feature_importances_\nfig = plt.figure(figsize=(10, 6))\nx = X_train.columns.values\nplt.barh(x, 100*importance)\nplt.title('Feature Importance', loc='left')\nplt.xlabel('Percentage')\nplt.grid()\nplt.show()","96c4c1c8":"y_train_pred = model.predict(X_train_scaled)\nconf_mat = confusion_matrix(y_train, y_train_pred)\n\nfig, ax = plot_confusion_matrix(conf_mat=conf_mat,\n                                show_normed=True,\n                                show_absolute=False,\n                                figsize=(6, 6))\nfig.show()","b476cd21":"y_test = model.predict(X_test_scaled)","a4810754":"output = pd.DataFrame({'PassengerId': samp_subm['PassengerId'],\n                       'Survived': y_test})\noutput.to_csv('submission.csv', index=False)","fc1c508e":"output['Survived'].value_counts()","85de1a90":"# Handle Missing Values","a6177351":"# Encode Data","76eaab1f":"# Define Model","8b40c94f":"# Scale Data","49780af6":"## Feature Cabin","850c63bb":"# Overview","97191caf":"# Exploratory Data Analysis","d6ca6ddf":"# Select Features","66b8b3b4":"# Export Results","c2573e31":"Age:","8a7738a3":"# Correlation Matrix","63785737":"Categorical Features","de52be8e":"# Functions\nWe define some helper functions for visualizations.","f6b4d98a":"Fare","96c53b07":"Feature Importance","c254fc98":"# Feature Engineering","7ac47058":"## Feature Age","c1a3b91a":"# Load Data","ca2c5949":"## Feature Embarked","6f5316da":"Confusion Matrix Of The Test Data:","b42fe02a":"## Feature Fare","43ab8807":"# Intro\nWelcome to the [Tabular Playground Series - Apr 2021](https:\/\/www.kaggle.com\/c\/tabular-playground-series-apr-2021) competition.\n\n![](https:\/\/storage.googleapis.com\/kaggle-competitions\/kaggle\/26478\/logos\/header.png)\n\n<span style=\"color: royalblue;\">Please vote the notebook up if it helps you. Feel free to leave a comment above the notebook. Thank you. <\/span>","f3c6ba4f":"SibSP","b69566cc":"Sex","91beba1c":"# Define Train And Test Data","d8697d84":"# Analyse Results","52bdf710":"# Libraries","3c590353":"# Predict Test Data","76f9c9ff":"# Path","e62ba43d":"Columns with missing data:"}}