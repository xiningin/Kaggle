{"cell_type":{"51216e6e":"code","bb23b126":"code","0e5d2b57":"code","16b470d1":"code","83929a3a":"code","e91adc46":"code","7cb67361":"code","59d8bd3b":"code","de8ca8fd":"code","d23214e3":"code","af400b78":"code","daaae210":"code","5f37b823":"code","ebcc6f8d":"markdown","20dd361f":"markdown","cc9ec262":"markdown"},"source":{"51216e6e":"import numpy as np\nimport pandas as pd\nfrom numba import njit\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp","bb23b126":"def get_penalty(n, choice):\n    penalty = None\n    if choice == 0:\n        penalty = 0\n    elif choice == 1:\n        penalty = 50\n    elif choice == 2:\n        penalty = 50 + 9 * n\n    elif choice == 3:\n        penalty = 100 + 9 * n\n    elif choice == 4:\n        penalty = 200 + 9 * n\n    elif choice == 5:\n        penalty = 200 + 18 * n\n    elif choice == 6:\n        penalty = 300 + 18 * n\n    elif choice == 7:\n        penalty = 300 + 36 * n\n    elif choice == 8:\n        penalty = 400 + 36 * n\n    elif choice == 9:\n        penalty = 500 + 36 * n + 199 * n\n    else:\n        penalty = 500 + 36 * n + 398 * n\n    return penalty\n\n\ndef GetPreferenceCostMatrix(data):\n    cost_matrix = np.zeros((N_FAMILIES, N_DAYS), dtype=np.int64)\n    for i in range(N_FAMILIES):\n        desired = data.values[i, :-1]\n        cost_matrix[i, :] = get_penalty(FAMILY_SIZE[i], 10)\n        for j, day in enumerate(desired):\n            cost_matrix[i, day-1] = get_penalty(FAMILY_SIZE[i], j)\n    return cost_matrix\n\n\ndef GetAccountingCostMatrix():\n    ac = np.zeros((500, 500, 6), dtype=np.float64)\n    for n in range(ac.shape[0]):\n        for n_p1 in range(ac.shape[1]):\n            for j in range(1, 6):\n                diff = abs(n - n_p1)\n                ac[n, n_p1, j] = max(0, (n - 125) \/ 400 * (n**(0.5 + diff \/ 50.0))\/j**2)\n    return ac\n\n\n# preference cost\n@njit(fastmath=True)\ndef pcost(prediction):\n    daily_occupancy = np.zeros(N_DAYS, dtype=np.int64)\n    penalty = 0\n    for (i, p) in enumerate(prediction):\n        n = FAMILY_SIZE[i]\n        penalty += PCOSTM[i, p]\n        daily_occupancy[p] += n\n    return penalty, daily_occupancy\n\n\n# accounting cost\n@njit(fastmath=True)\ndef acost(daily_occupancy):\n    do = np.zeros(N_DAYS+5, dtype=np.int64)\n    do[:N_DAYS] = daily_occupancy\n    do[N_DAYS:] = do[N_DAYS-1]\n    accounting_cost = 0\n    n_out_of_range = 0\n    for day in range(N_DAYS):\n        for j in range(1, 6):\n            n_pj = do[day + j]\n            n    = do[day]\n            n_out_of_range += (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n            accounting_cost += ACOSTM[n, n_pj, j]\n    return accounting_cost, n_out_of_range\n\n\n@njit(fastmath=True)\ndef cost_function(prediction):\n    penalty, daily_occupancy = pcost(prediction)\n    accounting_cost, n_out_of_range = acost(daily_occupancy)\n    return penalty + accounting_cost + n_out_of_range*100000000","0e5d2b57":"# swappers\n\ndef findBetterDay4Family(pred):\n    fobs = np.argsort(FAMILY_SIZE)\n    score = cost_function(pred)\n    original_score = np.inf\n    \n    while original_score>score:\n        original_score = score\n        for family_id in fobs:\n            for pick in range(10):\n                day = DESIRED[family_id, pick]\n                oldvalue = pred[family_id]\n                pred[family_id] = day\n                new_score = cost_function(pred)\n                if new_score<score:\n                    score = new_score\n                else:\n                    pred[family_id] = oldvalue\n\n        print(score, end='\\r')\n    print(score)\n    \n\ndef stochastic_product_search(top_k, fam_size, original, \n                              verbose=1000, verbose2=50000,\n                              n_iter=500, random_state=2019):\n    \"\"\"\n    original (np.array): The original day assignments.\n    \n    At every iterations, randomly sample fam_size families. Then, given their top_k\n    choices, compute the Cartesian product of the families' choices, and compute the\n    score for each of those top_k^fam_size products.\n    \"\"\"\n    \n    best = original.copy()\n    best_score = cost_function(best)\n    \n    np.random.seed(random_state)\n\n    for i in range(n_iter):\n        fam_indices = np.random.choice(range(DESIRED.shape[0]), size=fam_size)\n        changes = np.array(list(product(*DESIRED[fam_indices, :top_k].tolist())))\n\n        for change in changes:\n            new = best.copy()\n            new[fam_indices] = change\n\n            new_score = cost_function(new)\n\n            if new_score < best_score:\n                best_score = new_score\n                best = new\n                \n        if verbose and i % verbose == 0:\n            print(f\"Iteration #{i}: Best score is {best_score:.2f}      \", end='\\r')\n            \n        if verbose2 and i % verbose2 == 0:\n            print(f\"Iteration #{i}: Best score is {best_score:.2f}      \")\n    \n    print(f\"Final best score is {best_score:.2f}\")\n    return best","16b470d1":"def seed_finding(seed, prediction_input):\n    prediction = prediction_input.copy()\n    np.random.seed(seed)\n    best_score = cost_function(prediction)\n    original_score = best_score\n    best_pred = prediction.copy()\n    print(\"SEED: {}   ORIGINAL SCORE: {}\".format(seed, original_score))\n    for t in range(100):\n        for i in range(5000):\n            for j in range(10):\n                di = prediction[i]\n                prediction[i] = DESIRED[i, j]\n                cur_score = cost_function(prediction)\n\n                KT = 1\n                if t < 5:\n                    KT = 1.5\n                elif t < 10:\n                    KT = 4.5\n                else:\n                    if cur_score > best_score + 100:\n                        KT = 3\n                    elif cur_score > best_score + 50 :\n                        KT = 2.75\n                    elif cur_score > best_score + 20:\n                        KT = 2.5\n                    elif cur_score > best_score + 10:\n                        KT = 2\n                    elif cur_score > best_score:\n                        KT = 1.5\n                    else:\n                        KT = 1\n\n                prob = np.exp(-(cur_score - best_score) \/ KT)\n                if np.random.rand() < prob:\n                    best_score = cur_score\n                else:\n                    prediction[i] = di\n        if best_score < original_score:\n            print(\"NEW BEST SCORE on seed {}: {}\".format(seed, best_score))\n            original_score = best_score\n            best_pred = prediction.copy()\n\n    return best_pred","83929a3a":"def solveSantaLP(thrs = 10):\n    \n    S = pywraplp.Solver('SolveAssignmentProblem', pywraplp.Solver.GLOP_LINEAR_PROGRAMMING)\n    \n    #S.SetNumThreads(NumThreads) \n    #S.set_time_limit(limit_in_seconds*1000*NumThreads) #cpu time = wall time * N_threads\n    \n    x = {}\n    candidates = [[] for _ in range(N_DAYS)] #families that can be assigned to each day\n\n    for i in range(N_FAMILIES):\n        for j in DESIRED[i, :]:\n            candidates[j].append(i)\n            x[i, j] = S.BoolVar('x[%i,%i]' % (i, j))\n\n            \n    daily_occupancy = [S.Sum([x[i, j] * FAMILY_SIZE[i] for i in candidates[j]])\n                                                       for j in range(N_DAYS)]\n\n    family_presence = [S.Sum([x[i, j] for j in DESIRED[i, :]])\n                                      for i in range(N_FAMILIES)]\n\n\n\n    # Objective\n    preference_cost = S.Sum([PCOSTM[i, j] * x[i,j] for i in range(N_FAMILIES)\n                                                   for j in DESIRED[i, :] ])\n\n    S.Minimize(preference_cost)\n\n\n\n    # Constraints\n    for j in range(N_DAYS-1):\n        S.Add(daily_occupancy[j]   - daily_occupancy[j+1] <= thrs)\n        S.Add(daily_occupancy[j+1] - daily_occupancy[j]   <= thrs)\n\n    for i in range(N_FAMILIES):\n        S.Add(family_presence[i] == 1)\n\n    for j in range(N_DAYS):\n        S.Add(daily_occupancy[j] >= MIN_OCCUPANCY)\n        S.Add(daily_occupancy[j] <= MAX_OCCUPANCY)\n\n\n\n    res = S.Solve()\n\n    resdict = {0:'OPTIMAL', 1:'FEASIBLE', 2:'INFEASIBLE', 3:'UNBOUNDED', \n               4:'ABNORMAL', 5:'MODEL_INVALID', 6:'NOT_SOLVED'}\n\n    print('LP solver result:', resdict[res])\n\n\n    l = [(i, j, x[i, j].solution_value()) for i in range(N_FAMILIES)\n                                          for j in DESIRED[i, :] \n                                          if x[i, j].solution_value()>0]\n\n    df = pd.DataFrame(l, columns=['family_id', 'day', 'n'])\n    return df","e91adc46":"def solveSantaIP(families, min_occupancy, max_occupancy):\n\n    S = pywraplp.Solver('SolveAssignmentProblem', pywraplp.Solver.CBC_MIXED_INTEGER_PROGRAMMING)\n    \n    #S.SetNumThreads(NumThreads) \n    #S.set_time_limit(limit_in_seconds*1000*NumThreads) #cpu time = wall time * N_threads\n\n    n_families = len(families)\n    \n    x = {}\n    candidates = [[] for _ in range(N_DAYS)] #families that can be assigned to each day\n\n    for i in families:\n        for j in DESIRED[i, :]:\n            candidates[j].append(i)\n            x[i, j] = S.BoolVar('x[%i,%i]' % (i, j))\n\n            \n    daily_occupancy = [S.Sum([x[i, j] * FAMILY_SIZE[i] for i in candidates[j]])\n                                                       for j in range(N_DAYS)]\n\n    family_presence = [S.Sum([x[i, j] for j in DESIRED[i, :]])\n                                      for i in families]\n\n\n\n    # Objective\n    preference_cost = S.Sum([PCOSTM[i, j] * x[i,j] for i in families\n                                                   for j in DESIRED[i, :] ])\n    \n\n    S.Minimize(preference_cost)\n\n\n    # Constraints\n\n    for i in range(n_families):\n        S.Add(family_presence[i] == 1)\n\n    for j in range(N_DAYS):\n        S.Add(daily_occupancy[j] >= min_occupancy[j])\n        S.Add(daily_occupancy[j] <= max_occupancy[j])\n\n    res = S.Solve()\n    \n    resdict = {0:'OPTIMAL', 1:'FEASIBLE', 2:'INFEASIBLE', 3:'UNBOUNDED', \n               4:'ABNORMAL', 5:'MODEL_INVALID', 6:'NOT_SOLVED'}\n    \n    print('MIP solver result:', resdict[res])\n    \n                \n    l = [(i, j) for i in families\n                for j in DESIRED[i, :] \n                if x[i, j].solution_value()>0]\n\n\n    df = pd.DataFrame(l, columns=['family_id', 'day'])\n    return df","7cb67361":"def solveSanta(thrs = 10):\n    df = solveSantaLP(thrs) # Initial solution for most of families\n    \n    THRS = 0.999\n\n    assigned_df   = df[df.n>THRS].copy()\n    unassigned_df = df[(df.n<=THRS)&(df.n>1-THRS)]\n    unassigned = unassigned_df.family_id.unique()\n    print('{} unassigned families'.format(len(unassigned)))\n\n\n    assigned_df['family_size'] = FAMILY_SIZE[assigned_df.family_id]\n    occupancy = assigned_df.groupby('day').family_size.sum().values\n    min_occupancy = np.array([max(0, MIN_OCCUPANCY-o) for o in occupancy])\n    max_occupancy = np.array([MAX_OCCUPANCY - o for o in occupancy])\n\n    \n    rdf = solveSantaIP(unassigned, min_occupancy, max_occupancy) # solve the rest with MIP\n    df = pd.concat((assigned_df[['family_id', 'day']], rdf)).sort_values('family_id')\n    return df.day.values","59d8bd3b":"N_DAYS = 100\nN_FAMILIES = 6000\nMAX_OCCUPANCY = 300\nMIN_OCCUPANCY = 125\n\ndata = pd.read_csv('\/kaggle\/input\/santa-2019-revenge-of-the-accountants\/family_data.csv', index_col='family_id')\n\nFAMILY_SIZE = data.n_people.values\nDESIRED     = data.values[:, :-1] - 1\nPCOSTM = GetPreferenceCostMatrix(data) # Preference cost matrix\nACOSTM = GetAccountingCostMatrix()     # Accounting cost matrix","de8ca8fd":"%%time\nprediction = solveSanta(thrs=9)\npc, occ = pcost(prediction)\nac, _ = acost(occ)\nprint('{}, {:.2f}, ({}, {})'.format(pc, ac, occ.min(), occ.max()))","d23214e3":"new = prediction.copy()\nfindBetterDay4Family(new) ","af400b78":"final = stochastic_product_search(\n        top_k=2,\n        fam_size=8, \n        original=new, \n        n_iter=10000,\n        verbose=1000,\n        verbose2=50000,\n        random_state=2019\n        )","daaae210":"final = seed_finding(2019, final)","5f37b823":"sub = pd.DataFrame(range(N_FAMILIES), columns=['family_id'])\nsub['assigned_day'] = final+1\nsub.to_csv('submission.csv', index=False)","ebcc6f8d":"# References\n\n- https:\/\/www.kaggle.com\/vipito\/santa-ip\n- https:\/\/www.kaggle.com\/inversion\/santa-s-2019-starter-notebook\n- https:\/\/www.kaggle.com\/sekrier\/fast-scoring-using-c-52-usec\n- https:\/\/www.kaggle.com\/nickel\/250x-faster-cost-function-with-numba-jit\n- https:\/\/www.kaggle.com\/ilu000\/greedy-dual-and-tripple-shuffle-with-fast-scoring\n- https:\/\/www.kaggle.com\/xhlulu\/santa-s-2019-stochastic-product-search\n- https:\/\/www.kaggle.com\/hengzheng\/santa-s-seed-seeker","20dd361f":"# Mixed-integer programming Solver","cc9ec262":"# Linear programing Solver"}}