{"cell_type":{"024eb73a":"code","58d3edc0":"code","1e20672b":"code","e7a61aca":"code","1cef888c":"markdown","ee806277":"markdown","1f8c7489":"markdown"},"source":{"024eb73a":"import json\nfrom pathlib import Path\nfrom PIL import Image as PILImage\nimport IPython\nimport numpy as np\nfrom math import trunc\nimport base64\nfrom io import BytesIO","58d3edc0":"class CocoDataset():\n    def __init__(self, annotation_path, image_dir):\n        self.annotation_path = annotation_path\n        self.image_dir = image_dir\n        \n        # Customize these segmentation colors if you like, if there are more segmentations\n        # than colors in an image, the remaining segmentations will default to white\n        self.colors = ['red', 'green', 'blue', 'yellow']\n        \n        json_file = open(self.annotation_path)\n        self.coco = json.load(json_file)\n        json_file.close()\n        \n        self._process_info()\n        self._process_licenses()\n        self._process_categories()\n        self._process_images()\n        self._process_segmentations()\n    \n    def _process_info(self):\n        self.info = self.coco['info']\n        \n    def _process_licenses(self):\n        self.licenses = self.coco['licenses']\n        \n    def _process_categories(self):\n        self.categories = dict()\n        self.super_categories = dict()\n        \n        for category in self.coco['categories']:\n            cat_id = category['id']\n            super_category = category['supercategory']\n            \n            # Add category to categories dict\n            if cat_id not in self.categories:\n                self.categories[cat_id] = category\n            else:\n                print(f'ERROR: Skipping duplicate category id: {category}')\n            \n            # Add category id to the super_categories dict\n            if super_category not in self.super_categories:\n                self.super_categories[super_category] = {cat_id}\n            else:\n                self.super_categories[super_category] |= {cat_id} # e.g. {1, 2, 3} |= {4} => {1, 2, 3, 4}\n\n    def _process_images(self):\n        self.images = dict()\n        for image in self.coco['images']:\n            image_id = image['id']\n            if image_id not in self.images:\n                self.images[image_id] = image\n            else:\n                print(f'ERROR: Skipping duplicate image id: {image}')\n                \n    def _process_segmentations(self):\n        self.segmentations = dict()\n        for segmentation in self.coco['annotations']:\n            image_id = segmentation['image_id']\n            if image_id not in self.segmentations:\n                self.segmentations[image_id] = []\n            self.segmentations[image_id].append(segmentation)\n        \n    def display_info(self):\n        print('Dataset Info')\n        print('==================')\n        for key, item in self.info.items():\n            print(f'  {key}: {item}')\n            \n    def display_licenses(self):\n        print('Licenses')\n        print('==================')\n        for license in self.licenses:\n            for key, item in license.items():\n                print(f'  {key}: {item}')\n                \n    def display_categories(self):\n        print('Categories')\n        print('==================')\n        for sc_name, set_of_cat_ids in self.super_categories.items():\n            print(f'  super_category: {sc_name}')\n            for cat_id in set_of_cat_ids:\n                print(f'    id {cat_id}: {self.categories[cat_id][\"name\"]}'\n                     )\n                \n            print('')\n            \n    def display_image(self, image_id, show_bbox=True, show_polys=True, show_crowds=True):\n        print('Image')\n        print('==================')\n        \n        # Print image info\n        image = self.images[image_id]\n        for key, val in image.items():\n            print(f'  {key}: {val}')\n            \n        # Open the image\n        image_path = Path(self.image_dir) \/ image['file_name']\n        image = PILImage.open(image_path)\n        \n        buffer = BytesIO()\n        image.save(buffer, format='PNG')\n        buffer.seek(0)\n        \n        data_uri = base64.b64encode(buffer.read()).decode('ascii')\n        image_path = \"data:image\/png;base64,{0}\".format(data_uri)\n        \n        # Calculate the size and adjusted display size\n        max_width = 600\n        image_width, image_height = image.size\n        adjusted_width = min(image_width, max_width)\n        adjusted_ratio = adjusted_width \/ image_width\n        adjusted_height = adjusted_ratio * image_height\n        \n        # Create bounding boxes and polygons\n        bboxes = dict()\n        polygons = dict()\n        rle_regions = dict()\n        seg_colors = dict()\n        \n        for i, seg in enumerate(self.segmentations[image_id]):\n            if i < len(self.colors):\n                seg_colors[seg['id']] = self.colors[i]\n            else:\n                seg_colors[seg['id']] = 'white'\n                \n            print(f'  {seg_colors[seg[\"id\"]]}: {self.categories[seg[\"category_id\"]][\"name\"]}')\n            \n            bboxes[seg['id']] = np.multiply(seg['bbox'], adjusted_ratio).astype(int)\n            \n            if seg['iscrowd'] == 0:\n                polygons[seg['id']] = []\n                for seg_points in seg['segmentation']:\n                    seg_points = np.multiply(seg_points, adjusted_ratio).astype(int)\n                    polygons[seg['id']].append(str(seg_points).lstrip('[').rstrip(']'))\n            else:\n                # Decode the RLE\n                px = 0\n                rle_list = []\n                for j, counts in enumerate(seg['segmentation']['counts']):\n                    if counts < 0:\n                        print(f'ERROR: One of the counts was negative, treating as 0: {counts}')\n                        counts = 0\n                    \n                    if j % 2 == 0:\n                        # Empty pixels\n                        px += counts\n                    else:\n                        # Create one or more vertical rectangles\n                        x1 = trunc(px \/ image_height)\n                        y1 = px % image_height\n                        px += counts\n                        x2 = trunc(px \/ image_height)\n                        y2 = px % image_height\n                        \n                        if x2 == x1: # One vertical column\n                            line = [x1, y1, 1, (y2 - y1)]\n                            line = np.multiply(line, adjusted_ratio)\n                            rle_list.append(line)\n                        else: # Two or more columns\n                            # Insert left-most line first\n                            left_line = [x1, y1, 1, (image_height - y1)]\n                            left_line = np.multiply(left_line, adjusted_ratio)\n                            rle_list.append(left_line)\n                            \n                            # Insert middle lines (if needed)\n                            lines_spanned = x2 - x1 + 1\n                            if lines_spanned > 2: # Two columns won't have a middle\n                                middle_lines = [(x1 + 1), 0, lines_spanned - 2, image_height]\n                                middle_lines = np.multiply(middle_lines, adjusted_ratio)\n                                rle_list.append(middle_lines)\n                                \n                            # Insert right-most line\n                            right_line = [x2, 0, 1, y2]\n                            right_line = np.multiply(right_line, adjusted_ratio)\n                            rle_list.append(right_line)\n                            \n                if len(rle_list) > 0:\n                    rle_regions[seg['id']] = rle_list\n                                \n                            \n        \n        # Draw the image\n        html = '<div class=\"container\" style=\"position:relative;\">'\n        html += f'<img src=\"{str(image_path)}\" style=\"position:relative; top:0px; left:0px; width:{adjusted_width}px;\">'\n        html += '<div class=\"svgclass\">'\n        html += f'<svg width=\"{adjusted_width}\" height=\"{adjusted_height}\">'\n        \n        # Draw shapes on image\n        if show_polys:\n            for seg_id, points_list in polygons.items():\n                for points in points_list:\n                    html += f'<polygon points=\"{points}\" \\\n                        style=\"fill:{seg_colors[seg_id]}; stroke:{seg_colors[seg_id]}; fill-opacity:0.5; stroke-width:1;\" \/>'\n        \n        if show_crowds:\n            for seg_id, line_list in rle_regions.items():\n                for line in line_list:\n                    html += f'<rect x=\"{line[0]}\" y=\"{line[1]}\" width=\"{line[2]}\" height=\"{line[3]}\" \\\n                        style=\"fill:{seg_colors[seg_id]}; stroke:{seg_colors[seg_id]}; \\\n                        fill-opacity:0.5; stroke-opacity:0.5\" \/>'\n        \n        if show_bbox:\n            for seg_id, bbox in bboxes.items():\n                html += f'<rect x=\"{bbox[0]}\" y=\"{bbox[1]}\" width=\"{bbox[2]}\" height=\"{bbox[3]}\" \\\n                    style=\"fill:{seg_colors[seg_id]}; stroke:{seg_colors[seg_id]}; fill-opacity:0\" \/>'\n        \n        html += '<\/svg>'\n        html += '<\/div>'\n        html += '<\/div>'\n        html += '<style>'\n        html += '.svgclass {position: absolute; top:0px; left: 0px}'\n        html += '<\/style>'\n        \n        return html\n        \n        ","1e20672b":"instances_json_path = \"\/kaggle\/input\/cocosynth-for-here-we-grow\/cocosynth-master\/cocosynth-master\/datasets\/box_dataset_synthetic_complete\/output\/coco_instances.json\"\nimages_path = \"\/kaggle\/input\/cocosynth-for-here-we-grow\/cocosynth-master\/cocosynth-master\/datasets\/box_dataset_synthetic_complete\/output\/images\"\ncoco_dataset = CocoDataset(instances_json_path, images_path)\ncoco_dataset.display_info()\ncoco_dataset.display_licenses()\ncoco_dataset.display_categories()","e7a61aca":"html = coco_dataset.display_image(1)\nIPython.display.HTML(html)","1cef888c":"# CocoDataset Class\nThis class imports and processes an annotations JSON file that you will specify when creating an instance of the class.","ee806277":"# COCO Image Viewer\nA single image COCO dataset viewer. Import COCO Instances JSON and view segmentations on top of that image.","1f8c7489":"# Open Instances Annotations and Display Info\nIn this section, we create a new instance of the CocoDataset class, which will open the instances JSON and display high level information about the dataset: info, license, and categories.\n\n## Instructions\n- Replace the instances_json_path with the path to your instances json file.\n- Replace the images_path with the path to the folder that contains all of the images referenced in the instances json.\n\nIf you don't already have these files, you can find download links in [..\/datasets\/README.md](..\/datasets\/README.md)"}}