{"cell_type":{"69a175e2":"code","7b138966":"code","88f54256":"code","25748ab9":"code","007fc410":"code","556c7ef7":"code","bc6306e3":"code","bda61c96":"code","a0e86195":"code","49411347":"code","168b3f4d":"code","da3f212a":"code","e06c4951":"code","f61e61ad":"code","9a6a2c83":"code","dcbc9d71":"code","d6d6239e":"code","a2ff2444":"code","684c7239":"code","fa5a5af4":"code","733dd03f":"code","4958db0e":"code","f0fd787f":"code","75424ae5":"code","3218eff0":"markdown","84d4d1a5":"markdown","61e39ff2":"markdown","bf1f959f":"markdown","dd993abf":"markdown","d2128bb1":"markdown","6b18efb3":"markdown","b9a6a985":"markdown","1260bd4a":"markdown","6c86b928":"markdown"},"source":{"69a175e2":"#___________________________________________\n\n# Creator Emmanuel Pintelas\n#___________________________________________\n\n# https:\/\/www.kaggle.com\/c\/deepfake-detection-challenge\/discussion\/128954\nimport gc\nimport os\n\nimport zipfile\nimport numpy as np\nimport tensorflow as tf\nfrom keras.layers import Dense,Conv2D,MaxPooling2D,Dropout,BatchNormalization,Lambda,Activation,Input,Flatten,Reshape,Conv2DTranspose\nimport skimage\nfrom skimage.exposure import rescale_intensity\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nfrom skimage.transform import rescale, resize, downscale_local_mean\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.preprocessing import OneHotEncoder\nimport skimage\nfrom PIL import Image\nfrom skimage.io import imread, imshow, imread_collection, concatenate_images\nfrom skimage.transform import resize\nfrom skimage.util import crop, pad\nfrom skimage.morphology import label\nfrom keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau, Callback\nfrom keras import optimizers\nfrom tensorflow.keras.layers import Dense, GlobalAveragePooling2D, BatchNormalization, GlobalMaxPooling2D\nimport psutil\nimport multiprocessing as mp\nfrom keras.applications import ResNet50, DenseNet201, Xception, VGG16, InceptionV3, InceptionResNetV2, MobileNetV2, NASNetMobile\nimport copy\nmp.cpu_count()\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\nimport sys\nfrom  skimage.feature import greycoprops\n#%matplotlib inline\nimport keras\nfrom keras.models import load_model\nfrom keras.models import Model,Sequential\nfrom keras.layers import Dense,Conv2D,MaxPooling2D,Dropout,BatchNormalization,Lambda,Activation,Input,Flatten,Reshape,Conv2DTranspose, LeakyReLU\nimport keras.backend as K\nfrom keras.layers.merge import add\nfrom sklearn.model_selection import train_test_split\nimport os\nimport glob\nfrom time import time,asctime\nfrom random import randint as r\nimport random\nfrom skimage import io\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom numpy import save, load\nfrom   sklearn.metrics           import f1_score, accuracy_score, classification_report, confusion_matrix\nfrom sklearn import metrics\nfrom numpy import load\nimport pandas as pd\nimport skimage\nfrom skimage.transform import resize\nimport math\nfrom sklearn.svm import SVC\nfrom keras.layers import Input, Dense, UpSampling2D, Flatten, Reshape\nfrom itertools import combinations_with_replacement\nimport itertools\nimport numpy as np\nfrom skimage import filters, feature\nfrom skimage import img_as_float32\nfrom concurrent.futures import ThreadPoolExecutor\nimport scipy.stats\nfrom keras.layers import GlobalAveragePooling3D\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ VIDEO 3D CNN CLASSIFICATION FUNCTIONS _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\nclass Video_Generator_3D_CNN(tf.keras.utils.Sequence):\n    'Generates data for Keras'\n    def __init__(self,mode='',\n                 batch_size=1, depth='', width='', heigth='', paths = '', labels = '', n_channels=3, shuffle=False):\n\n        'Initialization'\n        self.mode = mode\n        self.batch_size = batch_size\n        self.paths = paths   # video paths of jpg frame images\n        self.labels = labels # video labels\n        self.depth = depth   # Number of frames\n        self.width = width\n        self.heigth = heigth\n        self.n_channels = n_channels\n        #self.shuffle = shuffle\n        #self.augment = augmentations\n        self.on_epoch_end()\n        self.cnt = 0\n\n\n    def __len__(self):\n        'Denotes the number of batches per epoch'\n        return int(np.ceil(len(self.paths) \/ self.batch_size))\n\n    def __getitem__(self, index):\n        'Generate one batch of data'\n        # Generate indexes of the batch\n        indexes = self.indexes[index*self.batch_size:min((index+1)*self.batch_size,len(self.paths))]\n        # Find list of IDs\n        list_IDs_im = [self.paths[k] for k in indexes]\n\n        Y = np.empty((len(list_IDs_im),2))\n        j=-1\n        for i in indexes:\n            j+=1\n            Y[j,] = self.labels[i] \n            #print(i)\n\n        # Generate data\n        \u03a7   = self.data_generation(list_IDs_im)\n        \n        \n\n        \n\n        self.cnt +=1\n        #print (self.cnt)\n\n        if self.mode == 'predict':\n               return \u03a7   \n        elif self.mode == 'train_C': \n            return \u03a7, Y      \n        elif self.mode == 'train_AE': \n            \u03a71 = \u03a7\n            \u03a72 = np.copy(\u03a71)\n            return \u03a71, \u03a72  \n\n    def on_epoch_end(self):\n        'Updates indexes after each epoch'\n        self.indexes = np.arange(len(self.paths))\n        # if self.shuffle == True:\n        #     np.random.shuffle(self.indexes)\n\n    def data_generation(self, list_IDs_im):\n        'Generates data containing batch_size samples' # X : (n_samples, *dim, n_channels)\n        # Initialization\n        X = np.empty((len(list_IDs_im),self.depth,self.width,self.heigth,self.n_channels))\n\n        # Generate data\n        for i, vid_path in enumerate(list_IDs_im):  \n            vid_path = vid_path[0]\n            Frames_id = os.listdir(vid_path)\n\n            Frames_id_int = []\n            for fr in Frames_id:\n                    if '_' not in fr:    \n                                fr = int (fr.replace('.jpg',''))\n                                Frames_id_int.append (fr)\n            Frames_id_int = np.array(Frames_id_int)\n            Frames_id_int = np.sort(Frames_id_int) \n\n            signal = 0\n            while signal != 1:\n                    try:\n                        for fr_int in Frames_id_int:\n                            fr_str = str(fr_int)+'.jpg'\n                            img_path = vid_path+'\/'+fr_str\n                            img = io.imread(img_path) # all frames must be of same size\n                            img = img.astype(float)\n                            Frames_per_Instance.append(img)  \n                        Frames_per_Instance = np.array(Frames_per_Instance)\n                        signal = 1\n                    except:  \n                        Frames_per_Instance = []\n\n\n            #Frames_per_Instance = resize (Frames_per_Instance,(self.depth,self.width,self.heigth,self.n_channels))\n            Frames_per_Instance_Sampled = np.zeros((self.depth,self.width,self.heigth,self.n_channels))\n            init_depth = Frames_per_Instance.shape[0]\n            sampling_Ratio = int (init_depth\/self.depth)\n            j=-1\n            for _i in range(300):\n                    if _i % sampling_Ratio == 0:\n                        j+=1\n                        Frames_per_Instance_Sampled[j] = cv2.resize(Frames_per_Instance[_i],(self.width,self.heigth)).astype(float)\/255.\n                        # plt.figure()\n                        # plt.imshow(Frames_per_Instance_Sampled[j])\n                        # plt.show()\n\n            X[i,] = Frames_per_Instance_Sampled\n\n        \n\n        return X\n\n\n\ndef Build_Classifier_3D_CNN (depth, width, heigth):\n\n                    inputs = keras.Input((depth, width, heigth, 3))\n\n                    x = layers.Conv3D(filters=32, kernel_size=3, activation=\"relu\")(inputs)\n                    x = layers.MaxPool3D(pool_size=(1,2,2))(x)\n                    x = layers.BatchNormalization()(x)\n\n                    x = layers.Conv3D(filters=64, kernel_size=3, activation=\"relu\")(x)\n                    x = layers.MaxPool3D(pool_size=(2,2,2))(x)\n                    x = layers.BatchNormalization()(x)\n\n                    x = layers.Conv3D(filters=128, kernel_size=3, activation=\"relu\")(x)\n                    x = layers.MaxPool3D(pool_size=(2,2,2))(x)\n                    x = layers.BatchNormalization()(x)\n\n                    x = layers.Conv3D(filters=256, kernel_size=3, activation=\"relu\")(x)\n                    x = layers.MaxPool3D(pool_size=(2,2,2))(x)\n                    x = layers.BatchNormalization()(x)\n\n                    x = layers.GlobalAveragePooling3D()(x)\n                    # FC Layer ___________\n                    x = layers.Dense(units=64, activation=\"relu\")(x)\n                    x = layers.Dropout(0.2)(x)\n\n                    outputs = layers.Dense(units=2, activation=\"sigmoid\")(x)\n\n                    # Define the model.\n                    model3d = keras.Model(inputs, outputs, name=\"Classifier_3D_CNN\")\n\n                    return model3d\n\n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ CNN Feature Extractor _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\ndef Build_CNN_F_Extr (CNN,layer_id):\n        layer =  CNN.layers[layer_id]\n        layer_name = layer.name\n        CNN_F_Extr = Model(inputs=CNN.input, outputs=CNN.get_layer(layer_name).output)\n        model = Sequential()\n        model.add(CNN_F_Extr)\n        model.add(Flatten())\n        CNN_F_Extr = model\n        return CNN_F_Extr\n\n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ VIDEO 2D CNN FUNCTIONS _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n \ndef Build_R2D_Classifier (width, heigth):\n\n    R2D = ResNet50(include_top=False, weights='imagenet',  input_shape=(width, heigth,3))\n    model = Sequential()\n    model.add(R2D)\n    model.add(GlobalAveragePooling2D())\n    # FC Layer ___________\n    model.add(Dense(units=64, activation=\"relu\"))\n    model.add(Dropout(0.2))\n    model.add(layers.Dense(units=1, activation=\"sigmoid\"))\n    R2D_Classifier = model\n    R2D_Classifier.summary()\n    return R2D_Classifier\n\n\ndef Video_2D_CNN_FE (CNN2D_FE,depth,width,heigth,n_channels,paths):\n    FEATURES = np.zeros(((paths.shape[0]), depth, CNN2D_FE.output.shape[1]))\n    index = -1\n    for vid_path in paths:  \n                index+=1\n                vid_path = vid_path[0]\n                _,__,name = vid_path.split('\/')\n                Frames_id = os.listdir(vid_path)\n\n                Frames_id_int = []\n                for fr in Frames_id:\n                        if '_' not in fr:    \n                                    fr = int (fr.replace('.jpg',''))\n                                    Frames_id_int.append (fr)\n                Frames_id_int = np.array(Frames_id_int)\n                Frames_id_int = np.sort(Frames_id_int) \n\n                Frames_per_Instance = []\n                for fr_int in Frames_id_int:\n                                fr_str = str(fr_int)+'.jpg'\n                                img_path = vid_path+'\/'+fr_str\n                                img = io.imread(img_path) # all frames must be of same size\n                                img = img.astype(float)\n                                Frames_per_Instance.append(img)  \n                Frames_per_Instance = np.array(Frames_per_Instance)\n\n                Frames_per_Instance_Sampled = np.zeros((depth,width,heigth,n_channels))\n                init_depth = Frames_per_Instance.shape[0]\n                sampling_Ratio = int (init_depth\/depth)\n                j=-1\n                for _i in range(300):\n                        if _i % sampling_Ratio == 0:\n                            j+=1\n                            Frames_per_Instance_Sampled[j] = cv2.resize(Frames_per_Instance[_i],(width,heigth)).astype(float)\/255.\n                            # plt.figure()\n                            # plt.imshow(Frames_per_Instance_Sampled[j])\n                            # plt.show()\n                \n                features_per_instance = CNN2D_FE.predict(Frames_per_Instance_Sampled)\n                FEATURES[index] = features_per_instance\n    return FEATURES\n\n\n\n\n\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n\n\n\n\n\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ HC FEATURES 1 _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n \ndef Co_Oc_Features (img):\n    img = np.uint8(img)\n    if img.shape[-1] == 3:\n                    matrix0 = skimage.feature.texture.greycomatrix(img[:,:,0], [1,2], [0, np.pi\/2],  normed=True, symmetric=True)\n                    matrix1 = skimage.feature.texture.greycomatrix(img[:,:,1], [1,2], [0, np.pi\/2],  normed=True, symmetric=True)\n                    matrix2 = skimage.feature.texture.greycomatrix(img[:,:,2], [1,2], [0, np.pi\/2],  normed=True, symmetric=True)\n                    con0,dis0,hom0,ASM0,en0,cor0 = greycoprops(matrix0, 'contrast'), greycoprops(matrix0, 'dissimilarity'), greycoprops(matrix0, 'homogeneity'),greycoprops(matrix0, 'ASM'),greycoprops(matrix0, 'energy'),greycoprops(matrix0, 'correlation')\n                    con1,dis1,hom1,ASM1,en1,cor1 = greycoprops(matrix1, 'contrast'), greycoprops(matrix1, 'dissimilarity'), greycoprops(matrix1, 'homogeneity'),greycoprops(matrix1, 'ASM'),greycoprops(matrix1, 'energy'),greycoprops(matrix1, 'correlation')\n                    con2,dis2,hom2,ASM2,en2,cor2 = greycoprops(matrix2, 'contrast'), greycoprops(matrix2, 'dissimilarity'), greycoprops(matrix2, 'homogeneity'),greycoprops(matrix2, 'ASM'),greycoprops(matrix2, 'energy'),greycoprops(matrix2, 'correlation')\n                    con0,dis0,hom0,ASM0,en0,cor0, con1,dis1,hom1,ASM1,en1,cor1, con2,dis2,hom2,ASM2,en2,cor2 = con0.reshape(1,4),dis0.reshape(1,4),hom0.reshape(1,4),ASM0.reshape(1,4),en0.reshape(1,4),cor0.reshape(1,4), con1.reshape(1,4),dis1.reshape(1,4),hom1.reshape(1,4),ASM1.reshape(1,4),en1.reshape(1,4),cor1.reshape(1,4), con2.reshape(1,4),dis2.reshape(1,4),hom2.reshape(1,4),ASM2.reshape(1,4),en2.reshape(1,4),cor2.reshape(1,4)\n                    \n                    mean0,std0, mean1,std1, mean2,std2 = np.array(np.mean(img[:,:,0])).reshape(-1,1),np.array(np.std(img[:,:,0])).reshape(-1,1), np.array(np.mean(img[:,:,1])).reshape(-1,1),np.array(np.std(img[:,:,1])).reshape(-1,1), np.array(np.mean(img[:,:,2])).reshape(-1,1),np.array(np.std(img[:,:,2])).reshape(-1,1)\n                    \n                    co_oc = np.concatenate((mean0,std0, mean1,std1, mean2,std2, con0,dis0,hom0,ASM0,en0,cor0, con1,dis1,hom1,ASM1,en1,cor1, con2,dis2,hom2,ASM2,en2,cor2),axis = 1) \n                    return co_oc\n    else:\n        matrix0 = skimage.feature.texture.greycomatrix(img, [1,2], [0, np.pi\/2],  levels=256, normed=True, symmetric=True)\n        con0,dis0,hom0,ASM0,en0,cor0 = greycoprops(matrix0, 'contrast'), greycoprops(matrix0, 'dissimilarity'), greycoprops(matrix0, 'homogeneity'),greycoprops(matrix0, 'ASM'),greycoprops(matrix0, 'energy'),greycoprops(matrix0, 'correlation')\n        co_oc = np.concatenate((con0.reshape(1,4),dis0.reshape(1,4),hom0.reshape(1,4),ASM0.reshape(1,4),en0.reshape(1,4),cor0.reshape(1,4)),axis = 1) \n        return co_oc\n        \n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ CNN Compile and Train _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\nimport tensorflow_addons as tfa\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom keras import backend as K\n\n# Compatible with tensorflow backend\ndef focal_loss(gamma=2., alpha=.25):\n\tdef focal_loss_fixed(y_true, y_pred):\n\t\tpt_1 = tf.where(tf.equal(y_true, 1), y_pred, tf.ones_like(y_pred))\n\t\tpt_0 = tf.where(tf.equal(y_true, 0), y_pred, tf.zeros_like(y_pred))\n\t\treturn -K.mean(alpha * K.pow(1. - pt_1, gamma) * K.log(pt_1+K.epsilon())) - K.mean((1 - alpha) * K.pow(pt_0, gamma) * K.log(1. - pt_0 + K.epsilon()))\n\treturn focal_loss_fixed\n\n\ndef Compile_CNN(model,lr):\n                    # Compile model.\n                    initial_learning_rate = lr \n                    lr_schedule = keras.optimizers.schedules.ExponentialDecay(\n                        initial_learning_rate, decay_steps=100000, decay_rate=0.96, staircase=True\n                    )\n                    model.compile(\n                        loss='binary_crossentropy',#focal_loss(),  # 'binary_crossentropy'   'categorical_crossentropy', 'sparse_categorical_crossentropy',\n                        optimizer=keras.optimizers.Adam(learning_rate=lr_schedule),   # 0.001\n                        metrics=['accuracy'] # Geometric_Mean\n                    )\n\n                    # Define callbacks.\n                    checkpoint_cb = keras.callbacks.ModelCheckpoint(\n                        \"CNN_Classifier.h5\",\n                        mode='max',\n                        monitor=['val_acc'], # Geometric_Mean\n                        save_best_only=True\n                    )\n                    early_stopping_cb = keras.callbacks.EarlyStopping(monitor=['val_acc'], patience=3)\n                    return model, checkpoint_cb, early_stopping_cb\n\n\ndef Train_CNN(model, epochs, train_video_g, test_video_g, checkpoint_cb, early_stopping_cb):\n                    model.fit(train_video_g,\n                                                    verbose=1,\n                                                    epochs=epochs,\n                                                    #############################callbacks=[checkpoint_cb, early_stopping_cb],\n                                                    #validation_data=test_video_g,\n                                                    shuffle=False)\n                    return model\n\n\n\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n#_______________________________________________________________________________________________________________________________________________________________\n#_____________ General Functions _________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\ndef decode_labels (labels):\n    int_labels = []\n    for lb in labels:\n        if lb == 'FAKE':\n            int_labels.append(1)\n        else:\n            int_labels.append(0)\n    int_labels = np.array(int_labels)\n    return int_labels\n\ndef create_paths (folder_name,filenames):\n    paths = []\n    for f in filenames:\n        f,_ = f.split('.mp4')\n        path = folder_name+f\n        paths.append(path)\n    paths = pd.DataFrame(paths).values\n    return  paths\n\n\n\ndef Balance_Data (X,Y):\n\n    cnt_label1, cnt_label0 = 0, 0\n    X0,X1 = [],[]\n    for x,y in zip (X,Y):\n        if y == 1:\n            cnt_label1+=1\n            X1.append(x)\n        else:\n            cnt_label0+=1\n            X0.append(x)\n\n    if cnt_label0>cnt_label1:\n        final_N = cnt_label1\n    else:\n        final_N = cnt_label0\n\n    s1 = int(cnt_label1 \/ final_N)\n    s0 = int(cnt_label0 \/ final_N)\n\n    X1_b = []\n    for i in range (cnt_label1):\n        if i % s1  == 0:\n            X1_b.append(X1[i])\n    X0_b = []\n    for i in range (cnt_label0):\n        if i % s0  == 0:\n            X0_b.append(X0[i])\n    X0_b = np.array(X0_b)\n    X1_b = np.array(X1_b)\n    Y0_b = np.zeros((X0_b.shape[0],1))\n    Y1_b = np.ones((X1_b.shape[0],1))\n\n    X = np.concatenate((X0_b, X1_b),axis=0)\n    Y = np.concatenate((Y0_b, Y1_b),axis=0)\n    return X,Y\n\n\n\ndef Create_2D_Dataset (depth,width,heigth,n_channels,train_paths,Labels_train):\n    for vid_path, lbl in zip(train_paths,Labels_train):  \n                vid_path = vid_path[0]\n                _,__,name = vid_path.split('\/')\n                Frames_id = os.listdir(vid_path)\n\n                Frames_id_int = []\n                for fr in Frames_id:\n                        if '_' not in fr:    \n                                    fr = int (fr.replace('.jpg',''))\n                                    Frames_id_int.append (fr)\n                Frames_id_int = np.array(Frames_id_int)\n                Frames_id_int = np.sort(Frames_id_int) \n\n                Frames_per_Instance = []\n                for fr_int in Frames_id_int:\n                                fr_str = str(fr_int)+'.jpg'\n                                img_path = vid_path+'\/'+fr_str\n                                img = io.imread(img_path) # all frames must be of same size\n                                img = img.astype(float)\n                                Frames_per_Instance.append(img)  \n                Frames_per_Instance = np.array(Frames_per_Instance)\n\n                Frames_per_Instance_Sampled = np.zeros((depth,width,heigth,n_channels))\n                init_depth = Frames_per_Instance.shape[0]\n                sampling_Ratio = int (init_depth\/depth)\n                j=-1\n                for _i in range(300):\n                        if _i % sampling_Ratio == 0:\n                            j+=1\n                            Frames_per_Instance_Sampled[j] = cv2.resize(Frames_per_Instance[_i],(width,heigth))#.astype(float)\/255.\n                            # plt.figure()\n                            # plt.imshow(Frames_per_Instance_Sampled[j])\n                            # plt.show()\n\n                _cnt = -1\n                for fr_s in Frames_per_Instance_Sampled:\n                    _cnt+=1\n                    skimage.io.imsave ('Dataset\/Test_Dataset_2D\/'+str(int(lbl))+'\/'+str(_cnt)+name+'.jpg',fr_s)    \n                    # Train_Dataset_2D   # lbl[0]\n\n                    \n                    \n                    \ndef Evaluation(preds, labels):\n\n                    test_y = labels\n                    pr_t = preds\n\n                    Acc = accuracy_score(test_y, pr_t) \n                    F1 = f1_score(test_y, pr_t)\n                    tn, fp, fn, tp = confusion_matrix(test_y, pr_t).ravel()\n                    GM = ((tp*tn)**(0.5)) \/ (((tp+fn)*(tn+fp))**(0.5))\n                    sensitivity =  tp \/ (tp + fn) # sensitivity, recall\n                    specificity = tn \/ (tn+fp) # specificity, selectivity\n                    #ROC_AUC = metrics.roc_auc_score(test_y, probs)  # [:,1]\n\n\n                    print ('CM = ')\n                    print(np.round (confusion_matrix(test_y, preds), 3))                    \n                    print ('Acc = ')\n                    print(str(np.round (Acc, 3)*100))\n                    print ('GM = ')\n                    print(np.round (GM, 4))\n                    print ('F1 = ')\n                    print(np.round (F1, 3))\n                    print ('Sen = ')\n                    print(np.round (sensitivity, 3))\n                    print ('Spe = ')\n                    print(np.round (specificity, 3))\n                    # print ('ROC_AUC = ')\n                    # print(np.round (ROC_AUC, 3))\n                    \n                    \n#_______________________________________________________________________________________________________________________________________________________________\n#______________________________________________________________________________________________________________________\n#_______________________________________________________________________________________________________________________________________________________________\n\n\n\n\n\n\n","7b138966":"\n\"\"\"A vanilla 3D resnet implementation.\nBased on Raghavendra Kotikalapudi's 2D implementation\nkeras-resnet (See https:\/\/github.com\/raghakot\/keras-resnet.)\n\"\"\"\nfrom __future__ import (\n    absolute_import,\n    division,\n    print_function,\n    unicode_literals\n)\nimport six\nfrom math import ceil\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.layers import (\n    Input,\n    Activation,\n    Dense,\n    Flatten\n)\nfrom keras.layers.convolutional import (\n    Conv3D,\n    AveragePooling3D,\n    MaxPooling3D\n)\nfrom keras.layers.merge import add\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.regularizers import l2\nfrom tensorflow.keras import backend as K\n\n\ndef _bn_relu(input):\n    \"\"\"Helper to build a BN -> relu block (by @raghakot).\"\"\"\n    norm = BatchNormalization(axis=CHANNEL_AXIS)(input)\n    return Activation(\"relu\")(norm)\n\n\ndef _conv_bn_relu3D(**conv_params):\n    filters = conv_params[\"filters\"]\n    kernel_size = conv_params[\"kernel_size\"]\n    strides = conv_params.setdefault(\"strides\", (1, 1, 1))\n    kernel_initializer = conv_params.setdefault(\n        \"kernel_initializer\", \"he_normal\")\n    padding = conv_params.setdefault(\"padding\", \"same\")\n    kernel_regularizer = conv_params.setdefault(\"kernel_regularizer\",\n                                                l2(1e-4))\n\n    def f(input):\n        conv = Conv3D(filters=filters, kernel_size=kernel_size,\n                      strides=strides, kernel_initializer=kernel_initializer,\n                      padding=padding,\n                      kernel_regularizer=kernel_regularizer)(input)\n        return _bn_relu(conv)\n\n    return f\n\n\ndef _bn_relu_conv3d(**conv_params):\n    \"\"\"Helper to build a  BN -> relu -> conv3d block.\"\"\"\n    filters = conv_params[\"filters\"]\n    kernel_size = conv_params[\"kernel_size\"]\n    strides = conv_params.setdefault(\"strides\", (1, 1, 1))\n    kernel_initializer = conv_params.setdefault(\"kernel_initializer\",\n                                                \"he_normal\")\n    padding = conv_params.setdefault(\"padding\", \"same\")\n    kernel_regularizer = conv_params.setdefault(\"kernel_regularizer\",\n                                                l2(1e-4))\n\n    def f(input):\n        activation = _bn_relu(input)\n        return Conv3D(filters=filters, kernel_size=kernel_size,\n                      strides=strides, kernel_initializer=kernel_initializer,\n                      padding=padding,\n                      kernel_regularizer=kernel_regularizer)(activation)\n    return f\n\n\ndef _shortcut3d(input, residual):\n    \"\"\"3D shortcut to match input and residual and merges them with \"sum\".\"\"\"\n    stride_dim1 = ceil(input.shape[DIM1_AXIS] \\\n        \/ residual.shape[DIM1_AXIS])\n    stride_dim2 = ceil(input.shape[DIM2_AXIS] \\\n        \/ residual.shape[DIM2_AXIS])\n    stride_dim3 = ceil(input.shape[DIM3_AXIS] \\\n        \/ residual.shape[DIM3_AXIS])\n    equal_channels = residual.shape[CHANNEL_AXIS] \\\n        == input.shape[CHANNEL_AXIS]\n\n    shortcut = input\n    if stride_dim1 > 1 or stride_dim2 > 1 or stride_dim3 > 1 \\\n            or not equal_channels:\n        shortcut = Conv3D(\n            filters=residual.shape[CHANNEL_AXIS],\n            kernel_size=(1, 1, 1),\n            strides=(stride_dim1, stride_dim2, stride_dim3),\n            kernel_initializer=\"he_normal\", padding=\"valid\",\n            kernel_regularizer=l2(1e-4)\n            )(input)\n    return add([shortcut, residual])\n\n\ndef _residual_block3d(block_function, filters, kernel_regularizer, repetitions,\n                      is_first_layer=False):\n    def f(input):\n        for i in range(repetitions):\n            strides = (1, 1, 1)\n            if i == 0 and not is_first_layer:\n                strides = (2, 2, 2)\n            input = block_function(filters=filters, strides=strides,\n                                   kernel_regularizer=kernel_regularizer,\n                                   is_first_block_of_first_layer=(\n                                       is_first_layer and i == 0)\n                                   )(input)\n        return input\n\n    return f\n\n\ndef basic_block(filters, strides=(1, 1, 1), kernel_regularizer=l2(1e-4),\n                is_first_block_of_first_layer=False):\n    \"\"\"Basic 3 X 3 X 3 convolution blocks. Extended from raghakot's 2D impl.\"\"\"\n    def f(input):\n        if is_first_block_of_first_layer:\n            # don't repeat bn->relu since we just did bn->relu->maxpool\n            conv1 = Conv3D(filters=filters, kernel_size=(3, 3, 3),\n                           strides=strides, padding=\"same\",\n                           kernel_initializer=\"he_normal\",\n                           kernel_regularizer=kernel_regularizer\n                           )(input)\n        else:\n            conv1 = _bn_relu_conv3d(filters=filters,\n                                    kernel_size=(3, 3, 3),\n                                    strides=strides,\n                                    kernel_regularizer=kernel_regularizer\n                                    )(input)\n\n        residual = _bn_relu_conv3d(filters=filters, kernel_size=(3, 3, 3),\n                                   kernel_regularizer=kernel_regularizer\n                                   )(conv1)\n        return _shortcut3d(input, residual)\n\n    return f\n\n\ndef bottleneck(filters, strides=(1, 1, 1), kernel_regularizer=l2(1e-4),\n               is_first_block_of_first_layer=False):\n    \"\"\"Basic 3 X 3 X 3 convolution blocks. Extended from raghakot's 2D impl.\"\"\"\n    def f(input):\n        if is_first_block_of_first_layer:\n            # don't repeat bn->relu since we just did bn->relu->maxpool\n            conv_1_1 = Conv3D(filters=filters, kernel_size=(1, 1, 1),\n                              strides=strides, padding=\"same\",\n                              kernel_initializer=\"he_normal\",\n                              kernel_regularizer=kernel_regularizer\n                              )(input)\n        else:\n            conv_1_1 = _bn_relu_conv3d(filters=filters, kernel_size=(1, 1, 1),\n                                       strides=strides,\n                                       kernel_regularizer=kernel_regularizer\n                                       )(input)\n\n        conv_3_3 = _bn_relu_conv3d(filters=filters, kernel_size=(3, 3, 3),\n                                   kernel_regularizer=kernel_regularizer\n                                   )(conv_1_1)\n        residual = _bn_relu_conv3d(filters=filters * 4, kernel_size=(1, 1, 1),\n                                   kernel_regularizer=kernel_regularizer\n                                   )(conv_3_3)\n\n        return _shortcut3d(input, residual)\n\n    return f\n\n\ndef _handle_data_format():\n    global DIM1_AXIS\n    global DIM2_AXIS\n    global DIM3_AXIS\n    global CHANNEL_AXIS\n    if K.image_data_format() == 'channels_last':\n        DIM1_AXIS = 1\n        DIM2_AXIS = 2\n        DIM3_AXIS = 3\n        CHANNEL_AXIS = 4\n    else:\n        CHANNEL_AXIS = 1\n        DIM1_AXIS = 2\n        DIM2_AXIS = 3\n        DIM3_AXIS = 4\n\n\ndef _get_block(identifier):\n    if isinstance(identifier, six.string_types):\n        res = globals().get(identifier)\n        if not res:\n            raise ValueError('Invalid {}'.format(identifier))\n        return res\n    return identifier\n\n\nclass Resnet3DBuilder(object):\n    \"\"\"ResNet3D.\"\"\"\n\n    @staticmethod\n    def build(input_shape, num_outputs, block_fn, repetitions, reg_factor):\n        \"\"\"Instantiate a vanilla ResNet3D keras model.\n        # Arguments\n            input_shape: Tuple of input shape in the format\n            (conv_dim1, conv_dim2, conv_dim3, channels) if dim_ordering='tf'\n            (filter, conv_dim1, conv_dim2, conv_dim3) if dim_ordering='th'\n            num_outputs: The number of outputs at the final softmax layer\n            block_fn: Unit block to use {'basic_block', 'bottlenack_block'}\n            repetitions: Repetitions of unit blocks\n        # Returns\n            model: a 3D ResNet model that takes a 5D tensor (volumetric images\n            in batch) as input and returns a 1D vector (prediction) as output.\n        \"\"\"\n        _handle_data_format()\n        if len(input_shape) != 4:\n            raise ValueError(\"Input shape should be a tuple \"\n                             \"(conv_dim1, conv_dim2, conv_dim3, channels) \"\n                             \"for tensorflow as backend or \"\n                             \"(channels, conv_dim1, conv_dim2, conv_dim3) \"\n                             \"for theano as backend\")\n\n        block_fn = _get_block(block_fn)\n        input = Input(shape=input_shape)\n        # first conv\n        conv1 = _conv_bn_relu3D(filters=64, kernel_size=(7, 7, 7),\n                                strides=(2, 2, 2),\n                                kernel_regularizer=l2(reg_factor)\n                                )(input)\n        pool1 = MaxPooling3D(pool_size=(3, 3, 3), strides=(2, 2, 2),\n                             padding=\"same\")(conv1)\n\n        # repeat blocks\n        block = pool1\n        filters = 64\n        for i, r in enumerate(repetitions):\n            block = _residual_block3d(block_fn, filters=filters,\n                                      kernel_regularizer=l2(reg_factor),\n                                      repetitions=r, is_first_layer=(i == 0)\n                                      )(block)\n            filters *= 2\n\n        # last activation\n        block_output = _bn_relu(block)\n\n        # average poll and classification\n        pool2 = AveragePooling3D(pool_size=(block.shape[DIM1_AXIS],\n                                            block.shape[DIM2_AXIS],\n                                            block.shape[DIM3_AXIS]),\n                                 strides=(1, 1, 1))(block_output)\n        flatten1 = Flatten()(pool2)\n        if num_outputs > 1:\n            dense = Dense(units=num_outputs,\n                          kernel_initializer=\"he_normal\",\n                          activation=\"softmax\",\n                          kernel_regularizer=l2(reg_factor))(flatten1)\n        else:\n            dense = Dense(units=num_outputs,\n                          kernel_initializer=\"he_normal\",\n                          activation=\"sigmoid\",\n                          kernel_regularizer=l2(reg_factor))(flatten1)\n\n        model = Model(inputs=input, outputs=dense)\n        return model\n\n    @staticmethod\n    def build_resnet_18(input_shape, num_outputs, reg_factor=1e-4):\n        \"\"\"Build resnet 18.\"\"\"\n        return Resnet3DBuilder.build(input_shape, num_outputs, basic_block,\n                                     [2, 2, 2, 2], reg_factor=reg_factor)\n\n    @staticmethod\n    def build_resnet_34(input_shape, num_outputs, reg_factor=1e-4):\n        \"\"\"Build resnet 34.\"\"\"\n        return Resnet3DBuilder.build(input_shape, num_outputs, basic_block,\n                                     [3, 4, 6, 3], reg_factor=reg_factor)\n\n    @staticmethod\n    def build_resnet_50(input_shape, num_outputs, reg_factor=1e-4):\n        \"\"\"Build resnet 50.\"\"\"\n        return Resnet3DBuilder.build(input_shape, num_outputs, bottleneck,\n                                     [3, 4, 6, 3], reg_factor=reg_factor)\n\n    @staticmethod\n    def build_resnet_101(input_shape, num_outputs, reg_factor=1e-4):\n        \"\"\"Build resnet 101.\"\"\"\n        return Resnet3DBuilder.build(input_shape, num_outputs, bottleneck,\n                                     [3, 4, 23, 3], reg_factor=reg_factor)\n\n    @staticmethod\n    def build_resnet_152(input_shape, num_outputs, reg_factor=1e-4):\n        \"\"\"Build resnet 152.\"\"\"\n        return Resnet3DBuilder.build(input_shape, num_outputs, bottleneck,\n                                     [3, 8, 36, 3], reg_factor=reg_factor)\n\n","88f54256":"activate = 2  # 1 for activation","25748ab9":"if 1 == 1:\n    filenames_train,  filenames_test = np.load('..\/input\/deepfake-videos\/filenames_train.npy', allow_pickle=True), np.load('..\/input\/deepfake-videos\/filenames_test.npy', allow_pickle=True)\n    train_paths = create_paths ('..\/input\/deepfake-videos\/Train_Videos_Raw_JPG\/Train_Videos_Raw_JPG\/',filenames_train) #\n    test_paths = create_paths ('..\/input\/deepfake-videos\/Test_Videos_Raw_JPG\/Test_Videos_Raw_JPG\/',filenames_test) #\n    Labels_train,  Labels_test = np.load('..\/input\/deepfake-videos\/Labels_train.npy', allow_pickle=True), np.load('..\/input\/deepfake-videos\/Labels_test.npy', allow_pickle=True)\n    Labels_train, Labels_test = decode_labels (Labels_train), decode_labels (Labels_test)\n    train_paths,Labels_train = Balance_Data (train_paths,Labels_train)\n    from sklearn.preprocessing import OneHotEncoder\n    onehot_encoder = OneHotEncoder()\n    Labels_train_oh = onehot_encoder.fit_transform(Labels_train.reshape(-1,1)).toarray()#.astype(int)\n    Labels_test_oh = onehot_encoder.fit_transform(Labels_test.reshape(-1,1)).toarray()#.astype(int)\n\n\n\nif 1 == 1:\n    from random import shuffle\n    ind_list = [_r_ for _r_ in range(len(train_paths))]\n    shuffle(ind_list)\n    train_paths  = train_paths[ind_list]\n    Labels_train_oh  = Labels_train_oh[ind_list]\n    Labels_train  = Labels_train[ind_list]","007fc410":"if 1 == 2:\n\n    depth, width, heigth = 300, 160, 160 \n    train_g = Video_Generator_3D_CNN(mode='train_AE', batch_size=1, depth=depth, width=width, heigth=heigth, paths = train_paths, labels = Labels_train_oh, n_channels=3, shuffle=False)\n    val_g = Video_Generator_3D_CNN(mode='train_AE', batch_size=1,  depth=depth, width=width, heigth=heigth, paths = test_paths, labels = Labels_test_oh, n_channels=3, shuffle=False)#\n","556c7ef7":"            \ndef Build_AE3D_EE(depth, width, heigth):\n                    inputs = keras.Input((depth, width, heigth, 3)) # init 300,150,150\n\n                    x = layers.Conv3D(filters=16, kernel_size=(3,3,3), strides=(1,1,1), padding='same')(inputs)\n                    x = layers.LeakyReLU()(x)\n                    x = layers.MaxPool3D(pool_size=(3,2,2))(x)\n                    \n                    x = layers.Conv3D(filters=3, kernel_size=(3,3,3), strides=(4,2,2), padding='same')(x)\n                    x = layers.LeakyReLU()(x)\n            \n    \n    \n                    x = tf.keras.layers.Conv3DTranspose (filters=32, kernel_size=(3,3,3), strides=(4,2,2), padding='same')(x) \n                    x = layers.LeakyReLU()(x)\n                    x = tf.keras.layers.Conv3DTranspose (filters=16, kernel_size=(3,3,3), strides=(3,2,2), padding='same')(x) \n                    x = layers.LeakyReLU()(x)\n                    \n                    outputs =  layers.Conv3DTranspose(filters=3, kernel_size=(3,3,3), strides=(1,1,1), activation=\"sigmoid\", padding='same')(x)\n\n                    # Define the model.\n                    ae3d = keras.Model(inputs, outputs, name=\"ae_3D\")\n                    \n                    return ae3d\n\n","bc6306e3":"if 1 == 2:\n    CAE = Build_AE3D_EE(depth, width, heigth)\n    CAE.summary()","bda61c96":"if 1 == 2:\n    lr = 0.001    # 0.001  0.0005   0.0001 0.00005\n    CAE, checkpoint_cb, early_stopping_cb = Compile_CNN (CAE, lr)\n\n            # Training  (Very Slow)\n    if 1==1:    \n                epochs = 5\n                CAE = Train_CNN(CAE, epochs, train_g, val_g, checkpoint_cb, early_stopping_cb)  ","a0e86195":"#CAE.save('CAE_25_40.h5')","49411347":"if 1 == activate:\n    depth, width, heigth = 300, 160, 160 \n    train_g = Video_Generator_3D_CNN(mode='train_C', batch_size=1, depth=depth, width=width, heigth=heigth, paths = train_paths, labels = Labels_train_oh, n_channels=3, shuffle=False)\n    val_g = Video_Generator_3D_CNN(mode='train_C', batch_size=1,  depth=depth, width=width, heigth=heigth, paths = test_paths, labels = Labels_test_oh, n_channels=3, shuffle=False)#\n","168b3f4d":"if 1 == activate:\n    CAE = load_model('..\/input\/ae3d-deepfake\/CAE_25_40.h5')\n    layer =  CAE.layers [5]  \n    layer_name = layer.name\n    encoder_3d = Model(inputs=CAE.input, outputs=CAE.get_layer(layer_name).output)\n    encoder_3d.summary()","da3f212a":"if 1 == activate:\n    for layer in encoder_3d.layers:\n                            layer.trainable = False\n    encoder_3d.summary()","e06c4951":"if 1 == activate:\n    R3D = Resnet3DBuilder.build_resnet_50((25, 40, 40, 3), 2)\n    layer =  R3D.layers [-3]  # [3]\n    layer_name = layer.name\n    R3D = Model(inputs=R3D.input, outputs=R3D.get_layer(layer_name).output)\n    \n    model = Sequential()\n    model.add(encoder_3d)\n    model.add(R3D)\n    model.add(GlobalAveragePooling3D())\n#             # FC Layer ___________\n    model.add(Dense(units=64, activation=\"relu\"))\n    model.add(Dropout(0.2))\n    model.add(layers.Dense(units=2, activation=\"sigmoid\"))\n\n    CAE3D_R3D = model\n    CAE3D_R3D.summary()","f61e61ad":"1+1","9a6a2c83":"if 1 == activate:\n    # CAE3D_I3D = load_model('')\n    lr = 0.00015\n    CAE3D_R3D, checkpoint_cb, early_stopping_cb = Compile_CNN (CAE3D_R3D, lr)\n\n    # Training  (Very Slow)\n    if 1==1:    \n                epochs = 4\n                CAE3D_R3D = Train_CNN(CAE3D_R3D, epochs, train_g, val_g, checkpoint_cb, early_stopping_cb)  # at 0.645 - 0.70 acc is good to stop\n\n","dcbc9d71":"#Evaluation(np.argmax(CAE3D_R3D.predict(val_g),axis=1), Labels_test)  ","d6d6239e":"if 1 == activate:\n    layer =  CAE3D_R3D.layers [2]  \n    layer_name = layer.name\n    CAE3D_R3D_FE = Model(inputs=CAE3D_R3D.input, outputs=CAE3D_R3D.get_layer(layer_name).output)\n    CAE3D_R3D_FE.summary()","a2ff2444":"if 1 == activate:\n    f_train = CAE3D_R3D_FE.predict(train_g)\n    f_test = CAE3D_R3D_FE.predict(val_g)","684c7239":"if 1 == activate:\n    ML = LogisticRegression(C=10, max_iter=550).fit(f_train, Labels_train) # DecisionTreeClassifier(max_depth=5)SVC(C=1,kernel='rbf').fit(probs_CAE_CNN_tr, Labels_train) #\n    preds = ML.predict(f_test)\n    Evaluation(preds, Labels_test)","fa5a5af4":"if 1 == activate:\n    #CAE3D_R3D.save('CAE_150_R3D_E-E.h5')\n    #CAE3D_R3D_FE.save('CAE_150_R3D_FE.h5')\n    np.save('CAE_25_40_R3D_Features_tr',f_train)\n    np.save('CAE_25_40_R3D_Features_ts',f_test)\n    np.save('Labels_train', Labels_train)\n    np.save('Labels_test',  Labels_test)\n\n    # 150           \n    # 100                  \n    # 50\n    # 25   ","733dd03f":"# CAE = load_model('..\/input\/ae3d-deepfake\/CAE_25_40.h5')\n\n\n# layer =  CAE.layers [5]  # [3]\n# layer_name = layer.name\n# \u0395\u0395ncoder_3d = Model(inputs=CAE.input, outputs=CAE.get_layer(layer_name).output)\n# \u0395\u0395ncoder_3d.summary()\n# #encoder_3d.save('encoder_3d_Cascade.h5',encoder_3d)\n\n\n# trial = val_g[0][0]\n# Reconstructed = CAE.predict(trial)\n# encoded = \u0395\u0395ncoder_3d.predict(trial)\n# encoded = encoded [0]\n# Reconstructed = Reconstructed [0]\n# trial = trial [0]","4958db0e":"#         en_video = trial\n#         en_video.shape\n#         fig=plt.figure(figsize=(12,12))\n#         columns = 20#6\n#         rows = 15#8\n#         for i in range(1,  columns*rows+1):  # 48\n#                     img = en_video[i-1,:,:,:] #en_video[:,:,i-1]\n#                     fig.add_subplot(rows, columns, i)\n#                     plt.axis('off')\n#                     plt.imshow(img)\n#         plt.show()","f0fd787f":"#         en_video = encoded\n#         en_video.shape\n#         fig=plt.figure(figsize=(12,12))\n#         columns = 5#6\n#         rows = 5#8\n#         for i in range(1,  columns*rows+1):  # 48\n#                     img = en_video[i-1,:,:,:] #en_video[:,:,i-1]\n#                     fig.add_subplot(rows, columns, i)\n#                     plt.axis('off')\n#                     plt.imshow(img)\n#         plt.show()","75424ae5":"#         en_video = Reconstructed\n#         en_video.shape\n#         fig=plt.figure(figsize=(12,12))\n#         columns = 20#6\n#         rows = 15#8\n#         for i in range(1,  columns*rows+1):  # 48\n#                     img = en_video[i-1,:,:,:] #en_video[:,:,i-1]\n#                     fig.add_subplot(rows, columns, i)\n#                     plt.axis('off')\n#                     plt.imshow(img)\n#         plt.show()","3218eff0":"**MAIN PROGRAM**","84d4d1a5":"CAE Training","61e39ff2":"**RESNET 3D**","bf1f959f":"**ENCODED\/COMPRESSED**","dd993abf":"**RECONSTRUCTED**","d2128bb1":"**DATA PATHS CREATION**","6b18efb3":"**LIBRARIES and FUNCTIONS**","b9a6a985":"CAE3D OUTPUT VIZUALIZATION","1260bd4a":"**INITIAL**","6c86b928":"CAE-I3D Training"}}