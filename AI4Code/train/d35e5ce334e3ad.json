{"cell_type":{"dbbc6d9d":"code","7130623c":"code","2f2967b0":"code","aa59747e":"code","a2192f16":"code","7317c71d":"code","85608c70":"code","4910fc69":"code","bbcaf47b":"code","a6db824d":"code","96459bb8":"code","9a0e016d":"code","280c9784":"code","46d3d10f":"code","51081033":"code","81dc1d22":"code","7a440a27":"code","fbec6cef":"code","40c84a3d":"code","137e3265":"code","93e624ff":"code","5057d331":"code","97e8e917":"code","1f0e43f2":"code","d597cb63":"code","1feb664d":"code","1038a1a8":"code","b9db22b1":"code","80ffdfc1":"code","c207f5db":"code","fa2d4d74":"code","14372437":"code","c8831281":"code","0b566bf0":"code","5f691f12":"code","8a38c1e9":"code","fcae5832":"code","6de700cc":"code","aaebb2fe":"code","7fba45d2":"code","f1ec7f0f":"code","ab8e9497":"code","c101ea11":"code","7d222cd6":"code","a1c43eb8":"code","0fa6c675":"code","43123505":"code","668da8d6":"code","c755a802":"code","24d13a3b":"code","2b52ac3b":"code","dd8c22d4":"code","3c99d8d0":"code","47726d75":"code","c983985a":"code","5fcb4530":"code","77099637":"code","ef6b39ac":"code","9953cc0c":"code","a0daccc7":"code","2620ce28":"code","bf391ac3":"code","aeac150f":"code","8ff15f25":"code","500647d4":"code","fb27110e":"code","11b7f78e":"code","74b6bf74":"code","c2c933eb":"code","4f8a694f":"code","3e0b5b42":"code","d4117084":"code","8ee2a89f":"code","34315151":"code","48e26d6c":"code","b699c1bf":"code","0810403e":"code","fd1bd408":"markdown","83a8de08":"markdown","13986f39":"markdown","ae4681b8":"markdown","a5d7013f":"markdown","1709ed59":"markdown","e6f5c6bc":"markdown","0f217539":"markdown","631c3639":"markdown","c9187ce9":"markdown","fbc79f7c":"markdown","2e4a7f64":"markdown"},"source":{"dbbc6d9d":"!pip install ..\/input\/python-datatable\/datatable-0.11.0-cp37-cp37m-manylinux2010_x86_64.whl > \/dev\/null 2>&1","7130623c":"import numpy as np\nimport pandas as pd\nimport psutil\n\nfrom collections import defaultdict\nimport datatable as dt\nimport lightgbm as lgb\nfrom matplotlib import pyplot as plt\nimport riiideducation\nimport random\nfrom sklearn.metrics import roc_auc_score\nimport gc\n\n_ = np.seterr(divide='ignore', invalid='ignore')","2f2967b0":"data_types_dict = {\n    'timestamp': 'int64',\n    'user_id': 'int32', \n    'content_id': 'int16', \n    'content_type_id':'int8', \n    'task_container_id': 'int16',\n    #'user_answer': 'int8',\n    'answered_correctly': 'int8', \n    'prior_question_elapsed_time': 'float32', \n    'prior_question_had_explanation': 'bool'\n}\ntarget = 'answered_correctly'","aa59747e":"train_df = dt.fread('..\/input\/riiid-test-answer-prediction\/train.csv', columns=set(data_types_dict.keys())).to_pandas()","a2192f16":"train_df = train_df.sample(600*1000)","7317c71d":"print(psutil.virtual_memory().percent)","85608c70":"#reading in lecture df\nlectures_df = pd.read_csv('\/kaggle\/input\/riiid-test-answer-prediction\/lectures.csv')","4910fc69":"lectures_df['type_of'] = lectures_df['type_of'].replace('solving question', 'solving_question')\n\nlectures_df = pd.get_dummies(lectures_df, columns=['part', 'type_of'])\n\npart_lectures_columns = [column for column in lectures_df.columns if column.startswith('part')]\n\ntypes_of_lectures_columns = [column for column in lectures_df.columns if column.startswith('type_of_')]","bbcaf47b":"train_lectures = train_df[train_df.content_type_id == True].merge(lectures_df, left_on='content_id', right_on='lecture_id', how='left')","a6db824d":"user_lecture_stats_part = train_lectures.groupby('user_id',as_index = False)[part_lectures_columns + types_of_lectures_columns].sum()","96459bb8":"lecturedata_types_dict = {   \n    'user_id': 'int32', \n    'part_1': 'int8',\n    'part_2': 'int8',\n    'part_3': 'int8',\n    'part_4': 'int8',\n    'part_5': 'int8',\n    'part_6': 'int8',\n    'part_7': 'int8',\n    'type_of_concept': 'int8',\n    'type_of_intention': 'int8',\n    'type_of_solving_question': 'int8',\n    'type_of_starter': 'int8'\n}\nuser_lecture_stats_part = user_lecture_stats_part.astype(lecturedata_types_dict)","9a0e016d":"for column in user_lecture_stats_part.columns:\n    #bool_column = column + '_boolean'\n    if(column !='user_id'):\n        user_lecture_stats_part[column] = (user_lecture_stats_part[column] > 0).astype('int8')","280c9784":"train_lectures[train_lectures.user_id==5382]","46d3d10f":"user_lecture_stats_part[user_lecture_stats_part.user_id==5382]","51081033":"user_lecture_stats_part.tail()","81dc1d22":"user_lecture_stats_part.dtypes","7a440a27":"#clearing memory\ndel(train_lectures)","fbec6cef":"print(psutil.virtual_memory().percent)\n#train_df.head(n=10)","40c84a3d":"cum = train_df.groupby('user_id')['content_type_id'].agg(['cumsum', 'cumcount'])\ntrain_df['user_lecture_cumsum'] = cum['cumsum'] \ntrain_df['user_lecture_lv'] = cum['cumsum'] \/ cum['cumcount']\n\n\ntrain_df.user_lecture_lv=train_df.user_lecture_lv.astype('float16')\ntrain_df.user_lecture_cumsum=train_df.user_lecture_cumsum.astype('int8')\nuser_lecture_agg = train_df.groupby('user_id')['content_type_id'].agg(['sum', 'count'])\n#train_df.head(n=10)","137e3265":"train_df['prior_question_had_explanation'].fillna(False, inplace=True)\ntrain_df = train_df.astype(data_types_dict)\ntrain_df = train_df[train_df[target] != -1].reset_index(drop=True)\nprior_question_elapsed_time_mean=train_df['prior_question_elapsed_time'].mean()\ntrain_df['prior_question_elapsed_time'].fillna(prior_question_elapsed_time_mean, inplace=True)\n#train_df.head(n=10)","93e624ff":"max_timestamp_u = train_df[['user_id','timestamp']].groupby(['user_id']).agg(['max']).reset_index()\n#max_timestamp_u = train_df[['user_id','timestamp']].groupby(['user_id']).agg(['max'])\nmax_timestamp_u.columns = ['user_id', 'max_time_stamp']","5057d331":"\ntrain_df['lagtime'] = train_df.groupby('user_id')['timestamp'].shift()\ntrain_df['lagtime']=train_df['timestamp']-train_df['lagtime']\ntrain_df['lagtime'].fillna(0, inplace=True)\ntrain_df.lagtime=train_df.lagtime.astype('int32')\n#train_df.drop(columns=['timestamp'], inplace=True)\n#train_df.head(n=10)","97e8e917":"lagtime_agg = train_df.groupby('user_id')['lagtime'].agg(['mean'])\ntrain_df['lagtime_mean'] = train_df['user_id'].map(lagtime_agg['mean'])\ntrain_df.lagtime_mean=train_df.lagtime_mean.astype('int32')\n#train_df.head(n=10)","1f0e43f2":"user_prior_question_elapsed_time = train_df[['user_id','prior_question_elapsed_time']].groupby(['user_id']).tail(1)\n#max_timestamp_u = train_df[['user_id','timestamp']].groupby(['user_id']).agg(['max'])\nuser_prior_question_elapsed_time.columns = ['user_id', 'prior_question_elapsed_time']","d597cb63":"\ntrain_df['delta_prior_question_elapsed_time'] = train_df.groupby('user_id')['prior_question_elapsed_time'].shift()\ntrain_df['delta_prior_question_elapsed_time']=train_df['prior_question_elapsed_time']-train_df['delta_prior_question_elapsed_time']\ntrain_df['delta_prior_question_elapsed_time'].fillna(0, inplace=True)\n#train_df.head(n=10)\n","1feb664d":"train_df.delta_prior_question_elapsed_time=train_df.delta_prior_question_elapsed_time.astype('int32')","1038a1a8":"train_df['timestamp']=train_df['timestamp']\/(1000*3600)\ntrain_df.timestamp=train_df.timestamp.astype('int16')\n#","b9db22b1":"train_df['lag'] = train_df.groupby('user_id')[target].shift()\n#train_df.head(n=10)","80ffdfc1":"\n\ncum = train_df.groupby('user_id')['lag'].agg(['cumsum', 'cumcount'])\ntrain_df['user_correctness'] = cum['cumsum'] \/ cum['cumcount']\ntrain_df['user_correct_cumsum'] = cum['cumsum']\ntrain_df['user_correct_cumcount'] = cum['cumcount']\ntrain_df.drop(columns=['lag'], inplace=True)\n\n# train_df['user_correctness'].fillna(1, inplace=True)\ntrain_df['user_correct_cumsum'].fillna(0, inplace=True)\n#train_df['user_correct_cumcount'].fillna(0, inplace=True)\ntrain_df.user_correctness=train_df.user_correctness.astype('float16')\ntrain_df.user_correct_cumcount=train_df.user_correct_cumcount.astype('int16')\ntrain_df.user_correct_cumsum=train_df.user_correct_cumsum.astype('int16')\n#train_df.head(n=10)","c207f5db":"train_df.prior_question_had_explanation=train_df.prior_question_had_explanation.astype('int8')\n\ntrain_df['lag'] = train_df.groupby('user_id')['prior_question_had_explanation'].shift()\n#train_df.head(n=10)","fa2d4d74":"\ncum = train_df.groupby('user_id')['lag'].agg(['cumsum', 'cumcount'])\ntrain_df['explanation_mean'] = cum['cumsum'] \/ cum['cumcount']\ntrain_df['explanation_cumsum'] = cum['cumsum'] \ntrain_df.drop(columns=['lag'], inplace=True)\n\ntrain_df['explanation_mean'].fillna(0, inplace=True)\ntrain_df['explanation_cumsum'].fillna(0, inplace=True)\ntrain_df.explanation_mean=train_df.explanation_mean.astype('float16')\ntrain_df.explanation_cumsum=train_df.explanation_cumsum.astype('int16')\n#train_df.head(n=10)","14372437":"del cum\ngc.collect()","c8831281":"\ntrain_df[\"attempt_no\"] = 1\ntrain_df.attempt_no=train_df.attempt_no.astype('int8')\ntrain_df[\"attempt_no\"] = train_df[[\"user_id\",\"content_id\",'attempt_no']].groupby([\"user_id\",\"content_id\"])[\"attempt_no\"].cumsum()","0b566bf0":"#train_df.head(n=10)","5f691f12":"train_df.dtypes","8a38c1e9":"explanation_agg = train_df.groupby('user_id')['prior_question_had_explanation'].agg(['sum', 'count'])\nexplanation_agg=explanation_agg.astype('int16')\n#train_df.drop(columns=['prior_question_had_explanation'], inplace=True)","fcae5832":"user_agg = train_df.groupby('user_id')[target].agg(['sum', 'count'])\ncontent_agg = train_df.groupby('content_id')[target].agg(['sum', 'count','var'])\ntask_container_agg = train_df.groupby('task_container_id')[target].agg(['sum', 'count','var'])\n\n#prior_question_elapsed_time_agg = train_df.groupby('user_id')['prior_question_elapsed_time'].agg(['sum', 'count'])","6de700cc":"user_agg=user_agg.astype('int16')\ncontent_agg=content_agg.astype('float32')\ntask_container_agg=task_container_agg.astype('float32')","aaebb2fe":"attempt_no_agg=train_df.groupby([\"user_id\",\"content_id\"])[\"attempt_no\"].agg(['sum'])\nattempt_no_agg=attempt_no_agg.astype('int8')\n#attempt_series = train_df[['user_id', 'content_id','attempt_no']].groupby(['user_id','content_id'])['attempt_no'].max()","7fba45d2":"train_df['content_count'] = train_df['content_id'].map(content_agg['count']).astype('int32')\ntrain_df['content_sum'] = train_df['content_id'].map(content_agg['sum']).astype('int32')\ntrain_df['content_correctness'] = train_df['content_id'].map(content_agg['sum'] \/ content_agg['count'])\ntrain_df.content_correctness=train_df.content_correctness.astype('float16')\ntrain_df['task_container_sum'] = train_df['task_container_id'].map(task_container_agg['sum']).astype('int32')\ntrain_df['task_container_std'] = train_df['task_container_id'].map(task_container_agg['var']).astype('float16')\ntrain_df['task_container_correctness'] = train_df['task_container_id'].map(task_container_agg['sum'] \/ task_container_agg['count'])\ntrain_df.task_container_correctness=train_df.task_container_correctness.astype('float16')\n#train_df.head(n=10)","f1ec7f0f":"questions_df = pd.read_csv(\n    '..\/input\/riiid-test-answer-prediction\/questions.csv', \n    usecols=[0, 1,3,4],\n    dtype={'question_id': 'int16','bundle_id': 'int16', 'part': 'int8','tags': 'str'}\n)\nquestions_df['part_bundle_id']=questions_df['part']*100000+questions_df['bundle_id']\nquestions_df.part_bundle_id=questions_df.part_bundle_id.astype('int32')\ntag = questions_df[\"tags\"].str.split(\" \", n = 10, expand = True)\ntag.columns = ['tags1','tags2','tags3','tags4','tags5','tags6']\n#\n\ntag.fillna(0, inplace=True)\ntag = tag.astype('int16')\nquestions_df =  pd.concat([questions_df,tag],axis=1).drop(['tags'],axis=1)","ab8e9497":"questions_df.rename(columns={'question_id':'content_id'}, inplace=True)","c101ea11":"questions_df['content_correctness'] = questions_df['content_id'].map(content_agg['sum'] \/ content_agg['count'])\nquestions_df.content_correctness=questions_df.content_correctness.astype('float16')\nquestions_df['content_correctness_std'] = questions_df['content_id'].map(content_agg['var'])\nquestions_df.content_correctness_std=questions_df.content_correctness_std.astype('float16')","7d222cd6":"part_agg = questions_df.groupby('part')['content_correctness'].agg(['mean', 'var'])\nquestions_df['part_correctness_mean'] = questions_df['part'].map(part_agg['mean'])\nquestions_df['part_correctness_std'] = questions_df['part'].map(part_agg['var'])\nquestions_df.part_correctness_mean=questions_df.part_correctness_mean.astype('float16')\nquestions_df.part_correctness_std=questions_df.part_correctness_std.astype('float16')","a1c43eb8":"bundle_agg = questions_df.groupby('bundle_id')['content_correctness'].agg(['mean'])\nquestions_df['bundle_correctness'] = questions_df['bundle_id'].map(bundle_agg['mean'])\nquestions_df.bundle_correctness=questions_df.bundle_correctness.astype('float16')","0fa6c675":"tags1_agg = questions_df.groupby('tags1')['content_correctness'].agg(['mean', 'var'])\nquestions_df['tags1_correctness_mean'] = questions_df['tags1'].map(tags1_agg['mean'])\nquestions_df['tags1_correctness_std'] = questions_df['tags1'].map(tags1_agg['var'])\nquestions_df.tags1_correctness_mean=questions_df.tags1_correctness_mean.astype('float16')\nquestions_df.tags1_correctness_std=questions_df.tags1_correctness_std.astype('float16')","43123505":"questions_df.drop(columns=['content_correctness'], inplace=True)\n#questions_df.head(n=10)","668da8d6":"questions_df.dtypes","c755a802":"del bundle_agg\ndel part_agg\ndel tags1_agg\ngc.collect()","24d13a3b":"#pd.set_option(\"display.max_columns\",500)","2b52ac3b":"#questions_df.drop(columns=['tags4','tags5','tags6'], inplace=True)","dd8c22d4":"len(train_df)","3c99d8d0":"train_df['user_correctness'].fillna( 1, inplace=True)\ntrain_df['attempt_no'].fillna(1, inplace=True)\n#\ntrain_df.fillna(0, inplace=True)","47726d75":"#train_df.head(n=10)","c983985a":"#train_df.drop(columns=['content_type_id'], inplace=True)","5fcb4530":"train_df.dtypes","77099637":"features = [\n#   'user_id',\n    'timestamp',\n    'lagtime',\n    'lagtime_mean',\n   # 'content_id',\n   # 'task_container_id',\n    'user_lecture_cumsum', # X\n    'user_lecture_lv',\n    'prior_question_elapsed_time',\n    'delta_prior_question_elapsed_time',\n    'user_correctness',\n    'user_correct_cumcount', #X\n    'user_correct_cumsum', #X\n    'content_correctness',\n   # 'content_correctness_std',\n    'content_count',\n    'content_sum', #X\n    'task_container_correctness',\n   # 'task_container_std',\n   # 'task_container_sum',\n    'bundle_correctness',\n    'attempt_no',\n    'part',\n    'part_correctness_mean',\n   # 'part_correctness_std',\n    'tags1',\n    'tags1_correctness_mean',\n  #  'tags1_correctness_std',\n#HDKIM    'tags2',\n#HDKIM    'tags3',\n#HDKIM    'tags4',\n#HDKIM    'tags5',\n#HDKIM    'tags6',\n    'bundle_id',\n  #  'part_bundle_id',\n    'explanation_mean', \n    'explanation_cumsum',\n    'prior_question_had_explanation',\n#     'part_1',\n#     'part_2',\n#     'part_3',\n#     'part_4',\n#     'part_5',\n#     'part_6',\n#     'part_7',\n#     'type_of_concept',\n#     'type_of_intention',\n#     'type_of_solving_question',\n#     'type_of_starter'\n]\ncategorical_columns= [\n#   'user_id',\n  #  'content_id',\n  # 'task_container_id',\n    'part',        \n    'tags1',\n#HDKIM    'tags2',\n#HDKIM    'tags3',\n#HDKIM    'tags4',\n#HDKIM    'tags5',\n#HDKIM    'tags6',\n    'bundle_id',\n   # 'part_bundle_id',\n    'prior_question_had_explanation',\n#     'part_1',\n#     'part_2',\n#     'part_3',\n#     'part_4',\n#     'part_5',\n#     'part_6',\n#     'part_7',\n#     'type_of_concept',\n#     'type_of_intention',\n#     'type_of_solving_question',\n#     'type_of_starter'\n]\n\n\n","ef6b39ac":"print(psutil.virtual_memory().percent)","9953cc0c":"#import required packages\nimport lightgbm as lgb\nimport xgboost as xgb\nimport catboost as cb\nimport gc\nfrom hyperopt import hp, tpe, Trials, STATUS_OK\nfrom hyperopt.fmin import fmin\nfrom hyperopt.pyll.stochastic import sample\n#optional but advised\nimport warnings\nwarnings.filterwarnings('ignore')\n\n#GLOBAL HYPEROPT PARAMETERS\nNUM_EVALS = 1000 #number of hyperopt evaluation rounds\nN_FOLDS = 5 #number of cross-validation folds on data in each evaluation round\n\n#LIGHTGBM PARAMETERS\nLGBM_MAX_LEAVES = 500 #2**11 #maximum number of leaves per tree for LightGBM\nLGBM_MAX_DEPTH = -1 #25 #maximum tree depth for LightGBM\nEVAL_METRIC_LGBM_REG = 'mae' #LightGBM regression metric. Note that 'rmse' is more commonly used \nEVAL_METRIC_LGBM_CLASS = 'auc'#LightGBM classification metric\n\n#XGBOOST PARAMETERS\nXGB_MAX_LEAVES = 2**12 #maximum number of leaves when using histogram splitting\nXGB_MAX_DEPTH = 25 #maximum tree depth for XGBoost\nEVAL_METRIC_XGB_REG = 'mae' #XGBoost regression metric\nEVAL_METRIC_XGB_CLASS = 'auc' #XGBoost classification metric\n\n#CATBOOST PARAMETERS\nCB_MAX_DEPTH = 8 #maximum tree depth in CatBoost\nOBJECTIVE_CB_REG = 'MAE' #CatBoost regression metric\nOBJECTIVE_CB_CLASS = 'Logloss' #CatBoost classification metric\n\n#OPTIONAL OUTPUT\nBEST_SCORE = 0\n\ndef quick_hyperopt(data, labels, package='lgbm', num_evals=NUM_EVALS, diagnostic=False):\n    \n    #==========\n    #LightGBM\n    #==========\n    \n    if package=='lgbm':\n        \n        print('Running {} rounds of LightGBM parameter optimisation:'.format(num_evals))\n        #clear space\n        gc.collect()\n        \n        integer_params = ['max_depth',\n                         'num_leaves',\n                          'max_bin',\n                         'min_data_in_leaf',\n                         'min_data_in_bin'\n                         ]\n        \n        def objective(space_params):\n            \n            #cast integer params from float to int\n            for param in integer_params:\n                space_params[param] = int(space_params[param])\n            \n            #extract nested conditional parameters\n            if space_params['boosting']['boosting'] == 'goss':\n                top_rate = space_params['boosting'].get('top_rate')\n                other_rate = space_params['boosting'].get('other_rate')\n                #0 <= top_rate + other_rate <= 1\n                top_rate = max(top_rate, 0)\n                top_rate = min(top_rate, 0.5)\n                other_rate = max(other_rate, 0)\n                other_rate = min(other_rate, 0.5)\n                space_params['top_rate'] = top_rate\n                space_params['other_rate'] = other_rate\n            \n            subsample = space_params['boosting'].get('subsample', 1.0)\n            space_params['boosting'] = space_params['boosting']['boosting']\n            space_params['subsample'] = subsample\n            \n            #DONEfor classification, set stratified=True and metrics=EVAL_METRIC_LGBM_CLASS\n            cv_results = lgb.cv(space_params, train, nfold = N_FOLDS, stratified=True,\n                                early_stopping_rounds=100, metrics=EVAL_METRIC_LGBM_CLASS, seed=42)\n            \n            #best_loss = cv_results['l1-mean'][-1] #'l2-mean' for rmse\n            #DONEfor classification, comment out the line above and uncomment the line below:\n            best_loss = 1 - cv_results['auc-mean'][-1]\n            #if necessary, replace 'auc-mean' with '[your-preferred-metric]-mean'\n            return{'loss':best_loss, 'status': STATUS_OK }\n        \n        train = lgb.Dataset(data, labels)\n                \n        #integer and string parameters, used with hp.choice()\n        boosting_list = [{'boosting': 'gbdt',\n                          'subsample': hp.uniform('subsample', 0.5, 1)},\n                         #{'boosting': 'goss',\n                         # 'subsample': 1.0,\n                         #'top_rate': hp.uniform('top_rate', 0, 0.5),\n                         #'other_rate': hp.uniform('other_rate', 0, 0.5)}\n                        ] #if including 'dart', make sure to set 'n_estimators'\n        #metric_list = ['MAE', 'RMSE'] \n        #DONEfor classification comment out the line above and uncomment the line below\n        metric_list = ['auc'] #modify as required for other classification metrics\n        objective_list_reg = ['huber', 'gamma', 'fair', 'tweedie']\n        objective_list_class = ['binary']\n        #DONEfor classification set objective_list = objective_list_class\n        objective_list = objective_list_class\n\n        space ={'boosting' : hp.choice('boosting', boosting_list),\n                'num_leaves' : hp.quniform('num_leaves', 2, LGBM_MAX_LEAVES, 1),\n                'max_depth': int(-1),\n                'max_bin': hp.quniform('max_bin', 32, 255, 1),\n                'min_data_in_leaf': int(20),\n                'min_data_in_bin': int(3),\n                'min_gain_to_split' : float(0.0),\n                'lambda_l1' : hp.uniform('lambda_l1', 0, 5),\n                'lambda_l2' : hp.uniform('lambda_l2', 0, 5),\n                'learning_rate' : hp.loguniform('learning_rate', np.log(0.005), np.log(0.2)),\n                'metric' : hp.choice('metric', metric_list),\n                'objective' : hp.choice('objective', objective_list),\n                'feature_fraction' : hp.quniform('feature_fraction', 0.5, 1, 0.01),\n                'bagging_fraction' : hp.quniform('bagging_fraction', 0.5, 1, 0.01)\n            }\n        \n        #optional: activate GPU for LightGBM\n        #follow compilation steps here:\n        #https:\/\/www.kaggle.com\/vinhnguyen\/gpu-acceleration-for-lightgbm\/\n        #then uncomment lines below:\n        #space['device'] = 'gpu'\n        #space['gpu_platform_id'] = 0,\n        #space['gpu_device_id'] =  0\n\n        trials = Trials()\n        best = fmin(fn=objective,\n                    space=space,\n                    algo=tpe.suggest,\n                    max_evals=num_evals, \n                    trials=trials)\n                \n        #fmin() will return the index of values chosen from the lists\/arrays in 'space'\n        #to obtain actual values, index values are used to subset the original lists\/arrays\n        best['boosting'] = boosting_list[best['boosting']]['boosting']#nested dict, index twice\n        best['metric'] = metric_list[best['metric']]\n        best['objective'] = objective_list[best['objective']]\n                \n        #cast floats of integer params to int\n#        for param in integer_params:\n#            best[param] = int(best[param])\n        \n        print('{' + '\\n'.join('{}: {}'.format(k, v) for k, v in best.items()) + '}')\n        if diagnostic:\n            return(best, trials)\n        else:\n            return(best)\n    \n    else:\n        print('Package not recognised. Please use \"lgbm\" for LightGBM, \"xgb\" for XGBoost or \"cb\" for CatBoost.')","a0daccc7":"flag_lgbm=True\nclfs = list()\nparams = {\n'num_leaves': 350, #350\n'max_bin':700,\n'min_child_weight': 0.03454472573214212,\n'feature_fraction': 0.58, \n'bagging_fraction': 0.58, \n#'min_data_in_leaf': 106,\n'objective': 'binary',\n'max_depth': -1,\n'learning_rate': 0.05, #0.05\n\"boosting_type\": \"gbdt\",\n\"bagging_seed\": 11,\n\"metric\": 'auc',\n\"verbosity\": -1,\n'reg_alpha': 0.3899927210061127,\n'reg_lambda': 0.6485237330340494,\n'random_state': 47\n}\ntrains=list()\nvalids=list()\nnum=1\nfor i in range(0,num):\n  \n    #train_df=train_df.reset_index(drop=True)\n    train_df_clf=train_df.sample(n=500*1000)\n    print('sample end')\n    #train_df.drop(train_df_clf.index, inplace=True)\n    #print('train_df drop end')\n    \n   \n    del train_df\n    \n    users=train_df_clf['user_id'].drop_duplicates()#\u53bb\u91cd\n    \n    users=users.sample(frac=0.025)\n    users_df=pd.DataFrame()\n    users_df['user_id']=users.values\n  \n  \n    valid_df_newuser = pd.merge(train_df_clf, users_df, on=['user_id'], how='inner',right_index=True)\n    del users_df\n    del users\n    gc.collect()\n    #\n    train_df_clf.drop(valid_df_newuser.index, inplace=True)\n   \n    #-----------\n    #train_df_clf=train_df_clf.sample(frac=0.2)\n    #train_df_clf.drop(valid_df_newuser.index, inplace=True)\n    train_df_clf = pd.merge(train_df_clf, questions_df, on='content_id', how='left',right_index=True)#\n    valid_df_newuser = pd.merge(valid_df_newuser, questions_df, on='content_id', how='left',right_index=True)#\n    \n#     train_df_clf = pd.merge(train_df_clf, user_lecture_stats_part, on='user_id', how=\"left\",right_index=True)\n#     valid_df_newuser = pd.merge(valid_df_newuser, user_lecture_stats_part, on='user_id', how=\"left\",right_index=True)\n\n    valid_df=train_df_clf.sample(frac=0.09)\n    train_df_clf.drop(valid_df.index, inplace=True)\n   \n    valid_df = valid_df.append(valid_df_newuser)\n    del valid_df_newuser\n    gc.collect()\n    #\n\n    trains.append(train_df_clf)\n    valids.append(valid_df)\n    print('valid_df length\uff1a',len(valid_df))\n    #train_df=train_df.reset_index(drop=True)","2620ce28":"#del train_df\ndel train_df_clf\ndel valid_df\ngc.collect()","bf391ac3":"labels = trains[i][target].to_numpy()","aeac150f":"data = trains[i][features]","8ff15f25":"#del all other data frames\ndel attempt_no_agg\ndel content_agg\ndel explanation_agg\ndel lagtime_agg\ndel lectures_df\ndel max_timestamp_u\ndel questions_df\ndel tag\ndel task_container_agg\ndel user_agg\ndel user_lecture_agg\ndel user_lecture_stats_part\ndel user_prior_question_elapsed_time \ndel trains\ndel valids\ngc.collect()","500647d4":"lgbm_params = quick_hyperopt(data, labels, 'lgbm', 1000, False)","fb27110e":"\nfor i in range(0,num):\n\n#     \n    tr_data = lgb.Dataset(trains[i][features], label=trains[i][target])\n    va_data = lgb.Dataset(valids[i][features], label=valids[i][target])\n    \n#     del train_df_clf\n#     del valid_df\n#     gc.collect()\n    del trains\n    del valids\n    gc.collect()\n\n    model = lgb.train(\n        lgbm_params, \n        tr_data,\n#         train_df[features],\n#         train_df[target],\n        num_boost_round=50000,\n        #valid_sets=[(train_df[features],train_df[target]), (valid_df[features],valid_df[target])], \n        valid_sets=[tr_data, va_data],\n        early_stopping_rounds=50,\n        feature_name=features,\n        categorical_feature=categorical_columns,\n        verbose_eval=50\n    )\n    clfs.append(model)\n    #print('auc:', roc_auc_score(valid_df[target], model.predict(valid_df[features])))\n    #model.save_model(f'model.txt')\n    lgb.plot_importance(model, importance_type='gain')\n    plt.show()\n\n    del tr_data\n    del va_data\n    gc.collect()\n#    \n# del trains\n# del valids\n# gc.collect()","11b7f78e":"user_sum_dict = user_agg['sum'].astype('int16').to_dict(defaultdict(int))\nuser_count_dict = user_agg['count'].astype('int16').to_dict(defaultdict(int))\ncontent_sum_dict = content_agg['sum'].astype('int32').to_dict(defaultdict(int))\ncontent_count_dict = content_agg['count'].astype('int32').to_dict(defaultdict(int))\n\ndel user_agg\ndel content_agg\ngc.collect()\n\ntask_container_sum_dict = task_container_agg['sum'].astype('int32').to_dict(defaultdict(int))\ntask_container_count_dict = task_container_agg['count'].astype('int32').to_dict(defaultdict(int))\ntask_container_std_dict = task_container_agg['var'].astype('float16').to_dict(defaultdict(int))\n\nexplanation_sum_dict = explanation_agg['sum'].astype('int16').to_dict(defaultdict(int))\nexplanation_count_dict = explanation_agg['count'].astype('int16').to_dict(defaultdict(int))\ndel task_container_agg\ndel explanation_agg\ngc.collect()","74b6bf74":"user_lecture_sum_dict = user_lecture_agg['sum'].astype('int16').to_dict(defaultdict(int))\nuser_lecture_count_dict = user_lecture_agg['count'].astype('int16').to_dict(defaultdict(int))\n\nlagtime_mean_dict = lagtime_agg['mean'].astype('int32').to_dict(defaultdict(int))\n#del prior_question_elapsed_time_agg\ndel user_lecture_agg\ndel lagtime_agg\ngc.collect()","c2c933eb":"attempt_no_agg=attempt_no_agg[attempt_no_agg['sum'] >1]\nattempt_no_sum_dict = attempt_no_agg['sum'].to_dict(defaultdict(int))\n\ndel attempt_no_agg\ngc.collect()","4f8a694f":"max_timestamp_u_dict=max_timestamp_u.set_index('user_id').to_dict()\nuser_prior_question_elapsed_time_dict=user_prior_question_elapsed_time.set_index('user_id').to_dict()\n#del question_elapsed_time_agg\ndel max_timestamp_u\ndel user_prior_question_elapsed_time\ngc.collect()","3e0b5b42":"len(max_timestamp_u_dict['max_time_stamp'])","d4117084":"def get_max_attempt(user_id,content_id):\n    k = (user_id,content_id)\n\n    if k in attempt_no_sum_dict.keys():\n        attempt_no_sum_dict[k]+=1\n        return attempt_no_sum_dict[k]\n\n    attempt_no_sum_dict[k] = 1\n    return attempt_no_sum_dict[k]","8ee2a89f":"print(psutil.virtual_memory().percent)","34315151":"#HDKIM SAKT\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import Dataset, DataLoader\n\nclass FFN(nn.Module):\n    def __init__(self, state_size=200):\n        super(FFN, self).__init__()\n        self.state_size = state_size\n\n        self.lr1 = nn.Linear(state_size, state_size)\n        self.relu = nn.ReLU()\n        self.lr2 = nn.Linear(state_size, state_size)\n        self.dropout = nn.Dropout(0.2)\n    \n    def forward(self, x):\n        x = self.lr1(x)\n        x = self.relu(x)\n        x = self.lr2(x)\n        return self.dropout(x)\n\ndef future_mask(seq_length):\n    future_mask = np.triu(np.ones((seq_length, seq_length)), k=1).astype('bool')\n    return torch.from_numpy(future_mask)\n\nclass SAKTModel(nn.Module):\n    def __init__(self, n_skill, max_seq=MAX_SEQ, embed_dim=128): #HDKIM 100\n        super(SAKTModel, self).__init__()\n        self.n_skill = n_skill\n        self.embed_dim = embed_dim\n\n        self.embedding = nn.Embedding(2*n_skill+1, embed_dim)\n        self.pos_embedding = nn.Embedding(max_seq-1, embed_dim)\n        self.e_embedding = nn.Embedding(n_skill+1, embed_dim)\n\n        self.multi_att = nn.MultiheadAttention(embed_dim=embed_dim, num_heads=8, dropout=0.2)\n\n        self.dropout = nn.Dropout(0.2)\n        self.layer_normal = nn.LayerNorm(embed_dim) \n\n        self.ffn = FFN(embed_dim)\n        self.pred = nn.Linear(embed_dim, 1)\n    \n    def forward(self, x, question_ids):\n        device = x.device        \n        x = self.embedding(x)\n        pos_id = torch.arange(x.size(1)).unsqueeze(0).to(device)\n\n        pos_x = self.pos_embedding(pos_id)\n        x = x + pos_x\n\n        e = self.e_embedding(question_ids)\n\n        x = x.permute(1, 0, 2) # x: [bs, s_len, embed] => [s_len, bs, embed]\n        e = e.permute(1, 0, 2)\n        att_mask = future_mask(x.size(0)).to(device)\n        att_output, att_weight = self.multi_att(e, x, x, attn_mask=att_mask)\n        att_output = self.layer_normal(att_output + e)\n        att_output = att_output.permute(1, 0, 2) # att_output: [s_len, bs, embed] => [bs, s_len, embed]\n\n        x = self.ffn(att_output)\n        x = self.layer_normal(x + att_output)\n        x = self.pred(x)\n\n        return x.squeeze(-1), att_weight\n    \nclass TestDataset(Dataset):\n    def __init__(self, samples, test_df, skills, max_seq=MAX_SEQ): #HDKIM 100\n        super(TestDataset, self).__init__()\n        self.samples = samples\n        self.user_ids = [x for x in test_df[\"user_id\"].unique()]\n        self.test_df = test_df\n        self.skills = skills\n        self.n_skill = len(skills)\n        self.max_seq = max_seq\n\n    def __len__(self):\n        return self.test_df.shape[0]\n\n    def __getitem__(self, index):\n        test_info = self.test_df.iloc[index]\n\n        user_id = test_info[\"user_id\"]\n        target_id = test_info[\"content_id\"]\n\n        q = np.zeros(self.max_seq, dtype=int)\n        qa = np.zeros(self.max_seq, dtype=int)\n\n        if user_id in self.samples.index:\n            q_, qa_ = self.samples[user_id]\n            \n            seq_len = len(q_)\n\n            if seq_len >= self.max_seq:\n                q = q_[-self.max_seq:]\n                qa = qa_[-self.max_seq:]\n            else:\n                q[-seq_len:] = q_\n                qa[-seq_len:] = qa_          \n        \n        x = np.zeros(self.max_seq-1, dtype=int)\n        x = q[1:].copy()\n        x += (qa[1:] == 1) * self.n_skill\n        \n        questions = np.append(q[2:], [target_id])\n        \n        return x, questions\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nSAKT_model = SAKTModel(n_skill, embed_dim=128)\n\ntry:\n    SAKT_model.load_state_dict(torch.load(\"..\/input\/sakt-with-randomization-state-updates\/SAKT-HDKIM.pt\"))\nexcept:\n    SAKT_model.load_state_dict(torch.load(\"..\/input\/sakt-with-randomization-state-updates\/SAKT-HDKIM.pt\", map_location='cpu'))\n\nSAKT_model.to(device)\nSAKT_model.eval()\n\nimport pickle\ngroup = pickle.load(open(\"group.pkl\", \"rb\"))\n\nprint(psutil.virtual_memory().percent)\n\n#HDKIMHDKIM","48e26d6c":"# model = lgb.Booster(model_file='..\/input\/riiid-lgbm-starter\/model.txt')\nenv = riiideducation.make_env()","b699c1bf":"iter_test = env.iter_test()\nprior_test_df = None","0810403e":"%%time\n\nfor (test_df, sample_prediction_df) in iter_test:    \n    if (prior_test_df is not None) & (psutil.virtual_memory().percent<90):\n        print(psutil.virtual_memory().percent)\n        prior_test_df[target] = eval(test_df['prior_group_answers_correct'].iloc[0])\n        prior_test_df = prior_test_df[prior_test_df[target] != -1].reset_index(drop=True)       \n        prior_test_df['prior_question_had_explanation'].fillna(False, inplace=True)       \n        prior_test_df.prior_question_had_explanation=prior_test_df.prior_question_had_explanation.astype('int8')\n        \n        #HDKIM SAKT State Update\n        prev_group = prior_test_df[['user_id', 'content_id', 'answered_correctly']].groupby('user_id').apply(lambda r: (\n            r['content_id'].values,\n            r['answered_correctly'].values))\n        for prev_user_id in prev_group.index:\n            prev_group_content = prev_group[prev_user_id][0]\n            prev_group_ac = prev_group[prev_user_id][1]\n            if prev_user_id in group.index:\n                group[prev_user_id] = (np.append(group[prev_user_id][0],prev_group_content), \n                                       np.append(group[prev_user_id][1],prev_group_ac))\n            else:\n                group[prev_user_id] = (prev_group_content,prev_group_ac)\n            if len(group[prev_user_id][0])>MAX_SEQ:\n                new_group_content = group[prev_user_id][0][-MAX_SEQ:]\n                new_group_ac = group[prev_user_id][1][-MAX_SEQ:]\n                group[prev_user_id] = (new_group_content,new_group_ac)\n\n        #HDKIMHDKIM\n    \n        user_ids = prior_test_df['user_id'].values\n        content_ids = prior_test_df['content_id'].values\n        task_container_ids = prior_test_df['task_container_id'].values\n        prior_question_had_explanations = prior_test_df['prior_question_had_explanation'].values\n        targets = prior_test_df[target].values\n       \n        for user_id, content_id,prior_question_had_explanation,task_container_id,answered_correctly in zip(user_ids, content_ids, prior_question_had_explanations,task_container_ids,targets):\n            user_sum_dict[user_id] += answered_correctly\n            user_count_dict[user_id] += 1         \n            explanation_sum_dict[user_id] += prior_question_had_explanation\n            explanation_count_dict[user_id] += 1\n            \n\n    prior_test_df = test_df.copy()\n    lecture_test_df = test_df[test_df['content_type_id'] == 1].reset_index(drop=True)\n    \n    for i, (user_id,content_type_id, content_id) in enumerate(zip(lecture_test_df['user_id'].values,lecture_test_df['content_type_id'].values,lecture_test_df['content_id'].values)):\n      \n        user_lecture_sum_dict[user_id] += content_type_id\n        user_lecture_count_dict[user_id] += 1\n        #\n        if(len(user_lecture_stats_part[user_lecture_stats_part.user_id==user_id])==0):\n            user_lecture_stats_part = user_lecture_stats_part.append([{'user_id':user_id}], ignore_index=True)\n            user_lecture_stats_part.fillna(0, inplace=True)\n            user_lecture_stats_part.loc[user_lecture_stats_part.user_id==user_id,part_lectures_columns + types_of_lectures_columns]+=lectures_df[lectures_df.lecture_id==content_id][part_lectures_columns + types_of_lectures_columns].values\n        else:\n            user_lecture_stats_part.loc[user_lecture_stats_part.user_id==user_id,part_lectures_columns + types_of_lectures_columns]+=lectures_df[lectures_df.lecture_id==content_id][part_lectures_columns + types_of_lectures_columns].values\n  \n        \n    test_df = test_df[test_df['content_type_id'] == 0].reset_index(drop=True)\n   \n    #HDKIM SAKT\n    test_dataset = TestDataset(group, test_df, skills)\n    test_dataloader = DataLoader(test_dataset, batch_size=51200, shuffle=False)\n    \n    SAKT_outs = []\n\n    for item in test_dataloader:\n        x = item[0].to(device).long()\n        target_id = item[1].to(device).long()\n\n        with torch.no_grad():\n            output, att_weight = SAKT_model(x, target_id)\n \n        output = torch.sigmoid(output)\n        output = output[:, -1]\n        SAKT_outs.extend(output.view(-1).data.cpu().numpy())\n    \n    #HDKIMHDKIM\n\n    test_df['prior_question_had_explanation'].fillna(False, inplace=True)\n    test_df.prior_question_had_explanation=test_df.prior_question_had_explanation.astype('int8')\n    test_df['prior_question_elapsed_time'].fillna(prior_question_elapsed_time_mean, inplace=True)\n    \n\n    user_lecture_sum = np.zeros(len(test_df), dtype=np.int16)\n    user_lecture_count = np.zeros(len(test_df), dtype=np.int16) \n    \n    user_sum = np.zeros(len(test_df), dtype=np.int16)\n    user_count = np.zeros(len(test_df), dtype=np.int16)\n    content_sum = np.zeros(len(test_df), dtype=np.int32)\n    content_count = np.zeros(len(test_df), dtype=np.int32)\n    task_container_sum = np.zeros(len(test_df), dtype=np.int32)\n    task_container_count = np.zeros(len(test_df), dtype=np.int32)\n    task_container_std = np.zeros(len(test_df), dtype=np.float16)\n    content_task_mean = np.zeros(len(test_df), dtype=np.float16)\n    explanation_sum = np.zeros(len(test_df), dtype=np.int32)\n    explanation_count = np.zeros(len(test_df), dtype=np.int32)\n    delta_prior_question_elapsed_time = np.zeros(len(test_df), dtype=np.int32)\n\n    attempt_no_count = np.zeros(len(test_df), dtype=np.int16)\n    lagtime = np.zeros(len(test_df), dtype=np.int32)\n    lagtime_mean = np.zeros(len(test_df), dtype=np.int32)\n   \n    \n    for i, (user_id,prior_question_had_explanation,content_type_id,prior_question_elapsed_time,timestamp, content_id,task_container_id) in enumerate(zip(test_df['user_id'].values,test_df['prior_question_had_explanation'].values,test_df['content_type_id'].values,test_df['prior_question_elapsed_time'].values,test_df['timestamp'].values, test_df['content_id'].values, test_df['task_container_id'].values)):\n         \n        user_lecture_sum_dict[user_id] += content_type_id\n        user_lecture_count_dict[user_id] += 1\n        \n        user_lecture_sum[i] = user_lecture_sum_dict[user_id]\n        user_lecture_count[i] = user_lecture_count_dict[user_id]\n        \n        user_sum[i] = user_sum_dict[user_id]\n        user_count[i] = user_count_dict[user_id]\n        content_sum[i] = content_sum_dict[content_id]\n        content_count[i] = content_count_dict[content_id]\n        task_container_sum[i] = task_container_sum_dict[task_container_id]\n        task_container_count[i] = task_container_count_dict[task_container_id]\n        task_container_std[i]=task_container_std_dict[task_container_id]\n      \n        explanation_sum[i] = explanation_sum_dict[user_id]\n        explanation_count[i] = explanation_count_dict[user_id]\n  \n        if user_id in max_timestamp_u_dict['max_time_stamp'].keys():\n            lagtime[i]=timestamp-max_timestamp_u_dict['max_time_stamp'][user_id]\n            max_timestamp_u_dict['max_time_stamp'][user_id]=timestamp\n            lagtime_mean[i]=(lagtime_mean_dict[user_id]+lagtime[i])\/2           \n        else:\n            lagtime[i]=0\n            max_timestamp_u_dict['max_time_stamp'].update({user_id:timestamp})\n            lagtime_mean_dict.update({user_id:timestamp})\n            lagtime_mean[i]=(lagtime_mean_dict[user_id]+lagtime[i])\/2\n            \n        if user_id in user_prior_question_elapsed_time_dict['prior_question_elapsed_time'].keys():            \n            delta_prior_question_elapsed_time[i]=prior_question_elapsed_time-user_prior_question_elapsed_time_dict['prior_question_elapsed_time'][user_id]\n            user_prior_question_elapsed_time_dict['prior_question_elapsed_time'][user_id]=prior_question_elapsed_time\n        else:           \n            delta_prior_question_elapsed_time[i]=0    \n            user_prior_question_elapsed_time_dict['prior_question_elapsed_time'].update({user_id:prior_question_elapsed_time})\n           \n        \n        \n    \n    #\n    #test_df = pd.merge(test_df, questions_df, on='content_id', how='left',right_index=True)    \n    #test_df = pd.concat([test_df.reset_index(drop=True), questions_df.reindex(test_df['content_id'].values).reset_index(drop=True)], axis=1)\n    test_df=test_df.merge(questions_df.loc[questions_df.index.isin(test_df['content_id'])],\n                  how='left', on='content_id', right_index=True)\n    \n    #test_df = pd.merge(test_df, user_lecture_stats_part, on=['user_id'], how=\"left\",right_index=True)\n    #test_df = pd.concat([test_df.reset_index(drop=True), user_lecture_stats_part.reindex(test_df['user_id'].values).reset_index(drop=True)], axis=1)\n#     test_df=test_df.merge(user_lecture_stats_part.loc[user_lecture_stats_part.index.isin(test_df['user_id'])],\n#                   how='left', on='user_id', right_index=True)\n \n    test_df['user_lecture_lv'] = user_lecture_sum \/ user_lecture_count\n    test_df['user_lecture_cumsum'] = user_lecture_sum\n    test_df['user_correctness'] = user_sum \/ user_count\n    test_df['user_correct_cumcount'] =user_count\n    test_df['user_correct_cumsum'] =user_sum\n    #\n    test_df['content_correctness'] = content_sum \/ content_count\n    test_df['content_count'] = content_count\n    test_df['content_sum'] = content_sum\n    \n    test_df['task_container_correctness'] = task_container_sum \/ task_container_count\n    test_df['task_container_sum'] = task_container_sum \n    test_df['task_container_std'] = task_container_std \n    #test_df['content_task_mean'] = content_task_mean \n    \n    test_df['explanation_mean'] = explanation_sum \/ explanation_count\n    test_df['explanation_cumsum'] = explanation_sum \n    \n    #\n    test_df['delta_prior_question_elapsed_time'] = delta_prior_question_elapsed_time \n    \n  \n \n    test_df[\"attempt_no\"] = test_df[[\"user_id\", \"content_id\"]].apply(lambda row: get_max_attempt(row[\"user_id\"], row[\"content_id\"]), axis=1)\n    test_df[\"lagtime\"]=lagtime\n    test_df[\"lagtime_mean\"]=lagtime_mean\n\n    test_df['user_correctness'].fillna( 1, inplace=True)\n    test_df['attempt_no'].fillna(1, inplace=True)\n    #\n    test_df.fillna(0, inplace=True)\n    \n\n    test_df['timestamp']=test_df['timestamp']\/(1000*3600)\n    test_df.timestamp=test_df.timestamp.astype('int16')\n\n\n    sub_preds = np.zeros(test_df.shape[0])\n    for i, model in enumerate(clfs, 1):\n        test_preds  = model.predict(test_df[features])\n        sub_preds += test_preds\n    #HDKIM\n    #test_df[target] = sub_preds \/ len(clfs) #HDKIM\n    \n    lgbm_final = sub_preds \/ len(clfs)   \n    test_df[target] = np.array(SAKT_outs) * 0.5 + lgbm_final * 0.5\n    #HDKIMHDKIM\n\n    env.predict(test_df[['row_id', target]])","fd1bd408":"Source Kernels\n* Riiid LGBM bagging2 + SAKT =0.781 https:\/\/www.kaggle.com\/ammarnassanalhajali\/riiid-lgbm-bagging2-sakt-0-781\n* SAKT + Riiid LGBM bagging2 LB 0.780 [https:\/\/www.kaggle.com\/leadbest\/sakt-riiid-lgbm-bagging2](http:\/\/)\n* SAKT with Randomization & State Updates LB0.771 https:\/\/www.kaggle.com\/leadbest\/sakt-with-randomization-state-updates\n* Riiid! LGBM bagging2 LB0.772 https:\/\/www.kaggle.com\/zephyrwang666\/riiid-lgbm-bagging2","83a8de08":"#free all ram not passing to hyperopt\ndel attempt_no_agg\ndel categorical_columns\ndel column\ndel content_agg\ndel data_types_dict\ndel defaultdict\ndel explanation_agg\ndel lagtime_agg\ndel max_timestamp_u\ndel tag\ndel task_container_agg\ndel user_agg\ndel user_lecture_agg\ndel user_lecture_stats_part\ndel user_prior_question_elapsed_time\ngc.collect()","13986f39":"# SAKT Part I","ae4681b8":"labels = np.array(train_df['answered_correctly'].astype(np.int32)).reshape((-1, ))","a5d7013f":"#HDKIM \n\nMAX_SEQ = 160\n\nskills = train_df[\"content_id\"].unique()\nn_skill = len(skills)\nprint(\"number skills\", len(skills))\n\ngroup = train_df[['user_id', 'content_id', 'answered_correctly']].groupby('user_id').apply(lambda r: (\n            r['content_id'].values,\n            r['answered_correctly'].values))\n\nfor user_id in group.index:\n    q, qa = group[user_id]\n    if len(q)>MAX_SEQ:\n        group[user_id] = (q[-MAX_SEQ:],qa[-MAX_SEQ:])\n        \nimport pickle\npickle.dump(group, open(\"group.pkl\", \"wb\"))\ndel group\ngc.collect()\n\n#HDKIMHDKIM\n","1709ed59":"# Inference","e6f5c6bc":"train_df.drop(columns = ['answered_correctly'], inplace=True)","0f217539":"# Preprocess","631c3639":"Hyperopt","c9187ce9":"# Train","fbc79f7c":"## Combining of  SAKT with Riiid LGBM bagging2 then remove some features","2e4a7f64":"# SAKT Part II"}}