{"cell_type":{"1b708cca":"code","80a4582f":"code","e3378bb0":"code","7b23bcd5":"code","eb9e6577":"code","65012630":"code","82e0c38e":"code","4ca87f5d":"code","5717522f":"code","7055fc01":"code","7ec0ec4f":"code","4671eef2":"code","e5eba2e4":"code","c2f4ebc5":"code","17517342":"code","f90fa612":"code","08f11ecc":"code","962f0e42":"code","38cd5849":"code","86016d72":"code","a1b954e2":"markdown"},"source":{"1b708cca":"import numpy as np\nimport pandas as pd\nfrom pandas import Series, DataFrame\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nsns.set_style('whitegrid')\nfrom sklearn.cluster import KMeans\nfrom copy import deepcopy","80a4582f":"cust_df= pd.read_csv('..\/input\/Mall_Customers.csv')","e3378bb0":"cust_df.head()","7b23bcd5":"cust_df.describe()","eb9e6577":"cust_df.shape","65012630":"plt.figure(figsize=(5,5))\nsns.distplot(cust_df['Age'] , bins =50)\n","82e0c38e":"plt.figure(figsize=(5,5))\nsns.distplot(cust_df['Spending Score (1-100)'] , bins =50)","4ca87f5d":"plt.figure(figsize=(5,5))\nsns.countplot(\"Gender\",data = cust_df)","5717522f":"plt.figure(figsize=(5,5))\nsns.lmplot(x=\"Annual Income (k$)\",y=\"Spending Score (1-100)\",data=cust_df,hue= \"Gender\")","7055fc01":"X1 = cust_df[['Annual Income (k$)' , 'Spending Score (1-100)']]\ninertia = []\nfor n in range(1 , 11):\n    algorithm = (KMeans(n_clusters = n ,init='k-means++', n_init = 10 ,max_iter=300, \n                        tol=0.0001,  random_state= None  , algorithm='auto') )\n    algorithm.fit(X1)\n    inertia.append(algorithm.inertia_)","7ec0ec4f":"plt.plot(range(1,11), inertia)\nplt.title('The elbow method')\nplt.xlabel('The number of clusters')\nplt.ylabel('Inertia')\nplt.show()","4671eef2":"f1 = cust_df['Annual Income (k$)'].values","e5eba2e4":"f2 = cust_df['Spending Score (1-100)'].values","c2f4ebc5":"X = np.array(list(zip(f1, f2)))","17517342":"plt.scatter(f1, f2, c='black', s=7)","f90fa612":"k=5\nC_x = np.random.randint(0, np.max(X)-20, size=k)\nC_y = np.random.randint(0, np.max(X)-20, size=k)\nC = np.array(list(zip(C_x, C_y)), dtype=np.float32)\nprint(C)","08f11ecc":"plt.scatter(f1, f2, c='#050505', s=7)\nplt.scatter(C_x, C_y, marker='*', s=200, c='g')","962f0e42":"#Euclidian calculator\ndef dist(a, b, ax=1):\n    return np.linalg.norm(a - b, axis=ax)","38cd5849":"# To store the value of centroids when it updates\nC_old = np.zeros(C.shape)\n# Cluster Lables(0, 1, 2)\nclusters = np.zeros(len(X))\n# Error func. - Distance between new centroids and old centroids\nerror = dist(C, C_old, None)\n# Loop will run till the error becomes zero\nwhile error != 0:\n    # Assigning each value to its closest cluster\n    for i in range(len(X)):\n        distances = dist(X[i], C)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    # Storing the old centroid values\n    C_old = deepcopy(C)\n    # Finding the new centroids by taking the average value\n    for i in range(k):\n        points = [X[j] for j in range(len(X)) if clusters[j] == i]\n        C[i] = np.mean(points, axis=0)\n    error = dist(C, C_old, None)","86016d72":"colors = ['r', 'g', 'b', 'y', 'c', 'm']\n\nfig, ax = plt.subplots()\nfor i in range(k):\n        points = np.array([X[j] for j in range(len(X)) if clusters[j] == i])\n        ax.scatter(points[:, 0], points[:, 1], s=7, c=colors[i])\nax.scatter(C[:, 0], C[:, 1], marker='*', s=200, c='#050505')","a1b954e2":"Elbow point is at 5. Therefore Value of k is 5"}}