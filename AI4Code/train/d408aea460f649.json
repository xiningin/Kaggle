{"cell_type":{"d9a13465":"code","4459e70f":"code","aa9eeed2":"code","5e7a4c94":"code","65bb2163":"code","e60c86b2":"code","196ea11a":"code","a90792c9":"code","e15f72c1":"code","66b8fb08":"code","d1b381a8":"code","a371daee":"code","0f1450f3":"code","57d5fe8b":"code","b111a61d":"code","34110a30":"code","d34a2aff":"code","6817c673":"code","c26f54a8":"code","dadd15c7":"code","cf22a45a":"code","85e9a1d5":"code","8770c2e6":"code","a3db5a99":"code","bf6e7ec9":"code","38f7855d":"code","171ca82d":"code","cb772210":"code","1c2bc5a7":"code","4d23b206":"code","42b05e2b":"code","67598bee":"code","ee18daa0":"code","2db91084":"code","4f3d2f34":"code","ee9db08e":"code","075e24f2":"markdown","2330eb2f":"markdown","4a73e3b1":"markdown","57044b9b":"markdown","7d1b0e91":"markdown","df51671f":"markdown","589fea70":"markdown","da811c87":"markdown","8af1a99e":"markdown","6ed96005":"markdown","b3b80364":"markdown","07e3e4b7":"markdown","845453d9":"markdown","8426ce3e":"markdown","b7edb7f6":"markdown","45643354":"markdown","2244cea8":"markdown","ae76a299":"markdown","5124eedc":"markdown","25dfd050":"markdown","6c004224":"markdown","add92dcc":"markdown","670f0c38":"markdown","bd228c8f":"markdown","d75d6956":"markdown","db4e33a1":"markdown","032a1110":"markdown","a88f6487":"markdown","077ada18":"markdown","3520504d":"markdown","3cfa38ca":"markdown"},"source":{"d9a13465":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\nfrom statsmodels.tsa.arima.model import ARIMA\nfrom statsmodels.tsa.stattools import adfuller, kpss\nimport statsmodels.api as sm\nfrom pandas.plotting import autocorrelation_plot\nfrom statsmodels.graphics.tsaplots import plot_acf\nfrom sklearn.metrics import mean_squared_error\nimport datetime ","4459e70f":"# Install pmdarima package. It will be usefull to build the ARIMA model.\n!pip install pmdarima","aa9eeed2":"from pmdarima.arima import auto_arima","5e7a4c94":"# Read Earth temperature dataset\nearthTemp = pd.read_csv('..\/input\/climate-change-earth-surface-temperature-data\/GlobalTemperatures.csv',index_col='dt') #parse_dates=['dt'])\nearthTemp.head(5)","65bb2163":"# See how many null values for each column\nearthTemp.isnull().sum()","e60c86b2":"# Remove lines where the Land & Ocean temperature is null\nearthTemp = earthTemp[earthTemp['LandAndOceanAverageTemperature'].notnull()]","196ea11a":"# Show dataset size\nearthTemp.shape","a90792c9":"# See new dataframe\nearthTemp.head(5)","e15f72c1":"# Convert dt column elements to datetime object\nearthTemp.index = pd.to_datetime(earthTemp.index, format='%Y-%m-%d')  # transform string dates to datatime objects","66b8fb08":"# Get the average temperature for each year and plot the global trend from 1850 year\nfig_dims = (10, 8)\nfig, ax = plt.subplots(figsize=fig_dims)\nearthTemp[\"LandAndOceanAverageTemperature\"].plot(linewidth=1)\nplt.title('Land & Ocean temperature', fontsize=20)\nplt.xlabel('year', fontsize=15)\nplt.ylabel('\u00b0C', fontsize=15)\nplt.grid(True)\n","d1b381a8":"# Plot the year average temperature\n\navgTemp = earthTemp.groupby(earthTemp.index.year).mean()\nfig_dims = (10, 8)\nfig, ax = plt.subplots(figsize=fig_dims)\navgTemp[\"LandAndOceanAverageTemperature\"].plot(linewidth=1)\nplt.title('Land & Ocean temperature', fontsize=20)\nplt.xlabel('year', fontsize=15)\nplt.ylabel('\u00b0C', fontsize=15)\nplt.grid(True)\n\n","a371daee":"meanTemp = earthTemp[\"LandAndOceanAverageTemperature\"].mean()\nearthTemp[\"LandAndOceanAverageTemperatureDelta\"] = earthTemp[\"LandAndOceanAverageTemperature\"] - meanTemp","0f1450f3":"# Plot the difference with respect the mean temperature\n\navgTemp = earthTemp.groupby(earthTemp.index.year).mean()\nfig_dims = (10, 8)\nfig, ax = plt.subplots(figsize=fig_dims)\navgTemp[\"LandAndOceanAverageTemperatureDelta\"].plot(linewidth=1, label ='delta T')\nplt.axhline(y=0, color='r', linestyle='-', label = 'average')\nplt.title('Change in Land & Ocean temperature ', fontsize=20)\nplt.legend(fontsize='x-large')\nplt.xlabel('year', fontsize=15)\nplt.ylabel('\u00b0C', fontsize=15)\nplt.grid(True)","57d5fe8b":"# Plot the difference with respect the mean temperature\n\navgTemp = earthTemp.groupby(earthTemp.index.year).mean()\nfig_dims = (20, 14)\nfig, ax = plt.subplots(figsize=fig_dims)\navgTemp[\"LandAndOceanAverageTemperatureDelta\"].plot.bar(linewidth=1, label ='delta T')\nplt.axhline(y=0, color='r', linestyle='-', label = 'average')\nplt.title('Change in Land & Ocean temperature ', fontsize=20)\nplt.legend(fontsize='x-large')\n# Show only some xticks\nfor i, t in enumerate(ax.get_xticklabels()):\n    if (i % 5) != 0:\n        t.set_visible(False)\nplt.xlabel('year', fontsize=15)\nplt.ylabel('\u00b0C', fontsize=15)\nplt.grid(True)","b111a61d":"decomposition = sm.tsa.seasonal_decompose(earthTemp[\"LandAndOceanAverageTemperatureDelta\"], model='additive')\nfig, (ax1,ax2,ax3) = plt.subplots(3,1, figsize=(15,8))\ndecomposition.trend.plot(ax=ax1)\nax1.set_ylabel('Trend')\ndecomposition.resid.plot(ax=ax2)\nax2.set_ylabel('Residual')\ndecomposition.seasonal.plot(ax=ax3)\nax3.set_ylabel('Seasonal')\nplt.show()","34110a30":"# Check the stationarity of the time series\n#ADF (Augmented Dickey Fuller) Test\n\n#define function for ADF test\ndef adf_test(timeseries):\n    #Perform Dickey-Fuller test:\n    print ('Results of Dickey-Fuller Test:')\n    dftest = adfuller(timeseries, autolag='AIC')\n    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\n    for key,value in dftest[4].items():\n       dfoutput['Critical Value (%s)'%key] = value\n    print (dfoutput)\n\n#apply adf test on the series\nadf_test(earthTemp[\"LandAndOceanAverageTemperatureDelta\"])","d34a2aff":"# Define kpss test function\ndef kpss_test(timeseries):\n    print ('Results of KPSS Test:')\n    kpsstest = kpss(timeseries, regression='c')\n    kpss_output = pd.Series(kpsstest[0:3], index=['Test Statistic','p-value','Lags Used'])\n    for key,value in kpsstest[3].items():\n        kpss_output['Critical Value (%s)'%key] = value\n    print (kpss_output)","6817c673":"#apply kpss_test on the series\nkpss_test(earthTemp[\"LandAndOceanAverageTemperatureDelta\"])","c26f54a8":"plt.figure(figsize=(12, 10))\nearthTemp[\"LandAndOceanAverageTemperature_diff\"] = earthTemp[\"LandAndOceanAverageTemperatureDelta\"].diff(12) # we set 12 that should be the data seasonality because we have monthly data\nearthTemp[\"LandAndOceanAverageTemperature_diff\"] = earthTemp[\"LandAndOceanAverageTemperature_diff\"].dropna()\nearthTemp[\"LandAndOceanAverageTemperature_diff\"].plot()\nplt.title('First Order Differenced Series', fontsize=14)\nplt.xlabel('Year', fontsize=12)\nplt.ylabel('Difference', fontsize=12)\nplt.grid(True)\nplt.show()","dadd15c7":"# See how many null values for each column\n# Remove lines where the Lqnd, Oceqn temperqture is null\nearthTemp = earthTemp[earthTemp['LandAndOceanAverageTemperature_diff'].notna()]","cf22a45a":"# Verify again the criteria\n#apply adf test on the series\nadf_test(earthTemp['LandAndOceanAverageTemperature_diff'])","85e9a1d5":"kpss_test(earthTemp['LandAndOceanAverageTemperature_diff'])","8770c2e6":"# Create a separate dataset for our predictions\nseries = pd.DataFrame(data=earthTemp['LandAndOceanAverageTemperatureDelta'])\nseries.index = earthTemp.index","a3db5a99":"# The function is very expensive from a computational point of view and takes up to 20 minutes to run. \n# If you do not want to wait, the optimal parameters have already been found and are those used in the next step.\n# Obs. for the trend we try with 'ct', constant + linear, however we have seen that the trend of the temperature time series is more complex\n# Another possibility, would be to eliminate the trend by differencing. \n# In this case, the predicted results would refer to the differenced series and in order to get the results related to the original series \n# we would need invert the differentiation.\n# However, here, we try to impose a 'ct' trend (constant+linear).\n# The search for these parameters is limited by the space available in memory, \n# I was forced to limit the search for these parameters due to memory problems in kaggle\n\n\n\nmodel = auto_arima(series['LandAndOceanAverageTemperatureDelta'], \n                       start_p=1,\n                       start_q=1,\n                       max_p=3,\n                       max_q=3,\n                       start_P=1,\n                       start_Q=1,\n                       max_P=2,\n                       max_Q=2,\n                       m=12,\n                       seasonal=True,\n                       d=1,\n                       D=1,\n                       trend = 'ct',\n                       test = 'adf',\n                       trace=True,\n                       error_action='ignore',\n                       suppress_warnings=True,\n                       stepwise=True)\n\nprint(model.summary())","bf6e7ec9":"# Show diagnosis parameters\nmodel.plot_diagnostics(figsize=(14,10))\nplt.show()","38f7855d":"# Construct the model\n# We create a SARIMAX model using the parameter found at previous step\n# As we have seen in our previous analysis the trend of the temperature time series is quite complicated and irregular. \n# We try with a 'ct' trend --> This step could be improved by modeling the trend of the time series or by removing the trend (i.e. by differencing).\n# We need also to specify the seasonality so we add a seasonal_order (where 12 is the seasonality, \n# we have monthly data so the seasonality is 12)\n# As done previously, we don't need to care to give in input the differenced time series, because the SARIMAX function will automatically take care\n# fo this step (we specify the d parameter=1)\n\nmod = sm.tsa.SARIMAX(series['LandAndOceanAverageTemperatureDelta'], order=(0, 1, 3), seasonal_order=(1,1,[1, 2],12), trend='ct')\n# Estimate the parameters\nres = mod.fit()\n\nprint(res.summary())","171ca82d":"# Now that we have fitted the data we can plot the fitted results and compare them wrt original data\n# We just need to specify the start and end index\n# The start index is date of the first sample in our training dataset, the end index is the last index of the last sample in our training dataset\n\nstartDate = series.index[0]\nendDate = series.index[-1]\npredicted = res.predict(start=startDate, end=endDate)\nseries['LandAndOceanAverageTemperaturePredictions'] = predicted","cb772210":"# Compute the mean squared error between the predicted series and the original series \nprint('The mean squared error is:', mean_squared_error(series['LandAndOceanAverageTemperatureDelta'],series['LandAndOceanAverageTemperaturePredictions']))","1c2bc5a7":"plt.figure(figsize=(22,10))\nplt.plot(series.index,series['LandAndOceanAverageTemperatureDelta'],label = \"original\")\nplt.plot(series['LandAndOceanAverageTemperaturePredictions'],label = \"predicted\")\nplt.title(\"Time Series Forecast\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Mean Temperature\")\nplt.legend()\nplt.grid(True)\nplt.show()","4d23b206":"# We could have a better view taking the average for each year\n\n# Convert dt column elements to datetime object\n#earthTemp.index = pd.to_datetime(earthTemp.index, format='%Y-%d-%m')\n# Get the average temperature for each year and plot the global trend from 1750 year\navgTemp = series.groupby(series.index.year).mean()\nfig_dims = (10, 8)\nfig, ax = plt.subplots(figsize=fig_dims)\navgTemp[\"LandAndOceanAverageTemperatureDelta\"].plot(marker='.', linestyle=\"None\", label='Original')\navgTemp[\"LandAndOceanAverageTemperaturePredictions\"].plot(linewidth=1, label='Predicted')\nplt.title('Land & Ocean temperature', fontsize=20)\nplt.xlabel('year', fontsize=15)\nplt.ylabel('\u00b0C', fontsize=15)\nplt.legend(fontsize='x-large')\nplt.grid(True)\n","42b05e2b":"# To make predictions in 40 years, we need to multiply the number of sample per year (12) for 40\nnbStep = 12*40\nforecast = res.get_forecast(steps=nbStep)","67598bee":"# Get a datadictionary with predictions and confidence intervals\nforecast = forecast.summary_frame()","ee18daa0":"# Create a dataframe with the forecast values and the upper and lower values at 95% confidence level\nforecasts = pd.DataFrame(columns = ['LandAndOceanAverageTemperaturePredictions','LandAndOceanAverageTemperaturePredictionsUpper','LandAndOceanAverageTemperaturePredictionsLower'])\nforecasts['LandAndOceanAverageTemperaturePredictions'] = forecast['mean']\nforecasts['LandAndOceanAverageTemperaturePredictionsUpper'] = forecast['mean_ci_upper']\nforecasts['LandAndOceanAverageTemperaturePredictionsLower'] = forecast['mean_ci_lower']\nforecasts.index = forecast.index","2db91084":"plt.figure(figsize=(22,10))\nplt.plot(series.index,series['LandAndOceanAverageTemperatureDelta'],label = \"original\")\nplt.plot(series['LandAndOceanAverageTemperaturePredictions'],label = \"predicted in sample\")\nplt.plot(forecasts['LandAndOceanAverageTemperaturePredictions'],label = \"forecast out of sample\")\nplt.title(\"Time Series Forecast\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Mean Temperature\")\nplt.legend()\nplt.grid(True)\nplt.show()","4f3d2f34":"avgTemp = series.groupby(series.index.year).mean()\navgTempPred = forecasts.groupby(forecasts.index.year).mean()\nfig_dims = (10, 8)\nfig, ax = plt.subplots(figsize=fig_dims)\navgTemp[\"LandAndOceanAverageTemperatureDelta\"].plot(linewidth=1, label='original')\navgTemp[\"LandAndOceanAverageTemperaturePredictions\"].plot(linewidth=1, label='predicted in sample')\navgTempPred[\"LandAndOceanAverageTemperaturePredictions\"].plot(linewidth=1, label='forecast out of sample')\n#ax.fill_between(avgTempPred.index, avgTempPred['LandAndOceanAverageTemperaturePredictionsLower'], avgTempPred['LandAndOceanAverageTemperaturePredictionsUpper'], color='k', alpha=0.1);\nplt.title('Land & Ocean temperature', fontsize=20)\nplt.xlabel('year', fontsize=15)\nplt.ylabel('\u00b0C', fontsize=15)\nplt.legend(fontsize='x-large')\nplt.grid(True)","ee9db08e":"avgTemp = series.groupby(series.index.year).mean()\navgTempPred = forecasts.groupby(forecasts.index.year).mean()\nfig_dims = (10, 8)\nfig, ax = plt.subplots(figsize=fig_dims)\navgTemp[\"LandAndOceanAverageTemperatureDelta\"].plot(linewidth=1, label='original')\navgTemp[\"LandAndOceanAverageTemperaturePredictions\"].plot(linewidth=1, label='predicted in sample')\navgTempPred[\"LandAndOceanAverageTemperaturePredictions\"].plot(linewidth=1, label='forecast out of sample')\nax.fill_between(avgTempPred.index, avgTempPred['LandAndOceanAverageTemperaturePredictionsLower'], avgTempPred['LandAndOceanAverageTemperaturePredictionsUpper'], color='k', alpha=0.1);\nplt.title('Land & Ocean temperature', fontsize=20)\nplt.xlabel('year', fontsize=15)\nplt.ylabel('\u00b0C', fontsize=15)\nplt.legend(fontsize='x-large')\nplt.grid(True)","075e24f2":"## Out-of-sample predictions (forecast)","2330eb2f":"KPSS is another test for checking the stationarity of a time series. The null and alternate hypothesis for the KPSS test are opposite with respect to the Augmented Dickey Fuller.\n\nNull Hypothesis: The process is trend stationary.\n\nAlternate Hypothesis: The series has a unit root (series is not stationary).\n\nIf the test statistic is greater than the critical value, we reject the null hypothesis (series is not stationary). If the test statistic is less than the critical value, if fail to reject the null hypothesis (series is stationary).","4a73e3b1":"In our above example, the test statistic > critical value, which implies that the series is not stationary. However, there are many definitions of stationarity and the results of different tests could be different. In the next section we will try the KPSS test.","57044b9b":"We could also calculate the average temperature between 1850-2015 and then calculate the difference with respect this long term average as it is usually done for temperature analysis.","7d1b0e91":"The time series seems to shows a trend and periodicity. To better visualize the trend, we calculate the average temperature for each year.","df51671f":"<a id=\"Time_series_analysis\"><\/a> <br> \n# **3. Time series stationarity analysis** ","589fea70":"# Global warming analysis & predictions\n\nThe following kernel aims to study the time series of the Earth's temperature in order to address the issue of global warming.\nThe dataset used was made available by [Berkeley Earth](http:\/\/berkeleyearth.org\/about\/) organization and contains data relating to the Land & Oceans temperature of the Earth since 1750. The study of the earth's temperature is a time series that depends on many physical variables:\n- variations in the sun's energy reaching Earth\n- changes in the reflectivity of the Earth's atmosphere and surface\n- changes in the greenhouse effect which affects the amount of the heat retained by Earth's atmosphere\n\nEach of these physical variables is a function of time. Therefore, the models used are extremely heavy complex physical models.\n\nThe following kernel aims to use a purely statistical method, the ARIMA (Autoregressive integrated moving average) method. Usually this method is used in the analysis of economic series. This notebook intends to study its behavior for the analysis of a physical series such as that of the Earth's temperature.","da811c87":"<a id=\"Conclusions\"><\/a> <br> \n# **5. Conclusions** ","8af1a99e":"<a id=\"Data_Analysis\"><\/a> <br> \n# **2. Data Analysis** ","6ed96005":"It is quite evident that our series has a trend superimposed on a seasonality. \n\nIn any case, it is also possible to conduct statistical tests to determine the non-stationarity of a time series, as we will do in the next section.","b3b80364":"We plot the in sample predictions and the out of sample predictions with upper and lower confidence intervals of 95%.","07e3e4b7":"We will now plot the average land\/ocean temperature of each year.  ","845453d9":"Usually when building a model we should split the original series in train and test set. However, the time series demonstrates a particular behaviour in the last 40th years. To avoid to lose information, I decide to use the whole time series to select hyperparameters and to train the model.","8426ce3e":"The non-stationarity of the time series can be seen in a convenient way by decomposing the series into its non-stationary elements as below:","b7edb7f6":"# Table of Contents:\n* **1. [Libraries](#Libraries)** <br>\n* **2. [Data Analysis](#Data_Analysis)** <br>\n* **3. [Time series stationarity analysis](#Time_series_analysis)** <br>\n* ** 3.1 [Augmented Dickey Fuller test](#Dickey_Fuller_test) <br>\n* ** 3.2 [Kpss test](#Kpss_test) <br>\n* **4. [Predictions with ARIMA model](#ARIMA)** <br>\n* **5. [Conclusions](#Conclusions)** <br>\n","45643354":"## In-sample predictions","2244cea8":"ARIMA, autoregressive integrated moving average, is a generalization of an autoregressive moving average (ARMA) model, and combines:\n\n- ****AR****  Autoregression\n\nA future values is predicted as a function of its past values:\n\n$Y_{t} = a + b_1 Y_{t-1} + b_2 Y_{t-2} + b_3 Y_{t-3}$\n\nThe dependency from the past values is defined by the parameter p. In this case p=3, (i.e. the future values depends on the past 3 values)\n\n\n- ****MR****  Moving average\n\nThe predicted variable $Y_{t}$ depends on error of the previous lagged values\n\n$Y_{t} = a + E_{t} + b_1 E_{t-1} + b_2 E_{t-2}$\n\nThe dependency from past errors values is defined by the values q\n\n- ****I****  Integrated\n\nIt differences the data to remove trend and make it stationary. It is defined by the parameter d (i.e. the number of differencing to make the time series stationary)\n\nTherefore, the ARIMA model is the combination of these 3 model and it is defined by parameters (d,q,d)\n\n\nHowever, the ARIMA model is not able to take care of seasonality. This can be done by the SARIMA model (i.e. Seasonal ARIMA).\nIt adds more 4 more parameters P,D,Q,m:\n\n- P is Seasonal AR term\n- Q is seasonal MA term\n- D is seasonal difference order\n- m is the number of time steps for a single seasonal period","ae76a299":"## 3.1 *Augmented Dickey Fuller test* <a id=\"Dickey_Fuller_test\"><\/a>","5124eedc":"In this kernel, we will analyse the Land and Ocean Average Temperature","25dfd050":"How to interpret the previous plots?\n\n-**Standardized residual** There should be no obvious patterns in the residuals --> ok\n\n-**Histogram plus kde estimate** The KDE curve should be very similar to the normal distribution --> seems to be centered (but the peaks are quite far)\n\n-**Normal Q-Q** Most of the data points should lie on the straight line --> Ok (even if we have some points quite far from the straight line at start and at the end)\n\n-**Correlogram** In order to have a good git the 95% of correlations for lag greater than one should not be significant --> Ok\n\nThe previous charts shows that we have found a pretty good model but there is certainly room for improvement, such as better modeling of the trend.","6c004224":"<a id=\"Libraries\"><\/a> <br> \n# **1. Libraries** ","add92dcc":"<a id=\"ARIMA\"><\/a> <br> \n# **4. Predictions with ARIMA model** \n","670f0c38":"From the previous analysis we saw that the time series is a non stationary series. \nThis results could be found also thanks to the Automatic determination of SARIMA parameters.","bd228c8f":"The test statistic is greater than the critical value, we reject the null hypothesis (series is not stationary).\n\nThe difference of the tests is that the ADF test has an alternate hypothesis of linear or difference stationary, while the KPSS test identifies trend-stationarity in a series.\n\nSome definitions:\n\nStrict Stationary: A strict stationary series satisfies the mathematical definition of a stationary process. For a strict stationary series, the mean, variance and covariance are not the function of time. The aim is to convert a non-stationary series into a strict stationary series for making predictions.\n\nTrend Stationary: A series that has no unit root but exhibits a trend is referred to as a trend stationary series. Once the trend is removed, the resulting series will be strict stationary. The KPSS test classifies a series as stationary on the absence of unit root. This means that the series can be strict stationary or trend stationary.\n\nDifference Stationary: A time series that can be made strict stationary by differencing. ADF test is also known as a difference stationarity test.\n\nBoth tests have shown that the time series is non-stationary.","d75d6956":"## 3.2 *KPSS test* <a id=\"Kpss_test\"><\/a>","db4e33a1":"In this kernel we have learned:\n\n- Basic analysis of a time series. Visual inspection to determine stationarity or not\n- Criteria for determining stationarity in a rigorous way\n- ARIMA and SARIMA models to make in-sample predictions and out-of-samples forecast\n- Studied the historical series of Earth Land and Oceans temperature\n\nGlobal warming is a critical issue that will have a very important impact on our lives in the coming years. I hope this notebook can also help raise awareness of people's opinion on the subject.\n\nI hope you enjoyed this kernel and thank you for taking the time to read it.","032a1110":"The same plot could also be seen effectively with a bar plot","a88f6487":"Current studies by NASA estimates that the temperature will rise up 2\u00b0 in 2050 with respect to the long term average if we continue with our national policies. \n\nMy model shows a possible increase of 2.5\u00b0. To compare the models, however, it would be necessary to use the same data and report these increases over the same time period with respect to the long-term average (as a reminder, in the present kernel the variations are referred to the long-term average between 1850 and 2015.). \n\nPotential improvements of the current work could be a better selection of hyperparameters for the SARIMAX model (with a better modeling of the trend). We could also add uncertainties about the measurements that are available in the dataset and that were not used in this work.","077ada18":"We see that just by taking 1 differenciation, we pass both criteria. Therefore, just by taking 1 differenciation we can obtain a stationary series.","3520504d":"In order to develop a good auto-regressive model we should have a stationary timeseries. If the series is non-stationary it should be converted to a stationary one.\n\nJust by looking at the previous plot however, we can see that the series exibits a trend (i.e. non stationary). In any case, we can make more accurate checks by applying tests on the time series.\n\nCheck the stationarity of the time series ADF (Augmented Dickey Fuller) Test\n\nThe Dickey Fuller test could be used to determine the presence of unit root in the series, and hence help us understand if the series is stationary or not. The null and alternate hypothesis of this test are:\n\nNull Hypothesis: The series has a unit root (value of a =1)\n\nAlternate Hypothesis: The series has no unit root.\n\nIf we fail to reject the null hypothesis, we can say that the series is non-stationary. If the test statistic is less than the critical value, we can reject the null hyphotesis (i.e. the series is stationary). If the test statistic is greater than the critical value, we fail to reject the null hypothesis (i.e. the series is not stationary)","3cfa38ca":"Obviously for periods much later in time, the probability margins will be very large."}}