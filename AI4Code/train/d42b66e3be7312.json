{"cell_type":{"4a9b24b4":"code","37e8a89d":"code","c65911fc":"code","5cb06756":"code","20af352b":"code","49d251c1":"code","a1f2eff9":"code","40dedb85":"code","0e8c3d5e":"code","4fa48dd1":"code","29a8cdab":"code","2be2d770":"code","f41ec00a":"code","60242970":"code","2c118266":"code","3ce64629":"code","00de1203":"code","7a2a6dde":"code","fe8ad2b5":"code","1c350c6d":"code","9d371015":"code","bbc36aa5":"code","cfee2ec7":"code","1c2cacca":"code","1a9f2b20":"code","0edc64be":"code","1dce39fa":"code","43d4881a":"code","59d5f8b7":"code","7977cece":"code","7f276c25":"code","e6d5a649":"code","11d7c93c":"code","43003139":"code","35243706":"code","5b4cfbc3":"code","936118e6":"code","beac9220":"code","6a40f5e8":"code","6daa0a31":"code","1fee5095":"code","b92cbe04":"markdown","837a9401":"markdown","930a5ba1":"markdown","aae15648":"markdown","57fa6f02":"markdown","676437da":"markdown","4432978a":"markdown","64de7c63":"markdown","f189f6cd":"markdown","4a3bd91d":"markdown","2a66cbc3":"markdown","5a56dab2":"markdown","40144fb2":"markdown","f74f3c7b":"markdown"},"source":{"4a9b24b4":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\nfrom scipy.stats import norm\nfrom sklearn.preprocessing import StandardScaler\nfrom scipy import stats\nimport warnings\nwarnings.filterwarnings('ignore')\n%matplotlib inline\nfrom sklearn.preprocessing import LabelEncoder\nfrom scipy.stats import norm, skew\nfrom scipy.special import boxcox1p\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import Lasso\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.base import BaseEstimator, TransformerMixin, RegressorMixin, clone\nfrom sklearn.model_selection import KFold, cross_val_score, train_test_split\nfrom sklearn.metrics import mean_squared_error, r2_score","37e8a89d":"df_train = pd.read_csv(\"..\/input\/machine-learning-hebei-north-university\/train.csv\")\ndf_test = pd.read_csv(\"..\/input\/machine-learning-hebei-north-university\/test.csv\")","c65911fc":"df_train.dtypes.array","5cb06756":"sns.distplot(df_train['SalePrice'] , fit=norm);\nfig = plt.figure()\nres = stats.probplot(df_train['SalePrice'], plot=plt)\nplt.show()","20af352b":"df_train[\"SalePrice\"] = np.log1p(df_train[\"SalePrice\"])","49d251c1":"sns.distplot(df_train['SalePrice'] , fit=norm);\nfig = plt.figure()\nres = stats.probplot(df_train['SalePrice'], plot=plt)\nplt.show()","a1f2eff9":"sns.set()\ncols = ['SalePrice', 'OverallQual', 'GrLivArea', 'GarageCars', 'TotalBsmtSF', 'FullBath', 'YearBuilt']\nsns.pairplot(df_train[cols], size = 2.5)\nplt.show();","40dedb85":"sns.pairplot(df_train[[\"SalePrice\", 'GrLivArea']])","0e8c3d5e":"df_train.drop(df_train[(df_train['GrLivArea']>4000) & (df_train['SalePrice']<300000)].index, inplace=True)","4fa48dd1":"corrmat = df_train.corr()","29a8cdab":"k = 10\ncols = corrmat.nlargest(k, 'SalePrice')['SalePrice'].index\ncm = np.corrcoef(df_train[cols].values.T)\nsns.set(font_scale=1.25)\nhm = sns.heatmap(cm, cbar=True, annot=True, \n                 square=True, fmt='.2f', annot_kws={'size': 10}, yticklabels=cols.values, xticklabels=cols.values)\nplt.show()","2be2d770":"target = df_train.SalePrice.copy()","f41ec00a":"df = pd.concat((df_train, df_test)).reset_index(drop=True)\ndf.drop(['SalePrice'], axis=1, inplace=True)\nprint(\"all_data size is : {}\".format(df.shape))","60242970":"total = df.isnull().sum().sort_values(ascending=False)\npercent = (df.isnull().sum() \/ df.isnull().count()).sort_values(ascending=False)\nmissing_data = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])\nmissing_data.head(20)","2c118266":"for col in [\"PoolQC\", \"MiscFeature\", \"Alley\", \"Fence\", \"FireplaceQu\"] :\n    df[col] = df[col].fillna(\"No\")\nfor col in ['GarageType', 'GarageFinish', 'GarageQual', 'GarageCond']:\n    df[col] = df[col].fillna('No')\nfor col in ['GarageYrBlt', 'GarageArea', 'GarageCars']:\n    df[col] = df[col].fillna(0)\nfor col in ['BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF','TotalBsmtSF', 'BsmtFullBath', 'BsmtHalfBath']:\n    df[col] = df[col].fillna(0)\nfor col in ['BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2']:\n    df[col] = df[col].fillna('No')","3ce64629":"df[\"MasVnrType\"] = df[\"MasVnrType\"].fillna(\"None\")\ndf[\"MasVnrArea\"] = df[\"MasVnrArea\"].fillna(0)","00de1203":"df.MSZoning.hist()","7a2a6dde":"df['MSZoning'] = df['MSZoning'].fillna(df['MSZoning'].mode()[0])","fe8ad2b5":"df[\"Functional\"] = df[\"Functional\"].fillna(\"Typ\")","1c350c6d":"df[\"LotFrontage\"] = df.groupby(\"Neighborhood\")[\"LotFrontage\"].transform(lambda x: x.fillna(x.median()))\ntotal = df.isnull().sum().sort_values(ascending=False)\npercent = (df.isnull().sum() \/ df.isnull().count()).sort_values(ascending=False)\nmissing_data = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])\nmissing_data.head(20)","9d371015":"df['KitchenQual'] = df['KitchenQual'].fillna(df['KitchenQual'].mode()[0])","bbc36aa5":"df['MSSubClass'] = df['MSSubClass'].fillna(\"No\")\ndf['Exterior1st'] = df['Exterior1st'].fillna(df['Exterior1st'].mode()[0])\ndf['Exterior2nd'] = df['Exterior2nd'].fillna(df['Exterior2nd'].mode()[0])\ndf['Electrical'] = df['Electrical'].fillna(df['Electrical'].mode()[0])\ndf.drop([\"Utilities\"], axis=1, inplace=True)","cfee2ec7":"for col in [\"MSSubClass\", \"OverallCond\", \"YrSold\", \"MoSold\"]:\n    df[col] = df[col].apply(str)","1c2cacca":"##Ordinal Encoding for those variables:\ncols = ('FireplaceQu', 'BsmtQual', 'BsmtCond', 'GarageQual', 'GarageCond', \n        'ExterQual', 'ExterCond','HeatingQC', 'PoolQC', 'KitchenQual', 'BsmtFinType1', \n        'BsmtFinType2', 'Functional', 'Fence', 'BsmtExposure', 'GarageFinish', 'LandSlope',\n        'LotShape', 'PavedDrive', 'Street', 'Alley', 'CentralAir', 'MSSubClass', 'OverallCond', \n        'YrSold', 'MoSold')\n\nfor c in cols:\n    lbl = LabelEncoder() \n    lbl.fit(list(df[c].values)) \n    df[c] = lbl.transform(list(df[c].values))","1a9f2b20":"\nnumeric_feats = df.dtypes[df.dtypes != \"object\"].index\nskewed_feats = df[numeric_feats].apply(lambda x: skew(x)).sort_values(ascending=False)\nskewness = pd.DataFrame({'Skew' : skewed_feats})\nskewness.head(10)","0edc64be":"skewed_features = skewness.index\nlam = 0.15\nfor col in skewed_features:\n    df[col] = boxcox1p(df[col], lam)","1dce39fa":"df.drop([\"Id\"], axis=1, inplace=True)\ndf = pd.get_dummies(df)\ntrain = df[:df_train.shape[0]]\ntest = df[df_train.shape[0]:]","43d4881a":"num_vars = train.select_dtypes(include=['int64','float64']).columns\nscaler = StandardScaler()\ntrain[num_vars] = scaler.fit_transform(train[num_vars])\ntest[num_vars] = scaler.transform(test[num_vars])","59d5f8b7":"X_train, X_test, y_train, y_test = train_test_split(train, target, test_size=0.2, random_state=42)","7977cece":"params = {'alpha': [0.0001, 0.001, 0.01, 0.05, 0.1, \n                 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 2.0, 3.0, \n                 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 20, 50, 100]\n         }\n\n\nridge = Ridge()\n\nfolds = 5\nmodel_cv = GridSearchCV(estimator = ridge, \n                        param_grid = params, \n                        scoring= 'neg_mean_squared_error', \n                        cv = folds, \n                        return_train_score=True,\n                        verbose = 1)    \n\nmodel_cv.fit(X_train, y_train) ","7f276c25":"ridge = model_cv.best_estimator_","e6d5a649":"y_train_pred_ridge = ridge.predict(X_train)\nprint(r2_score(y_true=y_train, y_pred=y_train_pred_ridge))","11d7c93c":"y_test_pred_ridge = ridge.predict(X_test)\nprint(r2_score(y_true=y_test, y_pred=y_test_pred_ridge))","43003139":"print ('RMSE Validation is: \\n', mean_squared_error(y_test, y_test_pred_ridge))","35243706":"params = {'alpha': [0.00005, 0.0001, 0.001, 0.008, 0.01]}\nlasso = Lasso()\n\nmodel_cv_l = GridSearchCV(estimator = lasso, \n                        param_grid = params, \n                        scoring= 'neg_mean_squared_error', \n                        cv = folds, \n                        return_train_score=True,\n                        verbose = 1)            \n\nmodel_cv_l.fit(X_train, y_train)","5b4cfbc3":"lasso = model_cv_l.best_estimator_","936118e6":"y_train_pred_lasso = lasso.predict(X_train)\nprint(r2_score(y_true=y_train, y_pred=y_train_pred_lasso))","beac9220":"y_test_pred_lasso = lasso.predict(X_test)\nprint(r2_score(y_true=y_test, y_pred=y_test_pred_lasso))","6a40f5e8":"print ('RMSE Validation is: \\n', mean_squared_error(y_test, y_test_pred_lasso))","6daa0a31":"preds = np.exp(ridge.predict(test))\npredictions = pd.DataFrame({'Id': df_test['Id'] ,'SalePrice': preds })\npredictions.to_csv(\"preds.csv\",index=False)","1fee5095":"predictions.SalePrice","b92cbe04":"\u63d2\u8865\u7f3a\u5931\u6570\u636e","837a9401":"\u5e94\u7528\u4e00\u4e2a\u70ed\u7f16\u7801","930a5ba1":"\u68c0\u67e5\u504f\u5ea6","aae15648":"\u8bad\u7ec3\u6a21\u578b","57fa6f02":"\u8bfb\u53d6\u6570\u636e","676437da":"\u63a2\u7d22\u76ee\u6807\u53d8\u91cf","4432978a":"\u5173\u4e8e\u6570\u636e\u7684\u4ecb\u7ecd","64de7c63":"\u5c1d\u8bd5\u5cad\u56de\u5f52","f189f6cd":"\u4f7f\u7528Python\u5220\u9664\u5f02\u5e38\u503c","4a3bd91d":"\u5904\u7406\u7f3a\u5931\u6570\u636e","2a66cbc3":"\u5269\u4e0b\u7684\u7279\u6027\u53ea\u67091\u62162\u4e2aNA\u503c\uff0c\u6240\u4ee5\u53ef\u4ee5\u653e\u5f03","5a56dab2":"\u51c6\u5907\u63d0\u4ea4","40144fb2":"paireplot\u5e2e\u52a9\u533a\u5206\u53d8\u91cf\u672c\u8eab\u7684\u5206\u5e03\u548c\u53d8\u91cf\u4e4b\u95f4\u7684\u5173\u7cfb","f74f3c7b":"\u5e94\u7528\u6700\u5f3a\u5927\u7684\u8f6c\u6362\u6cd5\u4e4b\u4e00Box-cox\u8f6c\u6362"}}