{"cell_type":{"9cc17dd9":"code","5db0df9d":"code","2c5a868a":"code","a1a5ff9f":"code","24198649":"code","49110fad":"code","74bd3427":"code","1c1f187e":"code","4dbaa31f":"code","53559a8e":"code","5e1b29da":"code","39d75c5e":"code","889e5a09":"code","f18e754b":"markdown","9275d5a3":"markdown","4f7fad3a":"markdown"},"source":{"9cc17dd9":"import os\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nfrom subprocess import check_output\nprint(check_output([\"ls\", \"..\/input\"]).decode(\"utf8\"))","5db0df9d":"G = pd.read_csv('\/kaggle\/input\/distance-is-all-you-need-hyper-search\/submission.csv') #old dis hyp plb:-1.770","2c5a868a":"sub_path = \"..\/input\/chemistry-models\"\nall_files = os.listdir(sub_path)\nall_files","a1a5ff9f":"import warnings\nwarnings.filterwarnings(\"ignore\")\n\nouts = [pd.read_csv(os.path.join(sub_path, f), index_col=0) for f in all_files]\nconcat_sub = pd.concat(outs, axis=1)\ncols = list(map(lambda x: \"mol\" + str(x), range(len(concat_sub.columns))))\nconcat_sub.columns = cols\n# concat_sub['mod_H'] = G['scalar_coupling_constant']\nconcat_sub.reset_index(inplace=True)\n\nconcat_sub.head()\nncol = concat_sub.shape[1]\n","24198649":"concat_sub.head(5)","49110fad":"\nschnet  =  pd.read_csv(\"..\/input\/schnet-starter-kit\/kernel_schnet.csv\")\nconcat_sub['new_mod_H'] = G.scalar_coupling_constant\nconcat_sub['schnet_mod_H'] = schnet.scalar_coupling_constant\n\n","74bd3427":"concat_sub.head(6)","1c1f187e":"# check correlation\nconcat_sub.iloc[:,1:].corr()","4dbaa31f":"corr = concat_sub.iloc[:,1:].corr()\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\n# Set up the matplotlib figure\nf, ax = plt.subplots(figsize=(11, 9))\n\n# Generate a custom diverging colormap\ncmap = sns.diverging_palette(220, 10, as_cmap=True)\n\n# Draw the heatmap with the mask and correct aspect ratio\nsns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})","53559a8e":"concat_sub.drop('mol4', axis=1, inplace=True)","5e1b29da":"concat_sub.iloc[:,1:].corr()","39d75c5e":"concat_sub['m_median'] = concat_sub.iloc[:, 1:8].median(axis=1)","889e5a09":"concat_sub['scalar_coupling_constant'] = concat_sub['m_median']\nconcat_sub[['id', 'scalar_coupling_constant']].to_csv('stack_median.csv', \n                                        index=False, float_format='%.6f')","f18e754b":"# Median Stacking","9275d5a3":"## Stacking the Best Models\n<pre><b>\nThis Kernel shows how the scores can be improved using Stacking Method.\nCredit Goes to the following kernels\nref:\n1. https:\/\/www.kaggle.com\/criskiev\/distance-is-all-you-need-lb-1-481\n2. https:\/\/www.kaggle.com\/marcelotamashiro\/lgb-public-kernels-plus-more-features\n3. https:\/\/www.kaggle.com\/scaomath\/no-memory-reduction-workflow-for-each-type-lb-1-28\n4. https:\/\/www.kaggle.com\/fnands\/1-mpnn\n5. https:\/\/www.kaggle.com\/harshit92\/fork-from-kernel-1-481\n6. https:\/\/www.kaggle.com\/marcogorelli\/criskiev-s-distances-more-estimators-groupkfold?scriptVersionId=18843561\n<\/b><\/pre>","4f7fad3a":"# A big thanks to [roydatascience](https:\/\/www.kaggle.com\/roydatascience)"}}