{"cell_type":{"137f09dd":"code","8eeb2307":"code","d45b016e":"code","f7e92ca9":"code","6a4ec5bb":"code","cb30dc63":"code","cab0b44c":"code","75a80ccf":"code","bf0510d3":"code","f7eacd22":"code","a5e83f91":"code","3f6eebfd":"code","cf68ef6f":"code","3560acb4":"code","c6e83c09":"code","0f69ede4":"code","4c4f9093":"code","500c5bfc":"code","71614b73":"code","cdc118c5":"code","824dab82":"code","f9ccbf62":"code","8927bdbc":"code","fbc5520e":"code","1561f7b3":"code","64a96074":"code","28afe06a":"code","65de0418":"code","a6947ee2":"code","f62629b1":"code","c890f293":"code","6f43263d":"code","5c4ec0cb":"code","c032ac47":"code","05a1d12d":"code","db408854":"code","5fb05bea":"code","bc341454":"markdown","e26a733e":"markdown","dd33382c":"markdown","62442df7":"markdown","f9f175dc":"markdown","17403b82":"markdown","9dc1084e":"markdown","327606cb":"markdown","16ccf7e4":"markdown","69107a82":"markdown","3ad30911":"markdown","fbbccd76":"markdown","76b9de2d":"markdown","6ec12f81":"markdown","4ee27d2b":"markdown","d6d5d8da":"markdown","19e70d90":"markdown","2b8598ff":"markdown"},"source":{"137f09dd":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport cv2\nimport glob\n\n%matplotlib inline","8eeb2307":"labels_df = pd.read_csv('..\/input\/labels.csv')\nlabels = np.array(labels_df[' hemorrhage'].tolist())\n\nfiles = sorted(glob.glob('..\/input\/head_ct\/head_ct\/*.png'))\nimages = np.array([cv2.imread(path) for path in files])","d45b016e":"labels_df[' hemorrhage'].hist(bins=2)","f7e92ca9":"images_df = pd.DataFrame(images, columns=['image'])","6a4ec5bb":"images_df['width'] = images_df['image'].apply(lambda x: x.shape[0])\nimages_df['height'] = images_df['image'].apply(lambda x: x.shape[1])","cb30dc63":"images_df[['height', 'width']].hist(bins=20)","cab0b44c":"images_df[['height', 'width']].describe()","75a80ccf":"images = np.array([cv2.resize(image, (128, 128)) for image in images])","bf0510d3":"plt.imshow(images[0])","f7eacd22":"plt.imshow(images[100])","a5e83f91":"plt.figure(figsize=(12, 12))\nfor i, flip in enumerate([None, -1, 0, 1]):\n    plt.subplot(221 + i)\n    if flip is None:\n        plt.imshow(images[0])\n    else:\n        plt.imshow(cv2.flip(images[0], flip))","3f6eebfd":"print(labels)","cf68ef6f":"# since data is strictly true until index 100 and then strictly false,\n# we can take random 90 entries from frist half and then random 90 from the second half\n# to have evenly distributed train and test sets\nindicies = np.random.permutation(100)\ntrain_true_idx, test_true_idx = indicies[:90], indicies[90:]\ntrain_false_idx, test_false_idx = indicies[:90] + 100, indicies[90:] + 100\ntrain_idx, test_idx = np.append(train_true_idx, train_false_idx), np.append(test_true_idx, test_false_idx)\n\ntrain_validationX, train_validationY = images[train_idx], labels[train_idx]\ntestX, testY = images[test_idx], labels[test_idx]\n\nprint(train_validationX.shape, testX.shape)\nprint(train_validationY.shape, testY.shape)","3560acb4":"# now to split train and validation sets\ntr_len = train_validationX.shape[0]\ntrain_val_split = int(tr_len*0.9)\nindicies = np.random.permutation(tr_len)\ntrain_idx, validation_idx = indicies[:train_val_split], indicies[train_val_split:]\n\ntrainX, trainY = train_validationX[train_idx], train_validationY[train_idx]\nvalidationX, validationY = train_validationX[validation_idx], train_validationY[validation_idx]\n\nprint(trainX.shape, validationX.shape)\nprint(trainY.shape, validationY.shape)","c6e83c09":"import keras","0f69ede4":"from keras.models import Sequential\nfrom keras.layers import Dense, Input, Flatten, Dropout, Conv2D, MaxPooling2D, GlobalAveragePooling2D, GlobalMaxPooling2D\nfrom keras.callbacks import ModelCheckpoint\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom sklearn.metrics import confusion_matrix\n\nimport math","4c4f9093":"train_image_data = ImageDataGenerator(\n    rescale=1.\/255,\n    shear_range=0.,\n    zoom_range=0.05,\n    rotation_range=180,\n    width_shift_range=0.05,\n    height_shift_range=0.05,\n    horizontal_flip=True,\n    vertical_flip=True,\n    fill_mode='constant',\n    cval=0\n)\nvalidation_image_data = ImageDataGenerator(\n    rescale=1.\/255,\n    shear_range=0.,\n    zoom_range=0.05,\n    rotation_range=90,\n    width_shift_range=0.05,\n    height_shift_range=0.05,\n    horizontal_flip=True,\n    vertical_flip=True,\n    fill_mode='constant',\n    cval=0)","500c5bfc":"plt.figure(figsize=(12, 12))\nfor X_batch, y_batch in train_image_data.flow(trainX, trainY, batch_size=9):\n    for i in range(0, 9):\n        plt.subplot(330 + 1 + i)\n        plt.imshow(X_batch[i])\n    plt.show()\n    break","71614b73":"def check_accuracy(model, setX, actual, print_images=True):\n    predicted = np.array([int(x[0] > 0.5) for x in model.predict(setX)])\n    if print_images:\n        rows = math.ceil(len(predicted)\/10.)\n        plt.figure(figsize=(20, 3 * rows))\n        for i in range(len(predicted)):\n            plt.subplot(rows, 10, i+1)\n            plt.imshow(setX[i])\n            plt.title(\"pred \"+str(predicted[i])+\" actual \"+str(actual[i]))\n        \n    confusion = confusion_matrix(actual, predicted)\n    tn, fp, fn, tp = confusion.ravel()\n    print(\"True positive:\", tp, \", True negative:\", tn,\n          \", False positive:\", fp, \", False negative:\", fn)\n\n    print(\"Total accuracy:\", np.sum(predicted==actual) \/ len(predicted) * 100., \"%\")\n    return (tn, fp, fn, tp)","cdc118c5":"def simple_conv_model(input_shape):\n    model = Sequential()\n    \n    model.add(Conv2D(32, kernel_size=3, strides=2, padding='same', activation='relu', input_shape=input_shape))\n    model.add(MaxPooling2D(pool_size=2))\n    model.add(Conv2D(32, kernel_size=3, strides=2, padding='same', activation='relu'))\n    model.add(MaxPooling2D(pool_size=2))\n    model.add(Conv2D(64, kernel_size=3, strides=2, padding='same', activation='relu'))\n    \n    model.add(GlobalAveragePooling2D())\n    model.add(Dropout(0.4))\n    \n    model.add(Dense(32, activation='relu'))\n    model.add(Dropout(0.4))\n    \n    model.add(Dense(1, activation='sigmoid'))\n    return model","824dab82":"model = simple_conv_model((128, 128, 3))\nmodel.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=['accuracy'])","f9ccbf62":"model.summary()","8927bdbc":"model.fit_generator(train_image_data.flow(trainX, trainY, batch_size=128),\n    steps_per_epoch=128,\n    validation_data=validation_image_data.flow(validationX, validationY, batch_size=16),\n    validation_steps=100,\n    callbacks=[ModelCheckpoint(\"weights.h5\", monitor='val_acc', save_best_only=True, mode='max')],\n    epochs=16)","fbc5520e":"check_accuracy(model, validationX\/255., validationY)","1561f7b3":"model.save(\"last-weights.h5\")\nmodel.load_weights(\"weights.h5\")","64a96074":"check_accuracy(model, trainX\/255., trainY, False)","28afe06a":"check_accuracy(model, validationX\/255., validationY)","65de0418":"def imbalance_set(coeff=2):\n    imbalanced_trainX = []\n    imbalanced_trainY = []\n    for i, train_x in enumerate(trainX):\n        def add_entry(x, y):\n            imbalanced_trainX.append(x)\n            imbalanced_trainY.append(y)\n\n        add_entry(train_x, trainY[i])\n\n        if(trainY[i] == 1):\n            for j in range(coeff-1):\n                add_entry(train_x, trainY[i])\n    return (np.array(imbalanced_trainX), np.array(imbalanced_trainY))\n\nimbalanced_trainX, imbalanced_trainY = imbalance_set(2)\nprint(imbalanced_trainX.shape, imbalanced_trainY.shape)","a6947ee2":"def bigger_conv_model(input_shape):\n    model = Sequential()\n    \n    model.add(Conv2D(32, kernel_size=3, strides=2, padding='same', activation='relu', input_shape=input_shape))\n    model.add(MaxPooling2D(pool_size=2))\n    model.add(Conv2D(32, kernel_size=3, strides=2, padding='same', activation='relu'))\n    model.add(MaxPooling2D(pool_size=2))\n    model.add(Conv2D(64, kernel_size=3, strides=2, padding='same', activation='relu'))\n    \n    model.add(GlobalAveragePooling2D())\n    model.add(Dropout(0.4))\n    \n    model.add(Dense(64, activation='relu'))\n    model.add(Dropout(0.4))\n    \n    model.add(Dense(1, activation='sigmoid'))\n    return model","f62629b1":"model = bigger_conv_model((128, 128, 3))\nmodel.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=['accuracy'])\nmodel.summary()","c890f293":"model.fit_generator(train_image_data.flow(imbalanced_trainX, imbalanced_trainY, batch_size=128),\n    steps_per_epoch=128,\n    validation_data=validation_image_data.flow(validationX, validationY, batch_size=16),\n    validation_steps=100,\n    callbacks=[ModelCheckpoint(\"bigger_model_checkpoint_weights.h5\", monitor='val_acc', save_best_only=True, mode='max')],\n    epochs=24)","6f43263d":"check_accuracy(model, trainX\/255., trainY, False)","5c4ec0cb":"check_accuracy(model, validationX\/255., validationY, False)","c032ac47":"model.save(\"bigger_model_latest_weights.h5\")\nmodel.load_weights(\"bigger_model_checkpoint_weights.h5\")","05a1d12d":"check_accuracy(model, trainX\/255., trainY, False)","db408854":"check_accuracy(model, validationX\/255., validationY, False)","5fb05bea":"check_accuracy(model, testX\/255., testY)","bc341454":"# Image augmentation","e26a733e":"Split data into train, validation and test subsets.","dd33382c":"Punishing false negatives may be implemented in several ways.\n* imbalance dataset so there are more positive cases, therefore model will prefer false positives over false negatives\n* make it a multiclass classification and use 'class_weight' parameter of Keras (which is essentially will do the same trick)\n* write custom loss function that is oriented on lowering false negativer rate (or improving _sensitivity_)\n* or write custom metrics, based on which checkpoint will save model\n\nLet's try the approach with imbalancing training dataset.","62442df7":"# Adding flipped images","f9f175dc":"# False negative result will kill patient\nFalse positive result will be an inconvinience.\n\nWe have to punish false negative results while training the model.","17403b82":"# 89% of accuracy on validation set and 0 false negative\nTime to check model on test set","9dc1084e":"The overall generalization of model seems good, overfitting isn't too big. But since this is a medical problem, we have to consider one additional thing.","327606cb":"Model showed good results.\n\nAdditional improvements could be made if image augmentation contained alterations of contrast.","16ccf7e4":"We could also improve the dataset by adding flipped images. It doesn't matter from what side we will look at the CT scan, brain hemorrhage can and should be diagnosed just as well. By adding flipped images to dataset, we can greatly increase the accuracy of model.","69107a82":"# Training model","3ad30911":"model.fit(imbalanced_trainX, imbalanced_trainY, validation_data=(validationX, validationY),\n          callbacks=[ModelCheckpoint(\"weights-fna-model.hdf5\", monitor='val_acc', save_best_only=True, mode='max')],\n          batch_size=128, epochs=200)","fbbccd76":"Now, we don't want those flipped images in our test set just to be sure model didn't create any preferences for upside down and flipped images, so the dataset expansion should take place after split into train and test sets.\n\nFortunately, there is ImageDataGenerator for the purposes of flipping and rotating images.","76b9de2d":"# Initial data exploration","6ec12f81":"There is the same amount of data for both cases.","4ee27d2b":"# Building the model","d6d5d8da":"Before we will create and train model, we need to make all images the same sizes.\n\nThe tradeoff is simple here - lesser images would be faster to train, there would be a lot of examples so lesser chance of overfitting, but it is a clear loss of information. If the error would be still big, we will need to consider to use a bigger size, and either stretch little images (and lose quality significantly) or drop them entirely (and risk overfitting).\n\nFor now we will go the simplest path - resizing to the smallest size (and even smaller - 128 insted of 134).","19e70d90":"Images are not the same sizes! We need to find the optimal size, but before we have to explore it.","2b8598ff":"The quality of images seems to be acceptable."}}