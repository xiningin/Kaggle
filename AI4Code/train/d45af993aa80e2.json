{"cell_type":{"00f2c0b2":"code","07ad2f28":"code","b5ae8e01":"code","b28bd82d":"code","835b268d":"code","ca44e8f2":"code","888d74f7":"code","c87892f0":"code","ea7ad06b":"code","c7240c62":"code","19f275b1":"code","19cd8cf4":"code","a13c9d2f":"code","6060e853":"code","a3bafaaa":"code","52401eb6":"code","fceb86ce":"code","e958507b":"code","4a2e8bb5":"code","090a36d5":"code","6fef2819":"code","6c1debdf":"code","43277198":"code","444ff1c8":"code","2103468f":"code","fbd6c31d":"code","bb506634":"code","3b681c2a":"code","e0bd048e":"code","14725190":"code","a9cb22e3":"code","82d57f7c":"code","70c45823":"code","88aaafd6":"code","d0d83a3a":"code","9532a8ea":"code","78af14b1":"code","e82115bc":"code","da5af367":"code","a9453961":"code","22162ef6":"code","11dca860":"code","a7b72638":"code","21c80f34":"code","dc57b012":"markdown","b23af8b4":"markdown","95216df4":"markdown","8203fd8a":"markdown","917143f8":"markdown","4d0660c0":"markdown","592fdfb2":"markdown","8194e782":"markdown","90e2f246":"markdown","6710b759":"markdown","cbb4ae69":"markdown","7fc7f747":"markdown","6562372b":"markdown","8e3eacf6":"markdown","ec7a0333":"markdown","823208db":"markdown","bb0b9686":"markdown"},"source":{"00f2c0b2":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\npd.set_option(\"display.max_rows\",20)\npd.set_option(\"display.max_columns\",None)\n","07ad2f28":"solarpower = pd.read_csv(\"..\/input\/solarpanelspower\/metingen_4sept2021.cvs\",header = None,skiprows=1 ,names = ['date','cum_power' \n                                                                            ], sep=',',usecols = [0,1],\n                     \n                     parse_dates={'date_time_format' : ['date']}, infer_datetime_format=True,index_col='date_time_format')\n# because the data is collected in the morning then the power is that of that of the day before\nsolarpower = solarpower.shift(periods=-1, freq='D', axis=0)\nsolarpower = solarpower.dropna()\nprint(solarpower.head() )","b5ae8e01":"# make the data stationary because cum_power is cumulative\nsolarpower2 = solarpower.shift(periods=1, freq='D', axis=0)\nsolarpower['cum_power_shift'] = solarpower2.loc[:,'cum_power']\nsolarpower['day_power'] = solarpower['cum_power'].values - solarpower['cum_power_shift']\nsolarpower.iloc[0:1].day_power.value = 0.\nA = solarpower.dropna()\ndel A['cum_power_shift']\nsolarpower = A.copy()\n\ndel A","b28bd82d":"solarpower.plot( y=['day_power']);","835b268d":"solarpower.head()","ca44e8f2":"solarpower.head().tail()","888d74f7":"def accumulate(df, col, start_date='2011-10-27' , end_date=None):\n    '''\n    input: dataframe df, col= colum to accumulate, from start_date up to end_date\n    returns: new_df with cumulated column\n    \n    '''\n    new_df = df.loc[start_date:end_date].copy()\n    col_list = new_df[col].to_list()\n    cum_list = [0]\n    old_power = 0\n    for i in range(len(col_list)):\n        c_power = old_power + col_list[i]\n        cum_list.append(c_power)\n        old_power = c_power        \n    new_df['cumulated'] = cum_list[1:]\n    return new_df\n    ","c87892f0":"jear_dict_start_dates = {'j1':'2011-10-27', 'j2':'2012-10-27','j3':'2013-10-27',\n                        'j4':'2014-10-27', 'j5':'2015-10-27','j6':'2016-10-27',\n                        'j7':'2017-10-27', 'j8':'2018-10-27','j9':'2019-10-27',\n                        'j10':'2020-10-27'} \n'''\n                        'j10':'2020-10-27', 'j11':'2021-10-27','j12':'2022-10-27',}\n                        '''\n\njear_dict_end_dates = {'j1':'2012-10-27', 'j2':'2013-10-27','j3':'2014-10-27',\n                        'j4':'2015-10-27', 'j5':'2016-10-27','j6':'2017-10-27',\n                        'j7':'2018-10-27', 'j8':'2019-10-27','j9':'2020-10-27','j10':'2021-10-27'}\n\n","ea7ad06b":"solarpower.head()","c7240c62":"solarpower.tail()","19f275b1":"import datetime\ny = []\nx = []\nfor j in range(1,10,1):\n    jear = 'j'+str(j)\n    start_date = jear_dict_start_dates[jear]\n    end_date = jear_dict_end_dates[jear]\n    x.append(end_date[:4])\n    start_power = solarpower.loc[start_date, 'cum_power']\n    end_power = solarpower.loc[end_date, 'cum_power']\n    \n    y.append(end_power - start_power)\n    \n        \ny, x\nplt.bar(x,y)\nplt.savefig('solar_energy_per_year.png')\nplt.show()\nprint('mean of yearly power:', np.array(y).mean() )","19cd8cf4":"Y = np.array(y)\nX = np.array(x).reshape(-1,1).astype(np.float16)\nfrom sklearn.linear_model import LinearRegression\nmodel = LinearRegression(fit_intercept=False).fit(X,Y)\n","a13c9d2f":"r_sq = model.score(X, Y)\nprint('coefficient of determination:', r_sq)\nprint('intercept= ', model.intercept_)\nprint('slope=', model.coef_)","6060e853":"def plot_linreg(column, df, size=[5,6], save_fig=False):\n        '''\n        plots y and the line linear regression\n        input : y is column name in df\n        output: plot of y and linreg line, parameters w (coefficient of x) and b (intercept with y-axis)\n        \n        '''\n        lm = LinearRegression(fit_intercept = True)\n        X = range(len(df))\n        y = df[column].values\n        \n        x = np.array(X)\n        X = x.reshape(1,-1).T\n        lm.fit(X, y)\n        #A = np.vstack([X, np.ones(len(x))]).T\n        #w, b = np.linalg.lstsq(A, y, rcond=None)[0]\n        b , w = lm.intercept_ , lm.coef_[0]\n        print(b,w)\n        plt.figure(figsize=size)\n        plt.plot(X, y, label='Original data', markersize=10)\n        plt.plot(X, w*X + b, 'r', label='Fitted line')\n        plt.title(column)\n        plt.legend()\n        if save_fig:\n            plt.savefig('plot_linreg.png')\n        plt.show()\n        print('line starts at:', b, '= intercept')\n        print('line ends at:' ,(b+ w*X[-1]))\n\n\n        return w, b\n    \nw, b = plot_linreg('day_power', solarpower,size=[15,6] , save_fig=True)\n#print(w, b)","a3bafaaa":"solarpower = solarpower.reset_index()","52401eb6":"# utility to add extra date columns\n\ndef get_month(x):\n    month = x.month\n    return month\ndef get_yr(x):\n    year = x.year\n    return year\ndef get_day(x):\n    day = x.day\n    return day","fceb86ce":"# adding extra date columns\n\nsolarpower['year'] = solarpower['date_time_format'].apply(get_yr)\nsolarpower['month'] = solarpower['date_time_format'].apply(get_month)\nsolarpower['day'] = solarpower['date_time_format'].apply(get_day)\n\n# drop februari 29th to make equal years\nsolarpower = solarpower[(solarpower['month']!=2) | (solarpower['day']!= 29)].reset_index(drop=True)\n# discard year 2011\nsolarpower = solarpower[(solarpower['year']!=2011)].reset_index(drop=True)\n\n\n# make OneHotEncoded columns\ndummy_month  = pd.get_dummies(solarpower['month'])\ndummy_day = pd.get_dummies(solarpower['day'])\nmonth_columns = []\nfor i in range(1,13,1):\n    month_columns.append('m'+str(i))\nday_columns = []\nfor i in range(1,32,1):\n    day_columns.append('d'+str(i))\n    \ndummy_month.columns = month_columns\ndummy_day.columns = day_columns","e958507b":"solarpower.head()","4a2e8bb5":"# adding one-hot encoded columns\nsolarpower = solarpower.join(dummy_month)\nsolarpower = solarpower.join(dummy_day)\n\nsolarpower.head()","090a36d5":"# calculating the whole years\nlast_day = solarpower.date_time_format[-1:].ravel()[0]\nlast_year = np.datetime64(last_day, 'Y')\n\nnr_full_years = int(str(last_year - 2012)) # 2012 is the first whole year of data\n\n\nprint('number of whole years =', nr_full_years)\n","6fef2819":"# aggregate the statistics of day_power per day and per year incl previous years\ndef growing_stats():\n    df_2012 = solarpower[solarpower.year == 2012]\n    stats_df = df_2012.groupby(['month', 'day'])['day_power'].agg(['mean', 'std', 'min', 'max'])\n    \n    for i in range(nr_full_years-1):\n        year = 2013 + i\n        df = solarpower[solarpower.year <= year]\n        stats = df.groupby(['month', 'day'])['day_power'].agg(['mean', 'std', 'min', 'max'])\n        #print('stats.shape:', stats.shape)\n        stats_df = pd.concat([stats_df, stats], axis=0)\n        #print('stats_df.shape:', stats_df.shape)\n    stats_df.reset_index(inplace=True)\n    stats_df = stats_df.fillna(0)\n    #stats_df.head()\n    solarpower_whole_yrs = solarpower[solarpower.year > 2011]\n    solarpower_whole_yrs = solarpower[solarpower.year < int(str(last_year))]\n    solarpower_whole_yrs.reset_index(inplace=True, drop=True)\n    #print('solarpower_whole_yrs.shape: ',solarpower_whole_yrs.shape)\n    \n    solarpower_whole_yrs = pd.concat([solarpower_whole_yrs, stats_df], axis=1)\n    #print('solarpower_whole_yrs shape:', solarpower_whole_yrs.shape)\n    solarpower_whole_yrs.rename({'mean':'mean2', 'std':'std2', 'min':'min2', 'max':'max2'}, inplace=True,axis='columns')\n    \n    return solarpower_whole_yrs\n\nsolarpower_whole_yrs = growing_stats()   \n#solarpower_whole_yrs.head()","6c1debdf":"solarpower_whole_yrs[['std2', 'mean2']].plot()\n#solarpower_whole_yrs['mean'].plot()\nplt.show()","43277198":"# utitlity to add Polynomial columns from the stats columns\nfrom sklearn.preprocessing import PolynomialFeatures\n\ndef add_polynomyals(df, degree=2):\n    poly = PolynomialFeatures(degree)\n    try:\n        X = df[['mean2', 'std2', 'min2','max2']]\n\n    except Exception as e:\n        X = df[['mean1', 'std1', 'min1','max1']]\n        \n    Poly = poly.fit_transform(X)\n    #print('Poly.shape',Poly.shape)\n    Poly_df = pd.DataFrame(Poly)\n    df = pd.concat([df,Poly_df], axis=1)\n    try:\n        X = df[['mean2', 'std2', 'min2','max2']]\n    except Exception as e:\n        pass\n    #print(X.shape)\n    Poly = poly.fit_transform(X)\n    print('Poly.shape',Poly.shape)\n    Poly_df = pd.DataFrame(Poly)\n    df = pd.concat([df,Poly_df], axis=1)\n    return df\n\n","444ff1c8":"# utility to get stats over all the whole years (the same for all years)\ndef simple_stats():\n    df_stats = solarpower.groupby(['month', 'day'])['day_power'].agg(['mean', 'std', 'min', 'max'])\n    #print('df_stats index', df_stats.index)\n    df_stats =df_stats.reset_index(drop=True)\n    #print('df_stats index', df_stats.index)\n    #print('df_stats shape: ',df_stats.shape )\n    solarpower_whole_yrs = solarpower[solarpower.year > 2011]\n    solarpower_whole_yrs = solarpower[solarpower.year < int(str(last_year))]\n    solarpower_whole_yrs.reset_index(inplace=True, drop=True)\n    #print('solarpower_whole_yrs.shape: ',solarpower_whole_yrs.shape)\n    dict_df_years = {}\n    for year in range(2012,int(str(last_year)),1):\n        #print(year)\n        df_year = solarpower_whole_yrs[solarpower_whole_yrs.year == year].reset_index(drop=True)\n        #print( 'df_year.shape:', df_year.shape)\n        #print('index', df_year.index[:5]  )\n        df_year = df_year.drop(['day', 'month'], axis=1)\n        #print('df_year shape', df_year.shape)\n        dict_df_years[year] = pd.concat([df_year, df_stats], axis=1)\n        #print(dict_df_years[year].head(1))\n        #print('dict_df_years[year] shape', dict_df_years[year].shape)\n    solarpower_w_stats = dict_df_years[2012]\n    #print('solarpower_w_stats = dict_df_years[2012] shape', solarpower_w_stats.shape)\n    del dict_df_years[2012]\n    for key, value in dict_df_years.items():\n        \n        solarpower_w_stats = pd.concat([solarpower_w_stats, value], axis=0).reset_index(drop=True)\n        #print('solarpower_w_stats shape', solarpower_w_stats.shape)\n    solarpower_w_stats.rename({'mean':'mean1', 'std':'std1', 'min':'min1', 'max':'max1'}, inplace=True,axis='columns')\n    return solarpower_w_stats\n\nsolarpower_whole_yrs = simple_stats()\nsolarpower_whole_yrs.shape","2103468f":"solarpower_whole_yrs['mean1'].plot()","fbd6c31d":"# import all sklearn linear models\nfrom sklearn.linear_model import LinearRegression as LR\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import Lasso\nfrom sklearn.linear_model import ElasticNet as EN\n#from sklearn.linear_model import Lars\nfrom sklearn.linear_model import LassoLars\nfrom sklearn.linear_model import OrthogonalMatchingPursuit as OMP\nfrom sklearn.linear_model import BayesianRidge as BR\nfrom sklearn.linear_model import ARDRegression as ARDR\nfrom sklearn.linear_model import HuberRegressor as HR\nfrom sklearn.linear_model import TweedieRegressor as TR\nfrom sklearn.svm import LinearSVR as SVMl\nfrom sklearn.svm import NuSVR \nfrom sklearn.svm import SVR \nfrom sklearn.kernel_ridge import KernelRidge as KR\n#from sklearn.naive_bayes import GaussianNB as GNB\n#from sklearn.ensemble import AdaBoostRegressor as ADAR\n#from sklearn.ensemble import GradientBoostingRegressor as GBR\n\nmodels = [LR, Ridge, Lasso, EN, LassoLars, OMP, BR, ARDR, HR, SVMl, NuSVR, SVR , KR, TR]\n","bb506634":"# utility to make the train and test sets\n\ndef My_train_test_split(df):\n    train = df[df.year <=2018]\n    X = train.drop(['date_time_format', 'year'], axis=1)\n    y_start = df[df.year >2012]\n    y = y_start[y_start.year <=2019].cum_power.values\n    test_low = df[df.year<=2019]\n    test = test_low[test_low.year >=2013]\n    X_test = test.drop(['date_time_format','year'], axis=1)\n    y_test_low = df[df.year<=2020]\n    y_test = y_test_low[y_test_low.year>=2014].cum_power.values\n    \n    return X, y, X_test, y_test\n    \nX, y, X_test, y_test = My_train_test_split(solarpower_whole_yrs)\n\nprint( len(X) , len(y) , len(X_test) , len(y_test) )","3b681c2a":"from sklearn.metrics import r2_score\n#r2_score(y_true, y_pred) # Best possible score is 1.0 \n\n# switch off the warnings from sklearn\nimport warnings\nwarnings.filterwarnings(action='ignore')","e0bd048e":"def search_models(X, y, X_test, y_test=None):\n    try:\n        assert( len(X) == len(y) == len(X_test) ) \n    except Exception as e:\n        print('error AssertionError: ', e)\n        return\n    \n    results_dict = {}\n    y_hat_error_dict = {}\n    for model in models:\n        #print(model)\n        results = []\n        y_hat_results = []\n        model = model()\n        try:\n            model.fit(X,y)\n            score = model.score(X,y)\n            results.append(score) # index 0 r2 score on train\n            y_hat = model.predict(X_test)\n            preds = y_hat- y_hat[0]\n            results.append(preds) # index 1 y_hat prediction\n            y_hat_total = y_hat[-1:]-y_hat[0]\n            results_dict[str(model)]=results\n           \n            if y_test is not None:\n                y_test_total = y_test[-1:]-y_test[0]\n                y_hat_error = y_test_total - y_hat_total\n                y_hat_results.append(y_hat_error)  # index 0 y_hat_error\n                score_on_test=r2_score( (y_test-y_test[0]  ), preds)\n                y_hat_results.append(score_on_test) # index 1 r2 score on test\n                y_hat_error_dict[str(model)] = y_hat_results \n\n\n        except Exception as e:\n            print('error in', model)\n            pass\n    return results_dict, y_hat_error_dict\n        ","14725190":"def plot_results(results_dict, y_hat_error_dict):\n    \n    for key, value in results_dict.items() :\n        print('Model:', key, 'Score: %.5f' %value[0])\n    \n    if len(y_hat_error_dict) != 0:\n        for key, value in y_hat_error_dict.items():\n              print('Model:', key ,'Error on X_test: %.0f' %int(value[0]), 'r2 on test: %.5f' %value[1])\n    \n    # define the figure size and grid layout properties\n    figsize = (15, 15)\n    cols = 3\n    keys = list(results_dict.keys())\n    rows = len(keys) \/\/ cols + 1\n    counter = 0\n    def trim_axs(axs, N):\n        \"\"\"\n        Reduce *axs* to *N* Axes. All further Axes are removed from the figure.\n        \"\"\"\n        axs = axs.flat\n        for ax in axs[N:]:\n            ax.remove()\n        return axs[:N]\n    \n    axs = plt.figure(figsize=figsize, constrained_layout=True).subplots(rows, cols)\n    axs = trim_axs(axs, len(results_dict))\n    \n    for ax in axs :\n        case = keys[counter]\n        value = results_dict[case]\n        x = value[1][-365:]\n        \n        ax.set_title('Model=%s' % str(case))\n        ax.plot(x, label=case)\n        if len(y_hat_error_dict) != 0:\n            delta = y_test[-365] - value[1][-365]\n            x = y_test[-365:] - delta\n            ax.plot(x,  label='y_true')\n        ax.legend()\n        \n        counter+=1\n","a9cb22e3":"# test 1\nsolarpower_whole_yrs = growing_stats()\n# solarpower_whole_yrs = simple_stats()\n# solarpower_whole_yrs = add_polynomyals(solarpower_whole_yrs)\n\nX, y, X_test, y_test = My_train_test_split(solarpower_whole_yrs)\nresults_dict,  y_hat_error_dict= search_models(X, y, X_test, y_test=y_test)\nplot_results(results_dict, y_hat_error_dict)","82d57f7c":"# test 2\n# solarpower_whole_yrs = growing_stats()\nsolarpower_whole_yrs = simple_stats()\n# solarpower_whole_yrs = add_polynomyals(solarpower_whole_yrs)\n\nX, y, X_test, y_test = My_train_test_split(solarpower_whole_yrs)\nresults_dict,  y_hat_error_dict= search_models(X, y, X_test, y_test=y_test)\nplot_results(results_dict, y_hat_error_dict)","70c45823":"# test 3\nsolarpower_whole_yrs = growing_stats()\nsolarpower_whole_yrs = simple_stats()\n# solarpower_whole_yrs = add_polynomyals(solarpower_whole_yrs)\n\nX, y, X_test, y_test = My_train_test_split(solarpower_whole_yrs)\nresults_dict,  y_hat_error_dict= search_models(X, y, X_test, y_test=y_test)\nplot_results(results_dict, y_hat_error_dict)","88aaafd6":"# test 4\nsolarpower_whole_yrs = growing_stats()\n#solarpower_whole_yrs = simple_stats()\nsolarpower_whole_yrs = add_polynomyals(solarpower_whole_yrs)\n\nX, y, X_test, y_test = My_train_test_split(solarpower_whole_yrs)\nresults_dict,  y_hat_error_dict= search_models(X, y, X_test, y_test=y_test)\nplot_results(results_dict, y_hat_error_dict)","d0d83a3a":"# test 5\n#solarpower_whole_yrs = growing_stats()\nsolarpower_whole_yrs = simple_stats()\nsolarpower_whole_yrs = add_polynomyals(solarpower_whole_yrs)\nX, y, X_test, y_test = My_train_test_split(solarpower_whole_yrs)\nresults_dict,  y_hat_error_dict= search_models(X, y, X_test, y_test=y_test)\nplot_results(results_dict, y_hat_error_dict)\n","9532a8ea":"# test 5\nsolarpower_whole_yrs = growing_stats()\nsolarpower_whole_yrs = simple_stats()\nsolarpower_whole_yrs = add_polynomyals(solarpower_whole_yrs)\nX, y, X_test, y_test = My_train_test_split(solarpower_whole_yrs)\nresults_dict,  y_hat_error_dict= search_models(X, y, X_test, y_test=y_test)\nplot_results(results_dict, y_hat_error_dict)","78af14b1":"solarpower.head(1)","e82115bc":"solarpower.tail(1)","da5af367":"# utility to make the train and test sets\n\ndef last_train_test_split(df):\n    train = df[df.year <=2019]\n    X = train.drop(['date_time_format', 'year'], axis=1)\n    #print('X', len(X))\n    y_start = df[df.year >2012]\n    y = y_start[y_start.year <=2020].cum_power.values\n    #print( 'y' ,len(y))\n    test_low = df[df.year<=2020]\n    test = test_low[test_low.year >=2013]\n    X_test = test.drop(['date_time_format','year'], axis=1)\n    #print('X_test', len(X_test))\n    y_test_low = df[df.year<2022]\n    y_test = y_test_low[y_test_low.year>=2014].cum_power.values\n    #print('y_test', len(y_test))\n    last_date = solarpower.date_time_format.loc[solarpower.index[-1]]\n    days_in_last_Y = int(str(last_date - np.datetime64('2021-01-01'))[:3])\n    y_test = list(y_test) + list(( 365- days_in_last_Y-1) * [y_test[-1]] )\n    #print(len(y_test))\n    return X, y, X_test, y_test\n    \nX, y, X_test, y_test = last_train_test_split(solarpower)","a9453961":"assert(len(X) == len(y) == len(X_test) == len(y_test))\n\nprint(len(X), len(y) , len(X_test) , len(y_test))\n\n","22162ef6":"def last_plot_results(results_dict, y_test):\n    scores = []\n    keys = []\n    errors = []\n\n    \n    # define the figure size and grid layout properties\n    figsize = (15, 15)\n    cols = 3\n    keys = list(results_dict.keys())\n    rows = len(keys) \/\/ cols + 1\n    counter = 0\n    def trim_axs(axs, N):\n        \"\"\"\n        Reduce *axs* to *N* Axes. All further Axes are removed from the figure.\n        \"\"\"\n        axs = axs.flat\n        for ax in axs[N:]:\n            ax.remove()\n        return axs[:N]\n    \n    axs = plt.figure(figsize=figsize, constrained_layout=True).subplots(rows, cols)\n    axs = trim_axs(axs, len(results_dict))\n    \n    for ax in axs :\n        case = keys[counter]\n        value = results_dict[case]\n        x = value[1][-365:]\n        x = x - x[0]\n        ax.set_title('Model=%s' % str(case))\n        ax.plot(x, label=case)\n        delta = y_test[-365]\n        #print(delta , y_test[-1])\n        x = y_test[-365:] - delta\n        ax.plot(x,  label='y_true')\n        ax.legend()\n        \n        counter+=1\n\n","11dca860":"def ensemble():\n    df = solarpower_whole_yrs\n    functions = {'A':growing_stats(), 'B':simple_stats(), 'C':add_polynomyals(df)}\n    combinations = ['A','B', 'AC','BC']\n    results_df_list = []\n    for c in combinations:\n        if len(c)==1:\n            print(c)\n            df_name = 'df'+c\n            df_results_name = df_name + 'result'\n            #####\n            df_name = functions[c]\n            #print('df_name.shape', df_name.shape)\n            X, y, X_test, y_test = last_train_test_split(df_name)\n            # for last prediction we have no whole year\n            df_results_name, y_hat_error_dict = search_models(X, y, X_test, )\n            results_df_list.append(df_results_name)\n            X, y, X_test, y_test = last_train_test_split(solarpower)\n            #last_plot_results(df_results_name, y_test)\n        elif len(c) == 2:\n            print(c)\n            df_name = 'df'+c\n            df_results_name = df_name + 'result'\n            df_name = functions[c[0]]\n            #print('df_name.shape', df_name.shape)\n            df_name = functions[c[1]]\n            #print('df_name.shape', df_name.shape)\n            X, y, X_test, y_test = last_train_test_split(df_name)\n            # for last prediction we have no whole year\n            df_results_name, y_hat_error_dict = search_models(X, y, X_test, )\n            results_df_list.append(df_results_name)\n            X, y, X_test, y_test = last_train_test_split(solarpower)\n            #last_plot_results(df_results_name, y_test)\n    return results_df_list\n\n            \n\n\nresults_df_list = ensemble()\n\n","a7b72638":"combinations = ['A','AC','B','BC']\n\n\ncounter = 0\ndf_names = []\ndf_all_results = pd.DataFrame()\nfor results_dict in results_df_list:\n    df_name = 'df_' + combinations[counter]\n    df_name = pd.DataFrame()\n    #plot_results(results_dict, y_hat_error_dict)\n    for key, value in results_dict.items():\n        #print(value[0])\n        if value[0] > 0.999:\n            column = key + combinations[counter]\n            df_name[column]=value[1][-365:]\n    m_name = 'mean'+combinations[counter]\n    #df_name[m_name] = df_name.mean(axis=1)\n    df_all_results = pd.concat([df_all_results, df_name], axis=1)\n    #df_name.plot()\n    counter +=1\n    \n\n    \ndf_all_results.shape\n","21c80f34":"df_all_results['mean']= df_all_results.mean(axis=1)\ny1 = df_all_results['mean'].ravel()\ny1_total = y1[-1] - y1[0]\nprint('total solar power predicted for 2021: %0.f' % y1_total)\n_,_,_,y_test = last_train_test_split(solarpower)\ny2 = y_test[-365:] - y_test[0]\nplt.plot(y2, label='y_true')\nplt.plot(y1, label='predicted')\nplt.legend()\nplt.show()","dc57b012":"# Import all sklearn linear models","b23af8b4":"# Aggregate the statistics of day_power per day and per year incl previous years","95216df4":"# Search the models","8203fd8a":"# Plot the results","917143f8":"##### The slope is positive which means that the power will increase each year. So why is the solar power increasing each year (on average) despite the fact that the solar pannels gather dust and are ageing?\n\n##### Rami Ma found the answer by looking at the the weather data and finding the correlations with the solar power.\n\nhttps:\/\/www.kaggle.com\/ramima\/visualizing-predicting-power-from-weather-forecast\n\n\n![](humidity.png)","4d0660c0":"# Utility to add Polynomial columns from the stats columns","592fdfb2":"# Utility to get stats over all the whole years (the same for all years)","8194e782":"# Prediction of latest year (is not a whole year)","90e2f246":"# Utility to make the last train and test sets","6710b759":"# Adding extra date columns","cbb4ae69":"# Adding one-hot encoded columns","7fc7f747":"#### Please upvote and\/or comment","6562372b":"# Testing the models on combinations of simple_stats, growing_stats add_polynomials","8e3eacf6":"# Utility to add extra date columns","ec7a0333":"# Result","823208db":"# Calculating the whole years","bb0b9686":"# Utility to make the train and test sets"}}