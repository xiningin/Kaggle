{"cell_type":{"5607ad18":"code","a73eae18":"code","5fe9057d":"code","9a69dc97":"code","9a664514":"code","ed19819e":"code","1b7c34b5":"code","57275c6c":"code","854ac815":"code","c94d1a7d":"markdown","6828f220":"markdown","c63a1421":"markdown","0eca5685":"markdown","65f3f440":"markdown","901c7554":"markdown","1c890788":"markdown","c471bcd5":"markdown","6b089c44":"markdown","4c9500ed":"markdown","b6295a2b":"markdown","2103d769":"markdown","b2d29e4a":"markdown","055ead5b":"markdown","9c1a3851":"markdown","6dfc6e7c":"markdown","99771911":"markdown","9657ef03":"markdown","9420f9ab":"markdown"},"source":{"5607ad18":"print(\"Hello World\")","a73eae18":"print('Hello World')\nprint(\"Hello World\")","5fe9057d":"# this is a comment, it will be ignored by the computer\nprint(\"Comments are very useful!\")","9a69dc97":"# store a short string or DNA sequence in the variable my_dna\nmy_dna = \"ATGCGTA\"\n\n# store a short DNA sequence in the variable my_dna\nmy_dna = \"ATGCGTA\"\n\n# now print the DNA sequence\nprint(my_dna)\nprint(\"==========================\")\n\n# change the value of my_dna\nmy_dna = \"TGGTCCA\"\n\n# store a short DNA sequence in the variable banana\nbanana = \"ATGCGTA\"\n\n# now print the DNA sequence\nprint(banana)\nprint(\"==========================\")\n\n## -------------------------------------------------------------------\n\n## STRING CONCATENTATION\n\n## adding strings together and printing\nmy_dna = \"AATT\" + \"GGCC\"\nprint(my_dna)\nprint(\"==========================\")\n\nupstream = \"AAA\"\nmy_dna = upstream + \"ATGC\"\n# my_dna is now \"AAAATGC\"\nprint(my_dna)\nprint(\"==========================\")\n\nupstream = \"AAA\"\ndownstream = \"GGG\"\nmy_dna = upstream + \"ATGC\" + downstream\n# my_dna is now \"AAAATGCGGG\"\nprint(my_dna)\nprint(\"==========================\")\n\n## -------------------------------------------------------------------\n\n# CHANGING CASE\n\n# store the DNA sequence in a variable\nmy_dna = \"ATGCGAGT\"\n\n# calculate the length of the sequence and store it in a variable\ndna_length = len(my_dna)\n\n# print a message telling us the DNA sequence length\nprint(\"The length of the DNA sequence is \" + str(dna_length)) #str() converts the number into a string for printing\nprint(\"==========================\")\n\n# alternatively\nprint(str(len(my_dna))) #used in more complex programs\nprint(\"==========================\")\n\n# --------------------------------------------------------------\n\nnumber = 3 + int('4') #int() converts string to number\n# number is now 7\nprint(number)\nprint(\"==========================\")\n\n\n# --------------------------------------------------------------\n\nmy_dna = \"ATGC\"\n\n# print the variable\nprint(\"before: \" + my_dna)\n\n# run the lower method and store the result\nlowercase_dna = my_dna.lower() #lower() method changes case; only works on strings\n\n# print the variable again\nprint(\"after: \" + my_dna)\nprint(\"==========================\")\n\n\n# --------------------------------------------------------------------------\n\n# REPLACEMENT\n\nprotein = \"vlspadktnv\"\n\n# replace valine with tyrosine\nprint(protein.replace(\"v\", \"y\"))\n\n# we can replace more than one character\nprint(protein.replace(\"vls\", \"ymt\"))\n\n# the original variable is not affected\nprint(protein)\nprint(\"==========================\")\n\n\n# ------------------------------------------------------\n\n# EXTRACTING PART OF A STRING\n\n# The positions of a string start from 0 (i.e DNA has the letter 'D' at index 0, 'N' at index 1, etc.)\n\nprotein = \"vlspadktnv\"\n\n# print positions three to five\nprint(protein[3:5])\n\n# positions start at zero, not one\nprint(protein[0:6])\n\n# if we miss out the last number, it goes to the end of the string\nprint(protein[2:])\n\nprotein = \"vlspadktnv\"\nfirst_residue = protein[2] #uses index 2 of the string\nprint(first_residue)\nprint(\"==========================\")\n\n\n# ------------------------------------------------------\n\n## SUBSTRINGS\n\nprotein = \"vlspadktnv\"\n# count amino acid residues\n# count() counts the occurance of object defined in the string\nvaline_count = protein.count('v')\nlsp_count = protein.count('lsp')\ntryptophan_count = protein.count('w')\n\n# now print the counts\nprint(\"valines: \" + str(valine_count))\nprint(\"lsp: \" + str(lsp_count))\nprint(\"tryptophans: \" + str(tryptophan_count))\n\n\n# find the number of time each substring appears\nprotein = \"vlspadktnv\" \nprint(str(protein.find('p'))) \nprint(str(protein.find('kt'))) \nprint(str(protein.find('w')))\nprint(\"==========================\")\n\n ","9a664514":"# CREATING LISTS AND RETRIEVING ELEMENTS \n\n# create lists\napes = [\"Homo sapiens\", \"Pan troglodytes\", \"Gorilla gorilla\"] # string list\nconserved_sites = [24, 56, 132] # number lists\n# can be different type of lists\n\n# each item in list is called an element and has an index\napes = [\"Homo sapiens\", \"Pan troglodytes\", \"Gorilla gorilla\"]\nconserved_sites = [24, 56, 132]\nprint(apes[2]) #list[index] finds what value is at index\nfirst_site = conserved_sites[2] \n\n# use the index() method to find an index \napes = [\"Homo sapiens\", \"Pan troglodytes\", \"Gorilla gorilla\"]\nchimp_index = apes.index(\"Pan troglodytes\")\n# chimp_index is now 1\n\n# index can't be negative \n\nranks = [\"kingdom\",\"phylum\", \"class\", \"order\", \"family\", \"peasant\"]\nlower_ranks = ranks[2:5] # index 2 to index 5 is printed\n# lower ranks are class, order and family\n\napes = [\"Homo sapiens\", \"Pan troglodytes\", \"Gorilla gorilla\"]\nprint(apes)\napes.append(\"Pan paniscus\") # adds item to the end of the list\nprint(apes)\n\n# WORKING WITH LIST ELEMENTS\n\napes = [\"Homo sapiens\", \"Pan troglodytes\", \"Gorilla gorilla\"]\nprint(\"There are \" + str(len(apes)) + \" apes\")\napes.append(\"Pan paniscus\")\nprint(\"Now there are \" + str(len(apes)) + \" apes\") \n\n# adding lists\napes = [\"Homo sapiens\", \"Pan troglodytes\", \"Gorilla gorilla\"]\nmonkeys = [\"Papio ursinus\", \"Macaca mulatta\"]\nprimates = apes + monkeys\n\nprint(str(len(apes)) + \" apes\")\nprint(str(len(monkeys)) + \" monkeys\")\nprint(str(len(primates)) + \" primates\")\n\nranks = [\"kingdom\",\"phylum\", \"class\", \"order\", \"family\"]\nprint(\"at the start : \" + str(ranks))\n \nranks.reverse() # reverses lists\nprint(\"after reversing : \" + str(ranks))\n\nranks.sort() # sorts list in alphabetical order\nprint(\"after sorting : \" + str(ranks))\n\n# WRITING A LOOP\napes = [\"Homo sapiens\", \"Pan troglodytes\", \"Gorilla gorilla\"]\n\nprint(apes[0] + \" is an ape\")\nprint(apes[1] + \" is an ape\")\nprint(apes[2] + \" is an ape\")\n\n# for loop to do the same thing as above ^\nfor ape in apes:\n    print(ape + \" is an ape\")\n\n# more complicated loop    \napes = [\"Homo sapiens\", \"Pan troglodytes\", \"Gorilla gorilla\"]    \n\nfor ape in apes:\n    name_length = len(ape)\n    first_letter = ape[0] \n    print(ape + \" is an ape. Its name starts with \" + first_letter)\n    print(\"Its name has \" + str(name_length) + \" letters\")\n\n    \n# USING A STRING AS A LIST\n\n# iterating through a string as represented by a list\nname = \"python\"\nfor character in name:\n    print(\"one character is \" + character)\n\n    \nnames = \"melanogaster,simulans,yakuba,ananassae\"\nspecies = names.split(\",\") #',' = delimeter, whenever it sees the delimeter, it splits the string\nprint(str(species))\n\n# RANGE LOOPING\n\nprotein = \"vlspadktnv\"\n\n# instead of doing \nprint(protein[0:1])\nprint(protein[0:2])\nprint(protein[0:3])\n\n# you could do this using loops\nstop_positions = [3,4,5,6,7,8,9,10]\nfor stop in stop_positions:\n    substring = protein[0:stop]\n    print(substring)\n\n## range loops\nfor number in range(6):\n    print(number)\n\nfor number in range(3, 8):\n    print(number)\n    \nfor number in range(2, 14, 4):\n    print(number)","ed19819e":"# DEFINING FUNCTION\n\ndef get_at_content(dna): # defining function\n    length = len(dna) \n    a_count = dna.upper().count('A')\n    t_count = dna.upper().count('T') \n    at_content = (a_count + t_count) \/ length \n    return round(at_content, 2) \n\nmy_at_content = get_at_content(\"ATGCGCGATCGATCGAATCG\") # get_at_content(dna) is how you call a function\nprint(str(my_at_content))\nprint(get_at_content(\"ATGCATGCAACTGTAGC\"))\nprint(get_at_content(\"aactgtagctagctagcagcgta\"))\n\n\ndef get_at_content(dna, sig_figs): # defining function with multiple parameters (arguments required to create function)\n    length = len(dna) \n    a_count = dna.upper().count('A') \n    t_count = dna.upper().count('T') \n    at_content = (a_count + t_count) \/ length \n    return round(at_content, sig_figs) \n\ntest_dna = \"ATGCATGCAACTGTAGC\"\nprint(get_at_content(test_dna, 1)) # calling functions w a DNA strand and rounding sig figures\nprint(get_at_content(test_dna, 2))\nprint(get_at_content(test_dna, 3))\n\n# ENCAPSULATION\n# Encapsulation just means dividing up a complex program into little bits which we can work on independently. \n\n# Functions don't have to always take an argument\ndef get_a_number(): # basic example\n    return 42\n\n# UNCOMMENT BELOW DURING DEMO\n# def get_at_content(): #harder example of function that doesn't take in arguments\n#     dna = \"ACTGATGCTAGCTA\"\n#     length = len(dna) \n#     a_count = dna.upper().count('A') \n#     t_count = dna.upper().count('T') \n#     at_content = (a_count + t_count) \/ length \n#     return round(at_content, 2)\n\n## You can call functions with \"keywords\" - usually used to show what each parameter is used for and mean\nget_at_content(dna=\"ATCGTGACTCG\", sig_figs=2)\n\n# Functions can start off with defaults\ndef get_at_content(dna, sig_figs=2):\u2776\n    length = len(dna) \n    a_count = dna.upper().count('A') \n    t_count = dna.upper().count('T') \n    at_content = (a_count + t_count) \/ length \n    return round(at_content, sig_figs)\n\n# any call of this function until changed\/redefined will default to 2 sig figs\n\n## TESTING FUNCTIONS\nassert get_at_content(\"ATGC\") == 0.5\n## Assertions allow us to check if the function is actually working\n# assert <function call> == <expected output>\n\n# test suites\nassert get_at_content(\"A\") == 1\nassert get_at_content(\"G\") == 0\nassert get_at_content(\"ATGC\") == 0.5\nassert get_at_content(\"AGG\") == 0.33\nassert get_at_content(\"AGG\", 1) == 0.3\nassert get_at_content(\"AGG\", 5) == 0.33333\n\n","1b7c34b5":"## IF STATEMENTS\n\nexpression_level = 125\nif expression_level > 100: # condition definition\n    print(\"gene is highly expressed\") # what happens if the condition is true?\n    \naccs = ['ab56', 'bh84', 'hv76', 'ay93', 'ap97', 'bd72'] \nfor accession in accs: # checks every element in the list\n    if accession.startswith('a'): # checks for if it starts with an 'a'\n        print(accession) # what to do if it starts with an 'a'\n        \n# ELSE STATEMENTS\n        \nexpression_level = 125\nif expression_level > 100: # condition\n    print(\"gene is highly expressed\") # what happens if code is true\nelse: # if all the 'if' conditions fail, result to this code\n    print(\"gene is lowly expressed\") # what happens if code is true\n    \naccs = ['ab56', 'bh84', 'hv76', 'ay93', 'ap97', 'bd72']\n\nfor accession in accs: # checks through every element of the list\n    if accession.startswith('a'): # check if starts with an 'a'\n        print(accession + \"\\n\") # what happens if it starts with an 'a'\n    else: # if none of the 'if' conditions work\n        print(accession + \"\\n\")  # what happens if else activates\n    \n# ELIF STATEMENTS\n\nfor accession in accs:\n    if accession.startswith('a'): # if condition (main condition)\n        print(accession + \"\\n\")\n    elif accession.startswith('b'): # alternate conditions if previous conditions don't work\n        print(accession + \"\\n\")\n    elif accession.startswith('c'):\n        print(accession + \"\\n\")\n    elif accession.startswith('d'):\n        print(accession + \"\\n\")\n    elif accession.startswith('e'):\n        print(accession + \"\\n\")\n    else: # if all conditions don't work (default)\n        print(accession + \"\\n\")\n    \n# WHILE LOOPS\n\ncount = 0\nwhile count<10: # iterates till this condtion is false (while it is true)\n    print(count)\n    count = count + 1 # increases the count value to make it eventually false\n\n# COMPLEX CONDITIONS\n\n# nested if statements\naccs = ['ab56', 'bh84', 'hv76', 'ay93', 'ap97', 'bd72']\nfor accession in accs:\n    if accession.startswith('a'):\n        if accession.endswith('3'): # if elements that start with a end with 3\n            print(accession)\n            \n# and conditions\naccs = ['ab56', 'bh84', 'hv76', 'ay93', 'ap97', 'bd72']\nfor accession in accs:\n    if accession.startswith('a') and accession.endswith('3'): # checks if both conditions are true\n        print(accession)\n\n# or conditions\naccs = ['ab56', 'bh84', 'hv76', 'ay93', 'ap97', 'bd72']\nfor accession in accs:\n    if accession.startswith('a') or accession.startswith('b'): # checks if either condition is true\n        print(accession)\n\n# compound conditional expressions\naccs = ['ab56', 'bh84', 'hv76', 'ay93', 'ap97', 'bd72']\nfor acc in accs:\n    if (acc.startswith('a') or acc.startswith('b')) and acc.endswith('4'): \n        print(acc)\n\naccs = ['ab56', 'bh84', 'hv76', 'ay93', 'ap97', 'bd72']\nfor acc in accs:\n    if acc.startswith('a') and not acc.endswith('6'): # not = opposite condition\n        print(acc)\n\n# and = both conditions true; or = 1 of the conditions true; not = opposite condition","57275c6c":"import Bio # this is how you import a module","854ac815":"# CREATING DICTIONARIES\n\nenzymes = { 'EcoRI':r'GAATTC','AvaII':r'GG(A|T)CC', 'BisI':r'GC[ATGC]GC' }\n\n# usually written something like this\nenzymes = { \n    'EcoRI' : r'GAATTC', \n    'AvaII' : r'GG(A|T)CC', \n    'BisI'  : r'GC[ATGC]GC' \n}\n\nprint(enzymes['BisI']) # allows you to print value associated with this key\n\n## BUILDING DICTIONARIES\n\nenzymes = {} # creates empty dictionary\nenzymes['EcoRI'] = r'GAATTC' # adds a value (GAATTC) at a new key (EcoRI)\nenzymes['BisI'] =  r'GC[ATGC]GC'\n\n# removes the EcoRI enzyme from the dictionary using the key\nenzymes.pop('EcoRI') # purpose of pop() method\n\n## ITERATING OVER DICTIONARY\n\nfor e in enzymes:\n    print(e)\n\n# creating dictionary through iteration\ndna = \"AATGATGAACGAC\" \nbases = ['A','T','G','C'] \nall_counts = {} \nfor base1 in bases: \n    for base2 in bases: \n        dinucleotide = base1 + base2 \n        count = dna.count(dinucleotide) \n        if count > 0: \n            all_counts[dinucleotide] = count\n\nprint(all_counts.keys()) # prints out all keys in a dictionary\n\nfor dinucleotide in all_counts.keys(): # iterates through keys\/entire dictionary\n    if all_counts.get(dinucleotide) == 2:\n        print(dinucleotide)\n        \nfor dinucleotide in sorted(all_counts.keys()): # sorted() sorts dictionary before processing it\n    if all_counts.get(dinucleotide) == 2:\n        print(dinucleotide)\n\n# iterating over full items\nfor key, value in my_dict.items(): # iterate giving you key and value\n    # do something with key and value ","c94d1a7d":"[Truth tables](https:\/\/i.ytimg.com\/vi\/o8vXoW-HTeA\/maxresdefault.jpg) are really good at figuring out logic needed for certain programs.","6828f220":"## Printing Messages to Screen","c63a1421":"# Conditional Statements\n\nBiology detects and classifies using computational decisions expressed by conditionals","0eca5685":"Hello everyone!\n\nWelcome to the Helyx Python lecture for our first annual Helyx Research Camp! Let's jump straight into it.","65f3f440":"## What will You Need for Camp for Python?\n\nJust a [Kaggle](http:\/\/kaggle.com) account!","901c7554":"# Data Types\n\n## Strings\n* Strings are essentially just words as seen above\n    * Many things you can do to manipulate and add strings\n    \nBelow is some code that describes more about strings and that data type in conjuction with variables.","1c890788":"print() is the name of a function, which tells Python what to do. In this case, the print() function is telling Python to print a message on the Console. We will talk more about functions later\n\n\"Hello World\" is the argument. This is what is going to get printed out. The arguments tell Python what we need to do more specifically.\n\nQuotes are important because they define the data type that the print function takes in or strings. Strings are words essentially. ","c471bcd5":"# Printing and Manipulating Text","6b089c44":"# Functions\n\nSimplifies code by allowing certain items to be run and typed out more simply.","4c9500ed":"# MODULES IN PYTHON\n\nImporting libraries allow you to apply different syntax to simplify things for certain applications, such as Biopython.","b6295a2b":"# Dictionaries\n\nAllows you to categorize and associate different values and keys to each other. Allows for paired data.\n\nA key is associated to a value, similar to how an index is associated to a value. However, the key is customizable and not set by Python.","2103d769":"**Be careful about what you are typing. Otherwise, you will get errors.**","b2d29e4a":"## Why do We Care about Text?\n\nWhile traditional programming deals a lot with different data types, such as numbers, booleans, and more, biological programming often deals with text. However, biological programming also does deal with numbers and other types of data.","055ead5b":"**Be careful of indentation errors!**","9c1a3851":"## Comments","6dfc6e7c":"### Why Are Comments Important?\n\n* Provides explanation of code \n* Makes documenting easier\n    * Reminds to update documentation\n* Gives you hints about the purpose of code","99771911":"# Lists and Loops\n\n## Why?\n\n* Lists store multiple pieces of data for easy access\n* Loops allow iteration through data to access","9657ef03":"# Table of Contents\/What are We Going to Go Over\n\n1. Printing and Manipulating Text\n2. Data Types\n    1. strings, ints, arrays\n3. Variables\n4. Imports\/Libraries\n5. Iteration\n6. Control Statements\n7. Functions\n8. Dictionaries\n9. File IO","9420f9ab":"## Why Python\n\n* Used in a lot of biology\n    * Data analysis (lots of data in biology)\n    * Image Analysis (detecting diseases using images, etc)\n* Growing popularity in industry\n* Common programming language\n* Can be applied in mostly any medium\n* Good language to jump into programming with\n    * Consistent syntax \n    * Good set of libraries\n    * One of the most readable languages\n    "}}