{"cell_type":{"24e68d10":"code","53652814":"code","5b5c4aac":"code","ad47cb56":"code","b7ba2947":"code","a59488d3":"code","dcbbff79":"code","954948f4":"code","11bf88f0":"code","a32b4bed":"code","b21c2081":"code","baab22c4":"code","b8162483":"code","98f5abe7":"code","08d6915b":"code","91ec136d":"code","baee1326":"code","216747c1":"code","0ef64c6b":"code","91f1c11d":"code","2941d475":"code","f390994b":"code","3c8a964a":"code","93304c7b":"code","5114cff7":"code","4518bf2d":"code","1c7ddd86":"code","517146d0":"code","10cb020d":"code","02d55ee6":"code","fcb0a3e0":"code","15c21e02":"code","108c48a2":"code","b99c491e":"code","0a738df5":"code","b5c6110b":"code","7c6f7432":"code","6427823f":"code","e6dbf760":"code","3314627f":"code","c479b000":"code","da2934a3":"code","0897ab22":"code","4d3a3554":"code","2da73054":"code","237a088d":"code","2aa8ba80":"code","977bcc8e":"code","cf4a2dfd":"code","f2b9a93c":"code","2f34ac3b":"code","c60df932":"code","bff624ba":"code","034fe4b9":"code","e389e07e":"code","777bbddd":"code","9d7a70d3":"code","a4b123a0":"code","cb702938":"code","820c5dbb":"code","f55c261a":"code","8f530ddc":"markdown","5fc20077":"markdown","017dd0ba":"markdown","02cba719":"markdown","b015a815":"markdown","d0ba5119":"markdown","af17f15f":"markdown","93622d98":"markdown","e68089fc":"markdown","e8d2da40":"markdown","23743983":"markdown","b1609601":"markdown","226ca0f5":"markdown","f583b657":"markdown","413d5264":"markdown","362d4b4c":"markdown","d7aa0e3c":"markdown","c3dfe5cf":"markdown","7a9547fa":"markdown","b0bf3d93":"markdown","91028534":"markdown","3f8156d1":"markdown","a32daee9":"markdown","80a7ad3f":"markdown","7520c3ba":"markdown","d8d7cfae":"markdown","e6a03098":"markdown","7a22a3d2":"markdown","30889cda":"markdown","4b425d61":"markdown","4f9b3ecc":"markdown","a9bcb5cd":"markdown","eb3d9da4":"markdown","7a695901":"markdown","d74f957a":"markdown","b637aafe":"markdown","7e199d01":"markdown","11f47e48":"markdown"},"source":{"24e68d10":"import numpy as np\nimport pandas as pd \nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nimport plotly.express as px\nfrom datetime import date, timedelta\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom sklearn.cluster import KMeans","53652814":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","5b5c4aac":"df_patient=pd.read_csv('\/kaggle\/input\/coronavirusdataset\/patient.csv')\ndf_time=pd.read_csv('\/kaggle\/input\/coronavirusdataset\/time.csv')\ndf_route=pd.read_csv('\/kaggle\/input\/coronavirusdataset\/route.csv')\ndf_trend=pd.read_csv('\/kaggle\/input\/coronavirusdataset\/trend.csv')","ad47cb56":"df_time['Days'] = range(1, 1+len(df_time))","b7ba2947":"df_time = df_time.rename(columns={'176': 'Date'})","a59488d3":"df_time.dtypes","dcbbff79":"df_time.date = pd.to_datetime(df_time.date)","954948f4":"df_time['day_of_week'] = df_time['date'].dt.day_name()\n\ndf_time.head()","11bf88f0":"df_time.dtypes","a32b4bed":"plt.figure(figsize=(15,6))\nplt.bar(df_time.Days, df_time.new_test, color='blue')\nplt.title('Number of tests undertaken', fontsize=15)\nplt.xlabel('Days')\nplt.ylabel(\"Count\")\nplt.legend(frameon=True, fontsize=12)\nplt.show()","b21c2081":"plt.figure(figsize=(15,6))\nplt.bar(df_time.Days, df_time.acc_test, color='blue')\nplt.title('Number of tests undertaken - Cumulative', fontsize=15)\nplt.xlabel('Days')\nplt.ylabel(\"Count\")\nplt.legend(frameon=True, fontsize=12)\nplt.show()","baab22c4":"plt.figure(figsize=(15,6))\nplt.bar(df_time.Days, df_time.new_confirmed, color='red')\nplt.title('Number of positive case', fontsize=15)\nplt.xlabel('Days')\nplt.ylabel(\"Count\")\nplt.legend(frameon=True, fontsize=12)\nplt.show()","b8162483":"plt.figure(figsize=(15,6))\nplt.bar(df_time.day_of_week, df_time.new_confirmed, color='red')\nplt.title('Number of positive case for whole dataset by weekday', fontsize=15)\nplt.xlabel('Days')\nplt.ylabel(\"Count\")\nplt.legend(frameon=True, fontsize=12)\nplt.show()","98f5abe7":"# Using a Boolean Mask\n# Greater than the start date and smaller than the end date\nmask = (df_time['date'] >= \"2020-01-20\") & (df_time['date'] <= \"2020-03-01\")\n\ndf_time_wholeweek = df_time.loc[mask]","08d6915b":"plt.figure(figsize=(15,6))\nplt.bar(df_time_wholeweek.day_of_week, df_time_wholeweek.new_confirmed, color='red')\nplt.title('Number of positive case for complete week - 2020-01-20 to 2020-03-01', fontsize=15)\nplt.xlabel('Days')\nplt.ylabel(\"Count\")\nplt.legend(frameon=True, fontsize=12)\nplt.show()","91ec136d":"df_patient.head(10)","baee1326":"print('There are a total of patients')\nprint(len(df_patient))\nprint('\\n')\nprint('These are the rows that have been filled in')\nprint(df_patient.count())","216747c1":"df_patient.head()","0ef64c6b":"df_patient.confirmed_date = pd.to_datetime(df_patient.confirmed_date)\ndf_patient.released_date = pd.to_datetime(df_patient.released_date)\ndf_patient.deceased_date = pd.to_datetime(df_patient.deceased_date)\n\ndaily_count = df_patient.groupby(df_patient.confirmed_date).id.count()\naccumulated_count = daily_count.cumsum()","91f1c11d":"df_patient['age'] = 2020 - df_patient['birth_year'] ","2941d475":"import math\ndef group_age(age):\n    if age >= 0: # not NaN\n        if age % 10 != 0:\n            lower = int(math.floor(age \/ 10.0)) * 10\n            upper = int(math.ceil(age \/ 10.0)) * 10 - 1\n            return f\"{lower}-{upper}\"\n        else:\n            lower = int(age)\n            upper = int(age + 9) \n            return f\"{lower}-{upper}\"\n    return \"Unknown\"\n\n\ndf_patient[\"age_range\"] = df_patient[\"age\"].apply(group_age)","f390994b":"df_patient.dtypes","3c8a964a":"df_patient.head()","93304c7b":"patient = df_patient","5114cff7":"date_cols = [\"confirmed_date\", \"released_date\", \"deceased_date\"]\nfor col in date_cols:\n    patient[col] = pd.to_datetime(patient[col])","4518bf2d":"patient[\"time_to_release_since_confirmed\"] = patient[\"released_date\"] - patient[\"confirmed_date\"]\n\npatient[\"time_to_death_since_confirmed\"] = patient[\"deceased_date\"] - patient[\"confirmed_date\"]\npatient[\"duration_since_confirmed\"] = patient[[\"time_to_release_since_confirmed\", \"time_to_death_since_confirmed\"]].min(axis=1)\npatient[\"duration_days\"] = patient[\"duration_since_confirmed\"].dt.days\nage_ranges = sorted(set([ar for ar in patient[\"age_range\"] if ar != \"Unknown\"]))\npatient[\"state_by_gender\"] = patient[\"state\"] + \"_\" + patient[\"sex\"]","1c7ddd86":"accumulated_count.plot()\nplt.title('Accumulated Confirmed Count');","517146d0":"infected_patients = patient.shape[0] #Total Patients\nrp = patient.loc[patient[\"state\"] == \"released\"].shape[0]\ndp = patient.loc[patient[\"state\"] == \"deceased\"].shape[0]\nip = patient.loc[patient[\"state\"]== \"isolated\"].shape[0]\nrp=rp\/patient.shape[0]\ndp=dp\/patient.shape[0]\nip=ip\/patient.shape[0]\nprint(\"The percentage of recovery is \"+ str(round(rp*100,2)),\"%\")\nprint(\"The percentage of deceased is \"+ str(round(dp*100,2)),\"%\")\nprint(\"The percentage of isolated is \"+ str(round(ip*100,2)),\"%\")","10cb020d":"states = pd.DataFrame(patient[\"state\"].value_counts())\nstates[\"status\"]=states.index\nstates.rename(columns={\"state\":\"count\"}, inplace = True)\n\nfig = px.pie(states,\n            values=\"count\",\n            names=\"status\",\n            title=\"Current state of patients\",\n            template=\"seaborn\")\n#Flexibility of labelling\nfig.update_traces(rotation=90, pull=0.05, textinfo=\"value+percent+label\")\nfig.show()","02d55ee6":"released = df_patient[df_patient.state == 'released']\nreleased.head()","fcb0a3e0":"isolated_state = df_patient[df_patient.state == 'isolated']\nisolated_state.head()","15c21e02":"dead = df_patient[df_patient.state == 'deceased']\ndead.head()","108c48a2":"plt.figure(figsize=(10,6))\nsns.set_style(\"darkgrid\")\nplt.title(\"Age distribution of the released\")\nsns.kdeplot(data=released['age'], shade=True)","b99c491e":"plt.figure(figsize=(10,6))\nsns.set_style(\"darkgrid\")\nplt.title(\"Age distribution of the isolated\")\nsns.kdeplot(data=isolated_state['age'], shade=True)","0a738df5":"plt.figure(figsize=(10,6))\nsns.set_style(\"darkgrid\")\nplt.title(\"Age distribution of the deceased\")\nsns.kdeplot(data=dead['age'], shade=True)\n","b5c6110b":"male_dead = dead[dead.sex=='male']\nfemale_dead = dead[dead.sex=='female']\n\nplt.figure(figsize=(10,6))\nsns.set_style(\"darkgrid\")\nplt.title(\"Age distribution of the deceased by gender\")\nsns.kdeplot(data=female_dead['age'], label=\"Women\", shade=True)\nsns.kdeplot(data=male_dead['age'],label=\"Male\" ,shade=True)","7c6f7432":"plt.figure(figsize=(10,8))\nsns.set_style(\"darkgrid\")\nsns.distplot(a=male_dead['age'], label=\"Men\", kde=False)\nsns.distplot(a=female_dead['age'], label=\"Women\", kde=False)\nplt.title(\"Age distribution of the deceased by sex\")\nplt.legend()","6427823f":"sns.kdeplot(data=dead['age'],label='deceased', shade=True)\nsns.kdeplot(data=released['age'],label='released', shade=True)\nsns.kdeplot(data=isolated_state['age'],label='released', shade=True)","e6dbf760":"plt.figure(figsize=(15, 5))\nplt.title('Sex')\ndead.sex.value_counts().plot.bar();","3314627f":"plt.figure(figsize=(15,5))\nplt.title('Infection reason')\ndf_patient.infection_reason.value_counts().plot.bar();","c479b000":"plt.figure(figsize=(15,5))\nplt.title('Groups')\ndf_patient.group.value_counts().plot.bar();","da2934a3":"sns.set(rc={'figure.figsize':(5,5)})\nsns.countplot(x=df_patient['state'].loc[\n    (df_patient['infection_reason']=='contact with patient')\n])","0897ab22":"age_gender_hue_order =[\"deceased_female\",\n                       \"deceased_male\"]\ncustom_palette = sns.color_palette(\"Reds\")[3:6] + sns.color_palette(\"Blues\")[2:5]\n\nplt.figure(figsize=(12, 8))\nsns.countplot(x = \"age_range\",\n              hue=\"state_by_gender\",\n              order=age_ranges,\n              hue_order=age_gender_hue_order,\n              palette=custom_palette,\n              data=patient)\nplt.title(\"State by gender and age\", fontsize=16)\nplt.xlabel(\"Age range\", fontsize=16)\nplt.ylabel(\"Count\", fontsize=16)\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.legend(loc=\"upper right\")\nplt.show()","4d3a3554":"df_route.head()","2da73054":"df_route.isna().sum()","237a088d":"clus=df_route.loc[:,['id','latitude','longitude']]\nclus.head(10)","2aa8ba80":"Y_axis = df_route[['latitude']]\nX_axis = df_route[['longitude']]\n\n# Within-Cluster-Sum-of-Squares\n\n# Using the elbow method to find the optimal number of clusters\nfrom sklearn.cluster import KMeans\nwcss = []\nfor i in range(1, 11):\n    kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)\n    kmeans.fit(X_axis, Y_axis)\n    wcss.append(kmeans.inertia_)\nplt.plot(range(1, 11), wcss)\nplt.title('The Elbow Method')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')\nplt.show()","977bcc8e":"kmeans = KMeans(n_clusters = 4, init ='k-means++')\nkmeans.fit(clus[clus.columns[1:3]])\nclus['cluster_label'] = kmeans.fit_predict(clus[clus.columns[1:3]])\ncenters = kmeans.cluster_centers_\nlabels = kmeans.predict(clus[clus.columns[1:3]])","cf4a2dfd":"clus.plot.scatter(x = 'latitude', y = 'longitude', c=labels, s=30, cmap='coolwarm')\nplt.scatter(centers[:, 0], centers[:, 1], c='black', s=100, alpha=0.5)","f2b9a93c":"import folium\nsouthkorea_map = folium.Map(location=[36.55,126.983333 ], zoom_start=7,tiles='Stamen Toner')\n\nfor lat, lon,city in zip(df_route['latitude'], df_route['longitude'],df_route['city']):\n    folium.CircleMarker([lat, lon],\n                        radius=5,\n                        color='red',\n                      popup =('City: ' + str(city) + '<br>'),\n                        fill_color='red',\n                        fill_opacity=0.7 ).add_to(southkorea_map)\nsouthkorea_map","2f34ac3b":"plt.figure(figsize=(15,5))\nplt.title('Number patients in city')\ndf_route.province.value_counts().plot.bar();","c60df932":"plt.figure(figsize=(15,5))\nplt.title('Number patients in province')\ndf_route.province.value_counts().plot.bar();","bff624ba":"plt.figure(figsize=(12,8))\nsns.boxplot(x=\"state\",\n           y=\"duration_days\",\n           order=[\"released\", \"deceased\"],\n           data=patient)\nplt.title(\"Time from confirmation to release or death\", fontsize=16)\nplt.xlabel(\"State\", fontsize=16)\nplt.ylabel(\"Days\", fontsize=16)\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.show()","034fe4b9":"data = daily_count.resample('D').first().fillna(0).cumsum() # cumulative\n\ndata = data[20:]\nx = np.arange(len(data)).reshape(-1, 1)\ny = data.values","e389e07e":"from sklearn.neural_network import MLPRegressor\nmodel = MLPRegressor(hidden_layer_sizes=[32, 32, 10], max_iter=50000, alpha=0.0005, random_state=26)\n_=model.fit(x, y)","777bbddd":"test = np.arange(len(data)+7).reshape(-1, 1)\npred = model.predict(test)\nprediction = pred.round().astype(int)\nweek = [data.index[0] + timedelta(days=i) for i in range(len(prediction))]\ndt_idx = pd.DatetimeIndex(week)\npredicted_count = pd.Series(prediction, dt_idx)","9d7a70d3":"accumulated_count.plot()\npredicted_count.plot()\nplt.title('Prediction of Accumulated Confirmed Count')\nplt.legend(['current confirmd count', 'predicted confirmed count'])\nplt.show()","a4b123a0":"confirm_cs = pd.DataFrame(data).cumsum()\narima_data = confirm_cs.reset_index()\narima_data.columns = ['confirmed_date','count']\narima_data.head()","cb702938":"model = ARIMA(arima_data['count'].values, order=(1, 2, 1))\nfit_model = model.fit(trend='c', full_output=True, disp=True)\nfit_model.summary()","820c5dbb":"fit_model.plot_predict()\nplt.title('Forecast vs Actual')\npd.DataFrame(fit_model.resid).plot()","f55c261a":"df_trend","8f530ddc":"Reason for the infection","5fc20077":"We choose the number of clusters based on the elbow method.","017dd0ba":"Feature engineering to add a field for age and grouping them","02cba719":"Time from confirmation to release or death","b015a815":"# Let's look at the patient data","d0ba5119":"* Date: Year-Month-Day\n* acc_test: the accumulated number of tests\n* acc_negative: the accumulated number of negative results\n* acc_confirmed: the accumulated number of positive results\n* acc_released: the accumulated number of releases\n* acc_deceased: the accumulated number of deceases\n* new_test: the number of new tests\n* new_negative: the number of new negative results\n* new_confirmed: the number of new positive results\n* new_released: the number of new releases\n* new_deceased: the number of new deceases","af17f15f":"Patients in Provience\/State","93622d98":"Current State of Patient","e68089fc":"This is super interesting, more positive cases seems to be in later during the week.\n\nEven though new positive cases are arising everyday","e8d2da40":"COVID-19 has infected more than 5,000 people in South Korea. \n\nSouth Korea currently has the second highest infection counts in the world.\n\nLast point of data collected is approx. 5th March 2020.\n\nThanks to the open source commitee and help to be able to explore and learn tools and explore this dataset. Special thanks to @vanshjatana for the help and layout.\n\n![SouthKorea](http:\/\/richiewong.co.uk\/wp-content\/uploads\/2020\/03\/cait-ellis-Erld-XTqXv0-unsplash-scaled-e1583538082567.jpg)","23743983":"Preprocessing","b1609601":"A lot more test have been taken in day 30+ since 20th January","226ca0f5":"Regression Model","f583b657":"Patient who died","413d5264":"Patient in city\n","362d4b4c":"# Looking route data","d7aa0e3c":"Making data ready for prediction\n\n","c3dfe5cf":"Age distribution of death by gender","7a9547fa":"State of Patient","b0bf3d93":"Affected place in world map","91028534":"Majority are contacted with patients and vists to Daegu","3f8156d1":"Graphical representatoin of current confirmed and predicted confirmed","a32daee9":"Comparison of released and deceased by age","80a7ad3f":"Age distribution of death","7520c3ba":"Autoregressive integrated moving average(Arima)","d8d7cfae":"We will verify our clusters by putting values in world map by making use of folium library","e6a03098":"People who are in isolated state","7a22a3d2":"The most rich filled data points in the Patients Database\n* Country\n* Confirmed Date\n* State","30889cda":"Death by gender","4b425d61":"# Cases in group\n\nLet's look at the time dataset - which is a aggregation of the number of test undertaken","4f9b3ecc":"Graphical representation of clusters","a9bcb5cd":"Let's only look at it for the whole complete week for completeness","eb3d9da4":"Let's see how the number of test changed","7a695901":"# Look at the trend dataset!","d74f957a":"**Live updates counts:**\nhttps:\/\/www.worldometers.info\/coronavirus\/\n\n**Visualisation from World Health Organisation:**\nhttps:\/\/experience.arcgis.com\/experience\/685d0ace521648f8a5beeeee1b9125cd\n\n**For refrence**\nhttps:\/\/www.kaggle.com\/vanshjatana\/analysis-on-coronavirus","b637aafe":"Age distribution of the released","7e199d01":"We can see most death cases are the elderly","11f47e48":"People who released"}}