{"cell_type":{"a1a9639a":"code","316d09e5":"code","f0dfef93":"code","274d91f7":"code","36195f0e":"code","ae47b181":"code","f81d8cba":"code","3461b8be":"code","4fc799f5":"code","d55996fc":"code","7123b949":"code","89039d3a":"code","3da66c35":"code","19623ca5":"code","a0b4bcdd":"code","ba662361":"code","ba1f214d":"code","75289f01":"code","976f9f00":"code","7ebb2467":"code","d59dc62a":"code","0b4d8c65":"code","46d88f0e":"markdown","a677211a":"markdown","6fa18750":"markdown","02f2d31a":"markdown","e13f6bc5":"markdown","e8f3d90d":"markdown","a8c30e10":"markdown","9bdd9d33":"markdown","1e098ed8":"markdown","8b5f8cac":"markdown","033988e7":"markdown","57ff90f8":"markdown","8bf9f6a2":"markdown","6853c03a":"markdown","878efd89":"markdown","dbbcb7a8":"markdown"},"source":{"a1a9639a":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\n\nimport keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D\n\nimport os\nimport cv2\nfrom sklearn import preprocessing\nfrom pathlib import Path","316d09e5":"# storing train images path and label\n\ntrain_path = []\nlabel_train = []\n\npath_train = \"..\/input\/messy-vs-clean-room\/images\/train\"\n\nfor filename in os.listdir(path_train+\"\/clean\/\"):\n    train_path.append(path_train + \"\/clean\/\" + filename)\n    label_train.append(0)\n\nfor filename in os.listdir(path_train+\"\/messy\"):\n    train_path.append(path_train + \"\/messy\/\" + filename)\n    label_train.append(1)\n\nprint(\"Number of train images: \", len(train_path))","f0dfef93":"# storing validation images path and label\n\nval_path = []\nlabel_val = []\n\npath_val = \"..\/input\/messy-vs-clean-room\/images\/val\"\n\nfor filename in os.listdir(path_val+\"\/clean\"):\n    val_path.append(path_val + \"\/clean\/\" + filename)\n    label_val.append(0)\n    \nfor filename in os.listdir(path_val+\"\/messy\"):\n    val_path.append(path_val + \"\/messy\/\" + filename)\n    label_val.append(1)\n    \nprint(\"Number of validation images: \", len(val_path))","274d91f7":"# storing test images path, it doesn't have any label\n\ntest_path = []\n\nfor filename in os.listdir(\"..\/input\/messy-vs-clean-room\/images\/test\/\"):\n    test_path.append(\"..\/input\/messy-vs-clean-room\/images\/test\/\" + filename)\n\nprint(\"Number of validation images: \", len(test_path))","36195f0e":"# checking train path\nimage = cv2.imread(train_path[0]) \nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n# the first image bleongs to clean directory under train\nplt.imshow(image)\nplt.title(\"Clean\", fontsize = 20)\nplt.axis('off')\nplt.show()","ae47b181":"# checking validation path\nimage = cv2.imread(val_path[0]) \nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n# the first image bleongs to clean directory under validation\nplt.imshow(image)\nplt.title(\"Clean\", fontsize = 20)\nplt.axis('off')\nplt.show()\n","f81d8cba":"# checking test path\nimage = cv2.imread(test_path[0]) \nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n# we dont know which image belongs to which category\nplt.imshow(image)\nplt.title(\"unknown\", fontsize = 20)\nplt.axis('off')\nplt.show()","3461b8be":"X_train = []\nX_test = []\nX_val = []\n\n# reading images for train data\nfor path in train_path:\n    \n    image = cv2.imread(path)        \n    image =  cv2.resize(image, (100,100))    \n    X_train.append(image)\n    \n# reading images for test data\nfor path in test_path:\n    \n    image = cv2.imread(path)        \n    image =  cv2.resize(image, (100,100))    \n    X_test.append(image)\n\n# reading images for validation data\nfor path in val_path:\n    \n    image = cv2.imread(path)\n    image =  cv2.resize(image, (100,100))    \n    X_val.append(image)\n\n\nX_test = np.array(X_test)\nX_train = np.array(X_train)\nX_val = np.array(X_val)","4fc799f5":"print(\"Shape of X_train: \", X_train.shape)\nprint(\"Shape of X_test: \", X_test.shape)\nprint(\"Shape of X_val: \", X_val.shape)","d55996fc":"X_train[:2]","7123b949":"X_train = X_train.astype('float32')\nX_test = X_test.astype('float32')\nX_val = X_val.astype('float32')\n\nX_train \/= 255\nX_test \/= 255\nX_val \/= 255","89039d3a":"# the shape is not going to change\nprint(\"Shape of X_train: \", X_train.shape)\nprint(\"Shape of X_test: \", X_test.shape)\nprint(\"Shape of X_val: \", X_val.shape)","3da66c35":"# creating numpy array from the labels list\ny_train = keras.utils.to_categorical(label_train, 2)\ny_val = keras.utils.to_categorical(label_val, 2)","19623ca5":"y_val","a0b4bcdd":"# displaying the shape\nprint(\"Shape of y_train: \", y_train.shape)\nprint(\"Shape of y_val: \", y_val.shape)","ba662361":"model = Sequential()\n\n# input shape for first layer is 100,100,3 -> 100 * 100 pixles and 3 channels\nmodel.add(Conv2D(32, (3, 3), padding='same', input_shape=(100, 100, 3), activation=\"relu\"))\n\n# adding 32 nodes in the second layer\nmodel.add(Conv2D(32, (3, 3), activation=\"relu\"))\n\n# maxpooling will take highest value from a filter of 2*2 shape\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\n# it will prevent overfitting\nmodel.add(Dropout(0.25))\n\n# adding more layers similarly\nmodel.add(Conv2D(64, (3, 3), padding='same', activation=\"relu\"))\nmodel.add(Conv2D(64, (3, 3), activation=\"relu\"))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Dropout(0.25))\n\nmodel.add(Flatten())\nmodel.add(Dense(512, activation=\"relu\"))\n\nmodel.add(Dropout(0.5))\n\n# activation function is sigmoid for the binary data\nmodel.add(Dense(2, activation=\"sigmoid\"))\n\n# compiling the model\nmodel.compile(\n    loss='binary_crossentropy',\n    optimizer=\"adam\",\n    metrics=['accuracy']\n)\n\nmodel.summary()","ba1f214d":"# training the model\nhistory = model.fit(\n    X_train,\n    y_train,\n    batch_size=30,\n    epochs=150,\n    validation_data=(X_val , y_val),\n    shuffle=True\n)","75289f01":"# displaying the model accuracy\nplt.plot(history.history['accuracy'], label='train', color=\"red\")\nplt.plot(history.history['val_accuracy'], label='validation', color=\"blue\")\nplt.title('Model accuracy')\nplt.legend(loc='upper left')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.show()","976f9f00":"# displaying the model loss\nplt.plot(history.history['loss'], label='train', color=\"red\")\nplt.plot(history.history['val_loss'], label='validation', color=\"blue\")\nplt.title('Model loss')\nplt.legend(loc='upper left')\nplt.xlabel('epoch')\nplt.ylabel('loss')\nplt.show()","7ebb2467":"pred = model.predict(X_test)","d59dc62a":"pred","0b4d8c65":"fig, axs= plt.subplots(2,5, figsize=[24,12])\n\n\ncount=0\nfor i in range(2):    \n    for j in range(5):  \n        \n        img = cv2.imread(test_path[count])\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n       \n        txt = \"clean prob: {:.4}% \\n messy prob: {:.4}%\".format( 100*pred[count][0], 100*pred[count][1])\n        \n                \n        axs[i][j].imshow(img)\n        axs[i][j].set_title(txt, fontsize = 14)\n        axs[i][j].axis('off')\n\n        count+=1\n        \nplt.suptitle(\"All predictions are shown in title\", fontsize = 18)        \nplt.show()","46d88f0e":"## Results ##","a677211a":"# Classifying house images #\n\n\nGoal: Our goal is to classify the unknown images into clean house or messy house label. For this purpose we will use Keras Sequential model with Binary Crossentropy and sigmoid activation as we have only two target categories. \n\n**Contents**:\n\n1. [Reading the data](#Reading-the-data)\n2. [Verifying the images](#Verifying-the-images)\n3. [Creating train , test and validation set](#Creating-train-,-test-and-validation-set)\n4. [Creating the Sequential model](#Creating-the-Sequential-model)\n5. [Results](#Results)\n\n\n\nLet's start by importing the libraries.","6fa18750":"## Creating train , test and validation set ##","02f2d31a":"The shape (192, 100, 100, 3) means 192 train images, each with size 100 * 100 and 3 channels - BGR. The array shows the pixel values stored from the image. Each pixel value is in the range 0-255 . Let's divide each pixel value with 255 to get a range from 0-1. ","e13f6bc5":"## Thank you ##","e8f3d90d":"## Reading the data ##","a8c30e10":"## Creating the Sequential model ##","9bdd9d33":"### Note:\n\nAs the `we dont have y_test or labels for the unknown data`, we `can't find the test accuracy`. Although as we have only `10 images` in test data, we can manually label it but still it no good. `One incorrect` label will `decrease the score by 10%`. So let's just predict the label instead of finding the accuracy.","1e098ed8":"Now we will create our keras sequential model. How we are creating it is specified in the comments","8b5f8cac":"We have our model, training data and validation data. Let's train the model now.","033988e7":"Creating y_train and y_val (validation) from the labels list","57ff90f8":"We will store the path of train , test and validation data in seperate list. Here, all the data store in \"clean\" directory will have the same label which is : clean, and all the data store in \"messy\" directory will have the same label: messy. \n\nLet's represent clean with 0, and messy with 1.","8bf9f6a2":"## Verifying the images ##\n\n\nDisplaying the one image from each train test and validation data to verify if the images are loaded properly or not.","6853c03a":"Displaying the results for all 10 test data","878efd89":"We will now create training , testing and validation data set from the retrieved path. We will resize the images so that every image has same shape. Also, the images must be convereted to numpy array before feeding them inside keras model.","dbbcb7a8":"Let's evaluate the results. First we will see how much accuracy we obtained for the train and validation data and then we will check the loss"}}