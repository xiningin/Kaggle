{"cell_type":{"8b0a600c":"code","61b662bd":"code","b7ce3209":"code","0de97d57":"markdown","ad41d3ad":"markdown","1aa302c3":"markdown","65dff7fd":"markdown"},"source":{"8b0a600c":"# Imports and helper functions\nimport tensorflow as tf\n\ndef int_list_to_hex(l):\n    return ''.join(\"{0:0{1}x}\".format(x, 2) for x in l)\n\ndef int_list_to_string(l):\n    return ''.join(chr(x) for x in l)","61b662bd":"message_str = \"Hello this is a secret message.\"\nmessage = tf.constant([ord(c) for c in message_str], tf.uint8)\n\nkey_uint32 = tf.Variable(tf.random_uniform(message.shape, minval=0, maxval=2**8, dtype=tf.int32))\nkey = tf.cast(key_uint32, tf.uint8)\n\nencrypt_xor = tf.bitwise.bitwise_xor(message, key)\ndecrypt_xor = tf.bitwise.bitwise_xor(encrypt_xor, key)\n\nwith tf.Session().as_default() as session:\n    session.run(tf.global_variables_initializer())\n    print('key:'.ljust(24), int_list_to_hex(key.eval()))\n    print('message:'.ljust(24), int_list_to_string(message.eval()))\n\n    ciphertext = encrypt_xor.eval()\n    print('encrypted ciphertext:'.ljust(24), int_list_to_hex(ciphertext))\n\n    plaintext = decrypt_xor.eval()\n    print('decrypted plaintext:'.ljust(24), int_list_to_string(plaintext))","b7ce3209":"BLOCK_SIZE = 32\nNUM_ROUNDS = 16\n\ndef feistel_network_encrypt_round(round_key, left_0, right_0):\n    \"\"\"Run one encryption round of a Feistel network.\n\n    Args:\n        round_key: The PRF is keyed with this round key.\n        left_0: the left half of the input.\n        right_0: the right half of the input.\n    Returns:\n        right n+1: the right half ouput.\n        left n+1: the left half output.\n    \"\"\"\n    # (Using bitwise inversion instead of a true PRF)\n    f_ri_ki = tf.bitwise.invert(right_0)\n    right_plusone = tf.bitwise.bitwise_xor(left_0, f_ri_ki)\n\n    return right_0, right_plusone\n\n\ndef feistel_network_decrypt_round(round_key, left_plusone, right_plusone):\n    \"\"\"Run one decryption round of a Feistel network.\n\n    Args:\n        round_key: The PRF is keyed with this round key.\n        left_plusone: the preceding left half of the input.\n        right_plusone: the precedingright half of the input.\n    Returns:\n        left n-1: the decrypted left half.\n        right n-1: the decrypted right half.\n    \"\"\"\n    # (Using bitwise inversion instead of a true PRF)\n    f_lip1_ki = tf.bitwise.invert(left_plusone)\n    right_0 = tf.bitwise.bitwise_xor(right_plusone, f_lip1_ki)\n\n    return right_0, right_plusone\n\ndef pkcs7_pad(text):\n    # Not true PKCS #7 padding, only for demo purposes.\n    val = BLOCK_SIZE - (len(text) % BLOCK_SIZE)\n    return text + ('%d' % val) * val\n\ndef pkcs7_unpad(text):\n    val = text[-1]\n    return text[:(len(text) - int(text[-1]))]\n\nmessage_str = pkcs7_pad(\"Hello this is a secret message.\")\ninput_tensor = tf.constant([ord(c) for c in message_str], tf.uint8)\n\nkey_uint32 = tf.Variable(tf.random_uniform((NUM_ROUNDS,), minval=0, maxval=2**8, dtype=tf.int32))\nkey = tf.cast(key_uint32, tf.uint8)\n\nwith tf.Session().as_default() as session:\n    session.run(tf.global_variables_initializer())\n\n    # Keys here are used to seed the random shuffle.\n    # Key is 16 bytes, one byte per round.\n    # (Note: this does not follow the DES key scheduling algorithm).\n    print('key:'.ljust(24), int_list_to_hex(key.eval()))\n    print('padded message:'.ljust(24), int_list_to_string(input_tensor.eval()))\n    \n    # Encryption: split the input in half and run the network for 16 rounds.\n    left, right = tf.split(input_tensor, num_or_size_splits=2)\n    \n    for round_num in range(NUM_ROUNDS):\n        right, left = feistel_network_encrypt_round(key[round_num], left, right)\n    \n    print('encrypted ciphertext:'.ljust(24), int_list_to_hex(left.eval()) + int_list_to_hex(right.eval()))\n\n    # Decryption: run the network in reverse.\n    for round_num in range(NUM_ROUNDS):\n        left, right = feistel_network_decrypt_round(key[round_num], left, right)\n    \n    print('decrypted plaintext:'.ljust(24), pkcs7_unpad(int_list_to_string(left.eval()) + int_list_to_string(right.eval())))","0de97d57":"# The One Time Pad\n\nThe One-Time Pad is the simplest and the most secure cipher. So why doesn't everything use it?\n\nFor a key $k$ and a message $m$, the OTP is defined as $k \\oplus m = c$. You just XOR ($\\oplus$) every byte of the key with the message. This gives you 100% perfect secrecy, since XOR'ing a uniform random distribution with anything always gives you a uniform random distribution.\n\nHowever, the key must be as large as the message you send, and if you have a secure way of transmitting a key that large, why not use that method to send the message? OTP is still used for extremely security-critical things, like the [president's red phone](https:\/\/www.hackthis.co.uk\/articles\/one-time-pad#practical-application-of-the-concept-of-the-one-time-pad).\n\nIn TensorFlow we define we can use the builtin method `tf.bitwise.bitwise_xor` to XOR vectors of arbitrary length, giving us a One-Time Pad.\n","ad41d3ad":"That's it for now. I don't think there are any practical use cases for writing cryptographic algorithms in TensorFlow, unless maybe if you need to encrypt an extremely large input by distributing your computation across many nodes. And even then, you shouldn't use TensorFlow for real cryptography, and more importantly, unless it is your career, you shouldn't be implementing your own cryptographic algorithms \ud83d\ude09.","1aa302c3":"# DES, the Data Encryption Standard\n\n<img style=\"float: right; width: 20%; margin-left: 1em;\" src=\"https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/6\/6a\/DES-main-network.png\/250px-DES-main-network.png\" \/>\n\nThe [Data Encryption Standard](https:\/\/en.wikipedia.org\/wiki\/Data_Encryption_Standard), or DES, was the crypto workhorse of the 1970's-1990's. The core of the algorithm is a Feistel Network, which is a construction that lets you create an invertible function (i.e. a function that can encrypt a message and decrypt it to the same message) out of a non-invertible pseudo-random function (for instance a hash function, but with the same output size as the input).\n\nThe Feistel Network works by splitting the input into two halves (a left half and a right half) and feeding those halves through 16 rounds, as illustrated in the image to the right.\n\nGiven a pseudo-random function $F$, the next round of the encryption algorithm (left half: $L_{i+1}$, right half: $R_{i+1}$) is computed as:\n\n$$L_{i+1} = R_i$$\n\n$$R_{i+1} = L_i  \\oplus F(R_i,K_i)$$\n\nSimilarly the decryption algorithm is the reverse:\n\n$$L_i = R_{i+1} \\oplus F(L_{i+1},K_i)$$\n\n$$R_i = L_{i+1}$$\n","65dff7fd":"# Doing Cryptography in TensorFlow\n\n<img src=\"https:\/\/i.stack.imgur.com\/IGGiW.gif\" alt=\"A Feistel Network, the algorithm behind DES.\" style=\"max-width: 360px; display: inline;\" \/>\n<img src=\"https:\/\/cdn-images-1.medium.com\/max\/1600\/1*Gh5PS4R_A5drl5ebd_gNrg@2x.png\" alt=\"A neural network.\" style=\"max-width: 360px; display: inline;\" \/>\n\n**[TensorFlow](https:\/\/www.tensorflow.org\/)** is a popular machine learning framework. Under the hood, TensorFlow is a general platform for doing computation over tensors in the structure of a graph. While studying Cryptography, a completely different field of Computer Science, you might begin to notice that cryptographic algorithms are also frequently structured as the manipulation of vectors and matrices of bytes in the structure of a graph. You might begin to see where this is going.\n\nWhat follows is a completely frivolous experiment to implement various cryptographic algorithms in TensorFlow.\n\n_**Important note:** do not use this code for real cryptography!_\n\n----------\n\n<small>Above on the left: the Feistel Network from the DES cipher, implemented below. On the right: a deep neural network.<\/small>\n\n"}}