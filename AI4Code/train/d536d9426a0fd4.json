{"cell_type":{"d10393f8":"code","caeda323":"code","cffee254":"code","8af444c2":"code","4f2c8179":"code","d896120f":"code","01eea26d":"code","d53b7711":"code","21697ce4":"code","b5dafce3":"markdown","cae92767":"markdown","f4edd6fd":"markdown","e1556d98":"markdown","ac3a0a9d":"markdown","ca7dae00":"markdown","ff7d00a8":"markdown"},"source":{"d10393f8":"import os\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom tqdm import tqdm_notebook as tqdm \n\nos.listdir('..\/input')","caeda323":"CHUNCK_SIZE = 40000000\nN_SMOOTH_POINTS = 4000","cffee254":"def feature_extractor(x):\n    return np.std(x)","8af444c2":"x, y = [], []\nfor train in tqdm(pd.read_csv('..\/input\/train.csv', \n                                   dtype={'acoustic_data': np.int16, 'time_to_failure': np.float16}, \n                                   chunksize=CHUNCK_SIZE)):\n    for i in range(N_SMOOTH_POINTS, len(train), N_SMOOTH_POINTS):\n        x.append(feature_extractor((train.iloc[i-N_SMOOTH_POINTS: i, 0].values)))\n        y.append(np.mean(train.iloc[i-N_SMOOTH_POINTS: i, 1].values))","4f2c8179":"from sklearn.base import BaseEstimator\n\nclass FailureDetector(BaseEstimator):\n    def __init__(self, window_size=3, \n                 dtime=1.5, \n                 delay=3,\n                 init_thr=-100,\n                 max_itr=100,\n                 use_bias=False,\n                 verbose=1):\n        self.window_size = window_size\n        self.dtime=dtime\n        self.delay = delay\n        self.thr = init_thr\n        self.b = 0\n        self.verbose = verbose\n        self.max_itr = max_itr\n        self.use_bias = use_bias\n    \n    def fit(self, x, y):\n        _y = np.where((np.array(y)[1:] - np.array(y)[:-1]) > self.dtime)[0]\n        peaks = self.uniques(_y, self.delay)\n        \n        n_peaks = len(peaks)\n        _error = n_peaks\n        itr = 0\n        while _error != 0 and itr < self.max_itr:\n            _p = np.where(self.feature(x, self.window_size) < self.thr)[0]\n            _peaks = self.uniques(_p, self.delay)\n            itr += 1\n            _error = n_peaks - len(_peaks)\n            if self.verbose == 1:\n                print(f'Iter:{itr}; Thr: {self.thr}; Error: {_error}')\n            if abs(_error) > 0:\n                self.thr += 10*_error\/abs(_error)\n            \n        self.b = np.mean(peaks - _peaks)\n        \n    def predict(self, x):\n        peaks = np.where(self.feature(x, self.window_size) < self.thr)[0]\n        peaks = self.uniques(peaks, self.delay).astype(np.float64)\n        if self.use_bias:\n            peaks += self.b\n        return np.floor(peaks).astype(int)\n        \n    @staticmethod\n    def uniques(x, delay):\n        peaks = [0]\n        for j in range(len(x)):\n            if x[j] - peaks[-1] > delay:\n                peaks.append(x[j])\n        peaks.pop(0)\n        return np.array(peaks)\n    \n    @staticmethod\n    def feature(x, size):\n        new_x = np.zeros_like(x)\n        for i in range(1, len(x)):\n            new_x[i] = x[i-size if i-size > 0 else 0] - x[i]\n        return new_x","d896120f":"x, y = np.array(x), np.array(y)","01eea26d":"%%time\nfd = FailureDetector(verbose=0)\nfd.fit(x, y)\nfailure = fd.predict(x)","d53b7711":"fig, ax = plt.subplots(1, 1, figsize=(24,8))\n\nax.plot(x)\nax.plot(np.array(y))\nfor f in failure:\n    plt.axvspan(f-10, f+10, alpha=0.3, color='g')\nfig.savefig('train_failures.png');","21697ce4":"submission = pd.read_csv('..\/input\/sample_submission.csv', index_col='seg_id')\nfor seg_id in tqdm(submission.index):\n    seg = pd.read_csv('..\/input\/test\/' + seg_id + '.csv')\n    x_seg = []\n    for i in range(N_SMOOTH_POINTS, len(seg), N_SMOOTH_POINTS):\n        x_seg.append(feature_extractor((seg.iloc[i-N_SMOOTH_POINTS: i, 0].values)))\n    x_seg = np.array(x_seg)\n    failure = fd.predict(x_seg)\n    \n    if len(failure) > 0:\n        fig, ax = plt.subplots(1, 1, figsize=(24,8))\n\n        ax.plot(x_seg)\n        for f in failure:\n            plt.axvspan(f-2, f+2, alpha=0.3, color='g')\n        plt.title(f'{seg_id}')\n        plt.show()\n        fig.savefig(f'{seg_id}.png')","b5dafce3":"## <center> How much failures in test data?...","cae92767":"Hmm ... This algorithm detected <b> 7 <\/b> failures, which are visualized in the graphs above.","f4edd6fd":"## <center> Failure Detection","e1556d98":"At the plot above can be counted 16 failures.","ac3a0a9d":"## <center> Preparing Data","ca7dae00":"The standard deviation with a window size of 4000 points is used as the base function.","ff7d00a8":"Failure detection algorithm based on calculation gradient and choices threshold for finding outliers, which is failure."}}