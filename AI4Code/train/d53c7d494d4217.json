{"cell_type":{"81483bc7":"code","93c37d88":"code","49d5ebb1":"code","2f566157":"code","dfaf1605":"code","a1942dbf":"code","4d72434d":"code","9980bb26":"code","19f9d8e5":"code","b1831dfc":"code","d66cb25c":"code","f55a2a3d":"code","0e1c4bcb":"code","1aed547b":"code","39aa23d9":"markdown","e561f7c8":"markdown","3ed4a89c":"markdown","18fab5ed":"markdown","28fbc46f":"markdown","2942a006":"markdown","bef03f23":"markdown","5113254a":"markdown","9bf78c52":"markdown","fe12a0c2":"markdown","0b0c27ef":"markdown","efeb1eec":"markdown","ab623623":"markdown","3bf728e1":"markdown","4458714d":"markdown","aeb44d1d":"markdown","a04b98cc":"markdown","7d5950c3":"markdown"},"source":{"81483bc7":"import numpy as np\nimport pandas as pd\nimport math\nimport matplotlib.pyplot as plt","93c37d88":"def de(fobj, bounds, mut=0.8, crossp=0.7, popsize=100, its=1000):\n    dimensions = len(bounds)\n    pop = np.random.rand(popsize, dimensions)\n    min_b, max_b = np.asarray(bounds).T\n    diff = np.fabs(min_b - max_b)\n    pop_denorm = min_b + pop * diff\n    fitness = np.asarray([fobj(ind) for ind in pop_denorm])\n    best_idx = np.argmin(fitness)\n    best = pop_denorm[best_idx]\n    for i in range(its):\n        for j in range(popsize):\n            idxs = [idx for idx in range(popsize) if idx != j]\n            a, b, c = pop[np.random.choice(idxs, 3, replace = False)]\n            mutant = np.clip(a + mut * (b - c), 0, 1)\n            cross_points = np.random.rand(dimensions) < crossp\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, dimensions)] = True\n            trial = np.where(cross_points, mutant, pop[j])\n            trial_denorm = min_b + trial * diff\n            f = fobj(trial_denorm)\n            if f < fitness[j]:\n                fitness[j] = f\n                pop[j] = trial\n                if f < fitness[best_idx]:\n                    best_idx = j\n                    best = trial_denorm\n        yield best, fitness[best_idx]","49d5ebb1":"data = pd.read_csv(\"..\/input\/ROP_WOB_BSS.csv\")\nprint('CSV file DataFrame\\n\\n',data.head())","2f566157":"x1 = data['x1'].values\ny  = data['y'].values","dfaf1605":"# x1 = data['x1'].values\n# x2 = data['x2'].values\n# X3 = data ...\n# .\n# .\n# .\n\n# y  = data['y'].values","a1942dbf":"def fmodel(x1, w):  \n\n    return (w[0]*x1**w[1])","4d72434d":"#def fmodel(x1,x2,x3, w):\n#    return (w[0]*x1**w[1]*x2**w[2]*x3**w[3]+w[4])","9980bb26":"def AAD(w):\n    \n    y_pred = fmodel(x1, w)\n    return (sum(abs(y - y_pred)) \/ len(y))","19f9d8e5":"#def AAD(w):\n    \n#    y_pred = fmodel(x1,x2,x3, w)\n#    return np.sqrt(sum(abs(y - y_pred)) \/ len(y))","b1831dfc":"result = list(de(AAD, [(0, 0.1), (0,2)], mut=0.5, crossp=0.5, popsize=50, its=100))\ndf = pd.DataFrame(result)","d66cb25c":"print(df)","f55a2a3d":"df['w1'], df['w2'] = zip(*df[0]) # Unzip\ncols = [0] # Drop the first column\ndf.drop(df.columns[cols],axis = 1,inplace = True) # Drop the first column\ndf.columns.values[0] = \"Fitness\" # name the first column as Fitness\nbest_coff = list(zip(df.iloc[len(df)-1,1:])) # insert the best coefficients into the best_coff\nprint(best_coff)","0e1c4bcb":"# df['w1'], df['w2'], df['w3']= zip(*df[0])\n# cols = [0]\n# df.drop(df.columns[cols],axis=1,inplace=True)\n# df.columns.values[0] = \"Fitness\"\n# best_coff = list(zip(df.iloc[len(df)-1,1:]))\n# print(best_coff)","1aed547b":"data_ncol=len(df.columns) # number of paramters \nfig = plt.figure(figsize=(5,10)) # you may change these to change the distance between plots.\n\nfor i in range(1,(data_ncol+1)):\n    if i<data_ncol:\n        plt.subplot(3, 1, i)\n        plt.plot(df['w{}'.format(i)],'bo', markersize=4)\n        plt.xlabel('Iteration')\n        plt.ylabel('w{}'.format(i))\n        plt.grid(True)\n    else:       \n        plt.subplot(3, 1, data_ncol)\n        plt.plot(df['Fitness'],'red', markersize=4)\n        plt.xlabel('Iteration')\n        plt.ylabel('Fitness')\n        plt.grid(True)\nplt.show()","39aa23d9":"# Plot the results\n* Plot the best agents and the Fitness versus iteration.\n* Using following lines of codes and plot the a and b versus iterations number.\n* Plus see the DE evolution versus iteration.\n* make sure that the boundaries were selected appropriately.\n* In case of having no-convergence, you may need to change the number of populations or DE hyper-parameters (mutation and cross over).","e561f7c8":"# Check out the results\n* The first column has a and b values in form of zip.\n* Unzip the first column and save it in different names.\n* Name the first values as w[1] and the second one as w[2] and drop the first column of DataFrame (df).\n* The second column is fitness value.\n* Name the first column in new DataFrame as Fitness.\n* Print the best a and b values (best coefficients).","3ed4a89c":"* In case of having three independent parameters follow below example.","18fab5ed":"# Define Error function\n* Once the model was defined, another function is needed.\n* This function will recieve the output of the model and compares it with the data and will give the averaged absolute difference.\n* Let's call it AAD and define it as follows.\n* You may define your function.\n","28fbc46f":"* Check out the head and tail of your results.","2942a006":"* In case of having more than one independent parameters, add more lines like below:","bef03f23":"As is seen in the above DaraFrame, there are one independent (x1) and one dependant (y) parameter.","5113254a":"* In case of having three independent parameters, the function will be defined as below.","9bf78c52":"# Differential Evolution Algorithm\nIn evolutionary computation, differential evolution (DE) is a method that optimizes a problem by iteratively trying to improve a candidate solution with regard to a given measure of quality. Such methods are commonly known as metaheuristics as they make few or no assumptions about the problem being optimized and can search very large spaces of candidate solutions. However, metaheuristics such as DE do not guarantee an optimal solution is ever found. The differential evolution algorithm code is provided at the following.  The codes were borrowed from the below link (Ref 1).\n\nThe DE algorithm is a branch of evolutionary methods developed by Storn and Price (1997) and it is used to find the optimum solution for extensive, continuous domains. The DE algorithm begins with a population of random candidates and it recombines them to improve the fitness of each one iteratively using a simple equation. Each random pair vectors (X1,X2) give a differential vector (X3 = X2 \u2013 X1). The weighted difference vector, X4 = F \u00d7 X3, is used to perturb the third random vector, X5 using Equation X6 = X5 + X4,  to achieve the noisy random vector, X6.\nThe \"F\" term is called weighting or scaling factor and it is primarily within the range of 0.5 to 2. The weighting factor determines the amplification of differential variation among candidates. A crossover (CR) factor regulates the amount of recombinations between candidates. The CR is applied to the noisy random vector by taking the target vector into account to achieve the trial vector. The fitness of the trial vector is then compared to the target vector and it is replaced if it is a better fit. The DE algorithm repeats the mutation\n(weighting factor), recombination (crossover factor) and selection steps until a predetermined criteria is achieved. The four major steps for evolutionary methods are provided in Figure below. The DE algorithm, like any other metaheuristic algorithm, doesn't guarantee that an optimal solution is ever found (Ref 2).\n\n* Reference 1: https:\/\/en.wikipedia.org\/wiki\/Differential_evolution\n* Reference 2: https:\/\/www.onepetro.org\/conference-paper\/SPE-185741-MS\n* Reference for algorithm codes: https:\/\/pablormier.github.io\/2017\/09\/05\/a-tutorial-on-differential-evolution-with-python\/#\nI do appreciate Mr Pablo Rodriguez-Mier for his wonderful work. \nPlease check out his website. The codes and visualization are borrowed from his website.\nI am sure you will find more helpful details on his website (Yabox library was used for the following visualization).","fe12a0c2":"# Prepare your Data\n* Prepare your Data in the form of CSV and upload it to the Kernel.\n* Prepare a CSV file and insert your data as follows. Check out the Data tab at the right side of this kernel and see the arrangement.\n* Use Add Data tab at the right top side of this Kernel to upload your prepared CSV file.\n* Name the independent parameters columns like x1, x2, x3, ... in the CSV file.\n* Name the dependant parameters column as y in the CSV file.","0b0c27ef":"![ackley.gif](attachment:ackley.gif)","efeb1eec":"# Turn the DataFrame to an array\n* The DE function (defined above) uses array. So change the DataFrame parameters to array as provided in the following.","ab623623":"### Read your data from CSV file and check out the first 5 rows.\n* In this case there are just two rows of data.","3bf728e1":"# Libraries\n* Import following libraries.","4458714d":"# Run DE Algorithm\n* Apply the DE algorithm to the function within predetermined boundaries.\n* Insert number of iterations.\n* Insert number of populations.\n* In this case, we look for a and b (w[0] and w[1]). Two boundaries are defined which are seen at the following.\n* Call the DE function (de) and insert the comparison function (AAD), insert lower and upper boundaries (here there are two).\n* The mut is mutation and crossp is cross over. These are DE algorithm hyper-parameters.","aeb44d1d":"\n![Capture.PNG](attachment:Capture.PNG)\n* Reference 2: https:\/\/www.onepetro.org\/conference-paper\/SPE-185741-MS","a04b98cc":"# Define the model\n* Define the model you are going to fit.\n* Here we have an easy example. Y = a*X^b\n* The a and b are the constants which we are trying to find using the provided DataFrame (x1, y in CSV file) and the DE algorithm.\n* The best a and b value will results in close estimations for the model (Y = a*X^b) comparing to DataFrame dependant values (y in CSV file).\n* Define the model as fmodel as provided below.\n* Note instead of using the a and b in this case, use the \"w\" as an array. \"w\" will have two elements, which are representative for a and b. \n* In our simple example, w[0] = a and w[1] = b.","7d5950c3":"* In case of having more than one independent parameters (e.i. x1, x2, x3) define the fmodel as below.\n* Note that In such case, the objective model would be something like Y = a*(X1*^b)*(X2^c)*(X3^d)+e \n* Note that In such model, the a, b, ..,e are constants which are found using the DataFrame and DE algorithm.\n* \"a\" through \"e\" are actually the w[0], w[1], w[2], w[3], w[4]."}}