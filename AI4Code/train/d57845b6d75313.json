{"cell_type":{"887b884d":"code","7eb9706b":"code","43ea1f19":"code","be6ac562":"code","881ab99c":"code","5fff575d":"code","41b023d4":"code","64214229":"code","019c741d":"code","17f08009":"code","91b51372":"code","6b1fb6db":"code","f9dc2d6c":"code","ecb06930":"code","7bf2b465":"code","81ca09f5":"code","0a80c5a6":"code","88b11b0e":"code","6a728cf0":"code","4de2b3e4":"code","aa949530":"code","f63d03f5":"code","cbddbd5c":"code","353bf1f4":"code","23a26470":"code","a537e5f1":"code","79193cda":"code","9132a20d":"code","ec999ae6":"code","7308654d":"code","5a278d53":"code","21786e7d":"code","52368e21":"code","a5098a23":"code","5c5fdf8e":"code","c3597b4c":"code","0a430896":"code","05251028":"code","da1924e5":"code","39214cef":"code","d71d6e8f":"code","531c45c5":"code","54ff5992":"code","b7d0f98d":"code","2e16420d":"code","63a2f863":"code","70ca8d8c":"code","6237283d":"code","15ea7523":"code","8af2040f":"code","60a0a6ce":"code","07fe761d":"code","d4c47dbc":"code","8685682d":"code","dbdbde7f":"markdown","6c5cb26f":"markdown","410792a0":"markdown","5b7d1eff":"markdown","c1f69ffd":"markdown","ae1061b3":"markdown","c9fefa56":"markdown","081a7ed6":"markdown","ea20e205":"markdown","90cb2b13":"markdown","ce136bba":"markdown","1fbe908a":"markdown","881ae6b8":"markdown","1b8d05c4":"markdown","3f457b82":"markdown","0304507e":"markdown","00cdb924":"markdown","5341c073":"markdown","8a497448":"markdown","a89a44f3":"markdown","07fad881":"markdown","8632fad2":"markdown","f0527193":"markdown","9f590cb3":"markdown","b29d19ff":"markdown","bd745f50":"markdown","fe7cde3a":"markdown","7c4bce44":"markdown","0601c2a4":"markdown","ed574312":"markdown","1e182621":"markdown"},"source":{"887b884d":"# import the required libraries\nimport json\nimport re\nimport numpy as np\nimport pandas as pd\n\n# if you need to use Colab to import data\n# from google.colab import files\n# from google.colab import drive","7eb9706b":"# OPTION 1: upload the data to your virtual machine by calling the upload() method in files\n# files.upload()","43ea1f19":"# OPTION 2: upload the data to you Drive, \n# mount it to your virtual machine and access it like local folder\n\n# drive.mount('drive')\n\n# the argument of the method is the path where the drive should be mounted\n# by default this mounts the drive to the location '\/contents' in you virtual machine\n# you will have to provice an authorization token for this method to work\n# log into you Google account and get the authorization code, paste it here and click Enter","be6ac562":"# consol can be accessed in Colab using the '!' sign before command\n# !ls","881ab99c":"# use the function created in the last tutorial to read in the data\ndef read_devices_json(file_path):\n  '''A function for reading in a JSON file.\n     \n     Takes in the string file_path and returns a dict\n  '''\n  with open(file_path, 'r', encoding='utf-8') as file:\n    return json.load(file)","5fff575d":"# load the file\nfile_path = '..\/input\/devices_data.txt'\ndevices_dict = read_devices_json(file_path)","41b023d4":"# check that the data has been imported as a dict and have look at its keys\nprint(type(devices_dict))\nprint(devices_dict.keys())","64214229":"# create a list of the form  [(0, 'Acer'), .......] for all makers in the devices_dict\nmakers = [(x, y) for x, y in zip(range(devices_dict.keys().__len__()), devices_dict.keys())]\nprint(makers)","019c741d":"maker_name = 'Samsung'\n\n# get Samsung's maker_id form the list we just created\nfor maker in makers:\n  if maker[1] == maker_name:\n    maker_id = maker[0]\n    \nprint(maker_id)","17f08009":"# get a data for Galaxy S10 from the devices_dict \ndevice_name = 'Galaxy S10'\nfor device_num, device in devices_dict[maker_name].items():\n  if device['device_name'] == device_name:\n    device_id = maker_name.upper() + '_' + device_num \n    break\n    \nprint(device_id)\nprint(device)","91b51372":"# define a class called FeatureGen which we will use to collect all the features from all the devices\n# pass for now, we will add attributes and methods to this class in the next section\nclass FeatureGen:\n  '''FeatureGen will contain a dict of all features from all the devices called all_features_dict\n  \n     It also contains a collection of useful methods for parsing data from a Devices object\n  '''\n  pass","6b1fb6db":"# create a basic implemention of a class for working with the devices_data\n# much more functionality will be added to this class later\n# all Device's will inherit from FeatureGen\nclass Device(FeatureGen):\n  '''A class for working with device data scrapped on GSMArena''' \n  # initliaze the class using a device \n  def __init__(self, device, device_id, maker_name, maker_id):\n    self.maker_name = maker_name\n    self.maker_id = maker_id\n    self.device_id = device_id\n    \n    # set the device_info as attributes of the Device \n    for device_info_name, device_info in device.items():\n      # emulates the functionality of self.varable = value\n      setattr(self, device_info_name, device_info)","f9dc2d6c":"# create an instance of Device using the S10's data and call it device1\ndevice1 = Device(device, device_id, maker_name, maker_id)","ecb06930":"# check all the attributes stored under device1\ndevice1.__dict__","7bf2b465":"class FeatureGen:\n  '''FeatureGen will contain a dict of all features from all the devices called all_features_dict\n  \n     It also contains a collection of useful methods for parsing data from a Devices object\n  '''\n  \n  # initialize a collector dictionary to collect features from all devices\n  # out dict will have a feature called device_notes for collecting specs where the key is nan\n  all_features_dict = {'device_notes':None}\n  \n  def gen_from_dict(self, spec_value, spec_name):\n    '''A function for generating more features from the value of a spec if the spec_value is also a dict'''\n    for key, value in spec_value.items():\n      # if key or value is np.NaN it will crash split_string, so convert it\n      if pd.isna(key):\n        key = 'nan'\n      if pd.isna(value):\n        value = 'nan'\n      key_ = self.split_string(key)\n      # in some cases, the spec_ is NaN or '' and in other case the value is nan or ''\n      # account for these cases \n      # don't take any action, this is a waste attribute, we don't want to add it to the feature list of a device\n      if (key_ == 'nan' or key_ == '') and (value == '' or value == 'nan'):\n        pass\n      # if key is 'NaN' or '', but the value is not, we want to create a note about the value under device_notes\n      elif (key_ == 'nan' or key_ == '') and (value != '' or value != 'nan'):\n        # create a new note using the key and value which is of the format 'battery_-This device has great battery life'\n        self.device_notes.setdefault(spec_name, value)\n      # if the key is not empty and the value is, we do not want this spec\n      elif (key_ != 'nan' or key_ != '') and (value == '' or value == 'nan'):\n        pass\n      # if none of the above issues are there, we can add the feature as an attribute of the device\n      else:\n        new_key = spec_name + '_' + key_\n        setattr(self, new_key, value)\n        self.set_all_features(new_key)\n        self.create_feature(new_key)","81ca09f5":"class Device(FeatureGen):\n  '''A class for working with device data scrapped on GSMArena''' \n  # we want to initalize a list to keep track of all the features collected for THIS device\n  features_list = []\n  \n  # initliaze the class using a device \n  def __init__(self, device, device_id, maker_name, maker_id):\n    self.maker_name = maker_name\n    self.create_feature('maker_name')\n    self.set_all_features('maker_name')\n    \n    self.maker_id = maker_id\n    self.create_feature('maker_id')\n    self.set_all_features('maker_id')\n    \n    self.device_id = device_id\n    self.create_feature('device_id')\n    self.set_all_features('device_id')\n    \n    # set the device_info as attributes of the Device \n    for device_info_name, device_info in device.items():\n      # emulates the functionality of self.varable = value\n      setattr(self, device_info_name, device_info)\n      self.create_feature(device_info_name)\n      self.set_all_features(device_info_name)\n      \n    # go through each spec and parse it if needed before adding to the devices attributes\n    self.device_notes = {}\n    for spec, value in device['device_specs'].items():\n      spec_ = self.split_string(spec)\n      if isinstance(value, dict):\n        self.gen_from_dict(value, spec_)\n        self.create_feature(spec_)\n      else:\n        setattr(self, spec_, value)\n      \n      \n  # helping functions    \n  def split_string(self, spec_name):\n    '''A function for changing the ' ' and '-' demlimiter\n       in a spec_name to  '_'\n       \n       Given 'Selfie Camera', returns selfie_camera\n    '''\n    split_spec_pattern = re.compile('\\s|-|\u2013')\n    split_specs = re.split(split_spec_pattern, spec_name)\n    return '_'.join(split_specs).lower()\n  \n  \n  def create_feature(self, spec_name):\n    '''A function that allows us to consolidate the names of all features recovered from the GIVEN device'''\n    if spec_name not in self.features_list:\n      self.features_list.append(spec_name)\n      \n      \n  def set_all_features(self, spec_name):\n    '''A function that allows us to consolidate the names of all features recovered from ALL devices'''\n    if spec_name not in FeatureGen.all_features_dict:\n      FeatureGen.all_features_dict.setdefault(spec_name, None)","0a80c5a6":"device1 = Device(device, device_id, maker_name, maker_id)\ndevice1.__dict__","88b11b0e":"def create_devices_from_data(devices_dict):\n  '''A function for creating objects out of all the devices stored in devices_dict\n  \n     Takes in dict and returns a list with all the device objects created from the data  \n  '''\n  # create an empty list for collecting all the device objects\n  devices_collector = []\n  # each maker has a maker_id starting from 0 for all the makers\n  for maker_id, (maker_name, devices_info) in zip(range(len(devices_dict.keys())), devices_dict.items()):\n    maker_name_split = [split.upper() for split in re.split(re.compile(' |-'), maker_name)]\n    maker_name_ = ''.join(maker_name_split)\n    \n    # iterate through each device under a maker and use maker_name_ and device_num to create a unique device_id\n    for device_num, device in devices_info.items():\n      device_id = maker_name_ + '_' + device_num\n      # create the device object using the Device class and then append the object to the collector array \n      device_ = Device(device, device_id, maker_name, maker_id)\n      devices_collector.append(device_)\n  \n  return devices_collector","6a728cf0":"FeatureGen.all_features_dict.keys()","4de2b3e4":"# test it out\ndevices_collector = create_devices_from_data(devices_dict)\n\nprint(len(devices_collector))\nprint(devices_collector[0])","aa949530":"def create_feature_column(feature_name, devices_collector):\n  '''A function for creating a feature column of a given name using devices_collector'''  \n  collector_array = []\n\n  for device in devices_collector:\n    feature = getattr(device, feature_name, None)\n    if not feature:\n      collector_array.append(np.NaN)\n    else:\n      collector_array.append(feature)\n  return collector_array","f63d03f5":"# test it out\nfeature_name = 'banner_batsize_hl'\nfeature_column = create_feature_column(feature_name, devices_collector)\nprint(feature_column)","cbddbd5c":"# create a function that uses the above functions and the class to create a data table for devices_data\ndef create_df(devices_dict):\n  # create Device objects from of devices_dict\n  devices_collector = create_devices_from_data(devices_dict)\n  \n  # get a dict of all features collected across all devices\n  all_features_dict = FeatureGen.all_features_dict\n  \n  # create the feature columns for each feature and set it as the new value of the all_features_dict\n  for feature_name, _ in all_features_dict.items():\n    col = create_feature_column(feature_name, devices_collector)\n    all_features_dict[feature_name] = col\n  \n  # create a DataFrame from the dict and return it\n  return pd.DataFrame(all_features_dict)","353bf1f4":"# test it out\ndf = create_df(devices_dict)","23a26470":"# take a peek at the dataset\ndf.head()","a537e5f1":"# get the first row of the df and verify that maker_name is nan\nrow1 = df.iloc[0, :]\npd.isna(row1['maker_id'])","79193cda":"# get the tail of the df to verify that other makers have their id unaltered\ndf.tail()","9132a20d":"# take a look at the shape of the dataset and the columns\nprint(df.shape)\nprint(df.info())","ec999ae6":"# create a class for housing the parsing functions\n\nclass ParsingFunctions:\n  '''A class for housing all the parsing function which will be used on device specs data'''\n  pass","7308654d":"class ParsingFunctions:\n  '''A class for housing all the parsing function which will be used on device specs data'''\n  \n  # all specs passed into FunctionGen will also be passed into ParsingFunctions\n  # we will create a list which contains the name of the spec_values which we want to parse\n  # the feature will only be parsed if the name is on the list\n  allow_parsing = ['banner_batsize_hl', 'banner_displayres_hl']\n  \n  \n  def parse_spec(self, spec_, value):\n    '''A function for parsing each of the spec to get the information we want\n       This function is meant to be called on each iteration of banner_spec\/value pair\n    '''\n    # check if spec_ is the in the allow_parsing list\n    if spec_ in ParsingFunctions.allow_parsing:\n      # parsing function for a feature MUST be stored as a function of the name, parse_feature_name\n      # for example, parse_banner_batsize_hl is the parsing function for the feature banner_batsize_hl\n      parsing_function_name = 'parse_' + spec_\n      parsing_function = getattr(self, parsing_function_name)\n      parsed_values = parsing_function(value)\n      # parsing functions will be written in such a way that the features and values are part of a dict\n      for feature_name, feature_value in parsed_values.items():\n        setattr(self, feature_name, feature_value)\n        self.set_all_features(feature_name)\n        self.create_feature(feature_name)\n    # if spec_ in not in the allow_parsing list, simply set the value current value of the spec\n    else:\n      setattr(self, spec_, value)\n      self.set_all_features(spec_)\n      self.create_feature(spec_)\n        \n        \n        \n  def parse_banner_batsize_hl(self, value):\n    '''A function for parsing the batsize_hl\n\n       Takes in str '3800' and returns the np.floats64 3800\n    '''\n    return {'batsize':np.float64(value)}\n  \n  \n  def parse_banner_displayres_hl(self, value):\n    '''A function for parsing the displayres_hl\n    \n       Takes in str '1280x1920 pixels' and returns two np.float64's for the length and height of the screen\n    '''\n    res_pattern = re.compile('(\\d+)x(\\d+)')\n    return_val =  re.findall(res_pattern, value)\n    feature_names = ['displayres_len', 'displayres_height']\n    if not return_val:\n      return {'displayres_len':np.NaN, 'displayres_height':np.NaN}\n    else:\n      return  {name:np.float64(i) for name, i  in zip(feature_names, return_val[0])}","5a278d53":"class FeatureGen(ParsingFunctions):\n  '''FeatureGen will contain a dict of all features from all the devices called all_features_dict\n  \n     It also contains a collection of useful methods for parsing data from a Devices object\n  '''\n  \n  # initialize a collector dictionary to collect features from all devices\n  # out dict will have a feature called device_notes for collecting specs where the key is nan\n  all_features_dict = {'device_notes':None}\n  \n  def gen_from_dict(self, spec_value, spec_name):\n    '''A function for generating more features from the value of a spec if the spec_value is also a dict'''\n    for key, value in spec_value.items():\n      if pd.isna(key):\n        key = 'nan'\n      if pd.isna(value):\n        value = 'nan'\n      key_ = self.split_string(key)\n      # in some cases, the spec_ is NaN or '' and in other case the value is nan or ''\n      # account for these cases \n      # don't take any action, this is a waste attribute, we don't want to add it to the feature list of a device\n      if (key_ == 'nan' or key_ == '') and (value == '' or value == 'nan'):\n        pass\n      # if key is 'NaN' or '', but the value is not, we want to create a note about the value under device_notes\n      elif (key_ == 'nan' or key_ == '') and (value != '' or value != 'nan'):\n        # create a new note using the key and value which is of the format 'battery_-This device has great battery life'\n        self.device_notes.setdefault(spec_name, value)\n      # if the key is not empty and the value is, we do not want this spec\n      elif (key_ != 'nan' or key_ != '') and (value == '' or value == 'nan'):\n        pass\n      # if none of the above issues are there, we can add the feature as an attribute of the device\n      else:\n        new_key = spec_name + '_' + key_\n        self.parse_spec(new_key, value)","21786e7d":"class Device(FeatureGen):\n  '''A class for working with device data scrapped on GSMArena''' \n  # we want to initalize list to keep track of all the features collected for THIS device\n  features_list = []\n  \n  # initliaze the class using a device \n  def __init__(self, device, device_id, maker_name, maker_id):\n    self.maker_name = maker_name\n    self.create_feature('maker_name')\n    self.set_all_features('maker_name')\n    \n    self.maker_id = maker_id\n    self.create_feature('maker_id')\n    self.set_all_features('maker_id')\n    \n    self.device_id = device_id\n    self.create_feature('device_id')\n    self.set_all_features('device_id')\n    \n    # set the device_info as attributes of the Device \n    for device_info_name, device_info in device.items():\n      # emulates the functionality of self.varable = value\n      setattr(self, device_info_name, device_info)\n      self.create_feature(device_info_name)\n      self.set_all_features(device_info_name)\n    \n      \n    self.device_notes = {}\n    for spec, value in device['device_specs'].items():\n      spec_ = self.split_string(spec)\n#       print(spec_ , ':  ',value)\n      if isinstance(value, dict):\n        self.gen_from_dict(value, spec_)\n        self.create_feature(spec_)\n      else:\n        setattr(self, spec_, value)\n      \n      \n  def split_string(self, spec_name):\n    '''A function for changing the ' ' and '-' demlimiter\n       in a spec_name to  '_'\n       \n       Given 'Selfie Camera', returns selfie_camera\n    '''\n    split_spec_pattern = re.compile('\\s|-|\u2013')\n    split_specs = re.split(split_spec_pattern, spec_name)\n    return '_'.join(split_specs).lower()\n  \n  \n  def create_feature(self, spec_name):\n    '''A function that allows us to consolidate the names of all features recovered from the GIVEN device'''\n    if spec_name not in self.features_list:\n      self.features_list.append(spec_name)\n      \n      \n  def set_all_features(self, spec_name):\n    '''A function that allows us to consolidate the names of all features recovered from ALL devices'''\n    if spec_name not in FeatureGen.all_features_dict:\n      FeatureGen.all_features_dict.setdefault(spec_name, None)","52368e21":"maker_name = 'Samsung'\n\n# get Samsung's maker_id form the list we just created\nfor maker in makers:\n  if maker[1] == maker_name:\n    maker_id = maker[0]\n    \nprint(maker_id)\n\n# get the data for Galaxy S10 from the devices_dict \ndevice_name = 'Galaxy S10'\nfor device_num, device in devices_dict[maker_name].items():\n  if device['device_name'] == device_name:\n    device_id = maker_name.upper() + '_' + device_num \n    break\n    \nprint(device_id)\nprint(device)","a5098a23":"device1 = Device(device, device_id, maker_name, maker_id)","5c5fdf8e":"# check that the the data was parsed properly\ntype(device1.batsize)\ntype(device1.displayres_height)\ntype(device1.displayres_len)\n\nprint('device_name: {} | batsize: {}, {} | displayres_height: {}, {} | displayres_len: {}, {}'\n      .format(device1.device_name, device1.batsize, type(device1.batsize)\n             , device1.displayres_height, type(device1.displayres_height)\n             , device1.displayres_len, type(device1.displayres_len)\n             ) \n     )","c3597b4c":"class ParsingFunctions:\n  '''A class for housing all the parsing function which will be used on device specs data'''\n  \n  # a list to keep track of which features have parsing functions\n  allow_parsing = []\n  \n  def parse_spec(self, spec_, value):\n    '''A function for parsing each of the spec to get the information we want\n       This function is meant to be called on each iteration of banner_spec\/value pair\n    '''\n    # check if spec_ is the in the allow_parsing list\n    if spec_ in ParsingFunctions.allow_parsing:\n      # parsing function for a feature MUST be stored as a function of the name, parse_feature_name\n      # for example, parse_banner_batsize_hl is the parsing function for the feature banner_batsize_hl\n      parsing_function_name = 'parse_' + spec_\n      parsing_function = getattr(ParsingFunctions, parsing_function_name)\n      parsed_values = parsing_function(value)\n      # parsing functions will be written in such a way that the features and values are part of a dict\n      for feature_name, feature_value in parsed_values.items():\n        setattr(self, feature_name, feature_value)\n        self.set_all_features(feature_name)\n        self.create_feature(feature_name)\n    # if spec_ in not in the allow_parsing list, simply set the value current value of the spec\n    else:\n      setattr(self, spec_, value)\n      self.set_all_features(spec_)\n      self.create_feature(spec_)\n      \n  @classmethod   \n  def add_new_parsers(cls, new_parsers):\n    '''A function for creating user defined parsers, initiliaze new parsers before calling Device\n    \n       Accepts a single function or a list of functions   \n    '''\n    # if a list of parsers is provided, check if each parser is a function that follows our name format\n    if isinstance(new_parsers, list):\n      for n, parser in enumerate(new_parsers):\n        if not callable(parser):\n          raise TypeError('parser at index {} in new_parsers must be callable, not of type {}'.format(n, type(parser)))\n        else:\n          parsing_function_name = parser.__name__\n          # slice the name, say parse_batsize_hl at parse_  i.e [6:]\n          col_name = parsing_function_name[6:]\n          if col_name not in cls.allow_parsing:\n            cls.allow_parsing.append(col_name)\n            setattr(cls, parsing_function_name, parser)\n          else:\n            print('WARNING! function for parsing {} already exists! {} was not added'.format(col_name, parsing_function_name))\n    elif callable(new_parsers):\n      parsing_function_name = new_parsers.__name__\n      col_name = parsing_function_name[6:]\n      if col_name not in cls.allow_parsing:\n        cls.allow_parsing.append(col_name)\n        setattr(cls, parsing_function_name, new_parsers)\n      else:\n        print('WARNING! function for parsing {} already exists! {} was not added'.format(col_name, parsing_function_name))\n    else:\n      raise TypeError('parser must be callable, not of type {}'.format(type(new_parsers)))","0a430896":"def parse_banner_batsize_hl(value):\n  '''A function for parsing the batsize_hl\n\n     Takes in str '3800' and returns the np.floats64 3800\n  '''\n  return {'batsize':np.float64(value)}\n\n  \ndef parse_banner_displayres_hl(value):\n  '''A function for parsing the displayres_hl\n\n     Takes in str '1280x1920 pixels' and returns two np.float64's for the length and height of the screen\n  '''\n  res_pattern = re.compile('(\\d+)x(\\d+)')\n  return_val =  re.findall(res_pattern, value)\n  feature_names = ['displayres_len', 'displayres_height']\n  if not return_val:\n    return {'displayres_len':np.NaN, 'displayres_height':np.NaN}\n  else:\n    return  {name:np.float64(i) for name, i  in zip(feature_names, return_val[0])}","05251028":"# add the user defined parsing function to the ParsingFunctions class\nprint(ParsingFunctions.allow_parsing)\nparsing_functions = [parse_banner_batsize_hl, parse_banner_displayres_hl]\nParsingFunctions.add_new_parsers(parsing_functions)\nprint(ParsingFunctions.allow_parsing)","da1924e5":"# create a test Device object and test it out\ndevice1 = Device(device, device_id, maker_name, maker_id)\ndevice1.displayres_height","39214cef":"import json\nimport re \nimport numpy as np\nimport pandas as pd","d71d6e8f":"class ParsingFunctions:\n  '''A class for housing all the parsing function which will be used on device specs data'''\n  \n  # a list to keep track of which features have parsing functions\n  allow_parsing = []\n  \n  def parse_spec(self, spec_, value):\n    '''A function for parsing each of the spec to get the information we want\n       This function is meant to be called on each iteration of banner_spec\/value pair\n    '''\n    # check if spec_ is the in the allow_parsing list\n    if spec_ in ParsingFunctions.allow_parsing:\n      # parsing function for a feature MUST be stored as a function of the name, parse_feature_name\n      # for example, parse_banner_batsize_hl is the parsing function for the feature banner_batsize_hl\n      parsing_function_name = 'parse_' + spec_\n      parsing_function = getattr(ParsingFunctions, parsing_function_name)\n      parsed_values = parsing_function(value)\n      # parsing functions will be written in such a way that the features and values are part of a dict\n      for feature_name, feature_value in parsed_values.items():\n        setattr(self, feature_name, feature_value)\n        self.set_all_features(feature_name)\n        self.create_feature(feature_name)\n    # if spec_ in not in the allow_parsing list, simply set the value current value of the spec\n    else:\n      setattr(self, spec_, value)\n      self.set_all_features(spec_)\n      self.create_feature(spec_)\n      \n  @classmethod   \n  def add_new_parsers(cls, new_parsers):\n    '''A function for creating user defined parsers, initiliaze new parsers before calling Device\n    \n       Accepts a single function or a list of functions   \n    '''\n    # if a list of parsers is provided, check if each parser is a function that follows our name format\n    if isinstance(new_parsers, list):\n      for n, parser in enumerate(new_parsers):\n        if not callable(parser):\n          raise TypeError('parser at index {} in new_parsers must be callable, not of type {}'.format(n, type(parser)))\n        else:\n          parsing_function_name = parser.__name__\n          # slice the name, say parse_batsize_hl at parse_  i.e [6:]\n          col_name = parsing_function_name[6:]\n          if col_name not in cls.allow_parsing:\n            cls.allow_parsing.append(col_name)\n            setattr(cls, parsing_function_name, parser)\n          else:\n            print('WARNING! function for parsing {} already exists! {} was not added'.format(col_name, parsing_function_name))\n    elif callable(new_parsers):\n      parsing_function_name = new_parsers.__name__\n      col_name = parsing_function_name[6:]\n      if col_name not in cls.allow_parsing:\n        cls.allow_parsing.append(col_name)\n        setattr(cls, parsing_function_name, new_parsers)\n      else:\n        print('WARNING! function for parsing {} already exists! {} was not added'.format(col_name, parsing_function_name))\n    else:\n      raise TypeError('parser must be callable, not of type {}'.format(type(new_parsers)))\n      \n  @classmethod\n  def clear_existing_parsers(cls):\n    '''A function for clearing current parsers'''\n    cls.allow_parsing = []\n    print('All exisiting parsing functions have been cleared!')","531c45c5":"class FeatureGen(ParsingFunctions):\n  '''FeatureGen will contain a dict of all features from all the devices called all_features_dict\n  \n     It also contains a collection of useful methods for parsing data from a Devices object\n  '''\n  \n  # initialize a collector dictionary to collect features from all devices\n  # out dict will have a feature called device_notes for collecting specs where the key is nan\n  all_features_dict = {'device_notes':None}\n  \n  def gen_from_dict(self, spec_value, spec_name):\n    '''A fnction for generating more features from the value of a spec if the spec_value is also a dict'''\n    for key, value in spec_value.items():\n      if pd.isna(key):\n        key = 'nan'\n      if pd.isna(value):\n        value = 'nan'\n      key_ = self.split_string(key)\n      # in some cases, the spec_ is NaN or '' and in other case the value is nan or ''\n      # account for these cases \n      # don't take any action, this is a waste attribute, we don't want to add it to the feature list of a device\n      if (key_ == 'nan' or key_ == '') and (value == '' or value == 'nan'):\n        pass\n      # if key is 'NaN' or '', but the value is not, we want to create a note about the value under device_notes\n      elif (key_ == 'nan' or key_ == '') and (value != '' or value != 'nan'):\n        # create a new note using the key and value which is of the format 'battery_-This device has great battery life'\n        self.device_notes.setdefault(spec_name, value)\n      # if the key is not empty and the value is, we do not want this spec\n      elif (key_ != 'nan' or key_ != '') and (value == '' or value == 'nan'):\n        pass\n      # if none of the above issues are there, we can add the feature as an attribute of the device\n      else:\n        new_key = spec_name + '_' + key_\n        self.parse_spec(new_key, value)","54ff5992":"class Device(FeatureGen):\n  '''A class for working with device data scrapped on GSMArena''' \n  # we want to initalize a list to keep track of all the features collected for THIS device\n  features_list = []\n  \n  \n  # initliaze the class using a device \n  def __init__(self, device, device_id, maker_name, maker_id):\n    # start adding attributes to the device object  \n    self.maker_name = maker_name\n    self.create_feature('maker_name')\n    self.set_all_features('maker_name')\n    \n    self.maker_id = maker_id\n    self.create_feature('maker_id')\n    self.set_all_features('maker_id')\n    \n    self.device_id = device_id\n    self.create_feature('device_id')\n    self.set_all_features('device_id')\n                \n    # set the device_info as attributes of the Device \n    for device_info_name, device_info in device.items():\n      # emulates the functionality of self.varable = value\n      setattr(self, device_info_name, device_info)\n      self.create_feature(device_info_name)\n      self.set_all_features(device_info_name)\n    \n    # all device \"specs\" exception opinion are a dict of sub specs, which we need to parse\n    # these will be treated separetly using FeatureGen and ParsingFunctions\n    self.device_notes = {}\n    for spec, value in device['device_specs'].items():\n      spec_ = self.split_string(spec)\n      if isinstance(value, dict):\n        self.gen_from_dict(value, spec_)\n        self.create_feature(spec_)\n      else:\n        setattr(self, spec_, value)\n      \n      \n  def split_string(self, spec_name):\n    '''A function for changing the ' ' and '-' demlimiter\n       in a spec_name to  '_'\n       \n       Given 'Selfie Camera', returns selfie_camera\n    '''\n    split_spec_pattern = re.compile('\\s|-|\u2013')\n    split_specs = re.split(split_spec_pattern, spec_name)\n    return '_'.join(split_specs).lower()\n  \n  \n  def create_feature(self, spec_name):\n    '''A function that allows us to consolidate the names of all features recovered from the GIVEN device'''\n    if spec_name not in self.features_list:\n      self.features_list.append(spec_name)\n      \n      \n  def set_all_features(self, spec_name):\n    '''A function that allows us to consolidate the names of all features recovered from ALL devices'''\n    if spec_name not in FeatureGen.all_features_dict:\n      FeatureGen.all_features_dict.setdefault(spec_name, None)\n      \n  \n  @staticmethod\n  def read_devices_json(file_path):\n    '''A function for reading in a JSON file.\n\n       Takes in the string file_path and returns a dict\n    '''\n    with open(file_path, 'r', encoding='utf-8') as file:\n      devices_dict = json.load(file)\n      return devices_dict\n    \n    \n  @staticmethod\n  def list_makers(devices_dict):\n    '''A function that takes in the loaded devices_dict data and returns a list of makers\n     \n       Returns a list of the form  [(0, 'Acer'), .......] for all makers in the devices_dict\n    '''\n    makers = [(x, y) for x, y in zip(range(devices_dict.keys().__len__()), devices_dict.keys())]\n    return makers\n    \n    \n  @staticmethod\n  def create_devices_from_data(devices_dict):\n    '''A function for creating objects out of all the devices stored in devices_dict\n\n       Retuns a list of Device objects for all devices in the devices_dict \n    '''\n    # we want to initalize a list for collecting all the device objects\n    devices_collector = []\n    # each maker has a maker_id starting from 0 for all the makers\n    for maker_id, (maker_name, devices_info) in zip(range(len(devices_dict.keys())), devices_dict.items()):\n      maker_name_split = [split.upper() for split in re.split(re.compile(' |-'), maker_name)]\n      maker_name_ = ''.join(maker_name_split)\n\n      # iterate through each device under a maker and use maker_name_ and device_num to create a unique device_id\n      for device_num, device in devices_info.items():\n        device_id = maker_name_ + '_' + device_num\n        # create the device object using the Device class and then append the object to the collector array \n        device_ = Device(device, device_id, maker_name, maker_id)\n        devices_collector.append(device_)\n    return devices_collector\n  \n        \n  @staticmethod     \n  def create_feature_column(feature_name, devices_collector):\n    '''A function for creating a feature column of a given name using devices_collector'''  \n    collector_array = []\n    for device in devices_collector:\n      feature = getattr(device, feature_name, None)\n      if not feature:\n        collector_array.append(np.NaN)\n      else:\n        collector_array.append(feature)\n    return collector_array\n\n        \n  @staticmethod\n  def create_df(devices_dict):\n    '''A function for creating a DataFrame using all the data from all the Device objects'''\n    \n    if not devices_dict:\n      raise AttributeError('This function cannot be run of devices_dict if is empty')\n    \n    # create Device objects from devices_dict\n    devices_collector = Device.create_devices_from_data(devices_dict)\n\n    # get a dict of all features collected across all devices\n    all_features_dict = FeatureGen.all_features_dict\n\n    # create the feature columns for each feature and set it as the new value of the all_features_dict\n    for feature_name, _ in all_features_dict.items():\n      col = Device.create_feature_column(feature_name, devices_collector)\n      all_features_dict[feature_name] = col\n\n    # create a DataFrame from the dict and return it\n    return pd.DataFrame(all_features_dict)","b7d0f98d":"# assuming that you have deviceparser.py in your working directory, load it as follows\nfrom deviceparser import Device, ParsingFunctions","2e16420d":"# define your parsing functions \nclass MyParsers:\n  '''A container class for housing all the parsing functions'''\n  \n  # define the parsing functions\n  def parse_banner_batsize_hl(spec_value):\n    '''A function for parsing the batsize_hl\n\n       Takes in str '3800' and returns the np.floats64 3800\n    '''\n    return {'batsize':np.float64(spec_value)}\n\n\n  def parse_banner_displayres_hl(spec_value):\n    '''A function for parsing the displayres_hl\n\n       Takes in str '1280x1920 pixels' and returns two np.float64's for the length and height of the screen\n    '''\n    res_pattern = re.compile('(\\d+)x(\\d+)')\n    return_val =  re.findall(res_pattern, spec_value)\n    feature_names = ['displayres_len', 'displayres_height']\n    if not return_val:\n      return {'displayres_len':np.NaN, 'displayres_height':np.NaN}\n    else:\n      return  {name:np.float64(i) for name, i  in zip(feature_names, return_val[0])}\n\n\n  def parse_banner_ramsize_hl(spec_value):\n      '''A function for parsing the ramsize_hl\n\n         Takes in str '2' and returns the np.float64 2\n      '''\n      return {'ramsize':np.float64(spec_value)}\n\n\n  def parse_banner_displaysize_hl(spec_value):\n      '''A function for parsing the displaysize_hl\n\n         Takes in str '6.0\"' and returns np.float64 6.0\n      '''\n      disp_size_pattern = re.compile('(^\\d+\\.?\\d*)\\s?\"')\n      return_val = re.findall(disp_size_pattern, spec_value)\n      if not return_val:\n        return {'displaysize':np.NaN}\n      else:\n        return {'displaysize':np.float64(return_val[0])}\n\n\n  def parse_body_weight(spec_value):\n    '''A function for parsing body_weight in devices_data\n       Takes in string '165 g ((9.17 oz))' and returns weight in gm as np.float64\n    '''\n    weight_pattern = re.compile('(\\d+\\.?\\d?)\\s?(?:g|gm|gram|grms|grams)')\n    weight = re.findall(weight_pattern, spec_value)\n    if not weight:\n      return {'weight':np.NaN}\n    else:\n      feature_value = np.float64(weight[0])    \n      return {'weight':feature_value}\n\n\n  # examples of launch_status\n  # 1. Available. Released 2018, July\n  # 2. Coming soon. Exp. release 2019, Q1\n  # 3. Cancelled\n  def parse_launch_status(spec_value):\n    '''A function for parsing the launch_status\n\n       Returns str 'Available' or 'Coming soon' or 'Cancelled'\n\n    '''\n    status_patten = re.compile('(Available|Coming\\s?soon|Cancelled|Discontinued).*')\n    status = re.findall(status_patten, spec_value)\n    if not status:\n      return {'launch_status':np.NaN}\n    else:\n      return {'launch_status':status[0]}\n\n\n  def parse_launch_announced(spec_value):\n    '''A function for parsing the release date of a phone\n\n       Returns a pandas.Timestamp object\n    '''\n    year_month_pattern = re.compile('\\d{4}[\\s,.]*(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|\\\n                                    Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|\\\n                                    Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)')\n    year_only_pattern = re.compile('\\d{4}')\n\n    # finding year, month gets hightest priority\n    year_month = re.findall(year_month_pattern, spec_value)\n\n    if not year_month:\n      year = re.findall(year_only_pattern, spec_value)\n      # if year is also not present then set both month and year to np.NaN\n      if not year:\n        dt = np.NaN\n      else:\n        dt = year[0]\n    else:\n      dt = year_month[0]\n\n    return {'launch_announced':pd.to_datetime(dt)}\n\n\n  def parse_body_dimensions(spec_value):\n    '''A function for parsing the body dimensions\n\n       Returns the value of each dimension as a np.float64. Returns np.NaN if dimensions not found\n    '''\n    dimensions_pattern = re.compile('((?:\\d+\\.?\\d*[\\sx]+){3})mm')\n    float_pattern = re.compile('\\d+\\.?\\d*')\n\n    dimensions = re.findall(dimensions_pattern, spec_value)\n    if not dimensions:\n      return {'body_x':np.NaN, 'body_y':np.NaN, 'body_z':np.NaN}\n    else:\n      # find each of the dimensions\n      each_dim = re.findall(float_pattern, dimensions[0])\n      x = np.float64(each_dim[0])\n      y = np.float64(each_dim[1])\n      z = np.float64(each_dim[2])\n      return {'body_x':x, 'body_y':y, 'body_z':z}\n\n\n  # different types of displays noticed\n  # 1. OLED\n  # 2. LCD \n  # 3. TFT - variant of LCD\n  # 4. IPS - variant of LCD\n  # 5. Monochrome|Grayscale\n  def parse_display_type(spec_value):\n    '''A function for categorizing the display types of devices\n\n       Returns str category 'OLED', 'LCD', 'TFT', 'IPS' or 'MONO'\n    '''\n    # if this is not a known display type return NaN \n    display_type_category = np.NaN\n\n    if re.compile('.*OLED.*').match(spec_value):\n      display_type_category = 'OLED'\n    elif re.compile('.*LCD.*').match(spec_value):\n      display_type_category = 'LCD'\n    elif re.compile('.*TFT.*').match(spec_value):\n      display_type_category = 'TFT'\n    elif re.compile('.*IPS.*').match(spec_value):\n      display_type_category = 'IPS'\n    elif re.compile('.*[Mm]onochrome.*|.*[Gg]rayscale.*').match(spec_value):\n      display_type_category = 'MONO'\n    return {'display_type':spec_value, 'display_type_category':display_type_category}\n\n\n  # values of battery_talk_talk\n  # 1. Up to 4 h 30 min\n  # 2. Up to 4 h\n  # 3. Up to 7 h 30 min (multimedia)\n  # 4. Up to 15 h 20 min (2G) \/ Up to 6 h (3G)\n  def parse_battery_talk_time(spec_value):\n    '''A function for parsing a device's talk time\n\n       Returns three pd.TimeDelta objects\n       If 3G or 2G talktimes are reported, they get a value, else np.NaN\n       If neither 3G nor 2g talktimes are reported then make an attempt to find a generic talktime\n    '''\n    # output variables\n    talk_time_3g_td = np.NaN\n    talk_time_2g_td = np.NaN\n    talk_time_td = np.NaN\n\n\n    talk_time_3g_pattern = re.compile('.*Up\\sto\\s((?:\\d+\\sh)?(?:\\s?\\d+\\smin)?)\\s\\(3G\\)')\n    talk_time_2g_pattern = re.compile('.*Up\\sto\\s((?:\\d+\\sh)?(?:\\s?\\d+\\smin)?)\\s\\(2G\\)')\n    talk_time_pattern = re.compile('.*Up\\sto\\s((?:\\d+\\sh)?(?:\\s?\\d+\\smin)?)')\n\n    talk_time_3g = re.findall(talk_time_3g_pattern, spec_value) \n    talk_time_2g = re.findall(talk_time_2g_pattern, spec_value) \n\n    if talk_time_3g:\n      talk_time_3g_td = pd.to_timedelta(talk_time_3g[0])\n\n    if talk_time_2g:\n        talk_time_2g_td = pd.to_timedelta(talk_time_2g[0])\n\n    # if this device has neither 2g or 3g talk time, try finding a generic talktime\n    if (not talk_time_3g) and (not talk_time_2g):\n      talk_time = re.findall(talk_time_pattern, spec_value)\n      if talk_time:\n        talk_time_td = pd.to_timedelta(talk_time[0])\n\n    return {'talk_time':talk_time_td, 'talk_time_2g':talk_time_2g_td, 'talk_time_3g':talk_time_3g_td}\n\n\n  def parse_platform_chipset(spec_value):\n    '''A function for parsing the device chipset\n\n       Returns silicon gate width (x nm) as np.float64 along with chipset name\n    '''\n    gate_width_pattern = re.compile('\\((\\d+)\\snm\\)')\n    gate_width = re.findall(gate_width_pattern, spec_value)\n\n    if gate_width:\n      return {'platform_chipset':spec_value, 'platform_chipset_gate_width':np.float64(gate_width[0])}\n    else:\n      return {'platform_chipset':spec_value, 'platform_chipset_gate_width':np.NaN}","63a2f863":"# current version of ParsingFunctions does not come preloaded with any methods \nprint(ParsingFunctions.__dict__)\n\n# ParsingFunctions can be provided a single parsing functions or a list of parsing functions\nParsingFunctions.add_new_parsers(MyParsers.parse_banner_batsize_hl)\nprint(ParsingFunctions.__dict__)\n\nParsingFunctions.add_new_parsers([MyParsers.parse_banner_displayres_hl, \\\n                                  MyParsers.parse_banner_ramsize_hl, \\\n                                  MyParsers.parse_banner_displaysize_hl\n                                 ])\n\nprint(ParsingFunctions.__dict__)\n\n# only one parsing function of a given name can exist at a time inide ParsingFunctions\n# a warning message is printed out if you try to reassign a function which already exists\n# use clear_existing_parser() method if you need to reimport a parser of the same name\nParsingFunctions.clear_existing_parsers()\n\n# defining user defined functions inside a class makes it easy to obtain the functions as a list\nparsing_functions_list = [value for key, value in MyParsers.__dict__.items() if re.compile('parse_.*').match(key)]\n\nParsingFunctions.add_new_parsers(parsing_functions_list)\n","70ca8d8c":"# loading devices_data\nfile_path = '..\/devices_data.txt'\ndevices_dict = Device.read_devices_json(file_path)\ndevices_dict.keys()","6237283d":"# access maker_id and maker_name using Device.list_makers() method\nmakers = Device.list_makers(devices_dict)\nprint(makers)","15ea7523":"# parsing a single device object\n\nmaker_name = 'Samsung'\n# get Samsung's maker_id form the list we just created\nfor maker in makers:\n  if maker[1] == maker_name:\n    maker_id = maker[0]\n    \n# get the data for Galaxy S10 from the devices_dict \ndevice_name = 'Galaxy S10'\nfor device_num, device in devices_dict[maker_name].items():\n  if device['device_name'] == device_name:\n    device_id = maker_name.upper() + '_' + device_num \n    break\n    \n# create the device object by initializng an instance of the Device class\ns10 = Device(device, device_id, maker_name, maker_id)\n\n# new features have been created using the parsing functions\nprint(s10.batsize)\nprint(s10.displayres_height)\nprint(s10.displayres_len)\nprint(s10.displaysize)\nprint(s10.ramsize)","8af2040f":"# creating a list of device objects for all makers\ndevices_collector = Device.create_devices_from_data(devices_dict)\nprint(len(devices_collector))\nprint(type(devices_collector[0]))","60a0a6ce":"# simple one line filters can be written for devices collector using list comprehensions\n# use getattr() for getting the value of a feature instead of self.feature_name\n# this ensures that an AttributeError is not thrown if the device does not have the attribute \nsamsung_devices = [x for x in devices_collector if getattr(x, 'maker_name', None) == 'Samsung']\nprint(len(samsung_devices) == len(devices_dict['Samsung'].keys()))\n\ns10 = [x for x in devices_collector if getattr(x, 'device_name', None) == 'Galaxy S10']\nprint(s10[0].device_name)\n\nbatsize = [x.batsize if getattr(x, 'batsize', None) is not None else np.NaN for x in devices_collector]\nprint(batsize)\n\n# this might seem complicated if you are beginner, but it is a great opportunity to learn about list comprehensions","07fe761d":"# create a DataFrame after applying all the user defined parsing functions to the devices data\ndf = Device.create_df(devices_dict)\ndf.head()","d4c47dbc":"df.info()","8685682d":"df.to_csv('devices_data_full.csv')","dbdbde7f":"**OPTION 3:** Connecting Colab To Local Runtime\n\nDetailed instructions for connecting Colab to you local Jupyter Notebook runtime can be found [here](https:\/\/research.google.com\/colaboratory\/local-runtimes.html).","6c5cb26f":"Repeat the same process we saw earlier to create a new **Device** object","410792a0":"### Expanding the Functionality of Our Classes","5b7d1eff":"### Create the Skeleton Dataset","c1f69ffd":"As a next step, we want to create a function which takes in a feature name from the list of keys of **FeatureGen.all_devices_dict** and checks if this feature is present as an attribute of the device objects in **devices_collector** to return a list which corresponds to the feature column values. Each key present in **all_divces_dict** will be a feature of the final feature table\n\nIf the device has a given attribute, then the value is added to a list, else we will add a **np.NaN** to the list to denote a missing value. Finally, this list will be set as the value of feature (i.e key). The ","ae1061b3":"In this tutorial, you will learn how to implement **classes** in Python for storing and parsing the data collected for devices (smartphones, phones, smart watches, etc..) from [GSMArena](https:\/\/www.gsmarena.com). I scrapped the *devices_data.txt* file required for this tutorial from GSMArena by building a web crawler from scratch using BeautifulSoup. You can learn how to do this in my [previous tutorial](https:\/\/www.kaggle.com\/vigvisw\/collect-data-by-building-a-web-crawler). \n\n\n\n**DISCLAIMER:** The credit for originally assembling and making this data available in the public domain goes to the GSMArena team.\n\nThe *devices_data.txt* file can be downloaded on my [GitHub page](https:\/\/github.com\/vigvisw\/end2endml).","c9fefa56":"With the all of these peices in place, we can finally define a function called **create_df** which takes in as the input, the **devices_dict** from earlier and returns a *Pandas DataFrame* with all the fratures extracted from all the devices.","081a7ed6":"At the very least, we will have to use two classes. The first of these will be called **Device**. This class is used to create device objects which contain all the relavent attributes of a device such as it name, link, maker and most importantly, its specs. Remember that the spec data is text and hence we need to parse it to get the data in a form which can be manipulated by **pandas** down the line. To help with this process, **Device** needs to <a href=\"https:\/\/en.wikipedia.org\/wiki\/Inheritance_(object-oriented_programming)\">***inherit***<\/a> from another class. This will be called **FeatureGen**. For now, we will **pass** **FeatureGenn** without doing anything, and add functionality to it later.","ea20e205":"### Parsing Data","90cb2b13":"**Options For Working with Data In Colab**\n\nFull list of options and sample code can be found [here](https:\/\/colab.research.google.com\/notebooks\/io.ipynb).","ce136bba":"\nArmed with the [data](https:\/\/github.com\/vigvisw\/end2endml) and the knowledge that you have learned here, you can write a parsing function for any spec in the *devices_data.txt*, as long as you follow the rules below.","1fbe908a":"### Creating Your Own Parsing Functions","881ae6b8":"1. Currently parsing functions can only be defined for **specs**. This includes everything we collected on a device's page. I have kept is this way because, these are things which I conisider a device's feature. You can modify the three classes to parse device information such as **device_name**, **maker_name** etc, if you choose.\n2. The parsing function **must** follow the name format 'parse_' + spec_name. For example, if you are trying to parse the feature **platform_os** as seen in the columns of the *Skeleton Dataset*, the parsing function which you define must be be named **parse_platform_os**.\n3. The return value of the parsing function **must** be a dictionary of the format **{*new_feature_name*:parsed_value,.........}**. The keys of *new_feature_name* will be used used to create new parsed feature column. **Note** that the **new_feature_name**(s) in the above dictionary will replace the input feature in the **all_features_dict**.\n4. Each parsing function that you want to use must be first defined and then passed as a list (or use the function object itself, if using only one) to **ParsingFunction.add_new_parsers()** as an argument.","1b8d05c4":"### Importing Devices Data","3f457b82":"**Rules For Writing Parsing Functions For Devices Data**","0304507e":"### Creating Classes To Work With Devices","00cdb924":"**Note** that Pandas has converted the **maker_id** *0* into the **NaN** object.  We can also get the **tail** of the **DataFrame** to double check that the  rest of the **maker_name**'s are uneffected.","5341c073":"The general procedure that we want to follow is:\n\n1. Split the **device_specs** of device object and iterate through each of the key\/value pairs and create new attributes for the device.\n2. Set the attribute value using using the lower case name of spec while also handling '  ' , ' -', '\u2013 ' characters which can appear in the spec name (Selfie Camera, batsize-hl). This makes it possible to call the attribute of a device.\n3. Use a list called **feature_list** to keep tack of all the attributes (features or specs) of a **Device**. Use a dict called **all_features_dict** to keep track of all the features collected across all devices. This dict itself is an attribute of **FeatureGen**.\n4. Account for any missing values. Although I double checked to make sure that any missing values were parsed as **np.NaN** when building the dataset, for some reason, some of the \"sub specs\" (Battery and Tests in the above output) parsed as the str 'NaN'. Ensure that the Feature Generator has a function to account for these.","8a497448":"Since we are working with multiple related things (devices) onto which we will be applying parsing functions is the future, it is a good idea to define a **class** called **Device** for working with the **devices_dict**.\n\nResources for learning about *Classes* and *Object Oriented Programming*\n1. [Written tutorial](https:\/\/jeffknupp.com\/blog\/2014\/06\/18\/improve-your-python-python-classes-and-object-oriented-programming\/) by Jeff Knupp\n2. [Video tutorial series](https:\/\/www.youtube.com\/watch?v=ZDa-Z5JzLYM&list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc) by Corey Schafer\n3. [Methods vs Functions](https:\/\/www.geeksforgeeks.org\/difference-method-function-python\/) by GeeksForGeeks","a89a44f3":"If we take a look at the data under any device, we can see that the **banner_SPEC_hl** contain repeated information from the other specs. The reason I chose to extract these features is that they make the parsing of certain types of data easier. A prime example of this is the feature **banner_batsize_hl** which tells us the [capacity](http:\/\/web.mit.edu\/evt\/summary_battery_specifications.pdf) of the phone's battery in *mAh* without the need to parse any extra string. While writing regular expressions can be fun, to do it for this many features is a very time consuming process and we should take any help we can. By using the banner feature, simply need to convert the string into an **np.float64** object in order to make it usable for statistical analysis and data visualization.\n\nSince we will be defining parsing functions for a large number of features, I will not be going through each one in detail. I will show you how you can define your own parsing functions for two features using **ParsingFunctions** and I **highly suggest** that you use use the comments and the functions' docstring to understand how the rest work.","07fad881":"First, we want to give each maker in the GSMArena dataset a *maker_id*.","8632fad2":"In the previous step, we managed to build what I call a \"skeleton\" version of the dataset. The name implies that it has all of the bare bones components necessary for exploratory data analysis, which will be the topic of the next tutorial. However, we need to parse the data points first. All the data are currently strings and we need to write functions to extract and format the data in type that we want.\n\nTOo help do this we will use a new class called **ParserFunctions** which will be inherited by **FeatureGen**","f0527193":"Instructions For Using deviceparser.py","9f590cb3":"1. Download *deviceparser.py* and move it to [Python's working directory](https:\/\/stackoverflow.com\/questions\/17359698\/how-to-get-the-current-working-directory-using-python-3\/17361545).\n2. Import the module into your IDE.\n3. At this point, you can define you own parsing functions which must comply with **Rules For Writing Parsing Functions For Devices Data**.\n4. Expose the **ParsingFunctions** class to user defined functions by passing a list of functions to the **ParsingFunctions.add_new_parsers()** method.\n5. Load the **devices_data.txt** file by passing the file path to **Device.read_devices_json()**. This loads in the JSON file as a Python dictionary.\n6. A list of device objects can be created for all the makers by providing the **Device.create_devices_from_data()** method with the dictionary obtained in step 5.\n7. To make it easy to manipulate the data once it has been parsed, the **Device.create_df()** method has been defined, which creates a pandas DataFrame from *devices_data*. As an argument, this method takes in the dict object which was loaded in step 5 and applies **Device.create_devices_from_data()**. An internal dictionary called **all_features_dict** is used to keep track of all the features collected from all the devices. For example, flagship devices released in 2018 and 2019 tend to have three main cameras, which is denoted by the feature *main_camera_triple*. This method is written such that a  device feature listed in the keys of **all_features_dict** is given a value and np.NaN, otherwise.","b29d19ff":"Everything we have made so far can be put together and implemented as a module called **deviceparser**.\n\nThe full source code is copied below and module, called *deviceparser.py*, can be cloned\/download on my [GitHub page](https:\/\/github.com\/vigvisw\/devicedataparser).","bd745f50":"Use a smaller subset of the data so that we can follow along with what is happening. I will use the [Samsung Galaxy S10](https:\/\/www.gsmarena.com\/samsung_galaxy_s10-9536.php). \n\nTo uniqely identify each device, we want to make a **device_id** of the form, **maker_name** + '_' +  **device_num**, where  **device_num** is the key of the device under a maker.","fe7cde3a":"Since we have a class which can extract all the specs (read as *features*) from the spec sheet of a device, we can build the first draft of the dataset. \n\nWe will now create a function called **create_df** which creates **Device** objects out of all the devices in **devices_dict**. Since the features from all devices are being added to the dictionary **all_features_collector** located inside the class **FeatureGen**, we will use the keys of this dictionary as the as columns.","7c4bce44":"The real data we want are the specs of the device which are stored under **device_specs** mostly in the form of dictionaries. The one \"spec\" which is not a dictionary is **Opinions**. We will handle this spec seperately. ","0601c2a4":"Using any of the methods above, Once the data is available, read it in using the **json** module.\n\nResources for learning about *JSON* and I\/O in Python:\n1. [JSON](https:\/\/www.youtube.com\/watch?v=pTT7HMqDnJw) by Socratica\n2. [Reading and Writing Files](https:\/\/www.youtube.com\/watch?v=Uh2ebFW8OYM&t=374s) by Corey Schafer\n","ed574312":"### Putting It All Together","1e182621":"Since each person using this dataset will have their own set of questions to answer, it would be best if we can modify the functionality of  the **ParsingFunctions**  class to take in a list of user defined parsing functions which will then be applied to appropriate colum to get the feature that we want.\n\nTo acheive this, we create a new *classmethod* called **add_new_parser** which can take in either a single function or a list of functions. To parse a device attribute when the device is created, we first need to initialize **ParsingFunctions** by calling the **add_new_parser** method as shown in the code below.\n\n**NOTE:** The two parsing function we defined earlier are no longer defined in the **ParsingFunctions** class. The fact that they are user defined offers us a lot of flexibility.  The features to be parsed in the **allow_parsing** list are also also populated by the **add_new_parser** method. "}}