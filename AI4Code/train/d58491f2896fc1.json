{"cell_type":{"e596173c":"code","62748a00":"code","1f9c917f":"code","46a1fdb4":"code","fd178758":"code","3f5f7375":"code","229122a4":"code","71d8dece":"code","f9cc32ae":"code","4501d986":"code","9813232b":"code","c5a4dba3":"code","79d61051":"code","2b671afd":"code","08f870f3":"code","9ef6949e":"code","46181cab":"code","a291b802":"code","d025d7c7":"code","bb2eb239":"code","b126eebb":"code","689d6734":"code","e7751260":"markdown","d1c4c06f":"markdown","6f0a861f":"markdown","83c0fa47":"markdown","81f2ae9d":"markdown","f3d2bbbb":"markdown","fe99d1eb":"markdown","f66143d8":"markdown","5736e7c3":"markdown","fdef16ee":"markdown","64b787dd":"markdown","24009a8f":"markdown","7c370ca0":"markdown","f90105ed":"markdown","7a149770":"markdown","a5537ec3":"markdown","00e92a29":"markdown","049431a0":"markdown","328e35b2":"markdown","0bb9d0f1":"markdown","86f761fe":"markdown","321d82e0":"markdown","b4390ba9":"markdown"},"source":{"e596173c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom random import randint\nfrom sklearn import metrics\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import KFold, cross_val_score\nfrom sklearn import svm\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\n\nimport warnings\nfrom sklearn import svm\nwarnings.filterwarnings(\"ignore\")\nfrom sklearn.model_selection import train_test_split\nclassifiers = ['LinearSVM', 'RadialSVM', \n               'Logistic',  'RandomForest', \n               'AdaBoost',  'DecisionTree', \n               'KNeighbors','GradientBoosting']\nmodels = [svm.SVC(kernel='linear'),\n          svm.SVC(kernel='rbf'),\n          LogisticRegression(max_iter = 1000),\n          RandomForestClassifier(n_estimators=200, random_state=0),\n          AdaBoostClassifier(random_state = 0),\n          DecisionTreeClassifier(random_state=0),\n          KNeighborsClassifier(),\n          GradientBoostingClassifier(random_state=0)]\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","62748a00":"def split(df,label):\n    X_tr, X_te, Y_tr, Y_te = train_test_split(df, label, test_size=0.25, random_state=42)\n    return X_tr, X_te, Y_tr, Y_te","1f9c917f":"def acc_score(df,label):\n    Score = pd.DataFrame({\"Classifier\":classifiers})\n    j = 0\n    acc = []\n    X_train,X_test,Y_train,Y_test = split(df,label)\n    for i in models:\n        model = i\n        model.fit(X_train,Y_train)\n        predictions = model.predict(X_test)\n        acc.append(accuracy_score(Y_test,predictions))\n        j = j+1     \n    Score[\"Accuracy\"] = acc\n    Score.sort_values(by=\"Accuracy\", ascending=False,inplace = True)\n    Score.reset_index(drop=True, inplace=True)\n    return Score","46a1fdb4":"def initilization_of_population(size,n_feat):\n    population = []\n    for i in range(size):\n        chromosome = np.ones(n_feat,dtype=np.bool)     \n        chromosome[:int(0.3*n_feat)]=False             \n        np.random.shuffle(chromosome)\n        population.append(chromosome)\n    return population","fd178758":"def fitness_score(population):\n    scores = []\n    for chromosome in population:\n        logmodel.fit(X_train.iloc[:,chromosome],Y_train)         \n        predictions = logmodel.predict(X_test.iloc[:,chromosome])\n        scores.append(accuracy_score(Y_test,predictions))\n    scores, population = np.array(scores), np.array(population) \n    inds = np.argsort(scores)                                    \n    return list(scores[inds][::-1]), list(population[inds,:][::-1]) ","3f5f7375":"def selection(pop_after_fit,n_parents):\n    population_nextgen = []\n    for i in range(n_parents):\n        population_nextgen.append(pop_after_fit[i])\n    return population_nextgen\n\n","229122a4":"def crossover(pop_after_sel):\n    pop_nextgen = pop_after_sel\n    for i in range(0,len(pop_after_sel),2):\n        new_par = []\n        child_1 , child_2 = pop_nextgen[i] , pop_nextgen[i+1]\n        new_par = np.concatenate((child_1[:len(child_1)\/\/2],child_2[len(child_1)\/\/2:]))\n        pop_nextgen.append(new_par)\n    return pop_nextgen","71d8dece":"def mutation(pop_after_cross,mutation_rate,n_feat):   \n    mutation_range = int(mutation_rate*n_feat)\n    pop_next_gen = []\n    for n in range(0,len(pop_after_cross)):\n        chromo = pop_after_cross[n]\n        rand_posi = [] \n        for i in range(0,mutation_range):\n            pos = randint(0,n_feat-1)\n            rand_posi.append(pos)\n        for j in rand_posi:\n            chromo[j] = not chromo[j]  \n        pop_next_gen.append(chromo)\n    return pop_next_gen","f9cc32ae":"\ndef generations(df,label,size,n_feat,n_parents,mutation_rate,n_gen,X_train,\n                                   X_test, Y_train, Y_test):\n    best_chromo= []\n    best_score= []\n    population_nextgen=initilization_of_population(size,n_feat)\n    for i in range(n_gen):\n        scores, pop_after_fit = fitness_score(population_nextgen)\n        print('Best score in generation',i+1,':',scores[:1])  #2\n        pop_after_sel = selection(pop_after_fit,n_parents)\n        pop_after_cross = crossover(pop_after_sel)\n        population_nextgen = mutation(pop_after_cross,mutation_rate,n_feat)\n        best_chromo.append(pop_after_fit[0])\n        best_score.append(scores[0])\n    return best_chromo,best_score","4501d986":"data_hd = pd.read_csv(\"..\/input\/heart-disease-uci\/heart.csv\")\ntarget = 'target'\n#splitlabel(data_hd,target)","9813232b":"label_hd = data_hd['target']\ndata_hd_copy = data_hd\ndata_hd_copy.drop(['target'], axis = 1, inplace = True)","c5a4dba3":"print(data_hd.shape[0], \"kay\u0131t ----\" , data_hd.shape[1],\"\u00f6zellik bulunmaktad\u0131r\")","79d61051":"score1 = acc_score(data_hd,label_hd)\nscore1","2b671afd":"logmodel = DecisionTreeClassifier(random_state=0)\nX_train,X_test, Y_train, Y_test = split(data_hd_copy,label_hd)\nchromo_df_pd,score_pd=generations(data_hd_copy,label_hd,size=100,n_feat=data_hd_copy.shape[1],n_parents=64,mutation_rate=0.20,n_gen=7,\n                         X_train = X_train,X_test = X_test,Y_train = Y_train,Y_test = Y_test)","08f870f3":"logmodel = LogisticRegression(max_iter = 1000)\nX_train,X_test, Y_train, Y_test = split(data_hd_copy,label_hd)\nchromo_df_pd,score_pd=generations(data_hd_copy,label_hd,size=100,n_feat=data_hd_copy.shape[1],n_parents=64,mutation_rate=0.20,n_gen=7,\n                         X_train = X_train,X_test = X_test,Y_train = Y_train,Y_test = Y_test)","9ef6949e":"#for logmodel in models:\n#    print(logmodel)\n#    X_train,X_test, Y_train, Y_test = split(data_hd_copy,label_hd)\n#    chromo_df_pd,score_pd=generations(data_hd_copy,label_hd,size=80,n_feat=data_hd_copy.shape[1],n_parents=64,mutation_rate=0.20,n_gen=5,\n#                         X_train = X_train,X_test = X_test,Y_train = Y_train,Y_test = Y_test)","46181cab":"data_hd = pd.read_csv(\"..\/input\/body-performance-data\/bodyPerformance.csv\")\ndata_hd.head()\n","a291b802":"print(data_hd.shape[0], \"kay\u0131t ----\" , data_hd.shape[1],\"\u00f6zellik bulunmaktad\u0131r\")","d025d7c7":"data_hd_copy = data_hd\ndata_hd_copy['class'] = data_hd_copy['class'].str.replace('A','1')\ndata_hd_copy['class'] = data_hd_copy['class'].str.replace('B','2')\ndata_hd_copy['class'] = data_hd_copy['class'].str.replace('C','3')\ndata_hd_copy['class'] = data_hd_copy['class'].str.replace('D','4')\n\n","bb2eb239":"label_hd = data_hd_copy['gender']\ndata_hd_copy.drop(['gender'], axis = 1, inplace = True)\ndata_hd_copy.head()","b126eebb":"score1 = acc_score(data_hd,label_hd)\nscore1","689d6734":"\nlogmodel = LogisticRegression(max_iter = 1000)\nX_train,X_test, Y_train, Y_test = split(data_hd_copy,label_hd)\nchromo_df_pd,score_pd=generations(data_hd_copy,label_hd,size=100,n_feat=data_hd_copy.shape[1],n_parents=64,mutation_rate=0.20,n_gen=7,\n                         X_train = X_train,X_test = X_test,Y_train = Y_train,Y_test = Y_test)","e7751260":"**crossover birinci ebeveyn ile ikinci ebeveyn aras\u0131nda gen \u00e7aprazlanmas\u0131n\u0131 sa\u011flamaktad\u0131r**","d1c4c06f":"<h3>Genetik Algoritma \u00c7al\u0131\u015fma Prensibi <\/h3>","6f0a861f":"**generations belirtilen nesil say\u0131s\u0131 i\u00e7in yukar\u0131daki t\u00fcm  fonksiyonlar\u0131 \u00e7al\u0131\u015ft\u0131rmaktad\u0131r**","83c0fa47":"<h2>Genetik Algoritma Kullan\u0131m Alanlar\u0131<\/h2>","81f2ae9d":"\n<center><img src=\"https:\/\/i.hizliresim.com\/fmck43j.png\">","f3d2bbbb":"**mutation random bir \u015fekilde se\u00e7ilen bit ya da gen \u00fczerinde mutasyon sa\u011flamakta ve onlar\u0131 rastgele \u00e7evirmektedir.**","fe99d1eb":"**Split fonksiyonu veri setimizin training ve test seti olarak par\u00e7alanabilmesini sa\u011flamakt\u0131r.**","f66143d8":"\n<center><img src=\"https:\/\/i.hizliresim.com\/1fd4j5a.png\">","5736e7c3":"# Sklearn Ne \u0130\u015fe Yarar? ","fdef16ee":"# Genetik Algoritma Nedir?","64b787dd":"\n<center><img src=\"https:\/\/i.pinimg.com\/originals\/e1\/3b\/cd\/e13bcd0c2045b0a548d3d1663da17564.gif\">","24009a8f":"**Gerekli k\u00fct\u00fcphanelerin projeye eklenmesi**","7c370ca0":"**B\u00fct\u00fcn s\u0131n\u0131fland\u0131r\u0131c\u0131lar i\u00e7in uygunluk de\u011ferini d\u00f6ndermeye yarayan fonksiyondur.**","f90105ed":"**Kal\u0131t\u0131m** : Bireylerin genetik \u00f6zelliklerini kendilerinden sonraki nesillere aktarabilmesi\n* **\n**\u00c7e\u015fitlilik** : Bir pop\u00fclasyondaki bireylerin kendilerini farkl\u0131 k\u0131lacak \u00f6zelliklere sahip olabilmesi\n* **\n**Seleksiyon** : Bir pop\u00fclasyon i\u00e7erisinde problemimize en uygun \u00e7\u00f6z\u00fcm\u00fc belirleme s\u00fcrecidir. Daha sonra en uygun \u00e7\u00f6z\u00fcmler t\u00fcretilecek \u00e7\u00f6z\u00fcmlerin ebeveynleri olarak hareket etmektedir. Buradaki neslin g\u00fc\u00e7l\u00fc \u00f6zelliklerini yavrulara aktararak en optimal \u00e7\u00f6z\u00fcme odaklan\u0131lmaktad\u0131r.  Se\u00e7im uygunluk de\u011ferleri baz al\u0131nmakta ve Rulet \u00c7ark\u0131 ya da Turnuva y\u00f6ntemi uygulanmaktad\u0131r. \n* **\n**\u00c7aprazlama** : En iyi iki ebeveynden gelen genler yeni bir \u00e7\u00f6z\u00fcm olu\u015fturmak i\u00e7in rastgele de\u011fi\u015ftirildi\u011finde ger\u00e7ekle\u015fmeltedir. Tek Noktal\u0131 ve \u00c7ok Noktal\u0131 \u00e7aprazlama olarak iki t\u00fcr bulunmaktad\u0131r.\n* *Tek Noktal\u0131 \u00c7aprazlama* : Tek noktal\u0131 \u00e7aprazlamada kromozom belirli bir k\u0131sm\u0131n\u0131 bir ebeveynden kalan k\u0131sm\u0131n\u0131 ise di\u011fer ebeveynden almaktad\u0131r.\n* *\u00c7ok Noktal\u0131 \u00c7aprazlama* :  \u00c7ift noktal\u0131 \u00e7aprazlamada ise kromozomun her par\u00e7as\u0131n\u0131 farkl\u0131 bir ebeveyn verebilmektedir.\n\n*A\u015fa\u011f\u0131da \u00f6rnek grafikte sizler i\u00e7in tek noktal\u0131 ve \u00e7ift noktal\u0131 \u00e7aprazlamay\u0131 a\u00e7\u0131klamaya \u00e7al\u0131\u015ft\u0131k*\n\n<center><img src=\"https:\/\/i.hizliresim.com\/r1dvy2p.png\">\n    \n* **\n**Mutasyon** : Se\u00e7im ya da mutasyon kullan\u0131larak yeni bir pop\u00fclasyon olu\u015fturulur ve daha sonra elde edilen yeni pop\u00fclasyon mutasyon yoluyla rastgele de\u011fi\u015ftirilmektedir.\n\n*A\u015fa\u011f\u0131daki \u00d6rnekte sizlere mutasyon a\u015famas\u0131n\u0131 da g\u00f6stermeye \u00e7al\u0131\u015ft\u0131k*\n\n\n","7a149770":"Scikit-learn veri bilimi, makine \u00f6\u011frenmesi ve yapay zeka alanlar\u0131nda en s\u0131k kullan\u0131lan Python k\u00fct\u00fcphanalerinden biridir. Bu alanlarda pek \u00e7ok i\u015flemi ger\u00e7ekle\u015ftirebilmenize imkan sa\u011flarken, bu i\u015flemler s\u0131ras\u0131nda da sizlere b\u00fcy\u00fck kolayl\u0131klar sa\u011flamaktad\u0131r. S\u0131n\u0131flar\u0131, y\u00f6ntemleri ve i\u015flevleriyle uygulamalar\u0131n\u0131z\u0131n arka plan i\u015flemlerini kolayla\u015ft\u0131r\u0131r.\nGenel olarak;\n* Veri i\u015fleme\n* Boyutsal k\u00fc\u00e7\u00fclme\n* Model se\u00e7imi\n* Regresyon\n* S\u0131n\u0131fland\u0131rma\n* K\u00fcme analizi\ngibi i\u015flemlerde kullan\u0131l\u0131yor olsa da kendi i\u00e7erisinde s\u0131k kullan\u0131lan test datalar\u0131n\u0131 dahi bar\u0131nd\u0131rmaktad\u0131r. Numpy, SciPy ve Matplotlib \u00fczerine olu\u015fturulmu\u015ftur. Tamamen a\u00e7\u0131k kaynakl\u0131d\u0131r ve geli\u015ftirilmeye a\u00e7\u0131kt\u0131r. ","a5537ec3":"* **Gen** : Yap\u0131s\u0131nda probleme ait en k\u00fc\u00e7\u00fck bilgiyi ta\u015f\u0131yan birime gen denir. Genellikle her bir gen *bit* olarak ifade edilmektedir.\n* **\n* **Kromozom** : Kromozom, nesil veya pop\u00fclasyonda bulunan bir aday \u00e7\u00f6z\u00fcm\u00fc temsil eder. Genlerden olu\u015fmaktad\u0131r ve bir di\u011fer ismi de genotip olarak bilinmektedir. \n* **\n* **Pop\u00fclasyon** : Olas\u0131 \u00e7\u00f6z\u00fcm bilgilerini i\u00e7ermekte ve kromozomlar\u0131n bir araya gelmesiyle olu\u015fmaktad\u0131r. Buradaki birey say\u0131s\u0131 problemden probleme de\u011fi\u015fiklik g\u00f6sterebilmektedir. Pop\u00fclasyon ne kadar b\u00fcy\u00fcrse problemin \u00e7\u00f6z\u00fclme s\u00fcresi de yine bir o kadar b\u00fcy\u00fcme g\u00f6sterecektir. Birey say\u0131s\u0131 gere\u011finden fazla oldu\u011fu takdirde \u00e7\u00f6z\u00fcm s\u00fcresi gereksiz bir \u015fekilde b\u00fcy\u00fcrken e\u011fer birey say\u0131s\u0131 az olursa bizi optimal de\u011ferlere ula\u015ft\u0131ramayabilmektedir. Edward Grefenstette, genetik algoritmalar i\u00e7in ideal pop\u00fclasyon b\u00fcy\u00fckl\u00fc\u011f\u00fcn\u00fcn 10 ile 160 aras\u0131nda olmas\u0131 gerekti\u011fini savunmaktad\u0131r.\n","00e92a29":"<h2>Genetik Operasyonlar ve Genetik Algoritmalar\u0131n \u00d6zellikleri<h2>","049431a0":"**initilization_of_population Fonksiyonu random olarak bir popluasyon olu\u015fturmaya yaramaktad\u0131r.**","328e35b2":"**selection fonksiyonu en iyi ebeveynlerin se\u00e7ilmesini sa\u011flamaktad\u0131r**","0bb9d0f1":"<h2> Genetik Algoritmada Temel Kavramlar <\/h2> ","86f761fe":"**fitness_score En iyi ebeveynleri uygunluk skorlar\u0131yla birlikte d\u00f6nd\u00fcrmektedir.**","321d82e0":"Genetik algoritma; Charles Darwin taraf\u0131ndan ortaya at\u0131lan ve en uygun olan canl\u0131n\u0131n hayata devam etmesini destekleyen do\u011fal seleksiyon teorisi \u00fczerinden ortaya \u00e7\u0131km\u0131\u015f bir algoritmad\u0131r. Do\u011fal seleksiyon teorisinde yavrular aras\u0131nda hayatta kalmaya en uygun bireyler ebeveynlerinin genleri do\u011frultusunda se\u00e7ilmekte ve yine hayatta kalma \u015fans\u0131n\u0131 artt\u0131rabilmek ad\u0131na \u00e7e\u015fitli \u00e7aprazlama ve mutasyon i\u015flemleri kullan\u0131lmaktad\u0131r. Do\u011fal seleksiyon ile birlikte yeni yavrular hayatta kalma \u015fans\u0131 daha y\u00fcksek ve g\u00fcn\u00fcn \u015fartlar\u0131na optimize edilmi\u015f varl\u0131klara d\u00f6n\u00fc\u015f\u00fcrler. Yapmas\u0131 gerekenler (beslenme, bar\u0131nma, do\u011fal ko\u015fullar kar\u015f\u0131s\u0131nda hayatta kalabilme vs.) konusunda daha geli\u015fmi\u015f ve i\u015flevsel olurlar. Bu tamamen biyolojinin bize sundu\u011fu bir nimettir ve genetik algoritmada da buradan esinlenerek zorlu matematiksel problemlerin \u00fcstesinden gelinmi\u015ftir. Genetik algoritmalarda her nesilde bir de\u011ferlendirme s\u00fcreci bulunmaktad\u0131r. Bu s\u00fcre\u00e7 i\u00e7erisinde bireylerin hayatta kalmaya ne kadar elveri\u015fli olduklar\u0131 yani problemin \u00e7\u00f6z\u00fcm\u00fc i\u00e7in ne kadar uygun olduklar\u0131 saptanmaktad\u0131r. Uygunluk de\u011feri (**fitness**) kavram\u0131 genetik algoritmalardaki en kilit noktalardan birisidir. Karma\u015f\u0131k matematiksel problemler ya da modeller \u00fczerinde \u00e7al\u0131\u015facak bir genetik algoritma sistemi tasarland\u0131\u011f\u0131nda uygunluk de\u011feri \u00fczerinden bu karma\u015f\u0131kl\u0131\u011f\u0131n \u00fcstesinden gelinebilmektedir. Uygunluk de\u011ferini \u00f6l\u00e7ebilmek ad\u0131na uygunluk fonksiyonu olu\u015fturulmal\u0131d\u0131r ve bu fonksiyonun olu\u015fturulmas\u0131 problemin yap\u0131s\u0131na g\u00f6re farkl\u0131l\u0131l\u0131k g\u00f6sterebilmektedir.","b4390ba9":"* Derin \u00f6\u011frenme \u00e7al\u0131\u015fmalar\u0131nda hiperparametrelerin belirlenmesi\n* **\n* Makine \u00d6\u011frenmesi modellerinde \u00f6zellik se\u00e7imlerindeki uygunluk fakt\u00f6r\u00fcn\u00fcn belirlenmesi\n* **\n* \u00c7\u00f6z\u00fclmesi zor olan hatta imkans\u0131z gibi g\u00f6r\u00fcnen problemlerin \u00e7\u00f6z\u00fcmlenmesi\n* ** \n* Deneysel \u00e7al\u0131\u015fmalarda optimizasyon i\u015flemleri\n* **\n* S\u0131n\u0131fland\u0131rma i\u015flemleri\n"}}