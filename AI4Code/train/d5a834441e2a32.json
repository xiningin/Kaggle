{"cell_type":{"8453f5fb":"code","ab21574f":"code","ae4c7353":"code","b1ed2451":"code","7b1dd6bd":"code","f89d1ea1":"code","805f190e":"code","321f4d63":"code","1732abb3":"code","51b2b5b1":"code","5f7c1d8c":"code","38feba7f":"code","a0c06039":"code","111bf204":"code","d518195b":"code","834ad577":"code","c44287da":"code","2c882810":"code","ac10b090":"code","d945e343":"code","904fd332":"code","5f0107cf":"code","4a68bc26":"code","7cd36691":"code","7bba1504":"code","0d0de25b":"code","413a9c38":"code","33e1a697":"markdown","d6b15533":"markdown","5df4842c":"markdown"},"source":{"8453f5fb":"# Getting the test and train data \n!wget https:\/\/s3.eu-central-1.wasabisys.com\/aicrowd-public-datasets\/aicrowd_educational_pkhnd\/data\/public\/test.csv\n!wget https:\/\/s3.eu-central-1.wasabisys.com\/aicrowd-public-datasets\/aicrowd_educational_pkhnd\/data\/public\/train.zip\n!unzip train.zip","ab21574f":"# Importing necessary libraries\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Machine Learning \nfrom sklearn.model_selection import train_test_split","ae4c7353":"train_data_path = \"train.csv\" #path where data is stored\ntrain_data = pd.read_csv(train_data_path) #load data in dataframe using pandas","b1ed2451":"# Getting the test data \ntest_data_path = \"test.csv\"\ntest_data = pd.read_csv(test_data_path)","7b1dd6bd":"train_data.shape, test_data.shape","f89d1ea1":"# Let's look at the training data \ntrain_data.head()","805f190e":"# Data Labels \ntrain_data['label'].value_counts() ","321f4d63":"train_data.head()","1732abb3":"line = train_data.iloc[1]\nprint(type(line))","51b2b5b1":"# Creating a testing dictionary \ntest = {'S1': 1,\n        'C1': 2,\n        'S2': 1,\n        'C2': 3,\n        'S3': 2,\n        'C3': 4,\n        'S4': 2,\n        'C4': 5,\n        'S5': 2,\n        'C5': 6}","5f7c1d8c":"# FUNCTION TO EXTRACT DATA FROM A ROW \ndef series_to_dict(ser):\n    dic = {} \n    \n    # Allot dictionary positions\n    dic['S1'] = ser[0]\n    dic['C1'] = ser[1]\n    dic['S2'] = ser[2]\n    dic['C2'] = ser[3]\n    dic['S3'] = ser[4]\n    dic['C3'] = ser[5]\n    dic['S4'] = ser[6]\n    dic['C4'] = ser[7]\n    dic['S5'] = ser[8]\n    dic['C5'] = ser[9]\n    \n    # Return the dectionary \n    return dic\n\n# Working and tested \nline = train_data.iloc[1]\nprint(series_to_dict(line))","38feba7f":"# Function to check for flush\ndef check_flush(dic):\n    \n    # Extract suites \n    S1 = dic['S1'] \n    S2 = dic['S2'] \n    S3 = dic['S3'] \n    S4 = dic['S4'] \n    S5 = dic['S5'] \n    \n    # Check if all suites same \n    if S1 == S2 == S3 == S4 == S5:\n        return 1    # all matching suites\n    else: \n        return 0\n\n# Working and tested ","a0c06039":"# Function to check for Straight \ndef check_straight(dic):\n    \n    '''\n      input: dictionary containing all cards' info\n      \n    '''\n    \n    # Extract classes\n    C1 = dic['C1'] \n    C2 = dic['C2'] \n    C3 = dic['C3'] \n    C4 = dic['C4'] \n    C5 = dic['C5']\n    \n    class_flag = 1\n    \n    # Make a class list \n    C = [C1, C2, C3, C4, C5]\n    \n    # Sort the list \n    C.sort()\n    \n    # Start checking for a \n    for i in range(len(C)-1):\n        if C[i+1]==C[i]+1:\n            pass\n        else:\n            class_flag = 0\n            break\n    return class_flag\n    \n# Tested and Working ","111bf204":"check_straight(test)","d518195b":"# Check remaining combinations\ndef check_from_4_to_9(dic):\n    \n    '''\n      input: dictionary containing all cards' info\n      \n    '''\n    \n    # Extract classes\n    C1 = dic['C1'] \n    C2 = dic['C2'] \n    C3 = dic['C3'] \n    C4 = dic['C4'] \n    C5 = dic['C5']\n    \n    # Counts the number of unique cards in the sorted list\n    counter = 1\n    \n    # Make a class list \n    C = [C1, C2, C3, C4, C5]\n    C.sort()\n    \n    # Looping through all cases\n    for i in range(1,5):\n        if C[i] == C[i-1]:\n            pass\n        else: \n            counter += 1\n    \n    # 4 unique cards mean one pair\n    if counter == 4:\n        return 1    # Assigned label \n    \n    # 3 unique cards could mean 2 pair or 3 of a kind \n    elif counter == 3: \n        \n        # create counters for val counts \n        count = [1, 0, 0]\n        \n        j = 0\n        for i in range(1, 5):\n            if C[i] == C[i-1]:\n                count[j] += 1\n            else:\n                j+=1\n                count[j] += 1\n        # Sort value counts list \n        count.sort()\n        \n        if count[2] == 2:\n            return 2    # TWO PAIR CONDITION SATISFIED \n        \n        if count[2] == 3: \n            return 3    # THREE OF A KIND CONDTITION SATISFIED \n    \n    # If 2 unique cards then we could have 4 of a kind or full house \n    elif counter == 2: \n        \n        # Check condition for four of a kind \n        if C[0] == C[1]:\n            if C[0] == C[1] == C[2] == C[3]:\n                return 7    # Four of a kind contion satisfied\n            else:\n                # Check full house conditions \n                return 6\n        else:\n            # Only four of a kind possible \n            return 7\n    \n    # If none\n    else:\n        return 0\n                \n# Tested and working      \n            ","834ad577":"check_from_4_to_9(test)","c44287da":"def check_royal(dic):\n    \n    '''\n      input: dictionary containing all cards' info\n      \n    '''\n    \n    # Extract classes\n    C1 = dic['C1'] \n    C2 = dic['C2'] \n    C3 = dic['C3'] \n    C4 = dic['C4'] \n    C5 = dic['C5']\n    \n    # Make a class list \n    C = [C1, C2, C3, C4, C5]\n    C.sort()\n    \n    # Check for Royal \n    if C[0] == 1: \n        for i in range(1, 5):\n            if C[i] != 9 + i:\n                       return 0\n        return 1","2c882810":"# Function to assign labels to the series data \ndef assign_hand_label(ser):\n    \n    '''\n      input: Series containing all the card information\n      output: card hand label\n      \n    '''\n    \n    # Extract Data \n    hand = series_to_dict(ser)\n    # Check if a flush \n    if check_flush(hand):\n        \n        # Check if a Royal Flush \n        if check_royal(hand):\n            return 9\n        \n        # Check if straight flush \n        elif check_straight(hand):\n            return 8\n        \n        else: \n            return 5 \n    \n    # Check for the rest \n    if check_straight(hand) or check_royal(hand):\n        return 4\n    else:\n        return check_from_4_to_9(hand)\n    \n#     # If all fail \n#     else: \n#         return 0 ","ac10b090":"line=train_data.iloc[815]\nassign_hand_label(line)","d945e343":"pred = [] \nfor i in range(len(train_data)):\n    line = train_data.iloc[i]\n    val = assign_hand_label(line)\n    print(\"{}. True Value: {} and Predicted Value: {}\".format(i, line['label'], val))\n    pred.append(val)\n\n","904fd332":"# Check accuracy \nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\ny_train = train_data['label'].values\n\n# Convert pred to series\npred = pd.Series(pred)\nacc_sc = accuracy_score(y_true=y_train, y_pred=pred)\nprint(acc_sc)","5f0107cf":"print(classification_report(y_true=y_train, y_pred=pred))","4a68bc26":"print(confusion_matrix(y_true=y_train, y_pred=pred))","7cd36691":"import seaborn as sns\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(15, 6))\nsns.heatmap(confusion_matrix(y_true=y_train, y_pred=pred), annot=True, cmap='Accent_r')","7bba1504":"print(pred.unique())","0d0de25b":"test_pred = [] \nfor i in range(len(test_data)):\n    line = test_data.iloc[i]\n    val = assign_hand_label(line)\n    test_pred.append(val)","413a9c38":"\n# sub = pd.DataFrame({'label' : test_pred})\n# sub\n# sub.to_csv('submission2.csv', index=False)","33e1a697":"## Predictions on Test Data","d6b15533":"## HARD CODING THE WHOLE THING ","5df4842c":"### Checking the hardcoded functions"}}