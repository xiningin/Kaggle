{"cell_type":{"8827bae8":"code","229a78e1":"code","3e200b10":"code","f1642064":"code","66a21e6a":"code","6f45da31":"code","1cd85b0d":"code","c5423c24":"code","a9aadf0d":"code","9533901d":"code","c3f246e4":"code","f1b9d868":"code","b062d9e2":"code","d81aae27":"code","a3462f3a":"code","bee1a675":"markdown","cfd119e3":"markdown","9694937d":"markdown","62c7dbef":"markdown","77187bcf":"markdown","5052fde8":"markdown","dcf16ab5":"markdown","d879143d":"markdown","1e99434c":"markdown","ea0ba9b3":"markdown","f30eb9f8":"markdown"},"source":{"8827bae8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","229a78e1":"import numpy as np\nimport pandas as pd\nfrom pandasql import sqldf\nimport itertools\nfrom collections import defaultdict\nfrom itertools import permutations,combinations\n","3e200b10":"data = pd.read_csv('\/kaggle\/input\/marketing-campaign\/marketing.csv')\ndata.dropna(axis = 0, inplace = True)\ndata[\"conversion\"]=data[\"converted\"].astype('int')\ndata.to_csv('marketing-clean.csv',index=False)","f1642064":"\ndata = data[['user_id','date_served','marketing_channel','conversion']]\n\ndata","66a21e6a":"#set global funtions\npysqldf = lambda q: sqldf(q, globals())","6f45da31":"#SQL code for coalitions\n\nq = \"\"\"SELECT channels_subset, sum(b.conversion) as conversion_sum\nFROM(\nSELECT user_id, GROUP_CONCAT(DISTINCT(marketing_channel)) as channels_subset, max(conversion) as conversion\nFROM(\nSELECT user_id,marketing_channel,conversion\nFROM data\nORDER BY user_id,marketing_channel\n) a\nGROUP BY user_id)\nb\nGROUP BY channels_subset;\"\"\"\n\nnames = pysqldf(q)\nnames","1cd85b0d":"def power_set(List):\n    PS = [list(j) for i in range(len(List)) for j in itertools.combinations(List, i+1)]\n    return PS","c5423c24":"def subsets(s):\n    '''\n    This function returns all the possible subsets of a set of channels.\n    input :\n            - s: a set of channels.\n    '''\n    if len(s)==1:\n        return s\n    else:\n        sub_channels=[]\n        for i in range(1,len(s)+1):\n            sub_channels.extend(map(list,itertools.combinations(s, i)))\n    return list(map(\",\".join,map(sorted,sub_channels)))","a9aadf0d":"def v_function(A,C_values):\n    '''\n    This function computes the worth of each coalition.\n    inputs:\n            - A : a coalition of channels.\n            - C_values : A dictionnary containing the number of conversions that each subset of channels has yielded.\n    '''\n    subsets_of_A = subsets(A)\n    #print(subsets_of_A)\n    #exit()\n    worth_of_A=0\n    for subset in subsets_of_A:\n        #print(\"subset:\", subset)\n        if subset in C_values:\n            #print(\"subset:\", subset, \"; Value:\", C_values[subset])\n            worth_of_A += C_values[subset]\n    return worth_of_A","9533901d":"def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)","c3f246e4":"def calculate_shapley(df, col_name):\n    '''\n    This function returns the shapley values\n            - df: A dataframe with the two columns: ['channels_subset', 'conversion_sum'].\n            The channel_subset column is the channel(s) associated with the conversion and the count is the sum of the conversions. \n            - col_name: A string that is the name of the column with conversions\n            **Make sure that that each value in channel_subset is in alphabetical order. Email,PPC and PPC,Email are the same \n            in regards to this analysis and should be combined under Email,PPC.\n            ***Be careful with the distinct number of channels because this can signifcantly slow the perfomance of this function.\n            Remember the total possible combinations of channels is 2^(n) where n is the number of channels. If you have 30 channels\n            this is 1,073,741,824 combinations. \n            \n    '''\n    c_values = df.set_index(\"channels_subset\").to_dict()[col_name]\n    df['channels'] = df['channels_subset'].apply(lambda x: x if len(x.split(\",\")) == 1 else np.nan)\n    channels = list(df['channels'].dropna().unique())\n    \n    v_values = {}\n    for A in power_set(channels):\n        v_values[','.join(sorted(A))] = v_function(A,c_values)\n    #print(v_values)\n    n=len(channels)\n    shapley_values = defaultdict(int)\n\n    for channel in channels:\n        for A in v_values.keys():\n            #print(A)\n            if channel not in A.split(\",\"):\n                #print(channel)\n                cardinal_A=len(A.split(\",\"))\n                A_with_channel = A.split(\",\")\n                A_with_channel.append(channel)            \n                A_with_channel=\",\".join(sorted(A_with_channel))\n                # Weight = |S|!(n-|S|-1)!\/n!\n                weight = (factorial(cardinal_A)*factorial(n-cardinal_A-1)\/factorial(n))\n                # Marginal contribution = v(S U {i})-v(S)\n                contrib = (v_values[A_with_channel]-v_values[A]) \n                shapley_values[channel] += weight * contrib\n        # Add the term corresponding to the empty set\n        shapley_values[channel]+= v_values[channel]\/n \n        \n    return shapley_values","f1b9d868":"#visualizations of Shapley attribution\nimport matplotlib.pyplot as plt\nfrom pandas.plotting import scatter_matrix\n%matplotlib inline\nimport seaborn as sns\nresult = pd.DataFrame(list(dict(calculate_shapley(names, \"conversion_sum\")).items()),columns = ['Channel','Contributions'])\n# Visualization\nplt.subplots(figsize=(18, 6))\nsns.barplot(x='Channel', y='Contributions', data=result)\nplt.show()","b062d9e2":"calculate_shapley(names, \"conversion_sum\")","d81aae27":"simple_attr = pd.pivot_table(data, values='conversion', index=['marketing_channel'], aggfunc=np.sum)\nsimple_attr = simple_attr.reset_index()\nsimple_attr","a3462f3a":"# Visualization of simple attributions\nplt.subplots(figsize=(18, 6))\nsns.barplot(x='marketing_channel', y='conversion', data=simple_attr)\nplt.show()","bee1a675":"Return all the possible subsets of a set of channels\n","cfd119e3":"Computes the worth of each coalition.\n","9694937d":"Calculate the factorial of a number (a non-negative integer)\n","62c7dbef":"**Reduce Features to Channels \/ Conversions and dates**","77187bcf":"# Shapley Value Attribution","5052fde8":"Create a function that returns all possible combination of the channel\n","dcf16ab5":"# SIMPLE Attribution","d879143d":"**Ingest Data**","1e99434c":"**Import Libraries**","ea0ba9b3":"Thank the smart people at the below link for this code:\nhttps:\/\/medium.com\/analytics-vidhya\/the-shapley-value-approach-to-multi-touch-attribution-marketing-model-e345b35f3359\n\n","f30eb9f8":"Final code here\n"}}