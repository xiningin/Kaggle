{"cell_type":{"41e11f55":"code","ff1a4972":"code","5bb06554":"code","b1f33e3e":"code","a4be6fae":"code","86063e65":"code","28b44cd7":"code","eaf02653":"code","4049eee9":"code","8e5a970e":"code","d06e3249":"code","148fb481":"code","fb869f3b":"code","1f2742a4":"code","c6447a10":"code","1b912baa":"code","cbf19dcb":"code","36299b59":"code","56196499":"code","c53e6123":"code","53f2989f":"code","0802ecdc":"code","adc3ac55":"code","963a7048":"code","6e1ea35c":"code","14241f63":"code","73917cbc":"code","6b656e1b":"code","b7620a75":"code","c37c8381":"code","2af52f02":"code","1f7bb071":"code","c1317079":"code","4c7f018a":"code","cf10f95e":"code","3bf6b5ee":"code","678ebdef":"code","76c773b3":"code","3bb47ca8":"code","2a61aed7":"code","3691c9f5":"code","50d611c0":"code","8d522d5c":"code","3ef9c5d2":"code","91a5b85f":"code","007bdd57":"code","b7322f9b":"code","543ed853":"code","eb63aba2":"code","ca63b0c2":"code","3723b5bb":"code","bfee7936":"code","2d12349c":"code","7c4c131b":"code","b89e32cf":"code","cf5b37d4":"code","273425b0":"code","94432c4d":"code","8a7c4392":"code","f0e593ab":"code","e38b1b97":"code","3a5c4946":"code","92f3938d":"code","aaf9e8ca":"code","ae587084":"code","26572f06":"code","6333b641":"code","1faaee18":"code","d93d1b48":"code","21e96329":"code","18e2ee6a":"code","3fefcd77":"code","d706f0f7":"code","08c25156":"code","cd243e6e":"code","022f34f0":"code","057921ee":"code","7f588220":"code","9aa2a25a":"code","6260815f":"code","d3c06b6e":"markdown","604e706c":"markdown","04ba840c":"markdown","ae9870d2":"markdown","0acc043e":"markdown","8a988c53":"markdown","1bee8a12":"markdown","89a76380":"markdown","454fcb3d":"markdown","92e650fe":"markdown","785a758b":"markdown","5fac8f78":"markdown","105a8e72":"markdown","76b79c01":"markdown","300b35d4":"markdown","59f9b8eb":"markdown","3cebb5e9":"markdown","21af1e1f":"markdown","fd1196ab":"markdown","4ee1565b":"markdown","6daa7d80":"markdown","8bc8bc00":"markdown","be0c20aa":"markdown","8eee978d":"markdown","6a31f394":"markdown","d1fc059d":"markdown","2ea56822":"markdown","bc40ea59":"markdown","6233a6cd":"markdown","ebab51a1":"markdown","08a002ef":"markdown","a6456561":"markdown","c95cd19c":"markdown","424980e9":"markdown","3e1db2a2":"markdown","b29c8652":"markdown","ba7e0dd8":"markdown","5437c1c1":"markdown","1ec81058":"markdown","1647758f":"markdown","0234df0e":"markdown","6f7a9534":"markdown","94844075":"markdown","b00438d1":"markdown","e5f94082":"markdown","31d24c95":"markdown","d3d5a7dc":"markdown","38bc2144":"markdown","59734b74":"markdown","5c3ec8a9":"markdown","2bd7ae2c":"markdown","181e66f8":"markdown","c17f6853":"markdown","ce7ed321":"markdown","19e44d6e":"markdown","567c3693":"markdown","5b7bf585":"markdown","fec6f3cb":"markdown","abc95d9e":"markdown","5b7e541e":"markdown","9c24f1b4":"markdown","af42348b":"markdown","7b73c737":"markdown","1da323bd":"markdown","72cbb7c3":"markdown","a7151bff":"markdown","340da853":"markdown","572b10f4":"markdown","7ad743a9":"markdown","7b911d86":"markdown","89840298":"markdown","316172f2":"markdown"},"source":{"41e11f55":"import pandas as pd   # package for data analysis\nimport numpy as np    # package for numerical computations\n\n# libraries for visualization\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# to ignore warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# For Preprocessing, ML models and Evaluation\nfrom sklearn.model_selection import train_test_split   # To split the dataset into train and test set\n\nfrom sklearn.linear_model import LogisticRegression     # Logistic regression model\n\nfrom sklearn import preprocessing\nfrom sklearn.preprocessing import LabelEncoder    # for converting categorical to numerical\n\nfrom sklearn.metrics import f1_score    # for model evaluation","ff1a4972":"data = pd.read_csv('https:\/\/raw.githubusercontent.com\/dphi-official\/Datasets\/master\/pharma_data\/Training_set_advc.csv')","5bb06554":"# Take a look at the first five observations\ndata.head()","b1f33e3e":"data.Treated_with_drugs.value_counts()","a4be6fae":"data['Treated_with_drugs'] = data['Treated_with_drugs'].str.upper()","86063e65":"data.Patient_Smoker.value_counts()","28b44cd7":"def smoker(r):\n  if (r == \"NO\") or (r == \"NO \"):\n    return 'NO'\n  elif (r == \"YES\") or (r == \"YES \") or (r == \"YESS\") or (r == \"YESS \"):\n    return 'YES'\n  else:\n    return 'Cannot say'\n\ndata.Patient_Smoker = data.Patient_Smoker.apply(smoker)  # Applying the function to all the entries of Patient_Smoker column","eaf02653":"data.Patient_Rural_Urban.value_counts()","4049eee9":"data.Patient_mental_condition.value_counts()","8e5a970e":"# A concise summary of the data\ndata.info()","d06e3249":"sns.countplot(x='Survived_1_year', data=data)\nplt.show()","148fb481":"# getting only the numerical features\nnumeric_features = data.select_dtypes(include=[np.number])    # select_dtypes helps you to select data of particular types \nnumeric_features.columns","fb869f3b":"numeric_data=data[['Diagnosed_Condition', 'Patient_Age', 'Patient_Body_Mass_Index', 'Number_of_prev_cond', 'Survived_1_year']]  #keeping in the target varibale for analysis purposes\nnumeric_data.head()\n\n# ID_Patient_Care_Situation and Patient_ID are just an ID we can ignore them for data analysis.\n# Number_of_prev_cond is dependent on 7 columns - A, B, C, D, E, F, Z","1f2742a4":"# Checking the null values in numerical columns\nnumeric_data.isnull().sum()","c6447a10":"data['Number_of_prev_cond'] = data['Number_of_prev_cond'].fillna(data['Number_of_prev_cond'].mode()[0])  # filling the missing value of 'Number_of_prev_cond'\n\nnumeric_data['Number_of_prev_cond']=data['Number_of_prev_cond']\nnumeric_data.isnull().sum()\n\n# The returned object by using mode() is a series so we are filling the null value with the value at 0th index ( which gives us the mode of the data)","1b912baa":"# Taking a look at the basic statistical description of the numerical columns\nnumeric_data.describe()","cbf19dcb":"\nfor feature in numeric_data.drop('Survived_1_year', axis = 1).columns:\n  sns.boxplot(x='Survived_1_year', y=feature, data=numeric_data)\n  plt.show()","36299b59":"numeric_data=numeric_data.drop(['Survived_1_year'], axis=1)\ncolormap = sns.diverging_palette(10, 220, as_cmap = True)\nsns.heatmap(numeric_data.corr(),\n            cmap = colormap,\n            square = True,\n            annot = True)\nplt.show()","56196499":"data.isnull().sum()","c53e6123":"data['Treated_with_drugs']=data['Treated_with_drugs'].fillna(data['Treated_with_drugs'].mode()[0])","53f2989f":"data['A'].fillna(data['A'].mode()[0], inplace = True)\ndata['B'].fillna(data['B'].mode()[0], inplace = True)\ndata['C'].fillna(data['C'].mode()[0], inplace = True)\ndata['D'].fillna(data['D'].mode()[0], inplace = True)\ndata['E'].fillna(data['E'].mode()[0], inplace = True)\ndata['F'].fillna(data['F'].mode()[0], inplace = True)\ndata['Z'].fillna(data['Z'].mode()[0], inplace = True)","0802ecdc":"data.isnull().sum()","adc3ac55":"categorical_data = data.drop(numeric_data.columns, axis=1)    # dropping the numerical columns from the dataframe 'data'\ncategorical_data.drop(['Patient_ID', 'ID_Patient_Care_Situation'], axis=1, inplace = True)    # dropping the id columns form the dataframe 'categorical data'\ncategorical_data.head()    # Now we are left with categorical columns only. take a look at first five observaitons","963a7048":"categorical_data.nunique()   # nunique() return you the number of unique values in each column\/feature","6e1ea35c":"# Visualization of categorical columns\nfor feature in ['Patient_Smoker', 'Patient_Rural_Urban', 'Patient_mental_condition']:\n  sns.countplot(x=feature,  hue='Survived_1_year', data=categorical_data)\n  plt.show()\n\n\nplt.figure(figsize=(15,5))\nsns.countplot(x='Treated_with_drugs',  hue='Survived_1_year', data=categorical_data)\nplt.xticks(rotation=90)\nplt.show()\n","14241f63":"drugs = data['Treated_with_drugs'].str.get_dummies(sep=' ') # split all the entries separated by space and create dummy variable\ndrugs.head()","73917cbc":"data = pd.concat([data, drugs], axis=1)     # concat the two dataframes 'drugs' and 'data'\ndata = data.drop('Treated_with_drugs', axis=1)    # dropping the column 'Treated_with_drugs' as its values are now splitted into different columns\n\ndata.head()","6b656e1b":"data.Patient_Smoker.value_counts()","b7620a75":"data.Patient_Smoker[data['Patient_Smoker'] == \"Cannot say\"] = 'NO'    # we already know 'NO' is the mode so directly changing the values 'Cannot say' to 'NO'","c37c8381":"data.drop('Patient_mental_condition', axis = 1, inplace=True)","2af52f02":"data = pd.get_dummies(data, columns=['Patient_Smoker', 'Patient_Rural_Urban'])","1f7bb071":"data.head()","c1317079":"data.info()","4c7f018a":"print(data.ID_Patient_Care_Situation.nunique())     # nunique() gives you the count of unique values in the column\nprint(data.Patient_ID.nunique())","cf10f95e":"data.drop(['ID_Patient_Care_Situation'], axis =1, inplace=True)","3bf6b5ee":"X = data.drop('Survived_1_year',axis = 1)\ny = data['Survived_1_year']","678ebdef":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)","76c773b3":"model = LogisticRegression(max_iter = 1000)     # The maximum number of iterations will be 1000. This will help you prevent from convergence warning.\nmodel.fit(X_train,y_train)","3bb47ca8":"pred = model.predict(X_test)","2a61aed7":"print(f1_score(y_test,pred))","3691c9f5":"from sklearn.feature_selection import SelectFromModel\nfrom sklearn.metrics import accuracy_score, f1_score\nfrom sklearn.ensemble import RandomForestClassifier","50d611c0":"forest = RandomForestClassifier(random_state=1, n_estimators=1000, max_depth=5)\n \nforest.fit(X_train, y_train)","8d522d5c":"y_pred = forest.predict(X_test)\n\nfscore = f1_score(y_test ,y_pred)\nfscore","3ef9c5d2":"!pip install Boruta","91a5b85f":"from boruta import BorutaPy","007bdd57":"boruta_selector = BorutaPy(forest, n_estimators='auto', verbose=2, random_state=1)   # initialize the boruta selector\nboruta_selector.fit(np.array(X_train), np.array(y_train))       # fitting the boruta selector to get all relavent features. NOTE: BorutaPy accepts numpy arrays only.","b7322f9b":"print(\"Selected Features: \", boruta_selector.support_)    # check selected features\n \n\nprint(\"Ranking: \",boruta_selector.ranking_)               # check ranking of features\n\nprint(\"No. of significant features: \", boruta_selector.n_features_)","543ed853":"selected_rfe_features = pd.DataFrame({'Feature':list(X_train.columns),\n                                      'Ranking':boruta_selector.ranking_})\nselected_rfe_features.sort_values(by='Ranking')","eb63aba2":"X_important_train = boruta_selector.transform(np.array(X_train))\nX_important_test = boruta_selector.transform(np.array(X_test))","ca63b0c2":"# Create a new random forest classifier for the most important features\nrf_important = RandomForestClassifier(random_state=1, n_estimators=1000, n_jobs = -1)\n\n# Train the new classifier on the new dataset containing the most important features\nrf_important.fit(X_important_train, y_train)","3723b5bb":"y_important_pred = rf_important.predict(X_important_test)\nrf_imp_fscore = f1_score(y_test, y_important_pred)","bfee7936":"print(rf_imp_fscore)","2d12349c":"from sklearn.model_selection import GridSearchCV\n# Create the parameter grid based on the results of random search \nparam_grid = {\n    'bootstrap': [True, False],\n    'max_depth': [5, 10, 15],\n    'n_estimators': [500, 1000]}","7c4c131b":"rf = RandomForestClassifier(random_state = 1)\n\n# Grid search cv\ngrid_search = GridSearchCV(estimator = rf, param_grid = param_grid, \n                          cv = 2, n_jobs = -1, verbose = 2)","b89e32cf":"grid_search.fit(X_important_train, y_train)","cf5b37d4":"grid_search.best_params_","273425b0":"pred = grid_search.predict(X_important_test)","94432c4d":"f1_score(y_test, pred)","8a7c4392":"import pandas as pd","f0e593ab":"# Load the data\ntest_new_data = pd.read_csv(\"https:\/\/raw.githubusercontent.com\/dphi-official\/Datasets\/master\/pharma_data\/Testing_set_advc.csv\")","e38b1b97":"test_new_data.info()","3a5c4946":"# take a look how the new test data look like\ntest_new_data.head()","92f3938d":"test_new_data.Treated_with_drugs.value_counts()","aaf9e8ca":"test_new_data['Treated_with_drugs'] = test_new_data['Treated_with_drugs'].str.upper()","ae587084":"test_new_data.Patient_Smoker.value_counts()","26572f06":"def smoker(r):\n  if (r == \"NO\") or (r == \"NO \"):\n    return 'NO'\n  elif (r == \"YES\") or (r == \"YES \") or (r == \"YESS\") or (r == \"YESS \"):\n    return 'YES'\n  else:\n    return 'Cannot say'\n\ntest_new_data.Patient_Smoker = test_new_data.Patient_Smoker.apply(smoker)","6333b641":"test_new_data.Patient_Rural_Urban.value_counts()","1faaee18":"test_new_data.Patient_mental_condition.value_counts()","d93d1b48":"test_new_data.isnull().sum()","21e96329":"drugs = test_new_data['Treated_with_drugs'].str.get_dummies(sep=' ') # split all the entries\ndrugs.head()","18e2ee6a":"test_new_data = pd.concat([test_new_data, drugs], axis=1)     # concat the two dataframes 'drugs' and 'data'\ntest_new_data = test_new_data.drop('Treated_with_drugs', axis=1)    # dropping the column 'Treated_with_drugs' as its values are splitted into different columns\n\ntest_new_data.head()","3fefcd77":"test_new_data.Patient_Smoker.value_counts()","d706f0f7":"test_new_data.drop('Patient_mental_condition', axis = 1, inplace=True)","08c25156":"test_new_data = pd.get_dummies(test_new_data, columns=['Patient_Smoker', 'Patient_Rural_Urban'])","cd243e6e":"test_new_data.head()","022f34f0":"test_new_data.info()","057921ee":"test_new_data.drop(['ID_Patient_Care_Situation'], axis =1, inplace=True)","7f588220":"test_new_data.info()","9aa2a25a":"imp_test_features = boruta_selector.transform(np.array(test_new_data))","6260815f":"prediction = grid_search.predict(imp_test_features)","d3c06b6e":"Let's convert all the values in the column - 'Treated_with_drugs' to upper case","604e706c":"New test data has no missing values. So treating missing value is not required.","04ba840c":"There are no same value in different format in columns - 'Patient_Rural_Urban' and 'Patient_mental_condition'. So no data preparation required here. Now our dataset is good to go for EDA.","ae9870d2":"'Patient_Smoker' is also a categorical column and we need to create dummies for this too. If you observe the data, the column 'Patient_Smoker' has a category 'Cannot say'.","0acc043e":"## Thanks for reading the Notebook! Upvote if you learned anything new \ud83d\ude04","8a988c53":"## New Test Data\nTasks to be performed:\n*  Load the new test data\n*  Data Preparation - same as done on training data\n*  If missing values are there then fill the missing values with the same techniques that were used for training dataset\n*  Convert categorical column to numerical\n*  Predict the output\n*  Download the predicted values in csv\n\nWhy do we need to do the same procedure of filling missing values, data cleaning and data preprocessing on the new test data as it was done for the training and evaluation data?\n\n**Ans:** Because our model has been trained on certain format of data and if we don't provide the testing data of the similar format, the model will give erroneous predictions and the accuracy\/f1 score of the model will decrease. Also, if the model was build on 'n' number of features, while predicting on new test data you should always give the same number of features to the model. In this case if you provide different number of features while predicting the output, your ML model will throw a **ValueError** saying something like **'number of features given x; expecting n'**. Not confident about these statements? Well, as a data scientist you should always perform some experiment and observe the results.","1bee8a12":"As you can see there are no missing data now and all the data are of numerical type.","89a76380":"The f1 score by Random Forest classifier is 84% which is better than logistic regression.\n\nWell there are so many feaures to train the model. We can go and try some feature selection techniques and check if the performance of Random Forest is affected or not. And see if with the decrease in the complexity of model is satisfactory with minimal affect to the performance of the model.\n\nWe have used the Boruta feature selector. You can use some other techniques too and see if that is giving better result than Boruta.","454fcb3d":"The f1 score by Logistic Regression model is 79%. Let's try Random Forest Classifier and see if we get better result with it.","92e650fe":"#### **Pre-Processing and Data Cleaning of Categorical Variables**\n","785a758b":"### Prediction","5fac8f78":"So 'Treated_with_drugs' column has 32 unique values while 'Patient_Smoker' has only 3 categorical values. 'Patient_mental_condition' column has only 1 categorical value.","105a8e72":"### Data Preparation - same as we did for training data","76b79c01":"**Can you observe the new test data here?** It is in the same format as our training data before performing any cleaning and preprocessing.","300b35d4":"Next, we will perform EDA on our continuous variables\n\n---\n\n","59f9b8eb":"The column 'Patient_mental_condition' has only one category 'stable'. So we can drop this column as for every observation the entry here is 'stable'. This feature won\u2019t be useful for making the prediction of the target variable as it doesn\u2019t provide any useful insights of the data. Hence, It is better to remove this kind of features.","3cebb5e9":"#### Preprocessing and data cleaning: same as we did on training data","21af1e1f":"The column 'Patient_mental_condition' has only one category 'stable'. So we can drop this column as for every observation the entry here is 'stable'.","fd1196ab":"### **Load Libraries**","4ee1565b":"Now let's convert the remaining categorical column to numerical using get_dummies() function of pandas (i.e. one hot encoding).","6daa7d80":"Let's convert all the values in the column - 'Treated_with_drugs' to upper case","8bc8bc00":"If you remember from above that the Random Forest Classifier with all the features had given f1 score as 82.2% while after selecting some relavent features the Random Forest Classifier has given f1 score as 88.4% which is a good improvement in terms of bothe performance of the model (i.e. the result) and the complexity is also reduced.","be0c20aa":"There can be different ways to deal with the category 'Cannot say'. Here we will consider it as missing value and fill those entries with the mode value of the column.","8eee978d":"# Conclusion\n* It is clearly observable that how the f1 scores increased from logistic regression to random forest, random forest with full features to random forest on the selected features using Boruta. \n* Then again the f1 score increased with Hyper parameter tunning.\n* Also this is one of the approach to solve this problem. There can be many other approaches to solve this problem.\n* We could also try standardizing and normalizing the data or some other algorithms and so on....\n* Well you should try standardizing or normalizing the data and then observe the difference in f1 score.\n* Also try doing using Decision Tree.\n","6a31f394":"*Evaluation:*","d1fc059d":"**observations**\n\n1. The minimum and maximum values for all the numerical columns.\n2. The mean and median (i.e. 50%) value for all the numerical columns are nearly same.\n","2ea56822":"As you can see the accuracy has been improved from 88.4% to 88.8% by selecting some good parameters with the help of hyper parameter tunning - GridSearchCV","bc40ea59":"### **EDA** ","6233a6cd":"We can see above the column - 'Treated_with_drugs' has two different value representing the same drug i.e. DX6 & dx6 are same drugs. This indicates that data preparation is required here. Let's see other categorical columns.","ebab51a1":"### 2. Random Forest","08a002ef":"Let's take a look at the distribution of our target variable to determine if we have a balanced dataset\n","a6456561":"#### *Filling Missing values*","c95cd19c":"We have discussed in our sessions that machine learning models accepts only numerical data. 'Treated_with_drugs' column is a categorical column and has values as combination of one or more drugs. Let's split all those combined drugs into individual drugs and create dummies for that.","424980e9":"This data does not have value as 'Cannot say' in 'Patient_Smoker' column","3e1db2a2":"### 3. Random Forest and Boruta","b29c8652":"### **Load Data**","ba7e0dd8":"So boruta has selected 17 relavent features. # Let's visualise it better in the form of a table","5437c1c1":"#### Build the model with selected features","1ec81058":"## Problem Statement\n### Objective\nA hospital in the province of Greenland has been trying to improve its care conditions by looking at historic survival of the patients. They tried looking at their data but could not identify the main factors leading to high survivals.\n\nYou are the best data scientist in Greenland and they've hired you to solve this problem. Now you are responsible for developing a model that will predict the chances of survival of a patient after 1 year of treatment (Survived_1_year).\n\n### Dataset & Data Description\nThe dataset contains the patient records collected from a hospital in Greenland. The \"Survived_1_year\" column is a target variable which has binary entries (0 or 1).\n\n*  Survived_1_year == 0, implies that the patient did not survive after 1 year of treatment\n*  Survived_1_year == 1, implies that the patient survived after 1 year of treatment\n\nTo load the dataset in your jupyter notebook, use the below command:\n\n\n```\nimport pandas as pd\npharma_data = pd.read_csv('https:\/\/raw.githubusercontent.com\/dphi-official\/Datasets\/master\/pharma_data\/Training_set_advc.csv')\n```\n\n\n#### Data Description:\n\n*  ID_Patient_Care_Situation: Care situation of a patient during treatment\n*  Diagnosed_Condition: The diagnosed condition of the patient\n*  ID_Patient: Patient identifier number\n*  Treatment_with_drugs: Class of drugs used during treatment\n*  Survived_1_year: If the patient survived after one year (0 means did not survive; 1 means survived)\n*  Patient_Age: Age of the patient\n*  Patient_Body_Mass_Index: A calculated value based on the patient\u2019s weight, height, etc.\n*  Patient_Smoker: If the patient was a smoker or not\n*  Patient_Rural_Urban: If the patient stayed in Rural or Urban part of the country\n*  Previous_Condition: Condition of the patient before the start of the treatment ( This variable is splitted into 8 columns - A, B, C, D, E, F, Z and Number_of_prev_cond. A, B, C, D, E, F and Z are the previous conditions of the patient. Suppose for one patient, if the entry in column A is 1, it means that the previous condition of the patient was A. If the patient didn't have that condition, it is 0 and same for other conditions. If a patient has previous condition as A and C , columns A and C will have entries as 1 and 1 respectively while the other column B, D, E, F, Z will have entries 0, 0, 0, 0, 0 respectively. The column Number_of_prev_cond will have entry as 2 i.e. 1 + 0 + 1 + 0 + 0 + 0 + 0 + 0 = 2 in this case. )","1647758f":"#### Evaluation","0234df0e":"We can also see there are some outliers in the columns - 'Patient_Age', 'Patient_Body_Mass_Index', and 'Number_of_prev_cond'. There are various ways to treat the outliers as mentioned in the article https:\/\/towardsdatascience.com\/ways-to-detect-and-remove-the-outliers-404d16608dba. Here I have not treated any outliers.","6f7a9534":"There are two ID columns - 'ID_Patient_Care_Situation' and 'Patient_ID'. We can think of removing these columns if these are randomly generated value and there is not any id repeated like we had done for the 'PassengerId' in Titanic Dataset. 'PassengerId' was randomly generated for each passenger and none of the ids were repeated. So let's check these two ids columns.","94844075":"There should be three category here - NO, YES, and Cannot say","b00438d1":"## Solution steps:\n1. Load data\n2. Data Preparation\n3. Understand your data: EDA\n4. Pre-process the data \n5. Prepare train and test datasets\n6. Choose a model\n7. Train your model\n8. Evaluate the model (F1-score calculation)\n9. Optimize: repeat steps 5 - 7\n","e5f94082":"### **Model Building**\n\nWe have seen from Exploratory Data Analysis that this is a classification problem as the target column 'Survived_1_year' has two values 0 - means the patient did not survive after one year of treatment, 1 - means the patient survived after one year of treatment. So we can use classification models for this problem. Some of the classification models are - Logistic Regression, Random Forest Classifier, Decision Tree Classifier, etc. However, we have used two of them - Logistic Regression and Random Forest Classifier.","31d24c95":"Now let's convert the categorical column to numerical using get_dummies() function of pandas (i.e. one hot encoding).","d3d5a7dc":"Well we have chosen some of the parameters randomly like max_depht, n_estimators. There are many other parameters related to Random Forest model.If you remember we had discussed in our session 'Performance Evaluation' about Hyper parameter tunning. Hyper parameter tunnning helps you to choose a set of  optimal parameters for a model. So let's try if this helps us to further improve the performance of the model. \n\nGrid Search helps you to find the optimal parameter for a model.","38bc2144":"Finally, we must look at the EDA for our categorical variables. However, before analyzing the categorical columns further, we will treat the missing values","59734b74":"A good way to visualize the above information would be boxplots.\n\n**Box Plot**\n\nA box plot is a great way to get a visual sense of an entire range of data. It can tell you about your outliers and what their values are. It can also tell you if your data is symmetrical, how tightly your data is grouped, and if and how your data is skewed.\n\nBox plots divides data into its quartiles. The \u201cbox\u201d shows a user the data set between the first and third quartiles.\n\nThe median gets drawn somewhere inside the box and then you see the most extreme non-outliers to finish the plot. Those lines are known as the \u201cwhiskers\u201d. If there are any outliers then those can be plotted as well.\n\nWith box plots you can answer how diverse or uniform your data might be. You can identify what is normal and what is extreme. Box plots help give a shape to your data that is broad without sacrificing the ability to look at any piece and ask more questions.\n\nIt displays the five-number summary of a set of data. The five-number summary is:\n\n*  minimum\n*  first quartile (Q1)\n*  median\n*  third quartile (Q3)\n*  maximum\n\nBoxplot also helps you to check if there are any outliers in your data or not.\n\nFor reading about boxplot and outliers: https:\/\/towardsdatascience.com\/ways-to-detect-and-remove-the-outliers-404d16608dba\n\nRead more about Box Plots [here](https:\/\/towardsdatascience.com\/understanding-boxplots-5e2df7bcbd51).","5c3ec8a9":"**Observations:**\n\n1. There are 23097 observations divided into 17 columns.\n2. There are some missing values in the dataset.\n","2bd7ae2c":"2. Train\/test split\n\nWe want to check the performance of the model that we built. For this purpose, we always split (both input and output data) the given data into training set which will be used to train the model, and test set which will be used to check how accurately the model is predicting outcomes.\n\nFor this purpose we have a class called 'train_test_split' in the 'sklearn.model_selection' module.","181e66f8":"**Now let's predict the output for new test data**\n\nWell, we will predict the output for new test data using the Random Forest model with the selected features using Boruta and also with the best parameters that we got during hyper parmeter tunning because we have got the highest f1 score with this model on **X_test** data (also called the validation data). We can directly use **grid_search** variable to predict as this variable is the reference to the trained model.","c17f6853":"# Agenda\n*  Problem Statement\n  *  Objective\n  *  Dataset & Data Description\n*  Solution Steps:\n  *  Load data\n  *  Understand your data: Data Analysis and Visualizations (EDA)\n  *  Pre-process the data\n  *  Prepare train and test datasets\n  *  Choose a model\n  *  Train your model\n  *  Evaluate the model (F1-score calculation)\n  *  Optimize: repeat steps 5 - 7\n*  Conclusion\n*  Prediction on New Test data\n  *  Load the new test data\n  *  Fill missing values if any\n  *  Preprocessing and cleaning the data\n  *  Predict the target values","ce7ed321":"#### Displaying features rank wise","19e44d6e":"There should be three category here - NO, YES, and Cannot say","567c3693":"### EDA on Categorical Data\nLet's perform Exploratory Data Analysis on the Categorical data.\nIn the categorical_data variable we'll keep all the categorical features and remove the others.\n\nNote that the features are not being removed from the main dataset - data. We'll select features with a feature selection technique later.","5b7bf585":"### 1. Logistic Regression Model","fec6f3cb":"You can see there are 23097 unique 'ID_Patient_Care_Situation' and there are 23097 total observations in the dataset. So this column can be dropped.\n\nNow, there are only 10570 unique values in the column 'Patient_ID'. This means there are some patient who came two or more times in the hospital because it is possible the same person was sick for two or more than two times (with different illness) and visited hospital for the treatment. And the same patient will have different caring condition for different diseases. \n\nSo there are some useful information in the column - 'Patient_ID' and thus we will not drop this column.","abc95d9e":"##### Evaluating on X_test","5b7e541e":"#### Create a new subset of the data with only the selected features","9c24f1b4":"We can see that 1235 values are missing from 'Number_of_prev_cond' column. We will fill these with the mode. \n\n**Why mode?** As per the data description this column's value is dependent on the seven columns - 'A', 'B', 'C', 'D', 'E', 'F', 'Z'. These columns have values either 0 or 1. Hence these seven columns are categorical columns. So the column 'Number_of_prev_cond' have discrete values from integers 0 to 7 and can be considered as categorical column as it has only 7 different values. Hence here we can fill the missing values with mode.","af42348b":"Now we can look at the distributions of our categorical variables","7b73c737":"**Note:** Before proceeding ahead please revise the feature selection Notebook or the session if you don't remember what is **'Boruta'**.\n\nBoruta is an all-relevant feature selection method. Unlike other techniques that select small set of features to minimize the error, Boruta tries to capture all the important and interesting features you might have in your dataset with respect to the target variable.\n\nBoruta by default uses random forest although it works with other algorithms like LightGBM, XGBoost etc.\n\nYou can install Boruta with the command\n\npip install Boruta","1da323bd":"There are no same value in different format in columns - 'Patient_Rural_Urban' and 'Patient_mental_condition'. So no data preparation required here. Now our dataset is good to go for EDA.","72cbb7c3":"As you can see there are no missing data now and all the data are of numerical type.\n\nThe column - 'ID_Patient_Care_Situation' is an ID. Here we can remove this column too as we did in training dataset.","a7151bff":"### Hyper Parameter Tunning","340da853":"### Checking missing values","572b10f4":"### Data Preparation","7ad743a9":"Following is a correlation analysis between the continuous varibles, visualized using a heatmap","7b911d86":"Primary screenings: \n1. Get a look at the data, its columns and kind of values contained in these columns: df.head()\n2. Stepping back a bit, get a look at the column overview: number, types, NULL counts: df.info()","89840298":"### **Prepare Train\/Test Data**\n\n1. Separating the input and output variables\n\nBefore building any machine learning model, we always separate the input variables and output variables. Input variables are those quantities whose values are changed naturally in an experiment, whereas output variable is the one whose values are dependent on the input variables. So, input variables are also known as independent variables as its values are not dependent on any other quantity, and output variable\/s are also known as dependent variables as its values are dependent on other variable i.e. input variables. Like here in this data, we can see that whether a person will survive after one year or not, depends on other variables like, age, diagnosis, body mass index, drugs used, etc.\n\nBy convention input variables are represented with 'X' and output variables are represented with 'y'.","316172f2":"There are 8000 + patients who did not survive after 1 year of treatment and 14000 + patients who survived after 1 year of treatment. The ratio is 1:2 (approx). So there is no class imbalance"}}