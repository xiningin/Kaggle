{"cell_type":{"3fd5ba80":"code","76d9fef7":"code","ebef6918":"code","4b9de8cb":"code","bcb4c908":"code","45e7f2de":"code","f581e28d":"code","65ef581b":"code","0278dcb2":"markdown"},"source":{"3fd5ba80":"import numpy as np\nimport pandas as pd\nimport glob\nimport tqdm\nfrom collections import OrderedDict\nimport langid # I want english songs","76d9fef7":"csv = pd.read_csv(*glob.glob(\"\/kaggle\/input\/*\/data.csv\"))","ebef6918":"def scale_0_1(df, col):\n    df.loc[:, col] = (df[col]-df[col].mean())\/df[col].std()","4b9de8cb":"attrs = [\"acousticness\", \"danceability\", \"energy\", \"instrumentalness\", \"liveness\", \"loudness\", \"speechiness\", \"tempo\", \"valence\"]\nfor attr in attrs:\n    scale_0_1(csv, attr) # Rescale these attributes to be N(0, 1)\ncsv.loc[:, \"name\"] = csv[\"name\"].str.lower()\ncsv = csv.drop_duplicates(subset=attrs)","bcb4c908":"# langid.classify is a fast way to check the language of the song name\ndef check_en(name):\n    try:\n        return langid.classify(name)[0] in [\"en\"]\n    except:\n        return False\n\ntqdm.tqdm.pandas()\ncsv = csv[csv[\"name\"].progress_apply(lambda x: check_en(x))]","45e7f2de":"song_name = \"i'll do anything\"\nrows = csv[[\"name\", \"id\", \"artists\"]+attrs][csv[\"name\"].str.contains(song_name)]\nvec = rows[attrs].iloc[2].to_numpy() # choose the second song \"let it be - remastered 2009\"\nrows","f581e28d":"# Slow (takes 2 mins to pass through the dataset)\nsimilar_songs = OrderedDict()\nfor index, row in tqdm.tqdm(csv.iterrows()):\n    other_vec = row[attrs].to_numpy()\n    dist = ((vec-other_vec)**2).mean() # Mean squared difference\n    similar_songs[dist] = row[[\"name\", \"artists\"]]","65ef581b":"# recommendations\nfor k, v in sorted(similar_songs.items(), key=lambda x:x[0]):\n    if k > 0.05: break\n    print(k, v['name'], v['artists'])","0278dcb2":"In this first notebook, I am using Spotify data to see which songs are similar to a given song. Similar songs are simply those songs which are close to the vector embedding of the given song. I construct the vector embedding using (scaled version of) attributes like \"acousticness\", ..., \"valence\"."}}