{"cell_type":{"0b6f00e7":"code","47c80e22":"code","307e22bf":"code","16775a1f":"code","12b5b466":"code","41330b90":"code","c48ee6de":"code","edd9dde8":"code","a1d93dc2":"code","10c64171":"code","a768ec9e":"code","06420b8b":"code","69d3ede5":"code","af7fb7c4":"code","08da163f":"code","8042df86":"code","f19fc1e4":"code","05e97d5a":"code","d0624de7":"code","ef688bee":"code","663a4727":"code","825c2407":"code","a38e6654":"markdown","f5a53e57":"markdown","b267bb9e":"markdown","072e9385":"markdown","e41024e6":"markdown","ec155444":"markdown","8cf5e25f":"markdown","907c1423":"markdown","0e574b81":"markdown"},"source":{"0b6f00e7":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport random\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport requests\n!pip install bs4\nfrom bs4 import BeautifulSoup\n\n# Configs\npd.options.display.float_format = '{:,.4f}'.format\nsns.set(style=\"whitegrid\")\nplt.style.use('seaborn')\nseed = 42\nnp.random.seed(seed)\nrandom.seed(seed)","47c80e22":"website='https:\/\/www.worldometers.info\/coronavirus\/#countries' # url for the site \nwebsite_url=requests.get(website).text\nsoup = BeautifulSoup(website_url,'html.parser')","307e22bf":"my_table = soup.find('tbody')\n\ntable_data = []\nfor row in my_table.findAll('tr'):\n    row_data = []\n    for cell in row.findAll('td'):\n        row_data.append(cell.text)\n    if(len(row_data) > 0):\n        data_item = {\"Country\": row_data[1],\n                     \"TotalCases\": row_data[2],\n                     \"NewCases\": row_data[3],\n                     \"TotalDeaths\": row_data[4],\n                     \"NewDeaths\": row_data[5],\n                     \"TotalRecovered\": row_data[6],\n                     \"ActiveCases\": row_data[8],\n                     \"SeriousCritical\": row_data[9],\n                     \"TotCases\/1Mpop\": row_data[10],\n                     \"Deaths\/1Mpop\": row_data[11],\n                     \"TotalTests\": row_data[12],\n                     \"Tests\/1Mpop\": row_data[13],\n                     \"Population\": row_data[14],\n        }\n        table_data.append(data_item)\n\ndf = pd.DataFrame(table_data)","16775a1f":"# Exclude Continents Rows and NAN row\ndf = df[8:] ","12b5b466":"# Example\ndf.iloc[9]","41330b90":"columns = df.columns.tolist()\n\ndef remove_punctuation(x):\n    y = x.replace(',','').replace('+','')\n    return y\n\ndef a_function(x):\n    return x.replace('\\n','')\n\ndfr = pd.DataFrame()\n\nfor c in columns:\n    dfr[c] = df[c].apply(remove_punctuation).replace(r'^\\s*$', np.nan, regex=True)\n\ndfr['Country'] = dfr['Country'].apply(a_function)\ndfr.head()","c48ee6de":"for c in columns[1:]: # excet Countries\n    dfr[c] = dfr[c].fillna(0).replace('N\/A','')\n    dfr[c] = dfr[c].fillna({'':0}).replace('',0)\n    dfr[c] = dfr[c].astype(float).astype(int)\n    \ndfr = dfr.reset_index(drop=True)\ndfr.info()","edd9dde8":"dfr.head()","a1d93dc2":"import datetime\ndt = datetime.datetime.today()\n\ntoday_file = 'covid19-word-o-meter-{:02d}-{:02d}-{:4d}'.format(dt.month,dt.day,dt.year) +'.csv'\ndfr.to_csv(today_file, index=True)","10c64171":"df = dfr","a768ec9e":"import squarify \nimport matplotlib\n\ndef tree_map_cat_feat(dfr, column, title='', threshold=1, figsize=(18, 6), alpha=.7):\n    \"\"\" Print treempa to categorical variables\n    Ex: tree_map_cat_feat(df, 'country', 'top countries in country', 200)\n    \"\"\"\n    plt.figure(figsize=figsize)\n    df_series = dfr[column].value_counts()\n    df_mins = df_series[ df_series <= threshold ].sum()\n    df_series = df_series[ df_series > threshold ]\n    df_series['Others'] = df_mins\n    percentages = df_series \/ df_series.sum()\n    alist, mini, maxi = [], min(df_series), max(df_series)\n    for i in range(len(df_series)):\n        alist.append( df_series.index[i] + '\\n{:.2%}'.format(percentages[i]) )\n    # https:\/\/matplotlib.org\/3.1.0\/tutorials\/colors\/colormaps.html\n    cmap = matplotlib.cm.viridis # Blues, plasma, inferno. \n    norm = matplotlib.colors.Normalize(vmin=mini, vmax=maxi)\n    colors = [cmap(norm(i)) for i in df_series]\n    squarify.plot(sizes=df_series.values, label=alist, color=colors, alpha=alpha)\n    plt.axis('off')\n    plt.title(title)\n    plt.show()\n# tree_map_cat_feat(df, 'top countries', 200)","06420b8b":"from bokeh.io import show\nfrom bokeh.plotting import figure\nfrom bokeh.models import LinearColorMapper, HoverTool, ColorBar\nfrom bokeh.palettes import magma,viridis,cividis, inferno\nfrom bokeh.models import WheelZoomTool, BoxZoomTool, ResetTool\n\ndef eda_us_states_geo_plot(geosource, df_in, title, column, state_column, low = -1, high = -1, palette = -1, plot_width=500):\n    \"\"\"\n    Generate Bokeh Plot to Brazil States:\n        geosource: GeoJSONDataSource of Bokeh\n        df_in: DataSet before transformed in GeoJSONDataSource\n        title: title of plot\n        column: column of df_in to be placed values in geoplot\n        state_column: indicate column with names of States\n        low = (optional) min value of range of color spectre\n        high = (optional) max values of range of color spectre\n        palette: (optional) can be magma, viridis, civis, inferno e etc.. (with number os colors)\n            Example: cividis(8) (8 colors to classify), cividis(256)  (256, more colors to clasify)\n    \"\"\"\n    if high == -1:\n        high = max(df_in[column])\n    if low == -1:\n        low = min(df_in[column])\n    if palette == -1:\n        palette = inferno(24)\n        \n    palette = palette[::-1]\n    color_mapper = LinearColorMapper(palette = palette, low = low, high = high)\n    \n    hover = HoverTool(tooltips = [ ('Contry','@{'+'name'+'}'), (column, '@{'+column+'}{%.2f}')],\n                  formatters={'@{'+column+'}' : 'printf'})\n\n    color_bar = ColorBar(color_mapper=color_mapper, label_standoff=8, width = 450, height = 20, \n                         border_line_color=None, location = (0,0),  orientation = 'horizontal')\n\n    p = figure(title = title, plot_height = 400, plot_width = plot_width, tools = [hover])\n\n    p.xgrid.grid_line_color = None\n    p.ygrid.grid_line_color = None\n    p.xaxis.visible = False\n    p.yaxis.visible = False\n\n    p.patches('xs','ys', source = geosource, line_color = 'black', line_width = 0.25,\n              fill_alpha = 1, fill_color = {'field' : str(column), 'transform' : color_mapper})\n\n    p.add_layout(color_bar, 'below')\n    p.add_tools(WheelZoomTool())\n    p.add_tools(ResetTool())\n    return p   \n\nfrom bokeh.palettes import Turbo256 \nfrom bokeh.models import ColumnDataSource\nfrom bokeh.transform import factor_cmap\nfrom bokeh.palettes import magma,viridis,cividis, inferno\n\ndef eda_bokeh_horiz_bar_ranked(df, column_target, title = '', int_top = 3, second_target = 'state'):\n    \"\"\"\n    Generate Bokeh Plot ranking top fists and last value:\n        df: data_frame\n        column_targe: a column of df inputed\n        title: title of plot\n        int_top: number of the tops\n        column: column of df_in to be placed values in geoplot\n        second_targe = 'state'\n    \"\"\"\n    ranked = df.sort_values(by=column_target, ascending=False).reset_index(drop = True)\n    ranked = ranked.dropna()\n    top_int = int_top\n    # top = ranked[:top_int].append(ranked[-top_int:]) # Bottom an Top\n    top = ranked[:top_int+top_int]# only Top\n    top.index = top.index + 1\n    source = ColumnDataSource(data=top)\n    list_second_target = source.data[second_target].tolist()\n    index_label = list_second_target[::-1] # reverse order label\n\n    p = figure(plot_width=500, plot_height=400, y_range=index_label, \n                toolbar_location=None, title=title)   \n\n    p.hbar(y=second_target, right=column_target, source=source, height=0.85, line_color=\"#000000\",\n          fill_color=factor_cmap(second_target, palette=inferno(24), factors=list_second_target))\n    p.x_range.start = 0  # start value of the x-axis\n\n    p.xaxis.axis_label = \"value of '\" + column_target + \"'\"\n\n    hover = HoverTool()  # initiate hover tool\n    hover.tooltips = [(\"Value\",\"@{\" + column_target + \"}{%.2f}\" ),(\"Ranking\",\"@index\u00b0\")]\n    hover.formatters={'@{'+column_target+'}' : 'printf'}\n\n    hover.mode = 'hline' # set the mode of the hover tool\n    p.add_tools(hover)   # add the hover tooltip to the plot\n\n    return p # show in notebook\n\ndef eda_geplot_state_rank_plot(my_df, primary_column, target_column, first_title, second_title, int_top = 10, location_column = 'state', ):\n    \"\"\"\n    Execute and show all together:\n    @ primary_columns must to be a float to join to make a GeoSource\n    generate_GeoJSONSource_to_districts()\n    eda_seoul_districts_geo_plot()\n    eda_bokeh_horiz_bar_ranked()\n    \"\"\"\n    my_df = my_df.rename({primary_column: target_column}, axis = 1)\n\n    geo_source = generate_GeoJSONSource(my_df)\n\n    geo = eda_us_states_geo_plot(geo_source, my_df, first_title,\n                                       target_column, location_column, palette = inferno(32))\n\n\n    # rank 8 bottom and Up\n    rank = eda_bokeh_horiz_bar_ranked(my_df, target_column, second_title,\n                                      int_top = int_top, second_target = 'Country')\n\n    show( row( geo, rank ))","69d3ede5":"# new functions to geojson of each continent\n\ndef create_geojson_to_one_map(my_df, my_geojson):\n    geo_source_merged_re = my_geojson.merge(my_df, left_on = 'name', right_on = 'Country', how='left')\n    eight_columns = geo_source_merged_re.columns[7]\n    return GeoJSONDataSource( geojson = geo_source_merged_re.to_json()), geo_source_merged_re[['Country', 'year', eight_columns]]\n\ndef geoplot_to_map(my_df, my_geojson, primary_column, target_column, first_title, second_title, int_top = 10, location_column = 'state', plot_width=500):\n    my_df = my_df.rename({primary_column: target_column}, axis = 1)\n\n    geo_source, my_df = create_geojson_to_one_map(my_df, my_geojson)\n\n    geo = eda_us_states_geo_plot(geo_source, my_df, first_title,target_column,\n                                 location_column, palette = inferno(32), plot_width = plot_width)\n\n    rank = eda_bokeh_horiz_bar_ranked(my_df, target_column, second_title,int_top = int_top,\n                                      second_target = 'Country')\n\n    show( row( geo, rank ))","af7fb7c4":"def filter_by_merging_geojson(my_df, my_geojson):\n    return my_geojson.merge(my_df, left_on = 'name', right_on = 'entity', how='left')['Country'].dropna().unique().tolist()","08da163f":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","8042df86":"file_path = '\/kaggle\/working\/' + today_file\ndf = pd.read_csv(file_path)\nprint(\"DataSet = {:,d} rows and {} columns\".format(df.shape[0], df.shape[1]))\n\nprint(\"\\nAll Columns:\\n=>\", df.columns.tolist())\n\nquantitative = [f for f in df.columns if df.dtypes[f] != 'object']\nqualitative = [f for f in df.columns if df.dtypes[f] == 'object']\n\nprint(\"\\nStrings Variables:\\n=>\", qualitative,\n      \"\\n\\nNumerics Variables:\\n=>\", quantitative)\n\ndf.head()","f19fc1e4":"dfs = df.describe(include='all').T.fillna('').rename(columns={'freq': 'freq of top'})\ndfs['dtypes'] = df.dtypes\ndfs['Missing'] = df.isnull().sum().values\ndfs","05e97d5a":"from bokeh.io import output_notebook, show\nfrom bokeh.plotting import figure\nfrom bokeh.models.tools import HoverTool\nfrom bokeh.models import GeoJSONDataSource\nfrom bokeh.layouts import row\noutput_notebook()\n\nimport geopandas as gpd\n\n# import geojson\ngeojson = gpd.read_file('..\/input\/world-map-eckert3\/world-eckert3.geo.json')\n\n# delete useless columns\nlist_to_delete = ['id', 'hc-group', 'hc-middle-x', 'hc-middle-y', 'hc-key', 'hc-a2',\n                  'labelrank', 'woe-id', 'labelrank', 'iso-a3', 'iso-a2', 'woe-id']\n\n# Replace in GEO\nreplace_dict = {'United States of America': 'USA', 'United Republic of Tanzania': 'Tanzania',\n                'Republic of Serbia': 'Serbia', 'The Bahamas':'Bahamas', 'United Kingdom': 'UK', \n               'Republic of Congo': 'Congo', 'Czech Republic': 'Czechia', 'South Korea': 'S. Korea',\n}\ngeojson = geojson.drop(list_to_delete, axis = 1).dropna().replace(replace_dict)\n\n# Replace COVID Countries Names\n\nreplace_dict_covid_contries = {'Brunei ': 'Brunei', 'Cabo Verde': 'Cape Verde', 'Faeroe Islands': 'Faroe Islands',\n                'UAE': 'United Arab Emirates', 'Vatican City': 'Vatican', 'North Macedonia': 'Macedonia',\n                'CAR': 'Central African Republic', 'Guinea-Bissau': 'Guinea Bissau', 'DRC': 'Democratic Republic of the Congo'\n}\ndf['Country'] = df['Country'].replace(replace_dict_covid_contries)\n\ndef generate_GeoJSONSource(my_df):\n    global geojson\n    geo_source_merged = geojson.merge(my_df, left_on = 'name', right_on = 'Country')\n    return GeoJSONDataSource( geojson = geo_source_merged.to_json())\n\n# show\ngeojson.head(3)","d0624de7":"df.head()","ef688bee":"geo_source_merged = geojson.merge(df, left_on = 'name', right_on = 'Country', how='right') # Join\ngeo_source_merged['name'] = geo_source_merged['name'].fillna('mising')\n\n# list of contries in geoJSON\ngeojson_countries = geojson['name'].tolist()\ngeojson_countries.sort()\n\n# list of contries in COVID-DATASET\ncovid_data_countries = df['Country'].tolist()\ncovid_data_countries.sort()\n\ndata_in_covid_not_in_geo = []\nfor country in covid_data_countries:\n    if(country not in geojson_countries):\n        data_in_covid_not_in_geo.append(country)\n        \ndata_in_geo_not_in_covid = []\nfor country in geojson_countries:\n    if(country not in covid_data_countries):\n        data_in_geo_not_in_covid.append(country)\n        \nprint('\\nHas in COVID but NOT IN GEO (SHOW COVID):\\n', data_in_covid_not_in_geo)\nprint('\\nHas in GEO but NOT IN COVID (SHOW GEO):\\n', data_in_geo_not_in_covid)","663a4727":"primary_column = 'TotalDeaths'\ntarget_column = 'TotalDeaths'\n\ndf1 = df.groupby(['Country']).sum()[primary_column].reset_index()\ndf1 = df1.drop(df1[df1['Country'].isin(remove_list)].index, axis=0) # remove_list: removes mismatched data\n\neda_geplot_state_rank_plot(df1, primary_column, target_column,\n                           \"Total Of Deaths in World\", \"The Top 20 Countries on Deaths\")","825c2407":"primary_column = 'Deaths\/1Mpop'\ntarget_column = 'Deaths by Population'\n\ndf1 = df.groupby(['Country']).sum()[primary_column].reset_index()\ndf1 = df1.drop(df1[df1['Country'].isin(remove_list)].index, axis=0) # remove_list: removes mismatched data\n\neda_geplot_state_rank_plot(df1, primary_column, target_column,\n                           \"Deaths by Population in World\", \"The Top 20 Countries on Deaths by Population\")","a38e6654":"## Snippets","f5a53e57":"<h1 align=\"center\"> COVID19 WorldOMeter TEMP <\/h1>\n\n<img src=\"https:\/\/www.paho.org\/sites\/default\/files\/styles\/flexslider_full\/public\/2020-03\/blue-covid-banner.jpg\" width=\"50%\" \/>\n\nCreated: 2021-04-08 || Last updated: 2020-04-08\n\nKaggle Kernel made by \ud83d\ude80 <a href=\"https:\/\/www.kaggle.com\/rafanthx13\"> Rafael Morais de Assis<\/a>\n\nWebScrap based on [link](https:\/\/www.kaggle.com\/milobele\/scraping-covid-19-data-from-worldometer-site)\n\nDataset get from [worlOmeter](https:\/\/www.worldometers.info\/coronavirus\/#countries)","b267bb9e":"## GeoSource","072e9385":"## WebScraping WoldOMeter <a id=\"top\"><\/a>\n\nWeb Scraping Site\n","e41024e6":"## GeoCharts","ec155444":"## Clean Data\n\nClean Data: remove punctuation and black spaces","8cf5e25f":"## Finaly DataSet and Export","907c1423":"## Explonatory Data Analysis","0e574b81":"## Table Of Content (TOC) <a id=\"top\"><\/a>\n\n## Import Libs and DataSet"}}