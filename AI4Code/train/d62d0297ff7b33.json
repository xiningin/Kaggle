{"cell_type":{"11f36f10":"code","4c96d63c":"code","5eddb34a":"code","d84e6c1d":"code","8ebb9803":"code","0964f7a8":"code","2fe778fa":"code","166b94b1":"code","2737d004":"code","5ba125d4":"code","f5471ede":"code","7651a5af":"code","90a34fce":"code","37d9786f":"code","46bc66c1":"code","792151e2":"code","9363c2a4":"code","917c4ce3":"code","778c114b":"code","be1bef5e":"code","7bf676e8":"code","0603c240":"code","95440a21":"code","3dd3c62f":"code","e5ca3f28":"code","cdbec23a":"code","a5c9a752":"code","ab922ad7":"code","cb029ddc":"code","f19145dd":"code","4188c19f":"code","54b60c83":"code","421ff5c2":"code","de489be0":"code","f676ca32":"code","866eeb5e":"code","e6e145da":"code","53972719":"code","c6ceb17a":"code","1cf01c61":"code","c940e2d4":"code","63b76168":"code","7e89cf25":"code","c21c61bf":"code","4560751b":"code","d0f9aaec":"code","8532a3ca":"code","0ea77c21":"code","91f1c939":"code","a7f9168f":"code","7614a3dd":"code","3112e16b":"code","f7cd3326":"code","c92f3c2d":"code","c84c9ff0":"markdown","45eb9928":"markdown","c89fd684":"markdown","8c3dbd1a":"markdown","5dc93ca9":"markdown","9cac6429":"markdown","bde48dfe":"markdown","8c01c6a3":"markdown","54373372":"markdown","ced40f89":"markdown","b8b639fc":"markdown","0112dc2a":"markdown","31805dca":"markdown","bfefb641":"markdown","96534ab3":"markdown","1474d89e":"markdown","5b37c8f6":"markdown"},"source":{"11f36f10":"import numpy as np\nimport pandas as pd\nfrom pathlib import Path\nimport cv2\nfrom tqdm import tqdm\nimport re\nimport time\n\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.ensemble import RandomForestClassifier\n\nfrom keras.applications import resnet50\nfrom keras import layers, models, callbacks\n\nimport matplotlib.pyplot as plt\n%matplotlib inline","4c96d63c":"!ls ..\/input","5eddb34a":"!ls ..\/input\/petfinder-adoption-prediction","d84e6c1d":"!ls ..\/input\/keras-pretrained-models\/","8ebb9803":"df = pd.read_csv(\"..\/input\/petfinder-adoption-prediction\/train\/train.csv\", header=0)","0964f7a8":"image_paths = list(Path(\"..\/input\/petfinder-adoption-prediction\/train_images\").glob(\"*.jpg\"))\nimage_ids = [x.stem.split(\"-\")[0] for x in image_paths]","2fe778fa":"df = df.merge(pd.DataFrame({\"PetID\":image_ids, \"ImagePath\":image_paths}), on=\"PetID\", how=\"outer\")","166b94b1":"has_images_mask = ~df[\"ImagePath\"].isnull()","2737d004":"print(\"Number of entries without images: {0}\".format((~has_images_mask).sum()))","5ba125d4":"fig = plt.figure(figsize=(10, 4))\n\nax0 = fig.add_subplot(1, 2, 1)\nax0.set_title(\"Has Images\")\nax0.hist(df[has_images_mask][\"AdoptionSpeed\"].values)\nax0.set_xlabel(\"Adoption Speed\")\nax0.set_ylabel(\"Count\")\n\nax1 = fig.add_subplot(1, 2, 2, sharex=ax0)\nax1.set_title(\"Doesn't have images\")\nax1.hist(df[~has_images_mask][\"AdoptionSpeed\"].values);","f5471ede":"train_df = df.dropna(subset=[\"ImagePath\"])","7651a5af":"# This is only for testing\n# train_df = train_df.sample(100)","90a34fce":"IMAGE_HEIGHT = 64\nIMAGE_WIDTH = 64","37d9786f":"def read_image(p, image_height, image_width):\n    image = cv2.imread(str(p))\n    image = cv2.resize(image, (image_width, image_height))\n    # image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    # image = np.expand_dims(image, 2)\n    image = image.astype(np.float32) \/ 255.0\n    return image","46bc66c1":"images = []\n\nfor p in tqdm(train_df[\"ImagePath\"].values):\n    image = read_image(p, IMAGE_HEIGHT, IMAGE_WIDTH)\n    images.append(image)","792151e2":"images = np.stack(images)","9363c2a4":"images.shape","917c4ce3":"adoption_speed = train_df[\"AdoptionSpeed\"].values","778c114b":"ohe = OneHotEncoder()\nohe.fit(adoption_speed.reshape(-1, 1));","be1bef5e":"adoption_speed_ohe = ohe.transform(adoption_speed.reshape(-1, 1))","7bf676e8":"adoption_speed_ohe.shape","0603c240":"INPUT_SHAPE = (IMAGE_HEIGHT, IMAGE_WIDTH, 3)\nNUM_CLASSES = len(ohe.categories_[0])","95440a21":"base_model = resnet50.ResNet50(include_top=False, weights=None, input_shape=INPUT_SHAPE, pooling=\"avg\")","3dd3c62f":"x = base_model.output\n# x = layers.Dense(1024, activation=\"relu\")(x)\n# x = layers.Dropout(0.5)(x)\nout = layers.Dense(NUM_CLASSES, activation=\"softmax\")(x)\n\nmodel = models.Model(inputs=base_model.input, outputs=out)","e5ca3f28":"model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=[\"accuracy\"])","cdbec23a":"fig, axs = plt.subplots(1, 2, figsize=(12, 4))\naxs[0].hist(model.get_layer(\"res2c_branch2c\").get_weights()[0].flatten(), bins=50)\naxs[1].hist(model.get_layer(\"res5c_branch2c\").get_weights()[0].flatten(), bins=50);","a5c9a752":"imagenet_weights_path = \"..\/input\/keras-pretrained-models\/resnet50_weights_tf_dim_ordering_tf_kernels_notop.h5\"","ab922ad7":"model.load_weights(imagenet_weights_path, by_name=True)","cb029ddc":"fig, axs = plt.subplots(1, 2, figsize=(12, 4))\naxs[0].hist(model.get_layer(\"res2c_branch2c\").get_weights()[0].flatten(), bins=50)\naxs[1].hist(model.get_layer(\"res5c_branch2c\").get_weights()[0].flatten(), bins=50);","f19145dd":"layer_regex = {\n    \"3+\": r\"(res3.*)|(bn3.*)|(res4.*)|(bn4.*)|(res5.*)|(bn5.*)\",\n    \"4+\": r\"(res4.*)|(bn4.*)|(res5.*)|(bn5.*)\",\n    \"5+\": r\"(res5.*)|(bn5.*)\",\n    \"all\": \".*\",\n}","4188c19f":"trainable_layers = layer_regex[\"3+\"]","54b60c83":"for layer in model.layers:\n    if not layer.weights:\n        continue\n    \n    if re.fullmatch(trainable_layers, layer.name):\n        layer.trainable = True\n    else:\n        layer.trainable = False","421ff5c2":"print(\"Number of trainable layers: {0}\".format(len([x for x in model.layers if x.trainable])))","de489be0":"class KernelRunTimeCallback(callbacks.Callback):\n    def __init__(self, init_timestamp, max_runtime_in_secs):\n        super(callbacks.Callback, self).__init__()\n        self.init_timestamp = init_timestamp\n        self.max_runtime_in_secs = max_runtime_in_secs\n    \n    def on_batch_end(self, batch, logs=None):\n        elapsed_time = time.time() - self.init_timestamp\n        if elapsed_time > self.max_runtime_in_secs:\n            self.model.stop_training = True\n            print(\"Training stopped due to maximum kernel runtime restriction\")","f676ca32":"BATCH_SIZE = 32\nEPOCHS = 100","866eeb5e":"early_stopping = callbacks.EarlyStopping(monitor=\"val_loss\", patience=20, verbose=1)\ncheckpoint_file_path = \"model_checkpoint.h5\"\nmodel_checkpoint = callbacks.ModelCheckpoint(checkpoint_file_path,\n                                             monitor=\"val_loss\",\n                                             verbose=1,\n                                             save_best_only=True,\n                                             save_weights_only=True)\nkernel_runtime_callback = KernelRunTimeCallback(time.time(), 110*60)","e6e145da":"callbacks = [early_stopping, model_checkpoint, kernel_runtime_callback]","53972719":"hist = model.fit(images,\n                 adoption_speed_ohe,\n                 batch_size=BATCH_SIZE,\n                 epochs=EPOCHS,\n                 validation_split=0.2,\n                 shuffle=True,\n                 callbacks=callbacks)","c6ceb17a":"plt.plot(hist.history[\"val_loss\"], label=\"validation loss\")\nplt.plot(hist.history[\"loss\"], label=\"train loss\")\nplt.legend();","1cf01c61":"plt.plot(hist.history[\"val_acc\"], label=\"validation accuracy\")\nplt.plot(hist.history[\"acc\"], label=\"train accuracy\")\nplt.legend();","c940e2d4":"model.load_weights(checkpoint_file_path)","63b76168":"forest = RandomForestClassifier(n_estimators=100)","7e89cf25":"imageless_df = df[~has_images_mask]\nfeature_mtx = imageless_df[df.columns[2:17]].values\nadoption_speed = imageless_df[\"AdoptionSpeed\"].values","c21c61bf":"forest.fit(feature_mtx, adoption_speed);","4560751b":"test_df = pd.read_csv(\"..\/input\/petfinder-adoption-prediction\/test\/test.csv\", header=0)","d0f9aaec":"image_test_paths = list(Path(\"..\/input\/petfinder-adoption-prediction\/test_images\").glob(\"*.jpg\"))\nimage_test_ids = [x.stem.split(\"-\")[0] for x in image_test_paths]","8532a3ca":"tmp_df = pd.DataFrame({\"PetID\":image_test_ids, \"ImagePath\":image_test_paths})\ntest_df = test_df.merge(tmp_df, on=\"PetID\", how=\"outer\")","0ea77c21":"# Just for testing\n# test_df = test_df.sample(100)","91f1c939":"print(\"Number of entries without images: {0}\".format(test_df[\"ImagePath\"].isnull().sum()))","a7f9168f":"pet_ids = test_df[\"PetID\"].values\nimage_paths = test_df[\"ImagePath\"].values\nfeature_vector = test_df[test_df.columns[2:17]].values\n\npred_adoption_speed = []\n\nfor pet_id, image_path, feature_vector in tqdm(zip(pet_ids, image_paths, feature_vector)):\n    if str(image_path) == \"nan\":\n        pred = forest.predict(np.expand_dims(feature_vector, 0))[0]\n        pred_adoption_speed.append(pred)\n    else:\n        image = read_image(image_path, IMAGE_HEIGHT, IMAGE_WIDTH)\n        pred = model.predict(np.expand_dims(image, 0))[0]\n        pred = np.argmax(pred)\n        pred_adoption_speed.append(pred)","7614a3dd":"submission_df = pd.DataFrame()\nsubmission_df[\"PetID\"] = pet_ids\nsubmission_df[\"AdoptionSpeed\"] = pred_adoption_speed","3112e16b":"submission_df = submission_df.groupby(\"PetID\").mean().reset_index()\n# TODO: rounding\nsubmission_df[\"AdoptionSpeed\"] = submission_df[\"AdoptionSpeed\"].astype(int)","f7cd3326":"submission_df.shape","c92f3c2d":"submission_df.to_csv(\"submission.csv\", index=False)","c84c9ff0":"### 2.1 Load Imagenet weights (and check if it loaded)","45eb9928":"### 5. 1 Test Data","c89fd684":"### 1.2 Prepare Label","8c3dbd1a":"### 2.3 Custom Callback","5dc93ca9":"----------------------------","9cac6429":"---------------------------","bde48dfe":"## 1. Prepare data","8c01c6a3":"### 3. 1 Load back the \"best weights\"","54373372":"## 2. Model","ced40f89":"## 3. Train Model","b8b639fc":"## 5. Prediction","0112dc2a":"## 4. Imageless entries model - Random Forest","31805dca":"### 1.1 Prepare Images","bfefb641":"### 2.2 Set Trainable Layers","96534ab3":"### 5.2 Classification","1474d89e":"### 5.3 Creating Submission","5b37c8f6":"--------------------------"}}