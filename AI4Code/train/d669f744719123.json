{"cell_type":{"646f785e":"code","1aeca401":"code","80cf18f9":"code","f924f79f":"code","23e4ee5e":"code","e926106e":"markdown","04c8c0f7":"markdown","270e7a3d":"markdown","5505c0ba":"markdown","74a0d2c0":"markdown","abe3e4f7":"markdown","ca79289d":"markdown","f157a9ed":"markdown","c59d1dd2":"markdown","d36fe790":"markdown","ba568648":"markdown","f5ab151d":"markdown","2eb83d18":"markdown","ad817076":"markdown","6ee3f5ad":"markdown","ee6c2b71":"markdown","822e45ce":"markdown"},"source":{"646f785e":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\n\nimport seaborn as sns\nimport os\nfrom pathlib import Path\nimport collections\n\n\n\"\"\"\nPossible Events\n['None' 'ball_snap' 'pass_forward' 'pass_arrived' 'pass_outcome_caught'\n 'first_contact' 'out_of_bounds' 'line_set' 'tackle' 'play_action'\n 'touchdown' 'pass_outcome_incomplete' 'pass_tipped'\n 'pass_outcome_touchdown' 'fumble' 'fumble_offense_recovered' 'qb_sack'\n 'fumble_defense_recovered']\n\n\"\"\"\nstart_of_pass_event = np.array(['pass_forward', 'pass_shovel'])\nend_of_pass_event = np.array(['pass_outcome_incomplete', 'pass_outcome_caught', 'pass_outcome_touchdown'])\nskip_plays_where = np.array(['qb_sack','qb_strip_sack','pass_outcome_interception'])\nusable_defense_attributes = ['x','y','r','dir','s','a']\n\n\n# ===============\nweeks = [pd.read_csv(f\"..\/input\/nfl-big-data-bowl-2021\/week{i}.csv\") for i in range(1,18)]\nweeks_df = pd.concat(weeks,axis=0)\n# ===============\n# weeks_df = pd.read_csv(\"..\/input\/nfl-big-data-bowl-2021\/week1.csv\")\n# ===============\n\nplays_df = pd.read_csv('..\/input\/nfl-big-data-bowl-2021\/plays.csv')\n\ndef dist(player1, player2):\n    return np.sqrt((player1[0] - player2[0])**2 + (player1[1] - player2[1])**2)\n\n# given a play slice, find which player is closest to the football at the throw frame \ndef get_passer(play_slice, offense_team):\n    throw_frame = play_slice[(play_slice.event.isin(start_of_pass_event)) & (play_slice.team == offense_team)]\n    football = play_slice[(play_slice.event.isin(start_of_pass_event)) & (play_slice.team == 'football')]\n    passer = throw_frame.iloc[((throw_frame['x']-football['x'].values)**2 + (throw_frame['y']-football['y'].values)**2).argsort()[:1]]\n    try:\n        assert(len(passer) == 1)\n    except:\n        print(play_slice.event.unique())\n        assert(len(passer) == 1) # force error \n    return passer\n    \n# given a play slice, find which player is closest to the football at the catch frame \ndef get_receiver(play_slice, offense_team):\n    catch_frame = play_slice[(play_slice.event.isin(end_of_pass_event)) & (play_slice.team == offense_team)]\n    football = play_slice[(play_slice.event.isin(end_of_pass_event)) & (play_slice.team == 'football')]\n    receiver = catch_frame.iloc[((catch_frame['x']-football['x'].values)**2 + (catch_frame['y']-football['y'].values)**2).argsort()[:1]]\n    try:\n        assert(len(receiver) == 1)\n    except:\n        print(play_slice.event.unique())\n        print(len(receiver))\n        assert(len(receiver) == 1) # force error\n    return receiver\n\ndef sort_by_distance_to(players, target):\n    \n    try:\n        dists = np.sqrt((players['x']-target['x'].values)**2 + (players['y']-target['y'].values)**2)\n    except:\n        print(players.shape,target.shape)\n        assert(False)\n    \n    players = pd.concat([players, pd.DataFrame({'r' : dists})], axis=1, sort=False) # store distances to receiver\n    sorted_args = dists.argsort()\n    sorted_players = players.iloc[sorted_args]\n    return sorted_players\n\ndef store_play_info(week_df, dictionary={}, player_dictionary={}):\n    data = []\n    max_row_len = 0\n    play_info_dict = {}\n    skipped = []\n    total = 0    \n    games = week_df.gameId.unique() # gameId are the only globally unique identifier\n    print(\"Gathering Data...\")\n    for gameId in games:\n        game_slice = week_df[week_df.gameId == gameId]\n        plays = game_slice.playId.unique() # playId is unique within the scope of each game\n        for playId in plays:\n            total+=1\n            \n            play_slice = game_slice[game_slice.playId == playId]      \n            \n            # if one of these specific events, skip play\n            e = [reason in play_slice.event.values for reason in skip_plays_where]\n            if(any(e)):\n                skipped += skip_plays_where[e].tolist()\n                continue\n                \n            # if these start of pass events do not happen, skip play\n            e = [reason in play_slice.event.values for reason in start_of_pass_event]\n            if(not any(e)):\n                skipped += start_of_pass_event[e].tolist()\n                continue\n                \n            # if these end of pass events do not happen, skip play\n            e = [reason in play_slice.event.values for reason in end_of_pass_event]\n            if(not any(e)):\n                skipped += end_of_pass_event[e].tolist()\n                continue\n            \n            # figure out which team is on offense during this play\n            offense_team = play_slice[play_slice.position == 'QB'].team\n            # error in data, skip this one play\n            if(len(offense_team) == 0):\n                continue\n            offense_team = offense_team.values[0]\n            defense_team = 'away' if offense_team == 'home' else 'home'\n            \n            # identify passer and receiver \n            try:\n                passer = get_passer(play_slice, offense_team = offense_team)\n                receiver = get_receiver(play_slice, offense_team=offense_team)\n            except:\n                skipped += ['unknown']\n                continue\n                \n            play = plays_df.query('gameId == @gameId and playId == @playId') # check if the passer and receiver are correct by getting play desc\n            \n#             # ===================================================\n#             # proof passer and receiver works\n#             print(f'Info Extract: pass from {passer.displayName.item()} to {receiver.displayName.item()} was {play.passResult.item()}')\n#             print('Official Desc:',play.playDescription.item())\n#             # ===================================================\n        \n            # time of throw and catch as integers\n            throw_frame_int = passer.frameId.values[0]\n            catch_frame_int = receiver.frameId.values[0]\n            ball_snap_int = play_slice[play_slice.event=='ball_snap'].iloc[0].frameId.item()\n            \n            football_at_throw = play_slice[(play_slice.frameId == throw_frame_int) & (play_slice.team == 'football')]\n            receiver_at_throw = play_slice[(play_slice.frameId == throw_frame_int) & (play_slice.nflId == receiver.nflId.item())]\n            defense_at_throw = play_slice[(play_slice.frameId == throw_frame_int) & (play_slice.team == defense_team)]\n            \n            # skip problematic plays\n            if(len(receiver_at_throw)!=1):\n                continue\n            if(len(defense_at_throw)==0):\n                continue\n                \n            defense_sorted = sort_by_distance_to(defense_at_throw,receiver_at_throw)\n            \n            \n            \n            \n#             # ===================================================\n#             # proof sort of defense distances worked\n#             x,y = receiver_at_throw[['x','y']].values[0]\n#             for coord in defense_sorted[['x','y']].values:\n#                 print(dist((x,y),coord))\n#             # ===================================================\n            \n    \n            play_completion = plays_df[(plays_df['gameId'] == gameId) & (plays_df['playId'] == playId)]['passResult']\n            play_r = play_slice[play_slice.nflId == receiver.nflId.item()][['x','y','s','a','dis','o','dir']]\n            play_d = play_slice[play_slice.nflId == defense_sorted.iloc[0].nflId.item()][['x','y','s','a','dis','o','dir','time','frameId','gameId','playId']]\n            columns = np.hstack(([f'r_{c}' for c in play_r.columns],[f'd_{c}' for c in play_d.columns[:7]],play_d.columns[7:]))\n            \n            # somehow one is not labeled in the last frame\n            if(len(play_r)!=len(play_d)):\n                length = min(len(play_r),len(play_d))\n                play_r = play_r.iloc[:length]\n                play_d = play_d.iloc[:length]\n#                 print(play_slice[(play_slice.nflId == receiver.nflId.item()) | (play_slice.nflId == defense_sorted.iloc[0].nflId.item())][['nflId','frameId']])\n                \n                \n                \n            play_limited = np.hstack((play_r.values,play_d.values))\n            play_limited = pd.DataFrame(play_limited,columns = columns)\n            \n            # calculate the angle in between the direction the defender is traveling and the direction the receiver is traveling \n            dirs = (play_limited[['d_dir']] * np.pi\/180) + np.pi\/2\n            w = (play_limited[['r_y']].values - play_limited[['d_y']]).values.tolist()\n            s = (play_limited[['r_x']].values - play_limited[['d_x']]).values.tolist()\n            optimal_angle = np.arctan2(w,s)\n            angle_between = np.abs(optimal_angle - (dirs.values))\n            angle_between = pd.DataFrame(np.where(angle_between>np.pi, 2*np.pi - angle_between, angle_between),columns=['angle_between'])            \n            play_limited = pd.concat([play_limited,angle_between],axis=1)\n        \n            if(gameId not in dictionary):\n                dictionary[gameId] = {}\n            dictionary[gameId][playId] = {\n                'play_slice' : play_limited,\n                'play_completion' : play_completion.item(),\n                'throw_frame_int' : throw_frame_int,\n                'catch_frame_int' : catch_frame_int,\n                'ball_snap_int' : ball_snap_int,\n                \n            }\n            \n            \n            d_nflId = defense_sorted.iloc[0].nflId.item()\n            if(d_nflId not in player_dictionary):\n                player_dictionary[d_nflId] = []\n            player_dictionary[d_nflId].append({\n                'gameId' : gameId,\n                'playId' : playId,\n                \n                'receiver_nflId' : receiver.nflId.item(),\n                'receiver_name' : receiver.displayName.item(),\n                'receiver_data' : play_slice[play_slice.nflId == receiver.nflId.item()][['x','y','s','a','dis','o','dir']],\n                \n                'defender_name' : defense_sorted.iloc[0].displayName,\n                'defender_data' : play_slice[play_slice.nflId == d_nflId][['x','y','s','a','dis','o','dir']],\n                \n            \n            })           \n                    \n\n            \n#             break\n#         break\n            \n            \n    \n#     for i in range(len(data)):\n#         data[i] = data[i][:-1]+([np.nan]*(max_row_len-len(data[i])))+[data[i][-1]]\n#     data = np.array(data)\n    \n    \n    return np.array(sorted(skipped,reverse=True)), total, data, dictionary, player_dictionary\n    \n            \n# for i,week in enumerate(weeks):\n#     print(f'week {i+1}')\n#     skipped, total, data, plays_dict, player_dict = store_play_info(week)\nskipped, total, data, plays_dict, player_dict = store_play_info(weeks_df)\n\n# print(player_dict)","1aeca401":"# gather extracted data into datasets and split\/scale\n\n# each frame is 1\/10 of a second, so t-2 for reaction time of 0.2 seconds\n\nX = []\ny = []\n\nX_neg = []\ny_neg = []\n\nattributes = ['x','y','s','a','dir']\n\ntime = []\nfor gkey in plays_dict.keys():\n    for pkey in plays_dict[gkey].keys():        \n        catch_frame_int = plays_dict[gkey][pkey]['catch_frame_int']\n        ball_snap_int = plays_dict[gkey][pkey]['ball_snap_int']\n        completion = plays_dict[gkey][pkey]['play_completion']\n        total_time = catch_frame_int - ball_snap_int\n        play_slice = plays_dict[gkey][pkey]['play_slice']\n        \n        time.append(total_time)\n        play_slice = play_slice[(play_slice.frameId > ball_snap_int) & (play_slice.frameId < catch_frame_int)]\n        x_array = np.hstack((play_slice[[f'd_{a}' for a in attributes]].values[:-2],\n                                  play_slice[[f'r_{a}' for a in attributes]].values[2:]))\n        y_array = play_slice[[f'd_{a}' for a in attributes]].values[2:]\n\n        if(completion == 'I'):\n            # what the defense should do\n            X.append(x_array)\n            y.append(y_array)\n            \n        else:\n            # what the defense should not do\n            X_neg.append(x_array)\n            y_neg.append(y_array)\n            \n    \n    \n    \nX = np.vstack(X)\ny = np.vstack(y)\nX_neg = np.vstack(X_neg)\ny_neg = np.vstack(y_neg)\n","80cf18f9":"\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.multioutput import MultiOutputRegressor\n\ndef find_scaler(X_train):\n    max_data = np.max(X_train,axis=0)\n    return max_data + max_data * 0.1\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.3, random_state=4)\n\nX_train_neg, X_test_neg, y_train_neg, y_test_neg = train_test_split(\n    X_neg, y_neg, test_size=0.3, random_state=4)\n\n\n# scale the data between 0 and 1\nscaler = find_scaler(X_train)\ny_scaler = scaler[:len(scaler)\/\/2]\nX_train = X_train\/scaler\ny_train = y_train\/y_scaler\nX_test = X_test\/scaler\ny_test = y_test\/y_scaler\n\nscaler_neg = find_scaler(X_train_neg)\ny_scaler_neg = scaler_neg[:len(scaler_neg)\/\/2]\nX_train_neg = X_train_neg\/scaler_neg\ny_train_neg = y_train_neg\/y_scaler_neg\nX_test_neg = X_test_neg\/scaler_neg\ny_test_neg = y_test_neg\/y_scaler_neg\n\n\n\nmax_depth = 30\n\nprint('fitting pos')\nregr_rf = RandomForestRegressor(n_estimators=100, max_depth=max_depth, random_state=2)\nregr_rf.fit(X_train, y_train)\ny_rf = regr_rf.predict(X_test)\nprint(f\"RF Accuracy Score={regr_rf.score(X_test, y_test):.2f}\")\n\nprint('fitting neg')\nregr_rf_neg = RandomForestRegressor(n_estimators=100, max_depth=max_depth, random_state=2)\nregr_rf_neg.fit(X_train_neg, y_train_neg)\ny_rf_neg = regr_rf_neg.predict(X_test_neg)\nprint(f\"RF Accuracy Score={regr_rf_neg.score(X_test_neg, y_test_neg):.2f}\")\n\n\n","f924f79f":"print(f\"Testing the pass completed data to positive model={regr_rf.score(X_test_neg, y_test_neg):.2f}\")\nprint(f\"Testing the pass incomplete data to negative model={regr_rf_neg.score(X_test, y_test):.2f}\")\n\n\ny_pos_pred_neg = regr_rf.predict(X_test_neg)\ny_neg_pred_pos = regr_rf_neg.predict(X_test)\n\n# print('Defender:')\n# print(X_test[0,X_test.shape[1]\/\/2:])\n# print('Receiver:')\n# print(X_test[0,:X_test.shape[1]\/\/2])\n# print('Pos Prediction:')\n# print(y_rf[0])\n# print('Neg Prediction:')\n# print(y_neg_pred_pos[0])\n\nexample = 0\n\ndf = pd.DataFrame(np.vstack((X_test[example,X_test.shape[1]\/\/2:],X_test[example,:X_test.shape[1]\/\/2],y_rf[example],y_neg_pred_pos[example])),columns=attributes,index=['D','R','pos pred','neg pred'])\ndf.iloc[0] = df.iloc[0]*scaler[:len(scaler)\/\/2]\ndf.iloc[1] = df.iloc[1]*scaler[len(scaler)\/\/2:]\ndf.iloc[2] = df.iloc[2]*y_scaler\ndf.iloc[3] = df.iloc[3]*y_scaler_neg\ndf\n    \n","23e4ee5e":"def moving_avg(x,n=10):\n    return np.convolve(x,np.ones(n)\/n,mode='valid')\n\ndef moving_avg_2d(x, y, n=10):\n    mavg_x = np.convolve(x,np.ones(n)\/n,mode='valid')\n    mavg_y = np.convolve(y,np.ones(n)\/n,mode='valid')\n    return mavg_x, mavg_y\n\ndef plot_moving_avg(x,y,n=10,label='',c=None):\n    mavg_x = np.convolve(x,np.ones(n)\/n,mode='valid')\n    mavg_y = np.convolve(y,np.ones(n)\/n,mode='valid')\n    plt.plot(mavg_x,mavg_y,label=label,c=c)\n\ndef score_defender(pos_model, neg_model, play, show=False):\n    d_data = play['defender_data'][attributes]\n    r_data = play['receiver_data'][attributes]\n    d_data_compare = d_data[:-2]\n    p = np.hstack((d_data_compare,r_data[2:]))\n    pos_pred = pos_model.predict(p\/scaler)*y_scaler\n    neg_pred = neg_model.predict(p\/scaler_neg)*y_scaler_neg\n    \n    pos_mavg_x, pos_mavg_y = moving_avg_2d(pos_pred[:,0],pos_pred[:,1])\n    neg_mavg_x, neg_mavg_y = moving_avg_2d(neg_pred[:,0],neg_pred[:,1])\n        \n    d_data_compare_x = d_data_compare.x[-len(pos_mavg_x):]\n    d_data_compare_y = d_data_compare.y[-len(pos_mavg_y):]\n\n    \n    pos_score = np.mean((((d_data_compare_x-pos_mavg_x)**2)+((d_data_compare_y-pos_mavg_y)**2)).values**.5)\n    neg_score = np.mean((((d_data_compare_x-neg_mavg_x)**2)+((d_data_compare_y-neg_mavg_y)**2)).values**.5)\n    S = pos_score\/neg_score-1\n    print('pos score:',pos_score)\n    print('neg score:',neg_score)\n    print('overall:',S)\n    \n    if(show):\n        \n        plot_moving_avg(pos_pred[:,0],pos_pred[:,1],label='pos bound',c='g')\n        plot_moving_avg(neg_pred[:,0],neg_pred[:,1],label='neg bound',c='r')\n\n\n        plt.plot(d_data.x,d_data.y,label='defender',c='b')\n        plt.plot(r_data.x,r_data.y,label='receiver',c='purple')\n\n        plt.scatter(r_data.x.iloc[0],r_data.y.iloc[0],c='g')\n        plt.scatter(d_data.x.iloc[0],d_data.y.iloc[0],c='g')\n\n        plt.legend()\n        plt.title(f'Defender Score {S:.3f}')\n        plt.show()\n    \nplayer_keys = list(player_dict.keys())\n\nplay = player_dict[player_keys[4]][0] \nscore_defender(regr_rf, regr_rf_neg, play,show=True)\n\nplay = player_dict[player_keys[10]][0] \nscore_defender(regr_rf, regr_rf_neg, play,show=True)\n\nplay = player_dict[player_keys[1]][1] \nscore_defender(regr_rf, regr_rf_neg, play,show=True)\n    \n    \n    ","e926106e":"## Future Work","04c8c0f7":"# A Defender Rating System Based On Learned Positive And Negative Route Support Vectors","270e7a3d":"## Rating Defense On Learned General Optimal Route","5505c0ba":"###### Using a random forest regressor, we can learn the behavior exhibited in plays and build a model predicting the movements of a defender. For every timeframe in the play, we use the defenders current attributes along side the attributes of a receiver 0.2 seconds earlier in the play. This is to account for a typical human reaction time. At each timeframe, the next movement is then predicted from both models. ","74a0d2c0":"###### In the example data shown above, we see a single timeframe of a defender, and the timeframe 0.2 seconds earlier of a receiver to account for reaction time. The positive model shows the predicted next position of the defender to be closer to the receiver, with speed, acceleration, and direction also making minor adjustments to be more similar to the receiver. This is what one would expect, but this serves as a confirmation of hypothesis. The negative model shows similar characteristics in some cases, but it appears somewhat more unintuitive. ","abe3e4f7":"##### Below is the fully defined scoring model, and a few visuals to support it. The final score of a defender is defined as the similarity of the defenders route to the two predicted by each of the positive and negative models. S = P\/N-1, where P and R are the average distances between the each of the respective models and the defenders path. Overall values above 0 represent plays that more closely resemble a positive general performance, and those below 0 represent plays that resemble poor defensive performance. ","ca79289d":"###### If this route was imagined to be the route of a defender, they would be following or attempting to predict the route of a receiver. This receiver must be on one side of the defender path, therefore we label the support vectors as positive and negative. We assume that being closer to the receiver during the route forces a more optimal outcome for the defender (an incomplete pass). Replacing the two dimensional data with data more closely aligned with the problem at hand, we end up with the figure below. While the data points are not relevent, we decide our path based on a general learned model of route decisions throughout the play.","f157a9ed":"###### The problem I am attempting to solve in this notebook is how to give a general rating to a defensive player based on their performance in a given play. My specific approach takes inspiration from applications of a support vector machine (svm) splitting a dataset of two dimensions. If we consider a space with numerous object which we wish to maneuver around, a solution through these objects resembles the classification of two sets of data, one on each side of the chosen path. ","c59d1dd2":"###### Above we see the accuracy scores for both models. In the first block we see a positive model accuracy of 93%, and a negative model accuracy of 91%. This is, of course a regressive solution and therefore accuracy here is just an R^2 metric. In the second block we see a difference when passing complete pass data to the positive model, as well as relatively similar drop when passing incomplete pass data to the negative model. This implies a fundamental difference in defender movement behavior dictating whether a pass results in being complete or incomplete, and that this difference can be learned.","d36fe790":"## Extracting Data","ba568648":"###### Now if we take another step in the direction of a traditional svm, we can assign a class to each of the two sets of objects split by our path. We extend the path to produce two support vectors modeling the the furthest extremes in which the path can shift in either direction while still correctly splitting the data according to the path**, it would look something like this. ","f5ab151d":"![svm1.png](attachment:svm1.png)","2eb83d18":"![svm3.png](attachment:svm3.png)","ad817076":" ##### What is good defensive performance? Can there exist a general probabilistic bound for good coverage and bad coverage? To be a great defensemen you have to have quick reactions and good predictive insight on where the offensive play may lead. There must be a general model that explores whether an individual defensive performance was leaning toward historically ideal behavior or toward actions that typically influenced the play in a negative way for the defender (a completed catch). \n\n##### This models judges the performance of a defender from an extremely generalistic approach. If we feed the model enough data of completed and incompleted plays, it must eventually overlook the flukes and star performances and learn to view an average play by what influence the defender has over its outcome. \n\n##### There is an abstract concept of an average defensive player. He does not exist in real life but he can be modeled and used as a benchmark in which to compare all other defensive players. How would the average of all defenseive players react to a play? Once this problem is solved, it sets a benchmark that can either be over or under performed. \n","6ee3f5ad":"![svm2.png](attachment:svm2.png)","ee6c2b71":"###### Therefore a defender can be evaluated based on their tendencies to stray closer to the positive or negative path prediction. ","822e45ce":"##### This notebook can benefit from numerous improvements. The most important would be a custom random forest classifier with a loss that enforces the laws of physics. At the current iteration, this model relies on the learning ability of the classifier to willingly obey the physics it observes within the data. Reinforcing rules that state the boundaries of what is possible for a defender given his position, speed, acceleration, ect. would improve the potential of this approach. While the high level concept of this project is present, and a display of its efficacy is in place, it can be greatly improved given more time. Additional considerations are listed below:\n* Reinforcement of the boundaries of possible physical motion wihtin loss function \n* Augmenting play data into a single quadrant (such that all plays proceed in a single direction)\n* Additional engineered features added to training data for better model understanding of the situation at each time frame"}}