{"cell_type":{"895743e1":"code","47014b92":"code","266e187f":"code","c2368d41":"code","6e2a8042":"code","529dbe9c":"code","540d3b80":"code","8b675acb":"code","6b0f077e":"code","bfd8675a":"code","78c8cf60":"code","f7a5d004":"code","31cd2aea":"code","24c6c101":"code","0f3749d8":"code","00a1e2f1":"code","41eaa3d3":"code","ee58eec6":"code","b7fc6048":"code","4b7d51af":"code","71f26d64":"code","c6f94c30":"code","174e9ccf":"code","87d58a83":"code","844fefbb":"code","86c10fea":"code","91cdedbe":"code","2bc19188":"code","79ecc894":"code","61ba093e":"code","5fc89d60":"code","1b518a6f":"code","fb11e903":"code","72ac8ff7":"code","2d339c44":"code","35a73738":"code","57aba671":"code","3e95e52b":"code","c974db81":"code","5857e283":"code","574c2702":"code","643159ae":"code","4250b7ab":"code","69081436":"code","9216f26a":"code","b741a14a":"code","7a49fef9":"code","0ffa1900":"code","ff6b617d":"code","ed862f6d":"code","e782518d":"code","523582d7":"code","0599b499":"code","0ce19e69":"code","796d756c":"code","cdf60c67":"code","805aff57":"code","f09d5c42":"code","8bc786f9":"code","94b5767e":"code","765a8019":"code","335ab4c2":"code","81b1a4cc":"code","4b95db44":"code","33fc2a90":"code","02131339":"code","3c4ad200":"code","f9f98aa3":"code","3fe624c2":"code","f5962672":"code","77da9ef5":"code","d2b16be3":"code","6aeec099":"code","5454b679":"code","a1ee5401":"code","453cfd4f":"code","4ae98c43":"code","9e3d49f9":"code","611ae7bd":"code","098ba3af":"code","a070e07a":"code","cbbb2285":"code","52c7c6f8":"code","bdfe8da1":"code","02ce823e":"code","84a6da78":"code","cfb5659f":"code","143cc8ca":"code","37a808ef":"code","6a8f5958":"code","8e244d80":"code","8e1064d0":"code","2bc244b1":"code","64f378dd":"code","cd6cb4a5":"code","6c2fca8e":"code","6cfe3817":"code","16426cb9":"code","68552d7b":"markdown","3e53ea3f":"markdown","82982af1":"markdown","6ba971d3":"markdown","6b53d442":"markdown","bf0a968e":"markdown","c1bfb32a":"markdown","025d4bfa":"markdown","1f9085ec":"markdown","b30d0796":"markdown","2a828b14":"markdown","d912d175":"markdown","b9cb8740":"markdown","5b4d9a00":"markdown","5530fb93":"markdown","d6849ac9":"markdown","83e261e4":"markdown","7a31ea54":"markdown","f7f1c7c6":"markdown","7437af4c":"markdown","6b53dd78":"markdown","40422ad6":"markdown","a57dea05":"markdown","745def8e":"markdown"},"source":{"895743e1":"import pandas as pd \nimport numpy as np \nimport matplotlib.pyplot as plt \nimport seaborn as sns\n\nimport os\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n# time calculation to track some processes\nimport time\n\nimport pickle\n\n# import the function to compute cosine_similarity\nfrom sklearn.metrics.pairwise import cosine_similarity\nfrom sklearn.cluster import KMeans\n\nimport scipy as sp","47014b92":"PATH_DATA = \"..\/input\/easymoneygrupo5\/\"","266e187f":"products = pd.read_csv(PATH_DATA+'products_df.csv', encoding='utf-8')\nproducts.drop(columns=['Unnamed: 0'], inplace=True)","c2368d41":"products.head()","6e2a8042":"products.columns","529dbe9c":"# dataset con los clientes actuales y productos que tienen \nclientes_=products[products['pk_partition']=='2019-05-28']","540d3b80":"# Borramos 'em_account_pp' porque siempre es cero y, por tanto, no aporta informaci\u00f3n. \n# Se excluye tambi\u00e9n payroll porque es un servicio y queremos evaluar los productos vendidos.\n\nclientes_=clientes_[['pk_cid', 'short_term_deposit', 'loans', 'mortgage',\n       'funds', 'securities', 'long_term_deposit',\n       'credit_card', 'pension_plan', 'payroll_account',\n       'emc_account', 'debit_card', 'em_account_p', 'em_acount']]","8b675acb":"# el dataframe clientes_ incluye todos los clientes del \u00faltimo mes.\nclientes_","6b0f077e":"# calculamos una columna total para saber el n\u00famero de productos que tiene cada cliente con easyMoney\nclientes_['total'] = clientes_.iloc[:,1:].sum(axis=1)","bfd8675a":"clientes_","78c8cf60":"# dividimos el dataset entre los clientes que tienen actualmente productos contratados y los que no\nclientes_productos=clientes_[clientes_[\"total\"]>0]\nclientes_productos","f7a5d004":"# los clientes que no tienen actualmente un producto contratado con nosotros\nclientes_sin_productos=clientes_[clientes_[\"total\"]==0]","31cd2aea":"clientes_sin_productos","24c6c101":"clientes_sin_productos.drop([\"total\"], axis=1, inplace=True)\nclientes_productos.drop([\"total\"], axis=1, inplace=True)","0f3749d8":"# Recomendaremos los productos m\u00e1s populares, por lo tanto, hacemos un ranking de los productos m\u00e1s vendidos\n# organizamos la base de datos con la que trabajaremos","00a1e2f1":"clientes_productos=clientes_productos.melt(id_vars=[\"pk_cid\"], value_name='valor', var_name='producto')","41eaa3d3":"# reorganizaci\u00f3n del dataset\nclientes_productos","ee58eec6":"# borramos los productos que no han contratado el cliente\nclientes_conproductos=clientes_productos[clientes_productos['valor']==1]","b7fc6048":"clientes_conproductos.drop(['valor'], axis=1, inplace=True)","4b7d51af":"clientes_conproductos","71f26d64":"# construimos un diccionario con los clientes y los productos que han comprado\nlista_clientes_comprados=clientes_conproductos.groupby('pk_cid')['producto'].agg(list).to_dict()","c6f94c30":"# Recomendaremos los productos m\u00e1s populares, por lo tanto, hacemos un ranking de los productos m\u00e1s vendidos\n# el orden coincide con el ranking considerando todo el historico\n\nmas_populares=clientes_conproductos.groupby(['producto']).count()\nmas_populares.columns=['ranking']\nmas_populares=mas_populares.sort_values(by=['ranking'], ascending=False)","174e9ccf":"mas_populares","87d58a83":"mas_populares=mas_populares.reset_index()\nmas_populares['ranking1'] = mas_populares.index\nmas_populares.drop(['ranking'], axis=1, inplace=True)\nmas_populares['ranking']=mas_populares['ranking1']+1\nmas_populares.drop(['ranking1'], axis=1, inplace=True)\nmas_populares","844fefbb":"# diccionario con los top-ventas\ntop_ventas=pd.Series(mas_populares.ranking.values,index=mas_populares.producto).to_dict()","86c10fea":"top_ventas","91cdedbe":"# la siguiente funci\u00f3n asigna a cada cliente el producto m\u00e1s popular que no tenga contratado.\n\ndef clientes_recomendacion(lista_clientes, mi_top ):\n    \n    lcliente=[]\n    lreco=[]\n\n    for k, v in list(lista_clientes.items()):\n        for k1, v1 in mi_top.items():\n            if (k1 not in v and  k not in lcliente):\n                lcliente.append(k)\n                lreco.append(k1)\n    lista_f=(lcliente, lreco)\n    key_list = lista_f[0]\n    value_list1 = lista_f[1]\n    dict_from_list = {key_list[i]: value_list1[i] for i in range(len(key_list))}\n    return dict_from_list","2bc19188":"run = False\nif run == True:\n    recomendaciones = clientes_recomendacion(lista_clientes_comprados, top_ventas )","79ecc894":"#guardar diccionario\n#fichero = open(\"recomendaciones_data.pkl\", \"wb\")\n#pickle.dump(df_recomendacion, fichero)\n#fichero.close()","61ba093e":"# abrir el pickle\nfichero = open(PATH_DATA+\"recomendaciones_data.pkl\", \"rb\")\noutput = pickle.load(fichero)","5fc89d60":"# pasamos el diccionario de clientes y recomendaci\u00f3n a un df\ndf_recomendacion = pd.DataFrame([[key, output[key]] for key in output.keys()], columns=['pk_cid', 'recomendacion'])","1b518a6f":"df_recomendacion","fb11e903":"# asignamos el top venta a los clientes que no tienen ning\u00fan producto contratado actualmente\nclientes_sin_productos=clientes_sin_productos[['pk_cid']]","72ac8ff7":"clientes_sin_productos['recomendacion']='em_acount'","2d339c44":"clientes_sin_productos","35a73738":"# unimos ambos dataframes. df_recomendacion contiene para cada cliente una recomendaci\u00f3n de un producto\ndf_recomendacion=df_recomendacion.append(clientes_sin_productos)","57aba671":"client_segmentation = pd.read_csv('..\/input\/easymoneygrupo5\/client_segmentation.csv')\ntry: \n    client_segmentation.drop('Unnamed: 0',axis=1, inplace=True)\nexcept: \n    pass\n\nif client_segmentation['cluster'].min() == 0:\n    client_segmentation['cluster'] += 1\n\nclient_segmentation.head()","3e95e52b":"client_segmentation[\"cluster\"].value_counts().sort_index(ascending=True)","c974db81":"selected = [3,6]\ndf_reco_selected = client_segmentation[client_segmentation['cluster'].isin(selected)]\ndf_reco_selected = pd.merge(df_reco_selected, df_recomendacion.reset_index(), how='right', on='pk_cid')\ndf_reco_selected.set_index('pk_cid',inplace=True)\n\ndf_reco_selected = df_reco_selected.dropna(how='any')\n\nprint(df_reco_selected.head())\ndf_reco_selected.shape[0]","5857e283":"df_reco_selected[\"cluster\"].value_counts().sort_index(ascending=True)","574c2702":"df_reco_selected.drop(['index'],axis=1,inplace=True)\n","643159ae":"df_reco_selected","4250b7ab":"#guardar el dataset de df_reco_selected que contiene para los clusters 3 y 6 las recomendaciones de productos \n#fichero = open(\"reco_selected_data.pkl\", \"wb\")\n#pickle.dump(df_reco_selected, fichero)\n#fichero.close()","69081436":"products_dict = {\"short_term_deposit\":\"ahorro e inversi\u00f3n\", \"loans\":\"financiaci\u00f3n\", \"mortgage\":\"financiaci\u00f3n\", \n    \"funds\":\"ahorro e inversi\u00f3n\", \"securities\":\"ahorro e inversi\u00f3n\", \"long_term_deposit\":\"ahorro e inversi\u00f3n\", \n    \"em_account_pp\":\"cuenta\", \"credit_card\":\"financiaci\u00f3n\", \"payroll_account\":\"cuenta\", \"pension_plan\":\"ahorro e inversi\u00f3n\", \n    \"emc_account\":\"cuenta\", \"debit_card\":\"financiaci\u00f3n\", \"em_account_p\":\"cuenta\", \"em_acount\":\"cuenta\"}\n\ncost_product = {'cuenta':10, 'ahorro e inversi\u00f3n':40, 'financiaci\u00f3n':60}","9216f26a":"df_reco_selected['tipo_producto'] = df_reco_selected['recomendacion'].replace(products_dict)\ndf_reco_selected['precio'] = df_reco_selected['tipo_producto'].replace(cost_product)\ndf_reco_selected.head()","b741a14a":"prediccion_clientes = pd.read_csv('..\/input\/easymoneygrupo5\/clients_prediction.csv')\ntry:\n    prediccion_clientes.drop('Unnamed: 0',axis=1,inplace=True)\nexcept:\n    pass","7a49fef9":"prediccion_clientes.drop('precio',axis=1,inplace=True)","0ffa1900":"recomendaciones_predict = pd.merge(df_reco_selected.reset_index(),  prediccion_clientes, how='left', on=['pk_cid'])\nrecomendaciones_predict.dropna(how='any',inplace=True)","ff6b617d":"filename = '..\/input\/easymoneygrupo5\/modelo_compra_general.sav'\nmodel = pickle.load(open(filename, 'rb'))\nmodel","ed862f6d":"features = model.feature_name_","e782518d":"X_predict = recomendaciones_predict.copy(deep=True)\n\ncols = ['total_ahorros', 'compra_cuenta', 'total', 'total_cuenta', 'compra_ahorros', 'compra_financiacion', 'compra', 'total_financiacion']\n#cols.append('pk_cid')\nfor x in cols:\n    try:\n        features.remove(x)\n    except:\n        pass\n    \n#features.remove('pk_cid')\n\nX_predict = X_predict[features]","523582d7":"predictions = model.predict_proba(X_predict)[:,1]\nrecomendaciones_predict['prob'] = predictions","0599b499":"social = pd.read_csv(PATH_DATA+'sociodemographic_df.csv')\nsocial = social.groupby('pk_cid').last()\nsocial.reset_index(inplace=True)","0ce19e69":"recomendaciones_predict = pd.merge(recomendaciones_predict, social[['pk_cid','deceased']], how='left', on='pk_cid' )\nrecomendaciones_predict['deceased'].value_counts()","796d756c":"recomendaciones_predict = recomendaciones_predict[recomendaciones_predict['deceased'] == 'N']","cdf60c67":"view_cols = ['pk_cid','recomendacion','precio','prob']\n\nrecomendaciones_predict = recomendaciones_predict.sort_values('prob',ascending=False)\nrecomendaciones_predict.head(10)","805aff57":"reco_financiacion = recomendaciones_predict[ recomendaciones_predict['tipo_producto'] == 'financiaci\u00f3n']\nreco_financiacion[view_cols].sort_values('prob',ascending=False).head(10)","f09d5c42":"reco_ahorros = recomendaciones_predict[ recomendaciones_predict['tipo_producto'] == 'ahorro e inversi\u00f3n']\nreco_ahorros[view_cols].sort_values('prob',ascending=False).head(10)","8bc786f9":"reco_cuenta = recomendaciones_predict[ recomendaciones_predict['tipo_producto'] == 'cuenta']\nreco_cuenta[view_cols].sort_values('prob',ascending=False).head(10)","94b5767e":"thres_financiacion = 0.25\nthres_ahorros = 0.3\nthres_cuenta = 0.3\n\nN = reco_financiacion[reco_financiacion['prob']>thres_financiacion].shape[0]\nM = reco_ahorros[reco_ahorros['prob']>thres_ahorros].shape[0]\nL = reco_cuenta[reco_cuenta['prob']>thres_cuenta].shape[0]\n\nprint('Recomendaciones para financiaci\u00f3n:', N)\nprint('Recomendaciones para ahorros:', M)\nprint('Recomendaciones para cuentas:', L)\nprint('Recomendaciones totales:', N+M+L)","765a8019":"financiacion_selected = reco_financiacion[reco_financiacion['prob']>thres_financiacion].sort_values('prob',ascending=False)\nfinanciacion_selected = financiacion_selected.groupby('pk_cid').first()\nfinanciacion_selected.reset_index(inplace=True)\n\nprint(financiacion_selected.shape[0])\ndisplay(financiacion_selected[view_cols].sort_values('prob',ascending=False).head(10))","335ab4c2":"ahorros_selected = reco_ahorros[(reco_ahorros['prob']>thres_ahorros) & (~reco_ahorros['pk_cid'].isin(financiacion_selected['pk_cid']))].sort_values('prob',ascending=False)\n#ahorros_selected.reset_index(inplace=True)\nahorros_selected = ahorros_selected.groupby('pk_cid').first()\nahorros_selected.reset_index(inplace=True)\n\nprint(ahorros_selected.shape[0])\ndisplay(ahorros_selected[view_cols].sort_values('prob',ascending=False).head(10))","81b1a4cc":"cuenta_selected = reco_cuenta[(reco_cuenta['prob']>thres_ahorros) & (~reco_cuenta['pk_cid'].isin(financiacion_selected['pk_cid'])) & (~reco_cuenta['pk_cid'].isin(ahorros_selected['pk_cid']))].sort_values('prob',ascending=False)\n#cuenta_selected.reset_index(inplace=True)\ncuenta_selected = cuenta_selected.groupby('pk_cid').first()\ncuenta_selected.reset_index(inplace=True)\n\nprint(cuenta_selected.shape[0])\ndisplay(cuenta_selected[view_cols].sort_values('prob',ascending=False).head(10))","4b95db44":"final_reco = financiacion_selected.head(5000)\nprint('Tras a\u00f1adir financiacion (60\u20ac): ',final_reco.shape[0])\nfinal_reco = pd.concat( (final_reco, ahorros_selected.head(500)), ignore_index=True)\nprint('Tras a\u00f1adir ahorros (40\u20ac): ',final_reco.shape[0])\nfinal_reco = pd.concat( (final_reco, cuenta_selected.head( 10000 - final_reco.shape[0] )), ignore_index=True)\nprint('Tras a\u00f1adir cuentas (10\u20ac): ',final_reco.shape[0])\nfinal_reco[view_cols].sort_values('prob',ascending=False).head()","33fc2a90":"final_reco['tipo_producto'].value_counts(normalize=True)","02131339":"run = True\nif run == True:\n    final_reco[view_cols].to_csv('recomendaciones_finales.csv')","3c4ad200":"conversiones_worst = {3:0.33, 6:0.45}\nconversiones_expected = {3:0.63, 6:0.74}\nconversiones_best = {3:0.91, 6:1}\n\nfor cluster in conversiones_worst:\n    final_reco['profit_worst'] = final_reco['cluster'].replace(conversiones_worst)*final_reco['precio']*final_reco['prob']\n\nfor cluster in conversiones_expected:\n    final_reco['profit_expected'] = final_reco['cluster'].replace(conversiones_expected)*final_reco['precio']*final_reco['prob']\n    \nfor cluster in conversiones_best:\n    final_reco['profit_best'] = final_reco['cluster'].replace(conversiones_best)*final_reco['precio']*final_reco['prob']","f9f98aa3":"coste_emails = 300\nprint('Beneficio neto (worst case) [\u20ac]:',round(final_reco['profit_worst'].sum()\/100)*100 - coste_emails)\nprint('Beneficio neto (expected case) [\u20ac]:',round(final_reco['profit_expected'].sum()\/100)*100 - coste_emails)\nprint('Beneficio neto (best case) [\u20ac]:',round(final_reco['profit_best'].sum()\/100)*100 - coste_emails)","3fe624c2":"lista_columnas2= (['pk_cid', 'short_term_deposit', 'loans', 'mortgage',\n       'funds', 'securities', 'long_term_deposit',\n       'credit_card', 'pension_plan', 'payroll_account',\n       'emc_account', 'debit_card', 'em_account_p', 'em_acount'])\nlista_columnas2","f5962672":"df_reco=products[lista_columnas2]\ndf_reco","77da9ef5":"# Construimos el dataset de recomendaci\u00f3n donde tendremos para cada cliente el tiempo (o las veces) que ha tenido cada producto en los 17 meses que tenemos informaci\u00f3n. \ndf_reco_final=df_reco.pivot_table(index='pk_cid', aggfunc=[sum])\ndf_reco_final.head()","d2b16be3":"df_reco_final.columns = df_reco_final.columns.droplevel()","6aeec099":"# comprobamos que no hay nulos\ndf_reco_final.isnull().sum()","5454b679":"# Tenemos 456.373 clientes y 13 productos.\ndf_reco_final.shape","a1ee5401":"df_reco_final.describe()","453cfd4f":"df_reco_final.head()","4ae98c43":"# Para cada cliente sumamos la cantidad de producto que tiene contratados,\n# borraremos aquellos clientes que no tienen ning\u00fan producto contratado pues no aportan informaci\u00f3n para hacer recomendaciones\ndf_reco_final['suma']=df_reco_final.sum(axis=1)","9e3d49f9":"df_reco_final.drop(df_reco_final[df_reco_final[\"suma\"]==0].index,axis=0,inplace=True)\ndf_reco_final.drop('suma', axis=1, inplace=True)","611ae7bd":"df_reco_final.describe()","098ba3af":"df_reco_final.head()","a070e07a":"st = time.time()\ndf_reco_norm = df_reco_final.apply(lambda x: (x - np.min(x))\/(np.max(x) - np.min(x)), axis = 1)\net = time.time()\nprint(\"Normalization took {} minutes\".format(round((et - st)\/60, 2)))","cbbb2285":"# Verificamos si se generaron ceros.\ndf_reco_norm.isnull().sum()","52c7c6f8":"# Se comprueba que los valores de los productos est\u00e1n normalizados entre 0 y 1.\ndf_reco_norm.describe()","bdfe8da1":"# Escogemos una muestra aleatoria de 20000 observaciones porque con una cantidad superior se reinicia el kernel y nos da problema.\ndf_reco_norm2 = df_reco_norm.sample(20000)","02ce823e":"# construimos una matriz sparse de datos para cada usuarios y los productos.\nsparse_ratings = sp.sparse.csr_matrix(df_reco_norm2.values)","84a6da78":"sparse_ratings","cfb5659f":"item_similarity = cosine_similarity(sparse_ratings.T)","143cc8ca":"item_similarity_df = pd.DataFrame(item_similarity, index = df_reco_norm2.columns, columns = df_reco_norm2.columns)","37a808ef":"# Obtenemos la matriz de similitud del coseno item based\nitem_similarity_df.head()","6a8f5958":"def lista_recomendaciones(columna, df):\n    top5=df[columna].sort_values(ascending=False)[1:6]\n    recomendaciones_columna=top5.index\n    recomendaciones_columna=recomendaciones_columna.tolist()\n    return recomendaciones_columna ","8e244d80":"# Para mirar los top 5 productos que se podr\u00edan recomendar a los clientes que tienen short_term_deposit:\nrecomendaciones_short_term_deposit=lista_recomendaciones('short_term_deposit', item_similarity_df)\nrecomendaciones_short_term_deposit","8e1064d0":"user_similarity = cosine_similarity(sparse_ratings)\n\nuser_similarity_df = pd.DataFrame(user_similarity, index = df_reco_norm2.index, columns = df_reco_norm2.index)","2bc244b1":"user_similarity_df.head()","64f378dd":"# La siguiente funci\u00f3n muestra, para un cliente dado, 10 clientes similares a \u00e9l basado en la similitud del coseno\n\ndef top_users(user, df):\n    \n    if user not in df.columns:\n        return('No data available on user {}'.format(user))\n    \n    print('Most Similar Clients:\\n')\n    \n    sim_users = df.sort_values(by = user, ascending=False).index[1:11]\n    sim_values = df.sort_values(by = user, ascending=False).loc[:,user].tolist()[1:11]\n    \n    for user, sim in zip(sim_users, sim_values):\n        print('User #{0}, Similarity value: {1:.2f}'.format(user, sim))","cd6cb4a5":"# La siguiente funci\u00f3n muestra un dataframe con los top 5 productos de dos clientes:\n\ndef compare_2_users(user1, user2, df, nr_productos):\n\n    top_10_user_1 = df[df.index == user1].melt().sort_values(\"value\", ascending = False)[:nr_productos]\n    top_10_user_1.columns = [\"name_user_{}\".format(user1), \"rating_user_{}\".format(user1)]\n    top_10_user_1 = top_10_user_1.reset_index(drop = True)\n\n    top_10_user_2 = df[df.index == user2].melt().sort_values(\"value\", ascending = False)[:nr_productos]\n    top_10_user_2.columns = [\"name_user_{}\".format(user2), \"rating_user_{}\".format(user2)]\n    top_10_user_2 = top_10_user_2.reset_index(drop = True)\n\n    combined_2_users = pd.concat([top_10_user_1, top_10_user_2], axis = 1, join = \"inner\")\n    \n    return combined_2_users","6c2fca8e":"user1 = 1072201\nuser2 = 1446542","6cfe3817":"combined_2_users = compare_2_users(user1, user2, df_reco_final, 5)\ncombined_2_users","16426cb9":"top_users(1216199, user_similarity_df)","68552d7b":"Aunque no utilizamos las siguientes t\u00e9cnicas porque no se aplican a nuestro problema por el tipo de datos que tenemos, mostramos a continuaci\u00f3n c\u00f3mo podr\u00edamos hacer una recomendaci\u00f3n basada en la similitud entre productos o clientes a trav\u00e9sdel c\u00e1lculo de la similitud del coseno item based y user based.","3e53ea3f":"Guardamos la lista de recomendaciones por cliente en un pickle para no tener que volver a correr el c\u00f3digo y, as\u00ed, ahorrarnos tiempo","82982af1":"El siguiente paso es definir los thresholds de probabilidad m\u00ednima que estamos dispuestos a aceptar. Es importante destacar que se ha impuesto el requerimiento de que tan s\u00f3lo se puede realizar la recomendaci\u00f3n de un produdcto a un cliente, por lo que un mismo cliente puede aparecer en los 3 tipos pero nos quedamos con tan solo una recomendaci\u00f3n.\n\nLos threshold que se tienen que entrar son m\u00e1s bajos de lo esperado, esto se debe a que al modelo el cuesta predecir compra o no compra y ante la duda decide ser conservador. Otro hecho es que la lista de recomendaciones tampoco es muy larga al reducir las recomendaciones tan s\u00f3lo a los clusters 3 y 6; y estamos recomendando productos nuevos; una posible mejora ser\u00eda recomendar productos a clientes que no lo tienen contratado pero lo han contratado anteriormente (existen varios clusters que tienen este comportamiento).\n\nA\u00f1adir otro cluster hubiera hubiera sido un buen paso sin embargo las conversiones de los otros clusters eran muy lejanas a lo que se considera ideal. ","6ba971d3":"Exploraci\u00f3n del dataframe df_reco_final.\n\nObservamos que uno de los productos m\u00e1s populares es em_account y la debit_card","6b53d442":"## Beneficio neto esperado <a class=\"anchor\" id=\"XX\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEn el email la responsable de Marketing Erin, nos pide si es posible el calcular el ROI. El <a href=\"https:\/\/www.40defiebre.com\/que-es\/roi\">Return of Investment<\/a> se calcula como:\n\n$$ROI = \\frac{ Beneficio \\; neto - Inversion }{Inversion}$$\n\nLa inversi\u00f3n \u00fanicamente se incluye el precio del emails, sin embargo este coste no para nada realista. A este coste deber\u00edan a\u00f1adirsele los salarios de los trabajadores: copywriter, personal de marketing o el data scientist incluso (evaluados mensualmente); y los costes de sus ordenadores, etc. Para poder dar un valor de ROI realista.\n\nSeg\u00fan <a href=\"https:\/\/mailchimp.com\/pricing\/marketing\/\">Mail Chimp<\/a> el precio aproximado para m\u00e1s de 50.000 contactos es de aproximadamente de 300\u20ac. Para una valor de inversi\u00f3n tan bajo aparece un ROI del 200%, muy pocas acciones tienen tal ROI en la vida real.\n\nEs por ello que se refiere obtener el beneficio neto y en un futuro calcular la inversi\u00f3n que supone con m\u00e1s detalle. \n\nEl beneficio neto se calcula como:\n\n$$Beneficio \\; neto [\u20ac] = \\sum_j^{recomendaciones} probabilidad \\; compra_j \\cdot conversion_{cluster} \\cdot precio \\; producto_j $$\n\nLa f\u00f3rmula anterior es una correcta aproximaci\u00f3n del beneficio neto que se espera tras la campa\u00f1a de email marketing. ","bf0a968e":"De todas las recomendaciones algunas son para productos de financiaci\u00f3n, otras para productos de ahorros e inversi\u00f3n y otras para cuentas. Sin embargo, el beneficio de cada producto es diferente por lo que resulta interesante optar por los productos que mejor beneficio nos hacen obtener, pese a que el riesgo aumente (es decir que la probabilidad de compra disminuya). \n\nPara ello se separan las recomendaciones seg\u00fan el tipo de producto.","c1bfb32a":"Mostramos a continuaci\u00f3n c\u00f3mo podr\u00edamos calcular la similitud del coseno user based.","025d4bfa":"# Data Preparation <a class=\"anchor\" id=\"1\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nEn esta secci\u00f3n se preparan y limpian los datos para poder realizar las recomendaciones.","1f9085ec":"# Anexos","b30d0796":"## Similitud del coseno","2a828b14":"A continuaci\u00f3n se graba en una lista el orden de los features que deben ser entrados al modelo. Y se carga el modelo en un pickle, se ha optado por un Gradient Boosting Classifier en este caso por su versi\u00f3n de Light Gradient Boosting Machine.","d912d175":"Luego de borrar los clientes sin productos contratados durantes los 17 meses, nos quedan 350.384 clientes.","b9cb8740":"En este caso se ofrecen 3 posibles casos, para ello se calculan las conversiones 25 cuartil, media y 75 cuartil de cada cluster; pudiendo as\u00ed ofrecer el rango de valores en los que se espera que sea el beneficio neto con un worst case, expected case y best case. ","5b4d9a00":"Queremos recomendar productos a los clientes basado en los productos que tienen actualmente y considerando el tiempo que los ha tenido. La idea es hacer recomendaciones basada en la siguiente l\u00f3gica: Los clientes que han tenido el producto X por muchos meses, tambi\u00e9n tienden a tener el producto Y por muchos meses, por lo tanto, los clientes que tienen X y no tienen Y se les recomendar\u00e1 el producto Y.\n\nPara ello, nos basaremos en la similitud entre items calculada a trav\u00e9s de la similitud del coseno.\n\nLos primero que tenemos que hacer es normalizar el rango de las variables para evitar el efecto de escala, lo haremos usando MinMax Scale.","5530fb93":"# Selecci\u00f3n de las recomendaciones <a class=\"anchor\" id=\"XX\"><\/a>\n\n[Tabla de Contenidos](#0)\n\nTras obtener las recomendaciones, el siguiente paso es escoger que recomendaciones son las que mayor probabilidad de \u00e9xito tienen y que adem\u00e1s generan mayor beneficio para la compa\u00f1\u00eda. Para ello se construy\u00f3 un Modelo de Compra que permite obtener la probabilidad de compra de cada cliente y cada producto recomendado, el desarrollo y construcci\u00f3n de este modelo puede visualizarse en <a href=\"https:\/\/www.amazon.es\/Hands-Unsupervised-Learning-Using-Python\/dp\/1492035645\">Tarea 3: Modelo de Compra<\/a>. \n\nEn la misma subtarea se preparan los datos para la predicci\u00f3n donde se tienen los registros y atributos de cada cliente en el siguiente mes.","d6849ac9":"Con el dataset df_recomendacion tenemos recomendaciones para toda nuestra base de clientes, pero solo tenemos presupuesto para 10.000 emails. Por lo tanto, seleccionaremos estos 10.000 clientes con base en sus intereses y los productos m\u00e1s rentables para easyMoney. Como explicamos anteriormente, haremos recomendaciones a los clientes que pertenecen a los clusters 3 (Los Curiosos) y 6 (Los Comprometidos) y escogeremos los que con mayor probabilidad nos compraran un producto.\nOrganizamos a continuaci\u00f3n este dataset con los 10.000 clientes","83e261e4":"La siguiente funci\u00f3n extrae las top 5 recomendaciones de cada producto\n","7a31ea54":"#### Importaci\u00f3n de librer\u00edas y dataset","f7f1c7c6":"Para el desarrollo del motor de recomendaci\u00f3n utilizaremos el dataset de productos.","7437af4c":"El siguiente paso es asegurarse que no se realizan recomendaciones a clientes fallecidos.","6b53dd78":"Hacemos una primera exploraci\u00f3n del dataset. Tenemos para cada cliente y mes (o partici\u00f3n) los productos y servicios que tienen contratados.","40422ad6":"# Tarea 3: Recomendaci\u00f3n\n\n<a href=\"https:\/\/www.amazon.es\/Hands-Unsupervised-Learning-Using-Python\/dp\/1492035645\">Volver a P\u00e1gina Principal<\/a>\n\nLa tarea 3 consiste en hacer un motor de recomendaci\u00f3n para 10.000 clientes a quienes les enviaremos un email con el producto que m\u00e1s les interese y que nos da mayores ganancias. Para ello, ordenaremos nuestros productos para cada cliente en funci\u00f3n de sus preferencias. \n\nAdicionalmente, predeciremos la tasa de respuesta que obtendremos de los clientes y calcularemos el retorno de la inversi\u00f3n (ROI) o en su defecto el beneficio neto.\n\n## Tabla de Contenidos <a class=\"anchor\" id=\"0\"><\/a>\n\n1. [Data Preparation](#origin) <br> \n    1.1. [Salario (salary)](#11) <br> \n    1.2. [Fallecido (deceased)](#12) <br> \n    1.3. [Cliente activo (active_customer)](#13) <br> \n    1.10. [Productos](#110) <br> \n2. [Data Cleaning](#2) <br> \n    2.1. [Feature Selection](#21) <br> \n    \n3. [Selecci\u00f3n de las recomendaciones](#3) <br> \n    3.1. [Beneficio neto esperado](#31) <br> \n    \n4. [Preparaci\u00f3n del dashboard](#4) <br> \n5. [Conclusiones](#5) <br>","a57dea05":"## Recomendaci\u00f3n User Based","745def8e":"## Similitud del coseno para calcular similaridades entre productos comprados"}}