{"cell_type":{"b1bb3275":"code","725bcb81":"code","79782ebf":"code","85917fc4":"code","1fc7ce73":"code","f610b101":"code","54c3b618":"code","534e63d0":"code","e62a94d2":"code","be8856f0":"code","7ea2af1f":"code","8a1d9ff6":"code","4885d31e":"code","d9918c73":"code","c344eaa9":"code","b841ac0a":"code","854b1f49":"code","5b5f05b1":"code","eec072c0":"code","7497eeca":"code","5bf035d0":"code","c38c7587":"code","ac61c28b":"code","c2cc2aac":"code","6b70477c":"code","bc3ac303":"code","82a74a64":"code","2e921271":"code","2ef8df24":"code","47a9bf04":"code","a1f76275":"code","6fad8d2f":"code","4bac106d":"code","b6eebb4e":"code","72d20c9f":"code","c8c5969d":"code","8ec0c3c4":"code","c224c00b":"code","d935af75":"code","025def21":"markdown","4497baa1":"markdown","52fba38b":"markdown","2b6008b5":"markdown","02484517":"markdown","4a2de490":"markdown","fc206888":"markdown","68c4a830":"markdown"},"source":{"b1bb3275":"!pip install imutils\n!pip install image-classifiers==1.0.0b1","725bcb81":"# import the necessary packages\nimport tensorflow as tf\nimport gc\nfrom tensorflow.keras.optimizers import SGD,RMSprop\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.applications import InceptionV3\nfrom tensorflow.keras.layers import AveragePooling2D\nfrom tensorflow.keras.layers import Dropout, GlobalAveragePooling2D, Activation, BatchNormalization, Dropout, LSTM, ConvLSTM2D\nfrom tensorflow.keras.layers import Flatten\nfrom tensorflow.keras.layers import Dense\nfrom tensorflow.keras.layers import Input,Conv2D, SeparableConv2D, MaxPool2D, LeakyReLU, Activation, LSTM, ConvLSTM2D, Lambda, Reshape, BatchNormalization, Bidirectional\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras.utils import to_categorical\nfrom tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint,TensorBoard,TerminateOnNaN, LearningRateScheduler\nfrom tensorflow.keras.losses import binary_crossentropy\nfrom tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau, TerminateOnNaN\nfrom tensorflow.keras.layers import Lambda, Reshape, DepthwiseConv2D, ZeroPadding2D, Add, MaxPooling2D,Activation, Flatten, Conv2D, Dense, Input, Dropout, Concatenate, GlobalMaxPooling2D, GlobalAveragePooling2D, BatchNormalization\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras import regularizers\nfrom tensorflow.keras import backend as K\n\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.model_selection import train_test_split, StratifiedKFold, RepeatedStratifiedKFold\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix, roc_auc_score, roc_curve, auc\nfrom imutils import paths\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport random\nimport shutil\nimport cv2\nimport os\nfrom datetime import datetime\n%load_ext tensorboard","79782ebf":"from __future__ import absolute_import, division, print_function, unicode_literals\nprint(\"Num GPUs Available: \", len(tf.config.experimental.list_physical_devices('GPU')))\ntf.config.experimental.list_physical_devices('GPU')\ntf.debugging.set_log_device_placement(True)","85917fc4":"dataset_path = '.\/out'\nlog_path = '.\/logs'","1fc7ce73":"%%bash\nrm -rf out\nmkdir -p out\nmkdir -p logs","f610b101":"ls ..\/input\/covid19-pneumonia-normal-chest-xray-pa-dataset","54c3b618":"df = pd.DataFrame(columns =['class', 'directory'])  \ndf","534e63d0":"# df.loc[-1] = [\"normal\", \"norma\/00000398_0.png\"] \n# df.index = df.index + 1  # shifting index\n# df = df.sort_index() \n# df","e62a94d2":"# for dirpath, dirnames, filenames in os.walk('..\/input\/covid19-pneumonia-normal-chest-xray-pa-dataset\/normal'):\n#     for filename in filenames:\n#         print('normal\/' + filename)","be8856f0":"import os\nfor dirpath, dirnames, filenames in os.walk('..\/input\/covid19-pneumonia-normal-chest-xray-pa-dataset\/normal'):\n    for filename in filenames:\n        df.loc[-1] = [\"normal\", ('normal\/' + filename)] \n        df.index = df.index + 1 \n        df = df.sort_index() \nfor dirpath, dirnames, filenames in os.walk('..\/input\/covid19-pneumonia-normal-chest-xray-pa-dataset\/covid'):\n    for filename in filenames:\n        df.loc[-1] = [\"covid\", ('covid\/' + filename)] \n        df.index = df.index + 1 \n        df = df.sort_index() \nfor dirpath, dirnames, filenames in os.walk('..\/input\/covid19-pneumonia-normal-chest-xray-pa-dataset\/pneumonia'):\n    for filename in filenames:\n        df.loc[-1] = [\"pneumonia\", ('pneumonia\/' + filename)] \n        df.index = df.index + 1 \n        df = df.sort_index() ","7ea2af1f":"df","8a1d9ff6":"df_y = df['class']\ndf_x = df['directory']","4885d31e":"df_x","d9918c73":"df_y.value_counts()","c344eaa9":"X_train, X_test, Y_train, Y_test = train_test_split(df_x, df_y, stratify=df_y, test_size=0.20, random_state=7)","b841ac0a":"Y_train.value_counts()","854b1f49":"test = pd.concat([X_test, Y_test], axis = 1)\ntest.head()","5b5f05b1":"# rm -rf dataset\/test","eec072c0":"# used to copy files according to each fold\ndef copy_images(df, directory):\n    \n    # input and output directory\n    input_path = \"..\/input\/covid19-pneumonia-normal-chest-xray-pa-dataset\"     \n    output_path = \"out\/\" + directory\n\n    # remove all files from previous fold\n    if os.path.exists(output_path):\n        shutil.rmtree(output_path)\n\n    # create folder for files from this fold\n    if not os.path.exists(output_path):\n        os.makedirs(output_path)\n\n    # create subfolders for each class\n    classs=['normal','covid','pneumonia']\n    for c in classs:\n        if not os.path.exists(output_path + '\/' + c):\n            os.makedirs(output_path + '\/' + c)\n        \n    # copy files\n    for i, row in df.iterrows():\n        path_from = \"{}\/{}\".format(input_path, row['directory'])\n        path_to = \"{}\/{}\".format(output_path, row['directory'])\n        shutil.copy(path_from, path_to)\n#         print(path_to)","7497eeca":"copy_images(test, 'test')","5bf035d0":"!ls .\/out\/test  ","c38c7587":"print(len(os.listdir('.\/out\/test\/normal')))\nprint(len(os.listdir('.\/out\/test\/covid')))\nprint(len(os.listdir('.\/out\/test\/pneumonia')))","ac61c28b":"train_datagen = ImageDataGenerator(rescale=1.\/255, rotation_range=15, fill_mode='nearest')\nval_datagen = ImageDataGenerator(rescale=1.\/255)\ntest_datagen = ImageDataGenerator(rescale=1.\/255)","c2cc2aac":"test_generator = test_datagen.flow_from_directory(\n    directory=r\".\/out\/test\/\",\n    target_size=(224, 224),\n    color_mode=\"rgb\",\n    batch_size=1,\n    class_mode=None,\n    shuffle=False,\n    seed=42\n)","6b70477c":"class_to_label_map = {'pneumonia' : 2, 'covid' : 1, 'normal' : 0}","bc3ac303":"def get_model():\n    \n    # Create Model..........................................\n    \n    # Input layer\n    baseModel = InceptionV3(weights=\"imagenet\", include_top=False, input_tensor=Input(shape=(224, 224, 3)))\n    for layer in baseModel.layers:\n        layer.trainable = False\n    x = baseModel.output\n    \n#     x = AveragePooling2D(pool_size=(3,3), name='avg_pool')(x)\n\n    # LSTM layer\n    x = Reshape((25, 2048))(x)\n    x = ((LSTM(512, activation=\"relu\", return_sequences=True, trainable=False)))(x)\n    x = BatchNormalization()(x)\n#     x = Dropout(0.5)(x)\n    \n    # FC layer\n    x = Flatten(name=\"flatten\")(x)\n    \n    # fc1 layer\n    x = Dense(units=4096, activation='relu')(x)\n    x = BatchNormalization()(x)\n#     x = Dropout(0.5)(x)\n\n    # fc2 layer\n    x = Dense(units=4096, activation='relu')(x)\n    x = BatchNormalization()(x)\n#     x = Dropout(0.5)(x)\n    \n    # Output layer\n    output = Dense(units=3, activation='softmax')(x)\n\n    model = Model(inputs=baseModel.input, outputs=output)\n    opt = RMSprop(lr=0.0001, decay=1e-6)\n    model.compile(loss='categorical_crossentropy', optimizer=opt, metrics=[\"accuracy\"])\n    \n    return model","82a74a64":"from math import floor\nN_FOLDS = 1\nEPOCHS = 100\nINIT_LR = 2e-4\nT_BS = 32\nV_BS = 32\ndecay_rate = 0.95\ndecay_step = 1\n\nskf = StratifiedKFold(n_splits = 5, random_state = 7, shuffle = True)\nlog_dir = \".\/logs\/\" + datetime.now().strftime(\"%Y%m%d-%H%M%S\")\ntensorboard_callback = TensorBoard(log_dir=log_dir, histogram_freq=1)\n\ncallbacks = [ModelCheckpoint(filepath='best_lstm_model.h5', monitor='val_loss',mode='min',verbose=1,save_best_only=True,save_weights_only=True),\n             LearningRateScheduler(lambda epoch : INIT_LR * pow(decay_rate, floor(epoch \/ decay_step))), tensorboard_callback]","2e921271":"from time import time","2ef8df24":"submission_predictions = []\n\nfor epoch, (train_index, val_index) in enumerate(skf.split(df_x, df_y)):\n    x_train, x_val = df_x.iloc[train_index], df_x.iloc[val_index]\n    y_train, y_val = df_y.iloc[train_index], df_y.iloc[val_index]\n    \n    print(y_train.value_counts())\n    print(y_val.value_counts())\n\n    train = pd.concat([x_train, y_train], axis=1)\n    val = pd.concat([x_val, y_val], axis = 1)\n    \n    # copy the images according to the fold\n    copy_images(train, 'train')\n    copy_images(val, 'val')\n    \n    print('Running fold '+ str(epoch+1))\n    \n    # CREATE MODEL\n    model = get_model()\n#     model.summary()\n    \n    # Load Model Weights\n    if epoch != 0:\n        model.load_weights('best_lstm_model.h5') \n    \n    train_generator = train_datagen.flow_from_directory(\n        directory=r\".\/out\/train\/\",\n        target_size=(224, 224),\n        color_mode=\"rgb\",\n        batch_size=16,\n        class_mode=\"categorical\",\n        shuffle=True,\n        seed=42\n    )\n    valid_generator = val_datagen.flow_from_directory(\n        directory=r\".\/out\/val\/\",\n        target_size=(224, 224),\n        color_mode=\"rgb\",\n        batch_size=16,\n        class_mode=\"categorical\",\n        shuffle=True,\n        seed=42\n    )\n    \n    startTrain = time()\n    history = model.fit_generator(\n                generator=train_generator,\n                steps_per_epoch=train_generator.n\/\/train_generator.batch_size,\n                validation_data=valid_generator,\n                validation_steps=valid_generator.n\/\/valid_generator.batch_size,\n                epochs=EPOCHS,\n                callbacks=callbacks\n    )\n    print(time()-startTrain)\n    \n    hist_df = pd.DataFrame(history.history) \n    hist_csv_file = 'history.csv'\n    \n    fig, ax = plt.subplots(1, 2, figsize=(10, 6))\n    ax = ax.ravel()\n    for i, met in enumerate(['accuracy', 'loss']):\n        ax[i].plot(history.history[met])\n        ax[i].plot(history.history['val_' + met])\n        ax[i].set_title('Model {}'.format(met))\n        ax[i].set_xlabel('number of epochs')\n        ax[i].set_ylabel(met)\n        ax[i].legend(['train', 'val'])\n    plt.savefig('accuracy_performance_graph'+'_'+str(epoch)+'.png')\n    \n    test_generator.reset()\n    startTest = time()\n    predY=model.predict_generator(\n            test_generator,\n            steps=test_generator.n\/\/test_generator.batch_size,\n            verbose=1)\n    print(time()-startTest)\n    \n    if epoch >= 1:\n        submission_predictions.append(predY)\n        \n    testY = test_generator.classes\n    confusion__matrix=confusion_matrix(testY, np.argmax(predY, axis = -1))\n    cr=(classification_report(testY, np.argmax(predY, axis = -1), target_names=class_to_label_map, output_dict=True, digits=4))\n    print (cr)\n    print(confusion__matrix)\n    \n    cm_df = pd.DataFrame(confusion__matrix)\n    cr_df = pd.DataFrame(cr)\n    with open(hist_csv_file, mode='a') as f:\n        hist_df.to_csv(f)\n        cm_df.to_csv(f)\n        cr_df.to_csv(f)\n    \n    plt.figure(figsize=(10, 4))\n    plt.plot(history.history['accuracy'], label='train_accuracy')\n    plt.plot(history.history['val_accuracy'], label='val_accuracy')\n    plt.plot(history.history['loss'], label='train_loss')\n    plt.plot(history.history['val_loss'], label='val_loss')\n    plt.title(\"Model accuracy & loss\")\n    plt.ylabel(\"accuracy & loss\")\n    plt.xlabel(\"number of epochs\")\n    plt.legend([\"train_accuracy\", \"val_accuracy\", \"train_loss\", \"val_loss\"], loc=\"upper left\")\n    plt.savefig('accuracy_loss_performance'+'_'+str(epoch)+'.png')\n    \n    model.save('final_lstm_model.h5') \n    \n    del history\n    del model\n    gc.collect()","47a9bf04":"predY = np.average(submission_predictions, axis = 0, weights = [2**i for i in range(len(submission_predictions))])","a1f76275":"roc_auc_score(testY, predY, multi_class='ovo')","6fad8d2f":"roc_auc_score(testY, predY, multi_class='ovr')","4bac106d":"class_to_label_map = ['normal', 'covid', 'pneumonia']","b6eebb4e":"import seaborn as sns\ndef plot_multiclass_roc(y_test, y_score, n_classes, figsize=(17, 6)):\n\n    # structures\n    fpr = dict()\n    tpr = dict()\n    roc_auc = dict()\n    plt.figure(figsize=(10, 10))\n    lw = 3\n\n    # calculate dummies once\n    y_test_dummies = pd.get_dummies(y_test, drop_first=False).values\n    for i in range(n_classes):\n        fpr[i], tpr[i], _ = roc_curve(y_test_dummies[:, i], y_score[:, i])\n        roc_auc[i] = auc(fpr[i], tpr[i])\n\n    colors = ['aqua', 'darkorange', 'cornflowerblue']\n    for i, color in zip(range(n_classes), colors):\n        plt.plot(fpr[i], tpr[i], color=color, lw=lw,\n                 label='ROC curve of class {0} (area = {1:0.4f})'\n                 ''.format(class_to_label_map[i], roc_auc[i]))\n\n    plt.plot([0, 1], [0, 1], 'k--', lw=lw)\n    plt.xlim([0.0, 1.0])\n    plt.ylim([0.0, 1.05])\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n#     plt.title('Some extension of Receiver operating characteristic to multi-class')\n    plt.legend(loc=\"lower right\")\n    plt.show()\n\nplot_multiclass_roc(testY, predY, n_classes=3, figsize=(10, 10))","72d20c9f":"import seaborn as sns\ndef plot_multiclass_roc(y_test, y_score, n_classes, figsize=(17, 6)):\n\n    # structures\n    fpr = dict()\n    tpr = dict()\n    roc_auc = dict()\n    plt.figure(figsize=(10, 10))\n    lw = 2\n\n    # calculate dummies once\n    y_test_dummies = pd.get_dummies(y_test, drop_first=False).values\n    for i in range(n_classes):\n        fpr[i], tpr[i], _ = roc_curve(y_test_dummies[:, i], y_score[:, i])\n        roc_auc[i] = auc(fpr[i], tpr[i])\n\n    colors = ['aqua', 'darkorange', 'cornflowerblue']\n    for i, color in zip(range(n_classes), colors):\n        plt.plot(fpr[i], tpr[i], color=color, lw=lw,\n                 label='ROC curve of class {0} (area = {1:0.4f})'\n                 ''.format(class_to_label_map[i], roc_auc[i]))\n\n    plt.plot([0, 1], [0, 1], 'k--', lw=lw)\n    plt.xlim([0.0, 1.0])\n    plt.ylim([0.0, 1.05])\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n#     plt.title('Some extension of Receiver operating characteristic to multi-class')\n    plt.legend(loc=\"lower right\")\n    plt.show()\n\nplot_multiclass_roc(testY, predY, n_classes=3, figsize=(10, 10))","c8c5969d":"cm_mat = confusion_matrix(testY, np.argmax(predY, axis = -1))","8ec0c3c4":"def plot_confusion_matrix(cm,\n                          target_names,\n                          title='Confusion matrix',\n                          cmap=None,\n                          normalize=True):\n\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import itertools\n\n    accuracy = np.trace(cm) \/ float(np.sum(cm))\n    misclass = 1 - accuracy\n\n    if cmap is None:\n        cmap = plt.get_cmap('Greens')\n\n    plt.figure(figsize=(8, 6))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title, fontsize = 'larger')\n\n    if target_names is not None:\n        tick_marks = np.arange(len(target_names))\n        plt.xticks(tick_marks, target_names, rotation=45, fontsize = 'larger')\n        plt.yticks(tick_marks, target_names, fontsize = 'larger')\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n\n\n    thresh = cm.max() \/ 1.5 if normalize else cm.max() \/ 2\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        if normalize:\n            plt.text(j, i, \"{:0.4f}\".format(cm[i, j]),\n                     horizontalalignment=\"center\",\n                     color=\"white\" if cm[i, j] > thresh else \"black\", fontsize = 'larger')\n        else:\n            plt.text(j, i, \"{:,}\".format(cm[i, j]),\n                     horizontalalignment=\"center\",\n                     color=\"white\" if cm[i, j] > thresh else \"black\", fontsize = 'larger')\n\n\n    plt.tight_layout()\n    plt.ylabel('True label', fontsize = 'larger')\n    plt.xlabel('Predicted label', fontsize = 'larger')\n#     plt.xlabel('Predicted label\\naccuracy={:0.4f}; misclass={:0.4f}'.format(accuracy, misclass))\n    plt.show()\n    \nplot_confusion_matrix(cm_mat, \n                      normalize = False,\n                      target_names = ['Normal', 'COVID-19', 'Pneumonia'],\n                      title        = \"Confusion Matrix\")","c224c00b":"print(classification_report(testY, np.argmax(predY, axis = -1), target_names = ['normal', 'covid', 'pneumonia'], digits=4))","d935af75":"!rm -rf out\n!rm -rf logs","025def21":"#### Confusion matrix","4497baa1":"### Evaluation","52fba38b":"## Model","2b6008b5":"## Setup","02484517":"## Data preprocessing","4a2de490":"### Plot trining metrics","fc206888":"## Build Dataset","68c4a830":"### Training"}}