{"cell_type":{"fd99d5d7":"code","5a6ed5dc":"code","aaba99a3":"code","9ce58dde":"code","4866b5f6":"code","b1602d46":"code","f5f82f38":"code","ffad717f":"code","3b8fc76e":"code","9f39dc2f":"code","9fe056f8":"code","01c822fc":"code","0af06d5a":"code","8c149ae0":"code","b1e0ef60":"code","dfc155cc":"code","44c4ca0c":"code","4b17bf99":"code","110c9be8":"markdown","d75c24e4":"markdown","7bfffdfc":"markdown","a2fd6c87":"markdown","e051f806":"markdown","3237b523":"markdown","4d9477d4":"markdown","9df8782d":"markdown","666d8526":"markdown","eb283a7a":"markdown","82d8204f":"markdown"},"source":{"fd99d5d7":"# Import numpy, pandas, and matplotlib using the standard aliases. \n# Import the following tools from sklearn: \n#     Pipeline, SimpleImputer, ColumnTransformer, OneHotEncoder, StandardScaler\n#     LogisticRegression, DecisionTreeClassifier, RandomForestClassifier, GridSearchCV\n# Import joblib\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport joblib\n\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import OneHotEncoder, StandardScaler\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import GridSearchCV","5a6ed5dc":"# Load the training data into a DataFrame named 'train'. \n# Print the shape of the resulting DataFrame. \n# You do not need the test data in this notebook. \n\ntrain = pd.read_csv('..\/input\/titanic\/train.csv')\ntrain = train.sample(frac=1, random_state=1)\n\nprint(train.shape)","aaba99a3":"# Display the head of the train DataFrame. \ntrain.head()","9ce58dde":"# Calculate and print the number of number of missing values in each column.\n\ntrain.isnull().sum().to_frame().T","4866b5f6":"# Display a DataFrame showing the proportion of observations with each \n# possible of the target variable (which is Survived). \n\n(train.Survived.value_counts() \/ len(train)).to_frame()","b1602d46":"y_train = train.Survived.values\ntrain.drop(['PassengerId', 'Survived'], axis = 1, inplace=True)\n\ntrain.head()","f5f82f38":"# We will start with some feature engineering. \n\n# Add a new column named 'FamSize' to the DataFrame. \n# This should be the sum of the 'SibSp' and 'Parch' columns. \n\ntrain['FamSize'] = train.SibSp + train.Parch\n\n# We will use the function below to determine the deck letter for each passenger:\ndef set_deck(cabin):\n    if str(cabin) == 'nan':\n        return 'Missing'\n    return cabin[0]\n\n# Use the map() method of the train DataFrame to apply the function above \n# to the 'Cabin' column. Store the results in a new column named 'Deck'. \n\ntrain['Deck'] = train.Cabin.map(set_deck)\nprint(train)","ffad717f":"# Create a list of numberical feature names. Use the following features: 'Age', 'FamSize', 'Fare'\n\nnum_features = ['Age', 'FamSize', 'Fare']\n\n# Create a list of categorical feature names. Use the following features: 'Sex', 'Pclass', 'Deck', 'Embarked'\n\ncat_features = ['Sex', 'Pclass', 'Deck', 'Embarked']\n\n# Combine the two previous lists into one list named 'features'\n\nfeatures = num_features + cat_features\n\n# Create a Pipeline object for processing the numerical features. \n# This pipeline should consist of a SimpleImputer and a StandardScaler\n\nnum_transformer = Pipeline(\n    steps = [\n        ('imputer', SimpleImputer(strategy='mean')),\n        ('scaler', StandardScaler())  \n    ]\n)\n\n# Create a Pipeline object for processing the categorical features. \n# This pipeline should consist of a SimpleImputer and a OneHotEncoder\n\ncat_transformer = Pipeline(\n    steps = [\n        ('imputer', SimpleImputer(strategy='constant', fill_value='Missing')),\n        ('onehot', OneHotEncoder(handle_unknown='ignore'))\n    ]\n)\n\n# Create a ColumnTransformer object that combines the two pipelines created above. \n# Name this ColumnTransformer 'preprocessor'\n\npreprocessor = ColumnTransformer(\n    transformers = [\n        ('num', num_transformer, num_features),\n        ('cat', cat_transformer, cat_features) \n    ]\n)","3b8fc76e":"# Fit the preprocessor to the training data, selecting only the columns in the 'features' list. \n# Apply the fitted preprocessor to the training data, again selecting only the relevant columns. \n# Store the array created in the previous step into a variable named 'X_train'.\n\npreprocessor.fit(train)\nX_train = preprocessor.transform(train)\n\n# Create a variable named 'y_train' that contains the training labels. \n# Print the shapes of X_train and y_train.\n\nprint('X_train shape:', X_train.shape)\nprint('y_train shape:', y_train.shape)","9f39dc2f":"# Select a range of parameter values of C. \n# You might need to experiment with this to find a good value for C\n# Update the code below to perform 10-Fold cross-validation. \n# Set the scoring parameter below to 'accuracy'\n\nlr_clf = LogisticRegression(max_iter=1000, solver='saga', penalty='elasticnet')\n\nlr_parameters = {\n    'l1_ratio':[0, 0.5, 1],\n    'C': [0.001, 0.01, 0.1, 1, 10]\n}\n\nlr_grid = GridSearchCV(lr_clf, lr_parameters, cv= 10, refit='True', n_jobs=-1, verbose=10, scoring= 'accuracy')\nlr_grid.fit(X_train, y_train)\n\nlr_model = lr_grid.best_estimator_\n\nprint('Best Parameters:', lr_grid.best_params_)\nprint('Best CV Score:  ', lr_grid.best_score_)\nprint('Training Acc:   ', lr_model.score(X_train, y_train))","9fe056f8":"# Run this cell without any changes to view the CV results.\n\nlr_summary = pd.DataFrame(lr_grid.cv_results_['params'])\nlr_summary['cv_score'] = lr_grid.cv_results_['mean_test_score']\n\nfor r in lr_parameters['l1_ratio']:\n    temp = lr_summary.query(f'l1_ratio == {r}')\n    plt.plot(temp.C, temp.cv_score, label=r)\nplt.xscale('log')\nplt.ylim([0.75, 0.82])\nplt.xlabel('Regularization Parameter (C)')\nplt.ylabel('CV Score')\nplt.legend(title='L1 Ratio', loc='lower right')\nplt.grid()\nplt.show()\n\nprint(lr_summary.to_string(index=False))","01c822fc":"# Select values to consider for the max_depth and min_samples_leaf hyperparameters.\n# You might need to experiment to find a good range of parameter values. \n# Update the code below to perform 10-Fold cross-validation. \n# Set the scoring parameter below to 'accuracy' \n\ndt_clf = DecisionTreeClassifier(random_state=1)\n\ndt_parameters = {\n    'max_depth': [2, 4, 6, 8, 10, 12, 14, 16],\n    'min_samples_leaf': [2, 4, 8, 16]\n}\n\ndt_grid = GridSearchCV(dt_clf, dt_parameters, cv= 10, refit='True', n_jobs=-1, verbose=0, scoring= 'accuracy')\ndt_grid.fit(X_train, y_train)\n\ndt_model = dt_grid.best_estimator_\n\nprint('Best Parameters:', dt_grid.best_params_)\nprint('Best CV Score:  ', dt_grid.best_score_)\nprint('Training Acc:   ', dt_model.score(X_train, y_train))","0af06d5a":"# Run this cell without any changes to view the CV results.\n\ndt_summary = pd.DataFrame(dt_grid.cv_results_['params'])\ndt_summary['cv_score'] = dt_grid.cv_results_['mean_test_score']\n\nfor ms in dt_parameters['min_samples_leaf']:\n    temp = dt_summary.query(f'min_samples_leaf == {ms}')\n    plt.plot(temp.max_depth, temp.cv_score, label=ms)\nplt.xlabel('Maximum Depth')\nplt.ylabel('CV Score')\nplt.legend(title='Min Samples')\nplt.grid()\nplt.show()\n\nprint(dt_summary.to_string(index=False))","8c149ae0":"# Select a number of trees to use in your random forest.\n# Select values to consider for the max_depth and min_samples_leaf hyperparameters.\n# You might need to experiment to find a good range of parameter values. \n# Update the code below to perform 10-Fold cross-validation. \n# Set the scoring parameter below to 'accuracy'\n\nrf_clf = RandomForestClassifier(random_state=1, n_estimators= 50)\n\nrf_parameters = {\n    'max_depth': [14, 15, 16, 17, 18, 19],\n    'min_samples_leaf': [2, 3, 4, 5]\n}\n\nrf_grid = GridSearchCV(rf_clf, rf_parameters, cv= 10, refit='True', n_jobs=-1, verbose=0, scoring= 'accuracy')\nrf_grid.fit(X_train, y_train)\n\nrf_model = rf_grid.best_estimator_\n\nprint('Best Parameters:', rf_grid.best_params_)\nprint('Best CV Score:  ', rf_grid.best_score_)\nprint('Training Acc:   ', rf_model.score(X_train, y_train))","b1e0ef60":"# Run this cell without any changes to view the CV results.\n\nrf_summary = pd.DataFrame(rf_grid.cv_results_['params'])\nrf_summary['cv_score'] = rf_grid.cv_results_['mean_test_score']\n\nfor ms in rf_parameters['min_samples_leaf']:\n    temp = rf_summary.query(f'min_samples_leaf == {ms}')\n    plt.plot(temp.max_depth, temp.cv_score, label=ms)\nplt.xlabel('Maximum Depth')\nplt.ylabel('CV Score')\nplt.legend(title='Min Samples')\nplt.grid()\nplt.show()\n\nprint(rf_summary.to_string(index=False))","dfc155cc":"print(rf_grid.best_params_)","44c4ca0c":"final_model = RandomForestClassifier(random_state=1, n_estimators=50, max_depth=17, min_samples_leaf=2)\nfinal_model.fit(X_train, y_train)\n\nprint(final_model.score(X_train, y_train))","4b17bf99":"# Save your pipeline to a file. \n# Determine the best model found above and save that to a file. \n# Download both files to your local device and then upload them as a Kaggle dataset. \n\njoblib.dump(preprocessor, 'titanic_preprocessor_01.joblib')\njoblib.dump(final_model, 'titanic_model_01.joblib')\nprint('Model written to file.')","110c9be8":"## Logistic Regression","d75c24e4":"## Decicion Trees","7bfffdfc":"# Load Training Data","a2fd6c87":"## Random Forests","e051f806":"# Preprocessing","3237b523":"# Check Label Distribution","4d9477d4":"# Import Statements","9df8782d":"# Check for Missing Values","666d8526":"# Save Pipeline and Model","eb283a7a":"# Titanic Dataset\n\nMost of the code cells below include comments explaining the task to be performed in those cells. Please delete the comments and add code to perform those tasks. There are a few code cells in which code has already been provided for you. In some cases, you will need to compelte this code. ","82d8204f":"# Model Selection"}}