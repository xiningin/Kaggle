{"cell_type":{"fe7b67db":"code","6a68090d":"code","49c8f68a":"code","fbf3eeb9":"code","b062b183":"code","3c911e57":"code","68c42ad0":"code","02e1f8f3":"code","4ab864f6":"code","45fd42c7":"code","85604e2b":"code","3048531a":"code","df15b90d":"code","cf7b5c5c":"code","3e00fdb5":"code","45927610":"code","cec51b87":"code","3623e218":"markdown","175a5ff7":"markdown","5261054b":"markdown","4dda137e":"markdown","5f015297":"markdown","91be8b70":"markdown","dfae1057":"markdown","efa70790":"markdown","08806670":"markdown","5dca3cbc":"markdown","d99ae20e":"markdown","a86bcbdd":"markdown","2ae86870":"markdown","69d1f6eb":"markdown","b911c2ed":"markdown","7268f3b1":"markdown","19e28826":"markdown","c5605d3d":"markdown","c21d3a97":"markdown","049fc8a0":"markdown","9c0dc050":"markdown"},"source":{"fe7b67db":"weight = 0.1","6a68090d":"def neural_network(input_val, weight):\n    # you could also picture this like the formula\n    # y       =   m     *    x    \n    prediction = weight * input_val\n    return prediction","49c8f68a":"number_of_toes = [8.5, 9.5, 10, 9]\ninput_val = number_of_toes[0]\npred = neural_network(input_val, weight)\nprint(pred)","fbf3eeb9":"def elementwise_multiplication(vec_a, vec_b):\n    # multiplying the values in two different vectors (assuming they have the same length)\n    \n    if (len(vec_a) == len(vec_b)):\n        final_vector = [a*b for a,b in zip(vec_a, vec_b)]\n    else:\n        final_vector = 0\n    \n    return final_vector","b062b183":"def elementwise_addition(vec_a, vec_b):\n    # adding the values in two different vectors (assuming they have the same length)\n    \n    if (len(vec_a) == len(vec_b)):\n        final_vector = [a+b for a,b in zip(vec_a, vec_b)]\n    else:\n        final_vector = 0\n        \n    return final_vector","3c911e57":"def vector_sum(vec_a):\n    # the summation of all the values in a vector\n    \n    return sum(vec_a)","68c42ad0":"def vector_average(vec_a):\n    # the average of all the values in a vector\n    \n    return sum(vec_a)\/len(vec_a)","02e1f8f3":"def dot_product(vec_a, vec_b):\n    # the dot product is the summation of multiplying two or more vectors\n    \n    final_vector = elementwise_multiplication(vec_a, vec_b)\n    return vector_sum(final_vector)","4ab864f6":"# practice\na = [0,1,0,1]\nb = [1,0,1,0]\nc = [0,1,1,0]\nd = [.5,0,.5,0]\ne = [0,1,-1,0]\n\n[dot_product(a,b), dot_product(b,c), dot_product(b,d), dot_product(c,c), dot_product(d,d), dot_product(c,e)]","45fd42c7":"weights = [0.1, 0.2, 0]","85604e2b":"def neural_network2(input_val, weights):\n    \n    pred = dot_product(input_val, weights)\n    return pred","3048531a":"# each index in the vectors below corresponds to one game (4 games in total)\n# i.e. toes[0], wlrec[0], nfans[0] => 1st game\n# toes[1], wlrec[1], nfans[1] => 2nd game\n# etc.\n\ntoes = [8.5, 9.5, 9.9, 9.0]\nwlrec = [0.65, 0.8, 0.8, 0.9]\nnfans = [1.2, 1.3, 0.5, 1.0]\n\ninput_val = [toes[0], wlrec[0], nfans[0]]\npred = neural_network2(input_val, weights)\nprint(pred)","df15b90d":"def neural_network_numpy(input_val, weights):\n    pred = input_val.dot(weights)\n    return pred","cf7b5c5c":"import numpy as np\n\nweights3 = np.array([0.1, 0.2, 0])\n\ntoes = np.array([8.5, 9.5, 9.9, 9.0])\nwlrec = np.array([0.65, 0.8, 0.8, 0.9])\nnfans = np.array([1.2, 1.3, 0.5, 1.0])\n\n#we are just predicting the first game\ninput_val3 = np.array([toes[0], wlrec[0], nfans[0]])\npred = neural_network_numpy(input_val3, weights3)\nprint(pred)","3e00fdb5":"def vector_mat_mul(vect, matrix):\n    assert(len(vect) == len(matrix))\n    output = [0,0,0]\n    \n    for i in range(len(vect)):\n        output[i] = dot_product(vect, matrix[i])\n        \n    return output\n\ndef neural_network(input_val, weights):\n    pred = vector_mat_mul(input_val, weights)\n    return pred\n\n            #toes wins #fans\nweights = [[0.1, 0.1, -0.3], #hurt?\n          [0.1, 0.2, 0.0], #win?\n          [0.0, 1.3, 0.1]] #sad?\n\ntoes = [8.5, 9.5, 9.9, 9.0]\nwlrec = [0.65, 0.8, 0.8, 0.9]\nnfans = [1.2, 1.3, 0.5, 1.0]\n\n#input_values are just the values of one game\ninput_values = [toes[0], wlrec[0], nfans[0]]\npred = neural_network(input_values, weights)\nprint(pred)","45927610":"def neural_network(input_val, weights):\n    hid = vector_mat_mul(input_val, weights[0])\n    pred = vector_mat_mul(hid, weights[1])\n    return pred\n\nih_wgt = [[0.1, 0.2, -0.1],\n         [-0.1, 0.1, 0.9],\n         [0.1, 0.4, 0.1]]\n\nhp_wgt = [[0.3, 1.1, -0.3],\n         [0.1, 0.2, 0.0],\n         [0.0, 1.3, 0.1]]\n\nweights = [ih_wgt, hp_wgt]\n\ntoes = [8.5, 9.5, 9.9, 9.0]\nwlrec = [0.65, 0.8, 0.8, 0.9]\nnfans = [1.2, 1.3, 0.5, 1.0]\n\ninput_val = [toes[0], wlrec[0], nfans[0]]\npred = neural_network(input_val, weights)\nprint(pred)","cec51b87":"import numpy as np\n\ndef neural_network_stacked(i_val, weights):\n    hid = i_val.dot(weights[0])\n    pred = hid.dot(weights[1])\n    return pred\n\nih_wgt = np.array([[0.1, 0.2, -0.1],\n         [-0.1, 0.1, 0.9],\n         [0.1, 0.4, 0.1]]).T\n\nhp_wgt = np.array([[0.3, 1.1, -0.3],\n         [0.1, 0.2, 0.0],\n         [0.0, 1.3, 0.1]]).T\n\nweights2 = [ih_wgt, hp_wgt]\n\ntoes = np.array([8.5, 9.5, 9.9, 9.0])\nwlrec = np.array([0.65, 0.8, 0.8, 0.9])\nnfans = np.array([1.2, 1.3, 0.5, 1.0])\n\ni_val = np.array([toes[0], wlrec[0], nfans[0]])\npred = neural_network_stacked(i_val, weights2)\nprint(pred)","3623e218":"## Neural Network with a Dot Product","175a5ff7":"See if you can write functions that perform the following functions:\n* `def elementwise_multiplication(vec_a, vec_b)`\n* `def elementwise_addition(vec_a, vec_b)`\n* `def vector_sum(vec_a)`\n* `def vector_average(vec_a)`\n\nThen, see if you can use two of these methods to peform the dot product!\n\nWhen done, try the following vectors:\n* `a = [0,1,0,1]`\n* `b = [1,0,1,0]`\n* `c = [0,1,1,0]`\n* `d = [.5,0,.5,0]`\n* `e = [0,1,-1,0]`\n\nAnd their function calls below:\n\n* `dot_product(a,b) = 0`\n* `dot_product(b,c) = 1`\n* `dot_product(b,d) = 1`\n* `dot_product(c,c) = 2`\n* `dot_product(d,d) = .5`\n* `dot_product(c,e) = 0`","5261054b":"## Neural Network with a Dot Product (NumPy version)","4dda137e":"## Predicting multiple inputs and outputs","5f015297":"## Predicting on Predictions: Neural Networks Can Be Stacked!","91be8b70":"## A Simple Neural Network From Scratch","dfae1057":"![IMG_0176.JPG](attachment:IMG_0176.JPG)","efa70790":"### Neural Network Stacked (w\/o NumPy)","08806670":"Note: As an Amazon Associate I earn from qualifying purchases. I get commissions for purchases made through links in this jupyter notebook. See a more full disclaimer [here](https:\/\/jdridgeway.com\/disclaimer\/)","5dca3cbc":"### Remember:","d99ae20e":"![IMG_0175.JPG](attachment:IMG_0175.JPG)","a86bcbdd":"Material that the following code is drawn upon comes from the Grokking Deep Learning book which you can purchase here (ebook: https:\/\/www.manning.com\/books\/grokking-deep-learning) or (physical: https:\/\/amzn.to\/3efYKmU)","2ae86870":"In referencing my pictures above, a stacked neural network would work like the following:","69d1f6eb":"## Challenge: Vector Math","b911c2ed":"The code above is an example of a forward propagating neural network. You're basically making calculations on your predictions (with their corresponding weights) that produce other predictions.","7268f3b1":"### Neural Network Stacked (w\/ NumPy)","19e28826":"![IMG_0177.JPG](attachment:IMG_0177.JPG)","c5605d3d":"![IMG_0178.JPG](attachment:IMG_0178.JPG)","c21d3a97":"Check out my blog post here, for a high level scope of the book and my thoughts \ud83d\udc49\ud83c\udffe https:\/\/jdridgeway.com\/deep-learning-from-scratch-simple-nn\/","049fc8a0":"The `weight` variable is the scale by which the prediction is determined in the neural_network function. I am thinking about this like one would a formula (i.e. `y = mx + b` or `y = mx`). The slope (in case `m`) determines what your `y` or your `prediction` will be, based off of your input value `x`.","9c0dc050":"the corresponding weights change in the `for loop`. In the example (from the Grokking Deep Learning book), the corresponding weights are just weights[0]. You still have two more left to get the corresponding predictions being:\n* hurt prediction (p1)\n* win prediction (p2)\n* sad prediction (p3)\n\nThe way I've come to think about it (and makes sense for me) is like you are multiplying each set of weights with a vector (in this case, set of inputs or number of toes, win\/loss record, and number of fans)."}}