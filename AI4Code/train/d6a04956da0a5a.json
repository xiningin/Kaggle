{"cell_type":{"a2bc9862":"code","c51ef806":"code","a07a37ab":"code","05f9a9d1":"code","f6615d25":"code","645e697a":"code","e2ffebd0":"code","dc426628":"code","8cb2794d":"code","e933fe2c":"code","09cc0f3c":"code","380b7047":"code","4630de62":"code","2452cae3":"code","9c6c4470":"code","4cd09290":"code","716caee2":"code","34fc2e72":"code","653884b0":"code","387b0a5e":"code","282baf57":"code","72c348ae":"code","29b08abd":"code","3025bb23":"code","2b52d46d":"code","56cbad64":"code","b06227da":"markdown","a8503858":"markdown"},"source":{"a2bc9862":"!pip uninstall kaggle\n!pip install --upgrade pip\n!pip install kaggle","c51ef806":"!mkdir -p ~\/.kaggle\n!cp kaggle.json ~\/.kaggle\n!ls -lha kaggle.json\n!chmod 600 ~\/.kaggle\/kaggle.json","a07a37ab":"! kaggle competitions download -c taxi","05f9a9d1":"!unzip taxi.zip","f6615d25":"import torch\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport random\nimport numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler","645e697a":"device = 'cuda' if torch.cuda.is_available() else 'cpu'\n\nrandom.seed(777)\ntorch.manual_seed(777)\nif device == 'cuda':\n      torch.cuda.manual_seed_all(777)","e2ffebd0":"train = pd.read_csv('train.csv')\ntest = pd.read_csv('test.csv')","dc426628":"cab_type = {\"Uber\":0, \"Lyft\":1}\n\ntrain['cab_type']= train['cab_type'].map(cab_type)\ntest['cab_type']= test['cab_type'].map(cab_type)","8cb2794d":"summary_mapping = {\" Clear \":0,\" Drizzle \":1,\" Foggy \":2,\" Light Rain \":3,\" Mostly Cloudy \":4,\" Overcast \":5,\" Partly Cloudy \":6,\" Possible Drizzle \":7,\" Rain \":8}\n\ntrain['short_summary'] = train['short_summary'].map(summary_mapping)\ntest['short_summary'] = test['short_summary'].map(summary_mapping)","e933fe2c":"icon_mapping = {\" clear-day \":0,\" clear-night \":1,\" cloudy \":2,\" fog \":3,\" partly-cloudy-day \":4,\" partly-cloudy-night \":5,\" rain \":6}\n\ntrain['icon'] = train['icon'].map(icon_mapping)\ntest['icon'] = test['icon'].map(icon_mapping)","09cc0f3c":"x_data = train.loc[0:,\"cab_type\":\"precipIntensityMax\"]\ny_data = train.loc[0:,\"price\"]\n\nx_data = np.array(x_data)\ny_data = np.array(y_data)\nscaler = MinMaxScaler()\n\nx_data = scaler.fit_transform(x_data)\nx_train = torch.FloatTensor(x_data).to(device)\ny_train = torch.FloatTensor(y_data).to(device).reshape(-1,1)\n\nprint(x_train[:5])\nprint(x_train.shape)\nprint(y_train[:5])\nprint(y_train.shape)","380b7047":"x_test = test.loc[0:,\"cab_type\":]\nx_test = np.array(x_test)\nx_test = scaler.transform(x_test)\nx_test = torch.FloatTensor(x_test).to(device)\n\nx_test[:3]","4630de62":"learning_rate = 5e-3\ntraining_epochs = 500\nbatch_size =50","2452cae3":"train_dataset = torch.utils.data.TensorDataset(x_train, y_train)\n\ndata_loader = torch.utils.data.DataLoader(dataset=train_dataset,\n                                          batch_size=batch_size,\n                                          shuffle=True,\n                                          drop_last=True)","9c6c4470":"linear1=torch.nn.Linear(19,19,bias=True)\nlinear3=torch.nn.Linear(19,1,bias=True)\ndropout=torch.nn.Dropout(p=0.3)\nrelu= torch.nn.LeakyReLU()","4cd09290":"torch.nn.init.kaiming_uniform_(linear1.weight)\ntorch.nn.init.kaiming_uniform_(linear3.weight)","716caee2":"model = torch.nn.Sequential(linear1,relu,dropout,\n                            linear3).to(device)","34fc2e72":"loss = torch.nn.MSELoss().to(device)\noptimizer = optim.Adam(model.parameters(),lr = learning_rate)","653884b0":"total_batch = len(data_loader)\n\nfor epoch in range(training_epochs):\n    avg_cost = 0\n\n    for X, Y in data_loader:\n\n        X = X.to(device)\n        Y = Y.to(device)\n\n        # \uadf8\ub798\ub514\uc5b8\ud2b8 \ucd08\uae30\ud654\n        optimizer.zero_grad()\n        # Forward \uacc4\uc0b0\n        hypothesis = model(X)\n        # Error \uacc4\uc0b0\n        cost = loss(hypothesis, Y)\n        # Backparopagation\n        cost.backward()\n        # \uac00\uc911\uce58 \uac31\uc2e0\n        optimizer.step()\n\n        # \ud3c9\uade0 Error \uacc4\uc0b0\n        avg_cost += cost \/ total_batch\n        \n    if(epoch%20 == 0):    \n          print('Epoch:', '%04d' % (epoch + 1), 'cost =', '{:.9f}'.format(avg_cost))\n\nprint('Learning finished')","387b0a5e":"x_test = test.loc[0:,\"cab_type\":]\nx_test = np.array(x_test)\nx_test = scaler.transform(x_test)\nx_test = torch.FloatTensor(x_test).to(device)\n\nx_test[:3]","282baf57":"model(x_train)","72c348ae":"with torch.no_grad():\n\n    x_test=np.array(x_test.cpu())\n    x_test=torch.from_numpy(x_test).float().to(device)\n    predict=model(x_test)","29b08abd":"correct_prediction = predict.cpu().numpy().reshape(-1,1)","3025bb23":"for i in range(len(predict)):\n      result['price'][i]=predict[i].item()","2b52d46d":"result['price'] = result['price'].astype(int)","56cbad64":"result.to_csv('submit.csv', index=False)","b06227da":"\ub098\uba38\uc9c0\ub294 \uacf5\uaca9\ubc1b\uc740 \ucf54\ub4dc\ub97c \ub2e4\uc2dc \uc0ac\uc6a9\ud558\uc600\ub2e4.","a8503858":"## \uacf5\uaca9\ubc1b\uc740 \ucf54\ub4dc\uc640\uc758 \ucc28\uc774\uc810\n\n- \ud65c\uc131\ud654 \ud568\uc218\ub97c relu -> LeakyReLU\ub85c \ubcc0\uacbd\n- \ucd08\uae30\ud654 \ubc29\ubc95\uc744 kaiming_uniform_\uc73c\ub85c \ubcc0\uacbd"}}