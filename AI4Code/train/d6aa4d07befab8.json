{"cell_type":{"b7373293":"code","64595e5e":"code","04d45d52":"code","13274e80":"code","ff6a1ec0":"code","f8d3e485":"code","51c4785f":"code","06ebc2f5":"code","b5e85f12":"code","4d939052":"markdown","8d844320":"markdown","21c7108a":"markdown","51a6b477":"markdown","c2d95b1e":"markdown","c1a44f61":"markdown","18eb6003":"markdown","41751c96":"markdown","82553176":"markdown","f4e1e9bb":"markdown","611cf3db":"markdown","d09adbca":"markdown","9c46dace":"markdown","1189c417":"markdown","400ed689":"markdown","3cf91887":"markdown","1ba7981a":"markdown","42b75bc0":"markdown"},"source":{"b7373293":"'''Libraries to manipulate data'''\nimport numpy as np\nimport pandas as pd\nimport os\nimport math\nimport copy\nimport glob\nimport random\nfrom scipy import stats\n\n'''Libraries for Data Visualization'''\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.express as px\nimport plotly.graph_objs as go \nfrom plotly.colors import n_colors\nfrom plotly.subplots import make_subplots\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nimport plotly.figure_factory as ff\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n\n'''Load NFL Special Teams data'''\ntracking2020 = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2020.csv')\ntracking2019 = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2019.csv')\ntracking2018 = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2018.csv')\n\nplays = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/plays.csv')\nplayers = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/players.csv')\ngames = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/games.csv')\nscoutingData = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/PFFScoutingData.csv')\n                           ","64595e5e":"'''Define auxiliary functions to compute the developed metrics'''\ndef getDistance(x1, y1, x2, y2, squared=False): \n    if squared == False:\n        euclideanDistance = math.sqrt((y2-y1)**2 + (x2-x1)**2)\n    else:\n        euclideanDistance = (y2-y1)**2 + (x2-x1)**2\n    return euclideanDistance\n\ndef getDefendingTeam(trackingData_byPlay):\n    gameId = trackingData_byPlay['gameId'].reset_index(drop=True)[0]\n    playId = trackingData_byPlay['playId'].reset_index(drop=True)[0]\n    kickerId = plays[plays['playId'] == playId][plays['gameId'] == gameId]['kickerId'].reset_index(drop=True)[0]\n    nonreturningTeam = trackingData_byPlay[trackingData_byPlay['nflId'] == kickerId]['team'].reset_index(drop=True)[0]\n    if nonreturningTeam == \"away\":\n        returningTeam = \"home\"\n    if nonreturningTeam == \"home\":\n        returningTeam = \"away\"\n    return returningTeam\n\ndef detectReturner(trackingData_byPlay):\n    if plays[plays['playId'] == trackingData_byPlay['playId'].reset_index(drop=True)[0]][plays['gameId'] == trackingData_byPlay['gameId'].reset_index(drop=True)[0]]['specialTeamsPlayType'].reset_index(drop=True)[0] == 'Punt':\n        event = 'punt_received'\n    if plays[plays['playId'] == trackingData_byPlay['playId'].reset_index(drop=True)[0]][plays['gameId'] == trackingData_byPlay['gameId'].reset_index(drop=True)[0]]['specialTeamsPlayType'].reset_index(drop=True)[0] == 'Kickoff':\n        event = 'kick_received'\n    trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['event'] == event]\n    if len(trackingData_byPlay['x']) == 0:\n        return None\n    distances = []\n    players = []\n    for player in trackingData_byPlay[trackingData_byPlay['team'] != 'football']['nflId']:\n        player_data = trackingData_byPlay[trackingData_byPlay['nflId'] == player]\n        football_data = trackingData_byPlay[trackingData_byPlay['team'] == 'football']\n        dist = getDistance(player_data['x'].reset_index(drop=True)[0], player_data['y'].reset_index(drop=True)[0], football_data['x'].reset_index(drop=True)[0], football_data['y'].reset_index(drop=True)[0])\n        distances.append(dist)\n        players.append(player)\n    returner = players[distances.index(min(distances))]\n    return returner\n\ndef getReturnStart(trackingData_byPlay, team):\n    trackingData_byPlay = trackingData_byPlay.reset_index(drop=True)\n    maxFrames = max(trackingData_byPlay['frameId'])\n    returnerId = detectReturner(trackingData_byPlay)\n    if returnerId == None:\n        return None, None\n    for frameId in range(1, maxFrames):\n        try:\n            distance = getDistance(trackingData_byPlay[trackingData_byPlay['frameId'] == frameId][trackingData_byPlay['team'] == 'football']['x'].reset_index(drop=True)[0], trackingData_byPlay[trackingData_byPlay['frameId'] == frameId][trackingData_byPlay['team'] == 'football']['y'].reset_index(drop=True)[0], trackingData_byPlay[trackingData_byPlay['frameId'] == frameId][trackingData_byPlay['nflId'] == returnerId][trackingData_byPlay['team'] == team]['x'].reset_index(drop=True)[0], trackingData_byPlay[trackingData_byPlay['frameId'] == frameId][trackingData_byPlay['nflId'] == returnerId][trackingData_byPlay['team'] == team]['y'].reset_index(drop=True)[0])\n        except KeyError:\n            return None, None\n        if distance < 1:\n            returnStart = frameId\n            break\n    try:\n        framesAfterStart = maxFrames - returnStart\n    except:\n        return None, None\n    return returnStart, framesAfterStart\n    \ndef computeMRI(trackingData_byPlay, team):\n    returnStart, framesAfterStart = getReturnStart(trackingData_byPlay, team)\n    if returnStart == None:\n        return None\n    returnerId = detectReturner(trackingData_byPlay)\n    trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['team'] == team][trackingData_byPlay['nflId'] != returnerId]\n    ResponsivenessIndices = []\n    if framesAfterStart < 15:\n        return None\n    else:\n        trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['frameId'] >= returnStart]\n        for player in trackingData_byPlay['displayName'].unique():\n            trackingData_byPlay_player = trackingData_byPlay[trackingData_byPlay['displayName'] == player]\n            ResponsivenessIndices.append(max(trackingData_byPlay_player['a']))\n    MRI = sum(ResponsivenessIndices) \/ len(ResponsivenessIndices)\n    return MRI\n\ndef computeMPI_MPSI(trackingData_byPlay, team, frames_batch=5, frames_limit=50):\n    returnStart, framesAfterStart = getReturnStart(trackingData_byPlay, team)\n    if returnStart == None:\n        return None, None\n    returnerId = detectReturner(trackingData_byPlay)\n    trackingData_byPlay_ballcarrier = trackingData_byPlay[trackingData_byPlay['nflId'] == returnerId]\n    trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['nflId'] != returnerId]\n    ProximityIndices = []\n    PositioningSuitabilityIndices = []\n    if framesAfterStart < 15:\n        return None, None\n    else:\n        trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['frameId'] >= returnStart + 10]\n        interval = frames_batch\n        for frame in trackingData_byPlay['frameId']:\n            if frame - (returnStart + 10) > frames_limit:\n                break\n            interval += 1\n            if interval < frames_batch:\n                continue\n            '''Compute Proximity Index per time frame'''\n            trackingData_byPlay_framed = trackingData_byPlay[trackingData_byPlay['frameId'] == frame]\n            centroidOpponents = {}\n            combinations = [] #store for MPSI\n            for player in trackingData_byPlay_framed[trackingData_byPlay_framed['team'] == team]['displayName']:\n                trackingData_byPlay_framed_player = trackingData_byPlay_framed[trackingData_byPlay_framed['displayName'] == player]\n                distances = []\n                players = []\n                for opponentPlayer in trackingData_byPlay_framed[trackingData_byPlay_framed['team'] != team][trackingData_byPlay_framed['team'] != 'football']['displayName'].unique():\n                    trackingData_byPlay_framed_opponent = trackingData_byPlay_framed[trackingData_byPlay_framed['displayName'] == opponentPlayer]\n                    distances.append(getDistance(trackingData_byPlay_framed_player['x'].reset_index(drop=True)[0], trackingData_byPlay_framed_player['y'].reset_index(drop=True)[0], trackingData_byPlay_framed_opponent['x'].reset_index(drop=True)[0], trackingData_byPlay_framed_opponent['y'].reset_index(drop=True)[0]))\n                    players.append(trackingData_byPlay_framed_opponent['displayName'].reset_index(drop=True)[0])\n                covered = players[distances.index(min(distances))]\n                if covered in centroidOpponents:\n                    centroidOpponents[covered].append(min(distances))\n                else:\n                    centroidOpponents[covered] = [min(distances)]\n                combinations.append((players[distances.index(min(distances))], player))\n            byCluster = []\n            for covered in centroidOpponents:\n                byCluster.append(sum(centroidOpponents[covered]) \/ len(centroidOpponents[covered]))\n            ProximityIndices.append(sum(byCluster) \/ len(byCluster))\n            '''Compute Positioning Suitability Index per time frame'''\n            trackingData_byPlay_ballcarrier_framed = trackingData_byPlay_ballcarrier[trackingData_byPlay_ballcarrier['frameId'] == frame]\n            X_Pb = trackingData_byPlay_ballcarrier_framed['x'].reset_index(drop=True)[0]\n            Y_Pb = trackingData_byPlay_ballcarrier_framed['y'].reset_index(drop=True)[0]\n            X_Pbtsigma = X_Pb + math.sin(trackingData_byPlay_ballcarrier_framed['dir'].reset_index(drop=True)[0])\n            Y_Pbtsigma = Y_Pb + math.cos(trackingData_byPlay_ballcarrier_framed['dir'].reset_index(drop=True)[0])\n            PSI = []\n            CoveredPlayers = []\n            for combination in combinations:\n                Pk = trackingData_byPlay_framed[trackingData_byPlay_framed['displayName'] == combination[0]]\n                X_Pk = Pk['x'].reset_index(drop=True)[0]\n                Y_Pk = Pk['y'].reset_index(drop=True)[0]\n                Pr = trackingData_byPlay_framed[trackingData_byPlay_framed['displayName'] == combination[1]]\n                X_Pr = Pr['x'].reset_index(drop=True)[0]\n                Y_Pr = Pr['y'].reset_index(drop=True)[0]\n                cosine = (getDistance(X_Pk,Y_Pk,X_Pr,Y_Pr,squared=True)+getDistance(X_Pb,Y_Pb,X_Pr,Y_Pr,squared=True)-getDistance(X_Pb,Y_Pb,X_Pk,Y_Pk,squared=True))\/(2*(getDistance(X_Pk,Y_Pk,X_Pr,Y_Pr)*getDistance(X_Pb,Y_Pb,X_Pr,Y_Pr)))\n                if cosine > 1 and cosine < 1.2:\n                    cosine = 1\n                if cosine < -1 and cosine > -1.2:\n                    cosine = -1\n                PSI_Degrees = math.degrees(math.acos(cosine))\n                PSI.append(PSI_Degrees)\n                CoveredPlayers.append(combination[0])\n            PositioningSuitabilityIndices.append(sum(PSI) \/ len(PSI))\n            interval = 0\n    MPI = sum(ProximityIndices) \/ len(ProximityIndices)\n    MPSI = sum(PositioningSuitabilityIndices) \/ len(PositioningSuitabilityIndices)\n    \n    interval = frames_batch\n    store = []\n    \n    return MPI, MPSI\n            \ndef buildMAI(df, team):\n    MRI = computeMRI(df, team)\n    MPI, MPSI = computeMPI_MPSI(df, team)\n    \n    if MRI == None or MPI == None or MPSI == None:\n        return None, None, None, None\n    MAI = 0 #####\n    return MAI, MRI, MPI, MPSI #####\n\ndef ComputeAndStoreMAI_byPlay(trackingData, playId):\n    gameId = trackingData['gameId'].reset_index(drop=True)[0]\n    \n    homeAbbr = games[games['gameId'] == gameId]['homeTeamAbbr'].reset_index(drop=True)[0]\n    visitorAbbr = games[games['gameId'] == gameId]['visitorTeamAbbr'].reset_index(drop=True)[0]\n    \n    trackingData_byPlay = trackingData[trackingData['playId']== playId]\n    MAI, MRI, MPI, MPSI = buildMAI(trackingData_byPlay, getDefendingTeam(trackingData_byPlay))\n    YardsByPlay = plays[plays['playId']==playId][plays['gameId']==gameId]['kickReturnYardage'].reset_index(drop=True)[0]\n    return MAI, MRI, MPI, MPSI, YardsByPlay, getDefendingTeam(trackingData_byPlay), visitorAbbr, homeAbbr\n","04d45d52":"#2020\ngames_rawMetrics2020 = pd.read_csv(\"..\/input\/nfl-2022-processed-data\/games_stored2020.csv\")\n\ngamma_ = 0.2\nlambda_ = 0.45\nphi_ = 0.35\n\nminmaxMetrics2018_2019_2020 = {'MaxMRI': 6.7540000000000004,\n 'MinMRI': 1.5370000000000001,\n 'MaxMPI': 11.658249870954279,\n 'MinMPI': 0.8690253143061738,\n 'MaxMPSI': 131.28043201108832,\n 'MinMPSI': 27.789299614347524}\n\nminmaxMetrics2020 = {'MaxMRI': 0.0,\n 'MinMRI': 9999.0,\n 'MaxMPI': 0.0,\n 'MinMPI': 9999.0,\n 'MaxMPSI': 0.0,\n 'MinMPSI': 9999.0}\n\nfor game in games_rawMetrics2020['games']:\n    game_Strings = game[2:-2].split(\"], [\")\n    if len(game_Strings) <= 1:\n        continue\n    for playString in game_Strings:\n        play = playString[1:-1].split(\", \")\n        if play[1] == \"None\" or play[4] == \"nan\":\n            continue\n        if float(play[1]) > minmaxMetrics2020['MaxMRI']:\n            minmaxMetrics2020['MaxMRI'] = float(play[1])\n        if float(play[1]) < minmaxMetrics2020['MinMRI']:\n            minmaxMetrics2020['MinMRI'] = float(play[1])\n        if float(play[2]) > minmaxMetrics2020['MaxMPI']:\n            minmaxMetrics2020['MaxMPI'] = float(play[2])\n        if float(play[2]) < minmaxMetrics2020['MinMPI']:\n            minmaxMetrics2020['MinMPI'] = float(play[2])\n        if float(play[3]) > minmaxMetrics2020['MaxMPSI']:\n            minmaxMetrics2020['MaxMPSI'] = float(play[3])\n        if float(play[3]) < minmaxMetrics2020['MinMPSI']:\n            minmaxMetrics2020['MinMPSI'] = float(play[3])\n            \nMAI_byTeam = {}\nMAI_byPlay = []\ngameCount = 0\ngamesToSkip = []\ngamesToSkip_counter = 0\nplaysToSkip = []\nplaysToSkip_counter = 0\nfor game in games_rawMetrics2020['games']:\n    game_Strings = game[2:-2].split(\"], [\")\n    if len(game_Strings) <= 1:\n        gamesToSkip.append(gamesToSkip_counter)\n        gamesToSkip_counter += 1\n        continue\n    game_Plays_adjusted = []\n    gamesToSkip_counter += 1\n    for playString in game_Strings:\n        play = playString[1:-1].split(\", \")\n        if play[1] == \"None\" or play[4] == \"nan\":\n            playsToSkip.append(playsToSkip_counter)\n            playsToSkip_counter += 1\n            continue\n        playsToSkip_counter += 1\n        nMRI = round((float(play[1]) - minmaxMetrics2018_2019_2020['MinMRI']) \/ (minmaxMetrics2018_2019_2020['MaxMRI'] - minmaxMetrics2018_2019_2020['MinMRI']), 3)\n        nMPI = round((float(play[2]) - minmaxMetrics2018_2019_2020['MinMPI']) \/ (minmaxMetrics2018_2019_2020['MaxMPI'] - minmaxMetrics2018_2019_2020['MinMPI']), 3)\n        nMPSI = round((float(play[3]) - minmaxMetrics2018_2019_2020['MinMPSI']) \/ (minmaxMetrics2018_2019_2020['MaxMPSI'] - minmaxMetrics2018_2019_2020['MinMPSI']), 3)\n        MAI = round(gamma_*nMRI + lambda_*nMPSI + phi_*(1 - nMPI), 3)\n\n        game_Plays_adjusted.append([MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]])\n        MAI_byPlay.append((MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]))\n    \nGameIDs = []\nPlayIDs = []\ncounter1 = 0\ncounter2 = 0\nfor gameId in games[games['season']==2020]['gameId']:\n    ReturnIDs = plays[plays['specialTeamsResult'] == 'Return'][['playId','gameId']]\n    if counter1 in gamesToSkip:\n        counter1 += 1\n        continue\n    counter1 += 1\n    for playId in ReturnIDs[ReturnIDs['gameId'] == gameId]['playId']:\n        if counter2 in playsToSkip:\n            counter2 += 1\n            continue\n        if plays[plays['playId'] == playId][plays['gameId'] == gameId]['specialTeamsResult'].reset_index(drop=True)[0] != 'Return': #take only Kickoff and Punt with Return outcome\n            counter2 += 1\n            continue\n        counter2 += 1\n        GameIDs.append(gameId)\n        PlayIDs.append(playId)\n        \nMAI_byPlay_df = pd.DataFrame(MAI_byPlay, columns=['MAI','MRI','MPI','MPSI','YardsGained','ReturningTeam','AwayTeam','HomeTeam'])\nMAI_byPlay_df['gameId'] = GameIDs\nMAI_byPlay_df['playId'] = PlayIDs\n\n#_____________________________________\n#2019\ngames_rawMetrics2019 = pd.read_csv(\"..\/input\/nfl-2022-processed-data\/games_stored2019.csv\")\n\nminmaxMetrics2019 = {'MaxMRI': 0.0,\n 'MinMRI': 9999.0,\n 'MaxMPI': 0.0,\n 'MinMPI': 9999.0,\n 'MaxMPSI': 0.0,\n 'MinMPSI': 9999.0}\n\nfor game in games_rawMetrics2019['games']:\n    game_Strings = game[2:-2].split(\"], [\")\n    if len(game_Strings) <= 1:\n        continue\n    for playString in game_Strings:\n        play = playString[1:-1].split(\", \")\n        if play[1] == \"None\" or play[4] == \"nan\":\n            continue\n        if float(play[1]) > minmaxMetrics2019['MaxMRI']:\n            minmaxMetrics2019['MaxMRI'] = float(play[1])\n        if float(play[1]) < minmaxMetrics2019['MinMRI']:\n            minmaxMetrics2019['MinMRI'] = float(play[1])\n        if float(play[2]) > minmaxMetrics2019['MaxMPI']:\n            minmaxMetrics2019['MaxMPI'] = float(play[2])\n        if float(play[2]) < minmaxMetrics2019['MinMPI']:\n            minmaxMetrics2019['MinMPI'] = float(play[2])\n        if float(play[3]) > minmaxMetrics2019['MaxMPSI']:\n            minmaxMetrics2019['MaxMPSI'] = float(play[3])\n        if float(play[3]) < minmaxMetrics2019['MinMPSI']:\n            minmaxMetrics2019['MinMPSI'] = float(play[3])\n            \nMAI_byTeam = {}\nMAI_byPlay2019 = []\ngameCount = 0\ngamesToSkip = []\ngamesToSkip_counter = 0\nplaysToSkip = []\nplaysToSkip_counter = 0\nfor game in games_rawMetrics2019['games']:\n    game_Strings = game[2:-2].split(\"], [\")\n    if len(game_Strings) <= 1:\n        gamesToSkip.append(gamesToSkip_counter)\n        gamesToSkip_counter += 1\n        continue\n    game_Plays_adjusted = []\n    gamesToSkip_counter += 1\n    for playString in game_Strings:\n        play = playString[1:-1].split(\", \")\n        if play[1] == \"None\" or play[4] == \"nan\":\n            playsToSkip.append(playsToSkip_counter)\n            playsToSkip_counter += 1\n            continue\n        playsToSkip_counter += 1\n        nMRI = round((float(play[1]) - minmaxMetrics2018_2019_2020['MinMRI']) \/ (minmaxMetrics2018_2019_2020['MaxMRI'] - minmaxMetrics2018_2019_2020['MinMRI']), 3)\n        nMPI = round((float(play[2]) - minmaxMetrics2018_2019_2020['MinMPI']) \/ (minmaxMetrics2018_2019_2020['MaxMPI'] - minmaxMetrics2018_2019_2020['MinMPI']), 3)\n        nMPSI = round((float(play[3]) - minmaxMetrics2018_2019_2020['MinMPSI']) \/ (minmaxMetrics2018_2019_2020['MaxMPSI'] - minmaxMetrics2018_2019_2020['MinMPSI']), 3)\n        MAI = round(gamma_*nMRI + lambda_*nMPSI + phi_*(1 - nMPI), 3)\n\n        game_Plays_adjusted.append([MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]])\n        MAI_byPlay2019.append((MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]))\n    \nGameIDs = []\nPlayIDs = []\ncounter1 = 0\ncounter2 = 0\nfor gameId in games[games['season']==2019]['gameId']:\n    ReturnIDs = plays[plays['specialTeamsResult'] == 'Return'][['playId','gameId']]\n    if counter1 in gamesToSkip:\n        counter1 += 1\n        continue\n    counter1 += 1\n    for playId in ReturnIDs[ReturnIDs['gameId'] == gameId]['playId']:\n        if counter2 in playsToSkip:\n            counter2 += 1\n            continue\n        if plays[plays['playId'] == playId][plays['gameId'] == gameId]['specialTeamsResult'].reset_index(drop=True)[0] != 'Return': #take only Kickoff and Punt with Return outcome\n            counter2 += 1\n            continue\n        counter2 += 1\n        GameIDs.append(gameId)\n        PlayIDs.append(playId)\n        \nMAI_byPlay_df2019 = pd.DataFrame(MAI_byPlay2019, columns=['MAI','MRI','MPI','MPSI','YardsGained','ReturningTeam','AwayTeam','HomeTeam'])\nMAI_byPlay_df2019['gameId'] = GameIDs\nMAI_byPlay_df2019['playId'] = PlayIDs\n\n\n#_____________________________________\n#2018\ngames_rawMetrics2018 = pd.read_csv(\"..\/input\/nfl-2022-processed-data\/games_stored2018.csv\")\n\nminmaxMetrics2018 = {'MaxMRI': 0.0,\n 'MinMRI': 9999.0,\n 'MaxMPI': 0.0,\n 'MinMPI': 9999.0,\n 'MaxMPSI': 0.0,\n 'MinMPSI': 9999.0}\n\nfor game in games_rawMetrics2018['games']:\n    game_Strings = game[2:-2].split(\"], [\")\n    if len(game_Strings) <= 1:\n        continue\n    for playString in game_Strings:\n        play = playString[1:-1].split(\", \")\n        if play[1] == \"None\" or play[4] == \"nan\":\n            continue\n        if float(play[1]) > minmaxMetrics2018['MaxMRI']:\n            minmaxMetrics2018['MaxMRI'] = float(play[1])\n        if float(play[1]) < minmaxMetrics2018['MinMRI']:\n            minmaxMetrics2018['MinMRI'] = float(play[1])\n        if float(play[2]) > minmaxMetrics2018['MaxMPI']:\n            minmaxMetrics2018['MaxMPI'] = float(play[2])\n        if float(play[2]) < minmaxMetrics2018['MinMPI']:\n            minmaxMetrics2018['MinMPI'] = float(play[2])\n        if float(play[3]) > minmaxMetrics2018['MaxMPSI']:\n            minmaxMetrics2018['MaxMPSI'] = float(play[3])\n        if float(play[3]) < minmaxMetrics2018['MinMPSI']:\n            minmaxMetrics2018['MinMPSI'] = float(play[3])\n            \nMAI_byTeam = {}\nMAI_byPlay2018 = []\ngameCount = 0\ngamesToSkip = []\ngamesToSkip_counter = 0\nplaysToSkip = []\nplaysToSkip_counter = 0\nfor game in games_rawMetrics2018['games']:\n    game_Strings = game[2:-2].split(\"], [\")\n    if len(game_Strings) <= 1:\n        gamesToSkip.append(gamesToSkip_counter)\n        gamesToSkip_counter += 1\n        continue\n    game_Plays_adjusted = []\n    gamesToSkip_counter += 1\n    for playString in game_Strings:\n        play = playString[1:-1].split(\", \")\n        if play[1] == \"None\" or play[4] == \"nan\":\n            playsToSkip.append(playsToSkip_counter)\n            playsToSkip_counter += 1\n            continue\n        playsToSkip_counter += 1\n        nMRI = round((float(play[1]) - minmaxMetrics2018_2019_2020['MinMRI']) \/ (minmaxMetrics2018_2019_2020['MaxMRI'] - minmaxMetrics2018_2019_2020['MinMRI']), 3)\n        nMPI = round((float(play[2]) - minmaxMetrics2018_2019_2020['MinMPI']) \/ (minmaxMetrics2018_2019_2020['MaxMPI'] - minmaxMetrics2018_2019_2020['MinMPI']), 3)\n        nMPSI = round((float(play[3]) - minmaxMetrics2018_2019_2020['MinMPSI']) \/ (minmaxMetrics2018_2019_2020['MaxMPSI'] - minmaxMetrics2018_2019_2020['MinMPSI']), 3)\n        MAI = round(gamma_*nMRI + lambda_*nMPSI + phi_*(1 - nMPI), 3)\n\n        game_Plays_adjusted.append([MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]])\n        MAI_byPlay2018.append((MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]))\n    \nGameIDs = []\nPlayIDs = []\ncounter1 = 0\ncounter2 = 0\nfor gameId in games[games['season']==2018]['gameId']:\n    ReturnIDs = plays[plays['specialTeamsResult'] == 'Return'][['playId','gameId']]\n    if counter1 in gamesToSkip:\n        counter1 += 1\n        continue\n    counter1 += 1\n    for playId in ReturnIDs[ReturnIDs['gameId'] == gameId]['playId']:\n        if counter2 in playsToSkip:\n            counter2 += 1\n            continue\n        if plays[plays['playId'] == playId][plays['gameId'] == gameId]['specialTeamsResult'].reset_index(drop=True)[0] != 'Return': #take only Kickoff and Punt with Return outcome\n            counter2 += 1\n            continue\n        counter2 += 1\n        GameIDs.append(gameId)\n        PlayIDs.append(playId)\n        \nMAI_byPlay_df2018 = pd.DataFrame(MAI_byPlay2018, columns=['MAI','MRI','MPI','MPSI','YardsGained','ReturningTeam','AwayTeam','HomeTeam'])\nMAI_byPlay_df2018['gameId'] = GameIDs\nMAI_byPlay_df2018['playId'] = PlayIDs","13274e80":"'''Statistical Tests and Distribution Plots - MRI'''\nhighValue = MAI_byPlay_df[MAI_byPlay_df['MRI'] >= 0.575]\nlowValue = MAI_byPlay_df[MAI_byPlay_df['MRI'] < 0.575]\n\nhighValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MRI'] >= 0.575]\nlowValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MRI'] < 0.575]\n\nhighValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MRI'] >= 0.575]\nlowValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MRI'] < 0.575]\n\nalpha = 0.05\n\nstat, p = stats.ttest_ind(highValue['YardsGained'], lowValue['YardsGained'], equal_var=False)\nif p > alpha:\n    outcome = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome = 'Test Outcome:<br>Different distributions'\nif p < 0.001:\n    p = \"<0.0001\"\n    \nstat2019, p2019 = stats.ttest_ind(highValue2019['YardsGained'], lowValue2019['YardsGained'], equal_var=False)\nif p2019 > alpha:\n    outcome2019 = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome2019 = 'Test Outcome:<br>Different distributions'\nif p2019 < 0.001:\n    p2019 = \"<0.0001\"\nelse:\n    p2019 = round(p2019, 3)\n    \nstat2018, p2018 = stats.ttest_ind(highValue2018['YardsGained'], lowValue2018['YardsGained'], equal_var=False)\nif p2018 > alpha:\n    outcome2018 = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome2018 = 'Test Outcome:<br>Different distributions'\nif p2018 < 0.001:\n    p2018 = \"<0.0001\"\nelse:\n    p2018 = round(p2018, 3)\n    \nhighValue2 = pd.DataFrame()\nhighValue2['YardsGained'] = highValue['YardsGained']\nhighValue2['MRI'] = 'High'\nlowValue2 = pd.DataFrame()\nlowValue2['YardsGained'] = lowValue['YardsGained']\nlowValue2['MRI'] = 'Low'\n\nhighValue2019_2 = pd.DataFrame()\nhighValue2019_2['YardsGained'] = highValue2019['YardsGained']\nhighValue2019_2['MRI'] = 'High'\nlowValue2019_2 = pd.DataFrame()\nlowValue2019_2['YardsGained'] = lowValue2019['YardsGained']\nlowValue2019_2['MRI'] = 'Low'\n\nhighValue2018_2 = pd.DataFrame()\nhighValue2018_2['YardsGained'] = highValue2018['YardsGained']\nhighValue2018_2['MRI'] = 'High'\nlowValue2018_2 = pd.DataFrame()\nlowValue2018_2['YardsGained'] = lowValue2018['YardsGained']\nlowValue2018_2['MRI'] = 'Low'\n\nMRI_plays = pd.concat([highValue2, lowValue2])\nMRI_plays2019 = pd.concat([highValue2019_2, lowValue2019_2])\nMRI_plays2018 = pd.concat([highValue2018_2, lowValue2018_2])\n\nbp1 = px.box(MRI_plays, x='MRI', y=\"YardsGained\")\nbp1.data[0].marker.color = 'black'\n\nbp2 = px.box(MRI_plays2019, x='MRI', y=\"YardsGained\")\nbp2.data[0].marker.color = 'black'\n\nbp3 = px.box(MRI_plays2018, x='MRI', y=\"YardsGained\")\nbp3.data[0].marker.color = 'black'\n\nridge = px.violin(MRI_plays, x='YardsGained', y='MRI', orientation='h')\nridge2 = px.violin(MRI_plays2019, x='YardsGained', y='MRI', orientation='h')\nridge3 = px.violin(MRI_plays2018, x='YardsGained', y='MRI', orientation='h')\n\nridge.data[0].marker.color = 'black'\nridge.update_traces(side=\"positive\", width=4)\nridge2.data[0].marker.color = 'black'\nridge2.update_traces(side=\"positive\", width=4)\nridge3.data[0].marker.color = 'black'\nridge3.update_traces(side=\"positive\", width=4)\n\nfig = make_subplots(rows=3, cols=3,\n                   specs=[\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}]\n                   ],\n    )\n\nfig.add_trace(bp1.data[0], row=1, col=2)\nfig.add_trace(ridge.data[0], row=1, col=3)\n\nfig.add_trace(bp2.data[0], row=2, col=2)\nfig.add_trace(ridge2.data[0], row=2, col=3)\n\nfig.add_trace(bp3.data[0], row=3, col=2)\nfig.add_trace(ridge3.data[0], row=3, col=3)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2020<\/b><br>Two-sample T-test:<br>- Statistics={round(stat, 3)};<br>- p-value={p};<br><b>{outcome}<\/b>\",\n    textposition=[\"middle center\"],\n    textfont=dict(size=12,color=\"black\")),row=1, col=1)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2019<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2019, 3)};<br>- p-value={p2019};<br><b>{outcome2019}<\/b>\",\n    textposition=\"middle center\",\n    textfont=dict(size=12,color=\"black\")),row=2, col=1)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2018<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2018, 3)};<br>- p-value={p2018};<br><b>{outcome2018}<\/b>\",\n    textposition=\"middle center\",\n    textfont=dict(size=12,color=\"black\")),row=3, col=1)\n\nfig.update_layout(\n    title={\n        'text': \"Yards Gained from Return - High MRI vs Low MRI\",\n        'y':0.95,\n        'x':0.5,\n        'xanchor': 'center',\n        'yanchor': 'top'}, \n    height=800,\n    showlegend=False,\n    template='plotly_white',\n    )\nfig.layout.yaxis2.title = 'Yards Gained'\nfig.layout.xaxis3.title = 'Yards Gained'\nfig.layout.yaxis3.title = 'MRI'\nfig.layout.yaxis5.title = 'Yards Gained'\nfig.layout.xaxis6.title = 'Yards Gained'\nfig.layout.yaxis6.title = 'MRI'\nfig.layout.yaxis8.title = 'Yards Gained'\nfig.layout.xaxis9.title = 'Yards Gained'\nfig.layout.yaxis9.title = 'MRI'\n\nfig.layout.yaxis.showgrid = False\nfig.layout.xaxis.showgrid = False\nfig.layout.yaxis.zeroline = False\nfig.layout.xaxis.zeroline = False\nfig.layout.yaxis.visible = False\nfig.layout.xaxis.visible = False\nfig.layout.yaxis4.showgrid = False\nfig.layout.xaxis4.showgrid = False\nfig.layout.yaxis4.zeroline = False\nfig.layout.xaxis4.zeroline = False\nfig.layout.yaxis4.visible = False\nfig.layout.xaxis4.visible = False\nfig.layout.yaxis7.showgrid = False\nfig.layout.xaxis7.showgrid = False\nfig.layout.yaxis7.zeroline = False\nfig.layout.xaxis7.zeroline = False\nfig.layout.yaxis7.visible = False\nfig.layout.xaxis7.visible = False\n\nfig.show()","ff6a1ec0":"'''Statistical Tests and Distribution Plots - MPI'''\nhighValue = MAI_byPlay_df[MAI_byPlay_df['MPI'] >= 0.125]\nlowValue = MAI_byPlay_df[MAI_byPlay_df['MPI'] < 0.125]\n\nhighValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MPI'] >= 0.125]\nlowValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MPI'] < 0.125]\n\nhighValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MPI'] >= 0.125]\nlowValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MPI'] < 0.125]\n\nalpha = 0.05\n\nstat, p = stats.ttest_ind(highValue['YardsGained'], lowValue['YardsGained'], equal_var=False)\nif p > alpha:\n    outcome = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome = 'Test Outcome:<br>Different distributions'\nif p < 0.001:\n    p = \"<0.0001\"\n    \nstat2019, p2019 = stats.ttest_ind(highValue2019['YardsGained'], lowValue2019['YardsGained'], equal_var=False)\nif p2019 > alpha:\n    outcome2019 = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome2019 = 'Test Outcome:<br>Different distributions'\nif p2019 < 0.001:\n    p2019 = \"<0.0001\"\nelse:\n    p2019 = round(p2019, 3)\n    \nstat2018, p2018 = stats.ttest_ind(highValue2018['YardsGained'], lowValue2018['YardsGained'], equal_var=False)\nif p2018 > alpha:\n    outcome2018 = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome2018 = 'Test Outcome:<br>Different distributions'\nif p2018 < 0.001:\n    p2018 = \"<0.0001\"\nelse:\n    p2018 = round(p2018, 3)\n    \nhighValue2 = pd.DataFrame()\nhighValue2['YardsGained'] = highValue['YardsGained']\nhighValue2['MPI'] = 'High'\nlowValue2 = pd.DataFrame()\nlowValue2['YardsGained'] = lowValue['YardsGained']\nlowValue2['MPI'] = 'Low'\n\nhighValue2019_2 = pd.DataFrame()\nhighValue2019_2['YardsGained'] = highValue2019['YardsGained']\nhighValue2019_2['MPI'] = 'High'\nlowValue2019_2 = pd.DataFrame()\nlowValue2019_2['YardsGained'] = lowValue2019['YardsGained']\nlowValue2019_2['MPI'] = 'Low'\n\nhighValue2018_2 = pd.DataFrame()\nhighValue2018_2['YardsGained'] = highValue2018['YardsGained']\nhighValue2018_2['MPI'] = 'High'\nlowValue2018_2 = pd.DataFrame()\nlowValue2018_2['YardsGained'] = lowValue2018['YardsGained']\nlowValue2018_2['MPI'] = 'Low'\n\nMPI_plays = pd.concat([highValue2, lowValue2])\nMPI_plays2019 = pd.concat([highValue2019_2, lowValue2019_2])\nMPI_plays2018 = pd.concat([highValue2018_2, lowValue2018_2])\n\nbp1 = px.box(MPI_plays, x='MPI', y=\"YardsGained\")\nbp1.data[0].marker.color = 'black'\n\nbp2 = px.box(MPI_plays2019, x='MPI', y=\"YardsGained\")\nbp2.data[0].marker.color = 'black'\n\nbp3 = px.box(MPI_plays2018, x='MPI', y=\"YardsGained\")\nbp3.data[0].marker.color = 'black'\n\nridge = px.violin(MPI_plays, x='YardsGained', y='MPI', orientation='h')\nridge2 = px.violin(MPI_plays2019, x='YardsGained', y='MPI', orientation='h')\nridge3 = px.violin(MPI_plays2018, x='YardsGained', y='MPI', orientation='h')\n\nridge.data[0].marker.color = 'black'\nridge.update_traces(side=\"positive\", width=4)\nridge2.data[0].marker.color = 'black'\nridge2.update_traces(side=\"positive\", width=4)\nridge3.data[0].marker.color = 'black'\nridge3.update_traces(side=\"positive\", width=4)\n\nfig = make_subplots(rows=3, cols=3,\n                   specs=[\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}]\n                   ],\n    )\n\nfig.add_trace(bp1.data[0], row=1, col=2)\nfig.add_trace(ridge.data[0], row=1, col=3)\n\nfig.add_trace(bp2.data[0], row=2, col=2)\nfig.add_trace(ridge2.data[0], row=2, col=3)\n\nfig.add_trace(bp3.data[0], row=3, col=2)\nfig.add_trace(ridge3.data[0], row=3, col=3)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2020<\/b><br>Two-sample T-test:<br>- Statistics={round(stat, 3)};<br>- p-value={p};<br><b>{outcome}<\/b>\",\n    textposition=[\"middle center\"],\n    textfont=dict(size=12,color=\"black\")),row=1, col=1)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2019<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2019, 3)};<br>- p-value={p2019};<br><b>{outcome2019}<\/b>\",\n    textposition=\"middle center\",\n    textfont=dict(size=12,color=\"black\")),row=2, col=1)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2018<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2018, 3)};<br>- p-value={p2018};<br><b>{outcome2018}<\/b>\",\n    textposition=\"middle center\",\n    textfont=dict(size=12,color=\"black\")),row=3, col=1)\n\nfig.update_layout(\n    title={\n        'text': \"Yards Gained from Return - High MPI vs Low MPI\",\n        'y':0.95,\n        'x':0.5,\n        'xanchor': 'center',\n        'yanchor': 'top'}, \n    height=800,\n    showlegend=False,\n    template='plotly_white',\n    )\nfig.layout.yaxis2.title = 'Yards Gained'\nfig.layout.xaxis3.title = 'Yards Gained'\nfig.layout.yaxis3.title = 'MPI'\nfig.layout.yaxis5.title = 'Yards Gained'\nfig.layout.xaxis6.title = 'Yards Gained'\nfig.layout.yaxis6.title = 'MPI'\nfig.layout.yaxis8.title = 'Yards Gained'\nfig.layout.xaxis9.title = 'Yards Gained'\nfig.layout.yaxis9.title = 'MPI'\n\nfig.layout.yaxis.showgrid = False\nfig.layout.xaxis.showgrid = False\nfig.layout.yaxis.zeroline = False\nfig.layout.xaxis.zeroline = False\nfig.layout.yaxis.visible = False\nfig.layout.xaxis.visible = False\nfig.layout.yaxis4.showgrid = False\nfig.layout.xaxis4.showgrid = False\nfig.layout.yaxis4.zeroline = False\nfig.layout.xaxis4.zeroline = False\nfig.layout.yaxis4.visible = False\nfig.layout.xaxis4.visible = False\nfig.layout.yaxis7.showgrid = False\nfig.layout.xaxis7.showgrid = False\nfig.layout.yaxis7.zeroline = False\nfig.layout.xaxis7.zeroline = False\nfig.layout.yaxis7.visible = False\nfig.layout.xaxis7.visible = False\n\nfig.show()","f8d3e485":"'''Statistical Tests and Distribution Plots - MPSI'''\nhighValue = MAI_byPlay_df[MAI_byPlay_df['MPSI'] >= 0.575]\nlowValue = MAI_byPlay_df[MAI_byPlay_df['MPSI'] < 0.575]\n\nhighValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MPSI'] >= 0.575]\nlowValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MPSI'] < 0.575]\n\nhighValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MPSI'] >= 0.575]\nlowValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MPSI'] < 0.575]\n\nalpha = 0.05\n\nstat, p = stats.ttest_ind(highValue['YardsGained'], lowValue['YardsGained'], equal_var=False)\nif p > alpha:\n    outcome = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome = 'Test Outcome:<br>Different distributions'\nif p < 0.001:\n    p = \"<0.0001\"\n    \nstat2019, p2019 = stats.ttest_ind(highValue2019['YardsGained'], lowValue2019['YardsGained'], equal_var=False)\nif p2019 > alpha:\n    outcome2019 = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome2019 = 'Test Outcome:<br>Different distributions'\nif p2019 < 0.001:\n    p2019 = \"<0.0001\"\nelse:\n    p2019 = round(p2019, 3)\n    \nstat2018, p2018 = stats.ttest_ind(highValue2018['YardsGained'], lowValue2018['YardsGained'], equal_var=False)\nif p2018 > alpha:\n    outcome2018 = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome2018 = 'Test Outcome:<br>Different distributions'\nif p2018 < 0.001:\n    p2018 = \"<0.0001\"\nelse:\n    p2018 = round(p2018, 3)\n    \nhighValue2 = pd.DataFrame()\nhighValue2['YardsGained'] = highValue['YardsGained']\nhighValue2['MPSI'] = 'High'\nlowValue2 = pd.DataFrame()\nlowValue2['YardsGained'] = lowValue['YardsGained']\nlowValue2['MPSI'] = 'Low'\n\nhighValue2019_2 = pd.DataFrame()\nhighValue2019_2['YardsGained'] = highValue2019['YardsGained']\nhighValue2019_2['MPSI'] = 'High'\nlowValue2019_2 = pd.DataFrame()\nlowValue2019_2['YardsGained'] = lowValue2019['YardsGained']\nlowValue2019_2['MPSI'] = 'Low'\n\nhighValue2018_2 = pd.DataFrame()\nhighValue2018_2['YardsGained'] = highValue2018['YardsGained']\nhighValue2018_2['MPSI'] = 'High'\nlowValue2018_2 = pd.DataFrame()\nlowValue2018_2['YardsGained'] = lowValue2018['YardsGained']\nlowValue2018_2['MPSI'] = 'Low'\n\nMPSI_plays = pd.concat([highValue2, lowValue2])\nMPSI_plays2019 = pd.concat([highValue2019_2, lowValue2019_2])\nMPSI_plays2018 = pd.concat([highValue2018_2, lowValue2018_2])\n\nbp1 = px.box(MPSI_plays, x='MPSI', y=\"YardsGained\")\nbp1.data[0].marker.color = 'black'\n\nbp2 = px.box(MPSI_plays2019, x='MPSI', y=\"YardsGained\")\nbp2.data[0].marker.color = 'black'\n\nbp3 = px.box(MPSI_plays2018, x='MPSI', y=\"YardsGained\")\nbp3.data[0].marker.color = 'black'\n\nridge = px.violin(MPSI_plays, x='YardsGained', y='MPSI', orientation='h')\nridge2 = px.violin(MPSI_plays2019, x='YardsGained', y='MPSI', orientation='h')\nridge3 = px.violin(MPSI_plays2018, x='YardsGained', y='MPSI', orientation='h')\n\nridge.data[0].marker.color = 'black'\nridge.update_traces(side=\"positive\", width=4)\nridge2.data[0].marker.color = 'black'\nridge2.update_traces(side=\"positive\", width=4)\nridge3.data[0].marker.color = 'black'\nridge3.update_traces(side=\"positive\", width=4)\n\nfig = make_subplots(rows=3, cols=3,\n                   specs=[\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}]\n                   ],\n    )\n\nfig.add_trace(bp1.data[0], row=1, col=2)\nfig.add_trace(ridge.data[0], row=1, col=3)\n\nfig.add_trace(bp2.data[0], row=2, col=2)\nfig.add_trace(ridge2.data[0], row=2, col=3)\n\nfig.add_trace(bp3.data[0], row=3, col=2)\nfig.add_trace(ridge3.data[0], row=3, col=3)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2020<\/b><br>Two-sample T-test:<br>- Statistics={round(stat, 3)};<br>- p-value={p};<br><b>{outcome}<\/b>\",\n    textposition=[\"middle center\"],\n    textfont=dict(size=12,color=\"black\")),row=1, col=1)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2019<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2019, 3)};<br>- p-value={p2019};<br><b>{outcome2019}<\/b>\",\n    textposition=\"middle center\",\n    textfont=dict(size=12,color=\"black\")),row=2, col=1)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2018<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2018, 3)};<br>- p-value={p2018};<br><b>{outcome2018}<\/b>\",\n    textposition=\"middle center\",\n    textfont=dict(size=12,color=\"black\")),row=3, col=1)\n\nfig.update_layout(\n    title={\n        'text': \"Yards Gained from Return - High MPSI vs Low MPSI\",\n        'y':0.95,\n        'x':0.5,\n        'xanchor': 'center',\n        'yanchor': 'top'}, \n    height=800,\n    showlegend=False,\n    template='plotly_white',\n    )\nfig.layout.yaxis2.title = 'Yards Gained'\nfig.layout.xaxis3.title = 'Yards Gained'\nfig.layout.yaxis3.title = 'MPSI'\nfig.layout.yaxis5.title = 'Yards Gained'\nfig.layout.xaxis6.title = 'Yards Gained'\nfig.layout.yaxis6.title = 'MPSI'\nfig.layout.yaxis8.title = 'Yards Gained'\nfig.layout.xaxis9.title = 'Yards Gained'\nfig.layout.yaxis9.title = 'MPSI'\n\nfig.layout.yaxis.showgrid = False\nfig.layout.xaxis.showgrid = False\nfig.layout.yaxis.zeroline = False\nfig.layout.xaxis.zeroline = False\nfig.layout.yaxis.visible = False\nfig.layout.xaxis.visible = False\nfig.layout.yaxis4.showgrid = False\nfig.layout.xaxis4.showgrid = False\nfig.layout.yaxis4.zeroline = False\nfig.layout.xaxis4.zeroline = False\nfig.layout.yaxis4.visible = False\nfig.layout.xaxis4.visible = False\nfig.layout.yaxis7.showgrid = False\nfig.layout.xaxis7.showgrid = False\nfig.layout.yaxis7.zeroline = False\nfig.layout.xaxis7.zeroline = False\nfig.layout.yaxis7.visible = False\nfig.layout.xaxis7.visible = False\n\nfig.show()","51c4785f":"'''Statistical Tests and Distribution Plots - MAI'''\nhighValue = MAI_byPlay_df[MAI_byPlay_df['MAI'] >= 0.675]\nlowValue = MAI_byPlay_df[MAI_byPlay_df['MAI'] < 0.675]\n\nhighValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MAI'] >= 0.675]\nlowValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MAI'] < 0.675]\n\nhighValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MAI'] >= 0.675]\nlowValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MAI'] < 0.675]\n\nalpha = 0.05\n\nstat, p = stats.ttest_ind(highValue['YardsGained'], lowValue['YardsGained'], equal_var=False)\nif p > alpha:\n    outcome = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome = 'Test Outcome:<br>Different distributions'\nif p < 0.001:\n    p = \"<0.0001\"\n    \nstat2019, p2019 = stats.ttest_ind(highValue2019['YardsGained'], lowValue2019['YardsGained'], equal_var=False)\nif p2019 > alpha:\n    outcome2019 = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome2019 = 'Test Outcome:<br>Different distributions'\nif p2019 < 0.001:\n    p2019 = \"<0.0001\"\nelse:\n    p2019 = round(p2019, 3)\n    \nstat2018, p2018 = stats.ttest_ind(highValue2018['YardsGained'], lowValue2018['YardsGained'], equal_var=False)\nif p2018 > alpha:\n    outcome2018 = 'Test Outcome:<br>Same distributions'\nelse:\n    outcome2018 = 'Test Outcome:<br>Different distributions'\nif p2018 < 0.001:\n    p2018 = \"<0.0001\"\nelse:\n    p2018 = round(p2018, 3)\n    \nhighValue2 = pd.DataFrame()\nhighValue2['YardsGained'] = highValue['YardsGained']\nhighValue2['MAI'] = 'High'\nlowValue2 = pd.DataFrame()\nlowValue2['YardsGained'] = lowValue['YardsGained']\nlowValue2['MAI'] = 'Low'\n\nhighValue2019_2 = pd.DataFrame()\nhighValue2019_2['YardsGained'] = highValue2019['YardsGained']\nhighValue2019_2['MAI'] = 'High'\nlowValue2019_2 = pd.DataFrame()\nlowValue2019_2['YardsGained'] = lowValue2019['YardsGained']\nlowValue2019_2['MAI'] = 'Low'\n\nhighValue2018_2 = pd.DataFrame()\nhighValue2018_2['YardsGained'] = highValue2018['YardsGained']\nhighValue2018_2['MAI'] = 'High'\nlowValue2018_2 = pd.DataFrame()\nlowValue2018_2['YardsGained'] = lowValue2018['YardsGained']\nlowValue2018_2['MAI'] = 'Low'\n\nMAI_plays = pd.concat([highValue2, lowValue2])\nMAI_plays2019 = pd.concat([highValue2019_2, lowValue2019_2])\nMAI_plays2018 = pd.concat([highValue2018_2, lowValue2018_2])\n\nbp1 = px.box(MAI_plays, x='MAI', y=\"YardsGained\")\nbp1.data[0].marker.color = 'black'\n\nbp2 = px.box(MAI_plays2019, x='MAI', y=\"YardsGained\")\nbp2.data[0].marker.color = 'black'\n\nbp3 = px.box(MAI_plays2018, x='MAI', y=\"YardsGained\")\nbp3.data[0].marker.color = 'black'\n\nridge = px.violin(MAI_plays, x='YardsGained', y='MAI', orientation='h')\nridge2 = px.violin(MAI_plays2019, x='YardsGained', y='MAI', orientation='h')\nridge3 = px.violin(MAI_plays2018, x='YardsGained', y='MAI', orientation='h')\n\nridge.data[0].marker.color = 'black'\nridge.update_traces(side=\"positive\", width=4)\nridge2.data[0].marker.color = 'black'\nridge2.update_traces(side=\"positive\", width=4)\nridge3.data[0].marker.color = 'black'\nridge3.update_traces(side=\"positive\", width=4)\n\nfig = make_subplots(rows=3, cols=3,\n                   specs=[\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n    [{},{\"type\": \"box\"}, {\"type\":\"violin\"}]\n                   ],\n    )\n\nfig.add_trace(bp1.data[0], row=1, col=2)\nfig.add_trace(ridge.data[0], row=1, col=3)\n\nfig.add_trace(bp2.data[0], row=2, col=2)\nfig.add_trace(ridge2.data[0], row=2, col=3)\n\nfig.add_trace(bp3.data[0], row=3, col=2)\nfig.add_trace(ridge3.data[0], row=3, col=3)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2020<\/b><br>Two-sample T-test:<br>- Statistics={round(stat, 3)};<br>- p-value={p};<br><b>{outcome}<\/b>\",\n    textposition=[\"middle center\"],\n    textfont=dict(size=12,color=\"black\")),row=1, col=1)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2019<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2019, 3)};<br>- p-value={p2019};<br><b>{outcome2019}<\/b>\",\n    textposition=\"middle center\",\n    textfont=dict(size=12,color=\"black\")),row=2, col=1)\n\nfig.add_trace(go.Scatter(\n    x=[1],y=[1],mode=\"text\",\n    text=f\"<b>Season 2018<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2018, 3)};<br>- p-value={p2018};<br><b>{outcome2018}<\/b>\",\n    textposition=\"middle center\",\n    textfont=dict(size=12,color=\"black\")),row=3, col=1)\n\nfig.update_layout(\n    title={\n        'text': \"Yards Gained from Return - High MAI vs Low MAI\",\n        'y':0.95,\n        'x':0.5,\n        'xanchor': 'center',\n        'yanchor': 'top'}, \n    height=800,\n    showlegend=False,\n    template='plotly_white',\n    )\nfig.layout.yaxis2.title = 'Yards Gained'\nfig.layout.xaxis3.title = 'Yards Gained'\nfig.layout.yaxis3.title = 'MAI'\nfig.layout.yaxis5.title = 'Yards Gained'\nfig.layout.xaxis6.title = 'Yards Gained'\nfig.layout.yaxis6.title = 'MAI'\nfig.layout.yaxis8.title = 'Yards Gained'\nfig.layout.xaxis9.title = 'Yards Gained'\nfig.layout.yaxis9.title = 'MAI'\n\nfig.layout.yaxis.showgrid = False\nfig.layout.xaxis.showgrid = False\nfig.layout.yaxis.zeroline = False\nfig.layout.xaxis.zeroline = False\nfig.layout.yaxis.visible = False\nfig.layout.xaxis.visible = False\nfig.layout.yaxis4.showgrid = False\nfig.layout.xaxis4.showgrid = False\nfig.layout.yaxis4.zeroline = False\nfig.layout.xaxis4.zeroline = False\nfig.layout.yaxis4.visible = False\nfig.layout.xaxis4.visible = False\nfig.layout.yaxis7.showgrid = False\nfig.layout.xaxis7.showgrid = False\nfig.layout.yaxis7.zeroline = False\nfig.layout.xaxis7.zeroline = False\nfig.layout.yaxis7.visible = False\nfig.layout.xaxis7.visible = False\n\nfig.show()","06ebc2f5":"'''Return kicking plays sorted by Yards Gained'''\n#'''\ncolors = n_colors('rgb(0, 255, 255)', 'rgb(0, 0, 255)', 76, colortype='rgb')\n\nMAI_byPlay_df_Sorted = MAI_byPlay_df.sort_values(by=['MAI'], ascending=False).reset_index()\nMAI_byPlay_df_Sorted = MAI_byPlay_df_Sorted.drop([row for row in range(20, (len(MAI_byPlay_df_Sorted['MAI'])- 20))])\n\nMAI = MAI_byPlay_df_Sorted['MAI']\nMRI = MAI_byPlay_df_Sorted['MRI']\nMPI = MAI_byPlay_df_Sorted['MPI']\nMPSI = MAI_byPlay_df_Sorted['MPSI']\nYardsGained = MAI_byPlay_df_Sorted['YardsGained']\nteam = MAI_byPlay_df_Sorted['ReturningTeam']\nvisitorTeam = MAI_byPlay_df_Sorted['AwayTeam']\nhomeTeam = MAI_byPlay_df_Sorted['HomeTeam']\ngameId = MAI_byPlay_df_Sorted['gameId']\nplayId = MAI_byPlay_df_Sorted['playId']\n\nfig = go.Figure(data=[go.Table(\n  header=dict(\n    values=['<b>MAI<\/b>', '<b>MRI<\/b>', '<b>MPI<\/b>', '<b>MPSI<\/b>', '<b>Yards<br>Gained<\/b>', '<b>Returning<br>Team<\/b>', '<b>Away<br>Team<\/b>',\n            '<b>Home<br>Team<\/b>', '<b>GameID<\/b>', '<b>PlayID<\/b>'],\n    line_color='black', fill_color='lime',\n    align='center',font=dict(color='black', size=12)\n  ),\n  columnwidth=[1,1,1,1,1,1,1,1,1.5,1],\n  cells=dict(\n    values=[MAI, MRI, MPI, MPSI, YardsGained, team, visitorTeam, homeTeam, gameId, playId],\n    line_color=['black','black','black','black','black','black','black','black','black','black'],\n    fill_color=['white','white','white','white',np.array(colors)[(YardsGained).astype(int)],'white','white','white','white','white'],\n    align='center', font=dict(color='black', size=12)\n    ))\n])\n\nfig.update_layout(\n    title={\n        'text': \"\",\n        'y':0.95,\n        'x':0.5,\n        'xanchor': 'center',\n        'yanchor': 'top'},    \n    height=1100)\n\nfig.show()\n#'''","b5e85f12":"# '''Import Libraries to manipulate data'''\n# import numpy as np\n# import pandas as pd\n# import os\n# import math\n# import copy\n# import glob\n# import random\n# from scipy import stats\n\n# '''Import Libraries for Data Visualization'''\n# import matplotlib.pyplot as plt\n# import seaborn as sns\n# import plotly.express as px\n# import plotly.graph_objs as go \n# from plotly.colors import n_colors\n# from plotly.subplots import make_subplots\n# from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\n# import plotly.figure_factory as ff\n\n# import warnings\n# warnings.filterwarnings(\"ignore\")\n\n# '''Load NFL Special Teams data'''\n\n# tracking2020 = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2020.csv')\n# tracking2019 = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2019.csv')\n# tracking2018 = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2018.csv')\n\n# plays = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/plays.csv')\n# players = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/players.csv')\n# games = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/games.csv')\n# scoutingData = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/PFFScoutingData.csv')\n                           \n# '''Define auxiliary functions to compute the developed metrics'''\n# def getDistance(x1, y1, x2, y2, squared=False): \n#     if squared == False:\n#         euclideanDistance = math.sqrt((y2-y1)**2 + (x2-x1)**2)\n#     else:\n#         euclideanDistance = (y2-y1)**2 + (x2-x1)**2\n#     return euclideanDistance\n\n# def getDefendingTeam(trackingData_byPlay):\n#     gameId = trackingData_byPlay['gameId'].reset_index(drop=True)[0]\n#     playId = trackingData_byPlay['playId'].reset_index(drop=True)[0]\n#     kickerId = plays[plays['playId'] == playId][plays['gameId'] == gameId]['kickerId'].reset_index(drop=True)[0]\n#     nonreturningTeam = trackingData_byPlay[trackingData_byPlay['nflId'] == kickerId]['team'].reset_index(drop=True)[0]\n#     if nonreturningTeam == \"away\":\n#         returningTeam = \"home\"\n#     if nonreturningTeam == \"home\":\n#         returningTeam = \"away\"\n#     return returningTeam\n\n# def detectReturner(trackingData_byPlay):\n#     if plays[plays['playId'] == trackingData_byPlay['playId'].reset_index(drop=True)[0]][plays['gameId'] == trackingData_byPlay['gameId'].reset_index(drop=True)[0]]['specialTeamsPlayType'].reset_index(drop=True)[0] == 'Punt':\n#         event = 'punt_received'\n#     if plays[plays['playId'] == trackingData_byPlay['playId'].reset_index(drop=True)[0]][plays['gameId'] == trackingData_byPlay['gameId'].reset_index(drop=True)[0]]['specialTeamsPlayType'].reset_index(drop=True)[0] == 'Kickoff':\n#         event = 'kick_received'\n#     trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['event'] == event]\n#     if len(trackingData_byPlay['x']) == 0:\n#         return None\n#     distances = []\n#     players = []\n#     for player in trackingData_byPlay[trackingData_byPlay['team'] != 'football']['nflId']:\n#         player_data = trackingData_byPlay[trackingData_byPlay['nflId'] == player]\n#         football_data = trackingData_byPlay[trackingData_byPlay['team'] == 'football']\n#         dist = getDistance(player_data['x'].reset_index(drop=True)[0], player_data['y'].reset_index(drop=True)[0], football_data['x'].reset_index(drop=True)[0], football_data['y'].reset_index(drop=True)[0])\n#         distances.append(dist)\n#         players.append(player)\n#     returner = players[distances.index(min(distances))]\n#     return returner\n\n# def getReturnStart(trackingData_byPlay, team):\n#     trackingData_byPlay = trackingData_byPlay.reset_index(drop=True)\n#     maxFrames = max(trackingData_byPlay['frameId'])\n#     returnerId = detectReturner(trackingData_byPlay)\n#     if returnerId == None:\n#         return None, None\n#     for frameId in range(1, maxFrames):\n#         try:\n#             distance = getDistance(trackingData_byPlay[trackingData_byPlay['frameId'] == frameId][trackingData_byPlay['team'] == 'football']['x'].reset_index(drop=True)[0], trackingData_byPlay[trackingData_byPlay['frameId'] == frameId][trackingData_byPlay['team'] == 'football']['y'].reset_index(drop=True)[0], trackingData_byPlay[trackingData_byPlay['frameId'] == frameId][trackingData_byPlay['nflId'] == returnerId][trackingData_byPlay['team'] == team]['x'].reset_index(drop=True)[0], trackingData_byPlay[trackingData_byPlay['frameId'] == frameId][trackingData_byPlay['nflId'] == returnerId][trackingData_byPlay['team'] == team]['y'].reset_index(drop=True)[0])\n#         except KeyError:\n#             return None, None\n#         if distance < 1:\n#             returnStart = frameId\n#             break\n#     try:\n#         framesAfterStart = maxFrames - returnStart\n#     except:\n#         return None, None\n#     return returnStart, framesAfterStart\n    \n# def computeMRI(trackingData_byPlay, team):\n#     returnStart, framesAfterStart = getReturnStart(trackingData_byPlay, team)\n#     if returnStart == None:\n#         return None\n#     returnerId = detectReturner(trackingData_byPlay)\n#     trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['team'] == team][trackingData_byPlay['nflId'] != returnerId]\n#     ResponsivenessIndices = []\n#     if framesAfterStart < 15:\n#         return None\n#     else:\n#         trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['frameId'] >= returnStart]\n#         for player in trackingData_byPlay['displayName'].unique():\n#             trackingData_byPlay_player = trackingData_byPlay[trackingData_byPlay['displayName'] == player]\n#             ResponsivenessIndices.append(max(trackingData_byPlay_player['a']))\n#     MRI = sum(ResponsivenessIndices) \/ len(ResponsivenessIndices)\n#     return MRI\n\n# def computeMPI_MPSI(trackingData_byPlay, team, frames_batch=5, frames_limit=50):\n#     returnStart, framesAfterStart = getReturnStart(trackingData_byPlay, team)\n#     if returnStart == None:\n#         return None, None\n#     returnerId = detectReturner(trackingData_byPlay)\n#     trackingData_byPlay_ballcarrier = trackingData_byPlay[trackingData_byPlay['nflId'] == returnerId]\n#     trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['nflId'] != returnerId]\n#     ProximityIndices = []\n#     PositioningSuitabilityIndices = []\n#     if framesAfterStart < 15:\n#         return None, None\n#     else:\n#         trackingData_byPlay = trackingData_byPlay[trackingData_byPlay['frameId'] >= returnStart + 10]\n#         interval = frames_batch\n#         for frame in trackingData_byPlay['frameId']:\n#             if frame - (returnStart + 10) > frames_limit:\n#                 break\n#             interval += 1\n#             if interval < frames_batch:\n#                 continue\n#             '''Compute Proximity Index per time frame'''\n#             trackingData_byPlay_framed = trackingData_byPlay[trackingData_byPlay['frameId'] == frame]\n#             centroidOpponents = {}\n#             combinations = [] #store for MPSI\n#             for player in trackingData_byPlay_framed[trackingData_byPlay_framed['team'] == team]['displayName']:\n#                 trackingData_byPlay_framed_player = trackingData_byPlay_framed[trackingData_byPlay_framed['displayName'] == player]\n#                 distances = []\n#                 players = []\n#                 for opponentPlayer in trackingData_byPlay_framed[trackingData_byPlay_framed['team'] != team][trackingData_byPlay_framed['team'] != 'football']['displayName'].unique():\n#                     trackingData_byPlay_framed_opponent = trackingData_byPlay_framed[trackingData_byPlay_framed['displayName'] == opponentPlayer]\n#                     distances.append(getDistance(trackingData_byPlay_framed_player['x'].reset_index(drop=True)[0], trackingData_byPlay_framed_player['y'].reset_index(drop=True)[0], trackingData_byPlay_framed_opponent['x'].reset_index(drop=True)[0], trackingData_byPlay_framed_opponent['y'].reset_index(drop=True)[0]))\n#                     players.append(trackingData_byPlay_framed_opponent['displayName'].reset_index(drop=True)[0])\n#                 covered = players[distances.index(min(distances))]\n#                 if covered in centroidOpponents:\n#                     centroidOpponents[covered].append(min(distances))\n#                 else:\n#                     centroidOpponents[covered] = [min(distances)]\n#                 combinations.append((players[distances.index(min(distances))], player))\n#             byCluster = []\n#             for covered in centroidOpponents:\n#                 byCluster.append(sum(centroidOpponents[covered]) \/ len(centroidOpponents[covered]))\n#             ProximityIndices.append(sum(byCluster) \/ len(byCluster))\n#             '''Compute Positioning Suitability Index per time frame'''\n#             trackingData_byPlay_ballcarrier_framed = trackingData_byPlay_ballcarrier[trackingData_byPlay_ballcarrier['frameId'] == frame]\n#             X_Pb = trackingData_byPlay_ballcarrier_framed['x'].reset_index(drop=True)[0]\n#             Y_Pb = trackingData_byPlay_ballcarrier_framed['y'].reset_index(drop=True)[0]\n#             X_Pbtsigma = X_Pb + math.sin(trackingData_byPlay_ballcarrier_framed['dir'].reset_index(drop=True)[0])\n#             Y_Pbtsigma = Y_Pb + math.cos(trackingData_byPlay_ballcarrier_framed['dir'].reset_index(drop=True)[0])\n#             PSI = []\n#             CoveredPlayers = []\n#             for combination in combinations:\n#                 Pk = trackingData_byPlay_framed[trackingData_byPlay_framed['displayName'] == combination[0]]\n#                 X_Pk = Pk['x'].reset_index(drop=True)[0]\n#                 Y_Pk = Pk['y'].reset_index(drop=True)[0]\n#                 Pr = trackingData_byPlay_framed[trackingData_byPlay_framed['displayName'] == combination[1]]\n#                 X_Pr = Pr['x'].reset_index(drop=True)[0]\n#                 Y_Pr = Pr['y'].reset_index(drop=True)[0]\n#                 cosine = (getDistance(X_Pk,Y_Pk,X_Pr,Y_Pr,squared=True)+getDistance(X_Pb,Y_Pb,X_Pr,Y_Pr,squared=True)-getDistance(X_Pb,Y_Pb,X_Pk,Y_Pk,squared=True))\/(2*(getDistance(X_Pk,Y_Pk,X_Pr,Y_Pr)*getDistance(X_Pb,Y_Pb,X_Pr,Y_Pr)))\n#                 if cosine > 1 and cosine < 1.2:\n#                     cosine = 1\n#                 if cosine < -1 and cosine > -1.2:\n#                     cosine = -1\n#                 PSI_Degrees = math.degrees(math.acos(cosine))\n#                 PSI.append(PSI_Degrees)\n#                 CoveredPlayers.append(combination[0])\n#             PositioningSuitabilityIndices.append(sum(PSI) \/ len(PSI))\n#             interval = 0\n#     MPI = sum(ProximityIndices) \/ len(ProximityIndices)\n#     MPSI = sum(PositioningSuitabilityIndices) \/ len(PositioningSuitabilityIndices)\n    \n#     interval = frames_batch\n#     store = []\n    \n#     return MPI, MPSI\n            \n# def buildMAI(df, team):\n#     MRI = computeMRI(df, team)\n#     MPI, MPSI = computeMPI_MPSI(df, team)\n    \n#     if MRI == None or MPI == None or MPSI == None:\n#         return None, None, None, None\n#     MAI = 0 #####\n#     return MAI, MRI, MPI, MPSI #####\n\n# def ComputeAndStoreMAI_byPlay(trackingData, playId):\n#     gameId = trackingData['gameId'].reset_index(drop=True)[0]\n    \n#     homeAbbr = games[games['gameId'] == gameId]['homeTeamAbbr'].reset_index(drop=True)[0]\n#     visitorAbbr = games[games['gameId'] == gameId]['visitorTeamAbbr'].reset_index(drop=True)[0]\n    \n#     trackingData_byPlay = trackingData[trackingData['playId']== playId]\n#     MAI, MRI, MPI, MPSI = buildMAI(trackingData_byPlay, getDefendingTeam(trackingData_byPlay))\n#     YardsByPlay = plays[plays['playId']==playId][plays['gameId']==gameId]['kickReturnYardage'].reset_index(drop=True)[0]\n#     return MAI, MRI, MPI, MPSI, YardsByPlay, getDefendingTeam(trackingData_byPlay), visitorAbbr, homeAbbr\n\n# '''Store MRI, MPI, and MPSI for each play and each game in a csv file\n# Note: this has been applied for all seasons and stored in three csv files, one per season; the only private dataset of this notebook indeed \n# contains only data obtained by processing, using the following code, the nfl datasets.\n# '''\n# #2020\n# games_stored = [] #####\n# for gameId in games[games['season']==2020]['gameId']:\n#     ReturnIDs = plays[plays['specialTeamsResult'] == 'Return'][['playId','gameId']]\n\n#     trackingData = tracking2020[tracking2020['gameId'] == gameId]\n#     plays_stored = [] #####\n#     for playId in ReturnIDs[ReturnIDs['gameId'] == gameId]['playId']:\n#         if plays[plays['playId'] == playId][plays['gameId'] == gameId]['specialTeamsResult'].reset_index(drop=True)[0] != 'Return': #take only Kickoff and Punt with Return outcome\n#             continue\n#         MAI, MRI, MPI, MPSI, ReturnYardsGained, team, visitorTeam, homeTeam = ComputeAndStoreMAI_byPlay(trackingData, playId=playId)\n        \n#         plays_stored.append([MAI, MRI, MPI, MPSI, ReturnYardsGained, team, visitorTeam, homeTeam])#####\n        \n#         homeResults = plays[plays['playId'] == playId][plays['gameId'] == gameId]['preSnapHomeScore'].item()\n#         visitorResults = plays[plays['playId'] == playId][plays['gameId'] == gameId]['preSnapVisitorScore'].item()\n#     games_stored.append([plays_stored, homeResults, visitorResults])#####\n    \n# games_df_2020 = pd.DataFrame(games_stored, columns=['games','homeResults','visitorResults'])\n# games_df_2020.to_csv(\".\/games_stored2020.csv\", index=False)#####\n\n# #2019\n# games_stored = [] #####\n# for gameId in games[games['season']==2019]['gameId']:\n#     ReturnIDs = plays[plays['specialTeamsResult'] == 'Return'][['playId','gameId']]\n\n#     trackingData = tracking2019[tracking2019['gameId'] == gameId]\n#     plays_stored = [] #####\n#     for playId in ReturnIDs[ReturnIDs['gameId'] == gameId]['playId']:\n#         if plays[plays['playId'] == playId][plays['gameId'] == gameId]['specialTeamsResult'].reset_index(drop=True)[0] != 'Return': #take only Kickoff and Punt with Return outcome\n#             continue\n#         MAI, MRI, MPI, MPSI, ReturnYardsGained, team, visitorTeam, homeTeam = ComputeAndStoreMAI_byPlay(trackingData, playId=playId)\n        \n#         plays_stored.append([MAI, MRI, MPI, MPSI, ReturnYardsGained, team, visitorTeam, homeTeam])#####\n        \n#         homeResults = plays[plays['playId'] == playId][plays['gameId'] == gameId]['preSnapHomeScore'].item()\n#         visitorResults = plays[plays['playId'] == playId][plays['gameId'] == gameId]['preSnapVisitorScore'].item()\n#     games_stored.append([plays_stored, homeResults, visitorResults])#####\n    \n# games_df_2019 = pd.DataFrame(games_stored, columns=['games','homeResults','visitorResults'])\n# games_df_2019.to_csv(\".\/games_stored2019.csv\", index=False)#####\n\n# #2018\n# games_stored = [] #####\n# for gameId in games[games['season']==2018]['gameId']:\n#     ReturnIDs = plays[plays['specialTeamsResult'] == 'Return'][['playId','gameId']]\n\n#     trackingData = tracking2018[tracking2018['gameId'] == gameId]\n#     plays_stored = [] #####\n#     for playId in ReturnIDs[ReturnIDs['gameId'] == gameId]['playId']:\n#         if plays[plays['playId'] == playId][plays['gameId'] == gameId]['specialTeamsResult'].reset_index(drop=True)[0] != 'Return': #take only Kickoff and Punt with Return outcome\n#             continue\n#         MAI, MRI, MPI, MPSI, ReturnYardsGained, team, visitorTeam, homeTeam = ComputeAndStoreMAI_byPlay(trackingData, playId=playId)\n        \n#         plays_stored.append([MAI, MRI, MPI, MPSI, ReturnYardsGained, team, visitorTeam, homeTeam])#####\n        \n#         homeResults = plays[plays['playId'] == playId][plays['gameId'] == gameId]['preSnapHomeScore'].item()\n#         visitorResults = plays[plays['playId'] == playId][plays['gameId'] == gameId]['preSnapVisitorScore'].item()\n#     games_stored.append([plays_stored, homeResults, visitorResults])#####\n    \n# games_df_2018 = pd.DataFrame(games_stored, columns=['games','homeResults','visitorResults'])\n# games_df_2018.to_csv(\".\/games_stored2018.csv\", index=False)#####\n\n\n# '''Load the csv files of each season, process them and compute MAI for each play'''\n# #2020\n# games_rawMetrics2020 = pd.read_csv(\"..\/input\/nfl-2022-processed-data\/games_stored2020.csv\") # csv file for season 2020\n\n# gamma_ = 0.2\n# lambda_ = 0.45\n# phi_ = 0.35\n\n# minmaxMetrics2018_2019_2020 = {'MaxMRI': 6.7540000000000004, # obtained  by taking the min and max of each metric ever\n#  'MinMRI': 1.5370000000000001,                               # encountered in the three seasons from 2018 to 2020.\n#  'MaxMPI': 11.658249870954279,\n#  'MinMPI': 0.8690253143061738,\n#  'MaxMPSI': 131.28043201108832,\n#  'MinMPSI': 27.789299614347524}\n\n# minmaxMetrics2020 = {'MaxMRI': 0.0,\n#  'MinMRI': 9999.0,\n#  'MaxMPI': 0.0,\n#  'MinMPI': 9999.0,\n#  'MaxMPSI': 0.0,\n#  'MinMPSI': 9999.0}\n\n# for game in games_rawMetrics2020['games']:\n#     game_Strings = game[2:-2].split(\"], [\")\n#     if len(game_Strings) <= 1:\n#         continue\n#     for playString in game_Strings:\n#         play = playString[1:-1].split(\", \")\n#         if play[1] == \"None\" or play[4] == \"nan\":\n#             continue\n#         if float(play[1]) > minmaxMetrics2020['MaxMRI']:\n#             minmaxMetrics2020['MaxMRI'] = float(play[1])\n#         if float(play[1]) < minmaxMetrics2020['MinMRI']:\n#             minmaxMetrics2020['MinMRI'] = float(play[1])\n#         if float(play[2]) > minmaxMetrics2020['MaxMPI']:\n#             minmaxMetrics2020['MaxMPI'] = float(play[2])\n#         if float(play[2]) < minmaxMetrics2020['MinMPI']:\n#             minmaxMetrics2020['MinMPI'] = float(play[2])\n#         if float(play[3]) > minmaxMetrics2020['MaxMPSI']:\n#             minmaxMetrics2020['MaxMPSI'] = float(play[3])\n#         if float(play[3]) < minmaxMetrics2020['MinMPSI']:\n#             minmaxMetrics2020['MinMPSI'] = float(play[3])\n            \n# MAI_byTeam = {}\n# MAI_byPlay = []\n# gameCount = 0\n# gamesToSkip = []\n# gamesToSkip_counter = 0\n# playsToSkip = []\n# playsToSkip_counter = 0\n# for game in games_rawMetrics2020['games']:\n#     game_Strings = game[2:-2].split(\"], [\")\n#     if len(game_Strings) <= 1:\n#         gamesToSkip.append(gamesToSkip_counter)\n#         gamesToSkip_counter += 1\n#         continue\n#     game_Plays_adjusted = []\n#     gamesToSkip_counter += 1\n#     for playString in game_Strings:\n#         play = playString[1:-1].split(\", \")\n#         if play[1] == \"None\" or play[4] == \"nan\":\n#             playsToSkip.append(playsToSkip_counter)\n#             playsToSkip_counter += 1\n#             continue\n#         playsToSkip_counter += 1\n#         nMRI = round((float(play[1]) - minmaxMetrics2018_2019_2020['MinMRI']) \/ (minmaxMetrics2018_2019_2020['MaxMRI'] - minmaxMetrics2018_2019_2020['MinMRI']), 3)\n#         nMPI = round((float(play[2]) - minmaxMetrics2018_2019_2020['MinMPI']) \/ (minmaxMetrics2018_2019_2020['MaxMPI'] - minmaxMetrics2018_2019_2020['MinMPI']), 3)\n#         nMPSI = round((float(play[3]) - minmaxMetrics2018_2019_2020['MinMPSI']) \/ (minmaxMetrics2018_2019_2020['MaxMPSI'] - minmaxMetrics2018_2019_2020['MinMPSI']), 3)\n#         MAI = round(gamma_*nMRI + lambda_*nMPSI + phi_*(1 - nMPI), 3)\n\n#         game_Plays_adjusted.append([MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]])\n#         MAI_byPlay.append((MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]))\n    \n# GameIDs = []\n# PlayIDs = []\n# counter1 = 0\n# counter2 = 0\n# for gameId in games[games['season']==2020]['gameId']:\n#     ReturnIDs = plays[plays['specialTeamsResult'] == 'Return'][['playId','gameId']]\n#     if counter1 in gamesToSkip:\n#         counter1 += 1\n#         continue\n#     counter1 += 1\n#     for playId in ReturnIDs[ReturnIDs['gameId'] == gameId]['playId']:\n#         if counter2 in playsToSkip:\n#             counter2 += 1\n#             continue\n#         if plays[plays['playId'] == playId][plays['gameId'] == gameId]['specialTeamsResult'].reset_index(drop=True)[0] != 'Return': #take only Kickoff and Punt with Return outcome\n#             counter2 += 1\n#             continue\n#         counter2 += 1\n#         GameIDs.append(gameId)\n#         PlayIDs.append(playId)\n        \n# MAI_byPlay_df = pd.DataFrame(MAI_byPlay, columns=['MAI','MRI','MPI','MPSI','YardsGained','ReturningTeam','AwayTeam','HomeTeam'])\n# MAI_byPlay_df['gameId'] = GameIDs\n# MAI_byPlay_df['playId'] = PlayIDs\n\n# #_____________________________________\n# #2019\n# games_rawMetrics2019 = pd.read_csv(\"..\/input\/nfl-2022-processed-data\/games_stored2019.csv\") # csv file for season 2019\n\n# minmaxMetrics2019 = {'MaxMRI': 0.0,\n#  'MinMRI': 9999.0,\n#  'MaxMPI': 0.0,\n#  'MinMPI': 9999.0,\n#  'MaxMPSI': 0.0,\n#  'MinMPSI': 9999.0}\n\n# for game in games_rawMetrics2019['games']:\n#     game_Strings = game[2:-2].split(\"], [\")\n#     if len(game_Strings) <= 1:\n#         continue\n#     for playString in game_Strings:\n#         play = playString[1:-1].split(\", \")\n#         if play[1] == \"None\" or play[4] == \"nan\":\n#             continue\n#         if float(play[1]) > minmaxMetrics2019['MaxMRI']:\n#             minmaxMetrics2019['MaxMRI'] = float(play[1])\n#         if float(play[1]) < minmaxMetrics2019['MinMRI']:\n#             minmaxMetrics2019['MinMRI'] = float(play[1])\n#         if float(play[2]) > minmaxMetrics2019['MaxMPI']:\n#             minmaxMetrics2019['MaxMPI'] = float(play[2])\n#         if float(play[2]) < minmaxMetrics2019['MinMPI']:\n#             minmaxMetrics2019['MinMPI'] = float(play[2])\n#         if float(play[3]) > minmaxMetrics2019['MaxMPSI']:\n#             minmaxMetrics2019['MaxMPSI'] = float(play[3])\n#         if float(play[3]) < minmaxMetrics2019['MinMPSI']:\n#             minmaxMetrics2019['MinMPSI'] = float(play[3])\n            \n# MAI_byTeam = {}\n# MAI_byPlay2019 = []\n# gameCount = 0\n# gamesToSkip = []\n# gamesToSkip_counter = 0\n# playsToSkip = []\n# playsToSkip_counter = 0\n# for game in games_rawMetrics2019['games']:\n#     game_Strings = game[2:-2].split(\"], [\")\n#     if len(game_Strings) <= 1:\n#         gamesToSkip.append(gamesToSkip_counter)\n#         gamesToSkip_counter += 1\n#         continue\n#     game_Plays_adjusted = []\n#     gamesToSkip_counter += 1\n#     for playString in game_Strings:\n#         play = playString[1:-1].split(\", \")\n#         if play[1] == \"None\" or play[4] == \"nan\":\n#             playsToSkip.append(playsToSkip_counter)\n#             playsToSkip_counter += 1\n#             continue\n#         playsToSkip_counter += 1\n#         nMRI = round((float(play[1]) - minmaxMetrics2018_2019_2020['MinMRI']) \/ (minmaxMetrics2018_2019_2020['MaxMRI'] - minmaxMetrics2018_2019_2020['MinMRI']), 3)\n#         nMPI = round((float(play[2]) - minmaxMetrics2018_2019_2020['MinMPI']) \/ (minmaxMetrics2018_2019_2020['MaxMPI'] - minmaxMetrics2018_2019_2020['MinMPI']), 3)\n#         nMPSI = round((float(play[3]) - minmaxMetrics2018_2019_2020['MinMPSI']) \/ (minmaxMetrics2018_2019_2020['MaxMPSI'] - minmaxMetrics2018_2019_2020['MinMPSI']), 3)\n#         MAI = round(gamma_*nMRI + lambda_*nMPSI + phi_*(1 - nMPI), 3)\n\n#         game_Plays_adjusted.append([MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]])\n#         MAI_byPlay2019.append((MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]))\n    \n# GameIDs = []\n# PlayIDs = []\n# counter1 = 0\n# counter2 = 0\n# for gameId in games[games['season']==2019]['gameId']:\n#     ReturnIDs = plays[plays['specialTeamsResult'] == 'Return'][['playId','gameId']]\n#     if counter1 in gamesToSkip:\n#         counter1 += 1\n#         continue\n#     counter1 += 1\n#     for playId in ReturnIDs[ReturnIDs['gameId'] == gameId]['playId']:\n#         if counter2 in playsToSkip:\n#             counter2 += 1\n#             continue\n#         if plays[plays['playId'] == playId][plays['gameId'] == gameId]['specialTeamsResult'].reset_index(drop=True)[0] != 'Return': #take only Kickoff and Punt with Return outcome\n#             counter2 += 1\n#             continue\n#         counter2 += 1\n#         GameIDs.append(gameId)\n#         PlayIDs.append(playId)\n        \n# MAI_byPlay_df2019 = pd.DataFrame(MAI_byPlay2019, columns=['MAI','MRI','MPI','MPSI','YardsGained','ReturningTeam','AwayTeam','HomeTeam'])\n# MAI_byPlay_df2019['gameId'] = GameIDs\n# MAI_byPlay_df2019['playId'] = PlayIDs\n\n\n# #_____________________________________\n# #2018\n# games_rawMetrics2018 = pd.read_csv(\"..\/input\/nfl-2022-processed-data\/games_stored2018.csv\") # csv file for season 2018\n\n# minmaxMetrics2018 = {'MaxMRI': 0.0,\n#  'MinMRI': 9999.0,\n#  'MaxMPI': 0.0,\n#  'MinMPI': 9999.0,\n#  'MaxMPSI': 0.0,\n#  'MinMPSI': 9999.0}\n\n# for game in games_rawMetrics2018['games']:\n#     game_Strings = game[2:-2].split(\"], [\")\n#     if len(game_Strings) <= 1:\n#         continue\n#     for playString in game_Strings:\n#         play = playString[1:-1].split(\", \")\n#         if play[1] == \"None\" or play[4] == \"nan\":\n#             continue\n#         if float(play[1]) > minmaxMetrics2018['MaxMRI']:\n#             minmaxMetrics2018['MaxMRI'] = float(play[1])\n#         if float(play[1]) < minmaxMetrics2018['MinMRI']:\n#             minmaxMetrics2018['MinMRI'] = float(play[1])\n#         if float(play[2]) > minmaxMetrics2018['MaxMPI']:\n#             minmaxMetrics2018['MaxMPI'] = float(play[2])\n#         if float(play[2]) < minmaxMetrics2018['MinMPI']:\n#             minmaxMetrics2018['MinMPI'] = float(play[2])\n#         if float(play[3]) > minmaxMetrics2018['MaxMPSI']:\n#             minmaxMetrics2018['MaxMPSI'] = float(play[3])\n#         if float(play[3]) < minmaxMetrics2018['MinMPSI']:\n#             minmaxMetrics2018['MinMPSI'] = float(play[3])\n            \n# MAI_byTeam = {}\n# MAI_byPlay2018 = []\n# gameCount = 0\n# gamesToSkip = []\n# gamesToSkip_counter = 0\n# playsToSkip = []\n# playsToSkip_counter = 0\n# for game in games_rawMetrics2018['games']:\n#     game_Strings = game[2:-2].split(\"], [\")\n#     if len(game_Strings) <= 1:\n#         gamesToSkip.append(gamesToSkip_counter)\n#         gamesToSkip_counter += 1\n#         continue\n#     game_Plays_adjusted = []\n#     gamesToSkip_counter += 1\n#     for playString in game_Strings:\n#         play = playString[1:-1].split(\", \")\n#         if play[1] == \"None\" or play[4] == \"nan\":\n#             playsToSkip.append(playsToSkip_counter)\n#             playsToSkip_counter += 1\n#             continue\n#         playsToSkip_counter += 1\n#         nMRI = round((float(play[1]) - minmaxMetrics2018_2019_2020['MinMRI']) \/ (minmaxMetrics2018_2019_2020['MaxMRI'] - minmaxMetrics2018_2019_2020['MinMRI']), 3)\n#         nMPI = round((float(play[2]) - minmaxMetrics2018_2019_2020['MinMPI']) \/ (minmaxMetrics2018_2019_2020['MaxMPI'] - minmaxMetrics2018_2019_2020['MinMPI']), 3)\n#         nMPSI = round((float(play[3]) - minmaxMetrics2018_2019_2020['MinMPSI']) \/ (minmaxMetrics2018_2019_2020['MaxMPSI'] - minmaxMetrics2018_2019_2020['MinMPSI']), 3)\n#         MAI = round(gamma_*nMRI + lambda_*nMPSI + phi_*(1 - nMPI), 3)\n\n#         game_Plays_adjusted.append([MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]])\n#         MAI_byPlay2018.append((MAI, nMRI, nMPI, nMPSI, float(play[4]), play[5][1:-1], play[6][1:-1], play[7][1:]))\n    \n# GameIDs = []\n# PlayIDs = []\n# counter1 = 0\n# counter2 = 0\n# for gameId in games[games['season']==2018]['gameId']:\n#     ReturnIDs = plays[plays['specialTeamsResult'] == 'Return'][['playId','gameId']]\n#     if counter1 in gamesToSkip:\n#         counter1 += 1\n#         continue\n#     counter1 += 1\n#     for playId in ReturnIDs[ReturnIDs['gameId'] == gameId]['playId']:\n#         if counter2 in playsToSkip:\n#             counter2 += 1\n#             continue\n#         if plays[plays['playId'] == playId][plays['gameId'] == gameId]['specialTeamsResult'].reset_index(drop=True)[0] != 'Return': #take only Kickoff and Punt with Return outcome\n#             counter2 += 1\n#             continue\n#         counter2 += 1\n#         GameIDs.append(gameId)\n#         PlayIDs.append(playId)\n        \n# MAI_byPlay_df2018 = pd.DataFrame(MAI_byPlay2018, columns=['MAI','MRI','MPI','MPSI','YardsGained','ReturningTeam','AwayTeam','HomeTeam'])\n# MAI_byPlay_df2018['gameId'] = GameIDs\n# MAI_byPlay_df2018['playId'] = PlayIDs\n\n# '''Statistical Tests and Distribution Plots'''\n# '''Statistical Tests and Distribution Plots - MRI'''\n# highValue = MAI_byPlay_df[MAI_byPlay_df['MRI'] >= 0.575]\n# lowValue = MAI_byPlay_df[MAI_byPlay_df['MRI'] < 0.575]\n\n# highValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MRI'] >= 0.575]\n# lowValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MRI'] < 0.575]\n\n# highValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MRI'] >= 0.575]\n# lowValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MRI'] < 0.575]\n\n# alpha = 0.05\n\n# stat, p = stats.ttest_ind(highValue['YardsGained'], lowValue['YardsGained'], equal_var=False)\n# if p > alpha:\n#     outcome = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome = 'Test Outcome:<br>Different distributions'\n# if p < 0.001:\n#     p = \"<0.0001\"\n    \n# stat2019, p2019 = stats.ttest_ind(highValue2019['YardsGained'], lowValue2019['YardsGained'], equal_var=False)\n# if p2019 > alpha:\n#     outcome2019 = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome2019 = 'Test Outcome:<br>Different distributions'\n# if p2019 < 0.001:\n#     p2019 = \"<0.0001\"\n# else:\n#     p2019 = round(p2019, 3)\n    \n# stat2018, p2018 = stats.ttest_ind(highValue2018['YardsGained'], lowValue2018['YardsGained'], equal_var=False)\n# if p2018 > alpha:\n#     outcome2018 = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome2018 = 'Test Outcome:<br>Different distributions'\n# if p2018 < 0.001:\n#     p2018 = \"<0.0001\"\n# else:\n#     p2018 = round(p2018, 3)\n    \n# highValue2 = pd.DataFrame()\n# highValue2['YardsGained'] = highValue['YardsGained']\n# highValue2['MRI'] = 'High'\n# lowValue2 = pd.DataFrame()\n# lowValue2['YardsGained'] = lowValue['YardsGained']\n# lowValue2['MRI'] = 'Low'\n\n# highValue2019_2 = pd.DataFrame()\n# highValue2019_2['YardsGained'] = highValue2019['YardsGained']\n# highValue2019_2['MRI'] = 'High'\n# lowValue2019_2 = pd.DataFrame()\n# lowValue2019_2['YardsGained'] = lowValue2019['YardsGained']\n# lowValue2019_2['MRI'] = 'Low'\n\n# highValue2018_2 = pd.DataFrame()\n# highValue2018_2['YardsGained'] = highValue2018['YardsGained']\n# highValue2018_2['MRI'] = 'High'\n# lowValue2018_2 = pd.DataFrame()\n# lowValue2018_2['YardsGained'] = lowValue2018['YardsGained']\n# lowValue2018_2['MRI'] = 'Low'\n\n# MRI_plays = pd.concat([highValue2, lowValue2])\n# MRI_plays2019 = pd.concat([highValue2019_2, lowValue2019_2])\n# MRI_plays2018 = pd.concat([highValue2018_2, lowValue2018_2])\n\n# bp1 = px.box(MRI_plays, x='MRI', y=\"YardsGained\")\n# bp1.data[0].marker.color = 'black'\n\n# bp2 = px.box(MRI_plays2019, x='MRI', y=\"YardsGained\")\n# bp2.data[0].marker.color = 'black'\n\n# bp3 = px.box(MRI_plays2018, x='MRI', y=\"YardsGained\")\n# bp3.data[0].marker.color = 'black'\n\n# ridge = px.violin(MRI_plays, x='YardsGained', y='MRI', orientation='h')\n# ridge2 = px.violin(MRI_plays2019, x='YardsGained', y='MRI', orientation='h')\n# ridge3 = px.violin(MRI_plays2018, x='YardsGained', y='MRI', orientation='h')\n\n# ridge.data[0].marker.color = 'black'\n# ridge.update_traces(side=\"positive\", width=4)\n# ridge2.data[0].marker.color = 'black'\n# ridge2.update_traces(side=\"positive\", width=4)\n# ridge3.data[0].marker.color = 'black'\n# ridge3.update_traces(side=\"positive\", width=4)\n\n# fig = make_subplots(rows=3, cols=3,\n#                    specs=[\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}]\n#                    ],\n#     )\n\n# fig.add_trace(bp1.data[0], row=1, col=2)\n# fig.add_trace(ridge.data[0], row=1, col=3)\n\n# fig.add_trace(bp2.data[0], row=2, col=2)\n# fig.add_trace(ridge2.data[0], row=2, col=3)\n\n# fig.add_trace(bp3.data[0], row=3, col=2)\n# fig.add_trace(ridge3.data[0], row=3, col=3)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2020<\/b><br>Two-sample T-test:<br>- Statistics={round(stat, 3)};<br>- p-value={p};<br><b>{outcome}<\/b>\",\n#     textposition=[\"middle center\"],\n#     textfont=dict(size=12,color=\"black\")),row=1, col=1)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2019<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2019, 3)};<br>- p-value={p2019};<br><b>{outcome2019}<\/b>\",\n#     textposition=\"middle center\",\n#     textfont=dict(size=12,color=\"black\")),row=2, col=1)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2018<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2018, 3)};<br>- p-value={p2018};<br><b>{outcome2018}<\/b>\",\n#     textposition=\"middle center\",\n#     textfont=dict(size=12,color=\"black\")),row=3, col=1)\n\n# fig.update_layout(\n#     title={\n#         'text': \"Yards Gained from Return - High MRI vs Low MRI\",\n#         'y':0.95,\n#         'x':0.5,\n#         'xanchor': 'center',\n#         'yanchor': 'top'}, \n#     height=800,\n#     showlegend=False,\n#     template='plotly_white',\n#     )\n# fig.layout.yaxis2.title = 'Yards Gained'\n# fig.layout.xaxis3.title = 'Yards Gained'\n# fig.layout.yaxis3.title = 'MRI'\n# fig.layout.yaxis5.title = 'Yards Gained'\n# fig.layout.xaxis6.title = 'Yards Gained'\n# fig.layout.yaxis6.title = 'MRI'\n# fig.layout.yaxis8.title = 'Yards Gained'\n# fig.layout.xaxis9.title = 'Yards Gained'\n# fig.layout.yaxis9.title = 'MRI'\n\n# fig.layout.yaxis.showgrid = False\n# fig.layout.xaxis.showgrid = False\n# fig.layout.yaxis.zeroline = False\n# fig.layout.xaxis.zeroline = False\n# fig.layout.yaxis.visible = False\n# fig.layout.xaxis.visible = False\n# fig.layout.yaxis4.showgrid = False\n# fig.layout.xaxis4.showgrid = False\n# fig.layout.yaxis4.zeroline = False\n# fig.layout.xaxis4.zeroline = False\n# fig.layout.yaxis4.visible = False\n# fig.layout.xaxis4.visible = False\n# fig.layout.yaxis7.showgrid = False\n# fig.layout.xaxis7.showgrid = False\n# fig.layout.yaxis7.zeroline = False\n# fig.layout.xaxis7.zeroline = False\n# fig.layout.yaxis7.visible = False\n# fig.layout.xaxis7.visible = False\n\n# fig.show()\n\n# '''Statistical Tests and Distribution Plots - MPI'''\n# highValue = MAI_byPlay_df[MAI_byPlay_df['MPI'] >= 0.125]\n# lowValue = MAI_byPlay_df[MAI_byPlay_df['MPI'] < 0.125]\n\n# highValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MPI'] >= 0.125]\n# lowValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MPI'] < 0.125]\n\n# highValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MPI'] >= 0.125]\n# lowValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MPI'] < 0.125]\n\n# alpha = 0.05\n\n# stat, p = stats.ttest_ind(highValue['YardsGained'], lowValue['YardsGained'], equal_var=False)\n# if p > alpha:\n#     outcome = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome = 'Test Outcome:<br>Different distributions'\n# if p < 0.001:\n#     p = \"<0.0001\"\n    \n# stat2019, p2019 = stats.ttest_ind(highValue2019['YardsGained'], lowValue2019['YardsGained'], equal_var=False)\n# if p2019 > alpha:\n#     outcome2019 = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome2019 = 'Test Outcome:<br>Different distributions'\n# if p2019 < 0.001:\n#     p2019 = \"<0.0001\"\n# else:\n#     p2019 = round(p2019, 3)\n    \n# stat2018, p2018 = stats.ttest_ind(highValue2018['YardsGained'], lowValue2018['YardsGained'], equal_var=False)\n# if p2018 > alpha:\n#     outcome2018 = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome2018 = 'Test Outcome:<br>Different distributions'\n# if p2018 < 0.001:\n#     p2018 = \"<0.0001\"\n# else:\n#     p2018 = round(p2018, 3)\n    \n# highValue2 = pd.DataFrame()\n# highValue2['YardsGained'] = highValue['YardsGained']\n# highValue2['MPI'] = 'High'\n# lowValue2 = pd.DataFrame()\n# lowValue2['YardsGained'] = lowValue['YardsGained']\n# lowValue2['MPI'] = 'Low'\n\n# highValue2019_2 = pd.DataFrame()\n# highValue2019_2['YardsGained'] = highValue2019['YardsGained']\n# highValue2019_2['MPI'] = 'High'\n# lowValue2019_2 = pd.DataFrame()\n# lowValue2019_2['YardsGained'] = lowValue2019['YardsGained']\n# lowValue2019_2['MPI'] = 'Low'\n\n# highValue2018_2 = pd.DataFrame()\n# highValue2018_2['YardsGained'] = highValue2018['YardsGained']\n# highValue2018_2['MPI'] = 'High'\n# lowValue2018_2 = pd.DataFrame()\n# lowValue2018_2['YardsGained'] = lowValue2018['YardsGained']\n# lowValue2018_2['MPI'] = 'Low'\n\n# MPI_plays = pd.concat([highValue2, lowValue2])\n# MPI_plays2019 = pd.concat([highValue2019_2, lowValue2019_2])\n# MPI_plays2018 = pd.concat([highValue2018_2, lowValue2018_2])\n\n# bp1 = px.box(MPI_plays, x='MPI', y=\"YardsGained\")\n# bp1.data[0].marker.color = 'black'\n\n# bp2 = px.box(MPI_plays2019, x='MPI', y=\"YardsGained\")\n# bp2.data[0].marker.color = 'black'\n\n# bp3 = px.box(MPI_plays2018, x='MPI', y=\"YardsGained\")\n# bp3.data[0].marker.color = 'black'\n\n# ridge = px.violin(MPI_plays, x='YardsGained', y='MPI', orientation='h')\n# ridge2 = px.violin(MPI_plays2019, x='YardsGained', y='MPI', orientation='h')\n# ridge3 = px.violin(MPI_plays2018, x='YardsGained', y='MPI', orientation='h')\n\n# ridge.data[0].marker.color = 'black'\n# ridge.update_traces(side=\"positive\", width=4)\n# ridge2.data[0].marker.color = 'black'\n# ridge2.update_traces(side=\"positive\", width=4)\n# ridge3.data[0].marker.color = 'black'\n# ridge3.update_traces(side=\"positive\", width=4)\n\n# fig = make_subplots(rows=3, cols=3,\n#                    specs=[\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}]\n#                    ],\n#     )\n\n# fig.add_trace(bp1.data[0], row=1, col=2)\n# fig.add_trace(ridge.data[0], row=1, col=3)\n\n# fig.add_trace(bp2.data[0], row=2, col=2)\n# fig.add_trace(ridge2.data[0], row=2, col=3)\n\n# fig.add_trace(bp3.data[0], row=3, col=2)\n# fig.add_trace(ridge3.data[0], row=3, col=3)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2020<\/b><br>Two-sample T-test:<br>- Statistics={round(stat, 3)};<br>- p-value={p};<br><b>{outcome}<\/b>\",\n#     textposition=[\"middle center\"],\n#     textfont=dict(size=12,color=\"black\")),row=1, col=1)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2019<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2019, 3)};<br>- p-value={p2019};<br><b>{outcome2019}<\/b>\",\n#     textposition=\"middle center\",\n#     textfont=dict(size=12,color=\"black\")),row=2, col=1)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2018<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2018, 3)};<br>- p-value={p2018};<br><b>{outcome2018}<\/b>\",\n#     textposition=\"middle center\",\n#     textfont=dict(size=12,color=\"black\")),row=3, col=1)\n\n# fig.update_layout(\n#     title={\n#         'text': \"Yards Gained from Return - High MPI vs Low MPI\",\n#         'y':0.95,\n#         'x':0.5,\n#         'xanchor': 'center',\n#         'yanchor': 'top'}, \n#     height=800,\n#     showlegend=False,\n#     template='plotly_white',\n#     )\n# fig.layout.yaxis2.title = 'Yards Gained'\n# fig.layout.xaxis3.title = 'Yards Gained'\n# fig.layout.yaxis3.title = 'MPI'\n# fig.layout.yaxis5.title = 'Yards Gained'\n# fig.layout.xaxis6.title = 'Yards Gained'\n# fig.layout.yaxis6.title = 'MPI'\n# fig.layout.yaxis8.title = 'Yards Gained'\n# fig.layout.xaxis9.title = 'Yards Gained'\n# fig.layout.yaxis9.title = 'MPI'\n\n# fig.layout.yaxis.showgrid = False\n# fig.layout.xaxis.showgrid = False\n# fig.layout.yaxis.zeroline = False\n# fig.layout.xaxis.zeroline = False\n# fig.layout.yaxis.visible = False\n# fig.layout.xaxis.visible = False\n# fig.layout.yaxis4.showgrid = False\n# fig.layout.xaxis4.showgrid = False\n# fig.layout.yaxis4.zeroline = False\n# fig.layout.xaxis4.zeroline = False\n# fig.layout.yaxis4.visible = False\n# fig.layout.xaxis4.visible = False\n# fig.layout.yaxis7.showgrid = False\n# fig.layout.xaxis7.showgrid = False\n# fig.layout.yaxis7.zeroline = False\n# fig.layout.xaxis7.zeroline = False\n# fig.layout.yaxis7.visible = False\n# fig.layout.xaxis7.visible = False\n\n# fig.show()\n\n# '''Statistical Tests and Distribution Plots - MPSI'''\n# highValue = MAI_byPlay_df[MAI_byPlay_df['MPSI'] >= 0.575]\n# lowValue = MAI_byPlay_df[MAI_byPlay_df['MPSI'] < 0.575]\n\n# highValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MPSI'] >= 0.575]\n# lowValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MPSI'] < 0.575]\n\n# highValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MPSI'] >= 0.575]\n# lowValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MPSI'] < 0.575]\n\n# alpha = 0.05\n\n# stat, p = stats.ttest_ind(highValue['YardsGained'], lowValue['YardsGained'], equal_var=False)\n# if p > alpha:\n#     outcome = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome = 'Test Outcome:<br>Different distributions'\n# if p < 0.001:\n#     p = \"<0.0001\"\n    \n# stat2019, p2019 = stats.ttest_ind(highValue2019['YardsGained'], lowValue2019['YardsGained'], equal_var=False)\n# if p2019 > alpha:\n#     outcome2019 = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome2019 = 'Test Outcome:<br>Different distributions'\n# if p2019 < 0.001:\n#     p2019 = \"<0.0001\"\n# else:\n#     p2019 = round(p2019, 3)\n    \n# stat2018, p2018 = stats.ttest_ind(highValue2018['YardsGained'], lowValue2018['YardsGained'], equal_var=False)\n# if p2018 > alpha:\n#     outcome2018 = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome2018 = 'Test Outcome:<br>Different distributions'\n# if p2018 < 0.001:\n#     p2018 = \"<0.0001\"\n# else:\n#     p2018 = round(p2018, 3)\n    \n# highValue2 = pd.DataFrame()\n# highValue2['YardsGained'] = highValue['YardsGained']\n# highValue2['MPSI'] = 'High'\n# lowValue2 = pd.DataFrame()\n# lowValue2['YardsGained'] = lowValue['YardsGained']\n# lowValue2['MPSI'] = 'Low'\n\n# highValue2019_2 = pd.DataFrame()\n# highValue2019_2['YardsGained'] = highValue2019['YardsGained']\n# highValue2019_2['MPSI'] = 'High'\n# lowValue2019_2 = pd.DataFrame()\n# lowValue2019_2['YardsGained'] = lowValue2019['YardsGained']\n# lowValue2019_2['MPSI'] = 'Low'\n\n# highValue2018_2 = pd.DataFrame()\n# highValue2018_2['YardsGained'] = highValue2018['YardsGained']\n# highValue2018_2['MPSI'] = 'High'\n# lowValue2018_2 = pd.DataFrame()\n# lowValue2018_2['YardsGained'] = lowValue2018['YardsGained']\n# lowValue2018_2['MPSI'] = 'Low'\n\n# MPSI_plays = pd.concat([highValue2, lowValue2])\n# MPSI_plays2019 = pd.concat([highValue2019_2, lowValue2019_2])\n# MPSI_plays2018 = pd.concat([highValue2018_2, lowValue2018_2])\n\n# bp1 = px.box(MPSI_plays, x='MPSI', y=\"YardsGained\")\n# bp1.data[0].marker.color = 'black'\n\n# bp2 = px.box(MPSI_plays2019, x='MPSI', y=\"YardsGained\")\n# bp2.data[0].marker.color = 'black'\n\n# bp3 = px.box(MPSI_plays2018, x='MPSI', y=\"YardsGained\")\n# bp3.data[0].marker.color = 'black'\n\n# ridge = px.violin(MPSI_plays, x='YardsGained', y='MPSI', orientation='h')\n# ridge2 = px.violin(MPSI_plays2019, x='YardsGained', y='MPSI', orientation='h')\n# ridge3 = px.violin(MPSI_plays2018, x='YardsGained', y='MPSI', orientation='h')\n\n# ridge.data[0].marker.color = 'black'\n# ridge.update_traces(side=\"positive\", width=4)\n# ridge2.data[0].marker.color = 'black'\n# ridge2.update_traces(side=\"positive\", width=4)\n# ridge3.data[0].marker.color = 'black'\n# ridge3.update_traces(side=\"positive\", width=4)\n\n# fig = make_subplots(rows=3, cols=3,\n#                    specs=[\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}]\n#                    ],\n#     )\n\n# fig.add_trace(bp1.data[0], row=1, col=2)\n# fig.add_trace(ridge.data[0], row=1, col=3)\n\n# fig.add_trace(bp2.data[0], row=2, col=2)\n# fig.add_trace(ridge2.data[0], row=2, col=3)\n\n# fig.add_trace(bp3.data[0], row=3, col=2)\n# fig.add_trace(ridge3.data[0], row=3, col=3)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2020<\/b><br>Two-sample T-test:<br>- Statistics={round(stat, 3)};<br>- p-value={p};<br><b>{outcome}<\/b>\",\n#     textposition=[\"middle center\"],\n#     textfont=dict(size=12,color=\"black\")),row=1, col=1)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2019<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2019, 3)};<br>- p-value={p2019};<br><b>{outcome2019}<\/b>\",\n#     textposition=\"middle center\",\n#     textfont=dict(size=12,color=\"black\")),row=2, col=1)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2018<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2018, 3)};<br>- p-value={p2018};<br><b>{outcome2018}<\/b>\",\n#     textposition=\"middle center\",\n#     textfont=dict(size=12,color=\"black\")),row=3, col=1)\n\n# fig.update_layout(\n#     title={\n#         'text': \"Yards Gained from Return - High MPSI vs Low MPSI\",\n#         'y':0.95,\n#         'x':0.5,\n#         'xanchor': 'center',\n#         'yanchor': 'top'}, \n#     height=800,\n#     showlegend=False,\n#     template='plotly_white',\n#     )\n# fig.layout.yaxis2.title = 'Yards Gained'\n# fig.layout.xaxis3.title = 'Yards Gained'\n# fig.layout.yaxis3.title = 'MPSI'\n# fig.layout.yaxis5.title = 'Yards Gained'\n# fig.layout.xaxis6.title = 'Yards Gained'\n# fig.layout.yaxis6.title = 'MPSI'\n# fig.layout.yaxis8.title = 'Yards Gained'\n# fig.layout.xaxis9.title = 'Yards Gained'\n# fig.layout.yaxis9.title = 'MPSI'\n\n# fig.layout.yaxis.showgrid = False\n# fig.layout.xaxis.showgrid = False\n# fig.layout.yaxis.zeroline = False\n# fig.layout.xaxis.zeroline = False\n# fig.layout.yaxis.visible = False\n# fig.layout.xaxis.visible = False\n# fig.layout.yaxis4.showgrid = False\n# fig.layout.xaxis4.showgrid = False\n# fig.layout.yaxis4.zeroline = False\n# fig.layout.xaxis4.zeroline = False\n# fig.layout.yaxis4.visible = False\n# fig.layout.xaxis4.visible = False\n# fig.layout.yaxis7.showgrid = False\n# fig.layout.xaxis7.showgrid = False\n# fig.layout.yaxis7.zeroline = False\n# fig.layout.xaxis7.zeroline = False\n# fig.layout.yaxis7.visible = False\n# fig.layout.xaxis7.visible = False\n\n# fig.show()\n\n# '''Statistical Tests and Distribution Plots - MAI'''\n# highValue = MAI_byPlay_df[MAI_byPlay_df['MAI'] >= 0.675]\n# lowValue = MAI_byPlay_df[MAI_byPlay_df['MAI'] < 0.675]\n\n# highValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MAI'] >= 0.675]\n# lowValue2019 = MAI_byPlay_df2019[MAI_byPlay_df2019['MAI'] < 0.675]\n\n# highValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MAI'] >= 0.675]\n# lowValue2018 = MAI_byPlay_df2018[MAI_byPlay_df2018['MAI'] < 0.675]\n\n# alpha = 0.05\n\n# stat, p = stats.ttest_ind(highValue['YardsGained'], lowValue['YardsGained'], equal_var=False)\n# if p > alpha:\n#     outcome = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome = 'Test Outcome:<br>Different distributions'\n# if p < 0.001:\n#     p = \"<0.0001\"\n    \n# stat2019, p2019 = stats.ttest_ind(highValue2019['YardsGained'], lowValue2019['YardsGained'], equal_var=False)\n# if p2019 > alpha:\n#     outcome2019 = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome2019 = 'Test Outcome:<br>Different distributions'\n# if p2019 < 0.001:\n#     p2019 = \"<0.0001\"\n# else:\n#     p2019 = round(p2019, 3)\n    \n# stat2018, p2018 = stats.ttest_ind(highValue2018['YardsGained'], lowValue2018['YardsGained'], equal_var=False)\n# if p2018 > alpha:\n#     outcome2018 = 'Test Outcome:<br>Same distributions'\n# else:\n#     outcome2018 = 'Test Outcome:<br>Different distributions'\n# if p2018 < 0.001:\n#     p2018 = \"<0.0001\"\n# else:\n#     p2018 = round(p2018, 3)\n    \n# highValue2 = pd.DataFrame()\n# highValue2['YardsGained'] = highValue['YardsGained']\n# highValue2['MAI'] = 'High'\n# lowValue2 = pd.DataFrame()\n# lowValue2['YardsGained'] = lowValue['YardsGained']\n# lowValue2['MAI'] = 'Low'\n\n# highValue2019_2 = pd.DataFrame()\n# highValue2019_2['YardsGained'] = highValue2019['YardsGained']\n# highValue2019_2['MAI'] = 'High'\n# lowValue2019_2 = pd.DataFrame()\n# lowValue2019_2['YardsGained'] = lowValue2019['YardsGained']\n# lowValue2019_2['MAI'] = 'Low'\n\n# highValue2018_2 = pd.DataFrame()\n# highValue2018_2['YardsGained'] = highValue2018['YardsGained']\n# highValue2018_2['MAI'] = 'High'\n# lowValue2018_2 = pd.DataFrame()\n# lowValue2018_2['YardsGained'] = lowValue2018['YardsGained']\n# lowValue2018_2['MAI'] = 'Low'\n\n# MAI_plays = pd.concat([highValue2, lowValue2])\n# MAI_plays2019 = pd.concat([highValue2019_2, lowValue2019_2])\n# MAI_plays2018 = pd.concat([highValue2018_2, lowValue2018_2])\n\n# bp1 = px.box(MAI_plays, x='MAI', y=\"YardsGained\")\n# bp1.data[0].marker.color = 'black'\n\n# bp2 = px.box(MAI_plays2019, x='MAI', y=\"YardsGained\")\n# bp2.data[0].marker.color = 'black'\n\n# bp3 = px.box(MAI_plays2018, x='MAI', y=\"YardsGained\")\n# bp3.data[0].marker.color = 'black'\n\n# ridge = px.violin(MAI_plays, x='YardsGained', y='MAI', orientation='h')\n# ridge2 = px.violin(MAI_plays2019, x='YardsGained', y='MAI', orientation='h')\n# ridge3 = px.violin(MAI_plays2018, x='YardsGained', y='MAI', orientation='h')\n\n# ridge.data[0].marker.color = 'black'\n# ridge.update_traces(side=\"positive\", width=4)\n# ridge2.data[0].marker.color = 'black'\n# ridge2.update_traces(side=\"positive\", width=4)\n# ridge3.data[0].marker.color = 'black'\n# ridge3.update_traces(side=\"positive\", width=4)\n\n# fig = make_subplots(rows=3, cols=3,\n#                    specs=[\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}],\n#     [{},{\"type\": \"box\"}, {\"type\":\"violin\"}]\n#                    ],\n#     )\n\n# fig.add_trace(bp1.data[0], row=1, col=2)\n# fig.add_trace(ridge.data[0], row=1, col=3)\n\n# fig.add_trace(bp2.data[0], row=2, col=2)\n# fig.add_trace(ridge2.data[0], row=2, col=3)\n\n# fig.add_trace(bp3.data[0], row=3, col=2)\n# fig.add_trace(ridge3.data[0], row=3, col=3)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2020<\/b><br>Two-sample T-test:<br>- Statistics={round(stat, 3)};<br>- p-value={p};<br><b>{outcome}<\/b>\",\n#     textposition=[\"middle center\"],\n#     textfont=dict(size=12,color=\"black\")),row=1, col=1)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2019<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2019, 3)};<br>- p-value={p2019};<br><b>{outcome2019}<\/b>\",\n#     textposition=\"middle center\",\n#     textfont=dict(size=12,color=\"black\")),row=2, col=1)\n\n# fig.add_trace(go.Scatter(\n#     x=[1],y=[1],mode=\"text\",\n#     text=f\"<b>Season 2018<\/b><br>Two-sample T-test:<br>- Statistics={round(stat2018, 3)};<br>- p-value={p2018};<br><b>{outcome2018}<\/b>\",\n#     textposition=\"middle center\",\n#     textfont=dict(size=12,color=\"black\")),row=3, col=1)\n\n# fig.update_layout(\n#     title={\n#         'text': \"Yards Gained from Return - High MAI vs Low MAI\",\n#         'y':0.95,\n#         'x':0.5,\n#         'xanchor': 'center',\n#         'yanchor': 'top'}, \n#     height=800,\n#     showlegend=False,\n#     template='plotly_white',\n#     )\n# fig.layout.yaxis2.title = 'Yards Gained'\n# fig.layout.xaxis3.title = 'Yards Gained'\n# fig.layout.yaxis3.title = 'MAI'\n# fig.layout.yaxis5.title = 'Yards Gained'\n# fig.layout.xaxis6.title = 'Yards Gained'\n# fig.layout.yaxis6.title = 'MAI'\n# fig.layout.yaxis8.title = 'Yards Gained'\n# fig.layout.xaxis9.title = 'Yards Gained'\n# fig.layout.yaxis9.title = 'MAI'\n\n# fig.layout.yaxis.showgrid = False\n# fig.layout.xaxis.showgrid = False\n# fig.layout.yaxis.zeroline = False\n# fig.layout.xaxis.zeroline = False\n# fig.layout.yaxis.visible = False\n# fig.layout.xaxis.visible = False\n# fig.layout.yaxis4.showgrid = False\n# fig.layout.xaxis4.showgrid = False\n# fig.layout.yaxis4.zeroline = False\n# fig.layout.xaxis4.zeroline = False\n# fig.layout.yaxis4.visible = False\n# fig.layout.xaxis4.visible = False\n# fig.layout.yaxis7.showgrid = False\n# fig.layout.xaxis7.showgrid = False\n# fig.layout.yaxis7.zeroline = False\n# fig.layout.xaxis7.zeroline = False\n# fig.layout.yaxis7.visible = False\n# fig.layout.xaxis7.visible = False\n\n# fig.show()\n\n# '''Table: Return kicking plays sorted by Yards Gained; 20 highest MAI, 20 lowest MAI'''\n\n# colors = n_colors('rgb(0, 255, 255)', 'rgb(0, 0, 255)', 76, colortype='rgb')\n\n# MAI_byPlay_df_Sorted = MAI_byPlay_df.sort_values(by=['MAI'], ascending=False).reset_index()\n# MAI_byPlay_df_Sorted = MAI_byPlay_df_Sorted.drop([row for row in range(20, (len(MAI_byPlay_df_Sorted['MAI'])- 20))])\n\n# MAI = MAI_byPlay_df_Sorted['MAI']\n# MRI = MAI_byPlay_df_Sorted['MRI']\n# MPI = MAI_byPlay_df_Sorted['MPI']\n# MPSI = MAI_byPlay_df_Sorted['MPSI']\n# YardsGained = MAI_byPlay_df_Sorted['YardsGained']\n# team = MAI_byPlay_df_Sorted['ReturningTeam']\n# visitorTeam = MAI_byPlay_df_Sorted['AwayTeam']\n# homeTeam = MAI_byPlay_df_Sorted['HomeTeam']\n# gameId = MAI_byPlay_df_Sorted['gameId']\n# playId = MAI_byPlay_df_Sorted['playId']\n\n# fig = go.Figure(data=[go.Table(\n#   header=dict(\n#     values=['<b>MAI<\/b>', '<b>MRI<\/b>', '<b>MPI<\/b>', '<b>MPSI<\/b>', '<b>Yards<br>Gained<\/b>', '<b>Returning<br>Team<\/b>', '<b>Away<br>Team<\/b>',\n#             '<b>Home<br>Team<\/b>', '<b>GameID<\/b>', '<b>PlayID<\/b>'],\n#     line_color='black', fill_color='lime',\n#     align='center',font=dict(color='black', size=12)\n#   ),\n#   columnwidth=[1,1,1,1,1,1,1,1,1.5,1],\n#   cells=dict(\n#     values=[MAI, MRI, MPI, MPSI, YardsGained, team, visitorTeam, homeTeam, gameId, playId],\n#     line_color=['black','black','black','black','black','black','black','black','black','black'],\n#     fill_color=['white','white','white','white',np.array(colors)[(YardsGained).astype(int)],'white','white','white','white','white'],\n#     align='center', font=dict(color='black', size=12)\n#     ))\n# ])\n\n# fig.update_layout(\n#     title={\n#         'text': \"\",\n#         'y':0.95,\n#         'x':0.5,\n#         'xanchor': 'center',\n#         'yanchor': 'top'},    \n#     height=1100)\n\n# fig.show()\n\n# '''Framewise MAI - PlayPlot and EvaluationPlot; set to 2020, but can be adapted to visualize Plays and related MAI Evaluation Plot for other seasons, as well'''\n# def visualizeMAI(gameId, playId, season=2020):\n#     tracking2020_singlePlay = tracking2020[tracking2020['gameId'] == gameId][tracking2020['playId'] == playId]\n#     team = getDefendingTeam(tracking2020_singlePlay)\n#     returnStart, framesAfterStart = getReturnStart(tracking2020_singlePlay, team)\n#     returnerId = detectReturner(tracking2020_singlePlay)\n#     tracking2020_singlePlay_ballcarrier = tracking2020_singlePlay[tracking2020_singlePlay['nflId'] == returnerId]\n#     tracking2020_singlePlay = tracking2020_singlePlay[tracking2020_singlePlay['nflId'] != returnerId]\n#     max_accelerations = [0,0,0,0,0,0,0,0,0,0]\n#     frames = []\n#     framewiseMRI_store = []\n#     framewiseMPI_store = []\n#     framewiseMPSI_store = []\n#     framewiseMAI_store = []\n#     for frame in tracking2020_singlePlay['frameId'].unique():\n#         if frame < returnStart + 10:\n#             framewiseMRI = 0\n#             framewiseMRI_store.append(framewiseMRI)\n#             framewiseMPI = 0\n#             framewiseMPI_store.append(framewiseMRI)\n#             framewiseMPSI = 0\n#             framewiseMPSI_store.append(framewiseMRI)\n#             framewiseMAI = 0\n#             framewiseMAI_store.append(framewiseMAI)\n#             frames.append(frame)\n#         else:\n#             #MRI\n#             players = []\n#             for player in tracking2020_singlePlay['displayName'].unique():\n#                 tracking2020_singlePlay_player_framed = tracking2020_singlePlay[tracking2020_singlePlay['frameId'] == frame][tracking2020_singlePlay['displayName'] == player]\n#                 players.append(tracking2020_singlePlay_player_framed['a'].reset_index(drop=True)[0])\n#             for i in range(len(max_accelerations)):\n#                 if players[i] > max_accelerations[i]:\n#                     max_accelerations[i] = players[i]\n#             framewiseMRI = round(((sum(max_accelerations) \/ len(max_accelerations)) - minmaxMetrics2018_2019_2020['MinMRI']) \/ (minmaxMetrics2018_2019_2020['MaxMRI'] - minmaxMetrics2018_2019_2020['MinMRI']), 3)\n#             framewiseMRI_store.append(framewiseMRI)\n#             #MPI\n#             tracking2020_singlePlay_framed = tracking2020_singlePlay[tracking2020_singlePlay['frameId'] == frame]\n#             centroidOpponents = {}\n#             combinations = [] #store for MPSI     \n#             for player in tracking2020_singlePlay_framed[tracking2020_singlePlay_framed['team'] == team]['displayName']:\n#                 tracking2020_singlePlay_framed_player = tracking2020_singlePlay_framed[tracking2020_singlePlay_framed['displayName'] == player]\n#                 distances = []\n#                 players = []\n#                 for opponentPlayer in tracking2020_singlePlay_framed[tracking2020_singlePlay_framed['team'] != team][tracking2020_singlePlay_framed['team'] != 'football']['displayName'].unique():\n#                     tracking2020_singlePlay_framed_opponent = tracking2020_singlePlay_framed[tracking2020_singlePlay_framed['displayName'] == opponentPlayer]\n#                     distances.append(getDistance(tracking2020_singlePlay_framed_player['x'].reset_index(drop=True)[0], tracking2020_singlePlay_framed_player['y'].reset_index(drop=True)[0], tracking2020_singlePlay_framed_opponent['x'].reset_index(drop=True)[0], tracking2020_singlePlay_framed_opponent['y'].reset_index(drop=True)[0]))\n#                     players.append(tracking2020_singlePlay_framed_opponent['displayName'].reset_index(drop=True)[0])\n#                 covered = players[distances.index(min(distances))]\n#                 if covered in centroidOpponents:\n#                     centroidOpponents[covered].append(min(distances))\n#                 else:\n#                     centroidOpponents[covered] = [min(distances)]\n#                 combinations.append((players[distances.index(min(distances))], player))\n#             byCluster = []\n#             for covered in centroidOpponents:\n#                 byCluster.append(sum(centroidOpponents[covered]) \/ len(centroidOpponents[covered]))\n#             framewiseMPI = round(((sum(byCluster) \/ len(byCluster)) - minmaxMetrics2018_2019_2020['MinMPI']) \/ (minmaxMetrics2018_2019_2020['MaxMPI'] - minmaxMetrics2018_2019_2020['MinMPI']), 3)\n#             framewiseMPI_store.append(framewiseMPI)\n#             #MPSI\n#             tracking2020_singlePlay_ballcarrier_framed = tracking2020_singlePlay_ballcarrier[tracking2020_singlePlay_ballcarrier['frameId'] == frame]\n#             X_Pb = tracking2020_singlePlay_ballcarrier_framed['x'].reset_index(drop=True)[0]\n#             Y_Pb = tracking2020_singlePlay_ballcarrier_framed['y'].reset_index(drop=True)[0]\n#             PSI = []\n#             CoveredPlayers = []\n#             for combination in combinations:\n#                 Pk = tracking2020_singlePlay_framed[tracking2020_singlePlay_framed['displayName'] == combination[0]]\n#                 X_Pk = Pk['x'].reset_index(drop=True)[0]\n#                 Y_Pk = Pk['y'].reset_index(drop=True)[0]\n#                 Pr = tracking2020_singlePlay_framed[tracking2020_singlePlay_framed['displayName'] == combination[1]]\n#                 X_Pr = Pr['x'].reset_index(drop=True)[0]\n#                 Y_Pr = Pr['y'].reset_index(drop=True)[0]\n#                 cosine = (getDistance(X_Pk,Y_Pk,X_Pr,Y_Pr,squared=True)+getDistance(X_Pb,Y_Pb,X_Pr,Y_Pr,squared=True)-getDistance(X_Pb,Y_Pb,X_Pk,Y_Pk,squared=True))\/(2*(getDistance(X_Pk,Y_Pk,X_Pr,Y_Pr)*getDistance(X_Pb,Y_Pb,X_Pr,Y_Pr)))\n#                 if cosine > 1 and cosine < 1.2:\n#                     cosine = 1\n#                 if cosine < -1 and cosine > -1.2:\n#                     cosine = -1\n#                 PSI_Degrees = math.degrees(math.acos(cosine))\n#                 PSI.append(PSI_Degrees)\n#                 CoveredPlayers.append(combination[0])\n#             framewiseMPSI = round(((sum(PSI) \/ len(PSI)) - minmaxMetrics2018_2019_2020['MinMPSI']) \/ (minmaxMetrics2018_2019_2020['MaxMPSI'] - minmaxMetrics2018_2019_2020['MinMPSI']), 3)\n#             framewiseMPSI_store.append(framewiseMPSI)\n#             framewiseMAI = round(0.2*framewiseMRI + 0.45*framewiseMPSI + 0.35*(1 - framewiseMPI), 3)\n#             framewiseMAI_store.append(framewiseMAI)\n#             frames.append(frame)\n\n#     df = pd.DataFrame(frames, columns=['frames'])\n#     df['framewiseMRI'] = framewiseMRI_store\n#     df['framewiseMPI'] = framewiseMPI_store\n#     df['framewiseMPSI'] = framewiseMPSI_store\n#     df['framewiseMAI'] = framewiseMAI_store\n#     return df, returnStart\n        \n# def visualizePlay(gameId, playId):\n#     tracking_df_byGame = tracking2020[tracking2020['gameId'] == gameId]\n#     tracking_df_withPlay = (tracking2020['gameId'] == gameId) & (tracking2020['playId'] == playId)\n#     tracking_df_byGame = (\n#         tracking2020[tracking_df_withPlay][['x', 'y', 'time', 'nflId', 'team', 'displayName','frameId','jerseyNumber']]\n#         .fillna(0.)\n#         .sort_values(['team', 'time'])\n#     )\n#     fig = px.scatter(\n#         tracking_df_byGame,\n#         x='x', y='y',\n#         color='team',\n#         animation_frame='frameId',animation_group=\"nflId\",\n#         hover_name=\"displayName\",\n#         text='jerseyNumber',\n#     )\n#     fig.update_traces(marker=dict(size=16,\n#                                   line=dict(width=2,color='DarkSlateGrey')),\n#                       selector=dict(mode='markers'))\n\n#     for x in range(0, 130, 10):\n#         fig.add_trace(go.Scatter(x=[x, x], y=[0, 53.5], mode='lines', showlegend=False, line=dict(color=\"#333333\")))\n#     fig.add_trace(go.Scatter(x=[0, 120], y=[53.5, 53.5], mode='lines', showlegend=False, line=dict(color=\"#333333\")))\n#     fig.add_trace(go.Scatter(x=[0, 120], y=[0, 0], mode='lines', showlegend=False, line=dict(color=\"#333333\")))\n#     fig.update_layout(\n#         title={\n#             'text': f\"Display Play - Game: {gameId}, Play: {playId}\",\n#             'y':0.70,\n#             'x':0.5,\n#             'xanchor': 'center',\n#             'yanchor': 'top'}, \n#             template='plotly_dark',\n#         width=1200,\n#         height=700\n#     )\n#     fig.layout.updatemenus[0].buttons[0].args[1][\"frame\"][\"duration\"] = 50\n#     return fig\n    \n# gameId, playId = 2020122600, 3416\n    \n# playPlot = visualizePlay(gameId, playId)\n# #'''\n# playPlot.data[0].marker.size = 20\n# playPlot.data[1].marker.size = 20\n# playPlot.data[2].marker.size = 20\n# playPlot.data[0].textfont.color = 'black'\n# playPlot.data[1].textfont.color = 'black'\n# playPlot.data[2].textfont.color = 'black'\n# playPlot.data[0].marker.color = 'red'\n# playPlot.data[1].marker.color = 'white'\n# playPlot.data[2].marker.color = 'lime'\n# for i in range(len(playPlot.frames)):\n#     for k in range(len(playPlot.frames[i]['data'])):\n#         playPlot.frames[i].data[0].marker.color = 'red'\n#         playPlot.frames[i].data[1].marker.color = 'white'\n#         playPlot.frames[i].data[2].marker.color = 'lime'\n#         playPlot.frames[i].data[0].textfont.color = 'black'\n#         playPlot.frames[i].data[1].textfont.color = 'black'\n#         playPlot.frames[i].data[2].textfont.color = 'black'        \n#         playPlot.frames[i].data[0].marker.size = 20\n#         playPlot.frames[i].data[1].marker.size = 20\n#         playPlot.frames[i].data[2].marker.size = 20\n        \n# playPlot.layout.updatemenus[0].y = 0.1\n# playPlot.layout.sliders[0].y = 1.5\n# playPlot.layout.updatemenus[0].bordercolor='black'\n# playPlot.layout.updatemenus[0].bgcolor='black'\n# #'''\n# playPlot.show()\n\n\n# framewise_df, t0 = visualizeMAI(gameId, playId)\n        \n# MRI = pd.DataFrame(framewise_df['frames'])\n# MRI['metric'] = \"MRI\"\n# MRI['value'] = framewise_df['framewiseMRI']\n\n# MPI = pd.DataFrame(framewise_df['frames'])\n# MPI['metric'] = \"MPI\"\n# MPI['value'] = framewise_df['framewiseMPI']\n\n# MPSI = pd.DataFrame(framewise_df['frames'])\n# MPSI['metric'] = \"MPSI\"\n# MPSI['value'] = framewise_df['framewiseMPSI']\n\n# MAI = pd.DataFrame(framewise_df['frames'])\n# MAI['metric'] = \"MAI\"\n# MAI['value'] = framewise_df['framewiseMAI']\n\n# concatenated = pd.concat([MRI, MPI, MPSI, MAI])\n\n# fig = px.line(concatenated, x = \"frames\", y = \"value\", title = \"Framewise MAI\", animation_frame=\"frames\", color='metric',\n#                  range_x=[-1,max(concatenated['frames'])+2], range_y=[-0.1,1.5],color_discrete_sequence=['purple','lime','orange','cyan'])\n# fig.layout.updatemenus[0].y = 1.40\n# fig.update_traces(marker=dict(\n#             size=20,\n#             line=dict(\n#                 color='black',\n#                 width=5\n#             )))\n\n# fig.update_layout(\n#     title={\n#         'text': \"Framewise MAI\",\n#         'y':0.90,\n#         'x':0.5,\n#         'xanchor': 'center',\n#         'yanchor': 'top'}, \n#     showlegend=True,\n#     template='plotly_dark',\n#     width=1200,\n#     )\n# fig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = 50\n\n# fig.add_vline(x=t0, line_width=2, line_color='red', line_dash='dash',annotation_text=\"t0\", \n#               annotation_position=\"top right\")\n# fig.add_vline(x=t0+10, line_width=2, line_color='red', line_dash='dash',annotation_text=\"t0 + \u03b5\", \n#               annotation_position=\"top right\")\n# if max(concatenated['frames']) > t0+60:\n#     fig.add_vline(x=t0+60, line_width=2, line_color='red', line_dash='dash',annotation_text=\"$t_{end, \\sigma}$\", \n#                   annotation_position=\"top right\")\n# else:\n#     fig.add_vline(x=max(concatenated['frames']), line_width=2, line_color='red', line_dash='dash',annotation_text=\"$t_{end, \\sigma}$\", \n#                   annotation_position=\"top right\")\n# fig.layout.xaxis.title.text = 'Frames (t)'\n\n# colors = {'MRI':'purple',\n#           'MPI':'lime',\n#           'MPSI':'orange',\n#           'MAI':'cyan'}\n# for i in range(len(fig.frames)):\n#     for k in range(len(fig.frames[i]['data'])):\n#         fig.frames[i]['data'][k]['line']['color'] = colors[fig.frames[i]['data'][k]['name']]\n        \n# for i in range(1, len(fig.frames)):\n#     for k in range(len(fig.frames[i]['data'])):\n#         fig.frames[i]['data'][k]['x'] = np.concatenate((fig.frames[i-1]['data'][k]['x'], fig.frames[i]['data'][k]['x']))\n#         fig.frames[i]['data'][k]['y'] = np.concatenate((fig.frames[i-1]['data'][k]['y'], fig.frames[i]['data'][k]['y']))\n\n# fig.layout.updatemenus[0].bordercolor='black'\n# fig.layout.updatemenus[0].bgcolor='black'\n\n# fig.show()\n\n","4d939052":"## Putting pieces together: MAI\n\n<div style='text-align:center'><font size=3> $MAI = \\gamma(nMRI) + \\lambda(nMPSI) + \\phi(1 - nMPI) $;<\/font><\/div><br>\n\n<div style='text-align:center'><font size=3> $normalizedMetric = \\frac{RawMetric - RawMetric_{min}}{RawMetric_{max} - RawMetric_{min}} $;<\/font><\/div><br>\n\n<div style='text-align:center'><font size=3>$\\implies MAI = \\gamma(\\frac{MRI - MRI_{min}}{MRI_{max} - MRI_{min}}) + \\lambda(\\frac{MPSI - MPSI_{min}}{MPSI_{max} - MPSI_{min}}) + \\phi(1 - \\frac{MPI - MPI_{min}}{MPI_{max} - MPI_{min}})$,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$MAI \\in [0, 1]$<\/font><\/div><br>\n\n\nWhere:\n- $max$ and $min$ subscripts represent, respectively, the maximum and the minimum value of the non-normalized metric ever encountered in the three season of available tracking data, i.e., 2018, 2019 and 2020;\n- $\\gamma$, $\\lambda$, and $\\phi$ are coefficients indicating how much each sub-metric contributes to the Mean Aggression Index.\n\nNote: the purpose of normalizing each sub-metric is to yield evaluation measures in the same scale, i.e., between 0 and 1, easing the MAI computation process and making it fit in the [0, 1] interval, as well.","8d844320":"We will now visualize three plays from the above list: a high-MAI play, a low-MAI play, and a low-MAI play with very high YardsGained (i.e., an exception).\n\n#### High MAI, high YardsGained\n![VideoPlot2_40.gif](https:\/\/github.com\/Mauromar00\/NFL-2022---MAI\/blob\/main\/40.gif?raw=true)\n<br>An effective aggressive defense with high-pressure coverage schemes explains pretty well the high gain in yards of the returning team.\n\nNote: the minimum and maximum values of each sub-metric have been computed with intervals of 5 time frames (i.e., half a second); hence, some slightly larger values may occur when computed frame by frame, and the framewise computation of MPSI sometimes exceeds the 1 threshold.\n\n#### Low MAI, low YardsGained\n![VideoPlot1_3416.gif](https:\/\/github.com\/Mauromar00\/NFL-2022---MAI\/blob\/main\/3416.gif?raw=true)\n<br>The extremely low MAI delineates a low-pressure behavior assumed by returning team players, with a subsequent overwhelm of the ball returner by kicking team players; the poor yardage gain is a direct consequence.\n\n#### Exception: low MAI, high YardsGained\n![VideoPlot3_4543.gif](https:\/\/github.com\/Mauromar00\/NFL-2022---MAI\/blob\/main\/4543.gif?raw=true)\n<br>As previously mentioned, MAI evaluates aggressive defense of returning team players; this play is a clear example of a play where the decisive factor for a high yardage gain is not imputable to effective protection of the ball returner, rather it can be attributed to a combination of skill and responsiveness of the ball returner, and kicker performance (who presumably aimed at performing an onside kick).","21c7108a":"### 3.1 Mean Responsiveness Index","51a6b477":"The prevalence of darker colors in the top half of the table denotes a prevalence of overall higher Yard Gains in plays where the returning team displays high MAI, precisely as we previously observed and inferred through the statistical tests. These examples are taken to the extreme (20 very low vs 20 very high MAI plays), but they convey the concept pretty well.","c2d95b1e":"<div style=\"background-color:white\"> <font size=\"5\"> <b> 0. Outline <\/b> <\/font> <\/div>\n<div style=\"background-color:white\"> <font size=\"3\"> <b> 1. Introduction <\/b> <\/font> <\/div>\n<div style=\"background-color:white\"> <font size=\"3\"> <b> 2. Building the MAI: Mean Aggression Index <\/b> <\/font> <\/div>\n<ol>\n2.1 \tMean Responsiveness Index: MRI<br>\n2.2 \tMean Proximity Index: MPI<br>\n2.3 \tMean Positioning Suitability Index: MPSI<br>\nPutting pieces together: MAI<br>\n<\/ol>\n<div style=\"background-color:white\"> <font size=\"3\"> <b> 3. Experiments and Validation <\/b> <\/font> <\/div>\n<div style=\"background-color:white\"> <font size=\"3\"> <b> 4. Conclusions and Potential Developments <\/b> <\/font> <\/div>\n<div style=\"background-color:white\"> <font size=\"3\"> <b> Appendix <\/b> <\/font> <\/div>\n","c1a44f61":"Higher Mean Responsiveness Index leads, as expected, to higher gains in terms of Yards in Return Kicking plays: in fact, we adopted a statistical inference technique for hypothesis testing called t-test whose outcome confirms what we can suppose looking at the plots and we previously hypothesized, i.e., the distributions are different.\n\n### 3.2 Mean Proximity Index","18eb6003":"This time and similarly as before p-values are extremely low (close to zero), more than necessary to assert that the two categories, high vs low, yield different gained yards distributions, with high Mean Aggression Index being associated with consistently higher yardage gain.\n\nLet us now visualize the list of season 2020 Return kicking plays sorted by MAI, with associated sub-metrics and yardage gain.","41751c96":"Even though responsive players are more likely to effectively keep pushing against opponent tacklers, other factors kick in when evaluating the actual effect of Proximity. Indeed, a low-responsiveness player can still be effective in defending the ball carrier and move opponent players away from the returner if able to exert a constant pressure on them; similarly, a high-responsiveness player not properly covering opponent players may lead the returning team to a fateful outcome. Despite having some relationship with MRI, the MPI thus takes into account playing factors of Return Kicking plays that are completely unrelated to MRI, as well.\n\nTo obtain the Mean Proximity Index, a clustering process is applied, with some assumptions that must hold in order for the whole picture to be consistent. \n- The number of clusters is equal to 11, with each player of the kicking team representing a single cluster centroid;\n- Each player of the receiving team is clustered and associated to a player of the kicking team (who represents his cluster's Centroid) after a certain time frame $\\epsilon$ (we set it at one second after the Return starts), and then re-clustered after every half a second to make the MPI account for eventual coverage variations;\n- Clustering is performed each second after a player of the receiving team (who will be the returner) takes the ball, using $x$ and $y$ features;\n- The Mean Proximity Index is obtained as a revisited Within-Cluster Sum of Squares (WCSS), i.e., the Within-Cluster Average Distance, averaged over all the time frames between $t_{0} + \\epsilon$ and $t_{end, \\sigma}$; the WCAD is obtained by averaging the Euclidean Distance between each receiving team player and the associated clustering centroid, i.e., the kicking team player to cover.\n\nHence, we obtain the Mean Proximity Index MPI as follows:\n\n<div style='text-align:center'><font size=3> $MPI = \\frac{1}{t_{end, \\sigma}-(t_{0}+\\epsilon)}\t\\sum_{t=t_{0}+\\epsilon}^{t_{end, \\sigma}}WCAD_{t}  ;$<\/font><\/div><br>\n\n<div style='text-align:center'><font size=3> $WCAD_{t} = \\frac{1}{n-\\delta}\\sum_{i=1}^{n-\\delta}\\frac{1}{m}\\sum_{j=1}^{m}\tEuclidean Distance(P_{i, j}^{r},P_{i}^{k})_{t};$<\/font><\/div><br>\n\n<div style='text-align:center'><font size=3> $\\implies MPI = \\frac{1}{t_{end, \\sigma}-(t_{0}+\\epsilon)}\t\\sum_{t=t_{0}+\\epsilon}^{t_{end, \\sigma}}\\frac{1}{n-\\delta}\\sum_{i=1}^{n-\\delta}\\frac{1}{m}\\sum_{j=1}^{m}\tEuclidean Distance(P_{i, j}^{r},P_{i}^{k})_{t}$<\/font><\/div><br>\n\nWhere:\n- $n - \\delta$ is the number of clusters with cardinality $|i|$ greater than or equal to 2; in fact, $n$ is the number of total clusters (i.e., 11), while $\\delta$ is the number of clusters inapplicable to account for MPI computation, i.e., clusters composed only by a kicking team player, representing an opponent player left uncovered;\n- $m$ is the number of total receiving players in a cluster that contains at least one receiving player; $j$ denotes a specific receiving player belonging to cluster number $i$;\n- $r$  superscript denotes the Player of the receiving team belonging to cluster $i$, hence assigned to covering the Player of the kicking team, denoted by $k$ superscript, belonging to the same cluster;\n- $t_{end,\\sigma}$ denotes the end of tracking data processing for assessment purposes: if the number of time frames after $t_{0} + \\epsilon$ is lower than $\\sigma$, then it represents the end of the play; if there are more than $\\sigma$ time frames available, then the metric will only be computed until time frame $t_{end, \\sigma}$ is reached. We will set the time frame limit factor $\\sigma$ equal to 50 time frames;\n- $\\epsilon$ represents a lagging factor that allows to take into account the desired metrics only from a relevant moment of the play onwards; $t_{0} + \\epsilon$ thus indicates the starting point of metrics recording, when players reacted to the start of the return and acted accordingly.\n\nNote: for MPI, the lower, the better.\n\n![Fig1.PNG](attachment:14b39fcd-8975-4cfc-8f71-19bb893927c7.PNG)\n","82553176":"# 2. Building the MAI: Mean Aggression Index\n\n\n\n## 2.1 Mean Responsiveness Index: MRI\n\nThe Mean Responsiveness Index is mainly about the Acceleration attributes of players in Return Kicking plays. We can define it as follows:\n\n<div style='text-align:center'><font size=4> $MRI = \\frac{1}{N}\t\\sum_{i=1}^{N}max_{a_{i,t}}, t \\in [t_{0}, t_{end}] $<\/font><\/div><br>\n\n\nWhere:\n- $N$ is the Number of non-ball carrier players in the returning team (i.e., 10);\n- $i$ represents a player of the Team;\n- $t$ represents a specific second of a play;\n- $t_{0}$ represents the time at which the receiving team takes the ball and starts the return;\n- $t_{end}$ denotes the end of the play;\n- $a$ represents the acceleration feature of player $i$ at time $t$.\n\nEach Responsiveness Index represents the maximum acceleration reached by a player during a play and, more specifically, between the return start $t_{0}$ and its end $t_{end}$; the MRI averages the Responsiveness Indices of all the players of a Special Team. The rationale behind including this metric relies on the implications a powerful acceleration during the Return timeframe (between $t_{0}$ and $t_{end}$) has in terms of Responsiveness: a defensive player with an explosive acceleration interposing himself between the ball carrier and a dangerous opponent player might prevent a fatal tackle to occur, and this can hugely affect the result of a play.","f4e1e9bb":"# Appendix\n\nThe below hidden cell contains all the code used to process data, carry out statistical tests, and realize plots\/tables.\n","611cf3db":"Much more evident than before, both Box plots and Density plots denote a clear distributional difference. The t-test of the difference of means between low MPI and high MPI populations (i.e., plays) confirms the validity of this sub-metric.\n\n### 3.3 Mean Positioning Suitability Index","d09adbca":"### Mean Aggression Index\n\nLet us now move on to the Mean Aggression Index. Based on the previous results, we can set the coefficients of each normalized sub-metric as follows: <br>$\\gamma_{MRI} = 0.2;$<br>$\\lambda_{MPSI} = 0.45;$<br>$\\phi_{MPI} = 0.35$.<br>","9c46dace":"## 2.2 Mean Proximity Index: MPI","1189c417":"### 2.3 Mean Positioning Suitability Index: MPSI\n\nA receiving player might exhibit high proximity values (low MPI) for the great majority of a return, but this may not be enough if the tackling player still has a crack on the ball carrier; the Mean Positioning Suitability Index aims at quantifying how much suitable, in terms of ball carrier protection, the positioning of receiving players are during return kicking plays, regardless of their proximity to the opponent players they are covering.\n\nWe obtain the metric as follows:\n\n<div style='text-align:center'><font size=2> $MPSI = \\frac{1}{t_{end, \\sigma}-(t_{0}+\\epsilon)}\\sum_{t=t_{0}+\\epsilon}^{t_{end, \\sigma}}\t\\frac{1}{c}\t\\sum_{h=1}^{c}PSI_{h,t};  $<\/font><\/div><br>\n\n<div style='text-align:center'><font size=2> $PSI_{h,t} = cos^{-1}\\frac{EuclideanDistance(P_{h}^{k}, P_{h}^{r})^{2}_{t} + EuclideanDistance(P^{b}, P_{h}^{r})^{2}_{t} - EuclideanDistance(P^{b}, P_{i}^{k})^{2}_{t}}{2EuclideanDistance(P_{h}^{k}, P_{h}^{r})_{t} \\times EuclideanDistance(P^{b}, P_{h}^{r})_{t}};  $<\/font><\/div><br>\n\n<div style='text-align:center'><font size=2> $\\implies MPSI = \\frac{1}{t_{end, \\sigma}-(t_{0}+\\epsilon)}\\sum_{t=t_{0}+\\epsilon}^{t_{end, \\sigma}}\t\\frac{1}{c}\t\\sum_{h=1}^{c}cos^{-1}(\\frac{EuclideanDistance(P_{h}^{k}, P_{h}^{r})^{2}_{t} + EuclideanDistance(P^{b}, P_{h}^{r})_{t}^{2} - EuclideanDistance(P^{b}, P_{h}^{k})^{2}_{t}}{2EuclideanDistance(P_{h}^{k}, P_{h}^{r})_{t} \\times EuclideanDistance(P^{b}, P_{h}^{r})_{t}})   $<\/font><\/div><br>\n\nWhere:\n- $b$ superscript denotes the ball carrier player;\n- $c$ represents the set of all possible combinations of receiving team player and kicking team player, established in the clustering process;\n- $r$ and $k$ superscripts denote, respectively, the player of the receiving team and the player of the kicking team belonging to the combination number $h$ established in the clustering process; unlike for the MPI, PSI will not be averaged between all the receiving players of the same cluster this time;\n\nThe idea behind the MPSI basically consists in taking, for each couple Receiving Player $P_{i}^{r}$-Kicking Team Player to be covered $P_{i}^{k}$, the angle that forms between the straight line that connects the receiving team ball carrier $P^{b}$ and the given receiving player $P_{i}^{r}$, and the straight line connecting the receiving player $P_{i}^{r}$ to the kicking team player to be covered $P_{i}^{k}$. Given that the straight lines represent distances we can derive from tracking data, trigonometry allows us to easily derive our desired angle. As the following figure shows, the closer the angle is to 180, the more suitable the receiving player's position is to defend the ball carrier from any eventual intrusion carried out by the kicking team player; any change that leads to a less suitable positioning leads to a decrease in the angle, hence in the PSI.\n\n![Fig2.png](attachment:02bd9b9f-64a5-4401-9af2-2cbb97efc414.png)","400ed689":"# 1. Introduction\n\nSpecial Teams are composed by players who are on the field during kicking plays. We are thus dealing with kickers, punters, long-snappers, and other roles mainly involved in kick and return activities (including coverage, an aspect that we will investigate carefully).\nThe possible plays that are carried out by Special Teams are Kickoff, Punt, Field Goal, and Extra Point; for our purposes, we will take into account Kickoffs and Punts with Return outcome. In these plays, the receiving team gets the ball and advances through the field, trying a touchdown; to avoid this, the kicking team tries to tackle the ball carrier, hence the receiving team is entitled to protect the ball carrier by creating real barriers that cover opponent players and prevent them to tackle the returning player. \n\nWhat we are going to explore is the impact an aggressive defense to protect the ball carrier in Return-outcome Kicking Plays has on the play result (i.e., on the number of yards gained by the returning team), and how to actually quantify such aggressive defense through the adoption of a 3-step assessment metric.","3cf91887":"# 3. Experiments and Validation\n\nLet us now carry out an analysis of the developed metrics and how these metrics practically affect the Return Kicking plays' result, i.e., the yards gained by the returning team. Returns indeed aim at gaining ground that is measured in yards, and a higher yardage gain usually represents a better Return outcome. We will thus make use of statistical techniques to make experiments and highlight distributive differences in the data (e.g., Yards gain in high MRI plays vs Yards gain in low MRI plays) to validate, using data from all the seasons from 2018 to 2020, each of the proposed sub-metrics and, ultimately, the MAI.\n","1ba7981a":"Once again, distributional differences between low and high MPSI hold, with high MPSI being associated with higher gain in terms of yardage and a subsequent suitability of MPSI sub-metric for our purposes.","42b75bc0":"# 4. Conclusions and Potential Developments \n\nWe developed an assessment framework that comprehensively accounts for the various facets of Return Kicking plays involved in aggressive defense practices, ranging from player-specific responsiveness to positional features. The MAI metric is thus composed by three sub-metrics, each of which represents a specific feature that complements and compensates the weaknesses of the others: an example is the MPI that accounts for proximity but disregards positioning, that is then captured by MPSI. MAI, together with its component sub-metrics, revealed to be effective in quantifying and evaluating aggressive defense carried out by returning team players to protect the ball returner, and its modular nature enables a better understanding of returning team performance and this, in turn, has the potential to enact the development of better coverage schemes and aggressive defense strategies. It comes with a wide range of potential application scenarios and possible developments to make it more suitable to case-specific purposes: a significant example is the possibility of computing the MAI in a Playerwise fashion, evaluating each player's contribution to the Teamwise MAI we saw so far and investigating components to highlight individual players' strengths and weaknesses; this way, MAI would also allow to rank special teams' players, in the setting of return kicking plays, according to their aggressive defense performance."}}