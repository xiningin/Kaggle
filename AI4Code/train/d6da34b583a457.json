{"cell_type":{"05869d31":"code","75c2b298":"code","4313d9dd":"code","84a35a37":"code","6fa5fd2a":"code","48c6178c":"code","a6f192a0":"code","367e040a":"code","09c4181b":"code","a18095f7":"code","7111b3c4":"code","96cd514a":"code","41d6b0fa":"code","0cac39b1":"code","22cf0763":"code","21435619":"code","54073e2c":"code","3d084cdd":"code","bda52f6b":"code","52820811":"code","18ffa698":"code","30fe8cdf":"code","e4a41e82":"code","8e2a3f41":"code","19af23cd":"code","c7bab51b":"code","d5e4e40e":"code","57f9cacf":"code","66c80772":"code","ac6e8f61":"code","52f94b53":"code","980bb9c1":"code","21d72a24":"code","c501168b":"code","a2be3e37":"code","40590081":"code","7dc5d7f7":"code","c33f0ae7":"code","1b7dc239":"code","f1c6c875":"code","23595211":"code","348de590":"code","a70d647e":"code","a0f3a93f":"code","a9ef3fb2":"code","55b9d527":"code","e63807db":"code","cdd1d089":"markdown","bf6348fb":"markdown","f5c8e3a4":"markdown","cadfbdee":"markdown","8c5c3e31":"markdown","a24f6aed":"markdown","f73531d5":"markdown","189145d6":"markdown","20cba07a":"markdown","f091988f":"markdown","c5e1f250":"markdown","7b515e0b":"markdown","2dfa020b":"markdown","cb58f19d":"markdown","fc0d946b":"markdown","7ee826b2":"markdown","a46e1739":"markdown","ea2c5b99":"markdown","60fbccea":"markdown","dd441c55":"markdown","013c309e":"markdown","9ae6e59c":"markdown","40850dfa":"markdown","62e4b03f":"markdown","f803307e":"markdown","3aee809d":"markdown","de098cbf":"markdown","58e606d9":"markdown","0dd38a67":"markdown","4d8dfd14":"markdown","37f64c9a":"markdown","9d3561e4":"markdown","71517db4":"markdown","19f2e6e6":"markdown","2f164236":"markdown"},"source":{"05869d31":"import pandas as pd\nimport numpy as np\nimport datetime as dt\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\n\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.express as px\n\nimport plotly.graph_objs as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nfrom pprint import pprint\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn import metrics\nimport fbprophet\nfrom fbprophet.plot import plot_plotly, plot_components_plotly\nimport datetime\nimport os","75c2b298":"df_pg1 = pd.read_csv('..\/input\/solar-power-generation-data\/Plant_1_Generation_Data.csv')\ndf_pg2 = pd.read_csv('..\/input\/solar-power-generation-data\/Plant_2_Generation_Data.csv')\ndf_ws1 = pd.read_csv('..\/input\/solar-power-generation-data\/Plant_1_Weather_Sensor_Data.csv')\ndf_ws2 = pd.read_csv('..\/input\/solar-power-generation-data\/Plant_2_Weather_Sensor_Data.csv')","4313d9dd":"#Plant 1\ndf_pgen1=pd.read_csv('..\/input\/solar-power-generation-data\/Plant_1_Generation_Data.csv')\ndf_sen1=pd.read_csv('..\/input\/solar-power-generation-data\/Plant_1_Weather_Sensor_Data.csv')","84a35a37":"df_pgen1","6fa5fd2a":"df_sen1","48c6178c":"# Power Generation Plant 1\n\ndf_pgen1['DATE_TIME'] = pd.to_datetime(df_pgen1['DATE_TIME'],format = '%d-%m-%Y %H:%M')\ndf_pgen1['DATE'] = df_pgen1['DATE_TIME'].apply(lambda x:x.date())\ndf_pgen1['TIME'] = df_pgen1['DATE_TIME'].apply(lambda x:x.time())\ndf_pgen1['DATE'] = pd.to_datetime(df_pgen1['DATE'],format = '%Y-%m-%d')\ndf_pgen1['HOUR'] = pd.to_datetime(df_pgen1['TIME'],format='%H:%M:%S').dt.hour\ndf_pgen1['MINUTES'] = pd.to_datetime(df_pgen1['TIME'],format='%H:%M:%S').dt.minute\ndf_pgen1['DC_POWER'] = df_pgen1[['DC_POWER']].apply(lambda arr: np.divide(arr,10))","a6f192a0":"# Weather Sensor Data 1\n\ndf_sen1['DATE_TIME'] = pd.to_datetime(df_sen1['DATE_TIME'],format = '%Y-%m-%d %H:%M')\ndf_sen1['DATE'] = df_sen1['DATE_TIME'].apply(lambda x:x.date())\ndf_sen1['TIME'] = df_sen1['DATE_TIME'].apply(lambda x:x.time())\ndf_sen1['DATE'] = pd.to_datetime(df_sen1['DATE'],format = '%Y-%m-%d')\ndf_sen1['HOUR'] = pd.to_datetime(df_sen1['TIME'],format='%H:%M:%S').dt.hour\ndf_sen1['MINUTES'] = pd.to_datetime(df_sen1['TIME'],format='%H:%M:%S').dt.minute","367e040a":"# Data Preprocessing\n## Here we make the DATE_TIME column (which right now contains string values) datetimeobjects\ndf_pg1['DATE_TIME'] = pd.to_datetime(df_pg1['DATE_TIME'], format = '%d-%m-%Y %H:%M')\ndf_pg2['DATE_TIME'] = pd.to_datetime(df_pg2['DATE_TIME'], format = '%Y-%m-%d %H:%M')\ndf_ws1['DATE_TIME'] = pd.to_datetime(df_ws1['DATE_TIME'], format = '%Y-%m-%d %H:%M')\ndf_ws2['DATE_TIME'] = pd.to_datetime(df_ws2['DATE_TIME'], format = '%Y-%m-%d %H:%M')\n## Data Cleaning: Here we remove those columns which do not interest us\ndf_pg1 = df_pg1.drop(columns = 'PLANT_ID')\ndf_pg2 = df_pg2.drop(columns = 'PLANT_ID')\ndf_ws1 = df_ws1.drop(columns = ['PLANT_ID', 'SOURCE_KEY'])\ndf_ws2 = df_ws2.drop(columns = ['PLANT_ID', 'SOURCE_KEY'])\n## We will now merge data for same plants: df_pg1 with df_ws1 and df_pg2 with df_ws2\ndf1 = pd.merge(df_pg1, df_ws1, on = 'DATE_TIME', how = 'left')\ndf2 = pd.merge(df_pg2, df_ws2, on = 'DATE_TIME', how = 'left')\n## We will create a new column for DATE and TIME so that the code remains simple\ndf1['DATE'] = df1['DATE_TIME'].dt.date\ndf2['DATE'] = df2['DATE_TIME'].dt.date\ndf1['TIME'] = df1['DATE_TIME'].dt.time\ndf2['TIME'] = df2['DATE_TIME'].dt.time\n## Filling in empty values with approximate assumptions\nn = (27.862188+28.361993)\/2\ndf1['IRRADIATION'] = df1['IRRADIATION'].fillna(n)\n\nprint('Station 1 value count-')\nprint('\\tExpected values: ' + str(22*34*23*4))\nprint('\\tValues received: ' + str(df1.shape[0]))\nprint('Station 2 value counts-')\nprint('\\tExpected values: ' + str(22*34*23*4))\nprint('\\tValues received: ' + str(df2.shape[0]))","09c4181b":"tmp1 = df1.groupby('DATE', as_index = False).agg({'DC_POWER': 'mean', 'AC_POWER': 'mean', 'MODULE_TEMPERATURE': 'mean', 'AMBIENT_TEMPERATURE': 'mean', 'IRRADIATION': 'mean'})\ntmp2 = df2.groupby('DATE', as_index = False).agg({'AC_POWER': 'mean', 'DC_POWER': 'mean', 'MODULE_TEMPERATURE': 'mean', 'AMBIENT_TEMPERATURE': 'mean', 'IRRADIATION': 'mean'})\nfig = go.Figure()\nfig.add_trace(go.Scatter(x = tmp1.DATE, y = tmp1.DC_POWER\/10-tmp1.AC_POWER, mode = 'lines', name = 'Station 1-Loss'))\nfig.add_trace(go.Scatter(x = tmp2.DATE, y = tmp2.DC_POWER-tmp2.AC_POWER, mode = 'lines', name = 'Station 2-Loss'))\nfig.update_layout(title = 'Power Loss from Mean DC to Mean AC', xaxis_title = 'Dates', yaxis_title = 'Loss')\nfig.show()\n\nfig = make_subplots(rows = 1, cols = 2)\nfig.add_trace(go.Scatter(x = tmp1.DATE, y = tmp1.DC_POWER\/10, mode = 'lines', name = 'Station 1-DC'), row = 1, col = 1)\nfig.add_trace(go.Scatter(x = tmp2.DATE, y = tmp2.DC_POWER, mode = 'lines', name = 'Station 2-DC'), row = 1, col = 1)\nfig.add_trace(go.Scatter(x = tmp1.DATE, y = tmp1.DC_POWER\/10-tmp1.AC_POWER, mode = 'lines', name = 'Station 1-Loss'), row = 1, col = 2)\nfig.add_trace(go.Scatter(x = tmp2.DATE, y = tmp2.DC_POWER-tmp2.AC_POWER, mode = 'lines', name = 'Station 2-Loss'), row = 1, col = 2)\nfig.update_layout(title = 'Comparison Plot between Power lost vs Power Generated', xaxis_title = 'Dates', yaxis_title = 'Power')\nfig.show()","a18095f7":"fig = go.Figure()\nfig.add_trace(go.Scatter(x = tmp1.DATE, y = tmp1.AC_POWER, mode = 'lines', name = 'STATION 1'))\nfig.add_trace(go.Scatter(x = tmp2.DATE, y = tmp2.AC_POWER, mode = 'lines', name = 'STATION 2'))\nfig.update_layout(title = 'AC Power Output Comparison Plot', xaxis_title = 'DATE\/TIME', yaxis_title = 'Power Output')\nfig.show()\n\nfig = make_subplots(rows = 2, cols = 2)\nfig.add_trace(go.Scatter(x = tmp1.DATE, y = tmp1.IRRADIATION, mode = 'lines', name = 'IRR-ST1'), row = 1, col = 1)\nfig.add_trace(go.Scatter(x = tmp2.DATE, y = tmp2.IRRADIATION, mode = 'lines', name = 'IRR-ST2'), row = 1, col = 2)\nfig.add_trace(go.Scatter(x = tmp1.DATE, y = tmp1.MODULE_TEMPERATURE, mode = 'lines', name = 'MOD-ST1'), row = 2, col = 1)\nfig.add_trace(go.Scatter(x = tmp2.DATE, y = tmp2.MODULE_TEMPERATURE, mode = 'lines', name = 'MOD-ST2'), row = 2, col = 2)\nfig.add_trace(go.Scatter(x = tmp1.DATE, y = tmp1.AMBIENT_TEMPERATURE, mode = 'lines', name = 'AMB-ST1'), row = 2, col = 1)\nfig.add_trace(go.Scatter(x = tmp2.DATE, y = tmp2.AMBIENT_TEMPERATURE, mode = 'lines', name = 'AMB-ST2'), row = 2, col = 2)\nfig.show()","7111b3c4":"tmp1 = df1.groupby(['SOURCE_KEY', 'DATE'], as_index = False).agg({'DC_POWER': 'mean', 'AC_POWER': 'mean'})\ntmp2 = df1.groupby(['SOURCE_KEY', 'TIME'], as_index = False).agg({'DC_POWER': 'mean', 'AC_POWER': 'mean'})\nfig = make_subplots(rows = 1, cols = 2)\nkeys = df1['SOURCE_KEY'].unique()\nfor key in keys:\n    fig.add_trace(go.Scatter(x = tmp1[tmp1['SOURCE_KEY'] == key].DATE, y = tmp1[tmp1['SOURCE_KEY'] == key].AC_POWER, mode = 'lines', name = key), row = 1, col = 1)\n    fig.add_trace(go.Scatter(x = tmp2[tmp2['SOURCE_KEY'] == key].TIME, y = tmp2[tmp2['SOURCE_KEY'] == key].AC_POWER, mode = 'lines', name = key), row = 1, col = 2)\nfig.update_layout(title = 'Station 1')\nfig.show()\n\ntmp1 = df2.groupby(['SOURCE_KEY', 'DATE'], as_index = False).agg({'DC_POWER': 'mean', 'AC_POWER': 'mean'})\ntmp2 = df2.groupby(['SOURCE_KEY', 'TIME'], as_index = False).agg({'DC_POWER': 'mean', 'AC_POWER': 'mean'})\nfig = make_subplots(rows = 1, cols = 2)\nkeys = df2['SOURCE_KEY'].unique()\nfor key in keys:\n    fig.add_trace(go.Scatter(x = tmp1[tmp1['SOURCE_KEY'] == key].DATE, y = tmp1[tmp1['SOURCE_KEY'] == key].AC_POWER, mode = 'lines', name = key), row = 1, col = 1)\n    fig.add_trace(go.Scatter(x = tmp2[tmp2['SOURCE_KEY'] == key].TIME, y = tmp2[tmp2['SOURCE_KEY'] == key].AC_POWER, mode = 'lines', name = key), row = 1, col = 2)\nfig.update_layout(title = 'Station 2')\nfig.show()\n\ntmp1 = df1.groupby(['SOURCE_KEY', 'DATE'], as_index = False).agg({'DC_POWER': 'mean', 'AC_POWER': 'mean'})\ntmp2 = df2.groupby(['SOURCE_KEY', 'DATE'], as_index = False).agg({'DC_POWER': 'mean', 'AC_POWER': 'mean'})\nfig = make_subplots(rows = 1, cols = 2, specs=[[{'type': 'domain'}, {'type': 'domain'}]])\nfig.add_trace(go.Pie(labels = tmp1['SOURCE_KEY'], values = tmp1['DC_POWER']\/10, name = 'DC Production'), 1, 1)\nfig.add_trace(go.Pie(labels = tmp1['SOURCE_KEY'], values = tmp1['AC_POWER'], name = 'AC Output'), 1, 2)\nfig.update_traces(hoverinfo = 'label+percent+name')\nfig.update_layout(title_text = 'Station 1: Pie Chart Comparison')\nfig.show()\nfig = make_subplots(rows = 1, cols = 2, specs=[[{'type': 'domain'}, {'type': 'domain'}]])\nfig.add_trace(go.Pie(labels = tmp2['SOURCE_KEY'], values = tmp2['DC_POWER'], name = 'DC Production'), 1, 1)\nfig.add_trace(go.Pie(labels = tmp2['SOURCE_KEY'], values = tmp2['AC_POWER'], name = 'AC Output'), 1, 2)\nfig.update_traces(hoverinfo = 'label+percent+name')\nfig.update_layout(title_text = 'Station 2: Pie Chart Comparison')\nfig.show()","96cd514a":"X_train1, X_test1, Y_train1, Y_test1 = train_test_split(df1[['IRRADIATION']], df1['DC_POWER']\/10, test_size = 0.3, random_state = 0)\nX_train2, X_test2, Y_train2, Y_test2 = train_test_split(df2[['IRRADIATION']], df2['DC_POWER'], test_size = 0.3, random_state = 0)\nlin1 = LinearRegression()\nlin2 = LinearRegression()\nlin1.fit(X_train1, Y_train1)\nlin2.fit(X_train2, Y_train2)\nY_pred1 = lin1.predict(X_test1)\nY_pred2 = lin2.predict(X_test2)\nprint('Train Accuracy')\nprint('\\tModel 1 MAE: ', metrics.mean_absolute_error(Y_train1, lin1.predict(X_train1)))\nprint('\\tModel 2 MAE: ', metrics.mean_absolute_error(Y_train2, lin2.predict(X_train2)))\nprint('Test Accuracy')\nprint('\\tModel 1 MAE: ', metrics.mean_absolute_error(Y_test1, Y_pred1))\nprint('\\tModel 2 MAE: ', metrics.mean_absolute_error(Y_test2, Y_pred2))","41d6b0fa":"tmp1 = df1.groupby('DATE', as_index = False).agg({'IRRADIATION': 'mean'})\ntmp2 = df2.groupby('DATE', as_index = False).agg({'IRRADIATION': 'mean'})\ntmp1 = df1.rename(columns = {'DATE': 'ds', 'IRRADIATION': 'y'})\ntmp2 = df2.rename(columns = {'DATE': 'ds', 'IRRADIATION': 'y'})\nprop1 = fbprophet.Prophet(changepoint_prior_scale = 0.6)\nprop2 = fbprophet.Prophet(changepoint_prior_scale = 0.6)\nprop1.fit(tmp1)\nprop2.fit(tmp2)\nforecast1 = prop1.make_future_dataframe(periods = 15, freq = 'D')\nforecast1 = prop1.predict(forecast1)\nforecast2 = prop2.make_future_dataframe(periods = 15, freq = 'D')\nforecast2 = prop2.predict(forecast2)","0cac39b1":"yhat1 = forecast1['yhat'].values.reshape(-1, 1)\nyhat2 = forecast2['yhat'].values.reshape(-1, 1)\nypred1 = lin1.predict(yhat1)\nypred2 = lin2.predict(yhat2)\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x = forecast1['ds'], y = forecast1['yhat'], mode = 'lines', name = 'Station 1'))\nfig.add_trace(go.Scatter(x = forecast2['ds'], y = forecast2['yhat'], mode = 'lines', name = 'Station 2'))\nfig.update_layout(title = 'Forecast for next 15 days', xaxis_title = 'Date', yaxis_title = 'DC Production')\nfig.show()\n\nfig = go.Figure()\nfig.add_trace(go.Scatter(x = forecast1['ds'], y = ypred1, mode = 'lines', name = 'Station 1'))\nfig.add_trace(go.Scatter(x = forecast2['ds'], y = ypred2, mode = 'lines', name = 'Station 2'))\nfig.update_layout(title = 'Forecast for next 15 days', xaxis_title = 'Date', yaxis_title = 'DC Production')\nfig.show()","22cf0763":"r_left = pd.merge(df_pgen1,df_sen1,on='DATE_TIME',how='left')\nr_left","21435619":"r_left.isnull().sum()","54073e2c":"null_data1 = r_left[r_left.isnull().any(axis=1)]\nnull_data1","3d084cdd":"plt.figure(figsize=(20,10))\nplt.plot(r_left['IRRADIATION'],r_left['DC_POWER'],marker='o',linestyle='',alpha=0.5,label='DC Power')\nplt.legend()\n\nplt.xlabel('Irradiation')\nplt.ylabel('DC Power')","bda52f6b":"plt.figure(figsize=(20,10))\nplt.plot(r_left['MODULE_TEMPERATURE'],r_left['DC_POWER'],marker='o',linestyle='',alpha=0.5,label='DC Power')\nplt.legend()\n\nplt.xlabel('Module temperature')\nplt.ylabel('DC Power')","52820811":"data_summary = df_pgen1.groupby(['SOURCE_KEY','DATE']).agg(READINGS = ('TOTAL_YIELD','count'),\n                                                         INV = ('SOURCE_KEY',max),\n                                                        DATE = ('DATE',max))\nplt.scatter(data_summary['DATE'],data_summary['READINGS'])\nplt.xticks(rotation=90)","18ffa698":"plt.figure(figsize=(12,8))\nfor inv in data_summary['INV'].unique():\n    plt.scatter(data_summary[data_summary['INV']==inv]['DATE'],\n            data_summary[data_summary['INV']==inv]['READINGS'],label=inv,s = 80)\nplt.legend()\nplt.title('Readings vs Date')\nplt.xlabel('Date')\nplt.ylabel('Number of Readings')\nplt.show()","30fe8cdf":"# FIlling Irradiation column with 0 for null values\nr_left['IRRADIATION'] = r_left['IRRADIATION'].fillna(0) \nr_left['AMBIENT_TEMPERATURE'] = r_left['AMBIENT_TEMPERATURE'].fillna(0) \nr_left['MODULE_TEMPERATURE'] = r_left['MODULE_TEMPERATURE'].fillna(0) \n\n#x = r_left.iloc[:,[12]].values\nx = r_left.iloc[:,15:16].values\ny = r_left.iloc[:,3].values\nr_left","e4a41e82":"from sklearn.model_selection import train_test_split\nx_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2,random_state=0)\n\nfrom sklearn.linear_model import LinearRegression\nmodel = LinearRegression()\n\nmodel.fit(x_train,y_train)","8e2a3f41":"y_pred = model.predict(x_test)\n# Visualization of Best Fit Line\n# Training Data\nplt.scatter(x_train,y_train,s=1)\nplt.scatter(x_train,model.predict(x_train),s=1)\nplt.show()","19af23cd":"# Testing Data\nplt.scatter(x_test,y_test,s=1)\nplt.scatter(x_test,model.predict(x_test),s=1)\nplt.show()","c7bab51b":"# Plotting for Predicted vs Real Output in the test data\nplt.scatter(y_pred,y_test,s=1)","d5e4e40e":"df1 = pd.DataFrame({'Actual':y_test,'Predicted':y_pred})\ndf2 = df1.head(10)\n\n# Research\nimport seaborn as sns\nsns.regplot(x='Actual',y='Predicted',data=df1)\nplt.show()","57f9cacf":"from sklearn.metrics import r2_score,mean_squared_error\nprint(mean_squared_error(y_pred,y_test))","66c80772":"day_summary = df_sen1.groupby('DATE').agg(TOTAL_IRRADIANCE=('IRRADIATION',sum),DATE=('DATE',max))\nday_summary","ac6e8f61":"day_summary = day_summary.rename(columns={'DATE':'ds','TOTAL_IRRADIANCE':'y'})\nday_summary.info()","52f94b53":"import fbprophet\nop = fbprophet.Prophet(changepoint_prior_scale=0.25)\nop.fit(day_summary)","980bb9c1":"# Make a future possible prediction (df) for 1 month\nforecast = op.make_future_dataframe(periods = 30,freq='D')\nforecast = op.predict(forecast)","21d72a24":"op.plot(forecast,xlabel='Date',ylabel='Irradiation')\nplt.title('Irradiation Prediction');","c501168b":"forecast['ds'].value_counts()","a2be3e37":"df_new = df_sen1[['DATE_TIME','IRRADIATION']]","40590081":"df_new","7dc5d7f7":"df_new = df_new.rename(columns={'DATE_TIME':'ds','IRRADIATION':'y'})\ndf_new","c33f0ae7":"import fbprophet\nop = fbprophet.Prophet(changepoint_prior_scale=0.25)\nop.fit(df_new)","1b7dc239":"# Make a future possible prediction (df) for H Hours\nforecast = op.make_future_dataframe(periods = 300,freq='H')\nforecast = op.predict(forecast)","f1c6c875":"op.plot(forecast,xlabel='Date',ylabel='Irradiation')\nplt.title('Irradiation Prediction');","23595211":"op.plot_components(forecast);","348de590":"# correlation matrix\ncor = r_left.drop(['PLANT_ID_x','PLANT_ID_y'],axis=1)\ncor = cor.corr()\ncor","a70d647e":"# plotting correlations on a heatmap\n\n# figure size\nplt.figure(figsize=(8,4))\n\n# heatmap\nsns.heatmap(cor, cmap=\"YlGnBu\", annot=True)\nplt.show()","a0f3a93f":"plt.figure(figsize=(14,7))\nplt.xlabel(\"DATE\")\nplt.ylabel(\"DC Power\")\nplt.title(\"1BY6WEcLGh8j5v7 over Days\")\ndf=df_pgen1[df_pgen1['SOURCE_KEY']=='ZoEaEvLYb1n2sOq'][['DATE','DC_POWER',\"AC_POWER\"]]\ndf=df.groupby(\"DATE\").sum()\nsns.lineplot(data=df, palette=\"tab10\", linewidth=2.5)\nplt.show()","a9ef3fb2":"df=df_pgen1[df_pgen1['DATE']=='2020-05-15\t'][['DATE','DC_POWER',\"AC_POWER\",\"TIME\"]]\na=[]\nfor t in df[\"TIME\"]:\n    a.append(t.strftime(\"%H:%M:%S\"))","55b9d527":"fig = px.line(df, x=a, y=[df[\"DC_POWER\"]])\nfig.show()","e63807db":"fig = px.line(df, x=a, y=[df[\"AC_POWER\"]])\nfig.show()","cdd1d089":"### ***A project by Piyush Tripathi and Astitva Prakash, under the mentorship of Azib Hasan*** ","bf6348fb":"## **Importing Libraries**","f5c8e3a4":"![image.png](attachment:image.png)","cadfbdee":"## **Optimizing the DataFrame**","8c5c3e31":"# **Questions explored :**","a24f6aed":"## **Examining Dataframes**","f73531d5":"![image.png](attachment:image.png)","189145d6":"# **Business Value**","20cba07a":"## **Analyzing Single Invertor for Failure**","f091988f":"# **Conclusion**","c5e1f250":"### One of the main challenges in solar forecasting methods is developing new tools and practices that manage the variability and uncertainty of solar power.\n\n* How environmental data can augment the business value of the analytics?\n* Can historical telemetry data on inverters be used to diagnose failures?\n* Which predictive models help in predicting power generated and system failures?","7b515e0b":"# **Prerequisites**","2dfa020b":"### Failure Ratios","cb58f19d":"# **Cleaning Data**","fc0d946b":"### Solar professionals are highly interested in minimizing Total Costs of Ownership (TCO). Inverter manufacturers can help meet their needs by offering analytics that provide early detection of degradation and early prediction of failure. These analytics can provide valuable lead time for performing maintenance and, if necessary, for acquiring and installing a replacement device or the right parts, to minimize maintenance costs and prevent days of lost solar energy production. Actual monetary benefits are situational and can be calculated based on factors such as days of lead time, whether hot spares are available, and avoidance of multiple service trips by bringing replacements for the most-likely components. Other factors include regulatory penalties and the value of electricity in the region.","7ee826b2":"* #### Approach 1","a46e1739":"![image.png](attachment:image.png)","ea2c5b99":"# ***Improving Solar Production***","60fbccea":"### We start by selecting a random generator and looking over its behaviour over time.","dd441c55":"#### These graphs present some interesting ideas we wanted to explore, but couldn't due to lack of data.","013c309e":"### How Devices may fail","9ae6e59c":"![image.png](attachment:image.png)","40850dfa":"## **Importing Datasets**","62e4b03f":"### Graphing DC and AC Power Generation to look fort peak Times","f803307e":"![image.png](attachment:image.png)","3aee809d":"* ### Estimation of power production, based on factors such as seasonality and current irradiance, may be used for detecting defects in the solar plant. Estimated DC or AC energy can be compared to the actual values measured by inverters during the same time period. Significant deviations or patterns may indicate possible defects in the solar plant (e.g., degradation or sudden failure in one or more pieces of equipment,from the panels to inverters).\n\n* ### Forecasts of power production may be used to reduce inherent uncertainties associated with variable renewable energy generation. Grid operators today rely upon forecasts of both load and generation to balance electricity supply and demand. Accurate forecasts not only support the safe and reliable operation of the grid, but also encourage cost-effective operations by improving the scheduling of generation and reducing the use of costly \u2019spinning reserves\u2019\n\n* ### Since photovoltaic equipment (often including the inverter) is constantly exposed to atmospheric conditions, identifying relationships between weather exposure and device failure is a critical step in developing more resilient equipment and for understanding degradation, performance, or failures. For instance, field engineers servicing solar inverters have noted that device failures seem to occur more frequently after intense lightning storms","de098cbf":"* ### Our goal for these studies was to explore how predictions of solar inverter and plant health and production can be improved by applying data science techniques\n* ### These analytics enable detection of degradation and improvements in production of solar energy\n* ### We can leverage Machine Learning and data science to better understand and classify potential root causes of device malfunction such as lightning, booster error, or grid inrush.","58e606d9":"* ### Better understanding and prediction of production of renewable energy\n* ### Improved accuracy and lead time for detection of degradation and diagnosis of failures\n* ### Making these new analytics and the associated data readily accessible to end users and to internal customers who are not data science experts themselves","0dd38a67":"### Pairwise scatter plots between coefficient estimates suggesting collinearity between {temperature, precipitation} and humidity.","4d8dfd14":"# **Working**","37f64c9a":"# **Objectives**","9d3561e4":"![image.png](attachment:image.png)","71517db4":"# **Furthur Exploration**","19f2e6e6":"## **Training Model**","2f164236":"* #### Approach 2"}}