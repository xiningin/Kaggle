{"cell_type":{"082b0f85":"code","5b94a2dc":"code","40956294":"code","e8ad6e7e":"code","91457790":"code","70b452c4":"code","18e19fe7":"code","adc256aa":"code","c4702fbc":"code","c51a36ef":"code","4bcdebb8":"code","ae300970":"code","ee850c37":"code","d08b3daa":"code","a3c85cf2":"code","e8139bdc":"code","92dc6ba9":"code","7a36c084":"markdown","674d95aa":"markdown","16a8fbdb":"markdown","de1c922c":"markdown","dfd04971":"markdown","fa378c91":"markdown","b7b5a0bf":"markdown","c9497507":"markdown","852e4a08":"markdown","6e622b77":"markdown","b6bde148":"markdown","dff5360f":"markdown"},"source":{"082b0f85":"import numpy as np\nimport pandas as pd\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt  \n\nfrom timeit import default_timer as timer\nfrom sklearn import preprocessing\n\n#!pip install ultimate\n#from ultimate.mlp import MLP \n\nfrom keras import regularizers\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.callbacks import ModelCheckpoint, LearningRateScheduler, EarlyStopping, ModelCheckpoint, ReduceLROnPlateau\n\nimport gc, sys\ngc.enable()\n","5b94a2dc":"def state(message,start = True, time = 0):\n    if(start):\n        print(f'Working on {message} ... ')\n    else :\n        print(f'Working on {message} took ({round(time , 3)}) Sec \\n')","40956294":"INPUT_DIR = \"..\/input\/\"","e8ad6e7e":"def feature_engineering(is_train=True):\n    # When this function is used for the training data, load train_V2.csv :\n    if is_train: \n        print(\"processing train_V2.csv\")\n        df = pd.read_csv(INPUT_DIR + 'train_V2.csv')\n        \n        # Only take the samples with matches that have more than 1 player \n        # there are matches with no players or just one player ( those samples could affect our model badly) \n        df = df[df['maxPlace'] > 1]\n    \n    # When this function is used for the test data, load test_V2.csv :\n    else:\n        print(\"processing test_V2.csv\")\n        df = pd.read_csv(INPUT_DIR + 'test_V2.csv')\n        \n    # Make a new feature indecating the total distance a player cut :\n    state('totalDistance')\n    s = timer()\n    df['totalDistance'] = df['rideDistance'] + df[\"walkDistance\"] + df[\"swimDistance\"]\n    e = timer()\n    state('totalDistance', False, e - s)\n          \n\n    state('rankPoints')\n    s = timer()\n    # Process the 'rankPoints' feature by replacing any value of (-1) to be (0) :\n    df['rankPoints'] = np.where(df['rankPoints'] <= 0 ,0 , df['rankPoints'])\n    e = timer()                                  \n    state('rankPoints', False, e-s)\n    \n\n    target = 'winPlacePerc'\n    # Get a list of the features to be used\n    features = list(df.columns)\n    \n    # Remove some features from the features list :\n    features.remove(\"Id\")\n    features.remove(\"matchId\")\n    features.remove(\"groupId\")\n    features.remove(\"matchDuration\")\n    features.remove(\"matchType\")\n    \n    y = None\n    \n    # If we are processing the training data, process the target\n    # (group the data by the match and the group then take the mean of the target) \n    if is_train: \n        y = np.array(df.groupby(['matchId','groupId'])[target].agg('mean'), dtype=np.float64)\n        # Remove the target from the features list :\n        features.remove(target)\n    \n    # Make new features indicating the mean of the features ( grouped by match and group ) :\n    print(\"get group mean feature\")\n    agg = df.groupby(['matchId','groupId'])[features].agg('mean')\n    # Put the new features into a rank form ( max value will have the highest rank)\n    agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    \n    \n    # If we are processing the training data let df_out = the grouped  'matchId' and 'groupId'\n    if is_train: df_out = agg.reset_index()[['matchId','groupId']]\n    # If we are processing the test data let df_out = 'matchId' and 'groupId' without grouping \n    else: df_out = df[['matchId','groupId']]\n    \n    # Merge agg and agg_rank (that we got before) with df_out :\n    df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    df_out = df_out.merge(agg_rank, suffixes=[\"_mean\", \"_mean_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    # Make new features indicating the max value of the features for each group ( grouped by match )\n    print(\"get group max feature\")\n    agg = df.groupby(['matchId','groupId'])[features].agg('max')\n    # Put the new features into a rank form ( max value will have the highest rank)\n    agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    \n    # Merge the new (agg and agg_rank) with df_out :\n    df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    df_out = df_out.merge(agg_rank, suffixes=[\"_max\", \"_max_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    # Make new features indicating the minimum value of the features for each group ( grouped by match )\n    print(\"get group min feature\")\n    agg = df.groupby(['matchId','groupId'])[features].agg('min')\n    # Put the new features into a rank form ( max value will have the highest rank)\n    agg_rank = agg.groupby('matchId')[features].rank(pct=True).reset_index()\n    \n    # Merge the new (agg and agg_rank) with df_out :\n    df_out = df_out.merge(agg.reset_index(), suffixes=[\"\", \"\"], how='left', on=['matchId', 'groupId'])\n    df_out = df_out.merge(agg_rank, suffixes=[\"_min\", \"_min_rank\"], how='left', on=['matchId', 'groupId'])\n    \n    # Make new features indicating the number of players in each group ( grouped by match )\n    print(\"get group size feature\")\n    agg = df.groupby(['matchId','groupId']).size().reset_index(name='group_size')\n     \n    # Merge the group_size feature with df_out :\n    df_out = df_out.merge(agg, how='left', on=['matchId', 'groupId'])\n    \n    # Make new features indicating the mean value of each features for each match :\n    print(\"get match mean feature\")\n    agg = df.groupby(['matchId'])[features].agg('mean').reset_index()\n    \n    # Merge the new agg with df_out :\n    df_out = df_out.merge(agg, suffixes=[\"\", \"_match_mean\"], how='left', on=['matchId'])\n    \n    # Make new features indicating the number of groups in each match :\n    print(\"get match size feature\")\n    agg = df.groupby(['matchId']).size().reset_index(name='match_size')\n    \n    # Merge the match_size feature with df_out :\n    df_out = df_out.merge(agg, how='left', on=['matchId'])\n    \n    # Drop matchId and groupId\n    df_out.drop([\"matchId\", \"groupId\"], axis=1, inplace=True)\n    \n    # X is the output dataset (without the target) and y is the target :\n    X = np.array(df_out, dtype=np.float64)\n    \n    \n    del df, df_out, agg, agg_rank\n    gc.collect()\n\n    return X, y\n","91457790":"%%time\n# Process the training data :\nx_train, y = feature_engineering(True)\n# Scale the data to be in the range (-1 , 1)\nscaler = preprocessing.MinMaxScaler(feature_range=(-1, 1), copy=False).fit(x_train)","70b452c4":"print(\"x_train\", x_train.shape, x_train.max(), x_train.min())\nscaler.transform(x_train)\nprint(\"x_train\", x_train.shape, x_train.max(), x_train.min())","18e19fe7":"y = y * 2 - 1\nprint(\"y\", y.shape, y.max(), y.min())","adc256aa":"%%time\n# create NN_model\nNN_model = Sequential()\nNN_model.add(Dense(x_train.shape[1],  input_dim = x_train.shape[1], activation='relu'))\nNN_model.add(Dense(x_train.shape[1], activation='relu'))\n#NN_model.add(Conv1D(136, 3, activation='relu'))\n#NN_model.add(Dense(136, activation='tanh'))\n#NN_model.add(Conv1D(136, 3, activation='relu'))\nNN_model.add(Dense(x_train.shape[1], activation='relu'))\n#NN_model.add(Conv1D(136, 3, activation='relu'))\n#NN_model.add(Dense(136, activation='tanh'))\n\n# output Layer\nNN_model.add(Dense(1, activation='linear'))\n\n# Compile the network :\nNN_model.compile(loss='mean_absolute_error', optimizer='adam', metrics=['mean_absolute_error'])\nNN_model.summary()\n","c4702fbc":"checkpoint_name = 'Weights-{epoch:03d}--{val_loss:.5f}.hdf5' \ncheckpoint = ModelCheckpoint(checkpoint_name, monitor='val_loss', verbose = 1, save_best_only = True, mode ='auto')\ncallbacks_list = [checkpoint]\n\n#early_stopping = EarlyStopping(monitor='val_loss', mode = 'auto', patience=3, verbose=1)\n","c51a36ef":"%%time\nNN_model_h = NN_model.fit(x=x_train, \n             y=y, \n             batch_size=3000,\n             epochs=30, \n             verbose=1, \n             callbacks=callbacks_list,\n             validation_split=0.20, \n             validation_data=None, \n             shuffle=True,\n             class_weight=None, \n             sample_weight=None, \n             initial_epoch=0,\n             steps_per_epoch=None, \n             validation_steps=None)\nprint(NN_model_h.history)\ndel x_train, y\ngc.collect()","4bcdebb8":"x_test, _ = feature_engineering(False)\nscaler.transform(x_test)\nprint(\"x_test\", x_test.shape, x_test.max(), x_test.min())\nnp.clip(x_test, out=x_test, a_min=-1, a_max=1)\nprint(\"x_test\", x_test.shape, x_test.max(), x_test.min())","ae300970":"%%time\npred = NN_model.predict(x_test)\ndel x_test\ngc.collect()","ee850c37":"pred = pred.reshape(-1)\npred = (pred + 1) \/ 2","d08b3daa":"df_test = pd.read_csv(INPUT_DIR + 'test_V2.csv')","a3c85cf2":"%%time\nprint(\"fix winPlacePerc\")\nfor i in range(len(df_test)):\n    winPlacePerc = pred[i]\n    maxPlace = int(df_test.iloc[i]['maxPlace'])\n    if maxPlace == 0:\n        winPlacePerc = 0.0\n    elif maxPlace == 1:\n        winPlacePerc = 1.0\n    else:\n        gap = 1.0 \/ (maxPlace - 1)\n        winPlacePerc = round(winPlacePerc \/ gap) * gap\n    \n    if winPlacePerc < 0: winPlacePerc = 0.0\n    if winPlacePerc > 1: winPlacePerc = 1.0    \n    pred[i] = winPlacePerc","e8139bdc":"df_test['winPlacePerc'] = pred","92dc6ba9":"submission = df_test[['Id', 'winPlacePerc']]\nsubmission.to_csv('submission.csv', index=False)","7a36c084":"## Define an MLP model and train it :","674d95aa":"Before I start explaining the code, I have to say that the most of this code was taken from [[This kernel](https:\/\/www.kaggle.com\/anycode\/simple-nn-baseline-3)] by [anycode](https:\/\/www.kaggle.com\/anycode) Kaggler","16a8fbdb":" Finally, I hope you understand every line of this kernel, also if you have any note don't hesitate to put it in a comment .","de1c922c":"### Scale the target to be in the range (-1 , 1)","dfd04971":"**Fisrt :** Let's load the needed dependencies :","fa378c91":"### Process and scale the training data  :","b7b5a0bf":"### Reshape the predictions and put them in the right range(0 , 1 )","c9497507":"# How to Score (0.0255 - 0.0245)","852e4a08":"## Create the submission file : ","6e622b77":"### Predict the target using the test data : ","b6bde148":"** I explained the following code with comments, I hope you understand it well**","dff5360f":"## Process the test data and scale it :"}}