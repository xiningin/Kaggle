{"cell_type":{"1c648410":"code","200748d4":"code","920eb1b1":"code","1fa9c991":"code","b55e581c":"code","4217f9f9":"code","e181b951":"code","e9698728":"code","66f77446":"code","c5205605":"code","c0029a91":"code","3ceb7dc3":"code","3e2c2333":"code","4279dfab":"code","1e6a6745":"code","1d2306ad":"code","b699d17d":"code","ca577e85":"markdown","8f8dc153":"markdown","30f8f121":"markdown","470449ed":"markdown","8bf0bc64":"markdown","257168e2":"markdown","5580d725":"markdown","662a7a53":"markdown","b8d9b44c":"markdown","02f285fb":"markdown"},"source":{"1c648410":"#Importing Stuff\nimport numpy as np \nimport pandas as pd \nfrom math import *\ntrain = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')","200748d4":"train.head()","920eb1b1":"test.head()","1fa9c991":"train['len']=train.apply(lambda x: len(x['text']),axis=1)\ntrain['plen']=train.apply(lambda x: (ceil(x['len']\/100)*100),axis=1)\ntrain.head()","b55e581c":"test['len']=test.apply(lambda x: len(x['ciphertext']),axis=1)\ntest.head()","4217f9f9":"df1 = test[test.difficulty==1].copy()\ndf2 = test[test.difficulty==2].copy()\ndf3 = test[test.difficulty==3].copy()\ndf4 = test[test.difficulty==4].copy()","e181b951":"df1.groupby('len').nunique()","e9698728":"df1[df1.len==500]","66f77446":"train[train.plen==500]","c5205605":"#We extract the \ncipherText500 = df1.loc[45272].ciphertext\ncipherText500","c0029a91":"for _,i in train[train.plen==500].iterrows():\n    print(i.text)\n    print(cipherText500)\n    print(\"\\n\\n\\n\")","3ceb7dc3":"text500 = train.loc[13862].text\ntext500","3e2c2333":"\ndef permchk(s):\n    a = \"\"\n    for i in list(s):\n        if i>='a' and i<='z':\n            a+='x'\n        elif i>='A' and i<='Z':\n            a+='X'\n        else:\n            a+=i\n    return a\n\np = len(cipherText500)\nl = len(text500)\nx = (p-l)\/\/2\nprint(permchk(text500))\nprint(permchk(cipherText500[x:l+x]))","4279dfab":"for _,i in df1[df1.len==500].iterrows():\n    print(i.ciphertext_id,end=\" : \")\n    for _,j in train.iterrows():\n        if(i.len==j.plen):\n            p = j.plen\n            l = j.len\n            x = (p-l)\/\/2\n            pcj = permchk(j.text)\n            pci = permchk(i.ciphertext[x:x+l])\n            if pci==pcj:\n                print(j.plaintext_id,end=\",\")\n    print(\"\")","1e6a6745":"for _,i in df1[df1.len==400].iterrows():\n    print(i.ciphertext_id,end=\" : \")\n    for _,j in train.iterrows():\n        if(i.len==j.plen):\n            p = j.plen\n            l = j.len\n            x = (p-l)\/\/2\n            pcj = permchk(j.text)\n            pci = permchk(i.ciphertext[x:x+l])\n            if pci==pcj:\n                print(j.plaintext_id,end=\",\")\n    print(\"\")","1d2306ad":"for _,i in df1[df1.len==300].iterrows():\n    print(i.ciphertext_id,end=\" : \")\n    for _,j in train.iterrows():\n        if(i.len==j.plen):\n            p = j.plen\n            l = j.len\n            x = (p-l)\/\/2\n            pcj = permchk(j.text)\n            pci = permchk(i.ciphertext[x:x+l])\n            #print(j.text)\n            #print(pci)\n            #print(pcj)\n            if pci==pcj:\n                print(j.plaintext_id,end=\",\")\n    print(\"\")","b699d17d":"for _,i in df1[df1.len==200].iterrows():\n    print(i.ciphertext_id,end=\" : \")\n    for _,j in train.iterrows():\n        if(i.len==j.plen):\n            p = j.plen\n            l = j.len\n            x = (p-l)\/\/2\n            pcj = permchk(j.text)\n            pci = permchk(i.ciphertext[x:x+l])\n            #print(j.text)\n            #print(pci)\n            #print(pcj)\n            if pci==pcj:\n                print(j.plaintext_id,end=\",\")\n    print(\"\")","ca577e85":"# But this does not work that well with length 100. But we have enough pairs to decipher difficulty 1","8f8dc153":"Credit : The approach so far has been from [Something to begin with: a first hint\n](https:\/\/www.kaggle.com\/pednt9\/something-to-begin-with-a-first-hint) from now on its entirely my own","30f8f121":"### We realise that padding is centered. \nSo `left_padding = (padded length-length)\/2` and similarly `right_padding = padded length - (padded length-length)\/2`\n<br\/>We make a function that converts all a-x to x, A-Z to X and leaves punctuation as is","470449ed":"# Let us First Focus on Difficulty 1\nWe find out how many unique lengths are there","8bf0bc64":"# Some More Hints for Difficulty 1\nThis Notebook continiues on apporach by Paul Dnt in his kernel [Something to begin with: a first hint](https:\/\/www.kaggle.com\/pednt9\/something-to-begin-with-a-first-hint)\nI will update this as new ideas come","257168e2":"# We seprate test data according to difficulty","5580d725":"If you observe carefully, all punctuations marks line up with some padding in the first text\n![](https:\/\/i.imgur.com\/MlFKoJg.png?2)","662a7a53":"Now we know that length of plaintext is not edited in this difficulty. So a plaintext of padded length 500 will be there are length 500 in our test case.\n<br\/>\nAlso since there is only one element in 500 and 400 category each, it is a good starting point for us.","b8d9b44c":"## As this is exactly same we can loop through all values in train to find corresponding values in df1","02f285fb":"## Since we know lengths are padded we add length and padded length feilds to the dataframe"}}