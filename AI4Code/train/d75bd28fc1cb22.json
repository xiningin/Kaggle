{"cell_type":{"cbb5c9cb":"code","cfaf65f8":"code","0ff32f84":"code","f663bb14":"code","307a2661":"markdown","ca4343d4":"markdown","5faf475d":"markdown","5e72d273":"markdown","a610160e":"markdown"},"source":{"cbb5c9cb":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import rcParams\n    \nfrom numpy.random import random\nfrom numpy import pi\n\nimport os\nprint(os.listdir(\"..\/input\"))\n","cfaf65f8":"def MonteCarloPi(maxIterations):\n#Draw a square and a circle to frame out simulation\n    squareX = [1,-1,-1,1,1]\n    squareY = [1,1,-1,-1,1]\n    circleX,circleY = [],[]\n    \n    for i in range(361):\n        circleX.append(np.cos(np.pi*i\/180))\n        circleY.append(np.sin(np.pi*i\/180))\n\n#Start keeping track of values we're interested in\n    insideX,insideY,outsideX,outsideY,Iteration,CurrentPi = [],[],[],[],[],[]\n    insideCounter = 0\n\n#Generate a bunch of values of x and y between -1 and 1, then assess their combined radius on an xy plane\n    for i in range(maxIterations):\n        x = 2*(random()-0.5)\n        y = 2*(random()-0.5)\n        r = np.sqrt(x**2+y**2)\n        Iteration.append(i)\n        if r <= 1:\n            insideCounter +=1\n            insideX.append(x)\n            insideY.append(y)\n        else:\n            outsideX.append(x)\n            outsideY.append(y)\n        CurrentPi.append(4*insideCounter\/(i+1))\n\n    piValue = 4*insideCounter \/ maxIterations\n    piError = round(100*((piValue-pi)\/pi),4)\n\n#Draw a 2D plot of where our iterations landed compared to the square and circle\n    rcParams['figure.figsize'] = 5, 5\n    plt.plot(squareX,squareY,color='#000000')\n    plt.plot(circleX,circleY,color='#0000CC')\n    plt.scatter(insideX,insideY,color='#00CC00',marker=\".\")\n    plt.scatter(outsideX,outsideY,color='#CC0000',marker=\".\")\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.show()\n    \n#Draw a psuedo-time series plot of current estimate of pi vs. iteration number\n    plt.plot(Iteration,CurrentPi,color='#009900')\n    plt.axhline(y=pi,color='#0F0F0F',ls='--')\n    plt.axis([0,maxIterations,0,4.1])\n    plt.xlabel('Iteration Number')\n    plt.ylabel('Estimate for pi')\n    plt.show()\n\n#print out our final estimate and how it compares to the true value\n    print('\\n' + f'Pi is approximately {piValue}\\n')\n    print(f'This is {piError}% off the true value.\\n')","0ff32f84":"MonteCarloPi(500)","f663bb14":"MonteCarloPi(50000)","307a2661":"**Drawing a square and a circle**\n\nWe want our to be within a 2x2 grid centered at the origin.  The corners of the square will be at (1,1), (1,-1), (-1,-1), and (-1,1).  The circle will be a unit circle with radius 1.\n\nFor the square, we can generate a list for X and Y values using the corner points.\n\nThe circle we can generate using our knowledge of trigonometry.  The X value of a particular point will be cosine of the angle, and the Y value will be its sine.  The total angle of the circle is 2pi radians, and a for loop will allow a quick calculation of the X and Y values of the circle ever degree.\n\n**Initial Values**\n\nThe points inside the circle, outside the circle, what iteration we're on, and current value for pi are all empty lists, and we can append those lists with new values later.  insideCounter is the number of points that appear within the circle, which starts at 0 since we have no points.\n\n**Generating points in the square**\n\nNumpy's random() function will generate a uniform random number between 0 and 1.  We want a number between -1 and 1, so we must first transform it.  Subtracting 0.5 from random() gives a value between -0.5 and 0.5, and multiplying that by 2 gives a number between -1 and 1.  We will do this twice, once for x, once for y.\n\nPythagoras tells us the distance from the origin (r) of our randomly generated points is the square root of the sum of their squares.  If this r value is less than 1, we will add 1 to our insideCounter.  Points inside the circle get appended to the lists for insideX and insideY, and points outside the circle get appended to the lists outsideX and outsideY.  Regardless of whether the new points are inside or outside the circle, we append the current value of pi.\n\nOnce we're done iterating, we can calculate the final value of pi, and its error versus the true value.\n\n**Drawing the plots**\n\nWe want two plots, one is the points with relation to the square and circle, the other the estimate of pi over a number of iterations.","ca4343d4":" Now with the code complete, we can run the function for a desired number of iterations.  The more iterations run, the better the estimate.  Here's how it looks with 500 and 50,000 iterations.","5faf475d":"First import some libraries,","5e72d273":"A simple tutorial for doing a Monte Carlo simulation using Python.   \n\nFrom geometry, we know the ratio of the area of an circle inscribed in a square to that square is pi\/4.  For our Monte Carlo simulation, we will generate a bunch of points in a square and determine which ones are in the circle and which ones are not.  The ratio of the points inside circle to the total number of points is pi\/4.","a610160e":"Next, we're going to set up a function in Python to: \n1. Generate points within a square\n2. Determine which points are also in the circle\n3. Plot the points to visualize those points\n4. Plot the estimate for pi versus the iteration number, to see how quickly we converge on the true value of pi (spoiler: it's noisy)"}}