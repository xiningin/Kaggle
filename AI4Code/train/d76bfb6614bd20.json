{"cell_type":{"fda16269":"code","bf3fbf3a":"code","fea011ae":"code","dccba4b5":"code","b3363d92":"code","c4dd1a21":"code","b746bbfc":"code","5eef0c51":"code","0f4de8f6":"code","38b233e2":"code","d55799e6":"code","99c10ff4":"code","28a8e3e8":"code","1c0b9e3e":"code","3132aed9":"code","fb93a579":"code","51b85edb":"code","4d19e5e1":"code","3bde60a0":"code","3d600d50":"code","3eaf3c6e":"code","fe091e03":"code","9aab729b":"code","6f1bbf10":"code","442853c7":"code","e5686d9c":"code","91676f12":"code","7b73bb62":"code","ff02bcff":"code","82054ee3":"code","ea3a94ac":"code","825a37f6":"code","e0defff5":"code","7dbceee6":"code","98fa997d":"code","be07d6b2":"code","6c59a6b5":"code","b3fe65f7":"code","9187e94e":"code","be82f294":"markdown","8195c575":"markdown","baebbd5e":"markdown","e679177d":"markdown","ebe121c1":"markdown","d9432a40":"markdown","f269fdc7":"markdown"},"source":{"fda16269":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport ast\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nplt.style.use(style=\"seaborn\")\n%matplotlib inline","bf3fbf3a":"df_movie = pd.read_csv(\"..\/input\/tmdb-movie-metadata\/tmdb_5000_movies.csv\")\ndf_credit = pd.read_csv(\"..\/input\/tmdb-movie-metadata\/tmdb_5000_credits.csv\")","fea011ae":"def extract_feature(x, field='name'):\n    \"\"\"\n    function is intended to convert string\n    json and extract values of a specified field\n    as a list...\n    \"\"\"\n    x = ast.literal_eval(x)\n    return [i[field].lower() for i in x]\n\ndef find_animation(x):\n    '''\n    Search for animation genre and label it as '1' for\n    animation and '0' for non - animation\n    '''\n    for i in x:\n        if i.lower() == 'animation':\n            return 1\n    return 0","dccba4b5":"df_movie.head()","b3363d92":"#  checking length of both dataframes\nlen(df_movie),len(df_credit)","c4dd1a21":"# Extracting genres\ndf_movie['list_genres'] = df_movie['genres'].apply(extract_feature)\ndf_movie['list_genres']","b746bbfc":"# Extracting animated movies\ndf_movie['animated'] = df_movie['list_genres'].apply(find_animation)","5eef0c51":"df_movie.head(4).T","0f4de8f6":"# Selecting revelant columns\ndf_movie = df_movie[['id', 'original_title','list_genres','animated']]\ndf_movie.head()","38b233e2":"df_credit.head()","d55799e6":"# Extracting all job roles for each movie\ndf_credit['alljobs'] = df_credit['crew'].apply(extract_feature,field = 'job')\ndf_credit.head()","99c10ff4":"# Merge movie and credit dataframes\ndf = pd.merge(df_movie, df_credit,left_on='id', right_on='movie_id')\ndf.head()","28a8e3e8":"# selecting useful features\ndf = df[['title','list_genres','animated','alljobs']]\ndf.head()","1c0b9e3e":"df['animated'].value_counts()","3132aed9":"# save df\n# df.to_csv('taskone.csv',index=False)","fb93a579":"# Total number of unique jobs across all movies\njobs = []\nfor i in df['alljobs']:\n    for j in i:\n        jobs.append(j.lower())\ntotal_jobs = len(set(jobs))\nprint('There are',total_jobs,'different jobs in this dataset')\njobs = list(set(jobs))\njobs = [x for x in jobs]\nmjobs =jobs\n# print(jobs)","51b85edb":"# Seperate animated movies and non-animated movies into different dataframes\nanimated= df.groupby('animated').get_group(1).reset_index(drop=True)\nothers = df.groupby('animated').get_group(0).reset_index(drop=True)","4d19e5e1":"animated_copy = animated.copy()\nnon_animated_copy = others.copy()","3bde60a0":"# total list of crews job titles in animated movies\nanimated_jobs = []\nfor i in animated['alljobs']:\n    for j in i:\n        animated_jobs.append(j.lower())\ntotal_ajobs = (len(set(animated_jobs)))\nprint('There are',total_ajobs,'job titles for animated movies')\najobs = list(set(animated_jobs))","3d600d50":"# total list of crews job titles in non-animated movies\nother_jobs = []\nfor i in others['alljobs']:\n    for j in i:\n        other_jobs.append(j.lower())\ntotal_ojobs = (len(set(other_jobs)))\nprint('There are',total_ojobs,'job titles for non-animated movies')\nojobs = list(set(other_jobs))","3eaf3c6e":"# jobs common to both animated movies and non animated movies\ncommon_jobs = set.intersection(set(ojobs),set(ajobs))\ntotal_comm_jobs  = len(set(common_jobs))\nprint('There are',total_comm_jobs,'job titles common to both animated and non_animated movies')\n# print(common_jobs)","fe091e03":"# Check for each of the 278 animated job titles in 'alljobs' column for each movie\njob_count = []\nanimation_jobs = []\nfor k in animated_copy['alljobs']:\n    k = list(set(k))\n    ujobs= [j for j in ajobs if j in k]\n    job_count.append(len(ujobs))\n    animation_jobs.append(ujobs)\n# print(k)\nanimated_copy['animation_jobs'] = animation_jobs\nanimated_copy['animation_job_count']= job_count\nanimated_copy.head()","9aab729b":"# however note that some job titles in the 'animationjobs' column also exist in 'other_jobs'(non_animation)\nlen(set.intersection(set(ajobs),set(ojobs)))","6f1bbf10":"com_df = df.copy()\n# Check for each of these common job titles for each movie\njob_count = []\ncom_jobs = []\nfor k in com_df['alljobs']:\n    k = list(set(k))\n    cjobs= [j for j in common_jobs if j  in k]\n    job_count.append(len(cjobs))\n    com_jobs.append(cjobs)\n    \ncom_df['common_jobs'] = com_jobs\ncom_df['common_job_count']= job_count\ncom_df.head()","442853c7":"df['animated'].value_counts()","e5686d9c":"# Check for each of these unique non animation job titles for each movie\n# Check for each of the 401 non animated job titles in 'alljobs' for each movie\n\njob_count = []\nnon_animation_jobs = []\nfor k in non_animated_copy['alljobs']:\n    k = list(set(k))\n    ujobs= [j for j in ojobs if j in k]\n    job_count.append(len(ujobs))\n    non_animation_jobs.append(ujobs)\n    \nnon_animated_copy['non_animation_jobs'] = non_animation_jobs\nnon_animated_copy['non_animation_job_count']= job_count\nnon_animated_copy.head()","91676f12":"sns.set(rc={'figure.figsize':(18.7,8.27)})\nax = sns.countplot(x = 'animation_job_count',\n            data = animated_copy)\nax.set_title('number of animated movies vs number of animation jobs')\nax.set_ylabel('number of animated movies')","7b73bb62":"# preview of concatenation - obviously, NAN values appear for non animation\n# jobs column for animated movies and vice versa\n\nadf = animated_copy[['title','animated','animation_jobs','animation_job_count']].head(3)\nnadf = non_animated_copy[['title','animated','non_animation_jobs','non_animation_job_count']].head(3)\ndf = pd.concat([adf,nadf], keys=['title', 'animated', 'animation_jobs','non_animation_jobs'])\ndf.head(6)","ff02bcff":"adf = animated_copy[['title','animated','animation_jobs','animation_job_count']]\nnadf = non_animated_copy[['title','animated','non_animation_jobs','non_animation_job_count']]\ndf = pd.concat([adf,nadf], keys=['title', 'animated', 'animation_jobs','non_animation_jobs'])\ndf","82054ee3":"print(df['animated'].value_counts())","ea3a94ac":"#one hot encode the job titles\ndf = df.fillna(0)\n\n#For every row in the dataframe, iterate through the list of animation jobs and place a 1 into the corresponding column\ntry:\n    for index, row in df.iterrows():\n        for jobs in row['animation_jobs']:\n            df.loc[index, jobs] = 1\n    df = df.fillna(0)\nexcept TypeError:\n    print(index,jobs)    \ndf","825a37f6":"# df.iloc[233]","e0defff5":"#For every row in the dataframe, iterate through the list of non animation jobs and place a 1 into the corresponding column\ntry:\n    for index, row in df.iloc[234:].iterrows():\n        for jobs in row['non_animation_jobs']:\n            df.loc[index, jobs] = 1\n        df = df.fillna(0)\nexcept TypeError:\n    print(index,jobs)\n    pass\n    \ndf","7dbceee6":"train_df = df.iloc[:,6:].reset_index(drop=True)\ntrain_df.head()","98fa997d":"x = train_df\ny = df[['animated']].reset_index(drop=True)\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\n\nx_train, x_test, y_train, y_test = train_test_split(x,np.ravel(y) , test_size=0.30, random_state=1)\n\nlreg = LogisticRegression(C=10,max_iter = 2000)\nclf=lreg.fit(x_train, y_train)\ny_pred = clf.predict(x_test)\nprint('Accuracy {:.2f}'.format(clf.score(x_test, y_test)))\n\nfrom sklearn.metrics import classification_report\nprint(classification_report(y_test, y_pred)) \n\nfrom sklearn.metrics import confusion_matrix\nconfusion_matrix = confusion_matrix(y_test, y_pred)","be07d6b2":"print(confusion_matrix)","6c59a6b5":"# Predict new values, change all job titles to 1 and fill the remaining values with 0 to make it 417\npredi = non_animated_copy.copy()\nval = predi['alljobs'][2]\n# val\ntestdf = pd.DataFrame()\nfor i in mjobs:\n    testdf.loc[0,f'{i}'] = 0\n\nfor i in set(val):\n    testdf.loc[0, f'{i}'] = 1\n    \nclf.predict(testdf)[0]","b3fe65f7":"sns.set(rc={'figure.figsize':(10.7,6.27)})\n\nclf_report = classification_report(y_test,\n                                   y_pred,\n                                   labels=[0,1],\n                                   target_names=['non_animated','animated'],\n                                   output_dict=True)\n\nclf_plot =sns.heatmap(pd.DataFrame(clf_report).iloc[:-1, :].T, annot=True)\nclf_plot.set_title('Logistic regression classification report')\n","9187e94e":"clf_plot = clf_plot.get_figure()\n\nclf_plot.savefig(\"log_reg_clf_rep.png\")","be82f294":"# Modelling","8195c575":"## Task One\n### Can we categorize we the films by type, such as animated or not by using the crew's job titles?","baebbd5e":"# Preprocessing","e679177d":"### Seperating the movies into all jobs found in animated movies and non animated movies and using logistic regression for modelling\n","ebe121c1":"Below we can see the are 234 animated movies and 4569 non animated movies","d9432a40":"recall 0 is for non_animated and 1 is for animated movies","f269fdc7":"From the figure above, no animated movie made use of the 238 jobs titles, the max number used was 102. its obvious that most animated movies needs at least 102jobs."}}