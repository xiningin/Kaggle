{"cell_type":{"392fd26e":"code","f3cefc58":"code","2055d0ee":"code","4883b245":"code","6bb6724f":"markdown","b2bb1c33":"markdown","654d3ae6":"markdown","140d5753":"markdown"},"source":{"392fd26e":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nPlotWidth = 8","f3cefc58":"def MonteCarloPi(numDataPoints, numCirclePoints = 360, numDecimalPoints = 4):\n#Draw a square and a circle to frame out simulation\n    squareX = [1,-1,-1,1,1]\n    squareY = [1,1,-1,-1,1]\n    \n    circleX = (np.cos(np.pi*np.arange(numCirclePoints+1)\/180))\n    circleY = (np.sin(np.pi*np.arange(numCirclePoints+1)\/180))\n\n#Generate a bunch of values of x and y between -1 and 1, then assess their combined radius on an xy plane\n    dfMonteCarloPi = pd.DataFrame(columns=['x', 'y', 'r', 'Location', 'CurrentPi'])\n    dfMonteCarloPi['x'] = 2*(np.random.rand(numDataPoints)-0.5)\n    dfMonteCarloPi['y'] = 2*(np.random.rand(numDataPoints)-0.5)\n    dfMonteCarloPi['r'] = np.sqrt(dfMonteCarloPi['x']**2 + dfMonteCarloPi['y']**2)\n    dfMonteCarloPi.loc[dfMonteCarloPi['r'] <= 1, 'Location'] = 'Inside'\n    dfMonteCarloPi.loc[dfMonteCarloPi['r'] > 1, 'Location'] = 'Outside'\n    dfMonteCarloPi['CurrentPi'] = 4*(dfMonteCarloPi['Location'] == 'Inside').cumsum()\/(dfMonteCarloPi.index-1)\n    \n    piValue = np.round(np.array(dfMonteCarloPi['CurrentPi'])[-1], numDecimalPoints)\n    piError = np.round(round(100*((piValue-np.pi)\/np.pi),4), numDecimalPoints)\n\n#Draw a 2D plot of where our iterations landed compared to the square and circle\n    plt.figure(figsize=(PlotWidth,PlotWidth))\n    plt.plot(squareX,squareY,color='#000000')\n    plt.plot(circleX,circleY,color='#0000CC')\n    sns.scatterplot(x='x', y='y', data=dfMonteCarloPi, hue='Location', palette='colorblind')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.legend(bbox_to_anchor=(0,-.08), loc=\"upper left\")\n    plt.title('Locations of randomly drawn points')\n    plt.show()\n    \n#Draw a psuedo-time series plot of current estimate of pi vs. iteration number\n    plt.figure(figsize=(PlotWidth,PlotWidth))\n    plt.plot(dfMonteCarloPi.index+1,dfMonteCarloPi['CurrentPi'],color='#009900')\n    plt.axhline(y=np.pi,color='#0F0F0F',ls='--')\n    plt.xlim(0,numDataPoints+1)\n    plt.ylim(0,4)\n    plt.xlabel('Iteration Number')\n    plt.ylabel('Estimate for pi')\n    plt.title('Current estimate for pi by iteration number')\n    plt.show()\n\n#print out our final estimate and how it compares to the true value\n    print('\\n' + f'Pi is approximately {piValue}\\n')\n    print(f'This is {piError}% off the true value.\\n')\n#     return dfMonteCarloPi","2055d0ee":"MonteCarloPi(1000)","4883b245":"MonteCarloPi(10000)","6bb6724f":"First import some libraries,","b2bb1c33":"Now with the code complete, we can run the function for a desired number of iterations.  The more iterations run, the better the estimate.  Here's how it looks with 1,000 and 10,000 iterations.","654d3ae6":"A simple tutorial for doing a Monte Carlo simulation using Python.   \n\nFrom geometry, we know the ratio of the area of an circle inscribed in a square to that square is pi\/4.  For our Monte Carlo simulation, we will generate a bunch of points in a square and determine which ones are in the circle and which ones are not.  The ratio of the points inside circle to the total number of points is pi\/4.","140d5753":"Next, we're going to set up a function in Python to: \n1. Generate points within a square between -1 and 1 for both x and y\n2. Determine which points are also in the circle (radius is <= 1)\n3. Plot the points to visualize those points\n4. Plot the estimate for pi versus the iteration number, to see how quickly we converge on the true value of pi (spoiler: it's noisy)"}}