{"cell_type":{"c1dc5c6d":"code","ed37e4c7":"code","890618ce":"code","23630cce":"code","1607f476":"code","62e90d37":"code","a1ca8cc0":"code","5937d937":"code","19ba6344":"code","ba24cf26":"code","0bb01377":"markdown"},"source":{"c1dc5c6d":"!git clone 'https:\/\/gist.github.com\/d6e801ecf19449029decb5b68dd6280a.git' custom_loss\n!git clone 'https:\/\/gist.github.com\/belkhir-nacim\/10a0ce966159eddc6a0cae07c92acdc8' utils\n!pip install torchsummary\nimport gc\nimport os,h5py\nimport numpy as np\nimport pandas as pd\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nfrom torch import nn,optim\nimport torch.nn.functional as F\nfrom torchvision import transforms\nfrom torchvision.utils import make_grid\nfrom sklearn.metrics import confusion_matrix\nfrom torchsummary import summary\nfrom custom_loss.ssim_loss import SSIM\nfrom utils.cudafy import Cudafy\nimport matplotlib.pyplot as plt\nfrom tqdm.autonotebook import tqdm","ed37e4c7":"EXAMPLE_DATA_ROOT_FOLDER = '\/kaggle\/input\/textiledefectdetection'","890618ce":"class UnsupervisedTextureDataset(Dataset):\n    filenames = {64: dict(train='matchingtDATASET_train_64.h5', test='matchingtDATASET_test_64.h5'),\n                 32: dict(train='matchingtDATASET_train_32.h5', test='matchingtDATASET_test_32.h5')}\n    \n    defect_classes = ['good', 'color','cut','hole','metal_contamination','thread']\n    \n    def __init__(self, root_folder, train=True, patch_size=64, keep_angles=True, keep_defects=False, transformation=None, test_sub_sample=200):\n        if os.path.exists(root_folder):\n            self.root_folder = root_folder\n        else:\n            raise IOError('The path of the directory is incorrect or doesn\\'t exist')\n        \n        self.patch_size = patch_size if patch_size in self.filenames.keys() else 32    \n        self.data_dict, self.label_defect, self.label_angles, self.index_image = self.load_data(train,keep_angles=keep_angles,keep_defects=keep_defects)\n        assert(type(keep_angles) is bool or ((type(keep_angles) is int) and (keep_angles <=8)) )\n        self.keep_angles = keep_angles\n        self.transformation = transforms.Compose([transforms.ToTensor()]) if transformation is None  else  transformation\n        if (train==False) and (test_sub_sample is not None):\n            test_sub_sample = int(test_sub_sample)\n            if test_sub_sample>1:\n                idx = np.random.choice( np.arange(self.label_angles.shape[0]), size=test_sub_sample,replace=False)\n                self.label_defect, self.label_angles, self.index_image = self.label_defect[idx], self.label_angles[idx], self.index_image[idx]\n            \n    def load_data(self,train, keep_angles=True, keep_defects=False):\n        files = self.filenames[self.patch_size]\n        filename = files['train'] if train else files['test']\n        label_defect, label_angle, index_image = [], [], []\n        with h5py.File(os.path.join(self.root_folder,filename),mode='r') as f:\n            dict_defects = {}\n            for defect_key in f.keys():\n                if not keep_defects and not defect_key=='good':\n                    continue\n                DONE=False\n                dict_angles = {}\n                for angle_key in f[defect_key].keys():\n                    if not keep_angles and angle_key==0:\n                        continue\n                    x = f[defect_key][angle_key][:]\n                    if not DONE:\n                        label_angle.extend([int(angle_key.replace('angle',''))]*x.shape[0])\n                        label_defect.extend([int(self.defect_classes.index(defect_key))]*x.shape[0])\n                        index_image.append(np.arange(x.shape[0]))\n                        DONE=True\n                    dict_angles[int(angle_key.replace('angle',''))] = x.reshape(x.shape[0], self.patch_size,self.patch_size,1)\n                dict_defects[int(self.defect_classes.index(defect_key))] = dict_angles\n        return dict_defects, np.array(label_defect),np.array(label_angle),np.concatenate(index_image)\n    \n    def __len__(self):\n        return self.label_defect.shape[0]\n    \n    def __getitem__(self,idx):\n        angles = self.data_dict[self.label_defect[idx]]\n        img =angles[0][self.index_image[idx]]\n        img = self.transformation(img)        \n        if not self.keep_angles:\n            return img, img\n        else:\n            imgrot =angles[self.keep_angles][self.index_image[idx]]\n            imgrot = self.transformation(imgrot)\n            return img, imgrot\n        \n        \ndef getdataloader(root, patch_size=64, batch_size=32, keep_angles=False,keep_defects=False,  test_sub_sample=False, num_workers=5, *args,**kwargs):\n    transformation = transforms.Compose([transforms.ToTensor(), transforms.Normalize([0.3541], [0.1352])])\n    dataset = UnsupervisedTextureDataset(root_folder=root, train=True, patch_size=patch_size, keep_angles=keep_angles, keep_defects=keep_defects, transformation=transformation)\n    train_loader = DataLoader(dataset=dataset,batch_size=batch_size,shuffle=True,num_workers=num_workers, pin_memory=True)\n    \n    transformation = transforms.Compose([transforms.ToTensor(), transforms.Normalize([0.3541], [0.1352])])\n    dataset = UnsupervisedTextureDataset(root_folder=root, train=False, patch_size=patch_size,  keep_angles=keep_angles, keep_defects=keep_defects, transformation=transformation, test_sub_sample=test_sub_sample)\n    val_loader = DataLoader(dataset=dataset,batch_size=batch_size,shuffle=False, num_workers=num_workers, pin_memory=True)\n    return train_loader, val_loader\n\ndef gettestdata(root, patch_size=64, batch_size=128, keep_angles=False, keep_defects=True, test_sub_sample=None, num_workers=5, *args, **kwargs):\n    transformation = transforms.Compose([transforms.ToTensor(), transforms.Normalize([0.3541], [0.1352])])\n    dataset = UnsupervisedTextureDataset(root_folder=root, train=False, patch_size=patch_size, keep_angles=keep_angles, keep_defects=keep_defects, transformation=transformation, test_sub_sample=test_sub_sample)\n    val_loader = DataLoader(dataset=dataset, batch_size=batch_size, shuffle=True, num_workers=num_workers, pin_memory=True)\n    return val_loader\n    ","23630cce":"class FullyConnectedAE(nn.Module):\n    ttype = 'ae'\n    def __init__(self,img_shape=None, encoding_dim=64, *args,**kwargs):\n        super(FullyConnectedAE, self).__init__()\n        self.input_shape = img_shape\n        self.input_dim = img_shape[0]* img_shape[1]\n        self.encoder = nn.Linear(self.input_dim, encoding_dim)\n        self.decoder = nn.Linear(encoding_dim, self.input_dim)\n    def forward(self, x):\n        x = x.view(x.shape[0],-1)\n        encoded = F.relu(self.encoder(x))\n        decoded = self.decoder(encoded)\n        return torch.sigmoid(decoded.view(x.shape[0],1, *self.input_shape))\n    \n    def features_extraction(self,x):\n        x = x.view(x.shape[0],-1)\n        encoded = F.relu(self.encoder(x))\n        return encoder","1607f476":"class VectorQuantizer(nn.Module):\n    def __init__(self, num_embeddings, embedding_dim, commitment_cost):\n        super(VectorQuantizer, self).__init__()\n        \n        self._embedding_dim = embedding_dim\n        self._num_embeddings = num_embeddings\n        \n        self._embedding = nn.Embedding(self._num_embeddings, self._embedding_dim)\n        self._embedding.weight.data.uniform_(-1\/self._num_embeddings, 1\/self._num_embeddings)\n        self._commitment_cost = commitment_cost\n\n    def forward(self, inputs):\n        # convert inputs from BCHW -> BHWC\n        inputs = inputs.permute(0, 2, 3, 1).contiguous()\n        input_shape = inputs.shape\n        # Flatten input\n        flat_input = inputs.view(-1, self._embedding_dim)\n        # Calculate distances\n        distances = (torch.sum(flat_input**2, dim=1, keepdim=True) + torch.sum(self._embedding.weight**2, dim=1) - 2 * torch.matmul(flat_input, self._embedding.weight.t()))    \n        # Encoding\n        encoding_indices = torch.argmin(distances, dim=1).unsqueeze(1)\n        encodings = torch.zeros(encoding_indices.shape[0], self._num_embeddings, device=inputs.device)\n        encodings.scatter_(1, encoding_indices, 1)\n        # Quantize and unflatten\n        quantized = torch.matmul(encodings, self._embedding.weight).view(input_shape)\n        # Loss\n        e_latent_loss = F.mse_loss(quantized.detach(), inputs)\n        q_latent_loss = F.mse_loss(quantized, inputs.detach())\n        loss = q_latent_loss + self._commitment_cost * e_latent_loss\n        \n        quantized = inputs + (quantized - inputs).detach()\n        avg_probs = torch.mean(encodings, dim=0)\n        perplexity = torch.exp(-torch.sum(avg_probs * torch.log(avg_probs + 1e-10)))\n        # convert quantized from BHWC -> BCHW\n        return loss, quantized.permute(0, 3, 1, 2).contiguous(), perplexity, encodings\n    \nclass VectorQuantizerEMA(nn.Module):\n    def __init__(self, num_embeddings, embedding_dim, commitment_cost, decay, epsilon=1e-5):\n        super(VectorQuantizerEMA, self).__init__()\n        \n        self._embedding_dim = embedding_dim\n        self._num_embeddings = num_embeddings\n        \n        self._embedding = nn.Embedding(self._num_embeddings, self._embedding_dim)\n        self._embedding.weight.data.normal_()\n        self._commitment_cost = commitment_cost\n        \n        self.register_buffer('_ema_cluster_size', torch.zeros(num_embeddings))\n        self._ema_w = nn.Parameter(torch.Tensor(num_embeddings, self._embedding_dim))\n        self._ema_w.data.normal_()\n        \n        self._decay = decay\n        self._epsilon = epsilon\n\n    def forward(self, inputs):\n        # convert inputs from BCHW -> BHWC\n        inputs = inputs.permute(0, 2, 3, 1).contiguous()\n        input_shape = inputs.shape\n        \n        # Flatten input\n        flat_input = inputs.view(-1, self._embedding_dim)\n        \n        # Calculate distances\n        distances = (torch.sum(flat_input**2, dim=1, keepdim=True)  + torch.sum(self._embedding.weight**2, dim=1) - 2 * torch.matmul(flat_input, self._embedding.weight.t()))\n            \n        # Encoding\n        encoding_indices = torch.argmin(distances, dim=1).unsqueeze(1)\n        encodings = torch.zeros(encoding_indices.shape[0], self._num_embeddings, device=inputs.device)\n        encodings.scatter_(1, encoding_indices, 1)\n        \n        # Quantize and unflatten\n        quantized = torch.matmul(encodings, self._embedding.weight).view(input_shape)\n        \n        # Use EMA to update the embedding vectors\n        if self.training:\n            self._ema_cluster_size = self._ema_cluster_size * self._decay + (1 - self._decay) * torch.sum(encodings, 0)\n            # Laplace smoothing of the cluster size\n            n = torch.sum(self._ema_cluster_size.data)\n            self._ema_cluster_size = ( (self._ema_cluster_size + self._epsilon) \/ (n + self._num_embeddings * self._epsilon) * n)\n            dw = torch.matmul(encodings.t(), flat_input)\n            self._ema_w = nn.Parameter(self._ema_w * self._decay + (1 - self._decay) * dw)\n            self._embedding.weight = nn.Parameter(self._ema_w \/ self._ema_cluster_size.unsqueeze(1))\n        \n        # Loss\n        e_latent_loss = F.mse_loss(quantized.detach(), inputs)\n        loss = self._commitment_cost * e_latent_loss\n        \n        # Straight Through Estimator\n        quantized = inputs + (quantized - inputs).detach()\n        avg_probs = torch.mean(encodings, dim=0)\n        perplexity = torch.exp(-torch.sum(avg_probs * torch.log(avg_probs + 1e-10)))\n        \n        # convert quantized from BHWC -> BCHW\n        return loss, quantized.permute(0, 3, 1, 2).contiguous(), perplexity, encodings\n    \n\nclass Residual(nn.Module):\n    def __init__(self, in_channels, num_hiddens, num_residual_hiddens):\n        super(Residual, self).__init__()\n        self._block = nn.Sequential(nn.ReLU(True), nn.Conv2d(in_channels=in_channels,out_channels=num_residual_hiddens, kernel_size=3, stride=1, padding=1, bias=False),\n                                    nn.ReLU(True), nn.Conv2d(in_channels=num_residual_hiddens, out_channels=num_hiddens, kernel_size=1, stride=1, bias=False))\n    def forward(self, x):\n        return x + self._block(x)\n\nclass ResidualStack(nn.Module):\n    def __init__(self, in_channels, num_hiddens, num_residual_layers, num_residual_hiddens):\n        super(ResidualStack, self).__init__()\n        self._num_residual_layers = num_residual_layers\n        self._layers = nn.ModuleList([Residual(in_channels, num_hiddens, num_residual_hiddens) for _ in range(self._num_residual_layers)])\n\n    def forward(self, x):\n        for i in range(self._num_residual_layers):\n            x = self._layers[i](x)\n        return F.relu(x)\n    \n\nclass Encoder(nn.Module):\n    def __init__(self, in_channels, num_hiddens, num_residual_layers, num_residual_hiddens):\n        super(Encoder, self).__init__()\n        self._conv_1 = nn.Conv2d(in_channels=in_channels,out_channels=num_hiddens\/\/2,kernel_size=4,stride=2, padding=1)\n        self._conv_2 = nn.Conv2d(in_channels=num_hiddens\/\/2,out_channels=num_hiddens,kernel_size=4,stride=2, padding=1)\n        self._conv_3 = nn.Conv2d(in_channels=num_hiddens,out_channels=num_hiddens,kernel_size=3,stride=1, padding=1)\n        self._residual_stack = ResidualStack(in_channels=num_hiddens,num_hiddens=num_hiddens,num_residual_layers=num_residual_layers,num_residual_hiddens=num_residual_hiddens)\n\n    def forward(self, inputs):\n        x = self._conv_1(inputs)\n        x = F.relu(x)\n        x = self._conv_2(x)\n        x = F.relu(x)\n        x = self._conv_3(x)\n        return self._residual_stack(x)\n    \nclass Decoder(nn.Module):\n    def __init__(self, in_channels, num_hiddens, num_residual_layers, num_residual_hiddens):\n        super(Decoder, self).__init__()\n        self._conv_1 = nn.Conv2d(in_channels=in_channels, out_channels=num_hiddens, kernel_size=3, stride=1, padding=1)\n        self._residual_stack = ResidualStack(in_channels=num_hiddens, num_hiddens=num_hiddens, num_residual_layers=num_residual_layers, num_residual_hiddens=num_residual_hiddens)\n        self._conv_trans_1 = nn.ConvTranspose2d(in_channels=num_hiddens,  out_channels=num_hiddens\/\/2, kernel_size=4,  stride=2, padding=1)\n        self._conv_trans_2 = nn.ConvTranspose2d(in_channels=num_hiddens\/\/2,  out_channels=1, kernel_size=4, stride=2, padding=1)\n\n    def forward(self, inputs):\n        x = self._conv_1(inputs)\n        x = self._residual_stack(x)\n        x = self._conv_trans_1(x)\n        x = F.relu(x)\n        return self._conv_trans_2(x)\n    \nclass VQVAEModel(nn.Module):\n    ttype = 'vqvae'\n    def __init__(self, num_hiddens, num_residual_layers, num_residual_hiddens, \n                 num_embeddings, embedding_dim, commitment_cost, decay=0):\n        super(VQVAEModel, self).__init__()\n        self._encoder = Encoder(1, num_hiddens,num_residual_layers,  num_residual_hiddens)\n        self._pre_vq_conv = nn.Conv2d(in_channels=num_hiddens, out_channels=embedding_dim, kernel_size=1,  stride=1)\n        if decay > 0.0:\n            self._vq_vae = VectorQuantizerEMA(num_embeddings, embedding_dim, commitment_cost, decay)\n        else:\n            self._vq_vae = VectorQuantizer(num_embeddings, embedding_dim, commitment_cost)\n        self._decoder = Decoder(embedding_dim, num_hiddens, num_residual_layers, num_residual_hiddens)\n\n    def forward(self, x):\n        z = self._encoder(x)\n        z = self._pre_vq_conv(z)\n        loss, quantized, perplexity, _ = self._vq_vae(z)\n        x_recon = self._decoder(quantized)\n\n        return loss, x_recon, perplexity\n    \n    ","62e90d37":"\n\nclass Trainer(object):\n    def __init__(self, model, train_loader, val_loader,optimizer=None, criterion=None, no_epochs=5, cudafy=None, target_type='defect', lr=1e-1, *args,**kwargs):\n        \n        self.cudafy = cudafy if cudafy is not None else Cudafy(0)\n        self.no_epochs = no_epochs\n        self.model = self.cudafy(model)\n        self.criterion = criterion #if criterion is not None else nn.MSELoss()\n\n        if self.criterion.__class__.__name__!= 'SSIM':\n            print('not ssim')\n        else:\n            print('ssim')\n        if optimizer == optim.Adam:\n            self.optimizer = optimizer(self.model.parameters(),lr=lr, amsgrad=False) # if optimizer is not None else optim.SGD(self.model.parameters(), lr=lr)\n        else:\n            self.optimizer = optimizer(self.model.parameters(),lr=lr)\n        self.train_loader, self.valid_loader = train_loader, val_loader\n        print(\"Total_params\",sum(p.numel() for p in model.parameters()))\n        print(\"Trainable_params\",sum(p.numel() for p in model.parameters() if p.requires_grad))\n        self.data_variance = 0.1352 # computed on all training healthy data\n    \n    def train_an_epoch(self):\n        self.model.train()\n        train_loss = 0.0\n        for data,target in self.train_loader:\n            data, target = self.cudafy(data), self.cudafy(target)\n            # clear the gradients of all optimized variables\n            self.optimizer.zero_grad()\n            # forward pass: compute predicted outputs by passing inputs to the model\n            if self.model.ttype =='ae':\n                output = self.model(data)\n                loss = self.criterion(output, target) if self.criterion.__class__.__name__!= 'SSIM' else  1 - self.criterion(output,target)\n            elif self.model.ttype == 'vqvae':\n                vq_loss, data_recon, perplexity = self.model(data)\n                recon_error = F.mse_loss(data_recon, target) \/ self.data_variance\n                loss = recon_error + vq_loss\n            # calculate the batch loss\n            \n            \n            # backward pass: compute gradient of the loss with respect to model parameters\n            loss.backward()\n            # perform a single optimization step (parameter update)\n            self.optimizer.step()\n            # update training loss\n            train_loss += self.cudafy.get(loss).item()*data.size(0)\n        return train_loss\n            \n    def valid_an_epoch(self):\n        valid_loss = 0.0\n        self.model.eval()\n        for data,target in self.valid_loader:\n            data, target = self.cudafy(data), self.cudafy(target)\n            if self.model.ttype =='ae':\n                output = self.model(data)\n                loss = self.criterion(output, target) if self.criterion.__class__.__name__!= 'SSIM' else 1 - self.criterion(output,target)\n            elif self.model.ttype == 'vqvae':\n                vq_loss, data_recon, perplexity = self.model(data)\n                recon_error = F.mse_loss(data_recon, target) \/ self.data_variance\n                loss = recon_error + vq_loss\n            # update average validation loss\n            valid_loss += self.cudafy.get(loss).item()*data.size(0)            \n        return valid_loss\n    \n    \n    def train(self):\n        alltrainloss = []\n        allvalidloss = []\n#         pbar = tqdm()\n        iterable = range(1, self.no_epochs+1)\n        for epoch in iterable:\n\n            train_loss = self.train_an_epoch()\n            valid_loss = self.valid_an_epoch()\n            train_loss = train_loss\/len(self.train_loader.sampler)\n            valid_loss = valid_loss\/len(self.valid_loader.sampler)\n            gc.collect()\n            \n            alltrainloss.append(train_loss)\n            allvalidloss.append(valid_loss)\n            # print training\/validation statistics \n#             pbar.set_description(f'Epoch: {epoch} \\tTraining Loss: {train_loss:.4f} \\tValidation Loss: {valid_loss:.4f}')\n            print(f'Epoch: {epoch} \\tTraining Loss: {train_loss:.4f} \\tValidation Loss: {valid_loss:.4f}', end='\\n' if epoch%10==0 else '\\r')\n#             pbar.update(1)\n        figure = plt.figure(figsize=(10,10))\n        ax1 = figure.gca()\n        linet, = ax1.plot(alltrainloss,label='Train')\n        linev, = ax1.plot(allvalidloss,label='Valid')\n        ax1.legend([linet,linev],['train','valid'])","a1ca8cc0":"def get_model(modeltype='fullyae', patch_size=32, encoding_dim=64, num_hiddens = 128,  num_residual_hiddens = 32, num_residual_layers = 2, embedding_dim = 64, num_embeddings = 512, commitment_cost = 0.25, decay = 0.99, *args,**kwargs):\n    if modeltype=='fullyae': model = FullyConnectedAE(img_shape=(patch_size, patch_size), encoding_dim=encoding_dim)\n    elif modeltype=='convae': model = ConvAE()\n    elif modeltype=='vqvae': model = VQVAEModel(num_hiddens, num_residual_layers, num_residual_hiddens, num_embeddings, embedding_dim, commitment_cost, decay)\n        \n    else:\n        raise NotImplementedError('More Options will be added later')\n    return model\n\ndef run(options):\n    train_loader, val_loader = getdataloader(**options)        \n    model = get_model(**options)\n#     summary(model, (1,options['patch_size'],options['patch_size']),1,'cpu')\n    trainer = Trainer(model=model,train_loader=train_loader, val_loader=val_loader, **options)\n    trainer.train()\n    gc.collect()\n    return trainer.model\n\ndef test(options, model):\n    cudafy = options['cudafy']\n    model = cudafy(model)\n    valid_loader = gettestdata(**options)\n    with torch.no_grad():\n        model.eval()\n        for data,target in valid_loader:\n            data, target = cudafy(data), cudafy(target)\n            if model.ttype =='ae':\n                output = model(data)\n            elif model.ttype == 'vqvae':\n                _, output, _ = model(data)\n\n            fig, axes = plt.subplots(1,2, figsize=(25,25))\n            ax1, ax3 = axes.ravel()\n            grid_img = make_grid(cudafy.get(data),nrow=16).permute(1, 2, 0)*0.1352 +       0.3541\n            ax1.imshow(grid_img)\n            ax1.set_title('Input')\n            grid_img = make_grid(cudafy.get(output),nrow=16).permute(1, 2, 0) *0.1352 +       0.3541\n            ax3.imshow(grid_img)\n            ax3.set_title('Reconstructed')\n            ","5937d937":"train_parameters=dict(root='\/kaggle\/input\/textiledefectdetection', patch_size=64, batch_size=256, modeltype='vqvae',\n                      num_hiddens = 64,  num_residual_hiddens = 32, num_residual_layers = 1, embedding_dim = 32, num_embeddings = 128, commitment_cost = 0.25, decay = 0.99,\n                      cudafy = Cudafy(0), lr=1e-3, no_epochs=200,  keep_angles=False,  keep_defects=False, test_sub_sample=500, num_workers=4, optimizer= optim.Adam)\nmodel = run(train_parameters)","19ba6344":"test_parameters = dict(root='\/kaggle\/input\/textiledefectdetection', patch_size=64, batch_size=256, cudafy=Cudafy(0),keep_angles=False, keep_defects=False, num_workers=4,test_sub_sample=256  )\ntest(options=test_parameters, model=model)\ntest_parameters = dict(root='\/kaggle\/input\/textiledefectdetection', patch_size=64, batch_size=256, cudafy=Cudafy(0),keep_angles=False, keep_defects=True, num_workers=4,test_sub_sample=256  )\ntest(options=test_parameters, model=model)","ba24cf26":"def gen_img_from_discrete_code(code, id_img_to_plot=0):\n    '''\n    code: B,outH,outW, where outH is the output size of the encoder\n    id_img_to_plot: id of the img to plot in the batch, should be less than B\n    '''\n    z_idx=model._vq_vae._embedding(code).permute(0, 3, 1, 2)\n    out_img=model._decoder(z_idx)\n    plt.figure()\n    plt.imshow(out_img[id_img_to_plot].cpu().detach().squeeze(), cmap='gray')\n    plt.title('img generated from discrete code')\n\ndef test_image_generator():\n    valid_loader = gettestdata(**test_parameters)\n    data, tgt=next(iter(valid_loader))\n    tensor_img=torch.tensor(data).cuda()\n\n    #######test generation manually########\n    id_img_to_plot=0\n    plt.imshow(tensor_img[id_img_to_plot].cpu().detach().squeeze(), cmap='gray')\n    plt.title('input img')\n    out_e=model._pre_vq_conv(model._encoder(tensor_img))\n    B,C,H,W=out_e.shape\n    code=torch.argmax(model._vq_vae(out_e)[-1], dim=1).reshape(B,H,W)\n    gen_img_from_discrete_code(code, id_img_to_plot)\n    ######################################\n    #generate random discrete code\n    ind=np.random.randint(0,train_parameters['num_embeddings'],(1,H,W)).astype(np.long)#encoder divdes size by 4#it should be between 0 and K-1\n    ind_tensor=torch.LongTensor(ind).cuda()\n    gen_img_from_discrete_code(ind_tensor, id_img_to_plot)","0bb01377":"# Model VQ-VAE\n![architecture](https:\/\/miro.medium.com\/max\/1400\/1*wZ_dz7WNTFzin0IdOil6TQ.png)"}}