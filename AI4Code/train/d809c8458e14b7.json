{"cell_type":{"d2d3b319":"code","4bef94fe":"code","05b4738a":"code","09f80496":"code","ed1982ec":"code","7484bd84":"markdown"},"source":{"d2d3b319":"import numpy as np\nimport pandas as pd\nimport xgboost as xgb\n\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.utils.multiclass import unique_labels\n\ndata = pd.read_csv(\"..\/input\/dataset.csv\")\n\n# clean up column names\ndata.columns = data.columns.\\\n    str.strip().\\\n    str.lower()\n\n# remove non-numeric columns\ndata = data.select_dtypes(['number']) \n\n# split data into training & testing\ntrain, test = train_test_split(data, shuffle=True)\n\n# peek @ dataframe\ntrain.head()","4bef94fe":"# split training data into inputs & outputs\nX = train.drop([\"type\"], axis=1)\nY = train[\"type\"]\n\n# specify model (xgboost defaults are generally fine)\nmodel = xgb.XGBRegressor(tree_method = \"gpu_exact\")\n\n# fit our model\nmodel.fit(y=Y, X=X)","05b4738a":"# split testing data into inputs & output\ntest_X = test.drop([\"type\"], axis=1)\ntest_Y = test[\"type\"]\n\n# predictions & actual values, from test set\npredictions = model.predict(test_X) > 0\nactual = test_Y","09f80496":"# plot_confusion_matrix function is from scikit-learn's documentation: \n# https:\/\/scikit-learn.org\/stable\/auto_examples\/model_selection\/plot_confusion_matrix.html\ndef plot_confusion_matrix(y_true, y_pred, classes,\n                          normalize=False,\n                          title=None,\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    if not title:\n        if normalize:\n            title = 'Normalized confusion matrix'\n        else:\n            title = 'Confusion matrix, without normalization'\n\n    # Compute confusion matrix\n    cm = confusion_matrix(y_true, y_pred)\n    # Only use the labels that appear in the data\n    classes = classes[unique_labels(y_true, y_pred)]\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    fig, ax = plt.subplots()\n    im = ax.imshow(cm, interpolation='nearest', cmap=cmap)\n    ax.figure.colorbar(im, ax=ax)\n    # We want to show all ticks...\n    ax.set(xticks=np.arange(cm.shape[1]),\n           yticks=np.arange(cm.shape[0]),\n           # ... and label them with the respective list entries\n           xticklabels=classes, yticklabels=classes,\n           title=title,\n           ylabel='True label',\n           xlabel='Predicted label')\n\n    # Rotate the tick labels and set their alignment.\n    plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\",\n             rotation_mode=\"anchor\")\n\n    # Loop over data dimensions and create text annotations.\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i in range(cm.shape[0]):\n        for j in range(cm.shape[1]):\n            ax.text(j, i, format(cm[i, j], fmt),\n                    ha=\"center\", va=\"center\",\n                    color=\"white\" if cm[i, j] > thresh else \"black\")\n    fig.tight_layout()\n    return ax","ed1982ec":"# plot confusion matrix \nplot_confusion_matrix(actual, predictions, normalize=True, classes=data.type)","7484bd84":"This kernel has an XGBoost model that predicts whether a website is malicious or not. "}}