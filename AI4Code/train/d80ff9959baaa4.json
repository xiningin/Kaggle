{"cell_type":{"ed440366":"code","56187ddc":"code","0e1add61":"code","f5e94bad":"code","9e84b986":"code","2d9dd9bb":"code","d564da95":"code","2f630920":"code","2b8ae3ca":"code","d065e333":"code","e7a5fe9e":"code","14dda3b4":"code","906a5595":"code","b49d3c38":"code","2c63e11a":"markdown","2827a944":"markdown","0132e022":"markdown","ba4070eb":"markdown","cee5b3dc":"markdown","ed27fb1d":"markdown","22ceb964":"markdown","0c540d47":"markdown"},"source":{"ed440366":"#Import necessary libraries\nimport pandas as pd\nimport pandas_datareader\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nimport datetime as dt\nimport seaborn as sns\nimport plotly.express as px\nimport plotly.graph_objs as go\nfrom plotly.offline import plot,iplot\nfrom plotly.subplots import make_subplots\n\nplt.style.use('ggplot')","56187ddc":"#Select tickers\ntickers = ['AAPL','TSLA','GOOGL','AMZN','IBM','NVDA'] #choose your tickers here\n\n#choose the start date:\nstart = dt.datetime(2020,1,31)\n\n#we assume that the end date is TODAY:\nend = dt.datetime.now()","0e1add61":"#import the data\n#create a list of the series\nprices = []\n\nfor i in tickers:\n    p = pandas_datareader.DataReader(i,\n                                    data_source='yahoo',\n                                    start=start,\n                                    end = end)['Adj Close']\n    prices.append(p)","f5e94bad":"#fix incosistencies if any\n#create a sequence of dates to be used for refference\ndate_seq = pd.date_range(start=start, end=end)\n\n#create a list to hold the missing dates for each ticker\ndates = [[] for l in range(len(prices))] #reverse the list of dates if needed with: \"last_first = [date for date in dates[::-1]]\"\n\n#find the missing dates\nfor date in date_seq:\n        for p in range(0,len(prices)):          \n            if date in prices[p].index:\n                dates[p].append(date)\n            else:\n                dates[p].append('missing')\n\n#check differences\nfor i in range(0,len(dates)):\n    print(date_seq.difference(dates[i]))\n\n#get missing dates\nmissing_l = [[] for l in range(len(dates))] \n\nfor i in range(0,len(dates)):\n    missing_l[i] = date_seq.difference(dates[i])\n\n#Plot missing dates if there are nay\nfor i in range(0,len(missing_l)):\n    plt.bar(missing_l[i],len(missing_l[i]),label=tickers[i])\nplt.legend(loc='best')","9e84b986":"#create date mapping\nprices_new = pd.DataFrame(columns = [\"Date\"])\nprices_new['Date'] = pd.to_datetime(date_seq)\n\n#do a duplicate check\nfor i in range (0,len(prices)):\n    print(sum(prices[i].index.duplicated())) #there are duplicated rows in each series\n\n#merge and remove duplicates\nfor p in prices:\n    prices_new = pd.merge(prices_new, p,  on=\"Date\", how=\"left\")\n    if sum(prices_new['Date'].duplicated()) > 0:\n        prices_new = prices_new.drop_duplicates(subset = \"Date\")\n\n#duplicates check\nprices_new['Date'][prices_new['Date'].duplicated()]\nprint('Duplicated dates:',sum(prices_new['Date'].duplicated()))\n\n#look at the cleaned data:\nprices_new.head()","2d9dd9bb":"#rearrange dataframe\nprices_new = prices_new.set_index(\"Date\")","d564da95":"#fix colnames\nprices_new.columns = tickers\n\n#count the N of missing values\nprices_new.isna().sum()\n\n#impute missing data\n#Imputation: \n   # Because the series are not missing due to random mistakes, \n       # we can umpute the with the lagged variable a.k.a (LOCF):\nprices_new.fillna(method=\"ffill\", inplace=True)\nprices_new.head()","2f630920":"#make function for returns\ndef returns(x):\n    return (x - x.shift(1))\/x.shift(1)\n\n#get new dataframe with returns\nrets = prices_new.apply(returns)\n\n#compare function with pct_change\nrets.mean()\nrets.std()\n\n#set plotting parametes:\nplt.rcParams['figure.figsize'] = [14, 10]\n\n#plot absolute stock values\nprices_new.plot() #create plt plot\nplt.title('Absolute stock values')","2b8ae3ca":"#plot log values\nnp.log(prices_new).plot()\nplt.title('Logarithmic stock values')","d065e333":"#plot returns to examine statistical properties\nprices_new.pct_change(1).plot()\nplt.title('Stock returns')","e7a5fe9e":"#plot correlations\nprices_new.pct_change().corr()\nsns.heatmap(prices_new.pct_change().corr(),annot = True)\nplt.title('Correlations')","14dda3b4":"#create automated plots\nimport matplotlib.colors as mcolors\n\ntotal = len(rets.columns)\ncol_len = math.ceil(len(rets.columns)\/2)\nrow_len = total \/\/ col_len\nrow_len += total % col_len\n\nposition = range(1,total+1)\n\nfig1 = plt.figure(1)\nfor k in range(total):\n\n  ax1 = fig1.add_subplot(col_len,row_len,position[k])\n  fig1.suptitle('Histogram of returns')\n  ax1.hist(rets.iloc[:,[k]],color = list(mcolors.TABLEAU_COLORS.keys())[k])\n  ax1.set_xlabel(rets.columns[k])","906a5595":"#volatility vs returns over time\ntime_window = 30 #set time window(in this case a monthly moving average)\n\nmonthly_rets = rets.rolling(window=30).mean()\nmonthly_vol = rets.rolling(window=30).std()\n\nfig2 = plt.gcf()\nfor k in range(total):\n\n  ax2 = fig2.add_subplot(col_len,row_len,position[k])\n  fig2.suptitle('Monthly returns\/volatility')\n  ax2.plot(monthly_rets.iloc[:,[k]],label='returns')\n  ax2.plot(monthly_vol.iloc[:,[k]],label='volatility')\n  ax2.set_xlabel(monthly_rets.columns[k])\n  ax2.legend()","b49d3c38":"#Sortino and sharpre ratio\n#cumulative volatility and expected returns\n#cum returns and vol\nvol = prices_new.pct_change(1).std()\nr = prices_new.pct_change(1).mean() #expected returns\ns_volatility = rets[rets < 0].std() #vol by sortino\n\nSharpre_ratio = r\/vol\nSortino_ratio = r\/s_volatility\n\n#Create sortino plot\nSortino_ratio.plot(kind='bar',color=list(mcolors.TABLEAU_COLORS.keys())[0:len(r)])\nplt.title('Sortino ratio')\n\n#create Sharpre plot\nplt.figure()\nSharpre_ratio.plot(kind='bar',color=list(mcolors.TABLEAU_COLORS.keys())[0:len(r)])\nplt.title('Sharpre ratio')","2c63e11a":"**Put the dates in the df index:**","2827a944":"#  **Mini-tool for investment portfolio analysis**\n**Problem definition:** The problem that we're trying to solve is to create a financial report of any N number of assets. For this purpose we have to create dynamic charts of some key financial metrics and implement data cleaning and processing procedures to insure data validity.","0132e022":"**This part checks for duplicates**","ba4070eb":"**Get the data from Yahoo finance**","cee5b3dc":"**Choose tickers:**\nThe code creates dynamic charts and tables, so it should work with any N number of tickers","ed27fb1d":"**Now we are ready to analyze**","22ceb964":"**Here we check for missing values and missing patters within the series**","0c540d47":"**Now we have to impute the missing variables, according to the missing pattern, in this case we will use LOCF**"}}