{"cell_type":{"77fc8dfc":"code","36a099f7":"code","f0cf0636":"code","2930fc9c":"code","93196e17":"code","f8ee793b":"code","f60d1cb7":"code","0e40f07e":"code","a8ed0e15":"code","b603a085":"code","ff003f81":"code","416b5f52":"code","8937ad43":"code","073fe94e":"code","76fdb900":"code","3db4af47":"code","8b46e2ec":"code","017819f5":"code","b3669ef3":"code","a875d33a":"code","6d952a77":"code","77259ddb":"code","8b096e84":"code","ac6e3334":"code","10872d40":"code","23efab44":"code","9211e0f6":"code","0c0b141e":"code","1853a30a":"code","e221cafd":"markdown","0439c8d3":"markdown","9234ebc8":"markdown","389c5929":"markdown","30283900":"markdown","26e10f8a":"markdown","d9e74ac4":"markdown","2ec5cd14":"markdown","7407f46d":"markdown","1061b87c":"markdown","de8c248e":"markdown","55e5c63f":"markdown","5f11bcee":"markdown","4ac7d376":"markdown","ddbb10a5":"markdown"},"source":{"77fc8dfc":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","36a099f7":"# Importing packages\n# For plots\nfrom matplotlib import pyplot as plt\n# To count letters and characters\nfrom collections import Counter \n","f0cf0636":"test_path = '..\/input\/test.csv'\ntrain_path = '..\/input\/train.csv'\nsampleSubmission_path = '..\/input\/sample_submission.csv'","2930fc9c":"# Read and shows the head of the trainning data set\ntrain_data = pd.read_csv(train_path)#, index_col = 0)\ntrain_data.head()","93196e17":"# Read and shows the head of the test data set\ntest_data = pd.read_csv(test_path)#, index_col = 0)\ntest_data.head()","f8ee793b":"# Some Statistics from the train data set\ntrain_data.describe()","f60d1cb7":"test_data.describe()","0e40f07e":"# Columns name\nprint(train_data.columns)\nprint(test_data.columns)\n","a8ed0e15":"# first feature: create a 'length' column\ntrain_data['length'] = train_data.text.apply(len)\ntrain_data.head()","b603a085":"test_data['length'] = test_data.ciphertext.apply(len)\ntest_data.head()","ff003f81":"# filter the test dataframes by cypher level\ndf_level_1 = test_data[test_data.difficulty==1].copy()\ndf_level_2 = test_data[test_data.difficulty==2].copy()\ndf_level_3 = test_data[test_data.difficulty==3].copy()\ndf_level_4 = test_data[test_data.difficulty==4].copy()\n\ndf_level_1.head(3)\n#df_level_2.head(3)\n#df_level_3.head(3)\n#df_level_4.head(3)","416b5f52":"# Filter the train data set for difficult level\nLevel1_loc = df_level_1.loc[:].index.values\nfor i in range(len(Level1_loc)):\n    train_data[train_data['index'] == Level1_loc[i]].text.values","8937ad43":"for i in range(len(Level1_loc)):\n    train_level1 += train_data[train_data['index'] == Level1_loc[i]].text.values\n    \n\n\n\n#data_loc = train_data[train_data['index'] == Level1_loc[2]].index.values","073fe94e":"train_data[train_data['length']<=100]['length'].hist(bins=99)","76fdb900":"# using collections.Counter() to get count of each element in string  \nplain_char_cntr = Counter(''.join(train_data['text'].values))\nplain_stats_train = pd.DataFrame([[x[0], x[1]] for x in plain_char_cntr.items()], columns=['Letter', 'Frequency'])\nplain_stats_train = plain_stats_train.sort_values(by='Frequency', ascending=False)\nprint(plain_stats_train.head())\n","3db4af47":"# using collections.Counter() to get count of each element in string  \nplain_char_test = Counter(''.join(df_level_1['ciphertext'].values))\nplain_stats_test = pd.DataFrame([[x[0], x[1]] for x in plain_char_test.items()], columns=['Letter', 'Frequency'])\nplain_stats_test = plain_stats_test.sort_values(by='Frequency', ascending=False)\nprint(plain_stats_test.head())","8b46e2ec":"# Plot the frequencies\nf, ax = plt.subplots(figsize=(15, 5))\nplt.bar(np.array(range(len(plain_stats_test))) + 0.5, plain_stats_test['Frequency'].values)\nplt.bar(np.array(range(len(plain_stats_train))) + 0.5, plain_stats_train['Frequency'].values\/\/4, alpha=.5,color='green')\nplt.xticks(np.array(range(len(plain_stats_test))) + 0.5, plain_stats_test['Letter'].values)\nplt.show()","017819f5":"# Level of dificulty\nA1 = df_level_1.length\nprint('Level 1 \\n')\nprint(A1.describe())","b3669ef3":"# then we look in the training data to find the passage with the corresponding length\nmatching_pieces = train_data[(train_data.length>=401) & (train_data.length<=500)]\nmatching_pieces\n# only three unciphered texts length are in the interval: let's print them","a875d33a":"matching_pieces.text.values","6d952a77":"print('Unciphered text:\\n', train_data.loc[13862].text, '\\n\\nCiphered text (level 1):\\n', \n      df_level_1.loc[45272].ciphertext)","77259ddb":"# Function to decrypt the text\ndef decrypt_text(cipher_text):\n    l = 'abcdefghijklmnopqrstuvwxy'\n    u = 'ABCDEFGHIJKLMNOPQRSTUVWXY'\n    \n    key =  [15, 24, 11, 4]\n    key_index = 0\n    plain = ''\n\n    for character in cipher_text:\n        test = l.find(character)\n        if test != -1:\n            p = (test - key[key_index]) % 25\n            pc = l[p]\n            key_index = (key_index + 1) % len(key)\n        else:\n            test2 = u.find(character)\n            if test2 != -1:\n                p = (test - key[key_index]) % 25\n                pc = u[p]\n                key_index = (key_index + 1) % len(key)\n            else:\n                pc = character\n        \n        plain += pc\n        \n    return plain","8b096e84":"# Function to encrypt the text\ndef encrypt_text(plain_text):\n    l = 'abcdefghijklmnopqrstuvwxy'\n    u = 'ABCDEFGHIJKLMNOPQRSTUVWXY'\n    \n    key =  [15, 24, 11, 4]\n    key_index = 0\n    encrypted = ''\n\n    for character in plain_text:\n        test = l.find(character)\n        if test != -1:\n            p = (test + key[key_index]) % 25\n            pc = l[p]\n            key_index = (key_index + 1) % len(key)\n        else:\n            test2 = u.find(character)\n            if test2 != -1:\n                p = (test + key[key_index]) % 25\n                pc = u[p]\n                key_index = (key_index + 1) % len(key)\n            else:\n                pc = character\n        \n        encrypted += pc\n        \n    return encrypted","ac6e3334":"plain_text = train_data.loc[13862].text\ncipher_text = df_level_1.loc[45272].ciphertext\n\nprint('Plain text = \\n', plain_text, '\\n\\n')\nprint('Decrypted text = \\n', decrypt_text(cipher_text), '\\n\\n')\nprint('Encrypted text = \\n', encrypt_text(plain_text), '\\n\\n')","10872d40":"df_level_1.loc[Level1_loc[2]].ciphertext","23efab44":"Level1_loc = df_level_1.loc[:].index.values\ntrain_data[train_data['index'] == Level1_loc[2]]\n\ndata_loc = train_data[train_data['index'] == Level1_loc[2]].index.values\nplain_text = train_data.loc[data_loc].text.values\ncipher_text = df_level_1.loc[Level1_loc[2]].ciphertext\n\n\nprint('Plain text = \\n', plain_text, '\\n\\n')\nprint('Decrypted text = \\n', decrypt_text(cipher_text), '\\n\\n')","9211e0f6":"KEYLEN = 4 # len('pyle')\ndef decrypt_level_1(ctext):\n    \n    key = [ord(c) - ord('a') for c in 'pyle']\n    print('Key = ', key)\n    \n    key_index = 0\n    plain = ''\n    for c in ctext:\n        cpos = 'abcdefghijklmnopqrstuvwxy'.find(c)\n        print('c = ', c)\n        print('cpos = ', cpos)\n        if cpos != -1:\n            p = (cpos - key[key_index]) % 25\n            print('p = ', p)\n            pc = 'abcdefghijklmnopqrstuvwxy'[p]\n            key_index = (key_index + 1) % KEYLEN\n        else:\n            cpos = 'ABCDEFGHIJKLMNOPQRSTUVWXY'.find(c)\n            if cpos != -1:\n                p = (cpos - key[key_index]) % 25\n                pc = 'ABCDEFGHIJKLMNOPQRSTUVWXY'[p]\n                key_index = (key_index + 1) % KEYLEN\n            else:\n                pc = c\n        plain += pc\n                              \n    return plain\n\ndef encrypt_level_1(ptext, key_index=0):\n    key = [ord(c) - ord('a') for c in 'pyle']\n    ctext = ''\n    for c in ptext:\n        pos = 'abcdefghijklmnopqrstuvwxy'.find(c)\n        if pos != -1:\n            p = (pos + key[key_index]) % 25\n            cc = 'abcdefghijklmnopqrstuvwxy'[p]\n            key_index = (key_index + 1) % KEYLEN\n        else:\n            pos = 'ABCDEFGHIJKLMNOPQRSTUVWXY'.find(c)\n            if pos != -1:\n                p = (pos + key[key_index]) % 25\n                cc = 'ABCDEFGHIJKLMNOPQRSTUVWXY'[p]\n                key_index = (key_index + 1) % KEYLEN\n            else:\n                cc = c\n        ctext += cc\n    return ctext\n\ndef test_decrypt_level_1(c_id):\n    \n    ciphertext = test_data[test_data['ciphertext_id'] == c_id].ciphertext.values\n    print('Ciphertxt:', ciphertext)\n    decrypted = decrypt_level_1(ciphertext)\n    print('Decrypted:', decrypted)\n    encrypted = encrypt_level_1(decrypted)\n    print('Encrypted:', encrypted)\n    print(\"Encrypted == Ciphertext:\", encrypted == ciphertext)\n\n\nc_id = 'ID_4a6fc1ea9'\ntest_decrypt_level_1(c_id) ","0c0b141e":" test_data[test_data['ciphertext_id'] =='ID_4a6fc1ea9']","1853a30a":"A2 = df_level_2.length\nprint('\\n Level 2 \\n')\nprint(A2.describe())","e221cafd":"## **Test data fields**\n1. **ciphertext_id** - A unique ID for each line's ciphertext in the set.\n2. **ciphertext** - A segment of encrypted text.\n3. **difficulty** - Each document has been encrypted with between 1 and 4 ciphers. The difficulty level of a segment of ciphertext denotes which ciphers were used, and in what order.","0439c8d3":"### Some Statistics from the test data set","9234ebc8":"## **Training data fields**\n1. **plaintext_id** - A unique ID for each line in the set.\n2. **text** - The unpadded, unencrypted text of the review.\n3. **index** - A unique ID that should be assigned to each ciphertext_id in test.csv when you've decrypted (or think you've correctly decrypted!) its ciphertext.","389c5929":"# **Visualization**","30283900":"Thanks to Paul Dnt for his Public Kernel with ideas of how to start!!! https:\/\/www.kaggle.com\/pednt9\/something-to-begin-with-a-first-hint\/comments","26e10f8a":"# **Read Data**","d9e74ac4":"From: https:\/\/www.kaggle.com\/kaggleuser58\/cipher-challenge-iii-level-1","2ec5cd14":"## **File descriptions**\n1. **training.csv** - the training data - contains plaintext_ids and text samples for each Shakespearean line in the training set, along with a unique index.\n\n2. ** test.csv** - the test data - ciphertext_ids, ciphertext, and a difficulty level indicating which ciphers were used.\n\n3. **sample_submission.csv** - a sample submission file in the correct format.","7407f46d":"## Count letters in the string","1061b87c":"# **Ciphertext Challenge III**","de8c248e":"## Decrypt Level 1","55e5c63f":"### Test Data Set","5f11bcee":"### Some Statistics from the train data set","4ac7d376":"* ## Understanding level 1","ddbb10a5":" ## Understanding level 2"}}