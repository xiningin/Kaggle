{"cell_type":{"f30883df":"code","7b021343":"code","84c6e1b3":"code","880b59e9":"code","8106b50d":"code","155d155b":"code","44b56f20":"code","0df8c512":"code","032bbceb":"code","47d1db8d":"code","2b2e6bb8":"code","199d8cbd":"code","22b8b33a":"code","fb4f73af":"code","a8053974":"code","16f9bcd5":"code","4b91a27d":"code","7d1dfacf":"code","3f101c2b":"code","0911bda6":"code","146a7274":"code","a7126903":"code","22e28e81":"code","1df3001c":"code","7594bf8f":"code","aab80872":"code","40b26691":"code","14265bd8":"code","c5dcd6a3":"markdown","f491fc0d":"markdown","81ccc687":"markdown","e1521240":"markdown","c84007a6":"markdown","7c35ccdd":"markdown","724c5a18":"markdown","08351060":"markdown","adc58ef5":"markdown","d52fc9ee":"markdown","962d840c":"markdown","a2a79eaa":"markdown","b8cab049":"markdown","22cd9eea":"markdown","8d0604b5":"markdown","cf9fbcdc":"markdown","6a1c5df4":"markdown","c69645c2":"markdown","d8302cf7":"markdown","66539414":"markdown","2bad314d":"markdown","d32bc553":"markdown","243a400f":"markdown","d37026a0":"markdown","13099c23":"markdown","39d59d0c":"markdown","64c10072":"markdown","f63e6750":"markdown","a5c6a74d":"markdown","1c5b9383":"markdown","2de02529":"markdown","77ab734a":"markdown","2db71696":"markdown","84b8ea93":"markdown","c39016cd":"markdown","2cbc99c8":"markdown","365c0af4":"markdown","299cb757":"markdown","808909ea":"markdown","d7cbd54c":"markdown","6512b835":"markdown","70abb66f":"markdown","0a37f64f":"markdown","25d7f962":"markdown","c27ec9c6":"markdown"},"source":{"f30883df":"# To read and handle data files\nimport pandas as pd\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\n\n# For handling arrays and vectors\nimport numpy as np\n\n# For visualization\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# For creating wordcloud\nfrom wordcloud import WordCloud\n\n# For string manipulation\nimport string\n\n# For creating vectors from text and determining similarity\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\n# To display DataFrame\nfrom IPython.display import display\n\n# Supress warnings\nimport warnings\nwarnings.filterwarnings('ignore')","7b021343":"# Download data files from Google Drive\n!pip install gdown\n!gdown --id 11lg5kzdTidiiYjqlfLXQn0r8yi5ae77O\n!gdown --id 1DXMxVci-rdvXGgtf8fRXr6wWS-FFxUA4\n!gdown --id 1M9oq8IN-Icr5S1-aPenEqcJux41ubERa","84c6e1b3":"# Read data file and display first 5 records\ntracks = pd.read_csv('.\/tracks_transformed.csv', na_filter=False)\ntracks.head()","880b59e9":"# Read artists data file\nartists = pd.read_csv('.\/artists_transformed.csv')\n\n# Drop rows with null values\nartists.dropna(inplace=True)\n\n# Convert \"followers\" field to numeric\nartists['followers'] = pd.to_numeric(artists['followers'])\n\n# Display first 5 records\nartists.head()","8106b50d":"# Read genres data file and display first 5 records\ngenres = pd.read_csv('.\/data_by_genres_o.csv', na_filter=False)\ngenres.head()","155d155b":"# Display summary statistics for tracks data\ntracks.describe().transpose()","44b56f20":"# Display summary statistics for artists data\nartists.describe().transpose()","0df8c512":"# Get top 10 most popular tracks\npopular_songs = tracks.groupby('name')['popularity'].mean().sort_values(ascending=False).head(10)\n\n# Plot horizontal bar chart\nplt.figure(figsize=(16, 10))\nplt.barh(popular_songs.index, popular_songs)\nplt.title('Most Popular Songs\/Tracks', fontdict=dict(fontsize=15), fontweight='bold')\nplt.xlabel('Popularity', fontdict=dict(fontsize=15), fontweight='bold')\nplt.ylabel('Song\/Track Name', fontdict=dict(fontsize=15), fontweight='bold')\nplt.xticks(fontsize='large', weight='bold')\nplt.yticks(fontsize='large', weight='bold')\nfor i, v in enumerate(popular_songs):\n    plt.text(v+0.5, i-0.15, str(int(v)), fontdict=dict(fontsize=15), fontweight='bold')\nplt.show()","032bbceb":"# Get top 10 most popular artists\npopular_artists = artists.groupby('name')['popularity'].mean().sort_values(ascending=False).head(10)\n\n# Plot horizontal bar chart\nplt.figure(figsize=(16, 10))\nplt.barh(popular_artists.index, popular_artists)\nplt.title('Most Popular Artists', fontdict=dict(fontsize=15), fontweight='bold')\nplt.xlabel('Popularity', fontdict=dict(fontsize=15), fontweight='bold')\nplt.ylabel('Artist Name', fontdict=dict(fontsize=15), fontweight='bold')\nplt.xticks(fontsize='large', weight='bold')\nplt.yticks(fontsize='large', weight='bold')\nfor i, v in enumerate(popular_artists):\n    plt.text(v+0.5, i-0.15, str(int(v)), fontdict=dict(fontsize=15), fontweight='bold')\nplt.show()","47d1db8d":"# Get top 10 most followed artists\npopular_artists = artists.groupby('name')['followers'].mean().sort_values(ascending=False).head(10)\n\n# Plot horizontal bar chart\nplt.figure(figsize=(16, 10))\nplt.barh(popular_artists.index, popular_artists)\nplt.title('Most Followed Artists', fontdict=dict(fontsize=15), fontweight='bold')\nplt.xlabel('Number of Followers', fontdict=dict(fontsize=15), fontweight='bold')\nplt.ylabel('Artist Name', fontdict=dict(fontsize=15), fontweight='bold')\nplt.xticks(fontsize='large', weight='bold')\nplt.yticks(fontsize='large', weight='bold')\nfor i, v in enumerate(popular_artists):\n    plt.text(v+0.5, i-0.15, str(int(v\/\/1000000))+'M', fontdict=dict(fontsize=15), fontweight='bold')\nplt.show()","2b2e6bb8":"# Text from \"genre\" column in genres data\ngenre_text = ' '.join(genre for genre in genres.genres.astype(str))\n\n# Generate wordcloud using text\nwc = WordCloud(background_color=\"white\")\nwordcloud = wc.generate(genre_text)\n\n# Display wordcloud\nplt.axis('off')\nplt.figure(figsize=(16, 10))\nplt.imshow(wordcloud)\nplt.show()","199d8cbd":"# Get top 10 most popular genres\npopular_genres = genres.groupby('genres')['popularity'].mean().sort_values(ascending=False).head(10)\n\n# Plot horizontal bar chart\nplt.figure(figsize=(16, 10))\nplt.barh(popular_genres.index, popular_genres)\nplt.title('Most Popular Genres', fontdict=dict(fontsize=15), fontweight='bold')\nplt.xlabel('Popularity', fontdict=dict(fontsize=15), fontweight='bold')\nplt.ylabel('Genre', fontdict=dict(fontsize=15), fontweight='bold')\nplt.xticks(fontsize='large', weight='bold')\nplt.yticks(fontsize='large', weight='bold')\nfor i, v in enumerate(popular_genres):\n    plt.text(v+0.5, i-0.15, str(int(v)), fontdict=dict(fontsize=15), fontweight='bold')\nplt.show()","22b8b33a":"# Sort tracks data based on popularity and take first 10,000 records\nsong_library = tracks.sort_values(by=['popularity'], ascending=False).head(10000)\n\n# Drop \"id_artists\" field from DataFrame\nsong_library.drop(['id_artists'], axis=1, inplace=True)\n\n# Reset index for DataFrame\nsong_library.reset_index(inplace=True, drop=True)\n\n# Display first 5 records\nsong_library.head()","fb4f73af":"# Create CountVectorizer object to transform text into vector\nsong_vectorizer = CountVectorizer()\n\n# Fit the vectorizer on \"genres\" field of song_library DataFrame\nsong_vectorizer.fit(song_library['genres'])","a8053974":"# Function to recommend more songs based on given song name\ndef song_recommender(song_name):\n    try:\n        # Numeric columns (audio features) in song_library DataFrame\n        num_cols = ['release_year', 'duration_s', 'popularity', 'danceability', 'energy', 'key', 'loudness',\n                    'mode', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo']\n\n        # Create vector from \"genres\" field (text data) for given song\n        text_vec1 = song_vectorizer.transform(song_library[song_library['name']==str(song_name)]['genres']).toarray()\n\n        # Create vector from numerical columns for given song\n        num_vec1 = song_library[song_library['name']==str(song_name)][num_cols].to_numpy()\n\n        # Initialise empty list to store similarity scores\n        sim_scores=  []\n\n        # For every song\/track in song library, determine cosine similarity with given song\n        for index, row in song_library.iterrows():\n            name = row['name']\n\n            # Create vector from \"genres\" field for other songs\n            text_vec2 = song_vectorizer.transform(song_library[song_library['name']==name]['genres']).toarray()\n\n            # Create vector from numerical columns for other songs\n            num_vec2 = song_library[song_library['name']==name][num_cols].to_numpy()\n\n            # Calculate cosine similarity using text vectors\n            text_sim = cosine_similarity(text_vec1, text_vec2)[0][0]\n\n            # Calculate cosine similarity using numerical vectors\n            num_sim = cosine_similarity(num_vec1, num_vec2)[0][0]\n\n            # Take average of both similarity scores and add to list of similarity scores\n            sim = (text_sim + num_sim)\/2\n            sim_scores.append(sim)\n        \n        # Add new column containing similarity scores to song_library DataFrame\n        song_library['similarity'] = sim_scores\n\n        # Sort DataFrame based on \"similarity\" column\n        song_library.sort_values(by=['similarity', 'popularity', 'release_year'], ascending=[False, False, False], inplace=True)\n\n        # Create DataFrame \"recommended_songs\" containing 5 songs that are most similar to the given song and return this DataFrame\n        recommended_songs = song_library[['name', 'artists', 'release_year']][2:7]\n        return recommended_songs\n    except:\n        # If given song is not found in song library then display message\n        print('{} not found in songs library.'.format(song_name))","16f9bcd5":"# More songs like Hail to the King by Avenged Sevenfold\nsong_recommender('Hail to the King')","4b91a27d":"# More songs like Eye of the Tiger by Survivor\nsong_recommender('Eye of the Tiger')","7d1dfacf":"# More songs like Blinding Lights by The Weeknd\nsong_recommender('Blinding Lights')","3f101c2b":"# Sort artists data based on popularity and take first 10,000 records\nartist_library = artists.sort_values(by=['popularity', 'followers'], ascending=[False, False]).head(10000)\n\n# Reset index for DataFrame\nartist_library.reset_index(inplace=True, drop=True)\n\n# Display first 5 records\nartist_library.head()","0911bda6":"# Create CountVectorizer object to transform text into vector\nartist_vectorizer = CountVectorizer()\n\n# Fit the vectorizer on \"genres\" field of song_library DataFrame\nartist_vectorizer.fit(artist_library['genres'])","146a7274":"# Function to recommend more artists based on given artist name\ndef artist_recommender(artist_name):\n    try:\n        # Numeric columns (audio features) in artist_library DataFrame\n        num_cols = ['followers', 'popularity']\n\n        # Create vector from \"genres\" field (text data) for given artist\n        text_vec1 = artist_vectorizer.transform(artist_library[artist_library['name']==str(artist_name)]['genres']).toarray()\n\n        # Create vector from numerical columns for given song\n        num_vec1 = artist_library[artist_library['name']==str(artist_name)][num_cols].to_numpy()\n\n        # Initialise empty list to store similarity scores\n        sim_scores = []\n\n        # For every artist in artist library, determine cosine similarity with given artist\n        for index, row in artist_library.iterrows():\n            name = row['name']\n\n            # Create vector from \"genres\" field for other artists\n            text_vec2 = artist_vectorizer.transform(artist_library[artist_library['name']==name]['genres']).toarray()\n\n            # Create vector from numerical columns for other songs\n            num_vec2 = artist_library[artist_library['name']==name][num_cols].to_numpy()\n\n            # Calculate cosine similarity using text vectors\n            text_sim = cosine_similarity(text_vec1, text_vec2)[0][0]\n\n            # Calculate cosine similarity using numerical vectors\n            num_sim = cosine_similarity(num_vec1, num_vec2)[0][0]\n\n            # Take average of both similarity scores and add to list of similarity scores\n            sim = (text_sim + num_sim)\/2\n            sim_scores.append(sim)\n\n        # Add new column containing similarity scores to artist_library DataFrame\n        artist_library['similarity'] = sim_scores\n\n        # Sort DataFrame based on \"similarity\" column\n        artist_library.sort_values(by=['similarity', 'popularity', 'followers'], ascending=[False, False, False], inplace=True)\n\n        # Create DataFrame \"recommended_artists\" containing 5 artists that are most similar to the given artist, sort and return this DataFrame\n        recommended_artists = artist_library[['name', 'genres', 'followers', 'popularity']][2:7]\n        recommended_artists.sort_values(by=['popularity', 'followers'], ascending=[False, False], inplace=True)\n        return recommended_artists\n    except:\n        # If given artist is not found in artist library then display message\n        print('{} not found in artists library.'.format(artist_name))","a7126903":"# More artists like Def Leppard\nartist_recommender('Def Leppard')","22e28e81":"# More artists like Opeth\nartist_recommender('Opeth')","1df3001c":"# More artists like Diljit Dosanjh\nartist_recommender('Diljit Dosanjh')","7594bf8f":"# Function to recommend similar songs and artists based on song name\ndef spotify_recommender(song_name):\n    try:\n        # Get DataFrame of recommended songs using song_recommender() function\n        recommended_songs = song_recommender(song_name)\n\n        # Create empty DataFrame to store details of recommended artists\n        recommended_artists = pd.DataFrame({'name':[], 'genres':[], 'followers':[], 'popularity':[]})\n\n        # Get contributing artists for given song\n        artists = song_library[song_library['name']==str(song_name)]['artists'].values[0].split(',')\n\n        # For each contributing artist, get recommended artists using artist_recommender() function\n        for artist in artists:\n            artist_name = artist.strip()\n\n            # Concatenate returned DataFrame with recommended_artists DataFrame\n            recommended_artists = pd.concat([recommended_artists, artist_recommender(artist_name)])\n        \n        # Sort DataFrame based on \"popularity\" and \"followers\" columns\n        recommended_artists.sort_values(by=['popularity', 'followers'], ascending=[False, False], inplace=True)\n\n        # Display recommended songs    \n        print('More songs you might like:')\n        display(recommended_songs)\n\n        # Display recommended artists\n        print('\\n\\nOther artists you might like:')\n        display(recommended_artists.head())\n    except:\n        # If given song is not found in song library then display message\n        print('{} not found in songs library.'.format(song_name))","aab80872":"# Recommendations for the song \"Nero Forte\" by Slipknot\nspotify_recommender('Nero Forte')","40b26691":"# Recommendations for the song \"La Camisa Negra\" by Juanes\nspotify_recommender('La Camisa Negra')","14265bd8":"# Recommendations for the song \"Congratulations\" by Post Malone\nspotify_recommender('Congratulations')","c5dcd6a3":"Spotify, founded on 23rd April 2006, is the world's largest music streaming service provider, with over 365 million monthly active users, including 165 million paying subscribers, as of June 2021.\n\nIn Spotify's apps, music can be browsed or searched for via various parameters, such as artist, album, genre, playlist, or record label. Users can create, edit and share playlists, share tracks on social media, and make playlists with other users. Spotify provides access to over 70 million songs, 2.2 million podcasts and 4 billion playlists.","f491fc0d":"# Modelling","81ccc687":"In the same way that I created the *song_recommender()* function, I have created a similar function to recommend similar artists based on the artist name given. The concept behind both recommender functions is the same, with the only difference being the data used.\n\nAgain, for demonstration purposes, I have taken the top 10,000 most popular artists from the pool of all artists.","e1521240":"**What are recommendation systems?**\n\nRecommender systems are active information filtering systems which personalize the information coming to a user based on their interests, relevance of the information etc. Recommender systems are used widely for recommending movies, articles, restaurants, places to visit, items to buy etc.\n\nSimply put, recommendation systems \"recommend\" personalized content on the basis of user\u2019s past\/current preference to improve the user experience. Broadly, there are two types of recommendation systems \u2013 **Content-based & Collaborative filtering based**.\n\nYouTube sugesting relevant videos to viewers based on their previous browsing history, as well as LinkedIn suggesting users to connect with other users they may know, are instances of recommendation systems in action.","c84007a6":"Some observations:\n\n1. The tracks data contains songs that were released as early as in 1900, up untill 2021.\n2. The longest song\/track is about **5621 seconds (93 minutes)** long, and the shortest song\/track is only **3 seconds** long.\n3. On average, the songs are fairly danceable (mean value = 0.563) and energetic (mean value = 0.542).\n4. The mean tempo for songs\/tracks on Spotify is about 118 beats per minute (BPM), while the fastest song has a tempo of **246.381 BPM**.","7c35ccdd":"### 1.1. Tracks data","724c5a18":"For modelling, I have used tracks data, which contains information about each song\/track, including a number of audio features as well as the music genre of that song.\n\nTo use the genre information (text data) in the vector space model, I have transformed the genres text into a vector using the **CountVectorizer** toool available in the sklearn library.\n\nThe audio features are numerical values which can be used directly to create a vector to represent each song in the vector space model.\n\nFinally, the similarity between two songs is determined using the cosine similarity metric, based on the vectors generated for each song.","08351060":"Justin Bieber falls to 4th place in term of number of folllowers on Spotify, behind Drake, who has a lower popularity rating.\n\nThe most followed artist on Spotify is **Ed Sheeran**, with a massive 78.9 million followers.","adc58ef5":"## 1. Song recommender","d52fc9ee":"**How does a content-based recommendation system work?**\n\nContent-based filtering methods are based on a description of the item and a profile of the user's preferences. Content-based recommenders treat recommendation as a user-specific classification problem and learn a classifier for the user's likes and dislikes based on an item's features.\n\nBasically, these methods use an item profile (i.e., a set of discrete attributes and characteristics) characterizing the item within the system. To abstract the features of the items in the system, an item presentation algorithm is applied. A widely used algorithm is the **vector space representation**.\n\nSuch a content-based recommendation system makes recommendations based on the \"proximity\" of an item's vector to the vector of an item that the user likes. Those items whose vector representations are close to the vector representation of an item already liked by the user are recommended.","962d840c":"![Spotify Logo](https:\/\/2672686a4cf38e8c2458-2712e00ea34e3076747650c92426bbb5.ssl.cf1.rackcdn.com\/2019-02-06-06-11-02.png)","a2a79eaa":"[Yamac Eren Ay](https:\/\/www.kaggle.com\/yamaerenay) has collected a Spotify dataset, containing details of ~600,000 songs\/tracks, using the Spotify Web API. This amazing dataset is available on Kaggle, check it out [here](https:\/\/www.kaggle.com\/yamaerenay\/spotify-dataset-19212020-160k-tracks).","b8cab049":"The latest version of the dataset consists of the following files:\n\n1. **artists.csv:** Details of 1.1M artists on Spotify.\n2. **data_by_artist_o.csv:** Audio features for each artist.\n3. **data_by_genres_o.csv:** Audio features for each genre.\n4. **data_by_year_o.csv:** Audio features of songs in different year.\n5. **data_o.csv:** Original data containing audio features of tracks.\n6. **tracks.csv:** Audio features of 600k tracks available on Spotify.","22cd9eea":"## 4. Most followed artists","8d0604b5":"## 2. Artists recommender","cf9fbcdc":"## 6. Most popular genres","6a1c5df4":"The most popular song on Spotify (in terms of popularity rating) is **Olivia Rodrigo's drivers license**, with a popularity rating of 99.\n\nThe 2nd most popular song is **Blinding Lights by The Weeknd**, followed by **Friday** in 3rd.","c69645c2":"Let's now visualize the data available through some basic charts to gain some more insight.","d8302cf7":"**Vector space model for recommendation systems**\n\nThe Vector Space Model is used commonly in content-based recommendation systems. In this model, each item is represented as a **vector of its attributes** in an n-dimensional space and the angle between the vectors is calculated to determine the similarity between the vectors.\n\n**Cosine similarity measure** is widely used to determine the proximity of two vectors represented using this model, and ultimately give a measure of the similarity between the vectors.","66539414":"Here is a wordcloud generated using the different genres available in the genres data.","2bad314d":"The above chart shows the most popular music genres, based on the popularity rating.\n\nThe most popular genre is **basshall**, followed by **turkish edm** and **south african house**.","d32bc553":"# Conclusion","243a400f":"## 5. Genre WordCloud","d37026a0":"In this section, I will be developing the content-based recommendation system, based on the vector space model described above.","13099c23":"I have performed data transformation for this dataset to convert the exisiting data into a more usable form for modelling and developing the recommendation system. The final data that I will be using to develop the recommendation system is the **tracks_transformed.csv** and **artists_transformed.csv** file.\n\nCheck out the [data preprocessing and transformation notebook](https:\/\/github.com\/prathamSharma25\/Spotify-CBRS\/blob\/main\/Spotify_Data_Transformation.ipynb).","39d59d0c":"# Exploratory Data Analysis","64c10072":"In this section, I have created a function to recommend songs based on an input song name. Songs similar to the one provided to the function are determined using the vector space model explained above.\n\nFor demonstration purpose, I have reduced the size of the song library to only the top 10,000 most popular songs, based on the popularity rating.","f63e6750":"## Data Description","a5c6a74d":"# Content-based Recommendation Systems","1c5b9383":"Hence, this notebook shows the step-by-step procedure to develop a content-based recommendation system for Spotify. The concept explained and implemented can be extended to any other service, say products on Amazon, or courses on Coursera.","2de02529":"## 3. Most popular artists","77ab734a":"# Data","2db71696":"# Introduction","84b8ea93":"As a popular music streaming service, it is used by a large number of people all over the world on a daily basis. One way in which Spotify keeps its users not only satisfied with, but also hooked to the platform, is by making smart and personal recommendations to users based on their listening history.\n\nSuch recommendation systems are used by many more companies to provide a highly personal user experience.\n\nIn this notebook, I will be developing a basic content-based recommendation system for Spotify. This begins with a gentle introduction to content-based recommendation systems and the underlying concepts. Further, I will be performing basic Exploratory Data Analysis (EDA) before going on to build the recommendation system.","c39016cd":"The function defined in the next code cell brings together the functions *song_recommender()* and *artist_recommender()* to create a complete Spotify recommender function.","2cbc99c8":"The most popular artist on Spotify (in terms of popularity rating) is **Justin Bieber**, with a popularity rating of 100, followed by **Bad Bunny** and **Drake**.\n\nHowever, Justing Bieber is not the most followed artist, as we will see next.","365c0af4":"### 1.2. Artists data","299cb757":"## 3. Complete Spotify recommender","808909ea":"## 1. Summary statistics","d7cbd54c":"## 2. Most popular songs\/tracks","6512b835":"**An example**\n\nAs an example, consider the songs *This Means War (Artist: Avenged Sevenfold; Genre: Heavy Metal)*, *Sad But True (Artist: Metallica; Genre: Heavy Metal)*, *Juice (Artist: Lizzo; Genre: Pop\/Funk\/Rock)* and *Something Big (Artist: Shawn Mendes; Genre: Pop)*.\n\nUsing the vector space model, the four songs (items) may be represented in terms of the two attributes 'acousticness' and 'tempo' as shown below.\n\n![](https:\/\/drive.google.com\/uc?export=view&id=172FHhvj_Zg8v0BYqQjX3ITw-3_nlt5zS)\n\nAs shown, the vectors for the first two songs are closer to each other than to the other two songs. Vectors that lie closer to each other in the vector space have a small angle between them. In turn, the value of the cosine of this angle between the vectors will be high. This measure can be used to determine the similarity between two vectors, and hence two songs (items).\n\nHence, a content-based recommendation system will recommend the song *Sad But True* to a user who likes the song *This Means War*. Similarly, a user who likes *Juice* may be recommended *Something Big*, and not *Sad But True*.\n\nThis is the basic concept behind the recommendation system that I will be developing in this notebook.","70abb66f":"**Important terms related to recommendation systems**\n\n1. **Item:** In the context of recommendation systems, an **item** refers to content whose characteristics are used in the recommender models. These could be movies, documents, book etc. In this case, each song available on Spotify is an item.\n\n2. **Attribute:** An **attribute** refers to the characteristic of an item. In this case, each song (item) has different characteristics such as tempo, genre, acousticness, etc.","0a37f64f":"Some observations:\n\n1. The most followed artist on Spotify has **78.90 million** followers.\n2. On average, an artist on Spotify has about 38,506 followers.","25d7f962":"Some of the audio features that describe songs\/tracks are:\n\n1. **Acousticness:** Whether the song\/track is acoustic or not.\n2. **Tempo:** The tempo of the song\/track, measured in beats per minute (BPM).\n3. **Energy:** How energetic the song\/track is.\n4. **Liveness:** Whether a live audience is present or the song\/track is studio recorded.\n5. **Valence:** How positive the the music is.\n\nThese features are the attributes that describe each item, and will be used to determine vectors for each item (song\/track).","c27ec9c6":"Let's first take a quick look at the summary statistics for the tracks, artists and genres data. This will give us a number of statistical measures, such as mean value, median value, and maximum value, for each numerical field in the data."}}