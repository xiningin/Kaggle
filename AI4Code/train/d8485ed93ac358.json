{"cell_type":{"fed2e547":"code","1b6d2248":"code","824a7666":"code","76bc54dd":"code","4d48f67e":"code","4d7dbff1":"code","b43c6673":"code","fbd66f0b":"code","0316868d":"markdown","03d23970":"markdown","38c9a0df":"markdown","959ec1ac":"markdown","aca789e9":"markdown","ff96699c":"markdown","f4f4dec7":"markdown","200b4919":"markdown","3ca0e339":"markdown"},"source":{"fed2e547":"#Precisamos fazer o download do ambiente de Connect X:\n# Vamos precisar de um kaggle-enviroments customizado para a avalia\u00e7\u00e3o.\n!pip install git+https:\/\/github.com\/matheusgmaia\/kaggle-environments\n    ","1b6d2248":"#Criar ambiente\nfrom kaggle_environments import evaluate, make, utils\n\nenv = make(\"connectx\", debug=True)\nenv.render()","824a7666":"# -*- coding: utf-8 -*-\nimport random\nimport numpy as np\nAI_MOVE = 1\nHUMAN_MOVE = 2\n\n\n\n\ndef terminal_node(board):\n    \"\"\"\n    Checa se o estado atual do tabuleiro \u00e9 um estado terminal - 4 pe\u00e7as foram conectadas\n    \"\"\"\n    score = eval_board(board)\n    if score > 100000:\n        return True\n    elif score < -100000:\n        return True\n    \n    return False\ndef eval_board(board):\n    \"\"\"\n    Avalia o estado de um tabuleiro e retorna o seu score\n    \"\"\"\n    def __eval_window(agent_tiles, human_tiles, score=0):\n        \"\"\"\n        Fun\u00e7\u00e3o Heur\u00edstica. Retorna um valor para cada situa\u00e7\u00e3o de janela com 4 pe\u00e7as.\n        \"\"\"\n        # Caso terminal\n        if agent_tiles == 4:\n            score += 1000000 # Um valor absurdamente alto define um estado terminal\n        # human_tiles = 0\n        elif agent_tiles == 3 and human_tiles == 0:\n            score += 50\n        elif agent_tiles == 2 and human_tiles == 0:\n            score += 15\n        elif agent_tiles == 1 and human_tiles == 0:\n            score += 1\n\n        # human_tiles = 1\n        elif agent_tiles == 3 and human_tiles == 1:\n            score += 8\n        elif agent_tiles == 2 and human_tiles == 1:\n            score += 5\n        elif agent_tiles == 1 and human_tiles == 1:\n            score += 0\n        elif agent_tiles == 0 and human_tiles == 1:\n            score -= 1\n\n        # human_tiles = 2\n\n        elif agent_tiles == 2 and human_tiles == 2:\n            score += 0\n        elif agent_tiles == 1 and human_tiles == 2:\n            score -= 5\n        elif agent_tiles == 0 and human_tiles == 2:\n            score -= 15\n\n        # human_tiles = 3\n\n        elif agent_tiles == 1 and human_tiles == 3:\n            score -= 8\n        elif agent_tiles == 0 and human_tiles == 3:\n            score -= 50\n\n        # human_tiles = 4\n        elif human_tiles == 4:\n            score -= 1000000 # Um valor absurdamente alto define um estado terminal\n\n        return score\n\n    def __eval_hor(board, score=0):\n        \"\"\"\n        Avalia as pontua\u00e7\u00f5es do tabuleiro horizontalmente\n        \"\"\"\n        # Pegando a linha\n        cols = board.shape[1]\n        rows = board.shape[0]\n        # Percorre todas as linhas e avalia janelas de 4 pe\u00e7as\n        for j in range(rows):\n            for i in range(cols - 3):\n                window = board[j][i:i+4]\n                agent_tiles = np.count_nonzero(window == AI_MOVE)\n                human_tiles = np.count_nonzero(window == HUMAN_MOVE)\n                score = __eval_window(agent_tiles, human_tiles, score)\n\n        return score\n\n\n    def __eval_ver(board, score=0):\n        \"\"\"\n        Avalia as pontua\u00e7\u00f5es do tabuleiro verticalmente\n        \"\"\"\n        # Pegando a linha\n        cols = board.shape[1]\n        rows = board.shape[0]\n        # Percorre todas as colunas e avalia janelas de 4 pe\u00e7as\n        for j in range(cols):\n            for i in range(rows - 3):\n                window = board[i:i+4, j]\n                agent_tiles = np.count_nonzero(window == AI_MOVE)\n                human_tiles = np.count_nonzero(window == HUMAN_MOVE)\n                score = __eval_window(agent_tiles, human_tiles, score)\n\n        return score\n\n    def __eval_main_diag(board, score=0):\n        \"\"\"\n        Avalia as pontua\u00e7\u00f5es do tabuleiro nas diagonais principais\n        \"\"\"\n        cols = board.shape[1]\n        rows = board.shape[0]\n        # Percorre todas as diagonais princiais e avalia janelas de 4 pe\u00e7as\n        for row in range(3, rows):\n            for col in range(0, cols-3):\n                window = [board[row-i][col+i] for i in range(4)]\n                agent_tiles = window.count(AI_MOVE)\n                human_tiles = window.count(HUMAN_MOVE)\n                score = __eval_window(agent_tiles, human_tiles, score)\n\n        return score\n\n    def __eval_sec_diag(board, score=0):\n        \"\"\"\n        Avalia as pontua\u00e7\u00f5es do tabuleiro nas diagonais secund\u00e1rias\n        \"\"\"\n        cols = board.shape[1]\n        #rows = board.shape[0]\n        # Percorre todas as diagonais secund\u00e1rias e avalia janelas de 4 pe\u00e7as\n        for row in range(0, 3):\n            for col in range(0, cols-3):\n                window = [board[row+i][col+i] for i in range(4)]\n                agent_tiles = window.count(AI_MOVE)\n                human_tiles = window.count(HUMAN_MOVE)\n                score = __eval_window(agent_tiles, human_tiles, score)\n\n        return score\n\n    # FEATURES DA FUN\u00c7\u00c3O DE AVALIA\u00c7\u00c3O:\n    # JANELAS HORIZONTAIS, VERTICAIS E DIAGONAIS\n    # CADA FEATURE RECEBE PESO 1\n    # EVAL(S) = W1*f1 + ... + Wn*fn\n    score = 0\n    score = __eval_hor(board, score) + __eval_ver(board, score) + __eval_main_diag(board, score) + __eval_sec_diag(board, score)\n    return score\n\ndef get_board(obs, cfg):\n    \"\"\"\n    Retorna uma matriz que representa o tabuleiro\n    \"\"\"\n    cols = cfg.columns\n    rows = cfg.rows\n    shape = (rows, cols)\n\n    board = np.array(obs.board).reshape(shape)\n\n    return board\n\ndef gen_board(board, move, MOVE_TYPE):\n    \"\"\"\n    Gera um tabuleiro futuro, levando em considera\u00e7\u00e3o a pr\u00f3xima jogada.\n    Recebe como entrada o estado atual do tabuleiro.\n\n    Retorna o estado do tabuleiro ap\u00f3s a jogada.\n    \"\"\"\n\n\n    # Checa qual \u00e9 a linha certa para inser\u00e7\u00e3o da jogada\n    new_board = board.copy()\n\n    line = new_board.shape[0] - 1\n    while new_board[line][move] != 0:\n        line = line - 1\n\n    new_board[line][move] = MOVE_TYPE\n\n    return new_board\n\ndef get_valid_moves(board):\n    \"\"\"\n    Retorna as jogadas v\u00e1lidas de acordo com o estado atual do tabuleiro\n    \"\"\"\n    valid_moves = [col for col in range(len(board[0])) if board[0][col] == 0]\n    return valid_moves\n\n\ndef minimax(board, depth, maximizer):\n    \"\"\"\n    Retorna a melhor jogada, de acordo com o algoritmo minimax\n    \"\"\"\n    if depth == 0 or terminal_node(board):\n        if not get_valid_moves(board): # Sem mais jogadas v\u00e1lidas = empate\n            return None, 0\n        return None, eval_board(board) # Chegamos em uma posi\u00e7\u00e3o vencedora. Nenhuma jogada deve ser retornada\n    elif maximizer == True: # Jogada da AI\n        value = -100000000\n        # Expans\u00e3o de todas as jogadas\n        valid_moves = get_valid_moves(board)\n        best_move = valid_moves[0]\n        for move in valid_moves:\n            resulting_board = gen_board(board, move,AI_MOVE) # Computa o tabuleiro para a pr\u00f3xima posi\u00e7\u00e3o, dado a jogada atual\n            new_value = minimax(resulting_board, depth - 1, False)[1] # Pega o valor do minimax\n            if new_value >= value:\n                value = new_value\n                best_move = move\n        return best_move, value\n    \n    else: # Jogada do humano\n        value =  100000000\n        valid_moves = get_valid_moves(board)\n        best_move = valid_moves[0]\n        for move in valid_moves:\n            resulting_board = gen_board(board,move, HUMAN_MOVE) # Computa o tabuleiro para a pr\u00f3xima posi\u00e7\u00e3o, dado a jogada atual\n            new_value = minimax(resulting_board, depth - 1, True)[1]   # Pega o valor do minimax\n            if new_value <= value:\n                value = new_value\n                best_move = move\n                \n        return best_move, value\n    \n\n\nimport time\ndef my_agent(obs, cfg):  # recebe o estado atual do jogo e a configura\u00e7\u00e3o do jogo, retorna uma jogada\n    # Gerando o tabuleiro inicial\n\n    board = get_board(obs, cfg)\n    minimax_start_time = time.time()\n    best_move, _ = minimax(board, 3, True)\n    minimax_end_time = time.time() - minimax_start_time\n    \n    \n    \n    return best_move","76bc54dd":"env.reset()\nenv.run([my_agent, \"rules\"]) #Agente definido em my_agent versus angente rand\u00f4mico.\nenv.render(mode=\"ipython\", width=500, height=450)","4d48f67e":"# Play as first position against random agent.\ntrainer = env.train([None, \"rules\"])\n\nobservation = trainer.reset()\n\nwhile not env.done:\n    my_action = my_agent(observation, env.configuration)\n    print(\"A\u00e7\u00e3o do seu agente: Coluna\", my_action+1)\n    observation, reward, done, info = trainer.step(my_action)\n    env.render(mode=\"ipython\", width=100, height=90, header=False, controls=False)\nenv.render()","4d7dbff1":"# \"None\" represents which agent you'll manually play as (first or second player).\nenv.play([my_agent, None], width=500, height=450) #Altere \"rules\" por my_agent para jogar contra o seu agente","b43c6673":"def mean_win_draw(rewards):\n    return sum( 1 for r in rewards if (r[0] == 1 or r[0] == 0.)) \/ len(rewards)\n\n# Run multiple episodes to estimate its performance.\nvs_random = mean_win_draw(evaluate(\"connectx\", [my_agent, \"random\"], num_episodes=10))\nprint(\"My Agent vs Random Agent:\", vs_random)\n\nvs_negamax = mean_win_draw(evaluate(\"connectx\", [my_agent, \"negamax\"], num_episodes=10))\nprint(\"My Agent vs Negamax Agent:\", vs_negamax)\n\nvs_rules = mean_win_draw(evaluate(\"connectx\", [my_agent, \"rules\"], num_episodes=10))\nprint(\"My Agent vs Rule Agent:\", vs_rules)\n\nvs_greedy = mean_win_draw(evaluate(\"connectx\", [my_agent, \"greedy\"], num_episodes=10))\nprint(\"My Agent vs Greedy Agent:\", vs_greedy)","fbd66f0b":"import csv\n\nseu_nome = \"Andre Igor\"\n\nrows = [['Id', 'Predicted'],['random',vs_random],[ 'negamax', vs_negamax],[ 'rules', vs_rules],[ 'greedy', vs_greedy]]\nf = open(seu_nome+'-ConnectX.csv', 'w')\nwith f:\n    writer = csv.writer(f)\n    for row in rows:\n        writer.writerow(row)","0316868d":"# Testar o seu Agente\n\nEste trecho simula o comportamento do agente contra um agente rand\u00f4mico.","03d23970":"# Avalie o seu Agente\n\nA submiss\u00e3o na competi\u00e7\u00e3o do kaggle ser\u00e1 o resultado do seu agente contra 4 agentes previamente definidos.\nPode utilizar ","38c9a0df":"# Debug\/Train o seu Agent.\n\nAqui \u00e9 poss\u00edvel ver como o seu agente funciona a cada etapa.","959ec1ac":"# Notebook template para a competi\u00e7\u00e3o Connect X do Virtus-UP.\n\nNessa competi\u00e7\u00e3o vamos criar agentes inteligentes para o jogo connect X. Vamos utilizar o mesmo ambiente utilizado na competi\u00e7\u00e3o https:\/\/www.kaggle.com\/c\/connectx\/, essa competi\u00e7\u00e3o ainda est\u00e1 em andamento.\n\nPara a nossa competi\u00e7\u00e3o n\u00e3o vamos permitir apenas t\u00e9cnicas da IA cl\u00e1ssica.\n\nLeia com aten\u00e7\u00e3o os textos. Qualquer d\u00favida crie uma discurs\u00e3o na p\u00e1gina da competi\u00e7\u00e3o ou mande mensagem para os monitores.","aca789e9":"1. Em Data\/output voc\u00ea pode baixar o .csv com o seu resultado atual. Isso est\u00e1 acess\u00edvel no painel lateral ou ap\u00f3s realizar um commit no kernel. \n2. Submeta o csv na p\u00e1gina da competi\u00e7\u00e3o.\n\nNo fim da competi\u00e7\u00e3o os monitores v\u00e3o fazer um campeonato com todos os agentes.","ff96699c":"# Jogue voc\u00ea mesmo\nClick on any column to place a checker there (\"manually select action\").\n\nVoc\u00ea pode jogar contra o seu agente ou contra qualquer um dos 4 agentes j\u00e1 definidos (random, negamax, rules, greedy).","f4f4dec7":"# Agente Inteligente utilizando Minimax\n\n","200b4919":"# Submiss\u00e3o para O Connect-X Virtus Up","3ca0e339":"# Setup do Notebook\n\n## IMPORTATE: Habilite a internet no painel lateral. Settings\/Internet\/On"}}