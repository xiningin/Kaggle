{"cell_type":{"78164a60":"code","28cc52bd":"code","74ca97f0":"code","9995416a":"code","41623a27":"code","b07e2da9":"code","078e74ad":"code","4680fb0c":"code","1cd5a846":"code","b0022577":"code","98d23f2e":"markdown","f7e2dc2a":"markdown"},"source":{"78164a60":"import pandas as pd\nimport numpy as np","28cc52bd":"# Import CSV\nbook = pd.read_csv(\"..\/input\/books.csv\")\nbook_tags = pd.read_csv(\"..\/input\/book_tags.csv\")\nratings = pd.read_csv(\"..\/input\/ratings.csv\")\ntags = pd.read_csv(\"..\/input\/tags.csv\")\nto_read = pd.read_csv(\"..\/input\/to_read.csv\")","74ca97f0":"print(book.head(5))\nprint(tags.head(5))\nprint(ratings.head(5))\nprint(book_tags.head(5))\nprint(to_read.head(5))","9995416a":"#Ratings matrix to be one row per user and one column per movie.\nprint(\"Total Books: \", book.shape[0])\n## Total User only considering user who rated atleast one movie\nprint(\"Total User: \", len(ratings['user_id'].unique()))","41623a27":"## Using Explicit feedback data only\nbooks = book[['book_id', 'authors', 'original_title', 'average_rating']].copy()\nbooks_df = ratings.reset_index().pivot_table(index = 'user_id', columns = 'book_id', values = 'rating').fillna(0)\nprint(books_df.head(), books_df.shape)","b07e2da9":"# Normalize by each users mean and convert it from a dataframe to a numpy array\nR = books_df.as_matrix()\nuser_ratings_mean = np.mean(R, axis = 1)\nR_demeaned = R - user_ratings_mean.reshape(-1, 1)\n","078e74ad":"from scipy.sparse.linalg import svds\nU, sigma, Vt = svds(R_demeaned, k = 50)\ndel(R_demeaned)\nsigma = np.diag(sigma)\nprint(sigma)","4680fb0c":"# add the user means back to get the predicted 5-star ratings\nall_user_predicted_ratings = np.dot(np.dot(U, sigma), Vt) + user_ratings_mean.reshape(-1, 1)\nprint(all_user_predicted_ratings)\n# Making Recommendation\npreds_df = pd.DataFrame(all_user_predicted_ratings, columns = books_df.columns)\nprint(preds_df.head(5))","1cd5a846":"def recommend_books(predictions_df, userID, books_df, original_ratings_df, num_recommendations=5):\n    \n    # Get and sort the user's predictions\n    user_row_number = userID - 1 # UserID starts at 1, not 0\n    sorted_user_predictions = predictions_df.iloc[user_row_number].sort_values(ascending=False)\n    \n    # Get the user's data and merge in the movie information.\n    user_data = original_ratings_df[original_ratings_df.user_id == (userID)]\n    user_full = (user_data.merge(books_df, how = 'left', left_on = 'book_id', right_on = 'book_id').\n                     sort_values(['rating'], ascending=False)\n                 )\n\n#     print 'User {0} has already rated {1} books.', %(.format(userID, user_full.shape[0]))\n#     print 'Recommending the highest {0} predicted ratings movies not already rated.'.format(num_recommendations)\n    \n    # Recommend the highest predicted rating books that the user hasn't read yet.\n    recommendations = (books_df[~books_df['book_id'].isin(user_full['book_id'])].\n         merge(pd.DataFrame(sorted_user_predictions).reset_index(), how = 'left',\n               left_on = 'book_id',\n               right_on = 'book_id').\n         rename(columns = {user_row_number: 'Predictions'}).\n         sort_values('Predictions', ascending = False).\n                       iloc[:num_recommendations, :-1]\n                      )\n\n    return(user_full, recommendations)","b0022577":"# Now we can recommend books to any user id (ex : user_id : 121)\nalready_rated, predictions = recommend_books(preds_df, 121, books, ratings, 10)\nprint(predictions, already_rated.shape)","98d23f2e":"\n## Matrix Factorization via Singular Value Decomposition\nMatrix factorization is the breaking down of one matrix in a product of multiple matrices. It's extremely well studied in mathematics, and it's highly useful. There are many different ways to factor matrices, but singular value decomposition is particularly useful for making recommendations.\n\nSo what is singular value decomposition (SVD)? At a high level, SVD is an algorithm that decomposes a matrix $R$ into the best lower rank (i.e. smaller\/simpler) approximation of the original matrix $R$. Mathematically, it decomposes R into a two unitary matrices and a diagonal matrix:\n\n$$\\begin{equation}\nR = U\\Sigma V^{T}\n\\end{equation}$$\nwhere R is users's ratings matrix, $U$ is the user \"features\" matrix, $\\Sigma$ is the diagonal matrix of singular values (essentially weights), and $V^{T}$ is the books \"features\" matrix. $U$ and $V^{T}$ are orthogonal, and represent different things. $U$ represents how much users \"like\" each feature and $V^{T}$ represents how relevant each feature is to each books.\n\nTo get the lower rank approximation, we take these matrices and keep only the top $k$ features, which we think of as the underlying tastes and preferences vectors.","f7e2dc2a":"## Using Explicit feedback i.e. Rating Data"}}