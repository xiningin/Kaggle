{"cell_type":{"6d657565":"code","382a5b66":"code","278bdfc8":"code","94b98c98":"code","8c57ffa2":"code","fc293a58":"code","beb686ef":"code","0817afbb":"code","9f5b06b1":"code","b4e895ff":"code","60ddf884":"code","00feb373":"code","9170765a":"markdown","7c2749c9":"markdown","11214c4e":"markdown","825b5fea":"markdown","fc90ab1a":"markdown","4b7cc98d":"markdown","42ce43fd":"markdown","90f1ced8":"markdown"},"source":{"6d657565":"import warnings\nwarnings.filterwarnings('ignore')","382a5b66":"# \u3044\u3064\u3082\u306e\u304a\u307e\u3058\u306a\u3044\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# \u30c7\u30fc\u30bf\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u307e\u3059\n#players = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/players.csv')\n#pffs = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/PFFScoutingData.csv')\ntrack18 = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2018.csv')\n#track19 = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2019.csv')\n#track20 = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/tracking2020.csv')\ngames = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/games.csv')\nplays = pd.read_csv('..\/input\/nfl-big-data-bowl-2022\/plays.csv')","278bdfc8":"# Copied from https:\/\/www.kaggle.com\/werooring\/nfl-big-data-bowl-basic-eda-for-beginner\n\ndef downcast(df, verbose=True):\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    for col in df.columns:\n        dtype_name = df[col].dtype.name\n        if dtype_name == 'object':\n            pass\n        elif dtype_name == 'bool':\n            df[col] = df[col].astype('int8')\n        elif dtype_name.startswith('int') or (df[col].round() == df[col]).all():\n            df[col] = pd.to_numeric(df[col], downcast='integer')\n        else:\n            df[col] = pd.to_numeric(df[col], downcast='float')\n    end_mem = df.memory_usage().sum() \/ 1024**2\n#    if verbose:\n#        print('{:.1f}% Compressed'.format(100 * (start_mem - end_mem) \/ start_mem))\n    \n    return df\n\n\n# \u4e0d\u8981\u306a\u5217\u306e\u524a\u9664\ngames = games.drop(['season', 'week', 'gameDate', 'gameTimeEastern','visitorTeamAbbr'], axis=1)\ngames = downcast(games)\n\nplays = plays.drop(['playDescription', 'quarter', 'down', 'yardsToGo', \n                    'kickerId', 'kickBlockerId', 'yardlineSide', 'yardlineNumber', \n                    'gameClock', 'penaltyCodes', 'penaltyJerseyNumbers', 'penaltyYards', \n                    'preSnapHomeScore', 'preSnapVisitorScore', 'passResult', \n                    'kickLength', 'playResult', 'absoluteYardlineNumber'], axis=1)\nplays = downcast(plays)\n\ndf_list = []\nfor df_temp in [track18]:#, track19, track20]:\n    df_temp = df_temp.drop(['time','dis','o','jerseyNumber','position'], axis=1)\n    df_temp = downcast(df_temp)\n    df_list.append(df_temp)\ntrack_data = pd.concat(df_list, axis=0).reset_index(drop=True)\n\n# \u30e1\u30e2\u30ea\u306e\u7bc0\u7d04\u7528\ndel track18#, track19, track20","94b98c98":"# Return \u8ddd\u96e2\u306e\u983b\u5ea6\u3092\u8abf\u3079\u308b\nreturn_plays = plays[(plays['specialTeamsResult']== 'Return')]\n\n# game \u30c7\u30fc\u30bf\u304b\u3089 home \u306e\u30c1\u30fc\u30e0\u306e\u60c5\u5831\u3092\u8ffd\u52a0\nreturn_plays = pd.merge(return_plays, games, on=['gameId'], how='inner')\n\n# returner \u306e id \u3092\u8aac\u660e\u5909\u6570\u306b\u52a0\u3048\u308b\nreturn_plays = return_plays.dropna(subset=['returnerId'])\nreturn_plays['returnerId'] = return_plays['returnerId'].str[:5]\nreturn_plays['returnerId'] = return_plays['returnerId'].astype(int)\n\n\n###\n# \u8ffd\u8de1\u30c7\u30fc\u30bf\u3092 return \u304c\u8d77\u304d\u305f\u5834\u5408\u306e\u307f\u306b\u5236\u9650\ntrack_data = pd.merge(track_data, return_plays, on=['gameId','playId'], how='inner')\n\n# \u30b3\u30fc\u30c8\u306e\u5165\u308c\u66ff\u3048\u3068\u304b\u3042\u308b\u3063\u307d\u3044\u306e\u3067\u653b\u6483\u65b9\u5411(playDirection)\u306b\u5fdc\u3058\u3066\u5ea7\u6a19\u3092\u4fee\u6b63\ntrack_data['x'] = (120-track_data['x']) - (120-track_data['x']*2) * (track_data['playDirection'] == 'right')\ntrack_data['y'] = (53.3-track_data['y']) - (53.3-track_data['y']*2) * (track_data['playDirection'] == 'right')\ntrack_data['dir'] = np.mod(track_data['dir'] + 180 * (track_data['playDirection'] == 'left'), 360)\n\n# \u5ea7\u6a19\u30c7\u30fc\u30bf\u306e team \u3092 home \/ away \u304b\u3089 offense \/ diffense \u306b\u5909\u63db\nhomeplayer = (track_data['team'] == 'home')                                         # 'football'\u306f'away'\u306e\u3082\u306e\nhometeam   = (track_data['possessionTeam'] == track_data['homeTeamAbbr'])\ntrack_data['team'] = (homeplayer == hometeam).replace({True:'offense', False:'diffense'})\n\n\n###\n# \u3055\u3089\u306breceive \u3055\u308c\u3066\u304b\u3089tackle\u3059\u308b\u307e\u3067\u306e\u9593\u306b\u5236\u9650\nreceive = track_data[(track_data['displayName']=='football')&((track_data['event']=='punt_received') | (track_data['event']=='kick_received'))]\nreceive = receive[['gameId', 'playId','frameId']]\nreceive = receive.rename(columns={'frameId': 'frame_start'})\n\ntackle = track_data[(track_data['displayName']=='football')&(track_data['event']=='tackle')]\ntackle = tackle[['frameId','gameId', 'playId','x', 'returnerId']]\ntackle = tackle.rename(columns={'frameId': 'frame_end', 'x': 'x_end'})\n\nreturn_frame = pd.merge(receive, tackle, on=['gameId', 'playId'], how='inner')\n#return_frame.head()\n\n\n###\n# \u3044\u3089\u306a\u3044\u5909\u6570\u306e\u304a\u6383\u9664\ndel games, plays, receive, tackle\n\ntrack_data = track_data[track_data['displayName'] != 'football']\ntrack_data = track_data[['x', 'y', 's', 'a', 'dir', 'nflId', 'team', 'frameId', 'gameId', 'playId']]\n#track_data.head()","8c57ffa2":"# \u7279\u5fb4\u91cf\u3068\u3057\u3066\u3001\u30dc\u30fc\u30eb\u304b\u3089\u4e00\u5b9a\u8ddd\u96e2\u306e\u5473\u65b9\u30fb\u76f8\u624b\u9078\u624b\u306e\u4eba\u6570\u3092\u7528\u3044\u308b\ndef ball_neighbour(df_track, dist):\n    offense_temp = df_track[(df_track['distance'] < dist)&(df_track['team']=='offense')]\n    diffense_temp = df_track[(df_track['distance'] < dist)&(df_track['team']=='diffense')]\n    return [offense_temp.shape[0], diffense_temp.shape[0]]\n\ndef pos_neighbour(df_track, dist):\n    offense_temp = df_track[(df_track['distance'] < dist)&(df_track['distance_x'] >= 0)&(df_track['team']=='offense')]\n    diffense_temp = df_track[(df_track['distance'] < dist)&(df_track['distance_x'] >= 0)&(df_track['team']=='diffense')]\n    return [offense_temp.shape[0], diffense_temp.shape[0]]\n\n# \u9078\u624b\u306e\u4f4d\u7f6e\u30c7\u30fc\u30bf\u304b\u3089\u7279\u5fb4\u91cf\u3092\u4f5c\u6210\nresult_list = []\nfor i_index in return_frame.index:\n    game_id = return_frame.loc[i_index,'gameId']\n    play_id = return_frame.loc[i_index,'playId']\n    frame_start = return_frame.loc[i_index,'frame_start']\n    frame_end = return_frame.loc[i_index,'frame_end']\n    x_end = return_frame.loc[i_index,'x_end']\n    returner = return_frame.loc[i_index, 'returnerId']\n\n    # \u4e2d\u9593\u306e\u30d5\u30ec\u30fc\u30e0\u3092\u3059\u3079\u3066\u30c7\u30fc\u30bf\u3068\u3057\u3066\u7528\u3044\u308b\n    for frame_index in range(frame_start, frame_end, 3):\n        df_temp = track_data[(track_data['gameId']==game_id)&(track_data['playId']==play_id)&(track_data['frameId']==frame_index)].copy()\n        df_temp1 = df_temp[df_temp['team']=='offense'].copy()\n        df_temp2 = df_temp[(df_temp['team']=='diffense')&(df_temp['nflId']!=returner)].copy()\n\n        returner_loc = df_temp[df_temp['nflId']==returner][['x','y','s','a','dir']].values[0]\n        df_temp['distance'] = ((df_temp['x'] - returner_loc[0]) ** 2 + (df_temp['y'] - returner_loc[1]) ** 2) ** 0.5\n        df_temp['distance_x'] = -(df_temp['x'] - returner_loc[0])     # returner \u3088\u308a\u524d\u306b\u4eba\u304c\u3044\u308b\u306a\u3089\u6b63\u5024\n\n        df_temp1['distance'] = 999999\n        for diffense_index in df_temp2.index:\n            diffense_loc = df_temp.loc[diffense_index,['x','y']].values\n            df_temp1['distance'] = np.minimum(df_temp1['distance'], ((df_temp1['x'] - diffense_loc[0]) ** 2 + (df_temp2['y'] - diffense_loc[1]) ** 2) ** 0.5)\n        df_temp1 = df_temp1[df_temp1['distance'] > 0.5]\n        df_temp1['distance'] = ((df_temp1['x'] - returner_loc[0]) ** 2 + (df_temp1['y'] - returner_loc[1]) ** 2) ** 0.5\n\n        feature_item = [i_index, game_id, play_id, frame_index] + returner_loc.tolist()\n        feature_item += ball_neighbour(df_temp, 7) + ball_neighbour(df_temp, 5) + ball_neighbour(df_temp, 3) + ball_neighbour(df_temp, 1) + ball_neighbour(df_temp, 0.5)\n        feature_item += pos_neighbour(df_temp, 7) + pos_neighbour(df_temp, 5) + pos_neighbour(df_temp, 3) + pos_neighbour(df_temp, 1) + pos_neighbour(df_temp, 0.5)\n        feature_item += [ball_neighbour(df_temp1, 7)[0]] + [ball_neighbour(df_temp1, 3)[0]] + [ball_neighbour(df_temp1, 1)[0]]\n        feature_item += [-(x_end-returner_loc[0])]\n        \n        result_list.append(feature_item)\n\ndf_train = pd.DataFrame(result_list, columns=['gameplayId','gameId','playId','frameId', \n                                              'returner_x','returner_y','returner_s','returner_a','returner_dir', \n                                              'offense7','diffense7','offense5','diffense5','offense3','diffense3','offense1','diffense1','offense.5','diffense.5',\n                                              'offense+7','diffense+7','offense+5','diffense+5','offense+3','diffense+3','offense+1','diffense+1','offense+.5','diffense+.5',\n                                              'free-offense7','free-offense3','free-offense1','return_yard'])","fc293a58":"df_train.to_csv('intermediate_file.csv')\n#df_train = pd.read_csv('..\/input\/nfl2022-app\/intermediate_file.csv', index_col=0)","beb686ef":"# \u6a5f\u68b0\u5b66\u7fd2\u3067\u4f7f\u3046\u7528\u306e\u30c7\u30fc\u30bf\ndf_list = []\nfor i_index in return_frame.index:\n    df_temp = df_train[df_train['gameplayId']==i_index]\n    df_temp = df_temp.rolling(5, min_periods=1).sum() \/ 5    # \u524d\u306e 5 \u30d5\u30ec\u30fc\u30e0\u9593\u306e\u30c7\u30fc\u30bf\u306e\u5e73\u5747\n    df_list.append(df_temp)\n\ndf_train_mean = pd.concat(df_list, axis=0)\ndf_train_mean = df_train_mean.drop(['gameplayId','gameId','playId','frameId','returner_s','returner_a','returner_dir','return_yard'], axis=1)\ndf_train_mean = df_train_mean.add_suffix('_mean')\n\ndf_train = pd.concat([df_train, df_train_mean], axis=1)\ndf_train = df_train.astype(float)","0817afbb":"# \u8a13\u7df4\u30c7\u30fc\u30bf\u3001\u691c\u8a3c\u30c7\u30fc\u30bf\u306e\u5206\u5272\nfrom sklearn.model_selection import train_test_split\n\ny_train = (df_train['return_yard'] <= 5) * 1\nX_train = df_train.drop(['gameplayId','gameId','playId','frameId','return_yard'], axis=1)\n\nmean_x = X_train.mean()\nstd_x = X_train.std()\n#X_train = (X_train - mean_x) \/ std_x\n\n# \u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\u3001\u691c\u8a3c\u30c7\u30fc\u30bf\u306e\u3068\u308a\u308f\u3051\nX_test = X_train[df_train['gameId'] >= 2018120000]\ny_test = y_train[df_train['gameId'] >= 2018120000]\nX_train = X_train[df_train['gameId'] < 2018120000]\ny_train = y_train[df_train['gameId'] < 2018120000]\n\n# \u5b66\u7fd2\u958b\u59cb\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, f1_score\nfrom sklearn.metrics import precision_score, recall_score\n\nlr5 = LogisticRegression(solver='liblinear', penalty='l1')\nlr5.fit(X_train, y_train)\ny_train_pred = lr5.predict(X_train)\ny_test_pred = lr5.predict(X_test)\nprint('F-score(train data): ', f1_score(y_train.values, y_train_pred))\nprint('F-score(test data): ', f1_score(y_test.values, y_test_pred))","9f5b06b1":"# Calibration curves \u306e\u4f5c\u56f3\nfrom sklearn.calibration import calibration_curve\n\nprob = lr5.predict_proba(X_test)[:, 1] # \u76ee\u7684\u5909\u6570\u304c1\u3067\u3042\u308b\u78ba\u7387\u3092\u4e88\u6e2c\nprob_true, prob_pred = calibration_curve(y_true=y_test, y_prob=prob, n_bins=20)\n\nfig, ax1 = plt.subplots()\nax1.plot(prob_pred, prob_true, marker='s', label='calibration plot', color='skyblue') # \u30ad\u30e3\u30ea\u30d7\u30ec\u30fc\u30b7\u30e7\u30f3\u30d7\u30ed\u30c3\u30c8\u3092\u4f5c\u6210\nax1.plot([0, 1], [0, 1], linestyle='--', label='ideal', color='limegreen') # 45\u5ea6\u7dda\u3092\u30d7\u30ed\u30c3\u30c8\nax1.legend(bbox_to_anchor=(1.12, 1), loc='upper left')\nax1.set_xlabel(\"Mean Predicted Probability\")\nax1.set_ylabel(\"Fraction of positives\")\n#ax2 = ax1.twinx() # 2\u8ef8\u3092\u8ffd\u52a0\n#ax2.hist(prob, bins=20, histtype='step', color='orangered') # \u30b9\u30b3\u30a2\u306e\u30d2\u30b9\u30c8\u30b0\u30e9\u30e0\u3082\u4f75\u305b\u3066\u30d7\u30ed\u30c3\u30c8\n#ax2.set_ylabel(\"Counts\")\nplt.show()","b4e895ff":"# \u30ea\u30bf\u30fc\u30f3\u306e\u963b\u6b62\u306e\u5b9a\u7fa9\u3092\u3059\u3053\u3057\u305a\u3064\u5909\u3048\u3066\u8a08\u7b97\nyard_list = np.arange(0.5, 15, 0.5)\nmodel_list = []\n\nfor yard_index in yard_list:\n    y_train = (df_train['return_yard'] <= yard_index) * 1\n\n    # \u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\u3001\u691c\u8a3c\u30c7\u30fc\u30bf\u306e\u3068\u308a\u308f\u3051\n    y_test = y_train[df_train['gameId'] >= 2018120000]\n    y_train = y_train[df_train['gameId'] < 2018120000]\n\n    # \u5b66\u7fd2\u958b\u59cb\n    lr = LogisticRegression(solver='liblinear', penalty='l1')\n    lr.fit(X_train, y_train)\n    y_train_pred = lr.predict(X_train)\n    y_test_pred = lr.predict(X_test)\n    model_list.append(lr)","60ddf884":"X_sample = X_test.iloc[240:241,:]\nprob_list = []\nfor lr in model_list:\n    prob = lr.predict_proba(X_sample)[:, 1] # \u76ee\u7684\u5909\u6570\u304c1\u3067\u3042\u308b\u78ba\u7387\u3092\u4e88\u6e2c\n    prob_list.append(prob[0])\nplt.scatter(yard_list, prob_list)\nplt.plot(yard_list, prob_list)\nplt.ylim(0,1)\nplt.show()","00feb373":"X_sample = df_train.iloc[240,:]\ngameId = X_sample['gameId']\nplayId = X_sample['playId']\nframeId = X_sample['frameId']\n\ndf_temp = track_data[(track_data['gameId']==gameId)&(track_data['playId']==playId)&(track_data['frameId']==frameId)]\ndf_temp1 = df_temp[df_temp['team']=='offense']\ndf_temp2 = df_temp[df_temp['team']=='diffense']\n\nplt.scatter(df_temp1['x'], df_temp1['y'], alpha=0.9)\nplt.scatter(df_temp2['x'], df_temp2['y'], alpha=0.9)\nplt.ylim(0,53.3)\nplt.show()","9170765a":"Similarly, calculate the probability for each distance of how far the returner can go before being stopped.","7c2749c9":"# 3. Add New Feature\nFrom the original dataset,\n\nThe following variables will be adopted as features.\n\n* ball_neighbour(df_track, dist) : number of enemies and allies within (dist) yards around the returner when the player placement follows (df_track)\n* pos_neighbour(df_track, dist) : number of enemies and allies within (dist) yards **in front of** the returner when the player placement follows (df_track)\n\nIn addition, the average of the number of people in the last five frames is also added as an explanatory variable.","11214c4e":"# 1. Load the Libraries and Datasets\nWe use the following datasets and the parameters.  \nTo compress data size, downcast function which copied from this page $\\downarrow$ is applied. <br>\nhttps:\/\/www.kaggle.com\/werooring\/nfl-big-data-bowl-basic-eda-for-beginner\n\n* **games.csv** : gameId, homeTeamAbbr\n\n* **plays.csv** : gameId, playId, possessionTeam, specialTeamsPlayType, specialTeamsResult, returnerId, kickReturnYardage\n\n* **tracking20\\*\\*.csv** : x, y, s, dir, event, nflId, displayName, team, frameId, gameId, playId, playDirection","825b5fea":"# 4. Predict Success Rate of the Tackle\nFrom the data above, we will predict the success rate of return rejection.  \nFor easy understanding, to block a return is defined as the returner not advancing more than 5 yards in the x-axis direction from the moment.\n* 1 : Returner will stop in 5 yards.\n* 0 : Returner will advance at least 5 yards.\n\nLogistic regression is used for prediction.  \nThe data from October and November 2018 will be used as the teacher data and Descember 2018 will be used as the test data.","fc90ab1a":"# Goal\nThis notebook analyzes data on kickoff and punt plays.  \n\nA player in opposing team who receives the ball on a punt or a kickoff play runs in order to return the ball, while the kickoff team run up to the returner and tackle to prevent them from returning.\n\nFor better strategy, it is useful to predict the return distance of a punt from the player tracking data.\nHowever, it is not possible to predict the exact return distance from temporal position data.\nThe return distance increases significantly when the returner slips through the tackle, but this does not always happen.\n\nIn this note, we will obtain the probability distribution of the distance the returner travels from the current position, instead of predicting the return distance and considers the success rate of the tackle and the position of all players.","4b7cc98d":"This model gives us not only a prediction of blocking success \/ failure, but also the success rate.   \nThe calibration curve below shows the relationship between the predicted probability (x axis) and actual success rate in each bins.","42ce43fd":"# 2. Data Preparation\nLooking at parameter \"event\" in tracking data, the flow of the game should be in the following order in a normal punt play.\n\n* ball_snap\n* punt\n* punt_received\n* first_contact\n* tackle\n  \nWe will examine return yardage from punt_recieved (or kick_received in kickoff play) to tackle.\n\n\n### Modifying \"plays.csv\" data (+ \"games.csv\")\n1. Limit plays.csv data to only when a return occurs.\n1. Add home team information (\"homeTeamAbbr\") from games.csv data.\n1. Add returner's id (\"returnerId\") as an explanatory variable.\n\n### Modifying \"tracking20\\*\\*.csv\" data\n\n1. Restrict tracking data to only when a return occurs.\n1. Modify the coordinates according to the \"playDirection\".\n1. Convert the coordinate data team from (home \/ away) to (offense \/ diffense).\n1. Restrict to the time between receive and tackle.","90f1ced8":"### Output Example\nAs an example, we will predict the distance the returner will advance in a given frame.\nThe horizontal axis represents the distance the returner being stopped and the vertical axis represents the corresponding probability.\nThe figure below shows the player's position. The blue dots represent the attackers, and the orange dots represent the defenders."}}