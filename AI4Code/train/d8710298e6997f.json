{"cell_type":{"8b6cfd9b":"code","412f4fbb":"code","215a756a":"code","1a44abb2":"code","5b5cd75e":"code","d7d36291":"code","2a8ae73c":"code","5c1bf034":"code","f1cea9fc":"code","b3ff4d5b":"code","69ae272c":"code","0b524ed2":"code","c949911d":"code","3d330309":"code","0dc2eac4":"code","53935475":"markdown","15a09240":"markdown","3daa9e97":"markdown","5c888c41":"markdown","153e6b99":"markdown","b6979afe":"markdown","4cdf9f2b":"markdown","755cbf10":"markdown","fbbf2815":"markdown","9951f9c8":"markdown","561a5fcd":"markdown","05b7abb2":"markdown","e965a61a":"markdown","99387865":"markdown","aec9926c":"markdown"},"source":{"8b6cfd9b":"from PIL import Image \nImage.open(\"..\/input\/cltv-value\/cltv.jpg\")","412f4fbb":"# installlation required\n!pip install Lifetimes\n!pip install openpyxl\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing\nimport datetime as dt\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sqlalchemy import create_engine\nimport datetime as dt\nimport matplotlib.pyplot as plt\nfrom lifetimes import BetaGeoFitter\nfrom lifetimes import GammaGammaFitter\nfrom lifetimes.plotting import plot_period_transactions\nimport seaborn as sns\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n        \n        \n# Making the appearance settings of the printouts\n\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\npd.set_option('display.float_format', lambda x: '%.3f' % x)        ","215a756a":"# Load data into pandas dataframe..\n\ndf = pd.read_excel(\"\/kaggle\/input\/online\/online_retail.xlsx\", sheet_name=\"Year 2010-2011\")\ndf.head()","1a44abb2":"def outlier_thresholds(dataframe, variable):\n    \"\"\"\n    It allows us to catch outliers.\n    It determines the upper and lower limits over the quarterly values.\n    \n    Parameters\n    ------\n    dataframe: dataframe\n                The dataframe from which variable names are to be retrieved\n    variable: variable\n                The variable from which has outlier value\n                    \n    Returns\n    ------\n    low limit: low limit\n                It subtracts 1.5 times the interquartile range from quantile(0.01)\n    \n    up_limit:  up limit: \n                It adds up 1.5 times the interquartile value from quantile(0.99)\n                \n    Notes\n    ------\n    It alone is not enough to get rid of outliers. It works with replace_with_thresholds.\n    \n    \"\"\"\n    quartile1 = dataframe[variable].quantile(0.01)\n    quartile3 = dataframe[variable].quantile(0.99)\n    interquantile_range = quartile3 - quartile1\n    up_limit = quartile3 + 1.5 * interquantile_range\n    low_limit = quartile1 - 1.5 * interquantile_range\n    return low_limit, up_limit\n\ndef replace_with_thresholds(dataframe, variable):\n    \"\"\"\n    Replaces captured outliers according to the defined upper and lower limit\n    \n    Parameters\n    ------\n    dataframe: dataframe\n                The dataframe from which variable names are to be retrieved\n    variable: variable\n                The variable from which has outlier value\n                    \n    Returns\n    ------\n    None\n                \n    Notes\n    ------\n    It alone is not enough to get rid of outliers. It works with outlier_thresholds.\n    \n    \"\"\"\n    low_limit, up_limit = outlier_thresholds(dataframe, variable)\n    # dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit\n    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit\n    \n    \ndef data_prep(dataframe):\n    dataframe.dropna(axis=0, inplace=True)\n    dataframe = dataframe[~dataframe[\"Invoice\"].str.startswith(\"C\", na=False)]\n    dataframe = dataframe[dataframe[\"Quantity\"] > 0]\n    replace_with_thresholds(dataframe, \"Quantity\")\n    replace_with_thresholds(dataframe, \"Price\")\n    dataframe[\"TotalPrice\"] = dataframe[\"Quantity\"] * dataframe[\"Price\"]\n    return dataframe\n\ndf = data_prep(df)\ndf.head()","5b5cd75e":"# recency: difference between first and last purchase. Weekly (for every single user)\n# T: the age of the client in the company. Weekly (for every single user)\n# frequency: total number of repeat purchases. Weekly (frequency>1)(for every single user)\n# monetary_value: average earnings per purchase.Weekly (for every single user)\n\n# The date on which the analysis should be performed.\ndf[\"InvoiceDate\"].max() \ntoday_date = dt.datetime(2011, 12, 11)\n\ncltv_df = df.groupby('Customer ID').agg({'InvoiceDate': [lambda date: (date.max() - date.min()).days,\n                                                         lambda date: (today_date - date.min()).days],\n                                         'Invoice': lambda num: num.nunique(),\n                                         'TotalPrice': lambda TotalPrice: TotalPrice.sum()})\n\ncltv_df.head()   # index problem\ncltv_df.columns = cltv_df.columns.droplevel(1)  # fixing index problem\n\n# Defining columns names\ncltv_df.columns = ['recency', 'T', 'frequency', 'monetary']\ncltv_df.head()","d7d36291":"# Average Order Value (average_order_value = total_price \/ total_transaction)\ncltv_df[\"monetary\"] = cltv_df[\"monetary\"] \/ cltv_df[\"frequency\"]\n# cltv_df = cltv_df[cltv_df[\"monetary\"] > 0]\n\n# it should be more than one purchase\ncltv_df = cltv_df[(cltv_df['frequency'] > 1)]\n\n# we need weekly value for each customer\ncltv_df[\"recency\"] = cltv_df[\"recency\"] \/ 7\n\n# we need weekly value for each customer\ncltv_df[\"T\"] = cltv_df[\"T\"] \/ 7\n\n# cltv_df[\"frequency\"] = cltv_df[\"frequency\"].astype(int) if there is a type problem\n\ncltv_df.head()","2a8ae73c":"ax = sns.distplot(cltv_df['monetary'])","5c1bf034":"bgf = BetaGeoFitter(penalizer_coef=0.001)\n\nbgf.fit(cltv_df['frequency'],\n        cltv_df['recency'],\n        cltv_df['T'])","f1cea9fc":"bgf.conditional_expected_number_of_purchases_up_to_time(1,\n                                                        cltv_df['frequency'],\n                                                        cltv_df['recency'],\n                                                        cltv_df['T']).sort_values(ascending=False).head(10)\n\n\ncltv_df[\"expected_purc_1_week\"] = bgf.predict(1,\n                                              cltv_df['frequency'],\n                                              cltv_df['recency'],\n                                              cltv_df['T'])\n","b3ff4d5b":"bgf.predict(4,\n            cltv_df['frequency'],\n            cltv_df['recency'],\n            cltv_df['T']).sort_values(ascending=False).head(10)\n\n\ncltv_df[\"expected_purc_1_month\"] = bgf.predict(4,\n                                               cltv_df['frequency'],\n                                               cltv_df['recency'],\n                                               cltv_df['T'])\n\n\ncltv_df.sort_values(\"expected_purc_1_month\", ascending=False).head(10)","69ae272c":"ggf = GammaGammaFitter(penalizer_coef=0.01)\nggf.fit(cltv_df['frequency'], cltv_df['monetary'])\n\n\n# top 10 most profitable customers\nggf.conditional_expected_average_profit(cltv_df['frequency'],\n                                        cltv_df['monetary']).sort_values(ascending=False).head(10)\n\n\ncltv_df[\"expected_average_profit\"] = ggf.conditional_expected_average_profit(cltv_df['frequency'],\n                                                                             cltv_df['monetary'])\n\ncltv_df.sort_values(\"expected_average_profit\", ascending=False).head(10)","0b524ed2":"cltv = ggf.customer_lifetime_value(bgf,\n                                   cltv_df['frequency'],\n                                   cltv_df['recency'],\n                                   cltv_df['T'],\n                                   cltv_df['monetary'],\n                                   time=6,   # 6 month\n                                   freq=\"W\", # Weekly\n                                   discount_rate=0.01)\n\ncltv.head()\ncltv = cltv.reset_index()\ncltv.sort_values(by= \"clv\", ascending=False).head()\n\n# 50 most valuable customers in a 6-month\ncltv.sort_values(by=\"clv\", ascending=False).head(20)","c949911d":"a =ggf.customer_lifetime_value(bgf,\n                                   cltv_df['frequency'],\n                                   cltv_df['recency'],\n                                   cltv_df['T'],\n                                   cltv_df['monetary'],\n                                   time=1,  # 1 month\n                                   freq=\"W\",  # Weekly\n                                   discount_rate=0.01)\n\nb =ggf.customer_lifetime_value(bgf,\n                                   cltv_df['frequency'],\n                                   cltv_df['recency'],\n                                   cltv_df['T'],\n                                   cltv_df['monetary'],\n                                   time=12,  # 12 month\n                                   freq=\"W\",  # Weekly\n                                   discount_rate=0.01)\n","3d330309":"cltv_final = cltv_df.merge(cltv, on=\"Customer ID\", how=\"left\")\ncltv_final.sort_values(by=\"clv\", ascending=False).head(10)\n\n# Crossing customer information\ncltv_final[cltv_final[\"Customer ID\"] == 14298.00000]\ncltv_final[cltv_final[\"Customer ID\"] == 14096.00000]\n\n# apply them scaler to understanding clearly\nscaler = MinMaxScaler(feature_range=(0, 1))\nscaler.fit(cltv_final[[\"clv\"]])\ncltv_final[\"scaled_clv\"] = scaler.transform(cltv_final[[\"clv\"]])\ncltv_final.sort_values(by=\"scaled_clv\", ascending=False).head()","0dc2eac4":"cltv_final[\"segment\"] = pd.qcut(cltv_final[\"scaled_clv\"], 4, labels=[\"D\", \"C\", \"B\", \"A\"])\ncltv_final.head()\n\ncltv_final.sort_values(by=\"scaled_clv\", ascending=False).head(50)\n\n# segment-based customer descriptive statistics\ncltv_final.groupby(\"segment\").agg(\n    {\"count\", \"mean\", \"sum\"})","53935475":"# Calculations for Weekly Values","15a09240":"# CLTV Dataset","3daa9e97":"# Creating the Data Structure for Life Time","5c888c41":"# GAMMA-GAMMA Model (Expected Average Profit)","153e6b99":"*  >  For each customer in the table above; recency, T, Frequency and Monetary values were calculated. \n*  >  E.g; There were 52 weeks between the first and last purchase of the customer with the customer number 12347,000(R). S\\he made him\\her first purchase 52 weeks ago(T). S\\he made a total of 7 transactions (F). Him\\Her total spend is 615.\n","b6979afe":"# Calculation CLTV with BG-NBD and GAMMA GAMMA Models\n","4cdf9f2b":"> **Who are the 10 customers we expect the most to purchase in a week?**","755cbf10":"# BG-NBD Model  (Expected number of transaction)","fbbf2815":"# CLTV Prediction with BG-NBD and Gamma-Gamma Models","9951f9c8":"# Creating Segments by CLTV","561a5fcd":"> **Who are the 10 customers we expect the most to purchase in a month?**","05b7abb2":"> **Analyze the top 10 people at 1 month CLTV and the 10 highest at 12 months.**","e965a61a":"# What is CLTV (Costumer Life Time Value)?","99387865":"**Customer Life Time Value**","aec9926c":"It is the total value of a customer for that company over their entire relationship with the company.\nCLTV is a prediction of the net profit attributed to an ongoing relationship between customer and product. By providing a running estimate on how much a particular consumer is likely to spend on that app, CLTV helps set marketing budgets and ensures that companies pursue the most effective users.\n\nIf a company can predict a user\u2019s lifetime value successfully, it provides marketers with a much better base on which to make decisions \u2013 helping a company maximize the effectiveness of its advertising spending. The term itself is also known as customer lifetime value (CLV or CLTV) and lifetime customer value (LCV).\n\nAre the customers we gain profitable in the long run?\n\nAre we investing enough resources to keep customers loyal and satisfy them based on customer lifetime values?\n\nWhat future strategies should we have to increase loyalty to our brand?\n\n**Formulas for CLTV**\n* Data Preprocessing\n* Average Order Value (average_order_value = total_price \/ total_transaction)\n* Purchase Frequency (total_transaction \/ total_number_of_customers)\n* Repeat Rate & Churn Rate (The number of multiple shopper \/ Total Customers)\n* Profit Margin (profit_margin =  total_price * 0.10)\n* Customer Value (customer_value = average_order_value * purchase_frequency)\n* Customer Lifetime Value (CLTV = (customer_value \/ churn_rate) x profit_margin)\n* Creation of Segments\n\n**CLTV in 4 Steps**\n* Data Preperation\n* Calculate Expected Sale Forecasting values with BG-NBD Model.\n* Calculate Expected Average Profit values with Gamma-Gamma Model.\n* Calculate CLTV for a specified time period with BG-NBD and Gamma-Gamma models."}}