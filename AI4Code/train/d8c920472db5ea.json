{"cell_type":{"01114850":"code","fbfeaa24":"code","6285b118":"code","a42ee07e":"code","fbc1adf0":"code","689a4b4b":"code","5f1ac50c":"code","7de04f7b":"code","3744f09f":"code","5bfa99a2":"code","28cf76ae":"code","91bbdeb1":"code","c26bd963":"code","0687d394":"code","19a3fc06":"code","a8d53848":"code","507df1bd":"code","3e8e4421":"code","6f2dd927":"code","18f9d446":"code","97e3da39":"code","40606611":"code","39cb44e5":"code","5b6ada81":"code","8d0b76d1":"code","c8a22512":"code","a4378995":"code","7222cec7":"code","48fd864c":"code","c358c7ca":"code","46b54a23":"code","9a5a972f":"code","41ed3f5e":"code","64233e80":"code","3b6e31e7":"markdown","a751f058":"markdown","2d6e5c65":"markdown","6aecd5ce":"markdown","d1cbd8d4":"markdown","7c1339e4":"markdown","7a63b22e":"markdown","d3187159":"markdown","b7efd967":"markdown","eac67279":"markdown","678108b6":"markdown","29bca65f":"markdown","abae2ee0":"markdown","88feb6ac":"markdown","1876d06d":"markdown","4562cf5e":"markdown","b7e0b59e":"markdown","2677829c":"markdown","918e8aab":"markdown","152c47ce":"markdown","7cf2b89b":"markdown"},"source":{"01114850":"import numpy as np                # linear algebra\nimport pandas as pd               # data frames\nimport seaborn as sns             # visualizations\nimport matplotlib.pyplot as plt\nimport scipy.stats                # statistics\nfrom scipy.cluster.hierarchy import dendrogram","fbfeaa24":"import plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots","6285b118":"from sklearn.model_selection import StratifiedShuffleSplit\nfrom sklearn.cluster import AgglomerativeClustering\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn import preprocessing","a42ee07e":"import warnings\nwarnings.filterwarnings('ignore')","fbc1adf0":"df = pd.read_csv(\"..\/input\/80-cereals\/cereal.csv\")\ndf.head()","689a4b4b":"def missing_zero_values_table(df):\n    mis_val = df.isnull().sum()\n    mis_val_percent = round(df.isnull().mean().mul(100),2)\n    mz_table = pd.concat([mis_val,mis_val_percent],axis=1)\n    mz_table = mz_table.rename(columns = {df.index.name:'col_name',0:'Missing Values',1:'% of Total Values'})\n    mz_table['Data_type']=df.dtypes\n    mz_table=mz_table.sort_values('% of Total Values',ascending=False)\n    print(\"Your selected dataframe has ** \"+str(df.shape[1])+\" ** columns and ** \"+str(df.shape[0])+\" ** Rows.\\n\"\n                 \"There are ** \"+str(mz_table[mz_table.iloc[:,1] != 0].shape[0])+\n                  \" ** columns that have missing values. \\n\")\n    return mz_table.reset_index()","5f1ac50c":"missing_zero_values_table(df)","7de04f7b":"def highlight_max(s, props=''):\n    return np.where(s == np.nanmax(s.values), props, '')\ndf[['mfr','type']].apply(pd.Series.value_counts).T.style.apply(highlight_max,props='color:red;', axis=1)","3744f09f":"df.iloc[:,~df.columns.isin(['name','mfr','type','rating'])].describe()","5bfa99a2":"df = df.sort_values(['rating'],ascending=False).reset_index(drop=True)\npx.bar(x=df[\"rating\"],y=df[\"name\"], orientation='h',\n      title='Product Rating',\n       labels={'x':'Rating',\n               'y':'Product Name'})","28cf76ae":"labels = df['type'].unique()\nvalues = df['type'].value_counts()","91bbdeb1":"fig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=.3,title='type value counts')])\nfig.show()","c26bd963":"labels = df['mfr'].unique()\nvalues = df['mfr'].value_counts()","0687d394":"px.bar(x=labels,y=values,      \n       title='mfr value counts',\n       labels={'x':'mfr',\n               'y':'Count'})","19a3fc06":"# Display the histogram to undestand the data\nf, axes = plt.subplots(3,5, figsize=(20, 12))\nsns.distplot( df[\"calories\"], ax=axes[0,0])\nsns.distplot( df[\"protein\"], ax=axes[0,1])\nsns.distplot( df[\"fat\"], ax=axes[0,2])\nsns.distplot( df[\"fiber\"], ax=axes[0,3])\nsns.distplot( df[\"sodium\"], ax=axes[0,4])\nsns.distplot( df[\"carbo\"], ax=axes[1,0])\nsns.distplot( df[\"sugars\"], ax=axes[1,1])\nsns.distplot( df[\"protein\"], ax=axes[1,2])\nsns.distplot( df[\"vitamins\"], ax=axes[1,3])\nsns.distplot( df[\"cups\"], ax=axes[1,4])\nsns.distplot( df[\"potass\"], ax=axes[2,0])\nsns.distplot( df[\"vitamins\"], ax=axes[2,1])\nsns.distplot( df[\"shelf\"], ax=axes[2,2])\nsns.distplot( df[\"weight\"], ax=axes[2,3])","a8d53848":"fig = make_subplots(rows=1, cols=2)\n\nfig.add_trace(\n    go.Scatter(x=df['mfr'], y=df['weight'],\n               mode ='markers',\n               name ='mfr & weight' ),\n    row=1, col=1\n)\n\nfig.add_trace(\n    go.Scatter(x=df['mfr'], y=df['cups'],\n              mode ='markers',\n              name ='mfr & cups'),\n    row=1, col=2\n)\n\nfig.update_layout(height=600, width=800, title_text=\"Scatter plot mfr with two y = [weight,markers]\")\nfig.show()","507df1bd":"#How to normalize the values\ndf.loc[df['name'].isin(['All-Bran','Lucky Charms','Puffed Wheat'])]","3e8e4421":"# Normalize with weight\ncereals = df.iloc[:,~df.columns.isin(['name','mfr','type','rating'])].div(df.weight, axis=0)\ncereals = pd.concat([df.iloc[:,df.columns.isin(['name','mfr','type','rating'])] , cereals], axis=1)\ncereals.head()","6f2dd927":"# Compute the correlation matrix\ncorr=df.iloc[:,~cereals.columns.isin(['name','mfr','type'])].corr()\n\n# Generate a mask for the upper triangle\nmask = np.zeros_like(corr,dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\n# set up the matplotlib figure\nf,ax = plt.subplots(figsize=(11,9))\n\n#Generate a custom diverging colormap\ncmap = sns.diverging_palette(220,10,as_cmap=True)\n\n# Draw the heatmap with the mask and correct aspect ratio\nsns.heatmap(corr,mask=mask,cmap=cmap,vmax=.3,center=0,\n           square=True, linewidths=.5, cbar_kws={\"shrink\": .5})","18f9d446":"px.scatter(\n    df, x='sugars', y='rating', opacity=0.65,\n    trendline='ols', trendline_color_override='darkblue')","97e3da39":"cereals_scale = cereals\n\nscaler  = preprocessing.StandardScaler()\ncolumns = cereals_scale.columns[3:]\ncereals_scale[columns] = scaler.fit_transform(cereals_scale[columns])\ncereals_scale.head()","40606611":"#Finding the average of good and bad ingredients\ncereals_scale['Good'] = cereals_scale.loc[:,['protein','fiber','vitamins']].mean(axis=1)\n#Good: the bigger the better\ncereals_scale['Bad'] = cereals_scale.loc[:,['fat','sodium','potass','sugars']].mean(axis=1)\n#Multiply by negative to make this indicator the bigger the worse.","39cb44e5":"cereals_scale.loc[cereals_scale['name'].isin(['All-Bran','Lucky Charms','Puffed Wheat'])]","5b6ada81":"#Visualize the relacionship between the good\/bad ingredients measure\nax = sns.lmplot('Good', # Horizontal axis\n           'Bad', # Vertical axis\n           data=cereals_scale, # Data source\n           fit_reg=True, # Don't fix a regression line\n           height = 10,\n           aspect =2 ) # size and dimension\n\nplt.title('Cereals Plot')\n# Set x-axis label\nplt.xlabel('Good')\n# Set y-axis label\nplt.ylabel('Bad')\n\n\ndef label_point(x, y, val, ax):\n    a = pd.concat({'x': x, 'y': y, 'val': val}, axis=1)\n    for i, point in a.iterrows():\n        if point['val'] == 'Lucky Charms':\n            ax.text(point['x']+.02, point['y'], str(point['val']),bbox=dict(facecolor='red', alpha=0.5))\n        else:\n            ax.text(point['x']+.02, point['y'], str(point['val']))\n\nlabel_point(cereals_scale.Good, cereals_scale.Bad, cereals_scale.name, plt.gca())  ","8d0b76d1":"# One-Hot Encoding mfr column\ndummy = pd.get_dummies(cereals_scale['mfr'])\ncereals_scale = pd.concat([cereals_scale, dummy], axis=1)","c8a22512":"# Integer Encoding\nlabel_encoder = LabelEncoder()\ntype_encoded  = label_encoder.fit_transform(cereals_scale['type'])\ncereals_scale['type_encoded'] = type_encoded","a4378995":"cereals_scale","7222cec7":"model = AgglomerativeClustering(distance_threshold=0,n_clusters=None)\n\ntemp = cereals_scale.set_index('name')\nmodel = model.fit(temp.drop(['mfr','type'],axis=1))\n\ncounts = np.zeros(model.children_.shape[0])\nn_samples = len(model.labels_)","48fd864c":"for i,merge in enumerate(model.children_):\n    current_count =0 \n    for child_idx in merge:\n        if child_idx < n_samples:\n            current_count += 1\n        else:\n            current_count += counts[child_idx - n_samples]\n        counts[i] = current_count","c358c7ca":"linkage_matrix = np.column_stack([model.children_,model.distances_,counts]).astype(float)","46b54a23":"plt.figure(figsize=(15, 15))\ndendrogram(linkage_matrix, leaf_font_size=8, orientation='right',labels=temp.index)\nplt.show()","9a5a972f":"#Finding a proxy of Sharpe Ratio good\/bad to make a new ranking.\ncereals_scale['new_ranking'] = cereals_scale['Good']\/cereals_scale['Bad']\n\n# Visualization new ranking\nnew_cereals = cereals_scale.sort_values(['new_ranking'],ascending=False).reset_index(drop=True)\nplt.figure(figsize=(20,20))\nsns.barplot(x=new_cereals[\"new_ranking\"],y=new_cereals[\"name\"])\nplt.xlabel(\"Product Name\",fontsize=15)\nplt.ylabel(\"New Rating\",fontsize=15)\nplt.title(\"Product Rating\",fontsize=15)\nplt.show()","41ed3f5e":"#Finding the most characteristic ingredient in each cereal\ndef knownby (row):\n    maxValue = max(map(abs, pd.Series.tolist(row)[4:12]))\n    try:\n        index = pd.Series.tolist(row).index(maxValue)\n    except ValueError:\n        index = pd.Series.tolist(row).index(-maxValue)        \n    return index\n\ncereals_scale['knowby']=cereals_scale.apply(lambda row: knownby (row),axis=1)\ncereals_scale['knowby']=cereals_scale.columns[cereals_scale['knowby']]\ncereals_scale.loc[cereals_scale['name'].isin(['All-Bran','Lucky Charms','Puffed Wheat'])]","64233e80":"temp = cereals_scale['knowby'].value_counts().to_frame().reset_index()\npx.bar(x=temp['index'],y=temp['knowby'],      \n       title='Count of ingredients prevalence',\n       labels={'x':'knownby',\n               'y':'Count'})","3b6e31e7":"The base of this notebook is [Lucky Charms Clovers](https:\/\/www.kaggle.com\/camiloemartinez\/lucky-charms-lovers) in my opinion, that notebook need cereals dendrogram chart, so I add dendrogram chart and published it and changed base notebook a little","a751f058":"## Understand the categorical variables","2d6e5c65":"# New Features\nTo evaluate each individual cereal we are going to create two new variables:\n-\tMeasure of good\/bad ingredients in each cereal\n-\tThe ingredient that is more relevant in each cereal\n\n","6aecd5ce":"# Take a Quick Look at the Data Structure","d1cbd8d4":"## Data Transformations\n\nNow that we have comparable variables across cereals let\u2019s standardize those variables to have an holistic approach of a cereal in all its features. This allow us to create new features with the existing variables.\n","7c1339e4":"Value counts categorical values and highlight max value  \nGeneral Mills and Kelloggs are the biggest brands in the dataset. General Mills has been producing Lucky Charms by since 1964.","7a63b22e":"'mfr','type' is categorical data and fortunately don't have missing value","d3187159":"Fiber and protein have a little correlation with the consumer preference while calories and sugars influence the most.","b7efd967":"In this context, a linear regression frontier shows the relationship between good and bad nutrients from a cereal. No doubts the best cereal by its ingredients is *All-Brand with extra Fiber* and the worse is *Cinnamon Toast Crunch*. *Lucky Charms* is not that bad but is not that good either given that is over the line.","eac67279":"## Objective\nI have been eating Lucky Charms since I was a kid, the marshmallows and the integral cereal combination looks like the perfect breakfast (sometimes even lunch and dinner) but many people say this is a bad cereal. So the question have to be ask: is Lucky Charms a good cereal amongst the other options? ","678108b6":"'mfr' column","29bca65f":"Now Lucky Charms go up 13th positions with this new approach, however still not in the top","abae2ee0":"'type' column","88feb6ac":"Lucky Charms has the 7th worse ranking mmm\u2026 maybe the general public don\u2019t like those amazing pink hearts marshmallows.","1876d06d":"# Exploratory Data Analysis","4562cf5e":"It look like the nutritional facts are given by portion which varies by cereal. We need to make those variables comparable.","b7e0b59e":"Special thanks for [Camilo Ernesto](https:\/\/www.kaggle.com\/camiloemartinez) with his great [notebook](https:\/\/www.kaggle.com\/camiloemartinez\/lucky-charms-lovers)","2677829c":"It looks like the best way to make them comparable is by weight.","918e8aab":"Let's go and enjoy it :)","152c47ce":"Just look at Lucy Charm :)","7cf2b89b":"If not Lucky charms which variables make a cereal perform better in the rating."}}