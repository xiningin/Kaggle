{"cell_type":{"2d1a818b":"code","00ece663":"code","d75b1e78":"code","d53227f5":"code","4da83ea9":"code","315cf5ab":"code","046f1c4e":"code","c90e7ed1":"code","3ddb3071":"code","bfe546a9":"code","91d3b658":"code","196d4750":"code","4adcb413":"code","b82b9879":"code","63778621":"code","8865ad70":"code","5381f945":"code","d7380e8c":"code","e46a1e2b":"code","78ed8032":"code","6e8539c9":"code","904ca377":"code","6fbc7e4e":"code","9299630c":"code","f31f72af":"code","b8ada10d":"code","40f40afd":"markdown"},"source":{"2d1a818b":"!pip -q install lightautoml","00ece663":"from sklearn.impute import SimpleImputer\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nfrom sklearn.metrics import mean_squared_error, mean_squared_log_error\nfrom sklearn.model_selection import train_test_split\n\nimport torch\nfrom autowoe import AutoWoE, ReportDeco\nfrom lightautoml.automl.presets.tabular_presets import TabularAutoML, TabularUtilizedAutoML\nfrom lightautoml.dataset.roles import DatetimeRole\nfrom lightautoml.tasks import Task","d75b1e78":"N_THREADS = 8 # threads cnt for lgbm and linear models\nN_FOLDS = 5 # folds cnt for AutoML\nRANDOM_STATE = 42 # fixed random state for various reasons\nTEST_SIZE = 0.2 # Test size for metric check\nTARGET_NAME = 'price' # Target column name\nTIMEOUT = 3500 # Time in seconds for automl run\nnp.random.seed(RANDOM_STATE)\ntorch.set_num_threads(N_THREADS)","d53227f5":"i_cols=['bodyType', 'brand', 'color', 'fuelType', 'modelDate', #'name',\n       'numberOfDoors', 'productionDate', #'vehicleConfiguration',\n       'vehicleTransmission',# 'engineDisplacement', \n        'enginePower',\n       #'description', \n        'mileage', \n        #'\u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0442\u0430\u0446\u0438\u044f',\n        '\u041f\u0440\u0438\u0432\u043e\u0434', '\u0420\u0443\u043b\u044c', \n       '\u0412\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u044b', '\u041f\u0422\u0421',  'price', #'start_date',\n       # 'model'\n       ]","4da83ea9":"train = pd.read_csv('..\/input\/parsing-all-moscow-auto-ru-09-09-2020\/all_auto_ru_09_09_2020.csv', usecols=i_cols)\ntrain.head()","315cf5ab":"train['bodyType']=train['bodyType'].apply(lambda x: str(x).split()[0])\ntrain['numberOfDoors']=train['numberOfDoors'].replace(0.0,np.nan)","046f1c4e":"imputer1 = SimpleImputer(strategy='most_frequent')\nimputer1 = imputer1.fit(train.iloc[:, [0,1,2,3,6,7,8,10,11,12,13]])\ntrain.iloc[:, [0,1,2,3,6,7,8,10,11,12,13]] = imputer1.transform(train.iloc[:, [0,1,2,3,6,7,8,10,11,12,13]])\n\nimputer2 = SimpleImputer(strategy='mean')\nimputer2 = imputer2.fit(train.iloc[:, [4,6,9,14]])\ntrain.iloc[:,[4,6,9,14]] = imputer2.transform(train.iloc[:, [4,6,9,14]])\n\nimputer3 = SimpleImputer(strategy='median')\nimputer3 = imputer3.fit(train.iloc[:, [5]])\ntrain.iloc[:,[5]] = imputer3.transform(train.iloc[:, [5]])","c90e7ed1":"train['price']=train['price'].astype(np.int64)","3ddb3071":"train_data, test_data = train_test_split(train, \n                                         test_size=TEST_SIZE, \n                                         random_state=RANDOM_STATE)","bfe546a9":"task = Task('reg', loss = 'rmsle', metric = 'rmsle')","91d3b658":"roles = {\n    'target': 'price',\n}","196d4750":"cnt_trained = 0\nresults = []\nrs_list = list(range(2000, 2005))\nfor it, rs in enumerate(rs_list):\n    print('=' * 30)\n    print('START RANDOM_STATE = {}'.format(rs))\n    print('=' * 30)\n    \n    # Train AutoML\n    automl = TabularAutoML(task = task, \n                       timeout = TIMEOUT,\n                       cpu_limit = N_THREADS,\n                       reader_params = {'n_jobs': N_THREADS, 'cv': N_FOLDS, 'random_state': rs},\n                        verbose = 1)\n    oof_pred = automl.fit_predict(train_data, roles = roles)\n    \n    # Predict on test\n    test_pred = automl.predict(test_data)\n    cnt_trained += 1\n    \n    # Save predictions\n    if it == 0:\n        oof_pred_full = oof_pred.data[:, 0].copy()\n        test_pred_full = test_pred.data[:, 0].copy()\n    else:\n        oof_pred_full += oof_pred.data[:, 0]\n        test_pred_full += test_pred.data[:, 0]\n    \n    # Check scores for current predict and aggregated one\n    rmsle_usual = mean_squared_log_error(test_data['price'].values, test_pred.data[:, 0]) ** 0.5\n    rmsle_full = mean_squared_log_error(test_data['price'].values, test_pred_full \/ cnt_trained) ** 0.5\n    results.append((rmsle_usual, rmsle_full, rmsle_full - rmsle_usual))\n    \n    print('Check scores...')\n    print('Holdout score: {}'.format(rmsle_usual))\n    print('Holdout score full: {}'.format(rmsle_full))\n    print('Difference: {}'.format(rmsle_full - rmsle_usual))","4adcb413":"test_pred_full_0 = test_pred_full.copy() \/ cnt_trained","b82b9879":"mean_rmsle = np.mean([res[0] for res in results])\nmean_rmsle","63778621":"data_with_pseudolabels = test_data.copy()\ndata_with_pseudolabels['price'] = test_pred_full_0.copy() \n\nnew_dataset = pd.concat([train_data, data_with_pseudolabels]).sample(frac = 1, random_state = 13).reset_index(drop = True)\nprint(train_data.shape, new_dataset.shape)","8865ad70":"train_data['price'].describe()","5381f945":"new_dataset['price'].describe()","d7380e8c":"cnt_trained = 0\nresults = []\nrs_list = list(range(2000, 2005))\nfor it, rs in enumerate(rs_list):\n    print('=' * 30)\n    print('START RANDOM_STATE = {}'.format(rs))\n    print('=' * 30)\n    \n    # Train AutoML\n    automl = TabularAutoML(task = task, \n                       timeout = TIMEOUT,\n                       cpu_limit = N_THREADS,\n                       reader_params = {'n_jobs': N_THREADS, 'cv': N_FOLDS, 'random_state': rs},\n                        verbose = 1)\n    oof_pred = automl.fit_predict(new_dataset, roles = roles)\n    \n    # Predict on test\n    test_pred = automl.predict(test_data)\n    cnt_trained += 1\n    \n    # Save predictions\n    if it == 0:\n        oof_pred_full = oof_pred.data[:, 0].copy()\n        test_pred_full = test_pred.data[:, 0].copy()\n    else:\n        oof_pred_full += oof_pred.data[:, 0]\n        test_pred_full += test_pred.data[:, 0]\n    \n    # Check scores for current predict and aggregated one\n    rmsle_usual = mean_squared_log_error(test_data['price'].values, test_pred.data[:, 0]) ** 0.5\n    rmsle_full = mean_squared_log_error(test_data['price'].values, test_pred_full \/ cnt_trained) ** 0.5\n    results.append((rmsle_usual, rmsle_full, rmsle_full - rmsle_usual))\n    \n    print('Check scores...')\n    print('Holdout score: {}'.format(rmsle_usual))\n    print('Holdout score full: {}'.format(rmsle_full))\n    print('Difference: {}'.format(rmsle_full - rmsle_usual))","e46a1e2b":"mean_rmsle = np.mean([res[0] for res in results])\nmean_rmsle","78ed8032":"def clean_dataset(df):\n    assert isinstance(df, pd.DataFrame), \"df needs to be a pd.DataFrame\"\n    df.dropna(inplace=True)\n    indices_to_keep = ~df.isin([np.nan, np.inf, -np.inf]).any(1)\n    return df[indices_to_keep].astype(np.float32)","6e8539c9":"cnt_trained = 0\nresults = []\nrs_list = list(range(2000, 2010))\nfor it, rs in enumerate(rs_list):\n    print('=' * 30)\n    print('START RANDOM_STATE = {}'.format(rs))\n    print('=' * 30)\n    \n    # Train AutoML\n    automl = TabularAutoML(task = task, \n                       timeout = TIMEOUT,\n                       cpu_limit = N_THREADS,\n                       reader_params = {'n_jobs': N_THREADS, 'cv': N_FOLDS, 'random_state': rs},\n                        verbose = 1)\n    oof_pred = automl.fit_predict(train_data, roles = roles)#.astype(np.int64)\n    \n    # Predict on test\n    test_pred = automl.predict(test_data)\n    cnt_trained += 1\n    \n    print(oof_pred.data[:, 0])\n    print(np.all(np.isfinite(oof_pred.data[:, 0])))\n    \n    mean_arr=np.nanmean(oof_pred.data[:, 0])\n    print(mean_arr)\n    oof_pred.data[:, 0]=np.nan_to_num(oof_pred.data[:, 0],nan=mean_arr)\n    print(np.all(np.isfinite(oof_pred.data[:, 0])))\n    \n    \n    print(test_pred.data[:, 0])\n    print(np.all(np.isfinite(test_pred.data[:, 0])))\n    \n    testmean_arr=np.nanmean(test_pred.data[:, 0])\n    print(testmean_arr)\n    test_pred.data[:, 0]=np.nan_to_num(test_pred.data[:, 0],nan=testmean_arr)\n    print(np.all(np.isfinite(test_pred.data[:, 0])))  \n    # Save predictions\n    if it == 0:\n        oof_pred_full = oof_pred.data[:, 0].copy()\n        test_pred_full = test_pred.data[:, 0].copy()\n    else:\n        oof_pred_full += oof_pred.data[:, 0]\n        test_pred_full += test_pred.data[:, 0]\n\n    # Check scores for current predict and aggregated one\n    rmsle_usual = mean_squared_log_error(train_data['price'].values, oof_pred.data[:, 0]) ** 0.5\n    rmsle_full = mean_squared_log_error(train_data['price'].values, oof_pred_full \/ cnt_trained) ** 0.5\n    results.append((rmsle_usual, rmsle_full, rmsle_full - rmsle_usual))\n    \n    print('Check scores...')\n    print('OOF score: {}'.format(rmsle_usual))\n    print('OOF score full: {}'.format(rmsle_full))\n    print('Difference: {}'.format(rmsle_full - rmsle_usual))","904ca377":"test_pred_full_0 = test_pred_full.copy() \/ cnt_trained","6fbc7e4e":"# create pseudolabelled dataset from real test data\ntest_data_with_pseudolabels = test_data.copy()\ntest_data_with_pseudolabels['price'] = test_pred_full_0\n\n# combine all together\nfull_dataset = pd.concat([train_data, test_data_with_pseudolabels]).sample(frac = 1, random_state = 13).reset_index(drop = True)\nprint(train_data.shape, full_dataset.shape)","9299630c":"cnt_trained = 0\nresults = []\nrs_list = list(range(2000, 2007))\nfor it, rs in enumerate(rs_list):\n    print('=' * 30)\n    print('START RANDOM_STATE = {}'.format(rs))\n    print('=' * 30)\n    \n    # Train AutoML\n    automl = TabularAutoML(task = task, \n                       timeout = TIMEOUT,\n                       cpu_limit = N_THREADS,\n                       general_params = {'use_algos': ['lgb', 'lgb_tuned', 'cb_tuned']},\n                       reader_params = {'n_jobs': N_THREADS, 'cv': N_FOLDS, 'random_state': rs},\n                        verbose = 1)\n    oof_pred = automl.fit_predict(full_dataset, roles = roles)\n    \n    # Predict on test\n    test_pred = automl.predict(test_data)\n    cnt_trained += 1\n    \n    # Save predictions\n    if it == 0:\n        oof_pred_full = oof_pred.data[:, 0].copy()\n        test_pred_full = test_pred.data[:, 0].copy()\n    else:\n        oof_pred_full += oof_pred.data[:, 0]\n        test_pred_full += test_pred.data[:, 0]","f31f72af":"predictions = test_pred_full \/ cnt_trained","b8ada10d":"import joblib\njoblib.dump(automl, 'model.pkl')","40f40afd":"https:\/\/www.kaggle.com\/alexryzhkov\/lightautoml-houseprices-love"}}