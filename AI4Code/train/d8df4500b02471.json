{"cell_type":{"d0f10bd8":"code","ea97f7b8":"code","b9794d4c":"code","3e5cc6a7":"code","cb731007":"code","7ad276df":"code","0b6c4672":"code","03f4ec79":"code","4d92f89b":"code","4d85b82c":"code","0cbc5464":"code","8039db21":"code","872b0c51":"code","2db2f970":"markdown","da879e28":"markdown","d37a999e":"markdown","36a9dcc9":"markdown","27e4466b":"markdown","fb2fd146":"markdown","12cd5b65":"markdown","a474be56":"markdown","d2a90849":"markdown","961fb9c4":"markdown","c79b5246":"markdown","eb115ad6":"markdown","021db103":"markdown","35a3928c":"markdown","5d224dfc":"markdown","831ead35":"markdown","b9e6c598":"markdown"},"source":{"d0f10bd8":"#We set the handles to empty only once\nif not 'handles' in globals():\n    global handles\n    handles=[]","ea97f7b8":"import _ctypes\ndef unloadAllLibs():\n    global handles\n    for handle in handles:\n        _ctypes.dlclose(handle)\n    handles=[]","b9794d4c":"%%writefile myfunc.cpp\n\nextern \"C\" {\n    \n    struct GRID{\n        int* data;\n        int W;\n        int H;\n    };\n    \n    long sumOfSquares(long x) {\n        long total=0;\n        for(long n=0;n<x;n++){\n           total+=n*n;\n        }\n        return total;\n    }\n    int* doubleElements(int* A, int W, int H){\n        int* B=new int[W*H];\n        for(int x=0;x<W;x++){\n            for(int y=0;y<H;y++){\n                B[W*y+x] = A[W*y+x]*2;\n            }\n        }\n        return B;\n    }\n    \n    GRID addOne(GRID a){\n        for(int n=0; n<a.W * a.H; n++){\n            a.data[n]++;\n        }\n        return a;\n    }\n}","3e5cc6a7":"!g++  -shared -o myfunctions.dll myfunc.cpp","cb731007":"import numpy as np\nimport ctypes\nfrom numpy.ctypeslib import ndpointer\n\nunloadAllLibs()\nlib = ctypes.cdll.LoadLibrary('\/kaggle\/working\/myfunctions.dll')\n#Always keep a track of the handles:\nhandles.append(lib._handle)\n\nmylist = [1,2,3,4,5,6]\n\n#set the output type:\nlib.doubleElements.restype = ndpointer(dtype=ctypes.c_int32, shape=[3,2])\nlib.sumOfSquares.restype = ctypes.c_int64\n#lib.doubleElements.argtypes = [ctypes.POINTER(ctypes.c_int32)] #<--(Not neccessary - the input type is inferred)\n\n#create a C array from the list\nclist =  (ctypes.c_int32 * len(mylist)) (*mylist)\n\n#Call the functions\nprint(lib.sumOfSquares(100))\nprint(lib.doubleElements( clist , 3, 2 ))\n\n#Alternatively just return a C array:\nlib.doubleElements.restype = ctypes.POINTER(ctypes.c_int32)\nx = lib.doubleElements( clist , 3, 2 )\n\n#We change the C array back into a list like this:\nprint([x[i] for i in range(6)])\n\n","7ad276df":"#lib.foo.restype = POINTER(POINTER(c_int))\n#clist2d = (POINTER(c_int) * 2) ( (c_int * 2) (10,20) , (c_int * 2) (30,40))","0b6c4672":"a = np.array([[2,4],[6,8],[10,12]],dtype=np.int32)\ncarray = a.ctypes.data_as(ctypes.POINTER(ctypes.c_int32))\n#lib.doubleElements.restype = ndpointer(dtype=ctypes.c_int32, shape=[3,2]) #<--could use this instead of casting\nb = lib.doubleElements(carray,3,2)\n#get back the array:\nnp.ctypeslib.as_array(b,shape=[3,2])","03f4ec79":"class GRID(ctypes.Structure):\n    _fields_=[(\"data\",ctypes.POINTER(ctypes.c_int32)),(\"W\",ctypes.c_int32),(\"H\",ctypes.c_int32 )]\n \nlib.addOne.restype = GRID;\n    \nA = GRID(carray,3,2)\nB = lib.addOne(A)\nnp.ctypeslib.as_array(B.data,shape=[B.W,B.H])","4d92f89b":"%load_ext Cython","4d85b82c":"%%cython\ncpdef long sumOfSquares(long x):\n    cdef long total=0\n    cdef long n=0\n    for n in range(x):\n        total+=n*n\n    return total\n","0cbc5464":"def sumOfSquaresPython(x):\n    total=0\n    for n in range(x):\n        total+=n*n\n    return total","8039db21":"import time\nL=1000000\n#Commented out pure python because it's too slow\n'''\nstart=time.time()\nz=sumOfSquaresPython(L)\nend=time.time()\nprint(f'Pure python {end-start}    {z}')\n'''\n\nstart=time.time()\nz=lib.sumOfSquares(L)\nend=time.time()\nprint(f'Pure C++ {end-start}    {z}')\n\nstart=time.time()\nz=sumOfSquares(L)\nend=time.time()\nprint(f'Cython {end-start}    {z}')","872b0c51":"#Lets unload the libraries just for good measure\nunloadAllLibs()","2db2f970":"Tutorial\n==","da879e28":"It is important to keep a track of the handles of the libraries you have loaded and then unload them before trying to recompile the libaries. So we have an array to keep track of the libraries you have loaded:","d37a999e":"Time comparisons (obviously the results are wrong since the numbers are bigger than machine precission):","36a9dcc9":"Using C++ functions in your Code\n==\n\nThis notebook demonstrates how you can use C++ functions in your code if you need a bit of a speed up (It could speed up your code by 30 times in some cases). I don't know if this will work for competitions or not. You can change the C++ functions and click **Run All** and it should work.\n\nA comparrison with Cython at the end. It turns out it may be better to use cython  after all instead of messing about with C++! Whatever is best for you. One downside of Cython is it seems like it takes a very long time to compile large files compared to C++. Probably use Cython if you only have a small function to speed up and C++ if you have many functions.","27e4466b":"Compile the library:","fb2fd146":"Thankyou\n==\nI hope you enjoyed this notebook","12cd5b65":"Create your C++ library functions here:","a474be56":"Multidimensional Arrays\n==\nFor a 2x2 multidimensional array \n\nint\\*\\*foo(int\\*\\* x) {..}\n\nyou have for example:","d2a90849":"Structs\n==\nIt is sometimes useful to put things in structs. We just have to make the same Structure in Python:","961fb9c4":"Tips\n==\nFor fastest performance, keep your arrays as C arrays rather than convert back and forth between numpy arrays and C arrays. Put loops in C++ rather than calling C++ functions in a loop. Use Python for things like visualisation and printing results. If you have a lot of C++ code, it may be useful to put this in another file while working, and only add it to the notebook when submitting to competitions. (I have found ndpointer doesn't work on all systems but seems to work on Kaggle.)","c79b5246":"Clean up:\n","eb115ad6":"Casting is easier with numpy arrays. To turn an numpy array into a 1D C array use:","021db103":"Define a function to unload the libraries so we can recompile them later:","35a3928c":"Cython\n==\nThis is way of compiling python down to C. But it only works if you have the Cython extension. It works on Kaggle but maybe not offline unless you install the extension. ","5d224dfc":"We'll compare this with a function written in pure python:","831ead35":"Now you can call the functions","b9e6c598":"Write your cython code. It is like python but with types. "}}