{"cell_type":{"ad7a4b82":"code","b33ee0e5":"code","e11439b4":"code","91b8d125":"code","32d02c05":"code","0e87cef3":"code","81e9f886":"code","28b02eaf":"code","65600c15":"code","422ded63":"markdown","d3880a78":"markdown","cb89f7a9":"markdown"},"source":{"ad7a4b82":"import pandas as pd\nimport numpy as np\nimport lightgbm as lgb\nimport matplotlib.pyplot as plt","b33ee0e5":"print('Train')\ntrain = pd.read_csv(\"..\/input\/train\/train.csv\")\nprint(train.shape)\n\ntarget = train['AdoptionSpeed']\ntrain_id = train['PetID']\ntrain.drop(['AdoptionSpeed', 'PetID'], axis=1, inplace=True)","e11439b4":"# drop categorical features to simplify\ntrain.drop(['Name', 'RescuerID', 'Description'], axis=1, inplace=True)\ntrain.shape","91b8d125":"# 5 classes classificasion\n\nlgb_params = {'objective':'multiclass',\n              'num_class': 5, \n              'learning_rate': 0.1,\n              'boosting': 'gbdt',\n              'n_estimators': 10000, \n              'random_state': 2019}","32d02c05":"from sklearn.model_selection import KFold\n\nfolds = KFold(n_splits=3, shuffle=True, random_state=15)\n\nclasses = sorted(target.unique())\noof_preds = np.zeros((len(train), len(classes)))\n\nfeatures = [c for c in train.columns if c not in ['target']]\n\nfor fold_, (trn_, val_) in enumerate(folds.split(train.values, target.values)):\n    trn_x, trn_y = train.iloc[trn_][features], target.iloc[trn_]\n    val_x, val_y = train.iloc[val_][features], target.iloc[val_]\n    \n    clf = lgb.LGBMClassifier(**lgb_params)\n    clf.fit(\n        trn_x, trn_y,\n        eval_set=[(trn_x, trn_y), (val_x, val_y)],\n        verbose=100,\n        early_stopping_rounds=100,\n    )\n    oof_preds[val_] = clf.predict_proba(val_x, num_iteration=clf.best_iteration_)\n    \nprint(oof_preds.shape)","0e87cef3":"oof_preds[:5]","81e9f886":"# http:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.metrics.confusion_matrix.html\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n    plt.tight_layout()","28b02eaf":"unique_y = np.unique(target)\nclass_map = dict()\nfor i,val in enumerate(unique_y):\n    class_map[val] = i\n        \ny_map = np.zeros((target.shape[0],))\ny_map = np.array([class_map[val] for val in target])\ny_map.shape","65600c15":"import itertools\nfrom sklearn.metrics import confusion_matrix\n\n# Compute confusion matrix\ncnf_matrix = confusion_matrix(y_map, np.argmax(oof_preds,axis=-1))\nnp.set_printoptions(precision=2)\n\nclass_names = classes # list [0, 1, 2, 3, 4]\n\n# Plot non-normalized confusion matrix\nplt.figure(figsize=(7,7))\nfoo = plot_confusion_matrix(cnf_matrix, classes=class_names,normalize=True,\n                      title='Confusion matrix')","422ded63":"cf : https:\/\/www.kaggle.com\/c\/PLAsTiCC-2018\/discussion\/74564","d3880a78":"# We got probabilities of each classes","cb89f7a9":"# This is my first public kernel which will introduce you the useful tool to visualize your preds.\n\n"}}