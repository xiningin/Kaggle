{"cell_type":{"5117ff94":"code","724254aa":"code","46aec547":"code","279df58c":"code","7a16f57f":"code","78d4d7a5":"code","1e0e2a6d":"code","a105246c":"code","1676ad13":"code","4815190f":"code","9978ff2f":"markdown","d78dc6c0":"markdown","8572a4ea":"markdown"},"source":{"5117ff94":"# Adding imports that will be used\n\nimport numpy as np # linear algebra\n\n# The following code takes all files in the given directory and print the paths of the files\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","724254aa":"# Definition of the tuples that will be read from the input files. These tuples of three positions represent the item index, its value and its weight\nimport sys\nimport csv\ncsv.field_size_limit(sys.maxsize)\nfrom collections import namedtuple\nItem = namedtuple(\"Item\", ['index', 'value', 'weight']) # check https:\/\/docs.python.org\/3\/library\/collections.html#collections.namedtuple","46aec547":"# This method checks that the solution is a valid solution. It is that the selected list of items does not weight more than the knapsack capacity\ndef check_solution(capacity, items, taken):\n    weight = 0\n    value = 0\n    for item in items:\n        if taken[item.index]== 1:\n            weight += item.weight\n            value += item.value\n    if weight> capacity:\n        print(\"Incorrect solution, the knapsack capacity is exceeded: Capacity = %f, Weight = %f\" % (capacity, weight))\n        return 0\n    return value","279df58c":"def solve_with_greedy(items, capacity):\n    # a trivial greedy algorithm for filling the knapsack\n    # it takes items in-order until the knapsack is full\n    # do you need a sort? Implement the sort method (below) and use it here\n\n    #implement your own heuristic at value_comparator as an item comparer\n    itemsSortedByValue = sort(items, cmp=value_comparator)\n    \n    value = 0\n    weight = 0\n    taken = [0]*len(items)\n\n    for item in itemsSortedByValue:\n        if weight + item.weight <= capacity:\n            taken[item.index] = 1\n            value += item.value\n            weight += item.weight\n            \n    # prepare the solution in the specified output format\n    output_data = str(value) + ' ' + str(0) + '\\n'\n    output_data += ' '.join(map(str, taken))\n    \n    return output_data, check_solution(capacity, items, taken)","7a16f57f":"# Write here your implementation of sort()\ndef sort(items, cmp):\n    pass","78d4d7a5":"# This function takes input data that describes a specific problem of TSP and solve it\ndef solve_it(input_data):\n    # Modify this code to run your optimization algorithm\n    # parse the input\n    lines = input_data.split('\\n')\n\n    firstLine = lines[0].split()\n    item_count = int(firstLine[0])\n    capacity = int(firstLine[1])\n\n    items = []\n\n    for i in range(1, item_count+1):\n        line = lines[i]\n        parts = line.split()\n        items.append(Item(i-1, int(parts[0]), int(parts[1])))\n\n    return solve_with_greedy(items, capacity)","1e0e2a6d":"# For each input file, solve_it is called and the result serialized in the ouputs for kaggle and moodle\nstr_output_kaggle = [[\"Filename\",\"Max_value\"]]\nstr_output_moodle = [[\"Filename\",\"Max_value\", \"Solution\"]]\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        full_name = dirname+'\/'+filename\n        with open(full_name, 'r') as input_data_file:\n            input_data = input_data_file.read()\n            output, value = solve_it(input_data)\n            str_output_kaggle.append([filename,str(value)])\n            str_output_moodle.append([filename,str(value), output.split('\\n')[1]])","a105246c":"from IPython.display import FileLink\ndef submission_generation(filename, str_output):\n    os.chdir(r'\/kaggle\/working')\n    with open(filename, 'w', newline='') as file:\n        writer = csv.writer(file)\n        for item in str_output:\n            writer.writerow(item)\n    return  FileLink(filename)","1676ad13":"submission_generation('NAME_P2_kaggle.csv', str_output_kaggle)","4815190f":"# The file generated by this method must be uploaded in the task of the \"campus virtual\". The file to upload in the \"campus virtual\" must be the one related to one submitted to Kaggle. That is, both submitted files must be generated in the same run\nsubmission_generation('NAME_P2_moodle.csv', str_output_moodle)","9978ff2f":"El problema de la mochila (Knapsack problem - KSP) consiste en encontrar, a partir de los objetos disponibles, el conjunto de objetos que quepa en la mochila cuyo valor acumulado sea m\u00e1ximo. Al igual que en el problema anterior, este problema es f\u00e1cilmente resoluble haciendo una comprobaci\u00f3n de todas las posibles combinaciones de objetos y tomando aquella que m\u00e1s valor tenga. Sin embargo, estos m\u00e9todos basados en la fuerza bruta son imposibles de aplicar cuando la lista de objetos que se pueden introducir en la mochila crece mucho.\n\nEn esta pr\u00e1ctica se trabajar\u00e1 el problema de la mochila, teniendo como objetivo alcanzar una soluci\u00f3n que permita calcular conjuntos de objetos \u00f3ptimos a partir de una lista peque\u00f1a de objetos. Como en la pr\u00e1ctica anterior, y siguiendo este notebook, se tendr\u00e1 que hacer uso del lenguaje de programaci\u00f3n Python para realizar la pr\u00e1ctica, rellenando o modificando el c\u00f3digo que se indique a lo largo del notebook. Se debe realizar una implementaci\u00f3n de un algoritmo **greedy** para resolver este problema.\n\nEn este notebook se han incluido distintos datasets que representan diferentes configuraciones del problema del KSP, con distintas listas de objetos y tama\u00f1os de mochila. El c\u00f3digo que acompa\u00f1a a este notebook permite realizar la lectura de estos ficheros para su procesamiento. Existen varios c\u00f3digos a lo largo del notebook que deben ser completados o modificados para terminar esta practica. Concretamente, se debe realizar las siguientes implementaciones:\n\n* Algoritmo greedy para solucionar el problema del KSP\n* Algoritmo de ordenaci\u00f3n de vectores (no se puede usar la funci\u00f3n [sort()](https:\/\/docs.python.org\/3\/howto\/sorting.html) the Python o similares, aunque se puede usar para comprobar resultados).\n\nNOTA: los c\u00f3digos implementados por el alumno deben utilizar [funciones lambda](https:\/\/www.w3schools.com\/python\/python_lambda.asp) en la medida de lo posible.","d78dc6c0":"El c\u00f3digo a continuaci\u00f3n debe ser modificado para implementar una soluci\u00f3n [**greedy**](https:\/\/es.wikipedia.org\/wiki\/Algoritmo_voraz) que utilice en la medida de lo posible funciones lambda","8572a4ea":"La siguiente funci\u00f3n debe ser implementada por el alumno. Debe implementarse alg\u00fan m\u00e9todo de ordenaci\u00f3n de vectores para poderlo usar desde la funci\u00f3n solve_with_greedy.\n\nLa funci\u00f3n acepta dos argumentos. El primero \"items\" es la lista de Items a ordenar, el segundo \"cmp\" es una funci\u00f3n lambda de comparaci\u00f3n analoga a las que utiliza el m\u00e9todo [sort()](https:\/\/docs.python.org\/3\/howto\/sorting.html) de Python 3"}}