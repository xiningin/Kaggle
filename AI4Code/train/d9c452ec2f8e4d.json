{"cell_type":{"fe604a85":"code","db6e4269":"code","7eafe77e":"code","f57d02fe":"code","72a04347":"code","164b442a":"code","f7937ab4":"code","3c7f88ba":"code","2059fb06":"code","974512aa":"code","0c5db0dc":"code","ead4d979":"code","ddcc7feb":"code","feca2594":"markdown","3be2dd98":"markdown"},"source":{"fe604a85":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport os, glob, random, cv2, glob, pydicom\n","db6e4269":"\ndirectory = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train'\nvox = [\"FLAIR\",\"T1w\", \"T1wCE\", \"T2w\"]\n ","7eafe77e":"# Get a list of images in a series\ndef get_series_list(case, series_name):\n    series_list = []\n    for subdirs, dirs, files in os.walk(directory + '\/' + case + \"\/\" + series_name):\n        series_list = os.listdir(directory + '\/' + case + '\/' + series_name)        \n    return series_list","f57d02fe":"# Find the image in the middle of each series stack, returns a list of four images\ndef get_middle_images(case):\n    \n    middle_images = []\n    \n    # Iterate through each of the four series directories and get the files \n    for ser in vox:\n        series_files = get_series_list(case, ser)\n        series_df = pd.DataFrame(columns = ['image','instance_number'])\n\n        # Get the DICOM InstanceNumber tag to order the images since we can't rely on the filenames to be in order\n        for s in series_files:\n            img = pydicom.dcmread(directory + \"\/\" + case + \"\/\" + ser + \"\/\" + s)\n            series_df.loc[len(series_df.index)] = [s, img[0x0020,0x0013].value] \n        series_df['instance_number'] = pd.to_numeric(series_df['instance_number'])\n\n        # Sort the image list by InstanceNumber\n        series_df = series_df.sort_values(by=['instance_number'])\n        \n        # Find the image in the middle of the list\n        middle_index = int(series_df.shape[0] \/ 2)\n        middle_image = series_df.iloc[middle_index]['image']\n\n        middle_images.append(ser + \"\/\" + middle_image)\n\n    return middle_images","72a04347":"# Convert the Image Orientation Patient tag cosine values into a text string of the plane.\n# This represents the plane the image is 'closest to' .. it does not explain any obliqueness\ndef get_image_plane(loc):\n    row_x = round(loc[0])\n    row_y = round(loc[1])\n    row_z = round(loc[2])\n    col_x = round(loc[3])\n    col_y = round(loc[4])\n    col_z = round(loc[5])\n    if row_x == 1 and row_y == 0 and col_x == 0 and col_y == 0:\n        return \"Coronal\"\n    if row_x == 0 and row_y == 1 and col_x == 0 and col_y == 0:\n        return \"Sagittal\"\n    if row_x == 1 and row_y == 0 and col_x == 0 and col_y == 1:\n        return \"Axial\"\n    return \"Unknown\"","164b442a":"# Display images and their plane\n#def plane_images(dataset,case):\n        \ncase1=[]\nflair,j_flair=[],[]  \nt1w,j_t1w=[],[]    \nt1wce,j_t1wce=[],[]   \nt2w,j_t2w=[],[]    \n#note = []\n\ndf ={}\n#dataset=\"train\"\n\ncases = os.listdir(directory)\nfor case in cases:\n      \n    for img in get_middle_images(case):\n        \n        baca=directory + \"\/\" + case \n        image = pydicom.dcmread(baca+ \"\/\" + img)\n        ser = img.split(\"\/\")\n        image_orientation_patient = image[0x0020,0x0037]        \n        plane = get_image_plane(image_orientation_patient)\n\n        if ser[0]==\"FLAIR\":\n            flair.append(plane)   #+'('+str(len(os.listdir(baca+ \"\/FLAIR\")))+')')\n            j_flair.append(len(os.listdir(baca+ \"\/FLAIR\")))\n        if ser[0]==\"T1w\":\n            t1w.append(plane)   #+'('+str(len(os.listdir(baca+ \"\/T1w\")))+')')\n            j_t1w.append(len(os.listdir(baca+ \"\/T1w\")))\n        if ser[0]==\"T1wCE\":\n            t1wce.append(plane)   #+'('+str(len(os.listdir(baca+ \"\/T1wCE\")))+')')\n            j_t1wce.append(len(os.listdir(baca+ \"\/T1wCE\")))\n        if ser[0]==\"T2w\":\n            t2w.append(plane)   #+'('+str(len(os.listdir(baca+ \"\/T2w\")))+')' )            \n            j_t2w.append(len(os.listdir(baca+ \"\/T2w\")))\n                       \n    case1.append(case)   #+'('+str(len(cases))+')')\n    #note.append(img)\n    \n    df = pd.DataFrame.from_dict({        \n        \"case1\" : case1,\n        #\"0\" : jum_case1,\n        \n        \"flair\" : flair,\n        \"j_flair\" : j_flair,\n        \n        \"t1w\" : t1w,\n        \"j_t1w\" : j_t1w,\n        \n        \"t1wCE\" : t1wce,\n        \"j_t1wce\" : j_t1wce,\n        \n        \"t2w\" : t2w,\n        \"j_t2w\" : j_t2w\n        \n        #\"Note\" : note\n    })\n    #return df    \nprint(df)","f7937ab4":"# df.to_excel(\"PreprocessDataMRI-1.xlsx\", sheet_name=\"data\", index=False)\n# df.to_csv(\"PreprocessDataMRI-1.csv\", index=False)","3c7f88ba":"df_train_labels_dir = '..\/input\/rsna-miccai-brain-tumor-radiogenomic-classification\/train_labels.csv'\ndf_train_labels = pd.read_csv(df_train_labels_dir) \n\n#df_train_labels = df_train_labels.rename({'BraTS21ID': 'case1'}, axis=1)\ndf_train_labels['BraTS21ID'] = df_train_labels['BraTS21ID'].apply(lambda x: '{0:0>5}'.format(x))\nprint(len(df_train_labels))    \ndf_train_labels.head()","2059fb06":"#df_train=pd.read_csv('PreprocessDataMRI-0.csv')\ndf_train=df\n\ndf_train = df_train.rename({'case1':'BraTS21ID','flair': 'FLAIR','t1w':'T1w','t1wCE':'T1wCE','t2w':'T2w'}, axis=1)\ndf_train = df_train.rename({'j_flair': 'j_FLAIR','j_t1w':'j_T1w','j_t1wce':'j_T1wCE','j_t2w':'j_T2w'}, axis=1)\ndf_train['BraTS21ID'] = df_train['BraTS21ID'].apply(lambda x: '{0:0>5}'.format(x))\ndf_train['path_BraTS21ID']=directory+'\/'+df_train['BraTS21ID'] \ndf_train2 = pd.concat([df_train, df_train_labels['MGMT_value']], axis=1)\ndf_train2[0:10]","974512aa":"# Make a simple linear VOI LUT from the raw (stored) pixel data\ndef make_lut(storedPixels, windowWidth, windowLevel, p_i):\n    \n    # Slope and Intercept set to 1 and 0 for MR. Get these from DICOM tags instead if using \n    # on a modality that requires them (CT, PT etc)\n    slope = 1.0\n    intercept = 0.0\n    minPixel = int(np.amin(storedPixels))\n    maxPixel = int(np.amax(storedPixels))\n\n    # Make an empty array for the LUT the size of the pixel 'width' in the raw pixel data\n    lut = [0] * (maxPixel + 1)\n    \n    # Invert pixels and windowLevel for MONOCHROME1. We invert the specified windowLevel so that \n    # increasing the level value makes the images brighter regardless of photometric intrepretation\n    invert = False\n    if p_i == \"MONOCHROME1\":\n        invert = True\n    else:\n        windowLevel = (maxPixel - minPixel) - windowLevel\n        \n    # Loop through the pixels and calculate each LUT value\n    for storedValue in range(minPixel, maxPixel):\n        modalityLutValue = storedValue * slope + intercept\n        voiLutValue = (((modalityLutValue - windowLevel) \/ windowWidth + 0.5) * 255.0)\n        clampedValue = min(max(voiLutValue, 0), 255)\n        if invert:\n            lut[storedValue] = round(255-clampedValue)\n        else:\n            lut[storedValue] = round(clampedValue)\n        \n    return lut","0c5db0dc":"# Apply the LUT to a pixel array\ndef apply_lut(pixels_in, lut):\n    \n    pixels_in = pixels_in.flatten()\n    pixels_out = [0] * len(pixels_in)\n    \n    for i in range(0, len(pixels_in)):\n        pixel = pixels_in[i]\n        pixels_out[i] = int(lut[pixel])\n        \n    return pixels_out","ead4d979":"pasient=os.listdir(directory)[0]\n\n#vox = [\"FLAIR\",\"T1w\", \"T1wCE\", \"T2W\"]\ndef gambar(baris,kolom):  \n    t=directory+'\/'+pasient+'\/'+vox[kolom]\n    t_paths = sorted(os.listdir(t), \n            key=lambda x: int(x[:-4].split(\"-\")[-1]),)   \n    mid =len(os.listdir(directory+'\/'+pasient+'\/'+vox[kolom]))\/\/2\n    t_paths_=t_paths[mid-((nbaris+2)\/\/2):mid+((nbaris+2)\/\/2)]  \n    t_paths_ = t_paths_[baris]\n    return t_paths_\n\nwindow_width = 300    # 1000,600,300,  1500,1000, 700\nwindow_level = 900     #  900,900,900,  2000,2000,2000\n\nnbaris=10\n\nfig,axs = plt.subplots(nbaris,4,figsize=(4*10,nbaris*10))\nfig.subplots_adjust(top=.96)\nfig.suptitle('pasient = '+pasient, fontsize=60, fontweight='bold')\n\nfor kolom in range (4):\n    for baris in range(nbaris):     \n        gam = pydicom.read_file(directory+'\/'+pasient+'\/'+vox[kolom]+'\/'+gambar(baris,kolom))   #.pixel_array \n        \n        lut = make_lut(gam.pixel_array, window_width, window_level, gam.PhotometricInterpretation)\n        gam = np.reshape(apply_lut(gam.pixel_array, lut), (gam.pixel_array.shape[0],gam.pixel_array.shape[1]))\n        \n        plane=df_train2[df_train2['BraTS21ID'] == pasient][vox[kolom]].values[0]\n        \n        axs[baris, kolom].imshow(gam,cmap=\"viridis\")   #cmap='gray')   #cmap=\"viridis\") \n        axs[baris, kolom].set_title(vox[kolom]+'-'+plane+' ('+gambar(baris,kolom)+')',fontsize=26)","ddcc7feb":"pasient=os.listdir(directory)[1]\n\n\ndef gambar(baris,kolom):  \n    t=directory+'\/'+pasient+'\/'+vox[kolom]\n    t_paths = sorted(os.listdir(t), \n            key=lambda x: int(x[:-4].split(\"-\")[-1]),)   \n    mid =len(os.listdir(directory+'\/'+pasient+'\/'+vox[kolom]))\/\/2\n    t_paths_=t_paths[mid-((nbaris+2)\/\/2):mid+((nbaris+2)\/\/2)]  \n    t_paths_ = t_paths_[baris]\n    return t_paths_\n\nnbaris=7\n\nfig,axs = plt.subplots(nbaris,4,figsize=(4*10,nbaris*10))\nfig.subplots_adjust(top=.96)\nfig.suptitle('pasient = '+pasient, fontsize=60, fontweight='bold')\n\nfor kolom in range (4):\n    for baris in range(nbaris):     \n        gam = pydicom.read_file(directory+'\/'+pasient+'\/'+vox[kolom]+'\/'+gambar(baris,kolom)).pixel_array           \n        axs[baris, kolom].imshow(gam,cmap=\"viridis\") \n        axs[baris, kolom].set_title(vox[kolom]+' ('+gambar(baris,kolom)+')',fontsize=26)\n","feca2594":"## Adjust contrast and brightness","3be2dd98":"## Determining Planes"}}