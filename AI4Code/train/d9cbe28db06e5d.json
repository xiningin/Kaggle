{"cell_type":{"f4b69f36":"code","05ac38b3":"code","1a586261":"code","563c55ec":"code","f3449bf2":"code","b322d249":"code","ac46de40":"code","87af9dd5":"code","bdf7d0a0":"code","ea7e5d4d":"code","fde7e478":"code","b41959bc":"code","c010eb54":"code","cd403213":"code","f400932a":"code","1713f85c":"code","4a3ed26c":"code","18f6bb9a":"code","56391d18":"code","005d5511":"code","812f091c":"code","7e9e8a8f":"code","d6041fbb":"code","a98aa946":"code","7e1594cf":"code","282126ca":"code","5503948c":"code","9421afb8":"code","ecf131fd":"code","eda4a75a":"code","ec1a061e":"code","90d536b9":"code","f3a0ff18":"code","89a1712a":"code","5b8c4f0d":"code","365c8e65":"code","80424b09":"code","65607c3f":"code","22e49410":"code","e194cc39":"code","7a65c993":"markdown","9fb37040":"markdown","8bec2024":"markdown","72381904":"markdown","fff629b6":"markdown","841965d2":"markdown","a419bff3":"markdown","196e0b7d":"markdown","340a01b3":"markdown","339708f6":"markdown","a60bc182":"markdown","5da6086c":"markdown","37e32732":"markdown","7f0fb4ff":"markdown","c4b8b8d7":"markdown","e2971d17":"markdown","28a2ebb9":"markdown","05bb3836":"markdown","d4e29e43":"markdown","ce46aaea":"markdown","6ce842c4":"markdown","ebccf87c":"markdown","a43cbf82":"markdown","1ce0c586":"markdown","bfd4b6fa":"markdown","2b751acc":"markdown","20e5e229":"markdown","84f8c531":"markdown","8da7268a":"markdown","c067a80f":"markdown","99b02317":"markdown","38cf848d":"markdown","fed031fe":"markdown","d1a61e12":"markdown","65e86c9b":"markdown","0c622dae":"markdown","9c396e81":"markdown"},"source":{"f4b69f36":"import os, warnings, random\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import train_test_split\nimport tensorflow as tf\nimport tensorflow.keras.layers as L\nfrom tensorflow.keras import optimizers, Sequential, Model\n\n# Set seeds to make the experiment more reproducible.\ndef seed_everything(seed=0):\n    random.seed(seed)\n    np.random.seed(seed)\n    tf.random.set_seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    os.environ['TF_DETERMINISTIC_OPS'] = '1'\n\nseed = 0\nseed_everything(seed)\nwarnings.filterwarnings('ignore')\npd.set_option('display.float_format', lambda x: '%.2f' % x)","05ac38b3":"test = pd.read_csv('..\/input\/test.csv', dtype={'ID': 'int32', 'shop_id': 'int32', \n                                                  'item_id': 'int32'})\nitem_categories = pd.read_csv('..\/input\/item_categories.csv', \n                              dtype={'item_category_name': 'str', 'item_category_id': 'int32'})\nitems = pd.read_csv('..\/input\/items.csv', dtype={'item_name': 'str', 'item_id': 'int32', \n                                                 'item_category_id': 'int32'})\nshops = pd.read_csv('..\/input\/shops.csv', dtype={'shop_name': 'str', 'shop_id': 'int32'})\nsales = pd.read_csv('..\/input\/sales_train.csv', parse_dates=['date'], \n                    dtype={'date': 'str', 'date_block_num': 'int32', 'shop_id': 'int32', \n                      'item_id': 'int32', 'item_price': 'float32', 'item_cnt_day': 'int32'})","1a586261":"train = sales.join(items, on='item_id', rsuffix='_').join(shops, on='shop_id', rsuffix='_').join(item_categories, on='item_category_id', rsuffix='_').drop(['item_id_', 'shop_id_', 'item_category_id_'], axis=1)","563c55ec":"print(f'Train rows: {train.shape[0]}')\nprint(f'Train columns: {train.shape[1]}')\n\ndisplay(train.head().T)\ndisplay(train.describe())","f3449bf2":"print(f\"Min date from train set: {train['date'].min().date()}\")\nprint(f\"Max date from train set: {train['date'].max().date()}\")","b322d249":"test_shop_ids = test['shop_id'].unique()\ntest_item_ids = test['item_id'].unique()\n# Only shops that exist in test set.\ntrain = train[train['shop_id'].isin(test_shop_ids)]\n# Only items that exist in test set.\ntrain = train[train['item_id'].isin(test_item_ids)]","ac46de40":"train_monthly = train[['date', 'date_block_num', 'shop_id', 'item_id', 'item_cnt_day']]\ntrain_monthly = train_monthly.sort_values('date').groupby(['date_block_num', 'shop_id', 'item_id'], as_index=False)\ntrain_monthly = train_monthly.agg({'item_cnt_day':['sum']})\ntrain_monthly.columns = ['date_block_num', 'shop_id', 'item_id', 'item_cnt']\ntrain_monthly = train_monthly.query('item_cnt >= 0 and item_cnt <= 20')\n# Label\ntrain_monthly['item_cnt_month'] = train_monthly.sort_values('date_block_num').groupby(['shop_id', 'item_id'])['item_cnt'].shift(-1)\n\ndisplay(train_monthly.head(10).T)\ndisplay(train_monthly.describe().T)","87af9dd5":"monthly_series = train_monthly.pivot_table(index=['shop_id', 'item_id'], columns='date_block_num',values='item_cnt', fill_value=0).reset_index()\nmonthly_series.head()","bdf7d0a0":"first_month = 20\nlast_month = 33\nserie_size = 12\ndata_series = []\n\nfor index, row in monthly_series.iterrows():\n    for month1 in range((last_month - (first_month + serie_size)) + 1):\n        serie = [row['shop_id'], row['item_id']]\n        for month2 in range(serie_size + 1):\n            serie.append(row[month1 + first_month + month2])\n        data_series.append(serie)\n\ncolumns = ['shop_id', 'item_id']\n[columns.append(i) for i in range(serie_size)]\ncolumns.append('label')\n\ndata_series = pd.DataFrame(data_series, columns=columns)\ndata_series.head()","ea7e5d4d":"data_series = data_series.drop(['item_id', 'shop_id'], axis=1)","fde7e478":"labels = data_series['label']\ndata_series.drop('label', axis=1, inplace=True)\ntrain, valid, Y_train, Y_valid = train_test_split(data_series, labels.values, test_size=0.10, random_state=0)","b41959bc":"print(\"Train set\", train.shape)\nprint(\"Validation set\", valid.shape)\ntrain.head()","c010eb54":"X_train = train.values.reshape((train.shape[0], train.shape[1], 1))\nX_valid = valid.values.reshape((valid.shape[0], valid.shape[1], 1))\n\nprint(\"Train set reshaped\", X_train.shape)\nprint(\"Validation set reshaped\", X_valid.shape)","cd403213":"serie_size =  X_train.shape[1] # 12\nn_features =  X_train.shape[2] # 1\n\nepochs = 20\nbatch = 128\nlr = 0.0001\n\nlstm_model = Sequential()\nlstm_model.add(L.LSTM(10, input_shape=(serie_size, n_features), return_sequences=True))\nlstm_model.add(L.LSTM(6, activation='relu', return_sequences=True))\nlstm_model.add(L.LSTM(1, activation='relu'))\nlstm_model.add(L.Dense(10, kernel_initializer='glorot_normal', activation='relu'))\nlstm_model.add(L.Dense(10, kernel_initializer='glorot_normal', activation='relu'))\nlstm_model.add(L.Dense(1))\nlstm_model.summary()\n\nadam = optimizers.Adam(lr)\nlstm_model.compile(loss='mse', optimizer=adam)","f400932a":"lstm_history = lstm_model.fit(X_train, Y_train, \n                              validation_data=(X_valid, Y_valid), \n                              batch_size=batch, \n                              epochs=epochs, \n                              verbose=2)","1713f85c":"encoder_decoder = Sequential()\nencoder_decoder.add(L.LSTM(serie_size, activation='relu', input_shape=(serie_size, n_features), return_sequences=True))\nencoder_decoder.add(L.LSTM(6, activation='relu', return_sequences=True))\nencoder_decoder.add(L.LSTM(1, activation='relu'))\nencoder_decoder.add(L.RepeatVector(serie_size))\nencoder_decoder.add(L.LSTM(serie_size, activation='relu', return_sequences=True))\nencoder_decoder.add(L.LSTM(6, activation='relu', return_sequences=True))\nencoder_decoder.add(L.TimeDistributed(L.Dense(1)))\nencoder_decoder.summary()\n\nadam = optimizers.Adam(lr)\nencoder_decoder.compile(loss='mse', optimizer=adam)","4a3ed26c":"encoder_decoder_history = encoder_decoder.fit(X_train, X_train, \n                                              batch_size=batch, \n                                              epochs=epochs, \n                                              verbose=2)","18f6bb9a":"rpt_vector_layer = Model(inputs=encoder_decoder.inputs, outputs=encoder_decoder.layers[3].output)\ntime_dist_layer = Model(inputs=encoder_decoder.inputs, outputs=encoder_decoder.layers[5].output)\nencoder_decoder.layers","56391d18":"rpt_vector_layer_output = rpt_vector_layer.predict(X_train[:1])\nprint('Repeat vector output shape', rpt_vector_layer_output.shape)\nprint('Repeat vector output sample')\nprint(rpt_vector_layer_output[0])","005d5511":"time_dist_layer_output = time_dist_layer.predict(X_train[:1])\nprint('Time distributed output shape', time_dist_layer_output.shape)\nprint('Time distributed output sample')\nprint(time_dist_layer_output[0])","812f091c":"encoder = Model(inputs=encoder_decoder.inputs, outputs=encoder_decoder.layers[2].output)","7e9e8a8f":"train_encoded = encoder.predict(X_train)\nvalidation_encoded = encoder.predict(X_valid)\nprint('Encoded time-series shape', train_encoded.shape)\nprint('Encoded time-series sample', train_encoded[0])","d6041fbb":"train['encoded'] = train_encoded\ntrain['label'] = Y_train\n\nvalid['encoded'] = validation_encoded\nvalid['label'] = Y_valid\n\ntrain.head(10)","a98aa946":"last_month = serie_size - 1\nY_train_encoded = train['label']\ntrain.drop('label', axis=1, inplace=True)\nX_train_encoded = train[[last_month, 'encoded']]\n\nY_valid_encoded = valid['label']\nvalid.drop('label', axis=1, inplace=True)\nX_valid_encoded = valid[[last_month, 'encoded']]\n\nprint(\"Train set\", X_train_encoded.shape)\nprint(\"Validation set\", X_valid_encoded.shape)","7e1594cf":"X_train_encoded.head()","282126ca":"mlp_model = Sequential()\nmlp_model.add(L.Dense(10, kernel_initializer='glorot_normal', activation='relu', input_dim=X_train_encoded.shape[1]))\nmlp_model.add(L.Dense(10, kernel_initializer='glorot_normal', activation='relu'))\nmlp_model.add(L.Dense(1))\nmlp_model.summary()\n\nadam = optimizers.Adam(lr)\nmlp_model.compile(loss='mse', optimizer=adam)","5503948c":"mlp_history = mlp_model.fit(X_train_encoded.values, Y_train_encoded.values, epochs=epochs, batch_size=batch, validation_data=(X_valid_encoded, Y_valid_encoded), verbose=2)","9421afb8":"fig, (ax1, ax2) = plt.subplots(1, 2, sharey=True,figsize=(22,7))\n\nax1.plot(lstm_history.history['loss'], label='Train loss')\nax1.plot(lstm_history.history['val_loss'], label='Validation loss')\nax1.legend(loc='best')\nax1.set_title('Regular LSTM')\nax1.set_xlabel('Epochs')\nax1.set_ylabel('MSE')\n\nax2.plot(mlp_history.history['loss'], label='Train loss')\nax2.plot(mlp_history.history['val_loss'], label='Validation loss')\nax2.legend(loc='best')\nax2.set_title('MLP with LSTM encoder')\nax2.set_xlabel('Epochs')\nax2.set_ylabel('MSE')\n\nplt.show()","ecf131fd":"lstm_train_pred = lstm_model.predict(X_train)\nlstm_val_pred = lstm_model.predict(X_valid)\nprint('Train rmse:', np.sqrt(mean_squared_error(Y_train, lstm_train_pred)))\nprint('Validation rmse:', np.sqrt(mean_squared_error(Y_valid, lstm_val_pred)))","eda4a75a":"mlp_train_pred2 = mlp_model.predict(X_train_encoded.values)\nmlp_val_pred2 = mlp_model.predict(X_valid_encoded.values)\nprint('Train rmse:', np.sqrt(mean_squared_error(Y_train_encoded, mlp_train_pred2)))\nprint('Validation rmse:', np.sqrt(mean_squared_error(Y_valid_encoded, mlp_val_pred2)))","ec1a061e":"latest_records = monthly_series.drop_duplicates(subset=['shop_id', 'item_id'])\nX_test = pd.merge(test, latest_records, on=['shop_id', 'item_id'], how='left', suffixes=['', '_'])\nX_test.fillna(0, inplace=True)\nX_test.drop(['ID', 'item_id', 'shop_id'], axis=1, inplace=True)\nX_test.head()","90d536b9":"X_test = X_test[[(i + (34 - serie_size)) for i in range(serie_size)]]\nX_test.head()","f3a0ff18":"X_test_reshaped = X_test.values.reshape((X_test.shape[0], X_test.shape[1], 1))\nprint(X_test_reshaped.shape)","89a1712a":"lstm_test_pred = lstm_model.predict(X_test_reshaped)","5b8c4f0d":"test_encoded = encoder.predict(X_test_reshaped)","365c8e65":"X_test['encoded'] = test_encoded\nX_test.head()","80424b09":"X_test_encoded = X_test[[33, 'encoded']]\nprint(\"Train set\", X_test_encoded.shape)\nX_test_encoded.head()","65607c3f":"mlp_test_pred = mlp_model.predict(X_test_encoded)","22e49410":"lstm_prediction = pd.DataFrame(test['ID'], columns=['ID'])\nlstm_prediction['item_cnt_month'] = lstm_test_pred.clip(0., 20.)\nlstm_prediction.to_csv('lstm_submission.csv', index=False)\nlstm_prediction.head(10)","e194cc39":"mlp_prediction = pd.DataFrame(test['ID'], columns=['ID'])\nmlp_prediction['item_cnt_month'] = mlp_test_pred.clip(0., 20.)\nmlp_prediction.to_csv('mlp_submission.csv', index=False)\nmlp_prediction.head(10)","7a65c993":"[Another good explanation about the used layers](https:\/\/machinelearningmastery.com\/encoder-decoder-long-short-term-memory-networks\/)","9fb37040":"As you can see this is just the same value repeated some times to match the same shape of the model input.\n\n#### TimeDistributed layer\n* This layer is more common, sometimes is used when you want to mix RNN layers with other kind of layers.\n* We could output the model with another LSTM layer with one neuron and \"return_sequences=True\" parameter, but using a \"TimeDistributed\" layer wrapping a \"Dense\" layer we will have the same weights for each outputted time-step.","8bec2024":"#### You should be aware that the better the autoencoder is able to reconstruct the input the better it internally encodes the input, in other words if we have a good autoencoder we probably will have an equally good encoder.\n#### Let's take a look at the layers of the encoder_decoder model:","72381904":"#### Add encoded features to the test set.","fff629b6":"#### Defining the encoding model.\n* What I want is to encode the whole series into a single value, so I need the output from the layer with a single neuron (in this case it's the third LSTM layer).\n* I'll take only the encoding part of the model and define it as a new one.","841965d2":"#### Now let's encode the train and validation time-series.","a419bff3":"# Data preprocessing\n* I'm dropping all features but \"item_cnt_day\" because I'll be using only it as a univariate time-series.\n* We are asked to predict total sales for every product and store in the next month, and our data is given by day, so let's aggregate the data by month.\n* Also I'm leaving only monthly \"item_cnt\" >= 0 and <= 20, as this seems to be the distributions of the test set.","196e0b7d":"#### Predictions from the MLP model with LSTM encodded feature .","340a01b3":"### Build test set\n#### Since we have two models I'll build test sets to apply on both of them.","339708f6":"# Time-series processing\n* As I only need the \"item_cnt\" feature as a series, I can get that easily by just using a pivot operation.\n* This way I'll also get the missing months from each \"shop_id\" and \"item_id\", and then replace them with 0 (otherwise would be \"nan\"). ","a60bc182":"#### Dropping identifier columns as we don't need them anymore.","5da6086c":"#### About the autoencoder layers\n#### LSTM\n* This is just a regular LSTM layer, a layer that is able to receive sequence data and learn based on it nothing much to talk about.","37e32732":"<h2><center>Predict future sales<\/center><\/h2>\n\nWe are asking you to predict total sales for every product and store in the next month. By solving this competition you will be able to apply and enhance your data science skills.\n\nYou are provided with daily historical sales data. The task is to forecast the total amount of products sold in every shop for the test set. Note that the list of shops and products slightly changes every month. Creating a robust model that can handle such situations is part of the challenge.\n\n#### Data fields description:\n* ID - an Id that represents a (Shop, Item) tuple within the test set\n* shop_id - unique identifier of a shop\n* item_id - unique identifier of a product\n* item_category_id - unique identifier of item category\n* date_block_num - a consecutive month number, used for convenience. January 2013 is 0, February 2013 is 1,..., October 2015 is 33\n* date - date in format dd\/mm\/yyyy\n* item_cnt_day - number of products sold. You are predicting a monthly amount of this measure\n* item_price - current price of an item\n* item_name - name of item\n* shop_name - name of shop\n* item_category_name - name of item category\n\n### Dependencies","7f0fb4ff":" ### MLP with LSTM encoded feature test predictions\n* For the MLP model with the encoded features I'm only using the current month \"item_count\" and the encoded time-series feature from our LSTM encoder model.\n\n#### Encoding the time-series","c4b8b8d7":"#### Predictions from the regular LSTM model.","e2971d17":"#### Currently I have one series (33 months) for each unique pair of \"shop_id\" and \"item_id\", but probably would be better to have multiple smaller series for each unique pair, so I'm generating multiple series of size 12 (one year) for each unique pair.","28a2ebb9":"#### Making predictions.","05bb3836":"### Let's take a look at the raw data","d4e29e43":"### Regular LSTM model test predictions\n* For the regular LSTM model we just need the last 12 months, because that's our series input size.","ce46aaea":"#### Now we can use the new encoded feature that is a representation of the whole time-series and train a \"less complex\" model that does not receives sequenced data as input.\n\n# MLP with LSTM encoded feature\n* For the MLP model I'm only using the current month \"item_count\" and the encoded time-series feature from our LSTM encoder model, the idea is that we won't need the whole series because we already have a column that represents the whole series into a single value (it's like a dimensionality reduction).","6ce842c4":"### Loading data","ebccf87c":"### Train and validation sets.","a43cbf82":"#### RepeatVector layer\n* Here is something we don't usually see, this layers basically repeats it's input \"n\" times, the reason to use it is because the last layers from the encoder part (the layer with one neuron) don't return sequences, so it does not outputs a sequenced data, this way we can't just add another LSTM layer after it, we need a way to turn this output into a sequence of the same time-steps of the model input, this is where \"RepeatVector\" layers comes in.\n* Let's see what it outputs.","1ce0c586":"#### Add new encoded features to the train and validation sets.","bfd4b6fa":"#### MLP with LSTM encoder on train and validation.","2b751acc":"### Reshape data.\n* Time-series shape **(data points, time-steps, features)**.","20e5e229":"### Join data sets","84f8c531":"#### First let's begin with how a regular RNN time-series approach could be.\n\n# Regular LSTM model.","8da7268a":"# Autoencoder\n* Now we will build an autoencoder to learn how to reconstruct the input, this way it internally learns the best way to represent the input in lower dimensions.\n* The reconstruct model is composed of an encoder and a decoder, the encoder is responsible for learning how to represent the input into lower dimensions and the decoder learns how to rebuild the smaller representations into the input again.\n* Here is a structural representations of an autoencoder:\n <img src=\"https:\/\/raw.githubusercontent.com\/dimitreOliveira\/MachineLearning\/master\/Kaggle\/Predict%20Future%20Sales\/Autoencoder_structure.png\" width=\"400\">\n* After the models is trained we can keep only the encoder part and we'll have a model that is able to do what we want.\n\n### LSTM Autoencoder.","c067a80f":"#### Regular LSTM on train and validation.","99b02317":"# Comparing models\n* As you can see I tried to build both models with a similar topology (type\/number of layers and neurons), so it could make more sense to compare them.\n* The results are pretty close, also they may change a bit depending on the random initialization of the networks weights, so I would say they are very similar in terms of performance.\n\n#### Model training","38cf848d":"<h1><center>Time-series forecasting with deep learning & LSTM autoencoders<\/center><\/h1>\n\n* The purpose of this work is to show one way time-series data can be effiently encoded to lower dimensions, to be used into non time-series models.\n* Here I'll encode a time-series of size 12 (12 months) to a single value and use it on a MLP deep learning model, instead of using the time-series on a LSTM model that could be the regular approach.\n* The first part of the data preparation is from my other kernel [Model stacking, feature engineering and EDA](https:\/\/www.kaggle.com\/dimitreoliveira\/model-stacking-feature-engineering-and-eda).\n* This work was inspired by this Machinelearningmastery post [A Gentle Introduction to LSTM Autoencoders](https:\/\/machinelearningmastery.com\/lstm-autoencoders\/), make sure to check out.","fed031fe":"#### Making predictions.","d1a61e12":"### Time period of the dataset","65e86c9b":"I'm leaving only the \"shop_id\" and \"item_id\" that exist in the test set to have more accurate results.","0c622dae":"### Reshape data.\n* Time-series shape **(data points, time-steps, features)**.","9c396e81":"Just a disclaimer, you absolutely can get better results on any of the used models,  I did not spent too much time tuning the models hyper parameters, as this is just for demonstration purpose, so if you want to give the code a try, you should surely tune a little more, if you get better results or any good insight about the models or architecture please let me know.\n\nIf you want to check out some interesting different approaches on time series problems take a look at this kernel [Deep Learning for Time Series Forecasting](https:\/\/www.kaggle.com\/dimitreoliveira\/deep-learning-for-time-series-forecasting)."}}