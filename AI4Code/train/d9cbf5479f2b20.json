{"cell_type":{"50ea9515":"code","4aef2e9c":"markdown"},"source":{"50ea9515":"# EL Assignment 2\n#Create a full python code implementing all necessary functions for an B-Tree\n#Turn in the code and an self created example.\n\nclass BTreeNode:\n    def __init__(self, leaf=False):\n        self.keys = []\n        self.child = []\n        self.leaf = leaf\n\n\nclass BTree:\n    def __init__(self, t):\n        self.root = BTreeNode(True)\n        self.t = t\n\n    # Insert key\n    def insert(self, k):\n        root = self.root\n        # node is full, split\n        if len(root.keys) == 2 * self.t - 1:\n            temp = BTreeNode()\n            self.root = temp\n            temp.child.insert(0, root)\n            self.splitchild(temp, 0)\n            self.insert_non_full(temp, k)\n\n        # node is not full, just insert\n        else:\n            self.insert_non_full(root, k)\n\n    def insert_non_full(self, tnode, k):\n        i = len(tnode.keys) - 1\n        if tnode.leaf:\n            tnode.keys.append((None, None))\n            while i >= 0 and k[0] < tnode.keys[i][0]:\n                tnode.keys[i + 1] = tnode.keys[i]\n                i -= 1\n            tnode.keys[i + 1] = k\n\n        else:\n            while i >= 0 and k[0] < tnode.keys[i][0]:\n                i -= 1\n            i += 1\n            if len(tnode.child[i].keys) == (2 * self.t) - 1:\n                self.splitchild(tnode, i)\n                if k[0] > tnode.keys[i][0]:\n                    i += 1\n            self.insert_non_full(tnode.child[i], k)\n\n    # Split child\n    def splitchild(self, tnode, i):\n        t = self.t\n        y = tnode.child[i]\n        x = BTreeNode(y.leaf)\n        tnode.child.insert(i + 1, x)\n        tnode.keys.insert(i, y.keys[t - 1])\n        x.keys = y.keys[t: (2 * t) - 1]\n        y.keys = y.keys[0: t - 1]\n        if not y.leaf:\n            x.child = y.child[t: 2 * t]\n            y.child = y.child[0: t - 1]\n\n        # Delete the predecessor\n    def deletebefore(self, tnode):\n        if tnode.leaf:\n            return tnode.pop()\n        n = len(tnode.keys) - 1\n        if len(tnode.child[n].keys) >= self.t:\n            self.deletesibling(tnode, n + 1, n)\n        else:\n            self.deletemerge(tnode, n, n + 1)\n        self.deleteafter(tnode.child[n])\n\n    def deleteafter(self, tnode):\n        if tnode.leaf:\n            return tnode.keys.pop(0)\n        if len(tnode.child[1].keys) >= self.t:\n            self.deletesibling(tnode, 0, 1)\n        else:\n            self.deletemerge(tnode, 0, 1)\n        self.deleteafter(tnode.child[0])\n\n    def deleteint(self, tnode, k, i):\n        t = self.t\n        if tnode.leaf:\n            if tnode.keys[i][0] == k[0]:\n                tnode.keys.pop(i)\n                return\n            return\n\n        if len(tnode.child[i].keys) >= t:\n            tnode.keys[i] = self.deletebefore(tnode.child[i])\n            return\n        elif len(tnode.child[i + 1].keys) >= t:\n            tnode.keys[i] = self.deleteafter(tnode.child[i + 1])\n            return\n        else:\n            self.deletemerge(tnode, i, i + 1)\n            self.deleteint(tnode.child[i], k, self.t - 1)\n\n    def deletesibling(self, tnode, i, j):\n        cnode = tnode.child[i]\n        if i < j:\n            rnode = tnode.child[j]\n            cnode.keys.append(tnode.keys[i])\n            tnode.keys[i] = rnode.keys[0]\n            if len(rnode.child) > 0:\n                cnode.child.append(rnode.child[0])\n                rnode.child.pop(0)\n            rnode.keys.pop(0)\n        else:\n            lnode = tnode.child[j]\n            cnode.keys.insert(0, tnode.keys[i - 1])\n            tnode.keys[i - 1] = lnode.keys.pop()\n            if len(lnode.child) > 0:\n                cnode.child.insert(0, lnode.child.pop())\n\n    def deletemerge(self, tnode, i, j):\n        cnode = tnode.child[i]\n\n        if j > i:\n            rnode = tnode.child[j]\n            cnode.keys.append(tnode.keys[i])\n            for k in range(len(rnode.keys)):\n                cnode.keys.append(rnode.keys[k])\n                if len(rnode.child) > 0:\n                    cnode.child.append(rnode.child[k])\n            if len(rnode.child) > 0:\n                cnode.child.append(rnode.child.pop())\n            n = cnode\n            tnode.keys.pop(i)\n            tnode.child.pop(j)\n        else:\n            lnode = tnode.child[j]\n            lnode.keys.append(tnode.keys[j])\n            for i in range(len(cnode.keys)):\n                lnode.keys.append(cnode.keys[i])\n                if len(lnode.child) > 0:\n                    lnode.child.append(cnode.child[i])\n            if len(lnode.child) > 0:\n                lnode.child.append(cnode.child.pop())\n            n = lnode\n            tnode.keys.pop(j)\n            tnode.child.pop(i)\n\n        if tnode == self.root and len(tnode.keys) == 0:\n            self.root = n\n\n    def delete(self, tnode, k):\n        t = self.t\n        i = 0\n        while i < len(tnode.keys) and k[0] > tnode.keys[i][0]:\n            i += 1\n        if tnode.leaf:\n            if i < len(tnode.keys) and tnode.keys[i][0] == k[0]:\n                tnode.keys.pop(i)\n                return\n            return\n\n        if i < len(tnode.keys) and tnode.keys[i][0] == k[0]:\n            return self.deleteint(tnode, k, i)\n        elif len(tnode.child[i].keys) >= t:\n            self.delete(tnode.child[i], k)\n        else:\n            if i != 0 and i + 2 < len(tnode.child):\n                if len(tnode.child[i - 1].keys) >= t:\n                    self.deletesibling(tnode, i, i - 1)\n                elif len(tnode.child[i + 1].keys) >= t:\n                    self.deletesibling(tnode, i, i + 1)\n                else:\n                    self.deletemerge(tnode, i, i + 1)\n            elif i == 0:\n                if len(tnode.child[i + 1].keys) >= t:\n                    self.deletesibling(tnode, i, i + 1)\n                else:\n                    self.deletemerge(tnode, i, i + 1)\n            elif i + 1 == len(tnode.child):\n                if len(tnode.child[i - 1].keys) >= t:\n                    self.deletesibling(tnode, i, i - 1)\n                else:\n                    self.deletemerge(tnode, i, i - 1)\n            self.delete(tnode.child[i], k)\n\n    def print_tree(self, tnode, k=0):\n        print(k, \" \", \"length:\", len(tnode.keys), end=\", \")\n        for i in tnode.keys:\n            print(i, end=\" \")\n        print()\n        k += 1\n        if len(tnode.child) > 0:\n            for i in tnode.child:\n                self.print_tree(i, k)\n\nTree = BTree(4)\n\nfor i in range(15):\n    Tree.insert((i, 2 * i))\n\nprint(\"Tree: \")\nTree.print_tree(Tree.root)\nTree.delete(Tree.root, (10,))\nprint(\"\")\nprint(\"Deleting 10: \")\nTree.print_tree(Tree.root)","4aef2e9c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session"}}