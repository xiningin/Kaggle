{"cell_type":{"3bd48c87":"code","3e1ffd6d":"code","357c3219":"code","de1b07f2":"code","4396709b":"markdown"},"source":{"3bd48c87":"import torch\nfrom engine import train_one_epoch, evaluate\nimport utils\nimport transforms as T\nimport torchvision\nfrom torchvision.models.detection.faster_rcnn import FastRCNNPredictor\nimport torch.utils.data\nfrom PIL import Image, ImageFile\nimport pandas as pd\nfrom tqdm import tqdm\n\nImageFile.LOAD_TRUNCATED_IMAGES = True","3e1ffd6d":"def _get_instance_segmentation_model(num_classes):\n    model = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)\n    in_features = model.roi_heads.box_predictor.cls_score.in_features\n    model.roi_heads.box_predictor = FastRCNNPredictor(in_features, num_classes)\n    return model","357c3219":"import collections\nimport os\nimport numpy as np\n\n\nclass OpenDataset(torch.utils.data.Dataset):\n    def __init__(self, image_dir, df_path, height, width, transforms=None):\n        self.transforms = transforms\n        self.image_dir = image_dir\n        self.df = pd.read_csv(df_path)\n        self.height = height\n        self.width = width\n        self.image_info = collections.defaultdict(dict)\n        \n        # Filling up image_info is left as an exercise to the reader\n        \n\n    def __getitem__(self, idx):\n        # load images ad masks\n        img_path = self.image_info[idx][\"image_path\"]\n        img = Image.open(img_path).convert(\"RGB\")\n        img = img.resize((self.width, self.height), resample=Image.BILINEAR)\n        \n        # processing part and extraction of boxes is left as an exercise to the reader\n\n        target = {}\n        target[\"boxes\"] = boxes\n        target[\"labels\"] = labels\n        target[\"image_id\"] = image_id\n        target[\"area\"] = area\n        target[\"iscrowd\"] = iscrowd\n\n        if self.transforms is not None:\n            img, target = self.transforms(img, target)\n\n        return img, target\n\n    def __len__(self):\n        return len(self.image_info)","de1b07f2":"num_classes = # define number of classes here\ndevice = torch.device('cuda:0')\n\ndataset_train = OpenDataset(\"..\/input\/train\/\", \"..\/input\/train.csv\", 128, 128, transforms=None)\n\nmodel_ft = get_instance_segmentation_model(num_classes)\nmodel_ft.to(device)\n\ndata_loader = torch.utils.data.DataLoader(\n    dataset_train, batch_size=4, shuffle=True, num_workers=8,\n    collate_fn=utils.collate_fn)\n\nparams = [p for p in model_ft.parameters() if p.requires_grad]\noptimizer = torch.optim.SGD(params, lr=0.005,\n                            momentum=0.9, weight_decay=0.0005)\nlr_scheduler = torch.optim.lr_scheduler.StepLR(optimizer,\n                                               step_size=5,\n                                               gamma=0.1)\nnum_epochs = 8\nfor epoch in range(num_epochs):\n    train_one_epoch(model_ft, optimizer, data_loader, device, epoch, print_freq=10)\n    lr_scheduler.step()\n\ntorch.save(model_ft.state_dict(), \"model.bin\")","4396709b":"#### I have left certain parts as exercise to the reader. This model is quite fast and should give good results if used properly. In case of any questions, feel free to ask. Upvotes are appreciated if this helps you."}}