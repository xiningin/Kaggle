{"cell_type":{"fcfb200e":"code","dbdfe4d3":"code","16b62fa1":"code","40b220fa":"code","4c4712e1":"code","46f74f57":"code","9e864498":"code","0e209731":"code","d526bb4a":"code","a6def9b5":"code","58499c21":"code","638a4c05":"code","476de004":"code","79cc0eeb":"code","8d9c1405":"code","25f665b3":"code","3bb2c4fc":"code","667dff25":"code","04622cf2":"code","91b1ac0a":"code","367d5b0f":"code","885443f6":"code","e4655a6a":"code","ba8fd6de":"code","1a871277":"code","0d7b7f97":"code","5bf66a6a":"code","448fa5eb":"code","6914a09f":"code","ed8bd1b5":"code","9e7f1d67":"code","a8cb6d6d":"code","7311e7a3":"code","0e9ac2dd":"code","50244801":"code","bcb94fe8":"code","bef419bb":"code","f73306e4":"code","f82f9783":"markdown","7d6a25b9":"markdown","b93a121b":"markdown","7539c60b":"markdown","ece68265":"markdown","246f29c9":"markdown","d2933b07":"markdown","caa2507e":"markdown","fa614b4f":"markdown","87847374":"markdown","b107a2c2":"markdown","91b0394c":"markdown","2cd357f4":"markdown","adb48c17":"markdown","8bc9d42c":"markdown","e8977092":"markdown","eb536779":"markdown","3102dcdf":"markdown","7636c5b0":"markdown","9e0215e0":"markdown","86eeeb44":"markdown","65b4cd97":"markdown","374e4464":"markdown","3fdc3fa3":"markdown","008d3f7e":"markdown"},"source":{"fcfb200e":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt # plotting\nimport numpy as np # linear algebra\nimport os # accessing directory structure\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n","dbdfe4d3":"print(os.listdir('..\/input'))","16b62fa1":"nRowsRead = 1000 # specify 'None' if want to read whole file\n# innercity.csv has 21613 rows in reality, but we are only loading\/previewing the first 1000 rows\ndf1 = pd.read_csv('..\/input\/innercity.csv', delimiter=',', nrows = nRowsRead)\ndf1.dataframeName = 'innercity.csv'\nnRow, nCol = df1.shape\nprint(f'There are {nRow} rows and {nCol} columns')","40b220fa":"df1.head(5)","4c4712e1":"df1.info()","46f74f57":"df1.columns","9e864498":"df1.dtypes","0e209731":"df1.isnull().any()","d526bb4a":"df1.isna().sum()","a6def9b5":"df1.duplicated().sum()","58499c21":"df1.describe(include='all').T","638a4c05":"# Distribution graphs (histogram\/bar graph) of column data\ndef plotPerColumnDistribution(df, nGraphShown, nGraphPerRow):\n    nunique = df.nunique()\n    df = df[[col for col in df if nunique[col] > 1 and nunique[col] < 50]] # For displaying purposes, pick columns that have between 1 and 50 unique values\n    nRow, nCol = df.shape\n    columnNames = list(df)\n    nGraphRow = (nCol + nGraphPerRow - 1) \/ nGraphPerRow\n    plt.figure(num = None, figsize = (6 * nGraphPerRow, 8 * nGraphRow), dpi = 80, facecolor = 'w', edgecolor = 'k')\n    for i in range(min(nCol, nGraphShown)):\n        plt.subplot(nGraphRow, nGraphPerRow, i + 1)\n        columnDf = df.iloc[:, i]\n        if (not np.issubdtype(type(columnDf.iloc[0]), np.number)):\n            valueCounts = columnDf.value_counts()\n            valueCounts.plot.bar()\n        else:\n            columnDf.hist()\n        plt.ylabel('counts')\n        plt.xticks(rotation = 90)\n        plt.title(f'{columnNames[i]} (column {i})')\n    plt.tight_layout(pad = 1.0, w_pad = 1.0, h_pad = 1.0)\n    plt.show()\n","476de004":"df1.corr()","79cc0eeb":"#PEARSON CORRELATION\n\nplt.figure(figsize = (15,10))\nsns.heatmap(df1.corr(method=\"pearson\"))\nplt.title('PEARSON CORRELATION', fontsize=15)","8d9c1405":"#SPEARMAN CORRELATION\n\nplt.figure(figsize = (15,10))\nsns.heatmap(df1.corr(method=\"spearman\"))\nplt.title('SPEARMAN CORRELATION', fontsize=15)","25f665b3":"#KENDALL CORRELATION\n\nplt.figure(figsize = (15,10))\nsns.heatmap(df1.corr(method=\"kendall\"))\nplt.title('KENDALL CORRELATION', fontsize=15)","3bb2c4fc":"# Correlation matrix\ndef plotCorrelationMatrix(df, graphWidth):\n    filename = df.dataframeName\n    df = df.dropna('columns') # drop columns with NaN\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    if df.shape[1] < 2:\n        print(f'No correlation plots shown: The number of non-NaN or constant columns ({df.shape[1]}) is less than 2')\n        return\n    corr = df.corr()\n    plt.figure(num=None, figsize=(graphWidth, graphWidth), dpi=80, facecolor='w', edgecolor='k')\n    corrMat = plt.matshow(corr, fignum = 1)\n    plt.xticks(range(len(corr.columns)), corr.columns, rotation=90)\n    plt.yticks(range(len(corr.columns)), corr.columns)\n    plt.gca().xaxis.tick_bottom()\n    plt.colorbar(corrMat)\n    plt.title(f'Correlation Matrix for {filename}', fontsize=15)\n    plt.show()\n","667dff25":"# Scatter and density plots\ndef plotScatterMatrix(df, plotSize, textSize):\n    df = df.select_dtypes(include =[np.number]) # keep only numerical columns\n    # Remove rows and columns that would lead to df being singular\n    df = df.dropna('columns')\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    columnNames = list(df)\n    if len(columnNames) > 10: # reduce the number of columns for matrix inversion of kernel density plots\n        columnNames = columnNames[:10]\n    df = df[columnNames]\n    ax = pd.plotting.scatter_matrix(df, alpha=0.75, figsize=[plotSize, plotSize], diagonal='kde')\n    corrs = df.corr().values\n    for i, j in zip(*plt.np.triu_indices_from(ax, k = 1)):\n        ax[i, j].annotate('Corr. coef = %.3f' % corrs[i, j], (0.8, 0.2), xycoords='axes fraction', ha='center', va='center', size=textSize)\n    plt.suptitle('Scatter and Density Plot')\n    plt.show()\n","04622cf2":"%matplotlib inline\nsns.boxplot(data=df1)","91b1ac0a":"%matplotlib inline\nplt.figure(figsize = (28,8))\nsns.boxplot(data=df1)","367d5b0f":"plotPerColumnDistribution(df1, 10, 5)","885443f6":"plotCorrelationMatrix(df1, 8)","e4655a6a":"plotScatterMatrix(df1, 20, 10)","ba8fd6de":"#missing data\ntotal = df1.isnull().sum().sort_values(ascending=False)\npercent = (df1.isnull().sum()\/df1.isnull().count()).sort_values(ascending=False)\nmissing_data = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])\nmissing_data.head(20)","1a871277":"print(pd.isnull(df1).any())","0d7b7f97":"df1[\"sold_year\"] = df1[\"dayhours\"].apply(lambda x:x.split('T')[0][:4])","5bf66a6a":"df1 = df1.drop(columns = 'cid')","448fa5eb":"df1 = df1.drop(columns = 'dayhours')","6914a09f":"df1.head()","ed8bd1b5":"df1.head()","9e7f1d67":"X = df1.drop(\"price\", axis=1)\nY = df1[\"price\"]\nprint(X.shape)\nprint(Y.shape)","a8cb6d6d":"from sklearn.preprocessing import StandardScaler, MinMaxScaler\nscaler = MinMaxScaler().fit(X)\nscaled_X = scaler.transform(X)","7311e7a3":"from sklearn.model_selection import train_test_split\n\nseed      = 42\ntest_size = 0.30\n\nX_train, X_test, Y_train, Y_test = train_test_split(scaled_X, Y, test_size = test_size, random_state = seed)\n\nprint(X_train.shape)\nprint(X_test.shape)\nprint(Y_train.shape)\nprint(Y_test.shape)","0e9ac2dd":"from sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.linear_model import Lasso\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import ElasticNet\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.ensemble import AdaBoostRegressor\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom xgboost import XGBRegressor\n\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import mean_absolute_error\n\n# user variables to tune\nfolds   = 10\nmetric  = \"neg_mean_absolute_error\"\n\n# hold different regression models in a single dictionary\nmodels = {}\nmodels[\"Linear\"]        = LinearRegression()\nmodels[\"Lasso\"]         = Lasso()\nmodels[\"Ridge\"]         = Ridge()\nmodels[\"ElasticNet\"]    = ElasticNet()\nmodels[\"DecisionTree\"]  = DecisionTreeRegressor()\nmodels[\"KNN\"]           = KNeighborsRegressor()\nmodels[\"RandomForest\"]  = RandomForestRegressor()\nmodels[\"AdaBoost\"]      = AdaBoostRegressor()\nmodels[\"GradientBoost\"] = GradientBoostingRegressor()\nmodels[\"XGBoost\"] = XGBRegressor()\n\n# 10-fold cross validation for each model\nmodel_results = []\nmodel_names   = []\nfor model_name in models:\n\tmodel   = models[model_name]\n\tk_fold  = KFold(n_splits=folds, random_state=seed)\n\tresults = cross_val_score(model, X_train, Y_train, cv=k_fold, scoring=metric)\n\t\n\tmodel_results.append(results)\n\tmodel_names.append(model_name)\n\tprint(\"{}: {}, {}\".format(model_name, round(results.mean(), 3), round(results.std(), 3)))\n\n# box-whisker plot to compare regression models\nfigure = plt.figure(figsize = (20,8))\n\nfigure.suptitle('Regression models comparison')\naxis = figure.add_subplot(111)\nplt.boxplot(model_results)\naxis.set_xticklabels(model_names, rotation = 45, ha=\"right\")\naxis.set_ylabel(\"Mean Absolute Error (MAE)\")\nplt.margins(0.05, 0.1)\n","50244801":"model = GradientBoostingRegressor()\nmodel.fit(X_train,Y_train)\n\n##print(\"Intercept : \", model.intercept_)\n##print(\"Slope : \", model.coef_)\n\n#Predicting TEST & TRAIN DATA\ntrain_predict = model.predict(X_train)\ntest_predict = model.predict(X_test)\n\nerror_percent = np.mean(np.abs((Y_train - train_predict) \/ Y_train)) * 100\nprint(\"MAPE - Mean Absolute Percentage Error (TRAIN DATA): \",error_percent )\nY_train, train_predict = np.array(Y_train), np.array(train_predict)","bcb94fe8":"model = GradientBoostingRegressor()\nmodel.fit(X_test,Y_test)\n\n##print(\"Intercept : \", model.intercept_)\n##print(\"Slope : \", model.coef_)\n\n#Predicting TEST & TRAIN DATA\ntrain_predict = model.predict(X_train)\ntest_predict = model.predict(X_test)\n\nerror_percent = np.mean(np.abs((Y_train - train_predict) \/ Y_train)) * 100\nprint(\"MAPE - Mean Absolute Percentage Error (TEST DATA): \",error_percent )\nY_train, train_predict = np.array(Y_train), np.array(train_predict)\n\n#print(\"Mape - Train:\" , np.mean(np.abs((Y_train,train_predict))))\n#print(\"Mape - Test:\" ,np.mean(np.abs((Y_test,test_predict))))\n","bef419bb":"# plot between predictions and Y_test\nx_axis = np.array(range(0, test_predict.shape[0]))\nplt.figure(figsize=(20,10))\nplt.plot(x_axis, test_predict, linestyle=\"--\", marker=\"o\", alpha=0.7, color='r', label=\"predictions\")\nplt.plot(x_axis, Y_test, linestyle=\"--\", marker=\"o\", alpha=0.7, color='g', label=\"Y_test\")\nplt.xlabel('Row number')\nplt.ylabel('PRICE')\nplt.title('Predictions vs Y_test')\nplt.legend(loc='lower right')","f73306e4":"feature_importance = model.feature_importances_\nfeature_importance = 100.0 * (feature_importance \/ feature_importance.max())\n\nsorted_idx = np.argsort(feature_importance)\npos        = np.arange(sorted_idx.shape[0]) + .5\n\nplt.figure(figsize = (15,18))\n\n#Make a horizontal bar plot.\nplt.barh(pos, feature_importance[sorted_idx], align='center')\nplt.yticks(pos, df1.columns[sorted_idx])\nplt.xlabel('Relative Importance')\nplt.title('Variable Importance')","f82f9783":"Now, we will split the data into train and test set. We can easily do this using scikit-learn\u2019s train_test_split() function using a test_size parameter.","7d6a25b9":"Distribution graphs (histogram\/bar graph) of sampled columns:","b93a121b":"describe() function will give out the statistical summary of the dataset. Using this function, we can understand the count, min, max, mean and standard deviation for each attribute (column) in the dataset. ","7539c60b":"## Problem statement:\n\nA house value is simply more than location and square footage. Like the features that make up a person, an educated party would want to know all aspects that give a house its value. For example, you want to sell a house and you don\u2019t know the price which you can take\u200a\u2014\u200ait can\u2019t be too low or too high. To find house price you usually try to find similar properties in your neighbourhood and based on gathered data you will try to assess your house price. ","ece68265":"We can visualize the predictions made by our best model and the original targets Y_test using the below code.","246f29c9":"View the above Box plot clearly by adding figsize","d2933b07":"## Correlation matrix:","caa2507e":"## Training Regression Model\n\nBy looking at the dataset, we simply can\u2019t suggest the best Regression Model for this problem. So, we will try out different Regression models available in scikit-learn with a k-fold cross validation method.\n\nlet's assume k = 10 (k-fold cross validation)\n\nIt means we split the training data into train and test data using a test_size parameter for 10-folds. Each fold will have different samples that are not present in other folds. By this way, we can throughly train our model on different samples in the dataset.\n\nBefore doing anything, we will split our dataframe df into features X and target Y.","fa614b4f":"We can easily convert the dataset into a pandas dataframe and simply pass in the dataset.data as an argument to pd.DataFrame(). We can view the first 5 rows in the dataset using head() function.","87847374":"## Visualize the dataset\n\nWe will use two types of visualization strategy namely univariate plots and bivariate plots\n\n## Box plot\n\nA box-whisker plot is a univariate plot used to visualize a data distribution.\n\n* * The ends of whiskers are the maximum and minimum range of data distribution.\n* The central line in the box is the median of the entire data distribution.\n* The right and left edges in the box are the medians of data distribution to the right and left from the central median, respectively.\n","b107a2c2":"We should check the datatype of each column using dtypes to make sure every column has a numeric datatype. If a column has a different datatype such as string or character, we need to map that column to a numeric datatype such as integer or float.","91b0394c":"We will cover 3 methods\n\n* PEARSON CORRELATION\n* SPEARMAN CORRELATION\n* KENDALL CORRELATION","2cd357f4":"As we see different data distributions, we will standardize the dataset using StandardScaler function in scikit-learn. This is a useful technique where the attributes are transformed to a standard gaussian distribution with a mean of 0 and a standard deviation of 1.","adb48c17":"We could still tune different regression models used in this example using scikit-learn\u2019s GridSearchCV() function. By tuning, we mean trying out different hyper-parameters for each model.","8bc9d42c":"## Feature Importance\n\nOnce we have a trained model, we can understand feature importance (or variable importance) of the dataset which tells us how important each feature is, to predict the target. Below chart shows relative importance of different feature in the dataset made by our best model Gradient Boosting Regressor (GBR).","e8977092":"Let\u2019s dive into Regression. We will use different Regression models offered by scikit-learn to produce a baseline accuracy for this problem. \n\nWe will use the MAE (Mean Absolute Error) as the performance metric for the regression models.","eb536779":"There is 1 csv file in the current version of the dataset:","3102dcdf":"## Density plot\n\nDensity plot is another univariate plot that draws a histogram of the data distribution and fits a Kernel Density Estimate (KDE).\n## Scatter plot\n\nScatter plot is used to understand relationship between two different attributes in the dataset. Below we have compared PRICE (target) vs each of the attribute in the dataset.","7636c5b0":"We will use pandas and scikit-learn to load and explore the dataset. The dataset can easily be loaded from scikit-learn\u2019s datasets module using read_csv function.","9e0215e0":"## Missing data\nSometimes, in a dataset we will have missing values such as NaN or empty string in a cell. We need to take care of these missing values so that our machine learning model doesn\u2019t break. To handle missing values, there are three approaches followed.\n\n    Replace the missing value with a large negative number (e.g. -999).\n    Replace the missing value with mean of the column.\n    Replace the missing value with median of the column.\n\nTo find if a column in our dataset has missing values, you can use pd.isnull(df).any() which returns a boolean for each column in the dataset that tells if the column contains any missing value. In this dataset, there are no missing values!","86eeeb44":"Let's take a quick look at what the data looks like:","65b4cd97":"## Correlation\n\nPandas offers three different ways to find correlation between attributes (columns). The output of each of these correlation functions fall within the range [-1, 1].\n","374e4464":"## Descriptive Analysis\n\nLet's check the file: ..\/input\/innercity.csv\n\n","3fdc3fa3":"## Choosing the best model\n\nBased on the above comparison, we can see that Gradient Boosting Regression model outperforms all the other regression models. So, we will choose it as the best Regression Model for this problem.","008d3f7e":"The next hidden code cells define functions for plotting data. Click on the \"Code\" button in the published kernel to reveal the hidden code."}}