{"cell_type":{"3f274409":"code","db58e02c":"code","7db4cf9b":"code","5aabea84":"code","5b1e9437":"code","ddbe7ea1":"code","cd4ea25a":"code","85efb821":"code","41667672":"code","f8f99faa":"code","f4c1d7ca":"code","3a4f4ccb":"code","a5301260":"markdown","0676a889":"markdown","98f7746f":"markdown","1f355576":"markdown","f3a5f56d":"markdown","09f4db7e":"markdown","d7fda91e":"markdown","e0058b8b":"markdown","73ffc878":"markdown","4f372fdb":"markdown","6c2ef1e5":"markdown"},"source":{"3f274409":"!pip install torchhandle","db58e02c":"import numpy as np \nimport pandas as pd\nimport os\nimport random\nimport torch\nimport torchhandle\nfrom torchhandle.workflow import BaseContext,Metric\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\ndevice,torchhandle.__version__","7db4cf9b":"def set_seed(seed: int = 42):\n    random.seed(seed)\n    np.random.seed(seed)\n    os.environ[\"PYTHONHASHSEED\"] = str(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed) \n    #torch.backends.cudnn.deterministic = True  \n    #torch.backends.cudnn.benchmark = True  \nset_seed()","5aabea84":"train_df=pd.read_csv(\"..\/input\/tabular-playground-series-aug-2021\/train.csv\")\ntest_df=pd.read_csv(\"..\/input\/tabular-playground-series-aug-2021\/test.csv\")\nfeat=[f'f{i}' for i in  range(100)]","5b1e9437":"from sklearn.model_selection import KFold,StratifiedKFold,train_test_split\nfrom sklearn.preprocessing import StandardScaler\n\nx=train_df[feat].values\ny=train_df[[\"loss\"]].values\nss = StandardScaler()\nx = ss.fit_transform(x)\ntest_scaled = ss.fit_transform(test_df[feat].values)\n","ddbe7ea1":"class Net(torch.nn.Module):\n    def __init__(self, ):\n        super().__init__()\n        self.layer = torch.nn.Sequential(\n            torch.nn.Linear(100, 50),\n            torch.nn.LeakyReLU(),\n            torch.nn.Linear(50, 1)\n           )\n    def forward(self, x):\n        return self.layer(x)","cd4ea25a":"class RMSE(Metric):\n    def __init__(self):\n        self.diff = None\n\n    def map(self, state):\n\n        target = state.target_batch.cpu().detach() #.unsqueeze(dim=1)\n        output = state.output_batch.cpu().detach()\n        if self.diff is None:\n            self.diff = torch.pow(target - output, 2)\n        else:\n            self.diff = torch.cat([self.diff, torch.pow(target - output, 2)], dim=0)\n\n    def reduce(self):\n        mse = torch.sum(self.diff) \/ self.diff.shape[0]\n        rmse = torch.sqrt(mse)\n        return [rmse]\n\n    @property\n    def name(self) -> list:\n        return [\"RMSE\"]\n\n    @property\n    def best(self) -> list:\n        return [\"min\"]","85efb821":"model = {\"fn\": Net}\ncriterion = {\"fn\": torch.nn.MSELoss}\noptimizer = {\"fn\": torch.optim.Adam,\n             \"args\": {\"lr\": 4e-3}\n             }\nmetric_fn = [{\"fn\": RMSE}]\nc = BaseContext(model=model,\n                criterion=criterion,\n                optimizer=optimizer,\n                metric_fn=metric_fn,\n                progress=None,\n                context_tag=\"mlp\")","41667672":"model_list=[]\nkf = KFold(n_splits=7 ,random_state=2021,shuffle=True)\nfold=1\nfor train_index, test_index in kf.split(x):\n    X_train, X_test = x[train_index], x[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n    X_train=torch.tensor(X_train,dtype=torch.float32).to(device)\n    y_train=torch.tensor(y_train,dtype=torch.float32).to(device)\n    X_test=torch.tensor(X_test,dtype=torch.float32)\n    y_test=torch.tensor(y_test,dtype=torch.float32)\n    trn_ds =torch.utils.data.TensorDataset(X_train,y_train)\n    val_ds =torch.utils.data.TensorDataset(X_test,y_test)\n    trn_loader = torch.utils.data.DataLoader(trn_ds, batch_size=2048, shuffle=True)\n    val_loader = torch.utils.data.DataLoader(val_ds, batch_size=2048)\n    loaders = {\"train\": trn_loader, \"valid\": trn_loader}\n    train = c.make_train_session(device, dataloader=loaders,fold_tag=str(fold))\n    train.train(epochs=15)\n    fold=fold+1\n    model_list.append(train.model.cpu())","f8f99faa":"pred_list=[]\nwith torch.no_grad():\n    for m in model_list:\n        pred_list.append(m(torch.tensor(test_scaled, dtype=torch.float32)).numpy())\npred=np.mean(pred_list,axis=0)\npred.shape","f4c1d7ca":"test_df[\"loss\"]=pred\nsub=test_df[[\"id\",\"loss\"]]\nsub.head()","3a4f4ccb":"sub.to_csv(\"submission.csv\",index=False)","a5301260":"* TensorDataset instead of custom dataset\n* all data directly into the GPU to speed up data reading and training\n* Kfold\n* torchhandle simplified training code\n\nmore information about torchhandle please check https:\/\/github.com\/deephub-ai\/torch-handle","0676a889":"# submit","98f7746f":"# read data","1f355576":"# kfold and train","f3a5f56d":"# model","09f4db7e":"# random seed","d7fda91e":"# metric class","e0058b8b":"# pred","73ffc878":"# preprocess ","4f372fdb":"# import ","6c2ef1e5":"# hyper param"}}