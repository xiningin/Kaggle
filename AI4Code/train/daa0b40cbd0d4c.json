{"cell_type":{"a66aa7af":"code","17492392":"code","53002e2e":"code","a1d70212":"code","c36260c7":"code","884a683f":"code","844d7d93":"code","e0cc9b69":"code","010ae685":"code","642eeb8d":"code","0d261ad3":"code","9628db6b":"code","24bee2cb":"code","97417d21":"code","37bfc3db":"code","29aec013":"code","698da350":"code","1b5d02f0":"code","589e32f7":"code","d89353ac":"code","6c17d795":"code","66709078":"code","5802d87b":"code","2687c289":"code","80c7c9d2":"code","08d388bd":"code","96b731fb":"code","6aebae80":"code","bd0c45e8":"markdown","d7cab8ef":"markdown","4bde8ce4":"markdown","909755b4":"markdown","caedf437":"markdown","cc469eb6":"markdown","76c7dc23":"markdown","d12bd9d9":"markdown","614f3262":"markdown","fac4b042":"markdown","5a0846f3":"markdown","dc8c45c3":"markdown","6bf3cd8c":"markdown","6bab58d8":"markdown"},"source":{"a66aa7af":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nfig, ax=plt.subplots()","17492392":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","53002e2e":"df2019=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2019.xlsx')\ndf2018=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2018.xlsx')\ndf2017=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2017.xlsx')\ndf2016=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2016.xlsx')\ndf2015=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2015.xlsx')\ndf2014=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2014.xlsx')\ndf2013=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2013.xlsx')\ndf2012=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2012.xlsx')\ndf2011=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2011.xlsx')\ndf2010=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2010.xlsx')\ndf2009=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2009.xlsx')\ndf2008=pd.read_excel('\/kaggle\/input\/IPL_Player_Scores_2008.xlsx')","a1d70212":"df2019.head(1)","c36260c7":"df2017.head(1)","884a683f":"df2019=df2019.set_index('PLAYER')\ndf2018=df2018.set_index('PLAYER')\ndf2017=df2017.set_index('PLAYER')\ndf2016=df2016.set_index('PLAYER')\ndf2015=df2015.set_index('PLAYER')\ndf2014=df2014.set_index('PLAYER')\ndf2013=df2013.set_index('PLAYER')\ndf2012=df2012.set_index('PLAYER')\ndf2011=df2011.set_index('PLAYER')\ndf2010=df2010.set_index('PLAYER')\ndf2009=df2009.set_index('PLAYER')\ndf2008=df2008.set_index('PLAYER')","844d7d93":"#checking duplicates\ndf2008[df2008.index.duplicated()]\ndf2009[df2009.index.duplicated()]\ndf2010[df2010.index.duplicated()]\ndf2011[df2011.index.duplicated()]\ndf2012[df2012.index.duplicated()]\ndf2013[df2013.index.duplicated()]\ndf2014[df2014.index.duplicated()]\ndf2015[df2015.index.duplicated()]\ndf2016[df2016.index.duplicated()]\ndf2017[df2017.index.duplicated()]\ndf2018[df2018.index.duplicated()]\ndf2019[df2019.index.duplicated()]","e0cc9b69":" pd.DataFrame(\n    {'len2019': [df2019.index.size],\n     'len2018': [df2018.index.size],\n     'len2017': [df2017.index.size],\n     'len2016': [df2016.index.size],\n     'len2015': [df2015.index.size],\n     'len2014': [df2014.index.size],\n     'len2013': [df2013.index.size],\n     'len2012': [df2012.index.size],\n     'len2011': [df2011.index.size],\n     'len2010': [df2010.index.size],\n     'len2009': [df2009.index.size],\n     'len2008': [df2008.index.size],\n    })","010ae685":"df2018=df2018[df2018.index.isin(df2019.index)]\ndf2017=df2017[df2017.index.isin(df2019.index)]\ndf2016=df2016[df2016.index.isin(df2019.index)]\ndf2015=df2015[df2015.index.isin(df2019.index)]\ndf2014=df2014[df2014.index.isin(df2019.index)]\ndf2013=df2013[df2013.index.isin(df2019.index)]\ndf2012=df2012[df2012.index.isin(df2019.index)]\ndf2011=df2011[df2011.index.isin(df2019.index)]\ndf2010=df2010[df2010.index.isin(df2019.index)]\ndf2009=df2009[df2009.index.isin(df2019.index)]\ndf2008=df2008[df2008.index.isin(df2019.index)]","642eeb8d":"pd.DataFrame(\n    {'len2019': [df2019.index.size],\n     'len2018': [df2018.index.size],\n     'len2017': [df2017.index.size],\n     'len2016': [df2016.index.size],\n     'len2015': [df2015.index.size],\n     'len2014': [df2014.index.size],\n     'len2013': [df2013.index.size],\n     'len2012': [df2012.index.size],\n     'len2011': [df2011.index.size],\n     'len2010': [df2010.index.size],\n     'len2009': [df2009.index.size],\n     'len2008': [df2008.index.size],\n    })","0d261ad3":"#performing linear regression on 2019 to see how scores are calculates\nX=df2019.iloc[:,2:]\ny=df2019.loc[:,'Pts']\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=101)\n# Running logistic regression model\nfrom sklearn.linear_model import LinearRegression\nmodel = LinearRegression()\nresult = model.fit(X_train, y_train)\nresult.score(X_train,y_train)\n#Score somes as 1 . full match","9628db6b":"#mean sq error\nnp.mean((y_test-result.predict(X_test))**2)\n#very little values. effectively zero","24bee2cb":"result.coef_\n#These can be used as weights for calculating any scores.","97417d21":"#attribute scores\n#Wkts\tDots\tFours\tSixes\tCatches\tStumpings\n#3.5, 1. , 2.5, 3.5, 2.5, 2.5\nattribute_weights = {\n    'Wkts':3.5, \n    'Dots':1, \n    'Fours':2.5,\n    'Sixes' :3.5,\n    'Catches' :2.5,\n    'Stumpings':2.5\n}","37bfc3db":"def computeScores(df, attribute_weights):\n    df['battingPts']=df['Fours']*attribute_weights.get('Fours')+df['Sixes']*attribute_weights.get('Sixes')\n    df['bowlingPts']=df['Wkts']*attribute_weights.get('Wkts')+df['Dots']*attribute_weights.get('Dots')\n    df['fieldingPts']=df['Catches']*attribute_weights.get('Catches')+df['Stumpings']*attribute_weights.get('Stumpings')\n    return df","29aec013":"df2019=computeScores(df2019,attribute_weights)\ndf2018=computeScores(df2018,attribute_weights)\ndf2017=computeScores(df2017,attribute_weights)\ndf2016=computeScores(df2016,attribute_weights)\ndf2015=computeScores(df2015,attribute_weights)\ndf2014=computeScores(df2014,attribute_weights)\ndf2013=computeScores(df2013,attribute_weights)\ndf2012=computeScores(df2012,attribute_weights)\ndf2011=computeScores(df2011,attribute_weights)\ndf2010=computeScores(df2010,attribute_weights)\ndf2009=computeScores(df2009,attribute_weights)\ndf2008=computeScores(df2008,attribute_weights)","698da350":"alpha=.2\nseason_weights={\n    '2019':1,\n    '2018':1-alpha,\n    '2017':(1-alpha)**2,\n    '2016':(1-alpha)**3,\n    '2015':(1-alpha)**4,\n    '2014':(1-alpha)**5,\n    '2013':(1-alpha)**6,\n    '2012':(1-alpha)**7,\n    '2011':(1-alpha)**8,\n    '2010':(1-alpha)**9,\n    '2009':(1-alpha)**10,\n    '2008':(1-alpha)**11\n}","1b5d02f0":"season_weights.items()","589e32f7":"#columns to be selected\ncolumns=['Pts','battingPts','bowlingPts','fieldingPts']","d89353ac":"#calculating scores with historic data\ndfCombined=(df2019[columns]*season_weights.get('2019')).add(\n    df2018[columns]*season_weights.get('2018'),fill_value=0).add(\n    df2017[columns]*season_weights.get('2017'),fill_value=0).add(\n    df2016[columns]*season_weights.get('2016'),fill_value=0).add(\n    df2015[columns]*season_weights.get('2015'),fill_value=0).add(\n    df2014[columns]*season_weights.get('2014'),fill_value=0).add(\n    df2013[columns]*season_weights.get('2013'),fill_value=0).add(\n    df2012[columns]*season_weights.get('2012'),fill_value=0).add(\n    df2011[columns]*season_weights.get('2011'),fill_value=0).add(\n    df2010[columns]*season_weights.get('2010'),fill_value=0).add(\n    df2009[columns]*season_weights.get('2009'),fill_value=0).add(\n    df2008[columns]*season_weights.get('2008'),fill_value=0)","6c17d795":"print('top 5 overall')\ndfCombined.sort_values(columns,ascending=[False,False,False,False]).head()   ","66709078":"print('top 5 batsman')\ndfCombined.sort_values(['battingPts'],ascending=[False]).head()","5802d87b":"print('top 5 bowlers')\ndfCombined.sort_values(['bowlingPts'],ascending=[False]).head()","2687c289":"print('top 15 fielders')\nprint('At the top all wicketkeepers due to stumping score')\ndfCombined.sort_values(['fieldingPts'],ascending=[False]).head(15)","80c7c9d2":"print('top all rounders')\ndfCombined[(dfCombined['battingPts']>dfCombined['battingPts'].mean()) &\n           (dfCombined['bowlingPts']>dfCombined['bowlingPts'].mean()) &\n           (dfCombined['fieldingPts']>dfCombined['fieldingPts'].mean())]  ","08d388bd":"#scaling the data\nfrom sklearn.preprocessing import MinMaxScaler\nscale=MinMaxScaler()\nafC=scale.fit_transform(dfCombined)\ndfC=pd.DataFrame(afC,columns=['Pts','Batting','Bowling','Fielding'],index=np.arange(dfCombined.index.size))\ndfC.index=dfCombined.index\ndfC=dfC*100#Best Scaled values\n#top 5 aggregate\ndfBest=dfC.sort_values(['Pts'],ascending=[False]).head()\n#top 5 batsman\ndfBatsman=dfC.sort_values(['Batting'],ascending=[False]).head()\n\n#top 5 bowlers\ndfBowlers=dfC.sort_values(['Bowling'],ascending=[False]).head()\n\n#top 5 fielders\n#these are all wicketkeepers due to stimping score\ndfwicketKeepers=dfC.sort_values(['Fielding'],ascending=[False]).head()\n\n#top 5 all rounders\ndfAllrounders=dfC[(dfC['Batting']>dfC['Batting'].mean()) &\n           (dfC['Bowling']>dfC['Bowling'].mean()) &\n           (dfC['Fielding']>dfC['Fielding'].mean())]","96b731fb":"def spiderplot(df, indx):\n    #taking values out of DF\n    values=df.iloc[indx].values.flatten().tolist()\n    values+=values[:1]\n    #defining colors\n    import random\n    r = lambda: random.randint(0,255)\n    colorRandom = '#%02X%02X%02X' % (r(),r(),r())\n    if colorRandom == '#ffffff':colorRandom = '#a5d6a7'\n    basic_color = '#37474f'\n    color_annotate = '#01579b'\n    #spider plot\n    from math import pi\n    Categories=list(dfCombined)[1:]\n    N=len(Categories)\n    angles = [n \/ float(N) * 2 * pi for n in range(N)]\n    angles += angles[:1]\n    plt.figure(figsize=(7,7))\n    ax=plt.subplot(111,projection='polar')\n    ax.set_theta_offset(pi\/2)\n    ax.set_theta_direction(-1)\n    plt.xticks(angles[:-1],Categories,color='black',size=17)\n    plt.yticks([25,50,75,100],[\"low\",\"average\",\"good\",\"great\"],color=color_annotate, size=10)\n    plt.ylim(0,100)\n    ax.plot(angles,values,color=basic_color,linewidth=1, linestyle='solid')\n    ax.fill(angles,values,color=colorRandom,alpha=.3)\n    plt.title(df.index[indx],size=20)\n    plt.show()","6aebae80":"print(\"OverAll Best after IPL 2019\")\nspiderplot(dfBest.iloc[:,1:],0)\nprint(\"Best Batsman\")\nspiderplot(dfBatsman.iloc[:,1:],0)\nprint(\"Best Bowler\")\nspiderplot(dfBowlers.iloc[:,1:],0)\nprint(\"Best Wicketkeeper\")\nspiderplot(dfwicketKeepers.iloc[:,1:],0)\nprint(\"Best Allrounder\")\nspiderplot(dfAllrounders.iloc[:,1:],0)","bd0c45e8":"Computing batting, bowling and fielding scores seperately.","d7cab8ef":"Checking the length for all years","4bde8ce4":"Checking the weights","909755b4":"The purpose of this kernel is to aggregate the player rankings of IPL players from 2008-2019 and profile the players.\nPlayer scores are aggregated based on reducing weightages for every year. The data has been scraped from iplt20.com","caedf437":"Scaling the data for plotting.","cc469eb6":"checking the lengths again, very few players have been a part of IPL since 2008","76c7dc23":"Axar Patel and Ben Stokes, dont shine in any individual department, but top the list as all rounders","d12bd9d9":"IPL computes scores with linear weightages. 3.5 wkts, 1 dot ball, 2.5 4s, 3.5 6s, 2.5 chatches, 2.5 stumpings. Verifying the same.","614f3262":"Adding bowling, batting and fielding scores to the existing dataframes","fac4b042":"Setting player names as index for all dataframes","5a0846f3":"Creating Spiderplots","dc8c45c3":"Calculating weighted scores","6bf3cd8c":"Only interested in players that played in 2019, removing other players.","6bab58d8":"keeping the weight factor as .2, every previous year has 20% less weightage than the current year."}}