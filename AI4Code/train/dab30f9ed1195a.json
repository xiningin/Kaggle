{"cell_type":{"f7bc61c3":"code","5d12770a":"code","b05603b2":"code","60c401a8":"code","de3a8fc6":"code","2ee64af3":"code","d65b59d2":"code","00976f9a":"code","b244d0db":"code","95f7d977":"code","910a9b3d":"code","683eabf7":"code","1201d5e9":"code","ab6487ac":"code","76103e4c":"code","99b86553":"code","3218006b":"code","d13ac048":"code","00dea277":"code","760ec260":"code","0e9814bc":"code","19ffc635":"code","c3af216a":"code","8d08b6e9":"code","a9a5d471":"code","17e326a3":"code","9ff02a37":"code","87c0685c":"code","524c9ec2":"markdown","f50e9d13":"markdown","cc884224":"markdown","6406e705":"markdown","741440af":"markdown","c849295b":"markdown","5b3e68bd":"markdown","1f0cf46d":"markdown","6be50c5f":"markdown","884760c4":"markdown","9e93df50":"markdown","8f68055e":"markdown","b048724c":"markdown","284ef00a":"markdown","0d4e8e48":"markdown","034a0a05":"markdown","582160e8":"markdown","17a33cc1":"markdown","b355a118":"markdown","9094fd43":"markdown","6572bb69":"markdown","6ff08eeb":"markdown","5c2898c6":"markdown","4d4d5455":"markdown","92ad9bb1":"markdown","c6812763":"markdown","5e11c35c":"markdown","2e3aa07c":"markdown","7d1489ef":"markdown","ae01573d":"markdown"},"source":{"f7bc61c3":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nimport warnings\nwarnings.filterwarnings('ignore')","5d12770a":"# loading the dataset in the variable called 'df' and setting the index column as 'Id'\n\ndf= pd.read_csv('..\/input\/dataset-pubg\/data.csv', index_col='Id')","b05603b2":"df.head()  # To view top 5 entries in the dataset.\n\n# in order to view bottom 5 entries, we can do\n#df.tail()\n\n#in order to view more than 5 entries, we can enter any integer value into '()'.\n#Ex: df.head(10) or df.tail(15), etc","60c401a8":"# Now, we let us see all the column names.\ndf.columns","de3a8fc6":"# We can see that the column named 'Unnamed: 0' can be removed from the dataset as it is not clear, what it represents.\n\ndf= df.drop(['Unnamed: 0'], axis=1)  # If axis=0, it consitutes row operation. Since we have to remove the column, we do axis=1.","2ee64af3":"df.head(2)","d65b59d2":"# Now let us check for the shape of the dataset and also that are any null values present in our dataset.\n# For that,\n\nprint('shape of the dataset=', df.shape)\n\nprint(' \\nThe null count of each column of the dataset are as follows:')\ndf.isnull().sum()","00976f9a":"# To view the null row from the dataset:\n\ndf[df['winPlacePerc'].isnull() == True]","b244d0db":"# Function to identify numeric features:\n\ndef numeric_features(dataset):\n    numeric_col = dataset.select_dtypes(include=np.number).columns.tolist()\n    return dataset[numeric_col].head()\n    \nnumeric_columns = numeric_features(df)\nprint(\"Numerical Features:\")\nprint(numeric_columns)\n\nprint(\"====\"*20)\n\n\n\n\n# Function to identify categorical features:\n\ndef categorical_features(dataset):\n    categorical_col = dataset.select_dtypes(exclude=np.number).columns.tolist()\n    return dataset[categorical_col].head()\n\ncategorical_columns = categorical_features(df)\nprint(\"Categorical Features:\")\nprint(categorical_columns)\n\nprint(\"====\"*20)\n\n\n\n# Function to check the datatypes of all the columns:\n\ndef check_datatypes(dataset):\n    return dataset.dtypes\n\nprint(\"Datatypes of all the columns:\")\ncheck_datatypes(df)","95f7d977":"# Function to detect outliers in every feature\ndef detect_outliers(df):\n    cols = list(df)\n    outliers = pd.DataFrame(columns = ['Feature', 'Number of Outliers'])\n    for column in cols:\n        if column in df.select_dtypes(include=np.number).columns:\n            q1 = df[column].quantile(0.25)\n            q3 = df[column].quantile(0.75)\n            iqr = q3 - q1\n            fence_low = q1 - (1.5*iqr)\n            fence_high = q3 + (1.5*iqr)\n            outliers = outliers.append({'Feature':column, 'Number of Outliers':df.loc[(df[column] < fence_low) | (df[column] > fence_high)].shape[0]},ignore_index=True)\n    return outliers\n\ndetect_outliers(df)","910a9b3d":"# Summary statistics for the number of kills\nprint('The average person kills {:.4f} players'.format(df['kills'].mean()))\nprint('50% of people have ',df['kills'].quantile(0.50),' kills or less')\nprint('75% of people have ',df['kills'].quantile(0.75),' kills or less')\nprint('99% of people have ',df['kills'].quantile(0.99),' kills or less')\nprint('while the most kills recorded in the data is', df['kills'].max())","683eabf7":"data = df.copy()\ndata.loc[data['kills'] > data['kills'].quantile(0.99)] = '8+'\nplt.figure(figsize=(20,15))\nsns.countplot(data['kills'].astype('str').sort_values())\nplt.title('Kill Count',fontsize=15)\nplt.show()","1201d5e9":"# Summary statistics for the number of kills\nprint('The average person kills {:.4f} players in a short time'.format(df['killStreaks'].mean()))\nprint('50% of people have ',df['killStreaks'].quantile(0.50),' kills or less in a short time')\nprint('75% of people have ',df['killStreaks'].quantile(0.75),' kills or less in a short time')\nprint('99% of people have ',df['killStreaks'].quantile(0.99),' kills or less in a short time')\nprint('While the most kills in a row recorded in the data is', df['killStreaks'].max())","ab6487ac":"data = df.copy()\ndata.loc[data['killStreaks'] > data['killStreaks'].quantile(0.99)] = '4+'\nplt.figure(figsize=(20,15))\nsns.countplot(data['killStreaks'].astype('str').sort_values())\nplt.title('Kill Count',fontsize=15)\nplt.show()","76103e4c":"# To check how many unique values are present in this categorical column: \n\ndf['matchType'].value_counts()","99b86553":"# To plot the above insights in form of 'countplot'\n\nplt.figure(figsize=(20,15))\nsns.countplot(df['matchType'], )\nplt.title('Match Type',fontsize=15)","3218006b":"data = df.copy()\n\n# Keep only those players that didn't kill anyone\ndata = data[data['kills']==0]\nplt.figure(figsize=(15,10))\nplt.title('Damage Dealt by 0 killers',fontsize=15)\nsns.distplot(data['damageDealt'])","d13ac048":"# Keep only the players that won the match\ndata = df[df['winPlacePerc'] == 1]\n\nplt.figure(figsize=(15,10))\nplt.title('Match duration for winners',fontsize=15)\nsns.distplot(data['matchDuration'])","00dea277":"sns.jointplot(x='winPlacePerc', y='killStreaks', data=df, color='b')","760ec260":"sns.jointplot(x='winPlacePerc', y='damageDealt', data=df, color='b')","0e9814bc":"# Summary statistics for the number of kills\nprint('The average person kills {:.4f} players on their own team'.format(df['teamKills'].mean()))\nprint('50% of people have killed ',df['teamKills'].quantile(0.50),' team players')\nprint('75% of people have killed ',df['teamKills'].quantile(0.75),' team players')\nprint('99% of people have killed ',df['teamKills'].quantile(0.99),' team players')\nprint('while the most kills recorded in the data is', df['teamKills'].max())","19ffc635":"sns.jointplot(x='winPlacePerc', y='teamKills', data=df, ratio=3, color='r')","c3af216a":"# Create a new feature for total distance travelled\ndata = df[['winPlacePerc']].copy()\ndata['totalDistance'] = df['walkDistance'] + df['rideDistance'] + df['swimDistance']\n\n# Summary statistics for the total distance travelled\nprint('The average person travelled {:.2f} m'.format(data['totalDistance'].mean()))\nprint('25% of people have travelled {:.2f} m or less'.format(data['totalDistance'].quantile(0.25)))\nprint('50% of people have travelled {:.2f} m or less'.format(data['totalDistance'].quantile(0.50)))\nprint('75% of people have travelled {:.2f} m or less'.format(data['totalDistance'].quantile(0.75)))\nprint('99% of people have travelled {:.2f} m or less'.format(data['totalDistance'].quantile(0.99)))\nprint('The longest distance travelled in the data is {:.2f} m'.format(data['totalDistance'].max()))","8d08b6e9":"sns.jointplot(x='winPlacePerc', y='totalDistance', data=data, ratio=3, color='r')\n","a9a5d471":"# Summary statistics for the number of healing items used\nprint('The average person uses {:.2f} healing items'.format(df['heals'].mean()))\nprint('50% of people used {:.2f} healing items'.format(df['heals'].quantile(0.50)))\nprint('75% of people used {:.2f} healing items or less'.format(df['heals'].quantile(0.75)))\nprint('99% of people used {:.2f} healing items or less'.format(df['heals'].quantile(0.99)))\nprint('The doctor of the data used {:.2f} healing items'.format(df['heals'].max()))","17e326a3":"# Summary statistics for the number of boosting items used\nprint('The average person uses {:.2f} boosting items'.format(df['boosts'].mean()))\nprint('50% of people used {:.2f} boosting items'.format(df['boosts'].quantile(0.50)))\nprint('75% of people used {:.2f} boosting items or less'.format(df['boosts'].quantile(0.75)))\nprint('99% of people used {:.2f} boosting items or less'.format(df['boosts'].quantile(0.99)))\nprint('The addict of the data used {:.2f} boosting items'.format(df['boosts'].max()))","9ff02a37":"data = df.copy()\ndata = data[data['heals'] < data['heals'].quantile(0.99)]\ndata = data[data['boosts'] < data['boosts'].quantile(0.99)]\n\nf,ax1 = plt.subplots(figsize =(20,10))\nsns.pointplot(x='heals',y='winPlacePerc',data=data,color='red',alpha=1.0)\nsns.pointplot(x='boosts',y='winPlacePerc',data=data,color='blue',alpha=0.8)\nplt.text(4,0.6,'Heals',color='red',fontsize = 17,style = 'italic')\nplt.text(4,0.55,'Boosts',color='blue',fontsize = 17,style = 'italic')\nplt.xlabel('Number of heal\/boost items',fontsize = 15,color='blue')\nplt.ylabel('Win Percentage',fontsize = 15,color='blue')\nplt.title('Heals vs Boosts',fontsize = 20,color='blue')\nplt.grid()","87c0685c":"f,ax = plt.subplots(figsize=(15, 15))\nsns.heatmap(df.corr(), annot=True, linewidths=.5, fmt= '.2f',ax=ax)","524c9ec2":"### Detect outliers in the continuous columns\n\nOutliers are observations that lie far away from majority of observations in the dataset and can be represented mathematically in different ways.\n\nOne method of defining outliers are: outliers are data points lying beyond **(third quartile + 1.5xIQR)** and below **(first quartile - 1.5xIQR)**. \n\n- The function below takes a dataframe and outputs the number of outliers in every numeric feature based on the above rule of *IQR* \n\nYou can even modify the function below to capture the outliers as per their other definitions. ","f50e9d13":"### Multivariate analysis","cc884224":"In a PUBG game, up to 100 players start in each match (matchId). Players can be on teams (groupId) which get ranked at the end of the game (winPlacePerc) based on how many other teams are still alive when they are eliminated. In game, players can pick up different munitions, revive downed-but-not-out (knocked) teammates, drive vehicles, swim, run, shoot, and experience all of the consequences -- such as falling too far or running themselves over and eliminating themselves.\n\nYou are provided with a large number of anonymized PUBG game stats, formatted so that each row contains one player's post-game stats. The data comes from matches of all types: solos, duos, squads, and custom; there is no guarantee of there being 100 players per match, nor at most 4 players per group.\n","6406e705":"##### Observations:\n- It appears that the match duration has no bearing on the winPlacePerc. Apparently you can even win the game in just over 2 min, but more commonly the game is won in approximately 1400 or 1850 seconds.\n- The match Duration is not a feature that is likely to be useful in predicting the winPlacePer.","741440af":"#### Maximum number of enemy players killed in a short time.\nThis is the number of enemy players killed in a short time by each player.","c849295b":"# PUBG Exploratory Data Ananlysis (EDA)","5b3e68bd":"##### Ovservation:\n- Here, we see a distribution of how much damage, players that dont kill anyone, can inflict on there enemies. We can see that most players dont deal out too much, this is most likely all the new players trying to figure out the controls and getting to know the game while they continually get beaten up by the more expereince players.","1f0cf46d":"From observing above information, we can see that the shape of the dataset is (1111742, 28). This means that the dataset has 1111742 rows and 28 columns.\n\nLater we can notice that none, but only 1 column has 1 null value. The name of that column is 'winPlacePerc'.","6be50c5f":"The other way to view this statistical data is in the form of graph as shown. Here is a plot of the number of players that make 1, 2, 3,4+ killStreaks in a game!!","884760c4":"#### Number of times a player killed a team mate\n- This is the number of times a team member kills one of there own team.","9e93df50":"The other way to view this statistical data is in the form of graph as shown. Here is a plot of the number of players that make 1, 2, 3, ... 8+ kills in a game!!","8f68055e":"#### Dealing with the 'matchType' column","b048724c":"#### Damage to enemy players\nWe've seen that most people aren't able to kill any one, so maybe they inflict some damage to their enemies","284ef00a":"# Understanding the dataset\n\n**Data Set Information**\n\n**Features**\n\n|Feature|Description|\n|-----|-----|\n|DBNOs|Number of enemy players knocked.|\n|assists|Number of enemy players this player damaged that were killed by teammates.|\n|boosts|Number of boost items used.|\n|damageDealt|Total damage dealt. Note: Self inflicted damage is subtracted.|\n|headshotKills|Number of enemy players killed with headshots.|\n|heals|Number of healing items used.|\n|Id|Player\u2019s Id|\n|killPlace|Ranking in match of number of enemy players killed.|\n|killPoints|Kills-based external ranking of players. (Think of this as an Elo ranking where only kills matter.) If there is a value other than -1 in rankPoints, then any 0 in killPoints should be treated as a \u201cNone\u201d.|\n|killStreaks|Max number of enemy players killed in a short amount of time.|\n|kills|Number of enemy players killed.|\n|longestKill|Longest distance between player and player killed at time of death. This may be misleading, as downing a player and driving away may lead to a large longestKill stat.|\n|matchDuration|Duration of match in seconds.|\n|matchId|ID to identify matches. There are no matches that are in both the training and testing set.|\n|matchType|String identifying the game mode that the data comes from. The standard modes are \u201csolo\u201d, \u201cduo\u201d, \u201csquad\u201d, \u201csolo-fpp\u201d, \u201cduo-fpp\u201d, and \u201csquad-fpp\u201d; other modes are from events or custom matches.|\n|rankPoints|Elo-like ranking of players. This ranking is inconsistent and is being deprecated in the API\u2019s next version, so use with caution. Value of -1 takes the place of \u201cNone\u201d.|\n|revives|Number of times this player revived teammates|.\n|rideDistance|Total distance traveled in vehicles measured in meters.|\n|roadKills|Number of kills while in a vehicle.|\n|swimDistance|Total distance traveled by swimming measured in meters.|\n|teamKills|Number of times this player killed a teammate.|\n|vehicleDestroys|Number of vehicles destroyed.|\n|walkDistance|Total distance traveled on foot measured in meters.|\n|weaponsAcquired|Number of weapons picked up.|\n|winPoints|Win-based external ranking of players. (Think of this as an Elo ranking where only winning matters.) If there is a value other than -1 in rankPoints, then any 0 in winPoints should be treated as a \u201cNone\u201d.|\n|groupId|ID to identify a group within a match. If the same group of players plays in different matches, they will have a different groupId each time.|\n|numGroups|Number of groups we have data for in the match.|\n|maxPlace|Worst placement we have data for in the match. This may not match with numGroups, as sometimes the data skips over placements.|\n|winPlacePerc|The target of prediction. This is a percentile winning placement, where 1 corresponds to 1st place, and 0 corresponds to last place in the match. It is calculated off of maxPlace, not numGroups, so it is possible to have missing chunks in a match.|","0d4e8e48":"There is a reasonable correlation here with the damadge we deal out to enemey players and the winPlacePerc.","034a0a05":"##### Observations :\n- From the above graph, it is clear that the most played matchtype is **squad-fpp** \n- The least played matchtype is **normal-duo**","582160e8":"## EDA & Data Visualizations\n\nExploratory data analysis is an approach to analyzing data sets by summarizing their main characteristics with visualizations. The EDA process is a crucial step prior to building a model in order to unravel various insights that later become important in developing a robust algorithmic model.","17a33cc1":"##### Observations:\n- Here we can see how the heal items and boost items ae used compared to each other.\n- This seems to indicate that using a few healing items increases your chance of winning, but you need to use more boosts to actaully achieve a change of winning.","b355a118":"#### Lets have a look at the match duration for all the winners.","9094fd43":"#### Healing and using Boosts affect on the result\n- Healing items are used to heal yourself after you've been injured, which improves your health and allows you to continue palying the game for longer\n- Boost items are used by a player to increase speed and accuracy, which will allow a player to achieve more kills with weapons or get away from a fight faster.","6572bb69":"#### Total distance travelled\nThis is not an existing feature in the data, but we can combine the distance features to forma a total distance measure, so see if this has any predictive power of our target variable.","6ff08eeb":"#### Pearson correlation between all features","5c2898c6":"Lets have a look at the data for this and see if there is any correlation to our target variable \"winPlacePerc\".\n\nA **correlation** between two random vairables describes a statistical association, which basically means how close these two random variables are to having a linear relation ship. The correlation can range between -1 and 1:\n\n- A correlation of 1 means the variables are perfectly correlated.\n- A correlation of 0 means there is no corerlation between teh variables.\n- A corerlation of -1 means the variabels are prefectly negatively corerlated","4d4d5455":"##### Ovservation:\n- There is a reasonably strong correlation with the total distance travelled and winning, although most of this correlation may just be due to the strong correlation with walking distance and winPlacePerc. However, one interesting item to note is that it looks like the person that travelled the longest distance didn't win, when they travelled over 41 kms in a single match.","92ad9bb1":"### Bivariate Analysis \n\nBivariate analysis involves checking the relationship between two variables simultaneously.","c6812763":"## Univariate analysis\n\nUnivariate analysis means analysis of a single variable. It\u2019s mainly describes the characteristics of the variable.\n","5e11c35c":"#### Number of enemys the player killed:\nThis is the number of enemy players that were killed by each player.","2e3aa07c":"###  Importing necessary libraries\n\nThe following code is written in Python 3.x. Libraries provide pre-written functionality to perform necessary tasks.","7d1489ef":"### Observations :\n- As per the IQR methodology, there are outliers in majority of the columns.","ae01573d":"##### Observations:\n- According to the colorbar we can find the correlation between different features.\n- If correlation is positive, one variable increases with other.\n- If correlation is negative, as one variable increases, the other decreases.\n- if correlation is 1, it means that either the variables are same or they are almost same"}}