{"cell_type":{"fc2fd8cc":"code","6da193d5":"code","6fb8d211":"code","3712ffd9":"code","7a9e0b1c":"code","e59541a4":"code","8c345c6f":"code","de7664f0":"code","0b4a0050":"code","e07a9c95":"code","c936bbe9":"code","29f85d5c":"code","d98d01a7":"code","66593c1b":"code","8b937bf9":"code","eb15f146":"code","ac692943":"code","a3925334":"code","1f2d9cb4":"code","693c4a20":"code","2a2675c5":"code","971ccf3f":"code","a693fe2e":"code","692ff245":"code","67b750c4":"code","3e852d9c":"code","979a4792":"markdown","3612f187":"markdown","ac9564ed":"markdown","d22956cb":"markdown","e5165996":"markdown","45bfebdf":"markdown","c17e61dd":"markdown","c61cf6ca":"markdown","044f7c53":"markdown","d70ded5d":"markdown","b0f399a1":"markdown","2feaee2b":"markdown","57068cc5":"markdown","2ee70140":"markdown","9647327c":"markdown","c831e211":"markdown","5ee135a0":"markdown","5676b878":"markdown","bf3c341c":"markdown","77391754":"markdown"},"source":{"fc2fd8cc":"import pandas as pd\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nsns.set()\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# ignore warnings\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\nwarnings.filterwarnings(\"ignore\", category=FutureWarning)\nwarnings.filterwarnings(\"ignore\", category=RuntimeWarning)","6da193d5":"train = pd.read_csv(\"..\/input\/titanicdivethrough-featurecave\/feature_cave_train.csv\", index_col=0)\ntest = pd.read_csv(\"..\/input\/titanicdivethrough-featurecave\/feature_cave_test.csv\", index_col=0)\n\n# To compare our results in the end, we need the original data\noriginal_train = train.copy()","6fb8d211":"class MyClassifier:\n    \n    def __init__(self, n_features):\n        self.n_features = n_features\n        np.random.seed(0)\n        self.w = np.random.normal(loc=0, scale=0.01, size=n_features + 1)\n        self.losses = []\n    \n    def predict(self, x):\n        y = sigmoid(np.sum(self.w[:-1]*x, axis=1) + self.w[-1])\n        return y\n    \n    def loss(self, y, t):\n        E = - np.sum(t * np.log(y) + (1-t) * np.log(1-y))\n        return E\n        \n    def gradient(self, x, y, t):\n        grad = np.zeros(self.w.shape[0])\n        for d in range(self.w.shape[0]):\n            if d != self.n_features:\n                grad[d] = np.sum((y-t)*x[:, d])\n            else:\n                grad[d] = np.sum((y-t))\n        return grad\n        \n    def update(self, eta, grad):\n        w_next = np.zeros(self.w.shape) \n        for d in range(self.w.shape[0]):\n            w_next[d] = self.w[d] - eta * grad[d]\n        return w_next\n\n    def learn(self, x, t, eta=0.000001, max_steps=100000, tol=0.00001):\n        y = self.predict(x)\n        for step in range(max_steps):\n            error = self.loss(y, t)\n            grad = self.gradient(x, y, t)\n            self.w = self.update(eta, grad)\n            self.losses.append(error)\n            y = self.predict(x)\n            error_next = self.loss(y, t)\n            if (error - error_next) < tol:\n                break\n                \n    def decide(self, y):\n        decision = np.zeros(y.shape)\n        decision[y >= 0.5] = 1\n        decision[y < 0.5] = 0\n        return decision.astype(np.int)\n    \n    def accuracy(self, y, t):\n        N = y.shape[0]\n        return 1\/N * np.sum(1 - np.abs(t-y))\n        \n    def score(self, x, t):\n        y = self.predict(x)\n        y = self.decide(y)\n        return self.accuracy(y, t)","3712ffd9":"def sigmoid(x):\n    result = 1\/(1+np.exp(-x))\n    return result","7a9e0b1c":"from sklearn.model_selection import train_test_split\n\nfeatures = train.drop([\"PassengerId\", \"Survived\"], axis=1).columns\n\nX = train[features].values\nY = train.Survived.values\n\nx_train, x_val, t_train, t_val = train_test_split(X, Y, random_state=0)\n\ntrain_df = pd.DataFrame(x_train, columns=features)\ntrain_df[\"Survived\"] = t_train\nval_df = pd.DataFrame(x_val, columns=features)\nval_df[\"Survived\"] = t_val\n\ntrain_df.head()","e59541a4":"one_step_classifier = MyClassifier(n_features = len(features))\npredictions = one_step_classifier.predict(x_train)\ngrad = one_step_classifier.gradient(x_train, predictions, t_train)\n\nfeatures_names = list(features) + [\"bias\"]\n\nplt.figure(figsize=(20,6))\nsns.barplot(x=features_names, y=grad)\nplt.ylabel(\"gradients of loss\")\nplt.xlabel(\"per feature parameter $w_{d}$\")\nplt.title(\"one step gradients\")\nplt.xticks(rotation=45);","8c345c6f":"from sklearn.preprocessing import StandardScaler\n# scale the train and test ages\n\nscaler = StandardScaler()\ntrain.Age = scaler.fit_transform(train.Age.values.reshape(-1,1))\ntest.Age = scaler.transform(test.Age.values.reshape(-1,1))","de7664f0":"# visualize the scaled ages distributions of train and test\n# hint: you can use sns.distplot of the opensource tool seaborn\nplt.figure(figsize=(20,5))\nsns.distplot(train.Age.values, label=\"train\", color=\"darkorange\")\nsns.distplot(test.Age.values, label=\"test\", color=\"tomato\");\nplt.xlabel(\"Scaled age values\");\nplt.ylabel(\"Density\")\nplt.legend();","0b4a0050":"assert(np.round(train.Age.mean(),1) == 0)\nassert(np.round(train.Age.median(), 1) == -0.1)\nassert(np.round(train.Age.min(), 1) == -2.2)\nassert(np.round(train.Age.max(), 1) == 3.9)\nassert(np.round(test.Age.mean(),1) == 0)\nassert(np.round(test.Age.median(), 1) == -0.1)\nassert(np.round(test.Age.min(), 1) == -2.2)\nassert(np.round(test.Age.max(), 1) == 3.6)","e07a9c95":"plt.figure(figsize=(20,5))\nsns.distplot(train_df.Fare.values, color=\"Purple\")\nplt.xlabel(\"Fare\")\nplt.ylabel(\"Density\")\nplt.title(\"Fare distribution in train_df\");","c936bbe9":"def get_grad_contributions(y, t, x_d):\n    contributions = (y - t) * x_d\n    return contributions\n\nfare_contributions = get_grad_contributions(predictions, t_train, train_df.Fare.values)","29f85d5c":"plt.figure(figsize=(20,5))\nsns.distplot(fare_contributions, color=\"violet\")\nplt.xlabel(\"Contribution of fare to the gradient\");\nplt.ylabel(\"Density\")\nplt.title(\"Do we have extreme contributions to the gradient?\");","d98d01a7":"# create some normally distributed samples:\noriginal = np.random.normal(loc=0, scale=1, size=200)\n# add an outlier\nshifted = np.array(original.tolist() + [1000])\n# comute the mean\nprint(np.mean(original))\nprint(np.mean(shifted))","66593c1b":"# Just a method to plot our fare distribution with some statistics\ndef show_fare_distribution():\n    plt.figure(figsize=(20,5))\n    sns.kdeplot(train[train.Survived==0].Fare, color=\"Blue\", shade=True)\n    sns.kdeplot(train[train.Survived==1].Fare, color=\"Green\", shade=True)\n    plt.axvline(np.max(train.Fare.values), color=\"Yellow\")\n    plt.axvline(np.min(train.Fare.values), color=\"Yellow\")\n    plt.axvline(np.mean(train.Fare.values)+np.std(train.Fare.values), color=\"Orange\")\n    plt.axvline(np.mean(train.Fare.values)-np.std(train.Fare.values), color=\"Orange\")\n    plt.axvline(np.mean(train.Fare.values), color=\"Red\")\n    plt.axvline(np.median(train.Fare.values), color=\"Black\")\n    plt.xlabel(\"Fare\")\n    plt.ylabel(\"Density\")\n    return plt","8b937bf9":"show_fare_distribution()","eb15f146":"# perform a log transformation of the fare features in train and test! \n# Hint: You can use pandas apply method, for example: train.Fare = train.Fare.apply(lambda l: some method(l))\ntrain.Fare = train.Fare.apply(lambda l: np.log(l+1))\ntest.Fare = test.Fare.apply(lambda l: np.log(l+1))\nshow_fare_distribution()","ac692943":"train.Fare = scaler.fit_transform(train.Fare.values.reshape(-1,1))\ntest.Fare = scaler.transform(test.Fare.values.reshape(-1,1))","a3925334":"assert(np.round(np.mean(train.Fare), 2) == 0.)\nassert(np.round(np.median(train.Fare), 2) == -0.23)\nassert(np.round(np.min(train.Fare), 2) == -3.06)\nassert(np.round(np.max(train.Fare), 2) == 3.39)\nassert(np.round(np.std(train.Fare), 2) == 1.)\nassert(np.round(np.mean(test.Fare), 2) == 0.05)\nassert(np.round(np.median(test.Fare), 2) == -0.23)\nassert(np.round(np.min(test.Fare), 2) == -3.06)\nassert(np.round(np.max(test.Fare), 2) == 3.39)\nassert(np.round(np.std(test.Fare), 2) == 1.)","1f2d9cb4":"sns.countplot(x=train.Sex, hue=train.Survived);","693c4a20":"train.Sex = train.Sex.apply(lambda l: np.where(l==0, -1, 1))\ntest.Sex = test.Sex.apply(lambda l: np.where(l==0, -1, 1))","2a2675c5":"# Perform this mapping for all remaining categorical features in train and test!\n\ncols_to_use = [col for col in train.columns if col not in [\"PassengerId\", \"Survived\", \"Age\", \"Sex\", \"Fare\"]]\nfor col in cols_to_use:\n    train[col] = train[col].apply(lambda l: np.where(l==0, -1, 1))","971ccf3f":"features = train.drop([\"PassengerId\", \"Survived\"], axis=1).columns\n\nX = train[features].values\nY = train.Survived.values\n\nX_old = original_train[features].values\nY_old = original_train.Survived.values\n\nx_train, x_val, t_train, t_val = train_test_split(X, Y, random_state=0)\nx_train_old, x_val_old, t_train_old, t_val_old = train_test_split(X_old, Y_old, random_state=0)","a693fe2e":"new_model = MyClassifier(x_train.shape[1])\nnew_model.learn(x_train, t_train)\nnew_losses = new_model.losses\nnew_score = new_model.score(x_val, t_val)\nprint(new_score)","692ff245":"old_model = MyClassifier(x_train_old.shape[1])\nold_model.learn(x_train_old, t_train_old)\nold_losses = old_model.losses\nold_score = old_model.score(x_val_old, t_val_old)\nprint(old_score)","67b750c4":"plt.figure()\nplt.plot(new_losses, 'g')\nplt.plot(old_losses, 'r')\nplt.xlabel(\"Iteration steps\")\nplt.ylabel(\"Loss\")","3e852d9c":"assert(np.round(old_score, 4) == 0.7982)\nassert(np.round(new_score, 4) == 0.8117)","979a4792":"## Get your equipment\n\nWe have entered the wrack as we are going to understand the heart of our learning process - how gradients flow.  ;-)","3612f187":"To pass this station, uncomment and run. If you are right, nothing shows up! ;-)","ac9564ed":"Obviously our loss decreases faster! Consequently we may reduce the iteration steps and\/or increase the learning rate. :-)","d22956cb":"Can you see the few high valued contributions above 50 that are mainly responsible for our high fare gradient?","e5165996":"## Station 5 - Categorical features\n\nLet's dive into the next problem... Currently we set our categorical features either to 1 or 0. But is this really a good choice? Let's try to figure it out given the sex feature. There was a high chance to survive if the passenger was a female:","45bfebdf":"Due to the very high outlier, the mean is shifted towards higher values even though the majority is centered around zero. The same problem applies to the gradient contributions: One very high outlier contribution shifts the gradient towards learning exotics ignoring the remaining samples. For skewed distributions this is true as well: The contributions of the longer tail have more impact on the gradient than the others and makes our model learning from exotics as well. \n\n### It's your turn\nPerform a log-transformation to scale the fares such that they look somehow normally distributed:\n\n$$ x_{transformed, fare} = \\log (x_{fare} + 1) $$\n\nOf course you can use (and should try out) different constants than 1 to get away with the signularity of the log function at zero. But for matching solutions I would recommend to use this one. ;-)","c17e61dd":"You should see that the fare and the age exhibit the highest gradients. Why is it bad that we make large steps in weight update for high valued gradients and only small steps for low valued gradients? What does this mean for our speed and performance of gradient descent especially if you use a limit of loss change (tolerance) as a stopping criterion? ","c61cf6ca":"If we would predict a probability of 0.5 for a male and for a female to survive, we would expect gradient contributions that point into opposite directions. But actually we obtain:\n\nFor females: $ (y - t) \\cdot x_{sex} = (0.5 - 1) \\cdot 1  = -0.5 $\n\nFor males: $ (y - t) \\cdot x_{sex} = (0.5 - 1) \\cdot 0 = 0 $\n\nZero contribution in this case is bad. Only if the prediction is equal to the target we would like to have a zero contribution. Consequently we could make progress if we would use values like 1 and -1 to describe the gender:\n\nFor females: $ (y - t) \\cdot x_{sex} = (0.5 - 1) \\cdot 1  = -0.5 $\n\nFor males: $ (y - t) \\cdot x_{sex} = (0.5 - 1) \\cdot -1 = 0.5 $\n\nNow, both are pushed into different directions. This is great, especially in the case where the feature is powerful like the sex feature. This way we only need one parameter update step for the sex feature to separate our target groups. Let's use our new strategy:","044f7c53":"Ok, after transformation you are not yet finished with the fare: Normalize the feature to zero mean and unit variance using your own method or the StandardScaler of scikit-learn as you have done with the ages. ","d70ded5d":"## Station 1: Recap gradient magnitudes\n\nIn the last kernels we have already seen that the gradients of the loss $E$ with respect to the parameters $w$ depend on the features $x$:\n\n$$ \\frac{\\partial E}{\\partial w_{d}} = \\sum_{n=1}^{N} (y_{n} - t_{n}) \\cdot x_{n, d}$$\n\nBy taking just one step and looking at the gradients we have revealed that the different feature value ranges result in different gradient magnitudes. Currently our gradients are mainly driven by high contributions of features with high value ranges whereas the others only exhibit low impact on the weight and loss change. This is not our desire as we want to have those features to have a high impact on the gradients that are mainly resposible for the survival of our passengers. ;-)\n\nLet's have a look at the gradients per feature by taking one iteration step with your logistic regression model. Which features show the highest gradients?","b0f399a1":"## Welcome Kaggler!\n\nWith this diving course I invite you to learn some machine learning basics. This course is designed as a series of kernels that guides you through different topics and hopefully you can discover some hidden treasures that push you forward on your data science road. You don't have to pick the courses in sequence if you are only interested in some topics that are covered. If you are new I would recommend you to take them step by step one after another. ;-)\n\nJust fork the kernels and have fun! :-)\n\nUPDATE - I'm currently working on the series to change from interactive mode to guided. Don't wonder and have caution - Work in progress ;-)\n\n* [Prepare to start](https:\/\/www.kaggle.com\/allunia\/titanic-dive-through-prepare-to-start): Within this kernel we will prepare our data such that we can use it to proceed. Don't except nice feature selection or extraction techniques here because we will stay as simple as possible. Without a clear motivation we won't change any features. Consequently we are only going to explore how to deal with missing values and how to turn objects to numerical values. In the end we will store our prepared data as output such that we can continue working with it in the next kernel.\n* [MyClassifier](https:\/\/www.kaggle.com\/allunia\/titanic-dive-through-myclassifier): Are you ready to code your own classifier? Within this kernel you will build logistic regression from scratch. By implementing the model ourselves we can understand the assumptions behind it. This knowledge will help us to make better decisions in the next kernel where we will use this model and build some diagnosis tools to improve its performance.\n* [The feature cave](https:\/\/www.kaggle.com\/allunia\/titanic-dive-through-feature-cave): By using our own logistic regression model we will explore how we can improve by adding a bias term and why we should encode categorical features. \n* **Feature scaling and outliers**: Why is it important to scale features and to detect outliers? By analyzing the model structure we will discover how our gradients and our model performance are influenced by these topics. ","2feaee2b":"### Split into train and validation data\n\nTo see how well our model performs, we will split our train data into train and validation data. This way we can try to become better by looking at the performance on the validation data. ","57068cc5":"## Station 3 - Exotic impact\n\nOk, we are done with the ages, but what about the fares? Let's have a look at them:","2ee70140":"### Packages and data","9647327c":"Can you explain why this fare distribution causes a new problem not only with convergence speed but with bad predictions as well? If you are not sure why, look at the equation to compute the gradient for the parameter update for $w_{fare}$:\n\n$$ \\frac{\\partial E}{\\partial w_{fare}} = \\sum_{n=1}^{N} (y_{n} - t_{n}) \\cdot x_{n, fare}$$\n\n$$ w_{fare}^{\\tau+1} = w_{fare}^{\\tau} - \\eta \\cdot \\frac{\\partial E}{\\partial w_{fare}}$$\n\nWe are summing over all $n$ passengers and our initial predictions $y$ are relatively close to 0.5. Thus the term $(y_{n}-t_{n})$ is always close to 0.5 for $t_{n}=0$ or close to $-0.5$ for $t_{n} = 1$. There is nothing wrong with that. BUT, you are multiplying with $x_{n,fare}$! If it's an outlier this yields a high contribution to the gradient in the sum. Even if all other contributions might be of a low value, one high outlier value already shifts the entire gradient towards higher values as well. This is a bad learning behaviour! If our model gradients are mainly driven by outliers, it tries to learn the survival of these exotic values, ignoring the majority of all remaining passengers. :-( Uff! \n\nOk, before we are going to fix this, let's play safe and have a look at the distribution of all contributions $(y_{n} - t_{n}) \\cdot x_{n, fare}$ of our one step learning classifier:","c831e211":"Let's start!","5ee135a0":"## Station 2 - Scaling the age\n\nTo obtain faster convergence we shall scale the age and the fare feature to value ranges close to those of our remaining features. In our case they are categorical and hold values either of zero or one. One way to get close to this range is standard scaling: For each value we subtract the feature mean $\\mu$ and divide by standard deviation $\\sigma$: \n\n$$x_{scaled} = \\frac{x - \\mu_{x, train}}{\\sigma_{x, train}} $$\n\nThis way our new distribution has zero mean and unit variance. Consequently the majority of our values is close to those of our remaining features. As you usually do not know new data like the test data, you should compute the mean and the standard deviation on the train data. Now it's your turn: Scale the age feature! You can do so by implementing your own scaling method or by using [StandardScaler](http:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.preprocessing.StandardScaler.html) of scikit-learn:","5676b878":"## Station 4 - Transforming and scaling the fare\n\n** Many models like normally distributed features!**\n\nAnd logistic regression does! But why?\n\nOk, imagine you have a powerful feature that is normally distributed and the decision boundary for belonging to group 0 or 1 is exactly the mean $\\mu = 0$. For example all samples with negative values survived the disaster and the positive ones died. In this case we would obtain the following gradient contributions for survived passengers:\n\nFor $x = \\mu: (0.5 - 1) \\cdot 0 = 0 $\n\nFor $x < \\mu:  (0.5 - 1) \\cdot sign(-) > 0$\n\nFor $x > \\mu: (0.5 - 1) \\cdot sign(+) < 0$\n\nAs we assumed a normal distribution we would obtain zero for the total gradient as the sum\/integral over all passengers. Consequently we would not update our initial parameter $w_{initial}$. We are already done! :-) But what if our \"perfect\" and powerful feature distribution exhibits an outlier? In this case we would yield a gradient $\\partial _{w} E > 0$ and our model tries to update the parameter $w$ such that it fits the outlier at the expense of other passenger samples. This problem is similar for skewed feature distributions: High absolute values contribute more to the sum than many small ones. It the same problem as with the mean. One example:","bf3c341c":"## Station 6- Speed up and pass the gate\n\nOk, let's show that we yield a better and faster convergence of the loss function by feature scaling and transformation! ","77391754":"### Self-made logistic regression\nAgain we have to use our beginners diving equipment - our selfmade logistic regression classifier. This way we make sure that we have access to every part of our model and that we can try some experiments to find out how our model reacts. If you have done the other courses you may wonder if this is the improved version - yes! It includes the bias term:"}}