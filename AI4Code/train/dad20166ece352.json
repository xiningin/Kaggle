{"cell_type":{"00b4784a":"code","dde0c5f1":"markdown"},"source":{"00b4784a":"import gresearch_crypto\nimport numpy as np\nimport pandas as pd\n\nenv = gresearch_crypto.make_env()\niter_test = env.iter_test()\n\nasset_details = pd.read_csv('..\/input\/g-research-crypto-forecasting\/asset_details.csv')\n#create dictionnary of weights\ndict_weights = {}\n\nfor i in range(asset_details.shape[0]):\n    dict_weights[asset_details.iloc[i,0]] = asset_details.iloc[i,1]\n    \nfor i, (df_test, df_pred) in enumerate(iter_test):\n    \n    df_test['weights'] = df_test.Asset_ID.map(dict_weights).fillna(0)\n    df_test['log_ret'] = np.log(df_test.Close\/df_test.Open).fillna(0)\n    \n    df_pred.Target = -(df_test['log_ret'] - (df_test['weights'] * df_test['log_ret']).sum() \/ df_test['weights'].sum())\n\n    env.predict(df_pred)","dde0c5f1":"Taking advantage of usually negative autoccorelation of log returns.\nFor an explanation (And More !) see my EDA notebook here: https:\/\/www.kaggle.com\/lucasmorin\/crypto-forecasting-intro-eda\/"}}