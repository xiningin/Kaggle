{"cell_type":{"12b18f1f":"code","1c287182":"code","ba4bf2b2":"code","9dafccb0":"code","daa1a302":"code","acb8f980":"code","248a8908":"code","dda471dd":"code","1afd9faf":"markdown"},"source":{"12b18f1f":"import numpy as np\n\nimport pandas as pd\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom matplotlib import collections  as mc\n\nimport seaborn as sns\n\nfrom tqdm import tqdm\n\nimport warnings\n\nglobal moveOptions\n# step correspoinding to grid neighbour\nmoveOptions = np.array([[0,-1],[0,1],[1,0],[-1,0]])","1c287182":"def plot_line(line,n,m):\n    lc = mc.LineCollection(line, colors = [0,0,0,1], linewidths = 0.5)\n    fig, ax = plt.subplots(dpi=200)\n    #set x\/y limits to match grid size\n    #x\/y ticks for each coordinate \n    plt.setp(ax, xlim = (-0.5,n-0.5), ylim = (-0.5,m-0.5),\n             xticks = [], yticks = [],\n             xticklabels = [], yticklabels = [])\n    ax.add_collection(lc)\n    ax.grid()\n    plt.savefig('longLine.jpg')","ba4bf2b2":"# i and j are the indices for the node whose neighbors you want to find\ndef find_neighbours(grid, i, j):\n    return np.array([grid[i+1,j], grid[i-1,j],grid[i,j+1], grid[i,j-1]])","9dafccb0":"def generate_line(line,n,m):\n\n    # grid is True is space is valid to be occupied, otherwise False\n    # padded with False (boundaries)\n    grid = np.ones((n,m),bool)\n    pad = np.zeros((n+2,m+2),bool)\n\n    # set initial coordinate\n    if not line:\n        # if no line to start from, start at 0,0\n        coor = (0,0)\n    else:\n        # otherwise start at last coordinate of line\n        coor = line[-1][-1]\n        \n        # mark invalid (already occupied) coordinates on grid\n        start = line[0][0]\n        grid[n-start[1]-1, start[0]] = False\n        for segment in line:\n            endSeg = segment[-1]\n            grid[n-endSeg[1]-1, endSeg[0]] = False\n    \n\n        \n        \n    # run until no valid moves left\n    while True:\n\n        # mark coordinates that have been occupied\n        # lineCollections plot inverted so must transform coordinates to match\n        grid[n-coor[1]-1, coor[0]] = False\n\n        # insert grid such that there is 1 cell width boundary of False\n        pad[1:-1,1:-1] = grid\n\n        neighbours = find_neighbours(pad, n-coor[1], coor[0]+1)\n        validOptions = moveOptions[neighbours]\n\n        if not np.any(neighbours):\n            break\n\n        move = np.random.randint(0,len(validOptions))\n        nextCoor = list(coor)\n        nextCoor += validOptions[move]\n        nextCoor = tuple(nextCoor)\n\n        line.append([coor,nextCoor])\n        coor = nextCoor\n        \n    return line","daa1a302":"def calculate_line_variance(line,segLength):\n    i = 0\n    segmentVarianceMeans = np.zeros(len(segLength))\n    for segL in segLength:\n        # segment line into segments of certain length\n        segments = [line[i:i+segL] for i in range(len(line)-(segL-1))]\n\n        # store segment variances\n        segmentVariance = np.zeros(len(segments))\n\n\n        for seg in segments:\n            segmentVariance = np.var(seg)\n            \n        segmentVarianceMeans[i] = segmentVariance.mean()\n        \n    return segmentVarianceMeans.mean()","acb8f980":"## PLAY WITH THESE PARAMETERS ##\n\n#Grid Dimensions\nn = 12\nm = 12\n\n#number of lines to compare in each training cycle\npopulationSize = 1*10**3\n\n#number of training cycles\ngenerations = 100\n\n################################\n\nbestFitness = np.zeros(generations)\n\n # create empty dataframe to populate\nindex = range(populationSize)\ncolumns = ['line','length','variance']\ndata = pd.DataFrame(index=index, columns=columns)\n\nvarSegLength = np.array([3,8,12,24])\n\nfor gen in tqdm(range(generations)):\n\n    # populate dataframe\n    for i in range(populationSize):\n        if gen == 0:\n            line = generate_line([],n,m)\n        else:\n            # slice off end of line at random point \n\n            # max length cut is proportional to training generation \n            longestCut = (varSegLength.min() + 1) + int((gen\/generations)*(len(bestLine)-1))\n            # minimum cut is varSegLength\n            cut = np.random.randint(varSegLength.min()-1,longestCut)\n\n            #regrow line randomly\n            line = generate_line(bestLine[:cut],n,m)\n\n        length = len(line)\n        with warnings.catch_warnings(): \n            warnings.simplefilter('ignore')\n            lineVariance = -(calculate_line_variance(line,varSegLength))\n        data.loc[i]['line'] = line\n        data.loc[i]['length'] = length\n        data.loc[i]['variance'] = lineVariance\n\n    bestFitness[gen] = (data['length'] + data['variance']).max() \n    bestLine = data['line'][(data['length'] + data['variance']) == bestFitness[gen]].values[0]\n\n    \n#PLOT\nplot_line(bestLine,n,m)\nfig, ax = plt.subplots()\nplt.plot(bestFitness,color = 'black')\nplt.xlabel('Training Cycles')\nplt.ylabel('Space Filling')\nax.set_xlim(0,generations)\nplt.savefig('fitness.jpg')\nplt.show()","248a8908":"sns.distplot(pd.to_numeric(data['length']))\nplt.show()","dda471dd":"sns.distplot(pd.to_numeric(-data['variance']))\nplt.show()","1afd9faf":"- Lines are grown by random walk within boundary of grid.\n- Fitness of a line (how well it fills space) is calculated proportional to: line length and variance of segments of line. For calculating variance, line is divided up into segments and the variance of each segment is averaged. This is repeated for segments of different lengths and averaged again.\n- For each generation the best line of the previous generation is cut and a random point and regrown by random walk again."}}