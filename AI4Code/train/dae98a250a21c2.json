{"cell_type":{"2c09b613":"code","412c5472":"code","b4541fc2":"code","8edff334":"code","ff52aed7":"code","ac1c001b":"code","ba0000c8":"code","d2d6fc2f":"code","437af6ac":"code","687b9818":"code","e57f229a":"code","92aaa2b9":"code","bb53f15a":"code","5bef5f5c":"markdown","186dcc5e":"markdown","bb13bc22":"markdown","ba778908":"markdown","0f637bc6":"markdown","867a0930":"markdown","bea7f7f2":"markdown","5c6ab153":"markdown","69e961bd":"markdown","291452e8":"markdown"},"source":{"2c09b613":"import ipywidgets as widgets\nfrom IPython.display import display,HTML,clear_output\nwith open('\/kaggle\/input\/cleaned-medical-ner-graph\/widget.html', 'r') as content_file:\n    content = content_file.read()\n    display(HTML(content))","412c5472":"import random\nfrom pathlib import Path\nimport networkx as nx\nimport pickle","b4541fc2":"G = pickle.load(open('\/kaggle\/input\/medica-negraph\/graph.pkl', 'rb'))\nall_edges = G.edges(data=True)\nedges_to_remove = [edge for edge in all_edges if edge[2]['weight'] < 150]\nprint(len(G.edges()),len(edges_to_remove))\nG.remove_edges_from(edges_to_remove)\nnodes_to_remove = [node[0] for node in G.nodes(data=True) if node[1]['weight'] < 100 ]\n#nodes_to_remove = [node[0] for node in G.nodes(data=True) if '|' in node[0] ]\nG.remove_nodes_from(nodes_to_remove)\nG.remove_nodes_from(list(nx.isolates(G)))\nprint(len(G),len(G.edges()))","8edff334":"def get_top_n_nodes(num):\n    nodes_to_keep = []\n    for t in ['MedicalCondition','Pathogen','Medicine']:\n        mc_nodes = [(n[0],n[1]['weight']) for n in G.nodes(data=True) if n[1]['type'] == t]\n        sorted_entities = sorted(mc_nodes, key=lambda tup: tup[1])\n        sorted_entities.reverse()\n        nodes_to_keep.extend([n[0] for n in sorted_entities[0:num]])\n    return nodes_to_keep","ff52aed7":"def get_top_pathogen_and_treatment(med_condition,path_n,treat_n):\n    try:\n        neighbors = G.neighbors(med_condition)\n        all_nodes = G.nodes[med_condition]\n        pathogens = [(n,G.nodes[n]['weight']) for n in neighbors  if G.nodes[n]['type'] == 'Pathogen' and \"vaccine\" not in n]\n        pathogen_weights = []\n        for p in pathogens:\n            pathogen_weights.append((p[0],G.edges[p[0],med_condition]['weight']))\n        sorted_pathogens = sorted(pathogen_weights, key=lambda tup: tup[1])\n        sorted_pathogens.reverse() \n        neighbors = G.neighbors(med_condition)\n        medicines = [(n,G.nodes[n]['weight']) for n in neighbors  if G.nodes[n]['type'] == 'Medicine' \n                     and 'virus' not in n and \"|\" not in n]     \n        medicine_weights = []\n        for p in medicines:\n            medicine_weights.append((p[0],G.edges[p[0],med_condition]['weight']))\n        sorted_medicines = sorted(medicine_weights, key=lambda tup: tup[1])\n        sorted_medicines.reverse()\n        return (sorted_pathogens[0:path_n],sorted_medicines[0:treat_n])\n    except:\n        return([],[])","ac1c001b":"import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.pyplot import figure\nimport logging\nimport warnings\nimport json\nlogger = logging.getLogger()\nlogger.setLevel(logging.CRITICAL)\nwarnings.filterwarnings('ignore')","ba0000c8":"top_nodes = get_top_n_nodes(40)\narr_ui = []\nfor node in top_nodes:\n    if node[0:3] == 'MC_':\n        #print(node)\n        path,meds = get_top_pathogen_and_treatment(node,4,4)\n        #print(path,meds)\n        arr_ui.append([node[3:],\n                       \", \".join([p[0][3:] for p in path]),\n                       \", \".join([m[0][3:] for m in meds])])","d2d6fc2f":"html_text = '''\n<script>arr={0};function run(){window.setTimeout(function(){var x=parseInt(Math.random()*arr.length); $(\"#a\").text(arr[x][0]).hide().fadeIn(1000);$(\"#b\").text(arr[x][1]).hide().fadeIn(1000);$(\"#c\").text(arr[x][2]).hide().fadeIn(1000);console.log(\"dfsdsdfdsff\");run()},4000)}run();<\/script> \n'''.replace(\"{0}\",json.dumps(arr_ui))\n#display(widgets.HTML(value=html_text))\n#print(html_text)","437af6ac":"def plot_data(condition,pathogens,medicines):    \n    fig, (ax1, ax2) = plt.subplots(1,2);\n    fig.set_size_inches(8.5, 4.5)\n\n    path_name = [p[0][3:] for p in pathogens]\n    count = [p[1] for p in pathogens]\n    y_pos = np.arange(len(path_name))\n    ax1.barh(y_pos, count, align='center');\n    ax1.set_yticks(y_pos);\n    ax1.set_yticklabels(path_name);\n    ax1.invert_yaxis();\n    ax1.set_xlabel('Pathogens');\n    ax1.set_title('Top pathogens');\n    \n    med_name = [p[0][3:] for p in medicines]\n    count2 = [p[1] for p in medicines]\n    y_pos2 = np.arange(len(med_name))\n    ax2.barh(y_pos2, count2, align='center',color='r');\n    ax2.set_yticks(y_pos2);\n    ax2.set_yticklabels(med_name);\n    ax2.invert_yaxis();\n    ax2.set_xlabel('Medication');\n    ax2.set_title('Top medicines');\n    fig.tight_layout();\n    _ = plt.show();\n","687b9818":"\nwtxt = widgets.Text(\n    value='Enter Medical Conditon',\n    disabled=False\n)\n\ncombo = widgets.Combobox(\n    options=[n[0][3:] for n in G.nodes(data=True) if n[1]['type'] == 'MedicalCondition'\n and n[1]['weight'] > 100 and 'virus' not in n[0]],\n    description='',\n    layout={'width': '230px'},\n    disabled=False,\n    placeholder = 'eg. headache,asthama'\n)\nbtn = widgets.Button(\n    description='Search',\n    disabled=False,\n    button_style='info',\n    tooltip='Click me',\n    icon='search' \n)\n\n\ndef on_change(change):\n    clear_output()\n    display(widgets.HBox((widgets.Label(value=\"Enter a medical condition and click search\"),combo,btn)))\n    a,b = get_top_pathogen_and_treatment(\"MC_\"+combo.value,15,15)\n    #print(a,b)\n    newText = combo.value\n    if len(a) > 0 or len(b) > 0:\n        plot_data(combo.value,a,b)\n    else:\n        clear_output()\n        info_section.value =  \"<div>\" + \"no data found for <strong> \" +combo.value + \"<\/strong><\/div>\"        \n        display(widgets.HBox((form_anchor,widgets.Label(value=\"Enter a medical condition and click search\"),combo,btn,info_section)))\n        \nbtn.on_click(on_change)\nform_anchor  = widgets.HTML(value=\"<span id='searchFrm'><\/span>\")\ninfo_section = widgets.HTML(value=\"<span><\/span>\")\n\ndisplay(widgets.HBox((form_anchor,widgets.Label(value=\"Enter a medical condition and click search\"),combo,btn,info_section)))","e57f229a":"G = pickle.load(open('\/kaggle\/input\/medica-negraph\/graph.pkl', 'rb'))\nG = G.subgraph(get_top_n_nodes(30))\nnx.write_gexf(G,'graph4_30.gexf')","92aaa2b9":"labels = [n for n in G.nodes()]\nsource,target,values = [],[],[]\nfor e in G.edges(data=True):\n    if G.nodes[e[0]]['type'] == 'MedicalCondition':\n        target.append(labels.index(e[1]))\n        source.append(labels.index(e[0]))\n    else:\n        target.append(labels.index(e[0]))\n        source.append(labels.index(e[1]))\n    values.append(e[2]['weight'])\n    \ntypes_of_node = list(nx.get_node_attributes(G,'type').values())\n \nfor i in range(0,len(types_of_node)):\n    if types_of_node[i] == 'Medicine':\n        labels[i] = labels[i]+ ' ^'","bb53f15a":"import plotly.graph_objects as go\nimport plotly\n%matplotlib inline\nplotly.offline.init_notebook_mode()\n\nfig = go.Figure(data=[go.Sankey(\n    node = dict(\n      pad = 10,\n      thickness = 50,\n      line = dict(color = \"#dddddd\", width = 0.5),\n      label = [l[3:] for l in labels] ,\n    ),\n    link = dict(\n      source = source, \n      target = target, \n      value = values \n  ))])\n\nfig.update_layout(title_text=\"Relationship between diseases, pathongens and medication^\", font_size=10,height=1000)\ndisplay(widgets.HTML(value=\"<span id='dataViz'><\/span>\"))\nfig.show()\nplotly.offline.plot(fig, filename='relation.html')","5bef5f5c":"Draws basic UI for looking up information about a medical condition","186dcc5e":"# The Approach\n![image.png](attachment:image.png)","bb13bc22":"\n![image.png](attachment:image.png)\n\n> This is still a working draft. Expect dirty code, imcomplete documention and changes every now and then :-)\n\nThis notebook provides a summary of all my work on the CORD-19 Research Dataset . It contains high level details of the techniques I used. The notebook works on the final output of my processing (which is a network graph) and creates two visualuzations:\n* A simple form, where you can search for a disease (medical condition), and see pathogens and medication linked to it. [Click here](#searchFrm) to go to the cell. (\u26a0\ufe0f **Please run the whole notebook before clicking** )\n* A 'Sankey's Diagram' using plotly which shows relationship between most common entities . [Click here](#dataViz) to go to the interactive visualization or [view it as a webpage](relation.html)  ( \u26a0\ufe0f **Please run the whole notebook before clicking** )\n\nThis notebook contains links to other notebooks which contain code to perform individual tasks. I will be making those notebooks public and adding the links soon","ba778908":"The plan was to use NER to find mentions diseases (medical condition), medication and pathogens in every paper. Then I created a graph using this information. Each of the above entities constitute the nodes of the graph. Everytime a (medical_condition,medication) or (medical_condition,pathogen) pair is encountered in a document a node is added to the graph.\n\nBecause of the small training data which I had for training a custom NER tagger, I had to add a cleansing step to remove wrongly identified entities. I used FastText's world embeddings along with a very simple thresholding based scheme. For every NER category, I picked 5 representataive entities. Then for every detected entity, I calculated average of similarity between the detected entity and each of five entitiy. Using a hard threshold I managed to eliminiate many unwanted entities.\n\nThis notebook uses the cleaned graph for generating the above mentioned visualizations","0f637bc6":"This method takes medical condition (disease name) as input and returns top-n pathogens and treatments(medicines) linked to the medical condition. The 'path_n' tells the function max pathogens to fetch and 'treat_n' max medicine names to fetch","867a0930":"# CORD-19 Research Dataset: Analysis & Visualization","bea7f7f2":"# Links to notebooks\n\n* [Training Custom NER Model](https:\/\/www.kaggle.com\/finalepoch\/medical-ner-using-spacy) \n* [Running Custom NER Model and creating entity graph](#)  (Coming soon)\n* [Cleaning NER output using FastText and simple similarity measure](#) (Coming soon)","5c6ab153":"[Open this visualization in a seperate tab of your browser](relation.html)","69e961bd":"Load the 'cleaned graph' and remove all edges with weights less than 200, because we want to limit the data to be shown in visualization","291452e8":"This method plots a bar chart for pathogens and medicines associated with a medicial condition.\nInputs are name of the medical condition and two dictionaries which contain counts for pathogens and medicines"}}