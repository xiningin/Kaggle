{"cell_type":{"3e233599":"code","05eb92cc":"code","71c24ddb":"code","57247193":"code","c10f5a54":"code","19fd5474":"code","9b169283":"code","9c589bb6":"code","ef0ff4d5":"code","62b3ed81":"code","cfaa218f":"code","ef8c8285":"code","c4f01264":"code","16290cb0":"code","d67bcac4":"code","9dd0e3d9":"code","f4a0089d":"code","cf71fd7a":"code","96e6dda0":"code","e8218bce":"code","5b00c0da":"code","b5b3a084":"markdown","97d91420":"markdown","98888436":"markdown","490c80ed":"markdown","b7e28b8c":"markdown","fe44a205":"markdown","86fde573":"markdown","a8d8c53c":"markdown","9c077b17":"markdown","2ee57967":"markdown","e331864c":"markdown","5e3c67f2":"markdown","887209d8":"markdown","eb72bedb":"markdown","abca97de":"markdown","5e8ea8c0":"markdown","999e25f9":"markdown","64425c2b":"markdown","66894c7b":"markdown","065fb982":"markdown","5db89049":"markdown","76785e11":"markdown","adca0736":"markdown","03161005":"markdown","de4a56a1":"markdown"},"source":{"3e233599":"!pip install opencv-contrib-python\nimport numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import figure\nimport os\nimport math\nimport cv2 \ncv2.__version__","05eb92cc":"horse =  r\"\/kaggle\/input\/computer-vision-course\/imagenes\/horse.jpg\"\nlinux = r\"\/kaggle\/input\/opencv-samples-images\/data\/LinuxLogo.jpg\"\nblobs = r\"\/kaggle\/input\/opencv-samples-images\/blobs.jpg\"\nskew_text = r\"..\/input\/opencv-samples-images\/data\/box_in_scene.png\"\nellipse = r\"\/kaggle\/input\/opencv-samples-images\/data\/ellipses.jpg\"\nshapes = r\"\/kaggle\/input\/opencv-samples-images\/data\/pic3.png\"\nsudoku = r\"..\/input\/opencv-samples-images\/data\/sudoku.png\"\nwaldobeach =  r\"\/kaggle\/input\/opencv-samples-images\/WaldoBeach.jpg\"\nfibrolite = r\"..\/input\/microscopic-material-images\/Fibrolite.jpg\"","71c24ddb":"#Read the images and convert to RGB\nimage_1 = cv2.imread(linux)\nimage_1 = cv2.cvtColor(image_1, cv2.COLOR_BGR2GRAY)\nfigure(figsize=(18,16), dpi=30)\nprint(\"original image shape: \",image_1.shape)\nplt.imshow(image_1,cmap=\"gray\")","57247193":"kernel= np.array( [  [-1,-1,-1], [-1,9,-1], [-1,-1,-1] ]  ).astype(\"uint8\") #sharpen\nkernel1 = np.ones((5,5), np.uint8) #blur\nrectKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (9, 5)) #rectangular Kernel\nsqKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7)) # Square kernel","c10f5a54":"BLUR = cv2.GaussianBlur(image_1, (3, 3), 0) # and sigmaX = 0 - Standard deviation value of kernal along horizontal direction.\ndil1 = cv2.dilate(BLUR, kernel1,iterations=1)\ndil2 = cv2.dilate(BLUR, kernel1,iterations=2)\ndil3 = cv2.dilate(BLUR, kernel1,iterations=4)\n\n\ntitles = [\"original\",\"dilation 1 pass\", \"dilation 2 pass\",\"dilation 4 pass\"]\nimages=[BLUR,dil1, dil2,dil3]\nfigure(figsize=(12,8), dpi=70)\n\nfor i in range(4):\n    plt.subplot(2,2,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","19fd5474":"\ndil_k1 = cv2.dilate(BLUR, kernel,iterations=1)\ndil_k2 = cv2.dilate(BLUR, kernel1,iterations=1)\ndil_k3 = cv2.dilate(BLUR, rectKernel,iterations=1)\ndil_k4 = cv2.dilate(BLUR, sqKernel,iterations=1)\n\ntitles = [\"sharpen kernel\",\"blur kernel\", \"Rectangular kernel\",\"Square kernel\"]\nimages=[dil_k1,dil_k2, dil_k3,dil_k4]\nfigure(figsize=(12,8), dpi=70)\n\nfor i in range(4):\n    plt.subplot(2,2,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","9b169283":"BLUR = cv2.GaussianBlur(image_1, (3, 3), 0) # and sigmaX = 0 - Standard deviation value of kernal along horizontal direction.\ner1 = cv2.erode(BLUR, kernel1,iterations=1)\ner2 = cv2.erode(BLUR, kernel1,iterations=2)\ner3 = cv2.erode(BLUR, kernel1,iterations=3)\n\n\ntitles = [\"original\",\"erosion 1 pass\", \"erosion 2 pass\",\"erosion 3 pass\"]\nimages=[BLUR,er1, er2,er3]\nfigure(figsize=(18,10), dpi=70)\n\nfor i in range(4):\n    plt.subplot(2,2,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","9c589bb6":"\ner_k1 = cv2.erode(BLUR, kernel,iterations=1)\ner_k2 = cv2.erode(BLUR, kernel1,iterations=1)\ner_k3 = cv2.erode(BLUR, rectKernel,iterations=1)\ner_k4 = cv2.erode(BLUR, sqKernel,iterations=1)\n\ntitles = [\"original\",\"sharpen kernel\",\"blur kernel\", \"Rectangular kernel\",\"Square kernel\"]\nimages=[BLUR,er_k1,er_k2, er_k3,er_k4]\nfigure(figsize=(18,10), dpi=70)\n\nfor i in range(5):\n    plt.subplot(2,3,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","ef0ff4d5":"#Read the images and convert to RGB\nimage_2 = cv2.imread(fibrolite)\nimage_2 = cv2.cvtColor(image_2, cv2.COLOR_BGR2GRAY)\nfigure(figsize=(18,16), dpi=30)\nprint(\"original image shape: \",image_1.shape)\n\nplt.imshow(image_2,cmap=\"gray\")\ner_k1 = cv2.erode(image_2 , kernel,iterations=1)\n\nfigure(figsize=(18,16), dpi=30)\nclean = (image_2 - er_k1)\nplt.imshow(clean,cmap=\"gray\")","62b3ed81":"BLUR = cv2.GaussianBlur(image_1, (3, 3), 0) # and sigmaX = 0 - Standard deviation value of kernal along horizontal direction.\nop1 = cv2.morphologyEx(BLUR, cv2.MORPH_OPEN, kernel)\nop2 = cv2.morphologyEx(BLUR, cv2.MORPH_OPEN, kernel1)\nop3 = cv2.morphologyEx(BLUR, cv2.MORPH_OPEN, rectKernel)\nop4 = cv2.morphologyEx(BLUR, cv2.MORPH_OPEN, sqKernel)\n\ntitles = [\"original\",\"opening sharpen kernel\", \"opening 3x3 kernel\",\"opening rectangular kernel\",\"openin square kernel\"]\nimages=[BLUR,op1,op2,op3,op4]\nfigure(figsize=(18,10), dpi=70)\n\nfor i in range(5):\n    plt.subplot(2,3,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","cfaa218f":"BLUR = cv2.GaussianBlur(image_1, (3, 3), 0) # and sigmaX = 0 - Standard deviation value of kernal along horizontal direction.\ncl1 = cv2.morphologyEx(BLUR, cv2.MORPH_CLOSE, kernel)\ncl2 = cv2.morphologyEx(BLUR, cv2.MORPH_CLOSE, kernel1)\ncl3 = cv2.morphologyEx(BLUR, cv2.MORPH_CLOSE, rectKernel)\ncl4 = cv2.morphologyEx(BLUR, cv2.MORPH_CLOSE, sqKernel)\n\ntitles = [\"original\",\"Closing sharpen kernel\", \"Closing 3x3 kernel\",\"Closing rectangular kernel\",\"Closing square kernel\"]\nimages=[BLUR,cl1,cl2,cl3,cl4]\nfigure(figsize=(18,10), dpi=70)\n\nfor i in range(5):\n    plt.subplot(2,3,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","ef8c8285":"image_3 = cv2.imread(skew_text)\nimage_3 = cv2.cvtColor(image_3, cv2.COLOR_BGR2GRAY)\n\n\nBLUR = cv2.GaussianBlur(image_3, (3, 3), 0) # and sigmaX = 0 - Standard deviation value of kernal along horizontal direction.\n\nt1 = cv2.morphologyEx(BLUR, cv2.MORPH_TOPHAT, kernel)\nt2 = cv2.morphologyEx(BLUR, cv2.MORPH_TOPHAT, kernel1)\nt3 = cv2.morphologyEx(BLUR, cv2.MORPH_TOPHAT, rectKernel)\nt4 = cv2.morphologyEx(BLUR, cv2.MORPH_TOPHAT, sqKernel)\n\ntitles = [\"original\",\"Tophat sharpen kernel\", \"Tophat 3x3 kernel\",\"Tophat rectangular kernel\",\"Tophat square kernel\"]\nimages=[BLUR,t1,t2,t3,t4]\nfigure(figsize=(24,14), dpi=90)\n\nfor i in range(5):\n    plt.subplot(2,3,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","c4f01264":"BLUR = cv2.GaussianBlur(image_3, (3, 3), 0) # and sigmaX = 0 - Standard deviation value of kernal along horizontal direction.\ng1 = cv2.morphologyEx(BLUR, cv2.MORPH_GRADIENT, kernel)\ng2 = cv2.morphologyEx(BLUR, cv2.MORPH_GRADIENT, kernel1)\ng3 = cv2.morphologyEx(BLUR, cv2.MORPH_GRADIENT, rectKernel)\ng4 = cv2.morphologyEx(BLUR, cv2.MORPH_GRADIENT, sqKernel)\n\ntitles = [\"original\",\"GRADIENT sharpen kernel\", \"GRADIENT 3x3 kernel\",\"GRADIENT rectangular kernel\",\"GRADIENT square kernel\"]\nimages=[BLUR,g1,g2,g3,g4]\nfigure(figsize=(18,10), dpi=70)\n\nfor i in range(5):\n    plt.subplot(2,3,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","16290cb0":"BLUR = cv2.GaussianBlur(image_3, (3, 3), 0) # and sigmaX = 0 - Standard deviation value of kernal along horizontal direction.\nlinblur = BLUR\nbh1 = cv2.morphologyEx(BLUR, cv2.MORPH_BLACKHAT, kernel)\nbh2 = cv2.morphologyEx(BLUR, cv2.MORPH_BLACKHAT, kernel1)\nbh3 = cv2.morphologyEx(BLUR, cv2.MORPH_BLACKHAT, rectKernel)\nbh4 = cv2.morphologyEx(BLUR, cv2.MORPH_BLACKHAT, sqKernel)\n\ntitles = [\"original\",\"BLACKHAT sharpen kernel\", \"BLACKHAT 3x3 kernel\",\"BLACKHAT rectangular kernel\",\"BLACKHAT square kernel\"]\nimages=[BLUR,bh1,bh2,bh3,bh4]\nfigure(figsize=(18,10), dpi=70)\n\nfor i in range(5):\n    plt.subplot(2,3,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","d67bcac4":"BLUR = cv2.GaussianBlur(image_2, (3, 3), 0) # and sigmaX = 0 - Standard deviation value of kernal along horizontal direction.\nkernel0 = np.array(([0, 1, 0], [1, -1, 1], [0, 1, 0]), dtype=\"int\")\nhm1 = cv2.morphologyEx(BLUR, cv2.MORPH_HITMISS, kernel0)\nhm2 = cv2.morphologyEx(BLUR, cv2.MORPH_HITMISS, kernel1)\nhm3 = cv2.morphologyEx(BLUR, cv2.MORPH_HITMISS, rectKernel)\nhm4 = cv2.morphologyEx(BLUR, cv2.MORPH_HITMISS, sqKernel)\n\ntitles = [\"original\",\"HITMISS sharpen kernel\", \"HITMISS 3x3 kernel\",\"HITMISS rectangular kernel\",\"HITMISS square kernel\"]\nimages=[BLUR,hm1,hm2,hm3,hm4]\nfigure(figsize=(18,10), dpi=70)\n\nfor i in range(5):\n    plt.subplot(2,3,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","9dd0e3d9":"from skimage import data\nfrom skimage import color, morphology\nfrom skimage.util import img_as_ubyte\nfrom skimage.morphology import disk, dilation,skeletonize\n\n\nhorse = data.horse()\nsk = skeletonize(horse == 0)\n\ntitles = [\"original\",\"Skeletonize\"]\nimages=[horse,sk]\nfigure(figsize=(18,10), dpi=50)\n\nfor i in range(2):\n    plt.subplot(1,2,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","f4a0089d":"sk1 = skeletonize(linblur == 1)\ntitles = [\"original\",\"Skeletonize\"]\nimages=[linblur,sk1]\nfigure(figsize=(18,10), dpi=50)\n\nfor i in range(2):\n    plt.subplot(1,2,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","cf71fd7a":"from skimage import data\nfrom skimage import color, morphology\nfrom skimage.util import img_as_ubyte\nfrom skimage.morphology import disk, convex_hull_image ,skeletonize\n\nhull = convex_hull_image(horse == 0)\ntitles = [\"original\",\"convex_hull_image\"]\nimages=[horse,hull]\nfigure(figsize=(18,10), dpi=50)\n\nfor i in range(2):\n    plt.subplot(1,2,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","96e6dda0":"hull1 = convex_hull_image(BLUR == 2)\ntitles = [\"original\",\"Convex Hull\"]\nimages=[BLUR,hull1]\nfigure(figsize=(18,10), dpi=50)\n\nfor i in range(2):\n    plt.subplot(1,2,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()","e8218bce":"#Read the images and convert to RGB\nimage_2 = cv2.imread(fibrolite)\nimage_2 = cv2.cvtColor(image_2, cv2.COLOR_BGR2GRAY)\nfigure(figsize=(18,16), dpi=30)\nprint(\"original image shape: \",image_1.shape)\nplt.imshow(image_2,cmap=\"gray\")","5b00c0da":"from skimage import data\nfrom skimage import color, morphology\n\n\nfootprint = morphology.disk(1) #scikit-image\nres = morphology.white_tophat(image_2, footprint) #scikit-image\nclean = (image_2 - res)\n\nmedian_blur = cv2.medianBlur(clean.astype(np.float32),3)\n\ntitles = [\"original\",\"white_tophat\",\"Difference\",\"+Median Blur\"]\nimages=[image_2,res,clean,median_blur]\nfigure(figsize=(20,16), dpi=70)\n\nfor i in range(4):\n    plt.subplot(2,2,i+1), plt.imshow(images[i], \"gray\")\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\nplt.show()\n","b5b3a084":"As the erosion pass increases, the shrink effect increases.","97d91420":"Morphological operations use a small shape or template known as a structuring element.The structuring element is positioned at all possible locations in the image and is compared to\nthe corresponding neighbourhood of pixels. As with convolution kernels, it is common for structuring elements to have odd dimensions. We will define kernels for the morphological operations, we will define 4 different kernels:\n  * 3x3 sharpen kernel\n  * 5x5 blur kernel\n  * 9x5 Rectangular kernel\n  * 7x7 Square kernel\n  \n we wil use the opencv function of:\n >cv2.getStructuringElement(cv2.MORPH_RECT, ( x, y) )","98888436":"Morphology means form and structure. Also known as \u201cmathematical morphology\u201d since the operations are nothing but simple math. A morphological operation is a range of non-linear image processing techniques that deal with the shape or morphology of features in an image. Most morphological analysis techniques operate on BINARY images or GRAY images.","490c80ed":"## ****$\\color{orange}{\\text{Section 1.6 Gradient}}$**** <a class=\"anchor\"  id=\"section1_6\"><\/a>\n\n\n>cv2.morphologyEx(IMAGE, cv2.MORPH_GRADIENT, KERNEL)","b7e28b8c":"Hi everyone! We continue to deep dive to image processing with OpenCV for Computer Vision, it is a long notebook so keep in tune. If you missed the first three parts, you are welcome to reach from here :\n\n* Lesson 1: [OpenCV for Computer Vision 1 - Beginner](https:\/\/www.kaggle.com\/volkandl\/opencv-for-computer-vision-1-beginner)\n* Lesson 2: [OpenCV for Computer Vision 2 - intermediate](https:\/\/www.kaggle.com\/volkandl\/opencv-for-computer-vision-2-intermediate)\n* Lesson 3: [OpenCV for Computer Vision 3 - Contour Detection](https:\/\/www.kaggle.com\/volkandl\/opencv-for-computer-vision-3-contour-detection)\n\n\n","fe44a205":"We will use the opencv function of:\n\n>cv2.dilate(MASK, rectKernel,iterations=1)\n\nAs you can see, wen the iteration number increases the boundries of the features are enlarges more. For removing the noise ( if any ) we will first apply a gaussian blur to the GRAY image.","86fde573":"## ****$\\color{orange}{\\text{Section 1.8 HIT OR MISS}}$**** <a class=\"anchor\"  id=\"section1_8\"><\/a>\n\nThe hit-or-miss transformation serves to detect features in the image that match the shape of the structuring element. However, Hit or Miss operation is too much sensitive to noise, requires exact shape.\n\n\n>cv2.morphologyEx(IMAGE, cv2.MORPH_HITMISS, KERNEL)\n","a8d8c53c":"Kernel size should be selected according to the aim of the operation. ","9c077b17":"#### ****$\\color{Pink}{\\text{Conclusion: Opening vs Closing}}$**** \n\n\n\nThe difference between opening and closing is in the initial iteration, erosion, or dilation.\n\n* Opening is used when the image has many small regions. It shouldn'b be used for narrow regions where there is a chance that the initial erosion operation might disconnect regions.\n* Closing is used when a region has become disconnected and the desire is to restore connectivity. It shouldn't be used when different regions are located closely such that the first iteration of dilation might connect them. For instance it is a killer for OCR applications whereas opening can be beneficial for thight writings for text recognition (OCR).","2ee57967":"## ****$\\color{orange}{\\text{Section 1.10 White Tophat from SCIKIT IMAGE MORPHOLOGY}}$**** <a class=\"anchor\"  id=\"section1_10\"><\/a>","e331864c":"## ****$\\color{orange}{\\text{Section 1.9 Convex hull from SCIKIT IMAGE MORPHOLOGY}}$**** <a class=\"anchor\"  id=\"section1_9\"><\/a>","5e3c67f2":"## ****$\\color{orange}{\\text{Section 1.2 Erosion}}$**** <a class=\"anchor\"  id=\"section1_2\"><\/a>\n\nErosion is the opposite of dilation basically. Morphological erosion shrinks or erodes an image:\n\n* It expands the holes enclosed by a single region and make the gaps between different regions larger.\n\n\n\n*Source for technical information: https:\/\/homepages.inf.ed.ac.uk\/*\n","887209d8":"## ****$\\color{orange}{\\text{Section 1.4 Closing}}$**** <a class=\"anchor\"  id=\"section1_4\"><\/a>\n\nMorphological closing involves the application of dilation, followed by erosion.\n\n* The effect is to smooth boundaries, to join narrow breaks, and to fill small holes caused by noise.\n* Connect disconnected objects.\n\n>cv2.morphologyEx(IMAGE, cv2.MORPH_CLOSE, KERNEL)","eb72bedb":"## ****$\\color{orange}{\\text{Section 1.3 Opening}}$**** <a class=\"anchor\"  id=\"section1_3\"><\/a>\n\nMorphological opening involves the application of erosion, followed by dilation.  \n\n* The effect is to smooth boundaries, to break narrow isthmuses, and to eliminate small noise regions.\n* Separate connected objects, remove small objects.\n\n>cv2.morphologyEx(IMAGE, cv2.MORPH_OPEN, KERNEL)","abca97de":"Extracting the white tophat operated image from the original image may help to reduce the noise.\n\n>clean = (image_2 - res) ","5e8ea8c0":"## ****$\\color{orange}{\\text{Section 1.8 SKELETONIZE from SCIKIT IMAGE MORPHOLOGY}}$**** <a class=\"anchor\"  id=\"section1_8\"><\/a>\n\n\nSkeletonizing is also known as thinning. Morphological skeletonization reduces a region to its minimum number of connected \u201c1\u201d-valued pixels. Skeletonization reduces a region shape to lines that are symmetrically contained within the shape.\n","999e25f9":"## ****$\\color{orange}{\\text{Section 1.7 Black Hat}}$**** <a class=\"anchor\"  id=\"section1_7\"><\/a>\n\nThe black hat operation is used to enhance dark objects of interest in a bright background.\n\n>cv2.morphologyEx(IMAGE, cv2.MORPH_BLACKHAT, KERNEL)","64425c2b":"## ****$\\color{orange}{\\text{Section 1.1 Dilation}}$**** <a class=\"anchor\"  id=\"section1_1\"><\/a>\n\nDilation is the one of the morphological operations. It is typically applied to binary images, but there are versions that work on grayscale images. In opencv it works for both.The basic effect of the operator on a binary image is to gradually enlarge the boundaries of regions of foreground pixels (i.e. white pixels, typically). Thus areas of foreground pixels grow in size while holes within those regions become smaller. [1]\n\nMorphological dilation expands or dilates an image:\n\n* It shrinks the holes enclosed by a single region and make the gaps between different regions smaller.\n* It tends to fill in any small intrusions into a regions boundaries.\n\n\n*Source for technical information: https:\/\/homepages.inf.ed.ac.uk\/*\n\n\n*Source for gif: Wikipedia*","66894c7b":"As the dilation pass increases, dilation affects more on closing operations.","065fb982":"### ****$\\color{orange}{\\text{If You want to be an AI Expert, Knowing Deep learning is never enough alone!}}$****\n\n### $\\color{Pink}{\\text{Table of Contents  }}$\n\n* [Chapter:  Morphology](#chapter1)     \n    * [Section 1.1 Dilation](#section1_1)\n    * [Section 1.2 Erosion ](#section1_2)\n    * [Section 1.3 Opening](#section1_3)\n    * [Section 1.4 Closing](#section1_4)\n    * [Section 1.5 Morphological Gradient ](#section1_5)\n    * [Section 1.6 Top Hat ](#section1_6)\n    * [Section 1.7 Black Hat ](#section1_7)\n    * [Section 1.8 SKELETONIZE from SCIKIT IMAGE MORPHOLOGY ](#section1_8)  \n    * [Section 1.9 Convex hull from SCIKIT IMAGE MORPHOLOGY](#section1_9)      \n    * [Section 1.10 White Tophat from SCIKIT IMAGE MORPHOLOGY ](#section1_10)      \n\n    \n\n****$\\color{pink}{\\text{If You like my work, Please upvote  }}$****\n","5db89049":"#### ****$\\color{orange}{\\text{Section 1.2.1 Contour Extraction by Erosion}}$**** \n\nThe contours are extracted by subtracting the eroded image from the original image. One application of erosion is contour extraction. An image eroded using cellular erosion contains regions lacking boundary pixels.","76785e11":"# ****$\\color{orange}{\\text{Chapter 1. Morphology}}$****  <a class=\"anchor\" id=\"chapter1\"><\/a>\n\n","adca0736":"## ****$\\color{orange}{\\text{Section 1.5 Top Hat}}$**** <a class=\"anchor\"  id=\"section1_5\"><\/a>\n\n\nThe top hat operation is used to enhance bright objects of interest in a dark background. \n\n>cv2.morphologyEx(IMAGE, cv2.MORPH_TOPHAT, KERNEL)","03161005":"![kagglepart4.png](attachment:5705ff9f-4bd5-4d81-b086-8e0fad8a96dc.png)","de4a56a1":"For kernel selection, the bigger kernel is, the more enlarging occurs as you can see  below."}}