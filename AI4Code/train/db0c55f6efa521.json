{"cell_type":{"8593ee3b":"code","f5c57ef4":"code","90b9e282":"code","b937ee07":"code","9fdf3039":"code","a3d1ea7a":"code","b78a6f1c":"code","27fa4e5e":"code","b686614d":"code","3d090277":"code","667edc7c":"code","2e58c543":"code","2d12161c":"code","326645d0":"code","d98364c8":"markdown","deba01a6":"markdown","849d5c23":"markdown"},"source":{"8593ee3b":"import matplotlib.pyplot as plt\nimport numpy as np \nimport os\nimport pandas as pd","f5c57ef4":"from sklearn.model_selection import KFold\nfrom sklearn.preprocessing import LabelEncoder, StandardScaler\nfrom sklearn.model_selection import train_test_split","90b9e282":"from keras.utils import np_utils\nfrom keras.models import Sequential\nfrom keras.layers import LSTM, Dense, BatchNormalization","b937ee07":"from keras.utils import Sequence\nclass SeqGen(Sequence):\n\n    def __init__(self, x_set, y_set, batch_size):\n        self.x, self.y = x_set, y_set\n        self.batch_size = batch_size\n\n    def __len__(self):\n        return int(np.ceil(len(self.x) \/ float(self.batch_size)))\n\n    def __getitem__(self, idx):\n        batch_x = self.x[idx * self.batch_size:(idx + 1) * self.batch_size]\n        batch_y = self.y[idx * self.batch_size:(idx + 1) * self.batch_size]\n\n        return batch_x, batch_y","9fdf3039":"def get_model():\n    model = Sequential()\n    model.add(LSTM(16,input_shape=(11,11), return_sequences=True))    \n    model.add(LSTM(16))  \n    model.add(BatchNormalization())  \n    model.add(Dense(3, activation = 'softmax'))\n    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\n    return model","a3d1ea7a":"def plot_history_accuracy(history):\n    plt.plot(history.history['accuracy'])\n    plt.plot(history.history['val_accuracy'])\n    plt.title('model accuracy')\n    plt.ylabel('accuracy')\n    plt.xlabel('epoch')\n    plt.legend(['train', 'test'], loc='upper left')\n    plt.show()","b78a6f1c":"def plot_history_loss(history):\n    plt.plot(history.history['loss'])\n    plt.plot(history.history['val_loss'])\n    plt.title('model loss')\n    plt.ylabel('loss')\n    plt.xlabel('epoch')\n    plt.legend(['train', 'test'], loc='upper left')\n    plt.show()","27fa4e5e":"def train_model(model, X, Y):\n    x_train, x_test, y_train, y_test = train_test_split( X, Y, test_size=0.3, random_state=42, shuffle=True )\n    standard = StandardScaler().fit(x_train)\n    x_train_standard = standard.transform(x_train).reshape(2016,11,11)\n    x_test_standard = standard.transform(x_test).reshape(864,11,11)\n    return model.fit_generator(SeqGen(x_train_standard,y_train,batch_size=12), validation_data=(x_test_standard,y_test), epochs=20, verbose=1)","b686614d":"df = pd.read_csv('\/kaggle\/input\/eeg-data-from-hands-movement\/Dataset\/user_a.csv', delimiter=',', index_col=False)\ndf.dataframeName = 'dataset.csv'","3d090277":"X = df.iloc[:,1:]\nY = df.iloc[:,0]\nl = ['complement'] * (121 - X.shape[1]) \n\nfor index,col in enumerate(l):\n    X[col+str(index)] = 0\n\nX = X.values\nY = Y.values","667edc7c":"encoder = LabelEncoder()\nencoder.fit(Y)\nencoded_Y = encoder.transform(Y)\ndummy_y = np_utils.to_categorical(encoded_Y)","2e58c543":"model = get_model()\nhistory = train_model(model, X, dummy_y)","2d12161c":"plot_history_accuracy(history)","326645d0":"plot_history_loss(history)","d98364c8":"### Pre-processing","deba01a6":"### Read dataset","849d5c23":"### Simple RNN"}}