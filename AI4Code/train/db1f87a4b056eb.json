{"cell_type":{"91f20994":"code","7d91dd31":"code","1648843d":"code","ace14133":"code","0b96747c":"code","ca1c0eee":"code","811c657a":"code","4be5ac8f":"code","9abed748":"code","2ea843ca":"code","e31060c7":"code","016e62ee":"code","39afb793":"code","9766e90d":"code","55fdae46":"code","5b817d4b":"code","c72b19e0":"markdown","e5eaacda":"markdown","8ff1062c":"markdown","3cbdf5c7":"markdown","6ed31a36":"markdown","8c402503":"markdown","f6845f98":"markdown","865e1d9e":"markdown","53b81f1a":"markdown","f34ceb4e":"markdown","7aa40761":"markdown","45a22277":"markdown","c51bdf06":"markdown"},"source":{"91f20994":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\npd.set_option(\"display.max_colwidth\", None) # setting the maximum width in characters when displaying pandas column. \"None\" value means unlimited.\n\nimport matplotlib.pyplot as plt  # plotting\nfrom glob import glob     # pathname management\n\nimport random    # generating (pseudo)-random numbers\n\nimport matplotlib.mlab as mlab  # some MATLAB commands\nfrom scipy.interpolate import interp1d  # interpolating a 1-D function","7d91dd31":"training_labels_path = '..\/input\/g2net-gravitational-wave-detection\/training_labels.csv'\ntraining_labels = pd.read_csv(training_labels_path)","1648843d":"training_labels.head(3)","ace14133":"training_labels['target'].value_counts()","0b96747c":"training_paths = glob(\"..\/input\/g2net-gravitational-wave-detection\/train\/*\/*\/*\/*\")\nprint(\"The total number of files in the training set:\", len(training_paths))","ca1c0eee":"ids = [path.split(\"\/\")[-1].split(\".\")[0] for path in training_paths]\npaths_df = pd.DataFrame({\"path\":training_paths, \"id\": ids})\ntrain_data = pd.merge(left=training_labels, right=paths_df, on=\"id\")","811c657a":"train_data.head(3)","4be5ac8f":"def load_random_file(signal = None):\n    \"\"\"Selecting a random file from the training dataset. \n    \n    Args:\n        signal: bool\n            optional flag defining whether to select pure detector \n            noise (False) or detector noise plus simulated signal (True).\n            If skipped, the flag is chosen randomly.\n    Returns:\n        file_id: str\n            unique id of the selected file\n        target: int\n            0 or 1, target value\n        data: numpy.ndarray\n            numpy array in the shape (3, 4096), where 3 is the number\n            of detectors, 4096 is number of data points (each time series\n            instance spans over 2 seconds and is sampled at 2048 Hz)\n        \n    \"\"\"    \n    if signal is None:\n        signal = random.choice([True, False])\n        \n    filtered = train_data[\"target\"]==signal   # filtering dataframe based on the target value\n    \n    index = random.choice(train_data[filtered].index)   # random index \n    \n    file_id = train_data['id'].at[index]\n    target = train_data['target'].at[index]\n    path = train_data['path'].at[index]\n    \n    data = np.load(path)\n    \n    return file_id, target, data","9abed748":"file_id, target, data = load_random_file()\nylim = 1.1*np.max(data)\n\nplt.style.use('ggplot')\n\nfig, axs = plt.subplots(ncols=1, nrows=3, figsize=(10, 5))\n\nfor i in range(3):\n    ax = axs.ravel()[i]\n    ax.plot(data[i])\n    ax.margins(0)\n    axs[i].set_title(f\"Detector {i+1}\", loc='center')\n    ax.set_ylabel(f\"Amplitude\")\n    ax.set_ylim([-ylim, ylim])\n    \naxs[0].xaxis.set_visible(False)\naxs[1].xaxis.set_visible(False)\n\naxs[2].set_xlabel(\"Time stamp\")\nfig.suptitle(f\"Raw data visualization. ID: {file_id}. Target: {target}.\")\nplt.show()","2ea843ca":"fs = 2048      # sampling rate\nNFFT = 4*fs    # the Nyquist frequency \nf_min = 20.\nf_max = fs\/2","e31060c7":"_, target, data = load_random_file(True)\n\nstrain1, strain2, strain3 = data[0], data[1], data[2]\n\nPxx_1, freqs = mlab.psd(strain1, Fs = fs, NFFT = NFFT)\nPxx_2, freqs = mlab.psd(strain2, Fs = fs, NFFT = NFFT)\nPxx_3, freqs = mlab.psd(strain3, Fs = fs, NFFT = NFFT)\n\npsd_1 = interp1d(freqs, Pxx_1)\npsd_2 = interp1d(freqs, Pxx_2)\npsd_3 = interp1d(freqs, Pxx_3)\n\nfig, ax = plt.subplots(ncols=1, nrows=1, figsize=(10, 5))\nax.loglog(freqs, np.sqrt(Pxx_1),\"g\",label=\"Detector 1\")\nax.loglog(freqs, np.sqrt(Pxx_2),\"r\",label=\"Detector 2\")\nax.loglog(freqs, np.sqrt(Pxx_3),\"b\",label=\"Detector 3\")\n\nax.set_xlim([f_min, f_max])\nax.set_ylabel(\"ASD (strain\/$\\sqrt{Hz}$)\")\nax.set_xlabel(\"Frequency (Hz)\")\nax.legend()\n\nplt.show()","016e62ee":"!pip -q install pycbc\nimport pycbc","39afb793":"def generate_qtransform(data, fs):\n    \"\"\"Function for generating constant Q-transform. \n    \n    Args:\n        data: numpy.ndarray\n            numpy array in the shape (3, 4096), where 3 is the number\n            of detectors, 4096 is number of data points (each time series\n            instance spans over 2 seconds and is sampled at 2048 Hz)\n        fs: int\n            sampling frequency\n    Returns:\n        times: numpy.ndarray\n            array of time bins\n        freqs: numpy.ndarray\n            array of frequency bins\n        qplanes: list\n            list with 3 elements corresponding to each detector in the raw\n            data file. Each element is a 2-d vector of the power in each \n            time-frequency bin\n    \"\"\"    \n    \n    qplanes = []\n    for i in range(len(data)):\n        \n        # converting data into PyCBC Time Series format\n        ts = pycbc.types.TimeSeries(data[i, :], epoch=0, delta_t=1.0\/fs)   \n        \n        # whitening the data within some frequency range\n        ts = ts.whiten(0.125, 0.125) \n        \n        # calculating CQT values\n        times, freqs, qplane = ts.qtransform(.002, logfsteps=100, qrange=(10, 10), frange=(20, 512))\n\n        qplanes.append(qplane)\n        \n    return times, freqs, qplanes ","9766e90d":"def plot_qtransform(file_id, target, data):\n    \"\"\"Plotting constant Q-transform data.\n    \n    Args:\n        file_id: str\n            unique id of the selected file\n        target: int\n            0 or 1, target value\n        data: numpy.ndarray\n            numpy array in the shape (3, 4096), where 3 is the number\n            of detectors, 4096 is number of data points (each time series\n            instance spans over 2 seconds and is sampled at 2048 Hz)\n    \"\"\"\n    \n    times, freqs, qplanes = generate_qtransform(data, fs=fs)\n    \n    fig, axs = plt.subplots(ncols=1, nrows=3, figsize=(12, 8))\n\n    for i in range(3):\n\n        axs[i].pcolormesh(times, freqs, qplanes[i], shading = 'auto')\n        axs[i].set_yscale('log')\n        axs[i].set_ylabel('Frequency (Hz)')\n        axs[i].set_xlabel('Time (s)')\n        axs[i].set_title(f\"Detector {i+1}\", loc='left')\n        axs[i].grid(False)\n\n    axs[0].xaxis.set_visible(False)\n    axs[1].xaxis.set_visible(False)\n\n    fig.suptitle(f\"Q transform visualization. ID: {file_id}. Target: {target}.\", fontsize=16)\n    plt.show()","55fdae46":"file_id, target, data = load_random_file()\nplot_qtransform(file_id, target, data)","5b817d4b":"file_id = '7945e449f3'\ntarget = 1\ndata  = np.load(train_data[train_data['id']==file_id]['path'].values[0])\n\nplot_qtransform(file_id, target, data)","c72b19e0":"Here we have a sample with a strong GW signal, characterized by a frequency chirp on the CQT spectrogram:","e5eaacda":"\n\nUndoubtedly, one of the most bright breakthroughs in science in the recent decade was the detection of gravitational waves back in 2015. These waves are tiny ripples of the space-time fabric coming from collisions of some super-heavy objects, like black holes or neutron stars, predicted by Einstein 100 years before. The waves can travel billions of light years before hitting the ultra-sensitive instruments, called interferometers. Constructing such a device is the result of immense work by many scientists, engineers, and information science experts from whole over the world. \n\nThe first discovery of gravitational waves was widely outreached in the scientific community, as well as in general audience media. After the first event, more than 50 similar mergers or candidates have been reported. Now, when more and more data is collected, it is needed to more accurately detect GW signals, so that it can help build a more complete picture of our universe.\n\nIn the competition, you have a training set containing simulated time series data coming from three different locations (LIGO Hanford, LIGO Livingston, both in the US, and Virgo, in Italy). Each data file (in .npy format) represents either instrument noise or noise with a simulated gravitational wave signal, and is labeled 0 or 1, respectively. These labels are stored in a different .csv file. The task is to build a system capable of identification time series instances with GW signal present. So, this is a pure **binary classification problem** well known in the ML community. ","8ff1062c":"Now we can select a random data file, perform CQT and plot the results.","3cbdf5c7":"We can conclude that the training dataset is pretty much balanced.","6ed31a36":"To load a random data sample, we can make a helper function.","8c402503":"## Importing libraries\n\nFirst we need to import some libraries required to load and process the data.","f6845f98":"# Constant Q-Transform\n\nAnother very common way to visualize a GW signal is to perform a constant Q-transform (or CQT). This is a time-frequency representation widely used in processing musical data. To quickly perform Q-transform, we are going to use PyCBC library (the docs are available [here](http:\/\/pycbc.org\/pycbc\/latest\/html\/)).","865e1d9e":"We can prepare some helper functions to generate and visualize Q-transforms. Some useful demos with PyCBC methods can be found [here](https:\/\/github.com\/gwastro\/PyCBC-Tutorials).","53b81f1a":"# Welcome to (one more) Exploratory Data Analysis of the G2Net Dataset. \n<img src=\"https:\/\/i.ytimg.com\/vi\/TWqhUANNFXw\/maxresdefault.jpg\" alt=\"title\">\nThe image shows a chirp pattern of gravitational waves detected by LIGO on September 14, 2015.\nCredit: LIGO (http:\/\/www.ligo.org)","f34ceb4e":"# Plotting the raw data in time domain","7aa40761":"# Plotting the data in frequency domain\n\nOne of the ways to explore the frequency components of the data, is to plot the amplitude spectral density. To read more on this topic, please refer to the following link: https:\/\/www.gw-openscience.org\/GW150914data\/LOSC_Event_tutorial_GW150914.html#Whitening","45a22277":"# Importing data. General analysis","c51bdf06":"It turned out to be useful to merge labels and file paths based on their ids."}}