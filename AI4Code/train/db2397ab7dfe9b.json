{"cell_type":{"2838fdf4":"code","373841aa":"code","c83bdb72":"code","8d8aad87":"code","c92c6428":"code","a11e6152":"code","67b75218":"code","8281ebe0":"code","4c33d30b":"code","dd7c774c":"code","2682285e":"code","4c28b977":"code","3b7a38ba":"code","8a31d9f9":"code","24e5216c":"code","05ec1e1d":"code","4b6528d3":"code","41ed9a08":"code","afd15a7b":"code","a60d8535":"code","782925ee":"code","3b96e777":"code","bc6ca6bd":"code","81c27863":"code","cfdf8b62":"code","11c65645":"markdown","aa4b1107":"markdown"},"source":{"2838fdf4":"%load_ext autoreload\n%autoreload 2\n\n%matplotlib inline","373841aa":"import json\nimport os\nimport torch\nfrom torch.utils.data import DataLoader, SequentialSampler, RandomSampler, Dataset\nfrom PIL import Image\nimport torchvision.models as models\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch import optim\nimport torchvision\nimport pandas as pd","c83bdb72":"dic = json.loads(open('\/kaggle\/input\/hackathon-blossom-flower-classification\/cat_to_name.json').read())","8d8aad87":"classes = list(dic.values())","c92c6428":"loader = torchvision.transforms.Compose([torchvision.transforms.ToTensor()])  \n\nroot = r'\/kaggle\/input\/hackathon-blossom-flower-classification\/flower_data\/flower_data\/train'\ntrain_image_files = []\nfor x in os.scandir(root):\n    for y in os.scandir(x):\n        if y.name.endswith(\".jpg\") or x.name.endswith(\".png\") or x.name.endswith(\".JPG\"):\n            train_image_files.append(y.path)\n\nclass train_dataset(Dataset):\n    def __init__(self, train_image_files, dic, classes):\n        self.train_image_files = train_image_files\n        self.dic = dic\n        self.classes = classes\n    def __getitem__(self, i):\n        image_data = Image.open(self.train_image_files[i]).resize((256, 256))\n        image_data = loader(image_data)\n        image_data.to(torch.float)\n        return image_data, self.classes.index(self.dic[self.train_image_files[i].split('\/')[7]])\n    def __len__(self):\n        return len(self.train_image_files)\n\nroot = r'\/kaggle\/input\/hackathon-blossom-flower-classification\/flower_data\/flower_data\/valid\/'\nvalid_image_files = []\nfor x in os.scandir(root):\n    for y in os.scandir(x):\n        if y.name.endswith(\".jpg\") or x.name.endswith(\".png\") or x.name.endswith(\".JPG\"):\n            valid_image_files.append(y.path)\n\nclass valid_dataset(Dataset):\n    def __init__(self, valid_image_files, dic, classes):\n        self.valid_image_files = valid_image_files\n        self.dic = dic\n        self.classes = classes\n    def __getitem__(self, i):\n        image_data = Image.open(self.valid_image_files[i]).resize((256, 256))\n        image_data = loader(image_data)\n        image_data.to(torch.float)\n        return image_data, self.classes.index(self.dic[self.valid_image_files[i].split('\/')[7]])\n    def __len__(self):\n        return len(self.valid_image_files)","a11e6152":"train = train_dataset(train_image_files, dic, classes)\nvalid = valid_dataset(valid_image_files, dic, classes)","67b75218":"train_dl = DataLoader(train, batch_size = 64, shuffle = True, drop_last=True)\nvalid_dl = DataLoader(valid, batch_size = 64, shuffle=False)","8281ebe0":"model = models.resnet34(pretrained=True)\nfc_features = model.fc.in_features\nmodel.fc = nn.Linear(fc_features, 102)","4c33d30b":"from typing import *\n\ndef listify(o):\n    if o is None: return []\n    if isinstance(o, list): return o\n    if isinstance(o, str): return [o]\n    if isinstance(o, Iterable): return list(o)\n    return [o]\ndef accuracy(out, targ): return (torch.argmax(out, dim=1)==targ).float().mean()","dd7c774c":"import re\n\n_camel_re1 = re.compile('(.)([A-Z][a-z]+)')\n_camel_re2 = re.compile('([a-z0-9])([A-Z])')\ndef camel2snake(name): \n    s1 = re.sub(_camel_re1, r'\\1_\\2', name)\n    return re.sub(_camel_re2, r'\\1_\\2', s1).lower()\n\nclass Callback(): \n    _order=0 \n    def set_runner(self, run): self.run=run              \n    def __getattr__(self, k): return getattr(self.run, k) \n    @property\n    def name(self):\n        name = re.sub(r'Callback$', '', self.__class__.__name__)\n        return camel2snake(name or 'callback')\n    #\u5b9a\u4e49Exception\u5f02\u5e38\u7c7b\n    def __call__(self, cb_name):         \n        f = getattr(self, cb_name, None)\n        if f and f(): return True\n        return False\nclass CancelTrainException(Exception): pass     \nclass CancelEpochException(Exception): pass     \nclass CancelBatchException(Exception): pass    ","2682285e":"class TrainEvalCallback(Callback): \n    def begin_fit(self):\n        self.run.n_epochs=0.   \n        self.run.n_iter=0\n    \n    def after_batch(self):\n        if not self.in_train: return\n        self.run.n_epochs += 1.\/self.iters\n        self.run.n_iter   += 1\n        \n    def begin_epoch(self):\n        self.run.n_epochs=self.epoch\n        self.model.train()\n        self.run.in_train=True \n\n    def begin_validate(self):\n        self.model.eval()\n        self.run.in_train=False ","4c28b977":"class Runner():\n    def __init__(self, cbs=None, cb_funcs=None):\n        cbs = listify(cbs)                      \n        for cbf in listify(cb_funcs):           \n            cb = cbf()                          \n            setattr(self, cb.name, cb)          \n            cbs.append(cb)\n        self.stop,self.cbs = False,[TrainEvalCallback()]+cbs\n    @property\n    def opt(self):       return self.learn.opt\n    @property\n    def model(self):     return self.learn.model\n    @property\n    def loss_func(self): return self.learn.loss_func\n    @property\n    def data(self):      return self.learn.data\n\n    def one_batch(self, xb, yb):\n        try:\n            self.xb,self.yb = xb,yb\n            self('begin_batch')\n            self.pred = self.model(self.xb)\n            self('after_pred')\n            self.loss = self.loss_func(self.pred, self.yb)\n            self('after_loss')\n            if not self.in_train: return\n            self.loss.backward()\n            self('after_backward')\n            self.opt.step()\n            self('after_step')\n            self.opt.zero_grad()\n        except CancelBatchException: self('after_cancel_batch') #\n        finally: self('after_batch')\n\n    def all_batches(self, dl):\n        self.iters = len(dl)\n        try:\n            for xb,yb in dl: self.one_batch(xb, yb)\n        except CancelEpochException: self('after_cancel_epoch')\n\n    def fit(self, epochs, learn):\n        self.epochs,self.learn,self.loss = epochs,learn,torch.tensor(0.)\n\n        try:\n            for cb in self.cbs: cb.set_runner(self)\n            self('begin_fit')\n            for epoch in range(epochs):\n                self.epoch = epoch\n                if not self('begin_epoch'): self.all_batches(self.data.train_dl)\n\n                with torch.no_grad(): \n                    if not self('begin_validate'): self.all_batches(self.data.valid_dl)\n                self('after_epoch')\n            \n        except CancelTrainException: self('after_cancel_train')\n        finally:\n            self('after_fit')\n            self.learn = None\n\n    def __call__(self, cb_name):\n        for cb in sorted(self.cbs, key=lambda x: x._order):\n            f = getattr(cb, cb_name, None)                 \n            if f and f(): return True                     \n        return False","3b7a38ba":"class AvgStats():\n    def __init__(self, metrics, in_train): self.metrics,self.in_train = listify(metrics),in_train\n    \n    def reset(self):\n        self.tot_loss,self.count = 0.,0 \n        self.tot_mets = [0.] * len(self.metrics) \n        \n    @property\n    def all_stats(self): return [self.tot_loss.item()] + self.tot_mets \n    @property\n    def avg_stats(self): return [o\/self.count for o in self.all_stats] \n    \n    def __repr__(self): \n        if not self.count: return \"\"\n        return f\"{'train' if self.in_train else 'valid'}: {self.avg_stats}\" \n\n    def accumulate(self, run):\n        bn = run.xb.shape[0]\n        self.tot_loss += run.loss * bn \n        self.count += bn              \n        for i,m in enumerate(self.metrics):\n            self.tot_mets[i] += m(run.pred, run.yb) * bn \n\nclass AvgStatsCallback(Callback):\n    _order = 1\n    def __init__(self, metrics):\n        self.train_stats,self.valid_stats = AvgStats(metrics,True),AvgStats(metrics,False) #train\u6570\u636e\u548cvalid\u6570\u636e\u5206\u522b\u5b9a\u4e49\u4e00\u4e2aAvgStats\n        \n    def begin_epoch(self):\n        self.train_stats.reset()\n        self.valid_stats.reset()\n        \n    def after_loss(self):\n        stats = self.train_stats if self.in_train else self.valid_stats\n        with torch.no_grad(): stats.accumulate(self.run)\n    \n    def after_epoch(self):\n        print(self.train_stats)\n        print(self.valid_stats)","8a31d9f9":"class DataBunch():\n    def __init__(self, train_dl, valid_dl, c=None):\n        self.train_dl,self.valid_dl,self.c = train_dl,valid_dl,c\n        \n    @property\n    def train_ds(self): return self.train_dl.dataset\n        \n    @property\n    def valid_ds(self): return self.valid_dl.dataset","24e5216c":"class Learner():\n    def __init__(self, model, opt, loss_func, data):\n        self.model,self.opt,self.loss_func,self.data = model,opt,loss_func,data","05ec1e1d":"device = torch.device('cuda',0)\ntorch.cuda.set_device(device)","4b6528d3":"class CudaCallback(Callback): \n    def begin_fit(self): self.model.cuda() \n    def begin_batch(self): self.run.xb,self.run.yb = self.xb.cuda(),self.yb.cuda()","41ed9a08":"data = DataBunch(train_dl, valid_dl)\nlearn = Learner(model, optim.SGD(model.parameters(), lr = 0.1), F.cross_entropy, data)\nstats = AvgStatsCallback([accuracy])\nrun = Runner(cbs=stats, cb_funcs =  CudaCallback)","afd15a7b":"run.fit(3, learn)","a60d8535":"torch.save(model, 'model.pkl')","782925ee":"root = r'\/kaggle\/input\/hackathon-blossom-flower-classification\/test set\/test set\/'\ntest_image_files = []\nfor x in os.scandir(root):\n    if x.name.endswith(\".jpg\") or x.name.endswith(\".jpeg\") or x.name.endswith(\".JPG\"):\n        test_image_files.append(x.path)","3b96e777":"test_name = []\ntest_label = []\nfor i in range(len(test_image_files)):\n    image_data = Image.open(test_image_files[i]).convert(\"RGB\").resize((256, 256))\n    image_data = loader(image_data)\n    image_data = image_data.to(torch.float).unsqueeze(0)\n    pred = classes[int(model(image_data.cuda()).argmax())]\n    test_name.append(test_image_files[i].split('\/')[-1]) \n    test_label.append(pred)","bc6ca6bd":"ans = pd.DataFrame([test_name,test_label]).rename({0:'image_name',1:'predict_label'}).T","81c27863":"ans","cfdf8b62":"ans.to_csv('pred.csv')","11c65645":"Some codes are from course.fast.ai.","aa4b1107":"The accuracy of train data set is 0.9983. The accuracy of valid data set is 0.9743."}}