{"cell_type":{"4b73c722":"code","75a936f7":"code","05e4d764":"code","f6856547":"code","cfba673f":"code","6fbfcb6e":"code","0978e5b6":"code","ea84415a":"code","05ff6541":"code","9aef072b":"code","6a798b1f":"code","b519a9f6":"code","3a55a47a":"code","28efd8cc":"code","0ca88f6a":"code","abe05190":"code","4eab958b":"code","0787996b":"code","0fff2aa7":"code","94c5a622":"code","e258ef2c":"code","0cfd79f4":"code","ae8bf315":"code","1d19cb32":"code","e9703e83":"markdown","9801a684":"markdown","a7a17672":"markdown","cdcacac8":"markdown","6e65ec06":"markdown","daf5dc64":"markdown","ca158db0":"markdown","bee0bd04":"markdown","818b967f":"markdown","06b8069f":"markdown","b5fe8f11":"markdown","8c5e2229":"markdown","12b4e3b2":"markdown","970fbbad":"markdown"},"source":{"4b73c722":"import cv2\nimport math\nimport numpy as np\nimport scipy as sp\nimport pandas as pd","75a936f7":"image_path = \"..\/input\/images\/\"\ntrain_path = \"..\/input\/train.csv\"\n\ntrain_data = pd.read_csv(train_path)\n\nsample_index = 5000\nsample_len = 5100","05e4d764":"import plotly.graph_objects as go","f6856547":"fig = go.Figure([go.Pie(labels=train_data.columns[1:],\n           values=train_data.iloc[:, 1:].sum().values)])\nfig.update_layout(title_text=\"Pie chart of targets\", template=\"simple_white\")\nfig.data[0].marker.line.color = 'rgb(0, 0, 0)'\nfig.data[0].marker.line.width = 0.5\nfig.show()","cfba673f":"from tqdm import tqdm\ntqdm.pandas()","6fbfcb6e":"def load_image(image_id):\n    file_path = image_id + \".jpg\"\n    image = cv2.imread(image_path + file_path)\n    return cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\ntrain_images = train_data[\"image_id\"][sample_index:sample_len].progress_apply(load_image)","0978e5b6":"import plotly.express as px","ea84415a":"fig = px.imshow(cv2.resize(train_images[sample_index], (512, 512)))\nfig.show()","05ff6541":"red_values = [np.mean(train_images[sample_index + idx][:, :, 0]) for idx in range(len(train_images))]\ngreen_values = [np.mean(train_images[sample_index + idx][:, :, 1]) for idx in range(len(train_images))]\nblue_values = [np.mean(train_images[sample_index + idx][:, :, 2]) for idx in range(len(train_images))]\nvalues = [np.mean(train_images[sample_index + idx]) for idx in range(len(train_images))]","9aef072b":"import plotly.figure_factory as ff\n\nfig = ff.create_distplot([values], group_labels=[\"Channels\"], colors=[\"purple\"])\nfig.update_layout(showlegend=False, template=\"simple_white\")\nfig.update_layout(title_text=\"Distribution of channel values\")\nfig.data[0].marker.line.color = 'rgb(0, 0, 0)'\nfig.data[0].marker.line.width = 0.5\nfig","6a798b1f":"fig = ff.create_distplot([red_values], group_labels=[\"R\"], colors=[\"red\"])\nfig.update_layout(showlegend=False, template=\"simple_white\")\nfig.update_layout(title_text=\"Distribution of red channel values\")\nfig.data[0].marker.line.color = 'rgb(0, 0, 0)'\nfig.data[0].marker.line.width = 0.5\nfig","b519a9f6":"fig = ff.create_distplot([green_values], group_labels=[\"G\"], colors=[\"green\"])\nfig.update_layout(showlegend=False, template=\"simple_white\")\nfig.update_layout(title_text=\"Distribution of green channel values\")\nfig.data[0].marker.line.color = 'rgb(0, 0, 0)'\nfig.data[0].marker.line.width = 0.5\nfig","3a55a47a":"fig = ff.create_distplot([blue_values], group_labels=[\"B\"], colors=[\"blue\"])\nfig.update_layout(showlegend=False, template=\"simple_white\")\nfig.update_layout(title_text=\"Distribution of blue channel values\")\nfig.data[0].marker.line.color = 'rgb(0, 0, 0)'\nfig.data[0].marker.line.width = 0.5\nfig","28efd8cc":"fig = go.Figure()\n\nfor idx, values in enumerate([red_values, green_values, blue_values]):\n    if idx == 0:\n        color = \"Red\"\n    if idx == 1:\n        color = \"Green\"\n    if idx == 2:\n        color = \"Blue\"\n    fig.add_trace(go.Box(x=[color]*len(values), y=values, name=color, marker=dict(color=color.lower())))\n    \nfig.update_layout(yaxis_title=\"Mean value\", xaxis_title=\"Color channel\",\n                  title=\"Mean value vs. Color channel\", template=\"plotly_white\")","0ca88f6a":"fig = ff.create_distplot([red_values, green_values, blue_values],\n                         group_labels=[\"R\", \"G\", \"B\"],\n                         colors=[\"red\", \"green\", \"blue\"])\nfig.update_layout(title_text=\"Distribution of red channel values\", template=\"simple_white\")\nfig.data[0].marker.line.color = 'rgb(0, 0, 0)'\nfig.data[0].marker.line.width = 0.5\nfig.data[1].marker.line.color = 'rgb(0, 0, 0)'\nfig.data[1].marker.line.width = 0.5\nfig.data[2].marker.line.color = 'rgb(0, 0, 0)'\nfig.data[2].marker.line.width = 0.5\nfig","abe05190":"import matplotlib.pyplot as plt","4eab958b":"def visualize_leaves(cond=[0, 0, 0, 0], cond_cols=[\"healthy\"], is_cond=True):\n    if not is_cond:\n        cols, rows = 3, min([3, len(train_images)\/\/3])\n        fig, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(30, rows*20\/3))\n        for col in range(cols):\n            for row in range(rows):\n                ax[row, col].imshow(train_images.loc[train_images.index[-row*3-col-1]])\n        return None\n        \n    cond_0 = \"healthy == {}\".format(cond[0])\n    cond_1 = \"scab == {}\".format(cond[1])\n    cond_2 = \"rust == {}\".format(cond[2])\n    cond_3 = \"multiple_diseases == {}\".format(cond[3])\n    \n    cond_list = []\n    for col in cond_cols:\n        if col == \"healthy\":\n            cond_list.append(cond_0)\n        if col == \"scab\":\n            cond_list.append(cond_1)\n        if col == \"rust\":\n            cond_list.append(cond_2)\n        if col == \"multiple_diseases\":\n            cond_list.append(cond_3)\n    \n    data = train_data.loc[sample_index:sample_len]\n    for cond in cond_list:\n        data = data.query(cond)\n        \n    #images = train_images.loc[list(data.index)]\n    images = train_images.loc[sample_index:sample_len]\n    cols, rows = 3, min([3, len(images)\/\/3])\n    \n    fig, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(30, rows*20\/3))\n    for col in range(cols):\n        for row in range(rows):\n            ax[row, col].imshow(images.loc[images.index[row*3+col]])\n    plt.show()","0787996b":"visualize_leaves(cond=[1, 0, 0, 0], cond_cols=[\"healthy\"])","0fff2aa7":"scab_sample_index = 5289\nscab_sample_end = 5389\n\ntrain_images = train_data[\"image_id\"][scab_sample_index:scab_sample_end].progress_apply(load_image)","94c5a622":"def visualize_leaves(cond=[0, 0, 0, 0], cond_cols=[\"healthy\"], is_cond=True):\n    if not is_cond:\n        cols, rows = 3, min([3, len(train_images)\/\/3])\n        fig, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(30, rows*20\/3))\n        for col in range(cols):\n            for row in range(rows):\n                ax[row, col].imshow(train_images.loc[train_images.index[-row*3-col-1]])\n        return None\n        \n    cond_0 = \"healthy == {}\".format(cond[0])\n    cond_1 = \"scab == {}\".format(cond[1])\n    cond_2 = \"rust == {}\".format(cond[2])\n    cond_3 = \"multiple_diseases == {}\".format(cond[3])\n    \n    cond_list = []\n    for col in cond_cols:\n        if col == \"healthy\":\n            cond_list.append(cond_0)\n        if col == \"scab\":\n            cond_list.append(cond_1)\n        if col == \"rust\":\n            cond_list.append(cond_2)\n        if col == \"multiple_diseases\":\n            cond_list.append(cond_3)\n    \n    data = train_data.loc[scab_sample_index:scab_sample_end]\n    for cond in cond_list:\n        data = data.query(cond)\n        \n    #images = train_images.loc[list(data.index)]\n    images = train_images.loc[scab_sample_index:scab_sample_end]\n    cols, rows = 3, min([3, len(images)\/\/3])\n    \n    fig, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(30, rows*20\/3))\n    for col in range(cols):\n        for row in range(rows):\n            ax[row, col].imshow(images.loc[images.index[row*3+col]])\n    plt.show()","e258ef2c":"visualize_leaves(cond=[0, 1, 0, 0], cond_cols=[\"scab\"])","0cfd79f4":"rust_sample_index = 5919\nrust_sample_end = 6019\n\ntrain_images = train_data[\"image_id\"][rust_sample_index:rust_sample_end].progress_apply(load_image)","ae8bf315":"def visualize_leaves(cond=[0, 0, 0, 0], cond_cols=[\"healthy\"], is_cond=True):\n    if not is_cond:\n        cols, rows = 3, min([3, len(train_images)\/\/3])\n        fig, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(30, rows*20\/3))\n        for col in range(cols):\n            for row in range(rows):\n                ax[row, col].imshow(train_images.loc[train_images.index[-row*3-col-1]])\n        return None\n        \n    cond_0 = \"healthy == {}\".format(cond[0])\n    cond_1 = \"scab == {}\".format(cond[1])\n    cond_2 = \"rust == {}\".format(cond[2])\n    cond_3 = \"multiple_diseases == {}\".format(cond[3])\n    \n    cond_list = []\n    for col in cond_cols:\n        if col == \"healthy\":\n            cond_list.append(cond_0)\n        if col == \"scab\":\n            cond_list.append(cond_1)\n        if col == \"rust\":\n            cond_list.append(cond_2)\n        if col == \"multiple_diseases\":\n            cond_list.append(cond_3)\n    \n    data = train_data.loc[scab_sample_index:scab_sample_end]\n    for cond in cond_list:\n        data = data.query(cond)\n        \n    #images = train_images.loc[list(data.index)]\n    images = train_images.loc[rust_sample_index:rust_sample_end]\n    cols, rows = 3, min([3, len(images)\/\/3])\n    \n    fig, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(30, rows*20\/3))\n    for col in range(cols):\n        for row in range(rows):\n            ax[row, col].imshow(images.loc[images.index[row*3+col]])\n    plt.show()","1d19cb32":"visualize_leaves(cond=[0, 0, 1, 0], cond_cols=[\"rust\"])","e9703e83":"## Visualize sample leaves","9801a684":"### Healthy","a7a17672":"### Blue channel values","cdcacac8":"## Channel distributions","6e65ec06":"### scab","daf5dc64":"### Sample Image","ca158db0":"# Load images","bee0bd04":"### Red channel values","818b967f":"### Green channel values","06b8069f":"### All channel values","b5fe8f11":"### All channel values","8c5e2229":"### rust","12b4e3b2":"# Pie chart","970fbbad":"# Introduction\n\nIt is basic EDA for PlantPathology Apple Dataset.\n\nEnjoy it! :)\n\n\n<br\/>\n**references**\n* https:\/\/www.kaggle.com\/tarunpaparaju\/plant-pathology-2020-eda-models"}}