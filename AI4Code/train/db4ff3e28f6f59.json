{"cell_type":{"97e389ae":"code","34736fbc":"code","9494898d":"code","6a2f8510":"code","303ed20e":"code","fa0375ba":"code","f746e573":"code","f77db68f":"code","e33c9e29":"code","4dd6f5e0":"code","dfe9746b":"code","ebde9d33":"code","b3f5670d":"code","7d93200b":"code","4ed407a9":"code","58bb81eb":"markdown","42c1fa4b":"markdown","9926f28a":"markdown","d4c8c93c":"markdown","03fd68e8":"markdown","ee57da7f":"markdown","f1138986":"markdown","c6418b98":"markdown","f6e1879b":"markdown","b2a430fb":"markdown","b192e2c3":"markdown","43e8a1ce":"markdown","dfd751c4":"markdown","1165c00f":"markdown","c623c1a6":"markdown","af01855d":"markdown","db7fb569":"markdown"},"source":{"97e389ae":"import random \nimport math \nimport numpy as np\nfrom datetime import datetime\nimport numba as nb\nimport matplotlib.pyplot as plt \nimport seaborn as sns \nplt.style.use('seaborn-dark')\n\ndef timer(func,num):\n    \"\"\"Accepts a function and arguments for that function\n    params:\n    ======\n    func: A function \n    num: Argument of this function \n    retuns: Time elapsed by this function \n    \"\"\"\n    start_time = datetime.now()\n    func(num)\n    end_time = datetime.now()\n    print('.> ', end = \"\")\n    return (end_time - start_time).total_seconds()\n\ndef example_function_python(num):\n    # create two lists \n    X = []\n    Y = []\n    \n    # fill to make a matrix if dimension num X 40 \n    for i in range(num):\n        # for first list take the square root of random number  \n        X.append([math.sqrt(random.randint(1,1000)) for _ in range(num)])\n        # for the second number take exponential of that integer \n        Y.append([math.sqrt(random.randint(1,1000)) for _ in range(num)])\n    \n    # generate matrix to hold these numbers \n    Z = [[0 for _ in range(len(Y[0]))] for _ in range(len(X))]\n    #print(np.array(X).shape, np.array(Y).shape, np.array(Z).shape)\n    \n    # perform matrix multiplication logic \n    for i in range(len(X)): \n        \n        for j in range(len(Y[0])): \n            for k in range(len(Y)):\n                Z[i][j] += X[i][k]*Y[k][j]\n    return Z ","34736fbc":"plain_python = [timer(example_function_python,num) for num in range(0,1000,100)]","9494898d":"import matplotlib.pyplot as plt \nplt.style.use('seaborn-dark')\nplt.figure(dpi = 120)\nplt.plot(range(0,1000,100), plain_python)\nplt.xlabel(\"Number of Iterations\")\nplt.ylabel(\"Seconds\")","6a2f8510":"def example_function_numpy(num):\n    X = np.sqrt(np.random.randint(1,1000,size = (num,num))) \n    Y = np.sqrt(np.random.randint(1,1000,size = (num,num))) \n    return np.dot(X,Y)\nnumpy = [timer(example_function_numpy,num) for num in range(0,1000,100)]\nplt.figure(dpi = 120)\nplt.plot(range(0,1000,100), numpy)\nplt.xlabel(\"Number of Iterations\")\nplt.ylabel(\"Seconds\")","303ed20e":"numba_jit = nb.jit(example_function_python)\n%time z = numba_jit(1000)","fa0375ba":"numba_njit = nb.njit(example_function_python)\nnumba_list = [timer(numba_njit,num) for num in range(0,1000,100)]\nplt.figure(dpi = 120)\nplt.plot(range(0,1000,100), numba_list)\nplt.xlabel(\"Number of Iterations\")\nplt.ylabel(\"Seconds\")","f746e573":"numba_njit = nb.njit(example_function_python, parallel = True)\n%time z = numba_njit(1000) ","f77db68f":"@nb.njit()\ndef example_function_numba(num):\n    # create two lists \n    X = np.sqrt(np.random.randint(1,1000,size = (num,num))) \n    Y = np.sqrt(np.random.randint(1,1000,size = (num,num))) \n    \n    \n    # generate matrix to hold these numbers \n    Z = np.zeros_like(X)\n    for i in range(len(X)): \n        \n        for j in range(len(Y[0])): \n            for k in range(len(Y)):\n                Z[i][j] += X[i][k]*Y[k][j]\n    return Z \n\njit_time =timer(example_function_numba,1000)\nprint(jit_time)\n\nnumba_numpy_list = [timer(example_function_numba,num) for num in range(0,1000,100)]\nplt.figure(dpi = 120)\nplt.plot(range(0,1000,100), numba_numpy_list)\nplt.xlabel(\"Number of Iterations\")\nplt.ylabel(\"Seconds\")","e33c9e29":"import matplotlib.pyplot as plt \nplt.style.use('seaborn-dark')\nplt.figure(dpi = 120)\nplt.plot(range(0,1000,100), [0.0,\n 0.214097,\n 1.588295,\n 5.530069,\n 13.584038,\n 27.472998,\n 47.856996,\n 77.211966,\n 117.906999,\n 179.297997], label = 'plain python'\n)\n\n\n\nplt.plot(range(0,1000,100), numba_numpy_list, label = 'numpy numba')\nplt.xlabel(\"Number of Iterations\")\nplt.ylabel(\"Seconds\")\n\n\nplt.plot(range(0,1000,100), numba_list, label = 'numba python')\nplt.xlabel(\"Number of Iterations\")\nplt.ylabel(\"Seconds\")\n\nplt.xlabel(\"Number of Iterations\")\nplt.ylabel(\"Seconds\")\nplt.legend()","4dd6f5e0":"def ewma_python_numpy(x,alpha): \n    \"\"\"\n    x: value of series in the current time period\n    \n    alpha: The parameter decides how important \n    the current observation is in the calculation of ewma, the \n    higher value of alpha more closely ewma tracks the original \n    series \n    EWMA(t) = alpha * x(t) + (1 - alpha)*EWMA(t-1)\n    \"\"\"\n    y = np.zeros_like(x) \n    y[0] = x[0] \n    for i in range(1, len(x)): \n        y[i] = alpha * x[i] + (1 - alpha) * y[i - 1] \n    return y ","dfe9746b":"example_array = np.random.random(size = 1000000) +1\n%time z = ewma_python_numpy(example_array,0.2)","ebde9d33":"@nb.njit()\ndef ewma_python_numba(x,alpha): \n    \"\"\"\n    x: value of series in the current time period\n    \n    alpha: The parameter decides how important \n    the current observation is in the calculation of ewma, the \n    higher value of alpha more closely ewma tracks the original \n    series \n    EWMA(t) = alpha * x(t) + (1 - alpha)*EWMA(t-1)\n    \"\"\"\n    y = np.zeros_like(x) \n    y[0] = x[0] \n    for i in range(1, len(x)): \n        y[i] = alpha * x[i] + (1 - alpha) * y[i - 1] \n    return y ","b3f5670d":"%time y = ewma_python_numba(example_array,0.2)","7d93200b":"def monte_carlo_py(num):\n    in_circle = 0 \n    for i in range(num): \n        x = random.random()\n        y = random.random()\n        if x**2 + y**2 < 1.0: \n            in_circle+= 1 \n    return 4* (in_circle\/num)\n%time z = monte_carlo_py(10000000)","4ed407a9":"@nb.njit()\ndef monte_carlo_numba(num):\n    in_circle = 0 \n    for i in range(num): \n        x = random.random()\n        y = random.random()\n        if x**2 + y**2 < 1.0: \n            in_circle+= 1 \n    return 4* (in_circle\/num)\n%time z = monte_carlo_numba(10000000)","58bb81eb":"#### Lets compare the above methods we used to speed up\nWe observe that numba combined with numpy vector performed the best.","42c1fa4b":"#### Using No-Python Mode \n1. The Numba @jit decorator fundamentally operates in two compilation modes, nopython mode and object mode. In the below example @njit decorator is used which is equavalent to @jit(nopython-True); this is instructing Numba to operate in nopython mode. The behaviour of the nopython compilation mode is to essentially compile the decorated function so that it will run entirely without the involvement of the Python interpreter. This is the recommended and best-practice way to use the Numba jit decorator as it leads to the best performance.\n\n2. The below example took 1 second less than @jit method.","9926f28a":"## Example 2 Calculating EWMA\n1. The Exponentially Weighted Moving Average (EWMA) is a quantitative or statistical measure used to model or describe a time series. The EWMA is widely used in finance, the main applications being technical analysis and volatility modeling.\n2. The EWMA is a recursive function, which means that the current observation is calculated using the previous observation. The EWMA\u2019s recursive property leads to the exponentially decaying weights as shown below:","d4c8c93c":"\n#### Using Numba JIT compiler we can observe it only took 16 seconds to run as opposed to python one which took 175 seconds. I recommend using decorator instead of calling function in this way but for simplicity and not to repete the code more than one time i am using the below method to call the function.","03fd68e8":"## 4. Numba + Numpy, Replacing the lists with numpy vectors and boom it just took 2 seconds for execution. \n","ee57da7f":"## 2. Using numpy approach \nAs we can see code in numpy is sweet, simple and super fast ","f1138986":"## The main goal of this article is to show how you can easily speed up your code 100 times faster than native python version.\n\n### We will be looking at 4 methods to write code and verify which method is better with respect to other methods.\n1. Plain Vanilla Python \n2. Numpy \n3. Numba \n4. Numba + Numpy ","c6418b98":"### Other Options\n1. **nogil**:  tries to release the global interpreter lock inside the compiled function. The GIL will only be released if Numba can compile the function in nopython mode, otherwise a compilation warning will be printed.\n2. **parallel**: If true, parallel enables the automatic parallelization of a number of common Numpy constructs as well as the fusion of adjacent parallel operations to maximize cache locality.\n3. **fastmath**: If true, fastmath enables the use of otherwise unsafe floating point transforms as described in the LLVM documentation","f6e1879b":"## 1. Plain Vanilla Python\nThis function will generate two random matrix and multiply them as we can observe this function has very high time complexity \nand space complexity please ignore the working of this function as it only for demonstration.","b2a430fb":"## 3. Using Numba The super-star of this show.\n1. Numba is a package that allows the dynamic compiling of pure Python code by the use of LLVM. The application in a simple case, like the one at hand, is surprisingly straightforward and the dynamically compiled function\n\n2. Numba uses just in time compiler which essentially translates Python functions to optimized machine code at runtime using the industry-standard LLVM compiler library. i.e All the heavy loop lifting is handeled by llvm\n\n2. When a call is made to a Numba decorated function it is compiled to machine code \u201cjust-in-time\u201d for execution and all or part of your code can subsequently run at native machine code speed!\n```python\nimport numba as nb\n@nb.jit()\ndef example_function_numba(num):\n        pass \n```","b192e2c3":"### And look at that speed boost 145 times faster than generic code.","43e8a1ce":"#### using parallel=True\n1. Setting the parallel option for njit() enables a Numba transformation pass that attempts to automatically parallelize and perform other optimizations on (part of) a function. this feature only works on CPUs.\n2. But this function will only work if the code is parallellizable but below function is not parallelizable.","dfd751c4":"$\\large ewma_{t}=\\alpha * r_{t} + (1 - \\alpha ) * ewma_{t - 1}$\n1. alpha = weight \n2. r = value of time series in current time period ","1165c00f":"1. The above is a unit circle with radius 1 hence the area of the circle is =  $\\pi *(1^{2})$\n2. And the square has side of length 2. Hence its area = 4. \n\n$ \\large eq1: \\frac{Area_{Circle}}{Area_{Square}} = \\frac{inside\\ points\\ of\\ circle}{inside\\ points\\ of\\ square\\ and\\ circle}$\n<br>\n$ \\large eq2: \\frac{\\pi}{4} = \\frac{inside\\ points\\ of\\ circle}{inside\\ points\\ of\\ square\\ and\\ circle}$\n<br>\n$ \\large eq3: \\pi = \\frac{4 * inside\\ points\\ of\\ circle}{inside\\ points\\ of\\ square\\ and\\ circle}$\n<br> \n$\\large The\\ point\\ lies\\ inside\\ the\\ circle\\ if\\ the\\ equation\\ is\\ satisfied.$\n$\\large x^{2} + y^{2} < 1.0$","c623c1a6":"## Example 3 Calculating pi using monte carlo method.\nLet's  Consider this circle with radius 1 inscribed inside a square with area 4","af01855d":"### Conclusion\n1. Although numba seems a good substitute it cannot be used for all tasks. \n2. Numba only supports python core data structures and numpy arrays. \n3. There is no way to interact with python and its modules in nopython mode. \n4. There is limited support for classes.\n","db7fb569":"![image.png](attachment:image.png)"}}