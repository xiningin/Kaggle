{"cell_type":{"26642891":"code","3fc229cd":"code","8efa1c29":"code","15673429":"code","068eb748":"code","c5a244dc":"code","22835067":"code","cdef28e7":"code","7717db8a":"code","3f4ab79a":"code","5583dccc":"code","1046d2c1":"code","743a03ac":"code","906701b1":"code","d6437c9a":"code","f21a05fd":"code","1a79395e":"code","adb1b442":"code","d61d28a3":"code","ae983e0d":"code","eac64fe4":"code","8da84108":"code","9087a6c5":"code","38d1b7f0":"code","3185b762":"code","2f5755b8":"code","1a757729":"code","03bf94d7":"code","73c56317":"code","970725c3":"code","e209c2a2":"code","38286e0e":"code","4a8dbe31":"code","97c32f37":"code","b2d41030":"code","e472dadd":"code","36c9a747":"code","a925ea72":"code","7610ceb3":"code","eb29daaa":"code","2d2c7935":"code","56bcff74":"code","eecd688c":"code","06dd24bf":"markdown","f9457339":"markdown","db86edc0":"markdown","bc1b67aa":"markdown","bccb616e":"markdown","68f010b5":"markdown","4111643c":"markdown","f310e085":"markdown","e180f17b":"markdown","9f019ab9":"markdown","8d7f9429":"markdown","d14a08a4":"markdown","4df74317":"markdown","72736b2b":"markdown","ce52eadf":"markdown","a63b058b":"markdown","f0b1ca0e":"markdown","7526eb89":"markdown","3d42240a":"markdown","08237f90":"markdown","2e6833a1":"markdown","e3e5203a":"markdown","c3e94398":"markdown","68a64c9c":"markdown","025d6f9c":"markdown","37f32f87":"markdown","80520d4a":"markdown","bed249a7":"markdown"},"source":{"26642891":"# importing librabries\n\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn import preprocessing\nfrom sklearn.metrics import confusion_matrix","3fc229cd":"# Loading data\n\ndf_train = pd.read_csv('..\/input\/loan-prediction-problem-dataset\/train_u6lujuX_CVtuZ9i.csv')\ndf_test = pd.read_csv('..\/input\/loan-prediction-problem-dataset\/test_Y3wMUE5_7gLdaTN.csv')","8efa1c29":"# inspecting loaded data\n\ndf_train.head()","15673429":"# inspecting size of the dataset\ndf_train.shape","068eb748":"# making missing value data frame\n\nmissing_df_train = df_train.isnull()\nmissing_df_test = df_test.isnull()","c5a244dc":"# finding all missing values in training data\n\nfor column in missing_df_train.columns.values.tolist():\n    print(column)\n    print(missing_df_train[column].value_counts())\n    print()","22835067":"# finding all missing values in testing data\n\nfor column in missing_df_test.columns.values.tolist():\n    print(column)\n    print(missing_df_test[column].value_counts())\n    print()","cdef28e7":"# filling missing values in training data\n\ndf_train['Gender'].fillna(df_train['Gender'].mode()[0], inplace = True)\ndf_train['Married'].fillna(df_train['Married'].mode()[0], inplace = True)\ndf_train['Dependents'].fillna(df_train['Dependents'].mode()[0], inplace = True)\ndf_train['Self_Employed'].fillna(df_train['Self_Employed'].mode()[0], inplace = True)\ndf_train['LoanAmount'].fillna(df_train['LoanAmount'].median(), inplace = True)\ndf_train['Loan_Amount_Term'].fillna(df_train['Loan_Amount_Term'].mode()[0], inplace = True)\ndf_train['Credit_History'].fillna(df_train['Credit_History'].mode()[0], inplace = True)","7717db8a":"# filling missing values in test data\n\ndf_test['Gender'].fillna(df_test['Gender'].mode()[0], inplace = True)\ndf_test['Dependents'].fillna(df_test['Dependents'].mode()[0], inplace = True)\ndf_test['Self_Employed'].fillna(df_test['Self_Employed'].mode()[0], inplace = True)\ndf_test['LoanAmount'].fillna(df_test['LoanAmount'].median(), inplace = True)\ndf_test['Loan_Amount_Term'].fillna(df_test['Loan_Amount_Term'].mode()[0], inplace = True)\ndf_test['Credit_History'].fillna(df_test['Credit_History'].mode()[0], inplace = True)","3f4ab79a":"sns.countplot(x = df_train['Gender'], hue = df_train['Married'])","5583dccc":"sns.countplot(x = df_train['Gender'], hue = df_train['Loan_Status'])","1046d2c1":"sns.scatterplot(x = df_train['LoanAmount'], y = df_train['ApplicantIncome'], hue = df_train['Loan_Status'])","743a03ac":"sns.countplot(x = df_train['Married'], hue = df_train['Loan_Status'])","906701b1":"sns.countplot(x = df_train['Property_Area'], hue = df_train['Loan_Status'])","d6437c9a":"sns.countplot(x = df_train['Self_Employed'],hue = df_train['Loan_Status'])","f21a05fd":"sns.countplot(x = df_train['Education'], hue = df_train['Loan_Status'])","1a79395e":"sns.heatmap(df_train.corr(),annot=True)","adb1b442":"sns.countplot(x = df_train['Loan_Amount_Term'], hue = df_train['Loan_Status']).set_yscale('log')","d61d28a3":"fig, ax = plt.subplots(2, 4, figsize = (20, 10))\nsns.countplot(x = df_train['Gender'], ax = ax[0][0])\nsns.countplot(x = df_train['Married'], ax = ax[0][1])\nsns.countplot(x = df_train['Dependents'], ax = ax[0][2])\nsns.countplot(x = df_train['Education'], ax = ax[0][3])\nsns.countplot(x = df_train['Self_Employed'], ax = ax[1][0])\nsns.countplot(x = df_train['Loan_Amount_Term'], ax = ax[1][1]).set_yscale('log')\nsns.countplot(x = df_train['Credit_History'], ax = ax[1][2])\nsns.countplot(x = df_train['Property_Area'], ax = ax[1][3])","ae983e0d":"status_counts = df_train['Loan_Status'].value_counts()\nprint(\"Percentage of Y: \", end = ' ')\nprint(status_counts[0] \/ (status_counts[0] + status_counts[1]) * 100)\nprint(\"Percentage of N: \", end = ' ')\nprint(status_counts[1] \/ (status_counts[0] + status_counts[1]) * 100)","eac64fe4":"df_train = df_train[df_train['ApplicantIncome'] <= 20000]\ndf_train = df_train[df_train['LoanAmount'] <= 400]\ndf_train.shape","8da84108":"sns.scatterplot(x = df_train['LoanAmount'], y = df_train['ApplicantIncome'], hue = df_train['Loan_Status'])","9087a6c5":"# Dropping coapplicant income data\n\ndf_train = df_train.drop(labels = ['CoapplicantIncome'], axis = 1)\ndf_test = df_test.drop(labels = ['CoapplicantIncome'], axis = 1)","38d1b7f0":"# Label encoding training data since all these features have some priority\n\nlabel_encoder = preprocessing.LabelEncoder()\ndf_train['Loan_Status'] = label_encoder.fit_transform(df_train['Loan_Status'])\ndf_train['Married'] = label_encoder.fit_transform(df_train['Married'])\ndf_train['Education'] = label_encoder.fit_transform(df_train['Education'])\ndf_train['Dependents'] = label_encoder.fit_transform(df_train['Dependents'])\ndf_train['Self_Employed'] = label_encoder.fit_transform(df_train['Self_Employed'])\ndf_train['Property_Area'] = label_encoder.fit_transform(df_train['Property_Area'])\ndf_train['Gender'] = label_encoder.fit_transform(df_train['Gender'])","3185b762":"# Label encoding test data since all these features have some priority\n\nlabel_encoder = preprocessing.LabelEncoder()\ndf_test['Married'] = label_encoder.fit_transform(df_test['Married'])\ndf_test['Education'] = label_encoder.fit_transform(df_test['Education'])\ndf_test['Dependents'] = label_encoder.fit_transform(df_test['Dependents'])\ndf_test['Self_Employed'] = label_encoder.fit_transform(df_test['Self_Employed'])\ndf_test['Property_Area'] = label_encoder.fit_transform(df_test['Property_Area'])\ndf_test['Gender'] = label_encoder.fit_transform(df_test['Gender'])","2f5755b8":"# inspecting data\n\ndf_train.head()","1a757729":"# Dropping unique identifier\n\ndf_train.drop('Loan_ID', axis = 1, inplace = True)\ntest_ID = df_test['Loan_ID']\ndf_test.drop('Loan_ID', axis = 1, inplace = True)","03bf94d7":"# Importing SMOTE\n\nfrom imblearn.over_sampling import SMOTE\nsm = SMOTE(sampling_strategy = 1 ,k_neighbors = 15)","73c56317":"x_ch = df_train['Credit_History']\nX_ch = df_train.drop('Credit_History', axis = 1)\nX_ch, x_ch = sm.fit_sample(X_ch, x_ch)","970725c3":"X_ch.shape","e209c2a2":"df_train = pd.concat([X_ch, x_ch], axis = 1)","38286e0e":"# Splitting target variable\n\ny = df_train['Loan_Status']\nX = df_train.drop('Loan_Status', axis = 1)","4a8dbe31":"# Inspecting data\n\nX.tail()","97c32f37":"# Normalizing data\n\nnormalized_X = preprocessing.normalize(X)\nnormalized_X_test = preprocessing.normalize(df_test)","b2d41030":"# importing model\n\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC","e472dadd":"# fitting Logistic Regression\n\nmodel = LogisticRegression()\nmodel.fit(normalized_X, y)\nypred_LR = model.predict(normalized_X_test)","36c9a747":"# fitting Decision Tree\n\ntree = DecisionTreeClassifier()\ntree.fit(normalized_X, y)\nypred_TR = tree.predict(normalized_X_test)","a925ea72":"# fitting Random Forest\n\nforest = RandomForestClassifier()\nforest.fit(normalized_X, y)\nypred_RF = forest.predict(normalized_X_test)","7610ceb3":"# fitting Support Vector Classifier\n\nsvc = SVC()\nsvc.fit(normalized_X, y)\nypred_SV = svc.predict(normalized_X_test)","eb29daaa":"result = []\nfor value in ypred_LR:\n    if value == 1:\n        result.append('Y')\n    else:\n        result.append('N')\ndf = pd.concat([test_ID, pd.DataFrame(result)], axis = 1)\ndf.rename(columns = {0:'Loan_Status'}, inplace = True)\ndf.to_csv('Final_result_LR.csv', index = False)","2d2c7935":"result = []\nfor value in ypred_TR:\n    if value == 1:\n        result.append('Y')\n    else:\n        result.append('N')\ndf = pd.concat([test_ID, pd.DataFrame(result)], axis = 1)\ndf.rename(columns = {0:'Loan_Status'}, inplace = True)\ndf.to_csv('Final_result_TR.csv', index = False)","56bcff74":"result = []\nfor value in ypred_RF:\n    if value == 1:\n        result.append('Y')\n    else:\n        result.append('N')\ndf = pd.concat([test_ID, pd.DataFrame(result)], axis = 1)\ndf.rename(columns = {0:'Loan_Status'}, inplace = True)\ndf.to_csv('Final_result_RF.csv', index = False)","eecd688c":"result = []\nfor value in ypred_SV:\n    if value == 1:\n        result.append('Y')\n    else:\n        result.append('N')\ndf = pd.concat([test_ID, pd.DataFrame(result)], axis = 1)\ndf.rename(columns = {0:'Loan_Status'}, inplace = True)\ndf.to_csv('Final_result_SV.csv', index = False)","06dd24bf":"# Handling Missing values","f9457339":"# Building the final submission files","db86edc0":"### Observation:\n\nFrom the above EDA all the feautes except Coapplicant income and Gender seem to be important","bc1b67aa":"# Exploratory Data Analysis","bccb616e":"# Normalization","68f010b5":"# Missing values","4111643c":"### File for Random Forest","f310e085":"### Observation:\n\nSelf Emplyed people are rare and more likely to be rejected for loan.","e180f17b":"### File for Support vector Classifier","9f019ab9":"### Observation:\n\nUnmarried are more likely to be rejected for loan.","8d7f9429":"### Obseravtion from EDA\n\nCredit History and Self Employed need upsampling.","d14a08a4":"### Observation:\n\nSince missing values are in minority, we will use mode to fill the missing data.","4df74317":"### Observation:\n\nNon Graduates are more likely to be rejected for loan.","72736b2b":"# Feature Engineering","ce52eadf":"### Observation:\n\nMore males get their loans approved.","a63b058b":"### Observation:\n\nMost males are married and most females are unmarried. Therefore married men frequent the mall more.","f0b1ca0e":"# Feature Selection","7526eb89":"### Observation:\n\nSome Correlation between Applicant income and Loan Amount.","3d42240a":"# Handling Outliers","08237f90":"### Observation:\n\nLong term loans are more likely to be rejected.","2e6833a1":"### Observation:\n\nPeople from rural areas are more likely to be rejected for loan.","e3e5203a":"### Observation:\n\nToo many outliers.","c3e94398":"### File for logistic regression","68a64c9c":"# SMOTE for upsampling","025d6f9c":"# Model Building","37f32f87":"### File for Decision Tree","80520d4a":"### Observation:\n\nFeatures like gender, education, self employed and credit history need to be up sampled.","bed249a7":"# Loading data"}}