{"cell_type":{"9491a7df":"code","774f2895":"code","239798cd":"code","ff465f6a":"code","c776cf23":"code","d424ebb7":"code","a6f39a9c":"code","0454f2d3":"code","e00165d1":"code","f5982223":"code","27ba0468":"code","d24e234b":"code","cba64c52":"code","7fe1ecdd":"code","6bd48719":"code","b0d76bf1":"code","1b5971a9":"code","6c9a741a":"code","e22a42c5":"code","e45affd0":"code","9f4680d8":"markdown","45424ab2":"markdown","f925b1c9":"markdown"},"source":{"9491a7df":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport scipy\nfrom sklearn.decomposition import PCA\nimport scipy.sparse.linalg as ll\nimport math\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\ndirectory = os.getcwd()\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","774f2895":"from sklearn.utils.graph_shortest_path import graph_shortest_path\nimport scipy.io as sio\nfrom scipy.spatial.distance import cdist\nimport networkx as nx\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\n\nisomap = sio.loadmat(\"\/kaggle\/input\/isomap-and-food-consumption\/isomap.mat\")\nfaces = isomap['images'].T\nfaces.shape","239798cd":"fig = plt.figure(figsize=(5,5)) \nfig.subplots_adjust(left=0, right=1, bottom=0, top=1, hspace=0.05, wspace=0.05) \n\nimg_disp = np.reshape(faces[0]*100, (64, 64), order=\"C\")\nax = fig.add_subplot(1, 2, 2, xticks=[], yticks=[]) \nax.imshow(img_disp, interpolation='nearest')","ff465f6a":"from scipy.ndimage import rotate\nfig = plt.figure(figsize=(5,5)) \nfig.subplots_adjust(left=0, right=1, bottom=0, top=1, hspace=0.05, wspace=0.05) \n\nax = fig.add_subplot(1, 2, 2, xticks=[], yticks=[]) \nax.imshow(rotate(img_disp, angle=-90), interpolation='nearest')","c776cf23":"# Rotate all the faces to make visualizing pretty\nfor index, face in enumerate(faces):\n    img_disp = np.reshape(face, (64, 64), order=\"C\")\n    img_disp_rotated = rotate(img_disp, angle=-90)\n    faces[index] = np.reshape(img_disp_rotated, (64*64), order=\"C\")","d424ebb7":"def construct_A(faces, epsilon, distance_metric):\n    \n    distances = cdist(XA=faces, XB=faces, metric=distance_metric)\n    \n    A = np.zeros_like(distances)\n    A[distances < epsilon] = distances[distances < epsilon]\n    \n    return A\n\nA = construct_A(faces, 15, 'euclidean')","a6f39a9c":"import matplotlib.image as mpimg\nfrom numpy import sqrt\n\ndef show_graph(adjacency_matrix, faces):\n    import numpy\n    numpy.random.seed(42)\n\n    fig = plt.figure(figsize=(15,8)) \n    fig.subplots_adjust(left=0, right=1, bottom=0, top=1, hspace=0.05, wspace=0.05) \n    ax = fig.add_subplot(1, 2, 1) \n    ax.axis('off')\n    fig.patch.set_visible(False)\n    \n    rows, cols = np.where(adjacency_matrix != 0)\n    edges = zip(rows.tolist(), cols.tolist())\n    G = nx.Graph()\n    G.add_edges_from(edges)\n    nx.draw(G, node_size=10, width=.01, alpha=0.6, ax=ax)\n    \n    N = len(faces)\n    imsize = 0.05 # this is the image size\n    ax = fig.add_subplot(1, 2, 2) \n    ax.axis('off')\n    \n    trans = ax.transData.transform\n    trans2 = fig.transFigure.inverted().transform\n    pos = nx.spring_layout(G, k=1\/sqrt(N))\n    nx.draw_networkx(G, pos, node_size=10, width=.01, edge_color=\"black\", alpha=0.6, with_labels=False, ax=ax)\n\n    for n in G.nodes():\n        if n%10 == 0:\n            (x,y) = pos[n]\n            xx,yy = trans((x,y)) # figure coordinates\n            xa,ya = trans2((xx,yy)) # axes coordinates\n            a = plt.axes([xa-imsize, ya-imsize, imsize, imsize])\n            a.imshow(np.reshape(faces[n]*100, (64, 64), order=\"C\"))\n            a.set_aspect('equal')\n            a.axis('off')\n        \n    plt.show()","0454f2d3":"print(\"Epsilon = 20\")\nA = construct_A(faces, 20, 'euclidean')\nshow_graph(A, faces)\n\nprint(\"Epsilon = 15\")\nA = construct_A(faces, 15, 'euclidean')\nshow_graph(A, faces)\n\nprint(\"Epsilon = 10\")\nA = construct_A(faces, 10, 'euclidean')\nshow_graph(A, faces)\n\nprint(\"Epsilon = 5\")\nA = construct_A(faces, 5, 'euclidean')\nshow_graph(A, faces)","e00165d1":"plt.spy(A)\nplt.title('A Matrix', fontsize=20, pad='15.0')\nplt.show()","f5982223":"A = construct_A(faces, 15, 'euclidean')\n\n# Shortest path distance matrix \/ graph distance matrix\nD = graph_shortest_path(A)\n\n\n# Compute the centering matrix H:\nm = len(D)\nI = np.eye(m)\nH = I - 1\/m * np.ones((m,m))\n\nC = -1\/2 * H @ D**2 @ H","27ba0468":"evals, evecs = scipy.linalg.eig(C)\nevals = evals.real\nevecs = evecs.real\n\n#sorted_vals = evals[np.argsort(-evals)]\n#sorted_vecs = evecs[:,np.argsort(-evals)]\ntop = 2\ntop_evals = evals[np.argsort(evals)[-top:]]\ntop_evecs = evecs[:,np.argsort(evals)[-top:]]\n\nZ = top_evecs * np.sqrt(top_evals)\nZ.shape","d24e234b":"x = Z[:,0]\ny = Z[:,1]\n\nfig, ax = plt.subplots(figsize=(15,8))\nax.scatter(x, y)\nfor x0, y0, face in zip(x, y, faces):\n    ab = AnnotationBbox(OffsetImage(np.reshape(face*100, (64, 64), order=\"C\"),zoom=.2), (x0, y0), frameon=False)\n    ax.add_artist(ab)","cba64c52":"print(\"Epsilon = 1500\")\nA = construct_A(faces, 1500, 'cityblock')\nshow_graph(A, faces)\n\nprint(\"Epsilon = 1000\")\nA = construct_A(faces, 1000, 'cityblock')\nshow_graph(A, faces)\n\nprint(\"Epsilon = 750\")\nA = construct_A(faces, 750, 'cityblock')\nshow_graph(A, faces)\n\nprint(\"Epsilon = 500\")\nA = construct_A(faces, 500, 'cityblock')\nshow_graph(A, faces)\n\nprint(\"Epsilon = 200\")\nA = construct_A(faces, 200, 'cityblock')\nshow_graph(A, faces)\n\nprint(\"Epsilon = 50\")\nA = construct_A(faces, 50, 'cityblock')\nshow_graph(A, faces)","7fe1ecdd":"A = construct_A(faces, 750, 'cityblock')\n\n# Shortest path distance matrix \/ graph distance matrix\nD = graph_shortest_path(A)\n\nm = len(D)\n\nI = np.eye(m)\nH = I - 1\/m * np.ones((m,m))\nC = -1\/2 * H @ D**2 @ H\n\nevals, evecs = scipy.linalg.eig(C)\nevals = evals.real\nevecs = evecs.real\n\ntop = 2\ntop_evals = evals[np.argsort(evals)[-top:]]\ntop_evecs = evecs[:,np.argsort(evals)[-top:]]\n\nZ = top_evecs * np.sqrt(top_evals)\nZ.shape\n\nx = Z[:,0]\ny = Z[:,1]\n\nfig, ax = plt.subplots(figsize=(15,8))\nax.scatter(x, y)\nfor x0, y0, face in zip(x, y, faces):\n    ab = AnnotationBbox(OffsetImage(np.reshape(face*100, (64, 64), order=\"C\"),zoom=.2), (x0, y0), frameon=False)\n    ax.add_artist(ab)","6bd48719":"pca = PCA(n_components = 2)\npca.fit(faces.T)\n\nx = pca.components_[0]\ny = pca.components_[1]\n\nfig, ax = plt.subplots(figsize=(15,8))\nax.scatter(x, y)\nfor x0, y0, face in zip(x, y, faces):\n    ab = AnnotationBbox(OffsetImage(np.reshape(face*100, (64, 64), order=\"C\"),zoom=.2), (x0, y0), frameon=False)\n    ax.add_artist(ab)","b0d76bf1":"food_df = pd.read_csv(\"\/kaggle\/input\/isomap-and-food-consumption\/food-consumption.csv\")\nfood_df.head()","1b5971a9":"countries = food_df.to_numpy()[:,0]\nfood_names = food_df.columns.to_numpy()[1:21]\nfoods = food_df.to_numpy()[:,1:21].astype(\"float32\")","6c9a741a":"# Returns the top 2 principal components\ndef pca_homebrew(x):\n    mu = np.mean(x, axis = 1)\n    xc = x - mu[:, None]\n\n    C = np.dot(xc, xc.T) \/ 20\n\n    S,W = ll.eigs(C, k = 2)\n    S = S.real\n    W = W.real\n\n    dim1 = np.dot(W[:,0], xc)\/math.sqrt(S[0]) # component 1\n    dim2 = np.dot(W[:,1], xc)\/math.sqrt(S[1]) # component 2\n    \n    return dim1, dim2","e22a42c5":"c1, c2 = pca_homebrew(foods.T)\n\nfig, ax = plt.subplots()\nax.scatter(c1, c2)\nfig.set_size_inches(16, 10)\n\nfor i, txt in enumerate(countries):\n    ax.annotate(txt, (c1[i], c2[i]+.1))","e45affd0":"c1, c2 = pca_homebrew(foods)\n\nfig, ax = plt.subplots()\nax.scatter(c1, c2)\nfig.set_size_inches(16, 10)\n\nfor i, txt in enumerate(food_names):\n    ax.annotate(txt, (c1[i], c2[i]+.1))","9f4680d8":"## PCA: Food consumption in European countries","45424ab2":"## Goal\nApply spectial clustering to find similar features on an image dataset. The idea is that eigenvalues\/eigenvectors of the\nadjacency matrix can be used to represent a graph. Using this, we can seperate images of a face based on which direction they are faces. ","f925b1c9":"![image.png](attachment:e8fb2454-8032-46bb-aa85-aeea35d2926f.png)"}}