{"cell_type":{"c0c7635f":"code","05c43c52":"code","f7cdcbce":"code","f0c03963":"code","c37f42dc":"code","00966f52":"code","2ca5b4bf":"code","4962af82":"code","176810e7":"code","7ef92cb7":"code","88e596e7":"code","d8c8c5f1":"code","cf971be4":"code","5f3604ba":"code","e286f4a3":"code","9470f4cd":"code","5cd2c51a":"code","165d7138":"code","b30769cb":"code","0c862b2a":"code","b615c280":"code","9d4e4277":"code","2c853001":"code","722f7395":"code","fa0ea6e3":"code","4a18840c":"code","afe91dad":"code","f72282d4":"code","c95956d5":"code","ad0b8435":"code","8881cce6":"code","cc7822fc":"code","0029bc53":"code","9aea7e76":"code","db91c456":"code","5a5dd753":"code","2963ffe5":"markdown","5996e380":"markdown","74dea715":"markdown","ca908a0e":"markdown","52e09ed0":"markdown","a6f68d6b":"markdown","fe82923c":"markdown","9b426fb3":"markdown","df612b9a":"markdown","95bc822d":"markdown","090202b8":"markdown","67523e1b":"markdown","79100426":"markdown","2286b426":"markdown","bd33e6f8":"markdown","84370e64":"markdown","30f4aa85":"markdown","17cd2105":"markdown","7de278f3":"markdown","b81957dd":"markdown","078ab187":"markdown","2b6dd1df":"markdown","a5724b53":"markdown","a128d480":"markdown","e608a59b":"markdown","7bfac09a":"markdown","d08379ee":"markdown","2e2d75ac":"markdown"},"source":{"c0c7635f":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nprint(os.listdir(\"..\/input\/brent-oil-prices\"))","05c43c52":"df = pd.read_csv(\"..\/input\/brent-oil-prices\/BrentOilPrices.csv\")","f7cdcbce":"df.head()","f0c03963":"import seaborn as sns\nfrom matplotlib import pyplot as plt\n\ndf['Date'] = pd.to_datetime(df['Date'], format=\"%b %d, %Y\")\ndf.head()","c37f42dc":"g = sns.lineplot(x='Date',y='Price',data = df)\nplt.title(\"Brent Oil Price Trend\")","00966f52":"def plot_price_trend(df, start_date, end_date):\n    \"\"\"\n    This function filters the dataframe for the specified date range and \n    plots the line plot of the data using seaborn.\n    \n    The dataframe may not be indexed on any Datetime column.\n    In this case, we use mask to filter out the date.\n    \n    PS - There is another function provided later in the notebook \n    which used indexed column to filter data\n    \"\"\"\n    mask = (df['Date'] > start_date) & (df['Date'] <= end_date)\n    sdf = df.loc[mask]\n    plt.figure(figsize = (10,5))\n    chart = sns.lineplot(x='Date',y='Price',data = sdf)\n#     chart.set_xticklabels(chart.get_xticklabels(), rotation=45)\n    plt.title(\"Brent Oil Price Trend\")","2ca5b4bf":"plot_price_trend(df,'2017-01-01','2019-01-01')","4962af82":"from fbprophet import Prophet\nm = Prophet()","176810e7":"pro_df = df\npro_df.columns = ['ds','y']\npro_df.head()","7ef92cb7":"m.fit(pro_df)\nfuture = m.make_future_dataframe(periods = 90)\nforecast = m.predict(future)","88e596e7":"forecast.head()","d8c8c5f1":"m.plot_components(forecast)","cf971be4":"m.plot(forecast)","5f3604ba":"cmp_df = forecast.set_index('ds')[['yhat','yhat_lower','yhat_upper']].join(pro_df.set_index('ds'))","e286f4a3":"cmp_df.head()","9470f4cd":"cmp_df.tail(5)","5cd2c51a":"plt.figure(figsize=(17,8))\n#plt.plot(cmp_df['yhat_lower'])\n#plt.plot(cmp_df['yhat_upper'])\nplt.plot(cmp_df['yhat'])\nplt.plot(cmp_df['y'])\nplt.legend()\nplt.show()","165d7138":"def plot_price_forecast(df,start_date, end_date):\n    \"\"\"\n    This function filters the dataframe for the specified date range and \n    plots the actual and forecast data.\n    \n    Assumption: \n    - The dataframe has to be indexed on a Datetime column\n    This makes the filtering very easy in pandas using df.loc\n    \"\"\"\n    cmp_df = df.loc[start_date:end_date]\n    plt.figure(figsize=(17,8))\n    plt.plot(cmp_df['yhat'])\n    plt.plot(cmp_df['y'])\n    plt.legend()\n    plt.show()","b30769cb":"plot_price_forecast(cmp_df,'2017-01-01','2020-01-01')","0c862b2a":"from statsmodels.tsa.arima_model import ARIMA    # ARIMA Modeling\nfrom statsmodels.tsa.stattools import adfuller   # Augmented Dickey-Fuller Test for Checking Stationary\nfrom statsmodels.tsa.stattools import acf, pacf  # Finding ARIMA parameters using Autocorrelation\nfrom statsmodels.tsa.seasonal import seasonal_decompose # Decompose the ARIMA Forecast model","b615c280":"arima_df = df.set_index('ds')\narima_df.head()","9d4e4277":"# Perform Augmented Dickey\u2013Fuller test to check if the given Time series is stationary:\ndef test_stationarity(ts):\n    \n    #Determing rolling statistics\n    rolmean = ts.rolling(window=12).mean()\n    rolstd = ts.rolling(window=12).std()\n\n    #Plot rolling statistics:\n    orig = plt.plot(ts, color='blue',label='Original')\n    mean = plt.plot(rolmean, color='red', label='Rolling Mean')\n    std = plt.plot(rolstd, color='black', label = 'Rolling Std')\n    plt.legend(loc='best')\n    plt.title('Rolling Mean & Standard Deviation')\n    plt.show(block=False)\n    \n    #Perform Dickey-Fuller test:\n    print('Results of Dickey-Fuller Test:')\n    dftest = adfuller(ts['y'], autolag='AIC')\n    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\n    for key,value in dftest[4].items():\n        dfoutput['Critical Value (%s)'%key] = value\n    print(dfoutput)","2c853001":"test_stationarity(arima_df)","722f7395":"from statsmodels.graphics.tsaplots import plot_acf,plot_pacf\nplot_acf(arima_df)\nplot_pacf(arima_df)","fa0ea6e3":"# Implementing own function to create ACF plot\ndef get_acf_plot(ts):\n    #calling acf function from stattools\n    y = ts['y']\n    lag_acf = acf(y, nlags=500)\n    plt.figure(figsize=(16, 7))\n    plt.plot(lag_acf, marker=\"o\")\n    plt.axhline(y=0,linestyle='--',color='gray')\n    plt.axhline(y=-1.96\/np.sqrt(len(y)),linestyle='--',color='gray')\n    plt.axhline(y=1.96\/np.sqrt(len(y)),linestyle='--',color='gray')\n    plt.title('Autocorrelation Function')\n    plt.xlabel('number of lags')\n    plt.ylabel('correlation')\n    \ndef get_pacf_plot(ts):\n    #calling pacf function from stattools\n    y = arima_df['y']\n    lag_pacf = pacf(y, nlags=50)\n    plt.figure(figsize=(16, 7))\n    plt.plot(lag_pacf, marker=\"o\")\n    plt.axhline(y=0,linestyle='--',color='gray')\n    plt.axhline(y=-1.96\/np.sqrt(len(y)),linestyle='--',color='gray')\n    plt.axhline(y=1.96\/np.sqrt(len(y)),linestyle='--',color='gray')\n    plt.title('Partial Autocorrelation Function')\n    plt.xlabel('number of lags')\n    plt.ylabel('correlation')","4a18840c":"get_acf_plot(arima_df)\nget_pacf_plot(arima_df)","afe91dad":"# Log Transformation\nts_log = np.log(arima_df)\nplt.plot(ts_log)","f72282d4":"# Moving Average of last 12 values\nmoving_avg = ts_log.rolling(12).mean()\nplt.plot(ts_log)\nplt.plot(moving_avg, color='red')","c95956d5":"# Differencing\nts_log_ma_diff = ts_log - moving_avg\nts_log_ma_diff.head(12)","ad0b8435":"ts_log_ma_diff.dropna(inplace=True)\ntest_stationarity(ts_log_ma_diff)","8881cce6":"# Exponentially weighted moving average \nexpwighted_avg = ts_log.ewm(halflife=12).mean()\n\nplt.plot(ts_log)\nplt.plot(expwighted_avg, color='red')\nts_log_ewma_diff = ts_log - expwighted_avg\ntest_stationarity(ts_log_ewma_diff)","cc7822fc":"ts_log_diff = ts_log - ts_log.shift()\nplt.plot(ts_log_diff)","0029bc53":"ts_log_diff.dropna(inplace=True)\ntest_stationarity(ts_log_diff)","9aea7e76":"from statsmodels.tsa.seasonal import seasonal_decompose\ndecomposition = seasonal_decompose(ts_log, freq = 30)\n\ntrend = decomposition.trend\nseasonal = decomposition.seasonal\nresidual = decomposition.resid\n\nplt.subplot(411)\nplt.plot(ts_log, label='Original')\nplt.legend(loc='best')\nplt.subplot(412)\nplt.plot(trend, label='Trend')\nplt.legend(loc='best')\nplt.subplot(413)\nplt.plot(seasonal,label='Seasonality')\nplt.legend(loc='best')\nplt.subplot(414)\nplt.plot(residual, label='Residuals')\nplt.legend(loc='best')\nplt.tight_layout()","db91c456":"ts_log_decompose = residual\nts_log_decompose.dropna(inplace=True)\ntest_stationarity(ts_log_decompose)","5a5dd753":"model = ARIMA(ts_log, order=(2, 1, 2))  \nresults_ARIMA = model.fit(disp=-1)  \nplt.plot(ts_log_diff)\nplt.plot(results_ARIMA.fittedvalues, color='red')\n# plt.title('RSS: %.4f'% sum((results_ARIMA.fittedvalues-ts_log_diff)**2))","2963ffe5":"Step 8) - ARIMA models","5996e380":"1) Need to convert Date column to standard format","74dea715":"# Data Preprocessing","ca908a0e":"Step 1) - First we import the required libraries","52e09ed0":"Step 1) - First we import the Prophet class from fbprophet module and then create an instance of this.","a6f68d6b":"Observation - The null hypothesis of ADF test is the Time series is NOT stationary. We see that the Test Statistic (-1.95) is higher than 10% Critical Value (-2.56). This means this result is statistically significant at 90% confidence interval and so, we fail to reject the null hypothesis. \n\nThis means that our time series data is NOT stationary.","fe82923c":"# Forecast Model","9b426fb3":"Step 4) - Next, we use this function to check if our given timeseries data is stationary or not","df612b9a":"# 1) Using Prophet","95bc822d":"Step 7 - Then, we visualize the original and forecast data alongside each other","090202b8":"Step 4) - We check the forecast data has several components - trend, weakly and yearly seasonality - and for each of these components, we have the lower and upper confidence intervals data.","67523e1b":"Step 5) - We plot these components of the forecast fit model.","79100426":"# Data Exploration","2286b426":"Step 3) - Next we write a function that plots the Rolling mean and standard deviation and then checks the stationarity of the time series using Augmented Dickey - Fuller Test\n\nCredit - https:\/\/www.kaggle.com\/freespirit08\/time-series-for-beginners-with-arima","bd33e6f8":"Stpe 9) - Using this function, we can see that, the original graph (orange) does not have data towards the end. This data can be taken from the forecasted graph (blue). ","84370e64":"# 2) Using ARIMA","30f4aa85":"Note that the original y data is NaN towards the end because, these are the predicted dates.","17cd2105":"Step 8) - From above graph, we are not able to readily see how many months data was forecast. \n\nSo, We need a function which will show us the original and forecast data between a specified date range.","7de278f3":"Step 6) - Next we see some methods to make the data stationary","b81957dd":"Step 6)- Next we want to visualize side by side the original data and the forecast data. So for this, we join the original and forecast data on the column 'ds'","078ab187":"# Input Data","2b6dd1df":"**Visualizing Full Data as a line plot**","a5724b53":"Step 3) - Next we fit this dataframe into the model object created and then create a forecast for the Oil Price for the next 90 days. \n\nThis might take ~1mins","a128d480":"**Function to plot Oil Price Trend between specific period**","e608a59b":"# 3) Using LSTM","7bfac09a":"Step 5) - Some definitions - \n\nCorrelation - Describes how much two variables depend on each other. \n\nPartial Correlation - When multiple variables are involved, two variables may have direct relation as well as indirect relation (i.e x1 and x3 are related and x2 and x3 are related. Due to this indirect relation, x1 and x2 might be related). This is called partial correlation.\n\nAuto Correlation - In a time series data, variable at a time step is dependent upon its lag values. This is called auto-correlation (i.e. variable depending upon its own values)\n\nPartial Autocorrelation - describes correlation of a variable with its lag values after removing the effect of indirect correlation.\n\n","d08379ee":"Step 2) - Arima requires the date column to be set as index","2e2d75ac":"Step 2) - Note that Prophet requires the date column as 'ds' and outcome varible as 'y'.\nSo we change this in our dataframe and check its data."}}