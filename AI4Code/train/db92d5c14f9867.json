{"cell_type":{"4ba69891":"code","5a51dc87":"code","42df5872":"code","c645108c":"code","fe0f49cc":"code","1a9a07c7":"code","b32f5741":"code","b54b8b4c":"code","be2fe63a":"code","9e963a15":"code","846909e6":"code","cb9283c8":"code","e37220c9":"code","bf597058":"code","3a645193":"code","f515cc88":"code","29b72dc2":"code","ed338bdc":"code","0dcb12fd":"code","45cb9a5e":"code","50846ffd":"code","5db9098b":"code","904dc7a1":"code","d3106f47":"code","787492c2":"code","a5375b09":"code","00616cbb":"code","7cacd96f":"code","e9b7c0ff":"code","8aafb494":"code","d3591873":"code","76878799":"code","e38659f5":"code","76b6b102":"code","21159ad4":"code","c94f2620":"code","d116001c":"code","0a7f938b":"code","b87693c4":"code","8b2ccba2":"code","08967b75":"code","f319a5d4":"code","f9aa663a":"code","6ef108e8":"code","d0f0d5c0":"code","20729e6e":"code","7c2617da":"code","21296c96":"code","30cae7be":"code","d70865c0":"code","55ee2802":"code","e4bc1271":"code","c8915bee":"markdown","2c8b49b6":"markdown","78867969":"markdown","ed9ee74e":"markdown","84279ffe":"markdown","f9e3fb01":"markdown","79574328":"markdown","2359d05c":"markdown","ce381d1e":"markdown","644e1020":"markdown","3168610b":"markdown","e1f2fb81":"markdown","94331857":"markdown","1015de49":"markdown","ac2fc392":"markdown","8da25602":"markdown","85c6a085":"markdown","b836a0f2":"markdown","633dc696":"markdown","b6596e35":"markdown","85e62a97":"markdown","4486d2e9":"markdown","5cca348a":"markdown","01120099":"markdown"},"source":{"4ba69891":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\nfrom scipy.stats import pearsonr\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nimport math\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n#Gets sum of all deaths 1 month after vaccination week date, categorized by different causes:\ndef get_monthly_increment(state, start_date, number_of_months):\n    end_date = start_date + relativedelta(months = number_of_months) + relativedelta(days = 7)\n    df_all_records_date_range = df_death_count_state_only[df_death_count_state_only[column_name_date] >= start_date]\n    df_all_records_date_range = df_all_records_date_range[df_all_records_date_range[column_name_jurisdiction_deaths] == state]\n    df_all_records_date_range = df_all_records_date_range[df_all_records_date_range[column_name_date] <= end_date]\n    df_all_records_date_range = df_all_records_date_range[[column_name_disease_all_cause, column_name_disease_natural_cause, column_name_disease_septicemia, column_name_disease_malignant_neoplasms, column_name_disease_diabetes, column_name_disease_alzheimer, column_name_disease_influenza_pneumonia, column_name_disease__lower_respiratory, column_name_disease_respiratory, column_name_disease_nephritis, column_name_disease_non_classified, column_name_disease_non_cardiovascular, column_name_disease_non_cerebrovascular, column_name_disease_non_covid_multiple, column_name_disease_non_covid_underlying]].sum(axis=0)\n    return df_all_records_date_range\n\n#rounds decimals:\ndef round_decimals_up(number:float, decimals:int=2):\n    \"\"\"\n    Returns a value rounded up to a specific number of decimal places.\n    \"\"\"\n    if not isinstance(decimals, int):\n        raise TypeError(\"decimal places must be an integer\")\n    elif decimals < 0:\n        raise ValueError(\"decimal places has to be 0 or more\")\n    elif decimals == 0:\n        return math.ceil(number)\n\n    factor = 10 ** decimals\n    return math.ceil(number * factor) \/ factor\n\n#filename_death_count_1 = 'Weekly_Counts_of_Deaths_by_State_and_Select_Causes__2014-2019.csv'\nfilename_death_count = '..\/input\/covid-19-vaccines-and-deaths-by-state\/Weekly_Provisional_Counts_of_Deaths_by_State_and_Select_Causes__2020-2021.csv'\nfilename_vaxxed_janssen = '..\/input\/covid-19-vaccines-and-deaths-by-state\/COVID-19_Vaccine_Distribution_Allocations_by_Jurisdiction_-_Janssen.csv'\nfilename_vaxxed_moderna = '..\/input\/covid-19-vaccines-and-deaths-by-state\/COVID-19_Vaccine_Distribution_Allocations_by_Jurisdiction_-_Moderna.csv'\nfilename_vaxxed_pfizer = '..\/input\/covid-19-vaccines-and-deaths-by-state\/COVID-19_Vaccine_Distribution_Allocations_by_Jurisdiction_-_Pfizer.csv'\n\n#Column names original files:\ncolumn_name_jurisdiction_vaxxed = 'Jurisdiction'\ncolumn_name_week_vaxxed = 'Week of Allocations'\ncolumn_name_first_dose_vaxxed = '1st Dose Allocations'\ncolumn_name_second_dose_vaxxed = '2nd Dose Allocations'\n\ncolumn_name_week_deaths = 'Week Ending Date'\ncolumn_name_jurisdiction_deaths = 'Jurisdiction of Occurrence'\n\n#Diseases columns:\ncolumn_name_disease_all_cause = 'All Cause'\ncolumn_name_disease_natural_cause = 'Natural Cause'\ncolumn_name_disease_septicemia = 'Septicemia (A40-A41)'\ncolumn_name_disease_malignant_neoplasms = 'Malignant neoplasms (C00-C97)'\ncolumn_name_disease_diabetes = 'Diabetes mellitus (E10-E14)'\ncolumn_name_disease_alzheimer = 'Alzheimer disease (G30)'\ncolumn_name_disease_influenza_pneumonia = 'Influenza and pneumonia (J09-J18)'\ncolumn_name_disease__lower_respiratory = 'Chronic lower respiratory diseases (J40-J47)'\ncolumn_name_disease_respiratory = 'Other diseases of respiratory system (J00-J06,J30-J39,J67,J70-J98)'\ncolumn_name_disease_nephritis = 'Nephritis, nephrotic syndrome and nephrosis (N00-N07,N17-N19,N25-N27)'\ncolumn_name_disease_non_classified = 'Symptoms, signs and abnormal clinical and laboratory findings, not elsewhere classified (R00-R99)'\ncolumn_name_disease_non_cardiovascular = 'Diseases of heart (I00-I09,I11,I13,I20-I51)'\ncolumn_name_disease_non_cerebrovascular = 'Cerebrovascular diseases (I60-I69)'\ncolumn_name_disease_non_covid_multiple = 'COVID-19 (U071, Multiple Cause of Death)'\ncolumn_name_disease_non_covid_underlying = 'COVID-19 (U071, Underlying Cause of Death)'\n\n#New column names:\ncolumn_name_date = 'Date'\n\n#columns for monthly death totals:\ncolumn_name_increment_monthly_all_cause = 'MI All Causes'\ncolumn_name_increment_monthly_natural_cause = 'MI Natural Causes'\ncolumn_name_increment_monthly_septicemia = 'MI Septicemia'\ncolumn_name_increment_monthly_malignant_neoplasms = 'MI Malignant Neoplasms'\ncolumn_name_increment_monthly_diabetes = 'MI Diabetes'\ncolumn_name_increment_monthly_alzheimer = 'MI Alzheimer'\ncolumn_name_increment_monthly_influenza_pneumonia = 'MI Influenza and Pneumonia'\ncolumn_name_increment_monthly__lower_respiratory = 'MI Chronic lower respiratory diseases'\ncolumn_name_increment_monthly_respiratory = 'MI Other respiratory diseases'\ncolumn_name_increment_monthly_nephritis = 'MI Nephrosis Like'\ncolumn_name_increment_monthly_non_classified = 'MI Not Classified Causes'\ncolumn_name_increment_monthly_non_cardiovascular = 'MI Cardiovascular'\ncolumn_name_increment_monthly_non_cerebrovascular = 'MI Cerebrovascular'\ncolumn_name_increment_monthly_non_covid_multiple = 'MI COVID-19 Multiple Causes'\ncolumn_name_increment_monthly_non_covid_underlying = 'MI COVID-19 as Underlying Cause'","5a51dc87":"df_raw_death_count = pd.read_csv(filename_death_count, encoding = 'latin')\ndf_raw_vaxxed_janssen = pd.read_csv(filename_vaxxed_janssen, encoding = 'latin')\ndf_raw_vaxxed_moderna = pd.read_csv(filename_vaxxed_moderna, encoding = 'latin')\ndf_raw_vaxxed_pfizer = pd.read_csv(filename_vaxxed_pfizer, encoding = 'latin')","42df5872":"#puts together all vaccine types (janssen, moderna and pfizer), groups them by state:\ndf_vaxxed = pd.concat([df_raw_vaxxed_janssen, df_raw_vaxxed_moderna, df_raw_vaxxed_pfizer])\ndf_vaxxed = df_vaxxed.groupby(by=[column_name_jurisdiction_vaxxed, column_name_week_vaxxed]).sum().reset_index()\n\n#Removes country-level records:\ndf_death_count_state_only = df_raw_death_count[df_raw_death_count[column_name_jurisdiction_deaths] != 'United States']\n\n#Adds a date column with corresponding datetime objects instead of string dates:\ndf_vaxxed[column_name_date] = pd.to_datetime(df_vaxxed[column_name_week_vaxxed], format='%m\/%d\/%Y')\n\n#remove records before 1 and 1\/2 months before the last record, because there is no death data and bias results:\n#max_date = max(df_vaxxed[column_name_date]) - relativedelta(months = 1) - relativedelta(days = 15)\n\n#I didnt remove 1 month records because latest death count is updated on mid august, while vaccination count was updated on July (one month before)\nmax_date = max(df_vaxxed[column_name_date])\ndf_vaxxed = df_vaxxed[df_vaxxed[column_name_date] < max_date]\n\n#add 8 records before vax starts (2 months) to get data with dose = 0\nstates = df_vaxxed[column_name_jurisdiction_vaxxed].unique()\n\n#For each state, it adds 9 weeks of pre-vaccination records, in oder to get pre-vaccination death counts:\nfor state in states:\n    min_date = min(df_vaxxed[df_vaxxed[column_name_jurisdiction_vaxxed] == state][column_name_date])\n    #9 records of 1 week each, means we're adding 2 and 1\/2 months pre-vaccinations records\n    for i in range(1, 9):\n        min_date = min_date - relativedelta(days = 7)\n        min_date_date_time = datetime.fromtimestamp(min_date.timestamp())\n        new_row = {column_name_jurisdiction_vaxxed:state, column_name_date:min_date_date_time, column_name_week_vaxxed:min_date_date_time.strftime(\"%m\/%d\/%Y\"), column_name_first_dose_vaxxed:0, column_name_second_dose_vaxxed:0}\n        df_vaxxed = df_vaxxed.append(new_row, ignore_index=True)\n        \n#Adds a date column with corresponding datetime objects instead of string dates:\ndf_death_count_state_only[column_name_date] = pd.to_datetime(df_death_count_state_only[column_name_week_deaths], format='%Y-%m-%d')","c645108c":"#calculate for monthly death count after vaccination\ndf_vaxxed[[column_name_increment_monthly_all_cause, column_name_increment_monthly_natural_cause, column_name_increment_monthly_septicemia, column_name_increment_monthly_malignant_neoplasms, column_name_increment_monthly_diabetes, column_name_increment_monthly_alzheimer, column_name_increment_monthly_influenza_pneumonia, column_name_increment_monthly__lower_respiratory, column_name_increment_monthly_respiratory, column_name_increment_monthly_nephritis, column_name_increment_monthly_non_classified, column_name_increment_monthly_non_cardiovascular, column_name_increment_monthly_non_cerebrovascular, column_name_increment_monthly_non_covid_multiple, column_name_increment_monthly_non_covid_underlying]] = df_vaxxed.apply(lambda x: get_monthly_increment(x[column_name_jurisdiction_vaxxed], x[column_name_date], 1), axis=1)\n\ncolumn_name_vaxxed_total = 'Total Vaccinations'\ndf_vaxxed[column_name_vaxxed_total] = df_vaxxed[column_name_first_dose_vaxxed] + df_vaxxed[column_name_second_dose_vaxxed]","fe0f49cc":"# Only compute pearson prod-moment correlations between features\n# columns and -First Dose- target column\nexclude_columns = [column_name_vaxxed_total, column_name_first_dose_vaxxed, column_name_second_dose_vaxxed, column_name_jurisdiction_vaxxed, column_name_week_vaxxed, column_name_date]\nfeature_target_corr = pd.DataFrame(columns = ['Variables', 'Correlation', 'p-value'])\n\nfor col in df_vaxxed:\n    if col not in exclude_columns:\n        new_row = {'Variable':col, 'Correlation':pearsonr(df_vaxxed[col], df_vaxxed[column_name_vaxxed_total])[0], 'p-value':round_decimals_up(pearsonr(df_vaxxed[col], df_vaxxed[column_name_vaxxed_total])[1], 4)}\n        feature_target_corr = feature_target_corr.append(new_row, ignore_index=True)\n\nfeature_target_corr = feature_target_corr.sort_values('Correlation', ascending = False)\nfeature_target_corr['Correlation'] = feature_target_corr['Correlation']*100","1a9a07c7":"#Plots correlation data of Vaccination Total by different disease death count:\nplt.figure(figsize = (12,10))\nsns.barplot(data = feature_target_corr, y='Variable', x='Correlation', orient = 'h').set_title('Correlation between Vaccination Dose and Death Cause')\n\nplt.show()","b32f5741":"# Dark theme seems fitting...\nsns.set_theme(style=\"darkgrid\")\n\n# Fitting data in Kmeans theorem in order to get some indication on the groups\nkmeans = KMeans(n_clusters=3\n                , random_state=1).fit(df_vaxxed[[column_name_vaxxed_total, column_name_increment_monthly_non_classified]])\n# This creates a new column called cluster which has cluster number for each row respectively.\ndf_vaxxed['cluster'] = kmeans.labels_\n\nfig, axes = plt.subplots(2, 3, figsize=(18, 10))\n\nfig.suptitle('Death Stats by Vaccination Doses')\n\nsns.scatterplot(data=df_vaxxed, x=column_name_vaxxed_total, y=column_name_increment_monthly_non_classified, ax=axes[0, 0], hue='cluster')\nsns.scatterplot(data=df_vaxxed, x=column_name_vaxxed_total, y=column_name_increment_monthly_malignant_neoplasms, ax=axes[0, 1], hue='cluster')\nsns.scatterplot(data=df_vaxxed, x=column_name_vaxxed_total, y=column_name_increment_monthly_non_cerebrovascular, ax=axes[0, 2], hue='cluster')\nsns.scatterplot(data=df_vaxxed, x=column_name_vaxxed_total, y=column_name_increment_monthly_non_cardiovascular, ax=axes[1, 0], hue='cluster')\nsns.scatterplot(data=df_vaxxed, x=column_name_vaxxed_total, y=column_name_increment_monthly__lower_respiratory, ax=axes[1, 1], hue='cluster')\nsns.scatterplot(data=df_vaxxed, x=column_name_vaxxed_total, y=column_name_increment_monthly_diabetes, ax=axes[1, 2], hue='cluster')\n\nplt.show()","b54b8b4c":"from sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn import metrics\nfrom sklearn.metrics import r2_score,mean_squared_error","be2fe63a":"#Setting the value for X and Y\nx = df_vaxxed[[column_name_vaxxed_total]].values\ny = df_vaxxed[column_name_increment_monthly_non_classified].values","9e963a15":"x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3, random_state = 0)","846909e6":"model = LinearRegression() \nmodel.fit(x_train, y_train)","cb9283c8":"y_pred = model.predict(x_test)","e37220c9":"plt.scatter(x, y, s = 10)\n\n# predicted values\nplt.plot(x_test, y_pred, color='r')\nplt.show()","bf597058":"print(r2_score(y_test, y_pred))","3a645193":"# 0 means the model is perfect. Therefore the value should be as close to 0 as possible\nmeanAbErr = metrics.mean_absolute_error(y_test, y_pred)\nmeanSqErr = metrics.mean_squared_error(y_test, y_pred)\nrootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred))\n\nprint('Mean Absolute Error:', meanAbErr)\nprint('Mean Square Error:', meanSqErr)\nprint('Root Mean Square Error:', rootMeanSqErr)","f515cc88":"from sklearn.tree import DecisionTreeRegressor","29b72dc2":"model = DecisionTreeRegressor() \nmodel.fit(x_train, y_train)","ed338bdc":"y_pred = model.predict(x_test)","0dcb12fd":"# 0 means the model is perfect. Therefore the value should be as close to 0 as possible\nmeanAbErr = metrics.mean_absolute_error(y_test, y_pred)\nmeanSqErr = metrics.mean_squared_error(y_test, y_pred)\nrootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred))\n\nprint('Mean Absolute Error:', meanAbErr)\nprint('Mean Square Error:', meanSqErr)\nprint('Root Mean Square Error:', rootMeanSqErr)","45cb9a5e":"plt.figure()\nplt.scatter(x, y, s=20, edgecolor=\"black\",\n            c=\"darkorange\", label=\"data\")\nplt.plot(x_test, y_test, color=\"cornflowerblue\",\n         label=\"Test Set\", linewidth=2)\nplt.plot(x_test, y_pred, color=\"yellowgreen\", label=\"Predicted\", linewidth=2)\nplt.xlabel(\"data\")\nplt.ylabel(\"target\")\nplt.title(\"Decision Tree Regression\")\nplt.legend()\nplt.show()","50846ffd":"print(r2_score(y_test, y_pred))","5db9098b":"from sklearn.ensemble import RandomForestRegressor","904dc7a1":"model = RandomForestRegressor(n_estimators=300, max_depth=15, random_state=0) \nmodel.fit(x_train, y_train)","d3106f47":"y_pred = model.predict(x_test)","787492c2":"# 0 means the model is perfect. Therefore the value should be as close to 0 as possible\nmeanAbErr = metrics.mean_absolute_error(y_test, y_pred)\nmeanSqErr = metrics.mean_squared_error(y_test, y_pred)\nrootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred))\n\nprint('Mean Absolute Error:', meanAbErr)\nprint('Mean Square Error:', meanSqErr)\nprint('Root Mean Square Error:', rootMeanSqErr)","a5375b09":"plt.figure()\nplt.scatter(x, y, s=20, edgecolor=\"black\",\n            c=\"darkorange\", label=\"data\")\nplt.plot(x_test, y_test, color=\"cornflowerblue\",\n         label=\"Test Set\", linewidth=2)\nplt.plot(x_test, y_pred, color=\"yellowgreen\", label=\"Predicted\", linewidth=2)\nplt.xlabel(\"data\")\nplt.ylabel(\"target\")\nplt.title(\"Random Forest Regression\")\nplt.legend()\nplt.show()","00616cbb":"print(r2_score(y_test, y_pred))","7cacd96f":"from keras.wrappers.scikit_learn import KerasRegressor\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom keras.models import Sequential\nfrom keras.layers import Dense","e9b7c0ff":"def baseline_model():\n    # create model\n    model = Sequential()\n    model.add(Dense(16, input_dim = 1, kernel_initializer = 'normal', activation = 'relu'))\n    model.add(Dense(1, kernel_initializer = 'normal'))\n    # Compile model\n    model.compile(loss='mean_squared_error', optimizer='adam')\n    return model\n\n# evaluate model\nestimator = KerasRegressor(build_fn = baseline_model, epochs = 100, batch_size = 5, verbose = 0)\nkfold = KFold(n_splits = 10)\nresults = cross_val_score(estimator, X = x_train, y = y_train, cv = kfold)\nprint(\"Baseline: %.2f (%.2f) MSE\" % (results.mean(), results.std()))","8aafb494":"estimator.fit(x, y)\ny_pred = estimator.predict(x_test)","d3591873":"# 0 means the model is perfect. Therefore the value should be as close to 0 as possible\nmeanAbErr = metrics.mean_absolute_error(y_test, y_pred)\nmeanSqErr = metrics.mean_squared_error(y_test, y_pred)\nrootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred))\n\nprint('Mean Absolute Error:', meanAbErr)\nprint('Mean Square Error:', meanSqErr)\nprint('Root Mean Square Error:', rootMeanSqErr)","76878799":"print(r2_score(y_test, y_pred))","e38659f5":"from array import array","76b6b102":"model.fit(x, y)","21159ad4":"x_new = np.array([1]).reshape(-1, 1)\ndeaths_non_classified_no_vax = model.predict(x_new)\nx_new = np.array([1000000]).reshape(-1, 1)\ndeaths_non_classified_vaxxed = model.predict(x_new)","c94f2620":"y = df_vaxxed[column_name_increment_monthly_malignant_neoplasms].values\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3, random_state = 0)\nmodel.fit(x_train, y_train)\ny_pred = model.predict(x_test)\nprint(r2_score(y_test, y_pred))","d116001c":"# 0 means the model is perfect. Therefore the value should be as close to 0 as possible\nmeanAbErr = metrics.mean_absolute_error(y_test, y_pred)\nmeanSqErr = metrics.mean_squared_error(y_test, y_pred)\nrootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred))\n\nprint('Mean Absolute Error:', meanAbErr)\nprint('Mean Square Error:', meanSqErr)\nprint('Root Mean Square Error:', rootMeanSqErr)","0a7f938b":"x_new = np.array([1]).reshape(-1, 1)\ndeaths_non_tumor_no_vax = model.predict(x_new)\nx_new = np.array([1000000]).reshape(-1, 1)\ndeaths_non_tumor_vaxxed = model.predict(x_new)","b87693c4":"y = df_vaxxed[column_name_increment_monthly_non_cerebrovascular].values\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3, random_state = 0)\nmodel.fit(x_train, y_train)\ny_pred = model.predict(x_test)\nprint(r2_score(y_test, y_pred))","8b2ccba2":"# 0 means the model is perfect. Therefore the value should be as close to 0 as possible\nmeanAbErr = metrics.mean_absolute_error(y_test, y_pred)\nmeanSqErr = metrics.mean_squared_error(y_test, y_pred)\nrootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred))\n\nprint('Mean Absolute Error:', meanAbErr)\nprint('Mean Square Error:', meanSqErr)\nprint('Root Mean Square Error:', rootMeanSqErr)","08967b75":"x_new = np.array([1]).reshape(-1, 1)\ndeaths_non_brain_no_vax = model.predict(x_new)\nx_new = np.array([1000000]).reshape(-1, 1)\ndeaths_non_brain_vaxxed = model.predict(x_new)","f319a5d4":"y = df_vaxxed[column_name_increment_monthly_non_cardiovascular].values\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3, random_state = 0)\nmodel.fit(x_train, y_train)\ny_pred = model.predict(x_test)\nprint(r2_score(y_test, y_pred))","f9aa663a":"# 0 means the model is perfect. Therefore the value should be as close to 0 as possible\nmeanAbErr = metrics.mean_absolute_error(y_test, y_pred)\nmeanSqErr = metrics.mean_squared_error(y_test, y_pred)\nrootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred))\n\nprint('Mean Absolute Error:', meanAbErr)\nprint('Mean Square Error:', meanSqErr)\nprint('Root Mean Square Error:', rootMeanSqErr)","6ef108e8":"x_new = np.array([1]).reshape(-1, 1)\ndeaths_non_heart_no_vax = model.predict(x_new)\nx_new = np.array([1000000]).reshape(-1, 1)\ndeaths_non_heart_vaxxed = model.predict(x_new)","d0f0d5c0":"y = df_vaxxed[column_name_increment_monthly__lower_respiratory].values\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3, random_state = 0)\nmodel.fit(x_train, y_train)\ny_pred = model.predict(x_test)\nprint(r2_score(y_test, y_pred))","20729e6e":"# 0 means the model is perfect. Therefore the value should be as close to 0 as possible\nmeanAbErr = metrics.mean_absolute_error(y_test, y_pred)\nmeanSqErr = metrics.mean_squared_error(y_test, y_pred)\nrootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred))\n\nprint('Mean Absolute Error:', meanAbErr)\nprint('Mean Square Error:', meanSqErr)\nprint('Root Mean Square Error:', rootMeanSqErr)","7c2617da":"x_new = np.array([1]).reshape(-1, 1)\ndeaths_non_lungs_no_vax = model.predict(x_new)\nx_new = np.array([1000000]).reshape(-1, 1)\ndeaths_non_lungs_vaxxed = model.predict(x_new)","21296c96":"y = df_vaxxed[column_name_increment_monthly_diabetes].values\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3, random_state = 0)\nmodel.fit(x_train, y_train)\ny_pred = model.predict(x_test)\nprint(r2_score(y_test, y_pred))","30cae7be":"# 0 means the model is perfect. Therefore the value should be as close to 0 as possible\nmeanAbErr = metrics.mean_absolute_error(y_test, y_pred)\nmeanSqErr = metrics.mean_squared_error(y_test, y_pred)\nrootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred))\n\nprint('Mean Absolute Error:', meanAbErr)\nprint('Mean Square Error:', meanSqErr)\nprint('Root Mean Square Error:', rootMeanSqErr)","d70865c0":"x_new = np.array([1]).reshape(-1, 1)\ndeaths_non_diabetes_no_vax = model.predict(x_new)\nx_new = np.array([1000000]).reshape(-1, 1)\ndeaths_non_diabetes_vaxxed = model.predict(x_new)","55ee2802":"total_deaths_no_vax = deaths_non_classified_no_vax + deaths_non_tumor_no_vax + deaths_non_brain_no_vax + deaths_non_heart_no_vax + deaths_non_lungs_no_vax + deaths_non_diabetes_no_vax\ntotal_deaths_vaxxed = deaths_non_classified_vaxxed + deaths_non_tumor_vaxxed + deaths_non_brain_vaxxed + deaths_non_heart_vaxxed + deaths_non_lungs_vaxxed + deaths_non_diabetes_vaxxed\ndelta = total_deaths_vaxxed - total_deaths_no_vax\nprint(delta*100\/1000000)","e4bc1271":"delta_non_classified = deaths_non_classified_vaxxed- deaths_non_classified_no_vax\nprint(delta_non_classified*100\/delta)","c8915bee":"Given this model: \n* We are only considering causes of death with more correlation rate: non classified, tumors, cerebrovascular, cardiovascular, lower respiratory illness and diabetes. \n* We are excluding completely: nephrosis, natural causes, influenza, pneumonia, alzheimer, septicemia, other respiratory and covid.\n* We have a fair margin of error on the correlated causes.\n* We can safely assume that we are not including potential vaccine related deaths from the excluded causes.\n\n# **Conclusion:** Covid-19 Vaccination alone has around 1.15% death rate in one month after vaccination date. And 3.5% of those definitely did not have an underlying condition (unclassified deaths).","2c8b49b6":"* **Random Forest Regression:**","78867969":"Model for diabetes","ed9ee74e":"# Covid 19 stats from official sources:\n\n* [67.6% of people](https:\/\/www.reuters.com\/world\/india\/india-govt-survey-shows-two-thirds-have-coronavirus-antibodies-2021-07-20\/) have natural inmunity against Covid-19.\n* 15.6% of people who get the disease, are asymptomatic from COVID infection. ([source](https:\/\/pubmed.ncbi.nlm.nih.gov\/32691881\/)).\n* Covid-19 mortaility rate in the USA: 1.8% on the highest mortality rate (age-agnostic). ([source](https:\/\/coronavirus.jhu.edu\/data\/mortality))\n* 4.5% of all deaths occurred in patients under the age of 65 who did not have an underlying medical condition ([source](https:\/\/www.worldometers.info\/coronavirus\/coronavirus-death-rate\/)).\n\n# Conclusions: \n* Chances of getting Covid-19 infection with symptoms are 27.35%.\n* If you don't have an underlying condition and aren't vaccinated, your chances of dying with COVID are 0.023%. If you have an underlying condition and are unvaccinated, your chance of dying with COVID is 0.5%.\n* If you have an underlying condition, your chance of dying from the vaccine **in one month time** is 1.09%. If you don't have an underlying condition, your chances of dying from the vaccine **in one month time** are 0.058%.\n* Chances of other side effects from the COVID vaccine are quite high, I won't quantify it as accurate data is not available right now.\n* Chances of long term side effects from the COVID vaccine and deaths after 1 month are **unknown at this time.** The vaccines are experimental so no such data exist at this point.\n\n# The main conclusion is: if you vaccinate against Covid-19, your chances of dying (from vaccination alone) increase around 152% and **only considering the first month after vaccination**. If you consider mid-to-long term conditions (that are virtually unknown at this time), the probability increases considerably.","84279ffe":"# Conclusion #1\n\nStatistical analysis shows that COVID Vaccine Dose is **strongly** correlated to unclassified deaths. From the visualization alone we can tell that with 0 doses, the max number of unclassified deaths for the next month following vaccination is around 500, for any state. As the number of vaccination doses increase, the number of unclassified deaths for the month following increase 300%+.\n\nIt'd be interesting to see what more pro data analysts can make of this data.","f9e3fb01":"# **Intro**\n\nSince early 2020, we all know the COVID-19 pandemic was declared by the WHO, according to the new definition of Pandemic from 2009, that removed the section that stated (\"with enormous numbers of deaths and illness.\"):\n![Screenshot from webcrawler text, as the official doc was deleted by the WHO.](https:\/\/i.ibb.co\/8YHpWv9\/Pandemic-def.jpg)\n\nEver since then, a race for developing a vaccine was triggered. And after 2 months of phase 3 trials of a new mRNA technology never tested in humans before, vaccines where [approved for emergency use worldwide](https:\/\/www.fda.gov\/vaccines-blood-biologics\/vaccines\/emergency-use-authorization-vaccines-explained), during their phase 3 trial experiments currently in progress (officially until 2023).\n\nThis development urge us to consider the currently available data for analysis.\n\n# **Hypothesis**\nA hyphothesis that I would like to put to the test is the claim that vaccination benefits outweight the risks. In order to do that with the data that we have currently, we are going to analyse how the vaccination allocations may be correlated with the number of deaths for the next month. We will listen now to the unforgiving answers from the data itself.","79574328":"That gives us an initial taste of what the data is saying. A weak Pearson Product-Moment Correlation (random features) is around 30%-40%, so everything above 50% is considered correlated.\nThis initial analysis tells us that the number of vaccination doses, is somehow correlated with all causes of death, except for Septicemia and COVID-19; and is **significantly** correlated with \"Not classified Causes\".\nLet's dig deeper...","2359d05c":"**69.75 of the data fits the Random Forest Regression model**","ce381d1e":"* **Decision Tree Regression:**","644e1020":"Model for lower respiratory disceases","3168610b":"# Evaluating different regression models for deaths prediction\n* **Linear Regression:**","e1f2fb81":"* **Step 3:**\n**Data preprocessing: **\n* We are going to be using all of the vendors vaccines together (Pfizer, Moderna and Janssen), because the goal is not to evaluate them separately.\n* Remove the country-level records in order to analyse only by State. We want to analyze the records by State, as it gives us the necesary variability for States with different vaccination allocation efforts.\n* Remove the last 1 month and 1\/2 vaccination allocation records, because we want to correlate the results with 1 month after vaccination, and such data doesn't exist on the death count dataset (it's real time, so that would mean 1 month from now we will have that data).\n* Add 2 months of data from death counts to the vaccination records, in order to include 2 months of pre-vaccination death count records for higher correlation precision.","94331857":"**59.65 of the data fits the simple Linear Regression model**","1015de49":"* **Step 5:**\nNow lets figure out correlation:","ac2fc392":"# **Method**\n\n* **Step 1:**\nImport libraries, declare functions and variables.","8da25602":"Model for cerebrovascular","85c6a085":"* **Step 4:**\n**Data preprocessing:** \n\nWe are going to add the sum of all deaths by different causes to each weekly vaccination record, for the state.\nSo, for each vaccination weekly record, we include a whole month of accumulated death count.","b836a0f2":"**65.37 of the data fits the simple Decision Tree Regression model**","633dc696":"* **Step 2:**\nImport all of the files we are going to be using (raw files from the CDC).","b6596e35":"**67.14 of the data fits the Deep Learning Regression model**","85e62a97":"Model for Tumors:","4486d2e9":"# Using our predictor to measure deaths increment per million people.","5cca348a":"Model for cardiovascular","01120099":"* **Step 6:**\nWe are going to do some visualizations of our findings:"}}