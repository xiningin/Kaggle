{"cell_type":{"c5909c09":"code","88a0ca01":"code","b28b1703":"code","4344bc58":"code","39a19bdb":"code","91ee87ba":"code","2f8e3df2":"code","90e2e110":"code","049b7ee9":"code","0e6cf933":"code","09cd2067":"code","07099eb6":"code","bd23e829":"code","abc7ac76":"code","48c86b08":"code","6b791d34":"code","6f853f78":"code","cf61fbf8":"code","9e59e9c0":"code","cb0bd46b":"code","f9ed3bb6":"code","417af4cc":"code","74e1dc1e":"code","91788b8a":"code","57335bd0":"code","bc2b107b":"code","1eaa4714":"code","e6d43f04":"code","a6574e3d":"code","d61aa5c3":"markdown","cfc3577d":"markdown","d4b91c1b":"markdown","52e85bc4":"markdown","3babbf2b":"markdown","f6115ba7":"markdown","9d9b12b1":"markdown","f40843fb":"markdown","4e20a5f2":"markdown","4a849385":"markdown","6a210ac4":"markdown","35352925":"markdown","1b26814c":"markdown","3943cfce":"markdown","3aefe1e6":"markdown","80a9540e":"markdown","82f0171e":"markdown","b76aaf12":"markdown","9edc8104":"markdown","7380276c":"markdown"},"source":{"c5909c09":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom PIL import Image\nfrom glob import glob\nfrom tqdm import tqdm\nimport cv2","88a0ca01":"data_dir = '..\/input\/hpa-single-cell-image-classification\/'\ntrain_dir = data_dir + 'train\/'\ntrain_df = pd.read_csv(\"..\/input\/hpa-single-cell-image-classification\/train.csv\")\ntrain_df","b28b1703":"def get_binary_mask(img):\n    \"\"\" key : RGB \uc774\ubbf8\uc9c0\ub97c Gray scale \uc774\ubbf8\uc9c0\ub85c \ubcc0\ud658\ud558\ub294 \ud568\uc218\n    \n        < get_binary_mask \ud568\uc218 >\n        \uc774\uc9c4 segmentation (\uac01 \ud53d\uc140\uc744 \uc774\uc9c4\uc73c\ub85c \ubd84\ub958\ud558\ub294 \uac83 = \ud751\ubc31\uc73c\ub85c \ubd84\ub958)\uc744 \ud558\uae30 \uc704\ud574 \n        Otsu threshold\ub97c \uc801\uc6a9\ud558\uae30 \uc804,\n        RGB \uc774\ubbf8\uc9c0\ub97c gray scale \uc774\ubbf8\uc9c0\ub85c \ubc14\uafb8\ub294 \ud568\uc218\n        \n        - \uac01 \ud53d\uc140\uc744 \uc774\uc9c4\uc73c\ub85c \ubd84\ub958\ud558\uae30 \uc704\ud574\uc11c\ub294 gray scale \uc774\ubbf8\uc9c0\uac00 \ud544\uc694\n        - Otsu threshold : \ud53d\uc140\uc744 \uc774\uc9c4 \ubd84\ub958\ud558\ub294 otsu threshold.\n    \"\"\"\n    blurred_img = cv2.GaussianBlur(img, (25,25), 0)\n    gray_img = cv2.cvtColor(blurred_img, cv2.COLOR_RGBA2GRAY)\n    ret, otsu = cv2.threshold(gray_img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n    \n    kernel = np.ones((40,40), np.uint8)\n    closed_mask = cv2.morphologyEx(otsu, cv2.MORPH_CLOSE, kernel) # img, opening \ubc29\uc2dd, kernel \uc0ac\uc774\uc988\n    \n    return closed_mask\n\n# \uc774\ubbf8\uc9c0\ub97c otsu threshold\uc5d0 \uae30\ubc18\ud55c grayscale \uc774\ubbf8\uc9c0\ub85c \ubc14\uafbc\ud6c4, \n# \ub178\uc774\uc988 \uc81c\uac70\ub97c \ud55c\ubc88 \ud574\uc900 mask(binary segmentation image)\ub97c \ub9ac\ud134","4344bc58":"def load_RGBY_image(image_id_path):\n    \"\"\" key : \ubaa8\ub4e0 \uc0c9\uc0c1\uc758 \uc774\ubbf8\uc9c0\ub97c \ud569\ud55c array \ub97c \ub9ac\ud134. \n        Load and stack the channels that are stored separately.\n    \"\"\"\n    red_image = cv2.imread(image_id_path+\"_red.png\", cv2.IMREAD_UNCHANGED)\n    green_image = cv2.imread(image_id_path+\"_green.png\", cv2.IMREAD_UNCHANGED)\n    blue_image = cv2.imread(image_id_path+\"_blue.png\", cv2.IMREAD_UNCHANGED)\n    yellow_image = cv2.imread(image_id_path+\"_yellow.png\", cv2.IMREAD_UNCHANGED)\n\n    stacked_images = np.transpose(np.array([red_image, green_image, blue_image, yellow_image]), \n                                  (1,2,0))\n    \n    return stacked_images\n\n# cv2.IMREAD_UNCHANGED : alpha channel \ud3ec\ud568. source image \ub85c \uc77d\uc5b4\ub4e4\uc784 ARGB\n# TODO : \uadfc\ub370 \uc5ec\uae30\uc120 \uc65c 1\ucc28\uc6d0\uc774\uc9c0?\n# np.transpose : W x H x C -> C x W x H \ub85c \ubcc0\uacbd","39a19bdb":"fig, axes = plt.subplots(1,2,figsize=(12,4))\naxes[0].imshow(stacked_images[:,:,:3]) # RGB image\naxes[1].imshow(binary_mask)\nplt.show();","91ee87ba":"cv2.imread(image_id_path+'_red.png', cv2.IMREAD_COLOR).shape","2f8e3df2":"# sample \ud655\uc778\nimage_id_path = train_dir + train_df.iloc[0]['ID']\nstacked_images = load_RGBY_image(image_id_path) # 4 channel : red, green, blue, yellow\nbinary_mask = get_binary_mask(stacked_images)\n\nprint(f\"stacked_images.shape : {stacked_images.shape}\\nbinary_mask.shape : {binary_mask.shape}\")","90e2e110":"def rle_encoding(x):\n    \n    \"\"\" Run-length encoding : https:\/\/en.wikipedia.org\/wiki\/Run-length_encoding\n    \n        \ub9c8\uc2a4\ud06c\ub97c \uc800\uc7a5\ud558\uae30 \uc26c\uc6b4 \ud615\uc2dd\uc73c\ub85c \ubc14\uafb8\ub294 \uac83\n        RLE encoding \ub41c \ub9c8\uc2a4\ud06c\ub97c \ubaa8\ub378\uc5d0 input \uc2dc\ud0a8\ub2e4.\n        \n        ex) WWWBBBBWWCCCCCC = 3W4B2W6C\n    \"\"\"\n    \n    dots = np.where(x.T.flatten() == 255)[0]\n    run_lengths = []\n    prev = -2\n    \n    for b in dots:\n        if (b > prev + 1):\n            run_lengths.extend((b+1, 0))\n        run_lengths[-1] += 1\n        prev = b # \ud55c\uce78 \uc774\uc0c1 \ub3d9\ub5a8\uc5b4\uc838 \uc788\uc744 \uacbd\uc6b0 length \ub9ac\uc14b\n        \n    return ' '.join([str(x) for x in run_lengths])","049b7ee9":"def get_instance_masks(binary_mask):\n    \"\"\"\n        \ubc14\uc774\ub108\ub9ac \ub9c8\uc2a4\ud06c\ub97c input \ubc1b\uc544\uc11c,\n        \uc791\uc740 \uc544\uc774\ud15c\uc740 \uac78\ub7ec\ub0b4\uace0, \ud070 binary larget object \uc758 \ub3c5\ub9bd\ub41c \ub9c8\uc2a4\ud06c\ub97c \uc0dd\uc131\ud55c\ub2e4.\n    \"\"\"\n    contours = cv2.findContours(binary_mask, \n                                cv2.RETR_TREE,\n                                cv2.CHAIN_APPROX_SIMPLE)\n    instance_masks = []\n    for contour in contours[0]:\n        if cv2.contourArea(contour) > 100: # \ud615\ud0dc\uc758 \ub113\uc774 \uad6c\ud558\uae30\n            instance_contour = np.zeros(binary_mask.shape) # \uc77c\ub2e8 \uc804\uccb4 \uc774\ubbf8\uc9c0 \ud06c\uae30\ub9cc\ud07c\n            cv2.drawContours(instance_contour, [contour], \n                             0, 255, thickness = cv2.FILLED)\n            \n            encoded_cell_mask = rle_encoding(instance_contour)\n            instance_masks.append(encoded_cell_mask)\n            \n    return instance_masks\n    \n# parameter \uc124\uba85\uc740 \ub9c1\ud06c\ucc38\uc870\n# cv2.RETR_TREE : \ubaa8\ub4e0 contours line \uc744 \ucc3e\uc73c\uba70, \ubaa8\ub4e0 hierachy \uad00\uacc4\ub97c \uad6c\uc131\ud568.\n# cv2.CHAIN_APPROX_SIMPLE : contours line \uc744 \uadf8\ub9b4 \uc218 \uc788\ub294 point \ub9cc \uc800\uc7a5(ex: \uc0ac\uac01\ud615\uc774\uba74 4\uac1c \ud3ec\uc778\ud2b8)","0e6cf933":"train_df[:20].head(5) # iterrows \ub85c \ud589\uc744 \ud558\ub098\uc529 \ubd88\ub7ec\uc62c dataframe","09cd2067":"# \uc544\ub798 process \uc608\uc2dc \ubc0f \uc2dc\uac01\ud654\nfor idx, item in train_df.iterrows():\n    image_id_path = train_dir+item.ID\n    break\n    \nstacked_images = load_RGBY_image(image_id_path)\nbinary_mask = get_binary_mask(stacked_images)\ninstance_masks = get_instance_masks(binary_mask)\n\nprint(f\"stacked_images.shape : {stacked_images.shape}\\nbinary_mask.shape : {binary_mask.shape}\")","07099eb6":"fig, axes = plt.subplots(1,2,figsize=(12,4))\naxes[0].imshow(stacked_images[:,:,:3]) # RGB image\naxes[1].imshow(binary_mask)\nplt.show();","bd23e829":"# get_instance_mask \ud568\uc218 \ub0b4\ubd80\n\n# contours (\ub77c\uc778 \ub530\ub0b4\uae30)\ncontours = cv2.findContours(binary_mask, # image\n                            cv2.RETR_TREE, # contours \ub77c\uc778, \ubaa8\ub4e0 hierachy \uad00\uacc4 \uad6c\uc131 = \ubaa8\ub4e0 \uacbd\uacc4\uc5d0 \ucee8\ud22c\uc5b4\ub97c \uadf8\ub9bc\n                            cv2.CHAIN_APPROX_SIMPLE) \n# contours line \uc744 \uadf8\ub9b4 \uc218 \uc788\ub294 \ud3ec\uc778\ud2b8 \uc800\uc7a5, 4\uac01\ud615\uc740 4\uac1c. \ub9ce\uc744 \uacbd\uc6b0, \ub9d0 \uadf8\ub300\ub85c \ub9ce\uae30 \ub54c\ubb38\uc5d0.\ncontours[1]","abc7ac76":"for i in contours[0]:\n    print(i.shape)\n# 5\uac1c\uc758 \ub77c\uc778\uc744 \ub530\ub0c8\ub2e4. = contours \ub294 \uac80\uc740\uc0c9 \ubc30\uacbd\uc5d0\uc11c \ud770\uc0c9\uc744 \ucc3e\ub294 \uac83\n# \ud55c\ubd93\uadf8\ub9ac\uae30\ub85c \uadf8\ub9b4 \uc218 \uc788\ub294 \ubb3c\uccb4 \ub369\uc5b4\ub9ac\ub97c \ucd1d 5\uac1c \ucc3e\uc558\ub2e4\ub294 \ub9d0.","48c86b08":"# contours 5 \uac1c \uc911 \ud558\ub098\uc529 \ud14c\uc2a4\ud2b8 \uc2dc\uac01\ud654 \ud574\ubcf4\uc790\ninstance_masks = []\ncontour = contours[0][0] # 1\/5\nif cv2.contourArea(contour) > 100:\n    instance_contour = np.zeros(binary_mask.shape)\n    cv2.drawContours(instance_contour, [contour], 0, 255, thickness = cv2.FILLED)\n    \nplt.imshow(instance_contour)\nplt.title('instance_contour visualization 1\/5')\nplt.show();","6b791d34":"print(f\"instance_contou unique value : {np.unique(instance_contour)}\")\nprint(f\"instance_contour.shape : {instance_contour.shape}\")\nall_pixels = instance_contour.shape[0] * instance_contour.shape[1]\nprint(f\"all pixel length : {all_pixels}\")","6f853f78":"# RLE_encoding \ud568\uc218 \uc548\uc73c\ub85c\n\ntotal = len(np.where(instance_contour.T.flatten() == 255)[0])\nprint(f\"\ud770\uc0c9\uc778 \uc778\ub371\uc2a4\uc758 \ud53d\uc140 \uc218 : {total}\")\nprint(f\"\ube44\uc728 : {(total \/ all_pixels):.4f}\")\ndots = np.where(instance_contour.T.flatten() == 255)[0]\nprint(f\"\\n dots(index) : {dots}\")\nprint(f\"\\tdots : instance contour \ub97c \uc804\uce58\ud558\uace0 flatten \uc2dc\ud0a8 \ud6c4, \ud770\uc0c9\uc778 \uac83\ub4e4\uc758 \uc778\ub371\uc2a4 \uac12\ub9cc \ubf51\uc544\ub0b8 \uac83\")","cf61fbf8":"# x = instance_contour\nrun_lengths = []\nprev = -2\nfor b in dots:\n    if (b > prev + 1):               # b \uac00 0 \uc774\uc0c1\uc774\uba74, \n        run_lengths.extend((b+1, 0)) #  \n    run_lengths[-1] += 1\n    prev = b\nrle_sample = ' '.join([str(x) for x in run_lengths])\nlen(rle_sample)","9e59e9c0":"rle_sample[:500]\n# encoded_cell_mask = rle_encoding(instance_contour)\n# encoded_cell_mask \n# \uc774 \uacfc\uc815\uc744 \uac70\uce5c \uac83","cb0bd46b":"process_RLE_for = 20\ntrain_df[\"RLE_encoding\"] = \"\"\n\nwith tqdm(total=process_RLE_for) as pbar: \n    for idx, item in train_df[:process_RLE_for].iterrows():\n        image_id_path = train_dir+item.ID\n\n        stacked_images = load_RGBY_image(image_id_path)\n        binary_mask = get_binary_mask(stacked_images)\n        instance_masks = get_instance_masks(binary_mask)\n\n        train_df.at[idx, \"RLE_encoding\"] = str(instance_masks)\n        pbar.update(1) # to 20(total)\n        \n        \n# iterrows : \uccab \ubc88\uc9f8 \ubcc0\uc218 idx \uc5d0 \uc778\ub371\uc2a4\ub97c \ubc1b\uace0, item \uc740 \uc5f4\uc758 \ud589\uc5d0 \ud558\ub098\uc529 \uc811\uadfc\ud558\uc5ec \ucd9c\ub825","f9ed3bb6":"train_df.loc[15:25] # 20\uac1c\ub9cc \ud588\uc73c\ubbc0\ub85c","417af4cc":"def plot_color_distribution(isolated_cell_img):\n    color = ('r', 'g', 'b', 'y')\n    for i, col in enumerate(color):\n        histr = cv2.calcHist([isolated_cell_img],[i], None, [256], [1, 256])\n        plt.plot(histr, color = col)\n        plt.xlim([1, 256])\n    plt.show();","74e1dc1e":"def analyze_individual_cells(binary_mask, original_image): \n    \n    contours = cv2.findContours(binary_mask,\n                                cv2.RETR_TREE,\n                                cv2.CHAIN_APPROX_SIMPLE)\n    \n    for contour in contours[0]:\n        if cv2.contourArea(contour) > 100:\n            x, y, width, height = cv2.boundingRect(contour)\n            \n            instance_contour = np.zeros(binary_mask.shape)\n            cv2.drawContours(instance_contour, [contour], 0, 255, thickness = cv2.FILLED)\n            \n            isolated_cell_image = np.zeros(binary_mask.shape)\n            isolated_cell_image = cv2.bitwise_and(original_image, original_image, mask = instance_contour.astype('uint8'))\n            \n            plt.imshow(isolated_cell_image[y : y+height, x : x+width, :3])\n            plt.show()\n            plot_color_distribution(isolated_cell_image[y:y+height, x:x+width])","91788b8a":"image_id_path = train_dir + train_df.iloc[0]['ID']\nstacked_images = load_RGBY_image(image_id_path)\nbinary_mask = get_binary_mask(stacked_images)\n\nfig, axes = plt.subplots(1,2,figsize=(12,4))\naxes[0].imshow(stacked_images[:,:,:3]) # RGB image\naxes[1].imshow(binary_mask)\nplt.show();","57335bd0":"# \ube44\ud2b8\uc5f0\uc0b0 \uc218\ud589\ncontours = cv2.findContours(binary_mask,\n                            cv2.RETR_TREE,\n                            cv2.CHAIN_APPROX_SIMPLE)\n\noriginal_image = stacked_images\n\ncontour = contours[0][0] # contours \uc911 \uccab \ubc88\uc9f8 \ud558\ub098\ub85c \uc2dc\uac01\ud654 \uc2dc\ub3c4\nif cv2.contourArea(contour) > 100:\n    x, y, width, height = cv2.boundingRect(contour) # contour bounding box \uc0dd\uc131 (format = COCO)\n    instance_contour = np.zeros(binary_mask.shape)\n    cv2.drawContours(instance_contour, [contour], 0, 255, thickness = cv2.FILLED)\n\n    isolated_cell_image = np.zeros(binary_mask.shape)\n    isolated_cell_image = cv2.bitwise_and(original_image, original_image, mask = instance_contour.astype('uint8'))\n            \nprint(f\"isolated_cell_image.shape : {isolated_cell_image.shape}\")","bc2b107b":"fig, axes = plt.subplots(1,2,figsize=(12,4))\naxes[0].imshow(isolated_cell_image[y : y+height, x : x+width, :3]) # \ud655\ub300\ubc84\uc804\naxes[1].imshow(isolated_cell_image[:,:,:3])\nplt.show();","1eaa4714":"plt.figure(figsize=(4,4))\ncolor = ('r', 'g', 'b', 'y')\nfor i, col in enumerate(color):\n    for i, col in enumerate(color):\n        histr = cv2.calcHist([isolated_cell_image],[i], None, [256], [1, 256]) \n        # isolated_cell_img \uc758 \uac01 channel \uc5d0 \ub300\ud574 histogram \uc744 \ubf51\uc544\ub0b8\ub2e4.\n        plt.plot(histr, color = col)\n        plt.xlim([1, 256]) # RGB \uc218\uce58\nplt.show();","e6d43f04":"analyze_individual_cells(binary_mask, stacked_images)","a6574e3d":"#TODO : Tasks","d61aa5c3":"### [Contours](https:\/\/opencv-python.readthedocs.io\/en\/latest\/doc\/15.imageContours\/imageContours.html) \n: cv2.findContours, cv2.contourArea, cv2.drawContours    \n\n* **contours** : \ub3d9\uc77c\ud55c \uc0c9 \ub610\ub294 \ub3d9\uc77c\ud55c \uac15\ub3c4\ub97c \uac00\uc9c0\uace0 \uc788\ub294 \uc601\uc5ed\uc758 \uacbd\uacc4\uc120\uc744 \uc5f0\uacb0\ud55c \uc120 : like \ub4f1\uace0\uc120\n    - \uc815\ud655\ub3c4\ub97c \ub192\ud788\uae30 \uc704\ud574\uc11c Binary Image \ub97c \uc0ac\uc6a9. Threshold \ub098 canny edge \ub97c \uc120\ucc98\ub9ac\ub85c \uc218\ud589\n    - `cv2.findContours()` \ud568\uc218\ub294 \uc6d0\ubcf8 \uc774\ubbf8\uc9c0\ub97c \uc9c1\uc811 \uc218\uc815\ud558\uae30 \ub54c\ubb38\uc5d0, \uc6d0\ubcf8 \uc774\ubbf8\uc9c0\ub97c \ubcf4\uc874\ud558\ub824\uba74 Copy \ud574\uc11c \uc0ac\uc6a9\n    - OpenCV \uc5d0\uc11c\ub294 contours \ub97c \ucc3e\ub294 \uac83\uc740 \uac80\uc740\uc0c9 \ubc30\uacbd\uc5d0\uc11c \ud558\uc580\uc0c9 \ub300\uc0c1\uc744 \ucc3e\ub294 \uac83. So, \ub300\uc0c1 = \ud770\uc0c9, \ubc30\uacbd = \uac80\uc740\uc0c9\n\n**Find & Draw Contours**\n```py\ncv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]]) \u2192 image, contours, hierarchy\n\ncv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]]) \u2192 dst\n\n# parameter \ub294 \ub9c1\ud06c \ucc38\uc870\n```\n\n[\uc774\ubbf8\uc9c0 Contour \uc751\uc6a9 \ub9c1\ud06c](https:\/\/m.blog.naver.com\/PostView.nhn?blogId=samsjang&logNo=220516822775&proxyReferer=https:%2F%2Fwww.google.com%2F)","cfc3577d":"## Add the RLE encoding to the existing training dataframe\n\ntrain_df \uc5d0 RLE encoding \uac12\uc744 \ucd94\uac00\ud558\uc790","d4b91c1b":"# Reference : [Original Notebook](https:\/\/www.kaggle.com\/frlemarchand\/generate-masks-from-weak-image-level-labels)\n\nhttps:\/\/www.kaggle.com\/frlemarchand\/generate-masks-from-weak-image-level-labels  \nI refer to this notebook.  \nI study many function, code and knowledge based on this notebook.\nAnd then I add more information and knowledge by myself.    \n\nThanks for   \n[@Francois Lemarchand](https:\/\/www.kaggle.com\/frlemarchand)\n\n### \uc774 \ub178\ud2b8\ubd81\uc740 \ud559\uc2b5\uc744 \uc704\ud574 \uc704\uc758 \ucc38\uc870 \ub178\ud2b8\ubd81\uc744 \ucc38\uace0\ud558\uace0, \ubc88\uc5ed\ud558\uc600\uc73c\uba70, \ucd94\uac00\ub85c \uacf5\ubd80\ud55c \ub0b4\uc6a9\uacfc \uc9c0\uc2dd\uc744 \uc815\ub9ac\ud55c \ub178\ud2b8\ubd81\uc785\ub2c8\ub2e4.","52e85bc4":"### \uacb0\ub860\n\n\uc774\ub7ec\ud55c \uacfc\uc815\uc744 4\ubc88 \ub354 \ubc18\ubcf5\ud558\uc5ec \uc774\ubbf8\uc9c0\uc5d0 \ud574\ub2f9\ud558\ub294 \ud558\ub098\uc758 rle_encoding \ucd1d\uc9d1\ud569 \uc744 \ub9cc\ub4e0\ub2e4.","3babbf2b":"binary mask \ub294 RGB+Y \uc774\ubbf8\uc9c0\ub97c \uae30\uc900\uc73c\ub85c binary masking \uc744 \ud1b5\ud574 \ucd94\ucd9c.","f6115ba7":"### [Otsu threshold](https:\/\/opencv-python.readthedocs.io\/en\/latest\/doc\/09.imageThresholding\/imageThresholding.html)\n\n```py\ncv2.threshold(src, thres, maxval, type)\n- src : input_image \ub85c single_channel \uc774\ubbf8\uc9c0 (\uadf8\ub808\uc774 \uc2a4\ucf00\uc77c)\n- thresh : \uc784\uacc4\uac12\n- maxval : \uc784\uacc4\uac12\uc744 \ub118\uc5c8\uc744 \ub54c \uc801\uc6a9\ud560 value\n- type : thresholding type : type \uc5d0 \ub530\ub77c \uc774\uc9c4 \uc0c9\uae54\uc758 \ud0c0\uc785\uc744 \uc9c0\uc815\ud560 \uc218 \uc788\ub2e4.\n\ncv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)\n- \uc77c\ubd80 \uc601\uc5ed\uc774 \uc644\uc804\ud788 \ud770\uc0c9 \ub610\ub294 \uac80\uc815\uc0c9\uc73c\ub85c \ubcf4\uc5ec\uc9c0\ubbc0\ub85c \uc774\uac83\uc744 \ud574\uacb0\ud558\uae30 \uc704\ud55c \ud568\uc218\n```\n\nOtsu \uc758 \uc774\uc9c4\ud654  \n: thresholding \ucc98\ub9ac\uc5d0\uc11c \uc784\uacc4\uac12\uc740 \uc0ac\uc6a9\uc790\uac00 \uacb0\uc815\ud558\uc5ec parameter \ub85c \uc804\ub2ec. by trial and error \ubc29\uc2dd  \n: bimodal image(\ud788\uc2a4\ud1a0\uadf8\ub7a8\uc73c\ub85c \ubd84\uc11d\ud558\uba74 2\uac1c\uc758 peak \uac00 \uc788\ub294 \uc774\ubbf8\uc9c0)\uc758 \uacbd\uc6b0\ub294 \ud788\uc2a4\ud1a0\uadf8\ub7a8\uc5d0\uc11c \uc784\uacc4\uac12\uc744 \uc5b4\ub290\uc815\ub3c4 \uc815\ud655\ud788 \uacc4\uc0b0\ud560 \uc218 \uc788\ub2e4.  \n\nOtsu\uc758 \uc774\uc9c4\ud654(Otsu's Binarization)\ub780 bimodal image \uc5d0\uc11c \uc784\uacc4\uac12\uc744 \uc790\ub3d9\uc73c\ub85c \uacc4\uc0b0\ud574\uc8fc\ub294 \uac83.\n\n### [cv2.morphologyEx](https:\/\/webnautes.tistory.com\/1257)\nOpenCV \uc5d0\uc11c \uc81c\uacf5\ud558\ub294 \ud568\uc218 : Erosion, Dilation, Opening, Closing  \n1. Erosion : \ubc14\uc774\ub108\ub9ac \uc774\ubbf8\uc9c0\uc5d0\uc11c \ud770\uc0c9 '\uc624\ube0c\uc81d\ud2b8'\uc758 \uc678\uacfd \ud53d\uc140\uc744 0(\uac80\uc740\uc0c9)\uc73c\ub85c \ub9cc\ub4e0\ub2e4.(\uc0ac\uc9c4 \uc804\uccb4\uc758 \uc678\uacfd X) = \uac00\ub298\uac8c\n2. Dilation : Erosion \uacfc \ubc18\ub300. \ud770\uc0c9 \uc624\ube0c\uc81d\ud2b8\uc758 \uc678\uacfd \ud53d\uc140\uc744 1\ub85c \ub9cc\ub4e0\ub2e4. = \ub450\uaecd\uac8c\n3. Opening : Erosion \uc5f0\uc0b0 \ub2e4\uc74c\uc5d0 Dilation \uc5f0\uc0b0\uc744 \uc801\uc6a9.(\ud55c\ubc88 \uc9c0\uc6b0\uace0\ub3c4 \uc874\uc7ac\ud558\ub294 \uac83\ub4e4\uc744 \ub450\uaecd\uac8c) \uc774\ubbf8\uc9c0 \uc0c1\uc758 \ub178\uc774\uc988(\uc791\uc740 \ud770\uc0c9)\ub97c \uc81c\uac70\ud558\ub294\ub370 \uc0ac\uc6a9 \n4. Closing : Dilation \uc5f0\uc0b0 \ub2e4\uc74c\uc5d0 Erosion \uc5f0\uc0b0\uc744 \uc801\uc6a9. \ud770\uc0c9 \uc624\ube0c\uc81d\ud2b8\uc5d0 \uc788\ub294 \uc791\uc740 \uac80\uc740\uc0c9 \uad6c\uba4d\ub4e4\uc744 \uba54\uc6b0\ub294\ub370 \uc0ac\uc6a9.\n```py\ncv2.erode()\ncv2.dilate()\ncv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)\ncv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)\n```  \nkernel : filter \ud06c\uae30","9d9b12b1":"contours[1] = hierachy\n\n|\uc778\ub371\uc2a4|\ub2e4\uc74c(next)|\uc774\uc804(prev)|\uc790\uc2dd(First Child)|\ubd80\ubaa8(parent)|\n|:-|:-:|:-:|:-:|:-:|\n|0|1|-1|-1|-1|\n|1|2|0|-1|-1|\n|2|3|1|-1|-1|\n|3|4|2|-1|-1|\n|4|-1|3|-1|-1|\n\n|\uc778\ub371\uc2a4|\ud589|\uc758\ubbf8|\ub2e4\uc74c|\uc774\uc804|\n|:-:|:-:|:-:|:-:|:-:|\n|\uc778\ub371\uc2a4 0 | 0\ubc88\uc9f8 \ud589 | \uccab \ubc88\uc9f8 \ub3c4\ud615\uc758 \ucee8\ud22c\uc5b4 | 1 = \ub2e4\uc74c \ub3c4\ud615\uc740 1\ud589| \uc758\ubbf8\uc5c6\uc74c |\n|\uc778\ub371\uc2a4 1 | 1\ubc88\uc9f8 \ud589 | \ub450 \ubc88\uc9f8 \ub3c4\ud615\uc758 \ucee8\ud22c\uc5b4 | 2 = \ub2e4\uc74c \ub3c4\ud615\uc740 2\ud589| 0 = \uc774\uc804 \ub3c4\ud615\uc740 0\ud589|\n|\uc778\ub371\uc2a4 2 | 2\ubc88\uc9f8 \ud589 | \uc138 \ubc88\uc9f8 \ub3c4\ud615\uc758 \ucee8\ud22c\uc5b4 | 3 = \ub2e4\uc74c \ub3c4\ud615\uc740 3\ud589| 1 = \uc774\uc804 \ub3c4\ud615\uc740 1\ud589|\n|\uc778\ub371\uc2a4 3 | 3\ubc88\uc9f8 \ud589 | \ub124 \ubc88\uc9f8 \ub3c4\ud615\uc758 \ucee8\ud22c\uc5b4 | 4 = \ub2e4\uc74c \ub3c4\ud615\uc740 4\ud589| 2 = \uc774\uc804 \ub3c4\ud615\uc740 2\ud589|\n|\uc778\ub371\uc2a4 4 | 4\ubc88\uc9f8 \ud589 | \ub2e4\uc12f \ubc88\uc9f8 \ub3c4\ud615\uc758 \ucee8\ud22c\uc5b4 | -1 = \ub2e4\uc74c \ub3c4\ud615\uc740 \uc5c6\uc74c| 3 = \uc774\uc804 \ub3c4\ud615\uc740 3\ud589|\n\n\n\n-1 : \uc758\ubbf8\uc5c6\uc74c  \n(\uc774 contours hierachy \uc5d0\uc11c\ub294 \uc790\uc2dd\uacfc \ubd80\ubaa8\uac00 \ubaa8\ub450 -1 \uc774\ubbc0\ub85c \ud45c \uc124\uba85\uc5d0\uc11c \uc81c\uc678\ud568)\n\n\uc790\uc2dd\uacfc \ubd80\ubaa8 \uad00\ub828 \uacc4\uce35\uc740 \ucc38\uace0\ub9c1\ud06c \ucc38\uc870 :\n[\ucc38\uace0 \ub9c1\ud06c](https:\/\/bkshin.tistory.com\/entry\/OpenCV-22-%EC%BB%A8%ED%88%AC%EC%96%B4Contour)\n\n<img src = 'https:\/\/img1.daumcdn.net\/thumb\/R1280x0\/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlDtdX%2FbtqHq2Q5eFD%2F1UqKRIEGFO81aGSIfwccIk%2Fimg.png' width = 300 height = 300 align = left>  \n\n\uc774\ucc98\ub7fc \uadf8\ub9bc\uc744 \uadf8\ub9b4 \uacbd\uc6b0 \ubc88\uac1c \ud558\ub098\uc5d0 \ub2e4\uc591\ud55c \ubc29\uc2dd\uc73c\ub85c \ucee8\ud22c\uc5b4\ub97c \uac10\uc2f8\ub294 \uadf8\ub9bc\uc744 \uadf8\ub9b4 \uc218 \uc788\uc74c","f40843fb":"\uc5ec\uae30\uc11c isolated_cell_image \ub294 contour \ub85c \ub098\ub220\uc9c4 \ub3c5\ub9bd\ub41c \ud55c \ub4f1\uace0\uc120\uc744 \ub530\ub77c \uc874\uc7ac\ud558\ub294 \uc138\ud3ec \ub369\uc5b4\ub9ac","4e20a5f2":"# Load the images and apply a binary mask","4a849385":"### [\ube44\ud2b8\uc5f0\uc0b0](https:\/\/opencv-python.readthedocs.io\/en\/latest\/doc\/07.imageArithmetic\/imageArithmetic.html)  \nsrc1, src2, dis, mask\n```py\ncv2.bitwise_and()\ncv2.bitwise_or()\ncv2.bitwise_not()\ncv2.bitwise_xor()\n```\nbinary \uc774\ubbf8\uc9c0 2\uac1c\ub97c \uac00\uc9c0\uace0 \ube44\ud2b8\uc5f0\uc0b0\uc744 \uc218\ud589\ud55c\ub2e4.\n\n---------\n\n\uc544\ub798\uc5d0\uc11c \ubcf4\ub4ef, \uc815\uc758\ud55c \ud568\uc218\ub97c \uc0ac\uc6a9\ud558\uc5ec \uac1c\ubcc4 \uc138\ud3ec\ub97c \ubd84\ub9ac\ud558\ub824\uace0 \ud560 \ub54c, \uc6b0\ub9ac\ub294 \uc138\ud3ec\uac00 \uc11c\ub85c \ub108\ubb34 \uac00\uae4c\uc774 \uc788\uc744 \ub54c \uba87 \uac00\uc9c0 \ubb38\uc81c\ub97c \uad00\ucc30\ud560 \uc218 \uc788\ub2e4.  ","6a210ac4":"## Introduction\n\n\uc774 \ub178\ud2b8\ubd81\uc740 \ub370\uc774\ud130\ub97c \ubd88\ub7ec\uc624\ub294 \uba87\uba87 \ud568\uc218\ub4e4\uc744 \uc18c\uac1c\ud558\ub294 \uac83\uacfc, \ud559\uc2b5 \uc774\ubbf8\uc9c0\uc5d0 \uc874\uc7ac\ud558\ub294 \ubaa8\ub4e0 \uc138\ud3ec\uc758 \ud074\ub798\uc2a4\ubcc4 \ub9c8\uc2a4\ud06c\ub97c \uc0dd\uc131\ud558\ub294 \uac83\uc744 \ubaa9\ud45c\ub85c \ud569\ub2c8\ub2e4.   \n\uac01 \ud074\ub798\uc2a4\ubcc4 \ub9c8\uc2a4\ud06c(instance segmentation masks) \ub97c \uc0dd\uc131\ud568\uc73c\ub85c\uc368, \uc6b0\ub9ac\ub294 \uc138\ud3ec\ub97c \uac1c\ubcc4\uc801\uc73c\ub85c \ubd84\uc11d\ud560 \uc218 \uc788\uace0, \uc804\uccb4 \uc774\ubbf8\uc9c0\ub97c \ub300\uc0c1\uc73c\ub85c \uc8fc\uc5b4\uc9c4 \ud55c\uac1c \ub610\ub294 \uc5ec\ub7ec\uac1c\uc758 \ub808\uc774\ube14\uacfc \uc5f0\uad00\uc9c0\uc5b4\ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4.  ","35352925":"### \ubc30\uc6b4\uc810\n\n\uc774 \ub178\ud2b8\ubd81\uc744 \ud1b5\ud574\uc11c HPA task \uc790\uccb4\ubcf4\ub2e4\ub294 \uae30\ubc18\uc774 \ub418\ub294 \ud568\uc218, image \ub97c \ub2e4\ub8e8\ub294 \uac83\uc5d0 \ub300\ud574\uc11c \ubc30\uc6e0\ub2e4.  \ntask \ub294 \ub2e4\ub978 \ub178\ud2b8\ubd81\uc744 \ud1b5\ud574\uc11c \uc5b4\ub5bb\uac8c \uad6c\uccb4\uc801\uc73c\ub85c \ud559\uc2b5\uacfc \uc608\uce21\uc774 \uc218\ud589\ub418\ub294\uc9c0, \uc815\ud655\ud55c task \ub294 \ubb34\uc5c7\uc778\uc9c0 \uacf5\ubd80\ud574\ubcf4\uc790.  ","1b26814c":"## Generate instance masks and convert to RLE encoding\n```py\ndef rle_encoding(x)\ndef get_instance_masks(binary_mask)\n```","3943cfce":"## \uc804\uccb4 contours \uc5d0 \ub300\ud574\uc11c \uc218\ud589","3aefe1e6":"### [Histogram (OpenCV, Matplotlib)](https:\/\/opencv-python.readthedocs.io\/en\/latest\/doc\/19.imageHistograms\/imageHistograms.html)\nOpenCV \uc640 Matplotlib \ub97c \uc774\uc6a9\ud558\uc5ec Histogram \uc744 \ucc3e\uc744 \uc218 \uc788\ub2e4.\n\n* Histogram : \uc774\ubbf8\uc9c0\uc758 \ubc1d\uae30\uc758 \ubd84\ud3ec\ub97c \uadf8\ub798\ud504\ub85c \ud45c\ud604\ud55c \ubc29\uc2dd. \uc774\ubbf8\uc9c0 \uc804\uccb4\uc758 \ubc1d\uae30 \ubd84\ud3ec\uc640 \ucc44\ub3c4(\uc0c9\uc758 \ubc1d\uace0 \uc5b4\ub450\uc6c0)\ub97c \uc54c \uc218 \uc788\ub2e4.\n```py\ncv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]])\n```\n  \n(\uc88c\uce21 \uc774\ubbf8\uc9c0)  \n2\uac00\uc9c0 \uc774\ubbf8\uc9c0\ub97c grayscale \ub85c \uc77d\uc5b4 \ube5b\uc758 \uc138\uae30 \ubd84\ud3ec\ub97c \ubcf4\uc5ec\uc8fc\ub294 \uc608\uc81c(\ucd9c\ucc98 : opencv-python.readthedocs.io)  \nRed Line\uc774\ubbf8\uc9c0\ub294 \uc804\uccb4\uc801\uc73c\ub85c \uc5b4\ub461\uae30 \ub54c\ubb38\uc5d0 \ud788\uc2a4\ud1a0\uadf8\ub7a8\uc5d0\uc11c \uc88c\uce21\uc758 \ubd84\ud3ec\uac00 \ub192\uace0, Green Line \uc774\ubbf8\uc9c0\ub294 \uc804\uccb4\uc801\uc73c\ub85c \ubc1d\uae30 \ub54c\ubb38\uc5d0 \uc624\ub978\ucabd\uc758 \ubd84\ud3ec\uac00 \ub192\uc2b5\ub2c8\ub2e4. \n\n(\uc6b0\uce21 \uc774\ubbf8\uc9c0)  \n\uc774\ubbf8\uc9c0\uc758 \ud2b9\uc815\uc601\uc5ed\uc758 \ud788\uc2a4\ud1a0\uadf8\ub7a8\uc744 \ubd84\uc11d\ud558\uae30 \uc704\ud574\uc11c mask \ub97c \uc801\uc6a9\ud560 \uc218 \uc788\ub2e4.  \nred : \uc6d0\ubcf8\uc774\ubbf8\uc9c0 \ud788\uc2a4\ud1a0\uadf8\ub7a8, blue : mask \uc801\uc6a9\ub41c \ud788\uc2a4\ud1a0\uadf8\ub7a8\n\n<img src = 'https:\/\/opencv-python.readthedocs.io\/en\/latest\/_images\/result0110.jpg' width = 500 height = 500 align = left>\n<img src = 'https:\/\/opencv-python.readthedocs.io\/en\/latest\/_images\/result026.jpg' width = 500 height = 500 align = right>\n\n\n","80a9540e":"Manual control of `tqdm()` updates using a `with` statement:    \nwith \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud574\uc11c tqdm \uc744 \uc218\ub3d9\uc73c\ub85c \ucee8\ud2b8\ub864\ud55c\ub2e4. update() \ub85c \uc218\ub3d9\uc73c\ub85c \uc9c4\ud589\ub960\uc744 \uc99d\uac00\uc2dc\ud0a8\ub2e4.  \n```py\nwith tqdm(total=100) as pbar:\n    for i in range(10):\n        sleep(0.1)\n        pbar.update(10)\n-------------------------------------\npbar = tqdm(total=100)\nfor i in range(10):\n    sleep(0.1)\n    pbar.update(10)\npbar.close()\n```\n[link](https:\/\/github.com\/tqdm\/tqdm)","82f0171e":"## \uc774\ubbf8\uc9c0 \ud788\uc2a4\ud1a0\uadf8\ub7a8\n\n\ud559\uc2b5 \uc774\ubbf8\uc9c0\uc758 \ubaa8\ub4e0 \uc138\ud3ec\uc5d0 \ub300\ud574 \uac1c\ubcc4 \ub9c8\uc2a4\ud06c\ub97c \uc0dd\uc131\ud568\uc73c\ub85c\uc368, \uc774\ubbf8\uc9c0 \ubd84\uc11d\uc744 \uc2e4\uc2dc\ud560 \uc218 \uc788\ub2e4.   \n\uc544\ub798\ub294, \ubaa8\ub4e0 \uc138\ud3ec\uc640 RGB \ucc44\ub110\uc758 \uc0c9 \ubd84\ud3ec\ub97c \uc2dc\uac01\ud654\ud558\uc600\ub2e4.  \n\uc138\ud3ec\uc758 \ud074\ub798\uc2a4\ub97c \ubd84\ubcc4\ud558\ub294 \ubc29\ubc95\uc740 \uc0c9 \ubd84\ud3ec signature \uc5d0 \uae30\ubc18\ud558\uc5ec clustering \ud558\ub294 \ubc29\ubc95\ub3c4 \uc788\ub2e4.","b76aaf12":"### 2) \ud504\ub85c\uc138\uc2a4 \uc9c4\ud589","9edc8104":"### 1) \uc81c\ub300\ub85c \ub41c \uc2dc\uc791 \uc804\uc5d0 \uac01 \uacfc\uc815\uc744 \ud558\ub098\ud558\ub098 \ub72f\uc5b4\ubcf4\uc790","7380276c":"\uc608\uc815\ub41c \ucf54\ub4dc \uc608\uc2dc\n```py\ninstance_masks = []\nfor contour in contours[0]: # \ud604\uc7ac 5\uac1c\n    if cv2.contourArea(contour) > 100: # \ucc3e\uc740 \uc601\uc5ed\uc774 \ub9e4\uc6b0 \uc791\ub2e4\uba74, \ud328\uc2a4\ud558\uaca0\ub2e4.\n        instance_contour = np.zeros(binary_mask.shape) # contour \ub9c8\ub2e4 \uc0c8\ub85c\uc6b4 \ub3c4\ud654\uc9c0\n        # \uc77c\ub2e8 \uc804\uccb4 \uc774\ubbf8\uc9c0 \ud06c\uae30\ub9cc\ud07c 0 array\uc0dd\uc131(\ubc30\uacbd) = \uc724\uacfd\uc120 \uadf8\ub9ac\uae30 \uc900\ube44\n        cv2.drawContours(instance_contour, # \uc785\ub825 \uc601\uc0c1(\uac80\uc740\uc0c9 \ub3c4\ud654\uc9c0)\n                         [contour],        # \uadf8\ub9bc \uadf8\ub9b4 \ucee8\ud22c\uc5b4 \ubc30\uc5f4 = contours\n                         0,                # \uadf8\ub9bc \uadf8\ub9b4 \ucee8\ud22c\uc5b4 \uc778\ub371\uc2a4 = contours[0]\n                         255,              # \uc0c9\uc0c1 \uac12 = \uc5ec\uae30\uc11c\ub294 \ud770\uc0c9\uc73c\ub85c \ud1b5\uc77c\n                         thickness = cv2.FILLED)\n        \n        encoded_cell_mask = rle_encoding(instance_contour) # \n        instance_masks.append(encoded_cell_mask)\n```"}}