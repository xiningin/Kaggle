{"cell_type":{"ff96ffed":"code","5c239d25":"code","76613f67":"code","5409a00d":"code","fd0902d1":"code","b93ee81b":"code","0b700093":"code","7a1e6ac2":"code","98ef732e":"code","b9eb1931":"markdown","8e9f95f7":"markdown","3d5fc44b":"markdown","c8456e2d":"markdown","7a9f2f2a":"markdown","6f9b8c32":"markdown","8e63bbb4":"markdown","e7c97073":"markdown"},"source":{"ff96ffed":"import os\nimport cv2\nimport numpy as np\nfrom tqdm import tqdm\nimport torch \nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim","5c239d25":"# False skips data pre-processing and training data can be loaded in directly\nREBUILD_DATA = True\n\nclass CatsVSDogs():\n    \n    # Size of the image\n    IMG_SIZE = 50\n    \n    # Directory location\n    CATS = '..\/input\/kaggle-cat-vs-dog-dataset\/kagglecatsanddogs_3367a\/PetImages\/Cat\/'\n    DOGS = '..\/input\/kaggle-cat-vs-dog-dataset\/kagglecatsanddogs_3367a\/PetImages\/Dog\/'\n    \n    # Labels for cats and dogs\n    LABELS = {CATS:0, DOGS:1}\n    \n    # Initializing variables\n    training_data = []\n    catcount = 0\n    dogcount = 0\n    \n    def make_training_data(self):\n        for label in self.LABELS:\n            \n            # Looping through each pictures\n            for f in tqdm(os.listdir(label)):\n                \n                try:\n                    path = os.path.join(label, f)\n\n                    # Reading images and converting to grayscale\n                    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)\n\n                    # Resizing images\n                    img = cv2.resize(img, (self.IMG_SIZE, self.IMG_SIZE))\n\n                    # Getting the training data\n                    self.training_data.append([np.array(img), np.eye(2)[self.LABELS[label]]])\n\n                    # Checking distribution of data\n                    if label == self.CATS:\n                        self.catcount += 1\n                    elif label == self.DOGS:\n                        self.dogcount += 1\n                        \n                except Exception as e:\n                    pass\n\n            np.random.shuffle(self.training_data)\n            np.save(\"training_data.npy\", self.training_data)\n            print(\"Cates: \", self.catcount)\n            print(\"Dogs: \", self.dogcount)\n            \nif REBUILD_DATA:\n    catsvdogs = CatsVSDogs()\n    catsvdogs.make_training_data()","76613f67":"training_data = np.load(\"training_data.npy\", allow_pickle = True)","5409a00d":"import matplotlib.pyplot as plt\n%matplotlib inline\n\nplt.imshow(training_data[1][0], cmap = \"gray\")","fd0902d1":"class Net(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 32, 5)\n        self.conv2 = nn.Conv2d(32, 64, 5)\n        self.conv3 = nn.Conv2d(64, 128, 5)\n        \n        # Getting the output size for the fully connected layer\n        x = torch.randn(50,50).view(-1, 1, 50, 50)\n        self._to_linear = None\n        self.convs(x)\n        \n        self.fc1 = nn.Linear(self._to_linear, 512)\n        self.fc2 = nn.Linear(512, 2)\n\n    def convs(self, x):\n        x = F.max_pool2d(F.relu(self.conv1(x)), (2,2))\n        x = F.max_pool2d(F.relu(self.conv2(x)), (2,2))\n        x = F.max_pool2d(F.relu(self.conv3(x)), (2,2))\n        \n        if self._to_linear is None:\n            self._to_linear = x[0].shape[0]*x[0].shape[1]*x[0].shape[2]\n            \n        return x\n    \n    def forward(self, x):\n        x = self.convs(x)\n        x = x.view(-1, self._to_linear)\n        x = F.relu(self.fc1(x))\n        x = F.softmax(self.fc2(x), dim=1)\n        return x\n\nnet = Net()","b93ee81b":"# Using Adam optimizer to optimize weights of the Neural Network\noptimizer = optim.Adam(net.parameters(), lr = 0.001)\n\n# Initializing loss function\nloss_function = nn.MSELoss()\n\n# Getting the features\nX = torch.Tensor([i[0] for i in training_data]).view(-1, 50, 50)\n\n# Scaling the features\nX = X\/255.0\n\n# Getting the target\ny = torch.Tensor([i[1] for i in training_data])\n\n# Statistics to create testing set\nVAL_PCT = 0.1\nval_size = int(len(X)*VAL_PCT)\nprint(val_size)\n","0b700093":"# Train test split\n\ntrain_X = X[:-val_size]\ntrain_y = y[:-val_size]\n\ntest_X = X[-val_size:]\ntest_y = y[-val_size:]","7a1e6ac2":"# Training the model in batches of 100\nBATCH_SIZE = 100\n\n# Number of Epochs\nEPOCHS = 1\n\n# Model Training\nfor epoch in range(EPOCHS):\n    for i in tqdm(range(0, len(train_X), BATCH_SIZE)):\n        batch_X = train_X[i:i+BATCH_SIZE].view(-1, 1, 50, 50)\n        batch_y = train_y[i:i+BATCH_SIZE]\n        \n        net.zero_grad()\n        outputs = net(batch_X)\n        loss = loss_function(outputs, batch_y)\n        loss.backward()\n        optimizer.step()\n        \nprint(loss)     ","98ef732e":"# Calculating Accuracy\n\ncorrect = 0\ntotal = 0\n\nwith torch.no_grad():\n     for i in tqdm(range(len(test_X))):\n            real_class = torch.argmax(test_y[i])\n            net_out = net(test_X[i].view(-1,1,50,50))[0]\n            predicted_class = torch.argmax(net_out)\n            \n            if predicted_class == real_class:\n                correct += 1\n            total +=1\n                \nprint(\"Accuracy: \", round(correct\/total, 3))","b9eb1931":"## Building a Convolutional Neural Network for the Cat vs Dogs dataset using PyTorch","8e9f95f7":"Splitting into training and test data","3d5fc44b":"Creating a class for data preprocessing","c8456e2d":"Loading the training data","7a9f2f2a":"Creating 3 Convolutional layer Neural Network for the classification task","6f9b8c32":"Accuracy can be further increased by training the model with higher number of Epochs.","8e63bbb4":"Importing necessary libraries","e7c97073":"Viewing an image from the dataset"}}