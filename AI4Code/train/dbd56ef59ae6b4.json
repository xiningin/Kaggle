{"cell_type":{"c2205569":"code","7834c3a3":"code","25455576":"code","3559b61d":"code","faa6a039":"code","e8608ded":"code","540e912a":"code","8fb853cc":"code","919f1c56":"code","0ab50cf8":"code","1810ae0a":"code","7819fd8d":"code","332ade68":"code","aa1626e8":"code","91b44cbd":"code","f6b9537b":"code","14b247fb":"code","6f40ecf3":"code","fa79d6f7":"code","9f6fdfdd":"code","af46409d":"code","96a00541":"code","9b3f13be":"code","6d4e930b":"code","b5c79fca":"code","dc5d7b96":"code","a076beed":"code","83b87f3c":"code","47afa41c":"code","664e950b":"code","7f882c96":"code","b9323708":"code","4ad47896":"markdown","75759ab1":"markdown","b79a51ee":"markdown","ba402a99":"markdown"},"source":{"c2205569":"import sys\nsys.path.append('..\/input\/pytorch-image-models\/pytorch-image-models-master')","7834c3a3":"import numpy as np\nimport pandas as pd \nimport os\nimport time \nimport albumentations as A\nfrom albumentations.pytorch import ToTensorV2\nfrom collections import defaultdict\nfrom tqdm import tqdm\nfrom sklearn import model_selection, preprocessing \nfrom sklearn.model_selection import KFold, GroupKFold\nimport cv2\nfrom matplotlib import pyplot as plt\nfrom PIL import Image\nimport copy\n\nimport torch \nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.optim.lr_scheduler import CosineAnnealingWarmRestarts, CosineAnnealingLR, ReduceLROnPlateau\n\nfrom torch.utils.data import Dataset, DataLoader \nimport torchvision\nfrom torchvision import models, transforms \nfrom torch.cuda.amp import autocast, GradScaler\n\n","25455576":"params = {\n    \"model\": \"efficientnet_b3\",\n    \"device\": torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\"),\n    \"lr\": 0.0001,\n    \"batch_size\": 2,\n    \"num_workers\": 16,\n    \"num_epochs\": 5,\n    \"T_0\":6, # CosineAnnealingWarmRestarts\n    \"min_lr\":1e-6\n}","3559b61d":"ROOT_DIR = \"..\/input\/ranzcr-clip-catheter-line-classification\"\ntrain_dir = \"..\/input\/ranzcr-clip-catheter-line-classification\/train\/\"","faa6a039":"df = pd.read_csv(os.path.join(ROOT_DIR, \"train.csv\"))","e8608ded":"df.head(5)","540e912a":"len(df['StudyInstanceUID'].unique())","8fb853cc":"import random \nimg_list = os.listdir(os.path.join(ROOT_DIR, \"train\/\"))\nfig, ax = plt.subplots(3, 3, figsize = (12, 12))\n\nfor row in range(3):\n    for col in range(3):\n        rand_idx = np.random.randint(len(img_list))\n        img = cv2.imread(os.path.join(ROOT_DIR, \"train\/\"+img_list[rand_idx]),cv2.COLOR_BGR2RGB)\n        ax[row, col].imshow(img)\n        #print(img.shape)\n        \n                    \nfig.show()","919f1c56":"sample_df = pd.read_csv(os.path.join(ROOT_DIR, \"sample_submission.csv\"))","0ab50cf8":"sample_df.head()","1810ae0a":"classes = sample_df.columns[1:]","7819fd8d":"len(classes)","332ade68":"labels = df[classes]","aa1626e8":"labels","91b44cbd":"#img_list = os.list_dir(os.path.join(ROOT_DIR, df[\"StudyInstanceUID\"]+\".jpg\"))","f6b9537b":"classes = df.columns[1:].values","14b247fb":"sample_df.columns[1:]","6f40ecf3":"classes = ['ETT - Abnormal', 'ETT - Borderline', 'ETT - Normal', 'NGT - Abnormal',\n       'NGT - Borderline', 'NGT - Incompletely Imaged', 'NGT - Normal',\n       'CVC - Abnormal', 'CVC - Borderline', 'CVC - Normal',\n       'Swan Ganz Catheter Present']","fa79d6f7":"df[classes].values","9f6fdfdd":"df[classes[:5]].value_counts().plot.bar(figsize=(12, 8))\nplt.show()","af46409d":"df.iloc[: ,0][1]","96a00541":"class RANZRDataset(Dataset):\n    def __init__(self, data_dir, df, transform=None):\n        self.data_dir = data_dir\n        self.df = df\n        self.files = df[\"StudyInstanceUID\"].values\n        self.labels = df[classes].values\n        self.transform = transform\n        \n    def __getitem__(self, idx):\n        img_name = self.files[idx]\n        file_path = f\"{self.data_dir}{img_name}\"+\".jpg\"\n#         image = Image.open(file_path).convert('RGB')\n#         image = np.array(image)\n        image = cv2.imread(file_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n        #print(file_path)\n        if self.transform:\n            augmented = self.transform(image = image)\n            image = augmented[\"image\"]\n        \n        label = torch.tensor(self.labels[idx]).float()\n        \n        return image, label\n    def __len__(self):\n        return len(self.df)\n        \n        ","9b3f13be":"dataset = RANZRDataset(train_dir, df)\nimg, label = dataset[0]\nplt.imshow(img)\nplt.show()\nprint(label)","6d4e930b":"def get_train_transform():\n    return A.Compose([\n        A.RandomResizedCrop(300, 300, p=1),\n        A.Flip(p=0.5),\n        A.RandomRotate90(),\n        A.OneOf([\n            A.OpticalDistortion(p=0.3),\n            A.GridDistortion(p=.1),\n            A.IAAPiecewiseAffine(p=0.3),\n        ], p=0.2),\n        A.OneOf([\n            A.CLAHE(clip_limit=2),\n            A.IAASharpen(),\n            A.IAAEmboss(),\n            A.RandomBrightnessContrast(),            \n        ], p=0.3),\n        A.HueSaturationValue(p=0.3),\n        #A.ShiftScaleRotate(shift_limit=0.0625, scale_limit=0.50, rotate_limit=45, p=.25),\n        #A.Normalize(mean = [0.485, 0.456, 0.406], std = [0.229, 0.224, 0.225]),\n        ToTensorV2(),\n\n    ])\n        \ndef get_valid_transform():\n    return A.Compose([\n        A.RandomResizedCrop(300, 300, p=1),\n        #A.Flip(0.5),\n        #A.Normalize(mean = [0.485, 0.456, 0.406], std = [0.229, 0.224, 0.225]),\n        ToTensorV2(),\n\n    ])","b5c79fca":"dataset = RANZRDataset(train_dir, df, get_train_transform())\n#img , label = dataset[0]\nprint(np.array(img).shape)\nfig, ax = plt.subplots(1, 4, figsize = (12, 10))\nfor i in range(0, 4):\n    img , label = dataset[i]\n    ax[i].imshow(img.permute(2,1,0))\n    ax[i].set_title(np.array(label))\nplt.show()\n","dc5d7b96":"train_dataset = RANZRDataset(train_dir, df, get_train_transform())\nvalid_dataset = RANZRDataset(train_dir, df, get_valid_transform())\n\n#indices = torch.randperm(len(train_dataset)).tolist()\n\n# train_dataset = torch.utils.data.Subset(train_dataset, indices=indices[:-100] )\n# valid_dataset = torch.utils.data.Subset(valid_dataset, indices=indices[-100:] )\ntrain_loader = DataLoader(train_dataset, \n                         batch_size = params[\"batch_size\"], \n                         num_workers = params[\"num_workers\"], \n                         pin_memory=True, \n                         shuffle = True)\nvalid_loader = DataLoader(valid_dataset, \n                         batch_size = params[\"batch_size\"], \n                         num_workers = params[\"num_workers\"],\n                         pin_memory= True, \n                         shuffle = False)","a076beed":"print(len(train_dataset), len(valid_dataset))","83b87f3c":"len(classes)","47afa41c":"import timm\n#EFFICIENTNET-B7\nclass RANZRModel(nn.Module):\n    def __init__(self, model_name=params[\"model\"], pretrained=False):\n        super().__init__()\n        self.model = timm.create_model(model_name, pretrained=pretrained)\n        n_features = self.model.classifier.in_features\n        self.model.classifier = nn.Linear(n_features, len(classes))\n\n    def forward(self, x):\n        x = self.model(x)\n        return x","664e950b":"def train_one_epoch(epoch, model, criterion, optimizer, scheduler):\n    since = time.time()\n\n    \n    data_cnt = 0\n    model.train()# Set model to training mode \n    print('Epoch {}\/{}'.format(epoch, params[\"num_epochs\"] - 1))\n    print('-' * 10)\n    running_loss = 0.0\n    for (inputs, labels) in train_loader:\n        \n        inputs = inputs.to(params[\"device\"]).float()\n        labels = labels.to(params[\"device\"]).float()\n        \n        \n        optimizer.zero_grad()\n        outputs = model(inputs)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        # statistics\n        running_loss += loss.item() \n        scheduler.step()\n        \n    print(\"Epoch {} - Training loss: {:.4f}\".format(epoch, running_loss\/len(train_loader)))\n        \n        \ndef valid_one_epoch(epoch, model, criterion, optimizer, scheduler):\n    since = time.time()\n\n\n    # Each epoch has a training and validation phase\n\n    preds =[]\n    model.eval()  \n    valid_loss = 0.0\n\n    # Iterate over data.\n    for inputs, labels in valid_loader:\n        inputs = inputs.to(params[\"device\"]).float()\n        labels = labels.to(params[\"device\"]).float()\n        \n        outputs = model(inputs)\n        loss = criterion(outputs, labels)\n        \n        preds.append(outputs.sigmoid().detach().cpu().numpy()) \n        #print(np.mean(preds))\n        valid_loss += loss.item() \n   \n    valid_loss = valid_loss\/len(valid_loader)\n    y_pred = np.concatenate(preds)\n    print(\"val_loss: {:0.4f} \".format(valid_loss))\n    return valid_loss, y_pred","7f882c96":"model = RANZRModel(model_name=params[\"model\"], pretrained=True)\nmodel.to(params[\"device\"])\ncriterion = nn.BCEWithLogitsLoss().to(params[\"device\"])\noptimizer = torch.optim.Adam(model.parameters(), lr=params[\"lr\"])\nscheduler = CosineAnnealingWarmRestarts(optimizer, T_0=params[\"T_0\"], T_mult=1, eta_min=params[\"min_lr\"], last_epoch=-1)\n","b9323708":"kf = GroupKFold(n_splits=3)\ngroups = df[\"PatientID\"].values\nX = df[\"StudyInstanceUID\"]\ny = df[classes]\nfold_var = 1\n#kf = kf.get_n_splits(X,y,groups)\nfor train_index, test_index in kf.split(X,y, groups):\n    #print(train_index, test_index)\n    train_dataset = RANZRDataset(train_dir, df.iloc[train_index], get_train_transform())\n    valid_dataset = RANZRDataset(train_dir, df.iloc[test_index], get_valid_transform())\n    \n    #print(len(train_dataset), len(valid_dataset))\n    train_loader = DataLoader(train_dataset, \n                         batch_size = params[\"batch_size\"], \n                         num_workers = params[\"num_workers\"], \n                         pin_memory=True, \n                         shuffle = True)\n    valid_loader = DataLoader(valid_dataset, \n                             batch_size = params[\"batch_size\"], \n                             num_workers = params[\"num_workers\"],\n                             pin_memory= True, \n                             shuffle = False)\n    \n    print(f\"{'-'*10} fold {fold_var} result {'-'*10}\")\n    best_loss = 1e10\n    for epochs in range (params[\"num_epochs\"]):\n        train_one_epoch(epochs,model, criterion, optimizer, scheduler)\n        with torch.no_grad():\n            val_loss , preds = valid_one_epoch(epochs,model, criterion, optimizer, scheduler)\n            scheduler.step()\n            if best_loss > val_loss:\n                best_loss = val_loss\n                torch.save(model.state_dict(), f'.\/fold_{fold_var}_{params[\"model\"]}_best.pth')\n    fold_var += 1","4ad47896":"Inference Notebook is here [kaggle kernels pull razatabish\/ranzr-clip-inference](http:\/\/)","75759ab1":"**Defining models**","b79a51ee":"**Plot some Data**","ba402a99":"**Defining Datasets and visualization**"}}