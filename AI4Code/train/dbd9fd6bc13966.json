{"cell_type":{"053c5bf0":"code","2dd1da34":"code","ffbff328":"code","b95f5753":"code","0ad6964b":"code","b9db9506":"code","839cecfd":"code","872fd597":"code","e92b4713":"code","8e57b6e3":"code","ef29916e":"code","8c050d20":"code","c4909146":"code","5eecb0d8":"code","97541c7b":"markdown","96990586":"markdown","b0541621":"markdown","bb44dd46":"markdown","9940ac65":"markdown","7e6b736a":"markdown","b7125281":"markdown","5de57bd0":"markdown","74d1a94b":"markdown","0c62124c":"markdown","71d85f8d":"markdown","a0abfa56":"markdown","70cf4258":"markdown","9b785696":"markdown","cc0eff52":"markdown","d12cbbc6":"markdown","9c753534":"markdown"},"source":{"053c5bf0":"import numpy as np\nimport pandas as pd\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","2dd1da34":"def preprocessor(package):\n    \"\"\"\n    This takes a input package and applies preprocessing steps like converting to lowercase,\n    strip the `\\n` and `space` from the ends.\n    \"\"\"\n    return package.lower().strip()","ffbff328":"# Open the file and read the list of packages\nwith open('\/kaggle\/input\/pip-requirement-files\/Python_ver36.txt', 'r') as f:\n    py36 = f.readlines()\n    \n# clean the data\npy36 = list(map(preprocessor, py36))\n\nprint(\"Number of packages for Python 3.6 are: \", len(py36))\nprint(f\"\\nFew of the records are:\\n{py36[:5]}\")","b95f5753":"with open('\/kaggle\/input\/pip-requirement-files\/Python_ver39.txt', 'r') as f:\n    py39 = f.readlines()\n    \n# clean the data\npy39 = list(map(preprocessor, py39))\n    \nprint(\"Number of packages for Python 3.9 are: \", len(py39))\nprint(f\"\\nFew of the records are:\\n{py39[:5]}\")","0ad6964b":"# define the costs\nins_cost = 1\ndel_cost = 1\nsub_cost = 2","b9db9506":"def edit_distance_recurse(seq1, seq2, operations=[]):\n    \"\"\"Returns the Edit Distance between the provided two sequences.\"\"\"\n    \n    if len(seq2) == 0:\n        operations = operations + ([f\"Delete `{seq1}` from sequence1.\"] if len(seq1) else [])\n        return len(seq1), operations\n    \n    if len(seq1) == 0:\n        operations = operations + ([f\"Insert `{seq2}` into sequence1.\"] if len(seq2) else [])\n        return len(seq2), operations\n    \n    if seq1[0] == seq2[0]:\n        operations = operations + [f\"Make no change for character `{seq1[0]}`.\"]\n        return edit_distance_recurse(seq1[1: ], seq2[1: ], operations)\n    \n    # calculate cost if insertion was made\n    ins_operations = operations + [f\"Insert `{seq2[0]}` in sequence1.\"]\n    insertion, ins_operations = edit_distance_recurse(seq1, seq2[1: ], ins_operations)\n    \n    # calculate cost if deletion was done\n    del_operations = operations + [f\"Delete `{seq1[0]}` from sequence1.\"]\n    deletion, del_operations = edit_distance_recurse(seq1[1: ], seq2, del_operations)\n    \n    # calculate cost if substitution was done\n    sub_operations = operations + [f\"Replace `{seq1[0]}` in sequence1 with `{seq2[0]}`.\"]\n    substitution, sub_operations = edit_distance_recurse(seq1[1: ], seq2[1: ], sub_operations)\n    \n    # calculate minimum cost\n    min_cost = min(insertion + ins_cost, deletion + del_cost, substitution + sub_cost)\n    \n    if min_cost == (substitution + sub_cost):\n        return min_cost, sub_operations\n    elif min_cost == deletion + del_cost:\n        return min_cost, del_operations\n    else:\n        return min_cost, ins_operations","839cecfd":"seq1 = \"numpy\"\nseq2 = \"numexpr\"\n\nscore, operations = edit_distance_recurse(seq1, seq2)\nprint(f\"Edit Distance between `{seq1}` & `{seq2}` is: {score}\")\nprint(\"\\nOperations performed are:\\n\")\nfor operation in operations:\n    print(operation)","872fd597":"def min_cost_path(cost, operations):\n    \n    # operation at the last cell\n    path = [operations[cost.shape[0]-1][cost.shape[1]-1]]\n    \n    # cost at the last cell\n    min_cost = cost[cost.shape[0]-1][cost.shape[1]-1]\n    \n    row = cost.shape[0]-1\n    col = cost.shape[1]-1\n    \n    while row >0 and col > 0:\n            \n        if cost[row-1][col-1] <= cost[row-1][col] and cost[row-1][col-1] <= cost[row][col-1]:\n            path.append(operations[row-1][col-1])\n            row -= 1\n            col -= 1\n\n        elif cost[row-1][col] <= cost[row-1][col-1] and cost[row-1][col] <= cost[row][col-1]:\n            path.append(operations[row-1][col])\n            row -= 1\n\n        else:\n            path.append(operations[row][col-1])\n            col -= 1\n        \n                    \n    return \"\".join(path[::-1][1:])","e92b4713":"def edit_distance_dp(seq1, seq2):\n    \n    # create an empty 2D matrix to store cost\n    cost = np.zeros((len(seq1)+1, len(seq2)+1))\n    \n    # fill the first row\n    cost[0] = [i for i in range(len(seq2)+1)]\n    \n    # fill the first column\n    cost[:, 0] = [i for i in range(len(seq1)+1)]\n    \n    # to store the operations made\n    operations = np.asarray([['-' for j in range(len(seq2)+1)] \\\n                                 for i in range(len(seq1)+1)])\n    \n    # fill the first row by insertion \n    operations[0] = ['I' for i in range(len(seq2)+1)]\n    \n    # fill the first column by insertion operation (D)\n    operations[:, 0] = ['D' for i in range(len(seq1)+1)]\n    \n    operations[0, 0] = '-'\n    \n    # now, iterate over earch row and column\n    for row in range(1, len(seq1)+1):\n        \n        for col in range(1, len(seq2)+1):\n            \n            # if both the characters are same then the cost will be same as \n            # the cost of the previous sub-sequence\n            if seq1[row-1] == seq2[col-1]:\n                cost[row][col] = cost[row-1][col-1]\n            else:\n                \n                insertion_cost = cost[row][col-1] + ins_cost\n                deletion_cost = cost[row-1][col] + del_cost\n                substitution_cost = cost[row-1][col-1] + sub_cost\n                \n                # calculate the minimum cost\n                cost[row][col] = min(insertion_cost, deletion_cost, substitution_cost)\n                \n                # get the operation\n                if cost[row][col] == substitution_cost:\n                    operations[row][col] = 'S'\n                    \n                elif cost[row][col] == ins_cost:\n                    operations[row][col] = 'I'\n                else:\n                    operations[row][col] = 'D'\n                \n    return cost[len(seq1), len(seq2)], min_cost_path(cost, operations)","8e57b6e3":"seq1 = \"numpy\"\nseq2 = \"numexpr\"\n\nscore, operations = edit_distance_dp(\"numpy\", \"numexpr\")\n\nprint(f\"Edit Distance between `{seq1}` & `{seq2}` is: {score}\")\nprint(\"\\nOperations performed are:\\n\")\nfor operation in operations:\n    if operation == '-':\n        print('No Change.')\n    elif operation == 'I':\n        print('Insertion')\n    elif operation == 'D':\n        print('Deletion')\n    else:\n        print('Substitution')","ef29916e":"# to store the best matching package for py36 found in py39\np36_best_match = {}\n\n# for each package in py36 get the score\nfor pack36 in py36:\n    \n    best_score = float('inf')\n    best_package = None\n    \n    # match with each package in py39\n    for pack39 in py39:\n        \n        # get the edit distance between pack36 and pack39\n        score, _ = edit_distance_dp(pack36, pack39)\n        \n        # if the score is less than best score so far\n        # store the new score and package name\n        if score < best_score:\n            best_score = score\n            best_package = pack39\n            \n    # append the details of best package found for pack36\n    p36_best_match[pack36] = (best_package, best_score)\n\n# print the results\nfor pack36, (pack39, score) in p36_best_match.items():\n    print(f\"Best matching package for `{pack36}` with distance of {score} is `{pack39}`\")","8c050d20":"# this function will trim the versions and return of they are same or not\ndef is_same(pack1, pack2):\n    return pack1.split('==')[0] == pack2.split('==')[0]\n\nprint(f\"Are packages `pandas` and `pandas==1.1.1` same? {is_same('pandas', 'pandas==1.1.1')}\")","c4909146":"# get total number of packages in py36\ntotal_packs_in_py36 = len(py36)\n\n# get the count of records where match was found\ntotal_matched_records = sum([is_same(pack36, pack39) for pack36, (pack39, _) in p36_best_match.items()])\n\n# get the accuracy\naccuracy = total_matched_records * 1.0 \/ total_packs_in_py36\n\nprint(f\"The total number of correct matches are: {total_matched_records} out of {total_packs_in_py36} and the accuracy is: {accuracy:.2f}\")","5eecb0d8":"# find the actual corresponding record of 'xlrd' in py39 list\nfor pack39 in py39:\n    if pack39.startswith('xlrd'):\n        print(pack39)\n        break","97541c7b":"**Let's now understand how to we break the problem in sub-problems, store the results and then solve overall problem.**\n\nIn the image below - across the rows we have `sequence1` which we want to convert into `sequence2` (which is across the columns) with minimum conversion cost.\n\nThe character `#` before the two sequence indicates the empty string or the begining of the string.\n\n![](https:\/\/i.ibb.co\/ZYkqLwX\/1PNG.png)\n\nNow, we will fill this Matrix with cost of different sub-sequence to get the overall solution. But, first let's look at the base cases:\n>\n>+ When `sequence1` is empty, then the cost to get `sequence2` is just the cost of adding the characters in the `sequence2`. The first row in the Maxtrix above >indicates that `sequence1` is empty.\n>    ![](https:\/\/i.ibb.co\/W5pb7Kq\/2.png)    \n>    \n>    If both the sequences are empty, then the cost is `0`.\n>![](https:\/\/i.ibb.co\/dm2y39t\/3.png)    \n>    \n>    If we add character `n` to the `sequence1` we get cost of `1`.\n>![](https:\/\/i.ibb.co\/6nQzdXr\/4.png)    \n>\n>    Same way we will fill our first row, where value in each column is `1 + previous column value`, i.e. cost of adding 1 more character is added.\n>![](https:\/\/i.ibb.co\/hWgHn5d\/5.png)    \n>    \n>    **Note:** the value 7 in the last column represents that if `sequence1` is empty then the cost of converting `sequence1` to `sequence2` is `7`. Also, the cost of converting an empty sequence to subsequence `'num'` is `3`.\n    \n    \n    \n>+ Opposite to this we have a case when `sequence2` is empty, but `sequence1` is not. Then the values across the rows represent the cost of deleting the characters to get an empty sequence.\n>![](https:\/\/i.ibb.co\/kyC1Dvv\/6.png)\n>\n>    **Note:** here the cost `5` represents the total cost to delete all the characters of `sequence1` to get empty `sequence2`.\n    \n\n**_Now the matrix with base cases' costs filled will be as follows:_**\n\n![](https:\/\/i.ibb.co\/fGsTyF8\/7.png)\n\n\n**Solving for Sub-problems and fill up the matrix.**\n\n>The value under ('n', 'n') is `0`, since these both characters are same and hence no cost for conversion.\n>![](https:\/\/i.ibb.co\/WB1kz2p\/8.png)\n\n>The below matrix show the cost to convert `#n` to `#nu` is `1`, since the cost of substrings `#n` & `#n` is `0`, we only add the cost of adding `u` to `sub-sequence1`.\n>![](https:\/\/i.ibb.co\/qgsYcdQ\/9.png)\n\n>Similar to above, the cost of converting `#nu` to `#n` is `1`, since the cost of substrings `#n` & `#n` is `0`, we only add the cost of deleting `u` from `sub-sequence1`.\n>![](https:\/\/i.ibb.co\/nDDqjPH\/10.png)\n\n>After few iterations the matrix will look as shown below. **Note:** the cost user sub-sequences `#num` & `#num` is `0`, since they are identical.\n>![](https:\/\/i.ibb.co\/YRGC8Sr\/11.png)\n\n>**So far we have only looked at insertion and deletion opetions, but now we will also, consider a substitution example. To solve for the subsequences `#nump` & `#nume` we will first calculate the cost of sub-sequences `#num` & `#num` (which is `0` as we noted above), hence the total cost is $0 + 2 = 2$ which is the cost of substituting `p` to `e`.**\n>![](https:\/\/i.ibb.co\/P1Z9vcs\/12.png)\n\n**The complete matrix is below and the total cost is mentioned in the last column of the last row - which is `4`.**\n![](https:\/\/i.ibb.co\/8PMDHFw\/13.png)\n\n**Also, by tracing the minimum cost from the last column of the last row to the first column of first row we can get the operations which were performed to reach this minimum cost.**\n![](https:\/\/i.ibb.co\/qRrtjhj\/14.png)","96990586":"### Hope the explainations were clear and you learnt from this notebook and let me know in the comments if you have any questions.","b0541621":"There is no matching record of 'xlrd' in py39 list that is it was never installed for Python 3.9 version.\n\nThe number of records in py36 is 276, while it is only 146 in py39, hence we can find the matching names only for 53% of the records of py36 (146\/276).","bb44dd46":"# Check the accuracy of the above solution\n\nTo do so, we will simply crop out the version part of the package names `==x.x.x` from both py36 and its best matching package from py39 and then check if they are the same or not.","9940ac65":"# What is Edit Distance and how to implement it?\n\nEdit Distance or Levenstein distance (the most common) is a metric to calculate the similarity between a pair of sequences. The distance between two sequences is measured as the number of edits (insertion, deletion, or substitution) are required to change one sequence to another.\n\nIn this section we will learn to implement the Edit Distance. ","7e6b736a":"**The reason for Edit distance to be `4` is:** characters `n,u,m` remain same (hence 0 cost), then `e & x` are inserted resulted in total cost of `2` so far.\nThen, no change was made for `p`, so no change in cost and finally, `y is replaced with r`, which resulted in additional cost of 2.\n\nHence, the total cost is `4`.","b7125281":"**Below function gets the operations performed to get the minimum cost.**","5de57bd0":"**Let's test this function for some examples**","74d1a94b":"**Below is the recursive function.** I will also, add some narration i.e. the function to print out the operation (insertion, deletion or substitution) it is performing.","0c62124c":"## Edit Distance using Dynamic Programming\n\nDynamic programming can be applied to the problems that have **_overlapping subproblems_**. Like in our case, where to get the Edit distance between `numpy` & `numexpr`, we first compute the same for sub-sequences `nump` & `nume`, then for `numpy` & `numex` and so on...\n\nOnce, we solve for a particular subproblem we store its result, which later on is used to solve overall problem. \n\n**_To know more about Dynamic Programming you can refer to my short tutorial - [Introduction to Dynamic Programming](https:\/\/www.hackerearth.com\/practice\/notes\/introduction-to-dynamic-programming\/)._**","71d85f8d":"# Implement Edit Distance from Sratch\n\nThe dataset we are going to use contains files containing the list of packages with their versions installed for two versions of Python language which are 3.6 and 3.9.\n\nThe records of Pandas package in the two files are:\n+ `pandas`\n+ `pandas==1.2.1`\n\nIn this excercise for each of the package mentioned in one file we will find the most suitable one from the second file. The sutability will be based on the Levenstein distance or the Edit distance metric.","a0abfa56":"**Below functions calculates Edit distance using Dynamic programming**","70cf4258":"# Get the pairwise distance between the requirement files\n\nNow, that we have built a function to calculate the edit distance between two sequences, we will use it to calculate the score between two packages from two different requirenment files.\n\nThen, for each of package mentioned in the requirement file of Python 3.6 version we will find the best matching package from the Python 3.9 version file.","9b785696":"## Edit distance using Recursion\n\nWe can directly convert the above formula into a Recursive function to calculate the Edit distance between two sequences, but the time complexity of such solution is $O(3^{(m+n)})$. \n\nSo, once we get clarity how does Edit distance work, we will write more optimised solution for it using Dynamic Programming having time complexity of $O(m*n)$.","cc0eff52":"**Let's look at below example to understand why we have such a low accuracy.**\n\n> Best matching package for `xlrd` with distance of 10.0 is `rsa==4.7`","d12cbbc6":"# Load the data\n\nWe will load the two files as the lists","9c753534":"## Distance metric\n\nThe Levenstein distance is calculated using the following:\n\n![Levenshtein Distance: image taken from wikipedia](https:\/\/wikimedia.org\/api\/rest_v1\/media\/math\/render\/svg\/10554aecc5e56da9be4657acd75b9a67b5e8b394)\n\nWhere tail means rest of the sequence except for the 1st character, in Python lingo it is `a[1:]`.\n\nThe explainations of the conditions are:\n+ If b is an empty sequence (`|b|=0`), then cost is the length of a (`|a|`).\n+ If a is an empty sequence (`|a|=0`), then cost is the length of b (`|b|`).\n+ If the 1st characters of a & b are same (`a[0] = b[0]`), then the cost is the cost of subsequence tail(a) (`a[1:]`) and tail(b) (`b[1:]`).\n+ Finally, the cost is the minimum of insertion, deletion, or substitution operation, which are as defined:\n    + `lev(tail(a), b)` indicates a character is deleted from a\n    + `lev(a, tail(b)` indicates a character is inserted to a\n    + `lev(tail(a), tail(b))` indicates substitution\n    \n**Note: here in the formula above, the cost of insertion, deletion or substitution has been kept same i.e. `1`. But, the cost of substitution is generally considered as `2`, which we will use in the implementation.**"}}