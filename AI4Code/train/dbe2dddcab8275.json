{"cell_type":{"8a18470f":"code","9ba2766f":"code","b0f4cd7d":"code","25d76d81":"code","fe17c155":"code","94ff9889":"code","43d46452":"code","33ab9304":"code","be8964c6":"code","898020d5":"markdown","e221a7ca":"markdown","9232f5b3":"markdown","a3faddbb":"markdown","d1b075ad":"markdown","8562bcdc":"markdown","113394cc":"markdown","16d69625":"markdown"},"source":{"8a18470f":"!pip install tensorflow-gpu==2.0.0-beta1\nimport numpy as np # linear algebra\nimport tensorflow as tf\nfrom sklearn.metrics import classification_report\nfrom tensorflow.python.framework.errors_impl import NotFoundError\nfrom tensorflow.python.keras import Input, Model\nfrom tensorflow.python.keras.engine import Layer\nfrom tensorflow.python.keras.layers import Concatenate, Dense, Reshape, LeakyReLU, \\\n    BatchNormalization, Flatten, Conv2D, Conv2DTranspose\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n# for dirname, _, filenames in os.walk('\/kaggle\/input'):\n#     for filename in filenames:\n#         print(os.path.join(dirname, filename))\n\ntf.__version__","9ba2766f":"class GatedNonlinearity(Layer):\n    def __init__(self, **kwargs):\n        super(GatedNonlinearity, self).__init__(**kwargs)\n\n    @tf.function\n    def call(self, inputs, **kwargs):\n        assert isinstance(inputs, list)\n        base, condition = inputs\n        a, b = base[:, :, :, ::2], base[:, :, :, 1::2]\n        c, d = condition[:, :, :, ::2], condition[:, :, :, 1::2]\n        a = a + c\n        b = b + d\n        result = tf.sigmoid(a) * tf.tanh(b)\n        return result\n\n\nclass Generator:\n    def __init__(self, num_classes, target_width, bn=False, noise_size=128, min_channels=64, max_channels=1024):\n        self.num_classes = num_classes\n        self.target_width = target_width\n        self.noise_size = noise_size\n        self.bn = bn\n        self.create_model(min_channels, max_channels)\n        self._model_path = '\/kaggle\/input\/gen_weights.h5'\n\n    def create_model(self, min_channels, max_channels):\n        gate = GatedNonlinearity()\n        _width = 4\n        _num_blocks = np.log2(self.target_width \/ _width).astype(np.uint8)\n        _num_channels = min(max_channels, min_channels * (2 ** _num_blocks))\n        _num_channels = max(min_channels, _num_channels)\n        noise = Input(shape=[self.noise_size], dtype=tf.float32)\n        label = Input(shape=[self.num_classes], dtype=tf.float32)\n        x = Concatenate()([noise, label])\n        output = Dense(_width * _width * _num_channels)(x)\n        output = Reshape(target_shape=(_width, _width, _num_channels))(output)\n\n        for i in range(1, _num_blocks + 1):\n            if self.bn:\n                output = BatchNormalization()(output)\n            condition = Dense(_width * _width * _num_channels, use_bias=False)(label)\n            condition = Reshape(target_shape=(_width, _width, _num_channels))(condition)\n            output = gate([output, condition])\n            _num_channels = min(max_channels, min_channels * (2 ** (_num_blocks - i)))\n            _num_channels = max(min_channels, _num_channels)\n            if i == _num_blocks:\n                _num_channels = 3\n            _width *= 2\n            output = Conv2DTranspose(_num_channels, kernel_size=5, strides=2, padding='same')(output)\n        gen_image = tf.tanh(output)\n        self.model = Model(inputs=[noise, label], outputs=[gen_image])\n    \n    def load(self):\n        try:\n            self.model.load_weights(self._model_path)\n        except (NotFoundError, OSError):\n            print(\"[ERROR] loading weights failed: {}\".format(self._model_path))\n            return False\n        return True","b0f4cd7d":"class Discriminator:\n    def __init__(self, num_classes, image_width, depth, leak=.2, bn_epsilon=0):\n        self.num_classes = num_classes\n        self.image_width = image_width\n        self.leak = leak\n        self.bn_epsilon = bn_epsilon\n        self.create_model(depth)\n        self._model_path = '\/kaggle\/input\/disc_weights.h5'\n    \n    def load(self):\n        try:\n            self.model.load_weights(self._model_path)\n        except (NotFoundError, OSError):\n            print(\"[ERROR] loading weights failed: {}\".format(self._model_path))\n            return False\n        return True\n\n    def create_model(self, depth):\n        def _conv(d):\n            return Conv2D(d, kernel_size=5, strides=2, padding='same')\n\n        _num_blocks = np.log2(self.image_width \/ 4).astype(np.uint8) - 1\n        image = Input(shape=(self.image_width, self.image_width, 3), dtype=tf.float32)\n        conv = _conv(depth)(image)\n        conv = LeakyReLU(alpha=self.leak)(conv)\n        for i in range(_num_blocks):\n            depth *= 2\n            conv = _conv(depth)(conv)\n            if self.bn_epsilon != 0:\n                conv = BatchNormalization(epsilon=self.bn_epsilon)(conv)\n            conv = LeakyReLU(alpha=self.leak)(conv)\n        features = Flatten()(conv)\n        logit = Dense(1, name='wasserstein_logit')(features)\n        label = Dense(self.num_classes, activation='softmax', name='label')(features)\n        self.model = Model(inputs=[image], outputs=[logit, label])","25d76d81":"from PIL import Image\nfrom tensorflow.python.keras.utils import to_categorical\n\nidx2label = {\n    0: 'abstract',\n    1: 'animal-painting',\n    2: 'cityscape',\n    3: 'figurative',\n    4: 'flower-painting',\n    5: 'genre-painting',\n    6: 'landscape',\n    7: 'marina',\n    8: 'mythological-painting',\n    9: 'nude-painting-nu',\n    10: 'portrait',\n    11: 'religious-painting',\n    12: 'still-life',\n    13: 'symbolic-painting'\n}\nlabel2idx = {val: key for key, val in idx2label.items()}\nnum_classes = len(idx2label.keys())\nnoise_size = 128\nimage_size = 128\n\ngen = Generator(num_classes, image_size, bn=False)\ndisc = Discriminator(num_classes, image_size, 64, bn_epsilon=0)\ngen.load()\ndisc.load()","fe17c155":"def display_image(*images, col=None, width=20):\n    from matplotlib import pyplot as plt\n    if col is None:\n        col = len(images)\n    row = np.math.ceil(len(images) \/ col)\n    plt.figure(figsize=(width, (width + 1) * row \/ col))\n    for i, image in enumerate(images):\n        plt.subplot(row, col, i + 1)\n        plt.axis('off')\n        plt.imshow(image, cmap='gray')\n    plt.subplots_adjust(wspace=0, hspace=0)\n    plt.show()","94ff9889":"def generate_labels(batch_size, num_classes, condition=None):\n    if condition is None:\n        labels = np.random.randint(num_classes, size=batch_size).astype(np.float32)\n    else:\n        labels = np.ones(shape=batch_size).astype(np.float32) * condition\n    return to_categorical(labels, num_classes=num_classes)\n\n\ndef denorm_image(x):\n    return np.clip((x + 1) * 127.5, 0, 255).astype('uint8')\n\n\ndef generate_images(num_samples, genre=None):\n    if genre:\n        genre_idx = label2idx[genre]\n    else:\n        genre_idx = None\n    noise = tf.random.normal(shape=[num_samples, noise_size])\n    labels = generate_labels(num_samples, num_classes, condition=genre_idx)\n    images = gen.model.predict([noise, labels])\n    return images","43d46452":"def create_montage(images, cols, width=1000):\n    _width = int(width \/ cols)\n    rows = np.math.ceil(len(images) \/ cols)\n    height = np.ceil(_width * rows).astype('int')\n    canvas = Image.new('RGB', (width, height), color=(255, 255, 255))\n    for row in range(rows):\n        for col in range(cols):\n            arr = images[row * cols + col]\n            x0, y0 = col * _width, row * _width\n            x1, y1 = x0 + _width, y0 + _width\n            image = Image.fromarray(arr)\n            resized = image.resize((_width, _width))\n            canvas.paste(resized, box=(x0, y0, x1, y1))\n    return canvas","33ab9304":"images = denorm_image(generate_images(24))\nmontage = create_montage(images, cols=6, width=750)\ndisplay_image(np.array(montage), width=12)","be8964c6":"sample_genre = 'cityscape'\nimages = denorm_image(generate_images(24, sample_genre))\nmontage = create_montage(images, cols=6, width=750)\ndisplay_image(np.array(montage), width=12)","898020d5":"## Let's try generating some arts of a given genre!","e221a7ca":"# Declare Generator","9232f5b3":"## Let's try generating some random arts!","a3faddbb":"a function to randomly generate one-hot vectors used as classification labels\n\nand a function to normalize image pixel values to [0 - 255]\n\na function to randomly generate a given number of artworks","d1b075ad":"# Prepare a few helper functions\n\na function for displaying arbitrary number of images on the screen","8562bcdc":"# Create the generator & discriminator and load trained weights","113394cc":"# Declare Discriminator","16d69625":"a function to paste pictures together to make a montage image"}}