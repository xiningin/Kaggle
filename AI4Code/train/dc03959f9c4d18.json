{"cell_type":{"7c2f6af4":"code","69485866":"code","adf836fe":"code","f3ae7f68":"code","85436b8e":"code","ab5b6b53":"code","a5ad9301":"code","0fb313e8":"code","f4757ca2":"code","aa566ddf":"code","d34bca2c":"code","e583b0c6":"code","a89fb0d1":"code","5dba53a2":"code","858c4e1e":"code","71389e1c":"code","2911f2a0":"code","d1387409":"code","25815011":"markdown","9b269778":"markdown","8656ce1b":"markdown","d667c604":"markdown","ea2f4efd":"markdown","a0c3c682":"markdown","67d40fe6":"markdown","5bbb9958":"markdown","ff282817":"markdown","7fb3b720":"markdown","aa9d261c":"markdown"},"source":{"7c2f6af4":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","69485866":"import seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline","adf836fe":"train = pd.read_csv('\/kaggle\/input\/titanic\/train.csv')\ntest = pd.read_csv('\/kaggle\/input\/titanic\/test.csv')","f3ae7f68":"train.info()","85436b8e":"train.dropna(inplace=True)\ntest.dropna(inplace=True)","ab5b6b53":"from sklearn.preprocessing import LabelEncoder\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report, confusion_matrix, accuracy_score","a5ad9301":"train['Age_Range'] = pd.cut(train['Age'], bins=4)\nsns.countplot(train['Age_Range'])","0fb313e8":"test['Age_Range'] = pd.cut(test['Age'], bins=4)\nsns.countplot(test['Age_Range'])","f4757ca2":"cutted = pd.cut(pd.concat([train['Age'], test['Age']]), 4, retbins=True)\nintervals = cutted[1]","aa566ddf":"sns.countplot(pd.cut(train['Age'], intervals))","d34bca2c":"sns.countplot(pd.cut(test['Age'], intervals))","e583b0c6":"cutted = pd.cut(pd.concat([train['Age'], test['Age']]), 4, retbins=True)\nintervals = cutted[1]\ntrain['Age_Range'] = pd.cut(train['Age'], intervals)\ntest['Age_Range'] = pd.cut(test['Age'], intervals)\nage_encoder = LabelEncoder().fit(pd.concat([train['Age_Range'], test['Age_Range']]))\ntrain['Age_Range'] = age_encoder.transform(train['Age_Range'])\ntest['Age_Range'] = age_encoder.transform(test['Age_Range'])","a89fb0d1":"sns.countplot(train['Age_Range'])","5dba53a2":"sns.countplot(test['Age_Range'])","858c4e1e":"class CutEncoder():\n    \"\"\"Encode numeric values with equal interval cut value between 0 and n_classes-1.\"\"\"\n    def __init__(self):\n        self.intervals = None\n    def fit(self, x, bins):\n        self.x = x\n        self.bins = bins\n        cutted = pd.cut(self.x, self.bins, retbins=True)\n        self.intervals = cutted[1]\n    def transform(self, y):\n        return pd.cut(y, self.intervals, labels=list(range(len(self.intervals)-1)))\n        ","71389e1c":"cut_encoder = CutEncoder()\ncut_encoder.fit(pd.concat([train['Age'], test['Age']]), 4)\ntrain['Age_Range'] = cut_encoder.transform(train['Age'])\ntest['Age_Range'] = cut_encoder.transform(test['Age'])","2911f2a0":"sns.countplot(train['Age_Range'])","d1387409":"sns.countplot(test['Age_Range'])","25815011":"now let us add new Age_range column.","9b269778":"we got the same result with easier and less code\n```\ncut_encoder = CutEncoder()\ncut_encoder.fit(pd.concat([train['Age_Range'], test['Age_Range']]), 4)\ntrain['Age_Range'] = c.transform(train['Age'])\ntest['Age_Range'] = c.transform(test['Age'])\n```\n\ninstead of \n\n```\ncutted = pd.cut(pd.concat([train['Age'], test['Age']]), 4, retbins=True)\nintervals = cutted[1]\ntrain['Age_Range'] = pd.cut(train['Age'], intervals)\ntest['Age_Range'] = pd.cut(test['Age'], intervals)\nage_encoder = LabelEncoder().fit(pd.concat([train['Age_Range'], test['Age_Range']]))\ntrain['Age_Range'] = age_encoder.transform(train['Age_Range'])\ntest['Age_Range'] = age_encoder.transform(test['Age_Range'])\n```\n","8656ce1b":"Ayoub Abuzer","d667c604":"we can see that the bins are the same for both data sets. now we need to add new column with the the data and encode labels.","ea2f4efd":"In this notebook i will share with you a solution for an encoding problem.\n\nlet us asume that we have some numeric feature in two data sets - train and test, if we want to make some feature engineering adding a column with $n$ cuts of the values, using the popular $pandas.cut(x, n)$ function for each one of the data sets will oftenly give us different cuts for each one of the data sets, which will badly influce machine learning models and other encoders, let us see an example of the famous titanic data.\n","a0c3c682":"we can notice immediatly that the bins is totaly different, so this will be bad choice for us, because this will lie for the model and also we can not encode that unseen values, and if execute that code \n```\nage_encoder = LabelEncoder().fit(train['Age'])\ntrain['Age'] = age_encoder.transform(train['Age'])\ntest['Age'] = age_encoder.transform(test['Age'])\n```\n\nwe will get this error :\n\n```\ny contains previously unseen labels: Interval(19.128, 38.085, closed='right')\n```","67d40fe6":"Good Luck","5bbb9958":"# CutEncoder","ff282817":"Imagine that we have the so called **```CutEncoder```**, which will cut the data into equal bins and encode it.","7fb3b720":"for simplicity i will drop null values","aa9d261c":"we could fix the problem by getting bins intervals for the combined data, and perform a cut again with the defined intervals for both the data sets."}}