{"cell_type":{"01d8c2a6":"code","6c27e65d":"code","8062f234":"code","60cff6ee":"code","94767c9e":"code","1b1b50a0":"code","a500d243":"code","b2748cf7":"code","dfd69cc2":"code","26b11356":"code","0a32f977":"code","5f27eb24":"markdown","3f2924fd":"markdown","4077bb5c":"markdown","44bfb0c4":"markdown","80af9fb7":"markdown","59e943e9":"markdown","496ef694":"markdown","effdafaa":"markdown","0f8fa4a9":"markdown","022a576e":"markdown","7eff1a61":"markdown","071d91b2":"markdown","7ea05f11":"markdown","88f9b46e":"markdown","f8a84592":"markdown","4484deeb":"markdown"},"source":{"01d8c2a6":"try:\n  # %tensorflow_version only exists in Colab.\n  %tensorflow_version 2.x\nexcept Exception:\n    pass\n  \nimport tensorflow as tf\nimport tensorflow_datasets as tfds\n\nimport numpy as np\nimport matplotlib.pyplot as plt","6c27e65d":"def map_image(image, label):\n    '''Normalizes the image. Returns image as input and label.'''\n    image = tf.cast(image, dtype=tf.float32)\n    image = image \/ 255.0\n    return image, image","8062f234":"BATCH_SIZE = 128\nSHUFFLE_BUFFER_SIZE = 1024\n\ntrain_dataset = tfds.load('fashion_mnist', as_supervised=True, split=\"train\")\ntrain_dataset = train_dataset.map(map_image)\ntrain_dataset = train_dataset.shuffle(SHUFFLE_BUFFER_SIZE).batch(BATCH_SIZE).repeat()\n\ntest_dataset = tfds.load('fashion_mnist', as_supervised=True, split=\"test\")\ntest_dataset = test_dataset.map(map_image)\ntest_dataset = test_dataset.batch(BATCH_SIZE).repeat()","60cff6ee":"def encoder(inputs):\n    '''Defines the encoder with two Conv2D and max pooling layers.'''\n    conv_1 = tf.keras.layers.Conv2D(filters=64, kernel_size=(3,3), activation='relu', padding='same')(inputs)\n    max_pool_1 = tf.keras.layers.MaxPooling2D(pool_size=(2,2))(conv_1)\n\n    conv_2 = tf.keras.layers.Conv2D(filters=128, kernel_size=(3,3), activation='relu', padding='same')(max_pool_1)\n    max_pool_2 = tf.keras.layers.MaxPooling2D(pool_size=(2,2))(conv_2)\n\n    return max_pool_2","94767c9e":"def bottle_neck(inputs):\n    '''Defines the bottleneck.'''\n    bottle_neck = tf.keras.layers.Conv2D(filters=256, kernel_size=(3,3), activation='relu', padding='same')(inputs)\n    encoder_visualization = tf.keras.layers.Conv2D(filters=1, kernel_size=(3,3), activation='sigmoid', padding='same')(bottle_neck)\n\n    return bottle_neck, encoder_visualization","1b1b50a0":"def decoder(inputs):\n    '''Defines the decoder path to upsample back to the original image size.'''\n    conv_1 = tf.keras.layers.Conv2D(filters=128, kernel_size=(3,3), activation='relu', padding='same')(inputs)\n    up_sample_1 = tf.keras.layers.UpSampling2D(size=(2,2))(conv_1)\n \n    conv_2 = tf.keras.layers.Conv2D(filters=64, kernel_size=(3,3), activation='relu', padding='same')(up_sample_1)\n    up_sample_2 = tf.keras.layers.UpSampling2D(size=(2,2))(conv_2)\n\n    conv_3 = tf.keras.layers.Conv2D(filters=1, kernel_size=(3,3), activation='sigmoid', padding='same')(up_sample_2)\n\n    return conv_3","a500d243":"def convolutional_auto_encoder():\n    '''Builds the entire autoencoder model.'''\n    inputs = tf.keras.layers.Input(shape=(28, 28, 1,))\n    encoder_output = encoder(inputs)\n    bottleneck_output, encoder_visualization = bottle_neck(encoder_output)\n    decoder_output = decoder(bottleneck_output)\n  \n    model = tf.keras.Model(inputs =inputs, outputs=decoder_output)\n    encoder_model = tf.keras.Model(inputs=inputs, outputs=encoder_visualization)\n    return model, encoder_model\n","b2748cf7":"convolutional_model, convolutional_encoder_model = convolutional_auto_encoder()\nconvolutional_model.summary()","dfd69cc2":"train_steps = 60000 \/\/ BATCH_SIZE\nvalid_steps = 60000 \/\/ BATCH_SIZE\n\nconvolutional_model.compile(optimizer=tf.keras.optimizers.Adam(), loss='binary_crossentropy')\nconv_model_history = convolutional_model.fit(train_dataset, steps_per_epoch=train_steps, validation_data=test_dataset, validation_steps=valid_steps, epochs=40)","26b11356":"def display_one_row(disp_images, offset, shape=(28, 28)):\n    '''Display sample outputs in one row.'''\n    for idx, test_image in enumerate(disp_images):\n        plt.subplot(3, 10, offset + idx + 1)\n        plt.xticks([])\n        plt.yticks([])\n        test_image = np.reshape(test_image, shape)\n        plt.imshow(test_image, cmap='gray')\n\n\ndef display_results(disp_input_images, disp_encoded, disp_predicted, enc_shape=(8,4)):\n    '''Displays the input, encoded, and decoded output values.'''\n    plt.figure(figsize=(15, 5))\n    display_one_row(disp_input_images, 0, shape=(28,28,))\n    display_one_row(disp_encoded, 10, shape=enc_shape)\n    display_one_row(disp_predicted, 20, shape=(28,28,))","0a32f977":"# take 1 batch of the dataset\ntest_dataset = test_dataset.take(1)\n\n# take the input images and put them in a list\noutput_samples = []\nfor input_image, image in tfds.as_numpy(test_dataset):\n      output_samples = input_image\n\n# pick 10 indices\nidxs = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# prepare test samples as a batch of 10 images\nconv_output_samples = np.array(output_samples[idxs])\nconv_output_samples = np.reshape(conv_output_samples, (10, 28, 28, 1))\n\n# get the encoder ouput\nencoded = convolutional_encoder_model.predict(conv_output_samples)\n\n# get a prediction for some values in the dataset\npredicted = convolutional_model.predict(conv_output_samples)\n\n# display the samples, encodings and decoded values!\ndisplay_results(conv_output_samples, encoded, predicted, enc_shape=(7,7))","5f27eb24":"![Autoencoders4.png](attachment:61e76f51-0024-4132-998f-1b8eb80b3377.png)","3f2924fd":"As mentioned, you will use convolutional layers to build the model. This is composed of three main parts: encoder, bottleneck, and decoder. You will follow the configuration shown in the image below.","4077bb5c":"You can now build the full autoencoder using the functions above.","44bfb0c4":"## Prepare the Dataset","80af9fb7":"## Imports","59e943e9":"## Display sample results","496ef694":"The encoder, just like in previous labs, will contract with each additional layer. The features are generated with the Conv2D layers while the max pooling layers reduce the dimensionality.","effdafaa":"## Convolutional Autoencoders\n\nIn this lab, you will use convolution layers to build your autoencoder. This usually leads to better results than dense networks and you will see it in action with the [Fashion MNIST dataset](https:\/\/www.tensorflow.org\/datasets\/catalog\/fashion_mnist).","0f8fa4a9":"<img src=\"https:\/\/drive.google.com\/uc?export=view&id=15zh7bst9KKvciRdCvMAH7kXt3nNkABzO\" width=\"75%\" height=\"75%\"\/>","022a576e":"The decoder will upsample the bottleneck output back to the original image size.","7eff1a61":"![Autoencoders2.png](attachment:4f42ac34-4029-4c5f-8d44-12bb6938a476.png)","071d91b2":"As usual, let's see some sample results from the trained model.","7ea05f11":"As before, you will load the train and test sets from TFDS. Notice that we don't flatten the image this time. That's because we will be using convolutional layers later that can deal with 2D images.","88f9b46e":"A bottleneck layer is used to get more features but without further reducing the dimension afterwards. Another layer is inserted here for visualizing the encoder output.","f8a84592":"## Define the Model","4484deeb":"## Compile and Train the model"}}