{"cell_type":{"fb464017":"code","2e0b9d3c":"code","fdc2638a":"code","0b722a06":"code","69dfa26c":"code","5f81bd34":"code","56f36a3f":"code","f51b87f8":"code","8bb88d81":"code","63f71aa8":"code","ef04ab8b":"code","7cc35c0d":"code","ab009244":"code","32dae1ca":"code","0aaa6191":"code","0c74dd7b":"code","32b90f46":"code","fd6172c4":"code","a352944f":"markdown","d1cc4a69":"markdown","3c05325f":"markdown","ead9ddc7":"markdown","ff6f477d":"markdown","f2d00683":"markdown","908377dc":"markdown","9936fd4c":"markdown","ae18f61a":"markdown","c77235fb":"markdown","fa0eeb7a":"markdown","e6223625":"markdown","53ae5dff":"markdown"},"source":{"fb464017":"import numpy as np\nimport pandas as pd \nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom statsmodels.tsa.ar_model import AR\nfrom statsmodels.tsa.arima_model import ARIMA\npd.options.mode.chained_assignment = None","2e0b9d3c":"class crypto:\n    def __init__(self, df, currency = 'XLM'):\n        self.currency = currency\n        df = df.rename(columns={'Unnamed: 0': 'Day'})\n        self.df = df[(df['Symbol']==self.currency)]\n        \n        del df\n    \n    def fit(self, target='High', type_='AR', ARIMA_order=(1,1,1)):\n        \"\"\"\n        Fit the model on the train set\n        There is a choice between AR and ARIMA models.\n        The ARIMA_order parameter is only used in the latter case.\n        \"\"\"\n       # self.df['%s_shift' % (target)] = self.df[target].shift()\n        #self.df.dropna(inplace=True)\n        divide=len(self.df)-200\n        self.train = self.df[:divide]\n        self.test = self.df[divide:]\n        self.target = target\n        \n        if type_=='AR':\n            model = AR(self.train[target])\n            \n        elif type_=='ARIMA':\n            model = ARIMA(self.train[target], order=ARIMA_order)\n        self.model_fit = model.fit()\n        print('Lag: %s' % self.model_fit.k_ar)\n        print('Coefficients: %s' % self.model_fit.params)\n        self.window = self.model_fit.k_ar\n        self.coef = self.model_fit.params\n        sns.lineplot(x = 'Day', y = 'High', data=self.train, label = 'train', color='b')\n        sns.lineplot(self.train['Day'], y=self.model_fit.fittedvalues,  label = 'Fitted Values', color='r')\n        plt.title('Fitted Model')\n        plt.show()\n        \n    def fit_analysis(self):\n        self.train['%s_predicted' % (self.target)] = self.model_fit.fittedvalues\n        return self.train\n    \n    def plot_rolling_mean(self, window=7):\n        sns.set(rc={'figure.figsize':(20,20)})\n        sns.set(style=\"whitegrid\", font_scale=1.5)\n        sns.set_palette(\"Paired\")\n        sns.lineplot(x = self.train['Day'], y = self.train[self.target].rolling(window).mean(), data=self.train, label = 'Train rolling mean', color='b')\n        sns.lineplot(x=self.train['Day'], y=self.model_fit.fittedvalues.rolling(window).mean(),  label = 'Fitted Values rolling mean', color='r')\n        plt.title('Rolling Mean Window = %s' % (window))\n        plt.show()\n        \n    def ups_and_downs(self, day_shift=1, type_='train'):\n        \"\"\"\n        Shift the target by 1 day, and calculate the difference between today and yesterday.\n        Drop NaNs and assign 0 to a down-shift and 1 to an up-shift in the training set.\n        Repeat this process for the predicted values.\n        \"\"\"\n        if type_=='train':\n            train = self.train.copy()\n            train.dropna(inplace=True)\n            train['%s_shift' % (self.target)] = train[self.target].shift(day_shift)\n            train.dropna(inplace=True)\n            train['%s_shift_predicted' % (self.target)] = train['%s_predicted' % (self.target)].shift(day_shift)\n            train.dropna(inplace=True)\n            train['Diff_%s' % (self.target)] = train['%s_shift' % (self.target)] - train[self.target]\n            train['Diff_%s_predicted' % (self.target)] = train['%s_shift_predicted' % (self.target)] - train['%s_predicted' % (self.target)]\n            train['Ups_Downs_Real'] = np.where(train['Diff_%s' % (self.target)]<=0, 0, 1)\n            train['Ups_Downs_Predicted'] = np.where(train['Diff_%s_predicted' % (self.target)]<=0, 0, 1)\n            return train\n        elif type_=='test':\n            test = self.test.copy()\n            test.dropna(inplace=True)\n            test['%s_shift' % (self.target)] = test[self.target].shift(day_shift)\n            test.dropna(inplace=True)\n            test['%s_shift_predicted' % (self.target)] = test['pred'].shift(day_shift)\n            test.dropna(inplace=True)\n            test['Diff_%s' % (self.target)] = test['%s_shift' % (self.target)] - test[self.target]\n            test['Diff_%s_predicted' % (self.target)] = test['%s_shift_predicted' % (self.target)] - test['pred']\n            test['Ups_Downs_Real'] = np.where(test['Diff_%s' % (self.target)]<=0, 0, 1)\n            test['Ups_Downs_Predicted'] = np.where(test['Diff_%s_predicted' % (self.target)]<=0, 0, 1)\n            return test\n        \n    def predict(self, target='High'):\n        \"\"\"\n        Predict the future!\n        \"\"\"\n        history = self.train[target].iloc[len(self.train)-self.window:]\n        history = [history.iloc[i] for i in range(len(history))]\n        predictions = list()\n        for t in range(len(self.test)):\n            length = len(history)\n            lag = [history[i] for i in range(length-self.window,length)]\n            yhat = self.coef[0]\n            for d in range(self.window):\n                yhat += self.coef[d+1] * lag[self.window-d-1]\n            obs = self.test[target].iloc[t]\n            predictions.append(yhat)\n            history.append(obs)\n        self.predictions = predictions\n        self.test['pred'] = self.predictions\n        sns.set(rc={'figure.figsize':(10,10)})\n        sns.set(style=\"whitegrid\", font_scale=1.5)\n        sns.set_palette(\"Paired\")\n        sns.lineplot(x = 'Day', y = 'High', data=self.test, label = 'test', color='b')\n        sns.lineplot(self.test['Day'], y=self.predictions,  label = 'predictions', color='r')\n        plt.title('%s' % (self.currency))\n        plt.show()\n        ","fdc2638a":"df = pd.read_csv(\"..\/input\/all_currencies.csv\")\n","0b722a06":"xlm = crypto(df=df, currency='XLM')\nxlm.fit(target='High')","69dfa26c":"tmp = xlm.fit_analysis()\ntmp.head(25)","5f81bd34":"from sklearn.metrics import mean_absolute_error\nfrom sklearn.metrics import mean_squared_error\ntmp.dropna(inplace=True)\nprint('Mean Absolute Error: ', mean_absolute_error(tmp['High'], tmp['High_predicted']),'\\n',\n      'Mean Squared Error: ', mean_squared_error(tmp['High'], tmp['High_predicted']))\nprint('Mean Value of XLM: ', np.mean(tmp['High']))","56f36a3f":"xlm.plot_rolling_mean(window=7)","f51b87f8":"ups_downs = xlm.ups_and_downs(day_shift=1)[['Ups_Downs_Real', 'Ups_Downs_Predicted']]\nups_downs.head(15)","8bb88d81":"from sklearn.metrics import roc_auc_score\nroc_auc_score(ups_downs[['Ups_Downs_Real']], ups_downs[['Ups_Downs_Predicted']])","63f71aa8":"ups_downs = xlm.ups_and_downs(day_shift=7)[['Ups_Downs_Real', 'Ups_Downs_Predicted']]\nprint('7 days: ', roc_auc_score(ups_downs[['Ups_Downs_Real']], ups_downs[['Ups_Downs_Predicted']]))\n\nups_downs = xlm.ups_and_downs(day_shift=14)[['Ups_Downs_Real', 'Ups_Downs_Predicted']]\nprint('14 days: ',roc_auc_score(ups_downs[['Ups_Downs_Real']], ups_downs[['Ups_Downs_Predicted']]))","ef04ab8b":"xlm.predict()","7cc35c0d":"print('Mean Absolute Error: ', mean_absolute_error(xlm.test['High'], xlm.predictions),'\\n',\n      'Mean Squared Error: ', mean_squared_error(xlm.test['High'], xlm.predictions))\nprint('Mean Value of XLM: ', np.mean(xlm.test['High']))","ab009244":"ups_downs = xlm.ups_and_downs(day_shift=1, type_='test')[['Ups_Downs_Real', 'Ups_Downs_Predicted']]\nups_downs.head(15)","32dae1ca":"roc_auc_score(ups_downs[['Ups_Downs_Real']], ups_downs[['Ups_Downs_Predicted']])","0aaa6191":"ups_downs = xlm.ups_and_downs(day_shift=7, type_='test')[['Ups_Downs_Real', 'Ups_Downs_Predicted']]\nprint('7 days: ', roc_auc_score(ups_downs[['Ups_Downs_Real']], ups_downs[['Ups_Downs_Predicted']]))\n\nups_downs = xlm.ups_and_downs(day_shift=14, type_='test')[['Ups_Downs_Real', 'Ups_Downs_Predicted']]\nprint('14 days: ',roc_auc_score(ups_downs[['Ups_Downs_Real']], ups_downs[['Ups_Downs_Predicted']]))","0c74dd7b":"xlm.fit(target='High', type_='ARIMA', ARIMA_order=(23,0,0))","32b90f46":"xlm.fit(target='High', type_='ARIMA', ARIMA_order=(23,0,1))","fd6172c4":"xlm.fit_analysis()\nups_downs = xlm.ups_and_downs(day_shift=7)[['Ups_Downs_Real', 'Ups_Downs_Predicted']]\nroc_auc_score(ups_downs[['Ups_Downs_Real']], ups_downs[['Ups_Downs_Predicted']])","a352944f":"The average error compared to the average price seems to be rather low, meaning that we should be able to see quite a nice rolling mean","d1cc4a69":"## Ups-and-Downs\n\nA rolling mean works well, but what about predicting the individual ups-and-downs?\n\nWe will drop the NaN rows and analyse how well our model can predict the ups-and-downs of the XLM behaviour.\n\nLet's first look at the shift per day","3c05325f":"## ARIMA\n\nLet's go ahead and fit a more complex model - the [ARIMA model.](http:\/\/www.statsmodels.org\/devel\/generated\/statsmodels.tsa.arima_model.ARIMA.html)\nThere is an extra parameter that must be fed into this model - ARIMA_order=(p,d,q)\n\nIf we set d = q = 0 and p=23, we should retrieve the AR model that we had above.\nLet's check this\n\n**Note: This fitting can be quite slow compared to a standard AR model**","ead9ddc7":"## Auto Regressive Model\nLet's try and predict the future of crypto! We're going to fit an Auto Regressive (AR) model on the XLM ([Stellar Lumens](https:\/\/www.coingecko.com\/en\/coins\/stellar)) currency. Further information on these models [can be found here.](https:\/\/www.quantstart.com\/articles\/Autoregressive-Moving-Average-ARMA-p-q-Models-for-Time-Series-Analysis-Part-1)\n\nThe code here is adapted from [this excellent resource.](https:\/\/machinelearningmastery.com\/autoregression-models-time-series-forecasting-python\/)\n\nAs we will see, the AR model finds that a 23-day lag best explains the behaviour of this particular cryptocoin .","ff6f477d":"Again we see that the rolling mean will be an accurate value, and we should expect an accurate MAE \/ MSE. The up-and-down prediction we expect to be a little more spurious","f2d00683":"The first 23 days are predicted as NaN. This is, of course, what we expect: the AR model has deemed the most accurate model to consist of a 23-day window. How accurate is our model at predicting the daily High value of XLM?","908377dc":"Quite a few of these values are clearly wrong. Let's quantify this.","9936fd4c":"It's difficult to gauge how well the model is fitting. It *looks* to be accurate, but of course we need to perform some analysis on this. Let us now call the *fit_analysis()* function:","ae18f61a":"The following class will be used to generate all the subsequent code.","c77235fb":"Let us fit the model on the target 'High'","fa0eeb7a":"The predictive power of our model over longer time periods is much stronger - not a surprise given:\n1.  The noticeable trend of our fitted model to have an acceptable rolling mean\n2. The volatility of cryptocurrency markets\n\n**However** it's very important to remember that so far we are looking at the fitted model, and **not** the test set. \n\nIs the test score comparable to the train score?","e6223625":"The model is not overfitting, as we see approximately the same metric scores on train and test. The one-day shift prediction is slightly better, but still not very accurate","53ae5dff":"Not a good value at all! We are basically flipping a coin to decide whether the value of Stellar Lumens will increase or decrease. \n\nWhat about predicting the ups-and-downs over a long time frame, e.g. a week?"}}