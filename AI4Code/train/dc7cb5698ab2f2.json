{"cell_type":{"bd43d88b":"code","beff5dbc":"code","cef6b352":"code","6c3500a1":"code","9b86f936":"code","f58717db":"code","5a36aabd":"code","c4b911c3":"code","77066fe2":"code","9fce36f6":"code","1a83673c":"code","d3ef152d":"code","f6155cc5":"code","1452cddb":"code","40b741e1":"code","86f1bf61":"code","c5491995":"code","372c05a6":"code","4c373e43":"code","3ac73f45":"code","9dc94f76":"code","1ff6ab28":"code","70506225":"code","fb701c07":"code","bea9b1ec":"code","d96a56ee":"markdown","69b77203":"markdown","54ffb2b4":"markdown","eefba023":"markdown","f8c62a37":"markdown","c825bee2":"markdown","cca614ec":"markdown","309fd070":"markdown","463431f3":"markdown","659cd298":"markdown","30c1d315":"markdown"},"source":{"bd43d88b":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\n\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nPATH = '..\/input\/catalanmushrooms'\ntrain = pd.read_csv(PATH+'\/train.csv')\ntest = pd.read_csv(PATH+'\/test.csv', index_col=\"Id\")","beff5dbc":"train.drop_duplicates(inplace=True)\nX = train.drop(columns=['poisonous', 'Id'])\nX = X[test.columns]\ny = train['poisonous']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, train_size=.85, random_state=8)","cef6b352":"X.columns","6c3500a1":"from sklearn.preprocessing import OneHotEncoder","9b86f936":"enc = OneHotEncoder(handle_unknown='ignore', sparse=False)\nX_train_enc = enc.fit_transform(X_train)\nX_test_enc = enc.transform(X_test)","f58717db":"from sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.linear_model import LogisticRegression","5a36aabd":"enc_pipeline = Pipeline(steps=[\n    ('one-hot_enc', OneHotEncoder(handle_unknown='ignore', sparse=False))\n])\ntransformer = ColumnTransformer(transformers=[\n    ('transform', enc_pipeline, X_train.columns)  \n])\nlr_pipeline = Pipeline(steps=[\n    ('processor', transformer),\n    ('model', LogisticRegression(solver='lbfgs', max_iter=400))\n])\n\n_ = lr_pipeline.fit(X_train, y_train)","c4b911c3":"predictions_lr = lr_pipeline.predict(X_test)","77066fe2":"from sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import ConfusionMatrixDisplay\nfrom sklearn.metrics import roc_auc_score, roc_curve, auc, RocCurveDisplay","9fce36f6":"cm = confusion_matrix(y_test, predictions_lr)\n\ncm_display = ConfusionMatrixDisplay(cm).plot()\n\nfpr_lr, tpr_lr, thresholds = roc_curve(y_test, predictions_lr)\nroc_display = RocCurveDisplay(fpr=fpr_lr, tpr=tpr_lr).plot()","1a83673c":"thresholds","d3ef152d":"from sklearn.ensemble import RandomForestClassifier","f6155cc5":"rfc_pipeline = Pipeline(steps=[\n    ('processor', transformer),\n    ('model', RandomForestClassifier(max_depth=5))\n])\n\n_ = rfc_pipeline.fit(X_train, y_train)\n\npredictions_rfc = rfc_pipeline.predict(X_test)\n\ncm_rfc = confusion_matrix(y_test, predictions_rfc)\n\ncm_rfc_display = ConfusionMatrixDisplay(cm_rfc).plot()\n\nfpr_rfc, tpr_rfc, thresholds_rfc = roc_curve(y_test, predictions_rfc)\nroc_rfc_display = RocCurveDisplay(fpr=fpr_rfc, tpr=tpr_rfc).plot()","1452cddb":"from sklearn.neighbors import KNeighborsClassifier","40b741e1":"knr_pipeline = Pipeline(steps=[\n    ('processor', transformer),\n    ('model', KNeighborsClassifier(n_neighbors=6))\n])\n\n_ = knr_pipeline.fit(X_train, y_train)\n\npredictions_knr = knr_pipeline.predict(X_test)\n\ncm_knr = confusion_matrix(y_test, predictions_knr)\n\ncm_knr_display = ConfusionMatrixDisplay(cm_knr).plot()\n\nfpr_knr, tpr_knr, thresholds_knr = roc_curve(y_test, predictions_knr)\nroc_knr_display = RocCurveDisplay(fpr=fpr_knr, tpr=tpr_knr).plot()","86f1bf61":"from sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.metrics import mean_squared_log_error","c5491995":"def error_fct(name, pipe, df_x, df_y):\n    results = pd.DataFrame({'predictions':pipe.predict(df_x), 'true_values':df_y})\n    mse = mean_squared_error(results.true_values, results.predictions)\n    rmse = mean_squared_error(results.true_values, results.predictions)**0.5\n    rmsle = mean_squared_log_error(results.true_values, abs(results.predictions))**0.5\n    print('pipeline:', name,' ','mse:', mse,' ','rmse:', rmse,' ','rmsle:', rmsle)","372c05a6":"error_fct('lr', lr_pipeline, X_test, y_test)","4c373e43":"error_fct('rfc', rfc_pipeline, X_test, y_test)","3ac73f45":"error_fct('knr', knr_pipeline, X_test, y_test)","9dc94f76":"test","1ff6ab28":"submission_array = knr_pipeline.predict(test)","70506225":"submission = pd.DataFrame({'Id': test.index, 'poisonous': submission_array})","fb701c07":"submission","bea9b1ec":"submission.to_csv('submission.csv', index=False)\nprint(\"submission.csv has been saved.\")","d96a56ee":"## ROC-Curve","69b77203":"## Encoding","54ffb2b4":"The exploration of X shows:\n- no missing values\n- no numerical columns\n- no ordinal categorical columns\n\n---> all columns are categorical and nominal","eefba023":"## Submission","f8c62a37":"# Identifying poisonous and non poisonous mushrooms","c825bee2":"## ColumnTransformation","cca614ec":"#### LogisticRegression Pipeline","309fd070":"## Calculating Errors","463431f3":"#### KNeighborsRegressor Pipeline","659cd298":"#### RandomForest Pipeline","30c1d315":"Receiver Operating Characteristic (ROC) curves:\n\nA receiver operating characteristic (ROC), or simply ROC curve, is a graphical plot which illustrates the performance of a binary classifier system as its discrimination threshold is varied.\n\nThe classification system contains of four general classes:\n```\n  True Positiv = as positiv classified matching the truth\n  False Positiv = as positiv classified not matching the truth\n  True Negativ = as negativ classified matching the truth\n  False Negativ = as negativ classified not matching the truth\n```\n\nThe ROC curve is created by plotting the fraction of true positives out of the positives (TPR = true positive rate) vs. the fraction of false positives out of the negatives (FPR = false positive rate), at various threshold settings. TPR is also known as sensitivity, and FPR is one minus the specificity or true negative rate.\n```\n  TPR = Sensitivity = True Positives \/ (True Positives + False Negatives)\n  Specificity = True Negatives \/ (True Negatives + False Positives)\n  FPR = 1-Specificity = False Positives \/ (False Positives + True Negatives)\n```\nThe ROC curve function requires the true binary value and the target scores, which can either be probability estimates of the positive class, confidence values, or binary decisions.\n```\nThe ROC curve is a useful tool for a few reasons:\n -The curves of different models can be compared directly in general or for different thresholds.\n -The area under the curve (AUC) can be used as a summary of the model skill.\n```  \nThe AUC (Area Under Curve) is the area enclosed by the ROC curve. A perfect classifier has AUC = 1 and a completely random classifier has AUC = 0.5.\nThe range of possible AUC values is [0, 1]."}}