{"cell_type":{"b0b6d2c7":"code","312cc11b":"code","88c2b36f":"code","6f6af0f2":"code","4eeeb7dc":"code","2593dc19":"code","4f02c615":"code","6da71247":"code","5b595942":"code","afa3c863":"code","d0f20f57":"code","a3f7b84c":"code","467703fc":"code","d7c23e88":"code","3af878c1":"code","80b25b68":"code","26aa2e03":"code","32894583":"code","97c1f2be":"code","9a468844":"code","0a18c44b":"code","2bb82e6e":"code","4c6868c6":"code","1ea1cb0e":"code","a44de84b":"code","66fdc66e":"code","a9faaa37":"code","9769de23":"code","c43ad8c7":"code","b993384d":"code","fa94a7c2":"code","c1be797a":"code","2e80712c":"code","709ff209":"code","d8508f5c":"code","2e079ea0":"code","190fb2cf":"code","97ea96a7":"code","a02f31d3":"code","b0996683":"markdown","bdbb12ce":"markdown","66f5de4c":"markdown","af389649":"markdown","fe492066":"markdown"},"source":{"b0b6d2c7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport lightgbm as lgbm\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import KFold, StratifiedKFold\nfrom sklearn.metrics import log_loss\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.preprocessing import LabelEncoder, StandardScaler\n\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import Dense, Dropout, BatchNormalization, Activation \nfrom keras.callbacks import EarlyStopping, ModelCheckpoint\nfrom keras import optimizers\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\nimport gc\n# Any results you write to the current directory are saved as output.","312cc11b":"train = pd.read_csv('..\/input\/kaggletutorial\/covertype_train.csv')\ntest = pd.read_csv('..\/input\/kaggletutorial\/covertype_test.csv')","88c2b36f":"train.shape","6f6af0f2":"test.shape","4eeeb7dc":"train_index = train.shape[0]","2593dc19":"original_all_data = pd.concat([train, test])\nall_data = original_all_data.copy()","4f02c615":"original_all_data['Soil_Type']","6da71247":"for col in all_data.loc[:,all_data.dtypes=='object'].columns:\n    all_data[col] = all_data[col].factorize()[0]","5b595942":"all_data['Soil_Type']","afa3c863":"all_data2 = pd.concat([train, test])\nfor col in all_data2.loc[:,all_data2.dtypes=='object'].columns:\n    le = LabelEncoder()\n    all_data2[col] = le.fit_transform(all_data2[col])","d0f20f57":"all_data2['Soil_Type']","a3f7b84c":"unique_soil_type = sorted(original_all_data['Soil_Type'].unique())\nfor index, soil in enumerate(unique_soil_type):\n    print(soil, original_all_data.loc[original_all_data['Soil_Type']==soil ].shape[0], \n          all_data2.loc[all_data2['Soil_Type']==index ].shape[0]) ","467703fc":"unique_soil_type = sorted(original_all_data['Soil_Type'].unique())\nfor index, soil in enumerate(unique_soil_type):\n    print(soil, original_all_data.loc[original_all_data['Soil_Type']==soil ].shape[0], \n          all_data.loc[all_data['Soil_Type']==index ].shape[0]) ","d7c23e88":"all_data2 = pd.concat([train, test])\nle = LabelEncoder()","3af878c1":"%timeit(le.fit_transform(all_data2['Soil_Type']))","80b25b68":"%timeit(all_data2['Soil_Type'].factorize()[0])","26aa2e03":"all_data = pd.concat([train, test])\nfor col in all_data.loc[:, all_data.dtypes=='object'].columns:\n    all_data[col] = all_data[col].factorize()[0]","32894583":"train_df = all_data.iloc[:train_index]\ntest_df = all_data.iloc[train_index:]","97c1f2be":"y_value = train_df['Cover_Type']\ndel train_df['Cover_Type'], train_df['ID']\n\ndel test_df['Cover_Type'], test_df['ID']","9a468844":"lgbm_param =  {\n    'boosting_type': 'gbdt',\n    'objective': 'binary',\n    'metric': 'binary_logloss',\n    \"learning_rate\": 0.06,\n    \"num_leaves\": 16,\n    \"max_depth\": 6,\n    \"colsample_bytree\": 0.7,\n    \"subsample\": 0.8,\n    \"reg_alpha\": 0.1,\n    \"reg_lambda\": 0.1,\n    \"nthread\":8\n}","0a18c44b":"NFOLD = 5\nfolds = StratifiedKFold(n_splits= NFOLD, shuffle=True, random_state=2018)\n\ntotal_score = 0\nbest_iteration = 0\nfor n_fold, (train_idx, valid_idx) in enumerate(folds.split(train_df, y_value)):\n    train_x, train_y = train_df.iloc[train_idx], y_value.iloc[train_idx]\n    valid_x, valid_y = train_df.iloc[valid_idx], y_value.iloc[valid_idx]\n    \n    evals_result_dict = {} \n    dtrain = lgbm.Dataset(train_x, label=train_y)\n    dvalid = lgbm.Dataset(valid_x, label=valid_y)\n  \n    clf = lgbm.train(lgbm_param, train_set=dtrain, num_boost_round=3000, valid_sets=[dtrain, dvalid],\n                           early_stopping_rounds=200, evals_result=evals_result_dict, verbose_eval=100)\n    \n    predict = clf.predict(valid_x)\n    cv_score = log_loss(valid_y, predict )\n    total_score += cv_score\n    best_iteration = max(best_iteration, clf.best_iteration)\n    print('Fold {} LogLoss : {}'.format(n_fold + 1, cv_score ))\n    lgbm.plot_metric(evals_result_dict)\n    plt.show()","2bb82e6e":"print(\"Best Iteration\", best_iteration)\nprint(\"Total LogLoss\", total_score\/NFOLD)\ndtrain = lgbm.Dataset(train_df, label=y_value)\nclf = lgbm.train(lgbm_param, train_set=dtrain, num_boost_round=best_iteration)\npredict = clf.predict(test_df)","4c6868c6":"submission = pd.read_csv('..\/input\/kaggletutorial\/sample_submission.csv')\nsubmission[\"Cover_Type\"] = predict\nsubmission.to_csv('lightgbm_baseline_{:.5f}.csv'.format(total_score\/NFOLD), index=False)","1ea1cb0e":"all_data = pd.concat([train, test])","a44de84b":"all_data = pd.concat([train, test])\ncategory_feature = []\nfor col in all_data.loc[:, all_data.dtypes=='object'].columns:\n    all_data[col] = all_data[col].factorize()[0]\n    category_feature.append(col)","66fdc66e":"category_feature","a9faaa37":"all_data.isnull().sum()","9769de23":"sns.distplot(all_data.loc[all_data['Aspect'].notnull(),'Aspect'])\nplt.show()","c43ad8c7":"sns.distplot(all_data['Aspect'].fillna(all_data['Aspect'].mean()))\nplt.show()","b993384d":"all_data['Aspect'].fillna(all_data['Aspect'].mean(), inplace=True)","fa94a7c2":"train_df = all_data.iloc[:train_index]\ntest_df = all_data.iloc[train_index:]","c1be797a":"numerical_feature = list(set(train_df.columns) - set(category_feature) - set(['Cover_Type','ID']))\nnumerical_feature","2e80712c":"sc = StandardScaler()\ntrain_df[numerical_feature] = sc.fit_transform(train_df[numerical_feature])\ntest_df[numerical_feature] = sc.transform(test_df[numerical_feature] )","709ff209":"y_value = train_df['Cover_Type']\ndel train_df['Cover_Type'], train_df['ID']\n\ndel test_df['Cover_Type'], test_df['ID']","d8508f5c":"def keras_model(input_dims):\n    model = Sequential()\n    \n    model.add(Dense(input_dims, input_dim=input_dims))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Dropout(0.3))\n    \n    model.add(Dense(input_dims\/\/2))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Dropout(0.2))\n    \n    # output layer (y_pred)\n    model.add(Dense(1))\n    model.add(Activation('sigmoid'))\n    \n    # compile this model\n    model.compile(loss='binary_crossentropy', # one may use 'mean_absolute_error' as alternative\n                  optimizer='adam', metrics=['accuracy'])\n    return model\n\ndef keras_history_plot(history):\n    plt.plot(history.history['loss'], 'y', label='train loss')\n    plt.plot(history.history['val_loss'], 'r', label='val loss')\n    plt.xlabel('epoch')\n    plt.ylabel('loss')\n    plt.legend(loc='upper right')\n    plt.show()","2e079ea0":"model = keras_model(train_df.shape[1])\ncallbacks = [\n        EarlyStopping(\n            patience=10,\n            verbose=10)\n    ]\n\n\nNFOLD = 5\nfolds = StratifiedKFold(n_splits= NFOLD, shuffle=True, random_state=2018)\n\ntotal_score = 0\nbest_epoch = 0\nfor n_fold, (train_idx, valid_idx) in enumerate(folds.split(train_df, y_value)):\n    train_x, train_y = train_df.iloc[train_idx], y_value.iloc[train_idx]\n    valid_x, valid_y = train_df.iloc[valid_idx], y_value.iloc[valid_idx]\n    \n    history = model.fit(train_x.values, train_y.values, nb_epoch=30, batch_size = 64, validation_data=(valid_x.values, valid_y.values), \n                        verbose=1, callbacks=callbacks)\n    \n    keras_history_plot(history)\n    predict = model.predict(valid_x.values)\n    null_count = np.sum(pd.isnull(predict) )\n    if null_count > 0:\n        print(\"Null Prediction Error: \", null_count)\n        predict[pd.isnull(predict)] = predict[~pd.isnull(predict)].mean()\n    \n    cv_score = log_loss(valid_y, predict )\n    total_score += cv_score\n    best_epoch = max(best_epoch, np.max(history.epoch))\n    print('Fold {} LogLoss : {}'.format(n_fold + 1, cv_score ))","190fb2cf":"print(\"Best Epoch: \", best_epoch)\nprint(\"Total LogLoss\", total_score\/NFOLD)","97ea96a7":"history = model.fit(train_df.values, y_value.values, nb_epoch=best_epoch, batch_size = 64, verbose=1)\npredict = model.predict(test_df.values)\nnull_count = np.sum(pd.isnull(predict) )\nif null_count > 0:\n    print(\"Null Prediction Error: \", null_count)\n    predict[pd.isnull(predict)] = predict[~pd.isnull(predict)].mean()","a02f31d3":"submission = pd.read_csv('..\/input\/kaggletutorial\/sample_submission.csv')\nsubmission[\"Cover_Type\"] = predict\nsubmission.to_csv('neuralnetwork_baseline_{:.5f}.csv'.format(total_score\/NFOLD), index=False)","b0996683":"#### \uc18d\ub3c4 \ube44\uad50","bdbb12ce":"### Label Encoding \uc2e4\uc2b5","66f5de4c":"\ud30c\ub77c\ubbf8\ud130 \ud29c\ub2dd \ub9c8\uc74c\uaecf \ud558\uc154\ub3c4 \ub429\ub2c8\ub2e4!","af389649":"# \uc55e\uc73c\ub85c FE\ub97c \ud1b5\ud574\uc11c Model\uc758 \uc131\ub2a5\uc744 \uc62c\ub9ac\uace0 Tree Model\uacfc \uc120\ud615 \ubaa8\ub378\uac04 \ube44\uad50\ub97c \ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.\n### \uadf8\uc5d0 \uc55e\uc11c \uae30\uc900\uc774 \ub418\ub294 Tree Model \uc785\ub2c8\ub2e4. \uc544\ubb34\uac83\ub3c4 \ud558\uc9c0 \uc54a\uace0 Label Encoding\ub9cc \uc218\ud589\ud55c Tree Model \uc785\ub2c8\ub2e4.","fe492066":"## Tree Model\uacfc \ube44\uad50\ub420 Neural Network \ubaa8\ub378\uc785\ub2c8\ub2e4.\n\uc544\uc8fc \uac04\ub2e8\ud558\uac8c Layer\uac00 \uad6c\uc131\ub418\uc5b4 \uc788\uc2b5\ub2c8\ub2e4.<br>\nLabel Encoding\ub9cc\ud558\uace0 Null \uac12\ub9cc \ucc44\uc6e0\uc744 \uacbd\uc6b0 \uc544\uc608 \ud559\uc2b5\uc774 \ub418\uc9c0 \uc54a\uc544. StandardScaler\uae4c\uc9c0 \uc9c4\ud589\ud558\uc600\uc2b5\ub2c8\ub2e4. <br>"}}