{"cell_type":{"fdfce8bf":"code","046c31b0":"code","a3305435":"code","93f28c37":"code","10f7c7a6":"code","851101bc":"code","f462469c":"code","3f17c812":"code","5fdae543":"code","645ac3e0":"code","b9a46d83":"code","c9576ce9":"code","e4f782ef":"code","c16e0af9":"code","d3b59b05":"code","bd2b4c7b":"code","852f0f71":"code","cfbe7a93":"code","6b3725e8":"code","452e6263":"code","207a7797":"code","e5d60617":"code","4e58c75f":"code","a15a6179":"code","388246f3":"code","c7671354":"code","d3daadeb":"code","15505fcd":"code","f95ff1ee":"code","1c54007f":"code","0e93eb2d":"code","fb2da6f6":"code","c2f8785c":"code","ed70779e":"code","edf37176":"code","04ce39b2":"code","1f8f8836":"code","5904f7ac":"code","902fa689":"code","434b4cf6":"code","a4369759":"code","0e95d20d":"code","314841c3":"code","1d5766bb":"code","8591c331":"code","6fa0805f":"code","c4198855":"code","900e207e":"code","412586a1":"code","1e2ae155":"code","edf643b2":"code","bbcf47f4":"code","4e4e69e6":"code","263226af":"code","634c9fad":"code","e913c168":"code","4776e136":"code","7dc91d3e":"markdown","95018560":"markdown","b6f8fd3b":"markdown","671e9729":"markdown","7a7a9e50":"markdown","3c6a61c0":"markdown","62c4d18c":"markdown","7e61fdfe":"markdown","a46054a4":"markdown","d2d97015":"markdown","41afe15f":"markdown"},"source":{"fdfce8bf":"# importing modules which are going to use\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom scipy.stats import norm\nfrom scipy import stats\nfrom sklearn import preprocessing\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import Lasso\nfrom sklearn.linear_model import ElasticNet\n\nfrom sklearn import metrics\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import mean_absolute_error\nfrom math import sqrt\nfrom sklearn.metrics import r2_score","046c31b0":"# the first look through the data \n\nNYC_AIRBNB = pd.read_csv('..\/input\/AB_NYC_2019.csv', encoding = \"ISO-8859-1\")\nNYC_AIRBNB.head()","a3305435":"# data types and numbers of variables\nNYC_AIRBNB.info()","93f28c37":"# info of NaN in our data set as percentage\n\ndef show_missing (df):\n    \"\"\"This function returns percentage and total number of missing values\"\"\"\n    percent = df.isnull().sum()*100\/df.shape[0]\n    total = df.isnull().sum()\n    missing = pd.concat([percent, total], axis=1, keys=['percent', 'total'])\n    return missing[missing.total>0].sort_values('total', ascending=False)","10f7c7a6":"show_missing(NYC_AIRBNB)","851101bc":"# dropping 'id', host_name', 'last_review' and 'host_id' columns\n# Because of the low percentage of \"host_name\"s NANs, \"last_review\" is a date. \n# we don't use 'id', and 'host_id' in our model.\n\nNYC_AIRBNB=NYC_AIRBNB.drop(['id','host_name','last_review', 'host_id'], axis=1)","f462469c":"#dropping the NaNs from 'name'\n\nNYC_AIRBNB=NYC_AIRBNB.dropna(subset=[\"name\"])","3f17c812":"# filling the NaNs of \"reviews_per_month\" with mean\n\nNYC_AIRBNB['reviews_per_month'] = NYC_AIRBNB['reviews_per_month'].fillna(NYC_AIRBNB['reviews_per_month'].mean())","5fdae543":"NYC_AIRBNB.describe()","645ac3e0":"NYC_AIRBNB.price.hist(bins=100)","b9a46d83":"NYC_AIRBNB[NYC_AIRBNB.price<1000].price.hist(bins=100)\nplt.show()","c9576ce9":"from scipy.stats import zscore","e4f782ef":"z=zscore(NYC_AIRBNB.price)\nz","c16e0af9":"m=NYC_AIRBNB.price.mean()\ns=NYC_AIRBNB.price.std()\nm+3*s","d3b59b05":"plt.boxplot(NYC_AIRBNB.price)\nplt.show()","bd2b4c7b":"# we will drop the rows which have a price more than mean+3*std (zscore>3)\nnp.sum(NYC_AIRBNB.price>873)","852f0f71":"NYC_AIRBNB_dropped=NYC_AIRBNB[NYC_AIRBNB.price<873]\nNYC_AIRBNB_dropped","cfbe7a93":"from scipy.stats.mstats import winsorize\n\nNYC_AIRBNB_winsor = NYC_AIRBNB.copy()\nNYC_AIRBNB_winsor['price'] = winsorize(NYC_AIRBNB[\"price\"], (0, 0.01))\n\nmax(NYC_AIRBNB_winsor.price)","6b3725e8":"plt.boxplot(NYC_AIRBNB_winsor.price)\nplt.title(\"Boxplot of Prices\")\nplt.show()","452e6263":"import plotly.graph_objs as go","207a7797":"# create a donut-like pie chart to show the ratio of Airbnb numbers by Neighborhood_group\n\ncolors = ['gold', 'mediumturquoise', 'darkorange', 'lightgreen']\nlabels = NYC_AIRBNB.neighbourhood_group.value_counts().index\nvalues = NYC_AIRBNB.neighbourhood_group.value_counts().values\n\nfig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=.2)])\nfig.update_traces(marker=dict(colors = colors, line=dict(color='#000000', width=1)))\n\nfig.show()","e5d60617":"# use countplot to show the ratio of Airbnb amounts by Neighborhood_group\n\nplt.subplots(figsize=(14,6))\nsns.countplot('neighbourhood_group',data=NYC_AIRBNB,palette='Spectral')\nplt.xticks(rotation=70)\nplt.title('Airbnb Numbers by Neighbourhood Group in NYC', color='red')\nplt.show()","4e58c75f":"# create a donut-like pie chart to show the ratio of Airbnb room types\n\ncolors = ['gold', 'mediumturquoise', 'darkorange', 'lightgreen']\nlabels = NYC_AIRBNB.room_type.value_counts().index\nvalues = NYC_AIRBNB.room_type.value_counts().values\n\n# Use `hole` to create a donut-like pie chart\nfig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=.3)])\nfig.update_traces(marker=dict(colors = colors, line=dict(color='#000000', width=2)))\n\nfig.show()","a15a6179":"# the ratio of Airbnb room types with countplot by Neighbourhood_group\n\nplt.subplots(figsize=(14,6))\nsns.countplot('neighbourhood_group',data=NYC_AIRBNB,palette='Spectral', hue=\"room_type\")\nplt.xticks(rotation=70)\nplt.title('Airbnb Room Types by Neighbourhood Group in NYC', color='red')\nplt.show()","388246f3":"# neighbourhood_groups with daily average prices\n\nNYC_AIRBNB.groupby('neighbourhood_group').mean()['price'].plot.bar()","c7671354":"#let's grab 10 most reviewed listings in NYC\n\ntop_reviewed_listings=NYC_AIRBNB.nlargest(10,'number_of_reviews')\ntop_reviewed_listings","d3daadeb":"price_avrg=top_reviewed_listings.price.mean()\nprint('Average price per night: {}'.format(price_avrg))","15505fcd":"NYC_AIRBNB['Cat'] = NYC_AIRBNB['price'].apply(lambda x: 'costly' if x > 3000\n                                                    else ('medium' if x >= 1000 and x < 3000\n                                                    else ('reasonable' if x >= 500 and x < 1000\n                                                     else ('cheap' if x >= 100 and x <500\n                                                          else'very cheap'))))","f95ff1ee":"plt.figure(figsize=(10,8))\n\nsns.scatterplot(NYC_AIRBNB.latitude,NYC_AIRBNB.longitude, hue='Cat', data=NYC_AIRBNB)","1c54007f":"data_manhattan=NYC_AIRBNB[NYC_AIRBNB.neighbourhood_group=='Manhattan']\ndata_manhattan.head()","0e93eb2d":"data_manha_65=data_manhattan[data_manhattan.price<65]\ndata_manha_65['label']=data_manha_65.apply(lambda x: (x['name'],'price:'+str(x['price'])),axis=1)\ndata_manha_65.head()","fb2da6f6":"import folium\nfrom folium import plugins","c2f8785c":"# According to this map,you can see the number of rooms due to price of <65 USD.\n\nLong=-73.92\nLat=40.86\nmanha_map=folium.Map([Lat,Long],zoom_start=12)\n\nmanha_rooms_map=plugins.MarkerCluster().add_to(manha_map)\nfor lat,lon,label in zip(data_manha_65.latitude,data_manha_65.longitude,data_manha_65.label):\n    folium.Marker(location=[lat,lon],icon=None,popup=label).add_to(manha_rooms_map)\nmanha_map.add_child(manha_rooms_map)\n\nmanha_map","ed70779e":"NYC_AIRBNB_model = NYC_AIRBNB_dropped.copy()","edf37176":"# using get_dummies by concatting \"room_type\",\"neighbourhood_group\" to shape our model \n\nNYC_AIRBNB_model= pd.concat([NYC_AIRBNB_model, pd.get_dummies(NYC_AIRBNB_model[[\"room_type\",\"neighbourhood_group\"]])], axis=1)\nNYC_AIRBNB_model.head()","04ce39b2":"plt.figure(figsize=(10,10))\nsns.distplot(NYC_AIRBNB_model['price'], fit=norm)\nplt.title(\"Price Distribution Plot\",size=15, weight='bold')","1f8f8836":"NYC_AIRBNB_model['price_log'] = np.log(NYC_AIRBNB_model.price+1)","5904f7ac":"# With Log-Price Distribution Plot we see price feature have normal distribution.\n\nplt.figure(figsize=(12,10))\nsns.distplot(NYC_AIRBNB_model['price_log'], fit=norm)\nplt.title(\"Log-Price Distribution Plot\",size=12, weight='bold')","902fa689":"plt.figure(figsize=(7,7))\nstats.probplot(NYC_AIRBNB_model['price_log'], plot=plt)\nplt.show()","434b4cf6":"# Need to see the correlation table but it shows us that there is no strong relationship between price and other features.\n# But at least price_log will give us some correleations with room_types.\n\nf,ax = plt.subplots(figsize=(13, 13))\nsns.heatmap(NYC_AIRBNB_model.drop('neighbourhood', axis = 1).corr(), annot=True, linewidths=.5, fmt= '.1f',ax=ax)\nplt.show()","a4369759":"#trying to create our model with _price_log\n\nY = NYC_AIRBNB_model['price_log']\nX = NYC_AIRBNB_model.drop([\"neighbourhood\", \"neighbourhood_group\", \"room_type\", \"price\", \n                           \"latitude\", \"longitude\",\"price_log\", \"name\"], axis=1)","0e95d20d":"lrm = LinearRegression()\nlrm.fit(X, Y)","314841c3":"print('Variables: \\n', lrm.coef_)\nprint('Constant Value (bias): \\n', lrm.intercept_)","1d5766bb":"import statsmodels.api as sm\n\nX = sm.add_constant(X)\nresults = sm.OLS(Y, X).fit()\nresults.summary()","8591c331":"from sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_absolute_error\nimport statsmodels.api as sm\nfrom statsmodels.tools.eval_measures import mse, rmse\n\n%matplotlib inline\npd.options.display.float_format = '{:.3f}'.format\n\nimport warnings\nwarnings.filterwarnings(action=\"ignore\")","6fa0805f":"X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2, random_state = 465)\n\nprint(\"Observation number in train set : {}\".format(X_train.shape[0]))\nprint(\"Observation number in test set   : {}\".format(X_test.shape[0]))","c4198855":"X_train = sm.add_constant(X_train)\n\nresults = sm.OLS(y_train, X_train).fit()\n\nresults.summary()","900e207e":"# real values with red line, predicted values with blue dots\n\nX_test = sm.add_constant(X_test)\ny_preds = results.predict(X_test)\n\nbaslik_font = {'family': 'arial','color':  'darkred','weight': 'bold','size': 15 }\neksen_font = {'family': 'arial','color':  'darkblue','weight': 'bold','size': 10 }\nplt.figure(dpi = 100)\n\nplt.scatter(y_test, y_preds)\nplt.plot(y_test, y_test, color=\"red\")\nplt.xlabel(\"Real Values\", fontdict=eksen_font)\nplt.ylabel(\"Predicted Values\", fontdict=eksen_font)\nplt.title(\"Prices: Real and Predicted Values\", fontdict=baslik_font)\nplt.show()\n\nprint(\"mean_absolute_error (MAE)        : {}\".format(mean_absolute_error(y_test, y_preds)))\nprint(\"mean_squared_error (MSE)          : {}\".format(mse(y_test, y_preds)))\nprint(\"root_mean_squared_error (RMSE)     : {}\".format(rmse(y_test, y_preds)))\nprint(\"mean_absolute_percentage_error (MAPE) : {}\".format(np.mean(np.abs((y_test - y_preds) \/ y_test)) * 100))","412586a1":"X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2, random_state = 465)","1e2ae155":"lrm = LinearRegression()\nlrm.fit(X_train, y_train)\n\ny_train_prediction = lrm.predict(X_train)\ny_test_prediction = lrm.predict(X_test)\n\nprint(\"Train Observation Number  : {}\".format(X_train.shape[0]))\nprint(\"Test Observation Number    : {}\".format(X_test.shape[0]), \"\\n\")\n\nprint(\"R-Square value in Train Set  : {}\".format(lrm.score(X_train, y_train)))\nprint(\"-----Test Set Statistics---\")\nprint(\"Test set R-Square Value         : {}\".format(lrm.score(X_test, y_test)))\nprint(\"mean_absolute_error (MAE)        : {}\".format(mean_absolute_error(y_test, y_test_prediction)))\nprint(\"mean_squared_error (MSE)          : {}\".format(mse(y_test, y_test_prediction)))\nprint(\"root_mean_squared_error (RMSE)     : {}\".format(rmse(y_test, y_test_prediction)))\nprint(\"mean_absolute_percentage_error (MAPE) : {}\".format(np.mean(np.abs((y_test - y_test_prediction) \/ y_test)) * 100))","edf643b2":"for alpha in [10**x for x in range (-10, 10)]:\n    ridgeregr = Ridge(alpha=alpha) \n    ridgeregr.fit(X_train, y_train)\n\n    y_train_prediction = ridgeregr.predict(X_train)\n    y_test_prediction = ridgeregr.predict(X_test)\n\n    print(\"alpha : {} , root_mean_squared_error (RMSE) : {}\".format(alpha, rmse(y_test, y_test_prediction)))","bbcf47f4":"ridgeregr = Ridge(alpha=1) \nridgeregr.fit(X_train, y_train)\n\ny_train_prediction = ridgeregr.predict(X_train)\ny_test_prediction = ridgeregr.predict(X_test)\n\nprint(\"R-Square value in Train Set       : {}\".format(ridgeregr.score(X_train, y_train)))\nprint(\"-----Test Set Statistics---\")\nprint(\"Test set R-Square Value         : {}\".format(ridgeregr.score(X_test, y_test)))\nprint(\"mean_absolute_error (MAE)        : {}\".format(mean_absolute_error(y_test, y_test_prediction)))\nprint(\"mean_squared_error (MSE)          : {}\".format(mse(y_test, y_test_prediction)))\nprint(\"root_mean_squared_error (RMSE)     : {}\".format(rmse(y_test, y_test_prediction)))","4e4e69e6":"mse(y_test, y_test_prediction)","263226af":"from sklearn.linear_model import Lasso\n\nlassoregr = Lasso(alpha=0.0001) \nlassoregr.fit(X_train, y_train)\n\ny_train_prediction = lassoregr.predict(X_train)\ny_test_prediction = lassoregr.predict(X_test)\n\nprint(\"R-Square value in Train Set       : {}\".format(lassoregr.score(X_train, y_train)))\nprint(\"-----Test Set Statistics---\")\nprint(\"Test set R-Square Value         : {}\".format(lassoregr.score(X_test, y_test)))\nprint(\"mean_absolute_error (MAE)        : {}\".format(mean_absolute_error(y_test, y_test_prediction)))\nprint(\"mean_squared_error (MSE)          : {}\".format(mse(y_test, y_test_prediction)))\nprint(\"root_mean_squared_error (RMSE)     : {}\".format(rmse(y_test, y_test_prediction)))","634c9fad":"for alpha in [10**x for x in range (-10, 10)]:\n    lassoregr = Lasso(alpha=alpha) \n    lassoregr.fit(X_train, y_train)\n\n    y_train_prediction = lassoregr.predict(X_train)\n    y_test_prediction = lassoregr.predict(X_test)\n\n    print(\"alpha : {} , root_mean_squared_error (RMSE) : {}\".format(alpha, rmse(y_test, y_test_prediction)))","e913c168":"from sklearn.linear_model import ElasticNet\n\nelasticregr = ElasticNet(alpha=0.001, l1_ratio=0.5) \nelasticregr.fit(X_train, y_train)\n\ny_train_prediction = elasticregr.predict(X_train)\ny_test_prediction = elasticregr.predict(X_test)\n\nprint(\"R-Square value in Train Set       : {}\".format(elasticregr.score(X_train, y_train)))\nprint(\"-----Test Set Statistics---\")\nprint(\"Test set R-Square Value          : {}\".format(elasticregr.score(X_test, y_test)))\nprint(\"mean_absolute_error (MAE)        : {}\".format(mean_absolute_error(y_test, y_test_prediction)))\nprint(\"mean_squared_error (MSE)          : {}\".format(mse(y_test, y_test_prediction)))\nprint(\"root_mean_squared_error (RMSE)     : {}\".format(rmse(y_test, y_test_prediction)))","4776e136":"np.exp (y_test_prediction)","7dc91d3e":"### 4. Model By Using Regression","95018560":"### 2. General View of the Data","b6f8fd3b":"This Airbnb ('AB_NYC_2019') dataset for the 2019 year appeared to be a very rich dataset with a variety of columns that allowed us to do deep data exploration and visualization on each significant column presented. But unfortunately for modelling with regression when we compare real and predicted values we couldnt reach the wanted aim because of data in hands. May be if we try to use latitude and longitude variables to achieve a better result, especially R-square will be better. At the end, we can even choose ridge or lasso model to best fit our prediction (They both have the same RMSE value). \n\nOverall, with this study we discovered a very good number of interesting relationships between features and tried to explain each step of the process. This data analytics adn visualizations will useful for better business decisions, control over the platform, marketing initiatives and much more... Therefore, I hope this kernel helps everyone!","671e9729":"The distribution graph shows that there is a right-skewed -a positive skewness- distribution on price. Log transformation will be used to make this feature less skewed. This will help to make easier interpretation and better statistical analysis. But  division by zero is a problem while calculating so \"log+1\" transformation would be better to use.","7a7a9e50":"### 1. Introduction\nAirbnb is an online marketplace which lets people rent out their properties or spare rooms to guests since 2008. Airbnb takes 3% commission of every booking from hosts, and between 6% and 12% from guests. NYC is the most populous city in the United States and also one of the most popular tourism and business place in the world where Airbnb usage is widespread.\n\nAirbnb NYC 2019 data contains listing activity and metrics. In this study, I would like to choose the best prediction model for price in NYC Airbnb. Meanwhile, price feature's relationship examines with others and some data exploratory analysis and visualizations will be made.","3c6a61c0":"### 5. Conclusions","62c4d18c":"### 3. EDA","7e61fdfe":"### Contents\n1. Introduction\n2. General View of the Data\n3. Explatory Data Analysis (EDA)\n4. Model by using Regression\n5. Conclusions\n","a46054a4":"### A LINEAR REGRESSION DATA SCIENCE PROJECT PREPARED BY ABDULKAD\u0130R GER\u00c7EKSEVER","d2d97015":"### NYC AIRBNB PRICE PREDICTION","41afe15f":"From this table output, we can observe that top 10 most reviewed listings on Airbnb for NYC has price average of 65 USD with most bof the listings under 100 USD."}}