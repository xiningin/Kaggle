{"cell_type":{"7458c4f2":"code","83948cc9":"code","2ce18dd3":"code","dd32eea5":"code","32ef421d":"code","8d4602f9":"code","9a2c3247":"code","6ad94c9a":"code","7c0d0d8c":"code","766ae3ec":"code","861fc895":"code","c0b11622":"code","c62a768a":"markdown","c376caf4":"markdown","605d2c3a":"markdown","5d760f9c":"markdown"},"source":{"7458c4f2":"import pandas as pd       \nimport matplotlib as mat\nimport matplotlib.pyplot as plt    \nimport numpy as np\nimport os\nimport seaborn as sns\nimport cv2\npd.options.display.max_colwidth = 100\n\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report, roc_curve, auc\n\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nfrom tensorflow.keras import callbacks\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\n\nimport glob","83948cc9":"IMG_SIZE = 150\nBATCH = 64\nSEED = 42\n\nmain_path = \"..\/input\/labeled-chest-xray-images\/chest_xray\"\n\ntrain_path = os.path.join(main_path,\"train\")\ntest_path=os.path.join(main_path,\"test\")\n\ntrain_normal = glob.glob(train_path+\"\/NORMAL\/*.jpeg\")\ntrain_pneumonia = glob.glob(train_path+\"\/PNEUMONIA\/*.jpeg\")\n\ntest_normal = glob.glob(test_path+\"\/NORMAL\/*.jpeg\")\ntest_pneumonia = glob.glob(test_path+\"\/PNEUMONIA\/*.jpeg\")","2ce18dd3":"train_list = [x for x in train_normal]\ntrain_list.extend([x for x in train_pneumonia])\n\ndf_train = pd.DataFrame(np.concatenate([['Normal']*len(train_normal) , ['Pneumonia']*len(train_pneumonia)]), columns = ['class'])\ndf_train['image'] = [x for x in train_list]\n\ntest_list = [x for x in test_normal]\ntest_list.extend([x for x in test_pneumonia])\n\ndf_test = pd.DataFrame(np.concatenate([['Normal']*len(test_normal) , ['Pneumonia']*len(test_pneumonia)]), columns = ['class'])\ndf_test['image'] = [x for x in test_list]","dd32eea5":"df_train","32ef421d":"df_test","8d4602f9":"train_df, val_df = train_test_split(df_train, test_size = 0.20, random_state = SEED, stratify = df_train['class'])\n\ntrain_df","9a2c3247":"train_datagen = ImageDataGenerator(rescale=1\/255.,\n                                  zoom_range = 0.1,\n                                  #rotation_range = 0.1,\n                                  width_shift_range = 0.1,\n                                  height_shift_range = 0.1)\n\nval_datagen = ImageDataGenerator(rescale=1\/255.)\n\nds_train = train_datagen.flow_from_dataframe(train_df,\n                                             #directory=train_path, #dataframe contains the full paths\n                                             x_col = 'image',\n                                             y_col = 'class',\n                                             target_size = (IMG_SIZE, IMG_SIZE),\n                                             class_mode = 'binary',\n                                             batch_size = BATCH,\n                                             seed = SEED)\n\nds_val = val_datagen.flow_from_dataframe(val_df,\n                                            #directory=train_path,\n                                            x_col = 'image',\n                                            y_col = 'class',\n                                            target_size = (IMG_SIZE, IMG_SIZE),\n                                            class_mode = 'binary',\n                                            batch_size = BATCH,\n                                            seed = SEED)\n\nds_test = val_datagen.flow_from_dataframe(df_test,\n                                            #directory=test_path,\n                                            x_col = 'image',\n                                            y_col = 'class',\n                                            target_size = (IMG_SIZE, IMG_SIZE),\n                                            class_mode = 'binary',\n                                            batch_size = 1,\n                                            shuffle = False) ","6ad94c9a":"#Setting callbakcs\n\nearly_stopping = callbacks.EarlyStopping(\n    monitor='val_loss',\n    patience=5,\n    min_delta=0.0000001,\n    restore_best_weights=True,\n)\n\nplateau = callbacks.ReduceLROnPlateau(\n    monitor='val_loss',\n    factor = 0.2,                                     \n    patience = 2,                                   \n    min_delt = 0.0000001,                                \n    cooldown = 0,                               \n    verbose = 1\n) ","7c0d0d8c":"def get_model():\n    \n    #Input shape = [width, height, color channels]\n    inputs = layers.Input(shape=(IMG_SIZE, IMG_SIZE, 3))\n    \n    # Block One\n    x = layers.Conv2D(filters=1, kernel_size=3, padding='valid')(inputs)\n    x = layers.BatchNormalization()(x)\n    x = layers.Activation('relu')(x)\n    x = layers.MaxPool2D()(x)\n    x = layers.Dropout(0.2)(x)\n\n    # Block Two\n    x = layers.Conv2D(filters=3, kernel_size=5, padding='valid')(x)\n    x = layers.BatchNormalization()(x)\n    x = layers.Activation('relu')(x)\n    x = layers.MaxPool2D()(x)\n    x = layers.Dropout(0.2)(x)\n    \n    # Block Three\n    x = layers.Conv2D(filters=3, kernel_size=5, padding='valid', dilation_rate = 4)(x)\n    x = layers.BatchNormalization()(x)\n    x = layers.Activation('relu')(x)\n    x = layers.Dropout(0.5)(x)\n    x = layers.GlobalAveragePooling2D()(x)\n\n    # Head\n    x = layers.Dense(128, activation='relu')(x) \n    \n    #Final Layer (Output)\n    output = layers.Dense(1, activation='sigmoid')(x)\n    \n    model = keras.Model(inputs=[inputs], outputs=output)\n    \n    return model\n","766ae3ec":"keras.backend.clear_session()\n\nmodel = get_model()\nmodel.compile(loss='binary_crossentropy'\n              , optimizer = keras.optimizers.Adam(learning_rate=0.00003), metrics='binary_accuracy')\n\nmodel.summary()","861fc895":"history = model.fit(ds_train,\n          batch_size = BATCH, epochs = 100,\n          validation_data=ds_val,\n          steps_per_epoch=(len(train_df)\/BATCH),\n          validation_steps=(len(val_df)\/BATCH))","c0b11622":"X_test, y_test = next(ds_test)\nds_test.reset()\ny_pred = model.predict(X_test, batch_size=BATCH, verbose=1)\ny_pred_bool = np.argmax(y_pred, axis=1)\n\nprint(classification_report(y_test, y_pred_bool))","c62a768a":"## Definindo o modelo CNN de Liang e Zheng","c376caf4":"## Gera\u00e7\u00e3o de m\u00e9tricas de desempenho precision, recall e f1-score para o modelo CNN","605d2c3a":"# Conclus\u00f5es \n\nEsse projeto final de introdu\u00e7\u00e3o \u00e0 intelig\u00eancia artificial despertou a minha curiosidade para a \u00e1rea de intelig\u00eancia artificial. Apesar de n\u00e3o ter compreendido o artigo da implementa\u00e7\u00e3o do modelo CNN de Liang e Zheng em sua totalidade, o projeto me incentivou a procurar mais a fundo o tema de redes neuronais convolucionais. ","5d760f9c":"## Projeto 3 da disciplina Introdu\u00e7\u00e3o \u00e0 Intelig\u00eancia Artificial\n\nUniversidade de Bras\u00edlia\n\nInstituto de Ci\u00eancias Exatas\n\nDepartamento de Ci\u00eancia da Computa\u00e7\u00e3o\n\nIntrodu\u00e7\u00e3o \u00e0 Intelig\u00eancia Artificial \u2013 1\/2021\n\nProfessor: D\u00edbio Leandro Borges\n\nDesenvolvido por: Guilherme Silva Souza\n\nMatricula: 190014059\n\n## Fontes usadas no projeto:\n\nhttps:\/\/www.kaggle.com\/jonaspalucibarbosa\/chest-x-ray-pneumonia-cnn-transfer-learning\/notebook\n\nhttps:\/\/www.kaggle.com\/tolgadincer\/labeled-chest-xray-images \n\n## Introdu\u00e7\u00e3o\n\nAs redes neurais convolucionais (CNN) se utilizam de uma arquitetura especial que \u00e9 particularmente bem adequada para classificar imagens. O uso dessa arquitetura torna as redes convolucionais r\u00e1pidas de treinar, o que \u00e9 vantajoso para trabalhar com redes profundas. Hoje, a CNN, ou alguma variante pr\u00f3xima, \u00e9 usada na maioria dos modelos para reconhecimento de imagem. Nesse projeto foi implementado o modelo CNN de Liang e Zheng."}}