{"cell_type":{"43464dba":"code","e6da299c":"code","c476b5cd":"code","56961101":"code","761670cb":"code","cde2ae3d":"code","2fcd117a":"code","97c92c4a":"code","3140c07a":"code","0a73ce0c":"code","ec56161f":"code","d88fe554":"code","b1a345fa":"code","cbe9e3b6":"code","9f4222df":"code","267e3243":"code","77c79007":"code","cbafcfd8":"code","9cceb988":"code","04093faf":"code","ab4c4f0b":"markdown","5f3c2beb":"markdown","7abbb183":"markdown","b17460c7":"markdown","98cc8afb":"markdown","cdc7dc26":"markdown","d7eb4097":"markdown","d7ba3615":"markdown","e3a80f1a":"markdown"},"source":{"43464dba":"import pandas as pd\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import r2_score\n\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.preprocessing import OneHotEncoder\n","e6da299c":"housing = pd.read_csv('..\/input\/house-prices-advanced-regression-techniques\/train.csv')","c476b5cd":"housing.head()","56961101":"housing.info()","761670cb":"housing.duplicated().any()","cde2ae3d":"housing.drop_duplicates(inplace=True)","2fcd117a":"housing.isna().any()","97c92c4a":"list(housing.select_dtypes(include=['object']))","3140c07a":"ordinal_columns = ['ExterQual', 'ExterCond', 'BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'KitchenQual', 'FireplaceQu','GarageFinish', 'GarageQual', 'GarageCond', 'PoolQC','Fence']","0a73ce0c":"housing[ordinal_columns]","ec56161f":"housing[ordinal_columns].isna().any()","d88fe554":"def check_cols_with_missing(df):\n    nulls = df.isnull().sum()[df.isnull().any()==True]\n    df_output = pd.DataFrame({\n        \"nulls\":nulls})   \n    return df_output\n\ncheck_cols_with_missing(housing[ordinal_columns])","b1a345fa":"# This is the pandas way of filling in the missing values. However, we need to create a function to include in our Pipeline\nhousing_ordinal = housing[ordinal_columns].fillna('N_A').copy()","cbe9e3b6":"housing_ordinal","9f4222df":"# Creating the custom function\n\n# Make a function\ndef impute_categ_nulls(df):\n    df = df.fillna(\"N_A\")\n    return df\n\n# Import the FunctionTransformer\nfrom sklearn.preprocessing import FunctionTransformer\n\n# Convert the function using the FunctionTransformer\ncat_imputer = FunctionTransformer(impute_categ_nulls, validate=False)","267e3243":"housing_ordinal.columns","77c79007":"# Determine the order in which their categories should be placed (must be done manually, otherwise would be ordered arbitrarily)\nExterQual_cats = [\"Po\", \"Fa\", \"TA\", \"Gd\", \"Ex\"]\nExterCond_cats = [\"Po\", \"Fa\", \"TA\", \"Gd\", \"Ex\"]\nBsmtQual_cats = [\"N_A\", \"Po\", \"Fa\", \"TA\", \"Gd\", \"Ex\"]\nBsmtCond_cats = [\"N_A\", \"Po\", \"Fa\", \"TA\", \"Gd\", \"Ex\"]\nBsmtExposure_cats = [\"N_A\", \"No\", \"Mn\", \"Av\", \"Gd\"]\nBsmtFinType1_cats = [\"N_A\", \"Unf\", \"LwQ\", \"Rec\", \"BLQ\", \"ALQ\", \"GLQ\"]\nKitchenQual_cats =  [\"Po\", \"Fa\", \"TA\", \"Gd\", \"Ex\"]\nFireplaceQu_cats = [\"N_A\", \"Po\", \"Fa\", \"TA\", \"Gd\", \"Ex\"]\nGarageFinish_cats = [\"N_A\",\"Unf\",\"RFn\",\"Fin\"]\nGarageQual_cats   = [\"Po\", \"Fa\", \"TA\", \"Gd\", \"Ex\"]\nGarageCond_cats =  [\"Po\", \"Fa\", \"TA\", \"Gd\", \"Ex\"]\nPoolQC_cats = [\"N_A\", \"Fa\", \"TA\", \"Gd\", \"Ex\"]\nFence_cats = [\"N_A\",\"MnWw\", \"GdWo\", \"MnPrv\",\"Gdprv\"]\n\n\ncats_ord = [ExterQual_cats, ExterCond_cats, BsmtQual_cats,\n            BsmtCond_cats, BsmtExposure_cats, BsmtFinType1_cats,\n            KitchenQual_cats, FireplaceQu_cats,GarageFinish_cats,GarageQual_cats,GarageCond_cats,PoolQC_cats,Fence_cats]","cbafcfd8":"X = housing.drop(columns=\"SalePrice\")\ny = housing[\"SalePrice\"]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, train_size=.8, random_state=42)\n","9cceb988":"from sklearn.preprocessing import OrdinalEncoder\n\nnumeric_features = list(X.select_dtypes(exclude=[\"object\"]))\n\nnumeric_pipe = make_pipeline(\n    SimpleImputer(strategy=\"median\")\n)\n\ncategorical_features_ordinal = ordinal_columns\ncategorical_transformer_ordinal = OrdinalEncoder(categories=cats_ord)\ncategorical_features_onehot = list(set(list(X.select_dtypes(include=[\"object\"]))) - set(ordinal_columns))\ncategorical_transformer_onehot = OneHotEncoder(handle_unknown=\"ignore\")\n\ncategorical_preprocessor = ColumnTransformer(\n    transformers=[\n        (\"cat_ordinal\", categorical_transformer_ordinal, categorical_features_ordinal),\n        (\"cat_onehot\", categorical_transformer_onehot, categorical_features_onehot),\n    ]\n)\n\ncategorical_pipe = make_pipeline(\n    cat_imputer,\n    categorical_preprocessor\n)\n\n\ncat_num_preprocessor = ColumnTransformer(\n    transformers=[\n        (\"num\", numeric_pipe, numeric_features),\n        (\"cat_pipe\", categorical_pipe, list(X.select_dtypes(include=[\"object\"]))),\n    ]\n)\n\n\npipe = make_pipeline(\n    cat_num_preprocessor,\n    StandardScaler(),\n    KNeighborsRegressor()\n)\n\n","04093faf":"#pipe.fit(X_train, y_train)","ab4c4f0b":"Now we write out the categories we need to transform from each column","5f3c2beb":"We've been using the term categorical to describe non-numerical data up to this point. Our categorical data can be divided into two subcategories. One of these subcategories is also known as Categorical, which is a bit confusing. The other subcategory is Ordinal.\n\nCategorical variables are made up of two or more categories with no inherent order.\n* male, female, non-binary\n* German, Indian, Russian, Vietnamese\n\nOrdinal variables are similar to categorical variables, but there is a distinct order to them.\n* very bad, bad, ok, good, very good\n* high school graduate, bachelor's degree holder, master's degree holder, doctorate holder\n\nBy giving Categorical variables extra columns, OneHotEncoder ensures that there is no implied order between them. We can, however, create a numerical order with Ordinal variables (e.g., very bad = 0, bad = 1, ok = 2, good = 3, very good = 4).\n\nOneHotEncoder converts Categorical variables into extra columns. OrdinalEncoder converts Ordinal variables to numerical values.\n\nWe now need to determine which of our categorical columns are Ordinal, and which are Categorical","7abbb183":"# Including Ordinal Encoder in to our pipeline\n\nAgain we need to ColumnTransform first (as we are transforming only part of our data), then we include the ColumnTransformer in to our Pipeline (where we transform all the data as one)","b17460c7":"OrdinalEncoder can't work if there are missing values, so first we need to fill in the blanks","98cc8afb":"Missing values are a subcategory in these columns. It indicates the absence of a basement or a fireplace in the home. As a result, we'll classify these missing values using the lowest ordinal number.\n\nWe'll fill them in with an obvious placeholder first, because the OrdinalEncoder can't work if there are missing values.\n\nWhen using SKLearn to create a Pipeline, any object in the Pipeline must be able to use the fit and transform methods. FunctionTransformer is used to accomplish this. We can use FunctionTransformer to create a custom function that can fit and transform data.","cdc7dc26":"## OneHotEncoder vs OrdinalEncoder","d7eb4097":"## Implementing OrdinalEncoder","d7ba3615":"# Categorical data","e3a80f1a":"Check these columns against data_description.txt to see which of these columns are ordinal"}}