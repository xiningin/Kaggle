{"cell_type":{"1fe72fca":"code","9bf26373":"code","0955032f":"code","852f630c":"code","ff3c81bd":"code","66c39abd":"code","0b2c8411":"code","82ad331f":"code","9ff6cb29":"code","e58250ed":"code","57e35b73":"code","0104e712":"markdown","41af3670":"markdown"},"source":{"1fe72fca":"import pandas as pd \nimport numpy as np \nimport datetime as dt \nimport plotly.express as px # Visualization Operations\nimport warnings # Warnings\n\nwarnings.filterwarnings(\"ignore\") # We ignored the warnings.\npd.set_option('display.expand_frame_repr', False)\n","9bf26373":"def load_retail_data(pathname):\n    \"\"\"\n    Function created to retrieve Online Retail II datasets.\n    \n     Parameters\n     -----------\n     pathname str, optional\n         The index of the dataset.\n    \n     Returns\n     -----------\n     pd.DataFrame\n         Returned dataset by index.\n    \"\"\"\n    return pd.read_csv(pathname, sep=\";\")","0955032f":"def data_prep_for_rfm(dataframe):\n    \"\"\"\n   The function that collects data pre-processing processes specific to Online Retail for RFM\n    \n     Parameters\n     ------------\n     dataframe pd.DataFrame\n         Dataset for RFM analysis\n    \n     Returns\n     ------------\n     dataframe pd.DataFrame\n         Data set prepared for RFM\n    \n    \"\"\"\n    dataframe.dropna(inplace=True)\n    dataframe = dataframe[~(dataframe[\"Invoice\"].str.contains(\"C\"))]\n    dataframe[\"Customer ID\"] = dataframe[\"Customer ID\"].astype(int).astype(str)\n    dataframe[\"InvoiceDate\"] = pd.to_datetime(dataframe[\"InvoiceDate\"])\n    dataframe[\"TotalPrice\"] = dataframe[\"Quantity\"] * dataframe[\"Price\"]\n    return dataframe","852f630c":"\ndef create_rfm(dataframe:pd.DataFrame, dataframe_id:str, rfm_grid:dict, segment_list=False):\n    \"\"\"\n   Function that generates the table for RFM Analysis.\n    This function completes the operations in 4 steps.\n        Step 1: Creating RFM metrics\n            While creating the RFM metrics, the user determines the id value and R-F-M values to be grouped by himself.\n        Step 2: Generating RFM scores.\n            The metrics table is used when creating RFM scores. Values are divided into 5 parts according to percentages 0-20, 21-40, 41-60, 61-80 and 81-100.\n            The rank() method is used to assign a label to the first of the values between two percentiles in frequency.\n        Step 3: Creating the segments.\n            Segments were created using RegEx structure according to R and F scores.\n            Referenced source: https:\/\/guillaume-martin.github.io\/rfm-segmentation-with-python.html\n    \n    Parameters\n    -----------\n    dataframe pd.DataFrame\n        The data structure required to create the RFM table\n    dataframe_id str\n        The id column to deal with depending on the problem\n    rfm_grid dict\n        Aggregation dictionary to use depending on the problem\n    \n    Returns\n    -----------\n    rfm_table pd.DataFrame\n        Generated RFM table.\n    seg_map.values() list\n        Segment list.\n    \n    Examples\n    -----------\n    >>> ...\n    >>> analyse_date = dt.datetime(2011, 12, 11)\n    >>> agg_dict = {\"InvoiceDate\": lambda recency: (analyse_date - recency.max()).days,\n                    \"Invoice\": \"nunique\",\n                    \"TotalPrice\": \"sum\"}\n    >>> rfm = create_rfm(df, \"Customer ID\", agg_dict)\n    >>> rfm.head()\n         Customer ID  Recency  Frequency  Monetary recency_score frequency_score monetary_score RFM_SCORE       segment\n    0       12346      326          1  77183.60             1               1              5        11      hibernating\n    1       12347       40          7   4310.00             4               5              5        45  loyal_customers\n    2       12348       76          4   1797.24             3               4              4        34  loyal_customers\n    3       12349       19          1   1757.55             4               1              4        41        promising\n    4       12350      311          1    334.40             1               1              2        11      hibernating\n    \"\"\"\n    # Step 1: Creating RFM Metrics\n    df_rfm = dataframe.groupby(dataframe_id).agg(rfm_grid)\n    df_rfm.columns = [\"Recency\", \"Frequency\", \"Monetary\"]\n    df_rfm = df_rfm[df_rfm[\"Monetary\"] > 0]\n    df_rfm.reset_index(inplace=True)\n    \n    # Step 2: Generating RFM Scores\n    df_rfm[\"recency_score\"] = pd.qcut(df_rfm['Recency'], 5, labels=[5, 4, 3, 2, 1])\n    df_rfm[\"frequency_score\"] = pd.qcut(df_rfm['Frequency'].rank(method=\"first\"), 5, labels=[1, 2, 3, 4, 5])\n    df_rfm[\"monetary_score\"] = pd.qcut(df_rfm['Monetary'], 5, labels=[1, 2, 3, 4, 5])\n    \n    # Step 3: Creating the segments\n    df_rfm[\"RFM_SCORE\"] = (df_rfm['recency_score'].astype(str) + df_rfm['frequency_score'].astype(str))\n    seg_map = {\n    r'[1-2][1-2]': 'hibernating',\n    r'[1-2][3-4]': 'at_risk',\n    r'[1-2]5': 'cant_loose',\n    r'3[1-2]': 'about_to_sleep',\n    r'33': 'need_attention',\n    r'[3-4][4-5]': 'loyal_customers',\n    r'41': 'promising',\n    r'51': 'new_customers',\n    r'[4-5][2-3]': 'potential_loyalists',\n    r'5[4-5]': 'champions'\n    }\n    df_rfm['segment'] = df_rfm['RFM_SCORE'].replace(seg_map, regex=True)\n    \n    \n    # Step 4: Return the RFM dataframe\n    if segment_list:        \n        return df_rfm, seg_map.values() \n    return df_rfm","ff3c81bd":"online_retail_2009_2010_df = load_retail_data(\"..\/input\/online-retail-ii-uci-two-peroid\/online_retail_II_2009_2010.csv\")\nonline_retail_2010_2011_df = load_retail_data(\"..\/input\/online-retail-ii-uci-two-peroid\/online_retail_II_2010_2011.csv\")","66c39abd":"online_retail_2009_2010_df = data_prep_for_rfm(online_retail_2009_2010_df)\nonline_retail_2010_2011_df = data_prep_for_rfm(online_retail_2010_2011_df)","0b2c8411":"online_retail_2009_2010_df['InvoiceDate'].max() ## 2010-12-09\nanalyse_date_2010 = online_retail_2009_2010_df['InvoiceDate'].max() + pd.DateOffset(days=2)\n","82ad331f":"agg_dict_2010 = {\"InvoiceDate\": lambda recency: (analyse_date_2010 - recency.max()).days,\n                 \"Invoice\": \"nunique\",\n                 \"TotalPrice\": \"sum\"}\nrfm_2009_2010 = create_rfm(online_retail_2009_2010_df, \"Customer ID\", agg_dict_2010)\nrfm_2009_2010[\"period\"] = \"2009_2010\"","9ff6cb29":"online_retail_2010_2011_df['InvoiceDate'].max() ## 2011-12-09\nanalyse_date_2011 = online_retail_2010_2011_df['InvoiceDate'].max() + pd.DateOffset(days=2)\n","e58250ed":"agg_dict_2011 = {\"InvoiceDate\": lambda recency: (analyse_date_2011 - recency.max()).days,\n                 \"Invoice\": \"nunique\",\n                 \"TotalPrice\": \"sum\"}\nrfm_2010_2011 = create_rfm(online_retail_2010_2011_df, \"Customer ID\", agg_dict_2011)\nrfm_2010_2011[\"period\"] = \"2010_2011\"\n","57e35b73":"temp_df = pd.concat([rfm_2009_2010[[\"segment\", \"period\"]], rfm_2010_2011[[\"segment\", \"period\"]]], ignore_index=True)\nfig = px.treemap(temp_df, path=[\"segment\", \"period\"], title=\"RFM Segments 2009-2010 vs. 2010-2011\")\nfig.show()\n","0104e712":"# let data be your best friend :D","41af3670":"## With Rfm, you can compare your company's 2-year customer segmentation transitions, see your strengths and weaknesses, and take action. You can easily take more different actions.\n\n"}}