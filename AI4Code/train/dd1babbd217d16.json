{"cell_type":{"ecf9f71c":"code","15876959":"code","81423cb9":"code","7f286210":"code","9e2b0ece":"code","a38b4fe3":"code","b7138f1d":"code","a000cce2":"code","ba1f0d68":"code","fdfbf62a":"code","80c8a4e4":"code","179a48c7":"code","eb41dc4c":"code","7d6c0302":"code","bb5548cd":"code","15f8ab60":"code","a6be66e3":"code","18287f04":"code","c7880b12":"code","08ab5727":"code","b14e88a9":"code","232b7237":"code","34d76111":"code","1a758150":"code","e227a3dd":"code","7a97eb99":"code","0febdc43":"code","b7bba852":"code","f752bb6a":"code","5e5bf97c":"code","458eb5d6":"code","dcb23891":"code","16c93abd":"code","856c3433":"code","6d512790":"code","31bd8534":"code","0fd7d66e":"markdown","1af36dc3":"markdown","8bdf6808":"markdown","9fc9be8a":"markdown","ede2247a":"markdown","4395a99c":"markdown","6b5a9953":"markdown","0837aacc":"markdown","5aac7ead":"markdown","5cec28d3":"markdown","50bb9319":"markdown","ed4fbd5a":"markdown","bf0f735a":"markdown","6ee9f83b":"markdown","2b44e46e":"markdown","8001e5cd":"markdown","7ef5def5":"markdown","102167c9":"markdown","de608465":"markdown","ba3dae40":"markdown","e2a62ce9":"markdown","3c1d6e9f":"markdown","5a03d44e":"markdown","dcf05957":"markdown","49d87397":"markdown","8a1d8abf":"markdown","acda8f4f":"markdown","21614049":"markdown","eb07a093":"markdown","60c05e75":"markdown","6d15b1ad":"markdown","2aec1efb":"markdown","05ba7ef2":"markdown","f0976330":"markdown","d0a660f3":"markdown","b21858cc":"markdown"},"source":{"ecf9f71c":"# Importing libraries and \nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\n# importing data\ndf = pd.read_csv(\"..\/input\/scripts.csv\")\ndel df[\"Unnamed: 0\"]\n\ndf.head()","15876959":"dial_df = df.drop([\"EpisodeNo\",\"SEID\",\"Season\"],axis=1)\ndial_df.head()","81423cb9":"dial_df[\"Character\"].value_counts().head(12).plot(kind=\"bar\")","7f286210":"def corpus_creator(name):\n    st = \"\" \n    for i in dial_df[\"Dialogue\"][dial_df[\"Character\"]==name]:\n        st = st + i\n    return st\n\ncorpus_df = pd.DataFrame()\ncorpus_df[\"Character\"] = list(dial_df[\"Character\"].value_counts().head(12).index)\n\nli = []\nfor i in corpus_df[\"Character\"]:\n    li.append(corpus_creator(i))\n\ncorpus_df[\"Dialogues\"] = li\n\ncorpus_df","9e2b0ece":"from sklearn.feature_extraction import text\npunc = ['.', ',', '\"', \"'\", '?', '!', ':', ';', '(', ')', '[', ']', '{', '}',\"%\"]\nstop_words = text.ENGLISH_STOP_WORDS.union(punc)","a38b4fe3":"from nltk.tokenize import word_tokenize\ndef text_processor(dialogue):\n    dialogue = word_tokenize(dialogue)\n    nopunc=[word.lower() for word in dialogue if word not in stop_words]\n    nopunc=' '.join(nopunc)\n    return [word for word in nopunc.split()]","b7138f1d":"corpus_df[\"Dialogues\"] = corpus_df[\"Dialogues\"].apply(lambda x: text_processor(x))\ncorpus_df","a000cce2":"corpus_df[\"Length\"] = corpus_df[\"Dialogues\"].apply(lambda x: len(x))\ncorpus_df","ba1f0d68":"fig, ax = plt.subplots(figsize=(10,10))\nsns.barplot(ax=ax,y=\"Length\",x=\"Character\",data=corpus_df)","fdfbf62a":"import gensim\n# Creating a dictionary for mapping every word to a number\ndictionary = gensim.corpora.Dictionary(corpus_df[\"Dialogues\"])\nprint(dictionary[567])\nprint(dictionary.token2id['cereal'])\nprint(\"Number of words in dictionary: \",len(dictionary))\n\n# Now, we create a corpus which is a list of bags of words. A bag-of-words representation for a document just lists the number of times each word occurs in the document.\ncorpus = [dictionary.doc2bow(bw) for bw in corpus_df[\"Dialogues\"]]\n\n# Now, we use tf-idf model on our corpus\ntf_idf = gensim.models.TfidfModel(corpus)\n\n# Creating a Similarity objectr\nsims = gensim.similarities.Similarity('',tf_idf[corpus],num_features=len(dictionary))\n\n# Creating a dataframe out of similarities\nsim_list = []\nfor i in range(12):\n    query = dictionary.doc2bow(corpus_df[\"Dialogues\"][i])\n    query_tf_idf = tf_idf[query]\n    sim_list.append(sims[query_tf_idf])\n    \ncorr_df = pd.DataFrame()\nj=0\nfor i in corpus_df[\"Character\"]:\n    corr_df[i] = sim_list[j]\n    j = j + 1   ","80c8a4e4":"fig, ax = plt.subplots(figsize=(12,12))\nsns.heatmap(corr_df,ax=ax,annot=True)\nax.set_yticklabels(corpus_df.Character)\nplt.savefig('similarity.png')\nplt.show()","179a48c7":"dial_df = dial_df[(dial_df[\"Character\"]==\"ELAINE\") | (dial_df[\"Character\"]==\"GEORGE\") | (dial_df[\"Character\"]==\"KRAMER\")]\ndial_df.head(8)","eb41dc4c":"def text_process(dialogue):\n    nopunc=[word.lower() for word in dialogue if word not in stop_words]\n    nopunc=''.join(nopunc)\n    return [word for word in nopunc.split()]","7d6c0302":"X = dial_df[\"Dialogue\"]\ny = dial_df[\"Character\"]","bb5548cd":"from sklearn.feature_extraction.text import TfidfVectorizer\nvectorizer = TfidfVectorizer(analyzer=text_process).fit(X)","15f8ab60":"print(len(vectorizer.vocabulary_))\nX = vectorizer.transform(X)\n","a6be66e3":"# Splitting the data into train and test set\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=101)","18287f04":"from sklearn.naive_bayes import MultinomialNB as MNB\nfrom sklearn.linear_model import LogisticRegression as LR\nfrom sklearn.ensemble import RandomForestClassifier as RFC\nfrom sklearn.ensemble import VotingClassifier as VC\nmnb = MNB(alpha=10)\nlr = LR(random_state=101)\nrfc = RFC(n_estimators=80, criterion=\"entropy\", random_state=42, n_jobs=-1)\nclf = VC(estimators=[('mnb', mnb), ('lr', lr), ('rfc', rfc)], voting='hard')","c7880b12":"# Fitting and predicting\nclf.fit(X_train,y_train)\n\npredict = clf.predict(X_test)","08ab5727":"# Classification report\nfrom sklearn.metrics import confusion_matrix, classification_report\nprint(confusion_matrix(y_test, predict))\nprint('\\n')\nprint(classification_report(y_test, predict))","b14e88a9":"def predictor(s):\n    s = vectorizer.transform(s)\n    pre = clf.predict(s)\n    print(pre)","232b7237":"# Answer should be Kramer\npredictor(['I\\'m on the Mexican, whoa oh oh, radio.'])","34d76111":"# Answer should be Elaine\npredictor(['Do you have any idea how much time I waste in this apartment?'])","1a758150":"# Answer should be George \npredictor(['Yeah. I figured since I was lying about my income for a couple of years, I could afford a fake house in the Hamptons.'])","e227a3dd":"# Now, a random sentence\npredictor(['Jerry, I\\'m gonna go join the circus.'])","7a97eb99":"# A random sentence\npredictor(['I wish we can find some way to move past this.'])","0febdc43":"# Answer should be Kramer\npredictor(['You\u2019re becoming one of the glitterati.'])","b7bba852":"# Answer should be Elaine\npredictor(['Jerry, we have to have sex to save the friendship.'])","f752bb6a":"import keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Activation, Dropout\nfrom keras.preprocessing.text import Tokenizer","5e5bf97c":"# Encoding categorical data using label encoding and one-hot encoding \nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder\nlabelencoder_X_1 = LabelEncoder()\ny = labelencoder_X_1.fit_transform(y)\ny = y.reshape(-1,1)\nonehotencoder = OneHotEncoder(categorical_features = [0])\ny = onehotencoder.fit_transform(y).toarray()\n# This would transform the dependent variable into a 3-column matrix, first for Elaine, second for George and third for Kramer ","458eb5d6":"y = np.delete(y,2,1).astype(int)","dcb23891":"# Splitting the data again into train and test set\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=101)","16c93abd":"max_words = 14178\nnum_classes = 2\n\nmodel = Sequential()\nmodel.add(Dense(512, input_shape=(max_words,)))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(256, input_shape=(max_words,)))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(128, input_shape=(max_words,)))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(num_classes))\nmodel.add(Activation('softmax'))","856c3433":"model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])","6d512790":"model.fit(X_train, y_train, epochs=60, batch_size=256)","31bd8534":"model.fit(X_test, y_test, epochs=60, batch_size=256)","0fd7d66e":"See, this \"george effect\" can lead to awkward results. That's why I am trying to find a way to get rid of that high recall value and also improve the precision of classifier. ","1af36dc3":"Fitting and predicting the model","8bdf6808":"# What have I done here?\nI have tried to create a classifier to predict the name of the speaker of a given dialogue. I have used the scripts database for this purpose. So, if a line is given to the predictor, it returns the person who said or might say that line.","9fc9be8a":"# This would delete the 3rd column of the matrix to prevent the dummy variable trap\n[Click here](https:\/\/www.quora.com\/When-do-I-fall-in-the-dummy-variable-trap) to know more about **Dummy Variable trap** ","ede2247a":"# TF-IDF Vectorizer\nConvert a collection of raw documents to a matrix of TF-IDF features. Equivalent to CountVectorizer followed by TfidfTransformer.\n\nIn information retrieval, tf\u2013idf or TFIDF, short for term frequency\u2013inverse document frequency, is a numerical statistic that is intended to reflect how important a word is to a document in a collection or corpus. It is often used as a weighting factor in searches of information retrieval, text mining, and user modeling. The tf-idf value increases proportionally to the number of times a word appears in the document and is offset by the frequency of the word in the corpus, which helps to adjust for the fact that some words appear more frequently in general. Nowadays, tf-idf is one of the most popular term-weighting schemes; 83% of text-based recommender systems in the domain of digital libraries use tf-idf.\n","4395a99c":"# Creating a voting classifier with Multinomial Naive Bayes, logistic regression and random forest classifier\nThe EnsembleVoteClassifier is a meta-classifier for combining similar or conceptually different machine learning classifiers for classification via majority or plurality voting.\n\nThe EnsembleVoteClassifier implements \"hard\" and \"soft\" voting. In hard voting, we predict the final class label as the class label that has been predicted most frequently by the classification models. In soft voting, we predict the class labels by averaging the class-probabilities (only recommended if the classifiers are well-calibrated).","6b5a9953":"Compiling the model.","0837aacc":"**This was a basic ANN approach which has shown great improvement over a simple voted classifier.**","5aac7ead":"For creating a corpus out of the data, we will create a datframe concatenating all dialogues of a character. We are choosing 12 characters(by number of dialogues) ","5cec28d3":"# Now, we predict...","50bb9319":"Now, we create a text_processor function to tokenize concatenated dialogues and removing stop words","ed4fbd5a":"Way too many dialogues by george will certainly affect the classifier.","bf0f735a":"# Preparation for classifier","6ee9f83b":"Now, we do some **correlation analysis**  to find out how similar are the dialogues of different characters to each other.\n(For this, we will use a library called **gensim**. Next cell is the most important yet.)","2b44e46e":"On a side note, this new GPU feature is very helpful. Thanks, Team Kaggle!","8001e5cd":"So we get about 51% precision which is not bad considering the limited vocablury. George is dominant here due to high recall value of 0.80. So, unless a dialogue has words that don't exist at all in George's vocablury, there is a high chance George will the speaker of most lines. The situation was worse when Jerry was inclued. **This is why I decided to drop Jerry's dialogues from the dataset.** ","7ef5def5":"Obviously, Jerry speaks the most followed by George, Elaine and Kramer","102167c9":"This plot can actually depict how different the characters are from each other. Like **Jerry, George, Elaine and Kramer** speak highly similar lines. Maybe, that's why they are friends(This might have happened because they are usually talking to each other and also because their dialogues are mumore than others). **[Setting] has lowest correlation scores** well because it is the odd one out because it is not a person. **Jerry and George have highly similar dialogues with 81%  correlation.**","de608465":"# Time to use keras for this purpose (Simple ANN approach)","ba3dae40":"Now, we don't really require the EpisodeNo, SEID and Season columns so we remove them.","e2a62ce9":"# Plot by number of dialogues spoken","3c1d6e9f":"# Heatmap to detect similarity between characters' dialogues","5a03d44e":"# About the dataset\nThis dataset is about the show about \"nothing\". Yeah, you guessed it right. I am talking about Seinfeld, one of the greatest sitcoms of all time. This dataset provides episodic analysis of the series including the entire script and significant amount of information about each episode.","dcf05957":"Time for some EDA","49d87397":"Now, we apply this method","8a1d8abf":"# The Predictor","acda8f4f":"First, we import libraries.","21614049":"# Who has spoken the most in Seinfeld?","eb07a093":"I have used Keras which is a high-level Neural Networks API built on top of low level neural networks APIs like Tensorflow and Theano. As it is high-level, many things are already taken care of therefore it is easy to work with and a great tool to start with. [Here's the documentation for keras](https:\/\/keras.io\/).\n\nI have explained the working of keras for beginners in this kernel. [Click here.](https:\/\/www.kaggle.com\/thebrownviking20\/intro-to-keras-with-breast-cancer-data)\n\n**Refer to this kernel to learn in detail about the basic approach for a classification model using keras.** That kernel is based on numerical data and this one is based on textual data so there are bound to be some differences in both approaches.(If anything, this model requires more layers) ","60c05e75":"# Preparing stopwords(words that are obsolete for NLP or words that hinder modelling). Very helpful in human speech but useless when trained for modelling","6d15b1ad":"# A text processor for processing dialogues","2aec1efb":"# So the test set accuracy is 84.17% which is even better than training set.","05ba7ef2":"# So the training set accuracy is 83% which is much better than the Voted Classifier we prepared previously.","f0976330":"# An awesome way to use classification\nI am predicting the dialogues said by Elaine, George and Kramer only, so we will choose only their dialogues(I wanted to include Jerry, I mean what is Seinfeld without Jerry Seinfeld but I will later tell you why I didn't do that. Look for clues in markdown)","d0a660f3":"Adding a length column to the new dataframe which contains length of the concatenated dialogues","b21858cc":"Creating the model."}}