{"cell_type":{"9de9e615":"code","20424311":"code","24d15220":"code","a241a656":"code","35ee2b0a":"code","12328f7f":"code","86ce118d":"code","f35add18":"code","e7df544e":"code","d4306159":"code","28ed903f":"code","07326c84":"code","7cd62bf8":"code","3c68614d":"code","5353535e":"code","03adb47c":"code","9e54fd39":"code","b708f79f":"code","01414343":"code","bdecd8dc":"code","c6710567":"code","134f1830":"code","04b1717e":"code","3499e262":"code","a8b07bec":"code","851dd1d6":"code","b4fe241b":"code","090f8e02":"code","3c8339c2":"code","8811376d":"code","d229fe0e":"code","9c0819c5":"code","2e794c7f":"code","14964f6c":"code","5855577a":"code","07f3e69e":"code","198ddf83":"markdown","9cfe4264":"markdown","d73b99ae":"markdown","5b71c80d":"markdown","46b8803b":"markdown","ad3fe8de":"markdown","95ca3ded":"markdown","52428534":"markdown","c5db8128":"markdown","54f551f8":"markdown","d66b09a6":"markdown","662af2a5":"markdown","e90512aa":"markdown","3651dfa5":"markdown","e0774919":"markdown","4ae6911c":"markdown","146afd9c":"markdown","44559e66":"markdown","58a0d2be":"markdown","ecfea3fb":"markdown","507cea47":"markdown","e67d3db7":"markdown","0f266a19":"markdown","17262db8":"markdown","8b8831ff":"markdown","a697c301":"markdown"},"source":{"9de9e615":"from keras.datasets import fashion_mnist, mnist\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom keras.layers import Input, Dense, Conv2D, MaxPooling2D, UpSampling2D, Dropout\nfrom keras.models import Model\n\nimport os,cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 20, 10\n\nfrom sklearn.utils import shuffle\nfrom sklearn.model_selection import train_test_split\nimport pandas as pd# Any results you write to the current directory are saved as output.\nfrom IPython.display import display, Image\n\nfrom keras.preprocessing.image import load_img\nfrom keras import Model\nfrom keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau\nfrom keras.models import load_model\nfrom keras.optimizers import Adam\nfrom keras.utils.vis_utils import plot_model\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.layers import Input, Conv2D, Conv2DTranspose, MaxPooling2D, concatenate, Dropout\n\n# Any results you write to the current directory are saved as output.\nfrom IPython.display import display, Image","20424311":"# get the data\nfilname = '..\/input\/facial-expression\/fer2013\/fer2013.csv'\n\n#different labels of images(not useful known about for current problem)\nlabel_map = ['Anger', 'Disgust', 'Fear', 'Happy', 'Sad', 'Surprise', 'Neutral']\n\n#different features names\nnames=['emotion','pixels','usage']\n\n#Reading data in dataframe\ndf=pd.read_csv('..\/input\/facial-expression\/fer2013\/fer2013.csv',names=names, na_filter=False)\nim=df['pixels']\ndf.head(10)","24d15220":"#reading data and labels from dataset and appending in list\n\ndef getData(filname):\n    # images are 48x48\n    # N = 35887\n    Y = []\n    X = []\n    first = True\n    for line in open(filname):\n        if first:\n            first = False\n        else:\n            row = line.split(',')\n            Y.append(int(row[0]))\n            X.append([int(p) for p in row[1].split()])\n\n    X, Y = np.array(X), np.array(Y)\n    return X, Y","a241a656":"#extracting data from dataset\nX, Y = getData(filname)\nnum_class = len(set(Y))\n#print(num_class)","35ee2b0a":"# keras with tensorflow backend\nN, D = X.shape\n\n#reshaping the dataset\nX = X.reshape(N, 48, 48, 1)","12328f7f":"#splitting data in train, test\nx_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, random_state=42, shuffle=True)","86ce118d":"x_train.shape","f35add18":"#NOrmalizing the images\nx_train = x_train.astype('float32') \/ 255.\nx_test = x_test.astype('float32') \/ 255.\n\n#reshaping the images\nx_train = np.reshape(x_train, (len(x_train), 48, 48, 1))  # adapt this if using `channels_first` image data format\nx_test = np.reshape(x_test, (len(x_test), 48, 48, 1))  # adapt this if using `channels_first` image data format\n\n\n#adding noise in data\nnoise_factor = 0.1\nx_train_noisy = x_train + noise_factor * np.random.normal(loc=0.0, scale=1.0, size=x_train.shape) \nx_test_noisy = x_test + noise_factor * np.random.normal(loc=0.0, scale=1.0, size=x_test.shape) \n\n#clipping put data near to 0--->0 aand data near to 1-->1(eg=0.3-->0 or 0.7-->1)\nx_train_noisy = np.clip(x_train_noisy, 0., 1.)\nx_test_noisy = np.clip(x_test_noisy, 0., 1.)","e7df544e":"x_test_final_noisy = x_test_noisy[-100:]\nx_test_noisy = x_test_noisy[:-100]\n\nx_test_final_original = x_test[-100:]\nx_test = x_test[:-100]","d4306159":"n = 10","28ed903f":"plt.figure(figsize=(48, 48))\nfor i in range(n):\n    ax = plt.subplot(1, n, i+1)\n    plt.imshow(x_train_noisy[i].reshape(48, 48))\n    plt.gray()\n    ax.get_xaxis().set_visible(False)\n    ax.get_yaxis().set_visible(False)\nplt.show()","07326c84":"display(Image(filename=\"\/kaggle\/input\/images-architecture\/images_architecture\/autoencoder.png\"))","7cd62bf8":"input_img = Input(shape=(48, 48, 1))  # adapt this if using `channels_first` image data format\n\nx = Conv2D(32, (3, 3), activation='relu', padding='same')(input_img)\nx = MaxPooling2D((2, 2), padding='same')(x)\nx = Dropout(0.2)(x)\nx = Conv2D(32, (3, 3), activation='relu', padding='same')(x)\nencoded = MaxPooling2D((2, 2), padding='same')(x)\n\n\n# at this point the representation is (7, 7, 32)\n\nx = Conv2D(32, (3, 3), activation='relu', padding='same')(encoded)\nx = UpSampling2D((2, 2))(x)\nx = Dropout(0.2)(x)\nx = Conv2D(32, (3, 3), activation='relu', padding='same')(x)\nx = UpSampling2D((2, 2))(x)\n\ndecoded = Conv2D(1, (3, 3), activation='sigmoid', padding='same')(x)\n\nautoencoder = Model(input_img, decoded)\nautoencoder.compile(optimizer='adam', loss='MSE')","3c68614d":"autoencoder.summary()","5353535e":"autoencoder.fit(x_train_noisy, x_train,\n                epochs=35,\n                batch_size=64,\n                shuffle=True,\n                validation_data=(x_test_noisy, x_test))","03adb47c":"predict = autoencoder.predict(x_test_final_noisy)","9e54fd39":"n=3","b708f79f":"plt.figure(figsize=(40, 48))\nfor i in range(n):\n    ax = plt.subplot(1, n, i+1)\n    plt.imshow(x_test_final_original[i].reshape(48, 48))\n    plt.gray()\n    ax.get_xaxis().set_visible(False)\n    ax.get_yaxis().set_visible(False)\nplt.show()","01414343":"plt.figure(figsize=(40, 48))\nfor i in range(n):\n    ax = plt.subplot(1, n, i+1)\n    plt.imshow(x_test_final_noisy[i].reshape(48, 48))\n    plt.gray()\n    ax.get_xaxis().set_visible(False)\n    ax.get_yaxis().set_visible(False)\nplt.show()","bdecd8dc":"plt.figure(figsize=(40, 48))\nfor i in range(n):\n    ax = plt.subplot(1, n, i+1)\n    plt.imshow(predict[i].reshape(48, 48))\n    plt.gray()\n    ax.get_xaxis().set_visible(False)\n    ax.get_yaxis().set_visible(False)\nplt.show()","c6710567":"autoencoder.history.history","134f1830":"epochs = range(len(autoencoder.history.history['loss']))\n\nplt.plot(epochs,autoencoder.history.history['loss'],'r-o', label='Training Loss')\nplt.title('Training Loss')\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.legend()\nplt.figure()\n\n","04b1717e":"epochs = range(len(autoencoder.history.history['loss']))\n\nplt.plot(epochs,autoencoder.history.history['loss'],'r-o', label='Training Loss')\nplt.plot(epochs,autoencoder.history.history['val_loss'],'b-o', label='Validation Loss')\nplt.title('Training Loss vs Validation Loss')\nplt.xlabel('Epoch')\nplt.ylabel('Loss')\nplt.legend()\nplt.figure()\n\n","3499e262":"from skimage.measure import compare_ssim, compare_psnr, compare_mse\nfrom skimage import data, img_as_float","a8b07bec":"# First Image\ncompare_mse(x_test_final_original[0], predict[0])","851dd1d6":"# Second Image\ncompare_mse(x_test_final_original[1], predict[1])","b4fe241b":"# Third Image\ncompare_mse(x_test_final_original[2], predict[2])","090f8e02":"# whole dataset\ncompare_mse(x_test_final_original, predict)","3c8339c2":"#First Image\ncompare_ssim(x_test_final_original[0], predict[0], multichannel=True)","8811376d":"#Second Image\ncompare_ssim(x_test_final_original[1], predict[1], multichannel=True)","d229fe0e":"#Third Image\ncompare_ssim(x_test_final_original[2], predict[2], multichannel=True)","9c0819c5":"# whole test dataset\ncompare_ssim(x_test_final_original, predict, multichannel=True)","2e794c7f":"#First image\ncompare_psnr(x_test_final_original[0], predict[0])","14964f6c":"#Second image\ncompare_psnr(x_test_final_original[1], predict[1])","5855577a":"#third image\ncompare_psnr(x_test_final_original[2], predict[2])","07f3e69e":"#whole final dataset\ncompare_psnr(x_test_final_original, predict)","198ddf83":"# Visualization of 10 Data","9cfe4264":"## Original Test images","d73b99ae":"## Extract data from CSV","5b71c80d":"## Adding labels and images(pixel values) in respective array","46b8803b":"# For Whole final_test Dataset","ad3fe8de":"## Making Prediction","95ca3ded":"## Noised Test images","52428534":"# Structural Similarity Index\n\n* When comparing images, the mean squared error (MSE)--while simple to implement--is not highly indicative of perceived similarity. Structural similarity aims to address this shortcoming by taking texture into account\n\n","c5db8128":"* Image denoising is to remove noise from a noisy image, so as to restore the true image\n* In this notebook FER2013 dataset is used which contains approx 35 thousand images of 7 different emotions\n* Image is grayscale of size 48*48","54f551f8":"# Extracting Data and splitting train and test ","d66b09a6":"## Reshaping images","662af2a5":"# Importing libraries","e90512aa":"# One of the way we can achieve our goal of removing noise is AutoEncoder\n\n**Copied from Keras Blog(https:\/\/blog.keras.io\/building-autoencoders-in-keras.html):\n**\n* What are autoencoders good for?\n* Today two interesting practical applications of autoencoders are data denoising (which we feature later in this post), and dimensionality reduction for data visualization. With appropriate dimensionality and sparsity constraints, autoencoders can learn data projections that are more interesting than PCA or other basic techniques.","3651dfa5":"# noise factor: 0.1","e0774919":"# AutoEncoder: Train Loss VS validation loss","4ae6911c":"# MSE between Images\n\n* Compare MSE between two images","146afd9c":"## AutoEncoder Architecture","44559e66":"## Generated Test images","58a0d2be":"# AutoEncoder Summary","ecfea3fb":"**Refer to Keras Blog for better idea : https:\/\/blog.keras.io\/building-autoencoders-in-keras.html**","507cea47":"# Training Model","e67d3db7":"# Taking 100 images seperate for final testing","0f266a19":"# Visualizing the prediction","17262db8":"# Construction of Model","8b8831ff":"# PSNR\n\nSource: https:\/\/www.mathworks.com\/help\/vision\/ref\/psnr.html\n\n* The PSNR block computes the peak signal-to-noise ratio, in decibels, between two images. This ratio is used as a quality measurement between the original and a compressed image. The higher the PSNR, the better the quality of the compressed, or reconstructed image.\n\n* The mean-square error (MSE) and the peak signal-to-noise ratio (PSNR) are used to compare image compression quality. The MSE represents the cumulative squared error between the compressed and the original image, whereas PSNR represents a measure of the peak error. The lower the value of MSE, the lower the error.","a697c301":"# Data Preprocessing"}}