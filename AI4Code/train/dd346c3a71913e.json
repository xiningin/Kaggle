{"cell_type":{"63281527":"code","c9556a21":"code","5d4803c6":"code","7904fa49":"code","85f0788e":"code","736afcda":"code","fb78144f":"code","e4557281":"code","f1c2f662":"code","b443e96b":"code","ac676e66":"code","ad927cfa":"code","c4a649e4":"code","4c28f267":"code","4b2a3b59":"code","c38f85f1":"code","3faee675":"code","afe78a58":"code","98aacb36":"code","f4193724":"code","fce903c2":"code","e4454105":"code","08a26725":"markdown","a127ba00":"markdown","03c76ad8":"markdown","c63d9708":"markdown","399941b1":"markdown"},"source":{"63281527":"#import libraries\nimport os\nimport zipfile\nimport glob\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib.cm as cm\nimport keras\nimport cv2\n%matplotlib inline\n\n#import K-Means\nfrom sklearn.cluster import KMeans\n# important metrics\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import confusion_matrix","c9556a21":"np.random.seed(42)","5d4803c6":"zip_files = glob.glob('\/kaggle\/input\/dogs-vs-cats\/*.zip')\n\nprint('{} files found in the input directory'.format(str(len(zip_files))) +'\\n')\nfor file in zip_files:\n    with zipfile.ZipFile(file, 'r') as Z:\n        Z.extractall('data')\n    print ('{} is extracted'.format(file.split('\/')[-1]) + '\\n')\n      \nprint('Extraction is completed' + '\\n')","7904fa49":"# os.listdir(\".\/data\/train\")","85f0788e":"data = []\nlabel = []\npath = \".\/data\/train\/\"\nc = 0\nd = 0\nIMG_SIZE = 32\n\nfor file in os.listdir(path):\n    img=cv2.imread(path+file)\n    img=cv2.resize(img,(IMG_SIZE,IMG_SIZE))\n    img=img.astype('float32')\n    \n    if file[:3]=='cat':\n        if c==200: continue\n        c+=1\n        label.append(\"cat\")\n    else:\n        if d==200: continue\n        d+=1\n        label.append(\"dog\")\n    \n    data.append(img)\ndata = np.array(data)","736afcda":"# converting label cat to 0 and dog to 1\ndata_label = []\nfor i in label:\n    if i==\"cat\": data_label.append(0)\n    else: data_label.append(1)\ndata_label = np.array(data_label)","fb78144f":"# Data Normalization\n\n# Normalization\ndata = data\/255.0\n    \n# k-means accept data with less than 3 dimensions\nreshaped_data = data.reshape(len(data),-1)\nreshaped_data.shape","e4557281":"# Applying K-Means Clustering\nkmeans = KMeans(n_clusters=2, random_state=0)\nclusters = kmeans.fit_predict(reshaped_data)\nkmeans.cluster_centers_.shape","f1c2f662":"# This is how our centroids look like\nkmeans.cluster_centers_ = kmeans.cluster_centers_*255\nplt.figure(figsize = (10,9))\nbottom = 0.35\nfor i in range(2):\n    plt.subplots_adjust(bottom)\n    plt.subplot(4,4,i+1)\n    plt.imshow(kmeans.cluster_centers_[i].astype(int).reshape(32,32,3))","b443e96b":"# Scatter Plot for both the centroids\nx_data = [i for i in range(3072)]\nplt.scatter(x_data,kmeans.cluster_centers_[0], color = 'red',alpha=0.2,s=70)\nplt.scatter(x_data,kmeans.cluster_centers_[1] , color = 'blue',alpha=0.2,s=50)","ac676e66":"# Since K-Means Does not know about our labels we have to change labels of k-means according to our usage\n\n# mapping labels from cluster to original labels\ndef get_reference_dict(clusters,data_label):\n    reference_label = {}\n    # For loop to run through each label of cluster label\n    for i in range(len(np.unique(clusters))):\n        index = np.where(clusters == i,1,0)\n        num = np.bincount(data_label[index==1]).argmax()\n        reference_label[i] = num\n    return reference_label\n\n# Mapping predictions to original labels\ndef get_labels(clusters,refernce_labels):\n    temp_labels = np.random.rand(len(clusters))\n    for i in range(len(clusters)):\n        temp_labels[i] = reference_labels[clusters[i]]\n    return temp_labels","ad927cfa":"reference_labels = get_reference_dict(clusters,data_label)\npredicted_labels = get_labels(clusters,reference_labels)","c4a649e4":"# Accuracy Score for right predictions\nprint(accuracy_score(predicted_labels,data_label))","4c28f267":"mat = confusion_matrix(data_label,predicted_labels)\nsns.heatmap(mat, annot=True)\nplt.ylabel('true label')\nplt.xlabel('predicted label')","4b2a3b59":"# elbow method\n# squared distance\nsse = []\nlist_k = [2,16,64,100,256]\n\nfor k in list_k:\n    km = KMeans(n_clusters=k)\n    clusters = km.fit_predict(reshaped_data)\n    sse.append(km.inertia_)\n    \n    reference_labels = get_reference_dict(clusters,data_label)\n    predicted_labels = get_labels(clusters,reference_labels)\n    \n    print(f\"Accuracy for k = {k}: \", accuracy_score(predicted_labels,data_label))\n\n# Plot sse against k\nplt.figure(figsize=(6, 6))\nplt.plot(list_k, sse, '-o')\nplt.xlabel(r'Number of clusters *k*')\nplt.ylabel('Sum of squared distance');","c38f85f1":"# Libraries\nfrom keras.applications.resnet50 import preprocess_input\nfrom keras.preprocessing import image","3faee675":"# Extract features from resnet50\ndef extract_vector(data_holder):\n    resnet_feature_list = []\n\n    for im in data_holder:\n        im = image.img_to_array(im) \n#         print(\"dimensions of im: \", im.shape)\n        img = preprocess_input(np.expand_dims(im.copy(), axis=0))\n#         print(\"dimensions of img: \", img.shape)\n        resnet_feature = model.predict(img)\n        resnet_feature_np = np.array(resnet_feature)\n#         print(\"dimensions of resnet_feature_np: \", resnet_feature_np.shape)\n        resnet_feature_list.append(resnet_feature_np.flatten())\n\n    return np.array(resnet_feature_list)","afe78a58":"# IMG_SIZE = 32\nmodel =   keras.applications.ResNet50(weights='imagenet', include_top=False, input_shape=(IMG_SIZE, IMG_SIZE,3))","98aacb36":"# Extract vectors and apply kmeans\narray = extract_vector(data)\nkmeans = KMeans(n_clusters=2, random_state=0)\nclusters = kmeans.fit_predict(array)","f4193724":"reference_labels = get_reference_dict(clusters,data_label)\npredicted_labels = get_labels(clusters,reference_labels)","fce903c2":"from sklearn.metrics import accuracy_score\nprint(accuracy_score(predicted_labels,data_label))","e4454105":"mat = confusion_matrix(data_label,predicted_labels )\nsns.heatmap(mat, annot=True)\nplt.ylabel('true label')\nplt.xlabel('predicted label')","08a26725":"Output <br>\ndimensions of im:  (32, 32, 3)<br>\ndimensions of img:  (1, 32, 32, 3)<br>\ndimensions of resnet_feature_np:  (1, 1, 1, 2048)<br>","a127ba00":"# Data Processing","03c76ad8":"# Elbow Method: Find good value of K","c63d9708":"# Standard K-Means for image classification","399941b1":"# Transfer Learning"}}