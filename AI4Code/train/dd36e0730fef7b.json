{"cell_type":{"311a8ec5":"code","94a6afe7":"code","59f59ce5":"code","fe1aacc0":"code","02bae1e4":"code","c8d87d3d":"code","e8ae7879":"code","62dfb6ad":"markdown"},"source":{"311a8ec5":"import sys\nsys.path = [\n    '..\/input\/choix-034\/local\/choix-0.3.4\/choix-0.3.4\/',\n] + sys.path\n\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom sklearn.preprocessing import LabelEncoder\nimport choix\n","94a6afe7":"validation_data = pd.read_csv(\"..\/input\/jigsaw-toxic-severity-rating\/validation_data.csv\")\ncomments = pd.read_csv(\"..\/input\/jigsaw-toxic-severity-rating\/comments_to_score.csv\")\n\nlist_comments = comments[\"text\"].unique()\nvalidation_data = validation_data.query (  \"less_toxic in @list_comments or more_toxic in @list_comments\" ).copy()\n\ntext_encoder = LabelEncoder ()\ntexts =np.concatenate ( [comments[\"text\"].values,validation_data[\"less_toxic\"].values,validation_data[\"more_toxic\"].values] )\n\ntext_encoder.fit(texts)\ncomments[\"encode_text\"]=text_encoder.transform(comments[\"text\"])\nvalidation_data[\"less_toxic\"]=text_encoder.transform(validation_data[\"less_toxic\"])\nvalidation_data[\"more_toxic\"]=text_encoder.transform(validation_data[\"more_toxic\"])","59f59ce5":"validation_data[\"text_a\"] = validation_data.apply(lambda row: row[\"less_toxic\"] if row[\"less_toxic\"]  <  row[\"more_toxic\"] else  row[\"more_toxic\"],axis=1)\nvalidation_data[\"text_b\"] = validation_data.apply(lambda row: row[\"more_toxic\"] if row[\"less_toxic\"]  <  row[\"more_toxic\"] else  row[\"less_toxic\"],axis=1)\nvalidation_data[\"win_a\"] = validation_data.apply(lambda row: 0 if row[\"less_toxic\"]  <  row[\"more_toxic\"] else 1,axis=1)\nvalidation_data[\"win_b\"] = validation_data.apply(lambda row: 1 if row[\"less_toxic\"]  <  row[\"more_toxic\"] else 0,axis=1)\n\nvalidation_data_agg = validation_data.groupby([\"text_a\",\"text_b\"]).agg({\"win_a\":\"sum\",\"win_b\":\"sum\"}).reset_index()\nvalidation_data_agg[\"less_toxic\"] = validation_data_agg.apply (lambda row: row[\"text_a\"] if row[\"win_a\"]< row[\"win_b\"] else row[\"text_b\"], axis=1 )\nvalidation_data_agg[\"more_toxic\"] = validation_data_agg.apply (lambda row: row[\"text_b\"] if row[\"win_a\"]< row[\"win_b\"] else row[\"text_a\"], axis=1 )\n\nvalidation_data_agg.head()","fe1aacc0":"data = validation_data_agg[[\"more_toxic\",\"less_toxic\"]].values\n\nn_items = len(text_encoder.classes_) \ndata = [(x[0], x[1]) for x in data]\n\n# Bradley-Terry model with I-LSR  (maximum-likelihood inference algorithm) \nparams = choix.ilsr_pairwise(n_items, data, alpha=0.01)\n\nrank = {}\nfor n, text in enumerate(np.argsort(params)):\n    rank[text] = n\n\ncomments[\"score\"] = comments[\"encode_text\"].map(lambda x: rank[x])","02bae1e4":"less_toxic_count = validation_data.groupby([\"less_toxic\"]).agg ({\"worker\":\"count\"}).to_dict()[\"worker\"]\nmore_toxic_count = validation_data.groupby([\"more_toxic\"]).agg ({\"worker\":\"count\"}).to_dict()[\"worker\"]\ncomments[\"less_toxic_count\"] = comments[\"encode_text\"].map (lambda x: less_toxic_count.get(x, 0) )\ncomments[\"more_toxic_count\"] = comments[\"encode_text\"].map (lambda x: more_toxic_count.get(x, 0) )\ncomments[\"pairwise_count\"] = comments[\"less_toxic_count\"] + comments[\"more_toxic_count\"] \ncomments.head()","c8d87d3d":"comments_encode_score = comments[[\"encode_text\",\"score\"]].copy()\ncomments_encode_score.index=comments_encode_score[\"encode_text\"]\ncomments_encode_score = comments_encode_score.to_dict()[\"score\"]\n\ncomments_validation_data = validation_data.query (  \"less_toxic in @comments_encode_score.keys() and more_toxic in @comments_encode_score.keys()\" ).copy()\ncomments_validation_data[\"score_less_toxic\"] = comments_validation_data[\"less_toxic\"].map(lambda x: comments_encode_score[x]  )\ncomments_validation_data[\"score_more_toxic\"] = comments_validation_data[\"more_toxic\"].map(lambda x: comments_encode_score[x]  )\ncomments_validation_data[\"pairwise_score\"] = comments_validation_data[\"score_more_toxic\"] >  comments_validation_data[\"score_less_toxic\"]\nscore = comments_validation_data[\"pairwise_score\"].mean() \n\nprint (f\"Average Agreement with Annotators on validation data:  {score:.5f}\")","e8ae7879":"submission = comments[[\"comment_id\",\"score\"]]\nsubmission.to_csv(\"submission.csv\", index=False)\nsubmission.head()","62dfb6ad":"## Bradley-Terry model with choix\n\n[Bradley-Terry model](https:\/\/en.wikipedia.org\/wiki\/Bradley%E2%80%93Terry_model) assigns scores to a fixed set of items based on pairwise comparisons of these items.\n\nFor each individual *i* of the population the model discover a parameter *pi* that is a positive real-valued  that represent the score. \n\nIn choix, items are represented by n consecutive integers *{0,\u2026,n\u22121}*. The event \"item i wins over item j\" is represented by the Python tuple *(i, j)*.\n\nNote that the winning item must always comes first in the tuple."}}