{"cell_type":{"d1f8740f":"code","bcfcaab6":"code","a159e2f0":"code","1a532378":"markdown"},"source":{"d1f8740f":"import numpy as np \nimport pandas as pd \nimport pandas_profiling as pp\npd.set_option('display.max_columns', 500)\npd.set_option('display.max_rows', 500)\npd.set_option('display.max_colwidth', -1)\n\n# Fun\u00e7\u00e3o reduce memory -> https:\/\/www.kaggle.com\/cttsai\ndef reduce_mem_usage(df, verbose=True):\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n\n    for col in df.columns:\n#         print(col)\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)\n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        # RCO - Acrescentado para conversao de Yes or No em 1 e 0\n        elif col_type == 'object':\n            if df[col].unique().all() in ['Y', 'N', 'Yes', 'No', 'Sim', 'N\u00e3o', 'Verdadeiro', 'Falso']:\n                df[col] = df[col].map({'Y': 1, 'N': 0}).astype('int8')\n                                \n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))\n    print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) \/ start_mem))\n    return df\n\ndef import_merge(tipo, nr=None):\n    trans = pd.read_csv(DATA_FOLDER + tipo + '_transaction.csv', nrows=nr)\n    ident = pd.read_csv(DATA_FOLDER + tipo + '_identity.csv', nrows=nr)\n    ident[id] = 1 # para identifica\u00e7\u00e3o das linhas correspondentes no merge\n    df = trans.merge(ident, how='left')\n    df = reduce_mem_usage(df)\n    return df\n\ndef describe_object(df):\n    df1 = pd.DataFrame()\n    for col in df.select_dtypes(include = 'object').columns: # somente colunas texto (categ\u00f3ricas)\n        item = df[col].dropna().unique() # lista de valores unicos na coluna\n        nulo = df[col].isna().sum() # quantidade te valores null\n        pnulo = nulo \/ len(df[col].index) # % de valores null\n        dic = {'ind': col,'lista':[item], 'nulos':nulo, '%nulo':pnulo} #monta um dict \n        df2 = pd.DataFrame(dic) # passa para df\n        df1 = pd.concat([df1,df2]) # vai juntando cada coluna como um registro novo no df\n    df1.set_index('ind', drop=True, inplace=True) # define index como nome da variavel\n    df3 = df.describe(include = 'object').T\n    df3['%freq'] = df3['freq'].div(df3['count']).astype(np.float64).round(4)  # inclui campo com % da moda\n    df4 = df3.merge(df1, left_index = True, right_index = True) # merge c\/ describe do pd\n    return df4\n\n\n\nDATA_FOLDER = '..\/input\/'\nimport os\nprint(os.listdir(DATA_FOLDER))","bcfcaab6":"df_train = import_merge('train', 10000)","a159e2f0":"describe_object(df_train)","1a532378":"# IEEE Fraud Detection Competition\n\n### Rafael Caneiro de Oliveira\nhttps:\/\/www.kaggle.com\/c\/ieee-fraud-detection"}}