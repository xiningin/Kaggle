{"cell_type":{"0286123f":"code","a41f97db":"code","ac846497":"code","2e9c915a":"code","bd712160":"code","29431552":"code","bebd2d43":"code","62cb189e":"code","2c699014":"code","d2566cb7":"markdown","ab2395a0":"markdown","e0c4c04f":"markdown","550c88af":"markdown","c0953c56":"markdown","23d59590":"markdown","019f1a2c":"markdown","f7974d68":"markdown","1cb2626f":"markdown"},"source":{"0286123f":"!pip install nqdm\nfrom nqdm import nqdm\n\nimport numpy as np\nimport pandas as pd\n\nfrom matplotlib import pyplot as plt\nimport seaborn as sns","a41f97db":"print(\"data1: hashable, data2: iterable, data3: constant\")\narg1 = pd.Series([43, 64, 12], index = list(\"abc\"))\narg2 = np.arange(5, 9)\narg3 = 2.0\n\nfor i, x in enumerate(nqdm(arg1, arg2, arg3)):\n    print(i, \": \", x)\n    \n\"\"\"\nEquivalent:\n\nfor i in range(arg3):\n    for j in arg2:\n        for k in zip(arg1.index, arg1.values):\n            print([dict(k), j, i])\n\"\"\"","ac846497":"arg1 = np.arange(8).reshape(2, 2, 2)\narg2 = 2\n\nprint(\"\\nDepth: 0\\n\")\nfor i, x in enumerate(nqdm(arg1, arg2, depth = [0, 0])):\n    print(i,\": \", x)\n    \nfig, ax = plt.subplots(2)\nfor i in range(2):\n    sns.heatmap(np.arange(i*4, i*4 + 4).reshape(2, 2), ax = ax[i]) \n\n\"\"\"\nEquivalent:\n\nfor i in range(arg2):\n    for arg1_1 in arg1:\n        print([arg1_1, i])\n\"\"\"","2e9c915a":"print(\"\\nDepth: 1\\n\")\n\nfor i, x in enumerate(nqdm(arg1, arg2, depth = [1, 0])):\n    print(i,\": \", x)\n    \nfig, ax = plt.subplots(2, 2)\nfor i in range(2):\n    for j in range(2):\n        sns.heatmap(np.arange(i*4 + j*2, i*4 + j*2 + 2).reshape(2, 1), ax = ax[i][j]) \n    \n\"\"\"\nEquivalent:\n\nfor i in range(arg2):\n    for arg1_1 in arg1:\n        for arg1_1_1 in arg1_1:\n            print([arg1_1_1, i])\n\"\"\"","bd712160":"print(\"\\nDepth: 2\\n\")\nfor i, x in enumerate(nqdm(arg1, arg2, depth = [2, 0])):\n    print(i,\": \", x)\n    \nfig, ax = plt.subplots(4, 2)\nfor i in range(2):\n    for j in range(2):\n        for k in range(2):\n            sns.heatmap(np.arange(i*4 + j*2 + k, i*4 + j*2 + k + 1).reshape(1, 1), ax = ax[2 * i + j][k]) \n    \n    \n\"\"\"\nEquivalent:\n\nfor i in range(arg2):\n    for arg1_1 in arg1:\n        for arg1_1_1 in arg1_1:\n            for arg1_1_1_1 in arg1_1_1:\n                print([arg1_1_1_1, i])\n\"\"\"","29431552":"arg1, arg2, arg3 = 2, 2, 2\n\ndata = []\n\nprint(\"Binary numbers sorted in ascending order, last argument is the least significant bit\")\nfor i, x in enumerate(nqdm(arg1, arg2, arg3, order = \"last\")):\n    print(i, \": \", x)\n    data.append(x)\n\nsns.heatmap(data)\n\n\"\"\"\nEquivalent:\n\nfor i in range(arg3):\n    for j in range(arg2):\n        for k in range(arg3):\n            print([k, j, i])\n\"\"\"","bebd2d43":"print(\"Binary numbers, first argument is the least significant bit\")\n\ndata = []\n\nfor i, x in enumerate(nqdm(2, 2, 2, order = \"first\")):\n    print(i, \": \", x)\n    data.append(x)\n\nsns.heatmap(data)\n    \n\"\"\"\nEquivalent:\n\nfor i in range(arg1):\n    for j in range(arg2):\n        for k in range(arg3):\n            print([k, j, i])\n\"\"\"","62cb189e":"print(\"Custom order\")\n\ndata = []\n\nfor i, x in enumerate(nqdm(2, 2, 2, order = [1, 2, 0])):\n    print(i, \": \", x)\n    data.append(x)\n\nsns.heatmap(data)\n\"\"\"\nEquivalent:\n\nfor i in range(arg3):\n    for j in range(arg1):\n        for k in range(arg2):\n            print([k, j, i])\n\"\"\"","2c699014":"for i in nqdm(list(\"abcdefgh\"), enum=True):\n    print(i)\n    \n\"\"\"\nEquivalent:\n\nfor i in enumerate(nqdm(list('abcdefgh'))):\n    print(i)\n\"\"\"","d2566cb7":"## 4) Loops With Custom Hierarchical Order\n*Problem:* TQDM, despite all these disadvantages, gives you the ability to define which loop comes first or which one is the innermost, while NQDM compresses all loops into a single one and it is hard to tell which is the innermost or not.\n\n*Solution:* NQDM has now a new attribute called 'order' (default = \"first\"), so that you can specify the hierarchical order as you wish.\n1. first: The first argument is in the innermost loop, the last argument in the outermost loop\n2. last: The last argument is in the innermost loop, the first argument in the outermost loop\n3. [order_1,\u00a0\u2026, order_n] (given n-arguments): The i-th argument with the order_i =0 is in the innermost loop, the j-th argument with the order_j = n-1 is in the outermost loop","ab2395a0":"## NQDM\u200a-\u200aModern Progress\u00a0Bar","e0c4c04f":"## Inspiration\nYou can test these features and explore some use cases in your next projects. It is still in early development stages, so some features might not work well as expected, that is why I would be more than happy to see your contribution in the project. Feel free to fork it or leave a comment and upvote. Thank you for your attention!","550c88af":"## But Why?\nGenerally, there are 4 major challenges NQDM took seriously:\n\n1. General Parameters\n2. Multiple Loops\n3. Loops With Multiple Levels\n4. Loops With Custom Hierarchical Order\n\n## 1) General Parameters\n*Problem*: tqdm() accepts only certain kinds of parameters, for example list, range object, numpy array. trange() accepts integer.\n\n*Solution*: nqdm() works with 3 different data groups:\n1. Hashables: Instead of the formal definition, it is meant: data types which have key-value pairs. For example: dicts, pd.Series, pd.DataFrame\n2. Iterables: Instead of the definition again, it includes the array-like objects. For example: np.array, list, range, string\n3. Constants: The number of iterations. If it is not an integer, then it is converted to integer.\n\n---\n\n## 2) Multiple Loops\n*Problem:* It is still possible to use TQDM for looping over 2 lists, but when there are 3 or more lists, then it opens newline progress bars for each element in the nested loops, which makes everything complicated. If you just put a single progress bar on the outer loop, then it is not precise. It is kind of a trade-off situation and you need to decide between readable output and precision.\n\n*Solution:* NQDM accepts an arbitrary number of parameters. Let's say there are 3 lists with each 100 elements. It simulates a single loop with 100\u00b3 = 1 M elements in a single progress bar and returns all indices or elements in given order. There are 3 different scenarios for iteration:\n1. Hashables: It returns a dict with a single key-value pair, {'key1': val1}\n2. Iterables: It returns the element at given index, arr[i]\n3. Constants: It returns the index of range object, i","c0953c56":"## BONUS: Enumeration\nDid you know that you could enumerate items without using enumerate() function?","23d59590":"## A Novel Approach\nToday, this little text might change the way you are programming in Python with a simple yet quick solution. If you don't know about TQDM module, then I suggest you to look here. It is nothing revolutionary that I basically added some new features to the already existing TQDM module and created NQDM. It works basically the same as TQDM, you just need to make a quick setup:\n\n## [Source Code](https:\/\/github.com\/yamaceay\/nqdm)\n\n## NQDM\u200a-\u200aQuick Setup","019f1a2c":"![Logo](https:\/\/miro.medium.com\/max\/3480\/1*BlCdGzK8eX51S3-wCy2kdg.png)","f7974d68":"## 3) Loops With Multiple Levels\n*Problem:* There are some very good implementations, for example: leave argument set to True and the loop refreshes itself. However TQDM cannot really iterate over 3 dimensions of a single 3D list without opening newlines.\n\n*Solution:* NQDM has a feature called depth (default: 0), which transforms the data in Pythonic data structures like list or dict and 'flattens' the data.\n\n1. Dict: Values without keys are iterated\n2. List: Normal iteration\n\nIf data to be flattened is a dict, then the dict's values are iterated. Thanks to the nature of NQDM, you can also specify depth of each argument manually.\n1. Generally: nqdm(arg1, arg2, arg3, depth = [d_arg1, d_arg2, d_arg3]).\n2. Same depth: If an integer d_arg is given, then nqdm(arg1, arg2, arg3, depth = d_arg) is equivalent to nqdm(arg1, arg2, arg3, depth = [d_arg, d_arg, d_arg]).","1cb2626f":"Hey, if you are a programmer worked or still working with huge volumes of data, you might think \"How can I track the progress of the program?\", \"How can I iterate over 4 lists and is there a way to find out how long it will take?\". Some general use cases of multiple loops:\n\n1. Hyperparameter tuning\n2. Large-scale web scraping\n3. JSON data with bazillion dimensions \n\nI think we all hate these scenarios."}}