{"cell_type":{"b91a718c":"code","e692cd5f":"code","dd43da37":"code","b92737a2":"code","0d4b95ce":"code","e1bfe449":"code","ae13c16d":"code","2437095e":"code","f81767d0":"code","e0179d27":"code","50a8e98c":"code","38e32e95":"code","ff94c657":"code","a61f9f9a":"markdown","c325e216":"markdown","194e5b58":"markdown","1fbc0652":"markdown","8d5c3347":"markdown"},"source":{"b91a718c":"!git clone https:\/\/github.com\/siddharthchaini\/gpvae-raw.git","e692cd5f":"!mv -v .\/gpvae-raw\/* .\/","dd43da37":"!rm -rf gpvae-raw\n!rm gpvaeraw.ipynb","b92737a2":"!pip install tensorflow --upgrade","0d4b95ce":"import sys\nimport os\nimport time\nfrom datetime import datetime\nimport numpy as np\nimport matplotlib\nmatplotlib.use(\"Agg\")\nfrom matplotlib import pyplot as plt\nimport tensorflow as tf\n\ntf.compat.v1.enable_eager_execution()\n\nfrom sklearn.metrics import average_precision_score, roc_auc_score\nfrom sklearn.linear_model import LogisticRegression\n\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)","e1bfe449":"from lib.models import *","ae13c16d":"data = np.load(\"..\/input\/gpvae-raw\/physionet.npz\")\nx_train_full = data['x_train_full']\nx_train_miss = data['x_train_miss']\nm_train_miss = data['m_train_miss']\nx_val_full = data['x_train_full']\nx_val_miss = data['x_train_miss']\nm_val_miss = data['m_train_miss']\ny_val = data['y_train']\nm_val_artificial = data[\"m_train_artificial\"]","2437095e":"x_val_full[x_val_full == 0] = 'nan'","f81767d0":"imputed = np.load(\"..\/input\/gpvae-raw\/models\/210710_reproduce_physionet\/imputed.npy\")\nx_val_imputed_std = np.load(\"..\/input\/gpvae-raw\/models\/210710_reproduce_physionet\/x_val_imputed_std.npy\")","e0179d27":"import matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nsns.set()","50a8e98c":"np.random.seed(22)","38e32e95":"sns.set_style(\"whitegrid\")","ff94c657":"k=0\nwhile k<=5: # 5 random non-nan plots\n    i = np.random.randint(low=0,high=x_val_full.shape[0])\n    j = np.random.randint(low=0,high=x_val_full.shape[2])\n    y1 = x_val_full[i,:,j]\n    if np.isnan(y1).all():\n        continue # Continue if full input was NA\n    y2 = imputed[i,:,j]\n    yerr = x_val_imputed_std[i,:,j]\n    dyfit = yerr\n    x = np.arange(48)\n    plt.plot(x, y2, '-', label='imputed')\n    plt.plot(x, y1,'or', label='full')\n    plt.fill_between(x, y2 - dyfit, y2 + dyfit,\n                 color='blue', alpha=0.2)\n    plt.title(f\"Sample #{i}, Channel #{j}\")\n    plt.savefig(f\"Sample #{i}, Channel #{j}.png\",dpi=300)\n    plt.legend()\n    plt.show()\n    k = k+1","a61f9f9a":"# Kaggle stuff","c325e216":"## Imports","194e5b58":"# Download Physionet data","1fbc0652":"- https:\/\/www.kaggle.com\/siddharthchaini\/gp-vae-intro\n- https:\/\/github.com\/siddharthchaini\/GP-VAE\/blob\/master\/train.py","8d5c3347":"## Viz"}}