{"cell_type":{"db847d9d":"code","61b939f4":"code","dd0f0e55":"code","7153c8b9":"code","3c3bdbd7":"code","2bbf351e":"code","e16176fb":"code","028e5112":"code","4fee2565":"code","41441d1e":"code","dc6a7bc3":"code","a477a747":"code","a95f52e4":"code","155e7ecf":"code","0d8fd8c0":"code","77c3406b":"code","807fae94":"code","0af5487b":"code","85a00826":"code","d8cfe4a9":"code","d77947f8":"code","9b1f6b94":"code","08a36a0f":"code","7523ef72":"code","14f12dea":"code","1ec2de7c":"code","bd0e48d2":"code","a44fc152":"code","e2b78742":"code","6370e742":"code","45b81c73":"code","e002c0af":"code","ff72e0af":"code","84beda9c":"code","72cbd295":"code","3b381cb5":"code","ec10f504":"code","15205fc5":"code","21e151be":"code","713a545a":"code","49d9c942":"code","0299e018":"code","b19ccfa7":"code","3f0aaa0d":"code","584ee526":"code","1da6df49":"code","c96b0f74":"code","187284cd":"code","c3142063":"code","9102ba7e":"markdown","8e0903ba":"markdown","a5f6d230":"markdown","a6906045":"markdown","44a438af":"markdown","c3962462":"markdown"},"source":{"db847d9d":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport seaborn as sns \n%matplotlib inline\nfrom scipy import stats\nfrom scipy.stats import norm, skew\npd.set_option('display.float_format', lambda x: '{:.3f}'.format(x)) \nfrom subprocess import check_output\nprint(check_output([\"ls\", \"..\/input\"]).decode(\"utf8\"))","61b939f4":"train = pd.read_csv('..\/input\/house-prices-advanced-regression-techniques\/train.csv')\ntest = pd.read_csv('..\/input\/house-prices-advanced-regression-techniques\/test.csv')","dd0f0e55":"train.head()","7153c8b9":"test.head()","3c3bdbd7":"print(f'shape of train dataframe{train.shape}')\nprint(f'shape of test dataframe{test.shape}')","2bbf351e":"train_id = train['Id']\ntest_id = test['Id']\n\ntrain.drop(labels = 'Id', axis =1 ,inplace = True)\ntest.drop(labels = 'Id', axis =1 ,inplace = True)","e16176fb":"print(f'shape of train dataframe{train.shape}')\nprint(f'shape of test dataframe{test.shape}')","028e5112":"train.columns","4fee2565":"len(train['GrLivArea'].unique())","41441d1e":"fig , ax = plt.subplots()\nax.scatter(x= train['GrLivArea'], y= train['SalePrice'])\nplt.xlabel('GrLivArea')\nplt.ylabel('SalePrice')","dc6a7bc3":"train = train.drop(train[(train['GrLivArea']>4000) & (train['SalePrice']<300000)].index)","a477a747":"fig , ax = plt.subplots()\nax.scatter(x= train['GrLivArea'], y= train['SalePrice'])\nplt.xlabel('GrLivArea')\nplt.ylabel('SalePrice')","a95f52e4":" sns.distplot(train['SalePrice'] , fit=norm);\n (mu, sigma) = norm.fit(train['SalePrice'])\n print( '\\n mu = {:.2f} and sigma = {:.2f}\\n'.format(mu, sigma))\n plt.legend(['Normal dist. ($\\mu=$ {:.2f} and $\\sigma=$ {:.2f} )'.format(mu, sigma)],\n             loc='best')\n plt.ylabel('Frequency')\n plt.title('SalePrice distribution')\n fig = plt.figure()\n res = stats.probplot(train['SalePrice'], plot=plt)\n plt.show()\n\n sns.kdeplot(train['SalePrice'])","155e7ecf":"train['SalePrice']= np.log1p(train['SalePrice'])\nsns.distplot(train['SalePrice'], fit = norm)\n ","0d8fd8c0":"(mu, sigma) = norm.fit(train['SalePrice'])\nprint( '\\n mu = {:.2f} and sigma = {:.2f}\\n'.format(mu, sigma))\nplt.legend(['Normal dist. ($\\mu=$ {:.2f} and $\\sigma=$ {:.2f} )'.format(mu, sigma)],\n             loc='best')\n\nres = stats.probplot(train['SalePrice'], plot=plt)\nplt.show()","77c3406b":"plt.figure(figsize=(12,10))\nsns.heatmap(train.corr(),square=True)","807fae94":"plt.figure(figsize=(12,9))\nsns.heatmap(train.isnull(),cmap='coolwarm')","0af5487b":"ntrain= train.shape[0]\nntest = test.shape[0]\ny_train = train.SalePrice.values\nall_data = pd.concat((train,test)).reset_index(drop=True)\nall_data.drop(['SalePrice'], axis=1, inplace=True)\n\nprint(f'shape of the concatenated dataset is {all_data.shape}')\n      ","85a00826":"all_data_na = (all_data.isnull().sum() \/ len(all_data)) * 100\nall_data_na = all_data_na.drop(all_data_na[all_data_na == 0].index).sort_values(ascending=False)[:30]\nmissing_data = pd.DataFrame({'Missing Ratio' :all_data_na})\nmissing_data.head(20)","d8cfe4a9":"f, ax = plt.subplots(figsize=(15, 12))\nplt.xticks(rotation='90')\nsns.barplot(x=all_data_na.index, y=all_data_na)\nplt.xlabel('Features', fontsize=15)\nplt.ylabel('Percent of missing values', fontsize=15)\nplt.title('Percent missing data by feature', fontsize=15)\n","d77947f8":"all_data['PoolQC'] = all_data['PoolQC'].fillna('None')","9b1f6b94":"all_data['MiscFeature']= all_data['MiscFeature'].fillna('None')\n","08a36a0f":"all_data['Alley'] = all_data['Alley'].fillna('None')","7523ef72":"all_data['Fence']= all_data['Fence'].fillna('None')","14f12dea":"all_data['FireplaceQu']= all_data['FireplaceQu'].fillna('None')","1ec2de7c":"all_data['LotFrontage']= all_data.groupby('Neighborhood').transform(\nlambda x: x.fillna(x.median()))","bd0e48d2":"for col in ('GarageType', 'GarageFinish', 'GarageQual', 'GarageCond'):\n    all_data[col] = all_data[col].fillna('None')","a44fc152":"for col in ('GarageYrBlt', 'GarageArea', 'GarageCars'):\n    all_data[col] = all_data[col].fillna(0)","e2b78742":"for col in ('BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF','TotalBsmtSF', 'BsmtFullBath', 'BsmtHalfBath'):\n    all_data[col] = all_data[col].fillna(0)\n    ","6370e742":"for col in ('BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2'):\n    all_data[col] = all_data[col].fillna('None')\n    \nall_data[\"MasVnrType\"] = all_data[\"MasVnrType\"].fillna(\"None\")\nall_data[\"MasVnrArea\"] = all_data[\"MasVnrArea\"].fillna(0)\nall_data['MSZoning'] = all_data['MSZoning'].fillna(all_data['MSZoning'].mode()[0])","45b81c73":"all_data= all_data.drop(labels = 'Utilities',axis =1)","e002c0af":"sns.heatmap(all_data.isnull())","ff72e0af":"all_data[\"Functional\"] = all_data[\"Functional\"].fillna(\"Typ\")\nall_data['Electrical'] = all_data['Electrical'].fillna(all_data['Electrical'].mode()[0])\nall_data['KitchenQual'] = all_data['KitchenQual'].fillna(all_data['KitchenQual'].mode()[0])\nall_data['Exterior1st'] = all_data['Exterior1st'].fillna(all_data['Exterior1st'].mode()[0])\nall_data['Exterior2nd'] = all_data['Exterior2nd'].fillna(all_data['Exterior2nd'].mode()[0])\nall_data['MSSubClass'] = all_data['MSSubClass'].fillna(\"None\")","84beda9c":"all_data['MSSubClass'] = all_data['MSSubClass'].apply(str)\n\n#Changing OverallCond into a categorical variable\nall_data['OverallCond'] = all_data['OverallCond'].astype(str)\n\n#Year and month sold are transformed into categorical features.\nall_data['YrSold'] = all_data['YrSold'].astype(str)\nall_data['MoSold'] = all_data['MoSold'].astype(str)","72cbd295":"from sklearn.preprocessing import LabelEncoder\ncols = ('FireplaceQu', 'BsmtQual', 'BsmtCond', 'GarageQual', 'GarageCond', \n        'ExterQual', 'ExterCond','HeatingQC', 'PoolQC', 'KitchenQual', 'BsmtFinType1', \n        'BsmtFinType2', 'Functional', 'Fence', 'BsmtExposure', 'GarageFinish', 'LandSlope',\n        'LotShape', 'PavedDrive', 'Street', 'Alley', 'CentralAir', 'MSSubClass', 'OverallCond', \n        'YrSold', 'MoSold')\n# process columns, apply LabelEncoder to categorical features\nfor c in cols:\n    lbl = LabelEncoder() \n    lbl.fit(list(all_data[c].values)) \n    all_data[c] = lbl.transform(list(all_data[c].values))\n\n# shape        \nprint('Shape all_data: {}'.format(all_data.shape))","3b381cb5":"all_data['TotalSF'] = all_data['TotalBsmtSF'] + all_data['1stFlrSF'] + all_data['2ndFlrSF']","ec10f504":"all_data.head()","15205fc5":"numeric_feats = all_data.dtypes[all_data.dtypes != \"object\"].index\n\n# Check the skew of all numerical features\nskewed_feats = all_data[numeric_feats].apply(lambda x: skew(x.dropna())).sort_values(ascending=False)\nprint(\"\\nSkew in numerical features: \\n\")\nskewness = pd.DataFrame({'Skew' :skewed_feats})\nskewness.head(10)","21e151be":"skewness = skewness[abs(skewness) > 0.75]\nprint(\"There are {} skewed numerical features to Box Cox transform\".format(skewness.shape[0]))\n\nfrom scipy.special import boxcox1p\nskewed_features = skewness.index\nlam = 0.15\nfor feat in skewed_features:\n    #all_data[feat] += 1\n    all_data[feat] = boxcox1p(all_data[feat], lam)","713a545a":"all_data = pd.get_dummies(all_data)\nprint(all_data.shape)","49d9c942":"train = all_data[:ntrain]\ntest= all_data[ntrain:]","0299e018":"n_folds = 5\n\ndef rmsle_cv(model):\n    kf = KFold(n_folds, shuffle=True, random_state=42).get_n_splits(train.values)\n    rmse= np.sqrt(-cross_val_score(model, train.values, y_train, scoring=\"neg_mean_squared_error\", cv = kf))\n    return(rmse)","b19ccfa7":"from sklearn.linear_model import ElasticNet, Lasso,  BayesianRidge, LassoLarsIC\nfrom sklearn.ensemble import RandomForestRegressor,  GradientBoostingRegressor\nfrom sklearn.kernel_ridge import KernelRidge\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.base import BaseEstimator, TransformerMixin, RegressorMixin, clone\nfrom sklearn.model_selection import KFold, cross_val_score, train_test_split\nfrom sklearn.metrics import mean_squared_error\nimport xgboost as xgb\nimport lightgbm as lgb","3f0aaa0d":"lasso = make_pipeline(RobustScaler(), Lasso(alpha =0.0005, random_state=1))\nENet = make_pipeline(RobustScaler(), ElasticNet(alpha=0.0005, l1_ratio=.9, random_state=3))\nKRR = KernelRidge(alpha=0.6, kernel='polynomial', degree=2, coef0=2.5)\nGBoost = GradientBoostingRegressor(n_estimators=3000, learning_rate=0.05,\n                                   max_depth=4, max_features='sqrt',\n                                   min_samples_leaf=15, min_samples_split=10, \n                                   loss='huber', random_state =5)\nmodel_xgb = xgb.XGBRegressor(colsample_bytree=0.4603, gamma=0.0468, \n                             learning_rate=0.05, max_depth=3, \n                             min_child_weight=1.7817, n_estimators=2200,\n                             reg_alpha=0.4640, reg_lambda=0.8571,\n                             subsample=0.5213, silent=1,\n                             random_state =7, nthread = -1)\nmodel_lgb = lgb.LGBMRegressor(objective='regression',num_leaves=5,\n                              learning_rate=0.05, n_estimators=720,\n                              max_bin = 55, bagging_fraction = 0.8,\n                              bagging_freq = 5, feature_fraction = 0.2319,\n                              feature_fraction_seed=9, bagging_seed=9,\n                              min_data_in_leaf =6, min_sum_hessian_in_leaf = 11)","584ee526":"score = rmsle_cv(lasso)\nprint(\"\\nLasso score: {:.4f} ({:.4f})\\n\".format(score.mean(), score.std()))","1da6df49":"class AveragingModels(BaseEstimator, RegressorMixin, TransformerMixin):\n    def __init__(self, models):\n        self.models = models\n        \n    # we define clones of the original models to fit the data in\n    def fit(self, X, y):\n        self.models_ = [clone(x) for x in self.models]\n        \n        # Train cloned base models\n        for model in self.models_:\n            model.fit(X, y)\n\n        return self\n    \n    #Now we do the predictions for cloned models and average them\n    def predict(self, X):\n        predictions = np.column_stack([\n            model.predict(X) for model in self.models_\n        ])\n        return np.mean(predictions, axis=1)  ","c96b0f74":"averaged_models = AveragingModels(models = (ENet, GBoost, KRR, lasso))\n\nscore = rmsle_cv(averaged_models)\nprint(\" Averaged base models score: {:.4f} ({:.4f})\\n\".format(score.mean(), score.std()))","187284cd":"class StackingAveragedModels(BaseEstimator, RegressorMixin, TransformerMixin):\n    def __init__(self, base_models, meta_model, n_folds=5):\n        self.base_models = base_models\n        self.meta_model = meta_model\n        self.n_folds = n_folds\n   \n    # We again fit the data on clones of the original models\n    def fit(self, X, y):\n        self.base_models_ = [list() for x in self.base_models]\n        self.meta_model_ = clone(self.meta_model)\n        kfold = KFold(n_splits=self.n_folds, shuffle=True, random_state=156)\n        \n        # Train cloned base models then create out-of-fold predictions\n        # that are needed to train the cloned meta-model\n        out_of_fold_predictions = np.zeros((X.shape[0], len(self.base_models)))\n        for i, model in enumerate(self.base_models):\n            for train_index, holdout_index in kfold.split(X, y):\n                instance = clone(model)\n                self.base_models_[i].append(instance)\n                instance.fit(X[train_index], y[train_index])\n                y_pred = instance.predict(X[holdout_index])\n                out_of_fold_predictions[holdout_index, i] = y_pred\n                \n        # Now train the cloned  meta-model using the out-of-fold predictions as new feature\n        self.meta_model_.fit(out_of_fold_predictions, y)\n        return self\n   \n    #Do the predictions of all base models on the test data and use the averaged predictions as \n    #meta-features for the final prediction which is done by the meta-model\n    def predict(self, X):\n        meta_features = np.column_stack([\n            np.column_stack([model.predict(X) for model in base_models]).mean(axis=1)\n            for base_models in self.base_models_ ])\n        return self.meta_model_.predict(meta_features)","c3142063":"stacked_averaged_models = StackingAveragedModels(base_models = (ENet, GBoost, KRR),\n                                                 meta_model = lasso)\n\nscore = rmsle_cv(stacked_averaged_models)\nprint(\"Stacking Averaged models score: {:.4f} ({:.4f})\".format(score.mean(), score.std()))","9102ba7e":"filling the lot frontage area with the median of all the areas included in the same neighbourhood within the dataset.","8e0903ba":"Correlation graph","a5f6d230":"Null values in the dataset","a6906045":"As seen in the probability plot it is not varying linearly it roughly follows a logarithmic pattern.","44a438af":"Feature Engineering","c3962462":"Importing all the suitable models for the ptediction"}}