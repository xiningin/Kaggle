{"cell_type":{"22da5c32":"code","773f3d0a":"code","8e2c3df1":"code","ff3d8ed2":"code","0a629bfa":"code","84ba927a":"code","d85a048f":"code","97fa48e1":"code","21c7a7b8":"code","1d93d88c":"code","ad008752":"code","14d02dba":"code","f00113be":"code","ed197343":"code","cfaaf7dd":"markdown","4f35a4f4":"markdown","be2445d7":"markdown","0d89bb3b":"markdown","ac301617":"markdown"},"source":{"22da5c32":"import os, time, sys, gc\nfrom tqdm import tqdm_notebook as tqdm\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n#wave analysis\nimport pywt \nfrom statsmodels.robust import mad\nimport scipy\nfrom scipy import stats \nfrom scipy import signal\nfrom scipy.signal import hann, hilbert, convolve, butter, deconvolve\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import StratifiedKFold, KFold\n\nimport lightgbm as lgb\nfrom sklearn.metrics import f1_score","773f3d0a":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","8e2c3df1":"INPUTDIR = '\/kaggle\/input\/liverpool-ion-switching\/'\nNROWS = None\nSHIFT = 1\nWINDOW = [10, 25, 50, 100, 500, 1000, 5000, 10000, 25000]\nn_fold = 3\nERSR = 500\nDISP = 1000\nnum_round = 5000\nfolds = KFold(n_splits=n_fold, shuffle=True, random_state=6666)","ff3d8ed2":"%%time\ndf_train = pd.read_csv(f'{INPUTDIR}\/train.csv', nrows=NROWS, dtype={'time':np.float32, 'signal':np.float32})\ndf_test = pd.read_csv(f'{INPUTDIR}\/test.csv', nrows=NROWS, dtype={'time':np.float32, 'signal':np.float32})\nsub_df = pd.read_csv(f'{INPUTDIR}\/sample_submission.csv', nrows=NROWS)","0a629bfa":"print(df_train.columns)\nprint(df_test.columns)\nprint(df_train.shape)\nprint(df_test.shape)","84ba927a":"def rolling_feature(df, sft, window_sizes):\n    for window in window_sizes:\n        df[\"roll_sum_\" + str(window)] = df['signal'].rolling(window=window).sum()\n        df[\"roll_mean_\" + str(window)] = df['signal'].rolling(window=window).mean()\n                    \n        df[\"roll_std_\" + str(window)] = df['signal'].rolling(window=window).std()\n        df[\"roll_max2min_\" + str(window)] = df['signal'].rolling(window=window).max()\/\\\n            df['signal'].rolling(window=window).min()\n        df[\"roll_max_diff_min_\" + str(window)] = df['signal'].rolling(window=window).max()-\\\n            df['signal'].rolling(window=window).min()\n        \n        df[\"roll_mean_diffwt2_\" + str(window)] = df['signal'].rolling(window=window).mean()-\\\n            df['signal'].shift(sft*2).rolling(window=window).mean()\n        \n        df[\"roll_mean_diffwt3_\" + str(window)] = df['signal'].rolling(window=window).mean()-\\\n            df['signal'].shift(sft*3).rolling(window=window).mean()\n        \n        df[\"roll_skew_\" + str(window)] = df['signal'].rolling(window=window).skew()\n        \n        df.replace([np.inf, -np.inf], np.nan, inplace=True)\n        df.fillna(0, inplace=True)\n    return df\n","d85a048f":"%%time\ndf_train = rolling_feature(df_train, SHIFT, WINDOW)\ndf_test = rolling_feature(df_test, SHIFT, WINDOW)","97fa48e1":"df_train.head(10)","21c7a7b8":"drop_list = [ 'time', 'signal', 'open_channels']\nfeatures = [c for c in df_train.columns if c not in drop_list]\ntarget = df_train['open_channels']\nlen(features)","1d93d88c":"param_lgb = {'num_leaves': 128,\n          'min_data_in_leaf': 64,\n          'objective': 'huber',\n          'max_depth': -1,\n          'learning_rate': 0.1,\n          'boosting': 'gbdt',\n          'bagging_freq': 5,\n          'bagging_fraction': 0.8,\n          'bagging_seed': 66,\n          'metric': 'mae',\n          'verbosity': 1,\n          'nthread': -1,\n          'random_state': 6666}","ad008752":"sts_time = time.time()\noof = np.zeros(len(df_train))\n#train_pred = np.zeros(len(df_train))\npredictions = np.zeros(len(df_test))\nfeature_importance_df = pd.DataFrame()\n\n#run model\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(df_train)):\n    strLog = \"Fold {}\".format(fold_+1)\n    print(strLog ,'started at', time.ctime())\n    \n    \n    X_tr, X_val = df_train.iloc[trn_idx][features], df_train.iloc[val_idx][features]\n    y_tr, y_val = target.iloc[trn_idx], target.iloc[val_idx]\n    \n    trn_data = lgb.Dataset(X_tr, label=y_tr)\n    val_data = lgb.Dataset(X_val, label=y_val)\n\n    model = lgb.train(param_lgb, trn_data, num_round, valid_sets = [trn_data, val_data], verbose_eval=DISP, early_stopping_rounds = ERSR)\n    oof[val_idx] = model.predict(X_val, num_iteration=model.best_iteration)\n    \n    #feature importance\n    fold_importance_df = pd.DataFrame()\n    fold_importance_df[\"Feature\"] = features\n    fold_importance_df[\"importance\"] = model.feature_importance()\n    fold_importance_df[\"fold\"] = fold_ + 1\n    feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0)\n    #predictions\n    #train_pred += model.predict(df_train[features], num_iteration=model.best_iteration) \/ folds.n_splits\n    predictions += model.predict(df_test[features], num_iteration=model.best_iteration) \/ folds.n_splits\n    \n    ed_time = time.time()\n    calc_time = ed_time - sts_time\n    print('Calc Time : %.2f [sec]' % calc_time)\n\nend_time = time.time()\ncalc_time = end_time - sts_time\nprint('Calc Time : %.2f [sec]' % calc_time)","14d02dba":"cols = (feature_importance_df[[\"Feature\", \"importance\"]]\n        .groupby(\"Feature\")\n        .mean()\n        .sort_values(by=\"importance\", ascending=False)[:200].index)\nbest_features = feature_importance_df.loc[feature_importance_df.Feature.isin(cols)]\n\nplt.figure(figsize=(14,26))\nsns.barplot(x=\"importance\", y=\"Feature\", data=best_features.sort_values(by=\"importance\",ascending=False))\nplt.title('LightGBM Features (averaged over folds)')\nplt.tight_layout()","f00113be":"sub_df['open_channels'] = np.round(predictions).astype(np.int)\nCVscore = f1_score(target, np.round(oof).astype(np.int), labels=None, pos_label=1, average='macro',  zero_division='warn') \nprint('CV Score is: {:.3f}'.format(CVscore))","ed197343":"sub_df.to_csv(\"submission.csv\", index=False, float_format='%.4f')","cfaaf7dd":"## Submission","4f35a4f4":"## Import Data","be2445d7":"## Define Functions","0d89bb3b":"## Import Libraries","ac301617":"### Rolling Features"}}