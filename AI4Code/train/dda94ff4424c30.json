{"cell_type":{"ac7e20f9":"code","d2f38fad":"code","cc99f21d":"code","1d574341":"code","f42f4cdf":"code","c417bce8":"code","55b12345":"code","317e6860":"code","e0fb4a98":"code","66942736":"code","b853b479":"code","cc19b327":"code","b6a6d97d":"code","bef8b17b":"code","12d3c4bf":"code","1bff64d0":"code","6b0b02b8":"code","31c96fd7":"code","4dd0cc0f":"code","20fa3318":"code","7d5e23b5":"code","e981ac89":"code","29fea7aa":"code","809e0096":"code","73f41dd9":"code","91cfe56f":"code","58f05e0f":"code","1a15806d":"code","4e8926ad":"code","897008d0":"markdown","4cc3b177":"markdown","14b041a5":"markdown","6fd05071":"markdown","f924c331":"markdown","b53bae70":"markdown","6a933514":"markdown"},"source":{"ac7e20f9":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d2f38fad":"import pandas as pd\npd.set_option('display.max_columns', 20)\nmovie = pd.read_csv(\"\/kaggle\/input\/movielens-20m-dataset\/movie.csv\")\nrating = pd.read_csv(\"\/kaggle\/input\/movielens-20m-dataset\/rating.csv\")\n\ndf = movie.merge(rating, how=\"left\", on=\"movieId\")\ndf.head()","cc99f21d":"df.shape","1d574341":"# Let's find the unique movies:\ndf[\"title\"].nunique()","f42f4cdf":"#Let's see how many comments were made on which movie:\ndf[\"title\"].value_counts().head()","c417bce8":"# Let's get to the movies with less than 1000 reviews:\ncomment_counts = pd.DataFrame(df[\"title\"].value_counts())\nrare_movies = comment_counts[comment_counts[\"title\"] <= 1000].index\n\n# Let's get access to movies with over 1000 reviews:\ncommon_movies = df[~df[\"title\"].isin(rare_movies)]\ncommon_movies.shape","55b12345":"# Unique movies with more than 1000 reviews:\ncommon_movies[\"title\"].nunique()","317e6860":"# Let's create the User Movie Df:\nuser_movie_df = common_movies.pivot_table(index=[\"userId\"], columns=[\"title\"], values=\"rating\")\n\n# There are 3159 movies that 138493 users have voted for. \nuser_movie_df.shape","e0fb4a98":"user_movie_df.head(10)","66942736":"# item-based movie recommendation example:\nmovie_name = \"Matrix, The (1999)\"\nmovie_name = user_movie_df[movie_name]\nuser_movie_df.corrwith(movie_name).sort_values(ascending=False).head(10)","b853b479":"# Let's determine the movies that the user watched.\n\n# Let's choose random user:\n# random_user = int(pd.Series(user_movie_df.index).sample(1, random_state=45).values)\nrandom_user = 28491","cc19b327":"# Let's reduce the #dataset to user 28491:\nrandom_user_df = user_movie_df[user_movie_df.index == random_user]\nrandom_user_df","b6a6d97d":"# Let's choose non-NaN. Movies watched by all 28491:\nmovies_watched = random_user_df.columns[random_user_df.notna().any()].tolist()\nmovies_watched","bef8b17b":"#let's verify:\nuser_movie_df.loc[user_movie_df.index == random_user, user_movie_df.columns == \"Young Guns (1988)\"]\n# gave this movie a 3.0 rating.","12d3c4bf":"# How many movies have user #28491 watched:\nlen(movies_watched)","1bff64d0":"# we have reduced the dataset based on movies watched by user 28491:\nmovies_watched_df = user_movie_df[movies_watched]\nmovies_watched_df.head()\nmovies_watched_df.shape","6b0b02b8":"# information on how many movies each user watched in total:\nuser_movie_count = movies_watched_df.T.notnull().sum()\n\nuser_movie_count = user_movie_count.reset_index()\nuser_movie_count.columns = [\"userId\",\"movie_count\"]\nuser_movie_count.head()","31c96fd7":"# 3 user watched 22 movies:\nuser_movie_count[user_movie_count[\"movie_count\"] == 22].count()","4dd0cc0f":"# 60% of movies watched by 28491:\nperc = len(movies_watched) * 60 \/ 100\nperc","20fa3318":"# People who have watched more than 60% movies together with 28491 users:\nusers_same_movies = user_movie_count[user_movie_count[\"movie_count\"] > perc][\"userId\"]\nusers_same_movies.count()","7d5e23b5":"# Let's combine the data of user #28491 and similar users:\nfinal_df = pd.concat([movies_watched_df[movies_watched_df.index.isin(users_same_movies)],\n                      random_user_df[movies_watched]])\n\nfinal_df.shape\nfinal_df.T.corr()","e981ac89":"#corr for all users:\ncorr_df = final_df.T.corr().unstack().sort_values().drop_duplicates()\ncorr_df = pd.DataFrame(corr_df, columns=[\"corr\"])\ncorr_df.index.names = ['user_id_1', 'user_id_2']\ncorr_df = corr_df.reset_index()\ncorr_df.head()","29fea7aa":"# Users with a correlation of %65 or more with 28491 users:\ntop_users = corr_df[(corr_df[\"user_id_1\"] == random_user) & (corr_df[\"corr\"] >= 0.65)][\n    [\"user_id_2\", \"corr\"]].reset_index(drop=True)\n\ntop_users = top_users.sort_values(by='corr', ascending=False)\ntop_users.rename(columns={\"user_id_2\": \"userId\"}, inplace=True)\ntop_users.head()","809e0096":"# let's see the ratings of users:\nrating = pd.read_csv(\"\/kaggle\/input\/movielens-20m-dataset\/rating.csv\")\ntop_users_ratings = top_users.merge(rating[[\"userId\", \"movieId\", \"rating\"]], how='inner')\n\ntop_users_ratings = top_users_ratings[top_users_ratings[\"userId\"] != random_user]\ntop_users_ratings.head()","73f41dd9":"# Calculate the Weighted Average Recommendation Score and keep the first 5 movies.\n\n#Let's do a single score with the most similar by corr * rating:\ntop_users_ratings['weighted_rating'] = top_users_ratings['corr'] * top_users_ratings['rating']\ntop_users_ratings.groupby('movieId').agg({\"weighted_rating\": \"mean\"})\n\nrecommendation_df = top_users_ratings.groupby('movieId').agg({\"weighted_rating\": \"mean\"})\nrecommendation_df = recommendation_df.reset_index()\nrecommendation_df.head()","91cfe56f":"# weighted rating greater than 4:\nrecommendation_df[recommendation_df[\"weighted_rating\"] > 3.7]\n\n# Movies 28491 will like:\nmovies_to_be_recommend = recommendation_df[recommendation_df[\"weighted_rating\"] > 3.7].sort_values(\"weighted_rating\", ascending=False)\n\nmovies_to_be_recommend.merge(movie[[\"movieId\", \"title\"]])\n\n#Let's see the top 5 movies:\nmovies_to_be_recommend.merge(movie[[\"movieId\", \"title\"]])[:5]","58f05e0f":"# Make an item-based suggestion based on the name of the movie that the user has watched with the highest score.\n\n# \u25aa 5 suggestions user-based\n# \u25aa 5 suggestions item-based\n\nmovie = pd.read_csv(\"\/kaggle\/input\/movielens-20m-dataset\/movie.csv\")\nrating = pd.read_csv(\"\/kaggle\/input\/movielens-20m-dataset\/rating.csv\")\n\n# The last highly-rated movie by user 108170:\n\nuser = 108170\nmovie_id = rating[(rating[\"userId\"] == user) & (rating[\"rating\"] == 5.0)].sort_values(by=\"timestamp\", ascending=False)[\"movieId\"][0:1].values[0]\nmovie_id","1a15806d":"# \u25aa 5 suggestions user-based\nmovies_to_be_recommend.merge(movie[[\"movieId\", \"title\"]])[:5]['title'].to_list()","4e8926ad":"# \u25aa 5 suggestions item-based\nmovie_name = movie[movie['movieId'] == movie_id]['title'].values[0]\nmovie_name = user_movie_df[movie_name]\nmoveis_from_item_based = user_movie_df.corrwith(movie_name).sort_values(ascending=False)\nmoveis_from_item_based[1:6].index.to_list()","897008d0":"# Load Dataset\n","4cc3b177":"# Dataset and Story\n\nMovieLens, a movie recommendation service, provided the dataset. It contains the rating scores for these movies along with the movies.\n\nIt contains 2,000,0263 ratings across 27,278 movies. This data was created by 138,493 users between 09 January 1995 and 31 March 2015. This data set was created on October 17, 2016. Users are randomly selected. It is known that all selected users voted for at least 20 movies.\n\n**Variables of the data set:**\n\n**movie.csv**\n- movieId \u2013 Unique movie number. (UniqueID) \n- title \u2013 Movie name\n\n**rating.csv**\n* userid \u2013 Unique user number. (UniqueID) \n* movieId \u2013 Unique movie number. (UniqueID) \n* rating \u2013 The rating given to the movie by the user\n* timestamp \u2013 Evaluation date","14b041a5":"# What Is Collaborative Filtering?\n\nCollaborative filtering is a technique that can filter out items that a user might like on the basis of reactions by similar users. It works by searching a large group of people and finding a smaller set of users with tastes similar to a particular user. It looks at the items they like and combines them to create a ranked list of suggestions. There are many ways to decide which users are similar and combine their choices to create a list of recommendations. \n\n\n**Item-Based Collaborative Filtering** is the recommendation system to use the similarity between items using the ratings by users. \n\n**User-Based Collaborative Filtering** is a technique used to predict the items that a user might like on the basis of ratings given to that item by the other users who have similar taste with that of the target user. Many websites use collaborative filtering for building their recommendation system.\n\n![image.png](attachment:abe5498e-7c57-4be2-bd14-7f337f55d9ec.png)\n\n","6fd05071":"A recommender system, or a recommendation system, can be thought of as a subclass of information filtering system that seeks to predict the best \u201crating\u201d or \u201cpreference\u201d a user would give to an item which is typically obtained by optimizing for objectives like total clicks, total revenue, and overall sales.\n\nBroadly speaking, most recommender systems leverage two types of data:\n* Interaction Data, such as ratings, and browsing behaviors, and\n* Attribution Information, about each user and items\n\nThe modeling approach relying on the former data is generally known Collaborative Filtering method, and the approach using the latter is referred to as the Content-Base Filtering method. There is also another category known as Knowledge-Based recommender system that is based on explicitly specified user requirements.\nOf course, each of these methods has its strengths and weaknesses depending on which applications they are used for, and the amount of data available.\nHybrid Systems are then used to combined the advantages of these approaches to have a robust performing system across a wide variety of applications.\n\n\n![image.png](attachment:f1b9acb5-be23-48ac-949c-d1d399038f5e.png)\n\n\n* **Collaborative Filtering Methods:** \n\nThese types of models use the collaborative power of the ratings provided by multiple users to make recommendations and rely mostly on leveraging either inter-item correlations or inter-user interactions for the prediction process. Intuitively, it relies on an underlying notion that two users who rate items similarly are likely to have comparable preferences for other items.\n\nThere are two types of methods that are commonly used in collaborative filtering:\n\n**Memory-based** methods also referred to as neighborhood-based collaborative filtering algorithms, where ratings of user-item combinations are predicted based on their neighborhoods. These neighborhoods can be further defined as (1) User Based, and (2) Item Based.\n\nIn **Model-based** methods, ML techniques are used to learn model parameters within the context of a given optimization framework\n\n* **Content Based Filtering Methods:**\n\nIn these types of systems, the descriptive attributes of items\/users are used to make recommendations. The term \u201ccontent\u201d refers to these descriptions. In content-based methods, the ratings and interaction behavior of users are combined with the content information available in the items.\n\n* **Hybrid Methods:** \n\nIn many cases, a wider variety of inputs is available; in such cases, many opportunities exist for hybridization, where the various aspects from different types of systems are combined to achieve the best of all worlds. The approach is comparable to the conventional ensemble analysis approach, where the power of multiple types of machine learning algorithms is combined to create a more robust model.","f924c331":"# Hybrid Recommender System","b53bae70":"# Let's Start!","6a933514":"# Business Problem\n\nEstimate using the item-based and user-based recommender methods for the user whose ID is given."}}