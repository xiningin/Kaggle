{"cell_type":{"33a3d700":"code","bc150a73":"code","122f0e53":"code","a130a195":"code","210b8209":"code","9ade1f99":"code","99a85ca0":"code","88aff271":"code","94d4745f":"code","191d2a35":"code","ff497f65":"code","85d5a6aa":"code","7520d927":"code","cd5a6455":"code","a77547be":"code","642f869c":"code","d30d7efd":"code","36d324e3":"code","a9a4427c":"code","1c58d6ff":"code","9c9f7455":"code","154a945b":"code","ff4801c1":"code","511937b4":"code","807a6181":"code","162b30fc":"code","3347cf4b":"code","92a3b818":"code","111b4ac4":"code","6425182f":"code","f9001545":"code","4d6f2588":"code","cb349cf1":"code","94525798":"code","0fd507b7":"code","32196985":"code","4c6cb5b9":"markdown"},"source":{"33a3d700":"from IPython.display import Image\nImage(\"..\/input\/ecg-presentation\/Slayt2.JPG\")","bc150a73":"Image(\"..\/input\/ecg-presentation\/Slayt4.JPG\")","122f0e53":"pip install treelib","a130a195":"##############################################################\n####################### Libraries ############################\n##############################################################\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\nimport seaborn as sns\nfrom treelib import Tree\nimport pywt\nimport scipy.io as sio\n\nfrom scipy.fftpack import fft\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder, RobustScaler\nfrom sklearn.decomposition import PCA\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, AdaBoostClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import cross_validate, GridSearchCV, train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.tree import DecisionTreeClassifier\nfrom lightgbm import LGBMClassifier\n\nimport warnings\nimport pickle\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nwarnings.filterwarnings('ignore')\npd.set_option('display.max_columns', 15)\npd.set_option('display.max_rows', 20)\npd.set_option('display.float_format', lambda x: '%.3f' % x)\npd.set_option('display.width', 170)","210b8209":"##############################################################\n####################### Functions ############################\n##############################################################\n\ndir_in = '..\/input\/ecg-dataset\/'\ndir_out = ''\ndef load_dataset(filename, extension = '.csv', directory = dir_in):\n    \"\"\"\n    Iports the dataset\n    Parameters\n    ----------\n    dataset\n\n    Returns\n    -------\n    dataframe\n    \"\"\"\n    if 'csv' in extension:\n        data = pd.read_csv(directory+filename+extension)\n    elif 'xls' in extension:\n        data = pd.read_excel(directory+filename+extension)\n    elif 'pkl' in extension:\n        data = pd.DataFrame(pickle.load(open(directory+filename+extension, 'rb')))\n    return data\n\ndef save_dataset(data, filename, extension = '.csv', directory = dir_out):\n    \"\"\"\n    Iports the dataset\n    Parameters\n    ----------\n    dataset\n\n    Returns\n    -------\n    dataframe\n    \"\"\"\n    if 'csv' in extension:\n        data.to_csv(ddirectoryir+filename+extension)\n    elif 'xls' in extension:\n        data.to_excel(directory+filename+extension, index=False)\n    elif 'pkl' in extension:\n        pickle.dump(data, open(directory+filename+extension, 'wb'))\n\n\ndef plot_time_freq_scaleogram(y, f_s):\n    y = list(y)\n\n    scales = np.arange(1, 256)\n    title = 'CWT (Power Spectrum)'\n    ylabel = 'Frequency'\n    xlabel = 'Time'\n\n    fig = plt.figure(figsize=(16, 16))\n    spec = gridspec.GridSpec(ncols=6, nrows=6)\n    top_ax = fig.add_subplot(spec[0, 0:5])\n    bottom_left_ax = fig.add_subplot(spec[1:, 0:5])\n    bottom_right_ax = fig.add_subplot(spec[1:, 5])\n    cbar_ax = fig.add_axes([0.95, 0.5, 0.03, 0.25])\n\n    plot_signal(top_ax, y, f_s)\n    yticks, ylim, im = plot_wavelet(bottom_left_ax, y, f_s, scales, waveletname='cmor1.5-1.0', xlabel=xlabel, ylabel=ylabel, title=title, depth=4)\n\n    fig.colorbar(im, cax=cbar_ax, orientation=\"vertical\")\n\n    plot_fft(bottom_right_ax, y, f_s, plot_direction='vertical', yticks=yticks, ylim=ylim)\n    bottom_right_ax.set_ylabel('Period', fontsize=14)\n    # plt.tight_layout()\n    plt.show()\n\ndef plot_signal(ax, y, f_s):\n    N = len(y)\n    time = np.arange(0, N) * (1\/f_s)\n    ax.plot(time, y, label='signal')\n    ax.set_xlim([time[0], time[-1]])\n    ax.set_ylabel('Amplitude', fontsize=16)\n    ax.set_title('Signal', fontsize=16)\n    ax.legend(loc='upper right')\n\ndef plot_fft(ax, y, f_s, plot_direction='horizontal', yticks=None, ylim=None):\n    variance = np.std(y) ** 2\n    f, fft = get_fft(y, f_s)\n    if plot_direction == 'horizontal':\n        ax.plot(f, fft, 'r-', label='Fourier Transform')\n    elif plot_direction == 'vertical':\n        scales_log = np.log2(f)\n        ax.plot(fft, scales_log, 'r-', label='Fourier Transform')\n        ax.set_yticks(np.log2(yticks))\n        #ax.set_yticks(yticks)\n        ax.set_yticklabels(yticks)\n        # ax.invert_yaxis()\n        ax.set_ylim(ylim[0], -1)\n    ax.legend()\n\ndef plot_wavelet(ax, y, f_s, scales, waveletname='cmor', cmap=plt.cm.seismic, title='', ylabel='', xlabel='', depth = 1):\n    time = np.arange(0, N) * (1 \/ f_s)\n    coefficients, frequencies = pywt.cwt(y, scales, waveletname, 1\/f_s)\n\n    power = (abs(coefficients)) ** 2\n    period = frequencies\n    levels = [0.015625,0.03125,0.0625, 0.125, 0.25, 0.5, 1]\n    levels = [level \/ depth for level in levels]\n    # levels = [0.0625, 0.125, 0.25, 0.5, 1, 2, 4, 8]\n    contourlevels = np.log2(levels)\n\n    im = ax.contourf(time, np.log2(period), np.log2(power), contourlevels, extend='both', cmap=cmap)\n\n    ax.set_title(title, fontsize=15)\n    ax.set_ylabel(ylabel, fontsize=15)\n    ax.set_xlabel(xlabel, fontsize=15)\n    yticks = 2**np.arange(np.ceil(np.log2(period.min())), np.ceil(np.log2(period.max())))\n    ax.set_yticks(np.log2(yticks))\n    ax.set_yticklabels(yticks)\n    ax.invert_yaxis()\n    ylim = ax.get_ylim()\n\n    return yticks, ylim, im\n\ndef plot_tree(wp):\n    tree = Tree()\n    tree.create_node(\"data\", \"data\")  # No parent means its the root node\n    for level in range(1, wp.maxlevel + 1):\n        nodes = wp.get_level(level, order='natural', decompose=False)\n        for i, node in enumerate(nodes):\n            if level == 1:\n                parent = \"data\"\n            else:\n                parent = nodes_prev[int(i \/ 2)].path\n            tree.create_node(str(node.path), str(node.path), parent=parent)\n        nodes_prev = nodes\n    tree.show()\n\ndef wpd_plt(y, wave='sym5', n=None, best_basis = None):\n    # wpd decompose\n    wp = pywt.WaveletPacket(data=y, wavelet=wave, mode='symmetric', maxlevel=n)\n    n = wp.maxlevel\n    # Calculate the coefficients for each node, where map Medium, key by'aa'Wait, value For List\n    map = {}\n    map[1] = y\n    for row in range(1, n + 1):\n        lev = []\n        for i in [node.path for node in wp.get_level(row, 'freq')]:\n            map[i] = wp[i].data\n\n    # Mapping\n    plt.figure(figsize=(15, 10))\n    ax = plt.subplot(n + 1, 1, 1)  # Draw the first graph\n    ax.set_title('data')\n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n    plt.plot(map[1])\n    for i in range(2, n + 2):\n        level_num = pow(2, i - 1)  # Starting with the second row, the power of 2 of the previous row is calculated\n        # Getting decomposed at each level node: For example, the third layer['aaa', 'aad', 'add', 'ada', 'dda', 'ddd', 'dad', 'daa']\n        re = [node.path for node in wp.get_level(i - 1, 'freq')]\n        for j in range(1, level_num + 1):\n            if best_basis != None:\n                if True in [(re[j - 1].startswith(b) & (re[j - 1] != b)) for b in best_basis]:\n                    continue\n            ax = plt.subplot(n + 1, level_num, level_num * (i - 1) + j)\n            plt.plot(map[re[j - 1]])  # List starts at 0\n            ax.set_title(re[j - 1])\n            ax.set_yticklabels([])\n            ax.set_xticklabels([])\n    plt.show()\n\n\ndef get_best_basis(data, wave='sym5', thresh=1., **_):\n    wp = pywt.WaveletPacket(data, wave)\n    wp.get_leaf_nodes(decompose=True)\n    levels = pywt.dwt_max_level(len(data), pywt.Wavelet(wave))\n\n    for level in range(levels, 1, -1):\n        nodes = wp.get_level(level, order='natural', decompose=False)\n        paths = [n.path for n in nodes]\n        n = len(paths)\n        for i in range(0, n, 2):\n            child_vals = np.hstack([wp[paths[i]].data, wp[paths[i + 1]].data])  # child nodelar\u0131n\u0131n approximation ve details verilerini birle\u015ftirir\n            parent_val = wp[wp[paths[i]].parent.path].data  # parent nodunun verileri\n            # child nodelar\u0131n\u0131n verilerinin entropisi parent nodu verisinin entropisinden b\u00fcy\u00fckse child nodelar\u0131 sil\n            # aksi durumda parent nodu verisini parent nod verisinin entropi de\u011feri olarak de\u011fi\u015ftir\n            if shannon_entropy(child_vals) > shannon_entropy(parent_val) * thresh:\n                wp.__delitem__(paths[i])\n                wp.__delitem__(paths[i + 1])\n            else:\n                wp[wp[paths[i]].parent.path].data = min(shannon_entropy(child_vals), shannon_entropy(parent_val))\n    leaves = wp.get_leaf_nodes()\n    best_basis = leaves\n\n    return wp, best_basis\n\ndef get_features(data):\n    entropy = shannon_entropy(data)\n    crossings = get_crossings(data)\n    statistics = get_statistics(data)\n    return [entropy] + crossings + statistics\n\ndef shannon_entropy(data):\n    if len(data) == 1:\n        s = data\n    else:\n        e = data ** 2 \/ len(data)\n        p = e \/ sum(e)\n        s = -sum(p * np.log(p))\n    return s\n\ndef get_crossings(data):\n    zero_crossing_indices = np.nonzero(np.diff(np.array(data) > 0))[0]\n    no_zero_crossings = len(zero_crossing_indices)\n    mean_crossing_indices = np.nonzero(np.diff(np.array(data) > np.nanmean(data)))[0]\n    no_mean_crossings = len(mean_crossing_indices)\n    return [no_zero_crossings, no_mean_crossings]\n\ndef get_statistics(data):\n    n5 = np.nanpercentile(data, 5)\n    n25 = np.nanpercentile(data, 25)\n    n75 = np.nanpercentile(data, 75)\n    n95 = np.nanpercentile(data, 95)\n    median = np.nanpercentile(data, 50)\n    mean = np.nanmean(data)\n    std = np.nanstd(data)\n    var = np.nanvar(data)\n    rms = np.nanmean(np.sqrt(data**2))\n    return [n5, n25, n75, n95, median, mean, std, var, rms]\n\ndef get_fft(y, f_s):\n    N = len(y)\n    f = np.linspace(0.0, 1.0 \/ (2.0 * (1\/f_s)), N \/\/ 2)\n    fft_ = fft(y)\n    fft_ = 2.0 \/ N * np.abs(fft_[0:N \/\/ 2])\n    return f, fft_\n\ndef get_autocorr(y, f_s):\n    autocorr = np.correlate(y, y, mode='full')\n    autocorr = autocorr[len(autocorr) \/\/ 2:]\n    x_values = np.array([(1\/f_s) * jj for jj in range(0, N)])\n    return x_values, autocorr","9ade1f99":"Image(\"..\/input\/ecg-presentation\/Slayt3.JPG\")","99a85ca0":"##############################################################\n################# Data parameteters ##########################\n##############################################################\n\nwave = 'sym5'\nN = 2048 # data points of each observation\nf_s = 128 # data sampling frequency (Hz)\ndt = 1\/f_s # data sampling period (sec)\nN_t = N*dt # data recording time (sec)","88aff271":"##############################################################\n################## Data preparation ##########################\n##############################################################\n\necg = sio.loadmat('..\/input\/ecg-dataset\/ECGData.mat')\necg_labels = list(map(lambda x: x[0][0], ecg['ECGData'][0][0][1]))\n\necg_data = np.array([])\necg_label = np.array([])\n\ndiv = 32\nfor e, ecg_signal in enumerate(ecg['ECGData'][0][0][0]):\n    ecg_label = np.append(ecg_label, [ecg_labels[e] for i in range(div)])\n    if ecg_data.size == 0:\n        ecg_data = np.vstack([np.array_split(ecg_signal, div)])\n    else:\n        ecg_data = np.vstack([ecg_data, np.array_split(ecg_signal, div)])\n\n# Removing mean component of the data\necg_data = np.array([data - np.mean(data) for data in ecg_data])\n\ndf_data = pd.DataFrame()\nfor i, data in enumerate(ecg_data):\n    df_data['data_' + str(i)] = data\n\nsave_dataset(df_data, 'ecg_data', extension = '.pkl', directory=dir_out)\ndf_data = load_dataset('ecg_data', extension = '.pkl', directory=dir_out)\n\ndf_data.head()","94d4745f":"Image(\"..\/input\/ecg-presentation\/Slayt5.JPG\")","191d2a35":"Image(\"..\/input\/ecg-presentation\/Slayt6.JPG\")","ff497f65":"Image(\"..\/input\/ecg-presentation\/Slayt7.JPG\")","85d5a6aa":"Image(\"..\/input\/ecg-presentation\/Slayt8.JPG\")","7520d927":"##############################################################\n################# Data visualization #########################\n##############################################################\n\n# Sample observation time, frequency ve autocorrelation graphs\ny = list(df_data['data_0'])\n\ntime = np.arange(0, len(y)) * (1 \/ f_s)\nplt.plot(time, y, linestyle='-', color='blue')\nplt.xlabel('Time [s]', fontsize=16)\nplt.ylabel('Amplitude', fontsize=16)\nplt.title('Signal', fontsize=16)\nplt.show()\n\nfrom scipy.fftpack import fft\nf, fft = get_fft(y, f_s)\nplt.plot(f, fft, linestyle='-', color='blue')\nplt.xlabel('Frequency [Hz]', fontsize=16)\nplt.ylabel('Amplitude', fontsize=16)\nplt.title('Frequency Transform', fontsize=16)\nplt.show()\n\nt, autocorr = get_autocorr(y, f_s)\nplt.plot(t, autocorr, linestyle='-', color='blue')\nplt.xlabel('Time [s]')\nplt.ylabel('Amplitude')\nplt.title('Autocorrelation', fontsize=16)\nplt.show()","cd5a6455":"Image(\"..\/input\/ecg-presentation\/Slayt9.JPG\")","a77547be":"Image(\"..\/input\/ecg-presentation\/Slayt10.JPG\")","642f869c":"Image(\"..\/input\/ecg-presentation\/Slayt11.JPG\")","d30d7efd":"# Sample observation time, frequency ve scaleogram graphs\nfrom scipy.fftpack import fft\nplot_time_freq_scaleogram(y, f_s)\n\n# Sample observation graphs\nwp = pywt.WaveletPacket(y,wave)\nplot_tree(wp)\nwpd_plt(df_data['data_0'])","36d324e3":"Image(\"..\/input\/ecg-presentation\/Slayt12.JPG\")","a9a4427c":"Image(\"..\/input\/ecg-presentation\/Slayt15.JPG\")","1c58d6ff":"##############################################################\n######### Discrete wavelet transform features ################\n##############################################################\n\ndf = pd.DataFrame()\nfeatures = []\nfor i in range(df_data.shape[1]):\n    f = []\n    coeff = pywt.wavedec(df_data['data_' + str(i)], wave)\n    for c in coeff:\n        f += get_features(c)\n    features.append(f)\n    print(str(i+1) + '\/' + str(df_data.shape[1]) + ' dwt coefficient features', end=\"\\r\")\ndf = pd.DataFrame(features)\ndf.columns = ['dwt_' + str(i) for i in range(df.shape[1])]\n\nsave_dataset(df, 'ecg_feature', extension = '.pkl', directory=dir_out)\ndf = load_dataset('ecg_feature', extension = '.pkl', directory=dir_out)\n\ndf.head()","9c9f7455":"Image(\"..\/input\/ecg-presentation\/Slayt13.JPG\")","154a945b":"Image(\"..\/input\/ecg-presentation\/Slayt14.JPG\")","ff4801c1":"Image(\"..\/input\/ecg-presentation\/Slayt16.JPG\")","511937b4":"##############################################################\n###### Wavelet packet transform best basis features ##########\n##############################################################\n\nbest_basis = []\nfor i in range(df_data.shape[1]):\n    wp, basis = get_best_basis(df_data['data_' + str(i)], wave)\n    best_basis.append(basis)\n    print(str(i + 1) + '\/' + str(df_data.shape[1]) + ', number of best basis: ' + str(len(basis)), end=\"\\r\")\n\nlen(best_basis)\n\nprint(\"\")\nwpbb_ = []\nfor i, bb in enumerate(best_basis):\n    print(str(i + 1) + '\/' + str(len(best_basis)) + ' wpt coefficient features', end=\"\\r\")\n    wpbb = []\n    entropy_list = []\n    entropy_list = np.array([shannon_entropy(p.data) for p in bb])\n    wpbb.append(np.sum(entropy_list))\n    wpbb.append(np.average(entropy_list))\n    wpbb.append(np.std(entropy_list))\n    wpbb.append(np.var(entropy_list))\n    for level in range(1,8):\n        entropy_list = []\n        entropy_list = np.array([shannon_entropy(p.data) for p in bb if len(p.path) == level])\n        if(len(entropy_list) ==0):\n            entropy_list = [0]\n        wpbb.append(np.sum(entropy_list))\n        wpbb.append(np.average(entropy_list))\n        wpbb.append(np.std(entropy_list))\n        wpbb.append(np.var(entropy_list))\n\n    power_list = []\n    power_list = np.array([np.sum((abs(p.data)) ** 2) for p in bb])\n    wpbb.append(np.sum(power_list))\n    wpbb.append(np.average(power_list))\n    wpbb.append(np.std(power_list))\n    wpbb.append(np.var(power_list))\n    for level in range(1,8):\n        power_list = []\n        power_list = np.array([np.sum((abs(p.data))) ** 2 for p in bb if len(p.path) == level])\n        if(len(power_list) ==0):\n            power_list = [0]\n        wpbb.append(np.sum(power_list))\n        wpbb.append(np.average(power_list))\n        wpbb.append(np.std(power_list))\n        wpbb.append(np.var(power_list))\n    wpbb_.append(wpbb)\n\nwpbb_a = np.array(wpbb_).T\nfor i in range(wpbb_a.shape[0]):\n    df['wpt_' + str(i)] = wpbb_a[i]\n\nsave_dataset(df, 'ecg_feature', extension = '.pkl', directory=dir_out)\ndf = load_dataset('ecg_feature', extension = '.pkl', directory=dir_out)\n\n# Plotting sample wavelet packet best basis tree\ny = list(df_data['data_0'])\nwp, best_basis = get_best_basis(y, wave)\nwpd_plt(df_data['data_0'], best_basis = [b.path for b in best_basis])\n\ndf.head()","807a6181":"Image(\"..\/input\/ecg-presentation\/Slayt17.JPG\")","162b30fc":"##############################################################\n###### Principal component analysis of the features ##########\n##############################################################\n\n# PCA model and fitting\ndf_pca = StandardScaler().fit_transform(df)\npca = PCA()\npca_fit = pca.fit_transform(df_pca)\npca.explained_variance_ratio_\nnp.cumsum(pca.explained_variance_ratio_)\n\n# Optimum component numbers\npca = PCA().fit(df_pca)\nplt.plot(np.cumsum(pca.explained_variance_ratio_))\nplt.xlabel(\"Component number\")\nplt.ylabel(\"Cumulative variance ratio\")\nplt.show()\n\n#Final PCA\npca = PCA(n_components=60) # optimum component number: 60\npca_fit = pca.fit_transform(df_pca)\n\npca.explained_variance_ratio_\nnp.cumsum(pca.explained_variance_ratio_) # explanability of 60 components: %95.\n\nfor i, pca in enumerate(pca_fit.T):\n    df['pca_' + str(i)] = pca\n\ndf.head()","3347cf4b":"##############################################################\n################## Adding target labels ######################\n##############################################################\n\ndf['y'] = LabelEncoder().fit_transform(ecg_label)\ndf['y_label'] = ecg_label\n\nsave_dataset(df, 'ecg_feature', extension = '.pkl', directory=dir_out)\ndf = load_dataset('ecg_feature', extension = '.pkl', directory=dir_out)\n\ndf.head()","92a3b818":"Image(\"..\/input\/ecg-presentation\/Slayt18.JPG\")","111b4ac4":"Image(\"..\/input\/ecg-presentation\/Slayt19.JPG\")","6425182f":"##############################################################\n################## Data preparation ##########################\n##############################################################\n\ndf = load_dataset('ecg_feature', extension = '.pkl', directory=dir_out)\n\nY = df['y']\nX_ = df.drop(['y', 'y_label'], axis=1)\nfor wpt in [col for col in X_.columns if 'wpt' in col]:\n    X_ = X_.drop(wpt, axis=1)\nfor dwt in [col for col in X_.columns if 'dwt' in col]:\n    X_ = X_.drop(dwt, axis=1)\n\nrs = RobustScaler()\nX = rs.fit_transform(X_)\n\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.20, random_state=0)\n\nY.head()","f9001545":"X_.head()","4d6f2588":"Image(\"..\/input\/ecg-presentation\/Slayt20.JPG\")","cb349cf1":"##############################################################\n################## Base Models ##########################\n##############################################################\n\nclassifiers = [('LR', LogisticRegression(solver='liblinear')),\n               ('KNN', KNeighborsClassifier()),\n               ('SVC', SVC()),\n               ('CART', DecisionTreeClassifier()),\n               ('RF', RandomForestClassifier()),\n               ('Adaboost', AdaBoostClassifier()),\n               ('GBM', GradientBoostingClassifier()),\n               ('LightGBM', LGBMClassifier()),\n               ]\n\nfor name, classifier in classifiers:\n    cv_results = cross_validate(classifier, X, Y, cv=3, scoring=['f1_micro', 'f1_macro', 'accuracy'], error_score=\"raise\")\n    print(f' ############# {name} #############')\n    print(f\" test accuracy: {round(cv_results['test_accuracy'].mean(), 4)} \")\n    print(f\" f1_micro: {round(cv_results['test_f1_micro'].mean(), 4)} \")\n    print(f\" f1_macro: {round(cv_results['test_f1_macro'].mean(), 4)} \")","94525798":"Image(\"..\/input\/ecg-presentation\/Slayt21.JPG\")","0fd507b7":"##############################################################\n############## Hyperparameter Optimization ###################\n##############################################################\n\nlr_params = {'C': [0.001, 0.01, 0.1, 1, 10]}\n\nsvc_params = {'C': [0.1, 1, 10, 100],\n              'gamma': [1, 0.1, 0.01, 0.001],\n              'kernel': ['rbf']}\n\ngbm_params = {'learning_rate': [0.001, 0.001, 0.1],\n              'max_depth': [3, 5, 8],\n              'n_estimators': [10, 50, 100],\n              'subsample': [0.5, 0.8, 1.0]}\n\nlightgbm_params = {'learning_rate': [0.01, 0.1],\n                   'n_estimators': [100, 200, 500],\n                   'colsample_bytree': [0.3, 0.5, 0.7]}\n\nclassifiers = [('LR', LogisticRegression(solver='liblinear'), lr_params),\n               ('SVC', SVC(), svc_params),\n               ('GBM', GradientBoostingClassifier(), gbm_params),\n               ('LightGBM', LGBMClassifier(), lightgbm_params)]\n\nbest_models = {}\n\nfor name, classifier, params in classifiers:\n    print(f'########## {name} Before ##########')\n    cv_results = cross_validate(classifier, X, Y, cv=3, scoring=['f1_micro', 'f1_macro', 'accuracy'])\n\n    print(f\" test accuracy : {round(cv_results['test_accuracy'].mean(), 4)} \")\n    print(f\" f1_micro : {round(cv_results['test_f1_micro'].mean(), 4)} \")\n    print(f\" f1_macro : {round(cv_results['test_f1_macro'].mean(), 4)} \")\n\n    print(f'########## {name} After ##########')\n    gs_best = GridSearchCV(classifier, params, cv=3, n_jobs=-1, verbose=False).fit(X, Y)\n    final_model = classifier.set_params(**gs_best.best_params_)\n\n    cv_results = cross_validate(final_model, X, Y, cv=3, scoring=['f1_micro', 'f1_macro', 'accuracy'])\n    print(f\" test accuracy : {round(cv_results['test_accuracy'].mean(), 4)}\")\n    print(f\" f1_micro : {round(cv_results['test_f1_micro'].mean(), 4)} \")\n    print(f\" f1_macro : {round(cv_results['test_f1_macro'].mean(), 4)} \")\n    print(f\"{name} best params: {gs_best.best_params_}\", end='\\n\\n')\n\n    best_models[name] = final_model","32196985":"##############################################################\n################### Plot Importance ##########################\n##############################################################\n\ndef plot_importance(model, features, num=len(X), save=False):\n    feature_imp = pd.DataFrame({'Value': model.feature_importances_, 'Feature': features.columns})\n    plt.figure(figsize=(10, 10))\n    sns.set(font_scale=1)\n    sns.barplot(x='Value', y='Feature', data=feature_imp.sort_values(by='Value', ascending=False)[0:num])\n    plt.title('Feature Importance List')\n    plt.tight_layout()\n    plt.show()\n    if save:\n        plt.savefig('importances.png')\n\n\nfinal_model_ = final_model.fit(X,Y)\nplot_importance(final_model_, X_, 15)","4c6cb5b9":"https:\/\/github.com\/atacanozkan\/ecg_classification"}}