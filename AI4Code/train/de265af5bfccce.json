{"cell_type":{"e20e9cdb":"code","c93ef297":"code","3bf2ad3f":"code","97a43675":"code","de2c46da":"code","612ba722":"code","182957ac":"code","45b8b12c":"code","6b245864":"code","1f3ac875":"code","adf1c91c":"code","bb250ba3":"code","467eeb0a":"code","508ad45d":"code","0fbc5659":"code","c67d7e18":"code","9bb50db4":"code","5911649c":"code","da1b87b2":"code","85b1e0ee":"code","e2249ab6":"code","7faf3b99":"code","652790cf":"code","535b3572":"markdown","43f55973":"markdown","e503e875":"markdown","0210b99b":"markdown","cd05607e":"markdown","67e33e01":"markdown","9eb0c868":"markdown"},"source":{"e20e9cdb":"import ast\nimport numba\nimport string\n\nimport numpy as np\nimport pandas as pd\n\nfrom itertools import combinations, permutations, product\nfrom math import sqrt, factorial\nfrom sklearn.neighbors import KDTree\nfrom sympy import isprime, primerange\nfrom tqdm import tqdm_notebook","c93ef297":"K = 4#!","3bf2ad3f":"def frunkopt_func_generator(K):\n    K = K - 1 # Dont look like that, K-Opt means, \n              # that we will remove K links between 2K points \n              # p1 - p2, p3 - p4, ..., p2K-1 - p2K\n              # so we will get K-1 unmoved segments\n              # p2..p3, p4..p5, ..., p2K-2..p2K-1\n    letters = np.array(list(string.ascii_uppercase[:K]))\n    i = 0\n    tab = '    '\n    function_name = f'move_{K+1}opt'\n    function_strings = []\n    function_strings.append(\"@numba.jit('void(i8[:], i8[:], i8)', nopython=True, parallel=False)\")\n    function_strings.append(f\"def {function_name}(path, idx, move_type):\")\n    function_strings.append(\"{}pslice = slice(idx[0]+1, idx[-1]+1)\".format(tab))\n    function_strings.append(\"{}{} = {}\".format(tab, ', '.join(letters), ', '.join([f'path[idx[{t}]+1:idx[{t+1}]+1]' for t in np.arange(K)])))\n    function_strings.append(\"{}{} = {}\".format(tab, ', '.join(string.ascii_lowercase[:K]), '[::-1], '.join(letters) + '[::-1]'))\n    for p in permutations(np.arange(K)):\n        for r in product([0, 1], repeat=K):\n            out_arr = [letters[j].lower() if r[j] else letters[j] for j in p]\n            function_strings.append('{}{} move_type == {}:'.format(tab, 'elif' if i else 'if', i))\n            function_strings.append(\"{}path[pslice] = np.concatenate(({}))\".format(tab * 2, ', '.join(out_arr)))\n            i += 1\n    return function_name, \"\"\"{}\"\"\".format('\\n'.join(function_strings))","97a43675":"frunktion_name, frunktion_body = frunkopt_func_generator(K)","de2c46da":"%%time\nexec(compile(ast.parse(frunktion_body), '<string>', mode='exec'))","612ba722":"frunkopt_move = locals()[frunktion_name]","182957ac":"cities = pd.read_csv(\n    '..\/input\/traveling-santa-2018-prime-paths\/cities.csv', \n    index_col=['CityId'])\n\nXY = np.stack(\n    (\n        cities.X.astype(np.float32), \n        cities.Y.astype(np.float32)\n    ), \n    axis=1)\n\nis_not_prime = np.array([0 if isprime(i) else 1 for i in cities.index], dtype=np.int32)","45b8b12c":"@numba.jit('f8(i8, i8, i8)', nopython=True, parallel=False)\ndef cities_dist(id_from, id_to, offset):\n    xy_from, xy_to = XY[id_from], XY[id_to]\n    dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n    distance = sqrt(dx * dx + dy * dy)\n    if offset % 10 == 9 and is_not_prime[id_from]:\n        return 1.1 * distance\n    return distance\n\n@numba.jit('f8(i8[:], i8)', nopython=True, parallel=False)\ndef chunk_score(chunk, offset):\n    pure_distance, penalty = 0.0, 0.0\n    penalty_modulo = 9 - offset % 10\n    for path_index in numba.prange(chunk.shape[0] - 1):\n        id_from, id_to = chunk[path_index], chunk[path_index+1]\n        xy_from, xy_to = XY[id_from], XY[id_to]\n        dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n        distance = sqrt(dx * dx + dy * dy)\n        pure_distance += distance\n        if path_index % 10 == penalty_modulo and is_not_prime[id_from]:\n            penalty += distance\n    return pure_distance + 0.1 * penalty\n\n\n@numba.jit('f8(i8[:])', nopython=True, parallel=False)\ndef path_score(path):\n    return chunk_score(path, 0)\n\ndef path_score_full(path):\n    pure_distance, penalty = 0.0, 0.0\n    penalty_modulo = 9\n    for path_index in numba.prange(path.shape[0] - 1):\n        id_from, id_to = path[path_index], path[path_index + 1]\n        xy_from, xy_to = XY[id_from], XY[id_to]\n        dx, dy = xy_from[0] - xy_to[0], xy_from[1] - xy_to[1]\n        distance = sqrt(dx * dx + dy * dy)\n        pure_distance += distance\n        if path_index % 10 == penalty_modulo and is_not_prime[id_from]:\n            penalty += distance\n    return (\n        round(pure_distance, 4), \n        round(0.1 * penalty, 4), \n        round(pure_distance + 0.1 * penalty, 4)\n    )","6b245864":"N_NEIGHBORS = 2*K + 2\nRADIUS = 3*K + 3","1f3ac875":"kdt = KDTree(XY[1:])\nneighbors_N = kdt.query(XY[1:], N_NEIGHBORS, return_distance=False)[:, :2*K-1]\nneighbors_R = kdt.query_radius(XY[1:], RADIUS, count_only=False, return_distance=False)","adf1c91c":"neighbors = set()\n\nfor city_id in tqdm_notebook(cities.index[1:]):\n    for neib_triplet in combinations(neighbors_N[city_id - 1] + 1, K):\n        neighbors.add(tuple(sorted(neib_triplet)))\n        \n    for neib_triplet in combinations(neighbors_R[city_id - 1][:N_NEIGHBORS-K+1] + 1, K):\n        neighbors.add(tuple(sorted(neib_triplet)))\n    \nprint(f'{len(neighbors)} cities {K}-neighbors are selected.')","bb250ba3":"@numba.jit('f8(i8[:])', nopython=True, parallel=False)\ndef sum_distance(ids):\n    res = 0\n    for i in numba.prange(len(ids)):\n        for j in numba.prange(i + 1, len(ids)):\n            res += cities_dist(ids[i], ids[j], 0)\n    return res","467eeb0a":"neighbors = np.array(list(neighbors))\ndistances = np.array(list(map(sum_distance, tqdm_notebook(neighbors))))\norder = distances.argsort()\nneighbors = neighbors[order]","508ad45d":"initial_path = pd.read_csv('..\/input\/dp-shuffle\/submission.csv').Path.values","0fbc5659":"path = initial_path.copy()\npath_index = np.argsort(path[:-1])\ninitial_score = total_score = path_score(path)\n\nprint(path_score_full(path))\nprint(f'Total score is {path_score(path):.2f}.')","c67d7e18":"frunkopt_moves_count = factorial(K - 1) * 2 ** (K - 1)\nprint(frunkopt_moves_count)","9bb50db4":"runs = 2\nneighbors_len = len(neighbors)\ncases_improved = np.zeros((runs, frunkopt_moves_count))","5911649c":"def make_submission(name, path):\n    pd.DataFrame({'Path': path}).to_csv(f'{name}.csv', index=False)","da1b87b2":"RADIUS","85b1e0ee":"for run in np.arange(1, runs + 1):\n    magic_number = K * (10 ** (RADIUS - N_NEIGHBORS + 1)) \/\/ run\n    print(f'Run #{run} | {magic_number}')\n    for step, ids in tqdm_notebook(enumerate(neighbors[:magic_number], 1), total=magic_number):\n        if step % 10 ** 6 == 0:\n            new_total_score = path_score(path)\n            last_improvement = total_score - new_total_score\n            print(f\"score {new_total_score:.2f} | last 10^6 {last_improvement:.2f} | total {initial_score - new_total_score:.2f}.\")\n            print(cases_improved[run - 1])\n            total_score = new_total_score\n            if last_improvement > K:\n                make_submission(f'frunkopt_{path_score(path):.4f}', path)\n\n        idx = sorted(path_index[ids])\n        new_idx = idx - idx[0]\n\n        pslice = slice(idx[0], idx[-1] + 2)\n        chunk = path[pslice]\n        best_score = chunk_score(chunk, idx[0])\n        best_move = -1\n        \n        for move_type in numba.prange(1, frunkopt_moves_count): # since move_type == 0 will not change chunk\n            new_chunk = chunk.copy()\n            frunkopt_move(new_chunk, new_idx, move_type)\n            new_score = chunk_score(new_chunk, idx[0])\n            if new_score < best_score:\n                best_score = new_score\n                best_move = move_type\n                best_chunk = new_chunk.copy()\n        \n        if best_move > -1:\n            path[pslice] = best_chunk\n            path_index = np.argsort(path[:-1])\n            cases_improved[run - 1, best_move] += 1\n","e2249ab6":"print(cases_improved)","7faf3b99":"total_score = path_score(path)\nprint(f'Total improvement | {initial_score - total_score:.2f}')\nprint('Final scores |', path_score_full(path))","652790cf":"make_submission(f'final_frunkopt_{path_score(path):.4f}', path)","535b3572":"Since we have `K - 1` tour's segments to manipulate, total number of legal moves is equal number of permutations `(K-1)!` multiplied by `2^(K-1)`, because each segment can be in 2 states: reversed or not.","43f55973":"I'm going to share fully automated K-Optimization :D","e503e875":"This is the main part of kernel. We will generate function for K-Opt move!","0210b99b":"That's all, good luck to all and happy kaggling!","cd05607e":"It's Alive!!!","67e33e01":"Since we get `frunktion_body`, we have to revive it. *abracadabra*","9eb0c868":"Then you know what to do :)"}}