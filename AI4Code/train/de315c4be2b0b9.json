{"cell_type":{"0874b4b0":"code","f8bf123c":"code","9482cb9c":"code","441381fa":"code","5e3df0c5":"code","294478b1":"code","0e8ff911":"code","06109306":"markdown","ce4c8840":"markdown","76a0654c":"markdown","ca3cfca9":"markdown","c5968169":"markdown","8785d562":"markdown","a8b60076":"markdown","b3c56d08":"markdown"},"source":{"0874b4b0":"# First step, import libraries.\nimport numpy as np \nimport pandas as pd \nfrom matplotlib import pyplot as plt","f8bf123c":"# Import the dataset and encode the date\ndf = pd.read_csv('..\/input\/coinbaseUSD_1-min_data_2014-12-01_to_2017-10-20.csv.csv')\ndf['date'] = pd.to_datetime(df['Timestamp'],unit='s').dt.date\ngroup = df.groupby('date')\nReal_Price = group['Weighted_Price'].mean()","9482cb9c":"# split data\nprediction_days = 30\ndf_train= Real_Price[:len(Real_Price)-prediction_days]\ndf_test= Real_Price[len(Real_Price)-prediction_days:]","441381fa":"# Data preprocess\ntraining_set = df_train.values\ntraining_set = np.reshape(training_set, (len(training_set), 1))\nfrom sklearn.preprocessing import MinMaxScaler\nsc = MinMaxScaler()\ntraining_set = sc.fit_transform(training_set)\nX_train = training_set[0:len(training_set)-1]\ny_train = training_set[1:len(training_set)]\nX_train = np.reshape(X_train, (len(X_train), 1, 1))","5e3df0c5":"# Importing the Keras libraries and packages\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\n\n# Initialising the RNN\nregressor = Sequential()\n\n# Adding the input layer and the LSTM layer\nregressor.add(LSTM(units = 4, activation = 'sigmoid', input_shape = (None, 1)))\n\n# Adding the output layer\nregressor.add(Dense(units = 1))\n\n# Compiling the RNN\nregressor.compile(optimizer = 'adam', loss = 'mean_squared_error')\n\n# Fitting the RNN to the Training set\nregressor.fit(X_train, y_train, batch_size = 5, epochs = 100)\n","294478b1":"# Making the predictions\ntest_set = df_test.values\ninputs = np.reshape(test_set, (len(test_set), 1))\ninputs = sc.transform(inputs)\ninputs = np.reshape(inputs, (len(inputs), 1, 1))\npredicted_BTC_price = regressor.predict(inputs)\npredicted_BTC_price = sc.inverse_transform(predicted_BTC_price)\n","0e8ff911":"# Visualising the results\nplt.figure(figsize=(25,15), dpi=80, facecolor='w', edgecolor='k')\nax = plt.gca()  \nplt.plot(test_set, color = 'red', label = 'Real BTC Price')\nplt.plot(predicted_BTC_price, color = 'blue', label = 'Predicted BTC Price')\nplt.title('BTC Price Prediction', fontsize=40)\ndf_test = df_test.reset_index()\nx=df_test.index\nlabels = df_test['date']\nplt.xticks(x, labels, rotation = 'vertical')\nfor tick in ax.xaxis.get_major_ticks():\n    tick.label1.set_fontsize(18)\nfor tick in ax.yaxis.get_major_ticks():\n    tick.label1.set_fontsize(18)\nplt.xlabel('Time', fontsize=40)\nplt.ylabel('BTC Price(USD)', fontsize=40)\nplt.legend(loc=2, prop={'size': 25})\nplt.show()","06109306":"* **Prediction**\n\nNotice that I only predict the price of the next day using the price today. Since there must be a lot of influence factors and it must have a lot of error when you predict a longer time.","ce4c8840":"* **Building the model **\n\nI build the RNN model using Keras. Choose some appropriate parameters","76a0654c":"*** Import the datasets.**\n\nSecond, import the dataset. After reviewing the dataset, I think I need to recode the datetime since it is better to use the dataset sorted by date not by minutes. Then I group the dataset by date and take the average price of all minutes in the day as the price of the day.","ca3cfca9":"* **Visualising**\n\nPlot the predicted price and the real price. Compare the diference. The difference is larger when the time is further to the training set. That is why I only want to predict the price of one month","c5968169":"**Thank you **","8785d562":"*** Split the dataset.** \n\nI want to predict the BTC price for a month, so I take the data of last 30 days as the test set","a8b60076":"*** Process Data**\n\nI feature scale the data and reshape it since I want to use Keras","b3c56d08":"* **Introduction**\n\nI am using RNN method to predict the BTC price. "}}