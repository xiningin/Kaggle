{"cell_type":{"8ec66ed8":"code","6ff691d0":"code","4cb30aaf":"code","d2e8a8e5":"code","02a63063":"code","653db29d":"code","c6d603b2":"code","203a34c7":"code","71d3e8e6":"code","3a4c3260":"code","61f8285a":"code","1513db43":"code","0774c826":"code","dcb18d45":"code","ba2907d3":"code","57dbf40c":"code","8c313d79":"code","46bf6d0e":"code","55477fc5":"code","c8776a03":"code","9e7375fb":"code","a03b599a":"code","2a8ea47d":"code","0df2d9e7":"code","6f68f68b":"code","8bf83370":"code","a5502215":"code","70e1966c":"code","b9ee7f6e":"code","af16b3a5":"code","6c629911":"code","902ccf9d":"code","2d8a1f2b":"code","c83be56e":"code","0232774b":"code","c0350dc9":"code","1c6d905b":"code","5b0c8fba":"markdown","80b75072":"markdown","f7c81c9d":"markdown","c63930c2":"markdown","f4f9f363":"markdown","811e210c":"markdown","0bf969a2":"markdown","a2581080":"markdown","d9e92e1e":"markdown","36cf385f":"markdown","1094f1c7":"markdown"},"source":{"8ec66ed8":"import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import  OneHotEncoder as ohe\nfrom sklearn.preprocessing import StandardScaler as ss\nfrom sklearn.compose import ColumnTransformer as ct\nfrom sklearn.impute import SimpleImputer\nfrom imblearn.over_sampling import SMOTE, ADASYN\nfrom sklearn.decomposition import PCA\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.model_selection import train_test_split\n\nfrom sklearn.ensemble import RandomForestClassifier as rf\nfrom sklearn.ensemble import ExtraTreesClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier as gbm\nfrom xgboost.sklearn import XGBClassifier\nimport lightgbm as lgb\n\n\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import auc, roc_curve\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import average_precision_score\nimport sklearn.metrics as metrics\nfrom xgboost import plot_importance\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.metrics import confusion_matrix\n\n\nfrom bayes_opt import BayesianOptimization\nfrom skopt import BayesSearchCV\nfrom eli5.sklearn import PermutationImportance\n\n\n%matplotlib inline","6ff691d0":"pd.options.display.max_columns = 200\n\n\ntrain = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')\n","4cb30aaf":"print(\"A glimpse at the columns of training data:\")\ntrain.head()","d2e8a8e5":"train.info()","02a63063":"target = train['Target']\ntarget.value_counts()","653db29d":"train.isnull().sum().sort_values(ascending=False).head()","c6d603b2":"train['v18q1'] = train['v18q1'].fillna(0)\ntest['v18q1'] = test['v18q1'].fillna(0)\ntrain['rez_esc'] = train['rez_esc'].fillna(0)\ntest['rez_esc'] = test['rez_esc'].fillna(0)\ntrain['SQBmeaned'] = train['SQBmeaned'].fillna(0)\ntest['SQBmeaned'] = test['SQBmeaned'].fillna(0)\ntrain['meaneduc'] = train['meaneduc'].fillna(0)\ntest['meaneduc'] = test['meaneduc'].fillna(0)\ntrain['v2a1'] = train['v2a1'].fillna(0)\ntest['v2a1'] = test['v2a1'].fillna(0)\n","203a34c7":"train.isnull().sum().sort_values(ascending=False).head()","71d3e8e6":"train.head()\n","3a4c3260":"def Target(a):\n    for i in a:\n        if  i==1:\n             Class.append('extreme poverty')\n        elif i==2:\n             Class.append('moderate poverty')\n        elif i==3:\n             Class.append('vulnerable households')\n        else:\n             Class.append('non vulnerable households')\n    return Class\n                          \nlst = list(train['Target'])\nClass=[]\nlist2 = Target(lst)\nlist2\ntrain['Class']=list2","61f8285a":"train.tail()","1513db43":"sns.countplot(\"Class\", data=train)\nplt.xticks(size=20,rotation=90)","0774c826":"plt.figure(figsize=(10,10))\n\nplt.subplot(2,2,1)\nsns.countplot(\"Class\",hue='v18q', data=train)\nplt.xticks(size=10,rotation=90)\nplt.title('Presence of Tablet in house hold')\n\nplt.subplot(2,2,2)\nsns.countplot(\"Class\",hue=\"refrig\", data=train)\nplt.xticks(size=10,rotation=90)\nplt.title('Presence of Refrigrator in house hold')\n\nplt.subplot(2,2,3)\nsns.countplot(\"Class\",hue=\"computer\", data=train)\nplt.xticks(size=10,rotation=90)\nplt.title('Presence of \"Computer\" in house hold')\n\nplt.subplot(2,2,4)\nsns.countplot(\"Class\",hue=\"television\", data=train)\nplt.xticks(size=10,rotation=90)\nplt.title('Presence of \"Television\" in house hold')\n\n","dcb18d45":"sns.countplot(\"tamhog\",hue=\"Class\", data=train)\n\nplt.title('Size of the house hold')","ba2907d3":"plt.figure(figsize=(10,10))\nplt.title('Presence of Tablet in house hold')\n\nplt.subplot(2,2,1)\nsns.countplot(\"hogar_nin\",hue='Class', data=train)\nplt.xticks(size=10,rotation=90)\nplt.xlabel('Children')\nplt.title('People distribution in House holds')\n\nplt.subplot(2,2,2)\nsns.countplot(\"hogar_adul\",hue='Class', data=train)\nplt.xticks(size=10,rotation=90)\nplt.xlabel('Adult')\nplt.title('People distribution in House holds')\n\nplt.subplot(2,2,3)\nsns.countplot(\"hogar_mayor\",hue='Class', data=train)\nplt.xticks(size=10,rotation=90)\nplt.xlabel('65+')\nplt.title('People distribution in House holds')\n","57dbf40c":"df_q = train[['Target', 'epared1', 'epared2', 'epared3', 'etecho1', 'etecho2', 'etecho3', 'eviv1', 'eviv2', 'eviv3']]\ndf_q.loc[df_q['epared1'] == 1, 'wall'] = 'Bad'\ndf_q.loc[df_q['epared2'] == 1, 'wall'] = 'Regular'\ndf_q.loc[df_q['epared3'] == 1, 'wall'] = 'Good'\n\ndf_q.loc[df_q['etecho1'] == 1, 'roof'] = 'Bad'\ndf_q.loc[df_q['etecho2'] == 1, 'roof'] = 'Regular'\ndf_q.loc[df_q['etecho3'] == 1, 'roof'] = 'Good'\n\ndf_q.loc[df_q['eviv1'] == 1, 'floor'] = 'Bad'\ndf_q.loc[df_q['eviv2'] == 1, 'floor'] = 'Regular'\ndf_q.loc[df_q['eviv3'] == 1, 'floor'] = 'Good'\n\ndf_q = df_q[['Target', 'wall', 'roof', 'floor']]","8c313d79":"print(\"Roof quality\")\nprint(\"==============================================================================================================================\")\ndf_q.loc[df_q['Target'] == 1, 'Target'] = 'Extreme'\ndf_q.loc[df_q['Target'] == 2,'Target'] = 'Moderate'\ndf_q.loc[df_q['Target'] == 3,'Target'] = 'Vulnerable'\ndf_q.loc[df_q['Target'] == 4,'Target'] = 'Non-Vulnerable'\nax = sns.catplot(x = 'roof', col = 'Target', data = df_q, kind=\"count\", col_order=['Extreme', 'Moderate', 'Vulnerable', 'Non-Vulnerable']).set_titles(\"{col_name}\")\nax.fig.set_size_inches(15,4)\nax.set(ylabel = '')\nplt.show()\n\nprint(\"Wall quality\")\nprint(\"==============================================================================================================================\")\n\nax = sns.catplot(x = 'wall', col = 'Target', data = df_q, kind=\"count\" ,col_order=['Extreme', 'Moderate', 'Vulnerable', 'Non-Vulnerable'], order = ['Bad', 'Regular', 'Good']).set_titles(\"{col_name}\")\nax.fig.set_size_inches(15,4)\nax.set(ylabel = '')\nplt.show()\n\nprint(\"Floor quality\")\nprint(\"==============================================================================================================================\")\n\nax = sns.catplot(x = 'floor', col = 'Target', data = df_q, kind=\"count\", col_order=['Extreme', 'Moderate', 'Vulnerable', 'Non-Vulnerable']).set_titles(\"{col_name}\")\nax.fig.set_size_inches(15,4)\nax.set(ylabel = '')\nplt.show()","46bf6d0e":"train.select_dtypes('object').head()","55477fc5":"yes_no_map = {'no':0,'yes':1}\ntrain['dependency'] = train['dependency'].replace(yes_no_map).astype(np.float32)\ntrain['edjefe'] = train['edjefe'].replace(yes_no_map).astype(np.float32)\ntrain['edjefa'] = train['edjefa'].replace(yes_no_map).astype(np.float32)\n    ","c8776a03":"train.drop(['Id','idhogar',\"dependency\",\"edjefe\",\"edjefa\"], inplace = True, axis =1)\n\ntest.drop(['Id','idhogar',\"dependency\",\"edjefe\",\"edjefa\"], inplace = True, axis =1)","9e7375fb":"\ntrain.drop(['Class'],inplace=True,axis=1)","a03b599a":"y = train.iloc[:,137]\ny.unique()","2a8ea47d":"X = train.iloc[:,1:138]\nX.shape","0df2d9e7":"my_imputer = SimpleImputer()\nX = my_imputer.fit_transform(X)\nscale = ss()\nX = scale.fit_transform(X)\npca = PCA(0.95)\nX = pca.fit_transform(X)","6f68f68b":"X_train, X_test, y_train, y_test = train_test_split(\n                                                    X,\n                                                    y,\n                                                    test_size = 0.2)","8bf83370":" \nmodelrf = rf()","a5502215":"import time\nstart = time.time()\nmodelrf = modelrf.fit(X_train, y_train)\nend = time.time()\n(end-start)\/60","70e1966c":"classes = modelrf.predict(X_test)","b9ee7f6e":"(classes == y_test).sum()\/y_test.size ","af16b3a5":"modelneigh = KNeighborsClassifier(n_neighbors=4)","6c629911":"start = time.time()\nmodelneigh = modelneigh.fit(X_train, y_train)\nend = time.time()\n(end-start)\/60","902ccf9d":"classes = modelneigh.predict(X_test)\n\nclasses\n(classes == y_test).sum()\/y_test.size ","2d8a1f2b":"modelgbm=gbm()\nstart = time.time()\nmodelgbm = modelgbm.fit(X_train, y_train)\nend = time.time()\n(end-start)\/60\n","c83be56e":"classes = modelgbm.predict(X_test)\n\nclasses\n(classes == y_test).sum()\/y_test.size ","0232774b":"modellgb = lgb.LGBMClassifier(max_depth=-1, learning_rate=0.1, objective='multiclass',\n                             random_state=None, silent=True, metric='None', \n                             n_jobs=4, n_estimators=5000, class_weight='balanced',\n                             colsample_bytree =  0.93, min_child_samples = 95, num_leaves = 14, subsample = 0.96)","c0350dc9":"start = time.time()\nmodellgb = modellgb.fit(X_train, y_train)\nend = time.time()\n(end-start)\/60","1c6d905b":"classes = modellgb.predict(X_test)\n\nclasses\n(classes == y_test).sum()\/y_test.size ","5b0c8fba":"Checking missing values ","80b75072":"Modelling with Light Gradient Booster","f7c81c9d":"Age groups among house holds","c63930c2":"GradientBoostingClassifier","f4f9f363":"Splitting the data into train & test","811e210c":"These are the core data fields as described in the [data description](https:\/\/www.kaggle.com\/c\/costa-rican-household-poverty-prediction\/data):\n\n* Id - a unique identifier for each row.\n* Target - the target is an ordinal variable indicating groups of income levels. \n    1 = extreme poverty \n    2 = moderate poverty \n    3 = vulnerable households \n    4 = non vulnerable households\n* idhogar - this is a unique identifier for each household. This can be used to create household-wide features, etc. All rows in a given household will have a matching value for this identifier.\n* parentesco1 - indicates if this person is the head of the household.\n","0bf969a2":"Random Forest","a2581080":"House holds with presence of 'Tablets in there house holds'..Not present=0, present =1","d9e92e1e":"KNeighborsClassifier","36cf385f":"FIlling missing values with 0","1094f1c7":" Data Analysis"}}