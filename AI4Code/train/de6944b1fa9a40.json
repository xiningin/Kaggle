{"cell_type":{"543e29d4":"code","a0ac587c":"code","1d51c4e9":"code","b892e909":"code","5bf9053b":"code","0d1298a8":"code","4979824e":"code","4ad5be83":"code","4587c6bd":"code","bf30eb89":"code","6a9afb74":"code","6a90eec3":"code","b9d63ae3":"code","1dd71cd7":"code","cf9d40fa":"code","04b0d528":"code","48eb09c4":"code","7cb3b19b":"code","5bb7156b":"code","a4c663ce":"code","f123b6d2":"code","bb7a4471":"code","95b633e3":"code","8662e474":"code","a83487d4":"code","f2e94019":"code","e8deb260":"code","8e401589":"code","4c90de01":"code","97c380a0":"code","25b37710":"code","c51f8887":"code","98988ba3":"code","1b5e9e95":"code","24f786f9":"code","4d40cdbf":"code","77a6cb1f":"code","e5f056a6":"code","58dcf86d":"code","79e089a6":"code","78653094":"code","420b5c3c":"code","c20afd37":"code","e564cee0":"code","1f8b790a":"code","c5b7dd6a":"code","0802c486":"code","6409505c":"code","6cf8b2e9":"code","df838c36":"code","3ce338ff":"code","4db3cb89":"code","610416c7":"code","52774027":"code","4255a7cc":"code","f20882a5":"code","52c26fdd":"code","b4c2c135":"code","c14f4e38":"code","78763206":"code","7848cab6":"code","cd074d23":"code","5f35d262":"code","95021bb6":"code","6332c498":"code","70cba799":"code","0afa3315":"code","0929e95f":"code","56426325":"markdown","46ed1a3e":"markdown","82a26b8f":"markdown","41d38f11":"markdown","7851aab9":"markdown","1c31b183":"markdown","68c30c36":"markdown","82bcdacc":"markdown","60a6a565":"markdown","03aa53c7":"markdown","8c95529e":"markdown","27b34c07":"markdown","298b7926":"markdown","9b785edf":"markdown","0a21c34f":"markdown","f9cc473b":"markdown","4cf7ca71":"markdown","5a7e3ebf":"markdown","da65a22c":"markdown","4c4e9b92":"markdown","fcc2202d":"markdown","9f895b5f":"markdown","3518003d":"markdown","bfe52c54":"markdown","0195734e":"markdown","ba3884a6":"markdown","4aba380c":"markdown","368c805f":"markdown","f5de5ec9":"markdown","8cc898ed":"markdown","7eb5e722":"markdown","30f44432":"markdown","933f6c0b":"markdown","ffff5c02":"markdown","3789609d":"markdown","ee4853d9":"markdown","f9c1edcd":"markdown","cf30e47a":"markdown","77914b87":"markdown","e83d60df":"markdown","678c069f":"markdown","5348ad41":"markdown","2d75557d":"markdown","11007cfc":"markdown","6796afaa":"markdown","ea235bd8":"markdown","e8f10557":"markdown","5e07fbaf":"markdown","17b74d5e":"markdown","24449d6c":"markdown","8ba17400":"markdown","cde56f36":"markdown","b8f46d31":"markdown","e7d1c7fc":"markdown","8997c885":"markdown","9b206b95":"markdown","38c69857":"markdown","bc24d576":"markdown","60226a1a":"markdown","ddf148cc":"markdown","0aa482fe":"markdown","c88ef90c":"markdown","de2ca196":"markdown","a2d81c3e":"markdown","2f85d7e8":"markdown","b71516e5":"markdown","ef9c39af":"markdown","f3acd257":"markdown","b1e57e74":"markdown","11a34c37":"markdown","613dc9eb":"markdown","f332f034":"markdown","2c5afa90":"markdown","2c877e3e":"markdown","9f2d7cd1":"markdown","91a41c5d":"markdown","ba25a2d8":"markdown","b31bdab3":"markdown","a34834c9":"markdown","f5b1f1c7":"markdown","6d7d6276":"markdown","877e3c2b":"markdown","bd355d0c":"markdown","fced98a5":"markdown","84793daa":"markdown","5b21ff86":"markdown","bffbf3c3":"markdown","045eab95":"markdown","27d03978":"markdown","94bb9282":"markdown","e270a797":"markdown"},"source":{"543e29d4":"import re    # for regular expressions \nimport nltk  # for text manipulation \nimport string \nimport warnings \nimport numpy as np \nimport pandas as pd \nimport seaborn as sns \nimport matplotlib.pyplot as plt","a0ac587c":"pd.set_option(\"display.max_colwidth\", 200) \nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning) \n\n%matplotlib inline","1d51c4e9":"import io\n\ntrain = pd.read_csv('..\/input\/twitter-sentiment-analysis-hatred-speech\/train.csv')\ntest  = pd.read_csv('..\/input\/twitter-sentiment-analysis-hatred-speech\/test.csv')","b892e909":"train[train['label'] == 0].head(10)","5bf9053b":"train[train['label'] == 1].head(10)","0d1298a8":"train.shape, test.shape","4979824e":"train[\"label\"].value_counts()","4ad5be83":"length_train = train['tweet'].str.len() \nlength_test = test['tweet'].str.len() \nplt.hist(length_train, bins=20, label=\"train_tweets\") \nplt.hist(length_test, bins=20, label=\"test_tweets\") \nplt.legend() \nplt.show()","4587c6bd":"combi = train.append(test, ignore_index=True) \ncombi.shape","bf30eb89":"def remove_pattern(input_txt, pattern):\n    r = re.findall(pattern, input_txt)\n    for i in r:\n        input_txt = re.sub(i, '', input_txt)\n    return input_txt ","6a9afb74":"combi['tidy_tweet'] = np.vectorize(remove_pattern)(combi['tweet'], \"@[\\w]*\") \ncombi.head()","6a90eec3":"combi['tidy_tweet'] = combi['tidy_tweet'].str.replace(\"[^a-zA-Z#]\", \" \") \ncombi.head(10)","b9d63ae3":"combi['tidy_tweet'] = combi['tidy_tweet'].apply(lambda x: ' '.join([w for w in x.split() if len(w)>3]))\ncombi.head()","1dd71cd7":"tokenized_tweet = combi['tidy_tweet'].apply(lambda x: x.split()) # tokenizing \ntokenized_tweet.head()","cf9d40fa":"from nltk.stem.porter import * \nstemmer = PorterStemmer() \ntokenized_tweet = tokenized_tweet.apply(lambda x: [stemmer.stem(i) for i in x]) # stemming\ntokenized_tweet.head()","04b0d528":"for i in range(len(tokenized_tweet)):\n    tokenized_tweet[i] = ' '.join(tokenized_tweet[i])    \ncombi['tidy_tweet'] = tokenized_tweet\ncombi['tidy_tweet'].head()","48eb09c4":"all_words = ' '.join([text for text in combi['tidy_tweet']]) \n\nfrom wordcloud import WordCloud \n\nwordcloud = WordCloud(width=800, height=500, random_state=21, max_font_size=110).generate(all_words) \nplt.figure(figsize=(10, 7)) \nplt.imshow(wordcloud, interpolation=\"bilinear\") \nplt.axis('off') \nplt.show()","7cb3b19b":"normal_words =' '.join([text for text in combi['tidy_tweet'][combi['label'] == 0]]) \nwordcloud = WordCloud(width=800, height=500, random_state=21, max_font_size=110).generate(normal_words) \nplt.figure(figsize=(10, 7)) \nplt.imshow(wordcloud, interpolation=\"bilinear\") \nplt.axis('off') \nplt.show()","5bb7156b":"negative_words = ' '.join([text for text in combi['tidy_tweet'][combi['label'] == 1]]) \nwordcloud = WordCloud(width=800, height=500, random_state=21, max_font_size=110).generate(negative_words) \nplt.figure(figsize=(10, 7))\nplt.imshow(wordcloud, interpolation=\"bilinear\") \nplt.axis('off') \nplt.show()","a4c663ce":"# function to collect hashtags \ndef hashtag_extract(x):    \n    hashtags = []    \n    # Loop over the words in the tweet    \n    for i in x:        \n        ht = re.findall(r\"#(\\w+)\", i)        \n        hashtags.append(ht)     \n    return hashtags","f123b6d2":"# extracting hashtags from non racist\/sexist tweets \nHT_regular = hashtag_extract(combi['tidy_tweet'][combi['label'] == 0]) \n\n# extracting hashtags from racist\/sexist tweets \nHT_negative = hashtag_extract(combi['tidy_tweet'][combi['label'] == 1]) \n\n# unnesting list \nHT_regular = sum(HT_regular,[]) \nHT_negative = sum(HT_negative,[])","bb7a4471":"a = nltk.FreqDist(HT_regular) \nd = pd.DataFrame({'Hashtag': list(a.keys()), 'Count': list(a.values())}) \n\n# selecting top 20 most frequent hashtags     \nd = d.nlargest(columns=\"Count\", n = 20)\n\nplt.figure(figsize=(16,5)) \nax = sns.barplot(data=d, x= \"Hashtag\", y = \"Count\") \nax.set(ylabel = 'Count') \nplt.show()","95b633e3":"b = nltk.FreqDist(HT_negative) \ne = pd.DataFrame({'Hashtag': list(b.keys()), 'Count': list(b.values())}) \n\n# selecting top 20 most frequent hashtags \ne = e.nlargest(columns=\"Count\", n = 20)   \nplt.figure(figsize=(16,5)) \nax = sns.barplot(data=e, x= \"Hashtag\", y = \"Count\")","8662e474":"from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer \nimport gensim","a83487d4":"bow_vectorizer = CountVectorizer(max_df=0.90, min_df=2, max_features=1000, stop_words='english') \nbow = bow_vectorizer.fit_transform(combi['tidy_tweet']) \nbow.shape","f2e94019":"tfidf_vectorizer = TfidfVectorizer(max_df=0.90, min_df=2, max_features=1000, stop_words='english') \ntfidf = tfidf_vectorizer.fit_transform(combi['tidy_tweet']) \ntfidf.shape","e8deb260":"tokenized_tweet = combi['tidy_tweet'].apply(lambda x: x.split()) # tokenizing \nmodel_w2v = gensim.models.Word2Vec(\n            tokenized_tweet,\n            size=200, # desired no. of features\/independent variables\n            window=5, # context window size\n            min_count=2,\n            sg = 1, # 1 for skip-gram model\n            hs = 0,\n            negative = 10, # for negative sampling\n            workers= 2, # no.of cores\n            seed = 34) \n\nmodel_w2v.train(tokenized_tweet, total_examples= len(combi['tidy_tweet']), epochs=20)","8e401589":"model_w2v.wv.most_similar(positive=\"dinner\")","4c90de01":"model_w2v.wv.most_similar(positive=\"trump\")","97c380a0":"def word_vector(tokens, size):\n    vec = np.zeros(size).reshape((1, size))\n    count = 0.\n    for word in tokens:\n        try:\n            vec += model_w2v[word].reshape((1, size))\n            count += 1.\n        except KeyError: # handling the case where the token is not in vocabulary                                     \n            continue\n    if count != 0:\n        vec \/= count\n    return vec","25b37710":"wordvec_arrays = np.zeros((len(tokenized_tweet), 200)) \nfor i in range(len(tokenized_tweet)):\n    wordvec_arrays[i,:] = word_vector(tokenized_tweet[i], 200)\n    wordvec_df = pd.DataFrame(wordvec_arrays) \n\nwordvec_df.shape","c51f8887":"from gensim.models.doc2vec import LabeledSentence","98988ba3":"def add_label(twt):\n    output = []\n    for i, s in zip(twt.index, twt):\n        output.append(LabeledSentence(s, [\"tweet_\" + str(i)]))\n    return output\nlabeled_tweets = add_label(tokenized_tweet) # label all the tweets","1b5e9e95":"labeled_tweets[:6]","24f786f9":"model_d2v = gensim.models.Doc2Vec(dm=1, # dm = 1 for \u2018distributed memory\u2019 model                                   \n                                  dm_mean=1, # dm = 1 for using mean of the context word vectors                                  \n                                  vector_size=200, # no. of desired features                                  \n                                  window=5, # width of the context window                                  \n                                  negative=7, # if > 0 then negative sampling will be used                                 \n                                  min_count=5, # Ignores all words with total frequency lower than 5.                                  \n                                  workers=3, # no. of cores                                  \n                                  alpha=0.1, # learning rate                                  \n                                  seed = 23)\nmodel_d2v.build_vocab([i for i in labeled_tweets])\nmodel_d2v.train(labeled_tweets, total_examples= len(combi['tidy_tweet']), epochs=15)","4d40cdbf":"docvec_arrays = np.zeros((len(tokenized_tweet), 200)) \nfor i in range(len(combi)):\n    docvec_arrays[i,:] = model_d2v.docvecs[i].reshape((1,200))    \n\ndocvec_df = pd.DataFrame(docvec_arrays) \ndocvec_df.shape","77a6cb1f":"from sklearn.linear_model import LogisticRegression \nfrom sklearn.model_selection import train_test_split \nfrom sklearn.metrics import f1_score","e5f056a6":"# Extracting train and test BoW features \ntrain_bow = bow[:31962,:] \ntest_bow = bow[31962:,:] \n\n# splitting data into training and validation set \nxtrain_bow, xvalid_bow, ytrain, yvalid = train_test_split(train_bow, train['label'], random_state=42, test_size=0.3)\nlreg = LogisticRegression() \n\n# training the model \nlreg.fit(xtrain_bow, ytrain) \n\nprediction = lreg.predict_proba(xvalid_bow) # predicting on the validation set \nprediction_int = prediction[:,1] >= 0.3 # if prediction is greater than or equal to 0.3 than 1 else 0 \nprediction_int = prediction_int.astype(np.int) \n\nf1_score(yvalid, prediction_int) # calculating f1 score for the validation set","58dcf86d":"train_tfidf = tfidf[:31962,:] \ntest_tfidf = tfidf[31962:,:] \n\nxtrain_tfidf = train_tfidf[ytrain.index] \nxvalid_tfidf = train_tfidf[yvalid.index]\n\nlreg.fit(xtrain_tfidf, ytrain) \n\nprediction = lreg.predict_proba(xvalid_tfidf) \nprediction_int = prediction[:,1] >= 0.3 \nprediction_int = prediction_int.astype(np.int) \n\nf1_score(yvalid, prediction_int) # calculating f1 score for the validation set","79e089a6":"train_w2v = wordvec_df.iloc[:31962,:] \ntest_w2v = wordvec_df.iloc[31962:,:] \n\nxtrain_w2v = train_w2v.iloc[ytrain.index,:]\nxvalid_w2v = train_w2v.iloc[yvalid.index,:]\n\nlreg.fit(xtrain_w2v, ytrain) \n\nprediction = lreg.predict_proba(xvalid_w2v) \nprediction_int = prediction[:,1] >= 0.3 \nprediction_int = prediction_int.astype(np.int) \n\nf1_score(yvalid, prediction_int)","78653094":"train_d2v = docvec_df.iloc[:31962,:] \ntest_d2v = docvec_df.iloc[31962:,:] \n\nxtrain_d2v = train_d2v.iloc[ytrain.index,:] \nxvalid_d2v = train_d2v.iloc[yvalid.index,:]\n\nlreg.fit(xtrain_d2v, ytrain) \n\nprediction = lreg.predict_proba(xvalid_d2v) \nprediction_int = prediction[:,1] >= 0.3 \nprediction_int = prediction_int.astype(np.int) \n\nf1_score(yvalid, prediction_int)","420b5c3c":"from sklearn import svm","c20afd37":"svc = svm.SVC(kernel='linear', C=1, probability=True).fit(xtrain_bow, ytrain) \n\nprediction = svc.predict_proba(xvalid_bow) \nprediction_int = prediction[:,1] >= 0.3 \nprediction_int = prediction_int.astype(np.int)\n\nf1_score(yvalid, prediction_int)","e564cee0":"svc = svm.SVC(kernel='linear', C=1, probability=True).fit(xtrain_tfidf, ytrain) \n\nprediction = svc.predict_proba(xvalid_tfidf) \nprediction_int = prediction[:,1] >= 0.3 \nprediction_int = prediction_int.astype(np.int) \n\nf1_score(yvalid, prediction_int)","1f8b790a":"svc = svm.SVC(kernel='linear', C=1, probability=True).fit(xtrain_w2v, ytrain) \n\nprediction = svc.predict_proba(xvalid_w2v) \nprediction_int = prediction[:,1] >= 0.3 \nprediction_int = prediction_int.astype(np.int) \n\nf1_score(yvalid, prediction_int)","c5b7dd6a":"svc = svm.SVC(kernel='linear', C=1, probability=True).fit(xtrain_d2v, ytrain) \n\nprediction = svc.predict_proba(xvalid_d2v) \nprediction_int = prediction[:,1] >= 0.3 \nprediction_int = prediction_int.astype(np.int) \n\nf1_score(yvalid, prediction_int)","0802c486":"from sklearn.ensemble import RandomForestClassifier","6409505c":"rf = RandomForestClassifier(n_estimators=400, random_state=11).fit(xtrain_bow, ytrain) \n\nprediction = rf.predict(xvalid_bow) \n\nf1_score(yvalid, prediction)","6cf8b2e9":"rf = RandomForestClassifier(n_estimators=400, random_state=11).fit(xtrain_tfidf, ytrain) \n\nprediction = rf.predict(xvalid_tfidf) \n\nf1_score(yvalid, prediction)","df838c36":"rf = RandomForestClassifier(n_estimators=400, random_state=11).fit(xtrain_w2v, ytrain) \n\nprediction = rf.predict(xvalid_w2v) \n\nf1_score(yvalid, prediction)","3ce338ff":"rf = RandomForestClassifier(n_estimators=400, random_state=11).fit(xtrain_d2v, ytrain) \n\nprediction = rf.predict(xvalid_d2v) \n\nf1_score(yvalid, prediction)","4db3cb89":"from xgboost import XGBClassifier","610416c7":"xgb_model = XGBClassifier(max_depth=6, n_estimators=1000).fit(xtrain_bow, ytrain) \n\nprediction = xgb_model.predict(xvalid_bow) \n\nf1_score(yvalid, prediction)","52774027":"xgb = XGBClassifier(max_depth=6, n_estimators=1000).fit(xtrain_tfidf, ytrain)\n\nprediction = xgb.predict(xvalid_tfidf) \n\nf1_score(yvalid, prediction)","4255a7cc":"xgb = XGBClassifier(max_depth=6, n_estimators=1000, nthread= 3).fit(xtrain_w2v, ytrain)\n\nprediction = xgb.predict(xvalid_w2v) \n\nf1_score(yvalid, prediction)","f20882a5":"xgb = XGBClassifier(max_depth=6, n_estimators=1000, nthread= 3).fit(xtrain_d2v, ytrain)\n\nprediction = xgb.predict(xvalid_d2v)\n\nf1_score(yvalid, prediction)","52c26fdd":"import xgboost as xgb","b4c2c135":"dtrain = xgb.DMatrix(xtrain_w2v, label=ytrain) \ndvalid = xgb.DMatrix(xvalid_w2v, label=yvalid) \ndtest = xgb.DMatrix(test_w2v)\n# Parameters that we are going to tune \nparams = {\n    'objective':'binary:logistic',\n    'max_depth':6,\n    'min_child_weight': 1,\n    'eta':.3,\n    'subsample': 1,\n    'colsample_bytree': 1\n }","c14f4e38":"def custom_eval(preds, dtrain):\n    labels = dtrain.get_label().astype(np.int)\n    preds = (preds >= 0.3).astype(np.int)\n    return [('f1_score', f1_score(labels, preds))]","78763206":"gridsearch_params = [\n    (max_depth, min_child_weight)\n    for max_depth in range(6,10)\n     for min_child_weight in range(5,8)\n ]","7848cab6":"max_f1 = 0.\nbest_params = None \nfor max_depth, min_child_weight in gridsearch_params:\n  print(\"CV with max_depth={}, min_child_weight={}\".format(max_depth, min_child_weight))\n  params['max_depth'] = max_depth\n  params['min_child_weight'] = min_child_weight\n  cv_results = xgb.cv(params, dtrain, feval= custom_eval, num_boost_round=200, maximize=True, seed=16, nfold=5, early_stopping_rounds=10)     \n  mean_f1 = cv_results['test-f1_score-mean'].max()\n  boost_rounds = cv_results['test-f1_score-mean'].argmax()    \n  print(\"\\tF1 Score {} for {} rounds\".format(mean_f1, boost_rounds))    \n  if mean_f1 > max_f1:\n    max_f1 = mean_f1\n    best_params = (max_depth,min_child_weight) \n\nprint(\"Best params: {}, {}, F1 Score: {}\".format(best_params[0], best_params[1], max_f1))","cd074d23":"params['max_depth'] = 7 \nparams['min_child_weight'] = 6","5f35d262":"gridsearch_params = [\n    (subsample, colsample)\n    for subsample in [i\/10. for i in range(5,10)]\n    for colsample in [i\/10. for i in range(5,10)] ]","95021bb6":"max_f1 = 0. \nbest_params = None \nfor subsample, colsample in gridsearch_params:\n  print(\"CV with subsample={}, colsample={}\".format(\n                             subsample,\n                             colsample))\n  params['colsample'] = colsample\n  params['subsample'] = subsample\n  cv_results = xgb.cv(params, dtrain, feval= custom_eval, num_boost_round=200, maximize=True, seed=16, nfold=5, early_stopping_rounds=10)\n  mean_f1 = cv_results['test-f1_score-mean'].max()\n  boost_rounds = cv_results['test-f1_score-mean'].argmax()\n  print(\"\\tF1 Score {} for {} rounds\".format(mean_f1, boost_rounds))\n  if mean_f1 > max_f1:\n    max_f1 = mean_f1\n    best_params = (subsample, colsample) \n\nprint(\"Best params: {}, {}, F1 Score: {}\".format(best_params[0], best_params[1], max_f1))","6332c498":"params['subsample'] = 0.8 \nparams['colsample_bytree'] = 0.5","70cba799":"max_f1 = 0. \nbest_params = None \nfor eta in [.3, .2, .1, .05, .01, .005]:\n    print(\"CV with eta={}\".format(eta))\n     # Update ETA\n    params['eta'] = eta\n\n     # Run CV\n    cv_results = xgb.cv(\n        params,\n        dtrain,\n        feval= custom_eval,\n        num_boost_round=1000,\n        maximize=True,\n        seed=16,\n        nfold=5,\n        early_stopping_rounds=20\n    )\n\n     # Finding best F1 Score\n    mean_f1 = cv_results['test-f1_score-mean'].max()\n    boost_rounds = cv_results['test-f1_score-mean'].argmax()\n    print(\"\\tF1 Score {} for {} rounds\".format(mean_f1, boost_rounds))\n    if mean_f1 > max_f1:\n        max_f1 = mean_f1\n        best_params = eta \nprint(\"Best params: {}, F1 Score: {}\".format(best_params, max_f1))","0afa3315":"params['eta'] = 0.1","0929e95f":"xgb_model = xgb.train(\n    params,\n    dtrain,\n    feval= custom_eval,\n    num_boost_round= 1000,\n    maximize=True,\n    evals=[(dvalid, \"Validation\")],\n    early_stopping_rounds=10\n )","56426325":"### 2. Removing Punctuations, Numbers, and Special Characters","46ed1a3e":"#### Preparing Vectors for Tweets","82a26b8f":"Let\u2019s play a bit with our Word2Vec model and see how does it perform. We will specify a word and the model will pull out the most similar words from the corpus","41d38f11":"We can see most of the words are positive or neutral. Words like love, great, friend, life are the most frequent ones. It doesn\u2019t give us any idea about the words associated with the racist\/sexist tweets. Hence, we will plot separate wordclouds for both the classes (racist\/sexist or not) in our train data.","7851aab9":"Given below is a user-defined function to remove unwanted text patterns from the tweets.","1c31b183":"Doc2Vec model is an unsupervised algorithm to generate vectors for sentence\/paragraphs\/documents. This approach is an extension of the word2vec. The major difference between the two is that doc2vec provides an additional context which is unique for every document in the corpus. This additional context is nothing but another feature vector for the whole document. This document vector is trained along with the word vectors.","68c30c36":"Here we will use nltk\u2019s PorterStemmer() function to normalize the tweets. But before that we will have to tokenize the tweets. Tokens are individual terms or words, and tokenization is the process of splitting a string of text into tokens.","82bcdacc":"TF-IDF works by penalising the common words by assigning them lower weights while giving importance to words which are rare in the entire corpus but appear in good numbers in few documents.\n\nLet\u2019s have a look at the important terms related to TF-IDF:\n\nTF = (Number of times term t appears in a document)\/(Number of terms in the document)\n\nIDF = log(N\/n), where, N is the number of documents and n is the number of documents a term t has appeared in.\n\nTF-IDF = TF*IDF","60a6a565":"Preparing doc2vec Feature Set","03aa53c7":"Let\u2019s check out a few non racist\/sexist tweets.","8c95529e":"## Modeling","27b34c07":"### A) Understanding the common words used in the tweets: WordCloud","298b7926":"Word embeddings are the modern way of representing words as vectors. The objective of word embeddings is to redefine the high dimensional word features into low dimensional feature vectors by preserving the contextual similarity in the corpus. They are able to achieve tasks like King -man +woman = Queen","9b785edf":"All these hashtags are positive and it makes sense. I am expecting negative terms in the plot of the second list. Let\u2019s check the most frequent hashtags appearing in the racist\/sexist tweets.","0a21c34f":"A wordcloud is a visualization wherein the most frequent words appear in large size and the less frequent words appear in smaller sizes.\n\nLet\u2019s visualize all the words our data using the wordcloud plot","f9cc473b":"In the train dataset, we have 2,242 (7%) tweets labeled as racist or sexist, and 29,720 (93%) tweets labeled as non racist\/sexist. So, it is an imbalanced classification challenge.\n\nNow we will check the distribution of length of the tweets, in terms of words, in both train and test data.","4cf7ca71":"### Bag-of-Words Features","5a7e3ebf":"### Doc2Vec Features","da65a22c":"## RandomForest","4c4e9b92":"## Results :","fcc2202d":"To implement doc2vec, we have to labelise or tag each tokenised tweet with unique IDs. We can do so by using Gensim\u2019s LabeledSentence() function.","9f895b5f":"## Data Cleaning","3518003d":"We will be following the steps below to clean the raw tweets in out data.\n\nWe will remove the twitter handles as they are already masked as @user due to privacy concerns. These twitter handles hardly give any information about the nature of the tweet.\n\nWe will also get rid of the punctuations, numbers and even special characters since they wouldn\u2019t help in differentiating different types of tweets.\n\nMost of the smaller words do not add much value. For example, \u2018pdx\u2019, \u2018his\u2019, \u2018all\u2019. So, we will try to remove them as well from our data.\n\nLastly, we will normalize the text data. For example, reducing terms like loves, loving, and lovable to their base word, i.e., \u2018love\u2019.are often used in the same context. If we can reduce them to their root word, which is \u2018love\u2019. It will help in reducing the total number of unique words in our data without losing a significant amount of information.","bfe52c54":"#### Racist\/Sexist Tweets","0195734e":"### Word2Vec Features","ba3884a6":"### Word2Vec Features","4aba380c":"Now let\u2019s stitch these tokens back together. It can easily be done using nltk\u2019s MosesDetokenizer function.","368c805f":"We are now done with all the pre-modeling stages required to get the data in the proper form and shape. We will be building models on the datasets with different feature sets prepared in the earlier sections \u2014 Bag-of-Words, TF-IDF, word2vec vectors, and doc2vec vectors. We will use the following algorithms to build models:\n\n- Logistic Regression\n- Support Vector Machine\n- RandomForest\n- XGBoost","f5de5ec9":"Word2Vec is not a single algorithm but a combination of two techniques \u2013 CBOW (Continuous bag of words) and Skip-gram model. Both of these are shallow neural networks which map word(s) to the target variable which is also a word(s). Both of these techniques learn weights which act as word vector representations.\n\nCBOW tends to predict the probability of a word given a context. A context may be a single adjacent word or a group of surrounding words. The Skip-gram model works in the reverse manner, it tries to predict the context for a given word.","8cc898ed":"Let\u2019s create a new column tidy_tweet, it will contain the cleaned and processed tweets. Note that we have passed \u201c@[]*\u201d as the pattern to the remove_pattern function. It is actually a regular expression which will pick any word starting with \u2018@\u2019.","7eb5e722":"### TF-IDF Features","30f44432":"### B) Words in non racist\/sexist tweets","933f6c0b":"|  | Logistic Regression | SVM      | RandomForest       | XGBoost       |\n|:--------:|  :-----------:  |  :-----------:  |  :-----------:  |  :-----------:  |\n| Bag of words      | 0.53       | 0.51       | 0.55       | 0.51       |\n| TF-IDF   | 0.55        | 0.51        | 0.56        | 0.52        |\n| Word2Vec | 0.61       | 0.62        | 0.50        | 0.65        |\n| Doc2Vec  | 0.39        | 0.16        | 0.07        | 0.34       |","ffff5c02":"Here we will use DMatrices. A DMatrix can contain both the features and the target.","3789609d":"Here we will replace everything except characters and hashtags with spaces. The regular expression \u201c[^a-zA-Z#]\u201d means anything except alphabets and \u2018#\u2019.","ee4853d9":"Hashtags in twitter are synonymous with the ongoing trends on twitter at any particular point in time. We should try to check whether these hashtags add any value to our sentiment analysis task, i.e., they help in distinguishing tweets into the different sentiments.","f9c1edcd":"The tweet seems sexist in nature and the hashtags in the tweet convey the same feeling.\n\nWe will store all the trend terms in two separate lists \u2014 one for non-racist\/sexist tweets and the other for racist\/sexist tweets.","cf30e47a":"Let\u2019s train a Word2Vec model on our corpus.","77914b87":"Since our data contains tweets and not just words, we\u2019ll have to figure out a way to use the word vectors from word2vec model to create vector representation for an entire tweet. There is a simple solution to this problem, we can simply take mean of all the word vectors present in the tweet. The length of the resultant vector will be the same, i.e. 200. We will repeat the same process for all the tweets in our data and obtain their vectors. Now we have 200 word2vec features for our data.\n\nWe will use the below function to create a vector for each tweet by taking the average of the vectors of the words present in the tweet.","e83d60df":"### 4. Text Normalization ","678c069f":"From the above two examples, we can see that our word2vec model does a good job of finding the most similar words for a given word. But how is it able to do so? That\u2019s because it has learned vectors for every unique word in our data and it uses cosine similarity to find out the most similar vectors (words).","5348ad41":"Now we have 200 new features, whereas in Bag of Words and TF-IDF we had 1000 features.","2d75557d":"### 1. Removing Twitter Handles (@user)","11007cfc":"## Bag-of-Words Features","6796afaa":"### TF-IDF Features","ea235bd8":"Now we can normalize the tokenized tweets.","e8f10557":"## Data Inspection","5e07fbaf":"## Logistic Regression","17b74d5e":"### Doc2Vec Features","24449d6c":"As we can clearly see, most of the words have negative connotations. So, it seems we have a pretty good text data to work on. Next we will the hashtags\/trends in our twitter data.","8ba17400":"We have to be a little careful here in selecting the length of the words which we want to remove. So, I have decided to remove all the words having length 3 or less. For example, terms like \u201chmm\u201d, \u201coh\u201d are of very little use. It is better to get rid of them.","cde56f36":"## TF-IDF Features","b8f46d31":"#### Tuning max_depth and min_child_weight","e7d1c7fc":"There are quite a many words and characters which are not really required. So, we will try to keep only those words which are important and add value.\n\nLet\u2019s check dimensions of the train and test dataset.","8997c885":"### 2. Doc2Vec Embedding","9b206b95":"### Doc2Vec Features","38c69857":"### C) Racist\/Sexist Tweets","bc24d576":"## Support Vector Machine (SVM)","60226a1a":"## Word2Vec Features","ddf148cc":"As expected, most of the terms are negative with a few neutral terms as well. So, it\u2019s not a bad idea to keep these hashtags in our data as they contain useful information. Next, we will try to extract features from the tokenized tweets.","0aa482fe":"#### Non-Racist\/Sexist Tweets","c88ef90c":"#### Now let\u2019s tune the learning rate.","de2ca196":"### TF-IDF Features","a2d81c3e":"### TF-IDF Features","2f85d7e8":"XGBoost with Word2Vec model has given us the best performance so far. Let\u2019s try to tune it further to extract as much from it as we can. XGBoost has quite a many tuning parameters and sometimes it becomes tricky to properly tune them. This is what we are going to do in the following steps.","b71516e5":"### General Approach for Parameter Tuning\n\nWe will follow the steps below to tune the parameters:\n\n- Choose a relatively high learning rate. Usually a learning rate of 0.3 is used at this stage.\n\n- Tune tree-specific parameters such as max_depth, min_child_weight, subsample, colsample_bytree keeping the learning rate fixed.\n\n- Tune the learning rate.\n\n- Finally tune gamma to avoid overfitting.","ef9c39af":"Now check out a few racist\/sexist tweets.","f3acd257":"### Word2Vec Features","b1e57e74":"## FineTuning XGBoost + Word2Vec","11a34c37":"You can see the difference between the raw tweets and the cleaned tweets (tidy_tweet) quite clearly. Only the important words in the tweets have been retained and the noise (numbers, punctuations, and special characters) has been removed.","613dc9eb":"Now that we have prepared our lists of hashtags for both the sentiments, we can plot the top \u2018n\u2019 hashtags. So, first let\u2019s check the hashtags in the non-racist\/sexist tweets.","f332f034":"Let\u2019s have a look at the result.","2c5afa90":"### 1. Word2Vec Embeddings","2c877e3e":"### Doc2Vec Features","9f2d7cd1":"Let\u2019s have a look at the final list of tuned parameters.\n\n{'colsample': 0.8,\n\n'colsample_bytree': 0.5, 'eta': 0.1,\n\n'max_depth': 7, 'min_child_weight': 6,\n\n'objective': 'binary:logistic',\n\n'subsample': 0.8}\n\nFinally we can now use these tuned parameters in our xgboost model. We have used early stopping of 10 which means if the model\u2019s performance doesn\u2019t improve under 10 rounds, then the model training will be stopped.","91a41c5d":"## XGBoost","ba25a2d8":"To analyse a preprocessed data, it needs to be converted into features. Depending upon the usage, text features can be constructed using assorted techniques \u2013 Bag of Words, TF-IDF, and Word Embeddings.","b31bdab3":"Before we begin exploration, we must think and ask questions related to the data in hand. A few probable questions are as follows:\n\n- What are the most common words in the entire dataset?\n- What are the most common words in the dataset for negative and positive tweets, respectively?\n- How many hashtags are there in a tweet?\n- Which trends are associated with my dataset?\n- Which trends are associated with either of the sentiments? Are they compatible with the sentiments?","a34834c9":"### Bag-of-Words Features","f5b1f1c7":"### D) Understanding the impact of Hashtags on tweets sentiment","6d7d6276":"## Data Visualization","877e3c2b":"Train set has 31,962 tweets and test set has 17,197 tweets.\n\nLet\u2019s have a glimpse at label-distribution in the train dataset.","bd355d0c":"### Bag-of-Words Features","fced98a5":"Most of the frequent words are compatible with the sentiment, i.e, non-racist\/sexists tweets. Similarly, we will plot the word cloud for the other sentiment. Expect to see negative, racist, and sexist terms.","84793daa":"Before we begin cleaning, let\u2019s first combine train and test datasets. Combining the datasets will make it convenient for us to preprocess the data. Later we will split it back into train and test data.","5b21ff86":"We will prepare a custom evaluation function to calculate F1 score.","bffbf3c3":"### Word2Vec Features","045eab95":"### Bag-of-Words Features","27d03978":"Now let\u2019s train a doc2vec model.","94bb9282":"### 3. Removing Short Words","e270a797":"> Evaluation Metric: \n       **F1 score** is being used as the evaluation metric. It is the weighted average of Precision and Recall. Therefore, this score takes both false positives and false negatives into account. It is suitable for uneven class distribution problems."}}