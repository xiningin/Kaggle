{"cell_type":{"870a094a":"code","3d069b28":"code","6f93b4f8":"code","659ee332":"code","524e5e0d":"code","017a7dd1":"code","2b6e5ec3":"code","03614376":"code","13ab2eca":"code","46407824":"code","5b5513c4":"code","0d9a5f3d":"code","c6ff468b":"code","22e035ab":"code","3453672c":"code","e9a99a9e":"code","c2c1892d":"code","06917312":"code","2f412666":"code","6884450e":"code","b98445bc":"code","b50fbcb9":"code","c1f5a749":"code","30733b60":"code","f32c5c26":"code","1286e1ed":"code","da500b64":"code","26754ca2":"code","02de1e23":"code","a6e2e135":"code","4e413337":"code","3a197e4d":"code","296938a4":"code","88e79b9e":"code","c93293b5":"code","adb98dfc":"code","8a821ac0":"code","a9b48292":"code","eae82da2":"code","c9d85575":"code","d8146d7f":"code","4a2d4295":"code","2e020dd0":"code","a8b8a1f7":"code","1dea05ee":"code","4c063149":"code","2166324c":"code","fd7b6f96":"code","5683566b":"code","992e4891":"code","d4bb540a":"code","0667d65d":"code","9e967be0":"code","6b2838fb":"code","b0bb4f05":"code","bccb347d":"code","5e98b8e6":"code","18927844":"code","8c0076d7":"code","fd0c3b60":"code","aed8f02f":"code","18659ea0":"markdown","2ffc144d":"markdown","6125484b":"markdown","e6519fa9":"markdown","ede794ad":"markdown","7d670849":"markdown","6f0db414":"markdown","145db07e":"markdown","0b1a0d8f":"markdown","679c1153":"markdown","f513d99e":"markdown","82e77abf":"markdown","5e230852":"markdown","7b69b80c":"markdown","0b92332d":"markdown","b4bd5a19":"markdown","7f0fd1c8":"markdown","d267b43d":"markdown","0fe3929e":"markdown","9256e402":"markdown","650ce67c":"markdown","94d9793d":"markdown","cbae38f6":"markdown","ded8dbfb":"markdown","310124d0":"markdown","cfeb76c9":"markdown","db5b17d4":"markdown","7d512dd3":"markdown","70bef3bd":"markdown","d2f7f8dc":"markdown","2b562038":"markdown","47377f17":"markdown","44707f4a":"markdown","6d5b5b8a":"markdown","44e25a4e":"markdown","f3c2cfd5":"markdown","32411068":"markdown","eb7d3e81":"markdown","3ee6ad70":"markdown","e8462211":"markdown","c936eeb5":"markdown","956d1067":"markdown","529468fc":"markdown","725ef429":"markdown","a7ef4199":"markdown","20dfed33":"markdown","909c5781":"markdown","2771f319":"markdown","ac9661e8":"markdown","b61327b1":"markdown","4d5dc06f":"markdown","768e8516":"markdown","5366124f":"markdown","c78b5962":"markdown","e7275d9a":"markdown","2f5f6256":"markdown","006aa612":"markdown","fa18895c":"markdown","651a2970":"markdown","ae49077f":"markdown"},"source":{"870a094a":"!conda install -c conda-forge gdcm -y","3d069b28":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport pydicom\nimport scipy.ndimage\nimport gdcm\n\nfrom skimage import measure \nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\nfrom skimage.morphology import disk, opening, closing\nfrom tqdm import tqdm\n\nfrom IPython.display import HTML\nfrom PIL import Image\n\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\nwarnings.filterwarnings(\"ignore\", category=FutureWarning)\n\nfrom os import listdir, mkdir","6f93b4f8":"listdir(\"..\/input\/\")","659ee332":"#basepath = \"..\/input\/osic-pulmonary-fibrosis-progression\/\"\n# or if you are taking part in RSNA pulmonary embolism detection:\nbasepath = \"..\/input\/rsna-str-pulmonary-embolism-detection\/\"\nlistdir(basepath)","524e5e0d":"train = pd.read_csv(basepath + \"train.csv\")\ntest = pd.read_csv(basepath + \"test.csv\")","017a7dd1":"train.shape","2b6e5ec3":"train.head()","03614376":"if basepath == \"..\/input\/osic-pulmonary-fibrosis-progression\/\":\n    train[\"dcm_path\"] = basepath + \"train\/\" + train.Patient + \"\/\"\nelse:\n    train[\"dcm_path\"] = basepath + \"train\/\" + train.StudyInstanceUID + \"\/\" + train.SeriesInstanceUID  ","13ab2eca":"def load_scans(dcm_path):\n    if basepath == \"..\/input\/osic-pulmonary-fibrosis-progression\/\":\n        # in this competition we have missing values in ImagePosition, this is why we are sorting by filename number\n        files = listdir(dcm_path)\n        file_nums = [np.int(file.split(\".\")[0]) for file in files]\n        sorted_file_nums = np.sort(file_nums)[::-1]\n        slices = [pydicom.dcmread(dcm_path + \"\/\" + str(file_num) + \".dcm\" ) for file_num in sorted_file_nums]\n    else:\n        # otherwise we sort by ImagePositionPatient (z-coordinate) or by SliceLocation\n        slices = [pydicom.dcmread(dcm_path + \"\/\" + file) for file in listdir(dcm_path)]\n        slices.sort(key = lambda x: float(x.ImagePositionPatient[2]))\n    return slices","46407824":"example = train.dcm_path.values[0]\nscans = load_scans(example)","5b5513c4":"scans[0]","0d9a5f3d":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nfor n in range(10):\n    image = scans[n].pixel_array.flatten()\n    rescaled_image = image * scans[n].RescaleSlope + scans[n].RescaleIntercept\n    sns.distplot(image.flatten(), ax=ax[0]);\n    sns.distplot(rescaled_image.flatten(), ax=ax[1])\nax[0].set_title(\"Raw pixel array distributions for 10 examples\")\nax[1].set_title(\"HU unit distributions for 10 examples\");","c6ff468b":"def transform_to_hu(slices):\n    images = np.stack([file.pixel_array for file in slices])\n    images = images.astype(np.int16)\n\n    # convert ouside pixel-values to air:\n    # I'm using <= -1000 to be sure that other defaults are captured as well\n    images[images <= -1000] = 0\n    \n    # convert to HU\n    for n in range(len(slices)):\n        \n        intercept = slices[n].RescaleIntercept\n        slope = slices[n].RescaleSlope\n        \n        if slope != 1:\n            images[n] = slope * images[n].astype(np.float64)\n            images[n] = images[n].astype(np.int16)\n            \n        images[n] += np.int16(intercept)\n    \n    return np.array(images, dtype=np.int16)","22e035ab":"hu_scans = transform_to_hu(scans)","3453672c":"fig, ax = plt.subplots(1,4,figsize=(20,3))\nax[0].set_title(\"Original CT-scan\")\nax[0].imshow(scans[0].pixel_array, cmap=\"bone\")\nax[1].set_title(\"Pixelarray distribution\");\nsns.distplot(scans[0].pixel_array.flatten(), ax=ax[1]);\n\nax[2].set_title(\"CT-scan in HU\")\nax[2].imshow(hu_scans[0], cmap=\"bone\")\nax[3].set_title(\"HU values distribution\");\nsns.distplot(hu_scans[0].flatten(), ax=ax[3]);\n\nfor m in [0,2]:\n    ax[m].grid(False)","e9a99a9e":"first_patient = load_slice('..\/input\/rsna-str-pulmonary-embolism-detection\/train\/0003b3d648eb\/d2b2960c2bbf')\nfirst_patient_pixels = transform_to_hu(first_patient)\n\ndef sample_stack(stack, rows=6, cols=6, start_with=10, show_every=5):\n    fig,ax = plt.subplots(rows,cols,figsize=[18,20])\n    for i in range(rows*cols):\n        ind = start_with + i*show_every\n        ax[int(i\/rows),int(i % rows)].set_title(f'slice {ind}')\n        ax[int(i\/rows),int(i % rows)].imshow(stack[ind],cmap='bone')\n        ax[int(i\/rows),int(i % rows)].axis('off')\n    plt.show()\n\nsample_stack(first_patient_pixels)","c2c1892d":"N = 100","06917312":"def get_window_value(feature):\n    if type(feature) == pydicom.multival.MultiValue:\n        return np.int(feature[0])\n    else:\n        return np.int(feature)\n\npixelspacing_r = []\npixelspacing_c = []\nslice_thicknesses = []\npatient_id = []\npatient_pth = []\nrow_values = []\ncolumn_values = []\nwindow_widths = []\nwindow_levels = []\n\nif basepath == \"..\/input\/osic-pulmonary-fibrosis-progression\/\":\n    patients = train.Patient.unique()[0:N]\nelse:\n    patients = train.SeriesInstanceUID.unique()[0:N]\n\nfor patient in patients:\n    patient_id.append(patient)\n    if basepath == \"..\/input\/osic-pulmonary-fibrosis-progression\/\":\n        path = train[train.Patient == patient].dcm_path.values[0]\n    else:\n        path = train[train.SeriesInstanceUID == patient].dcm_path.values[0]\n    example_dcm = listdir(path)[0]\n    patient_pth.append(path)\n    dataset = pydicom.dcmread(path + \"\/\" + example_dcm)\n    \n    window_widths.append(get_window_value(dataset.WindowWidth))\n    window_levels.append(get_window_value(dataset.WindowCenter))\n    \n    spacing = dataset.PixelSpacing\n    slice_thicknesses.append(dataset.SliceThickness)\n    \n    row_values.append(dataset.Rows)\n    column_values.append(dataset.Columns)\n    pixelspacing_r.append(spacing[0])\n    pixelspacing_c.append(spacing[1])\n    \nscan_properties = pd.DataFrame(data=patient_id, columns=[\"patient\"])\nscan_properties.loc[:, \"rows\"] = row_values\nscan_properties.loc[:, \"columns\"] = column_values\nscan_properties.loc[:, \"area\"] = scan_properties[\"rows\"] * scan_properties[\"columns\"]\nscan_properties.loc[:, \"pixelspacing_r\"] = pixelspacing_r\nscan_properties.loc[:, \"pixelspacing_c\"] = pixelspacing_c\nscan_properties.loc[:, \"pixelspacing_area\"] = scan_properties.pixelspacing_r * scan_properties.pixelspacing_c\nscan_properties.loc[:, \"slice_thickness\"] = slice_thicknesses\nscan_properties.loc[:, \"patient_pth\"] = patient_pth\nscan_properties.loc[:, \"window_width\"] = window_widths\nscan_properties.loc[:, \"window_level\"] = window_levels\nscan_properties.head()","2f412666":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(pixelspacing_r, ax=ax[0], color=\"Limegreen\", kde=False)\nax[0].set_title(\"Pixel spacing distribution \\n in row direction \")\nax[0].set_ylabel(\"Counts in train\")\nax[0].set_xlabel(\"mm\")\nsns.distplot(pixelspacing_c, ax=ax[1], color=\"Mediumseagreen\", kde=False)\nax[1].set_title(\"Pixel spacing distribution \\n in column direction\");\nax[1].set_ylabel(\"Counts in train\");\nax[1].set_xlabel(\"mm\");","6884450e":"counts = scan_properties.groupby([\"rows\", \"columns\"]).size()\ncounts = counts.unstack()\ncounts.fillna(0, inplace=True)\n\n\nfig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(slice_thicknesses, color=\"orangered\", kde=False, ax=ax[0])\nax[0].set_title(\"Slice thicknesses of all patients\");\nax[0].set_xlabel(\"Slice thickness in mm\")\nax[0].set_ylabel(\"Counts in train\");\n\nfor n in counts.index.values:\n    for m in counts.columns.values:\n        ax[1].scatter(n, m, s=counts.loc[n,m], c=\"midnightblue\")\nax[1].set_xlabel(\"rows\")\nax[1].set_ylabel(\"columns\")\nax[1].set_title(\"Pixel area of ct-scan per patient\");","b98445bc":"scan_properties[\"r_distance\"] = scan_properties.pixelspacing_r * scan_properties.rows\nscan_properties[\"c_distance\"] = scan_properties.pixelspacing_c * scan_properties[\"columns\"]\nscan_properties[\"area_cm2\"] = 0.1* scan_properties[\"r_distance\"] * 0.1*scan_properties[\"c_distance\"]\nscan_properties[\"slice_volume_cm3\"] = 0.1*scan_properties.slice_thickness * scan_properties.area_cm2","b50fbcb9":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(scan_properties.area_cm2, ax=ax[0], color=\"purple\")\nsns.distplot(scan_properties.slice_volume_cm3, ax=ax[1], color=\"magenta\")\nax[0].set_title(\"CT-slice area in $cm^{2}$\")\nax[1].set_title(\"CT-slice volume in $cm^{3}$\")\nax[0].set_xlabel(\"$cm^{2}$\")\nax[1].set_xlabel(\"$cm^{3}$\");","c1f5a749":"max_path = scan_properties[\n    scan_properties.area_cm2 == scan_properties.area_cm2.max()].patient_pth.values[0]\nmin_path = scan_properties[\n    scan_properties.area_cm2 == scan_properties.area_cm2.min()].patient_pth.values[0]\n\nmin_scans = load_scans(min_path)\nmin_hu_scans = transform_to_hu(min_scans)\n\nmax_scans = load_scans(max_path)\nmax_hu_scans = transform_to_hu(max_scans)\n\nbackground_water_hu_scans = max_hu_scans.copy()","30733b60":"def set_manual_window(hu_image, custom_center, custom_width):\n    w_image = hu_image.copy()\n    min_value = custom_center - (custom_width\/2)\n    max_value = custom_center + (custom_width\/2)\n    w_image[w_image < min_value] = min_value\n    w_image[w_image > max_value] = max_value\n    return w_image","f32c5c26":"fig, ax = plt.subplots(1,2,figsize=(20,10))\nax[0].imshow(set_manual_window(min_hu_scans[np.int(len(min_hu_scans)\/2)], -500, 1000), cmap=\"YlGnBu\")\nax[1].imshow(set_manual_window(max_hu_scans[np.int(len(max_hu_scans)\/2)], -500, 1000), cmap=\"YlGnBu\");\nax[0].set_title(\"CT-scan with small slice area\")\nax[1].set_title(\"CT-scan with large slice area\");\nfor n in range(2):\n    ax[n].axis(\"off\")","1286e1ed":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(max_hu_scans[np.int(len(max_hu_scans)\/2)].flatten(), kde=False, ax=ax[1])\nax[1].set_title(\"Large area image\")\nsns.distplot(min_hu_scans[np.int(len(min_hu_scans)\/2)].flatten(), kde=False, ax=ax[0])\nax[0].set_title(\"Small area image\")\nax[0].set_xlabel(\"HU values\")\nax[1].set_xlabel(\"HU values\");","da500b64":"max_path = scan_properties[\n    scan_properties.slice_volume_cm3 == scan_properties.slice_volume_cm3.max()].patient_pth.values[0]\nmin_path = scan_properties[\n    scan_properties.slice_volume_cm3 == scan_properties.slice_volume_cm3.min()].patient_pth.values[0]\n\nmin_scans = load_scans(min_path)\nmin_hu_scans = transform_to_hu(min_scans)\n\nmax_scans = load_scans(max_path)\nmax_hu_scans = transform_to_hu(max_scans)","26754ca2":"fig, ax = plt.subplots(1,2,figsize=(20,10))\nax[0].imshow(set_manual_window(min_hu_scans[np.int(len(min_hu_scans)\/2)], -500, 1000), cmap=\"YlGnBu\")\nax[1].imshow(set_manual_window(max_hu_scans[np.int(len(max_hu_scans)\/2)], -500, 1000), cmap=\"YlGnBu\");\nax[0].set_title(\"CT-scan with small slice volume\")\nax[1].set_title(\"CT-scan with large slice volume\");\nfor n in range(2):\n    ax[n].axis(\"off\")","02de1e23":"fig, ax = plt.subplots(1,2,figsize=(20,5))\nsns.distplot(max_hu_scans[np.int(len(max_hu_scans)\/2)].flatten(), kde=False, ax=ax[1])\nax[1].set_title(\"Large slice volume\")\nsns.distplot(min_hu_scans[np.int(len(min_hu_scans)\/2)].flatten(), kde=False, ax=ax[0])\nax[0].set_title(\"Small slice volume\")\nax[0].set_xlabel(\"HU values\")\nax[1].set_xlabel(\"HU values\");","a6e2e135":"def plot_3d(image, threshold=700, color=\"navy\"):\n    \n    # Position the scan upright, \n    # so the head of the patient would be at the top facing the camera\n    p = image.transpose(2,1,0)\n    \n    verts, faces,_,_ = measure.marching_cubes_lewiner(p, threshold)\n\n    fig = plt.figure(figsize=(10, 10))\n    ax = fig.add_subplot(111, projection='3d')\n\n    # Fancy indexing: `verts[faces]` to generate a collection of triangles\n    mesh = Poly3DCollection(verts[faces], alpha=0.2)\n    mesh.set_facecolor(color)\n    ax.add_collection3d(mesh)\n\n    ax.set_xlim(0, p.shape[0])\n    ax.set_ylim(0, p.shape[1])\n    ax.set_zlim(0, p.shape[2])\n\n    plt.show()","4e413337":"plot_3d(max_hu_scans)","3a197e4d":"old_distribution = max_hu_scans.flatten()","296938a4":"example = train.dcm_path.values[0]\nscans = load_scans(example)\nhu_scans = transform_to_hu(scans)","88e79b9e":"plot_3d(hu_scans)","c93293b5":"plt.figure(figsize=(20,5))\nsns.distplot(old_distribution, label=\"weak 3d plot\", kde=False)\nsns.distplot(hu_scans.flatten(), label=\"strong 3d plot\", kde=False)\nplt.title(\"HU value distribution\")\nplt.legend();","adb98dfc":"print(len(max_hu_scans), len(hu_scans))","8a821ac0":"def resample(image, scan, new_spacing=[1,1,1]):\n    # Determine current pixel spacing\n    spacing = np.array([scan[0].SliceThickness] + list(scan[0].PixelSpacing), dtype=np.float32)\n\n    resize_factor = spacing \/ new_spacing\n    new_real_shape = image.shape * resize_factor\n    new_shape = np.round(new_real_shape)\n    real_resize_factor = new_shape \/ image.shape\n    new_spacing = spacing \/ real_resize_factor\n    \n    image = scipy.ndimage.interpolation.zoom(image, real_resize_factor, mode='nearest')\n    \n    return image, new_spacing","a9b48292":"img_resampled, spacing = resample(max_hu_scans, scans, [1,1,1])\nprint(\"Shape before resampling\\t\", hu_scans.shape)\nprint(\"Shape after resampling\\t\", img_resampled.shape)","eae82da2":"def largest_label_volume(im, bg=-1):\n    vals, counts = np.unique(im, return_counts=True)\n\n    counts = counts[vals != bg]\n    vals = vals[vals != bg]\n\n    if len(counts) > 0:\n        return vals[np.argmax(counts)]\n    else:\n        return None\n    \ndef fill_lungs(binary_image):\n    image = binary_image.copy()\n    # For every slice we determine the largest solid structure\n    for i, axial_slice in enumerate(image):\n        axial_slice = axial_slice - 1\n        labeling = measure.label(axial_slice)\n        l_max = largest_label_volume(labeling, bg=0)\n\n        if l_max is not None: #This slice contains some lung\n            image[i][labeling != l_max] = 1\n    return image\n","c9d85575":"def segment_lung_mask(image):\n    segmented = np.zeros(image.shape)   \n    \n    for n in range(image.shape[0]):\n        binary_image = np.array(image[n] > -320, dtype=np.int8)+1\n        labels = measure.label(binary_image)\n        \n        background_label_1 = labels[0,0]\n        background_label_2 = labels[0,-1]\n        background_label_3 = labels[-1,0]\n        background_label_4 = labels[-1,-1]\n    \n        #Fill the air around the person\n        binary_image[background_label_1 == labels] = 2\n        binary_image[background_label_2 == labels] = 2\n        binary_image[background_label_3 == labels] = 2\n        binary_image[background_label_4 == labels] = 2\n    \n        #We have a lot of remaining small signals outside of the lungs that need to be removed. \n        #In our competition closing is superior to fill_lungs \n        selem = disk(4)\n        binary_image = closing(binary_image, selem)\n    \n        binary_image -= 1 #Make the image actual binary\n        binary_image = 1-binary_image # Invert it, lungs are now 1\n        \n        segmented[n] = binary_image.copy() * image[n]\n    \n    return segmented","d8146d7f":"plt.figure(figsize=(20,5))\nsns.distplot(hu_scans[20], kde=False)\nplt.title(\"Example HU value distribution\");\nplt.xlabel(\"HU-value\")\nplt.ylabel(\"count\")","4a2d4295":"binary_image = np.array((hu_scans[20]>-320), dtype=np.int8) + 1\nnp.unique(binary_image)","2e020dd0":"labels = measure.label(binary_image)\n\nbackground_label_1 = labels[0,0]\nbackground_label_2 = labels[0,-1]\nbackground_label_3 = labels[-1,0]\nbackground_label_4 = labels[-1,-1]","a8b8a1f7":"binary_image_2 = binary_image.copy()\nbinary_image_2[background_label_1 == labels] = 2\nbinary_image_2[background_label_2 == labels] = 2\nbinary_image_2[background_label_3 == labels] = 2\nbinary_image_2[background_label_4 == labels] = 2","1dea05ee":"fig, ax = plt.subplots(1,3,figsize=(20,7))\nax[0].imshow(binary_image, cmap=\"binary\", interpolation='nearest')\nax[1].imshow(labels, cmap=\"jet\", interpolation='nearest')\nax[2].imshow(binary_image_2, cmap=\"binary\", interpolation='nearest')\n\nax[0].set_title(\"Binary image\")\nax[1].set_title(\"Labelled image\");\nax[2].set_title(\"Binary image - background removed\");","4c063149":"selem = disk(4)\nclosed_binary_2 = closing(binary_image_2, selem)\n\nclosed_binary_2 -= 1 #Make the image actual binary\nclosed_binary_2 = 1-closed_binary_2 # Invert it, lungs are now 1","2166324c":"filled_lungs_binary = fill_lungs(binary_image_2)","fd7b6f96":"air_pocket_binary = closed_binary_2.copy()\n# Remove other air pockets insided body\nlabels_2 = measure.label(air_pocket_binary, background=0)\nl_max = largest_label_volume(labels_2, bg=0)\nif l_max is not None: # There are air pockets\n    air_pocket_binary[labels_2 != l_max] = 0","5683566b":"fig, ax = plt.subplots(1,3,figsize=(20,7))\n\nax[0].imshow(closed_binary_2, cmap=\"binary\", interpolation='nearest')\nax[1].imshow(filled_lungs_binary, cmap=\"binary\", interpolation='nearest')\nax[2].imshow(air_pocket_binary, cmap=\"binary\", interpolation='nearest')\n\n\nax[0].set_title(\"Morphological closing\");\nax[1].set_title(\"Guidos filling lung structures\");\nax[2].set_title(\"Guidos air pocket removal\");","992e4891":"segmented = segment_lung_mask(np.array([hu_scans[20]]))\n\nfig, ax = plt.subplots(1,2,figsize=(20,10))\nax[0].imshow(hu_scans[20], cmap=\"Blues_r\")\nax[1].imshow(segmented[0], cmap=\"Blues_r\");","d4bb540a":"segmented_lungs = segment_lung_mask(hu_scans)","0667d65d":"fig, ax = plt.subplots(6,5, figsize=(20,20))\nfor n in range(6):\n    for m in range(5):\n        ax[n,m].imshow(segmented_lungs[n*5+m], cmap=\"Blues_r\")","9e967be0":"plot_3d(segmented_lungs, threshold=-600)","6b2838fb":"image_sizes = scan_properties.groupby([\"rows\", \"columns\"]).size().sort_values(ascending=False)\nimage_sizes","b0bb4f05":"plt.figure(figsize=(8,8))\nfor n in counts.index.values:\n    for m in counts.columns.values:\n        plt.scatter(n, m, s=counts.loc[n,m], c=\"dodgerblue\", alpha=0.7)\nplt.xlabel(\"rows\")\nplt.ylabel(\"columns\")\nplt.title(\"Pixel area of ct-scan per patient\");\nplt.plot(np.arange(0,1400), '-.', c=\"purple\", label=\"squared\")\nplt.plot(888 * np.ones(1400), '-.', c=\"crimson\", label=\"888 rows\");\nplt.legend();","bccb347d":"class ImageObserver:\n    \n    def __init__(self, scan_properties, batch_size):\n        self.scan_properties = scan_properties\n        self.batch_size = batch_size\n    \n    def select_group(self, group=(512,512)):\n        self.group = group\n        self.name = \"rows {}, columns {}\".format(group[0], group[1])\n        self.batch_shape = (self.batch_size, group[0], group[1])\n        self.selection = self.scan_properties[\n            (self.scan_properties[\"rows\"]==group[0]) & (self.scan_properties[\"columns\"]==group[1])\n        ].copy()\n        self.patient_pths = self.selection.patient_pth.unique()\n    \n    \n    def get_loader(self):\n        \n        idx=0\n        images = np.zeros(self.batch_shape)\n        \n        for path in self.patient_pths:\n            \n            scans = load_scans(path)\n            hu_scans = transform_to_hu(scans)\n            images[idx,:,:] = hu_scans[0]\n            \n            idx += 1\n            if idx == self.batch_shape[0]:\n                yield images\n                images = np.zeros(self.batch_shape)\n                idx = 0\n        if idx > 0:\n            yield images","5e98b8e6":"my_choice = image_sizes.index.values[0]\nprint(my_choice)\nto_display = 4","18927844":"observer = ImageObserver(scan_properties, to_display)\nobserver.select_group(my_choice)\nobserver_iterator = observer.get_loader()","8c0076d7":"images = next(observer_iterator)","fd0c3b60":"fig, ax = plt.subplots(1,to_display,figsize=(20,5))\n\n\nfor m in range(to_display):\n    image = images[m]\n    ax[m].imshow(set_manual_window(image, -500, 1000), cmap=\"YlGnBu\")\n    ax[m].set_title(observer.name)","aed8f02f":"from IPython.display import HTML\nHTML('<center><iframe width=\"700\" height=\"400\" src=\"https:\/\/www.youtube.com\/embed\/KZld-5W99cI?rel=0&amp;controls=0&amp;showinfo=0\" frameborder=\"0\" allowfullscreen><\/iframe><\/center>')","18659ea0":"### Perspectives\n\n* La fermeture morphologique a mieux fonctionn\u00e9 que la m\u00e9thode Guidos. Mais il nous manque souvent beaucoup d'informations \u00e0 l'int\u00e9rieur des poumons, juste pour \u00e9liminer ces signaux corporels. Il y a certainement place pour des am\u00e9liorations ! ;-)\n* En revanche, la m\u00e9thode du fill-lung a des probl\u00e8mes avec les signaux restants du corps et ne donne pas ce que nous aimons obtenir.\n* En outre, l'\u00e9limination des poches d'air ne fonctionne pas bien non plus.\n\n","2ffc144d":"Le plot_3d fonctionne bien dans le Data Science Bowl 2017, mais dans notre cas, les r\u00e9sultats ne sont pas aussi bons. Cela d\u00e9pend du seuil, mais jusqu'\u00e0 pr\u00e9sent, je ne sais pas pourquoi nos reconstructions ont souvent l'air floues ou montrent aussi des r\u00e9gions du tube","6125484b":"Nous pouvons maintenant d\u00e9finir toutes les r\u00e9gions \u00e9tiquet\u00e9es de l'image binaire qui correspondent \u00e0 ces \u00e9tiquettes d'angle \u00e0 la valeur \"non poumon\" 2 ","e6519fa9":"Par rapport \u00e0 la version pr\u00e9c\u00e9dente, celle-ci est bien plus belle. Tra\u00e7ons les distributions. Peut-\u00eatre pouvons-nous comprendre ce qui ne va pas en les regardant :","ede794ad":"## Reconstruction 3D du CT-scans <a class=\"anchor\" id=\"reconstruction\"><\/a>","7d670849":"![](https:\/\/hopital-prive-saint-martin-caen.ramsaygds.fr\/sites\/default\/files\/styles\/article_header_desktop\/public\/pneumo_fibrose_pulmonaire.jpg?itok=WNqdaZFm)","6f0db414":"# Qu'est-ce que la fibrose pulmonaire ?","145db07e":"* Pour l'exemple de l'OSIC, nous pouvons trouver : Ihh... il \u00e9tait r\u00e9gl\u00e9 sur l'eau par d\u00e9faut dans la grande image... pourquoi ? ! C'est mauvais ! Nous devons trouver une strat\u00e9gie pour r\u00e9gler ce probl\u00e8me. Ce n'est pas bon que nous ayons parfois des r\u00e9gions ext\u00e9rieures qui ressemblent \u00e0 de l'\"eau\" et parfois des r\u00e9gions qui ressemblent \u00e0 de l'\"air\".","0b1a0d8f":"### Tri de nos tranches et cr\u00e9ation de GIF","679c1153":"Le r\u00e9sultat de ces \u00e9tapes se pr\u00e9sente comme suit ","f513d99e":"### La plus petite et la plus grande zone de coupe CT","82e77abf":"On voit que les valeurs varient vraiment beaucoup d'un patient \u00e0 l'autre ! Comme elles sont donn\u00e9es en mm et que les scans ct couvrent g\u00e9n\u00e9ralement 512 valeurs de lignes et de colonnes... **Nous pouvons calculer la distance minimale et maximale couverte par les images","5e230852":"\n#### **Quand parle-t-on de fibrose pulmonaire ?**\n\n    On parle de fibrose pulmonaire lorsque se d\u00e9veloppe dans le poumon du tissu fibreux qui remplace peu \u00e0 peu le tissu normal. Certaines fibroses pulmonaires r\u00e9sultent d\u2019une toxicit\u00e9 de m\u00e9dicaments ; d\u2019autres sont associ\u00e9es \u00e0 des maladies auto-immunes, c\u2019est-\u00e0-dire des maladies dans lesquelles notre syst\u00e8me immunitaire attaque nos organes.\n    Parfois, on ne retrouve pas de cause et on parle de \u00ab fibrose pulmonaire idiopathique \u00bb (FPI). La FPI est une maladie rare (1 personne sur 2 500 \u00e0 1 sur 7 000 personnes), d\u2019origine inexpliqu\u00e9e, qu\u2019on rencontre plus volontiers apr\u00e8s la soixantaine.\n\n#### **Comment se manifeste la fibrose pulmonaire ?**\n\n    La fibrose pulmonaire se traduit par un essoufflement progressif et une toux s\u00e8che. Les patients peuvent aussi pr\u00e9senter un amaigrissement, une perte d\u2019app\u00e9tit, une fatigue importante. Dans un cas sur deux, les doigts rev\u00eatent un aspect caract\u00e9ristique en baguette de tambour, avec des ongles bomb\u00e9s.\n\n\n#### **Comment diagnostique-t-on la fibrose pulmonaire ?**\n\n    Le diagnostic de fibrose pulmonaire est souvent difficile. \u00c0 l\u2019auscultation, le m\u00e9decin peut entendre des bruits pulmonaires \u00e9vocateurs.\n\n    La radiographie pulmonaire peut \u00eatre normale au d\u00e9but. Mais, le scanner visualise, dans un cas sur deux, les zones de fibrose sous forme d\u2019un aspect \u00ab en rayon de miel \u00bb.\n\n    Pour \u00e9carter d\u2019autres maladies (maladie li\u00e9e \u00e0 l\u2019amiante, silicose des mineurs), on pourra effectuer un lavage des bronches et des alv\u00e9oles, ce qui n\u00e9cessite une fibroscopie ; ce lavage permet de recueillir des cellules pulmonaires pour les analyser.\n\n    Parfois, une biopsie de poumon sera demand\u00e9e. Cet examen exige un geste chirurgical.\n    Afin d\u2019\u00e9valuer le degr\u00e9 de handicap respiratoire, on a recours \u00e0 un test de marche (capacit\u00e9 \u00e0 l\u2019effort), des \u00e9preuves fonctionnelles respiratoires (mesure du souffle), une mesure des gaz sanguins (oxyg\u00e8ne, gaz carbonique). \n","7b69b80c":"# G\u00e9n\u00e9ration d'un ensemble de donn\u00e9es pour les fichiers pr\u00e9trait\u00e9s <a class=\"anchor\" id=\"datagenerator\"><\/a>\n\n\n## Traitement des diff\u00e9rentes tailles d'images <a class=\"anchor\" id=\"image_sizes\"><\/a>\n\nPour g\u00e9n\u00e9rer les donn\u00e9es, nous devons r\u00e9examiner les diff\u00e9rentes tailles d'images : Pour l'OSIC, nous avons deux grands groupes de taille et quelques petites valeurs aberrantes. Par exemple, nous pourrions redimensionner ou recadrer manuellement les valeurs aberrantes et trouver une strat\u00e9gie pour les deux grands groupes. Examinons \u00e0 nouveau les tailles :","0b92332d":"Il suffit de relancer la cellule suivante, pour observer le prochain lot d'images :","b4bd5a19":"Maintenant, toutes les valeurs brutes par tranche sont mises \u00e0 l'\u00e9chelle des H-units.","7f0fd1c8":"### Insights\n\n* Les grandes tailles d'images carr\u00e9es pr\u00e9sentent souvent des r\u00e9solutions plus \u00e9lev\u00e9es qu'avec 512 lignes et 512 colonnes. Le redimensionnement en fonction des deux grands groupes (512, 512) ou (768, 768) est ici logique.\n* Dans les cas non carr\u00e9s, les cultures centrales devraient fonctionner au mieux car elles n'ont que des valeurs de fond plus importantes mais appartiennent toujours aux grands groupes de la r\u00e9gion du scanner interne.","d267b43d":"### Pixelspacing\n\n* L'attribut \"pixelspacing\" que vous pouvez trouver dans les fichiers dicom est important. Il nous indique la distance physique parcourue par un pixel. Vous pouvez voir qu'il n'y a que 2 valeurs qui d\u00e9crivent les directions x et y dans le plan d'une tranche transversale. \n* Pour un patient, cet espacement des pixels est g\u00e9n\u00e9ralement le m\u00eame pour toutes les tranches.\n* Mais entre les patients, l'espacement des pixels peut varier en raison des pr\u00e9f\u00e9rences personnelles ou institutionnelles des m\u00e9decins et de la clinique, et il d\u00e9pend \u00e9galement du type de scanner. Par cons\u00e9quent, si vous comparez deux images dans la taille des poumons, cela ne signifie pas automatiquement que la plus grande est vraiment plus grande dans la taille physique de l'organe !\n\nExaminons les distributions des largeurs et des hauteurs d'espacement des pixels des patients","0fe3929e":"Et voici \u00e0 quoi cela ressemble si nous masquons l'image originale avec les poumons binaires segment\u00e9s dans notre exemple en 2D","9256e402":"Je pense que nous devons comprendre l'algorithme de marching_cubes_lewiner pour comprendre pourquoi l'intrigue fonctionne parfois bien et parfois pas. Mais je pense que ce n'est pas vraiment important pour la comp\u00e9tition elle-m\u00eame. Pour l'instant, je n'aime pas passer plus de temps sur ce sujet. Il est peut-\u00eatre plus important de garder \u00e0 l'esprit que les distributions globales peuvent \u00eatre diff\u00e9rentes.","650ce67c":"### \u00c9paisseur de la tranche et surface des pixels\n\nL'\u00e9paisseur de la tranche nous indique la distance parcourue par une tranche dans la direction Z. Tra\u00e7ons \u00e9galement la distribution de celle-ci. En outre, le tableau de pixels des valeurs brutes couvre une zone sp\u00e9cifique donn\u00e9e par les valeurs des lignes et des colonnes. Examinons-le \u00e9galement","94d9793d":"## R\u00e9\u00e9chantillonnage de la taille des voxels","cbae38f6":"Avec -320, nous s\u00e9parons les poumons (-700) \/ l'air (-1000) et les tissus avec des valeurs proches de l'eau (0).","ded8dbfb":"Avant de commencer, tra\u00e7ons la distribution des pixels de certains fichiers dicom pour avoir une impression des donn\u00e9es brutes:","310124d0":"Maintenant, nous connaissons des quantit\u00e9s importantes pour calculer la distance physique couverte par un ct-scan !","cfeb76c9":"## Surface et volume de la tranche du CT-scan - EDA <a class=\"anchor\" id=\"scan_eda\"><\/a>","db5b17d4":"Examinons le premier fichier dicom de notre exemple de patient :","7d512dd3":"### Perspectives\n\n* En regardant une tranche de scan avec la plus petite et la plus grande surface, on peut voir que la grande tranche a beaucoup de r\u00e9gion inutile couverte. Nous pourrions la recadrer.\n* Bizarre... dans la deuxi\u00e8me image avec la grande surface, la r\u00e9gion ext\u00e9rieure du tube du scanner n'est pas r\u00e9gl\u00e9e sur la valeur de l'air mais plut\u00f4t sur une valeur situ\u00e9e au milieu de la plage de -1000 \u00e0 1000.","70bef3bd":"# References <a class=\"anchor\" id=\"references\"><\/a>","d2f7f8dc":"Pour quelques exemples, nous pouvons voir qu'il existe des valeurs brutes \u00e0 -2000. Elles correspondent \u00e0 des images ayant une limite circulaire \u00e0 l'int\u00e9rieur de l'image. L'\"ext\u00e9rieur\" de cette valeur circulaire est souvent fix\u00e9 par d\u00e9faut \u00e0 -2000 (ou dans d'autres concours, j'ai \u00e9galement trouv\u00e9 -3000).","2b562038":"Ce genre de mod\u00e8les \u00e9vidents vaut toujours la peine d'\u00eatre examin\u00e9. Peut-\u00eatre pouvons-nous trouver une sorte de r\u00e8gle qui nous permette de cr\u00e9er une bonne strat\u00e9gie de redimensionnement. Voici un petit observateur qui vous permet de parcourir les fichiers en ex\u00e9cutant \u00e0 nouveau la cellule de code :","47377f17":"### solution Finale","44707f4a":"Pour supprimer les signaux, nous pouvons utiliser la fermeture morphologique. Si vous aimez jouer avec la valeur du disque. Elle doit \u00eatre suffisamment grande pour annuler les signaux du corps mais suffisamment petite pour garder suffisamment de d\u00e9tails \u00e0 l'int\u00e9rieur des poumons","6d5b5b8a":"### Le plus petit et le plus grand volume de CT-slice","44e25a4e":"Comparons avec la m\u00e9thode de remplissage des poumons de Guidos:","f3c2cfd5":"### Perspectives\n\n1. La premi\u00e8re image montre le binaire brut. Dans ce cas, nous trouvons l'air comme arri\u00e8re-plan et nous devons le r\u00e9gler sur la valeur \"non poumon\" de 2.\n2. Pour cela, nous \u00e9tiquetons toutes les r\u00e9gions connect\u00e9es dans l'image binaire. Il existe de nombreuses r\u00e9gions \u00e9tiquet\u00e9es, mais les seules qui nous int\u00e9ressent sont les 4 r\u00e9gions d'angle \u00e0 (0,0), (0,500), (500,0) et (500,500).\n3. La connaissance des \u00e9tiquettes correspondantes nous aide \u00e0 r\u00e9gler manuellement le fond \u00e0 la valeur 2 (noir).\n4. Au final, nous pouvons voir que les poumons sont blancs (1), mais nous trouvons encore beaucoup de signaux restants qui correspondent \u00e0 des tissus corporels qu'il nous faut encore enlever.","32411068":"Les poumons ont des valeurs de 1 ainsi que les milieux atmosph\u00e9riques. En revanche, les milieux par d\u00e9faut semblables \u00e0 ceux de l'eau et de nombreux autres tissus ou fluides organiques ont des valeurs de 2. Comme nous aimons seulement segmenter les poumons, nous devons \u00e9liminer le milieu. Dans le cas de l'air et des valeurs par d\u00e9faut similaires \u00e0 l'air, nous devons d\u00e9finir manuellement leurs valeurs \u00e0 2. Nous pouvons le faire en \u00e9tiquetant les r\u00e9gions connect\u00e9es dans l'image binaire et en extrayant les \u00e9tiquettes de chaque r\u00e9gion qui correspond aux coins de la tranche d'image 2D ","eb7d3e81":"# Travailler avec des fichiers dicom <a class=\"anchor\" id=\"dicom\"><\/a>","3ee6ad70":"## Tissue segmentation <a class=\"anchor\" id=\"segmentation\"><\/a>","e8462211":"am\u00e9liorer la segmentation","c936eeb5":"## Chargement des CT-scans par patient <a class=\"anchor\" id=\"ct_scans\"><\/a>\n\n* Pour charger le scan 3D complet, nous devons commander les fichiers\/tranches dicom uniques par \"ImagePositionPatient\": ","956d1067":"Il est int\u00e9ressant de noter que nous avons encore quelques signaux en dehors des poumons","529468fc":"## Table of contents\n\n1. [Qu'est-ce que la fibrose pulmonaire ?](#fibrosis)\n2. [References](#references)\n    * [Data Science Bowl 2017 - Preprocessing Tutorial by Guido Zuidhof](#bowl_2017)\n    * [Papers](#papers)\n2. [Data paths](#prepare)\n3. [Travailler avec des fichiers dicom](#dicom)\n    * [Chargement des CT-scans par patient](#ct_scans)\n    * [Transformation en unit\u00e9s Hounsfield](#hunits)\n    * [La taille des voxels](#voxel)\n    * [Surface et volume de la tranche du CT-scan - EDA](#scan_eda)\n    * [Reconstruction 3D des scanners](#reconstruction)\n    * [Segmentation des tissus](#segmentation)\n4. [G\u00e9n\u00e9ration d'un ensemble de donn\u00e9es pour les fichiers pr\u00e9trait\u00e9s](#datagenerator)\n    * [Lien vers le data-set](https:\/\/www.kaggle.com\/allunia\/osic-pulmonary-fibrosis-progression-huscans)","725ef429":"Et avec la suppression de sa poche d'air ","a7ef4199":"* Des tranches tr\u00e8s fines permettent de montrer plus de d\u00e9tails. En revanche, les tranches \u00e9paisses contiennent moins de bruit mais sont plus sujettes aux artefacts. Hmm... Je suis tr\u00e8s excit\u00e9 de voir quelques exemples ici aussi. \n* M\u00eame s'il est courant d'avoir des zones de taille 512x512 pixels, on peut voir que ce n'est pas toujours vrai ! On peut trouver beaucoup d'exceptions et m\u00eame une ou quelques tr\u00e8s grandes zones de pixels (1300x1300) ! !! (OSIC)\n* Un pr\u00e9traitement correct de ces scans pourrait \u00eatre tr\u00e8s important... nous devons le v\u00e9rifier.","20dfed33":"je ne vois pas une grande diff\u00e9rence. Peut-\u00eatre que celle avec le grand volume de la tranche semble un peu plus floue. Mais comme ci-dessus, il y a une r\u00e9gion du scanner ext\u00e9rieur qui a \u00e9t\u00e9 r\u00e9gl\u00e9e sur la valeur de l'eau (valeur HU de 0) au lieu de celle de l'air.","909c5781":"## La taille des voxels <a class=\"anchor\" id=\"voxel\"><\/a>\n\nLe voxel repr\u00e9sente le pixel 3D qui est donn\u00e9 dans un scanner. Pour autant que je sache, il est couvert par le plan 2D de l'attribut d'espacement des pixels dans les directions x et y et par l'\u00e9paisseur de la tranche dans la direction z.","2771f319":"Vous pouvez voir que celui-ci est tr\u00e8s diff\u00e9rent de celui-l\u00e0","ac9661e8":"# Data paths <a class=\"anchor\" id=\"prepare\"><\/a>","b61327b1":"### information\n\n1. Le CT-scan capture des informations sur la radiodensit\u00e9 d'un objet ou d'un tissu expos\u00e9 aux rayons X. Une tranche transversale d'un scan est reconstitu\u00e9e apr\u00e8s avoir pris des mesures dans plusieurs directions diff\u00e9rentes.\n2. Nous devons passer \u00e0 des unit\u00e9s Hounsfield car la composition spectrale des rayons X d\u00e9pend des param\u00e8tres de mesure tels que les param\u00e8tres d'acquisition et la tension du tube. En se normalisant aux valeurs de l'eau et de l'air (l'eau a un HU 0 et l'air -1000), les images des diff\u00e9rentes mesures deviennent comparables.\n3. Un ct-scanner donne environ 4000 valeurs de gris qui ne peuvent pas \u00eatre captur\u00e9es par nos yeux. C'est pourquoi on proc\u00e8de \u00e0 un fen\u00eatrage. De cette fa\u00e7on, l'image est affich\u00e9e dans une plage de HU qui correspond le mieux \u00e0 la r\u00e9gion d'int\u00e9r\u00eat. ","4d5dc06f":"Pour l'OSIC, il est int\u00e9ressant de constater que nous avons deux types de mod\u00e8les diff\u00e9rents. Dans la comp\u00e9tition RSNA, toutes les images d'entra\u00eenement sont de forme 512, 512. Vous n'avez donc pas besoin d'explorer davantage les tailles des images. Mais peut-\u00eatre est-il encore utile de parcourir les images pour trouver des id\u00e9es de bonnes augmentations.","768e8516":"Pour acc\u00e9l\u00e9rer le calcul, j'ai s\u00e9lectionn\u00e9 N patients \u00e0 prendre en consid\u00e9ration. Utilisez N = train.shape [0] pour le faire pour tous les patients de l'ensemble de donn\u00e9es","5366124f":"## Zone physique et volume de la tranche couverts par un seul ct-scan","c78b5962":"Nous avons des images avec des zones et des volumes de sliches extr\u00eamement larges","e7275d9a":"\n\n* [Intrinsic dependencies of CT radiomic features on voxel size and number of gray levels](https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC5462462\/)","2f5f6256":"### Comprendre la segmentation \u00e9tape par \u00e9tape:","006aa612":"### pour en savoir plus sur les unit\u00e9s Hounsfield","fa18895c":"## Transformation en unit\u00e9s Hounsfield <a class=\"anchor\" id=\"hunits\"><\/a>","651a2970":"Et nous pouvons \u00e9galement v\u00e9rifier l'aspect de l'affaire 3D","ae49077f":"Let's load the csv-files:"}}