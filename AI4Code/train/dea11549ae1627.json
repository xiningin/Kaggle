{"cell_type":{"aea26f40":"code","30a3aa0e":"code","a491b245":"code","7bef05a1":"code","ee7f8181":"code","9f940f06":"code","24c90d0f":"code","e46aad65":"code","3a78ea1b":"code","2adba6b9":"code","0bdf4936":"code","c30d1e4f":"code","114b5fd2":"code","2a1811cb":"code","d7b8c2d0":"code","33225200":"code","29d25aaf":"code","1f79dcbd":"code","fbc718b4":"code","88c12bc0":"code","072faab6":"code","abcb7823":"code","d9bbceae":"markdown","ea38a439":"markdown","a83b5158":"markdown","05678b8e":"markdown","d2277967":"markdown","be517bac":"markdown","f43a4b28":"markdown"},"source":{"aea26f40":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","30a3aa0e":"pip install snap-stanford","a491b245":"import snap\nimport pandas as pd\nimport numpy as np\nimport os\nimport glob\nfrom IPython.display import Image\nimport matplotlib.image as mpimg\nimport warnings\nwarnings.filterwarnings('ignore')\nimport matplotlib.pyplot as plt\n%matplotlib inline","7bef05a1":"motifs_folder = '\/kaggle\/input\/cs224whw2018\/'","ee7f8181":"# Small graph for testing\ndef test_esu_graph():\n    G = snap.TNGraph.New()\n\n    for i in range(1, 10):\n        G.AddNode(i)\n\n    labels = snap.TIntStrH()\n\n    for Node in G.Nodes():\n        labels[Node.GetId()] = str(Node.GetId())\n\n    G.AddEdge(1, 2)\n    G.AddEdge(2, 3)\n    G.AddEdge(1, 3)\n    G.AddEdge(1, 4)\n    G.AddEdge(1, 5)\n    G.AddEdge(8, 3)\n    G.AddEdge(9, 3)\n    G.AddEdge(2, 7)\n    G.AddEdge(2, 6)\n    return G\ndef draw_graph(G, fileout, show = True):\n    labels = snap.TIntStrH()\n    for Node in G.Nodes():\n        labels[Node.GetId()] = str(Node.GetId())\n    snap.DrawGViz(G, snap.gvlNeato, fileout, 'G', labels)\n    if show:\n        plt.imshow(mpimg.imread(fileout)); plt.axis('off')\n        plt.show()","9f940f06":"G = test_esu_graph()\ndraw_graph(G, 'test_esu.png')","24c90d0f":"def gen_config_model_rewire(G, N_iter, computeCls=True):\n    \"\"\"\n    perform rewiring in graph\n    N - number of tries for rewiring\n    @param G: snap graph\n    @param N_iter: Int, number of rewiring\n    @param computeCls: bool, true for compute clustering coefficient\n    @return: snap graph\n    \"\"\"\n    G_rew = G\n    edge_list = [edge.GetId() for edge in G_rew.Edges()]\n    num_edges = len(edge_list)\n    clustCoefs = []\n    counter, n_shots = 0, 0\n    while counter < N_iter and n_shots < 100000:\n\n        n_shots += 1\n        ix1, ix2 = np.random.randint(num_edges, size=2)\n        e1, e2 = edge_list[ix1], edge_list[ix2]\n        u, v = np.random.choice(e1, size=2, replace=False)\n        w, x = np.random.choice(e2, size=2, replace=False)\n        no_self_loops = u != w and v != x\n        is_edges = G_rew.IsEdge(*e1) and G_rew.IsEdge(*e2)\n        no_mul_edges = not G_rew.IsEdge(int(u), int(w)) and not G_rew.IsEdge(int(v), int(x))\n        if no_self_loops and is_edges and no_mul_edges:\n            G_rew.DelEdge(*e1)\n            G_rew.DelEdge(*e2)\n            G_rew.AddEdge(int(u), int(w))\n            G_rew.AddEdge(int(v), int(x))\n            counter += 1\n\n        if computeCls and counter % 100 == 0:\n            clustCoefs.append(snap.GetClustCf(G_rew, -1))\n\n    return G_rew, clustCoefs\n","e46aad65":"G_rew, clustCoefs = gen_config_model_rewire(G, 3)\ndraw_graph(G_rew, 'test_rew_esu.png')","3a78ea1b":"def plot_cluster_coefs(clustering_coeffs):\n    plt.plot(np.linspace(0,10000,len(clustering_coeffs)), clustering_coeffs)\n    plt.xlabel('Iteration')\n    plt.ylabel('Average Clustering Coefficient')\n    plt.title('Random edge rewiring: Clustering Coefficient')\n    plt.show()\n    \ndef test_rewiring():\n    \"\"\"\n    Main q3 workflow. All of the work can be done in gen_config_model_rewire\n    but you may modify this function as needed.\n    \"\"\"\n\n    graphpath = '\/kaggle\/input\/cs224whw2018\/USpowergrid_n4941.txt'\n    G = load_graph(graphpath)\n    config_graph, clustering_coeffs = gen_config_model_rewire(G, 10000)\n    plot_cluster_coefs(clustering_coeffs)\n\n    return G_rew\ndef load_graph(filepath):\n    \"\"\"\n\n    @param filepath: string, path to file with the Graph represented as edge list:  one line   - one edge\n    @return: snap Graph\n    \"\"\"\n    G = snap.LoadEdgeList(snap.PNGraph, filepath, 0, 1)\n    return G","2adba6b9":"%%time\ntest_rewiring()","0bdf4936":"from itertools import permutations\n\ndef match(G1, G2):\n    \"\"\"\n\n    This function compares two graphs of size 3 (number of nodes)\n    and checks if they are isomorphic.\n    It returns a boolean indicating whether or not they are isomorphic\n    You should not need to modify it, but it is also not very elegant...\n\n\n    @param G1:  snap Graph\n    @param G2:  snap Graph\n    @return: bool, True if graphs matches\n    \"\"\"\n\n    if G1.GetEdges() > G2.GetEdges():\n        G = G1\n        H = G2\n    else:\n        G = G2\n        H = G1\n    # Only checks 6 permutations, since k = 3\n    for p in permutations(range(3)):\n        edge = G.BegEI()\n        matches = True\n        while edge < G.EndEI():\n            if not H.IsEdge(p[edge.GetSrcNId()], p[edge.GetDstNId()]):\n                matches = False\n                break\n            edge.Next()\n        if matches:\n            break\n    return matches\n\n\nclass MotifsOnGraphs:\n    \"\"\"\n    Compute all the motifs size 3 with ESU algo\n\n    Arguments:\n        network: path to file with the Graph represented as edge list:  one line   - one edge\n        motifs_folder: path to folder with all motifs named as numberOfmotif.txt\n\n    Attributes:\n        motifs: list of motifs as snap graphs\n        motif_counts : list of ints\n    \"\"\"\n\n    def __init__(self, motifs_folder):\n        \"\"\"\n        @param motifs_folder: path to folder with all motifs named as numberOfmotif.txt\n                            with the Graph represented as edge list:  one line   - one edge\n        \"\"\"\n        subgraph_fnames = [os.path.join(motifs_folder, f'{i}.txt') for i in range(13)]\n        self.__k = 3\n        self.motifs = [snap.LoadEdgeList(snap.PNGraph, f\"{motifs_folder}{i}.txt\", 0, 1) for i in\n                       range(len(subgraph_fnames))]\n        self.motif_counts = [0] * len(self.motifs)\n        self.__nbrs_cache = {}\n\n    def enumerate_subgraph(self, G, verbose=False):\n        \"\"\"\n        This is the main function of the ESU algorithm.\n        Here, you should iterate over all nodes in the graph,\n        find their neighbors with ID greater than the current node\n        and issue the recursive call to extend_subgraph in each iteration\n\n        A good idea would be to print a progress report on the cycle over nodes,\n        So you get an idea of how long the algorithm needs to run\n\n        @param G: snap Graph\n        @param verbose: bool\n        @return: list of int motifs count\n        \"\"\"\n\n        self.motif_counts = [0] * len(self.motifs)  # Reset the motif counts (Do not remove)\n        ##########################################################################\n        for Node in G.Nodes():\n            node_id = Node.GetId()\n            if verbose:\n                print(f\"Node {node_id} is processing: \")\n\n            v_ext = {el for el in self.getNbrs(G, node_id) if el > node_id}\n            self.extend_subgraph(G, {node_id}, v_ext, node_id, verbose)\n        self.__nbrs_cache = {}\n\n    def count_iso(self, G, sg, verbose=False):\n        \"\"\"\n\n        Given a set of 3 node indices in sg, obtains the subgraph from the\n        original graph and renumbers the nodes from 0 to 2.\n        It then matches this graph with one of the 13 graphs in\n        directed_3.\n        When it finds a match, it increments the motif_counts by 1 in the relevant\n        index\n\n        IMPORTANT: counts are stored in global motif_counts variable.\n        It is reset at the beginning of the enumerate_subgraph method.\n\n        @param G: snap Graph\n        @param sg: list of ints\n        @param verbose: bool, print list of node indices\n        @return: motif_counts\n        \"\"\"\n\n        if verbose:\n            print(sg)\n        nodes = snap.TIntV()\n        for NId in sg:\n            nodes.Add(NId)\n\n        SG = snap.GetSubGraphRenumber(G, nodes)\n        for i in range(len(self.motifs)):\n            if match(self.motifs[i], SG):\n                self.motif_counts[i] += 1\n                break\n\n    def extend_subgraph(self, G, sg, v_ext, node_id, verbose=False):\n        \"\"\"\n         This is the recursive function in the ESU algorithm\n        The base case is already implemented and calls count_iso. You should not\n        need to modify this.\n\n        Implement the recursive case.\n\n        @param sg: set of int subgraph members\n        @param v_ext:  set of int extensions member\n        @param node_id: int node index\n        @param verbose: bool\n        @return: motif counter\n        \"\"\"\n\n        # Base case (you should not need to modify this):\n        if len(sg) is self.__k:\n            # print(sg)\n            self.count_iso(G, sg, verbose)\n            return\n        # Recursive step:\n        ##########################################################################\n        while len(v_ext) > 0:\n            w = v_ext.pop()\n            #            if len(sg) <  self.__k-1:\n            Nw = self.getExclsNbrs(G, w, sg)\n            to_extend = {ni for ni in Nw if ni > node_id}\n\n            self.extend_subgraph(G, set.union(sg, {w}), set.union(v_ext, to_extend), node_id, verbose)\n\n    def getExclsNbrs(self, G, node_include, nodes_excl):\n        incl_set = self.getNbrs(G, node_include)\n        excl_set = set(nodes_excl)\n        [excl_set.update(self.getNbrs(G, ni)) for ni in nodes_excl]\n        return incl_set.difference(excl_set)\n\n    def getNbrs(self, G, node_id):\n        if node_id in self.__nbrs_cache:\n            return self.__nbrs_cache[node_id]\n        NodeVec = snap.TIntV()\n        snap.GetNodesAtHop(G, node_id, 1, NodeVec, False)\n        nbrs = set(NodeVec)\n        self.__nbrs_cache[node_id] = nbrs\n        return nbrs\n\n","c30d1e4f":"mfs = MotifsOnGraphs(motifs_folder)","114b5fd2":"#plot one of the motif with index i\ndraw_graph(mfs.motifs[0], 'motif.png')","2a1811cb":"G1 = load_graph('\/kaggle\/input\/cs224whw2018\/esu_test.txt')\ndraw_graph(G1, 'esu_test.png')\nmfs.enumerate_subgraph(G1, verbose=True)","d7b8c2d0":"G2 = test_esu_graph()\ndraw_graph(G2, 'test_esu.png')\nmfs.enumerate_subgraph(G2, verbose=True)","33225200":"graphpath = '\/kaggle\/input\/cs224whw2018\/USpowergrid_n4941.txt'\nG = load_graph(graphpath)","29d25aaf":"node_id = 1\nnbrs = mfs.getNbrs(G,1)\nnbr_nbrs = set()\n[nbr_nbrs.update(mfs.getNbrs(G, ni)) for ni in nbrs]\nnbrs.update(nbr_nbrs)\nprint(nbrs)","1f79dcbd":"node_list = list(nbrs)\nnodes = snap.TIntV()\nfor NId in node_list:\n    nodes.Add(NId)\nSG = snap.GetSubGraph(G, nodes)\ndraw_graph(SG,'SG.png', show = False)  \nImage('SG.png')","fbc718b4":"%%time\nmfs.enumerate_subgraph(G, verbose=False)\nprint(f'Vectors of motifs: \\n {mfs.motif_counts}')\nreal_scores = mfs.motif_counts","88c12bc0":"%%time\nconf_motifs = []\nfor i in range(10):\n    print(i)\n    config_graph, clustering_coeffs = gen_config_model_rewire(G, 10000)\n    mfs.enumerate_subgraph(config_graph, verbose=False)\n    print(f'Vectors of motifs for {i} config graph: \\n {mfs.motif_counts}')\n    conf_motifs.append(mfs.motif_counts)","072faab6":"pd.DataFrame(pd.DataFrame(conf_motifs).T.values, columns=['Experiment #%s' % str(x+1) for x in range(10)])","abcb7823":"z_scores = (real_scores - np.mean(conf_motifs, axis = 0))\/np.std(conf_motifs, axis = 0)\npd.DataFrame([z_scores, real_scores], index=['Z-score', 'Motif count'])","d9bbceae":"## 3.3. Detecting motifs on real data [10 points]\nNow that we are equiped with a null model and a motif counting algorithm, we will proceed to\ndetect motifs on real world data.   \n   \n   ![1007](https:\/\/habrastorage.org\/webt\/bi\/mv\/vy\/bimvvyobp8vrw-8rxgaupdm_juy.png)   \n       \n  Figure: All possible non-isomorphic directed 3-subgraphs    \n      \n  ![1008](https:\/\/habrastorage.org\/webt\/y3\/8v\/la\/y38vladtjqewt51x_xf1ztz5sgs.png)   \n      \n  Figure: The provided graph to test ESU against. Note that this graph has 6 connected 3-\nsubgraphs    \n    ","ea38a439":"A second (and more popular) approach to sampling from the con\fguration model is to do \\edge\nrewiring\". The idea with this algorithm is to start with an empirical network and then randomly\nrewire edges until it is essentially random.   \n   \nImplement \\edge rewiring\" for the US power grid graph. To do this, load the USpowergrid n4941.txt\ndataset as a PNGraph and iteratively repeat the following process:   \n1. Randomly select two distinct edges e1 = (a; b) and e2 = (c; d) from the graph. Now, try to\nre-wire these edges.   \n2. Randomly select one of endpoint of edge e1 and call it u. Let v be the other endpoint in\ne1. At this point, either u = a, v = b or u = b, v = a. Do the same for edge e2. Call the\nrandomly selected endpoint w and the other endpoint x.   \n3. Perform the rewiring. In the graph, replace the directed edges e1 = (a; b) and e2 = (c; d) with\nthe directed edges (u;w) and (v; x) as long as this results in a simple network (no self-loops\nor multi-edges). If the result is not a simple network, reject this rewiring and return to step\n1; otherwise, keep the newly swapped edges and return to step 1.  \n   \nTest your implementation and verify that you did not alter the number of nodes or edges on the\noriginal network. Run your edge rewiring implementation for 10,000 iterations on the power grid\nnetwork. Every 100 iterations, calculate the average clustering coefficient of the rewired network.\nThen plot the average clustering coe\u000ecient as a function of the number of iterations. Brie\ny comment\non the curve that represents the model being rewired by explaining its shape.","a83b5158":"***enumerate_subgraph*** \n\nBasic function for motifs counting. \n\nWhat do we need to do:\n\n    - implement ESU algo to enlist all possibles subgraphs with the size 3\n    - find matching through the one of the 13 basic motifs taking into account isomorphism graph ","05678b8e":"# Motif detection and configuration model\n\n## The Configuration Model [10 points]\nA common method for analyzing the properties of real world networks is to analyze their behavior\nin comparison with a generated theoretical model referred to as a \\null model.\" We have previously\ndiscussed some null models in class (Lecture 2), such as the Erd}os-Renyi model and the configuration\nmodel. While the Erd}os-Renyi model has many nice theoretical properties, the configuration model\nis useful because it generates random networks with a specified degree sequence. In other words,\ngiven a real network, the configuration model allows you to sample from the space of networks\nthat have the exact same sequence of degrees (i.e., the sampled random networks have the same\ndegree distribution as the network you are studying). For more background on the configuration\nmodel, check out these lecture notes by Aaron Clauset: http:\/\/tuvalu.santafe.edu\/~aaronc\/courses\/5352\/fall2013\/csci5352_2013_L11.pdf   \n   \nOne way of using the configuration model to generate such a network is through the spoke matching\nalgorithm covered in Lecture 5. The intuition behind this algorithm is that we first break the\nnetwork apart into a bunch of \\stubs\", which are basically nodes with dangling edges (spokes);\nthen we generate a random network by randomly pairing up these spokes and connecting them.\nUsing this approach, however, has a couple of subtleties. For instance, this algorithm can sometimes\ncreate improper (i.e. non-simple) networks with self-loops or multiple edges between two nodes;\nif this happens, then you must reject this sampled network and try again. If you wish, you may\ntry to implement the configuration model using this method, but instead, we will use another\napproach.","d2277967":"Compare with motif distribution for configuration model","be517bac":"## Experiment with power grid graph\nLoad the provided USpowergrid n4941.txt dataset as a PNGraph. Compute the motif frequencies\nusing your ESU implementation from the previous exercise. Now, sample 10 instances from the\ncon\fguration model using this graph a starting point. Note that depending on your implementation\nyou may need to reload the graph to generate each con\fguration model instance. Compute the\nmotif frequencies on each of the 10 samples random graphs and store the results. You may use a\nnumpy array of size 10\u000213 to store your motif counts. Compute the per-motif mean and standard\ndeviation for the motif counts on these 10 runs and use it to compute the Z scores. Recall:   \n   \n   ![1009](https:\/\/habrastorage.org\/webt\/mh\/yd\/ol\/mhydol-z7mejareqwyx1btqroc4.png)   \n      \nwhere N(i) is the number of times motif i appeared in the original graph, \u0016N\n(i)\nsampled is the mean\nnumber of times motif i appeared in the 10 sampled graphs and std(N(i)\nsampled) is the standard\ndeviation of the sampled motif frequencies for motif i.\n    \n    \nPlot the Z scores against their respective motif index and comment (1-2 sentences) on the results.\n   \n\nRepeat the above process for the email-Eu-core.txt dataset also loaded as a PNGraph. Report\nthe obtained Z score plot along with comments as before.   \n   \nOur reference implementation of the solution runs in about 10 minutes for the USpowergrid dataset\nand about 2.5 hours for the email-Eu dataset.","f43a4b28":"## 3.2. Exact Subgraph Enumeration (ESU) [15 points]\nAs we saw in class (Lecture 5), we have covered several metrics at node level (such as degree,\nPageRank score and node clustering) as well as at graph level (diameter, size of components, graph\nclustering coefficient). It would be useful to have something that characterized the graph at the\nmesoscopic level, that is, somewhere in between looking at the whole graph and looking at a single\nnode. Looking at subgraphs of the network seems intuitive and will prove useful. Motifs are defined\nas recurrent, significant patterns of interconnections. They can help us understand how a network\nworks and will help us predict the reaction of a network in a given situation.   \n    \nWe can think of motifs as structurally identical subgraphs that occur frequently within a graph. It\nmay be the case that a motif of interest appears several time in the graph, with overlapping nodes.\nEven though instances of the motif may overlap, we count each appearance separately.    \n    \nWe wish to be able to count occurrences of certain subgraphs and compare with the number of\noccurrences in a null model, so that we identify the patterns that occur more frequently in a given\ngraph and that as such, may be identi\fed as motifs. But, as we saw in lecture, finding size-k\nmotifs in graphs is a complex computational challenge, since it involves enumerating all possible\nsize-k connected subgraphs and counting the number of occurrences of each subgraph type. This\nis an NP-hard problem, since graph isomorphism is NP-complete! But dont worry! We'll tackle a\nsubproblem.   \n     \nImplement the ESU algorithm we covered in Lecture 5 to find all possible 3-subgraphs. We have\nprovided starter code which takes care of the graph isomorphism matching and counting problem.\nAlthough, in general, this problem is NP-hard, for k = 3 we can exhaustively check all 3! = 6\npossible permutations on node labelings to find to which of the 13 possible 3-subgraphs (shown in\nFigure 4) has been identified. All you need to do is implement ESU as a recursive algorithm that\nupon finding a 3-subgraph, counts it using our provided isomorphism counting implementation.   \n    \nTest your implementation against the provided esu test.txt dataset. Load the file as a PNGraph.\nIn Figure 5 you can see the graph we are loading. Then, run with the verbose option set to True\nand report the output of the run."}}