{"cell_type":{"ab4d2e62":"code","ba67e44b":"code","9b5fca2a":"code","eb135b58":"code","eb0cdf19":"code","22cf538f":"code","f901acb6":"code","75e8f465":"code","0c0f1827":"code","afcf045d":"code","89e12dcb":"markdown","0bdfcf15":"markdown","154dd724":"markdown","20f127ec":"markdown","c963edea":"markdown","40edd607":"markdown","02115406":"markdown","ff2d5aa3":"markdown"},"source":{"ab4d2e62":"import torch\nimport torch.nn as nn\nimport matplotlib.pyplot as plt \nimport numpy as np","ba67e44b":"configs = {\n    'A': [\n        {'in_ch':   3, 'out_ch':  64, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch':  64, 'out_ch': 128, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 128, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 256, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 256, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n    ],\n    'B': [\n        {'in_ch':   3, 'out_ch':  64, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch':  64, 'out_ch':  64, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch':  64, 'out_ch': 128, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 128, 'out_ch': 128, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 128, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 256, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 256, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n    ],\n    'D': [\n        {'in_ch':   3, 'out_ch':  64, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch':  64, 'out_ch':  64, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch':  64, 'out_ch': 128, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 128, 'out_ch': 128, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 128, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 256, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 256, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 256, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n    ],\n    'E': [\n        {'in_ch':   3, 'out_ch':  64, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch':  64, 'out_ch':  64, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch':  64, 'out_ch': 128, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 128, 'out_ch': 128, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 128, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 256, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 256, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 256, 'out_ch': 256, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 256, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': False },\n        {'in_ch': 512, 'out_ch': 512, 'activation': nn.ReLU, 'maxpool': True  },\n        # ---------------------------------------------------------------------        \n    ],\n}","9b5fca2a":"class VggNet(nn.Module):\n    def __init__(self, config, out_classes=1000):\n        super(VggNet, self).__init__()\n        \n        # maxpool (halves input w,h)\n        self.pool = nn.MaxPool2d(kernel_size=(2,2), stride=(2,2))\n        \n        # conv series\n        self.conv_series = self.get_conv_series(config)\n        \n        # fc series w\/ dropout\n        self.fc_series = self.get_fc_series([\n             {'in_nodes': 512*7*7, 'out_nodes':         4096, 'activation':     nn.ReLU, 'dropout': 0.5   },\n             {'in_nodes':    4096, 'out_nodes':         4096, 'activation':     nn.ReLU, 'dropout': 0.5   },\n             {'in_nodes':    4096, 'out_nodes':  out_classes, 'activation':  nn.Softmax, },\n        ])\n        \n    def forward(self, x):\n        \n        # input   : (num_samples, 3, 224, 224)\n        # output  : (num_samples, 512, 7, 7) \n        # As spatial resolution is preserved, only maxpool down samples (by half)\n        # i.e for 5 maxpools, (224) \/ (2^5) =  7\n        # 512 comes from depth\n        x = self.conv_series(x)\n        \n        # reshape for lin fcs\n        x = x.reshape(num_samples, -1)\n        \n        # input   : (num_samples, -1) i.e (num_samples, 512*7*7)\n        # output  : (num_samples, out_classes)\n        x = self.fc_series(x)\n        \n        return x\n    \n    \n    # ==============    \n    # Helpers\n    # ==============\n    def get_conv_series(self, config):\n        \"\"\"\n        Gives out sequential model of convs\n        \"\"\"\n        \n        # accumultor\n        series = []\n        \n        # common to all\n        # s=p=1 for k=3 preserves spatial\n        # resolution\n        k = (3,3)\n        s = (1,1)\n        p = (1,1)\n        \n        for layer_cfg in config:\n            \n            in_ch, out_ch  = layer_cfg['in_ch'], layer_cfg['out_ch']\n            actvn          = layer_cfg['activation']\n            is_pool        = layer_cfg['maxpool']\n            \n            # add conv layer\n            series.append(\n                nn.Conv2d(\n                    in_channels=in_ch, \n                    out_channels=out_ch, \n                    kernel_size=k, \n                    stride=s, \n                    padding=p\n                )\n            )\n            \n            # add activation if specified\n            if actvn is not False:\n                series.append(actvn())\n            \n            # add pool if specified\n            if is_pool is not False:\n                series.append(self.pool)\n                \n        # return seq from accumulator\n        return nn.Sequential(*series)\n    \n    \n    \n    def get_fc_series(self, config):\n        \"\"\"\n        Gives out sequential model of lin units\n        \"\"\"\n        # accumulator\n        series = []\n        \n        for layer_cfg in config:\n            \n            in_nodes   = layer_cfg['in_nodes']\n            out_nodes  = layer_cfg['out_nodes']\n            activation = layer_cfg['activation']\n            dropout    = layer_cfg['dropout'] if 'dropout' in layer_cfg else None\n            \n            # add lin layer\n            series.append(nn.Linear(in_nodes, out_nodes))\n            \n            # add activation\n            if activation: series.append(activation())\n                \n            # add dropout\n            if dropout is not None:\n                series.append( nn.Dropout(p=dropout))\n                \n        # return seq\n        return nn.Sequential(*series)","eb135b58":"Vgg16 = VggNet(configs['D'])\n\nnum_samples = 8\nINPUT = torch.randn(num_samples, 3, 224, 224)\n\nprint(Vgg16(INPUT).shape)","eb0cdf19":"del Vgg16","22cf538f":"Vgg19 = VggNet(configs['E'])\n\nnum_samples = 8\nINPUT = torch.randn(num_samples, 3, 224, 224)\n\nprint(Vgg19(INPUT).shape)","f901acb6":"del Vgg19","75e8f465":"Vgg13 = VggNet(configs['B'])\n\nnum_samples = 8\nINPUT = torch.randn(num_samples, 3, 224, 224)\n\nprint(Vgg13(INPUT).shape)","0c0f1827":"del Vgg13","afcf045d":"Vgg11 = VggNet(configs['A'])\n\nnum_samples = 8\nINPUT = torch.randn(num_samples, 3, 224, 224)\n\nprint(Vgg11(INPUT).shape)","89e12dcb":"# **VGG Net**","0bdfcf15":"**Test**","154dd724":"![image.png](attachment:image.png)","20f127ec":"**Loss function:** Cross Entropy Loss\n\n**Optimizer:** [SGD+Momentum(0.9)](), `batch_size=256`, L2 reularistion w\/ coeff `5e-4`, dropout `0.5` to FC layers, `lr=1e-2` divided by 10 depending on val. loss ","c963edea":"# Implementation","40edd607":"# Novelity\n\n- 3x3 Features\n- LRN proved useless","02115406":"# Key Takeaways\n\n- Preprocessing of input image\n    - Subraction of mean RGB values\n    - Random cropping from rescales training images (two different approaches)\n    \n- **3x3** 3-D filters for feasibility of depth (smallest size to capture up, down, left, right)\n- Applicability to **other datasets**\n- Not all convs follow maxpool. **Spatial resolution of image is preserved**(width and height. Not depth) until maxpool\n- Conv, conv, conv, max **increases discriminative power**( Because of 3 relus)\n- Progressively increase (x2) depth of activations (by incresing depth of 3-D kernels (w=h=3))\n- Pretrained wts used for initialisation. But pointed out **Glorot and Bengio Initialisation** as an alternative.\n- depth is important. (removing single layer drops accuracy by 2%)","ff2d5aa3":"![image.png](attachment:image.png)\n<p style=\"text-align: center\">Source: <a href=\"https:\/\/www.researchgate.net\/profile\/Clifford_Yang\/publication\/325137356\/figure\/fig2\/AS:670371271413777@1536840374533\/llustration-of-the-network-architecture-of-VGG-19-model-conv-means-convolution-FC-means.jpg\">researchgate.net<\/a><\/p>\n\n> Note in image:\n> - Spacial resolution is preserved until maxpool (halves it)\n> - Depth of activation is doubled after maxpool (as a result of doubling *number of 3-D Kernels*)"}}