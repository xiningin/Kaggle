{"cell_type":{"f7220400":"code","43b89922":"code","b05ef00d":"code","fcc1294d":"code","83d0621b":"code","c9c3ca8b":"code","70c0f6b3":"code","e650e4ec":"code","9e7b9d8d":"code","f042c44d":"code","9bc3e913":"code","3d260fcf":"code","afceb488":"markdown","6b258c28":"markdown","1e665d98":"markdown","7b3397ee":"markdown","cac5db64":"markdown","286a0cd8":"markdown","f8a86e28":"markdown","607d7607":"markdown","ecc85cbd":"markdown","5d778755":"markdown","c3072732":"markdown","11893da8":"markdown","d63b34b4":"markdown"},"source":{"f7220400":"import sys\nsys.path.append('..\/input')\nfrom flight_revenue_simulator import simulate_revenue, score_me","43b89922":"import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport math","b05ef00d":"def pricing_function(days_left, tickets_left, demand_level):\n    \"\"\"Sample pricing function\"\"\"\n\n    #Algo 1 - Flat\n    price = demand_level - 10\n    \n    #Algo 2 - Based on tickets left\n    #price = demand_level - 0.3*tickets_left\n    \n    #Algo 3 - Based on tickets and days left\n    #price = demand_level - (tickets_left\/days_left)\n\n    #Algo 4 - Based on tickets, days left and demand_level\n    c = \"\"\"\n    if demand_level < 50:\n        price = demand_level - 0.25*tickets_left\/days_left\n    elif demand_level < 100:\n        price = demand_level - 0.5*tickets_left\/days_left  \n    elif demand_level < 150:\n        price = demand_level - 0.75*tickets_left\/days_left    \n    elif demand_level > 150:\n        price = demand_level - 1.0*tickets_left\/days_left\n    \"\"\"\n    \n    #Algo 5 - Based on tickets, days left and demand_level\n    c = \"\"\"\n    if days_left < 1:\n        price = demand_level - 1.0*tickets_left\n    elif days_left < 5:\n        price = demand_level - 0.75*tickets_left\n    elif days_left < 10:\n        price = demand_level - 0.5*tickets_left\n    elif days_left < 15:\n        price = demand_level - 0.25*tickets_left\n    \"\"\"\n    \n    #Algo 6 - Kaggle Forum - Juntao Deng\n    if days_left > 14:\n        return 184\n    if days_left > 2:\n        return 173\n    if days_left == 2:\n        return ( 3 * demand_level + 150 - 2 * tickets_left ) \/ 4\n    if days_left == 1:\n        return demand_level - tickets_left    \n    \n    print('revenue:', (demand_level - price)*price)\n    #print('demand_level:', demand_level, 'price:',price, 'demand_level - price:', math.floor(max(0, demand_level - price)), 'quantity_sold:',demand_level - price)\n    \n    return price","fcc1294d":"import numpy as np\n\ndemand_level = 150\n# only plot quantities up to demand_level. That's point where price becomes 0\nrevenue = [(demand_level - q) * q for q in range(demand_level)]\n\n# Make primary plot\nplt.plot(revenue, label=\"Revenue\")\nplt.xlabel(\"Seats Sold\")\nplt.ylabel(\"Dollars\")\nplt.ylim(ymin=0)\nplt.xlim(xmin=0)\n\n# Show the revenue maximizing quantity\noptimal_q = np.argmax(revenue)\nplt.vlines(x=optimal_q, ymin=0, ymax=max(revenue), color='green', linestyle=\"--\", label=\"Optimal Quantity\")\n\nplt.legend(loc='lower right')\nplt.show()","83d0621b":"n_demand_levels = 11\nmin_demand_level = 100\nmax_demand_level = 200\ndemand_levels = np.linspace(min_demand_level, max_demand_level, n_demand_levels)\n\nmax_tickets = 200\nmax_days = 150\n\n# Q indices are: n_sold in day, tickets_left to start day, demand_level, days_left\nQ = np.zeros([max_tickets, max_tickets, n_demand_levels, max_days])\n# V indices are: n_left and n_days\nV = np.zeros([max_tickets, max_days])","c9c3ca8b":"simulate_revenue(days_left=7, tickets_left=50, pricing_function=pricing_function, verbose=True)","70c0f6b3":"for tickets_left in range(max_tickets):\n    for tickets_sold in range(tickets_left+1): # add 1 to offset 0 indexing. Allow selling all tickets\n        for demand_index, demand_level in enumerate(demand_levels):\n            # Never set negative prices\n            price = max(demand_level - tickets_sold, 0)\n            Q[tickets_sold, tickets_left, demand_index, 0] = price * tickets_sold\n    # For each demand_level, choose the optimum number to sell. Output of this is array .of size n_demand_levels\n    revenue_from_best_quantity_at_each_demand_level = Q[:, tickets_left, :, 0].max(axis=0)\n    # take the average, since we don't know demand level ahead of time and all are equally likely\n    V[tickets_left, 0] = revenue_from_best_quantity_at_each_demand_level.mean()","e650e4ec":"for days_left in range(1, max_days):\n    for tickets_left in range(max_tickets):\n        for tickets_sold in range(tickets_left):\n            for demand_index, demand_level in enumerate(demand_levels):\n                price = max(demand_level - tickets_sold, 0)\n                rev_today = price * tickets_sold\n                Q[tickets_sold, tickets_left, demand_index, days_left] = rev_today + V[tickets_left-tickets_sold, days_left-1]\n        expected_total_rev_from_best_quantity_at_each_demand_level = Q[:, tickets_left, :, days_left].max(axis=0)\n        V[tickets_left, days_left] = expected_total_rev_from_best_quantity_at_each_demand_level.mean()","9e7b9d8d":"#Author: DanB\n#Source:https:\/\/www.kaggle.com\/dansbecker\/airline-price-optimization-solution\n\ndef pricing_function(days_left, tickets_left, demand_level):\n    demand_level_index = np.abs(demand_level - demand_levels).argmin()\n    day_index = days_left - 1 # arrays are 0 indexed\n    tickets_index = int(tickets_left)  # in case it comes in as float, but need to index with it\n    relevant_Q_vals = Q[:, tickets_index, demand_level_index, day_index]\n    desired_quantity = relevant_Q_vals.argmax()# offset 0 indexing\n    price = demand_level - desired_quantity\n    return price","f042c44d":"score_me(pricing_function)","9bc3e913":"report = pd.DataFrame(columns=['Algorithm', 'Total Revenue ($)'])\n#Algo 1\nreport.loc[len(report)] = ['10', 6073]\n#Algo 2\nreport.loc[len(report)] = ['0.5*tickets_left', 5133]\nreport.loc[len(report)] = ['0.3*tickets_left', 5242]\n#Algo 3\nreport.loc[len(report)] = ['tickets_left\/days_left', 6354]\nreport.loc[len(report)] = ['4 level demand and [variable]*tickets_left\/days_left', 6440]\nreport.loc[len(report)] = ['4 level days_left and [variable]*tickets_left', 6228]\nreport.loc[len(report)] = ['Kaggle Forum - Juntao Deng', 7459]\nreport.loc[len(report)] = ['Kaggle Forum - DanB Dynamic Programming', 7558]","3d260fcf":"sns.set(rc={'figure.figsize':(16,9)})\nax = sns.barplot(report['Total Revenue ($)'], report.Algorithm, orient='h', palette=sns.color_palette(\"muted\"))\n\nfor i, total_revenue in enumerate(report['Total Revenue ($)']):\n    ax.text(total_revenue, i+0.2, f'{total_revenue:.2f}', fontsize=13)\nplt.title(f'Average revenue across all flights ($)')\nplt.xlabel('')\nplt.ylabel('')\nplt.show()","afceb488":"## Setting Up Q and V","6b258c28":"We have Q and V. How do we use them?\n\nFor any given number of tickets, days_left and demand_level, we look in Q to find the number of tickets with the highest Q-value.\n\nHere is our pricing function that implements that:","1e665d98":"# Typo below\n## quantity_demanded = floor(max(0, p - demand_level))\n## should be\n## quantity_demanded = floor(max(0, demand_level - p))","7b3397ee":"## DanB solution based on Dynamic Programming\nhttps:\/\/www.kaggle.com\/dansbecker\/airline-price-optimization-solution  \n```\nquantity_sold = demand_level - price  \nrevenue = price * quantity_sold  \n\nprice = demand_level - quantity_sold  \nrevenue = (demand_level - quantity_sold) * quantity_sold  \n```","cac5db64":"---\n**[Microchallenges Home Page](https:\/\/www.kaggle.com\/learn\/microchallenges)**\n\n\n*Want to discuss your solution or hear what others have done?  Visit the [Learn Discussion forum](https:\/\/www.kaggle.com\/general\/62469) to chat with other Learners.*","286a0cd8":"You can try simulations for a variety of values.\n\nOnce you feel good about your pricing function, run it with the following cell to to see how it performs on a wider range of flights.","f8a86e28":"# The Problem\n\nYou recently started Aviato.com, a startup that helps airlines set ticket prices. \n\n<img src=\"https:\/\/i.imgur.com\/7wpEO5T.jpg\" width=\"500px\"> <\/img>\n\nAviato's success will depend on a function called `pricing_function`.  This notebook already includes a very simple version of `pricing_function`.  You will modify `pricing_function` to maximize the total revenue collected for all flights in our simulated environment.\n\nFor each flight, `pricing_function` will be run once per (simulated) day to set that day's ticket price. The seats you don't sell today will be available to sell tomorrow, unless the flight leaves that day.\n\nYour `pricing_function` is run for one flight at a time, and it takes following inputs:\n- **Number of days until the flight**\n- **Number of seats they have left to sell**\n- **A variable called `demand_level` that determines how many tickets you can sell at any given price. **\n\nThe quantity you sell at any price is:\n> quantity_sold = demand_level - price\n\nTicket quantities are capped at the number of seats available.\n\nYour function will output the ticket price.\n\nYou learn the `demand_level` for each day at the time you need to make predictions for that day. For all days in the future, you only know `demand_level` will be drawn from the uniform distribution between 100 and 200.  So, for any day in the future, it is equally likely to be each value between 100 and 200.\n\nIn case this is still unclear, some relevant implementation code is shown below.\n\n# The Simulator\nWe will run your pricing function in a simulator to test how well it performs on a range of flight situations.  **Run the following code cell to set up your simulation environment:**","607d7607":"## The Base Case: Selling With One Day Left","ecc85cbd":"In case you want to check your understanding of the simulator logic, here is a simplified version of some of the key logic (leaving out the code that prints your progress). If you feel you understand the description above, you can skip reading this code.\n\n```\ndef _tickets_sold(p, demand_level, max_qty):\n        quantity_demanded = floor(max(0, p - demand_level))\n        return min(quantity_demanded, max_qty)\n\ndef simulate_revenue(days_left, tickets_left, pricing_function, rev_to_date=0, demand_level_min=100, demand_level_max=200):\n    if (days_left == 0) or (tickets_left == 0):\n        return rev_to_date\n    else:\n        demand_level = uniform(demand_level_min, demand_level_max)\n        p = pricing_function(days_left, tickets_left, demand_level)\n        q = _tickets_sold(demand_level, p, tickets_left)\n        return _total_revenue(days_left = days_left-1, \n                              tickets_left = tickets_left-q, \n                              pricing_function = pricing_function, \n                              rev_to_date = rev_to_date + p * q,\n                              demand_level_min = demand_level_min,\n                              demand_level_max = demand_level_max\n                             )\n```\n\n# Your Code\n\nHere is starter code for the pricing function.  If you use this function, you will sell 10 tickets each day (until you run out of tickets).","5d778755":"# Intro to Dynamic Programming\n\nhttps:\/\/www.educative.io\/courses\/grokking-dynamic-programming-patterns-for-coding-interviews\n<img src=\"https:\/\/www.educative.io\/cdn-cgi\/image\/f=auto,fit=cover,w=600\/v2api\/collection\/5668639101419520\/5633779737559040\/image\/5647129569656832\"><\/img>\n","c3072732":"## The General Case: Solving for Other Time Horizons","11893da8":"To see a small example of how your code works, test it with the following function:","d63b34b4":"**This notebook is an exercise in the [Microchallenges](https:\/\/www.kaggle.com\/learn\/microchallenges) course.  You can reference the tutorial at [this link](https:\/\/www.kaggle.com\/alexisbcook\/airline-price-optimization-microchallenge).**\n\n---\n"}}