{"cell_type":{"e36241b7":"code","c6d32c96":"code","8e0c672e":"code","2ed6cc3b":"code","465a821d":"code","27b006a1":"code","a1d15622":"code","447bbdd0":"code","b1101a5b":"code","9cc78dd0":"code","098d1c0f":"code","9226f981":"code","84553d1e":"code","64fead24":"code","b6b0f721":"code","99f8afef":"code","1d0cd5fc":"code","2d477167":"code","ee5e5977":"code","2aabc5d0":"code","e466c50b":"code","ced8fdf1":"code","75c7c958":"markdown","75cb9714":"markdown","51536f0d":"markdown"},"source":{"e36241b7":"import numpy as np\nimport pandas as pd\nimport os\nimport gc\nimport glob\nimport random\nimport shutil\nfrom matplotlib import pyplot as plt\n\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import MinMaxScaler, StandardScaler\n\nimport pytorch_lightning as pl\nfrom pytorch_lightning.callbacks.early_stopping import EarlyStopping\nfrom pytorch_lightning.loggers import TensorBoardLogger\nfrom pytorch_lightning.core.memory import ModelSummary\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import TensorDataset, DataLoader\nfrom torch.optim.lr_scheduler import ExponentialLR\n\nimport warnings\nwarnings.simplefilter('ignore')","c6d32c96":"!pip install -q monai-weekly\nfrom monai.metrics import ROCAUCMetric","8e0c672e":"N_SPLITS = 10\nSEED = 42\nBATCH_SIZE = 1024\nWORKERS = 4\nEPOCHS = 100\nLEARNING_RATE = 2e-3\nMODEL_PATH = \"models\"\nTB_LOG_NAME = \"lightning_logs\"","2ed6cc3b":"def seed_everything(seed=42):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    pl.utilities.seed.seed_everything(seed, workers=True)\n    \nseed_everything(SEED)","465a821d":"train_df = pd.read_csv('..\/input\/tabular-playground-series-mar-2021\/train.csv')\ntrain_df = train_df[train_df.columns[1:]]\ntrain_df","27b006a1":"train_df.info()","a1d15622":"df=train_df\nfrom sklearn.preprocessing import LabelEncoder\nfor c in df.columns:\n    if df[c].dtype=='object': \n        df[c]=df[c].fillna('N')\n        lbl = LabelEncoder()\n        print(c)\n        lbl.fit(df[c])\n        df[c] = lbl.transform(df[c].values)\ntrain_df=df","447bbdd0":"train_df.target.value_counts(normalize=True)","b1101a5b":"train_df['fold'] = -1\nskf = StratifiedKFold(n_splits=N_SPLITS, shuffle=True, random_state=SEED)\nfor fold, (train_idx, val_idx) in enumerate(skf.split(train_df, train_df['target'])):\n    train_df.loc[val_idx, 'fold'] = fold","9cc78dd0":"train_df","098d1c0f":"class Model(pl.LightningModule):\n    def __init__(self, in_size, learning_rate, num_targets=1, hidden_size=128):\n        super().__init__()\n        self.in_size = in_size\n        self.lr = learning_rate\n        self.num_targets = num_targets\n        self.hidden_size = hidden_size\n        \n        self.fc1 = nn.Linear(self.in_size, self.hidden_size)\n        self.fc2 = nn.Linear(self.hidden_size, self.hidden_size)\n        self.fc3 = nn.Linear(self.hidden_size, self.num_targets)\n        self.relu = F.relu\n        self.swish = F.hardswish\n        self.flatten = nn.Flatten()\n        self.dropout = nn.Dropout(0.2)\n        self.roc_auc_metric = ROCAUCMetric()\n    \n    def forward(self, x):\n        x = self.flatten(x)\n        x = self.swish(self.fc1(x))\n        x = self.swish(self.fc2(x))\n        x = self.swish(self.fc2(x))\n        x = self.fc3(x)\n        \n        return x\n    \n    def training_step(self, batch, batch_idx):\n        X, y = batch\n        y_hat = self(X).squeeze(1)\n        loss = F.binary_cross_entropy_with_logits(y_hat, y)  \n        self.log('loss', loss)\n        return {'loss': loss}\n        \n    def validation_step(self, batch, batch_idx):\n        X, y = batch\n        y_hat = self(X).squeeze(1)\n        self.roc_auc_metric(y_hat, y)      \n    \n    def validation_epoch_end(self, training_step_outputs):\n        roc_auc = self.roc_auc_metric.aggregate()\n        self.roc_auc_metric.reset()\n        self.log('roc_auc', roc_auc)\n        \n    def predict_step(self, X, batch_idx: int, dataloader_idx: int = None):\n        return self(X[0])    \n    \n    def configure_optimizers(self):\n        optimizer = torch.optim.AdamW(self.parameters(), lr=self.lr, eps=1e-8, weight_decay=1e-2, amsgrad=False)\n        return optimizer","9226f981":"pipes = []\n\nfor fold in range(N_SPLITS):\n    print('Fold:', fold)\n    train_data = train_df[train_df['fold']!=fold]\n    val_data = train_df[train_df['fold']==fold]\n    \n    X_train = train_data.drop(['target', 'fold'], axis=1)\n    y_train = train_data['target']\n    \n    X_val = val_data.drop(['target', 'fold'], axis=1)\n    y_val = val_data['target']\n\n    pipe = Pipeline([\n            (\"scaler\", MinMaxScaler()),\n    ])\n\n    pipe.fit(X_train)\n    pipes.append(pipe)\n    \n    X_train = pd.DataFrame(pipe.transform(X_train), columns=X_train.columns, index=X_train.index)\n    X_val = pd.DataFrame(pipe.transform(X_val), columns=X_val.columns, index=X_val.index)\n    \n    train_ds = TensorDataset(torch.FloatTensor(X_train.values), torch.FloatTensor(y_train.values))\n    val_ds = TensorDataset(torch.FloatTensor(X_val.values), torch.FloatTensor(y_val.values))\n\n    train_dl = DataLoader(train_ds, batch_size=BATCH_SIZE, shuffle=True, num_workers=WORKERS)\n    val_dl = DataLoader(val_ds, batch_size=BATCH_SIZE, shuffle=False, num_workers=WORKERS)\n\n    model = Model(X_train.shape[1],LEARNING_RATE,1,128,)\n\n    checkpoint_callback = pl.callbacks.ModelCheckpoint(\n        dirpath=MODEL_PATH,\n        filename=f'model_{fold}_' + '{roc_auc:.3}',\n        monitor='roc_auc',\n        mode='max',\n        save_weights_only=True)\n\n    logger = TensorBoardLogger(\n        save_dir=os.getcwd(),\n        version=fold,\n        name=TB_LOG_NAME\n    )\n \n    early_stop_callback = EarlyStopping(\n        monitor='loss',\n        min_delta=0.00,\n        patience=3,\n        verbose=False,\n        mode='min'\n    )\n    \n    # print(ModelSummary(model))\n    trainer = pl.Trainer(\n        fast_dev_run=False,\n        max_epochs=EPOCHS,\n        #gpus=1,\n        precision=32,\n        limit_train_batches=1.0,\n        limit_val_batches=1.0, \n        num_sanity_val_steps=0,\n        val_check_interval=1.0, \n        callbacks=[checkpoint_callback],\n        logger=logger\n     )\n\n    trainer.fit(model, train_dl, val_dl)\n    \n    del model, trainer, val_data, train_data, X_train, X_val, y_train, y_val, train_ds, val_ds, train_dl, val_dl\n    gc.collect()\n    torch.cuda.empty_cache()","84553d1e":"trained_models = []\nfor i in range(N_SPLITS):\n    list = glob.glob(f\".\/models\/model_{i}_*.ckpt\")\n    list.sort()\n    trained_models.append(list[-1])","64fead24":"trained_models","b6b0f721":"import pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\n\ntest_df = pd.read_csv('..\/input\/tabular-playground-series-mar-2021\/test.csv')\ntest_df = test_df[test_df.columns[1:]]\ntest_df","99f8afef":"test_df.info()","1d0cd5fc":"print(test_df['cat0'].unique().tolist())\nprint(type(test_df['cat0']))","2d477167":"df=test_df\nfor c in df.columns:\n    if df[c].dtype=='object': \n        df[c]=df[c].fillna('N')\n        lbl = LabelEncoder()\n        print(c)\n        lbl.fit(df[c])\n        df[c] = lbl.transform(df[c].values)\n        \ntest_df=df","ee5e5977":"all_preds = []\ntrainer = pl.Trainer() #pl.Trainer(gpus=1)\nmodel = Model(test_df.shape[1], LEARNING_RATE)\n\nfor model_name in trained_models:\n    fold = int(model_name.split('_')[1])\n    pipe = pipes[fold]\n    test_data = pipe.transform(test_df)\n    model.load_state_dict(torch.load(model_name)['state_dict'])\n    test_ds = TensorDataset(torch.FloatTensor(test_data))\n    test_dl = DataLoader(test_ds, batch_size=BATCH_SIZE, shuffle=False, num_workers=WORKERS)\n    preds = trainer.predict(model, test_dl)\n    preds = torch.cat(preds).cpu().numpy().flatten()\n    all_preds.append(preds)","2aabc5d0":"np_all_preds = np.array(all_preds)\nnp_all_preds[:, :4], np_all_preds[:, -4:]","e466c50b":"avg_preds = np.mean(np_all_preds, axis=0)\navg_preds[:4], avg_preds[-4:]","ced8fdf1":"sample_df = pd.read_csv('..\/input\/tabular-playground-series-mar-2021\/sample_submission.csv')\nsample_df['target'] = np.where(avg_preds<0.5,0,1)\n#sample_df['target'] = avg_preds\nsample_df.to_csv('submission.csv', index=False)\nsample_df","75c7c958":"# TPS0321 Pytorch Lighting\nThis notebook refferred to <br\/>\nhttps:\/\/www.kaggle.com\/hiro5299834\/tps-nov-2021-pytorch-lightning","75cb9714":"<h1> Network implementation <\/h1>","51536f0d":"<h1> Inference <\/h1>"}}