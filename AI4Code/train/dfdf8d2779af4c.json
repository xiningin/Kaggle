{"cell_type":{"b201c5d7":"code","57f87a41":"code","7ffb368a":"code","da93fae6":"code","55990ee2":"code","53f090b2":"code","c366cc8c":"code","72d0f984":"code","25cb2d20":"code","85915869":"code","ba7dee38":"code","eebd001a":"code","0dfca96b":"markdown","2b20555a":"markdown","1693b542":"markdown","578b5e93":"markdown","0985c4fe":"markdown","811e980f":"markdown"},"source":{"b201c5d7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","57f87a41":"# Firstly, we import libraries and put settings\nimport datetime as dt\nimport pandas as pd\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\npd.set_option('display.width', 400)\npd.set_option('display.float_format', lambda x: '%.5f' % x)","7ffb368a":"# Import\ndf_ = pd.read_csv('..\/input\/online-retail-ii-uci\/online_retail_II.csv')\ndf = df_.copy()\ndf.head()","da93fae6":"# We try to understand the data. Let's take a glance at descriptive statistics for numerical variables\ndf.describe().T","55990ee2":"# We'll drop missing values.\ndf.isnull().sum()                \ndf.dropna(inplace=True)","53f090b2":"# There are some canceled transactions into 'Invoice' variable. It causes minus values in Quantity and Price\n# Let's get rid of them.\ndf = df[~df['Invoice'].str.contains('C',na=False)]","c366cc8c":"# Let's check top 5 selling products\ndf['Description'].nunique()\ndf['Description'].value_counts()\ndf.groupby(\"Description\").agg({\"Quantity\": \"sum\"}).sort_values(\"Quantity\", ascending=False).head()","72d0f984":"# We need a variable for RFM segmentation which represents 'monetary'. So I'll create a new variable called 'TotalPrice'\ndf['TotalPrice'] = df['Quantity'] *  df['Price']\ndf.head()","25cb2d20":"import datetime as dt\ndf['InvoiceDate']= pd.to_datetime(df['InvoiceDate'])\ntoday_date = dt.datetime(2011, 12, 11)\nrfm = df.groupby('Customer ID').agg({'InvoiceDate': lambda x: (today_date-x.max()).days,\n                                     'Invoice': lambda y: y.nunique(),\n                                     'TotalPrice': lambda z: z.sum()})\nrfm.columns = ['recency','frequency','monetary']\nrfm.head()","85915869":"rfm['recency_score'] = pd.qcut(rfm['recency'],q=5,labels=[5,4,3,2,1])\nrfm['frequency_score'] = pd.qcut(rfm['frequency'].rank(method=\"first\"),5,labels=[1,2,3,4,5])\nrfm['monetary_score']  = pd.qcut(rfm['monetary'],5,labels=[1,2,3,4,5])\n\n# Various implementations of an RFM analysis system may use slightly different values or scaling, however.\n# The collection of three values for each customer is called an RFM cell but we will use RF here\n\nrfm['RF_SCORE'] = rfm['recency_score'].astype('str') + rfm['frequency_score'].astype('str')\nrf = rfm\nrf.head()","ba7dee38":"seg_map = {\n    r'[1-2][1-2]': 'hibernating',\n    r'[1-2][3-4]': 'at_Risk',\n    r'[1-2]5': 'cant_loose',\n    r'3[1-2]': 'about_to_sleep',\n    r'33': 'need_attention',\n    r'[3-4][4-5]': 'loyal_customers',\n    r'41': 'promising',\n    r'51': 'new_customers',\n    r'[4-5][2-3]': 'potential_loyalists',\n    r'5[4-5]': 'champions'\n}\nrf['segment'] = rf['RF_SCORE'].replace(seg_map, regex=True)\nrf.head()","eebd001a":"rf[[\"segment\", \"recency\", \"frequency\", \"monetary\"]].groupby(\"segment\").agg([\"mean\", \"count\"])","0dfca96b":"#### Let's take a (deep) look at our segments and make a decision about 'which segments are important to me to increase sales","2b20555a":"### Our dataframe is ready to create scores. We'll turn metrics into scores therefore we'll use qcut function here.(You may use 'Pareto Principle',also)","1693b542":"## In the final, We will decide which groups are important to us. We will select 3 groups.In my opinion, Champions, Can't loose and Loyal Customers are the most 3 important groups but it is open to discuss of course.\n\n### Firstly, here as you see \"Champions\" group is very important group to us. This group can be the focus in new product promotion\n### Secondly, We can focus on \"Can't loose\" because they bring us the most money after champions.They used to shop often, it's important to return them. Discount offers can be effective in their return.\n### Lastly, \"Loyal Customers'.This group also has high returns. We can call them send prensent maybe because it may be necessary to make them feel valued.Additionaly, inform them about campaings etc.\n\n# WHICH ARE THE MOST IMPORTANT 3 GROUP FOR YOU? LET ME KNOW :) \n# THANKS FOR YOUR TIME!\n","578b5e93":"#### RFM is abbriviation for 'R'ecency , 'F'requency, 'M'onetary\n#### Recency  : Time from customer's last purchase to date\n#### Frequency: Total number of purchase\n#### Monetary : Total spend by the customer","0985c4fe":"### Today we will talk about RFM. RFM Scoring is a frequently used method in customer analytics. It is a simple and powerful method applied for customer segmentation. We will segment our customers and decide which customer group is important to us.","811e980f":"### Let's create our segments."}}