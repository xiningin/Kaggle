{"cell_type":{"f3df80c5":"code","08c872dd":"code","ec42aa51":"code","30c42d19":"code","59139904":"code","33f46f54":"code","d9e77ceb":"code","f770a259":"code","182fe35c":"code","3b155cc8":"code","cc8e4ce9":"code","1eb50f6e":"code","9e648256":"code","1aafd45a":"code","451dd65f":"code","f5cc48f7":"code","6e3bdcc1":"code","a4ec18e6":"code","bb3ac9e1":"code","afce6841":"code","06911837":"code","6791d466":"code","c68c09eb":"code","de2476c5":"code","a2be83fb":"code","a8aa89ff":"code","20c09d34":"code","317b7b70":"code","1bdef36a":"code","f4e7984b":"code","f79a3015":"code","fd2ed810":"code","5892e5b3":"code","299455db":"code","baf80a01":"code","7e1a083a":"code","007e2b5e":"code","1c22f5cc":"code","72e00c54":"code","8cdd7fd5":"code","e1b5380c":"code","4151be5d":"code","3f8526fd":"markdown","c9ee41f3":"markdown","7df674ac":"markdown","900b1398":"markdown","4e69a694":"markdown","b1a17f11":"markdown","c002fd9d":"markdown","67f67608":"markdown","4a80af8c":"markdown","b2700ca6":"markdown","9b2a64c2":"markdown","9f54c21b":"markdown","3866ab9f":"markdown","bfba39dd":"markdown","f5d2e2fc":"markdown","98588be0":"markdown","8bbf933c":"markdown","0a4c961d":"markdown","0f767c97":"markdown","421eacde":"markdown","1e852514":"markdown","b5e7840e":"markdown","a868e3f7":"markdown","aeb11ce9":"markdown","4d7b3e3c":"markdown","34e7eb14":"markdown","94d42eb7":"markdown","805ef9ae":"markdown","a8baeb63":"markdown","103cd513":"markdown","eedb92f0":"markdown","40572cc6":"markdown"},"source":{"f3df80c5":"#numerical\/system libs\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\npd.options.display.max_rows = 999\npd.options.display.max_columns = 200\nimport re\nimport random\nimport json\nimport functools\n\n\n#visualization libs\n%matplotlib inline\n#%config InlineBackend.figure_format ='retina'\n\nimport pylab as plt\nimport seaborn as sns\nsns.set_style('whitegrid')\nfrom ipywidgets.widgets import HTML\nfrom tqdm import tqdm\n\n\n#graph and network libs\nimport networkx as nx\nimport community as louvain\n\n\n#machine learning libs\nfrom sklearn.preprocessing import normalize\nfrom sklearn.cluster import KMeans, DBSCAN\nfrom sklearn.decomposition import PCA\nfrom sklearn import decomposition, manifold\n\nfrom gensim.models import Word2Vec","08c872dd":"# many graph algorithms depends on random inicialization\ndef  setRandom():\n    random.seed(42)\n    np.random.seed(42)\n\nsetRandom()","ec42aa51":"#Manual configuration of the capital of eurovision affiliated countries\n\nlatLongFixed = pd.DataFrame.from_records(\n[{'countryfrom': 'Albania', 'Capital': 'Tirane', 'Latitude': 41.3310413, 'Longitude': 19.7828036},\n {'countryfrom': 'Andorra', 'Capital': 'Andorra la Vella', 'Latitude': 42.5051006, 'Longitude': 1.5116108},\n {'countryfrom': 'Armenia', 'Capital': 'Yerevan', 'Latitude': 40.1535684, 'Longitude': 44.3484804},\n #{'countryfrom': 'Australia', 'Capital': 'Canberra', 'Latitude': -35.15, 'Longitude': 149.08},\n  {'countryfrom': 'Australia', 'Capital': 'Canberra', 'Latitude': 36, 'Longitude': -19}, #fake location to make the graph looks pretier than the real location\n {'countryfrom': 'Austria',   'Capital': 'Vienna', 'Latitude': 48.2208286, 'Longitude': 16.2399746},\n {'countryfrom': 'Azerbaijan', 'Capital': 'Baku', 'Latitude': 40.3947695, 'Longitude': 49.714873},\n {'countryfrom': 'Belarus', 'Capital': 'Minsk', 'Latitude': 53.8847608, 'Longitude': 27.4532841},\n {'countryfrom': 'Belgium', 'Capital': 'Brussels', 'Latitude': 50.8550625, 'Longitude': 4.3053498},\n {'countryfrom': 'Bosnia', 'Capital': 'Sarajevo', 'Latitude': 43.8938852, 'Longitude': 18.2429054},\n {'countryfrom': 'Bulgaria', 'Capital': 'Sofia', 'Latitude': 42.6955992, 'Longitude': 23.1838604},\n {'countryfrom': 'Croatia', 'Capital': 'Zagreb', 'Latitude': 45.8403496, 'Longitude': 15.8242458},\n {'countryfrom': 'Cyprus', 'Capital': 'Nicosia', 'Latitude': 35.1923727, 'Longitude': 33.3273614},\n {'countryfrom': 'Czech Republic', 'Capital': 'Prague', 'Latitude': 50.0598058, 'Longitude': 14.3255389},\n {'countryfrom': 'Denmark', 'Capital': 'Copenhagen', 'Latitude': 55.6713442, 'Longitude': 12.523784},\n {'countryfrom': 'Estonia', 'Capital': 'Tallinn', 'Latitude': 59.4717421, 'Longitude': 24.4580607},\n {'countryfrom': 'Finland', 'Capital': 'Helsinki', 'Latitude': 60.11021, 'Longitude': 24.7385001},\n {'countryfrom': 'France', 'Capital': 'Paris', 'Latitude': 48.8589507, 'Longitude': 2.2770197},\n {'countryfrom': 'Georgia', 'Capital': \"T'bilisi\", 'Latitude': 41.7326304, 'Longitude': 44.6987664},\n {'countryfrom': 'Germany', 'Capital': 'Berlin', 'Latitude': 52.5069312, 'Longitude': 13.1445453},\n {'countryfrom': 'Greece', 'Capital': 'Athens', 'Latitude': 37.9909517, 'Longitude': 23.6682987},\n {'countryfrom': 'Hungary', 'Capital': 'Budapest', 'Latitude': 47.4813602, 'Longitude': 19.9902175},\n {'countryfrom': 'Iceland', 'Capital': 'Reykjavik', 'Latitude': 64.1335484, 'Longitude': -21.9224819},\n {'countryfrom': 'Ireland', 'Capital': 'Dublin', 'Latitude': 53.3244431, 'Longitude': -6.3857885},\n {'countryfrom': 'Israel', 'Capital': 'Jerusalem', 'Latitude': 31.7965337, 'Longitude': 35.0352712},\n {'countryfrom': 'Italy', 'Capital': 'Rome', 'Latitude': 41.9102415, 'Longitude': 12.3959115},\n {'countryfrom': 'Latvia', 'Capital': 'Riga', 'Latitude': 56.9715357, 'Longitude': 24.8489796},\n {'countryfrom': 'Lithuania', 'Capital': 'Vilnius', 'Latitude': 54.7007582, 'Longitude': 25.972849},\n {'countryfrom': 'Luxembourg', 'Capital': 'Luxembourg', 'Latitude': 49.6076951, 'Longitude': 6.0658298},\n {'countryfrom': 'Macedonia', 'Capital': 'Skopje', 'Latitude': 41.9991965, 'Longitude': 21.3548497},\n {'countryfrom': 'Malta',     'Capital': 'Valletta', 'Latitude': 35.8984976, 'Longitude': 14.5044102},\n {'countryfrom': 'Moldova', 'Capital': 'Chisinau', 'Latitude': 47.0000178, 'Longitude': 28.718091},\n {'countryfrom': 'Monaco',  'Capital': 'Monte Carlo', 'Latitude': 43.7410682, 'Longitude': 7.4172157},\n \n {'countryfrom': 'Montenegro', 'Capital': 'Montenegro', 'Latitude': 42.708679, 'Longitude': 19.37439},\n {'countryfrom': 'Morocco', 'Capital': 'Rabbat', 'Latitude': 31.791702, 'Longitude': -7.09262},\n {'countryfrom': 'Netherlands', 'Capital': 'Amsterdam', 'Latitude': 52.3547925, 'Longitude': 4.7638758},\n {'countryfrom': 'Norway',   'Capital': 'Oslo', 'Latitude': 59.8937803, 'Longitude': 10.6446921},\n {'countryfrom': 'Poland',   'Capital': 'Warsaw', 'Latitude': 52.2328546, 'Longitude': 20.9207684},\n {'countryfrom': 'Portugal', 'Capital': 'Lisbon', 'Latitude': 38.7436056, 'Longitude': -9.2304149},\n {'countryfrom': 'Romania',  'Capital': 'Bucuresti', 'Latitude': 44.4377397, 'Longitude': 25.9542107},\n {'countryfrom': 'Russia',   'Capital': 'Moskva', 'Latitude': 55.5807418, 'Longitude': 37.8237562},\n {'countryfrom': 'San Marino', 'Capital': 'San Marino', 'Latitude': 43.9428565, 'Longitude': 12.3898818},\n {'countryfrom': 'Serbia', 'Capital': 'Belgrade', 'Latitude': 44.8151593, 'Longitude': 20.2821702},\n {'countryfrom': 'Slovakia', 'Capital': 'Bratislava', 'Latitude': 48.1356948, 'Longitude': 16.9754907,},\n {'countryfrom': 'Slovenia', 'Capital': 'Ljubljana', 'Latitude': 46.0660959, 'Longitude': 14.4618877},\n {'countryfrom': 'Spain', 'Capital': 'Madrid', 'Latitude': 40.4378693, 'Longitude': -3.8199641,},\n {'countryfrom': 'Sweden', 'Capital': 'Stockholm', 'Latitude': 59.3260664, 'Longitude': 17.841628},\n {'countryfrom': 'Switzerland', 'Capital': 'Bern', 'Latitude': 46.9546485, 'Longitude': 7.3246587},\n {'countryfrom': 'Turkey', 'Capital': 'Ankara', 'Latitude': 39.9032919, 'Longitude': 32.6223372},\n {'countryfrom': 'Ukraine', 'Capital': 'Kiev', 'Latitude': 50.4016974, 'Longitude': 30.251825},\n {'countryfrom': 'United Kingdom', 'Capital': 'London', 'Latitude': 51.5285578, 'Longitude': -0.05}]\n)","30c42d19":"#countries  participants of eurovision and their neighbours. \ncountriesCodes =['AE','AU','SA','SY','BE', 'EL','GR', 'LT', 'PT', 'BG', 'ES', 'LU', 'RO','GB','KZ','TM',\n                 'CZ', 'FR', 'HU', 'SI', 'DK', 'HR', 'MT', 'SK', 'DE', 'IT', 'NL', 'FI','IQ',\n                 'EE', 'CY', 'AT', 'SE', 'IE', 'LV', 'PL', 'UK', 'IS', 'NO', 'LI', 'CH','KW','OM',\n                 'ME', 'MK', 'AL', 'RS', 'TR', 'BA', 'XK', 'AM', 'BY', 'GE', 'AZ', 'MD', 'UA', 'IR',\n                 'IL', 'DZ', 'LB', 'SY', 'EG', 'LY', 'TN', 'IL', 'MA', 'RU', 'JO', 'PS','LB','PS','YE','JO','MT']\n\ncountriesBorders = json.loads(open('..\/input\/countries-borders\/countries.geojson').read())","59139904":"#moving australia shape from south pacific to north atlantic for visualization purpose\nausCenter = pd.DataFrame(latLongFixed)[['Longitude','Latitude']].min().values+5\nfor n in countriesBorders['features']:\n    if n['properties']['name']=='Australia':\n        geometry = n['geometry'];\n        if geometry['type'] == 'MultiPolygon':\n            for c in geometry['coordinates']:\n                for i in range(len(c)):\n                    c[i] = ((np.array(c[i]) + np.array([-150,35]))\/2+ausCenter).tolist()","33f46f54":"# TODO: in a future relase this code will be replace by folium or other library\nfrom matplotlib.patches import Polygon, Rectangle\ndef plotCountry(x, fill=False, fill_color='#fff'):\n    coord = x['coordinates'];\n    def draw(p):\n        if len(p) < 2:\n            return;\n        p = np.array(p);\n        plt.gca().plot(p[:,0],p[:,1],c='#cccccc', zorder=1)\n        plt.gca().add_patch(Polygon(p,color=fill_color, zorder=1))\n            \n    if x['type'] == 'MultiPolygon':\n        for p in coord:\n            draw(p[0])\n            \n    if x['type'] == 'Polygon':\n        draw(coord[0])","d9e77ceb":"# Eurovision dataset with data from 1975 to 2019 \n\ndf = pd.read_excel('\/kaggle\/input\/eurovision-song-contest-scores-19752019\/eurovision_song_contest_1975_2019.xlsx')\ndf.columns = ['year','final','edition','votetype','countryfrom','countryto','points','duplicate'];","f770a259":"def basicClean(df, minYears = 5, last_participation=8):\n    df2 = df.copy().query('points > 0')\n    \n    #Removing duplicates\n    df2['duplicate'] = df2['duplicate'].apply(lambda x: True if x == 'x' or x==True else False)\n    df2 = df2.query('duplicate == False').drop(columns=['duplicate'])\n\n    \n    #Stantardazing countries names.\n    def applyRename(x):\n        renamings ={\n            'North Macedonia':'Macedonia',\n            'F.Y.R. Macedonia':'Macedonia',\n            'The Netherands': 'Netherlands',\n            'The Netherlands':'Netherlands',\n            'Bosnia & Herzegovina':'Bosnia',\n        }\n        return renamings[x] if x in renamings else x\n\n    df2['countryfrom'] = df2['countryfrom'].apply(applyRename)\n    df2['countryto']   = df2['countryto'].apply(applyRename)\n    \n    \n\n    #replicating  Yugoslavia's results to countries that part of it.\n    division = {\n        'Yugoslavia':['Macedonia','Serbia','Montenegro','Slovenia','Bosnia','Croatia'],\n        'Serbia & Montenegro':['Serbia','Montenegro'],\n    }\n    \n    df2['countryfrom'] = df2['countryfrom'].apply(lambda x:division[x] if x in division else x)\n    df2['countryto']   = df2['countryto'].apply(lambda x:division[x] if x in division else x)\n    df2 = df2.explode('countryfrom').explode('countryto')\n    \n    \n    \n    # removing countries with less then 5 participations and not active in the last 5 years\n    toKeep = df2.groupby('countryfrom').apply(lambda x:pd.Series({\n        'years':x['year'].nunique(),\n        'last_participation':df2['year'].max() - x['year'].max(),\n    })).query(f'years >= {minYears} and last_participation <= {last_participation}').reset_index()['countryfrom'];\n    \n    display(HTML(\"<p>ignored countries: %s<\/p>\" %', '.join(df2[df2['countryfrom'].isin(toKeep)==False]['countryfrom'].unique())))\n\n    df2 = df2[df2['countryfrom'].isin(toKeep)]\n    df2 = df2[df2['countryto'].isin(toKeep)]\n    \n    \n    #keep only the points received at the highest stage (finals\/semifinals)\n    df2['finalcode']=df2.final.map({'f':1,'sf':2,'sf1':2,'sf2':2})\n    temp1 = df2.groupby(['countryto','year']).agg({'finalcode':'min'});\n    df2 = pd.merge(df2,temp1, on=['countryto','year','finalcode'], how='inner')\n    \n    assert len(df2.groupby(['countryfrom','countryto','year']).agg({'final':'nunique'}).query('final >1')) == 0\n    \n    df2.drop(columns=['finalcode','edition'], inplace=True)\n    \n    return df2.reindex()\n\ndf2 = basicClean(df);\ndisplay(HTML(str(len(df2))))\ndf2.sample(5)","182fe35c":"df2\\\n    .groupby(['countryto'])\\\n    .apply(lambda x:pd.Series({\n        'nyear':x['year'].nunique(),\n        'min_year':x['year'].min(),\n        'max_year':x['year'].max(),\n        'presence':int(100*x['year'].nunique()\/(x['year'].max()-x['year'].min()+1))\n    }))\\\n    .sort_values('nyear',ascending=False)\\\n    .style.bar(subset='nyear', color=['royalblue'])\n    #.plot(kind='bar',figsize=(15,2), title='Participation by country');","3b155cc8":"#The Winner\ndf2.query('final ==\"f\"')\\\n    .groupby(['countryto','year']).agg({'points':'sum'}).reset_index()\\\n    .groupby('year').apply(lambda x:x.sort_values('points').tail(1)).reset_index(drop=True)\\\n    .sort_values('year',ascending=False)\\\n    .head(12).T.style.set_caption(\"The Winners\").hide_index()\\\n    #.bar(subset=['points'], color='#d65f5f')","cc8e4ce9":"def atTop(df,tops):\n    #points received\n    df= df.groupby(['countryto','year']).agg({'points':'sum'}).reset_index().groupby('year')\n    \n    #top1 (country with most of points)\n    top = df.apply(lambda x:x.sort_values('points').tail(1)).reset_index(drop=True)\\\n        .groupby('countryto').agg({'year':'nunique'}).rename(columns={'year':'years_on_top'}).reset_index()\n    \n    #the other tops\n    for t in tops:\n        temp = df.apply(lambda x:x.sort_values('points').tail(t)).reset_index(drop=True)\\\n            .groupby('countryto').agg({'year':'nunique'})\\\n            .rename(columns={'year':f'years_on_top_{t}'}).reset_index()\n        top = pd.merge(top,temp, on='countryto',how='outer')\n        \n    top = top.fillna(0);\n    floatcols = top.columns[top.dtypes == 'float64']\n    top[floatcols] = top[floatcols].astype(int)\n        \n    return top","1eb50f6e":"dfAtTop = atTop(df2.query('final ==\"f\"'), tops=[3,5,7,10])\ndfAtTop.sort_values(['years_on_top','years_on_top_3'], ascending=[False,False]).head(20)\\\n    .style.bar(subset=['years_on_top','years_on_top_3','years_on_top_5','years_on_top_7','years_on_top_10'],\n               color='#cccccc')","9e648256":"def plotRankByCountry(countryFrom, minYear, crop = 30):\n    temp = df2 \\\n        .query(f'year >= {minYear} and countryfrom==\"{countryFrom}\"')\\\n    \n    \n    fig, axs = plt.subplots(ncols=2, nrows=2, figsize=(12,8))\n\n    # top friends of Jury\n    temp.pivot_table(index='countryto',columns='votetype',values='points',aggfunc='sum')\\\n        .fillna(0).sort_values('J', ascending=False).head(crop)\\\n        .plot(kind='bar',stacked=True,ax=axs[0,0], title=f'Total point by country after {minYear} from {countryFrom}');\n\n    temp1 =  temp\\\n        .pivot_table(index='countryto',values='points',aggfunc='sum').fillna(0).sort_values('points', ascending=False);\n    \n    \n    ########\n    temp1.apply(lambda x:x\/x.sum()).head(crop)\\\n        .plot(kind='bar',stacked=True,ax=axs[1,0], title=f'Total normalized point by country after {minYear} from {countryFrom}');\n\n    \n    ########  pay attention to number of countries that is necessary to reach pareto\n    temp1.apply(lambda x:x\/x.sum()).cumsum().head(crop)\\\n        .plot(stacked=True,ax=axs[1,0].twinx());\n    axs[1,0].grid(False)\n\n    \n    \n    temp1.apply(lambda x:(1-x\/x.sum()).diff()).head(crop)\\\n        .plot(kind='bar',stacked=True,ax=axs[0,1], title=f'Diff of cummulative curve by country after {minYear} from {countryFrom}');\n\n    def norm(x):\n        x['points'] \/= x['points'].sum()\n        return x\n\n    temp_sorted = temp.groupby('year').apply(norm).reset_index(drop=True)\n    t =temp_sorted.groupby('countryto').sum().sort_values('points').index.values[::-1]\n    t = t[0:crop]\n\n    ax=sns.boxplot(data=temp_sorted[temp_sorted['countryto'].isin(t)], x='countryto', y='points', order=t,ax=axs[1,1]);\n    ax.set_xticklabels(ax.get_xticklabels(),rotation=90);\n    ax.set_title('Boxplot of the normalized points by year sorted by sum')\n    plt.tight_layout()","1aafd45a":"plotRankByCountry(countryFrom = 'Iceland',minYear = 2000, crop=15)","451dd65f":"plotRankByCountry(countryFrom = 'France',minYear = 2000, crop=30)","f5cc48f7":"df2 \\\n    .query('year >= 2000 and countryfrom==\"Spain\"')\\\n    .pivot_table(index='countryto',columns='votetype', values='points',aggfunc='sum').fillna(0).sort_values('J',ascending=False)\\\n    .apply(lambda x: x\/x.sum(), axis=0)\\\n    .plot(kind='bar',stacked=False,figsize=(15,4), title='Countries Spain has voted to');\nplt.grid('off')\nplt.show();","6e3bdcc1":"#use these function to filter out only the top N with most of point by countries\n# or Top %percent of cumsum (useful for Pareto analysis).\n\n\ndef selectTopN(x,column, top=3):\n    x = x.sort_values(column).tail(top)\n    return x;\n\ndef selectTopPercent(x,column, percent=0.2, retrieve_first=True):\n    x = x.sort_values(column, ascending=False)\n    cut = x[column].cumsum() \/ x[column].sum();\n    cut = cut <= percent;\n    \n    #return at least the first and avoid warnings\n    if retrieve_first and cut.sum() ==0:\n        return x.iloc[0];\n    \n    return x[cut==True];","a4ec18e6":"def plot(g, title, ax=None):\n    if ax == None:\n        ax = plt.gca();\n        \n    ax.set_title(title);\n    \n    np.random.seed(12)\n    pos=nx.kamada_kawai_layout(g,weight='weight');\n    nx.draw(g,\n        pos = pos,\n        ax=ax,\n        cmap=plt.cm.viridis_r,\n        edge_color='#cccccc',\n        node_color=list(nx.pagerank(g).values()),\n        font_color='#000',\n        with_labels=True,\n    )\n\n\nplt.figure(figsize=(15,7));\n\n###########################################################################\n### chart with all connections\nplt.subplot(121);\ntemp = df2.groupby(['countryfrom','countryto']).agg({'points':'sum'})\\\n    .reset_index().rename(columns={'points':'weight'})\n\ng = nx.from_pandas_edgelist(temp,'countryfrom','countryto',['weight'], create_using=nx.OrderedDiGraph)\nplot(g,title='all conections',ax=plt.gca())\n\n###########################################################################\n### chat with only top connections  limited to XX % total weight\nplt.subplot(122);\ntemp = df2.groupby(['countryfrom','countryto']).agg({'points':'sum'})\\\n    .reset_index().rename(columns={'points':'weight'})\\\n    .groupby(['countryfrom']).apply(selectTopPercent,'weight',0.3).reset_index(drop=True)\n\ng = nx.from_pandas_edgelist(temp,'countryfrom','countryto',['weight'], create_using=nx.OrderedDiGraph)\nplot(g,title='30% of the edge weight',ax=plt.gca())\n\n\nplt.tight_layout();","bb3ac9e1":"nColumns=8;\nfig, axs = plt.subplots(int(np.ceil(len(nx.algorithms.triads.TRIAD_NAMES)\/nColumns)), nColumns, figsize=(12,4))\n\nfor i,k in enumerate(list(nx.algorithms.triads.TRIAD_NAMES)):\n    ax = axs[i\/\/nColumns, i%nColumns]\n    ax.set_title(f'{k}');\n    nx.draw(nx.triad_graph(k), pos={'a':[0,0],'c':[10,0],'b':[5,10*np.sqrt(3)\/2]},\n            node_size=200, font_size=15,font_color='white', with_labels=True,ax=ax);\n\nax.set_facecolor('#cccccc');\nplt.tight_layout();","afce6841":"def createTriac(df,topN, funcTop=selectTopN):\n    temp = df.groupby(['countryfrom','countryto']).agg({'points':'sum'})\\\n    .reset_index().rename(columns={'points':'weight'})\\\n    .groupby(['countryfrom']).apply(funcTop,'weight',topN).reset_index(drop=True)\n\n    g = nx.from_pandas_edgelist(temp,'countryfrom','countryto',['weight'], create_using=nx.OrderedDiGraph)\n    return nx.triadic_census(g);","06911837":"#selecting only relevant votes from most points to less point as connections\ndisplay(HTML(\"How chosing top N most voted countries as edges can affect the network\"));\ntriads = pd.DataFrame([\n    {'triad':c[0], 'count':c[1], 'topn':n}\n    for n in [1,2,3,4,5,7,10,15,20,25,30,35,41,45]\n    for c in createTriac(df2, n).items()\n]).pivot_table(index='triad',columns='topn', values='count')\ntriads.reindex(index=list(nx.algorithms.triads.TRIAD_NAMES)).style.background_gradient()","6791d466":"display(HTML(\"How chosing top N percent of votes countries as edges can affect the network\"))\ntriads = pd.DataFrame([\n    {'triad':c[0], 'count':c[1], 'percent':int(n*100)}\n    for n in np.linspace(0,1,21)\n    for c in createTriac(df2, n, selectTopPercent).items()\n]).pivot_table(index='triad',columns='percent', values='count')\ntriads.reindex(index=list(nx.algorithms.triads.TRIAD_NAMES)).style.background_gradient()","c68c09eb":"temp = df2.query('year >= 2000').groupby(['countryfrom','countryto']).agg({'points':'sum'})\\\n    .reset_index().rename(columns={'points':'weight'})\\\n    .groupby(['countryfrom']).apply(selectTopPercent,'weight',0.20).reset_index(drop=True)\n\ng = nx.from_pandas_edgelist(temp,'countryfrom','countryto',['weight'])\n#fidler is the second small eigenvector of the laplacian matrix ( Degree matrix - Adjacency matrix)\n#The tells how connected is the graph.the graph can be cut, or split, in two groups with nodes with negative sign and positive sign\nfidVect = nx.linalg.fiedler_vector(nx.Graph(g), weight='weight')\n\n\n\ntemp = nx.to_pandas_adjacency(g,weight='weight');\nplt.subplots(figsize=(13, 10));\nplt.subplot(221)\nnp.random.seed(24);\nnx.draw_spring(g,weight=None, with_labels=True, node_color=fidVect, seed=42,node_size=100, iterations=50,k=1, scale=1, cmap=plt.cm.viridis)\nplt.title('Force Layout View')\nplt.subplot(222)\nplt.title('Fidler second eigenvector (0 is the best cut)')\nplt.plot(fidVect[np.argsort(fidVect)]);\nplt.xlabel('Node order');\nplt.ylabel('Eigen value')\n\nplt.subplot(223)\nsns.heatmap(temp.iloc[np.argsort(temp.index),np.argsort(temp.index)],cmap='Blues');\nplt.title('Alphabetic ordering')\nplt.subplot(224)\nsns.heatmap(temp.iloc[np.argsort(fidVect),np.argsort(fidVect)],cmap='Greens');\nplt.title('Spectral ordering')\nplt.tight_layout()\n","de2476c5":"def normalizer(x):\n    x['points'] = x['points']\/x['points'].sum()\n    return x;\n\ndf3 = df2 \\\n    .query('final==\"f\" and year >= 2000 ')\\\n    .groupby(['countryfrom','countryto'])\\\n    .agg({'points':'sum'}).reset_index()\\\n    .groupby('countryfrom').apply(normalizer).reset_index(drop=True)\\\n    .groupby('countryfrom').apply(selectTopPercent,'points',0.30).reset_index(drop=True)\\\n    .rename(columns={'points':'weight'})\n\nG = nx.from_pandas_edgelist(df3, 'countryfrom','countryto', ['weight'], create_using=nx.OrderedDiGraph)","a2be83fb":"pd.DataFrame(dict(G.out_degree()).items(),columns=['country','out_degree']).groupby('out_degree').count()","a8aa89ff":"import functools\nnodeMeasures = {\n    'pagerank':nx.pagerank(G,weight='weight', max_iter=1000),\n    'eigevector':nx.algorithms.centrality.eigenvector_centrality(G,max_iter=1000),\n    'degree':nx.algorithms.centrality.degree_centrality(G),\n    'betweenness':nx.algorithms.centrality.betweenness_centrality(G),\n    'closeness':nx.algorithms.centrality.closeness_centrality(G),\n};\n\nnodeMeasures = [pd.DataFrame(nodeMeasures[v].items(), columns=['country',v]) for v in nodeMeasures]\n\nnodeMeasures = functools.reduce(lambda  left,right: pd.merge(left,right,on='country', how='outer'), nodeMeasures)\n\ndef pond(x):\n    x['pond'] = (1+x[['pagerank','degree','closeness','betweenness']]).cumprod()[-1]-1;\n    return x;\n\nnodeMeasures = nodeMeasures.apply(pond,axis=1)\n\nnodeMeasures.corr().style.background_gradient().format(\"{:.1%}\")","20c09d34":"nodeMeasures\\\n    .sort_values('pond',ascending=False).set_index('country').round(2)\\\n    .style.background_gradient(axis=0).format(\"{:.5}\")","317b7b70":"def draw_ego(G, n):\n    np.random.seed(12);\n    G = nx.ego_graph(G,n, radius=1);\n    pos = nx.kamada_kawai_layout(G)\n    nx.draw(G,pos = pos,\n                   with_labels=True,arrowsize=25, font_color='black', font_weight='bold', node_size=800,\n                   node_color=[2 if nn == n else 1 for nn in G],\n                   cmap=plt.cm.Set1_r);\n\nplt.figure(figsize=(15,3))\ncs = ['Russia','Sweden', 'Israel','Spain','Switzerland',];\nfor i, c in enumerate(cs):\n    plt.subplot(101+len(cs)*10+i)\n    draw_ego(G,c)\n    plt.gca().set_title(c)\n    \nplt.tight_layout()\nplt.grid(False);","1bdef36a":"plt.figure(figsize=(15,3))\n# pick your country here\ncs = ['Romania','Moldova', 'Italy','San Marino',];\nfor i, c in enumerate(cs):\n    plt.subplot(101+len(cs)*10+i)\n    draw_ego(G,c)\n    plt.gca().set_title(c)\n    \nplt.tight_layout()\nplt.grid(False);","f4e7984b":"# we will pick pageRank becase it scale well and works with directed weighted graphs.\n\ninfluence = nx.pagerank(G,weight='weight')\ninfluenceMax = max(influence.values())","f79a3015":"colors = [sns.color_palette()[c] for c in range(10)]\ncolors = ['#%02x%02x%02x' % (int(r*255), int(g*255), int(b*255)) for (r, g, b) in colors ]\n\n\ncomType = 'louvain';\nif comType == 'LPA':\n    communities = {\n        n:colors[i]\n        for i, c in enumerate(nx.algorithms.community.label_propagation_communities(nx.Graph(G)))\n        for n in list(c)\n    };\nelif comType == 'louvain':      \n    communities = {c:colors[i] for c, i in louvain.best_partition(nx.Graph(G),random_state=42).items()}\nelif comType == 'spectral':\n    from sklearn.cluster import SpectralClustering\n    sc = SpectralClustering(10, affinity='precomputed', n_init=100).fit(nx.to_numpy_matrix(nx.Graph(G)))\n    communities = {c:colors[i] for c, i in zip(G.nodes(), sc.labels_)}","fd2ed810":"# changing the networkx function to draw labels with the same color as the nodes\ndef draw_networkx_labels(G, pos,\n                         labels=None,\n                         font_size=12,\n                         font_color='k',\n                         font_family='sans-serif',\n                         font_weight='normal',\n                         alpha=1.0,\n                         bbox=None,\n                         pos_shift = 0,\n                         ax=None,\n                         **kwds):\n    \"\"\"Draw node labels on the graph G.\n\n    Parameters\n    ----------\n    G : graph\n       A networkx graph\n\n    pos : dictionary\n       A dictionary with nodes as keys and positions as values.\n       Positions should be sequences of length 2.\n\n    labels : dictionary, optional (default=None)\n       Node labels in a dictionary keyed by node of text labels\n\n    font_size : int\n       Font size for text labels (default=12)\n\n    font_color : string\n       Font color string (default='k' black)\n\n    font_family : string\n       Font family (default='sans-serif')\n\n    font_weight : string\n       Font weight (default='normal')\n\n    alpha : float\n       The text transparency (default=1.0)\n\n    ax : Matplotlib Axes object, optional\n       Draw the graph in the specified Matplotlib axes.\n\n    Returns\n    -------\n    dict\n        `dict` of labels keyed on the nodes\n\n    Examples\n    --------\n    >>> G=nx.dodecahedral_graph()\n    >>> labels=nx.draw_networkx_labels(G,pos=nx.spring_layout(G))\n\n    Also see the NetworkX drawing examples at\n    http:\/\/networkx.github.io\/documentation\/latest\/gallery.html\n\n\n    See Also\n    --------\n    draw()\n    draw_networkx()\n    draw_networkx_nodes()\n    draw_networkx_edges()\n    draw_networkx_edge_labels()\n    \"\"\"\n    try:\n        import matplotlib.pyplot as plt\n        import matplotlib.cbook as cb\n    except ImportError:\n        raise ImportError(\"Matplotlib required for draw()\")\n    except RuntimeError:\n        print(\"Matplotlib unable to open display\")\n        raise\n\n    if ax is None:\n        ax = plt.gca()\n\n    if labels is None:\n        labels = dict((n, n) for n in G.nodes())\n\n    # set optional alignment\n    horizontalalignment = kwds.get('horizontalalignment', 'center')\n    verticalalignment = kwds.get('verticalalignment', 'center')\n    \n    if type(font_color) == str:\n        font_color = [font_color]*len(labels);\n\n    text_items = {}  # there is no text collection so we'll fake one\n    for (n, label),_font_color in zip(labels.items(),font_color):\n        (x, y) = pos[n]\n        label = str(label)  # this will cause \"1\" and 1 to be labeled the same\n        t = ax.text(x+pos_shift, y+pos_shift,\n                  label,\n                  size=font_size,\n                  color=_font_color,\n                  family=font_family,\n                  weight=font_weight,\n                  horizontalalignment=horizontalalignment,\n                  verticalalignment=verticalalignment,\n                  transform=ax.transData,\n                  bbox=bbox,\n                  clip_on=True,\n                  )\n        text_items[n] = t\n\n    return text_items\n","5892e5b3":"def plotESC(G, communities, influence, pos,pos_shift=0):\n    eColor = [communities[u] for (u, v, d) in G.edges(data=True)]\n    \n    nx.draw_networkx_edges(\n        G, pos, \n        width=[10*d['weight']+1 for (u, v, d) in G.edges(data=True)],\n        alpha=0.2,\n        edge_color=eColor,\n        zorder=25,);\n    \n    # nodes\n    nx.draw_networkx_nodes(\n        G,\n        pos,\n        linewidths=3,\n        nodelist=influence.keys(),\n        node_size=[400*v\/influenceMax+30 for v in influence.values()],\n        node_color=[communities[c] for c in influence.keys()],\n        zorder=30,\n    )\n    \n    draw_networkx_labels(\n        G,\n        pos,\n        pos_shift=pos_shift,\n        font_size=10,\n        font_weight='bold',\n        font_family='sans-serif',\n        font_color=[communities[c] for c in influence.keys()],\n        zorder=30,\n    )","299455db":"plt.figure(figsize=(17,15), dpi=500)\nplt.gca().set_facecolor('#eeeeFF');\nfor d in countriesBorders['features']:\n    if d['properties']['iso_a2'] in countriesCodes:\n        plotCountry(d['geometry'],'a');\n        \npos = {}\nfor c in G:\n    pos[c] =  latLongFixed.query('countryfrom == \"%s\"'%c)[['Longitude','Latitude']].values.flatten()\n\n\nplotESC(G, communities, influence, pos,pos_shift=1.5);\n\n\nplt.axis('scaled')\n#plt.grid(False)\nplt.xlim(-30,55);\nplt.ylim(30,70);","baf80a01":"shells = pd.merge(\n    pd.DataFrame(communities.items(), columns=['country','cluster']),\n    pd.DataFrame(dict(G.degree()).items(), columns=['country','degree'])\n).sort_values(['cluster','degree'])['country'].values","7e1a083a":"plt.figure(figsize=(18,9))\n\nplt.subplot(121)\nplt.gca().set_facecolor('#eeeeFF');\nnp.random.seed(42)\npos = nx.layout.fruchterman_reingold_layout(nx.Graph(G),k=0.01,iterations=100,scale = 2);\nplotESC(G, communities, influence, pos,pos_shift=0.1);\nplt.grid(False)\n\nplt.subplot(122)\nplt.gca().set_facecolor('#eeeeFF');\npos = nx.shell_layout(G,nlist=[shells])\nplotESC(G, communities, influence, pos,pos_shift=0.05);\nplt.grid(False)\nplt.tight_layout()\nplt.show()\n","007e2b5e":"# function to generate random walk sequences of nodes\ndef get_randomwalk(G, node, path_length, seed=None):\n    \n    if seed is not None:\n        rnd = random.Random(seed)\n    else:\n        rnd = random.Random()\n        \n    random_walk = [node]\n    \n    for i in range(path_length-1):\n        temp = list(G.neighbors(node))\n        temp = list(set(temp) - set(random_walk))    \n        if len(temp) == 0:\n            break\n\n        random_node = rnd.choice(temp)\n        random_walk.append(random_node)\n        node = random_node\n        \n    return random_walk","1c22f5cc":"def deepWalk(G,n_walks = 30, walk_length=15, w2v_window=5, w2v_size=100, w2v_epochs=50):\n    all_nodes = list(G.nodes())\n    random.seed(42)\n    random_walks = []\n\n    for n in tqdm(all_nodes):\n        for i in range(n_walks):\n            random_walks.append(get_randomwalk(G,n,walk_length,42))\n    \n    # train word2vec model\n    model = Word2Vec(window = w2v_window,\n                     size = w2v_size, #embedding size\n                     sg = 1, # 0 cbow , 1 - skip-gram\n                     hs = 0, # 0 - negative-sampling, 1-hierarquical softmax\n                     negative = 10, # for negative sampling\n                     alpha=0.001,\n                     min_alpha=0.007,\n                     seed = 14)\n\n    model.build_vocab(random_walks, progress_per=2)\n    model.train(random_walks, total_examples = model.corpus_count, epochs=w2v_epochs, report_delay=1)\n    return model;","72e00c54":"def deepwal_layout(G):\n    from sklearn.manifold import TSNE\n    nodes = G.nodes();\n    np.random.seed(42);\n    graphEmbeddings = deepWalk(G, w2v_size=5,w2v_window=3,walk_length=20,n_walks=20);\n    vectors = graphEmbeddings[nodes];\n    #print(vectors)\n    loc = TSNE(2, random_state=42).fit_transform(vectors);\n    \n    return {n:v for n,v in zip(nodes,loc)}\n    ","8cdd7fd5":"plt.figure(figsize=(15,15))\n\npos = deepwal_layout(G)\n\nplotESC(G, communities, influence, pos,pos_shift=0);\n\n#plt.axis('scaled')\nplt.grid(False)\nplt.show()\n","e1b5380c":"import math\n\n\n# the Earth is a sphere so eclidean distance will not work\ndef haversine_distance(origin, destination):\n    \"\"\"\n    Calculate the Haversine distance.\n\n    Parameters\n    ----------\n    origin : tuple of float\n        (lat, long)\n    destination : tuple of float\n        (lat, long)\n\n    Returns\n    -------\n    distance_in_km : float\n\n    Examples\n    --------\n    >>> origin = (48.1372, 11.5756)  # Munich\n    >>> destination = (52.5186, 13.4083)  # Berlin\n    >>> round(distance(origin, destination), 1)\n    504.2\n    \"\"\"\n    lat1, lon1 = origin\n    lat2, lon2 = destination\n    radius = 6371  # km\n\n    dlat = math.radians(lat2 - lat1)\n    dlon = math.radians(lon2 - lon1)\n    a = (math.sin(dlat \/ 2) * math.sin(dlat \/ 2) +\n         math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *\n         math.sin(dlon \/ 2) * math.sin(dlon \/ 2))\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    d = radius * c\n\n    return d","4151be5d":"def a(G):\n    nodes = G.nodes();\n    graphEmbeddings = deepWalk(G, w2v_size=5,w2v_window=3,walk_length=15,n_walks=20);\n    vectors = graphEmbeddings[nodes];\n    \n    \n    latLongFixed2 = {c['countryfrom']:(c['Latitude'],c['Longitude']) for c in latLongFixed.to_dict('records')}\n    \n    \n    #plot matriz de similaridade\n    from sklearn.metrics import pairwise_distances\n    from scipy.spatial.distance import cosine\n    \n    pairs = []\n\n    for t in nx.all_pairs_dijkstra_path_length(G, weight=None):\n        root = t[0];\n        for k,v in t[1].items():\n            if k > root:\n                pairs.append({\n                    'source':root,\n                    'target':k,\n                    'graph_distance':v,\n                    'similarity':1-cosine(graphEmbeddings[root],graphEmbeddings[k]),\n                    'haversine_distance':haversine_distance(latLongFixed2[root],latLongFixed2[k]),\n                })\n                \n\n    sns.lineplot(x='graph_distance',y='similarity',data=pd.DataFrame(pairs));\n    plt.show();\n    \n\n    sns.scatterplot(x='graph_distance',y='haversine_distance',data=pd.DataFrame(pairs))\na(G);","3f8526fd":"## Visualization using the embedding space","c9ee41f3":"Some countries seem to concentrate their votes on specific partners and other countries never votes on their neighbours.","7df674ac":"# Visualization using geolocation","900b1398":"# 3. Loading Data <a name='loadingData'><a>","4e69a694":"## Eurovision song contest\n\nEurovision Song Contest is a contest organized by the European Broadcast Union (EBU). Their vision is to united european countries after the WWII.\n\nThe contestant key points are:\n* The event happens annualy since 1956.\n* Every participant broadcaster should indicate an artist or band to represent the country every eary\n* The voting system is divided in Jury Votes and, more recently, the Televoting:\n * Jury is a group of experts that usualy belong to the music industry.\n * Televoting is the vote given by the public using SMS, phone or eurovision app.\n * A country (jury or public) cannot vote himself.\n \n \n* Every country votes in 12 of the 41 participants. The top choice receice 12 points and the last one receive 1 vote.\n * Only the top 3 is annnouced on the finals.\n \n For more information, please check [eurovision.tv](!https:\/\/eurovision.tv\/about\/how-it-works)","b1a17f11":"# First graph visualization","c002fd9d":"# 4. Data exploration <a name='dataExploration'><\/a>\n\n\nThe purpose of this section is to understand how the data is organized, the presence of outliers, etc. And, provide some intuition for the following analysis.","67f67608":"The centrality measures tend to be correlated but the topN changes a little. ","4a80af8c":"* Tamanho do caminho (n_walks):\n* Tamanho da explora\u00e7\u00e3o (walk_length): \n* Tamanho da janela do embedding (w2v_window)\n* Tamanho da embedding (w2v_size):\n* N\u00famero de \u00e9poca da rede neural (w2v_epochs)","b2700ca6":"# Introduction <a name=\"introduction\"><\/a>","9b2a64c2":"### Centrality measures","9f54c21b":"Informal definitions:\n\n| Measure     | Concept                                                                                            |\n|-------------|----------------------------------------------------------------------------------------------------|\n| eigenvector | You are a friend of important people.                                                              |\n| PageRank    | Important people points to you, you must be important. (eigenvector centrality for directed graph) |\n| Degree      | if you have many connections you must be important.                                                |\n| Closeness   | you can reach everyone easily.                                                                     |\n| Betweeness  | you are the crossroad. Everyone has to pass through you to reach other parts of the graph.         |\n\nMany other definitions and concepts are available, but most graph algoritms doesn't scale well (see cliques).","3866ab9f":"Triad\/Triangle represents the smalest communitiy possible in a network. Many configurations of triads are feasible in a directed graph. The picture below shows these combinations and how the choice of the TopN votes for each country could affect the network,  from sparse to a dense small world graph.\n\nWe can see that if we use all the edges the graph will be totally connected and no extra information can be found.\n\n**So it is recommended to choose a cut off to select the most strong connections first**","bfba39dd":"# 6. Exploring spectral graph properties <a name='spectral'><\/a>\n\n- spectral graph theory help us:\n - To find best cuts\n - to uncover possible orders for hidden clustering ( see spectral clustering on Sklearn)","f5d2e2fc":"## Libraries","98588be0":"We clearly see that Iceland has given most of its high votes to its neighbours.","8bbf933c":"The Jury can influence more the result than the public (Televote) and, in many cases, is clear the diference on their preference.","0a4c961d":"This project is mainly focused on graph \/ networks and social networks analysis.  So I did some basic explorations about maps \/ geo information. Below it is manually configured the positions for each country capital.","0f767c97":"* nyear - number of editions\n* min_year - first edition\n* max_year - last edition\n* presence - %participation since first edition","421eacde":"### Some assumptions:\n- We are considering only editions after the 2000 year because:\n - Technology has changed the way these festival are broadcasted\n - Some countries have faced ruptures (Yuguslavia, Germany, etc)\n - Summing 2 decades will smooth the chance of a random country catch the attention of everyone, hence shine the light over partnership between countries (or juries teams).\n- The graph we are exploring is a small world graph:\n - Many countries have high probability to be conected all other nodes.\n - The difference between the first, second and second partner, measured by the rank, compared to the rest is evidente. Removing lower votes helps us to uncover the relationship.\n- Only the finals matter\n- the number of points will be used as weight","1e852514":"# 8. Experimental part of the analysis <a name='experimental'\/>","b5e7840e":"# 2. Study overview <a name=\"overview\"><\/a>\n\n\n## Questions we want to answer\n\n* Is there any bias on voting?\n* What are the most influencial country in the competition ?\n* Are the countries organized in communites ?\n* Are the countries organized by cultural affinity, like languages and so on ?\n* Is the geographical distance important?\n\n","a868e3f7":"## Why using graph analytics on this dataset\n\nDespite of its main effort to unite Europe throught the music, many situation shows a very delicate politicial, social and economic problems.  Follow a list of reasons to study the relationship of european countries in this music festival:\n\n* Political:\n * Germany was reunited.\n * Yuguslavia was splitted in many countries.\n * There were many wars on the balcans (Crimea, Kosovo, etc).\n * Greece, Spain and Portugal were affect by the adoption of Euro and felt into a economic crisis.\n * Imigrations have changed. Ex. Polish people living in Germany can vote on Poland as they were germans.\n * Israel has strong ties with many european countries.\n  * Many arab countries are also part of EBU but choosen not to participate due to Israel.\n  * Iceland protested in Tel Aviv 2019 edition (https:\/\/www.timesofisrael.com\/iceland-fined-for-eurovision-pro-palestinian-protest-at-tel-aviv-final\/)\n * Russia and Ukraine has many territorial disputes:\n  * Jamala's 2017 was seeing as protest over Crimea.\n * Russia still hold strong influence over the former USSR countries.\n * Turkey\/Azerbaijan had and have strong and blood conflits with Arminia (Arminian Genocide).\n \n* Cultural:\n * Many clusters emerge naturally due to language family:\n  * The romance languages in Iberic peninsula.\n  * The slavic languages in the balcan + russia.\n  * The germanic languages in the north.\n  * The greek (pro-greek languages) in Greee, Cyprus and Armenia (debatable)\n * Religions:  Agnostics, muslins, cristhians catholic, cristhians orthodox, etc.\n * LGBT support:\n  * Turkey says will participated on eurovision due to Conchita victory on 2014 edition.\n\n* Some countries allways give their 12 point the their best friends (ex. Greece <--> Cyprus).\n\nThese points were study in some cientific articles. ","aeb11ce9":"Irleand is the country with the largest number of victories but this dataset doesn't containts the editions from 1956 to 1974. ","4d7b3e3c":"# 7. Main Eurovision graph constrution <a name='MainGraph'><\/a>\n\nBuilding a graph after considering data exploration","34e7eb14":"---\n# 5. Exploring the network structure with triads analysis <a name=\"triads\"><\/a>\n\n","94d42eb7":"# Graph Analytics applied to Eurovision Song Contest - A Tutorial","805ef9ae":"![image.png](attachment:image.png)","a8baeb63":"# Table of contents\n1. [Introduction](#introduction)\n2. [Study overview](#overview)\n3. [Loading data](#loadingData)\n4. [Data Exploration](#dataExploration)\n5. [Triads](#Triads)\n6. [Exploring Spectral properties](#spectral)\n7. [Main Eurovision graph constrution](#MainGraph)\n8. [Experimental part of the analysis](#Experimental)\n","103cd513":"### Community detection\n\n- Label Propagation:\n * Set random labels to the nodes; Choose the most common label in the neighbourhood;\n * This method tends to cluster nodes into large communites \n * Very fast\n * Not a good option for highly dense graph.\n\n\n- Louvain Modularity:\n * Brute force assign nodes to clusters in order to maximize the number of edges within cluster.\n * Produces good clusters.\n\n\n- Spectral:\n * Kmeans of the spectral embedding (eigen (vectors+values) of the laplacian matrix)\n * Related to graph cuts","eedb92f0":"# Visualization using only the graph structure","40572cc6":"# Data cleaning\n\n* Removing empty edges (point ==0)\n* Removing edges marked as duplicated\n* Renaming some countries (Macedonia).  Please don't go into political discussions about that.\n* Broadcasting the results of Yugoslavia to its former countries.\n* Removing countries with few participations"}}