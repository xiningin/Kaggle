{"cell_type":{"8cd45cd1":"code","9d917c16":"code","9a9137a2":"code","eb350f88":"code","f9f2626a":"code","2de31861":"code","9f48347a":"code","94c3879a":"code","ade869b9":"code","a4f264c1":"code","e223e31d":"code","e1f98fdd":"code","ede8f499":"code","198de046":"code","0eaeb429":"code","ecf2d554":"code","98f1cae2":"code","0b532678":"code","9747f4d1":"code","5fa90386":"code","50751719":"code","1fee9000":"code","ad110040":"code","43e1d6e2":"code","49434a55":"code","8c345ce1":"code","ee059c24":"code","93617615":"code","17af53ef":"markdown","f4abeb5f":"markdown","fcdb16ab":"markdown","cce535b0":"markdown","04da08ef":"markdown","0893f33e":"markdown","08729fdc":"markdown","30b140a6":"markdown","dc693938":"markdown","bc57c882":"markdown","32627ddf":"markdown"},"source":{"8cd45cd1":"import seaborn as sns\nfrom datetime import datetime\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n","9d917c16":"train_data = pd.read_csv('\/kaggle\/input\/g-research-crypto-forecasting\/train.csv')\nasset_ID = pd.read_csv('\/kaggle\/input\/g-research-crypto-forecasting\/asset_details.csv')","9a9137a2":"asset_ID","eb350f88":"Bitcoin_Cash = train_data[train_data['Asset_ID'] == 2]\nBinance_Coin = train_data[train_data['Asset_ID'] == 0]\nBitcoin = train_data[train_data['Asset_ID'] == 1]\nEOS_IO = train_data[train_data['Asset_ID'] == 5]\nEthereum_Classic = train_data[train_data['Asset_ID'] == 6]\nEthereum = train_data[train_data['Asset_ID'] == 6]\nLitecoin = train_data[train_data['Asset_ID'] == 9]\nMonero = train_data[train_data['Asset_ID'] == 11]\nTRON = train_data[train_data['Asset_ID'] == 13]\nStellar = train_data[train_data['Asset_ID'] == 12]\nCardano = train_data[train_data['Asset_ID'] == 3]\nIOTA = train_data[train_data['Asset_ID'] == 8]\nMaker = train_data[train_data['Asset_ID'] == 10]\nDogecoin = train_data[train_data['Asset_ID'] == 4]","f9f2626a":"Bitcoin_Cash = Bitcoin_Cash.reindex(range(Bitcoin_Cash.index[0], Bitcoin_Cash.index[-1], 60), method = 'pad')\nBinance_Coin = Binance_Coin.reindex(range(Binance_Coin.index[0], Binance_Coin.index[-1], 60), method = 'pad')\nBitcoin = Bitcoin.reindex(range(Bitcoin.index[0], Bitcoin.index[-1], 60), method = 'pad')\nEOS_IO = EOS_IO.reindex(range(EOS_IO.index[0], EOS_IO.index[-1], 60), method = 'pad')\nEthereum_Classic = Ethereum_Classic.reindex(range(Ethereum_Classic.index[0], Ethereum_Classic.index[-1], 60), method = 'pad')\nEthereum = Ethereum.reindex(range(Ethereum.index[0], Ethereum.index[-1], 60), method = 'pad')\nLitecoin = Litecoin.reindex(range(Litecoin.index[0], Litecoin.index[-1], 60), method = 'pad')\nMonero = Monero.reindex(range(Monero.index[0], Monero.index[-1], 60), method = 'pad')\nTRON = TRON.reindex(range(TRON.index[0], TRON.index[-1], 60), method = 'pad')\nStellar = Stellar.reindex(range(Stellar.index[0], Stellar.index[-1], 60), method = 'pad')\nCardano = Cardano.reindex(range(Cardano.index[0], Cardano.index[-1], 60), method = 'pad')\nIOTA = IOTA.reindex(range(IOTA.index[0], IOTA.index[-1], 60), method = 'pad')\nMaker = Maker.reindex(range(Maker.index[0], Maker.index[-1], 60), method = 'pad')\nDogecoin = Dogecoin.reindex(range(Dogecoin.index[0], Dogecoin.index[-1], 60), method = 'pad')","2de31861":"ETH = Ethereum.copy()","9f48347a":"ETH = ETH.Close.fillna(method = 'pad')","94c3879a":"import math\nETH_Target = ETH.values\ntrain_len = math.ceil(len(ETH_Target) * 0.8)","ade869b9":"ETH_Target = ETH_Target.reshape(-1, 1)","a4f264c1":"from sklearn.preprocessing import MinMaxScaler\nNormalize = MinMaxScaler(feature_range=(0, 1))\nETH_Target = Normalize.fit_transform(ETH_Target)","e223e31d":"ETH_train_data, ETH_test_data = ETH_Target[0:train_len, :], ETH_Target[train_len:len(ETH_Target), :1]","e1f98fdd":"x_train = []\ny_train = []\nfor i in range(300, len(ETH_train_data)):\n   x_train.append(ETH_train_data[i-300:i, 0])\n   y_train.append(ETH_train_data[i, 0])\nx_train, y_train = np.array(x_train), np.array(y_train)","ede8f499":"x_train = x_train.reshape(x_train.shape[0], x_train.shape[1], 1)","198de046":"x_test = []\ny_test = []\nfor i in range(300, len(ETH_test_data)):\n   x_test.append(ETH_test_data[i-300:i, 0])\n   y_test.append(ETH_test_data[i, 0])\nx_test, y_test = np.array(x_test), np.array(y_test)","0eaeb429":"x_test = x_test.reshape(x_test.shape[0], x_test.shape[1], 1)","ecf2d554":"x_train.shape","98f1cae2":"from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Dropout, Conv1D, MaxPooling1D, TimeDistributed, Flatten\nfrom tensorflow.keras.utils import plot_model\nmodel = Sequential()\nmodel.add(LSTM(40, return_sequences=True, input_shape=(x_train.shape[1], 1)))\nmodel.add(LSTM(40, return_sequences=True))\nmodel.add(LSTM(40))\nmodel.add(Dense(30))\nmodel.add(Dense(1))\nmodel.compile(loss = 'mse', optimizer = 'adam')\nhistory = model.fit(x_train,y_train, batch_size = 512 , epochs = 20)","0b532678":"sns.set()\ndf_history = pd.DataFrame(history.history)\nsns.lineplot(x = df_history.index, y = df_history.loss)","9747f4d1":"import matplotlib.pyplot as plt\ny_pred = model.predict(x_test)\nplt.scatter(y_test, y_pred)\nplt.plot([x for x in range(2)], [x for x in range(2)], color = 'r')\nplt.xlabel(\"Reality MinMax\")\nplt.ylabel(\"Predicted MinMax\")\nplt.title('ETH')\nplt.show()\nplt.clf()","5fa90386":"y_pred = model.predict(x_test)\ny_test = y_test.reshape(-1, 1)\ny_pred = Normalize.inverse_transform(y_pred)\ny_test = Normalize.inverse_transform(y_test)\ny_pred = y_pred.reshape(len(y_pred), 1)\ny_test = y_test.reshape(len(y_pred), 1)","50751719":"plt.scatter(y_test, y_pred)\nplt.plot([1000*x for x in range(0, 8)], [1000*x for x in range(0, 8)], color = 'r')\nplt.xlabel(\"Reality Prices\")\nplt.ylabel(\"Predicted prices\")\nplt.title('ETH')\nplt.show()\nplt.clf()","1fee9000":"df_pred = pd.DataFrame(y_pred, columns = ['Prediction'], index = ETH.index[train_len +300:])\ndf_pred['Reality'] = y_test","ad110040":"df_pred","43e1d6e2":"def log_return(close):\n    return np.log(close).diff(periods = 15)","49434a55":"ETH_Target[train_len:len(ETH_Target), :1]","8c345ce1":"df_pred['Log_return_prediction'] = log_return(df_pred['Prediction'])[15: ]\ndf_pred['Log_return_reality'] = log_return(df_pred['Reality'])[15: ]","ee059c24":"plt.figure(figsize=(20,10))\nplt.plot(df_pred['Log_return_prediction'], color = 'r' , label = 'Prediction', alpha = 1)\nplt.plot(df_pred['Log_return_reality'], color = 'g', label = 'Reality', alpha = 0.7)\nplt.title('Log_Return Between the Prediction and Reality')\nplt.legend()\nplt.show()","93617615":"plt.figure(figsize = (30, 15))\nsns.lineplot(x = ETH.index[-100000:], y = ETH.values[-100000:], label = f'The ETH Close')\nsns.lineplot(x = df_pred.index, y = df_pred.Prediction, label = 'Prediction', color = 'r')\nsns.lineplot(x = df_pred.index, y = df_pred.Reality, label = 'Reality', color = 'g')\nplt.legend()\nplt.show()","17af53ef":"#### No MinMaxScaler comparsion between prediction(y_pred) price and reality(y_test) price","f4abeb5f":"## Prepare the Time series data\nThe data from No.0 to No.99 is x_train and predicting No.100's data is y_train","fcdb16ab":"# 1. Read the Data\n\nRead the datasets from 'g-research-crypto-forecasting datasets","cce535b0":"# **3. Data Clean**\nAdd the row which is NaN (More information can search the G-Research Crypto Forecasting notebook)","04da08ef":"# **6. The Comparsion between Reality and Pridiction data**\n\n#### After MinMaxScaler comparsion between prediction(y_pred) and reality(y_test)","0893f33e":"# **4. Data Preprocessing for Deep Learning Model**\n## Split the train_data and test_data\nI prepare the bit_train_data and bit_test_data.\nthe first 8 of 19 is bit_train_data, remaining the data as bit_test_data\n","08729fdc":"## Scaler the train, test data\n\nI ues the MinMaxScaler method to scale the data","30b140a6":"# **2. Data exploration**\n## **Take the Ethereum data**\nTake the each Asset_ID data, the Bitcoin is Asset_ID == 1","dc693938":"### the Bitcoin prediction and reality comparsion","bc57c882":"# **5. Deep Learning LSTM Model**","32627ddf":"The data from No.0 to No.99 is x_test and predicting No.100's data is y_test"}}