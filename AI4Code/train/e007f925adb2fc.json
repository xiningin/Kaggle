{"cell_type":{"823fb34e":"code","cb7e2b70":"code","ea907cfb":"code","cfabd3ef":"code","c0c1d58f":"code","8c67bd8a":"code","bd975174":"code","15e48fbc":"code","55ae53ae":"code","5a23eae4":"code","cc35ad89":"code","d6f8ba30":"code","7c4d9373":"code","f63d8f23":"code","73f646c6":"code","26363151":"code","dcfdb873":"code","4473f079":"code","1721d6f6":"code","9d18f2a0":"code","126f636b":"code","25f3cc0b":"code","bb77e7e4":"code","71023a09":"code","f7b53fac":"code","f28c9cf2":"code","5c42af9f":"code","bf73a9d5":"code","84d355f4":"code","eb983966":"code","dffd54aa":"code","cc596d7c":"code","0bdf21d3":"code","70231db2":"code","3c83030c":"code","1ab9bb8b":"code","8ed6def3":"code","38fb4e91":"code","20d3eb9c":"code","b765d7b4":"code","825453e3":"code","65de0b65":"code","b56f840f":"code","6f996d46":"code","e4f7a519":"code","c518d05d":"code","50244bc1":"code","c0ee4056":"code","0544a246":"markdown","25f0da1e":"markdown","b3c14620":"markdown","434bb212":"markdown","8af7e89e":"markdown","259cbf09":"markdown","fc356a26":"markdown","ae667e7a":"markdown","90bb7c75":"markdown","71413c0a":"markdown","f7ce36b0":"markdown","8dd95f2d":"markdown","f9d59d9c":"markdown","566c44b9":"markdown","f05287ff":"markdown","8b3efc21":"markdown"},"source":{"823fb34e":"import numpy as np \nimport pandas as pd\nimport timeit\nimport time\nimport re\n\npd.set_option('display.max_rows', 150)\npd.set_option('display.max_columns', 100)\npd.set_option('display.max_colwidth', None)\npd.set_option('display.width', None)\n\nn_timeit = 1\n\n# Helper functions\ndef concatenate_lines(lines):\n    entry = ''\n    entries = []\n    for line in lines:\n        if line != '':\n            entry += line + ' '\n        else:\n            entries.append(entry)\n            entry = ''\n\n    entries.append(entry) # Last entry before EOF as this does not end on a blank line\n    return pd.DataFrame(entries,columns=['raw'])\n\ndef time_func(func_call, n=200):\n    time = timeit.timeit(stmt = func_call, number = n, globals = globals())\/n\n    print(f'{func_call} done in {time} s')\n    return time\n\nprint('Loaded')","cb7e2b70":"data = pd.read_csv('\/kaggle\/input\/dec1-input\/input.txt', header=None, squeeze=True).tolist()\ndata_df = pd.read_csv('\/kaggle\/input\/dec1-input\/input.txt', header=None)\n\ndata_test = [979, 366, 299, 1721, 675, 1456]\n\ntotal = 2020","ea907cfb":"# Part 1: \ndef get_sum_factor(inputs):\n    \n    inputs = np.array(inputs)\n    \n    for i in inputs:\n\n        idx_sum = np.argwhere((i + inputs) == total)\n        \n        if len(idx_sum) == 0:\n            pass\n        else:\n            pair_num = int(inputs[idx_sum])\n            return [i, pair_num]\n        \n    return [i, pair_num]\n\nn = get_sum_factor(data)\nprint(f'Numbers {n}, summing to {np.sum(n)}, with product {np.product(n)}')","cfabd3ef":"# Part 2\ndef get_sum_factor_3_opt(inputs):\n    inputs = np.array(inputs)\n    \n    for i1, n1 in enumerate(inputs):\n        mask = (inputs < total - n1) # Removing terms that are too big\n        mask[:i1+1] = False            # Removing already checked terms\n        input2 = inputs[mask]\n        \n        for n2 in input2:\n            idx_sum = np.argwhere((n1 + n2 + input2) == total)\n\n            if len(idx_sum) == 0:\n                pass\n            else:\n                n3 = int(input2[idx_sum])\n                return [n1, n2, n3]\n    \n    return 'No solution'\n\nn = get_sum_factor_3_opt(data)\ntime = timeit.timeit(stmt = \"get_sum_factor_3_opt(data)\", number = n_timeit, globals = globals())\/n_timeit\nprint(f'Numbers {n}, summing to {np.sum(n)}, with product {np.product(n)}')\nprint(f'Running in {time} s')","c0c1d58f":"# Data load and preprocess\nd2_df = pd.read_csv('\/kaggle\/input\/input-dec2\/dec2.txt', header=None, names=['raw'])\n\nd2_df[['cnt_min', 'cnt_max', 'char', 'pwd']] = d2_df['raw'].str.split(\"-|: | \", expand=True)\nd2_df[['cnt_min', 'cnt_max']] = d2_df[['cnt_min', 'cnt_max']].astype('int')\nd2_df","8c67bd8a":"# PART 1\n# count character occurences in password\nd2_df['cnt_char'] = d2_df.apply(lambda x: x['pwd'].count(x['char']), axis=1)\n\n# setting password valid status\nd2_df['valid_part1'] = False\n\nmask_ok = (d2_df['cnt_char'] >= d2_df['cnt_min']) & (d2_df['cnt_char'] <= d2_df['cnt_max'])\nd2_df.loc[mask_ok, 'valid_part1'] = True\n\nprint(f'Number of valid passwords: ',d2_df['valid_part1'].sum())\nd2_df","bd975174":"# PART 2\nd2_df['valid_part2'] = d2_df.apply(lambda x:\n                                (x['pwd'][x['cnt_min']-1] == x['char'])  # Check 1. index\n                                ^ # XOR\n                                (x['pwd'][x['cnt_max']-1] == x['char']), # Check 2. index\n                                axis=1)\n\nprint(f'Number of valid passwords: ',d2_df['valid_part2'].sum())\nd2_df","15e48fbc":"# Data load and preprocess\nd3_df = pd.read_csv('\/kaggle\/input\/input-dec3\/dec3.txt', header=None)\n\n# d3_df = pd.DataFrame([\n#     '..##.......',\n#     '#...#...#..',\n#     '.#....#..#.',\n#     '..#.#...#.#',\n#     '.#...##..#.',\n#     '..#.##.....',\n#     '.#.#.#....#',\n#     '.#........#',\n#     '#.##...#...',\n#     '#...##....#',\n#     '.#..#...#.#'])\n\nn_right_pattern = len(d3_df.iloc[0,0])\n\nd3_df = d3_df[0].str.split('', expand=True).drop([0,n_right_pattern+1], axis='columns')\nd3_df.columns = [i for i in range(n_right_pattern)]\nd3_df = d3_df.replace( {'.': 0, '#': 1})\n\nn_down_pattern = len(d3_df)\nn_right_pattern = len(d3_df.iloc[0,:])\n\nright_step = 3\ndown_step = 1\ntotal_steps_down = int((n_down_pattern-1)\/down_step)\ntotal_steps_right = int((right_step\/down_step)*(total_steps_down))\npatterns_reps = int(np.ceil(total_steps_right\/n_down_pattern))\n\nprint(f'Total down steps ({total_steps_down}), total right steps ({total_steps_right}), required pattern reps ({patterns_reps})')\nd3_df","55ae53ae":"# Part 1\ntree_sum = 0\nidx_col = 0\nidx_row = 0\n\nfor i in range(0, total_steps_down + 1):\n    \n    reps = idx_col\/\/n_right_pattern\n    if reps > 0:\n        idx_col = idx_col - reps*n_right_pattern\n    \n    tree_sum += d3_df.iloc[idx_row, idx_col]\n    \n    idx_col += right_step      \n    idx_row += down_step\n    \nprint('Total hit trees: ', tree_sum)","5a23eae4":"# Part 2\ndef traverse_slope(pattern, step_right, step_down):\n    n_down_pattern = len(pattern)\n    n_right_pattern = len(pattern.iloc[0,:])\n    total_steps_down = int((n_down_pattern-1)\/step_down)\n\n    tree_sum = 0\n    idx_col = 0\n    idx_row = 0\n\n    for i in range(0, total_steps_down + 1):\n        \n        reps = idx_col\/\/n_right_pattern\n        if reps > 0:\n            idx_col = idx_col - reps*n_right_pattern\n        \n        tree_sum += pattern.iloc[idx_row, idx_col]\n\n        idx_col += step_right      \n        idx_row += step_down\n\n    return tree_sum\n\nslopes = [[1,1], [3,1], [5,1], [7,1], [1,2]]\ntree_hits = []\n\nfor i in range(len(slopes)):\n    trees = traverse_slope(pattern=d3_df, step_right=slopes[i][0], step_down=slopes[i][1])\n    tree_hits.append(trees)\n    print(f'Slope {slopes[i]} passes {trees} trees')\n\nprint(f'Trees hit multiplicationfactor:', np.prod(np.array(tree_hits)))","cc35ad89":"with open('..\/input\/input-dec4\/dec4.txt','r') as f:\n    lines = f.read().splitlines()\n\nentry = ''\nentries = []\nfor line in lines:\n    if line != '':\n        entry += line + ' '\n    else:\n        entries.append(entry)\n        entry = ''\n\nentries.append(entry) # Last entry before EOF as this does not end on a blank line\nd4_df =  pd.DataFrame(entries)\n\nd4_df.head()","d6f8ba30":"# Part 1\n# entries in field_list are all required to contain a value\nfield_list = ['byr','iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid']\nd4_df['valid'] = False\n\nfor f in field_list:\n    valid_field = d4_df[0].str.contains(f, na=False).astype('int')\n    d4_df['valid'] = d4_df['valid'] + valid_field\n    \nd4_df['valid'] = (d4_df['valid']\/len(field_list)).astype('int') #renormalize to 0 or 1\nprint(f'Part 1: Number of valid passports: ', d4_df['valid'].sum())\nd4_df.head()","7c4d9373":"# Part 2\nd = d4_df.copy()\n\n# assigning field values to columns\nfor f in field_list:\n    l = len(f)\n\n    d[f] = d[0].apply(lambda x: x[x.find(f)+l+1:x.find(' ', x.find(f))].strip())\n    d.loc[d[f].str[0] == ':', f] = '' # not found set to blank\n\nd.head()","f63d8f23":"# Validity of each field\n# byr (Birth Year) - four digits; at least 1920 and at most 2002.\nd['status_byr'] = (d['byr'] >= str(1920)) \\\n                & (d['byr'] <= str(2002))\n\n# iyr (Issue Year) - four digits; at least 2010 and at most 2020.\nd['status_iyr'] = (d['iyr'] >= str(2010)) \\\n                & (d['iyr'] <= str(2020))\n\n# eyr (Expiration Year) - four digits; at least 2020 and at most 2030.\nd['status_eyr'] = (d['eyr'] >= str(2020)) \\\n                & (d['eyr'] <= str(2030))\n\n# hgt (Height) - a number followed by either cm or in:\n#   If cm, the number must be at least 150 and at most 193.\n#   If in, the number must be at least 59 and at most 76.\nd['status_hgt'] = False\nd.loc[d['hgt'].str[-2:] == 'cm','status_hgt'] = (d['hgt'].str[-2:] == 'cm') \\\n                                              & (d['hgt'].str[:-2] >= str(150))\\\n                                              & (d['hgt'].str[:-2] <= str(193))\n\nd.loc[d['hgt'].str[-2:] == 'in','status_hgt'] = (d['hgt'].str[-2:] == 'in') \\\n                                              & (d['hgt'].str[:-2] >= str(59)) \\\n                                              & (d['hgt'].str[:-2] <= str(76))\n\n# hcl (Hair Color) - a # followed by exactly six characters 0-9 or a-f.\nd['status_hcl'] = (d['hcl'].str[0] == '#') \\\n                & ((d['hcl'].str.len() == 7)) \\\n                & (d['hcl'].apply(lambda x: all(c in '0123456789abcdef' for c in x[1:])))\n\n# ecl (Eye Color) - exactly one of: amb blu brn gry grn hzl oth.\nd['status_ecl'] = (d['ecl'].isin(['amb', 'blu', 'brn', 'gry', 'grn', 'hzl', 'oth']))\n\n# pid (Passport ID) - a nine-digit number, including leading zeroes.\nd['status_pid'] = (d['pid'].str.len() == 9) \\\n                & (d['pid'].str.isnumeric())\n\nd['valid_part2'] = d[['status_byr','status_iyr','status_eyr','status_hgt','status_hcl','status_ecl','status_pid']].prod(axis=1)\nprint('Part 2: Number of valid passports: ', d['valid_part2'].sum())\nd.head()","73f646c6":"d5_df = pd.read_csv('..\/input\/input-dec5\/dec5.txt', header=None, names=['raw'])\nd_test = pd.DataFrame(['FBFBBFFRLR', 'BFFFBBFRRR', 'FFFBBBFRRR', 'BBFFBBFRLL'])\nd5_df.head()","26363151":"# Part 1\ndef dwindle(code, lb_ini, ub_ini):    \n    ub = ub_ini\n    lb = lb_ini\n    \n    for c in code:\n        half = (ub - lb)\/2\n        if c in ['F','L'] :\n            ub = np.floor(ub - half)\n            idx = lb\n        else:\n            lb = np.ceil(lb + half)\n            idx = ub\n            \n    return int(idx)\n\ndef get_seat(code):\n    row = dwindle(code[:7], lb_ini = 0, ub_ini=127)\n    col = dwindle(code[7:], lb_ini = 0, ub_ini=7)\n    seat = int((row * 8) + col)\n    #print(f'row {row}, col {col}, seat {seat}')\n\n    return seat\n    \n\nd5_df['seat'] = d5_df['raw'].apply(lambda x: get_seat(x))\n\nprint(f'Highest seat ID on boarding passes: ', d5_df['seat'].max())","dcfdb873":"# Part 2\n# seat ids where +1 and -1 exists\nd5_df = d5_df.sort_values(by='seat').reset_index(drop=True)\nd5_df['seat_diff'] = d5_df['seat'].diff()\nmy_seat = int(d5_df.loc[d5_df['seat_diff'] > 1, 'seat'].values - 1)\n\nprint('My seat: ', my_seat)","4473f079":"with open('..\/input\/input-dec6\/dec6.txt','r') as f:\n    lines = f.read().splitlines()\n\nd6_df = concatenate_lines(lines)\n#d6_df = pd.DataFrame(['abc','a b c','ab ac', 'a a a a','b'], columns=['raw'])\nd6_df.head()","1721d6f6":"# Part 1\nd6_df['cnt_unique'] = d6_df['raw'].apply(lambda x: len(set(x.replace(' ', ''))))\n\nprint(f'Sum of declared goods: ', d6_df['cnt_unique'].sum())\nd6_df.head()","9d18f2a0":"# part 2\ndef grp_count(row):\n    ppl = row.count(' ')\n    grp_cnt = 0\n    for c in set(row.replace(' ', '')):\n        grp_cnt += row.count(c)\/\/ppl\n    \n    return grp_cnt\n\nd6_df['cnt_grp'] = d6_df['raw'].apply(lambda x: grp_count(x))\n\nprint(f'Sum of declared goods: ', d6_df['cnt_grp'].sum())\nd6_df.head()","126f636b":"with open('..\/input\/input-dec7\/dec7.txt','r') as f:\n    lines = f.read().splitlines()\n    \ntest = ['light red bags contain 1 bright white bag, 2 muted yellow bags.',\n'dark orange bags contain 3 bright white bags, 4 muted yellow bags.',\n'bright white bags contain 1 shiny gold bag.',\n'muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.',\n'shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.',\n'dark olive bags contain 3 faded blue bags, 4 dotted black bags.',\n'vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.',\n'faded blue bags contain no other bags.',\n'dotted black bags contain no other bags.']\nd7_df = pd.DataFrame(lines, columns=['raw'])","25f3cc0b":"# Process lines\nd7_df['processed']=d7_df['raw'].apply(lambda x: x\n                                    .replace(' bags', ' bag')\n                                    .replace(' bag', '')\n                                    .replace(' contain ', ':')\n                                    .replace(', ', ':')\n                                    .replace('.', '')\n                                    .replace(' ', '_')\n                                    .replace('no_other', '0_no_other'))\n\nd7_df['bag'] = d7_df['processed'].apply(lambda x: x[0:x.find(':',1)])\nd7_df['content'] = d7_df['processed'].apply(lambda x: x[x.find(':',1)+1::])\nd7_df = d7_df.drop(columns=['processed'])\nd7_df.head()","bb77e7e4":"# Part 1\nbags_find = ['shiny_gold']\nin_bags_hist = []\nkeep_running = True\n\nwhile keep_running:\n\n    in_bags = []\n    in_bags = d7_df.loc[d7_df['content'].str.contains('|'.join(bags_find)), 'bag'].unique()\n    \n    in_bags_hist.append(in_bags)\n    \n    if len(in_bags) == 0:\n        keep_running = False\n    \n    bags_find = in_bags\n\nhist = np.unique([bag for bag_list in in_bags_hist for bag in bag_list])\nprint('Part1: Number of ways to carry at least 1 shiny gold bag: ', len(hist))","71023a09":"# Part 2\ndef sub_bag_cnt(bag, find_bag):\n    sub_bags = bag.loc[bag['bag'] == find_bag, 'content'].str.split(':').iloc[0]\n    sub_bag_list = [[b[b.find('_',1)+1:], int(b[:b.find('_',1)])] for b in sub_bags]\n\n    sub_cnt = 0\n    for sb in sub_bag_list:\n        if sb[1] == 0: # No sub bags\n            sub_cnt = 1\n        else:\n            # Recursive call\n            rec_cnt = sub_bag_cnt(bag, sb[0])\n            # Condition to add bags holding other bags to the sum, but not empty bags\n            if rec_cnt == 1:\n                sub_cnt += sb[1]*rec_cnt\n            else:\n                sub_cnt += sb[1]*rec_cnt + sb[1]\n    return sub_cnt\n            \n\nbags_find = 'shiny_gold'\nbag_count = sub_bag_cnt(d7_df, bags_find)\ntime = timeit.timeit(stmt = \"sub_bag_cnt(d7_df, bags_find)\", number = n_timeit, globals = globals())\/n_timeit\nprint(f'Part2: Number of sub-bags within bag {bags_find}: ', bag_count)\nprint(f'Done in {time} s')","f7b53fac":"test = ['nop +0',\n'acc +1',\n'jmp +4',\n'acc +3',\n'jmp -3',\n'acc -99',\n'acc +1',\n'jmp -4',\n'acc +6']\nd8_df = pd.DataFrame(test, columns=['raw'])\nd8_df = pd.read_csv('..\/input\/input-dec8\/dec8.txt', names=['raw'])\nd8_df[['inst', 'arg']] = d8_df['raw'].str.split(' ', expand=True)\nd8_df['arg'] = pd.to_numeric(d8_df['arg'], downcast='integer')\nd8_df['visited'] = 0\nd8_df","f28c9cf2":"def follow_instruction_list(i,a):\n    acc = 0\n    idx = 0\n    n_eof = len(i)\n    visits = np.zeros(n_eof)\n    \n    keep_running = True\n    \n    while keep_running:\n        instruction = i[idx]\n        argument = a[idx]\n        visits[idx] +=  1\n\n        if visits[idx] <= 1:\n            if instruction == 'acc':\n                acc += argument\n                idx += 1\n            elif instruction == 'jmp':\n                idx += argument\n            else:\n                idx += 1\n                \n            if idx == n_eof:\n                keep_running = False\n                termination_reason = 'EOF'\n        else:\n            keep_running = False\n            termination_reason = 'INF LOOP'\n            \n    return acc, termination_reason\n\ninst = d8_df['inst'].to_list()\narg = d8_df['arg'].to_list()\nacc_fin, termination_reason = follow_instruction_list(inst,arg)\ntime = timeit.timeit(stmt = \"follow_instruction_list(inst,arg)\", number = 10, globals = globals())\/10\nprint(f'Part 1: Terminated due to {termination_reason}. Accumulator value after 1 run: ', acc_fin)\nprint(f'Done in {time} s')","5c42af9f":"# Part 2\ncount_flips = d8_df.loc[d8_df['inst'].isin(['nop', 'jmp']),'inst'].count()\nprint('Number of possible nop and jmp flips: ', count_flips)\nprint('Brute for checking requires a max time (Seconds) of: ', count_flips*time)\n\ndef flip_inst_list(inst,a):\n    for j, i in enumerate(inst):\n        if i == 'nop':\n            inst[j] = 'jmp'\n            acc_fin, termination_reason = follow_instruction_list(inst, a)\n            inst[j] = 'nop'\n\n        elif i == 'jmp':\n            inst[j] = 'nop'\n            acc_fin, termination_reason = follow_instruction_list(inst, a)\n            inst[j] = 'jmp'\n\n        if termination_reason == 'EOF':\n            #print(f'No infinite loop. Flipped on index {j}, ')\n            break\n            \n    return acc_fin, termination_reason\n\nacc_fin, termination_reason = flip_inst_list(inst,arg)\ntime = timeit.timeit(stmt = \"flip_inst_list(inst,arg)\", number = 10, globals = globals())\/10\nprint(f'Part 2: Terminated due to {termination_reason}. Accumulator value after run: ', acc_fin)\nprint(f'Done in {time} s')","bf73a9d5":"# Precessing\ntest = [35,  20,    15,    25,    47,    40,    62,    55,    65,    95,    102,    117,    150,    182,    127,    219,    299,    277,    309,    576]\n\nd9_df = pd.read_csv('..\/input\/input-dec9\/dec9.txt', names=['raw'])","84d355f4":"#Part 1\ndef find_sum(data, preamb):\n    idx = preamb\n\n    while True:\n        n = data[idx]\n        elements = data[idx - preamb:idx]\n        sum_exist = False\n        \n        for i, e in enumerate(elements):\n            sum_exist = (n - e) in (elements[:i]+elements[i+1:])\n            if sum_exist:\n                break\n\n        if sum_exist is False:\n            break\n        else:\n            idx += 1\n\n    return n\n\npreamb = 25\ninput_lst = d9_df['raw'].to_list()\nn = find_sum(input_lst,preamb)\nprint(f'Part 1: The first number which is not the sum of two elements of previous {preamb} is :', n)\nt = time_func(\"find_sum(input_lst,preamb)\", n=100)","eb983966":"# Part 2\ndef get_continous_sum_range(lst, n):\n    lst = np.array(lst)\n    cumsum = lst.cumsum()\n\n    for c in cumsum:\n        if n in cumsum:\n            break\n        else:\n            cumsum -= c \n\n    idx_start = np.where(cumsum > 0)[0][0]\n    idx_end = np.where(cumsum == n)[0][0] + 1\n\n    cont_set = lst[idx_start:idx_end]\n    range_min = cont_set.min()\n    range_max = cont_set.max()\n    min_max_sum = range_min + range_max\n    \n    return range_min, range_max, min_max_sum\n\n#get_continous_sum_range(test, 127)\nrange_min, range_max, min_max_sum = get_continous_sum_range(input_lst, 552655238)\nprint(f'Part 2: Minimum entry is {range_min}, Maximum entry is {range_max}, sum of min\/max is {min_max_sum}')\nt = time_func(\"get_continous_sum_range(input_lst, 552655238)\", n=100)","dffd54aa":"test=[16,\n10,\n15,\n5,\n1,\n11,\n7,\n19,\n6,\n12,\n4]\ntest2 = [28,\n33,\n18,\n42,\n31,\n14,\n46,\n20,\n48,\n47,\n24,\n23,\n49,\n45,\n19,\n38,\n39,\n11,\n1,\n32,\n25,\n35,\n8,\n17,\n7,\n9,\n4,\n2,\n34,\n10,\n3]\n\n\nd10_df = pd.DataFrame(test2,columns=['rating'])\nd10_df = pd.read_csv('..\/input\/input-dec10\/dec10.txt', names=['rating'])\nprint('Number of adaptor: ', len(d10_df))\nd10_df = d10_df.append({'rating': 0},ignore_index=True) # Append the outlet rating\nd10_df = d10_df.append({'rating': d10_df['rating'].max()+3},ignore_index=True) # Append the device rating","cc596d7c":"# Part 1\ndef find_ratings_seq(df):\n    df = df.sort_values(by='rating').reset_index(drop=True)\n    df['sequence_diff'] = df['rating'].diff()\n    \n    if (df['sequence_diff'] > 3).sum() > 0:\n        print('Cannot use all adaptors')\n    else:    \n        cnt_diff_1 = (df['sequence_diff'] == 1).sum()\n        cnt_diff_3 = (df['sequence_diff'] == 3).sum()\n\n        return cnt_diff_1, cnt_diff_3\n\nc1, c3 = find_ratings_seq(d10_df)\nprint(f'Part 1: count of 1-diff-ratings {c1}, count of 3-diff-ratings {c3}, product of counts: ', c1*c3)\nt = time_func(\"find_ratings_seq(d10_df)\", n=1000)","0bdf21d3":"# Part 2\ndef get_configurations(df):\n    df = df.sort_values(by='rating').reset_index(drop=True)\n    df['rating_diff_1'] = df['rating'].diff(periods=1)\n    df['rating_diff_2'] = df['rating'].diff(periods=2)\n    df['back_cover'] = (df[['rating_diff_1','rating_diff_2']] <= 3).sum(axis=1)\n\n    df['states'] = df['back_cover'].shift(-1)\n    \n    # if adapter 3 and 2 are off, then adapter 1 has to be on\n    df.loc[(df['states'].shift(-2) > 1)\n           & (df['states'].shift(-1) > 1)\n           & (df['states'] > 1), 'states'] = 2*(2**3 - 1)\/(2**3)\n\n    d10_df.loc[0,'states'] = 1 # first entry is outlet and state cannot change\n    \n    return df\n\nres_df = get_configurations(d10_df)\nprint(f'Part 2: Possible adapter configurations: ', int(res_df['states'].prod()))\nt = time_func(\"get_configurations(d10_df)\", n=1000)\nres_df","70231db2":"test= [['L.LL.LL.LL'],\n['LLLLLLL.LL'],\n['L.L.L..L..'],\n['LLLL.LL.LL'],\n['L.LL.LL.LL'],\n['L.LLLLL.LL'],\n['..L.L.....'],\n['LLLLLLLLLL'],\n['L.LLLLLL.L'],\n['L.LLLLL.LL']]\n\nd11_df = pd.DataFrame(test, columns=['raw'])\nd11_df = pd.read_csv('..\/input\/input-dec11\/dec11.txt', names=['raw'])\n#d11_df['proc'] =d11_df['raw'].str.replace('L', '0')\n#d11_df['proc'] =d11_df['proc'].str.replace('.', 'X')\nd11_df.head()","3c83030c":"# Part1\ndef seat_free(layout, row, col):\n    idx_max= len(layout[0])\n    col_idx_i = max(col-1,0)\n    col_idx_f = min(col+1,idx_max)+1\n    row_idx_i = max(row-1,0)\n    row_idx_f = min(row+1,idx_max)+1\n\n    neighbor_cnt = ''.join([r[col_idx_i:col_idx_f] for r in layout[row_idx_i:row_idx_f]]).count('#')\n\n    return neighbor_cnt\n\ndef get_final_seats(layout):\n\n    n_rows = len(layout)\n    n_cols = len(layout[0])\n    layout_new = layout.copy()\n    keep_running = True\n    n_iter = 0\n    while keep_running:\n        for r in range(n_rows):\n            for c in range(n_cols):\n                if layout[r][c] != '.':\n                    neighbors = seat_free(layout,row=r,col=c)\n                    if neighbors >= 4+1:\n                        layout_new[r] = layout_new[r][:c] + 'L' + layout_new[r][c + 1:]\n                    elif neighbors == 0:\n                        layout_new[r] = layout_new[r][:c] + '#' + layout_new[r][c + 1:]\n\n        n_iter += 1\n        if layout == layout_new:\n            keep_running = False\n        layout = layout_new.copy()\n    \n    total_seats = ''.join([rows for rows in layout]).count('#')\n    \n    return n_iter, total_seats\n\ndf_lst = d11_df['raw'].to_list()\nn_iter, total_seats = get_final_seats(df_lst)\nprint(f'Part 1: After {n_iter} iterations, the number of seated people is: ', total_seats)\nt = time_func(\"get_final_seats(df_lst)\", n=1)","1ab9bb8b":"# Part 2\ndef get_neighbor(layout, row_ini, col_ini, step_row, step_col, row_max, col_max):\n    row = row_ini + step_row\n    col = col_ini + step_col\n    state = 'B'\n    keep_running = True\n    \n    while keep_running & (row >= 0) & (row <= row_max) & (col >= 0) & (col <= col_max):\n        state = layout[row][col]\n        \n        if state != '.':\n            keep_running = False\n            \n        else:\n            row += step_row\n            col += step_col\n            \n    n = state.count('#')\n    \n    return n\n    \ndef get_final_seats_2(layout):\n    idx_row_max = len(layout) - 1\n    idx_col_max = len(layout[0]) - 1\n    layout_new = layout.copy()\n    \n    keep_running = True\n    n_iter = 0\n    while keep_running:\n        for r in range(idx_row_max+1):\n            for c in range(idx_col_max+1):\n                neighbors = 0\n                if layout[r][c] != '.':\n                    neighbors += get_neighbor(layout, row_ini=r, col_ini=c, step_row=-1, step_col=+0, row_max=idx_row_max, col_max=idx_col_max) # up\n                    neighbors += get_neighbor(layout, row_ini=r, col_ini=c, step_row=-1, step_col=+1, row_max=idx_row_max, col_max=idx_col_max) # diag right up\n                    neighbors += get_neighbor(layout, row_ini=r, col_ini=c, step_row=+0, step_col=+1, row_max=idx_row_max, col_max=idx_col_max) # right\n                    neighbors += get_neighbor(layout, row_ini=r, col_ini=c, step_row=+1, step_col=+1, row_max=idx_row_max, col_max=idx_col_max) # diag right down\n                    neighbors += get_neighbor(layout, row_ini=r, col_ini=c, step_row=+1, step_col=+0, row_max=idx_row_max, col_max=idx_col_max) # down\n                    neighbors += get_neighbor(layout, row_ini=r, col_ini=c, step_row=+1, step_col=-1, row_max=idx_row_max, col_max=idx_col_max) # diag left down\n                    neighbors += get_neighbor(layout, row_ini=r, col_ini=c, step_row=+0, step_col=-1, row_max=idx_row_max, col_max=idx_col_max) # left\n                    neighbors += get_neighbor(layout, row_ini=r, col_ini=c, step_row=-1, step_col=-1, row_max=idx_row_max, col_max=idx_col_max) # diag left up\n                    \n                    if neighbors >= 5:\n                        layout_new[r] = layout_new[r][:c] + 'L' + layout_new[r][c + 1:]\n                    elif neighbors == 0:\n                        layout_new[r] = layout_new[r][:c] + '#' + layout_new[r][c + 1:]\n\n        n_iter += 1\n        if layout == layout_new:\n            keep_running = False\n        layout = layout_new.copy()\n\n    \n    total_seats = ''.join([rows for rows in layout]).count('#')\n\n    return n_iter, total_seats, layout\n\ndf_lst = d11_df['raw'].to_list()\n\nn_iter, total_seats, layout_final = get_final_seats_2(df_lst)\nprint(f'Part 1: After {n_iter} iterations, the number of seated people is: ', total_seats)\nt = time_func(\"get_final_seats_2(df_lst)\", n=1)\n","8ed6def3":"test = ['F10',\n'N3',\n'F7',\n'R90',\n'F11']\n\nd12_df = pd.DataFrame(test, columns=['raw'])\nd12_df = pd.read_csv('..\/input\/input-dec12\/dec12.txt', names=['raw'])\nd12_df['command'] = d12_df['raw'].str[0]\nd12_df['step'] = pd.to_numeric(d12_df['raw'].str[1:])\nprint('Command types and counts:\\n',d12_df['command'].value_counts())\nprint('Turn values and counts:\\n',d12_df.loc[d12_df['command'].isin(['L','R']),'step'].value_counts())","38fb4e91":"# Part 1\nE_coord = 0\nN_coord = 0\nX = [E_coord, N_coord]\n# Coordinate moves\nmoves_north = int(d12_df.loc[d12_df['command'] == 'N', 'step'].sum())\nmoves_south = int(d12_df.loc[d12_df['command'] == 'S', 'step'].sum())\nmoves_west = int(d12_df.loc[d12_df['command'] == 'W', 'step'].sum())\nmoves_east = int(d12_df.loc[d12_df['command'] == 'E', 'step'].sum())\nN_coord = moves_north - moves_south\nE_coord = moves_east - moves_west\n\n# directional moves\nmask = d12_df['command'].isin(['L','R', 'F'])\ncommand = d12_df.loc[mask, 'command'].to_list()\nstep = pd.to_numeric(d12_df.loc[mask, 'step']).to_list()\ndirections = ['E', 'N', 'W', 'S']\n\nfacing = 'E'\ndirection_idx = directions.index(facing)\n\nfor c, s in zip(command, step):\n    if c == 'L':\n        direction_idx = (direction_idx + s\/\/90)%4\n        facing = directions[direction_idx]\n    elif c == 'R':\n        direction_idx = (direction_idx - s\/\/90)%4\n        facing = directions[direction_idx]\n    else:\n        if facing == 'N':\n            N_coord += s\n        elif facing == 'S':\n            N_coord -= s\n        elif facing == 'E':\n            E_coord += s\n        elif facing == 'W':\n            E_coord -= s\n\nX = [E_coord, N_coord]\nprint(f'Final coordinate (East, North) is ({X}). Distance from start: ', np.abs(X).sum())","20d3eb9c":"# Part 2\ndef rotate_wp(x,y, deg):\n    rad = deg\/360*2*np.pi\n    x_new = np.cos(rad)*x - np.sin(rad)*y\n    y_new = np.sin(rad)*x + np.cos(rad)*y\n    \n    return round(x_new), round(y_new)\n\ndef rotate_90(x,y, deg):\n    if deg < 0:\n        s = -1\n    else:\n        s = 1\n\n    for i in range(abs(deg\/\/90)):\n        x_new = -y*s\n        y = x*s\n        x = x_new\n        \n    return x, y\n\ndef follow_instruction(command, step):\n    wp_E = 10\n    wp_N = 1\n    ship_E = 0\n    ship_N = 0\n\n    directions = ['E', 'N', 'W', 'S']\n\n    for c, s in zip(command, step):\n        if c in directions:\n            if c == 'N':\n                wp_N += s\n            elif c == 'S':\n                wp_N -= s\n            elif c == 'E':\n                wp_E += s\n            elif c == 'W':\n                wp_E -= s\n        elif c in ['L', 'R']:\n            if c == 'L':\n                wp_E, wp_N = rotate_wp(wp_E,wp_N, deg=+s)\n            elif c == 'R':\n                wp_E, wp_N = rotate_wp(wp_E,wp_N, deg=-s)\n        else:\n            #moce forward\n            ship_E += s*wp_E\n            ship_N += s*wp_N\n            \n    return ship_E, ship_N\n\ndef follow_instruction_signed(command, step):\n    wp_E = 10\n    wp_N = 1\n    ship_E = 0\n    ship_N = 0\n\n    for c, s in zip(command, step):\n        if c == 'N':\n            wp_N += s\n        elif c == 'E':\n            wp_E += s\n        elif c == 'L':\n            wp_E, wp_N = rotate_90(wp_E,wp_N, deg=s)\n        else:\n            ship_E += s*wp_E\n            ship_N += s*wp_N\n            \n    return ship_E, ship_N\n\nd12_df['command_signed'] = d12_df['command'].copy()\nd12_df['step_signed'] = d12_df['step'].copy()\nd12_df.loc[d12_df['command'] == 'S','command_signed'] = 'N'\nd12_df.loc[d12_df['command'] == 'S','step_signed'] = -1*d12_df.loc[d12_df['command'] == 'S','step']\nd12_df.loc[d12_df['command'] == 'W','command_signed'] = 'E'\nd12_df.loc[d12_df['command'] == 'W','step_signed'] = -1*d12_df.loc[d12_df['command'] == 'W','step']\nd12_df.loc[d12_df['command'] == 'R','command_signed'] = 'L'\nd12_df.loc[d12_df['command'] == 'R','step_signed'] = -1*d12_df.loc[d12_df['command'] == 'R','step']\n\ncommand = d12_df.loc[:, 'command'].to_list()\nstep = pd.to_numeric(d12_df.loc[:, 'step']).to_list()\nship_E, ship_N = follow_instruction(command, step)\nX = [ship_E, ship_N]\nprint(f'Final coordinate (East, North) is ({X}). Distance from start: ', np.abs(X).sum())\n\ncommand_signed = d12_df.loc[:, 'command_signed'].to_list()\nstep_signed = pd.to_numeric(d12_df.loc[:, 'step_signed']).to_list()\nship_E, ship_N = follow_instruction_signed(command_signed, step_signed)\nX = [ship_E, ship_N]\nprint(f'Final coordinate (East, North) is ({X}). Distance from start: ', np.abs(X).sum())\n\nt = time_func(\"follow_instruction(command, step)\", n=1000)\nt = time_func(\"follow_instruction_signed(command_signed, step_signed)\", n=1000)","b765d7b4":"with open('..\/input\/input-dec13\/dec13.txt','r') as f:\n    lines = f.read().splitlines()\n\ntime = 939\ntest = ['7','13','x','x','59','x','31','19']\nd13_df = pd.DataFrame(test, columns=['raw'])\n\ntime = int(lines[0])\nschedule = lines[1].split(',')\nd13_df = pd.DataFrame(schedule, columns=['raw'])\n\nd13_df['raw'] = d13_df['raw'].str.replace('x', '0')\nd13_df['raw'] = pd.to_numeric(d13_df['raw'])\nd13_df['depart'] = np.ceil(time \/ d13_df['raw']) * d13_df['raw']\nd13_df['wait'] = d13_df['depart'] - time\nwait_min = d13_df['wait'].min()\nfirst_bus = d13_df.loc[d13_df['wait'] == wait_min,'raw'].iloc[0]\n\nprint(f'Part 1: First available bus is {first_bus} with a wait time of {wait_min}. Product is', first_bus*wait_min)","825453e3":"# Part 2\nd13_df['idx'] = d13_df.index\nmask = d13_df['raw'] != 0\n\norder = d13_df.loc[mask, 'idx'].to_list()\ndep_int = d13_df.loc[mask, 'raw'].to_list()\n# order = [0,1,2,3]\n# dep_int =[1789,37,47,1889]\n\ndef calc_time():\n    times = [dep_int[0]]\n    for i in range(2,len(dep_int)+1):\n        times = np.array([t for t\n                          in range(times[0],\n                                   np.prod(dep_int[:i]) + 1,\n                                   np.prod(dep_int[:i-1]))\n                          if (t+order[i-1])%dep_int[i-1] == 0])\n    return times\n\nprint(f'Part 2: time for departure to match bus ordering: ', calc_time())\nt = time_func(\"calc_time()\", n=1000)","65de0b65":"with open('..\/input\/input-dec14\/dec14.txt','r') as f:\n    lines = f.read().splitlines()\n    \ntest = ['mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X',\n       'mem[8] = 11',\n       'mem[7] = 101',\n       'mem[8] = 0']\ntest2 = ['mask = 000000000000000000000000000000X1001X',\n          'mem[42] = 100',\n          'mask = 00000000000000000000000000000000X0XX',\n          'mem[26] = 1']\ncommand = []\nvalue = []\nmem_idx = []\nfor l in lines:\n    lst = l.replace('mem[','').replace(']','').split(' = ')\n    if lst[0] == 'mask':\n        command.append(lst[0])\n        value.append(lst[1])\n    else:\n        command.append(int(lst[0]))\n        value.append(int(lst[1]))\n        mem_idx.append(int(lst[0]))\n\nmax_mem = max(mem_idx)\ndigits = len(value[0])","b56f840f":"def mask_convert(mask):\n    mask_product = mask.replace('1','0').replace('X','1,').replace('0','0,').split(',')[:-1]\n    mask_add = mask.replace('1','1,').replace('X','0').replace('0','0,').split(',')[:-1]\n\n    return mask_product, mask_add\n\ndef dec_to_bin(n):\n    num_bin = bin(n)[2:]\n    num_bin = ''.join(['0' for zero in range(digits-len(num_bin))]) + num_bin\n    return num_bin\n\ndef mask_dec(num_dec, mask):\n    mask_p, mask_s = mask_convert(mask)\n    num_bin = dec_to_bin(num_dec) \n    \n    num_masked = ''.join([str(int(num_bin[i])*int(mask_p[i])+int(mask_s[i])) for i in range(digits)])\n    return int(num_masked,2)\n\n\nmemory = np.zeros(max_mem+1)\nfor i, c in enumerate(command):\n    val = value[i]\n    if c == 'mask':\n        mask = val\n    else:\n        num_mask = mask_dec(val, mask)\n        memory[c] = num_mask\n        \nprint(f'Part 1: Sum of all memory entries is:', int(sum(memory)))","6f996d46":"# Part 2\ndef mask_convert_part2(mask):\n    mask_product = mask.replace('1','R').replace('0','1,').replace('X','0,').replace('R','0,').split(',')[:-1]\n    mask_add = mask.replace('1','1,').replace('X','2,').replace('0','0,').split(',')[:-1]\n    \n    return mask_product, mask_add\n    \ndef apply_mask_to_dec(num_dec, mask):\n    mask_p, mask_s = mask_convert_part2(mask)\n    num_bin = dec_to_bin(num_dec) \n\n    num_masked = ''.join([str(int(num_bin[i])*int(mask_p[i]) + int(mask_s[i])) for i in range(digits)])\n    \n    return num_masked\n    \ndef flip_floating(masks):\n    masks_flipped = []\n    for m in masks:\n        \n        mask0 = m.replace('2','0',1)\n        mask1 = m.replace('2','1',1)\n        masks_flipped.append(mask0)\n        masks_flipped.append(mask1)\n        \n    return masks_flipped\n    \ndigits = len(value[0])\n\nmemory = {}\nfor i, c in enumerate(command):\n    val = value[i]\n    if c == 'mask':\n        mask = val\n    else:\n        mask_mem = [apply_mask_to_dec(c, mask)]\n        for f in range(mask_mem[0].count('2')):\n            mask_mem = flip_floating(mask_mem)\n\n        mem_idx = [int(m,2) for m in mask_mem]\n        for idx in mem_idx:\n            memory[idx] = val\n        \nprint(f'Part 2: Sum of all memory entries is:',sum(memory.values()))\n","e4f7a519":"def assign_val_recent(dct, val, turn):\n    entry = dct.get(val,[])\n    if len(entry) == 0:\n        entry = [turn]\n    else:\n        entry = [entry[-1]]\n        entry.append(turn)\n\n    dct[val] = entry\n    \n    return dct\n\ndef assign_val(dct, val, turn):\n    entry = dct.get(val,[])\n    entry.append(turn)\n    dct[val] = entry\n    \n    return dct\n\ndef run_game(start_numbers, turns):\n    numbers_dict = {}\n    # Create initial start number dict\n    for i, n in enumerate(start_numbers):\n        numbers_dict = assign_val(numbers_dict, n, turn=i+1)\n\n    n_prev = start_numbers[-1]\n\n    # Run game until final turn\n    for i in range(len(start_numbers)+1,turns +1):\n        history = numbers_dict[n_prev]\n        if len(history) == 1:\n            n_new = 0\n            numbers_dict = assign_val(numbers_dict, n_new, turn=i)\n        else:\n            n_new = history[-1] - history[-2]\n            numbers_dict = assign_val(numbers_dict, n_new, turn=i)\n\n        n_prev = n_new\n\n    return n_new\n\n# Part 1\nstart_numbers = [15,12,0,14,3,1]\nturns = 2020\nn_final = run_game(start_numbers, turns)\nprint(f'Part 1: The number spoken at turn {turns} is', n_final)\nt = time_func(\"run_game(start_numbers, turns)\", n=1)\n\n# Part 2\nstart_numbers = [15,12,0,14,3,1]\nturns = 30000000\nn_final = run_game(start_numbers, turns)\nprint(f'Part 2: The number spoken at turn {turns} is', n_final)\nt = time_func(\"run_game(start_numbers, turns)\", n=1)","c518d05d":"with open('..\/input\/input-dec16\/dec16.txt','r') as f:\n    lines = f.read().splitlines()\nlines = np.array(lines)\n\nfield_ranges=[\n    ['class','1-3','5-7'],\n    ['row','6-11','33-44'],\n    ['seat','13-40','45-50']]\n\nyour_ticket = ['7,1,14']\n\nnearby_tickets = ['7,3,47',\n                  '40,4,50',\n                  '55,2,20',\n                  '38,6,12']\n\nsep_my_ticket = np.where(lines =='')[0][0]\nsep_nearby_tickets = np.where(lines =='')[0][1]\nfield_ranges = lines[:sep_my_ticket]\nmy_ticket = lines[sep_my_ticket+2]\nnearby_tickets = lines[sep_nearby_tickets+2:]\n\nfields_ranges_proc = []\nfor fr in field_ranges:\n    entry = re.split(\": | or \", fr)\n    entry[0] = entry[0].replace(' ', '_')\n    fields_ranges_proc.append(entry)\nfield_ranges = fields_ranges_proc\nfield_ranges","50244bc1":"# Part 1\nrange_dct = {}\n\nfor entry in field_ranges:\n    field = entry[0]\n    for fr in range(1,len(entry)):\n        sep = entry[fr].find('-')\n        i_min = int(entry[fr][:sep])\n        i_max = int(entry[fr][sep+1:])\n        \n        for i in range(i_min, i_max+1):\n            num_class = range_dct.get(i,[])\n            num_class.append(field)\n            range_dct[i] = num_class\n\n\nfalse_tickets = []\nfalse_entries = []\nfor i,t in enumerate(nearby_tickets):\n    num = t.split(',')\n    for n in num:\n        n = int(n)\n        if n not in range_dct:\n            false_tickets.append(i)\n            false_entries.append(n)\n            break\nprint(f'Part 1: Sum of all invalid entries on all nearby tickets', sum(false_entries))","c0ee4056":"# Part 2\nfield_names = [i[0] for i in field_ranges]\nn_fields = len(field_names)\n\nvalid_tickets = [nt for i, nt in enumerate(nearby_tickets) if i not in false_tickets]\nn_tickets = len(valid_tickets)\n\n# list of list, with entries containing all field 1 valuesfor all tickets, fields 2 values etc\nvalue_list = []\nfor i in range(0,n_fields):\n    values = []\n    for val in valid_tickets:\n        values.append(int(val.split(',')[i]))\n        \n    value_list.append(values)\n\n# run through each field, with all its given values\npossible_fields = []\nfor f in range(n_fields):\n    # list of possible fields for a given number value\n    entry_possible_fields = []\n    pf_dct = {}\n    for v in value_list[f]:\n        for e in range_dct[v]:\n            pf_dct[e] = pf_dct.get(e,0) + 1\n    # only retains fields which are possible for all field values\n    possible_fields.append([field for field in pf_dct if pf_dct[field] == n_tickets])\n    \n# order possibilities, such that the field with only 1 is first, then the field with only 2 etc\nidx_sorted = np.argsort([len(pf) for pf in possible_fields])\n\n# Assign fields by goind through field posibilities in sorted order\nassigned_field = []\nassigned_idx = []\nfor i in idx_sorted:\n    # filter out fields already assigned\n    rem_field = [f for f in possible_fields[i] if f not in assigned_field][0]\n    \n    assigned_idx.append(i)\n    assigned_field.append(rem_field)\n\n# select departure-type fields from my ticket\nkey = 'departure'\nkey_entries = []\nmy_ticket_lst = my_ticket.split(',')\nfor i, f in zip(assigned_idx, assigned_field):\n    if key in f:\n        key_entries.append(int(my_ticket_lst[i]))\n\nprint(f'Part 2: Product of ticket entries starting with {key} is',np.prod(key_entries))","0544a246":"# December 5","25f0da1e":"# December 11","b3c14620":"# December 1","434bb212":"# December 7","8af7e89e":"# December 16","259cbf09":"# December 15","fc356a26":"# December 3","ae667e7a":"# December 13","90bb7c75":"# December 2\n","71413c0a":"# December 9","f7ce36b0":"# December 4","8dd95f2d":"# December 6","f9d59d9c":"# December 10","566c44b9":"# December 8","f05287ff":"# December 14","8b3efc21":"# December 12"}}