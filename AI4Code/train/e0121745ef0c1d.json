{"cell_type":{"644f1e35":"code","5ac72c23":"code","1b9cc3eb":"code","2d66ca58":"code","bae7e111":"code","863a4bc6":"code","f613582b":"code","0a8d7463":"code","c5849b2e":"code","891c7f4c":"code","562dd8dc":"markdown","80f1b836":"markdown"},"source":{"644f1e35":"# importing the necessary libraries\nimport cv2\nimport os\nimport operator\nimport tensorflow\nimport numpy as np\nfrom sklearn.metrics import f1_score \nfrom matplotlib import pyplot as plt\nfrom tensorflow.keras.layers import Dense\nfrom tensorflow.keras.layers import Dropout\nfrom tensorflow.keras.layers import Flatten\nfrom tensorflow.keras.models import Sequential\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras.layers import Conv2D, MaxPooling2D","5ac72c23":"# function for solving sudoku using backtracking and printing the solved sudoku\nboard = [\n    [7,8,0,4,0,0,1,2,0],\n    [6,0,0,0,7,5,0,0,9],\n    [0,0,0,6,0,1,0,7,8],\n    [0,0,7,0,4,0,2,6,0],\n    [0,0,1,0,5,0,9,3,0],\n    [9,0,4,0,6,0,0,0,5],\n    [0,7,0,3,0,0,0,1,2],\n    [1,2,0,0,0,7,4,0,0],\n    [0,4,9,2,0,6,0,0,7]\n]\n\ndef find_empty(bo):\n    for i in range(len(bo)):\n        for j in range(len(bo[0])):\n            if bo[i][j] == 0:\n                return (i, j)  # row, col\n\n    return None\n\ndef print_board(bo):\n    for i in range(len(bo)):\n        if i % 3 == 0 and i != 0:\n            print(\"- - - - - - - - - - - - - \")\n\n        for j in range(len(bo[0])):\n            if j % 3 == 0 and j != 0:\n                print(\" | \", end=\"\")\n\n            if j == 8:\n                print(bo[i][j])\n            else:\n                print(str(bo[i][j]) + \" \", end=\"\")\n\ndef valid(bo, num, pos):\n    # Check row\n    for i in range(len(bo[0])):\n        if bo[pos[0]][i] == num and pos[1] != i:\n            return False\n\n    # Check column\n    for i in range(len(bo)):\n        if bo[i][pos[1]] == num and pos[0] != i:\n            return False\n\n    # Check box\n    box_x = pos[1] \/\/ 3\n    box_y = pos[0] \/\/ 3\n\n    for i in range(box_y*3, box_y*3 + 3):\n        for j in range(box_x * 3, box_x*3 + 3):\n            if bo[i][j] == num and (i,j) != pos:\n                return False\n\n    return True\n\ndef solve(bo):\n    find = find_empty(bo)\n    if not find:\n        return True\n    else:\n        row, col = find\n\n    for i in range(1,10):\n        if valid(bo, i, (row, col)):\n            bo[row][col] = i\n\n            if solve(bo):\n                return True\n\n            bo[row][col] = 0\n\n    return False\n\nprint_board(board)\nsolve(board)\nprint(\"\\n_________________________\\n\")\nprint_board(board)","1b9cc3eb":"# functions for image processing\ndef plot_many_images(images, titles='', rows=9, columns=9):\n    \"\"\"Plots each image in a given list as a grid structure. using Matplotlib.\"\"\"\n    plt.title('Extracted elements from sudoku')\n    for i, image in enumerate(images):\n        plt.subplot(rows, columns, i+1)\n        plt.imshow(image, 'gray')\n        plt.xticks([]), plt.yticks([])  # Hide tick marks\n    plt.axis('off')\n    plt.show()\n\n\ndef show_image(img, title='', flag=0):\n    if flag!=0:\n        return True\n    \"\"\"Shows an image until any key is pressed\"\"\"\n    plt.imshow(img, cmap='gray')\n    plt.title(title)\n    plt.axis('off')\n    plt.show()\n\n\ndef pre_process_image(img, skip_dilate=False, flag=0):\n    \"\"\"Uses a blurring function, adaptive thresholding and dilation to expose the main features of an image.\"\"\"\n\n    # Gaussian blur with a kernal size (height, width) of 9.\n    # Note that kernal sizes must be positive and odd and the kernel must be square.\n    proc = cv2.GaussianBlur(img.copy(), (9, 9), 0)\n\n    # Adaptive threshold using 11 nearest neighbour pixels\n    proc = cv2.adaptiveThreshold(proc, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)\n\n    # Invert colours, so gridlines have non-zero pixel values.\n    # Necessary to dilate the image, otherwise will look like erosion instead.\n    proc = cv2.bitwise_not(proc, proc)\n\n    if not skip_dilate:\n        # Dilate the image to increase the size of the grid lines.\n        kernel = np.array([[0., 1., 0.], [1., 1., 1.], [0., 1., 0.]], np.uint8)\n        proc = cv2.dilate(proc, kernel)\n\n    show_image(proc, 'pre-processed above image to binary for contour detection', flag)\n    return proc\n\n\ndef find_corners_of_largest_polygon(img):\n    \"\"\"Finds the 4 extreme corners of the largest contour in the image.\"\"\"\n    contours, h = cv2.findContours(img.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)  # Find contours\n    contours = sorted(contours, key=cv2.contourArea, reverse=True)  # Sort by area, descending\n    polygon = contours[0]  # Largest image\n\n    # Use of `operator.itemgetter` with `max` and `min` allows us to get the index of the point\n    # Each point is an array of 1 coordinate, hence the [0] getter, then [0] or [1] used to get x and y respectively.\n\n    # Bottom-right point has the largest (x + y) value\n    # Top-left has point smallest (x + y) value\n    # Bottom-left point has smallest (x - y) value\n    # Top-right point has largest (x - y) value\n    bottom_right, _ = max(enumerate([pt[0][0] + pt[0][1] for pt in polygon]), key=operator.itemgetter(1))\n    top_left, _ = min(enumerate([pt[0][0] + pt[0][1] for pt in polygon]), key=operator.itemgetter(1))\n    bottom_left, _ = min(enumerate([pt[0][0] - pt[0][1] for pt in polygon]), key=operator.itemgetter(1))\n    top_right, _ = max(enumerate([pt[0][0] - pt[0][1] for pt in polygon]), key=operator.itemgetter(1))\n\n    # Return an array of all 4 points using the indices\n    # Each point is in its own array of one coordinate\n    return [polygon[top_left][0], polygon[top_right][0], polygon[bottom_right][0], polygon[bottom_left][0]]\n\n\ndef distance_between(p1, p2):\n    \"\"\"Returns the scalar distance between two points\"\"\"\n    a = p2[0] - p1[0]\n    b = p2[1] - p1[1]\n    return np.sqrt((a ** 2) + (b ** 2))\n\n\ndef crop_and_warp(img, crop_rect, flag=0):\n    \"\"\"Crops and warps a rectangular section from an image into a square of similar size.\"\"\"\n\n    # Rectangle described by top left, top right, bottom right and bottom left points\n    top_left, top_right, bottom_right, bottom_left = crop_rect[0], crop_rect[1], crop_rect[2], crop_rect[3]\n\n    # Explicitly set the data type to float32 or `getPerspectiveTransform` will throw an error\n    src = np.array([top_left, top_right, bottom_right, bottom_left], dtype='float32')\n\n    # Get the longest side in the rectangle\n    side = max([\n        distance_between(bottom_right, top_right),\n        distance_between(top_left, bottom_left),\n        distance_between(bottom_right, bottom_left),\n        distance_between(top_left, top_right)\n        ])\n\n    # Describe a square with side of the calculated length, this is the new perspective we want to warp to\n    dst = np.array([[0, 0], [side - 1, 0], [side - 1, side - 1], [0, side - 1]], dtype='float32')\n\n    # Gets the transformation matrix for skewing the image to fit a square by comparing the 4 before and after points\n    m = cv2.getPerspectiveTransform(src, dst)\n\n    # Performs the transformation on the original image\n    warp = cv2.warpPerspective(img, m, (int(side), int(side)))\n    show_image(warp, 'extracted and warped sudoku from the above image', flag)\n    \n    return warp\n\n\ndef infer_grid(img):\n    \"\"\"Infers 81 cell grid from a square image.\"\"\"\n    squares = []\n    side = img.shape[:1]\n    side = side[0] \/ 9\n\n    # Note that we swap j and i here so the rectangles are stored in the list reading left-right instead of top-down.\n    for j in range(9):\n        for i in range(9):\n            p1 = (i * side, j * side)  # Top left corner of a bounding box\n            p2 = ((i + 1) * side, (j + 1) * side)  # Bottom right corner of bounding box\n            squares.append((p1, p2))\n    return squares\n\n\ndef cut_from_rect(img, rect):\n    \"\"\"Cuts a rectangle from an image using the top left and bottom right points.\"\"\"\n    return img[int(rect[0][1]):int(rect[1][1]), int(rect[0][0]):int(rect[1][0])]\n\n\ndef scale_and_centre(img, size, margin=0, background=0):\n    \"\"\"Scales and centres an image onto a new background square.\"\"\"\n    h, w = img.shape[:2]\n\n    def centre_pad(length):\n        \"\"\"Handles centering for a given length that may be odd or even.\"\"\"\n        if length % 2 == 0:\n            side1 = int((size - length) \/ 2)\n            side2 = side1\n        else:\n            side1 = int((size - length) \/ 2)\n            side2 = side1 + 1\n        return side1, side2\n\n    def scale(r, x):\n        return int(r * x)\n\n    if h > w:\n        t_pad = int(margin \/ 2)\n        b_pad = t_pad\n        ratio = (size - margin) \/ h\n        w, h = scale(ratio, w), scale(ratio, h)\n        l_pad, r_pad = centre_pad(w)\n    else:\n        l_pad = int(margin \/ 2)\n        r_pad = l_pad\n        ratio = (size - margin) \/ w\n        w, h = scale(ratio, w), scale(ratio, h)\n        t_pad, b_pad = centre_pad(h)\n\n    img = cv2.resize(img, (w, h))\n    img = cv2.copyMakeBorder(img, t_pad, b_pad, l_pad, r_pad, cv2.BORDER_CONSTANT, None, background)\n    return cv2.resize(img, (size, size))\n\n\ndef find_largest_feature(inp_img, scan_tl=None, scan_br=None):\n    \"\"\"\n    Uses the fact the `floodFill` function returns a bounding box of the area it filled to find the biggest\n    connected pixel structure in the image. Fills this structure in white, reducing the rest to black.\n    \"\"\"\n    img = inp_img.copy()  # Copy the image, leaving the original untouched\n    height, width = img.shape[:2]\n\n    max_area = 0\n    seed_point = (None, None)\n\n    if scan_tl is None:\n        scan_tl = [0, 0]\n\n    if scan_br is None:\n        scan_br = [width, height]\n\n    # Loop through the image\n    for x in range(scan_tl[0], scan_br[0]):\n        for y in range(scan_tl[1], scan_br[1]):\n            # Only operate on light or white squares\n            if img.item(y, x) == 255 and x < width and y < height:  # Note that .item() appears to take input as y, x\n                area = cv2.floodFill(img, None, (x, y), 64)\n                if area[0] > max_area:  # Gets the maximum bound area which should be the grid\n                    max_area = area[0]\n                    seed_point = (x, y)\n\n    # Colour everything grey (compensates for features outside of our middle scanning range\n    for x in range(width):\n        for y in range(height):\n            if img.item(y, x) == 255 and x < width and y < height:\n                cv2.floodFill(img, None, (x, y), 64)\n\n    mask = np.zeros((height + 2, width + 2), np.uint8)  # Mask that is 2 pixels bigger than the image\n\n    # Highlight the main feature\n    if all([p is not None for p in seed_point]):\n        cv2.floodFill(img, mask, seed_point, 255)\n\n    top, bottom, left, right = height, 0, width, 0\n\n    for x in range(width):\n        for y in range(height):\n            if img.item(y, x) == 64:  # Hide anything that isn't the main feature\n                cv2.floodFill(img, mask, (x, y), 0)\n\n            # Find the bounding parameters\n            if img.item(y, x) == 255:\n                top = y if y < top else top\n                bottom = y if y > bottom else bottom\n                left = x if x < left else left\n                right = x if x > right else right\n\n    bbox = [[left, top], [right, bottom]]\n    return img, np.array(bbox, dtype='float32'), seed_point\n\n\ndef extract_digit(img, rect, size):\n    \"\"\"Extracts a digit (if one exists) from a Sudoku square.\"\"\"\n\n    digit = cut_from_rect(img, rect)  # Get the digit box from the whole square\n\n    # Use fill feature finding to get the largest feature in middle of the box\n    # Margin used to define an area in the middle we would expect to find a pixel belonging to the digit\n    h, w = digit.shape[:2]\n    margin = int(np.mean([h, w]) \/ 2.5)\n    _, bbox, seed = find_largest_feature(digit, [margin, margin], [w - margin, h - margin])\n    digit = cut_from_rect(digit, bbox)\n\n    # Scale and pad the digit so that it fits a square of the digit size we're using for machine learning\n    w = bbox[1][0] - bbox[0][0]\n    h = bbox[1][1] - bbox[0][1]\n\n    # Ignore any small bounding boxes\n    if w > 0 and h > 0 and (w * h) > 100 and len(digit) > 0:\n        return scale_and_centre(digit, size, 4)\n    else:\n        return np.zeros((size, size), np.uint8)\n\n\ndef get_digits(img, squares, size, flag=0):\n    \"\"\"Extracts digits from their cells and builds an array\"\"\"\n    digits = []\n    img = pre_process_image(img.copy(), skip_dilate=True, flag=flag)\n    ii = img.copy()\n    ii = cv2.cvtColor(ii, cv2.COLOR_GRAY2BGR)\n    for square in squares:\n        digits.append(extract_digit(img, square, size))\n        a,b = (int(square[0][0]),int(square[0][1])), (int(square[1][0]),int(square[1][1]))\n        cv2.rectangle(ii, a, b, (0,255,0), 3)\n    show_image(ii, 'grid lines marked in green (digits to extract will be in between)', flag)\n    return digits\n\n\ndef parse_grid(path, flag=0):\n    original = cv2.imread(path, cv2.IMREAD_GRAYSCALE)\n    \n    rgb_img = cv2.cvtColor(original.copy(), cv2.COLOR_BGR2RGB)\n    show_image(original, 'original image', flag)\n\n    processed = pre_process_image(original, flag=flag)\n    corners = find_corners_of_largest_polygon(processed)\n    cv2.line(rgb_img, tuple(corners[0]), tuple(corners[1]), (255,0,0), 3)\n    cv2.line(rgb_img, tuple(corners[1]), tuple(corners[2]), (255,0,0), 3)\n    cv2.line(rgb_img, tuple(corners[2]), tuple(corners[3]), (255,0,0), 3)\n    cv2.line(rgb_img, tuple(corners[3]), tuple(corners[0]), (255,0,0), 3)\n    show_image(rgb_img, 'sudoku to extract', flag)\n    \n    cropped = crop_and_warp(original, corners, flag)\n    squares = infer_grid(cropped)\n    digits = get_digits(cropped, squares, 28, flag=flag)\n    warp_img = cv2.cvtColor(cropped.copy(), cv2.COLOR_BGR2RGB)\n    for a,b in squares:\n        x,y = int(a[0]), int(a[1])\n        w,z = int(b[0]), int(b[1])\n        cv2.circle(warp_img, (x,y), 7, (220,0,30), -1)\n        cv2.circle(warp_img, (w,z), 7, (220,0,30), -1)\n    show_image(warp_img, 'intersection of the green lines marked in red dot', flag)\n    return digits\n\npath = '..\/input\/ai-sudoku-solver-data\/'\ndigits = parse_grid(path+'sudoku.jpg', flag=0)\nplot_many_images(digits)","2d66ca58":"# creating the model\ndef create_model():\n    model = Sequential()\n    model.add(Conv2D(32, (16,16), input_shape=(28, 28, 1), activation='relu'))\n    model.add(Conv2D(8, (8,8), activation='relu'))\n    model.add(MaxPooling2D(pool_size=(2, 2)))\n    model.add(Dropout(0.5))\n    model.add(Flatten())\n    model.add(Dense(128, activation='relu'))\n    model.add(Dense(units=11, activation='softmax'))\n    return model","bae7e111":"# Gathering the data for training the model\ndef get_data():\n    data = pd.read_csv('..\/input\/ai-sudoku-solver-data\/image_data.csv')\n    X = []\n    Y = data['y']\n    del data['y']\n    for i in range(data.shape[0]):\n        flat_pixels = data.iloc[i].values[1:]\n        image = np.reshape(flat_pixels, (28,28))\n        X.append(image)\n\n    X = np.array(X)\n    Y = np.array(Y)\n\n    # split the data into training (50%) and testing (50%)\n    (X_train, X_test, Y_train, Y_test) = train_test_split(X, Y, test_size=0.1, random_state=22)\n\n    #reshaping data\n    X_train = X_train.reshape(-1,28,28,1)\n    X_test  = X_test.reshape(-1,28,28,1)\n    return X_train, X_test","863a4bc6":"# Getting predictions from the trained model\ndef predict_digits(model, digits):\n    dic = {}\n    char = \"1234567890\"\n    for i,c in enumerate(char):\n        dic[i+1] = c\n    sudoku = []\n    row = []\n    for i,dig in enumerate(digits):\n        img = dig.reshape(-1,28,28,1)\n        pred = model.predict_classes(img)[0]\n        character = dic[pred]\n        row.append(int(character))\n        if((i+1)%9==0):\n            sudoku.append(row)\n            row = []\n    return np.array(sudoku)","f613582b":"# Metrics for checking the model performance while training\ndef f1score(y, y_pred):\n  return f1_score(y, tf.math.argmax(y_pred, axis=1), average='micro') \n\ndef custom_f1score(y, y_pred):\n  return tf.py_function(f1score, (y, y_pred), tf.double)\n\ndef train_model(model):\n    X_train, X_test = get_data()\n    model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy', custom_f1score])\n    model.fit(X_train, Y_train, validation_data=(X_test, Y_test), epochs=35, batch_size=16, verbose=2)\n    return model","0a8d7463":"# main function takes the sudoku image file path as input\ndef main(path):\n    digits = parse_grid(path, flag=1)\n    model = create_model()\n    if 'model.h5' in os.listdir('..\/input\/ai-sudoku-solver-data'):\n        model.load_weights('..\/input\/ai-sudoku-solver-data\/model.h5')\n    else:\n        model = train_model(model)\n        \n    sudoku = predict_digits(model, digits)\n    solve(sudoku)\n    print('solved output:\\n')\n    print_board(sudoku)","c5849b2e":"img = cv2.imread(path+'sudoku.jpg')\nplt.imshow(img, cmap='gray')\nplt.axis('off')\nplt.title('input image')\nplt.show()","891c7f4c":"main(path+'sudoku.jpg')","562dd8dc":"## In this tutorial, I will show how to code your own sudoku solver using deep learning and some image processing.","80f1b836":"### Find the detailed explanation of the project in this blog: https:\/\/medium.com\/swlh\/how-to-solve-sudoku-using-artificial-intelligence-8d5d3841b872?source=friends_link&sk=c9055ce222a4ed4e6ea060a0f8bcfab2"}}