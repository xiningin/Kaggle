{"cell_type":{"ea8a9067":"code","5db8984f":"code","4e87a888":"code","63d768f0":"code","fa9ed158":"code","31e6d3f7":"code","06982df8":"code","0c2aabdd":"code","62004d0f":"code","2a9e3ec8":"code","f04fad0e":"code","66573e5a":"code","6c9996a1":"code","9f1f030b":"code","e9d83040":"code","6a14e87f":"code","c2eba0b8":"code","a249e04f":"code","33c79e15":"code","b97a2f1d":"markdown","30963eed":"markdown","819d2501":"markdown","7a69f808":"markdown","a425a63a":"markdown","3ff18c20":"markdown","623e39fe":"markdown","5e476cea":"markdown","d2eeb68c":"markdown"},"source":{"ea8a9067":"import os\n#for dirname, _, filenames in os.walk('\/kaggle\/input'):\n   # for filename in filenames:\n    #    print(os.path.join(dirname, filename))\n","5db8984f":"from __future__ import print_function, division\n\nimport torch\nimport torch.nn as nn #for creating and training the neural network\nimport torch.optim as optim #implement various optimization algorithms\nfrom torch.optim import lr_scheduler\nimport numpy as np\nimport torchvision\nfrom torchvision import datasets, models, transforms\nimport matplotlib.pyplot as plt\nimport time\nimport copy\n\nplt.ion()   # interactive mode","4e87a888":"# Data augmentation and normalization for training\n# Just normalization for validation\ndata_transforms = {\n    'train': transforms.Compose([\n        transforms.RandomResizedCrop(224),\n        transforms.RandomHorizontalFlip(),\n        transforms.ToTensor(),\n        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n    ]),\n    'val': transforms.Compose([\n        transforms.Resize(256),\n        transforms.CenterCrop(224),\n        transforms.ToTensor(),\n        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])\n    ]),\n}\n\ndata_dir = '..\/input\/hymenoptera-data\/hymenoptera_data'\nimage_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),\n                                          data_transforms[x])\n                  for x in ['train', 'val']}\ndataloaders = {x: torch.utils.data.DataLoader(image_datasets[x], batch_size=4,\n                                             shuffle=True, num_workers=4)\n              for x in ['train', 'val']}\ndataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'val']}\nclass_names = image_datasets['train'].classes\n\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")","63d768f0":"dataset_sizes","fa9ed158":"dataloaders","31e6d3f7":"dataloaders['train']","06982df8":"len(dataloaders['train'])","0c2aabdd":"print(device)","62004d0f":"x, y = image_datasets['train'][4]\nx.shape\n","2a9e3ec8":"plt.imshow(x.numpy().transpose((1, 2, 0)))","f04fad0e":"def imshow(inp, title=None): #Imshow for Tensor\n    inp = inp.numpy().transpose((1, 2, 0))\n    mean = np.array([0.485, 0.456, 0.406])\n    std = np.array([0.229, 0.224, 0.225])\n    inp = std * inp + mean\n    inp = np.clip(inp, 0, 1)\n    plt.imshow(inp)\n    if title is not None:\n        plt.title(title)\n    plt.pause(0.001) #pause a bit so that plots are updated\n    \n\n#Get batch of training data\ninputs, classes = next(iter(dataloaders['train']))\n\n#Make a grid from scratch\nout = torchvision.utils.make_grid(inputs)\n\nimshow(out, title=[class_names[x] for x in classes])\n","66573e5a":"def train_model(model, criterion, optimizer, scheduler, num_epochs=25):\n    since = time.time()\n\n    best_model_wts = copy.deepcopy(model.state_dict())\n    best_acc = 0.0\n\n    for epoch in range(num_epochs):\n        print('Epoch {}\/{}'.format(epoch, num_epochs - 1))\n        print('-' * 10)\n\n        # Each epoch has a training and validation phase\n        for phase in ['train', 'val']:\n            if phase == 'train':\n                model.train()  # Set model to training mode\n            else:\n                model.eval()   # Set model to evaluate mode\n\n            running_loss = 0.0\n            running_corrects = 0\n\n            # Iterate over data.\n            for inputs, labels in dataloaders[phase]:\n                inputs = inputs.to(device)\n                labels = labels.to(device)\n\n                # zero the parameter gradients\n                optimizer.zero_grad()\n\n                # forward\n                # track history if only in train\n                with torch.set_grad_enabled(phase == 'train'):\n                    outputs = model(inputs)\n                    _, preds = torch.max(outputs, 1)\n                    loss = criterion(outputs, labels)\n\n                    # backward + optimize only if in training phase\n                    if phase == 'train':\n                        loss.backward()\n                        optimizer.step()\n\n                # statistics\n                running_loss += loss.item() * inputs.size(0)\n                running_corrects += torch.sum(preds == labels.data)\n            if phase == 'train':\n                scheduler.step()\n\n            epoch_loss = running_loss \/ dataset_sizes[phase]\n            epoch_acc = running_corrects.double() \/ dataset_sizes[phase]\n\n            print('{} Loss: {:.4f} Acc: {:.4f}'.format(\n                phase, epoch_loss, epoch_acc))\n\n            # deep copy the model\n            if phase == 'val' and epoch_acc > best_acc:\n                best_acc = epoch_acc\n                best_model_wts = copy.deepcopy(model.state_dict())\n\n        print()\n\n    time_elapsed = time.time() - since\n    print('Training complete in {:.0f}m {:.0f}s'.format(\n        time_elapsed \/\/ 60, time_elapsed % 60))\n    print('Best val Acc: {:4f}'.format(best_acc))\n\n    # load best model weights\n    model.load_state_dict(best_model_wts)\n    return model","6c9996a1":"def visualize_model(model, num_images=6):\n    was_training = model.training\n    model.eval()\n    images_so_far = 0\n    fig = plt.figure()\n\n    with torch.no_grad():\n        for i, (inputs, labels) in enumerate(dataloaders['val']):\n            inputs = inputs.to(device)\n            labels = labels.to(device)\n\n            outputs = model(inputs)\n            _, preds = torch.max(outputs, 1)\n\n            for j in range(inputs.size()[0]):\n                images_so_far += 1\n                ax = plt.subplot(num_images\/\/2, 2, images_so_far)\n                ax.axis('off')\n                ax.set_title('predicted: {}'.format(class_names[preds[j]]))\n                imshow(inputs.cpu().data[j])\n\n                if images_so_far == num_images:\n                    model.train(mode=was_training)\n                    return\n        model.train(mode=was_training)","9f1f030b":"model_ft = models.resnet18(pretrained=True)\nnum_ftrs = model_ft.fc.in_features\n# Here the size of each output sample is set to 2.\n# Alternatively, it can be generalized to nn.Linear(num_ftrs, len(class_names)).\nmodel_ft.fc = nn.Linear(num_ftrs, 2)\n\nmodel_ft = model_ft.to(device)\n\ncriterion = nn.CrossEntropyLoss()\n\n# Observe that all parameters are being optimized\noptimizer_ft = optim.SGD(model_ft.parameters(), lr=0.001, momentum=0.9)\n\n# Decay LR by a factor of 0.1 every 7 epochs\nexp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=7, gamma=0.1)","e9d83040":"model_ft = train_model(model_ft, criterion, optimizer_ft, exp_lr_scheduler,\n                       num_epochs=25)","6a14e87f":"visualize_model(model_ft)","c2eba0b8":"model_conv = torchvision.models.resnet18(pretrained=True)\nfor param in model_conv.parameters():\n    param.requires_grad = False\n\n# Parameters of newly constructed modules have requires_grad=True by default\nnum_ftrs = model_conv.fc.in_features\nmodel_conv.fc = nn.Linear(num_ftrs, 2)\n\nmodel_conv = model_conv.to(device)\n\ncriterion = nn.CrossEntropyLoss()\n\n# Observe that only parameters of final layer are being optimized as\n# opposed to before.\noptimizer_conv = optim.SGD(model_conv.fc.parameters(), lr=0.001, momentum=0.9)\n\n# Decay LR by a factor of 0.1 every 7 epochs\nexp_lr_scheduler = lr_scheduler.StepLR(optimizer_conv, step_size=7, gamma=0.1)","a249e04f":"model_conv = train_model(model_conv, criterion, optimizer_conv,\n                         exp_lr_scheduler, num_epochs=25)","33c79e15":"visualize_model(model_conv)\n\nplt.ioff()\nplt.show()","b97a2f1d":"# Visualising images\nWe will visualize a few images so as to understand the data augmentations","30963eed":"# Training the model\n\nNow, let\u2019s write a general function to train a model. Here, we will illustrate:\n\n* Scheduling the learning rate\n* Saving the best model\n\nIn the following, parameter scheduler is an LR scheduler object from torch.optim.lr_scheduler.","819d2501":"Finetuning the convnet\n\nLoad a pretrained model and reset final fully connected layer.","7a69f808":"Train and evaluate\n\nIt should take around 15-25 min on CPU. On GPU though, it takes less than a minute.","a425a63a":"ConvNet as fixed feature extractor\n\nHere, we need to freeze all the network except the final layer. We need to set requires_grad == False to freeze the parameters so that the gradients are not computed in backward().","3ff18c20":"Train and evaluate\n\nOn CPU this will take about half the time compared to previous scenario. This is expected as gradients don\u2019t need to be computed for most of the network. However, forward does need to be computed.","623e39fe":"Visualizing the model predictions\n\nGeneric function to display predictions for a few images","5e476cea":"# Load Data\n\nWe will use torchvision and torch.utils.data packages for loading the data.\n\nThe problem we\u2019re going to solve today is to train a model to classify ants and bees. We have about 120 training images each for ants and bees. There are 75 validation images for each class. Usually, this is a very small dataset to generalize upon, if trained from scratch. Since we are using transfer learning, we should be able to generalize reasonably well.\n\nThis dataset is a very small subset of imagenet.","d2eeb68c":"We will learn how to train a convolutional network for image classification using transfer learning. In practice, very few people train an entire Convolutional Network from scratch (with random initialization), because it is relatively rare to have a dataset of sufficient size. Instead, it is common to pretrain a ConvNet on a very large dataset and then use the ConvNet either as an initialization or a fixed feature extractor for the task of interest.\n\n\nThese two major transfer learning scenarios look as follows:\n\n1. **Finetuning the convnet:** Instead of random initializaion, we initialize the network with a pretrained network. Rest of the training looks as usual.\n2. **ConvNet as fixed feature extractor:** Here, we will freeze the weights for all of the network except that of the final fully connected layer. This last fully connected layer is replaced with a new one with random weights and only this layer is trained.\n"}}