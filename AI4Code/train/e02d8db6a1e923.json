{"cell_type":{"99b8d744":"code","505d818a":"code","291d7eb2":"code","acb7d408":"code","f9bc3e49":"code","de07e5fd":"code","225fdb2c":"code","9241da8a":"code","24025de7":"code","5969e01e":"code","26f2e723":"code","78cebe2d":"code","1a91b246":"code","5ae945e3":"code","dd5d698d":"code","b711cec0":"code","3f4ccd13":"markdown","497d1609":"markdown","6c2e6d7d":"markdown","5d6a439f":"markdown","28edd438":"markdown","fe1ae71f":"markdown","d219cb11":"markdown","03139db9":"markdown","de8c9960":"markdown","b47fa7ec":"markdown","8c59a3c9":"markdown","9870fb36":"markdown","97a8c912":"markdown","78dbcb72":"markdown","e021b200":"markdown","3cea06ef":"markdown","f012c2e4":"markdown","6280b6e8":"markdown","69ecdae9":"markdown","bfc0652a":"markdown","8c7ec786":"markdown","872f7f07":"markdown","5cf013ce":"markdown","0fab51ff":"markdown","cdbe4ee7":"markdown","78a742af":"markdown","fd26dda4":"markdown","191ddfc3":"markdown","97e53f01":"markdown","e2912a0f":"markdown","7a9cf624":"markdown","cef639f8":"markdown","28c6049c":"markdown","bdf7ad82":"markdown","effc6b75":"markdown","c694f9ba":"markdown","44ed9504":"markdown"},"source":{"99b8d744":"import re\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.metrics import confusion_matrix\n\nimport nltk\nfrom nltk.tokenize import RegexpTokenizer\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","505d818a":"train = pd.read_csv(\"..\/input\/60k-stack-overflow-questions-with-quality-rate\/train.csv\")\nvalid = pd.read_csv(\"..\/input\/60k-stack-overflow-questions-with-quality-rate\/valid.csv\")\ntrain.head()","291d7eb2":"# change column names to lower:\ntrain.columns = train.columns.str.lower()\n\n# remove <p> from Body apply to train DataFrame \ntrain.body = train.body.str.replace('<p>','')\n# count words by splitting the string by space\nnum_words_in_body = pd.Series([len(row.split(' ')) for row in train.body])\n# add the count to train dataFrame\ntrain[\"num_words_in_body\"] = num_words_in_body\n#show the data\ntrain[\"num_words_in_body\"].head()","acb7d408":"# count words by splitting the string by space\nnum_words_in_title = pd.Series([len(row.split(' ')) for row in train.title])\n# add the count to train dataFrame\ntrain[\"num_words_in_title\"] = num_words_in_title\ntrain[\"num_words_in_title\"].head()","f9bc3e49":"# extract words from tags\nnum_of_tags = pd.Series([len(re.findall('<(\\w+)>', row)) for row in train.tags])\n# add the count to train DataFrame\ntrain[\"num_of_tags\"] = num_of_tags\ntrain[\"num_of_tags\"].head()","de07e5fd":"# get a list of tags from the dataFrame Tags column\ntags_list = []\nfor row in train.tags:\n    #print(row)\n    for tag in re.findall('<(.*?)>', row):   # if this is python-2.7 or python-3.x in the tag, it will be counted as different tags\n        tags_list.append(tag)\n        #print(tag)\n        \n# store unique tags into a tags_set\ntags_set = set(tags_list)\n\n# use the nltk package to count the frequency of each tag\ntags_freqD = nltk.FreqDist(tags_list)\n\n# sort the dictionary by the count, in descending order\nsorted_tagsD = sorted(tags_freqD.items(), key=lambda item:item[1], reverse=True)\n\n'''\n# evaluate the result, use \"python\" to test out\nfor k,v in sorted_tagsD:\n    if \"c\" in k:    \n        print(k, v)'''\nprint()","225fdb2c":"# top10_tags are the most used tags in the dataset\ntop10_tags = [tag[0] for tag in sorted_tagsD[:10]]\ntop10_tags","9241da8a":"# extract year from CreationDate\nCreationYear = pd.Series([date[:4] for date in train.creationdate])\n# add CreationYear to train DataFrame\ntrain[\"creation_year\"] = CreationYear\ntrain[\"creation_year\"].head()","24025de7":"train.tags = train.tags.str.replace('<|>',' ')\n#train.Tags = train.tags.str.replace('>',' ') # used | - or operator\ntrain.tags.head()\n","5969e01e":"train.head()","26f2e723":"labels = train.y.unique()\ntrain.groupby('y').size()\nplt.bar(labels, train.groupby('y').size())\nplt.xlabel(\"Quality Labels\")\nplt.ylabel(\"Total questions in Train dataset\")","78cebe2d":"years = train.creation_year.unique()\nplt.bar(years, train.groupby('creation_year').size())\nplt.xlabel(\"Year\")\nplt.ylabel(\"Total questions in year\")","1a91b246":"years  # unique years in dataset\nlabels # unique labels in dataset\nyear_label_df = pd.DataFrame(columns=labels, index=years, data= [[sum((train.y == label)&(train.creation_year== year)) for label in labels] for year in years ])\nprint(year_label_df)\nyear_label_df.plot.barh()","5ae945e3":"tags_freqD.plot(10)\n### i think we should use bar plot here","dd5d698d":"labels     # unique labels in dataset\ntop10_tags # top 10 tags used in the dataset\n# train[train['Tags'].str.contains('\\\\b(c)\\\\b', regex=True)].Tags\n\n\ntag_label_df = pd.DataFrame(columns=labels, index=top10_tags, data= [[sum((train.y == label)&(train['tags'].str.contains(tag, regex=True))) for label in labels] for tag in top10_tags ])\nprint(tag_label_df)\ntag_label_df.plot.bar()","b711cec0":"sns.pairplot(data=train, y_vars=[\"y\"], x_vars=[\"num_words_in_title\", \"num_words_in_body\", \"num_of_tags\", \"creation_year\"])","3f4ccd13":"d.\tStemming words","497d1609":"# CIS09 Intro to Data Science Final Project","6c2e6d7d":"# 4. Data Visualization ","5d6a439f":"from the bar chart above, we can see the train data is well balanced with equal amount of each qaulity questions in the dataset","28edd438":"# **1. Project Description**","fe1ae71f":"c.\tna\u00efve_bayes: GaussianNB","d219cb11":"b.\tRemoves stop words","03139db9":"a.\tTokenize the words (combine tag and text )","de8c9960":"# 7. Models Evaluation and Final Conclusion","b47fa7ec":"# 6. Build NLP Model","8c59a3c9":"# 5. Build Classification Models With Features","9870fb36":"b.\tGet number of words in title","97a8c912":"f. replace <> from Tags columns with space","78dbcb72":"c.\tPlot frequency of top 10 used tags in Stack Overflow","e021b200":"b.\tKNN classifier","3cea06ef":"a.\tWhich model is better for the prediction? Why do we think it performs better than the other one?","f012c2e4":"c.\tGet number of tags per question","6280b6e8":"f.\tUse multinomialNB to create model","69ecdae9":"e.\tExtract year of the question","bfc0652a":"g. print the layout of train dataFrame after preprosessing","8c7ec786":"d.Plot number of HQ, LQ posts for top 10 tags","872f7f07":"# 3. Preprocessing data and generate additional features ","5cf013ce":"As shown above, there are less questions comparing to previous years. \nIt would be interesting to check out the qaulity of questions among each year in the train dataset","0fab51ff":"c.\tRoom of improvement?","cdbe4ee7":"e.\tTransform words into document vector by CountVectorizer","78a742af":"c.\tGet frequency distribution and find out: * (may have to limit to certain years due to capacity) \n    - What are the commonly used words in high rating posts?\n    - What are the commonly used words in low rating posts? ","fd26dda4":"a.\tDecisionTreeClassifier","191ddfc3":"a.\tVisualize data by \u201cy\u201d, the question quality label, verify if data is balanced between each quality category","97e53f01":"e.\tPlot correlation between features and quality label\n    -\tlength of title vs quality\n    -\tlength of body text vs quality\n    -\tnumber of tags vs quality\n    -\tyear vs quality","e2912a0f":"b.\tPlot total questions per year (Plot total questions by label by year? )","7a9cf624":"b.\tWhat are the common characteristics of \u201cgood\u201d questions?","cef639f8":"*Name: Maria Gorbunova, Yueqi Wang *","28c6049c":"d.\tExtract tags for coding language associated with the question","bdf7ad82":"a.\tGet number of words in body","effc6b75":"# 2. Import main packages and data","c694f9ba":"Learn from 60,000 questions collected at Stack Overflow from 2016 to 2020, create models to label the quality of questions into three categories. \n\n    1.\tHQ: High-quality posts with a total of 30+ score and without a single edit.\n    2.\tLQ_EDIT: Low-quality posts with a negative score, and multiple community edits. However, they still remain open after those changes.\n    3.\tLQ_CLOSE: Low-quality posts that were closed by the community without a single edit.\n\nStudy the characteristics of good questions on Stack Overflow and pick the features that have the strongest correlation with the categories. Train several models to predict the category of the post. Choose the best model.\n","44ed9504":"- There are fewer HQ (high quality) questions as the total quesion number goes down\n- Meanwhile, the decrease of LQ (low qaulity) questions are not dropping as dramatically as the HQ questions. "}}