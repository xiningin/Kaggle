{"cell_type":{"3499a090":"code","60a8450f":"code","2e68bf1f":"code","0ac3de87":"code","ae49fd26":"code","f067a79f":"code","2a63ac70":"code","3f7a6ce6":"code","c3f29e6a":"code","54e5e2bb":"markdown","46e00a69":"markdown","d0413b54":"markdown","4e09e592":"markdown","7a037b7b":"markdown","c2eb5850":"markdown","8ca4613d":"markdown","582fbc6c":"markdown","b721429d":"markdown","5c4f79fd":"markdown","5a65da46":"markdown"},"source":{"3499a090":"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nplt.style.use('seaborn-whitegrid')\nMETA = \"..\/input\/meta-kaggle\/\"","60a8450f":"%%time\n# most of this time is taken by kaggle attaching the dataset\nepisodes_df = pd.DataFrame()\nfor i, chunk in enumerate(pd.read_csv(META + \"Episodes.csv\", usecols=['Id','CompetitionId'], chunksize=1e4)):\n    if i>260: episodes_df = pd.concat([episodes_df,chunk], ignore_index=True)\nepisodes_df[\"CompetitionId\"] = episodes_df[\"CompetitionId\"].astype(\"category\")\nepisodes_df = episodes_df[episodes_df.CompetitionId == 30067]\n\nepisodes_df.info(verbose=False, memory_usage=\"deep\")","2e68bf1f":"%%time\nepagents_df = pd.DataFrame()\nfor i, chunk in enumerate(pd.read_csv(META + \"EpisodeAgents.csv\", usecols=['EpisodeId','Reward','SubmissionId','InitialScore','UpdatedScore'], chunksize=1e6)):\n    if i>66: epagents_df = pd.concat([epagents_df,chunk], ignore_index=True)\n        \nepagents_df = epagents_df[epagents_df.EpisodeId.isin(episodes_df.Id)]\nepagents_df.fillna(0, inplace=True)\nepagents_df = epagents_df.sort_values(by=['EpisodeId'], ascending=True)\n\nepagents_df.info(verbose=False, memory_usage=\"deep\")","0ac3de87":"def getStats(SUB_ID):\n\n    scores = epagents_df[epagents_df['SubmissionId']==SUB_ID].UpdatedScore.tolist()\n    \n    scores_delta = np.diff(scores)\n    \n    eps = sorted(epagents_df[epagents_df['SubmissionId']==SUB_ID]['EpisodeId'].values)[2:]\n    us = epagents_df[(epagents_df['EpisodeId'].isin(eps)) & (epagents_df['SubmissionId']==SUB_ID)].sort_values('EpisodeId').Reward.values\n    them = epagents_df[(epagents_df['EpisodeId'].isin(eps)) & (epagents_df['SubmissionId']!=SUB_ID)].sort_values('EpisodeId').Reward.values\n    outcomes = []\n    for u,t in zip(us,them):\n        if u>t: outcomes.append(1)\n        if u<t: outcomes.append(0)\n        if u==t: \n            outcomes.append(0.5)\n            print(u,t)\n\n    return np.array(scores), np.array(outcomes), np.array(scores_delta)\n","ae49fd26":"SUB_ID = 23032370\nscores, outcomes, scores_delta = getStats(SUB_ID)","f067a79f":"plt.figure(figsize=(15, 8))\nplt.plot(scores, label='scores')\nplt.hlines(np.mean(scores), 0, len(scores), color='tab:orange', label=f'mean score {np.mean(scores):.2f}')\nplt.hlines(np.median(scores), 0, len(scores), color='tab:olive', label=f'median score {np.median(scores):.0f}')\n\nplt.scatter(np.argmax(scores), np.max(scores), color='tab:green', label=f'top score {np.max(scores)}')\nplt.legend()\nplt.show()","2a63ac70":"plt.figure(figsize=(15, 8))\nplt.plot(scores_delta)\n\nplt.scatter(np.argwhere(scores_delta > 0), scores_delta[scores_delta > 0], c='tab:green', label='Positive')\nplt.scatter(np.argwhere(scores_delta < 0), scores_delta[scores_delta < 0], c='tab:red', label='Negative')\n\nplt.hlines(0, 0, len(scores_delta), color='black', linestyles='--')\nplt.title('score delta')\nplt.legend()\nplt.show()","3f7a6ce6":"plt.figure(figsize=(15, 8))\nplt.plot(outcomes, c='lightgray', linestyle='--')\n\nplt.scatter(np.argwhere(outcomes == 1), outcomes[outcomes == 1], c='tab:green', label='Win')\nplt.scatter(np.argwhere(outcomes == 0), outcomes[outcomes == 0], c='tab:red', label='Loss')\nplt.scatter(np.argwhere(outcomes == 0.5), outcomes[outcomes == 0.5], c='tab:blue', label='Tie')\n\nplt.hlines(np.mean(outcomes), 0, len(outcomes), color='tab:orange', label='win rate')\nplt.legend()\nplt.title(f'win rate = {np.mean(outcomes):.3f}')\nplt.show()","c3f29e6a":"plt.figure(figsize=(15, 8))\n\nplt.plot(range(1, len(outcomes)+1), [sum(outcomes[:n])\/n for n in range(1, len(outcomes)+1)], label='win rate')\nplt.hlines(np.mean(outcomes), 1, len(outcomes), color='tab:orange', label='current win rate')\nplt.title('win rate change')\nplt.legend()\nplt.show()","54e5e2bb":"The rest of the notebook is 100% the same as @yalikesifulei's notebook plots.","46e00a69":"`SUB_ID` is the number in the end of link in form https:\/\/www.kaggle.com\/c\/lux-ai-2021\/leaderboard?dialog=episodes-submission-23032370. It also can be seen from submission's page:\n\n![SUB_ID](https:\/\/i.imgur.com\/vniyMkL.png)","d0413b54":"The meta kaggle data is now loaded. It takes only milliseconds to run charts from this point.","4e09e592":"## Win\/Loss\/Tie plot by match","7a037b7b":"## Load Meta Kaggle datasets","c2eb5850":"The rest of the notebook is 100% the same as @yalikesifulei's notebook plots.","8ca4613d":"## Score growth plot","582fbc6c":"## Score changes (delta) plot","b721429d":"## Setting up","5c4f79fd":"## Win rate change by match","5a65da46":"[@yalikesifulei](https:\/\/www.kaggle.com\/yalikesifulei) made a nice Notebook [\"Bot statistics with Selenium & Beautiful Soup\"](https:\/\/www.kaggle.com\/yalikesifulei\/bot-statistics-with-selenium-beautiful-soup) which shows various plots about Kaggle Simulation submissions. \n\nHe said \"Meta Kaggle dataset is not used because of extremely slow data loading.\" \n\nKaggle datasets don't really attach until you start using them, and Kaggle has a system of caching which means it can take minutes to attach the 16GB compressed dataset. Then a couple of minutes to load the 7GB episode file into pandas.\n\nHowever, in my opinion this is neater than using a web scraper and once loaded, charts per submission are evaluated in milliseconds. So, in case you want to use it, here it is.\n\nNote that if you fork this notebook you will need to re-attach the meta kaggle dataset as it changes daily. Click the **+ Add Data** in the top right and add the Meta Kaggle dataset and you are good to go."}}