{"cell_type":{"8fcd0149":"code","645bf53a":"code","d310604c":"code","2acbabb7":"code","06aa04fd":"code","fa8909ba":"code","b07e6f40":"code","82e257c3":"code","d29fe889":"code","ec2116fc":"code","f701df33":"code","6cf1936d":"code","b288ad39":"code","3a964776":"code","291a1c91":"code","e9858db5":"code","1629b423":"code","3a2aac11":"code","ce023a65":"code","bf6baaa4":"code","85a11502":"code","72f9097c":"code","4534baf3":"code","3c19fbf9":"code","825751fc":"code","9096b6b9":"code","7c995c75":"code","b257550d":"code","f9544674":"code","23b10ac8":"code","93bb5b59":"code","bf58e479":"code","a6641a49":"code","2fb36b3d":"code","50347d3b":"code","7321f438":"code","6bef7ec2":"code","8f40926b":"code","854a135e":"code","1a081c09":"code","ccfce513":"markdown","fe6dc8a6":"markdown","f65da1a0":"markdown","bca3f836":"markdown","85f5a82f":"markdown","6fab75ab":"markdown"},"source":{"8fcd0149":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport lightgbm as lgb\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom IPython.display import display, clear_output, FileLinks\n\nfrom sklearn.metrics import roc_auc_score\nfrom catboost import CatBoostClassifier, CatBoostRegressor\n\nimport altair as alt\nfrom altair.vega import v5\nfrom IPython.display import HTML\nfrom sklearn import preprocessing\nfrom tqdm.notebook import tqdm\nimport lightgbm as lgb\nimport numpy as np\nimport pandas as pd\nimport lightgbm as lgb\nimport glob\nimport os\nimport sklearn.datasets\nimport sklearn.metrics\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder \nfrom tqdm.notebook import tqdm\nimport optuna\n\nimport gc, datetime, random\n\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.impute import SimpleImputer\nfrom collections import defaultdict, Counter\n\nfrom sklearn.metrics import mean_squared_error\nfrom math import sqrt\n\nimport scipy.io as sio\nfrom scipy.io import loadmat, savemat\nfrom scipy.stats.stats import pearsonr \nfrom scipy.stats import spearmanr\n\nimport matplotlib\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\n\nimport time\nimport warnings\nfrom sklearn.linear_model import *\n\n\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.pipeline import Pipeline, FeatureUnion\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC, LinearSVC\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import StratifiedKFold, KFold, RepeatedKFold, GroupKFold, GridSearchCV, train_test_split, TimeSeriesSplit\nfrom sklearn.model_selection import StratifiedKFold\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nimport os\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport scipy.io        \nimport plotly.graph_objs as go\nfrom PIL import Image\n\n\n\nfor dirname, _, filenames in os.walk('..\/input\/live-stall-mobile-video-quality-database\/'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","645bf53a":"sub_mat = sio.loadmat('..\/input\/live-stall-mobile-video-quality-database\/LIVEMobileStallStudy2\/LIVEMobileStallStudy2\/liveMobileStall_subjectiveData.mat')\nsub_mat","d310604c":"# 0 : lools like continous score\n# 1 : lools like continous score per sec\n# 2 : final score\n# 3 : final score\n# 4 : each subjects score for each frames\n# 5 :  ","2acbabb7":"xx = sub_mat['liveMobileStall_subjectiveData'][0][0][0][1][0]\n\nprint(len(xx))\nprint(xx.shape)\nfor i in xx:\n    print(i)","06aa04fd":"yy = sub_mat['liveMobileStall_subjectiveData'][0][0][2]\nprint(len(yy))\nfig = plt.figure()\nplt.plot(yy)\ndisplay(fig)","fa8909ba":"vid_mat = sio.loadmat('..\/input\/live-stall-mobile-video-quality-database\/LIVEMobileStallStudy2\/LIVEMobileStallStudy2\/liveMobileStall_videoMetaData.mat')\n# vid_mat","b07e6f40":"# 0 : name\n# 1 : whether video is stlled or not\n# 2 : -1 for non stalled secs of stall ??? 20 ???\n# 3 : -1 for non stalled where secs of stall ??? 1000 ???\n# 4 : stall=100 nostall=0\n# 5 : stall in secs\n# 6 : len in sec - 1 \n# 7 : original\n# 8 : from which origonal video\n# 9 : ","82e257c3":"# vid_mat.keys()\nxx = vid_mat['liveMobileStall_videoMetaData'][0][0][4][1][0]\n\nprint(len(xx))\nprint(xx.shape)\nfor i in xx:\n    print(i)","d29fe889":"yy = vid_mat['liveMobileStall_videoMetaData'][0][0][5][0][0][0]\nprint(len(yy))\nfig = plt.figure()\nplt.plot(yy)\ndisplay(fig)","ec2116fc":"from keras.models import Sequential\nfrom keras.layers import Dense, LSTM\nfrom keras.preprocessing.sequence import TimeseriesGenerator\nfrom keras.regularizers import l2\n","f701df33":"def add_rebuffer(array, is_rebuffered_bool):\n    if len(array) == 1:\n        array = array[0]\n    if len(is_rebuffered_bool) == 1:\n        is_rebuffered_bool = is_rebuffered_bool[0]\n        \n    if len(is_rebuffered_bool) == len(array):\n        return np.array(array).reshape(-1, 1)[20:]\n    \n    new_array = np.array(is_rebuffered_bool)*-1\n    j=0\n    for i in range(len(new_array)):\n        new_array[i] = array[j]\n        if is_rebuffered_bool[i]==0:\n            j+=1\n    return np.array(new_array).reshape(-1, 1)[20:]","6cf1936d":"using_features = [4, 'frame intreval', 'frame no']\n\nn_input = 4\nn_feature = len(using_features)","b288ad39":"def model_init(f=0):\n    model = Sequential()\n    model.add(LSTM(256,activation = 'relu', input_shape= (n_input, n_feature), return_sequences=True, kernel_regularizer=l2(0.01*5), bias_regularizer=l2(0.01*5)))\n    model.add(LSTM(128, activation='relu', return_sequences=True, kernel_regularizer=l2(0.01*5), bias_regularizer=l2(0.01*5)))\n    model.add(LSTM(64, activation='relu', return_sequences=False, kernel_regularizer=l2(0.01*5), bias_regularizer=l2(0.01*5)))\n    model.add(Dense(1, kernel_regularizer=l2(0.01), bias_regularizer=l2(0.01)))\n    model.compile(optimizer='adam', loss='mse')\n    if f:\n        print(model.summary())\n    return model","3a964776":"# scaled_train","291a1c91":"\nfor i in range(len(vid_mat['liveMobileStall_videoMetaData'][0][0][4])):\n    \n    stack = vid_mat['liveMobileStall_videoMetaData'][0][0][4][i][0].reshape(-1, 1)\n    \n    intervals = np.array(range(len(stack))) \/\/ 200\n    \n    stack = np.hstack((stack, ))","e9858db5":"np.unique(np.array(range(len(stack))) \/\/ 200)","1629b423":"def get_labels(i):\n    cc = np.array(pd.Series(sub_mat['liveMobileStall_subjectiveData'][0][0][4][i][0][0]).replace(np.nan, 0))\n    labels = np.array([0.0] * len(cc))\n    count = 0\n    for j in range(27):\n        cc = np.array(pd.Series(sub_mat['liveMobileStall_subjectiveData'][0][0][4][i][j][0]).replace(np.nan, 0))\n        if np.sum(cc) == 0:\n            continue\n        count+=1\n        labels += cc\n    labels \/= count\n    return labels.reshape(-1, 1)\n\nget_labels(i)","3a2aac11":"train_datas = []\nvalid_datas = []\n\ntrain_datas_y = []\nvalid_datas_y = []\n\nfor i in range(len(vid_mat['liveMobileStall_videoMetaData'][0][0][4])):\n    \n    stack = vid_mat['liveMobileStall_videoMetaData'][0][0][4][i][0].reshape(-1, 1)\n    intervals = (np.array(range(len(stack))) \/\/ 20).reshape(-1, 1)\n    stack = np.hstack((stack, intervals))\n    stack = np.hstack((stack, np.array(range(len(stack))).reshape(-1, 1)))\n\n#     labels = sub_mat['liveMobileStall_subjectiveData'][0][0][0][i][0].reshape(-1, 1)\n    labels = get_labels(i)\n\n    \n#     # not a good normalisib but still\n#     for j in range(stack.shape[1]):\n#         if stack[:, j].std() != 0:\n#             stack[:, j]  = (stack[:, j] -  stack[:, j].mean()) \/  stack[:, j].std()\n\n    if labels.std() != 0:\n        labels  = 100*(labels -  labels.mean()) \/  labels.std()\n    \n    \n    \n    stack = stack[20:, :]\n    labels = labels[20:]\n    \n    stack = stack[1:, :]\n    labels = labels[:-1]\n\n    n_feature = stack.shape[1]\n    train, valid = stack[: int(0.80*len(stack)), :],  stack[int(0.80*len(stack)) - n_input:, :]\n    scaled_train, scaled_valid = labels[: int(0.80*len(stack))],  labels[int(0.80*len(stack)) - n_input:]\n\n    train_generator = TimeseriesGenerator(train,scaled_train,length=n_input, batch_size=1)\n    valid_generator = TimeseriesGenerator(valid,scaled_valid,length=n_input, batch_size=1)    \n    train_datas.append(train)\n    valid_datas.append(valid)\n    \n    train_datas_y.append(scaled_train)\n    valid_datas_y.append(scaled_valid)\n    \n    if i==2:\n        break","ce023a65":"# model = model_init(1)","bf6baaa4":"# model.fit_generator(train_generator,epochs=50, validation_data=valid_generator)","85a11502":"# tr_loss= model.history.history['loss']\n# val_loss= model.history.history['val_loss']\n\n# fig = plt.figure(figsize=(20,10));display(fig)\n# plt.plot(tr_loss, 'b')\n# plt.plot(val_loss, 'r')\n\n# display(fig)","72f9097c":"# atcual_train = scaled_train[:]\n# plt_x_train = range(len(atcual_train))\n# pred_train = model.predict(train_generator)\n# plt_x_train_p = n_input+np.array(range(len(pred_train)))\n\n\n# atcual_valid = scaled_valid[:]\n# pred_valid = model.predict(valid_generator)\n# plt_x_valid = np.array(range(len(atcual_train), len(atcual_train)+len(atcual_valid)))-n_input\n# plt_x_valid_p = n_input+np.array(range(len(atcual_train), len(atcual_train)+len(pred_valid)))-n_input\n\n\n# fig2 = plt.figure(figsize=(20,10));\n# plt.plot(plt_x_valid, atcual_valid, 'g')\n# plt.plot(plt_x_train_p, pred_train, 'b')\n# plt.plot(plt_x_train, atcual_train, 'g')\n# plt.plot(plt_x_valid_p, pred_valid, 'r')\n\n\n# display(fig2)","4534baf3":"def get_df(train_generator):\n    count=0\n    for i in train_generator:\n        count+=1\n    df = pd.DataFrame(index=range(count))\n\n    feats = []\n    labels = []\n    for seq in tqdm(train_generator):\n        feat_1 = []\n        for row in seq[0][0]:\n            for elem in row:\n                feat_1.append(elem)\n\n        feats.append(feat_1)\n        labels.append(seq[1][0][0])\n\n    df = pd.DataFrame(feats)\n    df['labels'] = labels\n    return df","3c19fbf9":"train, valid = get_df(train_generator), get_df(valid_generator)\nX_train, y_train = train.drop('labels', axis=1), train['labels']\nX_validation, y_validation = valid.drop('labels', axis=1), valid['labels']\n\n\ndata_generator = TimeseriesGenerator(stack,labels,length=n_input, batch_size=1)\ndata = get_df(data_generator)\nX_train, X_validation, y_train, y_validation = train_test_split(data.drop('labels', axis=1), data['labels'], train_size=0.800)\nX_train = X_train.sort_index()\nX_validation = X_validation.sort_index()\n\n\ny_train = y_train.sort_index()\ny_validation = y_validation.sort_index()\n","825751fc":"cat_cols = []\ncat_cols = X_train.columns","9096b6b9":"range_cols = []\nfor i in range(len(X_train.columns)\/\/3):\n    range_cols.append(3*i+2)\n    \ninterval_cols = []\nfor i in range(len(X_train.columns)\/\/3):\n    interval_cols.append(3*i+1)\n    \ncat_cols = []\nfor i in range(len(X_train.columns)\/\/3):\n    cat_cols.append(3*i)\ncat_cols\n","7c995c75":"params = {'learning_rate': 0.01024129583699132,\n 'l2_leaf_reg': 0.00019980149774000808,\n 'max_depth': 4,\n 'iterations': 1854,\n 'bagging_temperature': 0.01914241266114443,\n 'max_ctr_complexity': 2,\n 'max_bin': 35}","b257550d":"# FYI: Objective functions can take additional arguments\n# (https:\/\/optuna.readthedocs.io\/en\/stable\/faq.html#objective-func-additional-args).\ndef objective(trial):\n    param = {\n        \"eval_metric\": \"RMSE\",\n        'logging_level': 'Silent',\n        'boosting_type' : 'Plain' ,\n        \"learning_rate\": trial.suggest_float(\"learning_rate\", 1e-2, 0.5, log=True),\n        \"l2_leaf_reg\": trial.suggest_float(\"l2_leaf_reg\", 1e-8, 500.0, log=True),\n        \"max_depth\": trial.suggest_int(\"max_depth\", 2, 12, log=False),\n#         'task_type':\"GPU\",       \n        \"iterations\": trial.suggest_int(\"iterations\", 50, 5000),\n        \"bagging_temperature\": trial.suggest_float(\"bagging_temperature\", 1e-2, 0.5, log=True),\n        \"max_ctr_complexity\": trial.suggest_int(\"max_ctr_complexity\", 2, 2),\n        \"max_bin\": trial.suggest_int(\"max_bin\", 32, 200),\n        \"use_best_model\" : False,\n    }\n    \n    \n    model = CatBoostRegressor(**param)\n    model = model.fit(\n                        X_train, y_train, \n                        cat_features=cat_cols,\n                        use_best_model=False,\n#                         eval_set=(X_validation, y_validation),\n                     )\n    preds = model.predict(X_validation)\n    accuracy = sklearn.metrics.mean_squared_error(y_validation, preds, squared=False)\n    return accuracy","f9544674":"study = optuna.create_study(direction=\"minimize\")\n# study = optuna.create_study(direction=\"maximize\")\nstudy.optimize(objective, n_trials=5)\nprint(\"Number of finished trials: {}\".format(len(study.trials)))\ntrial = study.best_trial\nprint(\"Best trial:\")\n# paramss.append(trial.params)\nprint(\"  Value: {}\".format(trial.value))\nprint(\"  Params: \")\nfor key, value in trial.params.items():\n    print(\"    {}: {}\".format(key, value))\nparams = trial.params\ntrial.params","23b10ac8":"params['eval_metric'] = 'RMSE'\nparams['logging_level'] = 'Silent'\nparams['boosting_type'] = 'Plain'","93bb5b59":"# model_range = CatBoostRegressor(**params)\n# model_range.fit(\n#         X_train, y_train, \n#         cat_features=cat_cols,\n#         use_best_model=False,\n# #         eval_set=(X_validation, y_validation),\n#      )\n# model_range.get_params()","bf58e479":"model = CatBoostRegressor(**params)\nmodel.fit(\n        X_train, y_train, \n        cat_features=cat_cols,\n        use_best_model=False,\n#         eval_set=(X_validation, y_validation),\n     )\nmodel.get_params()","a6641a49":"# model = LinearRegression()\n# model.fit(\n#         X_train, y_train, \n# #         cat_features=cat_cols,\n# #         use_best_model=False,\n# #         eval_set=(X_validation, y_validation),\n#      )\n# model.get_params()","2fb36b3d":"X_train.head()","50347d3b":"atcual_train = y_train[:]\npred_train = model.predict(X_train)\n\n\natcual_valid = y_validation[:]\npred_valid = model.predict(X_validation)\n\nplt_x_train = range(len(atcual_train))\nplt_x_train_p = n_input+np.array(range(len(pred_train)))\nplt_x_valid = np.array(range(len(atcual_train), len(atcual_train)+len(atcual_valid)))-n_input\nplt_x_valid_p = n_input+np.array(range(len(atcual_train), len(atcual_train)+len(pred_valid)))-n_input\n\n\nplt_x_train = np.array(X_train.index)\nplt_x_train_p = np.array(X_train.index)\nplt_x_valid = np.array(X_validation.index)\nplt_x_valid_p = np.array(X_validation.index)\n\n\nfig2 = plt.figure(figsize=(20,10));\nplt.plot(plt_x_valid, atcual_valid, 'g')\nplt.plot(plt_x_train_p, pred_train, 'b')\nplt.plot(plt_x_train, atcual_train, 'g')\nplt.plot(plt_x_valid_p, pred_valid, 'r')\nplt.xlabel('frame')\nplt.ylabel('qoe')\nplt.legend([\"atcual_valid\", \"pred_train\", \"atcual_train\", \"pred_valid\"], loc =\"upper right\") \n\n\ndisplay(fig2)","7321f438":"atcual_train = y_train[:]\npred_train = model.predict(X_train)\n\n\natcual_valid = y_validation[:]\npred_valid = model.predict(X_validation)\n\nplt_x_train = range(len(atcual_train))\nplt_x_train_p = n_input+np.array(range(len(pred_train)))\nplt_x_valid = np.array(range(len(atcual_train), len(atcual_train)+len(atcual_valid)))-n_input\nplt_x_valid_p = n_input+np.array(range(len(atcual_train), len(atcual_train)+len(pred_valid)))-n_input\n\n\n# plt_x_train = np.array(X_train.index)\n# plt_x_train_p = np.array(X_train.index)\n# plt_x_valid = np.array(X_validation.index)\n# plt_x_valid_p = np.array(X_validation.index)\n\n\nfig2 = plt.figure(figsize=(20,10));\nplt.plot(plt_x_valid, atcual_valid, 'g')\nplt.plot(plt_x_train_p, pred_train, 'b')\nplt.plot(plt_x_train, atcual_train, 'g')\nplt.plot(plt_x_valid_p, pred_valid, 'r')\nplt.xlabel('frame')\nplt.ylabel('qoe')\nplt.legend([\"atcual_valid\", \"pred_train\", \"atcual_train\", \"pred_valid\"], loc =\"upper right\") \n\n\ndisplay(fig2)","6bef7ec2":"sklearn.metrics.mean_absolute_error(atcual_valid, pred_valid)","8f40926b":"sklearn.metrics.mean_squared_error(atcual_valid, pred_valid, squared=False)","854a135e":"from scipy import stats\nstats.spearmanr(atcual_valid,pred_valid)[0]\nstats.pearsonr(atcual_valid,pred_valid)[0]","1a081c09":"stats.pearsonr(atcual_valid,pred_valid)[0]","ccfce513":"# Metrics","fe6dc8a6":"RMSE","f65da1a0":"# **Prediction**","bca3f836":"Lables have benn normalised to have mean = 0 ,and std=100","85f5a82f":"# LSTM","6fab75ab":"# DataFrame based ML"}}