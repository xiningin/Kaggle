{"cell_type":{"3af21dac":"code","c3c0fa81":"code","c4b09876":"code","dac8da1e":"code","7d1418d4":"code","0c74a5d8":"code","eb838c81":"code","95850ef9":"markdown","964aaf8f":"markdown","c039f626":"markdown","e5ce1d4f":"markdown","f07f81d4":"markdown"},"source":{"3af21dac":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n","c3c0fa81":"%%time\n\ndtypes = {\n    \"row_id\":\"int64\",\n    \"timestamp\":\"int64\",\n    \"user_id\":\"int32\",\n    \"content_id\":\"int16\",\n    \"content_type_id\":\"int16\",\n    \"task_container_id\":\"int16\",\n    \"user_answer\":\"int8\",\n    \"answered_correctly\":\"int8\",\n    \"prior_question_elapsed_time\":\"float32\",\n    \"prior_question_had_explanation\":\"str\"\n}\n\ndata = pd.read_csv(\"\/kaggle\/input\/riiid-test-answer-prediction\/train.csv\", dtype=dtypes)","c4b09876":"sample_user = int(data.sample(1, random_state=42)[\"user_id\"])\n\n%time data.loc[data.user_id == sample_user]","dac8da1e":"%time user_indexes = data.groupby(\"user_id\")[\"row_id\"].agg([\"min\", \"max\"]).reset_index()","7d1418d4":"from tqdm import tqdm\n\ntotal_dict = {}\nfor user in tqdm(range(len(user_indexes))):\n    user_df = data.iloc[user_indexes.iloc[user, 1]:user_indexes.iloc[user, 2], :]\n    total_dict[f'data_{user_indexes.iloc[user, 0]}'] = user_df","0c74a5d8":"%timeit data.iloc[5834946:5835038,:]","eb838c81":"%timeit total_dict[f'data_{sample_user}']","95850ef9":"Now, we see that using iloc is really fast. But it might get confusing to update index values. Instead, as we see the code above, I created a dictionary that contains of every user's dataframe with keys of user id. Now, retrieving and updating should be easier.","964aaf8f":"So then, retrieving with dictionary keys may be even faster than .iloc and it is easy to update (you may want to append new rows etc.)","c039f626":"But, using .iloc absolutely so much faster. In order to establish my implement I will firstly use .iloc","e5ce1d4f":"**When the data is huge; it takes so much time to retrieve all the records for a user. Libraries such as datatable makes it faster or if you know all the index values (which is difficult).**\n\n**But I will show another approach so that we can update a user's record.**","f07f81d4":"Let's check in how much time it consumes to retrieve a user's df with .loc"}}