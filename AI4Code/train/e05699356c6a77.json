{"cell_type":{"80219761":"code","7ad9c8e0":"code","25447e34":"code","eb64b2c2":"code","7c47ef65":"code","ef26506a":"code","a55ad761":"code","545cffeb":"code","39431f2d":"code","3b0a6cfd":"code","89b2e195":"code","7e823ce2":"code","188aff8e":"code","fc2e55dd":"code","00bd4ce6":"code","3a5223a3":"code","e8499c60":"code","a8e1083b":"code","9c41fee9":"code","f18d6891":"code","9d0322f5":"code","e4ecccfb":"code","c2a0ce67":"code","77a0a87c":"code","7a1dd4ea":"code","c007bb66":"code","128780c7":"code","da969d5e":"code","39289b74":"code","bdff4845":"code","051c1d37":"code","6c98e6dc":"code","693428cc":"code","b706b920":"code","000da5b0":"code","ac5518ac":"code","ab57e115":"code","22a5956e":"code","45485eff":"code","24afe28c":"code","4b5bd54f":"code","cb293fc2":"code","6f5ce5f3":"code","029d0d68":"code","d35d89fd":"code","2cdc22a5":"code","2d104e34":"code","abf9f83d":"code","5018def0":"code","a6295b07":"code","6ffa1213":"code","1714ee50":"code","66345c95":"code","3a45468d":"code","617d5f31":"code","df8d8d3e":"code","1bec02e6":"code","cb52dddc":"code","48211825":"code","1f0a344e":"code","ffffe06a":"code","0c8e03f2":"code","b6ade857":"code","12b350fb":"code","da43ad15":"code","a6844bf7":"code","d34918a3":"code","62bd365c":"code","0c577cff":"code","9ddb0895":"code","07f6f842":"markdown","64d96415":"markdown","d98f9c48":"markdown","dd1db2c9":"markdown","fe9ba752":"markdown","d8b5e4fc":"markdown","f287de8b":"markdown","4f47f2ac":"markdown","5d759ed0":"markdown","6e82c80b":"markdown","df0ec44a":"markdown","5f772181":"markdown","e1284a88":"markdown","ca160526":"markdown","5a21143e":"markdown","4dccdff2":"markdown","7cba4659":"markdown","d7bee1f4":"markdown","953fbd92":"markdown","4e99b643":"markdown","d8d0a43f":"markdown","6b322a8e":"markdown","b9e152bc":"markdown","6972603b":"markdown","e6554b8b":"markdown","287df840":"markdown","eed84da6":"markdown","81bb8872":"markdown","e79a9d00":"markdown","e6090f03":"markdown","5332737e":"markdown","b6db78a5":"markdown","21f5fa2e":"markdown","3b2dfe53":"markdown","24e68c56":"markdown","41d19a67":"markdown","caf07f14":"markdown","ebdcd2ad":"markdown","59e0029a":"markdown","8b58ca17":"markdown","8c0215ec":"markdown","64362d86":"markdown","cc706b0b":"markdown","be2d5a1c":"markdown","3bd0afb3":"markdown","0ce11d7a":"markdown","d49ede32":"markdown","8b6ef353":"markdown","4cfde4dc":"markdown","57d93a1b":"markdown","548d8e8c":"markdown","aa837b04":"markdown","257edf70":"markdown","84d151e5":"markdown","7bcecd68":"markdown","825ce236":"markdown","47ce919b":"markdown","166b7332":"markdown","a88baed2":"markdown","e2d1bf7a":"markdown","5c605aa3":"markdown","116371a5":"markdown","fe850c22":"markdown","a60dba64":"markdown","f51613d1":"markdown","4978a3ec":"markdown","c2314027":"markdown","c95b2f53":"markdown","a51cbe21":"markdown","0daba023":"markdown","4e4be876":"markdown","9a736333":"markdown","ee5629aa":"markdown","68a9d880":"markdown","fa53fb0a":"markdown","705fa464":"markdown","e92920c2":"markdown","8488111a":"markdown","0d84f607":"markdown","908c901f":"markdown","bf067b8b":"markdown","2b5d487c":"markdown","8f58c4fe":"markdown","044d6fb8":"markdown","49f89d30":"markdown","e4625387":"markdown","5e35f29c":"markdown","f6ea6efb":"markdown","d0187503":"markdown","fa49e489":"markdown","89b1b993":"markdown","6e362a72":"markdown","2e7c7f50":"markdown","1396def5":"markdown","067b7a5f":"markdown","4a0d083b":"markdown","53c4c247":"markdown","cbe9a6bf":"markdown","16cb5654":"markdown","2c603e57":"markdown","d0f5f63d":"markdown","25deff1f":"markdown","68386481":"markdown","c48d8ce8":"markdown","8e63b9ee":"markdown","34004f20":"markdown"},"source":{"80219761":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","7ad9c8e0":"%matplotlib inline\n!pip install lifetimes\n!pip install jcopml","25447e34":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom lifetimes.utils import summary_data_from_transaction_data\nfrom jcopml.plot import plot_missing_value","eb64b2c2":"df = pd.read_csv(\"\/kaggle\/input\/onlineretail\/OnlineRetail.csv\",error_bad_lines=False, encoding='unicode_escape')\ndf.head()","7c47ef65":"df.dtypes","ef26506a":"plot_missing_value(df, return_df = True)","a55ad761":"df.describe()","545cffeb":"q1_quan = df['Quantity'].quantile(0.25)\nq3_quan = df['Quantity'].quantile(0.75)\niqr_quan = q3_quan - q1_quan\nlb_quan = float(q1_quan) - (1.5 * iqr_quan)\nub_quan = float(q3_quan) + (1.5 * iqr_quan)\n\nprint('Q1 = {}'.format(q1_quan))\nprint('Q3 = {}'.format(q3_quan))\nprint('IQR = Q3 - Q1 = {}'.format(iqr_quan))\nprint('lower bound = Q1 - 1.5 * IQR = {}'.format(lb_quan))\nprint('upper bound = Q3 + 1.5 * IQR = {}'.format(ub_quan))","39431f2d":"q1_unit = df['UnitPrice'].quantile(0.25)\nq3_unit = df['UnitPrice'].quantile(0.75)\niqr_unit = q3_unit - q1_unit \nlb_unit = float(q1_unit) - (1.5 * iqr_unit)\nub_unit = float(q3_unit) + (1.5 * iqr_unit)\n\nprint('Q1 = {}'.format(q1_unit))\nprint('Q3 = {}'.format(q3_unit))\nprint('IQR = Q3 - Q1 = {}'.format(iqr_unit))\nprint('lower bound = Q1 - 1.5 * IQR = {}'.format(lb_unit))\nprint('upper bound = Q1 - 1.5 * IQR = {}'.format(ub_unit))","3b0a6cfd":"sns.scatterplot(df['UnitPrice'], df['Quantity'])\nplt.title('Quantity x UnitPrice', fontsize = 20);","89b2e195":"dx = df[df['Quantity']>0] #hilangkan value negatif\ndy = df[df['UnitPrice']>0] #hilangkan value negatif\n\nfiltered_quantity = dx.query('(@q1_quan - 1.5 * @iqr_quan) <= Quantity <= (@q3_quan + 1.5 * @iqr_quan)')\nfiltered_unitprice = dy.query('(@q1_unit - 1.5 * @iqr_unit) <= UnitPrice <= (@q3_unit + 1.5 * @iqr_unit)')\n\nsns.scatterplot(filtered_unitprice['UnitPrice'], filtered_quantity['Quantity'])\nplt.title('Quantity x UnitPrice', fontsize = 20);","7e823ce2":"q1_quan_custom = df['Quantity'].quantile(0.5)\nq3_quan_custom = df['Quantity'].quantile(0.95)\niqr_quan_custom = q3_quan_custom - q1_quan_custom\n\nq1_unit_custom = df['UnitPrice'].quantile(0.5)\nq3_unit_custom = df['UnitPrice'].quantile(0.95)\niqr_unit_custom = q3_unit_custom - q1_unit_custom\n\ndx = df[df['Quantity']>0] #hilangkan value negatif\ndy = df[df['UnitPrice']>0] #hilangkan value negatif\n\nfiltered_quantity = dx.query('(@q1_quan_custom - 1.5 * @iqr_quan_custom) <= Quantity <= (@q3_quan_custom + 1.5 * @iqr_quan_custom)')\nfiltered_unitprice = dy.query('(@q1_unit_custom - 1.5 * @iqr_unit_custom) <= UnitPrice <= (@q3_unit_custom + 1.5 * @iqr_unit_custom)')\n\nsns.scatterplot(filtered_unitprice['UnitPrice'], filtered_quantity['Quantity'])\nplt.title('Quantity x UnitPrice', fontsize = 20);","188aff8e":"sns.distplot(df['Quantity'])\nplt.title('Distribusi Quantity', fontsize = 20)\nplt.xlabel('Quantity')\nplt.ylabel('count');","fc2e55dd":"sns.distplot(df['UnitPrice'])\nplt.title('Distribusi Unit price', fontsize = 20)\nplt.xlabel('Unit Price')\nplt.ylabel('count');","00bd4ce6":"x = df['Country'].value_counts().head(5)\nsns.barplot(x = x.values, y = x.index, )\nplt.title('5 negara terbesar', fontsize = 20)\nplt.xlabel('Count')\nplt.ylabel('Nama Negara');","3a5223a3":"x = df['Country'].nunique()\nprint(\"Terdapat total {} negara\".format(x))\n\ncountry = pd.DataFrame(df['Country'].value_counts()).reset_index()\ncountry.columns = ['Negara', 'Jumlah Transaksi']\ncountry","e8499c60":"df = df[df['Country'] == 'United Kingdom']\ndf.head()","a8e1083b":"df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])\ndf.head()","9c41fee9":"df = df[~df['CustomerID'].isna()]\ndf.head()","f18d6891":"df = df[df['Quantity']>0]\ndf = df[df['UnitPrice']>0]\ndf.head()","9d0322f5":"df['Revenue'] = df['Quantity'] * df['UnitPrice']\ndf.head()","e4ecccfb":"orders = df.groupby(['InvoiceNo', 'InvoiceDate']).sum().reset_index()\norders.head()","c2a0ce67":"rfm = summary_data_from_transaction_data(orders, 'CustomerID', 'InvoiceDate', monetary_value_col='Revenue').reset_index()\nrfm","77a0a87c":"plt.hist(rfm['frequency'])\nplt.title('Frequency')\nplt.ylabel('Jumlah Customer' )\nplt.xlabel('Frequency');","7a1dd4ea":"rfm = rfm[rfm['frequency']>0]\nrfm.head()","c007bb66":"plt.hist(rfm['frequency'])\nplt.title('Frequency')\nplt.ylabel('Jumlah Customer', )\nplt.xlabel('Frequency');","128780c7":"plt.hist(rfm['monetary_value'])\nplt.title('Monetary Value')\nplt.ylabel('Jumlah Customer', )\nplt.xlabel('Monetary Value');","da969d5e":"rfm = rfm[rfm['monetary_value']<2000]\nrfm.head()","39289b74":"plt.hist(rfm['monetary_value'])\nplt.title('Monetary Value')\nplt.ylabel('Jumlah Customer', )\nplt.xlabel('Monetary Value');","bdff4845":"quartiles = rfm.quantile(q=[0.25, 0.5, 0.75])\nquartiles","051c1d37":"def recency_score (data):\n    if data <= 60:\n        return 1\n    elif data <= 128:\n        return 2\n    elif data <= 221:\n        return 3\n    else:\n        return 4\n\ndef frequency_score (data):\n    if data <= 1:\n        return 1\n    elif data <= 1:\n        return 2\n    elif data <= 2:\n        return 3\n    else:\n        return 4\n\ndef monetary_value_score (data):\n    if data <= 142.935:\n        return 1\n    elif data <= 292.555:\n        return 2\n    elif data <= 412.435:\n        return 3\n    else:\n        return 4\n\nrfm['R'] = rfm['recency'].apply(recency_score )\nrfm['F'] = rfm['frequency'].apply(frequency_score)\nrfm['M'] = rfm['monetary_value'].apply(monetary_value_score)\nrfm.head()","6c98e6dc":"rfm['RFM_score'] = rfm[['R', 'F', 'M']].sum(axis=1)\nrfm.head()","693428cc":"rfm['label'] = 'Bronze' \nrfm.loc[rfm['RFM_score'] > 4, 'label'] = 'Silver' \nrfm.loc[rfm['RFM_score'] > 6, 'label'] = 'Gold'\nrfm.loc[rfm['RFM_score'] > 8, 'label'] = 'Platinum'\nrfm.loc[rfm['RFM_score'] > 10, 'label'] = 'Diamond'\n\nrfm.head()","b706b920":"barplot = dict(rfm['label'].value_counts())\nbar_names = list(barplot.keys())\nbar_values = list(barplot.values())\nplt.bar(bar_names,bar_values)\nprint(pd.DataFrame(barplot, index=[' ']))","000da5b0":"df2 = pd.read_csv(\"\/kaggle\/input\/onlineretail\/OnlineRetail.csv\",error_bad_lines=False, encoding='unicode_escape')\ndf2.head()","ac5518ac":"df2['InvoiceDate'] = pd.to_datetime(df2['InvoiceDate'])\ndf2.head()","ab57e115":"uk = df2[df2['Country'] == 'United Kingdom']\nuk.head()","22a5956e":"main_df = pd.DataFrame(df2['CustomerID'].unique())\nmain_df.columns = ['CustomerID']\nmain_df.head()","45485eff":"latest_purchase = uk.groupby('CustomerID').InvoiceDate.max().reset_index()\nlatest_purchase.columns = ['CustomerID','LatestPurchaseDate']\nlatest_purchase.head()","24afe28c":"latest_purchase['Recency'] = (latest_purchase['LatestPurchaseDate'].max() - latest_purchase['LatestPurchaseDate']).dt.days\nlatest_purchase.head()","4b5bd54f":"main_df = pd.merge(main_df, latest_purchase[['CustomerID','Recency']], on='CustomerID')\nmain_df.head()","cb293fc2":"sns.distplot(main_df['Recency'], kde=False, bins=50)\nplt.title('Distribusi Value Recency', fontsize = 20)\nplt.xlabel('Recency')\nplt.ylabel('count');","6f5ce5f3":"from sklearn.cluster import KMeans","029d0d68":"score = []\nfor k in range(1, 15):\n    kmeans = KMeans(n_clusters=k)\n    member = kmeans.fit_predict(np.array(main_df['Recency']).reshape(-1, 1))\n    score.append(kmeans.inertia_)\n    \nplt.figure(figsize=(10, 5))\nplt.plot(range(1, 15), score)\nplt.ylabel(\"Inertia\")\nplt.xlabel(\"n_clusters\");","d35d89fd":"kmeans = KMeans(n_clusters=4)\nkmeans.fit(main_df[['Recency']])\nmain_df['RecencyCluster'] = kmeans.predict(main_df[['Recency']])\nmain_df.head()","2cdc22a5":"main_df.groupby('RecencyCluster')['Recency'].describe()","2d104e34":"def order_cluster(cluster_field_name, target_field_name,df,ascending):\n    new_cluster_field_name = 'new_' + cluster_field_name\n    df_new = df.groupby(cluster_field_name)[target_field_name].mean().reset_index()\n    df_new = df_new.sort_values(by=target_field_name,ascending=ascending).reset_index(drop=True)\n    df_new['index'] = df_new.index\n    df_final = pd.merge(df,df_new[[cluster_field_name,'index']], on=cluster_field_name)\n    df_final = df_final.drop([cluster_field_name],axis=1)\n    df_final = df_final.rename(columns={\"index\":cluster_field_name})\n    return df_final","abf9f83d":"main_df = order_cluster('RecencyCluster', 'Recency',main_df,False)\nmain_df.head()","5018def0":"main_df.groupby('RecencyCluster')['Recency'].describe()","a6295b07":"frequency = uk.groupby('CustomerID').InvoiceDate.count().reset_index()\nfrequency.columns = ['CustomerID','Frequency']\nfrequency.head()","6ffa1213":"main_df = pd.merge(main_df, frequency, on='CustomerID')\nmain_df.head()","1714ee50":"main_df.Frequency.describe()","66345c95":"sns.distplot(main_df['Frequency'], kde=False, bins=50)\nplt.title('Distribusi Value Frequency', fontsize = 20)\nplt.xlabel('Frequency')\nplt.ylabel('count');","3a45468d":"score = []\nfor k in range(1, 15):\n    kmeans = KMeans(n_clusters=k)\n    member = kmeans.fit_predict(np.array(main_df['Frequency']).reshape(-1, 1))\n    score.append(kmeans.inertia_)\n    \nplt.figure(figsize=(10, 5))\nplt.plot(range(1, 15), score)\nplt.ylabel(\"Inertia\")\nplt.xlabel(\"n_clusters\");","617d5f31":"kmeans = KMeans(n_clusters=4)\nkmeans.fit(main_df[['Frequency']])\nmain_df['FrequencyCluster'] = kmeans.predict(main_df[['Frequency']])\nmain_df.head()","df8d8d3e":"main_df = order_cluster('FrequencyCluster', 'Frequency',main_df,True)\nmain_df.head()","1bec02e6":"main_df.groupby('FrequencyCluster')['Frequency'].describe()","cb52dddc":"uk['Revenue'] = uk['UnitPrice'] * uk['Quantity']\nrevenue = uk.groupby('CustomerID').Revenue.sum().reset_index()\nrevenue.head()","48211825":"main_df = pd.merge(main_df, revenue, on='CustomerID')\nmain_df.head()","1f0a344e":"main_df['Revenue'].describe()","ffffe06a":"sns.distplot(main_df['Revenue'], kde=False, bins=50)\nplt.title('Distribusi Revenue', fontsize = 20)\nplt.xlabel('Revenue')\nplt.ylabel('count');","0c8e03f2":"score = []\nfor k in range(1, 15):\n    kmeans = KMeans(n_clusters=k)\n    member = kmeans.fit_predict(np.array(main_df['Revenue']).reshape(-1, 1))\n    score.append(kmeans.inertia_)\n    \nplt.figure(figsize=(10, 5))\nplt.plot(range(1, 15), score)\nplt.ylabel(\"Inertia\")\nplt.xlabel(\"n_clusters\");","b6ade857":"kmeans = KMeans(n_clusters=4)\nkmeans.fit(main_df[['Revenue']])\nmain_df['RevenueCluster'] = kmeans.predict(main_df[['Revenue']])\nmain_df.head()","12b350fb":"main_df = order_cluster('RevenueCluster', 'Revenue',main_df,True)\nmain_df.head()","da43ad15":"main_df.groupby('RevenueCluster')['Revenue'].describe()","a6844bf7":"main_df['RFM_score'] = main_df['RecencyCluster'] + main_df['FrequencyCluster'] + main_df['RevenueCluster']\nmain_df.head()","d34918a3":"main_df['RFM_score'].unique()","62bd365c":"main_df.groupby('RFM_score')['Recency','Frequency','Revenue'].mean()\nmain_df.head()","0c577cff":"main_df['label'] = 'Bronze' \nmain_df.loc[main_df['RFM_score'] > 1, 'label'] = 'Silver' \nmain_df.loc[main_df['RFM_score'] > 2, 'label'] = 'Gold'\nmain_df.loc[main_df['RFM_score'] > 3, 'label'] = 'Platinum'\nmain_df.loc[main_df['RFM_score'] > 5, 'label'] = 'Diamond'\n\nmain_df.head()","9ddb0895":"barplot = dict(main_df['label'].value_counts())\nbar_names = list(barplot.keys())\nbar_values = list(barplot.values())\nplt.bar(bar_names,bar_values)\nprint(pd.DataFrame(barplot, index=[' ']))","07f6f842":"Ambil waktu pembelian paling akhir (latest purchase) untuk setiap ID","64d96415":"Oke, terlihat keseluruhan customer memiliki monetary value diantara 0 sampai 500. tetapi ada juga customer yang memiliki monetary value sebanyak 2000 keatas, bahkan sampai 16000an.","d98f9c48":"Sangat disayangkan value CustomerID banyak yang hilang, padahal library Lifetimes bergantung pada CustomerID untuk membuat segmentasi RFM. Mau tidak mau nantinya kita akan lakukan drop out terhadap value CustomerID yang bolong. Meskipun nantinya Lifetimes akan melakukannya secara otomatis, namun kita akan melakukannya secara manual.","dd1db2c9":"## Step 2: Hitung Individual RFM Score","fe9ba752":"Dari snapshot diatas, hal pertama yang menarik perhatian saya adalah value min dan max dari Quantity, karena valuenya simetris, min -80995 dan max 80995, ada apa gerangan? kira-kira kejadian apa yang menyebabkan hal ini terjadi?\n\nLalu ada juga UnitPrice dengan value negatif, apakah ini hutang?\n\nKita lanjut identifikasi outliers dan buat scatter plot untuk memahami hubungan antar keduanya","d8b5e4fc":"Berikut adalah langkah-langkah dalam membuat RFM model menggunakan algoritma K means:\n\n- Step 1, Hitung RFM Value, Tentukan Jumlah Cluster, dan Hitung RFM Score.\n- Step 2, Hitung score RFM secara keseluruhan\n- Step 3, Labeling","f287de8b":"### Data Types","4f47f2ac":"Jika sebelumnya kita memanfaatkan library Lifetimes untuk menghitung RFM Value, maka kali ini kita akan menggunakan algoritma machine learning, K means. Algoritma K means ini termasuk kedalam algoritma unsupervised learning, yang artinya kita akan mengolah data yang tak berlabel, dan nanti kita akan melabeli outputnya sesuai dengan analisis kita sendiri.","5d759ed0":"Kondisi detil cluster Frequency","6e82c80b":"Terdapat 4 kolom penting yang dapat kita gunakan untuk membuat segmentasi customer RFM, yaitu:\n\n- Quantity\n- UnitPrice\n- CustomerID\n- InvoiceDate\n\nKita coba lakukan beberapa pengecekkan untuk mengetahui gambaran secara umum kondisi data kita.","df0ec44a":"# Segmentasi Customer Menggunakan K means","5f772181":"Urutkan\n\nBerikut adalah hasil cluster Frequency yang sudah dibuat","e1284a88":"Untuk menghitung RFM Score secara keseluruhan kita cukup menjumlahkan value dari RFM individual score. ","ca160526":"Di step ini Lifetimes akan membuatkan dataframe baru secara otomatis berdasarkan dataframe yang sudah kita persiapkan sebelumnya.\n\noutputnya terdapat kolom frequency, recency, T, dan monetary_value. \n\nUntuk saat ini abaikan saja kolom CustomerID dan T, karena kita tidak akan menggunakannya. Jika kalian penasaran kolom apa T itu, berikut penjelasannya:\n\n- T adalah umur customer dari waktu pembelian pertama sampai akhir periode waktu yang ditentukan. representasi unit waktunya bisa menggunakan jam, hari, minggu, dll, tergantung kebijakan kalian.\n\nlalu apa bedanya dengan recency? kalian bisa membandingkannya dengan penjelasan recency sebagai berikut:\n\n- Recency adalah umur customer ketika mereka melakukan pembelian yang paling terbaru(recent). ini sama dengan durasi pembelian pertama(first purchase) sampai pembelian terbaru (latest purchase). *jika customer hanya melakukan satu kali pembelian, maka recency-nya adalah 0.","5a21143e":"## Quick EDA (Exploratory Data Analysis)","4dccdff2":"## Buat RFM Model","7cba4659":"### 2. Tentukan Jumlah Cluster","d7bee1f4":"Bisa dilihat, customer yang tidak melakukan transaksi ulang jumlahnya sangat mendominasi. Untuk membuat segmen yang lebih masuk akal, kita akan membuang data customer yang tidak melakukan pembelian ulang.","953fbd92":"### Step 1: Hitung RFM Values","4e99b643":"Binning.\n\nDibawah 2 adalah low value\nDiantara 2-4 adalah mid value\nDi","d8d0a43f":"## Step 4: Berikan Label untuk RFM_Score","6b322a8e":"Cek snapshot Frequency","b9e152bc":"# Segmentasi Customer menggunakan library Lifetimes","6972603b":"Berikut detil jumlah negara dan jumlah transaksi yang terjadi ","e6554b8b":"#### Outliers Quantity","287df840":"Halo teman-teman, bagaimana kabar kalian semua? saya harap kalian semua baik-baik saja ya. Kali ini saya ingin mendemonstrasikan cara mensegmentasikan customer (Metode RFM) menggunakan library Lifetimes dan juga K-means. \n\ntapi sebelum masuk ke RFM nya, saya ingin menunjukkan terlebih dahulu tipe-tipe segmentasi yang ada:","eed84da6":"Step 4. Buang value dari kolom 'Quantity' dan 'UnitPrice' yang memiliki value 0 dan negatif.","81bb8872":"Step 3. Buang value dari kolom 'CustomerID' yang datanya bolong.\n\nsebetulnya kita bisa saja melakukan input data kosong tersebut dengan data dummy. tapi kali ini kita akan drop out saja. Step drop out ini akan mengurangi jumlah data lumayan signifikan.","e79a9d00":"Tahapannya sama seperti ketika membuat RFM menggunakan library Lifetimes: \n\n- A. Persiapkan data\n- B. Buat RFM","e6090f03":"cek snapshot (describe) Recency yang sudah kita buat\n\nIngat, cluster dibawah belum diurutkan, kita belum mengetahui kasta clusternya.","5332737e":"### 1. Hitung Frequency Value\n\nUntuk menghitung Frequency, cukup gunakan kolom Frequency yang ada","b6db78a5":"### 2. Tentukan Jumlah Cluster","21f5fa2e":"### Describe Numerical Data","3b2dfe53":"Setelah di plot, sekarang makin terlihat jelas hubungan antar kedua kolom. \n\nData kita memiliki beberapa outliers ekstrim: \n\n- titik kelompok paling atas menggambarkan customer yang membeli banyak barang dengan harga yang tidak terlalu mahal, titik kelompok yang paling bawah adalah customer yang banyak .... mengembalikan barang? apakah ini retur?. Jika dicermati, bentuknya terlihat simetris dengan titik kelompok data yang paling atas. Hmm.. kira-kira apa ya maksudnya? menurut analisa saya, kemungkinan besar itu adalah Reseller, karena jika dilihat dari Quantitynya, tidak mungkin orang secara pribadi membeli barang sebegitu banyaknya. Reseller tersebut kemudian secara rutin mengambil barang dagangan dengan item yang sama, kemudian mengembalikan item yang tidak laku. Namun untuk membuktikan benar tidaknya, lebih baik kita tanyakan kepada Data Analis mengenai arti dari data itu, atau jangan-jangan ada kesalahan input? siapa tau. Dan sayang sekali penyedia data kita tidak menyertakan nomenklatur yang bisa menjelaskan data secara lebih detil.\n\n\n- Untuk titik kelompok yang paling kiri, saya tidak faham artinya apa, apakah itu pribadi yang berhutang. Sekali lagi cara terbaik untuk mengetahui kejelasan data kita adalah dengan menanyakannya kepada Data Analis.\n\n\n- Untuk titik kelompok yang paling kanan, itu adalah customer yang membeli barang dengan harga yang mahal, kemungkinan besar barang itu digunakan untuk diri sendiri karena Quantitynya tidaklah ekstrim. Cukup normal menurut saya, tidak begitu aneh.\n\nSecara umum data kita berisikan customer yang beraneka ragam, ada yang membeli barang dengan rentang harga yang luas namun Quantitynya rendah (kemungkinan besar digunakan untuk pribadi), dan ada juga customer yang membeli dengan Quantity tinggi namun rentang harga yang rendah(kemungkinan adalah Reseller)\n\nTapi saya penasaran bagaimana bentuk scatter plotnya jika tanpa outliers, yuk kita cek dulu. ","24e68c56":"Data sudah siap, sekarang waktunya lakukan segmentasi","41d19a67":"Step 1. Buang negara selain UK.","caf07f14":"### Hubungan antara Quantity dan UnitPrice","ebdcd2ad":"Berikut adalah distribusi monetary value tanpa outliers. *seharusnya kita melakukan investigasi lebih lanjut terhadap outliers, dan tidak membuangnya begitu saja, tapi untuk kali ini, kita buang saja outliersnya.","59e0029a":"### Identifikasi Outliers","8b58ca17":"### Distribusi Quantity dan UnitPrice","8c0215ec":"## B. Hitung RFM Value","64362d86":"#### Outliers UnitPrice","cc706b0b":"## Import Packages dan Data","be2d5a1c":"Secara umum perseberannya terlihat sama saja, namun jika diperhatikan dengan seksama terlihat kalau tingkat kepadatan di titik sebelah kanan atas mulai mengurang, artinya semakin tinggi UnitPrice semakin sedikit tingkat Quantity nya.\n\nNamun plot diatas kurang begitu jelas gambarannya, biar lebih pasti, coba kita plot dengan scope yang lebih jauh.","3bd0afb3":"### 3. Hitung Monetary Score","0ce11d7a":"### 3. Hitung Recency Score","d49ede32":"Score tertinggi yang kita miliki adalah 8 (dari total 9, R=3, F=3, M=3)","8b6ef353":"Plot Distribusi Value Frequency","4cfde4dc":"Sekarang gantian kita cek distribusi monetary_value dengan histogram","57d93a1b":"Untuk mengetahui value recency nya, kita harus mengetahui jumlah hari tidak aktifnya customer (tidak melakukan pembelian) sejak pembelian terakhir. caranya? sebagai berikut:","548d8e8c":"Merge dengan dataframe recency yang tadi sudah dibuat","aa837b04":"Import data","257edf70":"Kita identifikasi outliers menggunakan IQR score, rumusnya adalah:\n- IQR = Q3 - Q1\n- lower bound = Q1 - 1.5 * IQR\n- upper bound = Q3 + 1.5 * IQR ","84d151e5":"Untuk menentukan jumlah clusternya kita akan pakai inertia analysis","7bcecd68":"Berikut adalah cluster yang sudah diurutkan:","825ce236":"Munculkan kolom CustomerID dan Recency\n\nCaranya bebas terserah kalian, kali ini saya akan gunakan merge.","47ce919b":"Berikut adalah gambaran cluster Monetary Value","166b7332":"### 1. Hitung Recency Value","a88baed2":"Jika sebelumnya bagian marketing memberlakukan strategi yang sama terhadap semua customer, maka sekarang pihak marketing bisa memanfaatkan segmentasi RFM untuk membuat strategi yang lebih spesifik targetnya.\n\nContohnya seperti, tindakan apa yang harus dilakukan untuk mempertahankan customer agar selalu berada di kelas Diamond? jawabannya bisa dengan memberikan potongan harga yang spesial, buatkan personal merchandise, dll.\n\nSampai tahap ini kita bisa menyerahkan ke bagian marketing hasil segmentasi yang sudah dibuat untuk dilakukan perencanaan strategi dan analisa yang lebih mendalam.","e2d1bf7a":"### Tipe-Tipe Segmentasi:\n\n- Demographic: variabelnya: usia, gender, status pernikahan, pekerjaan.\n- Geographic: variabelnya: lokasi, wilayah, pedesaan.\n- Behavioral: variabelnya: pengeluaran, kebiasaan customer, penggunaan produk, produk yang dibeli sebelumnya.\n- Psychographic: variabelnya: status sosial, gaya hidup, karakter personal.","5c605aa3":"Buat histogram lagi untuk mengetahui distribusi kolom yang baru. sekarang distribusinya terlihat lebih baik, meskipun masih terjadi ketimpangan.","116371a5":"# Segmentasi Customer (Metode RFM)","fe850c22":"## Monetary Value (Revenue)","a60dba64":"Import data.","f51613d1":"Sama seperti Recency, kita akan gunakan 4 cluster","4978a3ec":"Secara garis besar, berikut adalah step yang dilakukan dalam membuat segmentasi customer menggunakan Lifetimes:\n\n- 1. Persiapkan data\n- 2. Buat RFM\n\nKita hanya akan melakukan segmentasi terhadap United Kingdom saja (karena datanya yang paling banyak, hehe)\n\nSebelum melakukan permodelan, kita persiapkan datanya terlebih dahulu menjadi format dataframe yang di inginkan Lifetimes.","c2314027":"Plot distribusi Recency valuenya","c95b2f53":"Distribusi Recencynya skewed ke kanan","a51cbe21":"Step 5. Buat kolom Revenue \n\nDefinisi Revenue dari Lifetimes adalah:\n- Revenue = UnitPrice * Quantity","0daba023":"Kita dapati terdapat banyak sekali kolom yang valuenya 0, apa yang terjadi?.\n\nSemuanya berawal dari recency, masih ingat definisi recency?.\n\n- Recency: Recency adalah umur customer ketika mereka melakukan pembelian yang paling terbaru (recent). Atau sama dengan durasi pembelian pertama(first purchase) sampai pembelian terbaru (latest purchase). *jika customer hanya melakukan satu kali pembelian, maka recency-nya adalah 0.\n\njika dilihat dari definisi diatas, maka kebanyakan customer tidak melakukan pembelian ulang, alias hanya membeli satu kali saja. efeknya, nilai frequency pun ikut menjadi 0, kok bisa? coba baca definisi frequency berikut:\n\n- Frequency: Angka pembelian ulang yang dilakukan customer. Atau sama dengan total pembelian dikurangi satu.\n\nJika total pembelian yang dilakukan customer hanya 1 kali, maka: 1-1= 0. Dan tentu saja efek ini berimbas ke monetary value. kalau recency dan frequency nya saja 0, lalu apa yang bisa dihitung untuk dimasukkan ke monetary value?.\n\nMaka dari itu kita akan melakukan sedikit penyesuaian lagi. Sekarang coba kita cek kondisi frequency dengan plot histogram.","4e4be876":"Berikut adalah bar plot dari label yang sudah dibuat","9a736333":"Transform InvoiceDate ke python object datetime","ee5629aa":"Segmentasi RFM adalah metode yang mudah untuk membuat segmentasi pelanggan. Outputnya intuitif, sehingga mudah untuk difahami dan di interpretasikan oleh pihak marketing nantinya. Namun dibalik kemudahannya, metode RFM memiliki beberapa kekurangan, yaitu:\n\n- Perhitungan segmentasi RFM hanya memperhatikan tiga faktor saja (Recency, Frequency, dan Monetary Value), dan mengabaikan faktor lain yang sama atau mungkin bisa jadi lebih penting (seperti rincian demografis, jenis produk, dll) \n\n- Segmentasi customer RFM adalah segmentasi yang memakai metode historical, yang artinya penilaian segmentasi hanya berdasarkan data masa lalu, yang mungkin tidak bisa menggambarkan kondisi customer di masa depan dengan baik. \n\nJadi, jangan mengambil keputusan hanya berdasarkan segmentasi RFM saja, perhatikan juga analisa model yang lain agar lebih luas point of view kita dalam mengambil keputusan.\n\nLalu antara Library Lifetimes dan K means, mana yang lebih baik? Jika dataset kalian tidak memiliki missing values, saya pribadi lebih merekomendasikan untuk pakai library saja, karena lebih cepat, mudah, dan praktis. Jika dataset kalian ada missing valuesnya, kalian bisa lakukan impute untuk mengisi missing valuesmya, tapi tentu saja hal itu akan mengurangi kepraktisan yang kita harapkan dari library.\n\nMungkin itu saja dari saya, jika ada pertanyaan atau masukan, bisa kalian tulis di kolom komentar atau boleh japri di ig saya: al.fath.terry \n\nDan... mohon di upvote jika dirasa bermanfaat. \n\nTerimakasih :)","68a9d880":"Plot 5 negara terbesar yang melakukan pembelian retail secara online (berbasis di UK)","fa53fb0a":"### Plot Missing Value","705fa464":"Aturan perhitungan score:\n\n- Recency: semakin rendah value Recency, semakin tinggi score nya.\n- Frequency: semakin tinggi value Frequency, semakin tinggi scorenya.\n- Monetary: semakin tinggi value Monetary, semakin tinggi scorenya.","e92920c2":"### 3. Hitung Frequency Score","8488111a":"Step 6. Persiapkan format dataframe yang di inginkan Lifetimes.\n\nBuat dataframe baru, agregatkan semua data berdasarkan InvoiceNo dan InvoiceDate.","0d84f607":"Setelah Score individual didapatkan, sekarang saatnya menghitung Score RFM  secara keseluruhan","908c901f":"Oh ya, sebetulnya ngga harus pake K-means sih, kalian bisa pakai algoritma clustering apapun, berhubung data penting yang akan kita modelkan adalah numerical semua (Recency, Frequency, Monetary Value, dan Invoicedate adalah data numerical ), dan juga K-means ini adalah algoritma yang simpel, jadi ya saya pakai K-means deh. \n\nAlasan lain yang menguatkan saya untuk memilih K-means adalah karena saya teringat pesan dari kak Wira: \"always start with simple model\". Siapa itu kak Wira? beliau adalah instruktur saya, hehe. Kenapa harus start with simple model? karena.... alasannya banyakkk, dan saya tidak akan menjabarkannya disini (mungkin akan saya ceritakan dilain notebook). Oke lanjut ke RFM nya ya.\n\nRFM adalah metode yang digunakan untuk mensegmentasikan customer berdasarkan kebiasaan perilaku pembeliannya. RFM ini termasuk kedalam tipe segmentasi Behavioral. Berikut adalah definisi masing-masing komponen dari RFM:\n\n- Recency: Recency adalah jarak waktu tidak aktifnya customer setelah mereka melakukan pembelian yang paling terbaru(recent). *jika customer hanya melakukan satu kali pembelian, maka recency-nya adalah 0. \n\n\n- Frequency: Angka pembelian *ulang*\/ repetisi pembelian yang dilakukan customer. Atau sama dengan total pembelian dikurangi satu.\n\n\n- Mean Moneter Value: rata-rata nilai uang yang telah dihabiskan oleh pelanggan dalam periode waktu tertentu. ini sama dengan jumlah semua pembelian customer dibagi dengan angka total pembelian (berapa kali customer melakukan pembelian).\n\nRFM dapat digunakan untuk mengenal basis customer dengan baik. Salah satu  contoh pemanfaatnya adalah, jika sebelumnya kalian memberikan treatment yang sama terhadap semua jenis customer yang ada, maka dengan RFM ini kalian bisa lebih spesifik dalam mengidentifikasi segmen yang ada, lalu menerapkan strategi pendekatan yang berbeda antar segmen. Agar lebih jelas, yuk ikuti terus kelanjutannya.","bf067b8b":"Kita akan gunakan library Lifetimes terlebih dahulu, Lifetimes adalah library Python yang bisa digunakan untuk analisa customer, selain itu Lifetimes juga bisa membuat model RFM berdasarkan data transaksional, dan fitur inilah yang akan kita gunakan.","2b5d487c":"## Kesimpulan ","8f58c4fe":"Kita gunakan United Kingdom saja sama seperti sebelumnya.","044d6fb8":"Kalian boleh melabeli score dengan nama apapun dan range berapapun, tergantung kebijakan kalian. Kali ini kita akan mensegmentasikannya menjadi 5 bagian, dengan urutan label sebagai berikut:\n'Bronze' sebagai yang terendah, diikuti dengan 'Silver', 'Goldr', 'Platinum', dan 'Diamond' yang tertinggi","49f89d30":"## Hitung Score RFM secara keseluruhan ","e4625387":"merge dataframe","5e35f29c":"### Plot 5 negara Terbesar","f6ea6efb":"Setelah melakukan EDA sekarang saatnya kita memodelkan data menjadi RFM. Yang pertama saya akan melakukannya dengan library Lifetimes, yang kedua saya akan menggunakan algoritma K-means.","d0187503":"Urutkan","fa49e489":"Step selanjutnya lakukan hal yang sama kepada Frequency dan Monetary value","89b1b993":"Step 2. Transform InvoiceDate ke python object datetime","6e362a72":"Berikut adalah langkah-langkah dalam membuat RFM model:\n\n- Step 1, hitung RFM Value\n- Step 2, hitung RFM Score\n- Step 3, hitung score RFM secara keseluruhan\n- Step 4, labeling\n\nKalau kalian bingung kenapa ada RFM Value dan RFM Score? apa bedanya? RFM Value adalah nilai dari RFM itu sendiri, sedangkan RFM Score adalah Score yang diberikan kepada RFM Value. agar lebih jelas, ikuti saja dulu notebook ini. Oke kita lanjut ya.","2e7c7f50":"### 2. Tentukan Jumlah Cluster","1396def5":"Untuk mengetahui kasta urutan valuenya kita akan menggunakan function berikut","067b7a5f":"### 1. Hitung Monetary Value\n\nUntuk menghitung Monetary Value, cukup kalikan UnitPrice dengan Quantity","4a0d083b":"## Frequency","53c4c247":"## A. Persiapkan data","cbe9a6bf":"Setelah melihat plot diatas, saya putuskan untuk menggunakan 4 kelas, karena 4 merupakan siku yang paling tidak tajam penurunannya.\n\nStep selanjutnya, hitung Recency score","16cb5654":"## Persiapkan Data","2c603e57":"Hitung Recency, rumusnya:\n\nRecency = titik waktu observasi - jumlah hari pembelian terakhir\n\n*kita gunakan waktu yang paling terkini (the latest) sebagai titik waktu observasi.","d0f5f63d":"Dan beginilah gambaran segmentasi customer yang sudah kita buat","25deff1f":"Ambil kolom CustomerID dan Frequency","68386481":"## Recency","c48d8ce8":"Ambil setiap ID yang ada","8e63b9ee":"Menghitung RFM individual Score dapat dilakukan dengan beberapa cara, kalian bisa menghitungnya menggunakan rumus perhitungan bisnis kalian sendiri yang kira-kira cocok dengan basis customer kalian. Kali ini kita akan menggunakan metode statistikal Quartil (membagi Score menjadi empat bagian)","34004f20":"## Step 3: Hitung RFM Score secara keseluruhan"}}