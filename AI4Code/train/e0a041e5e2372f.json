{"cell_type":{"c2292c7f":"code","67a221c2":"code","db59fa6f":"code","1238a6b7":"code","83f7c95e":"code","c06fa816":"code","7f317c0c":"code","34766647":"code","c1818462":"code","f0486e90":"code","7973b4d4":"code","4a60506c":"code","c06e8189":"code","31ba08bb":"code","59dcef10":"code","b13dd4ac":"code","a35d09cc":"code","c159d84b":"code","72c0e051":"code","cfa38525":"code","0e6fd309":"code","f0bd4dda":"code","46a30f2b":"code","c6169db8":"code","65d4cf57":"code","e25f15e2":"code","654d05b3":"code","d298decb":"code","70ee0faa":"code","1706faf4":"code","805ea519":"code","965222c9":"code","d1f25b70":"code","70d249a0":"code","b73a40d1":"code","e803560e":"code","14b9a6d8":"code","2fc99a8b":"markdown","ab782b89":"markdown","44737e9a":"markdown","0a23a320":"markdown","fb4b8bc5":"markdown","12568c25":"markdown","c4217223":"markdown","d916a956":"markdown"},"source":{"c2292c7f":"import numpy as np\nimport pandas as pd\nimport seaborn as sns \nimport matplotlib.pyplot as plt\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.neighbors import LocalOutlierFactor\nfrom scipy.stats import probplot\nfrom scipy.stats import zscore","67a221c2":"# Importing the dataset\ndf = pd.read_csv(\"..\/input\/indian-water-quality-data\/water_dataX.csv\", encoding= 'unicode_escape')\n# Selecting 1900 samples, because samples having indices greater than 1900 are not correct\ndf = df.iloc[0:1900, :]\ndf.shape","db59fa6f":"# Checking for datatypes of the dataset\ndf.dtypes","1238a6b7":"df.head()","83f7c95e":"# Changing column names\ndf = df.rename(columns={\"D.O. (mg\/l)\": \"DO\", \"CONDUCTIVITY (\u00b5mhos\/cm)\": \"Conductivity\", \"B.O.D. (mg\/l)\": \"BOD\", \"NITRATENAN N+ NITRITENANN (mg\/l)\": \"NI\", \"FECAL COLIFORM (MPN\/100ml)\": \"Fec_col\", \"TOTAL COLIFORM (MPN\/100ml)Mean\": \"Tot_col\"})","c06fa816":"# Converting object data type to numeric\ndef convert_to_numeric(df):\n    num_col = df.shape[1]\n    # Start from index 3\n    for index in range(3, num_col):\n        col_name = df.iloc[:, index].name\n        df[col_name] = pd.to_numeric(df[col_name], errors=\"coerce\")\n    return df\n\ndf = convert_to_numeric(df)\ndf.dtypes","7f317c0c":"# Replacing string NAN values with actual NAN value (np.nan)\ndef convert_to_nan(df):\n    n_col = df.shape[1]\n    for index in range(n_col):\n        df.iloc[:, index]  = df.iloc[:, index].replace(\"NAN\", np.nan)\n    return df\n\ndf = convert_to_nan(df)","34766647":"# Checking for missing values\ndf.isnull().sum().sort_values()","c1818462":"# Replacing NULL values with median of column\n# Selecting numeric data\ndf_num = df.select_dtypes(exclude=\"object\")\ndf_num_col = df_num.columns\nimputer = SimpleImputer(strategy=\"median\")\n\ndf_num = imputer.fit_transform(df_num)\ndf_num = pd.DataFrame(df_num, columns=df_num_col)","f0486e90":"# Filling Categorical missing values\ndf_cat = df.select_dtypes(include=\"object\")\ndf_cat.isnull().sum()","7973b4d4":"# Here we can fill these values by obeserving other attributes\n# Example - \npd.set_option('mode.chained_assignment', None)\ndf_cat_copy = df_cat.copy()\n\ndf_cat_copy[df_cat_copy[\"STATION CODE\"] == \"1330\"]\n# Station Code with value 1330 will have Location - TAMBIRAPARANI which belongs in STATE - TAMIL NADU\n# I can replace all the NAN occurences in STATE with TAMILNADU\ndf_cat_copy[\"STATE\"][df_cat_copy[\"STATION CODE\"] == \"1330\"] = df_cat_copy[\"STATE\"][df_cat_copy[\"STATION CODE\"] == \"1330\"].fillna(\"TAMILNADU\")\n\ndf_cat_copy[df_cat_copy[\"STATION CODE\"] == \"1330\"]","4a60506c":"# The NULL values in LOCATION attribute are in STATE attribute (ex - above dataframe)\n# So, I will fill the NULL values in LOCATION attribute with the corresponding STATE value\n# And, the state value will be replaced by the function \"fill_state\" defined below this cell\n\ndef fill_locations(df_cat):\n    location_null = df_cat[df_cat[\"LOCATIONS\"].isnull()]\n    location_null_indices = location_null.index\n    for index in location_null_indices:\n        state_value = location_null[\"STATE\"][index]\n        location_null[\"LOCATIONS\"][index] = state_value\n        location_null[\"STATE\"][index] = np.nan\n    df_cat[df_cat[\"LOCATIONS\"].isnull()] = location_null\n    return\n\nfill_locations(df_cat_copy)\ndf_cat_copy[df_cat_copy[\"STATION CODE\"] == \"1330\"]","c06e8189":"df_cat_copy[df_cat_copy[\"LOCATIONS\"] == \"TAMBIRAPARANI AT ARUMUGANERI, TAMILNADU\"]","31ba08bb":"# Now I can fill NULL values of Station code with corresponding LOCATION value(ex - above dataframe)\n# I will match the corresponding LOCATION value with other same LOCATION value and insert the value of station code\n\ndef fill_code(df_cat):\n    station_null = df_cat[df_cat[\"STATION CODE\"].isnull()]\n    station_null_indices = station_null.index\n    for index in station_null_indices:\n        stat_code = np.nan\n        location_index = station_null[\"LOCATIONS\"][index]\n        code_at_location = df_cat[\"STATION CODE\"][df_cat[\"LOCATIONS\"] == location_index]\n        for index_code in code_at_location.index:\n            if (code_at_location[index_code] != np.nan):\n                stat_code = code_at_location[index_code]\n                break\n        station_null[\"STATION CODE\"][index] = stat_code\n    df_cat[df_cat[\"STATION CODE\"].isnull()] = station_null\n    return\n\nfill_code(df_cat_copy)\ndf_cat_copy[df_cat_copy[\"LOCATIONS\"] == \"TAMBIRAPARANI AT ARUMUGANERI, TAMILNADU\"]","59dcef10":"# Filling all state NAN values which have corresponding station code value\ndef fill_state(df_cat):\n    station_code = df_cat[\"STATION CODE\"].unique()\n    for index in range(station_code.shape[0]):\n        if (station_code[index] != np.nan):\n            df_state = df_cat[\"STATE\"][df_cat[\"STATION CODE\"] == station_code[index]] \n            state_values = df_cat[\"STATE\"][df_cat[\"STATION CODE\"] == station_code[index]]\n            state = np.nan\n            for index_state in range(state_values.shape[0]):\n                if (state_values.iloc[index_state] != np.nan):\n                    state = state_values.iloc[index_state]\n                    break\n            df_state_fill = df_state.fillna(state) \n            df_cat[\"STATE\"][df_cat[\"STATION CODE\"] == station_code[index]] = df_state_fill\n    return\nfill_state(df_cat_copy)\ndf_cat_copy[df_cat_copy[\"STATION CODE\"] == \"1330\"]","b13dd4ac":"df_cat_copy.isnull().sum()","a35d09cc":"df_cat_copy[df_cat_copy[\"STATE\"].isnull()]","c159d84b":"# The first location KABBANI AT MUTHANKARA is in STATE Kerela\ndf_cat_copy[\"STATE\"][1106] = \"KERALA\"\ndf_cat_copy[\"STATE\"][1107] = \"KERALA\"\ndf_cat_copy[\"STATE\"][1650] = \"CHANDIGARH\"\ndf_cat_copy[\"STATE\"][1651] = \"CHANDIGARH\"\ndf_cat_copy[\"STATE\"][1652] = \"CHANDIGARH\"\ndf_cat_copy[\"STATE\"][1770] = \"CHANDIGARH\"\ndf_cat_copy[\"STATE\"][1771] = \"CHANDIGARH\"\ndf_cat_copy[\"STATE\"][1772] = \"CHANDIGARH\"\ndf_cat_copy[\"STATE\"][1784] = \"DAMAN & DIU\"\ndf_cat_copy[\"STATE\"][1785] = \"DAMAN & DIU\"\ndf_cat_copy[\"STATION CODE\"][1784] = \"0000\" # I am setting this according to myself\ndf_cat_copy[\"STATION CODE\"][1785] = \"0000\"","72c0e051":"df_cat = df_cat_copy\ndf_cat.isnull().sum()","cfa38525":"df_num.isnull().sum()","0e6fd309":"df_final = pd.concat([df_cat, df_num], axis=1)\ndf_final.isnull().sum()","f0bd4dda":"# These are the samples which don't contain any attribute\n# The filled attributes are median of corresponding columns\n# So it is best to remove them\ndf_null = df_final[(df_final[\"STATION CODE\"].isnull()) & (df_final[\"LOCATIONS\"].isnull()) & (df_final[\"STATE\"].isnull())]\ndf_null_indices = df_null.index\ndf_final.drop(df_null_indices, axis=0, inplace=True)\ndf_null","46a30f2b":"df_final.isnull().sum()","c6169db8":"df_final.shape","65d4cf57":"# PLotting PDFs of all the numeric attributes in the dataset\n\ndf_num_final = df_final.select_dtypes(exclude=\"object\")\n\ndef plot_kde(df):\n    n_col = df.shape[1]\n    for index in range(n_col):\n        col_index = df.iloc[:, index]\n        fig, ax = plt.subplots(1,1, figsize=(7, 5))\n        sns.kdeplot(data=df, x=col_index.name)\n        \nplot_kde(df_num_final)","e25f15e2":"# Here, almost all kde plots are Gaussian Like \n# Using Z-Score Normalization to detect outliers\n\ndf_num_final_norm = zscore(df_num_final, axis=0)\n\n\ndef indices_of_greater_than_3(df_norm):\n    indices_arr = []\n    n_col = df_norm.shape[1]\n    for index in range(n_col):\n        col_index = df_norm.iloc[: ,index]\n        greater_than_3 = df_norm[col_index > 3]\n        greater_than_3_index = greater_than_3.index\n        indices_arr.extend(greater_than_3_index)\n    return indices_arr\n\nindices_arr = indices_of_greater_than_3(df_num_final_norm)\nprint(\"Number of outliers using Z-Score method-\",len(indices_arr))\ndf_final.iloc[indices_arr, :]","654d05b3":"df_final.drop(indices_arr, axis=0, inplace=True)\ndf_final.shape","d298decb":"# KDE plots after removal of outliers\nplot_kde(df_final.select_dtypes(exclude=\"object\"))","70ee0faa":"# Calculating Water Quality Index of each sample\ndf_num_final = df_final.select_dtypes(exclude=\"object\")\n# Dropping year and Temp attribute because they are not used for computing WQI\ndf_num_final.drop([\"year\", \"Temp\"], axis=1, inplace=True)\n\n# Weight Vector(wi)\nwi = np.array([0.2213, 0.2604, 0.0022, 0.4426, 0.0492, 0.0221, 0.0022])\n\n# Standard values of parameters(si)\nsi = np.array([10, 8.5, 1000, 5, 45, 100, 1000])\n\n# Ideal values of paramters(vIdeal)\nvIdeal = np.array([14.6, 7, 0, 0, 0, 0, 0])\n\ndef calc_wqi(sample):\n    wqi_sample = 0\n    num_col = 7\n    for index in range(num_col):\n        v_index = sample[index] # Obeserved value of sample at index\n        v_index_ideal = vIdeal[index] # Ideal value of obeserved value\n        w_index = wi[index] # weight of corresponding parameter of obeserved value\n        std_index = si[index] # Standard value recommended for obeserved value\n        q_index = (v_index - v_index_ideal) \/ (std_index - v_index_ideal)\n        q_index = q_index * 100 # Final qi value of obeserved value\n        wqi_sample += q_index*w_index\n    return wqi_sample","1706faf4":"# Computing WQI for the whole dataset\ndef calc_wqi_for_df(df):\n    wqi_arr = []\n    for index in range(df.shape[0]):\n        index_row = df.iloc[index, :]\n        wqi_row = calc_wqi(index_row)\n        wqi_arr.append(wqi_row)\n    return wqi_arr","805ea519":"wqi_arr = calc_wqi_for_df(df_num_final)\n# Converting oridnary array to numpy array\nwqi_arr = np.array(wqi_arr)\nwqi_arr = np.reshape(wqi_arr, (-1, 1))\n\n# Resetting index values of the dataframes\nwqi_arr_df = pd.DataFrame(wqi_arr, columns=[\"WQI\"]).reset_index()\ndf_final = df_final.reset_index()","965222c9":"# Combining dataframe of WQI and dataframe of attributes \ndf_wqi = pd.concat([df_final, pd.DataFrame(wqi_arr, columns=[\"WQI\"])], axis=1)\ndf_wqi.drop(\"index\", axis=1, inplace=True)\ndf_wqi.shape","d1f25b70":"# These are samples with negative WQI\ndf_wqi[(df_wqi[\"WQI\"] < 0)]","70d249a0":"# Removing the samples with negative WQI\ndf_neg_indices = df_wqi[(df_wqi[\"WQI\"] < 0)].index\ndf_wqi.drop(df_neg_indices, axis=0, inplace=True)","b73a40d1":"df_wqi[\"WQI clf\"] = df_wqi[\"WQI\"].apply(lambda x: (3 if (x <= 25)  \n                                        else(2 if (26<=x<=50) \n                                        else(1 if (51<=x<=75) \n                                        else 0))))","e803560e":"df_wqi.tail()","14b9a6d8":"df_wqi.describe()","2fc99a8b":"## Water Quality Index Calculation\n\nI will be using \"Weighted Arithmetic Water Quality Index Method\" to calculate WQI of each water sample. The formula to calculate WQI is - \n\n**WQI = \u2211 qi \u00d7 wi \/ \u2211 wi**\n\nHere wi - Unit weight of ith parameter\n\n     qi - Quality estimate scale of each parameter, it is calculated with the formula - \n\n**qi = 100 \u00d7 ( Vi \u2212 VIdeal \/ Si \u2212 VIdeal )**\n\nHere Vi - Measured value of ith parameter\n\n     Videal - Ideal value of ith parameter in pure water\n     \n     Si - Standard value recommended for ith parameter\n\nwi is calculated by the formula - \n\n**wi = K \/  Si**\n\nHere K is proportionality constant which is - \n\n **K = 1 \/  \u2211 Si**","ab782b89":"##### Ideal value of parameters (Videal) - \n\nDissolved Oxygen                     14.6\n\npH                                   7.0\n\nConductivity                         0\n\nBiological Oxygen Demand             0\n\nNitrate                              0\n\nFecal Coliform                       0\n\nTotal Coliform                       0","44737e9a":"* The above are the missing values which are left and does not satisfy any condition\n* So, according to the location these values will be filled manually\n","0a23a320":"* Since I have 1900 training examples, I can replace each missing value with median of the column (to avoid outliers)","fb4b8bc5":"##### Standard value recommended for parameters (Si) - \n\nDissolved oxygen, mg\/L               10\n\npH                                   8.5\n\nConductivity, \u00b5S\/cm                  1000\n\nBiological oxygen demand, mg\/L       5\n\nNitrate, mg\/L                        45\n\nFecal coliform\/100 mL                100\n\nTotal coliform\/100 mL                1000","12568c25":"##### Values of unit weights for each parameter (wi) - \n\nDissolved Oxygen                     0.2213\n\npH                                   0.2604\n\nConductivity                         0.0022\n\nBiological Oxygen Demand             0.4426\n\nNitrate                              0.0492\n\nFecal Coliform                       0.0221\n\nTotal Coliform                       0.0022","c4217223":"* The final dataset contains 1898 samples and 12 attributes","d916a956":"Now I will set level of water contamination based on WQI -\n\n          WQI Range                   Classification\n\n         Less than 25                  Excellent(3)\n            26\u201350                         Good(2)\n            51-75                         Poor(1)\n        Greater than 75                 Very Poor(0)"}}