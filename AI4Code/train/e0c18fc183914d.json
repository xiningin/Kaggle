{"cell_type":{"080d18c1":"code","23982b7d":"code","4605b54e":"code","057c5e15":"code","f1abb147":"code","84082971":"code","42720559":"code","b538469a":"code","6d5bf726":"code","e21cbb2a":"code","321cea11":"code","28257e01":"code","521ccdb2":"code","17c4a6f4":"code","54167122":"code","c360af08":"markdown","10b8dd1a":"markdown","be97228d":"markdown","23dfb2d8":"markdown","4f8dde4c":"markdown","a3d38ef4":"markdown","f94541a9":"markdown","2e5c3cf2":"markdown","5c556356":"markdown","8bdffb9b":"markdown","ef0a3e36":"markdown","e1b3faa0":"markdown","d5fdcef3":"markdown"},"source":{"080d18c1":"from mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt # plotting\nimport numpy as np # linear algebra\nimport os # accessing directory structure\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport json\n","23982b7d":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","4605b54e":"print(os.listdir(\"..\/input\"))","057c5e15":"with open('..\/input\/starwars-full-interactions-allCharacters.json') as f:\n    data = json.load(f)\nprint(data['nodes'][0])\nprint(data['links'][0])\n","f1abb147":"import networkx as nx\nG = nx.Graph()\n\n#build graph nodes\nfor node in data['nodes']:\n    G.add_node(node['name'])\n    \n#build graph edges\nfor edge in data['links']:\n    G.add_edge(data['nodes'][edge['source']]['name'], data['nodes'][edge['target']]['name'])\n\n# G.add_node((data['nodes'][0]['value'], data['nodes'][0]['name']))\n# G.add_nodes_from([(data['nodes'][1]['value'], data['nodes'][1]['name'])])","84082971":"list(G)\nG.number_of_nodes()\nG.number_of_edges()","42720559":"options = {\n    'node_color': 'yellow',\n    'node_size': 400,\n    'width': 1,\n    'with_labels': True\n}\n\nnx.draw(G, **options)","b538469a":"#breadth-first search of a given graph, given number of layers, and given character\n#prints the characters most closely related with the node 'goodSideChar' and its neighbors\ndef BFS(graph, layers, goodSideChar):\n    curNode = goodSideChar\n    goodCounts = {curNode: 1}\n    visited = {}  #keep track of nodes we have already seen\n    queue = []    #keep track of nodes up next\n\n    #copy list of nodes into goodCounts dict\n    for node in graph.nodes():\n        goodCounts.update({node: 0})\n    \n    queue.append(curNode)\n    visited.update({curNode: True})\n    depth = 0\n    \n    while queue:\n        #check if we reached the specified depth\n        if queue[0] == 'null':\n            depth = depth + 1\n            queue.pop(0)\n        if layers == depth:\n            break\n        \n        curNode = queue.pop(0)\n        for node in list(graph.neighbors(curNode)):\n            #if node is already in dict, increment count\n            if goodCounts.get(node) is None:\n                goodCounts.update({node: 1})\n            else:\n                goodCounts.update({node: goodCounts.get(node) + 1})\n                \n            #queue node to be searched\n            if visited.get(node) is None:\n                visited.update({node: True})\n                queue.append(node)\n        queue.append('null')    \n    \n    #print goodCounts in sorted order        \n    listofTuples = sorted(goodCounts.items() , reverse=True, key=lambda x: x[1])\n    for elem in listofTuples:\n        print(elem[0] , \":\" , elem[1] )\n","6d5bf726":"BFS(G, 1, \"OBI-WAN\")","e21cbb2a":"cent = nx.degree_centrality(G)\n#print cent in sorted order limit 5    \nlistofTuples = sorted(cent.items() , reverse=True, key=lambda x: x[1])\nfor i in range(0,5):\n    print(listofTuples[i][0] , \":\" , listofTuples[i][1] )","321cea11":"bet = nx.betweenness_centrality(G,k=None,normalized=True,weight=None,endpoints=False,seed=None)\n#print bet in sorted order limit 5    \nlistofTuples = sorted(bet.items() , reverse=True, key=lambda x: x[1])\nfor i in range(0,5):\n    print(listofTuples[i][0] , \":\" , listofTuples[i][1] )","28257e01":"def calcCliqness(G):\n    cliq = nx.find_cliques(G)\n    count = 0\n    for i in cliq:\n        #print(i)\n        count += 1\n    #print('Count: ' + str(count))\n\n    cliquishness = count \/ len(G.nodes)\n    return cliquishness\n    #print(cliquishness)","521ccdb2":"#flip edges with probability 'prob'\nimport random as rand\nG_Original = G.copy()\nprob = .99\ncount = 0\ncliqVals = [calcCliqness(G)]\nprint('Begining num of edges: ' + str(len(G.edges)))\n\n\nfor e in G.edges:\n    if rand.uniform(0,1) <= prob:\n        print(str(count) + str(e))\n        source = e[0]\n        target = data['nodes'][rand.randrange(len(G.nodes))]['name'] \n        while G.has_edge(source, target):\n            target = data['nodes'][rand.randrange(len(G.nodes))]['name']\n        G.remove_edge(*e)\n        G.add_edge(source, target)\n        count += 1\n        cliqVals.append(calcCliqness(G))\n        if(nx.is_connected(G)):\n            print(nx.average_shortest_path_length(G))\n        else:\n            print('Not Connected')\n\n        \nprint('Ending num of edges: ' + str(len(G.edges)))\nprint('\\nProbability: ' + str(prob))\nprint('Edges Fliped: ' + str(count))\nfor i in cliqVals:\n    print(i)\n    \nG = G_Original.copy()","17c4a6f4":"numOfNeighbors = {}\n\nfor node in G.nodes():\n    count = 0\n    for i in G.neighbors(node):\n        count += 1\n    numOfNeighbors.update({node: count})\n\n#print list of 5 weakest nodes\nlistofTuples = sorted(numOfNeighbors.items() , reverse=False, key=lambda x: x[1])\nfor i in range(0,5):\n    print(listofTuples[i][0] , \":\" , listofTuples[i][1] )","54167122":"numOfNeighbors = {}\n\nfor node in G.nodes():\n    count = 0\n    for i in G.neighbors(node):\n        count += 1\n    numOfNeighbors.update({node: count})\n\n#print list of 5 strongest nodes\nlistofTuples = sorted(numOfNeighbors.items() , reverse=True, key=lambda x: x[1])\nfor i in range(0,10):\n    print(listofTuples[i][0] , \":\" , listofTuples[i][1] )","c360af08":"I am new to this environment, so let me figure out how to access this data","10b8dd1a":"# Task 3\nCompute cliquishness of graph. To do this, I will count the number of cliques found in the graph and divide by the number of nodes.","be97228d":"Now I want to simulate flipping random edges and calculate the cliquishness each iteration","23dfb2d8":"Okay, now I have figured out how to touch the data. I need to load the data in\n\nTo load data, run the following code block passing one of the files:\n* ..\/input\/starwars-episode-1-interactions-allCharacters.json\n* ..\/input\/starwars-episode-2-interactions-allCharacters.json\n* ..\/input\/starwars-episode-3-interactions-allCharacters.json\n* ..\/input\/starwars-episode-4-interactions-allCharacters.json\n* ..\/input\/starwars-episode-5-interactions-allCharacters.json\n* ..\/input\/starwars-episode-6-interactions-allCharacters.json\n* ..\/input\/starwars-full-interactions-allCharacters.json","4f8dde4c":"For Hypothesis 2, print top 5 results for centrality and betweenness","a3d38ef4":"# CSC455 P1: Star Wars Relationships\nName: David Shaw \n\nUnityID: dsshaw2","f94541a9":"## Conclusion","2e5c3cf2":"**Label Good\/Dark Side**","5c556356":"**Building a graph**\nNodes are character's names\nEdges are placed between characters whom appear in the same scene","8bdffb9b":"# Task 5\nCompare the emmergence of characters across all episodes by calculating the strongest ties of each episode.","ef0a3e36":"## ReadMe\nTo complete my analysis of the Star Wars network, I used this notebook to organize my code. Each block can be run by clicking into the block, and pressing control+enter or shift+enter. Additionally, the entire notebook can be run by clicking the \"Run All\" button in the above toolbar.\n\nTo change which episode to analyze, edit the 4th code block in this notebook. The filepaths for the 6 episodes and the entire series are given in the markdown block above the 4th code block in this notebook.","e1b3faa0":"# Task 4\nWeak ties - I distinguish weak ties by totaling the number of edges for each node. Nodes with the least amount of edges are the weakest because they have the fewest connections. The 5 nodes with the fewest edges are the weakest nodes and printed out.","d5fdcef3":"There is 0 csv file in the current version of the dataset:\n"}}