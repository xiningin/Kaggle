{"cell_type":{"368b26d7":"code","f94ca628":"code","c9b93558":"code","9bc621c3":"code","8e8781e3":"code","ee5e461d":"code","1f9fc103":"code","5df77ff0":"code","9e217bf6":"code","9f651237":"code","49ce0378":"code","c80c044c":"code","a245ad97":"code","4876e84d":"code","9e7cf697":"code","e0b31c53":"code","f54baca0":"markdown","b481d224":"markdown","ef9e00d3":"markdown","4dad1b22":"markdown","14022fbb":"markdown","390fe639":"markdown","9c75a235":"markdown","ffc44530":"markdown","b9f716b1":"markdown"},"source":{"368b26d7":"from math import log\n\n# loss1 - None\nloss1 = -1\/4000 * (174 * log(174\/1477) + (1477 - 174) * log(1 - 174\/1477))\n\n\n# loss2 - 16:9\n# cd == '1\/48000':\nloss2_1 = -1\/4000 * (1407 * log(1407\/1873) + (1873 - 1407) * log(1 - 1407\/1873))\n# cd == else:\nloss2_2 = -1\/4000 * (156 * log(156\/206) + (206 - 156) * log(1 - 156\/206))\n\n\n# loss3 - 9:16\n# cd == '1\/48000':\nloss3_1 = -1\/4000 * (70 * log(70\/178) + (178 - 70) * log(1 - 70\/178))\n# cd == else:\nloss3_2 = -1\/4000 * (182 * log(182\/241) + (241 - 182) * log(1 - 182\/241))\n\n\n# others\nothers = -1\/4000 * (11 * log(11\/25) + 14 * log(14\/25))\n\nscore = loss1 + loss2_1 + loss2_2 + loss3_1 + loss3_2 + others","f94ca628":"print('Public LB score: ', int(score * 100000) \/ 100000)","c9b93558":"import pandas as pd\nimport glob\nimport os\nimport subprocess as sp\nimport tqdm.notebook as tqdm\nfrom collections import defaultdict\nimport json\n\n! tar xvf ..\/input\/ffmpeg-static-build\/ffmpeg-git-amd64-static.tar.xz","9bc621c3":"def check_output(*popenargs, **kwargs):\n    closeNULL = 0\n    try:\n        from subprocess import DEVNULL\n        closeNULL = 0\n    except ImportError:\n        import os\n        DEVNULL = open(os.devnull, 'wb')\n        closeNULL = 1\n\n    process = sp.Popen(stdout=sp.PIPE, stderr=DEVNULL, *popenargs, **kwargs)\n    output, unused_err = process.communicate()\n    retcode = process.poll()\n\n    if closeNULL:\n        DEVNULL.close()\n\n    if retcode:\n        cmd = kwargs.get(\"args\")\n        if cmd is None:\n            cmd = popenargs[0]\n        error = sp.CalledProcessError(retcode, cmd)\n        error.output = output\n        raise error\n    return output\n\ndef ffprobe(filename):\n    \n    command = [\"..\/working\/ffmpeg-git-20191209-amd64-static\/ffprobe\", \"-v\", \"error\", \"-show_streams\", \"-print_format\", \"xml\", filename]\n\n    xml = check_output(command)\n    \n    return xml\n\ndef get_markers(video_file):\n\n    xml = ffprobe(str(video_file))\n    \n    found = str(xml).find('display_aspect_ratio')\n    if found >= 0:\n        ar = str(xml)[found+22:found+26]\n    else:\n        ar = None\n        \n    found = str(xml).find('\"audio\" codec_time_base')\n    if found >= 0:\n        cd = str(xml)[found+25:found+32]\n    else:\n        cd = None\n    \n    return ar, cd","8e8781e3":"video_file = '\/kaggle\/input\/deepfake-detection-challenge\/test_videos\/gunamloolc.mp4'\nget_markers(video_file)","ee5e461d":"filenames = glob.glob('\/kaggle\/input\/deepfake-detection-challenge\/train_sample_videos\/*.mp4')","1f9fc103":"my_dict = defaultdict()\nfor filename in tqdm.tqdm(filenames):\n    fn = filename.split('\/')[-1]\n    ar, cd = get_markers(filename)\n    my_dict[fn] = ar","5df77ff0":"display_aspect_ratios = pd.DataFrame.from_dict(my_dict, orient='index')\ndisplay_aspect_ratios.columns = ['display_aspect_ratio']\ndisplay_aspect_ratios = display_aspect_ratios.fillna('NONE')","9e217bf6":"labels = json.load(open('\/kaggle\/input\/deepfake-detection-challenge\/train_sample_videos\/metadata.json', encoding=\"utf8\"))\n\nlabels = pd.DataFrame(labels).transpose()\nlabels = labels.reset_index()\nlabels = labels.join(display_aspect_ratios, on='index')","9f651237":"labels.head()","49ce0378":"pd.crosstab(labels.display_aspect_ratio, labels.label)","c80c044c":"filenames = glob.glob('\/kaggle\/input\/deepfake-detection-challenge\/test_videos\/*.mp4')","a245ad97":"sub = pd.read_csv('\/kaggle\/input\/deepfake-detection-challenge\/sample_submission.csv')\nsub.label = 11\/25\nsub = sub.set_index('filename',drop=False)","4876e84d":"for filename in tqdm.tqdm(filenames):\n    \n    fn = filename.split('\/')[-1]\n    ar, cd = get_markers(filename)\n    \n    if ar is None:\n        sub.loc[fn, 'label'] = 174\/1477\n    if cd == '1\/48000':\n        if ar == '16:9':\n            sub.loc[fn, 'label'] = 1407\/1873\n        if ar == '9:16':\n            sub.loc[fn, 'label'] = 70\/178\n    else:\n        if ar == '16:9':\n            sub.loc[fn, 'label'] = 156\/206\n        if ar == '9:16':\n            sub.loc[fn, 'label'] = 182\/241","9e7cf697":"sub.label.value_counts()","e0b31c53":"sub.to_csv('submission.csv', index=False)","f54baca0":"# If you like it, please give it an upvote.","b481d224":"This notebook uses display_aspect_ratio metadata field as a great fake video predictor.","ef9e00d3":"The code below is from\n\nhttp:\/\/www.scikit-video.org\/stable\/io.html\n\nand specifically assembled from the following source files\n\nhttps:\/\/github.com\/scikit-video\/scikit-video\/blob\/master\/skvideo\/io\/ffprobe.py\n\nhttps:\/\/github.com\/scikit-video\/scikit-video\/blob\/master\/skvideo\/utils\/__init__.py\n\nThanks to [btk1](https:\/\/www.kaggle.com\/rakibilly) for the [ffmpeg Static Build dataset](https:\/\/www.kaggle.com\/rakibilly\/ffmpeg-static-build)","4dad1b22":"# Make predictions","14022fbb":"# Getting the metadata field with ffprobe","390fe639":"In the public test datatset it is not strictly true that if display_aspect_ratio field is missing it is a real video, and if it equals 16:9 it is a fake. There are some exceptions for whatever reason, but not too many. By selecting a proper threshold below we can decrease log-loss substantially. The thresholds are selected by Gurobi solver running on available submissions.\n\nIn more details, there are 4 groups that I am looking at, depending on the values of display_aspect_ratio, see below. In each of the groups there are [1303,  516,  167,   14] real samples and [ 174, 1563,  252,   11] fakes samples. For each group I select probability of a fake for that group, - this is the value that minimizes log-loss. How did I get the numbers for each group? I had some submissions with scores already, where I put different values for those groups. With these constraints it is possible to find the numbers, even manually. But manually is a little bit tiresome, so I wrote a mixed integer programming formulation for that problem, and used Gurobi to solve.","9c75a235":"# Motivation","ffc44530":"# Metadata is leaking targets","b9f716b1":"It's fork from https:\/\/www.kaggle.com\/zaharch\/data-leak-in-metadata @nosound\n\nThe original author has computed the data distribution, so we can compute Public LB score directly.\n\nThis leak will be repaired shortly afterwards."}}