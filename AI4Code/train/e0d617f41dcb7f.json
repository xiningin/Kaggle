{"cell_type":{"ec786f83":"code","057c3897":"code","1986de94":"code","049ef3ea":"code","75f3636d":"code","f0e6baa4":"code","38df1908":"code","90ac93a0":"code","7df9d9ae":"code","b6121214":"code","470b85a3":"code","5a29a32a":"code","0e57f4bd":"code","0a6b8224":"code","6113b0ba":"code","4b7a4db6":"code","68a0aea8":"code","d7c7e287":"code","63c57812":"code","37411a04":"code","bc38c23c":"code","41f8e2c1":"code","413d1d69":"code","71b303f8":"code","fd8f778d":"code","24ff4cd6":"code","742ebf8b":"code","186e52ab":"code","75ef1cf6":"code","d8e60fbd":"code","e492d63d":"code","f677fd0e":"markdown","357bc68e":"markdown","8e407824":"markdown","55353438":"markdown","ce1639f0":"markdown","8824a00c":"markdown","e5ecd37d":"markdown","566696f4":"markdown","3e385bb7":"markdown","5b02dccb":"markdown","a6cee739":"markdown","86b7d254":"markdown","da3b88e0":"markdown","50170ed4":"markdown","ca967156":"markdown","96e584a8":"markdown","85f7ea80":"markdown","820e6aef":"markdown","d7afe883":"markdown","7979fbda":"markdown","09c4bff4":"markdown","06ca5670":"markdown","3a4f6f1e":"markdown","78853acc":"markdown","3d90c8aa":"markdown","d40c6bda":"markdown","a675d194":"markdown","bfe7071a":"markdown","ae2b36d9":"markdown","7d6591dc":"markdown","cb4fe821":"markdown","287f0345":"markdown","6d6d9ee5":"markdown","9986fa13":"markdown","f44eb380":"markdown","59b995cb":"markdown","47b0a5a3":"markdown"},"source":{"ec786f83":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport seaborn as sns\nplt.style.use(style='ggplot')\nplt.rcParams['figure.figsize'] = (10, 6)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","057c3897":"#Reading the dataset\napplication = pd.read_csv(\"..\/input\/application_train.csv\")\napplication.head()","1986de94":"target_col = application['TARGET'].value_counts()\nx = target_col.index.tolist()\ny = target_col.values\ntotal_observations = y.sum()\n\n'''Matplotlib code starts here'''\nfig = plt.figure()\nax = fig.add_subplot(111)\n#or use this: fig, ax = plt.subplots()\nbar_plot = ax.bar(x, y, width=0.5, color='gr')\nax.set_xticks(x)\nax.set_xlabel('Target variable values')\nax.set_xticklabels(['Repay Loan','Default Loan'], rotation=0, fontsize=15)\n\nax.set_ylim(ymin=0, ymax=300000)\nax.set_ylabel('Count of target variable')\nax.set_yticks(np.arange(0, 325000, 25000))\n\n#The commented code below will convert y axis into percentage\n# formatter = FuncFormatter(lambda y, pos: \"%d%%\" % (y))\n# ax.yaxis.set_major_formatter(formatter)\n\nfor rect in bar_plot:\n    height = rect.get_height()\n    ax.text(rect.get_x() + rect.get_width()\/2., 0.99*height,\n            '%.2f' % ((height\/total_observations)*100) + \"%\", ha='center', va='bottom', fontsize=15)\n\nplt.title('Distribution of target variable')\nplt.show()","049ef3ea":"corr_vars = application.corr()['TARGET'].sort_values()\npositive_corr = corr_vars[corr_vars > 0].sort_values(ascending=False).drop('TARGET')[:10]\nnegative_corr = corr_vars[corr_vars < 0].sort_values(ascending=True)[:10]","75f3636d":"positive_corr","f0e6baa4":"negative_corr","38df1908":"cols_with_missing_values = len(application.isnull().sum()[application.isnull().sum() > 0])\ntotal_cols = application.shape[1] - 1\nprint(\"{} columns out of total {} columns have missing values\".format(cols_with_missing_values, total_cols))","90ac93a0":"missing_cols_prcnt = application.isnull().sum()\/application.shape[0] * 100\nhigh_missing_values = missing_cols_prcnt[missing_cols_prcnt > 50]\nhigh_missing_values_index = high_missing_values.index.tolist()\nprint(\"{} columns have more than 50% missing values\".format(len(high_missing_values_index)))\nprint(\"Top 10 columns with highest proportion of missing values:\")\nhigh_missing_values.sort_values(ascending=False)[:10]","7df9d9ae":"correlations = application.corr()['TARGET'].sort_values()\ncorr_missing_cols = correlations.reindex(high_missing_values_index).sort_values()\nmissing_cols_to_be_dropped = corr_missing_cols.index.difference(corr_missing_cols[(corr_missing_cols > 0.02) | (corr_missing_cols < -0.02)].index).tolist()\nprint(\"Number of columns that are to be dropped: {}\".format(len(missing_cols_to_be_dropped)))","b6121214":"pd.options.display.float_format = '{:.2f}'.format #Used to avoid scientific notation\napplication[[\"AMT_INCOME_TOTAL\", \"AMT_ANNUITY\", \"AMT_CREDIT\", \"AMT_GOODS_PRICE\"]].describe()","470b85a3":"fig, (ax1, ax2) = plt.subplots(1, 2)\nsns.distplot(application[\"AMT_CREDIT\"], color = 'blue', ax = ax1)\nsns.boxplot(x=application[\"AMT_CREDIT\"], ax = ax2)\nplt.show()","5a29a32a":"import matplotlib.gridspec as gridspec\nG = gridspec.GridSpec(4, 4)\nG.update(wspace=0.25, hspace=0.5)\nplt.figure(figsize = (20,20))\naxes_l = []\nnumeric_cols = [\"AMT_INCOME_TOTAL\", \"AMT_ANNUITY\", \"AMT_CREDIT\", \"AMT_GOODS_PRICE\"]\nrow_index = 0\ncol_index = 0\naxes_count = 0\nfor i, col in enumerate(numeric_cols):\n    #Plotting distribution plot \n    row_index = i\n    axes_l.append(plt.subplot(G[row_index, col_index]))\n    if application[col].isnull().sum() == 0:\n        sns.distplot(application[col], color = 'blue', ax = axes_l[axes_count])\n    else:\n        sns.distplot(application[col].dropna(), color = 'blue', ax = axes_l[axes_count])\n    plt.title('Distribution plot:'+col)\n              \n    axes_count+=1\n    col_index+=1\n    #Plotting boxplot\n    axes_l.append(plt.subplot(G[row_index, col_index]))\n    if application[col].isnull().sum() == 0:\n        sns.boxplot(application[col], ax = axes_l[axes_count])\n    else:\n        sns.boxplot(application[col].dropna(), ax = axes_l[axes_count])\n    plt.title('Boxplot:'+col)    \n              \n    axes_count += 1\n    col_index = 0\n\n# axes_l\nplt.show()","0e57f4bd":"application[['AMT_GOODS_PRICE', 'AMT_CREDIT']].corr()","0a6b8224":"application[['AMT_GOODS_PRICE', 'AMT_CREDIT']].isnull().sum()","6113b0ba":"plt.scatter(x = application['AMT_GOODS_PRICE'], y = application['AMT_CREDIT'], alpha=0.5)\nplt.show()","4b7a4db6":"application[\"AGE\"] = application[\"DAYS_BIRTH\"].abs()\/365\napplication[\"AGE\"].describe()","68a0aea8":"#Plotting age distribution\nfig, ax = plt.subplots()\nsns.distplot(application[\"AGE\"], color = 'blue', bins=20, kde=False, norm_hist=False)\nplt.show()","d7c7e287":"sns.kdeplot(application[application[\"TARGET\"]==1][\"AGE\"], color = 'blue', label = 'target == 1')\nsns.kdeplot(application[application[\"TARGET\"]==0][\"AGE\"], color = 'red', label = 'target == 0')\nplt.xlabel('Age')\nplt.ylabel('Density')\nplt.plot()","63c57812":"days_cols = []\ndays_cols = [col for col in application.columns if col.find(\"DAYS\")!=-1]\napplication[days_cols].describe()","37411a04":"application[application[\"DAYS_EMPLOYED\"] > 0][\"DAYS_EMPLOYED\"].shape","bc38c23c":"#Creating the binary column and setting the value = 1 wherevr the value of days_employed will be 365243\napplication[\"DAYS_EMPLOYED_ANOMALY\"] = 0\nanomalous_indices = application[application[\"DAYS_EMPLOYED\"] > 0][\"DAYS_EMPLOYED\"].index\napplication.loc[anomalous_indices, \"DAYS_EMPLOYED_ANOMALY\"] = 1\n#Replacing anomalies with 0\napplication[\"DAYS_EMPLOYED\"].replace(365243, 0, inplace=True)\napplication[[\"DAYS_EMPLOYED\", \"DAYS_EMPLOYED_ANOMALY\"]][:15]","41f8e2c1":"application[[\"EXT_SOURCE_1\", \"EXT_SOURCE_2\", \"EXT_SOURCE_3\"]].describe()","413d1d69":"#The code below was obtained from the kaggle kernel mentioned above\n#The code can also be implemented in a way similar to what was described in AMT columns\n\nplt.figure(figsize = (12, 12))\n# iterate through the new features\nfor i, feature in enumerate(['EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3']):\n    \n    # create a new subplot for each source\n    plt.subplot(3, 1, i + 1)\n    # plot repaid loans\n    sns.kdeplot(application.loc[application['TARGET'] == 0, feature], label = 'target == 0')\n    # plot loans that were not repaid\n    sns.kdeplot(application.loc[application['TARGET'] == 1, feature], label = 'target == 1')\n    \n    # Label the plots\n    plt.title('Distribution of %s by Target Value' % feature)\n    plt.xlabel('%s' % feature); plt.ylabel('Density');\n    \nplt.tight_layout(h_pad = 2.5)","71b303f8":"print(\"The following numbers are indicative of missing values in %\")\napplication[[\"EXT_SOURCE_1\", \"EXT_SOURCE_2\", \"EXT_SOURCE_3\"]].isnull().sum()\/application.shape[0] * 100","fd8f778d":"#One line of code to plot bar plot\napplication[\"CODE_GENDER\"].value_counts().plot.bar()","24ff4cd6":"gen_typ = application[\"CODE_GENDER\"].value_counts()\ngen_typ_vals = gen_typ.values\ngen_typ_idx =  gen_typ.index.tolist()\nprint(gen_typ_vals, gen_typ_idx)\nplt.bar(gen_typ_idx, gen_typ_vals)","742ebf8b":"repay = []\ndefault = []\ngender = application[\"CODE_GENDER\"].unique()\nfor g in gender:\n    default.append(application[(application[\"CODE_GENDER\"]==g) & (application[\"TARGET\"]==1)].shape[0]\/application[(application[\"CODE_GENDER\"]==g)].shape[0] * 100)\n    repay.append(application[(application[\"CODE_GENDER\"]==g) & (application[\"TARGET\"]==0)].shape[0]\/application[(application[\"CODE_GENDER\"]==g)].shape[0] * 100)\n\nfig, ax = plt.subplots(figsize=(10,5))\npos = list(range(len(gender)))\nwidth = 0.33\nplt.bar(pos, repay, width, color='g')\nplt.bar([p+width for p in pos], default, width, color='r')\nplt.legend([\"Repay\", \"Default\"])\n\n#X-axis manipulations\nax.set_xticks([p+0.5*width for p in pos])\nax.set_xticklabels(list(gender))\nax.set_xlabel('Gender')\n\n#Y-axis manipulations\nvals = ax.get_yticks()\nax.set_yticklabels(['{:,.2%}'.format(x\/100) for x in vals])\nax.set_ylabel('% of repaid\/defaulted loans')\n\nplt.show()","186e52ab":"repay = []\ndefault = []\ngender = application[\"CODE_GENDER\"].unique()\nfor g in gender:\n    default.append(application[(application[\"CODE_GENDER\"]==g) & (application[\"TARGET\"]==1)].shape[0]\/application[(application[\"CODE_GENDER\"]==g)].shape[0] * 100)\n    repay.append(application[(application[\"CODE_GENDER\"]==g) & (application[\"TARGET\"]==0)].shape[0]\/application[(application[\"CODE_GENDER\"]==g)].shape[0] * 100)\n\nfig, ax = plt.subplots(figsize=(10,5))\npos = list(range(len(gender)))\nwidth = 0.5\nplt.bar(pos, repay, width=width, color='g', label='Repay')\nplt.bar(pos, default, width=width, bottom=repay, color='r', label='Default')\nplt.legend([\"Repay\", \"Default\"])\n\nax.set_xticks([p for p in pos])\nax.set_xticklabels(list(gender))\nax.set_xlabel('Gender')\n\nvals = ax.get_yticks()\nax.set_yticklabels(['{:,.2%}'.format(x\/100) for x in vals])\nplt.show()","75ef1cf6":"repay = []\ndefault = []\ninc_typ = application[\"NAME_INCOME_TYPE\"].unique()\nfor g in inc_typ:\n    default.append(application[(application[\"NAME_INCOME_TYPE\"]==g) & (application[\"TARGET\"]==1)].shape[0]\/application[(application[\"NAME_INCOME_TYPE\"]==g)].shape[0] * 100)\n    repay.append(application[(application[\"NAME_INCOME_TYPE\"]==g) & (application[\"TARGET\"]==0)].shape[0]\/application[(application[\"NAME_INCOME_TYPE\"]==g)].shape[0] * 100)\n    \nfig,ax = plt.subplots(figsize=(15,5))\nwidth = 0.7\npos = list(range(len(repay)))\nplt.bar(pos, repay, width=width, color='g')\nplt.bar(pos, default, width=width, bottom=repay, color='r', label='Default')\nax.set_xticks([p for p in pos])\nax.set_xticklabels(inc_typ)\nplt.show()","d8e60fbd":"fig,ax = plt.subplots(figsize=(15,5))\ninc_type = application[\"NAME_INCOME_TYPE\"].value_counts()\ninc_type.plot.bar(color='b')","e492d63d":"inc_type","f677fd0e":" We will create a binary column where 1 will indicate anomalous data and 0 otherwise. We will also replace anomalous data with 0","357bc68e":"# Objective of the notebook\nThis notebook is meant for EDA of Application Dataset. We will be exploring different kinds of  numeric and categorical variables and also be plotting them. We will make use of Matplotlib and Seaborn library for plotting. \n\nThe secondary objective of the notebook is also to help us understand the different plotting functions of Matplotlib and Seaborn libraries. Generally a good idea of proceeding with the analysis is to find correlation of independent variables with the target variable and then explore some of the highly(both positive and negative) correlated variables. But as the purpose of the notebook is also to experiment with plotting libraries we will explore columns even if they don't have a high correlation.\n\nI would like to thank the brilliant kernels that are uploaded on Kaggle which inspired me to find new ways to explore data and create different kinds of graphs. \n\nThis is undoutedly the best kernel I found so far which inspired a lot of ideas and graphs in this jupyter notebook: https:\/\/www.kaggle.com\/willkoehrsen\/start-here-a-gentle-introduction","8e407824":"Normal bar chart will allow us to look at the count( or proportion) of each gender","55353438":"Finding: Men seem to have a higher proportion of default % but also men have double the applications as compared to women","ce1639f0":"# 4. Exploring AMT columns\n1. We will start by having a look at the summary statistics (there are 4 columns in total)\n2. We will plot the distribution along with its boxplot. As for implementation details we will go through how we can dynamically plot multiple subplots","8824a00c":"All the days are negative as time is considered relative to the date of application. However, we observe that Days_employed has maximum value of 365243. According to the business, this value represents Nulls. So we will first look at how many nulls are present and then impute the nulls and create a binary flag column which states whether the value of DAYS_EMPLOYED is null or not.","e5ecd37d":" Let's initially plot a distribution along with its boxplot using Seaborn","566696f4":"## 1. Is the dataset imbalanced?\nFor problems involving repayment of loans, credit etc. it is highly possible that the dataset is imbalanced","3e385bb7":"It might be a good idea to start exploration with 'DAYS_BIRTH' and 'EXT_SOURCE_3' as they are highly correlated with the target variable","5b02dccb":"ii) Missing values check","a6cee739":"Grouped bar chart (Helps us in knowing what proportion of each gender repaid or defaulted the loan)","86b7d254":"# 8. Age variable","da3b88e0":"# 2. Correlation of independent variables with target variables\nLet's list the top 10 postively and negatively correlated variables","50170ed4":"Looking at the count of rows for each category, it becomes clear that there are very few records for 'Unemployed' and 'Maternity leave' and it would have been disastrous jumping to conclusions based on the stacked bar chart alone.","ca967156":"Max and min shows that the values of this variable all lie within the range of 20 to 70. Thus it looks like this column has clean data","96e584a8":"There is a very high correlation between these 2 columns. So we will be imputing the missing values of AMT_GOODS_PRICE by AMT_CREDIT by taking a factor of avg( AMT_CREDIT)\/avg( AMT_GOODS_PRICE) * AMT_CREDIT","85f7ea80":"# 10. Learnings\nWhile there are a number of other variables that can be explored, we nonetheless have a vast list of learnings from the above exploration:\n\nLet's divide the learning section into two parts: 1. Data exploration and processing 2. Python visualization\n\n**Data Exploration and Processing**\n1. Correlation: Serves as a good starting point for analysis\n2. Missing value treatment:\n    *  Dropping columns: Here we dropped columns that had a very high proportion of missing values and had low correlation with target variable. This may not be always be a good idea\n    * Imputation by common methods: Mean and Median for continuous variables and Mode for categorical variables\n    * Imputation (other techniques): Here in one case we found that there exists a high correlation between two variables and based on that, imputation was carried out. Similarly business or domain knowledge can also be applied to impute certain columns. This process is time-consuming but can be effective\n    * Leave as it is: Certain algorithms like Gradient Boosting are not affected by missing values so it is not necessary to treat them\n3. Data consistency: Summary statistics(describe() in pandas) of the columns can be a way to QC the data\n    * Helps in identifying ouliers present in the data\n    * We looked at a way of how to create a binary column for anomalous data\n\nSome points that are a part of pre-processing but were not covered here\n1. Log transformation of Skewed variables for linear modeling\n2. Outlier treatment: Some commonly known techniques \n    * Univariate detection: Z-score, IQR      \n    * Multivariate detection: Mahalanobis distance, Cook's distance(mostly for linear regression)\n3. One hot encoding for categorical variables\n\n\n**Python Visualization**\n1. Bar graph\n2. Stacked and grouped bar chart\n3. Histogram\n4. Density plots\n5. Scatterplots","820e6aef":"With this we draw an end to analysis of continuous variables and this by no means is an exhaustive EDA as there are 100's of continuous variables in the entire dataset. But there is one interesting question that arises after looking at the KDE (or distribution) plots. How come the y-axis of these plots have values greater than 1? Here are some links on the same topic:\n* https:\/\/en.wikipedia.org\/wiki\/Kernel_density_estimation\n* https:\/\/stackoverflow.com\/questions\/32274865\/seaborn-distplot-y-axis-normalisation-wrong-ticklabels\n* https:\/\/stats.stackexchange.com\/questions\/138484\/displaying-frequency-when-using-kernel-density-estimation\n* https:\/\/towardsdatascience.com\/histograms-and-density-plots-in-python-f6bda88f5ac0","d7afe883":"# It's time for categorical variables now!!\nWhen it comes to visualizing categorical variables, bar charts are one of the most common and popular visualziation technique. It's pretty effective as well. Here we will explore Gender and NAME_INCOME_TYPE variables. <br>\nWe will look at how to plot the following variations of bar chart using matplotlib: \n    1. Normal bar chart (Both horizontal and vertical)\n    2. Group bar chart \n    3. Stacked bar chart ","7979fbda":"While it's not surprising to see unemployed with a higher default rate compared to others but what's baffling is that maternity leave category has the highest proportion of default %. <br>\nBefore jumping to conclusions we should make sure what is the count(rows) of each of these categories in the column","09c4bff4":"As we don't have much information as how to ext_source_data is derived and with a lot of missing values present, our only guess of imputing the missing values is by median","06ca5670":"# 6. Looking at Days_ columns","3a4f6f1e":"There is a clear distinction between distributions for target =0 and target = 1 for EXT_SOURCE_1 and EXT_SOURCE_3. Lower values of ext_source columns indicate a high default chance and higher values of these columns represent a lower default chance","78853acc":"Clearly we can see that the dataset is imbalanced. An approach to final modeling can involve using stratified k fold cross validation and hopefully the model will be capable of identifying the default loans in a better way","3d90c8aa":"i) Plotting the distributions for target = 1 and target = 0","d40c6bda":"# 5. Inspecting age variable\n1. Describe function (summary statistics) will help us in QC'ing the column. We can get to know if there any outliers\n2. Then we will plot the distribution when target = 0 and target = 1 and see if age plays any role in defaulting a loan","a675d194":"# 7. Investigating EXTSOURCE columns\nThe information comes from external sources and is normalized between 0 - 1. We don't have much information as to how it is derived. The EXTSOURCE3 is highly correlated to our target variable. We will plot the distributions for these columns which will be similar to Age distribution and we will also have a look at the missing values present in these columns.","bfe7071a":"# 9. Exploring NAME_INCOME_TYPE variable (Perils of blindly trusting graphs)\nThe visualizations will be very similar to what we did with the GENDER variable but we will look at how certain graphs can be misleading ","ae2b36d9":"More than 50% of the columns having missing values. While algorithms like Gradient boosting does not make it necessary to impute missing values we can still see which columns have high proportion of missing values","7d6591dc":"* Most of the distributions are right skewed. If one wants to proceed with linear modeling then they might as well think about Log transforming the variables\n* AMT_GOODS_PRICE and AMT_CREDIT seem to have similar distribution which is also confirmed by summary statistics. Let's look at the correlation between the 2 columns and also plot a scatterplot\n ","cb4fe821":"Let's just check if any of the two variables have missing values","287f0345":"To see if age is influencing loan default or not we will plot the density plots with target = 0 and target = 1 and hopefully it will give us some clarity","6d6d9ee5":"Columns with a lot of missing values is quite high. Now removing all the columns is not possible. So here we can adopt a 2 step approach<br>\n1) Find correlation with target variable and drop those columns which have  absolute correlation lower than 0.02<br>\n2) For the remaining variables, imputation can be done by median for numerical variables and mode for categorical variables","9986fa13":"# 3. Columns with missing values","f44eb380":"\nIt is evident that age is influencing the default rate as younger people have a higher tendency of default. ","59b995cb":"Stacked percentage bar chart","47b0a5a3":"The distribution looks right skewed which makes sense as not many people would be taking a very high amount loan. The next thing we are going to do is to plot multiple plots by using GridSpec. "}}