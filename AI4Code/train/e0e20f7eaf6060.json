{"cell_type":{"e4e0a6df":"code","446056a0":"code","3bbe0036":"code","f1dbc815":"code","ead853e8":"code","92365c82":"code","3ee6605b":"code","e4816c57":"code","747531af":"code","9aed8abf":"code","e8f64e76":"code","bbda5aa8":"code","0c25e13d":"markdown","20009689":"markdown","db55b58b":"markdown","c0023164":"markdown","9de9e488":"markdown","bcc603e5":"markdown","75e57a0a":"markdown","2b7e2a09":"markdown","e7b1ea08":"markdown"},"source":{"e4e0a6df":"import os\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nfrom keras.layers import Input, Dense, Bidirectional, Dropout\nfrom keras.layers.recurrent import LSTM\nfrom keras.models import Model\nfrom keras.callbacks import EarlyStopping\n\nimport numpy as np","446056a0":"os.listdir(\"..\/input\/\")","3bbe0036":"coin_dataframes = {}\n\ndef convert_comma_int(field):\n    try:\n        return int(field.replace(',', ''))\n    except ValueError:\n        return None\n    \nfor fn in os.listdir(\"..\/input\/\"):\n    if \"bitcoin_cache\" in fn:\n        continue\n    if fn.endswith(\"_price.csv\"):\n        coin_name = fn.split(\"_\")[0]\n        df = pd.read_csv(os.path.join(\"..\/input\/\", fn), parse_dates=[\"Date\"])\n        df['Market Cap'] = df['Market Cap'].map(convert_comma_int)\n        coin_dataframes[coin_name] = df.sort_values('Date')","f1dbc815":"coin_dataframes.keys()","ead853e8":"coin_dataframes['nem'].head()","92365c82":"# import plotly.plotly as py\n# import plotly.graph_objs as go\n\n# from datetime import datetime\n# # import pandas_datareader.data as web\n\n# data = [go.Scatter(x=coin_dataframes['bitcoin'].Date, y=coin_dataframes['bitcoin'].Date)]\n\n# py.iplot(data)\n\nplt.figure(figsize=(20,8))\ncoin_dataframes['bitcoin'].plot(x='Date', y='Close')\nplt.show()","3ee6605b":"def add_relative_columns(df):\n    day_diff = df['Close'] - df['Open']\n    df['rel_close'] = day_diff \/ df['Open']\n    df['high_low_ratio'] = df['High'] \/ df['Low']\n    df['rel_high'] = df['High'] \/ df['Close']\n    df['rel_low'] = df['Low'] \/ df['Close']\n    \n    \nfor df in coin_dataframes.values():\n    add_relative_columns(df)\n    \ncoin_dataframes[\"nem\"].head()","e4816c57":"def create_history_frames(coin_dataframes):\n    history_frames = {}\n    for coin_name, df in coin_dataframes.items():\n        history_frames[coin_name], x_cols = create_history_frame(df)\n    return history_frames, x_cols\n        \n\ndef create_history_frame(df):\n    feature_cols = ['rel_close', 'rel_high', 'rel_low', 'high_low_ratio']\n    y_col = ['rel_close']\n    x_cols = []\n    days = 10\n    history = df[['Date'] + y_col].copy()\n    for n in range(1, days+1):\n        for feat_col in feature_cols:\n            colname = '{}_{}'.format(feat_col, n)\n            history[colname] = df[feat_col].shift(n)\n            x_cols.append(colname)\n    history = history[days:]\n    return history, x_cols\n\ny_col = 'rel_close'\ncoin_history, x_cols = create_history_frames(coin_dataframes)","747531af":"def create_model():\n    input_layer = Input(batch_shape=(None, len(x_cols), 1))\n    layer = Bidirectional(LSTM(128, return_sequences=True))(input_layer)\n    layer = Bidirectional(LSTM(128))(layer)\n    out = Dense(1, activation=\"sigmoid\")(layer)\n    m = Model(inputs=input_layer, outputs=out)\n    m.compile(\"rmsprop\", loss='mean_squared_error')\n    return m\n\ndef create_train_test_mtx(history):\n    X = history[x_cols].as_matrix()\n    y = history[y_col].as_matrix()\n    X = X.reshape(X.shape[0], X.shape[1], 1)\n    rand_mtx = np.random.permutation(X.shape[0])\n    train_split = int(X.shape[0] * 0.9)\n    train_indices = rand_mtx[:train_split]\n    test_indices = rand_mtx[train_split:]\n\n    X_train = X[train_indices]\n    X_test = X[test_indices]\n    y_train = y[train_indices]\n    y_test = y[test_indices]\n    \n    return X_train, X_test, y_train, y_test\n\ndef train_model(model, X, y):\n    ea = EarlyStopping(monitor='val_loss', patience=2)\n    val_loss = model.fit(X, y, epochs=500, batch_size=64, callbacks=[ea], verbose=1, validation_split=.1)\n    return val_loss","9aed8abf":"rmse = {}\npred = {}\ntest = {}\n\nfor coin_name, history in coin_history.items():\n    model = create_model()\n    X_train, X_test, y_train, y_test = create_train_test_mtx(history)\n    train_model(model, X_train, y_train)\n    test[coin_name] = y_test\n    \n    # run prediction on test set\n    pred[coin_name] = model.predict(X_test)\n    # compute test loss\n    rmse[coin_name] = np.sqrt(np.mean((pred[coin_name] - y_test)**2))\n    print(coin_name, rmse[coin_name])","e8f64e76":"pred_sign = {coin_name: np.sign(pred[coin_name]) * np.sign(test[coin_name]) for coin_name in pred.keys()}\nfor coin, val in sorted(pred_sign.items()):\n    cnt = np.unique(pred_sign[coin], return_counts=True)[1]\n    print(\"[{}] pos\/neg change guessed correctly: {}, incorrectly: {}, correct%: {}\".format(\n        coin, cnt[0], cnt[1], cnt[0]\/ (cnt[0]+cnt[1]) * 100))","bbda5aa8":"pred_sign = {coin_name: np.sign(pred[coin_name]) for coin_name in pred.keys()}\nfor coin, val in sorted(pred_sign.items()):\n    e, cnt = np.unique(val, return_counts=True)\n    print(\"[{}] guesses: {}\".format(coin, dict(zip(e, cnt))))","0c25e13d":"## Bitcoin value growth\n\nJust for fun.","20009689":"# Compute relative growth and other relative values\n\nWe add these values as new columns to the dataframes:","db55b58b":"## Train a model for each currency\n\nWe save RMSE as well as the predictions on each test set.","c0023164":"# Load data\n\nWe load each currency into a separate dataframe and store the dataframes in a dictionary.","9de9e488":"Each dataframe looks like this:","bcc603e5":"## Did we guess anything useful at all?","75e57a0a":"## Create historical training data\n\nThe history tables will have values for the last 10 days for each day.","2b7e2a09":"## Do our models predict the signum of the value change correctly?","e7b1ea08":"# Define model\n\nWe will train a separate model for each currency. The models' architecture  identical."}}