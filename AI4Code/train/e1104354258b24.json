{"cell_type":{"f0e68c61":"code","0bb136a2":"code","aab12ef6":"markdown"},"source":{"f0e68c61":"########################################################################\n#### Python code computing quasiperiodic Majoranas\n#### 2021\/9\/25 By Yang Peng (yang.peng@csun.edu)\n########################################################################\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\nimport numpy as np\n# %matplotlib widget\nfrom matplotlib import path\nimport time\n# import ipywidgets as widgets\nfrom joblib import Parallel, delayed\nfrom scipy import linalg\nfrom scipy.sparse.linalg import eigsh\nimport multiprocessing\nimport matplotlib as mpl\nfrom numba import jit\n# mpl.use('Agg')\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import ImageGrid\nfrom mpl_toolkits.mplot3d.axes3d import Axes3D\nfrom matplotlib.ticker import LinearLocator, FormatStrFormatter\nnum_cores = multiprocessing.cpu_count() #import matplotlib.pyplot as plt\n%config Completer.use_jedi = False\nplt.rcParams.update({'font.size':16})","0bb136a2":"def main(omega1,omega2,target_energy,nmax):\n    ##############################################\n    ## Define parameters\n    NF1_cutoff = 3  ## Frequency sector # cutoff\n    NF2_cutoff = 3\n    NL = 50 ## Length of the chain\n    Nk = 50 ## number of K points\n    Ndim_k = 2*(2*NF1_cutoff+1)*(2*NF2_cutoff+1)\n    mu = 0.87\n    J = 0.51\n    Delta = 0\n    Delta1 = 0.1\n    Delta2 = 0.1\n    Delta12 = 0.1\n\n    ##############################################\n    ## Define matrices\n    global sigma_x,sigma_y,sigma_z,sigma_0, sigma_p,sigma_m,identity_F_double, freq_mat_double, freq_coup_p_1, freq_coup_p_2, freq_coup_m_1, freq_coup_m_2, identity_L, L_coup_p,  L_coup_m\n    sigma_x = np.array([[0,1],[1,0]])\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    sigma_z = np.array([[1,0],[0,-1]])\n    sigma_0 = np.eye(2)\n    sigma_p = np.array([[0,1],[0,0]])\n    sigma_m = np.array([[0,0],[1,0]])\n    identity_F1 = np.eye(2*NF1_cutoff+1)\n    identity_F2 = np.eye(2*NF2_cutoff+1)\n    identity_L = np.eye(NL)\n    freq1_mat = -np.diag(np.arange(-NF1_cutoff,NF1_cutoff+1))\n    freq2_mat = -np.diag(np.arange(-NF2_cutoff,NF2_cutoff+1))\n    freq1_coup_p = np.diag(np.ones(2*NF1_cutoff),1)\n    freq2_coup_p = np.diag(np.ones(2*NF2_cutoff),1)\n    L_coup_p = np.diag(np.ones(NL-1),1)\n    L_coup_m = L_coup_p.T\n    identity_F_double = np.kron(identity_F1,identity_F2)\n    freq_mat_double = np.kron(freq1_mat*omega1,identity_F2) + np.kron(identity_F1,freq2_mat*omega2)\n    freq_coup_p_1 = np.kron(freq1_coup_p,identity_F2)\n    freq_coup_m_1 = freq_coup_p_1.T\n    freq_coup_p_2 = np.kron(identity_F1,freq2_coup_p)\n    freq_coup_m_2 = freq_coup_p_2.T\n    freq_coup_p_12 = np.kron(freq1_coup_p,freq2_coup_p)\n    freq_coup_m_12 = freq_coup_p_12.T\n    \n    ##############################################\n    ## Constructing basic matrices\n    #################################\n    h0 = h0_onsite(mu)\n    V0 = V0_static(J,Delta)\n    Vp1 = V_drive_p(Delta1)\n    Vm1 = V_drive_m(Delta1)\n    Vp2 = V_drive_p(Delta2)\n    Vm2 = V_drive_m(Delta2)\n    Vp12 = V_drive_p(Delta12)\n    Vm12 = V_drive_m(Delta12)\n    \n    def real_space_ham(NL):\n        hstatic = np.kron(L_coup_p,V0)+np.kron(L_coup_m,V0.conj().T) + np.kron(identity_L,h0)\n        K = np.kron(freq_coup_p_1,np.kron(L_coup_p,Vp1)) + np.kron(freq_coup_m_1,np.kron(L_coup_p,Vm1))\n        K += np.kron(freq_coup_p_2,np.kron(L_coup_p,Vp2)) + np.kron(freq_coup_m_2,np.kron(L_coup_p,Vm2))\n        K += np.kron(freq_coup_p_12,np.kron(L_coup_p,Vp12)) + np.kron(freq_coup_m_12,np.kron(L_coup_p,Vm12))\n        K += K.conj().T\n        K += np.kron(identity_F_double, hstatic) + np.kron(freq_mat_double,np.kron(identity_L,sigma_0))\n        return K\n    \n    def unpack_WF(psi):\n        return psi.reshape([2*NF1_cutoff+1,2*NF2_cutoff+1,NL,2],order='C')\n    \n    def real_space_probaility(psi):\n        return np.sum(np.abs(psi)**2,axis=(0,1))\n    \n    def synthetic_space_probability(psi):\n        return np.sum(np.abs(psi)**2,axis=(2,3))\n    \n    def generate_synthetic_lattice(prob_synth):\n        n1 = np.arange(-NF1_cutoff,NF1_cutoff+1)\n        n2 = np.arange(-NF2_cutoff,NF2_cutoff+1)\n        NN2,NN1 = np.meshgrid(n2,n1)\n        N1_flatten = NN1.flatten()\n        N2_flatten = NN2.flatten()\n        fig,ax = plt.subplots()\n        ax.scatter(N1_flatten,N2_flatten,edgecolors='k',s=500,c=prob_synth.flatten(),cmap=plt.cm.gist_yarg)\n        ax.set_aspect(1)\n        ax.set_xlabel(r'$n_1$')\n        ax.set_ylabel(r'$n_2$')\n        ax.set_title('Probability in synthetic lattice')\n        return fig,ax\n    \n    def plot_prob_real_space(prob):\n        fig,ax = plt.subplots()\n        ax.plot(np.arange(NL),prob[:,0],'r-',label=r'$|\\psi_e|^2$')\n        ax.plot(np.arange(NL),prob[:,1],'b--',label=r'$|\\psi_h|^2$')\n        ax.legend()\n        ax.set_xlabel('Site Index')\n        ax.set_ylabel('Probability')\n        ax.set_title('Probability in real space')\n        return fig,ax\n    \n    def Bloch_Ham(k):\n        hstatic = V0*np.exp(1j*k) + V0.conj().T*np.exp(-1j*k) + h0    \n        K = np.kron(freq_coup_p_1,Vp1*np.exp(1j*k)) + np.kron(freq_coup_m_1,Vm1*np.exp(1j*k))\n        K += np.kron(freq_coup_p_2,Vp2*np.exp(1j*k)) + np.kron(freq_coup_m_2,Vm2*np.exp(1j*k))\n        K += np.kron(freq_coup_p_12,Vp12*np.exp(1j*k)) + np.kron(freq_coup_m_12,Vm12*np.exp(1j*k))\n        K += K.conj().T\n        K += np.kron(identity_F_double,hstatic)+np.kron(freq_mat_double,sigma_0)\n        return K\n    \n    def bands(Nk):\n        klist = np.linspace(-np.pi,np.pi,Nk+1)\n        klist = klist[0:-1]\n        EElist = np.zeros([Nk,Ndim_k])\n        for jj in range(Nk):\n            EElist[jj,:] = linalg.eigvalsh(Bloch_Ham(klist[jj]))\n        return klist, EElist\n    \n    def plot_probabilities(EV_state):\n        psi = unpack_WF(EV_state)\n        prob = real_space_probaility(psi)\n        prob_synth = synthetic_space_probability(psi)\n        fig1,ax1 = plot_prob_real_space(prob)\n        fig2,ax2 =generate_synthetic_lattice(prob_synth)\n        return fig1,ax1,fig2,ax2\n#     #####################################################\n#     ## PBC calculation\n#     klist,EElist = bands(Nk)\n#     fig,ax = plot_bands(klist,EElist)\n# #     return fig,ax\n#     #####################################################\n#     ## OBC calculation\n#     Ham_obc = real_space_ham(NL)\n#     EE_obc,EV_obc = linalg.eigh(Ham_obc)\n#     fig_obc,ax_obc = plot_spectrum(EE_obc)\n    #####################################################\n    ## Find nmax eigenstates close to a given target energy\n    Ham_obc = real_space_ham(NL)\n    EE_obc,EV_obc = eigsh(Ham_obc,k=nmax,sigma=target_energy)\n    zeroidx=np.argsort(abs(EE_obc-target_energy))\n    EE_obc = EE_obc[zeroidx]\n    EV_obc = EV_obc[:,zeroidx]\n    for nn in range(nmax):\n        plot_probabilities(EV_obc[:,nn])\n\n\ndef plot_spectrum(EElist):\n    len_EE = EElist.shape[0]\n    fig,ax = plt.subplots()\n    ax.plot(np.ones([len_EE,1]),EElist,'b.')\n    ax.set_title('Spectrum with OBC')\n    ax.set_ylabel(r'$E$')\n    ax.set_ylim([-2,2])\n    ax.tick_params(labelbottom = False, bottom = False)\n    return fig,ax\n\ndef plot_bands(klist,EElist):\n    numofk = klist.shape[0]\n    fig,ax = plt.subplots()\n    ax.plot(klist\/np.pi,EElist,'k.')\n    ax.set_title('Floquet Bands')\n    ax.set_ylabel(r'$E$')\n    ax.set_xlabel(r'$ka\/\\pi$')\n    ax.set_ylim([-3,3])\n    return fig,ax\n\ndef h0_onsite(mu):\n    return -mu*sigma_z\ndef V0_static(J,Delta):\n    return -J*sigma_z - 1j*Delta*sigma_x\ndef V_drive_p(Deltaj):\n    return -1j*Deltaj*sigma_p\ndef V_drive_m(Deltaj):\n    return -1j*Deltaj*sigma_m\n\n##########################################################################\n#### Run main function ###################################################\nif __name__ == \"__main__\":\n    omega1 = 6\n    omega2 = -2*np.sqrt(5) \n    ## Find nmax eigenstates close to a given target energy\n    target_energy = (omega1+omega2)\/2\n    nmax=1\n    main(omega1,omega2,target_energy,nmax)\n","aab12ef6":"# Majorana Multiplexing\nWe consider a quasiperiodically driven Kitaev chain. The static part of the Hamiltonian is\n$$\nH_{K} = -\\mu\\sum_{j=1}^N c_{j}^\\dagger c_{j} -\\sum_{j=1}^{N-1}[(Jc_{j}^\\dagger c_{j+1} + i\\Delta c_{j} c_{j+1}) + h.c.].\n$$\nThe time-dependent pairing is\n$$\nM(\\omega t) = -i\\Delta' \\sum_{j=1}^{N-1}( e^{-i\\omega t} c_{j} c_{j+1} - e^{i\\omega t}c_{j+1}^\\dagger c_{j}^\\dagger).\n$$\nThe total Hamiltonian we considered is\n$$\nH(t) = H_{K} + M(\\omega_1 t) + M(\\omega_2 t) + M((\\omega_1+\\omega_2)t).\n$$\nWhen $|\\omega_{1,2}|$ are large, and $|\\omega_1 + \\omega_2|$ is small, you can see the Majorana at $(\\omega_1 + \\omega_2)\/2$, embedded in the dense spectrum. It is localized a long the chain at the ends, it is also localized in the synthetic space. In the code below, and the figures generated from it. "}}