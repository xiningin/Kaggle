{"cell_type":{"4087f939":"code","c9fcb01e":"code","36a117e8":"code","853fb7d7":"code","e137530e":"code","1cdc7299":"code","22ff67e5":"code","c9c500ae":"code","e311a235":"code","10c1b076":"code","fd5576de":"code","0307b2ec":"code","82ce2b0b":"code","be4844ab":"code","abd5bfc2":"code","147f9bee":"code","7a8051d2":"code","867ca934":"markdown","0f9658e2":"markdown","a19c065e":"markdown","ae4603c5":"markdown","38fc686e":"markdown","ea76030c":"markdown","6da53b16":"markdown","083e6956":"markdown","504451bd":"markdown","d2ec51a3":"markdown","98baed34":"markdown","927f73b0":"markdown","ebd23778":"markdown","0af68c0d":"markdown","af07ddc1":"markdown","218dc940":"markdown","cdfd2a5f":"markdown","d71c9331":"markdown","fa285c67":"markdown","162211c4":"markdown","7f48a318":"markdown","30669495":"markdown"},"source":{"4087f939":"import numpy as np \nimport pandas as pd \nimport re \n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nimport ipywidgets as widgets\nfrom IPython.display import display, clear_output\nfrom ipywidgets import Output, Button, interact\n\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\ninit_notebook_mode(connected=True) \n!jupyter nbextension enable --py --sys-prefix widgetsnbextension","c9fcb01e":"all_data_2018 = pd.read_csv(\"..\/input\/kaggle-survey-2018\/multipleChoiceResponses.csv\", low_memory=False)\nall_data_2019 = pd.read_csv('..\/input\/kaggle-survey-2019\/multiple_choice_responses.csv', low_memory=False)\nall_data_2020 = pd.read_csv('..\/input\/kaggle-survey-2020\/kaggle_survey_2020_responses.csv', low_memory=False)\nall_data_2021 = pd.read_csv('..\/input\/kaggle-survey-2021\/kaggle_survey_2021_responses.csv', low_memory=False)\n\n\ndef df_cleaner(_data):\n\n    old_cols = list(_data.columns)\n    new_cols = _data.iloc[0]\n    updated_cols = []\n\n    for a, b in zip(old_cols, new_cols):\n        _new_col = str(a) + \" \" + str(b)\n        updated_cols.append(_new_col)\n\n    _data.columns = updated_cols\n    _data = _data[1:].copy()\n    _data.reset_index(drop=True, inplace=True)\n\n    # Columns are very wordy, let's clean some of that\n\n    _data.columns = _data.columns.str.replace(' - Selected Choice', '', regex=True)\n    _data.columns = _data.columns.str.replace('(Select all that apply)', '', regex=True)\n    _data.columns = _data.columns.str.replace('() -', '', regex=True)\n    _data.rename(columns=lambda x: re.sub(' +', ' ', x), inplace=True)\n    _data.rename(columns={\"Time from Start to Finish (seconds) Duration (in seconds)\" : \"Duration (seconds)\", \n                    \"Q1 What is your age (# years)?\" : \"Age\", \"Q2 What is your gender?\" : \"Gender\", \"Q3 In which country do you currently reside?\" : \"Country\",\n                    'Q4 What is the highest level of formal education that you have attained or plan to attain within the next 2 years?' : \"Degree\",\n                    'Q5 Select the title most similar to your current role (or most recent title if retired):' : \"Title\"},\n                    inplace=True)\n    _data.columns = _data.columns.str.strip()\n\n    _outliers_index = [_index for _index, _value in _data['Duration (seconds)'].iteritems() if int(_value) > 14400]\n\n    print(f\"{len(_outliers_index)} lines will be removed from the dataset out of {_data.shape[0]}\")\n\n    _data = _data.drop(_outliers_index, axis=0)\n\n    return _data","36a117e8":"_values = [all_data_2021[\"Time from Start to Finish (seconds)\"][1:].astype('int')]\n\nprint(f\"\"\"\nDuration (seconds) infos :\n\nMean : {int(sum(_values).mean())}     \nMedian :  {int(sum(_values).median())}\nMin value :  {int(sum(_values).min())}\nMax value :  {int(sum(_values).max())}\nStandard deviation : {round(np.std(_values), ndigits=2)}\n\"\"\")\n\n","853fb7d7":"df_2021 = df_cleaner(all_data_2021.copy())","e137530e":"fig = make_subplots(rows=1, cols=2, specs=[[{\"type\": \"box\"}, {\"type\": \"box\"}]])\n\nfig.add_trace(go.Box(y=all_data_2021[\"Time from Start to Finish (seconds)\"][1:].astype(\"int\"), name=\"\"), row=1, col=1)\nfig.add_trace(go.Box(y=df_2021['Duration (seconds)'].astype(\"int\"), name=\"\"), row=1, col=2)\n\nfig.update_xaxes(title_text=\"1. Original dataset\", row=1, col=1)\nfig.update_xaxes(title_text=\"2. Some outliers removed\", row=1, col=2)\n\nfig.update_traces(hovertemplate=\"<extra><\/extra>\", row=1, col=1)\n\nfig.update_layout(height=600, width=1000, \n            title_text=\"Boxplots of 'Duration (in seconds)' column\", \n            paper_bgcolor=\"darkgray\", \n            title_x=0.5, \n            showlegend=False)\n            \nfig.show()","1cdc7299":"df_2018 = df_cleaner(all_data_2018.copy())\ndf_2019 = df_cleaner(all_data_2019.copy())\ndf_2020 = df_cleaner(all_data_2020.copy())\n\ndf_2018.rename(columns={\"Q1 What is your gender?\" : \"Gender\", \n                        \"Q2 What is your age (# years)?\" : \"Age\",\n                        \"Q6 Select the title most similar to your current role (or most recent title if retired):\" : \"Title\"                        \n                        }, inplace=True)\ndf_2018[\"Gender\"] = df_2018[\"Gender\"].replace({'Male': \"Man\", \"Female\" : \"Woman\"})\ndf_2019[\"Gender\"] = df_2019[\"Gender\"].replace({'Male': \"Man\", \"Female\" : \"Woman\"})","22ff67e5":"fig = go.Figure()\n\n_year = 2018\n\nfor _df, _dff in zip([df_2018, df_2019, df_2020, df_2021], [all_data_2018, all_data_2019, all_data_2020, all_data_2021]):\n\n    _outliers = [_value for _value in _dff[_dff.columns[0]][1:] if int(_value) > 14400]\n\n    fig.add_trace(go.Bar(\n                        x=[_year], \n                        y=[len(_df)], \n                        name=_year, \n                        customdata=[len(_dff)],\n                        hovertemplate=\"<br>\".join([\n                            \"No outliers : %{y}\",\n                            \"Total : %{customdata}\", \n                        ]),\n                        texttemplate=\"%{y}\",\n                        textposition=\"auto\",\n                        marker_color='rgb(55, 83, 109)',  \n                        showlegend=False,\n                        ))\n    fig.add_trace(go.Bar(\n                        x=[_year], \n                        y=[len(_outliers)], \n                        name=_year, \n                        customdata=[len(_outliers)],\n                        hovertemplate=\"<br>\".join([\n                            \"Outliers : %{customdata}\", \n                        ]),\n                        texttemplate=\"<b>%{customdata}<b> outliers\",\n                        textposition=\"inside\",\n                        #marker_color='rgb(55, 83, 109)',  \n                        showlegend=False\n                        ))\n\n    _year += 1\n\nfig.update_layout(\n                paper_bgcolor=\"darkgray\",\n                title=\"<b>2018 - 2021 total survey participants<b><br><sup>Outlier : participant who took over 4 hours to complete the survey\",\n                title_x=0.5,\n                height=700,\n                barmode='stack', \n                xaxis = dict(\n                tickmode = 'linear',\n                tick0 = _year,\n                dtick = 1,\n                title = \"Year\",\n                categoryorder = 'category ascending',\n            ),\n            yaxis = dict( \n                title = \"Participants\",\n                tickformat = \"000\"\n            )\n                    )\n\nfig.show()","c9c500ae":"def historic_graphs(_grouper):\n\n    fig = go.Figure()\n\n    base_df = pd.DataFrame(columns={_grouper})\n    mean_age_df = pd.DataFrame(columns={\"Mean Age\", 2019, 2020, 2021})\n    _year = 2018\n    _total = []\n\n    for _df in [df_2018, df_2019, df_2020, df_2021]:\n        info = round(_df[_grouper].value_counts(normalize=True)*100, ndigits=2)\n        info = pd.DataFrame(info.rename('Percent').reset_index().rename(columns={\"index\" : _grouper}).sort_values(by=_grouper).reset_index(drop=True))\n        temp_df = pd.DataFrame({_grouper : info[_grouper].to_list() , _year : info[\"Percent\"].to_list()})\n        base_df = base_df.merge(temp_df, how=\"right\")\n        _year += 1 \n\n        if _grouper == \"Degree\":          \n            \n            for _age in _df[\"Age\"]:\n                if \"70+\" in _age:\n                    _total.append(70)\n                elif \"80+\" in _age:\n                    _total.append(80)                 \n                else:\n                    _mean = [int(a) for a in _age.split(\"-\")]\n                    _total.append(sum(_mean)\/2) \n\n            _mean_age = int(sum(_total)\/len(_total))\n\n\n    for _element in base_df[_grouper]:\n        data = base_df[base_df[_grouper] == _element].T[1:].reset_index()\n        data.rename(columns={\"index\" : \"year\", data.columns[1] : _element}, inplace=True)\n        fig.add_trace(go.Scatter(\n                        x=data[\"year\"], \n                        y=data[data.columns[1]],\n                        mode='lines+markers',\n                        name=_element,                    \n                        hovertemplate=\"<br>\".join([\n                                        \"Year : %{x}\",\n                                        \"%{y}%\"\n                                    ]), \n                        line=dict(width=3)\n                        ))\n\n\n    fig.update_layout(\n        title = f\"<b>{_grouper} distribution 2018 - 2021<b>\",\n        title_x = 0.5,\n        paper_bgcolor=\"darkgray\", \n        height=600, \n        width=1000,\n        showlegend=True,\n        xaxis = dict(\n            tickmode = 'linear',\n            tick0 = _year,\n            dtick = 1,\n            title = \"Year\"\n        ),\n        yaxis = dict( \n            title = \"Percentage\"\n        )\n    )\n\n    return fig, base_df","e311a235":"a, b, c, d = historic_graphs(\"Title\")[0], historic_graphs(\"Age\")[0], historic_graphs(\"Degree\")[0], historic_graphs(\"Gender\")[0]\ndisplay(a, b, c, d)","10c1b076":"df = df_2021\n\noverall_age = pd.DataFrame(df[\"Age\"].value_counts()).reset_index()\noverall_age.rename(columns={\"index\" : \"Age\", \"Age\" : \"Count\"}, inplace=True)\noverall_age[\"Percent\"] = overall_age[\"Count\"].apply(lambda x : round(x*100 \/ overall_age[\"Count\"].sum(), ndigits=2) if overall_age[\"Count\"].sum() != 0 else 0)\noverall_age.sort_values(by=\"Age\", inplace=True)\n\noverall_country = pd.DataFrame(df[\"Country\"].value_counts()).reset_index()\noverall_country.rename(columns={\"index\" : \"Country\", \"Country\" : \"Count\"}, inplace=True)\noverall_country[\"Percent\"] = overall_country[\"Count\"].apply(lambda x : round(x*100 \/ overall_country[\"Count\"].sum(), ndigits=2) if overall_country[\"Count\"].sum() != 0 else 0)\noverall_country.sort_values(by=\"Count\", ascending=False, inplace=True)\n\noverall_Title = pd.DataFrame(df[\"Title\"].value_counts()).reset_index()\noverall_Title.rename(columns={\"index\" : \"Title\", \"Title\" : \"Count\"}, inplace=True)\noverall_Title[\"Percent\"] = overall_Title[\"Count\"].apply(lambda x : round(x*100 \/ overall_Title[\"Count\"].sum(), ndigits=2) if overall_Title[\"Count\"].sum() != 0 else 0)\noverall_Title.sort_values(by=\"Count\", ascending=False, inplace=True)\n\noverall_Gender = pd.DataFrame(df[\"Gender\"].value_counts()).reset_index()\noverall_Gender.rename(columns={\"index\" : \"Gender\", \"Gender\" : \"Count\"}, inplace=True)\noverall_Gender[\"Percent\"] = overall_Gender[\"Count\"].apply(lambda x : round(x*100 \/ overall_Gender[\"Count\"].sum(), ndigits=2) if overall_Gender[\"Count\"].sum() != 0 else 0)\noverall_Gender.sort_values(by=\"Count\", ascending=False, inplace=True)\n\noverall_Degree = pd.DataFrame(df[\"Degree\"].value_counts()).reset_index()\noverall_Degree.rename(columns={\"index\" : \"Degree\", \"Degree\" : \"Count\"}, inplace=True)\noverall_Degree[\"Percent\"] = overall_Degree[\"Count\"].apply(lambda x : round(x*100 \/ overall_Degree[\"Count\"].sum(), ndigits=2) if overall_Degree[\"Count\"].sum() != 0 else 0)\noverall_Degree.sort_values(by=\"Count\", ascending=False, inplace=True)\n\ntitle_degree = round(df.groupby(\"Title\")[\"Degree\"].value_counts(normalize=True)*100, ndigits=2)\ntitle_degree = title_degree.rename('Percent').reset_index().sort_values(by=\"Title\").reset_index(drop=True)\n\nfig = make_subplots(rows=4, cols=2, \n                    specs=[\n                           [{'type':'bar', \"colspan\": 2}, None],    # First line on the graph, 'colspan\" cause the graph spans over 2 columns\n                           [{'type':'domain'}, {'type':'domain'}],\n                           [{'type':'domain'}, {'type':'domain'}],\n                           [{'type':'bar', \"colspan\": 2}, None],                     \n                           ], \n                    subplot_titles=(\"Top 10 countries\", \"Age\", \n                                    \"Gender\", \"Degree\",\n                                    \"Title\", \"Degree distribution per Job title\")\n                    )\n\nfig.add_trace(go.Bar(name='All', x=overall_country[:10]['Country'], y=overall_country[:10]['Percent'],\n                    customdata=overall_country[:10]['Count'],\n                    hovertemplate=\"<br>\".join([\n                                    \"%{x}\",\n                                    \"%{customdata} Kagglers\",\n                                    \"%{y}%\"\n                                ]),  \n                    texttemplate=\"%{customdata}\",\n                    textposition=\"inside\",\n                    marker_color='rgb(55, 83, 109)', \n                    showlegend=True,\n                    legendgroup='1',\n                    ),\n            row=1, col=1)\n\nfig.add_trace(go.Pie(\n       labels=overall_age[\"Age\"], values=overall_age[\"Count\"], \n       hole=.5, \n       legendgroup='2',\n       name=\"\"\n       ),\n       row=2, col=1)\n\nfig.add_trace(go.Pie(\n       labels=overall_Gender[\"Gender\"], values=overall_Gender[\"Count\"], \n       hole=.5, \n       legendgroup='2',\n       name=\"\"\n       ),\n       row=2, col=2)\n\nfig.add_trace(go.Pie(\n       labels=overall_Degree[\"Degree\"], values=overall_Degree[\"Count\"], \n       hole=.5, \n       legendgroup='3',\n       name=\"\"\n       ),\n       row=3, col=1)\n\nfig.add_trace(go.Pie(\n       labels=overall_Title[\"Title\"], values=overall_Title[\"Count\"], \n       hole=.5, \n       legendgroup='3',\n       name=\"\"\n       ),\n       row=3, col=2)\n\n\nfig.add_trace(go.Bar(name='', x=title_degree['Title'], y=title_degree['Percent'], \n                    customdata=title_degree['Degree'],\n                    hovertemplate=\"<br>\".join([\n                                    \"%{x}\",\n                                    \"%{customdata}\",\n                                    \"%{y}%\"\n                                ]),\n                    texttemplate=\"%{customdata}\",\n                    textposition=\"inside\",\n                    marker_color='rgb(55, 83, 109)',  \n                    showlegend=False,\n                    legendgroup='4',\n                    ),\n            row=4, col=1)\n\nfig.update_yaxes(title_text=\"Percentage of total\", row=1, col=1)\n\nfig.update_layout( \n            paper_bgcolor=\"darkgray\", \n            title=f\"<b>Overall view of the Kaggle 2021 survey<b>\", \n            title_x=0.5,\n            height=2000,\n            legend_tracegroupgap = 350,\n            showlegend=True,\n            autosize=True,\n            barmode='group',\n                         )\n\nfig.show()","fd5576de":"def generate_country_df(_country : str):\n\n    _df = df[df[\"Country\"] == _country]\n    return _df.reset_index(drop=True)\n\ndef generate_country_dashboard(_country : str):\n\n    if _country[0].islower() == True:\n        _country = _country.capitalize()\n        \n    _country_df = generate_country_df(f\"{_country}\")\n\n    country_age_values = round(_country_df[\"Age\"].value_counts(normalize=True)*100, ndigits=2)\n    country_age_values = country_age_values.rename(\"percent\").reset_index().sort_values(\"index\", ascending=True)\n\n    world_age_values = round(df[\"Age\"].value_counts(normalize=True)*100, ndigits=2)\n    world_age_values = world_age_values.rename(\"percent\").reset_index().sort_values(\"index\", ascending=True)\n\n    country_degree_values = _country_df[\"Degree\"].value_counts()\n    country_degree_labels = country_degree_values.index\n\n    world_degree_values = df[\"Degree\"].value_counts()\n    world_degree_labels = world_degree_values.index\n\n    gender_age_world = round(df.groupby(\"Age\")[\"Gender\"].value_counts(normalize=True)*100, ndigits=2)\n    gender_age_world = gender_age_world.rename('Percent').reset_index().sort_values(by=\"Age\").reset_index(drop=True)\n\n    gender_age_country = round(_country_df.groupby(\"Age\")[\"Gender\"].value_counts(normalize=True)*100, ndigits=2)\n    gender_age_country = gender_age_country.rename('Percent').reset_index().sort_values(by=\"Age\").reset_index(drop=True)\n\n    gender_job_world = round(df.groupby(\"Title\")[\"Gender\"].value_counts(normalize=True)*100, ndigits=2)\n    gender_job_world = gender_job_world.rename('Percent').reset_index().sort_values(by=\"Title\").reset_index(drop=True)\n\n    gender_job_country = round(_country_df.groupby(\"Title\")[\"Gender\"].value_counts(normalize=True)*100, ndigits=2)\n    gender_job_country = gender_job_country.rename('Percent').reset_index().sort_values(by=\"Title\").reset_index(drop=True)\n\n\n    fig = make_subplots(rows=4, cols=2, \n                        specs=[\n                            [{'type':'bar', \"colspan\": 2}, None],    # First line on the graph, 'colspan\" cause the graph spans over 2 columns\n                            [{'type':'domain'}, {'type':'domain'}],\n                            [{'type':'bar', \"colspan\": 2}, None],\n                            [{'type':'bar', \"colspan\": 2}, None]\n                            ], \n                        subplot_titles=(\"Age Distribution\", f\"{_country} degree distribution \", \n                                        \"World degree distribution\", \"Gender distribution per age group\",\n                                        \"Gender distribution per job title\")\n                        )\n        \n    fig.add_trace(go.Bar(name=f'{_country}', x=country_age_values[\"index\"], y=country_age_values[\"percent\"],\n                     hovertemplate=\"<br>\".join([\n                                    \"Age : %{x}\",\n                                    \"%{y}%\",\n                                ]),  \n                     marker_color='rgb(55, 83, 109)', \n                     legendgroup = '1'),\n              row=1, col=1)\n\n    fig.add_trace(go.Bar(name=f'World', x=world_age_values[\"index\"], y=world_age_values[\"percent\"], \n                        hovertemplate=\"<br>\".join([\n                                        \"Age : %{x}\",\n                                        \"%{y}%\",\n                                    ]), \n                        marker_color='rgb(26, 118, 255)', \n                        legendgroup = '1'),\n                row=1, col=1)\n\n    fig.add_trace(go.Pie(labels=country_degree_labels, values=country_degree_values, hole=.5, name=f\"{_country}\", legendgroup = '2'),\n                row=2, col=1)\n\n    fig.add_trace(go.Pie(labels=world_degree_labels, values=world_degree_values, hole=.5, name=\"World\", legendgroup = '2'),\n                row=2, col=2)\n\n    fig.add_trace(go.Bar(name=f'{_country}', x=gender_age_country['Age'], y=gender_age_country['Percent'],\n                        customdata=gender_age_country['Gender'],\n                        hovertemplate=\"<br>\".join([\n                                        \"Age : %{x}\",\n                                        \"%{customdata}\",\n                                        \"%{y}%\"\n                                    ]),  \n                        texttemplate=\"%{customdata}\",\n                        textposition=\"inside\",\n                        marker_color='rgb(55, 83, 109)', \n                        legendgroup = '3'),\n                row=3, col=1)\n                \n    fig.add_trace(go.Bar(name='World', x=gender_age_world['Age'], y=gender_age_world['Percent'], \n                        customdata=gender_age_world['Gender'],\n                        hovertemplate=\"<br>\".join([\n                                        \"Age : %{x}\",\n                                        \"%{customdata}\",\n                                        \"%{y}%\"\n                                    ]),\n                        texttemplate=\"%{customdata}\",\n                        textposition=\"inside\",\n                        marker_color='rgb(26, 118, 255)',  \n                        legendgroup = '3'),\n                row=3, col=1)\n    \n    fig.add_trace(go.Bar(name=f'{_country}', x=gender_job_country['Title'], y=gender_job_country['Percent'],\n                    customdata=gender_job_country['Gender'],\n                    hovertemplate=\"<br>\".join([\n                                    \"%{x}\",\n                                    \"%{customdata}\",\n                                    \"%{y}%\"\n                                ]),  \n                    texttemplate=\"%{customdata}\",\n                    textposition=\"inside\",\n                    marker_color='rgb(55, 83, 109)', \n                    legendgroup = '4',\n                    #orientation='h'\n                    ),\n            row=4, col=1)\n            \n    fig.add_trace(go.Bar(name='World', x=gender_job_world['Title'], y=gender_job_world['Percent'], \n                        customdata=gender_job_world['Gender'],\n                        hovertemplate=\"<br>\".join([\n                                        \"%{x}\",\n                                        \"%{customdata}\",\n                                        \"%{y}%\"\n                                    ]),\n                        texttemplate=\"%{customdata}\",\n                        textposition=\"inside\",\n                        marker_color='rgb(26, 118, 255)',  \n                        legendgroup = '4',\n                        #orientation='h'\n                        ),\n                row=4, col=1)\n\n    fig.update_layout( \n            paper_bgcolor=\"darkgray\", \n            title=f\"Overall view of {_country} <br><sup>{len(_country_df)} Kagglers - {round(len(_country_df)*100\/(len(all_data_2021)), ndigits=2)}% of total<sup>\", \n            title_x=0.5,\n            height=1700,\n            legend_tracegroupgap = 355,\n            showlegend=True,\n            barmode='group',\n            bargap=0.15, \n            bargroupgap=0.1,\n    )\n\n    print(f\"\"\"\n    The average participant from {_country} took {int(_country_df[\"Duration (seconds)\"].median())} seconds to fill the survey,     \n    is in the age group {_country_df[\"Age\"].mode()[0]}, identifies as a {_country_df[\"Gender\"].mode()[0]}, \n    the Kaggler's education is : {_country_df[\"Degree\"].mode()[0]}    \n    and current job title : {_country_df[\"Title\"].mode()[0]}\n    \"\"\")\n\n    return fig","0307b2ec":"output = Output()\nstart = Button(description=\"Generate graph\")\n\ncountry_widget = widgets.Dropdown(\n    options=sorted(list(all_data_2021['Q3'][1:].unique())),\n    value=sorted(list(all_data_2021['Q3'][1:].unique()))[0],\n    description='Country :',\n    disabled=False,\n)\n\ndef click_start(b):\n    with output:\n        clear_output()\n        display(generate_country_dashboard(country_widget.value))\n       \nstart.on_click(click_start)\n\ndef on_change(change):\n    with output:\n        clear_output()\n        display(generate_country_dashboard(country_widget.value))\n\ncountry_widget.observe(on_change)\n\ndisplay(country_widget, start, output)","82ce2b0b":"generate_country_dashboard(\"France\")","be4844ab":"########################################################\n# Little function to generate a df for each question to make data manipulation easier\n\ndef generate_df_for_question(_data , _question_number : int):\n\n    _cols = [_col for _col in _data.columns if f\"Q{str(_question_number)} \" in str(_col) or f\"Q{str(_question_number)}_\" in str(_col)]\n\n    for i in _data.columns[:6][::-1]:\n        _cols.insert(0, i)\n\n    return _data[_cols]\n\n\n########################################################\n# Manipulation of the data for each question according to the grouper selected\n\ndef create_insights_for_question(_data , _question : int, _grouper : str):\n\n    _df = generate_df_for_question(_data, _question)\n\n    if len(_df.columns) < 8:\n\n        _df_grouped_overall = _df.groupby(_grouper).count().reset_index()\n        _df_grouped_overall = round(_df[_df.columns[-1]].value_counts(normalize=True)*100, ndigits=2)\n        _df_grouped_overall = _df_grouped_overall.rename(\"Percent\").reset_index()\n        _df_grouped_overall.rename(columns={\"index\" : _df.columns[-1]}, inplace=True)\n\n        _df_grouped_focused = round(_df.groupby(by=_grouper)[_df.columns[-1]].value_counts(normalize=True)*100, ndigits=2)\n        _df_grouped_focused = _df_grouped_focused.rename(\"Percent\").reset_index()\n\n        return _df_grouped_overall, _df_grouped_focused\n\n    else:\n\n        _current_col = [_col for _col in _df.columns if f\"Q{_question} \" in str(_col) or f\"Q{_question}_\" in str(_col)]\n        _flag = False\n\n        for i in _current_col:\n            if i[3] == \"B\" or i[4] == \"B\":\n                _flag = True\n\n        if _flag == True:\n\n            _question_1 = _df.columns[6].split(\"()\")[0]\n            _question_2 = _df.columns[-1].split(\"()\")[0]\n            special_new_cols = _df.columns[:6].to_list()\n\n            for _col in _df.columns[6:]:\n                _begin = _col[0:5]\n                if \"()\" in _col:\n                    _end = _col.split(\"()\")[-1]\n                elif \"?\" in _col:\n                    _end = _col.split(\"?\")[-1]\n                _new = _begin + _end\n                special_new_cols.append(_new.strip())\n            \n            _single_col = _df.columns[7].split(\"()\")[0].strip()\n\n            _df.columns = special_new_cols\n            _df_grouped = _df.groupby(_grouper).count().reset_index()\n            _df_grouped.drop(_df_grouped.columns[1:6].to_list(), axis=1, inplace=True)\n\n            _len = int((len(_df_grouped.columns)-1)\/2)\n\n            _df_focused_A = _df_grouped[_df_grouped.columns[0:_len+1]]\n            _df_focused_B = _df_grouped[_df_grouped.columns[_len+1:]]\n            _df_focused_B = pd.DataFrame(_df_grouped[_df_grouped.columns[0]]).join(_df_focused_B)\n\n            _dic_A = {}\n            _dic_B = {}\n\n            for _col_A, _col_B in zip(_df_focused_A.columns[1:], _df_focused_B.columns[1:]):\n                _dic_A.update({_col_A.strip() : _df_focused_A[_col_A].sum()})\n                _dic_B.update({_col_B.strip() : _df_focused_B[_col_B].sum()})\n\n            _df_world_A = pd.DataFrame.from_dict(_dic_A, orient='index').reset_index()\n            _df_world_A.rename(columns={\"index\" : _question_1, 0 :\"Count\"}, inplace=True)\n            _df_world_A[\"Percent\"] = _df_world_A[\"Count\"].apply(lambda x : round(x*100 \/ _df_world_A[\"Count\"].sum(), ndigits=2))\n            _df_world_A.sort_values(\"Count\", ascending=False, inplace=True)\n            _df_world_A.reset_index(drop=True, inplace=True)\n\n            _df_world_B = pd.DataFrame.from_dict(_dic_B, orient='index').reset_index()\n            _df_world_B.rename(columns={\"index\" : _question_2, 0 :\"Count\"}, inplace=True)\n            _df_world_B[\"Percent\"] = _df_world_B[\"Count\"].apply(lambda x : round(x*100 \/ _df_world_B[\"Count\"].sum(), ndigits=2))\n            _df_world_B.sort_values(\"Count\", ascending=False, inplace=True)\n            _df_world_B.reset_index(drop=True, inplace=True)\n\n            return _df_world_A, _df_world_B, _df_focused_A, _df_focused_B, _question_1, _question_2\n\n        else:\n            \n            if \"()\" in _df.columns[6]:\n                _new_cols = [i.split(\"()\")[-1].strip() for i in _df.columns[6:]]\n                _single_col = _df.columns[-1].split(\"()\")[0].strip()\n            else:\n                for i in _df.columns[6:]:\n                    if len(i.split(\"?\")[-1].strip()) > 0:\n                        _new_cols = [i.split(\"?\")[-1].strip() for i in _df.columns[6:]]\n                    else:\n                        _new_cols = [i.split(\"?\")[0].strip() for i in _df.columns[6:]]\n\n                _single_col = _df.columns[-1].split(\"?\")[0].strip()      \n\n            for i in range(6): \n                _new_cols.insert(i, _df.columns[i])\n\n            _df.columns = _new_cols\n\n            _df_grouped = _df.groupby(_grouper).count().reset_index()\n            _df_grouped.drop(_df_grouped.columns[1:6].to_list(), axis=1, inplace=True)\n\n            _dic = {}\n\n            for _col in _df_grouped.columns[1:]:\n                _dic.update({_col : _df_grouped[_col].sum()})\n\n            _df_world = pd.DataFrame.from_dict(_dic, orient='index').reset_index()\n            _df_world.rename(columns={\"index\" : _single_col, 0 :\"Count\"}, inplace=True)\n            _df_world[\"Percent\"] = _df_world[\"Count\"].apply(lambda x : round(x*100 \/ _df_world[\"Count\"].sum(), ndigits=2))\n            _df_world.sort_values(\"Count\", ascending=False, inplace=True)\n            _df_world.reset_index(drop=True, inplace=True)\n         \n            return _df_world, _df_grouped\n\n########################################################\n# Generation of the graphs based on the transformed data\ndef generate_graphs_for_questions(_data , _question : int, _grouper : str):\n\n    _counter = 1           # Basic counter to keep track of how many graphs will be generated by the function, it can either be 2 or 4\n\n    try:\n        _df_global, _df_focused = create_insights_for_question(_data, _question, _grouper)\n        _counter = 2\n    except:\n        _df_world_A, _df_world_B, _df_focused_A, _df_focused_B, _question_1, _question_2 = create_insights_for_question(_data, _question, _grouper)\n        _counter = 4\n\n    #print(\"Nb de graphs :\", _counter)\n\n    if _counter == 2:\n\n        global_fig = px.histogram(_df_global, x=\"Percent\", y=_df_global.columns[0])\n\n        global_fig.update_layout(\n                        paper_bgcolor=\"darkgray\", \n                        title=_df_global.columns[0] + f\"<br><sup>All answers<sup>\", \n                        title_x=0.5\n                        )\n\n        global_fig.update_xaxes(title=\"Percentage\")\n        global_fig.update_yaxes(title=\"\", autorange=\"reversed\")\n        global_fig.update_traces(hovertemplate=\"%{x}%\")\n\n        try:\n            grouped_fig = px.histogram(_df_focused, x=\"Percent\", y=_grouper, color=_df_focused.columns[1])\n\n            grouped_fig.update_layout(\n                            paper_bgcolor=\"darkgray\", \n                            title=_df_focused.columns[1] + f\"<br><sup>Grouped by {_grouper}<sup>\", \n                            title_x=0.5, \n                            legend=dict(title=None) # this hides the legend title which i'm using as the title of the graph\n                            )\n\n            grouped_fig.update_xaxes(title=\"Percentage\")\n            grouped_fig.update_yaxes(title=\"\", autorange=\"reversed\")\n            grouped_fig.update_traces(hovertemplate=\"%{y} : %{x}%\")\n            \n        except:\n            df = pd.DataFrame(columns=[\"Answer\", \"Percent\", _grouper])\n\n            for _element in _df_focused[_grouper]:\n                \n                mini_df = _df_focused[_df_focused[_grouper] == _element].T#.reset_index()\n                mini_df = mini_df[1:].reset_index()\n                mini_df[_grouper] = _element\n                mini_df.rename(columns={\"index\" : \"Answer\", mini_df.columns[1] : \"Percent\"}, inplace=True)\n                mini_df[\"Percent\"] = mini_df[\"Percent\"].apply(lambda x : round(x*100 \/ mini_df[\"Percent\"].sum(), ndigits=2))\n\n                df = pd.concat([df, mini_df])\n\n            grouped_fig = px.histogram(df, x=\"Percent\", y=_grouper, color=df.columns[0])\n\n            grouped_fig.update_layout(\n                            paper_bgcolor=\"darkgray\", \n                            title=_df_global.columns[0] + f\"<br><sup>Grouped by {_grouper}<sup>\", \n                            title_x=0.5, \n                            legend=dict(title=None) # this hides the legend title which i'm using as the title of the graph\n                            )\n\n            grouped_fig.update_xaxes(title=\"Percentage\")\n            grouped_fig.update_yaxes(title=\"\", autorange=\"reversed\")\n            grouped_fig.update_traces(hovertemplate=\"%{y} : %{x}%\")\n\n        return global_fig, grouped_fig\n    \n    elif _counter == 4:\n\n        global_fig_A = px.histogram(_df_world_A, x=\"Percent\", y=_df_world_A.columns[0])\n\n        global_fig_A.update_layout(\n                        paper_bgcolor=\"darkgray\", \n                        title=_question_1 + f\"<br><sup>All answers<sup>\", \n                        title_x=0.5\n                        )\n\n        global_fig_A.update_xaxes(title=\"Percentage\")\n        global_fig_A.update_yaxes(title=\"\", autorange=\"reversed\")\n        global_fig_A.update_traces(hovertemplate=\"%{x}%\")\n\n        global_fig_B = px.histogram(_df_world_B, x=\"Percent\", y=_df_world_B.columns[0])\n\n        global_fig_B.update_layout(\n                        paper_bgcolor=\"darkgray\", \n                        title=_question_2 + f\"<br><sup>All answers<sup>\", \n                        title_x=0.5\n                        )\n\n        global_fig_B.update_xaxes(title=\"Percentage\")\n        global_fig_B.update_yaxes(title=\"\", autorange=\"reversed\")\n        global_fig_B.update_traces(hovertemplate=\"%{x}%\")\n\n        df_A_final = pd.DataFrame(columns=[\"Answer\", \"Percent\", _grouper])\n        df_B_final = pd.DataFrame(columns=[\"Answer\", \"Percent\", _grouper])\n\n        for _element in _df_focused_A[_grouper]:\n            \n            mini_df = _df_focused_A[_df_focused_A[_grouper] == _element].T\n            mini_df = mini_df[1:].reset_index()\n            mini_df[_grouper] = _element\n            mini_df.rename(columns={\"index\" : \"Answer\", mini_df.columns[1] : \"Percent\"}, inplace=True)\n            mini_df[\"Percent\"] = mini_df[\"Percent\"].apply(lambda x : round(x*100 \/ mini_df[\"Percent\"].sum(), ndigits=2) if mini_df[\"Percent\"].sum() != 0 else 0)\n\n            df_A_final = pd.concat([df_A_final, mini_df])\n\n        for _element in _df_focused_B[_grouper]:\n            \n            mini_df = _df_focused_B[_df_focused_B[_grouper] == _element].T\n            mini_df = mini_df[1:].reset_index()\n            mini_df[_grouper] = _element\n            mini_df.rename(columns={\"index\" : \"Answer\", mini_df.columns[1] : \"Percent\"}, inplace=True)\n            mini_df[\"Percent\"] = mini_df[\"Percent\"].apply(lambda x : round(x*100 \/ mini_df[\"Percent\"].sum(), ndigits=2) if mini_df[\"Percent\"].sum() != 0 else 0)\n\n            df_B_final = pd.concat([df_B_final, mini_df])\n\n        focus_A_fig = px.histogram(df_A_final, x=\"Percent\", y=_grouper, color=df_A_final.columns[0])\n\n        focus_A_fig.update_layout(\n                    paper_bgcolor=\"darkgray\", \n                    title=_question_1 + f\"<br><sup>Grouped by {_grouper}<sup>\", \n                    title_x=0.5,\n                    legend=dict(title=None) \n                    )\n\n        focus_A_fig.update_xaxes(title=\"Percentage\")\n        focus_A_fig.update_yaxes(title=\"\", autorange=\"reversed\")\n        focus_A_fig.update_traces(hovertemplate=\"%{x}%\")\n\n        focus_B_fig = px.histogram(df_B_final, x=\"Percent\", y=_grouper, color=df_B_final.columns[0])\n\n        focus_B_fig.update_layout(\n                    paper_bgcolor=\"darkgray\", \n                    title=_question_2 + f\"<br><sup>Grouped by {_grouper}<sup>\", \n                    title_x=0.5,\n                    legend=dict(title=None) \n                    )\n\n        focus_B_fig.update_xaxes(title=\"Percentage\")\n        focus_B_fig.update_yaxes(title=\"\", autorange=\"reversed\")\n        focus_B_fig.update_traces(hovertemplate=\"%{x}%\")       \n\n        return global_fig_A, global_fig_B, focus_A_fig, focus_B_fig","abd5bfc2":"output2 = Output()\nstart2 = Button(description=\"Create graphs\")\n\n_groupers = [\"Age\", \"Gender\", \"Country\", \"Degree\", \"Title\"]\n\nquestion_widget = widgets.Dropdown(\n    options=[i for i in range(6, 39)],\n    value=6,\n    description='Question :',\n    disabled=False,\n)\n\ngrouper_widget = widgets.Dropdown(\n    options=_groupers,\n    value=_groupers[0],\n    description='Group by :',\n    disabled=False,\n)\n\ndef click_start(b):\n    with output2:\n        clear_output()\n        try:\n            a, b, c, d = generate_graphs_for_questions(df, question_widget.value, grouper_widget.value)\n            display(a, b, c, d)\n        except:\n            a, b = generate_graphs_for_questions(df, question_widget.value, grouper_widget.value)\n            display(a, b)\n       \nstart2.on_click(click_start)\n\ndisplay(question_widget, grouper_widget, start2, output2)","147f9bee":"a, b, c, d = generate_graphs_for_questions(df, 32, \"Age\")\n\ndisplay(a, b, c, d)","7a8051d2":"a, b = generate_graphs_for_questions(df, 35, \"Title\")\n\ndisplay(a, b)","867ca934":"### How did the average Kaggle survey respondant evolve over the years?\n\nWe can see that the population is getting a little younger, and therefore more students and people with bachelor's degree are present. It still is very much dominated by men unfortunately","0f9658e2":"### Power BI sure is loved amongst Kagglers\n\n### Please do copy the notebook and have a play with the widget, see what other insights you can find =)","a19c065e":"### Here's what it looks like for France ( no bias whatsoever :)","ae4603c5":"### And for Question 35 grouped by Title","38fc686e":"Ok there is something going on there. The average participant took just under 11 minutes to finish the survey, and the slowest took over 28 days. Now there could be a lot of reasons for that, and Kaggle specifies that the data has been cleaned before being made available to us, but i'll choose to get rid of any line that took more than 4 hours to complete. ","ea76030c":"### mySQL remains the most used and sought after big data storage solution. It is interesting to see that over 10% of respondents do not use any databases. The Age of the respondent does not seem to influence his database choice ","6da53b16":"## Welcome to my Kaggle survey notebook\n\n### IMPORTANT - I did not know that ipywidgets don't work in the Kaggle environment once the notebook has been commited. It looks like Plotly's own dropdown possibilities will not cut it to achieve what i want.\n### Please click on \"copy & edit\" to get the notebook, you will be ale to run it and use the ipywidget Dropdown menu \n\nIf you like what you see please give it an upvote =)          \nIf you don't feel free to comment any criticism you may have about it                  \nThis notebook is interactive and you need to download \/ copy it to be able to run its functions                        \nAll the graphs are produced with Plotly which means that you can interact with them (click on the items in the legends if you want to hide them, double click if you want to isolate them, hover over the graph to get infos, zoom in\/out, export the graph)","083e6956":"## Dataset inspection, tuning and cleaning\n\n","504451bd":"### What are we learning ?\n\nFrom that figure we can get a few informations:\n\n* French kagglers are older than the world's average\n* Over 70% have a master's degree, that's way more than the world's average\n* Gender distribution per age group is quite similar to the world's one\n* Women are a bit more present in a few jobs : Statistician, Data Analyst, Business Analyst","d2ec51a3":"### The first column.. \n\n..is about the time it took for a given participant to complete the survey, let's print some infos about it","98baed34":"## My approach to the survey\n\nA lot of insights can be found in those answers.    \nIt would be interesting to be able to group the answers, i will do that and use the answers of the first 5 questions as possible groupers (**Age, Gender, Country, Degree, Title**).     \nI will create functions that will generate graphs for all questions, depending on the type of question (amongst the types listed above) 2 or 4 graphs will be generated. The first half of the them will be a global graphic, the second will be graphs grouped by the grouper of your choice.","927f73b0":"## Country infos\n\n\nThe first informations i'd like to get would be about how countries compare to the overall trend on a few elements:\n* Age\n* Education\n* Gender distribution per age group\n* Gender distribution per job title\n\nThat way we can have a few key informations about how the Kagglers from a selected country compare to the world\n\nCopy the notebook and select a country you want informations about from the dropdown menu below, a small graph will be generated","ebd23778":"2021 is the biggest year in term of partcipants, nice!\n\n\nNow I want to see how the general population has evolved over the past few years, the function the the collapsed cell below just does that","0af68c0d":"### Data relevance\n\nWe have a total of 25973 survey participants, Kaggle however has over [5 million registered users](https:\/\/www.kaggle.com\/general\/164795). Less than 0.6 % of the registered users completed the survey, this is a common problem with surveys and we will have to work with that, keeping in mind that it might not be a very good representation of the 99% + who did not take part in the survey.\n\nThe data quality of the .csv is quite good. I'll just take the first line of the dataset, where the questions are and concatenate it to the column names","af07ddc1":"### Age, Degree, Gender, and Title are possible options","218dc940":"## Understanding the questions \n\nThere are several types of questions in the survey.\n\n* Single answer questions about yourself (Age, gender, location, education, job title)\n* Single answer questions about your job \/ coding habits (where \"None\" or \"Other\" are options)\n* Multiple answer questions where you get to choose more than one option if you so wish\n* Multiple answer questions with sub-categories (A and B) those questions are usually about your use of a particular technology (part A) and your eagerness to learn more about it (part B), you may answer one part and not answer the second one and vice versa","cdfd2a5f":"## Throwback\n\nWe have at our disposal right here on Kaggle the datasets of the previous years' surveys, i'll include the ones from 2018, 2019 and 2020 and compare a few things\n\nLet's start by applying the thing we did to the first dataset, which is go and see how many out of the participants took over 4 hours to complete and could be considered outliers","d71c9331":"## 2021 Overall view\n\nBack to the 2021 dataset\n\n\nLet's create a few graphs about the general participant population shall we?","fa285c67":"### Here is what the function generates for Question 32 grouped by Age","162211c4":"### What can we see at a glance?\n\n* India and the U.S.A are at the top of the chart when it comes to participant number, together they represent over 37% of the total population\n* The age groups 18 - 21, 22 - 24 and 25 - 29 are about the same proportions (just under 19%)\n* This is a man's world... almost 80% of dudes and bros\n* A similar proportion of Bachelor's and Masters degrees, over 10% of Doctors as well, Kagglers got brains!\n* Over a quarter of students, which is understandable, but that's a variable we may wanna get rid of if we want insights about the **professional** data science world\n* Data Analysts, Business Analysts, Software engineers, Data engineers have about the same proportions of Bachelors and Masters, research scientists have over 56% of PhDs\n","7f48a318":"What does it look like now?","30669495":"We can work with that, and always get back to it if we wanna modify the threshold "}}