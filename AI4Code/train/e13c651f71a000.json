{"cell_type":{"f5afa912":"code","6b452b2c":"code","928e81e0":"code","25e7cc57":"code","896faff0":"code","9eac64f4":"code","a5c3b34a":"code","3a17c3db":"code","ddcbd0ac":"code","cf61aec1":"code","044c88d0":"code","d27913db":"code","63a633b9":"code","9bda889d":"code","a377d78c":"code","5bfbd2d9":"code","0a7c322d":"code","9e7a7aa6":"code","b41a9516":"code","4ea486f6":"code","b8b33c8d":"code","4890b971":"code","4d1cab49":"code","402304f1":"code","68563688":"code","b7c93aff":"code","1d7e6104":"code","0e83fb6e":"code","d6f83844":"code","752d35b5":"code","b4f58987":"markdown","7db483c5":"markdown","7f69da4c":"markdown","029bec5c":"markdown","55a043e6":"markdown","7f4f1808":"markdown","5c02767d":"markdown","68e39786":"markdown"},"source":{"f5afa912":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","6b452b2c":"from skimage.io import imread, imshow\nfrom skimage import transform\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nimport torchvision.transforms as transforms\nimport pandas as pd\nimport os\nimport random as rnd\n# importing matplotib to plot images and graphs\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\n# PyTorch libraries and modules\nimport torch\nfrom torch.autograd import Variable\nfrom torch.nn import Linear, ReLU, CrossEntropyLoss, Sequential, Conv2d, MaxPool2d, Module, Softmax, BatchNorm2d, Dropout\nfrom torch.optim import Adam, SGD\nimport torch.nn.functional as F\nfrom skimage.color import rgb2gray\nfrom sklearn.decomposition import PCA\nimport random\nimport numpy as np","928e81e0":"%matplotlib inline\ndataset_dir = '..\/input\/plant-seedlings-classification\/train'\nsubplot_size = len([dir for dir in os.listdir(dataset_dir)])\nfig, axs = plt.subplots(subplot_size, sharey = True, figsize=(50, 50))\n\nfor ax, dir in zip(axs ,os.listdir(dataset_dir)):\n    \n    file_name = rnd.choice([file for file in os.listdir(os.path.join(dataset_dir, dir))])\n#     print(file_name)\n    img = mpimg.imread(os.path.join(dataset_dir, dir, file_name))\n    img = transform.resize(img, (100, 100))\n    ax.imshow(img)\n    # Add title and axis names\n    ax.set_title(dir)\n    ","25e7cc57":"class_map = {}\nid = 0\nfor dir_name in os.listdir('..\/input\/plant-seedlings-classification\/train'):\n    class_map[dir_name] = id\n    id += 1\nclass_reverse_map ={}\nid = 0\nfor dir_name in os.listdir('..\/input\/plant-seedlings-classification\/train'):\n    class_reverse_map[id] = dir_name\n    id += 1\n","896faff0":"train_dir = '..\/input\/plant-seedlings-classification\/train'\ntrain_size = 0.85\nsub_dir = os.listdir(train_dir)\n# print(len(sub_dir))\nsub_dir_lengths ={}\ntrain_set_files = []\ntest_set_files = []\nfor sub in sub_dir:\n    full_path = os.path.join(train_dir, sub)\n    files = [os.path.join(train_dir, sub,name) for name in os.listdir(full_path)]\n    sub_dir_lengths[sub]=len(files)\n    random.shuffle(files)\n    train_set_files.extend(files[:int(train_size*sub_dir_lengths[sub])])\n    test_set_files.extend(files[int(train_size*sub_dir_lengths[sub]):])","9eac64f4":"len(test_set_files)","a5c3b34a":"# for sub in os.listdir(train_dir):\n#     full_path = os.path.join(train_dir, sub)\n#     print(f'{sub} - ({len(train_set_files[sub])}, {len(test_set_files[sub])})')","3a17c3db":"pca = PCA(n_components = 100)\n# train_df = pd.DataFrame(['file_path','image'])\ntrain_images = []\n# for sub_name in train_set_files.keys():\nfor file_name in train_set_files:\n    img = imread(file_name)\n    img = transform.resize(img, (100, 100, 3))\n    img = img.reshape(-1)\n    train_images.append(img)\n# train_df=pd.DataFrame(train_dict, columns = ['file_path','image'])\n# test_dict = []\n# for sub_name in test_set_files.keys():\n#     for file_name in test_set_files[sub_name]:\n#         img = imread(file_name)\n#         img = transform.resize(img, (100, 100, 3))\n#         img = img.reshape(-1)\n#         test_dict.append((file_name, img))\n# test_df = pd.DataFrame(test_dict, columns = ['file_path','image'])","ddcbd0ac":"len(train_images)","cf61aec1":"images_fit = pd.DataFrame(train_images)\nimages_fit = images_fit.values.tolist()\npca.fit(images_fit)","044c88d0":"pca.explained_variance_ratio_","d27913db":"class SeedDataSet(Dataset):\n    def __init__(self, dir, transform = None):\n        \"\"\"\n        dir has all the file names from training set which will be used for training (as opposed to few for validation)\n        \"\"\"\n        self.df = pd.DataFrame(dir, columns = ['Name'])\n       #         self.df = pd.DataFrame(columns = ['Name','Labels'])\n#         for i, dir_name in enumerate(os.listdir(dir)):\n#             for name in os.listdir(os.path.join(dir, dir_name)):\n#                 labels.append(( name, i ))\n#         self.df = pd.DataFrame(labels, columns = ['Name','Labels'])\n#         self.transforms = transform\n    \n    def __len__(self):\n        return len(self.df)\n    \n    def __getitem__(self, idx):\n        image_path_name = self.df.iloc[idx, 0]\n        \n        head_tail = os.path.split(image_path_name)\n        sub_dir_name = os.path.split(head_tail[0])[1]\n        \n#         label = self.df.iloc[idx, 1]\n#         path = os.path.join(self.dir, class_reverse_map[label] ,image_name)\n        img = imread(image_path_name)\n        \n        img = transform.resize(img, (100, 100, 3))\n        img = img.reshape(1, -1)\n        img = pca.transform(img)\n#         img = torch.from_numpy(img).unsqueeze(0)\n        return img, class_map[sub_dir_name]","63a633b9":"train_dataset = SeedDataSet(train_set_files,transform=transforms.Resize(100))\nvalidation_dataset = SeedDataSet(test_set_files,transform=transforms.Resize(100))","9bda889d":"len(validation_dataset)","a377d78c":"image, label = train_dataset[0]","5bfbd2d9":"# dir = '..\/input\/plant-seedlings-classification\/train'\n# shapes = []\n# df = pd.DataFrame(columns = ['Name','Labels'])\n# for i, dir_name in enumerate(os.listdir(dir)):\n#     for name in os.listdir(os.path.join(dir, dir_name)):\n#         img = imread(os.path.join(dir, dir_name,name))\n#         if img.ndim > 3:\n#             print(name)\n# df = pd.DataFrame(labels, columns = ['Name','Labels'])","0a7c322d":"# train_size = int(0.8 * len(dataset))\n# test_size = len(dataset) - train_size\n# train_dataset, test_dataset = torch.utils.data.random_split(dataset, [train_size, test_size])","9e7a7aa6":"image.shape","b41a9516":"train_loader = DataLoader(train_dataset, batch_size = 100, shuffle = True)\nval_loader = DataLoader(validation_dataset, batch_size = 100)","4ea486f6":"class CNN(torch.nn.Module):\n    def __init__(self):\n        super(CNN, self).__init__()\n#         self.conv_layer1 = torch.nn.Sequential(\n#             torch.nn.Conv2d(in_channels = 1, out_channels= 10, kernel_size = 11), \n#             torch.nn.ReLU(),\n#             torch.nn.MaxPool2d(kernel_size =2, stride = 2)\n#         )\n#         torch.nn.init.xavier_uniform_(self.conv_layer1.weight)\n#         torch.nn.init.xavier_uniform_(self.conv_layer1.bias)\n        \n#         self.conv_layer2 = torch.nn.Sequential(\n#         torch.nn.Conv2d(in_channels = 10, out_channels = 20, kernel_size = 10), \n#         torch.nn.ReLU(),\n#         torch.nn.MaxPool2d(kernel_size = 2, stride = 2)\n#         )\n#         torch.nn.init.xavier_uniform_(self.conv_layer2.weight)\n#         torch.nn.init.xavier_uniform_(self.conv_layer2.bias)\n        \n        self.fc1 = torch.nn.Linear(100, 25)\n        self.fc2 = torch.nn.Linear(25, 12)\n        \n    def forward(self, x):\n#         out = self.conv_layer1(x)\n#         out = self.conv_layer2(out)\n#         out = out.contiguous().view(out.size(0), -1)\n        out = F.relu(self.fc1(x))\n        out = self.fc2(out)\n        return out","b8b33c8d":"# defining the model\nmodel = CNN()\n# defining the optimizer\noptimizer = Adam(model.parameters(), lr=0.07)\n# defining the loss function\ncriterion = CrossEntropyLoss()\n# checking if GPU is available\nif torch.cuda.is_available():\n    model = model.cuda()\n    criterion = criterion.cuda()\n    \nprint(model)","4890b971":"learning_rate = 0.01\nloss_fn = torch.nn.CrossEntropyLoss()    # Softmax is internally computed.\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)","4d1cab49":"def train_loop(dataloader, model, loss_fn, optimizer, epoch):\n    size = len(dataloader.dataset)\n    epoch_loss = 0\n    correct = 0\n    num_batches = len(dataloader)\n    for batch, (X, y) in enumerate(dataloader):\n        # Compute prediction and loss\n#         X = X.permute(0,1,2)\n        X = X.float()\n        if torch.cuda.is_available():\n            X = X.cuda()\n            y = y.cuda()\n        pred = model(X)\n        pred = pred.squeeze()\n        y = y.long()\n        loss = loss_fn(pred, y)\n\n        # Backpropagation\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n        \n        \n        \n        loss, current = loss.item(), batch * len(X)\n        \n        print(f\"loss: {loss:>7f}  [{current:>5d}\/{size:>5d}]\")\n        epoch_loss += loss\/num_batches\n        correct += (pred.argmax(1) == y).type(torch.float).sum().item()\n    train_loss[epoch] = epoch_loss\n    train_acc[epoch] = correct\n    \n\ndef test_loop(dataloader, model, loss_fn, epoch):\n    size = len(dataloader.dataset)\n    num_batches = len(dataloader)\n    test_loss, correct = 0, 0\n\n    with torch.no_grad():\n        for X, y in dataloader:\n#             X = X.permute(0,1,2)\n            X = X.float()\n            if torch.cuda.is_available():\n                X = X.cuda()\n                y = y.cuda()\n            pred = model(X)\n            pred = pred.squeeze()\n            y = y.long()\n#             pred = F.one_hot(pred)\n            test_loss += loss_fn(pred, y).item()\n            correct += (pred.argmax(1) == y).type(torch.float).sum().item()\n\n    test_loss \/= num_batches\n    val_loss[epoch] = test_loss\n    correct \/= size\n    val_acc[epoch] = correct\n    print(f\"Test Error: \\n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \\n\")","402304f1":"if torch.cuda.is_available():\n    loss_fn = loss_fn.cuda()\n\nepochs = 10\ntrain_loss, val_loss, train_acc, val_acc = [0]*epochs, [0]*epochs, [0]*epochs, [0]*epochs\nfor t in range(epochs):\n    print(f\"Epoch {t+1}\\n-------------------------------\")\n    train_loop(train_loader, model, loss_fn, optimizer,  t)\n    test_loop(val_loader, model, loss_fn,t)\nprint(\"Done!\")","68563688":"x1 = list(range(epochs))\ny1 = train_loss\ny2 = val_loss\nfig, (ax0, ax1) = plt.subplots(2, sharex= True)\nax0.plot(x1, y1)\nax0.plot(x1, y2)\nax0.legend(['training loss','validation loss'])\ny1 = train_acc\ny2 = val_acc\nax1.plot(x1, y1)\nax1.plot(x1, y2)\nax1.legend(['training accuracy','validation accuracy'])\n\n","b7c93aff":"class TestDataset(Dataset):\n    def __init__(self, dir):\n        self.dir = dir\n        \n        names = [name for name in os.listdir(dir)]\n        self.df = pd.DataFrame(names, columns = ['Name'])\n    def __len__(self):\n        return len([name for name in os.listdir(self.dir)])\n    def __getitem__(self,idx):\n        \n        img_name = self.df.iloc[idx,0]\n        image = imread(os.path.join(self.dir, img_name))\n        \n#         img = imread(image_path_name)\n        \n        img = transform.resize(image, (100, 100, 3))\n        img = img.reshape(1, -1)\n        img = pca.transform(img)\n        \n        \n        return img, img_name","1d7e6104":"test_Dataset=  TestDataset('..\/input\/plant-seedlings-classification\/test')","0e83fb6e":"test_loader = DataLoader(test_Dataset, batch_size = 1)","d6f83844":"pred_dict = []\nfor i, (img, img_name) in enumerate(test_loader):\n    img_name = img_name[0]\n    \n    with torch.no_grad():\n        img = img.float()\n#         img = img.cuda()\n        output = model(img)\n\n        output = torch.argmax(output).cpu().numpy().item()\n        pred_dict.append((img_name, class_reverse_map[output]))\n        \ndf = pd.DataFrame(pred_dict, columns = ['file','species'])","752d35b5":"df.to_csv('sample_submission.csv', index = False)","b4f58987":"Importing Required Libraries","7db483c5":"Applying PCA to a subset of images in training directory","7f69da4c":"Counting num. of image files in each directory","029bec5c":"Defining a NN Model","55a043e6":"Plotting loss graphs","7f4f1808":"Plotting images of each class","5c02767d":"Image dimensions","68e39786":"fit PCA instance on training dataset"}}