{"cell_type":{"3f7f82c7":"code","938e8402":"code","3e33f2b1":"code","c98246f7":"code","5ef1c799":"code","fd565106":"code","0166ca5c":"code","c160e200":"code","88cd371c":"code","88e5c344":"code","84ade095":"code","7c789665":"code","aea7390a":"code","d40a0819":"code","eb213035":"code","bb79226c":"code","0c7cdfd2":"code","5aff3a30":"code","38aad884":"code","e10ba99e":"code","5efc2882":"code","c6e6e767":"code","f26a0657":"code","a9c8f27c":"code","2aae5fa5":"code","766608b9":"code","2449aff1":"code","08f96496":"code","0333f9fa":"code","d5e3c934":"code","35261b26":"code","823c0a55":"markdown","7dcb296d":"markdown","cb19fc7d":"markdown","474d2c19":"markdown","77969652":"markdown","2ee357f4":"markdown","eaeb59f1":"markdown","1561042e":"markdown","ebfb36eb":"markdown","4345d3fd":"markdown","938b2343":"markdown","c2dfa140":"markdown","6a7b22b6":"markdown","0ae35312":"markdown","cdd86f14":"markdown","1d460191":"markdown"},"source":{"3f7f82c7":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.neighbors import KNeighborsClassifier\n\nfrom sklearn.metrics import classification_report,confusion_matrix","938e8402":"data = pd.read_csv(\"..\/input\/brasilian-houses-to-rent\/houses_to_rent.csv\")\n\ndata.head()","3e33f2b1":"print(data[\"animal\"].value_counts())\nprint(data[\"furniture\"].value_counts())","c98246f7":"def data_cleanse(df):\n    \n    df = df.copy()\n    \n    # Replacing values with values that are easier to interpret and model friendly\n    df[\"furniture\"].replace({\"not furnished\" :\"0\",\"furnished\":\"1\"},inplace=True)\n    df[\"animal\"].replace({\"not acept\":\"0\",\"acept\":\"1\"},inplace=True)\n    df[\"floor\"].replace({\"-\":\"0\"},inplace=True)\n    df[\"hoa\"].replace({\"Sem info\":\"0\",\"Incluso\":\"0\"},inplace=True)\n    df[\"property tax\"].replace({\"Incluso\":\"0\"},inplace=True)\n    \n    # Removing unnessecary characters\n    for column in df.columns[-5:]:\n        df[column] = df[column].apply(lambda x: \"\".join(x.split(\"$\")[-1].split(\",\")))\n    \n    # Changing object types to numeric\n    for column in df.columns:\n        if df[column].dtype == \"object\":\n            df[column] = df[column].astype(\"int64\")\n    \n    # New feature detailing property tax proportion of total\n    df[\"PctTax\"] = df[\"property tax\"] \/ df[\"total\"]\n    \n    # Dropping unhelpful column\n    df.drop(columns=[\"Unnamed: 0\"],inplace=True)\n    \n    return df","5ef1c799":"cleaned_df = data_cleanse(data)\n\ncleaned_df.head()","fd565106":"cleaned_df.describe()","0166ca5c":"sns.set_style(\"whitegrid\")\n\n# Visualizing rent distribution\nsns.histplot(x=cleaned_df[\"rent amount\"],kde=True)\nplt.xlim(0,16000)\nplt.title(\"Rent Distribution\")","c160e200":"# Visualizing numeric feature distributions by location\nplt.figure(figsize=(14,12))\nplt.subplot(2,2,1)\nsns.kdeplot(x=cleaned_df[cleaned_df[\"city\"] == 1][\"rent amount\"],shade=True,label=\"City\")\nsns.kdeplot(x=cleaned_df[cleaned_df[\"city\"] == 0][\"rent amount\"],shade=True,label=\"Out of City\")\nplt.xlim(0,20000)\nplt.title(\"Rent amount by location\")\nplt.legend()\n\nplt.subplot(2,2,2)\nsns.kdeplot(x=cleaned_df[cleaned_df[\"city\"] == 1][\"total\"],shade=True,label=\"City\")\nsns.kdeplot(x=cleaned_df[cleaned_df[\"city\"] == 0][\"total\"],shade=True,label=\"Out of City\")\nplt.xlim(0,30000)\nplt.title(\"Total amount by location\")\nplt.legend()\n\nplt.subplot(2,2,3)\nsns.kdeplot(x=cleaned_df[cleaned_df[\"city\"] == 1][\"fire insurance\"],shade=True,label=\"City\")\nsns.kdeplot(x=cleaned_df[cleaned_df[\"city\"] == 0][\"fire insurance\"],shade=True,label=\"Out of City\")\nplt.xlim(0,300)\nplt.title(\"Fire insurance by location\")\nplt.legend()\n\nplt.subplot(2,2,4)\nsns.kdeplot(x=cleaned_df[cleaned_df[\"city\"] == 1][\"property tax\"],shade=True,label=\"City\")\nsns.kdeplot(x=cleaned_df[cleaned_df[\"city\"] == 0][\"property tax\"],shade=True,label=\"Out of City\")\nplt.xlim(0,6000)\nplt.title(\"Property tax by location\")\nplt.legend()","88cd371c":"# Visualizing relationship between total price and area\nplt.figure(figsize=(10,8))\nplt.scatter(x=\"total\",y=\"area\",alpha=0.4,\n            edgecolors=\"white\",data=cleaned_df[cleaned_df[\"city\"]==1],label=\"City\")\nplt.scatter(x=\"total\",y=\"area\",alpha=0.4,\n            edgecolors=\"white\",data=cleaned_df[cleaned_df[\"city\"]==0],label=\"Out of City\")\nplt.xlim(0,20000)\nplt.ylim(0,1000)\nplt.xlabel(\"Total\")\nplt.ylabel(\"Area\")\nplt.legend()","88e5c344":"plt.figure(figsize=(12,4))\n\nplt.subplot(1,3,1)\nsns.barplot(x=\"city\",y=\"PctTax\",data=cleaned_df)\nplt.title(\"Mean tax %\")\n\nplt.subplot(1,3,2)\nsns.barplot(x=\"city\",y=\"total\",data=cleaned_df)\nplt.title(\"Mean total\")\n\nplt.subplot(1,3,3)\nsns.barplot(x=\"city\",y=\"area\",data=cleaned_df)\nplt.title(\"Mean area\")\n\nplt.tight_layout()","84ade095":"cleaned_df.info()","7c789665":"y = cleaned_df[\"city\"]","aea7390a":"plt.figure(figsize=(8,8))\nplt.pie(y.value_counts().values,autopct=\"%.1f%%\",\n       explode=[0,0.1],labels=[\"City\",\"Not City\"],\n       )\nplt.title(\"Visualizing Class Imbalance\")\nplt.show()","d40a0819":"from sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MinMaxScaler","eb213035":"# Function to preprocess data\ndef prepro(df):\n    \n    scaler = MinMaxScaler(feature_range=(0,1))\n    X = df.drop(\"city\",axis=1)\n    y = df[\"city\"]\n    X = pd.DataFrame(scaler.fit_transform(X),columns=X.columns)\n                          \n    X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3,random_state=101)\n                          \n    return X_train,X_test,y_train,y_test","bb79226c":"X_train,X_test,y_train,y_test = prepro(cleaned_df)","0c7cdfd2":"# Function to evaluate input data with a Logistic Regression model\ndef model_eval(X_train,X_test,y_train,y_test,balance):\n    \n    logmod = LogisticRegression(solver=\"liblinear\")\n    logmod.fit(X_train, y_train)\n    \n    pred = logmod.predict(X_test)\n    \n    print(balance,\":\")\n    cm = confusion_matrix(y_test,pred)\n    cr = classification_report(y_test,pred)\n    print(cr)\n    sns.heatmap(cm,annot=True,vmin=0,cmap=\"Blues\",fmt=\"g\",cbar=False)","5aff3a30":"# Evaluating model performance on a Logistic Regression model\nmodel_eval(X_train,X_test,y_train,y_test,\"Unbalanced\")","38aad884":"# Number of samples needed from majority class to match minority class\nmin_class = np.min(cleaned_df[\"city\"].value_counts().values)","e10ba99e":"min_class","5efc2882":"# Create list of two dataframes, one where city = 1 and one where city = 0\nunder_sample = []\nunder_sample.append(cleaned_df.query(\"city == 1\"))\nunder_sample.append(cleaned_df.query(\"city == 0\"))\n\n# Extract equal number of samples from the list for each class\nequal_samples = []\nfor f in under_sample:\n    equal_samples.append(f.sample(min_class))\n    \n# Concatenate dataframes together\neqdf = pd.concat(equal_samples,axis=0)","c6e6e767":"eqdf = eqdf.sample(frac=1).reset_index(drop=True)\n\nplt.figure(figsize=(8,8))\nplt.pie(eqdf[\"city\"].value_counts(),autopct=\"%.1f%%\",explode=[0,0.03])\nplt.title(\"Classes Balanced With Undersampling\")\nplt.show()","f26a0657":"eqdf.head()","a9c8f27c":"# Split and scale data\nX_train,X_test,y_train,y_test = prepro(eqdf)","2aae5fa5":"# Evaluating model performance on a Logistic Regression model\nmodel_eval(X_train,X_test,y_train,y_test,\"balanced undersampled\")","766608b9":"cleaned_df[\"city\"].value_counts()","2449aff1":"oversample_min = cleaned_df[cleaned_df[\"city\"] == 0].sample(5249,replace=True)\nreg_samp = cleaned_df[cleaned_df[\"city\"] == 1]\nosdf = pd.concat([oversample_min,reg_samp],axis=0)","08f96496":"X_train,X_test,y_train,y_test = prepro(osdf)\nmodel_eval(X_train,X_test,y_train,y_test,\"balanced oversampled\")","0333f9fa":"models = {\n        \"logmod\":LogisticRegression(),\n         \"RFClassifier\":RandomForestClassifier(),\n         \"KNN\":KNeighborsClassifier(),\n         \"SVM\":SVC()\n         }\n\nfor key,value in models.items():\n    value.fit(X_train,y_train)\n    print(key+(\" trained\"))","d5e3c934":"for key,value in models.items():\n    p = value.predict(X_test)\n    print(key)\n    print(\"\")\n    print(classification_report(y_test,p))\n","35261b26":"# Random Forest Confusion Matrix\nrfm = RandomForestClassifier()\nrfm.fit(X_train,y_train)\n\npreds = rfm.predict(X_test)\n\nsns.heatmap(confusion_matrix(y_test,preds),vmin=0,cbar=False,fmt=\"g\",cmap=\"Blues\",annot=True)","823c0a55":"# **Predicting Location of rental property**","7dcb296d":"I will first use undersampling:","cb19fc7d":"**EDA**","474d2c19":"**Importing Libraries**","77969652":"**Dealing with class imbalances**","2ee357f4":"Given that I will be classifying each observation by whether it is in a city or not, we should look at how our target class is balanced:","eaeb59f1":"Now we have balanced classes","1561042e":"**Reading in data**","ebfb36eb":"Now to run a series of models on our oversampled data","4345d3fd":"As we can see above, our model has an accuracy of 87%. This sounds fairly good until we see that every prediction is for one class: Our overrepresented city class. We will now try balancing classes.","938b2343":"Almost 90% of our observations are within a city. This will likely negatively affect any model trained on this data, and skew our results","c2dfa140":"I will first train a model on our data in its' current form. Then, I will compare results to over and under sampled data.","6a7b22b6":"**Data Cleaning**","0ae35312":"**Modelling**","cdd86f14":"It looks as though there is very little difference in our balanced datasets, when it comes to model performance.","1d460191":"Now let's try oversampling our minority class"}}