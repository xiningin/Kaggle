{"cell_type":{"3c4d9d0f":"code","2587cb75":"code","99796178":"code","fe3501ea":"code","f3525480":"code","f2178b25":"code","30895083":"code","987ccdd9":"code","b6cf128a":"code","148c94df":"code","82538710":"code","03f34d71":"code","015d3a52":"code","6bd35470":"code","5e4c2b89":"code","fc3e48d4":"code","d5d9eefc":"code","2511a7a0":"code","ec703636":"code","44037a13":"code","af9f623e":"code","f498c4ec":"code","012fce1f":"code","fa6b6e21":"code","fffd78d2":"code","20cb2645":"code","ad7c9a82":"code","7d77b1d4":"code","37b184e4":"code","ebb4d8be":"code","3ac3eb50":"code","b2836b66":"code","5aded455":"code","1e2aa33c":"code","09911f03":"code","9b534f59":"code","b80b274c":"code","3c3a8468":"code","85add472":"code","0ae28924":"code","8c4b6c53":"code","6d1e73f7":"code","10590866":"code","5df2569f":"code","2143dd4c":"code","e973dbf2":"code","28bbeb39":"code","4958e3ce":"code","0a2502a7":"code","8ab96204":"code","c4aef13d":"code","7a94b020":"code","ddb0b63b":"code","19953f09":"code","e515a441":"code","281222e6":"code","ea6e3d06":"code","59ed8d15":"code","6a6d8346":"code","9343c449":"code","c60c1708":"code","52027319":"code","e645cb73":"code","31771b2d":"code","3eaa49f2":"code","a7e3d91c":"code","cb358302":"code","fcc399ff":"code","41f3be5a":"code","d4db918e":"code","da284340":"code","ca87e5a6":"code","80f2e4f1":"code","9a19e1f2":"code","48235c04":"code","8a399c26":"code","8250f04b":"code","705afde3":"code","5a052679":"code","14b78de6":"code","47460c6d":"code","a96f7ed9":"code","716598dc":"code","680a0161":"code","85f24d9c":"code","1f1051b1":"code","66fa2f62":"markdown","a8aebb26":"markdown","41bb00c1":"markdown","b60698c3":"markdown","32ca0f53":"markdown","1593192a":"markdown","ccdc1b9e":"markdown","2ca33471":"markdown","196f6241":"markdown","fe89540b":"markdown","323bdf4e":"markdown","a92ffa02":"markdown","665b39f4":"markdown","f1fb39b8":"markdown","103c656d":"markdown"},"source":{"3c4d9d0f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","2587cb75":"df_train = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-2\/train.csv')\ndf_test = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-2\/test.csv')\nsample_submission = pd.read_csv('\/kaggle\/input\/covid19-global-forecasting-week-2\/submission.csv')","99796178":"df_train","fe3501ea":"df_test","f3525480":"sample_submission","f2178b25":"train_countries = list(df_train['Country_Region'].unique())\ntest_countries = list(df_test['Country_Region'].unique())","30895083":"print(len(train_countries))\nprint(len(test_countries))\nprint(len(set(train_countries).intersection(set(test_countries))))","987ccdd9":"df_train_original = df_train\ndf_test_original = df_test","b6cf128a":"\ndf_train = df_train_original.replace(np.nan, '', regex=True)\ndf_test = df_test_original.replace(np.nan, '', regex=True)","148c94df":"df_train[['Country_Region', 'Province_State']]","82538710":"df_train['location'] = df_train[['Country_Region', 'Province_State']].apply(lambda x: '-'.join(x), axis=1)\ndf_test['location'] = df_test[['Country_Region', 'Province_State']].apply(lambda x: '-'.join(x), axis=1)","03f34d71":"locations_train = df_train['location'].unique()\nlocations_test = df_train['location'].unique()","015d3a52":"print(len(locations_train))\nprint(len(locations_test))","6bd35470":"df_train[df_train['ConfirmedCases'] > 0]","5e4c2b89":"groups_train = df_train.groupby(['Country_Region', 'Province_State'])\nprint(len(groups_train))","fc3e48d4":"# groups_train = df_train[df_train['ConfirmedCases'] > 0].groupby(['Country\/Region', 'Province\/State'])\n# print(len(groups_train))\n# groups_test = df_test[df_test['ConfirmedCases'] > 0].groupby('location')","d5d9eefc":"# groups.get_group('China-Hebei')\nmin_date = groups_train['Date'].min()","2511a7a0":"min_date","ec703636":"min_date_sorted = min_date.sort_values()","44037a13":"for x,y in zip(min_date_sorted.index, min_date_sorted):\n    print(x,y)","af9f623e":"list(df_train[df_train['Country_Region'] == 'China']['Province_State'])","f498c4ec":"df_train[(df_train['Country_Region'] == 'Pakistan')]","012fce1f":"df_train[(df_train['Country_Region'] == 'US') & (df_train['Province_State'] == 'Washington')]","fa6b6e21":"index = 0\nfor x,y in zip(min_date_sorted.index, min_date_sorted):\n    print(index, x, y)\n    index = index + 1","fffd78d2":"min_date_sorted.shape","20cb2645":"import matplotlib.pyplot as plt ","ad7c9a82":"index = 34","7d77b1d4":"record = df_train[(df_train['Country_Region'] == min_date_sorted.index[index][0]) & (df_train['Province_State'] == min_date_sorted.index[index][1])]","37b184e4":"# x axis values \nx = record['Date']\n# corresponding y axis values \ny1 = record['ConfirmedCases']\ny2 = record['Fatalities']\n  \n# plotting the points  \nplt.plot(x, y1, label = \"Confirmed Cases\") \n# plt.plot(x, y2, label = \"Fatalities\") \n# naming the x axis \nplt.xlabel('Date') \n# naming the y axis \nplt.ylabel('Label') \n  \n# giving a title to my graph \nplt.title(str(min_date_sorted.index[index][0]) + \" \" + str(min_date_sorted.index[index][1]) + ' - Confirmed Cases') \n  \n# function to show the plot \nplt.show() ","ebb4d8be":"# x axis values \nx = record['Date']\n# corresponding y axis values \ny1 = record['ConfirmedCases']\ny2 = record['Fatalities']\n  \n# plotting the points  \n# plt.plot(x, y1, label = \"Confirmed Cases\") \nplt.plot(x, y2, label = \"Fatalities\") \n# naming the x axis \nplt.xlabel('Date') \n# naming the y axis \nplt.ylabel('Label') \n  \n# giving a title to my graph \nplt.title(str(min_date_sorted.index[index][0]) + \" \" + str(min_date_sorted.index[index][1]) + ' - Fatalities') \n  \n# function to show the plot \nplt.show() ","3ac3eb50":"import numpy as np \n  \n# curve-fit() function imported from scipy \nfrom scipy.optimize import curve_fit \n  \nfrom matplotlib import pyplot as plt \n  \n# numpy.linspace with the given arguments \n# produce an array of 40 numbers between 0 \n# and 10, both inclusive \nx = np.linspace(0, 10, num = 40) \n  \n  \n# y is another array which stores 3.45 times \n# the sine of (values in x) * 1.334.  \n# The random.normal() draws random sample  \n# from normal (Gaussian) distribution to make \n# them scatter across the base line \ny = 3.45 * np.sin(1.334 * x) + np.random.normal(size = 40) \n  \n# Test function with coefficients as parameters \ndef test(x, a, b): \n    return a * np.sin(b * x) \n  \n# curve_fit() function takes the test-function \n# x-data and y-data as argument and returns  \n# the coefficients a and b in param and \n# the estimated covariance of param in param_cov \nparam, param_cov = curve_fit(test, x, y)","b2836b66":"import math\nt = np.arange(0., 90., 1)\n\n# red dashes, blue squares and green triangles\n# f = [70000*1\/(1+math.pow(math.e,-(x-30)\/2)) for x in t]\n# f = [700*1\/(1+math.pow(math.e,-(x-20)\/2)) * (700*1\/(1+math.pow(math.e,-(x-40)\/2)) + 700) for x in t]\n\nf = 9000*1\/(1+exp(-1*(t-42)\/2.7)) + 50*log(1+exp((t-50))) - 0\nprint(f)\nplt.plot(t, f, 'r--')\nplt.show()","5aded455":"record = df_train[(df_train['Country_Region'] == min_date_sorted.index[index][0]) & (df_train['Province_State'] == min_date_sorted.index[index][1])]\nrecord = record[record['ConfirmedCases'] > 0]\n\nfrom datetime import datetime\n# datetime.date.today()\nbase_date_object = datetime.strptime('2020-01-22', \"%Y-%m-%d\").date()\nrecord['days'] = [(datetime.strptime(date, \"%Y-%m-%d\").date() - base_date_object).days + 1 for date in record['Date']]\n","1e2aa33c":"\nrecord2 = record[record['Fatalities'] > 0]\n# x axis values \nx = record['days'].values\nx2 = record2['days'].values\n# corresponding y axis values \ny1 = record['ConfirmedCases'].values\ny2 = record2['Fatalities'].values","09911f03":"# print(record['Date'][3600])\n\nx","9b534f59":"# record['days']\ny2","b80b274c":"from scipy.optimize import curve_fit\nfrom numpy import exp, linspace, random, log\n\ndef gaussian(x, amp, cen, wid):\n    return amp * exp(-(x-cen)**2 \/ wid)\n\ndef test(x, a, b, c): \n    return a*1\/(1+exp(-b*(x-c)))\n\ndef test_linear(x, a, b, c, d, e, f): \n    return a*1\/(1+exp(-b*(x-c))) + d*log(1+exp(x-e)) - f\n\ndef custom(x, a, b , c, d, e, f, g):\n    return a*1\/(1+exp(-(x-b)\/c)) * (d*1\/(1+exp(-(x-e)\/f)) + g)","3c3a8468":"y_max_ = y1[-1]\ny1_prime = np.diff(y1)\ny1_prime2 = np.diff(y1_prime)\nif len(y1)>0 and len(y1_prime) > 0 and len(y1_prime2) > 0:\n    max_slope_index = len(y1_prime) - 1 - list(y1_prime)[::-1].index(max(y1_prime))\n    max_slope_range = (max_slope_index+1)\/len(y1_prime)\n    y_max_ = y1[-1]\n    if max_slope_range < 0.75:\n        if y1_prime[max_slope_index] > 0 and max_slope_range < 0.75 and (((y1_prime[max_slope_index] - max(y1_prime[-2:]))\/y1_prime[max_slope_index]) < 0.5):\n            y_max_ = y1[-1]\n            pass\n        else:\n            y_max_ = y1[max_slope_index + 1]\n            pass\n    else:\n        y_max_ = y1[-1]","85add472":"y1_prime","0ae28924":"y1","8c4b6c53":"y_max_","6d1e73f7":"# param, param_cov = curve_fit(test, np.array(x), np.array(y1), [700, 0.5, 19], bounds=([1,0.1,-30],[800,2,150]))\n# param, param_cov = curve_fit(test, np.array(x), np.array(y1), [y1[-1]\/2, 0.5, (x[-1] - x[0])\/2 + x[0]], bounds=([y1[-1]\/2, 0.1, -30],[y1[-1] + 1000, 2, 150]))\n# param, param_cov = curve_fit(test, np.array(x), np.array(y1), [y_max_, 0.5, (x[-1] - x[0])\/2 + x[0]], maxfev = 100000, bounds=([y_max_\/2, 0.1, 0],[y_max_*2 + 1500, 1, 150]))\nparam, param_cov = curve_fit(test, np.array(x), np.array(y1), [y_max_*4, 0.5, (x[-1] - x[0])\/2 + x[0]], maxfev = 100000, bounds=([y_max_*3, 0.1, 0],[y_max_*8 + 1500, 1, 150]))\n# param, param_cov = curve_fit(test_linear, np.array(x), np.array(y1), [y_max_, 0.5, (x[-1] - x[0])\/2 + x[0], 50, 45, 0], maxfev = 100000, bounds=([y_max_\/2, 0.1, 0, 1, 30, -100],[y_max_*2 + 1500, 1, 150, 100, 100, 1000]))\n# param, param_cov = curve_fit(custom, np.array(x), np.array(y1), maxfev = 100000, bounds=([1, 0, 1, 1, 30, 1, 1], [2, 60, 8, 200, 90, 8, 1400]))\n# np.array([1,2,3,4])","10590866":"# gmodel = Model(custom)\n# print('parameter names: {}'.format(gmodel.param_names))\n# print('independent variables: {}'.format(gmodel.independent_vars))\n# params = gmodel.make_params()\n# result = gmodel.fit(y1, params, x=x)","5df2569f":"param","2143dd4c":"index","e973dbf2":"y1_pred = test(x,param[0], param[1], param[2])\n# y1_pred = test_linear(x,param[0], param[1], param[2], param[3], param[4], param[5])\n# y1_pred = custom(x,param[0], param[1], param[2], param[3], param[4], param[5], param[6])\nbase_x = range(61,100,1)\n# y1_pred_test = custom(base_x, param[0], param[1], param[2], param[3], param[4], param[5], param[6])\ny1_pred_test = test(base_x, param[0], param[1], param[2])\n# y1_pred_test = test_linear(base_x, param[0], param[1], param[2], param[3], param[4], param[5])","28bbeb39":"# x axis values \n# x = record['Date']\n# corresponding y axis values \n# y1 = record['ConfirmedCases']\n# y2 = record['Fatalities']\n# plotting the points  \nplt.plot(x, y1, label = \"Confirmed Cases\") \nplt.plot(x, y1_pred, label = \"Predicted\") \nplt.plot(base_x, y1_pred_test, label = \"Predicted\") \n# naming the x axis \nplt.xlabel('Date') \n# naming the y axis \nplt.ylabel('Label') \n  \n# giving a title to my graph \nplt.title(str(min_date_sorted.index[index][0]) + \" \" + str(min_date_sorted.index[index][1]) + ' - Confirmed Cases') \n  \n# function to show the plot \nplt.show() ","4958e3ce":"test([-30],param[0], param[1], param[2])","0a2502a7":"np.diff(y1)","8ab96204":"y2 = record2['Fatalities'].values\nprint(y2)\nprint(len(y2))","c4aef13d":"x2","7a94b020":"(x2[-1] - x2[0])\/2 + x2[0]","ddb0b63b":"y2[-1]","19953f09":"\n# param2, param_cov2 = curve_fit(test, np.array(x), np.array(y2), [6, 0.5, 10], bounds=([6,0.4,0],[100,0.8,150]))\nparam2, param_cov2 = curve_fit(test, np.array(x2), np.array(y2), [y2[-1]\/2, 0.5, (x2[-1] - x2[0])\/2 + x2[0] -3], bounds=([y2[-1]\/2, 0.2, 0],[y2[-1] + 1, 0.8, 150]))","e515a441":"param2","281222e6":"y2_pred = test(x2,param2[0], param2[1], param2[2])","ea6e3d06":"# x axis values \n# x = record['Date']\n# corresponding y axis values \n# y1 = record['ConfirmedCases']\n# y2 = record2['Fatalities']\n  \n# plotting the points  \nplt.plot(x2, y2, label = \"Confirmed Cases\") \nplt.plot(x2, y2_pred, label = \"Fatalities\") \n# naming the x axis \nplt.xlabel('Date') \n# naming the y axis \nplt.ylabel('Label') \n  \n# giving a title to my graph \nplt.title(str(min_date_sorted.index[index][0]) + \" \" + str(min_date_sorted.index[index][1]) + ' - Fatalities') \n  \n# function to show the plot \nplt.show() ","59ed8d15":"print(x2)\nprint(y2_pred)\nprint(y2)","6a6d8346":"record","9343c449":"base_x = range(61,100,1)\nprint(len(base_x))\nbase_y1 = test(base_x,param[0], param[1], param[2])\nbase_y2 = test(base_x,param2[0], param2[1], param2[2])","c60c1708":"base_y1","52027319":"base_y2","e645cb73":"x","31771b2d":"day_index_pred = 0\ndiff1_list = []\ndiff2_list = []\nfor day in base_x:\n    if day in x:\n        day_index = np.where(x == day)\n        diff1 = y1[day_index] - base_y1[day_index_pred]\n        diff1_list.append(diff1)\n    if day in x2:\n        day_index = np.where(x2 == day)\n        diff2 = y2[day_index] - base_y2[day_index_pred]\n        diff2_list.append(diff2)\n    day_index_pred = day_index_pred + 1\n\ndiff1_mean = np.max(diff1_list)\ndiff2_mean = np.max(diff2_list)\n\n#     print('diff1_mean', diff1_mean)\n#     print('diff2_mean', diff2_mean)\nif np.isnan(diff1_mean):\n    pass\nelse:\n    base_y1_mod = list(np.array(base_y1) + diff1_mean)\nif np.isnan(diff2_mean):\n    pass\nelse:\n    base_y2_mod = list(np.array(base_y2) + diff2_mean)\n\nbase_y1_pred = [int(n) for n in base_y1_mod]\nbase_y2_pred = [int(m) for m in base_y2_mod]","3eaa49f2":"print(list(base_x))\nprint(base_y1)\nprint(base_y1_mod)\nprint(base_y1_pred)\nprint(diff1_list)\nprint(diff1_mean)","a7e3d91c":"print(list(base_x))\nprint(base_y2)\nprint(base_y2_mod)\nprint(base_y2_pred)\nprint(diff2_list)\nprint(diff2_mean)","cb358302":"test_groups = df_test.groupby(['Country_Region', 'Province_State'])","fcc399ff":"group = test_groups.get_group((\"Afghanistan\",\"\"))\nprint(group['Date'].values)\nprint(group['ForecastId'].values)","41f3be5a":"index = 0\nfor key_,_ in zip(min_date_sorted.index, min_date_sorted):\n    \n    record = df_train[(df_train['Country_Region'] == key_[0]) & (df_train['Province_State'] == key_[1])]\n    record['days'] = [(datetime.strptime(date, \"%Y-%m-%d\").date() - base_date_object).days + 1 for date in record['Date']]\n    # x axis values \n    x = record['days']\n    # corresponding y axis values \n    y1 = record['ConfirmedCases']\n    y2 = record['Fatalities']\n    y1_prime = np.diff(y1)\n    \n#     print(y1_prime)\n    stage0 = False\n    stage1 = False\n    stage2 = False\n    stage3 = False\n    count1 = 0\n    count2 = 0\n    for start in range(len(y1_prime)-3):\n        if sum(y1_prime[start:start+3]) <=12:\n            count1 = count1 + 1\n            count2 = 0\n        else:\n            count2 = count2 + 1\n            count1 = 0\n        if not stage0 and count2 == 0 and count1 > 2:\n            stage0 = True\n            count1 = 0\n        if not stage1 and count1 == 0 and count2 > 5:\n            stage0 = True\n            stage1 = True\n            count2 = 0\n        if stage1 and count2 == 0 and count1 > 3:\n            stage2 = True\n            count1 = 0\n        if stage2 and count1 == 0 and count2 > 2:\n            stage3 = True\n            count2 = 0\n    if stage3:\n        print(index, key_)\n        print(y1_prime)\n        # plotting the points  \n        plt.plot(x, y1, label = \"Confirmed Cases\") \n        # plt.plot(x, y2, label = \"Fatalities\") \n        # naming the x axis \n        plt.xlabel('Date') \n        # naming the y axis \n        plt.ylabel('Label') \n\n        # giving a title to my graph \n        plt.title(str(key_[0]) + \" \" + str(key_[1]) + ' - Confirmed Cases') \n\n        # function to show the plot \n        plt.show() \n    index = index + 1","d4db918e":"# Get average fatality rate with respect to confirmed cases\ntotal_confirmed = 0\ntotal_fatalities = 0\nrate = []\nmax_y1 = []\nmax_y2 = []\ndetails = []\nfor index, start_date in zip(min_date_sorted.index, min_date_sorted):\n    print(index, start_date)\n#     print(list(min_date_sorted.index).index(index))\n    record = df_train[(df_train['Country_Region'] == index[0]) & (df_train['Province_State'] == index[1])]\n    if len(record[record['ConfirmedCases'] > 0]) != 0:\n        record = record[record['ConfirmedCases'] > 0]\n    record2 = record\n    if len(record[record['Fatalities'] > 0]) != 0:\n        record2 = record[record['Fatalities'] > 0]\n    # corresponding y axis values \n    \n    y1 = record['ConfirmedCases'].values\n    y2 = record2['Fatalities'].values\n    \n    b = -1\n    bad_index = 0\n    mod_count = 0\n    y1_copy = list(y1)\n    for a in y1:\n        if a < b:\n            y1[bad_index] = b\n            mod_count = mod_count + 1\n        else:\n            b = a\n        bad_index = bad_index + 1\n#     if mod_count > 0:\n#         print(\"*****************\")\n#         print(list(min_date_sorted.index).index(index), index)\n#         print(mod_count)\n#         print(y1)\n#         print(y1_copy)\n#         print(\"*****************\")\n    b = -1\n    bad_index = 0\n    mod_count = 0\n    y2_copy = list(y2)\n    for a in y2:\n        if a < b:\n            y2[bad_index] = b\n            mod_count = mod_count + 1\n        else:\n            b = a\n        bad_index = bad_index + 1\n#     if mod_count > 0:\n#         print(\"*****************\")\n#         print(list(min_date_sorted.index).index(index), index)\n#         print(mod_count)\n#         print(y2)\n#         print(y2_copy)\n#         print(\"*****************\")\n    \n    \n    y1_prime = np.diff(y1)\n    y1_prime2 = np.diff(y1_prime)\n#     print(y1)\n#     print(\"-------------------------------\")\n#     print(y1_prime)\n#     print(\"-------------------------------\")\n#     print(y1_prime2)\n#     print(\"*******************************\")\n    y_max_ = y1[-1]*2 + 1500\n    \n    if len(y1)>0 and len(y1_prime) > 0 and len(y1_prime2) > 0:\n        max_slope_index = len(y1_prime) - 1 - list(y1_prime)[::-1].index(max(y1_prime))\n        max_slope_range = (max_slope_index+1)\/len(y1_prime)\n        if max_slope_range < 0.75:\n            if y1_prime[max_slope_index] > 0 and max_slope_range < 0.5 and (((y1_prime[max_slope_index] - max(y1_prime[-2:]))\/y1_prime[max_slope_index]) < 0.5):\n                y_max_ = y1[-1]*2 + 1500\n    #             print(\"*******************************\")\n    #             print(list(min_date_sorted.index).index(index), index)\n    #             print(max_slope_index + 1, len(y1_prime))\n    #             print(max_slope_range, \"Max slope range\")\n    #             print(y1)\n    #             print(\"-------------------------------\")\n    #             print(y1_prime)\n    #             print(\"-------------------------------\")\n    #             print(y1_prime2)\n    #             print(\"*******************************\")\n                pass\n            else:\n                y_max_ = y1[max_slope_index + 1]*2 + 1500\n    #             print(\"*******************************\")\n    #             print(index)\n    #             print(max_slope_index + 1, len(y1_prime))\n    #             print(max_slope_range, \"Max slope range\")\n    #             print(y1)\n    #             print(\"-------------------------------\")\n    #             print(y1_prime)\n    #             print(\"-------------------------------\")\n    #             print(y1_prime2)\n    #             print(\"*******************************\")\n                pass\n        else:\n            y_max_ = y1[-1]*2 + 1500\n\n    #     if(index[1] == 'California'):\n    #         print(\"*******************************\")\n    #         print(index)\n    #         print(max_slope_index + 1, len(y1_prime))\n    #         print(max_slope_range, \"Max slope range\")\n    #         print(y1)\n    #         print(\"-------------------------------\")\n    #         print(y1_prime)\n    #         print(\"-------------------------------\")\n    #         print(y1_prime2)\n    #         print(\"*******************************\")\n    ratio = 0\n    if y2[-1] > 0:\n        ratio = y1[-1]\/y2[-1]\n    else:\n        ratio = y1[-1]\n    max_y1.append(y1[-1])\n    max_y2.append(y2[-1])\n    rate.append(ratio)\n    details.append(\" \".join([str(x) for x in [y1[-1], \" ------- \", y2[-1], \" ---- \", ratio, \" --------------- \", record['Date'].values[-1], \" ---- \", index, \"----\", list(min_date_sorted.index).index(index)]]))\n#     print(y1[-1], \" ------- \", y2[-1], \" ---- \", ratio, \" --------------- \", record['Date'].values[-1], \" ---- \", index, \"----\", list(min_date_sorted.index).index(index))\n    total_confirmed = total_confirmed + y1[-1]\n    total_fatalities = total_fatalities + y2[-1]\n\nprint(total_confirmed\/total_fatalities)","da284340":"for a1, a2, b, c in zip(max_y1, max_y2, rate, details):\n    print(c)","ca87e5a6":"print(pd.DataFrame(rate).describe())\nprint('Median ', np.median(rate))\nprint('Mean ', np.mean(rate))\nprint('Average', np.average(rate, weights = max_y2))\navg = np.average(rate, weights = max_y2)","80f2e4f1":"for a1, a2, b, c in zip(max_y1, max_y2, rate, details):\n    if(a1 < 100 and a2 < 4 and b < avg):\n        # correct the y2_pred as per average rate = 22\n        print(c)\n        pass\n    else:\n        ## correct the y2_pred as per the rate\n#         print(c)\n        pass","9a19e1f2":"df = pd.DataFrame(columns = ['ForecastId','ConfirmedCases','Fatalities'])\ndf_hr = pd.DataFrame(columns = ['ForecastId', 'Country_Region', 'Province_State', 'Days', 'ConfirmedCases','Fatalities','Date'])\n","48235c04":"public_start_date = '2020-03-19'\npublic_end_date = '2020-04-01'\n\ncount = 0\nfor index, start_date in zip(min_date_sorted.index, min_date_sorted):\n    print(list(min_date_sorted.index).index(index), index, start_date)\n    record = df_train[(df_train['Country_Region'] == index[0]) & (df_train['Province_State'] == index[1])]\n    if len(record[record['ConfirmedCases'] > 0]) == 0:\n        pass\n    else:\n        record = record[record['ConfirmedCases'] > 0]\n    base_date_object = datetime.strptime(start_date, \"%Y-%m-%d\").date()\n    public_start_date_object = datetime.strptime(public_start_date, \"%Y-%m-%d\").date()\n    public_end_date_object = datetime.strptime(public_end_date, \"%Y-%m-%d\").date()\n    record['days'] = [(datetime.strptime(date, \"%Y-%m-%d\").date() - base_date_object).days + 1 for date in record['Date']]\n    public_start_day = (public_start_date_object - base_date_object).days + 1\n    public_end_day = (public_end_date_object - base_date_object).days + 1\n    \n    ## limit the training data to date before public start date\n    if len(record[record['days'] < public_start_day]) > 0:\n        record = record[record['days'] < public_start_day]\n    # x axis values \n    \n    record2 = record\n    if len(record[record['Fatalities'] > 0]) != 0:\n        record2 = record[record['Fatalities'] > 0]\n    x = record['days'].values\n    x2 = record2['days'].values\n    # corresponding y axis values \n    y1 = record['ConfirmedCases'].values\n    y2 = record2['Fatalities'].values\n    \n    \n    ####  data correction ####\n    b = -1\n    bad_index = 0\n    mod_count = 0\n#     y1_copy = list(y1)\n    for a in y1:\n        if a < b:\n            y1[bad_index] = b\n            mod_count = mod_count + 1\n        else:\n            b = a\n        bad_index = bad_index + 1\n    if mod_count > 0:\n        print(\"*****************\")\n        print(list(min_date_sorted.index).index(index), index)\n        print(mod_count)\n        print(y1)\n#         print(y1_copy)\n        print(\"*****************\")\n    b = -1\n    bad_index = 0\n    mod_count = 0\n#     y2_copy = list(y2)\n    for a in y2:\n        if a < b:\n            y2[bad_index] = b\n            mod_count = mod_count + 1\n        else:\n            b = a\n        bad_index = bad_index + 1\n    if mod_count > 0:\n        print(\"*****************\")\n        print(list(min_date_sorted.index).index(index), index)\n        print(mod_count)\n        print(y2)\n#         print(y2_copy)\n        print(\"*****************\")    \n    ####  data correction ####\n\n    if len(y1) > 0:\n        y_max_ = y1[-1]\n        y1_prime = np.diff(y1)\n        y1_prime2 = np.diff(y1_prime)\n        if len(y1)>0 and len(y1_prime) > 0 and len(y1_prime2) > 0:\n            max_slope_index = len(y1_prime) - 1 - list(y1_prime)[::-1].index(max(y1_prime))\n            max_slope_range = (max_slope_index+1)\/len(y1_prime)\n            y_max_ = y1[-1]\n            if max_slope_range < 0.75:\n                if y1_prime[max_slope_index] > 0 and max_slope_range < 0.75 and (((y1_prime[max_slope_index] - max(y1_prime[-2:]))\/y1_prime[max_slope_index]) < 0.5):\n                    y_max_ = y1[-1]\n                    pass\n                else:\n                    y_max_ = y1[max_slope_index + 1]\n                    pass\n            else:\n                y_max_ = y1[-1]\n    else:\n        y_max_ = 0\n    \n    stage0 = False\n    stage1 = False\n    stage2 = False\n    stage3 = False\n    count1 = 0\n    count2 = 0\n    for start in range(len(y1_prime)-3):\n        if sum(y1_prime[start:start+3]) <=12:\n            count1 = count1 + 1\n            count2 = 0\n        else:\n            count2 = count2 + 1\n            count1 = 0\n        if not stage0 and count2 == 0 and count1 > 2:\n            stage0 = True\n            count1 = 0\n        if not stage1 and count1 == 0 and count2 > 5:\n            stage0 = True\n            stage1 = True\n            count2 = 0\n        if stage1 and count2 == 0 and count1 > 3:\n            stage2 = True\n            count1 = 0\n        if stage2 and count1 == 0 and count2 > 2:\n            stage3 = True\n            count2 = 0\n    if stage3:\n        param, param_cov = curve_fit(custom, np.array(x), np.array(y1), maxfev = 100000, bounds=([1, 0, 1, 1, 30, 1, 1], [2, 60, 8, 200, 90, 8, 1400]))\n        y1_pred = custom(x, param[0], param[1], param[2], param[3], param[4], param[5], param[6])\n    elif index[0] == 'Korea, South':\n        param, param_cov = curve_fit(test_linear, np.array(x), np.array(y1), [y_max_, 0.5, (x[-1] - x[0])\/2 + x[0], 50, 45, 0], maxfev = 100000, bounds=([y_max_\/2, 0.1, 0, 1, 30, -100],[y_max_*5 + 1500, 1, 150, 100, 100, 1000]))\n        y1_pred = test_linear(x, param[0], param[1], param[2], param[3], param[4], param[5])\n    elif index[0] in ['US', 'Spain', 'Germany', 'France', 'Iran', 'United Kingdom']:\n        param, param_cov = curve_fit(test, np.array(x), np.array(y1), [y_max_*7, 0.5, (x[-1] - x[0])\/2 + x[0]], maxfev = 100000, bounds=([y_max_*5, 0.1, 0],[y_max_*10 + 1500, 1, 150]))\n        y1_pred = test(x, param[0], param[1], param[2])\n    elif index[0] == 'China':\n        param, param_cov = curve_fit(test, np.array(x), np.array(y1), [y_max_, 0.5, (x[-1] - x[0])\/2 + x[0]], maxfev = 100000, bounds=([y_max_\/2, 0.1, 0],[y_max_*5 + 1500, 1, 150]))\n        y1_pred = test(x, param[0], param[1], param[2])\n    else:\n        param, param_cov = curve_fit(test, np.array(x), np.array(y1), [y_max_*5, 0.5, (x[-1] - x[0])\/2 + x[0]], maxfev = 100000, bounds=([y_max_*4, 0.1, 0],[y_max_*8 + 1500, 1, 150]))\n        y1_pred = test(x, param[0], param[1], param[2])\n    param2, param_cov2 = curve_fit(test, np.array(x2), np.array(y2), [y2[-1]\/2, 0.5, (x2[-1] - x2[0])\/2 + x2[0] - 3], maxfev = 100000, bounds=([y2[-1]\/2, 0.1, 0],[y2[-1]*5 + 1, 0.8, 150]))\n    y2_pred = test(x2,param2[0], param2[1], param2[2])\n    \n#     print(y1)\n#     print(y1_pred)\n#     print(\"----------------------------------\")\n#     print(y2)\n#     print(y2_pred)\n#     print(\"----------------------------------\")\n    \n    group = test_groups.get_group(index)\n#     print(group['Date'].values)\n    group['days'] = [(datetime.strptime(date, \"%Y-%m-%d\").date() - base_date_object).days + 1 for date in group['Date'].values]\n    \n    group = group[group['days'] <= public_end_day]\n    \n    ids = group['ForecastId'].values\n    days = [(datetime.strptime(date, \"%Y-%m-%d\").date() - base_date_object).days + 1 for date in group['Date'].values]\n    \n    prev_days = range(public_start_day - 6, public_start_day - 1, 1)\n    \n    if stage3:\n        test_y1_pred_raw = custom(days, param[0], param[1], param[2], param[3], param[4], param[5], param[6])\n        prev_y1_pred_raw = custom(prev_days, param[0], param[1], param[2], param[3], param[4], param[5], param[6])\n    elif index[0] == 'Korea, South':\n        test_y1_pred_raw = test_linear(days, param[0], param[1], param[2], param[3], param[4], param[5])\n        prev_y1_pred_raw = test_linear(prev_days, param[0], param[1], param[2], param[3], param[4], param[5])\n    elif index[0] in ['US', 'Spain', 'Germany', 'France', 'Iran', 'United Kingdom']:\n        test_y1_pred_raw = test(days, param[0], param[1], param[2])\n        prev_y1_pred_raw = test(prev_days, param[0], param[1], param[2])\n    else:\n        test_y1_pred_raw = test(days, param[0], param[1], param[2])\n        prev_y1_pred_raw = test(prev_days, param[0], param[1], param[2])\n    test_y2_pred_raw = test(days, param2[0], param2[1], param2[2])\n    prev_y2_pred_raw = test(prev_days, param2[0], param2[1], param2[2])\n    \n    day_index_pred = 0\n    diff1_list = []\n    diff2_list = []\n    for day in prev_days:\n        if day in x:\n            day_index = np.where(x == day)\n            diff1 = y1[day_index] - prev_y1_pred_raw[day_index_pred]\n            diff1_list.append(diff1)\n        if day in x2:\n            day_index = np.where(x2 == day)\n            diff2 = y2[day_index] - prev_y2_pred_raw[day_index_pred]\n            diff2_list.append(diff2)\n        day_index_pred = day_index_pred + 1\n    \n    if len(diff1_list) > 0:\n        diff1_mean = np.max(diff1_list)\n    else:\n        diff1_mean = 0\n    if len(diff2_list) > 0:\n        diff2_mean = np.max(diff2_list)\n    else:\n        diff2_mean = 0\n#     print('diff1_mean', diff1_mean)\n#     print('diff2_mean', diff2_mean)\n    if np.isnan(diff1_mean):\n        pass\n    else:\n        test_y1_pred_raw = list(np.array(test_y1_pred_raw) + diff1_mean)\n    if np.isnan(diff2_mean):\n        pass\n    else:\n        test_y2_pred_raw = list(np.array(test_y2_pred_raw) + diff2_mean)\n    \n#     test_y1_pred = [int(n) for n in test_y1_pred_raw]\n#     test_y2_pred = [int(m) for m in test_y2_pred_raw]\n\n    test_y1_pred = test_y1_pred_raw\n    test_y2_pred = test_y2_pred_raw\n\n    \n    ratio = 0\n    if y2[-1] > 0:\n        ratio = y1[-1]\/y2[-1]\n    else:\n        ratio = y1[-1]\n    \n    train_day_index = days.index(public_start_day) - 1\n    \n    if(y1[-1] < 100 and y2[-1] < 4 and ratio < avg):\n        # correct the y2_pred as per average rate = 22\n        for pred_index in range(len(test_y2_pred)):\n            if pred_index > train_day_index:\n                if test_y2_pred[pred_index] < test_y1_pred[pred_index]\/avg:\n                    test_y2_pred[pred_index] = test_y1_pred[pred_index]\/avg\n    else:\n        ## correct the y2_pred as per the rate\n        for pred_index in range(len(test_y2_pred)):\n            if pred_index > train_day_index:\n                if test_y2_pred[pred_index] < test_y1_pred[pred_index]\/ratio:\n                    test_y2_pred[pred_index] = test_y1_pred[pred_index]\/ratio\n    \n    test_y1_pred = [int(n) for n in test_y1_pred]\n    test_y2_pred = [int(m) for m in test_y2_pred]\n    \n    local_df_hr = pd.DataFrame(ids, columns=['ForecastId'])\n    print()\n    local_df_hr.insert(1, 'Country_Region', [index[0]]*len(days))\n    local_df_hr.insert(2, 'Province_State', [index[1]]*len(days))\n    local_df_hr.insert(3, 'Days', days)\n    local_df_hr.insert(4, 'ConfirmedCases', test_y1_pred)\n    local_df_hr.insert(5, 'Fatalities', test_y2_pred)\n    local_df_hr.insert(6, 'Date', group['Date'].values)\n    \n    local_df = pd.DataFrame(ids, columns=['ForecastId'])\n    local_df.insert(1, 'ConfirmedCases', test_y1_pred)\n    local_df.insert(2, 'Fatalities', test_y2_pred)\n    df = df.append(local_df)\n    df_hr = df_hr.append(local_df_hr)\n    # x axis values \n#     if stage3:\n#     if not stage3 and index[0] not in ['US', 'Spain', 'Germany', 'France', 'Iran', 'United Kingdom']:\n#     if y1[-1] > test_y1_pred[0]:\n#     if index[0] in ['US', 'Spain', 'Germany', 'France', 'Iran', 'United Kingdom']:\n#         x = record['days'].values\n#         plt.plot(x, y1, label = \"Confirmed Cases\") \n#         plt.plot(x, y1_pred, label = \"Predicted\") \n#         plt.plot(days, test_y1_pred, label = \"Forecast\")\n#         plt.xlabel('Date') \n#         plt.ylabel('Label') \n#         plt.title(str(index[0]) + \" \" + str(index[1]) + ' - Confirmed Cases') \n#         plt.show() \n\n#         plt.plot(x2, y2, label = \"Fatalities\") \n#         plt.plot(x2, y2_pred, label = \"Predicted\")\n#         plt.plot(days, test_y2_pred, label = \"Forecast\")\n#         plt.xlabel('Date') \n#         plt.ylabel('Label') \n#         plt.title(str(index[0]) + \" \" + str(index[1]) + ' - Fatalities') \n#         plt.show() \n    count = count + 1\n#     break\n","8a399c26":"print(df.shape)\nprint(df_hr.shape)","8250f04b":"private_start_date = '2020-04-02'\nprivate_end_date = '2020-04-30'\n\ncount = 0\nfor index, start_date in zip(min_date_sorted.index, min_date_sorted):\n    print(list(min_date_sorted.index).index(index), index, start_date)\n    record = df_train[(df_train['Country_Region'] == index[0]) & (df_train['Province_State'] == index[1])]\n    if len(record[record['ConfirmedCases'] > 0]) == 0:\n        pass\n    else:\n        record = record[record['ConfirmedCases'] > 0]\n    base_date_object = datetime.strptime(start_date, \"%Y-%m-%d\").date()\n    private_start_date_object = datetime.strptime(private_start_date, \"%Y-%m-%d\").date()\n    private_end_date_object = datetime.strptime(private_end_date, \"%Y-%m-%d\").date()\n    record['days'] = [(datetime.strptime(date, \"%Y-%m-%d\").date() - base_date_object).days + 1 for date in record['Date']]\n    private_start_day = (private_start_date_object - base_date_object).days + 1\n    private_end_day = (private_end_date_object - base_date_object).days + 1\n    \n    ## limit the training data to date before public start date\n    if len(record[record['days'] < private_start_day]) > 0:\n        record = record[record['days'] < private_start_day]\n    # x axis values \n    \n    record2 = record\n    if len(record[record['Fatalities'] > 0]) != 0:\n        record2 = record[record['Fatalities'] > 0]\n    x = record['days'].values\n    x2 = record2['days'].values\n    # corresponding y axis values \n    y1 = record['ConfirmedCases'].values\n    y2 = record2['Fatalities'].values\n    \n    \n    ####  data correction ####\n    b = -1\n    bad_index = 0\n    mod_count = 0\n#     y1_copy = list(y1)\n    for a in y1:\n        if a < b:\n            y1[bad_index] = b\n            mod_count = mod_count + 1\n        else:\n            b = a\n        bad_index = bad_index + 1\n    if mod_count > 0:\n        print(\"*****************\")\n        print(list(min_date_sorted.index).index(index), index)\n        print(mod_count)\n        print(y1)\n#         print(y1_copy)\n        print(\"*****************\")\n    b = -1\n    bad_index = 0\n    mod_count = 0\n#     y2_copy = list(y2)\n    for a in y2:\n        if a < b:\n            y2[bad_index] = b\n            mod_count = mod_count + 1\n        else:\n            b = a\n        bad_index = bad_index + 1\n    if mod_count > 0:\n        print(\"*****************\")\n        print(list(min_date_sorted.index).index(index), index)\n        print(mod_count)\n        print(y2)\n#         print(y2_copy)\n        print(\"*****************\")    \n    ####  data correction ####\n\n    y_max_ = y1[-1]\n    y1_prime = np.diff(y1)\n    y1_prime2 = np.diff(y1_prime)\n    if len(y1)>0 and len(y1_prime) > 0 and len(y1_prime2) > 0:\n        max_slope_index = len(y1_prime) - 1 - list(y1_prime)[::-1].index(max(y1_prime))\n        max_slope_range = (max_slope_index+1)\/len(y1_prime)\n        y_max_ = y1[-1]\n        if max_slope_range < 0.75:\n            if y1_prime[max_slope_index] > 0 and max_slope_range < 0.75 and (((y1_prime[max_slope_index] - max(y1_prime[-2:]))\/y1_prime[max_slope_index]) < 0.5):\n                y_max_ = y1[-1]\n                pass\n            else:\n                y_max_ = y1[max_slope_index + 1]\n                pass\n        else:\n            y_max_ = y1[-1]\n    \n    \n    stage0 = False\n    stage1 = False\n    stage2 = False\n    stage3 = False\n    count1 = 0\n    count2 = 0\n    for start in range(len(y1_prime)-3):\n        if sum(y1_prime[start:start+3]) <=12:\n            count1 = count1 + 1\n            count2 = 0\n        else:\n            count2 = count2 + 1\n            count1 = 0\n        if not stage0 and count2 == 0 and count1 > 2:\n            stage0 = True\n            count1 = 0\n        if not stage1 and count1 == 0 and count2 > 5:\n            stage0 = True\n            stage1 = True\n            count2 = 0\n        if stage1 and count2 == 0 and count1 > 3:\n            stage2 = True\n            count1 = 0\n        if stage2 and count1 == 0 and count2 > 2:\n            stage3 = True\n            count2 = 0\n    if stage3:\n        param, param_cov = curve_fit(custom, np.array(x), np.array(y1), maxfev = 100000, bounds=([1, 0, 1, 1, 30, 1, 1], [2, 60, 8, 200, 90, 8, 1400]))\n        y1_pred = custom(x, param[0], param[1], param[2], param[3], param[4], param[5], param[6])\n    elif index[0] == 'Korea, South':\n        param, param_cov = curve_fit(test_linear, np.array(x), np.array(y1), [y_max_, 0.5, (x[-1] - x[0])\/2 + x[0], 50, 45, 0], maxfev = 100000, bounds=([y_max_\/2, 0.1, 0, 1, 30, -100],[y_max_*5 + 1500, 1, 150, 100, 100, 1000]))\n        y1_pred = test_linear(x, param[0], param[1], param[2], param[3], param[4], param[5])\n    elif index[0] in ['US', 'Spain', 'Germany', 'France', 'Iran', 'United Kingdom']:\n        param, param_cov = curve_fit(test, np.array(x), np.array(y1), [y_max_*6, 0.5, (x[-1] - x[0])\/2 + x[0]], maxfev = 100000, bounds=([y_max_*5, 0.1, 0],[y_max_*10 + 1500, 1, 150]))\n        y1_pred = test(x, param[0], param[1], param[2])\n    elif index[0] == 'China':\n        param, param_cov = curve_fit(test, np.array(x), np.array(y1), [y_max_, 0.5, (x[-1] - x[0])\/2 + x[0]], maxfev = 100000, bounds=([y_max_\/2, 0.1, 0],[y_max_*5 + 1500, 1, 150]))\n        y1_pred = test(x, param[0], param[1], param[2])\n    elif index[0] in ['Italy', 'Switzerland']:\n        param, param_cov = curve_fit(test, np.array(x), np.array(y1), [y_max_*3, 0.5, (x[-1] - x[0])\/2 + x[0]], maxfev = 100000, bounds=([y_max_*2, 0.1, 0],[y_max_*5 + 1500, 1, 150]))\n        y1_pred = test(x, param[0], param[1], param[2])\n    else:\n        param, param_cov = curve_fit(test, np.array(x), np.array(y1), [y_max_*4, 0.5, (x[-1] - x[0])\/2 + x[0]], maxfev = 100000, bounds=([y_max_*3, 0.1, 0],[y_max_*8 + 1500, 1, 150]))\n        y1_pred = test(x, param[0], param[1], param[2])\n    param2, param_cov2 = curve_fit(test, np.array(x2), np.array(y2), [y2[-1]\/2, 0.5, (x2[-1] - x2[0])\/2 + x2[0] - 3], maxfev = 100000, bounds=([y2[-1]\/2, 0.1, 0],[y2[-1]*5 + 1, 0.8, 150]))\n    y2_pred = test(x2,param2[0], param2[1], param2[2])\n    \n#     print(y1)\n#     print(y1_pred)\n#     print(\"----------------------------------\")\n#     print(y2)\n#     print(y2_pred)\n#     print(\"----------------------------------\")\n    \n    group = test_groups.get_group(index)\n#     print(group['Date'].values)\n    group['days'] = [(datetime.strptime(date, \"%Y-%m-%d\").date() - base_date_object).days + 1 for date in group['Date'].values]\n    \n    group = group[group['days'] >= private_start_day]\n    ids = group['ForecastId'].values\n    days = [(datetime.strptime(date, \"%Y-%m-%d\").date() - base_date_object).days + 1 for date in group['Date'].values]\n    \n    \n    prev_days = range(private_start_day - 6, private_start_day - 1, 1)\n    \n    if stage3:\n        test_y1_pred_raw = custom(days, param[0], param[1], param[2], param[3], param[4], param[5], param[6])\n        prev_y1_pred_raw = custom(prev_days, param[0], param[1], param[2], param[3], param[4], param[5], param[6])\n    elif index[0] == 'Korea, South':\n        test_y1_pred_raw = test_linear(days, param[0], param[1], param[2], param[3], param[4], param[5])\n        prev_y1_pred_raw = test_linear(prev_days, param[0], param[1], param[2], param[3], param[4], param[5])\n    elif index[0] in ['US', 'Spain', 'Germany', 'France', 'Iran', 'United Kingdom']:\n        test_y1_pred_raw = test(days, param[0], param[1], param[2])\n        prev_y1_pred_raw = test(prev_days, param[0], param[1], param[2])\n    else:\n        test_y1_pred_raw = test(days, param[0], param[1], param[2])\n        prev_y1_pred_raw = test(prev_days, param[0], param[1], param[2])\n    test_y2_pred_raw = test(days, param2[0], param2[1], param2[2])\n    prev_y2_pred_raw = test(prev_days, param2[0], param2[1], param2[2])\n    \n    \n    day_index_pred = 0\n    diff1_list = []\n    diff2_list = []\n    for day in prev_days:\n        if day in x:\n            day_index = np.where(x == day)\n            diff1 = y1[day_index] - prev_y1_pred_raw[day_index_pred]\n            diff1_list.append(diff1)\n        if day in x2:\n            day_index = np.where(x2 == day)\n            diff2 = y2[day_index] - prev_y2_pred_raw[day_index_pred]\n            diff2_list.append(diff2)\n        day_index_pred = day_index_pred + 1\n    \n    if len(diff1_list) > 0:\n        diff1_mean = np.max(diff1_list)\n    else:\n        diff1_mean = 0\n    if len(diff2_list) > 0:\n        diff2_mean = np.max(diff2_list)\n    else:\n        diff2_mean = 0\n    \n#     print('diff1_mean', diff1_mean)\n#     print('diff2_mean', diff2_mean)\n    if np.isnan(diff1_mean):\n        pass\n    else:\n        test_y1_pred_raw = list(np.array(test_y1_pred_raw) + diff1_mean)\n    if np.isnan(diff2_mean):\n        pass\n    else:\n        test_y2_pred_raw = list(np.array(test_y2_pred_raw) + diff2_mean)\n    \n#     test_y1_pred = [int(n) for n in test_y1_pred_raw]\n#     test_y2_pred = [int(m) for m in test_y2_pred_raw]\n    test_y1_pred = test_y1_pred_raw\n    test_y2_pred = test_y2_pred_raw\n    \n    ratio = 0\n    if y2[-1] > 0:\n        ratio = y1[-1]\/y2[-1]\n    else:\n        ratio = y1[-1]\n    \n    train_day_index = days.index(private_start_day) - 1\n    \n    if(y1[-1] < 100 and y2[-1] < 4 and ratio < avg):\n        # correct the y2_pred as per average rate = 22\n        for pred_index in range(len(test_y2_pred)):\n            if pred_index > train_day_index:\n                if test_y2_pred[pred_index] < test_y1_pred[pred_index]\/avg:\n                    test_y2_pred[pred_index] = test_y1_pred[pred_index]\/avg\n    else:\n        ## correct the y2_pred as per the rate\n        for pred_index in range(len(test_y2_pred)):\n            if pred_index > train_day_index:\n                if test_y2_pred[pred_index] < test_y1_pred[pred_index]\/ratio:\n                    test_y2_pred[pred_index] = test_y1_pred[pred_index]\/ratio\n    \n    test_y1_pred = [int(n) for n in test_y1_pred]\n    test_y2_pred = [int(m) for m in test_y2_pred]\n\n    local_df_hr = pd.DataFrame(ids, columns=['ForecastId'])\n    local_df_hr.insert(1, 'Country_Region', [index[0]]*len(days))\n    local_df_hr.insert(2, 'Province_State', [index[1]]*len(days))\n    local_df_hr.insert(3, 'Days', days)\n    local_df_hr.insert(4, 'ConfirmedCases', test_y1_pred)\n    local_df_hr.insert(5, 'Fatalities', test_y2_pred)\n    local_df_hr.insert(6, 'Date', group['Date'].values)\n    \n    local_df = pd.DataFrame(ids, columns=['ForecastId'])\n    local_df.insert(1, 'ConfirmedCases', test_y1_pred)\n    local_df.insert(2, 'Fatalities', test_y2_pred)\n    df = df.append(local_df)\n    df_hr = df_hr.append(local_df_hr)\n    # x axis values \n#     if stage3:\n#     if index[0] in ['US', 'Spain', 'Germany', 'France', 'Iran', 'United Kingdom']:\n#     print(y1_prime)\n#     if count > 166 and count < 173:\n#     x = record['days'].values\n#     plt.plot(x, y1, label = \"Confirmed Cases\") \n#     plt.plot(x, y1_pred, label = \"Predicted\") \n#     plt.plot(days, test_y1_pred, label = \"Forecast\")\n#     plt.xlabel('Date') \n#     plt.ylabel('Label') \n#     plt.title(str(index[0]) + \" \" + str(index[1]) + ' - Confirmed Cases') \n#     plt.show() \n\n#     plt.plot(x2, y2, label = \"Fatalities\") \n#     plt.plot(x2, y2_pred, label = \"Predicted\")\n#     plt.plot(days, test_y2_pred, label = \"Forecast\")\n#     plt.xlabel('Date') \n#     plt.ylabel('Label') \n#     plt.title(str(index[0]) + \" \" + str(index[1]) + ' - Fatalities') \n#     plt.show() \n    count = count + 1\n#     break\n","705afde3":"print(df.shape)\nprint(df_hr.shape)","5a052679":"df = df.sort_values(by=['ForecastId'], ascending=True)\ndf_hr = df_hr.sort_values(by=['ForecastId'], ascending=True)","14b78de6":"df.to_csv('submission.csv', index=False)\ndf_hr.to_csv('hr_submission.csv', index=False)","47460c6d":"df.shape","a96f7ed9":"for row in df_hr.values:\n    print(row)","716598dc":"df_test.shape","680a0161":"df.columns","85f24d9c":"df","1f1051b1":"df_hr","66fa2f62":"# ***Using Sigmoid, Multi-Sigmoid curve fitting with correction***","a8aebb26":"***Plot Curve - Fatalities***","41bb00c1":"Current\n\n1.3 make it special for US (10x) and South Korea with step linear function.\n\nEarlier\n\n1.2 [Use Float instead of integers]\n\n1.x [Added 5x multiplier on extimation boundary]\n\n1.x [Changing the predictions for public and private leaderboard]","b60698c3":"***Plot Curve - Cinfirmed Cases***","32ca0f53":"**Load Dataset**","1593192a":"**Identify Each Location by Index**","ccdc1b9e":"# ***Applying all features, fit curves for all locations and generate predictions with plots along with Human Readable output***","2ca33471":"***Checking on which curve applies to which location - Sigmoid or multi-Sigmoid***","196f6241":"***Correcting the bad points in data and generalizing curve-fitting base and bound estimates***","fe89540b":"***Analyze Curve Fitting of Sigmoid on a data point***","323bdf4e":"***Analyze record of a particular Location given by Index***","a92ffa02":"***Correction to be done on predictions of fitted-curve based on actual values ***","665b39f4":"***GroupBy Location***","f1fb39b8":"***Analyze Predictions on Future Days***","103c656d":"***Plot a sample multi-Sigmoid***"}}