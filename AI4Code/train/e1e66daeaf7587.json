{"cell_type":{"2e4aeb9d":"code","e6dfc1c1":"code","2ab53093":"code","62a222ac":"code","940b742a":"code","9f20efeb":"code","68e2b448":"code","cbd561d3":"code","fbdadf13":"code","23dd470f":"code","9fbd0083":"code","79b76580":"code","fe875272":"code","35d81921":"code","38bc8f92":"code","f059bb1b":"code","00206467":"code","fb84b879":"code","e2d13dc5":"code","759bd6e6":"code","109770bd":"code","ad22a587":"code","ce2d29c5":"code","be90b2f9":"code","1c7a58e6":"code","3398cc5f":"code","e327fbfe":"code","d7816029":"code","6dc03b02":"code","d663b44d":"code","54c2a311":"code","f6325641":"code","578e406e":"code","d4ef4a2e":"code","84125e9f":"code","76432da0":"code","5dd14d6b":"code","b6d420d6":"code","57dc6b8b":"code","28a78685":"code","74ea9bb1":"code","3b4f68bf":"code","7353d225":"code","907ff760":"code","c95e55bc":"code","1e1a9e59":"code","259d7cc1":"code","9c522d63":"code","266099a2":"code","74e9f7e3":"code","aa4fb9cb":"code","29b20ec3":"code","2ec4d612":"code","707dbcbb":"code","ec26c452":"code","30e5f1c6":"code","5c41b8bc":"code","424b8173":"code","dbc7f88e":"code","54714aea":"code","c8f97fe7":"code","e69a1ee7":"code","2b3a5fb8":"code","a7b78f46":"code","4222d30f":"code","3211a449":"code","8bf67c7a":"code","eac74028":"code","003fc1e1":"code","80cdf6b0":"code","6692c734":"code","1b8c6291":"code","530c3878":"code","c28f5450":"code","7163ff98":"code","15a2f913":"code","dcba4f64":"code","1117e825":"code","092908b2":"code","3ee2bd92":"code","f7d23799":"code","144de3ba":"code","20aa7103":"code","112747c9":"code","9680688f":"code","8293c92a":"code","1c9e5352":"code","e017dbc6":"code","aaba3378":"code","e273473f":"code","ab96384e":"code","c24c8f5c":"code","b105c452":"code","f0825b5c":"code","0cbacfcb":"code","1459156a":"code","08f7906e":"code","74818866":"code","937222b7":"code","d2ef8662":"code","bedd3268":"code","2b112d4f":"markdown","f0022594":"markdown","4833d6f5":"markdown","fe87c69d":"markdown","749b35bc":"markdown","d2ad063d":"markdown","208f58f2":"markdown","05085f0a":"markdown","36d2c32c":"markdown","1904eaa6":"markdown","af1e6c85":"markdown","7652e2c6":"markdown","a0e973d5":"markdown","19b23631":"markdown","cc9d2660":"markdown","ba35d7d1":"markdown","aff96693":"markdown","318dfe57":"markdown","0e196819":"markdown","5131966d":"markdown","71a67684":"markdown","c05664bd":"markdown","0d35591e":"markdown","941e3b69":"markdown","5805f533":"markdown","c5f1d3d3":"markdown","0ee9ae43":"markdown","4e870c88":"markdown","60512165":"markdown","caf901e8":"markdown","32015bff":"markdown","a866dbb7":"markdown","90270a2d":"markdown","bdc5c8b6":"markdown","3a251793":"markdown","3778f3ec":"markdown"},"source":{"2e4aeb9d":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\npd.set_option('display.float_format', lambda x: '%.3f' % x) # to display numbers in digits\n\nfrom scipy import stats\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","e6dfc1c1":"airbnb = pd.read_csv('..\/input\/airbnb\/AirBNB.csv')\nairbnb.head()","2ab53093":"airbnb.tail()","62a222ac":"print('This dataset has', airbnb.shape[0], 'rows\/observations, and ', airbnb.shape[1], 'columns')","940b742a":"airbnb.info()","9f20efeb":"airbnb = airbnb.drop(['id'], axis=1)","68e2b448":"for col in airbnb.select_dtypes(include=['object']):\n    airbnb[col] = airbnb[col].astype('category')","cbd561d3":"cat_col = airbnb.select_dtypes(include=['category'])\n\nfor col in cat_col:\n    print('Unique Values of {} are \\n'.format(col),airbnb[col].unique())\n    print('*'*90)","fbdadf13":"airbnb.describe(include='all').T","23dd470f":"airbnb.hist(figsize=(20,15));","9fbd0083":"from sklearn.model_selection import train_test_split","79b76580":"train_set, test_set = train_test_split(airbnb, test_size=0.2, random_state=42)\nprint(len(train_set), 'rows in training set')\nprint(len(test_set), 'rows in test set')","fe875272":"data = train_set.copy()\ndata.head()","35d81921":"# While doing uni-variate analysis of numerical variables we want to study their central tendency \n# and dispersion.\n# Let us write a function that will help us create boxplot and histogram for any input numerical \n# variable.\n# This function takes the numerical column as the input and returns the boxplots \n# and histograms for the variable.\n# Let us see if this help us write faster and cleaner code.\ndef histogram_boxplot(feature, figsize=(10,8), bins = None):\n    \"\"\" Boxplot and histogram combined\n    feature: 1-d feature array\n    figsize: size of fig (default (9,8))\n    bins: number of bins (default None \/ auto)\n    \"\"\"\n    f2, (ax_box2, ax_hist2) = plt.subplots(nrows = 2, # Number of rows of the subplot grid= 2\n                                           sharex = True, # x-axis will be shared among all subplots\n                                           gridspec_kw = {\"height_ratios\": (.25, .75)}, \n                                           figsize = figsize \n                                           ) # creating the 2 subplots\n    sns.boxplot(feature, ax=ax_box2, showmeans=True, color='violet') # boxplot will be created and a star will indicate the mean value of the column\n    sns.distplot(feature, kde=F, ax=ax_hist2, bins=bins,color = 'orange') if bins else sns.distplot(feature, kde=False, ax=ax_hist2,color='tab:cyan') # For histogram\n    ax_hist2.axvline(np.mean(feature), color='purple', linestyle='--') # Add mean to the histogram\n    ax_hist2.axvline(np.median(feature), color='black', linestyle='-') # Add median to the histogram","38bc8f92":"# Function to create barplots that indicate percentage for each category.\n\ndef perc_on_bar(z):\n    '''\n    plot\n    feature: categorical feature\n    the function won't work if a column is passed in hue parameter\n    '''\n\n    total = len(data[z]) # length of the column\n    plt.figure(figsize=(15,5))\n    ax = sns.countplot(data[z],palette='Paired')\n    for p in ax.patches:\n        percentage = '{:.1f}%'.format(100 * p.get_height()\/total) # percentage of each class of the category\n        x = p.get_x() + p.get_width() \/ 2 - 0.05 # width of the plot\n        y = p.get_y() + p.get_height()           # hieght of the plot\n        \n        ax.annotate(percentage, (x, y), size = 12) # annotate the percantage \n    plt.show() # show the plot","f059bb1b":"histogram_boxplot(data['accommodates'])","00206467":"histogram_boxplot(data['bathrooms'])","fb84b879":"histogram_boxplot(data['bedrooms'])","e2d13dc5":"histogram_boxplot(data['beds'])","759bd6e6":"histogram_boxplot(data['review_scores_rating'])","109770bd":"histogram_boxplot(data['log_price'])","ad22a587":"perc_on_bar('room_type')","ce2d29c5":"perc_on_bar('cancellation_policy')","be90b2f9":"perc_on_bar('cleaning_fee')","1c7a58e6":"perc_on_bar('instant_bookable')","3398cc5f":"plt.figure(figsize=(10,5))\n\nsns.heatmap(data.corr(),\n            annot=True,\n            linewidths=0.5,vmin=-1,vmax=1,\n            center=0,\n            cbar=True,\n            )\n\nplt.show()","e327fbfe":"data.corr()['log_price'].sort_values(ascending=False)","d7816029":"plt.figure(figsize=(10,5))\nsns.pairplot(data, diag_kind='kde');","6dc03b02":"data.columns","d663b44d":"data['bedrooms_per_accommodates'] = data['bedrooms'] \/ data['accommodates']\ndata['beds_per_accommodates'] = data['beds'] \/ data['accommodates']\ndata['bathrooms_per_accommodates'] = data['bathrooms'] \/ data['accommodates']","54c2a311":"data[['bedrooms_per_accommodates', 'beds_per_accommodates', 'bathrooms_per_accommodates']].describe().T","f6325641":"plt.figure(figsize=(10,5))\n\nsns.heatmap(data.corr(),\n            annot=True,\n            linewidths=0.5,vmin=-1,vmax=1,\n            center=0,\n            cbar=True,\n            )\n\nplt.show()","578e406e":"data.corr()['log_price'].sort_values(ascending=False)","d4ef4a2e":"data = train_set.drop('log_price', axis=1)\ndata_labels = train_set['log_price'].copy()","84125e9f":"data_num = data.drop(['room_type', 'cancellation_policy', 'cleaning_fee', 'instant_bookable'], axis=1)","76432da0":"data_num.info()","5dd14d6b":"data_num.isnull().sum()","b6d420d6":"# Using the SimpleImputer function to find the values using the Median Strategy\n\nfrom sklearn.impute import SimpleImputer\nimputer = SimpleImputer(strategy='median')","57dc6b8b":"imputer.fit(data_num)","28a78685":"imputer.statistics_","74ea9bb1":"data_num.median().values","3b4f68bf":"X = imputer.transform(data_num)","7353d225":"# Converting the transformed array into dataset\n\ndata_tr = pd.DataFrame(X, columns=data_num.columns, index=data_num.index)","907ff760":"data_tr.head()","c95e55bc":"# Double checking with info()\n\ndata_tr.info()","1e1a9e59":"data_cat = data[['room_type', 'cancellation_policy', 'cleaning_fee', 'instant_bookable']]\ndata_cat.head(10)","259d7cc1":"data_cat.isnull().sum()","9c522d63":"cat_imputer = SimpleImputer(strategy='most_frequent')","266099a2":"cat_imputer.fit(data_cat)","74e9f7e3":"cat_imputer.statistics_","aa4fb9cb":"data_cat.mode().values","29b20ec3":"X_cat = cat_imputer.transform(data_cat)","2ec4d612":"# Converting the transformed array into dataset\n\ndata_cat_fil = pd.DataFrame(X_cat, columns=data_cat.columns, index=data_cat.index)\ndata_cat_fil.info()","707dbcbb":"# Encoding the Categorical values with OneHotEncoder function from Scikit-Learn\n\nfrom sklearn.preprocessing import OneHotEncoder\ncat_encoder = OneHotEncoder()","ec26c452":"data_cat_1hot = cat_encoder.fit_transform(data_cat_fil)\ndata_cat_1hot","30e5f1c6":"# Showing the encoded values in an array\n\ndata_cat_1hot.toarray()","5c41b8bc":"cat_encoder.categories_","424b8173":"data.info()","dbc7f88e":"data_num.info()","54714aea":"from sklearn.base import BaseEstimator, TransformerMixin","c8f97fe7":"# Getting the required indices\n\ncol_names = \"accommodates\", \"bathrooms\", \"bedrooms\", \"beds\"\naccommodates_ix, bathrooms_ix, bedrooms_ix, beds_ix = [\n    data.columns.get_loc(c) for c in col_names] # get the column indices","e69a1ee7":"class CombinedAttributesAdder(BaseEstimator, TransformerMixin):\n    def __init__(self, add_bathrooms_per_accommodates=True): # no *args or **kargs\n        self.add_bathrooms_per_accommodates = add_bathrooms_per_accommodates\n    def fit(self, X, y=None):\n        return self  # nothing else to do\n    def transform(self, X):\n        bedrooms_per_accommodates = X[:, bedrooms_ix] \/ X[:, accommodates_ix]\n        beds_per_accommodates = X[:, beds_ix] \/ X[:, accommodates_ix]\n        if self.add_bathrooms_per_accommodates:\n            bathrooms_per_accommodates = X[:, bathrooms_ix] \/ X[:, accommodates_ix]\n            return np.c_[X, bedrooms_per_accommodates, beds_per_accommodates,\n                         bathrooms_per_accommodates]\n        else:\n            return np.c_[X, bedrooms_per_accommodates, beds_per_accommodates]\n\nattr_adder = CombinedAttributesAdder(add_bathrooms_per_accommodates=False)\nairbnb_extra_attribs = attr_adder.transform(data.values)","2b3a5fb8":"airbnb_extra_attribs","a7b78f46":"airbnb_extra_attribs = pd.DataFrame(\n    airbnb_extra_attribs,\n    columns=list(data.columns)+[\"bedrooms_per_accommodates\", \"beds_per_accommodates\"],\n    index=data.index)\nairbnb_extra_attribs.head()","4222d30f":"# Cross-Check with the original dataset to see the added Combied Attributes\ndata.head()","3211a449":"from sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler","8bf67c7a":"# Scaling & transformation will be applied on the numerical dataset (data_num)\n\ncol_names = \"accommodates\", \"bathrooms\", \"bedrooms\", \"beds\"\naccommodates_ix, bathrooms_ix, bedrooms_ix, beds_ix = [\n    data_num.columns.get_loc(c) for c in col_names] # get the column indices\n\n\nnum_pipeline = Pipeline([\n                        ('imputer', SimpleImputer(strategy=\"median\")),\n                        ('attribs_adder', CombinedAttributesAdder()),\n                        ('std_scaler', StandardScaler())\n                        ])\ndata_num_tr = num_pipeline.fit_transform(data_num)","eac74028":"data_num_tr","003fc1e1":"cat_pipeline = Pipeline([\n    ('imputer', SimpleImputer(strategy='most_frequent')),\n    ('encoder', OneHotEncoder())\n])\ndata_cat_tr = cat_pipeline.fit_transform(data_cat)","80cdf6b0":"data_cat_tr.toarray()","6692c734":"# using `ColumnTransformer` for the final pipeline using the previously Transformers\/Pipelines\n\nfrom sklearn.compose import ColumnTransformer","1b8c6291":"num_attribs = list(data_num)\ncat_attribs = list(data_cat)","530c3878":"full_pipeline = ColumnTransformer([\n                ('num', num_pipeline, num_attribs),\n                ('cat', cat_pipeline, cat_attribs),\n])\ndata_prepared = full_pipeline.fit_transform(data)","c28f5450":"data_prepared[0]","7163ff98":"from sklearn.linear_model import LinearRegression","15a2f913":"lin_reg = LinearRegression()\nlin_reg.fit(data_prepared, data_labels)","dcba4f64":"# Checking the values predicted on some data\n\nsome_data = data.iloc[:5]\nsome_labels = data_labels.iloc[:5]\nsome_data_prepared = full_pipeline.transform(some_data)\nprint('Predictions:', lin_reg.predict(some_data_prepared))\nprint('Labels:', list(some_labels))","1117e825":"#finding the RMSE for Linear Regression\nfrom sklearn.metrics import mean_squared_error\n\nhousing_predictions = lin_reg.predict(data_prepared)\nlin_mse = mean_squared_error(data_labels, housing_predictions)\nlin_rmse = np.sqrt(lin_mse)\nprint(\"RMSE for Linear Regression:\", lin_rmse)","092908b2":"from sklearn.model_selection import cross_val_score","3ee2bd92":"lin_scores = cross_val_score(lin_reg, data_prepared, data_labels, scoring='neg_mean_squared_error', cv=10)\nlin_rmse = np.sqrt(-lin_scores)","f7d23799":"print('Cross-Validation RMSE LR Scores: \\n', lin_rmse, '\\n')\nprint('Cross-Validation RMSE LR Scores Mean: \\n', lin_rmse.mean(), '\\n')\nprint('Cross-Validation RMSE LR Scores Std. Dev.: \\n', lin_rmse.std())","144de3ba":"from sklearn.tree import DecisionTreeRegressor","20aa7103":"tree_reg = DecisionTreeRegressor(random_state=42)\ntree_reg.fit(data_prepared, data_labels)","112747c9":"# Checking the values predicted on some data\n\nsome_data = data.iloc[:5]\nsome_labels = data_labels.iloc[:5]\nsome_data_prepared = full_pipeline.transform(some_data)\nprint('Predictions:', tree_reg.predict(some_data_prepared))\nprint('Labels:', list(some_labels))","9680688f":"#finding the RMSE for Decision Tree\n\nfrom sklearn.metrics import mean_squared_error\nhousing_predictions = tree_reg.predict(data_prepared)\ntree_mse = mean_squared_error(data_labels, housing_predictions)\ntree_rmse = np.sqrt(tree_mse)\nprint(\"RMSE for Decision Tree Regressor:\", tree_rmse)","8293c92a":"tree_scores = cross_val_score(tree_reg, data_prepared, data_labels, scoring='neg_mean_squared_error', cv=10)\ntree_rmse = np.sqrt(-tree_scores)","1c9e5352":"print('Cross-Validation RMSE DT Scores: \\n', tree_rmse, '\\n')\nprint('Cross-Validation RMSE DT Scores Mean: \\n', tree_rmse.mean(), '\\n')\nprint('Cross-Validation RMSE DT Scores Std. Dev.: \\n', tree_rmse.std())","e017dbc6":"from sklearn.ensemble import RandomForestRegressor","aaba3378":"rf_reg = RandomForestRegressor(n_estimators=100, random_state=42)\nrf_reg.fit(data_prepared, data_labels)","e273473f":"# Checking the values predicted on some data\n\nsome_data = data.iloc[:5]\nsome_labels = data_labels.iloc[:5]\nsome_data_prepared = full_pipeline.transform(some_data)\nprint('Predictions:', rf_reg.predict(some_data_prepared))\nprint('Labels:', list(some_labels))","ab96384e":"#finding the RMSE for Random Forest\n\nfrom sklearn.metrics import mean_squared_error\nhousing_predictions = rf_reg.predict(data_prepared)\nrf_mse = mean_squared_error(data_labels, housing_predictions)\nrf_rmse = np.sqrt(rf_mse)\nprint(\"RMSE for Random Forest Regressor:\", rf_rmse)","c24c8f5c":"rf_scores = cross_val_score(rf_reg, data_prepared, data_labels, scoring='neg_mean_squared_error', cv=10)\nrf_rmse = np.sqrt(-rf_scores)","b105c452":"print('Cross-Validation RMSE RF Scores: \\n', rf_rmse, '\\n')\nprint('Cross-Validation RMSE RF Scores Mean: \\n', rf_rmse.mean(), '\\n')\nprint('Cross-Validation RMSE RF Scores Std. Dev.:', rf_rmse.std())","f0825b5c":"final_model = lin_reg","0cbacfcb":"X_test = test_set.drop('log_price', axis=1)\ny_test = test_set['log_price'].copy()","1459156a":"X_test_prepared = full_pipeline.transform(X_test)\nfinal_predictions = final_model.predict(X_test_prepared)","08f7906e":"final_mse = mean_squared_error(y_test, final_predictions)\nfinal_rmse = np.sqrt(final_mse)\nfinal_rmse","74818866":"from scipy.stats import randint\n\nconfidence = 0.95\nsquared_error = (final_predictions - y_test) ** 2\nnp.sqrt(stats.t.interval(confidence, len(squared_error) - 1,\n                        loc=squared_error.mean(),\n                        scale=stats.sem(squared_error)))","937222b7":"start = 2384\nend = 2395\n\nsome_data = data.iloc[start:end]\nsome_labels = data_labels.iloc[start:end]","d2ef8662":"full_pipeline_with_predictor = Pipeline([\n    ('preparation', full_pipeline),\n    ('predictor', LinearRegression())\n])\n\nfull_pipeline_with_predictor.fit(data, data_labels)\nfull_pipeline_with_predictor.predict(some_data)","bedd3268":"pred_df = pd.DataFrame(full_pipeline_with_predictor.predict(some_data),\n                             columns=['Price_Prediction'], \n                             index=some_labels.index)\nprediction_df = pd.concat([some_labels, pred_df], axis=1)\nprediction_df","2b112d4f":"### Creating Training\/Test Sets","f0022594":"#### 2. Decision Tree","4833d6f5":"#### `beds`","fe87c69d":"### Load Data","749b35bc":"### Correlation Check","d2ad063d":"#### `accommodates`","208f58f2":"#### `log_price`","05085f0a":"### Data Cleaning ","36d2c32c":"Dataset has 7 numerical columns, and 4 categorical columns which there defined as *object*","1904eaa6":"Dropping `id` column from dataset","af1e6c85":"### EDA","7652e2c6":"#### `instant_bookable`","a0e973d5":"### Full Pipeline with Preparation & Prediction","19b23631":"### Evaluation with Test Dataset","cc9d2660":"#### `cancellation_policy`","ba35d7d1":"### Feature Scaling and Transformations","aff96693":"- Checking number of `bedrooms` per number of `accommodates`\n- Number of `beds` per numner of `accommodates`\n- Number of `bathrooms` per `accommodates`","318dfe57":"### Training Models","0e196819":"#### `bathrooms`","5131966d":"#### Attributes Combinations","71a67684":"### Import Libraries","c05664bd":"#### `bedrooms`","0d35591e":"#### `review_scores_rating`","941e3b69":"- Airbnb is an online platform that allows people to rent short term accommodation. This ranges from regular people with a spare bedroom to property management firms who lease multiple rentals. On the one side, Airbnb enables owners to list their space and earn rental money. On the other side, it provides travelers easy access to renting private homes.\n\n- Airbnb receives commissions from two sources upon every booking, namely from the hosts and guests. For every booking, Airbnb charges the guest 6-12% of the booking fee. Moreover, Airbnb charges the host 3% for every successful transaction.\n\n- As a senior data scientist at Airbnb, you have to come up with a pricing model that can effectively predict the Rent for an accommodation and can help hosts, travelers, and also the business in devising profitable strategies.","5805f533":"**Quick Insights**\n- The most frequent `room_type` is *Entire home\/apt*\n- `accommodates` has average number of 3 guests, and 75% of the guests are group of 4\n- One is the common number of `bathrooms`\n- Most places are considering *strict* `canellation_policy`\n- Most places are charging `cleaning_fees`\n- `instant_bookable` is not preferred by most place-owners\n- The average `review_scores_rating` is above 94%\n- One is also the common number of `beds'\n- `log_price` in average is 4.78 and goes up tp 7.60","c5f1d3d3":"#### 3. Random Forest","0ee9ae43":"#### Note:\nI have encountred an error while executing `num_pipeline` due to the change of indicies. Therefore, I have hard-coded the `col_names` again with `data_num` set to collect the right index for each attribute","4e870c88":"### Thanks !!\n\nEnjoy the code, and feel free to contact :)","60512165":"#### Numeric Data","caf901e8":"## Data Dictionary\n- 1. `id`: Property ID\n- 2. `room_type` Type of Room in the property\n- 3. `accommodates` How many adults can this property accomodate\n- 4. `bathrooms` Number of bathrooms in the property\n- 5. `cancellation_policy` Cancellation policy of the property\n- 6. `cleaning_fee` This denotes whether the property's cleaning fee is included in the rent or not\n- 7. `instant_bookable` It indicates whether an instant booking facility is available or not\n- 8. `review_scores_rating` The review rating score of the property\n- 9. `bedrooms Number` of bedrooms in the property\n- 10. `beds` Total number of beds in the property\n- 11. `log_price` Log of the rental price of the property for a fixed period","32015bff":"#### `room_type`","a866dbb7":"`bathrooms_per_accommodates` gives strong correlatio with `log_price` at -0.373, which is even stronger than number of `bathrooms` in the original dataset","90270a2d":"#### 1. Linear Regression","bdc5c8b6":"# Airbnb Room Price Prediction ","3a251793":"#### `cleaning_fee`","3778f3ec":"#### Categorical Data"}}