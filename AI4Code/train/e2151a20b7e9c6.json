{"cell_type":{"cc730066":"code","3ad63323":"code","042f17e5":"code","47eda1dc":"code","c2352f3c":"code","fd38ac27":"code","6340da80":"code","8a426c36":"code","cf6808f3":"code","4a3bcb5b":"code","bfbf3924":"code","a3eaf0f6":"code","2a873668":"code","645cca0d":"code","ee2b534e":"code","cf2e8fc6":"code","4607a53a":"code","fc2c5060":"code","14e88921":"code","021119cc":"code","0cbcaf4b":"code","e56ca9c2":"code","c68f4987":"code","d8d27670":"code","7dc28f8b":"code","939088a0":"code","c0d09800":"code","edeb24d4":"code","0256c5f8":"code","dd645e27":"code","059ec6c3":"code","e5a8ec14":"code","907c970f":"code","9b57c58e":"code","2cac84a0":"code","6a141142":"code","bda998de":"code","178e876d":"code","45aee0ab":"code","5858676d":"code","aac89399":"code","9690c4c9":"code","efd19dce":"code","93216850":"code","01905b87":"code","92664daa":"code","f0fa234e":"code","c672425c":"code","e929890c":"code","9039befe":"code","301b912b":"code","32bce78e":"code","d0255db1":"markdown","e617f70e":"markdown","74f9272f":"markdown","4dc5c52c":"markdown","ef33aad6":"markdown","c69097b7":"markdown","15cff0cf":"markdown","08456094":"markdown","c5196619":"markdown","f3012b3a":"markdown","552a680b":"markdown","901ba9de":"markdown","3cdbedba":"markdown","61dbe4cc":"markdown","a2d5478c":"markdown","b2ae182e":"markdown","bb4a31b3":"markdown","71625bbe":"markdown","ba214b75":"markdown","edaf75fa":"markdown","10740b25":"markdown","cf3db6cb":"markdown","5f4a1158":"markdown","ab8e0129":"markdown","8be44fba":"markdown","082a8817":"markdown"},"source":{"cc730066":"country_main = 'Ukraine'\nrolling_window = False","3ad63323":"# Comparing data for the last 2 weeks\nnum_end = 427 if not rolling_window else 0","042f17e5":"import os\nimport io\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\n\nfrom datetime import date, timedelta, datetime\nfrom fbprophet import Prophet\n#from fbprophet.make_holidays import make_holidays_df\n#from fbprophet.diagnostics import cross_validation, performance_metrics\n#from fbprophet.plot import plot_cross_validation_metric\nimport holidays\nfrom collections import Counter\nimport pycountry\n\nfrom sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error\n\nimport warnings\nwarnings.simplefilter('ignore')","47eda1dc":"# Thanks to https:\/\/api-covid19.rnbo.gov.ua\/\n# https:\/\/api-covid19.rnbo.gov.ua\/charts\/main-data?mode=ukraine\nprint(f'Download confirmed daily data from RNBO of Ukraine')\nmyfile = requests.get('https:\/\/api-covid19.rnbo.gov.ua\/charts\/main-data?mode=ukraine')\nopen('data', 'wb').write(myfile.content)\ndata = pd.read_json('data')\ndata","c2352f3c":"data['n_confirmed'] = data['confirmed'].diff()\n# A new wave from 6 July\ndata = data[166:].reset_index(drop=True)\n\n# Data from Autumn 2021\n#data = data[579:].reset_index(drop=True)\ndata","fd38ac27":"# Delete the last zero value\ndata = data[:-1]\ndata['n_confirmed'] = data['n_confirmed'].astype('int')\ndata.tail(3)","6340da80":"df2 = data[['dates','n_confirmed']].dropna()\ndf2 = df2[df2['n_confirmed'] > 0].reset_index(drop=True)\ndf2['n_confirmed'].plot()","8a426c36":"if rolling_window:\n    df2['n_confirmed'] = df2['n_confirmed'].rolling(7).mean()\n    df2['n_confirmed'].plot()","cf6808f3":"# As in my original notebook https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-ukraine-prophet-holidays-tuning\ndf2.columns = ['Date', 'Confirmed']\ndf2['Country'] = 'Ukraine'","4a3bcb5b":"df2.tail(8)","bfbf3924":"date_now = None","a3eaf0f6":"# The new data (probable value)\nn = len(df2)\ndf2.loc[n, 'Date'] = '2021-11-09'\ndf2.loc[n, 'Confirmed'] = 18988\ndf2.loc[n, 'Country'] = 'Ukraine'\ndate_now = '09.11.2021'","2a873668":"if date_now is None:\n    date_now = date.today().strftime(\"%d.%m.%Y\")\ndate_now","645cca0d":"latest_date = df2['Date'].max()\nlatest_date","ee2b534e":"df2.tail(5)","cf2e8fc6":"def cut_df(date0: str, \n           df:pd.DataFrame(), \n           col: str):\n    # Deletes all rows of dataframe df with df[col] < date0\n    format0 = '%Y-%m-%d'\n    df_temp = df.copy()\n    df_temp['col_dt'] = pd.to_datetime(df_temp[col], format=format0, errors='coerce')\n    date0_dt = datetime.strptime(date0, format0)\n    df_temp = df_temp[df_temp['col_dt'] >= date0_dt]\n    \n    return df_temp","4607a53a":"# Thanks to dataset https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries\nholidays_df = pd.read_csv('..\/input\/covid19-holidays-of-countries\/holidays_df_of_70_countries_for_covid_19_2021.csv')\nholidays_df[holidays_df['country'] == country_main]","fc2c5060":"holidays_df_code_countries = holidays_df['code'].unique()\nholidays_df_code_countries","14e88921":"# From notebook https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef dict_code_countries_with_holidays(list_name_countries: list,\n                                      holidays_df: pd.DataFrame()):\n        \n    \"\"\"\n    Defines a dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    in the dataset \"COVID-19: Holidays of countries\" \n    \n    Returns: \n    - countries: dictionary with the names of user countries and their two-letter codes (ISO 3166) \n    - holidays_df_identificated: DataFrame with holidays data for countries from dictionary 'countries'\n    \n    Args: \n    - list_name_countries: list of the name of countries (name or common_name or official_name or alha2 or alpha3 codes from ISO 3166)\n    - holidays_df: DataFrame with holidays \"COVID-19: Holidays of countries\"\n    \"\"\"\n    \n    import pycountry\n    \n    # Identification of countries for which there are names according to ISO\n    countries = {}\n    dataset_all_countries = list(holidays_df['code'].unique())\n    list_name_countries_identificated = []\n    list_name_countries_not_identificated = []\n    for country in list_name_countries:\n        try: \n            country_id = pycountry.countries.get(alpha_2=country)\n            if country_id.alpha_2 in dataset_all_countries:\n                countries[country] = country_id.alpha_2\n        except AttributeError:\n            try: \n                country_id = pycountry.countries.get(name=country)\n                if country_id.alpha_2 in dataset_all_countries:\n                    countries[country] = country_id.alpha_2\n            except AttributeError:\n                try: \n                    country_id = pycountry.countries.get(official_name=country)\n                    if country_id.alpha_2 in dataset_all_countries:\n                        countries[country] = country_id.alpha_2\n                except AttributeError:\n                    try: \n                        country_id = pycountry.countries.get(common_name=country)\n                        if country_id.alpha_2 in dataset_all_countries:\n                            countries[country] = country_id.alpha_2\n                    except AttributeError:\n                        try: \n                            country_id = pycountry.countries.get(alpha_3=country)\n                            if country_id.alpha_2 in dataset_all_countries:\n                                countries[country] = country_id.alpha_2\n                        except AttributeError:\n                            list_name_countries_not_identificated.append(country)\n    holidays_df_identificated = holidays_df[holidays_df['code'].isin(countries.values())]\n    \n    print(f'Thus, the dataset has holidays in {len(countries)} countries from your list with {len(list_name_countries)} countries')\n        \n    return countries, holidays_df_identificated.reset_index(drop=True)","021119cc":"countries_dict, holidays_df_base = dict_code_countries_with_holidays([country_main],holidays_df)\ncountries_dict","0cbcaf4b":"holidays_df_base['type'] = 'holiday'\nholidays_df = holidays_df_base.copy()\nholidays_df","e56ca9c2":"# From https:\/\/www.kaggle.com\/vbmokin\/covid-19-prophet-forecast-next-2-weeks\ndef adaption_df_to_holidays_df_for_prophet(df, col, countries_dict):\n    # Adaptation the dataframe df (by column=col) to holidays_df by list of countries in dictionary countries_dict\n    \n    # Filter df for countries which there are in the dataset with holidays\n    df = df[df[col].isin(list(countries_dict.keys()))].reset_index(drop=True)\n    \n    # Add alpha_2 (code from ISO 3166) for each country\n    df['iso_alpha'] = None\n    for key, value in countries_dict.items():\n        df.loc[df[col] == key, 'iso_alpha'] = value    \n    \n    return df","c68f4987":"df2 = adaption_df_to_holidays_df_for_prophet(df2, 'Country', countries_dict)\ndf2.columns = ['Date', 'Confirmed', 'Country', 'iso_alpha']\ncountry_iso_alpha = df2.loc[0,'iso_alpha']\ndf2","d8d27670":"def aux_holidays_df_generator(holidays_df, dates_list, name, source, window_size, shift7=True):\n    # Add dates from dates_list with anomalies of various kinds to the holiday dataset holidays_df\n    # name - the name of the anomaly\n    # source - the source of the primary information used for processing\n    \n    last_row = len(holidays_df)\n    if shift7:\n        holidays_dates = holidays_df['ds_holidays'].tolist()\n    else: holidays_dates = holidays_df['ds'].tolist()\n    common_dates = list(set(holidays_dates).intersection(set(dates_list)))\n    dates_list = list(set(dates_list).difference(set(common_dates)))\n        \n    for i in range(len(dates_list)):\n        holidays_df = holidays_df.append([holidays_df.loc[last_row-1,:]], ignore_index=True)\n        ds_dt = datetime.strptime(dates_list[i], '%Y-%m-%d')\n        holidays_df.loc[last_row+i, 'ds_holidays'] = dates_list[i]\n        holidays_df.loc[last_row+i, 'holiday'] = name\n        holidays_df.loc[last_row+i, 'source'] = source\n        holidays_df.loc[last_row+i, 'lower_window'] = -window_size\n        holidays_df.loc[last_row+i, 'upper_window'] = window_size\n    \n        # Type of holidays or pseudo-holidays\n        if name == 'the weakening of quarantine':\n            holidays_df.loc[last_row+i, 'type'] = 'SI'\n        elif name == 'Very comfortable conditions for rest':\n            holidays_df.loc[last_row+i, 'type'] = 'meteo'\n        elif name == 'Holidays as days of less efficient work of laboratories':\n            holidays_df.loc[last_row+i, 'type'] = 'lab'\n            holidays_df.loc[last_row+i, 'ds'] = (ds_dt + timedelta(days=2)).strftime('%Y-%m-%d')\n        elif name == 'Weekend quarantine as holidays':\n            holidays_df.loc[last_row+i, 'type'] = 'weekend'\n            \n        if shift7:\n            # Make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = (ds_dt + timedelta(days=7)).strftime('%Y-%m-%d')\n        else:\n            # Don't make shift with 7 day ahead\n            holidays_df.loc[last_row+i, 'ds'] = ds_dt.strftime('%Y-%m-%d')\n                    \n    return holidays_df.sort_values(by=['ds'])","7dc28f8b":"def plot_with_anomalies(df, cols_y_list, cols_y_list_name, dates_x, col_anomalies, val_anomal, log_y=False):\n    # Draws a plot with title - the features cols_y_list (y) and dates_x (x) from the dataframe df\n    # and with vertical lines in the date with col_anomalies == 1 \n    # with the length between the minimum and maximum of feature cols_y_list[0]\n    # with log_y = False or True\n    # cols_y_list - dictionary of the names of cols from cols_y_list (keys - name of feature, value - it's name for the plot legend), \n    # name of cols_y_list[0] is the title of the all plot\n    \n    fig = px.line(df, x=dates_x, y=cols_y_list[0], title=cols_y_list_name[cols_y_list[0]], log_y=log_y, template='gridon',width=700, height=800)\n    y_max = df[cols_y_list[0]].max()\n    for i in range(len(cols_y_list)-1):\n        fig.add_trace(go.Scatter(x=df[dates_x], y=df[cols_y_list[i+1]], mode='lines', name=cols_y_list_name[cols_y_list[i+1]]))\n        max_i = df[cols_y_list[i+1]].max()\n        y_max = max_i if max_i > y_max else y_max\n    \n    anomal_dates_list = df[df[col_anomalies] == val_anomal][dates_x].tolist()\n    y_min = min(df[cols_y_list[0]].min(),0)\n    for i in range(len(anomal_dates_list)):\n        anomal_date = anomal_dates_list[i]\n        fig.add_shape(dict(type=\"line\", x0=anomal_date, y0=y_min, x1=anomal_date, y1=y_max, line=dict(color=\"red\", width=1)))\n    fig.show()","939088a0":"# Thank to https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data\ndata = pd.read_csv(f\"https:\/\/storage.googleapis.com\/covid19-open-data\/v2\/UA\/main.csv\")","c0d09800":"data['stringency_index_jump'] = 0\nfor i in range(len(data)-1):\n    if (data.loc[i+1,'stringency_index'] is not None) and (data.loc[i,'stringency_index'] is not None) and \\\n    (data.loc[i+1,'stringency_index'] < data.loc[i,'stringency_index']):\n        data.loc[i+1, 'stringency_index_jump'] = 1\nsource_gov = 'https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker'\ndates_gov_list = data[data['stringency_index_jump'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_gov_list, 'the weakening of quarantine', source_gov, 2)\nplot_with_anomalies(data, [\"stringency_index\"], {\"stringency_index\" : \"Stringency index and dates of the weakening of quarantine in \" + country_main}, 'date', 'stringency_index_jump', 1)","edeb24d4":"data.columns.tolist()","0256c5f8":"data['rest_comfort'] = 0\ndata.loc[(data['average_temperature'] >= data['average_temperature'].quantile(.95)) & (data['rainfall'] <= data['rainfall'].quantile(.05)), 'rest_comfort'] = 1\ndates_weather_list = data[data['rest_comfort'] == 1]['date'].tolist()\nholidays_df = aux_holidays_df_generator(holidays_df, dates_weather_list, 'Very comfortable conditions for rest', 'https:\/\/www.ncei.noaa.gov\/', 2)\nplot_with_anomalies(data, [\"average_temperature\", \"rainfall\"], {\"average_temperature\" : \"Average temperature over time in \" + country_main, \"rainfall\" : \"rainfall\"}, 'date', 'rest_comfort', 1)","dd645e27":"df2.info()","059ec6c3":"holidays_dates = holidays_df_base['ds_holidays'].tolist()\nholidays_dates","e5a8ec14":"# Weekdays during which few tests were performed (less than 20 thousand per day) - an additional anomaly \nholidays_dates += ['2021-01-04', '2021-01-08']","907c970f":"# Weekends near the holidays in Ukraine - an additional anomaly \nholidays_dates += ['2020-04-20', '2021-05-11', '2021-06-08', '2021-06-29',\n                   '2021-01-08', '2021-05-03', '2021-05-03', '2021-05-10', \n                   '2021-06-21', '2021-08-23', '2021-10-15', '2021-12-27']","9b57c58e":"data['holidays_date'] = 0\nholidays_df = aux_holidays_df_generator(holidays_df, holidays_dates, 'Holidays as days of less efficient work of laboratories', \n                                        'https:\/\/github.com\/dr-prodigy\/python-holidays', 0, False)","2cac84a0":"holidays_weekend_quarantine = ['2020-11-14', '2020-11-15',\n                               '2020-11-21', '2020-11-22',\n                               '2020-11-28', '2020-11-29']","6a141142":"holidays_lockdown = ['2021-01-08', '2021-01-09','2021-01-10','2021-01-11','2021-01-12',\n                     '2021-01-13', '2021-01-14','2021-01-15','2021-01-16','2021-01-17',\n                     '2021-01-18', '2021-01-19','2021-01-20','2021-01-21','2021-01-22',\n                     '2021-01-23', '2021-01-24']","bda998de":"data['holidays_date'] = 0\nholidays_df = aux_holidays_df_generator(holidays_df, holidays_weekend_quarantine + holidays_lockdown, \n                                        'Weekend quarantine as holidays', \n                                        'https:\/\/www.kmu.gov.ua\/', 0, False)","178e876d":"holidays_df = cut_df(df2.loc[0, 'Date'], holidays_df, 'ds')\nholidays_df","45aee0ab":"fig = px.line(df2, x=\"Date\", y=\"Confirmed\", \n              title=\"Confirmed cases in \" + country_main, \n              log_y=False,template='gridon',width=700, height=600)\nfig.show()","5858676d":"df2['holiday'] = 0\nholidays_df_dates = holidays_df['ds'].tolist()\ndf2.loc[df2['Date'].isin(holidays_df_dates), 'holiday'] = 1\nplot_with_anomalies(df2, [\"Confirmed\"], {\"Confirmed\" : \"Confirmed cases and holidays data in \" + country_main}, 'Date', 'holiday', 1)\ndf2 = df2.drop(columns=['holiday'])","aac89399":"holidays_df_dates","9690c4c9":"# For stage 1 of tuning\nchangepoint_prior_scale_initial_level = 0.3\nweekly_season_reg_coef = 0.5\nholidays_adaptive = ['holiday', 'SI', 'meteo'] # holidays with adaptive window\n\n# For stage 2 of tuning\nseveral_days_period = 620       # Period of the first big wave in Ukraine\ndelta_wave_period = 180         # Period of the wave of Delta in Ukraine (probably)\nseveral_days_season_reg_coef = 2\nseveral_days_short_period = 4\nseveral_days_short_days_fourier_order = 10\nseveral_days_short_days_season_reg_coef = 0.5","efd19dce":"df2 = df2.drop(columns = ['Country', 'iso_alpha'])\ndf2.columns = ['ds','y']\ndf2.tail(14)","93216850":"days_to_forecast = 93 # in future (after training data) - to Feb 2022\ndays_to_forecast_for_evalution = 14 # on the latest training data - for model training\nfirst_forecasted_date = sorted(list(set(df2['ds'].values)))[-days_to_forecast_for_evalution]\nend_forecasted_date = (datetime.strptime(df2['ds'].max(), \"%Y-%m-%d\")+timedelta(days = days_to_forecast)).strftime(\"%Y-%m-%d\")\nfirst_data_date = df2['ds'].min()\n\nprint('The first date of data for modeling is: ' + first_data_date)\nprint('The first date to perform forecasts for evaluation is: ' + first_forecasted_date)\nprint('The end date to perform forecasts in future for is: ' + end_forecasted_date)","01905b87":"first_eval_index = len(df2)-days_to_forecast_for_evalution\nsecond_eval_index = len(df2)\ny_real = df2.tail(days_to_forecast_for_evalution)['y']\ny_real_sum = df2.tail(days_to_forecast_for_evalution)['y'].sum()\ncountry_df_val = df2.copy()\ncountry_df_val['ds'] = pd.to_datetime(country_df_val['ds'])\ncountry_df_val = country_df_val[(country_df_val['ds'] >= pd.to_datetime(first_forecasted_date))]\ncountry_df_val","92664daa":"def eval_error(forecast_df, title):\n    # Evaluate forecasts with validation set val_df and calculaction and printing with title the relative error\n    forecast_df[forecast_df['yhat'] < 0]['yhat'] = 0\n    result_df = forecast_df[(forecast_df['ds'] >= pd.to_datetime(first_forecasted_date))]\n    result_val_df = result_df.merge(country_df_val, on=['ds'])\n    result_val_df['rel_diff'] = (result_val_df['y'] - result_val_df['yhat'].round()).abs()\n    return (result_val_df['rel_diff'].sum())*100\/y_real_sum\n    #relative_error = sum(result_val_df['rel_diff'].values)*100\/y_real_sum\n    #return (forecast_df[first_eval_index:second_eval_index]['yhat'].sum())*100\/y_real_sum\n    #return mean_absolute_error(y_real, forecast_df[first_eval_index:second_eval_index]['yhat'])","f0fa234e":"df = df2.copy()\nlower_window = -3\nupper_window = 3\nprior_scale = 1\nchangepoint_prior_scale = 0.1\nweekly_fourier_order = 7\nweekly_seasonality_prior_scale = 0.2\nseveral_days_fourier_order = delta_wave_fourier_order = 5\nseveral_days_seasonality_prior_scale = delta_wave_seasonality_prior_scale = 0.05","c672425c":"def model_training_forecasting(delta_wave_period=180):\n    # Optimal Prophet model training and forecasting\n\n    model = Prophet(daily_seasonality=False, weekly_seasonality=False, yearly_seasonality=False, interval_width=0.8,\n                    holidays=holidays_df, changepoint_range=1, \n                    changepoint_prior_scale = changepoint_prior_scale,\n                    seasonality_mode = 'additive')\n    if weekly_fourier_order > 0:\n        model.add_seasonality(name='weekly', period=7, fourier_order=weekly_fourier_order, mode = 'additive', \n                              prior_scale = changepoint_prior_scale\/weekly_season_reg_coef)\n    if several_days_fourier_order > 0:\n        model.add_seasonality(name='several_days', period=several_days_period,\n                              fourier_order=several_days_fourier_order, mode = 'additive', \n                              prior_scale = changepoint_prior_scale\/several_days_season_reg_coef)\n        model.add_seasonality(name='delta_wave', period=delta_wave_period,\n                                  fourier_order=several_days_fourier_order, mode = 'additive', \n                                  prior_scale = changepoint_prior_scale_initial_level\/several_days_season_reg_coef)\n    model.add_seasonality(name='four_days', period=several_days_short_period, fourier_order=several_days_short_days_fourier_order, \n                          mode = 'additive', prior_scale = several_days_short_days_season_reg_coef)\n    \n    model.fit(df)\n    future = model.make_future_dataframe(periods=days_to_forecast)\n    forecast = model.predict(future)\n    \n    # Make values integer, and replace negative values with zero\n    feature_all = ['yhat_lower', 'yhat', 'yhat_upper']\n    forecast[feature_all] = forecast[feature_all].round().astype('int')\n    for feature in feature_all:\n        forecast.loc[forecast[feature] < 0, feature] = 0\n    \n    return model, forecast","e929890c":"def draw_plot(df_new, df, num, name_plot_start):\n    # Drawing plots in English and Ukranian languages\n    \n    if num > 0:\n        df_new = df_new[num:]\n        df = df[num:]\n            \n    def plot_lang(labels_list, name_plot):\n        # Drawing plot in given language\n        \n        fig = plt.figure(facecolor='w', figsize=(16,8))\n\n        # New forecast\n        t_new = pd.to_datetime(df_new['ds'].tolist())\n        plt.plot(t_new, df_new['yhat'], ls='-', c='#0072B2', label = labels_list[0])\n        if not rolling_window:\n            plt.fill_between(t_new, df_new['yhat_lower'], df_new['yhat_upper'], color='#0072B2', alpha=0.2)\n        \n        # Observation data\n        t = pd.to_datetime(df['ds'].tolist())\n        plt.scatter(t, df['y'], c='k', label = labels_list[-1])\n\n        plt.legend(loc='best')\n        plt.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n        fig.tight_layout()\n    \n    # Prepare dates for plots\n    date_today = date_now\n    forecast_today_en = f\"Forecast at {date_today}\"\n    forecast_today_ua = f\"\u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0432\u0456\u0434 {date_today}\"\n    labels_list_en = [forecast_today_en]\n    labels_list_ua = [forecast_today_ua]\n    labels_list_en.append(\"Official data\")\n    labels_list_ua.append(\"\u0414\u0430\u043d\u0456 \u0420\u041d\u0411\u041e \u0423\u043a\u0440\u0430\u0457\u043d\u0438\")\n    \n    # English version\n    plot_lang(labels_list_en, name_plot_start + 'forecast_today_all_en')\n    \n    # Ukranian version\n    plot_lang(labels_list_ua, name_plot_start + 'forecast_today_all_ua')","9039befe":"def draw_plot2(df_new, df, num, name_plot_start):\n    # Drawing plots for comparison in English and Ukranian languages\n    \n    if num > 0:\n        df_new = df_new[num:]\n        df = df[num:]\n            \n    def plot_lang(labels_list, name_plot):\n        # Drawing plot in given language\n        \n        fig = plt.figure(facecolor='w', figsize=(16,8))\n\n        # New forecast\n        t_new = pd.to_datetime(df_new['ds'].tolist())\n        plt.plot(t_new, df_new['yhat'], ls='-', c='#0072B2', label = labels_list[0])\n        if not rolling_window:\n            plt.fill_between(t_new, df_new['yhat_lower'], df_new['yhat_upper'], color='#0072B2', alpha=0.2)\n        \n        # Observation data\n        t = pd.to_datetime(df['ds'].tolist())\n        plt.scatter(t, df['y'], c='k', label = labels_list[-1])\n\n        plt.legend(loc='best')\n        plt.grid(True, which='major', c='gray', ls='-', lw=1, alpha=0.2)\n        fig.tight_layout()\n    \n    \n    # Prepare dates for plots\n    date_today = date_now\n    forecast_today_en = f\"Forecast at {date_today}\"\n    forecast_today_ua = f\"\u041f\u0440\u043e\u0433\u043d\u043e\u0437 \u0432\u0456\u0434 {date_today}\"\n    labels_list_en = [forecast_today_en]\n    labels_list_ua = [forecast_today_ua]\n    labels_list_en.append(\"Official data\")\n    labels_list_ua.append(\"\u0414\u0430\u043d\u0456 \u0420\u041d\u0411\u041e \u0423\u043a\u0440\u0430\u0457\u043d\u0438\")\n    \n    # English version\n    plot_lang(labels_list_en, name_plot_start + 'forecast_today_all_en')\n    \n    # Ukranian version\n    plot_lang(labels_list_ua, name_plot_start + 'forecast_today_all_ua')","301b912b":"def model_tuning(delta_wave_period):\n    model_future_opt, forecast_future_opt = model_training_forecasting(delta_wave_period=delta_wave_period)\n    fig_opt = model_future_opt.plot(forecast_future_opt, ylabel='Period = '+ str(delta_wave_period))\n    fig_opt_components = model_future_opt.plot_components(forecast_future_opt)\n    forecast_future_opt_future = forecast_future_opt[['ds', 'yhat_lower', 'yhat', 'yhat_upper']]\n    forecast_future_opt_future_days = forecast_future_opt_future.tail(days_to_forecast)\n    display(forecast_future_opt_future_days.tail())\n    forecast_future_opt_future_len=len(forecast_future_opt_future)\n    forecast_future_opt_future[len(df2)-days_to_forecast_for_evalution:len(df2)][['ds', 'yhat']]\n    forecast_future_opt_future.to_csv(f'forecast_future_opt_future_with_delta_period_{delta_wave_period}.csv', index=False)\n    \n    # Calculation errors\n    y_val = forecast_future_opt_future[len(df2)-days_to_forecast_for_evalution:len(df2)]['yhat']\n    y = df2.tail(days_to_forecast_for_evalution)['y']\n    print(f\"r2_score - {r2_score(y, y_val)}, mean_absolute_error - {mean_absolute_error(y, y_val)}, root_mean_squared_error - {(mean_squared_error(y, y_val))**(.5)}\")\n    \n    # Draw plots\n    # Comparing for all data\n    draw_plot(forecast_future_opt_future, df2, 0, 'All_')\n    \n    # Comparing data for the last 2 weeks\n    num_end = 413 if not rolling_window else 0\n    #num_end = 364 if not rolling_window else 0\n    #num_end = 49 if not rolling_window else 0\n    draw_plot2(forecast_future_opt_future, df2, num_end, 'Last_2_weeks_')\n    \n    print(f\"Thus, for {country_main} the optimal Prophet model has the forecasting errors:\")\n    print(f\"- r2_score - {round(r2_score(y, y_val),2)} (the best value - 1.0)\")\n    #print(f\"- MSE (mean_absolute_error) - {int(round(mean_absolute_error(y, y_val),0))} cases\")\n    #print(f\"- RMSE (root_mean_squared_error) - {int(round((mean_squared_error(y, y_val))**(.5), 0))} cases\")\n    #print(f\"- the main error (WAPE - relative error) = {best_result_all} % (the best value - 0.0 %).\")","32bce78e":"# The main tuning\nfor i in range(10):\n    delta_wave_period = 180 + i*10\n    print(\"\\n=========================================\")\n    print('Delta period =', delta_wave_period)\n    model_tuning(delta_wave_period)","d0255db1":"## 4. EDA<a class=\"anchor\" id=\"4\"><\/a>\n\n[Back to Table of Contents](#0.1)","e617f70e":"#### Thanks to https:\/\/api-covid19.rnbo.gov.ua\/","74f9272f":"## 5. Tuning Prophet model and results visualization<a class=\"anchor\" id=\"5\"><\/a>\n\n[Back to Table of Contents](#0.1)","4dc5c52c":"### 3.2.2. Very comfortable conditions for rest <a class=\"anchor\" id=\"3.2.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","ef33aad6":"## [Go to Top](#0)","c69097b7":"## 3. Selection data with holidays<a class=\"anchor\" id=\"3\"><\/a>\n\n[Back to Table of Contents](#0.1)","15cff0cf":"#### Thanks to:\n* [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data)\n* [NOAA](https:\/\/www.ncei.noaa.gov\/)","08456094":"## 3.1. Holidays with a shift<a class=\"anchor\" id=\"3.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","c5196619":"## 3.2. Additional dates of anomalies as holidays<a class=\"anchor\" id=\"3.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","f3012b3a":"<a class=\"anchor\" id=\"0\"><\/a>\n# COVID-19 in Ukraine: Possible Long-Term Scenarios with additive Prophet model tuning for the long-term forecast (for several months in the future)\n\nLet's try to adjust the possible period of the Delta wave for the daily increase in the number of new patients with COVID-19 in Ukraine.","552a680b":"<a class=\"anchor\" id=\"0.1\"><\/a>\n## Table of Contents\n\n1. [Import libraries](#1)\n1. [Download data](#2)\n1. [Selection data with holidays](#3)\n    - [Holidays with a shift](#3.1)\n    - [Additional dates of anomalies as holidays](#3.2)    \n        - [The weakening of quarantine](#3.2.1)\n        - [Very comfortable conditions for rest](#3.2.2)\n        - [Holidays as days of less efficient work of laboratories](#3.2.3)\n        - [Weekend quarantine as holidays](#3.2.4)        \n1. [EDA](#4)\n    - [Plots - Confirmed cases over time](#4.1)\n    - [Set initial values for tuning](#4.2)\n1. [Tuning Prophet model and results visualization](#5)","901ba9de":"Import libraries","3cdbedba":"#### Thanks to [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker)","61dbe4cc":"#### Thanks to [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data)","a2d5478c":"### 3.2.1. The weakening of quarantine<a class=\"anchor\" id=\"3.2.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","b2ae182e":"## 2. Download data<a class=\"anchor\" id=\"2\"><\/a>\n\n[Back to Table of Contents](#0.1)","bb4a31b3":"## 4.1. Plots - Confirmed cases over time<a class=\"anchor\" id=\"4.1\"><\/a>\n\n[Back to Table of Contents](#0.1)","71625bbe":"I hope you find this notebook useful and enjoyable.","ba214b75":"## 1. Import libraries<a class=\"anchor\" id=\"1\"><\/a>\n\n[Back to Table of Contents](#0.1)","edaf75fa":"# Dataset [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data)","10740b25":"## 4.2. Set initial values for tuning<a class=\"anchor\" id=\"4.2\"><\/a>\n\n[Back to Table of Contents](#0.1)","cf3db6cb":"### 3.2.3. Holidays as days of less efficient work of laboratories <a class=\"anchor\" id=\"3.2.3\"><\/a>\n\n[Back to Table of Contents](#0.1)","5f4a1158":"Your comments and feedback are most welcome.","ab8e0129":"### 3.2.4. Weekend quarantine as holidays<a class=\"anchor\" id=\"3.2.4\"><\/a>\n\n[Back to Table of Contents](#0.1)","8be44fba":"# Acknowledgements\n\n### Datasets:\n- my dataset [COVID-19 in Ukraine: daily data](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ukraine-daily-data) - it is recommended to follow the updates\n- official data of Ukraine (https:\/\/covid19.rnbo.gov.ua\/)\n- dataset [COVID-19 Open Data](https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data) (including dataset [Oxford COVID-19 government response tracker](https:\/\/www.bsg.ox.ac.uk\/research\/research-projects\/oxford-covid-19-government-response-tracker) and dataset [NOAA](https:\/\/www.ncei.noaa.gov\/)) : @article{Wahltinez2020,author = \"Oscar Wahltinez and Matt Lee and Anthony Erlinger and Mayank Daswani and Pranali Yawalkar and Kevin Murphy and Michael Brenner\", year = 2020, title = \"COVID-19 Open-Data: curating a fine-grained, global-scale data repository for SARS-CoV-2\", note = \"Work in progress\",  url = {https:\/\/github.com\/GoogleCloudPlatform\/covid-19-open-data},} \n- my dataset with holidays data [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries) - it is recommended to follow the updates\n\n### Notebooks:\n- notebook [COVID19 in UA: Long-Term Forecast with Prophet](https:\/\/www.kaggle.com\/vbmokin\/covid19-in-ua-long-term-forecast-with-prophet)\n- notebook [COVID in UA: Prophet with 4, Nd seasonality](https:\/\/www.kaggle.com\/vbmokin\/covid-in-ua-prophet-with-4-nd-seasonality)\n- notebook [COVID-19-in-Ukraine: Prophet & holidays tuning](https:\/\/www.kaggle.com\/vbmokin\/covid-19-in-ukraine-prophet-holidays-tuning)\n- notebook [COVID-19 Novel Coronavirus EDA & Forecasting Cases](https:\/\/www.kaggle.com\/khoongweihao\/covid-19-novel-coronavirus-eda-forecasting-cases) from [@Wei Hao Khoong](https:\/\/www.kaggle.com\/khoongweihao)\n\n### Libraries from GitHub:\n- https:\/\/facebook.github.io\/prophet\/\n- https:\/\/facebook.github.io\/prophet\/docs\/\n- https:\/\/github.com\/facebook\/prophet\n- https:\/\/github.com\/dr-prodigy\/python-holidays","082a8817":"### Thank to dataset [COVID-19: Holidays of countries](https:\/\/www.kaggle.com\/vbmokin\/covid19-holidays-of-countries)"}}