{"cell_type":{"9dff03d3":"code","34191624":"code","2763ebae":"code","396bdafa":"code","1a58d1fa":"code","05f10d1c":"code","8fadf393":"code","7ff85a9d":"code","4cd05466":"code","236fca26":"code","26c7ed15":"code","9e751636":"code","13100a76":"code","623d3706":"code","7e20363e":"code","8175f733":"code","cf92649c":"code","d190fb4c":"code","f1b70875":"code","ef85271a":"code","4debdb76":"code","bb29ce3f":"code","7346a52c":"code","02f83cbe":"code","18c4211c":"code","791226b2":"code","7ca90c89":"code","0a4cd7b3":"code","1f63bb2e":"code","0240dc18":"code","b6378e8b":"code","95e79af4":"code","5055ae76":"code","648f3446":"code","f512604c":"code","58dbb448":"code","0612d1e5":"markdown","ffa73ff1":"markdown","a9f275c4":"markdown","b53e0fbc":"markdown","062ee806":"markdown","2a576958":"markdown","ebcf2796":"markdown","2420d9a6":"markdown","be1fd05b":"markdown","b28c7b5c":"markdown","3622f0a9":"markdown","b14a0e6e":"markdown","0019df6c":"markdown","27225b5a":"markdown","9d17a91b":"markdown","dc3ab498":"markdown"},"source":{"9dff03d3":"import os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport missingno as msno\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier, export_graphviz\nfrom IPython.display import SVG\nfrom graphviz import Source\nimport itertools\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import train_test_split, cross_val_score, RandomizedSearchCV\nfrom sklearn.metrics import accuracy_score, roc_auc_score, recall_score, confusion_matrix\nfrom imblearn.under_sampling import RandomUnderSampler\nfrom imblearn.over_sampling import RandomOverSampler\nfrom imblearn.pipeline import Pipeline\nimport xgboost as xgb\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n%matplotlib inline","34191624":"df = pd.read_excel('..\/input\/covid19\/dataset.xlsx')","2763ebae":"df.shape","396bdafa":"df['SARS-Cov-2 exam result'].value_counts().plot.barh()","1a58d1fa":"# checking null values\nmsno.bar(df, figsize=(16, 4))","05f10d1c":"(df.isnull().sum() == df.shape[0]).any()","8fadf393":"full_null_series = (df.isnull().sum() == df.shape[0])\nfull_null_columns = full_null_series[full_null_series == True].index","7ff85a9d":"# columns with all values equal null\nprint(full_null_columns.tolist())","4cd05466":"df.drop(full_null_columns, axis=1, inplace=True)","236fca26":"(df.isnull().sum() \/ df.shape[0]).sort_values(ascending=False).head()","26c7ed15":"contain_null_series = (df.isnull().sum() != 0).index","9e751636":"target = 'SARS-Cov-2 exam result'\njust_one_target = []\n\nfor col in contain_null_series:\n    i = df[df[col].notnull()][target].nunique()\n    if i == 1:\n        just_one_target.append(col)    \n\n# columns that only are present when covid is negative        \nprint(just_one_target)","13100a76":"for col in just_one_target:\n    print(df[df[col].notnull()][target].unique())","623d3706":"df.drop(just_one_target, axis=1, inplace=True)","7e20363e":"msno.bar(df, figsize=(16, 4))","8175f733":"not_null_series = (df.isnull().sum() == 0)\nnot_null_columns = not_null_series[not_null_series == True].index\nnot_null_columns = not_null_columns[1:]","cf92649c":"def plot_histograms(df, cols, subplots_rows, subplots_cols, figsize=(16, 8), target='SARS-Cov-2 exam result'):\n    df_neg = df[df[target] == 'negative']\n    df_pos = df[df[target] == 'positive']\n    \n    cols = cols.tolist()\n    cols.remove(target)\n    \n    plt.figure()\n    fig, ax = plt.subplots(subplots_rows, subplots_cols, figsize=figsize)\n    \n    i = 0    \n    for col in cols:\n        i += 1\n        plt.subplot(subplots_rows, subplots_cols, i)\n        sns.distplot(df_neg[col], label=\"Negative\", bins=15, kde=False)\n        sns.distplot(df_pos[col], label=\"Positive\", bins=15, kde=False)\n        plt.legend()\n    plt.show()\n    \nplot_histograms(df, not_null_columns, 2, 2)","d190fb4c":"# dataprep categorical\nmask_pos_neg = {'positive': 1, 'negative': 0}\nmask_detected = {'detected': 1, 'not_detected': 0}\nmask_notdone_absent_present = {'not_done': 0, 'absent': 1, 'present': 2}\nmask_normal = {'normal': 1}\nmask_urine_color = {'light_yellow': 1, 'yellow': 2, 'citrus_yellow': 3, 'orange': 4}\nmask_urine_aspect = {'clear': 1, 'lightly_cloudy': 2, 'cloudy': 3, 'altered_coloring': 4}\nmask_realizado = {'N\u00e3o Realizado': 0}\nmask_urine_leuk = {'<1000': 1000}\nmask_urine_crys = {'Ausentes': 1, 'Urato Amorfo --+': 0, 'Oxalato de C\u00e1lcio +++': 0,\n                   'Oxalato de C\u00e1lcio -++': 0, 'Urato Amorfo +++': 0}","f1b70875":"df = df.replace(mask_detected)\ndf = df.replace(mask_pos_neg)\ndf = df.replace(mask_notdone_absent_present)\ndf = df.replace(mask_normal)\ndf = df.replace(mask_realizado)\ndf = df.replace(mask_urine_leuk)\ndf = df.replace(mask_urine_color)\ndf = df.replace(mask_urine_aspect)\ndf = df.replace(mask_urine_crys)\n\ndf['Urine - pH'] = df['Urine - pH'].astype('float')\ndf['Urine - Leukocytes'] = df['Urine - Leukocytes'].astype('float')","ef85271a":"x = df.drop(['Patient ID', 'SARS-Cov-2 exam result'], axis=1)\nx.fillna(999999, inplace=True)\ny = df['SARS-Cov-2 exam result']","4debdb76":"dt = DecisionTreeClassifier(max_depth=3)","bb29ce3f":"dt.fit(x, y)","7346a52c":"dt_feat = pd.DataFrame(dt.feature_importances_, index=x.columns, columns=['feat_importance'])\ndt_feat.sort_values('feat_importance').tail(8).plot.barh()\nplt.show()","02f83cbe":"os.environ[\"PATH\"] += os.pathsep + 'C:\/Program Files (x86)\/Graphviz2.38\/bin\/'\n\ngraph = Source(export_graphviz(dt, out_file=None, feature_names=x.columns, filled = True))\ndisplay(SVG(graph.pipe(format='svg')))","18c4211c":"sns.distplot(df[df['SARS-Cov-2 exam result'] == 1]['Leukocytes'], label=\"Covid\")\nsns.distplot(df[df['SARS-Cov-2 exam result'] == 0]['Leukocytes'], label=\"No Covid\")\nplt.legend()","791226b2":"classifiers = {'Logistic Regression' : LogisticRegression(),\n               'KNN': KNeighborsClassifier(),\n               'Decision Tree': DecisionTreeClassifier(),\n               'Random Forest': RandomForestClassifier(),\n               'AdaBoost': AdaBoostClassifier(),\n               'SVM': SVC()}\n\nsamplers = {'Random_under_sampler': RandomUnderSampler(),\n            'Random_over_sampler': RandomOverSampler()}\n\ndrop_cols = ['Patient ID', 'Patient addmited to regular ward (1=yes, 0=no)',\n             'Patient addmited to semi-intensive unit (1=yes, 0=no)',\n             'Patient addmited to intensive care unit (1=yes, 0=no)']","7ca90c89":"def df_split(df, target='SARS-Cov-2 exam result', drop_cols=drop_cols):\n    df = df.drop(drop_cols, axis=1)\n    df = df.fillna(999)\n    x = df.drop(target, axis=1)\n    y = df[target]    \n    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, stratify=y, random_state=42)                          \n    return x_train, x_test, y_train, y_test\n\ndef train_clfs(df, classifiers, samplers):\n    \n    x_train, x_test, y_train, y_test = df_split(df)\n    \n    names_samplers = []\n    names_clfs = []\n    results_train_cv_roc_auc = []\n    results_train_cv_recall = []\n    results_train_cv_accuracy = []\n    results_test_roc_auc = []\n    results_test_recall = []\n    results_test_accuracy = []\n    \n    for name_sampler, sampler in samplers.items():\n        print(f'Sampler: {name_sampler}\\n')\n        for name_clf, clf in classifiers.items():\n            print(f'Classifier: {name_clf}\\n')\n            \n            pipeline = Pipeline([('sampler', sampler),\n                                 ('clf', clf)])\n            \n            cv_auc = cross_val_score(pipeline, x_train, y_train, cv=10, scoring='roc_auc') \n            cv_rec = cross_val_score(pipeline, x_train, y_train, cv=10, scoring='recall')                                \n            cv_acc = cross_val_score(pipeline, x_train, y_train, cv=10, scoring='accuracy')        \n\n            pipeline.fit(x_train, y_train)        \n            y_pred = pipeline.predict(x_test)\n            \n            names_samplers.append(name_sampler)\n            names_clfs.append(name_clf)\n            results_train_cv_roc_auc.append(cv_auc)\n            results_train_cv_recall.append(cv_rec)\n            results_train_cv_accuracy.append(cv_acc)\n            results_test_roc_auc.append(roc_auc_score(y_test, y_pred))\n            results_test_recall.append(recall_score(y_test, y_pred))\n            results_test_accuracy.append(accuracy_score(y_test, y_pred))\n\n            print(f'CV\\t-\\troc_auc:\\t{round(cv_auc.mean(), 3)}')\n            print(f'CV\\t-\\trecall:\\t\\t{round(cv_rec.mean(), 3)}')\n            print(f'CV\\t-\\taccuracy:\\t{round(cv_acc.mean(), 3)}')\n\n            print(f'Test\\t-\\troc_auc:\\t{round(roc_auc_score(y_test, y_pred), 3)}')         \n            print(f'Test\\t-\\trecall:\\t\\t{round(recall_score(y_test, y_pred), 3)}')          \n            print(f'Test\\t-\\taccuracy:\\t{round(accuracy_score(y_test, y_pred), 3)}')      \n            print('\\n<-------------------------->\\n')\n\n    df_results_test = pd.DataFrame(index=[names_clfs, names_samplers], columns=['ROC_AUC', 'RECALL', 'ACCURACY'])\n    df_results_test['ROC_AUC'] = results_test_roc_auc\n    df_results_test['RECALL'] = results_test_recall\n    df_results_test['ACCURACY'] = results_test_accuracy\n\n    return df_results_test","0a4cd7b3":"df_results_test = train_clfs(df, classifiers, samplers)","1f63bb2e":"def train_xgb(df, clf):\n    \n    x_train, x_test, y_train, y_test = df_split(df)\n\n    scale_pos_weight = len(df[df['SARS-Cov-2 exam result'] == 0]) \/ len(df[df['SARS-Cov-2 exam result'] == 1])\n\n    param_grid = {'xgb__max_depth': [3, 4, 5, 6, 7, 8],\n                  'xgb__learning_rate': [0.01, 0.05, 0.1, 0.2],\n                  'xgb__colsample_bytree': [0.6, 0.7, 0.8],\n                  'xgb__min_child_weight': [0.4, 0.5, 0.6],\n                  'xgb__gamma': [0, 0.01, 0.1],\n                  'xgb__reg_lambda': [6, 7, 8, 9, 10],\n                  'xgb__n_estimators': [150, 200, 300],\n                  'xgb__scale_pos_weight': [scale_pos_weight]}\n\n    rs_clf = RandomizedSearchCV(clf, param_grid, n_iter=100,\n                                n_jobs=-1, verbose=2, cv=5,                            \n                                scoring='roc_auc', random_state=42)\n\n    rs_clf.fit(x_train, y_train)\n    \n    print(f'XGBOOST BEST PARAMS: {rs_clf.best_params_}')\n    \n    y_pred = rs_clf.predict(x_test)\n\n    df_results_xgb = pd.DataFrame(index=[['XGBoost'], ['No_sampler']], columns=['ROC_AUC', 'RECALL', 'ACCURACY'])\n\n    df_results_xgb['ROC_AUC'] = roc_auc_score(y_test, y_pred)\n    df_results_xgb['RECALL'] = recall_score(y_test, y_pred)\n    df_results_xgb['ACCURACY'] = accuracy_score(y_test, y_pred)\n    \n    return df_results_xgb","0240dc18":"df_results_xgb = train_xgb(df, xgb.XGBClassifier())","b6378e8b":"df_results = pd.concat([df_results_test, df_results_xgb])","95e79af4":"df_plot = pd.concat([df_results.sort_values('ROC_AUC', ascending=False).head(3),\n                     df_results.sort_values('RECALL', ascending=False).head(3),\n                     df_results.sort_values('ACCURACY', ascending=False).head(3)])","5055ae76":"def plot_test(df, xlim_min, xlim_max):\n\n    f, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10,12))\n    color = ['blue', 'red', 'green', 'yellow', 'orange', 'purple', 'navy', 'turquoise', 'darkorange']\n\n    df['ROC_AUC'].plot(kind='barh', ax=ax1, xlim=(xlim_min, xlim_max), title='ROC_AUC', color=color)\n    df['RECALL'].plot(kind='barh', ax=ax2, xlim=(xlim_min, xlim_max), title='RECALL', color=color)\n    df['ACCURACY'].plot(kind='barh', ax=ax3, xlim=(xlim_min, xlim_max), title='ACCURACY', color=color)\n    plt.show()","648f3446":"plot_test(df_plot, 0.4, 1)","f512604c":"def plot_confusion_matrix(y_test, y_pred, title='Confusion matrix'):\n    \n    cm = confusion_matrix(y_test, y_pred)\n    classes = ['No Covid', 'Covid']\n\n    plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues, )\n    plt.title(title, fontsize=14)\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes)\n    plt.yticks(tick_marks, classes)\n    \n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j]),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n    \ndef train_clf_threshold(df, clf, sampler=None):\n    thresholds = np.arange(0.1, 1, 0.1)\n    \n    x_train, x_test, y_train, y_test = df_split(df)\n    \n    if sampler:\n        clf_train = Pipeline([('sampler', sampler),\n                              ('clf', clf)])\n        \n    else:        \n        clf_train = clf\n            \n    clf_train.fit(x_train, y_train)\n    y_proba = clf_train.predict_proba(x_test)\n    \n    plt.figure(figsize=(10,10))\n\n    j = 1\n    for i in thresholds:\n        y_pred = y_proba[:,1] > i\n\n        plt.subplot(4, 3, j)\n        j += 1\n\n        # Compute confusion matrix\n        cnf_matrix = confusion_matrix(y_test,y_pred)\n        np.set_printoptions(precision=2)\n\n        print(f\"Threshold: {round(i, 1)} | Test Accuracy: {round(accuracy_score(y_test, y_pred), 2)}| Test Recall: {round(recall_score(y_test, y_pred), 2)} | Test Roc Auc: {round(roc_auc_score(y_test, y_pred), 2)}\")\n\n        # Plot non-normalized confusion matrix\n        plot_confusion_matrix(y_test, y_pred, title=f'Threshold >= {round(i, 1)}')","58dbb448":"train_clf_threshold(df, RandomForestClassifier(), sampler=RandomUnderSampler())","0612d1e5":"By looking at the `Leukocytes`, it seems that the feature helps to discriminate the data indeed. The feature can bring insights for doctors when analyzing a patient.","ffa73ff1":"\nTo understand the costs of each value, we can interpret the values of each cell in the confusion matrix as:\n- **True Negative:** Model predicted that patient is not infected by covid-19, and he is not. \n\n**Cost**: Low:- The patient will not need special treatment nor medicaments.\n\n- **False Positive:** Model predicted that patient is infected by covid-19, and he is not.\n\n**Cost**: Medium - The patient will receive special treatment and medicaments unnecessarily.\n\n- **False Negative:**\n\n**Cost**: Very-high - The patient may probably leave the hospital and transmit coronavirus to their colleagues and family, besides risking his life\n\n- **True Positive:**\n\n**Cost**: Medium - The patient will receive special treatment and medicaments.","a9f275c4":"### Feature importances\n\nNow I'll check the most important features according to decision tree.\nThis information can bring insights by applying feature engineering to improve the classification of the target.","b53e0fbc":"We still have many values null in the dataset.\nI'll drop the columns that only have one value in the target, since they'll hardly help to discriminate the presence of Covid-19.","062ee806":"## Description\n\nThis notebook aims providing an EDA (exploratory data analysis) of the covid-19 dataset from Hospital Israelita Albert Einstein.\nThe notebook is splited in the following sections:\n\n* **Importings:** Importing libs and data\n* **Analysis:** Analysing data, dropping unnecessary columns, treating null values, checking features\n* **Feature Importance:** Identifying important features by applying decision tree\n* **Modeling:** Applying classification models (logistic regression, knn, decision tree, random forest, adaboost, svm) combined with samplers (random under sampler and random over sampler), and xgboost to identify covid-19\n* **Conclusion:** Results in the test dataset (roc-auc, recall, accuracy)","2a576958":"### Importings","ebcf2796":"As we can see, depending on the risk we want to take, we can choose a model and threshold that provide both a high recall and a fair roc-auc.","2420d9a6":"### Conclusion\n\nWe can check the top 9 pipelines for each metric ROC_AUC, RECALL, and ACCURACY in the test dataset below:","be1fd05b":"### Modeling\n\nI will try to identify covid-19 by applying several models combined with random over sampler and random under sampler. The samplers will balance the dataset, so it should reduce the bias of my models. I will also apply xgboost with hyperparameter tuning.","b28c7b5c":"It's hard to see any feature that can help determine presence of covid-19.\nI'll prepare the data do convert categorical features to numeric and examine the feature importance of the features with logistic regression and decision tree models","3622f0a9":"As we want minimize the risk of false negatives, we should try to choose the models that have high recall. I plotted the confusion matrix of the pipeline `Random Forest + Random Under Sampler` for each threshold.","b14a0e6e":"We still have many null values in the dataset.\nI'll plot the columns that doesn't have any null to check if they can discriminate the target.","0019df6c":"### Analysis","27225b5a":"As we can see, many models performed well according to RECALL, but did not provided good results for ACCURACY.\nThe choice of the best metric depends on the costs associated to each true or false prediction\n\n<table>\n    <th> <\/th>\n    <th style=\" border: 1px solid black\">Predicted No Covid<\/th>\n    <th style=\" border: 1px solid black\">Predicted Covid<\/th>\n    <tr style=\" border: 1px solid black\">\n        <td style=\" border: 1px solid black\"><b>No Covid<\/b><\/td>\n        <td style=\" border: 1px solid black\">True Negative<\/td>\n        <td style=\" border: 1px solid black\">False Positive<\/td>\n    <\/tr>\n    <tr style=\" border: 1px solid black\">\n        <td style=\" border: 1px solid black\"><b>Covid<\/b><\/td>\n        <td style=\" border: 1px solid black\">False Negative<\/td>\n        <td style=\" border: 1px solid black\">True Positive<\/td>\n    <\/tr>\n<\/table>","9d17a91b":"The dataset is very unbalanced (covid-19 is only present in 90% of the data), so I will consider this during modeling.","dc3ab498":"It seems that there are some columns with all values equal null, so I'll drop them."}}