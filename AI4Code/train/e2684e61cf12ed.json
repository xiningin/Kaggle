{"cell_type":{"0da97663":"code","e67abe33":"code","0a77c3a4":"code","8c6d0c36":"code","fb5c128c":"code","81706f63":"code","3d7134f2":"code","ed3acfa6":"code","dc9d642b":"code","9708f8c0":"code","0cb1ebbc":"code","abad593a":"code","470c10dd":"code","d7309580":"code","368bf489":"code","e9d1e0b4":"markdown","3225b094":"markdown","4650ef8d":"markdown","443ff90b":"markdown","875cb7c3":"markdown","ecd1d98c":"markdown","21da0e30":"markdown","5dbe2f19":"markdown","96fa992d":"markdown"},"source":{"0da97663":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport datetime\nimport operator\nimport math\nimport random\n\nimport numpy as np\nfrom scipy.linalg import norm\nfrom scipy.spatial.distance import cdist\nfrom collections import defaultdict\n\n\nfrom sklearn import datasets\nfrom sklearn.datasets import make_blobs\n\n# ignoring warnings\nimport warnings\nwarnings.simplefilter(\"ignore\")\n\nimport os, cv2, json\n\n\nnp.random.seed(42)","e67abe33":"iris=datasets.load_iris()","0a77c3a4":"iris","8c6d0c36":"X=pd.DataFrame(iris.data,columns=['Sepal Length', 'Sepal Width', 'Petal Length', 'Petal Width'])\ny=pd.DataFrame(iris.target,columns=['Classes'])\n\nX","fb5c128c":"X=X.values","81706f63":"y=y.values","3d7134f2":"data=X","ed3acfa6":"y","dc9d642b":"def euclidean_distance(point1,point2):\n    dis=0\n    for i in range(len(point1)):\n        dis+=(point1[i]-point2[i])**2\n    return dis**0.5\n","9708f8c0":"# utility values\nm=2\nn=len(data)\nc=3\np=len(data[0])\nmax_iter=100","0cb1ebbc":"def initialize_membership_matrix(n,c):\n    member_mat=list()\n    for i in range(n):\n        random_list=[random.random() for x in range(c)]\n        summation=sum(random_list)\n        for i in range(len(random_list)):\n            random_list[i]=random_list[i]\/summation\n        member_mat.append(random_list)\n    return member_mat\n\ndef update_centroid(member_mat):\n    centroids={}\n\n    for j in range(c):\n        temp=[]\n        for k in range(p):\n            \n            add=0\n            for i in range(n):\n                add+=member_mat[i][j]**m\n            x=0\n            for i in range(n):\n                x+=(member_mat[i][j]**m)*(data[i][k])\n            val=x\/add\n            temp.append(val)\n        centroids[j]=temp\n    return centroids\n\n\ndef update_membership_matrix(member_mat,centroids):\n    ratio=float(2\/(m-1))\n\n    for i in range(n):\n        distances=list()\n        for j in range(c):\n            distances.append(euclidean_distance(data[i],centroids[j]))\n        for j in range(c):\n            den = sum([math.pow(float(distances[j]\/distances[q]), ratio) for q in range(c)])\n            member_mat[i][j] = float(1\/den) \n           \n            \n    return member_mat\n        \n                \n    \ndef find_cluster(member_mat):\n    clusters=list()\n    for i in range(n):\n        max_val, idx = max((val, idx) for (idx, val) in enumerate(member_mat[i]))\n        clusters.append(idx)\n    return clusters\n\ndef check(old_member_mat,member_mat):\n    diff=0\n    for i in range(n):\n        for j in range(c):\n            diff+=old_member_mat[i][j]-member_mat[i][j]\n    if(diff<0.01):\n        return True\n    return False\n\ndef fuzzy_c_mean():\n    \n    member_mat=initialize_membership_matrix(n,c)\n    for i in range(max_iter):\n        centroids=update_centroid(member_mat)\n        old_member_mat=member_mat\n        member_mat=update_membership_matrix(member_mat,centroids)\n        cluster=find_cluster(member_mat)\n        if(check(old_member_mat,member_mat))<0.01:\n            print(i)\n            break\n    \n   \n    \n    return cluster,centroids\n","abad593a":"clusters,centroids=fuzzy_c_mean()\nprint(\"Final Centroid points are:\")\nprint(centroids)\n\n\n# labeling the clusters\ndef label_clusters(clusters):\n    z=0\n    o=0\n    t=0\n    dict=defaultdict(int)\n\n\n    for i in range(50):\n        if(clusters[i]==0):\n            z=z+1\n        elif(clusters[i]==1):\n            o=o+1\n        else:\n            t=t+1\n    dict[z]=0\n    dict[o]=1\n    dict[t]=2\n    classes=[]\n    fin1=max(z,max(o,t))\n    \n    classes.append(dict[fin1])\n    z=0\n    o=0\n    t=0\n    for i in range(50,100):\n        if(clusters[i]==0):\n            z=z+1\n        elif(clusters[i]==1):\n            o=o+1\n        else:\n            t=t+1\n    dict[z]=0\n    dict[o]=1\n    dict[t]=2\n\n    fin1=max(z,max(o,t))\n    \n    classes.append(dict[fin1])\n    z=0\n    o=0\n    t=0\n    for i in range(100,150):\n        if(clusters[i]==0):\n            z=z+1\n        elif(clusters[i]==1):\n            o=o+1\n        else:\n            t=t+1\n    dict[z]=0\n    dict[o]=1\n    dict[t]=2\n    fin1=max(z,max(o,t))\n   \n    classes.append(dict[fin1])\n    \n    return classes\n\nclasses=label_clusters(clusters)","470c10dd":"\n\ndef confusion_matrix(clusters,classes,labels):\n    c_matrix=[[0 for i in range(labels)] for j in range(labels)]\n    m=0\n    n=0\n    q=0\n    for i in range(50):\n\n        if clusters[i]==classes[0]:\n            m=m+1\n        elif clusters[i]==classes[1]:\n            n=n+1\n        else:\n            q=q+1\n    c_matrix[0][0]=m\n    c_matrix[0][1]=n\n    c_matrix[0][2]=q\n    m=0\n    n=0\n    q=0\n    for i in range(50,100):\n        if clusters[i]==classes[0]:\n            m=m+1\n        elif clusters[i]==classes[1]:\n            n=n+1\n        else:\n            q=q+1\n    c_matrix[1][0]=m\n    c_matrix[1][1]=n\n    c_matrix[1][2]=q\n    m=0\n    n=0\n    q=0\n\n    for i in range(100,150):\n        if clusters[i]==classes[0]:\n            m=m+1\n        elif clusters[i]==classes[1]:\n            n=n+1\n        else:\n            q=q+1\n    c_matrix[2][0]=m\n    c_matrix[2][1]=n\n    c_matrix[2][2]=q\n    \n    \n    return c_matrix\n    ","d7309580":"class Metrics:\n    \n    def __init__(self,confusion_m):\n        self.confusion_m=confusion_m\n        self.total=np.sum(confusion_m)\n        self.diagonal=np.sum(np.diag(confusion_m))\n    \n    def accuracy(self):\n        accuracy=(self.diagonal\/self.total)\n        return accuracy\n    \n    def recall(self):\n        recall=np.diag(self.confusion_m)\/np.sum(self.confusion_m,axis=1)\n        recall=np.mean(recall)\n        return recall\n    \n    def precision(self):\n        precision=np.diag(self.confusion_m)\/np.sum(self.confusion_m,axis=0)\n        precision=np.mean(precision)\n        \n        return precision\n    \n    def f1_score(self,precision,recall):\n        f1_score=(2*precision*recall)\/(precision+recall)\n        \n        return f1_score\n","368bf489":"matrix=confusion_matrix(clusters,classes,3)\nperformance=Metrics(matrix)\n\naccuracy=performance.accuracy()\nrecall=performance.recall()\nprecision=performance.precision()\nf1_score=performance.f1_score(precision,recall)\n\nprint('confusion matrix is:',end='\\n')\nprint(np.array(matrix),end='\\n')\n\nprint(\"Accuracy of the model is {}\".format(accuracy*100))\nprint(\"Recall of the model is {}\".format(recall*100))\nprint(\"Precision of the model is {}\".format(precision*100))\nprint(\"F1-Score of the model is {}\".format(f1_score*100))","e9d1e0b4":"# performance","3225b094":"# Function to calculate euclidean distance","4650ef8d":"# Initializing the membership matrix","443ff90b":"#  FuzzyCMeans Implementation from scratch on Iris dataset","875cb7c3":"# confusion matrix","ecd1d98c":"# prediction","21da0e30":"# FuzzyCMeans Implementation","5dbe2f19":"> # load the dataset","96fa992d":"# Performance metrics"}}