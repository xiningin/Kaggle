{"cell_type":{"e1fff173":"code","75c0d8f2":"code","2356a265":"code","a910717c":"code","ab0777d3":"code","4c269310":"code","4ddfd02d":"code","c9ea2afd":"code","b7aa6b37":"code","ecbd1aa7":"code","d1ea9999":"code","191e75df":"code","9f4ed10b":"code","b128ce1f":"code","d537b36d":"code","54d08725":"code","db863414":"code","36a41414":"code","46d54b21":"code","1d352874":"code","6a8f5d6c":"markdown","d84836d9":"markdown","5ae7d172":"markdown"},"source":{"e1fff173":"#Basic EDA steps and optuna use for song popularity prediction\n#Reference from @isha20\n#https:\/\/www.kaggle.com\/isha20\/spp-eda-boosting.","75c0d8f2":"#General library imports\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n!nvidia-smi","2356a265":"from sklearn.pipeline import Pipeline","a910717c":"#Imputers and transformers\nfrom sklearn.preprocessing import OneHotEncoder, StandardScaler\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.compose import ColumnTransformer","ab0777d3":"from xgboost import XGBClassifier\nimport lightgbm as lgbm","4c269310":"# validation imports\nfrom sklearn.model_selection import StratifiedKFold, train_test_split\nfrom sklearn.metrics import roc_auc_score, roc_curve, auc","4ddfd02d":"import optuna","c9ea2afd":"df_train = pd.read_csv(\"..\/input\/song-popularity-prediction\/train.csv\")\ndf_test = pd.read_csv(\"..\/input\/song-popularity-prediction\/test.csv\")\ndf_train.info()","b7aa6b37":"#for col in df_train.columns:\n#    print(df_train[col].nunique())\n# <5 unique values are considered cat features\nnum_features = ['song_duration_ms', 'acousticness', 'danceability', 'energy','instrumentalness', 'liveness', 'loudness', 'speechiness', \n            'tempo', 'audio_valence',]\ncat_features = [\"key\", \"audio_mode\", \"time_signature\"]","ecbd1aa7":"df_train.isnull().sum() #missing vals","d1ea9999":"outliers = []\nfor col in num_features:\n    Q1 = np.percentile(df_train[col], 25)\n    Q3 = np.percentile(df_train[col], 75)\n    IQR = Q3-Q1\n\n    sub_outlier = df_train[(df_train[col]<(Q1-(1.5*IQR))) | (df_train[col]>(Q3+(1.5*IQR)))].index\n    outliers.extend(sub_outlier)","191e75df":"from collections import Counter\noutlier_indices = Counter(outliers) #outliers\noutliers = (k for k, v in outlier_indices.items() if v>2) #try with diffrent values","9f4ed10b":"fig, axes = plt.subplots(1, 3, figsize=(15, 5), sharey=True)\n\nsns.barplot(x=df_train['key'], y=df_train['song_popularity'], ax=axes[0])\naxes[0].set_title('Key')\n\nsns.barplot(x=df_train['audio_mode'], y=df_train['song_popularity'], ax=axes[1])\naxes[1].set_title('audio_mode')\n\nsns.barplot(x=df_train['time_signature'], y=df_train['song_popularity'], ax=axes[2])\naxes[2].set_title('time_signature')","b128ce1f":"corr = df_train.corr()\ncorr.style.background_gradient() \n#No very high correlation with song_popularity","d537b36d":"X = df_train[['song_duration_ms',\n 'acousticness',\n 'danceability',\n 'energy',\n 'instrumentalness',\n 'key',\n 'liveness',\n 'loudness',\n 'audio_mode',\n 'speechiness',\n 'tempo',\n 'time_signature',\n 'audio_valence']]\ny = df_train['song_popularity']","54d08725":"def run_dta(trial, data=X,target=y):\n    \n    X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.10, random_state=42)\n    \n    params = {\n                'metric': 'auc', \n                'random_state': 22,\n                'n_estimators': 4000,\n                'boosting_type': trial.suggest_categorical(\"boosting_type\", [\"gbdt\"]),\n                'lambda_l1': trial.suggest_loguniform('lambda_l1', 1e-3, 10.0),\n                'lambda_l2': trial.suggest_loguniform('lambda_l2', 1e-3, 10.0),\n                'colsample_bytree': trial.suggest_categorical('colsample_bytree', [0.5, 0.6, 0.7, 0.8, 0.9, 1.0]),\n                'bagging_fraction': trial.suggest_categorical('bagging_fraction', [0.6, 0.7, 0.80]),\n                'feature_fraction': trial.suggest_categorical('feature_fraction', [0.6, 0.7, 0.80]),\n                'learning_rate': trial.suggest_categorical('learning_rate', [0.005, 0.01, 0.02, 0.03, 0.05, 0.1]),\n                'max_depth': trial.suggest_int('max_depth', 2, 12, step=1),\n                'num_leaves' : trial.suggest_int('num_leaves', 13, 148, step=5),\n                'min_child_samples': trial.suggest_int('min_child_samples', 1, 96, step=5),\n            }\n    \n    clf = lgbm.LGBMClassifier(**params)  \n    clf.fit(X_train, y_train,\n            eval_set=[(X_valid, y_valid), (X_train, y_train)],\n            categorical_feature=[5, 8, 11],\n            callbacks=[lgbm.log_evaluation(period=100), \n                       lgbm.early_stopping(stopping_rounds=100)\n                      ],\n           )\n    \n    y_proba = clf.predict_proba(X_valid)[:, 1]\n    auc = roc_auc_score(y_valid, y_proba)\n    return auc","db863414":"study_obj = optuna.create_study(direction='maximize')\nstudy_obj.optimize(run_dta, n_trials=100)\nstudy_obj.best_params","36a41414":"X = df_train[['song_duration_ms',\n 'acousticness',\n 'danceability',\n 'energy',\n 'instrumentalness',\n 'key',\n 'liveness',\n 'loudness',\n 'audio_mode',\n 'speechiness',\n 'tempo',\n 'time_signature',\n 'audio_valence']]\ny = df_train['song_popularity']","46d54b21":"preds = []\nstratified_fold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n\n\nX_test =df_test[['song_duration_ms',\n 'acousticness',\n 'danceability',\n 'energy',\n 'instrumentalness',\n 'key',\n 'liveness',\n 'loudness',\n 'audio_mode',\n 'speechiness',\n 'tempo',\n 'time_signature',\n 'audio_valence']]\n\nfor fold, (train_idx, val_idx) in enumerate(stratified_fold.split(X, y)):\n    \n    X_train, X_valid = X.iloc[train_idx], X.iloc[val_idx]\n    y_train , y_valid = y.iloc[train_idx], y.iloc[val_idx]\n    \n    model = lgbm.LGBMClassifier(**study_obj.best_params)\n    \n    model.fit(X_train, y_train,\n            eval_set=[(X_valid, y_valid), (X_train, y_train)],\n            categorical_feature=[5, 8, 11],\n            callbacks=[lgbm.log_evaluation(period=100), \n                       lgbm.early_stopping(stopping_rounds=500)\n                      ],\n           )\n    preds.append(model.predict_proba(X_test)[:,1])\npreds = np.mean(np.column_stack(preds), axis=1)","1d352874":"results = pd.DataFrame(columns = ['id','song_popularity'])\nresults['id'] = df_test['id']\nresults['song_popularity'] = preds\nresults.to_csv(\"submission.csv\", index=False)","6a8f5d6c":"## Model and validation","d84836d9":"## Univariate EDA","5ae7d172":"## Multivariate EDA"}}