{"cell_type":{"52e47783":"code","322d64ef":"code","a277f224":"code","f8f3cee5":"code","e76fcd40":"code","7eb666a7":"code","dc9a5ae0":"code","9411c14d":"code","221363b5":"code","94a120c8":"code","efc1326b":"code","3cbe38ea":"code","bc943446":"code","b1df543b":"code","893c1156":"code","3a8ba5b6":"code","4a61e599":"code","3c97f042":"code","ffbfc9f7":"code","b993d360":"code","4c383df4":"code","19fc1b91":"code","87415e87":"code","867af20b":"code","3eecd22f":"code","4b758849":"code","484039e1":"code","46de0394":"code","7c2f515b":"code","4d1fb51b":"code","1822300e":"code","299474d4":"code","40b5b836":"code","ba907221":"code","8dcc98ad":"code","33ca3e2c":"code","2b48c693":"code","586a6070":"code","dbf15886":"code","be6267f8":"code","736b69a7":"code","628abb1d":"code","b3c0a6cd":"code","c4eaf430":"code","700209b8":"code","c5571cff":"code","34148150":"code","6d73bed2":"code","c56817b9":"code","76712b5f":"code","1bacfd70":"code","ed686854":"code","80f1315f":"code","f49d1c5d":"code","59723276":"markdown","b687914d":"markdown","c5f6abb2":"markdown","3a287604":"markdown","a1f962b9":"markdown","57a2dd06":"markdown","806cc453":"markdown","c916fef9":"markdown","5cccb238":"markdown","5acff11e":"markdown","9cb72fa7":"markdown","23804e06":"markdown","b0c814f2":"markdown","a5b52ed0":"markdown","2f7ea1db":"markdown","6cdfac15":"markdown","23c65f20":"markdown","cb6c124f":"markdown","a69c2b19":"markdown","d678e89b":"markdown","d5f41b32":"markdown","1471f8c1":"markdown","977f30bc":"markdown","deb5083c":"markdown","0892779b":"markdown","864fd5cd":"markdown","4ebc9235":"markdown","d4c5e164":"markdown","0fac7cd7":"markdown","63fbc4e8":"markdown","6b2729dc":"markdown","4ae7c40e":"markdown","27d0446c":"markdown","144e9038":"markdown"},"source":{"52e47783":"import math\nimport numpy as np\nimport pandas as pd\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nimport dateutil.easter as easter\n\nfrom learntools.time_series.style import *  # plot style settings\nfrom learntools.time_series.utils import plot_periodogram, make_lags, make_multistep_target, plot_multistep\n\nfrom statsmodels.tsa.deterministic import CalendarFourier, DeterministicProcess\n\nfrom xgboost import XGBRegressor\nfrom catboost import CatBoostRegressor\nfrom sklearn.linear_model import LinearRegression\n\nfrom sklearn.multioutput import MultiOutputRegressor\nfrom sklearn.multioutput import RegressorChain","322d64ef":"train_df = pd.read_csv(\n    '..\/input\/tabular-playground-series-jan-2022\/train.csv',\n    usecols=['country', 'store', 'product', 'date', 'num_sold'],\n    dtype={\n        'country': 'category',\n        'store': 'category',\n        'product': 'category',\n        'num_sold': 'float32',\n    },\n    parse_dates=['date'],\n    infer_datetime_format=True,\n)\n\ntest_df = pd.read_csv(\n    '..\/input\/tabular-playground-series-jan-2022\/test.csv',\n    usecols=['country', 'store', 'product', 'date'],\n    dtype={\n        'country': 'category',\n        'store': 'category',\n        'product': 'category',\n    },\n    parse_dates=['date'],\n    infer_datetime_format=True,\n)\n\naverage_sales = (\n    train_df\n    .groupby('date').mean()\n    .squeeze()\n)","a277f224":"train_df.head(6)","f8f3cee5":"print(\"Columns: {0}\".format(list(train_df.columns)))","e76fcd40":"countries = train_df['country'].unique()\nprint(\"Countries: {0}\".format(countries))","7eb666a7":"stores = train_df['store'].unique()\nprint(\"Stores: {0}\".format(stores))","dc9a5ae0":"products = train_df['product'].unique()\nprint(\"Products: {0}\".format(products))","9411c14d":"start_date = train_df.date.min()\nend_date = train_df.date.max()\nprint(\"Start and end date of the data: ({0}, {1})\".format(start_date, end_date))","221363b5":"print('Train data shape:', train_df.shape)\nprint('Test data shape:', test_df.shape)","94a120c8":"missing_values_train = train_df.isna().any().sum()\nprint('Missing values in train data: {0}'.format(missing_values_train[missing_values_train > 0]))\n\nmissing_values_test = test_df.isna().any().sum()\nprint('Missing values in test data: {0}'.format(missing_values_test[missing_values_test > 0]))","efc1326b":"duplicates_train = train_df.duplicated().sum()\nprint('Duplicates in train data: {0}'.format(duplicates_train))\n\nduplicates_test = test_df.duplicated().sum()\nprint('Duplicates in test data: {0}'.format(duplicates_test))","3cbe38ea":"def split_data(data):\n    splitted_data = []\n    for country in countries:\n        for store in stores:\n            for product in products:\n                splitted_data.append(data.loc[(data['country'] == country) & (data['store'] == store) & (data['product'] == product)])\n    return splitted_data","bc943446":"splitted_train = split_data(train_df)\nsplitted_test = split_data(test_df)\nsplitted_train[0]","b1df543b":"def merge_predictions(test_predictions):\n    predictions = pd.concat(test_predictions)\n    predictions.sort_index(inplace=True)\n    return predictions","893c1156":"def create_submission(submission, predictions):\n    output = pd.DataFrame({'row_id': test_df.index + len(train_df), 'num_sold': predictions})\n    output.to_csv(submission, index=False)\n    return output","3a8ba5b6":"fig, ax = plt.subplots()\n\n# Format the date columns so that it can be used with regplot\ndf = splitted_train[0].reset_index()\ndf = df.sort_values('date')\ndf['date_f'] = pd.factorize(df['date'])[0]\nmapping = dict(zip(df['date_f'], df['date'].dt.date))\n\n# Plot\nax.plot('date_f', 'num_sold', data=df, color='0.75')\nax = sns.regplot(x='date_f', y='num_sold', data=df, scatter_kws=dict(color='0.25'), line_kws=dict(linewidth=5))\n\n# Set ticks, labels and titles\nticks = np.array([df['date_f'][date] for date in range(0, len(df), 365)])\nax.set_xticks(ticks)\nlabels = pd.Series(ax.get_xticks()).map(mapping).fillna('')\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","4a61e599":"train_predictions = []\ntest_predictions = []\nfor i in range(len(splitted_train)):\n    train = splitted_train[i].copy()\n    test = splitted_test[i].copy()\n\n    # Create a time dummy\n    train['time'] = np.arange(len(train.index))\n    test['time'] = np.arange(len(test.index)) + len(train)\n\n    # Create training data\n    X = train.loc[:, ['time']]        # features\n    y = train.loc[:, 'num_sold']      # target\n    test_X = test.loc[:, ['time']]    # features\n\n    # Train the model\n    model = LinearRegression()\n    model.fit(X, y)\n    \n    # Make predictions\n    train_predictions.append(pd.Series(model.predict(X), index=X.index))\n    test_predictions.append(pd.Series(model.predict(test_X), index=test_X.index))","3c97f042":"# Plot\nax = splitted_train[0].loc[:, 'num_sold'].plot(**plot_params, alpha=0.5)\nax = train_predictions[0].plot(ax=ax, linewidth=5)\n\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticks(ticks * 18)\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","ffbfc9f7":"# Merge predictions\npredictions = merge_predictions(test_predictions)\n# Create submission\noutput = create_submission('submission_time-step.csv', predictions)\noutput","b993d360":"trend = average_sales.rolling(\n    window=240,\n    center=True,\n    min_periods=120,\n).mean()\n\nax = average_sales.plot(**plot_params, alpha=0.5)\nax = trend.plot(ax=ax, linewidth=5)\n\n# Set titles\nax.set_title('Average sales')\nax.set(xlabel='Date', ylabel='Number of sales');","4c383df4":"train_predictions = []\ntest_predictions = []\nfor i in range(len(splitted_train)):\n    train = splitted_train[i].copy()\n    test = splitted_test[i].copy()\n    \n    # Target\n    y = train.loc[:, 'num_sold']\n    \n    # Instantiate `DeterministicProcess` with arguments appropriate trend model\n    dp = DeterministicProcess(index=y.index, order=3)\n    \n    # Create features\n    X = dp.in_sample()\n    test_X = dp.out_of_sample(steps=len(test), forecast_index=test.index)\n    \n    # Train the model\n    model = LinearRegression()\n    model.fit(X, y)\n\n    # Make predictions\n    train_predictions.append(pd.Series(model.predict(X), index=X.index))\n    test_predictions.append(pd.Series(model.predict(test_X), index=test_X.index))","19fc1b91":"ax = splitted_train[0].loc[:, 'num_sold'].plot(**plot_params, alpha=0.5)\nax = train_predictions[0].plot(ax=ax, linewidth=5)\n\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticks(ticks * 18)\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","87415e87":"# Merge predictions\npredictions = merge_predictions(test_predictions)\n# Create submission\noutput = create_submission('submission_trend.csv', predictions)\noutput","867af20b":"plot_periodogram(average_sales);","3eecd22f":"y = average_sales.copy()\nfourier = CalendarFourier(freq='Y', order=4)\ndp = DeterministicProcess(\n    index=y.index,\n    constant=True,\n    order=1,\n    seasonal=True,\n    additional_terms=[fourier],\n    drop=True,\n)\nX = dp.in_sample()","4b758849":"model = LinearRegression()\nmodel.fit(X, y)\ny_pred = pd.Series(model.predict(X), index=X.index)\nax = y.plot(**plot_params, alpha=0.5, title=\"Average Sales\", ylabel=\"sales\")\nax = y_pred.plot(ax=ax, label=\"Seasonal\")\nax.legend();","484039e1":"y_deseason = y - y_pred\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True, sharey=True, figsize=(10, 7))\nax1 = plot_periodogram(y, ax=ax1)\nax1.set_title(\"Sales Frequency Components\")\nax2 = plot_periodogram(y_deseason, ax=ax2);\nax2.set_title(\"Deseasonalized\");","46de0394":"splitted_train_df = split_data(train_df)\nsplitted_test_df = split_data(test_df)","7c2f515b":"train_predictions = []\ntest_predictions = []\nfor i in range(len(splitted_train_df)):\n    df_train = splitted_train_df[i].copy()\n    df_train = df_train.set_index('date')\n    \n    df_test = splitted_test_df[i].copy()\n    df_test = df_test.set_index('date')\n    \n    # Target\n    y = df_train.loc[:, 'num_sold']\n\n    # Use DeterministicProcess and CalendarFourier to create:\n    # indicators for weekly seasons and\n    # Fourier features of order 4 for yearly seasons.\n    fourier = CalendarFourier(freq='Y', order=4)\n    dp = DeterministicProcess(\n        index=y.index,\n        constant=True,\n        order=1,\n        seasonal=True,\n        additional_terms=[fourier],\n        drop=True,\n    )\n    # Create the feature set for the dates given in y.index\n    X = dp.in_sample()\n    \n    # Create features for forecast.\n    test_X = dp.out_of_sample(steps=len(df_test), forecast_index=df_test.index)\n    \n    # Train the model\n    model = LinearRegression()\n    model.fit(X, y)\n\n    # Make predictions\n    train_predictions.append(pd.Series(model.predict(X), index=X.index))\n    test_predictions.append(pd.Series(model.predict(test_X), index=test_X.index))","4d1fb51b":"ax = splitted_train_df[0].loc[:, 'num_sold'].plot(**plot_params, alpha=0.5)\nax = pd.Series(data=train_predictions[0].values, index=splitted_train_df[0].index).plot(ax=ax)\n\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticks(ticks * 18)\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","1822300e":"predictions = np.zeros(len(test_predictions) * len(test_predictions[0]))\nfor i in range(len(test_predictions)):\n    for j in range(len(test_predictions[i])):\n        predictions[len(test_predictions) * j + i] = test_predictions[i][j]\noutput = create_submission('submission_seasonality.csv', predictions)\noutput","299474d4":"# Credits to https:\/\/www.kaggle.com\/ambrosm\/tpsjan22-03-linear-model, https:\/\/www.kaggle.com\/ambrosm\n# Feature engineering for holidays\ndef engineer_holidays(df):\n    # May\n    df = pd.concat([df,\n                        pd.DataFrame({f\"may{d}\":\n                                      (df.date.dt.month == 5) & (df.date.dt.day == d) \n                                      for d in list(range(1, 10))}) * 1, #  + list(range(17, 25))\n                        pd.DataFrame({f\"may{d}\":\n                                      (df.date.dt.month == 5) & (df.date.dt.day == d) & (df.country == 'Norway')\n                                      for d in list(range(19, 26))}) * 1],\n                       axis=1)\n    \n    # June and July\n    df = pd.concat([df,\n                        pd.DataFrame({f\"june{d}\":\n                                      (df.date.dt.month == 6) & (df.date.dt.day == d) & (df.country == 'Sweden')\n                                      for d in list(range(8, 14))}) * 1,\n                        pd.DataFrame({f\"june{d}\":\n                                      (df.date.dt.month == 6) & (df.date.dt.day == d) & (df.country == 'Norway')\n                                      for d in list(range(22, 31))}) * 1,\n                        pd.DataFrame({f\"july{d}\":\n                                      (df.date.dt.month == 7) & (df.date.dt.day == d) & (df.country == 'Norway')\n                                      for d in list(range(1, 3))}) * 1],\n                       axis=1)\n    \n    # Last Wednesday of June\n    wed_june_date = df.date.dt.year.map({2015: pd.Timestamp(('2015-06-24')),\n                                         2016: pd.Timestamp(('2016-06-29')),\n                                         2017: pd.Timestamp(('2017-06-28')),\n                                         2018: pd.Timestamp(('2018-06-27')),\n                                         2019: pd.Timestamp(('2019-06-26'))})\n    df = pd.concat([df,\n                        pd.DataFrame({f\"wed_june{d}\": \n                                      (df.date - wed_june_date == np.timedelta64(d, \"D\")) & (df.country != 'Norway')\n                                      for d in list(range(-4, 6))}) * 1],\n                       axis=1)\n    \n    # First Sunday of November\n    sun_nov_date = df.date.dt.year.map({2015: pd.Timestamp(('2015-11-1')),\n                                         2016: pd.Timestamp(('2016-11-6')),\n                                         2017: pd.Timestamp(('2017-11-5')),\n                                         2018: pd.Timestamp(('2018-11-4')),\n                                         2019: pd.Timestamp(('2019-11-3'))})\n    df = pd.concat([df,\n                        pd.DataFrame({f\"sun_nov{d}\": \n                                      (df.date - sun_nov_date == np.timedelta64(d, \"D\")) & (df.country != 'Norway')\n                                      for d in list(range(0, 9))}) * 1],\n                       axis=1)\n    \n    # First half of December (Independence Day of Finland, 6th of December)\n    df = pd.concat([df,\n                        pd.DataFrame({f\"dec{d}\":\n                                      (df.date.dt.month == 12) & (df.date.dt.day == d) & (df.country == 'Finland')\n                                      for d in list(range(6, 14))}) * 1],\n                       axis=1)\n\n    # Easter\n    easter_date = df.date.apply(lambda date: pd.Timestamp(easter.easter(date.year)))\n    df = pd.concat([df,\n                        pd.DataFrame({f\"easter{d}\": \n                                      (df.date - easter_date == np.timedelta64(d, \"D\"))\n                                      for d in list(range(-2, 11)) + list(range(40, 48)) + list(range(50, 59))}) * 1],\n                       axis=1)\n\n    return df","40b5b836":"train_predictions = []\ntest_predictions = []\nfor i in range(len(splitted_train_df)):\n    df_train = splitted_train_df[i].copy()\n    df_train = df_train.set_index('date')\n    \n    df_test = splitted_test_df[i].copy()\n    df_test = df_test.set_index('date')\n    \n    # Target\n    y = df_train.loc[:, 'num_sold']\n\n    # Use DeterministicProcess and CalendarFourier to create:\n    # indicators for weekly seasons and\n    # Fourier features of order 4 for yearly seasons.\n    fourier = CalendarFourier(freq='Y', order=4)\n    dp = DeterministicProcess(\n        index=y.index,\n        constant=True,\n        order=1,\n        seasonal=True,\n        additional_terms=[fourier],\n        drop=True,\n    )\n    # Create the feature set for the dates given in y.index\n    X = dp.in_sample()\n    X['date'], X['country'] = X.index, df_train['country']\n    X = engineer_holidays(X)\n    X.drop(['date', 'country'], axis=1, inplace=True)\n    \n    # Create features for forecast.\n    test_X = dp.out_of_sample(steps=len(df_test), forecast_index=df_test.index)\n    test_X['date'], test_X['country'] = test_X.index, df_test['country']\n    test_X = engineer_holidays(test_X)\n    test_X.drop(['date', 'country'], axis=1, inplace=True)\n    \n    # Train the model\n    model = LinearRegression()\n    model.fit(X, y)\n\n    # Make predictions\n    train_predictions.append(pd.Series(model.predict(X), index=X.index))\n    test_predictions.append(pd.Series(model.predict(test_X), index=test_X.index))","ba907221":"ax = splitted_train_df[0].loc[:, 'num_sold'].plot(**plot_params, alpha=0.5)\nax = pd.Series(data=train_predictions[0].values, index=splitted_train_df[0].index).plot(ax=ax)\n\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticks(ticks * 18)\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","8dcc98ad":"predictions = np.zeros(len(test_predictions) * len(test_predictions[0]))\nfor i in range(len(test_predictions)):\n    for j in range(len(test_predictions[i])):\n        predictions[len(test_predictions) * j + i] = test_predictions[i][j]\noutput = create_submission('submission_seasonality_holidays.csv', predictions)\noutput","33ca3e2c":"df_train = splitted_train_df[0]\ndf_train = df_train.set_index('date')\ny = df_train.loc[:, 'num_sold']\n\nfourier = CalendarFourier(freq='Y', order=4)\ndp = DeterministicProcess(\n    constant=True,\n    index=y.index,\n    order=1,\n    seasonal=True,\n    drop=True,\n    additional_terms=[fourier],\n)\nX_time = dp.in_sample()\n\nmodel = LinearRegression(fit_intercept=False).fit(X_time, y)\ndeseason = y - model.predict(X_time)","2b48c693":"ax = deseason.plot()\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug (deseasonalized)')\nax.set(xlabel='Date', ylabel='Number of sales');","586a6070":"# Create lag features\nX_lags = make_lags(deseason, lags=1)\n\nX = X_lags.dropna()\ny, X = y.align(X, join='inner')\n\nmodel = LinearRegression().fit(X, y)\ny_pred = pd.Series(model.predict(X), index=X.index)","dbf15886":"ax = y.plot(**plot_params, alpha=0.5)\nax = y_pred.plot(ax=ax)\n\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticks(labels.to_list())\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","be6267f8":"y_lag = df_train.loc[:, 'num_sold'].shift(1)\n\n# 28-day mean of lagged target\nX['mean_7'] = y_lag.rolling(7).mean()\n# 14-day median of lagged target\nX['median_14'] = y_lag.rolling(14).median()\n# 7-day rolling standard deviation of lagged target\nX['std_7'] = y_lag.rolling(7).std()\n\nX = X.dropna()\ny, X = y.align(X, join='inner')\n\nmodel = LinearRegression().fit(X, y)\ny_pred = pd.Series(model.predict(X), index=X.index)","736b69a7":"ax = y.plot(**plot_params, alpha=0.5)\nax = y_pred.plot(ax=ax)\n\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticks(labels.to_list())\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","628abb1d":"train_predictions = []\ntest_predictions = []\nfor i in range(len(splitted_train_df)):\n    df_train = splitted_train_df[i].copy()\n    df_train = df_train.set_index('date')\n\n    df_test = splitted_test_df[i].copy()\n    df_test = df_test.set_index('date')\n\n    # Target\n    y = df_train.loc[:, 'num_sold']\n\n    # Start by deseasonalizing the series \n    fourier = CalendarFourier(freq='Y', order=4)\n    dp = DeterministicProcess(\n        constant=True,\n        index=y.index,\n        order=1,\n        seasonal=True,\n        drop=True,\n        additional_terms=[fourier],\n    )\n    X_time = dp.in_sample()\n    test_X_time = dp.out_of_sample(steps=len(df_test), forecast_index=df_test.index)\n\n    model = LinearRegression(fit_intercept=False).fit(X_time, y)\n    deseason = y - model.predict(X_time)\n    test_X_y = pd.Series(model.predict(test_X_time), index=df_test.index)\n    \n    # Make features from `deseason`\n    X = make_lags(deseason, lags=1)\n    X.fillna(X.mean(), inplace=True)\n    \n    test_X = make_lags(test_X_y, lags=1)\n    test_X.fillna(test_X_y.mean(), inplace=True)\n\n    # Create lagged targets\n    y_lag = df_train.loc[:, 'num_sold'].shift(1)\n    test_X_y_lag = test_X_y.shift(1)\n\n    # 28-day mean of lagged target\n    X['mean_7'] = y_lag.rolling(7).mean()\n    X.fillna(y_lag.mean(), inplace=True)\n    \n    test_X['mean_7'] = test_X_y_lag.rolling(7).mean()\n    test_X.fillna(test_X_y_lag.mean(), inplace=True)\n    \n    # 14-day median of lagged target\n    X['median_14'] = y_lag.rolling(14).median()\n    X.fillna(y_lag.median(), inplace=True)\n    \n    test_X['median_14'] = test_X_y_lag.rolling(14).median()\n    test_X.fillna(test_X_y_lag.median(), inplace=True)\n    \n    # 7-day rolling standard deviation of lagged target\n    X['std_7'] = y_lag.rolling(7).std()\n    X.fillna(y_lag.std(), inplace=True)\n    \n    test_X['std_7'] = test_X_y_lag.rolling(7).std()\n    test_X.fillna(test_X_y_lag.std(), inplace=True)\n    \n    # Train the model\n    model = LinearRegression()\n    model.fit(X, y)\n\n    # Make predictions\n    train_predictions.append(pd.Series(model.predict(X), index=X.index))\n    test_predictions.append(pd.Series(model.predict(test_X), index=test_X.index))","b3c0a6cd":"ax = splitted_train_df[0].loc[:, 'num_sold'].plot(**plot_params, alpha=0.5)\nax = pd.Series(data=train_predictions[0].values, index=splitted_train_df[0].index).plot(ax=ax)\n\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticks(ticks * 18)\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","c4eaf430":"predictions = np.zeros(len(test_predictions) * len(test_predictions[0]))\nfor i in range(len(test_predictions)):\n    for j in range(len(test_predictions[i])):\n        predictions[len(test_predictions) * j + i] = test_predictions[i][j]\noutput = create_submission('submission_time-series.csv', predictions)\noutput","700209b8":"gdp_df = pd.read_csv('..\/input\/gdp-20152019-finland-norway-and-sweden\/GDP_data_2015_to_2019_Finland_Norway_Sweden.csv')\ngdp_df.set_index('year', inplace=True)","c5571cff":"# Future Engineering for the end of the year\ndef engineer_end_of_year(df):\n    df = pd.concat([df,\n                        pd.DataFrame({f\"dec{d}\":\n                                      (df.date.dt.month == 12) & (df.date.dt.day == d)\n                                      for d in range(24, 32)}) * 1,\n                        pd.DataFrame({f\"n-dec{d}\":\n                                      (df.date.dt.month == 12) & (df.date.dt.day == d) & (df.country == 'Norway')\n                                      for d in range(24, 32)}) * 1,\n                        pd.DataFrame({f\"f-jan{d}\":\n                                      (df.date.dt.month == 1) & (df.date.dt.day == d) & (df.country == 'Finland')\n                                      for d in range(1, 14)}) * 1,\n                        pd.DataFrame({f\"jan{d}\":\n                                      (df.date.dt.month == 1) & (df.date.dt.day == d) & (df.country == 'Norway')\n                                      for d in range(1, 10)}) * 1,\n                        pd.DataFrame({f\"s-jan{d}\":\n                                      (df.date.dt.month == 1) & (df.date.dt.day == d) & (df.country == 'Sweden')\n                                      for d in range(1, 15)}) * 1],\n                       axis=1)\n    return df","34148150":"# Feature engineering\ndef engineer(df):\n    def get_gdp(row):\n        country = 'GDP_' + row.country\n        return gdp_df.loc[row.date.year, country]\n\n    df = pd.concat([df,\n                    pd.DataFrame({'gdp': np.log(df.apply(get_gdp, axis=1)),\n                           'wd4': (df.date.dt.weekday == 4) * 1, # Friday\n                           'wd56': (df.date.dt.weekday >= 5) * 1, # Saturday and Sunday\n                          })],\n                       axis=1)\n\n    # Seasonal variations (Fourier series)\n    # The three products have different seasonal patterns\n    dayofyear = df.date.dt.dayofyear\n    for k in range(1, 3):\n        df[f'sin{k}'] = np.sin(dayofyear \/ 365 * 2 * math.pi * k)\n        df[f'cos{k}'] = np.cos(dayofyear \/ 365 * 2 * math.pi * k)\n\n    # Apply other engineering methods and drop the unwanted columns\n    df = engineer_end_of_year(df)\n    df = engineer_holidays(df)\n    df = df.drop(['date', 'country', 'store', 'product'], axis=1)\n\n    return df","6d73bed2":"train_predictions = []\ntest_predictions = []\nfor i in range(len(splitted_train_df)):\n    df_train = splitted_train_df[i].copy()\n    df_test = splitted_test_df[i].copy()\n    \n    # Target\n    y = df_train.loc[:, 'num_sold']\n    df_train = df_train.drop('num_sold', axis=1)\n\n    # Create the feature set for the dates given in y.index\n    X = df_train.copy()\n    X = engineer(X)\n    \n    # Create features for forecast.\n    test_X = df_test.copy()\n    test_X = engineer(test_X)\n    \n    # Train the model - Instead of linear regression,\n    # I have used CatBoostRegressor now.\n    model = CatBoostRegressor(silent=True)\n    model.fit(X, y)\n\n    # Make predictions\n    train_predictions.append(pd.Series(model.predict(X), index=X.index))\n    test_predictions.append(pd.Series(model.predict(test_X), index=test_X.index))","c56817b9":"ax = splitted_train[0].loc[:, 'num_sold'].plot(**plot_params, alpha=0.5)\nax = train_predictions[0].plot(ax=ax)\n\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticks(ticks * 18)\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","76712b5f":"# Merge predictions\npredictions = merge_predictions(test_predictions)\n# Create submission\noutput = create_submission('submission_fe_other.csv', predictions)\noutput","1bacfd70":"class BoostedHybrid:\n    def __init__(self, model_1, model_2):\n        self.model_1 = model_1\n        self.model_2 = model_2\n        \n    def fit(self, X_1, X_2, y):\n        # Fit self.model_1\n        self.model_1.fit(X_1, y)\n        \n        # Make predictions with self.model_1\n        y_fit = pd.Series(self.model_1.predict(X_1), index=X_1.index,\n                          dtype=np.float32, name='num_sold')\n        \n        # Fit self.model_2 on residuals\n        y_resid = y - y_fit\n        self.model_2.fit(X_2, y_resid)\n        \n    def predict(self, X_1, X_2):\n        # Predict with self.model_1\n        y_pred = self.model_1.predict(X_1)\n        \n        # Add self.model_2 predictions to y_pred\n        y_pred += self.model_2.predict(X_2)\n        \n        return y_pred","ed686854":"train_predictions = []\ntest_predictions = []\nfor i in range(len(splitted_train_df)):\n    df_train = splitted_train_df[i].copy()\n    df_test = splitted_test_df[i].copy()\n    \n    # Target\n    y = df_train.loc[:, 'num_sold']\n    df_train = df_train.drop('num_sold', axis=1)\n    \n    # Features\n    X = engineer(df_train.copy())\n    test_X = engineer(df_test.copy())\n    \n    # X_1: Features for LinearRegression\n    features = ['gdp']\n    X_1 = X.loc[:, features].copy()\n    test_X_1 = test_X.loc[:, features].copy()\n    \n    # X_2: Features for CatBoostRegressor \n    X_2 = X.drop(features, axis=1).copy()\n    test_X_2 = test_X.drop(features, axis=1).copy()\n    \n    # Create LinearRegression + CatBoostRegressor hybrid with BoostedHybrid\n    model = BoostedHybrid(\n        model_1=LinearRegression(),\n        model_2=CatBoostRegressor(silent=True),\n    )\n    # Fit the model\n    model.fit(X_1, X_2, y)\n\n    # Make predictions\n    train_predictions.append(pd.Series(model.predict(X_1, X_2), index=X_1.index))\n    test_predictions.append(pd.Series(model.predict(test_X_1, test_X_2), index=test_X_1.index))","80f1315f":"ax = splitted_train[0].loc[:, 'num_sold'].plot(**plot_params, alpha=0.5)\nax = train_predictions[0].plot(ax=ax)\n\n# Set ticks, labels and titles,\n# Since splitted data has different indices, apply it to ticks\nax.set_xticks(ticks * 18)\nax.set_xticklabels(labels)\nax.set_title('Finland - KaggleMart - Kaggle Mug')\nax.set(xlabel='Date', ylabel='Number of sales');","f49d1c5d":"# Merge predictions\npredictions = merge_predictions(test_predictions)\n# Create submission\noutput = create_submission('submission_hybrid.csv', predictions)\noutput","59723276":"Take a look at the predictions and use test predictions to create submission.","b687914d":"Take a look at the predictions and use test predictions to create submission.","c5f6abb2":"Now create the features and get the predictions.","3a287604":"Take a look at the predictions and use test predictions to create submission.","a1f962b9":"## Create features for holidays\n\nIn the exercise of the third lesson, there is also a part about creating the holiday features.  \n\nSo, I have used [this notebook's](https:\/\/www.kaggle.com\/ambrosm\/tpsjan22-03-linear-model) feature engineering about holidays to reach the same goal. Credits to https:\/\/www.kaggle.com\/ambrosm.","57a2dd06":"## Create Submission\n\nVery simple helper function to create a submission.","806cc453":"Create the feature and get the predictions.","c916fef9":"# [Trend feature](https:\/\/www.kaggle.com\/ryanholbrook\/trend)\n\nFrom the second lesson create the trend feature.  \n\nMake a moving average plot to estimate and identify the trend.","5cccb238":"# Helper functions\n\n## Split data\n\nIn the time series course the first course is creating a Time-step feature and a Lag feature. The data it is using only contains the dates and the target. Hence, I will try to create the same features, but I need to split the data to the same format. I am not sure doing that will cause information to be lost since I will apply a regression algorithm for each piece separately.","5acff11e":"# [Hybrid Models](https:\/\/www.kaggle.com\/ryanholbrook\/hybrid-models)\n\nAs the fifth lesson suggests, create a boosted hybrid by implementing a new Python class.  \nAlso, add the fit and predict methods to give it a scikit-learn like interface.","9cb72fa7":"# [Seasonality](https:\/\/www.kaggle.com\/ryanholbrook\/seasonality)\n\nNow try to discover the trend and the seasonal patterns according to the third lesson.  \n\nLet's examine the periodogram.","23804e06":"Periodogram suggest a strong annual and weekly seasonality.\n\nUse DeterministicProcess and CalendarFourier to create:\n  * indicators for weekly seasons and\n  * Fourier features of order 4 for yearly seasons.","b0c814f2":"Check the periodogram of the deseasonalized series.","a5b52ed0":"Create and add statistical features and get the predictions.","2f7ea1db":"## Merge predictions\n\nFunction to merge predictions and sort the indices again, so that they can be used to create a submission after running the model.","6cdfac15":"# [Time Series as Features](https:\/\/www.kaggle.com\/ryanholbrook\/time-series-as-features)\n\nAccording to our fourth lesson trend and seasonality will both create serial dependence that shows up in correlograms and lag plots.  \nTo isolate any purely cyclic behavior, we'll start by deseasonalizing the series.","23c65f20":"# Importing Libraries and Loading datasets","cb6c124f":"Take a look at the predictions and use test predictions to create submission.","a69c2b19":"# Basic Data Check","d678e89b":"# [Time-step feature](https:\/\/www.kaggle.com\/ryanholbrook\/linear-regression-with-time-series)\n\nLet's apply I have learned from the first lesson, the time-step feature.  \n\nStart with the linear regression on number of sales.","d5f41b32":"# TPS - Jan 2022 - Time Series\n\nIn this notebook, I will try to implement what I have learned from the [time series course](https:\/\/www.kaggle.com\/learn\/time-series).","1471f8c1":"Take a look at the predictions and use test predictions to create submission.","977f30bc":"# Future engineering from another notebook\n\nCredits to https:\/\/www.kaggle.com\/ambrosm\/tpsjan22-03-linear-model, https:\/\/www.kaggle.com\/ambrosm","deb5083c":"Now create the features and get the predictions.","0892779b":"Now create the features and get the predictions.","864fd5cd":"Take a look at the predictions and use test predictions to create submission.","4ebc9235":"Now create the time dummy and get the predictions.","d4c5e164":"# Features and Modelling\n\n","0fac7cd7":"Take a look at the predictions and use test predictions to create submission.","63fbc4e8":"# Explore Data","6b2729dc":"Create time series features and get the predictions.","4ae7c40e":"Let's fit and check the seasonal model.","27d0446c":"Now create the features and get the predictions.","144e9038":"Now create the features and get the predictions."}}