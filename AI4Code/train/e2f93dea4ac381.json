{"cell_type":{"46b4a0f5":"code","57194113":"code","f458e8e8":"code","6f80e994":"code","812dd415":"code","84fbbc82":"code","c0d538ae":"code","2a00c8bb":"code","5add83e0":"code","c4ac5295":"code","13de5388":"code","dca34f23":"code","e9b78ab4":"code","082a28e5":"code","425e46a2":"code","0279dc33":"code","b1eb29c2":"code","8ac855c2":"code","6cc6e8e0":"code","bc7202ee":"code","d3b3e82b":"code","cac1c9bd":"code","cac6ba6e":"code","c21af937":"code","db373afa":"code","5bbe88db":"code","2a376988":"code","c22ee3b8":"code","fc4e90e3":"code","ba38fa53":"code","25fd1c2a":"code","b30c8084":"code","15a847b9":"code","e99c0b66":"code","ce40f87e":"code","1e3124b7":"code","e9be9155":"code","2f94a27e":"code","2673f579":"markdown","e4c78cc0":"markdown","9c3c60d1":"markdown","ced1eb2c":"markdown","366b100f":"markdown","f103755d":"markdown","3d14ebe9":"markdown","94164a4d":"markdown","f4b41896":"markdown","83b9b1e7":"markdown","409a7e40":"markdown","c203067c":"markdown","6fde3cbb":"markdown","101e32c5":"markdown","b2e013c8":"markdown","900745b1":"markdown","02f11e6c":"markdown","d79edfaf":"markdown","aef530c8":"markdown","567a6b3b":"markdown","181023b6":"markdown","4a313704":"markdown","56691075":"markdown"},"source":{"46b4a0f5":"from fastai.conv_learner import *\nfrom fastai.dataset import *\n\nimport pandas as pd\nimport numpy as np\nimport os\nfrom PIL import Image\nfrom sklearn.model_selection import train_test_split","57194113":"PATH = '.\/'\nTRAIN = '..\/input\/airbus-ship-detection\/train_v2\/'\nTEST = '..\/input\/airbus-ship-detection\/test_v2\/'\nSEGMENTATION = '..\/input\/airbus-ship-detection\/train_ship_segmentations_v2.csv'","f458e8e8":"nw = 2   #number of workers for data loader\narch = resnet34 #specify target architecture","6f80e994":"train_names = [f for f in os.listdir(TRAIN)]\ntest_names = [f for f in os.listdir(TEST)]\n#5% of data in the validation set is sufficient for model evaluation\ntr_n, val_n = train_test_split(train_names, test_size=0.05, random_state=42)\nsegmentation_df = pd.read_csv(os.path.join(PATH, SEGMENTATION)).set_index('ImageId')","812dd415":"def cut_empty(names):\n    return [name for name in names \n            if(type(segmentation_df.loc[name]['EncodedPixels']) != float)]\n\ntr_n = cut_empty(tr_n)\nval_n = cut_empty(val_n)","84fbbc82":"def get_mask(img_id, df):\n    shape = (768,768)\n    img = np.zeros(shape[0]*shape[1], dtype=np.uint8)\n    masks = df.loc[img_id]['EncodedPixels']\n    if(type(masks) == float): return img.reshape(shape)\n    if(type(masks) == str): masks = [masks]\n    for mask in masks:\n        s = mask.split()\n        for i in range(len(s)\/\/2):\n            start = int(s[2*i]) - 1\n            length = int(s[2*i+1])\n            img[start:start+length] = 1\n    return img.reshape(shape).T","c0d538ae":"class pdFilesDataset(FilesDataset):\n    def __init__(self, fnames, path, transform):\n        self.segmentation_df = pd.read_csv(SEGMENTATION).set_index('ImageId')\n        super().__init__(fnames, transform, path)\n    \n    def get_x(self, i):\n        img = open_image(os.path.join(self.path, self.fnames[i]))\n        if self.sz == 768: return img \n        else: return cv2.resize(img, (self.sz, self.sz),cv2.INTER_AREA)\n    \n    def get_y(self, i):\n        mask = np.zeros((768,768), dtype=np.uint8) if (self.path == TEST) \\\n            else get_mask(self.fnames[i], self.segmentation_df)\n        img = Image.fromarray(mask).resize((self.sz, self.sz),cv2.INTER_AREA).convert('RGB')\n        return np.array(img).astype(np.float32)\n    \n    def get_c(self): return 0","2a00c8bb":"def get_data(sz,bs):\n    #data augmentation\n    aug_tfms = [RandomRotate(10, tfm_y=TfmType.CLASS),\n                RandomDihedral(tfm_y=TfmType.CLASS),\n                RandomLighting(0.05, 0.05, tfm_y=TfmType.CLASS)]\n    tfms = tfms_from_model(arch, sz, crop_type=CropType.NO, tfm_y=TfmType.CLASS, \n                aug_tfms=aug_tfms)\n    tr_names = tr_n if (len(tr_n)%bs == 0) else tr_n[:-(len(tr_n)%bs)] #cut incomplete batch\n    ds = ImageData.get_ds(pdFilesDataset, (tr_names,TRAIN), \n                (val_n,TRAIN), tfms, test=(test_names,TEST))\n    md = ImageData(PATH, ds, bs, num_workers=nw, classes=None)\n    return md","5add83e0":"cut,lr_cut = model_meta[arch]\ndef get_base(pre=True):                   #load ResNet34 model\n    layers = cut_model(arch(pre), cut)\n    return nn.Sequential(*layers)","c4ac5295":"class ResBlock(nn.Module):\n    def __init__(self, x_in, filters=64):\n        super().__init__()\n        self.conv1 = nn.Conv2d(x_in,filters,1)\n        self.bn1 = nn.BatchNorm2d(filters)\n        self.conv2 = nn.Conv2d(filters,filters,(3,3),padding=1)\n        self.bn2 = nn.BatchNorm2d(filters)\n        self.conv3 = nn.Conv2d(filters,x_in,1)\n        \n    def forward(self, x):\n        r = self.conv1(x)\n        r = F.relu(r)\n        r = self.bn1(r)\n        r = self.conv2(r)\n        r = F.relu(r)\n        r = self.bn2(r)\n        r = self.conv3(r)\n        return x + r\n    \nclass SEBlock(nn.Module):\n    def __init__(self, channel, reduction=16):\n        super(SEBlock, self).__init__()\n        self.avg_pool = nn.AdaptiveAvgPool2d(1)\n        self.fc = nn.Sequential(\n                nn.Linear(channel, channel \/\/ reduction),\n                nn.ReLU(inplace=True),\n                nn.Linear(channel \/\/ reduction, channel),\n                nn.Sigmoid())\n\n    def forward(self, x):\n        b, c, _, _ = x.size()\n        y = self.avg_pool(x).view(b, c)\n        y = self.fc(y).view(b, c, 1, 1)\n        return x * y\n\nclass UnetBlock(nn.Module):\n    def __init__(self, up_in, x_in, n_out, dropout=0.0):\n        super().__init__()\n        up_out = x_out = n_out\/\/2\n        self.x_conv  = nn.Conv2d(x_in,  x_out,  1)\n        self.tr_conv = nn.ConvTranspose2d(up_in, up_out, 2, stride=2)\n        self.cat_conv = nn.Conv2d(n_out, n_out, (3,3), padding=(1,1))\n        self.bn = nn.BatchNorm2d(n_out)\n        self.se = SEBlock(n_out)\n        self.dropout = nn.Dropout2d(dropout)\n        self.r = ResBlock(n_out,n_out\/\/2)\n        #self.conv1 = nn.Conv2d(2*n_out,n_out,1)\n        #self.conv2 = nn.Conv2d(n_out,n_out,1)\n        #self.bn_g = nn.BatchNorm2d(n_out)\n        #self.GLU = nn.GLU(dim=1)\n        #self.conv1 = nn.Conv2d(n_out,n_out,(3,3), padding=(1,1))\n        #self.conv2 = nn.Conv2d(n_out,n_out,(3,3), padding=(1,1))\n        #self.bn_in = nn.BatchNorm2d(n_out)\n        \n    def forward(self, up_p, x_p):\n        up_p = self.tr_conv(up_p)\n        x_p = self.x_conv(x_p)\n        cat_p = self.dropout(torch.cat([up_p,x_p], dim=1))\n        x = self.bn(F.relu(self.cat_conv(cat_p)))\n        x = self.r(x)\n        #g = self.bn_g(self.conv2(F.relu(self.conv1(cat_p))))\n        #x = self.GLU(torch.cat([x_p,g], dim=1))\n        x = self.se(x)\n        return x\n\nclass SaveFeatures():\n    features=None\n    def __init__(self, m): self.hook = m.register_forward_hook(self.hook_fn)\n    def hook_fn(self, module, input, output): self.features = output\n    def remove(self): self.hook.remove()\n    \nclass Unet34SE_hc(nn.Module):\n    def __init__(self, rn, dropout = 0.0):\n        super().__init__()\n        self.rn = rn\n        self.hc_sz = 16\n        self.filters = [64,64,128,256,512]\n        self.u_out = [self.hc_sz,128,128,256,256]\n        self.sfs = [SaveFeatures(rn[i]) for i in [2,4,5,6]]\n        self.up1 = UnetBlock(self.filters[4],self.filters[3],self.u_out[4],dropout)\n        self.up2 = UnetBlock(self.u_out[4],self.filters[2],self.u_out[3],dropout)\n        self.up3 = UnetBlock(self.u_out[3],self.filters[1],self.u_out[2],dropout\/2)\n        self.up4 = UnetBlock(self.u_out[2],self.filters[0],self.u_out[1])\n        self.up5 = nn.ConvTranspose2d(self.u_out[1], self.u_out[0], 2, stride=2)\n        self.hc_neck1 = nn.Conv2d(self.u_out[4], self.hc_sz, 1)\n        self.hc_neck2 = nn.Conv2d(self.u_out[3], self.hc_sz, 1)\n        self.hc_neck3 = nn.Conv2d(self.u_out[2], self.hc_sz, 1)\n        self.hc_neck4 = nn.Conv2d(self.u_out[1], self.hc_sz, 1)\n        self.head = nn.Sequential(nn.Conv2d(5*self.hc_sz,2*self.hc_sz,3,padding=1),\n                                 nn.ReLU(inplace=True),\n                                 nn.Conv2d(2*self.hc_sz,1,1))\n        \n    def forward(self,x):\n        x = F.relu(self.rn(x))\n        x = self.up1(x, self.sfs[3].features)\n        hc1 = self.hc_neck1(x)\n        x = self.up2(x, self.sfs[2].features)\n        hc2 = self.hc_neck2(x)\n        x = self.up3(x, self.sfs[1].features)\n        hc3 = self.hc_neck3(x)\n        x = self.up4(x, self.sfs[0].features)\n        hc4 = self.hc_neck4(x)\n        x = self.up5(x)\n        x = torch.cat((x,\n            F.interpolate(hc4,scale_factor=2,mode='bilinear'),\n            F.interpolate(hc3,scale_factor=4,mode='bilinear'),\n            F.interpolate(hc2,scale_factor=8,mode='bilinear'),\n            F.interpolate(hc1,scale_factor=16,mode='bilinear'),\n            ),dim=1)\n        x = self.head(x)\n        return x[:,0]\n    \n    def close(self):\n        for sf in self.sfs: sf.remove()\n            \nclass UnetModel():\n    def __init__(self,model,name='Unet'):\n        self.model,self.name = model,name\n\n    def get_layer_groups(self, precompute):\n        lgs = list(split_by_idxs(children(self.model.rn), [lr_cut]))\n        return lgs + [children(self.model)[1:]]","13de5388":"def dice_loss(input, target):\n    input = torch.sigmoid(input)\n    smooth = 1.0\n\n    iflat = input.view(-1)\n    tflat = target.view(-1)\n    intersection = (iflat * tflat).sum()\n    \n    return ((2.0 * intersection + smooth) \/ (iflat.sum() + tflat.sum() + smooth))","dca34f23":"class FocalLoss(nn.Module):\n    def __init__(self, gamma):\n        super().__init__()\n        self.gamma = gamma\n        \n    def forward(self, input, target):\n        if not (target.size() == input.size()):\n            raise ValueError(\"Target size ({}) must be the same as input size ({})\"\n                             .format(target.size(), input.size()))\n\n        max_val = (-input).clamp(min=0)\n        loss = input - input * target + max_val + \\\n            ((-max_val).exp() + (-input - max_val).exp()).log()\n\n        invprobs = F.logsigmoid(-input * (target * 2.0 - 1.0))\n        loss = (invprobs * self.gamma).exp() * loss\n        \n        return loss.mean()","e9b78ab4":"class MixedLoss(nn.Module):\n    def __init__(self, alpha, gamma):\n        super().__init__()\n        self.alpha = alpha\n        self.focal = FocalLoss(gamma)\n        \n    def forward(self, input, target):\n        loss = self.alpha*self.focal(input, target) - torch.log(dice_loss(input, target))\n        return loss.mean()","082a28e5":"def dice(pred, targs):\n    pred = (pred>0).float()\n    return 2.0 * (pred*targs).sum() \/ ((pred+targs).sum() + 1.0)\n\ndef IoU(pred, targs):\n    pred = (pred>0).float()\n    intersection = (pred*targs).sum()\n    return intersection \/ ((pred+targs).sum() - intersection + 1.0)","425e46a2":"m = to_gpu(Unet34SE_hc(get_base(True),0.15))\nmodels = UnetModel(m)","0279dc33":"#models.model","b1eb29c2":"sz = 256 #image size\nbs = 24#64  #batch size\n\nmd = get_data(sz,bs)","8ac855c2":"learn = ConvLearner(md, models)\nlearn.opt_fn=optim.Adamax\nlearn.clip = 1.0\nlearn.crit = MixedLoss(10.0, 2.0)\nlearn.metrics=[accuracy_thresh(0.5),dice,IoU]\nwd=1e-7\nlr = 2.5e-3","6cc6e8e0":"learn.summary()","bc7202ee":"#learn.freeze_to(1)","d3b3e82b":"learn.fit(lr,1,wds=wd,cycle_len=1,use_clr=(5,8))","cac1c9bd":"learn.save('Unet34r_256_0')","cac6ba6e":"lrs = np.array([lr\/100,lr\/10,lr])\nlearn.unfreeze() #unfreeze the encoder\nlearn.bn_freeze(True)","c21af937":"learn.fit(lrs,2,wds=wd,cycle_len=1,use_clr=(20,8))","db373afa":"learn.fit(lrs\/3,2,wds=wd,cycle_len=2,use_clr=(20,8))","5bbe88db":"learn.sched.plot_lr()","2a376988":"learn.save('Unet34r_256_1')","c22ee3b8":"def Show_images(x,yp,yt):\n    columns = 3\n    rows = min(bs,8)\n    fig=plt.figure(figsize=(columns*4, rows*4))\n    for i in range(rows):\n        fig.add_subplot(rows, columns, 3*i+1)\n        plt.axis('off')\n        plt.imshow(x[i])\n        fig.add_subplot(rows, columns, 3*i+2)\n        plt.axis('off')\n        plt.imshow(yp[i])\n        fig.add_subplot(rows, columns, 3*i+3)\n        plt.axis('off')\n        plt.imshow(yt[i])\n    plt.show()","fc4e90e3":"learn.model.eval();\nx,y = next(iter(md.val_dl))\nyp = to_np(F.sigmoid(learn.model(V(x))))","ba38fa53":"Show_images(np.asarray(md.val_ds.denorm(x)), yp, y)","25fd1c2a":"sz = 384 #image size\nbs = 16  #batch size\n\nmd = get_data(sz,bs)\nlearn.set_data(md)\nlearn.unfreeze()\nlearn.bn_freeze(True)","b30c8084":"#learn.fit(lrs\/5,1,wds=wd,cycle_len=2,use_clr=(10,8))","15a847b9":"#learn.save('Unet34r_384_1')","e99c0b66":"learn.model.eval();\nx,y = next(iter(md.val_dl))\nyp = to_np(F.sigmoid(learn.model(V(x))))","ce40f87e":"Show_images(np.asarray(md.val_ds.denorm(x)), yp, y)","1e3124b7":"#sz = 768 #image size\n#bs = 6  #batch size\n\n#md = get_data(sz,bs)\n#learn.set_data(md)\n#learn.unfreeze()\n#learn.bn_freeze(True)","e9be9155":"#learn.fit(lrs\/10,1,wds=wd,cycle_len=1,use_clr=(10,8))","2f94a27e":"#learn.save('Unet34_768_1')","2673f579":"### Model","e4c78cc0":"The results are not ideal, but almost all ships are captured correctly even if the model is making the prediction on a very low resolution (256x256) images.","9c3c60d1":"### Training (768x768)","ced1eb2c":"And finally, I put a picture (original image, prediction, ground truth) obtained by the model with dice 0.895 trained further on full resolution images in an independent run. Apart from one tiny ship in the last image, everything is captured. When I zoomed it in, it is really not clear if it is a ship of just a small island: I see only several white pixels, and there are several small islands under the water. Another interesting thing is that the model is able to capture details that it was not trained for. In particular, in 4-th image the model captures antennas (upper right ship) and the shape of ships, even if training set is composed of pixelized bounding boxes.","366b100f":"### Visualization","f103755d":"The model used in this kernel is inspired by a Carvana example from FastAI course (http:\/\/course.fast.ai\/index.html). It is composed of a ResNet34 based encoder and a simple upsampling decoder. Similar to the original U-net, skip connections are added between encoder and decoder to facilitate the information flow at different detalization levels. Meanwhile, using a pretrained ResNet34 model allows us to have a powerful encoder capable of handling elaborated feature, in comparison with the original U-net, without a risk of overfitting and necessity of training a big model from scratch. The total capacity of the model is ~21M parameters. Before using, the original ResNet34 model was further fine-tuned on ship\/no-ship classification task (https:\/\/www.kaggle.com\/iafoss\/fine-tuning-resnet34-on-ship-detection).","3d14ebe9":"## Overview","94164a4d":"Saved model can be ued for further training or for making predictions.","f4b41896":"Unfreeze the model and train it with differential learning rate. The lr of the head part is still 1e-3, while the middle layers of the model are trained with 1e-4 lr, and the base is trained with even smaller lr, 1e-5, since low level detectors do not vary much from one image data set to another.","83b9b1e7":"### Data","409a7e40":"There are two most obvious network architectures to approach this competition: U-net and SSD. Each of them has pros and cons. In particular, U-net provides a relatively simple way to solve the competition challenge using image segmentation. However, this competition requires prediction of an individual mask for each ship rather than one mask for entire image. Therefore, some creative postprocessing may be needed, especially to separate ships with overlapping masks, if it is even possible. Another drawback is that the data is labeled with using pixelized bounding boxes rather than real ship masks, therefore the score of U-net based models is lowered. Meanwhile, implementation of SSD requires usage of rotating bounding boxes (https:\/\/arxiv.org\/pdf\/1711.09405.pdf) that is not common and, therefore, would take additional efforts for development of the model and the corresponding loss function. In addition, bounding boxes are not provided in this competition and must be generated based on the pixel masks. Nevertheless, this approach is expected to provide higher score than U-net, especially since the data is labeled based on pixelized bounding boxes (I expect organizers used SSD with rotating bounding boxes to label train and test data).\nSince the first approach is more straightforward, I'll begin with presenting a kernel about U-net. In this post I will describe how to use pretrained ResNet34 to build a high accuracy image segmentation model. In particular, after training only a decoder for 1 epoch (15 min) on 256x256 rescaled images, the dice coefficient reaches ~0.8 (IoU ~0.67) that significantly outperforms all publicly available models posted so far in this competition. After training the entire model for 6 additional epochs with learning rate annealing, the dice coefficient reaches ~0.86 (IoU ~0.75). Due to the kernel run time limit, the model is further trained only for two epochs on 384x384 (dice ~0.87) followed by one epoch on 768x768 images. In an independent run I trained a model on 384x384 images for 12 epochs that boosted dice to 0.89 followed by training on full resolution images that increased dice further to 0.905.","c203067c":"![1](https:\/\/image.ibb.co\/mrqdze\/Ship_Detection.png)","6fde3cbb":"Training for just one epoch is insufficient to achieve high dice. However, if the training is continued, the dice can reach 0.90+.","101e32c5":"### Training","b2e013c8":"Fortunately, modern convolutional nets support input images of arbitrary resolution. To decrease the training time, one can start training the model on low resolution images first and continue training on higher resolution images for fewer epochs. In addition, a model pretrained on low resolution images first generalizes better since a pixel information is less available and high order features are tended to be used.","900745b1":"One of the challenges of this competition is strong data unbalance. Even if only images with ships are considered, the ratio of mask pixels to the total number of pixels is ~1:1000. If images with no ships are included, this ratio goes to ~1:10000, which is quite tough to handle. Therefore, I drop all images without ships, that makes the training set more balanced and also reduces the time per each epoch almost by 4 times. In an independent run, when the dice of my model reached 0.895, I ran it on images without ships and identified ~3600 false positive predictions out ~70k images. The incorrectly predicted images were incorporated to the training set as negative examples, and training was continued. The problem of false positive predictions can be further mitigated by stacking U-net model with a classification model predicting if ships are present in a particular image (https:\/\/www.kaggle.com\/iafoss\/fine-tuning-resnet34-on-ship-detection - ~98% accuracy). \nI also noticed that in some kernels the dataset is tried to be balanced by keeping approximately the same number of images with 0, 1, 2, etc. ships. However, this strategy would be effective for such task as ship counting rather than training U-net or SSD.  One possible way to balance the dataset is creative cropping the images that keeps approximately the same number of pixels corresponding to a ship or something else. However, I doubt that such approach will effective in this competition. Therefore, a special loss function must be used to mitigate the data unbalance.","02f11e6c":"### Visualization","d79edfaf":"Due to the kernel run time limit, the model was further trained only for two epochs on 384x384 (dice ~0.87) followed by one epoch on 768x768 images. In an independent run I trained a model on 384x384 images for 12 epochs that boosted dice to 0.89 followed by training on full resolution images that increased dice further to 0.905.","aef530c8":"### Loss function","567a6b3b":"### Training (384x384)","181023b6":"Loss function is one of the most crucial parts of the completion. Due to strong data unbalance, simple loss functions, such as Binary Cross-Entropy loss, do not really work. Soft dice loss can be helpful since it boosts prediction of correct masks, but it leads to unstable training. Winners of image segmentation challenges typically combine BCE loss with dice (http:\/\/blog.kaggle.com\/2017\/12\/22\/carvana-image-masking-first-place-interview\/). Similar loss function is used in publicly available models in this completion. I would agree that this combined loss function works perfectly for Carvana completion, where the number of pixels in the mask is about half of the total number of pixels. However, 1:1000 pixel unbalance deteriorates training with BCE. \nIf one tries to recall what is the loss function that should be used for strongly unbalanced data set, it is focal loss (https:\/\/arxiv.org\/pdf\/1708.02002.pdf), which revolutionized one stage object localization method in 2017. This loss function demonstrates amazing results on datasets with unbalance level 1:10-1000. In addition to focal loss, I include -log(soft dice loss). Log is important in the convex of the current competition since it boosts the loss for the cases when objects are not detected correctly and dice is close to zero. It allows to avoid false negative predictions or completely incorrect masks for images with one ship (the major part of the training set). Also, since the loss for such objects is very high, the model more effectively incorporates the knowledge about such objects and handles them even in images with multiple ships. To bring two losses to similar scale, focal loss is multiplied by 10. The implementation of focal loss is borrowed from https:\/\/becominghuman.ai\/investigating-focal-and-dice-loss-for-the-kaggle-2018-data-science-bowl-65fb9af4f36c .","4a313704":"Training only the decoder part for 1 epoch (15 min) leads to ~0.8 dice that outperforms all publicly available models in this competition.","56691075":"The training has been run with learning rate annealing. Periodic lr increase followed by slow decrease drives the system out of steep minima (when lr is high) towards broader ones (which are explored when lr decreases) that enhances the ability of the model to generalize and reduces overfitting."}}