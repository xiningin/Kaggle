{"cell_type":{"1cc737d0":"code","1ffa9764":"code","0d31c2e0":"code","5598a44b":"code","f6e0acde":"code","8c4bfd2d":"code","c168438b":"code","21d57687":"code","a665527f":"code","242d7e76":"code","2333d9dc":"code","83413ba3":"code","e5ad8c00":"code","d258d033":"code","e1f8eb6d":"code","4497967f":"code","4d3b1003":"code","e45cee46":"code","158875e2":"code","782e74dc":"code","d2671a38":"code","2573db7b":"code","c3d54c40":"code","20cff2e7":"code","1ae53c11":"code","60656c8c":"code","c7f8f8d5":"code","335f2819":"code","434378e2":"code","de1ff16d":"code","31f7024b":"code","2758ee11":"code","d3553045":"code","9bc09a6d":"markdown","723573e7":"markdown","c5f83e41":"markdown","71ce5d24":"markdown","83e334b3":"markdown","df3cc88f":"markdown","567e3dfe":"markdown","27c12f11":"markdown","2de06fd3":"markdown","f1f9da68":"markdown","7c772bf1":"markdown","aa169b42":"markdown","62ba8de8":"markdown","a62ae1f1":"markdown","42d6f299":"markdown","383afb5f":"markdown","8ff2e6a8":"markdown","59c3da9b":"markdown","05a0648e":"markdown","653b8bd0":"markdown","a9b07b90":"markdown","f1491545":"markdown","de88de84":"markdown","817239f3":"markdown","a2605ba0":"markdown","9c846edc":"markdown","bd0ac9b2":"markdown","43a4a15f":"markdown","8fcf8730":"markdown","f31b053b":"markdown","1287f48e":"markdown","6b8e30e2":"markdown","54774f84":"markdown"},"source":{"1cc737d0":"import os\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom tqdm import tqdm_notebook\n\n%matplotlib inline\nfrom matplotlib import pyplot as plt\nplt.style.use(['seaborn-darkgrid'])\nplt.rcParams['figure.figsize'] = (12, 9)\nplt.rcParams['font.family'] = 'DejaVu Sans'\n\nfrom sklearn import metrics\nfrom sklearn.cluster import KMeans, AgglomerativeClustering, SpectralClustering\nfrom sklearn.decomposition import PCA\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.svm import LinearSVC\n\nRANDOM_STATE = 17","1ffa9764":"# change this if necessary\nPATH_TO_SAMSUNG_DATA = \"..\/input\"","0d31c2e0":"X_train = np.loadtxt(os.path.join(PATH_TO_SAMSUNG_DATA, \"samsung_train.txt\"))\ny_train = np.loadtxt(os.path.join(PATH_TO_SAMSUNG_DATA,\n                                  \"samsung_train_labels.txt\")).astype(int)\n\nX_test = np.loadtxt(os.path.join(PATH_TO_SAMSUNG_DATA, \"samsung_test.txt\"))\ny_test = np.loadtxt(os.path.join(PATH_TO_SAMSUNG_DATA,\n                                  \"samsung_test_labels.txt\")).astype(int)","5598a44b":"# Checking dimensions\nassert(X_train.shape == (7352, 561) and y_train.shape == (7352,))\nassert(X_test.shape == (2947, 561) and y_test.shape == (2947,))","f6e0acde":"# Your code here\nX = np.vstack([X_train, X_test])\ny = np.hstack([y_train, y_test])","8c4bfd2d":"np.unique(y)","c168438b":"n_classes = np.unique(y).size","21d57687":"# Your code here\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)","a665527f":"# Your code here\npca = PCA(n_components=0.9, random_state=RANDOM_STATE).fit(X_scaled)\nX_pca = pca.transform(X_scaled)","242d7e76":"#\u0412 Your code here\nX_pca.shape","2333d9dc":"# Your code here\nround(float(pca.explained_variance_ratio_[0] * 100))","83413ba3":"# Your code here\nplt.scatter(X_pca[:, 0], X_pca[:, 1], c=y, s=20, cmap='viridis');","e5ad8c00":"# Your code here\nkmeans = KMeans(n_clusters=n_classes, n_init=100, \n                random_state=RANDOM_STATE, n_jobs=1)\nkmeans.fit(X_pca)\ncluster_labels = kmeans.labels_","d258d033":"# Your code here\nplt.scatter(X_pca[:, 0], X_pca[:, 1], c=cluster_labels, s=20,  \n            cmap='viridis');","e1f8eb6d":"tab = pd.crosstab(y, cluster_labels, margins=True)\ntab.index = ['walking', 'going up the stairs',\n            'going down the stairs', 'sitting', 'standing', 'lying', 'all']\ntab.columns = ['cluster' + str(i + 1) for i in range(6)] + ['all']\ntab","4497967f":"pd.Series(tab.iloc[:-1,:-1].max(axis=1).values \/ \n          tab.iloc[:-1,-1].values, index=tab.index[:-1])","4d3b1003":"# Your code here\ninertia = []\nfor k in tqdm_notebook(range(1, n_classes + 1)):\n    kmeans = KMeans(n_clusters=k, n_init=100, \n                    random_state=RANDOM_STATE, n_jobs=1).fit(X_pca)\n    inertia.append(np.sqrt(kmeans.inertia_))","e45cee46":"plt.plot(range(1, 7), inertia, marker='s');","158875e2":"d = {}\nfor k in range(2, 6):\n    i = k - 1\n    d[k] = (inertia[i] - inertia[i + 1]) \/ (inertia[i - 1] - inertia[i])","782e74dc":"d","d2671a38":"ag = AgglomerativeClustering(n_clusters=n_classes, \n                             linkage='ward').fit(X_pca)","2573db7b":"# Your code here\nprint('KMeans: ARI =', metrics.adjusted_rand_score(y, cluster_labels))\nprint('Agglomerative CLustering: ARI =', \n      metrics.adjusted_rand_score(y, ag.labels_))","c3d54c40":"# Your code here\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)","20cff2e7":"svc = LinearSVC(random_state=RANDOM_STATE)\nsvc_params = {'C': [0.001, 0.01, 0.1, 1, 10]}","1ae53c11":"%%time\n# Your code here\nbest_svc = GridSearchCV(svc, svc_params, n_jobs=1, cv=3, verbose=1)\nbest_svc.fit(X_train_scaled, y_train);","60656c8c":"best_svc.best_params_, best_svc.best_score_","c7f8f8d5":"y_predicted = best_svc.predict(X_test_scaled)","335f2819":"tab = pd.crosstab(y_test, y_predicted, margins=True)\ntab.index = ['walking', 'climbing up the stairs',\n             'going down the stairs', 'sitting', 'standing', 'lying', 'all']\ntab.columns = ['walking', 'climbing up the stairs',\n             'going down the stairs', 'sitting', 'standing', 'lying', 'all']\ntab","434378e2":"# Your code here\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n\npca = PCA(n_components=0.9, random_state=RANDOM_STATE)\nX_train_pca = pca.fit_transform(X_train_scaled)\nX_test_pca = pca.transform(X_test_scaled)","de1ff16d":"svc = LinearSVC(random_state=RANDOM_STATE)\nsvc_params = {'C': [0.001, 0.01, 0.1, 1, 10]}","31f7024b":"%%time\nbest_svc_pca = GridSearchCV(svc, svc_params, n_jobs=1, cv=3, verbose=1)\nbest_svc_pca.fit(X_train_pca, y_train);","2758ee11":"best_svc_pca.best_params_, best_svc_pca.best_score_","d3553045":"round(100 * (best_svc_pca.best_score_ - best_svc.best_score_))","9bc09a6d":"Define the number of unique values of the labels of the target class.","723573e7":"Look at the correspondence between the cluster marks and the original class labels and what kinds of activities the `KMeans` algorithm is confused at.","c5f83e41":"You can notice that the task is not very well solved just as a clustering task if you select several clusters (> 2). Now, let's solve the classification problem, given that the data is marked up.\n\nFor classification, use the support vector machine - class `sklearn.svm.LinearSVC`. \n\nChoose the `C` hyperparameter for` LinearSVC` using `GridSearchCV`.\n\n- Train the new `StandardScaler` on the training sample (with all the original features), apply scaling to the test sample\n- In `GridSearchCV`, specify cv = 3.","71ce5d24":"Visualize the data in the projection on the first two main components.","83e334b3":"**Question 6:** <br>\nSelect all the correct statements. <br>\n\n**Answer options:**\n- ARI expresses the similarity of the tags obtained after clustering, with class labels for the same sample and the higher the value of this index, the better **[+]**\n- According to ARI, KMeans handled clustering worse than Agglomerative Clustering **[+]**\n- For ARI, it does not matter which tags are assigned to the cluster, only the partitioning of objects into clusters is important **[+]**\n- In case of random partitioning into clusters ARI will be close to zero **[+]**\n\n\n**Comment:**\n1. Described in the \"Adjusted Rand Index (ARI)\" section [articles](https:\/\/www.kaggle.com\/kashnitsky\/topic-7-unsupervised-learning-pca-and-clustering) - the cluster labels and class labels are compared\n2. Yes, the higher the ARI, the better\n3. Yes, if you renumber clusters differently, ARI will not change\n4. True","df3cc88f":"**Question 7**<br>\nWhich value of the hyperparameter `C` was chosen the best on the basis of cross-validation? <br>\n\n**Answer options:**\n- 0.001\n- 0.01\n- 0.1 **[+]**\n- 1\n- 10","567e3dfe":"**Question 8:** <br>\nDoes SVM confuse the classes inside the activity groups we identified earlier (in the question 3)? We consider that it is confused, if the algorithm was wrong at least in one case. <br>\n\n**Answer options:**\n- yes **[+]**\n- no\n\n**Comment:**\nThe classifier solved the problem well, but not ideally.","27c12f11":"**Question 10:** <br>\nSelect all the correct statements:\n\n**Answer options:**\n- Principal component analysis in this case allowed to reduce the model training time, while the quality (the proportion of correct responses on cross-validation) suffered greatly, by more than 10%\n- PCA can be used to visualize data, but there are better methods for this task, for example, tSNE. But PCA has less computational complexity **[+]**\n- PCA builds linear combinations of initial characteristics that are poorly interpreted by humans **[+]**\n- SVM works better than kMeans, since it clearly reduces the algorithm to the optimization problem\n\n**Comment:**\n1. The first statement is true, principal component analysis in this case allowed to significantly reduce the training time of the model, but the quality suffered not so much - only by 4%\n2. For multidimensional data visualization it is better to use manifold learning methods, in particular, tSNE. At the same time, metrics assessing the quality of visualization have not really been invented yet, but tSNE is widely used precisely because in some cases it builds \"good\" pictures showing the data structure, as in the example with MNIST\n3. Linear combinations of features that build PCA are poorly interpreted by humans, for example, 0.574 \\* salary + 0.234 \\* num_children\n4. This option has a dirty trick: SVM and kMeans in general should not be compared - they solve different tasks.","2de06fd3":"For clustering, we do not need a target vector, so we'll work with the combination of training and test samples. Merge * X_train * with * X_test *, and * y_train * with * y_test *.","f1f9da68":"Let's try another method of clustering, which was described in the article - agglomerative clustering.","7c772bf1":"We see that for each class (i.e., each activity) there are several clusters. Let's look at the maximum percentage of objects in a class that are assigned to a single cluster. This will be a simple metric that characterizes how easily the class separates from others when clustering.\n\nExample: if for the class of \"going down the stairs\", in which there are 1406 objects, the distribution of clusters is:\n - cluster 1 - 900\n - cluster 3 - 500\n - cluster 6 - 6,\n \nthen such a share will be 900\/1406 $ \\approx $ 0.64.\n \n\n**Question 4:** <br>\nWhich activity has been separated from the rest better than others based on the simple metric described above? <br>\n\n**Answer:**\n- walking\n- standing\n- going down the stairs\n- there is no correct answer **[+]**","aa169b42":"Finally, do the same thing as in Question 7, but add the PCA.\n\n- Use the samples `X_train_scaled` and` X_test_scaled`\n- Teach the same PCA as before, on a scaled training sample, apply the conversion to a test\n- Choose the hyperparameter `C` with cross-validation on the training sample with PCA-transformation. You will notice how much faster it works than before.\n\n**Question 9:** <br>\nWhat is the difference between the best quality (the proportion of correct answers) for cross-validation in the case of all 561 initial characteristics and in the second case, when the principal component method was applied? Round to the nearest percent. <br>\n\n**Answer options:**\n- The quality is the same\n- 2%\n- 4% **[+]**\n- 10%\n- 20%","62ba8de8":"[These labels correspond to:](https:\/\/archive.ics.uci.edu\/ml\/machine-learning-databases\/00240\/UCI%20HAR%20Dataset.names)\n- 1 - walking\n- 2 - going up the stairs\n- 3 - going down the stairs\n- 4 - sitting\n- 5 - standing\n- 6 - lying down","a62ae1f1":"In this task, we will look at how data dimensionality reduction and clustering methods work. At the same time, we'll practice solving classification task again.\n\nWe will work with the [Samsung Human Activity Recognition] (https:\/\/archive.ics.uci.edu\/ml\/datasets\/Human+Activity+Recognition+Using+Smartphones) dataset. Download the data [here] (https:\/\/cloud.mail.ru\/public\/3EJK\/cB2VXsyrP). The data comes from the accelerometers and gyros of Samsung Galaxy S3 mobile phones ( you can find more info about the features using on the link above), the type of activity of a person with a phone in his pocket is also known - whether he walked, stood, lay, sat or walked up or down the stairs.\n\nFirst we imagine that the type of activity is unknown to us, and we will try to cluster people purely on the basis of available features. Then we solve the problem of determining the type of physical activity precisely as a classification problem.\n\nFill the code where needed (\"Your code is here\") and answer the questions in the [web form](https:\/\/docs.google.com\/forms\/d\/1ga4KcJdwMWsgEeE76vcTQ34C2iLF7VMhM6nIh_BHUNE).","42d6f299":"The result with PCA is worse by 4%, comparing the best proportion of correct answers on cross-validation.","383afb5f":"**Question 1:** <br>\nWhat is the minimum number of main components required to cover the 90% of the variance of the original (scaled) data?","8ff2e6a8":"Scale the sample using `StandardScaler` with default parameters.","59c3da9b":"------------------------------","05a0648e":"Reduce the number of dimensions using PCA, leaving as many components as necessary to explain at least 90% of the variance of the original (scaled) data. Use the scaled sample and fix the random_state (RANDOM_STATE constant).","653b8bd0":"Run the data clustering using the `KMeans` method, training the model on data with a reduced PCA dimension. In this case, we will give a clue to look for exactly 6 clusters, but in general case we will not know how many clusters we should be searching.\n\nOptions:\n\n- **n_clusters** = n_classes (number of unique labels of the target class)\n- **n_init** = 100\n- **random_state** = RANDOM_STATE (for the reproducibility of the result)\n\nOther parameters should have default values.","a9b07b90":"**Question 2:**<br>\nWhat percentage of the variance is covered by the first main component? Round to the nearest percent.\n\n**Answer options:**\n- 45\n- 51 **[+]**\n- 56\n- 61","f1491545":"------------------------","de88de84":"**Question 3:**<br>\nIf everything worked out correctly, you will see a number of clusters, almost perfectly separated from each other. What types of activity are included in these clusters? <br>\n\n**Answer options:**\n- 1 cluster: all 6 activities\n- 2 clusters: (walking, going up the stairs, going down the stairs ) and (sitting, standing, lying) ** [+] **\n- 3 clusters: (walking), (going up the stairs, going down the stairs) and (sitting, standing, lying)\n- 6 clusters","817239f3":"Calculate the Adjusted Rand Index (`sklearn.metrics`) for the resulting clustering and for ` KMeans` with the parameters from the 4th question.","a2605ba0":"**Question 5:** <br>\nHow many clusters can we choose according to the elbow method? <br>\n\n**Answer options:**\n- 1\n- 2 **[+]**\n- 3\n- 4","9c846edc":"# <center>Assignment #7 (demo). Solution\n## <center> Unsupervised learning","bd0ac9b2":"It can be seen that kMeans does not distinguish activities very well. Use the elbow method to select the optimal number of clusters. Parameters of the algorithm and the data we use are the same as before, we change only `n_clusters`.","43a4a15f":"As you can see, the classification problem is solved quite well.","8fcf8730":"Visualize the data in the projection on the first two main components. Color the dots according to the clusters received.","f31b053b":"-------------------------------","1287f48e":"We calculate $ D(k) $, as described in [this article](https:\/\/www.kaggle.com\/kashnitsky\/topic-7-unsupervised-learning-pca-and-clustering) in the section \"Selecting the number of clusters for kMeans\".","6b8e30e2":"**Answer options:**\n- 56 \n- 65 **[+]**\n- 66\n- 193","54774f84":"<center>\n<img src=\"https:\/\/habrastorage.org\/webt\/ia\/m9\/zk\/iam9zkyzqebnf_okxipihkgjwnw.jpeg\">\n    \n## <center> [mlcourse.ai](https:\/\/mlcourse.ai) \u2013 Open Machine Learning Course\nAuthors: [Olga Daykhovskaya](https:\/\/www.linkedin.com\/in\/odaykhovskaya\/), [Yury Kashnitsky](https:\/\/yorko.github.io\/). All content is distributed under the [Creative Commons CC BY-NC-SA 4.0](https:\/\/creativecommons.org\/licenses\/by-nc-sa\/4.0\/) license. Free use is permitted for any non-commercial purpose."}}