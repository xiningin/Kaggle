{"cell_type":{"0547b540":"code","9e29c8c1":"code","622367cb":"code","f6776943":"code","83f38e7a":"code","e06fa6ed":"code","2e65ef77":"code","3b3cc28c":"code","b6ba83d7":"code","131d3776":"code","3593dc20":"code","bd00b376":"code","28a89849":"markdown","ce2e1601":"markdown","609cd6f0":"markdown"},"source":{"0547b540":"import os\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report, confusion_matrix\n\nimport tensorflow as tf\nfrom tensorflow.keras import datasets, layers, models\nfrom tensorflow.keras.layers import Activation\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames[:5]:\n        print(os.path.join(dirname, filename)) ","9e29c8c1":"# Read the data\ndf = pd.read_json(\"\/kaggle\/input\/ships-in-satellite-imagery\/shipsnet.json\")\ndf.shape","622367cb":"# Normalize and reshape the image data\n# df[\"normalized_data\"] = df[\"data\"].apply(lambda x: (np.array(x) \/ 255).reshape(80, 80, 3)) # 3 band\ndf[\"normalized_data\"] = df[\"data\"].apply(lambda x: (np.array(x)[:6400] \/ 255).reshape(80, 80, 1)) # 1 band","f6776943":"df.head()","83f38e7a":"def plot_red_band(index: int):\n    img_data = np.array(df.iloc[index]['normalized_data'])# .reshape([80, 80])\n    plt.imshow(img_data, cmap='Greys_r')\n\nplot_red_band(1)","e06fa6ed":"# Define X and Y\nX = df[\"normalized_data\"]\nY = df[\"labels\"]\n\n# Split the data into training and testing sets. Use a 75\/25 split\n(X_train, X_test, Y_train, Y_test) = train_test_split(X, Y, test_size=0.25, random_state=42)","2e65ef77":"# Transform the training and testing data into arrays\nX_train = np.array([x for x in X_train])\nX_test = np.array([x for x in X_test])\nY_train = np.array([y for y in Y_train])\nY_test = np.array([y for y in Y_test])","3b3cc28c":"# Starts the model with a sequential ANN\nmodel = models.Sequential()\n\n# Adds the first convulsion layer and follows up with max pooling\n# model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(80, 80, 3))) # 3 band\nmodel.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(80, 80, 1))) # 1 band\nmodel.add(layers.MaxPooling2D((2, 2)))\n\n# Add additional hidden layers\nmodel.add(layers.Conv2D(64, (3, 3), activation='relu'))\nmodel.add(layers.MaxPooling2D((2, 2)))\nmodel.add(layers.Conv2D(64, (3, 3), activation='relu'))\n\n# Flattens the input into a 1D tensor\nmodel.add(layers.Flatten())\n# Makes the input more readable for classification\nmodel.add(layers.Dense(64, activation='relu'))\n# Classifies - ensure the input in the number of classes, indexed\n# at 0\nmodel.add(layers.Dense(1))\n# Final activation function\nmodel.add(Activation('sigmoid'))\n\nmodel.summary()","b6ba83d7":"# Compile the model\n# Use binary_crossentropy because there are only 2 classes present\nmodel.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=['accuracy'])","131d3776":"# Train the model\ngen_model = model.fit(X_train, Y_train, epochs=10, validation_data=(X_test, Y_test))","3593dc20":"# Evaluate the model\n\npredictions = model.predict(X_test)\nprint(classification_report(Y_test, predictions.round()))\nprint(confusion_matrix(Y_test, predictions.round()))","bd00b376":"# Save the model for later use\nmodel.save(\"ShipCNN.h5\")","28a89849":"For comparison with 3 bands:\n```\n              precision    recall  f1-score   support\n\n           0       0.95      1.00      0.98       733\n           1       1.00      0.87      0.93       267\n\n    accuracy                           0.96      1000\n   macro avg       0.98      0.93      0.95      1000\nweighted avg       0.97      0.96      0.96      1000\n```","ce2e1601":"Quickly implement https:\/\/towardsdatascience.com\/classifying-ships-in-satellite-imagery-with-neural-networks-944024879651 but change to use single red band to investigate reduction in performance. All 3 bands are used in the article","609cd6f0":"The pixel value data for each 80x80 RGB image is stored as a list of 19200 integers within the data list. The first 6400 entries contain the red channel values, the next 6400 the green, and the final 6400 the blue."}}