{"cell_type":{"9c73e1ae":"code","56ca0540":"code","b19072ca":"code","0104dc1d":"code","bde3158c":"code","85a6bf3c":"code","e093327b":"code","a884a66a":"code","7bd90830":"code","02637d2c":"code","33727956":"code","ac012f15":"code","9c7f731c":"code","9e5adb8d":"code","a5c2f712":"code","8ddd10da":"code","3b119e73":"code","075eafe0":"code","5375af90":"code","1052c3b1":"code","b8edf23d":"code","8253b445":"code","c90d6e64":"code","8aa5be56":"code","0930c974":"code","0ac1cb45":"code","b5ba6425":"code","bed38cc6":"code","d2d56739":"code","d2e77a7e":"code","5cb59403":"code","f2ae588b":"code","f0fadc04":"markdown","811a9fe6":"markdown","6159b388":"markdown","4c323bf1":"markdown","e3012818":"markdown","3e9f97a6":"markdown","6f2e60f2":"markdown","6bdfb8a8":"markdown","56702496":"markdown","095b90ec":"markdown","9b707898":"markdown","4b0e0e43":"markdown","230180ec":"markdown","de62fae0":"markdown","3655f8a3":"markdown","39c9ba25":"markdown"},"source":{"9c73e1ae":"# import all libraries\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport seaborn as sns\nimport re\n\nimport sklearn\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.preprocessing import scale\nfrom sklearn.feature_selection import RFE\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.pipeline import make_pipeline\n\nimport warnings # supress warnings\nwarnings.filterwarnings('ignore')","56ca0540":"# import Housing.csv\nhousing = pd.read_csv('..\/input\/housedata\/Housing.csv')\nhousing.head()","b19072ca":"# number of observations \nlen(housing.index)","0104dc1d":"# filter only area and price\ndf = housing.loc[:, ['area', 'price']]\ndf.head()","bde3158c":"# recaling the variables (both)\ndf_columns = df.columns\nscaler = MinMaxScaler()\ndf = scaler.fit_transform(df)\n\n# rename columns (since now its an np array)\ndf = pd.DataFrame(df)\ndf.columns = df_columns\n\ndf.head()","85a6bf3c":"# visualise area-price relationship\nsns.regplot(x=\"area\", y=\"price\", data=df, fit_reg=False)","e093327b":"# split into train and test\ndf_train, df_test = train_test_split(df, \n                                     train_size = 0.7, \n                                     test_size = 0.3, \n                                     random_state = 10)\nprint(len(df_train))\nprint(len(df_test))","a884a66a":"# split into X and y for both train and test sets\n# reshaping is required since sklearn requires the data to be in shape\n# (n, 1), not as a series of shape (n, )\nX_train = df_train['area']\nX_train = X_train.values.reshape(-1, 1)\ny_train = df_train['price']\n\nX_test = df_test['area']\nX_test = X_test.values.reshape(-1, 1)\ny_test = df_test['price']","7bd90830":"len(X_train)","02637d2c":"# fit multiple polynomial features\ndegrees = [1, 2, 3, 6, 10, 20]\n\n# initialise y_train_pred and y_test_pred matrices to store the train and test predictions\n# each row is a data point, each column a prediction using a polynomial of some degree\ny_train_pred = np.zeros((len(X_train), len(degrees)))\ny_test_pred = np.zeros((len(X_test), len(degrees)))\n\nfor i, degree in enumerate(degrees):\n    \n    # make pipeline: create features, then feed them to linear_reg model\n    model = make_pipeline(PolynomialFeatures(degree), LinearRegression())\n    model.fit(X_train, y_train)\n    \n    # predict on test and train data\n    # store the predictions of each degree in the corresponding column\n    y_train_pred[:, i] = model.predict(X_train)\n    y_test_pred[:, i] = model.predict(X_test)\n    ","33727956":"# visualise train and test predictions\n# note that the y axis is on a log scale\n\nplt.figure(figsize=(16, 8))\n\n# train data\nplt.subplot(121)\nplt.scatter(X_train, y_train)\nplt.yscale('log')\nplt.title(\"Train data\")\nfor i, degree in enumerate(degrees):    \n    plt.scatter(X_train, y_train_pred[:, i], s=15, label=str(degree))\n    plt.legend(loc='upper left')\n    \n# test data\nplt.subplot(122)\nplt.scatter(X_test, y_test)\nplt.yscale('log')\nplt.title(\"Test data\")\nfor i, degree in enumerate(degrees):    \n    plt.scatter(X_test, y_test_pred[:, i], label=str(degree))\n    plt.legend(loc='upper left')","ac012f15":"# compare r2 for train and test sets (for all polynomial fits)\nprint(\"R-squared values: \\n\")\n\nfor i, degree in enumerate(degrees):\n    train_r2 = round(sklearn.metrics.r2_score(y_train, y_train_pred[:, i]), 2)\n    test_r2 = round(sklearn.metrics.r2_score(y_test, y_test_pred[:, i]), 2)\n    print(\"Polynomial degree {0}: train score={1}, test score={2}\".format(degree, \n                                                                         train_r2, \n                                                                         test_r2))","9c7f731c":"# data preparation\n\n# list of all the \"yes-no\" binary categorical variables\n# we'll map yes to 1 and no to 0\nbinary_vars_list =  ['mainroad', 'guestroom', 'basement', 'hotwaterheating', 'airconditioning', 'prefarea']\n\n# defining the map function\ndef binary_map(x):\n    return x.map({'yes': 1, \"no\": 0})\n\n# applying the function to the housing variables list\nhousing[binary_vars_list] = housing[binary_vars_list].apply(binary_map)\nhousing.head()","9e5adb8d":"# 'dummy' variables\n# get dummy variables for 'furnishingstatus' \n# also, drop the first column of the resulting df (since n-1 dummy vars suffice)\nstatus = pd.get_dummies(housing['furnishingstatus'], drop_first = True)\nstatus.head()","a5c2f712":"# concat the dummy variable df with the main df\nhousing = pd.concat([housing, status], axis = 1)\nhousing.head()","8ddd10da":"# 'furnishingstatus' since we alreday have the dummy vars\nhousing.drop(['furnishingstatus'], axis = 1, inplace = True)\nhousing.head()","3b119e73":"# train-test 70-30 split\ndf_train, df_test = train_test_split(housing, \n                                     train_size = 0.7, \n                                     test_size = 0.3, \n                                     random_state = 100)\n\n# rescale the features\nscaler = MinMaxScaler()\n\n# apply scaler() to all the numeric columns \nnumeric_vars = ['area', 'bedrooms', 'bathrooms', 'stories', 'parking','price']\ndf_train[numeric_vars] = scaler.fit_transform(df_train[numeric_vars])\ndf_train.head()","075eafe0":"# apply rescaling to the test set also\ndf_test[numeric_vars] = scaler.fit_transform(df_test[numeric_vars])\ndf_test.head()","5375af90":"# divide into X_train, y_train, X_test, y_test\ny_train = df_train.pop('price')\nX_train = df_train\n\ny_test = df_test.pop('price')\nX_test = df_test","1052c3b1":"# num of max features\nlen(X_train.columns)","b8edf23d":"# first model with an arbitrary choice of n_features\n# running RFE with number of features=10\n\nlm = LinearRegression()\nlm.fit(X_train, y_train)\n\nrfe = RFE(lm, n_features_to_select=10)             \nrfe = rfe.fit(X_train, y_train)","8253b445":"# tuples of (feature name, whether selected, ranking)\n# note that the 'rank' is > 1 for non-selected features\nlist(zip(X_train.columns,rfe.support_,rfe.ranking_))","c90d6e64":"# predict prices of X_test\ny_pred = rfe.predict(X_test)\n\n# evaluate the model on test set\nr2 = sklearn.metrics.r2_score(y_test, y_pred)\nprint(r2)","8aa5be56":"# try with another value of RFE\nlm = LinearRegression()\nlm.fit(X_train, y_train)\n\nrfe = RFE(lm, n_features_to_select=6)             \nrfe = rfe.fit(X_train, y_train)\n\n# predict prices of X_test\ny_pred = rfe.predict(X_test)\nr2 = sklearn.metrics.r2_score(y_test, y_pred)\nprint(r2)","0930c974":"# k-fold CV (using all the 13 variables)\nlm = LinearRegression()\nscores = cross_val_score(lm, X_train, y_train, scoring='r2', cv=5)\nscores      ","0ac1cb45":"# the other way of doing the same thing (more explicit)\n\n# create a KFold object with 5 splits \nfolds = KFold(n_splits = 5, shuffle = True, random_state = 100)\nscores = cross_val_score(lm, X_train, y_train, scoring='r2', cv=folds)\nscores   ","b5ba6425":"# can tune other metrics, such as MSE\nscores = cross_val_score(lm, X_train, y_train, scoring='neg_mean_squared_error', cv=5)\nscores","bed38cc6":"# number of features in X_train\nlen(X_train.columns)","d2d56739":"# step-1: create a cross-validation scheme\nfolds = KFold(n_splits = 5, shuffle = True, random_state = 100)\n\n# step-2: specify range of hyperparameters to tune\nhyper_params = [{'n_features_to_select': list(range(1, 14))}]\n\n\n# step-3: perform grid search\n# 3.1 specify model\nlm = LinearRegression()\nlm.fit(X_train, y_train)\nrfe = RFE(lm)             \n\n# 3.2 call GridSearchCV()\nmodel_cv = GridSearchCV(estimator = rfe, \n                        param_grid = hyper_params, \n                        scoring= 'r2', \n                        cv = folds, \n                        verbose = 1,\n                        return_train_score=True)      \n\n# fit the model\nmodel_cv.fit(X_train, y_train)                  \n","d2e77a7e":"# cv results\ncv_results = pd.DataFrame(model_cv.cv_results_)\ncv_results","5cb59403":"# plotting cv results\nplt.figure(figsize=(16,6))\n\nplt.plot(cv_results[\"param_n_features_to_select\"], cv_results[\"mean_test_score\"])\nplt.plot(cv_results[\"param_n_features_to_select\"], cv_results[\"mean_train_score\"])\nplt.xlabel('number of features')\nplt.ylabel('r-squared')\nplt.title(\"Optimal Number of Features\")\nplt.legend(['test score', 'train score'], loc='upper left')","f2ae588b":"# final model\nn_features_optimal = 10\n\nlm = LinearRegression()\nlm.fit(X_train, y_train)\n\nrfe = RFE(lm, n_features_to_select=n_features_optimal)             \nrfe = rfe.fit(X_train, y_train)\n\n# predict prices of X_test\ny_pred = lm.predict(X_test)\nr2 = sklearn.metrics.r2_score(y_test, y_pred)\nprint(r2)","f0fadc04":"#### Splitting Into Train and Test","811a9fe6":"###  Hyperparameter Tuning Using Grid Search Cross-Validation\n\nA common use of cross-validation is for tuning hyperparameters of a model. The most common technique is what is called **grid search** cross-validation.\n\n","6159b388":"##  Building a Model Without Cross-Validation\n\nLet's now build a multiple regression model. First, let's build a vanilla MLR model without any cross-validation etc. ","4c323bf1":"Let's now predict the y labels (for both train and test sets) and store the predictions in a table. Each row of the table is one data point, each column is a value of $n$ (degree).","e3012818":"<table style=\"width:100%\">\n  <tr>\n    <th>   <\/th>\n    <th>degree-1<\/th>\n    <th>degree-2<\/th> \n    <th>degree-3<\/th>\n    <th>...<\/th>\n    <th>degree-n<\/th>\n  <\/tr>\n  <tr>\n    <th>x1<\/th>\n  <\/tr>\n  <tr>\n    <th>x2<\/th>\n  <\/tr>\n   <tr>\n    <th>x3<\/th>\n    <\/tr>\n    <tr>\n    <th>...<\/th>\n    <\/tr>\n    <tr>\n    <th>xn<\/th>\n    <\/tr>\n<\/table>","3e9f97a6":"For the first experiment, we'll do regression with only one feature. Let's filter the data so it only contains `area` and `price`.","6f2e60f2":"## Problems in the Current Approach\n\nIn train-test split, we have three options:\n1. **Simply split into train and test**: But that way tuning a hyperparameter makes the model 'see' the test data (i.e. knowledge of test data leaks into the model)\n2. **Split into train, validation, test sets**: Then the validation data would eat into the training set\n3. **Cross-validation**: Split into train and test, and train multiple models by sampling the train set. Finally, just test once on the test set.\n","6bdfb8a8":"### K-Fold CV","56702496":"## Cross-Validation with Linear Regression\n\nThis notebook demonstrates how to do cross-validation (CV) with linear regression as an example (it is heavily used in almost all modelling techniques such as decision trees, SVM etc.). We will mainly use `sklearn` to do cross-validation.\n\n","095b90ec":"###  Types of Cross-Validation Schemes\n\n\n1. **K-Fold** cross-validation: Most common\n2. **Leave One Out (LOO)**: Takes each data point as the 'test sample' once, and trains the model on the rest n-1 data points. Thus, it trains n total models.\n    - Advantage: Utilises the data well since each model is trained on n-1 samples\n    - Disadvantage: Computationally expensive\n3. **Leave P-Out (LPO)**: Creat all possible splits after leaving p samples out. For n data points, there are (nCp) possibile train-test splits.\n4. (**For classification problems**) **Stratified K-Fold**: Ensures that the relative class proportion is approximately preserved in each train and validation fold. Important when ther eis huge class imbalance (e.g. 98% good customers, 2% bad).\n\n#### Additional Reading ####\nThe sklearn documentation enlists all CV schemes <a href=\"http:\/\/scikit-learn.org\/stable\/modules\/cross_validation.html\">here.<\/a>\n","9b707898":"## 0. Experiments to Understand Overfitting\n\nIn this section, let's quickly go through some experiments to understand what overfitting looks like. We'll run some experiments using polynomial regression.","4b0e0e43":"### Polynomial Regression\n\nYou already know simple linear regression:\n\n$y = \\beta_0 + \\beta_1 x_1$\n\nIn polynomial regression of degree $n$, we fit a curve of the form:\n\n$y = \\beta_0 + \\beta_1 x_1 + \\beta_2x_1^2 + \\beta_3x_1^3 ... + \\beta_nx_1^n$\n\nIn the experiment below, we have fitted polynomials of various degrees on the housing data and compared their performance on train and test sets.\n\nIn sklearn, polynomial features can be generated using the `PolynomialFeatures` class. Also, to perform `LinearRegression` and `PolynomialFeatures` in tandem, we will use the module `sklearn_pipeline` - it basically creates the features and feeds the output to the model (in that sequence).","230180ec":"#### Using RFE \n\nNow, we have 13 predictor features. To build the model using RFE, we need to tell RFE how many features we want in the final model. It then runs a feature elimination algorithm. \n\nNote that the number of features to be used in the model is a **hyperparameter**.","de62fae0":"Notice that the test score is very close to the 'mean test score' on the k-folds (about 60%). In general, the mean score estimated by CV will usually be a good estimate of the test score. ","3655f8a3":"Now we can choose the optimal value of number of features and build a final model.","39c9ba25":"Note that we haven't rescaled the test set yet, which we'll need to do later while making predictions."}}