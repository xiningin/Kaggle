{"cell_type":{"9c4d9fd4":"code","005c73a5":"code","902d0575":"code","47fafc58":"code","69b78f13":"code","66f6841a":"code","490368b1":"code","65814276":"code","cb475d59":"code","afe837ab":"code","db6c4742":"code","c2fc879f":"code","ce5354cc":"markdown","f0c71865":"markdown","ecfa132a":"markdown","791ceff5":"markdown","0f35cf1f":"markdown","65e269ed":"markdown","b140fc83":"markdown","e3fbd5c6":"markdown","38ec6038":"markdown","9b53b933":"markdown","91d9e08a":"markdown","039afe2d":"markdown","26c8f9a1":"markdown","90fb00e4":"markdown","b1da7ed0":"markdown","983fb99d":"markdown"},"source":{"9c4d9fd4":"import pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport collections\nfrom sklearn.manifold import TSNE #this was PCA earlier. But TSNE provides better viewing results.\nfrom sklearn.decomposition import PCA\nimport spacy\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nnlp = spacy.load(\"en_core_web_sm\")","005c73a5":"file1 = \"\/kaggle\/input\/netflix-shows\/netflix_titles.csv\" # name and path of the dataset.","902d0575":"odf = pd.read_csv(file1)","47fafc58":"odf.head(1)","69b78f13":"def comma_delimited_process(tdf,\n                           field_name,\n                           delimiter = \",\",\n                           space_replace = \"_\"):\n    '''\n        For some fields, multiple names are separated by a comma.\n        This will remove spaces between the same name and then replace the comma with a space\n        The intention is that after using CountVectorizer, the same names can be separated cleanly\n    '''\n    \n    df = tdf.copy()\n    \n    df[field_name] = df[field_name].str.replace(\" {}\".format(delimiter), delimiter)\n    df[field_name] = df[field_name].str.replace(\"{} \".format(delimiter), delimiter)\n    \n    df[field_name] = df[field_name].apply( lambda x: str(x).lower())\n    \n    df[field_name] = df[field_name].str.replace(\" \", space_replace)\n    \n    df[field_name] = df[field_name].str.replace(delimiter, \" \")\n    print(\"Returning dataframe of shape\", df.shape)\n    return df\n\n\ndef countvectorize_dataframe(tdf,\n                            field_name,\n                            prefix):\n    '''\n        This will use CountVectorizer and the return the results as a dataframe using same index of \n        original frame.\n    '''\n    \n    class LemmaTokenizer(object):\n        def __init__(self):\n            pass\n\n        def __call__(self, articles):\n            return [x.lemma_ for x in nlp(articles) if not x.is_stop and x.is_alpha]\n\n    df = tdf.copy()\n    \n    cv = CountVectorizer(tokenizer=LemmaTokenizer(), stop_words='english')\n\n    cvft = cv.fit_transform(df[field_name])\n    \n    desc_df = pd.DataFrame(cvft.toarray())\n    desc_df = desc_df.add_prefix(prefix)\n    print(desc_df.shape, \" is the shape of dataframe\")\n    return desc_df\n\n\ndef similarity_finder(index,\n                     cs):\n    '''\n        Get the index based on similarity\n    '''\n    current = cs[index]\n    sorted_results = np.argsort(current)[::-1]\n    return sorted_results\n\ndef find_title(df,\n              field_name,\n              title):\n    '''\n        Find the closest title based on a string search\n    '''\n    sear = df[field_name].str.lower()\n    vals = df[ sear.str.contains(title.lower()) ]\n    if len(vals) > 0:\n        vals = vals.index[0]\n    else:\n        vals = -1\n    return vals\n\n\ndef return_visualization(odf, temp_df):\n    from sklearn.manifold import TSNE\n    #tsne = PCA(n_components = 2, random_state = 0)\n    tsne = TSNE(n_components=2, random_state=0)\n\n    projections = tsne.fit_transform(temp_df)\n    projections = pd.DataFrame(projections)\n    projections.columns = [\"pca_\" + str(x) for x in range(len(projections.columns))]\n    df_plot = pd.concat([odf, pd.DataFrame(projections)], axis = 1)\n    fig = px.scatter(df_plot, x = 'pca_0', y='pca_1', \n                       color = 'type',\n                       hover_name='title',\n                       hover_data=['listed_in', 'rating', 'director','description'],\n                       title = 'Visualization based on similarity')\n    \n    return fig","66f6841a":"# comma columns are the ones where data is split via comma delimiter\ncomma_columns = ['director', 'cast', 'listed_in', 'country']\n# predictive columns are the ones we want to dummyfy and use in our similarity calculation\npredictive_columns = ['rating', 'type']\n\npdf =  odf[predictive_columns].copy()\n\nfor i in predictive_columns:\n    if pdf[i].dtype not in ('int64', 'float64'):\n        pdf = pd.concat( [ pdf.drop( i , axis = 1),\n                     pd.get_dummies( pdf[i] )],\n                  axis = 1\n                 )\n                  \n\nfor i in comma_columns:\n    director_df = comma_delimited_process(odf,\n                                         i,\n                                         i)\n\n    director_df = countvectorize_dataframe(director_df,\n                            i,\n                            i)\n    \n    if pdf is None:\n        pdf = director_df.copy()\n    else:\n        pdf = pd.concat([ pdf, director_df], axis = 1)\n        \n        \ndesc_df = countvectorize_dataframe(odf, \n                                  'description',\n                                  '_desc_')\n\npdf = pd.concat([pdf, desc_df], axis = 1)\n\n\nprint(\"Total pdf shape is \", pdf.shape)","490368b1":"cs = cosine_similarity(pdf)","65814276":"index = find_title(odf, 'title',\n          'Rocky III')\n\nodf.iloc[ similarity_finder(index,\n                 cs)[:5] ]","cb475d59":"index = find_title(odf, 'title',\n          'Walking Dead')\n\nodf.iloc[ similarity_finder(index,\n                 cs)[:5] ]","afe837ab":"index = find_title(odf, 'title',\n          'Jaws')\n\nodf.iloc[ similarity_finder(index,\n                 cs)[:5] ]","db6c4742":"# Commented out as this will take too much time\n#fig = return_visualization(odf, pdf)","c2fc879f":"#fig.show()","ce5354cc":"# Import Libraries","f0c71865":"---\n## TSNE Plot","ecfa132a":"# Netflix\n\nSkynet (reference Terminator the Movie) invented Netflix as a weapon of choice in order to reduce the life expectancy of all human beings by gluing them on the screens of their Television or Mobile devices.\n\nIn this short (hopefully) notebook, we will try to explore a Kaggle dataset https:\/\/www.kaggle.com\/shivamb\/netflix-shows in order to find insights using tools used in CCE6040.","791ceff5":"# Prediction Time\n\nLet us try to find similar titles like below.","0f35cf1f":"# Helper Functions","65e269ed":"# Constants to be used later","b140fc83":"**Description**\n\nThe idea of the notebook is as follows\n\n* There are some fields like director, cast, listed_in which have multiple entries separated by a comma\n* There is a description field which is all text\n* We want to create cosine similarity matrix based on the directors, casts, listed_in and the description.\n* So, for the **comma delimited** fields, we want each director to be represented as a separdate Vectorized item (from CountVectorizer)\n* For the description, we would **lemmatize** the text and then use those tokens for similarity.\n\nIn the end, we would try to use this approach to predict similar titles. **Beware** some very stupid suggestions will be seen :D","e3fbd5c6":"---\n## Rocky III","38ec6038":"---\n## The Walking Dead","9b53b933":"# Start Processing","91d9e08a":"# Introduction","039afe2d":"# Netflix Title Exploration\n","26c8f9a1":"# Read the dataset in dataframe","90fb00e4":"# That's all folks","b1da7ed0":"# Main Loop","983fb99d":"---\n## Jaws"}}