{"cell_type":{"4e8b8324":"code","75f01207":"code","ed925568":"code","6fa6721f":"code","54f1a27c":"code","5c5898ed":"code","03667de5":"code","c1ce60dd":"markdown"},"source":{"4e8b8324":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","75f01207":"import pandas as pd\nimport numpy as np\n\nimport torch\nimport random\n\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\n\nrandom.seed(1777)\ntorch.manual_seed(1777)\nif device == 'cuda' :\n    torch.cuda.manual_seed_all(777)\n\n# \ud559\uc2b5 \ud30c\ub77c\ubbf8\ud130 \uc124\uc815\nlearning_rate = 0.01\ntraining_epochs = 2020\nbatch_size = 15\n\n# Data load\ntrain_data = pd.read_csv('..\/input\/crime-types\/train_data.csv', header=None, skiprows=1, usecols=range(0, 13))\ntest_data = pd.read_csv('..\/input\/crime-types\/test_data.csv', header=None, skiprows=1, usecols=range(0, 12))\n\n# Data \ud30c\uc2f1\nx_train_data = train_data.loc[:, 1:13]\ny_train_data = train_data.loc[:, 0]\n\n# \ud30c\uc2f1\ud55c Data\ub97c numpy\uc758 array\ub85c \ubcc0\ud658\nx_train_data = np.array(x_train_data)\ny_train_data = np.array(y_train_data)\n\ntest_data = np.array(test_data)\n\n# \ubcc0\ud658\ud55c numpy\uc758 array\ub97c Tensor\ub85c \ubcc0\ud658\nx_train_data = torch.FloatTensor(x_train_data)\ny_train_data = torch.LongTensor(y_train_data)\n\ntest_data = torch.FloatTensor(test_data)\n\n# data_loader\uc5d0 \uc774\uc6a9\ud560 \ud558\ub098\uc758 train Dataset\uc73c\ub85c \ubcc0\ud658\ntrain_dataset = torch.utils.data.TensorDataset(x_train_data, y_train_data)\n\n# data_loader \uc124\uc815\ndata_loader = torch.utils.data.DataLoader(dataset=train_dataset,\n                                          batch_size=batch_size,\n                                          shuffle=True,\n                                          drop_last=True)\n\n# \ubaa8\ub378 \uc124\uacc4\nlinear1 = torch.nn.Linear(12, 256, bias=True)\nlinear2 = torch.nn.Linear(256, 256, bias=True)\nlinear3 = torch.nn.Linear(256, 256, bias=True)\nlinear4 = torch.nn.Linear(256, 512, bias=True)\nlinear5 = torch.nn.Linear(512, 1024, bias=True)\nlinear6 = torch.nn.Linear(1024, 1024, bias=True)\nlinear7 = torch.nn.Linear(1024, 512, bias=True)\nlinear8 = torch.nn.Linear(512, 512, bias=True)\nlinear9 = torch.nn.Linear(512, 256, bias=True)\nlinear10 = torch.nn.Linear(256, 256, bias=True)\nlinear11 = torch.nn.Linear(256, 128, bias=True)\nlinear12 = torch.nn.Linear(128, 128, bias=True)\nlinear13 = torch.nn.Linear(128, 10, bias=True)\nelu = torch.nn.ELU()\n\ntorch.nn.init.xavier_normal_(linear1.weight)\ntorch.nn.init.xavier_normal_(linear2.weight)\ntorch.nn.init.xavier_uniform_(linear3.weight)\ntorch.nn.init.xavier_normal_(linear4.weight)\ntorch.nn.init.xavier_uniform_(linear5.weight)\ntorch.nn.init.xavier_normal_(linear6.weight)\ntorch.nn.init.xavier_normal_(linear7.weight)\ntorch.nn.init.xavier_normal_(linear8.weight)\ntorch.nn.init.xavier_uniform_(linear9.weight)\ntorch.nn.init.xavier_normal_(linear10.weight)\ntorch.nn.init.xavier_uniform_(linear11.weight)\ntorch.nn.init.xavier_normal_(linear12.weight)\ntorch.nn.init.xavier_normal_(linear13.weight)\n\nmodel = torch.nn.Sequential(linear1, elu,\n                            linear2, elu,\n                            linear3, elu,\n                            linear4, elu,\n                            linear5, elu,\n                            linear6, elu,\n                            linear7, elu,\n                            linear8, elu,\n                            linear9, elu,\n                            linear10, elu,\n                            linear11, elu,\n                            linear12, elu,\n                            linear13).to(device)\n\nloss = torch.nn.CrossEntropyLoss().to(device)\noptimizer = torch.optim.Adagrad(model.parameters(), lr=learning_rate, lr_decay=1e-20, eps=1e-20)\n\n# \ubaa8\ub378 \ud559\uc2b5\ntotal_batch = len(data_loader)\n\nfor epoch in range(training_epochs) :\n    avg_cost = 0\n\n    for X, Y in data_loader :\n\n        X = X.to(device)\n        Y = Y.to(device)\n\n        optimizer.zero_grad()\n        hypothesis = model(X)\n        cost = loss(hypothesis, Y)\n        cost.backward()\n        optimizer.step()\n\n        avg_cost += cost \/ total_batch\n\n    print('Epoch : {:4d}'.format(epoch+1), 'Cost : {:.9f}'.format(avg_cost))\n\nprint('Learning Finishied')\n\n# \ubaa8\ub378 \ud3c9\uac00\nwith torch.no_grad() :\n    test_data = test_data.to(device)\n\n    prediction = model(test_data)\n    prediction = torch.argmax(prediction, 1)\n    prediction = prediction.cpu().numpy().reshape(-1, 1)\n\n","ed925568":"\nsubmit = pd.read_csv('..\/input\/crime-types\/submission_format.csv')\n\nfor i in range(len(prediction)) :\n    submit['Lable'][i] = prediction[i].item()\n\nsubmit.to_csv('result.csv', index=False, header=True)","6fa6721f":"    train_=train_data.loc[:, 1:13]\n    train_=torch.FloatTensor(train_.values)\n    train_=train_.to(device)\n    predtr = model( train_)\n    predtr = torch.argmax(predtr, 1)\n    predtr =predtr.detach().numpy().reshape(-1, 1)\n    predtr\n","54f1a27c":"prediction.shape","5c5898ed":"def verslag(titel,label2,yval,ypred,ypred2,mytrain):\n        from sklearn.metrics import classification_report    \n        yval=pd.Series(yval)\n        #ypred=pd.Series(ypred)\n        #ypred2=pd.Series(ypred2)\n        print('shape yval\/dropna ypred\/dropna',yval.dropna().shape,yval.shape,ypred.shape,np.array(ypred2).shape)\n        ypred=ypred\n        ypred2=ypred2\n        print(titel+'\\n', classification_report(yval,ypred )  )\n        vsubmit = pd.DataFrame({        label2[0]: mytrain[len(yval):].reset_index().index,        label2[1]: np.array(ypred2)    })\n        #print(label2,label2[0],label2[1 ],vsubmit.shape,vsubmit.head(3))\n        vsubmit[label2[1]]=vsubmit[label2[1]].astype('int')#-1\n        print('submission header',vsubmit.head())\n        vsubmit[label2].to_csv(titel+'submission.csv',index=False)\n        print(titel,vsubmit[label2].groupby(label2[1]).count() )\n        return  \n    \nverslag('test',['Index','Lable'],train_data[0],predtr,[x for x in prediction],submit)","03667de5":"len(submit),prediction.shape","c1ce60dd":"bizar enough, i dont't get to the 0.63 ??\nany trick here ?"}}