{"cell_type":{"33f1e372":"code","eb38bf3e":"code","51500f8a":"code","bac604dd":"code","733f6599":"code","b913cdce":"code","41d73164":"code","33a6f6e5":"code","897249cc":"code","8e03cca4":"markdown","3a36c677":"markdown","14c26c1a":"markdown","91d1e66a":"markdown","e1c7e586":"markdown","cc5b7fef":"markdown","2db9354a":"markdown"},"source":{"33f1e372":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt","eb38bf3e":"class Arm(object):\n    \"\"\"\n    Each arm's true click through rate is \n    modeled by a beta distribution.\n    \"\"\"\n    def __init__(self, idx, a=1, b=1):\n        \"\"\"\n        Init with uniform prior.\n        \"\"\"\n        self.idx = idx\n        self.a = a\n        self.b = b\n        \n    def record_success(self):\n        self.a += 1\n        \n    def record_failure(self):\n        self.b += 1\n        \n    def draw_ctr(self):\n        return np.random.beta(self.a, self.b, 1)[0]\n    \n    def mean(self):\n        return self.a \/ (self.a + self.b)","51500f8a":"def monte_carlo_simulation(arms, draw=100):\n    \"\"\"\n    Monte Carlo simulation of thetas. Each arm's click through\n    rate follows a beta distribution.\n    \n    Parameters\n    ----------\n    arms list[Arm]: list of Arm objects.\n    draw int: number of draws in Monte Carlo simulation.\n    \n    Returns\n    -------\n    mc np.matrix: Monte Carlo matrix of dimension (draw, n_arms).\n    p_winner list[float]: probability of each arm being the winner.\n    \"\"\"\n    # Monte Carlo sampling\n    alphas = [arm.a for arm in arms]\n    betas = [arm.b for arm in arms]\n    mc = np.matrix(np.random.beta(alphas, betas, size=[draw, len(arms)]))\n    \n    # count frequency of each arm being winner \n    counts = [0 for _ in arms]\n    winner_idxs = np.asarray(mc.argmax(axis=1)).reshape(draw,)\n    for idx in winner_idxs:\n        counts[idx] += 1\n    \n    # divide by draw to approximate probability distribution\n    p_winner = [count \/ draw for count in counts]\n    return mc, p_winner","bac604dd":"def thompson_sampling(arms):\n    \"\"\"\n    Stochastic sampling: take one draw for each arm\n    divert traffic to best draw.\n    \n    @param arms list[Arm]: list of Arm objects\n    @return idx int: index of winning arm from sample\n    \"\"\"\n    sample_p = [arm.draw_ctr() for arm in arms]\n    idx = np.argmax(sample_p)\n    return idx","733f6599":"def should_terminate(p_winner, est_ctrs, mc, alpha=0.05):\n    \"\"\"\n    Decide whether experiument should terminate. When value remaining in\n    experiment is less than 1% of the winning arm's click through rate.\n    \n    Parameters\n    ----------\n    p_winner list[float]: probability of each arm being the winner.\n    est_ctrs list[float]: estimated click through rates.\n    mc np.matrix: Monte Carlo matrix of dimension (draw, n_arms).\n    alpha: controlling for type I error\n    \n    @returns bool: True if experiment should terminate.\n    \"\"\"\n    winner_idx = np.argmax(p_winner)\n    values_remaining = (mc.max(axis=1) - mc[:, winner_idx]) \/ mc[:, winner_idx]\n    pctile = np.percentile(values_remaining, q=100 * (1 - alpha))\n    return pctile < 0.01 * est_ctrs[winner_idx]","b913cdce":"def k_arm_bandit(ctrs, alpha=0.05, burn_in=1000, max_iter=100000, draw=100, silent=False):\n    \"\"\"\n    Perform stochastic k-arm bandit test. Experiment is terminated when\n    value remained in experiment drops below certain threshold.\n    \n    Parameters\n    ----------\n    ctrs list[float]: true click through rates for each arms.\n    alpha float: terminate experiment when the (1 - alpha)th percentile\n        of the remaining value is less than 1% of the winner's click through rate.\n    burn_in int: minimum number of iterations.\n    max_iter int: maxinum number of iterations.\n    draw int: number of rows in Monte Carlo simulation.\n    silent bool: print status at the end of experiment.\n    \n    Returns\n    -------\n    idx int: winner's index.\n    est_ctrs list[float]: estimated click through rates.\n    history_p list[list[float]]: storing est_ctrs and p_winner.\n    traffic list[int]: number of traffic in each arm.\n    \"\"\"\n    n_arms = len(ctrs)\n    arms = [Arm(idx=i) for i in range(n_arms)]\n    history_p = [[] for _ in range(n_arms)]\n    \n    for i in range(max_iter):\n        idx = thompson_sampling(arms)\n        arm, ctr = arms[idx], ctrs[idx]\n\n        # update arm's beta parameters\n        if np.random.rand() < ctr:\n            arm.record_success()\n        else:\n            arm.record_failure()\n\n        # record current estimates of each arm being winner\n        mc, p_winner = monte_carlo_simulation(arms, draw)\n        for j, p in enumerate(p_winner):\n            history_p[j].append(p)\n            \n        # record current estimates of each arm's ctr\n        est_ctrs = [arm.mean() for arm in arms]\n        \n        # terminate when value remaining is negligible\n        if i >= burn_in and should_terminate(p_winner, est_ctrs, mc, alpha):\n            if not silent: print(\"Terminated at iteration %i\"%(i + 1))\n            break\n\n    traffic = [arm.a + arm.b - 2 for arm in arms]\n    return idx, est_ctrs, history_p, traffic","41d73164":"def plot_history(ctrs, est_ctrs, df_history, title, rolling=10, fname=None, transparent=False):\n    \"\"\"\n    Plot evolution of conversion rates estimates or winner probability for each arm.\n    \n    Parameters\n    ----------\n    ctr, est_ctrs list[float]: true ctrs and estiamted ctrs.\n    df_history list[list[float]]: a nested list of each arm's history.\n    rolling int: rolling window length.\n    fname str: enter file name if need to store, including '.png'.\n    transparent bool: make background transparent.\n    \"\"\"\n    true_winner_idx = np.argmax(ctrs)\n    winner_idx = np.argmax(est_ctrs)\n    \n    cols = [\"arm_%i_ctr=%.2f\"%(i + 1, ctr) for i, ctr in enumerate(ctrs)]\n    data = {col : hist for col, hist in zip(cols, df_history)}\n    df_history_ma = pd.DataFrame(data).rolling(rolling).mean()\n    \n    plt.figure(figsize=(12, 4))\n    for i, col in enumerate(cols):\n        if i == true_winner_idx :\n            plt.plot(df_history_ma[col], lw=2, color='b')\n        elif i == winner_idx:\n            plt.plot(df_history_ma[col], lw=2, color='r')\n        else:\n            plt.plot(df_history_ma[col], alpha=0.5)\n\n    legend = [\"true ctr = %.3f, est ctr = %.3f\"%(true, est) for true, est in zip(ctrs, est_ctrs)]\n    plt.legend(legend, frameon=False, loc='upper center', ncol=3)\n    plt.title(title)\n    plt.ylim(0, 1)\n    \n    plt.show()","33a6f6e5":"seed = 11\nnp.random.seed(seed)\n\nctrs = [0.04, 0.048, 0.03, 0.037, 0.044]\ntrue_winner_idx = np.argmax(ctrs)\nprint(\"true_winner_idx:\", true_winner_idx, ctrs)\n\n(winner_idx, est_ctrs, history_p, traffic) = k_arm_bandit(ctrs, alpha=0.05, burn_in=1400)","897249cc":"plot_history(ctrs, est_ctrs, history_p, \n             title=\"K-armed Bandit Algorithm (terminated in %i iterations)\"%sum(traffic), rolling=100)","8e03cca4":"### Simulation","3a36c677":"#### Termination Criterion","14c26c1a":"#### Thompson Sampling","91d1e66a":"#### Function: K-armed Bandit Experiment","e1c7e586":"#### Function: Plot Result ","cc5b7fef":"#### Function: Monte Carlo Simulation","2db9354a":"#### Class Definition\n* Each variant is an Arm class\n* Click-through rate (or equivalent) is modelled through Beta distribution"}}