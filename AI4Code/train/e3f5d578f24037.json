{"cell_type":{"916ec85b":"code","9c48677a":"code","bb6d4995":"code","7515ebb0":"code","18fa7235":"code","9040664a":"code","fe2f006c":"code","52da3940":"code","d8389fc1":"code","fbe68341":"code","1500aeab":"code","927318c2":"code","95f5b699":"code","f6063b35":"code","5a2dec97":"code","1f98ba65":"code","16cacac9":"markdown","5ca03f02":"markdown","04f3e06a":"markdown","5bf341c3":"markdown","d8edf6bd":"markdown","e853a195":"markdown","9af1e54d":"markdown","d5ca3c42":"markdown","ca091784":"markdown","d0b76704":"markdown","6c5264e2":"markdown","9be48823":"markdown","e44a3e2c":"markdown"},"source":{"916ec85b":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9c48677a":"!pip install git+https:\/\/github.com\/qiskit-community\/qiskit-textbook.git#subdirectory=qiskit-textbook-src","bb6d4995":"import qiskit\nqiskit.__qiskit_version__","7515ebb0":"from qiskit import QuantumCircuit, execute, Aer\nfrom qiskit.visualization import plot_histogram","18fa7235":"from qiskit_textbook.widgets import binary_widget\nbinary_widget(nbits=5)","9040664a":"n = 8\nn_q = n\nn_b = n\nqc_output = QuantumCircuit(n_q,n_b)","fe2f006c":"!pip install pylatexenc","52da3940":"qc_encode = QuantumCircuit(n)\nqc_encode.x(1)\nqc_encode.x(3)\nqc_encode.x(4)","d8389fc1":"for j in range(n):\n    qc_output.measure(j,j)\n    \nqc_output.draw()","fbe68341":"qc = qc_encode + qc_output\nqc.draw(output='mpl',justify='none')","1500aeab":"counts = execute(qc,Aer.get_backend('qasm_simulator')).result().get_counts()\nplot_histogram(counts)","927318c2":"qc_cnot = QuantumCircuit(2)\nqc_cnot.cx(0,1)\nqc_cnot.draw()","95f5b699":"#you\u2019ll find that the output is 11\nqc = QuantumCircuit(2,2)\nqc.x(0)\nqc.cx(0,1)\nqc.measure(0,0)\nqc.measure(1,1)\nqc.draw()","f6063b35":"qc_ha = QuantumCircuit(4,2)\n# encode inputs in qubits 0 and 1\nqc_ha.x(0) # For a=0, remove this line. For a=1, leave it.\nqc_ha.x(1) # For b=0, remove this line. For b=1, leave it.\nqc_ha.barrier()\n# use cnots to write the XOR of the inputs on qubit 2\nqc_ha.cx(0,2)\nqc_ha.cx(1,2)\nqc_ha.barrier()\n# extract outputs\nqc_ha.measure(2,0) # extract XOR value\nqc_ha.measure(3,1)\n\nqc_ha.draw()","5a2dec97":"qc_ha = QuantumCircuit(4,2)\n# encode inputs in qubits 0 and 1\nqc_ha.x(0) # For a=0, remove the this line. For a=1, leave it.\nqc_ha.x(1) # For b=0, remove the this line. For b=1, leave it.\nqc_ha.barrier()\n# use cnots to write the XOR of the inputs on qubit 2\nqc_ha.cx(0,2)\nqc_ha.cx(1,2)\n# use ccx to write the AND of the inputs on qubit 3\nqc_ha.ccx(0,1,3)\nqc_ha.barrier()\n# extract outputs\nqc_ha.measure(2,0) # extract XOR value\nqc_ha.measure(3,1) # extract AND value\n\nqc_ha.draw()","1f98ba65":"counts = execute(qc_ha,Aer.get_backend('qasm_simulator')).result().get_counts()\nplot_histogram(counts)","16cacac9":"To check the version installed in your computer, run the following in Python shell or Jupyter Notebook:","5ca03f02":"These strings of bits, known as binary strings, can be used to represent more than just numbers. For example, there is a way to represent any text using bits.","04f3e06a":"The half adder contains everything you need for addition. With the NOT, CNOT, and Toffoli gates, we can create programs that add any set of numbers of any size.","5bf341c3":"If you look again at the four possible sums, you\u2019ll notice that there is only one case for which this is 1 instead of 0: 1+1=10. It happens only when both the bits we are adding are 1. For this, we need a new gate: like a CNOT but controlled on two qubits instead of just one. This will perform a NOT on the target qubit only when both controls are in state 1. This new gate is called the Toffoli. For those of you who are familiar with Boolean logic gates, it is basically an AND gate.","d8edf6bd":"Here is a table showing all the possible inputs and corresponding outputs of the CNOT gate:\n![image.png](attachment:image.png)","e853a195":"In this example, we are calculating 1+1, because the two input bits are both 1. Let's see what we get.","9af1e54d":"The result is 10, which is the binary representation of the number 2. We have built a computer that can solve the famous mathematical problem of 1+1!","d5ca3c42":"# **Half adder using Qiskit**","ca091784":"In Qiskit, the Toffoli is represented with the ccx command.","d0b76704":"# Your first quantum circuit","6c5264e2":"**Controlled NOT gate - CNOT**","9be48823":"This circuit, which we have called qc_output, is created by Qiskit using **QuantumCircuit**. The number n_q defines the number of qubits in the circuit. With n_b we define the number of output bits we will extract from the circuit at the end.","e44a3e2c":"# Write your age in a Quantum Circuit"}}