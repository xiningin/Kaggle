{"cell_type":{"8ff505f9":"code","3dfbf499":"code","ee7aa6b0":"code","ea040b5b":"code","7c181e02":"code","7eb1d65c":"code","57c2afec":"code","6c197360":"code","2b071c5d":"markdown","25f7d386":"markdown","d00dc395":"markdown","2f0bae86":"markdown","e4aaedc7":"markdown","46887f3e":"markdown","fc1f7eb9":"markdown","c9a1583a":"markdown","41228f60":"markdown"},"source":{"8ff505f9":"# Base \n# -----------------------------------\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\n\n# Missing Value\n# -----------------------------------\n# !pip install missingno\nimport missingno as msno\n\n# Configuration\n# -----------------------------------\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nwarnings.simplefilter(action='ignore', category=FutureWarning)\n\npd.set_option('display.max_columns', None)\npd.options.display.float_format = '{:.2f}'.format\n\nfrom termcolor import colored","3dfbf499":"# Import\naq_auser = pd.read_csv(\"..\/input\/acea-water-prediction\/Aquifer_Auser.csv\")\naq_doganella = pd.read_csv(\"..\/input\/acea-water-prediction\/Aquifer_Doganella.csv\")\naq_luco = pd.read_csv(\"..\/input\/acea-water-prediction\/Aquifer_Luco.csv\")\naq_petrignago = pd.read_csv(\"..\/input\/acea-water-prediction\/Aquifer_Petrignano.csv\")\nlakeBilancino = pd.read_csv(\"..\/input\/acea-water-prediction\/Lake_Bilancino.csv\")\nriverArno = pd.read_csv(\"..\/input\/acea-water-prediction\/River_Arno.csv\")\nws_Amiata = pd.read_csv(\"..\/input\/acea-water-prediction\/Water_Spring_Amiata.csv\")\nws_Lupa = pd.read_csv(\"..\/input\/acea-water-prediction\/Water_Spring_Lupa.csv\")\nws_Madonna = pd.read_csv(\"..\/input\/acea-water-prediction\/Water_Spring_Madonna_di_Canneto.csv\")\n","ee7aa6b0":"datasets = {\"Aquifer Auser\":aq_auser, \"Aquifer Doganella\":aq_doganella, \"Aquifer Luco\":aq_luco, \"Aquifer Petrignano\":aq_petrignago,\n            \"Lake Bilancino\":lakeBilancino, \"River Arno\":riverArno, \"Water Spring Amiata\":ws_Amiata, \"Water Spring Lupa\":ws_Lupa, \n            \"Water Spring Madonna di Canneto\":ws_Madonna}\n\nfor i in datasets.keys():\n    print(colored(i.upper()+\": \\n\", \"cyan\", attrs=[\"bold\",'reverse', 'blink']), \n          # Dimensions\n          \"Observations:\" + str(datasets[i].shape[0]), \"| Variables:\"+str(datasets[i].shape[1]), \"\\n\\n\",\n         \n          # Missing Value\n          \"Does the data include any missing value? \\n\", aq_auser.isnull().values.any(), \"\\n\"\n         )\n    \n    for j in [\"object\", \"bool\", \"integer\", \"float\"]:\n          if datasets[i].select_dtypes(j).shape[1]>0:\n                print(\" Num of \"+j.capitalize()+\" Variables:\",datasets[i].select_dtypes(j).shape[1])\n    print(\"\\n\\n\")","ea040b5b":"for i in datasets.keys():\n    msno.heatmap(datasets[i])\n    plt.show()","7c181e02":"def missing_values(data, plot = False, target = \"SalePrice\"):\n    \n    mst = pd.DataFrame({\"Num_Missing\":data.isnull().sum(), \"Missing_Ratio\":data.isnull().sum() \/ data.shape[0]}).sort_values(\"Num_Missing\", ascending = False)\n    #mst[\"DataTypes\"] = data[mst.index].dtypes.values\n    mst = mst[mst.Num_Missing > 0].reset_index().rename({\"index\":\"Feature\"}, axis = 1)\n    mst = mst[mst.Feature != target]\n    \n    print(\"Number of Variables include Missing Values:\", mst.shape[0], \"\\n\")\n    \n    if mst[mst.Missing_Ratio >= 1.0].shape[0] > 0:  \n        print(\"Full Missing Variables:\",mst[mst.Missing_Ratio >= 1.0].Feature.tolist())\n        data.drop(mst[mst.Missing_Ratio >= 1.0].Feature.tolist(), axis = 1, inplace = True)\n\n        print(\"Full missing variables are deleted!\", \"\\n\")\n\n    if plot:\n        plt.figure(figsize = (25, 8))    \n        p = sns.barplot(mst.Feature, mst.Missing_Ratio)\n        for rotate in p.get_xticklabels():\n            rotate.set_rotation(90)\n            \n            \n    print(mst, \"\\n\")        \n    \n\nfor i in datasets.keys():\n    print(colored(i.upper()+\":\", \"cyan\", attrs=[\"bold\",'reverse', 'blink']))\n    missing_values(datasets[i], plot = True, target = \"\")\n    print(\"\\n\\n\")","7eb1d65c":"def num_plot(data, cat_length = 10, remove = [\"Id\"], hist_bins = 10, figsize = (20,4)):\n    \n    num_cols = [col for col in data.columns if data[col].dtypes != \"O\" \n                and len(data[col].unique()) >= cat_length]\n    \n    if len(remove) > 0:\n        num_cols = [x for x in num_cols if (x not in remove)]\n           \n    for i in num_cols:\n        fig, axes = plt.subplots(1, 3, figsize = figsize)\n        data.hist(str(i), bins = hist_bins, ax=axes[0])\n        data.boxplot(str(i),  ax=axes[1], vert=False);\n        try: \n            sns.kdeplot(np.array(data[str(i)]))\n        except: ValueError\n        \n        axes[1].set_yticklabels([])\n        axes[1].set_yticks([])\n        axes[0].set_title(i + \" | Histogram\")\n        axes[1].set_title(i + \" | Boxplot\")\n        axes[2].set_title(i + \" | Density\")\n        plt.show()\n        \n\nfor i in datasets.keys():\n    print(i.upper())\n    num_plot(datasets[i], cat_length = 10, remove = [\"Id\"], hist_bins = 10, figsize = (20,4))\n    print(\"\\n\\n\")\n\n","57c2afec":"for i in datasets.keys():\n    print(colored(i.upper()+\":\", \"cyan\", attrs=[\"bold\",'reverse', 'blink']))\n    sns.set(font_scale=1.1)\n    c = datasets[i].corr()\n    mask = np.triu(c.corr())\n    plt.figure(figsize=(20, 20))\n    sns.heatmap(c,\n            annot=True,\n            fmt='.1f',\n            cmap='coolwarm',\n            square=True,\n            mask=mask,\n            linewidths=1,\n            cbar=False)\n\n    plt.show()\n    print(\"\\n\\n\")","6c197360":"for i in datasets.keys():\n    datasets[i][\"Date\"] = pd.to_datetime(datasets[i][\"Date\"])\n    \n\nfor i in datasets.keys():\n    temp = datasets[i].copy()\n    print(colored(i.upper()+\" TIME RANGE\"+\": \\n\", \"cyan\", attrs=[\"bold\",'reverse', 'blink']))\n    \n    print(\"Min Date:\", str(temp.Date.min())[:11])\n    print(\"Max Date:\", str(temp.Date.max())[:11],\"\\n\\n\" )\n          \n    for j in temp.columns.tolist()[1:]:\n        fig = plt.figure()\n        ax = temp.set_index(\"Date\")[j].plot(figsize = (25,10), legend = True)\n        \n        #\u00a0Axis Config\n        plt.ticklabel_format(style='sci', axis='y', scilimits=(0,10))\n        ax.get_yaxis().set_major_formatter(plt.FuncFormatter(lambda x, loc: \"{:,}\".format(int(x))))\n        # Title\n        fig.suptitle(i.upper() + \"\\n\" + j ,fontsize=23)\n        \n        plt.xlabel(\"Date\", fontsize = 25)\n        plt.xticks(fontsize= 15)\n        plt.ylabel(j, fontsize = 25)\n        plt.yticks(fontsize= 15)\n    ","2b071c5d":"# 4. Missing Value\n","25f7d386":"# 5. Numeric Variables ","d00dc395":"# 7. Time Series","2f0bae86":"![](https:\/\/storage.googleapis.com\/kaggle-competitions\/kaggle\/24191\/logos\/header.png?t=2020-11-24-14-43-27)\n\n# Welcome\nThe [Acea Group](https:\/\/www.gruppo.acea.it\/en) is one of the leading Italian multiutility operators. Listed on the Italian Stock Exchange since 1999, the company manages and develops water and electricity networks and environmental services. Acea is the foremost Italian operator in the water services sector supplying 9 million inhabitants in Lazio, Tuscany, Umbria, Molise, Campania.\n\nIn this competition we will focus only on the water sector to help Acea Group preserve precious waterbodies. As it is easy to imagine, a water supply company struggles with the need to forecast the water level in a waterbody (water spring, lake, river, or aquifer) to handle daily consumption. During fall and winter waterbodies are refilled, but during spring and summer they start to drain. To help preserve the health of these waterbodies it is important to predict the most efficient water availability, in terms of level and water flow for each day of the year.\n\n# Data\nThe reality is that each waterbody has such unique characteristics that their attributes are not linked to each other. This analytics competition uses datasets that are completely independent from each other. However, it is critical to understand total availability in order to preserve water across the country.\n\nEach dataset represents a different kind of waterbody. As each waterbody is different from the other, the related features are also different. So, if for instance we consider a water spring we notice that its features are different from those of a lake. These variances are expected based upon the unique behavior and characteristics of each waterbody. The Acea Group deals with four different type of waterbodies: water springs, lakes, rivers and aquifers.\n\n# Challenge\nCan you build a story to predict the amount of water in each unique waterbody? The challenge is to determine how features influence the water availability of each presented waterbody. To be more straightforward, gaining a better understanding of volumes, they will be able to ensure water availability for each time interval of the year.\n\nThe time interval is defined as day\/month depending on the available measures for each waterbody. Models should capture volumes for each waterbody(for instance, for a model working on a monthly interval a forecast over the month is expected).\n\nThe desired outcome is a notebook that can generate four mathematical models, one for each category of waterbody (acquifers, water springs, river, lake) that might be applicable to each single waterbody.\n\n![](https:\/\/www.googleapis.com\/download\/storage\/v1\/b\/kaggle-user-content\/o\/inbox%2F6195295%2Fcca952eecc1e49c54317daf97ca2cca7%2FAcea-Input.png?generation=1606932492951317&alt=media)\n\n# Evaluation \nThis is an Analytics competition where your task is to create a Notebook that best addresses the Evaluation criteria below. Submissions should be shared directly with host and will be judged by the Acea Group based on how well they address:\n\n**Methodology\/Completeness (min 0 points, max 5 points)**\n\n- Are the statistical models appropriate given the data?\n- Did the author develop one or more machine learning models?\n- Did the author provide a way of assessing the performance and accuracy of their solution?\n- What is the Mean Absolute Error (MAE) of the models?\n- What is the Root Mean Square Error (RMSE) of the models?\n\n**Presentation (min 0 points, max 5 points)**\n\n- Does the notebook have a compelling and coherent narrative?\n- Does the notebook contain data visualizations that help to communicate the author\u2019s main points?\n- Did the author include a thorough discussion on the intersection between features and their prediction? For example between rainfall and amount\/level of water.\n- Was there discussion of automated insight generation, demonstrating what factors to take into account?\n- Is the code documented in a way that makes it easy to understand and reproduce?\n- Were all external sources of data made public and cited appropriately?\n\n**Application (min 0 points, max 5 points)**\n\n- Is the provided model useful\/able to forecast water availability in terms of level or water flow in a time interval of the year?\n- Is the provided methodology applicable also on new datasets belong to another waterbody?\n\n\n## Deadline\n- Entry and Final submission deadline: **February 17, 2021**\n- Winners announced: **March 10, 2021**\n\n# Data Description\n\n![image.png](attachment:image.png)","e4aaedc7":"![image.png](attachment:image.png)","46887f3e":"# 1. Packages","fc1f7eb9":"# 2. Data","c9a1583a":"#\u00a03. Data Info","41228f60":"# 6. Correlation"}}