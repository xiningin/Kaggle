{"cell_type":{"5f18a80f":"code","875fe2ef":"code","21186427":"code","ec62b68e":"code","32f77a85":"code","1996212a":"code","ba71b03f":"code","ebf07528":"code","d0aad86e":"code","538889fc":"markdown"},"source":{"5f18a80f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","875fe2ef":"#install requirment\n\n!pip install pickle-mixin\n!pip install markovify","21186427":"import pandas as pd\nfrom tqdm import tqdm\ndf = pd.read_csv(\"..\/input\/arabic-poetry\/Arabic_poetry_dataset.csv\", encoding=\"utf-8\")\nallowed_chars = ['\u0636', '\u0635', '\u062b', '\u0642', '\u0641', '\u063a', '\u0639', '\u0647', '\u062e', '\u062d', '\u062c', '\u062f', '\u0634', '\u0633', '\u064a', '\u0628', '\u0644', '\u0627', '\u062a', '\u0646', '\u0645',\n                 '\u0643', '\u0637', '\u0626', '\u0621', '\u0624', '\u0631' , '\u0649', '\u0629', '\u0648', '\u0632', '\u0638', '\u0625' ,'\u0623', '\u0622', ' ', '\\n', '\u0630', '\u0651']\n\ndef delete_puncs(poem):\n    for l in poem:\n        if l not in allowed_chars:\n            poem = poem.replace(l, \"\")\n    return poem\n\ndef extract_poems(poet_name):\n    with open('.\\input\\{}.txt'.format(poet_name), 'w', encoding=\"utf-8\") as f:\n        for i in range(len(df)):\n            if df['poet_name'][i].format(poet_name) == poet_name:\n                poem = delete_puncs(df['poem_text'][i])\n                f.write(\"{}\\n\\n\".format(poem))\n                \n                ","ec62b68e":"all_poets = set()\nfor poet_name in df['poet_name']:\n    all_poets.add(poet_name)","32f77a85":"import pickle\n\nwith open('..\/input\/arabic-vocab1\/vocabs.pkl', 'rb') as pickle_load:\n    voc_list = pickle.load(pickle_load)\n    \n\nallowed_chars = ['\u0630', '\u0636', '\u0635', '\u062b', '\u0642', '\u0641', '\u063a', '\u0639', '\u0647', '\u062e', '\u062d', '\u062c', '\u062f',\n                 '\u0634', '\u0633', '\u064a', '\u0628', '\u0644', '\u0627', '\u0623', '\u062a', '\u0646', '\u0645', '\u0643', '\u0637', '\u0626', '\u0621', '\u0624', '\u0631', '\u0649', \n                 '\u0629', '\u0648', '\u0632', '\u0638', '\u0651', ' ']\n\nmax_word_length = 9","1996212a":"#extract all words on the same rythmes\n\ndef rhymes_with(word):\n    if word not in ['\u0627\u0644\u0644\u0647', '\u0648\u0627\u0644\u0644\u0647', '\u0628\u0627\u0644\u0644\u0647', '\u0644\u0644\u0647', '\u062a\u0627\u0644\u0644\u0647']:\n        word = word.replace('\u0651', '')\n    ending = word[-2:]\n    rhymes = []\n    for w in voc_list:\n        if len(w) < max_word_length and w.endswith(ending):\n            rhymes.append(w)\n    return rhymes\n\ndef rhymes_with_last_n_chars(word, n):\n    if word not in ['\u0627\u0644\u0644\u0647', '\u0648\u0627\u0644\u0644\u0647', '\u0628\u0627\u0644\u0644\u0647', '\u0644\u0644\u0647', '\u062a\u0627\u0644\u0644\u0647', '\u0641\u0627\u0644\u0644\u0647']:\n        word = word.replace('\u0651', '')\n    ending = word[-n:]\n    rhymes = []\n    for w in voc_list:\n        if len(w) < max_word_length and w.endswith(ending):\n            rhymes.append(w)\n    return rhymes","ba71b03f":"import markovify\nfrom tqdm import tqdm\n\ndef markov(text_file):\n    with open(text_file, 'r', encoding='utf-8') as f:\n        text = f.read()\n    text_model = markovify.NewlineText(text)\n    return text_model","ebf07528":"def generate_poem_single_rhyme(poet_name, rhyme, iterations=3000, use_tqdm=False):\n    n_of_rhyme_letters = len(rhyme)\n    input_ff =  df.loc[df['poet_name'] == poet_name]\n    input_file = '..\/input\/poem-txt\/.txt'\n    text_model = markov(input_file)\n    rhymes_list = rhymes_with_last_n_chars(rhyme, n_of_rhyme_letters)\n    bayts = set()\n    used_rhymes = set()\n    \n    poem = \"\"\n    \n    if use_tqdm == True:\n        if hasattr(tqdm, '_instances'): tqdm._instances.clear()\n        it_range = tqdm(range(iterations))\n    else:\n        it_range = range(iterations)\n        \n    for i in it_range:\n        bayt = text_model.make_short_sentence(280, tries=100)\n        last_word = bayt.split()[-1]\n        if (last_word in rhymes_list) and (last_word not in used_rhymes) and (bayt not in bayts):\n            bayts.add(bayt)\n            used_rhymes.add(last_word)\n            poem += \"{}\\n\".format(bayt)\n            if not use_tqdm:\n                print(bayt)\n    return poem\n\ndef generate_poem_2_rhymes(poet_name, rhyme_1, rhyme_2, iterations=3000, use_tqdm=False):\n    n_of_rhyme_1_letters = len(rhyme_1)\n    n_of_rhyme_2_letters = len(rhyme_2)\n    \n    input_ff =  df.loc[df['poet_name'] == poet_name]\n    input_file = '..\/input\/poem-txt\/.txt'\n    text_model = markov(input_file)\n    \n    rhymes_1_list = rhymes_with_last_n_chars(rhyme_1, n_of_rhyme_1_letters)\n    rhymes_2_list = rhymes_with_last_n_chars(rhyme_2, n_of_rhyme_2_letters)\n    \n    bayts_1 = set()\n    bayts_2 = set()\n    \n    used_rhymes_1 = set()\n    used_rhymes_2 = set()\n    \n    poem = \"\"\n    \n    if use_tqdm == True:\n        if hasattr(tqdm, '_instances'): tqdm._instances.clear()\n        it_range = tqdm(range(iterations))\n    else:\n        it_range = range(iterations)\n        \n    for i in it_range:\n        bayt = text_model.make_short_sentence(280, tries=100)\n        last_word = bayt.split()[-1]\n        \n        if (last_word in rhymes_1_list) and (last_word not in used_rhymes_1) and (bayt not in bayts_1):\n            bayts_1.add(bayt)\n            used_rhymes_1.add(last_word)\n\n        if (last_word in rhymes_2_list) and (last_word not in used_rhymes_2) and (bayt not in bayts_2):\n            bayts_2.add(bayt)\n            used_rhymes_2.add(last_word)                \n    \n    len_of_poem = min(len(bayts_1), len(bayts_2))\n    for i in range(len_of_poem):\n        poem += \"{}\\n{}\\n\".format(list(bayts_1)[i], list(bayts_2)[i])\n        \n    return poem","d0aad86e":"x = generate_poem_single_rhyme(\n                            '\u062e\u0644\u0641\u0627\u0646 \u0628\u0646 \u0645\u0635\u0628\u062d',\n                            '\u0627\u0644\u0627',\n                            iterations=3000,\n                            use_tqdm=False\n                            )","538889fc":"                                    **Arabic Boem Genrator**\n                               \n                             Generating Arabic poems using Markov chains."}}