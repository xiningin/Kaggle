{"cell_type":{"45fcdc8b":"code","ffe7093d":"code","2f4c8d4e":"code","aa78de9c":"code","d806d2c3":"code","a2188800":"code","d18aa2b5":"code","ac1e4ed1":"code","49730e54":"markdown","bf04f786":"markdown","fd43c0ab":"markdown","3c47922f":"markdown","e0eba7e7":"markdown","23f39054":"markdown","e60fa446":"markdown","3a1b4a48":"markdown","e42f0e9e":"markdown","ba6e080a":"markdown"},"source":{"45fcdc8b":"import numpy as np\nimport pandas as pd\nimport json\nimport torch\nfrom torch import nn\nfrom torch.utils.data import Dataset, DataLoader\nfrom sklearn.preprocessing import LabelEncoder, OneHotEncoder","ffe7093d":"N_EPOCH = 200\nBATCH_SIZE = 64\nLEARN_RATE = 0.001\nFEATURE_SIZE = 21","2f4c8d4e":"def one_hot(categories, string):\n    encoding = np.zeros((len(string), len(categories)))\n    for idx, char in enumerate(string):\n        encoding[idx, categories.index(char)] = 1\n    return encoding\n\ndef featurize(entity):\n    sequence = one_hot(list('ACGU'), entity['sequence'])\n    structure = one_hot(list('.()'), entity['structure'])\n    loop_type = one_hot(list('BEHIMSX'), entity['predicted_loop_type'])\n    features = np.hstack([sequence, structure, loop_type])\n    return features \n\ndef char_encode(index, features, feature_size):\n    half_size = (feature_size - 1) \/\/ 2\n    \n    if index - half_size < 0:\n        char_features = features[:index+half_size+1]\n        padding = np.zeros((int(half_size - index), char_features.shape[1]))\n        char_features = np.vstack([padding, char_features])\n    elif index + half_size + 1 > len(features):\n        char_features = features[index-half_size:]\n        padding = np.zeros((int(half_size - (len(features) - index))+1, char_features.shape[1]))\n        char_features = np.vstack([char_features, padding])\n    else:\n        char_features = features[index-half_size:index+half_size+1]\n    \n    return char_features","aa78de9c":"class VaxDataset(Dataset):\n    def __init__(self, path, test=False):\n        self.path = path\n        self.test = test\n        self.features = []\n        self.targets = []\n        self.ids = []\n        self.load_data()\n    \n    def load_data(self):\n        with open(self.path, 'r') as text:\n            for line in text:\n                records = json.loads(line)\n                features = featurize(records)\n                \n                for char_i in range(records['seq_scored']):\n                    char_features = char_encode(char_i, features, FEATURE_SIZE)\n                    self.features.append(char_features)\n                    self.ids.append('%s_%d' % (records['id'], char_i))\n                        \n                if not self.test:\n                    targets = np.stack([records['reactivity'], records['deg_Mg_pH10'], records['deg_Mg_50C']], axis=1)\n                    self.targets.extend([targets[char_i] for char_i in range(records['seq_scored'])])\n                    \n    def __len__(self):\n        return len(self.features)\n    \n    def __getitem__(self, index):\n        if self.test:\n            return self.features[index], self.ids[index]\n        else:\n            return self.features[index], self.targets[index], self.ids[index]","d806d2c3":"train_dataset = VaxDataset('..\/input\/stanford-covid-vaccine\/train.json')\ntrain_dataloader = DataLoader(train_dataset, BATCH_SIZE, shuffle=True, num_workers=4, pin_memory=True)","a2188800":"import torch.nn as nn\ndef conv3x3(in_planes, out_planes, stride=1, groups=1, dilation=1):\n    \"\"\"3x3 convolution with padding\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride,\n                     padding=dilation, groups=groups, bias=False, dilation=dilation)\n\n\ndef conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)\n\n\nclass BasicBlock(nn.Module):\n    expansion = 1\n\n    def __init__(self, inplanes, planes, stride=1, downsample=None, groups=1,\n                 base_width=64, dilation=1, norm_layer=None):\n        super(BasicBlock, self).__init__()\n        if norm_layer is None:\n            norm_layer = nn.BatchNorm2d\n        if groups != 1 or base_width != 64:\n            raise ValueError('BasicBlock only supports groups=1 and base_width=64')\n        if dilation > 1:\n            raise NotImplementedError(\"Dilation > 1 not supported in BasicBlock\")\n        # Both self.conv1 and self.downsample layers downsample the input when stride != 1\n        self.conv1 = conv3x3(inplanes, planes, stride)\n        self.bn1 = norm_layer(planes)\n        self.relu = nn.ReLU(inplace=True)\n        self.conv2 = conv3x3(planes, planes)\n        self.bn2 = norm_layer(planes)\n        self.downsample = downsample\n        self.stride = stride\n\n    def forward(self, x):\n        identity = x\n\n        out = self.conv1(x)\n        out = self.bn1(out)\n        out = self.relu(out)\n\n        out = self.conv2(out)\n        out = self.bn2(out)\n\n        if self.downsample is not None:\n            identity = self.downsample(x)\n\n        out += identity\n        out = self.relu(out)\n\n        return out\n\n\nclass Bottleneck(nn.Module):\n    # Bottleneck in torchvision places the stride for downsampling at 3x3 convolution(self.conv2)\n    # while original implementation places the stride at the first 1x1 convolution(self.conv1)\n    # according to \"Deep residual learning for image recognition\"https:\/\/arxiv.org\/abs\/1512.03385.\n    # This variant is also known as ResNet V1.5 and improves accuracy according to\n    # https:\/\/ngc.nvidia.com\/catalog\/model-scripts\/nvidia:resnet_50_v1_5_for_pytorch.\n\n    expansion = 4\n\n    def __init__(self, inplanes, planes, stride=1, downsample=None, groups=1,\n                 base_width=64, dilation=1, norm_layer=None):\n        super(Bottleneck, self).__init__()\n        if norm_layer is None:\n            norm_layer = nn.BatchNorm2d\n        width = int(planes * (base_width \/ 64.)) * groups\n        # Both self.conv2 and self.downsample layers downsample the input when stride != 1\n        self.conv1 = conv1x1(inplanes, width)\n        self.bn1 = norm_layer(width)\n        self.conv2 = conv3x3(width, width, stride, groups, dilation)\n        self.bn2 = norm_layer(width)\n        self.conv3 = conv1x1(width, planes * self.expansion)\n        self.bn3 = norm_layer(planes * self.expansion)\n        self.relu = nn.ReLU(inplace=True)\n        self.downsample = downsample\n        self.stride = stride\n\n    def forward(self, x):\n        identity = x\n\n        out = self.conv1(x)\n        out = self.bn1(out)\n        out = self.relu(out)\n\n        out = self.conv2(out)\n        out = self.bn2(out)\n        out = self.relu(out)\n\n        out = self.conv3(out)\n        out = self.bn3(out)\n\n        if self.downsample is not None:\n            identity = self.downsample(x)\n\n        out += identity\n        out = self.relu(out)\n\n        return out\n\n\nclass ResNet(nn.Module):\n\n    def __init__(self, block, layers, num_classes=1000, zero_init_residual=False,\n                 groups=1, width_per_group=64, replace_stride_with_dilation=None,\n                 norm_layer=None):\n        super(ResNet, self).__init__()\n        if norm_layer is None:\n            norm_layer = nn.BatchNorm2d\n        self._norm_layer = norm_layer\n\n        self.inplanes = 64\n        self.dilation = 1\n        if replace_stride_with_dilation is None:\n            # each element in the tuple indicates if we should replace\n            # the 2x2 stride with a dilated convolution instead\n            replace_stride_with_dilation = [False, False, False]\n        if len(replace_stride_with_dilation) != 3:\n            raise ValueError(\"replace_stride_with_dilation should be None \"\n                             \"or a 3-element tuple, got {}\".format(replace_stride_with_dilation))\n        self.groups = groups\n        self.base_width = width_per_group\n        self.conv1 = nn.Conv2d(1, self.inplanes, kernel_size=7, stride=2, padding=3,\n                               bias=False)\n        self.bn1 = norm_layer(self.inplanes)\n        self.relu = nn.ReLU(inplace=True)\n        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        self.layer1 = self._make_layer(block, 64, layers[0])\n        self.layer2 = self._make_layer(block, 128, layers[1], stride=2,\n                                       dilate=replace_stride_with_dilation[0])\n        self.layer3 = self._make_layer(block, 256, layers[2], stride=2,\n                                       dilate=replace_stride_with_dilation[1])\n        self.layer4 = self._make_layer(block, 512, layers[3], stride=2,\n                                       dilate=replace_stride_with_dilation[2])\n        self.avgpool = nn.AdaptiveAvgPool2d((1, 1))\n        self.fc = nn.Linear(512 * block.expansion, num_classes)\n\n        for m in self.modules():\n            if isinstance(m, nn.Conv2d):\n                nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n            elif isinstance(m, (nn.BatchNorm2d, nn.GroupNorm)):\n                nn.init.constant_(m.weight, 1)\n                nn.init.constant_(m.bias, 0)\n\n        # Zero-initialize the last BN in each residual branch,\n        # so that the residual branch starts with zeros, and each residual block behaves like an identity.\n        # This improves the model by 0.2~0.3% according to https:\/\/arxiv.org\/abs\/1706.02677\n        if zero_init_residual:\n            for m in self.modules():\n                if isinstance(m, Bottleneck):\n                    nn.init.constant_(m.bn3.weight, 0)\n                elif isinstance(m, BasicBlock):\n                    nn.init.constant_(m.bn2.weight, 0)\n\n    def _make_layer(self, block, planes, blocks, stride=1, dilate=False):\n        norm_layer = self._norm_layer\n        downsample = None\n        previous_dilation = self.dilation\n        if dilate:\n            self.dilation *= stride\n            stride = 1\n        if stride != 1 or self.inplanes != planes * block.expansion:\n            downsample = nn.Sequential(\n                conv1x1(self.inplanes, planes * block.expansion, stride),\n                norm_layer(planes * block.expansion),\n            )\n\n        layers = []\n        layers.append(block(self.inplanes, planes, stride, downsample, self.groups,\n                            self.base_width, previous_dilation, norm_layer))\n        self.inplanes = planes * block.expansion\n        for _ in range(1, blocks):\n            layers.append(block(self.inplanes, planes, groups=self.groups,\n                                base_width=self.base_width, dilation=self.dilation,\n                                norm_layer=norm_layer))\n\n        return nn.Sequential(*layers)\n\n    def _forward_impl(self, x):\n        # See note [TorchScript super()]\n        x = self.conv1(x)\n        x = self.bn1(x)\n        x = self.relu(x)\n        x = self.maxpool(x)\n\n        x = self.layer1(x)\n        x = self.layer2(x)\n        x = self.layer3(x)\n        x = self.layer4(x)\n\n        x = self.avgpool(x)\n        x = torch.flatten(x, 1)\n        x = self.fc(x)\n\n        return x\n\n    def forward(self, x):\n        return self._forward_impl(x)\n\n\ndef _resnet(arch, block, layers, pretrained, progress, **kwargs):\n    model = ResNet(block, layers, **kwargs)\n    if pretrained:\n        state_dict = load_state_dict_from_url(model_urls[arch],\n                                              progress=progress)\n        model.load_state_dict(state_dict)\n    return model\n\n\ndef resnet18(pretrained=False, progress=True, **kwargs):\n    r\"\"\"ResNet-18 model from\n    `\"Deep Residual Learning for Image Recognition\" <https:\/\/arxiv.org\/pdf\/1512.03385.pdf>`_\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n        progress (bool): If True, displays a progress bar of the download to stderr\n    \"\"\"\n    return _resnet('resnet18', BasicBlock, [1, 1, 1, 1], pretrained, progress,\n                   **kwargs)\n\n\nclass VaxModel(nn.Module):\n\n    def __init__(self):\n        super(VaxModel, self).__init__()\n        self.resnet = resnet18()\n        self.drop = nn.Dropout(0.2)\n        self.linear1 =   nn.Linear(1000, 32)\n        self.drop1 = nn.Dropout(0.4)\n        self.rl1 =    nn.PReLU()\n        self.btn1=   nn.BatchNorm1d(32)\n        self.drop2=  nn.Dropout(0.4)\n        self.ln =     nn.Linear(32, 3)\n        \n\n    def forward(self, x):\n        x = self.drop(x)\n        x = x.reshape(x.shape[0],1, x.shape[1], x.shape[2])\n        x = self.resnet(x)\n        x = self.drop1(x)\n        x = self.linear1(x)\n        x = self.rl1(x)\n        x = self.btn1(x)\n        x = self.drop2(x)\n        x = self.ln(x)\n        return x","d18aa2b5":"model = VaxModel().cuda()\noptimizer = torch.optim.Adam(model.parameters(), LEARN_RATE)\nscheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, 'min',patience=5,factor=0.6)\ncriterion = nn.MSELoss()","ac1e4ed1":"best_avg = 1\nstop_ep = 0\nfor epoch in range(N_EPOCH):\n    losses = []\n    model.train()\n    for features, targets, ids in train_dataloader:\n        features = features.cuda().permute(0,2,1).float()\n        targets = targets.cuda().float()\n        predictions = model(features)\n        loss = criterion(predictions, targets)\n        for p in model.parameters():\n            p.grad = None\n        loss.backward()\n        optimizer.step()\n        losses.append(loss.detach().cpu().numpy())\n    avg_loss = float(np.mean(losses))\n    scheduler.step(metrics= avg_loss)\n    if avg_loss < best_avg:\n        stop_ep = 0\n        best_avg = avg_loss\n        print(f\"{epoch}: {avg_loss} saved model!!!!\")\n        torch.save(model.state_dict(), 'weights.pth')\n    else:\n        stop_ep += 1\n        print(f\"{epoch}: {avg_loss}\")\n    if stop_ep >= 10:\n        break","49730e54":"### Training","bf04f786":"### Dataset","fd43c0ab":"### Imports","3c47922f":"## Welcome to my first baseline notebook!\nThis is an interesting competition, especially with the short time constraint. We are provided a sequence of mRNA and for the first 68 bases we must predict three properties `reactivity`, `deg_Mg_pH10`, and `deg_Mg_50C`. In this notebook, I present my code for a simple baseline that as of publishing scores #1 on the leaderboard (0.380). I haven't messed with the hyperparameters at all so you are sure to get a better score than me!\n\nNote that this is the training part of a 2-part Notebook. The inference portion is located here: https:\/\/www.kaggle.compytorch-nn-starter-baseline-inference-0-380","e0eba7e7":"### Encoding functions","23f39054":"### DataLoaders","e60fa446":"### Model","3a1b4a48":"### Configuration","e42f0e9e":"Thank you for taking the time to view my notebook! I really hope you learned something and are able to use this as a platform for future work.\n\nThis is part one of a two-part notebook. To view the inference portion please go here: https:\/\/www.kaggle.compytorch-nn-starter-baseline-inference-0-380","ba6e080a":"- with\/out gru : 23: 0.5180768966674805 saved model!!!!\n- with gru: 22: 0.5302977561950684 saved model!!!!\n- w\/o gru high dropout: 23: 0.5289515852928162 saved model!!!!\n- with lstm 0.3 dropout: 24: 0.5024447441101074 saved model!!!!\n- with lstm 0.2 dropout: 23: 0.49915841221809387 saved model!!!!\n- with lstm remove 1 dropout :  24: 0.4912698566913605 saved model!!!!\n- with lstm 50 epochs: 0.4882\n- with resnet18 100epochs: 98: 0.2310710847377777 saved model!!!!\n"}}