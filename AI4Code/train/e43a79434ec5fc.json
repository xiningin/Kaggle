{"cell_type":{"7b5e254d":"code","1c71b8f8":"code","c518c425":"code","2d45c7cb":"code","e4bfa75e":"code","c39f4d0d":"code","8ab4d1f3":"code","9d81fdea":"code","8f98ee20":"code","bd119ae1":"code","f4686bd1":"code","8d7ab799":"code","b87af1b3":"code","5ed91798":"code","d98dd7cd":"code","daaa428c":"code","ca5ee3da":"code","7944c5c5":"code","ff5bb53e":"code","cc0c1526":"code","dc05bfb4":"code","da059d08":"code","f62fe8f0":"markdown","7cb343b7":"markdown","e1cb0a73":"markdown","9a14cdfb":"markdown"},"source":{"7b5e254d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport random\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nfrom pandas import datetime\nimport math, time\nimport itertools\nfrom sklearn import preprocessing\nfrom sklearn.preprocessing import MinMaxScaler\nimport datetime\nfrom operator import itemgetter\nfrom sklearn.metrics import mean_squared_error\nfrom math import sqrt\nimport torch\nimport torch.nn as nn\nfrom torch.autograd import Variable\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os \nfor dirname, _, filenames in os.walk('\/kaggle\/input'):# \u041f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u0440\u043e\u0439\u0442\u0438 \u043f\u043e \u0444\u0430\u0439\u043b\u0430\u043c \n    for i, filename in enumerate(filenames):\n        if i<5:\n            print(os.path.join(dirname,filename)) # \u041c\u0435\u0442\u043e\u0434 join \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0432\u0430\u043c \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u0438\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u0443\u0442\u0435\u0439 \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u043d\u043e\u0433\u043e \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435\u043b\u044f\n# Any results you write to the current directory are saved as output.","1c71b8f8":"# symbols = ['aapl','goog','ibm']","c518c425":"# \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0434\u0435\u043b\u0430\u0435\u0442 \u0434\u0430\u0442\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u043e \u0430\u043a\u0446\u0438\u044f\u043c\ndef stocks_data(symbols, dates):\n    df = pd.DataFrame(index=dates)\n    for symbol in symbols:\n        df_temp = pd.read_csv(\"..\/input\/Data\/Stocks\/{}.us.txt\".format(symbol), index_col='Date',\n                parse_dates=True, usecols=['Date', 'Close'], na_values=['nan'])\n        df_temp = df_temp.rename(columns={'Close': symbol})\n        df = df.join(df_temp)# \u0421 \u043f\u043e\u043c\u043e\u0449\u044c\u044e  join \u043c\u043e\u0436\u043d\u043e \u0434\u0435\u043b\u0430\u0442\u044c \u0440\u0430\u0431\u043e\u0447\u0438\u0439 \u043f\u0443\u0442\u044c \u0434\u043e \u0444\u0430\u0439\u043b\u0430\n    return df\n\n# \u0445\u0440\u0435\u043d\u044c \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043d\u0435 \u043d\u0435\u0443\u0436\u043d\u0430\n# \u0434\u0435\u043b\u0430\u0435\u0442 \u043a\u0440\u0430\u0441\u0438\u0432\u044b\u0435 \u0434\u0430\u0442\u044b \u0438 \u0442\u0434 \u043f\u043e\u0434 \u0433\u0438\u0441\u0442\u043e\u0433\u0440\u0430\u043c\u043c\u043e\u0439\ndates = pd.date_range('2015-01-02','2016-12-31',freq='B')\nsymbols = ['goog','ibm','aapl']\ndf = stocks_data(symbols, dates)\ndf.fillna(method='pad')\nprint(df)\n# \u0441\u0442\u043e\u0440\u043e\u0438\u043c \u0433\u0438\u0441\u0442\u043e\u0433\u0440\u0430\u043c\u043c\u0443\ndf.interpolate().plot()\nplt.show()","2d45c7cb":"df.head()","e4bfa75e":"# \u0441\u0442\u0440\u043e\u0438\u043c \u0438 \u0434\u0435\u043b\u0430\u0435\u043c \u043a\u0440\u0430\u0441\u043e\u0442\u0443\ndates = pd.date_range('2010-01-02','2017-10-11',freq='B')\ndf1=pd.DataFrame(index=dates)\ndf_ibm=pd.read_csv(\"..\/input\/Data\/Stocks\/ibm.us.txt\", parse_dates=True, index_col=0)\ndf_ibm=df1.join(df_ibm)\ndf_ibm[['Close']].plot()\nplt.ylabel(\"stock_price\")\nplt.title(\"IBM Stock\")\nplt.show()","c39f4d0d":"df_ibm=df_ibm[['Close']]\ndf_ibm.info()","8ab4d1f3":"dates = pd.date_range('2010-01-02','2017-10-11',freq='B')\ndf1=pd.DataFrame(index=dates)\ndf_aapl=pd.read_csv(\"..\/input\/Data\/Stocks\/aapl.us.txt\", parse_dates=True, index_col=0)\ndf_aapl=df1.join(df_aapl)\ndf_aapl[['Close']].plot()\nplt.ylabel(\"stock_price\")\nplt.title(\"Apple Stock\")\nplt.show()","9d81fdea":"df_aapl=df_aapl[['Close']]\ndf_aapl.info()","8f98ee20":"df_ibm = df_ibm.fillna(method = 'ffill')\ndf_aapl = df_aapl.fillna(method = 'ffill')\n\n# \u043f\u0435\u0440\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u0442 \u0432 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043e\u0442 -1 \u0434\u043e 1 (\u0442\u0438\u043f\u043e \u0443\u043c\u0435\u043d\u044c\u0448\u0430\u0435\u0442 \u043f\u043e \u0440\u0430\u0437\u043c\u0435\u0440\u0443)\nscaler = MinMaxScaler(feature_range=(-1, 1))\ndf_ibm['Close'] = scaler.fit_transform(df_ibm['Close'].values.reshape(-1,1))\n\nscaler = MinMaxScaler(feature_range=(-1, 1))\ndf_aapl['Close'] = scaler.fit_transform(df_aapl['Close'].values.reshape(-1,1))","bd119ae1":"df_aapl=df1.join(df_aapl)\ndf_aapl[['Close']].plot()\nplt.ylabel(\"stock_price\")\nplt.title(\"Apple Stock\")\nplt.show()","f4686bd1":"plt.plot(df_aapl['Close'])\nplt.plot(df_ibm['Close'])\nplt.show()","8d7ab799":"def load_data_2(stock_1 , stock_2, look_back):\n    data_raw_1= stock_1.as_matrix()\n    data_raw_2 = stock_2.as_matrix()\n    data_useful = []\n    \n    # \u0437\u0430\u0431\u0438\u0432\u0430\u0435\u043c \u0434\u0430\u0442\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c\u0438 \u0438\u043a\u0441-\u043e\u0432\n    for index in range(len(data_raw_1) - look_back - 21): \n        # \u0446\u0438\u043a\u043b \u0438\u0434\u0435\u0442 \u0434\u043e \u0447\u0438\u0441\u043b\u0430 \u0440\u0430\u0432\u043d\u043e\u0433\u043e \u0434\u043b\u0438\u043d\u043d\u0435 data_raw \u043c\u0438\u043d\u0443\u0441 look_back\n        # look_back \u044d\u0442\u043e \u043d\u0430 \u043a\u0430\u043a\u043e\u0439 \u0434\u0435\u043d\u044c \u043c\u044b \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u043d\u0430\u0437\u0430\u0434\n        data_1 = []\n        data_1.append(data_raw_1[index])\n        data_1.append(data_raw_1[index + 7])\n        data_1.append(data_raw_1[index + 14])\n        data_1.extend(data_raw_1[index+20: index+21+look_back])\n        \n        \n        data_2 = []  \n        # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0432 \u043d\u043e\u0432\u044b\u0439 \u0441\u043f\u0438\u0441\u043e\u043a \u043d\u0443\u0436\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\n        # \u044d\u0442\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u043e \u043e\u0442 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0445 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u0439\n        data_2.append(data_raw_2[index])\n        data_2.append(data_raw_2[index + 7])\n        data_2.append(data_raw_2[index + 14])\n        data_2.extend(data_raw_2[index+20: index+21+look_back])\n        # \u0434\u0435\u043b\u0430\u0435\u043c \u0438\u0437 \u0441\u043f\u0438\u0441\u043a\u0430  \u043c\u0430\u0441\u0441\u0438\u0432 numpy\n        data_2 = np.array(data_2)\n        # \u0434\u0435\u043b\u0430\u0435\u043c \u0435\u0433\u043e \u043d\u0430 \u0432\u0441\u044f\u043a\u0438\u0439 \u0441\u043b\u0443\u0447\u0430\u0439 -1 \u043d\u0430 1\n        data_2.reshape(-1,1)\n        data_1 = np.array(data_1)\n        data_1.reshape(-1,1)\n        data_3 = np.hstack((data_1 , data_2))\n        # \"\u043f\u0440\u0438\u043a\u043b\u0435\u0438\u0432\u0430\u0435\u043c\" \u0434\u0430\u0442\u0430 2 \u043a \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0434\u0430\u0442\u0435\n        data_useful.append(data_3)\n        if index == -1:\n            print(type(data_raw_1[index:index + look_back]))\n            print(data_raw_1[index:index + look_back].shape)\n    # \u0434\u0435\u043b\u0430\u0435\u043c \u0438\u0437 \u0441\u043f\u0438\u0441\u043a\u0430  \u043c\u0430\u0441\u0441\u0438\u0432 numpy\n    data_useful = np.array(data_useful);\n    \n    # \u0411\u044b\u043b\u043e 0,2\n    # \u041f\u0440\u0438 0,4 \/ train = test = 1,71\n    # \u041f\u0440\u0438 0,3 \/ train = 1.73 \/ test = 1.65 \n    test_set_size = int(np.round(0.3 * data_useful.shape[0]));\n    train_set_size = data_useful.shape[0] - (test_set_size);\n    \n    x_train_useful = data_useful[:train_set_size,:-1,:]\n    y_train_useful = data_useful[:train_set_size,-1,:]\n    \n    x_test_useful  = data_useful [train_set_size:,:-1]\n    y_test_useful  = data_useful [train_set_size:,-1,:]\n    \n    return [x_train_useful , y_train_useful , x_test_useful , y_test_useful]","b87af1b3":"look_back = 2\nx_train_useful, y_train_useful, x_test_useful, y_test_useful = load_data_2(df_aapl,df_ibm,  look_back)\n# x_train_ibm, y_train_ibm, x_test_ibm, y_test_ibm = load_data_ibm(df_ibm, look_back)\n# print('x_train_aapl.shape = ',x_train_aapl.shape)\n# print('y_train_aapl.shape = ',y_train_aapl.shape)\n# print('x_test_aapl.shape = ',x_test_aapl.shape)\n# print('y_test_aapl.shape = ',y_test_aapl.shape)","5ed91798":"# train_X = train_X.view([-1, x_train.shape[0], 1]\n# test_X = test_X.view([-1, x_test.shape[0], 1])\n# train_Y = train_Y.view([y_train.shape[0], 1])\n\n#print(y_train_useful.size(), x_train_aapl.size())","d98dd7cd":"x_train_useful = torch.from_numpy(x_train_useful).type(torch.Tensor)\nx_test_useful = torch.from_numpy(x_test_useful).type(torch.Tensor)\ny_train_useful = torch.from_numpy(y_train_useful).type(torch.Tensor)\ny_test_useful = torch.from_numpy(y_test_useful).type(torch.Tensor)\n\nprint(x_train_useful.size(), y_train_useful.size())\n\nn_steps = look_back-1\nbatch_size = 1606\n#n_iters = 3000\nnum_epochs = 350 #n_iters \/ (len(train_X) \/ batch_size)\n#num_epochs = int(num_epochs)\n\ntrain_useful = torch.utils.data.TensorDataset(x_train_useful,y_train_useful)\ntest_useful = torch.utils.data.TensorDataset(x_test_useful,y_test_useful)\n\ntrain_loader_useful = torch.utils.data.DataLoader(dataset=train_useful, \n                                           batch_size=batch_size, \n                                           shuffle=False)\n\ntest_loader_useful = torch.utils.data.DataLoader(dataset=test_useful, \n                                          batch_size=batch_size, \n                                          shuffle=False)\n\n# train_ibm = torch.utils.data.TensorDataset(x_train_aapl,y_train_ibm)\n# test_ibm = torch.utils.data.TensorDataset(x_test_aapl,y_test_ibm)\n\n# train_loader_ibm = torch.utils.data.DataLoader(dataset=train_ibm, \n#                                            batch_size=batch_size, \n#                                            shuffle=False)\n\n# test_loader_ibm = torch.utils.data.DataLoader(dataset=test_ibm, \n#                                           batch_size=batch_size, \n#                                           shuffle=False)","daaa428c":"# Build model\n#####################\ninput_dim = 2\nhidden_dim = 32\nnum_layers = 2 \noutput_dim = 2\n\n# Here we define our model as a class\nclass LSTM(nn.Module):\n    def __init__(self, input_dim, hidden_dim, num_layers, output_dim):\n        super(LSTM, self).__init__()\n        # Hidden dimensions\n        self.hidden_dim = hidden_dim\n\n        # Number of hidden layers\n        self.num_layers = num_layers\n\n        # Building your LSTM\n        # batch_first=True causes input\/output tensors to be of shape\n        # (batch_dim, seq_dim, feature_dim)\n        self.lstm = nn.LSTM(input_dim, hidden_dim, num_layers, batch_first=True)\n\n        # Readout layer\n        self.fc = nn.Linear(hidden_dim, output_dim)\n\n    def forward(self, x):\n        # Initialize hidden state with zeros\n        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_dim).requires_grad_()\n        \n        # Initialize cell state\n        c0 = torch.zeros(self.num_layers, x.size(0), self.hidden_dim).requires_grad_()\n        \n        # One time step\n        # We need to detach as we are doing truncated backpropagation through time (BPTT)\n        # If we don't, we'll backprop all the way to the start even after going through another batch\n        out, (hn, cn) = self.lstm(x, (h0.detach(), c0.detach()))\n\n        # Index hidden state of last time step\n        # out.size() --> 100, 28, 100\n        # out[:, -1, :] --> 100, 100 --> just want last time step hidden states! \n        out = self.fc(out[:, -1, :]) \n        # out.size() --> 100, 10\n        return out\n    \nmodel = LSTM(input_dim=input_dim, hidden_dim=hidden_dim, output_dim=output_dim, num_layers=num_layers)\n\nloss_fn = torch.nn.MSELoss(size_average=True)\n\noptimiser = torch.optim.Adam(model.parameters(), lr=0.01)\nprint(model)\nprint(len(list(model.parameters())))\nfor i in range(len(list(model.parameters()))):\n    print(list(model.parameters())[i].size())","ca5ee3da":"# Train model\n#####################\n\nhist = np.zeros(num_epochs)\n\n# x_train_aapl = torch.from_numpy(x_train_aapl).type(torch.Tensor)\n# x_test_aapl = torch.from_numpy(x_test_aapl).type(torch.Tensor)\n# y_train_aapl = torch.from_numpy(y_train_aapl).type(torch.Tensor)\n# y_test_aapl = torch.from_numpy(y_test_aapl).type(torch.Tensor)\n\n\n# Number of steps to unroll\nseq_dim =look_back-1  \n\nfor t in range(num_epochs):\n    # Initialise hidden state\n    # Don't do this if you want your LSTM to be stateful\n    #model.hidden = model.init_hidden()\n    \n    #print(type(x_train_aapl))\n    # Forward pass\n    y_train_pred = model(x_train_useful)\n\n    loss = loss_fn(y_train_pred, y_train_useful)\n    \n    print(loss)\n    if t % 10 == 0 and t !=0:\n        print(\"Epoch \", t, \"MSE: \", loss.item())\n    hist[t] = loss.item()\n\n    # Zero out gradient, else they will accumulate between epochs\n    optimiser.zero_grad()\n\n    # Backward pass\n    loss.backward()\n\n    # Update parameters\n    optimiser.step()","7944c5c5":"plt.plot(y_train_pred.detach().numpy()[:], label=\"Preds\")\nplt.plot(y_train_useful.detach().numpy()[0,:])\nplt.legend()\nplt.show()\n#print(y_train_pred.detach().numpy())\n#print(y_train_aapl.detach().numpy())\n\nplt.plot(hist, label=\"Training loss\")\nplt.legend()\nplt.show()","ff5bb53e":"np.shape(y_train_pred)","cc0c1526":"y_train_useful.detach().numpy().shape","dc05bfb4":"# \u0434\u0435\u043b\u0430\u0435\u043c \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u044f\ny_train_pred = model(x_train_useful)\ny_test_pred = model(x_test_useful)\n\n# invert \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u044f\ny_train_pred = scaler.inverse_transform(y_train_pred.detach().numpy())\n#y_train = scaler.inverse_transform(y_train.detach().numpy())\ny_test_pred = scaler.inverse_transform(y_test_pred.detach().numpy())\n#y_test = scaler.inverse_transform(y_test.detach().numpy())\n\n# \u0421\u0447\u0438\u0442\u0430\u0435\u043c RMSE \u043a\u043e\u0440\u0435\u043d\u044c \u0438\u0437 \u0441\u0440\u0435\u0434\u043d\u0435\u0439 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0438\u0447\u043d\u043e\u0439 \u043e\u0448\u0438\u0431\u043a\u0438\n# trainScore = math.sqrt(mean_squared_error(y_train[:,0], y_train_pred[:,0]))\n# print('Train Score: %.2f RMSE' % (trainScore))\n# testScore = math.sqrt(mean_squared_error(y_test[:,0], y_test_pred[:,0]))\n# print('Test Score: %.2f RMSE' % (testScore))","da059d08":"\n# shift train predictions for plotting\ntrainPredictPlot = np.empty_like(df_ibm)\ntrainPredictPlot[:, :] = np.nan\ntrainPredictPlot = y_train_pred \n\ntrainPredictPlot = np.empty_like(df_aapl)\ntrainPredictPlot[:, :] = np.nan\ntrainPredictPlot = y_train_pred \n\n# shift test predictions for plotting\ntestPredictPlot = np.empty_like(df_ibm)\ntestPredictPlot[:, :] =\n\n# \u0421\u0442\u0440\u043e\u0438\u043c baseline \u0438 predictions\nplt.figure(figsize=(16,8))\nplt.plot(scaler.inverse_transform(df_aapl))\nplt.plot(trainPredictPlot)\nplt.plot(testPredictPlot)\nplt.show()\n","f62fe8f0":"In this notebook we will be building and training LSTM to predict IBM stock. We will use PyTorch.","7cb343b7":"## 1. Libraries and settings","e1cb0a73":"## 3. Build the structure of model","9a14cdfb":"## 2. Analyze data"}}