{"cell_type":{"1e0a7723":"code","a910a471":"code","21bab67c":"code","9a2f57c8":"code","f61dd159":"code","c69fe062":"code","dbf4984a":"code","0bdc9502":"code","bdedd946":"code","f3be9411":"code","f4cf0d7c":"code","c30c614d":"code","f0dc6431":"code","01ebf56a":"code","ad0e405d":"code","9f36a317":"code","96f2c9cd":"code","fc4fb44d":"code","9fa412c4":"code","546eb518":"code","c52d7462":"code","dca38730":"code","856c022f":"code","ab4027c1":"code","df008bb9":"code","8dc289eb":"code","1d7ba15c":"code","268f8fe8":"code","b09c0032":"code","8ee4f6b3":"code","776b7fae":"code","b674a853":"code","7c9d9787":"code","ac0c04eb":"code","8f85b0ed":"code","e02b5c50":"code","a00fc631":"code","2780a991":"code","33989199":"code","508ef214":"code","4d343ae7":"code","359d4063":"code","44d374fb":"code","41017787":"code","e17f5e8a":"code","201d6a31":"code","defcf6cb":"code","8820b293":"code","95fe2d4a":"code","39044cc5":"code","d40e88ea":"code","46f148e6":"code","54c4f422":"code","5bb0f441":"code","f4a746a2":"code","e45b4989":"code","7894eafa":"code","0802ee32":"code","2523eba7":"code","898cb1e5":"code","89c85d1b":"code","d0a31f8a":"code","7b55e9e1":"code","be7b8210":"code","acf3e411":"code","15ea6c40":"code","92fdfa7e":"code","21c45a7d":"code","e94dc7c5":"code","6be8a565":"code","373bdbfc":"code","1a8795b8":"code","99fa3417":"code","605bfe2c":"code","3508ec98":"code","dbb4b110":"code","ec21c91b":"code","a972c70e":"code","9fd1f713":"code","11dfcb8b":"code","bca0417d":"code","6ea2041f":"code","3753b78b":"code","950b724b":"code","ee567c93":"code","fd853331":"code","edb3a302":"code","30f543b2":"code","1c93c198":"code","9e9e805b":"code","bd83c337":"code","7829074b":"code","05b7d748":"markdown","afb4e378":"markdown","f52fce57":"markdown"},"source":{"1e0a7723":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","a910a471":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nfrom time import time\nimport datetime\nimport gc\npd.set_option('display.max_columns',100)\npd.set_option('display.max_rows',1500)\npd.set_option('display.float_format', lambda x: '%.5f' % x)\nfrom sklearn.model_selection import train_test_split,KFold,GroupKFold\nfrom sklearn.preprocessing import LabelEncoder\nimport lightgbm as lgb\n\nfrom plotly.offline import init_notebook_mode,iplot,plot\nimport plotly.graph_objects as go\ninit_notebook_mode(connected=True)\nimport plotly.figure_factory as ff","21bab67c":"metadata_dtype = {'site_id':\"uint8\",'building_id':'uint16','square_feet':'float32','year_built':'float32','floor_count':\"float16\"}\nmetadata = pd.read_csv(\"..\/input\/ashrae-energy-prediction\/building_metadata.csv\",dtype=metadata_dtype)\nmetadata.info(memory_usage='deep')","9a2f57c8":"weather_dtype = {\"site_id\":\"uint8\"}\nweather_train = pd.read_csv(\"..\/input\/ashrae-energy-prediction\/weather_train.csv\",parse_dates=['timestamp'],dtype=weather_dtype)\nweather_test = pd.read_csv(\"..\/input\/ashrae-energy-prediction\/weather_test.csv\",parse_dates=['timestamp'],dtype=weather_dtype)\nprint (weather_train.info(memory_usage='deep'))\nprint (\"-------------------------------------\")\nprint (weather_test.info(memory_usage='deep'))","f61dd159":"train_dtype = {'meter':\"uint8\",'building_id':'uint16','meter_reading':\"float32\"}\ntrain = pd.read_csv(\"..\/input\/ashrae-energy-prediction\/train.csv\",parse_dates=['timestamp'],dtype=train_dtype)\ntest_dtype = {'meter':\"uint8\",'building_id':'uint16'}\ntest_cols_to_read = ['building_id','meter','timestamp']\ntest = pd.read_csv(\"..\/input\/ashrae-energy-prediction\/test.csv\",parse_dates=['timestamp'],usecols=test_cols_to_read,dtype=test_dtype)\n","c69fe062":"\"\"\"## Function to reduce the DF size\ndef reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() \/ 1024**2    \n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)    \n    end_mem = df.memory_usage().sum() \/ 1024**2\n    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df\"\"\"","dbf4984a":"\"\"\"#reducing memory usage\ntrain= reduce_mem_usage(train)\ntest= reduce_mem_usage(test)\n\nweather_train = reduce_mem_usage(weather_train)\nweather_test = reduce_mem_usage(weather_test)\nmetadata = reduce_mem_usage(metadata)\"\"\"","0bdc9502":"#submission file\nSubmission = pd.DataFrame(test.index,columns=['row_id'])","bdedd946":"train.tail()","f3be9411":"test.head()","f4cf0d7c":"metadata.head()","c30c614d":"weather_train.head()","f0dc6431":"weather_test.tail()","01ebf56a":"#checking missing values\nmissing_weather = pd.DataFrame(weather_train.isna().sum()\/len(weather_train),columns=[\"Weather_Train_Missing_%\"])\nmissing_weather[\"Weather_Test_Missing_%\"] = weather_test.isna().sum()\/len(weather_test)\nmissing_weather","ad0e405d":"#missing metadata\nmetadata.isna().sum()\/len(metadata)","9f36a317":"#dropped floor count since we have squarefoot\nmetadata['floor_count_isNa'] = metadata['floor_count'].isna().astype('uint8')\nmetadata['year_built_isNa'] = metadata['year_built'].isna().astype('uint8')\n# Dropping floor_count variable as it has 75% missing values\nmetadata.drop('floor_count',axis=1,inplace=True)","96f2c9cd":"missing_train_test = pd.DataFrame(train.isna().sum()\/len(train),columns=[\"Missing_Pct_Train\"])\nmissing_train_test[\"Missing_Pct_Test\"] = test.isna().sum()\/len(test)\nmissing_train_test","fc4fb44d":"train.tail()\n#we will need to combine weather file with train","9fa412c4":"train.describe(include='all')\n# Data contains records from 1st Jan to 31st Dec of 2016.\n# Data has information about 1448 buildings.\n# Data has 4 meter types.\n# Some extremely high values in meter reading which can be explored further.\n","546eb518":"train['meter'].replace({0:\"Electricity\",1:\"ChilledWater\",2:\"Steam\",3:\"HotWater\"},inplace=True)\ntest['meter'].replace({0:\"Electricity\",1:\"ChilledWater\",2:\"Steam\",3:\"HotWater\"},inplace=True)","c52d7462":"trace1 = go.Bar(x=train['meter'].unique(),y=train['meter'].value_counts().values,marker=dict(color=\"red\"),text='train')\ntrace2 = go.Bar(x=test['meter'].unique(),y=test['meter'].value_counts().values,marker=dict(color=\"blue\"),text='test')\ndata=[trace1,trace2]\nlayout = go.Layout(title='Countplot of meter',xaxis=dict(title='Meter'),yaxis=dict(title='Count'),hovermode='closest')\nfigure = go.Figure(data=data,layout=layout)\niplot(figure)","dca38730":"train[train['building_id'] == 1022]['meter'].unique()\n# Like it is mentioned in the competition description, each building may or may not have all 4 meter Id codes.","856c022f":"train.groupby('meter')['meter_reading'].agg(['min','max','mean','median','count','std'])\n#since min is 0 we must drop these values before training the model","ab4027c1":"for df in [train, test]:\n    df['Month'] = df['timestamp'].dt.month.astype(\"uint8\")\n    df['DayOfMonth'] = df['timestamp'].dt.day.astype(\"uint8\")\n    df['DayOfWeek'] = df['timestamp'].dt.dayofweek.astype(\"uint8\")\n    df['Hour'] = df['timestamp'].dt.hour.astype(\"uint8\")","df008bb9":"train[['timestamp','meter_reading']].set_index('timestamp').resample(\"H\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Hour')\ntrain[['timestamp','meter_reading']].set_index('timestamp').resample(\"D\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Day')\nplt.legend()\nplt.xlabel(\"Timestamp\")\nplt.ylabel(\"Average Meter Reading\")\nplt.title(\"Graph of Average Meter Reading\")\n# meter readings by hour and days..\/\/resample used to sample data","8dc289eb":"meter_Electricity = train[train['meter'] == \"Electricity\"]\nmeter_Electricity[['timestamp','meter_reading']].set_index('timestamp').resample(\"H\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Hour')\nmeter_Electricity[['timestamp','meter_reading']].set_index('timestamp').resample(\"D\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Day')\nplt.legend()\nplt.xlabel(\"Timestamp\")\nplt.ylabel(\"Average Meter Reading\")\nplt.title(\"Graph of Average Meter Readingfor Electricity Meter\")\n# The increase and decreasing trend can be attributed to the usage during the weekdays and during the weekends when it drops. ","1d7ba15c":"meter_ChilledWater = train[train['meter'] == \"ChilledWater\"]\nmeter_ChilledWater[['timestamp','meter_reading']].set_index('timestamp').resample(\"H\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Hour')\nmeter_ChilledWater[['timestamp','meter_reading']].set_index('timestamp').resample(\"D\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Day')\nplt.legend()\nplt.xlabel(\"Timestamp\")\nplt.ylabel(\"Average Meter Reading\")\nplt.title(\"Graph of Average Meter Readingfor ChilledWater Meter\")\n# Consumption gradually increases and reaches its peak during septembet to November months. \n","268f8fe8":"meter_Steam = train[train['meter'] == \"Steam\"]\nmeter_Steam[['timestamp','meter_reading']].set_index('timestamp').resample(\"H\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Hour')\nmeter_Steam[['timestamp','meter_reading']].set_index('timestamp').resample(\"D\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Day')\nplt.legend()\nplt.xlabel(\"Timestamp\")\nplt.ylabel(\"Average Meter Reading\")\nplt.title(\"Graph of Average Meter Readingfor Steam Meter\")\n# This is almost similar to that of the overall trend. ","b09c0032":"meter_HotWater = train[train['meter'] == \"HotWater\"]\nmeter_HotWater[['timestamp','meter_reading']].set_index('timestamp').resample(\"H\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Hour')\nmeter_HotWater[['timestamp','meter_reading']].set_index('timestamp').resample(\"D\")['meter_reading'].mean().plot(kind='line',figsize=(10,6),label='Avg_Meter_by_Day')\nplt.legend()\nplt.xlabel(\"Timestamp\")\nplt.ylabel(\"Average Meter Reading\")\nplt.title(\"Graph of Average Meter Readingfor HotWater Meter\")\n# Hot water meter reading is high during the winter months and reduces during the summer months. ","8ee4f6b3":"train.groupby(['meter','Month'])['meter_reading'].agg(['max','mean','median','count','std'])\n# We can see that only Steam meter has very high meter_reading values as compared to other types of meters.\n# We can see that the average electricity meter_reading does not vary much across the months.\n# Average Hot Water meter_reading is relatively less from April to October Months.\n# Average Steam meter_reading is way higher from March to June as compared to the other months.","776b7fae":"train.groupby(['meter','DayOfWeek'])['meter_reading'].agg(['max','mean','median','count','std'])\n# Average meter_reading of Steam type of meter is higher as compared to the other meter types.","b674a853":"summary=train.groupby('building_id')['meter_reading'].agg(['count','min','max','mean','median','std'])","7c9d9787":"#building wise summary\nsummary.sort_values(['mean'],ascending=False).head(20)","ac0c04eb":"train[train['building_id'] == 1099]['meter_reading'].describe()","8f85b0ed":"plt.hist(train[train['building_id'] == 1099]['meter_reading'])","e02b5c50":"train['meter_reading'].describe()","a00fc631":"sns.distplot(np.log1p(train['meter_reading']),kde=False)\nplt.title(\"Distribution of Log of Meter Reading Variable\")\n# Lot of 0 values as can be seen from the distribution","2780a991":"sns.boxplot(np.log1p(train[train['meter'] == \"Electricity\"]['meter_reading']))\nplt.title(\"Boxplot of Meter Reading Variable for the Meter Type: Electricity\")\n# We can see a few outliers here.","33989199":"sns.boxplot(np.log1p(train[train['meter'] == \"ChilledWater\"]['meter_reading']))\nplt.title(\"Boxplot of Meter Reading Variable for the Meter Type: Electricity\")\n# Not many outliers here. ","508ef214":"sns.boxplot(np.log1p(train[train['meter'] == \"HotWater\"]['meter_reading']))\nplt.title(\"Boxplot of Meter Reading Variable for the Meter Type: Electricity\")","4d343ae7":"sns.boxplot(np.log1p(train[train['meter'] == \"Steam\"]['meter_reading']))\nplt.title(\"Boxplot of Meter Reading Variable for the Meter Type: Electricity\")","359d4063":"sns.distplot(np.log1p(train[train['meter'] == \"Electricity\"]['meter_reading']),kde=False)\nplt.title(\"Distribution of Meter Reading per MeterID code: Electricity\")\n#same is case for other meter types we will neen to remove zero values","44d374fb":"metadata.info()\n# Missing values in year_built and floor_count variables.","41017787":"metadata.head()","e17f5e8a":"cols = ['site_id','primary_use','building_id','year_built']\nfor col in cols:\n    print (\"Number of Unique Values in the {} column are:\".format(col),metadata[col].nunique())","201d6a31":"cols = ['site_id','primary_use','year_built']\nfor col in cols:\n    print (\"Unique Values in the {} column are:\".format(col),metadata[col].unique())\n    print (\"\\n\")","defcf6cb":"trace1 = go.Bar(x=metadata['site_id'].unique(),y=metadata['site_id'].value_counts().values,marker=dict(color=\"blue\"))\ndata=[trace1]\nlayout = go.Layout(title='Countplot of site_id variable',xaxis=dict(title='site_id'),yaxis=dict(title='Count'),hovermode='closest')\nfigure = go.Figure(data=data,layout=layout)\niplot(figure)\n","8820b293":"trace1 = go.Bar(x=metadata['primary_use'].unique(),y=metadata['primary_use'].value_counts().values,marker=dict(color=\"rgb(55, 83, 109)\"))\ndata=[trace1]\nlayout = go.Layout(title='Countplot of primary_use variable',xaxis=dict(title='primary_use'),yaxis=dict(title='Count'),hovermode='closest')\nfigure = go.Figure(data=data,layout=layout)\niplot(figure)\n# Education, Office, Entertainment\/Public Assembly, Public Services, Lodging\/Residential form the bulk of Primary Use","95fe2d4a":"#to combine categories or not???\n#metadata['primary_use'].replace({\"Healthcare\":\"Other\",\"Parking\":\"Other\",\"Warehouse\/storage\":\"Other\",\"Manufacturing\/industrial\":\"Other\",\n #                               \"Retail\":\"Other\",\"Services\":\"Other\",\"Technology\/science\":\"Other\",\"Food sales and service\":\"Other\",\n  #                              \"Utility\":\"Other\",\"Religious worship\":\"Other\"},inplace=True)","39044cc5":"metadata['square_feet'].describe()","d40e88ea":"metadata['square_feet'] = np.log1p(metadata['square_feet'])","46f148e6":"sns.distplot(metadata['square_feet'])\nplt.title(\"Distribution of Square Feet variable of Metadata Table\")\nplt.xlabel(\"Area in Square Feet\")\nplt.ylabel(\"Frequency\")\n# Looks like a normal distribution distribution","54c4f422":"sns.boxplot(metadata['square_feet'])\nplt.title(\"Box Plot of Square Feet Variable\")\n# There are a few outliers visible","5bb0f441":"metadata.groupby('primary_use')['square_feet'].agg(['mean','median','count']).sort_values(by='count')\n# Parking has the highest average are although the count is less.\n# Education has the highest count as can be seen in the countplot above.","f4a746a2":"trace1 = go.Bar(x=metadata['year_built'].unique(),y=metadata['year_built'].value_counts().values,marker=dict(color=\"blue\"))\ndata=[trace1]\nlayout = go.Layout(title='Countplot of year_built variable',xaxis=dict(title='year_built'),yaxis=dict(title='Count'),hovermode='closest')\nfigure = go.Figure(data=data,layout=layout)\niplot(figure)","e45b4989":"metadata.describe()","7894eafa":"#should blank year be filled with 1976??\nmetadata['year_built'].fillna(1976, inplace=True)\nmetadata['year_built'] = metadata['year_built'].astype('int16')","0802ee32":"weather_train.head()","2523eba7":"weather_train.isna().sum()\/len(weather_train)","898cb1e5":"weather_train.info(memory_usage='deep')","89c85d1b":"weather_train[['air_temperature','cloud_coverage','dew_temperature','precip_depth_1_hr','sea_level_pressure','wind_speed']].describe()\n#Missing values in air_temperature, cloud_coverage, dew_temperature, precip_depth_1_hr, sea_level_pressure, wind_speed variables\n#There are negative values in air_temperature, dew_temperature and precip_depth_1_hr variables.\n#Looks like there are outliers in precip_depth_1_hr variable (can be guessed from Max value).\n#min value of wind_speed as 0 does not make any sense.\n#Only temperature would be crucial\n","d0a31f8a":"weather_train['timestamp'].describe()\n# This data is from 1st Jan to 31st Dec 2016, similar to the timestamp of the training data","7b55e9e1":"cols = ['air_temperature','cloud_coverage','dew_temperature','precip_depth_1_hr','sea_level_pressure','wind_speed']\nfor ind,col in enumerate(weather_train[cols]):\n    plt.figure(ind)\n    sns.distplot(weather_train[col].dropna())","be7b8210":"cols = ['air_temperature','cloud_coverage','dew_temperature','precip_depth_1_hr','sea_level_pressure','wind_speed']\nfor ind,col in enumerate(weather_train[cols]):\n    plt.figure(ind)\n    sns.boxplot(weather_train[col].dropna())","acf3e411":"weather_test.info(memory_usage='deep')","15ea6c40":"weather_test.info(memory_usage='deep')","92fdfa7e":"def fill_weather_dataset(weather_df):\n    \n    # Find Missing Dates\n    time_format = \"%Y-%m-%d %H:%M:%S\"\n\n    # Add new Features\n    weather_df[\"datetime\"] = pd.to_datetime(weather_df[\"timestamp\"])\n    weather_df[\"day\"] = weather_df[\"datetime\"].dt.day\n    weather_df[\"week\"] = weather_df[\"datetime\"].dt.week\n    weather_df[\"month\"] = weather_df[\"datetime\"].dt.month\n    \n    # Reset Index for Fast Update\n    weather_df = weather_df.set_index(['site_id','day','month'])\n\n    air_temperature_filler = pd.DataFrame(weather_df.groupby(['site_id','day','month'])['air_temperature'].mean(),columns=[\"air_temperature\"])\n    weather_df.update(air_temperature_filler,overwrite=False)\n\n    # Step 1\n    cloud_coverage_filler = weather_df.groupby(['site_id','day','month'])['cloud_coverage'].mean()\n    # Step 2\n    cloud_coverage_filler = pd.DataFrame(cloud_coverage_filler.fillna(method='ffill'),columns=[\"cloud_coverage\"])\n\n    weather_df.update(cloud_coverage_filler,overwrite=False)\n\n    due_temperature_filler = pd.DataFrame(weather_df.groupby(['site_id','day','month'])['dew_temperature'].mean(),columns=[\"dew_temperature\"])\n    weather_df.update(due_temperature_filler,overwrite=False)\n\n    # Step 1\n    sea_level_filler = weather_df.groupby(['site_id','day','month'])['sea_level_pressure'].mean()\n    # Step 2\n    sea_level_filler = pd.DataFrame(sea_level_filler.fillna(method='ffill'),columns=['sea_level_pressure'])\n\n    weather_df.update(sea_level_filler,overwrite=False)\n\n    wind_direction_filler =  pd.DataFrame(weather_df.groupby(['site_id','day','month'])['wind_direction'].mean(),columns=['wind_direction'])\n    weather_df.update(wind_direction_filler,overwrite=False)\n\n    wind_speed_filler =  pd.DataFrame(weather_df.groupby(['site_id','day','month'])['wind_speed'].mean(),columns=['wind_speed'])\n    weather_df.update(wind_speed_filler,overwrite=False)\n\n    # Step 1\n    precip_depth_filler = weather_df.groupby(['site_id','day','month'])['precip_depth_1_hr'].mean()\n    # Step 2\n    precip_depth_filler = pd.DataFrame(precip_depth_filler.fillna(method='ffill'),columns=['precip_depth_1_hr'])\n\n    weather_df.update(precip_depth_filler,overwrite=False)\n\n    weather_df = weather_df.reset_index()\n    weather_df = weather_df.drop(['datetime','day','week','month'],axis=1)\n    return weather_df","21c45a7d":"#filling blank values of weather\nweather_train = fill_weather_dataset(weather_train)\nweather_test = fill_weather_dataset(weather_test)","e94dc7c5":"cols = ['air_temperature','cloud_coverage','dew_temperature','precip_depth_1_hr','sea_level_pressure','wind_direction','wind_speed']\nfor col in cols:\n    print (\" Minimum Value of {} column is {}\".format(col,weather_train[col].min()))\n    print (\" Maximum Value of {} column is {}\".format(col,weather_train[col].max()))\n    print (\"----------------------------------------------------------------------\")","6be8a565":"for df in [weather_train,weather_test]:\n    df['air_temperature'] = df['air_temperature'].astype('float32')\n    df['cloud_coverage'] = df['cloud_coverage'].astype('float16')\n    df['dew_temperature'] = df['dew_temperature'].astype('float16')\n    df['precip_depth_1_hr'] = df['precip_depth_1_hr'].astype('float32')\n    df['sea_level_pressure'] = df['sea_level_pressure'].astype('float32')\n    df['wind_direction'] = df['wind_direction'].astype('float32')\n    df['wind_speed'] = df['wind_speed'].astype('float16')","373bdbfc":"%%time\ntrain = pd.merge(train,metadata,on='building_id',how='left')\ntest  = pd.merge(test,metadata,on='building_id',how='left')\nprint (\"Training Data Shape {}\".format(train.shape))\nprint (\"Testing Data Shape {}\".format(test.shape))\ngc.collect()","1a8795b8":"%%time\ntrain = pd.merge(train,weather_train,on=['site_id','timestamp'],how='left')\ntest  = pd.merge(test,weather_test,on=['site_id','timestamp'],how='left')\nprint (\"Training Data Shape {}\".format(train.shape))\nprint (\"Testing Data Shape {}\".format(test.shape))\ngc.collect()","99fa3417":"#since we have not filed blank years this might give errors\/wrong values\nfor df in [train,test]:\n    df['square_feet'] = df['square_feet'].astype('float16')\n    df['Age'] = df['timestamp'].dt.year - df['year_built']\n","605bfe2c":"# As per the discussion in the following thread, https:\/\/www.kaggle.com\/c\/ashrae-energy-prediction\/discussion\/117083, there is some discrepancy in the meter_readings for different ste_id's and buildings. It makes sense to delete them\nidx_to_drop = list((train[(train['site_id'] == 0) & (train['timestamp'] < \"2016-05-21 00:00:00\")]).index)\nprint (len(idx_to_drop))\ntrain.drop(idx_to_drop,axis='rows',inplace=True)\n","3508ec98":"# dropping all the electricity meter readings that are 0, after considering them as anomalies.\nidx_to_drop = list(train[(train['meter'] == \"Electricity\") & (train['meter_reading'] == 0)].index)\nprint(len(idx_to_drop))\ntrain.drop(idx_to_drop,axis='rows',inplace=True)","dbb4b110":"idx_to_drop = list((train[(train['building_id']==1099)&(train['meter_reading'] > 30000)&(train['meter'] == \"Steam\")]).index)\nprint (len(idx_to_drop))\ntrain.drop(idx_to_drop,axis='rows',inplace=True)","ec21c91b":"# Converting the dependent variable to logarithmic scale\ntrain['meter_reading'] = np.log1p(train['meter_reading'])","a972c70e":"%%time\nmean_meter_reading_per_building = train.groupby('building_id')['meter_reading'].mean()\ntrain['mean_meter_reading_per_building'] = train['building_id'].map(mean_meter_reading_per_building)\nmedian_meter_reading_per_building = train.groupby('building_id')['meter_reading'].median()\ntrain['median_meter_reading_per_building'] = train['building_id'].map(median_meter_reading_per_building)\nstd_meter_reading_per_building = train.groupby('building_id')['meter_reading'].std()\ntrain['std_meter_reading_per_building'] = train['building_id'].map(std_meter_reading_per_building)\n\nmean_meter_reading_per_dayofweek = train.groupby('DayOfWeek')['meter_reading'].mean()\ntrain['mean_meter_reading_per_dayofweek'] = train['DayOfWeek'].map(mean_meter_reading_per_dayofweek)\nmedian_meter_reading_per_dayofweek = train.groupby('DayOfWeek')['meter_reading'].median()\ntrain['median_meter_reading_per_dayofweek'] = train['DayOfWeek'].map(median_meter_reading_per_dayofweek)\nstd_meter_reading_per_dayofweek = train.groupby('DayOfWeek')['meter_reading'].std()\ntrain['std_meter_reading_per_dayofweek'] = train['DayOfWeek'].map(std_meter_reading_per_dayofweek)\n\n\nmean_meter_reading_per_meter = train.groupby('meter')['meter_reading'].mean()\ntrain['mean_meter_reading_per_meter'] = train['meter'].map(mean_meter_reading_per_meter)\nmedian_meter_reading_per_meter = train.groupby('meter')['meter_reading'].median()\ntrain['median_meter_reading_per_meter'] = train['meter'].map(median_meter_reading_per_meter)\nstd_meter_reading_per_meter = train.groupby('meter')['meter_reading'].std()\ntrain['std_meter_reading_per_meter'] = train['meter'].map(std_meter_reading_per_meter)\n\n\nmean_meter_reading_per_month = train.groupby('Month')['meter_reading'].mean()\ntrain['mean_meter_reading_per_month'] = train['Month'].map(mean_meter_reading_per_month)\nmedian_meter_reading_per_month = train.groupby('Month')['meter_reading'].median()\ntrain['median_meter_reading_per_month'] = train['Month'].map(median_meter_reading_per_month)\nstd_meter_reading_per_month = train.groupby('Month')['meter_reading'].std()\ntrain['std_meter_reading_per_month'] = train['Month'].map(std_meter_reading_per_month)\n\n\ntest['mean_meter_reading_per_building'] = test['building_id'].map(mean_meter_reading_per_building)\ntest['median_meter_reading_per_building'] = test['building_id'].map(median_meter_reading_per_building)\ntest['std_meter_reading_per_building'] = test['building_id'].map(std_meter_reading_per_building)\n\ntest['mean_meter_reading_per_dayofweek'] = test['year_built'].map(mean_meter_reading_per_dayofweek)\ntest['median_meter_reading_per_dayofweek'] = test['year_built'].map(median_meter_reading_per_dayofweek)\ntest['std_meter_reading_per_dayofweek'] = test['year_built'].map(std_meter_reading_per_dayofweek)\n\ntest['mean_meter_reading_per_meter'] = test['meter'].map(mean_meter_reading_per_meter)\ntest['median_meter_reading_per_meter'] = test['meter'].map(median_meter_reading_per_meter)\ntest['std_meter_reading_per_meter'] = test['meter'].map(std_meter_reading_per_meter)\n\ntest['mean_meter_reading_per_month'] = test['primary_use'].map(mean_meter_reading_per_month)\ntest['median_meter_reading_per_month'] = test['primary_use'].map(median_meter_reading_per_month)\ntest['std_meter_reading_per_month'] = test['primary_use'].map(std_meter_reading_per_month)","9fd1f713":"%%time\nfor df in [train, test]:\n    df['mean_meter_reading_per_building'] = df['mean_meter_reading_per_building'].astype(\"float16\")\n    df['median_meter_reading_per_building'] = df['mean_meter_reading_per_building'].astype(\"float16\")\n    df['std_meter_reading_per_building'] = df['std_meter_reading_per_building'].astype(\"float16\")\n    \n    df['mean_meter_reading_per_meter'] = df['mean_meter_reading_per_meter'].astype(\"float16\")\n    df['median_meter_reading_per_meter'] = df['median_meter_reading_per_meter'].astype(\"float16\")\n    df['std_meter_reading_per_meter'] = df['std_meter_reading_per_meter'].astype(\"float16\")\n    \n    df['mean_meter_reading_per_dayofweek'] = df['mean_meter_reading_per_dayofweek'].astype(\"float16\")\n    df['median_meter_reading_per_dayofweek'] = df['median_meter_reading_per_dayofweek'].astype(\"float16\")\n    df['std_meter_reading_per_dayofweek'] = df['std_meter_reading_per_dayofweek'].astype(\"float16\")\n    \n    df['mean_meter_reading_per_month'] = df['mean_meter_reading_per_month'].astype(\"float16\")\n    df['median_meter_reading_per_month'] = df['median_meter_reading_per_month'].astype(\"float16\")\n    df['std_meter_reading_per_month'] = df['std_meter_reading_per_month'].astype(\"float16\")\n    \n    df['Age'] = df['Age'].astype('uint8')\ngc.collect()","11dfcb8b":"train.drop(['timestamp','year_built'],axis=1,inplace=True)\ntest.drop(['timestamp','year_built'],axis=1,inplace=True)","bca0417d":"print (train.shape, test.shape)","6ea2041f":"%%time\nle = LabelEncoder()\n\ntrain['meter']= le.fit_transform(train['meter']).astype(\"uint8\")\ntest['meter']= le.fit_transform(test['meter']).astype(\"uint8\")\ntrain['primary_use']= le.fit_transform(train['primary_use']).astype(\"uint8\")\ntest['primary_use']= le.fit_transform(test['primary_use']).astype(\"uint8\")","3753b78b":"%%time\n# Let's check the correlation between the variables and eliminate the one's that have high correlation\n# Threshold for removing correlated variables\nthreshold = 0.9\n\n# Absolute value correlation matrix\ncorr_matrix = train.corr().abs()\ncorr_matrix.head()\n","950b724b":"# Upper triangle of correlations\nupper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))\nupper.head()","ee567c93":"# Select columns with correlations above threshold\nto_drop = [column for column in upper.columns if any(upper[column] > threshold)]\n\nprint('There are %d columns to remove.' % (len(to_drop)))\nprint (\"Following columns can be dropped {}\".format(to_drop))","fd853331":"train.drop(to_drop,axis=1,inplace=True)\ntest.drop(to_drop,axis=1,inplace=True)","edb3a302":"y = train['meter_reading']\ntrain.drop('meter_reading',axis=1,inplace=True)","30f543b2":"categorical_cols = ['building_id','Month','meter','Hour','primary_use','DayOfWeek','DayOfMonth','floor_count_isNa']","1c93c198":"params = {'feature_fraction': 0.75,\n          'bagging_fraction': 0.75,\n          'objective': 'regression',\n          'max_depth': 11,\n          'learning_rate': 0.15,\n          \"boosting_type\": \"gbdt\",\n          \"bagging_seed\": 11,\n          \"metric\": 'rmse',\n          \"verbosity\": -1,\n          'reg_alpha': 0.5,\n          'reg_lambda': 0.5,\n          'random_state': 47,\n          \"num_leaves\": 31}\n\nkf = KFold(n_splits=3)\nmodels = []\nfor train_index,test_index in kf.split(train):\n    train_features = train.iloc[train_index]\n    train_target = y.iloc[train_index]\n    \n    test_features = train.iloc[test_index]\n    test_target = y.iloc[test_index]\n    \n    d_training = lgb.Dataset(train_features, label=train_target,categorical_feature=categorical_cols, free_raw_data=False)\n    d_test = lgb.Dataset(test_features, label=test_target,categorical_feature=categorical_cols, free_raw_data=False)\n    \n    model = lgb.train(params, train_set=d_training, num_boost_round=2000, valid_sets=[d_training,d_test], verbose_eval=100, early_stopping_rounds=50)\n    models.append(model)\n    gc.collect()\n","9e9e805b":"ser1 = pd.DataFrame(models[0].feature_importance(),train.columns,columns=['Importance']).sort_values(by='Importance')\nser1['Importance'].plot(kind='bar',figsize=(10,6))","bd83c337":"ser2 = pd.DataFrame(models[1].feature_importance(),train.columns,columns=['Importance']).sort_values(by='Importance')\nser2['Importance'].plot(kind='bar',figsize=(10,6))","7829074b":"ser3 = pd.DataFrame(models[2].feature_importance(),train.columns,columns=['Importance']).sort_values(by='Importance')\nser3['Importance'].plot(kind='bar',figsize=(10,6))","05b7d748":"Distribution of sea_level_pressure looks like a normal distribution.\n\nLot of 0 values in precip_depth_1_hr variable.\n\nWind_Speed distribution looks like positively skewed.\n\nDew Temperature looks like a Negatively skewed distribution.\n\nCloud_Coverage takes distinct values unlike these other variables.","afb4e378":"<h2>Exploring the data<h2>","f52fce57":"<h2>Weather Data<h2>"}}