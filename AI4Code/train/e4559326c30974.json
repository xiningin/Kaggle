{"cell_type":{"ff8cae80":"code","07de6fcc":"code","829f30ae":"code","3a46dbdb":"code","d2c5f0ec":"code","bc56a6b1":"code","b8b08a3a":"markdown"},"source":{"ff8cae80":"#Import libraries\nimport pandas as pd\nimport numpy as np","07de6fcc":"#Read data\ndf = pd.read_csv('..\/input\/cities.csv')\nsubmission = pd.read_csv('..\/input\/sample_submission.csv')\n\ndf.head()","829f30ae":"#Initialize variables\nnumber_of_cities = df.shape[0]\nnon_traversed_cities = np.array((range(df.shape[0])))\ncurrent_city = 0\n\niteration = 1\ntraversed = []\ntotal_distance = []\n\nprint('Number of cities to traverse:', number_of_cities)","3a46dbdb":"#Find primes\ndef is_prime(n):\n    if n > 2:\n        i = 2\n        while i ** 2 <= n:\n            if n % i:\n                i += 1\n            else:\n                return False\n    elif n != 2:\n        return False\n    return True\n\n#Create column in DF_cities to flag prime cities\nprime_cities = df.CityId.apply(is_prime)\nnon_prime_index = prime_cities[prime_cities==False].index.values\n\nprint('Number of Prime cities:', sum(prime_cities))","d2c5f0ec":"#Find next closer city and add to traversed. Repeat until all cities traversed\nwhile len(traversed)<number_of_cities:\n\n    #print some info for debugging purposes\n    # print('Iteration number:,', iteration)\n    # print('Unique cities visited:', len(np.unique(traversed)) + 1)\n    # print('Current city:', current_city)\n    # print(' ')\n\n    # create distance matrix of current city to remaining cities\n    df_remain = df.loc[non_traversed_cities,:].reset_index(drop=True)\n    coords = np.array([df_remain.X.values, df_remain.Y.values]).T\n    current_city_idx = df_remain.index[df_remain['CityId']==current_city].values[0]\n    df_remain['distances'] = np.linalg.norm(coords-coords[current_city_idx], axis = 1)\n\n    # Make the distance of current city from self bigger than any other value to avoid selection\n    df_remain['distances'][df_remain['CityId']== current_city] = df_remain['distances'].max() + 1\n\n    #Add penalty if the city in every ten iterations is not prime\n    if iteration%10 == 0:\n        #Find the positions of remaining non prime cities\n        non_prime_idx = df_remain['CityId'].isin(non_prime_index)\n        df_remain['distances'].loc[non_prime_idx] = df_remain['distances'] * 1.1\n        print('Number of cities tralleved:', len(traversed),\n              'Percentage complete:', np.round(len(traversed)\/number_of_cities*100,4), '%')\n\n\n    #Find next closer city\n    next_city = df_remain['CityId'][df_remain['distances']==df_remain['distances'].min()].values[0]\n\n    # #Sanity check\n    # if next_city in traversed:\n    #     print('This city has been visited')\n    #     break\n\n    #Add current city to traversed and remove from non_traversed\n    traversed.append(current_city)\n    non_traversed_cities = np.delete(non_traversed_cities, np.where(non_traversed_cities==current_city))\n\n    #Add distance travelled to total_distance\n    total_distance.append(df_remain['distances'].min())\n\n    #Set next city as the current city to repeat the process\n    current_city = next_city\n    iteration +=1","bc56a6b1":"#Add the return to north pole\ntraversed.append(0)\n\n#Write to file to submit\nsubmission['Path'] = traversed\nsubmission.to_csv('santa_path.csv', index = False)\nsubmission.head()","b8b08a3a":"## Go Rudolf, go!\n\nIn this script I am gonna get Rudolf and his fellow reindeers a bit tired since I am not using an optimization packages to lay down the ex-ante shortest path. Instead, in each step of santa's trip, I am calculating the next closer city and send him there to dispatch gifts. Every tenth city he visits I am penalizing all cities except the primes with 10% distance increase as the problem requires. The process is repeated until all the graph is traversed. \n\nSorry Rudolf! I am going to make you another script with optimization to compensate!"}}