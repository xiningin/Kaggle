{"cell_type":{"35837013":"code","233a49e1":"code","0452287f":"code","84237a21":"code","b2edd397":"code","df8696a8":"code","8da68032":"code","c2cbebd1":"code","5a5f553c":"code","063ca48a":"code","bf594cd2":"code","73a125ca":"code","70f954db":"code","44cbafac":"code","737148f5":"code","fc7d8034":"code","31111e48":"code","99cf91e6":"code","1ba89fb2":"code","a638c68d":"code","5444fe0f":"code","e0571806":"code","009a4d58":"code","cf292e46":"code","7b435493":"code","afcb4510":"code","7d163871":"code","e35368f7":"code","ac08fbd4":"code","73c68ec5":"code","d2155654":"code","6d7adc4f":"code","18eaec6b":"code","d26faeae":"code","6c6e9ff4":"code","7cf7a850":"code","6579b6be":"code","d0c9a66e":"code","2f55cd61":"code","15f7f9d2":"code","ad5c2ae8":"code","77bcfc86":"code","53a57df5":"code","052a6410":"code","d4dadb37":"code","4cfe050a":"code","63ca1f23":"code","4a193195":"markdown","d70a283e":"markdown","e886b4e0":"markdown","4d510c4e":"markdown","a238fb53":"markdown","39ecf71d":"markdown","9287923c":"markdown"},"source":{"35837013":"import tensorflow as tf\ndevice_name = tf.test.gpu_device_name()\nif \"GPU\" not in device_name:\n    print(\"GPU device not found\")\nprint('Found GPU at: {}'.format(device_name))","233a49e1":"import os\nimport numpy as np\nimport pandas as pd\nfrom glob import glob\nfrom itertools import chain\nfrom sklearn.metrics import roc_curve, auc, roc_auc_score, accuracy_score, average_precision_score\nfrom matplotlib import pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\n\nimport tensorflow as tf","0452287f":"os.environ['CUDA_VISIBLE_DEVICES'] = '0'","84237a21":"DATA_DIR = '..\/input\/data\/'\nimage_size = 256\nbatch_size = 32","b2edd397":"df = pd.read_csv(f'{DATA_DIR}Data_Entry_2017.csv')","df8696a8":"data_image_paths = {os.path.basename(x): x for x in glob(os.path.join(DATA_DIR, 'images*', '*', '*.png'))}","8da68032":"df['path'] = df['Image Index'].map(data_image_paths.get)","c2cbebd1":"df['Finding Labels'] = df['Finding Labels'].map(lambda x: x.replace('No Finding', ''))","5a5f553c":"labels = np.unique(list(chain(*df['Finding Labels'].map(lambda x: x.split('|')).tolist())))\nlabels = [x for x in labels if len(x) > 0]","063ca48a":"labels","bf594cd2":"for label in labels:\n    if len(label) > 1:\n        df[label] = df['Finding Labels'].map(lambda finding: 1.0 if label in finding else 0.0)","73a125ca":"df.head()","70f954db":"labels = [label for label in labels if df[label].sum() > 1000]","44cbafac":"labels","737148f5":"train_df, valid_df = train_test_split(df, test_size=0.20, random_state=2018, stratify=df['Finding Labels'].map(lambda x: x[:4]))","fc7d8034":"train_df['labels'] = train_df.apply(lambda x: x['Finding Labels'].split('|'), axis=1)\nvalid_df['labels'] = valid_df.apply(lambda x: x['Finding Labels'].split('|'), axis=1)","31111e48":"core_idg = ImageDataGenerator(rescale=1 \/ 255,\n                                  samplewise_center=True,\n                                  samplewise_std_normalization=True,\n                                  horizontal_flip=True,\n                                  vertical_flip=False,\n                                  height_shift_range=0.05,\n                                  width_shift_range=0.1,\n                                  rotation_range=5,\n                                  shear_range=0.1,\n                                  fill_mode='reflect',\n                                  zoom_range=0.15)\n\ntrain_gen = core_idg.flow_from_dataframe(dataframe=train_df,\n                                             directory=None,\n                                             x_col='path',\n                                             y_col='labels',\n                                             class_mode='categorical',\n                                             batch_size=batch_size,\n                                             classes=labels,\n                                             target_size=(image_size, image_size))\n\nvalid_gen = core_idg.flow_from_dataframe(dataframe=valid_df,\n                                             directory=None,\n                                             x_col='path',\n                                             y_col='labels',\n                                             class_mode='categorical',\n                                             batch_size=batch_size,\n                                             classes=labels,\n                                             target_size=(image_size, image_size))\n\ntest_X, test_Y = next(core_idg.flow_from_dataframe(dataframe=valid_df,\n                                                       directory=None,\n                                                       x_col='path',\n                                                       y_col='labels',\n                                                       class_mode='categorical',\n                                                       batch_size=1024,\n                                                       classes=labels,\n                                                       target_size=(image_size, image_size)))","99cf91e6":"from tensorflow.keras.applications.densenet import DenseNet121\nfrom tensorflow.keras.applications.inception_v3 import InceptionV3\nfrom tensorflow.keras.applications.xception import Xception\nfrom tensorflow.keras.applications.nasnet import NASNetMobile\nfrom tensorflow.keras.applications.inception_resnet_v2 import InceptionResNetV2\n\nbase_model = InceptionResNetV2(include_top=False, weights='imagenet', input_shape=(256, 256, 3))\nx = base_model.output\nx = tf.keras.layers.GlobalAveragePooling2D()(x)\noutput = tf.keras.layers.Dense(len(labels), activation=\"softmax\")(x)\nmodel = tf.keras.Model(base_model.input, output)\nmodel.compile(optimizer=tf.keras.optimizers.RMSprop(), loss='binary_crossentropy', metrics=['accuracy'])","1ba89fb2":"def get_callbacks(model_name):\n    callbacks = []\n    tensor_board = tf.keras.callbacks.TensorBoard(log_dir='.\/logs', histogram_freq=0)\n    callbacks.append(tensor_board)\n    checkpoint = tf.keras.callbacks.ModelCheckpoint(\n        filepath=f'model.{model_name}.h5',\n        verbose=1,\n        save_best_only=True)\n    # erly = tf.keras.callbacks.EarlyStopping(monitor='loss', patience=3)\n    callbacks.append(checkpoint)\n    # callbacks.append(erly)\n    return callbacks","a638c68d":"callbacks = get_callbacks('inceptionresnetv2')\nmodel.fit(train_gen,\n              steps_per_epoch=128,\n              validation_data=(test_X, test_Y),\n              epochs=100,\n              callbacks=callbacks)","5444fe0f":"model.save('Inceptionmodel.hdf5')","e0571806":"model.save('Inception_Model.h5')","009a4d58":"from keras.models import load_model\ninception = tf.keras.models.load_model('Inception_model.h5')","cf292e46":"test_X.shape","7b435493":"sample_image = test_X[0]\nsample_image = sample_image.reshape((1, 256,256,3))\ny_pred = inception.predict(sample_image)","afcb4510":"y_pred","7d163871":"from sklearn.metrics import roc_auc_score\n\nprint(y_pred)\n# auc scores\nauc_score1 = roc_auc_score(test_Y, y_pred[:,1], multi_class='ovr')\nprint(auc_score1)","e35368f7":"y_pred","ac08fbd4":"clf = OneVsRestClassifier(LinearSVC(random_state=0))\ny_score = inception.fit(X_train, y_train).decision_function(X_test)\n\n# Compute ROC curve and ROC area for each class\nfpr = dict()\ntpr = dict()\nroc_auc = dict()\nfor i in range(n_classes):\n    fpr[i], tpr[i], _ = roc_curve(y_test[:, i], y_score[:, i])\n    roc_auc[i] = auc(fpr[i], tpr[i])\n\n# Plot of a ROC curve for a specific class\nfor i in range(n_classes):\n    plt.figure()\n    plt.plot(fpr[i], tpr[i], label='ROC curve (area = %0.2f)' % roc_auc[i])\n    plt.plot([0, 1], [0, 1], 'k--')\n    plt.xlim([0.0, 1.0])\n    plt.ylim([0.0, 1.05])\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver operating characteristic example')\n    plt.legend(loc=\"lower right\")\n    plt.show()","73c68ec5":"from sklearn.metrics import roc_auc_score\ntest_Y = np.argmax(test_Y, axis=-1)\ny_pred = np.argmax(y_pred, axis=-1)\nfpr_roc, tpr_roc, thresholds_roc = roc_curve(test_Y, y_pred)\nroc_auc = metrics.auc(fpr_roc, tpr_roc)","d2155654":"print('test binary accuracy = ',model.evaluate(test_X,test_Y, verbose=0)[1])","6d7adc4f":"from sklearn.metrics import plot_confusion_matrix\ntitles_options = [(\"Confusion matrix, without normalization\", None),\n                  (\"Normalized confusion matrix\", 'true')]\nfor title, normalize in titles_options:\n    disp = plot_confusion_matrix(model.fit(train_gen, valid_gen), X_test, y_test,\n                                 display_labels=labels,\n                                 cmap=plt.cm.Blues,\n                                 normalize=normalize)\n    disp.ax_.set_title(title)\n\n    print(title)\n    print(disp.confusion_matrix)\n\nplt.show()","18eaec6b":"test_X.shape\nsample_image = test_X[1]\nsample_image = sample_image.reshape((1, 256,256,3))\nx = inception.predict(sample_image)\ndef disease(arr):\n    for i in range(arr.size):\n        print(\"Disease:\",disease_name[i],\"Probability:\",arr[i])\n    \ndisease(x[0]) ","d26faeae":"test_X.shape","6c6e9ff4":"sample_image = test_X[0]\nsample_image = sample_image.reshape((1, 256,256,3))","7cf7a850":"x = model.predict(sample_image)","6579b6be":"x","d0c9a66e":"disease_name = [\"Atelectasis\",\"Cardiomegaly\",\"Effusion\",\"Infiltration\",\"Mass\",\"Nodule\",\"Pneumonia\",\"Pneumothorax\",\"Consolidation\",\"Edema\",\"Emphysema\",\"Fibrosis\",\"Pleural Thickening\",\"Hernia\"] ","2f55cd61":"def disease(arr):\n    for i in range(arr.size):\n        print(\"Disease:\",disease_name[i],\"Probability:\",arr[i])\n    \ndisease(x[0])  ","15f7f9d2":"import cv2\nimg = cv2.imread('..\/input\/data\/images_008\/images\/00016051_010.png')\nwidth = int(img.shape[1]*0.250)\nheight = int(img.shape[0]*0.250)\nsample_image2 = cv2.resize(img, (width, height), interpolation = cv2.INTER_AREA)\nprint(sample_image2.shape)","ad5c2ae8":"sample_image2 = sample_image2.reshape((1, 256, 256, 3))","77bcfc86":"model.predict(sample_image2)","53a57df5":"x","052a6410":"disease_name = [\"Atelectasis\",\"Cardiomegaly\",\"Effusion\",\"Infiltration\",\"Mass\",\"Nodule\",\"Pneumonia\",\"Pneumothorax\",\"Consolidation\",\"Edema\",\"Emphysema\",\"Fibrosis\",\"Pleural Thickening\",\"Hernia\"] ","d4dadb37":"def disease(arr):\n    max_val = arr[0]\n    for i in range(arr.size):\n        print(arr[i])\n        if arr[i] > max_val:\n            max_val = arr[i]\n            index = i\n    \n    print(\"Disease:\",disease_name[index],\"Probability:\",max_val)","4cfe050a":"disease(x[0])","63ca1f23":"# Prediction\nimport cv2\nimg = cv2.imread('..\/input\/data\/images_010\/images\/00020945_050.png')\nwidth = int(img.shape[1]*0.250)\nheight = int(img.shape[0]*0.250)\nsample_image2 = cv2.resize(img, (width, height), interpolation = cv2.INTER_AREA)\nprint(sample_image2.shape)\n\nsample_image2 = sample_image2.reshape((1, 256, 256, 3))\nx = model.predict(sample_image2)\n\nprint(x)\n\ndisease(x[0])","4a193195":"## Train model","d70a283e":"# From Here trying to predict roc auc score","e886b4e0":"## Create model","4d510c4e":"### Define DataGenerator","a238fb53":"## Data preprocessing","39ecf71d":"### Preprocessing Metadata","9287923c":"**Code for prediction**"}}