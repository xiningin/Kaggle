{"cell_type":{"645b9eb2":"code","672196e6":"code","1a696a94":"code","1aa71853":"code","1991215b":"code","f9c206a4":"code","214c172b":"code","2c848039":"code","db01e507":"code","5bc893e8":"code","6af0134a":"code","b6be1fc5":"code","d2974600":"code","c78a3fde":"code","6428cb61":"code","71e86c07":"code","2eb738b1":"code","079d666a":"code","8af3ce7a":"markdown","c878f140":"markdown","8b2119b3":"markdown","bd00ea06":"markdown","a0125550":"markdown","e6167bb0":"markdown","4ba5e4df":"markdown"},"source":{"645b9eb2":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","672196e6":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.interpolate import griddata\nfrom scipy.optimize import brentq\nfrom astropy import coordinates\nimport astropy.units as u\nfrom codecs import decode\nfrom astropy.cosmology import FlatLambdaCDM\nfrom astropy.io import ascii\nimport pandas as pd\nimport seaborn as sns\nimport glob","1a696a94":"qlf_df   = pd.read_csv('\/kaggle\/input\/halo-sims\/qlf_combined.csv')\nqlf_z_df = qlf_df[['z', 'refcode']]","1aa71853":"qlf_z_df.dropna(axis=1, how='all')\n","1991215b":"z = list(range(3,8))\n\ndef add_column( df, col = \"z\", vmin = 3.0, vmax = 4.0 ):\n    zid = \"{} < z < {}\".format(vmin, vmax)\n    flag = df[col].between( vmin, vmax )\n    df.loc[ flag, \"z_range\"] = zid\n\nfor zmin, zmax in zip( z[:-1], z[1:] ):\n    add_column(qlf_df, col=\"z\", vmin=zmin, vmax = zmax)","f9c206a4":"sortby_counts_qlf = qlf_z_df.groupby('refcode').count().sort_values(by='z')\nsortby_counts_qlf","214c172b":"f,ax = plt.subplots()\nax.hist([qlf_z_df[qlf_z_df['refcode'] == refcode]['z'].astype(float).values for refcode in sortby_counts_qlf.index], \n         stacked=True, \n         label = sortby_counts_qlf.index, \n         bins = z,\n         )\nax.set_yscale('log')\nax.legend()","2c848039":"class binned_volume:\n    def __init__(self, zmin, zmax, mag_limit, selfunc_file, cosmology = {\"H0\": 70.0, \"Om0\":0.3}):\n        self._zmin =zmin\n        self._zmax = zmax\n        self._mag_limit = mag_limit\n        self._cosmology = FlatLambdaCDM(H0=cosmology[\"H0\"], Om0=cosmology[\"Om0\"])\n        self._selfunc = np.loadtxt(selfunc_file)[:,1:]\n\n    def selection_function(self, z, M):\n        \"\"\"Interpolate the selection function for each quasras\n        Args: \n            z: redshift of the quasars\n            M: magnitude of the quasars\n        Return:\n            Interpolated values from the selfunc_file\n        \"\"\"\n        z_sf = self._selfunc[:,0]\n        m_sf = self._selfunc[:,1]\n        p_sf = self._selfunc[:,2]\n        \n        return griddata( list(zip(z_sf, m_sf)), p_sf, list(zip(z, M)) )\n    \n    def plot_selection_function(self,f, ax):\n        \"\"\"Plot the selection function of the survey\n        Return:\n            Plots on the selection function landscape\n        \"\"\"\n        z_sf = self._selfunc[:,0]\n        m_sf = self._selfunc[:,1]\n        p_sf = self._selfunc[:,2]\n        \n        z2d, m2d = np.meshgrid( np.unique(z_sf), np.unique(m_sf) )\n        p2d = griddata( list(zip(z_sf, m_sf)), p_sf, \n                       list(zip(z2d.flatten(), m2d.flatten() )) )\n        c = ax.pcolor(z2d, m2d, p2d.reshape( z2d.shape ) )\n        ax.set_xlabel(\"z\")\n        ax.set_ylabel(\"M1450\")\n        f.colorbar(c, ax=ax)\n        \n#         plt.show()\n        return ax\n                   \n    def search_NED_names(self, names, mode=\"Coordinates\"):\n        \"\"\"Look for the corresponding NED names from coordinates\n        Args: \n            names (list\/np.array): list of quasar names in coordinates\n        Return:\n            name identified by NED\n        \"\"\"\n        nednames = {}\n        for n in names:\n            try:\n                possible_names = query_sourcename(coord)\n                if len(possible_names) > 1:\n                    flag = (possible_names[\"Type\"] == b\"QSO\" )\n                    if flag.sum() > 1:\n                        print(possible_names[\"Type\"])\n                        nedname[coord] = possible_names[ flag][0]\n                else:\n                    nedname[coord] = possible_names[0]\n\n            except:\n                print(coord)\n                pass            \n        return nedname\n            \n    def query_sourcename(self,coord):\n        \"\"\"Query the source name based on coordinates\n        Args:\n            coord: coordinates of the objects in degress\n        Return:\n            sources: object that are closest that coordinates\n        \"\"\"\n        t = get_coord(coord)\n        t.sort([\"Separation\"])\n        pdt = t.to_pandas()\n        sources = pdt[pdt[\"Separation\"]<0.1]\n        sources = sources[\"Object Name\"].apply(decode).values\n\n        if len(sources) > 1:\n            return pdt[pdt[\"Separation\"]<0.1]\n\n        return sources\n\n    def estimate_distance_measure(self, zobs ):\n        dL = self._cosmology.luminosity_distance( zobs ).to(\"Mpc\").value\n        return -5.0*np.log10(dL)\n\n    def get_absolute_mag(self, zobs, iobs):\n        \"\"\"Calculate the absolute magnitudes, correcting for distance measures\n        Args:\n            zobs: observed redshift\n        Return:\n            Mi: absolute magnitudes in i-band\n        \"\"\"\n        DM_zobs = self.estimate_distance_measure(zobs)\n        Mi = iobs + DM_zobs - 25.0 #- Kcorr_z0\n        return Mi\n\n    def find_max_z_detectable(self, z, iobs=None, iabsmag = None ):\n        \"\"\"find the maximum detectable redshift, given the observed limit\n        Args:\n            z: quasar redshift\n            iobs: observed magnitudes\n            iabsmag: absolute magnitude\n        Return:\n            zmax_detectable\n            iabsmag\n        \"\"\"\n        mag_limit = self._mag_limit\n        if iabsmag == None:\n            iabsmag = self.get_absolute_mag(z, iobs)\n        zmax_detectable = brentq( lambda zmax: self.get_absolute_mag(zmax, mag_limit)- iabsmag,1.0,100.0)\n        return zmax_detectable, iabsmag\n\n\n    def effective_volume(self, zobs, iobs = None, irest = None, solid_angle = 2236. ):\n        \"\"\"calculate the detectable volume for a single quasar\n        Args: \n            zobs: observed redshift\n            iobs: observed band magnitude\n            irest: rest-frame band magnitude\n            solid_angle: angular area of the survey\n        Return:\n            dV: the detectable volume\n        \"\"\"\n        \n        zmin = self._zmin\n        zmax = self._zmax\n        imag_limit = self._mag_limit\n        cosmo = self._cosmology\n        \n        full_sky = 4.0*np.pi * (180. \/ np.pi)**2.\n        dV_zmin = cosmo.comoving_volume(zmin)\n\n        if iobs != None or irest != None:        \n            zmax_L, _ = self.find_max_z_detectable(zobs, iobs = iobs, iabsmag=irest)\n            if zmax > zmax_L:\n                zmax = zmax_L\n                if zmax < zobs:\n                    zmax = zobs\n        dV_zmax = cosmo.comoving_volume(zmax)\n        dV = dV_zmax - dV_zmin\n        dV = dV.to(\"Mpc^3\").value * solid_angle \/ full_sky \n\n        return dV\n    \n    def quasar_detectable_volume(self, solid_angle, redshift, iobs = None, irest = None ):\n        \"\"\"Calculate the quasara's detectable volume\n        Args:\n            redshift: the redshifts of the quasras\n            solid_angle: the survey angular square degree\n            iobs: the observed band magnitude\n            irest: the rest frame band magnitude\n        Returns:\n            Va: The volume of which the quasar is detectable\n        \"\"\"\n        Va = []\n        \n        if irest != None:\n            band_mag = irest\n            for z, m in zip(redshift, band_mag):\n                V = self.effective_volume(z, irest = m, solid_angle= solid_angle )\n                Va.append(V)\n        else:\n            band_mag = iobs\n            for z, m in zip(redshift, band_mag):\n                V = self.effective_volume(z, iobs = m, solid_angle= solid_angle )\n                Va.append(V)\n\n        return Va","db01e507":"qlf_df","5bc893e8":"willott10_selfunc = glob.glob(\"\/kaggle\/input\/halo-sims\/selection_function\/Data_new\/willot*sel.dat\")","6af0134a":"df = qlf_df[qlf_df['refcode'] == '2010AJ....139..906W']","b6be1fc5":"zmin = df[\"survey_zmin\"].values[0] \nzmax = df[\"survey_zmax\"].values[0]\nmaglimit = df[\"survey_maglimit\"].values[0]\nsurvey_area = df[\"survey_area\"].values[0]","d2974600":"bv = binned_volume(zmin, zmax, maglimit, willott10_selfunc[1], cosmology = {\"H0\": 70.0, \"Om0\":0.3})\nf, ax = plt.subplots()\nbv.plot_selection_function(f,ax)\nax.scatter( df[\"z\"], df[\"M1450\"], c='w' )","c78a3fde":"df_bhmass = pd.read_csv(\"\/kaggle\/input\/halo-sims\/final.csv\", index_col = 0)","6428cb61":"df_bhmass['Name'] = df_bhmass['name']","71e86c07":"mass_c = []\nfor c in df_bhmass.columns:\n    if \"log_bh\" in c and not c.endswith(\"_err\"):\n        mass_c.append(c)","2eb738b1":"class bh_mass_function:\n    def __init__(self, df_QLF, df_bhmass ):\n        self._QLF = df_QLF\n        self._bhmass = df_bhmass\n        self._merged_df = self._QLF.merge(self._bhmass, on=\"Name\")\n        self._unique_name = df_QLF[\"Name\"].unique()\n    \n    def calculate_volume(self, selfunc_file ):\n        zmin = self._QLF[\"survey_zmin\"].values[0] \n        zmax = self._QLF[\"survey_zmax\"].values[0]\n        maglimit = self._QLF[\"survey_maglimit\"].values[0]\n        survey_area = self._QLF[\"survey_area\"].values[0]\n        self.bv = binned_volume(zmin, zmax, maglimit, selfunc_file, cosmology = {\"H0\": 70.0, \"Om0\":0.3})\n        \n        Va = bv.quasar_detectable_volume( survey_area, self._merged_df[\"z_x\"], \n                                          self._merged_df[\"zmag\"])\n        self._merged_df[\"Va\"] = Va * self._merged_df[\"survey_fsc\"]\n    \n    \n    def get_average_nan( row ):\n        row = row[mass_c]\n        sel_crit = np.logical_and( ~row.isna(), row > 0 )\n        return row[sel_crit].mean() \n    \n    def get_mass_average(self):\n        bhmass = []\n        dV = []\n\n        for n in self._unique_name:\n            sel_crit = (self._merged_df[\"Name\"] == n)\n            temp = self._merged_df[sel_crit][mass_c].dropna(how='all', axis=1)\n            # avoid averaging entries with padding zeros\n            meanM = temp[temp>0].mean().mean()\n            bhmass.append(meanM)\n            dV.append( self._merged_df[sel_crit][\"Va\"].mean() )\n        \n        print( \"nobjects: {} \/ {}\".format( (~np.isnan(bhmass)).sum(), len(bhmass) ))\n        return np.array(bhmass), np.array(dV)\n    \n\nbins = np.logspace(9,12, 7)\ndef calculate_volume_density( bhmass, invV, bin_edge = bins):\n    \n    phi, _ = np.histogram( bhmass, weights=invV, bins = bin_edge)\n    phi_err, _ = np.histogram( bhmass, weights= invV**2.0, bins = bin_edge )\n    \n    bin_center = 0.5*(_[1:] + _[:-1])\n    \n    dbin = bin_edge[1:] - bin_edge[:-1]\n    return bin_center, phi \/ dbin, np.sqrt(phi_err) \/ dbin","079d666a":"mass_bin = np.linspace(7.0, 12., 11)\n\n\nbhmfunc = bh_mass_function(df, df_bhmass  )\nbhmfunc.calculate_volume( willott10_selfunc[1] )\n\nbhmass, dV = bhmfunc.get_mass_average()\n\ninvV = 1.0 \/ dV\nflag = np.isfinite(invV)\nbc, phi, phi_err =  calculate_volume_density( bhmass[flag], invV[flag], bin_edge=mass_bin )\n\n\nf, ax = plt.subplots(figsize=(10,10))\nax.errorbar( bc, phi, yerr=phi_err, marker ='.' , label= \"z = {} - {}\".format(zmin, zmax) )\nax.set_ylim(1.0e-13, 1.0e-5)\nax.set_yscale(\"log\")\nax.set_ylabel(r\"$\\frac{dN}{ dV dm}$\")\nax.set_xlabel(\"Log ($M_{BH}$)\")\nax.legend()","8af3ce7a":"# Quasar Luminosity Function Data Distribution","c878f140":"# Load the According Selection Function","8b2119b3":"# Calculate the detectable volume based on Cosmology and selection function","bd00ea06":"# Define Handy Function to calculate Black hole mass function","a0125550":"# Load the Blackhole mass measurements","e6167bb0":"# Import the QLF data","4ba5e4df":"# Import Libraries"}}