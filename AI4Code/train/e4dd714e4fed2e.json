{"cell_type":{"31e588d4":"code","e7685ba5":"code","9f1145b0":"code","43c63fff":"code","70901e90":"code","e9a548ee":"code","65c8a610":"code","ce5d7778":"code","fdd20728":"code","be6950ca":"code","7ced1771":"code","35ba895c":"code","0390bfd1":"code","cee26758":"code","3f548371":"code","4d52989b":"code","1ac6bda5":"code","c8f832ee":"markdown","26796662":"markdown","5d40b528":"markdown","2b7fdbca":"markdown","7411e512":"markdown","f8262333":"markdown","64c8cdd3":"markdown","a9f0466b":"markdown","0f4cc1a0":"markdown","35b8a11b":"markdown"},"source":{"31e588d4":"!pip install -q d2l","e7685ba5":"import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport math\nimport os\n\n%matplotlib inline\nfrom d2l import mxnet as d2l\nimport mxnet as mx\nfrom mxnet import autograd, gluon, image, init, nd, npx\nfrom mxnet.gluon import nn\nfrom mxnet.io import DataBatch\nimport matplotlib.pyplot as plt\n\nnpx.set_np()","9f1145b0":"base_path = '..\/input\/bananas-bounding-boxes\/bananas\/'\nedge_size = 256\nbatch_size = 32\nshuffle = True\nrand_crop = 0.5","43c63fff":"class BananasDataset():\n    def __init__(self, edge_size, batch_size, shuffle, rand_crop):\n        path_imgrec = os.path.join(base_path, 'train.rec')\n        path_imgidx = os.path.join(base_path, 'train.idx')\n        edge_size = edge_size\n        total_length = 998\n        self.length = math.ceil(total_length \/ batch_size)\n        self.iter = image.ImageDetIter(path_imgrec=path_imgrec, path_imgidx=path_imgidx, batch_size=batch_size, data_shape=(3, edge_size, edge_size), shuffle=shuffle, rand_crop=rand_crop)\n        \n    def next(self):\n        batch = self.iter.next()\n        return batch.data[0], batch.label[0]\n    \n    def __len__(self):\n        return self.length\n    \n    def reset(self):\n        self.iter.reset()","70901e90":"bananas_ds = BananasDataset(edge_size, 32, shuffle, rand_crop)","e9a548ee":"datas, labels = bananas_ds.next()\nimg = datas[0].asnumpy().astype(np.int32)\nimg = np.moveaxis(img, 0, 2)\nplt.imshow(img)","65c8a610":"class TinySSD(nn.Block):\n    def bbox_predictor(self, num_anchors):\n        '''\n            Bounding Box Prediction Layer using number of anchors\n        '''\n        return nn.Conv2D(num_anchors * 4, kernel_size=3, padding=1)\n    \n    def cls_predictor(self, num_anchors, num_classes):\n        '''\n            Categorical Prediction Layer using number of anchors and number of classes\n        '''\n        return nn.Conv2D(num_anchors * (num_classes + 1), kernel_size=3,\n                         padding=1)\n\n    \n    def down_sample_blk(self, num_channels):\n        '''\n            Reduces the height and width by 50%\n        '''\n        blk = nn.Sequential()\n        for _ in range(2):\n            blk.add(nn.Conv2D(num_channels, kernel_size=3, padding=1),\n                    nn.BatchNorm(in_channels=num_channels),\n                    nn.Activation('relu'))\n        blk.add(nn.MaxPool2D(2))\n        return blk\n    \n    def base_net(self):\n        '''\n            Base network block is used to extract features from original images\n            Doubles the number of channels at each step\n        '''\n        blk = nn.Sequential()\n        for num_filters in [16, 32, 64]:\n            blk.add(self.down_sample_blk(num_filters))\n        return blk\n    \n    def get_blk(self, i):\n        '''\n            SDD model contains a total of five modules:\n            1) Base Network block\n            2-4) Height and Width downsample blocks\n            5) Global Maximum pooling layer to reduce height and width to 1\n        '''\n        if i == 0: return self.base_net()\n        elif i == 4: return nn.GlobalMaxPool2D()\n        else: return self.down_sample_blk(128)\n    \n    def __init__(self, num_classes, **kwargs):\n        super(TinySSD, self).__init__(**kwargs)\n        self.num_classes = num_classes\n        \n        self.sizes = [[0.2, 0.272], [0.37, 0.447], [0.54, 0.619], [0.71, 0.79],\n                     [0.88, 0.961]]\n        self.ratios = [[1, 2, 0.5]] * 5\n        num_anchors = len(self.sizes[0]) + len(self.ratios[0]) - 1\n\n        for i in range(5):\n            # The assignment statement is self.blk_i = get_blk(i)\n            setattr(self, f'blk_{i}', self.get_blk(i))\n            setattr(self, f'cls_{i}', self.cls_predictor(num_anchors, num_classes))\n            setattr(self, f'bbox_{i}', self.bbox_predictor(num_anchors))\n            \n    def flatten_pred(self, pred):\n        return npx.batch_flatten(pred.transpose(0, 2, 3, 1))\n\n    def concat_preds(self, preds):\n        return np.concatenate([self.flatten_pred(p) for p in preds], axis=1)   \n    \n    \n    def blk_forward(self, X, blk, size, ratio, cls_predictor, bbox_predictor):\n        Y = blk(X)\n        anchors = npx.multibox_prior(Y, sizes=size, ratios=ratio)\n        cls_preds = cls_predictor(Y)\n        bbox_preds = bbox_predictor(Y)\n        return (Y, anchors, cls_preds, bbox_preds)\n\n    def forward(self, X):\n        anchors, cls_preds, bbox_preds = [None] * 5, [None] * 5, [None] * 5\n        for i in range(5):\n            # getattr(self, 'blk_%d' % i) accesses self.blk_i\n            X, anchors[i], cls_preds[i], bbox_preds[i] = self.blk_forward(\n                X, getattr(self, f'blk_{i}'), self.sizes[i], self.ratios[i],\n                getattr(self, f'cls_{i}'), getattr(self, f'bbox_{i}'))\n        # In the reshape function, 0 indicates that the batch size remains\n        # unchanged\n        anchors = np.concatenate(anchors, axis=1)\n        cls_preds = self.concat_preds(cls_preds)\n        cls_preds = cls_preds.reshape(\n            cls_preds.shape[0], -1, self.num_classes + 1)\n        bbox_preds = self.concat_preds(bbox_preds)\n        return anchors, cls_preds, bbox_preds","ce5d7778":"device, net = d2l.try_gpu(), TinySSD(num_classes=1)\nnet.initialize(init=init.Xavier(), ctx=device)\nnpx.set_np()","fdd20728":"cls_loss = gluon.loss.SoftmaxCrossEntropyLoss()\nbbox_loss = gluon.loss.L1Loss()\n\ndef calc_loss(cls_preds, cls_labels, bbox_preds, bbox_labels, bbox_masks):\n    '''\n        Calculate:\n            - classification loss by using Softmax\n            - Bounding Boxes position by using Mean Squared Error\n    '''\n    cls = cls_loss(cls_preds, cls_labels)\n    bbox = bbox_loss(bbox_preds * bbox_masks, bbox_labels * bbox_masks)\n    return cls + bbox","be6950ca":"def cls_eval(cls_preds, cls_labels):\n    '''\n        Category prediction results are placed in the final\n        dimension, argmax must specify this dimension\n    '''\n    return float((cls_preds.argmax(axis=-1).astype(\n        cls_labels.dtype) == cls_labels).sum())\n\ndef bbox_eval(bbox_preds, bbox_labels, bbox_masks):\n    return float((np.abs((bbox_labels - bbox_preds) * bbox_masks)).sum())","7ced1771":"trainer = gluon.Trainer(net.collect_params(), 'sgd',\n                        {'learning_rate': 0.2, 'wd': 5e-4})","35ba895c":"num_epochs, timer = 20, d2l.Timer()\nanimator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs],\n                        legend=['class error', 'bbox mae'])\n\n\nfor epoch in range(num_epochs):\n    metric = d2l.Accumulator(4)\n    \n    # reset dataset\n    bananas_ds.reset()\n    \n    for i in range(len(bananas_ds)):\n        X, y = bananas_ds.next()\n        \n        # to device\n        X, y = X.as_in_ctx(device), y.as_in_ctx(device)\n        timer.start()\n        \n        with autograd.record():\n            # forward propagation\n            anchors, cls_preds, bbox_preds = net(X)\n            \n            # label category and offset of each box\n            bbox_labels, bbox_masks, cls_labels = npx.multibox_target(\n                anchors, y, cls_preds.transpose(0, 2, 1))\n            \n            # calculate the loss function\n            l = calc_loss(cls_preds, cls_labels, bbox_preds, bbox_labels,\n                          bbox_masks)\n        \n        l.backward()\n        trainer.step(batch_size)\n        metric.add(cls_eval(cls_preds, cls_labels), cls_labels.size,\n                   bbox_eval(bbox_preds, bbox_labels, bbox_masks),\n                   bbox_labels.size)\n        \n    cls_err, bbox_mae = 1-metric[0]\/metric[1], metric[2]\/metric[3]\n    animator.add(epoch+1, (cls_err, bbox_mae))","0390bfd1":"def predict(X):\n    anchors, cls_preds, bbox_preds = net(X.as_in_ctx(device))\n    cls_probs = npx.softmax(cls_preds).transpose(0, 2, 1)\n    output = npx.multibox_detection(cls_probs, bbox_preds, anchors)\n    idx = [i for i, row in enumerate(output[0]) if row[0] != -1]\n    return output[0, idx]","cee26758":"def display(img, output, threshold):\n    img = img.asnumpy().astype(np.int32)\n    img = np.moveaxis(img, 0, 2)\n\n    d2l.set_figsize((5, 5))\n    fig = d2l.plt.imshow(img)\n    score = float(output[1])\n    if score > threshold:\n        h, w = img.shape[0:2]\n        bbox = nd.array([(output[2:6].asnumpy() * np.array((w, h, w, h))).astype(np.int32)])\n        d2l.show_bboxes(fig.axes, bbox, '%.2f' % score, 'w')","3f548371":"bananas_ds.reset()\ndatas, _ = bananas_ds.next()","4d52989b":"output = predict(X)\nprint(output[0])","1ac6bda5":"display(datas[1], output[1], 0.5)","c8f832ee":"# Conclusion","26796662":"# Loss and Evaluate functions","5d40b528":"# Architecture","2b7fdbca":"# Single Shot Multibox Detection (SSD)","7411e512":"# Dataset","f8262333":"In order to get a better Banana detection, you have to play with the parameters such as learning_rate, batch_size.\n\nFull credits go for [deep 2 learn](https:\/\/d2l.ai\/chapter_computer-vision\/ssd.html) to build the dataset and the tutorial.","64c8cdd3":"# SSD Model","a9f0466b":"# Training","0f4cc1a0":"# Prediction","35b8a11b":"![ssd.svg](attachment:ssd.svg)"}}