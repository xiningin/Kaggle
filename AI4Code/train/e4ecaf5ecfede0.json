{"cell_type":{"3614d04f":"code","df0852df":"code","e8af4e0e":"code","aeead458":"code","10ff397b":"code","3a105962":"code","95c15817":"code","e157ab06":"code","73459e39":"markdown"},"source":{"3614d04f":"import numpy as np # linear algebra\nimport os # accessing directory structure\n\nimport pydicom #for loading dicom\nimport scipy.ndimage","df0852df":"# A helper funtion for loading dicom scans as nump arrays\ndef load_dicom(path2scan_dir):\n    dicom_folder = path2scan_dir\n    dcms = os.listdir(dicom_folder)\n    first_slice_data = pydicom.read_file(os.path.join(path2scan_dir,dcms[0]))\n    first_slice = first_slice_data.pixel_array\n    orientation = np.transpose(first_slice_data.ImageOrientationPatient) #zyx format\n    spacing_xy = np.array(first_slice_data.PixelSpacing, dtype=float)\n    spacing_z = np.float(first_slice_data.SliceThickness)\n    spacing = np.array([spacing_z, spacing_xy[1], spacing_xy[0]]) #zyx format\n\n    scan = np.zeros((len(dcms),first_slice.shape[0],first_slice.shape[1]))\n    raw_slices=[]\n    indexes = []\n    for dcm in dcms:\n        slice_data = pydicom.read_file(os.path.join(dicom_folder,dcm))\n        slice_data.filename = dcm\n        raw_slices.append(slice_data)\n        indexes.append(float(slice_data.ImagePositionPatient[2]))\n    indexes = np.array(indexes,dtype=float)\n\n    raw_slices = [x for _, x in sorted(zip(indexes, raw_slices))]\n    origin = np.array(raw_slices[0][0x00200032].value) #origin is assumed to be the image location of the first slice\n    if origin is None:\n        origin = np.zeros(3)\n    else:\n        origin = np.array([origin[2],origin[1],origin[0]]) #change from x,y,z to z,y,x\n\n    for i, slice in enumerate(raw_slices):\n        scan[i, :, :] = slice.pixel_array\n    return scan, spacing, orientation, origin, raw_slices","e8af4e0e":"# Let's load one of the scans from Experiment 1\nscan_uuid = 8038\nscan, spacing, orientation, origin, raw_slices = load_dicom('\/kaggle\/input\/CT_Scans\/EXP1_blind\/'+str(scan_uuid))\n\nprint('The CT scan has the dimensions of',scan.shape,'  (z,y,x)')","aeead458":"# Now lets plot a few slices\nfrom matplotlib import pyplot as plt\n\n# Show a few slices along the body\nfor slice_indx in range(50,100,10):\n    plt.imshow(scan[slice_indx,:,:],cmap='bone',vmin=-1000,vmax=2000)\n    plt.show()","10ff397b":"#import the labels for Experiment 1\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\nexp1_labels = pd.read_csv('\/kaggle\/input\/labels_exp1.csv')","3a105962":"#find the regions of interest in our scan \nlocations = exp1_labels.loc[exp1_labels['uuid']==scan_uuid]\nlocations\n#Note that this location is 'FM' (False Malign) so it's an injected cancer\"","95c15817":"# Let's cut a small cube out of this scan containing this fake cancer\n\n# Here is the helper function\ndef cutCube(X, center, shape, padd=0): #center is a 3d coord (zyx)\n    center = center.astype(int)\n    hlz = np.round(shape[0] \/ 2)\n    hly = np.round(shape[1] \/ 2)\n    hlx = np.round(shape[2] \/ 2)\n\n    #add padding if out of bounds\n    if ((center - np.array([hlz,hly,hlx])) < 0).any() or (\n        (center + np.array([hlz,hly,hlx]) + 1) > np.array(X.shape)).any():  # if cropping is out of bounds, add padding\n        Xn = np.ones(np.array(X.shape) + shape * 2) * padd\n        Xn[shape[0]:(shape[0] + X.shape[0]), shape[1]:(shape[1] + X.shape[1]), shape[2]:(shape[2] + X.shape[2])] = X\n        centern = center + shape\n        cube = Xn[int(centern[0] - hlz):int(centern[0] - hlz + shape[0]),\n               int(centern[1] - hly):int(centern[1] - hly + shape[1]),\n               int(centern[2] - hlx):int(centern[2] - hlx + shape[2])]\n        return np.copy(cube)\n    else:\n        cube = X[int(center[0] - hlz):int(center[0] - hlz + shape[0]), int(center[1] - hly):int(center[1] - hly + shape[1]),\n               int(center[2] - hlx):int(center[2] - hlx + shape[2])]\n        return np.copy(cube)","e157ab06":"#Here are the regions of interest:\ncut_cubes = []\nfor i in range(len(locations)):\n    location = locations.iloc[i]\n    coord = np.array([location['slice'],location['y'],location['x']])\n    cut_cubes.append(cutCube(scan,coord,(64,64,64)))\n\n#disply the slices of each cut cube:\nfor cube in cut_cubes:\n    plt.figure(num=None, figsize=(10, 10), dpi=200)\n    for i in range(64):\n        plt.subplot(8,8,i+1)\n        plt.axis('off')\n        plt.tight_layout()\n        plt.imshow(cube[i,:,:],cmap='bone')\n    plt.show()","73459e39":"## Introduction\nIn this short notebook we will:\n1. Load a CT scan as a numpy array\n2. Plot a few of its slices\n3. Use the labels to find the location of a deepfake cancer in the scan\n4. Cut out a cube around the cancer and plot its slices"}}