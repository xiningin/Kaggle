{"cell_type":{"5029a7c2":"code","a6b3f9c5":"code","ce0fef0d":"code","23b75b45":"code","8d9dc47d":"code","1ec87d84":"markdown","0861525c":"markdown","c9fb9e9b":"markdown","5bab45e5":"markdown","6f23a3ec":"markdown","fa888286":"markdown","b95b5f29":"markdown","c4dbc117":"markdown","8eae78ab":"markdown"},"source":{"5029a7c2":"def f(*x, **y):\n\n    def s1(x):\n        s = 0\n        for i in x:\n            s = s + i\n        return s\n\n    def p1(x):\n        s = 1\n        if x:\n            for i in x:\n                s = s * i\n        return s\n    \n    def r1(x):\n        s = 0\n        rec = list(map(lambda x : 1\/x, x))\n        if rec:\n            for i in rec:\n                s = s + i\n        return s\n    \n    if y[\"action\"] == \"sum\":\n        return s1(*x)\n    elif y[\"action\"] == \"prod\":\n        return p1(*x)\n    elif y[\"action\"] == \"reciprocal sum\":       #This is the only required addition to the code.\n        return r1(*x)\n    else:\n        return f\"bad argument: {y}\"\n\n\nxlst = [1,2,3,4,5]\n\nprint(f(xlst, action = \"sum\"))\nprint(f(xlst, action = \"prod\"))\nprint(f(xlst, action = \"reciprocal sum\"))","a6b3f9c5":"def f(*x, **y):\n    \n    def s1(x):\n        s = 0\n        if x:\n            for i in x:\n                s += i\n        return s\n    \n    def p1(x):\n        p = 1\n        if x:\n            for i in x:\n                p *= i\n        return p\n    \n    # Adding function to add reciprocals of each number in list\n    def reciprocal(x):\n        rec_sum = 0\n        \n        # Inline lambda function to convert to reciprocals\n        reciprocal = list(map(lambda a:1\/a , x))\n        \n        if x:\n            for i in reciprocal:\n                rec_sums += i\n        return rec_sum\n        \n    if y[\"action\"] == \"sum\":\n        return s1(*x)\n    elif y[\"action\"] == \"prod\":\n        return p1(*x)\n    elif y[\"action\"] == \"reciprocal_sum\":\n        return reciprocal(*x)\n    else:\n        return f\"bad argument: {y}\"\n    \nif __name__ == '__main__':\n    import argparse\n    \n    parser = argparse.ArgumentParser()\n    parser.add_argument('-lst', '--List', nargs='+', type = int, default = [1], help= \"List of numbers\")\n    parser.add_argument('--op', help = \"Enter operator:\")\n    \n    args = parser.parse_args()\n    \n    print(f(args.List, action = args.op))","ce0fef0d":"class co_mul:\n    def __init__(self, re=0, im=0):\n        self.re = re\n        self.im = im\n\n    def get_re(self):\n        return self.re\n\n    def get_im(self):\n        return self.im\n\n    def __str__(self):\n        g = lambda x:\"+\" if x >= 0 else \"\"\n        return f\"({self.re}{g(self.im)}{self.im}i)\"\n    \n    \n    # The formula for complex multiplication is:\n    # (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\n    def __mul__(self, other):\n        new_re = (self.get_re() * other.get_re()) - (self.get_im() * other.get_im())       # ac - bd\n        new_im = (self.get_re() * other.get_im()) + (self.get_im() * other.get_re())       # ad + bc\n        return co_mul(new_re, new_im)\n\nif __name__ == '__main__':\n\n    w = co_mul(1,-3)     #Introducing first complex number.\n    x = co_mul(-1,3)     #Introducing second complex number.\n    y = co_mul(1,3)      #Introducing third complex number.\n    z = co_mul(-1,-3)    #introducing fourth complex number.\n    \n    answer = w * x * y * z   #Performing complex multiplication.\n    print(\"The complex multiplication of {}, {}, {}, and {} is: {}\".format(w,x,y,z,answer))\n    ","23b75b45":"import random as rn\nimport time\nimport matplotlib.pyplot as plt\n\nrun = time.time()\n\ndata = [rn.randint(0,200) for x in range(1000)]           # Creating a list of random numbers\n#print(data)\n\n#For Average 1\ntime_record_1 = []         # List to store the run time of each iteration of average1(S)\ninputs_1 = []              # List to store the input size of each iteration of average1(S)\nsub_data_1 = []            # List of specific amount of numbers taken from 'data'\n\ndef average1(S):\n    #S:sequence\n    n = len(S)\n    my_average = [0] * n\n    for j in range(n):\n        total = 0\n        for i in range(j + 1):\n            total += S[i]\n        my_average[j] = total \/ (j+1)\n    return my_average\n\nfor x in data:\n    sub_data_1.append(x)                   # Appending values from 'data' to sub_data_1.\n    start = time.time()                    # Recording start time.\n    average1(sub_data_1)                   # Running the algorithm.\n    run_time = time.time() - start         # Calculating run time of the algorithm.\n    time_record_1.append(run_time)         # Appending the run time to the time records.\n    inputs_1.append(len(sub_data_1))       # Appending input length to the input records.\n\n    \n    \n#For Average 2\ntime_record_2 = []         # List to store the run time of each iteration of average2(S)\ninputs_2 = []              # List to store the input size of each iteration of average2(S)\nsub_data_2 = []            # List of specific amount of numbers taken from 'data'\n\ndef average2(S):\n    #S:sequence\n    n = len(S)\n    my_average= [0] * n\n    for j in range(n):\n        my_average[j] = sum(S[0:j+1]) \/ (j+1)\n    return my_average\n\nfor x in data:\n    sub_data_2.append(x)                   # Appending values from 'data' to sub_data_2.\n    start = time.time()                    # Recording start time.\n    average1(sub_data_2)                   # Running the algorithm.\n    run_time = time.time() - start         # Calculating run time of the algorithm.\n    time_record_2.append(run_time)         # Appending the run time to the time records.\n    inputs_2.append(len(sub_data_2))       # Appending input length to the input records.\n    \n    \n\n#For Average 3\ntime_record_3 = []         # List to store the run time of each iteration of average3(S)\ninputs_3 = []              # List to store the input size of each iteration of average3(S)\nsub_data_3 = []            # List of specific amount of numbers taken from 'data'\n\ndef average3(S):\n    #S:sequence\n    n = len(S)\n    my_average = [0] * n\n    total = 0\n    for j in range(n):\n        total += S[j]\n        my_average[j] = total \/ (j+1)\n    return my_average\n\nfor x in data:\n    sub_data_3.append(x)                   # Appending values from 'data' to sub_data_3.\n    start = time.time()                    # Recording start time.\n    average1(sub_data_3)                   # Running the algorithm.\n    run_time = time.time() - start         # Calculating run time of the algorithm.\n    time_record_3.append(run_time)         # Appending the run time to the time records.\n    inputs_3.append(len(sub_data_3))       # Appending input length to the input records.\n\n    \n# Plotting the graphs for run time as a function of input size of the given algorithms.\nfig = plt.figure()\nplot = fig.add_subplot(1,1,1)\n\nplt.loglog(inputs_1,time_record_1)          # Plotting log graph of running time as a function of input size for average1(S)\nplt.loglog(inputs_2,time_record_2)          # Plotting log graph of running time as a function of input size for average2(S)\nplt.loglog(inputs_2,time_record_3)          # Plotting log graph of running time as a function of input size for average3(S)\n\nplt.xlabel(\"No. of elements\")\nplt.ylabel(\"Time required\")\nplt.legend([\"Average 1\", \"Average 2\", \"Average 3\"])\n\nfinal = time.time() - run          # This the the total run time of the full program.\nprint(final)","8d9dc47d":"import random as rn\nimport time\n#import matplotlib.pyplot as plt\n\n\n\ntime_limit = 0                  # Run time limit for which the length of the string is to be determined.\nsteps = 0                       # Step size to increase the length of the testing sequence\nlength = 0                      # Starting length of sequence\nselect = 0                      # Selecting the algorithm 1, 2, or 3.\n\n\n#For Algorithm 1\ndef algorithm1(S):              # This is the algorithm we have to run.\n    #S:sequence\n    for j in range(len(S)):\n        for k in range(j+1, len(S)):\n            if S[j] == S[k]:\n                return False\n    return True\n\n#For Algorithm 2\ndef algorithm2(S):\n    #S:sequence\n    S = sorted(S)\n    for j in range(1, len(S)):\n        if S[j-1] == S[j]:\n            return False\n    return True\n\n#For Algorithm 3\ndef algorithm3(S, start, stop):\n    #slice S[start:stop], S:sequence\n    if stop - start <= 1: return True\n    elif not algorithm3(S, start, stop-1): return False\n    elif not algorithm3(S, start+1, stop): return False\n    else: return S[start] != S[stop-1]\n\n\n\n#We will be using recursion to determine the length of sequence evaluated in the given run time.\ndef speed(time_limit,steps,length,select):\n    run_time = 0\n    for x in range(100000000):\n        while run_time <= time_limit:                               # If the run time is less than the required limit, the more numbers will be added to the sequence.\n            data = rn.sample(range(100000000),x + length + steps)   # Creating a sequence that has non-repeating numbers.\n            \n            x = x + steps\n            \n            if select == 1:\n                start = time.time()                               # Recording the start time.\n                algorithm1(data)                                  # Running the algorithm.\n                run_time = time.time() - start                    # Calculating the algorithm run time.\n            \n            elif select == 2:\n                start = time.time()                               # Recording the start time.\n                algorithm2(data)                                  # Running the algorithm.\n                run_time = time.time() - start                    # Calculating the algorithm run time.\n            \n            elif select == 3:\n                start = time.time()                               # Recording the start time.\n                algorithm3(data,0,len(data))                      # Running the algorithm.\n                run_time = time.time() - start                    # Calculating the algorithm run time.\n                if (time_limit - 5) < run_time and run_time < (time_limit + 5):          \n                    break\n            \n            else:\n                print(\"Error: Select a valid algorithm\")\n            x = x + steps                                         # The number of numbers equals to 'steps', if the run time is less than the required limit.\n            \n        \n        # Getting the run time to be exactly 45 seconds might take a long time\n        # So we have given a tolerance of 0.3 seconds on each side. If the run time falls in this range, then we will print the length and run time.\n        if (time_limit - 0.3) < run_time and run_time < (time_limit + 0.3):          \n            print(\"Algorithm {} can evaluate a sequence having {} numbers in {} seconds.\".format(select,len(data),run_time))\n            break\n            \n        # If the run time is greater than the required limit, we will reduce the number of elements in the sequence by the size 'steps'.\n        # Then we will run it again with the new reduced sequence length and the step size will be reduce by 50 times. \n        else:\n            nxt = len(data) - steps\n            if select == 1:\n                return speed(time_limit,steps\/\/50,nxt,select)\n            \n            if select == 2:\n                return speed(time_limit,steps\/\/5,nxt,select)\n            \n            if select == 3:\n                if (time_limit - 5) < run_time and run_time < (time_limit + 5):          \n                    print(\"Algorithm {} can evaluate a sequence having {} numbers in {} seconds.\".format(select,len(data),run_time))\n                    break\n                else:\n                    return speed(time_limit,max(1,steps\/\/2),nxt,select)\n            \n            \n\n#Setting the time_limit = 45 seconds, step size = 1000, starting length = 2 5000\nalgo1 = speed(45,1000,25000,1)\n\n#Setting the time_limit = 45 seconds, step size = 5000000, starting length = 20000000\nalgo2 = speed(45,5000000,21000000,2)\n\n#Setting the time_limit = 45 seconds, step size = 1, starting length = 26\nalgo3 = speed(45,1,26,3)","1ec87d84":"https:\/\/www.kaggle.com\/abhiravlande\/applied-algorithms-homework-3-by-adl","0861525c":"# **Question 2**","c9fb9e9b":"# **Question 3**","5bab45e5":"# **Question 1:** ","6f23a3ec":"# **Question 5**","fa888286":"# **Applied Algorithms Homework 3 by Abhirav Dhiren Lande**","b95b5f29":"The working of the code has been explained through comments for better understanding.\n**Note:** For algorithm 3, the run time for sequence with lengths 27 and 28 numbers was roughly 42.1 and 84.3 seconds respectively. Hence, we have set a tolerance of +- 5 seconds.","c4dbc117":"The working of the code has been explained through comments for better understanding.\n**Note:** For complex multiplication, we have used the formula: (a + bi) * (c + di) = (ac - bd) + (ad + bc)i.","8eae78ab":"# **Question 4**"}}