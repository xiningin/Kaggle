{"cell_type":{"753b9bda":"code","e4b62f26":"code","6b545252":"code","df737d01":"code","95469c6a":"code","ef75396f":"code","5c94a04f":"code","e8be02d0":"code","d33fdc99":"code","d4f8e9b0":"code","59e7a523":"code","d65f0a70":"code","9671b65c":"code","c1f5a0a0":"code","d9f89b39":"code","d5661158":"code","bde178a2":"code","ed6bf052":"code","19085acb":"code","e5d5de7e":"code","8c6261e6":"code","ff384f9a":"code","4ba170f7":"code","a854f36c":"code","37865289":"code","b9793c43":"code","fc1dbd8c":"markdown","26c6ee8d":"markdown","d41093ca":"markdown","387c17c4":"markdown","f3cb7747":"markdown","adcbb660":"markdown","41f3c8e8":"markdown","50b02e27":"markdown","8a4e68e4":"markdown","fe9481e7":"markdown","c77830e9":"markdown","af3798f5":"markdown","4f1a1b7d":"markdown","c80aa9f3":"markdown","2b4ce0de":"markdown","6f6fff01":"markdown","cff50db0":"markdown","b0f16126":"markdown","556439da":"markdown","9736277e":"markdown","0514d5dc":"markdown","56ffd09e":"markdown","7aba605d":"markdown","a98c8875":"markdown","4392b487":"markdown","0294b65c":"markdown","54c092de":"markdown","84b2477e":"markdown","a8cc96f4":"markdown","b8f1c406":"markdown","cc96599b":"markdown","b05fb26f":"markdown","df5974a7":"markdown","189ee305":"markdown","905c012b":"markdown","8121e93a":"markdown","f32660b9":"markdown","b993042a":"markdown","75f1a452":"markdown","0ce77ba8":"markdown","b39269c7":"markdown","622df956":"markdown","13b0739f":"markdown","8d6b94e5":"markdown","5886a15b":"markdown","83649c06":"markdown","d4cbc19c":"markdown"},"source":{"753b9bda":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport cufflinks as cf\nimport plotly.offline\n\ncf.go_offline()\ncf.set_config_file(offline=False, world_readable=True)\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.model_selection import GridSearchCV\n\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import accuracy_score\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.ensemble import AdaBoostClassifier\nfrom sklearn.ensemble import ExtraTreesClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\n\n\n\nimport warnings\nwarnings.filterwarnings('ignore')","e4b62f26":"df = pd.read_csv(\"..\/input\/iris\/Iris.csv\")","6b545252":"print(f\"Data has {df.shape[0]} instances and {df.shape[1] - 1} attributes.\")","df737d01":"df.head()","95469c6a":"df.describe().T","ef75396f":"df.Species.value_counts()","5c94a04f":"for i in df.drop(columns=[\"Species\", \"Id\"]).columns:\n    df[i].iplot(kind=\"box\", title=i, boxpoints=\"all\")","e8be02d0":"for i in df.drop(columns=[\"Species\", \"Id\"]).columns:\n    df[i].iplot(kind=\"hist\", title=i, bins=15)","d33fdc99":"plt.figure(dpi=200)\nsns.pairplot(df.drop(columns=\"Id\"), hue=\"Species\");","d4f8e9b0":"X = df.drop(columns=[\"Id\", \"Species\"])\ny = df.Species","59e7a523":"X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1845)","d65f0a70":"models = []\n\nmodels.append((\"LDA\", LinearDiscriminantAnalysis()))\nmodels.append((\"KNN\", KNeighborsClassifier()))\nmodels.append((\"DT\", DecisionTreeClassifier()))\nmodels.append((\"GB\", GaussianNB()))\nmodels.append((\"SVC\", SVC()))\n\n# evaluate each model in turn\n\nresults = []\nnames = []\n\nfor name, model in models:\n    kfold = StratifiedKFold(n_splits=10, random_state=0, shuffle=True)\n    cv_results = cross_val_score(model, X_train, y_train, cv=kfold, scoring=\"accuracy\")\n    \n    results.append(cv_results)\n    names.append(name)\n    \n    print(f\"{name}: {round(cv_results.mean(), 4)} ({round(cv_results.std(), 4)})\")","9671b65c":"results_df = pd.DataFrame(results, index=names).T\nresults_df","c1f5a0a0":"results_df.iplot(kind=\"box\", boxpoints=\"all\")","d9f89b39":"param_grid = dict(n_neighbors=[i for i in range(1, 22, 2)])\n\nmodel = KNeighborsClassifier()\nkfold = StratifiedKFold(n_splits=10, random_state=0, shuffle=True)\n\ngrid = GridSearchCV(estimator=model, param_grid=param_grid, scoring=\"accuracy\", cv=10)\ngrid_result = grid.fit(X_train, y_train)","d5661158":"print(f\"Best: {round(grid_result.best_score_, 6)} using {grid_result.best_params_}\") \nmeans = grid_result.cv_results_['mean_test_score']\nstds = grid_result.cv_results_['std_test_score']\nparams = grid_result.cv_results_['params']\nfor mean, stdev, param in zip(means, stds, params):\n    print(\"%f (%f) with: %r\" % (mean, stdev, param))","bde178a2":"ensembles = []\n\nensembles.append((\"AB\", AdaBoostClassifier()))\nensembles.append((\"GB\", GradientBoostingClassifier()))\nensembles.append((\"RF\", RandomForestClassifier()))\nensembles.append((\"ET\", ExtraTreesClassifier()))\n\n\nresults = []\nnames = []\n\nfor name, model in ensembles:\n    kfold = StratifiedKFold(n_splits=10, random_state=1845, shuffle=True)\n    cv_results = cross_val_score(model, X_train, y_train, cv=kfold, scoring=\"accuracy\")\n    \n    results.append(cv_results)\n    names.append(name)\n    \n    print(f\"{name}: {round(cv_results.mean(), 4)} ({round(cv_results.std(), 4)})\")","ed6bf052":"results_df = pd.DataFrame(results, index=names).T\nresults_df","19085acb":"results_df.iplot(kind=\"box\", boxpoints=\"all\")","e5d5de7e":"# Number of trees in random forest\nn_estimators = [200, 250, 300, 350, 400, 450, 500, 600]\n# Maximum number of levels in tree\nmax_depth = [10, 15, 20, 25, 30]\nmax_depth.append(None)\n# Create the random grid\nparam_grid = {'n_estimators': n_estimators,\n               'max_depth': max_depth}","8c6261e6":"model = RandomForestClassifier()\nkfold = StratifiedKFold(n_splits=10, random_state=1845, shuffle=True)\n\ngrid = GridSearchCV(estimator=model, param_grid=param_grid, scoring=\"accuracy\", cv=3, verbose=1)\ngrid_result = grid.fit(X_train, y_train)","ff384f9a":"print(f\"Best: {round(grid_result.best_score_, 6)} using {grid_result.best_params_}\") \n\nmeans = grid_result.cv_results_['mean_test_score']\nstds = grid_result.cv_results_['std_test_score']\nparams = grid_result.cv_results_['params']\n\nfor mean, stdev, param in zip(means, stds, params):\n    print(\"%f (%f) with: %r\" % (mean, stdev, param))","4ba170f7":"final_model = RandomForestClassifier(n_estimators=250, max_depth=30)\nfinal_model.fit(X_train, y_train)\n\ny_pred = final_model.predict(X_test)","a854f36c":"# Accuracy score\naccuracy_score(y_pred,y_test)","37865289":"print(confusion_matrix(y_test, y_pred))","b9793c43":"print(classification_report(y_test, y_pred))","fc1dbd8c":"## Class Distribution","26c6ee8d":"- We can see that all of the numerical values have the same scale (centimeters) and similar ranges between 0 and 8 centimeters.","d41093ca":"- We can probably do better, given that the ensemble techniques used the default parameters. Let's look at tuning the Random Forest to further lift the performance.","387c17c4":"# Summarize the Dataset","f3cb7747":"***","adcbb660":"# Data Visualization","41f3c8e8":"## Univariate Plots","50b02e27":"- We can see that each class has the same number of instances.","8a4e68e4":"#### We will start with some univariate plots, that is, plots of each individual variable. Given that the input variables are numeric, we can create box and whisker plots of each.","fe9481e7":"## Improve Resutls With Tuning","c77830e9":"- We can also plot the distribution of scores across the cross validation folds.","af3798f5":"## Improve Resutls With Tuning","4f1a1b7d":"## Create a Validation Dataset\n\n- We need to know whether or not the model that we created is any good. Later, we will use statistical methods to estimate the accuracy of the models that we create on unseen data. We also want a more concrete estimate of the accuracy of the best model on unseen data by evaluating it on actual unseen data. That is, we are going to hold back some data that the algorithms will not get to see and we will use this data to get a second and independent idea of how accurate the best model might actually be. We will split the loaded dataset into two, 80% of which we will use to train our models and 20% that we will hold back as a validation dataset.","c80aa9f3":"## Test Harness","2b4ce0de":"## Statistical Summary","6f6fff01":"- We will use 10-fold cross validation to estimate accuracy. This will split our dataset into 10 parts, train on 9 and test on 1 and repeat for all combinations of train-test splits. We are using the metric of accuracy to evaluate models. This is a ratio of the number of correctly predicted instances divided by the total number of instances in the dataset multiplied by 100 to give a percentage (e.g. 95% accurate). We will be using the scoring variable when we run build and evaluate each model next.","cff50db0":"- We now have 6 models and accuracy estimations for each. We need to compare the models to each other and select the most accurate. \n- We can see that it looks like Linear Discriminant Analysis has the largest estimated accuracy score. We can also create a plot of the model evaluation results and compare the spread and the mean accuracy of each model. There is a population of accuracy measures for each algorithm because each algorithm was evaluated 10 times (10 fold cross validation).","b0f16126":"#### Distribution of the target variable is one of the most important things in a classification problem.","556439da":"This is the end of the my first machine learning notebook. Huge credit to Jason Brownlee since the techniques I used was from his great book, Machine Learning Mastery with Python. I highly encourage people who are in the beginning of the Data Science journey to take a look at his great books. I am leaving a link where you can get information about his great sources.\n\nStay well.","9736277e":"- Seems like Iris-setosa will be the easiest to classify.\n- Iris-versicolor and Iris-virginica may be harder to classify since they both act same.","0514d5dc":"- It looks like Random Forest has a better mean score.","56ffd09e":"- Now it is time to create some models of the data and estimate their accuracy on unseen data. Here is what we are going to cover in this step:\n\n- Separate out a validation dataset.\n- Setup the test harness to use 10-fold cross validation.\n- Build 5 different models to predict species from flower measurements.\n- Select the best model.","7aba605d":"https:\/\/machinelearningmastery.com","a98c8875":"# Build Models","4392b487":"- You can see that the best for k (n neighbors) is 7 providing an accuracy of 0.97182, the best so far.","0294b65c":"- As we expected in EDA stage, our final model classified the Iris-setosa perfectly.\n- Our final model had some troubles classifying Iris-versicolor and Iris-virginica classes\n- Since our dataset is pretty small, 150 instances, our hold out validation test has just 45 instances.Our final model classified right 44 of those 45 instances which is pretty great score comparing with real world problems. Since this dataset aims to teach machine learning fundamentals to beginners, all 3 targets are pretty seperable.","54c092de":"## Base Models","84b2477e":"# Ensemble Methods","a8cc96f4":"We don\u2019t know which algorithms would be good on this problem or what configurations to use. We get an idea from the plots that some of the classes are partially linearly separable in some dimensions, so we are expecting generally good results. Let\u2019s evaluate six different algorithms:\n\n- Logistic Regression (LR).\n- Linear Discriminant Analysis (LDA).\n- k-Nearest Neighbors (KNN).\n- Classification and Regression Trees (CART). \udbff\udc00 Gaussian Naive Bayes (NB).\n- Support Vector Machines (SVM).\n\nThis list is a good mixture of simple linear (LR and LDA), nonlinear (KNN, CART, NB and SVM) algorithms. We reset the random number seed before each run to ensure that the evaluation of each algorithm is performed using exactly the same data splits. It ensures the results are directly comparable. Let\u2019s build and evaluate our five models:","b8f1c406":"Another way that we can improve the performance of algorithms on this problem is by using ensemble methods. In this section we will evaluate four different ensemble machine learning algorithms, two boosting and two bagging methods:\n\n\n- **Boosting Methods**: AdaBoost (AB) and Gradient Boosting (GBM).\n- **Bagging Methods**: Random Forests (RF) and Extra Trees (ET).","cc96599b":"## Dimesions of Dataset","b05fb26f":"***","df5974a7":"- We will use the same test harness as before, 10-fold cross validation.","189ee305":"- We are going use GaussianNB as our final model.","905c012b":"#### Take a look at a summary of each attribute. This includes the count, mean, the min and max values as well as some percentiles.","8121e93a":"- We know from the results in the previous section that KNN achieves good results. But can it do better? The default value for the number of neighbors in KNN is 5. We can use a grid search to try a set of different numbers of neighbors and see if we can improve the score. The below example tries odd k values from 1 to 21, an arbitrary range covering a known good value of 5. Each k value (n neighbors) is evaluated using 10-fold cross validation on the training dataset.","f32660b9":"# Import Libraries","b993042a":"The default number of boosting stages to perform (n estimators) is 100. This is a good candidate parameter of Random Forest to tune. Often, the larger the number of boosting stages, the better the performance but the longer the training time. In this section we will look at tuning the number of stages for Random Forest. We define a parameter grid n estimators values from 200 to 600. Each setting is evaluated using 3-fold cross validation.","75f1a452":"# Finalize Model","0ce77ba8":"#### We now have a basic idea about the data. We need to extend this with some visualizations. We are going to look at two types of plots:\n\n- Univariate plots to better understand each attribute.\n- Multivariate plots to better understand the relationships between attributes.","b39269c7":"- It looks like perhaps two of the input variables have a Gaussian distribution. This is useful to note as we can use algorithms that can exploit this assumption.","622df956":"# Evaluate Some Algorithms","13b0739f":"#### Now it is time to take a look at the data. In this step we are going to take a look at the data a few different ways;\n- Dimensions of the dataset.\n- Peek at the data itself.\n- Statistical summary of all attributes.\n- Breakdown of the data by the class variable.","8d6b94e5":"- We now have training data **X_train** and **y_train** for preparing models and a **X_test** and **y_test** sets that we can use later.","5886a15b":"- You can see that the box and whisker plots are squashed at the top of the range, with many samples achieving 100% accuracy.\n- LinearDiscriminantAnalysis performed best.\n- KNN is the runner-up in base models.","83649c06":"The Iris dataset was used in R.A. Fisher's classic 1936 paper, The Use of Multiple Measurements in Taxonomic Problems, and can also be found on the UCI Machine Learning Repository.\n\nIt includes three iris species with 50 samples each as well as some properties about each flower. One flower species is linearly separable from the other two, but the other two are not linearly separable from each other.\n\nThe columns in this dataset are:\n\n- Id\n- SepalLengthCm\n- SepalWidthCm\n- PetalLengthCm\n- PetalWidthCm\n- Species","d4cbc19c":"## Multivariate Plots"}}