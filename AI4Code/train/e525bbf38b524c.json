{"cell_type":{"70fcae1f":"code","445bbb13":"code","6f7c2346":"code","7b43c6fd":"code","23e6632a":"code","6131fb90":"code","2a8e0117":"code","e840e6ce":"markdown","033889c1":"markdown","1a4c367b":"markdown","9f9e338b":"markdown","c8ea0169":"markdown","14363103":"markdown"},"source":{"70fcae1f":"import cv2\nimport numpy as np\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nimport imutils\nimport zipfile","445bbb13":"#Load image and convert to grey.\nimg = cv2.imread('..\/input\/samples\/samples\/2cegf.png', 0)\nplt.imshow(img, 'gray')","6f7c2346":"# From RGB to BW\n# Adaptive thresholding\nth = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 17, 2)\n\n# Otsu thresholding\nret2, th2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n\n# Otsu thresholding with Gaussian Blur\nblur = cv2.GaussianBlur(img, (5, 5), 0)\nret3, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n\n#Plot\ntitles = ['Original', 'Adaptive', 'Otsu', 'Gaussian + Otsu']\nimages = [img, th, th2, th3]\nfor i in range(4):\n    plt.subplot(2, 2, i + 1), plt.imshow(images[i], 'gray')\n    plt.title(titles[i])\n    plt.xticks([]), plt.yticks([])\n\nplt.title('Threshold')\nplt.show()","7b43c6fd":"kernel = np.ones((3,3), np.uint8)\ndilation = cv2.dilate(th, kernel, iterations=1)\ndilation2 = cv2.dilate(th2, kernel, iterations=1)\ndilation3 = cv2.dilate(th3, kernel, iterations=1)\n\ntitles2 = ['Original', 'Adaptive', \"Otsu\", 'Gaussian + Otsu']\nimages2 = [img, dilation, dilation2, dilation3]\n\nfor i in range(4):\n    plt.subplot(2, 2, i + 1), plt.imshow(images2[i], 'gray')\n    plt.title(titles2[i])\n    plt.xticks([]), plt.yticks([])\n    \nplt.title('Dilation')\nplt.show()\n","23e6632a":"erosion = cv2.erode(dilation, kernel, iterations=1)\nerosion2 = cv2.erode(dilation2, kernel, iterations=1)\nerosion3 = cv2.erode(dilation3, kernel, iterations=1)\n\ntitles3 = ['Original', 'Adaptive', \"Otsu\", 'Gaussian + Otsu']\nimages3 = [img, erosion, erosion2, erosion3]\n\nfor i in range(4):\n    plt.subplot(2, 2, i + 1), plt.imshow(images3[i], 'gray')\n    plt.title(titles3[i])\n    plt.xticks([]), plt.yticks([])\n    \nplt.title('Erosion')\nplt.show()\n","6131fb90":"kernel = np.ones((3,1), np.uint8)\ndilation = cv2.dilate(erosion, kernel, iterations=1)\ndilation2 = cv2.dilate(erosion2, kernel, iterations=1)\ndilation3 = cv2.dilate(erosion3, kernel, iterations=1)\n\ntitles4 = ['Original', 'Adaptive', \"Otsu\", 'Gaussian + Otsu']\nimages4 = [img, dilation, dilation2, dilation3]\n\nfor i in range(4):\n    plt.subplot(2, 2, i + 1), plt.imshow(images4[i], 'gray')\n    plt.title(titles4[i])\n    plt.xticks([]), plt.yticks([])\n\nplt.title('Dilation')\nplt.show()\n","2a8e0117":"#Get the individual letters.\nx, y, w, h = 30, 12, 20, 38\nfor  i in range(5):\n    # get the bounding rect\n    cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)\n    cv2.rectangle(dilation, (x, y), (x + w, y + h), (0, 255, 0), 2)\n    cv2.rectangle(dilation2, (x, y), (x + w, y + h), (0, 255, 0), 2)\n    cv2.rectangle(dilation3, (x, y), (x + w, y + h), (0, 255, 0), 2)\n    x += w\n\ntitles3 = ['Original', 'Adaptive', \"Otsu\", 'Gaussian + Otsu']\nimages3 = [img, dilation, dilation2, dilation3] #img, opening, opening2, opening3]\n\nfor i in range(4):\n    plt.subplot(2, 2, i + 1), plt.imshow(images3[i], 'gray')\n    plt.title(titles3[i])\n    plt.xticks([]), plt.yticks([])\n\nplt.title('Contouring')\nplt.show()\n","e840e6ce":"Now we perform a last Morphological Transformations butthis time the kernel is 3x1 to reduce the height of the line.","033889c1":"There is no way to isolate the letters (by removing the line) without distoring the letters and making them irecognizable. Since the letter are always at the same place, we can simply extract them by hardcoding the coordinates.","1a4c367b":"Here we will take the image: a 5 letter word with some noise and remove the noise. We will attempt different methods and see which ones perform the best on the data. <br> Firstly, we will convert the image to black and white. We will use Thresholding to do so. Adaptive thresholding will determine when to set the image to black or white relative to the pixel's environment. That is usefull given the different shades of grey in the image. Otsu Thresholding will calculate a threshold value from the image histogram. We will also try applying a Blur to remove the noise on the image (the fading on the 4th letter).","9f9e338b":"Then we will try to remove the noise (the line that traverses the image). We will perform Erosions and Dilations (because it is black on white, erosion dilates and dilation erodes). These operation are Morphological Transformations: mathematical operations perfomed on the image's pixels. They will traverse the image with a matrix of nxm (3 by 3 in our case) and multiply the image with it and save the result.","c8ea0169":"## Data Processing","14363103":"# Table of Content\n\n1. [Introduction](#Introduction)\n2. [Imports](#Imports)\n3. [Data Processing](#Data-Processing)\n\n## Introduction\n\nThis notebook is an attempt at solving a CAPTCHA test.\n\n## Imports"}}