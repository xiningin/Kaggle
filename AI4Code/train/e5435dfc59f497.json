{"cell_type":{"bb7814b1":"code","ecbbe7dc":"code","6c191148":"code","3429247c":"code","1a5427f2":"code","2a883e09":"code","d41791e0":"code","5acb0324":"code","803c5bf1":"code","40447672":"code","4afb0ad4":"code","9e461e7e":"code","f1db5bd4":"code","f6b71ac4":"code","33522a58":"code","5890e6a4":"code","f8caf0b2":"code","c0cdc434":"code","0f25acbe":"code","3a45f6e8":"code","f47e8d77":"code","ee39888e":"code","3b03afd3":"code","5421c675":"code","0edd4a6e":"code","faa3acaf":"markdown","b6f3f882":"markdown","c85abb1b":"markdown","425aab4f":"markdown","be4c03b0":"markdown","bf5cc8e8":"markdown","1b8f4f59":"markdown","804c2f2b":"markdown","76d2f6a1":"markdown","fa597458":"markdown","ea02a164":"markdown","de865be1":"markdown","dc4279ac":"markdown","c58648e2":"markdown","04846115":"markdown","74f30ba9":"markdown","38717509":"markdown","e0f7733e":"markdown","86e3e41d":"markdown","05c64ce0":"markdown"},"source":{"bb7814b1":"import math\nimport numpy as np\nimport shapely.geometry as shg\nimport matplotlib.pyplot as plt\n","ecbbe7dc":"# some data\nimd = [35.2, 33.58, 41.1 ,7.4 ,33.6 ,61.9 ,37.4 ,31.1 ,42.9 ,3.4 ,55.6 ,21.5 ,27.4]\ndegree = [67, 8, 12, 24, 9, 16, 20, 19, 9, 73, 10, 103, 16]\npop = [187, 182, 180, 247, 211, 228, 228, 186, 178, 221, 225, 304, 233]\njobs = [85, 6, 17, 45, 15, 18, 26, 10, 18, 81, 16, 80, 27]\n","6c191148":"# Iteration Reminder\n\n# Iteration method 1 - using iterators\n\nfor d in degree:\n    print(d)\n    \n# Iteration Method 2 - using indexes\nfor i in range(len(degree)):\n    print (degree[i])\n    print(imd[i],jobs[i])\n    ","3429247c":"sum = 0\nfor value in pop:\n    sum = sum + value\n    print (sum, value)\n\nprint (\"total population is {}\".format(sum))","1a5427f2":"sum = 0\nfor value in pop:\n    sum = sum + value\n    print (sum, value)\n\nprint (sum)\nav = (sum \/ float(len(pop)))\nprint(\"Average population per SOA is {}\".format(av))","2a883e09":"# As a function convert the print to a \"return\"\ndef mean(values):\n    sum = 0\n    for value in values:\n        sum = sum + value\n    res = sum \/ float(len(values))\n    return res\n","d41791e0":"print(mean(imd))\nprint(mean(pop))\nprint(mean(degree))\nprint(mean(jobs))\n","5acb0324":"# write function here\n","803c5bf1":"# test result of your function against numpy standard deviation\nimport numpy as np\n\npop_np = np.array(pop)    #convert list into numpy array\npop_np.std(ddof=1)        #calculate stdev of a sample\n","40447672":"# write your function here","4afb0ad4":"# compare your results with numpy\nimport scipy.stats as stats         #import the stats package from scipy\nimd_np = np.array(imd)              #convert list to numpy array\nstats.skew(imd_np)                  #find the skew of the dataset imd\n","9e461e7e":"# write your function here\n# test correlations between the data sets","f1db5bd4":"# test using stats package\n#We can test it using the stats package again.\n\n# create numpy arrays for our data\nnpjobs = np.array(jobs)\nnpdeg = np.array(degree)\nnpimd = np.array(imd)\n\n\n# Positive correlation (> 0)\nx = stats.pearsonr(npdeg, npjobs) #name is pearsonr in stats package\nprint(x[0])\n# Negative correlation (<0)\ny = stats.pearsonr(npimd, npjobs) \nprint(y[0])","f6b71ac4":"# write your median function here","33522a58":"# test against numpy median function\nprint(np.median(pop_np)) #check it in numpy\npop2 = list(pop)  #copy the list\npop2.pop(12)      #remove the last item so we have 12\npop2_np = np.array(pop2)\nprint(np.median(pop2_np))\n","5890e6a4":"#Create some geometry as tuples \n\ngeom1 = [(1, 1), (1, 5), (5, 5), (5, 1)]\ngeom2 = [(1, 1), (2.5, 2.5), (3, 1)]\n\n#calculate the centroid\n#place this code in you file and run the script\n\ndef centroid(pts):\n    sumx = sumy = 0\n    for pt in pts:\n        x, y = pt\n        sumx = sumx + x\n        sumy = sumy + y\n    mx = sumx \/ float(len(pts))\n    my = sumy \/ float(len(pts))\n    return mx, my\n\nprint(centroid(geom1))\nprint(centroid(geom2))","f8caf0b2":"#calculate the centroid\nx1, y1 = centroid(geom1)\nx2, y2 = centroid(geom2)\n\n# MatPlotLib requires the values to be plotted to be lists so we need to convert them to lists.\n\n#Convert tuples to lists for plotting\nxy1 = list(zip(*geom1))\nxy2 = list(zip(*geom2))\n\n#convert centroids to lists for plotting\nmx = list([x1, x2])\nmy = list([y1, y2])\n\n#plot the outlines\n\nplt.plot(xy1[0], xy1[1], marker='o')\nplt.plot(xy2[0], xy2[1], marker='o')\n#plot the centroids\nplt.plot(mx, my, 'or')\n#set the axes\nplt.ylim([0, 10])\nplt.xlim([0, 10])\n#fill our shapes\nplt.fill(xy1[0], xy1[1],'b')\nplt.fill(xy2[0], xy2[1],'g')\n#add some labels\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\n\n#show the plot\nplt.show()\n","c0cdc434":"data = [(424779.449251638,565239.68078928), (424782.930069766,565235.780875993), (424792.450514798,565225.100934354), (424793.649592614,565226.199894994), (424796.199088166,565223.301153476), (424795.100127526,565222.19986453), (424797.100142758,565219.95072051), (424792.140850041,565215.450104161), (424785.300285721,565209.249824112), (424751.8495071,565246.849644808), (424753.099807659,565247.99982819), (424751.449038393,565249.750714632), (424741.050821833,565240.349013228), (424738.559533942,565243.149965875), (424733.800475579,565248.500414074), (424734.349955899,565249.000999959), (424744.49904367,565258.05112709), (424748.249945345,565261.399231751), (424749.700480257,565262.70075505), (424752.298870244,565265.001121813), (424754.480493377,565266.928959545), (424757.649318442,565269.739225418), (424768.399109275,565279.250357225), (424771.209375147,565276.109471837), (424773.449205942,565273.599557495), (424775.949807059,565270.800933154), (424762.350169144,565258.849736199), (424779.449251638,565239.68078928)]","0f25acbe":"x, y = centroid(data)\nmx = list([x])\nmy = list([y])\npltdata = list(zip(* data)) #convert points to list\nplt.plot(pltdata[0], pltdata[1], marker = 'o')\nplt.xlim([424700, 424820]) \t#set limits of x\nplt.ylim([565190, 565300]) #set limits of y\nplt.fill(pltdata[0], pltdata[1], color = 'lightblue')\nplt.plot(mx, my, 'or')\nplt.axis('equal') #make axis equal units\nplt.show\n","3a45f6e8":"poly = [(1,1),(5, 7),(10,1), (1,1)]\nx, y = list(zip(*poly))\nplt.plot(x,y)","f47e8d77":"# MBR code - smallest enclosing rectangle\n\ndef mbr(p):\n    #set min and max values - just need some valid value so use 1st coord\n    minx = p[0][0] #x coordinate of the 1st point\n    miny = p[0][1] #y coordinate of the 1st point\n    maxx = p[0][0]\n    maxy = p[0][1]\n    for coord in p:\n        x = coord[0]\n        y = coord[1]\n        if x > maxx:\n            maxx = x\n        if x < minx:\n            minx = x\n        if y > maxy:\n            maxy = y\n        if y < miny:\n            miny = y\n    \n    #create the rectangle\n    rect = [(minx, miny), (minx, maxy), (maxx, maxy), (maxx, miny)]\n    return rect\n\n","ee39888e":"poly = [(1,1),(5, 7),(10,1), (1,1)]\nx, y = list(zip(*poly))\nr = mbr(poly)\nx1, y1 = list(zip(*r))\nplt.plot(x,y)\nplt.plot(x1, y1)","3b03afd3":"# create data - a square note polygon is CLOSED (same and last coords the same)\ndata = [(1,1),(1,5), (5,5),(5,1),(1,1)]\n","5421c675":"\nfor i in range(len(data)-1):\n    x1 = data[i][0]\n    y1 = data[i][1]\n    x2 = data[i+1][0]\n    y2 = data[i+1][1]\n    print(x1,y1,x2, y2)\n        ","0edd4a6e":"# write function here","faa3acaf":"# Skewness\nThe Standard Deviation measures the amount of dispersion but it does not tell us anything about the direction of the dispersion \u2013 are the values clustered above or below the mean or are they distributed evenly (normally distributed).  When the weight of values are below the mean the dataset is said to be positively skewed.  If most values are above the mean then it is said to be negatively skewed. <p>\n\n![image.png](attachment:1c1e6280-41e0-48fc-bfc3-31cfa14343ac.png)\n\nWhere:<br>\n\"\u03c3\"  (sigma) = standard deviation of the population<p>\n\nWe can calculate this by <br>\n* Calculating the mean (x bar \u2013 using our mean() function)\n* Calculate the standard deviation of the pop using stdev function we wrote earlier\n* Subtract the mean from each value\n* Cube this value and add it to our running sum\n* After the summation (outside the loop)\n* Divide the sum by n * \"\u03c3\" ^3\n* Return the skew value\n","b6f3f882":"# Extracting line segments\n## Many vector calculations are done using line segments (a simple line with just a start and end coordinate)\n## A polygon can be considered as a set of line segments\n## To iterate over line segments we need the start coordinate and the end so we need to use indexes to get the data","c85abb1b":"## Iteration to extract line segments","425aab4f":"To calculate the mean we simple divide the total by the number of items after the loop has completed the summation eg.","be4c03b0":"Code to iterate over a list (pop) and sum the values to a variable called sum","bf5cc8e8":"# Summation\n![image.png](attachment:236f8a68-6bfb-4a52-bd20-2511ac33c5e8.png)","1b8f4f59":"# Check by plotting","804c2f2b":"# Plotting the geometry","76d2f6a1":"# Standard Deviation\nStandard deviation is a measure of the variance in the dataset.  The Standard Deviation of a sample is given by the formula:\n\n![image.png](attachment:9d6e2693-1e18-403e-b212-c75fc094189d.png)\n\n<p>It tells us how much the values deviate from the mean.  Although this looks complicated it is relatively trivial to convert into code:\n\n<p>For a given list of data called values, made up of a set of values we must\n\nCalculate:<br>\n* (each value \u2013 the mean of the values) \n* (x bar is standard notation for the mean) - (we have a function to compute the mean so only need to do this once at the start)\n* square this result\n  * using math.pow(x, y)\n* Sum these values in the range 1 ~ N (N being the number of items in the list)\n* Using a for i in x: type loop (as in the average code)\n* Divide this total sum by n (n being the number of items in the list)\n* After the summation has completed (careful with indentation)\n* Square root the result\n* To get the final answer using math.sqrt(x)\n\n<p>Write a new function following these steps.  Remember the SUMMATION is done inside the FOR loop, the other steps (4) and (5) are done outside the loop.\n","fa597458":"# Iteration Practical","ea02a164":"# Iteration over polygons\n## A polygon is a list of coordinate tuples\n## We iterate over coordinate tuples to carry out many basic **Vector Processing** operations\n### A good example is calculating the Minimum Bounding Rectangle (MBR) by finding the smallest and largest x and y values of a polygon or set of data","de865be1":"# Geometry handling using Iteration\n\n![image.png](attachment:003b6b8c-4da3-451f-b29d-285cf7095912.png)","dc4279ac":"# We can draw it and it's median point","c58648e2":"# Write a function to extract the longest line segment from a polygon","04846115":"# Non simple polygons\n* Below is some data from Ordnance Survey Mastermap Vector data","74f30ba9":"Test the code","38717509":"# Pearson\u2019s Product Moment Correlation Coefficient\nPearson\u2019s product measures the magnitude and direction of correlation between 2 sets of data.  We might assume that if you go to university then you might be rewarded with a better job.   Therefore we would expect there to be a POSITIVE correlation between our degree data (the number of people with a degree) and our job data (the number of people in high paid professional jobs).  Similarly we would expect the jobs data to be negatively correlated with the Index of Multiple Deprivation list (imd) ie.  In the areas where there are lots of people with good jobs we would expect there to be a low deprivation score (Gosforth is less deprived than Benwell for example).  A strong correlation will be near 1.  No correlation will be 0 and a strong negative correlation will be around -1.<p>\n\nPearson\u2019s will return a value in the range (-1 < 0 < 1)<p>\n\nPearson\u2019s product uses the standard deviation of a population formula.  For 2 sets of data called x and y and the standard deviation Sx and Sy Pearson\u2019s product can be expressed as:<p>\n\n![image.png](attachment:749459f3-0d56-4b05-ae1d-7779e432775c.png)\n\nIn plain English<br>\n1. Sum the product of xi * yi and divide total by n\n2. Subtract the product of the means of x and y\n3. Divide this by the product of the 2 standard deviations (stdev)\n\nHave a go at implementing Pearson\u2019s Product Correlation \n","e0f7733e":"# Practical Complete\n## We have looked at iteration of standard lists and geometry coordinates\n## We will be using iteration over polygon to calculate the Area of a Polygon in forthcoming coursework","86e3e41d":"# Median\nThe median of a dataset is the middle value.  It is useful if your data contains extreme values as the mean can then not be very representative.\n<br>\nThe median can be computed in the following fashion:\n1. Sort the values in ascending order\n2. if the number of values (n) in a list is odd then\n   * index of median value = n \/\/ 2  (the result of the integer division)\n3. if the number of values (n) is even\n   * median value = (value[n \/\/ 2 - 1] + value[n \/\/ 2]) \/ 2\n\n<br><br>\nImplement the median function and test it. (Hint numpy has a median function that takes a numpy array as an argument and returns the median).  You will need to create a new list with an even number pf values to test it properly\n","05c64ce0":"# First some data\n\n\n![image.png](attachment:bbfdff32-cb41-4314-9005-75e570c7e0c5.png)\n\n<br>This is a sample of data from the 2001 census for 13 Super Output Areas (SOAs)<br>\n* imd = Index of Multiple Deprivation - a combined measure of relative deprivation\n* degreee = numbers of people with University degrees\n* pop = Population data\n* jobs = Numbers of people with managerial\/profressional jobs (Doctor, Accountant, Lawyer, Lecturer, Senior Manager etc.)"}}