{"cell_type":{"999bb402":"code","7b2e9f49":"code","2823057e":"code","17166849":"code","4768dc28":"code","f7388b54":"code","f9d52209":"markdown","aea432c0":"markdown","91b7270b":"markdown","c997da96":"markdown","3b1153d3":"markdown","781064d4":"markdown"},"source":{"999bb402":"import numpy as np\nimport pandas as pd\nimport os\nfrom tqdm import tqdm_notebook as tqdm\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nprint(os.listdir(\"..\/input\"))\n\nKAGGLE_DIR = '..\/input'\n\n# Atom level properties\nMULLIKEN_CHARGES_CSV = os.path.join(KAGGLE_DIR, 'mulliken_charges.csv')\nSCALAR_COUPLING_CONTRIBUTIONS_CSV = os.path.join(KAGGLE_DIR, 'scalar_coupling_contributions.csv')\nMAGNETIC_SHIELDING_TENSORS_CSV = os.path.join(KAGGLE_DIR, 'magnetic_shielding_tensors.csv')\nSTRUCTURES_CSV = os.path.join(KAGGLE_DIR, 'structures.csv')\n\n# Molecule level properties\nPOTENTIAL_ENERGY_CSV = os.path.join(KAGGLE_DIR, 'potential_energy.csv')\nDIPOLE_MOMENTS_CSV = os.path.join(KAGGLE_DIR, 'dipole_moments.csv')\n\n# Atom-Atom interactions\nTRAIN_CSV = os.path.join(KAGGLE_DIR, 'train.csv')\nTEST_CSV = os.path.join(KAGGLE_DIR, 'test.csv')","7b2e9f49":"atomic_radius = {'H':0.38, 'C':0.77, 'N':0.75, 'O':0.73, 'F':0.71} # Without fudge factor\n\nfudge_factor = 0.05\natomic_radius = {k:v + fudge_factor for k,v in atomic_radius.items()}\nprint(atomic_radius)\n\nelectronegativity = {'H':2.2, 'C':2.55, 'N':3.04, 'O':3.44, 'F':3.98}\n\nstructures = pd.read_csv(STRUCTURES_CSV, dtype={'atom_index':np.int8})\n\natoms = structures['atom'].values\natoms_en = [electronegativity[x] for x in tqdm(atoms)]\natoms_rad = [atomic_radius[x] for x in tqdm(atoms)]\n\nstructures['EN'] = atoms_en\nstructures['rad'] = atoms_rad\n\ndisplay(structures.head())","2823057e":"i_atom = structures['atom_index'].values\np = structures[['x', 'y', 'z']].values\np_compare = p\nm = structures['molecule_name'].values\nm_compare = m\nr = structures['rad'].values\nr_compare = r\n\nsource_row = np.arange(len(structures))\nmax_atoms = 28\n\nbonds = np.zeros((len(structures)+1, max_atoms+1), dtype=np.int8)\nbond_dists = np.zeros((len(structures)+1, max_atoms+1), dtype=np.float32)\n\nprint('Calculating bonds')\n\nfor i in tqdm(range(max_atoms-1)):\n    p_compare = np.roll(p_compare, -1, axis=0)\n    m_compare = np.roll(m_compare, -1, axis=0)\n    r_compare = np.roll(r_compare, -1, axis=0)\n    \n    mask = np.where(m == m_compare, 1, 0) #Are we still comparing atoms in the same molecule?\n    dists = np.linalg.norm(p - p_compare, axis=1) * mask\n    r_bond = r + r_compare\n    \n    bond = np.where(np.logical_and(dists > 0.0001, dists < r_bond), 1, 0)\n    \n    source_row = source_row\n    target_row = source_row + i + 1 #Note: Will be out of bounds of bonds array for some values of i\n    target_row = np.where(np.logical_or(target_row > len(structures), mask==0), len(structures), target_row) #If invalid target, write to dummy row\n    \n    source_atom = i_atom\n    target_atom = i_atom + i + 1 #Note: Will be out of bounds of bonds array for some values of i\n    target_atom = np.where(np.logical_or(target_atom > max_atoms, mask==0), max_atoms, target_atom) #If invalid target, write to dummy col\n    \n    bonds[(source_row, target_atom)] = bond\n    bonds[(target_row, source_atom)] = bond\n    bond_dists[(source_row, target_atom)] = dists\n    bond_dists[(target_row, source_atom)] = dists\n\nbonds = np.delete(bonds, axis=0, obj=-1) #Delete dummy row\nbonds = np.delete(bonds, axis=1, obj=-1) #Delete dummy col\nbond_dists = np.delete(bond_dists, axis=0, obj=-1) #Delete dummy row\nbond_dists = np.delete(bond_dists, axis=1, obj=-1) #Delete dummy col\n\nprint('Counting and condensing bonds')\n\nbonds_numeric = [[i for i,x in enumerate(row) if x] for row in tqdm(bonds)]\nbond_lengths = [[dist for i,dist in enumerate(row) if i in bonds_numeric[j]] for j,row in enumerate(tqdm(bond_dists))]\nn_bonds = [len(x) for x in bonds_numeric]\n\n#bond_data = {'bond_' + str(i):col for i, col in enumerate(np.transpose(bonds))}\n#bond_data.update({'bonds_numeric':bonds_numeric, 'n_bonds':n_bonds})\n\nbond_data = {'bonds':bonds_numeric, 'n_bonds':n_bonds, 'bond_lengths':bond_lengths}\nbond_df = pd.DataFrame(bond_data)\nstructures = structures.join(bond_df)\ndisplay(structures.head(20))","17166849":"structures.tail(16)","4768dc28":"elements = structures['atom'].unique()\ngraphs_per_row = 3\nrow_count = int(np.ceil(len(elements) \/ graphs_per_row))\nfig, axes = plt.subplots(row_count, graphs_per_row, figsize=(20, row_count * 5))\n\nfor i, element in enumerate(elements):\n    x = structures[structures['atom'] == element].n_bonds.value_counts().index\n    y = structures[structures['atom'] == element].n_bonds.value_counts().values\n    ax = axes[i\/\/graphs_per_row, i%graphs_per_row]\n    ax.bar(x=x, height=y, tick_label=[str(n) for n in x], label='Bond count')\n    ax.set(title=f'Bond count - {element}', xlabel='Bond count', ylabel='frequency')\n\nplt.tight_layout()\nplt.show()","f7388b54":"elements = structures['atom'].unique()\ngraphs_per_row = 3\nrow_count = int(np.ceil(len(elements) \/ graphs_per_row))\nfig, axes = plt.subplots(row_count, graphs_per_row, figsize=(20, row_count * 5))\n\nfor i, element in enumerate(elements):\n    y = []\n    for l in structures[structures['atom'] == element]['bond_lengths'].values:\n        y.extend(l)\n    ax = axes[i\/\/graphs_per_row, i%graphs_per_row]\n    ax.hist(y, bins=1000)\n    ax.set(title=f'Bond lengths - {element}', xlabel='Bond length', ylabel='frequency')\n\nplt.tight_layout()\nplt.show()","f9d52209":"**The last molecule - 133885**\n\nHere is a visualization of the xyz file generated by a program called IQmol \n\n(Info and download here: http:\/\/iqmol.org\/)\n\n![image.png](attachment:image.png)\n\nThis molecule has 16 atoms.  Below are the generated bonds.  It is fairly easy to verify that the visualization program and the generated bonds agree. (Note: IQmol uses 1-index and I use 0-index)","aea432c0":"**Recovering bonds from structure**\n\nThis kernel presents a method to extract the bonds between atoms in a molecule.  The inputs are the XYZ coordinates of the atoms (as found in the given structure data) and the covalent radius for each element (from wikipedia).  The output is, for each atom, a list of atom_indexes of the other atoms that it is bonded to.  The method is similar to the atomic connectivity step described here: http:\/\/proteinsandwavefunctions.blogspot.com\/2018\/01\/xyz2mol-converting-xyz-file-to-rdkit.html.","91b7270b":"**Read and preprocess structure data**\n\nThe most important step here for bond detection is the addition of the atomic radius values.  There are several different definitions of atomic radius, but the most relevant in this situation is the radius of a single covalent bond.  Wikipedia maintains a table with this value at https:\/\/en.wikipedia.org\/wiki\/Atomic_radii_of_the_elements_(data_page).  I increased the values slightly in order to reduce false negatives.  Atoms that are not bonded repel each other, so it should be rare that this increase will result in false positives.","c997da96":"**Chemical Bond Calculation**\n\n","3b1153d3":"**Validation**","781064d4":"**Bond counts by element**\n\nBased on the number of electrons in an atom's valence shell, we know how many bonds the atom needs to form to be stable.  Hydrogen needs 1, Flourine needs 1, Oxygen needs 2, Nitrogen needs 3, and Carbon needs 4.  Bonds can be single, double, or triple, but we have not yet calculated the strength of the bonds.  Therefore there is a range of valid bond counts we could get for each atom.\n\n- Hydrogen         \n    - 1\n- Flourine\n    - 1\n- Oxygen\n    - 1 - 2\n- Nitrogen         \n    - 1 - 3\n- Carbon   \n    - 2 - 4\n    \nWhen we graph the number of bonds for each element we see that these conditions are met, with the sole exception of several Nitrogen atoms forming 4 bonds."}}