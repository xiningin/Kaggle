{"cell_type":{"e350a733":"code","cc9fe607":"code","d8ff19d6":"code","f2cbc31b":"code","6fab212c":"code","bd0135d8":"code","cd3774a2":"code","a17f6b47":"code","af0e6f9f":"code","0c4a1358":"code","5df15566":"code","6732da98":"code","f1e0d099":"code","e7b7ea14":"markdown","bfbcf155":"markdown","c8cf617a":"markdown","a1ba2435":"markdown","6fda5999":"markdown","129e4372":"markdown"},"source":{"e350a733":"import os\nimport time\nimport numpy as np\nimport pandas as pd\nfrom tqdm import tqdm\nfrom sklearn import metrics\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.metrics import roc_auc_score\nimport lightgbm as lgb\nimport pyarrow.parquet as pq\nimport gc\nfrom sklearn.model_selection import train_test_split\n\n%matplotlib inline","cc9fe607":"smooth = 1000\nkaggle_notebook = True","d8ff19d6":"if kaggle_notebook:\n    read_line = 500\n    test_start = 8712\n    train = pq.read_pandas('..\/input\/train.parquet', columns=[str(i) for i in range(read_line)]).to_pandas().values.T\n    test = pq.read_pandas('..\/input\/test.parquet', columns=[str(i) for i in range(test_start,test_start+read_line)]).to_pandas().values.T\n    meta_tr = pd.read_csv('..\/input\/metadata_train.csv', nrows=read_line)\n    meta_te = pd.read_csv('..\/input\/metadata_test.csv', nrows=read_line)\nelse:\n    train = pq.read_pandas('..\/input\/train.parquet').to_pandas().values.T\n    test = pq.read_pandas('..\/input\/test.parquet').to_pandas().values.T\n    meta_tr = pd.read_csv('..\/input\/metadata_train.csv')\n    meta_te = pd.read_csv('..\/input\/metadata_test.csv')","f2cbc31b":"def smooth_data(arr):\n    avarr = np.zeros((arr.shape[0],int(arr.shape[1]\/smooth)))\n    for i in range(arr.shape[0]):\n        for j in range(int(arr.shape[1]\/smooth)):\n            avarr[i,j] = np.mean(arr[i,smooth*j:smooth*j+smooth-1])\n    return avarr\ntrn = smooth_data(train)\ntst = smooth_data(test)","6fab212c":"def conv_fft(arr):\n    farr = np.zeros((arr.shape[0],int(arr.shape[1])))\n    for i in range(arr.shape[0]):\n        farr[i,:] = np.log(1+np.abs(np.fft.fft(arr[i])))\n    return farr\nftrn = conv_fft(trn)\nftst = conv_fft(tst)","bd0135d8":"trn_df = pd.DataFrame(ftrn)\ntst_df = pd.DataFrame(ftst)\n\n#target\ntrn_df['is_test'] = 0\ntst_df['is_test'] = 1\n\n# additional feats\ntrn_df['mean'] = np.mean(train,axis=1)\ntrn_df['max'] = np.max(train,axis=1)\ntrn_df['min'] = np.min(train,axis=1)\ntrn_df['phase'] = meta_tr.phase\ntst_df['mean'] = np.mean(test,axis=1)\ntst_df['max'] = np.max(test,axis=1)\ntst_df['min'] = np.min(test,axis=1)\ntst_df['phase'] = meta_te.phase\n\ndf = pd.concat([trn_df,tst_df])","cd3774a2":"params = {'num_leaves': 80,\n         'objective':'binary',\n         'learning_rate': 0.01,\n         \"boosting\": \"gbdt\",\n         \"feature_fraction\": 0.8,\n         \"bagging_freq\": 1,\n         \"bagging_fraction\": 0.8 ,\n         \"metric\": 'auc'}","a17f6b47":"n_folds = 10\nkfolds = StratifiedKFold(n_splits=n_folds, shuffle=True, random_state=110)\nvalid_preds = np.zeros(df.shape[0])\nfor n, (trn_idx, val_idx) in enumerate(kfolds.split(df, df['is_test'])):\n    tr = df.iloc[trn_idx].copy()\n    va = df.iloc[val_idx].copy()\n    tr_y = tr['is_test']\n    va_y = va['is_test']\n    del tr['is_test'], va['is_test']\n    lgtrain = lgb.Dataset(tr, label=tr_y)\n    lgvalid = lgb.Dataset(va, label=va_y)\n    valid_names=['train','valid']\n    valid_sets=[lgtrain, lgvalid]\n    bst = lgb.train(params,\n                     lgtrain,\n                     valid_sets=valid_sets,\n                     num_boost_round=100000,\n                     early_stopping_rounds=100,\n                     verbose_eval=100,\n                     )\n    valid_preds[val_idx] = bst.predict(va)\nscore = roc_auc_score(df['is_test'], valid_preds)\nprint(score)","af0e6f9f":"_ =lgb.plot_importance(bst, max_num_features=100, importance_type ='gain', figsize=(15,50))","0c4a1358":"meta_tr['pred'] = valid_preds[:len(trn_df)]\nmeta_tr.to_csv('metadata_train_for_AdversarialValidation.csv', index=False)","5df15566":"del train, test, trn, tst, ftrn, ftst\ngc.collect()\nread_line = 1000\ntest_start = 8712\ntest = pq.read_pandas('..\/input\/test.parquet', columns=[str(i) for i in range(test_start,test_start+read_line)]).to_pandas().values.T\nmeta_te = pd.read_csv('..\/input\/metadata_test.csv', nrows=read_line)\ntrain, test, meta_tr, meta_te = train_test_split(test, meta_te, test_size=0.5, random_state=1)","6732da98":"trn = smooth_data(train)\ntst = smooth_data(test)\nftrn = conv_fft(trn)\nftst = conv_fft(tst)\ntrn_df = pd.DataFrame(ftrn)\ntst_df = pd.DataFrame(ftst)\ntrn_df['is_test'] = 0\ntst_df['is_test'] = 1\ntrn_df['mean'] = np.mean(train,axis=1)\ntrn_df['max'] = np.max(train,axis=1)\ntrn_df['min'] = np.min(train,axis=1)\ntrn_df['phase'] = meta_tr.phase.values\ntst_df['mean'] = np.mean(test,axis=1)\ntst_df['max'] = np.max(test,axis=1)\ntst_df['min'] = np.min(test,axis=1)\ntst_df['phase'] = meta_te.phase.values\ndf = pd.concat([trn_df,tst_df])\n\nparams = {'num_leaves': 80,\n         'objective':'binary',\n         'learning_rate': 0.01,\n         \"boosting\": \"gbdt\",\n         \"feature_fraction\": 0.8,\n         \"bagging_freq\": 1,\n         \"bagging_fraction\": 0.8 ,\n         \"metric\": 'auc'}\n\nn_folds = 10\nkfolds = StratifiedKFold(n_splits=n_folds, shuffle=True, random_state=110)\nvalid_preds = np.zeros(df.shape[0])\nfor n, (trn_idx, val_idx) in enumerate(kfolds.split(df, df['is_test'])):\n    tr = df.iloc[trn_idx].copy()\n    va = df.iloc[val_idx].copy()\n    tr_y = tr['is_test']\n    va_y = va['is_test']\n    del tr['is_test'], va['is_test']\n    lgtrain = lgb.Dataset(tr, label=tr_y)\n    lgvalid = lgb.Dataset(va, label=va_y)\n    valid_names=['train','valid']\n    valid_sets=[lgtrain, lgvalid]\n    bst = lgb.train(params,\n                     lgtrain,\n                     valid_sets=valid_sets,\n                     num_boost_round=100000,\n                     early_stopping_rounds=100,\n                     verbose_eval=100,\n                     )\n    valid_preds[val_idx] = bst.predict(va)\nscore = roc_auc_score(df['is_test'], valid_preds)\nprint(score)","f1e0d099":"_ =lgb.plot_importance(bst, max_num_features=100, importance_type ='gain', figsize=(15,50))","e7b7ea14":"### convert by fft","bfbcf155":"## waht this notebook do:\n* to predict train or test\n* extract fft feats\n\n## what this notebook do not:\n* to predict Power Line Fault\n\n## findings\n* high auc ~ 0.99\n* so train and test has different distribution?","c8cf617a":"### add same feats","a1ba2435":"### Let's check whether we get the same result, if we split test to test1 and test2 and try to predict if it is test1 or test2?","6fda5999":"### down sampling","129e4372":"### training"}}