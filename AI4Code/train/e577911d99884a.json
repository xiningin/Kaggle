{"cell_type":{"155ad9f9":"code","021307e3":"code","bb5260cd":"code","12e44346":"code","b0a7ccfe":"code","45b483bd":"code","5226da2d":"code","532023dd":"code","d31df6c6":"code","1790e5e0":"code","cf6d6af1":"code","3955821f":"code","650c4d8a":"code","30d2d57d":"code","5e9d422e":"code","bc952079":"code","04095fb3":"code","17ce25ae":"code","e9720c54":"code","76568b45":"code","05dd0784":"code","40e75351":"code","e1b1483b":"code","9e7a6765":"code","ebda05b8":"code","737a9968":"code","f02984a6":"code","c18ad7e7":"code","40df9fa6":"code","a53f97e4":"code","d4ad4693":"code","53fcc9f1":"code","4e05426c":"code","d80bd9e6":"code","a9044ad7":"code","db5ced35":"code","1414125b":"code","43e11635":"code","996ac050":"code","6b82bd5a":"code","caecaa72":"code","d3f3e7a5":"code","dd3640b9":"code","f55743d7":"code","4d1a2082":"code","45d3618e":"code","e161ec1d":"code","f0dc4b12":"code","03dff6ee":"code","ca102951":"code","e2988d5a":"code","700b75f2":"code","4e3d75d4":"code","939af945":"code","888c53f1":"code","59a30983":"code","603bfb83":"code","6d4141e7":"code","cfe7f6b4":"code","2d110480":"code","2ed8bc9b":"code","4f266269":"code","63534be8":"code","dab17e9b":"code","cd3089cd":"markdown","a7b72f0f":"markdown","8b42b580":"markdown","48cf63aa":"markdown","6e60ddd9":"markdown","38a8e2f8":"markdown","cb4628bb":"markdown","a8de90da":"markdown","07e59425":"markdown","806e1075":"markdown","b546b0a6":"markdown","0b9355b0":"markdown","9f1ed6d5":"markdown","35bdafb3":"markdown","112b0280":"markdown","dbbd9000":"markdown","a012f18e":"markdown","bdaaaeb2":"markdown","cb737294":"markdown","3ba29844":"markdown","e3088818":"markdown","219515fa":"markdown","99e9eea7":"markdown","6c3c2927":"markdown","c12fb41c":"markdown","e45a0aaf":"markdown","33ad8a1f":"markdown","ad532a53":"markdown","8d444576":"markdown","c1d63714":"markdown","2e2c79e0":"markdown","1b37d39c":"markdown","d97509c2":"markdown","4b192f16":"markdown","d36cd1d6":"markdown","58166174":"markdown","acf6f4f5":"markdown","5f2a5091":"markdown","9492f685":"markdown","02db8c48":"markdown","0b34ab85":"markdown","e37cc099":"markdown","97ac6eb2":"markdown","5cb98d64":"markdown","2ac3df10":"markdown","9fcbf206":"markdown","6a95e938":"markdown","00661cce":"markdown","c73feafb":"markdown","72b0d683":"markdown","d9b53be1":"markdown","6c49c6ef":"markdown"},"source":{"155ad9f9":"import pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\nimport sklearn\nimport os\nimport matplotlib.pyplot as plt\npd.options.plotting.backend = \"plotly\"","021307e3":"df = pd.read_csv('..\/input\/pokemon\/pokemon.csv', index_col='pokedex_number')\ndf.head()","bb5260cd":"print(\"Shape of our dataframe:\")\ndf.shape","12e44346":"print(\"All columns we have:\\n \" ,df.columns.tolist())","b0a7ccfe":"df.info()","45b483bd":"num_cols = list(df.select_dtypes(exclude=['object']).columns)\nobj_cols = list(df.select_dtypes(include=['object']).columns)\nnull_cols = df.columns[df.isnull().any()]\n\nprint(\"Number of numeric columns:\", len(num_cols))\nprint(\"Number of object columns:\", len(obj_cols))\nprint(\"Number of null columns:\", len(null_cols))","5226da2d":"df[null_cols].head()","532023dd":"print(\"n\u00ba of null values per column:\")\ndf[null_cols].isnull().sum()","d31df6c6":"df.type2.fillna(\"None\", inplace=True)","1790e5e0":"df[obj_cols].head()","cf6d6af1":"df.capture_rate = df.capture_rate.replace('30 (Meteorite)255 (Core)', 30)\ndf.capture_rate = df.capture_rate.astype(int)","3955821f":"obj_cols.remove('name')\nobj_cols.remove('japanese_name')","650c4d8a":"dict_color_types = {\"Water\": \"rgb(51, 153, 255)\",\n                    \"Normal\": \"#e0e0d1\",\n                    \"Grass\": \"#47d147\",\n                    \"Bug\": \"#669900\",\n                    \"Psychic\": \"#ff33cc\",\n                    \"Fire\": \"#ff0000\",\n                    \"Rock\": \"#ffd24d\",\n                    \"Electric\": \"#ffff00\",\n                    \"Poison\": \"#990099\",\n                    \"Ground\": \"#cc9900\",\n                    \"Dark\": \"#1a001a\",\n                    \"Fighting\": \"#ff4000\",\n                    'Ghost': \"#1a001a\",\n                    'Dragon': \"#0033cc\",\n                    'Steel': \"#999966\",\n                    'Ice': \"#00ffff\",\n                    'Fairy': \"#ffccee\",\n                    'Flying': \"#d1e0e0\",\n                    }   # a dictionary of colors for each type","30d2d57d":"from plotly.subplots import make_subplots\n\ncount_type1 = df.groupby('type1').size().sort_values(ascending=True)\ncount_type1.index = count_type1.index.map(lambda x: x.capitalize())\ncount_type2 = df.groupby('type2').size().sort_values(ascending=True)\ncount_type2.index = count_type2.index.map(lambda x: x.capitalize())\n\nfig = make_subplots(rows=1, cols=2, subplot_titles=(\"Type 1\", \"Type 2\"),\n                    )\n\nfor idx, typ in enumerate([count_type1, count_type2]):\n    fig.add_trace(go.Bar(y=typ.index, x=typ.values, \n                       text=typ.values, textposition='outside',\n                       orientation='h',\n                       marker_color=typ.index.map(dict_color_types),\n                       name=\"Type \"+str(idx+1),\n                       ),\n                       row=1, col=idx+1)\n    if idx == 1: # update range to show text on bars\n        fig.update_xaxes(visible=False, range=[0, 500], row=1, col=idx+1) \n    else:\n        fig.update_xaxes(visible=False, range=[0, 130], row=1, col=idx+1)\n\nfig.update_layout(title='N\u00ba of Pokemon Types',\n                 template='plotly_white', width=1000, height=600,\n                 showlegend=False,\n                 margin=dict(l=40, r=10, t=100, b=20),\n                 yaxis_title=\"Type\",\n                 )\n\nfig.show()","5e9d422e":"print(\"Pok\u00e9mons that have flying as their primary type:\")\ndf[df.type1 == 'flying'][[\"name\", \"type1\", \"type2\"]]","bc952079":"count_type1 = df[df.is_legendary == 1].groupby('type1').size().sort_values(ascending=True)\ncount_type1.index = count_type1.index.map(lambda x: x.capitalize())\ncount_type2 = df[df.is_legendary == 1].groupby('type2').size().sort_values(ascending=True)\ncount_type2.index = count_type2.index.map(lambda x: x.capitalize())\n\nfig = make_subplots(rows=1, cols=2, subplot_titles=(\"Type 1\", \"Type 2\"),\n                    )\n\nfor idx, typ in enumerate([count_type1, count_type2]):\n    fig.add_trace(go.Bar(y=typ.index, x=typ.values, \n                       text=typ.values, textposition='outside',\n                       orientation='h',\n                       marker_color=typ.index.map(dict_color_types),\n                       name=\"Type \"+str(idx+1),\n                       ),\n                       row=1, col=idx+1)\n    if idx == 1: # update range to show text on bars\n        fig.update_xaxes(visible=False, range=[0, 30], row=1, col=idx+1) \n    else:\n        fig.update_xaxes(visible=False, range=[0, 30], row=1, col=idx+1)\n\nfig.update_layout(title=\"N\u00ba of Legendary Pok\u00e9mon's Types\",\n                 template='plotly_white', width=1000, height=600,\n                 showlegend=False,\n                 margin=dict(l=40, r=10, t=100, b=20),\n                 yaxis_title=\"Type\",\n                 )\n\nfig.show()","04095fb3":"count_type2 = df.groupby('type2').size().sort_values(ascending=True)\ncount_type2.index = count_type2.index.map(lambda x: x.capitalize())\ncount_type2_leg = df[df.is_legendary == 1].groupby('type2').size().sort_values(ascending=True)\ncount_type2_leg.index = count_type2_leg.index.map(lambda x: x.capitalize())\n\nfig = make_subplots(rows=1, cols=2, subplot_titles=(\"Non-legendary\", \"Legendary\"),\n                    )\n\nfor idx, typ in enumerate([count_type2, count_type2_leg]):\n    fig.add_trace(go.Bar(y=typ.index, x=typ.values, \n                       text=typ.values, textposition='outside',\n                       orientation='h',\n                       marker_color=typ.index.map(dict_color_types),\n                       name=\"Type \"+str(idx+1),\n                       ),\n                       row=1, col=idx+1)\n    if idx == 1: # update range to show text on bars\n        fig.update_xaxes(visible=False, range=[0, 500], row=1, col=idx+1) \n    else:\n        fig.update_xaxes(visible=False, range=[0, 500], row=1, col=idx+1)\n\nfig.update_layout(title=\"N\u00ba of Legendary Pok\u00e9mon's Types\",\n                 template='plotly_white', width=1000, height=600,\n                 showlegend=False,\n                 margin=dict(l=40, r=10, t=100, b=20),\n                 yaxis_title=\"Type\",\n                 )\n\nfig.show()","17ce25ae":"obj_cols.remove('type2')","e9720c54":"fig = df[\"classfication\"].value_counts().hist()\nfig.update_layout(title=\"Classifications in Common\",\n                    template='plotly_white', width=1000, height=400,\n                    showlegend=False,\n                    xaxis_title=\"n\u00ba of Pok\u00e9mon with the same classification\",\n                    yaxis_title=\"n\u00ba of Pok\u00e9mon in this category\",\n)","76568b45":"obj_cols.remove('classfication')","05dd0784":"def len_abilities(l):\n    if l[0] != '[':\n        return 1\n    else:\n        l = l.replace(\"'\", \"\").replace(\" \", \"\").strip('[]').split(',')\n        return len(l)","40e75351":"df[\"n_abilities\"] = df.abilities.map(len_abilities)","e1b1483b":"df.n_abilities.value_counts().plot(kind='bar')\nfig.update_layout(title=\"N\u00ba of Abilities for Pok\u00e9mon\",\n                    template='plotly_white', width=1000, height=400,\n                    showlegend=False,\n                    xaxis_title=\"Lenght of possible abilities\",\n                    yaxis_title=\"n\u00ba of Pok\u00e9mon\",\n)","9e7a6765":"obj_cols.remove('abilities')\nobj_cols.remove('capture_rate')\nprint(\"We will use these object columns:\", obj_cols)","ebda05b8":"df.describe()","737a9968":"num_cols = list(df.select_dtypes(exclude=['object']).columns)\nnum_cols.sort()\nprint(\"There are %i numerical columns.\" %len(num_cols))","f02984a6":"num_cols_against = num_cols[:18].copy()\nprint(\"Against columns:\", num_cols_against)","c18ad7e7":"corr = df[num_cols_against].corr()\npx.imshow(corr, color_continuous_scale=px.colors.sequential.Plasma)","40df9fa6":"def mean_against(x, y):\n    return (x+y)\/2","a53f97e4":"df[\"against_dark_ghost\"] = mean_against(df[\"against_ghost\"], df[\"against_dark\"])\nnum_cols.append(\"against_dark_ghost\")","d4ad4693":"num_cols.remove(\"against_dark\")\nnum_cols.remove(\"against_ghost\")","53fcc9f1":"att_cols = ['attack', 'defense', 'hp', 'sp_attack', 'sp_defense', 'speed', 'base_total']\nprint(\"Base stats columns:\", att_cols)","4e05426c":"from plotly.subplots import make_subplots\n\nfig = make_subplots(rows=7, cols=1, subplot_titles=(\"Attack\", \"Defense\", \"HP\", \"Sp. Atk\", \"Sp. Def\", \"Speed\", \"Total\"))\n\nfor i, col in enumerate(att_cols):\n    fig.add_trace(go.Histogram(x=df[col], name=col), row=i+1, col=1)\n    \nfig.update_layout(width=800, height=800, template='plotly_white', showlegend=False)\nfig.update_yaxes(range=[0, 100])\nfig.show()","d80bd9e6":"print(\"The strongest Pok\u00e9mon! (including their mega-evolution)\")\ndf[[\"base_total\", \"name\",\"is_legendary\"]].sort_values(\"base_total\", ascending=False).head(20)","a9044ad7":"print(\"Other numerical columns: \",list(set(num_cols[18:]) - set(att_cols)))","db5ced35":"fig = df.generation.value_counts().plot(kind='bar')\nfig.update_layout(title=\"N\u00ba of Pok\u00e9mon per Generation\",\n                    template='plotly_white', width=1000, height=400,\n                    showlegend=False,\n                    yaxis_title=\"N\u00ba of Pok\u00e9mon\",\n                    xaxis_title=\"Generation\",\n)","1414125b":"fig = df[df.is_legendary == 1].generation.value_counts().plot(kind='bar')\nfig.update_layout(title=\"N\u00ba of Legendary Pok\u00e9mon per Generation\",\n                    template='plotly_white', width=1000, height=400,\n                    showlegend=False,\n                    yaxis_title=\"N\u00ba of Pok\u00e9mon\",\n                    xaxis_title=\"Generation\",\n)","43e11635":"num_cols.remove(\"generation\")","996ac050":"fig = px.scatter(df, x=\"weight_kg\", y=\"height_m\", facet_col=\"is_legendary\", color=\"is_legendary\",\n                 hover_data=dict(is_legendary=False,\n                                 ), hover_name=\"name\",)\nfig.update_layout(title=\"Weight vs Height\",\n                    template='plotly_white', width=1000, height=400,\n                    showlegend=False,\n                    yaxis_title=\"Height (m)\",\n                    \n                    \n)\nfig.update_xaxes(title_text=\"Weight (kg)\")\nfig.update_coloraxes(showscale=False)\nfig.show()","6b82bd5a":"df[[\"weight_kg\", \"height_m\"]].describe()","caecaa72":"print(\"Pok\u00e9mon that don't have a genre:\")\ndf_genre = df[df.percentage_male.isnull()][[\"name\", \"is_legendary\"]]\ndf_genre","d3f3e7a5":"df_genre.is_legendary.value_counts()","dd3640b9":"df_is_legendary = df[df.is_legendary == 1]\nprint(\"Legendary pok\u00e9mon that have a genre:\")\ndf_is_legendary[~df_is_legendary.percentage_male.isnull()][[\"name\", \"percentage_male\"]]","f55743d7":"num_cols.remove(\"percentage_male\")","4d1a2082":"fig = px.box(df, x=\"is_legendary\", y=\"base_egg_steps\")\nfig.update_layout(title=\"Egg Steps Distribution by Legendary Class\",\n                  template=\"plotly_white\",\n                  xaxis_title=\"Is Legendary?\",\n                  yaxis_title=\"Egg Steps\")\nfig.show()","45d3618e":"fig = px.scatter(df, x=\"base_egg_steps\", y=\"weight_kg\", color=\"is_legendary\", hover_data=dict(is_legendary=False,\n                                                                                              ), hover_name=\"name\",)\nfig.update_layout(title=\"Egg Steps vs Weight\",\n                    template=\"plotly_white\",\n                    xaxis_title=\"Egg Steps\",\n                    yaxis_title=\"Weight (kg)\",\n                    showlegend=False)\nfig.show()","e161ec1d":"num_cols.remove(\"base_egg_steps\")","f0dc4b12":"df[[\"base_happiness\", \"capture_rate\", \"experience_growth\"]].describe()","03dff6ee":"fig = px.scatter(df, \"experience_growth\", \"base_total\", color=\"is_legendary\",\n                    hover_data=dict(is_legendary=False,\n                                                    ), hover_name=\"name\",)\nfig.update_layout(title=\"Experience Growth vs Total\",\n                    template='plotly_white', width=1000, height=400,\n                    showlegend=True,\n                    yaxis_title=\"Base Total\",\n                    xaxis_title=\"Experience Growth\",\n                    \n                    \n)\nfig.show()","ca102951":"num_cols.remove(\"experience_growth\")","e2988d5a":"fig = px.scatter(df, \"capture_rate\", \"base_total\", color=\"is_legendary\",\n                    hover_data=dict(is_legendary=False,\n                                                    ), hover_name=\"name\",)\nfig.update_layout(title=\"Capture Rate vs Total\",\n                    template='plotly_white', width=1000, height=400,\n                    showlegend=False,\n                    yaxis_title=\"Base Total\",\n                    xaxis_title=\"Capture Rate\",\n                    \n                    \n)\nfig.show()","700b75f2":"num_cols.remove(\"is_legendary\")\ncols = num_cols + obj_cols\nX = df[cols]","4e3d75d4":"corr = X.corr()\npx.imshow(corr, color_continuous_scale=px.colors.sequential.Plasma)","939af945":"for col in att_cols:\n    if col != 'base_total':\n        num_cols.remove(col)","888c53f1":"cols = num_cols + obj_cols\nX = df[cols]","59a30983":"from sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\n\n\ncat_pipe = Pipeline([\n    ('encoder', OneHotEncoder(handle_unknown='ignore')),\n])\n\nnum_pipe = Pipeline([\n    ('imputer', SimpleImputer(strategy='median')),\n    ('scaler', StandardScaler()),\n])\n\nprep_pipe = ColumnTransformer([\n    ('cat', cat_pipe, obj_cols),\n    ('num', num_pipe, num_cols),\n])\n\nX_prep = prep_pipe.fit_transform(X)","603bfb83":"from sklearn.mixture import BayesianGaussianMixture\n\ngm = BayesianGaussianMixture(n_components=30, n_init=10, random_state=42)\ngm.fit(X_prep)","6d4141e7":"print(\"The weights of each gaussian distribution\")\nnp.round(gm.weights_, 2) # the weights of each gaussian distribution","cfe7f6b4":"print(\"Our algorithm converged?\")\ngm.converged_ # True if the algorithm converged","2d110480":"df.is_legendary.value_counts(normalize=True)","2ed8bc9b":"densities = gm.score_samples(X_prep)\ndensity_threshold = np.percentile(densities, 9)\nanomalies = np.where(densities < density_threshold)","4f266269":"real_legendary = df.iloc[anomalies].name","63534be8":"def get_poke_image(name, df=df):\n    image_path = \"..\/input\/is-legendary-pokmon\/data\/pokemon_images\/{}.png\".format(name.lower().replace(\" \", \"-\"))\n    return image_path","dab17e9b":"fig, ax = plt.subplots(8, 9, figsize=(20, 20))\n\nfor idx, poke in enumerate(real_legendary):\n    image_path = get_poke_image(poke)\n    image = plt.imread(image_path)\n    ax[idx\/\/9, idx%9].imshow(image)\n    ax[idx\/\/9, idx%9].axis(\"off\")\n    ax[idx\/\/9, idx%9].set_title(poke)","cd3089cd":"# What Defines a Legendary Pok\u00e9mon?\n\n![All legendary Pok\u00e9mon](https:\/\/images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com\/f\/295fb76c-7179-4c70-a508-a1cce61a876f\/db48l6l-7d2e94e1-4acc-49e5-b143-97bdb4dbae61.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOiIsImlzcyI6InVybjphcHA6Iiwib2JqIjpbW3sicGF0aCI6IlwvZlwvMjk1ZmI3NmMtNzE3OS00YzcwLWE1MDgtYTFjY2U2MWE4NzZmXC9kYjQ4bDZsLTdkMmU5NGUxLTRhY2MtNDllNS1iMTQzLTk3YmRiNGRiYWU2MS5wbmcifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6ZmlsZS5kb3dubG9hZCJdfQ.MOc5mbFh7UWPnLFkw2REw09wO73VE3vVV5EIqjXgOOA)","a7b72f0f":"Okay, so what about the other columns? What questions can we ask about them?\n- `name` and `japanese_name` have a unique value for each pok\u00e9mon, so we will discard them to find our real legends.\n- `abilities` is a list of possible abilities for each pok\u00e9mon. How many possibilities are there for each one?\n- Is `classification` unique for each pok\u00e9mon?\n- What are the differences between the distribution in `type1` and `type2`, and their relationship with legendary pok\u00e9mon?","8b42b580":"Like I said earlier, is Classification unique for each poke or not? Let's plot how many pok\u00e9mon have a classification in common:","48cf63aa":"OK, but why legendary Pok\u00e9mon don't have a genre? Probably because they are unique in the Pok\u00e9mon world, so they are whether a non-genre or male or female! (Besides Heatran, if he's unique how can he has 50\/50 genre distribution?). Our real legends will also be unique in our new and proper Pok\u00e9mon Universe, so let's ignore the genre column.","6e60ddd9":"This heatmap points out an interesting relationship: 0.68 between `against_ghost` and `against_dark`. Let's calculate their mean and join both columns.","38a8e2f8":"Also, besides 1 pok\u00e9mon, every legendary has the same Experience Growth. We will also ignore this column.","cb4628bb":"We can see that their top-10 most common types are very similar. It's better to ignore this column to train our cluster algorithm, it doesn't aggregate much about pok\u00e9mon being legends or not.","a8de90da":"### Abilities","07e59425":"Like I said earlier, we can split our numerical columns in three categories - against, base stats and others.","806e1075":"Now, the time has come! Who are going to be the real legends? Let's plot all images of our new and fair Pok\u00e9dex.","b546b0a6":"# Training our Clustering Algorithm","0b9355b0":"### Base Stats columns","9f1ed6d5":"We can see a negative relationship between `Capture Rate` and `Base Total`, and also legendary pok\u00e9mons are more difficult to capture!","35bdafb3":"### What is a Bayesian Gaussian Mixture Model?\n\nTo explain in a few words, let's explain the Gaussian Mixture Model. It is a clustering algorithm that clusters instances in differents Gaussian Distributions. You can check a more deep explanation in this wonderful article: https:\/\/towardsdatascience.com\/gaussian-mixture-models-explained-6986aaf5a95\n\nAnd what is a Bayesian GMM? It is a variational Bayesian estimation of a GMM, which means that it tries to find the optimal parameters for a GMM. You can check its documentation at: https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.mixture.BayesianGaussianMixture.html\n\nNow, let's train our model!","112b0280":"How many legendary pok\u00e9mon don't have a genre?","dbbd9000":"### Other Numerical Columns","a012f18e":"Just as the genre dilemma, it appears that the egg steps are defined according to whether a Pok\u00e9mon is legendary or not. Besides 4 legends, all legendary have egg steps >= 20480. The only pok\u00e9mon in this threshold that isn't legendary is Type: Null and its evolution Silvally, but we already know he is a unique pok\u00e9mon to obtain in Pok\u00e9mon Sword and Shield. We will also ignore this column.","bdaaaeb2":"## Object Columns","cb737294":"### Classification","3ba29844":"Comparing them with ordinal Pok\u00e9mon, we can see some differences, but also some similarities:\n- The most common primary types are Psychic and Dragon for legendary against Water and Normal for non-legendary;\n- None and Flying are also the most common secondary types for legendary pok\u00e9mons!\n\nSo, does it `type2` helps us to identify legendary pok\u00e9mon? Let's plot their distribution:","e3088818":"So Water and Normal are the most common primary types, and the most common secondary is none at all, followed by flying. But it's curious, there are only 3 pok\u00e9mon whose primary type is flying, who are they?","219515fa":"### Dependencies","99e9eea7":"From the top-20 strongest pok\u00e9mon, 16 of them are legendary!","6c3c2927":"How many abilities a Pok\u00e9mon can have?","c12fb41c":"# Exploratory Data Analysis (EDA)","e45a0aaf":"Now let's create and train our model","33ad8a1f":"Just like classification, it has too many unique values. Let's remove it.\n","ad532a53":"We will find the best approach for each column in analyzing the Object and Numerical Columns.","8d444576":"So, pretty much all legendary Pok\u00e9mon don't have a genre. What are the legend Pok\u00e9mon that do have?","c1d63714":"Our density threshold will be 9%, which represents 72 pok\u00e9mon.","2e2c79e0":"We can see that every base stats column has a correlation coefficient >= 0.54. We will also remove these columns and only keep `base_total`","1b37d39c":"First, let's prepare our data. We will One-Hot Encode our object columns, replace our NaN values in the numerical columns by their median and standardize and scale all our columns before pass them to our model.","d97509c2":"To impute our NaN values, we have to think about the best approach for **each** column.\n- We have to analyze `height_m` and `weight_kg` to see if we impute by their mean or median;\n- Why there are `percentage_male` NaN values? Perhaps these Pok\u00e9mon don't have a genre?\n- There are Pok\u00e9mon that have only one type, that's why there are so many NaN values for `type2`. We will impute this column with the string \"None\".","4b192f16":"Why do we have more Legendary Pok\u00e9mon in the newest generations? What about the Old School? We can see a correlation between the n\u00ba of legends and generations, but correlation doesn't imply casualization. If we think about it, there should be an equal probability of legendary pok\u00e9mon in each generation. We won't use this column for predictions.","d36cd1d6":"What does it mean to be a legendary pok\u00e9mon? Is its size, weight, or just an arbitrary choice by its creators? In this notebook, I will try to find insights with data across all Pok\u00e9dex to answer this question, and also train a clustering algorithm to detect **anomalies** in our data, and find the **real legendary pok\u00e9mons** (spoiler: Gyarados is one of them \ud83e\udd70)","58166174":"Given there are some outliers (which are important, so we won't remove them), we will replace NaN values for their median in both columns.","acf6f4f5":"### Type","5f2a5091":"We can divide our columns into these categories:\n- Numerical columns (with only numerical values):\n    - Against columns: how strong\/weak a pok\u00e9mon is against a certain type\n    - Base columns: base stats (such as attack, speed, defense)\n    - Other attributes\n- Object columns (with only text values)\n- Null columns (with at least one NaN value)\nLet's analyze each one of these categories","9492f685":"### Reading Data","02db8c48":"OK, but how can we detect anomalies? We will localize the 72 instances (number of legendary pok\u00e9mon) that are in the lowest-density regions, and they, the most different pok\u00e9mons, the anomalies, are going to be our legends! But first, we have to define a density threshold to find these anomalies.","0b34ab85":"Now that we've chosen the appropriate columns that can show us the real legendary Pok\u00e9mon, let's train our cluster algorithm. But firstly, what is a clustering algorithm?\n\nTo understand it, we first have to split Machine Learning into two categories:\n- **Supervised Learning**: when our goal is to predict a particular label (or more than one) in a labeled dataset, i.e. to predict whether someone survived or not in the Titanic (we already know who survived or not, we will train our model to predict new instances)\n- **Unsupervised Learning**: when we use an unlabelled dataset to find patterns, anomalies, customer segmentation, and other tasks that don't involve predicting a target that already exists in our dataset.\n\nOur current task is an unsupervised learning problem - we will try to find clusters (groups) in our dataset, and the anomalies (outliers) are going to be considered the Real Legendary Pok\u00e9mon. But how will we do it? We will use a Bayesian Gaussian Mixture Model \ud83e\udd2f\ud83e\udd2f","e37cc099":"There are some positive outliers in our distributions. Are they legendary?","97ac6eb2":"## Null Columns","5cb98d64":"Let's see some basic statistics about them:","2ac3df10":"This is our dataset with only object columns. There is an error in it - why is `capture_rate` an object column? It has a value '30 (Meteorite)255 (Core)'. Let's replace it with 30.","9fcbf206":"### Against columns","6a95e938":"We can clearly see there are heavier legendary pok\u00e9mon than heavier non-legendary. But what about height? \n\nTo approach this question, we have to think about both our samples: we only have 72 legendary pok\u00e9mon, against 801 non-legendary. If the quantity of taller pok\u00e9mon legendary and non-legendary appears to be similar, the probability of a legendary pok\u00e9mon being taller is way bigger than a non-legendary!","00661cce":"## Numerical Columns","c73feafb":"We have too many exclusive classifications, so we will also ignore this column. ","72b0d683":"# The Real Legendary Pok\u00e9mon!!","d9b53be1":"Our dataset contains 801 pok\u00e9mons (one per row) and 40 attributes about each one of them, such as weight, height, number of abilities, etc. Let's now analyze our data.","6c49c6ef":"Wow, I can live in a world where Lucario, Gallade, and Wailord are the real deal! Imagine a videogame version with Stunfisk and Bibarel as their Version Legends, I would definitely buy it \ud83d\ude02\ud83d\ude02.\n\nAs a fan of Pok\u00e9mon, I had so much fun doing this project! I highly recommend you find some dataset of your interest and study AI having fun with it! \n\nIf you also enjoyed this project, please let me know in the comments, and tell me how can I improve it. Thank you!\n\n![](https:\/\/uploads.jovemnerd.com.br\/wp-content\/uploads\/2019\/05\/meme-pokemon-sleep.jpg)"}}