{"cell_type":{"b6791dcb":"code","8030e907":"code","c23af675":"code","225fed07":"code","1fb33c2e":"code","c3fab411":"code","aa8512ce":"code","7e63e336":"code","06e6bb01":"code","5412ca88":"code","7b17ada6":"code","421c273f":"code","c201564f":"code","5fed52ab":"code","3f65f56d":"code","002bc382":"code","b99fad8d":"code","f480cbb1":"code","bc94f1a5":"code","ad3c0146":"code","a93c35f8":"code","a062eefa":"code","335d2145":"code","304eb62d":"code","ae062bf0":"code","64c466b7":"code","43ba72b6":"code","6c2bbea3":"code","f2405542":"code","859623b1":"code","6836fc1f":"code","02608535":"code","ba28a153":"code","433b2526":"code","f9b2173a":"code","a87ed44f":"code","171b7b90":"markdown","cfc77447":"markdown","eceb0afd":"markdown","a7d3aaa7":"markdown","d31e9755":"markdown","cf86ef3b":"markdown","f103078f":"markdown","f977c2aa":"markdown","87342b69":"markdown","c345c676":"markdown","a7f4770d":"markdown","89802ec2":"markdown","6d63ad71":"markdown","c3f741b2":"markdown","fe7734ff":"markdown","f27c898f":"markdown","594ca5ad":"markdown","bc40e8a4":"markdown","9c5b3eea":"markdown","4386dac5":"markdown","1a170528":"markdown","b56fa0c1":"markdown","9f9d0d79":"markdown","0837f30d":"markdown","8de262ff":"markdown","f6ae2eda":"markdown","1f7417bd":"markdown","17653b00":"markdown","f5810bbf":"markdown","2bf0e719":"markdown","88f37a0d":"markdown","87ec3fbc":"markdown","ccf79ed1":"markdown","89bb4972":"markdown","95fb65b5":"markdown","76232db2":"markdown","1a67b61f":"markdown","d1e1bfb5":"markdown","580a0d7c":"markdown","84fad92c":"markdown","bccba315":"markdown","939a3ff1":"markdown","26fe263a":"markdown","a01b5c9c":"markdown"},"source":{"b6791dcb":"import pandas as pd\nimport numpy as np\nimport folium\nfrom sklearn.cluster import KMeans\n# Matplotlib and associated plotting modules\nimport matplotlib.cm as cm\nimport matplotlib.colors as colors","8030e907":"import requests\npostal_code_url = requests.get('https:\/\/en.wikipedia.org\/wiki\/List_of_postal_codes_of_Canada:_M').text","c23af675":"from bs4 import BeautifulSoup\nsoup = BeautifulSoup(postal_code_url,'lxml')","225fed07":"My_table = soup.find('table',{'class':'wikitable sortable'})","1fb33c2e":"df = pd.read_html(str(My_table))[0]\ndf","c3fab411":"df.replace('Not assigned', np.nan, inplace=True)\ndf.dropna(subset=[\"Borough\"], axis=0, inplace=True)\n\n# reset index, because we droped rows\ndf.reset_index(drop=True, inplace=True)\ndf","aa8512ce":"missing_data = df.isnull()\nfor column in missing_data.columns.values.tolist():\n    print(column)\n    print (missing_data[column].value_counts())\n    print(\"\")    ","7e63e336":"print (\"The size of the new dataset is: {} x {}\".format(df.shape[0], df.shape[1]))","06e6bb01":"# print a profile report of the dataset\nfrom pandas_profiling import ProfileReport\nprof = ProfileReport(df)\nprof.to_file(output_file='report.html')","5412ca88":"pip install pgeocode","7b17ada6":"import pgeocode\n\n# we want to retrieve the latitude\/longitude from a postal code in Canada 'ca'\nnomi = pgeocode.Nominatim('ca')\n\nlatitude = []\nlongitude = []\n\nfor index, row in df.iterrows():\n    location = nomi.query_postal_code(row[0])  # row[0] represents Postal Code value\n    latitude.append(location.latitude)\n    longitude.append(location.longitude)\n    \n# we put the result of the loop in new columns 'latitude' and 'longitude'\ndf['Latitude'] = latitude\ndf['Longitude'] = longitude\n\n\n# pb with Canada Post Gateway Processing Centre > need to do the query manually\ndf.loc[df['Neighborhood'] == \"Canada Post Gateway Processing Centre\", ['Latitude', 'Longitude']] = [43.636966,-79.615819]","421c273f":"from geopy.geocoders import Nominatim # convert an address into latitude and longitude values\n\naddress = 'Toronto, ON'\n\ngeolocator = Nominatim(user_agent=\"ca_explorer\")\nlocation = geolocator.geocode(address)\ntoronto_lat = location.latitude\ntoronto_long = location.longitude","c201564f":"# create map of TOronto using latitude and longitude values\nmap_toronto = folium.Map(location=[toronto_lat, toronto_long], zoom_start=10)\n\n# add markers to map\nfor lat, lng, borough, neighborhood in zip(df['Latitude'], df['Longitude'], df['Borough'], df['Neighborhood']):\n    label = '{}, {}'.format(neighborhood, borough)\n    label = folium.Popup(label, parse_html=True)\n    folium.CircleMarker(\n        [lat, lng],\n        radius=5,\n        popup=label,\n        color='blue',\n        fill=True,\n        fill_color='#3186cc',\n        fill_opacity=0.7,\n        parse_html=True).add_to(map_toronto)  \n    \nmap_toronto","5fed52ab":"CLIENT_ID = 'FNRS21YKKOHZNCXE2IVQX3GCUSVYOUXZKLHTG1FZR2EK2C0K' # your Foursquare ID\nCLIENT_SECRET = 'CG5K5YGHICCDTMTAAW441NHK5XPBHNR0FUKQI4BVROGIX4BE' # your Foursquare Secret\nVERSION = '20180605' # Foursquare API version\n\nprint('Your credentails:')\nprint('CLIENT_ID: ' + CLIENT_ID)\nprint('CLIENT_SECRET:' + CLIENT_SECRET)","3f65f56d":"# Get the neighborhood's latitude and longitude values\nneighborhood_latitude = df.loc[0, 'Latitude'] # neighborhood latitude value\nneighborhood_longitude = df.loc[0, 'Longitude'] # neighborhood longitude value\n\nneighborhood_name = df.loc[0, 'Neighborhood'] # neighborhood name\n\nprint('Latitude and longitude values of {} are {}, {}.'.format(neighborhood_name, \n                                                               neighborhood_latitude, \n                                                               neighborhood_longitude))","002bc382":"LIMIT = 100 # limit of number of venues returned by Foursquare API\n\nradius = 500 # define radius\n\n# create URL\nurl = 'https:\/\/api.foursquare.com\/v2\/venues\/explore?&client_id={}&client_secret={}&v={}&ll={},{}&radius={}&limit={}'.format(\n    CLIENT_ID, \n    CLIENT_SECRET, \n    VERSION, \n    neighborhood_latitude, \n    neighborhood_longitude, \n    radius, \n    LIMIT)\nurl # display URL","b99fad8d":"results = requests.get(url).json()\nresults","f480cbb1":"# function that extracts the category of the venue\ndef get_category_type(row):\n    try:\n        categories_list = row['categories']\n    except:\n        categories_list = row['venue.categories']\n        \n    if len(categories_list) == 0:\n        return None\n    else:\n        return categories_list[0]['name']","bc94f1a5":"venues = results['response']['groups'][0]['items']\n    \nnearby_venues = pd.json_normalize(venues) # flatten JSON\n\n# filter columns\nfiltered_columns = ['venue.name', 'venue.categories', 'venue.location.lat', 'venue.location.lng']\nnearby_venues =nearby_venues.loc[:, filtered_columns]\n\n# filter the category for each row\nnearby_venues['venue.categories'] = nearby_venues.apply(get_category_type, axis=1)\n\n# clean columns\nnearby_venues.columns = [col.split(\".\")[-1] for col in nearby_venues.columns]\n\nnearby_venues.head()","ad3c0146":"print('{} venues were returned by Foursquare.'.format(nearby_venues.shape[0]))","a93c35f8":"def getNearbyVenues(names, latitudes, longitudes, radius=500):\n    \n    venues_list=[]\n    for name, lat, lng in zip(names, latitudes, longitudes):\n        print(name)\n            \n        # create the API request URL\n        url = 'https:\/\/api.foursquare.com\/v2\/venues\/explore?&client_id={}&client_secret={}&v={}&ll={},{}&radius={}&limit={}'.format(\n            CLIENT_ID, \n            CLIENT_SECRET, \n            VERSION, \n            lat, \n            lng, \n            radius, \n            LIMIT)\n            \n        # make the GET request\n        results = requests.get(url).json()[\"response\"]['groups'][0]['items']\n        \n        # return only relevant information for each nearby venue\n        venues_list.append([(\n            name, \n            lat, \n            lng, \n            v['venue']['name'], \n            v['venue']['location']['lat'], \n            v['venue']['location']['lng'],  \n            v['venue']['categories'][0]['name']) for v in results])\n\n    nearby_venues = pd.DataFrame([item for venue_list in venues_list for item in venue_list])\n    nearby_venues.columns = ['Neighborhood', \n                  'Neighborhood Latitude', \n                  'Neighborhood Longitude', \n                  'Venue', \n                  'Venue Latitude', \n                  'Venue Longitude', \n                  'Venue Category']\n    \n    return(nearby_venues)","a062eefa":"toronto_venues = getNearbyVenues(names=df['Neighborhood'],\n                                   latitudes=df['Latitude'],\n                                   longitudes=df['Longitude']\n                                  )","335d2145":"print(toronto_venues.shape)\ntoronto_venues.head()","304eb62d":"# one hot encoding\ntoronto_onehot = pd.get_dummies(toronto_venues[['Venue Category']], prefix=\"\", prefix_sep=\"\")\n\n# add neighborhood column back to dataframe\ntoronto_onehot['Neighborhood'] = toronto_venues['Neighborhood'] \n\n# move neighborhood column to the first column\nfixed_columns = [toronto_onehot.columns[-1]] + list(toronto_onehot.columns[:-1])\ntoronto_onehot = toronto_onehot[fixed_columns]\n\ntoronto_onehot.head()","ae062bf0":"toronto_grouped = toronto_onehot.groupby('Neighborhood').mean().reset_index()\ntoronto_grouped","64c466b7":"num_top_venues = 5\n\nfor hood in toronto_grouped['Neighborhood']:\n    print(\"----\"+hood+\"----\")\n    temp = toronto_grouped[toronto_grouped['Neighborhood'] == hood].T.reset_index()\n    temp.columns = ['venue','freq']\n    temp = temp.iloc[1:]\n    temp['freq'] = temp['freq'].astype(float)\n    temp = temp.round({'freq': 2})\n    print(temp.sort_values('freq', ascending=False).reset_index(drop=True).head(num_top_venues))\n    print('\\n')","43ba72b6":"def return_most_common_venues(row, num_top_venues):\n    row_categories = row.iloc[1:]\n    row_categories_sorted = row_categories.sort_values(ascending=False)\n    \n    return row_categories_sorted.index.values[0:num_top_venues]","6c2bbea3":"num_top_venues = 10\n\nindicators = ['st', 'nd', 'rd']\n\n# create columns according to number of top venues\ncolumns = ['Neighborhood']\nfor ind in np.arange(num_top_venues):\n    try:\n        columns.append('{}{} Most Common Venue'.format(ind+1, indicators[ind]))\n    except:\n        columns.append('{}th Most Common Venue'.format(ind+1))\n\n# create a new dataframe\nneighborhoods_venues_sorted = pd.DataFrame(columns=columns)\nneighborhoods_venues_sorted['Neighborhood'] = toronto_grouped['Neighborhood']\n\nfor ind in np.arange(toronto_grouped.shape[0]):\n    neighborhoods_venues_sorted.iloc[ind, 1:] = return_most_common_venues(toronto_grouped.iloc[ind, :], num_top_venues)\n\nneighborhoods_venues_sorted.head()","f2405542":"# set number of clusters\nkclusters = 5\n\ntoronto_grouped_clustering = toronto_grouped.drop('Neighborhood', 1)\n\n# run k-means clustering\nkmeans = KMeans(n_clusters=kclusters, random_state=0).fit(toronto_grouped_clustering)\n\n# check cluster labels generated for each row in the dataframe\nkmeans.labels_[0:10] ","859623b1":"# add clustering labels\nneighborhoods_venues_sorted.insert(0, 'Cluster Labels', kmeans.labels_)\n\ntoronto_merged = df\n\n# merge toronto_grouped with df (toronto data) to add latitude\/longitude for each neighborhood\ntoronto_merged = toronto_merged.join(neighborhoods_venues_sorted.set_index('Neighborhood'), on='Neighborhood')\n\n# Drop \"na\" values\ntoronto_merged.dropna(subset=[\"Cluster Labels\"], axis=0, inplace=True)\n\n# Cast Cluster Labels to int\ntoronto_merged[\"Cluster Labels\"] = toronto_merged[\"Cluster Labels\"].astype(\"int64\") \n\ntoronto_merged.head()","6836fc1f":"# create map\nmap_clusters = folium.Map(location=[toronto_lat, toronto_long], zoom_start=10)\n\n# set color scheme for the clusters\nx = np.arange(kclusters)\nys = [i + x + (i*x)**2 for i in range(kclusters)]\ncolors_array = cm.rainbow(np.linspace(0, 1, len(ys)))\nrainbow = [colors.rgb2hex(i) for i in colors_array]\n\n# add markers to the map\nmarkers_colors = []\nfor lat, lon, poi, cluster in zip(toronto_merged['Latitude'], toronto_merged['Longitude'], toronto_merged['Neighborhood'], toronto_merged['Cluster Labels']):\n    label = folium.Popup(str(poi) + ' Cluster ' + str(cluster), parse_html=True)\n    folium.CircleMarker(\n        [lat, lon],\n        radius=5,\n        popup=label,\n        color=rainbow[cluster-1],\n        fill=True,\n        fill_color=rainbow[cluster-1],\n        fill_opacity=0.7).add_to(map_clusters)\n       \nmap_clusters","02608535":"toronto_merged.loc[toronto_merged['Cluster Labels'] == 0, toronto_merged.columns[[1] + list(range(5, toronto_merged.shape[1]))]]","ba28a153":"toronto_merged.loc[toronto_merged['Cluster Labels'] == 1, toronto_merged.columns[[1] + list(range(5, toronto_merged.shape[1]))]]","433b2526":"toronto_merged.loc[toronto_merged['Cluster Labels'] == 2, toronto_merged.columns[[1] + list(range(5, toronto_merged.shape[1]))]]","f9b2173a":"toronto_merged.loc[toronto_merged['Cluster Labels'] == 3, toronto_merged.columns[[1] + list(range(5, toronto_merged.shape[1]))]]","a87ed44f":"toronto_merged.loc[toronto_merged['Cluster Labels'] == 4, toronto_merged.columns[[1] + list(range(5, toronto_merged.shape[1]))]]","171b7b90":"## 1. Retrieve the data from Wikipedia page <a id=\"retrieve_wikipedia\"><\/a>","cfc77447":"## 2. Data Wrangling <a id=\"data_wrangling\"><\/a>","eceb0afd":"### Create a map of Toronto with neighborhoods superimposed on top","a7d3aaa7":"<h1 style=\"text-align:center\">Toronto Neighborhood Analysis - Capstone Project (IBM Data Science)<\/h1>","d31e9755":"#### Let's put that into a *pandas* dataframe","cf86ef3b":"#### Now write the code to run the above function on each neighborhood and create a new dataframe called *toronto_venues*.","f103078f":"### Explore Neighborhoods in Toronto","f977c2aa":"Create the dataframe from html","87342b69":"OK, no missing values in our dataset !","c345c676":"## 5. Cluster Neighborhoods <a id=\"cluster_neighborhoods\"><\/a>","a7f4770d":"In order to retrieve the latitude and the longitude from the postal code, we will use the library __pgeocode__ :","89802ec2":"### Cluster 1","6d63ad71":"### Exploration of all the neighborhoods in Toronto","c3f741b2":"Now let's create the new dataframe and display the top 10 venues for each neighborhood.","fe7734ff":"#### Let's explore the first neighborhood in our dataframe","f27c898f":"## Table of content\n\n<div class=\"alert alert-block alert-info\" style=\"margin-top: 20px\">\n\n1. [Retrieve the data from Wikipedia page](#retrieve_wikipedia)\n2. [Data Wrangling](#data_wrangling)\n3. [Exploration of the neighborhoods in Toronto](#exploration)\n4. [Analysis of Each Neighborhood](#analysis_neighborhood)\n5. [Cluster Neighborhoods](#cluster_neighborhoods)\n6. [Examine Clusters](#clusters)\n\n<\/div>\n<hr>","594ca5ad":"#### Let's print each neighborhood along with the top 5 most common venues","bc40e8a4":"### Cluster 3","9c5b3eea":"Run *k*-means to cluster the neighborhood into 5 clusters.","4386dac5":"## 3. Exploration of the neighborhoods in Toronto <a id=\"exploration\"><\/a>","1a170528":"First, let's write a function to sort the venues in descending order.","b56fa0c1":"#### Next, let's group rows by neighborhood and by taking the mean of the frequency of occurrence of each category","9f9d0d79":"Let's create a new dataframe that includes the cluster as well as the top 10 venues for each neighborhood.","0837f30d":" We know that all the information is in the *items* key. Before we proceed, let's create the **get_category_type** function :","8de262ff":"<p>Here the Neighborhoods having the same Postal Code are already in the same raw, and separated with a coma.<\/p>\n<p>Let's check that there are no missing values anymore :<p>","f6ae2eda":"#### Let's create a function to repeat the same process to all the neighborhoods in Toronto","1f7417bd":"#### Define Foursquare Credentials and Version","17653b00":"First, let's create the GET request URL :","f5810bbf":"#### Let's check the size of the resulting dataframe","2bf0e719":"### Cluster 0","88f37a0d":"Let's first scrape our wikipedia page using __BeautifulSoup__.","87ec3fbc":"#### Now, let's get the top 100 venues that are in Parkwoods within a radius of 500 meters","ccf79ed1":"## 6. Examine Clusters <a id=\"clusters\"><\/a>","89bb4972":"Drop the cells with a borough that is 'Not assigned'","95fb65b5":"Get the latitude and longitude of Toronto :","76232db2":"### Cluster 4","1a67b61f":"### Cluster 2","d1e1bfb5":"Now we are ready to clean the json and structure it into a *pandas* dataframe.","580a0d7c":"## Goal of this capstone project:\n\nUse location data in order to compare Toronto's neighborhoods and cluster them into 5 distinct groups.\nTo do that, we will have to :\n\n- Use location data and different location data providers, such as Foursquare.\n- Make RESTful API calls to the Foursquare API to retrieve data about venues in different neighborhoods around the world.\n- Be creative in situations where data are not readily available by scraping web data and parsing HTML code.\n- Make use of Folium library to generate maps of geospatial data and to communicate results and findings.","84fad92c":"Import all the libraries needed","bccba315":"Find class \u2018wikitable sortable\u2019 in the HTML script.","939a3ff1":"Let's send the GET request and examine the resutls","26fe263a":"## 4. Analysis of Each Neighborhood <a id=\"analysis_neighborhood\"><\/a>","a01b5c9c":"Finally, let's visualize the resulting clusters"}}