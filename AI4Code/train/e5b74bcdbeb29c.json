{"cell_type":{"7ed19501":"code","186e9388":"code","3deac090":"code","6d68fa49":"code","81d95666":"code","eb0ef409":"code","a8f14e2b":"code","b1e1d2ef":"code","3584fa47":"code","dc704ba1":"code","758dc835":"code","ac0ab553":"code","bf38dd63":"code","3a75d693":"code","0f0ea8cc":"code","ca4e8508":"markdown","4263c6d7":"markdown","584e3696":"markdown","969651a2":"markdown","127aface":"markdown","251b6289":"markdown","aea5ff9f":"markdown","b7601f20":"markdown","18426f38":"markdown","3ea71397":"markdown","340e011b":"markdown","0ed32598":"markdown","5211ba39":"markdown"},"source":{"7ed19501":"import pandas  as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n%matplotlib inline","186e9388":"data = pd.read_csv('..\/input\/creditcard.csv')\ndata.head(3)","3deac090":"pd.value_counts(data['Class']).plot.bar()\nplt.title('Fraud class histogram')\nplt.xlabel('Class')\nplt.ylabel('Frequency')\ndata['Class'].value_counts()","6d68fa49":"from sklearn.preprocessing import StandardScaler\n\ndata['normAmount'] = StandardScaler().fit_transform((data['Amount'].values.reshape(-1, 1)))\ndata = data.drop(['Time', 'Amount'], axis=1)\ndata.head()","81d95666":"X = np.array(data.drop(['Class'], axis=1))\ny = np.array(data['Class'])\nprint('Shape of X: {}'.format(X.shape))\nprint('Shape of y: {}'.format(y.shape))","eb0ef409":"from imblearn.over_sampling import SMOTE\n\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)\n\nprint(\"Number transactions X_train dataset: \", X_train.shape)\nprint(\"Number transactions y_train dataset: \", y_train.shape)\nprint(\"Number transactions X_test dataset: \", X_test.shape)\nprint(\"Number transactions y_test dataset: \", y_test.shape)","a8f14e2b":"print(\"Before OverSampling, counts of label '1': {}\".format(sum(y_train==1)))\nprint(\"Before OverSampling, counts of label '0': {} \\n\".format(sum(y_train==0)))\n\nsm = SMOTE(random_state=2)\nX_train_res, y_train_res = sm.fit_sample(X_train, y_train.ravel())\n\nprint('After OverSampling, the shape of train_X: {}'.format(X_train_res.shape))\nprint('After OverSampling, the shape of train_y: {} \\n'.format(y_train_res.shape))\n\nprint(\"After OverSampling, counts of label '1': {}\".format(sum(y_train_res==1)))\nprint(\"After OverSampling, counts of label '0': {}\".format(sum(y_train_res==0)))","b1e1d2ef":"from sklearn.model_selection import GridSearchCV\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import confusion_matrix, precision_recall_curve, auc, roc_auc_score, roc_curve, recall_score, classification_report\n\nparameters = { 'C': np.linspace(1, 10, 10) }\n\nlr = LogisticRegression()\nclf = GridSearchCV(lr, parameters, cv=5, verbose=5, n_jobs=3)\nclf.fit(X_train_res, y_train_res.ravel())","3584fa47":"clf.best_params_","dc704ba1":"lr1 = LogisticRegression(C=4,penalty='l2', verbose=5)\nlr1.fit(X_train_res, y_train_res.ravel())","758dc835":"import itertools\n\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=0)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        #print(\"Normalized confusion matrix\")\n    else:\n        1#print('Confusion matrix, without normalization')\n\n    #print(cm)\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","ac0ab553":"y_train_pre = lr1.predict(X_train)\n\ncnf_matrix_tra = confusion_matrix(y_train, y_train_pre)\n\nprint(\"Recall metric in the train dataset: {}%\".format(100*cnf_matrix_tra[1,1]\/(cnf_matrix_tra[1,0]+cnf_matrix_tra[1,1])))\n\n\nclass_names = [0,1]\nplt.figure()\nplot_confusion_matrix(cnf_matrix_tra , classes=class_names, title='Confusion matrix')\nplt.show()","bf38dd63":"y_pre = lr1.predict(X_test)\n\ncnf_matrix = confusion_matrix(y_test, y_pre)\n\nprint(\"Recall metric in the testing dataset: {}%\".format(100*cnf_matrix[1,1]\/(cnf_matrix[1,0]+cnf_matrix[1,1])))\n#print(\"Precision metric in the testing dataset: {}%\".format(100*cnf_matrix[0,0]\/(cnf_matrix[0,0]+cnf_matrix[1,0])))\n# Plot non-normalized confusion matrix\nclass_names = [0,1]\nplt.figure()\nplot_confusion_matrix(cnf_matrix , classes=class_names, title='Confusion matrix')\nplt.show()","3a75d693":"tmp = lr1.fit(X_train_res, y_train_res.ravel())","0f0ea8cc":"y_pred_sample_score = tmp.decision_function(X_test)\n\n\nfpr, tpr, thresholds = roc_curve(y_test, y_pred_sample_score)\n\nroc_auc = auc(fpr,tpr)\n\n# Plot ROC\nplt.title('Receiver Operating Characteristic')\nplt.plot(fpr, tpr, 'b',label='AUC = %0.3f'% roc_auc)\nplt.legend(loc='lower right')\nplt.plot([0,1],[0,1],'r--')\nplt.xlim([-0.1,1.0])\nplt.ylim([-0.1,1.01])\nplt.ylabel('True Positive Rate')\nplt.xlabel('False Positive Rate')\nplt.show()\nroc_auc","ca4e8508":"## Train Model","4263c6d7":"## See Imbalance","584e3696":"## Test Split","969651a2":"## SMOTE Oversample","127aface":"## Confusion Matrix","251b6289":"[credits](https:\/\/www.kaggle.com\/qianchao\/smote-with-imbalance-data) ","aea5ff9f":"## Libraries","b7601f20":"## Normalize Data","18426f38":"## Recall Metric","3ea71397":"## Train Model","340e011b":"## ROC Curve","0ed32598":"## Read Data","5211ba39":"## XY Label"}}