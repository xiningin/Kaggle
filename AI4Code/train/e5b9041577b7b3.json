{"cell_type":{"9a37d698":"code","b88cf2d5":"code","1e543e82":"code","bc20354f":"code","87cc7414":"code","5daacd78":"code","f8e2e272":"code","d624d0be":"code","4828a690":"code","6c9e0979":"code","59f0b935":"code","1b240d51":"code","626b7cf7":"code","3cf962b2":"code","3536e3d8":"code","5ef4f829":"code","f47214d8":"code","eb298210":"markdown","d0e97ccd":"markdown","fa2e8316":"markdown","e1c90c14":"markdown","f84d0656":"markdown","29ba29e8":"markdown","2a400c07":"markdown","35feb080":"markdown","3d5a7c39":"markdown","4dec4cb0":"markdown","150710f9":"markdown","5a1214d5":"markdown","c87949f1":"markdown"},"source":{"9a37d698":"!git clone https:\/\/github.com\/fadamsyah\/pytorch_brain_mri_segmentation.git","b88cf2d5":"cd .\/pytorch_brain_mri_segmentation","1e543e82":"import numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport matplotlib.pyplot as plt\nimport random\n\nfrom PIL import Image\nfrom sklearn.model_selection import train_test_split\nfrom torch.utils.data import DataLoader\n\nfrom lib.dataset import df_image_mask_path, BrainMRIDataset\nfrom lib.visualization import cfirst_to_clast, visualize\nfrom lib.loss import DiceLoss\nfrom lib.metrics import DiceScore\nfrom lib.augmentation import SegmentationTransforms\nfrom lib.model import UNet\nfrom lib.train import train_model\n\n%matplotlib inline","bc20354f":"# Get the dataframe containing image path\ndataset_df = df_image_mask_path(root='..\/..\/input\/lgg-mri-segmentation\/kaggle_3m')\n\n# Barplot\nplt.bar(['no-mask', 'mask'], [np.sum(dataset_df['mask'] == 0), np.sum(dataset_df['mask'] != 0)])\nplt.ylabel('count')\nplt.show()\n\n# Print 5 rows of the dataset\ndataset_df.head()","87cc7414":"# Find 10 images having mask\nidxs = []\nwhile len(idxs) < 10:\n    idx = random.randint(0, len(dataset_df) - 1)\n    if dataset_df.iloc[idx]['mask'] > 0:\n        idxs.append(idx)\n\n# PLOT\npath_img_rgb = []\npath_img_mask = []\nmask = []\n\nplt.figure(figsize=(30,8))\nfor i, idx in enumerate(idxs):        \n    img_rgb = Image.open(dataset_df.iloc[idx]['path_img_rgb'])\n    img_mask = Image.open(dataset_df.iloc[idx]['path_img_mask'])\n    \n    plt.subplot(2, 10, i + 1)\n    plt.imshow(img_rgb)\n    \n    plt.subplot(2, 10, (i + 1) + 10)\n    plt.imshow(img_mask)\n    \n    path_img_rgb.append(dataset_df.iloc[idx]['path_img_rgb'])\n    path_img_mask.append(dataset_df.iloc[idx]['path_img_mask'])\n    mask.append(dataset_df.iloc[idx]['mask'])\n\nplt.show()\n\n# print(path_img_rgb[:2])\n# print(path_img_mask[:2])\nprint(mask)","5daacd78":"# Stratified train-test-split\ndataset_df_train, dataset_df_val = train_test_split(\n    dataset_df, test_size=0.2,\n    stratify=dataset_df['mask'], random_state=42\n)","f8e2e272":"# For training data\n\nAUG_SCALE = 0.1\nAUG_ANGLE = 60.\nAUG_HFLIP_PROB = 0.5\nAUG_VFLIP_PROB = None\nAUG_SEQUENCE = ['horizontal_flip',\n                'vertical_flip',\n                'rotate','scale']\n\ntrain_aug = SegmentationTransforms(\n    scale=AUG_SCALE,\n    angle=AUG_ANGLE,\n    hflip_prob=AUG_HFLIP_PROB,\n    vflip_prob=AUG_VFLIP_PROB,\n    sequence=AUG_SEQUENCE\n)\n\nprint(train_aug)","d624d0be":"datasets = {\n    'train': BrainMRIDataset(dataset_df_train, train_aug),\n    'val': BrainMRIDataset(dataset_df_val)\n}\n\ndataset_sizes = {\n    'train': len(datasets['train']),\n    'val': len(datasets['val'])\n}","4828a690":"# Dataloader's parameter for training\nBATCH_SIZE = 64\nSHUFFLE = True\nNUM_WORKERS = 4\nDROP_LAST = True","6c9e0979":"dataloaders = {\n    'train': DataLoader(\n        datasets['train'], batch_size=BATCH_SIZE,\n        shuffle=SHUFFLE, num_workers=NUM_WORKERS,\n        drop_last=DROP_LAST, pin_memory=True),\n    'val': DataLoader(\n        datasets['val'], batch_size=BATCH_SIZE,\n        shuffle=False, num_workers=NUM_WORKERS,\n        drop_last=False, pin_memory=True)\n}","59f0b935":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")","1b240d51":"# Import the UNet model\nmodel = UNet().to(device, dtype=torch.float)","626b7cf7":"EPOCHS = 300\n\ncriterion = DiceLoss(1e-12)\nmetric = DiceScore(1e-12)\n# optimizer = optim.SGD(model.parameters(), lr=0.1, momentum=0.9, nesterov=True)\noptimizer = optim.AdamW(model.parameters(), weight_decay=1e-5, amsgrad=True)\n\n# Decay LR by a factor of 0.1 every 7 epochs\nexp_lr_scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=120, gamma=0.2)","3cf962b2":"output = train_model(device, model, dataloaders, dataset_sizes,\n                     criterion, optimizer, exp_lr_scheduler,\n                     metric, num_epochs=EPOCHS)\n\nmodel = output['model']\nhistory_loss = output['history_loss']\nhistory_metric = output['history_metric']","3536e3d8":"PATH = \"..\/state_dict_model.pt\"\ntorch.save(model.state_dict(), PATH)","5ef4f829":"plt.subplot(1,2,1)\nplt.plot(history_loss['train'], label='train')\nplt.plot(history_loss['val'], label='val')\nplt.legend()\nplt.title('Dice Loss')\n\nplt.subplot(1,2,2)\nplt.plot(history_metric['train'], label='train')\nplt.plot(history_metric['val'], label='val')\nplt.legend()\nplt.title('Dice Score')\n\nplt.show()","f47214d8":"n = 10\nn_pos = 7\nn_neg = n - n_pos\n\nidx_pos = []\nidx_neg = []\n\nimages, masks = next(iter(dataloaders['val']))\n\nfor idx, mask in enumerate(masks):\n    if torch.max(mask) > 0:\n        idx_pos.append(idx)\n    else:\n        idx_neg.append(idx)\n        \nidx = idx_pos[:n_pos]\nidx.extend(idx_neg[:n_neg])\n\nimages = images[idx]\nmasks = masks[idx]\n\nvisualize(device, model, images,\n          masks, threshold=0.5,\n          figsize=(16, 40))","eb298210":"## Plot the training history","d0e97ccd":"## Train-val split","fa2e8316":"## Create the dataloader","e1c90c14":"# Visualize the Dataset","f84d0656":"## Create the dataset","29ba29e8":"## Save the trained model","2a400c07":"# Create Dataset & DataLoader","35feb080":"## Image augmentation","3d5a7c39":"# Model Training","4dec4cb0":"## Create the UNet model","150710f9":"## Check GPU","5a1214d5":"## Visualize the result","c87949f1":"## Train the Model"}}