{"cell_type":{"d3a0d694":"code","dd7c307f":"code","eb8279f8":"code","6e9944ec":"code","8de71cce":"code","30fe7354":"code","6c764620":"code","b0e98f5b":"code","78703629":"code","dd86d8c1":"code","5d4c3e68":"code","a1dc8aab":"code","27852efc":"code","0c52380d":"code","7d6aa066":"code","bc52afc9":"code","cbf95748":"code","8e051165":"code","3485f658":"code","2de9c647":"code","64ab5a0e":"code","568c6072":"code","29f99163":"code","f6155644":"code","0a351939":"code","d23c4324":"code","ba4e9868":"code","59c8a2bd":"code","044dd753":"code","f37206a7":"code","da92984b":"code","4594367d":"code","377631e9":"code","c3808e97":"code","bf53848c":"code","7ba6b5d9":"code","1477d3f6":"code","7ba33bf7":"code","5f34b031":"code","6fada138":"code","22f947e3":"code","8b53874c":"code","6dbdcf94":"code","ad476a51":"code","ece725a5":"code","9171f93e":"code","f3b8bc42":"code","d3b1c6a9":"code","42d8e7a1":"code","d9881c8c":"code","eb73f371":"code","6a07ec5c":"code","022e0812":"code","d6690098":"code","4209189c":"code","d966e1fb":"code","c620d217":"code","600789b0":"code","2139a78b":"code","132724e6":"markdown","eac708bb":"markdown","bf5d17f6":"markdown","04ae63e9":"markdown","d22d4b7a":"markdown","0debdf4c":"markdown","f9c8a90b":"markdown","4e3a6626":"markdown","9774aa6c":"markdown","ef2a5c30":"markdown","32fe3136":"markdown","dfa7bc94":"markdown","03e842e8":"markdown","c4b5192c":"markdown","8653b3f5":"markdown","5ae5f9e4":"markdown","70ee9088":"markdown","56e645b1":"markdown","610714cd":"markdown","9780f363":"markdown","2e61b3d9":"markdown"},"source":{"d3a0d694":"\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n\nimport os\nprint(os.listdir(\"..\/input\"))\n","dd7c307f":"#Importing the data and forming the inner join between two tables\n\n\ncountry_code= pd.read_excel(\"..\/input\/Country-Code.xlsx\")\ncountry_code.head()\nprint('Shape of country code : ',country_code.shape)\n\nzomato=pd.read_csv('..\/input\/zomato.csv',encoding='latin-1')\nzomato.head()\nprint('Shape of main data : ',zomato.shape)\n\ndata=pd.merge(zomato,country_code,how='inner')\nprint('Shape of data after merging  : ',data.shape)\ndata.head()","eb8279f8":"data.columns=['Restaurant_ID', 'Restaurant_Name', 'Country_Code', 'City', 'Address',\n       'Locality', 'Locality_Verbose', 'Longitude', 'Latitude', 'Cuisines',\n       'Average_Cost_for_two', 'Currency', 'Has_Table_booking',\n       'Has_Online_delivery', 'Is_delivering_now', 'Switch_to_order_menu',\n       'Price_range', 'Aggregate_rating', 'Rating_color', 'Rating_text',\n       'Votes', 'Country']","6e9944ec":"# Helps in finding the number of null values in the whole dataset\n\ndata.isnull().sum() ","8de71cce":"#Lets see the records or ros that have null values in the Cuisines features\n\ndata[data.Cuisines.isnull()==True]\n\n#The common thing that can be observed from the records belo is that,  all the records with null vaues in the cuisine feature belongs to \"United States\"\n#Lets treat the null values after splitting the data into train ans test data. Becuase, we re however going to dropo the Cusines feature in further code.","30fe7354":"data.columns #Gives the number of columns that are in the dataset that we want to work on","6c764620":"data['Switch_to_order_menu'].value_counts() # Gives us the number of unique responses that are in \"Switch to order menu \" feature","b0e98f5b":"import matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\nplt.figure(figsize=(6,4),dpi=100)\ndata.groupby(['Country']).mean()['Price_range'].sort_values().plot(kind='barh',figsize=(10,6))","78703629":"#In this plot, number of votes given to a restauatnt on an average can be known.\n#We can observe that the votes given are highest for Asian countries(4 out of 5 are Asian) \n\n%config InlineBackend.figure_format = 'retina'\ndf=data.groupby(['Country']).mean()\nplt.figure(figsize=(8,5),frameon=True,dpi=100)\ndf['Votes'].sort_values().plot(kind='barh',figsize=(10,6))","dd86d8c1":"data['Rating_color'].value_counts() # Gives us the number of records that has Orange, White, Yellow etc,. in 'Rating Color' feature","5d4c3e68":"data['Rating_text'].value_counts() # Gives us the number of records that has AVergae, Not rated, Good etc,. in 'Rating text' feature","a1dc8aab":"# Features with the following features are droppped :\n\n# That are producing redundant information\n# That has 100% percent co relation with other features\n# The features that has no significance in predicting the rating\n# That requires NLP or other complex algorithms to analyse\n\ndata.drop(['Country_Code','Restaurant_ID', 'Restaurant_Name','Address','Locality','Locality_Verbose','Longitude', 'Latitude', 'Switch_to_order_menu','Rating_color'],axis=1,inplace=True)","27852efc":"#Lets rename the feature names without any gaps. Because, gaps in the olumn names may create trouble while indexing.\n#It is good practice to avoid spaces, gaps in the column name\n\ndata.columns=['City', 'Cuisines', 'Avg_cost', 'Currency',\n       'Table_booking', 'Online_delivery', 'Delivering_now',\n       'Price_range', 'Rating', 'Rating_text', 'Votes', 'Country']","0c52380d":"#lets create 2 dataframes in which one has target variable (i.e. Rating) and latter has predictor variables\n# X datframe has predictor variables while y datframe has target variable\n\nX=data.drop('Rating',axis=1)\ny=data['Rating']","7d6aa066":"X.isnull().sum()","bc52afc9":"#Here, I am splitting 2 dataframes into 4 parts.\n#They are 2 target variable datframes (i.e. y_train and y_test) and 2 predictor variables datframes (X_train and X_test)\n#X_train is used to train the model using predictor variables while X_test has same features as X_train which is used while testing the model\n#y_train is used as a target variable while training the model while y_test is compared with the predicted values after testing the model\n\n#Importing essential library\nfrom sklearn.model_selection import train_test_split\n\n\n#SPlitting the data into 4 datframes\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)","cbf95748":"#Helps in finding the popular cuisines\n\ndata.Cuisines.value_counts()","8e051165":"#As the number of cuisines are very high and to make the code identify each cuisines and count it, NLP might be needed.\n#So, instead of including the cuisisnes itself, we can also count the number of cuisines offered by the restaurant\n# Lets create a new feature that gives the number of cuisines offered by each restaurant\n\nX_train['no_of_cuisines'] = data.Cuisines.str.count(',')+1\nX_train.head()","3485f658":"X_test['no_of_cuisines'] = data.Cuisines.str.count(',')+1\nX_test.head()","2de9c647":"### As there are 9 null values in the cuisisnes, there are also 9 null values in the no_of_cuisines feature.","64ab5a0e":"#In the X_train datframe, lets see the number of records with different number of cuisines\n\nX_train.no_of_cuisines.value_counts()","568c6072":"#In the X_test datframe, lets see the number of records with diferent number of cuisisnes\n\nX_test.no_of_cuisines.value_counts()","29f99163":"#Imputing the null values with the model  in \"no_of_cusisnes\"\n\nX_train[\"no_of_cuisines\"].fillna(2, inplace = True)\nX_test[\"no_of_cuisines\"].fillna(2, inplace = True)","f6155644":"data.isnull().sum()","0a351939":"#A function is being created that helps in assigning continnets to their respective countries\n\ndef continent (x):\n    if (x in ['United States','Canada','Brazil']):\n        return ('Americas')\n    elif (x in ['India','Phillipines','Sri Lanka','UAE' ,'Indonesia' ,'Qatar','Singapore']):\n        return ('Asia')\n    elif (x in ['Australia','New Zealand']):\n        return ('Australia_continent')\n    elif (x in ['Turkey','United Kingdom']):\n        return ('Europe')\n    else:\n        return ('Africa')","d23c4324":"#Here the fuction is being called which creates a new feature named continent by checking with the \"Country\" feature\n\nX_train['Continent']=X_train['Country'].apply(continent)\nX_test['Continent']=X_test['Country'].apply(continent)","ba4e9868":"#Lets plot the amount spent at restaurants in different countries\n\n%config InlineBackend.figure_format = 'retina'\nplt.figure(figsize=(8,5),dpi=100)\ndata.groupby(['Country']).mean()['Avg_cost'].sort_values().plot(kind='barh',figsize=(10,6))","59c8a2bd":"conversion_rates= {'Botswana Pula(P)':0.095, 'Brazilian Real(R$)':0.266,'Dollar($)':1,'Emirati Diram(AED)':0.272,\n    'Indian Rupees(Rs.)':0.014,'Indonesian Rupiah(IDR)':0.00007,'NewZealand($)':0.688,'Pounds(\u008c\u00a3)':1.314,\n    'Qatari Rial(QR)':0.274,'Rand(R)':0.072,'Sri Lankan Rupee(LKR)':0.0055,'Turkish Lira(TL)':0.188}","044dd753":"X_train['New_cost'] = X_train['Avg_cost'] * X_train['Currency'].map(conversion_rates)\nX_test['New_cost'] = X_test['Avg_cost'] * X_test['Currency'].map(conversion_rates)","f37206a7":"plt.figure(figsize=(8,5),dpi=100)\nX_train.groupby(['Country']).mean()['New_cost'].sort_values().plot(kind='barh',figsize=(10,6))","da92984b":"def continent (x):\n    if (x in ['United States','Canada','Brazil']):\n        return ('Americas')\n    elif (x in ['India','Phillipines','Sri Lanka','UAE' ,'Indonesia' ,'Qatar','Singapore']):\n        return ('Asia')\n    elif (x in ['Australia','New Zealand']):\n        return ('Australia_continent')\n    elif (x in ['Turkey','United Kingdom']):\n        return ('Europe')\n    else:\n        return ('Africa')","4594367d":"#Here the fuction is being called which creates a new feature named continent by checking with the \"Country\" feature\n\nX_train['Continent']=X_train['Country'].apply(continent)\nX_test['Continent']=X_test['Country'].apply(continent)","377631e9":"#As model can only read numeric values, lets assign values to the rating text, Excellent being the highest(i.e. 5) and poor being the least (i.e. 1)\n# These texts will be replaced by the given numbers in train and test data. So that we can include this feature in the model \n\ndictionary = {'Excellent': 5,'Very Good': 4,'Average': 2,'Good': 3,'Not rated': 2,'Poor': 1} \nX_train.Rating_text = [dictionary[item] for item in X_train.Rating_text] \nX_test.Rating_text = [dictionary[item] for item in X_test.Rating_text] ","c3808e97":"#Here encoding is being done in both X_train and X_test dataframes\n\nBinary= {'Yes': 1,'No': 0} \n\nX_train.Online_delivery = [Binary[item] for item in X_train.Online_delivery] \nX_train.Table_booking = [Binary[item] for item in X_train.Table_booking] \nX_train.Delivering_now = [Binary[item] for item in X_train.Delivering_now] \n\nX_test.Online_delivery = [Binary[item] for item in X_test.Online_delivery] \nX_test.Table_booking = [Binary[item] for item in X_test.Table_booking] \nX_test.Delivering_now = [Binary[item] for item in X_test.Delivering_now] ","bf53848c":"print('Number of cities in the data : ',len(data.City.unique()))","7ba6b5d9":"#Lets drop avg_cost feature as new feature is created (i.e. New_cost)\n#Cuisines feature is not required as numer of cuisines is created\n# Currecny feature is not required as we have standardized everything into dollars\n# Lets drop city feature also as there are 141 different cities and when encoding is done, it may create a curse of dimensionality\n# If we feel city feature is mandatory, 141 new features will be created and to reduce the dimensions, we need to do PCA\n# In this code, as PCA is not being done, lets drop City feature too\n\nX_train.drop(['Avg_cost','Cuisines','Currency','City'],axis=1,inplace=True)\nX_test.drop(['Avg_cost','Cuisines','Currency','City'],axis=1,inplace=True)","1477d3f6":"print(X_train.shape)\nprint(X_test.shape)","7ba33bf7":"data.head().T","5f34b031":"#ENcoding is being done for continents in train and test data sets\n\ntrain_conti=pd.DataFrame(pd.get_dummies(X_train.Continent))\ntest_conti=pd.get_dummies(X_test.Continent)","6fada138":"#ENcoding is being done for countries in train and test data sets\n\ntrain_countr=pd.get_dummies(X_train.Country)\ntest_countr=pd.get_dummies(X_test.Country)","22f947e3":"#The encoded dataframes are being merged to the train and test datasets\n\nX_train=pd.concat([X_train,train_conti,train_countr],axis=1)\nX_test=pd.concat([X_test,test_conti,test_countr],axis=1)","8b53874c":"X_train.columns","6dbdcf94":"#As country and continent features are included in the datasets in the form of encoded data, lets drop the orginal features\n\nX_train.drop(['Country','Continent'],axis=1,inplace=True)\nX_test.drop(['Country','Continent'],axis=1,inplace=True)","ad476a51":"X_train.columns","ece725a5":"# Lets rename the columns in both train and test datasets\n\nX_train.columns=['Table_booking', 'Online_delivery', 'Delivering_now', 'Price_range',\n       'Rating_text', 'Votes', 'no_of_cuisines', 'New_cost', 'Africa',\n       'Americas', 'Asia', 'Australia_continent', 'Europe', 'Australia',\n       'Brazil', 'Canada', 'India', 'Indonesia', 'NewZealand', 'Phillipines',\n       'Qatar', 'Singapore', 'SouthAfrica', 'SriLanka', 'Turkey', 'UAE',\n       'UnitedKingdom', 'UnitedStates']\nX_test.columns=['Table_booking', 'Online_delivery', 'Delivering_now', 'Price_range',\n       'Rating_text', 'Votes', 'no_of_cuisines', 'New_cost', 'Africa',\n       'Americas', 'Asia', 'Australia_continent', 'Europe', 'Australia',\n       'Brazil', 'Canada', 'India', 'Indonesia', 'NewZealand', 'Phillipines',\n       'Qatar', 'Singapore', 'SouthAfrica', 'SriLanka', 'Turkey', 'UAE',\n       'UnitedKingdom', 'UnitedStates']","9171f93e":"#Importing libraries\n\nfrom sklearn import model_selection\nfrom scipy.stats import zscore\nfrom sklearn.metrics import explained_variance_score","f3b8bc42":"#Zscore scaling is being done here in both train and test datsets\n\ntrain_scale=pd.DataFrame(zscore(X_train,axis=1))\ntest_scale=pd.DataFrame(zscore(X_test,axis=1))","d3b1c6a9":"#After scaling the dataset, there will be no feature names. So, lets give feature names\n\ntrain_scale.columns=['Table_booking', 'Online_delivery', 'Delivering_now', 'Price_range',\n       'Rating_text', 'Votes', 'no_of_cuisines', 'New_cost', 'Africa',\n       'Americas', 'Asia', 'Australia_continent', 'Europe', 'Australia',\n       'Brazil', 'Canada', 'India', 'Indonesia', 'NewZealand', 'Phillipines',\n       'Qatar', 'Singapore', 'SouthAfrica', 'SriLanka', 'Turkey', 'UAE',\n       'UnitedKingdom', 'UnitedStates']\ntest_scale.columns=['Table_booking', 'Online_delivery', 'Delivering_now', 'Price_range',\n       'Rating_text', 'Votes', 'no_of_cuisines', 'New_cost', 'Africa',\n       'Americas', 'Asia', 'Australia_continent', 'Europe', 'Australia',\n       'Brazil', 'Canada', 'India', 'Indonesia', 'NewZealand', 'Phillipines',\n       'Qatar', 'Singapore', 'SouthAfrica', 'SriLanka', 'Turkey', 'UAE',\n       'UnitedKingdom', 'UnitedStates']","42d8e7a1":"#Lets see how the scaling has transformed our original data\n\ntrain_scale.head()","d9881c8c":"# Lets round off the values as after certan  nnumber of decimal places, the values does not make significant difference and becomes heavy on the computation\n\ntrain_scale=np.round(train_scale,decimals=4)\ntest_scale=np.round(test_scale,decimals=4)\ny_train=np.round(y_train,decimals=4)","eb73f371":"# implementation of Linear Regression model using scikit-learn\n\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn import metrics\nfrom sklearn.metrics import r2_score","6a07ec5c":"lr = LinearRegression() # Defing the linear regression model \nlr.fit(train_scale,y_train) #Fitting the data into the algorithm\nlr_pred = lr.predict(test_scale) #Predicting using Linear regression model\n\n#Metrics for comaprision between prediction and original values\nprint(r2_score(y_test,np.round(lr_pred,decimals=1))) \nprint('RMSE score through Linear regression : ',np.sqrt(metrics.mean_squared_error(y_test,np.round(lr_pred,decimals=1))))","022e0812":"from sklearn.tree import DecisionTreeRegressor\ndt= DecisionTreeRegressor()\ndt.fit(train_scale,y_train)\ndt_pred=dt.predict(test_scale)\nprint('RMSE score through Decision tree regression : ',np.sqrt(metrics.mean_squared_error(y_test,np.round(dt_pred,decimals=1))))","d6690098":"from sklearn.ensemble import RandomForestRegressor\nrf= RandomForestRegressor()\nrf.fit(train_scale,y_train)\nrf_pred=rf.predict(test_scale)\nprint('RMSE score through Random Forest : ',np.sqrt(metrics.mean_squared_error(y_test,np.round(rf_pred,decimals=1))))","4209189c":"import matplotlib.pyplot as plt\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(y_test,np.round(rf_pred,decimals=1),'*')\nplt.xlabel('Actual Rating',size=11)\nplt.ylabel('Predicted Ratinge using Random Forest',size=11)\nplt.show()","d966e1fb":"plt.figure(figsize=(6,4),dpi=100)\nplt.plot(y_test,rf_pred,'*',label='Random forest')\nplt.plot(y_test,dt_pred,'o',color='red',label='Decision tree',marker='s',markersize=4)\nplt.legend()\nplt.xlabel('Actual VRating',size=11)\nplt.ylabel('Predicted Rating',size=11)\nplt.show()","c620d217":"import xgboost\nxgb = xgboost.XGBRegressor(n_estimators=100, learning_rate=0.3, max_depth=4)\nxgb.fit(train_scale,y_train)\nxgb_pred= xgb.predict(test_scale)\nprint('RMSE score through XGBoost : ',np.sqrt(metrics.mean_squared_error(y_test,np.round(xgb_pred,decimals=1))))\nprint('R square value using XGBoost',r2_score(y_test,xgb_pred))\nprint('Variance covered by XG Boost Regression : ',explained_variance_score(xgb_pred,y_test))","600789b0":"plt.figure(figsize=(6,4),dpi=100)\nplt.plot(y_test,np.round(xgb_pred,decimals=1),'*')\nplt.xlabel('Actual Value',size=11)\nplt.ylabel('Predicted Value using Random Forest',size=11)\nplt.show()","2139a78b":"print('RMSE score through Linear Regression : ',np.sqrt(metrics.mean_squared_error(y_test,lr_pred)))\nprint('R square value using Linear Regression',r2_score(y_test,np.round(lr_pred,decimals=1)))\nprint('Variance covered by Linear Regression : ',explained_variance_score(lr_pred,y_test))\nprint('\\n')\nprint('RMSE score through Decision tree Regression : ',np.sqrt(metrics.mean_squared_error(y_test,dt_pred)))\nprint('R square value using Decision Tree Regression',r2_score(y_test,np.round(dt_pred,decimals=1)))\nprint('Variance covered by Decision Tree Regression : ',explained_variance_score(dt_pred,y_test))\nprint('\\n')\nprint('RMSE score through Random Forest : ',np.sqrt(metrics.mean_squared_error(y_test,np.round(rf_pred,decimals=1))))\nprint('R square value using Random Forest',r2_score(y_test,rf_pred))\nprint('Variance covered by Random Forest : ',explained_variance_score(rf_pred,y_test))\nprint('\\n')\nprint('RMSE score through XGBoost : ',np.sqrt(metrics.mean_squared_error(y_test,np.round(xgb_pred,decimals=1))))\nprint('R square value using XGBoost',r2_score(y_test,xgb_pred))\nprint('Variance covered by XG Boost Regression : ',explained_variance_score(xgb_pred,y_test))","132724e6":"### Lets create a new feature which counts the number of cuisines that a restaurant offers. The column Cuisines has few hunderds of different cuisines and some of the same cuisines are written with different spellings. Hence, it is very difficult to rectify those. However, while building a model, when encoding will be done, it will be heavy on computing and also may lead to Curse of Dimensionality as the number of features will become few hundreds.","eac708bb":"### Scaling. Lets apply zscore for the purpose of data scaling","bf5d17f6":"#### In the following plots, x axis shos the actual rating values while y axis shows the predicted ratings. Ideally when the modes predict exactly same as the actual values, there has to be a straight line passing through origin. \n\n\n#### Since, 100% accuracy is not possible, a slim distribution of points is acceptable. Slimmer the distrbution better the accuracy of the model","04ae63e9":"From the above 2 cells, we can see that Rating text and Rating color are representing the same thing in a different format. So, we can delete either of the columns.","d22d4b7a":"### Since 2 number of cuisines is mode for United States in both train and test, lets impute the null values with 3 in both X_train and X-test dataframes ","0debdf4c":"**Feature Engineering**","f9c8a90b":"### LINEAR REGRESSION","4e3a6626":"### Now, after bringing all country's cost into Dollar, we can observe that Singapore has the expensive food while India has the least expensive food. ","9774aa6c":"### As we can see that switch to order is not presenet in any of the restaurants, it does not give much information","ef2a5c30":"### XG BOOST REGRESSOR","32fe3136":"#### From the above scatter plots, we can observe that the decision tree has more spread out predictions when compared to slimmer scatter points of Random Forest. We can visually see that the Random forest has better performance than the decision tree.","dfa7bc94":"### From the above plot, we can see that the cost in Indonesia is very high which is due to the amount they pay for food. In the given data, each country's average cost is mentioned in their respective currency. Lets standardize the currency unit to Dollar. Below conversion rates are according to Google on the day of writing this code","03e842e8":"### RANDOM FOREST","c4b5192c":"### Conclusons\n\n>- XG Boost regressor has the least rmse score which indirectly tells us that it is the most accurte model among the 4 models\n>- R square value and Variance explained are almost equal\n>- Variance explained by XG Boost regressor and Random forest are amost equal\n>- Generally, Random Forest is expected to have lower RMSE than a Decsion Tree which is evident in our case study\n>- Due to the assumptions of Linear Regression algorithm which is a bit offset from the real case scenaro, Linear Regression has under performed","8653b3f5":"### Brazil has the least number of votes while Indonesia has the maximum","5ae5f9e4":"### Comparison among different models predicting the continous variable","70ee9088":"### Decision Tree regressor","56e645b1":"### There are 9 null values in the cuisines column which will be treated further\n","610714cd":"### Lets create a new feature named Continent which inlcudes respective countries that belong to a continent. This feature gives the model some extra information.","9780f363":"### Learning rate and max depth re taken in such a way that it gives the least rmse score. Mutliple scores are obtained by trial and error method.","2e61b3d9":"Lets create a new feature named Continent which inlcudes respective countries that belong to a continent. This feature gives the model some extra information."}}