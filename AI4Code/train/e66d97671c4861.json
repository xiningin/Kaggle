{"cell_type":{"93daa57a":"code","5d39b6c7":"code","aa02cc00":"code","e550eca2":"code","deb728be":"code","5da99a8b":"code","65654bbb":"code","2a10a5c5":"code","65b41107":"code","d7c0c7fd":"code","cb7dd560":"code","f5bff920":"code","b78ae307":"code","7635effc":"code","e54f82e0":"code","315785da":"markdown","fa830e7c":"markdown","6c0ad7f8":"markdown","d178d318":"markdown","ec533f4e":"markdown","1d6e87fb":"markdown","2fcf4e7e":"markdown","d445cba7":"markdown","785a763f":"markdown","cade94f5":"markdown","8de4a91e":"markdown","771f96bb":"markdown","da5227d6":"markdown","de266a05":"markdown","cad7a4fc":"markdown"},"source":{"93daa57a":"import pdb\nimport numpy as np\nimport torch\nfrom torch.autograd import grad\nimport torch.nn.functional as F\nimport matplotlib.pyplot as plt\n\n# for animation\n%matplotlib inline\nimport matplotlib.animation\nfrom IPython.display import Image\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom typing import Dict, List, Tuple","5d39b6c7":"mu1,sigma1 = -5,1\nmu2,sigma2 = 10,1\n\ngaussian1 = torch.distributions.Normal(mu1,sigma1) \ngaussian2 = torch.distributions.Normal(mu2,sigma2)","aa02cc00":"plt.figure(figsize=(14,4))\nx = torch.linspace(mu1-5*sigma1,mu1+5*sigma1,1000)\nplt.subplot(1,2,1)\nplt.plot(x.numpy(),gaussian1.log_prob(x).exp().numpy())\nplt.title(f'$\\mu={mu1},\\sigma={sigma1}$')\n\nx = torch.linspace(mu2-5*sigma2,mu2+5*sigma2,1000)\nplt.subplot(1,2,2)\nplt.plot(x.numpy(),gaussian2.log_prob(x).exp().numpy())\nplt.title(f'$\\mu={mu2},\\sigma={sigma2}$')\n\nplt.suptitle('Plotting the distributions')","e550eca2":"plt.figure(figsize=(14,4))\nx = torch.linspace(-mu1-mu2-5*sigma1-5*sigma2,mu1+mu2+5*sigma1+5*sigma2,1000)\npx = gaussian1.log_prob(x).exp() + gaussian2.log_prob(x).exp()\nplt.subplot(1,2,2)\nplt.plot(x.numpy(),px.numpy())\nplt.title('$P(X)$')","deb728be":"mu = torch.tensor([0.0])\nsigma = torch.tensor([1.0])\n\nplt.figure(figsize=(14,4))\nx = torch.linspace(-mu1-mu2-5*sigma1-5*sigma2,mu1+mu2+5*sigma1+5*sigma2,1000)\nQ = torch.distributions.Normal(mu,sigma) # this should approximate P, eventually :-)\nqx = Q.log_prob(x).exp()\nplt.subplot(1,2,2)\nplt.plot(x.numpy(),qx.detach().numpy())\nplt.title('$Q(X)$')","5da99a8b":"px = gaussian1.log_prob(x).exp() + gaussian2.log_prob(x).exp()\nqx = Q.log_prob(x).exp()\nF.kl_div(qx.log(),px)","65654bbb":"px = gaussian1.log_prob(x).exp() + gaussian2.log_prob(x).exp()\nqx = Q.log_prob(x)\nF.kl_div(qx,px)","2a10a5c5":"def optimize_loss(px: torch.tensor, loss_fn: str, muq: float = 0.0, sigmaq: float = 1.0,\\\n                  subsample_factor:int = 3,mode:str = 'min') -> Tuple[float,float,List[int]]:\n    \n    mu = torch.tensor([muq],requires_grad=True)\n    sigma = torch.tensor([sigmaq],requires_grad=True)    \n\n    opt = torch.optim.Adam([mu,sigma])\n\n    loss_val = []\n    epochs = 10000\n\n    #required for animation\n    all_qx,all_mu = [],[]\n    subsample_factor = 3 #have to subsample to reduce memory usage\n\n    torch_loss_fn = getattr(F,loss_fn)\n    for i in range(epochs):\n        Q = torch.distributions.Normal(mu,sigma) # this should approximate P\n        if loss_fn!='kl_div': # we need to exponentiate q(x) for these and few other cases\n            qx = Q.log_prob(x).exp()\n            all_qx.append(qx.detach().numpy()[::subsample_factor])\n        else:\n            qx = Q.log_prob(x)\n            all_qx.append(qx.exp().detach().numpy()[::subsample_factor])\n            \n        if mode=='min':\n            loss = torch_loss_fn(qx,px)\n        else:\n            loss = -torch_loss_fn(qx,px,dim=0)\n    #   backward pass\n        opt.zero_grad()\n        loss.backward()    \n        opt.step()\n        loss_val.append(loss.detach().numpy())\n        all_mu.append(mu.data.numpy()[0])\n        \n        \n        if i%(epochs\/\/10)==0:\n            print('Epoch:',i,'Loss:',loss.data.numpy(),'mu',mu.data.numpy()[0],'sigma',sigma.data.numpy()[0])\n\n\n    print('Epoch:',i,'Loss:',loss.data.numpy(),'mu',mu.data.numpy()[0],'sigma',sigma.data.numpy()[0])\n    \n    plt.figure(figsize=(14,6))\n    plt.subplot(2,2,1)\n    plt.plot(loss_val)\n    plt.xlabel('epoch')\n    plt.ylabel(f'{loss_fn} (Loss)')\n    plt.title(f'{loss_fn} vs epoch')\n    \n    plt.subplot(2,2,2)\n    plt.plot(all_mu)\n    plt.xlabel('epoch')\n    plt.ylabel('$\\mu$')\n    plt.title('$\\mu$ vs epoch')\n    \n    return mu.data.numpy()[0],sigma.data.numpy()[0],all_qx","65b41107":"x = torch.linspace(-mu1-mu2-5*sigma1-5*sigma2,mu1+mu2+5*sigma1+5*sigma2,1000)\npx = gaussian1.log_prob(x).exp() + gaussian2.log_prob(x).exp()\nmu,sigma,all_qx = optimize_loss(px, loss_fn='kl_div', muq = 0.0, sigmaq = 1.0)","d7c0c7fd":"def create_animation(x:torch.tensor,px:torch.tensor,all_qx:List,subsample_factor:int = 3,\\\n                     fn:str = 'anim_distr.gif') -> None:\n\n    # create a figure, axis and plot element \n    fig = plt.figure() \n    ax = plt.axes(xlim=(x.min(),x.max()), ylim=(0,0.5)) \n    text = ax.text(3,0.3,0)\n    line1, = ax.plot([], [], color = \"r\")\n    line2, = ax.plot([], [], color = \"g\",alpha=0.7)\n\n    def animate(i):    \n    #     non uniform sampling, interesting stuff happens fast initially\n        if i<75:\n            line1.set_data(x[::subsample_factor].numpy(),all_qx[i*50])\n            text.set_text(f'epoch={i*50}')\n            line2.set_data(x[::subsample_factor].numpy(),px.numpy()[::subsample_factor])\n        else:\n            line1.set_data(x[::subsample_factor].numpy(),all_qx[i*100])\n            text.set_text(f'epoch={i*100}')\n            line2.set_data(x[::subsample_factor].numpy(),px.numpy()[::subsample_factor])\n\n        return [line1,line2]\n\n    ani = matplotlib.animation.FuncAnimation(fig,animate,frames=100 \n                                   ,interval=200, blit=True)\n\n    fig.suptitle(f'Minimizing the {fn[:-3]}')\n    ax.legend(['Approximation','Actual Distribution'])\n    # save the animation as gif\n    ani.save(fn, writer='imagemagick', fps=10) ","cb7dd560":"# %% capture if you dont want to display the final image\nani = create_animation(x,px,all_qx,fn='kl_div.gif')\nImage(\"..\/working\/kl_div.gif\")","f5bff920":"x = torch.linspace(-mu1-mu2-5*sigma1-5*sigma2,mu1+mu2+5*sigma1+5*sigma2,1000)\npx = gaussian1.log_prob(x).exp() + gaussian2.log_prob(x).exp()\nmu,sigma,all_qx = optimize_loss(px, loss_fn='mse_loss', muq = 0.0, sigmaq = 1.0)","b78ae307":"fn = 'mse_loss_mean0.gif'\nani = create_animation(x,px,all_qx,fn=fn)\nImage(f\"..\/working\/{fn}\")","7635effc":"x = torch.linspace(-mu1-mu2-5*sigma1-5*sigma2,mu1+mu2+5*sigma1+5*sigma2,1000)\npx = gaussian1.log_prob(x).exp() + gaussian2.log_prob(x).exp()\nmu,sigma,all_qx = optimize_loss(px, loss_fn='mse_loss', muq = 5.0, sigmaq = 1.0)\n\nfn = 'mse_loss_mean5.gif'\nani = create_animation(x,px,all_qx,fn=fn)\nImage(f\"..\/working\/{fn}\")","e54f82e0":"x = torch.linspace(-mu1-mu2-5*sigma1-5*sigma2,mu1+mu2+5*sigma1+5*sigma2,1000)\npx = gaussian1.log_prob(x).exp() + gaussian2.log_prob(x).exp()\nmu,sigma,all_qx = optimize_loss(px, loss_fn='cosine_similarity', muq = 5.0, sigmaq = 1.0,mode='max')\n\nfn = 'cosine_similarity.gif'\nani = create_animation(x,px,all_qx,fn=fn)\nImage(f\"..\/working\/{fn}\")","315785da":"Pytorch provides easy way to obtain samples from a particular type of distribution. You can find many types of commonly used distributions in torch.distributions\nLet us first construct two gaussians with $$\\mu_{1}=-5,\\sigma_{1}=1$$ and $$\\mu_{1}=10, \\sigma_{1}=1$$","fa830e7c":"### Computing in pytorch","6c0ad7f8":"## KL-Divergence\n$$D_{KL}(P(x)||Q(X)) = \\sum_{x \\in X} P(x) \\log(P(x) \/ Q(x))$$\n","d178d318":"We can see that the result is very different from the KL divergence case. We are converging towards one of the gaussians, no middle ground !\n\nAlso, you can try expeimenting with different initial values for $\\mu_{Q}$. If you choose a value that is closer to 10 (mean of the second gaussian), it will converge towards it.","ec533f4e":"## Conclusion\nAs shown above in 1D case, we converge towards the nearest mean values. In a high dimensional space with multiple valleys, minimizing the MSE\/L1 Loss can lead to different results.  In deep learning, we are randomly initializing the weights of neural network. So, it makes sense that we converge towards different local minimas in different runs of the same neural network. \nTechniques like stochastic weight averaging perhaps improve generalizibility because they offer weights to different local minimas. Its possible that different local minimas encode important information about the dataset.\n\nIn the next post, I will try to explore Wasserstein distance.","1d6e87fb":"The Divergence is Infinity :-) I think this issue is caused when we exponentiate and then again take log. Using the log values directly seems to be fine.","2fcf4e7e":"## Constructing $Q(X)$\n\nWe will be using a gaussian distribution to approximate $P(X)$. We don't know the optimal paramters that will best approximate the distribution $P(x)$.\n\nSo, let us simply take $\\mu=0,\\sigma=1$ as our starting point. \n\nWe could chosen better values, since we already have prior knowledge about the distribution that we are trying to approximate $(P(x))$. But this is mostly not the case in real scenarios","d445cba7":"The above figure shows that the distributions have been correctly constructed.\n\nLet us add the gaussians and generate a new distribution, $P(x)$. \n\nOur aim will be to approximate this new distribution\nusing another gaussian $Q(x)$. We will try to find the parameters $\\mu_{Q},\\sigma_{Q}$ by minimizing the KL divergence between the distributions $P(x)$ and $Q(x)$","785a763f":"# Sanity Check\nLet us sample the distributions at some points to verify if its a gaussian with expected parameters","cade94f5":"I got curious about KL Divergence after reading the Variational Auto Encoder Paper. So, I decided to investigate it to get a better intuition. \n\nKL Divergence is a measure of how one probability distribution ($P$) is different from a second probability distribution ($Q$). If two distributions are identical, their KL div. should be 0. Hence, by minimizing KL div., we can find paramters of the second distribution ($Q$) that approximate $P$.\n\nIn this post i try to approximate the distribution $P$ (sum of two gaussians) by minimizing its KL divergence with another gaussian distribution $Q$.\n","8de4a91e":"# Loading Libraries","771f96bb":"# Constructing Gaussians","da5227d6":"You can easily very this to be the case for L1 loss also. \n\nNow, let us try to see what we get when we try to maximize the cosine similarity between two distributions.\n","de266a05":"Let us try to see what we get when we try to solve the Mean Squared Distance between $P$ and $Q$","cad7a4fc":"Pytorch provides function for computing KL Divergence. You can read more about it [here](https:\/\/pytorch.org\/docs\/stable\/nn.html#torch.nn.functional.kl_div).\n\nThe thing to note is that the input given is expected to contain log-probabilities. The targets are given as probabilities (i.e. without taking the logarithm).\n\nSo, the first argument to the function will be Q and second argument will be P (the target distribution).\n\nAlso, we have to be careful about numerical stabilty. "}}