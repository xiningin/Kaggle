{"cell_type":{"3c95ebe1":"code","cfa8e3bc":"code","b25eb46f":"code","f9349ab5":"code","daf0e550":"code","fdd83808":"code","a15b4c65":"code","7c9b3429":"code","981fd437":"code","9965e384":"code","6cda49b5":"code","eb597598":"markdown","0b9b0d9d":"markdown","69aebddd":"markdown","092ee445":"markdown","b99a861a":"markdown","13bd0bee":"markdown","ed96e346":"markdown","76e792d3":"markdown","16e8b92c":"markdown","8210085a":"markdown","812a6f05":"markdown","6a7fae00":"markdown","9a110076":"markdown","e9f0b0d2":"markdown"},"source":{"3c95ebe1":"from math import exp, log, pi\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nplt.style.use('seaborn')","cfa8e3bc":"def norm_pdf(x):\n    return (1.0\/((2*pi)**0.5))*exp(-0.5*x*x)","b25eb46f":"norm_pdf_dist = []\nloop = []\nfor i in range(0,10000):\n    j = i\/1000 - 5\n    loop.append(j)\n    norm_pdf_dist.append(norm_pdf(j))\n    \nplt.subplots(figsize=(6,4))\nax = sns.lineplot(x=loop, y=norm_pdf_dist)\nax.set(xlabel=\"Random Variable\", ylabel=\"Percentage\", title=\"Normal PDF\")\nplt.show()","f9349ab5":"def norm_cdf(x):\n    k = 1.0\/(1.0+0.2316419*x)\n    k_sum = k * (0.319381530 + k * (-0.356563782 + \\\n        k * (1.781477937 + k * (-1.821255978 + 1.330274429 * k))))\n\n    if x >= 0.0:\n        return (1.0 - (1.0 \/ ((2 * pi)**0.5)) * exp(-0.5 * x * x) * k_sum)\n    else:\n        return 1.0 - norm_cdf(-x)","daf0e550":"norm_cdf_dist = []\nloop_cdf = []\nfor i in range(0,10000):\n    j = i\/1000 - 5\n    loop_cdf.append(j)\n    norm_cdf_dist.append(norm_cdf(j))\n    \nplt.subplots(figsize=(6,4))\nax = sns.lineplot(x=loop, y=norm_cdf_dist)\nax.set(xlabel=\"Random Variable\", ylabel=\"Percentage\", title=\"Normal CDF\")\nplt.show()","fdd83808":"def d_j(j, S, K, r, v, T):\n    return (log(S\/K) + (r + ((-1)**(j-1))*0.5*v*v)*T)\/(v*(T**0.5))","a15b4c65":"def vanilla_call_price(S, K, r, v, T):\n    return S * norm_cdf(d_j(1, S, K, r, v, T)) - \\\n        K*exp(-r*T) * norm_cdf(d_j(2, S, K, r, v, T))\n\ndef vanilla_put_price(S, K, r, v, T):\n    return -S * norm_cdf(-d_j(1, S, K, r, v, T)) + \\\n        K*exp(-r*T) * norm_cdf(-d_j(2, S, K, r, v, T))","7c9b3429":"VCP = vanilla_call_price(100, 100, 0.0000001, 0.0000001, 10)\nVPP = vanilla_put_price(100, 100, 0.0000001, 0.0000001, 10)\n\nprint('Call Price: {}'.format(VCP))\nprint('Put Price: {}'.format(VPP))","981fd437":"VCP = vanilla_call_price(100, 50, 0.0000001, 0.0000001, 10)\nVPP = vanilla_put_price(100, 50, 0.0000001, 0.0000001, 10)\n\nprint('Call Price: {}'.format(VCP))\nprint('Put Price: {}'.format(VPP))","9965e384":"call_payoff = []\nput_payoff = []\nloop = []\nfor i in range(1,101):\n    loop.append(i)\n    call_payoff.append(vanilla_call_price(i, 50, 0.0000001, 0.0000001, 10))\n    put_payoff.append(vanilla_put_price(i, 50, 0.0000001, 0.0000001, 10))\n    \nfig, ax = plt.subplots(1,2, figsize=(12,4))\nsns.lineplot(x=loop, y=call_payoff, ax=ax[0])\nsns.lineplot(x=loop, y=put_payoff, ax=ax[1])\nax[0].set(title=\"Call Payoff\", xlabel=\"Underlying Value\", ylabel=\"Price\")\nax[1].set(title=\"Put Payoff\", xlabel=\"Underlying Value\", ylabel=\"Price\")\nplt.show()","6cda49b5":"df_call = pd.DataFrame([])\ndf_put = pd.DataFrame([])\nloop = range(1,101)\nfor v in range(1,101,20):\n    sigma = v\/100\n    df_call_t = pd.DataFrame({'{}%'.format(v): []})\n    df_put_t = pd.DataFrame({'{}%'.format(v): []})\n    \n    for i in range(1,101):\n        df_call_t = df_call_t.append({'{}%'.format(v): \n                                      vanilla_call_price(i, 50, 0.0000001, sigma, 10)},\n                                     ignore_index=True)\n        df_put_t = df_put_t.append({'{}%'.format(v): \n                                    vanilla_put_price(i, 50, 0.0000001, sigma, 10)},\n                                   ignore_index=True)\n        \n    df_call = pd.concat([df_call, df_call_t], axis=1, sort=False)\n    df_put = pd.concat([df_put, df_put_t], axis=1, sort=False)\n\nfig, ax = plt.subplots(1,2,figsize=(12,4))\nfor i in range(5):\n    sns.lineplot(x=loop, y=df_call.iloc[:,i], label=df_call.columns.values[i], ax=ax[0])\n    sns.lineplot(x=loop, y=df_put.iloc[:,i], label=df_put.columns.values[i], ax=ax[1])\n    ax[0].set(title=\"Call Payoff (by Volatility %)\", xlabel=\"Underlying Value\", ylabel=\"Price\")\n    ax[1].set(title=\"Put Payoff (by Volatility %)\", xlabel=\"Underlying Value\", ylabel=\"Price\")\n    ax[0].legend()\n    ax[1].legend()\nplt.show()","eb597598":"Below we provide examples of the Payoff functions for the Europian Call and Put option when the Strike Price is fixed at $(K=50)$ and the underlying value is variable.","0b9b0d9d":"## Black-Scholes Pricing Framework\n\nThe price of a European call $C(S,t)$ is given below, where the $S$ is the underlying asses, $K$ is the strike price, $r$ is the risk-free rate, $T$ is the time to maturity and $\\sigma$ is the (constant) volatility of the underlying $S$. Via the Black-Scholes framework, the price of a European Call is:\n\n\\begin{equation}\nC(S,t) = SN(d_1)-Ke^{-rT}N(d_2)\n\\end{equation}\n\nwith $d_1$ and $d_2$ defined as:\n\n\\begin{align*}\nd_1 &= \\frac{log(S\/K)+(r+\\frac{\\sigma^2}{2})T}{\\sigma \\sqrt{T}} \\\\\nd_2 &= d_1 - \\sigma \\sqrt{T}\n\\end{align*}\n\nLet us now introduce the ****put-call parity*** relationship which states that the relationship between the price of the European call option and European put option, both with the identical strike price $K$ and expiry $T$, has the same value as a single forward contract on this strike price and expiry. \n\nMathematically this can be represented as\n\n\\begin{equation}\nC(S,t) - P(S,t) = S(t) - K \\cdot B(t,T)\n\\end{equation}\n\nwhere $B(t,T)$ is the present value of a zero-coupon bond that matures to \\$1 AT TIME $T$ (present valuye factor for $K$.\n\nTherefore we can write the value of a European Put $P(S,t)$ as:\n\n\\begin{equation}\nP(S,t) = Ke^{-rT}-S+C(S,t) = Ke^{-rT}-S+(SN(d_1)-Ke^{-rT}N(d_2))\n\\end{equation}\n\nTwo other functions which need to be defined are the cumulative distributuon function and the probability density function of the standard normal distribution. These will not be taken for granted for the purpose of this article as:\n\n[cumulative distribution function for the standard normal distribution](http:\/\/en.wikipedia.org\/wiki\/Normal_distribution#Cumulative_distribution_function):\n\n\\begin{equation}\nN(x) = \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{x}e^{-t^2\/2}dt\n\\end{equation}\n\n[probability density function of the standard normal distribution](http:\/\/en.wikipedia.org\/wiki\/Normal_distribution#Probability_density_function):\n\n\\begin{equation}\nf(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2\/2}\n\\end{equation}\n\n\n\n","69aebddd":"**Example 2 - Strike Price less than Underlying Value $(S<K)$**\n\nConsider the same example but instead of the strike price being equal to the underlying $(S=K)$, let us assume the strike price is 50% higher than the underlying value $(S=K \\cdot 2)$. In this example the Call option would be worth the difference betweent the Underlying value and the Strike price because the option would instantly be in-the-money and could be excersised for a profit.","092ee445":"## Closed form European Call and Put Prices","b99a861a":"### Call-Put Price Interpretation\n\nConsider we are interested in pricing a European call in a simplified market where the rate $r$ and volatility $\\sigma$  is approximately zero. \n\n**Example 1 - Strike Price equal to Underlying Value $(S=K)$**\nThe price of the option is $\\sim 0$ since the option could be instantly excersised for for the same value.","13bd0bee":"Begin by importing the required packages into the Python environment.","ed96e346":"# Introduction\n\nThe purpose of this notebook is to provide an introduction to the Black-Sholes Pricing Framework and provide some example using python. We also assess the sensitivity of the price to changes in volatility. The types of options that will be covered in this notebook will only include 'vanilla' options (American and European options).","76e792d3":"![Derivative%20Pricing%20in%20Python%20%28mini%29.png](attachment:Derivative%20Pricing%20in%20Python%20%28mini%29.png)\n\n<a href=\"https:\/\/linkedin.com\/in\/ljhealy1992\">Liam Healy<\/a> $\\cdot$ Mar 18, 2019 $\\cdot$ 30 min read\n\n---\n\n> ### TL;DL \n> Introduction to pricing vanilla option in Python using the Black-Sholes Framework.","16e8b92c":"In real life conditions, not only does the underlying value of the asset changes but the market can also become more volatile and interests rates may change through time. All these factors introduce more unknowns when we are interesting in calculating the price of an option. \n\nBelow we demonstrate that the payoff curve changes significantly when the asset volatility is changed.","8210085a":"The price of a Europian Vanilla Call option $C(S,t)$ and Put $P(S,t)$ is defined in the functions below:","812a6f05":"We need to first define the normal probability density function. Given some random input variable $x$ we wish to calculate the probability of obtaining that random variable given a normal distribution. The PDF for a normal distribution is defined as:\n\n\\begin{equation}\nf(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2\/2}\n\\end{equation}","6a7fae00":"An approximation for the normal cumulative distribution is given by:\n\n\\begin{equation}\nN(x) = \\frac{1}{sqrt(2\\pi)} \\int^x_{-\\infty} e^{-\\frac{1}{2}s^2} ds\n\\end{equation}","9a110076":"Now we just need to calculate the $d_1$ and $d_2$ to complete the Black-Scholes framework. To simplify the implementation of this model we can write $d_j, j\\in {1,2}$ as the single function:\n\n\\begin{equation}\nd_j = \\frac{log(\\frac{S}{K})+(r+(-1)^{j-1} \\frac{1}{2}\\sigma^2)T}{ \\sigma \\sqrt{T}}\n\\end{equation}","e9f0b0d2":"To test that function we can plot the probabilities over some fixed range, say $x\\in (-5,5)$."}}