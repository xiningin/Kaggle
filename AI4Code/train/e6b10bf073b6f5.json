{"cell_type":{"570a1b29":"code","dbb131c0":"code","6d415979":"code","5fd6d33b":"code","6e8531c6":"code","9aee0d83":"code","2684e8d1":"code","50b3fce4":"code","c909a08f":"code","a7f8e08f":"code","56796072":"code","1dc1bf58":"code","ef701fcd":"code","12c5e5ce":"code","ff758b76":"code","bfe45b0d":"code","385e08f9":"code","9bf21590":"code","44fc1cbe":"code","2d11d607":"code","2400c1ab":"code","4bd8b404":"code","653b3aec":"code","2dde5348":"code","3fff057f":"code","6cdbd388":"code","a7c4c87e":"code","40cd5ed6":"code","f159eb23":"code","c25b4ea2":"code","de88471e":"code","a405d721":"code","7dd5e002":"code","8470d1c9":"code","fe39ea23":"code","70274862":"code","a9e6d54b":"code","b036d292":"code","e949f704":"code","45d11712":"code","7a168b59":"code","2c44a98e":"code","64ace87c":"code","fa7e3f3c":"code","11278e11":"code","d69d57c6":"code","49f225c9":"code","29e62cc1":"code","56ad5853":"code","c50d4c65":"code","9b63b8a2":"code","b6527302":"code","affffc82":"code","8236b7f2":"code","7251c8cf":"markdown","fa1a284e":"markdown","b5ce0219":"markdown","9e2bd8e5":"markdown","e2cf0006":"markdown","4fdf8609":"markdown","14cd5ceb":"markdown","a7b311e5":"markdown","e4ee0f6f":"markdown","d5dfc1af":"markdown","adbc265f":"markdown"},"source":{"570a1b29":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom pandas import datetime\nfrom sklearn.metrics import mean_squared_error\nimport warnings\nwarnings.filterwarnings(\"ignore\")","dbb131c0":"!pip install xlrd","6d415979":"!pip install openpyxl","5fd6d33b":"df= pd.read_excel('..\/input\/rbi-data\/RBI.xlsx')\ndf['Date']= pd.to_datetime(df['Date'])","6e8531c6":"\ndf.set_index('Date', inplace=True)","9aee0d83":"df.info()","2684e8d1":"df.head()","50b3fce4":"df.describe()","c909a08f":"df.plot(subplots=True)","a7f8e08f":"df.resample('M').mean().plot(subplots=True)","56796072":"df.resample('W').mean().plot()","1dc1bf58":"pd.plotting.lag_plot(df,lag=1)","ef701fcd":"from statsmodels.tsa.stattools import adfuller\nresult = adfuller(df['Value'])\nprint(f'Test Statistics: {result[0]}')\nprint(f'p-value: {result[1]}')\nprint(f'Critial Values: {result[4]}')\n\nif result[1] > 0.05 :\n  print('Series is not Stationary')\nelse:\n  print('Series is Stationary')","12c5e5ce":"from statsmodels.tsa.seasonal import seasonal_decompose\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n%matplotlib inline\nresult = seasonal_decompose(df['Value'], model='mul') \nresult.plot();","ff758b76":"import statsmodels.api as sm\nfrom statsmodels.graphics.tsaplots import plot_acf,plot_pacf\nfig= plt.figure(figsize=(15,5))\nax1= fig.add_subplot(211)\nfig= sm.graphics.tsa.plot_acf(df['Value'], ax= ax1)\nax2= fig.add_subplot(212)\nfig= sm.graphics.tsa.plot_pacf(df['Value'], ax= ax2)\nplt.show()","bfe45b0d":"!pip install pmdarima","385e08f9":"import pmdarima as pm\n\nmodel = pm.auto_arima(df['Value'], \n                        m=12, seasonal=True,\n                      start_p=0, start_q=0, max_order=4, test='adf',error_action='ignore',  \n                           suppress_warnings=True,\n                      stepwise=True, trace=True)","9bf21590":"model.summary()","44fc1cbe":"df","2d11d607":"train=df[(df.index.get_level_values(0) >= '2020-06-01') & (df.index.get_level_values(0) <= '2020-09-25')]\ntest=df[(df.index.get_level_values(0) > '2020-09-25')]","2400c1ab":"test.shape","4bd8b404":"model.fit(train['Value'])","653b3aec":"forecast=model.predict(n_periods=4, return_conf_int=True)","2dde5348":"forecast","3fff057f":"forecast_df = pd.DataFrame(forecast[0],index = test.index,columns=['Prediction'])\nforecast_df","6cdbd388":"pd.concat([df['Value'],forecast_df],axis=1).plot()","a7c4c87e":"forecast1=model.predict(n_periods=8, return_conf_int=True)","40cd5ed6":"forecast_range=pd.date_range(start='2020-09-25', periods=8)","f159eb23":"forecast1_df = pd.DataFrame(forecast1[0],index =forecast_range,columns=['Prediction'])","c25b4ea2":"pd.concat([df['Value'],forecast1_df],axis=1).plot()","de88471e":"lower=pd.Series(forecast1[1][:, 0], index =forecast_range)\nupper=pd.Series(forecast1[1][:, 1], index =forecast_range)","a405d721":"plt.plot(df['Value'])\nplt.plot(forecast1_df, color='darkgreen')\nplt.fill_between(forecast_range, \n                 lower, \n                 upper, \n                 color='k', alpha=.15)","7dd5e002":"out=model.plot_diagnostics()","8470d1c9":"!pip install fbprophet","fe39ea23":"from fbprophet import Prophet","70274862":"df","a9e6d54b":"df_final=df.reset_index()[['Date','Value']].rename({'Date':'ds','Value':'y'}, axis='columns')\ndf_final\n","b036d292":"train=df_final[(df_final['ds'] >= '2020-06-01') & (df_final['ds'] <= '2020-09-25')]\ntest=df_final[(df_final['ds'] > '2020-09-25')]","e949f704":"train.shape","45d11712":"test.shape","7a168b59":"m = Prophet(interval_width=0.95,yearly_seasonality=True)","2c44a98e":"m.fit(train)","64ace87c":"m.params","fa7e3f3c":"future = m.make_future_dataframe(periods=104)\nfuture.tail()","11278e11":"forecast = m.predict(future)\nforecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()","d69d57c6":"pd.concat([df_final.set_index('ds')['y'],forecast.set_index('ds')['yhat']],axis=1).plot()","49f225c9":"fig1 = m.plot(forecast)","29e62cc1":"fig2 = m.plot_components(forecast)","56ad5853":"from fbprophet.plot import add_changepoints_to_plot\nfig = m.plot(forecast)\na = add_changepoints_to_plot(fig.gca(), m, forecast)","c50d4c65":"deltas = m.params['delta'].mean(0)\ndeltas","9b63b8a2":"fig = plt.figure(facecolor='w')\nax = fig.add_subplot(111)\nax.bar(range(len(deltas)), deltas)\nax.grid(True, which='major', c='red', ls='-', lw=1, alpha=0.2)\nax.set_ylabel('Rate change')\nax.set_xlabel('changepoint')\nfig.tight_layout()","b6527302":"m.changepoints","affffc82":"pro_change= Prophet(changepoint_range = 0.9, yearly_seasonality=True)\nforecast = pro_change.fit(train).predict(future)\nfig= pro_change.plot(forecast);\na = add_changepoints_to_plot(fig.gca(), pro_change, forecast)","8236b7f2":"from fbprophet.plot import plot_plotly\nimport plotly.offline as py\n\nfig = plot_plotly(m, forecast)  # This returns a plotly Figure\npy.iplot(fig)","7251c8cf":"## Problem Statement:\n### ATMs filled with large amounts of cash may bring low transport\/logistic cost but high freezing & high insurance cost. On the other hand, if banks do not have the proper mechanism to track the usage pattern, then frequent re-filling ATMs will reduce freezing and insurance cost but increase logistic cost. This is important, because it will allow the goverment to gain information about the cash flow in the economy, as well as analyze the cash demand required for each ATM banks.","fa1a284e":"## Model Analysis:\n * **AutoARIMA** \n * **FBPROPHET**","b5ce0219":"## Prophet is a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects. It works best with time series that have strong seasonal effects and several seasons of historical data. Prophet is robust to missing data and shifts in the trend, and typically handles outliers well.\n\n### [Github](https:\/\/github.com\/facebook\/prophet)\n### [Docs](https:\/\/facebook.github.io\/prophet\/docs\/quick_start.html)","9e2bd8e5":"# **Facebook Prophet**","e2cf0006":"![prophet-icon-hero.jpg](https:\/\/research.fb.com\/wp-content\/uploads\/2017\/02\/prophet-icon-hero.jpg)","4fdf8609":"![autoarimafeat-850x531.jpg](https:\/\/cdn.analyticsvidhya.com\/wp-content\/uploads\/2018\/08\/autoarimafeat-850x531.jpg)","14cd5ceb":"# **Auto_ARIMA**","a7b311e5":"# RBI CASH & DEMAND FORCASTING TIMESERIES","e4ee0f6f":"# **Decompose**","d5dfc1af":"## ARIMA is a very popular statistical method for time series forecasting. ARIMA stands for **Auto-Regressive Integrated Moving Averages**. ARIMA model, we need to provide the p,d, and q values which are essential. We use statistical techniques to generate these values by performing the difference to eliminate the non-stationarity and plotting ACF and PACF graphs. In Auto ARIMA, the model itself will generate the optimal p, d, and q values which would be suitable for the data set to provide better forecasting.\n\n* https:\/\/www.analyticsvidhya.com\/blog\/2018\/08\/auto-arima-time-series-modeling-python-r\/\n* https:\/\/towardsdatascience.com\/time-series-forecasting-using-auto-arima-in-python-bb83e49210cd","adbc265f":"## Future work:\n### We can extend this model to forecast the cash demand for individual banks. Here, we have the data for ATM withdrawal across bank and so we can forecast the demand in total. However, if an individual bank forecasts the demand for their own ATMs, it can benefit them in following ways:\n\n*  **Optimizing the logistic and insurance cost,**\n\n*  **Stabilizing the cash freeze,**\n\n*  **Improving the customer goodwill and so on.**"}}