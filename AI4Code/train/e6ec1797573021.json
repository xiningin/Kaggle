{"cell_type":{"f6ebf191":"code","3c42f465":"code","504bc54d":"code","964bc208":"code","53bbbee9":"code","4b2a009d":"code","743673a2":"code","29631e58":"code","c3a5220c":"code","8c5b11a6":"code","f2fcb963":"markdown","de0a1aa2":"markdown","7dd77902":"markdown","4a7f7e4c":"markdown"},"source":{"f6ebf191":"%matplotlib inline\nfrom glob import glob\nimport os\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\ndef guess_image_dim(in_shape):\n    side_len = int(np.sqrt(in_shape))\n    if np.abs(in_shape-side_len*side_len)<2:\n        return (int(side_len), int(side_len))\n    else:\n        side_len = int(np.sqrt(in_shape\/3))\n        return (side_len, side_len, 3)\ncsv_dir = os.path.join('..', 'input', 'dermatology-mnist-loading-and-processing')","3c42f465":"all_files = sorted(glob(os.path.join(csv_dir, '*mnist*.csv')), \n                   key=lambda x: os.stat(x).st_size)[:5]\nall_df_dict = {os.path.splitext(os.path.basename(x))[0]: pd.read_csv(x) for x in all_files}\nfor c_key in all_df_dict.keys():\n    print(c_key, 'vector length:',  all_df_dict[c_key].shape[1], '->', guess_image_dim(all_df_dict[c_key].shape[1]))","504bc54d":"sns.pairplot(all_df_dict['hmnist_8_8_L'].iloc[:, list(range(10))+[-1]], hue = 'label')","964bc208":"# a few utility functions for showing MNIST-style images easily\nfrom skimage.util import montage\ndef show_data_as_images(in_df, sample=None, title='Group'):\n    fig, m_axs = plt.subplots(2, 4, figsize = (20, 10))\n    resize_dim = guess_image_dim(in_df.shape[1])\n    for c_ax, (c_label, c_rows) in zip(m_axs.flatten(), \n                                       in_df.groupby(['label'])):\n        c_images = c_rows.values[:, :-1].reshape((-1,)+resize_dim)\n        if sample is None:\n            md_args = {}\n        else:\n            md_args = {'grid_shape': (1, sample)}\n            c_images = c_images[np.random.choice(range(c_images.shape[0]), sample)]\n        if len(resize_dim)==2:\n            c_montage = montage(c_images, **md_args)\n            c_ax.matshow(c_montage, vmin=0, vmax=255, cmap='gray')\n        elif len(resize_dim)==3:\n            c_montage = np.stack([montage(c_images[:, :, :, i], **md_args) \n                                  for i in range(c_images.shape[3])],-1)\n            c_ax.imshow(c_montage)\n        \n        c_ax.set_title('{}: {}'.format(title, c_label))\n        c_ax.axis('off')\n        \ndef show_data_as_vec(in_df, title='Group'):\n    fig, m_axs = plt.subplots(2, 4, figsize = (20, 10))\n    for c_ax, (c_label, c_rows) in zip(m_axs.flatten(), \n                                       in_df.groupby(['label'])):\n        c_ax.matshow(c_rows.values.T, vmin=0, vmax=255, cmap='gray')\n        c_ax.set_title('{}: {}'.format(title, c_label))\n        c_ax.set_aspect(c_rows.shape[0]\/c_rows.shape[1])\n        c_ax.axis('off')","53bbbee9":"for c_key in all_df_dict.keys():\n    show_data_as_images(all_df_dict[c_key], sample=5, title=c_key)\n    show_data_as_vec(all_df_dict[c_key], title=c_key)","4b2a009d":"from sklearn.model_selection import train_test_split\nsample_id_count = list(all_df_dict.values())[0].shape[0]\ntrain_ids, test_ids = train_test_split(range(sample_id_count), \n                                       test_size=0.25, \n                                       random_state=2018)","743673a2":"from sklearn.metrics import confusion_matrix, accuracy_score\ndef evaluate_models(in_model_maker):\n    fig, m_axs = plt.subplots(1, 5, figsize = (25, 5))\n    for c_ax, c_key in zip(m_axs, all_df_dict.keys()):\n        c_df = all_df_dict[c_key].copy()\n        c_label = c_df.pop('label')\n        c_model = in_model_maker()\n        c_model.fit(c_df.iloc[train_ids, :], c_label.iloc[train_ids])\n        c_pred = c_model.predict(c_df.iloc[test_ids, :])\n        sns.heatmap(confusion_matrix(c_label.iloc[test_ids], c_pred), \n                    annot=True, cbar=False, fmt='d', ax=c_ax)\n        c_ax.set_title(f'Accuracy: {accuracy_score(c_label[test_ids], c_pred)*100:2.2f}%\\n{c_key}')","29631e58":"from sklearn.neighbors import KNeighborsClassifier\nevaluate_models(lambda : KNeighborsClassifier(n_jobs=4))","c3a5220c":"from sklearn.linear_model import LogisticRegression\nevaluate_models(lambda : LogisticRegression(n_jobs=4, solver='lbfgs'))","8c5b11a6":"from sklearn.ensemble import RandomForestClassifier\nevaluate_models(lambda : RandomForestClassifier(n_jobs=4))","f2fcb963":"# Show the first 10 pixels\nHere we show the distribution of the first 10 pixels for the smallest dataset (8x8)","de0a1aa2":"# Preview all the data\nHere we show all of the data and break it down by group. We can see the lowest resolution are probably far too small to interpret meaningfully.","7dd77902":"## Overview\nHere we show how to load, process and classify the CSV style data and test out a few simple models","4a7f7e4c":"# Comparing Models\nWe look at a number of different standard models for classifying the tiles\n- `KNearestNeighbors` \n- `LogisticRegression`\n- `RandomForest` \n\nThese give us a baseline for what we expect models to be able to do with these images"}}