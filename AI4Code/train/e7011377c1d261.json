{"cell_type":{"9c95701b":"code","5f45a63e":"code","99502442":"code","99733705":"code","83085c0e":"code","92bdd480":"code","45607b1c":"code","401271c2":"markdown","7ddfba1c":"markdown","7708afe6":"markdown"},"source":{"9c95701b":"\nimport torch\nimport torch.nn as nn\n","5f45a63e":"# Linear regression\n# f = w * x \n# here : f = 2 * x\n\n# 0) Training samples, watch the shape!\nX = torch.tensor([[1], [2], [3], [4]], dtype=torch.float32)\nY = torch.tensor([[2], [4], [6], [8]], dtype=torch.float32)\n\nn_samples, n_features = X.shape\nprint(f'#samples: {n_samples}, #features: {n_features}')","99502442":"\n\n# 0) create a test sample\nX_test = torch.tensor([5], dtype=torch.float32)\nprint(X_test)","99733705":"\n# 1) Design Model, the model has to implement the forward pass!\n# Here we can use a built-in model from PyTorch\ninput_size = n_features\noutput_size = n_features\n\n# we can call this model with samples X\nmodel = nn.Linear(input_size, output_size)\nprint(f'Prediction before training: f(5) = {model(X_test).item():.3f}')","83085c0e":"# 2) Define loss and optimizer\nlearning_rate = 0.02\nn_iters = 100\n\nloss = nn.MSELoss()\noptimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)\n","92bdd480":"'''\nclass LinearRegression(nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super(LinearRegression, self).__init__()\n        # define diferent layers\n        self.lin = nn.Linear(input_dim, output_dim)\n    def forward(self, x):\n        return self.lin(x)\nmodel = LinearRegression(input_size, output_size)\n'''","45607b1c":"# 3) Training loop\nfor epoch in range(n_iters):\n    # predict = forward pass with our model\n    y_predicted = model(X)\n\n    # loss\n    l = loss(Y, y_predicted)\n\n    # calculate gradients = backward pass\n    l.backward()\n\n    # update weights\n    optimizer.step()\n\n    # zero the gradients after updating\n    optimizer.zero_grad()\n\n    if epoch % 10 == 0:\n        [w, b] = model.parameters() # unpack parameters\n        print('epoch ', epoch+1, ': w = ', w[0][0].item(), ' loss = ', l)\n\nprint(f'Prediction after training: f(5) = {model(X_test).item():.3f}')","401271c2":"Credits: Python Engineer\n\nDon't hesitate to watch YouTube video. It has clear explanation\n\nhttps:\/\/youtu.be\/VVDHU_TWwUg\n\nIf you like my notebook Please upvote\n\nI will going to create more notebooks on pytorch","7ddfba1c":"1) Design model (input, output, forward pass with different layers)\n\n2) Construct loss and optimizer\n\n3) Training loop\n       - Forward = compute prediction and loss\n       - Backward = compute gradients\n       - Update weights","7708afe6":"#  we can also  use below class for model\n"}}