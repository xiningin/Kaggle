{"cell_type":{"71ddd24e":"code","6519eae0":"code","c5eda4ad":"code","73e87d6b":"code","e70f044b":"code","f9faafbc":"code","4cbc57a6":"code","815063be":"code","88c3ef89":"code","ad7ae1ca":"code","855a89f6":"code","534b0848":"code","4499c5cf":"code","8856a77d":"code","cddd62db":"code","644f6fbb":"code","1c24d136":"code","4242fa1d":"code","e2f0d437":"code","714a5b8c":"code","af0b60d6":"code","90947782":"code","3774e1d0":"markdown","1743c53b":"markdown","5ea9e281":"markdown","a736f6c7":"markdown","719f282e":"markdown","45b47ba9":"markdown","38a3328d":"markdown","2f2ba9ca":"markdown"},"source":{"71ddd24e":"import numpy as np\nimport pandas as pd\nimport os\nfrom google.cloud import bigquery\n!pip install plotly\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\ninit_notebook_mode(connected=True)","6519eae0":"client = bigquery.Client()\nethereum_classic_dataset_ref = client.dataset('crypto_ethereum_classic', project='bigquery-public-data')","c5eda4ad":"query = \"\"\"\nWITH mined_block AS (\n  SELECT miner, DATE(timestamp)\n  FROM `bigquery-public-data.crypto_ethereum_classic.blocks` \n  WHERE DATE(timestamp) > DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH)\n  ORDER BY miner ASC)\nSELECT miner, COUNT(miner) AS total_block_reward \nFROM mined_block \nGROUP BY miner \nORDER BY total_block_reward DESC\nLIMIT 10\n\"\"\"\n\nquery_job = client.query(query)\niterator = query_job.result()","73e87d6b":"rows = list(iterator)\n# Transform the rows into a nice pandas dataframe\ntop_miners = pd.DataFrame(data=[list(x.values()) for x in rows], columns=list(rows[0].keys()))\n# Look at the first 10 headlines\ntop_miners.head(10)","e70f044b":"from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nimport plotly.graph_objs as go","f9faafbc":"labels = top_miners['miner']\nvalues = top_miners['total_block_reward']\n\ntrace = go.Pie(labels=labels, values=values)\n\niplot([trace])","4cbc57a6":"query = \"\"\"\n#standardSQL\n-- MIT License\n-- Copyright (c) 2019 Yaz Khoury, yaz.khoury@gmail.com\n\nSELECT miner, \n    DATE(timestamp) as date,\n    COUNT(miner) as total_block_reward\nFROM `bigquery-public-data.crypto_ethereum_classic.blocks` \nGROUP BY miner, date\nHAVING COUNT(miner) > 100\nORDER BY date, COUNT(miner) ASC\n\"\"\"\nquery_job = client.query(query)\niterator = query_job.result()","815063be":"rows = list(iterator)\n# Transform the rows into a nice pandas dataframe\ntop_miners_by_date = pd.DataFrame(data=[list(x.values()) for x in rows], columns=list(rows[0].keys()))\ntop_miners_by_date.head(10)","88c3ef89":"date_series = top_miners_by_date['date'].unique()\ndate_series","ad7ae1ca":"traces = []\nminer_series = top_miners_by_date['miner'].unique()\n\nfor index, miner in enumerate(miner_series):\n    miner_reward_by_date = top_miners_by_date.loc[top_miners_by_date['miner'] == miner]\n    miner_reward = miner_reward_by_date['total_block_reward']\n    miner_date = miner_reward_by_date['date']\n    trace = dict(\n        x=miner_date,\n        y=miner_reward,\n        mode='lines',\n        stackgroup='one'\n    )\n    traces.append(trace)\nfig = dict(data=traces)\n\niplot(fig)","855a89f6":"query = \"\"\"\n#standardSQL\n-- MIT License\n-- Copyright (c) 2019 Yaz Khoury, yaz.khoury@gmail.com\n\nWITH total_reward_book AS (\n  SELECT miner, \n    DATE(timestamp) as date,\n    COUNT(miner) as total_block_reward\n  FROM `bigquery-public-data.crypto_ethereum_classic.blocks` \n  GROUP BY miner, date\n  HAVING COUNT(miner) > 100\n),\ntotal_reward_book_by_date AS (\n SELECT date, \n        miner AS address, \n        SUM(total_block_reward \/ POWER(10,0)) AS value\n  FROM total_reward_book\n  GROUP BY miner, date\n),\ndaily_rewards_with_gaps AS (\n  SELECT\n    address, \n    date,\n    SUM(value) OVER (PARTITION BY ADDRESS ORDER BY date) AS block_rewards,\n    LEAD(date, 1, CURRENT_DATE()) OVER (PARTITION BY ADDRESS ORDER BY date) AS next_date\n  FROM total_reward_book_by_date\n),\ncalendar AS (\n  SELECT date \n  FROM UNNEST(GENERATE_DATE_ARRAY('2015-07-30', CURRENT_DATE())) AS date\n),\ndaily_rewards AS (\n  SELECT address, \n    calendar.date, \n    block_rewards\n  FROM daily_rewards_with_gaps\n  JOIN calendar ON daily_rewards_with_gaps.date <= calendar.date \n  AND calendar.date < daily_rewards_with_gaps.next_date\n),\nsupply AS (\n  SELECT date,\n    SUM(block_rewards) AS total_rewards\n  FROM daily_rewards\n  GROUP BY date\n),\nranked_daily_rewards AS (\n  SELECT daily_rewards.date AS date,\n    block_rewards,\n    ROW_NUMBER() OVER (PARTITION BY daily_rewards.date ORDER BY block_rewards DESC) AS rank\n  FROM daily_rewards\n  JOIN supply ON daily_rewards.date = supply.date\n  WHERE SAFE_DIVIDE(block_rewards, total_rewards) >= 0.01\n  ORDER BY block_rewards DESC\n),\ndaily_gini AS (\n  SELECT date,\n    -- (1 \u2212 2B) https:\/\/en.wikipedia.org\/wiki\/Gini_coefficient\n    1 - 2 * SUM((block_rewards * (rank - 1) + block_rewards \/ 2)) \/ COUNT(*) \/ SUM(block_rewards) AS gini\n  FROM ranked_daily_rewards\n  GROUP BY DATE\n)\nSELECT date,\n  gini,\n  AVG(gini) OVER (ORDER BY date ASC ROWS 7 PRECEDING) AS gini_sma_7,\n  AVG(gini) OVER (ORDER BY date ASC ROWS 30 PRECEDING) AS gini_sma_30\nFROM daily_gini\nORDER BY date ASC\n\"\"\"\n\nquery_job = client.query(query)\niterator = query_job.result()","534b0848":"rows = list(iterator)\n# Transform the rows into a nice pandas dataframe\nmining_reward_gini_by_date = pd.DataFrame(data=[list(x.values()) for x in rows], columns=list(rows[0].keys()))\nmining_reward_gini_by_date.head(10)","4499c5cf":"traces = []\nx = mining_reward_gini_by_date['date']\ngini_list = ['gini', 'gini_sma_7', 'gini_sma_30']\nfor gini in gini_list:\n    y = mining_reward_gini_by_date[gini]\n    trace = dict(\n        x=x,\n        y=y,\n        hoverinfo=f'{gini}',\n        mode='lines'\n    )\n    traces.append(trace)\nfig = dict(data=traces)\n\niplot(fig, validate=False)","8856a77d":"query = \"\"\"\nwith double_entry_book as (\n    -- debits\n    select to_address as address, value as value\n    from `bigquery-public-data.crypto_ethereum_classic.traces`\n    where to_address is not null\n    and status = 1\n    and (call_type not in ('delegatecall', 'callcode', 'staticcall') or call_type is null)\n    union all\n    -- credits\n    select from_address as address, -value as value\n    from `bigquery-public-data.crypto_ethereum_classic.traces`\n    where from_address is not null\n    and status = 1\n    and (call_type not in ('delegatecall', 'callcode', 'staticcall') or call_type is null)\n    union all\n    -- transaction fees debits\n    select miner as address, sum(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) as value\n    from `bigquery-public-data.crypto_ethereum_classic.transactions` as transactions\n    join `bigquery-public-data.crypto_ethereum_classic.blocks` as blocks on blocks.number = transactions.block_number\n    group by blocks.miner\n    union all\n    -- transaction fees credits\n    select from_address as address, -(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) as value\n    from `bigquery-public-data.crypto_ethereum_classic.transactions`\n)\nselect address, \nsum(value) \/ 1000000000 as balance\nfrom double_entry_book\ngroup by address\norder by balance desc\nlimit 20\n\"\"\"\n\nquery_job = client.query(query)\niterator = query_job.result()","cddd62db":"rows = list(iterator)\n# Transform the rows into a nice pandas dataframe\ntop_address_rich_list = pd.DataFrame(data=[list(x.values()) for x in rows], columns=list(rows[0].keys()))\ntop_address_rich_list.head(10)","644f6fbb":"labels = top_address_rich_list['address']\nvalues = top_address_rich_list['balance']\n\ntrace = go.Pie(labels=labels, values=values)\n\niplot([trace])","1c24d136":"query = \"\"\"\nwith \ndouble_entry_book as (\n    -- debits\n    select to_address as address, value as value, block_timestamp\n    from `bigquery-public-data.crypto_ethereum_classic.traces`\n    where to_address is not null\n    and status = 1\n    and (call_type not in ('delegatecall', 'callcode', 'staticcall') or call_type is null)\n    union all\n    -- credits\n    select from_address as address, -value as value, block_timestamp\n    from `bigquery-public-data.crypto_ethereum_classic.traces`\n    where from_address is not null\n    and status = 1\n    and (call_type not in ('delegatecall', 'callcode', 'staticcall') or call_type is null)\n    union all\n    -- transaction fees debits\n    select miner as address, sum(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) as value, block_timestamp\n    from `bigquery-public-data.crypto_ethereum_classic.transactions` as transactions\n    join `bigquery-public-data.crypto_ethereum_classic.blocks` as blocks on blocks.number = transactions.block_number\n    group by blocks.miner, block_timestamp\n    union all\n    -- transaction fees credits\n    select from_address as address, -(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) as value, block_timestamp\n    from `bigquery-public-data.crypto_ethereum_classic.transactions`\n),\ndouble_entry_book_by_date as (\n    select \n        date(block_timestamp) as date, \n        address, \n        sum(value \/ POWER(10,0)) as value\n    from double_entry_book\n    group by address, date\n),\ndaily_balances_with_gaps as (\n    select \n        address, \n        date,\n        sum(value) over (partition by address order by date) as balance,\n        lead(date, 1, current_date()) over (partition by address order by date) as next_date\n        from double_entry_book_by_date\n),\ncalendar as (\n    select date from unnest(generate_date_array('2015-07-30', current_date())) as date\n),\ndaily_balances as (\n    select address, calendar.date, balance\n    from daily_balances_with_gaps\n    join calendar on daily_balances_with_gaps.date <= calendar.date and calendar.date < daily_balances_with_gaps.next_date\n),\n supply as (\n    select\n        date,\n        sum(balance) as daily_supply\n    from daily_balances\n    group by date\n),\nranked_daily_balances as (\n    select \n        daily_balances.date,\n        balance,\n        row_number() over (partition by daily_balances.date order by balance desc) as rank\n    from daily_balances\n    join supply on daily_balances.date = supply.date\n    where safe_divide(balance, daily_supply) >= 0.0001\n    ORDER BY safe_divide(balance, daily_supply) DESC\n), \ngini_daily as (\n   select\n    date,\n    -- (1 \u2212 2B) https:\/\/en.wikipedia.org\/wiki\/Gini_coefficient\n    1 - 2 * sum((balance * (rank - 1) + balance \/ 2)) \/ count(*) \/ sum(balance) as gini\n  from ranked_daily_balances\n  group by date\n)\nselect date,\n    gini,\n    avg(gini) over (order by date asc rows 7 preceding) as gini_sma7,\n    avg(gini) over (order by date asc rows 30 preceding) as gini_sma30\nfrom gini_daily\norder by date asc\n\"\"\"\n\nquery_job = client.query(query)\niterator = query_job.result()","4242fa1d":"rows = list(iterator)\n# Transform the rows into a nice pandas dataframe\ndaily_balance_gini = pd.DataFrame(data=[list(x.values()) for x in rows], columns=list(rows[0].keys()))\ndaily_balance_gini.head(10)","e2f0d437":"traces = []\nx = daily_balance_gini['date']\ngini_list = ['gini', 'gini_sma7', 'gini_sma30']\nfor gini in gini_list:\n    y = daily_balance_gini[gini]\n    trace = dict(\n        x=x,\n        y=y,\n        hoverinfo=f'{gini}',\n        mode='lines'\n    )\n    traces.append(trace)\nfig = dict(data=traces)\n\niplot(fig, validate=False)","714a5b8c":"query = \"\"\"\n#standardSQL\n-- MIT License\n-- Copyright (c) 2019 Yaz Khoury, yaz.khoury@gmail.com\n\nWITH block_rows AS (\n  SELECT *, ROW_NUMBER() OVER (ORDER BY timestamp) AS rn\n  FROM `bigquery-public-data.crypto_ethereum_classic.blocks`\n),\ndelta_time AS (\n  SELECT\n  mp.timestamp AS block_time,\n  mp.difficulty AS difficulty,\n  TIMESTAMP_DIFF(mp.timestamp, mc.timestamp, SECOND) AS delta_block_time\n  FROM block_rows mc\n  JOIN block_rows mp\n  ON mc.rn = mp.rn - 1\n),\nhashrate_book AS (\n  SELECT TIMESTAMP_TRUNC(block_time, DAY) AS block_day,\n  AVG(delta_block_time) as daily_avg_block_time,\n  AVG(difficulty) as daily_avg_difficulty\n  FROM delta_time\n  GROUP BY TIMESTAMP_TRUNC(block_time, DAY)\n)\nSELECT block_day,\n(daily_avg_difficulty\/daily_avg_block_time)\/1000000000 as hashrate\nFROM hashrate_book\nORDER BY block_day ASC\n\"\"\"\n\nquery_job = client.query(query)\niterator = query_job.result()","af0b60d6":"rows = list(iterator)\n# Transform the rows into a nice pandas dataframe\ndaily_hashrate = pd.DataFrame(data=[list(x.values()) for x in rows], columns=list(rows[0].keys()))\ndaily_hashrate.head(10)","90947782":"trace = go.Scatter(\n    x=daily_hashrate['block_day'],\n    y=daily_hashrate['hashrate'],\n    mode='lines'\n)\ndata = [trace]\niplot(data)","3774e1d0":"# Ethereum Classic as a BigQuery Dataset\n\nIn preparation for the Ethereum Classic dataset being available on Google BigQuery, we prepared a few awesome queries you can run here on this Kaggle notebook. \n\nThis notebook will go over queries you can run for Ethereum Classic, including getting top rich list, hashrate analysis, and daily gini coefficient measurement. Some queries will try to compare with other blockchain networks.\n\nWe will also be plotting our queries with [Plotly](https:\/\/plot.ly\/), which we will be installing in this notebook.","1743c53b":"## Top Miners By Rewards in the Last 30 Days\n\nHere, we try to find out who are the top miners by the address of the block mined in the last 30 days. We will run the following query as a string in python through the BigQuery client.\n```\nWITH mined_block AS (\n  SELECT miner, DATE(timestamp)\n  FROM `bigquery-public-data.ethereum_classic_blockchain.blocks` \n  WHERE DATE(timestamp) > DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH)\n  ORDER BY miner ASC)\nSELECT miner, COUNT(miner) AS total_block_reward \nFROM mined_block \nGROUP BY miner \nORDER BY total_block_reward ASC\n```\n\nLet's run it.","5ea9e281":"# Daily Hashrate\n\nHashrate is a measure of difficulty over block time. We can measure this by getting the delta time of each block timestamp from the previous block timestamp.\n\nWe can average it out by day. That is, the query can average out all difficulty and delta times per day and divide them by one another. We can further divide by 1 billion to get the GH\/s.\n\nWe will use the following query I wrote for the Daily Hashrate.\n\n```\n#standardSQL\n-- MIT License\n-- Copyright (c) 2019 Yaz Khoury, yaz.khoury@gmail.com\n\nWITH block_rows AS (\n  SELECT *, ROW_NUMBER() OVER (ORDER BY timestamp) AS rn\n  FROM `bigquery-public-data.crypto_ethereum_classic.blocks`\n),\ndelta_time AS (\n  SELECT\n  mp.timestamp AS block_time,\n  mp.difficulty AS difficulty,\n  TIMESTAMP_DIFF(mp.timestamp, mc.timestamp, SECOND) AS delta_block_time\n  FROM block_rows mc\n  JOIN block_rows mp\n  ON mc.rn = mp.rn - 1\n),\nhashrate_book AS (\n  SELECT TIMESTAMP_TRUNC(block_time, DAY) AS block_day,\n  AVG(delta_block_time) as daily_avg_block_time,\n  AVG(difficulty) as daily_avg_difficulty\n  FROM delta_time\n  GROUP BY TIMESTAMP_TRUNC(block_time, DAY)\n)\nSELECT block_day,\n(daily_avg_difficulty\/daily_avg_block_time)\/1000000000 as hashrate\nFROM hashrate_book\nORDER BY block_day ASC\n```","a736f6c7":"## Daily Top Balance Gini Coefficient\n\nNow, we will try getting daily top rich list from the genesis until now and then calculate the gini coefficient of the rich list.\n\nIn this context, the gini coefficient will be a measure of income inequality among wallet addresses based on how much ether balance is in each wallet. Of course, this assumes 1 person = 1 wallet, but a person can have multiple wallets. It will also query for top 10k addresses to be used in gini analysis. That will include exchange account balances, which we don't take into account eliminating from the dataset.\n\nThe query was written by from **[Evegeny Medvedev and Allen Day for this Google Blog Post](https:\/\/cloud.google.com\/blog\/products\/data-analytics\/introducing-six-new-cryptocurrencies-in-bigquery-public-datasets-and-how-to-analyze-them)**. I added some further analysis towards the end to measure the Simple Moving Average of the Gini for the past 7 and 30 days.","719f282e":"## Latest Daily Balance of Ethereum Classic (Top 20 Rich List)\n\nThis next query, adapted from this [Medium post by Evgeny Medvedev](https:\/\/medium.com\/google-cloud\/how-to-query-balances-for-all-ethereum-addresses-in-bigquery-fb594e4034a7) will get us the latest daily balance for Ethereum Classic.\n\nWe can order it by balance, getting us a nice rich list we can plot.","45b47ba9":"## Plotly Library for Plotting\nIn this notebook, we will be using [Plotly](https:\/\/plot.ly\/) for plotting our charts. You can sign up for a free account to get your API key in order to generate the charts if you choose to run this notebook on your own.\n\nLet's start by plotting the top miners by their block reward as a pie chart.","38a3328d":"## Top Miners By Block Rewards All Time\n\nNow, let's make it more interesting and plot the total rewards of everyone who has ever mined Ethereum Classic from the genesis block.\n\nWe will limit it to just miners who's daily block rewards are greater than 100. This allows us to save on computing and plotting the traces in this Kaggle notebook.\n\nWe can use the query here:\n```\n#standardSQL\n-- MIT License\n-- Copyright (c) 2019 Yaz Khoury, yaz.khoury@gmail.com\n\nSELECT miner, \n    DATE(timestamp) as date,\n    COUNT(miner) as total_block_reward\nFROM `bigquery-public-data.crypto_ethereum_classic.blocks` \nGROUP BY miner, date\nHAVING COUNT(miner) > 100\nORDER BY date, COUNT(miner) ASC\n```","2f2ba9ca":"## Daily Gini Coefficient of Ethereum Classic Mining Rewards By Miners\n\nNow, we shall compute the [Gini coefficient](https:\/\/en.wikipedia.org\/wiki\/Gini_coefficient).\n\nThe Gini coefficient is a statistical measure of distribution used to measure income or wealth distribution among a population. From the [Investopedia article](https:\/\/www.investopedia.com\/terms\/g\/gini-index.asp):\n> A country in which every resident has the same income would have an income Gini coefficient of 0. A country in which one resident earned all the income, while everyone else earned nothing, would have an income Gini coefficient of 1.\n\nHere, we are calculating the daily block reward distribution among addresses based on which mining address received a block daily.\n\nThe query uses what was constructed earlier and borrows from the implementation of the [Daily Balance Gini query](https:\/\/medium.com\/google-cloud\/calculating-gini-coefficient-in-bigquery-3bc162c82168) here. \n\nAlso, just for fun, we shall calculate the [Simple Moving Average](https:\/\/www.investopedia.com\/terms\/s\/sma.asp) of the Gini, using a 7 and 30 day windows. Simple Moving Average of SMA takes a set of values and their time periods, averages out a sum of the values divided by the chosen time window. \n\nThe query value for those here will be `gini_sma_7` and `gini_sma_30`.\n\nPlease not that this only calculates the gini of those miners who earned more than 1% of the block rewards in a day, otherwise, it'll always go to 1 due to many mining just 1 block."}}