{"cell_type":{"7a1d68b9":"code","9b1053e8":"code","2cb43d03":"code","d537011a":"code","971398e2":"code","e49b8c2a":"code","3efa9256":"code","f8af1aa3":"code","fec6338b":"code","8b35594c":"code","ab5bcd82":"markdown","aee7bdd4":"markdown","356e7a21":"markdown","84af0ae8":"markdown"},"source":{"7a1d68b9":"import plotly.graph_objects as go\nimport plotly\nfrom plotly.subplots import make_subplots\nimport warnings\nfrom time import *\nimport pandas as pd\nimport locale\nimport plotly.express as px\nimport dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output\nimport pandas as pd\nfrom bs4 import BeautifulSoup\nfrom geopy.geocoders import Nominatim\nfrom selenium import webdriver\nfrom time import *\nimport datetime\nimport requests, json\nimport pycountry\nimport pycountry_convert as pc\n\n# This for conversion of numerics\n#locale.setlocale(locale.LC_ALL, 'en_US')\nwarnings.filterwarnings(\"ignore\")\n","9b1053e8":"# This is latitude and longtitude location of some countries the data will often refer from this .If its not found here it will fetch through the api\ncord={'Spain': [-4, 39], 'Nigeria': [7, 9], 'Hungary': [19, 47], 'Chile': [-71, -31], 'Iceland': [-18, 64], 'Australia': [134, -24], 'Morocco': [-7, 31], 'Sweden': [14, 59], 'United States': [-100, 39], 'Uruguay': [-56, -32], 'Switzerland': [8, 46], 'Finland': [25, 63], 'Indonesia': [117, -2], 'Italy': [12, 42], 'Romania': [24, 45], 'Afghanistan': [66, 33], 'Belgium': [4, 50], 'Germany': [10, 51], 'Peru': [-75, -6], 'Bolivia': [-64, -17], 'Sri Lanka': [80, 7], 'Portugal': [-7, 40], 'Ukraine': [31, 49], 'United Kingdom': [-3, 55], 'Cambodia': [104, 13], 'Iran': [54, 32], 'Mexico': [-100, 22], 'Tunisia': [9, 33], 'Brazil': [-53, -10], 'India': [78, 22], 'Montenegro': [19, 42], 'Japan': [139, 36], 'Austria': [13, 47], 'Dominican Republic': [-70, 19], 'Croatia': [17, 45], 'Moldova': [28, 47], 'Armenia': [44, 40], 'Iraq': [44, 33], 'Algeria': [2, 28], 'Argentina': [-64, -34], 'Philippines': [122, 12], 'Norway': [9, 60], 'China': [104, 35], 'Canada': [-107, 61], 'Ecuador': [-79, -1]}\n\n#This is one of the sample of prepared dataset.To need to generate this we need to run the prep() function.\ndf=pd.read_csv('..\/input\/file6.csv')\nprint(df.head().to_string())\n\n#This is the map box access token inorder to use scatter_mapbox its necessary.\nmapbox_accesstoken='pk.eyJ1Ijoic3VkaGFuMjQ3IiwiYSI6ImNrOWZ3OHFzNjA2eDYzZGxpdjhteGk5aHAifQ.rgLrTsuLxjeMS9LbXJMxWA'\npx.set_mapbox_access_token(mapbox_accesstoken)\n\n","2cb43d03":"#Function to convert numerics to local Format\ndef strv(arg):\n    return locale.format(\"%d\", arg, grouping=True)\n\n#Function to get continent name with the given country name\ndef getcontinent(country_name):\n    country_alpha2 = pc.country_name_to_country_alpha2(country_name)\n    country_continent_code = pc.country_alpha2_to_continent_code(country_alpha2)\n    country_continent_name = pc.convert_continent_code_to_continent_name(country_continent_code)\n    return country_continent_name\n\n#To get the ISO code of the country to retrieve the exact details of the patricular country.\ndef getcode(arg):\n    try:\n        return ((pycountry.countries.search_fuzzy(arg)[0].alpha_3))\n    except:\n        return 'KR'\n","d537011a":"#To prepare the latitude and longtitude of the countries which are already saved through the previous results.\ndef get_locations():\n    data=pd.read_csv('Locations.csv')\n    dic=dict()\n    for row in data.to_dict(orient=\"row\"):\n        dic[(row['Country'],row['City'])]=[row['Latitude'],row['Longtitude']]\n    return dic\n\n#This is to handle the exceptional situations on finding the latitude and longtitude of certain countries which cannot be found with Nominatim.\ndef getaddress(address):\n    url = 'http:\/\/photon.komoot.de\/api\/?q='\n    resp = requests.get(url=url+address)\n    data = json.loads(resp.text)\n    return(data['features'][0]['geometry']['coordinates'])\n\n#To clean the numbers retrieved\ndef intnew(arg):\n    s='0'\n    for i in arg:\n        if i.isdigit():\n            s+=i\n    return int(s)\n\n#Start time\nst=time()\n\n#This function is to calculate the estimated time of arrival\ndef eta(seconds):\n    sec=seconds-st\n    return \"ETA: \"+str(datetime.timedelta(seconds=sec))\n\n\n","971398e2":"#This function is used to retrieve the information of a paricular country along with its states.\ndef retrivecountry(inp,country):\n    soup = BeautifulSoup(inp, 'html.parser')\n    #This is the div element containing country name\n    mydivs = soup.findAll(\"div\", {\"class\": \"BLWS2\"})\n    cities=[]\n    for i in mydivs:\n        cities.append(i.text)\n    #This the div element containing the count of each city.\n    mydivs = soup.findAll(\"div\", {\"class\": \"QM7g5b\"})\n    lis=[]\n    for i in mydivs:\n        lis.append(intnew(i.text))\n    lis=[lis[i:i+3] for i in range(0, len(lis),3)]\n    final=[]\n    for i in range(len(cities)):\n        final.append([country]+[cities[i]]+lis[i])\n    return final\n","e49b8c2a":"#This function is used for the preparation of datasets.\ndef prep():\n    countries=['Afghanistan', 'Algeria', 'Argentina', 'Australia', 'Austria', 'Belgium', 'Bolivia', 'Brazil', 'Cambodia', 'Canada', 'Chile', 'China', 'Croatia', 'Dominican Republic', 'Ecuador', 'Finland', 'Germany', 'Hungary', 'Iceland', 'India', 'Indonesia', 'Iran', 'Iraq', 'Ireland', 'Italy', 'Japan', 'Mexico', 'Moldova', 'Montenegro', 'Morocco', 'Nigeria', 'Norway', 'Pakistan', 'Peru', 'Philippines', 'Portugal', 'Romania', 'Slovakia', 'South Korea', 'Spain', 'Sri Lanka', 'Sweden', 'Switzerland', 'Tunisia', 'Ukraine', 'United Kingdom', 'United States', 'Uruguay']\n    driver = webdriver.Chrome()\n    data=[['Country','City','Confirmed','Recovered','Deaths','Latitude','Longtitude','Codes','Continent']]\n    codes=dict()\n    conts=dict()\n    for i in range(len(countries)):\n        \n        #Making a google search to retrieve the results\n        url=\"https:\/\/www.google.com\/search?q=covid+stats+\"+countries[i]\n        driver.get(url)\n        if url!=driver.current_url:\n            \n            #To avoid human robot check of google\n            driver.close()\n            sleep(3)\n            driver = webdriver.Chrome()\n            driver.get(url)\n        retrieved=retrivecountry(driver.page_source,countries[i])\n        data.extend(retrieved)\n        print(countries[i],'Cities:',len(retrieved),eta(time()))\n    print('Total Records',len(data))\n    driver.close()\n    \n    #Preparing the locations from past data.\n    locations=get_locations()\n    upd=[]\n    \n    for i in range(1,len(data)):\n        arg=data[i][:2]\n        \n        #If the country is not previously found this part will be finding the latitude and longtitude of the new location.\n        if locations.get((arg[0],arg[1]),'Not')=='Not':\n            arg=','.join(arg)\n            print(i,arg)\n            try:\n                geolocator = Nominatim()\n                location = geolocator.geocode(arg)\n                data[i]+=[location.latitude, location.longitude]\n            except:\n                data[i]+=getaddress(arg)\n            upd.append(data[i][:2]+data[i][-2:])\n        \n        #Otherwise the previous result will be assigned.\n        else:\n            data[i]+=locations[(arg[0],arg[1])]\n            \n\n    #This to get the ISO code of the country to get the correct continent\n    for i in range(1,len(data)):\n        if codes.get(data[i][0],'Not')=='Not':\n            codes[data[i][0]]=getcode(data[i][0])\n            data[i]+=[codes[data[i][0]]]\n        else:\n            data[i]+=[codes[data[i][0]]]\n    \n    #This is to get the continent name with the ISO code.\n    for i in range(1,len(data)):\n        if conts.get(data[i][0],'Not')=='Not':\n            conts[data[i][0]]=getcontinent(data[i][0])\n            data[i]+=[conts[data[i][0]]]\n        else:\n            data[i]+=[conts[data[i][0]]]\n            \n    #Converting the collected data to a proper data frame\n    df = pd.DataFrame(data[1:],columns=data[0])\n    upd =pd.DataFrame(upd,columns=['Country','City','Latitude','Longtitude'])\n    \n    #Updating the latitude and longtitude of newly fetched locations.\n    upd.to_csv('Locations.csv', mode='a', header=False)\n    df.to_csv('file5.csv')\n#prep()\nprint(df.head().to_string())","3efa9256":"#This function is used for Orthographic projection of COVID-19 Spread\ndef globe(df):\n    argdf=df\n    argdf.rename(columns={'Continent':'O'},inplace=True)\n    fig = px.scatter_geo(df, lat='Latitude',lon='Longtitude',\n                      color='O',\n                     hover_name=\"Country\", # column added to hover information\n                     size=\"Confirmed\",\n                     text=\"City\",\n                     \n                     )\n    fig.update_geos(projection_type=\"orthographic\",\n                    showcountries=True, countrycolor=\"Red\",\n                    showland=True, landcolor=\"lime\",\n        showocean=True, oceancolor=\"midnightblue\",lakecolor=\"Blue\"\n        )\n\n    fig.update_layout(\n        title_text='Global Spread of Corono',\n        titlefont=dict(\n            size=40,\n            color='Red'\n        )\n    )\n    return fig\nglobe(df).show()","f8af1aa3":"#This function is used for visualization in world map\ndef world(df):\n    argdf=df.loc[:700,:]\n    argdf.rename(columns={'Continent':'O'},inplace=True)\n    fig = px.scatter_mapbox(argdf, lat='Latitude',lon='Longtitude',\n                          color='O',\n                          hover_name='City',\n                         size=\"Confirmed\",\n                         height=870\n                         )\n    fig.update_layout(\n        mapbox=dict(\n            accesstoken=mapbox_accesstoken,\n            bearing=0,\n            center=go.layout.mapbox.Center(\n                lat=46,\n                lon=2\n            ),\n            pitch=0,\n            zoom=1.45\n        ),hoverlabel=dict(\n            bgcolor=\"Red\", \n            font_size=16, \n            font_family=\"Rockwell\"\n        )\n    )\n    fig.update_layout(\n    annotations=[dict(text='Global Spread of COVID-19', x=0.5, y=0.99,\n                      font=dict(family='Rockwell',color=\"Red\",size=23), showarrow=False),\n                 dict(text='Confirmed', x=0.95, y=0.99,\n                      font=dict(family='Georgia',color=\"midnightblue\",size=23), showarrow=False),\n                 dict(text='Recovered', x=0.95, y=0.90,\n                      font=dict(family='Georgia',color=\"midnightblue\",size=23), showarrow=False),\n                 dict(text='Deaths', x=0.928, y=0.81,\n                      font=dict(family='Georgia',color=\"midnightblue\",size=23), showarrow=False),\n                 dict(text=strv(df.Confirmed.sum()), x=0.95, y=0.95,\n                      font=dict(family='Droid Serif',color=\"Red\",size=23), showarrow=False),\n                 dict(text=strv(df.Recovered.sum()), x=0.95, y=0.85,\n                      font=dict(family='Droid Serif',color=\"Red\",size=23), showarrow=False),\n                 dict(text=strv(df.Deaths.sum()), x=0.95, y=0.76,\n                      font=dict(family='Droid Serif',color=\"Red\",size=23), showarrow=False)\n                 ])\n    \n    return fig\nworld(df).show()","fec6338b":"#This function is used for creating the map and the pie chart visualisation  for each country\ndef createmap(arg):\n    fig = make_subplots(\n    rows=3, cols=2,\n    column_widths=[0.6,0.4],\n    row_heights=[0.4, 0.3,0.3],\n    specs=[[{\"type\": \"scattermapbox\", \"rowspan\": 3}, {\"type\": \"Table\"}],\n           [None , {'type':'domain'}],\n           [None , {'type':'domain'}]])\n    argdf=df.loc[df['Country'] == arg]\n    argdf.sort_values(by='Confirmed', ascending=False,inplace=True)\n    \n    #Adding table for the country data\n    fig.add_trace(\n    go.Table(\n        header=dict(\n            values=[\"Country\", \"City\", \"Confirmed\",\n                    \"Recovered\", \"Deaths\"],\n            font=dict(size=10),line_color='darkslategray',fill_color='lightskyblue',\n            align=\"left\"\n        ),\n        cells=dict(\n            values=[argdf.Country,argdf.City,argdf.Confirmed,argdf.Recovered,argdf.Deaths],\n            align = \"left\",line_color='darkslategray',fill_color='lightcyan')\n    ),\n    row=1, col=2\n    )\n    \n    #Adding map view of the country\n    fig.add_trace(\n    go.Scattermapbox(lat=argdf[\"Latitude\"],\n                  lon=argdf[\"Longtitude\"],\n                     mode='markers',name=arg,\n        marker=go.scattermapbox.Marker(\n            size=argdf['Confirmed'],sizeref=2.*max(argdf['Confirmed'])\/(40.**2),sizemode=\"area\"\n        ),text=argdf['City']+','+argdf['Confirmed'].astype(str),hoverinfo=\"text\")\n    ,row=1, col=1\n    )\n    fig.update_layout(\n    hovermode='closest',\n    mapbox=dict(\n        accesstoken=mapbox_accesstoken,\n        bearing=0,style='satellite-streets',\n        pitch=0, center=dict(lat=cord[arg][1],lon=cord[arg][0]),\n        zoom=3.5\n    ),height=870\n    )\n    types=['Confirmed','Recovered','Deaths']\n    typev=[argdf.Confirmed.sum(),argdf.Recovered.sum(),argdf.Deaths.sum()]\n    colors=['Red','rgb(26, 196, 91)','Yellow']\n    \n    #Adding pie chart to represent each city confirmed proportion in the country. \n    fig.add_trace(go.Pie(labels=argdf.City, values=argdf.Confirmed,textposition='inside'),row=2, col=2)\n    \n    #Adding pie chart to represent the proportion of Confirmed,Recovered,Death\n    crd=go.Pie(labels=types,hole=.7, values=typev,\n                         marker=dict(colors=colors),textposition='inside')\n    fig.add_trace(crd,row=3, col=2)\n    fig.update_layout(\n    annotations=[dict(text='Stay', x=0.83, y=0.12,\n                      font=dict(color=\"Green\",size=20), showarrow=False),\n                 dict(text='Safe',x=0.84, y=0.08,\n                      font=dict(color=\"Green\",size=20), showarrow=False),\n                 dict(text='Proportion of Confirmed,Recovered,Deaths',x=0.915, y=0.26,\n                      font=dict(color=\"Green\",size=20), showarrow=False),\n                 dict(text='Proportion of Cites',x=0.76, y=0.63,\n                      font=dict(color=\"Green\",size=20),align='left',showarrow=False),\n                 dict(text='Confirmed',x=0.96, y=0.63,\n                      font=dict(color=\"Red\",size=20), showarrow=False),\n                 dict(text='Recovered',x=0.96, y=0.52,\n                      font=dict(color=\"Red\",size=20), showarrow=False),\n                 dict(text='Deaths',x=0.94, y=0.41,\n                      font=dict(color=\"Red\",size=20), showarrow=False),\n                 dict(text=strv(typev[0]),x=0.96, y=0.58,\n                      font=dict(color=\"midnightblue\",size=20), showarrow=False),\n                 dict(text=strv(typev[1]),x=0.96, y=0.46,\n                      font=dict(color=\"midnightblue\",size=20), showarrow=False),\n                 dict(text=strv(typev[2]),x=0.96, y=0.36,\n                      font=dict(color=\"midnightblue\",size=20), showarrow=False)\n                 ])\n    \n    return fig\n\n#Viewing spread of COVID-19 in various countries\nfor i in sorted(list(set(df['Country'].to_list())))[:15]:\n    try:\n        createmap(i).show()\n    except:\n        skip=0","8b35594c":"#Dash for serving the figures in local server\nexternal_stylesheets = ['https:\/\/codepen.io\/chriddyp\/pen\/bWLwgP.css']\n\napp = dash.Dash(__name__, external_stylesheets=external_stylesheets)\n\ncountries=['Afghanistan', 'Algeria', 'Argentina', 'Armenia', 'Australia', 'Austria', 'Belgium', 'Bolivia', 'Brazil', 'Cambodia', 'Canada', 'Chile', 'China', 'Croatia', 'Dominican Republic', 'Ecuador', 'Finland', 'Germany', 'Hungary', 'Iceland', 'India', 'Indonesia', 'Iran', 'Iraq', 'Ireland', 'Italy', 'Japan', 'Mexico', 'Moldova', 'Montenegro', 'Morocco', 'Nigeria', 'Norway', 'Pakistan', 'Peru', 'Philippines', 'Portugal', 'Romania', 'Slovakia', 'South Korea', 'Spain', 'Sri Lanka', 'Sweden', 'Switzerland', 'Tunisia', 'Ukraine', 'United Kingdom', 'United States', 'Uruguay']\napp.layout = html.Div([\n    html.Div([\n        html.Div([\n            dcc.Dropdown(\n                id='xaxis-column',\n                options=[{'label': i, 'value': i} for i in sorted(list(set(df['Country'].to_list())))]+\n                [{'label':'3d View', 'value': 'globe'}],\n                value=None,placeholder='Select country'\n            )\n        ],\n        style={'width': '15%', 'display': 'inline-block'}),\n    ]),\n    dcc.Graph(id='indicator-graphic'),\n])\n\n@app.callback(\n    Output('indicator-graphic', 'figure'),\n    [Input('xaxis-column', 'value')])\ndef update_graph(xaxis_column_name='India'):\n    if xaxis_column_name=='globe':\n        return globe(df)\n    elif xaxis_column_name:\n        if xaxis_column_name not in cord.keys():\n            cord[xaxis_column_name]=getaddress(xaxis_column_name)\n        return createmap(xaxis_column_name)\n    else:\n        return world(df)\ndef run():\n    app.run_server(debug=True,use_reloader=False)\n#To run this dashboard in local host\n#run()\n\n\n    \n","ab5bcd82":"<h3> Automation <\/h3>\n<pre class=\"tab\">          The selenium will open a new chrome tab. And then it will search the query. Now the inner HTML source of the page will be passed to retrievecountry function. The chrome tab will closed once the google seeks for human robot verification. Then again it will continue retrieving the data from a new chrome window. \n                          Now the inner HTML of each page browsed will be retrieved and processed with the help of retrievecountry function. Then the cleaned table is processed and latitude and longtitude values of each city will be retrieved with the help of API. And then it will start retrieving the ISO code of each country. This process is done in order to retrieve the continent to which the country belongs. Now the required data is retrieved and it will be converted to pandas dataframe\n                          \n\n                \n<\/pre>","aee7bdd4":"<h3> Web Scraping<\/h3>\n<pre class=\"tab\">   The inner HTML source of the page will be processed by retrievecountry function.This function uses Beautiful Soup to prettify the \nHTML Content.It will withdraw the required field such as city name,Confirmed cases, Recovered Cases, Death Cases.\nThen it will return processed table as its result.\n<\/pre>","356e7a21":"<h1>Interactive Live Dashboard for COVID-19 (Scraping and Visualization)<\/h1>\n<pre class=\"tab\">      This Dashboard is built with Plotly and Dash.The data found here are scraped from the Internet with the help Beautiful Soup,Requests and selenium. \n\nRequirements:\n        1.Selenium\n        2.BeautifulSoup\n        3.Plotly\n        4.Dash\n        5.Pandas\n<\/pre>","84af0ae8":"<h3> API to get locations <\/h3>\n<pre class=\"tab\">   To save time the previous day results will be stored in a CSV file.When the new address comes the API will be used to get the \nnew addresses respective latitude and longtitude.The newly discovered results will be updated in the CSV file.\n<\/pre>"}}