{"cell_type":{"5d4a90ee":"code","a8adb5b9":"code","e2fb4cde":"code","4547b304":"code","8e1df79c":"code","8f466939":"code","5be86b12":"code","813a081f":"code","b546fdc7":"code","2109d7cb":"code","43bd0850":"code","7406b8c0":"markdown","1ea937db":"markdown","ba41b98e":"markdown"},"source":{"5d4a90ee":"import numpy as np\nimport pandas as pd\nfrom sklearn.metrics import mean_squared_error as mse\nfrom sklearn.metrics import accuracy_score as acc\nimport  matplotlib.pyplot as plt","a8adb5b9":"\nfile = pd.read_csv('..\/input\/cancer-example\/cancer.csv')\ndata = file.to_numpy()\ninputs = data[:, :9]\noutputs = data[:, 9]\n\n","e2fb4cde":"\"\"\"\n ---- Shuffle ----\n\"\"\"\nper_list = np.random.permutation(len(data))\ninputs_sh = []\noutputs_sh = []\nfor i in range(len(data)):\n    per_idx = per_list[i]\n    tmp_input = inputs[per_idx]\n    tmp_output = outputs[per_idx]\n    inputs_sh.append(tmp_input)\n    outputs_sh.append(tmp_output)\ninputs_sh = np.array(inputs_sh)\noutputs_sh = np.array(outputs_sh)\n","4547b304":"\"\"\"\n ---- Normalize data ----\n (inputs - min) \/ (max - min)\n\"\"\"\nmin_vec = inputs_sh.min(axis = 0)\nmax_vec = inputs_sh.max(axis=0)\ninputs_sh = (inputs_sh - min_vec) \/ (max_vec - min_vec)","8e1df79c":"\"\"\"\n ---- spliting data ----\n\"\"\"\ntrn_test_split = int(0.75 * len(inputs_sh))\nX_train = inputs_sh[0:trn_test_split , : ]\nY_train = outputs_sh[0 : trn_test_split]\n\nX_val = inputs_sh[trn_test_split : , :]\nY_val = outputs_sh[trn_test_split : ,]","8f466939":"\"\"\"\n ---- Structure of Neural Network ----\n\"\"\"\nn0 = 9 # input layer\nn1 = 8 # first hidden layer\nn2 = 4 # second hidden layer\nn3 = 1 # output layer\n\nw1 = np.random.uniform(low=-1,high= +1,size=(n1,n0))\nw2 = np.random.uniform(low=-1,high= +1,size=(n2,n1))\nw3 = np.random.uniform(low=-1,high= +1,size=(n3,n2))","5be86b12":"# activation function\ndef activation(x):\n    y = 1\/(1 + np.exp(-1 * x))\n    return y\n","813a081f":"# feedforward algorithm\ndef feedforward(input_net):\n    # inputs * w1 --> x1 , y1= sigmoid(x1) , y1 * w2 --> x2\n    # y2 = sigmoid(x2) , y2 * w3 --> x3 , y3 = sigmoid(x3) , y3 : output\n    x1 = np.dot(input_net , w1.T)\n    y1 = activation(x1)\n    x2 = np.dot(y1 , w2.T)\n    y2 = activation(x2)\n    x3 = np.dot(y2 , w3.T)\n    y3 = activation(x3)\n\n    return y1 , y2 , y3","b546fdc7":"# Backpropagation\ndef d_activation(out):\n    # y = sigmoid(x) --> d_y = y * (1 - y)\n    d_y = out * ( 1 - out)\n    return d_y","2109d7cb":"epochs = 500\nlr = 0.001\n\nlist_AccTrain = []\nlist_MseTrain = []\nlist_AccValid = []\nlist_MseValid = []\n\nfor i in range(epochs):\n    for j in range(len(X_train)):\n        input = X_train[j] # shape input = (n0,)\n        input = np.reshape(input , newshape=(1,n0)) # shape input = (1,n0)\n        target = Y_train[j]\n\n        y1 , y2 , y3 = feedforward(input)\n        error = target - y3\n\n        # w1 = w1 - lr * (-2\/N)*(error) * d_f3 * w3 * d_f2 * w2 * d_f1 * ...\n        # ... * input\n        # (-2\/N) * error : N-->1\n        # w1.shape = (n1 , n0)\n        # d_f3.shape = (1,n3) = (1,1)\n        # w3.shape = (n3 , n2) -- > d_f3 * w3 : shape= (1,n2)\n        # d_f2.shape = (1, n2) --> diagonal(d_f2) : shape= (n2,n2)\n        # d_f3 * w3 * diagonal(d_f2) --> shape = (1 , n2)\n        # w2.shape = ( n2 , n1)\n        # d_f3 * w3 * ( diagonal(d_f2) * w2 --> shape = (1,n1)\n        # d_f1.shape = (1, n1) --> diagonal(d_f1) --> shape = (n1 , n1)\n        # matrix1 * diagonal(d_f1) --> shape = (1, n1) --> matrix2.T --> shape=(n1,1)\n        # input.shape = (1 , n0)\n        # matrix2.T * input --> shape = (n1 , n0)\n\n        d_f3 = d_activation(y3)\n\n        d_f2 = d_activation(y2)\n        diag_d_f2 = np.diagflat(d_f2)\n\n        d_f1 = d_activation(y1)\n        diag_d_f1 = np.diagflat(d_f1)\n\n        temp1 = -2 * error * d_f3\n        temp2 = temp1 * w3    #  or  np.dot(temp1 , w3)\n        temp3 = np.dot(temp2 , diag_d_f2)\n        temp4 = np.dot(temp3 , w2)\n        temp5 = np.dot(temp4 , diag_d_f1)\n        temp5 = temp5.T\n        temp6 = np.dot(temp5 , input)\n\n        w1 = w1 - lr * temp6\n\n        # w2 = w2 - lr * ((-2\/N)*error * d_f3 * w3 * diag_d_f2).T * y1\n        w2 = w2 - lr * np.dot(temp3.T , y1)\n\n        # w3 = w3 - lr * (-2\/N)*error * d_f3 * y2\n        w3 = w3 - lr * np.dot(temp1.T , y2)\n    # calculate and MSE train ::\n\n    Netoutput_Train = []\n    target_Train =[]\n    rnd_Netoutput_Train = []\n    for idx in range(len(X_train)):\n        input = X_train[idx]\n        target = Y_train[idx]\n        target_Train.append(target)\n\n        _ ,_ ,pred = feedforward(input)\n        Netoutput_Train.append(pred)\n        rnd_Netoutput_Train.append(np.round(pred))\n    mse_train = mse(target_Train ,Netoutput_Train)\n    #mse_train1 = np.square(np.subtract(target_Train,Netoutput_Train)).mean()\n    list_MseTrain.append(mse_train)\n\n    acc_train = acc(target_Train, rnd_Netoutput_Train)\n    list_AccTrain.append(acc_train)\n    print('epoch ' ,i , ' :MSE_Train = ' , mse_train ,'\\tACC_TRAIN = ' ,acc_train)\n\n# calculate and MSE Valid ::\n\n    Netoutput_val = []\n    target_val =[]\n    rnd_Netoutput_val = []\n    for idx in range(len(X_val)):\n        input = X_val[idx]\n        target = Y_val[idx]\n        target_val.append(target)\n\n        _ ,_ ,pred = feedforward(input)\n        Netoutput_val.append(pred)\n        rnd_Netoutput_val.append(np.round(pred))\n    mse_val = mse(target_val ,Netoutput_val)\n    #mse_val1 = np.square(np.subtract(target_val, Netoutput_val)).mean()\n    list_MseValid.append(mse_val)\n\n    acc_val= acc(target_val, rnd_Netoutput_val)\n    list_AccValid.append(acc_val)\n    print('epoch ' ,i , ' :MSE_val = ' , mse_val ,'\\tACC_val = ' ,acc_val)\n    print('---------------------------------------------------------')\n","43bd0850":"plt.figure(figsize=(12,12))\nplt.subplot(2,1,1)\nplt.title('MSE')\nplt.plot(list_MseTrain,label = 'MseTrain')\nplt.plot(list_MseValid , label = 'MseValid')\nplt.legend()\nplt.xlabel('epochs')\nplt.ylabel('MSE')\n\nplt.subplot(2,1,2)\nplt.title('accuracy')\nplt.plot(list_AccTrain ,label = 'AccTrain')\nplt.plot(list_AccValid , label = 'AccTrain')\nplt.show()","7406b8c0":"<div class=\"alert alert-block alert-success\">\n    <h1 align=\"center\"> Neural network based on mathematical relations in Python<\/h1>\n    <h3 align=\"center\"><\/h3>\n<\/div>","1ea937db":"Good luck!","ba41b98e":"<img src = \"https:\/\/www.ionos.de\/digitalguide\/fileadmin\/DigitalGuide\/Teaser\/ki-t.jpg\" width=100%>"}}