{"cell_type":{"37f167ec":"code","31daf401":"code","2d9904dd":"code","64899454":"code","ad892e81":"code","a96bf421":"code","dc2de94d":"code","f70bdc62":"code","9e5d9cc4":"code","21107701":"markdown","195435d1":"markdown","06788894":"markdown","e66dd139":"markdown","06abb8b3":"markdown","ee29ee7d":"markdown","8a4f3bb8":"markdown","d8372caf":"markdown","8b49c6e6":"markdown","2513208d":"markdown","a9853df0":"markdown","1a8acbf0":"markdown","eee9af2b":"markdown","5f99a969":"markdown"},"source":{"37f167ec":"import numpy as np\n\nimport jax\nimport jax.numpy as jnp\n\nfrom jax import grad\nfrom jax import jit\nfrom jax import lax\nfrom jax import random\n\n%config IPCompleter.use_jedi = False","31daf401":"# A global variable\ncounter = 5\n\ndef add_global_value(x):\n    \"\"\"\n    A function that relies on the global variable `counter` for\n    doing some computation.\n    \"\"\"\n    return x + counter","2d9904dd":"x = 2\n\n# We will `JIT` the function so that it runs as a JAX transformed\n# function and not like a normal python function\ny = jit(add_global_value)(x)\nprint(\"Global variable value: \", counter)\nprint(f\"First call to the function with input {x} with global variable value {counter} returned {y}\")\n\n# Someone updated the global variable value later in the code\ncounter = 10\n\n# Call the function again\ny = jit(add_global_value)(x)\nprint(\"\\nGlobal variable changed value: \", counter)\nprint(f\"Second call to the function with input {x} with global variable value {counter} returned {y}\")","64899454":"# Change the type of the argument passed to the function\n# In this case we will change int to float (2 -> 2.0)\nx = 2.0\ny = jit(add_global_value)(x)\nprint(f\"Third call to the function with input {x} with global variable value {counter} returned {y}\")","ad892e81":"# Change the shape of the argument\nx = jnp.array([2])\n\n# Changing global variable value again\ncounter = 15\n\n# Call the function again\ny = jit(add_global_value)(x)\nprint(f\"Third call to the function with input {x} with global variable value {counter} returned {y}\")","a96bf421":"def apply_sin_to_global():\n    return jnp.sin(jnp.pi \/ counter)\n\ny = apply_sin_to_global()\nprint(\"Global variable value: \", counter)\nprint(f\"First call to the function with global variable value {counter} returned {y}\")\n\n\n# Change the global value again\ncounter = 90\ny = apply_sin_to_global()\nprint(\"\\nGlobal variable value: \", counter)\nprint(f\"Second call to the function with global variable value {counter} returned {y}\")","dc2de94d":"# A function that takes an actual array object\n# and add all the elements present in it\ndef add_elements(array, start, end, initial_value=0):\n    res = 0\n    def loop_fn(i, val):\n        return val + array[i]\n    return lax.fori_loop(start, end, loop_fn, initial_value)\n\n\n# Define an array object\narray = jnp.arange(5)\nprint(\"Array: \", array)\nprint(\"Adding all the array elements gives: \", add_elements(array, 0, len(array), 0))\n\n\n# Redefining the same function but this time it takes an \n# iterator object as an input\ndef add_elements(iterator, start, end, initial_value=0):\n    res = 0\n    def loop_fn(i, val):\n        return val + next(iterator)\n    return lax.fori_loop(start, end, loop_fn, initial_value)\n    \n    \n# Create an iterator object\niterator = iter(np.arange(5))\nprint(\"\\n\\nIterator: \", iterator)\nprint(\"Adding all the elements gives: \", add_elements(iterator, 0, 5, 0))","f70bdc62":"def return_as_it_is(x):\n    \"\"\"Returns the same element doing nothing. A function that isn't\n    using `globals` or any `iterator`\n    \"\"\"\n    print(f\"I have received the value\")\n    return x\n\n\n# First call to the function\nprint(f\"Value returned on first call: {jit(return_as_it_is)(2)}\\n\")\n\n# Second call to the fucntion with different value\nprint(f\"Value returned on second call: {jit(return_as_it_is)(4)}\")","9e5d9cc4":"# Function that uses stateful objects but internally and is still pure\ndef pure_function_with_stateful_obejcts(array):\n    array_dict = {}\n    for i in range(len(array)):\n        array_dict[i] = array[i] + 10\n    return array_dict\n\n\narray = jnp.arange(5)\n\n# First call to the function\nprint(f\"Value returned on first call: {jit(pure_function_with_stateful_obejcts)(array)}\")\n\n# Second call to the fucntion with different value\nprint(f\"\\nValue returned on second call: {jit(pure_function_with_stateful_obejcts)(array)}\")","21107701":"Wait...What??? What just happened?\n\nWhen you `jit` your function, JAX tracing kicks in. On the first call, the results would be as expected, but on the subsequent function calls you will get the **`cached`** results unless:\n1. The type of the argument has changed or\n2. The shape of the argument has changed\n\nLet's see it in action","195435d1":"# Case 2: Iterators\n\nWe will take a very simple example to see the side effect. We will add numbers from `0 to 5` but in two different ways:\n1. Passing an actual array of numbers to a function\n2. Passing an **`iterator`** object to the same function","06788894":"# Case 3: IO\n\nLet's take one more example, a very **unusual** one that can turn your functions impure.","e66dd139":"Why the result turned out to be zero in the second case?<br>\nThis is because an `iterator` introduces an **external state** to retrieve the next value.","06abb8b3":"So, to keep things **pure**, remember not to use anything inside a function that depends on any **external state**, including the IO as well. If you do that, transforming the function would give you unexpected results, and you would end up wasting a lot of time debugging your code when the transformed function returns a cached result, which is ironical because pure functions are easy to debug","ee29ee7d":"# Pure Functions\n\nAccording to [Wikipedia](https:\/\/en.wikipedia.org\/wiki\/Pure_function), a function is pure if:\n1. The function returns the same values when invoked with the same inputs\n2. There are no side effects observed on a function call\n\nAlthough the definition looks pretty simple, without examples it can be hard to comprehend and it can sound very vague (especially to the beginners). The first point is clear, but what does a **`side-effect`** mean? What constitutes or is marked as a side effect? What can you do to avoid side effects?\n\nThough I can state all the things here and you can try to \"fit\" them in your head to make sure that you aren't writing anything that has a side effect, I prefer taking examples so that everyone can understand the \"why\" part in an easier way. So, let's take a few examples and see some common mistakes that can create side effects","8a4f3bb8":"*`Hooraaayy! Problem solved! You can use JIT, I won't!`*  If you are thinking in this direction, then it's time to remember two things:\n\n1. We are using JAX so that we can transform our native Python code to make it run **faster**\n2. We can achieve 1) if we compile (using it loosely here) the code so that it can run on **XLA**, the compiler used by JAX\n\nHence, avoid using `globals` in your computation because globals introduce **impurity**","d8372caf":"# Case 1 : Globals","8b49c6e6":"Did you notice that? The statement **`I have received the value`** didn't get printed on the subsequent call. <br>\nAt this point, most people would literally say `Well, this is insane! I am not using globals, no iterators, nothing at all and there is still a side effect? How is that even possible?`\n\nThe thing is that your function is still **dependent** on an **external state**. The **print** statement! It is using the standard output stream to print. What if the stream isn't available on the subsequent calls for whatsoever reason? That will violate the first principle of \"returning the same output\" when called with the same inputs.\n\n\nIn a nutshell, to keep function pure, don't use anything that depends on an **external state**. The word **external** is important because you can use stateful objects internally and still keep the functions pure. Let's take an example of this as well","2513208d":"# Pure functions with stateful objects","a9853df0":"What if I don't `jit` my function in the first place?  \u00af\\_(\u30c4)_\/\u00af <br>\nLet's take an example of that as well. We are in no hurry!","1a8acbf0":"That's it for Part-5! We will look into other building blocks in the next few chapters, and then we will dive into building neural networks in JAX! \n\n**References:**<br>\n1. https:\/\/jax.readthedocs.io\/en\/latest\/\n2. https:\/\/alvinalexander.com\/scala\/fp-book\/benefits-of-pure-functions\/\n3. https:\/\/www.sitepoint.com\/what-is-referential-transparency\/#referentialtransparencyinmaths","eee9af2b":"# Why pure functions?\n\nA natural question that comes to mind is that why JAX uses pure functions in the first place? No other framework like TensorFlow, PyTorch, mxnet, etc uses it. <br>\nAnother thing that you must be thinking right is probably this: Using pure functions is such a headache, I never have to deal with these nuances in TF\/Torch.\n\nWell, if you are thinking that, you aren't alone but before jumping to any conclusion, consider the advantages of relying on pure functions.\n\n### 1. Easy to debug\n\nThe fact that a function is pure implies that you don't need to look beyond the scope of the pure function. All you need to focus on is the arguments, the logic inside the function, and the returned value. That's it! Same inputs => Same outputs\n\n\n### 2. Easy to parallelize\n\nLet's say you have three functions A, B, and C and there is a computation involved like this one:<br>\n <div style=\"font-style: italic; text-align: center;\">\n `res = A(x) + B(y) + C(z)` <br>\n <\/div>\n \nBecause all the functions are pure, you don't have to worry about the dependency on an external state or a shared state. There is no dependency between A, B, and C in terms of how are they executed. Each function receives some argument and returns the same output. Hence you can easily offload the computation to many threads, cores, devices, etc. The only thing that the compiler has to ensure that the results of all the functions (A, B, and C in this case) are available before item assignment\n\n\n### 3. Caching or Memoization\n\nWe saw in the above examples that once we compile a pure function, the function will return a cached result on the subsequent calls. We can cache the results of the transformed functions to make the whole program a lot faster\n\n\n### 4. Functional Composition\n\nWhen functions are pure, you can `chain` them to solve complex things in a much easier way. For example, in JAX you will see these patterns very often:\n<div style=\"font-style: italic; text-align: center;\">\njit(vmap(grad(..)))\n<\/div>\n\n### 5. Referential transparency\n\nAn expression is called referentially transparent if it can be replaced with its corresponding value (and vice-versa) without changing the program's behavior. This can only be achieved when the function is pure. It is especially helpful when doing algebra (which is all we do in ML). For example, consider the expression<br>\n <div style=\"font-style: italic; text-align: center;\">\n  x = 5 <br>\n  y = 5 <br> \n z = x + y <br>\n <\/div>\n \n Now you can replace `x + y` with `z` anywhere in your code, considering the value of `z` is coming from a pure function","5f99a969":"**Update - 23rd Dec, 2021**\n\nWe have completed the TF-JAX tutorials series. 10 notebooks that covers every fundamental aspect of both TensorFlow and JAX. Here are the links to the notebooks along with the Github repo details:\n\n### TensorFlow Notebooks:\n\n* [TF_JAX_Tutorials - Part 1](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part1)\n* [TF_JAX_Tutorials - Part 2](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part2)\n* [TF_JAX_Tutorials - Part 3](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part3)\n\n### JAX Notebooks:\n\n* [TF_JAX_Tutorials - Part 4 (JAX and DeviceArray)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-4-jax-and-devicearray)\n* [TF_JAX_Tutorials - Part 5 (Pure Functions in JAX)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-5-pure-functions-in-jax\/)\n* [TF_JAX_Tutorials - Part 6 (PRNG in JAX)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-6-prng-in-jax\/)\n* [TF_JAX_Tutorials - Part 7 (JIT in JAX)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-7-jit-in-jax)\n* [TF_JAX_Tutorials - Part 8 (Vmap and Pmap)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-8-vmap-pmap)\n* [TF_JAX_Tutorials - Part 9 (Autodiff in JAX)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-9-autodiff-in-jax)\n* [TF_JAX_Tutorials - Part 10 (Pytrees in JAX)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-10-pytrees-in-jax)\n\n### Github Repo with all notebooks in one place\nhttps:\/\/github.com\/AakashKumarNain\/TF_JAX_tutorials\n\n---\n\n<img src=\"https:\/\/raw.githubusercontent.com\/google\/jax\/main\/images\/jax_logo_250px.png\" width=\"300\" height=\"300\" align=\"center\"\/><br>\n\nI hope you all enjoyed the first JAX tutorial where we discussed **DeviceArray** and some other fundamental concepts in detail. This is the fifth tutorial in this series, and today we will discuss another important concept specific to JAX. If you haven't looked at the previous tutorials, I highly suggest going through them once. Here are the links:\n\n1. [TF_JAX_Tutorials - Part 1](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part1)\n2. [TF_JAX_Tutorials - Part 2](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part2)\n3. [TF_JAX_Tutorials - Part 3](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part3)\n4. [TF_JAX_Tutorials - Part 4 (JAX and DeviceArray)](https:\/\/www.kaggle.com\/aakashnain\/tf-jax-tutorials-part-4-jax-and-devicearray)\n\n\nWithout any further delay, let's jump in and talk about **pure functions** along with code examples"}}