{"cell_type":{"3b7fbc2d":"code","2e1693ad":"code","5a00ae57":"code","d82810ed":"code","41ece1e2":"code","5fde8f8e":"code","f77860e2":"code","084b0808":"code","15d4bc5d":"code","8ac53635":"code","6aafb37a":"code","4ecfd7bc":"code","9b42ba4b":"code","bc2c399f":"code","eb5e8f84":"code","548ea54c":"code","fc5485a7":"code","a4e6ca4f":"code","21ff7ca7":"code","01b3611e":"code","9b248b46":"code","18319269":"code","e62b7d32":"markdown"},"source":{"3b7fbc2d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","2e1693ad":"import shapely.geometry as shg\nimport matplotlib.pyplot as plt\nfrom pylab import rcParams\nfrom shapely.geometry import Polygon,Point #Used for validating results with shapely\n\nrcParams['figure.figsize'] = 5, 5    #To adjust size of plot\n\ndef areasign(tri):\n    \"\"\"Finds the sign of the area of a closed triangle\n\n    Parameters\n    ----------\n    tri : List\n        List of coordinate tuples in the format\n        [(x, y), (x, y). (x, y), (x, y)]\n        First and last vertex are the same\n    \n    Returns\n    -------\n    int (-1, 1, 0)\n        -1 if the triangle is encoded clockwise\n        1  if the triangle is encoded anti-clockwise\n        0  if the coordinates are a 1d line\n    \"\"\"\n    sumarea = 0\n    for i in range(0, len(tri)-1):\n        xi = tri[i][0]\n        yi = tri[i][1]\n        xj = tri[i+1][0]\n        yj = tri[i+1][1]\n        sumarea = sumarea + ((xi*yj)-(yi*xj))\n        \n    if sumarea == 0: return 0\n    if sumarea < 0:  return -1\n    if sumarea > 0:  return 1\n\ndef create_triangle(test_pt, line_seg):\n    \"\"\" Creates a closed triangle from a test point and a line segment\n    \n    Parameters\n    ----------\n    test_pt : the test point in the format (x, y)\n    line_seg: the line segment in the format [(x, y), (x, y)]\n    \n    Returns\n    -------\n    A triangle consisting of 4 coordinate tuples\n    \"\"\"\n    tri = line_seg.copy()\n    \n    tri.insert(0, test_pt)\n    tri.append(test_pt)\n    \n    return tri\n\ndef line_intersection(line1, line2):\n    \"\"\" Tests whether 2 line segments intersect\n    \n    Parameters\n    ----------\n    line1 : the first line segment in the format [(x, y), (x, y)]\n    line2 : the second line segment in the format [(x, y), (x, y)] \n    \n    Returns\n    -------\n    True if the segmenets intersect,otherwise False\n    \"\"\"\n    \n    #create 4 triangles from the\n    #start and end points of each line and the other line\n    tri1 = create_triangle(line2[0], line1)\n    tri2 = create_triangle(line2[1], line1)\n    tri3 = create_triangle(line1[0], line2)\n    tri4 = create_triangle(line1[1], line2)\n    \n    #Calculate the signs of the  areas of these triangles\n    tri1sign = areasign(tri1)\n    tri2sign = areasign(tri2)\n    tri3sign = areasign(tri3)\n    tri4sign = areasign(tri4)\n    \n    #if the signs are not equal then the lines intersect\n    if ((tri1sign != tri2sign) and (tri3sign != tri4sign)):\n        return True\n    else:\n        return False","5a00ae57":"#Create and test using own data\npoly=[(1,1),(1,6),(6,6),(6,1),(1,1)]\npt=(3,4)\n\n","d82810ed":"#Halfline is a line segment that extend from a point to infinity\nhline=[pt,(1000000,1000001)]","41ece1e2":"#Plotting the polygon and the halfline\nxy = list(zip(*poly))\nplt.plot(xy[0], xy[1])\nplt.plot(pt[0], pt[1], 'ro')\nplt.plot([3,10], [4, 11], 'g-')\nplt.text (6.5, 6.6, s=\"half line\", rotation = 45, fontsize = 18)","5fde8f8e":"def pointinpolygon(pt, poly):\n    \"\"\" Tests whether a point is in a polygon\n    \n    Parameters\n    ----------\n    pt : the point in the format (x,y)\n    poly : the polygon in the format [(x1,y1),(x2,y2),(x3,y3)...(xn,yn)]\n    \n    Returns\n    -------\n    True if the point is in the polygon,otherwise False\n    \"\"\"\n    hline=[pt,(1000000,1000001)] \n    counter=0\n    \n    for i in range(len(poly)-1):\n        line_sg=[poly[i],poly[i+1]]\n        ans=line_intersection(hline,line_sg)\n        if ans==True:\n            counter=counter+1\n    if counter %2==0:\n        return False\n             \n    else:\n        return True\n        \n        \npoly=[(1,1),(1,6),(6,6),(6,1),(1,1)]\npt=(3,4)\nprint(pointinpolygon(pt,poly))\n\n#Shapely function for validation\npoly=Polygon([(1,1),(1,6),(6,6),(6,1),(1,1)])\npt=Point(3,4)\nshg=pt.within(poly)\nprint(shg)","f77860e2":"from shapely import wkt\nlist_of_polygons = []   #to store the polygons we read in our format\n\nf = open ('..\/input\/vector\/test_polygons1.txt') #Open the file\n\n#Iterate over the file\nfor each_line in f: \n    poly = wkt.loads(each_line)           #Read WKT format into a Polygon\n    print(list(poly.exterior.coords))     #Use coords to generate lists in our format\n    list_of_polygons.append(list(poly.exterior.coords))         #Add the polygon to our list of polygons","084b0808":"display(list_of_polygons)","15d4bc5d":"\nlist_of_points = []   #to store the polygons we read in our format\n\nf = open ('..\/input\/vector\/test_points1.txt') \n\n#Iterate over the file\nfor each_line in f: \n    pt = wkt.loads(each_line)           \n    print(list(pt.coords))     \n    list_of_points.append(pt.coords[0])  #So we get a list of coordinates","8ac53635":"display(list_of_points)","6aafb37a":"for poly in list_of_polygons:\n    xy = list(zip(*poly))\n    plt.fill(xy[0], xy[1], alpha=0.5)\n    \nfor pt in list_of_points:\n    #print(pt)\n    plt.plot(pt[0], pt[1], 'bx', ms=12)","4ecfd7bc":"for pt in list_of_points:\n    for poly in list_of_polygons:\n        ans= pointinpolygon(pt, poly)\n        print ('Point {} is located inside Polygon{} which is {}.'.format(pt,poly,ans))","9b42ba4b":"for pt in list_of_points:\n    for poly in list_of_polygons:\n        shg_poly=Polygon(poly)\n        shg_pt=Point(pt)\n        ans=shg_pt.within(shg_poly)\n        print ('Point {} is located inside {} which is {}.'.format(pt,poly,ans))\n        ","bc2c399f":"import fiona                             #a library that reads spatial formats\nfrom shapely.geometry import shape\n\nshapefile_polygons = []                  #a list to store the polygons we load\n\n\nc = fiona.open('..\/input\/shapefile\/test_polygon_shapefile.shp') #Open the shapefile\n\nfor each_poly in c:\n    geom = shape(each_poly['geometry'])\n    poly_data = each_poly[\"geometry\"][\"coordinates\"][0]  #EXTERIOR RING ONLY\n    poly = Polygon(poly_data)\n    print(poly)\n    #Converts into the same format as the other data\n    shapefile_polygons.append(list(poly.exterior.coords))\n\ndisplay(shapefile_polygons)","eb5e8f84":"# And read the points from a shapefile\nshapefile_points = []\n\nc = fiona.open('..\/input\/shapefile\/test_point_shapefile.shp')\n\nfor each_pt in c:\n    geom = shape(each_pt['geometry'])\n    pt_data = each_pt[\"geometry\"][\"coordinates\"]\n    pt =Point(pt_data)\n    print(pt)\n    shapefile_points.append(pt.coords[0])\n\ndisplay(shapefile_points)","548ea54c":"# Plot it out\nplt.gca().set_aspect('equal', adjustable='box')  #To make the x and y axis the same scale\n\nfor poly in shapefile_polygons:\n    xy = list(zip(*poly))\n    plt.fill(xy[0], xy[1], alpha=0.5)\n    \nfor pt in shapefile_points:\n    plt.plot(pt[0], pt[1], 'bx', ms=12)","fc5485a7":"#\nfor pt in shapefile_points:\n    for poly in shapefile_polygons:\n        ans= pointinpolygon(pt, poly)\n        print ('Point {} is located inside {} which is {}.'.format(pt,poly,ans))","a4e6ca4f":"for pt in shapefile_points:\n    for poly in shapefile_polygons:\n        shg_poly2=Polygon(poly)\n        shg_pt2=Point(pt)\n        ans=shg_pt2.within(shg_poly2)\n        print ('Point {} is located inside {} which is {}.'.format(pt,poly,ans))\n        ","21ff7ca7":"#Halfline is tangent to the polygon\n\npoly_1=[(4,1),(8,1),(8,6),(4,6),(2,4),(4,1)]\npt_1=(2,1)\n\nhline_1=(2,1000001)\n\n#Plotting the polygon and the halfline\nxy = list(zip(*poly_1))\nplt.plot(xy[0], xy[1])\nplt.plot(pt_1[0], pt_1[1], 'ro')\nplt.plot([2,2], [1, 10], 'g-')\nplt.text (2.2, 6, s=\"half line\", rotation = 90, fontsize = 18)\n          \ndef pointinpolygon(pt_1, poly_1):\n    \n    hline=[pt_1,(2,1000001)] \n    counter=0\n    \n    for i in range(len(poly_1)-1):\n        line_sg=[poly_1[i],poly_1[i+1]]\n        ans=line_intersection(hline,line_sg)\n        if ans==True:\n            counter=counter+1\n    if counter %2==0:\n        return False\n             \n    else:\n        return True\n        \n        \npoly_1=[(4,1),(8,1),(8,6),(4,6),(2,4),(4,1)]\npt_1=(2,1)\nprint(pointinpolygon(pt,poly))\n\n#Shapely function for validation\npoly1=Polygon([(4,1),(8,1),(8,6),(4,6),(2,4),(4,1)])\npt1=Point(2,1)\nshg=pt1.within(poly1)\nprint(shg)","01b3611e":"#Halfline intersecting at a vertex\n\npoly_2=[(2,2),(3,1),(6,1),(7,2),(7,6),(6,7),(3,7),(2,6),(2,2)]\npt_2=(1,1)\n\nhline_2=(1000000,1000000)\n\n#Plotting the polygon and the halfline\nxy = list(zip(*poly_2))\nplt.plot(xy[0], xy[1])\nplt.plot(pt_2[0], pt_2[1], 'ro')\nplt.plot([1,10], [1, 11], 'g-')\nplt.text (7.5, 7.6, s=\"half line\", rotation = 45, fontsize = 18)\n          \ndef pointinpolygon(pt_2, poly_2):\n    \n    hline=[pt_1,(1000000,1000000)] \n    counter=0\n    \n    for i in range(len(poly_2)-1):\n        line_sg=[poly_2[i],poly_2[i+1]]\n        ans=line_intersection(hline,line_sg)\n        if ans==True:\n            counter=counter+1\n    if counter %2==0:\n        return False\n             \n    else:\n        return True\n        \n        \npoly_1=[(2,2),(3,1),(6,1),(7,2),(7,6),(6,7),(3,7),(2,6),(2,2)]\npt_1=(1,1)\nprint(pointinpolygon(pt,poly))\n\n#Shapely function for validation\npoly2=Polygon([(2,2),(3,1),(6,1),(7,2),(7,6),(6,7),(3,7),(2,6),(2,2)])\npt2=Point(1,1)\nshg=pt2.within(poly2)\nprint(shg)\n\n","9b248b46":"#Halfline is collinear to one or more line segments\n\npoly_3=[(2,1),(10,1),(10,4),(6,4),(6,7),(10,7),(10,10),(2,10),(2,1)]\npt_3=(6,2)\n\nhline_3=(6,1000000)\n\n#Plotting the polygon and the halfline\nxy = list(zip(*poly_3))\nplt.plot(xy[0], xy[1])\nplt.plot(pt_3[0], pt_3[1], 'ro')\nplt.plot([6,6], [2, 15], 'g-')\nplt.text (6.1, 11, s=\"half line\", rotation = 90, fontsize = 18)\n          \ndef pointinpolygon(pt_3, poly_3):\n    \n    hline=[pt_1,(6,1000000)] \n    counter=0\n    \n    for i in range(len(poly_3)-1):\n        line_sg=[poly_3[i],poly_3[i+1]]\n        ans=line_intersection(hline,line_sg)\n        if ans==True:\n            counter=counter+1\n    if counter %2==0:\n        return False\n             \n    else:\n        return True\n        \n        \npoly_3=[(2,1),(10,1),(10,4),(6,4),(6,7),(10,7),(10,10),(2,10),(2,1)]\npt_3=(6,2)\nprint(pointinpolygon(pt,poly))\n\n#Shapely function for validation\npoly3=Polygon([(2,1),(10,1),(10,4),(6,4),(6,7),(10,7),(10,10),(2,10),(2,1)])\npt3=Point(6,2)\nshg=pt3.within(poly3)\nprint(shg)","18319269":"#Point located at the boundary of a polygon\n\npoly_4=[(2,1),(8,1),(6,5),(4,5),(2,1)]\npt_4=(5,1)\n\nhline_4=(1000000,1000001)\n\n#Plotting the polygon and the halfline\nxy = list(zip(*poly_4))\nplt.plot(xy[0], xy[1])\nplt.plot(pt_4[0], pt_4[1], 'ro')\nplt.plot([5,10], [1, 12], 'g-')\nplt.text (7.5, 8, s=\"half line\", rotation = 55, fontsize = 18)\n          \ndef pointinpolygon(pt_4, poly_4):\n    \n    hline=[pt_1,(6,1000000)] \n    counter=0\n    \n    for i in range(len(poly_4)-1):\n        line_sg=[poly_4[i],poly_4[i+1]]\n        ans=line_intersection(hline,line_sg)\n        if ans==True:\n            counter=counter+1\n    if counter %2==0:\n        return False\n             \n    else:\n        return True\n        \n        \npoly_4=[(2,1),(8,1),(6,5),(4,5),(2,1)]\npt_4=(5,1)\nprint(pointinpolygon(pt,poly))\n\n#Shapely function for validation\npoly4=Polygon([(2,1),(8,1),(6,5),(4,5),(2,1)])\npt4=Point(5,1)\nshg=pt4.within(poly4)\nprint(shg)","e62b7d32":"# Testing for Degenerative Cases\nThere are four types of degenerative cases identified:\n1. Halfline is a tangent to the polygon\n2. Halfline intersecting at a vertex3\n3. Halfline is collinear to one or more line segments\n4. Point located at the boundary of a polygon"}}