{"cell_type":{"eea6d6db":"code","c7319c19":"code","0246d105":"code","c10dda00":"code","ba9c0304":"code","fb26db2c":"code","66b7fca1":"code","3bf281c6":"code","2fb6ad58":"code","8fa91f65":"code","86e2f270":"code","09ba4a07":"code","104ef35c":"code","7bd8f405":"code","450992b8":"code","d70f80f4":"code","2f5ff4ba":"markdown","3f430fb4":"markdown","f2f8b1dd":"markdown","9edce269":"markdown"},"source":{"eea6d6db":"import os\nimport random\nimport cv2\nimport torch\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nfrom PIL import Image\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision import transforms","c7319c19":"for dirname, _, filenames in os.walk('\/kaggle\/input'):\n    print(dirname)","0246d105":"train_images_path = '\/kaggle\/input\/classification-with-limited-data\/food\/train\/images'\ntrain_labels_path = '\/kaggle\/input\/classification-with-limited-data\/food\/train\/train.csv'\ntest_images_path = '\/kaggle\/input\/classification-with-limited-data\/food\/test\/images'\ndf = pd.read_csv(train_labels_path)","c10dda00":"random_file = random.choice(os.listdir(train_images_path))","ba9c0304":"img = cv2.imread(os.path.join(train_images_path, random_file))\nimg = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) \n\nclassForImage = df[df['Id'] == random_file]['Expected'].values[0]\n\nprint(img.shape)","fb26db2c":"plt.imshow(img)\nprint(classForImage)","66b7fca1":"class FoodDataset(Dataset):\n    def __init__(self, x, y, transform=None):\n        self.x = x\n        self.y = torch.LongTensor(y)\n        self.transform = transform\n\n    def __getitem__(self, index):\n        x = self.x[index]\n        y = self.y[index]\n\n        if self.transform:\n            x = Image.fromarray(self.x[index].astype(np.uint8))\n            x = self.transform(x)\n\n        return x, y\n\n    def __len__(self):\n        return len(self.x)\n","3bf281c6":"train_x = []\ntrain_y = []\nfor file in os.listdir(train_images_path):\n    img = cv2.imread(os.path.join(train_images_path, file))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) \n    cls = df[df['Id'] == file]['Expected'].values[0]\n    train_x.append(img)\n    train_y.append(cls)\n\n    \ntrain_x = np.array(train_x)\ntrain_y = np.array(train_y)\nprint(train_x.shape, train_y.shape)\n\ntransform = transforms.Compose([transforms.Resize(32), transforms.ToTensor()])\ntrain_dataset = FoodDataset(train_x, train_y, transform=transform)\ntrain_loader = DataLoader(train_dataset, batch_size=1)","2fb6ad58":"dataiter = iter(train_loader)\nimages, labels = dataiter.next()","8fa91f65":"plt.imshow(images.numpy()[0,:,:,:].transpose(2,1,0))\nprint(labels.numpy()[0])","86e2f270":"import torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 256)\n        self.fc2 = nn.Linear(256, 128)\n        self.fc3 = nn.Linear(128, 107)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n\nnet = Net()","09ba4a07":"import torch.optim as optim\n\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)\n","104ef35c":"for epoch in range(20):  # loop over the dataset multiple times\n\n    running_loss = 0.0\n    for i, data in enumerate(train_loader, 0):\n        # get the inputs; data is a list of [inputs, labels]\n        inputs, labels = data\n\n        # zero the parameter gradients\n        optimizer.zero_grad()\n\n        # forward + backward + optimize\n        outputs = net(inputs)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n\n        # print statistics\n        running_loss += loss.item()\n        if i % 500 == 499:    # print every 2000 mini-batches\n            print('[%d, %5d] loss: %.3f' %\n                  (epoch + 1, i + 1, running_loss \/ 2000))\n            running_loss = 0.0\n\nprint('Finished Training')\n","7bd8f405":"df = pd.DataFrame(columns=[\"Id\", \"Expected\"])\n\nnumClasses = 107\nfor file in os.listdir(test_images_path):\n    \n    img = cv2.imread(os.path.join(test_images_path, file))\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) \n    \n    img = transform(Image.fromarray(img.astype(np.uint8)))\n    img = torch.unsqueeze(img, 0)\n    prob = net(img).detach().numpy()[0]\n    randomClass = random.randint(0,numClasses)\n    predictedClass = np.argmax(prob)\n    df.loc[len(df)] = [file, predictedClass]","450992b8":"df","d70f80f4":"df.to_csv('sample.csv', index = False)","2f5ff4ba":"Populating training and testing dataholders","3f430fb4":"# Starter Notebook","f2f8b1dd":"# Generating csv file for submission","9edce269":"# **Submitting results to competition**\nEverything runs smoothly, but the problem is you can't see your file anywhere in this page, nor in your Profile, Kernels tab, nowhere! This is because you haven't commited your notebook yet. To do that, click the Save Version button - as I write it, this is a light-blue button in the top-right corner of my notebook page, in the main pane. Click Save and Run All. It may take a minute for the Kaggle server to publish your notebook.\n\nWhen this operation is done, you can click the version number in the top right. Click the Notebook version, and then click the menu (...). Then click \"Submit to Competition\"."}}