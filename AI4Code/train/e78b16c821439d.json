{"cell_type":{"acc29784":"code","ca63303b":"code","451943d8":"code","a9f3c933":"code","fd7b77c4":"markdown","c292ffab":"markdown"},"source":{"acc29784":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","ca63303b":"import numpy as np\nimport cv2\nimport os\n","451943d8":"    def split_letters(captcha_path, save_path=False):\n        '''\n       This simple function will get the full captcha image and preprocess it with opencv,\n       returning the sparse letters in there axial order (left to right).\n       \n       :param captcha_path: directory path to captcha image\n       :param save_path: directory to save each letter's image, defaults to False, which does not save the images\n       :returns: list of the letter images in left-to-right order, images are as numpy arrays.\n        '''\n        \n        #First treatment method\n        method = cv2.THRESH_TRUNC\n        \n        #Reading captcha image with opencv\n        img = cv2.imread(f'{captcha_path}')\n        \n        #Converts Image from RGB format to GrayScale\n        img_grey = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\n        \n        #Gets images height and width respectively\n        (h, w) = img_grey.shape[:2]\n        \n        #Resizes image to 3x its size, makes it easier for Opencv to find the letters\n        img_grey = cv2.resize(img_grey, (w*3, h*3))\n        \n        #Not using the original image anymore, deleting it\n        del img\n        \n        #Preprocessing the grayscale captcha image, first with truncation + OTSU, then\n        #binarizing the image inversely. Making the whole image black (0) and white (255)\n        \n        _, treated_img = cv2.threshold(img_grey, 127, 255, method + cv2.THRESH_OTSU)\n\n        _, treated_img = cv2.threshold(treated_img, 115, 255, cv2.THRESH_BINARY_INV)\n        \n        #Transforming preprocessed image in numpy array\n        binary_img = np.array(treated_img)\n\n       \n\n        #Getting the contours of the image in hope of finding the letters\n        contours , _ = cv2.findContours(binary_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n\n        #Recursive function that gets contours bigger than a given threshold. Only stops when finds exactly 5 contours\n        #or when it hits recursion limit\n        def find_contours(thresh):\n            \n            #List to append the regions where the letters are found\n            regions = []\n            \n            #Iterating through contours and fetching the data\n            for contour in contours:\n                (x, y, width, height) = cv2.boundingRect(contour)\n                area = cv2.contourArea(contour)\n                \n                #Compares the area of the contour with given threshold, if greater, appends as a letter\n                if area > thresh:\n                    regions.append((x, y, width, height))\n\n            #Checking if we have 5 letters, as seen in captcha\n            if len(regions) == 5:\n                return regions\n                \n            else:\n                \n                #If we have more than 5 regions, then we have some unwanted noise, increases threshold and reruns function\n                if len(regions)>5: return find_contours(thresh+5)\n                \n                #If we have less than 5 regions, we are missing a letter, threshold is decreased and function is reruned\n                else: return find_contours(thresh-5)\n                \n\n            \n\n        \n            \n            \n        #Runs above function and raises error if it can't find the correct amount of contours\n        try: regions = find_contours(115)\n        except: raise RuntimeError('Failed to find contours in captcha image, check if image has letters in it')\n        \n        #Sorts the letter images in the left-to-right order based on there position in the X axis\n        regions = sorted(regions, key= lambda list : list[0])\n        \n        #List for the letter images\n        letters=[]\n        \n        #Iterates through the found letter regions\n        for rect in regions:\n            x, y, width, height = rect\n            \n            #Grabs the letters from our binary image, given their position\n            letter_img = binary_img[y-5:y+height+5, x-5:x+width+5]\n            \n            #Gets height and width respectively\n            (h, w) = letter_img.shape[:2]\n            \n            #Resize to twice there size\n            letter_img = cv2.resize(letter_img, (w*2, h*2))\n            \n\n            #Apply small blur, helps recognition\n            letter_img = cv2.GaussianBlur(letter_img, (5,5), 0)\n            \n            #Inverting binary image, making letters black\n            letter_img = 255 - letter_img\n            \n            #Appending to list\n            letters.append(letter_img)\n            \n            #Saves letter to given path, if it is given\n            if save_path:\n                raw_letters = len(os.listdir(save_path))\n\n\n                img_path= save_path+f'\\\\{raw_letters+1}.png'\n                cv2.imwrite(img_path, letter_img)\n        \n        \n        #Returns list of letter images\n        return letters","a9f3c933":"import matplotlib.pyplot as plt\n\nletters = split_letters('..\/input\/simple-gray-captchas\/Captchas\/Captchas\/1.png')\nplt.figure(figsize=(16,5))\nfor i, letter in enumerate(letters):\n    \n    plt.subplot(2,5,i+1)\n    plt.grid(False)\n    plt.imshow(letter)","fd7b77c4":"# Introduction\n\nThis notebook is to show how the captcha images were treated and prepared for the ConvNN training, it's a small code and it's simple if you already have some knowledge on opencv but not so hard otherwise.","c292ffab":"# Treating Captha Images\n\nThis simple function will get the full captcha image and preprocess it with opencv, returning the sparse letters in there axial order (left to right)."}}