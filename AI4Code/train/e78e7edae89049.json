{"cell_type":{"262fa1b1":"code","ecbf7899":"code","ccac17e7":"code","0e78d328":"code","6153ffff":"code","d41c1495":"code","cc21a614":"code","0ecc43ae":"code","9e0e8194":"code","1ba3d415":"code","75417345":"code","1f445e54":"code","29d65a3d":"code","d52dbb40":"code","469af6bd":"code","08b16209":"code","9c8ff873":"code","107d3114":"markdown","aeec7288":"markdown","0d2b600d":"markdown","9571af69":"markdown","8319d4e4":"markdown","f70ab07b":"markdown","5cc06831":"markdown","7fc2dfba":"markdown","87724e28":"markdown","e0173fe5":"markdown","a9f086f9":"markdown"},"source":{"262fa1b1":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n%matplotlib inline\n\nfrom math import sqrt\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\n# Analysis imports\nfrom pandas.plotting import lag_plot\nfrom pylab import rcParams\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom pandas import DataFrame\nfrom pandas import concat\n\n# Modelling imports\nfrom statsmodels.tsa.ar_model import AR\nfrom statsmodels.tsa.arima_model import ARMA\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom fbprophet import Prophet\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM, GRU\nfrom keras.layers import Dropout\n\n","ecbf7899":"dateparse = lambda dates: pd.datetime.strptime(dates, '%Y-%m-%d')\ndata = pd.read_csv('..\/input\/Data\/Stocks\/gs.us.txt', sep=',', parse_dates=['Date'], index_col='Date',date_parser=dateparse)\nplt.figure(figsize=(16,8))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Open Prices')\nplt.plot(data['Open']);","ccac17e7":"plt.figure(figsize=(12,8))\nlag_plot(data['Open'], lag=5)\nplt.title('Goldman Sachs Autocorrelation plot')\nplt.grid(True)\nplt.legend();","0e78d328":"rcParams['figure.figsize'] = 14, 8\ndata_arima = data['Open']\nresult = seasonal_decompose(data_arima[-1000:], model='additive', freq=30)\nplt.figure(figsize=(16,8))\nfig = result.plot()\nplt.show()","6153ffff":"values = DataFrame(data['Open'].values)\ndataframe = concat([values.shift(1),values.shift(5),values.shift(10),values.shift(30), values], axis=1)\ndataframe.columns = ['t', 't+1', 't+5', 't+10', 't+30']\nresult = dataframe.corr()\nprint(result)","d41c1495":"train_data, test_data = data[0:-73], data[-73:]\nplt.figure(figsize=(16,8))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Open Prices')\nplt.plot(data['Open'].tail(600), 'green', label='Train data')\nplt.plot(test_data['Open'], 'blue', label='Test data')\nplt.legend()","cc21a614":"mean_value = data['Open'].mean() # calculation of mean price\n\nplt.figure(figsize=(16,8))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Open Prices')\nplt.plot(data['Open'], 'green', label='Train data')\nplt.plot(test_data['Open'], 'blue', label='Test data')\nplt.axhline(y=mean_value, xmin=0.864, xmax=1, color='red')\nplt.legend()\n\nplt.figure(figsize=(16,8))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Open Prices')\nplt.plot(data['Open'].tail(600), 'green', label='Train data')\nplt.plot(test_data['Open'], 'blue', label='Test data')\nplt.axhline(y=mean_value, xmin=0.864, xmax=1, color='red')\nplt.legend()\n\nprint('MSE: '+str(mean_squared_error(test_data['Open'], np.full(len(test_data), mean_value))))\nprint('MAE: '+str(mean_absolute_error(test_data['Open'], np.full(len(test_data), mean_value))))\nprint('RMSE: '+str(sqrt(mean_squared_error(test_data['Open'], np.full(len(test_data), mean_value)))))","0ecc43ae":"train_ar = train_data['Open']\ntest_ar = test_data['Open']\n\nmodel = AR(train_ar)# train autoregression\nmodel_fit = model.fit()\nwindow = model_fit.k_ar\ncoef = model_fit.params\n\n# walk forward over time steps in test\nhistory = train_ar[len(train_ar)-window:]\nhistory = [history[i] for i in range(len(history))]\npredictions = list()\nfor t in range(len(test_ar)):\n    length = len(history)\n    lag = [history[i] for i in range(length-window,length)]\n    yhat = coef[0]\n    for d in range(window):\n        yhat += coef[d+1] * lag[window-d-1]\n    obs = test_ar[t]\n    predictions.append(yhat)\n    history.append(obs)\n \nplt.figure(figsize=(14,8))\nplt.plot(data.index[-600:], data['Open'].tail(600), color='green', label='Close price')\nplt.plot(test_data.index, test_data['Open'], color='red', label='Test close price')\nplt.plot(test_data.index, predictions, color='blue', label='Predicted close price')\nplt.xticks(rotation=30)\nplt.grid(True)\nplt.legend()\n\nplt.figure(figsize=(14,8))\nprint('Lag: %s' % model_fit.k_ar)\nplt.plot(data.index[-100:], data['Open'].tail(100), color='green', label='Close price')\nplt.plot(test_data.index, test_data['Open'], color='red', label='Test close price')\nplt.plot(test_data.index, predictions, color='blue', label='Predicted close price')\nplt.xticks(rotation=30)\nplt.grid(True)\nplt.legend()\n\nprint('MSE: '+str(mean_squared_error(test_data['Open'], predictions)))\nprint('MAE: '+str(mean_absolute_error(test_data['Open'], predictions)))\nprint('RMSE: '+str(sqrt(mean_squared_error(test_data['Open'], predictions))))","9e0e8194":"train_ma = train_data['Open']\ntest_ma = test_data['Open']\n\nhistory = [x for x in train_ma]\ny = test_ma\n# make first prediction\npredictions = list()\nmodel = ARMA(history, order=(0,8))\nmodel_fit = model.fit(disp=0)\nyhat = model_fit.forecast()[0]\npredictions.append(yhat)\n\nhistory.append(y[0])\n# rolling forecasts\nfor i in range(1, len(y)):\n    # predict\n    model = ARMA(history, order=(0,8))\n    model_fit = model.fit(disp=0)\n    yhat = model_fit.forecast()[0]\n    # invert transformed prediction\n    predictions.append(yhat)\n    # observation\n    obs = y[i]\n    history.append(obs)\n\nplt.figure(figsize=(14,8))\nplt.plot(data.index[-600:], data['Open'].tail(600), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, y, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predictions, color = 'blue', label = 'Predicted Stock Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nplt.figure(figsize=(14,8))\nplt.plot(data.index[-100:], data['Open'].tail(100), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, y, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predictions, color = 'blue', label = 'Predicted Stock Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nprint('MSE: '+str(mean_squared_error(y, predictions)))\nprint('MAE: '+str(mean_absolute_error(y, predictions)))\nprint('RMSE: '+str(sqrt(mean_squared_error(y, predictions))))","1ba3d415":"train_arma = train_data['Open']\ntest_arma = test_data['Open']\n\nhistory = [x for x in train_arma]\ny = test_arma\n# make first prediction\npredictions = list()\nmodel = ARMA(history, order=(1,8))\nmodel_fit = model.fit(disp=0)\nyhat = model_fit.forecast()[0]\npredictions.append(yhat)\n\nhistory.append(y[0])\n# rolling forecasts\nfor i in range(1, len(y)):\n    # predict\n    model = ARMA(history, order=(1,8))\n    model_fit = model.fit(disp=0)\n    yhat = model_fit.forecast()[0]\n    # invert transformed prediction\n    predictions.append(yhat)\n    # observation\n    obs = y[i]\n    history.append(obs)\n\nplt.figure(figsize=(14,8))\nplt.plot(data.index, data['Open'], color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, y, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predictions, color = 'blue', label = 'Predicted Stock Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nplt.figure(figsize=(14,8))\nplt.plot(data.index[-100:], data['Open'].tail(100), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, y, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predictions, color = 'blue', label = 'Predicted Stock Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nprint('MSE: '+str(mean_squared_error(y, predictions)))\nprint('MAE: '+str(mean_absolute_error(y, predictions)))\nprint('RMSE: '+str(sqrt(mean_squared_error(y, predictions))))","75417345":"train_arima = train_data['Open']\ntest_arima = test_data['Open']\n\nhistory = [x for x in train_arima]\ny = test_arima\n# make first prediction\npredictions = list()\nmodel = ARIMA(history, order=(1,1,0))\nmodel_fit = model.fit(disp=0)\nyhat = model_fit.forecast()[0]\npredictions.append(yhat)\nhistory.append(y[0])\n# rolling forecasts\nfor i in range(1, len(y)):\n    # predict\n    model = ARIMA(history, order=(1,1,1))\n    model_fit = model.fit(disp=0)\n    yhat = model_fit.forecast()[0]\n    # invert transformed prediction\n    predictions.append(yhat)\n    # observation\n    obs = y[i]\n    history.append(obs)\n    \nplt.figure(figsize=(14,8))\nplt.plot(data.index, data['Open'], color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, y, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predictions, color = 'blue', label = 'Predicted Stock Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nplt.figure(figsize=(14,8))\nplt.plot(data.index[-600:], data['Open'].tail(600), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, y, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predictions, color = 'blue', label = 'Predicted Stock Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nprint('MSE: '+str(mean_squared_error(y, predictions)))\nprint('MAE: '+str(mean_absolute_error(y, predictions)))\nprint('RMSE: '+str(sqrt(mean_squared_error(y, predictions))))","1f445e54":"# Drop the columns\nph_df_train = train_data.drop(['Close', 'High', 'Low','Volume', 'OpenInt'], axis=1)\nph_df_train['Date'] = ph_df_train.index\nph_df_train.rename(columns={'Open': 'y', 'Date': 'ds'}, inplace=True)\n\nprop = Prophet(changepoint_prior_scale=0.1)\nprop.fit(ph_df_train)\n# Create Future dates\nfuture_prices = prop.make_future_dataframe(periods=73)\n\n# Predict Prices\nforecast = prop.predict(future_prices)","29d65a3d":"plt.figure(figsize=(14,8))\nplt.plot(data.index, data['Open'], color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, test_data['Open'], color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, forecast['yhat'][-73:], color = 'blue', label = 'Predicted Stock Price')\nplt.fill_between(test_data.index, forecast['yhat_lower'][-73:], forecast['yhat_upper'][-73:], color='grey', label=\"Band Range\")\nplt.legend()\nplt.grid(True)\nplt.show()\n\nplt.figure(figsize=(14,8))\nplt.plot(data.index[-600:], data['Open'].tail(600), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, test_data['Open'], color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, forecast['yhat'][-73:], color = 'blue', label = 'Predicted Stock Price')\nplt.fill_between(test_data.index, forecast['yhat_lower'][-73:], forecast['yhat_upper'][-73:], color='grey', label=\"Band Range\")\nplt.legend()\nplt.grid(True)\nplt.show()\n\nprint('MSE: '+str(mean_squared_error(test_data['Open'], forecast['yhat'][-73:])))\nprint('MAE: '+str(mean_absolute_error(test_data['Open'], forecast['yhat'][-73:])))\nprint('RMSE: '+str(sqrt(mean_squared_error(test_data['Open'], forecast['yhat'][-73:]))))","d52dbb40":"train = train_data.iloc[:, 0:1].values # selecting open prices\n# Feature Scaling\nscaler = MinMaxScaler()\ntrain_scaled = scaler.fit_transform(train) \n# Train dataset\ntimesteps = 7\nX_train = []\ny_train = []\nfor i in range(timesteps, train.shape[0]):\n    X_train.append(train_scaled[i-timesteps:i, 0]) # we take 30 previous prices\n    y_train.append(train_scaled[i, 0]) # and 60-th price as y value\nX_train, y_train = np.array(X_train), np.array(y_train)\n# Reshaping\nX_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))\nfrom numpy.random import seed\nseed(2019)","469af6bd":"model = Sequential()\n\n# Adding the first LSTM layer \n# Here return_sequences=True means whether to return the last output in the output sequence, or the full sequence.\n# it basically tells us that there is another(or more) LSTM layer ahead in the network.\nmodel.add(LSTM(units = 60, return_sequences = True, input_shape = (X_train.shape[1], 1)))\n# Dropout regularisation for tackling overfitting\nmodel.add(Dropout(0.2))\n\nmodel.add(LSTM(units = 50))\nmodel.add(Dropout(0.25))\n\n# Adding the output layer\nmodel.add(Dense(units = 1))\n\n# Compiling the RNN\n# RMSprop is a recommended optimizer as per keras documentation\n# check out https:\/\/keras.io\/optimizers\/ for more details\nmodel.compile(optimizer = 'adam', loss = 'mean_squared_error')\n\n# Fitting the RNN to the Training set\nmodel.fit(X_train, y_train, epochs = 65, batch_size = 16)","08b16209":"# this will be used later while comparing and visualization\nreal_stock_price = test_data.iloc[:,0:1].values # taking open price\n# combine original train and test data vertically\n# as previous Open Prices are not present in test dataset\n# e.g. for predicting Open price for first date in test data, we will need stock open prices on timesteps previous dates  \ncombine = pd.concat((train_data['Open'], test_data['Open']), axis = 0)\n# our test inputs also contains stock open Prices of last timesteps dates (as described above)\ntest_inputs = combine[len(combine) - len(test_data) - timesteps:].values\ntest_inputs = test_inputs.reshape(-1,1)\ntest_inputs = scaler.transform(test_inputs)\n# same steps as we followed while processing training data\nX_test = []\nfor i in range(timesteps, test_data.shape[0]+timesteps):\n    X_test.append(test_inputs[i-timesteps:i, 0])\nX_test = np.array(X_test)\nX_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))\npredicted_stock_price = model.predict(X_test)\n# inverse_transform because prediction is done on scaled inputs\npredicted_stock_price = scaler.inverse_transform(predicted_stock_price)","9c8ff873":"plt.figure(figsize=(16,8))\nplt.plot(data.index[-600:], data['Open'].tail(600), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, real_stock_price, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predicted_stock_price, color = 'blue', label = 'Predicted Stock Price')\nplt.title('Goldman Sachs Stock Price Prediction')\nplt.xlabel('Time')\nplt.ylabel('Goldman Sachs Stock Price')\nplt.legend()\nplt.grid(True)\nplt.savefig('lstm_30.pdf')\nplt.show()\n\nmse = mean_squared_error(real_stock_price, predicted_stock_price)\nprint('MSE: '+str(mse))\nmae = mean_absolute_error(real_stock_price, predicted_stock_price)\nprint('MAE: '+str(mae))\nrmse = sqrt(mean_squared_error(real_stock_price, predicted_stock_price))\nprint('RMSE: '+str(rmse))","107d3114":"# Data Analysis","aeec7288":"### Seasonal decompose","0d2b600d":"# Facebook Prophet","9571af69":"### Autocorrelation plot","8319d4e4":"# Autoregression model","f70ab07b":"# LSTM","5cc06831":"# ARMA Model","7fc2dfba":"# Moving Average model","87724e28":"# ARIMA model","e0173fe5":"# Train-Test Split","a9f086f9":"# Mean value plot"}}