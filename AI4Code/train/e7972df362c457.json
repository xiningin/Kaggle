{"cell_type":{"0d7f947b":"code","c6ab6323":"code","ce1a63c9":"code","b179bb91":"code","7b9e4915":"code","f2dca928":"code","b0f0b06a":"code","5cb50cf7":"code","d9639d72":"code","4aac70c4":"code","8ed385b7":"code","4ad25261":"code","f93b6903":"code","4d605e26":"code","dc26c0e8":"code","808bb0b4":"code","b862e0b1":"code","b5209eb1":"code","01c4d1d8":"code","b3aa721e":"code","19174093":"code","074e6fcf":"code","6680f405":"code","6098c744":"code","9f8666be":"code","cbb1e8d4":"code","e242d673":"code","610ab3df":"code","66bac428":"code","81d21a64":"code","d72c368d":"markdown","5d97c60a":"markdown","c9f763b3":"markdown","3fcadd9d":"markdown","04ab5428":"markdown","70058cc3":"markdown","ba45523a":"markdown","bebb3e0a":"markdown","9b45eed0":"markdown","46531794":"markdown","492cdf57":"markdown","a5efe03a":"markdown","821c27da":"markdown","e9202b42":"markdown","246a0204":"markdown","1c08e83a":"markdown","01f068b4":"markdown","484aea8d":"markdown","bc8d3561":"markdown"},"source":{"0d7f947b":"import gym # openAi gym\nfrom gym import envs\nimport numpy as np \nimport datetime\nimport keras \nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nimport pandas as pd \nfrom time import sleep\n\nfrom rl.agents.dqn import DQNAgent\nfrom rl.policy import LinearAnnealedPolicy, BoltzmannQPolicy, EpsGreedyQPolicy\nfrom rl.memory import SequentialMemory\nfrom rl.core import Processor\nfrom rl.callbacks import FileLogger, ModelIntervalCheckpoint\nimport warnings\nwarnings.filterwarnings('ignore')","c6ab6323":"env = gym.make('Taxi-v2')\nenv.reset()\nenv.render()","ce1a63c9":"env.observation_space.n   #Total no. of states","b179bb91":"env.action_space.n   #Total no. of actions","7b9e4915":"env.env.s = 122\nenv.render()","f2dca928":"env.step(3)","b0f0b06a":"env.render()  #view state","5cb50cf7":"env.reset()\nenv.env.P[300]","d9639d72":"env = gym.make('Taxi-v2')\nrandom_policy = np.ones([env.env.nS, env.env.nA]) \/ env.env.nA\ndef random_policy_steps_count():\n    state = env.reset()\n    counter = 0\n    reward = None\n    while reward != 20:\n        state, reward, done, info = env.step(env.action_space.sample())  \n        counter += 1\n    return counter\n","4aac70c4":"counts = [random_policy_steps_count() for i in range(1000)]\nsns.distplot(counts)\nplt.title(\"Distribution of number of steps needed\")","8ed385b7":"print(\"An agent using Random search takes about an average of \" + str(int(np.mean(counts)))\n      + \" steps to successfully complete its mission.\")","4ad25261":"def policy_eval(policy, env, discount_factor=1.0, theta=0.00001):\n    \"\"\"\n    Evaluate a policy given an environment and a full description of the environment's dynamics.\n    \n    Args:\n        policy: [S, A] shaped matrix representing the policy.\n        env: OpenAI env. env.P represents the transition probabilities of the environment.\n            env.P[s][a] is a list of transition tuples (prob, next_state, reward, done).\n            env.nS is a number of states in the environment. \n            env.nA is a number of actions in the environment.\n        theta: We stop evaluation once our value function change is less than theta for all states.\n        discount_factor: Gamma discount factor.\n    \n    Returns:\n        Vector of length env.nS representing the value function.\n    \"\"\"\n    # Start with a random (all 0) value function\n    V = np.zeros(env.env.nS)\n    while True:\n        # TODO: Implement!\n        delta = 0  #delta = change in value of state from one iteration to next\n       \n        for state in range(env.env.nS):  #for all states\n            val = 0  #initiate value as 0\n            \n            for action,act_prob in enumerate(policy[state]): #for all actions\/action probabilities\n                for prob,next_state,reward,done in env.env.P[state][action]:  #transition probabilities,state,rewards of each action\n                    val += act_prob * prob * (reward + discount_factor * V[next_state])  #eqn to calculate\n            delta = max(delta, np.abs(val-V[state]))\n            V[state] = val\n        if delta < theta:  #break if the change in value is less than the threshold (theta)\n            break\n    return np.array(V)\n\ndef policy_iteration(env, policy_eval_fn=policy_eval, discount_factor=1.0):\n    \"\"\"\n    Policy Improvement Algorithm. Iteratively evaluates and improves a policy\n    until an optimal policy is found.\n    \n    Args:\n        env: The OpenAI envrionment.\n        policy_eval_fn: Policy Evaluation function that takes 3 arguments:\n            policy, env, discount_factor.\n        discount_factor: gamma discount factor.\n        \n    Returns:\n        A tuple (policy, V). \n        policy is the optimal policy, a matrix of shape [S, A] where each state s\n        contains a valid probability distribution over actions.\n        V is the value function for the optimal policy.\n        \n    \"\"\"\n    def one_step_lookahead(state, V):\n        \"\"\"\n        Helper function to calculate the value for all action in a given state.\n        \n        Args:\n            state: The state to consider (int)\n            V: The value to use as an estimator, Vector of length env.nS\n        \n        Returns:\n            A vector of length env.nA containing the expected value of each action.\n        \"\"\"\n        A = np.zeros(env.env.nA)\n        for a in range(env.env.nA):\n            for prob, next_state, reward, done in env.env.P[state][a]:\n                A[a] += prob * (reward + discount_factor * V[next_state])\n        return A\n    # Start with a random policy\n    policy = np.ones([env.env.nS, env.env.nA]) \/ env.env.nA\n\n    while True:\n        # Implement this!\n        curr_pol_val = policy_eval_fn(policy, env, discount_factor)  #eval current policy\n        policy_stable = True  #Check if policy did improve (Set it as True first)\n        for state in range(env.env.nS):  #for each states\n            chosen_act = np.argmax(policy[state])  #best action (Highest prob) under current policy\n            act_values = one_step_lookahead(state,curr_pol_val)  #use one step lookahead to find action values\n            best_act = np.argmax(act_values) #find best action\n            if chosen_act != best_act:\n                policy_stable = False  #Greedily find best action\n            policy[state] = np.eye(env.env.nA)[best_act]  #update \n        if policy_stable:\n            return policy, curr_pol_val\n    \n    return policy, np.zeros(env.env.nS)\n\ndef value_iteration(env, theta=0.0001, discount_factor=1.0):\n    \"\"\"\n    Value Iteration Algorithm.\n    \n    Args:\n        env: OpenAI env. env.P represents the transition probabilities of the environment.\n            env.P[s][a] is a list of transition tuples (prob, next_state, reward, done).\n            env.nS is a number of states in the environment. \n            env.nA is a number of actions in the environment.\n        theta: We stop evaluation once our value function change is less than theta for all states.\n        discount_factor: Gamma discount factor.\n        \n    Returns:\n        A tuple (policy, V) of the optimal policy and the optimal value function.        \n    \"\"\"\n    \n    def one_step_lookahead(state, V):\n        \"\"\"\n        Helper function to calculate the value for all action in a given state.\n        \n        Args:\n            state: The state to consider (int)\n            V: The value to use as an estimator, Vector of length env.nS\n        \n        Returns:\n            A vector of length env.nA containing the expected value of each action.\n        \"\"\"\n        A = np.zeros(env.env.nA)\n        for act in range(env.env.nA):\n            for prob, next_state, reward, done in env.env.P[state][act]:\n                A[act] += prob * (reward + discount_factor*V[next_state])\n        return A\n    \n    V = np.zeros(env.env.nS)\n    while True:\n        delta = 0  #checker for improvements across states\n        for state in range(env.env.nS):\n            act_values = one_step_lookahead(state,V)  #lookahead one step\n            best_act_value = np.max(act_values) #get best action value\n            delta = max(delta,np.abs(best_act_value - V[state]))  #find max delta across all states\n            V[state] = best_act_value  #update value to best action value\n        if delta < theta:  #if max improvement less than threshold\n            break\n    policy = np.zeros([env.env.nS, env.env.nA])\n    for state in range(env.env.nS):  #for all states, create deterministic policy\n        act_val = one_step_lookahead(state,V)\n        best_action = np.argmax(act_val)\n        policy[state][best_action] = 1\n        \n    \n    # Implement!\n    return policy, V","f93b6903":"env = gym.make('Taxi-v2')\nrandom_policy = np.ones([env.env.nS, env.env.nA]) \/ env.env.nA\npolicy_eval(random_policy,env,discount_factor=0.95)","4d605e26":"pol_iter_policy = policy_iteration(env,policy_eval,discount_factor=0.99)\npol_iter_policy[0]","dc26c0e8":"val_iter_policy = value_iteration(env,discount_factor=0.99)\nval_iter_policy[0]","808bb0b4":"for x in range(len(pol_iter_policy[0])):\n    if not (pol_iter_policy[0][x] == val_iter_policy[0][x]).all():\n        print(\"Not the same Policy\")\n        break\nprint(\"Same Policy\")","b862e0b1":"def count(policy):\n    curr_state = env.reset()\n    counter = 0\n    reward = None\n    while reward != 20:\n        state, reward, done, info = env.step(np.argmax(policy[curr_state]))  \n        curr_state = state\n        counter += 1\n    return counter","b5209eb1":"pol_count = count(pol_iter_policy[0])\npol_counts = [count(pol_iter_policy[0]) for i in range(10000)]\nprint(\"An agent using a policy which has been improved using policy-iterated takes about an average of \" + str(int(np.mean(pol_counts)))\n      + \" steps to successfully complete its mission.\")\nsns.distplot(pol_counts)","01c4d1d8":"val_count = count(val_iter_policy[0])\nval_counts = [count(val_iter_policy[0]) for i in range(10000)]\nprint(\"An agent using a policy which has been value-iterated takes about an average of \" + str(int(np.mean(val_counts)))\n      + \" steps to successfully complete its mission.\")\nsns.distplot(val_counts)","b3aa721e":"import random\nfrom IPython.display import clear_output\n\ndef Q_learning_train(env,alpha,gamma,epsilon,episodes): \n    \"\"\"Q Learning Algorithm with epsilon greedy \n\n    Args:\n        env: Environment \n        alpha: Learning Rate --> Extent to which our Q-values are being updated in every iteration.\n        gamma: Discount Rate --> How much importance we want to give to future rewards\n        epsilon: Probability of selecting random action instead of the 'optimal' action\n        episodes: No. of episodes to train on\n\n    Returns:\n        Q-learning Trained policy\n\n    \"\"\"\n    %%time\n    \"\"\"Training the agent\"\"\"\n\n    # For plotting metrics\n    all_epochs = []\n    all_penalties = []\n    \n    #Initialize Q table of 500 x 6 size (500 states and 6 actions) with all zeroes\n    q_table = np.zeros([env.observation_space.n, env.action_space.n])  \n    \n    for i in range(1, episodes+1):\n        state = env.reset()\n\n        epochs, penalties, reward, = 0, 0, 0\n        done = False\n\n        while not done:\n            if random.uniform(0, 1) < epsilon:\n                action = env.action_space.sample() # Explore action space randomly\n            else:\n                action = np.argmax(q_table[state]) # Exploit learned values by choosing optimal values\n\n            next_state, reward, done, info = env.step(action) \n\n            old_value = q_table[state, action]\n            next_max = np.max(q_table[next_state])\n\n            new_value = (1 - alpha) * old_value + alpha * (reward + gamma * next_max)\n            q_table[state, action] = new_value\n\n            if reward == -10:\n                penalties += 1\n\n            state = next_state\n            epochs += 1\n\n        if i % 100 == 0:\n            clear_output(wait=True)\n            print(f\"Episode: {i}\")\n    # Start with a random policy\n    policy = np.ones([env.env.nS, env.env.nA]) \/ env.env.nA\n\n    for state in range(env.env.nS):  #for each states\n        best_act = np.argmax(q_table[state]) #find best action\n        policy[state] = np.eye(env.env.nA)[best_act]  #update \n        \n    print(\"Training finished.\\n\")\n    return policy, q_table","19174093":"env = gym.make('Taxi-v2')\nenv.reset()\nQ_learn_pol = Q_learning_train(env,0.2,0.95,0.1,100000)","074e6fcf":"Q_Learning_counts = count(Q_learn_pol[0])\nQ_counts = [count(Q_learn_pol[0]) for i in range(1000)]\nprint(\"An agent using a policy which has been improved using Q-learning takes about an average of \" + str(int(np.mean(Q_counts)))\n      + \" steps to successfully complete its mission.\")\nsns.distplot(Q_counts)","6680f405":"def view_policy(policy):\n    curr_state = env.reset()\n    counter = 0\n    reward = None\n    while reward != 20:\n        state, reward, done, info = env.step(np.argmax(policy[0][curr_state])) \n        curr_state = state\n        counter += 1\n        env.env.s = curr_state\n        env.render()\n    ","6098c744":"view_policy(pol_iter_policy)","9f8666be":"view_policy(val_iter_policy)","cbb1e8d4":"view_policy(Q_learn_pol)","e242d673":"from IPython.display import clear_output\n\nfrom matplotlib import animation\nfrom IPython.display import display\n\n\ndef view_policy_anim(policy):\n    penalties, reward = 0, 0\n\n    frames = [] # for animation\n\n    done = False\n    curr_state = env.reset()\n    while not done:\n        action = np.argmax(policy[0][curr_state])\n        state, reward, done, info = env.step(action)\n        curr_state = state\n        if reward == -10:\n            penalties += 1\n\n        # Put each rendered frame into dict for animation\n        frames.append({\n            'frame': env.render(mode='ansi'),\n            'state': state,\n            'action': action,\n            'reward': reward\n            }\n        )\n    def print_frames(frames):\n        for i, frame in enumerate(frames):\n            clear_output(wait=True)\n            print(frame['frame'].getvalue())\n            print(f\"Timestep: {i + 1}\")\n            print(f\"State: {frame['state']}\")\n            print(f\"Action: {frame['action']}\")\n            print(f\"Reward: {frame['reward']}\")\n            sleep(.2)\n\n    print_frames(frames)","610ab3df":"view_policy_anim(val_iter_policy)","66bac428":"view_policy_anim(pol_iter_policy)","81d21a64":"view_policy_anim(Q_learn_pol)","d72c368d":"**We can see that the improved policy is definitely much more efficient than the random search.**","5d97c60a":"**Representations**\n\n- | --> WALL (Can't pass through, will remain in the same position if tries to move through wall)\n\n- Yellow --> Taxi Current Location\n\n- Blue --> Pick up Location\n\n- Purple --> Drop-off Location\n\n- Green --> Taxi turn green once passenger board\n\n- Letters --> Locations\n","c9f763b3":"# **3. Policy Iteration\/Value Iteration**\n\n**Policy Iteration** --> The algorithm redefines the policy at each step and improve the policy, and then compute the value according to this new policy until the policy converges.\n\n**Value Iteration** --> The algorithm computes the optimal state value function by iteratively improving the estimate of V(s). The algorithm initialize V(s) to arbitrary random values. It repeatedly updates the Q(s, a) and V(s) values until they converge. \n\n\nPolicy iteration and Value Iteration are guranteed to convege to the optimal policy and it often takes less iterations for policy iteration to converge than the value-iteration algorithm.\n\nBoth value-iteration and policy-iteration algorithms can be used for offline planning where the agent is assumed to have prior knowledge about the effects of its actions on the environment (they assume the Markov Decision model is known). Comparing to each other, policy-iteration is computationally efficient as it often takes considerably fewer number of iterations to converge although each iteration is more computationally expensive.","3fcadd9d":"# **4. Now, let's implement Q-learning with epsilon-greedy method** \n\nThe algorithm for Q-learning is as follows:\n\n- Initialize the Q-table by all zeros.\n- Start exploring actions: For each state, select any one among all possible actions for the current state (S).\n- Travel to the next state (S') as a result of that action (a).\n- For all possible actions from the state (S') select the one with the highest Q-value with probability (1-epsilon) and select a random action with probability (epsilon). This is to balance the exploration and exploitation actions.\n- Update Q-table values using the equation:  **Q(state,action) <- (1\u2212\u03b1) * Q(state,action) + \u03b1(reward + \u03b3 * max<sub>a<\/sub>Q(next state,all actions))**\n- Set the next state as the current state.\n- If goal state is reached, then end and repeat the process.","04ab5428":"The function (env.P) below can be used to see the relevant states and rewards for each action taken in that particular state.","70058cc3":"Clearly, it is not the most efficient way to complete this. Let's try to use policy iteration and value iteration method to more effectively let our agent complete this task. ","ba45523a":"We can also view it animated by running the function below. ","bebb3e0a":"Let's evaluate the random policy. ","9b45eed0":"# **2. Random Search**\nLet's start with the simplest way to train our agent to complete this task. The agent would just take random steps at every state until he completes the task (picking the passenger and dropping him off at the drop-off location). ","46531794":"**3.1 Functions for policy evaluation, policy iteration and value iteration.**","492cdf57":"Total Number of states in the environment = **500** (0 to 499)","a5efe03a":"Next, we use value iteration to improve our policy.","821c27da":"# **5. Let's watch how our optimal policies works in action**","e9202b42":"Each timestep, the agent chooses an action, and the environment returns an observation and a reward.\n\nThe 4 elements returned are:\n\n-  **Observation (object)**: the state the environment is in or an environment-specific object representing your observation of the environment.\n-  **Reward (float)**: Reward achieved by the previous action. \n    -  +20: Last step when we successfully pick up a passenger and drop them off at their desired location\n    -  -1: for each step in order for the agent to try and find the quickest solution possible\n    -  -10: every time you incorrectly pick up or drop off a passenger\n-  **Done (boolean)**: whether it\u2019s time to reset the environment again. Most (but not all) tasks are divided up into well-defined episodes, and done being True indicates the episode has terminated. (For example, you lost your last life.)\n-  **Info (dict)**: Can be ignored, diagnostic information useful for debugging. Official evaluations of your agent are not allowed to use this for learning.","246a0204":"**Actions (6 in total)**\n\n- 0: move south\n- 1: move north\n- 2: move east \n- 3: move west \n- 4: pickup passenger\n- 5: dropoff passenger","1c08e83a":"We can see that policy-iterated and value-iterated policies would converge to the same policy. ","01f068b4":"# **Introduction to Reinforcement Learning with Taxi V2 OpenAI Gym**\n\nWe shall use the Taxi V2 Open AI gym library. \nThe Documentation can be found at: https:\/\/github.com\/openai\/gym\/blob\/master\/gym\/envs\/toy_text\/taxi.py","484aea8d":"# **1. Intro to taxi game environment**\n\nThe aim of the taxi game is to make sure the taxi can get to the passenger, pick him up and bring him to the drop-off location in the fastest way possible.","bc8d3561":"Now let's use policy iteration to improve our policy. "}}