{"cell_type":{"afc036db":"code","fa951337":"code","5358d23b":"code","e3ecab5b":"code","cdd28239":"code","6fbb86be":"code","4bd89a7f":"code","8fe16f5b":"code","da0fa096":"code","f224036c":"code","0b762ac3":"code","1bc24702":"code","fcb167f4":"code","a801c7fe":"code","f8a7d920":"code","4300bd95":"code","6717da15":"code","ee20a3a9":"code","dd74cce3":"code","518e23b0":"code","b3e38311":"code","db0dd19a":"code","2cfefe7a":"code","3a029269":"code","80605d28":"code","02415d3b":"code","9e8da34c":"code","634dde1f":"code","289ef3b6":"code","3fd4a28d":"code","26386a33":"code","9eb4ce6e":"code","b78f7915":"code","e250e34f":"code","be737884":"code","bc19b9c8":"code","0f57dac1":"code","6d81c522":"code","dd34a84c":"code","ddb6209c":"code","f8990ee2":"code","f968f434":"code","ae9510db":"code","36b58d3a":"markdown","20af0427":"markdown","18f7ea73":"markdown","db5e83d1":"markdown","8585de65":"markdown","169c7090":"markdown","7e550e0b":"markdown","d28bb173":"markdown","0a3838a1":"markdown","5b1d3386":"markdown","90699f35":"markdown","55fa9ab1":"markdown","13492f49":"markdown","dd807a34":"markdown","a453aaae":"markdown","8625dc92":"markdown","0c67da49":"markdown","446cd44f":"markdown","eca0f70f":"markdown","7503633e":"markdown","c95351b6":"markdown","e4157276":"markdown","e931c572":"markdown","580ecba5":"markdown","3b252854":"markdown","2bbc3a85":"markdown","893ab3ba":"markdown","a25ac857":"markdown","c3ee9696":"markdown","2036d1e9":"markdown","cf83224d":"markdown","716fceb3":"markdown","ac5e72f0":"markdown","b5b54153":"markdown","dfa3ae3a":"markdown","2b0058d2":"markdown","6e5fe048":"markdown","5345966e":"markdown","3f0c34e2":"markdown","30792615":"markdown","6b9a5844":"markdown","59b8fe98":"markdown","85ed42c7":"markdown","9441e54d":"markdown","518c924c":"markdown","dfbd76b2":"markdown","26c52082":"markdown","6cb8d3a9":"markdown","06111ffe":"markdown","ecb35afe":"markdown","56dbac79":"markdown","7d62993f":"markdown","78f43945":"markdown","4ecf7c53":"markdown","52685290":"markdown","17587914":"markdown","afdfc609":"markdown","b870e838":"markdown","700b7468":"markdown","5f0d53d8":"markdown","3f51c62d":"markdown","2e5971fc":"markdown","27e06113":"markdown","f2673a9f":"markdown","912e2080":"markdown","3e7c982d":"markdown","1e2affd4":"markdown","e1e62acd":"markdown","5e686089":"markdown","0c646106":"markdown","5b854da5":"markdown","55b11ec8":"markdown"},"source":{"afc036db":"\n# @title Tutorial slides\n\n# @markdown These are the slides for the videos in this tutorial\nfrom IPython.display import IFrame\nIFrame(src=f\"https:\/\/mfr.ca-1.osf.io\/render?url=https:\/\/osf.io\/mf79a\/?direct%26mode=render%26action=download%26mode=render\", width=854, height=480)","fa951337":"# @title Install dependencies\n!apt-get install -y ffmpeg > \/dev\/null\n!pip install imageio-ffmpeg --quiet\n\n!pip install git+https:\/\/github.com\/NeuromatchAcademy\/evaltools --quiet\nfrom evaltools.airtable import AirtableForm\n\n# generate airtable form\natform = AirtableForm('appn7VdPRseSoMXEG','W1D5_T1','https:\/\/portal.neuromatchacademy.org\/api\/redirect\/to\/9c55f6cb-cdf9-4429-ac1c-ec44fe64c303')","5358d23b":"# Imports\nfrom __future__ import print_function\n\nimport time\nimport copy\nimport torch\nimport pathlib\n\nimport numpy as np\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.nn.functional as F\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\nfrom tqdm.auto import tqdm\nfrom IPython.display import HTML\nfrom torchvision import transforms\nfrom torchvision.datasets import ImageFolder","e3ecab5b":"# @title Figure Settings\nimport ipywidgets as widgets\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nplt.style.use(\"https:\/\/raw.githubusercontent.com\/NeuromatchAcademy\/content-creation\/main\/nma.mplstyle\")","cdd28239":"# @title Loading Animal Faces data\nimport requests, os\nfrom zipfile import ZipFile\n\nprint(\"Start downloading and unzipping `AnimalFaces` dataset...\")\nname = 'afhq'\nfname = f\"{name}.zip\"\nurl = f\"https:\/\/osf.io\/kgfvj\/download\"\n\nif not os.path.exists(fname):\n  r = requests.get(url, allow_redirects=True)\n  with open(fname, 'wb') as fh:\n    fh.write(r.content)\n\n  if os.path.exists(fname):\n    with ZipFile(fname, 'r') as zfile:\n      zfile.extractall(f\".\")\n      os.remove(fname)\n\nprint(\"Download completed.\")","6fbb86be":"# @title Loading Animal Faces Randomized data\nfrom IPython.display import clear_output\n\nprint(\"Start downloading and unzipping `Randomized AnimalFaces` dataset...\")\n\nnames = ['afhq_random_32x32', 'afhq_10_32x32']\nurls = [\"https:\/\/osf.io\/9sj7p\/download\",\n        \"https:\/\/osf.io\/wvgkq\/download\"]\n\n\nfor i, name in enumerate(names):\n  url = urls[i]\n  fname = f\"{name}.zip\"\n\n  if not os.path.exists(fname):\n    r = requests.get(url, allow_redirects=True)\n    with open(fname, 'wb') as fh:\n      fh.write(r.content)\n\n    if os.path.exists(fname):\n      with ZipFile(fname, 'r') as zfile:\n        zfile.extractall(f\".\")\n        os.remove(fname)\n\nprint(\"Download completed.\")","4bd89a7f":"# @title Plotting functions\ndef imshow(img):\n  img = img \/ 2 + 0.5     # unnormalize\n  npimg = img.numpy()\n  plt.imshow(np.transpose(npimg, (1, 2, 0)))\n  plt.axis(False)\n  plt.show()\n\n\ndef plot_weights(norm, labels, ws, title='Weight Size Measurement'):\n  plt.figure(figsize=[8, 6])\n  plt.title(title)\n  plt.ylabel('Frobenius Norm Value')\n  plt.xlabel('Model Layers')\n  plt.bar(labels, ws)\n  plt.axhline(y=norm,\n              linewidth=1,\n              color='r',\n              ls='--',\n              label='Total Model F-Norm')\n  plt.legend()\n  plt.show()\n\n\ndef early_stop_plot(train_acc_earlystop, val_acc_earlystop, best_epoch):\n  plt.figure(figsize=(8, 6))\n  plt.plot(val_acc_earlystop,label='Val - Early',c='red',ls = 'dashed')\n  plt.plot(train_acc_earlystop,label='Train - Early',c='red',ls = 'solid')\n  plt.axvline(x=best_epoch, c='green', ls='dashed',\n              label='Epoch for Max Val Accuracy')\n  plt.title('Early Stopping')\n  plt.ylabel('Accuracy (%)')\n  plt.xlabel('Epoch')\n  plt.legend()\n  plt.show()","8fe16f5b":"# @title Set random seed\n\n# @markdown Executing `set_seed(seed=seed)` you are setting the seed\n\n# for DL its critical to set the random seed so that students can have a\n# baseline to compare their results to expected results.\n# Read more here: https:\/\/pytorch.org\/docs\/stable\/notes\/randomness.html\n\n# Call `set_seed` function in the exercises to ensure reproducibility.\nimport random\nimport torch\n\ndef set_seed(seed=None, seed_torch=True):\n  if seed is None:\n    seed = np.random.choice(2 ** 32)\n  random.seed(seed)\n  np.random.seed(seed)\n  if seed_torch:\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.benchmark = False\n    torch.backends.cudnn.deterministic = True\n\n  print(f'Random seed {seed} has been set.')\n\n\n# In case that `DataLoader` is used\ndef seed_worker(worker_id):\n  worker_seed = torch.initial_seed() % 2**32\n  np.random.seed(worker_seed)\n  random.seed(worker_seed)","da0fa096":"# @title Set device (GPU or CPU). Execute `set_device()`\n# especially if torch modules used.\n\n# inform the user if the notebook uses GPU or CPU.\n\ndef set_device():\n  device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n  if device != \"cuda\":\n    print(\"WARNING: For this notebook to perform best, \"\n        \"if possible, in the menu under `Runtime` -> \"\n        \"`Change runtime type.`  select `GPU` \")\n  else:\n    print(\"GPU is enabled in this notebook.\")\n\n  return device","f224036c":"SEED = 2021\nset_seed(seed=SEED)\nDEVICE = set_device()","0b762ac3":"# Network Class - Animal Faces\nclass AnimalNet(nn.Module):\n  def __init__(self):\n    super(AnimalNet, self).__init__()\n    self.fc1 = nn.Linear(3 * 32 * 32, 128)\n    self.fc2 = nn.Linear(128, 32)\n    self.fc3 = nn.Linear(32, 3)\n\n  def forward(self, x):\n    x = x.view(x.shape[0],-1)\n    x = F.relu(self.fc1(x))\n    x = F.relu(self.fc2(x))\n    x = self.fc3(x)\n    output = F.log_softmax(x, dim=1)\n    return output","1bc24702":"def train(args, model, train_loader, optimizer,\n          reg_function1=None, reg_function2=None, criterion=F.nll_loss):\n  \"\"\"\n  Trains the current inpur model using the data\n  from Train_loader and Updates parameters for a single pass\n  \"\"\"\n  device = args['device']\n  model.train()\n  for batch_idx, (data, target) in enumerate(train_loader):\n    data, target = data.to(device), target.to(device)\n    optimizer.zero_grad()\n    output = model(data)\n    if reg_function1 is None:\n      loss = criterion(output, target)\n    elif reg_function2 is None:\n      loss = criterion(output, target)+args['lambda']*reg_function1(model)\n    else:\n      loss = criterion(output, target) + args['lambda1']*reg_function1(model) + args['lambda2']*reg_function2(model)\n    loss.backward()\n    optimizer.step()\n\n  return model\n\n\ndef test(model, test_loader, criterion=F.nll_loss, device='cpu'):\n  \"\"\"\n  Tests the current Model\n  \"\"\"\n  model.eval()\n  test_loss = 0\n  correct = 0\n  with torch.no_grad():\n    for data, target in test_loader:\n      data, target = data.to(device), target.to(device)\n      output = model(data)\n      test_loss += criterion(output, target, reduction='sum').item()  # sum up batch loss\n      pred = output.argmax(dim=1, keepdim=True)  # get the index of the max log-probability\n      correct += pred.eq(target.view_as(pred)).sum().item()\n\n  test_loss \/= len(test_loader.dataset)\n  return 100. * correct \/ len(test_loader.dataset)\n\n\ndef main(args, model, train_loader, val_loader,\n         reg_function1=None, reg_function2=None):\n  \"\"\"\n  Trains the model with train_loader and tests the learned model using val_loader\n  \"\"\"\n\n  device = args['device']\n\n  model = model.to(device)\n  optimizer = optim.SGD(model.parameters(), lr=args['lr'],\n                        momentum=args['momentum'])\n\n  val_acc_list, train_acc_list,param_norm_list = [], [], []\n  for epoch in tqdm(range(args['epochs'])):\n    trained_model = train(args, model, train_loader, optimizer,\n                          reg_function1=reg_function1,\n                          reg_function2=reg_function2)\n    train_acc = test(trained_model, train_loader, device=device)\n    val_acc = test(trained_model, val_loader, device=device)\n    param_norm = calculate_frobenius_norm(trained_model)\n    train_acc_list.append(train_acc)\n    val_acc_list.append(val_acc)\n    param_norm_list.append(param_norm)\n\n  return val_acc_list, train_acc_list, param_norm_list, trained_model","fcb167f4":"# @title Video 1: Introduction to Regularization\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n      def __init__(self, id, page=1, width=400, height=300, **kwargs):\n          self.id=id\n          src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n          super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1mo4y1X76E\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"jhQAnIHTR6A\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n#add event to airtable\natform.add_event('Video 1: Introduction to Regularization')\n\ndisplay(out)","a801c7fe":"# @title Video 2: Regularization as Shrinkage\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n      def __init__(self, id, page=1, width=400, height=300, **kwargs):\n          self.id=id\n          src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n          super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1YL411H7Dv\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"mhVbJ74upnQ\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n#add event to airtable\natform.add_event('Video 2: Regularization as Shrinkage')\n\ndisplay(out)","f8a7d920":"def calculate_frobenius_norm(model):\n  ####################################################################\n  # Fill in all missing code below (...),\n  # then remove or comment the line below to test your function\n  # raise NotImplementedError(\"Define `calculate_frobenius_norm` function\")\n  ####################################################################\n  norm = 0.0\n  # Sum the square of all parameters\n  for param in model.parameters():\n    norm += torch.sum(param**2)\n\n  # Take a square root of the sum of squares of all the parameters\n  norm = torch.sqrt(torch.sum(norm))\n  return norm\n\n\n# add event to airtable\natform.add_event('Coding Exercise 1: Frobenius Norm')\n\n# Seed added for reproducibility\nset_seed(seed=SEED)\n\n## uncomment below to test your code\nnet = nn.Linear(10, 1)\nprint(f'Frobenius Norm of Single Linear Layer: {calculate_frobenius_norm(net)}')","4300bd95":"# Frobenius Norm per Layer\ndef calculate_frobenius_norm(model):\n\n  # initialization of variables\n  norm, ws, labels = 0.0, [], []\n\n  # Sum all the parameters\n  for name, parameters in model.named_parameters():\n    p = torch.sum(parameters**2)\n    norm += p\n\n    ws.append((p**0.5).cpu().detach().numpy())\n    labels.append(name)\n\n  # Take a square root of the sum of squares of all the parameters\n  norm = (norm**0.5).cpu().detach().numpy()\n\n  return norm, ws, labels\n\n\nset_seed(SEED)\nnet = nn.Linear(10,1)\nnorm, ws, labels = calculate_frobenius_norm(net)\nprint(f'Frobenius Norm of Single Linear Layer: {norm:.4f}')\n# Plots the weights\nplot_weights(norm, labels, ws)","6717da15":"set_seed(seed=SEED)\n\n# Creates a new model\nmodel = AnimalNet()\n\n# Calculates the forbenius norm per layer\nnorm, ws, labels = calculate_frobenius_norm(model)\nprint(f'Frobenius Norm of Models weights: {norm:.4f}')\n\n# Plots the weights\nplot_weights(norm, labels, ws)","ee20a3a9":"# @title Video 3: Overparameterization and Overfitting\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n      def __init__(self, id, page=1, width=400, height=300, **kwargs):\n          self.id=id\n          src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n          super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1NX4y1A73i\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"-HJ_9HxY38g\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 3: Overparameterization and Overfitting')\n\ndisplay(out)","dd74cce3":"set_seed(seed=SEED)\n\n# creating train data\n# input\nX = torch.rand((10, 1))\n# output\nY = 2*X + 2*torch.empty((X.shape[0], 1)).normal_(mean=0, std=1)  # adding small error in the data\n\n#visualizing trian data\nplt.figure(figsize=(8, 6))\nplt.scatter(X.numpy(),Y.numpy())\nplt.xlabel('input (x)')\nplt.ylabel('output(y)')\nplt.title('toy dataset')\nplt.show()\n\n#creating test dataset\nX_test = torch.linspace(0, 1, 40)\nX_test = X_test.reshape((40, 1, 1))","518e23b0":"# Network Class - 2D\nclass Net(nn.Module):\n  def __init__(self):\n    super(Net, self).__init__()\n\n    self.fc1 = nn.Linear(1, 300)\n    self.fc2 = nn.Linear(300, 500)\n    self.fc3 = nn.Linear(500, 1)\n\n  def forward(self, x):\n    x = F.leaky_relu(self.fc1(x))\n    x = F.leaky_relu(self.fc2(x))\n    output = self.fc3(x)\n    return output","b3e38311":"set_seed(seed=SEED)\n\n# train the network on toy dataset\nmodel = Net()\n\ncriterion = nn.MSELoss()\noptimizer = optim.Adam(model.parameters(), lr=1e-4)\n\niters = 0\n# Calculates frobenius before training\nnormi, wsi, label = calculate_frobenius_norm(model)","db0dd19a":"set_seed(seed=SEED)\n# initializing variables\n\n# losses\ntrain_loss = []\ntest_loss = []\n# model norm\nmodel_norm = []\n# Initializing variables to store weights\nnorm_per_layer = []\n\nmax_epochs = 10000\n\nrunning_predictions = np.empty((40, int(max_epochs \/ 500 + 1)))\n\nfor epoch in tqdm(range(max_epochs)):\n  # frobenius norm per epoch\n  norm, pl, layer_names = calculate_frobenius_norm(model)\n\n  # training\n  model_norm.append(norm)\n  norm_per_layer.append(pl)\n  model.train()\n  optimizer.zero_grad()\n  predictions = model(X)\n  loss = criterion(predictions, Y)\n  loss.backward()\n  optimizer.step()\n\n  train_loss.append(loss.data)\n  model.eval()\n  Y_test = model(X_test)\n  loss = criterion(Y_test, 2*X_test)\n  test_loss.append(loss.data)\n\n  if (epoch % 500 == 0 or epoch == max_epochs - 1):\n    running_predictions[:, iters] = Y_test[:, 0, 0].detach().numpy()\n    iters += 1","2cfefe7a":"# @title Animation (Run Me!)\n\nset_seed(seed=SEED)\n# create a figure and axes\nfig = plt.figure(figsize=(14, 5))\nax1 = plt.subplot(121)\nax2 = plt.subplot(122)\n# organizing subplots\nplot1, = ax1.plot([],[])\nplot2 = ax2.bar([], [])\n\n\ndef frame(i):\n  ax1.clear()\n  title1 = ax1.set_title('')\n  ax1.set_xlabel(\"Input(x)\")\n  ax1.set_ylabel(\"Output(y)\")\n\n  ax2.clear()\n  ax2.set_xlabel('Layer names')\n  ax2.set_ylabel('Frobenius norm')\n  title2 = ax2.set_title('Weight Measurement: Forbenius Norm')\n\n  ax1.scatter(X.numpy(),Y.numpy())\n  plot1 = ax1.plot(X_test[:,0,:].detach().numpy(), running_predictions[:,i])\n  title1.set_text(f'Epochs: {i * 500}')\n  plot2 = ax2.bar(label, norm_per_layer[i*500])\n  plt.axhline(y=model_norm[i*500], linewidth=1,\n              color='r', ls='--',\n              label=f'Norm: {model_norm[i*500]:.2f}')\n  plt.legend()\n\n  return plot1, plot2\n\n\nanim = animation.FuncAnimation(fig, frame, frames=range(20),\n                               blit=False, repeat=False,\n                               repeat_delay=10000)\nhtml_anim = HTML(anim.to_html5_video())\nplt.close()\n\nimport IPython\nIPython.display.display(html_anim)","3a029269":"# @title Plot the train and test losses\nplt.figure(figsize=(8, 6))\nplt.plot(train_loss,label='train_loss')\nplt.plot(test_loss,label='test_loss')\nplt.ylabel('loss')\nplt.xlabel('epochs')\nplt.title('loss vs epoch')\nplt.legend()\nplt.show()","80605d28":"# @title Student Response\nfrom ipywidgets import widgets\n\n\ntext=widgets.Textarea(\n   value='Type your answer here and click on `Submit!`',\n   placeholder='Type something',\n   description='',\n   disabled=False\n)\n\nbutton = widgets.Button(description=\"Submit!\")\n\ndisplay(text,button)\n\ndef on_button_clicked(b):\n   atform.add_answer('q1', text.value)\n   print(\"Submission successful!\")\n\n\nbutton.on_click(on_button_clicked)","02415d3b":"# @markdown Frobenious norm of the model\nplt.figure(figsize=(8, 6))\nplt.plot(model_norm)\nplt.ylabel('norm of the model')\nplt.xlabel('epochs')\nplt.title('Size of the model vs Epochs')  # Change title to Frobenious norm of the model\nplt.show()","9e8da34c":"# @markdown Frobenius norm per layer before and after training\nnormf, wsf, label = calculate_frobenius_norm(model)\n\nplot_weights(float(normi), label, wsi,\n             title='Weight Size Before Training')\nplot_weights(float(normf), label, wsf,\n             title='Weight Size After Training')","634dde1f":"# Dataloaders for the Dataset\nbatch_size = 128\nclasses = ('cat', 'dog', 'wild')\n\n# defining number of examples for train, val test\nlen_train, len_val, len_test = 100, 100, 14430\n\ntrain_transform = transforms.Compose([\n     transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n     ])\ndata_path = pathlib.Path('.')\/'afhq'  # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=train_transform)","289ef3b6":"# Dataloaders for the Original Dataset\n\n# For reproducibility\ng_seed = torch.Generator()\ng_seed.manual_seed(SEED)\n\nimg_train_data, img_val_data,_ = torch.utils.data.random_split(img_dataset,\n                                                               [len_train,\n                                                                len_val,\n                                                                len_test])\n\n# Creating train_loader and Val_loader\ntrain_loader = torch.utils.data.DataLoader(img_train_data,\n                                           batch_size=batch_size,\n                                           num_workers=2,\n                                           worker_init_fn=seed_worker,\n                                           generator=g_seed)\n\nval_loader = torch.utils.data.DataLoader(img_val_data,\n                                         batch_size=1000,\n                                         num_workers=2,\n                                         worker_init_fn=seed_worker,\n                                         generator=g_seed)","3fd4a28d":"# Dataloaders for the Random Dataset\n\n# For reproducibility\ng_seed = torch.Generator()\ng_seed.manual_seed(SEED + 1)\n\n# splitting randomized data into training and validation data\ndata_path = pathlib.Path('.')\/'afhq_random_32x32\/afhq_random' # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=train_transform)\nrandom_img_train_data, random_img_val_data,_ = torch.utils.data.random_split(img_dataset, [len_train, len_val, len_test])\n\n# Randomized train and validation dataloader\nrand_train_loader = torch.utils.data.DataLoader(random_img_train_data,\n                                                batch_size=batch_size,\n                                                num_workers=2,\n                                                worker_init_fn=seed_worker,\n                                                generator=g_seed)\n\nrand_val_loader = torch.utils.data.DataLoader(random_img_val_data,\n                                              batch_size=1000,\n                                              num_workers=2,\n                                              worker_init_fn=seed_worker,\n                                              generator=g_seed)","26386a33":"# Dataloaders for the Partially Random Dataset\n\n# For reproducibility\ng_seed = torch.Generator()\ng_seed.manual_seed(SEED + 1)\n\n# Splitting data between training and validation dataset for partially randomized data\ndata_path = pathlib.Path('.')\/'afhq_10_32x32\/afhq_10' # using pathlib to be compatible with all OS's\nimg_dataset = ImageFolder(data_path\/'train', transform=train_transform)\npartially_random_train_data, partially_random_val_data,_ = torch.utils.data.random_split(img_dataset, [len_train, len_val, len_test])\n\n# Training and Validation loader for partially randomized data\npartial_rand_train_loader = torch.utils.data.DataLoader(partially_random_train_data,\n                                                        batch_size=batch_size,\n                                                        num_workers=2,\n                                                        worker_init_fn=seed_worker,\n                                                        generator=g_seed)\n\npartial_rand_val_loader = torch.utils.data.DataLoader(partially_random_val_data,\n                                                      batch_size=1000,\n                                                      num_workers=2,\n                                                      worker_init_fn=seed_worker,\n                                                      generator=g_seed)","9eb4ce6e":"# Network Class - Animal Faces\nclass BigAnimalNet(nn.Module):\n  def __init__(self):\n    super(BigAnimalNet, self).__init__()\n    self.fc1 = nn.Linear(3*32*32, 124)\n    self.fc2 = nn.Linear(124, 64)\n    self.fc3 = nn.Linear(64, 3)\n\n  def forward(self, x):\n    x = x.view(x.shape[0], -1)\n    x = F.leaky_relu(self.fc1(x))\n    x = F.leaky_relu(self.fc2(x))\n    x = self.fc3(x)\n    output = F.log_softmax(x, dim=1)\n    return output","b78f7915":"set_seed(seed=SEED)\nnormi, wsi, label = calculate_frobenius_norm(BigAnimalNet())","e250e34f":"# Here we have 100 true train data.\n\n# Set the arguments\nargs = {\n    'epochs': 200,\n    'lr': 5e-3,\n    'momentum': 0.9,\n    'device': DEVICE\n}\n\n\n# Initialize the network\nset_seed(seed=SEED)\nmodel = BigAnimalNet()\n\nstart_time = time.time()\n# Train the network\nval_acc_pure, train_acc_pure, _, model = main(args=args,\n                                              model=model,\n                                              train_loader=train_loader,\n                                              val_loader=val_loader)\nend_time = time.time()\n\nprint(f\"Time to memorize the dataset: {end_time - start_time}\")\n\n# Train and Test accuracy plot\nplt.figure(figsize=(8, 6))\nplt.plot(val_acc_pure, label='Val Accuracy Pure', c='red', ls='dashed')\nplt.plot(train_acc_pure, label='Train Accuracy Pure', c='red', ls='solid')\nplt.axhline(y=max(val_acc_pure), c='green', ls='dashed',\n            label='max Val accuracy pure')\nplt.title('Memorization')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\nplt.legend()\nplt.show()","be737884":"# @markdown #### Frobenius norm for AnimalNet before and after training\nnormf, wsf, label = calculate_frobenius_norm(model)\n\nplot_weights(float(normi), label, wsi, title='Weight Size Before Training')\nplot_weights(float(normf), label, wsf, title='Weight Size After Training')","bc19b9c8":"def visualize_data(dataloader):\n\n  for idx, (data, label) in enumerate(dataloader):\n    plt.figure(idx)\n    # Choose the datapoint you would like to visualize\n    index = 22\n\n    # choose that datapoint using index and permute the dimensions\n    # and bring the pixel values between [0, 1]\n    data = data[index].permute(1, 2, 0) * \\\n           torch.tensor([0.5, 0.5, 0.5]) + \\\n           torch.tensor([0.5, 0.5, 0.5])\n\n    # Convert the torch tensor into numpy\n    data = data.numpy()\n\n    plt.imshow(data)\n    plt.axis(False)\n    image_class = classes[label[index].item()]\n    print(f'The image belongs to : {image_class}')\n\n  plt.show()\n\n\n# Call the function\nvisualize_data(rand_train_loader)","0f57dac1":"# Here we have 100 completely shuffled train data.\n\n# Set the arguments\nargs = {\n    'epochs': 200,\n    'lr': 5e-3,\n    'momentum': 0.9,\n    'device': DEVICE\n}\n\n# Intialize the model\nset_seed(seed=SEED)\nmodel = BigAnimalNet()\n\n# Train the model\nval_acc_random, train_acc_random, _, model = main(args,\n                                                  model,\n                                                  rand_train_loader,\n                                                  val_loader)\n\n# Train and Test accuracy plot\nplt.figure(figsize=(8, 6))\nplt.plot(val_acc_pure,label='Val - Pure',c='red',ls = 'dashed')\nplt.plot(train_acc_pure,label='Train - Pure',c='red',ls = 'solid')\nplt.plot(val_acc_random,label='Val - Random',c='blue',ls = 'dashed')\nplt.plot(train_acc_random,label='Train - Random',c='blue',ls = 'solid')\n\nplt.title('Memorization')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\nplt.legend()\nplt.show()","6d81c522":"# @title Video 4: Early Stopping\nfrom ipywidgets import widgets\n\nout2 = widgets.Output()\nwith out2:\n  from IPython.display import IFrame\n  class BiliVideo(IFrame):\n      def __init__(self, id, page=1, width=400, height=300, **kwargs):\n          self.id=id\n          src = \"https:\/\/player.bilibili.com\/player.html?bvid={0}&page={1}\".format(id, page)\n          super(BiliVideo, self).__init__(src, width, height, **kwargs)\n\n  video = BiliVideo(id=f\"BV1cB4y1K777\", width=730, height=410, fs=1)\n  print(\"Video available at https:\/\/www.bilibili.com\/video\/{0}\".format(video.id))\n  display(video)\n\nout1 = widgets.Output()\nwith out1:\n  from IPython.display import YouTubeVideo\n  video = YouTubeVideo(id=f\"72IG2bX5l30\", width=730, height=410, fs=1, rel=0)\n  print(\"Video available at https:\/\/youtube.com\/watch?v=\" + video.id)\n  display(video)\n\nout = widgets.Tab([out1, out2])\nout.set_title(0, 'Youtube')\nout.set_title(1, 'Bilibili')\n\n# add event to airtable\natform.add_event('Video 4: Early Stopping')\n\ndisplay(out)","dd34a84c":"def early_stopping_main(args, model, train_loader, val_loader):\n\n  ####################################################################\n  # Fill in all missing code below (...),\n  # then remove or comment the line below to test your function\n  # raise NotImplementedError(\"Complete the early_stopping_main function\")\n  ####################################################################\n  device = args['device']\n  model = model.to(device)\n  optimizer = optim.SGD(model.parameters(),\n                        lr=args['lr'],\n                        momentum=args['momentum'])\n\n  best_acc = 0.0\n  best_epoch = 0\n\n  # Number of successive epochs that you want to wait before stopping training process\n  patience = 20 # in number of epcos\n\n  # Keps track of number of epochs during which the val_acc was less than best_acc\n  wait = 0\n\n  val_acc_list, train_acc_list = [], []\n  for epoch in tqdm(range(args['epochs'])):\n\n    # train the model\n    trained_model = train(args, model, train_loader, optimizer)\n\n    # calculate training accuracy\n    train_acc = test(trained_model, train_loader, device = device)\n\n    # calculate validation accuracy\n    val_acc = test(trained_model, val_loader, device = device)\n\n    if (val_acc > best_acc):\n      best_acc = val_acc\n      best_epoch = epoch\n      best_model = copy.deepcopy(trained_model)\n      wait = 0\n    else:\n      wait += 1\n\n    if (wait > patience):\n      print(f'early stopped on epoch: {epoch}')\n      break\n\n    train_acc_list.append(train_acc)\n    val_acc_list.append(val_acc)\n\n  return val_acc_list, train_acc_list, best_model, best_epoch\n\n\n# add event to airtable\natform.add_event('Coding Exercise 4: Early Stopping')\n\n# Set the arguments\nargs = {\n    'epochs': 200,\n    'lr': 5e-4,\n    'momentum': 0.99,\n    'device': DEVICE\n}\n\n# Initialize the model\nset_seed(seed=SEED)\nmodel = AnimalNet()\n\n## Uncomment to test\nval_acc_earlystop, train_acc_earlystop, best_model, best_epoch = early_stopping_main(args, model, train_loader, val_loader)\nprint(f'Maximum Validation Accuracy is reached at epoch: {best_epoch:2d}')\nearly_stop_plot(train_acc_earlystop, val_acc_earlystop, best_epoch)","ddb6209c":"# @title Student Response\nfrom ipywidgets import widgets\n\n\ntext=widgets.Textarea(\n   value='Type your answer here and click on `Submit!`',\n   placeholder='Type something',\n   description='',\n   disabled=False\n)\n\nbutton = widgets.Button(description=\"Submit!\")\n\ndisplay(text,button)\n\ndef on_button_clicked(b):\n   atform.add_answer('q3', text.value)\n   print(\"Submission successful!\")\n\n\nbutton.on_click(on_button_clicked)","f8990ee2":"# @title Airtable Submission Link\nfrom IPython import display as IPydisplay\nIPydisplay.HTML(\n   f\"\"\"\n <div>\n   <a href= \"{atform.url()}\" target=\"_blank\">\n   <img src=\"https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/blob\/main\/tutorials\/static\/AirtableSubmissionButton.png?raw=1\"\n alt=\"button link to Airtable\" style=\"width:410px\"><\/a>\n   <\/div>\"\"\" )","f968f434":"# Here we have 15% partially shuffled train data.\n\n# Set the arguments\nargs = {\n    'epochs': 200,\n    'lr': 5e-3,\n    'momentum': 0.9,\n    'device': DEVICE\n}\n\n# Intialize the model\nset_seed(seed=SEED)\nmodel = BigAnimalNet()\n\n# Train the model\nval_acc_shuffle, train_acc_shuffle, _, _, = main(args,\n                                                 model,\n                                                 partial_rand_train_loader,\n                                                 val_loader)\n\n# train and test acc plot\nplt.figure(figsize=(8, 6))\nplt.plot(val_acc_shuffle, label='Val Accuracy shuffle', c='red', ls='dashed')\nplt.plot(train_acc_shuffle, label='Train Accuracy shuffle', c='red', ls='solid')\nplt.axhline(y=max(val_acc_shuffle), c='green', ls='dashed',\n            label='Max Val Accuracy shuffle')\nplt.title('Memorization')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\nplt.legend()\nplt.show()","ae9510db":"#@markdown #### Plotting them all together (Run Me!)\nplt.figure(figsize=(8, 6))\nplt.plot(val_acc_pure,label='Val - Pure',c='red',ls = 'dashed')\nplt.plot(train_acc_pure,label='Train - Pure',c='red',ls = 'solid')\nplt.plot(val_acc_random,label='Val - Random',c='blue',ls = 'dashed')\nplt.plot(train_acc_random,label='Train - Random',c='blue',ls = 'solid')\nplt.plot(val_acc_shuffle, label='Val - shuffle', c='y', ls='dashed')\nplt.plot(train_acc_shuffle, label='Train - shuffle', c='y', ls='solid')\n\nplt.title('Memorization')\nplt.ylabel('Accuracy (%)')\nplt.xlabel('Epoch')\nplt.legend()\nplt.show()","36b58d3a":"One way to think about Regularization is to think in terms of the magnitude of the overall weights of the model. A model with big weights can fit more data perfectly, whereas a model with smaller weights tends to underperform on the train set but can surprisingly do very well on the test set. Having the weights too small can also be an issue as it can then underfit the model.\n\nThis week we use the sum of Frobenius Norm of all the tensors in the model as a measure of the \"size of the model\".","20af0427":" #### Frobenius norm for AnimalNet before and after training\n","18f7ea73":"## Data Visualizer\n\nBefore we train the model on a data with random labels, let's visualize and verify for ourselves that the data is random. Here, we have classes = (\"cat\", \"dog\", \"wild\"). \n\nWe use `.permute()` method. `plt.imshow()` expects imput to be in numpy format and in the format $(P_x, P_y, 3)$, where $P_x$ and $P_y$ are the number of pixels along axis $x$ and $y$ respectively.","db5e83d1":"\nAlso it is interesting to note that sometimes the model trained on slightly shuffled data does slightly better than the one trained on pure data.  Shuffling some of the data is a form of regularization--one of many ways of adding noise to the training data.","8585de65":"First, let's create the required dataloaders for all three datasets. Notice how we split the data. We train on a fraction of the dataset as it will be faster to train and will overfit more clearly.","169c7090":"At this point, we can now train our model.","7e550e0b":"Next, let's define the different parameters for training our model:\n","d28bb173":"---\n# Section 3: Memorization\n\n*Time estimate: ~20 mins*\n","0a3838a1":"Using the last function `calculate_frobenius_norm`, we can also obtain the Frobenius Norm per layer for a whole NN model and use the `plot_weigts` function to visualize them.","5b1d3386":"**Our 2021 Sponsors, including Presenting Sponsor Facebook Reality Labs**\n\n<p align='center'><img src='https:\/\/github.com\/NeuromatchAcademy\/widgets\/blob\/master\/sponsors.png?raw=True'\/><\/p>","90699f35":" **Hint:** Use functions `model.parameters()` or `model.named_parameters()`\n","55fa9ab1":"Before training our `BigAnimalNet()`, calculate the Frobenius norm again.","13492f49":" Now let's train the network on the shuffled data and see if it memorizes.","dd807a34":" Frobenius norm per layer before and after training\n","a453aaae":"###  Animation (Run Me!)\n","8625dc92":"<a href=\"https:\/\/colab.research.google.com\/github\/NeuromatchAcademy\/course-content-dl\/blob\/main\/tutorials\/W1D5_Regularization\/student\/W1D5_Tutorial1.ipynb\" target=\"_blank\"><img alt=\"Open In Colab\" src=\"https:\/\/colab.research.google.com\/assets\/colab-badge.svg\"\/><\/a>","0c67da49":"Now, think for a couple of minutes as to what the train and test accuracies of each of these models might be, given that you train for sufficient time and use a powerful network.","446cd44f":"Now let's visualize the Frobenious norm of the model as we trained. You should see that the value of weights increases over the epochs.","eca0f70f":"##  Airtable Submission Link\n","7503633e":"## Coding Exercise 4: Early Stopping\nReimplement the main function to include early stopping as described above. Then run the code below to validate your implementation.","c95351b6":"## Section 2.2: Overfitting on Test Dataset\n\n\nIn principle we should not touch our test set until after we have chosen all our hyperparameters. Were we to use the test data in the model selection process, there is a risk that we might overfit the test data. Then we would be in serious trouble. If we overfit our training data, there is always the evaluation on test data to keep us honest. But if we overfit the test data, how would we ever know?\n\nNote that there is another kind of overfitting: you do \"honest\" fitting on one set of images or posts, or medical records, but it may not generalize to other sets of images, posts or medical records.\n","e4157276":"##  Set device (GPU or CPU). Execute `set_device()`\n","e931c572":"Let's create some synthetic dataset that we will use to illustrate overfitting in neural networks.","580ecba5":"####  Student Response\n","3b252854":"---\n# Section 4: Early Stopping\n\n*Time estimate: ~20 mins*","2bbc3a85":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D5_Regularization\/solutions\/W1D5_Tutorial1_Solution_683d27d3.py)\n\n","893ab3ba":"#### Validation Dataset\nA common practice to address this problem is to split our data in three ways, using a validation dataset (or validation set) to tune the hyperparameters. Ideally, we would only touch the test data once, to assess the very best model or to compare a small number of models to each other, real-world test data is seldom discarded after just one use.\n\n","a25ac857":"##  Set random seed\n","c3ee9696":"# Tutorial 1: Regularization techniques part 1\n\n**Week 1, Day 5: Regularization**\n\n**By Neuromatch Academy**\n\n__Content creators:__ Ravi Teja Konkimalla, Mohitrajhu Lingan Kumaraian, Kevin Machado Gamboa, Kelson Shilling-Scrivo, Lyle Ungar\n\n__Content reviewers:__ Piyush Chauhan, Siwei Bai, Kelson Shilling-Scrivo\n\n__Content editors:__ Roberto Guidotti, Spiros Chavlis\n\n__Production editors:__ Saeed Salehi, Spiros Chavlis","2036d1e9":"###  Plot the train and test losses\n","cf83224d":"##  Video 3: Overparameterization and Overfitting\n","716fceb3":"##  Figure Settings\n","ac5e72f0":"A key idea of neural nets, is that they use models that are \"too complex\" - complex enough to fit all the noise in the data. One then needs to \"regularize\" them to make the models fit complex enough, but not too complex. The more complex the model, the better it fits the training data, but if it is too complex, it generalizes less well; it memorizes the training data but is less accurate on future test data.","b5b54153":"##  Video 1: Introduction to Regularization\n","dfa3ae3a":"---\n# Bonus: Train with randomized labels","2b0058d2":"## Think! Bonus: Does it Generalize?\nGiven that the Neural Network fit\/memorize the training data perfectly:\n\n*   Do you think it generalizes well?\n*   What makes you think it does or doesn't?\n","6e5fe048":"In this part, let's train on a partially shuffled dataset where 15% of the labels are noisy.","5345966e":"## Coding Exercise 1: Frobenius Norm\nBefore we start, let's define the Frobenius norm, sometimes also called the Euclidean norm of an $m\u00d7n$ matrix $A$  as the square root of the sum of the absolute squares of its elements.\n\n<br>\n\n\\begin{equation}\n||A||_F= \\sqrt{\\sum_{i=1}^m\\sum_{j=1}^n|a_{ij}|^2}\n\\end{equation} \n\nThis is just a measure of how big the matrix is, analogous to how big a vector is.","3f0c34e2":"---\n# Summary\n\nIn this tutorial, you have been introduced to the regularization technique, where we have described it as shrinkage. We have learned about overfitting, one of the worst caveats in deep learning, and finally we learned a method of reducing overfitting in our models called early-stopping.\n\nIf you have time left, you can learn how a model behaves when is trained with randomized labels.","30792615":" Frobenious norm of the model\n","6b9a5844":"## Think! 4: Early Stopping\n\nDiscuss among your pod why or why not:\n\n*   Do you think early stopping can be harmful for training your network?","59b8fe98":"###  Student Response\n","85ed42c7":"##  Loading Animal Faces data\n","9441e54d":"Finally, you can compare the Frobenius norm per layer in the model, before and after training.","518c924c":"##  Loading Animal Faces Randomized data\n","dfbd76b2":"##  Video 4: Early Stopping\n","26c52082":"\nNow that we have established that the validation accuracy reaches the peak well before the model overfits, we want to somehow stop the training early. You should have also observed from the above plots that the train\/test loss on real data is not very smooth and hence you might guess that the choice of epoch can play a very large role on the val\/test accuracy of your model. \n\nEarly stopping stops training when the validation accuracies stop increasing. \n\n<center><img src=\"https:\/\/raw.githubusercontent.com\/NeuromatchAcademy\/course-content-dl\/main\/tutorials\/static\/early-stopping-machine-learning-5422207.jpg\" alt=\"Overfitting\" width=\"600\"\/><\/center>","6cb8d3a9":" Executing `set_seed(seed=seed)` you are setting the seed\n","06111ffe":"Now, train our `BigAnimalNet()` model","ecb35afe":"---\n# Section 2: Overfitting\n\n*Time estimate: ~15 mins*\n","56dbac79":"```\nRandom seed 2021 has been set.\nFrobenius Norm of Single Linear Layer: 0.6572162508964539\n```","7d62993f":"---\n# Setup\nNote that some of the code for today can take up to an hour to run. We have therefore \"hidden\" the code and shown the resulting outputs.\n","78f43945":"### Think! 2.1: Interpreting losses\n\nRegarding the train and test graph above, discuss among yourselves:\n\n*   What trend do you see w.r.t to train and test losses ( Where do you see the minimum of these losses?)\n*   What does it tell us about the model we trained?\n\n  \n","4ecf7c53":"Let's create an overparametrized Neural Network that can fit on the dataset that we just created and train it. \n\nFirst, let's build the model architecture:","52685290":"Now that we have finished training, let's see how the model has evolved over the training process.","17587914":"##  Video 2: Regularization as Shrinkage\n","afdfc609":"## Section 2.1: Visualizing Overfitting\n\n","b870e838":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D5_Regularization\/solutions\/W1D5_Tutorial1_Solution_c705db1a.py)\n\n","700b7468":"Given sufficiently large networks and enough training, Neural Networks can achieve almost 100% train accuracy by remembering each training example. This is bad, however, because it will mean that the model will fail when presented with new data.\n\nIn this section we train three MLPs; one each on:\n\n\n1.   Animal Faces Dataset\n2.   A Completely Noisy Dataset (Random Shuffling of all labels)\n3.   A partially Noisy Dataset (Random Shuffling of 15% labels)\n","5f0d53d8":"---\n# Tutorial Objectives\n\n1. Big ANNs are efficient universal approximators due to their adaptive basis functions\n2. ANNs memorize some but generalize well\n3. Regularization as shrinkage of overparameterized models: early stopping ","3f51c62d":" #### Plotting them all together (Run Me!)\n","2e5971fc":"Apart from calculating the weight size for an entire model, we could also determine the weight size in every layer. For this, we can modify our `calculate_frobenius_norm` function as shown below. \n\n**Have a look how it works!!**","27e06113":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D5_Regularization\/solutions\/W1D5_Tutorial1_Solution_8f1d49a8.py)\n\n","f2673a9f":"Isn't it surprising to see that the NN was able to achieve 100% training accuracy on randomly shuffled labels? This is one of the reasons why training accuracy is not a good indicator of model performance.","912e2080":"Now let's define a model which has many parameters compared to the training dataset size, and train it on these datasets.","3e7c982d":"The train function takes in the current model, along with the train_loader and loss function, and updates the parameters for a single pass of the entire dataset. The test function takes in the current model after every epoch and calculates the accuracy on the test dataset.\n","1e2affd4":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D5_Regularization\/solutions\/W1D5_Tutorial1_Solution_62d845ba.py)\n\n*Example output:*\n\n<img alt='Solution hint' align='left' width=1120.0 height=832.0 src=https:\/\/raw.githubusercontent.com\/NeuromatchAcademy\/course-content-dl\/main\/tutorials\/W1D5_Regularization\/static\/W1D5_Tutorial1_Solution_62d845ba_3.png>\n\n","e1e62acd":"---\n# Section 0: Defining useful functions\nLet's start the tutorial by defining some functions which we will use frequently today, such as: `AnimalNet`, `train`, `test` and `main`.","5e686089":"---\n# Section 1: Regularization is Shrinkage\n\n*Time estimate: ~20 mins*","0c646106":"##  Plotting functions\n","5b854da5":"[*Click for solution*](https:\/\/github.com\/NeuromatchAcademy\/course-content-dl\/tree\/main\/\/tutorials\/W1D5_Regularization\/solutions\/W1D5_Tutorial1_Solution_1f125e8e.py)\n\n","55b11ec8":"##  Install dependencies\n"}}