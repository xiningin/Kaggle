{"cell_type":{"9b27a986":"code","afbe1ace":"code","77b47068":"code","c3e3c6dd":"code","53f6cc58":"code","a65d70bf":"code","9c3d543a":"code","8a2a7623":"code","fe81639a":"code","0b119319":"code","f94a0b30":"code","b7b88d51":"markdown","53b10a69":"markdown","090dcaf1":"markdown","6e7d759b":"markdown","309f4bb2":"markdown","216ec5f2":"markdown","5c25363c":"markdown","46bf4248":"markdown","be101a26":"markdown","3a3258de":"markdown","e8065066":"markdown","1481852a":"markdown","68633b37":"markdown","fe60e00c":"markdown","e8c0d9cb":"markdown"},"source":{"9b27a986":"!pip install -Uqq fastbook\nimport fastbook\nfastbook.setup_book()","afbe1ace":"#Import fastai vision modules\nfrom fastai.vision.all import *","77b47068":"import wandb\nwandb.login()\nfrom fastai.callback.wandb import WandbCallback","c3e3c6dd":"#Dataset path\npath = untar_data(URLs.PETS)","53f6cc58":"#Function for Labels\n#All cat image filename start with uppercase letter\n\ndef is_cat(x): return x[0].isupper()","a65d70bf":"dls = ImageDataLoaders.from_name_func(\n    path,\n    get_image_files(path),\n    valid_pct = 0.2,\n    seed = 42,\n    label_func = is_cat,\n    item_tfms = Resize(224)\n)","9c3d543a":"# wandb config\nWANDB_CONFIG = {\n     'competition': 'animal-classifier', \n              '_wandb_kernel': 'neuracort'\n    }","8a2a7623":"#CNN\n\nwandb.init(project='FastAI-Animal-Classifier', config= WANDB_CONFIG)\n\nlearn =cnn_learner(dls,\n                   resnet34,\n                   metrics = error_rate,\n                   cbs=WandbCallback()\n                  )\n\nlearn.fine_tune(1)","fe81639a":"#Image Uploader\nimport ipywidgets as widgets\n\nuploader = widgets.FileUpload()\nuploader","0b119319":"def pred():\n  '''\n  Function to convert images to ndarray and make predictions using model.\n  '''  \n  \n  #Convert image to array\n  img = PILImage.create(uploader.data[0])\n  img.show()\n\n  #Make Prediction\n  is_cat,_,probs = learn.predict(img)\n\n  print(f\"Image is of a Cat: {is_cat}.\")\n  print(f\"Probability image is a cat: {probs[1].item():.6f}\")","f94a0b30":"pred()","b7b88d51":"`cnn_learner` is used to build a convnet style learner from `dls` and `arch`\n\nThe model is built from `arch` using the number of final activations inferred from `dls` if possible (otherwise pass a value to `n_out`). It might be `pretrained` and the architecture is cut and split using the default metadata of the model architecture (this can be customized by passing a `cut` or a `splitter`).\n\nIf `normalize` and `pretrained` are `True`, this function adds a `Normalization` transform to the `dls` (if there is not already one) using the statistics of the pretrained model. That way, you won't ever forget to normalize your data in transfer learning.\n\nAll other arguments are passed to `Learner`.","53b10a69":"## [WandB Project Page -->](https:\/\/wandb.ai\/ishandutta\/FastAI-Animal-Classifier?workspace=user-ishandutta)","090dcaf1":"## Image Uploader Widget","6e7d759b":"## About FastAI\n\nfastai is a deep learning library which provides practitioners with high-level components that can quickly and easily provide state-of-the-art results in standard deep learning domains, and provides researchers with low-level components that can be mixed and matched to build new approaches. It aims to do both things without substantial compromises in ease of use, flexibility, or performance. This is possible thanks to a carefully layered architecture, which expresses common underlying patterns of many deep learning and data processing techniques in terms of decoupled abstractions. These abstractions can be expressed concisely and clearly by leveraging the dynamism of the underlying Python language and the flexibility of the PyTorch library. fastai includes:\n\nA new type dispatch system for Python along with a semantic type hierarchy for tensors\nA GPU-optimized computer vision library which can be extended in pure Python\nAn optimizer which refactors out the common functionality of modern optimizers into two basic pieces, allowing optimization algorithms to be implemented in 45 lines of code\nA novel 2-way callback system that can access any part of the data, model, or optimizer and change it at any point during training\nA new data block API","309f4bb2":"## Determine Label","216ec5f2":"## Data Loader","5c25363c":"## Imports","46bf4248":"**PETS**: A 37 category pet dataset with roughly 200 images for each class.","be101a26":"**Weights & Biases** is the machine learning platform for developers to build better models faster. \n\nYou can use W&B's lightweight, interoperable tools to \n- quickly track experiments, \n- version and iterate on datasets, \n- evaluate model performance, \n- reproduce models, \n- visualize results and spot regressions, \n- and share findings with colleagues. \n\nSet up W&B in 5 minutes, then quickly iterate on your machine learning pipeline with the confidence that your datasets and models are tracked and versioned in a reliable system of record.\n\nIn this notebook I will use Weights and Biases's amazing features to perform wonderful visualizations and logging seamlessly. ","3a3258de":"## Weights and Biases\n<center><img src = \"https:\/\/i.imgur.com\/1sm6x8P.png\" width = \"750\" height = \"500\"\/><\/center>  ","e8065066":"## Model","1481852a":"`ImageDataLoaders` is a Basic wrapper around several `DataLoader`s with factory methods for computer vision problems\n\nThis class should not be used directly, one of the factory methods should be preferred instead. All those factory methods accept as arguments:  \n\n`item_tfms`: one or several transforms applied to the items before batching them  \n`batch_tfms`: one or several transforms applied to the batches once they are formed  \n`bs`: the batch size  \n`val_bs`: the batch size for the validation `DataLoader` (defaults to `bs`)  \n`shuffle_train`: if we shuffle the training `DataLoader` or not  \n`device`: the PyTorch device to use (defaults to `default_device()`)  ","68633b37":"## Download Data set\n\n`untar_data` is a very powerful convenience function to download files from `url` to `dest`. The url can be a default url from the URLs class or a custom url. If dest is not passed, files are downloaded at the default_dest which defaults to ~\/.fastai\/data\/.\n\nThis convenience function extracts the downloaded files to dest by default. In order, to simply download the files without extracting, pass the noop function as extract_func.\n\nNote, it is also possible to pass a custom extract_func to untar_data if the filetype doesn't end with .tgz or .zip. The gzip and zip files are supported by default and there is no need to pass custom extract_func for these type of files.\n\nInternally, if files are not available at fname location already which defaults to ~\/.fastai\/archive\/, the files get downloaded at ~\/.fastai\/archive and are then extracted at dest location. If no dest is passed the default_dest to download the files is ~\/.fastai\/data. If files are already available at the fname location but not available then a symbolic link is created for each file from fname location to dest.","fe60e00c":"The validation set is a random subset of `valid_pct`, optionally created with `seed` for reproducibility. This method does the same as `ImageDataLoaders.from_path_func` except `label_func` is applied to the name of each filenames, and not the full path.","e8c0d9cb":"### Model Predictions"}}