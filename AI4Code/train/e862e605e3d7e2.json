{"cell_type":{"c652686c":"code","784c82b4":"code","a2081399":"code","67d1e1cd":"code","75a5edcd":"code","a8ced53e":"code","4fef2516":"code","4c66cf29":"code","03f66ab6":"code","57a5a8f8":"code","582f84ab":"code","5042f162":"code","4c25daf5":"code","c61c1365":"code","f425fc15":"code","062cbb5a":"code","095f46ea":"code","c72d17cf":"code","57d1c54f":"code","5480a155":"code","55f2ca9a":"code","c8ddad93":"code","25cf0a3c":"code","2e741535":"code","332989db":"code","768daa2b":"code","e3385368":"code","92d134ac":"code","ff289ac2":"code","c80fea69":"code","b3396001":"code","359125d2":"code","866510d0":"code","b8c10bdf":"markdown","fef8a340":"markdown","118c211c":"markdown"},"source":{"c652686c":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","784c82b4":"#import the required libraries\nimport pandas as pd\n\nimport numpy as np\n\nimport matplotlib.pyplot as plt\n\nimport seaborn as sns\n\nfrom tqdm import tqdm\nfrom tqdm import tqdm_notebook\n\nfrom scipy.signal import hilbert\nfrom scipy.signal import hann\nfrom scipy.signal import convolve","a2081399":"train_data = pd.read_csv('..\/input\/train.csv', dtype = {'acoustic_data': np.int16, 'time_to_failure': np.float32})","67d1e1cd":"#let's look at the training data\nprint(train_data.head())\nprint(100*'-')\nprint(train_data.shape)","75a5edcd":"#let's prepare our data\nseg_length = 150000\ntotal_samples = int(np.floor((train_data.shape[0]) \/ seg_length))\n\nx_train = pd.DataFrame(index = range(total_samples), dtype = np.float64) #an empty dataframe holding our feature values\ny_train = pd.DataFrame(index = range(total_samples), columns = ['time_to_failure'], dtype = np.float64) #an empty dataframe holding our target labels","a8ced53e":"def calc_change_rate(x):\n    change = (np.diff(x) \/ x[:-1]).values\n    change = change[np.nonzero(change)[0]]\n    change = change[~np.isnan(change)]\n    change = change[change != -np.inf]\n    change = change[change != np.inf]\n    return np.mean(change)\n\nfor value in tqdm_notebook(range(total_samples)):\n    sample = train_data.iloc[value*seg_length : value*seg_length + seg_length]\n    x = pd.Series(sample['acoustic_data'].values)\n    y = sample['time_to_failure'].values[-1]\n    y_train.loc[value, 'time_to_failure'] = y\n    \n    x_train.loc[value, 'AVERAGE'] = x.mean()\n    x_train.loc[value, 'STD'] = x.std()\n    x_train.loc[value, 'MAX'] = x.max()\n    x_train.loc[value, 'MIN'] = x.min() \n    x_train.loc[value, 'SUM'] = x.sum()\n    \n    x_train.loc[value, 'MEAN_CHANGE_ABS'] = np.mean(np.diff(x))\n    x_train.loc[value, 'MEAN_CHANGE_RATE'] = calc_change_rate(x)\n    \n    x_train.loc[value, 'MAX_TO_MIN'] = x.max() \/ np.abs(x.min())\n    x_train.loc[value, 'MAX_TO_MIN_DIFF'] = x.max() - np.abs(x.min())\n    x_train.loc[value, 'COUNT_BIG'] = len(x[np.abs(x) > 500])\n    \n    x_train.loc[value, 'AVERAGE_FIRST_10000'] = x[:10000].mean()\n    x_train.loc[value, 'AVERAGE_LAST_10000']  =  x[-10000:].mean()\n    x_train.loc[value, 'AVERAGE_FIRST_50000'] = x[:50000].mean()\n    x_train.loc[value, 'AVERAGE_LAST_50000'] = x[-50000:].mean()\n    \n    x_train.loc[value, 'STD_FIRST_10000'] = x[:10000].std()\n    x_train.loc[value, 'STD_LAST_10000']  =  x[-10000:].std()\n    x_train.loc[value, 'STD_FIRST_50000'] = x[:50000].std()\n    x_train.loc[value, 'STD_LAST_50000'] = x[-50000:].std()\n    \n    x_train.loc[value, 'ABS_AVERAGE'] = np.abs(x).mean()\n    x_train.loc[value, 'ABS_STD'] = np.abs(x).std()\n    x_train.loc[value, 'ABS_MAX'] = np.abs(x).max()\n    x_train.loc[value, 'ABS_MIN'] = np.abs(x).min()\n    \n    x_train.loc[value, '10Q'] = np.percentile(x, 0.10)\n    x_train.loc[value, '25Q'] = np.percentile(x, 0.25)\n    x_train.loc[value, '50Q'] = np.percentile(x, 0.50)\n    x_train.loc[value, '75Q'] = np.percentile(x, 0.75)\n    x_train.loc[value, '90Q'] = np.percentile(x, 0.90)\n    \n    x_train.loc[value, 'ABS_1Q'] = np.percentile(x, np.abs(0.01))\n    x_train.loc[value, 'ABS_5Q'] = np.percentile(x, np.abs(0.05))\n    x_train.loc[value, 'ABS_30Q'] = np.percentile(x, np.abs(0.30))\n    x_train.loc[value, 'ABS_60Q'] = np.percentile(x, np.abs(0.60))\n    x_train.loc[value, 'ABS_95Q'] = np.percentile(x, np.abs(0.95))\n    x_train.loc[value, 'ABS_99Q'] = np.percentile(x, np.abs(0.99))\n    \n    x_train.loc[value, 'KURTOSIS'] = x.kurtosis()\n    x_train.loc[value, 'SKEW'] = x.skew()\n    x_train.loc[value, 'MEDIAN'] = x.median()\n    \n    x_train.loc[value, 'HILBERT_MEAN'] = np.abs(hilbert(x)).mean()\n    x_train.loc[value, 'HANN_WINDOW_MEAN'] = (convolve(x, hann(150), mode = 'same') \/ sum(hann(150))).mean()\n    \n    for windows in [10, 100, 1000]:\n        x_roll_std = x.rolling(windows).std().dropna().values\n        x_roll_mean = x.rolling(windows).mean().dropna().values\n        \n        x_train.loc[value, 'AVG_ROLL_STD' + str(windows)] = x_roll_std.mean()\n        x_train.loc[value, 'STD_ROLL_STD' + str(windows)] = x_roll_std.std()\n        x_train.loc[value, 'MAX_ROLL_STD' + str(windows)] = x_roll_std.max()\n        x_train.loc[value, 'MIN_ROLL_STD' + str(windows)] = x_roll_std.min()\n        x_train.loc[value, '1Q_ROLL_STD' + str(windows)] = np.quantile(x_roll_std, 0.01)\n        x_train.loc[value, '5Q_ROLL_STD' + str(windows)] = np.quantile(x_roll_std, 0.05)\n        x_train.loc[value, '95Q_ROLL_STD' + str(windows)] = np.quantile(x_roll_std, 0.95)\n        x_train.loc[value, '99Q_ROLL_STD' + str(windows)] = np.quantile(x_roll_std, 0.99)\n        x_train.loc[value, 'AV_CHANGE_ABS_ROLL_STD' + str(windows)] = np.mean(np.diff(x_roll_std))\n        x_train.loc[value, 'ABS_MAX_ROLL_STD' + str(windows)] = np.abs(x_roll_std).max()\n        \n        x_train.loc[value, 'AVG_ROLL_MEAN' + str(windows)] = x_roll_mean.mean()\n        x_train.loc[value, 'STD_ROLL_MEAN' + str(windows)] = x_roll_mean.std()\n        x_train.loc[value, 'MAX_ROLL_MEAN' + str(windows)] = x_roll_mean.max()\n        x_train.loc[value, 'MIN_ROLL_MEAN' + str(windows)] = x_roll_mean.min()\n        x_train.loc[value, '1Q_ROLL_MEAN' + str(windows)] = np.quantile(x_roll_mean, 0.01)\n        x_train.loc[value, '5Q_ROLL_MEAN' + str(windows)] = np.quantile(x_roll_mean, 0.05)\n        x_train.loc[value, '95Q_ROLL_MEAN' + str(windows)] = np.quantile(x_roll_mean, 0.95)\n        x_train.loc[value, '99Q_ROLL_MEAN' + str(windows)] = np.quantile(x_roll_mean, 0.99)\n        x_train.loc[value, 'AV_CHANGE_ABS_ROLL_MEAN' + str(windows)] = np.mean(np.diff(x_roll_mean))\n        x_train.loc[value, 'ABS_MAX_ROLL_MEAN' + str(windows)] = np.abs(x_roll_mean).max()","4fef2516":"x_train.head()","4c66cf29":"y_train.head(10) #our training dataframe holding our output labels","03f66ab6":"y_train.isnull().sum()","57a5a8f8":"print(x_train.shape)\nprint(y_train.shape)","582f84ab":"from sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_absolute_error","5042f162":"#normalizing the data\nscaler = StandardScaler()\nscaler.fit(x_train)\nx_train_scaled = scaler.transform(x_train)\n\ny_train_flatten = y_train.values.ravel() #flattening the y_train","4c25daf5":"#let's look at the mormalized data\nx_train_dataframe = pd.DataFrame(x_train_scaled)\nx_train_dataframe.head(10)","c61c1365":"#splitting the data into train and test\nx_train1, x_test1, y_train1, y_test1 = train_test_split(x_train, y_train, test_size = 0.2, random_state = 101)","f425fc15":"#normalizing the data\nscaler = StandardScaler()\nscaler.fit(x_train1)\nx_train_scaled1 = scaler.transform(x_train1)\nx_test_scaled1 = scaler.transform(x_test1)\n\ny_train_flatten1 = y_train1.values.ravel() #flattening the y_train\ny_test_flatten1 = y_test1.values.ravel() #flattening the y_test","062cbb5a":"print(x_train_scaled1.shape)\nprint(x_test_scaled1.shape)\nprint(y_train_flatten1.shape)\nprint(y_test_flatten1.shape)","095f46ea":"#import the libraries for building the neural net\nimport keras\nfrom keras.layers import Dense\nfrom keras.layers import BatchNormalization\nfrom keras.layers import Activation\nfrom keras.layers import Dropout\nfrom keras.models import Sequential\nfrom keras import optimizers","c72d17cf":"kernel_init = 'normal'\ndef Model(input_dim, activation, classes):\n    model = Sequential()\n\n    model.add(Dense(1024, kernel_initializer = kernel_init, input_dim = input_dim))\n    model.add(Activation(activation))\n    model.add(BatchNormalization())\n#     model.add(Dense(1024, kernel_initializer = kernel_init, input_dim = input_dim))\n#     model.add(Activation(activation))\n#     model.add(BatchNormalization())\n    model.add(Dropout(0.3))\n\n    model.add(Dense(512, kernel_initializer = kernel_init)) \n    model.add(Activation(activation))\n    model.add(BatchNormalization())\n#     model.add(Dense(512, kernel_initializer = kernel_init)) \n#     model.add(Activation(activation))\n#     model.add(BatchNormalization())\n    model.add(Dropout(0.3))\n\n    model.add(Dense(64, kernel_initializer = kernel_init))    \n    model.add(Activation(activation))\n    model.add(BatchNormalization())\n#     model.add(Dense(64, kernel_initializer = kernel_init))    \n#     model.add(Activation(activation))\n#     model.add(BatchNormalization())\n    model.add(Dropout(0.3))\n    \n#     model.add(Dense(32, kernel_initializer = kernel_init))    \n#     model.add(Activation(activation))\n#     model.add(BatchNormalization())\n#     model.add(Dense(32, kernel_initializer = kernel_init))    \n#     model.add(Activation(activation))\n#     model.add(BatchNormalization())\n#     model.add(Dropout(0.2))\n\n    model.add(Dense(classes, kernel_initializer = kernel_init))    \n    model.add(Activation('linear'))\n    \n    return model","57d1c54f":"input_dim = x_train.shape[1]\nactivation = 'tanh'\nclasses = 1 #the output labels\nmodel = Model(input_dim = input_dim, activation = activation, classes = classes)\n\n#model.summary()","5480a155":"#compile the model\noptim = optimizers.Adam(lr = 0.001, decay = 0.001 \/ 32)\nmodel.compile(loss = 'mean_absolute_error', optimizer = optim, metrics = ['mean_absolute_error'])","55f2ca9a":"#fit the model onto the dataset\nh = model.fit(x_train_scaled1, y_train_flatten1, epochs = 100, batch_size = 32, verbose = 1)","c8ddad93":"#making predictions\nprediction_score = []\nmae_scores = []\npredictions = model.predict(x_test_scaled1, verbose = 1, batch_size = 32) #make predictons on the test data \nprediction_score.append(predictions)\n\nmae = mean_absolute_error(predictions, y_test_flatten1) #calculating MAE between our actual output labels and the predicted otuput labels\nmae_scores.append(mae)","25cf0a3c":"print(np.mean(mae_scores)) #average of mean absolute errors","2e741535":"predictions = np.hstack([p.reshape(-1,1) for p in prediction_score])\npredictions = np.mean(predictions, axis = 1)\nprint(mean_absolute_error(predictions, y_test1))","332989db":"def calc_change_rate(x):\n    change = (np.diff(x) \/ x[:-1]).values\n    change = change[np.nonzero(change)[0]]\n    change = change[~np.isnan(change)]\n    change = change[change != -np.inf]\n    change = change[change != np.inf]\n    return np.mean(change)\n\nsubmission = pd.read_csv('..\/input\/sample_submission.csv', index_col = 'seg_id')\nX_test = pd.DataFrame(columns = x_train.columns, dtype = np.float64, index = submission.index)\n\nfor id in tqdm_notebook(X_test.index):\n    seg = pd.read_csv('..\/input\/test\/' + id + '.csv')\n    \n    x = pd.Series(seg['acoustic_data'].values)\n    \n    X_test.loc[id, 'AVERAGE'] = x.mean()\n    X_test.loc[id, 'STD'] = x.std()\n    X_test.loc[id, 'MAX'] = x.max()\n    X_test.loc[id, 'MIN'] = x.min() \n    X_test.loc[id, 'SUM'] = x.sum()\n    \n    X_test.loc[id, 'MEAN_CHANGE_ABS'] = np.mean(np.diff(x))\n    X_test.loc[id, 'MEAN_CHANGE_RATE'] = calc_change_rate(x)\n    \n    X_test.loc[id, 'MAX_TO_MIN'] = x.max() \/ np.abs(x.min())\n    X_test.loc[id, 'MAX_TO_MIN_DIFF'] = x.max() - np.abs(x.min())\n    X_test.loc[id, 'COUNT_BIG'] = len(x[np.abs(x) > 500])\n    \n    X_test.loc[id, 'AVERAGE_FIRST_10000'] = x[:10000].mean()\n    X_test.loc[id, 'AVERAGE_LAST_10000']  =  x[-10000:].mean()\n    X_test.loc[id, 'AVERAGE_FIRST_50000'] = x[:50000].mean()\n    X_test.loc[id, 'AVERAGE_LAST_50000'] = x[-50000:].mean()\n    \n    X_test.loc[id, 'STD_FIRST_10000'] = x[:10000].std()\n    X_test.loc[id, 'STD_LAST_10000']  =  x[-10000:].std()\n    X_test.loc[id, 'STD_FIRST_50000'] = x[:50000].std()\n    X_test.loc[id, 'STD_LAST_50000'] = x[-50000:].std()\n    \n    X_test.loc[id, 'ABS_AVERAGE'] = np.abs(x).mean()\n    X_test.loc[id, 'ABS_STD'] = np.abs(x).std()\n    X_test.loc[id, 'ABS_MAX'] = np.abs(x).max()\n    X_test.loc[id, 'ABS_MIN'] = np.abs(x).min()\n    \n    X_test.loc[id, '10Q'] = np.percentile(x, 0.10)\n    X_test.loc[id, '25Q'] = np.percentile(x, 0.25)\n    X_test.loc[id, '50Q'] = np.percentile(x, 0.50)\n    X_test.loc[id, '75Q'] = np.percentile(x, 0.75)\n    X_test.loc[id, '90Q'] = np.percentile(x, 0.90)\n    \n    X_test.loc[id, 'ABS_1Q'] = np.percentile(x, np.abs(0.01))\n    X_test.loc[id, 'ABS_5Q'] = np.percentile(x, np.abs(0.05))\n    X_test.loc[id, 'ABS_30Q'] = np.percentile(x, np.abs(0.30))\n    X_test.loc[id, 'ABS_60Q'] = np.percentile(x, np.abs(0.60))\n    X_test.loc[id, 'ABS_95Q'] = np.percentile(x, np.abs(0.95))\n    X_test.loc[id, 'ABS_99Q'] = np.percentile(x, np.abs(0.99))\n    \n    X_test.loc[id, 'KURTOSIS'] = x.kurtosis()\n    X_test.loc[id, 'SKEW'] = x.skew()\n    X_test.loc[id, 'MEDIAN'] = x.median()\n    \n    X_test.loc[id, 'HILBERT_MEAN'] = np.abs(hilbert(x)).mean()\n    X_test.loc[id, 'HANN_WINDOW_MEAN'] = (convolve(x, hann(150), mode = 'same') \/ sum(hann(150))).mean()\n    \n    for windows in [10, 100, 1000]:\n        x_roll_std = x.rolling(windows).std().dropna().values\n        x_roll_mean = x.rolling(windows).mean().dropna().values\n        \n        X_test.loc[id, 'AVG_ROLL_STD' + str(windows)] = x_roll_std.mean()\n        X_test.loc[id, 'STD_ROLL_STD' + str(windows)] = x_roll_std.std()\n        X_test.loc[id, 'MAX_ROLL_STD' + str(windows)] = x_roll_std.max()\n        X_test.loc[id, 'MIN_ROLL_STD' + str(windows)] = x_roll_std.min()\n        X_test.loc[id, '1Q_ROLL_STD' + str(windows)] = np.quantile(x_roll_std, 0.01)\n        X_test.loc[id, '5Q_ROLL_STD' + str(windows)] = np.quantile(x_roll_std, 0.05)\n        X_test.loc[id, '95Q_ROLL_STD' + str(windows)] = np.quantile(x_roll_std, 0.95)\n        X_test.loc[id, '99Q_ROLL_STD' + str(windows)] = np.quantile(x_roll_std, 0.99)\n        X_test.loc[id, 'AV_CHANGE_ABS_ROLL_STD' + str(windows)] = np.mean(np.diff(x_roll_std))\n        X_test.loc[id, 'ABS_MAX_ROLL_STD' + str(windows)] = np.abs(x_roll_std).max()\n        \n        X_test.loc[id, 'AVG_ROLL_MEAN' + str(windows)] = x_roll_mean.mean()\n        X_test.loc[id, 'STD_ROLL_MEAN' + str(windows)] = x_roll_mean.std()\n        X_test.loc[id, 'MAX_ROLL_MEAN' + str(windows)] = x_roll_mean.max()\n        X_test.loc[id, 'MIN_ROLL_MEAN' + str(windows)] = x_roll_mean.min()\n        X_test.loc[id, '1Q_ROLL_MEAN' + str(windows)] = np.quantile(x_roll_mean, 0.01)\n        X_test.loc[id, '5Q_ROLL_MEAN' + str(windows)] = np.quantile(x_roll_mean, 0.05)\n        X_test.loc[id, '95Q_ROLL_MEAN' + str(windows)] = np.quantile(x_roll_mean, 0.95)\n        X_test.loc[id, '99Q_ROLL_MEAN' + str(windows)] = np.quantile(x_roll_mean, 0.99)\n        X_test.loc[id, 'AV_CHANGE_ABS_ROLL_MEAN' + str(windows)] = np.mean(np.diff(x_roll_mean))\n        X_test.loc[id, 'ABS_MAX_ROLL_MEAN' + str(windows)] = np.abs(x_roll_mean).max()","768daa2b":"X_test.head(10)","e3385368":"print(X_test.shape)","92d134ac":"X_test.isnull().sum()","ff289ac2":"submission.shape","c80fea69":"#normalizing our testing data\nX_test_scaled = scaler.transform(X_test)\nprint(X_test_scaled.shape)","b3396001":"input_dim = x_train.shape[1]\nactivation = 'tanh'\nclasses = 1\n\nhistory = dict() #dictionery to store the history of individual models for later visualization\nprediction_scores = dict() #dictionery to store the predicted scores of individual models on the test dataset\n\n#here we will be training the same model for a total of 10 times and will be considering the mean of the output values for predictions\nfor i in np.arange(0, 15):\n    optim = optimizers.Adam(lr = 0.001, decay = 0.001 \/ 32)\n    ensemble_model = Model(input_dim = input_dim, activation = activation, classes = classes)\n    ensemble_model.compile(loss = 'mean_absolute_error', optimizer = optim, metrics = ['mean_absolute_error'])\n    print('TRAINING MODEL NO : {}'.format(i))\n    H = ensemble_model.fit(x_train_scaled, y_train_flatten,\n                  batch_size = 32,\n                  epochs = 200,\n                  verbose = 1)\n    history[i] = H\n    \n#     ensemble_model.save('MODEL_{}.model'.format(i))\n    \n    predictions = ensemble_model.predict(X_test_scaled, verbose = 1, batch_size = 32)\n    prediction_scores[i] = predictions","359125d2":"#making predictions\nprediction1 = np.hstack([p.reshape(-1,1) for p in prediction_scores.values()]) #taking the scores of all the trained models\nprediction1 = np.mean(prediction1, axis = 1)\n\nprint(prediction1.shape)","866510d0":"#submitting the file\nsubmission['time_to_failure'] = prediction1\nsubmission.to_csv('submission.csv')","b8c10bdf":"**Here we will be using two types of neural networks. The first network is a simple feed forward neural network with the following architecture:**\n\n\n**1. BLOCK1: ((DENSE(32 filters) ---> ACTIVATION ---> BN) x 2) -----> DROPOUT**\n\n**2. BLOCK2 : ((DENSE(32 filters) ---> ACTIVATION ---> BN) x 2) -----> DROPOUT**\n\n**3. BLOCK3: ((DENSE(32 filters) ---> ACTIVATION ---> BN) x 2) -----> DROPOUT**\n\n**4. BLOCK4(output layer): (DENSE(classes) ---> ACTIVATION 2)**\n\n**The second type of the network will also be a feed forward neural net but unlike in the first one where we trained our dataset on a single neural net, here we will be training our dataset on multiplt neural networks. Each neural net will have its own output scores. The mean of all the individual scores will be considered to be the final otuput score. This type of model is called as Ensemble Model. Ensemble learning ususally helps us to achieve high performance of the model on our input data, hence such models are generally used instead of a sinlge model of neural network.**\n","fef8a340":"## ENSEMBLE NEURAL NETWORK","118c211c":"## SIMPLE NEURAL NETWORK"}}