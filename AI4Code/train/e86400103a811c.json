{"cell_type":{"7becc2d3":"code","caa8d8a6":"code","f582722d":"code","90ab065b":"code","d0c8bb19":"code","d0d8059f":"code","2fc0b9ed":"code","dcaaed00":"code","e4c1a97d":"code","5ddf6d37":"code","ce3b2f2a":"code","00e8a320":"code","61fdee51":"code","c2131115":"code","14e33246":"code","5e553a65":"code","e2f2c788":"code","86f4e41a":"code","8f4bea97":"code","df1df7fd":"code","148aa74f":"code","1c9d7c69":"code","4c33fdb5":"code","2040fcc9":"code","cd45398d":"code","fa8ff8c6":"code","a492d959":"code","48a055f6":"code","c8af2366":"code","e459bc0b":"code","f7771fd5":"code","28409f33":"code","083f02d9":"markdown","c8464c54":"markdown","d70badad":"markdown","1820e055":"markdown","745ae071":"markdown","3427ae38":"markdown","505a3f6f":"markdown","23cb914b":"markdown","cf1ab47c":"markdown","6cab6c98":"markdown","6e0031cc":"markdown"},"source":{"7becc2d3":"import numpy as np\nimport pandas as pd\nimport plotly.graph_objs as go\nimport plotly.figure_factory as ff\nfrom plotly.subplots import make_subplots\nfrom IPython.display import Image\n# read dataset\npoke = pd.read_csv('\/kaggle\/input\/pokemon\/pokemon_alopez247.csv')","caa8d8a6":"# first five\npoke.head()","f582722d":"# last five\npoke.tail()","90ab065b":"poke.info()","d0c8bb19":"poke.describe()","d0d8059f":"# verify the missing data and quantify\nmissing = pd.DataFrame({'qtd_NaN_data':poke.isna().sum(), \n                        'perc_NaN_data':round((poke.isna().sum()*100\/poke.shape[0]), 2)})\nmissing","2fc0b9ed":"# Data when 'Pr_Male' is NaN\npoke[poke['Pr_Male'].isna()].head(5)","dcaaed00":"# verify if all data with NaN in Pr_Male has field hasGender equals False\nprint('Without Pr Male:{} - Has gender False:{}'.format(\n    poke['Number'][poke['Pr_Male'].isna()].count(),\n    poke['Number'][poke['hasGender'] == False].count()))\n\n# compare quantities of isLegendary pokemons with isLegendary and hasGender equals False\nprint('Is Legendary :{} - Has gender False:{}'.format(\n    poke['Number'][poke['isLegendary'] == True].count(),\n    poke['Number'][(poke['hasGender'] == False) & (poke['isLegendary'] == True)].count()))","e4c1a97d":"# list of legendery with gender\nprint('**   Legendary pokemons with gender  **')\nprint()\npoke[(poke['hasGender'] == True) & (poke['isLegendary'] == True)]","5ddf6d37":"# list of categorical features\ncat_feat = ['Type_1', 'Type_2', 'Color', 'isLegendary', \n              'hasGender', 'Egg_Group_1', 'Egg_Group_2', \n              'hasMegaEvolution', 'Body_Style']\n\n# instantiate a subplot fig\nfig = make_subplots(rows=5,cols=2,\n                    vertical_spacing=0.09,\n                    horizontal_spacing=0.075,\n                    subplot_titles=cat_feat)\n\n# add each trace generated by each feature\nfor enu, c in enumerate(cat_feat):\n    # total values\n    status_values = poke[c].value_counts().to_frame()\n    # plot distribuition\n    trace = go.Bar(x=status_values.index, \n                   y=status_values[c], \n                   text=status_values[c], \n                   textposition='auto',\n                   name=c\n                  )\n    \n    # calculate position\n    row=int(np.ceil((enu+1)\/2))\n    col=(enu % 2)+1\n    \n    # add trace\n    fig.append_trace(trace, row=row, col=col)\n    fig.update_xaxes(tickangle = 45)\n    fig.update_yaxes(showgrid = False,showticklabels = False)\n\n# update layout\nfig.update_layout(title_text='Distribuition of Categorical Data', \n                  height=1200, width=1100)\n\n# to be viewed on github\n#img = fig.to_image(format='jpg')\n#Image(img)\n# to normal plot\nfig.show()","ce3b2f2a":"# list of numerical features\nnum_feat = ['Total','HP','Attack','Defense','Sp_Atk','Sp_Def',\n'Speed','Generation','Pr_Male','Height_m','Weight_kg','Catch_Rate']\n\n# create a subplot\nsub_fig = make_subplots(rows=int(np.ceil((len(num_feat))\/3)),\n                        cols=3, \n                        vertical_spacing=0.09,\n                        horizontal_spacing=0.075,\n                        subplot_titles=num_feat)\nsub_fig.update_layout(title='Distribuition of Numerical Data', height=800, width=800)\n\n# for each feature\nfor enu, i in enumerate(num_feat):\n    \n    # calculate position\n    row=int(np.ceil((enu+1)\/3))\n    col=(enu % 3)+1\n    \n    # just a custom bin size\n    if i == 'Pr_Male' or i == 'Height_m' or i == 'Generation':\n        fig = ff.create_distplot(hist_data=[poke[i].dropna()], \n                                 group_labels=[i],\n                                 bin_size=[.2], colors=[enu])\n    else:\n        fig = ff.create_distplot(hist_data=[poke[i].dropna()], \n                                 group_labels=[i],\n                                 bin_size=[10], colors=[enu])\n    # add each data at subplot\n    for mydata in fig['data']:\n        sub_fig.append_trace(mydata, row, col)\n        \n\n\n# to be viewed on github\n#img_bytes = sub_fig.to_image(format=\"jpeg\")\n#Image(img_bytes)\n\n# to normal plot\nsub_fig.show()","00e8a320":"# convert some categorical feature to new columns\npoke_dm = pd.get_dummies(poke, columns=['Type_1', 'Type_2', 'Color'])\npoke_dm.head()","61fdee51":"# group Type_1 and Type_2\nfor t in poke.groupby(['Type_1']).groups.keys():\n    poke_dm['Type_{}'.format(t)] = poke_dm.loc[:,\n                                        poke_dm.columns.str.endswith(t)].sum(axis=1)\n    del poke_dm['Type_1_{}'.format(t)]\n    del poke_dm['Type_2_{}'.format(t)]\n    \npoke_dm.info()","c2131115":"# calculate correlation with pearson method\ncorrelations = poke_dm.corr(method='pearson')\ncorrelations","14e33246":"# Print the heatmap of this correlation\ndata = [go.Heatmap(x=correlations.columns,\n                   y=correlations.index,\n                   z=correlations, colorscale='RdBu')]\nlayout = go.Layout(title='Correlations',\n                   yaxis={'autorange':\"reversed\"})\n\nfig = go.Figure(data=data,layout=layout)\nfig.update_layout(autosize=False, height=1000, width=1000)\n\n# to be viewed on github\n# img_bytes = fig.to_image(format=\"jpeg\")\n# Image(img_bytes)\n\n# to normal plot\nfig.show()","5e553a65":"# list of features to print\nd_list = ['Pr_Male', 'Catch_Rate', 'Height_m', 'Weight_kg', 'Total']\ndimensions = []\n\n# add dimensions\nfor d in d_list:\n    dimensions.append(dict(label=d, values=poke[d]))\n\n# create splom graph    \ndata = go.Splom(dimensions=dimensions, \n                showupperhalf=True,\n                marker = dict(size=5, showscale=False,))\n\nfig = go.Figure(data=data)\nfig.update_layout(height=900, width= 900, title='Compare numerical features')\n#Image(fig.to_image('jpg'))\nfig.show()","e2f2c788":"# list of features to print\nd_list = ['Pr_Male', 'Catch_Rate', 'Type_1', 'Weight_kg']#['Catch_Rate', 'HP', 'Attack', 'Defense', 'Sp_Atk', 'Sp_Def', 'Speed']\ndimensions = []\n\n# add dimensions\nfor d in d_list:\n    dimensions.append(dict(label=d, values=poke[d], visible=True))\n# create splom graph \ndata = go.Splom(dimensions=dimensions, marker = dict(size=5, showscale=False,))\n\nfig = go.Figure(data=data)\nfig.update_layout(height=800, width= 800, title='Compare numerical features')\n#Image(fig.to_image('jpg'))\nfig.show()","86f4e41a":"# group by two fields\nf1 = 'Type_1'\nf2 = 'Color'\ntest = poke.groupby([f1,f2]).Color.count().to_frame()\ntest = test.rename(columns={'Color':'ct'})\n\n# reset indexs\ntest.reset_index(inplace=True)\n\n# row to col\ntest = test.pivot(index=f2, columns=f1)['ct']\ntest = test.fillna(0)\n\n# group by two fields\nf1 = 'Type_2'\nf2 = 'Color'\ntest2 = poke.groupby([f1,f2]).Color.count().to_frame()\ntest2 = test2.rename(columns={'Color':'ct'})\n# reset indexs\ntest2.reset_index(inplace=True)\n# row to col\ntest2 = test2.pivot(index=f2, columns=f1)['ct']\ntest2 = test2.fillna(0)\n\n# sum total of type_1 by color and type_2 by color\ntest = test+test2\n\n# percent value of each color\nfor c in test.columns:\n    test[c] = test[c]\/test[c].sum()\ntest.head(2)","8f4bea97":"# print color bar by pokemon type\ndata = []\n\nfor field in test.index:\n    y = test.columns\n    x = test[test.index == field].values[0]\n    # create bard\n    bar = go.Bar(x=x,\n                  y=y,\n                  name=field,\n                  orientation='h',\n                  marker = dict(color=field)\n                 )\n\n    data.append(bar)\n\nlayout = go.Layout(title = 'Pokemon Color by Type', \n                   barmode='stack', \n                   yaxis=dict(title='Pokemon Type'), xaxis=dict(title='Percent'))\nfig = go.Figure(data=data,layout=layout)\n\nfig.update_layout(height=700, width=800)\n#Image(fig.to_image('jpg'))\nfig.show()","df1df7fd":"numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n\npoke_dm.select_dtypes(include=numerics).columns","148aa74f":"# let's print a dendogram of our data\nimport scipy.cluster.hierarchy as shc\nfrom sklearn.cluster import AgglomerativeClustering\n\n# list of features\nnum_feat = ['Total', 'HP', 'Attack', 'Defense', 'Sp_Atk', 'Sp_Def',\n       'Speed', 'Height_m', 'Weight_kg', 'Catch_Rate',\n       'Type_Bug', 'Type_Dark', 'Type_Dragon', 'Type_Electric', 'Type_Fairy',\n       'Type_Fighting', 'Type_Fire', 'Type_Flying', 'Type_Ghost', 'Type_Grass',\n       'Type_Ground', 'Type_Ice', 'Type_Normal', 'Type_Poison', 'Type_Psychic',\n       'Type_Rock', 'Type_Steel', 'Type_Water']\n\n# calculate the clusters with euclidean distance\ncluster = AgglomerativeClustering(n_clusters=4, affinity='euclidean', linkage='ward')\n\n# create dendogram with custom linkagefun\nfig = ff.create_dendrogram(\n    poke_dm[num_feat], orientation='bottom',\n    linkagefun=lambda x: shc.linkage(poke_dm[num_feat], 'ward', metric='euclidean'), \n    color_threshold=2000\n)\nfig.update_layout(width=800, height=500)\nfig.show()\n# Image(fig.to_image('jpg'))","1c9d7c69":"cl = cluster.fit_predict(poke_dm[num_feat])\n# add cluster in dataframe\npoke_dm['Cluster'] = cl\n\n# totalizate each group\nzero, um, dois, tres = [], [], [], []\nfor ii, i in enumerate(cl):\n    if i==0:\n        zero.append(poke[poke.index == ii].Name.values[0])\n    if i==1:\n        um.append(poke[poke.index == ii].Name.values[0])\n    if i==2:\n        dois.append(poke[poke.index == ii].Name.values[0])\n    if i==3:\n        tres.append(poke[poke.index == ii].Name.values[0])\n       \nprint('0:{}, 1:{}, 2:{}, 3:{}'.format(len(zero), len(um), len(dois), len(tres)))\n# print the smallest group \nprint(zero)","4c33fdb5":"# Check the behavior of groups with respect to field combinations\ncomb = [['Total','Catch_Rate'],\n        ['Attack','Catch_Rate'],\n        ['Defense','Catch_Rate'],\n        ['Weight_kg','Height_m'],\n        ['Attack','Defense'],\n        ['Speed','HP']]\n\n# create a figure\nfig = make_subplots(rows=3,cols=2,\n                    vertical_spacing=0.09,\n                    horizontal_spacing=0.075,\n                    subplot_titles= ['{} x {}'.format(i[0], i[1]) for i in comb]\n                   )\n\n# each combination with a subplot\nfor enu, fields in enumerate(comb):         \n    value_x = poke_dm[fields[0]]\n    value_y = poke_dm[fields[1]]\n    \n    row=int(np.ceil((enu+1)\/2))\n    col=(enu % 2)+1\n    \n    trace = go.Scatter(x=value_x,\n                       y=value_y, \n                       mode='markers',\n                       marker=dict(color=poke_dm['Cluster'], colorscale=[\"red\", \"green\", \"blue\"])                       \n                       )\n    fig.append_trace(trace, row=row, col=col)\n    \nfig.update_layout(title='Comparison of some features with Clusters', showlegend=False, width=800, height=800)\nfig.show()\n#Image(fig.to_image('jpg'))","2040fcc9":"from sklearn.decomposition import PCA as skPCA\n\n# create two components PCA\ns_pca = skPCA(n_components=2)\npca_components = s_pca.fit_transform(poke_dm[num_feat])\nc_pca1 = pca_components[:,0]\nc_pca2 = pca_components[:,1]\n# add the componets to dataframe\npoke_dm['pca1'] = c_pca1\npoke_dm['pca2'] = c_pca2\npoke_dm.head(2)","cd45398d":"# Plot PCA with the previously groups\npoke_dm_temp = poke_dm\ntrace = go.Scatter(x=poke_dm_temp['pca1'],\n                   y=poke_dm_temp['pca2'],\n                   mode='markers',\n                   text=poke_dm_temp['Name'],\n                   marker=dict(color=poke_dm_temp['Cluster'], colorscale=[\"red\", \"green\", \"blue\"]))\n\nfig = go.Figure(data=[trace])\nfig.update_layout(title='PCA and clusters of all generations',width=800, height=500)\nfig.show()\n#Image(fig.to_image('jpg'))","fa8ff8c6":"# Plot PCA with the previously groups but only first generation with pokemons names \npoke_dm_temp = poke_dm[(poke_dm['Generation'] == 1)|(poke_dm['Generation'] == 1)]\ntrace = go.Scatter(x=poke_dm_temp['pca1'],\n                   y=poke_dm_temp['pca2'],\n                   mode='markers+text',\n                   textposition=\"bottom center\",\n                   text=poke_dm_temp['Name'],\n                   marker=dict(color=poke_dm_temp['Cluster'], colorscale=[\"red\", \"green\", \"blue\"]))\n\nfig = go.Figure(data=[trace])\nfig.update_layout(title='PCA and clusters of first generations',width=800, height=500)\nfig.show()\n#Image(fig.to_image('jpg'))","a492d959":"# Plot PCA with print legendary and no legendary pokemons\npoke_dm_temp = poke_dm\n# no legendary\ntrace1 = go.Scatter(x=poke_dm_temp[poke_dm_temp['isLegendary'] == False]['pca1'],\n                   y=poke_dm_temp[poke_dm_temp['isLegendary'] == False]['pca2'],\n                   mode='markers',\n                   text=poke_dm_temp[poke_dm_temp['isLegendary'] == False]['Name'],\n                   name='Commun'\n                  )\n# legendary\ntrace2 = go.Scatter(x=poke_dm_temp[poke_dm_temp['isLegendary'] == True]['pca1'],\n                   y=poke_dm_temp[poke_dm_temp['isLegendary'] == True]['pca2'],\n                   mode='markers',\n                   text=poke_dm_temp[poke_dm_temp['isLegendary'] == True]['Name'],\n                   name='Legendary'\n                  )\n\nfig = go.Figure(data=[trace1, trace2])\nfig.update_layout(title='PCA and is Legendary pokemons',width=800, height=500, showlegend=True)\nfig.show()\n#Image(fig.to_image('jpg'))","48a055f6":"# function to convert categorical string to categorical int to see if there is any kernel per type pokemon\ndef cat_to_number(n):\n    types = {'Bug': 0,  'Dark': 1,  'Dragon': 2,  'Electric': 3,  'Fairy': 4, 'Fighting': 5,\n             'Fire': 6,  'Flying': 7,  'Ghost': 8,  'Grass': 9, 'Ground': 10, 'Ice': 11, 'Normal': 12,\n             'Poison': 13,  'Psychic': 14, 'Rock': 15, 'Steel': 16, 'Water': 17}\n    return types[n]\n\n# Plot PCA\npoke_dm_temp = poke_dm\ntrace = go.Scatter(x=poke_dm_temp['pca1'],\n                   y=poke_dm_temp['pca2'],\n                   mode='markers',\n                   textposition=\"bottom center\",\n                   text=poke_dm_temp['Name'],\n                   marker=dict(color=list(map(cat_to_number, poke['Type_1'])) ))\n\nfig = go.Figure(data=[trace])\nfig.update_layout(title='PCA by Type_1',width=800, height=500, showlegend=False)\nfig.show()\n#Image(fig.to_image('jpg'))","c8af2366":"from sklearn.model_selection import cross_val_score # Cross validation function\nfrom sklearn.metrics import confusion_matrix # To generate n confusion matrix\nfrom sklearn.naive_bayes import GaussianNB # Naive Bayes with Gaussian\nfrom sklearn.neighbors import KNeighborsClassifier # KNN model\nfrom sklearn.svm import SVC # SVM categorical\nfrom sklearn.gaussian_process import GaussianProcessClassifier # Gaussian process classification based on Laplace approximation\nfrom sklearn.gaussian_process.kernels import RBF # Parameter of GPC\nfrom sklearn.tree import DecisionTreeClassifier # Decision Tree to Classifier\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier # Random Forest and Adaboost\n\n# features used in models\nx_features = ['HP', 'Attack', 'Defense', 'Sp_Atk', 'Sp_Def',\n            'Speed', 'Height_m', 'Weight_kg', 'Catch_Rate',\n            'Type_Bug', 'Type_Dark', 'Type_Dragon', 'Type_Electric', 'Type_Fairy',\n            'Type_Fighting', 'Type_Fire', 'Type_Flying', 'Type_Ghost', 'Type_Grass',\n            'Type_Ground', 'Type_Ice', 'Type_Normal', 'Type_Poison', 'Type_Psychic',\n            'Type_Rock', 'Type_Steel', 'Type_Water']\n# feature target\ny_features = ['isLegendary']\n\n# separete dataset and targer\ndata_set = poke_dm[x_features]\ntarget = poke_dm[y_features].values.ravel()\n\n# list of models\nmodels = [GaussianNB(),\n          KNeighborsClassifier(3), \n          SVC(kernel=\"linear\", C=0.025),\n          SVC(gamma=10, C=2),\n          GaussianProcessClassifier(1.0 * RBF(1.0)),\n          AdaBoostClassifier(),\n          DecisionTreeClassifier(max_depth=5),          \n          RandomForestClassifier(max_depth=10, n_estimators=5, max_features=1),\n         ]\n\n# name models\nmodels_name = [\"Naive Bayes\", \"Nearest Neighbors\", \"Linear SVM\", \"RBF SVM\", \n               \"Gaussian Process\",\"AdaBoost\", \"Decision Tree\", \"Random Forest\"]","e459bc0b":"total_scores = {}\nfor model, model_name in zip(models, models_name):\n    np.random.seed = 42\n    # K-fold k=5\n    scores = cross_val_score(model, data_set, target, cv=10, scoring='accuracy')\n    total_scores[model_name] = [scores, scores.mean(), scores.std()]\n    # Accuracy\n    print(\"{} -- K-Fold mean accuracy: {:0.3f} (std: {:0.3f})\".format(model_name, scores.mean(), scores.std()))\n    # Verify prediction of all data\n    y_pred = model.fit(data_set,target).predict(data_set)\n    \n    # Confusion Matrix\n    z = confusion_matrix(target, y_pred)\n    x=['No Legendary', 'Is Legendary']\n    y=['No Legendary', 'Is Legendary']\n    \n    # Generate annotations to graph\n    annotations = []\n    for n, row in enumerate(z):\n        for m, val in enumerate(row):\n            annotations.append(go.layout.Annotation(text=str(z[n][m]), x=x[m], y=y[n],\n                                             xref='x1', yref='y1', showarrow=False))\n            \n    data = [go.Heatmap(x=x,y=y,z=z,                   \n                   colorscale=[\"white\", \"lightblue\"])] #amp blues peach\n\n    layout = go.Layout(title='Confusion Matrix - {}'.format(model_name), \n                       xaxis={'title' : 'Predicted label'},\n                       yaxis={'autorange' : 'reversed', \n                              'title' : 'True Label'})\n    \n    fig = go.Figure(data=data, layout=layout)\n    fig['layout'].update(annotations=annotations, height=350, width=350)\n\n    fig.show()\n    #display(Image(fig.to_image('jpg')))\n    print('----------------------------------------------------------------------------')","f7771fd5":"# boxplot of 10 folds of each model\n# Gaussian Process has better result and RBF SVM has a more stable model\nfig = go.Figure()\nfor enu, (model, (scores, v_mean, v_std)) in enumerate(total_scores.items()):\n    fig.add_trace(go.Box(\n        y=scores, \n        name=model,  \n        boxmean='sd'))\nfig.update_layout(title = 'Cross Validation Accuracy Comparacion')\nfig.update_yaxes(title = 'Accuracy')\nfig.update_xaxes(title = 'Models')\nfig.show()\n#display(Image(fig.to_image('jpg')))","28409f33":"gpc = GaussianProcessClassifier(1.0 * RBF(1.0))\ny_pred = gpc.fit(data_set,target).predict(data_set)\n\n# wrong classification\npoke_dm[poke_dm['isLegendary'] != y_pred][['Number', 'Name', 'Total', 'isLegendary']]","083f02d9":"**Type_1** and **Egg_Group_2** has a lot of NaN data because many pokemons are only one type and one egg group.\n\n10 percent are **Pr_Male** NaN because 77 pokemons has no gender and if these, 40 are Legendary of 46 Legendaries.","c8464c54":"## Dataset Features\n* **Number.** Pok\u00e9mon ID in the Pok\u00e9dex.\n* **Name.** Name of the Pok\u00e9mon.\n* **Type_1.** Primary type.\n* **Type_2.** Second type, in case the Pok\u00e9mon has it.\n* **Total.** Sum of all the base stats (Health Points, Attack, Defense, Special Attack, Special Defense, and Speed).\n* **HP.** Base Health Points.\n* **Attack.** Base Attack.\n* **Defense.** Base Defense.\n* **Sp_Atk.** Base Special Attack.\n* **Sp_Def.** Base Special Defense.\n* **Speed.** Base Speed.\n* **Generation.** Number of the generation when the Pok\u00e9mon was introduced.\n* **isLegendary.** Boolean that indicates whether the Pok\u00e9mon is Legendary or not.\n* **Color.** Color of the Pok\u00e9mon according to the Pok\u00e9dex.\n* **hasGender.** Boolean that indicates if the Pok\u00e9mon can be classified as female or male.\n* **Pr_male.** In case the Pok\u00e9mon has Gender, the probability of its being male. The probability of being female is, of course, 1 minus this value.\n* **Egg_Group_1.** Egg Group of the Pok\u00e9mon.\n* **Egg_Group_2.** Second Egg Group of the Pok\u00e9mon, in case it has two.\n* **hasMegaEvolution.** Boolean that indicates whether the Pok\u00e9mon is able to Mega-evolve or not.\n* **Height_m.** Height of the Pok\u00e9mon, in meters.\n* **Weight_kg.** Weight of the Pok\u00e9mon, in kilograms.\n* **Catch_Rate.** Catch Rate.\n* **Body_Style.** Body Style of the Pok\u00e9mon according to the Pok\u00e9dex.","d70badad":"## Missing Data","1820e055":"## Color analysis","745ae071":"## Reducing dimensionality with PCA","3427ae38":"## Correlations Analysis\n","505a3f6f":"## Categorical features analysis","23cb914b":"## Numerical features distribution","cf1ab47c":"Missing data\n* 371 has no second type\n* 77 has no Pr_Male\n* 530 has no Egg_Group_2","6cab6c98":"# Now, let's find some clusters","6e0031cc":"## Machine Learning\n### Let's try models to classify if some pokemon is legendary"}}