{"cell_type":{"76e80d1b":"code","b5456abd":"code","2d0389c8":"code","5c75a0a9":"code","904d073e":"code","096ba740":"code","82f0c539":"code","64b24430":"code","4c8391c8":"code","1c9864fa":"code","71be0cd4":"code","8a793f85":"code","2291277c":"code","04d22b51":"code","055ad17a":"code","e1cc514e":"code","065d857b":"markdown","d60fcacc":"markdown","6d1c6d10":"markdown","c26bc41c":"markdown","3f6813e5":"markdown","e32f75db":"markdown"},"source":{"76e80d1b":"import os\nimport itertools\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport PIL.Image as Image\n\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import Dataset,DataLoader\n\nimport torchvision\nfrom torchvision import transforms\nfrom torchvision.utils import save_image\n\nimport wandb","b5456abd":"device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nprint(device)","2d0389c8":"from kaggle_secrets import UserSecretsClient\nuser_secrets = UserSecretsClient()\napi_key = user_secrets.get_secret(\"wandb_api_key\")\n\nwandb.login(key=api_key)","5c75a0a9":"path = '..\/input\/summer2winter-yosemite'","904d073e":"class ImageDataset(Dataset):\n    \n    def __init__(self,path):\n        super().__init__()\n        self.path = path\n        self.train = os.listdir(path)\n        self.image_transforms = transforms.Compose([transforms.ToTensor(),\n                                                    transforms.Normalize((0.5, 0.5, 0.5),(0.5, 0.5, 0.5)),])\n   \n    def __len__(self):\n        return len(self.train)\n    \n    def __getitem__(self,idx):\n        image = f'{self.path}\/{self.train[idx]}'\n        image = Image.open(image)\n        if self.image_transforms:\n            return self.image_transforms(image)\n        return image\n    \n\ndef make_dataloader(batch_size=8, **kwargs):\n    dataset = ImageDataset(**kwargs)\n    dataloader = DataLoader(dataset,batch_size=batch_size,num_workers=1,pin_memory=True,shuffle=True)\n    return dataloader   ","096ba740":"dataloader_A = make_dataloader(path=f'{path}\/trainA')\ndataloader_B = make_dataloader(path=f'{path}\/trainB')","82f0c539":"def imshow(grid,title):\n    nparray = grid.cpu().numpy()\n    nparray = (nparray*0.5)+0.5\n    plt.figure(figsize=(12,12))\n    plt.title(title)\n    plt.axis('off')\n    plt.imshow(np.transpose(nparray,(1,2,0)))\n    plt.show()","64b24430":"imgsA = next(iter(dataloader_A))\ngridA = torchvision.utils.make_grid(imgsA,nrow=4)\nimshow(gridA,'Summer Images')","4c8391c8":"imgsB = next(iter(dataloader_B))\ngridB = torchvision.utils.make_grid(imgsB,nrow=4)\nimshow(gridB,'Winter Images')","1c9864fa":"class ConvBlock(nn.Module):\n  \n    def __init__(self,in_channels,out_channels,down=True,act=True,**kwargs):\n        super().__init__()\n        self.conv = nn.Sequential(\n                             nn.Conv2d(in_channels=in_channels,out_channels=out_channels,padding_mode='reflect',**kwargs)\n                             if down else nn.ConvTranspose2d(in_channels=in_channels,out_channels=out_channels,**kwargs),\n                             nn.InstanceNorm2d(out_channels),\n                             nn.ReLU(inplace=True) if act else nn.Identity(),\n                                )\n\n    def forward(self,x):\n        return self.conv(x)\n    \n\nclass ResidualBlock(nn.Module):\n  \n    def __init__(self,channels,**kwargs):\n        super().__init__()\n        self.main = nn.Sequential(\n                             ConvBlock(channels,channels,kernel_size=3, padding=1),\n                             ConvBlock(channels,channels,act=False,kernel_size=3, padding=1)\n                                 )\n\n    def forward(self,x):\n        return x + self.main(x)\n    \n\nclass Generator(nn.Module):\n\n    def __init__(self,nb_features,nb_residualblock=9):\n        super().__init__()\n        self.first = ConvBlock(3,nb_features,kernel_size=7,stride=1,padding=3)\n        self.down = nn.ModuleList(\n                        [ConvBlock(nb_features,nb_features*2,kernel_size=3, stride=2, padding=1),\n                        ConvBlock(nb_features*2,nb_features*4,kernel_size=3, stride=2, padding=1)]\n                                 )\n        self.residual_block = nn.Sequential(*[ResidualBlock(nb_features*4) for _ in range(nb_residualblock)])\n        self.up = nn.ModuleList(\n                        [ConvBlock(nb_features*4,nb_features*2,down=False,kernel_size=3, stride=2, padding=1, output_padding=1),\n                        ConvBlock(nb_features*2,nb_features,down=False,kernel_size=3, stride=2, padding=1, output_padding=1)]\n                               )\n        self.last = nn.Conv2d(nb_features,3,kernel_size=7,stride=1,padding=3, padding_mode=\"reflect\")\n\n    def forward(self,x):\n        x = self.first(x)\n        for layer in self.down:\n            x = layer(x)\n        x = self.residual_block(x)\n        for layer in self.up:\n            x = layer(x)\n        x = nn.Tanh()(self.last(x))\n        return x","71be0cd4":"class Block(nn.Module):\n\n    def __init__(self,in_channels,out_channels,stride):\n        super().__init__()\n        self.conv = nn.Sequential(\n                          nn.Conv2d(in_channels,out_channels,kernel_size=4,stride=stride,padding=1,padding_mode='reflect'),\n                          nn.InstanceNorm2d(out_channels),\n                          nn.LeakyReLU(0.2,inplace=True),\n                             )\n    def forward(self,x):\n        return self.conv(x)\n    \n\nclass Discriminator(nn.Module):\n\n    def __init__(self,nb_features):\n        super().__init__()\n        self.first = nn.Sequential(\n                         nn.Conv2d(3,nb_features,kernel_size=4,stride=2,padding=1,padding_mode='reflect'),\n                         nn.LeakyReLU(0.2,inplace=True),\n                              )\n        self.convblock = nn.ModuleList(\n                              [Block(nb_features,nb_features*2,2),\n                               Block(nb_features*2,nb_features*4,2),\n                               Block(nb_features*4,nb_features*6,1)]\n                                  )\n        self.last = nn.Sequential(\n                        nn.Conv2d(nb_features*6,1,kernel_size=4,padding=1,padding_mode='reflect'),\n                        nn.Sigmoid()\n                             )\n    def forward(self,x):\n        x = self.first(x)\n        for layer in self.convblock:    \n            x = layer(x)\n        x = self.last(x)\n        return x    ","8a793f85":"class CycleGAN(nn.Module):\n    \n    def __init__(self,nb_features=64,lr=0.002,beta1=0.5,beta2=0.999,lambda_cycle=10.0):\n        super().__init__()\n        self.G_AB = torch.load(\"..\/input\/cyclegan\/CycleGAN\/Generator_AtoB.pth\").to(device)\n        self.G_BA = torch.load(\"..\/input\/cyclegan\/CycleGAN\/Generator_BtoA.pth\").to(device)\n        self.D_A  = torch.load(\"..\/input\/cyclegan\/CycleGAN\/Discriminator_A.pth\").to(device)\n        self.D_B  = torch.load(\"..\/input\/cyclegan\/CycleGAN\/Discriminator_B.pth\").to(device)\n        self.adversarial_loss = nn.MSELoss()\n        self.cycle_loss = nn.L1Loss()\n        self.opt_G = torch.optim.Adam(itertools.chain(self.G_AB.parameters(),self.G_BA.parameters()),lr=lr,betas=(beta1,beta2))\n        self.opt_D_A  = torch.optim.Adam(self.D_A.parameters(),lr=lr,betas=(beta1,beta2))\n        self.opt_D_B  = torch.optim.Adam(self.D_B.parameters(),lr=lr,betas=(beta1,beta2))\n        self.lambda_cycle = lambda_cycle\n    \n    def setup_input(self,real_A,real_B):\n        self.real_A = real_A.to(device)\n        self.real_B = real_B.to(device)\n        self.fake_A = self.G_BA(self.real_B)\n        self.fake_B = self.G_AB(self.real_A)\n    \n    def optimize_D(self):\n        self.D_A.train()\n        self.D_B.train()\n        real_preds = self.D_A(self.real_A)\n        fake_preds = self.D_A(self.fake_A.detach())\n        real_loss = self.adversarial_loss(real_preds,torch.ones_like(real_preds,device=device))\n        fake_loss = self.adversarial_loss(fake_preds,torch.zeros_like(fake_preds,device=device))\n        loss_D_A = (real_loss+fake_loss)\/2\n        \n        real_preds = self.D_B(self.real_B)\n        fake_preds = self.D_B(self.fake_B.detach())\n        real_loss = self.adversarial_loss(real_preds,torch.ones_like(real_preds,device=device))\n        fake_loss = self.adversarial_loss(fake_preds,torch.zeros_like(fake_preds,device=device))\n        loss_D_B = (real_loss+fake_loss)\/2\n    \n        self.opt_D_A.zero_grad()\n        loss_D_A.backward()\n        self.opt_D_A.step()\n        \n        self.opt_D_B.zero_grad()\n        loss_D_B.backward()\n        self.opt_D_B.step()\n        \n        return loss_D_A,loss_D_B\n        \n    def optimize_G(self):\n        self.G_AB.train()\n        self.G_BA.train()\n        fake_preds_A = self.D_A(self.fake_A)\n        fake_preds_B = self.D_B(self.fake_B)\n        adversarial_loss_G_AB = self.adversarial_loss(fake_preds_B,torch.ones_like(fake_preds_B,device=device))\n        adversarial_loss_G_BA = self.adversarial_loss(fake_preds_A,torch.ones_like(fake_preds_A,device=device))\n        adversarial_loss_G = (adversarial_loss_G_AB + adversarial_loss_G_BA)\/2\n        \n        cycle_loss_G_AB = self.cycle_loss(self.real_A,self.G_BA(self.fake_B))\n        cycle_loss_G_BA = self.cycle_loss(self.real_B,self.G_AB(self.fake_A))\n        cycle_loss_G = (cycle_loss_G_AB + cycle_loss_G_BA)\/2\n        loss_G = adversarial_loss_G + (self.lambda_cycle*cycle_loss_G)\n    \n        self.opt_G.zero_grad()\n        loss_G.backward()\n        self.opt_G.step()\n        \n        return loss_G","2291277c":"gan = CycleGAN()","04d22b51":"wandb.init(project='CycleGAN', entity='balaji_ai',config=dict(nb_features=64,lr=0.002,beta1=0.5,beta2=0.999,lambda_cycle=10.0))\n\nfor iteration in range(17_000):\n    real_A = next(iter(dataloader_A))\n    real_B = next(iter(dataloader_B))\n    gan.setup_input(real_A,real_B)\n    loss_D_A,loss_D_B = gan.optimize_D()\n    loss_G = gan.optimize_G()\n    wandb.log({\"loss_G\":loss_G,\"loss_D_A\": loss_D_A,\"loss_D_B\":loss_D_B})\n    if ((iteration+1)%1_000==0):\n        wandb.log({\"Generated Summer images\" : [wandb.Image(im) for im in gan.fake_A]})\n        wandb.log({\"Generated Winter images\" : [wandb.Image(im) for im in gan.fake_B]})","055ad17a":"torch.save(gan.G_AB,'Generator_AtoB.pth')\ntorch.save(gan.G_BA,'Generator_BtoA.pth')\ntorch.save(gan.D_A,'Discriminator_A.pth')\ntorch.save(gan.D_B,'Discriminator_B.pth')","e1cc514e":"save_image(gan.real_A,\"real_summer.png\", nrow=4, normalize=True)\nsave_image(gan.real_B,\"real_winter.png\", nrow=4, normalize=True)\nsave_image(gan.fake_A.detach(),\"generated_summer.png\", nrow=4, normalize=True) \nsave_image(gan.fake_B.detach(),\"generated_winter.png\", nrow=4, normalize=True)","065d857b":"# Import Packages","d60fcacc":"# Prepare the Dataset","6d1c6d10":"# Results","c26bc41c":"# GAN","3f6813e5":"# Training","e32f75db":"# Training class"}}