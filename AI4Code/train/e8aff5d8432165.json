{"cell_type":{"88f20fcf":"code","10a8c890":"code","a7d52fc1":"code","4a81a17a":"code","aa76707d":"code","46ac27da":"code","ffa151b8":"code","e41f3ee3":"code","0a5e6bf3":"code","27938f71":"code","d1ff3ecc":"code","0162a570":"code","fbe8eb1a":"code","bd2fd75e":"code","1e954d34":"code","7b16acd1":"code","4e769f41":"code","b1e68d71":"code","22f8f81f":"code","4bbbddc6":"code","e8bdc4bc":"code","8299fbd6":"code","8bb04f7d":"code","6fdcaf75":"code","f6d15e98":"code","4a3c9bd0":"code","61402361":"code","a6b881bc":"code","d9f2f3ce":"code","ab5e58f1":"code","942c31f4":"code","157c1414":"code","442f7f3a":"code","d72971a6":"code","7ca59a7a":"code","cafdb7ff":"code","2bf627ae":"code","a75ef375":"code","4a152b20":"code","52b5d454":"code","62638541":"code","08f867a1":"code","99ac92ab":"code","2f93bc12":"code","da9226f8":"code","9680da42":"code","7c1fbd91":"code","519ce62b":"code","c95c826c":"code","887d223a":"code","91b5c4cd":"code","149b439c":"code","15b8cb24":"code","c0ed57e2":"code","a912f1b8":"code","15ed25cb":"code","c0bad590":"code","f8ae5b49":"code","09ac8b98":"code","e7c484fd":"code","d2846c7c":"code","d3b1efec":"code","be130b2e":"code","bb1986a9":"code","8a721cef":"code","9c82b807":"code","19482228":"code","140568aa":"code","d2ec1ac1":"code","f15353e6":"code","02405fd9":"code","983ac5f2":"code","3dd7426c":"code","5cc77109":"code","783a40b3":"code","6957c1af":"code","9b5ba079":"code","b5dc98e3":"code","cdb31a40":"code","f22d7099":"code","7866b08e":"markdown","0b312b83":"markdown","1f76d094":"markdown","e99e982a":"markdown","b26fcd62":"markdown","95511a5d":"markdown","a29d760f":"markdown","6986281f":"markdown","00bde3ce":"markdown","9a00ec5b":"markdown","4ee146f9":"markdown","1c952e2f":"markdown","daf07dfc":"markdown","d891fea9":"markdown"},"source":{"88f20fcf":"import os, sys\nimport datetime\nfrom time import time\nfrom tqdm import tqdm_notebook as tqdm\nfrom collections import Counter\n\nimport numpy as np\nimport pandas as pd\npd.set_option('display.max_columns', None)\n\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.model_selection import GroupKFold\nfrom sklearn.model_selection import train_test_split as split\nfrom sklearn.metrics import cohen_kappa_score\nimport category_encoders as ce\n\nfrom catboost import CatBoostRegressor\nimport lightgbm as lgb\nimport xgboost as xgb\n\nfrom functools import partial\nimport scipy as sp              # for optimize.minimize()","10a8c890":"# Execution environment setting\nKaggle = True\n\nif Kaggle:\n    DIR = '..\/input\/data-science-bowl-2019'\n    task_type = 'CPU'\nelse:\n    DIR = '.\/data-science-bowl-2019'\n    task_type = 'GPU'","a7d52fc1":"train = pd.read_csv(os.path.join(DIR,'train.csv'))\n#train_labels = pd.read_csv(os.path.join(DIR,'train_labels.csv'))\n#specs = pd.read_csv(os.path.join(DIR,'specs.csv'))\ntest = pd.read_csv(os.path.join(DIR,'test.csv'))\n#media_seq = pd.read_csv(os.path.join('..\/input\/dsb2019-external-data','media_sequence.csv'))","4a81a17a":"#print('train:\\t\\t',train.shape)\n#print('train_labels:\\t',train_labels.shape)\n#print('specs:\\t\\t',specs.shape)\n#print('test:\\t\\t',test.shape)\n#print('media_seq:\\t\\t',media_seq.shape)","aa76707d":"#train.head()","46ac27da":"#event_code_n = train['event_code'].nunique()\n#print(\"num of unique 'event_code':\", event_code_n)\n#print(\"'event_code': \",\n#      train['event_code'].min(), \"-\", train['event_code'].max())","ffa151b8":"# 'event_data' exsample\n#print(train['event_data'][40])\n#print(train['event_data'][41])\n#print(train['event_data'][43])","e41f3ee3":"#train_labels.head()","0a5e6bf3":"#train_labels[['game_session','installation_id', 'title']].describe()","27938f71":"# unique 'title' list\n#train_labels['title'].unique()","d1ff3ecc":"#specs.head()","0162a570":"#specs.describe()","fbe8eb1a":"# 'info' exsample\n#print(specs['info'][0],'\\n')\n#print(specs['info'][6],'\\n')\n#print(specs['info'][7])","bd2fd75e":"# 'args' exsample\n#print(specs['args'][0],'\\n')\n#print(specs['args'][1])","1e954d34":"#test.head(8)\n#test['world'].unique()","7b16acd1":"#test[['event_id','game_session','installation_id',\n#       'title','type','world']].describe()","4e769f41":"#' malke 'title' and 'event_code' list\ntitle_list = list(set(train['title'].value_counts().index).union(set(test['title'].value_counts().index)))\nevent_code_list = list(set(train['event_code'].value_counts().index).union(set(test['event_code'].value_counts().index)))\nevent_id_list = list(set(train['event_id'].value_counts().index).union(set(test['event_id'].value_counts().index)))\n","b1e68d71":"# make dict 'title to number(integer)'\ntitle2num = dict(zip(title_list, np.arange(len(title_list))))\n# meke dict 'number to title'\nnum2title = dict(zip(np.arange(len(title_list)), title_list))\n\n# meke dict 'title to win event_code'\n# (4100 except 'Bird Measurer' and 4110 for 'Bird Measurer')\ntitle2win_code = dict(zip(title2num.values(), (np.ones(len(title2num))).astype('int') * 4100))\ntitle2win_code[title2num['Bird Measurer (Assessment)']] = 4110","22f8f81f":"# Convert 'title to the number'\ntrain['title']  = train['title'].map(title2num)\ntest['title'] = test['title'].map(title2num)\n#train_labels['title'] = train_labels['title'].map(title2num)\n\n#Convert 'timestamp' to datetime\ntrain['timestamp'] = pd.to_datetime(train['timestamp'])\ntest['timestamp'] = pd.to_datetime(train['timestamp'])","4bbbddc6":"#train = train[train['installation_id'].isin(train_labels['installation_id'].unique())]","e8bdc4bc":"clip_time = {'Welcome to Lost Lagoon!':19,'Tree Top City - Level 1':17,'Ordering Spheres':61, 'Costume Box':61,\n        '12 Monkeys':109,'Tree Top City - Level 2':25, 'Pirate\\'s Tale':80, 'Treasure Map':156,'Tree Top City - Level 3':26,\n        'Rulers':126, 'Magma Peak - Level 1':20, 'Slop Problem':60, 'Magma Peak - Level 2':22, 'Crystal Caves - Level 1':18,\n        'Balancing Act':72, 'Lifting Heavy Things':118,'Crystal Caves - Level 2':24, 'Honey Cake':142, 'Crystal Caves - Level 3':19,\n        'Heavy, Heavier, Heaviest':61}","8299fbd6":"#user_sample = train[train['installation_id']=='0006a69f']\n#user_sample.head()\n#session = user_sample[user_sample['game_session'] == '2b9d5af79bcdb79f']\n#session.head()\n#num2title","8bb04f7d":"#clip_time[num2title[session.title.iloc[0]]]","6fdcaf75":"def agr_session(user_sample):\n    '''\n    user_sample : DataFrame from train\/test group by 'installation_id'\n    '''\n    session_agr = []\n\n    for i, session in user_sample.groupby(['game_session'],sort = False):\n        session = session.sort_values('timestamp')\n        event_code_count = {code:0 for code in event_code_list}\n        event_codes = Counter(session['event_code'])\n        for key in event_codes.keys():\n            event_code_count[key] += event_codes[key]\n        session_grp = event_code_count.copy()\n        \n        event_id_count = {code:0 for code in event_id_list}\n        event_ids = Counter(session['event_id'])\n        for key in event_ids.keys():\n            event_id_count[key] += event_ids[key]\n        session_grp.update(event_id_count.copy())\n\n        session_grp['installation_id'] = session['installation_id'].iloc[0]\n        session_grp['game_session'] = session['game_session'].iloc[0]\n        session_title = session['title'].iloc[0]  # Game\/Assessment\/Activity\/Clip\n        session_grp['title'] = session_title\n        session_type = session['type'].iloc[0]  # Game\/Assessment\/Activity\/Clip\n        session_grp['type'] = session_type\n        session_grp['world'] = session['world'].iloc[0]\n        session_grp['timestamp_st'] = session.iloc[0,2]\n        session_grp['timestamp_en'] = session.iloc[-1,2]\n        session_grp['event_count'] = len(session)\n        if session_type == 'Clip':\n            session_grp['game_time_sum'] = clip_time[num2title[session_title]]*1000\n        else:\n            session_grp['game_time_sum'] = session['game_time'].iloc[-1]\n        game_time_diff = session['game_time'].diff(1)\n        game_time_diff_nonzero = game_time_diff[game_time_diff!=0][~game_time_diff.isnull()]\n        session_grp['game_time_nonzeros'] = len(game_time_diff_nonzero)\n        #session_grp['game_time_ave'] = game_time_diff.mean(skipna=True)\n        #session_grp['game_time_ave_nonzero'] = game_time_diff_nonzero.mean(skipna=True)\n        #session_grp['game_time_max'] = game_time_diff.max()\n        #session_grp['game_time_min_nonzero'] = game_time_diff_nonzero.min()\n        #session_grp['game_time_std'] = game_time_diff.std()\n        #session_grp['game_time_std_nonzero'] = game_time_diff_nonzero.std()\n        \n        if session_type == 'Assessment':\n            #search for event_code 4100(4110)\n            all_4100 = session.query(f'event_code == {title2win_code[session_title]}')\n            #numbers of win and losses\n            time_to_first_ans = all_4100['game_time'].min()\n            time_to_final_ans = all_4100['game_time'].max()\n            win_n = all_4100['event_data'].str.contains('true').sum()\n            loss_n = all_4100['event_data'].str.contains('false').sum()\n            accuracy = (win_n)\/ (win_n + loss_n) if (win_n + loss_n) > 0 else 0\n            \n            if accuracy == 0:\n                accuracy_group = 0\n            elif accuracy == 1:\n                accuracy_group = 3\n            elif accuracy == 0.5:\n                accuracy_group = 2\n            else:\n                accuracy_group = 1\n\n        else:\n            time_to_first_ans = np.nan\n            time_to_final_ans = np.nan\n            win_n = np.nan\n            loss_n = np.nan\n            accuracy = np.nan\n            accuracy_group = np.nan\n        \n        session_grp['time_to_first_ans'] = time_to_first_ans\n        session_grp['time_to_final_ans'] = time_to_final_ans\n        session_grp['win_n'] = win_n\n        session_grp['loss_n'] = loss_n  \n        session_grp['accuracy'] = accuracy\n        session_grp['accuracy_group'] = accuracy_group\n        \n        session_agr.append(session_grp) \n    return session_agr\n","f6d15e98":"# get_data function is applyed to each installation_id\ncompiled_data = []\ninstallation_n = train['installation_id'].nunique()\nfor i, (ins_id, user_sample) in tqdm(enumerate(train.groupby( \\\n                                     'installation_id', sort=False)),\n                                     total=installation_n):\n    # user_sample : DataFrame group by 'installation_id'\n    compiled_data += agr_session(user_sample)","4a3c9bd0":"del train\ntrain_agr = pd.DataFrame(compiled_data)","61402361":"# process test set, the same that was done with the train set\ncompiled_data = []\nfor ins_id, user_sample in tqdm(test.groupby('installation_id',sort=False),\n                                total=1000):\n    compiled_data += agr_session(user_sample)    \ntest_agr = pd.DataFrame(compiled_data)\ndel compiled_data\ndel test","a6b881bc":"#ase = train_agr[train_agr['type']=='Assessment']\n#ase = ase[ase['installation_id']=='0006a69f']\n#e7e7db2a241eadcc\n#assess_hist = ase.iloc[0:2]\n#print(assess_hist)\n#assess_info = ase.iloc[1]\n#assess_info","d9f2f3ce":"#assess_hist","ab5e58f1":"#same_assess = assess_hist[assess_hist['title']==assess_info['title']]\n#\n#assess_hist['title']==assess_info['title']\n#same_assess = same_assess[same_assess['timestamp_st']<assess_info['timestamp_st']]\n#len(same_assess)\n#train_labels[train_labels['game_session']=='e7e7db2a241eadcc']","942c31f4":"#types_count = {'Clip':0, 'Activity':0, 'Assessment':0, 'Game':0}\n#ase = train_agr[train_agr['type']=='Assessment']\n\n#user_sample = train_agr[train_agr['installation_id']=='0006a69f']\n#user_sample = user_sample.sort_values('timestamp_st')\n#assessment_inst = user_sample[user_sample['type']=='Assessment']\n#assess_time =assessment_inst.timestamp_st.iloc[0]\n#assess_sample = user_sample[user_sample['timestamp_st'] <= assess_time]\n#assess_sample = assess_sample.sort_values('timestamp_st')\n#assess_sample = assess_sample[assess_sample['timestamp_st'] < assess_time]\n\n#assess_sample\n#ase","157c1414":"#assess_sample[assess_sample['type']=='Activity'].event_count.sum()","442f7f3a":"#def change_dic_key(d,old_key,new_key,default_value=None):\n#    d[new_key] = d.pop(old_key,default_value)","d72971a6":"#types_count = {'Clip':0, 'Activity':0, 'Assessment':0, 'Game':0}\n#for key in list(types_count.keys()):\n#    types_count[key+'_count'] = types_count[key]\n#    del types_count[key]\n#types_count","7ca59a7a":"def preprocess_data(user_sample,train_set = True):\n    prep_data = []\n    user_sample = user_sample.sort_values('timestamp_st')\n   # print(user_sample.installation_id.iloc[0])\n    assessment_inst = user_sample[user_sample['type']=='Assessment']\n    accumu_accuracy_group = 0\n    accumu_accuracy=0\n    accumu_win_n = 0 \n    accumu_loss_n = 0 \n    counter=0\n    accuracy_groups = {0.0:0, 1.0:0, 2.0:0, 3.0:0}\n    durations = []\n    for assess_time in assessment_inst['timestamp_st']:\n        #print(assess_time)\n        assess_sample = user_sample[user_sample['timestamp_st'] <= assess_time]\n        assess_sample = assess_sample.sort_values('timestamp_st')\n\n        time_spent_each_title = {title:0 for title in title_list}\n        event_code_count = {code:0 for code in event_code_list}\n        event_id_count = {code:0 for code in event_id_list}\n        types_time = {'Clip':0, 'Activity':0, 'Assessment':0, 'Game':0}\n        world_time = {'MAGMAPEAK':0, 'NONE':0, 'CRYSTALCAVES':0, 'TREETOPCITY':0}\n        types_count = {'Clip':0, 'Activity':0, 'Assessment':0, 'Game':0}\n        world_count = {'MAGMAPEAK':0, 'NONE':0, 'CRYSTALCAVES':0, 'TREETOPCITY':0}\n        \n        assess_hist = assess_sample[assess_sample['type']=='Assessment']\n        assess_info = assess_hist.iloc[-1]\n        assess_count = len(assess_hist)\n        assess_sample = assess_sample[assess_sample['timestamp_st'] < assess_time]\n        for key in event_code_count.keys():\n            event_code_count[key] = assess_sample[key].sum()\n        for key in event_id_count.keys():\n            event_id_count[key] = assess_sample[key].sum()\n        for key in types_count.keys():\n            types_count[key] = assess_sample[assess_sample['type']==key].event_count.sum()\n        for key in list(types_count.keys()):\n            types_count[key+'_count'] = types_count[key]\n            del types_count[key]\n      \n        for key in world_count.keys():\n            world_count[key] = assess_sample[assess_sample['world']==key].event_count.sum()\n        for key in list(world_count.keys()):\n            world_count[key+'_count'] = world_count[key]\n            del world_count[key]\n\n        assess_sample = user_sample[user_sample['timestamp_st'] <= assess_time]\n        features = event_code_count.copy()\n        features.update(event_id_count.copy())\n        features.update(types_count.copy())\n        features.update(world_count.copy())\n        #features['installation_id'] = assess_info['installation_id']\n        features['title'] = assess_info['title']\n        features['world'] = assess_info['world']\n        features['assess_count'] = assess_count\n        features['unique_assess'] = assess_hist.title.nunique()\n        features['unique_title'] = assess_sample.title.nunique()\n        features['unique_world'] = assess_sample.world.nunique()\n        \n        features['dayofweek'] = assess_info['timestamp_st'].dayofweek\n        #features['weekofyear'] = assess_info['timestamp_st'].weekofyear\n        #features['month'] = assess_info['timestamp_st'].month\n        #features['day'] = assess_info['timestamp_st'].day\n        features['hour'] = assess_info['timestamp_st'].hour\n        #features['time_to_asess'] = (assess_sample['timestamp_st'].iloc[-1] - assess_sample['timestamp_st'].iloc[0]).seconds\n        interval = assess_sample['timestamp_st'].shift(-1)-assess_sample['timestamp_en']\n        t_seconds = lambda x: x.seconds\n        interval = interval.map(t_seconds)\n        if len(interval)==1:\n            interval_before_assess=0\n        else:\n            interval_before_assess=interval.iloc[-2]\n        \n        #features['interval_before_assess'] = interval_before_assess\n        features['interval_ave'] = interval.mean()\n        features['interval_min'] = interval.min()\n        features['interval_max'] = interval.max()\n\n        assess_sample = assess_sample[assess_sample['timestamp_st'] < assess_time]\n        features['session_count'] = len(assess_sample)\n        features['event_count_mean'] = assess_sample[assess_sample['event_count']>1]['event_count'].mean()\n        features['event_count_max'] = assess_sample[assess_sample['event_count']>1]['event_count'].max()\n        features['event_count_min'] = assess_sample[assess_sample['event_count']>1]['event_count'].min()\n        features['event_count_std'] = assess_sample[assess_sample['event_count']>1]['event_count'].std()\n        features['accum_actions'] = assess_sample.event_count.sum()\n        features['accum_game_time'] = assess_sample.game_time_sum.sum()\n        features['game_time_nonzero_count'] = assess_sample.game_time_nonzeros.sum()\n        \n        \n        game_time_title = assess_sample.groupby(['title'])['game_time_sum'].sum()\n        for key in game_time_title.keys():\n            time_spent_each_title[num2title[key]] += game_time_title[key]\n        features.update(time_spent_each_title.copy())\n        game_time_type = assess_sample.groupby(['type'])['game_time_sum'].sum()\n        for key in game_time_type.keys():\n            types_time[key] = game_time_type[key]\n        features.update(types_time.copy())\n\n        game_time_world = assess_sample.groupby(['world'])['game_time_sum'].sum()\n        for key in game_time_world.keys():\n            world_time[key] = game_time_world[key]\n        features.update(world_time.copy())\n        \n        features['accumu_win_n'] = accumu_win_n\n        features['accumu_loss_n'] = accumu_loss_n\n        accumu_win_n += assess_info['win_n']\n        accumu_loss_n += assess_info['loss_n']\n        \n        features.update(accuracy_groups)\n        #if (np.isnan(accuracy_groups[assess_info['accuracy_group']]))==False:\n        accuracy_groups[assess_info['accuracy_group']] += 1\n        features['accuracy_ave'] = accumu_accuracy \/ counter \\\n                                                if counter > 0 else 0\n        accumu_accuracy += assess_info['accuracy']\n        features['accuracy_group_ave'] = \\\n                    accumu_accuracy_group \/ counter if counter > 0 else 0\n        accumu_accuracy_group +=  assess_info['accuracy_group']\n        counter +=1\n        \n        if durations == []:\n            features['duration_mean'] = 0\n            features['duration_std'] = 0\n            features['duration_max'] = 0\n        else:\n            features['duration_mean'] = np.mean(durations)\n            features['duration_mean'] = np.std(durations)\n            features['duration_max'] = np.max(durations)\n\n        durations.append(assess_info['game_time_sum'])\n        \n        if assess_count > 1:\n            last_title = assess_hist['title'].iloc[-2]\n            last_win_n = assess_hist['win_n'].iloc[-2]\n            last_loss_n = assess_hist['loss_n'].iloc[-2]\n            last_accuracy = assess_hist['accuracy'].iloc[-2]\n            last_accuracy_group = assess_hist['accuracy_group'].iloc[-2]\n            interval_from_last_assess = ( assess_hist['timestamp_st'].iloc[-1] - assess_hist['timestamp_st'].iloc[-2] ).seconds\n        else:\n            last_title = np.nan\n            last_win_n = np.nan\n            last_loss_n = np.nan\n            last_accuracy = np.nan\n            last_accuracy_group = np.nan\n            interval_from_last_assess = np.nan\n\n        features['last_title'] = last_title\n        features['last_win_n'] = last_win_n\n        features['last_loss_n'] = last_loss_n\n        features['last_accuracy'] = last_accuracy\n        features['last_accuracy_group'] = last_accuracy_group\n        #features['interval_from_last_assess'] = interval_from_last_assess\n\n        #features['same_accuracy_ave']=0\n        #features['same_accuracy_max']=0\n        #features['same_accuracy_min']=0\n        features['same_accuracy_try']=0\n        features['same_accuracy_game_time']=0\n        features['same_accuracy_event_count']=0\n        if len(assess_hist)>1:\n            same_assess = assess_hist[assess_hist['title']==assess_info['title']]\n            same_assess = same_assess[same_assess['timestamp_st']<assess_info['timestamp_st']]\n            if len(same_assess)>0:\n                #features['same_accuracy_ave']=same_assess.accuracy.mean()\n                #features['same_accuracy_max']=same_assess.accuracy.max()\n                #features['same_accuracy_min']=same_assess.accuracy.min()\n                features['same_accuracy_try']=len(same_assess)\n                features['same_accuracy_game_time']=same_assess.game_time_sum.sum()\n                features['same_accuracy_event_count']=same_assess.event_count.sum()\n\n        \n        if train_set:\n            features['accuracy_group'] = assess_info['accuracy_group']\n        if train_set==False or (assess_info['win_n'] + assess_info['loss_n']) > 0:\n            prep_data.append(features)\n\n    if train_set==False:\n        return prep_data[-1]\n    return prep_data\n#features","cafdb7ff":"#train_data = preprocess_data(user_sample)\n#train_data.head()\ninstallation_n = train_agr['installation_id'].nunique()\ntrain_data = []\nfor ins_id, user_sample in tqdm(train_agr.groupby('installation_id',sort=False),\n                                total=installation_n):\n    train_data += preprocess_data(user_sample)","2bf627ae":"#train_data = pd.DataFrame(train_data)\n#train_data.head()","a75ef375":"train_data = pd.DataFrame(train_data)\ndel train_agr","4a152b20":"train_data.groupby('accuracy_group').size()","52b5d454":"# process test set, the same that was done with the train set\ntest_data = []\nfor ins_id, user_sample in tqdm(test_agr.groupby('installation_id',sort=False),\n                                total=1000):\n    #print(user_sample.installation_id.iloc[0])\n    test_data.append(preprocess_data(user_sample,train_set = False))\ntest_data = pd.DataFrame(test_data)\n#del test_agr","62638541":"# all_features but 'accuracy_group', that is the label y\nall_features = [x for x in train_data.columns if x not in ['accuracy_group']]\n# categorical feature\ncategorical_features = ['world']","08f867a1":"train_data.head()","99ac92ab":"#object_cols = train_data.columns[train_data.dtypes == 'object']\n#for object_col in object_cols:\n#    train_data[object_col] = train_data[object_col].astype('float')","2f93bc12":"#test_agr[test_agr['type']=='Assessment'].head(30)\n#user_sample = test_agr[test_agr['installation_id']=='12771ee9']\n#user_sample = user_sample.sort_values('timestamp_st')\n#assessment_inst = user_sample[user_sample['type']=='Assessment']\n\n#print(assessment_inst)\n \n#test_agr[test_agr['type']=='Assessment'].iloc[1]['accuracy_group'].isnan()\n#aa['accuracy_group']","da9226f8":"# concatnate train and test data\ntemp_df = pd.concat([train_data[all_features], test_data[all_features]])\n#temp_df = temp_df.drop('day',axis=1)\n\n# encode\nencoder = ce.ordinal.OrdinalEncoder(cols = categorical_features)\ntemp_df = encoder.fit_transform(temp_df)\n#tarain_data = encoder.fit_transform(train_data)\n# dataset\nX, y = temp_df.iloc[:len(train_data),:], train_data['accuracy_group']\n#X, y = train_data[all_features], train_data['accuracy_group']\nX_test = temp_df.iloc[len(train_data):,:]","9680da42":"# Create multiple datasets to create multiple models (not for CV).\nNFOLDS = 5\nfolds = StratifiedKFold(n_splits=NFOLDS, shuffle=True, random_state=42)\n#groups = X.installation_id\n#folds = GroupKFold(n_splits=NFOLDS)\n#X = X.drop('installation_id',axis =1)","7c1fbd91":"# LightGBM\nstart_time = time()\nlgb_models = []\nscores = []\n\nparams = {\n    'n_jobs': -1,\n    'seed': 42,\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n#     'num_iteration': 100,           # add\n    'metric': 'rmse',\n#     'eval_metric': 'cappa',\n    'feature_fraction':0.998495,    # add\n    'bagging_fraction': 0.872417,   # mod 0.8\u2192, = subsample\n    'learning_rate': 0.02,\n    'feature_fraction': 0.9,        #   = colsample_bytree\n    'max_depth': 13,                # mod 10\u2192\n    'num_leaves': 1028,             # mod   # 2^max_depth < num_leaves\n    'min_gain_to_split':0.085502,   # add\n    'min_child_weight':1.087712,    # add\n    'lambda_l1': 1,  \n    'lambda_l2': 1,\n    'verbose': 100,\n}\n\n# Train and make models\nfor fold, (train_ids, val_ids) in enumerate(folds.split(X,y)):\n#for fold, (train_ids, val_ids) in enumerate(folds.split(X,y,groups)):\n    print('\u25cf Fold :', fold+1,'\/',NFOLDS)\n    train_set = lgb.Dataset(X.iloc[train_ids], y.iloc[train_ids],\n                           categorical_feature=categorical_features)\n    val_set = lgb.Dataset(X.iloc[val_ids], y.iloc[val_ids],\n                         categorical_feature=categorical_features)\n    model = lgb.train(params=params,\n                      train_set=train_set,\n                      valid_sets=[train_set, val_set],\n                      num_boost_round=5000,\n                      early_stopping_rounds=100,    # del\n                      verbose_eval=200\n                     )\n    lgb_models.append(model)\n    \nprint('\\nTime:', time() - start_time)","519ce62b":"importance  = pd.DataFrame(model.feature_importance(),index = train_set.feature_name, columns=['importance']).sort_values(by =  'importance',ascending=False)\nimportance[0:50]","c95c826c":"fig, ax = plt.subplots(figsize=(10, 15))\nlgb.plot_importance(model, max_num_features=50, ax=ax, importance_type='gain') # 'gai\u306en'\u4ed6\u306b'split'\u304c\u3042\u308b\u3002","887d223a":"imp = model.feature_importance(importance_type='gain') # importanc\u3092enumpy array\u3067\u53d7\u3051\u53d6\u308b\nth =500\nuse_col = X.columns[imp > th]\nX = X[use_col]\nX_test = X_test[use_col]","91b5c4cd":"# LightGBM\nstart_time = time()\nlgb_models = []\nscores = []\n\nparams = {\n    'n_jobs': -1,\n    'seed': 42,\n    'boosting_type': 'gbdt',\n    'objective': 'regression',\n#     'num_iteration': 100,           # add\n    'metric': 'rmse',\n#     'eval_metric': 'cappa',\n    'feature_fraction':0.998495,    # add\n    'bagging_fraction': 0.872417,   # mod 0.8\u2192, = subsample\n    'learning_rate': 0.02,\n    'feature_fraction': 0.9,        #   = colsample_bytree\n    'max_depth': 13,                # mod 10\u2192\n    'num_leaves': 1028,             # mod   # 2^max_depth < num_leaves\n    'min_gain_to_split':0.085502,   # add\n    'min_child_weight':1.087712,    # add\n    'lambda_l1': 1,  \n    'lambda_l2': 1,\n    'verbose': 100,\n}\n\n# Train and make models\nfor fold, (train_ids, val_ids) in enumerate(folds.split(X,y)):\n#for fold, (train_ids, val_ids) in enumerate(folds.split(X,y,groups)):\n    print('\u25cf Fold :', fold+1,'\/',NFOLDS)\n    train_set = lgb.Dataset(X.iloc[train_ids], y.iloc[train_ids],\n                           categorical_feature=categorical_features)\n    val_set = lgb.Dataset(X.iloc[val_ids], y.iloc[val_ids],\n                         categorical_feature=categorical_features)\n    model = lgb.train(params=params,\n                      train_set=train_set,\n                      valid_sets=[train_set, val_set],\n                      num_boost_round=5000,\n                      early_stopping_rounds=100,    # del\n                      verbose_eval=200\n                     )\n    lgb_models.append(model)\n    \nprint('\\nTime:', time() - start_time)","149b439c":"train_data.head()","15b8cb24":"fig, ax = plt.subplots(figsize=(10, 15))\nlgb.plot_importance(model, max_num_features=50, ax=ax, importance_type='gain') # 'gai\u306en'\u4ed6\u306b'split'\u304c\u3042\u308b\u3002\n#use = test[test['installation_id']=='00abaee7']\n#use[use['type']=='Assessment']","c0ed57e2":"# process test set, the same that was done with the train set\n#installation_n = train['installation_id'].nunique()\n#train_agr = pd.DataFrame()\n#for ins_id, user_sample in tqdm(train.groupby('installation_id',sort=False),\n#                                total=installation_n):\n#    train_agr = train_agr.append(agr_session(user_sample))\n#user_sample = train[train['installation_id']=='0006a69f']\n#train_agr = agr_session(user_sample)","a912f1b8":"# process test set, the same that was done with the train set\n#test_agr = pd.DataFrame()\n#for ins_id, user_sample in tqdm(test.groupby('installation_id',sort=False),\n#                                total=1000):\n#    test_agr = test_agr.append(agr_session(user_sample))","15ed25cb":"#train_data = preprocess_data(user_sample)\n#train_data.head()\n#installation_n = train_agr['installation_id'].nunique()\n#train_data = pd.DataFrame()\n#for ins_id, user_sample in tqdm(train_agr.groupby('installation_id',sort=False),\n#                                total=installation_n):\n#    train_data = train_data.append(preprocess_data(user_sample))","c0bad590":"#test_data = pd.DataFrame()\n#for ins_id, user_sample in tqdm(test_agr.groupby('installation_id',sort=False),\n#                                total=1000):\n#    test_data = test_data.append(preprocess_data(user_sample,False))","f8ae5b49":"# Create multiple datasets to create multiple models (not for CV).\n#NFOLDS = 5\n#folds = StratifiedKFold(n_splits=NFOLDS, shuffle=True, random_state=42)","09ac8b98":"# XGBoost\nstart_time = time()\nxgb_models = []\nscores = []\n\nparams = {\n    'max_depth': 9,                 # 6           # mod 10\u21929\n    'learning_rate': 0.01,          # = eta 0.1: [0,1]\n    'objective': 'reg:linear',                    # add\n    'n_estimators' : 300,           # 100\n    'subsample': 0.6,               # 1, (0,1]    # mod 0.8\u21920.6\n    'colsample_bytree': 1.0,        # 1, (0, 1]   # mod 0.8\u21921.0\n    'gamma': 0.0,                                 # add\n    'min_child_weight': 5,                        # add\n    'seed' : 42,\n}\n\n# Train and make models\nfor fold, (train_ids, val_ids) in enumerate(folds.split(X,y)):\n    print('\u25cf Fold :', fold+1,'\/',NFOLDS)\n    dtrain = xgb.DMatrix(X.iloc[train_ids], y[train_ids])\n    dval = xgb.DMatrix(X.iloc[val_ids], y[val_ids])\n    model = xgb.train(params=params,\n                      dtrain=dtrain,\n                      num_boost_round=5000,\n                      evals=[(dtrain, 'train'), (dval, 'val')],\n                      early_stopping_rounds=100,\n                      verbose_eval=100\n                     )\n    xgb_models.append(model)\n    \nprint('Time:', time() - start_time)","e7c484fd":"# makes the model and set the parameters\ndef make_CatBoost(task_type):\n    model = CatBoostRegressor(\n        iterations=5000,\n        learning_rate=0.02,\n        loss_function='RMSE',\n        random_seed=42,\n        depth=10,                            # add\n        border_count=108,                    # add\n        bagging_temperature=2.348502,        # add\n        task_type=task_type,\n        early_stopping_rounds=200\n    )\n    return model","d2846c7c":"# CatBoost\nstart_time = time()\ncat_models = []\nscores = []\n\n# Train and make models\nfor fold, (train_ids, test_ids) in enumerate(folds.split(X, y)):\n    print('\u25cf Fold :', fold+1,'\/',NFOLDS)\n    model = make_CatBoost(task_type)\n    #model.fit(X.loc[train_ids, all_features], y.loc[train_ids], \n    #          eval_set=(X.loc[test_ids, all_features], y.loc[test_ids]),\n    model.fit(X.loc[train_ids, use_col], y.loc[train_ids], \n              eval_set=(X.loc[test_ids, use_col], y.loc[test_ids]),\n              use_best_model=False,\n              verbose=500,\n              cat_features=categorical_features)    \n    cat_models.append(model)\n    \nprint('Time:', time() - start_time)","d3b1efec":"preds = []\n\n# CatBoost models\nfor model in cat_models:\n    pred = model.predict(X)\n    preds.append(pred)\n    \n# XGBoost models\nfor model in xgb_models:\n    pred = model.predict(xgb.DMatrix(X))\n    pred = pred.flatten()\n    preds.append(pred)\n    \n# LightGBM models\nfor model in lgb_models:\n    pred = model.predict(X,num_iteration=model.best_iteration)\n    pred = pred.reshape(len(X),1).flatten()\n    preds.append(pred)\n\ndf = pd.DataFrame(preds).T\ndf.columns = ['C1','C2','C3','C4','C5',   # CatBoost\n              'X1','X2','X3','X4','X5',   # XGBoost\n              'L1','L2','L3','L4','L5']   # LightGBM","be130b2e":"# Calculate the average value of each model pred\ndf['mean'] = df.mean(axis = 'columns')\ndf.head(10)","bb1986a9":"class OptRounder(object):\n    def __init__(self):\n        self.res_ = []\n        self.coef_ = []\n        \n    def get_res(self):\n        return self.res_\n    \n    # objective function\n    def func(self, coef, X, y):\n        kappa = cohen_kappa_score(self.bincut(coef, X), y,\n                                  weights='quadratic')\n        return -kappa\n\n    def bincut(self, coef, X):\n        return pd.cut(X,\n                      [-np.inf] + list(np.sort(coef)) + [np.inf],\n                      labels = [0, 1, 2, 3])\n        \n    def fit(self, X, y):\n        pfunc = partial(self.func, X=X, y=y)\n        self.res_ = sp.optimize.minimize(fun = pfunc,           # objective func\n                                         x0 = [0.6, 1.5, 2.4],  # initial coef\n                                         method='nelder-mead')  # solver\n        self.coef_ = self.res_.x\n        \n    def predict(self, X, coef):\n        return self.bincut(coef, X)","8a721cef":"optR = OptRounder()\noptR.fit(df['mean'].values.reshape(-1,), y)\nres = optR.get_res()        # Optimized result\n\nprint('\u25cfIterations performed\\t:',res.nit)\nprint('\u25cfOptimized coefficients\\t:',res.x)\nprint('\u25cfCohen Kappa score\\t:',-res.fun)\n\ncoefficients = res.x        # Optimized coefficients","9c82b807":"# final classification\ndf['predict'] = optR.predict(df['mean'].values, coefficients).astype(int)\n\ndf['y'] = y\ndf[['mean','predict','y']].head(10)","19482228":"df[['mean','predict','y']].plot(subplots=True,layout=(1, 3),\n                                figsize=(11, 3),kind='hist')","140568aa":"# binning plot of 'pred' versus 'y'\ndf.plot.hexbin(x='y', y='predict', gridsize=(3,3),\n               sharex=False, title = \"binning 'pred' vs 'y'\")","d2ec1ac1":"preds = []\nfor model in cat_models:        # CatBoost\n    pred = model.predict(X_test)\n    preds.append(pred)\nfor model in xgb_models:        # XGBoost\n    pred = model.predict(xgb.DMatrix(X_test))\n    pred = pred.flatten()\n    preds.append(pred)\nfor model in lgb_models:        # LightGBM\n    pred = model.predict(X_test,num_iteration=model.best_iteration)\n    pred = pred.reshape(len(X_test),1).flatten()\n    preds.append(pred)\ndf_s = pd.DataFrame(preds).T\n\ndf_s['mean'] = df_s.mean(axis = 'columns')\n\n# Classification\ndf_s['pred'] = optR.predict(df_s['mean'].values, coefficients).astype(int)\n\nprint(df_s.shape)\ndf_s[['mean','pred']].head(10)","f15353e6":"df_s[['mean','pred']].plot(subplots=True, layout=(1, 2),\n                           figsize=(7, 3), kind='hist')","02405fd9":"submission = pd.read_csv(os.path.join(DIR,'sample_submission.csv'))\nsubmission['accuracy_group'] = df_s['pred']\nsubmission.head(10)","983ac5f2":"submission.to_csv('submission.csv', index=None)","3dd7426c":"# Convert the raw data into processed features\n#def get_data(user_sample, test_set=False):\n#    '''\n#    user_sample : DataFrame from train\/test group by 'installation_id'\n#    test_set    : related with the labels processing\n#    '''\n    # Constants and parameters declaration\n#    user_assessments = []\n#    last_type = 0\n#    types_count = {'Clip':0, 'Activity':0, 'Assessment':0, 'Game':0}\n#    time_first_activity = float(user_sample['timestamp'].values[0])\n#    time_spent_each_title = {title:0 for title in title_list}\n#    event_code_count = {code:0 for code in event_code_list}\n#    accuracy_groups = {0:0, 1:0, 2:0, 3:0}\n    \n#    accumu_accuracy_group = 0\n#    accumu_accuracy=0\n#    accumu_win_n = 0 \n#    accumu_loss_n = 0 \n#    accumu_actions = 0\n#    counter = 0\n#    durations = []\n    \n    # group by 'game_session'\n#    for i, session in user_sample.groupby('game_session', sort=False):\n        # i      : game_session_id\n        # session: DataFrame from user_sample group by 'game_session'\n#        session_type = session['type'].iloc[0]  # Game\/Assessment\/Activity\/Clip\n#        session_title = session['title'].iloc[0]\n        \n#        if session_type != 'Assessment':\n#            time_spent = int(session['game_time'].iloc[-1] \/ 1000)   # [sec]\n#            time_spent_each_title[num2title[session_title]] += time_spent\n        \n#        if (session_type == 'Assessment') & (test_set or len(session)>1):\n            # search for event_code 4100(4110)\n#            all_4100 = session.query(f'event_code == \\\n#                                         {title2win_code[session_title]}')\n            # numbers of wins and losses\n#            win_n = all_4100['event_data'].str.contains('true').sum()\n#            loss_n = all_4100['event_data'].str.contains('false').sum()\n\n            # init features and then update\n#            features = types_count.copy()\n#            features.update(time_spent_each_title.copy())\n#            features.update(event_code_count.copy())\n#            features['session_title'] = session_title\n#            features['accumu_win_n'] = accumu_win_n\n#            features['accumu_loss_n'] = accumu_loss_n\n#            accumu_win_n += win_n\n#            accumu_loss_n += loss_n\n            \n#            features['day_of_the_week'] = (session['timestamp'].iloc[-1]). \\\n#                                            strftime('%A')    # Mod 2019-11-17\n\n#            if durations == []:\n#                features['duration_mean'] = 0\n#            else:\n#                features['duration_mean'] = np.mean(durations)\n#            durations.append((session.iloc[-1, 2] - session.iloc[0, 2] ).seconds)\n\n            # average of the all accuracy of this player\n#            features['accuracy_ave'] = accumu_accuracy \/ counter \\\n#                                                if counter > 0 else 0\n#            accuracy = win_n \/ (win_n + loss_n) \\\n#                                   if (win_n + loss_n) > 0 else 0\n#            accumu_accuracy += accuracy\n#            if accuracy == 0:\n#                features['accuracy_group'] = 0\n#            elif accuracy == 1:\n#                features['accuracy_group'] = 3\n#            elif accuracy == 0.5:\n#                features['accuracy_group'] = 2\n#            else:\n#                features['accuracy_group'] = 1\n#            features.update(accuracy_groups)\n#            accuracy_groups[features['accuracy_group']] += 1\n            # average of accuracy_groups of this player\n#            features['accuracy_group_ave'] = \\\n#                    accumu_accuracy_group \/ counter if counter > 0 else 0\n#            accumu_accuracy_group += features['accuracy_group']\n            \n            # how many actions the player has done in this game_session\n#            features['accumu_actions'] = accumu_actions\n            \n            # if test_set, all sessions belong to the final dataset\n            # elif train, needs to be passed throught this clausule\n#            if test_set or (win_n + loss_n) > 0:\n#                user_assessments.append(features)\n                \n#            counter += 1\n        \n        # how many actions was made in each event_code\n#        event_codes = Counter(session['event_code'])\n#        for key in event_codes.keys():\n#            event_code_count[key] += event_codes[key]\n\n        # how many actions the player has done\n#        accumu_actions += len(session)\n#        if last_type != session_type:\n#            types_count[session_type] += 1\n#            last_type = session_type\n            \n    # if test_set, only the last assessment must be predicted,\n    # the previous are scraped\n#    if test_set:\n#        return user_assessments[-1]\n#    return user_assessments","5cc77109":"# final classification\n#df['predict'] = optR.predict(df['mean'].values, coefficients).astype(int)\n\n#df['y'] = y\n#df[['mean','predict','y']].head(10)","783a40b3":"#df[['mean','predict','y']].plot(subplots=True,layout=(1, 3),\n#                                figsize=(11, 3),kind='hist')","6957c1af":"# binning plot of 'pred' versus 'y'\n#df.plot.hexbin(x='y', y='predict', gridsize=(3,3),\n#               sharex=False, title = \"binning 'pred' vs 'y'\")","9b5ba079":"#preds = []\n#for model in cat_models:        # CatBoost\n#    pred = model.predict(X_test)\n#    preds.append(pred)\n#for model in xgb_models:        # XGBoost\n#    pred = model.predict(xgb.DMatrix(X_test))\n#    pred = pred.flatten()\n#    preds.append(pred)\n#for model in lgb_models:        # LightGBM\n#    pred = model.predict(X_test,num_iteration=model.best_iteration)\n#    pred = pred.reshape(len(X_test),1).flatten()\n#    preds.append(pred)\n#df_s = pd.DataFrame(preds).T\n\n#df_s['mean'] = df_s.mean(axis = 'columns')\n\n# Classification\n#df_s['pred'] = optR.predict(df_s['mean'].values, coefficients).astype(int)\n\n#print(df_s.shape)\n#df_s[['mean','pred']].head(10)","b5dc98e3":"#df_s[['mean','pred']].plot(subplots=True, layout=(1, 2),\n#                           figsize=(7, 3), kind='hist')","cdb31a40":"#submission = pd.read_csv(os.path.join(DIR,'sample_submission.csv'))\n#submission['accuracy_group'] = df_s['pred']\n#submission.head(10)","f22d7099":"#submission.to_csv('submission.csv', index=None)","7866b08e":"## Step 3 : Optimize Rounding Coefficients\nThe rounding coefficient is optimized using the average value of the prediction results of each model. Optimization uses `scipy.optimize.minimize()`.","0b312b83":"### 1. train","1f76d094":"## Regressors and Classification by Optimal Rounding\n**\u25a0Classification steps**<BR>\n**Step 1** Create Regressor Models : Create multiple train_datasets using `kFold` and create a regression model from each dataset. I used ** CatBoost **, ** XGBoost **, ** LightGBM **.<BR>\n**Step 2** Predict each Model<BR>\n**Step 3** Optimize Rounding Coefficients : The rounding coefficient is optimized using the average value of the prediction results of each model. Optimization uses `scipy.optimize.minimize()`.<BR>\n**Step 4** Final Classification","e99e982a":"### 2. train_labels","b26fcd62":"## Step 1 : Create Regressor Models\nCreate multiple train_datasets using `kFold` and create a regression model from each dataset. I used ** CatBoost **, ** XGBoost **, ** LightGBM **.","95511a5d":"### - CatBoost","a29d760f":"## Observe the data","6986281f":"### -XGBoost","00bde3ce":"## Step 4 : Final Classification","9a00ec5b":"### 4. test","4ee146f9":"## Step 2 : Predict each Model","1c952e2f":"## Make submission","daf07dfc":"## Compile data\nBased on several kernels\n- Hosseinali: https:\/\/www.kaggle.com\/mhviraf\/a-new-baseline-for-dsb-2019-catboost-model\n- Bruno Aquino: https:\/\/www.kaggle.com\/braquino\/catboost-some-more-features","d891fea9":"### 3. specs"}}