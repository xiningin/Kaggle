{"cell_type":{"dbc70cf9":"code","5572e907":"code","3f5dc001":"code","67b4d0e1":"code","37c5de71":"code","0b328f28":"code","86c20d38":"code","98da4825":"code","fe8f3336":"code","ea642107":"code","0a0d185c":"code","adc98160":"code","ecbfed46":"code","c11c53d5":"code","8edac580":"code","6075ba0e":"code","67940818":"code","54e699b9":"code","c62da92a":"markdown","4b707451":"markdown","08e9f027":"markdown","9db69048":"markdown","c8d69b82":"markdown","bbe5dc19":"markdown","41ad2e94":"markdown","f7de6ea1":"markdown","bfca98a2":"markdown","629aade9":"markdown","e862d9ac":"markdown"},"source":{"dbc70cf9":"import numpy as np\nimport pandas as pd\nimport matplotlib.pylab as plt\nimport seaborn as sns\nfrom itertools import cycle\n\nplt.style.use('ggplot')\ncolor_pal = [x['color'] for x in plt.rcParams['axes.prop_cycle']]\ncolor_cycle = cycle(plt.rcParams['axes.prop_cycle'].by_key()['color'])","5572e907":"!ls -GFlash ..\/input\/liverpool-ion-switching\/","3f5dc001":"train = pd.read_csv('..\/input\/liverpool-ion-switching\/train.csv')\ntest = pd.read_csv('..\/input\/liverpool-ion-switching\/test.csv')\nss = pd.read_csv('..\/input\/liverpool-ion-switching\/sample_submission.csv')","67b4d0e1":"def color_negative_red(val):\n    \"\"\"\n    Takes a scalar and returns a string with\n    the css property `'color: red'` for negative\n    strings, black otherwise.\n    \"\"\"\n    color = 'red' if val < 0 else 'black'\n    return 'color: %s' % color","37c5de71":"# Training\ntrain.describe() \\\n    .T.round(4) \\\n    .style \\\n    .applymap(color_negative_red)","0b328f28":"# Test\ntest.describe() \\\n    .T.round(4) \\\n    .style \\\n    .applymap(color_negative_red)","86c20d38":"train['batch'] = (train.index \/\/ 500_000) + 1","98da4825":"fig, axs = plt.subplots(10, 2, figsize=(15, 30))\naxs = axs.flatten()\ni = 0\nfor b, d in train.groupby('batch'):    \n    d.set_index('time')['signal'].plot(style='.',\n                                       title=f'train batch {b:0.0f} - signal',\n                                       ax=axs[i],\n                                       alpha=0.2,\n                                      color=next(color_cycle))\n    d.set_index('time')['open_channels'].plot(style='.',\n                                              title=f'train batch {b:0.0f} - open_channels',\n                                              ax=axs[i+1],\n                                              alpha=0.5,\n                                      color=next(color_cycle))\n    i += 2\n#     break\nplt.tight_layout()","fe8f3336":"fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))\ntrain.loc[510000:520000].set_index('time')['signal'].plot(style='.',\n                                   title=f'train - close look - signal',\n                                   ax=ax1,\n                                   alpha=0.2,\n                                  color=next(color_cycle))\ntrain.loc[510000:520000].set_index('time')['open_channels'].plot(style='.',\n                                          title=f'train - close look - open_channels',\n                                          ax=ax2,\n                                  color=next(color_cycle))\nplt.show()","ea642107":"ax = train.groupby('open_channels') \\\n    .count()['time'] \\\n    .plot(figsize=(15, 5),\n          kind='bar',\n          title='Count of Target (Open Channels) in Training Set',\n          color=color_pal[0])\nplt.show()","0a0d185c":"train['signal'].plot(kind='hist',\n                     figsize=(15, 5),\n                     bins=55, label='train', alpha=0.5)\ntest['signal'].plot(kind='hist',\n                    bins=55,\n                    label='test',\n                    alpha=0.5,\n                    title='Signal distribution in train vs test')\nplt.legend()\nplt.show()","adc98160":"fig, axs = plt.subplots(4, 3, figsize=(15, 12))\naxs = axs.flat\nidx = 0\nfor i, d in train.groupby('open_channels'):\n    coloridx = idx\n    if idx > 6:\n        coloridx = idx - 6\n    d['signal'].plot(kind='hist',\n                     ax=axs[idx],\n                     title=f'Distribution of Signal for {i} Open Channels',\n                     bins=50, \n                    color=next(color_cycle))\n    idx += 1\nplt.tight_layout()","ecbfed46":"for i, d in train.groupby('open_channels'):\n    coloridx = idx\n    if idx > 6:\n        coloridx = idx - 6\n    d['signal'].plot(kind='hist',\n                     title=f'Distribution of Signal for {i} Open Channels',\n                     bins=50, \n                     figsize=(15, 5),\n                     alpha=0.5,\n                     color=next(color_cycle),\n                     label=i)\nplt.legend()\nplt.show()","c11c53d5":"fig, axs = plt.subplots(5, 2, figsize=(15, 20))\naxs = axs.flatten()\ni = 0\nfor b, d in train.groupby('batch'):\n    sns.violinplot(x='open_channels', y='signal', data=d, ax=axs[i])\n    axs[i].set_title(f'Batch {b:0.0f}')\n    i += 1\nplt.tight_layout()","8edac580":"test['batch'] = np.nan\ntest.loc[:500000, 'batch'] = 1 \ntest.loc[500000:500000*2, 'batch'] = 2\ntest.loc[500000*2:500000*3, 'batch'] = 3\ntest.loc[500000*3:500000*4, 'batch'] = 4","6075ba0e":"fig, axs = plt.subplots(2, 2, figsize=(15, 10))\naxs = axs.flatten()\ni = 0\nfor b, d in test.groupby('batch'):    \n    d.set_index('time')['signal'].plot(style='.',\n                                       title=f'test set batch {b:0.0f} - signal',\n                                       ax=axs[i],\n                                       alpha=0.2,\n                                      color=next(color_cycle))\n    i += 1\nplt.tight_layout()","67940818":"test['batch2'] = (test.index \/\/ 100_000) + 1","54e699b9":"fig, axs = plt.subplots(10, 2, figsize=(15, 30))\naxs = axs.flatten()\ni = 0\nfor b, d in test.groupby('batch2'):    \n    d.set_index('time')['signal'].plot(style='.',\n                                       title=f'test set batch {b:0.0f} - signal',\n                                       ax=axs[i],\n                                       alpha=0.2,\n                                      color=next(color_cycle))\n    i += 1\nplt.tight_layout()","c62da92a":"## Test batches may be smaller?","4b707451":"## Plotting the signal and open_channels for each \"batch\"","08e9f027":"# Test Data Signal Attributes\n- The test day only has 4 \"batches\"","9db69048":"## Distribution of our target \"Open Channels\"","c8d69b82":"# Viewing Channels vs Signal by batch.","bbe5dc19":"## Look at the distribution of \"Signal\" for different number of open channels.","41ad2e94":"`#smalldata`\n(hashtag \"small data\") - the training and test set are 87MB and 32MB respectively!","f7de6ea1":"## Data\nIn this competition, you will be predicting the number of open_channels present, based on electrophysiological signal data.\n\n**IMPORTANT: While the time series appears continuous, the data is from discrete batches of 50 seconds long 10 kHz samples (500,000 rows per batch). In other words, the data from 0.0001 - 50.0000 is a different batch than 50.0001 - 100.0000, and thus discontinuous between 50.0000 and 50.0001.**","bfca98a2":"## Training \"Batch\" of 500,000 rows\n- Total training size is 5000000, so we can think of them in terms of 10 \"batches\"","629aade9":"# Liverpool Data EDA\n\nIn this competition, you\u2019ll use ion channel data to better model automatic identification methods. If successful, you\u2019ll be able to detect individual ion channel events in noisy raw signals. The data is simulated and injected with real world noise to emulate what scientists observe in laboratory experiments.\n![](https:\/\/www.nature.com\/scitable\/content\/ne0000\/ne0000\/ne0000\/ne0000\/14707004\/U4CP3-1_IonChannel_ksm.jpg)","e862d9ac":"## Closer look at signal\/channels"}}