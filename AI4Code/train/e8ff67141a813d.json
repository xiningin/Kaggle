{"cell_type":{"3dd25e9e":"code","43d5a977":"code","7a42a157":"code","bc2e872e":"code","b3bcc5fb":"code","f67cc9d5":"code","73a3c788":"code","a0433f6c":"code","e2900c55":"code","9eb41776":"code","c490b57a":"code","00f13850":"code","1232bf47":"markdown","4ff9981a":"markdown","004352ae":"markdown","c67d7836":"markdown","c634835e":"markdown","0b9315dc":"markdown","b91bc63b":"markdown"},"source":{"3dd25e9e":"pip install rdflib","43d5a977":"pip install common","7a42a157":"# Install necessary Python pakcages\n# rdflib: RDF composition and querying with SPARQL in Python.\nfrom rdflib import RDFS, RDF, Namespace, Graph, URIRef, Literal\n\nfrom common import *","bc2e872e":"import json\nimport pandas as pd\nimport re","b3bcc5fb":"# Load knowledge for the conversion.\nwith open('..\/input\/buildsys2017samplebuilding\/re_dict2.json', 'r') as fp:\n    re_dict = json.load(fp)\nequip_order = ['AHU', 'Return_Fan', 'Supply_Fan']\nwith open('..\/input\/buildsys2017samplebuilding\/re_dict2.json', 'r') as fp:\n    zone_room_map = json.load(fp)\n    \n# Load raw data\ndf = pd.read_csv('..\/input\/buildsys2017samplebuilding\/brick_sample_building_raw.csv')","f67cc9d5":"# Consruct knowledge from Brick schema\n\nbg = Graph()\nbg.parse('..\/input\/buildsys2017samplebuilding\/Brick.ttl', format='turtle') # Load Brick schema.\nsubclasses_query = \"\"\"\nPREFIX brick: <https:\/\/brickschema.org\/schema\/1.0.1\/Brick#>\nselect ?tagset where {{\n?tagset rdfs:subClassOf+ brick:{0}.\n}}\n\"\"\"\npoint_query = subclasses_query.format('Point')\nequip_query = subclasses_query.format('Equipment')\nloc_query = subclasses_query.format('Location')\npoints = [str(row[0]).split('#')[-1] for row in bg.query(point_query)]\nequips = [str(row[0]).split('#')[-1] for row in bg.query(equip_query)]\nlocs = [str(row[0]).split('#')[-1] for row in bg.query(loc_query)]\n\n# Cleanup rules\nequips = [equip for equip in equips if \\\n          not 'Command' in equip and\n          not 'Sensor' in equip and\n          not 'Status' in equip and\n          not 'Alarm' in equip\n         ]","73a3c788":"g = Graph() # Initialize a graph\nRDFS # predefined namespace as 'http:\/\/www.w3.org\/2000\/01\/rdf-schema#'\nRDF # predefined namespace as 'http:\/\/www.w3.org\/1999\/02\/22-rdf-syntax-ns#'\nBRICK = Namespace('https:\/\/brickschema.org\/schema\/1.0.1\/Brick#')\nBF = Namespace('https:\/\/brickschema.org\/schema\/1.0.1\/BrickFrame#')\nEX = Namespace('http:\/\/example.com\/#')\ng.bind('ex', EX)\ng.bind('brick', BRICK)\ng.bind('bf', BF)\ng.bind('rdfs', RDFS)\ng.bind('rdf', RDF)","a0433f6c":"for row in df.iterrows():\n    vendor_name = row[1]['Vendor Given Name']\n    uuid = row[1]['uuid']\n    ############# Parsing Phase\n    # Extract all entities in vendor_name\n    entity_dict = dict()\n    raw_words = vendor_name.split('.') # This building uses '.' as a delimiter but not always it's comprehensive.\n    \n    # split more if needed\n    words = []\n    for word in raw_words:\n        if 'SF' in word or 'RF' in word:\n            words += word.split('-')\n        else:\n            words.append(word)\n    # Apply RE rules to detect tagsets.\n    for word in words:\n        for key, tagset in re_dict.items():\n            if re.findall(key, word):\n                if tagset in points:\n                    entity_dict[vendor_name] = tagset\n                else:\n                    entity_dict[word] = tagset # We will use a word as an entity name.\n    \n    ############# Add Brick Relationships\n    # Add instance relationships\n    for entity, tagset in entity_dict.items():\n        g.add((EX[entity], RDF['type'], BRICK[tagset]))\n    \n    # Add Location <-> Others\n    ## Find all location entities\n    loc_entities = list()\n    for entity, tagset in entity_dict.items():\n        if tagset in locs:\n            loc_entities.append(entity)\n    ## Assign hasLocation relationships to all non-location entities with the location entities.\n    for entity, tagset in entity_dict.items():\n        if tagset not in locs:\n            for loc_entity in loc_entities:\n                g.add((EX[entity], BF['hasLocation'], EX[loc_entity]))\n    \n    # Zone corresponds to a VAV.\n    vav_entity = None\n    for entity, tagset in entity_dict.items():\n        if tagset == 'HVAC_Zone':\n            vav_entity = 'VAV_' + entity\n            g.add((EX[vav_entity], RDF['type'], BRICK['VAV']))\n            g.add((EX[vav_entity], BF['feeds'], EX[entity]))\n    if vav_entity:\n        entity_dict[vav_entity] = 'VAV'\n                \n    # Add Equip <-> Point\n    ## Find all equip entities\n    equip_entities = list()\n    for entity, tagset in entity_dict.items():\n        if tagset in equips:\n            equip_entities.append(entity)\n    ## Assign isPointOf relationships to all Point entities \n    for entity, tagset in entity_dict.items():\n        if tagset in points:\n            for equip_entity in equip_entities:\n                g.add((EX[entity], BF['isPointOf'], EX[equip_entity]))\n    ## Add inclusive relationships among equipments\n    #if len(equip_entities) > 1:\n    #    rank_equip_list = [(equip, equip_orders.index(equip))]\n    #    sorted(equip_entities)\n    \n    # Add UUID\n    for entity, tagset in entity_dict.items():\n        if tagset in points:\n            g.add((EX[entity], BRICK['hasUuid'], Literal(str(uuid))))","e2900c55":"# Add zone-room inclusive relationships\nfor zone, rooms in zone_room_map.items():\n    for room in rooms:\n        g.add((EX[room], RDF['type'], BRICK['Room']))\n        g.add((EX[room], BF['isPartOf'], EX[zone]))\n        \n# The AHU feeds all VAVs\n## find VAVs.\nres = g.query(\"select ?vav where {?vav a <https:\/\/brickschema.org\/schema\/1.0.1\/Brick#VAV>}\")\nvavs = [str(row[0]).split('#')[-1] for row in res]\n## Add feeds relationship\nfor vav in vavs:\n    g.add((EX['AH1'], BF['feeds'], EX[vav]))","9eb41776":"try:\n    from IPython.display import display, Markdown\nexcept:\n    pass\n\ndef is_notebook():\n    try:\n        shell = get_ipython().__class__.__name__\n        if shell == 'ZMQInteractiveShell':\n            return True   # Jupyter notebook or qtconsole\n        elif shell == 'TerminalInteractiveShell':\n            return False  # Terminal running IPython\n        else:\n            return False  # Other type (?)\n    except NameError:\n        return False      # Probably standard Python interpreter\n\ndef print_graph(gr):\n    g_str = gr.serialize(format='turtle')#.decode('utf-8')\n    new_g_str = ''\n    for line in g_str.split('\\n'):\n        if 'prefix' not in line:\n            new_g_str += line + '\\n'\n    if is_notebook():\n        display(Markdown('```turtle\\n' + new_g_str + '\\n```'))\n    else:\n        print(g_str)","c490b57a":"print_graph(g)","00f13850":"#g.serialize('..\/input\/buildsys2017samplebuilding\/sample_building.ttl', format='turtle')\n\ng_sample=g.serialize(format='turtle')\ng_sample","1232bf47":"### Conversion Rules (for this building)\n1. A metadata is the name of the data point.\n2. Implicit Relationships:\n  - When a location is found, every other entitiy hasLocation the location.\n  - When equipment is is found, the point isPointOf the equipment.\n  - When multiple equipment is found, their hierarchy is assumed. In AHU-SF, SF isPartOf AHU. Same for AHU-RF.\n  - When HVAC Zone is found, there is a corresponding VAV.","4ff9981a":"### Helper functions","004352ae":"Setting up the Graph format for Brick (general)","c67d7836":"Regular expression recognition using re_dict","c634835e":"Setting up the Graph format for Brick conversion","0b9315dc":"## BRICK Tutorial at BuildSys 2017 led by Jason Koh and Gabe Fierro.\n\nhttps:\/\/github.com\/BuildSysUniformMetadata\/brick-tutorial-buildsys2017\n- with minor modifications","b91bc63b":"'re_dict2.json' contains the translation dictionary for the abbreviations of brick_sample_building_raw.csv"}}