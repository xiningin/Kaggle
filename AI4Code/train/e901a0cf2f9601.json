{"cell_type":{"5eba58d8":"code","f99c212c":"code","6faf9ee9":"code","3a9ea3f1":"code","c0fd046a":"code","e4fdb86a":"code","41ab7d5f":"code","e9207122":"markdown","ff25e7bf":"markdown","bceefda9":"markdown","69cbed90":"markdown","97808dfd":"markdown","c5805649":"markdown","c5c6a989":"markdown","a1d10902":"markdown","2b2e860d":"markdown"},"source":{"5eba58d8":"def should_hit(player_total, dealer_card_val, player_aces):\n    \"\"\"Return True if the player should hit (request another card) given the current game\n    state, or False if the player should stay. player_aces is the number of aces the player has.\n    \"\"\"\n    return False","f99c212c":"# SETUP. You don't need to worry for now about what this code does or how it works. \n# If you're curious about the code, it's available under an open source license at https:\/\/github.com\/Kaggle\/learntools\/\nfrom learntools.core import binder; binder.bind(globals())\nfrom learntools.python.ex3 import q7 as blackjack\nprint('Setup complete.')","6faf9ee9":"blackjack.simulate_one_game()","3a9ea3f1":"blackjack.simulate(n_games=50000)","c0fd046a":"all_states = [True, False, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, (10, True), (9, True), (8, True), (7, True), (6, True), (5, True), (4, True), (3, True), (2, True), (1, True), (10, False), (9, False), (8, False), (7, False), (6, False), (5, False), (4, False), (3, False), (2, False)]\nfinal_states = [21, 0, 20, 19, 18, 17] #1-17 are essentially equivalent as a FINAL state\nall_dealer_states = all_states[21:]#Dealer states in the player section of the game can only be among the last ten\n#The probability of one card achieving a certain score.\n#Note that Ace is counted as 1 and 11 both once if ace_one is false\n#However when ace_one is True then Ace has to be 1\ndef one_card_score_prob(score, ace_one = True, existing_list = None):\n    if score == 10:\n        return 4\/13\n    if score >= 1 and score <= 9:\n        return 1\/13\n    if score == 11 and ace_one == False:\n        return 1\/13\n    return 0\n#Add a card to an existing score (the reason why we have a list is that if there exists at least one ace it is counted as 1 and 11)\n#If we are adding a score to a score_list with two elements such that the second one is beyond 21 we return the first result only\n#In the input 1 represents ace\ndef add_card(state, extra_score):\n    if isinstance(state, int): #At least 11\n        score = state + extra_score\n        if score > 21:\n            return False\n        elif score == 21:\n            return True\n        else:\n            return score\n    if isinstance(state, bool): #True or False, shouldn't appear but just in case..\n        return state\n    (score, ace_ambi) = state #Tuple, that means score is at most 10\n    score = score + extra_score\n    if ace_ambi == False: #No ace or aces aren't ambiguous\n        if extra_score != 1: #Non-ace card\n            if score >= 11: #Can't be 21 or above\n                return score\n            else:\n                return score, False\n        else:#Ace\n            if score == 11: #Blackjack\n                return True\n            elif score > 11: #Because it can't be 21 or above\n                return score\n            else:\n                return score, True\n    else: #Has ambiguous ace\n        if score == 11: #Blackjack\n            return True\n        elif score > 11: #Becaue it can't be above 21\n            return score\n        else:\n            return score, True\n#Convert states to numbers. Busting gets 0. As for ambiguous aced cases we choose the higher ones.\ndef state_to_num(state):\n    if state is True:\n        return 21\n    if state is False:\n        return 0\n    if isinstance(state, int):\n        num = state\n    else:\n        (num, aced) = state\n        if aced is True:\n            num = num + 10\n    return num\n#Convert a state to its final state\ndef finalize(state):\n    num = state_to_num(state)\n    if num >= 1 and num < 17:\n        return 17\n    return num\ndef is_player_larger(player_state, dealer_state):\n    return state_to_num(player_state) > state_to_num(dealer_state)\ndef is_player_larger_num(player_state, dealer_state):\n    if state_to_num(player_state) > state_to_num(dealer_state):\n        return 1\n    return 0\ndef can_be_final(state):\n    if state is True or state is False:\n        return True\n    if isinstance(state, int):\n        if state >= 17:\n            return True\n        else:\n            return False\n    (num, aced) = state\n    if aced is True and num >= 7:\n        return True\n    return False\ndef must_be_final(state):\n    if state is True or state is False:\n        return True\n    if isinstance(state, int):\n        if state >= 17:\n            return True\n        else:\n            return False\n    return False\ndef be_optionally_final(state):\n    if isinstance(state, tuple):\n        (num, aced) = state\n        if aced is True and num >= 7:\n            return True\n        else:\n            return False\n    return False\ndef gen_dealer_loss_prob_tab():\n    states_amount = len(all_states)\n    fs_amount = len(final_states)\n    table = [[] for k in range(states_amount)]\n    for i in range(states_amount):\n        dealer_state = all_states[i]\n        for j in range(fs_amount):\n            player_fs = final_states[j]\n            #print(f'Now we are dealing with {dealer_state} {player_fs}!')\n            if i == 0:#Dealer gets Blackjack\n                table[i].append(0)\n                continue\n            if j == 1:#Player busts\n                table[i].append(0)\n                continue\n            if i == 1: # If player busts they lose regardless of whether the dealer busts which is why the two if statements must be in this order\n                table[i].append(1)\n                continue\n            if i <= 5: #If dealer_state must be final\n                if player_fs > dealer_state:#dealer_state must be a number in this case\n                    table[i].append(1)\n                else:\n                    table[i].append(0)\n                continue\n            if i >= 12 and i <= 15: #Optionally final\n                if 32 - i >= player_fs: #Otherwise it must not be interpreted using the higher value\n                    table[i].append(0)\n                    continue\n            #Now the free cases are done. Hard choices are mandatory\n            prob = 0\n            for k in range(1, 11):\n                new_dealer_state = add_card(dealer_state, k)\n                new_dealer_index = all_states.index(new_dealer_state)\n                #print(f'The new dealer index is {new_dealer_index} and the new dealer state is {new_dealer_state}')\n                conditional_dl_prob = table[new_dealer_index][j]\n                prob = prob + one_card_score_prob(k) * conditional_dl_prob\n            table[i].append(prob)\n            #print(prob)\n    return table\nd_table = gen_dealer_loss_prob_tab()\ndef gen_hitting_matrix(dealer_table):\n    states_amount = len(all_states)\n    ds_amount = len(all_dealer_states)\n    #first_ds_index = 21\n    neg_table = [[] for k in range(states_amount)]\n    pos_table = [[] for k in range(states_amount)]\n    choice_table = [[] for k in range(states_amount)]\n    for i in range(states_amount):\n        player_state = all_states[i] #Notice the ordering!\n        neg_fs = finalize(player_state)\n        for j in range(ds_amount):\n            dealer_state = all_dealer_states[j]\n            #print(f'Now we are dealing with {player_state} {dealer_state}!')\n            index1 = all_states.index(player_state)\n            findex1 = final_states.index(neg_fs)\n            index2 = 21 + j\n            neg_prob = dealer_table[index2][findex1] #Probability of player win without hitting\n            neg_table[i].append(neg_prob)\n            #print(f'The negative prob is {neg_prob}')\n            pos_prob = 0\n            if i == 0: #True\n                pos_table[i].append(neg_prob)\n                choice_table[i].append(False)\n                continue\n            if i == 1: #False\n                pos_table[i].append(neg_prob)\n                choice_table[i].append(False)\n                continue\n            for k in range(1, 11):\n                new_player_state = add_card(player_state, k)\n                new_player_index = all_states.index(new_player_state)\n                #print(f'The new player index is {new_player_index} and the new player state is {new_player_state}')\n                cond_neg_dl_prob = neg_table[new_player_index][j]\n                cond_pos_dl_prob = pos_table[new_player_index][j]\n                cond_max_dl_prob = max(cond_neg_dl_prob, cond_pos_dl_prob)\n                pos_prob = pos_prob + one_card_score_prob(k) * cond_max_dl_prob\n            #print(f'The positive prob is {pos_prob}')\n            pos_table[i].append(pos_prob)\n            if pos_prob > neg_prob:\n                choice_table[i].append(True)\n                #print('Verdict: True')\n            else:\n                choice_table[i].append(False)\n                #print('Verdict: False')\n    return choice_table\nc_table = gen_hitting_matrix(d_table)\n","e4fdb86a":"def should_hit(player_total, dealer_card_val, player_aces):\n    if player_total > 21: #bust\n        return False\n    if player_total == 21: #blackjack\n        return False\n    if player_total <= 10: #Small Unaced\n        player_state = (player_total, False)\n    elif player_aces > 0: #Aced\n        player_state = (player_total - 10, True)\n    else: #Unaced\n        player_state = player_total\n    if dealer_card_val is not 11:#Unaced\n        dealer_state = (dealer_card_val, False)\n    else:\n        dealer_state = (1, True)\n    index_player = all_states.index(player_state)\n    index_dealer = all_dealer_states.index(dealer_state)\n    return c_table[index_player][index_dealer]","41ab7d5f":"blackjack.simulate(n_games=50000)","e9207122":"Once you have run the set-up code. You can see the action for a single game of blackjack with the following line:","ff25e7bf":"# Intro\n\nReady for a quick test of your logic and programming skills?\n\nIn today's micro-challenge, you will write the logic for a blackjack playing program.  Our dealer will test your program by playing 50,000 hands of blackjack. You'll see how frequently your program won, and you can discuss how your approach stacks up against others in the challenge.\n\n![Blackjack](http:\/\/www.hightechgambling.com\/sites\/default\/files\/styles\/large\/public\/casino\/table_games\/blackjack.jpg)","bceefda9":"---\nThis exercise is from the **[Python Course](https:\/\/www.kaggle.com\/Learn\/python)** on Kaggle Learn.\n\nCheck out **[Kaggle Learn](https:\/\/www.kaggle.com\/Learn)**  for more instruction and fun exercises.","69cbed90":"# Your Turn\n\nWrite your own `should_hit` function in the cell below. Then run the cell and see how your agent did in repeated play.","97808dfd":"# Blackjack Rules\n\nWe'll use a slightly simplified version of blackjack (aka twenty-one). In this version, there is one player (who you'll control) and a dealer. Play proceeds as follows:\n\n- The player is dealt two face-up cards. The dealer is dealt one face-up card.\n- The player may ask to be dealt another card ('hit') as many times as they wish. If the sum of their cards exceeds 21, they lose the round immediately.\n- The dealer then deals additional cards to himself until either:\n    - The sum of the dealer's cards exceeds 21, in which case the player wins the round, or\n    - The sum of the dealer's cards is greater than or equal to 17. If the player's total is greater than the dealer's, the player wins. Otherwise, the dealer wins (even in case of a tie).\n\nWhen calculating the sum of cards, Jack, Queen, and King count for 10. Aces can count as 1 or 11 (when referring to a player's \"total\" above, we mean the largest total that can be made without exceeding 21. So e.g. A+8 = 19, A+8+8 = 17)\n\n# The Blackjack Player\nYou'll write a function representing the player's decision-making strategy. Here is a simple (though unintelligent) example.\n\n**Run this code cell** so you can see simulation results below using the logic of never taking a new card.","c5805649":"# Discuss Your Results\n\nHow high can you get your win rate? We have a [discussion thread](https:\/\/www.kaggle.com\/learn-forum\/58735#latest-348767) to discuss your results. Or if you think you've done well, reply to our [Challenge tweet](https:\/\/twitter.com\/kaggle) to let us know.","c5c6a989":"We'll simulate games between your player agent and our own dealer agent by calling your function. So it must use the name `should_hit`","a1d10902":"# The Blackjack Simulator\n\nRun the cell below to set up our simulator environment:","2b2e860d":"You can see how your player does in a sample of 50,000 games with the following command:"}}