{"cell_type":{"0ddefe90":"code","8a78df79":"code","0c5e49e1":"code","de325bc7":"code","a8b0dd9e":"code","d8b03fe6":"code","61d8242c":"code","0189d433":"code","5d19eeab":"code","eb2a2932":"code","181e638c":"code","465eac5e":"code","725aef08":"code","237e2ed2":"code","568064fb":"code","d30c8241":"code","43a3d751":"code","bda0072d":"code","6fba13b7":"code","a21519a7":"code","86fd90bd":"code","63513233":"code","9fc202d8":"code","28d58e41":"code","407b659a":"code","b63b98e3":"code","12d0a54b":"code","348c0856":"code","403e55c3":"code","13c8c524":"code","2b77d460":"markdown","f436fb1d":"markdown","8301a542":"markdown","345fb9ea":"markdown","d93e9cae":"markdown","f0b85cf5":"markdown","c5a6491f":"markdown","853efef3":"markdown","acb13f30":"markdown","b0d63dd4":"markdown","4e1ed970":"markdown","22d826e3":"markdown","46fa59c4":"markdown","64e89d10":"markdown","89b93159":"markdown","2e84ea9d":"markdown","458685ed":"markdown","f9aa9d3d":"markdown"},"source":{"0ddefe90":"import math\nfrom random import randint, randrange, random, shuffle\nimport torch\nfrom torch import tensor\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ntorch.set_printoptions(precision=5)","8a78df79":"def read_csv(filename, size, str_to_val):\n    res = torch.zeros((size, size))\n    with open(filename, 'r') as f:\n        for i, line in enumerate(f.readlines()):\n            if i > 0:\n                cell_str, cell_value_str = line.strip().split(',')\n                y_str, x_str = cell_str.split('_')\n                res[int(y_str), int(x_str)] = str_to_val(cell_value_str)\n    return res","0c5e49e1":"def save_csv(mat, filename):\n    with open(filename, 'w') as f:\n        f.write(\"pair,sim\\n\")\n        for i in range(mat.shape[0]):\n            for j in range(mat.shape[1]):\n                if i < j:\n                    f.write(f'{i}_{j},{mat[i][j]}\\n')","de325bc7":"n=372\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\n#device = 'cpu'","a8b0dd9e":"jac_mat = read_csv('jaccard.csv', n, float).to(device)\njac_mat","d8b03fe6":"jac_sym = jac_mat +  jac_mat.T + torch.eye(n).to(device)\njac_sym","61d8242c":"answer = read_csv('answer.csv', n, int).to(device, int)\nanswer","0189d433":"nan_tensor = torch.tensor(10.0).to(device) # 0.056\neps = 1e-4\n\ndef round_n_decimals(t,  n):\n    return torch.round(t * 10**n) \/ 10**n\n\ndef jaccard(mat):\n    rev_mat = 1 - mat\n    both = mat @ mat.T\n    both_null = rev_mat @ rev_mat.T\n    either = n - both_null\n    return torch.where(either == 0, nan_tensor, round_n_decimals(both \/ either, 5))","5d19eeab":"eval_mask = torch.zeros((n, n), dtype=int).to(device)\nfor i in range(n):\n    eval_mask[i, i+1:] = 1\neval_mask","eb2a2932":"nan_tensor = torch.tensor(0.056).to(device)\n\ndef squared_inc_row(m, m2, i, row):\n    next_m = m.clone()\n    next_m[i] += row\n    \n    m_row = m[:, i:i+1] * row\n    row_m_row = torch.matmul(row, next_m)\n    \n    m2 += m_row\n    m2[i] += row_m_row\n    m.copy_(next_m)\n    \ndef squared_inc_col(m, m2, i, col):\n    next_m = m.clone()\n    next_m[:, i] += col\n    \n    col_m = col.view(-1, 1) * m[i:i+1, :]\n    m_col_col = torch.matmul(next_m, col)\n    \n    m2 += col_m\n    m2[:, i] += m_col_col\n    m.copy_(next_m)\n\nclass Model:\n    def __init__(self, a, a2, inv, inv2):\n        self.a = a\n        self.a2 = a2\n        self.inv = inv\n        self.inv2 = inv2\n        \n    def clone(self):\n        return Model(self.a.clone(), self.a2.clone(), self.inv.clone(), self.inv2.clone())\n        \n    def eval(self):\n        either = n - self.inv2\n        return ((torch.where(either == 0, nan_tensor, self.a2 \/ either) - jac_mat).abs() * eval_mask).sum()\n    \n    def inc_row(self, i, row):\n        squared_inc_row(self.a, self.a2, i, row)\n        squared_inc_row(self.inv, self.inv2, i, -row)\n        \n    def inc_col(self, i, col):\n        squared_inc_col(self.a, self.a2, i, col)\n        squared_inc_col(self.inv, self.inv2, i, -col)\n        \n    def inc_sym(self, i, vec):\n        self.inc_row(i, vec)\n        vec[i] = 0\n        self.inc_col(i, vec)\n        \n    def fix_dependencies(self):\n        self.a2 = self.a @ self.a\n        self.inv = 1 - self.a\n        self.inv2 = self.inv @ self.inv\n    \ndef make_model(a):\n    inv = 1 - a\n    return Model(a, a @ a, inv, inv @ inv)\n\ndef random_guess():\n    a = torch.randint(2, size=(n, n))\n    for y in range(n):\n        for x in range(n):\n            if y > x:\n                a[y, x] = a[x, y]\n    return make_model(a.to(device, torch.float32))","181e638c":"m = make_model(torch.randint(2, size=(n, n)).to(device, torch.float32))\ntest_row = torch.randint(2, size=(n,)).to(device, torch.float32)\n\nm.inc_sym(8, test_row)\nprint(m.eval())\nm.fix_dependencies()\nprint(m.eval())","465eac5e":"test_m = make_model(torch.randint(2, size=(n, n)).to(device, torch.float32))\ntests = 1000\n\nfor ti in range(tests):\n    i = randrange(n)\n    rand_row = torch.randint(2, size=(n,)).to(device, torch.float32)\n    test_m.inc_row(i, rand_row)\n    \n    i = randrange(n)\n    rand_col = torch.randint(2, size=(n,)).to(device, torch.float32)\n    test_m.inc_col(i, rand_col)\n    \nfast_score = test_m.eval()\ntest_m.fix_dependencies()\ncorrect_score = test_m.eval()\n\nprint(f'Fast score: {fast_score}, Correct score: {correct_score}')\nprint('Correct!' if fast_score == correct_score else 'Incorrect:(')","725aef08":"initial_approximation = (jac_mat >= 0.18).to(device, torch.float32)\ninitial_approximation = initial_approximation + initial_approximation.T\ninitial_approximation_m = make_model(initial_approximation)\ninitial_approximation_m.a","237e2ed2":"m = initial_approximation_m # random_guess()\nm_score = m.eval()\ntotal_iteration = 0\n\nbest_m = m\nbest_m_score = best_m.eval()","568064fb":"new_scores = 0\nstat_better, stat_worse_accepted, stat_worse_rejected, stat_accept_anyway = 0, 0, 0, 0\nworsening = []\n\nfor iteration in range(6210001, 7000001): # range(0, 100001): # \n    candidate = m.clone()\n    \n    swap_count = 1 # max(int(n \/ (iteration \/ (16 * n) + 1)), 1)\n    swap_indexes = torch.randint(n, size=(swap_count,), device=device)\n    xor_vector = torch.zeros(n, device=device)\n    xor_vector[swap_indexes] = 1\n    \n    index = randrange(n)\n    delta = (1 - 2 * m.a[index]) * xor_vector\n    candidate.inc_sym(index, delta)\n    can_score = candidate.eval()\n    \n    score_increase = (can_score - m_score).item()\n    worsening += [max(score_increase, 0)]\n    \n    is_better = can_score < m_score\n    accept_anyway = random() < 1 \/ max(9020 * score_increase, 2) # False # \n    if is_better or accept_anyway:\n        m = candidate\n        m_score = can_score\n        new_scores += 1\n        # print(f'New score: {m_score} at iteration #{iteration} with swap_count={swap_count}') # Too much output\n    \n    # Statistics calculation\n    if is_better:\n        stat_better += 1\n    elif accept_anyway:\n        stat_worse_accepted += 1\n    else:\n        stat_worse_rejected += 1\n    stat_accept_anyway += int(accept_anyway)\n    \n    if can_score < best_m_score:\n        best_m = candidate\n        best_m_score = can_score\n        \n    if iteration % 1000 == 0:\n        #print(f'Iteration #{iteration}, score: {m_score:.2f}, new_scores: {new_scores}, swap_count: {swap_count}, better: {stat_better}, worse_acc: {stat_worse_accepted}, worse_rej: {stat_worse_rejected}, accept_anyway: {stat_accept_anyway}')\n        print(f'Iteration #{iteration}, score: {m_score:.2f}, swap_count: {swap_count}, better: {stat_better}, worse_acc: {stat_worse_accepted}, worse_rej: {stat_worse_rejected}, accept_anyway: {stat_accept_anyway}')\n        new_scores = 0\n        stat_better, stat_worse_accepted, stat_worse_rejected, stat_accept_anyway = 0, 0, 0, 0\n        \n    if total_iteration % 25000 == 0:\n        print(f'Error is: {int(((answer - m.a) * eval_mask).abs().sum().item())}')\n        torch.save(m.a, f'Backups\/anneal_m (backup {total_iteration}).pt')\n        \n    total_iteration += 1","d30c8241":"plt.figure(figsize=(16, 5))\nplt.scatter(range(len(worsening)), sorted(worsening))","43a3d751":"m = best_m\nm_score = best_m_score","bda0072d":"m_alt = m.a.clone()\nfor i in range(n):\n    # m_alt[i, i] = 0\n    continue\n\nm_jac = jaccard(m_alt)\njac_errors = (jac_sym - m_jac).abs().sum(0)\n\nerr_i_sorted = sorted(zip(jac_errors.tolist(), range(n)))\nfixed_count = 365\nfixed_threshold, _ = err_i_sorted[fixed_count]\nprint(f'Fixed threshold: {fixed_threshold}')\nvar_indexes = set(index for (error, index) in err_i_sorted[fixed_count:])\nprint(var_indexes)","6fba13b7":"plt.figure(figsize = (16, 5))\nplt.scatter(range(len(err_i_sorted)), [err for (err, index) in err_i_sorted])","a21519a7":"err_i_sorted[fixed_count-2 : fixed_count+3]","86fd90bd":"while m_score > 0.1:\n    new_scores = 0\n    stat_better, stat_worse_accepted, stat_worse_rejected, stat_accept_anyway = 0, 0, 0, 0\n    worsening = []\n\n    indexes_range = var_indexes # range(n) # \n    swaps = [(y, x) for y in indexes_range for x in indexes_range if y <= x] # [(i, i) for i in range(n)] # \n    # swaps = [(y, x) for y in range(n) for x in range(n) if y <= x] # [(i, i) for i in range(n)] # \n    shuffle(swaps)\n    print(f'Starting new bruteforce loop, swaps count: {len(swaps)}')\n\n    accepted_something = False\n    for iteration, (y, x) in enumerate(swaps):\n        candidate = m.clone()\n\n        xor_vector = torch.zeros(n, device=device)\n        xor_vector[x] = 1\n\n        index = y\n        delta = (1 - 2 * m.a[index]) * xor_vector\n        candidate.inc_sym(index, delta)\n        can_score = candidate.eval()\n\n        score_increase = (can_score - m_score).item()\n        worsening += [max(score_increase, 0)]\n\n        is_better = can_score < m_score\n        accept_anyway = random() < 1 \/ max(200 * score_increase, 2) # False # \n        if is_better or accept_anyway:\n            m = candidate\n            m_score = can_score\n            new_scores += 1\n            accepted_something = True\n            # print(f'New score: {m_score} at iteration #{iteration} with swap_count={swap_count}') # Too much output\n\n        # Statistics calculation\n        if is_better:\n            stat_better += 1\n        elif accept_anyway:\n            stat_worse_accepted += 1\n        else:\n            stat_worse_rejected += 1\n        stat_accept_anyway += int(accept_anyway)\n\n        if can_score < best_m_score:\n            best_m = candidate\n            best_m_score = can_score\n\n        if iteration % 1000 == 0:\n            #print(f'Iteration #{iteration}, score: {m_score:.2f}, new_scores: {new_scores}, swap_count: {swap_count}, better: {stat_better}, worse_acc: {stat_worse_accepted}, worse_rej: {stat_worse_rejected}, accept_anyway: {stat_accept_anyway}')\n            print(f'Iteration #{iteration}, score: {m_score:.2f}, swap_count: {swap_count}, better: {stat_better}, worse_acc: {stat_worse_accepted}, worse_rej: {stat_worse_rejected}, accept_anyway: {stat_accept_anyway}')\n            new_scores = 0\n            stat_better, stat_worse_accepted, stat_worse_rejected, stat_accept_anyway = 0, 0, 0, 0\n\n        if total_iteration % 25000 == 0:\n            print(f'Error is: {int(((answer - m.a) * eval_mask).abs().sum().item())}')\n            torch.save(m.a, f'Backups\/anneal_m (backup {total_iteration}).pt')\n\n        total_iteration += 1\n    \n    print('-' * 30)\n    if not accepted_something:\n        #break\n        pass\n        \nprint()\nprint('Local minimum reached')\nprint(f'Error is: {int(((answer - m.a) * eval_mask).abs().sum().item())}')","63513233":"((m.a == 0) | (m.a == 1)).all()","9fc202d8":"(m.a != m.a.T).any()","28d58e41":"m.fix_dependencies()\nprint(m.eval())","407b659a":"m_score","b63b98e3":"((answer - m.a) * eval_mask).abs().sum().item()","12d0a54b":"best_m_error = int(((answer - best_m.a) * eval_mask).abs().sum().item())\nbest_m_error","348c0856":"torch.save(best_m.a, f'Solutions\/an_{best_m_error}.pt')","403e55c3":"save_csv(best_m.a.to(int), f'Solutions\/an_{best_m_error}.txt')","13c8c524":"m.a = torch.load('anneal_m (1).pt')\nm.fix_dependencies()","2b77d460":"# Abstract","f436fb1d":"## Saving","8301a542":"## Validity checks","345fb9ea":"## Incrementing test","d93e9cae":"## The next block resets progress!","f0b85cf5":"\u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u043e\u043c \u043e\u0442\u0436\u0438\u0433\u0430:\n- \u041d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u0441 \u043a\u0430\u043a\u043e\u0439-\u043d\u0438\u0431\u0443\u0434\u044c \u043c\u043e\u0434\u0435\u043b\u0438\n- \u0414\u0435\u043b\u0430\u0435\u043c \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0435 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435\n- \u0415\u0441\u043b\u0438 \u0441\u0442\u0430\u043b\u043e \u043b\u0443\u0447\u0448\u0435 - \"\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c\" \u043d\u043e\u0432\u0443\u044e \u043c\u043e\u0434\u0435\u043b\u044c (\u043f\u0435\u0440\u0435\u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0441\u0442\u0430\u0440\u0443\u044e)\n- \u0415\u0441\u043b\u0438 \u0441\u0442\u0430\u043b\u043e \u0445\u0443\u0436\u0435 - \"\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c\" \u043d\u043e\u0432\u0443\u044e \u043c\u043e\u0434\u0435\u043b\u044c \u0441 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u043e\u0439 \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c\u044e (\u0432\u0430\u0436\u043d\u043e, \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0437\u0430\u0441\u0442\u0440\u044f\u0442\u044c \u0432 \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u043e\u043c \u043c\u0438\u043d\u0438\u043c\u0443\u043c\u0435. \u0411\u0435\u0437 \u044d\u0442\u043e\u0433\u043e \u043d\u0435 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442!), \u0438\u043d\u0430\u0447\u0435 \u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u0441\u0451 \u043a\u0430\u043a \u0431\u044b\u043b\u043e\n- \u041f\u043e\u0432\u0442\u043e\u0440\u044f\u0435\u043c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043c\u0438\u043b\u043b\u0438\u043e\u043d\u043e\u0432 \u0440\u0430\u0437\n\n\u041a\u043e\u0434 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0446\u0435\u043b\u044b\u0445 \u0441\u0442\u0440\u043e\u043a \u0438 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432, \u0445\u043e\u0442\u044f \u043f\u043e \u0444\u0430\u043a\u0442\u0443 \u044d\u0442\u043e \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u043e\u0441\u044c - \u0432\u0441\u0435\u0433\u0434\u0430 \u043c\u0435\u043d\u044f\u043b\u0441\u044f \u0440\u043e\u0432\u043d\u043e \u043e\u0434\u0438\u043d \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043d\u0430 \u043f\u0440\u043e\u0442\u0438\u0432\u043e\u043f\u043e\u043b\u043e\u0436\u043d\u044b\u0439.","c5a6491f":"## Finishing loop","853efef3":"## Incrementing debug","acb13f30":"## Optimization","b0d63dd4":"# Annealing","4e1ed970":"# Common","22d826e3":"## Entries with low Jaccard score should be altered less","46fa59c4":"# Fast jaccard update","64e89d10":"\u041f\u043e \u0431\u043e\u043b\u044c\u0448\u0435\u0439 \u0447\u0430\u0441\u0442\u0438 \u0442\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0435, \u0447\u0442\u043e \u0438 \"Main optimization loop\", \u0442\u043e\u043b\u044c\u043a\u043e \u0432\u043c\u0435\u0441\u0442\u043e \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u043a\u0430\u0436\u0434\u044b\u0439 \u0440\u0430\u0437 \u0432\u044b\u0431\u0438\u0440\u0430\u0442\u044c \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043d\u0430 \u0437\u0430\u043c\u0435\u043d\u0443, \u0442\u0443\u0442 \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u044e\u0442\u0441\u044f \u0432\u0441\u0435 (\u043d\u0435-\u0437\u0430\u0444\u0438\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435) \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0432 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435. \u041d\u0443\u0436\u043d\u043e \u0442\u0430\u043a \u043a\u0430\u043a \u0432 \u043a\u043e\u043d\u0446\u0435 \u043e\u0441\u0442\u0430\u0451\u0442\u0441\u044f \u043c\u0430\u043b\u043e \u043e\u0448\u0438\u0431\u043e\u043a, \u0438 \u0432\u0441\u0435\u0433\u0434\u0430 \u0432\u044b\u0431\u0438\u0440\u0430\u044f \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442, \u043d\u0430 \u0442\u043e \u0447\u0442\u043e\u0431\u044b \u043d\u0430\u0442\u043a\u043d\u0443\u0442\u044c\u0441\u044f \u043d\u0430 \u0432\u0441\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b-\u043e\u0448\u0438\u0431\u043a\u0438 \u0443\u0439\u0434\u0451\u0442 \u043c\u043d\u043e\u0433\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 - \u043b\u0443\u0447\u0448\u0435 \u043f\u0440\u043e\u0441\u0442\u043e \u043f\u0435\u0440\u0435\u0431\u0440\u0430\u0442\u044c \u0432\u0441\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b.","89b93159":"\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0442\u0440\u0438 \u0433\u0440\u0443\u043f\u043f\u044b \u0431\u043b\u043e\u043a\u043e\u0432 (\"Main optimization loop\", \"Finishing loop\" \u0438 \u0438\u043d\u043e\u0433\u0434\u0430 \"Entries with low Jaccard score should be altered less\") \u043f\u043e\u043e\u0447\u0435\u0440\u0451\u0434\u043d\u043e \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u043b\u0438\u0441\u044c (\u0430 \u0442\u0430\u043a\u0436\u0435 \u043f\u043e\u0440\u043e\u0439 \u043e\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u043b\u0438\u0441\u044c) \u0432\u0440\u0443\u0447\u043d\u0443\u044e \u0441 \u0440\u0443\u0447\u043d\u044b\u043c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432. \u0418\u0437\u043c\u0435\u043d\u044f\u043b\u0438\u0441\u044c \u0432 \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u043c \u0441\u0442\u0440\u043e\u043a\u0438:\n<pre>accept_anyway = random() < 1 \/ max(9020 * score_increase, 2) # False # \n\u0422\u0443\u0442 \u0438\u0437\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e \u0432\u043c\u0435\u0441\u0442\u043e 9020 \u0431\u044b\u043b\u043e \u0447\u0442\u043e-\u0442\u043e \u043e\u043a\u043e\u043b\u043e 300 \u0434\u043b\u044f \u0431\u043e\u043b\u044c\u0448\u0435\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0441\u0442\u0438, \u0430 \u0432 \u043a\u043e\u043d\u0446\u0435 \u044f \u043f\u043e\u0440\u043e\u0439 \u0438 \u043f\u0440\u043e\u0431\u043e\u0432\u0430\u043b \u0441\u0442\u0430\u0432\u0438\u0442\u044c False, \u0434\u043b\u044f \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u044f \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0445 \u0443\u0445\u0443\u0434\u0448\u0435\u043d\u0438\u0439.\n\nfixed_count = 365\n\u0412\u043f\u0435\u0440\u0432\u044b\u0435 \u043a\u043e\u0433\u0434\u0430 \u0434\u0430\u043d\u043d\u044b\u0439 \u043a\u0443\u0441\u043e\u043a \u043a\u043e\u0434\u0430 \u0431\u044b\u043b \u043d\u0430\u043f\u0438\u0441\u0430\u043d, \u044f \u0444\u0438\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043b 220 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0441 \u043d\u0430\u0438\u043c\u0435\u043d\u044c\u0448\u0438\u043c\u0438 \u043e\u0448\u0438\u0431\u043a\u0430\u043c\u0438 \u043f\u043e \u0436\u0430\u043a\u0430\u0440\u0443. \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u044b\u0431\u0438\u0440\u0430\u043b\u043e\u0441\u044c \"\u043d\u0430 \u0433\u043b\u0430\u0437\" \u0438\u0441\u0445\u043e\u0434\u044f \u0438\u0437 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043e\u0448\u0438\u0431\u043a\u0438 \u043f\u043e \u0436\u0430\u043a\u0430\u0440\u0443.\n<\/pre>","2e84ea9d":"<pre>(A + row)(A + row) = AA + A*row + row*(A + row)\n(A + col)(A + col) = (A + col)*col + col*A + A*A\n<\/pre>","458685ed":"## Loading","f9aa9d3d":"## Main optimization loop"}}