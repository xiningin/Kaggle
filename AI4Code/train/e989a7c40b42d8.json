{"cell_type":{"21bd145c":"code","e30dbcd1":"code","a653c3a4":"code","a5d49351":"code","0ecd435d":"code","11db209f":"code","9558cc0d":"code","071e0320":"code","58f9a2ed":"code","2882c168":"code","711835f7":"code","defa255b":"code","cd87fb04":"code","2baf221b":"code","98397cf4":"code","dc08e38e":"code","8dc967f6":"code","29d45b21":"markdown","b12c3a56":"markdown","068596a3":"markdown","2fecf26c":"markdown","6329201c":"markdown","4af802f4":"markdown","4fdfd0d1":"markdown","de9df2a6":"markdown","a9d4adaf":"markdown","164dd603":"markdown","db1e8515":"markdown","9e11a444":"markdown"},"source":{"21bd145c":"import pandas as pd\nimport numpy as np\n\ndf = pd.read_csv(\"..\/input\/fics-chess-games\/fics_fen_2_2M_rnn.csv\", header=None, sep=\";\", names=[\"FEN\"])\nX_data = df[\"FEN\"]\nX_data.head()","e30dbcd1":"games_sequence = list(df[\"FEN\"][:])\nlen(games_sequence)","a653c3a4":"games_list = []\ncut = 0\nfor i, pos in enumerate(games_sequence):\n    if pos == \"END\":\n        if len(games_sequence[cut:i]) > 11:\n            games_list.append(games_sequence[cut:i])\n        cut = i+1\ngames_list[34]   ","a5d49351":"gamesnr = len(games_list)\ngamesnr","0ecd435d":"def batchtotensor(inputbatch):\n    \n    pieces_str = \"PNBRQK\"\n    pieces_str += pieces_str.lower()\n    pieces = set(pieces_str)\n    valid_spaces = set(range(1,9))\n    pieces_dict = {pieces_str[0]:1, pieces_str[1]:2, pieces_str[2]:3, pieces_str[3]:4 , pieces_str[4]:5, pieces_str[5]:6,\n              pieces_str[6]:-1, pieces_str[7]:-2, pieces_str[8]:-3, pieces_str[9]:-4 , pieces_str[10]:-5, pieces_str[11]:-6}\n\n    maxnum = len(inputbatch)\n    boardtensor = np.zeros((maxnum, 8, 8,7))\n    \n    for num, inputstr in enumerate(inputbatch):\n        inputliste = inputstr.split()\n        rownr = 0\n        colnr = 0\n        for i, c in enumerate(inputliste[0]):\n            if c in pieces:\n                boardtensor[num, rownr, colnr, np.abs(pieces_dict[c])-1] = np.sign(pieces_dict[c])\n                colnr = colnr + 1\n            elif c == '\/':  # new row\n                rownr = rownr + 1\n                colnr = 0\n            elif int(c) in valid_spaces:\n                colnr = colnr + int(c)\n            else:\n                raise ValueError(\"invalid fenstr at index: {} char: {}\".format(i, c))\n        \n        if inputliste[1] == \"w\":\n            for i in range(8):\n                for j in range(8):\n                    boardtensor[num, i, j, 6] = 1\n        else:\n            for i in range(8):\n                for j in range(8):\n                    boardtensor[num, i, j, 6] = -1\n  \n    return boardtensor","11db209f":"sequence_length = 1","9558cc0d":"def myGenerator():\n    while 1:\n        for i in range(len(games_list)): \n            X_batch = []\n            y_batch = []\n            for j in range(len(games_list[i])-sequence_length-1):\n                X_batch.append(batchtotensor(games_list[i][j:j+sequence_length]))\n                y_batch.append(batchtotensor(games_list[i][j+sequence_length:j+sequence_length+1]))\n                \n            X_batch = np.array(X_batch)\n            y_batch = np.array(y_batch)\n            y_batch = np.squeeze(y_batch, axis=1)\n\n            yield (X_batch, y_batch)","071e0320":"from keras.models import Sequential\nfrom keras.layers import Input, Dense, LSTM, Reshape, SimpleRNN\nfrom keras.models import Model\n\nmodel = Sequential()\nmodel.add(Reshape((sequence_length,448,), input_shape=(sequence_length,8,8,7)))\nmodel.add(SimpleRNN(400,return_sequences=True))\nmodel.add(SimpleRNN(400))\nmodel.add(Dense(448, activation='tanh'))\nmodel.add(Reshape((8,8,7)))\nprint(model.summary())","58f9a2ed":"from pickle import load\nfrom keras.models import load_model\n\nmodel = load_model('..\/input\/model1\/model_chess_1.h5')","2882c168":"my_generator = myGenerator()\nmodel.compile(loss='mse', optimizer='adam')\nhistory = model.fit_generator(my_generator, steps_per_epoch = gamesnr, epochs = 1, verbose=1,  workers=2)\nmodel.save('model_chess_2.h5')","711835f7":"def tensor_to_fen(inputtensor):\n    pieces_str = \"PNBRQK\"\n    pieces_str += pieces_str.lower()\n    \n    maxnum = len(inputtensor)\n    \n    outputbatch = []\n    for i in range(maxnum):\n        fenstr = \"\"\n        for rownr in range(8):\n            spaces = 0\n            for colnr in range(8):\n                for lay in range(6):                    \n                    if inputtensor[i,rownr,colnr,lay] == 1:\n                        if spaces > 0:\n                            fenstr += str(spaces)\n                            spaces = 0\n                        fenstr += pieces_str[lay]\n                        break\n                    elif inputtensor[i,rownr,colnr,lay] == -1:\n                        if spaces > 0:\n                            fenstr += str(spaces)\n                            spaces = 0\n                        fenstr += pieces_str[lay+6]\n                        break\n                    if lay == 5:\n                        spaces += 1\n            if spaces > 0:\n                fenstr += str(spaces)\n            if rownr < 7:\n                fenstr += \"\/\"\n        if inputtensor[i,0,0,6] == 1:\n            fenstr += \" w\"\n        else:\n            fenstr += \" b\"\n        outputbatch.append(fenstr)\n    \n    return outputbatch","defa255b":"from pickle import load\nfrom keras.models import load_model\n\nmodel = load_model('..\/input\/model1\/model_chess_1.h5')\n\ndef generate_position(model, seed_fens):\n    encoded_seed = batchtotensor(seed_fens)\n    seed_list = np.array([encoded_seed])\n    pos = model.predict(seed_list)\n    pos = np.round(pos)\n    \n    return tensor_to_fen(pos)\n    ","cd87fb04":"prog = generate_position(model, [games_sequence[0]])\nprog","2baf221b":"count = 0\ncountall = 0\nfor i in range(len(games_sequence)-1):\n    if games_sequence[i] <= 'END' and games_sequence[i+1] <= 'END':\n        countall += 1\n        prog = generate_position(model, [games_sequence[i]])\n        if prog[0] == games_sequence[i+1]:\n            count += 1\n        \ncount \/ countall","98397cf4":"seed_fens = [\"rnbqkbnr\/pppppppp\/8\/8\/8\/8\/PPPPPPPP\/RNBQKBNR w\",\n\"rnbqkbnr\/pppppppp\/8\/8\/5P2\/8\/PPPPP1PP\/RNBQKBNR b\",\n\"rnbqkbnr\/ppp1pppp\/3p4\/8\/5P2\/8\/PPPPP1PP\/RNBQKBNR w\",\n\"rnbqkbnr\/ppp1pppp\/3p4\/8\/5P2\/5N2\/PPPPP1PP\/RNBQKB1R b\",\n\"rnbqkb1r\/ppp1pppp\/3p1n2\/8\/5P2\/5N2\/PPPPP1PP\/RNBQKB1R w\",\n\"rnbqkb1r\/ppp1pppp\/3p1n2\/8\/5P2\/3P1N2\/PPP1P1PP\/RNBQKB1R b\",\n\"rn1qkb1r\/ppp1pppp\/3p1n2\/8\/5Pb1\/3P1N2\/PPP1P1PP\/RNBQKB1R w\",\n\"rn1qkb1r\/ppp1pppp\/3p1n2\/8\/4PPb1\/3P1N2\/PPP3PP\/RNBQKB1R b\",\n\"r2qkb1r\/pppnpppp\/3p1n2\/8\/4PPb1\/3P1N2\/PPP3PP\/RNBQKB1R w\",\n\"r2qkb1r\/pppnpppp\/3p1n2\/8\/4PPb1\/3P1N2\/PPP1B1PP\/RNBQK2R b\"]\nseed_fens = [seed_fens[-sequence_length]]\nseed_fens","dc08e38e":"fenstring = generate_position(model, seed_fens)\nfenliste = fenstring[0].split()\nfenliste","8dc967f6":"import chess\nimport chess.svg\nfrom IPython.display import SVG\n\nboard = chess.Board(fenliste[0] + \" \" + fenliste[1] + \" - \" + \" - \"  \"0\" + \" 1\")\nSVG(chess.svg.board(board=board,size=400))","29d45b21":"## Count number of correct predicted positions","b12c3a56":"## Convert FEN to TENSOR\n\nA sequence of positions in FEN notation is converted to 8x8x7 Tensors","068596a3":"## Import the Chess Games as Sequence of Positions","2fecf26c":"## Convert a tensor to FEN","6329201c":" ## Define the Model","4af802f4":"## List of Positions","4fdfd0d1":"## Generate batches of positions - one batch per game ","de9df2a6":"## Train a new model","a9d4adaf":"## Some Testpositions","164dd603":"## Load model and define generate position","db1e8515":"## Load  a Model","9e11a444":"## List of Games"}}