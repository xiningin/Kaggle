{"cell_type":{"f2bedf04":"code","e597dd1d":"code","18bdceeb":"code","4b77c4ab":"code","ebde82f8":"code","cf212612":"code","bdef1a3a":"code","c50c628c":"code","60d2133c":"code","c302b73d":"code","547a3560":"code","89f76f99":"code","9cdd3371":"code","cdece656":"code","4da2b904":"code","6128aff4":"code","650de0d8":"code","d1c578cc":"code","250f93ed":"code","844e67c1":"code","6b7840ec":"code","dcb694cb":"code","1ac4bf4e":"code","927df518":"code","90c4610a":"code","60313565":"code","dc5d362b":"code","f7753121":"code","2218e1bf":"code","0b4216a4":"code","bad5ac9c":"code","e8132d13":"code","3e0def49":"code","45ff281c":"code","4c70188b":"code","afdc2d28":"code","89492ebf":"code","e744ee71":"code","3a489799":"code","08dbd923":"code","fdfe1f8c":"code","dd73ca7b":"code","9f476617":"code","5e4b3d73":"code","d986ab9f":"code","b6c1eceb":"code","656c7506":"code","568f3852":"code","ac78e2a0":"code","6446cac5":"code","60c77fe0":"code","db4dea0e":"code","823b5ab4":"code","1a2f968e":"code","ef6c3159":"code","ec66f1bd":"code","f2b4c4be":"code","e9f83962":"code","398a8ef6":"code","6d381269":"code","4d0d7b12":"code","aadd7852":"code","bad027ba":"code","3421c718":"code","d443b00a":"code","42141331":"code","2775aa90":"code","ed0fa33f":"code","2e292230":"code","813709fe":"code","14f79489":"code","8ff87f09":"code","efa2d106":"code","6acddeb7":"code","c23b94ea":"code","b8586e76":"code","16489247":"code","56cf315f":"code","24a503e0":"code","1eea1f1a":"code","8501eb45":"code","32661cae":"code","f6899d23":"code","b8f8c0c6":"code","3d853814":"code","1da90d9d":"code","2e3906a6":"code","6f0cdf98":"code","84cf4f09":"code","92e741bc":"code","cb53372d":"code","80329056":"code","83ea4895":"markdown","82013fa4":"markdown","6056d5ff":"markdown","958666fe":"markdown","ed9f0ecb":"markdown","50f600e2":"markdown","f6830e4e":"markdown","4d7983fc":"markdown","85276dfb":"markdown","6db89c4b":"markdown","7627517d":"markdown","665c312e":"markdown","38231863":"markdown","5639ebb3":"markdown","11ab10c0":"markdown","325e7662":"markdown","5daf9479":"markdown","0fb0cc22":"markdown","cb439259":"markdown","dc7a8d7a":"markdown","d495876e":"markdown","c28fda3b":"markdown","890debee":"markdown","b4e21889":"markdown","509eb629":"markdown","d9ecf240":"markdown","dacde36f":"markdown","6fa8d0b9":"markdown","0d00d2b7":"markdown"},"source":{"f2bedf04":"# !pip install --upgrade pandas","e597dd1d":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom datetime import datetime, timedelta, date\nimport re","18bdceeb":"from sklearn.model_selection import train_test_split\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis","4b77c4ab":"# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","ebde82f8":"%cd \"\/kaggle\/input\"","cf212612":"data_path = 'nfl-big-data-bowl-2022\/'","bdef1a3a":"plays = pd.read_csv (data_path + 'plays.csv')\nplayers = pd.read_csv (data_path + 'players.csv')\nPFFScouting = pd.read_csv (data_path + 'PFFScoutingData.csv')\ngames = pd.read_csv (data_path + 'games.csv')","c50c628c":"players_ori = players.copy()","60d2133c":"tracking2018 = pd.read_csv(data_path + 'tracking2018.csv')\ntracking2019 = pd.read_csv(data_path + 'tracking2019.csv')\ntracking2020 = pd.read_csv(data_path + 'tracking2020.csv')","c302b73d":"playgames = pd.merge(plays,games,on='gameId',how='left')\nplaygamesScout = pd.merge(playgames,PFFScouting,on=['gameId','playId'],how='left')\nrawDf = pd.merge(playgamesScout,players, left_on=['kickerId'],right_on=['nflId'],how='left')","547a3560":"def downcast(df, verbose=True):\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    for col in df.columns:\n        dtype_name = df[col].dtype.name\n        if dtype_name == 'object':\n            pass\n        elif dtype_name == 'bool':\n            df[col] = df[col].astype('int8')\n        elif dtype_name.startswith('int') or (df[col].round() == df[col]).all():\n            df[col] = pd.to_numeric(df[col], downcast='integer')\n        else:\n            df[col] = pd.to_numeric(df[col], downcast='float')\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    if verbose:\n        print('{:.1f}% Compressed'.format(100 * (start_mem - end_mem) \/ start_mem))\n    \n    return df","89f76f99":"def resumetable(df):\n    print(f'Shape : {df.shape}')\n    summary = pd.DataFrame(df.dtypes, columns=['Data Type'])\n    summary = summary.reset_index()\n    summary = summary.rename(columns={'index': 'Feature'})\n    summary['Num of null'] = df.isnull().sum().values\n    summary['Num of unique'] = df.nunique().values\n    summary['First value'] = df.loc[0].values\n    summary['Second value'] = df.loc[1].values\n    summary['Third value'] = df.loc[2].values\n    return summary","9cdd3371":"games = downcast(games)\nplayers = downcast(players)\nplays = downcast(plays)\nPFFScouting = downcast(PFFScouting)","cdece656":"#check data\nresumetable(players)\nresumetable(games)\nresumetable(plays)\nresumetable(PFFScouting)","4da2b904":"def cleanPlayers(players):\n    #convert height & weight\n\n    # Get the Height data from DataFrame & Split the heights by hyphen (\"-\")\n    players_heights = players[\"height\"].apply(lambda x: x.split(\"-\"))  \n\n    # Convert Heights to Centimeters and add them to DataFrame\n    players[\"height\"] = players_heights.apply(lambda x: int(x[0]) * 12 + int(x[1]) if len(x) == 2 else int(x[0])) * 2.54\n\n    # Convert Weights to Kilograms and them to DataFrame\n    players[\"weight\"] = round(players.weight * 0.453592, 2)\n\n    #fill in NAN Value on age and college name (only players in special team)\n    players.loc[players['displayName'] =='Hunter Niswander', ['birthDate']] = '1994-11-26'\n    players.loc[players['displayName'] =='Taylor Russolino', ['birthDate']] = '1989-05-23'\n    players.loc[players['displayName'] =='Brandon Wright', ['collegeName']] = 'North Carolina State'\n    players.loc[players['displayName'] =='Hunter Niswander', ['collegeName']] = 'Northwestern'\n    players.loc[players['displayName'] =='Taylor Russolino', ['collegeName']] = 'Mississippi'\n\n    players['birthDate'] = pd.to_datetime(players['birthDate'])\n\n    return players\n","6128aff4":"def cleanBeforeCombine(players, plays, games):\n    players = cleanPlayers(players)\n\n    games['gameDate'] = pd.to_datetime(games['gameDate'],infer_datetime_format=True)\n    plays= plays.loc[(plays['specialTeamsPlayType'] == 'Field Goal') | (plays['specialTeamsPlayType'] == 'Punt' ) | (plays['specialTeamsResult'] == 'Non-Special Teams Result' )]\n\n    return players, plays, games","650de0d8":"players, plays, games = cleanBeforeCombine(players, plays, games)","d1c578cc":"playgames = pd.merge(plays,games,on='gameId',how='left')\nplaygamesScout = pd.merge(playgames,PFFScouting,on=['gameId','playId'],how='left')\nalldata = pd.merge(playgamesScout,players, left_on=['kickerId'],right_on=['nflId'],how='left')","250f93ed":"typeCols = ['quarter', 'down', 'yardsToGo', 'possessionTeam',\n            'specialTeamsPlayType', 'specialTeamsResult', 'yardlineSide',\n            'yardlineNumber', 'gameClock', 'preSnapHomeScore',\n            'preSnapVisitorScore', 'absoluteYardlineNumber', 'homeTeamAbbr', 'visitorTeamAbbr']","844e67c1":"puntCols = ['quarter', 'down', 'yardsToGo', 'possessionTeam', \n            'yardlineSide', 'yardlineNumber', 'gameClock', 'preSnapHomeScore',\n            'preSnapVisitorScore', 'kickLength', 'absoluteYardlineNumber',\n            'homeTeamAbbr', 'visitorTeamAbbr', 'kickType', 'direction',\n            'nflId', 'height', 'weight', 'Position', 'age']","6b7840ec":"fgCols = ['quarter', 'down', 'yardsToGo', 'possessionTeam', 'specialTeamsResult',\n        'yardlineSide', 'yardlineNumber', 'gameClock', 'preSnapHomeScore',\n        'preSnapVisitorScore', 'absoluteYardlineNumber', 'homeTeamAbbr', 'visitorTeamAbbr',\n        'nflId', 'height', 'weight', 'Position', 'age']","dcb694cb":"allCols = list(set().union(puntCols, fgCols, typeCols))","1ac4bf4e":"pos_map = {'K':1,\"P\":0 }\nkick_map = {'N':1,\"A\":2,\"R\":3,0:0}\ndir_map = {'C':1,\"L\":2,\"R\":3,0:0 }","927df518":"def cleanAll(alldata):\n\n    # count the players age in the play\n    alldata[\"age\"]=alldata[\"gameDate\"].dt.year - alldata[\"birthDate\"].dt.year\n    alldata = alldata.drop(columns=[\"birthDate\", \"gameDate\"])\n\n    alldata['gameClock'] = pd.to_timedelta(alldata['gameClock'])\n    alldata['gameClock'] = alldata['gameClock'].dt.total_seconds()\n\n    #  convert team abbr to number\n    team_idx = alldata['homeTeamAbbr'].value_counts().sort_index(key=lambda x : x.str.lower())\n    team_map = {}\n    i = 0\n    for t in team_idx.index:\n        team_map[t] = i\n        i += 1\n\n    alldata['homeTeamAbbr'] = alldata['homeTeamAbbr'].map(team_map)\n    alldata['visitorTeamAbbr'] = alldata['visitorTeamAbbr'].map(team_map)\n    alldata['possessionTeam'] = alldata['possessionTeam'].map(team_map)\n    alldata['yardlineSide'] = alldata['yardlineSide'].map(team_map)\n\n    alldata['kickLength'] = alldata['kickLength'].fillna(0)\n\n    # conver categorical data to number\n    alldata['Position']= alldata['Position'].map(pos_map)\n    alldata['kickType'] = alldata['kickType'].map(kick_map)\n    alldata['direction'] = alldata['kickDirectionActual'].map(dir_map)\n\n    alldata = alldata[allCols]\n    return alldata, team_map\n","90c4610a":"alldata, team_map = cleanAll(alldata)","60313565":"alldata.head()","dc5d362b":"alldata.isna().sum()","f7753121":"punt = alldata[alldata['specialTeamsPlayType']=='Punt']\nfg = alldata[alldata['specialTeamsPlayType']=='Field Goal']\ncountpunt=punt['specialTeamsResult'].value_counts().reset_index()\ncountfg=fg['specialTeamsResult'].value_counts().reset_index()","2218e1bf":"\n\nfrom matplotlib import gridspec, ticker\ncolor_counts = (punt['specialTeamsResult'].value_counts().reset_index())\ncolor_counts.columns = ['specialTeamsResult', 'count']\n\norder = color_counts['specialTeamsResult']\npalette = color_counts['specialTeamsResult'].replace('other', None) # \"other\" is not a color name\n\nfig = plt.figure(figsize=(15, 8))\ngs = gridspec.GridSpec(1, 3, figure=fig)\n\n# Left plot\nax = fig.add_subplot(gs[0])\nsns.barplot(data = color_counts, x = 'count', y = 'specialTeamsResult',\n            #palette = palette, \n            ax = ax)\nax.set(title = 'Punt Result')\nax.set_xlim((0, 5600))\nfor p in ax.patches:\n    ax.annotate(f\"{int(p.get_width())}\", xy = (p.get_width(), p.get_y() + 0.5),\n                horizontalalignment = 'left')\n    clr = p.get_facecolor()\n    if clr == (1, 1, 1, 1):\n        # If facecolor is white\n        p.set_edgecolor('magenta')\nax.set_ylabel('')\n\n\n# Right plot\nax = fig.add_subplot(gs[1:3])\nsns.boxenplot(data = punt, x = 'kickLength', y = 'specialTeamsResult',\n              order = order, \n              #palette = palette, \n              ax = ax)\nax.set(title = 'Punt Results - Kick Lengths', xscale = 'log')\nax.yaxis.tick_right()\nax.set_ylabel('')\n\nplt.suptitle(\"How Punt Results Compared when it comes to kick lengths\", fontsize = 15)\nplt.tight_layout()\nplt.show()","0b4216a4":"from matplotlib import gridspec, ticker\ncolor_counts = (fg['specialTeamsResult'].value_counts().reset_index())\ncolor_counts.columns = ['specialTeamsResult', 'count']\n\norder = color_counts['specialTeamsResult']\npalette = color_counts['specialTeamsResult'].replace('other', None) # \"other\" is not a color name\n\nfig = plt.figure(figsize=(15, 8))\ngs = gridspec.GridSpec(1, 3, figure=fig)\n\n# Left plot\nax = fig.add_subplot(gs[0])\nsns.barplot(data = color_counts, x = 'count', y = 'specialTeamsResult',\n            #palette = palette, \n            ax = ax)\nax.set(title = 'Field Goal Result')\nax.set_xlim((0, 5600))\nfor p in ax.patches:\n    ax.annotate(f\"{int(p.get_width())}\", xy = (p.get_width(), p.get_y() + 0.5),\n                horizontalalignment = 'left')\n    clr = p.get_facecolor()\n    if clr == (1, 1, 1, 1):\n        # If facecolor is white\n        p.set_edgecolor('magenta')\nax.set_ylabel('')\n\n\n# Right plot\nax = fig.add_subplot(gs[1:3])\nsns.boxenplot(data = fg, x = 'kickLength', y = 'specialTeamsResult',\n              order = order, \n              #palette = palette, \n              ax = ax)\nax.set(title = 'Field Goal Results - Kick Lengths', xscale = 'log')\nax.yaxis.tick_right()\nax.set_ylabel('')\n\nplt.suptitle(\"How Field Goal Results Compared when it comes to kick lengths\", fontsize = 15)\nplt.tight_layout()\nplt.show()","bad5ac9c":"def fillna(df):\n    for c in df.columns:\n        col = df[c]\n        if col.isna().sum()>0:\n            df[c] = df[c].fillna(method='ffill')\n    return df","e8132d13":"def cleanTypeData(alldata):\n\n    classplaytype = alldata.drop(alldata[alldata.specialTeamsPlayType=='Extra Point'].index)\n    classplaytype = fillna(classplaytype)\n\n    classplaytype['specialTeamsPlayType'].mask(classplaytype['specialTeamsResult'] == 'Non-Special Teams Result', 'Non-Special Teams', inplace=True)\n\n    classplaytype =classplaytype[typeCols]\n    return classplaytype\n    ","3e0def49":"classplaytype = cleanTypeData(alldata)","45ff281c":"typeX = classplaytype.drop(columns=[\"specialTeamsPlayType\",\"specialTeamsResult\"])\ntypeInputCol = typeX.columns\ntypeX = typeX.to_numpy()\ntypeY = classplaytype['specialTeamsPlayType']\nprint(typeX.shape, typeY.shape)","4c70188b":"classplaytype['specialTeamsPlayType']","afdc2d28":"typeX_train, typeX_test, typeY_train, typeY_test = train_test_split(typeX, typeY, random_state=20, train_size=0.8)","89492ebf":"typeModel = GaussianNB()\ntypeModel.fit(typeX_train, typeY_train)\nprint('Accuracy of type classifier on training set: {:.2f}'\n     .format(typeModel.score(typeX_train, typeY_train)))\nprint('Accuracy of type classifier on test set: {:.2f}'\n     .format(typeModel.score(typeX_test, typeY_test)))","e744ee71":"typeModel.predict([typeX_test[2]])","3a489799":"def cleanPuntData(alldata):\n\n    punt = alldata.loc[(alldata['specialTeamsPlayType'] == 'Punt') & (alldata['specialTeamsResult']!='Non-Special Teams Result')]\n    \n    punt = punt.reset_index()\n    punt = fillna(punt)\n    punt = punt[puntCols]\n\n    return punt","08dbd923":"punt = cleanPuntData(alldata)\npunt.info()","fdfe1f8c":"def create_puntY(df):\n    categorized = []\n    for i, r in df.iterrows():\n\n        kickLength = r.kickLength\n        if 30>=kickLength:\n            # punt failed\n            categorized.append(0)\n        elif (kickLength>30) & (45>=kickLength):\n            categorized.append(1)\n        elif (kickLength>45) & (60>=kickLength):\n            categorized.append(2)\n        else: #kickLength > 60\n            categorized.append(3)\n    return categorized","dd73ca7b":"puntY = create_puntY(punt)\npuntX = punt.drop(columns=['kickLength'])\npuntInputCols = puntX.columns\npuntX = puntX.to_numpy()","9f476617":"puntX_train, puntX_test, puntY_train, puntY_test = train_test_split(puntX, puntY, random_state=234, train_size=0.9)\n","5e4b3d73":"puntModel = LinearDiscriminantAnalysis()\npuntModel.fit(puntX, puntY)\nprint('Accuracy of LDA classifier on training set: {:.2f}'\n     .format(puntModel.score(puntX, puntY)))\nprint('Accuracy of LDA classifier on test set: {:.2f}'\n     .format(puntModel.score(puntX_test, puntY_test)))","d986ab9f":"puntModel.predict_proba([puntX_test[0]])","b6c1eceb":"def cleanFgData(alldata):\n\n    FG = alldata.loc[(alldata['specialTeamsPlayType'] == 'Field Goal') & (alldata['specialTeamsResult']!='Non-Special Teams Result')]\n\n    FG = FG.reset_index()\n    FG = fillna(FG)\n    FG = FG[fgCols]\n    return FG","656c7506":"FG = cleanFgData(alldata)","568f3852":"FG.info()","ac78e2a0":"fgY = FG['specialTeamsResult'].map(\n    {'Kick Attempt Good':True, \n     \"Kick Attempt No Good\":False, \n     \"Blocked Kick Attempt\":False, \n     \"Out of Bounds\":False, \n     \"Downed\":False\n     })\nfgX = FG.drop(columns=['specialTeamsResult'])\nfgInputCols = fgX.columns\nfgX = fgX.to_numpy()","6446cac5":"len(fgInputCols)","60c77fe0":"fgX_train, fgX_test, fgY_train, fgY_test = train_test_split(fgX, fgY, random_state=2, train_size=0.8)\n","db4dea0e":"fgModel = LinearDiscriminantAnalysis()\nfgModel.fit(fgX_train,fgY_train)\nprint('Accuracy of LDA classifier on training set: {:.2f}'\n     .format(fgModel.score(fgX_train, fgY_train)))\nprint('Accuracy of LDA classifier on test set: {:.2f}'\n     .format(fgModel.score(fgX_test, fgY_test)))","823b5ab4":"fgModel.predict_proba([fgX_test[0]])","1a2f968e":"merged_df = pd.merge(plays, PFFScouting,  how='left', left_on=['gameId','playId'], right_on = ['gameId','playId'])\n\nmerged_df = pd.merge(merged_df, games,  how='left', left_on=['gameId'], right_on = ['gameId'])","ef6c3159":"def idReplace(df):\n    print(f\"Possible {df.playResult}:\")\n    print(\"- Key player: \", players_ori[players_ori.nflId == df['key']].displayName.item())\n    \n    supportNames = []\n    for i in df['support']:\n        supportNames.append(str(players_ori[players_ori.nflId == i].displayName.item()))\n    print(\"- Support player: \", supportNames, \"\\n\")","ec66f1bd":"new_df = merged_df[(merged_df.specialTeamsResult == \"Blocked Punt\")]\n\nnew_df = new_df.reset_index(drop=True)","f2b4c4be":"# Check for missing values\nnew_df.puntRushers.isna().sum()","e9f83962":"team = []\nteamSide = []\nkeyId = []\nsupportId = []\n\n\ndef ksm_blockedpunt(new_df):\n    ## Team\n    if new_df.possessionTeam == new_df.homeTeamAbbr:\n        team.append(new_df.visitorTeamAbbr)\n    else:\n        team.append(new_df.homeTeamAbbr)\n    \n    ## Key\n    keyId.append(int(new_df.kickBlockerId))\n    \n    ## Support\n    supportId_temp = [] ## To store one row after each loop, then append to \"supportId\"\n    \n    JerseyArr = re.split(r'; |\\s+', new_df.puntRushers)\n    \n    if JerseyArr[0] == new_df.homeTeamAbbr:\n        teamSide.append('home')\n    else:\n        teamSide.append('away')\n    \n    ## Retrieve the tracking data based on the year\n    if str(new_df.gameId).startswith('2018'):\n        trackingData = globals()['tracking' + '2018']\n    elif str(new_df.gameId).startswith('2019'):\n        trackingData = globals()['tracking' + '2019']\n    else:\n        trackingData = globals()['tracking' + '2020']\n          \n    ## Retrieve nflId of \n    for j in range(0, len(JerseyArr), 2):\n        if JerseyArr[j] == new_df.homeTeamAbbr:\n            supportId_temp.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'home') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))].iloc[0].nflId) )\n        else:\n            supportId_temp.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'away') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))].iloc[0].nflId) )\n \n    ## Append \"supportId_temp\" to \"supportId\"\n    supportId.append(supportId_temp)","398a8ef6":"new_df.apply(lambda x: ksm_blockedpunt(x), axis=1)","6d381269":"df_BlockedPunt_players = pd.DataFrame({\"playResult\": 'punt block', \"team\": [team], \"side\": [teamSide], \"key\": [keyId], \"support\": [supportId]})\n\ndf_BlockedPunt_players = df_BlockedPunt_players.explode(['team','side','key','support']).reset_index(drop=True)","4d0d7b12":"df_BlockedPunt_players","aadd7852":"new_df = merged_df[(merged_df.specialTeamsResult == \"Blocked Kick Attempt\")]\n\nnew_df = new_df.reset_index(drop=True)","bad027ba":"# Check for missing values\nnew_df.specialTeamsSafeties.isna().sum()","3421c718":"# Removing records with missing values\nnew_df = new_df.dropna(subset=['specialTeamsSafeties'])","d443b00a":"team = []\nteamSide = []\nkeyId = []\nsupportId = []\n\n\ndef ksm_blockedkick(new_df):\n    ## Team\n    if new_df.possessionTeam == new_df.homeTeamAbbr:\n        team.append(new_df.visitorTeamAbbr)\n    else:\n        team.append(new_df.homeTeamAbbr)\n        \n    ## Key\n    keyId.append(int(new_df.kickBlockerId))\n    \n    ## Support\n    supportId_temp = [] ## To store one row after each loop, then append to \"supportId\"\n    \n    if new_df.possessionTeam == new_df.homeTeamAbbr:\n        teamSide.append('home')\n    else:\n        teamSide.append('away')\n            \n    if not pd.isna(new_df.specialTeamsSafeties):\n        JerseyArr = re.split(r'; |\\s+', new_df.specialTeamsSafeties)\n        \n\n        ## Retrieve the tracking data based on the year\n        if str(new_df.gameId).startswith('2018'):\n            trackingData = globals()['tracking' + '2018']\n        elif str(new_df.gameId).startswith('2019'):\n            trackingData = globals()['tracking' + '2019']\n        else:\n            trackingData = globals()['tracking' + '2020']\n          \n        ## Retrieve nflId of \n        for j in range(0, len(JerseyArr), 2):\n            if JerseyArr[j] == new_df.homeTeamAbbr:\n                supportId_temp.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'home') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))].iloc[0].nflId) )\n            else:\n                supportId_temp.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'away') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))].iloc[0].nflId) )\n    \n    ## Append \"supportId_temp\" to \"supportId\"\n    supportId.append(supportId_temp)","42141331":"new_df.apply(lambda x: ksm_blockedkick(x), axis=1)","2775aa90":"df_BlockedKickAttempt_players = pd.DataFrame({\"playResult\": 'kick block attempt', \"team\": [team], \"side\": [teamSide], \"key\": [keyId], \"support\": [supportId]})\n\ndf_BlockedKickAttempt_players = df_BlockedKickAttempt_players.explode(['team','side','key','support']).reset_index(drop=True)","ed0fa33f":"df_BlockedKickAttempt_players = df_BlockedKickAttempt_players[~df_BlockedKickAttempt_players.support.str.len().eq(0)].reset_index(drop=True)","2e292230":"new_df = merged_df[(merged_df.specialTeamsResult == \"Return\")]\n\nnew_df = new_df.reset_index(drop=True)","813709fe":"# Checking for missing values\nnew_df.assistTackler.isna().sum()","14f79489":"# Removing records with missing values\nnew_df = new_df.dropna(subset=['assistTackler']).reset_index(drop=True)","8ff87f09":"import re\n\nteam = []\nteamSide = []\n\nkeyArr = []\n\nkeyId = []\nsupportId = []\n\n\ndef ksm_returntackled(new_df):    \n    ## Team\n    if new_df.possessionTeam == new_df.homeTeamAbbr:\n        team.append(new_df.visitorTeamAbbr)\n    else:\n        team.append(new_df.homeTeamAbbr)\n    \n    \n    \n    if new_df.possessionTeam == new_df.homeTeamAbbr:\n        teamSide.append('home')\n    else:\n        teamSide.append('away')\n        \n\n    ## Retrieve the tracking data based on the year\n    if str(new_df.gameId).startswith('2018'):\n        trackingData = globals()['tracking' + '2018']\n    elif str(new_df.gameId).startswith('2019'):\n        trackingData = globals()['tracking' + '2019']\n    else:\n        trackingData = globals()['tracking' + '2020']\n        \n    \n    ## Key\n    keyArr = re.split(r'; |\\s+', new_df.tackler)\n    if keyArr[0] == new_df.homeTeamAbbr:\n        keyId.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'home') & (trackingData.jerseyNumber == int(keyArr[1]))].iloc[0].nflId) )\n    else:\n        keyId.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'away') & (trackingData.jerseyNumber == int(keyArr[1]))].iloc[0].nflId) )\n\n    \n    \n    ## Support\n    supportId_temp = [] ## To store one row after each loop, then append to \"supportId\"\n    \n    if not pd.isna(new_df.assistTackler):\n        JerseyArr = re.split(r'; |\\s+', new_df.assistTackler)\n\n        ## Retrieve nflId of \n        for j in range(0, len(JerseyArr), 2):\n            if JerseyArr[j] == new_df.homeTeamAbbr:\n                supportId_temp.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'home') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))].iloc[0].nflId) )\n            else:\n                supportId_temp.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'away') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))].iloc[0].nflId) )\n \n    ## Append \"supportId_temp\" to \"supportId\"\n    supportId.append(supportId_temp)","efa2d106":"new_df.apply(lambda x: ksm_returntackled(x), axis=1)","6acddeb7":"df_ReturnTackled_players = pd.DataFrame({\"playType\": 'tackle on return', \"team\": [team], \"side\": [teamSide], \"key\": [keyId], \"support\": [supportId]})\n\ndf_ReturnTackled_players = df_ReturnTackled_players.explode(['team','side','key','support']).reset_index(drop=True)","c23b94ea":"df_ReturnTackled_players","b8586e76":"new_df = merged_df[(merged_df.specialTeamsPlayType == \"Punt\") & (merged_df.specialTeamsResult == \"Return\")]\n\nnew_df = new_df.reset_index(drop=True)","16489247":"# Checking missing values\nprint(new_df.returnerId.isna().sum())\nprint(new_df.vises.isna().sum())","56cf315f":"new_df = new_df.dropna(subset=['returnerId','vises']).reset_index(drop=True)","24a503e0":"import re\n\nteam = []\nteamSide = []\n\nkeyArr = []\n\nkeyId = []\nsupportId = []\n\n\ndef ksm_return(new_df):\n    ## Team\n    if new_df.possessionTeam == new_df.homeTeamAbbr:\n        team.append(new_df.visitorTeamAbbr)\n    else:\n        team.append(new_df.homeTeamAbbr)\n    \n    \n    ## Key\n    keyId.append(new_df.returnerId)\n    \n    \n    if new_df.possessionTeam == new_df.homeTeamAbbr:\n        teamSide.append('home')\n    else:\n        teamSide.append('away')\n        \n\n    ## Retrieve the tracking data based on the year\n    if str(new_df.gameId).startswith('2018'):\n        trackingData = globals()['tracking' + '2018']\n    elif str(new_df.gameId).startswith('2019'):\n        trackingData = globals()['tracking' + '2019']\n    else:\n        trackingData = globals()['tracking' + '2020']\n        \n    \n\n    ## Support\n    supportId_temp = [] ## To store one row after each loop, then append to \"supportId\"\n    \n    JerseyArr = re.split(r'; |\\s+', new_df.vises)\n\n    \n    ## Retrieve nflId of SUPPORT\n    for j in range(0, len(JerseyArr), 2):\n        if JerseyArr[j] == new_df.homeTeamAbbr:\n            if len(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'home') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))]) > 0:\n                supportId_temp.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'home') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))].iloc[0].nflId) )\n        else:\n            if len(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'away') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))]) > 0:\n                supportId_temp.append( int(trackingData.loc[(trackingData.gameId == new_df.gameId) & (trackingData.team == 'away') & (trackingData.jerseyNumber == int(JerseyArr[j+1]))].iloc[0].nflId) )\n        \n    ## Append \"supportId_temp\" to \"supportId\"\n    supportId.append(supportId_temp)","1eea1f1a":"new_df.apply(lambda x: ksm_return(x), axis=1)","8501eb45":"df_Return_players = pd.DataFrame({\"playResult\": 'punt return', \"team\": [team], \"side\": [teamSide], \"key\": [keyId], \"support\": [supportId]})\n\ndf_Return_players = df_Return_players.explode(['team','side','key','support']).reset_index(drop=True)","32661cae":"df_Return_players","f6899d23":"alldata.columns","b8f8c0c6":"inputCols = ['gameClock','down', 'quarter', 'yardsToGo',\n             'yardlineSide','yardlineNumber', 'absoluteYardlineNumber',\n             'preSnapVisitorScore', 'preSnapHomeScore',\n             'possessionTeam', 'homeTeamAbbr', 'visitorTeamAbbr', 'nflId', 'gameDate']\nstrategyCols = ['direction', 'kickType']\ngoalCols = ['kickLength','specialTeamsResult','specialTeamsPlayType']\nprint(len(inputCols) + len(strategyCols) + len(goalCols))","3d853814":"def cleanInput(inputs, team_map):\n\n    # count the players age in the play\n    nflid = inputs['nflId']\n    player = players_ori.loc[players.nflId == nflid].to_dict('r')[0]\n\n     # Get the Height data from DataFrame & Split the heights by hyphen (\"-\")\n    player_height = player[\"height\"]\n    player_height = player_height.split(\"-\")\n\n    # Convert Heights to Centimeters and add them to DataFrame\n    if len(player_height) == 2:\n        player[\"height\"] = int(player_height[0]) * 12 + int(player_height[1]) \n    else: \n        player[\"height\"] = int(player_height[0]) * 2.54\n\n    # Convert Weights to Kilograms and them to DataFrame\n    player[\"weight\"] = round(player['weight'] * 0.453592, 2)\n\n    inputs['Position'] = player['Position']\n    inputs['height'] = player['height']\n    inputs['weight'] = player['weight']\n\n    inputs['birthDate'] = datetime.strptime(player['birthDate'], \"%Y-%m-%d\")\n    inputs[\"gameDate\"] = datetime.strptime(inputs[\"gameDate\"], \"%m\/%d\/%Y\")\n\n    inputs[\"age\"]=inputs[\"gameDate\"].year - inputs[\"birthDate\"].year\n    inputs = inputs.drop(labels=[\"birthDate\", \"gameDate\"])\n\n    inputs['gameClock'] = pd.to_timedelta(inputs['gameClock'])\n    inputs['gameClock'] = inputs['gameClock'].total_seconds()\n    #  convert team abbr to number\n    inputs['homeTeamAbbr'] = team_map[inputs['homeTeamAbbr']]\n    inputs['visitorTeamAbbr'] = team_map[inputs['visitorTeamAbbr']]\n    inputs['possessionTeam'] = team_map[inputs['possessionTeam']]\n    inputs['yardlineSide'] = team_map[inputs['yardlineSide']]\n\n    # conver categorical data to number\n    inputs['Position']= pos_map[inputs['Position']]\n    inputs = inputs.astype('float64')\n\n    return inputs\n","1da90d9d":"def getPuntRes(inputs):\n    bestK=0\n    bestD =0\n    bestRes = 0\n    bestProb = 0\n    for k in range(1,4):\n        tmp = []\n        for d in range(1,4):\n            puntInputs = inputs\n\n            puntInputs['kickType'] = k\n            puntInputs['direction'] = d\n            puntInputs = puntInputs[puntInputCols].astype('float64')\n            puntInputs = puntInputs.to_numpy()\n            curRes = puntModel.predict([puntInputs])[0]\n            curProb = puntModel.predict_proba([puntInputs])[0, curRes]\n            \n            if (curRes>bestRes) &(curProb>bestProb) :\n                bestK=k\n                bestD =d\n                bestRes = curRes\n                bestProb = curProb\n\n    return bestK, bestD, bestRes, bestProb","2e3906a6":"re_kick_map ={\n    1: 'Normal - standard punt style',\n    3: 'Rugby style punt',\n    2: 'Nose down or Aussie-style punts' }","6f0cdf98":"re_dir_map ={\n    2: 'Left', 3: 'Right', 1: 'Center'}","84cf4f09":"punt_res_map = {\n    0:'less than 30',\n    1:\"between 30 and 45\",\n    2:\"between 45 and 60\",\n    3: 'over 60'\n}","92e741bc":"type_map ={0:'FG',1:'nonSP',2:'Punt'}","cb53372d":"def predict(inputs):\n    if inputs.possessionTeam == inputs.homeTeamAbbr:\n        opponentTeam = inputs.visitorTeamAbbr\n    else:\n        opponentTeam = inputs.homeTeamAbbr\n    \n    Type=[]\n    inputs = cleanInput(inputs, team_map)\n    # predict play type\n    typeInputs = inputs[typeInputCol].to_numpy()\n    typeRes = typeModel.predict_proba([typeInputs])\n    Type.append(np.argwhere(typeRes == np.max(typeRes))[0,1])\n    Type.append(np.argwhere(typeRes == np.unique(typeRes)[-2])[0,1])\n#     print(typeRes)\n#     print(Type)\n\n    \n    for idx, t in enumerate(Type):\n        print(f'No. {idx+1} recommended play type: {type_map.get(t)}')\n        \n        # FG\n        if t == 0:\n            fgInputs = inputs[fgInputCols].to_numpy()\n            fgSuccessRate = fgModel.predict_proba([fgInputs])[0,1]\n            print(f'    Success rate of Field Goal is {round(fgSuccessRate*100,2)}%\\n')\n            \n            if len(df_BlockedKickAttempt_players[df_BlockedKickAttempt_players.team == opponentTeam]) > 0:\n                df_BlockedKickAttempt_players[df_BlockedKickAttempt_players.team == opponentTeam].apply(lambda x: idReplace(x), axis=1)\n                \n            print(\"--------------------------------------\\n\")    \n        \n        elif t == 1:\n            print('Non-special team result')\n        \n        # Punt\n        else:\n            k, d, res, prob = getPuntRes(inputs)\n            resKick = re_kick_map.get(k)\n            resDir = re_dir_map.get(d)\n            puntRes = punt_res_map.get(res)\n            puntProb = round(prob*100)\n            print(f'    Suggested strategy for Punt: \\n    Direction: {resDir}, KicktType: {resKick}')\n            print(f'    Prediction: {puntProb}% of change kick to the distance {puntRes}\\n')\n            \n            if len(df_BlockedPunt_players[df_BlockedPunt_players.team == opponentTeam]) > 0:\n               df_BlockedPunt_players[df_BlockedPunt_players.team == opponentTeam].apply(lambda x: idReplace(x), axis=1)\n            \n            print(\"--------------------------------------\\n\") \n        \n\n","80329056":"try_inputs = rawDf.loc[120]\ntry_inputs = try_inputs[inputCols]\npredict(try_inputs)","83ea4895":"# \"Play Type Recommendation System & Result Prediction\"","82013fa4":"# Step 2 - Preprocessing\n","6056d5ff":"### Train Model","958666fe":"## Punt Model","ed9f0ecb":"> American Football is a very fast pace sports, during the match coaches might have to make certain strategic judgements within a small time period.\n\n> We are trying to build a recommendation system to facilitate coaches to make faster and more sound judgements! By entering some parameters of the current circumstance (e.g. quarter, scores, opponent team), the system will recommend the best formation of play (play type) in descending order, with success rate and even suggested strategy (including kick type and direction). The expected result will also be predicted, such as kick length of a punt.\nEven if coaches have this huge load of historical data that they can study, but such amount cannot be processed by a human's mind, especially not during a match. But with a tool like this, strategic decisions can be generated in a blink and with the support of the big data as well.\n\n> Besides strategies of own team, as American Football is a team sports, synergy plays a very important factor on strategy planning. But in this case, we are trying to predict the key and support players of the opponent team that own team need to be aware when doing certain types of play.","50f600e2":"## (a) Blocked Punt - kickBlockerId & puntRushers","f6830e4e":"## Some shared functions","4d7983fc":"## Import libs","85276dfb":"## Field Goal Model","6db89c4b":"# Step 4 - Building whole model","7627517d":"## (d) Return (returnerId & vises)","665c312e":"## Synergy Matrix\n### (Effective combination of Key + Support player)","38231863":"### Clean data","5639ebb3":"# Step 3 - Exploratory Data Analysis","11ab10c0":"## Clean and combine data","325e7662":"create y data","5daf9479":"## Compress size for saving memory space","0fb0cc22":"# Step 5 - Recommendation System \/ Prediction","cb439259":"### Combine data ","dc7a8d7a":"### Train model","d495876e":"## Play Type Classifier","c28fda3b":"## (c) Tackle on return - tacklers & assistTacklers","890debee":"### Prepare data","b4e21889":"### Clean train data","509eb629":"### Prepare data","d9ecf240":"### Before combining","dacde36f":"### Train model","6fa8d0b9":"# Step 1 - Importing files ","0d00d2b7":"## (b) Blocked Kick attempt (Field Goal\/Extra Point) - kickBlockerId & specialTeamsSafeties"}}