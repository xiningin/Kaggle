{"cell_type":{"c4df140a":"code","c7a77c4b":"code","058400f4":"code","a4a1dd7a":"code","671848c1":"code","c234f4fb":"code","4cf85919":"code","1bb12a88":"code","792ac7b2":"code","ca602afb":"code","6c802ae5":"code","4050d828":"code","0008eff3":"code","883c84a1":"code","4ecf4ecb":"code","3642efcf":"code","1fa73304":"code","1dd0522e":"code","3b5a39d2":"code","857d7cbf":"code","d7601f23":"code","40f14b56":"code","f9ce6a30":"markdown","28c15ac8":"markdown","ebd6040f":"markdown","57d5b864":"markdown","94b6a7a1":"markdown","0d1f7886":"markdown","0d516514":"markdown","e2eb8dd0":"markdown","53146e96":"markdown"},"source":{"c4df140a":"!pip install jcopdl\n!pip install jcopml","c7a77c4b":"import jcopdl\nimport numpy as np\nimport matplotlib.pyplot as plt","058400f4":"import torch\nfrom torch import nn, optim\nfrom jcopdl.callback import Callback, set_config","a4a1dd7a":"device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\ndevice","671848c1":"from torchvision import datasets, transforms\nfrom torch.utils.data import DataLoader","c234f4fb":"bs = 128\ncrop_size = 64\n\ntrain_transform = transforms.Compose([\n    transforms.RandomRotation(15),\n    transforms.RandomSizedCrop(crop_size, scale=(0.6, 0.9)),\n    transforms.ColorJitter(brightness=0.3),\n    transforms.ToTensor()\n])\n\ntest_transform = transforms.Compose([\n    transforms.Resize(70),\n    transforms.CenterCrop(crop_size),\n    transforms.ToTensor()\n])\n\ntrain_set = datasets.ImageFolder(\"\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/train\/\", transform=train_transform)\ntrainloader = DataLoader(train_set, batch_size=bs, shuffle=True, num_workers=4)\n\ntest_set = datasets.ImageFolder(\"\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/val\/\", transform=test_transform)\ntestloader = DataLoader(test_set, batch_size=bs, shuffle=True)","4cf85919":"feature, target = next(iter(trainloader))\nfeature.shape","1bb12a88":"label2cat = train_set.classes\nlabel2cat","792ac7b2":"from jcopdl.layers import conv_block, linear_block","ca602afb":"# conv_block = (\n#     nn.Conv2d(3, 8, 3, 1, 1),\n#     nn.ReLU(),\n#     nn.MaxPool2d(2, 2)\n# )","6c802ae5":"class CNN(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv = nn.Sequential(\n            conv_block(3, 8),\n            conv_block(8, 16),\n            conv_block(16, 32),\n            conv_block(32, 64), \n            nn.Flatten()\n        )\n        \n        self.fc = nn.Sequential(\n            linear_block(1024, 256, dropout=0.1),\n            linear_block(256, 2, activation=\"lsoftmax\")\n        )\n        \n    def forward(self, x):\n        x = self.conv(x)\n        x = self.fc(x)\n        return x","4050d828":"config = set_config({\n    \"batch_size\": bs,\n    \"crop_size\": crop_size\n})","0008eff3":"model = CNN().to(device)\ncriterion = nn.NLLLoss()\noptimizer = optim.AdamW(model.parameters(), lr=0.001)\ncallback = Callback(model, config, outdir=\"model\")","883c84a1":"from tqdm.auto import tqdm\n\ndef loop_fn(mode, dataset, dataloader, model, criterion, optimizer, device):\n    if mode == \"train\":\n        model.train()\n    elif mode == \"test\":\n        model.eval()\n    cost = correct = 0\n    for feature, target in tqdm(dataloader, desc=mode.title()):\n        feature, target = feature.to(device), target.to(device)\n        output = model(feature)\n        loss = criterion(output, target)\n        \n        if mode == \"train\":\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n        \n        cost += loss.item() * feature.shape[0]\n        correct += (output.argmax(1) == target).sum().item()\n    cost = cost \/ len(dataset)\n    acc = correct \/ len(dataset)\n    return cost, acc","4ecf4ecb":"while True:\n    train_cost, train_score = loop_fn(\"train\", train_set, trainloader, model, criterion, optimizer, device)\n    with torch.no_grad():\n        test_cost, test_score = loop_fn(\"test\", test_set, testloader, model, criterion, optimizer, device)\n    \n    # Logging\n    callback.log(train_cost, test_cost, train_score, test_score)\n\n    # Checkpoint\n    callback.save_checkpoint()\n        \n    # Runtime Plotting\n    callback.cost_runtime_plotting()\n    callback.score_runtime_plotting()\n    \n    # Early Stopping\n    if callback.early_stopping(model, monitor=\"test_score\"):\n        callback.plot_cost()\n        callback.plot_score()\n        break","3642efcf":"feature, target = next(iter(testloader))\nfeature, target = feature.to(device), target.to(device)","1fa73304":"with torch.no_grad():\n    model.eval()\n    output = model(feature)\n    preds = output.argmax(1)\npreds","1dd0522e":"from matplotlib import pyplot as plt","3b5a39d2":"fig, axes = plt.subplots(6, 6, figsize=(24, 24))\nfor image, label, pred, ax in zip(feature, target, preds, axes.flatten()):\n    ax.imshow(image.permute(1, 2, 0).cpu())\n    font = {\"color\": 'r'} if label != pred else {\"color\": 'g'}        \n    label, pred = label2cat[label.item()], label2cat[pred.item()]\n    ax.set_title(f\"L: {label} | P: {pred}\", fontdict=font);\n    ax.axis('off');","857d7cbf":"from jcopml.utils import save_model","d7601f23":"save_model(model, \"xray_chest_pneumonia_v1.pkl\")","40f14b56":"test_set_final = datasets.ImageFolder(\"\/kaggle\/input\/chest-xray-pneumonia\/chest_xray\/test\", transform=test_transform)\ntestloader_final = DataLoader(test_set_final, batch_size=bs)\n\nwith torch.no_grad():\n    test_cost_final, test_score_final = loop_fn(\"test\", test_set_final, testloader_final, model, criterion, optimizer, device)\n    print(f\"Test Accuracy: {test_score_final}\")    ","f9ce6a30":"# Visualization","28c15ac8":"# Save Model","ebd6040f":"label category","57d5b864":"# Training","94b6a7a1":"# Architecture & Config","0d1f7886":"# Training Preparation --> MCOC ","0d516514":"# Predict","e2eb8dd0":"# Evaluation","53146e96":"# Dataset & Dataloader "}}