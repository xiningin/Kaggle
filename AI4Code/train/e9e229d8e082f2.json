{"cell_type":{"ae42a218":"code","aa76026e":"code","a7172de4":"code","e46cfab3":"code","0678c7e5":"code","44cf47a3":"code","53d82a1d":"code","38a85cb3":"code","f15298ab":"code","2dabe61c":"code","8dd3039d":"code","e79eb666":"code","c61c3da2":"code","46e5b6c2":"code","581be903":"code","8c47acbf":"code","36a5fd2a":"code","75916f08":"code","942d264b":"code","48598528":"code","f9dec5ff":"code","de1252c0":"code","2ef08ba1":"code","78bdac71":"code","3bb0eb5d":"code","be20f0fb":"code","e3864615":"code","41f51677":"code","5b4b436e":"code","53664146":"code","c9147f4b":"code","93e438a9":"code","7f46af1e":"code","48216b8d":"code","8951a572":"code","28c3eda1":"code","34a106cd":"code","9a249d74":"code","6b7fe61f":"code","08ae15f1":"code","1d269082":"code","c3feef3c":"code","55c7536a":"code","26b1e4a6":"code","c6424d03":"code","7a8c1ab5":"code","79cd3076":"code","4d0c32f0":"code","b51dbab9":"code","47290896":"code","2e1a2883":"code","8f7b3a02":"code","ddaec3cf":"code","4e77c2f9":"code","f7e284d9":"code","90f67541":"code","0aaef253":"code","5a0dcee2":"code","2fdbebca":"code","ed5fbe91":"code","04444206":"code","504074d8":"code","715534da":"code","1d72ce82":"code","648e19c5":"code","d4f33150":"code","f07e8389":"code","f8516ae5":"code","3f3b05fc":"code","e06115bf":"code","4228c71c":"code","245153a7":"code","dd5c9772":"code","84e021b0":"code","9a4e248c":"code","b22f6f13":"code","06c2f713":"code","625a8077":"code","91da079c":"code","7e816e2f":"code","dcc3842a":"code","b5431b6c":"code","e36cefee":"code","62a69ae9":"code","e9bbd38b":"code","d16de260":"markdown","7035ab22":"markdown","bf26895e":"markdown","2e96c91f":"markdown","c9c44f69":"markdown","3d610cac":"markdown","cb7c0cb6":"markdown","43df18c2":"markdown","4444c442":"markdown","28b0914e":"markdown","cd8a4bbb":"markdown","7d88d670":"markdown","e467e31f":"markdown","d6d147cd":"markdown","a7d13c88":"markdown","e61d0087":"markdown","80ab665c":"markdown","6b5f2512":"markdown","f8647127":"markdown","d5276d9d":"markdown","58696849":"markdown","cfa56688":"markdown","bd95cdb9":"markdown","1148e4e5":"markdown","e9b30443":"markdown","e00438b4":"markdown","285b2938":"markdown"},"source":{"ae42a218":"! pip install calmap","aa76026e":"import calmap","a7172de4":"! pip install squarify","e46cfab3":"import squarify","0678c7e5":"import os\n    \n# Main libraries that we will use in this kernel\nimport datetime\nimport numpy as np\nimport pandas as pd\n\n# # garbage collector: free some memory is needed\nimport gc\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# statistical package and some useful functions to analyze our timeseries\nfrom statsmodels.tsa.stattools import pacf\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nimport statsmodels.tsa.stattools as stattools\n\nimport time\n\nfrom string import punctuation\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.linear_model import LinearRegression\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","44cf47a3":"PATH_DATA = \"..\/input\/nuclio07-dsc-0421\"","53d82a1d":"def print_files():\n    for dirname, _, filenames in os.walk(PATH_DATA):\n        for filename in filenames:\n            print(os.path.join(dirname, filename))","38a85cb3":"# Let's see how many different files we are dealing with\nprint_files()","f15298ab":"# import the df\nshops = pd.read_csv(os.path.join(PATH_DATA, \"shops.csv\"))\nshops.shape","2dabe61c":"shops.head()","8dd3039d":"# We don't have any duplicates in the shop_name field\nshops.shape[0] == len(shops[\"shop_name\"].unique())","e79eb666":"# However inspecting the df by name, we can see that shop_id 10 and 11 are very similar. Later we will try and group them once we inspect the sales per shop\nshops[shops[\"shop_id\"].isin([10, 11])]","c61c3da2":"# The same happens with the shops with shop_id 23 and 24\nshops[shops[\"shop_id\"].isin([23, 24])]","46e5b6c2":"# No missing values in the shops df\nshops.isnull().sum().sum()","581be903":"city_dict = {\n    2 : 'Adygea',\n    3 : 'Balashikha',\n    4 : 'Volzhski',\n    5 : 'Vlogda',\n    6 : 'Voronezh',\n    7 : 'Voronezh',\n    8 : 'Voronezh',\n    9 : 'Comercio Ambulante',\n    11 : 'Zhukovsky',\n    12 : 'Tienda Online',\n    13 : 'Kazan',\n    14 : 'Kazan',\n    15 : 'Kaluga',\n    16 : 'Kolomna',\n    17 : 'Krasnoyarsk',\n    18 : 'Krasnoyarsk',\n    19 : 'Kursk',\n    20 : 'Mosc\u00fa',\n    21 : 'Mosc\u00fa',\n    22 : 'Mosc\u00fa',\n    24 : 'Mosc\u00fa',\n    25 : 'Mosc\u00fa',\n    26 : 'Mosc\u00fa',\n    27 : 'Mosc\u00fa',\n    28 : 'Mosc\u00fa',\n    29 : 'Mosc\u00fa',\n    30 : 'Mosc\u00fa',\n    31 : 'Mosc\u00fa',\n    32 : 'Mosc\u00fa',\n    33 : 'Mytishchi',\n    34 : 'Nizhny Novgorod',\n    35 : 'Nizhny Novgorod',\n    36 : 'Novosibirsk',\n    37 : 'Novosibirsk',\n    38 : 'Omsk',\n    39 : 'Rostov Na Donu',\n    40 : 'Rostov Na Donu',\n    41 : 'Rostov Na Donu',\n    42 : 'San Petersburgo',\n    43 : 'San Petersburgo',\n    44 : 'Samara',\n    45 : 'Samara',\n    46 : 'Posad',\n    47 : 'Surgut',\n    48 : 'Tomsk',\n    49 : 'Tyumen',\n    50 : 'Tyumen',\n    51 : 'Tyumen',\n    52 : 'Ufa',\n    53 : 'Ufa',\n    54 : 'Khimki',\n    55 : 'Tienda Online',\n    56 : 'Checos',\n    57 : 'Yakutsk',\n    58 : 'Yakutsk',\n    59 : 'Yaroslavl'\n}","8c47acbf":"def fix_shops(shops, city_dict):\n    '''\n    This function modifies the shops df inplace.\n    It correct's 3 shops that we have found to be 'duplicates'\n    and also creates a few more features: extracts the city and encodes it using LabelEncoder\n    '''\n    shops = shops[~shops[\"shop_id\"].isin([0, 1, 10, 23])]\n\n    # replace all the punctuation in the shop_name columns\n    shops[\"shop_name_cleaned\"] = shops[\"shop_name\"].apply(lambda s: \"\".join([x for x in s if x not in punctuation]))\n    \n    # extract the city name\n    shops[\"city\"] = shops[\"shop_id\"].map(city_dict)\n    \n    # encode it using a simple LabelEncoder\n    shops[\"city_code\"] = LabelEncoder().fit_transform(shops['city'])\n    \n    return shops","36a5fd2a":"# apply our function to the shops_df\nshops = fix_shops(shops, city_dict)","75916f08":"# import df\nitems_category = pd.read_csv(os.path.join(PATH_DATA, \"item_categories.csv\"))\nitems_category.shape","942d264b":"items_category.head()","48598528":"# We don't have any duplicates in the item_category_name field\nitems_category.shape[0] == len(items_category[\"item_category_name\"].unique())","f9dec5ff":"# allow pandas to show all the rows from this df\npd.options.display.max_rows = items_category.shape[0]","de1252c0":"# If we take a closer look, we can see that we have a lot of Play Station categories: like accesories, games and so on. We have the same categories for XBOX and also for PC Games.\n# A lot of categories have to deal with books, presents and computer software and music (CD).\n# We will generate later some features by parsing the names and making groupedby features.\nitems_category.head()","2ef08ba1":"# If we apply a simple lambda function and extract the everything that contains PS, we will get 16 different categories for PlayStation\nitems_category[\"PS_flag\"] = items_category[\"item_category_name\"].apply(lambda x: True if \"PS\" in x else False)\nitems_category[items_category[\"PS_flag\"] == True]","78bdac71":"# No missing values in the items_category df\nitems_category.isnull().sum().sum()","3bb0eb5d":"# import df\nitems = pd.read_csv(os.path.join(PATH_DATA, \"items.csv\"))\nitems.shape","be20f0fb":"# allow pandas to show all the rows from this df\npd.options.display.max_rows = items.shape[0]\nitems.head()","e3864615":"# No missing values in the items category\nitems.isnull().sum().sum()","41f51677":"# Let's see the top 10 and bottom 10 item categories\nitems_gb = items.groupby(\"item_category_id\").size().sort_values(ascending = False).to_frame()\nitems_gb.head()","5b4b436e":"items_gb.rename(columns = {0:\"counts\"}, inplace = True)","53664146":"top_10 = items_gb[:10]","c9147f4b":"bottom_10 = items_gb[-10:]","93e438a9":"top_10 = top_10.append(bottom_10)\ntop_10 = top_10.sort_values(\"counts\", ascending = False)","7f46af1e":"top_10.reset_index()","48216b8d":"# We can notice that in the top 10 most popular items products we have PS3\n# At the same time, in the bottom 10 products, we can find 2 PS2.\n# This means, that we have to be careful while generating features like PS\npd.merge(top_10, items_category, left_on = \"item_category_id\", right_on = \"item_category_id\")","8951a572":"# import df\nsales = pd.read_csv(os.path.join(PATH_DATA, \"sales_train.csv\"))\nsales.shape","28c3eda1":"sales.sample(10)","34a106cd":"sales.info()","9a249d74":"# No null values in the sales df\n\n# Is this True?\n\nsales.isnull().sum()","6b7fe61f":"sorted(list(sales[\"item_cnt_day\"].unique()))[:20]","08ae15f1":"del shops, items_category, items, sales\ngc.collect()","1d269082":"# a simple function that creates a global df with all joins and also shops corrections\ndef create_df(path, city_dict):\n    '''\n    This is a helper function that creates the train df.\n    '''\n    # import all df\n    shops = pd.read_csv(os.path.join(path, \"shops.csv\"))                    \n    items_category = pd.read_csv(os.path.join(path, \"item_categories.csv\"))\n    items = pd.read_csv(os.path.join(path, \"items.csv\"))\n    sales = pd.read_csv(os.path.join(path, \"sales_train.csv\"))\n    \n    # fix shop_id in sales so that we can leater merge the df\n    \n    d_shops = {0:57, 1:58, 10:11, 23:24}\n    sales[\"shop_id\"] = sales[\"shop_id\"].map(lambda shop_id: d_shops[shop_id] if shop_id in d_shops.keys() else shop_id)\n    sales_shape_start = sales.shape[0]\n    shops = fix_shops(shops, city_dict) # fix the shops as we have seen before\n    \n    # create df by merging the previous dataframes\n    df = pd.merge(items, items_category, left_on = \"item_category_id\", right_on = \"item_category_id\")\n    df = pd.merge(sales, df, left_on = \"item_id\", right_on = \"item_id\")\n    df = pd.merge(df, shops, left_on = \"shop_id\", right_on = \"shop_id\")\n    \n    # sort the values\n    df.sort_values(by = [\"shop_id\", \"date\"], ascending = True, inplace = True)\n    df_shape_end = df.shape[0]\n    \n    assert sales_shape_start == df_shape_end, \"You have created a cartessian!\"\n    \n    return df","c3feef3c":"df = create_df(path = PATH_DATA, city_dict = city_dict)","55c7536a":"# It seems that there are no null values, however this is not fully true. \n# As we will see in the next section, when we groupby and plot the data, there are a lot of months where there have been no sales so basically it's a null value, and we have to impute zero sales for that month.\ndf.isnull().sum().sum()","26b1e4a6":"df.info()","c6424d03":"# Let's group by Month and see all the sales\n\n# resample in timeseries is the same as groupby\n# in order it to work, we must set the date column as index, and it must be a datetime format (strings are not valid)\n# when we resample it, we can pass D: daily, W: weekly or M: monthly\n# we can then perform operation on the 'resampled' columns like\n# sum, mean and others.\n\n# calculate the monthly sales\ndf[\"date\"] = pd.to_datetime(df[\"date\"], format = \"%d.%m.%Y\")","7a8c1ab5":"df[\"Year\"] = df[\"date\"].dt.year","79cd3076":"df[\"Month\"] = df[\"date\"].dt.month","4d0c32f0":"df.head()","b51dbab9":"# resample the data on a monthly basis\nx = df[[\"date\", \"item_cnt_day\"]].set_index(\"date\").resample(\"M\").sum()\n\n# plot the data using matplotlib\nplt.figure(figsize = (10, 6))\nplt.plot(x, color = \"blue\", label = \"Monthly sales\")\nplt.title(\"Monthly sales\")\nplt.legend();","47290896":"# perform the same operations but on a weekly basis\nx = df[[\"date\", \"item_cnt_day\"]].set_index(\"date\").resample(\"W\").sum()\n\nplt.figure(figsize = (10, 6))\nplt.plot(x.index, x, color = \"blue\", label = \"Weekly sales\")\nplt.title(\"Weekly sales\")\nplt.legend();","2e1a2883":"russian_holidays_start = [\ndatetime.datetime(2013, 1, 1),\ndatetime.datetime(2013, 2, 23),\ndatetime.datetime(2013, 3, 8),\ndatetime.datetime(2013, 5, 1),\ndatetime.datetime(2013, 5, 9),\ndatetime.datetime(2013, 6, 12),\ndatetime.datetime(2013, 11, 4),\n\ndatetime.datetime(2014, 1, 1),\ndatetime.datetime(2014, 2, 23),\ndatetime.datetime(2014, 3, 8),\ndatetime.datetime(2014, 5, 1),\ndatetime.datetime(2014, 5, 9),\ndatetime.datetime(2014, 6, 12),\ndatetime.datetime(2014, 11, 4),\n\ndatetime.datetime(2015, 1, 1),\ndatetime.datetime(2015, 2, 23),\ndatetime.datetime(2015, 3, 8),\ndatetime.datetime(2015, 5, 1),\ndatetime.datetime(2015, 5, 9),\ndatetime.datetime(2015, 6, 12),\ndatetime.datetime(2015, 11, 4)\n]","8f7b3a02":"russian_holidays_end = [\ndatetime.datetime(2013, 1, 8),\ndatetime.datetime(2013, 2, 23),\ndatetime.datetime(2013, 3, 8),\ndatetime.datetime(2013, 5, 1),\ndatetime.datetime(2013, 5, 9),\ndatetime.datetime(2013, 6, 12),\ndatetime.datetime(2013, 11, 4),\n\ndatetime.datetime(2014, 1, 8),\ndatetime.datetime(2014, 2, 23),\ndatetime.datetime(2014, 3, 8),\ndatetime.datetime(2014, 5, 1),\ndatetime.datetime(2014, 5, 9),\ndatetime.datetime(2014, 6, 12),\ndatetime.datetime(2014, 11, 4),\n\ndatetime.datetime(2015, 1, 8),\ndatetime.datetime(2015, 2, 23),\ndatetime.datetime(2015, 3, 8),\ndatetime.datetime(2015, 5, 1),\ndatetime.datetime(2015, 5, 9),\ndatetime.datetime(2015, 6, 12),\ndatetime.datetime(2015, 11, 4)\n]","ddaec3cf":"def create_ma_df(df, column_to_filter, iterable, period):\n\n    short_df = df[df[column_to_filter] == iterable][[\"date\",\"item_cnt_day\"]]\n    short_df[\"date\"] = pd.to_datetime(short_df[\"date\"], format = \"%d.%m.%Y\")\n    short_df[\"YEAR\"] = short_df[\"date\"].dt.year\n    short_df = short_df.set_index(\"date\").groupby(\"YEAR\").resample(period)[\"item_cnt_day\"].sum()\n    short_df = short_df.reset_index()\n    \n    short_df[f\"MA3{period}\"] = short_df[\"item_cnt_day\"].rolling(window = 3).mean()\n    short_df[f\"MA4{period}\"] = short_df[\"item_cnt_day\"].rolling(window = 4).mean()\n    short_df[f\"MA5{period}\"] = short_df[\"item_cnt_day\"].rolling(window = 5).mean()\n    \n    return short_df","4e77c2f9":"ITERABLE_COLUMN = \"shop_name\"\n# ITERABLE_COLUMN = \"item_category_name\"\n# ITERABLE_COLUMN = \"city\"\n\nfor iterable in sorted(list(df[ITERABLE_COLUMN].unique()))[:5]:\n\n    #######################################################################################\n    # Monthly sales\n    #######################################################################################\n    \n    # create the size of the figure\n    plt.figure(figsize = (30, 10))\n    plt.subplot(1, 2, 1)\n    \n    # create a df with ma sales\n    short_df = create_ma_df(df, ITERABLE_COLUMN, iterable, \"M\")\n    \n    # preparing the data to plot\n    sales = short_df[\"item_cnt_day\"]\n    dates = short_df[\"date\"]\n    average_3_months = short_df[\"MA3M\"]\n\n    # plot the data and add label\n    plt.plot(dates, sales, 'o-', label = \"Monthly sales\")\n    plt.plot(dates, average_3_months, '.-', label = \"Average sales of the last 3 months\")\n\n    # get current axis and plot the areas\n    ax = plt.gca()\n    alpha = 0.2\n    \n    for start_date, end_date in zip(russian_holidays_start, russian_holidays_end):\n        \n        # add shaded areas for holidays 2013\n        ax.axvspan(start_date, end_date, alpha = alpha, color = 'red')    \n       \n    # add title and show legend    \n    plt.title('Monthly sales of shop {}'.format(iterable))\n    plt.ylabel('Total Monthly sales of shop {}'.format(iterable))\n    plt.xlabel(\"Time grouped by month\")\n    plt.legend()\n    \n    #######################################################################################\n    # Weekly sales\n    #######################################################################################\n    \n    plt.subplot(1, 2, 2)\n    \n    # create a df with ma sales\n    short_df = create_ma_df(df, ITERABLE_COLUMN, iterable, \"W\")\n    \n    # preparing the data to plot\n    sales = short_df[\"item_cnt_day\"]\n    dates = short_df[\"date\"]\n    average_3_weeks = short_df[\"MA3W\"]\n\n    # plot the data and add label\n    plt.plot(dates, sales, 'o-', label = \"Weekly sales\")\n    plt.plot(dates, average_3_weeks, '.-', label = \"Average sales of the last 3 weeks\")\n    \n    # get current axis and plot the areas\n    ax = plt.gca()\n    \n    for start_date, end_date in zip(russian_holidays_start, russian_holidays_end):\n        \n        # add shaded areas for holidays 2013\n        ax.axvspan(start_date, end_date, alpha = alpha, color = 'red')\n    \n    # add title and show legend\n    plt.title('Weekly sales of shop {}'.format(iterable))\n    plt.ylabel('Total Weekly sales of shop {}'.format(iterable))\n    plt.xlabel(\"Time grouped by week\")\n    plt.legend()\n    \n    # general sales\n    plt.show()","f7e284d9":"# we can observe a general trend of decrasing sales.\n# let's add a second axis to see the variation of intradays sales\n\n# select the columns of interest\ndf_var = df[[\"date\", \"item_cnt_day\"]]\n\n# convert to datetime\ndf_var[\"date\"] = pd.to_datetime(df[\"date\"], format = \"%d.%m.%Y\")\n\n# set date as index\ndf_var.set_index(\"date\", inplace = True)\n\n# resample\/groupby by date and convert to frame the total daily sales\ndf_var = df_var.resample(\"M\")[\"item_cnt_day\"].sum().to_frame()\n\n# calculate the intra week variation between total sales\ndf_var[\"Variation\"] = df_var[\"item_cnt_day\"].diff()\/df_var[\"item_cnt_day\"].shift(1)\n\ndf_var.head()","90f67541":"# separate x and y\ny_sales = df_var[\"item_cnt_day\"]\ny_variation = df_var[\"Variation\"]\n\n# instanciate the figure\nfig = plt.figure(figsize = (15, 10))\nax = fig.add_subplot(111)\n\n# plot the total sales\nplot1 = ax.plot(y_sales, label = \"Total monthly sales\", color = \"blue\", alpha = 0.5)\n\n# create a secondary axis and plot the variation data\nax_bis = ax.twinx()\nplot2 = ax_bis.plot(y_variation, label = \"Intra - month variation of sales\", color = \"red\", alpha = 0.5)\n\n# create a common legend for both plots\nlns = plot1 + plot2\nlabs = [l.get_label() for l in lns]\nax.legend(lns, labs, loc = \"upper left\")\n\n# add a custom title to the plot\nax.set_title(\"Total monthly sales and variation\");","0aaef253":"# start with the regular df\ndf_for_question_1 = create_df(PATH_DATA, city_dict)","5a0dcee2":"# calendar heatmaps are really useful to see the overall activity for a certain period of time per day and per month.\n# let's build one using python.\n# we will be using the calmap package for this, because it makes it extremenly easy to plot this data\n# select the columns\ndf_calendar = df[[\"date\", \"item_cnt_day\"]]\n\n# set date as index and resample\ndf_calendar.set_index(\"date\", inplace = True)\n# notice that this time, we don't convert it to_frame()\n# df_calendar is a pandas series\n# THIS IS IMPORTANT since calmap expects a series\n# with a datetime index and the values to plot\ndf_calendar = df_calendar.resample(\"D\")[\"item_cnt_day\"].sum()\ndf_calendar.head()","2fdbebca":"# ----------------------------------------------------------------------------------------------------\n# plot the data using calmap\ncalmap.calendarplot(df_calendar, # pass the series\n                    fig_kws = {'figsize': (16,10)}, \n                    yearlabel_kws = {'color':'black', 'fontsize':14}, \n                    subplot_kws = {'title':'Total sales per year'});","ed5fbe91":"# This plot are fundamental in timeseries analysis.\n# Basically here we compare the a series again itself but with some lags.\n# These are plots that graphically summarize the strength of a relationship with an observation in a time series with observations at prior time steps.\n\n# More info: \n# https:\/\/machinelearningmastery.com\/gentle-introduction-autocorrelation-partial-autocorrelation\/\n\n# ----------------------------------------------------------------------------------------------------\n# instanciate the figure\nfig, (ax1, ax2) = plt.subplots(1, 2,figsize = (16,6), dpi = 80)\n\n# ----------------------------------------------------------------------------------------------------\n# plot the data using the built in plots from the stats module\n\n# The AutoCorrelation plot: compares a value v with the value v but n times in the past.\nplot_acf(df.set_index(\"date\").resample(\"D\")[\"item_cnt_day\"].sum(), ax = ax1, lags = 14)\n\n# The Parcial AutoCorrelation plot: partial autocorrelation at lag k is the correlation that results after removing the effect of any correlations due to the terms at shorter lags.\nplot_pacf(df.set_index(\"date\").resample(\"D\")[\"item_cnt_day\"].sum(), ax = ax2, lags = 14);","04444206":"# This code snippets show you have to calculate the Partial Autocorrelation\n# Partial Autocorrelation can be very counter intuitive since in some of our steps we are fitting a linear model\n# to predict the values of t - 2 using t - 1\n# Wait, what? Why we use values from yesterday to predict values before yesterday?\n# Basically because we assume that our timeseries is auto regressive. This means that the data at point t captures\n# all the variance\/information from all the previuos data points.\n# This way, t - 1, must have captured all the variance from previous points, thus t - 2, and so t - 1 becomes\n# a good predictor for values from t - 2.","504074d8":"# create a dataframe with total sales per day (all shops and all items)\ndf_total_sales = df.set_index(\"date\").resample(\"D\")[\"item_cnt_day\"].sum().to_frame()\n\n# rename the column item_cnt_day to total_sales\ndf_total_sales.columns = [\"total_sales\"]\n","715534da":"df_total_sales.head()","1d72ce82":"\n# create a few features that we need in order to calculate the parcial autocorrelation\ndf_total_sales[\"T-1\"] = df_total_sales[\"total_sales\"].shift(1)\ndf_total_sales[\"T-2\"] = df_total_sales[\"total_sales\"].shift(2)\n\n# we have a few nan for the first 2 rows so we must drop them\nprint(df_total_sales.shape)\ndf_total_sales.dropna(axis = \"rows\", inplace = True)\nprint(df_total_sales.shape)","648e19c5":"# instanciate the Linear model\nmodel = LinearRegression()\n\n# separate X and y\nX = df_total_sales[[\"T-1\"]]\ny = df_total_sales[\"total_sales\"]\n\n# fit and predict with the model\nmodel.fit(X, y)\npredictions = model.predict(X)\n\n# save our predictions to the total_sales df\ndf_total_sales[\"total_sales_from_T-1\"] = predictions","d4f33150":"df_total_sales.head()","f07e8389":"# instanciate the Linear model\nmodel = LinearRegression()\n\n# separate X and y\nX = df_total_sales[[\"T-1\"]]\ny = df_total_sales[\"T-2\"]\n\n# fit and predict with the model\nmodel.fit(X, y)\npredictions = model.predict(X)\n\n# save our predictions to the total_sales df\ndf_total_sales[\"T-2_from_T-1\"] = predictions","f8516ae5":"df_total_sales.head()","3f3b05fc":"# calculate the residual\n# this means: total_sales - total_sales_from_T-1\n# and: T-2 - \"T-2_from_T-1\"\ndf_total_sales[\"Residual_total_sales_T-1\"] = df_total_sales[\"total_sales\"] - df_total_sales[\"total_sales_from_T-1\"]\n\n# this step is very important based on the asumptions we have about many of the timeseries\n# for more information I recommend this read\n# https:\/\/towardsdatascience.com\/understanding-partial-auto-correlation-fa39271146ac\ndf_total_sales[\"Residual_T-2_T-1\"] = df_total_sales[\"T-2\"] - df_total_sales[\"T-2_from_T-1\"]","e06115bf":"df_total_sales.head()","4228c71c":"# calculathe the parcial autocorrelation using manual method\nmanual_pacf = df_total_sales.corr(method = \"pearson\")[\"Residual_total_sales_T-1\"][\"Residual_T-2_T-1\"]\nprint(\"Manual parcial autocorrelation method {}\".format(round(manual_pacf, 5)))\n\n# calculate the parcial autocorrelation using statsmodel package\nstats_pacf = pacf(df_total_sales['total_sales'], nlags = 2)[2]\nprint(\"Parcial autocorrelation method using stats package {}\".format(round(stats_pacf, 5)))","245153a7":"df_timeindex = df.set_index(\"date\").resample(\"W\")[\"item_cnt_day\"].sum().to_frame()\n\n# decompose the series using stats module\n# results in this case is a special class \n# whose attributes we can acess\nresult = seasonal_decompose(df_timeindex[\"item_cnt_day\"])\n\n# ----------------------------------------------------------------------------------------------------\n# instanciate the figure\n# make the subplots share teh x axis\nfig, axes = plt.subplots(ncols = 1, nrows = 4, sharex = True, figsize = (12,10))\n\n# ----------------------------------------------------------------------------------------------------\n# plot the data\n# using this cool thread:\n# https:\/\/stackoverflow.com\/questions\/45184055\/how-to-plot-multiple-seasonal-decompose-plots-in-one-figure\n# This allows us to have more control over the plots\n\n# plot the original data\nresult.observed.plot(ax = axes[0], legend = False)\naxes[0].set_ylabel('Observed')\naxes[0].set_title(\"Decomposition of a series\")\n\n# plot the trend\nresult.trend.plot(ax = axes[1], legend = False)\naxes[1].set_ylabel('Trend')\n\n# plot the seasonal part\nresult.seasonal.plot(ax = axes[2], legend = False)\naxes[2].set_ylabel('Seasonal')\n\n# plot the residual\nresult.resid.plot(ax = axes[3], legend = False)\naxes[3].set_ylabel('Residual')\n\n# ----------------------------------------------------------------------------------------------------\n# prettify the plot\n\n# get the xticks and the xticks labels\nxtick_location = df_timeindex.index.tolist()\n\n# set x_ticks\nax.set_xticks(xtick_location);","dd5c9772":"# start with the regular df\ndf_for_question_2 = create_df(PATH_DATA, city_dict)","84e021b0":"# prepare the data\n\n# extract each year using dt.year\ndf[\"YEAR\"] = df[\"date\"].dt.year\n\nshort_df = df[df[\"YEAR\"] == 2014][[\"item_cnt_day\", \"city\"]]\nshort_df = short_df.groupby(\"city\")[\"item_cnt_day\"].sum().to_frame()\nshort_df.sort_values(\"item_cnt_day\", ascending = False, inplace = True)\n\nmy_values = short_df[\"item_cnt_day\"]\nmy_pct = short_df[\"item_cnt_day\"]\/short_df[\"item_cnt_day\"].sum()\nlabels = ['{} - Sales :{}k \\n {}% of total'.format(city, sales\/1000, round(pct, 2)*100) for city, sales, pct in zip(short_df.index, my_values, my_pct)]\n\nplt.figure(figsize = (30, 8))\nsquarify.plot(sizes = my_values, label = labels,  alpha = 0.8)\nplt.title(\"Sales by city and their % over total sales in 2014\",fontsize = 23, fontweight = \"bold\")\n\nplt.axis('off')\nplt.tight_layout()","9a4e248c":"df[[\"city\", \"city_code\"]].drop_duplicates()","b22f6f13":"# treemaps are very useful to see the difference and the weights of categories\n# but they don't give us that much of information about the distribution of each category\n# let's use boxplot to see the distribution of a city\n\nplt.figure(figsize = (10, 10))\nsns.boxplot(x = \"city\",\n            y = \"item_cnt_day\", \n            data = df[(df[\"YEAR\"] == 2013) & (df[\"city_code\"] == 9)]);","06c2f713":"# start with the regular df\ndf_for_question_3 = create_df(PATH_DATA, city_dict)","625a8077":"# This plot will help us visualize the missing values for each datetime and item_id\n# This is the most granular plots possible, since we will be seeing individual sales by day and item_id\n# This plot can be very consufing, but the main point is to show all the \"missing values\" we have\n# We have seen previously in our EDA, that when we groupby and resamples our sales, we might think\n# that we don't have any missing values. But its not true, we only have the reported sales\n# This means that, if we have a shop or item_id that only had 3 sales per year, when we resample\n# our df by day, pandas will generate additional days with null sales.\n# those null sales is what we want to plot here\n# the values are ordered from less nulls to more nulls\n\ngb_df_ = df.pivot_table(index = [\"date\"], columns = ['item_id'], values = \"item_cnt_day\", aggfunc = sum).isnull()\norder_of_columns = list(gb_df_.sum().sort_values().index)\ngb_df_ = gb_df_[order_of_columns]\n\nplt.figure(figsize = (20, 10))\nplot = sns.heatmap(gb_df_, cbar = True, cmap = \"inferno\")\nplot.set_title(\"Null sales by item_id and day\");","91da079c":"# create a smaller df\nshort_df = df[[\"date\", \"item_cnt_day\", \"item_category_name\"]]\n\n# set the date to be the index (to resample later)\nshort_df.set_index(\"date\", inplace = True)\n\n# groupby by shop_name\ngb = short_df.groupby(\"item_category_name\")\n\n# resample the df by month sales (resample = groupby by months in timeseries)\ngbr = gb.resample(\"M\")[\"item_cnt_day\"].sum()\n\n# unstack the gbr to have columns name\ngbr = gbr.unstack(level = -1).T\n\n# sort the values, from no nulls to more null values\norder_of_columns = list(gbr.isnull().sum().sort_values().index)\n\n# change the order of the df\ngbr = gbr[order_of_columns]","7e816e2f":"# let's plot the null values for each shop\nplt.figure(figsize=(20, 10))\n\n# this lines gbr.unstack(level = -1).T.isnull()*1\n# converts any null to 1 and the rest will be 0\nsns.heatmap(gbr.isnull()*1, cmap = \"inferno\", cbar = True).set_title(\"Null values by item category and Month\");","dcc3842a":"# let's look at outliers for item sales\n# We will use boxplots because they are very useful to see the distribution of values\nplt.figure(figsize = (10,4))\nsns.boxplot(x = df[\"item_cnt_day\"]);","b5431b6c":"# let's look at outliers for item price\nplt.figure(figsize = (10,4))\nplt.xlim(df[\"item_price\"].min(), df[\"item_price\"].max()*1.1)\nsns.boxplot(x = df[\"item_price\"]);","e36cefee":"# joint plot is another very convenient way to plot the relationship between 2 variables\n# but because we have huge outliers, we don't see them \n# https:\/\/seaborn.pydata.org\/generated\/seaborn.jointplot.html\nplt.figure(figsize = (10,4))\nsns.jointplot(x = \"item_price\", y = \"item_cnt_day\", data = df);","62a69ae9":"# let's filter the outliers and make the same joint plot\ndf = df[(df[\"item_price\"] < np.percentile(df[\"item_price\"], q = 99)) & (df[\"item_cnt_day\"] >= 0) & (df[\"item_cnt_day\"] < np.percentile(df[\"item_cnt_day\"], q = 99))]","e9bbd38b":"# we have removed the outliers and now \nplt.figure(figsize = (10, 10))\nsns.jointplot(x = \"item_price\", y = \"item_cnt_day\", data = df);","d16de260":"<a id =\"question_1\"><\/a>\n# Question 1: Create a plot with the moving average of total sales (7 days) and the variation on the second axis.\n[Go back to the Table of Contents](#table_of_contents)","7035ab22":"<a id = \"question_2\"><\/a>\n# Question 2: Create a decomposition plot for a city of weekly sales\n[Go back to the Table of Contents](#table_of_contents)","bf26895e":"<a id = \"decomp_weekly\"><\/a>\n# Timeseries decomposition plots: weekly sales\n[Go back to the Table of Contents](#table_of_contents)","2e96c91f":"In the next plots we will represent the monthly sales (left plot) and weekly sales (right plot) for each shop. \n\nIn the light red\/pink areas of each plot, we will mark the national holidays in Russia and see if there is any connection with sales spikes.","c9c44f69":"<a id = \"autocorrelation_calculation\"><\/a>\n# Manually calculate the Partial Autocorrelation\n[Go back to the Table of Contents](#table_of_contents)","3d610cac":"From our very first and simple figure, we can already extract very useful information.\n* First of all, we can see big spikes in January, like to be motivated with national holidays in Russia.\n* Second: we see a general trend to decline in our timeseries. If you are planning to use a parametrical model, you must take into account this.","cb7c0cb6":"<a id = \"imports\"><\/a>\n# Imports\n[Go back to the Table of Contents](#table_of_contents)","43df18c2":"<a id =\"table_of_contents\"><\/a>\n# Table of contents\n\n\n[Imports](#imports)\n\n[Quick look at shops df](#quick_look_shops)\n\n[Fix shops df and generate some features](#fix_shops)\n\n[Quick look at item category df](#quick_look_item_cat)\n\n[Quick look at items df](#quick_look_item)\n\n[Quick look at sales df](#quick_look_sales)\n\n[Joining df](#join_df)\n\n[Exploratory Data Analysis (EDA)](#eda)\n\n[Viz of sales per week, month of shops and item_category columns](#sales_viz)\n\n[Total sales and the variation on secondary axis](#sales_viz_2_axis)\n\n--> [Question 1: Create a plot with the moving average of total sales (7 days) and the variation on the second axis.](#question_1)\n\n[Calendar heatmap](#calendar_heatmap)\n\n[Timeseries autocorrelation and partial autocorrelation plots: daily sales](#corr_plots_daily)\n\n[Manually calculate the Partial Autocorrelation](#autocorrelation_calculation)\n\n[Timeseries decomposition plots: weekly sales](#decomp_weekly)\n\n--> [Question 2: Create a decomposition plot for a city of weekly sales](#question_2)\n\n[Visualizing the most important cities](#viz_cities)\n\n--> [Question 3: Create a treemap plot for item_category and the total combined sales](#question_3)\n\n[Visualizing nulls values](#viz_null_values)\n\n[Visualization of outliers](#viz_outliers)\n\n[Conclusion](#conclusion)","4444c442":"<a id = \"viz_cities\"><\/a>\n# Visualizing the most important cities\n[Go back to the Table of Contents](#table_of_contents)","28b0914e":"<a id = \"quick_look_item_cat\"><\/a>\n# Quick look at items_category df\n[Go back to the Table of Contents](#table_of_contents)","cd8a4bbb":"<a id = \"quick_look_item\"><\/a>\n# Quick look at items df\n[Go back to the Table of Contents](#table_of_contents)","7d88d670":"Analyzing data on a weekly basis, gives us much more information. We can see more variation between weeks, but the main point stays the same: we have spines in January and sales that go down overtime.","e467e31f":"<a id = \"corr_plots_daily\"><\/a>\n# Timeseries autocorrelation and partial autocorrelation plots: daily sales\n[Go back to the Table of Contents](#table_of_contents)","d6d147cd":"<a id = \"question_3\"><\/a>\n# Question 3: Create a treemap plot for item_category and the total combined sales\n\n<span style=\"color:red\">If the % of a category over total is less 1%, don't put any label!!!<\/span>\n\n[Go back to the Table of Contents](#table_of_contents)","a7d13c88":"<a id = \"viz_null_values\"><\/a>\n# Visualizing nulls values\n[Go back to the Table of Contents](#table_of_contents)","e61d0087":"<a id = \"sales_viz_2_axis\"><\/a>\n# Total sales and the variation on secondary axis\n[Go back to the Table of Contents](#table_of_contents)","80ab665c":"<a id = \"sales_viz\"><\/a>\n# Viz of sales per week, month of shops and item_category columns\n[Go back to the Table of Contents](#table_of_contents)","6b5f2512":"<a id = \"viz_outliers\"><\/a>\n# Visualization of outliers\n[Go back to the Table of Contents](#table_of_contents)","f8647127":"# Welcome to this kernel\n\nThe goal of this kernel is very simple. It aims to provide some useful insights about the data and hopefully can guide you into what features to generate and how to tackle the modelling part.","d5276d9d":"<a id = \"conclusion\"><\/a>\n# Conclusion\n[Go back to the Table of Contents](#table_of_contents)\n\nAfter taking a look at the sales data, here are some conclusion we can extract:\n\n1. We see that the total sales decrease over time. This is very important because, we have to create features for our model that catch this trend.\n\n2. We have seen that the sales present huge spikes in Christmas season. Datetime features can help a lot our model.\n\n3. Data has a lot of missing values and we have not found a specific or category affected by this. More likely it's just the nature of the data.\n\n4. Top 3 cities capture more than 50% of total sales. City based features can be very helpful for the model.\n\n5. The top 3 categories represent more than 40% of total sales: they are Movies, PC Games and Music.\n\n6. Data presents outliers at the sales and price level. Before generating features or training a model, data must be cleaned properly.\n\n7. We have seen thanks to our calendar plots that we a small increase in sales on the weekends. We do see however bigger sales on 14 of February or 9 of May (holidays).","58696849":"<a id = \"join_df\"><\/a>\n# Joining df\n[Go back to the Table of Contents](#table_of_contents)","cfa56688":"<a id = \"fix_shops\"><\/a>\n# Fix shops df and generate some features\n[Go back to the Table of Contents](#table_of_contents)","bd95cdb9":"<a id = \"eda\"><\/a>\n# Exploratory Data Analysis (EDA)\n[Go back to the Table of Contents](#table_of_contents)","1148e4e5":"Treemaps are a very useful and visual tools to see different categories and their overall importance in a dataset.\nAlso, they are very cool and easy to make using Python and squarify.","e9b30443":"<a id = \"calendar_heatmap\"><\/a>\n# Calendar heatmap\n[Go back to the Table of Contents](#table_of_contents)","e00438b4":"<a id = \"quick_look_sales\"><\/a>\n# Quick look at sales df\n[Go back to the Table of Contents](#table_of_contents)","285b2938":"<a id = \"quick_look_shops\"><\/a>\n# Quick look at shops df\n[Go back to the Table of Contents](#table_of_contents)"}}