{"cell_type":{"858e4d21":"code","73aaa070":"code","104ab207":"code","8ae79751":"code","d808a385":"code","0a3f3be3":"code","28d24a98":"code","2e156479":"code","b2f85575":"code","ee27651e":"code","61e5f47f":"markdown","c75348d4":"markdown","5e6c99a4":"markdown","73f51a54":"markdown","548717e3":"markdown","bbd6dd0a":"markdown","ffefb980":"markdown","b7760cb7":"markdown"},"source":{"858e4d21":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nwarnings.filterwarnings(action=\"ignore\",category=DeprecationWarning)\nwarnings.filterwarnings(action=\"ignore\",category=FutureWarning)","73aaa070":"df_train=pd.read_csv('..\/input\/train.csv')\n#df_test=pd.read_csv('..\/input\/test.csv')\ndf_struct=pd.read_csv('..\/input\/structures.csv')","104ab207":"def map_atom_info(df_1,df_2, atom_idx):\n    df = pd.merge(df_1, df_2, how = 'left',\n                  left_on  = ['molecule_name', f'atom_index_{atom_idx}'],\n                  right_on = ['molecule_name',  'atom_index'])\n    df = df.drop('atom_index', axis=1)\n\n    return df\nfor atom_idx in [0,1]:\n    df_train = map_atom_info(df_train,df_struct, atom_idx)\n    df_train = df_train.rename(columns={'atom': f'atom_{atom_idx}',\n                                        'x': f'x_{atom_idx}',\n                                        'y': f'y_{atom_idx}',\n                                        'z': f'z_{atom_idx}'})","8ae79751":"def make_features(df):\n    df['dx']=df['x_1']-df['x_0']\n    df['dy']=df['y_1']-df['y_0']\n    df['dz']=df['z_1']-df['z_0']\n    df['distance']=(df['dx']**2+df['dy']**2+df['dz']**2)**(1\/2)\n    return df\ndf_train=make_features(df_train)","d808a385":"#I apologize for my poor coding skill. Please make the better one.\nprint(df_train.shape)\ndf_temp=df_train.loc[:,[\"molecule_name\",\"atom_index_0\",\"atom_index_1\",\"distance\",\"x_0\",\"y_0\",\"z_0\",\"x_1\",\"y_1\",\"z_1\"]].copy()\n\ndf_temp_=df_temp.copy()\ndf_temp_= df_temp_.rename(columns={'atom_index_0': 'atom_index_1',\n                                   'atom_index_1': 'atom_index_0',\n                                   'x_0': 'x_1',\n                                   'y_0': 'y_1',\n                                   'z_0': 'z_1',\n                                   'x_1': 'x_0',\n                                   'y_1': 'y_0',\n                                   'z_1': 'z_0'})\ndf_temp=pd.concat((df_temp,df_temp_),axis=0)\n\ndf_temp[\"min_distance\"]=df_temp.groupby(['molecule_name', 'atom_index_0'])['distance'].transform('min')\ndf_temp= df_temp[df_temp[\"min_distance\"]==df_temp[\"distance\"]]\n\ndf_temp=df_temp.drop(['x_0','y_0','z_0','min_distance'], axis=1)\ndf_temp= df_temp.rename(columns={'atom_index_0': 'atom_index',\n                                 'atom_index_1': 'atom_index_closest',\n                                 'distance': 'distance_closest',\n                                 'x_1': 'x_closest',\n                                 'y_1': 'y_closest',\n                                 'z_1': 'z_closest'})\n\nprint(df_temp.duplicated(subset=['molecule_name', 'atom_index']).value_counts())\n#delete duplicated rows (some atom pairs have perfectly same distance)\n#This code is added based on Adriano Avelar's comment.\ndf_temp=df_temp.drop_duplicates(subset=['molecule_name', 'atom_index'])\n\nfor atom_idx in [0,1]:\n    df_train = map_atom_info(df_train,df_temp, atom_idx)\n    df_train = df_train.rename(columns={'atom_index_closest': f'atom_index_closest_{atom_idx}',\n                                        'distance_closest': f'distance_closest_{atom_idx}',\n                                        'x_closest': f'x_closest_{atom_idx}',\n                                        'y_closest': f'y_closest_{atom_idx}',\n                                        'z_closest': f'z_closest_{atom_idx}'})\n\nprint(df_train.shape)","0a3f3be3":"df_train.head()","28d24a98":"def add_cos_features(df):\n    df[\"distance_0\"]=((df['x_0']-df['x_closest_0'])**2+(df['y_0']-df['y_closest_0'])**2+(df['z_0']-df['z_closest_0'])**2)**(1\/2)\n    df[\"distance_1\"]=((df['x_1']-df['x_closest_1'])**2+(df['y_1']-df['y_closest_1'])**2+(df['z_1']-df['z_closest_1'])**2)**(1\/2)\n    df[\"vec_0_x\"]=(df['x_0']-df['x_closest_0'])\/df[\"distance_0\"]\n    df[\"vec_0_y\"]=(df['y_0']-df['y_closest_0'])\/df[\"distance_0\"]\n    df[\"vec_0_z\"]=(df['z_0']-df['z_closest_0'])\/df[\"distance_0\"]\n    df[\"vec_1_x\"]=(df['x_1']-df['x_closest_1'])\/df[\"distance_1\"]\n    df[\"vec_1_y\"]=(df['y_1']-df['y_closest_1'])\/df[\"distance_1\"]\n    df[\"vec_1_z\"]=(df['z_1']-df['z_closest_1'])\/df[\"distance_1\"]\n    df[\"vec_x\"]=(df['x_1']-df['x_0'])\/df[\"distance\"]\n    df[\"vec_y\"]=(df['y_1']-df['y_0'])\/df[\"distance\"]\n    df[\"vec_z\"]=(df['z_1']-df['z_0'])\/df[\"distance\"]\n    df[\"cos_0_1\"]=df[\"vec_0_x\"]*df[\"vec_1_x\"]+df[\"vec_0_y\"]*df[\"vec_1_y\"]+df[\"vec_0_z\"]*df[\"vec_1_z\"]\n    df[\"cos_0\"]=df[\"vec_0_x\"]*df[\"vec_x\"]+df[\"vec_0_y\"]*df[\"vec_y\"]+df[\"vec_0_z\"]*df[\"vec_z\"]\n    df[\"cos_1\"]=df[\"vec_1_x\"]*df[\"vec_x\"]+df[\"vec_1_y\"]*df[\"vec_y\"]+df[\"vec_1_z\"]*df[\"vec_z\"]\n    df=df.drop(['vec_0_x','vec_0_y','vec_0_z','vec_1_x','vec_1_y','vec_1_z','vec_x','vec_y','vec_z'], axis=1)\n    return df\n    \ndf_train=add_cos_features(df_train)","2e156479":"mol_types=df_train[\"type\"].unique()\ndf_train_=df_train.iloc[:100000,:].copy()\n\nfig, ax = plt.subplots(8, 1, figsize=(8, 32))\nfor i, mol_type in enumerate(mol_types):\n    ax[i].scatter(df_train_.loc[df_train_['type'] ==mol_type][\"cos_0_1\"], df_train_.loc[df_train_['type'] == mol_type] ['scalar_coupling_constant'],s=10,alpha=0.3);\n    ax[i].set_title(str(mol_type))","b2f85575":"mol_types=df_train[\"type\"].unique()\ndf_train_=df_train.iloc[:100000,:].copy()\n\nfig, ax = plt.subplots(8, 1, figsize=(8, 32))\nfor i, mol_type in enumerate(mol_types):\n    ax[i].scatter(df_train_.loc[df_train_['type'] ==mol_type][\"cos_0\"], df_train_.loc[df_train_['type'] == mol_type] ['scalar_coupling_constant'],s=10,alpha=0.3);\n    ax[i].set_title(str(mol_type))","ee27651e":"mol_types=df_train[\"type\"].unique()\ndf_train_=df_train.iloc[:100000,:].copy()\n\nfig, ax = plt.subplots(8, 1, figsize=(8, 32))\nfor i, mol_type in enumerate(mol_types):\n    ax[i].scatter(df_train_.loc[df_train_['type'] ==mol_type][\"cos_1\"], df_train_.loc[df_train_['type'] == mol_type] ['scalar_coupling_constant'],s=10,alpha=0.3);\n    ax[i].set_title(str(mol_type))","61e5f47f":"Let's get **cosine angles** by calculating dot product of vectors.","c75348d4":"## Import & Load","5e6c99a4":"Most people are using distance features, but not using **ANGLE** features. My teacher 'Google' taught me that the angles among atoms are important to estimate molecular properties. Let me show some examples in this kernel.","73f51a54":"## Create Features\nLet's get the distance between atoms first.","548717e3":"Now, I get xyz positions of 4 atoms.\n1. atom_0\n2. atom_1\n3. closest one to atom_0\n4. closest one to atom_1\nIf atom_1 is C or N, it has some connections. It's not considered here. ","bbd6dd0a":"I use this great kernel to get x,y,z position. https:\/\/www.kaggle.com\/seriousran\/just-speed-up-calculate-distance-from-benchmark","ffefb980":"Next, find the coupled atom of atom_1 and atom_2. I'd like to use the distance to get the coupled atom(closest atom). You can use 'type' feature instead.","b7760cb7":"I'd like to show some graph. You can see the obvious relationship between 'angle' and 'scalar_coupling_constant'."}}