{"cell_type":{"b603dbd8":"code","c2a2e5dd":"code","4c357de6":"code","65d97b42":"code","c8da2ca3":"code","69a41527":"code","52392ad0":"code","5e6e6d45":"code","6c33388b":"code","2f2da828":"code","caddb679":"code","bb1adef1":"code","359848d0":"code","3d6d6086":"code","9f6b3169":"code","57237d89":"code","ae2cb994":"code","b0529238":"code","c2754a4e":"code","80e0485e":"code","4a63a6ad":"code","e042d06d":"code","b0ec1f65":"code","2b344ca4":"code","6ad7b895":"code","09eb3774":"markdown","f9ea7d12":"markdown","19cc7f1b":"markdown","822c027a":"markdown","0792fbca":"markdown","881dcc56":"markdown","74844490":"markdown","f240b827":"markdown","6962edfb":"markdown","38501817":"markdown","f8b96453":"markdown","a5816cb6":"markdown","cdb57363":"markdown","58ae9e0e":"markdown","6cf0a6b3":"markdown","0a6c4be9":"markdown","4b2f7fb1":"markdown","f820447b":"markdown","21a110a0":"markdown","3ed76f97":"markdown"},"source":{"b603dbd8":"import pandas as pd\nimport numpy as np\nimport os","c2a2e5dd":"# ALICE_PATH = os.path.join(\"datasets\", \"alice\")\n\n# def load_alice_data(alice_path=ALICE_PATH):\n#     csv_path_train = os.path.join(alice_path, \"train_sessions.csv\")\n#     csv_path_test = os.path.join(alice_path, \"test_sessions.csv\")\n#     return pd.read_csv(csv_path_train, index_col='session_id', parse_dates=['time1']), \\\n#             pd.read_csv(csv_path_test, index_col='session_id', parse_dates=['time1'])\n\n# df_train, df_test = load_alice_data()","4c357de6":"df_train = pd.read_csv(\"..\/input\/train_sessions.csv\", index_col='session_id', parse_dates=['time1'])\ndf_test = pd.read_csv(\"..\/input\/test_sessions.csv\", index_col='session_id', parse_dates=['time1'])","65d97b42":"df_train.head()","c8da2ca3":"df_train = df_train.sort_values(by=\"time1\")","69a41527":"df_train.info()","52392ad0":"for i in range(2, 11):\n    df_train['time{}'.format(i)] = pd.to_datetime(df_train['time{}'.format(i)])\nfor i in range(2, 11):\n    df_test['time{}'.format(i)] = pd.to_datetime(df_test['time{}'.format(i)])","5e6e6d45":"from sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.pipeline import FeatureUnion\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.preprocessing import StandardScaler","6c33388b":"class DataPreparator(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Fill NaN with zero values.\n    \"\"\"\n    def fit(self, X, y=None):\n        return self\n    def transform(self, X, y=None):\n        sites = ['site%s' % i for i in range(1, 11)]\n        return X[sites].fillna(0).astype('int')","2f2da828":"class ListPreparator(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Prepare a CountVectorizer friendly 2D-list from data.\n    \"\"\"\n    def fit(self, X, y=None):\n        return self\n    def transform(self, X, y=None):\n        X = X.values.tolist()\n        # Convert dataframe rows to strings\n        return [\" \".join([str(site) for site in row]) for row in X]","caddb679":"class AttributesAdder(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Add new attributes to training and test set.\n    \"\"\"\n    def fit(self, X, y=None):\n        return self \n    def transform(self, X, y=None):\n        # intraday features\n        hour = X['time1'].apply(lambda ts: ts.hour)\n        morning = ((hour >= 7) & (hour <= 11)).astype('int')\n        day = ((hour >= 12) & (hour <= 18)).astype('int')\n        evening = ((hour >= 19) & (hour <= 23)).astype('int')\n        \n        # season features\n        month = X['time1'].apply(lambda ts: ts.month)\n        summer = ((month >= 6) & (month <= 8)).astype('int')\n        \n        # day of the week features\n        weekday = X['time1'].apply(lambda ts: ts.weekday()).astype('int')\n        \n        # year features\n        year = X['time1'].apply(lambda ts: ts.year).astype('int')\n        \n        X = np.c_[morning.values, day.values, evening.values, summer.values, weekday.values, year.values]\n        return X","bb1adef1":"class ScaledAttributesAdder(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Add new features, that should be scaled.\n    \"\"\"\n    def fit(self, X, y=None):\n        return self\n    def transform(self, X, y=None):\n        # session time features\n        times = ['time%s' % i for i in range(1, 11)]\n        # session duration: take to the power of 1\/5 to normalize the distribution\n        session_duration = (X[times].max(axis=1) - X[times].min(axis=1)).astype('timedelta64[ms]').astype(int) ** 0.2\n        # number of sites visited in a session\n        number_of_sites = X[times].isnull().sum(axis=1).apply(lambda x: 10 - x)\n        # average time spent on one site during a session\n        time_per_site = (session_duration \/ number_of_sites) ** 0.2\n        \n        X = np.c_[session_duration.values]\n        return X","359848d0":"vectorizer_pipeline = Pipeline([\n    (\"preparator\", DataPreparator()),\n    (\"list_preparator\", ListPreparator()),\n    (\"vectorizer\", CountVectorizer(ngram_range=(1, 3), max_features=50000))\n])\n\nattributes_pipeline = Pipeline([\n    (\"adder\", AttributesAdder())\n])\n\nscaled_attributes_pipeline = Pipeline([\n    (\"adder\", ScaledAttributesAdder()),\n    (\"scaler\", StandardScaler())\n])","3d6d6086":"full_pipeline = FeatureUnion(transformer_list=[\n('vectorizer_pipeline', vectorizer_pipeline),\n('attributes_pipeline', attributes_pipeline),\n('scaled_attributes_pipeline', scaled_attributes_pipeline)\n])","9f6b3169":"X_train = full_pipeline.fit_transform(df_train)\nX_test = full_pipeline.transform(df_test)\n\ny_train = df_train[\"target\"].astype('int').values","57237d89":"from sklearn.model_selection import TimeSeriesSplit, cross_val_score\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.linear_model import LogisticRegression","ae2cb994":"time_split = TimeSeriesSplit(n_splits=10)\n\nlogit = LogisticRegression(C=1, random_state=42, solver='liblinear')\n\ncv_scores = cross_val_score(logit, X_train, y_train, cv=time_split, \n                        scoring='roc_auc', n_jobs=1)\n\ncv_scores.mean()","b0529238":"logit.fit(X_train, y_train)","c2754a4e":"def write_to_submission_file(predicted_labels, out_file,\n                             target='target', index_label=\"session_id\"):\n    predicted_df = pd.DataFrame(predicted_labels,\n                                index = np.arange(1, predicted_labels.shape[0] + 1),\n                                columns=[target])\n    predicted_df.to_csv(out_file, index_label=index_label)","80e0485e":"logit_test_pred = logit.predict_proba(X_test)[:, 1]\n\nwrite_to_submission_file(logit_test_pred, 'submit.csv') # 0.95191","4a63a6ad":"from sklearn.model_selection import GridSearchCV","e042d06d":"c_values = np.logspace(-2, 2, 20)\n\nlogit_grid = GridSearchCV(estimator=logit, param_grid={'C': c_values}, scoring='roc_auc', n_jobs=4, cv=time_split, verbose=1)","b0ec1f65":"logit_grid.fit(X_train, y_train)","2b344ca4":"logit_grid.best_params_","6ad7b895":"logit_test_pred = logit_grid.predict_proba(X_test)[:, 1]\n\nwrite_to_submission_file(logit_test_pred, 'submit1.csv') #0.95271","09eb3774":"**It seems like only the first time column is in datetime format. Better convert the rest now, otherwise you'll have a problem with the datetime arithmetic, for example, when calculation session duration as a feature.**","f9ea7d12":"**The key idea here is to write your own classes for data transformation. They must follow a pretty simple template: they should inherit from two base classes \u2013 ``BaseEstimator``, ``TransformerMixin`` \u2013 and have a ``fit()`` and ``transform()`` methods, which take the dataset (X) as input and have a y value set to None. In pipelines the ``__init__()`` method is not neccessary.**","19cc7f1b":"**As you can see, by using the pipeline template you can write fewer lines of code and understand more, what's going on in your data preparation workflow. You can test features much faster. But the greatest thing about pipelines is that you can generalize the data preparation and training process by changing the dataset you use as a the pipeline input. For example, you can use the same pipeline for transforming your train and test set. And even more: you can automate the whole process, when new data becomes available.**\n\n**Good luck with Alice!**","822c027a":"**As @yorko introduced, we use time-aware cross-validation scheme.**","0792fbca":"## Download data","881dcc56":"**Here, in the kernel, we'll do this manually.**","74844490":"**Now let's take a look at the column data types.**","f240b827":"**One of the great advantages of pipelines, is that you can use classes for adding features too. You can test new features quite easilly by adding\/removing some of them from the class, and then just running the whole pipeline. **","6962edfb":"**Once we've written the classes, we want to combine them into a pipeline. The ``Pipeline()`` class will call ``transform()`` methods on each one of them and return the transformed dataset, which you can pass to another pipeline as many times as you want. Here we have three separate pipelines with different purposes: ``vectorizer_pipeline`` prepares data for ``CountVectorizer()`` class, ``attributes_pipeline`` adds features and ``scaled_attributes_pipeline`` adds scaled features. **","38501817":"**If you're working on a local machine, it's always a good practice to write a function for data downloading. It can be as easy as the one shown below.**","f8b96453":"**Finally you can combine these pipelines using ``FeatureUnion()`` class, which will merge the resulting datasets from each pipeline. **","a5816cb6":"## Clean data","cdb57363":"**First of all we should notice, that our data is time dependent. Leaving it shuffled will cause some problems later on during the cross-validation, so let's sort it right away.**","58ae9e0e":"**Finally, train your model on the whole train set and write a function for submitting results.**","6cf0a6b3":"## Cross-validation and submitting results","0a6c4be9":"### Hi, in this kernel we'll make a baseline submission using sklearn pipelines instead of functions. Some of the advantages:\n* Less and more readable code\n* Faster feature engineering\n* More automation","4b2f7fb1":"Try to tune params","f820447b":"**I'll skip EDA and feature engineering for now \u2013 there are plenty of great kernels in this competition, that cover those in depth. Instead I'll try to show you another way of preparing data and training models \u2013 using the sklearn ``Pipeline()`` class, instead of good old functions. This approach is based more on object oriented, rather than procedural programming, which in fact reduces the length of your code quite a lot.**","21a110a0":"## Pipeline configuration","3ed76f97":"**All you need to do at the end, is just call ``fit_transform()`` or ``transform()`` methods on the ``full_pipeline`` and pass them your original datasets.**"}}