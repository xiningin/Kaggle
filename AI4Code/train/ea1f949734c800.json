{"cell_type":{"f8e6d593":"code","c58ed72c":"code","ed1f6db2":"code","99c948e2":"code","9275aa88":"code","750402d7":"code","72f7bf56":"code","1872ebe5":"code","e900010b":"code","219e41d1":"code","fda1b1e5":"code","68ecd62b":"code","1e6a992c":"code","83fadcbf":"code","c9241a0a":"code","ac6e1ddb":"code","0a2d47d1":"code","91a3f3ce":"code","9e2d1b9d":"code","22b1796a":"code","c3aea876":"code","9699e58d":"code","3774088d":"code","51c734da":"markdown"},"source":{"f8e6d593":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt \n\nimport datetime","c58ed72c":"## global pyplot settings -- can be changed for a specific instance\nplt.rcParams['figure.figsize'] = (8, 5.28) \nplt.rcParams[\"axes.labelsize\"] = 12\nplt.rcParams[\"axes.titlesize\"] = 13\nplt.rcParams[\"axes.titleweight\"] = 600\n\nsns.set_color_codes(\"pastel\")","ed1f6db2":"header_orig = [\"ID\",\"ts_year\",\"ts_month\",\"ts_day\",\"ts_hour\",\"ts_min\",\"ts_second\",\"te_year\",\"te_month\",\n          \"te_day\",\"te_hour\",\"te_min\",\"te_second\",\"td\",\"sa\",\"da\",\"sp\",\"dp\",\"pr\",\"_flag1\",\"_flag2\",\n          \"_flag3\",\"_flag4\",\"_flag5\",\"_flag6\",\"fwd\",\"stos\",\"ipkt\",\"ibyt\",\"opkt\",\"obyt\",\"_in\",\"out\",\n          \"sas\",\"das\",\"smk\",\"dmk\",\"dtos\",\"_dir\",\"nh\",\"nhb\",\"svln\",\"dvln\",\"ismc\",\"odmc\",\"idmc\",\"osmc\",\n          \"mpls1\",\"mpls2\",\"mpls3\",\"mpls4\",\"mpls5\",\"mpls6\",\"mpls7\",\"mpls8\",\"mpls9\",\"mpls10\",\"cl\",\"sl\",\n          \"al\",\"ra\",\"eng\",\"exid\",\"tr\",\"icmp_dst_ip_b\",\"icmp_src_ip\",\"udp_dst_p\",\"tcp_f_s\",\"tcp_f_n_a\",\n          \"tcp_f_n_f\",\"tcp_f_n_r\",\"tcp_f_n_p\",\"tcp_f_n_u\",\"tcp_dst_p\",\"tcp_src_dst_f_s\",\"tcp_src_tftp\",\n          \"tcp_src_kerb\",\"tcp_src_rpc\",\"tcp_dst_p_src\",\"smtp_dst\",\"udp_p_r_range\",\"p_range_dst\",\n          \"udp_src_p_0\",\"attack_t\",\"attack_a\"]\n\n\nlitnet_add_attack_lbls = [\"icmp_flood_brdcast\",\"icmp_flood_ip\",\"udp_ddos\",\"tcp_flood_syn\",\"tcp_f_n_a\",\n          \"tcp_f_n_f\",\"tcp_f_n_r\",\"tcp_f_n_p\",\"tcp_f_n_u\",\"http_ddos\",\"tcp_land_syn\",\"tftp_flood\",\n          \"kerberos_flood\",\"rpc_flood\",\"http_vulnerabilities\",\"smtp_flood\",\"udp_port_range\",\"port_range\",\n          \"udp_ddos_fragmented\",\"attack_type\",\"attack_action\"]\n\nnetflow_attr = [\"ID\",\"ts_year\",\"ts_month\",\"ts_day\",\"ts_hour\",\"ts_min\",\"ts_second\",\"te_year\",\"te_month\",\n          \"te_day\",\"te_hour\",\"te_min\",\"te_second\",\"time_delta\",\"src_add\",\"dest_add\",\"src_port\",\"dest_port\",\n          \"proto\",\"_flag1\",\"_flag2\",\"_flag3\",\"_flag4\",\"_flag5\",\"_flag6\",\"fwd_status\",\"in_tos_field\",\"in_pkt\",\"in_bytes\",\n          \"out_pkt\",\"out_bytes\",\"in_bytes_per_flow\",\"out_bytes_per_flow\",\"src_as\",\"dest_as\",\"src_mask\",\"dest_mask\",\n          \"out_tos_field\",\"flow_dir\",\"next_hop\",\"next_hop_bgp\",\"src_vlan\",\"dest_vlan\",\"in_src_mac\",\"out_dest_mac\",\"in_dest_mac\",\"out_src_mac\",\n          \"mpls1\",\"mpls2\",\"mpls3\",\"mpls4\",\"mpls5\",\"mpls6\",\"mpls7\",\"mpls8\",\"mpls9\",\"mpls10\",\"class_id\",\"selector_id\",\n          \"sampl_alg\",\"ra\",\"engine\",\"exporting_proc_id\",\"tr\"]\n\nheader = netflow_attr + litnet_add_attack_lbls","99c948e2":"### HELPER FUNCTIONS\ndef create_timestamp(series):\n    date = datetime.datetime(*series.values)\n    return pd.to_datetime(date)\n\ndef insert_column_at_pos(df, **kwargs):\n    df.insert(**kwargs)\n\ndef  find_samples_missing_vals(df, dfname):\n    attr_missing = df.loc[:, df.isnull().any()].isnull().sum()\n    if not attr_missing.empty:\n        print(attr_missing)\n    else: print(f\"there are no missing values in {dfname}\")","9275aa88":"## reading in each traffic type file\nblaster_worm = pd.read_csv(\"\/kaggle\/input\/litnet20\/BLASTER_WORM_v2.csv\", names=header, index_col=0, encoding=\"utf-8\")\nfragmentation = pd.read_csv(\"\/kaggle\/input\/litnet20\/FRAGMENTATION_v2.csv\", names=header, index_col=0, encoding=\"utf-8\")\nhttp_flood = pd.read_csv(\"\/kaggle\/input\/litnet20\/HTTP_FLOOD_v2.csv\", names=header, index_col=0, nrows-100000, encoding=\"utf-8\")\nicmp_flood = pd.read_csv(\"\/kaggle\/input\/litnet20\/ICMP_FLOOD_v2.csv\", names=header, index_col=0, nrows=100000, encoding=\"utf-8\")\nland_attack = pd.read_csv(\"\/kaggle\/input\/litnet20\/LAND_ATTACK_v2.csv\",names=header, index_col=0, nrows=100000, encoding=\"utf-8\")","750402d7":"## prezentacja rozmiaru danych z ka\u017cdego pliku\nblaster_shape = blaster_worm.shape\nfrag_shape = fragmentation.shape\nhttp_shape = http_flood.shape\nicmp_shape = icmp_flood.shape\nland_shape = land_attack.shape\nprint(f\"Rozmiar pliku BLASTER_WORM to {blaster_shape[0]} rekord\u00f3w i {blaster_shape[1]} kolumn\")\nprint(f\"Rozmiar pliku FRAGMENTATION to {frag_shape[0]} rekord\u00f3w i {frag_shape[1]} kolumn\")\nprint(f\"Rozmiar pliku HTTP_FLOOD to {http_shape[0]} rekord\u00f3w i {http_shape[1]} kolumn\")\nprint(f\"Rozmiar pliku ICMP_FLOOD to {icmp_shape[0]} rekord\u00f3w i {icmp_shape[1]} kolumn\")\nprint(f\"Rozmiar pliku LAND_ATTACK to {land_shape[0]} rekord\u00f3w i {land_shape[1]} kolumn\")","72f7bf56":"## podstawowe informacje przyk\u0142adowym pliku sk\u0142adowym\nhttp_flood.info()","1872ebe5":"## brakuj\u0105ce dane? ? \npd.options.mode.use_inf_as_na = True ## so that inf is also treated as NA value\nfind_samples_missing_vals(blaster_worm, \"blaster\")\nfind_samples_missing_vals(fragmentation, \"fragmentation\")\nfind_samples_missing_vals(http_flood, \"http\")\nfind_samples_missing_vals(icmp_flood, \"icmp\")\nfind_samples_missing_vals(land_attack, \"land\")","e900010b":"## merge wszystkich plik\u00f3w w jeden, kt\u00f3ry zostanie poddany dalszej analizie\nlitnet = pd.concat([blaster_worm, fragmentation, http_flood, icmp_flood, land_attack], ignore_index=True)\nlitnet_cp = litnet.copy()  ## copy to work on","219e41d1":"## change date columns to date format\nts_date = litnet_cp.iloc[:,:6]\nte_date = litnet_cp.iloc[:,6:12]\nts_date_col = ts_date.agg(create_timestamp, axis=1)\nte_date_col = te_date.agg(create_timestamp, axis=1)\n\nlitnet_cp.drop(labels=http_flood.iloc[:,:12], axis=1, inplace=True)\n\ninsert_column_at_pos(litnet_cp, loc=0, column=\"ts_time_struct\", value=ts_date_col)\ninsert_column_at_pos(litnet_cp, loc=1, column=\"te_time_struct\", value=te_date_col)","fda1b1e5":"## categorical vs numerical columns distribution comparison\nlitnet_cp.dtypes.value_counts().plot(kind=\"bar\")\nplt.title(\"dtypes distribution\")\nplt.xlabel(\"datatypes\")\nplt.yticks(np.arange(0,55,5))\nplt.ylabel(\"count\")\nplt.show()","68ecd62b":"litnet_cp[\"ts_time_struct\"]","1e6a992c":"# ## kolumny numeryczne VS kolumny kategoryczne\n#pd.datetime_is_numeric=True\nnum_cols = litnet_cp.select_dtypes(include=[\"number\"])\nobject_cols = litnet_cp.select_dtypes(exclude=[\"number\",\"datetime\"])\n\nnum_cols.describe()\n# #sns.countplot(x= data=litnet_cp.dtypes.value_counts(), palette=[\"g\",\"r\"]).plot()\n# #plt.title(\"numeric vs categorical data\")","83fadcbf":"object_cols.describe()","c9241a0a":"# different protocols distribution\nprotos = litnet_cp[\"proto\"]\nsns.countplot(x=protos, palette=[\"g\",\"r\"], order = protos.value_counts().index)\nplt.title(\"protocols distribution\")\nplt.yticks(np.arange(0,5000, 300))\nplt.show()","ac6e1ddb":"ml_ind = pd.MultiIndex.from_product([[\"wl\"], wl.values])\nser = pd.Series(index=ml_ind, dtype=\"object\", name=\"well-known-ports\")","0a2d47d1":"wl = litnet_cp.loc[litnet_cp[\"src_port\"] <= 1024, \"src_port\"]\nwl.sum()","91a3f3ce":"fig.axes[0]","9e2d1b9d":"# def add_text(rect):\n#     # add text to top of each bar\n#     for r in rect:\n#         h = r.get_height()\n#         ax.text(r.get_x() + r.get_width()\/2, h*1.01, s=format(h, \",\") ,fontsize=8, ha='center', va='bottom')\n        \n## port usage (source vs destination)\nsrc_well_known_ports = litnet_cp.loc[litnet_cp[\"src_port\"] <= 1024, \"src_port\"]\nsrc_higher_ports = litnet_cp.loc[litnet_cp[\"src_port\"] > 1024, \"src_port\"]\ndst_well_known_ports = litnet_cp.loc[litnet_cp[\"dest_port\"] <= 1024, \"dest_port\"]\ndst_higher_ports = litnet_cp.loc[litnet_cp[\"dest_port\"] > 1024, \"dest_port\"]\n\nfig = plt.figure()\nfig.set_size_inches(15.5, 7.5)\n#fig, (ax1, ax2) = plt.subplots(2)\n(ax1,ax2) = fig.subplots(2)\nbar1 = sns.barplot(ax=ax1, x=[\"src well known ports\", \"src higher custom ports\"], y=[src_well_known_ports.sum(), src_higher_ports.sum()],palette=[\"g\",\"r\"])\nax1.title.set_text('source port distribution')\n\n#add_text(bar1)\nsns.barplot(ax=ax2, x=[\"dest well known ports\", \"dest higher custom ports\"], y=[dst_well_known_ports.sum(), dst_higher_ports.sum()], palette=[\"g\",\"r\"])\nax2.title.set_text('destination ports distribution')\n\n\nplt.show()","22b1796a":"## port usage --- most common and most least src VS. dest ports \ndef pprint_series(s, direction):\n    for ind, val in s.items():\n        print(f\"{direction} port {ind} was used {val} times\")\n\nsrc_max_freq_ports = src_well_known_ports.value_counts().head(10)\nsrc_least_freq_ports = src_well_known_ports.value_counts().tail(10)\nprint(\"SOURCE PORTS\")\npprint_series(src_max_freq_ports, \"source\")\nprint(\"===\")\npprint_series(src_least_freq_ports, \"source\")\nprint(\"\\nDESTINATION PORTS\")\ndest_max_freq_ports = dst_well_known_ports.value_counts().head(10)\ndest_least_freq_ports = dst_well_known_ports.value_counts().tail(10)\npprint_series(src_max_freq_ports, \"destination\")\nprint(\"===\")\npprint_series(src_least_freq_ports, \"destination\")\n","c3aea876":"## liczba atak\u00f3w a ruchu normalnego ","9699e58d":"## jaki\u015b wykres tcp, flag i pr\u00f3bek mpls ","3774088d":"## PCA","51c734da":"## Wst\u0119pna wizualizacja danych"}}