{"cell_type":{"75b40bab":"code","6c227461":"code","a32f152b":"code","b61d4452":"code","f021948e":"code","589bb62b":"code","0f6af16e":"markdown"},"source":{"75b40bab":"# Import packages \nimport os\nimport warnings\nfrom tqdm import tqdm\n\nimport pandas as pd \nimport numpy as np \nimport matplotlib.pyplot as plt \nimport seaborn as sns \nimport plotly.graph_objects as go \nimport plotly.express as px \n\n# Configuration \nwarnings.simplefilter('ignore')\npd.set_option('display.max_columns', 200)","6c227461":"# Variable definitions\nDATA_PATH_RAW = \"..\/input\/ubiquant-market-prediction\"\nDATA_PATH_RAW_CUSTOM = \"..\/input\/ubiquant-raw\"\nBASE_COLS = ['row_id', 'time_id', 'investment_id', 'target']\nFEAT_COLS = [f'f_{i}' for i in range(300)]","a32f152b":"df = pd.read_parquet(os.path.join(DATA_PATH_RAW_CUSTOM, 'train_light.parquet'))\ndf.head()","b61d4452":"target_map = df.pivot(index='investment_id', columns='time_id', values='target')\nn_samples_inv_id = df.groupby('investment_id').agg('size')\ncorrs_inv = target_map.T.corr()   # Derive corr of return rates of different invs\ncorrs_inv = abs(corrs_inv[corrs_inv != 1])   # Take off-diagonal corrs\ninv_ids_leg = list(n_samples_inv_id[n_samples_inv_id > 600].index)\ncorrs_inv = corrs_inv.loc[inv_ids_leg, inv_ids_leg]\n\ncorrs_max = {'inv_id1': [], 'inv_id2': [], 'corr': []}\nfor inv_id, corr_vec in corrs_inv.iterrows():\n    corrs_max['inv_id1'].append(inv_id)\n    corrs_max['inv_id2'].append(corr_vec.index[corr_vec.argmax()])\n    corrs_max['corr'].append(corr_vec.max())\ncorrs_max = pd.DataFrame.from_dict(corrs_max, orient='columns')\ncorrs_max.sort_values('corr', ascending=False, inplace=True)\ncorrs_max.head()","f021948e":"inv_ids_top = [194, 1144, 1121, 1929, 2406, 2669]\ntarget_map_ = target_map.loc[inv_ids_top, :]\nsns.pairplot(target_map_.T, corner=True)","589bb62b":"fig = go.Figure()\nfor i, inv_id in tqdm(enumerate(inv_ids_top)):\n    target_vec = target_map[target_map.index == inv_id].values[0]\n    target_cumsum = np.nancumsum(target_vec)\n    \n    fig.add_trace(go.Scatter(x=target_map.columns, y=target_cumsum, \n                             mode='lines', name=f'inv_{inv_id}'))\n    del target_vec, target_cumsum\n    \nfig.update_layout(\n    title=\"Cumulative Return Rate of Highly Correlated Investments\",\n    xaxis_title=\"time_id\",\n    yaxis_title=\"Cumulative Return Rate\",\n    legend_title=\"investment_id\",\n)\nfig.show()","0f6af16e":"# Spatial Dependency among Return Rate Series\n\n## About this Notebook\nIn this kernel, I illustrate some interesting observations found when exploring correlations of return rate series of different investments. The result shows that there might be some **spatial dependency** among different investments, which can be used to help model learn better skills.\n\nTo see more analysis, please refer to [Ubiquant Market Prediction - A Simple EDA\n](https:\/\/www.kaggle.com\/abaojiang\/ubiquant-market-prediction-a-simple-eda).\n\n<div class=\"alert alert-block alert-warning\">\n    <h4>If you find this kernel useful, please upvote it, thanks a lot!!<\/h4>\n<\/div>"}}