{"cell_type":{"e35ea785":"code","b0b3a996":"code","f6f5f110":"code","631f4343":"code","167a67dd":"code","d948b472":"code","0b261221":"code","5c109747":"code","1dba9502":"markdown","e9f0058b":"markdown","a82ce1d2":"markdown","784d53a6":"markdown"},"source":{"e35ea785":"# default import\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","b0b3a996":"# import package we need\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom datetime import timedelta\nfrom matplotlib import style\nimport plotly.graph_objects as go\n%matplotlib inline","f6f5f110":"# ignore the warnings\nimport warnings\nwarnings.filterwarnings('ignore')","631f4343":"# define the path\npath='..\/input\/bitcoin-historical-price-1h2017820202\/btc_1h.csv'","167a67dd":"# read the data into dataframe\nbtc=pd.read_csv(path,index_col=0,parse_dates=True)","d948b472":"# have a peek on the data\nbtc.head()","0b261221":"# define the header and parameters\ndef backtest(dataframe,\n             start_date,end_date):\n\n#---------------Date Selector---------------#    \n    \n        # selecting the startdate and enddate\n        # if start and enddate is not specify, then select all range\n        if start_date==None:\n            start_date=dataframe.index[1]\n        if end_date==None:\n            end_date=dataframe.index[-1]\n        # slicing the range if start\/end date is specified\n        data=dataframe.loc[start_date:end_date,:]\n\n#---------------Signal Generator---------------#    \n        \n        data['20high']=data['open'].rolling(20*24).max()\n        data['10low']=data['open'].rolling(10*24).min()\n        \n        data=data.dropna()\n\n        data['buysignal']=data['close']-data['20high']\n        data['sellsignal']=data['close']-data['10low']\n\n        def buysig(series):\n            if series>0:\n                return 1\n            if series<0:\n                return 0\n\n        def sellsig(series):\n            if series>0:\n                return 0\n            if series<0:\n                return -1\n\n        # apply the transformation function to dataframe\n        data.loc[:,'buysignal']=data.loc[:,'buysignal'].apply(lambda x: buysig(x))\n        data.loc[:,'sellsignal']=data.loc[:,'sellsignal'].apply(lambda x: sellsig(x))\n\n        data['signal']=data['buysignal']+data['sellsignal']\n\n#---------------Account Setup---------------#    \n        \n        # setup counting system\n        holding=0        ## how many bitcoin is currently holding\n        holdingcost=0    ## prime cost for getting the bitcoin we are holding\n        outflow=0        ## tracking on cash outflow (cumulative)\n        inflow=0         ## tracking on cash inflow (cumulative)\n        order={}         ## a dict should contain buy\/sell date and its price\n\n#---------------Trading Loop---------------#\n\n        # iterating over the dataframe by iterrows to execute the order\n        for date,row in data.iterrows():\n\n            # if signal is openpos(signal=1), and there's no holding bitcoin(holding=0) then\n            if row['signal']==1 and holding==0:\n\n                # add 1 bitcoin into holding\n                holding=holding+1\n                # track on all-time cash outflow\n                outflow-=row['close']\n                # track on the single time buyin cost\n                holdingcost+=row['close']\n                # recortd the cost and buytime into dict\n                order[date]=-row['close']\n                # print out the on-time buyin action\n                print('Buy:{buy_create}$ @ {dt}'.format(buy_create=order[date],dt=date))\n\n            # else if signal is less than 0,and holding any of bitcoin then sell out all\n            elif row['signal']< 0 and holding>0:\n\n                # track the all-time cash inflow (before selling)\n                inflow+= row['close']*holding\n                # record the sell action into dict             \n                order[date]=+row['close']*holding\n                # reset the holding number (since we have sold all)\n                holding=0\n                # reset the holding cost (since we don't hold anything now)\n                holdingcost=0\n                # print out the on-time sell out action\n                print('Sell:{sell_create}$ @ {dt}'.format(sell_create=round(order[date],2),dt=date)) ## round\n\n            # record bitcoin holding qty in dataframe \n            data.loc[date,'holding']=holding\n            # record currently portfolio value in dataframe\n            data.loc[date,'portvalue']=data.loc[date,'holding']*row['close']\n            # record currently holding cost in dataframe\n            data.loc[date,'holdingcost']=holdingcost\n\n            # record profit in each timestamp\n            data.loc[date,'profit']=inflow+outflow+data.loc[date,'portvalue']\n\n#---------------Print Out Result---------------#\n\n        # calculation of the ROI\n        data['roi']=(data['portvalue']-data['holdingcost'])\/data['holdingcost']\n        data['roi']=data['roi'].fillna(0)\n\n        # print a seperator\n        print('------------------------Summary------------------------')\n        # print the total profit made\n        print('Profit(Incl Bitcoin Holding):{profit:} $'.format(profit=round((outflow+inflow+data.loc[data.index[-1],'portvalue'])))) ## round \n        # print the total profit made\n        print('Maximum Holding Cost(USDT):{profit:} $'.format(profit=(round(data['holdingcost'].max())))) ## round\n        # print the total time used\n        print('Duration:{timeframe:}'.format(timeframe=(data.index[-1]-data.index[0]))) \n        # print the maximum drawdown rate\n        print('Max Drawdown:{drawdown:} %'.format(drawdown=round(100*data['roi'].min())))\n\n#---------------Plot Nicely with Plotly---------------#        \n\n        # create empty list for saving buy_date and sell_date\n        buy_date=[]\n        sell_date=[]\n\n        # loop over the order dictionary and append buy & sell date\n        for key,value in order.items():\n            if value>0:\n                sell_date.append(key)\n            if value<0:\n                buy_date.append(key)\n\n        # extract the buy price and sell price\n        sp=data.loc[sell_date,'close']\n        bp=data.loc[buy_date,'close']\n        \n        # setup plotly object figure\n        fig=go.Figure()\n\n        # adding trace of close price and profit\n        fig.add_trace(go.Scatter(x=data.index,y=data['close'],name='Close',line_color='SlateBlue'))\n\n        fig.add_trace(go.Scatter(x=data.index,y=data['profit'],name='Profit',line_color='LightPink'))\n\n        # adding marker of Buyin and sell out \n        fig.add_trace(go.Scatter(x=buy_date,y=np.abs(bp),\n                                name='Buy',mode='markers',\n                                marker=dict(size=10,symbol=5),\n                                marker_color='red',\n                                text='BUY'))\n\n        fig.add_trace(go.Scatter(x=sell_date,y=np.abs(sp),\n                                name='Sell',mode='markers',\n                                marker=dict(size=10,symbol=6),\n                                marker_color='lime',\n                                text='SELL'))\n\n        # styling the plot and put text on it\n        fig.update_layout(title_text='Turtle_Backtest',\n                        xaxis_rangeslider_visible=True,\n                        template='gridon')\n\n        # show the plot\n        fig.show()\n\n        # return the data into dataframe\n        return data","5c109747":"# run the backtester\ndf=backtest(\n    dataframe=btc,\n    start_date='20170101',\n    end_date='20200210',\n    )","1dba9502":"# Referrence of Turtle Trading Strategy\n\n- current price is higher than the Highest price in the previous 20 days -> buy in\n- current price is lower than the lowest price in the previous 10 days -> sell out","e9f0058b":"# Backtester Construction\n\nWe have 5 chunk seperated in the code\n\n- Data selector\n- **Signal generator**\n- Trading Loop\n- Result\n- Plot Setup","a82ce1d2":"# Parameter of backtest\n1. dataframe : the dataframe you are going to do backtesting (should contain OHLC data, and the date is sorted by ascending)\n2. start_date : the date of backtest started (should be a string, like '20170101')\n3. end_date : the date of backtest ended (should be a string, like '20190101')","784d53a6":"# Target\n- Construct a Backtest Tool for Bitcoin Trading\n- Using Turtle Trading Strategy with the Backtest Tool (Actually you can use any other strategy)\n- Plot the result nicely (with plotly)"}}