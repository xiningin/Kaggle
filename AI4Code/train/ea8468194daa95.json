{"cell_type":{"51ac4eb2":"code","942104b6":"code","8e71833b":"code","3a24cb52":"code","bafe9c10":"code","86cdb9dc":"code","7a9c317d":"code","ee28cb70":"code","e4758eba":"code","2aebac82":"code","dbb37da7":"code","1bbb161c":"code","a378a868":"code","a03cdb73":"code","a95d7822":"code","bbc934d9":"code","5f21a75d":"code","9e137302":"code","ff3bf63c":"code","984602fc":"code","f3848278":"code","e06fbf6e":"code","15d1934a":"code","0e15f127":"code","e7189584":"code","30f47527":"code","d0506e6b":"code","692b2793":"code","64dafa49":"code","286735a1":"code","35de0469":"code","72734d1c":"code","768d2142":"code","c01648b7":"code","9ba74746":"code","3f18656f":"code","66e6d6fe":"code","7bf10cbc":"code","64ee4dd4":"code","4a9d443a":"code","7d8f6726":"code","a4dfea37":"code","a04c83b9":"code","db5fb484":"code","31913608":"code","32469b25":"code","44b67548":"code","fe4781f2":"code","61a68082":"code","58f1f9dd":"code","9fbd5232":"code","a8784ba8":"code","7d6d8fc9":"code","a7cd7b96":"code","959a1393":"code","d1490617":"code","4d8e4a6f":"markdown","8dbeba29":"markdown","c2a30d83":"markdown","21eb1def":"markdown","302af4c3":"markdown","754b0cbc":"markdown","b778c25e":"markdown","d4973c86":"markdown","8ea46f9c":"markdown","f670c650":"markdown","f367442b":"markdown","a0a79a58":"markdown","4c76c1c2":"markdown","1d61772d":"markdown","5ca52ef0":"markdown"},"source":{"51ac4eb2":"%matplotlib inline","942104b6":"# import necessary library \nfrom fastai.imports import *\nfrom pandas_summary import DataFrameSummary\nfrom sklearn.ensemble import RandomForestRegressor, RandomForestClassifier\nfrom IPython.display import display\n\nfrom sklearn import metrics","8e71833b":"from sklearn_pandas import DataFrameMapper\nfrom sklearn.preprocessing import LabelEncoder, Imputer, StandardScaler\nfrom pandas.api.types import is_string_dtype, is_numeric_dtype\nfrom sklearn.ensemble import forest\nfrom sklearn.tree import export_graphviz\n\n\ndef set_plot_sizes(sml, med, big):\n    plt.rc('font', size=sml)          # controls default text sizes\n    plt.rc('axes', titlesize=sml)     # fontsize of the axes title\n    plt.rc('axes', labelsize=med)    # fontsize of the x and y labels\n    plt.rc('xtick', labelsize=sml)    # fontsize of the tick labels\n    plt.rc('ytick', labelsize=sml)    # fontsize of the tick labels\n    plt.rc('legend', fontsize=sml)    # legend fontsize\n    plt.rc('figure', titlesize=big)  # fontsize of the figure title\n\ndef parallel_trees(m, fn, n_jobs=8):\n        return list(ProcessPoolExecutor(n_jobs).map(fn, m.estimators_))\n\ndef draw_tree(t, df, size=10, ratio=0.6, precision=0):\n    \"\"\" Draws a representation of a random forest in IPython.\n    Parameters:\n    -----------\n    t: The tree you wish to draw\n    df: The data used to train the tree. This is used to get the names of the features.\n    \"\"\"\n    s=export_graphviz(t, out_file=None, feature_names=df.columns, filled=True,\n                      special_characters=True, rotate=True, precision=precision)\n    IPython.display.display(graphviz.Source(re.sub('Tree {',\n       f'Tree {{ size={size}; ratio={ratio}', s)))\n\ndef combine_date(years, months=1, days=1, weeks=None, hours=None, minutes=None,\n              seconds=None, milliseconds=None, microseconds=None, nanoseconds=None):\n    years = np.asarray(years) - 1970\n    months = np.asarray(months) - 1\n    days = np.asarray(days) - 1\n    types = ('<M8[Y]', '<m8[M]', '<m8[D]', '<m8[W]', '<m8[h]',\n             '<m8[m]', '<m8[s]', '<m8[ms]', '<m8[us]', '<m8[ns]')\n    vals = (years, months, days, weeks, hours, minutes, seconds,\n            milliseconds, microseconds, nanoseconds)\n    return sum(np.asarray(v, dtype=t) for t, v in zip(types, vals)\n               if v is not None)\n\ndef get_sample(df,n):\n    \"\"\" Gets a random sample of n rows from df, without replacement.\n    Parameters:\n    -----------\n    df: A pandas data frame, that you wish to sample from.\n    n: The number of rows you wish to sample.\n    Returns:\n    --------\n    return value: A random sample of n rows of df.\n    Examples:\n    ---------\n    >>> df = pd.DataFrame({'col1' : [1, 2, 3], 'col2' : ['a', 'b', 'a']})\n    >>> df\n       col1 col2\n    0     1    a\n    1     2    b\n    2     3    a\n    >>> get_sample(df, 2)\n       col1 col2\n    1     2    b\n    2     3    a\n    \"\"\"\n    idxs = sorted(np.random.permutation(len(df))[:n])\n    return df.iloc[idxs].copy()\n\ndef add_datepart(df, fldname, drop=True, time=False, errors=\"raise\"):\t\n    \"\"\"add_datepart converts a column of df from a datetime64 to many columns containing\n    the information from the date. This applies changes inplace.\n    Parameters:\n    -----------\n    df: A pandas data frame. df gain several new columns.\n    fldname: A string that is the name of the date column you wish to expand.\n        If it is not a datetime64 series, it will be converted to one with pd.to_datetime.\n    drop: If true then the original date column will be removed.\n    time: If true time features: Hour, Minute, Second will be added.\n    Examples:\n    ---------\n    >>> df = pd.DataFrame({ 'A' : pd.to_datetime(['3\/11\/2000', '3\/12\/2000', '3\/13\/2000'], infer_datetime_format=False) })\n    >>> df\n        A\n    0   2000-03-11\n    1   2000-03-12\n    2   2000-03-13\n    >>> add_datepart(df, 'A')\n    >>> df\n        AYear AMonth AWeek ADay ADayofweek ADayofyear AIs_month_end AIs_month_start AIs_quarter_end AIs_quarter_start AIs_year_end AIs_year_start AElapsed\n    0   2000  3      10    11   5          71         False         False           False           False             False        False          952732800\n    1   2000  3      10    12   6          72         False         False           False           False             False        False          952819200\n    2   2000  3      11    13   0          73         False         False           False           False             False        False          952905600\n    \"\"\"\n    fld = df[fldname]\n    fld_dtype = fld.dtype\n    if isinstance(fld_dtype, pd.core.dtypes.dtypes.DatetimeTZDtype):\n        fld_dtype = np.datetime64\n\n    if not np.issubdtype(fld_dtype, np.datetime64):\n        df[fldname] = fld = pd.to_datetime(fld, infer_datetime_format=True, errors=errors)\n    targ_pre = re.sub('[Dd]ate$', '', fldname)\n    attr = ['Year', 'Month', 'Week', 'Day', 'Dayofweek', 'Dayofyear',\n            'Is_month_end', 'Is_month_start', 'Is_quarter_end', 'Is_quarter_start', 'Is_year_end', 'Is_year_start']\n    if time: attr = attr + ['Hour', 'Minute', 'Second']\n    for n in attr: df[targ_pre + n] = getattr(fld.dt, n.lower())\n    df[targ_pre + 'Elapsed'] = fld.astype(np.int64) \/\/ 10 ** 9\n    if drop: df.drop(fldname, axis=1, inplace=True)\n\ndef is_date(x): return np.issubdtype(x.dtype, np.datetime64)\n\ndef train_cats(df):\n    \"\"\"Change any columns of strings in a panda's dataframe to a column of\n    categorical values. This applies the changes inplace.\n    Parameters:\n    -----------\n    df: A pandas dataframe. Any columns of strings will be changed to\n        categorical values.\n    Examples:\n    ---------\n    >>> df = pd.DataFrame({'col1' : [1, 2, 3], 'col2' : ['a', 'b', 'a']})\n    >>> df\n       col1 col2\n    0     1    a\n    1     2    b\n    2     3    a\n    note the type of col2 is string\n    >>> train_cats(df)\n    >>> df\n       col1 col2\n    0     1    a\n    1     2    b\n    2     3    a\n    now the type of col2 is category\n    \"\"\"\n    for n,c in df.items():\n        if is_string_dtype(c): df[n] = c.astype('category').cat.as_ordered()\n\ndef apply_cats(df, trn):\n    \"\"\"Changes any columns of strings in df into categorical variables using trn as\n    a template for the category codes.\n    Parameters:\n    -----------\n    df: A pandas dataframe. Any columns of strings will be changed to\n        categorical values. The category codes are determined by trn.\n    trn: A pandas dataframe. When creating a category for df, it looks up the\n        what the category's code were in trn and makes those the category codes\n        for df.\n    Examples:\n    ---------\n    >>> df = pd.DataFrame({'col1' : [1, 2, 3], 'col2' : ['a', 'b', 'a']})\n    >>> df\n       col1 col2\n    0     1    a\n    1     2    b\n    2     3    a\n    note the type of col2 is string\n    >>> train_cats(df)\n    >>> df\n       col1 col2\n    0     1    a\n    1     2    b\n    2     3    a\n    now the type of col2 is category {a : 1, b : 2}\n    >>> df2 = pd.DataFrame({'col1' : [1, 2, 3], 'col2' : ['b', 'a', 'a']})\n    >>> apply_cats(df2, df)\n           col1 col2\n        0     1    b\n        1     2    a\n        2     3    a\n    now the type of col is category {a : 1, b : 2}\n    \"\"\"\n    for n,c in df.items():\n        if (n in trn.columns) and (trn[n].dtype.name=='category'):\n            df[n] = c.astype('category').cat.as_ordered()\n            df[n].cat.set_categories(trn[n].cat.categories, ordered=True, inplace=True)\n\ndef fix_missing(df, col, name, na_dict):\n    \"\"\" Fill missing data in a column of df with the median, and add a {name}_na column\n    which specifies if the data was missing.\n    Parameters:\n    -----------\n    df: The data frame that will be changed.\n    col: The column of data to fix by filling in missing data.\n    name: The name of the new filled column in df.\n    na_dict: A dictionary of values to create na's of and the value to insert. If\n        name is not a key of na_dict the median will fill any missing data. Also\n        if name is not a key of na_dict and there is no missing data in col, then\n        no {name}_na column is not created.\n    Examples:\n    ---------\n    >>> df = pd.DataFrame({'col1' : [1, np.NaN, 3], 'col2' : [5, 2, 2]})\n    >>> df\n       col1 col2\n    0     1    5\n    1   nan    2\n    2     3    2\n    >>> fix_missing(df, df['col1'], 'col1', {})\n    >>> df\n       col1 col2 col1_na\n    0     1    5   False\n    1     2    2    True\n    2     3    2   False\n    >>> df = pd.DataFrame({'col1' : [1, np.NaN, 3], 'col2' : [5, 2, 2]})\n    >>> df\n       col1 col2\n    0     1    5\n    1   nan    2\n    2     3    2\n    >>> fix_missing(df, df['col2'], 'col2', {})\n    >>> df\n       col1 col2\n    0     1    5\n    1   nan    2\n    2     3    2\n    >>> df = pd.DataFrame({'col1' : [1, np.NaN, 3], 'col2' : [5, 2, 2]})\n    >>> df\n       col1 col2\n    0     1    5\n    1   nan    2\n    2     3    2\n    >>> fix_missing(df, df['col1'], 'col1', {'col1' : 500})\n    >>> df\n       col1 col2 col1_na\n    0     1    5   False\n    1   500    2    True\n    2     3    2   False\n    \"\"\"\n    if is_numeric_dtype(col):\n        if pd.isnull(col).sum() or (name in na_dict):\n            df[name+'_na'] = pd.isnull(col)\n            filler = na_dict[name] if name in na_dict else col.median()\n            df[name] = col.fillna(filler)\n            na_dict[name] = filler\n    return na_dict\n\ndef numericalize(df, col, name, max_n_cat):\n    \"\"\" Changes the column col from a categorical type to it's integer codes.\n    Parameters:\n    -----------\n    df: A pandas dataframe. df[name] will be filled with the integer codes from\n        col.\n    col: The column you wish to change into the categories.\n    name: The column name you wish to insert into df. This column will hold the\n        integer codes.\n    max_n_cat: If col has more categories than max_n_cat it will not change the\n        it to its integer codes. If max_n_cat is None, then col will always be\n        converted.\n    Examples:\n    ---------\n    >>> df = pd.DataFrame({'col1' : [1, 2, 3], 'col2' : ['a', 'b', 'a']})\n    >>> df\n       col1 col2\n    0     1    a\n    1     2    b\n    2     3    a\n    note the type of col2 is string\n    >>> train_cats(df)\n    >>> df\n       col1 col2\n    0     1    a\n    1     2    b\n    2     3    a\n    now the type of col2 is category { a : 1, b : 2}\n    >>> numericalize(df, df['col2'], 'col3', None)\n       col1 col2 col3\n    0     1    a    1\n    1     2    b    2\n    2     3    a    1\n    \"\"\"\n    if not is_numeric_dtype(col) and ( max_n_cat is None or len(col.cat.categories)>max_n_cat):\n        df[name] = col.cat.codes+1\n\ndef scale_vars(df, mapper):\n    warnings.filterwarnings('ignore', category=sklearn.exceptions.DataConversionWarning)\n    if mapper is None:\n        map_f = [([n],StandardScaler()) for n in df.columns if is_numeric_dtype(df[n])]\n        mapper = DataFrameMapper(map_f).fit(df)\n    df[mapper.transformed_names_] = mapper.transform(df)\n    return mapper\n\ndef proc_df(df, y_fld=None, skip_flds=None, ignore_flds=None, do_scale=False, na_dict=None,\n            preproc_fn=None, max_n_cat=None, subset=None, mapper=None):\n    \"\"\" proc_df takes a data frame df and splits off the response variable, and\n    changes the df into an entirely numeric dataframe. For each column of df \n    which is not in skip_flds nor in ignore_flds, na values are replaced by the\n    median value of the column.\n    Parameters:\n    -----------\n    df: The data frame you wish to process.\n    y_fld: The name of the response variable\n    skip_flds: A list of fields that dropped from df.\n    ignore_flds: A list of fields that are ignored during processing.\n    do_scale: Standardizes each column in df. Takes Boolean Values(True,False)\n    na_dict: a dictionary of na columns to add. Na columns are also added if there\n        are any missing values.\n    preproc_fn: A function that gets applied to df.\n    max_n_cat: The maximum number of categories to break into dummy values, instead\n        of integer codes.\n    subset: Takes a random subset of size subset from df.\n    mapper: If do_scale is set as True, the mapper variable\n        calculates the values used for scaling of variables during training time (mean and standard deviation).\n    Returns:\n    --------\n    [x, y, nas, mapper(optional)]:\n        x: x is the transformed version of df. x will not have the response variable\n            and is entirely numeric.\n        y: y is the response variable\n        nas: returns a dictionary of which nas it created, and the associated median.\n        mapper: A DataFrameMapper which stores the mean and standard deviation of the corresponding continuous\n        variables which is then used for scaling of during test-time.\n    Examples:\n    ---------\n    >>> df = pd.DataFrame({'col1' : [1, 2, 3], 'col2' : ['a', 'b', 'a']})\n    >>> df\n       col1 col2\n    0     1    a\n    1     2    b\n    2     3    a\n    note the type of col2 is string\n    >>> train_cats(df)\n    >>> df\n       col1 col2\n    0     1    a\n    1     2    b\n    2     3    a\n    now the type of col2 is category { a : 1, b : 2}\n    >>> x, y, nas = proc_df(df, 'col1')\n    >>> x\n       col2\n    0     1\n    1     2\n    2     1\n    >>> data = DataFrame(pet=[\"cat\", \"dog\", \"dog\", \"fish\", \"cat\", \"dog\", \"cat\", \"fish\"],\n                 children=[4., 6, 3, 3, 2, 3, 5, 4],\n                 salary=[90, 24, 44, 27, 32, 59, 36, 27])\n    >>> mapper = DataFrameMapper([(:pet, LabelBinarizer()),\n                          ([:children], StandardScaler())])\n    >>>round(fit_transform!(mapper, copy(data)), 2)\n    8x4 Array{Float64,2}:\n    1.0  0.0  0.0   0.21\n    0.0  1.0  0.0   1.88\n    0.0  1.0  0.0  -0.63\n    0.0  0.0  1.0  -0.63\n    1.0  0.0  0.0  -1.46\n    0.0  1.0  0.0  -0.63\n    1.0  0.0  0.0   1.04\n    0.0  0.0  1.0   0.21\n    \"\"\"\n    if not ignore_flds: ignore_flds=[]\n    if not skip_flds: skip_flds=[]\n    if subset: df = get_sample(df,subset)\n    else: df = df.copy()\n    ignored_flds = df.loc[:, ignore_flds]\n    df.drop(ignore_flds, axis=1, inplace=True)\n    if preproc_fn: preproc_fn(df)\n    if y_fld is None: y = None\n    else:\n        if not is_numeric_dtype(df[y_fld]): df[y_fld] = df[y_fld].cat.codes\n        y = df[y_fld].values\n        skip_flds += [y_fld]\n    df.drop(skip_flds, axis=1, inplace=True)\n\n    if na_dict is None: na_dict = {}\n    else: na_dict = na_dict.copy()\n    na_dict_initial = na_dict.copy()\n    for n,c in df.items(): na_dict = fix_missing(df, c, n, na_dict)\n    if len(na_dict_initial.keys()) > 0:\n        df.drop([a + '_na' for a in list(set(na_dict.keys()) - set(na_dict_initial.keys()))], axis=1, inplace=True)\n    if do_scale: mapper = scale_vars(df, mapper)\n    for n,c in df.items(): numericalize(df, c, n, max_n_cat)\n    df = pd.get_dummies(df, dummy_na=True)\n    df = pd.concat([ignored_flds, df], axis=1)\n    res = [df, y, na_dict]\n    if do_scale: res = res + [mapper]\n    return res\n\ndef rf_feat_importance(m, df):\n    return pd.DataFrame({'cols':df.columns, 'imp':m.feature_importances_}\n                       ).sort_values('imp', ascending=False)\n\ndef set_rf_samples(n):\n    \"\"\" Changes Scikit learn's random forests to give each tree a random sample of\n    n random rows.\n    \"\"\"\n    forest._generate_sample_indices = (lambda rs, n_samples:\n        forest.check_random_state(rs).randint(0, n_samples, n))\n\ndef reset_rf_samples():\n    \"\"\" Undoes the changes produced by set_rf_samples.\n    \"\"\"\n    forest._generate_sample_indices = (lambda rs, n_samples:\n        forest.check_random_state(rs).randint(0, n_samples, n_samples))\n\ndef get_nn_mappers(df, cat_vars, contin_vars):\n    # Replace nulls with 0 for continuous, \"\" for categorical.\n    for v in contin_vars: df[v] = df[v].fillna(df[v].max()+100,)\n    for v in cat_vars: df[v].fillna('#NA#', inplace=True)\n\n    # list of tuples, containing variable and instance of a transformer for that variable\n    # for categoricals, use LabelEncoder to map to integers. For continuous, standardize\n    cat_maps = [(o, LabelEncoder()) for o in cat_vars]\n    contin_maps = [([o], StandardScaler()) for o in contin_vars]\n    return DataFrameMapper(cat_maps).fit(df), DataFrameMapper(contin_maps).fit(df)","3a24cb52":"df_raw = pd.read_csv('..\/input\/train.csv')\ndf_raw.shape","bafe9c10":"test_data = pd.read_csv('..\/input\/test.csv')\ntest_data.shape","86cdb9dc":"# log, because the competition want root mean square log error\ndf_raw.SalePrice = np.log(df_raw.SalePrice)","7a9c317d":"# function for displaying missing percentage of missing value for each columns\ndef display_all(df):\n    with pd.option_context(\"display.max_rows\", 1000): \n        with pd.option_context(\"display.max_columns\", 1000): \n            display(df)\n\ndisplay_all(df_raw.isnull().sum().sort_index()\/len(df_raw))","ee28cb70":"# turn the text all the text data into categorical\ntrain_cats(df_raw)","e4758eba":"# replacing missing value with median of the columns\ndf, y, nas = proc_df(df_raw, 'SalePrice')","2aebac82":"# this funnction add two more columns of total living area and age of the house\ndef transform(df):\n    df['TotalLivingSF'] = df['GrLivArea'] + df['TotalBsmtSF'] - df['LowQualFinSF']\n    df['AgeSold'] = df['YrSold'] - df['YearBuilt']\n    \ntransform(df)","dbb37da7":"# split into train and validation set\ndef split_vals(a,n): return a[:n].copy(), a[n:].copy()\n\nn_valid = int(1460 * 0.1)\nn_trn = len(df)-n_valid\nraw_train, raw_val = split_vals(df_raw, n_trn)\nX_train, X_val = split_vals(df, n_trn)\ny_train, y_val = split_vals(y, n_trn)\n\nX_train.shape, y_train.shape, X_val.shape","1bbb161c":"# to calculate rmse\ndef rmse(x,y):\n    return math.sqrt(((x-y)**2).mean())\n\n# to compare between train set and validation set and compare the rmse and r2 score\ndef print_score(m):\n    res = [rmse(m.predict(X_train), y_train), rmse(m.predict(X_val), y_val),\n                m.score(X_train, y_train), m.score(X_val, y_val)]\n    if hasattr(m, 'oob_score_'): res.append(m.oob_score_)\n    print(res)","a378a868":"# fit the base model and print the score \nm = RandomForestRegressor(n_jobs=-1,random_state = 1)\nm.fit(X_train, y_train)\nprint_score(m)","a03cdb73":"import IPython\nimport graphviz\n\ndef draw_tree(t, df, size=10, ratio=0.6, precision=0):\n    \"\"\" Draws a representation of a random forest in IPython.\n    Parameters:\n    -----------\n    t: The tree you wish to draw\n    df: The data used to train the tree. This is used to get the names of the features.\n    \"\"\"\n    s=export_graphviz(t, out_file=None, feature_names=df.columns, filled=True,\n                      special_characters=True, rotate=True, precision=precision, max_depth=2)\n    IPython.display.display(graphviz.Source(re.sub('Tree {',\n       f'Tree {{ size={size}; ratio={ratio}', s)))\n\ndraw_tree(m.estimators_[0], df)","a95d7822":"m = RandomForestRegressor(n_jobs=-1)\nm.fit(X_train, y_train)\nprint_score(m)","bbc934d9":"preds = np.stack([t.predict(X_val) for t in m.estimators_])\npreds[:,0], np.mean(preds[:,0]), y_val[0]","5f21a75d":"preds.shape","9e137302":"plt.plot([metrics.r2_score(y_val, np.mean(preds[:i+1], axis=0)) for i in range(10)]);","ff3bf63c":"m = RandomForestRegressor(n_estimators=60, n_jobs=-10, oob_score=True, random_state=1)\nm.fit(X_train, y_train)\nprint_score(m)","984602fc":"m = RandomForestRegressor(n_estimators=100, n_jobs=-10, oob_score=True, random_state=1)\nm.fit(X_train, y_train)\nprint_score(m)","f3848278":"m = RandomForestRegressor(n_estimators=100, n_jobs=-10, oob_score=True, min_samples_leaf=1, random_state=1)\nm.fit(X_train, y_train)\nprint_score(m)","e06fbf6e":"m = RandomForestRegressor(n_estimators=100, n_jobs=-10, oob_score=True, min_samples_leaf=2, random_state=1)\nm.fit(X_train, y_train)\nprint_score(m)","15d1934a":"m = RandomForestRegressor(n_estimators=60, n_jobs=-10, oob_score=True, min_samples_leaf=2, max_features=0.5,random_state=1)\nm.fit(X_train, y_train)\nprint_score(m)","0e15f127":"m = RandomForestRegressor(n_estimators=60, n_jobs=-10, oob_score=True, min_samples_leaf=1, max_features=0.4,random_state=1)\nm.fit(X_train, y_train)\nprint_score(m)","e7189584":"# we want to see the confidence of our model by using standard deviation\n# we selected the first row of actual and prediction\ndef get_preds(t): return t.predict(X_val)\n%time preds = np.stack(parallel_trees(m, get_preds))\nnp.mean(preds[:,0]), np.std(preds[:,0])","30f47527":"# column MSZoning is selected to see the mean and std\nx = raw_val.copy()\nx['pred_std'] = np.std(preds, axis=0)\nx['pred'] = np.mean(preds, axis=0)\nx.MSZoning.value_counts().plot.barh();","d0506e6b":"flds = ['MSZoning', 'SalePrice', 'pred', 'pred_std']\nmsz_summ = x[flds].groupby('MSZoning', as_index=False).mean()\nmsz_summ","692b2793":"# Sale price of each level of MSZoning\nmsz_summ = msz_summ[~pd.isnull(msz_summ.SalePrice)]\nmsz_summ.plot('MSZoning', 'SalePrice', 'barh', xlim=(0,20));","64dafa49":"# Sale price of each level of MSZoning prediciton. the black bar is the error. the longest the largest the error.\nmsz_summ.plot('MSZoning', 'pred', 'barh', xerr='pred_std', alpha=0.6, xlim=(0,20));","286735a1":"# RH has highest ration because it has the smallest group \n(msz_summ.pred_std\/msz_summ.pred).sort_values(ascending=False)","35de0469":"fi = rf_feat_importance(m, df); fi[:10]","72734d1c":"fi.plot('cols', 'imp', figsize=(10,6), legend=False);","768d2142":"def plot_fi(fi): return fi.plot('cols', 'imp', 'barh', figsize=(12,15), legend=False)","c01648b7":"# this is where we sit with client or domain expert to discuss whether it is legit or not this importance.\n# and this where we study each of the columns.\nplot_fi(fi[:]);","9ba74746":"# trying to see whether it improve the model or not when we only keep the necessary ones.\nto_keep = fi[fi.imp>0.005].cols; len(to_keep)","3f18656f":"# modeling with the selected columns\ndf_keep = df[to_keep].copy()\nX_train, X_val = split_vals(df_keep, n_trn)","66e6d6fe":"m = RandomForestRegressor(n_estimators=60, n_jobs=1, oob_score=True, min_samples_leaf=1, \n                                                max_features=0.5,random_state=1)\nm.fit(X_train, y_train)\nprint_score(m)","7bf10cbc":"fi = rf_feat_importance(m, df_keep)\nplot_fi(fi);","64ee4dd4":"# max_n_cat turn any category of 7 and less into multiple columns according to the number of categories. if it is more than 7 it does not change it.\ndf_trn2, y_trn, nas = proc_df(df_raw, 'SalePrice', max_n_cat=7)\nX_train, X_val = split_vals(df_trn2, n_trn)\n\nm = RandomForestRegressor(n_estimators=60, min_samples_leaf=1, max_features=0.5, n_jobs=-1, oob_score=True)\nm.fit(X_train, y_train)\nprint_score(m)","4a9d443a":"fi = rf_feat_importance(m, df_trn2)\nplot_fi(fi[:25]);","7d8f6726":"from scipy.cluster import hierarchy as hc","a4dfea37":"\ncorr = np.round(scipy.stats.spearmanr(df_keep).correlation, 4)\ncorr_condensed = hc.distance.squareform(1-corr)\nz = hc.linkage(corr_condensed, method='average')\nfig = plt.figure(figsize=(16,10))\ndendrogram = hc.dendrogram(z, labels=df_keep.columns, orientation='left', leaf_font_size=16)\nplt.show()","a04c83b9":"# getting the baseline\n# continue from feature importance dataset\ndef get_oob(df):\n    m = RandomForestRegressor(max_features=0.4, min_samples_leaf=1,n_estimators=300,n_jobs=-1,oob_score=True,random_state=11)\n    x, _ = split_vals(df, n_trn)\n    m.fit(x, y_train)\n    return m.oob_score_","db5fb484":"get_oob(df_keep)","31913608":"# we want to see if we drop the column whether the oob score improve or not.\nfor c in ('GrLivArea','TotalLivingSF','GarageCars', 'GarageArea', 'TotalBsmtSF', '1stFlrSF', 'GarageYrBlt','YearBuilt','Fireplaces','FireplaceQu'):\n    print(c, get_oob(df_keep.drop(c, axis=1)))","32469b25":"# when we drop this columns the the oob score increase\nto_drop = ['GrLivArea', 'GarageCars', 'TotalBsmtSF', 'GarageYrBlt', 'Fireplaces']\nget_oob(df_keep.drop(to_drop, axis=1))","44b67548":"# drop the column to run the model again\ndf_keep.drop(to_drop,inplace=True,axis=1)","fe4781f2":"len(df_keep.columns)","61a68082":"from sklearn.model_selection import train_test_split\nm = RandomForestRegressor(max_features=0.4, min_samples_leaf=1,n_estimators=300,n_jobs=-1,oob_score=True,random_state=11)\nX_train,X_val,y_train,y_val = train_test_split(df,y,test_size =  0.25,random_state = 11)\nm.fit(X_train, y_train)\nprint_score(m)","58f1f9dd":"columns = df_keep.columns\ncolumns","9fbd5232":"# combine train and validation and column that have been reduced and optimized\ndf_full_data = df[columns]\nprint(df_full_data.columns)\nm.fit(df_full_data, y)","a8784ba8":"df_test = pd.read_csv('..\/input\/test.csv')\ntransform(df_test) # add \"ageSold\" and \"TotalLivingSF\" to the set.\ntrain_cats(df_test) \ndf_test,_,_ = proc_df(df_test,na_dict = nas)\nId = df_test.Id\ndf_test = df_test[columns]\nans = np.stack((Id,np.exp(m.predict(df_test))),axis= 1)","7d6d8fc9":"ans = DataFrame(data = ans, columns=['Id', 'SalePrice'])","a7cd7b96":"ans.dtypes","959a1393":"ans['Id']= ans['Id'].astype(np.int32)\nans.to_csv('submission.csv', index=False)","d1490617":"ans.dtypes","4d8e4a6f":"## Drawing Tree","8dbeba29":"## Base model","c2a30d83":"## Intro to bagging","21eb1def":"## How to read r-squared?\n R-squared is measure with anything that less than 1. The best score is anything that close to 1. We can also see whether the model is overfit or not based on r-squared. If we can see from the model above, in training set the score is 0.973 but on the new set it gave 0.863 score.","302af4c3":"## Confidence based on tree variance","754b0cbc":"## Finding the best hyperparameters\nMin samples leaf is to set the last leaf to only 3 samples. Jeremy recommendation(1,3,5,10,25,100). This dataset is too little which is good to have only 1 last data in the leaf.\n\nMax features is to set at each split of a tree  a different half (0.5) of the features. It will be make the tree more varied and more generalized. We can tweak this features to none( select all features), 0.5, sqrt or log2.","b778c25e":"The above code take 10 trees predictions and average all that and compare with validation. If you can see the average score and the actual one is not too far.","d4973c86":"## One hot encoding\nIt can reduce the decision needed to make by the tree by making extra columns for each category. According to Jeremy, it is okay to put many columns for random forest. To understand the model, we can always one hot encoding.","8ea46f9c":"## Dendogram\nUsing hierarchical clustering to remove redundant features. Finding the similar features.","f670c650":" ## Feature importance\n This method randomly shuffling the row in a column. Each column one at a time and seeing the accuracy with our created model. We need to do this because we want to see the interactions of the features. Feature importance actually can be use in other models. When someone say using the linear coefficient to search for importance we should be skeptical because unlike random forest it does not have interaction with other features.","f367442b":"One hot encoding make some category stand out as the most important. Before this only exterqual column is mention in the importnace but after the one hot encoding, it stated more detailed that exterqual_ta has more importance than the rest of other exterqual category.","a0a79a58":"I do not know how to import FastAI 0.7 version into Kaggle so I copied the whole code below.","4c76c1c2":"The graph shows that r2 is increasing when tree increase which is good.","1d61772d":"Some features are improving in importance after the mod.","5ca52ef0":"# fast.ai v0.7 for my first competition\nThis is my first competition. Actually, this is my second try. So this notebook is my experience going through the competition with the notes and comment of the code for my own understanding. I do not know how to import FastAI version 0.7 into Kaggle so I just copy the code from [FastAI Github](https:\/\/github.com\/fastai\/fastai\/blob\/master\/old\/fastai\/structured.py). I also follow through this article written by [Utkarsh Chawla](https:\/\/towardsdatascience.com\/my-first-kaggle-competition-using-random-forests-to-predict-housing-prices-76efee28d42f) in Medium as reference. The note are taken by following the course : [Introduction to Machine Learning for Coders](http:\/\/course18.fast.ai\/ml) by FastAI from lesson 1 to lesson 4.\n\nThe next version maybe I will continue with lesson 4 and lesson 5 to get to know the data better."}}