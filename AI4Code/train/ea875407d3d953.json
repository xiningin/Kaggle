{"cell_type":{"2d3ae3c0":"code","79cdf243":"code","6267342f":"code","5f6e9add":"code","83b9f78f":"code","bb707f80":"code","4d5635b0":"code","93a2705d":"code","f37f0b33":"code","4c1198ab":"code","94905fb7":"code","feb261ca":"code","6773cb60":"code","a0d1a6ce":"code","5c2580d5":"code","9a08aede":"code","351e59b7":"code","63f0f0d2":"code","0535835e":"code","997d7ed0":"markdown","6f9cb30c":"markdown","e81973c5":"markdown","5fa952cd":"markdown","55eb4713":"markdown","ee8e8b30":"markdown","ec6b7a18":"markdown"},"source":{"2d3ae3c0":"import os\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nfrom subprocess import check_output\nprint(check_output([\"ls\", \"..\/input\"]).decode(\"utf8\"))","79cdf243":"from scipy.stats import rankdata\n\nLABELS = [\"sirna\"]","6267342f":"predict_list = []\npredict_list.append(pd.read_csv(\"..\/input\/cellstack\/submission (231).csv\")[LABELS].values)\npredict_list.append(pd.read_csv(\"..\/input\/cellstack\/submission(174).csv\")[LABELS].values)\npredict_list.append(pd.read_csv(\"..\/input\/cellstack\/submission(201).csv\")[LABELS].values)","5f6e9add":"import warnings\nwarnings.filterwarnings(\"ignore\")\nprint(\"Rank averaging on \", len(predict_list), \" files\")\npredictions = np.zeros_like(predict_list[0])\nfor predict in predict_list:\n    for i in range(1):\n        predictions[:, i] = np.add(predictions[:, i], rankdata(predict[:, i])\/predictions.shape[0])  \n\npredictions = predictions \/len(predict_list)\n\nsubmission = pd.read_csv('..\/input\/recursion-cellular-image-classification\/sample_submission.csv')\nsubmission[LABELS] = predictions\nsubmission.to_csv('AggStacker.csv', index=False)","83b9f78f":"sub_path = \"..\/input\/cellstack\"\nall_files = os.listdir(sub_path)\nall_files","bb707f80":"import warnings\nwarnings.filterwarnings(\"ignore\")\nouts = [pd.read_csv(os.path.join(sub_path, f), index_col=0) for f in all_files]\nconcat_sub = pd.concat(outs, axis=1)\ncols = list(map(lambda x: \"var\" + str(x), range(len(concat_sub.columns))))\nconcat_sub.columns = cols\nconcat_sub.reset_index(inplace=True)\nconcat_sub.head()\nncol = concat_sub.shape[1]","4d5635b0":"# check correlation\nconcat_sub.iloc[:,1:ncol].corr()","93a2705d":"corr = concat_sub.iloc[:,1:7].corr()\nmask = np.zeros_like(corr, dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\n# Set up the matplotlib figure\nf, ax = plt.subplots(figsize=(11, 9))\n\n# Generate a custom diverging colormap\ncmap = sns.diverging_palette(220, 10, as_cmap=True)\n\n# Draw the heatmap with the mask and correct aspect ratio\nsns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,\n            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})","f37f0b33":"# get the data fields ready for stacking\nconcat_sub['m_max'] = concat_sub.iloc[:, 1:ncol].max(axis=1)\nconcat_sub['m_min'] = concat_sub.iloc[:, 1:ncol].min(axis=1)\nconcat_sub['m_median'] = concat_sub.iloc[:, 1:ncol].median(axis=1)","4c1198ab":"concat_sub.describe()","94905fb7":"cutoff_lo = 0.8\ncutoff_hi = 0.2","feb261ca":"rank = np.tril(concat_sub.iloc[:,1:ncol].corr().values,-1)\nm_gmean = 0\nm = 14\nfor n in range(m):\n    mx = np.unravel_index(rank.argmin(), rank.shape)\n    m_gmean += (m-n)*(np.log(concat_sub.iloc[:, mx[0]+1]) + np.log(concat_sub.iloc[:, mx[1]+1]))\/2\n    rank[mx] = 1","6773cb60":"m_gmean = np.exp(m_gmean\/(n-1)**2)","a0d1a6ce":"concat_sub['sirna'] = m_gmean.astype(int)\nconcat_sub[['id_code','sirna']].to_csv('stack_mean.csv', \n                                        index=False, float_format='%.6f')","5c2580d5":"concat_sub['sirna']  = concat_sub['m_median'].astype(int)\nconcat_sub[['id_code','sirna']].to_csv('stack_median.csv', \n                                        index=False, float_format='%.6f')","9a08aede":"concat_sub['sirna']  = np.where(np.all(concat_sub.iloc[:,1:ncol] > cutoff_lo, axis=1), 1, \n                                    np.where(np.all(concat_sub.iloc[:,1:ncol] < cutoff_hi, axis=1),\n                                             0, concat_sub['m_median']))\nconcat_sub[['id_code','sirna']].to_csv('stack_pushout_median.csv', \n                                        index=False, float_format='%.6f')","351e59b7":"concat_sub['m_mean'] = m_gmean.astype(int)\nconcat_sub['sirna']  = np.where(np.all(concat_sub.iloc[:,1:ncol] > cutoff_lo, axis=1), \n                                    concat_sub['m_max'], \n                                    np.where(np.all(concat_sub.iloc[:,1:ncol] < cutoff_hi, axis=1),\n                                             concat_sub['m_min'], \n                                             concat_sub['m_mean'])).astype(int)\nconcat_sub[['id_code','sirna']].to_csv('stack_minmax_mean.csv', \n                                        index=False, float_format='%.6f')","63f0f0d2":"concat_sub['sirna'] = np.where(np.all(concat_sub.iloc[:,1:ncol] > cutoff_lo, axis=1), \n                                    concat_sub['m_max'], \n                                    np.where(np.all(concat_sub.iloc[:,1:ncol] < cutoff_hi, axis=1),\n                                             concat_sub['m_min'], \n                                             concat_sub['m_median'])).astype(int)\nconcat_sub[['id_code','sirna']].to_csv('stack_minmax_median.csv', \n                                        index=False, float_format='%.6f')","0535835e":"concat_sub['sirna'] = concat_sub['var0'].rank(method ='min') + concat_sub['var1'].rank(method ='min') + concat_sub['var2'].rank(method ='min') \nconcat_sub['sirna'] = (concat_sub['sirna']-concat_sub['sirna'].min())\/(concat_sub['sirna'].max() - concat_sub['sirna'].min()).astype(int)\nconcat_sub.describe()\nconcat_sub[['id_code','sirna']].to_csv('stack_rank.csv', index=False, float_format='%.8f')","997d7ed0":"## Averaging Ranks","6f9cb30c":"## Stat Stack","e81973c5":"# Mean Stacking","5fa952cd":"# Median Stacking","55eb4713":"# MinMax + Mean Stacking\n>* MinMax seems more gentle and it outperforms the previous one","ee8e8b30":"# MinMax + Median Stacking","ec6b7a18":"# Pushout + Median Stacking\n>* Pushout strategy is bit aggresive"}}