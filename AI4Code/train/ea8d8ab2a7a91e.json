{"cell_type":{"3c336150":"code","025018b8":"code","f1bd9362":"code","1f917589":"code","7d0ddb7c":"code","944a1485":"code","fb9f2e36":"code","776b7803":"code","b467f5fe":"code","e92ac94a":"markdown"},"source":{"3c336150":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom PIL import Image\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\ninputPaths = []\nmaskPaths = []\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input\/fluorescent-neuronal-cells\/all_images'):\n    for filename in filenames:\n        if filename.endswith(\"png\"):\n            fullPath = os.path.join(dirname, filename)\n            inputPaths.append(fullPath)\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input\/fluorescent-neuronal-cells\/all_masks'):\n    for filename in filenames:\n        if filename.endswith(\"png\"):\n            fullPath = os.path.join(dirname, filename)\n            maskPaths.append(fullPath)","025018b8":"def loadImages(imgPathNames, maskPathNames):\n    maskFileDict = {os.path.basename(fullPath): fullPath for fullPath in maskPathNames}\n    imgMaskFilePairsDict = {os.path.basename(fullPath) : (fullPath, maskFileDict[os.path.basename(fullPath)]) for fullPath in imgPathNames}\n    #dict<filename:string,(original:image, mask:image)>\n    imgMaskPairs = {}\n    for filename, (imgPath, maskPath) in imgMaskFilePairsDict.items():\n        img = np.array(Image.open(imgPath))\n        mask = np.array(Image.open(maskPath))\n        imgMaskPairs[filename] = (img, mask)\n    return imgMaskPairs\n\nimgMaskPairs = loadImages(inputPaths, maskPaths)","f1bd9362":"import matplotlib.pyplot as plt\n\nimgList = [t[0] for _, t in imgMaskPairs.items()]\nmaskList = [t[1] for _, t in imgMaskPairs.items()]\n\nplt.figure(figsize=(10,16))\nplt.imshow(maskList[0])","1f917589":"from collections import namedtuple\nfrom collections import defaultdict\n\nCellLocation = namedtuple(\"CellLocation\", [\"nPixels\", \"x\", \"y\", \"width\", \"height\"])\n\ndef bfs(r, c, nRows, nCols, traversable, groupAssignments, groupIndex):\n    frontier = [(r,c)]\n    groupAssignments[r][c] = groupIndex\n    while len(frontier) > 0:\n        curRow, curCol = frontier.pop()\n        nextNodes = [\n            (curRow + 1, curCol),\n            (curRow - 1, curCol),\n            (curRow, curCol + 1),\n            (curRow, curCol - 1)\n        ]\n        for nextRow, nextCol in nextNodes:\n            withinRange = (\n                nextRow >= 0 and nextRow < nRows and\n                nextCol >= 0 and nextCol < nCols)\n            unvisited = (\n                withinRange and \n                traversable[nextRow][nextCol] and\n                groupAssignments[nextRow][nextCol] == None)\n            if withinRange and unvisited:\n                frontier.append((nextRow, nextCol))\n                groupAssignments[nextRow][nextCol] = groupIndex\n    #end of loop, all linked nodes have been marked with \"groupIndex\"\n    return\n\n#(imgArr:TNumeric[][]) => CellLocation[]\ndef markGroups(maskArr):\n    threshold = int(255 * 0.5)\n    #Native python list to speed up per-element indexing\n    isCell = np.greater(maskArr, threshold).tolist() \n    nRows, nCols = maskArr.shape\n    group = [[None]*nCols for _ in range(nRows)]\n    groupIdx = 0\n    #flood fill & mark cell groups\n    for r in range(nRows):\n        for c in range(nCols):\n            unvisitedGroup = isCell[r][c] and (group[r][c] == None)\n            if unvisitedGroup:\n                bfs(r,c, nRows, nCols, isCell, group, groupIdx) #flood fill one cluster\n                groupIdx += 1 #Ensure group clusters are unique\n    \n    #Get size & bounding boxes\n    sizeDict = defaultdict(int)\n    \n    rightDict = defaultdict(int)\n    leftDict = defaultdict(lambda:nCols)\n\n    botDict = defaultdict(int)\n    topDict = defaultdict(lambda:nRows)\n    \n    for r in range(nRows):\n        for c in range(nCols):\n            if group[r][c] != None:\n                groupNo = group[r][c]\n                sizeDict[groupNo] += 1\n                \n                rightDict[groupNo] = max(rightDict[groupNo], c)\n                leftDict[groupNo] = min(leftDict[groupNo], c)\n                \n                botDict[groupNo] = max(botDict[groupNo], r)\n                topDict[groupNo] = min(topDict[groupNo], r)\n                \n    #pack into tuples\n    cellLocList = []\n    for groupNo, size in sizeDict.items():\n        x = leftDict[groupNo]\n        y = topDict[groupNo]\n        width = 1 + (rightDict[groupNo] - x)\n        height = 1 + (botDict[groupNo] - y)\n        cellLocList.append(CellLocation(size, x, y, width, height))\n        \n    return cellLocList","7d0ddb7c":"cellLocationList = [markGroups(mask) for mask in maskList]","944a1485":"#Sanity check\nimport matplotlib.patches as patches\n\nimageIdx = 0;\n\nplt.figure(figsize=(10,16))\n\nplt.title(\"Cell Boundaries (Based on corresponding mask)\")\nplt.imshow(imgList[imageIdx])\n\nax = plt.gca();\nfor cellLoc in cellLocationList[imageIdx]:\n    rect = patches.Rectangle((cellLoc.x, cellLoc.y), cellLoc.width, cellLoc.height, linewidth=1, edgecolor='r', facecolor='none')\n    ax.add_patch(rect)\n\nplt.show()","fb9f2e36":"flattenedCellLocations = []\nfor li in cellLocationList:\n    flattenedCellLocations.extend(li)","776b7803":"nTotalCells = len(flattenedCellLocations)\nprint(nTotalCells)\nsizes = [cellLoc.nPixels for cellLoc in flattenedCellLocations]\nwidths = [cellLoc.width for cellLoc in flattenedCellLocations]\nheights = [cellLoc.height for cellLoc in flattenedCellLocations]","b467f5fe":"fig, ax = plt.subplots(1, 3, figsize=(16,5))\n\nnBins = 20\nax[0].hist(sizes,bins=nBins)\nax[0].set_title('Cell Area (pixels)')\n\nax[1].hist(widths,bins=nBins)\nax[1].set_title('Cell Widths(pixels)')\n\nax[2].hist(heights,bins=nBins)\nax[2].set_title('Cell Heights(pixels)')\n\nplt.tight_layout()\nplt.show()\n\npercentile = 95\n\nsizePercentile = np.percentile(sizes, percentile)\nwidthPercentile = np.percentile(widths, percentile)\nheightPercentile = np.percentile(heights, percentile)\n\nprint(\"{0}th Percentile Values for:\".format(percentile))\nprint(\" Area:{:0.2f} pixels\".format(sizePercentile))\nprint(\" Width:{:0.2f} pixels\".format(widthPercentile))\nprint(\" Height:{:0.2f} pixels\".format(heightPercentile))","e92ac94a":"# Starter Notebook\n\nThis starter notebook provides the following:\n1. Loaded image data\n   * Corresponding microscope images and mask images loaded as 2D numpy arrays within the following Python Lists\n       * imgList\n       * maskList\n2. Cell Bounding Boxes\n   * List of cell bounding boxes for each image stored within the following List:\n       * cellLocationList\n   * Each cell bounding box contains the following members:\n       * \"nPixels\" - Cell size within the mask (in pixels)\n       * \"x\" - x location of bounding box within the image\n       * \"y\" - y location of bounding box within the image\n       * \"width\" - width of bounding box\n       * \"height\" - height of bounding box\n       \n**Additional Details:**\nBounding boxes are found by performing a flood-fill on the mask images, using a pixel intensity threshold of above 122 to denote that a pixel belongs to a cell. The bounding box represents the region that encapsulates each group of connected pixels that are marked as cells. Note that two overlapping cells may be interpreted as a single cell using this technique.\n\nThe 95th percentile of the cell sizes, widths & heights are provided below (3872, 103 & 83 pixels respectively).\n\nIn total, the entire dataset contains 2270 cells within the microscope images.\n\n**Note**: both the png decoding process and flood-fill process take a fair amount of time to execute (~4 mins from start to end). \n\nFeel free to use this notebook as a basis for your own projects. Have fun coding!"}}