{"cell_type":{"a4b63be5":"code","55fc06bd":"code","6010ee0f":"code","ea0a0d56":"code","fd374986":"code","7862d583":"code","3c10789c":"code","8bfd92ed":"code","358558c7":"code","b53e942a":"code","dca05f67":"code","1c346f43":"code","237288ce":"code","0b02a0e4":"code","cc6f4814":"code","6f5928af":"code","5798dcfa":"code","fa6a5998":"code","ef248897":"markdown","d239b705":"markdown","f0717f1d":"markdown"},"source":{"a4b63be5":"!pip uninstall --y kaggle\n!pip install --upgrade pip\n!pip install kaggle==1.5.6","55fc06bd":"!mkdir -p ~\/.kaggle\n!cp ..\/input\/kagglejson\/kaggle.json ~\/.kaggle\n!ls -lha ..\/input\/kagglejson\/kaggle.json\n!chmod 600 ~\/.kaggle\/kaggle.json","6010ee0f":"!kaggle competitions download -c 2020soil","ea0a0d56":"!unzip 2020soil.zip","fd374986":"import pandas as pd \nimport numpy as np\nimport torch \nimport torchvision.datasets as datasets\nimport torchvision.transforms as transforms\nimport torch.optim as optim\nimport torch.nn.functional as F\nimport torch.nn as nn","7862d583":"device = 'cuda' if torch.cuda.is_available() else 'cpu'\n\ntorch.manual_seed(777)\nif device == 'cuda':\n    torch.cuda.manual_seed_all(777)","3c10789c":"train = pd.read_csv('..\/input\/2020soil\/2020AI_soil_train.csv')\nprint(train.head(10))\nprint(train.info())\n","8bfd92ed":"learning_rate = 0.001\ntraining_epoch = 1000\nbatch_size = 50 ","358558c7":"x_train = train.iloc[:,1:-1]\ny_train = train.iloc[:,[-1]]\n\nx_train = np.array(x_train)\ny_train = np.array(y_train)\n\nx_train = torch.FloatTensor(x_train)\ny_train = torch.FloatTensor(y_train)\n\nprint(x_train.shape)\nprint(y_train.shape)","b53e942a":"train_dataset = torch.utils.data.TensorDataset(x_train,y_train)\n\ndata_loader = torch.utils.data.DataLoader(dataset = train_dataset,\n                                          batch_size = batch_size,\n                                          shuffle = True,\n                                          drop_last=True)\n\n","dca05f67":"linear1 = nn.Linear(7,4,bias=True)\nlinear2 = nn.Linear(4,4,bias=True)\nlinear3 = nn.Linear(4,4,bias=True)\nlinear4 = nn.Linear(4,4,bias=True)\nlinear5 = nn.Linear(4,1,bias=True)\n\nnn.init.xavier_uniform_(linear1.weight)\nnn.init.kaiming_normal_(linear2.weight)\nnn.init.xavier_uniform_(linear3.weight)\nnn.init.kaiming_normal_(linear4.weight)\nnn.init.xavier_uniform_(linear5.weight)\nrelu = nn.ReLU()","1c346f43":"model = nn.Sequential(\n    linear1,relu,\n    linear2,relu,\n    linear3,relu,\n    linear4,relu,\n    linear5\n).to(device)","237288ce":"loss = nn.MSELoss().to(device)\noptimizer = optim.Adam(model.parameters(),lr=learning_rate)","0b02a0e4":"total_batch = len(data_loader)\n\nfor epoch in range(training_epoch):\n    avg_cost = 0\n    for X,Y in data_loader:\n        X = X.to(device)\n        Y = Y.to(device)\n\n        optimizer.zero_grad()\n        hypothesis = model(X)\n        cost = loss(hypothesis,Y)\n        cost.backward()\n        optimizer.step()\n\n        avg_cost += cost\/total_batch\n\n    print('epoch {:.4f} , cost = {:.6f}'.format(epoch,avg_cost))\nprint('learning finished!')","cc6f4814":"test = pd.read_csv('..\/input\/2020soil\/2020_soil_test.csv')\nprint(test.info())\ntest = test.iloc[:,1:]\ntest = np.array(test)\ntest = torch.FloatTensor(test).to(device)\n\nwith torch.no_grad():\n    predict = model(test)\npredict","6f5928af":"correct_prediction = predict.cpu().numpy().reshape(-1,1)\nresult = pd.read_csv('..\/input\/2020soil\/soil_submission.csv')","5798dcfa":"for i in range(len(correct_prediction)):\n    result['Expected'][i] = correct_prediction[i]\n    ","fa6a5998":"result.to_csv('submit.csv',index=False)","ef248897":"\ud1a0\uc591 \uc624\uc5fc\uc758 \uc218\uce58\ub97c \uc608\uce21","d239b705":"layer 5\uac1c , kaiming uniform \ucd08\uae30\ud654","f0717f1d":"activation function - relu"}}