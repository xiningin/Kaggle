{"cell_type":{"df2ee880":"code","fda5693c":"code","2a79af67":"code","3fb90a59":"code","e2499e2d":"code","c6b2dcc9":"code","aadf08de":"code","21df485b":"code","582511cc":"code","2545668c":"code","adc734dc":"code","c6fe2db6":"code","b49c0096":"code","89125d94":"code","2c63bad7":"code","5fcce10c":"code","1999cc65":"code","86a1d0ac":"code","58c19832":"code","6bfe5b22":"code","c7a7988b":"code","cd4f20bf":"code","3dfc4e05":"code","83619c1f":"code","79421b9c":"code","24fd8b2a":"code","9a950519":"code","51ae6b9e":"code","0a8c35fd":"code","633c4b38":"code","74c2f306":"markdown","50461d0f":"markdown","24d3acbd":"markdown","97da4f80":"markdown","db13fb44":"markdown","0a73704d":"markdown","1a5c8b07":"markdown","1b63f67e":"markdown","40205c92":"markdown","d553c3c9":"markdown","77be575e":"markdown","c6142bb5":"markdown","9972d2c3":"markdown","6bbe5618":"markdown","1bd87346":"markdown","8f06c33f":"markdown","a6186a4d":"markdown","48df5e43":"markdown","6afd6979":"markdown","d66c89b3":"markdown","b6c9b646":"markdown","161cfdb9":"markdown","b2e9322a":"markdown","dc848ba8":"markdown"},"source":{"df2ee880":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom numpy.linalg import norm\nfrom collections import Counter\nfrom time import time\nfrom matplotlib import collections  as mc\n\nsns.set_style('whitegrid')","fda5693c":"df = pd.read_csv(\"..\/input\/cities.csv\")","2a79af67":"df.head()","3fb90a59":"plt.figure(figsize=(15, 10))\nplt.scatter(df.X, df.Y, s=1)\nplt.scatter(df.iloc[0: 1, 1], df.iloc[0: 1, 2], s=10, c=\"red\")\nplt.grid(False)\nplt.show()","e2499e2d":"nb_cities = max(df.CityId)\nprint(\"Number of cities to visit : \", nb_cities)","c6b2dcc9":"df.tail()","aadf08de":"def sieve_eratosthenes(n):\n    primes = [False, False] + [True for i in range(n-1)]\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * 2, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes","21df485b":"primes = np.array(sieve_eratosthenes(nb_cities)).astype(int)\ndf['Prime'] = primes","582511cc":"penalization = 0.1 * (1 - primes) + 1","2545668c":"df.head()","adc734dc":"plt.figure(figsize=(15, 10))\nsns.countplot(df.Prime)\nplt.title(\"Prime repartition : \" + str(Counter(df.Prime)))\nplt.show()","c6fe2db6":"plt.figure(figsize=(15, 10))\nplt.scatter(df[df['Prime'] == 0].X, df[df['Prime'] == 0].Y, s=1, alpha=0.4)\nplt.scatter(df[df['Prime'] == 1].X, df[df['Prime'] == 1].Y, s=1, alpha=0.6, c='blue')\nplt.scatter(df.iloc[0: 1, 1], df.iloc[0: 1, 2], s=10, c=\"red\")\nplt.grid(False)\nplt.title('Visualisation of cities')\nplt.show()","b49c0096":"def dist_matrix(coords, i, penalize=False):\n    begin = np.array([df.X[i], df.Y[i]])[:, np.newaxis]\n    mat =  coords - begin\n    if penalize:\n        return np.linalg.norm(mat, ord=2, axis=0) * penalization\n    else:\n        return np.linalg.norm(mat, ord=2, axis=0)","89125d94":"def get_next_city(dist, avail):\n    return avail[np.argmin(dist[avail])]","2c63bad7":"coordinates = np.array([df.X, df.Y])","5fcce10c":"current_city = 0 ","1999cc65":"left_cities = np.array(df.CityId)[1:]","86a1d0ac":"path = [0]","58c19832":"stepNumber = 1","6bfe5b22":"t0 = time()\n\nwhile left_cities.size > 0:\n    if stepNumber % 10000 == 0: #We print the progress of the algorithm\n        print(f\"Time elapsed : {time() - t0} - Number of cities left : {left_cities.size}\")\n    # If we are at the ninth iteration (modulo 10), we may want to go to a prime city. Note that there is an approximation here: we penalize the path to the 10th city insted of 11th\n    favorize_prime = (stepNumber % 10 == 9)\n    # Compute the distance matrix\n    distances = dist_matrix(coordinates, current_city, penalize=favorize_prime)\n    # Get the closest city and go to it\n    current_city = get_next_city(distances, left_cities)\n    # Update the list of not visited cities\n    left_cities = np.setdiff1d(left_cities, np.array([current_city]))\n    # Append the city to the path\n    path.append(current_city)\n    # Add one step\n    stepNumber += 1","c7a7988b":"print(f\"Loop lasted {(time() - t0) \/\/ 60} minutes \")","cd4f20bf":"path.append(0)","3dfc4e05":"print(len(path) == len(df) + 1)","83619c1f":"def plot_path(path, coordinates):\n    # Plot tour\n    lines = [[coordinates[: ,path[i-1]], coordinates[:, path[i]]] for i in range(1, len(path)-1)]\n    lc = mc.LineCollection(lines, linewidths=2)\n    fig, ax = plt.subplots(figsize=(20,20))\n    ax.set_aspect('equal')\n    plt.grid(False)\n    ax.add_collection(lc)\n    ax.autoscale()","79421b9c":"plot_path(path, coordinates)","24fd8b2a":"def get_score(path, coords, primes):\n    score = 0\n    for i in range(1, len(path)):\n        begin = path[i-1]\n        end = path[i]\n        distance = np.linalg.norm(coords[:, end] - coords[:, begin], ord=2)\n        if i%10 == 0:\n            if not primes[begin]:\n                distance *= 1.1\n        score += distance\n    return score","9a950519":"score = get_score(path, coordinates, primes)","51ae6b9e":"print(\"Solution scored \", score)","0a8c35fd":"print(score - get_score(path[:-1], coordinates, primes))","633c4b38":"submission = pd.DataFrame({\"Path\": path})\nsubmission.to_csv(\"submission.csv\", index=None)","74c2f306":"### Plotting path","50461d0f":"Adding the north pole to our path","24d3acbd":"Again, this is not very good. Let us check the influence of going back to the north pole : ","97da4f80":"This is kinda bad, but this is a greedy algorithm so there was not much to expect.","db13fb44":"Our path starts with the north pole","0a73704d":"We start at the north pole","1a5c8b07":"There are prime cities approximately all around the map. Which is a good thing as well.","1b63f67e":"Almost a tenth of the cities is prime, which is a good because we want to visit prime a prime city every 10 cities.","40205c92":"We have all cities to visit, except the north pole","d553c3c9":"Checking that our path is of correct length","77be575e":"This one gets the closest city available","c6142bb5":"This first function gets the distance of all the cities to the current city.\n\nIf we decide to penalize, we multiply the distance of non-prime cities by $1.1$","9972d2c3":"## Getting Prime Cities","6bbe5618":"#### End","1bd87346":"# Greedy Reindeer - A Starter code to the Traveling Santa Problem\n### Using a greedy algorithm to solve the problem-forked!!!\n\nPrime cities are taken into account","8f06c33f":"We store city coordinates in an array, for efficiency","a6186a4d":"Ouch. Anyways, let us submit our results.","48df5e43":"## Now to the Algorithm","6afd6979":"### Loop","d66c89b3":"### Key functions","b6c9b646":"We start at 1 the first step","161cfdb9":"## Results","b2e9322a":"### Initialization","dc848ba8":"## Loading Data"}}