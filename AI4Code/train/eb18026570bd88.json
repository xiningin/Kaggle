{"cell_type":{"279e99ab":"code","efa2abc4":"code","120a07df":"code","64f12c20":"code","45b5176b":"code","a661490e":"code","dbce04dd":"code","f3668436":"code","f99fdbf1":"code","1f38d539":"code","98227ccf":"code","9d79590a":"code","5ae921c8":"code","9a6a4c5a":"code","dc59c12c":"code","0fab8495":"code","554c3c91":"code","5ab4a872":"code","225d4f79":"code","1442af90":"markdown","bc3faa42":"markdown","a3d61469":"markdown","1babdcbe":"markdown","7f8313a3":"markdown","3b94cc08":"markdown","eadf7a4e":"markdown","ef847d11":"markdown","1c2ce493":"markdown","e63d38b9":"markdown","56410af8":"markdown","333a1fe5":"markdown","a0709017":"markdown","c567bbc2":"markdown"},"source":{"279e99ab":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import GroupKFold\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nfrom sklearn.metrics import accuracy_score, classification_report\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","efa2abc4":"#read the csv files\nfile_path = '..\/input\/epitope-prediction'\nbcell = pd.read_csv(f'{file_path}\/input_bcell.csv')\ncovid = pd.read_csv(f'{file_path}\/input_covid.csv')\nsars = pd.read_csv(f'{file_path}\/input_sars.csv')\n#concatenate the bcell and sars dataframes to train the LogisticRegression model\nbcell_sars = pd.concat([bcell,sars], axis=0, ignore_index = True)","120a07df":"#create 'length' column in the dfs as an added feature \n#Idea  and code from notebook by Future Corporation\nfor df in [bcell, sars, covid, bcell_sars]:\n    df['length'] = df['end_position'] - df['start_position']+1","64f12c20":"bcell_sars.head(3)","45b5176b":"#Plot histograms for the peptide features of B-cell epitopes in bcell \n# dataframe\n# Code modified from Future Corporation notebook\nfig, axes = plt.subplots(2, 2,figsize=(16,8))\naxes = [x for a in axes for x in a]\nfor ind, prop in enumerate ([\"chou_fasman\",\"emini\",\"kolaskar_tongaonkar\",\"parker\"]):\n    sns.histplot(x=bcell[prop], hue=bcell['target'],stat=\"density\", common_norm=False, kde=True, ax=axes[ind])\n    ","a661490e":"#Plot histograms for the protein features of B-cell epitopes in bcell \n# dataframe\n# Code modified from Future Corporation notebook\nfig, axes = plt.subplots(2, 2,figsize=(16,8))\naxes = [x for a in axes for x in a]\nfor ind, prop in enumerate ([\"isoelectric_point\", \"aromaticity\", \"hydrophobicity\", \"stability\"]):\n    sns.histplot(x=bcell[prop], hue=bcell['target'],stat=\"density\", common_norm=False, kde=True, ax=axes[ind])","dbce04dd":"#create training, testing and prediction datasets\nX_bcell=bcell.drop(['parent_protein_id', 'protein_seq', 'start_position', 'end_position', 'peptide_seq', 'target'], axis=1)\ny_bcell=bcell.target\nX_sars=sars.drop(['parent_protein_id', 'protein_seq', 'start_position', 'end_position', 'peptide_seq', 'target'], axis=1)","f3668436":"gkf = GroupKFold(n_splits=5)#create GroupKFold object with 5 splits of the data","f99fdbf1":"scores_logreg = []\nmodel_logreg=LogisticRegression(max_iter=500,C=1)\npredict=np.zeros(len(sars))\n\ni=0\nfor train_index, test_index in gkf.split(X_bcell, y_bcell, bcell['parent_protein_id']): #loop through the 5 GroupKFolds where the groups are the 'parent_protein_id'\n    X_train = X_bcell.loc[train_index]\n    y_train = y_bcell.loc[train_index]\n    X_test = X_bcell.loc[test_index]\n    y_test = y_bcell.loc[test_index]\n    model_logreg.fit(X_train, y_train)\n    scores_logreg.append(model_logreg.score(X_test, y_test))\n    predict+=model_logreg.predict(X_sars.values)\n    i+=1\n    if i==gkf.n_splits:\n        predict=predict\/gkf.n_splits\n    \n    \nprint('LogisticRegression mean score: ', np.mean(scores_logreg))\nprint(predict[:220])\n#display a portion of the output array to show the avg. clssification values","1f38d539":"print(\"Accuracy:\", accuracy_score(sars[\"target\"].values, np.int32(predict >= 0.5)))\nprint(classification_report(sars[\"target\"].values, np.int32(predict >= 0.5)))","98227ccf":"# Define the training and prediction data\nX_bcell_sars = bcell_sars.drop(['parent_protein_id', 'protein_seq', 'start_position', 'end_position', 'peptide_seq', 'target'], axis=1)\ny_bcell_sars = bcell_sars['target']\nX_covid=covid.drop(['parent_protein_id', 'protein_seq', 'start_position', 'end_position', 'peptide_seq'], axis=1)","9d79590a":"#(1)Train the LogisticRegression model with combined bcell_sars data. \n#(2)Predict antibody induction using covid data\nscores_logreg2=[]\nmodel_logreg2=LogisticRegression(max_iter=500,C=1)\ncovid_predict=np.zeros(len(covid))\n\ni=0\nfor train_index, test_index in gkf.split(X_bcell_sars, y_bcell_sars, bcell_sars['parent_protein_id']): \n    X_train = X_bcell_sars.loc[train_index]\n    y_train = y_bcell_sars.loc[train_index]\n    X_test = X_bcell_sars.loc[test_index]\n    y_test = y_bcell_sars.loc[test_index]\n    model_logreg2.fit(X_train, y_train)\n    scores_logreg2.append(model_logreg2.score(X_test, y_test))\n    covid_predict+=model_logreg2.predict(X_covid.values)\n    i+=1\n    if i==gkf.n_splits:\n        covid_predict=covid_predict\/gkf.n_splits\n    \nprint('LogisticRegression mean score: ', np.mean(scores_logreg2))   \nprint(covid_predict)","5ae921c8":"covid_final=covid.copy()#create deep copy of covid df\n#assign predicted average classification values to a new column\ncovid_final['predict']=covid_predict \ncovid_final['predict'].value_counts()","9a6a4c5a":"# View amino acid sequences of the 20 peptides predicted to be 'strong candidates'\ncovid_final[covid_final['predict']==1]['peptide_seq']","dc59c12c":"pfizer = \"MFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDKVFRSSVLHSTQDLFLPFFSNVTWFHAIHVSGTNGTKRFDNPVLPFNDGVYFASTEKSNIIRGWIFGTTLDSKTQSLLIVNNATNVVIKVCEFQFCNDPFLGVYYHKNNKSWMESEFRVYSSANNCTFEYVSQPFLMDLEGKQGNFKNLREFVFKNIDGYFKIYSKHTPINLVRDLPQGFSALEPLVDLPIGINITRFQTLLALHRSYLTPGDSSSGWTAGAAAYYVGYLQPRTFLLKYNENGTITDAVDCALDPLSETKCTLKSFTVEKGIYQTSNFRVQPTESIVRFPNITNLCPFGEVFNATRFASVYAWNRKRISNCVADYSVLYNSASFSTFKCYGVSPTKLNDLCFTNVYADSFVIRGDEVRQIAPGQTGKIADYNYKLPDDFTGCVIAWNSNNLDSKVGGNYNYLYRLFRKSNLKPFERDISTEIYQAGSTPCNGVEGFNCYFPLQSYGFQPTNGVGYQPYRVVVLSFELLHAPATVCGPKKSTNLVKNKCVNFNFNGLTGTGVLTESNKKFLPFQQFGRDIADTTDAVRDPQTLEILDITPCSFGGVSVITPGTNTSNQVAVLYQDVNCTEVPVAIHADQLTPTWRVYSTGSNVFQTRAGCLIGAEHVNNSYECDIPIGAGICASYQTQTNSPRRARSVASQSIIAYTMSLGAENSVAYSNNSIAIPTNFTISVTTEILPVSMTKTSVDCTMYICGDSTECSNLLLQYGSFCTQLNRALTGIAVEQDKNTQEVFAQVKQIYKTPPIKDFGGFNFSQILPDPSKPSKRSFIEDLLFNKVTLADAGFIKQYGDCLGDIAARDLICAQKFNGLTVLPPLLTDEMIAQYTSALLAGTITSGWTFGAGAALQIPFAMQMAYRFNGIGVTQNVLYENQKLIANQFNSAIGKIQDSLSSTASALGKLQDVVNQNAQALNTLVKQLSSNFGAISSVLNDILSRLDPPEAEVQIDRLITGRLQSLQTYVTQQLIRAAEIRASANLAATKMSECVLGQSKRVDFCGKGYHLMSFPQSAPHGVVFLHVTYVPAQEKNFTTAPAICHDGKAHFPREGVFVSNGTHWFVTQRNFYEPQIITTDNTFVSGNCDVVIGIVNNTVYDPLQPELDSFKEELDKYFKNHTSPDVDLGDISGINASVVNIQKEIDRLNEVAKNLNESLIDLQELGKYEQYIKWPWYIWLGFIAGLIAIVMVTIMLCCMTSCCSCLKGCCSCGSCCKFDEDDSEPVLKGVKLHYT\"\nmoderna = \"MFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDKVFRSSVLHSTQDLFLPFFSNVTWFHAIHVSGTNGTKRFDNPVLPFNDGVYFASTEKSNIIRGWIFGTTLDSKTQSLLIVNNATNVVIKVCEFQFCNDPFLGVYYHKNNKSWMESEFRVYSSANNCTFEYVSQPFLMDLEGKQGNFKNLREFVFKNIDGYFKIYSKHTPINLVRDLPQGFSALEPLVDLPIGINITRFQTLLALHRSYLTPGDSSSGWTAGAAAYYVGYLQPRTFLLKYNENGTITDAVDCALDPLSETKCTLKSFTVEKGIYQTSNFRVQPTESIVRFPNITNLCPFGEVFNATRFASVYAWNRKRISNCVADYSVLYNSASFSTFKCYGVSPTKLNDLCFTNVYADSFVIRGDEVRQIAPGQTGKIADYNYKLPDDFTGCVIAWNSNNLDSKVGGNYNYLYRLFRKSNLKPFERDISTEIYQAGSTPCNGVEGFNCYFPLQSYGFQPTNGVGYQPYRVVVLSFELLHAPATVCGPKKSTNLVKNKCVNFNFNGLTGTGVLTESNKKFLPFQQFGRDIADTTDAVRDPQTLEILDITPCSFGGVSVITPGTNTSNQVAVLYQDVNCTEVPVAIHADQLTPTWRVYSTGSNVFQTRAGCLIGAEHVNNSYECDIPIGAGICASYQTQTNSPRRARSVASQSIIAYTMSLGAENSVAYSNNSIAIPTNFTISVTTEILPVSMTKTSVDCTMYICGDSTECSNLLLQYGSFCTQLNRALTGIAVEQDKNTQEVFAQVKQIYKTPPIKDFGGFNFSQILPDPSKPSKRSFIEDLLFNKVTLADAGFIKQYGDCLGDIAARDLICAQKFNGLTVLPPLLTDEMIAQYTSALLAGTITSGWTFGAGAALQIPFAMQMAYRFNGIGVTQNVLYENQKLIANQFNSAIGKIQDSLSSTASALGKLQDVVNQNAQALNTLVKQLSSNFGAISSVLNDILSRLDPPEAEVQIDRLITGRLQSLQTYVTQQLIRAAEIRASANLAATKMSECVLGQSKRVDFCGKGYHLMSFPQSAPHGVVFLHVTYVPAQEKNFTTAPAICHDGKAHFPREGVFVSNGTHWFVTQRNFYEPQIITTDNTFVSGNCDVVIGIVNNTVYDPLQPELDSFKEELDKYFKNHTSPDVDLGDISGINASVVNIQKEIDRLNEVAKNLNESLIDLQELGKYEQYIKWPWYIWLGFIAGLIAIVMVTIMLCCMTSCCSCLKGCCSCGSCCKFDEDDSEPVLKGVKLHYT\"","0fab8495":"len(pfizer) #1273 amino acids in the sequence ","554c3c91":"pfizer==moderna","5ab4a872":"i=0\nfor seq in covid_final[covid_final['predict']==1]['peptide_seq']:\n    if seq in pfizer: continue\n    else: i+=1\nprint(i, 'peptides are not part of SARS-Cov2 sequence')","225d4f79":"disp_seq=pfizer[1129:1180]\nprint('1130', '<'*10, 'amino acid pos.', '>'*15, '1181')\nprint('|', '.'*47, '|')\nprint(disp_seq,' <- SARS-COV2')\nfor seq in covid_final[covid_final['predict']==1]['peptide_seq']:\n    if pfizer.find(seq)>1129:\n        print('.'*(pfizer.find(seq)-1129)+seq+'.'*(1180-pfizer.find(seq)-len(seq)))","1442af90":"For the four peptide features, there are no discernible differences between peptides that can or cannot induce neutralizing antibodies (i.e. target 1 vs. 0).","bc3faa42":"How well did the B-cell data help predict the antibody responses of sars peptides?\nConvert all classification values of the array that are >= 0.5 to an integer (i.e.1)\n*Code modified from Future Corporation notebook*","a3d61469":"(1) These amino acid sequences are identical. \n(2)This is the case even though the mRNA nucleotide sequences from Pfizer and Moderna vaccines are NOT identical (not shown)","1babdcbe":"Compare these peptides to the amino acid sequence coded by the Pfizer-BioNTech or Moderna vaccines. \nThe following are the translated amino acid sequences from pfizer and Moderna mRNA vaccines. \n(1) mRNA sequences copied from https:\/\/github.com\/NAalytics\/Assemblies-of-putative-SARS-CoV2-spike-encoding-mRNA-sequences-for-vaccines-BNT-162b2-and-mRNA-1273\n(2) mRNA sequences translated to amino acid sequences at https:\/\/web.expasy.org\/translate\/\n(3) The amino acid sequence comprises of part of the SARS-Cov2 spike protein which is presumed interact with the angiotensin-converting enzyme 2 (ACE2) receptor on the cell surface which subsequently enables virus entry into the cell.","7f8313a3":"There are a range of classification values, of which values >=0.5 can be reclassified as '1'. But it is interesting to note that there are 20 peptides, with a classification value of 1 . I will assume them to be 'strong candidates' for inducing covid antibodies since with every training\/prediction run, each of these peptides were classified as '1'. ","3b94cc08":"(1) Split the dataframe containing B-cell data using GroupKFold since there are groups of peptides derived from several parent proteins. GroupKFold prevents mixing of groups between training and testing data sets.\n(2) Train and test the LogisticRegression model\n(3) For each training run, predict antibody induction using the whole sars dataset.\n(4) Calculate the average classification over the number of repetitions (i.e. number of folds trained on). Here an assumption was made where an average calssification value of 1 indicates a 'strong candidate'\nfor induction of neutralizing antibodies (i.e. prediction of 1 for each training\/predicting run)\n*Code modified from Future Corporation notebook*","eadf7a4e":"There is also no clear differentiation between the protein features of those peptides that can or cannot induce neutralizing antibodies (i.e. target 1 vs. 0).","ef847d11":"(1) Output from the following code confirms that all of the 'strong' peptide candidates are part of the covid spike protein sequence. \n(2) This is not unexpected since the parent protein in the covid dataset is the spike protein","1c2ce493":"# Concluding Remarks\n1. Using a series of peptide and protein features in available datasets, a Logistic Regression model was used to predict the ability of a peptide to induce an antibody reaction.\n2. Misclassification of true positives is a clear problem for this model as evidenced by poor recall and F1-Score metrics. Lack of clear differences between features of those peptide that induce neutralizing antobodies versus those that do not may have affected the model's training and subsequently its predictive capability.\n3. It is also noteworthy to mention that according to the description of the original data, \"Positive-High,\" \"Positive-Intermediate,\" \"Positive-Low,\" antibody activity labels were all grouped into a single label as \"Positive\" (target=1) that may contribute to the model's poor performance. Such a mixture of peptide data may lead to 'confusion' during prediction.  \n4. Regardless of its predictive weakness, the model was able to predict 20 SARS-Cov2 scandidates that, in my opinion, may exert strong antibody responses. Seventeen of these candidates are from a small region of the spike protein, perhaps indicating the strong antigenic properties of this region in a primary or a secondary protein structure.\n","e63d38b9":"# TASK 2: Train with B-cell and sars data and predict antibody induction with covid-derived peptides","56410af8":"# Exploratory Data Analysis","333a1fe5":"(1) Seventeen  of the twenty 'strong candidates' for anti-covid antibody induction appear to be \nfrom a small region of the spike protein. \n(2) Following code aligns the latter region of the spike protein sequence with these 'strong candidate' peptides.\n(3) Three other strong candidates align outside of the displayed amino acid sequence window","a0709017":"# TASK 1: Train with B-cell data and predict antibody induction with sars-derived peptides","c567bbc2":"Precision is acceptable but not recall and F1-score for those peptides predicted to induce antibody reactions. Thus, misclassification of true positives but not true negatives is rampant. "}}