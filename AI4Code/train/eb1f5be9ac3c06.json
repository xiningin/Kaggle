{"cell_type":{"10500141":"code","ef0f2601":"code","ae63aec6":"code","84309dd1":"code","490d6c0a":"code","9e5a2b17":"code","2cadf159":"code","d9af0ab2":"code","6a175d5f":"code","83886c37":"code","4d86f625":"code","c1a251ad":"code","dfea11d9":"code","0ddfbd52":"code","813a4bfb":"code","4ef96bdc":"code","7834a859":"code","640e6e6e":"code","7ce2b386":"code","fce32298":"code","3959d603":"markdown","4523b334":"markdown","58900e34":"markdown","9dbf264c":"markdown","b75ea709":"markdown","e2b72835":"markdown","b7ac395f":"markdown","25af1b5e":"markdown","ff8f5321":"markdown","4b153ccd":"markdown","3c6339c4":"markdown","760d1db8":"markdown","e40ab4d5":"markdown","6e0ee453":"markdown"},"source":{"10500141":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport warnings\nfrom tqdm.notebook import tqdm\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session\nfrom datetime import date, datetime\nfrom dateutil.relativedelta import relativedelta\nfrom typing import List, Tuple, Dict","ef0f2601":"!pip install yahoofinancials\n\nfrom yahoofinancials import YahooFinancials as YF","ae63aec6":"D_AVAILABLE_COMPANIES = os.path.join('\/kaggle\/input', 'availablecompanies-usingfundamentalanalysis\/available_companies.csv')\ndf_companies = pd.read_csv(D_AVAILABLE_COMPANIES)\ndf_companies.head()","84309dd1":"df_companies = df_companies[df_companies.exchange == 'Nasdaq Global Select']\nprint(f'total comapnies in NASDAQ - {df_companies.shape[0]}')\ndf_companies.head()","490d6c0a":"list_tickers = df_companies.symbol.to_list()","9e5a2b17":"NUM_COMPANIES_PER_QUE = 1\nNUM_COMPANIES_TO_SEE = 150\n\nFLAG_GET_NEW_DATA = False\nclass Tickers_Iterator:\n    def __init__(self, list_tickers, num_companies = 1):\n        self.list_tickers = list_tickers\n        self.left_companies = len(list_tickers)\n        self.NUM_COMPANIES_PER_ITERATION = num_companies\n    def __iter__(self):\n        return self\n    def __next__(self):\n        if self.left_companies == 0 :\n            raise StopIteration\n        elif self.left_companies < self.NUM_COMPANIES_PER_ITERATION:\n            self.left_companies = 0\n            return self.list_tickers[:]\n        else:\n            output_tickers = self.list_tickers[:self.NUM_COMPANIES_PER_ITERATION]\n            self.list_tickers = self.list_tickers[self.NUM_COMPANIES_PER_ITERATION:]\n            self.left_companies -= self.NUM_COMPANIES_PER_ITERATION\n            return output_tickers\n    def get_numIteration(self):\n        return np.ceil(len(list_tickers) \/ self.NUM_COMPANIES_PER_ITERATION)\n\ndef reformat_dict_stmt_2_df_stmt(dict_format):\n    try:\n        for dict_ticker_dict_data in dict_format.values():\n            for ticker, list_dict_date_dict_data in dict_ticker_dict_data.items():\n                list_df = []\n                if list_dict_date_dict_data == None:\n                    return pd.DataFrame()\n                for dict_date_dict_data in list_dict_date_dict_data:\n                    for date, dict_data in dict_date_dict_data.items():\n                        list_df.append(pd.DataFrame.from_dict(dict_data, orient='index', columns=[date]))\n\n                df_format = pd.concat(list_df, axis=1)\n                return df_format\n    \n    except:\n        print(dict_format)\n        raise ValueError\n        \nif FLAG_GET_NEW_DATA:\n    #### make folders to save\n    d_saveFolder = os.path.join(r'\/kaggle\/working\/', 'financial_stmts')\n    if not os.path.isdir(d_saveFolder):\n        os.mkdir(d_saveFolder)\n    #### save stmts to this folder\n    tickers_iterator = Tickers_Iterator(list_tickers, num_companies = NUM_COMPANIES_PER_QUE)\n    for i, list_sampleTicker in tqdm(enumerate(tickers_iterator), total=tickers_iterator.get_numIteration()):\n        if i == NUM_COMPANIES_TO_SEE : # it takes too long\n            break\n        d_save = os.path.join(d_saveFolder, f'{list_sampleTicker[0]}_{NUM_COMPANIES_PER_QUE}.csv')\n        if not os.path.isfile(d_save):\n            yf = YF(list_sampleTicker)\n            df_income_annual = reformat_dict_stmt_2_df_stmt(yf.get_financial_stmts(frequency='annual', statement_type='income'))\n            df_balance_annual = reformat_dict_stmt_2_df_stmt(yf.get_financial_stmts(frequency='annual', statement_type='balance'))\n            df_cash_annual = reformat_dict_stmt_2_df_stmt(yf.get_financial_stmts(frequency='annual', statement_type='cash'))\n            df_total_annual = pd.concat([df_income_annual, df_balance_annual, df_cash_annual], axis = 0)\n            df_total_annual = df_total_annual[~df_total_annual.index.duplicated(keep='first')]\n            df_total_annual.to_csv(d_save)\n        else:\n            continue\n\n#         df_income_quarterly = reformat_dict_stmt_2_df_stmt(yf.get_financial_stmts(frequency='quarterly', statement_type='income'))\n#         df_balance_quarterly = reformat_dict_stmt_2_df_stmt(yf.get_financial_stmts(frequency='quarterly', statement_type='balance'))\n#         df_cash_quarterly = reformat_dict_stmt_2_df_stmt(yf.get_financial_stmts(frequency='quarterly', statement_type='cash'))","2cadf159":"def _reformat_list_price_2_df_price(list_price):\n    KEY_DATE = 'formatted_date'\n    df_price = pd.DataFrame(list_price)\n    df_price = df_price.set_index(KEY_DATE)\n    df_price = df_price.T\n    return df_price\ndef _reformat_dict_dividends_2_df_dividends(dict_dividends):\n    KEY_AMOUNT = 'amount'\n    list_df = []\n    for date, dict_data in dict_dividends.items():\n        list_df.append(pd.DataFrame({date:[dict_data[KEY_AMOUNT]]}, index=['dividends']))\n    df_dividends = pd.concat(list_df, axis = 1 )\n    df_dividends = df_dividends.sort_index(axis=1)\n    return df_dividends\n    \ndef reformat_dictPriceDvidends_2_dfPrice_dfDividends(dict_format):\n    KEY_EVENTS = 'eventsData'\n    KEY_DIVIDENDS = 'dividends'\n    KEY_PRICES = 'prices'\n    for dict_eventsData in dict_format.values():\n        try:\n            dict_dividendsData = dict_eventsData[KEY_EVENTS][KEY_DIVIDENDS]\n            df_divid = _reformat_dict_dividends_2_df_dividends(dict_dividendsData)\n        except:\n            df_divid = pd.DataFrame()\n        try:\n            list_priceData = dict_eventsData[KEY_PRICES]\n            df_price = _reformat_list_price_2_df_price(list_priceData)\n        except:\n            df_price = pd.DataFrame()\n        return df_divid, df_price","d9af0ab2":"if FLAG_GET_NEW_DATA:\n    tickers_iterator = Tickers_Iterator(list_tickers, num_companies = NUM_COMPANIES_PER_QUE)\n\n    #### make folders to save\n    d_saveFolderPrice = os.path.join(r'\/kaggle\/working\/', 'historical_prices')\n    if not os.path.isdir(d_saveFolderPrice):\n        os.mkdir(d_saveFolderPrice)\n    d_saveFolderDivid = os.path.join(r'\/kaggle\/working\/', 'dividends')\n    if not os.path.isdir(d_saveFolderDivid):\n        os.mkdir(d_saveFolderDivid)\n    #### save stmts to this folder\n    for i, list_sampleTicker in tqdm(enumerate(tickers_iterator), total=tickers_iterator.get_numIteration()):\n        if i == NUM_COMPANIES_TO_SEE: # it takes too long\n            break\n        d_save_price = os.path.join(d_saveFolderPrice, f'{list_sampleTicker[0]}_{NUM_COMPANIES_PER_QUE}_price.csv')\n        d_save_divid = os.path.join(d_saveFolderDivid, f'{list_sampleTicker[0]}_{NUM_COMPANIES_PER_QUE}_divid.csv')\n        if (not os.path.isfile(d_save_price)) and (not os.path.isfile(d_save_divid)):\n            yf = YF(list_sampleTicker)\n            dict_historical_price = yf.get_historical_price_data('2015-01-01', '2021-02-01', 'daily')\n            df_divid, df_price = reformat_dictPriceDvidends_2_dfPrice_dfDividends(dict_historical_price)\n            df_divid.to_csv(d_save_divid)\n            df_price.to_csv(d_save_price)      \n        else:\n            continue\n","6a175d5f":"def _str_2_date(str_time):\n    return datetime.strptime(str_time, '%Y-%m-%d').date()\n\ndef _str_2_deltaDate(str_time:str):\n    list_temp = str_time.split('-')\n    if len(list_temp) != 3:\n        raise ValueError(f'{str_time} is not in time format')\n    year = int(list_temp[0])\n    month = int(list_temp[1])\n    day = int(list_temp[2])\n    return relativedelta(years=year, months=month, days=day)\n\ndef _get_timeIndex_inPeriod(list_time:str, start_time:str, end_time:str)->List[str]:\n    list_passed_time = []\n    st = _str_2_date(start_time)\n    et = _str_2_date(end_time)\n    if et <= st : # check start time and end time is correclty given\n        raise ValueError(f'{start_time} is late than {end_time}')\n    for time in list_time:\n        t = _str_2_date(time)\n        if t > st and t < et:\n            list_passed_time.append(time)\n    return list_passed_time","83886c37":"TIME_DIVID_PERIOD = '0003-00-00'\nTIME_DIVID_INTERVAL = '0000-06-00'\nD_INPUT_DATAS = r'\/kaggle\/input\/150-tickers-of-companies'","4d86f625":"# demo_ticker\ndemo_ticker = 'AAPL'\nd_csv = os.path.join(os.path.join(D_INPUT_DATAS, 'dividends'), f'{demo_ticker}_1_divid.csv')\ndf_divid = pd.read_csv(d_csv, index_col = 0)\nstr_targetDate = '2021-02-01'\ndef get_dividends_date(df_divid, str_targetDate, time_period = TIME_DIVID_PERIOD, time_interval = TIME_DIVID_INTERVAL):\n    series_strDate = df_divid.columns\n    series_date = series_strDate.map(lambda str_date: _str_2_date(str_date))\n    delta_interval = _str_2_deltaDate(time_interval)\n    delta_period = _str_2_deltaDate(time_period)\n    date_end = _str_2_date(str_targetDate)\n    date_start = date_end - delta_period\n    # start\n    date_flag_start = date_end - delta_interval\n    date_flag_end = date_end\n    list_series_date = []\n    list_columns = []\n    i = 0\n    while date_flag_start >= date_start:\n        list_series_date.append(series_date[(series_date >= date_flag_start) & (series_date < date_flag_end)])\n        date_flag_start -= delta_interval\n        date_flag_end -= delta_interval\n        tp_start = f'{(i+1)*delta_interval}'.split('relativedelta')[1]\n        tp_end = f'{i*delta_interval}'.split('relativedelta')[1]\n        list_columns.append(f'dividens-{tp_start}~{tp_end}')\n        i += 1\n    # sum dividends in certain period\n    try:\n        df_dividends = pd.DataFrame(data = [[df_divid[series_date.map(lambda d: str(d))].loc['dividends'].sum() for series_date in list_series_date]], \n                                    columns = list_columns, index = ['sum'])\n    except KeyError:\n        df_dividends = pd.DataFrame(data = [[0 for i in range(len(list_series_date))]],\n                                    columns = list_columns, index = ['sum'])\n    return df_dividends\ndf_dividends = get_dividends_date(df_divid, str_targetDate)\ndf_dividends","c1a251ad":"NUM_START_FROM_BEGIN = 100\nNUM_END_FROM_BEGIN = 30\nLIST_PRICE_INDEX = ['close', 'volume']","dfea11d9":"# demo\nd_csv = os.path.join(os.path.join(D_INPUT_DATAS, 'historical_prices'), f'{demo_ticker}_1_price.csv')\ndf_price = pd.read_csv(d_csv, index_col = 0)\nstr_targetDate = '2021-01-15'\n\ndef get_price_data(df_price, str_targetDate, num_sfb=NUM_START_FROM_BEGIN, num_efb=NUM_END_FROM_BEGIN, list_loc = LIST_PRICE_INDEX):\n    \n    series_strDate = df_price.columns\n    try:\n        index_begin = np.where(series_strDate == str_targetDate)[0][0]\n    except:\n        raise ValueError(f'{str_targetDate} is not in price data')\n    index_start = index_begin - num_sfb\n    index_end = index_begin - num_efb\n    series_windowStrDate = series_strDate[index_start : index_end]\n    # reformat\n    dict_newColumn = {str_date : f'price-{i}' for i, str_date in enumerate(series_windowStrDate)}\n    df_windowPrice = df_price[series_windowStrDate].loc[list_loc]\n    df_windowPrice = df_windowPrice.rename(columns=dict_newColumn, errors='raise')\n    df_strDate = pd.DataFrame([[str_date for str_date in series_windowStrDate]], columns = [f'price-{i}' for i in range(len(series_windowStrDate))], index = ['date'])\n    df_windowPrice = df_windowPrice.append(df_strDate)\n    return df_windowPrice\n\nget_price_data(df_price, str_targetDate, num_sfb = NUM_START_FROM_BEGIN, num_efb = NUM_END_FROM_BEGIN)","0ddfbd52":"NUM_STMTS = 3\nLIST_STMTS_INDEX = ['researchDevelopment', 'effectOfAccountingCharges', 'incomeBeforeTax',\n                    'minorityInterest', 'netIncome', 'sellingGeneralAdministrative',\n                    'grossProfit', 'ebit', 'operatingIncome', 'otherOperatingExpenses',\n                    'interestExpense', 'extraordinaryItems', 'nonRecurring', 'otherItems',\n                    'incomeTaxExpense', 'totalRevenue', 'totalOperatingExpenses',\n                    'costOfRevenue', 'totalOtherIncomeExpenseNet', 'discontinuedOperations',\n                    'netIncomeFromContinuingOps', 'netIncomeApplicableToCommonShares',\n                    'totalLiab', 'totalStockholderEquity', 'otherCurrentLiab',\n                    'totalAssets', 'commonStock', 'otherCurrentAssets', 'retainedEarnings',\n                    'otherLiab', 'treasuryStock', 'otherAssets', 'cash',\n                    'totalCurrentLiabilities', 'shortLongTermDebt',\n                    'otherStockholderEquity', 'propertyPlantEquipment',\n                    'totalCurrentAssets', 'longTermInvestments', 'netTangibleAssets',\n                    'shortTermInvestments', 'netReceivables', 'longTermDebt', 'inventory',\n                    'accountsPayable', 'investments', 'changeToLiabilities',\n                    'totalCashflowsFromInvestingActivities', 'netBorrowings',\n                    'totalCashFromFinancingActivities', 'changeToOperatingActivities',\n                    'issuanceOfStock', 'changeInCash', 'repurchaseOfStock',\n                    'totalCashFromOperatingActivities', 'depreciation',\n                    'otherCashflowsFromInvestingActivities', 'dividendsPaid',\n                    'changeToInventory', 'changeToAccountReceivables',\n                    'otherCashflowsFromFinancingActivities', 'changeToNetincome',\n                    'capitalExpenditures']","813a4bfb":"# demo\nd_csv = os.path.join(os.path.join(D_INPUT_DATAS, 'financial_stmts'), f'{demo_ticker}_1.csv')\ndf_stmts = pd.read_csv(d_csv, index_col = 0)","4ef96bdc":"a = pd.DataFrame(columns= ['a', 'b'], data = [[1,2],[0,0]] )\nb = pd.DataFrame()\nb","7834a859":"\ndef get_stmts_data(df_stmts, str_targetDate, num_stmts = NUM_STMTS, list_stmts = LIST_STMTS_INDEX):\n    date_point = _str_2_date(str_targetDate)\n    series_date = df_stmts.columns.map(lambda str_date: _str_2_date(str_date)).sort_values(ascending = False)\n    series_passed_date = series_date[series_date < date_point]\n    series_windowStrDate = series_passed_date.map(lambda date_str:str(date_str))[:num_stmts]\n    if series_passed_date.shape[0] < num_stmts :\n        # warnings.warn(f'requiring stmt number - {num_stmts} is larger than capable stmt number - {series_passed_date.shape[0]}')\n        return pd.DataFrame()\n    try:\n        df_windowSTMT = df_stmts[series_windowStrDate].loc[list_stmts]\n    except KeyError: # if there is no key from LIST_STMTS_INDEX\n        df_windowSTMT = pd.DataFrame()\n        for index in list_stmts:\n            if index in df_stmts.index:\n                df_windowSTMT = df_windowSTMT.append(df_stmts[series_windowStrDate].loc[index])\n            else:\n                df_windowSTMT = df_windowSTMT.append(pd.Series(name = index))\n    # reformat\n    dict_newColumn = {str_date : f'stmt-{i}' for i, str_date in enumerate(series_windowStrDate)}\n    df_windowSTMT = df_windowSTMT.rename(columns=dict_newColumn, errors='raise')\n    df_strDate = pd.DataFrame([[str_date for str_date in series_windowStrDate]], columns = [f'stmt-{i}' for i in range(len(series_windowStrDate))], index = ['date'])\n    df_windowSTMT = df_windowSTMT.append(df_strDate)\n    return df_windowSTMT\nget_stmts_data(df_stmts, str_targetDate, num_stmts = NUM_STMTS)","640e6e6e":"def get_dataset(ticker, date):\n    '''\n    output - df_dividends, price, stmt and label of price\n    '''\n    pass\nticker = 'AAPL'\nstr_targetDate = '2020-01-15'\nD_STMT = '\/kaggle\/input\/150-tickers-of-companies\/financial_stmts'\nD_DIVID = '\/kaggle\/input\/150-tickers-of-companies\/dividends'\nD_PRICE = '\/kaggle\/input\/150-tickers-of-companies\/historical_prices'\nTIME_INVEST = 20\nLABEL_PRICE = 'close'\nclass DATA_of_TICKER:\n    def __init__(self, ticker,\n                 d_stmt = D_STMT, d_divid = D_DIVID, d_price = D_PRICE,\n                 fun_stmt = get_stmts_data, fun_price = get_price_data, fun_divid = get_dividends_date, \n                 time_divid_period = TIME_DIVID_PERIOD, time_divid_interval = TIME_DIVID_INTERVAL,\n                 num_stmts = NUM_STMTS, num_price_sfb = NUM_START_FROM_BEGIN, num_price_efb = NUM_END_FROM_BEGIN, \n                 list_stmts_index = LIST_STMTS_INDEX, list_price_index = LIST_PRICE_INDEX, \n                 time_invest = TIME_INVEST, label_price = LABEL_PRICE\n                ):\n        self.ticker = ticker\n        \n        self.D_STMT = d_stmt, \n        self.D_DIVID = d_divid\n        self.D_PRICE = d_price\n        \n        self.FUN_STMT = fun_stmt\n        self.FUN_PRICE = fun_price\n        self.FUN_DIVID = fun_divid\n        \n        self.LIST_STMTS_INDEX = list_stmts_index\n        self.LIST_PRICE_INDEX = list_price_index\n        \n        self.TIME_DIVID_PERIOD = time_divid_period\n        self.TIME_DIVID_INTERVAL = time_divid_interval\n        \n        self.NUM_STMTS = num_stmts\n        self.NUM_PRICE_SFB = num_price_sfb\n        self.NUM_PRICE_EFB = num_price_efb\n        \n        self.df_stmt = pd.read_csv(os.path.join(d_stmt, f'{ticker}_1.csv'), index_col = 0)\n        self.df_divid = pd.read_csv(os.path.join(d_divid, f'{ticker}_1_divid.csv'), index_col = 0)\n        self.df_price = pd.read_csv(os.path.join(d_price, f'{ticker}_1_price.csv'), index_col = 0)\n        \n        self.TIME_INVEST = time_invest\n        self.LABEL_PRICE = label_price\n    def _get_stmts_data(self, str_targetDate):\n        return self.FUN_STMT(self.df_stmt, str_targetDate, \n                             num_stmts = self.NUM_STMTS, list_stmts = self.LIST_STMTS_INDEX)\n    \n    def _get_price_data(self, str_targetDate):\n        return self.FUN_PRICE(self.df_price, str_targetDate, \n                              num_sfb=self.NUM_PRICE_SFB, num_efb=self.NUM_PRICE_EFB, list_loc = self.LIST_PRICE_INDEX)\n    \n    def _get_dividends_data(self, str_targetDate):\n        return self.FUN_DIVID(self.df_divid, str_targetDate, \n                              time_period = self.TIME_DIVID_PERIOD, time_interval = self.TIME_DIVID_INTERVAL)\n    \n    def _flatten_df_2_series(self, df):\n        list_col = df.columns\n        series_total = pd.Series(dtype = 'float64')\n        for col in list_col:\n            series = df[col]\n            series_total = series_total.append(series.rename(lambda label: f'{col}_{label}'))\n        return series_total\n    \n    def get_dataset(self, str_targetDate):\n        df_window_stmt = self._get_stmts_data(str_targetDate)\n        if df_window_stmt.empty: \n            return (pd.Series, 0)\n        df_window_price = self._get_price_data(str_targetDate)\n        df_window_divid = self._get_dividends_data(str_targetDate)\n        series_total = pd.Series(dtype = 'float64')\n        for df in [df_window_stmt, df_window_price, df_window_divid]:\n            series_total = series_total.append(self._flatten_df_2_series(df))\n        label = self._get_invest_portion(str_targetDate)\n        return (series_total, label)\n    \n    def _get_invest_portion(self, str_targetDate):\n        df_price = self.df_price\n        series_strDate = df_price.columns\n        index_investBegin = np.where(series_strDate == str_targetDate)[0][0]\n        str_investEnd = series_strDate[index_investBegin + self.TIME_INVEST]\n        price_invest_end = df_price[str_investEnd].loc[self.LABEL_PRICE]\n        price_invest_start = df_price[str_targetDate].loc[self.LABEL_PRICE]\n        return price_invest_end\/price_invest_start\n        \n    \ndemo_ticker = DATA_of_TICKER(ticker)\ndemo_ticker.get_dataset(str_targetDate)\n","7ce2b386":"tickers_iterator = Tickers_Iterator(list_tickers, num_companies = NUM_COMPANIES_PER_QUE)\nlist_date_startInvest = ['2020-01-13', '2020-02-10', '2020-03-16', '2020-04-13', '2020-05-11', '2020-06-15', '2020-07-13', '2020-08-10']\ndf_datasetTot = pd.DataFrame()\nlist_label = []\nif False:\n    for i, list_sampleTicker in tqdm(enumerate(tickers_iterator), total=tickers_iterator.get_numIteration()):\n        data_ticker = DATA_of_TICKER(list_sampleTicker[0])\n        for str_startInvestDate in list_date_startInvest:\n            dataset, label = data_ticker.get_dataset(str_startInvestDate)\n            if dataset.empty:\n                continue\n            df_datasetTot = df_datasetTot.append(dataset, ignore_index = True)\n            list_label.append(label)\ndf_datasetTot\n\n","fce32298":"# df_Tot = df_datasetTot.insert(len(df_datasetTot.columns), 'label', list_label)\ndf_datasetTot\ndf_datasetTot.to_csv('\/kaggle\/working\/150_dataset.csv')","3959d603":"**Data is collected from different time period**\n\nI will sample data in next criteria\n\n* Price will be affected by past dividends, stmts, and price. \n* dividends of 3 years with 6 month interval will be used.\n* 3 years of stmts data will be used. \n* price of 1 year will be also used. \n\nWe have to make functions which samples data of certain date. ","4523b334":"Let's just use code from 'Nasdaq Gloabal Select'\nNasdaq and NYSE have some differences. \nSee https:\/\/www.dailyfx.com\/nas-100\/NASDAQ-vs-NYSE.html","58900e34":"## Let's make Functions for Price Data\n- price data seems so many. \n- Let's just take 100 data points","9dbf264c":"We also need price datas","b75ea709":"## Now it's time to make the data to dataset form\n\n* Input should be ticker, date\n* and single function will get the dividends, price, stmt as dataset \n* label will be the price of speicific date#","e2b72835":"functions for dividends","b7ac395f":"constants to use","25af1b5e":"## First let's make functions for dividends","ff8f5321":"## Step 2 - reformat the data","4b153ccd":"# Using yahoofinancials to gather financial statements\n\n## Step 1 - make functions to gather code","3c6339c4":"Now let's gather data","760d1db8":"Get tickers I can use\nI got this using `FundamentalAnalysis.available_companies` module.","e40ab4d5":"## Now it's for STMT\n\nMake function for getting 3 STMT for specific date.","6e0ee453":"## Now all of the functions are ready to generate datasets.\n\nLet's make it"}}