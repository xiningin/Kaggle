{"cell_type":{"9a32d211":"code","1e99b995":"code","12c6aef0":"code","ff7d46a7":"code","950b340d":"code","69697ecb":"code","065e13fa":"code","6f016863":"code","35aa39e0":"code","7609297b":"code","a4aed121":"code","1b93f0fc":"code","a7acca4e":"code","7aedf378":"code","3b2aa4a1":"markdown","2243e724":"markdown","438f3e82":"markdown","0e029cee":"markdown","e2294979":"markdown","b0f15887":"markdown","63d86285":"markdown","79a841d7":"markdown","7b7da4a4":"markdown"},"source":{"9a32d211":"# First, I am importing some packages that I think I may need later on\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt","1e99b995":"table = list(range(1,10)) + [10]*4\ntable","12c6aef0":"draw_count = {str(card_value):table.count(card_value) for card_value in set(table)}\nprint('Card count in each draw',draw_count)\ntotal_cards = sum(card_count for card_count in draw_count.values())\nprint('Net cards', total_cards)\ndraw = {k:(v\/total_cards) for k,v in draw_count.items()}\nprint('Probability of each card:', draw)","ff7d46a7":"def bj_probability(player_count, dealer_count):\n    '''Returns a list as follows: [probability player wins if he opts to stay, probability player wins if he opts to hit]'''\n    if player_count > 21: return [0,0] # Player busts\n    if dealer_count > 21: return [1,1] # Dealer busts\n    if dealer_count >=17: \n        prob_win = 1*(player_count > dealer_count) # Player only wins if his count is higher than dealer's \n                                                   # once dealer hits 17 or more\n        return [prob_win, prob_win]\n    # Here is for other undecided scenarios\n    # Stay prob = probability of drawing each card * winning after dealer draws each card and player opts to stay again\n    stay_prob = sum(draw[card]  * bj_probability(player_count, dealer_count + int(card))[0]  for card in draw)\n    # Hit prob = probability of drawing each card * winning after dealer draws each card \n    # and player decides to play hit or stay depending on max prob of winning \n    hit_prob = sum(draw[card] * max(bj_probability(player_count + int(card), dealer_count)) for card in draw)\n    return [stay_prob, hit_prob]","950b340d":"arr = [[None for i in range(23)] for j in range(23)]\n\ndef bj_probability_with_dp(player_count, dealer_count):\n    '''Returns a list as follows: [probability player wins if he opts to stay, probability player wins if he opts to hit]'''\n    if player_count > 21: return [0,0] # Player busts\n    if dealer_count > 21: return [1,1] # Dealer busts\n    if arr[player_count][dealer_count] is None:\n        if dealer_count >=17: \n            prob_win = 1*(player_count > dealer_count) # Player only wins if his count is higher than dealer's \n                                                       # once dealer hits 17 or more\n            result =  [prob_win, prob_win]\n        else:\n            # Here is for other undecided scenarios\n            # Stay prob = probability of drawing each card * winning after dealer draws each card and player opts to stay again\n            stay_prob = sum(draw[card]  * bj_probability_with_dp(player_count, dealer_count + int(card))[0]  for card in draw)\n            # Hit prob = probability of drawing each card * winning after dealer draws each card \n            # and player decides to play hit or stay depending on max prob of winning \n            hit_prob = sum(draw[card] * max(bj_probability_with_dp(player_count + int(card), dealer_count)) for card in draw)\n            result = [stay_prob, hit_prob]\n        arr[player_count][dealer_count] = result\n    return arr[player_count][dealer_count]","69697ecb":"%%time \nprint(bj_probability_with_dp(0,0))","065e13fa":"df = pd.DataFrame(data=arr, columns=list(range(23)))\ndf.head(10)","6f016863":"for i in range(12,18):\n    print(i, 'normal prob', bj_probability(i,i), 'dp prob', bj_probability_with_dp(i,i))","35aa39e0":"df","7609297b":"df_1 =df.rename_axis('Player_count', axis='rows').rename_axis('Dealer_count', axis='columns').iloc[:-1,:-1]\ndf_1","a4aed121":"def stay_prob(x): return x[0]\ndf_stay = df_1.applymap(lambda x:stay_prob(x))\ndf_stay","1b93f0fc":"df_hit = df_1.applymap(lambda x:x[1])\ndf_hit","a7acca4e":"plt.figure(figsize=(7,7))\nplt.imshow(df_stay.values)\nplt.xlabel('Dealer count')\nplt.ylabel('Player count')\nplt.title('Stay probabilities colormap')\nplt.colorbar()\nplt.show()","7aedf378":"plt.figure(figsize=(7,7))\nplt.imshow(df_hit.values)\nplt.xlabel('Dealer count')\nplt.ylabel('Player count')\nplt.title('Hit probabilities colormap')\nplt.colorbar()\nplt.show()","3b2aa4a1":"Now, computing the entire probability matrix for all scenarios is easy peasy","2243e724":"As we observe, the hit probabilities get lower and lower as player count gets higher, but not always. As we see, near player count 11, the hit probability is little higher.\nThe stay probability follows a pattern too and peaks near 7-10, where the dealer may be more likely to end up below the player","438f3e82":"# Black Jack simulator\n\nIn this kernel, I am going to explore the way to encounter the winning strategy of BlackJack and how to arrive at the winning program.\nFor now , I will be considering an infinite set of decks that can be dealed and work from the simplest  variation of black jack to more complex versions.","0e029cee":"So as we can see above, the table contains the list of cards that can occur equally on each draw, just like the numbers on a 13 faced dice, except that 10 is repeated 4 times.\nNow, I will construct a probability dictionary so that I can get the probability of each card occuring on each draw.","e2294979":"Easy solution within 17 ms..","b0f15887":"Now, I will create the deck of cards and their corresponding probabilities.\nWe have cards 2,3,4,5,6,7,8,9,10 and Jack, Queen, King and Ace cards in the deck, making for a total of 13 cards that can be dealt with the same probability on next draw.\n\nI will create a dictionary consisting of the value of cards and count of cards. \nFor simplicity, I will consider the Jack, Queen and King cards to be no different from a number 10 card( which makes no difference)\nand the ace card to hold a default value of 1. I am not considering the high value of 11 Ace card for now. So, we can consider the deck to have cards 1 to 9 and 4 10 cards. \n\nForgive my jargon for black jack, as I am not familiar with it.","63d86285":"As seen above, each card can be drawn with probability 1\/13 = 7.7%, with exception of the no 10 card, which can be drawn with 4\/13 = 30.8% probability.\n\nNow, I will start to construct a skeletal function of the black jack probability measure.\nHere, I am just constructing a function which will get the probability of a player win based on the total count of cards that a player has and the count of cards that a dealer has. I will compute the stay probability and the hit probability of the player recursively so we can make a decision at any stage whether the player needs to hit or stay.","79a841d7":"### Converting the above into a DP problem\nAs an exercise, you can time the below queries.\n```\n%%time\nprint(bj_probability(16,16))\n```\n\n```\n%%time\nprint(bj_probability(14,14))\n```\n\n```\n%%time\nprint(bj_probability(12,12))\n```\n\n```\n%%time\nprint(bj_probability(11,11))\n```\n-------------------------------------------------------------------------\nTry running the below query and estimate the time it will take as an exercise(Wait till the black death of universe)\n\n```\n%%time\nprint(bj_probability(0,0))\n```\nConsidering it took about a minute to get probability of (11,11), I will use DP version, which is surprisingly easy.\n","7b7da4a4":"Now that we represented the probabilities, we can move on to next steps`\n\nWe can compare the results from both approaches to check if they are same"}}