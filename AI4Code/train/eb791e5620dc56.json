{"cell_type":{"656e915a":"code","4a9cf4c5":"code","012d0c41":"code","8ebdb5b6":"code","059d69c8":"code","3dc7df38":"code","b1652810":"code","1bd5afa1":"code","3ce86154":"code","b0387d6e":"code","17f07cce":"code","3f44f4a7":"code","3b6ba067":"code","23be8ef0":"code","72a349f4":"code","8d1302bb":"code","c884fc84":"code","2bbbc7f6":"code","dc559797":"code","525613ca":"code","69158657":"code","c3115862":"code","90a2341a":"code","facbd604":"code","75e4ad1c":"code","619b387f":"code","a34e598c":"code","fea02f4d":"code","2bdbfa40":"code","6b2efca3":"code","d06fa96a":"code","e7521acc":"markdown","7eeb1fb2":"markdown","2fa8c53d":"markdown","8c573fb5":"markdown","7b3088e6":"markdown","cb05d24a":"markdown","4ddeaf59":"markdown","6f87c45d":"markdown","8e33506d":"markdown","2944ba3a":"markdown","47104abb":"markdown","49d63885":"markdown","e72f8613":"markdown","32c67876":"markdown","bb30d20f":"markdown","0c7c67eb":"markdown","438ae47e":"markdown","e1ba218e":"markdown","f7c6bc8d":"markdown","9263234e":"markdown","4f222f0c":"markdown","cb5dbc85":"markdown","c186543f":"markdown","af2d3a21":"markdown","beb20371":"markdown","86ea5bd7":"markdown","13680d7a":"markdown"},"source":{"656e915a":"import os\nimport pandas as pd\nimport numpy as np\nfrom textblob import TextBlob\nimport re\nimport string\nimport warnings\nfrom sklearn.preprocessing import LabelEncoder\nimport nltk\nimport spacy\n#load the spacy english core \nspacy_nlp = spacy.load('en_core_web_sm')","4a9cf4c5":"folder = 'input\/competitive-data-science-predict-future-sales'\npath = f'..\/{folder}'\nfiles = os.listdir(path)\nprint(files)","012d0c41":"items = pd.read_csv(path + '\/' + files[0]) # beware of using your own indexes if you edit this notebook\ncategories = pd.read_csv(path + '\/' + files[2])\nshops = pd.read_csv(path + '\/' + files[-2])","8ebdb5b6":"def translateText(text, from_lang, to_lang):\n    \"\"\"\n    Function for translating text.\n    It first translates and removes non-ascii characters. \n    If the first try is not succesful, it removes punctuation before translating, \n    as it may cause bad request http errors (probably due to an unresolved bug). If this is again\n    not successful, it returns NA.\n    \n    Parameters\n    ----------\n    text: str\n        Text for translating.\n    from_lang: str\n        Original language.\n    to_lang: str\n        Desired language.\n    \"\"\"\n    \n    try:\n        # Translating.\n        text = str(TextBlob(text).translate(from_lang=from_lang, to=to_lang))\n        # Removing non-ascii characters.\n        text = re.sub('[^\\x00-\\x7F]+', '', text) \n        \n    except Exception: # some punctuation symbols currently cause a bad request error, we'll remove them and try again\n        text = text.translate(str.maketrans('', '', string.punctuation))\n        \n        try:\n            # Translating.\n            text = str(TextBlob(text).translate(from_lang=from_lang, to=to_lang))\n            # Removing non-ascii characters.\n            text = re.sub('[^\\x00-\\x7F]+', '', text)\n            \n        except Exception: \n            text = np.nan # we'll return NA in case of any other error so we can detect it later\n    \n    return text","059d69c8":"# applying translation for shops and categories\ncategories['category_name_en'] = categories.item_category_name.apply(lambda x: translateText(x, 'ru', 'en'))\nshops['shop_name_en'] = shops.shop_name.apply(lambda x: translateText(x, 'ru', 'en'))","3dc7df38":"# pretranslated files in local\nshops = pd.read_csv('..\/input\/new-shops\/new_shops.csv')\ncategories = pd.read_csv('..\/input\/new-categories\/new_categories.csv')","b1652810":"display(shops.head(3))\nprint(shops.shape)\nprint('\\nUntranslated values: \\n', shops.shop_name_en.isna().sum())\ndisplay(categories.head(3))\nprint(categories.shape)\nprint('\\nUntranslated values: \\n', categories.category_name_en.isna().sum())","1bd5afa1":"%%time\n# translating items\n# Uncomment the following line for a try, but beware of executing this cell with enough time to let it run, as it is a highly cpu and memory consuming task\n\n#items['item_name_en'] = items.item_name.apply(lambda x: translateText(x, 'ru', 'en'))","3ce86154":"# pretranslated files in local\nitems = pd.read_csv('..\/input\/new-items\/new_items.csv').drop(['Unnamed: 0'], axis=1)","b0387d6e":"display(items.head())\nprint(items.shape)\nprint('\\nUntranslated values: \\n', items.item_name_en.isna().sum())","17f07cce":"def detectLanguage(text):\n    \"\"\"\n    Detects language in a text.\n    \n    Parameters\n    ----------\n    text: str\n    \"\"\"\n    try:\n        text = TextBlob(text).detect_language()\n    except Exception:\n        pass\n    \n    return text","3f44f4a7":"items['language'] = items[items.item_name_en.isna()].item_name.apply(lambda x: detectLanguage(x))","3b6ba067":"display(items[(items.item_name_en.isna()) & (items.language != 'en')][['item_name', 'language']])\n\nitems['item_name_en'] = items.item_name_en.fillna(items.item_name)\ndel items['language']","23be8ef0":"del shops['shop_name'], categories['item_category_name'], items['item_name']","72a349f4":"# wholesome view of categories\npd.DataFrame(categories.category_name_en.values.reshape(-1, 12))","8d1302bb":"categories['category_name'] = categories.category_name_en.apply(lambda x: x.split(' - ')[0])\ncategories['subcategory_name'] = categories.category_name_en.apply(lambda x: x.split(' - ')[-1])\n\ncategories.head()","c884fc84":"def onlyAlphaNumeric(text):\n    \"\"\"\n    Puts to lowercase format and removes non-alphanumeric characters except spaces.\n    \n    Parameters\n    ----------\n    text: str\n    \"\"\"\n    text = text.lower()\n    text = re.sub(r'<\/i>|<b>|<i>|<\/b>', '', text) # also deleting some html notation\n    text = re.sub(r'[^A-Za-z0-9 ]+', '', text)\n    \n    return text","2bbbc7f6":"cat_columns = [col for col in categories.columns if 'name' in col]\ncategories[cat_columns] = categories[cat_columns].applymap(lambda x: onlyAlphaNumeric(x))\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\")\n    categories[32:35]['category_name'] = 'payment cards'\n    categories.iloc[32]['subcategory_name'] = 'cinema music games'\n    categories.iloc[34]['subcategory_name'] = 'number'\n    \ncategories['category_id'] = LabelEncoder().fit_transform(categories.category_name.values)\ncategories['subcategory_id'] = LabelEncoder().fit_transform(categories.subcategory_name.values)\n\ndisplay(categories.head())\nprint('Unique values: \\n', categories.nunique())","dc559797":"del categories['category_name_en']","525613ca":"shops_original_en = shops.copy()\n\nshops.head()","69158657":"# only alphanumeric strings\n# we could also eliminate 'quot' words, as they come from quotations before the translation,\n# but for our matter there is no necessity in doing so\ncat_columns = [col for col in shops.columns if 'name' in col]\nshops[cat_columns] = shops[cat_columns].applymap(lambda x: onlyAlphaNumeric(x))\n\n# also eliminating spelled quotations that may be left\nshops[cat_columns] = shops[cat_columns].applymap(lambda x: re.sub('quot', '', x))\n\n# cities\ndef takeCityName(text):\n    # we iterate over the name to find the city with a restriction of word-length\n    for i in range(0, len(text.split())):\n        if ((text.split()[i] != '') and (len(text.split()[i]) > 2)):\n            city = text.split()[i]\n            break\n                   \n    return city\n        \nshops['shop_city_name'] = shops.shop_name_en.apply(lambda x: takeCityName(x))\nshops['shop_city_name'] = np.where(shops['shop_city_name'] == 'digital', 'online', shops['shop_city_name'])\n\n# shop types\n#\nshops['shop_type_name'] = shops.shop_name_en.apply(lambda x: \n                                                   'megacenter' if re.findall(r'trk|xl|sec', x)\n                                                   else 'online' if 'online' in x\n                                                   else 'special' if re.findall(r'outbound|sale', x)\n                                                   else 'center' if re.findall(r'tc |shopping center', x)\n                                                   else 'unspecified')\n\n# ids\nshops['shop_city_id'] = LabelEncoder().fit_transform(shops.shop_city_name.values)\nshops['shop_type_id'] = LabelEncoder().fit_transform(shops.shop_type_name.values)   \n\ndisplay(shops.head())\nprint('Unique values: \\n', shops.nunique())","c3115862":"del shops['shop_name_en']","90a2341a":"with warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\")\n    for shop in shops_original_en.shop_name_en[15:23]:\n        doc = spacy_nlp(shop)\n        #the whole text with fancy entities location and type of entity\n        spacy.displacy.render(doc, style='ent', jupyter=True)","facbd604":"# printing stopwords examples with nltk\nstopwords_en = nltk.corpus.stopwords.words(\"english\")\nprint('10 examples of stopwords: ', stopwords_en[:10])","75e4ad1c":"items.tail()","619b387f":"def addTextMetrics(df, column):\n    \"\"\"Function for adding text metrics like length of name, number of nouns, etc. to a Dataframe.\n    \n    Parameters\n    ----------\n    df: pandas dataframe\n    column: str\n        Column of df for deriving text metrics from.\n    \n    Notes\n    -----\n    It uses a preloaded spacy language core, spacy_nlp.\n    \"\"\"      \n    \n    # adding basic name metrics\n    df[f'{column}_number_words'] = df[column].apply(lambda x: len(spacy_nlp(x)))\n    df[f'{column}_number_stopwords'] = df[column].apply(lambda x: len([token for token in spacy_nlp(x) \n                                                                       if token.is_stop]))\n    df[f'{column}_number_nouns'] = df[column].apply(lambda x: len([token for token in spacy_nlp(x) \n                                                                   if token.pos_ == 'NOUN']))\n    \n    return df","a34e598c":"def removeStopWords(text, content=False, outliers=False):\n    \"\"\" Removing stopwords and more non-useful words.\n    \n    Parameters\n    ----------\n    text: str\n    content: bool\n        If True, leaves only content words like nouns, adjectives, verbs and adverbs (also numbers).\n    outliers: bool\n         If True, removes what I call outliers in word length, for percentiles 5 and 95.\n         \n    Notes\n    -----\n    It uses a preloaded spacy language core, spacy_nlp.\n    \"\"\"      \n        \n    # Transforming to spacy.doc.Doc object for easier processing.\n    doc = spacy_nlp(text)\n    \n    if not content:\n        # removing stop_words with Spacy\n        tokens = [token.text for token in doc if not token.is_stop]\n\n        # if we've stripped all tokens by removing stopwords or we're left with just one word, we take the original name\n        if (len(tokens) < 2) or (not tokens):\n            tokens = [token.text for token in doc]\n    else:\n        # leaving only content words\n        tokens = [token.text for token in doc if token.pos_ in ['NOUN', 'PROPN', 'ADJ', 'VERB', 'NUM']]\n        if (len(tokens) < 2) or (not tokens): # if this is met, we take any remaining alpha characters\n            tokens = [token.text for token in doc if token.is_alpha]\n    \n    if outliers:\n        lengths = [len(token) for token in tokens]\n        words = []\n        for word in tokens:          \n            # Removing outliers in word-length:\n            if ((len(word.text) >= numpy.percentile(lengths,5)) and\n               (len(word.text) <= numpy.percentile(lengths,95))):\n                   words.append(word.text)  \n    \n        text = ' '.join(words) # return in string format\n    else:\n        text = ' '.join(tokens)\n \n    return text","fea02f4d":"%%time\n# only alphanumeric strings\ncat_columns = [col for col in items.columns if 'name' in col]\nitems[cat_columns] = items[cat_columns].applymap(lambda x: onlyAlphaNumeric(x))\n\n# also eliminating spelled quotations that may be left\nitems[cat_columns] = items[cat_columns].applymap(lambda x: re.sub('quot', '', x))\n\n# adding 3 new columns\nitems = addTextMetrics(items, 'item_name_en')\n\n# only removing stopwords and other non content words. \n# Outliers in word length are not necessary to be removed for this task.\nitems['item_name'] = items.item_name_en.apply(lambda x: removeStopWords(x, content=True))\n\n# we'll fill the remaining blank names with their original English name\nitems['item_name'] = np.where(items.item_name == '', items.item_name_en, items.item_name)","2bdbfa40":"display(items.tail())\nprint('Unique values: \\n', items.nunique())","6b2efca3":"del items['item_name_en']","d06fa96a":"#items.to_csv(path + '\/items_english.csv', index=False) # default comma-separated\n#categories.to_csv(path + '\/categories_english.csv', index=False)\n#shops.to_csv(path + '\/shops_english.csv', index=False)","e7521acc":"## Translation","7eeb1fb2":"Now, let's process items dataframe. In the previous cases, we've mostly had only nouns within the name, but for item names, we may also find adverbs, determinants and other so called **stopwords**, i.e., the most common words in a language. We'll be removing them in order to solely keep **nouns**-- which, in essence, **contain the whole meaning** of the name--, and other useful parts-of-speech or content words. We won't create a new ID for this new column, as even though we manage to reduce some cardinality with this process, it is still utterly high and there is no use for a meaningless ID. Also, we'll add 3 new columns containing a count of total words in the name, number of nouns and number of stopwords.\n\nWe'll utilize the prepared name for yielding more insights during the EDA phase. I'll soon upload a notebook for it.","2fa8c53d":"### Items","8c573fb5":"<div class=\"info alert-block alert-info\">\n    \ud83d\udcbb I have created this notebook in my local machine and already executed it. For speeding up the running of this notebook in Kaggle, I will be using my locally translated files.\n<\/div>","7b3088e6":"From the category values below, we can infer that every category name is comprised of a general category plus a subcategory, or just a single category. Let's extract them to create 2 new variables.","cb05d24a":"Translation for shops and categories is correct; there are no missing values. Great!","4ddeaf59":"<div class=\"alert alert-block alert-warning\">\n    <b>WARNING:<\/b> This next cell requires ~10 minutes to complete running.\n    <br><em>Executed with MSI PS42 Modern 8RC model.<\/em>\n<\/div>","6f87c45d":"---","8e33506d":"There are 321 unstranslated items, which is frankly well given the total number of observations, but let's dig deeper into them to see why they weren't translated.","2944ba3a":"## Preprocessing","47104abb":"In the table below we can see that all **untranslated items are due to them being already in English** or with a **numeric name**. This is also fantastic news! We'll use their original name. (Due to the small length of some of the strings, we can also see that the algorithm does what it can at detecting the language. It's important to note that these **language detection algorithms work best with bigger strings of text**, as they also tend to use stopwords as a primary source of knowledge.)","49d63885":"For the shops dataset, we'll perform the same text processing operations. In this case, though, **we're creating city** (as we can see that it tends to be the first token of the name) and **shop type variables** (as it is sometimes specified within). With a **little bit of research**, one may **comprehend the different types of shopping centers included**. For example, a TC (from the Russian \u0422\u0426) is a common shopping center, whereas a SEC (or TRK, depending on the translation, from the Russian \u0422\u0420\u0426 or \u0422\u0420\u041a) is a shopping and entertainment complex, including cinemas and other leisure activities.","e72f8613":"We will be using `TextBlob` for this task, which is a straightforward Text Processing library that I've already used in the past and works really well.","32c67876":"## Libraries","bb30d20f":"This challenge is marked as final project for the [\"How to win a data science competition\"](#https:\/\/www.coursera.org\/learn\/competitive-data-science\/home\/welcome) Coursera course.\n\nIn [this competition](#https:\/\/www.kaggle.com\/c\/competitive-data-science-predict-future-sales) we will work with a challenging time-series dataset consisting of daily sales data, kindly provided by one of the largest Russian software firms, [1C Company](#http:\/\/1c.ru\/eng\/title.htm). They are asking to **predict total sales for every product and store in the next month**. They provide various files with supplemental information, but texts are in Russian.\n\nNames may contain a lot of information about items and shops, and they will surely provide major insight towards creating a model for predicting sales. In order to get the maximum value, in this notebook we will **translate Russian names for items, categories and shops**; we'll remove punctuation and stopwords, find named entities, create new columns with information of interest and generate new files.","0c7c67eb":"<div class=\"alert alert-block alert-warning\">\n    <b>WARNING:<\/b> Translation for item names requires ~2 hours to complete running.\n    <br><em>Executed with MSI PS42 Modern 8RC model.<\/em>\n<\/div>","438ae47e":"## \ud83d\udca1 **Stay tuned for the next part: [In-depth EDA] Predict Future Sales**\n\nAlso, if you have any question or comment to add, please, feel welcome to do so!","e1ba218e":"We have now translated all our datasets! Let's get rid of the names in Russian.","f7c6bc8d":"## Data loading","9263234e":"Alternatively, for detecting cities, one could make use of **Named Entity Recognition** algorithms like the ones incorporated in `spaCy` library, but, as it's shown below, they're mostly unreliable for our task, even though it's one of the most powerful NLP libraries, with industrial strength, excelling at large-scale information processing.","4f222f0c":"# **Predict Future Sales**\n## *Translation\/Text Processing*","cb5dbc85":"Awesome! \u2728 Let's save the results.","c186543f":"## Saving files","af2d3a21":"### Tasks covered\n- [x] Process Russian texts and create new variables\n- [ ] Perform some EDA and data mining for deeper understanding, and prepare data\n- [ ] Create model and evaluate results\n\n### Content\n* [Libraries](#Libraries).\n* [Data loading](#Data-loading).\n* [Translation](#Translation).\n* [Preprocessing](#Preprocessing).\n    + [Categories](#Categories).\n    + [Shops](#Shops).\n    + [Items](#Items).\n* [Saving files](#Saving-files).","beb20371":"### Categories","86ea5bd7":"We'll also normalise names by putting them in lowercase format, as they differ in some categories; we'll leave only alphanumeric characters and spaces; and we'll also manually correct two categories. Lastly, we'll create temporal variable IDs for these new groups with Label Encoding.","13680d7a":"### Shops"}}