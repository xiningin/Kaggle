{"cell_type":{"4ebe2112":"code","872fd6f7":"code","9354c724":"code","b3a24f57":"code","7cf513a1":"code","bdb07a98":"code","933e814d":"code","495bea7c":"code","fa419e1f":"code","47051209":"code","ad344064":"code","943bfa64":"markdown","dbb8457a":"markdown","847fa1a0":"markdown","51568a5b":"markdown","4ee3e24a":"markdown","15fe55f7":"markdown","3d6a3be1":"markdown","d1aa614c":"markdown","cd7f6ae2":"markdown"},"source":{"4ebe2112":"!pip uninstall opencv-python -y\n#downgrade OpenCV a bit since some none-free features are not avilable\n!pip install opencv-contrib-python==3.4.2.17 --force-reinstall","872fd6f7":"#import libraries \nimport os\nimport cv2\nimport matplotlib.pyplot as plt\nimport re\nfrom sklearn.cluster import DBSCAN  # For DBSCAN\nimport numpy as np\n%matplotlib inline\n\nimage_paths=[] #List to store path of all images\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        if '.txt' in filename:\n            continue\n        image_paths.append(os.path.join(dirname, filename))","9354c724":"original_images=[]\ntampered_images=[]\n\nfor path in image_paths:\n    \n    if 'tamp' in path:              # As Observed from the above list tampered images name has tamp\n        tampered_images.append(path)\n    else:\n        original_images.append(path)\ntampered_images.sort()\noriginal_images.sort()\nprint(len(original_images),len(tampered_images))","b3a24f57":"def plot_image(img,size=(8,8)):\n    plt.figure(figsize = size)\n    plt.imshow(cv2.cvtColor(img,cv2.COLOR_BGR2RGB)) #Since opencv store images as BGR\n\ndef siftDetector(img):\n    sift = cv2.xfeatures2d.SIFT_create()\n    gray= cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) \n    key_points, descriptors = sift.detectAndCompute(gray, None)\n    return key_points,descriptors\n\ndef get_original(tampered):\n    name=re.findall(r'.*\/(.*)tamp.*',tampered)\n    original_index=-1\n    if len(name)<1:\n        return -1\n    for index,names in enumerate(original_images):\n        if name[0] in names:\n            original_index=index\n            break\n            \n    if original_index==-1:\n        return original_index,-1\n    else:\n        image=cv2.imread(original_images[original_index])\n        return image,original_index\n\ndef show_sift_features(color_img, kp,size=(8,8)):\n    gray_img=cv2.cvtColor(color_img,cv2.COLOR_BGR2GRAY)\n    plt.figure(figsize = size)\n    plt.imshow(cv2.drawKeypoints(gray_img, kp, color_img.copy()))","7cf513a1":"tampered1=cv2.imread(tampered_images[0])\nplot_image(tampered1)","bdb07a98":"original1 , index=get_original(tampered_images[0])\nif index!=-1:\n    plot_image(original1)","933e814d":"def make_clusters(de,eps=40,min_sample=2):\n    clustering = DBSCAN(eps=eps, min_samples=min_sample).fit(de)\n    return clustering\n\ndef locate_forgery(img,clustering,kps):\n    forgery=img.copy()\n    clusters = [[] for i in range(np.unique(clustering.labels_).shape[0]-1)]\n    for idx in range(len(kps)):\n        if clustering.labels_[idx]!=-1:\n            clusters[clustering.labels_[idx]].append((int(kps[idx].pt[0]),int(kps[idx].pt[1])))\n    for points in clusters:\n        if len(points)>1:\n            for idx1 in range(len(points)):\n                for idx2 in range(idx1+1,len(points)):\n                    cv2.line(forgery,points[idx2],points[idx1],(255,0,0),5)\n    plot_image(forgery)","495bea7c":"#Firs let us extract SIFT features\nkey_points,descriptors=siftDetector(tampered1)\nshow_sift_features(tampered1,key_points)","fa419e1f":"#Now Let's make clusters and locate forgery\n\nclusters=make_clusters(descriptors)\nlocate_forgery(tampered1,clusters,key_points)","47051209":"tampered=cv2.imread(tampered_images[20])\nkey_points,descriptors=siftDetector(tampered)\nclusters=make_clusters(descriptors)\nlocate_forgery(tampered,clusters,key_points)\n\n# Change Eps parameter to mark more\/less features\nclusters=make_clusters(descriptors,eps=80)\nlocate_forgery(tampered,clusters,key_points)","ad344064":"tampered=cv2.imread(tampered_images[50])\nkey_points,descriptors=siftDetector(tampered)\nclusters=make_clusters(descriptors)\nlocate_forgery(tampered,clusters,key_points)\n\n# Change Eps parameter to mark more\/less features\nclusters=make_clusters(descriptors,eps=80)\nlocate_forgery(tampered,clusters,key_points)","943bfa64":"## Some other examples and the role of eps","dbb8457a":"## Dividing Into Tampered and Original\nHere, I have divided image lists into tampered and original to use later.","847fa1a0":"## Why this approach works?\nThis approach works well because of the scale invariance nature of SIFT and the clustering power of the DBSCAN algorithm.\n\nSince the extracted features of the forged region should be similar to that of the original region so it is highly probable that they will be very close in the feature space and thus will be clustered together and this is the idea behind the above implementation.\n","51568a5b":"This is an implementation to detect Copy move forgery detection using DBSCAN clustering to give you an idea for how to work with forgery detection using OpenCV and sklearn. This technique can be used to detect a forgery in many cases. However, the detection accuracy is not the best and can be improved further by other techniques.","4ee3e24a":"## About Dataset\nThe dataset used is taken from here [MICC](http:\/\/http:\/\/lci.micc.unifi.it\/labd\/2015\/01\/copy-move-forgery-detection-and-localization\/) (\"I. Amerini, L. Ballan, R. Caldelli, A. Del Bimbo, G. Serra. \u201cA SIFT-based forensic method for copy-move attack detection and transformation recovery\u201d, IEEE Transactions on Information Forensics and Security, vol. 6, issue 3, pp. 1099-1110, 2011.\")\n\nI have used MICC-F220 version which is composed of around 220 images; 110 are tampered and 110 originals.\n\n\n","15fe55f7":"## DBSCAN Clustering\nIt is a density-based clustering non-parametric algorithm: given a set of points in some space, it groups together points that are closely packed together (points with many nearby neighbors), marking as outliers points that lie alone in low-density regions (whose nearest neighbors are too far away).\nThe DBSCAN algorithm basically requires 2 parameters:\n* **eps:** specifies how close points should be to each other to be considered a part of a cluster. It means that if the distance between two points is lower or equal to this value (eps), these points are considered neighbors.\n* **minPoints:** the minimum number of points to form a dense region. For example, if we set the minPoints parameter as 5, then we need at least 5 points to form a dense region.\n\nNow, I have defined two functions for making clusters and detection of forgery using those clusters.\n* make_clusters(de,eps,min_sample): This function will perform DBSCAN clustering and the role of parameters (eps,min_sample) is described above, it take another parameter which is de which is basically SIFT descriptor of the image.\n* locate_forgery(img,clustering,kps): This function takes the image clusters made and the SIFT keypoints to mark the forgery on the image. It does so by drawing lines between points classified into the same clusters.\n","3d6a3be1":"Let's check if we are able to detect forgery.","d1aa614c":"## How to use cv2.xfeatures2d.SIFT_create() ?\nSIFT features extraction is moved from OpenCV as SIFT is patented. I have downgraded OpenCV to use SIFT function in opencv.","cd7f6ae2":"## Helper Functions\n\n* **plot_image(img,size=(30,30))**: For plotting image.\n* **siftDetector(img)**: For extracting SIFT features and descriptors.\n* **get_original(tampered)**: Give the index of original image with the original image from the name of tampered image if present otherwise return -1.\n* **show_sift_features(color_img, kp,size=(30,30),flag=None)**:  It marks the extracted features on the image and parameters are the image itself, kp are the SIFT keypoints and."}}