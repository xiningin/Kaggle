{"cell_type":{"25445b14":"code","2186be98":"code","10c629d9":"code","e66ba797":"code","4be76932":"code","7deae22a":"code","5b74c8dd":"code","71271bea":"code","069c7279":"markdown","170eaa7d":"markdown","1d26dfbe":"markdown","cb04ef36":"markdown","2829b147":"markdown","b611d413":"markdown","a3d0e65e":"markdown","9a94dcf8":"markdown"},"source":{"25445b14":"import numpy as np\nimport matplotlib.pyplot as plt","2186be98":"# Refactored Code\n# ===================================\ndef get_mesh_grid_for_plt(plt, n_pts, subplot=False):\n    \"\"\"\n    Returns 2-D grid of x, y points corresponding\n    to meshgrid (scale of gdrid must be predefiend)\n    \n    :param plt: matplotlib pyplot\n    :param n_pts: tuple of (n_xpts, n_ypts) reprsenting 2-D grid\n    \n    TIME: O(N^2)\n    \"\"\"\n    # get lims (need to be set by user)\n    if not subplot:\n        xl, xr = plt.xlim()\n        yb, yt = plt.ylim()\n    else: # deal w\/ axesplots\n        xl, xr, yb, yt = plt.axis()\n    \n    # gen data using lims\n    # -------------------------\n    num_xpts, num_ypts = n_pts\n    # -------------------------\n    grid_xs = []\n    grid_ys = []\n    for x in np.linspace(xl, xr, num_xpts):\n        # for every x, gen ys\n        for y in np.linspace(yb, yt, num_ypts):\n            grid_xs.append(x)\n            grid_ys.append(y)    \n            \n    return (np.array(grid_xs), np.array(grid_ys))","10c629d9":"fig = plt.figure(figsize=(10,6))\n\nn_xpts, n_ypts = 30, 30\ngrid_xs, grid_ys = get_mesh_grid_for_plt(plt, (n_xpts, n_ypts))\n\n# plot data\nplt.scatter(grid_xs, grid_ys)\nplt.show()","e66ba797":"fig = plt.figure(figsize=(10,6))\n\nn_xpts, n_ypts = 100, 100\ngrid_xs, grid_ys = get_mesh_grid_for_plt(plt, (n_xpts, n_ypts))\n\n# plot data\nplt.scatter(grid_xs, grid_ys)\nplt.show()","4be76932":"def get_random_wts(size):\n    \"\"\" uniform [-1, 1]\"\"\"\n    return np.random.uniform(-1, 1, size=size)","7deae22a":"fig = plt.figure(figsize=(10,6))\n\n# predefine scale limits\nplt.xlim(left=-1, right=1)\nplt.ylim(bottom=-1, top=1)\n\n# setup meshgrid: get coordinates of 2D grid\nn_xpts, n_ypts = 300, 300\ngrid_xs, grid_ys = get_mesh_grid_for_plt(plt, (n_xpts, n_ypts))\n\n# ========================================================\n# computed color using direction of W\u2022X \n# (no intercept i.e origin-centered)\nw0, w1 = get_random_wts(2)\nWX = grid_xs*w0 + grid_ys*w1 # W\u2022X\ncolors = np.where(WX>=0, 'purple', 'grey')\n# =========================================================\n\n# plot data ---------------------------\nplt.scatter(grid_xs, grid_ys, c=colors)\n# -------------------------------------\n# sanity check check equation\nxs = np.linspace(-1, 1, 10)\nys = -(w0\/w1) * xs\nplt.plot(xs, ys, c='yellow')\n\nplt.show()","5b74c8dd":"fig, axarr = plt.subplots(4, 4, figsize=(20, 10))\naxarr = axarr.reshape(-1)\n\nfor ax in axarr:\n\n    # predefine scale limits\n    ax.axis(xmin=-1, xmax=1, ymin=-1, ymax=1)    \n\n    # setup meshgrid: get coordinates of 2D grid\n    n_xpts, n_ypts = 30, 30\n    grid_xs, grid_ys = get_mesh_grid_for_plt(ax, (n_xpts, n_ypts), subplot=True)\n\n    # ========================================================\n    # computed color using direction of W\u2022X \n    # (no intercept i.e origin-centered)\n    w0, w1 = get_random_wts(2)\n    WX = grid_xs*w0 + grid_ys*w1 # W\u2022X\n    colors = np.where(WX>=0, 'purple', 'grey')\n    # =========================================================\n\n    # plot data ---------------------------\n    ax.scatter(grid_xs, grid_ys, c=colors)\n    # -------------------------------------\n    # sanity check check equation\n    xs = np.linspace(-1, 1, 10)\n    ys = -(w0\/w1) * xs\n    ax.plot(xs, ys, c='yellow')\n\nplt.show()","71271bea":"NUM_RANDOM_LINES = 100\n\nfig = plt.figure(figsize=(10,6))\n\n# predefine scale limits\nplt.xlim(left=-1, right=1)\nplt.ylim(bottom=-1, top=1)\n\nxs = np.linspace(-1, 1, 10)\nfor _ in range(NUM_RANDOM_LINES):\n    w0, w1 = get_random_wts(2)\n    ys = -(w0\/w1) * xs\n    plt.plot(xs, ys, c='yellow')\n\nplt.show()","069c7279":"> # $$W^T\\cdot X + B = 0$$ \n> ### $$\\text{where} \\,\\,B=0\\,\\, \\text{i.e origin centered}$$ \n\n- **Yellow:** $y = mx + c$ where $c=0$ (origin centered). Note that \n\n> #### $$w_0*x_0 + w_1*x_1 = 0$$\n> #### $$x_1 = -\\frac{w_0}{w1} x_0$$\n\n- **Purple:** Positive direction\n\n> #### $$w_0*x_0 + w_1*x_1 > 0$$\n\n- **Grey:** Negative direction \n\n> #### $$w_0*x_0 + w_1*x_1 < 0$$\n","170eaa7d":"### **NOTE: `np.meshgrid`** is optimal to [use](https:\/\/numpy.org\/doc\/stable\/reference\/generated\/numpy.meshgrid.html)","1d26dfbe":"**small number of pts** \n\n```\nnum_xpts = 30\nnum_ypts = 30\n```","cb04ef36":"**large number of pts** \n\n```\nnum_xpts = 100\nnum_ypts = 100\n```","2829b147":"> <i><b>weights<\/b> are analogous to <b>components of <b><\/i>","b611d413":"# Sample Random Planes","a3d0e65e":"**Mesh Grid** (Raw implementation)","9a94dcf8":"**Plot `100` random lines**"}}