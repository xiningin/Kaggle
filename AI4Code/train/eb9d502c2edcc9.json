{"cell_type":{"716fc989":"code","c4ea4c2a":"code","4fd5e9bf":"code","d2445b9c":"code","9d46755a":"code","b7c063ce":"code","96fab683":"code","c1794d3f":"code","da885cad":"markdown","27f94303":"markdown","599d07c9":"markdown","99e85aad":"markdown","263ee7dd":"markdown","372b834d":"markdown"},"source":{"716fc989":"\n\nimport numpy as np \nimport pandas as pd \n\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nfrom PIL import Image  \nfrom IPython.display import display \n\nimport os\nimport datetime","c4ea4c2a":"ROOT_PATH = '\/kaggle\/input\/hpa-single-cell-image-classification\/'\n\nCHANNELS = np.array(['red', 'green', 'blue', 'yellow'])\n\nCHANNEL_SIZE = len(CHANNELS)\nSAMPLE_SIZE = 40","4fd5e9bf":"def get_images(id):\n    images = list()\n    for channel in CHANNELS:\n        path = ROOT_PATH + 'train\/{}_{}.png'.format(id, channel)\n        image = Image.open(path) \n        images.append(image)\n    return images","d2445b9c":"df_train = pd.read_csv(ROOT_PATH + 'train.csv')\nprint(\"Trainning data length: {}\".format(len(df_train)))\ndf_train.head()","9d46755a":"# if sample size is set then reduce trainning set accordingly\nif SAMPLE_SIZE > -1:\n    df_train = df_train.sample(SAMPLE_SIZE)\n    df_train.reset_index(inplace=True);","b7c063ce":"images = get_images( df_train.loc[df_train.index[0], 'ID'] )\n\n# zeros array to fill in missing RGB channels\nsize = np.shape(images[0])[0]\nzeros = np.zeros((size, size))\n\n# Create arrays for each image with 3 channels \nred_array = np.stack((images[0], zeros, zeros), 2)\ngreen_array = np.stack((zeros, images[1], zeros), 2)\nblue_array = np.stack((zeros, zeros, images[2]), 2)\n# Place yellow across both red and green channels\nyellow_array = np.stack((images[3], images[3], zeros), 2)\n\n# Convert to image\nred_image = Image.fromarray( np.uint8(red_array) )\ngreen_image = Image.fromarray( np.uint8(green_array) )\nblue_image = Image.fromarray( np.uint8(blue_array) )\nyellow_image = Image.fromarray( np.uint8(yellow_array) )\n\n# Plot what we have so far\nfig = plt.figure(figsize=(25,25))\nax = fig.add_subplot(1, CHANNEL_SIZE, 1)\nax.set_title(\"Red\")\nplt.imshow(np.asarray(red_image))\n\nax = fig.add_subplot(1, CHANNEL_SIZE, 2)\nax.set_title(\"Green\")\nplt.imshow(np.asarray(green_image))\n\nax = fig.add_subplot(1, CHANNEL_SIZE, 3)\nax.set_title(\"Blue\")\nplt.imshow(np.asarray(blue_image))\n\nax = fig.add_subplot(1, CHANNEL_SIZE, 4)\nax.set_title(\"Yellow\")\nplt.imshow(np.asarray(yellow_image))\n\n# Copy over yellow into red and blue taking the max value of each pixel between the two\n# Red \/ Yellow\nred_yellow_array = np.maximum(red_array, yellow_array)\nred_yellow_image = Image.fromarray( np.uint8(red_yellow_array) )\nax = fig.add_subplot(2, CHANNEL_SIZE, 5)\nax.set_title(\"Red \/ Yellow\")\nplt.imshow(np.asarray(red_yellow_image))\n\n# Green \/ Yellow\ngreen_yellow_array = np.maximum(green_array, yellow_array)\ngreen_yellow_image = Image.fromarray( np.uint8(green_yellow_array) )\nax = fig.add_subplot(2, CHANNEL_SIZE, 6)\nax.set_title(\"Green \/ Yellow\")\nplt.imshow(np.asarray(green_yellow_image))\n\n# Final solution to blend RGBY into RGB\nblended_array = np.stack((\n        np.maximum(images[0], images[3]),\n        np.maximum(images[1], images[3]),\n        images[2]\n    ), 2)\nblended_image = Image.fromarray( np.uint8(blended_array) )\nax = fig.add_subplot(2, CHANNEL_SIZE, 7)\nax.set_title(\"Final\")\nplt.imshow(np.asarray(blended_image))\n","96fab683":"def plot_blended_image(df_samples):\n    \n    fig = plt.figure(figsize=(25,2*len(df_samples)))\n    index = 1\n    \n    for sample_index, sample in df_samples.iterrows():\n\n        # get rgby images for sample\n        images = get_images(sample['ID'])\n        \n        # blend rgby images into single array\n        blended_array = np.stack((\n                np.maximum(images[0], images[3]),\n                np.maximum(images[1], images[3]),\n                images[2]\n            ), 2)\n        blended_image = Image.fromarray( np.uint8(blended_array) )\n        \n        # plot\n        ax = fig.add_subplot(len(df_samples) \/\/ 4 + 1, 4, index)\n        plt.imshow(np.asarray(blended_image))\n\n        index = index + 1","c1794d3f":"plot_blended_image(df_train)","da885cad":"# Purpose\n\nI used this notebook to work out a stratgey to blend the 4 red, green, blue and yellow images into a single image with Pillow.","27f94303":"# Final Solution\nPlot blended images for sampled images","599d07c9":"## Read Training Data","99e85aad":"## Parameters","263ee7dd":"# Get Images\nReturn array of images for all channels","372b834d":"# Exploration\n\nSome exploration to get to a final solution to blend images"}}