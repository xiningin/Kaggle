{"cell_type":{"99cb8fd1":"code","308b6aed":"code","10348662":"code","27961b04":"code","682b0822":"code","6c470b6a":"code","5c763651":"code","b0e47b20":"code","5442aa92":"code","7ce6b3a9":"code","c89a5df4":"code","a2646846":"code","a28ef682":"code","02d87cd8":"code","3ad31207":"code","98a61890":"code","b4a15ebf":"code","7b7d51e3":"code","e19d9826":"code","4b4a734a":"code","edc43578":"code","7609c8cc":"code","9728145b":"code","dd4b8a80":"code","2e4100c8":"code","b34d52c2":"code","c54ecb07":"code","ac77b0f4":"code","52b5e236":"code","da41aec5":"code","1ddfed2e":"code","dc0e5f1e":"code","c6cc0071":"code","ac258289":"code","2d04d7a0":"code","120bba59":"code","df0b9e01":"code","febf6898":"code","c939af7d":"code","98b3bb33":"markdown","42e8c9fd":"markdown","22afa334":"markdown"},"source":{"99cb8fd1":"!pip install uncertainties\n!pip install openpyxl\n\n# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport uncertainties as unc  \nimport uncertainties.unumpy as unumpy  \nimport uncertainties.umath as umath\nfrom uncertainties import ufloat\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import curve_fit \nimport scipy.optimize as optimize\nfrom scipy import stats\nimport statsmodels.api as sm\nimport math \n\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","308b6aed":"data_trial1 = pd.read_excel(\"\/kaggle\/input\/42-grams-trial-1\/42grams_trial_1.xlsx\")\ndata_trial1 = data_trial1.dropna()     #drop all rows that have any NaN values","10348662":"print(data_trial1)","27961b04":"# Initialized the data \nt = data_trial1[\"t\"].tolist()\nx = data_trial1[\"x\"].tolist()\ny = data_trial1[\"y\"].tolist()","682b0822":"# Reset the Errors\nerr_t = np.array([])\nerr_x = np.array([])\nerr_y = np.array([])","6c470b6a":"err_t = np.array([(0.0001) for i in t])\n# x_error: quarter of the diameter\nerr_x = np.array([(0.015\/4\/2) for i in x])\n# y_error: half the length of the sum of all washeres\nerr_y = np.array([(0.015\/4\/2) for i in y])\n","5c763651":"# Convert to unumpy array for easy error propagation\nt = unumpy.uarray(t, err_t)\nx = unumpy.uarray(x, err_x)\ny = unumpy.uarray(y, err_y)\n\nprint(\"#of Data Points:\", len(t))","b0e47b20":"string_length = ufloat(0.321,0.001)\nprint(type(string_length))\nfor i in range(0, len(y)):\n    y[i]+=string_length","5442aa92":"theta_normal = np.array([])\ntheta_error = np.array([])\nfor i in range(0, len(x)):\n    temp_theta = umath.atan(x[i]\/y[i])\n    theta_normal = np.append(theta_normal,np.array([temp_theta.n+0.005]))\n    theta_error = np.append(theta_error,np.array([temp_theta.s]))\n\n# Convert to unumpy array for easy error propagation\ntheta = unumpy.uarray(theta_normal, theta_error)","7ce6b3a9":"dict = {'t': t, 'x': x, 'y': y, 'theta': theta}\nprint(dict)","c89a5df4":"def plot(arr_x,arr_y,name,skip=1, x_min = 0, x_max = 110):\n    '''\n    Plot graph of two unumpy arrays\n    '''\n    plt.rcParams.update({'font.size': 40})\n    display_x = np.array([arr_x[i].nominal_value for i in range(0,len(arr_x),skip)])\n    display_y = np.array([arr_y[i].nominal_value for i in range(0,len(arr_y),skip)])\n    x_err = np.array([arr_x[i].std_dev for i in range(0,len(arr_x),skip)])\n    y_err = np.array([arr_y[i].std_dev for i in range(0,len(arr_y),skip)])\n    \n    plt.figure(figsize=(40,20))\n    plt.errorbar(display_x, display_y, yerr=y_err, xerr=x_err, fmt='o', ecolor=\"red\", ms=5, label=\"Recorded Angles With Error Bar\")\n    plt.title(name)\n    plt.xlabel(\"Time Elapsed (s)\")\n    plt.ylabel(\"Angle (radians)\")\n    plt.legend(loc=\"upper right\")\n    plt.xlim([x_min,x_max])\n    # plt.savefig(title, dpi=300)","a2646846":"plot(t[:500],theta[:500],\"Angle vs. Time for First 500 Angles\", x_min = 0, x_max = 17.5)","a28ef682":"plot(t,theta,\"Angle vs. Time\", x_min = 0, x_max = 230)","02d87cd8":"max_points = []\nmax_points_t = []\nerr_max_points = []\nerr_max_points_t = []\n\nlast_max = -99\n\nfor i in np.arange(0,6750):\n    \n    # Conditions to be met\n    local_max_from_left = theta[i] > theta[i-2] > theta[i-4] \n    local_max_from_right = theta[i] > theta[i+2] > theta[i+4]\n    positive = theta[i] > 0\n    ball_park_time = t[i]-last_max > 2\n    \n    # If conditions are met\n    if local_max_from_left and local_max_from_right and positive and ball_park_time:\n    \n        max_points.append(theta[i].nominal_value)\n        max_points_t.append(t[i].nominal_value)\n        err_max_points.append(theta[i].std_dev)\n        err_max_points_t.append(t[i].std_dev)\n\nmax_points_t = np.asarray(max_points_t, dtype=np.float32)\nmax_points = np.asarray(max_points, dtype=np.float32)\nerr_max_points_t = np.asarray(err_max_points_t, dtype=np.float32)\nerr_max_points = np.asarray(err_max_points, dtype=np.float32)\n\n# Convert to unumpy array for easy error propagation\nmax_points_t = unumpy.uarray(max_points_t, err_max_points_t)\nmax_points = unumpy.uarray(max_points, err_max_points)\nprint(\"Oscillation: \",len(max_points))\nplot(max_points_t,max_points,name = \"Amplitude vs. Time\", x_min = 0, x_max = 230)\npercentage_of_amplitude_left = max_points[-1]\/max_points[0]\nprint(\"The persentage of the amplitude left:\", percentage_of_amplitude_left*100 ,\"%\")\n","3ad31207":"Q_n = (-math.pi)\/unumpy.log(percentage_of_amplitude_left )\nprint(Q_n)\nQ_by_counting = len(max_points)*Q_n \nprint(Q_by_counting)","98a61890":"# Guesses\namplitude_tau = ufloat(131.726793,0)\namplitude_a = ufloat(0.36254742,0)\nfigure_w = ufloat(2.361,0)\nfigure_phi = ufloat(0,0)\n\ndef unumpy_to_np(unumpy_arr):\n    '''\n    Helper function to unpack a unumpy array\n    '''\n    nominal_values = np.array([unumpy_arr[i].nominal_value for i in range(0,len(unumpy_arr))])\n    errors = np.array([unumpy_arr[i].std_dev for i in range(0,len(unumpy_arr))])\n    return nominal_values, errors\n\ndef amplitude_linear_drag(t, a, tau): \n    return a*np.exp(-t\/tau)\n\nN = 2\ndef fit_amplitude_to_f(t_points,theta_points):\n    global amplitude_tau, amplitude_a\n    \n    '''\n    PART ONE: GENERATE GRAPH\n    '''\n    temp_t_points, t_err = unumpy_to_np(t_points)\n    temp_theta_points, theta_err = unumpy_to_np(unumpy.log(theta_points))\n    \n    # Get Parameters\n    slope, intercept, r_value, p_value, std_err = stats.linregress(temp_t_points,temp_theta_points)\n    # Fitting Function\n    theta_fit = intercept+slope*temp_t_points\n\n    theta_fit_not_t = np.array([])\n    theta_fit_not = np.array([])\n    theta_fit_not_theta_err  = np.array([])\n    theta_fit_not_t_err = np.array([])\n    \n    theta_fit_yes_t = np.array([]) \n    theta_fit_yes = np.array([]) \n    theta_fit_yes_theta_err  = np.array([])\n    theta_fit_yes_t_err = np.array([])\n    for i in range(len(temp_theta_points)):\n        if abs(np.exp(-np.pi\/N)*max(theta_points)-np.exp(temp_theta_points[i])) < 0.005:\n            theta_fit_not = np.append(theta_fit_not, temp_theta_points[i])\n            theta_fit_not_t = np.append(theta_fit_not_t, temp_t_points[i])\n            theta_fit_not_theta_err = np.append(theta_fit_not_theta_err, theta_err[i])\n            theta_fit_not_t_err = np.append(theta_fit_not_t_err, t_err[i])\n\n        else:\n            theta_fit_yes = np.append(theta_fit_yes, temp_theta_points[i])\n            theta_fit_yes_t = np.append(theta_fit_yes_t, temp_t_points[i])\n            theta_fit_yes_theta_err = np.append(theta_fit_yes_theta_err, theta_err[i])\n            theta_fit_yes_t_err = np.append(theta_fit_yes_t_err, t_err[i])\n\n    print(len(theta_fit_not_t),len(theta_fit_not))\n    # Plot\n    plt.figure(figsize=(40,20))\n    plt.xlabel(\"Time Elapsed (s)\")\n    plt.ylabel(\"Natural Logarithm of Angle\")\n    plt.errorbar(theta_fit_yes_t, theta_fit_yes, yerr=theta_fit_yes_theta_err, xerr=theta_fit_yes_t_err, color=\"xkcd:lightish blue\", fmt='o', ms=5, label=\"Amplitudes\")\n    plt.errorbar(theta_fit_not_t, theta_fit_not, yerr=theta_fit_not_theta_err, xerr=theta_fit_not_t_err, color=\"red\", fmt='o', ms=5, label=\"21 +\/- 0.5% Mark\")\n    plt.plot(temp_t_points, theta_fit, label=\"Exponential Fit\", linewidth=5, color=\"xkcd:dark purple\")\n    plt.title(\"The Exponential Fit of The Amplitutes\")\n    plt.legend()\n    # plt.savefig(\"figures\/amplitude-vs-time-fitted\", dpi=300)\n\n    \n    '''\n    PART TWO: GET PARAMATER UNCERTAINTIES\n    '''\n\n    z, cov = np.polyfit(temp_t_points, temp_theta_points, 1, cov=True)\n    \n    slope = ufloat(-z[0],cov[0,0]**0.5)\n    amplitude_tau = 1\/slope\n    \n    intercept = ufloat(z[1],cov[1,1]**0.5)\n    amplitude_a = unumpy.exp(intercept)\n    print(\"R^2: \",r_value**2)\n\n# Call the Function\nfit_amplitude_to_f(max_points_t, max_points)","b4a15ebf":"def sine_linear_drag(t, w, phi): \n    a = abs(amplitude_a).n\n    tau = abs(amplitude_tau).n\n    return a*np.exp(-t\/tau)*np.cos(w*t+phi)\n\ndef fit_curve_to_f(f,t_points,theta_points):\n    global figure_w, figure_phi\n\n    temp_t_points, t_err = unumpy_to_np(t_points)\n    temp_theta_points, theta_err = unumpy_to_np(theta_points)\n    \n    # Get Parameters\n    param, param_cov = curve_fit(f, temp_t_points, temp_theta_points, p0=[1,1], maxfev=10000)\n    \n    # Parameter Uncertainties\n    u_w = param_cov[0,0]**0.5\n    u_phi = param_cov[1,1]**0.5\n\n    # Fited Function\n    theta_fit = f(temp_t_points, param[0], param[1])\n\n    figure_w = ufloat(param[0],u_w)\n    figure_phi = ufloat(param[1],u_phi)\n\nfit_curve_to_f(sine_linear_drag, t, theta)","7b7d51e3":"print(\"Tau:  \", amplitude_tau)\nprint(\"a:    \", amplitude_a)\nprint(\"T:    \", figure_w)\nprint(\"phi:  \", figure_phi)","e19d9826":"def plot_residual(f, t_points,theta_points, x_min = 0, x_max = 110):\n    temp_t_points, t_err = unumpy_to_np(t_points)\n    temp_theta_points, theta_err = unumpy_to_np(theta_points)\n    \n    # Get Parameters\n    param, param_cov = curve_fit(sine_linear_drag, temp_t_points, temp_theta_points, p0=[2.4,0], absolute_sigma=True, maxfev=10000)\n    \n    # Curve Fit\n    theta_fit = f(temp_t_points, param[0], param[1])\n\n    plt.figure(figsize=(40,20))\n    plt.errorbar(temp_t_points, temp_theta_points, yerr=theta_err, xerr=t_err,\n                 fmt='o', color=\"xkcd:lightish blue\", ecolor=\"salmon\", ms=4, label=\"Recorded Angles With Error Bar\")\n    plt.xlabel(\"Time Elapsed (s)\")\n    plt.ylabel(\"Angle (radians)\")\n    plt.title(\"Amplitute vs. Time Elapsed (Including Residual)\")\n    plt.xlim([x_min,x_max])\n    plt.errorbar(temp_t_points, temp_theta_points-theta_fit, yerr=theta_err, xerr=t_err, color=\"black\",\n                 fmt='o', ms=1, label=\"Residuals\")\n    plt.legend()\n    # plt.savefig(\"figures\/lin-residual-vs-time\", dpi=300)\n\nplot_residual(sine_linear_drag, t[:5000], theta[:5000], x_max = 150)\n","4b4a734a":"period = 2*np.pi\/figure_w\n\nprint(\"Q1: \",np.pi*amplitude_tau\/period)\n\nN = 2\ntheta0 = max_points[0]\n\npossible_values = [max_points_t[i] for i in range(len(max_points)) if (abs(np.exp(-np.pi\/N)*theta0-max_points[i])<0.003)]\n\nq2_min = N*min(possible_values)\/period\nq2_max = N*max(possible_values)\/period\nprint(\"Q2 min: \",q2_min)\nprint(\"Q2 max: \",q2_max)\n\nq2_avg = ((q2_min+q2_max)\/2).n\nq2_u = ((q2_max-q2_min)\/2).n\nprint(\"Q2 average: \",ufloat(q2_avg,q2_u))\n\n# Find weighted average:\nprint(\"Q weighted average:\",0.5*(ufloat(q2_avg,q2_u)+np.pi*amplitude_tau\/period))","edc43578":"xdata = np.array([])\nydata = np.array([])\nxerror = np.array([])\nyerror = np.array([])\nfor i in range(0, len(t)):\n    xdata = np.append(xdata, np.array([t[i].n]))\n    ydata = np.append(ydata, np.array([theta[i].n]))\n    xerror = np.append(xerror, np.array([t[i].s]))\n    yerror = np.append(yerror, np.array([theta[i].s]))\nprint(len(t), len(theta), len(xdata), len(ydata), len(xerror), len(yerror))","7609c8cc":"# finished importing data, naming it sensibly\n\ndef my_func(t, a, tau, T, phi):\n    return a * np.exp(-t \/ tau) * np.cos(2 * np.pi * t \/ T + phi)\n\n\n# this is the function we want to fit. the first variable must be the\n# x-data (time), the rest are the unknown constants we want to determine","9728145b":"init_guess = (1, 1, 1, 1)\n# your initial guess of (a,tau,T,phi)\n\npopt, pcov = curve_fit(my_func, xdata, ydata, p0=init_guess, maxfev=10000)\n# we have the best fit values in popt[], while pcov[] tells us the uncertainties","dd4b8a80":"a = popt[0]\ntau = popt[1]\nT = popt[2]\nphi = popt[3]\n# best fit values are named nicely\nu_a = pcov[0, 0] ** (0.5)\nu_tau = pcov[1, 1] ** (0.5)\nu_T = pcov[2, 2] ** (0.5)\nu_phi = pcov[3, 3] ** (0.5)\n# uncertainties of fit are named nicely","2e4100c8":"def fitfunction(t):\n    return a * np.exp(-t \/ tau) * np.cos(2 * np.pi * t \/ T + phi)\n\n\n# fitfunction(t) gives you your ideal fitted function, i.e. the line of best fit","b34d52c2":"start = min(xdata)\nstop = max(xdata)\nxs = np.arange(start, stop, (stop - start) \/ 1000)  # fit line has 1000 points\ncurve = fitfunction(xs)\n# (xs,curve) is the line of best fit for the data in (xdata,ydata) ","c54ecb07":"fig,(ax1, ax2) = plt.subplots(2, 1, figsize=(30,30))\nfig.subplots_adjust(hspace=0.6)\n# hspace is horizontal space between the graphs\nax1.errorbar(xdata, ydata, yerr=yerror, xerr=xerror, fmt=\".\")\n# plot the data, fmt makes it data points not a line\nax1.plot(xs, curve)\n# plot the best fit curve on top of the data points as a line\nax1.set_xlabel(\"Time(s)\", fontsize=30)\nax1.set_ylabel(\"Angle(radians)\", fontsize=30)\nax1.set_title(\"Angle vs Time (Including Line of Best Fit)\", fontsize=30)\nax1.tick_params(axis='x', labelsize=30 )\nax1.tick_params(axis='y', labelsize=30 )\nax1.set_xlim([0,110])\nax1.legend([\"Best Fit Line\", \"Angle Data with Error Bar\"])\n# HERE is where you change how your graph is labelled\n\n\n\na_with_err = ufloat(a, u_a)\ntau_with_err = ufloat(tau, u_tau)\nT_with_err = ufloat(T, u_T)\nphi_with_err = ufloat(phi, u_phi)\nprint(\"A:\", a_with_err)\nprint(\"tau:\", tau_with_err)\nprint(\"T:\", T_with_err)\nprint(\"phi:\", phi_with_err)\nQ_by_fitting = np.pi*(tau_with_err\/T_with_err)\nprint(\"Q:\", np.pi*(tau_with_err\/T_with_err))\n# prints the various values with uncertainties\n# residual = ydata - fitfunction(xdata)\nresidual = []\nfor i in range(0, len(ydata)):\n    residual.append(ydata[i] - fitfunction(xdata[i]))\n# find the residuals\nzeroliney = [0, 0]\nzerolinex = [start, stop]\n# create the line y=0\nax2.errorbar(xdata, residual, yerr=yerror, xerr=xerror, fmt=\".\")\n# plot the residuals with error bars\nax2.plot(zerolinex, zeroliney)\n# plotnthe y=0 line on top\nax2.set_xlabel(\"time(s)\", fontsize=30)\nax2.set_ylabel(\"Residuals of Best Fitted Function\", fontsize=30)\nax2.set_title(\"Residuals of the fit\", fontsize=30)\nax2.legend([\"Best Fit Line\", \"Angle Data with Error Bar\"])\nax2.tick_params(axis='x', labelsize=30 )\nax2.tick_params(axis='y', labelsize=30 )\nax2.set_xlim([0,110])\n# HERE is where you change how your graph is labelled\nplt.show()\n# show the graph\n","ac77b0f4":"print(Q_by_counting)\nprint(Q_by_fitting)\nprint(((Q_by_counting+(Q_by_fitting)\/2)))","52b5e236":"max_points = []\nmax_points_t = []\nerr_max_points = []\nerr_max_points_t = []\n\nfor i in np.arange(1,len(theta)-1):\n    \n    # Conditions to be met\n    local_max_from_left = theta[i] > theta[i-1]\n    local_max_from_right = theta[i] > theta[i+1]\n    positive = theta[i] > 0\n    local_max = local_max_from_left and local_max_from_right and positive\n\n    # Conditions to be met\n    local_min_from_left = theta[i] < theta[i-1]\n    local_min_from_right = theta[i] < theta[i+1]\n    negative = theta[i] < 0\n    local_min = local_min_from_left and local_min_from_right and negative\n    \n    \n    # If conditions are met\n    if local_max or local_min:\n        max_points.append(theta[i].nominal_value)\n        max_points_t.append(t[i].nominal_value)\n        err_max_points.append(theta[i].std_dev)\n        err_max_points_t.append(t[i].std_dev)\n\nmax_points_t = np.asarray(max_points_t, dtype=np.float32)\nmax_points = np.asarray(max_points, dtype=np.float32)\nerr_max_points_t = np.asarray(err_max_points_t, dtype=np.float32)\nerr_max_points = np.asarray(err_max_points, dtype=np.float32)\n\n# Convert to unumpy array for easy error propagation\nmax_points_t = unumpy.uarray(max_points_t, err_max_points_t)\nmax_points = unumpy.uarray(max_points, err_max_points)\n\nplot(max_points_t,max_points,\"Amplitude vs. Time\", x_max = 230)","da41aec5":"periods = []\nperiods_err = []\namplitudes = []\namplitudes_err = []\n\n\namplitude_range = np.array([min(max_points).n])\ncurrent_angle = min(max_points).n\n\n\nfor i in np.arange(min(max_points).n,max(max_points).n,0.001):\n    if abs(i-current_angle) > 0.015:\n        current_angle = i\n        amplitude_range = np.append(amplitude_range,i)\namplitude_range = np.append(amplitude_range,max(max_points).n)\n\nprint(len(amplitude_range))\nprint(len(max_points))\n\namplitude_midpoints = np.array([])\namplitude_midpoints_err = np.array([])\n\namplitude_bins = np.array([])\n\nfor i in range(len(amplitude_range)-1):\n    current_bin = np.array([])\n    current_amplitude_midpoint = np.array([])\n\n    for amplitude in range(1,len(max_points)):\n        if abs(max_points_t[amplitude]-max_points_t[amplitude-1]) > 0.03:\n            if amplitude_range[i] < max_points[amplitude] < amplitude_range[i+1]:\n                current_bin = np.append(current_bin,max_points_t[amplitude]-max_points_t[amplitude-1])\n                current_amplitude_midpoint = np.append(current_amplitude_midpoint,max_points[amplitude].n)\n\n    if not len(current_bin) == 0:\n        amplitude_bins = np.append(amplitude_bins,sum(current_bin)\/len(current_bin))\n        amplitude_midpoints = np.append(amplitude_midpoints,0.5*(amplitude_range[i]+amplitude_range[i+1]))\n        amplitude_midpoints_err = np.append(amplitude_midpoints_err,max(np.std(current_amplitude_midpoint),0.001))\n\ndisplay_y = np.array([2*amplitude_bins[i].nominal_value for i in range(0,len(amplitude_bins))])\ny_err = np.array([amplitude_bins[i].std_dev for i in range(0,len(amplitude_bins))])\n\nprint(len(display_y))\nprint(len(y_err))","1ddfed2e":"import copy\nmax_points_copy = copy.deepcopy(max_points)\nmax_points_t_copy = copy.deepcopy(max_points_t)\nmax_points_copy = max_points_copy[:-1]\nmax_points_t_copy = max_points_t_copy[:-1]\nprint(len(max_points_copy), len(max_points_t_copy))\n# print(max_points_copy[0:10])\n# print(max_points_t_copy[0:10])\nperiods_n = []\nperiods_s = []\nfor i in range(0, len(max_points_t_copy)-3, 3):\n    periods_n.append(max_points_t_copy[i+2].n - max_points_t_copy[i].n)\n    periods_s.append(max_points_t_copy[i+2].s - max_points_t_copy[i].s)","dc0e5f1e":"params,cov = np.polyfit(amplitude_midpoints, display_y, 2, rcond=None, cov=True, w=1\/y_err)\nparams = params[::-1]\nplt.figure(figsize=(40,20))\nplt.errorbar( amplitude_midpoints, display_y, label=\"Recorded Period With Error Bar\", yerr=y_err,xerr=amplitude_midpoints_err, fmt='o', ecolor=\"red\", color=\"black\", ms=7)\n\n# fit_x_values = np.arange(min(amplitude_midpoints),max(amplitude_midpoints),0.01)\nfit_x_values = np.arange(-1.2,1.2,0.01)\nfit_y_values = params[0]+params[1]*fit_x_values+params[2]*fit_x_values**2 \nplt.plot(fit_x_values, fit_y_values, color=\"xkcd:lightish blue\",linewidth=3, label = 'best fit line')\n# plt.plot(amplitude_midpoints, amplitude_bins)\n\nplt.xlabel(\"Amplitude (radians)\")\nplt.ylabel(\"Period (s)\")\nplt.title(\"Period vs. Amplitude\")\nplt.legend(loc=\"upper right\")\nplt.xlim(-1.2,1.2)\n# plt.savefig(\"Figures\/period-vs-amplitude\", dpi=300)\n\n\np = unumpy.uarray(params, np.sqrt(np.diag(cov)))\nprint(p)\nprint(p[0],p[1]\/p[0],p[2]\/p[0])","c6cc0071":"print(amplitude_midpoints)\nresidual = []\nfor i in range(0, len(amplitude_midpoints)):\n    residual.append(display_y[i] - (params[0]+params[1]*amplitude_midpoints[i]+params[2]*amplitude_midpoints[i]**2))\n\nfig, ax = plt.subplots(figsize=(40,20))\nax.errorbar( amplitude_midpoints, residual, label=\"Recorded Period With Error Bar\", yerr=y_err,xerr=amplitude_midpoints_err, fmt='o', ecolor=\"red\", color=\"black\", ms=7)\nax.bar(amplitude_midpoints, residual,width = 0.005, label = 'Residual')\nx_axis = np.arange(-1.2, 1.2, 0.1)\nax.plot(x_axis, x_axis * 0, label = \"Best Fit Line\")\n# ax.fill_between(amplitude_midpoints, residual, alpha=0.2)\nax.legend()\nax.set_title(\"Residual of Fit\")\nax.set_xlabel(\"Amplitudes (radians)\")\nax.set_ylabel(\"Residuals of Best Fitted Function\")\nax.set_xlim(-1.2, 1.2)\nplt.show()","ac258289":"def period(angle, T0, alpha, beta): \n#     a = abs(amplitude_a).n\n#     tau = abs(amplitude_tau).n\n    return T0*(1+alpha*angle+beta*angle**2)\n\n\nparams,cov = np.polyfit(amplitude_midpoints, display_y, 6-1, rcond=None, cov=True, w=1\/y_err)\nparams = params[::-1]\nplt.figure(figsize=(40,20))\nplt.errorbar( amplitude_midpoints, display_y, label=\"Recorded Period With Error Bar\", yerr=y_err,xerr=amplitude_midpoints_err, fmt='o', ecolor=\"red\", color=\"black\", ms=7)\n\n# fit_x_values = np.arange(min(amplitude_midpoints),max(amplitude_midpoints),0.01)\nfit_x_values = np.arange(-1.2,1.2,0.01)\nfit_y_values = params[0]+params[1]*fit_x_values+params[2]*fit_x_values**2+ params[3]*fit_x_values**3+ params[4]*fit_x_values**4+ params[5]*fit_x_values**5  \nplt.plot(fit_x_values, fit_y_values, color=\"xkcd:lightish blue\",linewidth=3)\n# plt.plot(amplitude_midpoints, amplitude_bins)\n\nplt.xlabel(\"Amplitude (radians)\")\nplt.ylabel(\"Period (s)\")\nplt.title(\"Period vs. Amplitude\")\nplt.legend(loc=\"upper right\")\nplt.xlim(-1.2,1.2)\n# plt.savefig(\"Figures\/period-vs-amplitude\", dpi=300)\n\n\np = unumpy.uarray(params, np.sqrt(np.diag(cov)))\nprint(p)\nprint(p[0],p[1]\/p[0],p[2]\/p[0])\n# param, param_cov = curve_fit(period, amplitude_midpoints, display_y) # p0=[2.4,0]\n    \n#     # Parameter Uncertainties\n#     u_w = param_cov[0,0]**0.5\n#     u_phi = param_cov[1,1]**0.5\n\n#     # Fited Function\n#     theta_fit = f(temp_t_points, param[0], param[1])\n\n#     figure_w = ufloat(param[0],u_w)\n#     figure_phi = ufloat(param[1],u_phi)\n\n# fit_curve_to_f(sine_linear_drag, t, theta)","2d04d7a0":"print(amplitude_midpoints)\nresidual = []\nfor i in range(0, len(amplitude_midpoints)):\n    residual.append(display_y[i] - (params[0]+params[1]*amplitude_midpoints[i]+params[2]*amplitude_midpoints[i]**2+ params[3]*amplitude_midpoints[i]**3+ params[4]*amplitude_midpoints[i]**4+ params[5]*amplitude_midpoints[i]**5  ) + 0.01)\n\nfig, ax = plt.subplots(figsize=(40,20))\nax.errorbar( amplitude_midpoints, residual, label=\"Recorded Period With Error Bar\", yerr=y_err,xerr=amplitude_midpoints_err, fmt='o', ecolor=\"red\", color=\"black\", ms=7)\nax.bar(amplitude_midpoints, residual,width = 0.005, label = 'Residual')\nx_axis = np.arange(-1.2, 1.2, 0.1)\nax.plot(x_axis, x_axis * 0, label = \"Best Fit Line\")\n# ax.fill_between(amplitude_midpoints, residual, alpha=0.2)\nax.legend()\nax.set_title(\"Residual of Fit\")\nax.set_xlabel(\"Amplitudes (radians)\")\nax.set_ylabel(\"Residuals of Best Fitted Function\")\nax.set_xlim(-1.2, 1.2)\nplt.show()","120bba59":"def period(angle, T0, alpha, beta): \n#     a = abs(amplitude_a).n\n#     tau = abs(amplitude_tau).n\n    return T0*(1+alpha*angle+beta*angle**2)\n\n\nparams,cov = np.polyfit(amplitude_midpoints, display_y, 6, rcond=None, cov=True, w=1\/y_err)\nparams = params[::-1]\nplt.figure(figsize=(40,20))\nplt.errorbar( amplitude_midpoints, display_y, label=\"Recorded Period With Error Bar\", yerr=y_err,xerr=amplitude_midpoints_err, fmt='o', ecolor=\"red\", color=\"black\", ms=7)\n\nfit_x_values = np.arange(min(amplitude_midpoints),max(amplitude_midpoints),0.01)\nfit_y_values = params[0]+params[1]*fit_x_values+params[2]*fit_x_values**2\nplt.plot(fit_x_values, fit_y_values, color=\"xkcd:lightish blue\",linewidth=3)\n# plt.plot(amplitude_midpoints, amplitude_bins)\n\nplt.xlabel(\"Amplitude (radians)\")\nplt.ylabel(\"Period (s)\")\nplt.title(\"Period vs. Amplitude\")\nplt.legend(loc=\"upper right\")\n# plt.savefig(\"Figures\/period-vs-amplitude\", dpi=300)\n\n\np = unumpy.uarray(params, np.sqrt(np.diag(cov)))\nprint(p)\nprint(p[0],p[1]\/p[0],p[2]\/p[0])\n# param, param_cov = curve_fit(period, amplitude_midpoints, display_y) # p0=[2.4,0]\n    \n#     # Parameter Uncertainties\n#     u_w = param_cov[0,0]**0.5\n#     u_phi = param_cov[1,1]**0.5\n\n#     # Fited Function\n#     theta_fit = f(temp_t_points, param[0], param[1])\n\n#     figure_w = ufloat(param[0],u_w)\n#     figure_phi = ufloat(param[1],u_phi)\n\n# fit_curve_to_f(sine_linear_drag, t, theta)","df0b9e01":"def period(angle, T0, alpha, beta): \n#     a = abs(amplitude_a).n\n#     tau = abs(amplitude_tau).n\n    return T0*(1+alpha*angle+beta*angle**2)\n\n\nparams,cov = np.polyfit(amplitude_midpoints*amplitude_midpoints, display_y, 3, rcond=None, cov=True,w=1\/y_err)\nparams = params[::-1]\nplt.figure(figsize=(40,20))\nplt.errorbar(amplitude_midpoints*amplitude_midpoints, display_y, label=\"Recorded Period With Error Bar\", yerr=y_err,xerr=amplitude_midpoints_err, fmt='o', ecolor=\"red\", color=\"black\", ms=7)\n\nfit_x_values = np.arange(min(amplitude_midpoints*amplitude_midpoints),max(amplitude_midpoints*amplitude_midpoints),0.01)\nfit_y_values = params[0]+params[1]*fit_x_values\nplt.plot(fit_x_values, fit_y_values, color=\"xkcd:lightish blue\",linewidth=3)\n# plt.plot(amplitude_midpoints, amplitude_bins)\n\nplt.xlabel(\"Amplitude Squared (radians^2)\")\nplt.ylabel(\"Period (s)\")\nplt.title(\"Period vs. Amplitude Squared\")\nplt.legend(loc=\"upper left\")\n# plt.savefig(\"Figures\/period-vs-amplitude-linear\", dpi=300)\n\n\np = unumpy.uarray(params, np.sqrt(np.diag(cov)))\nprint(p)\nprint(p[1]\/p[0])\n# param, param_cov = curve_fit(period, amplitude_midpoints, display_y) # p0=[2.4,0]\n    \n#     # Parameter Uncertainties\n#     u_w = param_cov[0,0]**0.5\n#     u_phi = param_cov[1,1]**0.5\n\n#     # Fited Function\n#     theta_fit = f(temp_t_points, param[0], param[1])\n\n#     figure_w = ufloat(param[0],u_w)\n#     figure_phi = ufloat(param[1],u_phi)\n\n# fit_curve_to_f(sine_linear_drag, t, theta)","febf6898":"slope, intercept, r_value, p_value, std_err = stats.linregress(amplitude_midpoints*amplitude_midpoints,display_y)\nr_value**2","c939af7d":"def period(angle, T0, alpha, beta): \n#     a = abs(amplitude_a).n\n#     tau = abs(amplitude_tau).n\n    return T0*(1+alpha*angle+beta*angle**2)\n\n\nparams,cov = np.polyfit(amplitude_midpoints, display_y, 5, rcond=None, cov=True, w=1\/y_err)\nparams = params[::-1]\nplt.figure(figsize=(40,20))\nplt.errorbar( amplitude_midpoints, display_y, label=\"Recorded Period With Error Bar\", yerr=y_err,xerr=amplitude_midpoints_err, fmt='o', ecolor=\"red\", color=\"black\", ms=7)\n\nfit_x_values = np.arange(min(amplitude_midpoints),max(amplitude_midpoints),0.01)\nfit_y_values = params[0]+params[1]*fit_x_values+params[2]*fit_x_values**2+params[3]*fit_x_values**3+params[4]*fit_x_values**4\nplt.plot(fit_x_values, fit_y_values, color=\"xkcd:lightish blue\",linewidth=3)\n# plt.plot(amplitude_midpoints, amplitude_bins)\n\nplt.xlabel(\"Amplitude (radians)\")\nplt.ylabel(\"Period (s)\")\nplt.title(\"Period vs. Amplitude\")\nplt.legend(loc=\"upper right\")\n# plt.savefig(\"Figures\/period-vs-amplitude-quartic\", dpi=300)\n\n\np = unumpy.uarray(params, np.sqrt(np.diag(cov)))\nprint(p)\nprint(p[0],p[1]\/p[0],p[2]\/p[0],p[3]\/p[0],p[4]\/p[0])\n# param, param_cov = curve_fit(period, amplitude_midpoints, display_y) # p0=[2.4,0]\n    \n#     # Parameter Uncertainties\n#     u_w = param_cov[0,0]**0.5\n#     u_phi = param_cov[1,1]**0.5\n\n#     # Fited Function\n#     theta_fit = f(temp_t_points, param[0], param[1])\n\n#     figure_w = ufloat(param[0],u_w)\n#     figure_phi = ufloat(param[1],u_phi)\n\n# fit_curve_to_f(sine_linear_drag, t, theta)","98b3bb33":"Since the tracker measures the x,y position of the lower end of the pendulum, and we have set the lowest point of the pendulum to be the origin. \nTo get the anlge, we use ATAN(x\/y_actual) y_actual is calculated by the y above orgin plus the length of the string (0.321)","42e8c9fd":"Fit the curve","22afa334":"# Envelope Function\nWe can write a function to roughly describe the amplitude as a function of time"}}