{"cell_type":{"9a90ccf8":"code","cf17c977":"code","dbb42952":"code","160a343d":"code","16564615":"code","0bd07358":"code","1977fc16":"code","4abd15f2":"code","67dd1ccc":"code","5131d741":"code","a8cfce74":"code","1b0bf511":"code","fb6bddd9":"code","f60aaa17":"code","e5512d23":"code","daa27861":"code","d918f22a":"code","a8143583":"code","446f60cc":"code","c34bb651":"code","d4090f70":"code","f89f29e6":"code","220dd8c7":"code","82d5b455":"code","cfaedfb9":"code","23d757c0":"code","4ed80bf1":"code","28f9552e":"code","f99e68a6":"code","c8350d81":"code","b8d91dea":"code","39e6c5bb":"code","31941d94":"code","4195f647":"code","322cb1df":"code","7e22232e":"code","f0395766":"code","d63be155":"code","72998828":"code","319c8531":"code","9861a937":"code","eb23e942":"code","a7c203d6":"code","553c216e":"code","7b76d4d7":"code","80cd1f8a":"markdown","4c58e326":"markdown","9fc93f0b":"markdown","a4ee6647":"markdown"},"source":{"9a90ccf8":"import re\nimport nltk\nimport numpy as np\nfrom nltk.corpus import stopwords\nfrom sklearn.model_selection import train_test_split\nimport pandas as pd\nstopWords = set(stopwords.words('english'))\nimport os\nprint(os.listdir(\"..\/input\"))\nfrom nltk.stem import SnowballStemmer\nstem = SnowballStemmer('english')\n\nfrom imblearn.metrics import sensitivity_score","cf17c977":"# credit to https:\/\/www.kaggle.com\/taindow\/simple-cudnngru-python-keras \nspecials = [\"\u2019\", \"\u2018\", \"\u00b4\", \"`\"]\npuncts = [',', '.', '\"', ':', ')', '(', '-', '!', '?', '|', ';', \"'\", '$', '&', '\/', '[', ']', '>', '%', '=', '#', '*', '+', '\\\\', '\u2022',  '~', '@', '\u00a3', \n    '\u00b7', '_', '{', '}', '\u00a9', '^', '\u00ae', '`',  '<', '\u2192', '\u00b0', '\u20ac', '\u2122', '\u203a',  '\u2665', '\u2190', '\u00d7', '\u00a7', '\u2033', '\u2032', '\u00c2', '\u2588', '\u00bd', '\u00e0', '\u2026', \n    '\u201c', '\u2605', '\u201d', '\u2013', '\u25cf', '\u00e2', '\u25ba', '\u2212', '\u00a2', '\u00b2', '\u00ac', '\u2591', '\u00b6', '\u2191', '\u00b1', '\u00bf', '\u25be', '\u2550', '\u00a6', '\u2551', '\u2015', '\u00a5', '\u2593', '\u2014', '\u2039', '\u2500', \n    '\u2592', '\uff1a', '\u00bc', '\u2295', '\u25bc', '\u25aa', '\u2020', '\u25a0', '\u2019', '\u2580', '\u00a8', '\u2584', '\u266b', '\u2606', '\u00e9', '\u00af', '\u2666', '\u00a4', '\u25b2', '\u00e8', '\u00b8', '\u00be', '\u00c3', '\u22c5', '\u2018', '\u221e', \n    '\u2219', '\uff09', '\u2193', '\u3001', '\u2502', '\uff08', '\u00bb', '\uff0c', '\u266a', '\u2569', '\u255a', '\u00b3', '\u30fb', '\u2566', '\u2563', '\u2554', '\u2557', '\u25ac', '\u2764', '\u00ef', '\u00d8', '\u00b9', '\u2264', '\u2021', '\u221a', ]\ncontraction_mapping = {\"ain't\": \"is not\", \"aren't\": \"are not\",\"can't\": \"cannot\", \"'cause\": \"because\", \"could've\": \"could have\", \"couldn't\": \"could not\", \"didn't\": \"did not\",  \"doesn't\": \"does not\", \"don't\": \"do not\", \"hadn't\": \"had not\", \"hasn't\": \"has not\", \"haven't\": \"have not\", \"he'd\": \"he would\",\"he'll\": \"he will\", \"he's\": \"he is\", \"how'd\": \"how did\", \"how'd'y\": \"how do you\", \"how'll\": \"how will\", \"how's\": \"how is\",  \"I'd\": \"I would\", \"I'd've\": \"I would have\", \"I'll\": \"I will\", \"I'll've\": \"I will have\",\"I'm\": \"I am\", \"I've\": \"I have\", \"i'd\": \"i would\", \"i'd've\": \"i would have\", \"i'll\": \"i will\",  \"i'll've\": \"i will have\",\"i'm\": \"i am\", \"i've\": \"i have\", \"isn't\": \"is not\", \"it'd\": \"it would\", \"it'd've\": \"it would have\", \"it'll\": \"it will\", \"it'll've\": \"it will have\",\"it's\": \"it is\", \"let's\": \"let us\", \"ma'am\": \"madam\", \"mayn't\": \"may not\", \"might've\": \"might have\",\"mightn't\": \"might not\",\"mightn't've\": \"might not have\", \"must've\": \"must have\", \"mustn't\": \"must not\", \"mustn't've\": \"must not have\", \"needn't\": \"need not\", \"needn't've\": \"need not have\",\"o'clock\": \"of the clock\", \"oughtn't\": \"ought not\", \"oughtn't've\": \"ought not have\", \"shan't\": \"shall not\", \"sha'n't\": \"shall not\", \"shan't've\": \"shall not have\", \"she'd\": \"she would\", \"she'd've\": \"she would have\", \"she'll\": \"she will\", \"she'll've\": \"she will have\", \"she's\": \"she is\", \"should've\": \"should have\", \"shouldn't\": \"should not\", \"shouldn't've\": \"should not have\", \"so've\": \"so have\",\"so's\": \"so as\", \"this's\": \"this is\",\"that'd\": \"that would\", \"that'd've\": \"that would have\", \"that's\": \"that is\", \"there'd\": \"there would\", \"there'd've\": \"there would have\", \"there's\": \"there is\", \"here's\": \"here is\",\"they'd\": \"they would\", \"they'd've\": \"they would have\", \"they'll\": \"they will\", \"they'll've\": \"they will have\", \"they're\": \"they are\", \"they've\": \"they have\", \"to've\": \"to have\", \"wasn't\": \"was not\", \"we'd\": \"we would\", \"we'd've\": \"we would have\", \"we'll\": \"we will\", \"we'll've\": \"we will have\", \"we're\": \"we are\", \"we've\": \"we have\", \"weren't\": \"were not\", \"what'll\": \"what will\", \"what'll've\": \"what will have\", \"what're\": \"what are\",  \"what's\": \"what is\", \"what've\": \"what have\", \"when's\": \"when is\", \"when've\": \"when have\", \"where'd\": \"where did\", \"where's\": \"where is\", \"where've\": \"where have\", \"who'll\": \"who will\", \"who'll've\": \"who will have\", \"who's\": \"who is\", \"who've\": \"who have\", \"why's\": \"why is\", \"why've\": \"why have\", \"will've\": \"will have\", \"won't\": \"will not\", \"won't've\": \"will not have\", \"would've\": \"would have\", \"wouldn't\": \"would not\", \"wouldn't've\": \"would not have\", \"y'all\": \"you all\", \"y'all'd\": \"you all would\",\"y'all'd've\": \"you all would have\",\"y'all're\": \"you all are\",\"y'all've\": \"you all have\",\"you'd\": \"you would\", \"you'd've\": \"you would have\", \"you'll\": \"you will\", \"you'll've\": \"you will have\", \"you're\": \"you are\", \"you've\": \"you have\" }\nswear_words_re = ' 4r5e | 5h1t | 5hit | ass-fucker | assfucker | assfukka | asswhole | a_s_s | b!tch | b17ch | blow job | boiolas | bollok | boooobs | booooobs | booooooobs | bunny fucker | buttmuch | c0cksucker | carpet muncher | cl1t | cockface | cockmunch | cockmuncher | cocksuka | cocksukka | cokmuncher | coksucka | cunillingus | cuntlick | cuntlicker | cuntlicking | cyalis | cyberfuc | cyberfuck | cyberfucked | cyberfucker | cyberfuckers | cyberfucking | dirsa | dlck | dog-fucker | donkeyribber | ejaculatings | ejakulate | f u c k | f u c k e r | f4nny | faggitt | faggs | fannyflaps | fannyfucker | fanyy | fingerfucker | fingerfuckers | fingerfucks | fistfuck | fistfucked | fistfucker | fistfuckers | fistfucking | fistfuckings | fistfucks | fuckingshitmotherfucker | fuckwhit | fudge packer | fudgepacker | fukwhit | fukwit | fux0r | f_u_c_k | god-dam | kawk | knobead | knobed | knobend | knobjocky | knobjokey | kondum | kondums | kummer | kumming | kums | kunilingus | l3itch | m0f0 | m0fo | m45terbate | ma5terb8 | ma5terbate | master-bate | masterb8 | masterbat3 | masterbations | mof0 | mothafuck | mothafuckaz | mothafucked | mothafucking | mothafuckings | mothafucks | mother fucker | motherfucked | motherfuckings | motherfuckka | motherfucks | muthafecker | muthafuckker | n1gga | n1gger | nigg3r | nigg4h | nob jokey | nobjocky | nobjokey | penisfucker | phuked | phuking | phukked | phukking | phuks | phuq | pigfucker | pimpis | pissflaps | rimjaw | s hit | scroat | sh!t | shitdick | shitfull | shitings | shittings | s_h_i_t | t1tt1e5 | t1tties | teez | tittie5 | tittiefucker | tittywank | tw4t | twathead | twunter | v14gra | v1gra | w00se | whoar'","dbb42952":"def clean_contractions(text):\n    for s in specials:\n        if s in text:\n            text = text.replace(s, \"'\")\n    text = ' '.join([contraction_mapping[t] if t in contraction_mapping else t for t in text.split(\" \")])\n    return text\n\n# tips to accelerate string processing\ndef clean_text_slow(x, maxlen=None):\n    x = x.lower()\n    for punct in puncts[:maxlen]:\n        x = x.replace(punct, f' {punct} ')\n    return x\n\ndef clean_text_fast(x, maxlen=None):\n    x = x.lower()\n    for punct in puncts[:maxlen]:\n        if punct in x:  # add this line\n            x = x.replace(punct, f' {punct} ')\n    return x\n#######\ndef word_extraction(sentence):\n    #sentence=clean_contractions(sentence)\n    for s in specials:\n        if s in sentence: # this line to first speed up\n            sentence=sentence.replace(s,\"''\")\n    for punct in puncts:\n        if punct in sentence:\n            sentence=sentence.replace(punct, f' {punct} ')\n            \n    sentence=' '.join([contraction_mapping[t] if t in contraction_mapping else t for t in sentence.split(\" \")])\n    #sentence=re.sub(swear_words_re,' fuck',sentence) # comment because swear type may be linked to context\n    words = re.sub(\"[^\\w]\",\" \", sentence).split()\n    cleaned_text=[stem.stem(w.lower()) for w in words]\n    return str(cleaned_text)","160a343d":"dataset = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')\nsub = pd.read_csv('..\/input\/sample_submission.csv')","16564615":"toy=False\nif toy==True:\n    dataset=dataset.sample(n=10000)\n    test=test.sample(n=10000)","0bd07358":"dataset[dataset[\"target\"]>0.5][['target','comment_text']].sample(n=10)","1977fc16":"test.sample(n=5) ","4abd15f2":"dataset.target=dataset.target.apply(lambda x: 1 if x>0.5 else 0)","67dd1ccc":"dataset.target.value_counts()  # classes are unbalanced\n# ","5131d741":"%%time\ndataset['cleaned_comment']=dataset.comment_text.apply(lambda x: word_extraction(x))","a8cfce74":"# try to parallelize preprocessing #no gain\n\nimport tqdm\nfrom multiprocessing import Pool\n\ndef parallelize_apply(df,func,colname,num_process,newcolnames):\n    # takes as input a df and a function for one of the columns in df\n    pool =Pool(processes=num_process)\n    arraydata = pool.map(func,df[colname].values)\n    pool.close()\n    newdf = pd.DataFrame(arraydata,columns = newcolnames)\n    df = pd.concat([df,newdf],axis=1)\n    return df\n\n","1b0bf511":"%%time\n#parallelized_dataset = parallelize_apply(dataset,word_extraction,'comment_text',4,['cleaned_parallelized'])  # no gain 22 min","fb6bddd9":"%%time\ntest['cleaned_comment']=test.comment_text.apply(lambda x: word_extraction(x))","f60aaa17":"# CountVectorizer can bien replaced by TfidfVectorizer\nfrom sklearn.feature_extraction.text import TfidfVectorizer\ntfidf=TfidfVectorizer(max_features=4000)","e5512d23":"# Corpus definition\ncorpus = pd.concat([dataset['cleaned_comment'], test['cleaned_comment']])\ncorpus = corpus.drop_duplicates()","daa27861":"%%time\n#tfidf.fit(corpus)","d918f22a":"%%time\n#X=tfidf.transform(dataset['cleaned_comment'])","a8143583":"#y=dataset.target","446f60cc":"#X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33\n#                                    ,random_state=1)","c34bb651":"#X_train.shape","d4090f70":"#from sklearn.linear_model import LogisticRegression","f89f29e6":"#clf = LogisticRegression(random_state=0, solver='lbfgs').fit(X_train, y_train)","220dd8c7":"#clf.score(X_train,y_train)","82d5b455":"#clf.score(X_test,y_test)","cfaedfb9":"#predictions=clf.predict(X_test)\n#predictions.shape","23d757c0":"#X_test=tfidf.transform(test['cleaned_comment'])","4ed80bf1":"#y_test= clf.predict(X_test)","28f9552e":"#submission_df = pd.read_csv(\"..\/input\/sample_submission.csv\")\n","f99e68a6":"#submission_df['prediction'] = y_test","c8350d81":"#submission_df.to_csv(\"submission.csv\", index=False)","b8d91dea":"%%time\nimport gensim\nfrom gensim.models.word2vec import Word2Vec\nmodelW2V = Word2Vec(sentences=corpus, size=100, window=5, min_count=5, workers=2,sg=0)\nw2v = {w: vec for w, vec in zip(modelW2V.wv.index2word, modelW2V.wv.syn0)}","39e6c5bb":"from sklearn.feature_extraction.text import TfidfVectorizer\nfrom collections import defaultdict\nclass MeanEmbeddingVectorizer(object):\n    def __init__(self, word2vec):\n        self.word2vec = word2vec\n        if len(word2vec)>0:\n            self.dim=len(word2vec[next(iter(w2v))])\n        else:\n            self.dim=0\n            \n    def fit(self, X, y):\n        return self \n\n    def transform(self, X):\n        return np.array([\n            np.mean([self.word2vec[w] for w in words if w in self.word2vec] \n                    or [np.zeros(self.dim)], axis=0)\n            for words in X\n        ])\n\nclass TfidfEmbeddingVectorizer(object):\n    def __init__(self, word2vec):\n        self.word2vec = word2vec\n        self.word2weight = None\n        self.dim = len(next(iter(w2v)))\n\n    def fit(self, X, y):\n        tfidf = TfidfVectorizer(analyzer=lambda x: x)\n        tfidf.fit(X)\n        # if a word was never seen - it must be at least as infrequent\n        # as any of the known words - so the default idf is the max of \n        # known idf's\n        max_idf = max(tfidf.idf_)\n        self.word2weight = defaultdict(\n            lambda: max_idf,\n            [(w, tfidf.idf_[i]) for w, i in tfidf.vocabulary_.items()])\n\n        return self\n\n    def transform(self, X):\n        return np.array([\n                np.mean([self.word2vec[w] * self.word2weight[w]\n                         for w in words if w in self.word2vec] or\n                        [np.zeros(self.dim)], axis=0)\n                for words in X\n            ])","31941d94":"from sklearn.pipeline import make_pipeline\nfrom sklearn.svm import SVC\nvectorizer=TfidfEmbeddingVectorizer(w2v)\nvectorizer.fit(corpus,dataset.target)\nX_train=vectorizer.transform(dataset.cleaned_comment)","4195f647":"X_test=vectorizer.transform(test.cleaned_comment)","322cb1df":"# for making train - valid sets\nfrom sklearn.model_selection import train_test_split\nimport lightgbm as lgb","7e22232e":"def f(x):\n    value=0\n    if x>0.5:\n        value=1\n    return value\nvf = np.vectorize(f)","f0395766":"def LGB_bayesian(\n    bagging_freq,  # int\n    bagging_fraction,\n    feature_fraction,     \n    learning_rate,\n    min_data_in_leaf, #int\n    min_sum_hessian_in_leaf,\n    num_leaves): # int\n    \n    # LGB expects next three parameters need to be integer. So we make them integer\n    bagging_freq = int(bagging_freq)\n    min_data_in_leaf=int(min_data_in_leaf)\n    num_leaves=int(num_leaves)\n    assert type(bagging_freq) == int\n    assert type(min_data_in_leaf) == int\n    assert type(num_leaves)==int\n    param = {\n        'bagging_freq': bagging_freq,\n        'bagging_fraction':bagging_fraction,\n        'boost_from_average' :'false',\n        'boost':'gbdt',\n        'feature_fraction':feature_fraction,\n        'learning_rate':learning_rate,\n        'max_depth':-1,\n        'min_data_in_leaf':min_data_in_leaf,\n        'min_sum_hessian_in_leaf':min_sum_hessian_in_leaf,\n        'num_leaves':num_leaves,\n        'tree_learner':'serial',\n        'objective': 'binary',\n        'num_threads': 8, \n        \"device\" : \"cpu\"\n\n    }    \n\n    lgb_train = lgb.Dataset(X_train[bayesian_tr_index],\n                           label=dataset.target.iloc[bayesian_tr_index].values\n                           )\n    lgb_valid = lgb.Dataset(X_train[bayesian_val_index], label=dataset.target.iloc[bayesian_val_index].values\n                           )   \n\n    num_round = 5000\n    clf = lgb.train(param, lgb_train, 1000000, valid_sets = [lgb_train, lgb_valid], verbose_eval=100, early_stopping_rounds = 40)\n    \n    predictions = clf.predict(X_train[bayesian_val_index])# , num_iteration=clf.best_iteration)   \n    \n    predictions=  np.array([f(xi) for xi in predictions])\n    #score = metrics.roc_auc_score(dataset.target.iloc[bayesian_val_index].values, predictions)\n    score=sensitivity_score(dataset.target.iloc[bayesian_val_index].values, predictions, average='binary')\n    return score","d63be155":"from sklearn import metrics\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import StratifiedKFold\nbayesian_tr_index, bayesian_val_index  = list(StratifiedKFold(n_splits= 5, shuffle=True, random_state=13).split(X_train, dataset.target))[0]","72998828":"Bounds_LGB = {\n    'bagging_freq': (2,10),  'bagging_fraction': (0.1,0.9),\n    'feature_fraction': (0.05,0.5), 'learning_rate':(0.05,0.1),\n    'min_data_in_leaf': (2,100),     \n    'min_sum_hessian_in_leaf': (2,30),'num_leaves': (2,100)\n}","319c8531":"#from bayes_opt import BayesianOptimization\n#LGB_BO = BayesianOptimization(LGB_bayesian, Bounds_LGB, random_state=13)\n\n#init_points = 3  \n#n_iter = 10","9861a937":"import warnings\n#with warnings.catch_warnings():\n#    warnings.filterwarnings('ignore')\n#    LGB_BO.maximize(init_points=init_points, n_iter=n_iter, acq='ucb', xi=0.0, alpha=1e-6)\n","eb23e942":"#LGB_BO.max['params']","a7c203d6":"opt_param={'bagging_fraction': 0.72,\n 'bagging_freq': 7,\n        'boost_from_average' :'false',\n        'boost':'gbdt',\n                   'max_depth':-1,\n 'feature_fraction': 0.375,\n 'learning_rate': 0.05,\n 'min_data_in_leaf': 31,\n 'min_sum_hessian_in_leaf': 3.6,\n 'num_leaves': 86,\n'tree_learner':'serial',\n        'objective': 'binary',\n        'num_threads': 8, \n        \"device\" : \"cpu\"}","553c216e":"n_fold=5\nkfold = StratifiedKFold(n_splits=n_fold, shuffle=True, random_state=13)\n\ncvscores = []\npredictions=0\nfor trn_idx, val_idx in StratifiedKFold(n_splits= 5, shuffle=True, random_state=13).split(X_train, dataset.target):\n    trn_data=lgb.Dataset(X_train[trn_idx], label=dataset.target.iloc[trn_idx].values)\n    val_data=lgb.Dataset(X_train[val_idx], label=dataset.target.iloc[val_idx].values)\n\n    clf = lgb.train(opt_param, trn_data, 1000000, valid_sets = [trn_data, val_data], verbose_eval=50, early_stopping_rounds = 30)\n    \n    y_test= clf.predict(X_train[val_idx])\n    y_test=  np.array([f(xi) for xi in y_test])\n\n    score=sensitivity_score(dataset.target.iloc[val_idx].values, y_test, average='binary')\n    print('final score '+str(score))\n    predictions += clf.predict(X_test, num_iteration=clf.best_iteration) \/ n_fold\n    \n    \n","7b76d4d7":"submission_df = pd.read_csv(\"..\/input\/sample_submission.csv\")\nsubmission_df.columns\nsubmission_df['predictions'] = predictions\nsubmission_df.to_csv(\"submission.csv\", index=False)","80cd1f8a":"Word2Vec","4c58e326":"check 10 random rows.","9fc93f0b":"as there are no indications about type of toxicity in test dataset, I will keep only comment_text and target","a4ee6647":"Sources :\nhttps:\/\/medium.freecodecamp.org\/an-introduction-to-bag-of-words-and-how-to-code-it-in-python-for-nlp-282e87a9da04\nhttps:\/\/medium.com\/civis-analytics\/an-intro-to-natural-language-processing-in-python-framing-text-classification-in-familiar-terms-33778d1aa3ca\nhttps:\/\/www.kaggle.com\/nevermoi\/jigsaw-toxic-prediction-by-simple-linearsvr-tfidf\n\nspeed up preprocessing :https:\/\/www.kaggle.com\/syhens\/speed-up-your-preprocessing\n\nmetrics to deal with unbalanced class : \nhttps:\/\/towardsdatascience.com\/selecting-the-right-metric-for-skewed-classification-problems-6e0a4a6167a7\n"}}