{"cell_type":{"1593bd7e":"code","726fa167":"code","c759a8fd":"code","c8386e55":"code","ae681dec":"code","66d3d544":"code","12030083":"code","d08518ff":"code","59039a97":"code","8ab34806":"code","852b86b8":"code","cc5dd8f1":"code","0b9378e8":"code","9e43aec3":"code","eb5a24ab":"code","c84444eb":"markdown","77212b8c":"markdown","89ed02a4":"markdown","aebde4da":"markdown","e2a6ff41":"markdown","eb2a1a9d":"markdown","81fdd4b9":"markdown","f5d8d908":"markdown","3432bb92":"markdown","319c4381":"markdown","5e2bc10e":"markdown","453b2f88":"markdown","e54cbd8c":"markdown","83365ec7":"markdown","cad084e2":"markdown","c180e6e5":"markdown","1148f2a2":"markdown","3f9ea849":"markdown"},"source":{"1593bd7e":"# The Python programming language is based on modules, which can be imported in the beginning of every program.\n# Here we will use the following modules for our analysis:\n\n# Standard libraries\nfrom pathlib import Path            # deals with path related tasks, such as constructing new paths from names of files and from other paths and creating files at specific paths.\nimport warnings                     # provides warnings to warn the developer\/user\n# Third party libraries\n# %matplotlib inline  # magic function to present the output of plotting commands inline\nimport matplotlib.pyplot as plt     # cross-platform data visualisation and graphical plotting library\nimport numpy as np                  # important for vector and matrix computations\nimport pandas as pd                 # used to read and modify 'labeled' data (e.g. table-like structures)\nimport ipywidgets as widgets        # used for interactive HTML widgets\nimport scipy as sp                  # collection of mathematical algorithms and convenience functions built on NumPy\nfrom scipy.signal import find_peaks # function to detect local maxima in a signal\n\nprint('Imports succesful!')","726fa167":"# Plot settings\nfig_width, fig_height = 14, 3                   # Standard width and height of figures in inches\nplt.rcParams.update({\n    'font.size': 14,                            # default text size in figures\n    'lines.linewidth': 2,                       # line width in points\n    'lines.markersize': 10,                     # marker size, in points\n    'figure.figsize': (fig_width, fig_height),  # # figure size in inches\n    'figure.autolayout': True,                  # tight layout\n    'axes.spines.right': False,                 # if True, display right axis spine\n    'axes.spines.top': False,                   # if True, display top axis spine\n    'legend.frameon': False,                    # if True, draw the legend on a background patch\n    'legend.loc': 'center left',                # relative location of legend\n})\n\n# Widget settings\nslider_width, slider_height = '800px', '40px'\ndropdown_width, dropdown_height = '200px', '40px'\ninput_width, input_height = '200px', '40px'\n\n# Experiment type\nexperiment_type = 'StretchReceptor'\n\n# Separator of text file\nsep = '\\t'","c759a8fd":"\n# #######################################################\n# FileProperties\n# #######################################################\nclass FileProperties:\n    \"\"\"Class to store properties of each file\"\"\"\n    def __init__(self, experiment_type):\n        \"\"\"Simple init file of the class\n\n        Args:\n            experiment_type (str): Type of experiment. Either 'StretchReceptor' or 'WingMuscle'\n        \"\"\"\n        self.path_to_input_folder = Path()\n        self.analysis_class_list = list()\n        self.experiment_type = experiment_type\n        \n        if self.experiment_type != 'WingMuscle' and self.experiment_type != 'StretchReceptor':\n            warnings.warn(f'experiment_type must be \"WingMuscle\" or \"StretchReceptor\" and not \"{self.experiment_type}\".')\n        \n    def set_input_data(self, path_to_input_folder):  \n        \"\"\"Create widgets to set input data\n\n        Args:\n            path_to_input_folder (Path): path to folder with input data\n        \"\"\"\n        self.path_to_input_folder = path_to_input_folder\n\n        # Look up all text files within this dataset\n        path_to_input_files = self.path_to_input_folder.glob('**\/*.txt')\n    \n        # Check if input files are found\n        if not len(list(path_to_input_files)):\n            warnings.warn(f'No .txt files found. Make sure you have uploaded text file(s) to the right dataset.')\n        \n        # Loop over all input files to create widgets\n        self.file_properties = dict()\n        path_to_files = sorted(list(self.path_to_input_folder.glob('**\/*.txt')))\n        \n        for path_to_file in path_to_files:\n            self.create_file_widget(path_to_file)\n\n    def create_file_widget(self, path_to_file):\n        \"\"\"Create widget to set file properties, calls get_file_properties()\n    \n        Args:\n            path_to_file (Path): path to file\n        \"\"\"        \n        # Define file label based on path_to_file\n        file_label = str(path_to_file)[len(str(self.path_to_input_folder))+1:]\n        \n        # Define angle widget for experiment type\n        if self.experiment_type == 'WingMuscle':\n            angle_widget = widgets.fixed(0)               # Angle is not required for WingMuscle experiment\n            number_widget = widgets.IntText(              # Create IntText to specify number of sections\n                value=3,\n                description='Number of sections',\n                style={'description_width': 'initial'},\n                layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n            )\n        elif self.experiment_type == 'StretchReceptor':\n            angle_widget = widgets.BoundedFloatText(      # Create BoundedFloatText to specify angle\n                value='0',\n                placeholder='Type angle',\n                description='Angle',\n                style={'description_width': 'initial'},\n                layout=widgets.Layout(width=input_width, height=input_height),\n                min=0, max=360, step=5\n            )\n            number_widget = widgets.fixed(1)\n    \n        # Generate user interface to control function arguments: widgets\n        widget = widgets.interactive(\n            self.get_file_properties,                     # Call function which will be controlled\n            file_label=widgets.fixed(file_label),         # The file_label and path_to_file are already known\n            path_to_file=widgets.fixed(path_to_file),\n            use=widgets.Checkbox(                         # Create checkbox to specify whether to use this file\n                value=False,\n                description=file_label,\n                indent=False,\n                layout=widgets.Layout(height=input_height),\n            ),\n            angle=angle_widget,                           # Defined above\n            number_of_sections=number_widget,\n        )\n        \n        # Inspect file\n        self.output = widgets.Output()\n        if self.experiment_type == 'WingMuscle':\n            # Load file\n            df = pd.read_csv(path_to_file, sep=sep, header=0)\n            with self.output:\n                # Plot normalised column data\n                fig, ax = plt.subplots(1, 1)\n                for column in df.columns.values:\n                    if 'time' in column.lower():\n                        # Do not print time for now\n                        continue\n\n                    values = df[column]\n                    values_norm = (values - values.min()) \/ (values.max() - values.min())\n                    ax.plot(df[column], label=column)\n                # # Format\n                ax.set_xlim([df.index.min(), df.index.max()])\n                ax.set_xlabel('Index')\n                ax.set_ylabel('Norm. values')\n    \n        # Display widgets in horizontal format\n        display(widgets.VBox([\n            widgets.HBox(widget.children),\n            self.output,\n        ]))\n        \n    def get_file_properties(self, file_label, path_to_file, use=bool(), angle=float(), number_of_sections=int()):\n        \"\"\"Store the properties of each file.\n        Args:\n            file_label (str): label of each file\n            path_to_file (Path): path to file\n            use (bool): If True, use this file in the analysis\n            angle (float): Corresponding wing stretch angle, only for StretchReceptor\n            number_of_sections (int): Number of sections to be analysed, only for WingMuscle\n\n        Returns:\n            file_properties (dict): dictionary with properties of each file\n        \"\"\"\n        # We create a new dictionary within file_properties for each file and store angle and path_to_file\n        self.file_properties[file_label] = dict()\n        self.file_properties[file_label]['angle'] = angle\n        self.file_properties[file_label]['number_of_sections'] = number_of_sections        \n        self.file_properties[file_label]['path'] = path_to_file\n    \n        # Remove file if usage is set to False\n        if not use:\n            _ = self.file_properties.pop(file_label)\n        \n    def create_analysis_classes(self):\n        \"\"\"Create all analysis classes based on file properties dictionary\"\"\"\n        self.analysis_class_list = list()\n        \n        # Loop over all files\n        for file_label, value_dict in self.file_properties.items():\n            for section_number in range(value_dict['number_of_sections']):\n                file_analysis_class = FileAnalysis(                 # Create class for each file\n                        file_label=file_label,\n                        section_label=str(section_number + 1),      # Start counting from one instead of zero\n                        path_to_data=value_dict['path'],\n                        alpha=value_dict['angle'],\n                        experiment_type=self.experiment_type,\n                        number_of_sections=value_dict['number_of_sections']\n                    )\n                self.analysis_class_list.append(file_analysis_class) # Append to analysis_class_list\n\n        # Check if any FileAnalysis classes are created\n        if not len(self.analysis_class_list):\n            warnings.warn(\"No FileAnalysis classe(s) created. Did you select any file(s)?\")\n        else:\n            print(f'FileAnalysis class succesfullly created for {len(self.analysis_class_list)} class(es).')\n          \n        # Return analysis class list for further usage\n        return self.analysis_class_list\n\n# #######################################################\n# FileAnalysis\n# #######################################################\nclass FileAnalysis:\n    \"\"\"Class to perform the analysis of each file\"\"\"\n    def __init__(self, file_label, section_label, path_to_data, alpha, number_of_sections, experiment_type):\n        \"\"\"\n        Args:\n            file_label (str): label of each file\n            section_label (str): label of each sectio\n            path_to_data (Path): path to file\n            alpha (float): corresponding wing stretch angle, only for 'StretchReceptor'\n            number_of_sections (int): number of sections\n            experiment_type (str): type of experiment. Either 'StretchReceptor' or 'WingMuscle'\n        \"\"\"\n        # Store all initial variables\n        self.file_label = file_label\n        self.section_label = section_label\n        self.path_to_data = Path(path_to_data)\n        self.alpha = alpha\n        self.number_of_sections = number_of_sections\n        self.experiment_type = experiment_type\n        self.chained_assignment_ignore = self.ChainedAssignment()\n\n        # Define caption and path based on experiment type\n        if self.experiment_type == 'WingMuscle':\n            self.caption = widgets.Label(value=f'File {self.file_label} Section {self.section_label}:')\n            self.save_path = file_label.replace('.txt', '').replace('\/', '_') + '_' + section_label\n        elif self.experiment_type == 'StretchReceptor':\n            self.caption = widgets.Label(value=f'File {self.file_label}:')\n            self.save_path = file_label.replace('.txt', '').replace('\/', '_')\n\n\n    # ChainedAssignment\n    class ChainedAssignment:\n        \"\"\"Nested class to suppress 'ChainedAssignment' warnings.\"\"\"\n        def __init__(self, chained=None):\n            acceptable = [None, 'warn', 'raise']\n            assert chained in acceptable, \"chained must be in \" + str(acceptable)\n            self.swcw = chained\n\n        def __enter__(self):\n            self.saved_swcw = pd.options.mode.chained_assignment\n            pd.options.mode.chained_assignment = self.swcw\n            return self\n\n        def __exit__(self, *args):\n            pd.options.mode.chained_assignment = self.saved_swcw\n\n    # ####################################\n    # LOAD DATAFRAME\n    # ####################################\n    def load_data(self):\n        \"\"\"Read .txt file into a pandas DataFrame\"\"\"\n        # Read text file\n        self.df = pd.read_csv(self.path_to_data, sep=sep, header=0)\n        \n        # Calculate initial properties\n        self.time_range = (self.df.index.min(), self.df.index.max())\n        self.dt = self.df.index[1] - self.df.index[0]\n        \n        # Preallocate other dataframes\n        self.df_time = self.df\n\n    # ####################################\n    # SET COLUMN NAMES\n    # ####################################\n    def set_column_names(self, predict=False):\n        \"\"\"The column names in the text file do not necessarily describe the value in the columns.\n        This function creates the widgets to inspect column values and store column name relations.\n\n        Args:\n            predict (bool): If True, predict column names on old column names\n        \"\"\"\n        # Load data again to be sure to have a 'fresh' dataset\n        self.load_data()\n        \n        w_list = list()\n        self.rename_dict = dict()\n    \n        # Set options based on experiment type\n        if self.experiment_type == 'WingMuscle':\n            options = ['', 'Time (s)', 'Time (ms)', 'Signal']\n        elif self.experiment_type == 'StretchReceptor':\n            options = ['', 'Time (s)', 'Time (ms)', 'Stimulus', 'Signal']\n        else:\n            warnings.warn(f'experiment_type \"{self.experiment_type}\" must be \"WingMuscle\" or \"StretchReceptor\"')\n                             \n        for num, old_name in enumerate(self.df.columns):\n            value = ''\n            # Predict column_name based on old_name\n            if predict and self.experiment_type == 'WingMuscle':\n                if 'time' in old_name.lower():\n                    value = 'Time'\n                elif 'Ch1' in old_name:\n                    value = 'Signal'\n                elif 'Ch2' in old_name:\n                    value = 'Stimulus'  if self.experiment_type == 'StretchReceptor' else 'Signal'\n            elif predict and self.experiment_type == 'StretchReceptor':\n                value = ['Time (ms)', 'Signal', 'Stimulus', ''][num]\n                    \n            # Create widget and append to list of widgets\n            w_list.append(\n                widgets.interactive(\n                    self.update_column_name,\n                    old_name=widgets.fixed(old_name),\n                    new_name=widgets.Dropdown(\n                        options=options,\n                        description=old_name,\n                        value=value,\n                        layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n                    ),\n                )\n            )\n\n        # Display all widgets in desired layout\n        display(\n            widgets.VBox([\n                self.caption,\n                widgets.HBox([w for w in w_list])\n            ])\n        )\n    \n    def update_column_name(self, old_name=str(), new_name=str()):\n        \"\"\"Store column name relation and inspect column.\n\n        Args\n            old_name (str): old column name\n            new_name (str): new column name\n        \"\"\"\n        # Store column name relation\n        self.rename_dict[old_name] = new_name\n    \n        # Inspect column value\n        values = self.df[old_name]\n        if self.experiment_type == 'WingMuscle':\n            values = values[:1000]  # plot first 1000 values only\n\n        # Inspect columns\n        fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(fig_width\/4, fig_height))\n        ax.plot(values, color='steelblue')\n        # # Format\n        ax.set_xlabel('Index')\n        ax.set_ylabel(old_name)\n        ax.set_xlim([values.index.min(), values.index.max()])\n    \n    def rename_columns(self):\n        \"\"\"Actually rename each column\"\"\"\n        # Check column name entries\n        if not len([e for e in self.rename_dict.values() if e != '']):\n            warnings.warn(\"Please set any column names first\")\n            return\n        for key, value in self.rename_dict.items():\n            if 'time' in key.lower() and 'time' not in value.lower():\n                warnings.warn(f\"Please check your column name entry for {key}\")\n                return\n        \n        # Load data again to be sure to have a 'fresh' dataset\n        self.load_data()\n\n        # Loop over old column names\n        for old_name, new_name in self.rename_dict.items():\n            if new_name == '':  # Remove column\n                self.df.drop(columns=old_name, inplace=True, errors='ignore')\n            else:  # Rename column\n                if 'time' in new_name.lower():\n                    if '(ms)' in new_name:\n                        self.df[new_name] *= 1E-3  # Set to seconds\n                    new_name = 'Time'\n                self.df.rename(\n                    columns={old_name: new_name},\n                    inplace=True,\n                    errors='ignore',  # ignore if old_name is not present\n                )\n                \n        # Check if required columns are present\n        if 'Time' not in self.df.columns or 'Signal' not in self.df.columns:\n            warnings.warn(\"Please check the column settings.\")\n                \n        # Set time to dataframe index\n        if 'Time' not in self.df.index.names:\n            self.df.set_index('Time', drop=True, inplace=True)\n            \n    # ####################################\n    # SET TIME RANGE\n    # ####################################\n    def update_time_range(self, time_range=(None, None)):\n        \"\"\"Update requested time range and plot values for corresponding range.\n        \n        Args:\n            time_range (Float, Float): requested time range \n        \"\"\"\n        # Store time range\n        self.time_range = time_range\n        \n        # Plot values for corresponding range\n#         df = self.df.loc[self.time_range[0]:self.time_range[1]]         # Get rows within time range\n        \n        fig, ax = plt.subplots(nrows=1, ncols=1)\n        sign_norm = self.normalise(self.df['Signal'], shift=False)           # Normalise values\n        sign_norm = sign_norm.loc[self.time_range[0]:self.time_range[1]]\n        ax.plot(sign_norm, color='steelblue', label='Signal')\n        if self.experiment_type == 'StretchReceptor':\n            # No Stimulus in WingMuscle experiment\n            stim_norm = self.normalise(self.df['Stimulus'])                  # Normalise values\n            stim_norm = stim_norm.loc[self.time_range[0]:self.time_range[1]]\n            ax.plot(stim_norm, color='lightcoral', label='Stimulus')\n        # # Format\n        ax.set_xlim([time_range[0], time_range[1]])\n#         ax.set_ylim([0 - 0.01, 1 + 0.01])\n        ax.set_xlabel('Time [s]')\n        ax.set_ylabel('Values (normalised)')\n        ax.legend(bbox_to_anchor=(1, 0.5))\n            \n    def set_time_range(self, value=None):     \n        \"\"\"Create widget to set time range\"\"\"\n        if isinstance(value, type(None)):\n            value = [self.df.index.min(), self.df.index.max()]\n        \n        self.time_range_widget = widgets.interactive(\n            self.update_time_range,                                       # Function call\n            time_range=widgets.FloatRangeSlider(                          # Create FloatRangeSlider\n                value=value,\n                min=self.df.index.min(), max=self.df.index.max(), step=1, # Set slider limits\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Time range',\n                continuous_update=False,                                  # Set to False to improve performance\n            ),\n        )\n        display(self.caption,self.time_range_widget)\n        \n    def store_time_range(self):\n        \"\"\"Store time range\"\"\"\n        self.df_time = self.df.loc[self.time_range[0]:self.time_range[1]]\n#         self.dt = self.df_time.index[1] - self.df_time.index[0]         # Update time steps\n    \n    # ####################################\n    # SET STIMULUS ON AND OFFSET\n    # Only for StretchReceptor experiment\n    # ####################################\n    def set_stim_onoffset(self, downsampling_plot=100, downsampling_dt=100, dt_height=4):\n        \"\"\"Create widget to set stimulus start and end\"\"\"\n        self.downsampling_plot = downsampling_plot\n        self.downsampling_dt = downsampling_dt\n        self.dt_height = dt_height\n        \n        if self.experiment_type == 'WingMuscle':\n            # We don't need this function for WingMuscle experiment\n            return\n\n        # Downsample data to speed up query\n        df = self.df_time.iloc[::self.downsampling_dt, :]\n        \n        self.stim_time_range_widget = widgets.interactive(\n            self.update_stim_onoffset,                          # Call function\n            df=widgets.fixed(df),\n            height=widgets.FloatSlider(\n                value=df['Stimulus'].min(),     # prev: value=df['Stimulus'].max() * 2\/3 - By default set threshold to two thirds\n                min=df['Stimulus'].min(), max=df['Stimulus'].max(), step=0.01,\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Height'\n            )\n        )\n        display(self.caption, self.stim_time_range_widget)      # Show widget\n    \n    def update_stim_onoffset(self, df, height):\n        \"\"\"Update start and end times of stimulus and plot corresponding results.\n        \n        Args:\n            height (float): minimum height of stimulus to be on \n        \"\"\"\n        # Detect start and end times of stimulus based on changes in time values\n        df_sel = df.query('Stimulus > @height')       # Select rows for which stimulus is above threshold\n        t_sel = df_sel.index.values                             # Extract time stamps of selected rows\n        dt_sel = np.diff(t_sel)                                 # Calculate derivative of time stamps\n        \n        # Detect jumps in derivative of time stamps: where the stimulus stops and starts\n        dt_peak_inds, _ = find_peaks(x=dt_sel, height=self.dt_height)\n#         print(f'dt_height: {self.dt_height}')\n#         plt.figure()\n#         plt.plot(t_sel[1:], dt_sel)\n#         plt.axhline(y=self.dt_height)\n        \n        # Convert peak indices into start and end times\n        self.stim_start_times = [t_sel[0]]                      # Initial value is always a start\n        self.stim_end_times = [t_sel[-1]]                       # Final value is always a end\n        for peak in dt_peak_inds:                               # Loop over peak indices\n            self.stim_start_times.append(t_sel[peak + 1])       # Add next time stamp as start\n            self.stim_end_times.append(t_sel[peak])             # Add time stamp as end\n        self.stim_start_times.sort()                            # Sort the time stamps chronologically\n        self.stim_end_times.sort()\n\n        # Ouput\n        fig, ax = plt.subplots(nrows=1, ncols=1)\n        ax.plot(self.df_time['Stimulus'][::self.downsampling_plot], color='steelblue')    # Stimulus in sampled version\n        ax.axhline(y=height, color='k', linestyle='dashed')     # Threshold line\n        # Plot stimulus start and end\n        for stim_start_time, stim_end_time in zip(self.stim_start_times, self.stim_end_times):\n            ax.axvspan(stim_start_time, stim_end_time, color='lightcoral', alpha=0.5, zorder=-10)\n        # # Format\n        ax.set_ylim([df['Stimulus'].min() - 0.01, df['Stimulus'].max() + 0.01])\n        ax.set_xlim([df.index.min(), df.index.max()])\n        ax.set_ylabel('Stimulus')\n        ax.set_xlabel('Time [s]')\n        \n    # ####################################\n    # DETECT PEAKS\n    # ####################################    \n    def set_peaks(self, distance=10):\n        \"\"\"Select correct function\"\"\"\n        self.distance = distance\n        if self.experiment_type == 'WingMuscle':\n            self.set_peaks_wingmuscle()\n        elif self.experiment_type == 'StretchReceptor':\n            self.set_peaks_stretchreceptor()                             \n\n    # Wing Muscle            \n    def set_peaks_wingmuscle(self):\n        \"\"\"Create widget to set peaks in Wing muscle experiment\"\"\"\n        self.depressor_times = list()\n        self.elevator_times = list()\n        self.search_width = 0.005  # seconds\n        \n        # Create widget to plot function\n        self.peaks_widget = widgets.interactive(\n            self.plot_peaks_wingmuscle,\n            time=widgets.FloatSlider(\n                value=(self.time_range[-1] - self.time_range[0])\/2,  # Set initial value halfway\n                min=self.time_range[0], max=self.time_range[-1], step=self.search_width,\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Time [s]',\n                readout_format='.3f',\n                continuous_update=False,\n            )\n        )\n        # Show widget\n        display(self.caption, self.peaks_widget)  \n        \n        # Create widgets to store time stamps\n        depressor_button = widgets.Button(description=\"Add depressor\")\n        elevator_button = widgets.Button(description=\"Add elevator\")\n        depressor_remove_button = widgets.Button(description=\"Remove depressor\")\n        elevator_remove_button = widgets.Button(description=\"Remove elevator\")\n        remove_all_button = widgets.Button(description=\"Remove all\")\n        self.output = widgets.Output()\n        # Show widgets\n        display(widgets.VBox([\n            widgets.HBox([depressor_button, depressor_remove_button]),\n            widgets.HBox([elevator_button, elevator_remove_button]),\n            remove_all_button,\n            self.output,\n        ]))\n\n        # Link widgets\n        depressor_button.on_click(self.on_depressor_button_clicked)\n        elevator_button.on_click(self.on_elevator_button_clicked)\n        depressor_remove_button.on_click(self.on_depressor_remove_button_clicked)\n        elevator_remove_button.on_click(self.on_elevator_remove_button_clicked)\n        remove_all_button.on_click(self.on_remove_all_button_clicked)\n                \n    def on_depressor_button_clicked(self, b):\n        self.depressor_times.append(self.peak_time)\n        with self.output:\n            print(f\"Depressor stored at {self.peak_time} s\")\n            \n    def on_elevator_button_clicked(self, b):\n        self.elevator_times.append(self.peak_time)\n        with self.output:\n            print(f\"Elevator stored at  {self.peak_time} s\")\n    \n    def on_depressor_remove_button_clicked(self, b):\n        if self.peak_time in self.depressor_times:\n            self.depressor_times.remove(self.peak_time)\n            with self.output:\n                print(f\"Depressor removed at {self.peak_time} s\")\n        else:\n            with self.output:\n                print(f\"No depressor peak stored at {self.peak_time} s\")\n            \n    def on_elevator_remove_button_clicked(self, b):\n        if self.peak_time in self.elevator_times:\n            self.elevator_times.remove(self.peak_time)            \n            with self.output:\n                print(f\"Evelvator removed at {self.peak_time} s\")\n        else:\n            with self.output:\n                print(f\"No elevator peak stored at {self.peak_time} s\")\n                \n    def on_remove_all_button_clicked(self, b):\n        self.elevator_times = list()\n        self.depressor_times = list()\n        with self.output:\n            print(\"Removed all stored spikes.\")\n                      \n    def plot_peaks_wingmuscle(self, time=float()):\n        \"\"\"Inspect signal and plot detected peaks\n        \n        Args:\n            time (float): time stamp of slider \n        \"\"\"\n        # Detect closest peak\n        signal = self.df_time.loc[time-self.search_width:time+self.search_width, 'Signal']\n        self.peak_time = signal.abs().idxmax()\n        if self.peak_time:\n            peak_value = self.df_time.loc[self.peak_time, 'Signal']\n        else:\n            peak_value = None\n        \n        # Plot\n        fig, ax = plt.subplots(nrows=1, ncols=1)\n        ax.plot(self.df_time['Signal'], color='steelblue', label='Signal')             # Signal\n        # Indicate search area\n        ax.axvspan(time-self.search_width, time+self.search_width, alpha=0.5, color='lightcoral', zorder=-200)\n        ax.plot(self.peak_time, peak_value, 'o', color='k', alpha=0.5, zorder=20)     # Show value of local peak\n        # Depressor times\n        for depressor_time in self.depressor_times:\n            ax.plot(depressor_time, self.df_time['Signal'][depressor_time], 'v', color='lightcoral')\n        # Elevator times\n        for e_time in self.elevator_times:\n            ax.plot(e_time, self.df_time['Signal'][e_time], '^', color='tab:green')\n        # Format\n        ax.set_xlim(self.time_range)\n        ax.set_xlabel('Time [s]')\n        ax.set_ylabel('Signal')\n       \n    def preprocess_peaks(self):\n        \"\"\"Keep only unique and alternating peak times\"\"\"\n        if len(self.depressor_times) == 0:\n            import random\n            print(f\"{self.file_label} section {self.section_label}: No depressor peaks found; random peaks are created\")\n            self.depressor_times = random.sample(range(10, 30), 5)\n            self.elevator_times = random.sample(range(10, 30), 5)\n            \n        # Get unique peak times\n        depressor_times = sorted(set(self.depressor_times))\n        elevator_times = sorted(set(self.elevator_times))\n\n        # Keep only E peaks that occur after first D peak\n        first_depressor_peak_time = min(depressor_times)\n        elevator_times = [x for x in elevator_times if x > first_depressor_peak_time]\n\n        # Make peak lists same length\n        min_length = min(len(depressor_times), len(elevator_times))\n        self.depressor_times_neat = depressor_times[:min_length]\n        self.elevator_times_neat = elevator_times[:min_length]\n        return self.depressor_times_neat, self.elevator_times_neat        \n                             \n# Stretch Receptor\n    def set_peaks_stretchreceptor(self): \n        \"\"\"Create widget to set peaks in Stretch receptor experiment\"\"\"        \n        self.peaks_widget = widgets.interactive(\n            self.update_peaks_stretchreceptor,              # Function call\n            height=widgets.FloatSlider(\n                value=0.9, #used to be value=0.5\n                min=0, max=1, step=0.01,\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Height',\n                readout_format='.3f',\n                continuous_update=False,\n                style={'description_width': 'initial'},\n            ),\n            distance=widgets.fixed(25),\n#             distance=widgets.BoundedIntText(\n#                 value=25,\n#                 min=1, max=10000, step=1,\n#                 layout=widgets.Layout(width=input_width, height=input_height),\n#                 description=f'Distance (index)',\n#                 style={'description_width': 'initial'},\n#             ),\n            time_range=widgets.FloatRangeSlider(                          # Create FloatRangeSlider\n                value=[self.time_range[0], self.time_range[1]],\n                min=self.time_range[0], max=self.time_range[1], step=0.5, # Set slider limits\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Time range (s)',\n                continuous_update=False,                                  # Set to False to improve performance\n                style={'description_width': 'initial'},\n            ),\n        )\n        # Show widgets\n        display(self.caption, self.peaks_widget)\n                             \n    def update_peaks_stretchreceptor(self, height, distance, time_range=(None, None)):\n        \"\"\"Detect peaks and plot corresponding result\n        \n        Args:\n            height (float): threshold for peaks \n            distance (int): minimum distance between peaks (in indices) \n            zoom (bool): If True, plot a zoomed in version \n        \"\"\"\n        # Get normalised values\n        sign_norm = self.normalise(self.df_time['Signal'], shift=False)\n        stim_norm = self.normalise(self.df_time['Stimulus'])\n        \n        # Change to number of dt steps\n        distance_dt = distance\n\n        # Find peaks\n        self.peak_inds, _ = find_peaks(\n            sign_norm.abs().values,\n            height=height, distance=distance_dt\n        )\n        self.peak_times = self.df_time.index[self.peak_inds]                 # Store corresponding times\n        self.peak_values = self.df_time['Signal'].values[self.peak_inds]     # Get peak heights\n        \n        # Set peaks\n        with self.chained_assignment_ignore:\n            self.df_time['peaks'] = 0\n            self.df_time.loc[self.peak_times, 'peaks'] = 1\n        \n        # Plot result\n        fig, ax = plt.subplots(nrows=1, ncols=1)\n        ax.plot(sign_norm, color='steelblue', label='Signal')                           # Signal\n        ax.plot(self.peak_times, sign_norm.values[self.peak_inds],\n                'o', color='lightcoral', zorder=-10)                                    # Peaks\n        ax.plot(stim_norm, color='lightcoral', label='Stimulus', alpha=0.5, zorder=20) # Stimulus\n        ax.axhline(y=height, linestyle='dashed', color='k', alpha=0.5, zorder=5)        # Threshold\n        ax.axhline(y=-height, linestyle='dashed', color='k', alpha=0.5, zorder=5)\n        # # Format\n        ax.set_xlim([time_range[0], time_range[1]])      \n#         if zoom:\n#             ax.set_xlim([self.stim_start_times[0], self.stim_end_times[0]])\n#         else:\n#             ax.set_xlim([self.df_time.index.min(), self.df_time.index.max()])\n        ax.set_ylabel('Signal (normalised)')\n        ax.set_xlabel('Time [s]')\n        ax.legend(bbox_to_anchor=(1, 0.5))\n    \n                             \n    # ####################################\n    # ANALYSE PEAKS\n    # ####################################\n   # def analyse_peaks(self, fit_func_name='Linear'):\n    def analyse_peaks(self, fit_func_name):       \n        \"\"\"Select right function\"\"\"\n        if self.experiment_type == 'WingMuscle':\n            pass\n        elif self.experiment_type == 'StretchReceptor':\n            self.analyse_peaks_stretchreceptor(fit_func_name)\n            \n    # Stretch Receptor\n    def analyse_peaks_stretchreceptor(self, fit_func_name):\n        \"\"\"Prepare widget to analyse peaks\"\"\"\n        self.analysis_widgets = list()\n        self.fit_coefficients = list()\n        self.max_frequencies = list()\n        \n        # Create widget to set fit function name\n        \n        if fit_func_name:\n            self.set_fit_func(fit_func_name)\n        else:\n            self.create_fit_func_widget()\n       \n        for num, (stim_start_time, stim_end_time) in enumerate(zip(self.stim_start_times, self.stim_end_times)):\n            # Extract values within stimulus    \n            df = self.df_time.query('@stim_start_time < Time <= @stim_end_time')\n        \n            self.fit_coefficients.append(np.nan)\n            self.max_frequencies.append(np.nan)            \n            self.analysis_widgets.append(\n                self.create_analysis_widget_stretchreceptor(num, stim_start_time, stim_end_time, df)\n            )\n            \n        # Show widgets\n        display(self.caption, widgets.HBox([w for w in self.analysis_widgets]))\n    \n    def create_fit_func_widget(self):\n        w = widgets.interact(\n                self.set_fit_func,\n                fit_func_name=widgets.Dropdown(\n                    options=['Exponential', 'Linear'],\n                    value='Linear',\n                    description='Fit function',\n                    layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n                    style={'description_width': 'initial'},\n                )\n        )\n        display(w);\n        \n    def set_fit_func(self, fit_func_name):\n        self.fit_func_name = fit_func_name.lower()\n    \n    def create_analysis_widget_stretchreceptor(self, num, stim_start_time, stim_end_time, df):\n        \"\"\"Create widget to analyse peaks\"\"\"\n#         # Extract values within stimulus    \n#         df = self.df_time.query('@stim_start_time < Time <= @stim_end_time')\n#         df.index -= stim_start_time  # Shift time to start\n            \n        # Create widget\n        analysis_widget = widgets.interactive(\n            self.update_analysis_peaks_stretchreceptor,\n            bin_size=widgets.BoundedFloatText(\n                value=1,\n                min=0.1, max=10.1, step=0.1,\n                layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n                description=f'Bin size (s)',\n            ),\n            df=widgets.fixed(df),\n            num=widgets.fixed(num),\n          \n        #    fit_type=widgets.Dropdown(\n        #         options=['Exponential', 'Linear'],\n        #         value='Linear',\n        #         description='Fit function',\n        #        layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n        #        style={'description_width': 'initial'},\n        #     )\n        )\n        \n        return analysis_widget\n    \n    def update_analysis_peaks_stretchreceptor(self, bin_size, df, num):\n        \"\"\"Calculate frequency for bin settings, and plot results\"\"\"\n        # Select peaks within stimulus onset\n        stim_start_time = self.stim_start_times[num]\n        stim_end_time = self.stim_end_times[num]\n        peak_inds = np.asarray(self.peak_inds)\n        peak_times = np.asarray(self.peak_times)\n        mask = (peak_times >= stim_start_time) & (peak_times <= stim_end_time)\n        peak_inds = peak_inds[mask]\n        peak_times = peak_times[mask]\n                \n        # Bin peaks\n        bin_times = np.arange(stim_start_time, stim_end_time + bin_size, bin_size)\n        bin_times -= bin_times % bin_size\n        peak_times_binned = peak_times - peak_times % bin_size  # set bins\n        peak_counts = []\n        for bin_time in bin_times:\n            inds = [e for e in (peak_times_binned) if e == bin_time]\n#             print(f'{bin_time} | {inds} | {len(inds)}')\n            peak_counts.append(len(inds))\n        peak_counts = np.asarray(peak_counts)\n        \n        # Calculate frequency\n        freq = peak_counts \/ bin_size\n        freq_norm = self.normalise(freq)\n        time = bin_times\n        # Extract normalised signal and stimulus\n        signal_norm = self.normalise(df['Signal'], shift=False)\n        stimul_norm = self.normalise(df['Stimulus'])\n        \n        # Check\n#         print('bin_times', bin_times)\n#         print('peak_times_binned', peak_times_binned)\n#         print('peak_counts', peak_counts)\n#         print('freq', freq)\n#         plt.figure()\n#         plt.plot(peak_times_binned, peak_times, '.', alpha=0.2) \n#         plt.figure()\n#         plt.plot(bin_times, peak_counts, '.', alpha=0.2)\n        \n        \n        # Fit frequency to exponential decay and store results\n        if self.fit_func_name == 'exponential':\n            A, K, _, freq_fit, time_fit = self.fit_exp_nonlinear(time, freq)\n            self.fit_coefficients[num] = (K)\n        elif self.fit_func_name == 'linear':\n            A, C, freq_fit, time_fit = self.fit_linear(time, freq)\n            self.fit_coefficients[num] = A\n        self.max_frequencies[num] = max(freq)\n        \n        # Plot\n        fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(fig_width \/ 2, 2*fig_height))\n        axes[0].plot(signal_norm, color='steelblue', label='Signal', alpha=0.5)\n        axes[0].plot(stimul_norm, color='lightcoral', label='Stimulus', alpha=0.5)\n#         axes[0].plot(peak_times, [0.5] * len(peak_times), '.', color='lightcoral', label='Peaks')\n        axes[0].plot(time, freq_norm, '-', color='k', label='Frequency')\n        # # Format\n        axes[0].set_ylabel('Values (normalised)')\n        axes[0].set_xlabel('Time [s]')\n        axes[0].set_xlim([signal_norm.index.min(), signal_norm.index.max()])\n        axes[0].legend(bbox_to_anchor=(1, 0.5))\n        # Fit\n        axes[1].plot(time, freq, color='k', label='Frequency')\n        axes[1].plot(time_fit, freq_fit, color='lightcoral', linestyle='dashed', label='Fit')\n        # # Format\n        axes[1].set_ylabel('Frequency [Hz]')\n        axes[1].set_xlabel('Time [s]')\n        axes[1].set_xlim([signal_norm.index.min(), signal_norm.index.max()])\n        axes[1].legend(bbox_to_anchor=(1, 0.5))\n        \n    # ####################################\n    # Helper functions\n    # ####################################\n    @staticmethod\n    def normalise(values, shift=True):\n        \"\"\"Normalise values between -1 and 1\n\n        Args:\n            values (pd.DataFrame): values to be normalised\n        Returns:\n            pd.DataFrame\n        \"\"\"\n        if shift:\n            return (values - values.min()) \/ (values.max() - values.min())\n        else:\n            return values \/ values.abs().max()\n    \n    @staticmethod\n    def model_func_exp(t, A, K, C):\n        \"\"\"Exponential function\n\n        Args:\n            t (list): time stamps\n            A (float): amplitude\n            K (float): exponential decay coefficient\n            C (float): offset\n\n        Returns:\n            list\n        \"\"\"\n        return A * np.exp(K * t) + C\n    \n    @staticmethod\n    def model_func_lin(t, A, C):\n        \"\"\"Linear function\n        \n        Args:\n            t (array): time stamps\n            A (float): slope\n            C (float): intercept\n        \n        Returns:\n            list\n        \"\"\"\n        t = np.asarray(t)  # Convert to numpy array if t is a list\n        return A * t + C\n        \n    def fit_exp_nonlinear(self, t, y):\n        \"\"\"Fit data to exponential function\n\n        Args:\n            t (list): time stamps\n            y (list): values\n\n        Returns:\n            A (float): amplitude\n            K (float): exponential decay coefficient\n            C (float): offset\n            y_fit (list): fitted function\n        \"\"\"\n        warnings.simplefilter(\"error\", sp.optimize.OptimizeWarning)     # Catch OptimizeWarning as Exception\n        opt_parms = np.nan, np.nan, np.nan                              # Predefine values\n        \n        # Start from maximum value\n        max_ind = np.argmax(y)\n        t = t[max_ind:]\n        y = y[max_ind:]\n        \n        try:\n            # Optimise to exponential function\n            opt_parms, parm_cov = sp.optimize.curve_fit(self.model_func_exp, t, y, maxfev=2000)\n        except sp.optimize.OptimizeWarning:\n            warnings.warn(f'Fit unsuccessful, please try with other bin size.')\n        except:\n            warnings.warn(f'Fit unsuccessful, please try with other bin size.')\n        A, K, C = opt_parms\n        \n        y_fit = self.model_func_exp(t, A, K, C)\n        return A, K, C, y_fit, t\n    \n    def fit_linear(self, t, y):\n        \"\"\"Fit data to linear function\n\n        Args:\n            t (list): time stamps\n            y (list): values\n\n        Returns:\n            t (array): time stamps\n            A (float): slope\n            C (float): intercept\n            y_fit (list): fitted function\n        \"\"\"\n        warnings.simplefilter(\"error\", sp.optimize.OptimizeWarning)     # Catch OptimizeWarning as Exception\n        opt_parms = np.nan, np.nan                              # Predefine values\n        try:\n            # Optimise to exponential function\n            opt_parms, parm_cov = sp.optimize.curve_fit(self.model_func_lin, t, y, maxfev=2000)\n        except sp.optimize.OptimizeWarning:\n            warnings.warn(f'Fit unsuccessful, please try with other bin size.')\n        except:\n            warnings.warn(f'Fit unsuccessful, please try with other bin size.')\n        A, C = opt_parms\n        \n        y_fit = self.model_func_lin(t, A, C)\n        return A, C, y_fit, t\n\nclass WingMuscleAnalysis:\n    \"\"\"Class for specific WingMuscle analysis\"\"\"\n    def __init__(self, analysis_class_list):\n        \"\"\"\n        Args:\n            analysis_class_list (list): list of FileAnalysis classes \n        \"\"\"\n        self.analysis_class_list = analysis_class_list\n        \n        # Get number of sections\n        self.number_of_sections = self.analysis_class_list[0].number_of_sections\n        self.save_path = self.analysis_class_list[0].save_path\n         \n    def combine_peaks(self):\n        \"\"\"Extract peaks from analysis classes in analysis_class_list and combine in numpy array\"\"\"\n        # Extract times from analysis classes\n        self.depressor_times = []\n        self.elevator_times = []\n        for analysis_class in self.analysis_class_list:\n            depressor_times, elevator_times = analysis_class.preprocess_peaks()\n            self.depressor_times.append(depressor_times)\n            self.elevator_times.append(elevator_times)\n\n        # Combine to numpy array\n        # # Get maximum length\n        max_length = max(map(len, self.depressor_times + self.elevator_times))\n        d = np.empty((self.number_of_sections, max_length))\n        d[:] = np.NaN\n        e = np.empty((self.number_of_sections, max_length))\n        e[:] = np.NaN\n        # # Fill NaN array\n        for num, (d_time, e_time) in enumerate(zip(self.depressor_times, self.elevator_times)):\n            d[num, :len(d_time)] = d_time\n            e[num, :len(e_time)] = e_time\n        # Extract d0, d1, e0 and e1 values\n        self.d0, self.d1 = d[:, :-1], d[:, 1:]\n        self.e0, self.e1 = e[:, :-1], e[:, 1:]\n        # Expected values\n        self.wbf = 1 \/ (self.d1 - self.d0)\n        self.pr = (self.e0 - self.d0) \/ (self.d1 - self.d0)\n        \n        # Return\n        return self.d0, self.d1, self.e0, self.e1\n    \n    def plot_relation(self, wing_beat_frequency, phase_relation):\n        \"\"\"Plot wing beat frequency to phase relation per section\"\"\"\n        # Check input\n        if wing_beat_frequency.all() != eval('self.wbf').all():\n            warnings.warn(\"Please check the equation for the Wing Beat frequency.\")\n        if phase_relation.all() !=  eval('self.pr').all():\n            warnings.warn(\"Please check the equation for the Phase relation.\")\n                                        \n        # Calculate means\n        wing_beat_frequency_mean = np.nanmean(wing_beat_frequency, axis=1)\n        phase_relation_mean = np.nanmean(phase_relation, axis=1)\n        wing_beat_frequency_std = np.nanstd(wing_beat_frequency, axis=1)\n        phase_relation_std = np.nanstd(phase_relation, axis=1)\n    \n        # Plot wing beat frequency vs phase relation\n        fig, ax = plt.subplots(1, 1, figsize=(fig_width\/2, fig_height))\n        ax.errorbar(wing_beat_frequency_mean, phase_relation_mean, yerr=phase_relation_std, linestyle='none', marker='o')\n        return ax\n    \ndef input_text():\n    input_text = widgets.Text(description=\"Your text here\", style= {'description_width': 'initial'})\n    display(input_text)","c8386e55":"# This is the path to the dataset\npath_to_input_folder = Path('\/kaggle\/input\/stretchreceptor\/')\n\n# Create class to set file properties\nfp = FileProperties(experiment_type)\nfp.set_input_data(path_to_input_folder)  # Creates widgets to set file properties","ae681dec":"analysis_class_list = fp.create_analysis_classes()","66d3d544":"for analysis_class in analysis_class_list:\n    analysis_class.load_data()              # This function reads all selected text files","12030083":"analysis_class.df.head()","d08518ff":"for analysis_class in analysis_class_list:\n    analysis_class.set_column_names(False)","59039a97":"for analysis_class in analysis_class_list:\n    analysis_class.rename_columns()\n\n# Inspect data\nanalysis_class.df.head()","8ab34806":"for analysis_class in analysis_class_list:\n    analysis_class.set_time_range()","852b86b8":"for analysis_class in analysis_class_list:\n    analysis_class.store_time_range()","cc5dd8f1":"for analysis_class in analysis_class_list:\n    analysis_class.set_stim_onoffset()","0b9378e8":"for analysis_class in analysis_class_list:\n    analysis_class.set_peaks()","9e43aec3":"for analysis_class in analysis_class_list:\n    analysis_class.analyse_peaks('Linear')","eb5a24ab":"# Plot decay and maximum frequency per angle\nalphas = []\nfit_coefficients = []\nmax_frequencies = []\n\n# Create figure\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(fig_width, 2*fig_height), sharex='all')\n\n# Combine results over files\nfor analysis_class in analysis_class_list:\n    fit_coefficients = analysis_class.fit_coefficients\n    max_frequencies = analysis_class.max_frequencies\n    alpha = analysis_class.alpha\n    \n    ax1.plot([alpha] * len(fit_coefficients), fit_coefficients, '.', color='steelblue')       # Exponential decay or slope\n    ax2.plot([alpha] * len(max_frequencies), max_frequencies, '.', color='steelblue')         # Maximum frequencies\n\n# Format\n# Fill in the x and y label for the Fit coefficients (upper) plot:\nax1.set_xlabel('x')\nax1.set_ylabel('y')\n# Fill in the x and y label for the Max frequencies (lower) plot:\nax2.set_xlabel('x')\nax2.set_ylabel('y');","c84444eb":"# Compact Course: Stretch Receptor\n\nThis notebook will walk you through the analysis pipeline.\nIn order to work with this notebook, click `Edit` in the upper right corner.\n\nEach code cell needs to be run one by one. For this, you select the cell and press `SHIFT + ENTER`. <br>\nWe have combined all code within a few classes, with functions that you can simple run.\nTherefore, you don't have to pay attention to the actual code (although you are of course free to read it).\n\n**NOTE: Do not change the code!** <br>\nThese changes might mess up the analysis pipeline, requiring you to load a new document and start again.\nYou can perform the analysis using the created controls (so-called widgets).\n\n**Before you start:** remember to check your recorded files and change the decimal point from a comma to a dot using the CTRL+h command.","77212b8c":"# Imports and definitions\n#### Import packages\nFirst, we import the required python packages by running the following cell:","89ed02a4":"#### Formatting settings\nThen, we define the following formatting settings (mainly aesthetics):","aebde4da":"# Prepare analysis\n#### Create an analysis class per File\nAfter we have set the properties for each file, we can start the analysis.\nFor this, we create a `FileAnalysis` class for each file and store these in `analysis_class_list`, so we can easily access them later on.","e2a6ff41":"#### Combine results\nFinally, we will combine the results to plot the fit coefficients that show the rate of adaptation (either the slope if you used a linear fit or the coefficient of the exponent if you used an exponential fit) and the maximum frequencies. In the cell below, add the right axis label. Then, take a printscreen of your final figure and hand in the figure with an approporiate title and figure caption. Dont forget to add units, explain what the points and also mention which function you used as a fit.","eb2a1a9d":"How good is the linear fit? To text whether an exponential fit would be more suitable to your recordings, change the argument transmitted to the **analysis_class.analyse_peaks** function in the code above from **'Linear'** to **'Exponential'** and re-run the modified cell.\nIs the fit now better? If not, change it back to **'Linear'** and re-run the code","81fdd4b9":"#### Set time range\nIf desired, we can crop the time range of the data, by denoting a start and end time using the slider.\nFor more precision, the slider values can also be adjusted by selecting the start resp. end button and pressing the left\nor right arrow on your keyboard. Additionally, the values can also be set by selecting the numbers right of the slider, typing the desired values and pressing enter.\nThis has to be done for the data of each file.","f5d8d908":"#### Detect spikes\nNext, we want to detect all spikes in the measured signal. For this, we use a threshold again. Here, all peaks outside\nthe threshold area are detected to be spikes, peaks within the threshold are ignored (e.g. noise).\nThe zoom checkbox can be used to switch between a view of the entire signal and the signal during the first stimulus\nonset.","3432bb92":"#### Set data properties\nNow we can run the following code cell.\nAll text files in the _stretchreceptor_ dataset are shown.\nUse the checkbox in front of each file name to select which files to be used, and specify the corresponding stretch angle.","319c4381":"#### Define functions\nIn addition, we define the following classes that contain all functions we need in this analysis.\n<br>\nIf you want, you can skip reading this code. _(But don't forget to run this code cell.)_","5e2bc10e":"Make sure you have set the correct names for all values above, and run the next code cell to actually rename the columns.\nAn example of what the data now looks like will be given.","453b2f88":"# Analyse spikes\nNow we are going to analyse the detected spikes.\nRunning the code cell below, will generate two figures for each file.\nThe first figure shows values for four different properties:\nthe normalised stimulus (red line), the normalised signal (blue line), detected spikes (red dots),\nand the spike frequency (black line). The spike frequency is only shown for the times where the stimulus is ON.\nThe second figure shows the spike frequency averaged over all stimuli, and a fit to an exponential decay function (red dashed line).\nIf a fit was not possible, no red dashed line will be visible.\n\n\nThis spike frequency is calculated for different time bins: small subsections of time.\nFor each time bin, the number of spikes within that bin is calculated. \nSubsequently, we calculate the spike frequency by dividing the number of spikes by the time length of the bin.\n\nNow, we will vary the bin size such that we get a nice representation of the spike frequency and a good fit of the average will be possible. As a default we will try to fit a linear function to the spike frequency along time. ","e54cbd8c":"#### Load data\nRun the following code cell to read all selected text files. This might take a while...","83365ec7":"#### Detect stimulus\nWe are only interested in the data at the times when the stimulus is present.\nTo detect whether the stimulus is ON or OFFF, we set a certain threshold: when the stimulus value is above this threshold,\nthe stimulus is ON, otherwise the stimulus is OFF. The red shadings indicate the times when the stimulus is detected to\nbe ON. Run the following cell and use the slider to set the correct threshold.\nAgain, this has to be done for the data of each file.","cad084e2":"#### Set column names\nThe text file contains a table, with values for specific properties for each timestamp.\nUsing the following cell, we can see what one of these files currently looks like.","c180e6e5":"## Input data\nNext, you have to upload your experimental data.\nFor this, click on `Add data` in the top right corner of the Kaggle window.\n<div>\n<img src=\"attachment:8054ecaa-7ca0-424c-bfd7-8052618cfa04.png\" width=\"300\"\/>\n<\/div>\n\nWe will upload a new dataset. For this, click `Upload` in the new screen.\n\n<div>\n<img src=\"attachment:95d5331c-3f57-4d44-ad3a-28f636db705d.png\" width=\"400\"\/>\n<\/div>\n\nAdd the text files you want to use and name the dataset _stretchreceptor_. <br>\n**Important:** make sure you give the dataset the correct name. Otherwise you won't be able to read the corresponding files. Finally, click `Create`.\n\n<div>\n<img src=\"attachment:fd6c4e5c-09b5-4359-a21b-6aff075ad232.png\" width=\"300\"\/>\n<\/div>\n\nThe result will look something like this:\n\n<div>\n<img src=\"attachment:6f346289-7253-43d1-afa8-51ff0b096222.png\" width=\"300\"\/>\n<\/div>","1148f2a2":"Make sure you have set the correct time ranges above, and run the next code cell to store these settings.","3f9ea849":"The column names in the data do not necessarily describe the value in the columns.\n<br>\nBy running the following code cell, we can inspect the values in each file.\nEach figure shows the column values, the y axis displays the current name.\n<br>\nThe dropdown widgets have to be used to specify the right name for each column.\nNote that column names that are left empty, will be removed later on."}}