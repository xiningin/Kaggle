{"cell_type":{"e2cee340":"code","14e96c3d":"code","0e4c05ef":"code","b629ea4d":"code","3ab1d05b":"code","13df31ca":"code","58522b8f":"code","4b57132f":"code","f1ce26cf":"code","9357fabc":"code","83fc4e60":"code","d3cf29c0":"code","0f9dab39":"code","a10e9563":"code","2a4ea757":"code","30cf2d32":"code","f0e5c8bb":"code","07698d4b":"code","aae30ee4":"code","295f99f8":"code","fe1eb385":"code","af2c45b7":"code","926ae76c":"code","161fb5cc":"code","4a8bd38e":"code","7ab67fe9":"code","28eba53d":"code","ccf696d8":"code","3a1d5330":"code","d03d85ce":"code","752c18b0":"code","b0d9dbaa":"code","61c69c0f":"code","45c07e7c":"code","7dd6c4f2":"code","70dd547d":"code","32071841":"code","92f32500":"code","6e07f7a3":"code","725271dd":"markdown","7e40414b":"markdown","239c83aa":"markdown","16d4481c":"markdown","15cbd145":"markdown","55bf3644":"markdown","0af4129f":"markdown","93b85b8c":"markdown","79fec088":"markdown","9a5f9023":"markdown","d998843c":"markdown","b8c3cb67":"markdown","431fd5a8":"markdown","433b839b":"markdown","c769d0b1":"markdown","c581082a":"markdown","27660a26":"markdown","4a36ac63":"markdown","84caa765":"markdown","5b2e6e01":"markdown","f29153f3":"markdown","cb913dc6":"markdown","21a3e994":"markdown","ffcbc16d":"markdown","e3435f47":"markdown","c296192b":"markdown","f10e66b8":"markdown","5b25e196":"markdown","d477a895":"markdown","a920ed56":"markdown","c671a5c2":"markdown","093d320f":"markdown","a6a28283":"markdown","7ddf12cb":"markdown","319e483d":"markdown","131e6990":"markdown","7728ba32":"markdown","371829ab":"markdown","b1ebffd0":"markdown","5270939c":"markdown","5e2cd7ba":"markdown","b2cf67de":"markdown","be9e4170":"markdown"},"source":{"e2cee340":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\npd.set_option('display.max_columns', 500)\npd.set_option('display.width', 1000)","14e96c3d":"import requests, zipfile, io\nzipfile.ZipFile(io.BytesIO(requests.get('http:\/\/files.grouplens.org\/datasets\/movielens\/ml-latest-small.zip').content)).extractall()","0e4c05ef":"ls -a ml-latest-small","b629ea4d":"data_movies = pd.read_csv('ml-latest-small\/movies.csv')\ndata_tages = pd.read_csv('ml-latest-small\/tags.csv')\ndata_ratings = pd.read_csv('ml-latest-small\/ratings.csv')","3ab1d05b":"data_movies.head()","13df31ca":"data_movies.movieId.value_counts(),print('Number of duplicated unique ids are: ',data_movies.movieId.duplicated().sum())","58522b8f":"data_tages","4b57132f":"data_tages.movieId.value_counts()","f1ce26cf":"data_ratings","9357fabc":"data_ratings.movieId.value_counts()","83fc4e60":"merge = data_movies.merge(data_tages,on = 'movieId',how = 'inner')","d3cf29c0":"merge","0f9dab39":"merge.drop(columns=['tag','timestamp','genres'],inplace=True)","a10e9563":"merge","2a4ea757":"len(merge.userId.unique()) ","30cf2d32":"merge_list = merge.groupby(by = [\"userId\"])[\"title\"].apply(list).reset_index()\nmerge_list.head()","f0e5c8bb":"merge_list = merge_list[\"title\"].tolist()\nmerge_list[0:3]","07698d4b":"len(merge_list)","aae30ee4":"from mlxtend.preprocessing import TransactionEncoder\nte = TransactionEncoder()\nte_ary = te.fit(merge_list).transform(merge_list)\ndf = pd.DataFrame(te_ary, columns=te.columns_)","295f99f8":"df.head()","fe1eb385":"df.shape","af2c45b7":"from mlxtend.frequent_patterns import apriori\n%time\napriori_frequent_itemsets = apriori(df, min_support=0.01,use_colnames=True,max_len=2)","926ae76c":"apriori_frequent_itemsets['itemsets'].apply(lambda x: len(x)).value_counts()","161fb5cc":"from mlxtend.frequent_patterns import fpgrowth\n%time\nfpgrowth_frequent_itemsets = fpgrowth(df, min_support=0.01, use_colnames=True,max_len=2)\nfpgrowth_frequent_itemsets.head()","4a8bd38e":"fpgrowth_frequent_itemsets['itemsets'].apply(lambda x: len(x)).value_counts()","7ab67fe9":"fpgrowth_frequent_itemsets['length'] = fpgrowth_frequent_itemsets['itemsets'].apply(lambda x: len(x))\nfpgrowth_frequent_itemsets","28eba53d":"fpgrowth_frequent_itemsets[(fpgrowth_frequent_itemsets['length'] > 1)\n                          & (fpgrowth_frequent_itemsets['support'] > 0.06)].head()","ccf696d8":"fpgrowth_frequent_itemsets[(fpgrowth_frequent_itemsets['length'] != 1)]\n","3a1d5330":"fpgrowth_frequent_itemsets[fpgrowth_frequent_itemsets['itemsets'] == {'Step Brothers (2008)', 'Corpse Bride (2005)'}]","d03d85ce":"fpgrowth_frequent_itemsets[fpgrowth_frequent_itemsets['itemsets'].apply(lambda x: 'Step Brothers (2008)' in str(x))]","752c18b0":"import seaborn as sns\nsns.heatmap(data=fpgrowth_frequent_itemsets.corr(method='spearman'),\n           annot=True,\n           vmin=-1,\n           vmax=1,\n           center=0,\n           cmap='YlGnBu');","b0d9dbaa":"fpgrowth_frequent_itemsets.plot.hexbin(x='length',y='support',cmap='viridis',gridsize=20,sharex=False,bins=10);","61c69c0f":"%%time\nfrom mlxtend.frequent_patterns import association_rules\nrules = association_rules(fpgrowth_frequent_itemsets,metric=\"lift\",min_threshold=0.01)","45c07e7c":"rules","7dd6c4f2":"rules[rules[\"antecedents\"].apply(lambda x: \"Inception (2010)\" in str(x))].sort_values(ascending=False,by='lift')","70dd547d":"rules[rules[\"antecedents\"].apply(lambda x: \"Inception (2010)\" in str(x))].groupby(\n    ['antecedents', 'consequents'])[['lift']].max().sort_values(ascending=False,by='lift').head(10)","32071841":"rules[rules[\"antecedents\"].apply(lambda x: \"Inception (2010)\" in str(x))].groupby(\n    ['antecedents', 'consequents'])[['confidence']].max().sort_values(ascending=False,\n                                                                      by='confidence').head(10).plot(kind='bar').invert_xaxis()\nplt.title('Top movies that are likley to be watched with inception');","92f32500":"rules['antecedents'] = rules.antecedents.apply(lambda x: next(iter(x)))\nrules['consequents'] = rules.consequents.apply(lambda x: next(iter(x)))","6e07f7a3":"import networkx as nx\nimport warnings\nwarnings.filterwarnings('ignore')\nplt.style.use('fivethirtyeight')\nedges = nx.from_pandas_edgelist(rules.sort_values(ascending=False,by='lift').head(100)\n                           ,source='antecedents',target='consequents',edge_attr=None)\nplt.subplots(figsize=(40,30))\nplt.suptitle('Top 100 movies in term of (lift)', fontsize = 50,fontweight = 'bold')\npos = nx.planar_layout(edges)\nnx.draw_networkx_nodes(edges, pos, node_size = 2000,alpha= 0.7,node_color = 'tomato')\nnx.draw_networkx_edges(edges, pos, width = 6, alpha = 0.2, edge_color = 'indigo')\nnx.draw_networkx_labels(edges, pos, font_size = 25, font_family = 'FreeMono',weight='bold')\nplt.grid()\nplt.axis('off')\nplt.tight_layout()\nplt.show()","725271dd":"### 1. GENERATE FREQUENT ITEMSETS\n\nTwo Algorithms (Apriori, and Fpgrowth) are going to be disccussed to generaten frequent itemsets which are going to be used later on to create association rules\n### **Apriori Algorithm**\nA pseudocode in **figure 2** implements the frequests itemsets generation of apriori algorithm. where Ck adopts a set of candidate k-itemsets, and the frequent set if itemsets are represented by Fk. apriori following the belows steps: (Tan and etl 2013)\n\n1- The algorithm initially makes a single pass over the data set to determine the support of each item. Upon completion of this step, the set of all frequent 1-itemsets K.\n\n\n\n2- Algorithm generate new candidate k-itemsets and prune unnecessary candidates that are guaranteed to be infrequent given the frequent (k\u22121) itemsets found in the previous iteration.\n\n\n3- Algorithm makes an additional pass to count the support of the generated candidates. The subset function is used to determine all the candidate itemsets in Ck that are contained in each transaction t. \n\n\n4- After counting support, the algorithm eliminates all candidate itemsets whose support counts are less than N  minimum support which is chosen by the user. \n\n\n5- The algorithm terminates when there are no new frequent itemsets generated, ie Fk = \u2205.\n","7e40414b":"### Movies Rating Data\n\nMovies rating data contain more that 9k movies ids which can be usefull to be merged with the movies title dataset.\n","239c83aa":"## 2.4. DATA TRANSFORMATION\n\nHere data is transfered as a binary input to be accepted by the algorithm, serveral methods are avalible in several packages such as:\n\n---\n\n\n```python \npandas.get_dummies```\n\n\n```from mlxtend.preprocessing import TransactionEncoder```\n\n\n\n\n```sklearn.preprocessing.OneHotEncoder```","16d4481c":"## 1.2. STEPS TO COMPUTE ASSOCIATION RULES\n\n>- 1. GENERATE FREQUENT ITEMSETS\n\n>- 2. APPLY ASSOCIATION RULES ON GENERATED ITEMS SETS","15cbd145":"# Movies_Recommendations by -> Association_rules\n\nHi Everyones This notebooks speaks about the implementation of association rules on movielens movies dataset.\n\nIf you like this work kernel, feel free to leave a comment or an upvote :)\n\n* [INTRODUCTION TO ASSOCIATION RULES](#section-one)\n    - [THEORETICAL PART](#subsection-one)\n    - [PRACTICAL PART (coding)](#subsection-two)\n* [ANALYSIS OF RESULTS](#section-two)\n* [ENDNOTE & REFRENCES](#section-three)","55bf3644":"* Filtering by itemset length","0af4129f":"* And we can search also by all itemset in all frequent itemsets.","93b85b8c":"### **Fp-Growth Algorithm**\nThe algorithm does not create candidate sets in the same fashion as apriori in terms of multiple passes over the entire dataset. since it needs only two scans over the dataset to extract frequent itemsets from it, which makes it faster  and less expensive than apriori.\n\n1- The algorithm scans the whole dataset one time to calculate each item support cout. and ignore the infrequent items, and sort the generated item set in a descending order.\n\n2- Algorithm construct the Fp-tree by making a second pass over the data set. After reading the first transaction the first transaction is created  as a node between those items where a path is generated to encode this relation, and every node along the path has a frequency count of 1.\n\n3- This process continues until  all the generated transactions are mapped onto their relative path that have been constructed by the Fp-Tree.\n\n![Screen%20Shot%202020-06-03%20at%205.40.35%20PM.png](attachment:Screen%20Shot%202020-06-03%20at%205.40.35%20PM.png)\n\n>- Figure 3.  *Fp-Growth algorithm generation, adapted from Tan and etl (2013) Association Analysis: basic concepts and algorithms in Introduction to data mining.*\n","79fec088":"Apply some basic analysis that can used to generate some intresting insights\n\n* filter by columns based on numerial conditions","9a5f9023":"* Generate insights by filtering values based on thier combnations and occurances in all dataset.","d998843c":"## Drawbacks in association rules \nDue to the iterative process of rules generation in association rules mining where every item in the dataset is compared against each item and so on, the increase in items and transaction can make the computation very expensive, (Tan and etl 2013) listed some limitations that can be solved by decrease the dimensionality in datasets.and reduce the number of item sets in terms of columns and rows that need to be computed, that can be reduced by setting threshold to compute items sets that pases the threshold only.\n","b8c3cb67":"### Fpgrowth","431fd5a8":"![image.png](attachment:image.png) \n\n>- Table 1. *Transactional data example, adapted from Tan and etl (2013) Association Analysis: basic concepts and algorithms in Introduction to data mining*\n","433b839b":"* We can observe more the relation between support and length using correlation and hexbin plot. we can see an increse of rows that consist in more than one itemset. we can observe more insights if we had a multiple items in terms of items length instead of two only as a maximum in this example. ","c769d0b1":"To validate the created list per userId we can see it is the same as the code below. \n```python\nlen(merge.userId.unique())```","c581082a":"## 2.2. SELECTED DATA\n\nHere we can see from the directory of the uncompressed file that we have a total of 5 data set, we are going to select and observed which one that contain needed data for the implementation of association rules. which should look similar to **Table. 1**.","27660a26":"### APRIORI","4a36ac63":"sample of the list","84caa765":"![](https:\/\/i.pinimg.com\/originals\/bd\/5e\/47\/bd5e47075584914bcbe0f1fcff19c802.gif)\n","5b2e6e01":"### Movies Data\n\nThis is the only dataset that contains the titile of the movies and each movie unique key.","f29153f3":"Since we are going to merge. lets observe how many users we have.","cb913dc6":"## 1.1. MAJOR COMPUTATION IN ASSOCIATION RULES\nAssociation rules in general have the listed below major computaions in the dataset.\n\n**Support:**\nIs the percentage of the transaction that contains the items from the data set , which means how many times did the items occur in the dataset (Agrawal et al, 1993).\n\n$ support  (A\u2192C)=support (A\u222aC)$  ---> (range[0,1])\n\n**Confidence:** The probability that items on left hand side and right hand side  of ruleset are occurring together, with a higher confidence will reflect a higher likelihood of the items that will be purchased together based on the given rule (Agrawal et al, 1993).\n\n$confidence (A\u2192C)=support (A\u2192C) support(A)$  ---> (range [0,1])\n\n**Lift:**\nProbability of the all items set all occurring together in the rule. lift value more than 1 reflects that the presence of the item will increase with the presence of the other items and its occurrence in the same transaction, so the lift summarizes the strength of association rule as a link between the items of both sides (Brin et al, 1997).\n\n$lift (A\u2192C)=confidence (A\u2192C) support(C)$ ---> (range[0,\u221e])\n\n>- Note that left hand side and right hand side of the rules are identfied also as \"antecedents\" and \"consequents\".","21a3e994":"<a id=\"section-one\"><\/a>\n# 1. INTRODUCTION TO ASSOCIATION RULES\nAssociation rules analysis related algorithms, such as Apriori and FP-growth tree algorithms that can be defined as a developed techniques that been used for the transactional data type to compute how much association is between data values and thier relative combinations, like if a customer is 70% to buy a milk how likley a customer will also buy bread. Here will use two main types of algorithms are being used: The Apriori and the FP Growth, where data are structured as shown in **table 1**.","ffcbc16d":"One intresting way to view such data can be used by a network analysis type of plots which can be used to visulize the relation between each feature and it is crosspounding feature in same dataset. Here we used **Networkx** modules which can be implemented to selected top 100 strongest relation. netwrokx modules has many layouts can be plot which depends on nodes, here we selected ``'planar_layout'`` as it can present the huge selection of data points clearly and beatifully.\n\n>- Note: we added a lambda function to convert the forzenset to a string, to eliminate printing frozenset with each created node.","e3435f47":"An increasing value of lift is relatively associated with the increase of other measures such as confidence, lets observe top 10 movies that are relativley confidenent to be watched with the selected movie 'Inception'.","c296192b":"### Movies tages Data\nThis dataset contain the added tags to the movie plus the userid which is valuable to be considered as an index to each transaction, on the other hand the dataset has less movie ids than the rating dataset which made us select it instead.\n","f10e66b8":"Here we preprocess the dataset to create a transactional list were every row represent a user and his selected movies, which is similar to table. 1.","5b25e196":"![Screen%20Shot%202020-06-03%20at%205.40.09%20PM.png](attachment:Screen%20Shot%202020-06-03%20at%205.40.09%20PM.png)\n>- Figure 2  *Apriori algorithm Pseudocode, adapted from Tan and etl (2013) Association Analysis: basic concepts and algorithms in Introduction to data mining*","d477a895":"<a id=\"section-one\"><\/a>\n# 3 ENDING NOTE\n\nAssociation rules analysis can not generlize the results to work on as a full sphisticated system for movies recomendations, as  other techniques such collabertive filtering used by amazon store which is depending of similarity of users to recomend a product isntead of depending only on frequency of itemsets.","a920ed56":"<a id=\"section-two\"><\/a>\n\n## 2.6. ANAYSIS TO THE RESULTS","c671a5c2":"# REFRENCES\n\n**- Equations citation as taken from mlxtend module page:\n**\n>- R. Agrawal, T. Imielinski, and A. Swami. Mining associations between sets of items in large databases. In Proc. of the ACM SIGMOD Int'l Conference on Management of Data.\n\n>- S. Brin, R. Motwani, J. D. Ullman, and S. Tsur. Dynamic itemset counting and implication rules for market basket data\n\n>- Sergey Brin, Rajeev Motwani, Jeffrey D. Ullman, and Shalom Turk. Dynamic itemset counting and implication rules for market basket data. In SIGMOD 1997, Proceedings ACM SIGMOD International Conference on Management of Data.\n\n>- Sebastian Raschka. 2018, MLxtend: Providing machine learning and data science utilities and extensions to Python\u2019s scientific computing stack. The Journal of Open Source Software.\n\n**- Books\n**\n>- Tan, P., Steinbach, M., & Kumar, V. (2013). Introduction to Data Mining. Pearson Education UK.\nhttps:\/\/www-users.cs.umn.edu\/~kumar001\/dmbook\/ch5_association_analysis.pdf\n\n**- Used Dataset\n**\n>- F. Maxwell Harper and Joseph A. Konstan. 2015. The MovieLens Datasets: History and Context. ACM Transactions on Interactive Intelligent Systems (TiiS) 5, 4: 19:1\u201319:19. <https:\/\/doi.org\/10.1145\/2827872>\n\n**- More Tutorials:\n**\nin R programming:\n\n>- arules: Association Rule Mining with R \u2014 A Tutorial by Michael Hahsler :https:\/\/michael.hahsler.net\/research\/arules_RUG_2015\/demo\/\n\n\n**- Reading:**\n\n>- Amazon.com\nRecommendations\nItem-to-Item Collaborative Filtering:\nhttps:\/\/www.cs.umd.edu\/~samir\/498\/Amazon-Recommendations.pdf\n\n**- Intresting links**:\n\n>- Network analysis visulization teken from this tutorial:\nhttps:\/\/www.kaggle.com\/roshansharma\/fivethirtyeight-comics-analysis\/\n\n","093d320f":"Dropiong unneeded columns.","a6a28283":"## 2.1. DATASET (ml-latest-small.zip)\n\n\n<p><span style=\"color:red\"> <em>for the demonstration purpose we selected a smaller version of dataset to implement the tutorial.\n<\/em><\/span><\/p>\n\nThis dataset (ml-latest) describes 5-star rating and free-text tagging activity from MovieLens, a movie recommendation service. It contains 27753444 ratings and 1108997 tag applications across 58098 movies. These data were created by 283228 users between January 09, 1995 and September 26, 2018. This dataset was generated on September 26, 2018.\n\nMore information about the data and description can be found in the link: http:\/\/files.grouplens.org\/datasets\/movielens\/ml-latest-README.html","7ddf12cb":"<a id=\"subsection-one\"><\/a>\n# THEORETICAL PART","319e483d":"A less messy way to group the top 10 related movies to the selected one.\n\nWe can see here the selected movie inception has top values of lift on related movie due to the same director in them (Dunkirk)","131e6990":"## 2.7. Visulizing Association rules (Networkx)","7728ba32":"Sounds intresting that fpgrowth passed apriori in small dataset, on the other hand the number of generated item sets are the same in both algorithms.","371829ab":"## 2.5. GENERATING FREQUENT ITEMSETS\nThis section implement the use of the itemsets generation according to the selected parameters  ``` min_support=0.01,max_len=2``` as a threshold to paneltize the algorithm of using a huge memory size of the machine (1% support value, and maxixmum length of two items in each row is selected) as well.\n\n- **NOTE:** Note that the results frequent items are python frozensets, which can not be selected by pandas methods such as ```pd.loc[]```.\n","b1ebffd0":"<a id=\"subsection-two\"><\/a>\n# 2. PRACTICAL PART\n\n<img src=\"https:\/\/media.giphy.com\/media\/heIX5HfWgEYlW\/giphy.gif\">\n\n","5270939c":"## 2.3. MERGING DATASETS\n\nin this case inner join is selected since we need the data only when both movieId labels are existed on both datasets.\n\nmore details about merging can be found in pandas documentation: https:\/\/pandas.pydata.org\/pandas-docs\/stable\/user_guide\/merging.html ","5e2cd7ba":"## 2.6. ASSOCIATION RULES\n\nmlxtend module compute additional measures such as:\n\nfrom mlxtend documentation:\n\n  - $leverage(A->C) = support(A->C) - support(A)*support(C)$ \n--->range: [-1, 1]\n\n  - $conviction = [1 - support(C)] \/ [1 - confidence(A->C)]$ \n--->range: [0, inf]\n\n\nLeverage computes the difference between the observed frequency of A and C appearing together and the frequency that would be expected if A and C were independent. An leverage value of 0 indicates independence.\n\nA high conviction value means that the consequent is highly depending on the antecedent. For instance, in the case of a perfect confidence score, the denominator becomes 0 (due to 1 - 1) for which the conviction score is defined as 'inf'. Similar to lift, if items are independent, the conviction is 1.\n\n- **Here we are selecting the measure 'Lift' as a score evaluation method**","b2cf67de":"Lets create new feature that can be used for furthur analysis.","be9e4170":"It can be seen in the previous figure that \u2018Bear\u2019 from items columns have been seen in multiple rows, which means in cases such as  this item occur transaction this item occurs in most of rows which consider as support measure, but what does that means?."}}