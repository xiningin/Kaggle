{"cell_type":{"195ac830":"code","584e5daa":"code","548442bd":"code","5ffcccf0":"markdown","c3265244":"markdown","7c2f7f2f":"markdown"},"source":{"195ac830":"import pandas as pd\nimport numpy as np\nblosum62_Valores =[\n    [4,-1,-2,-2,0,-1,-1,0,-2,-1,-1,-1,-1,-2,-1,1,0,-3,-2,0,-2,-1,0,-4],\n    [-1,5,0,-2,-3,1,0,-2,0,-3,-2,2,-1,-3,-2,-1,-1,-3,-2,-3,-1,0,-1,-4],\n    [-2,0,6,1,-3,0,0,0,1,-3,-3,0,-2,-3,-2,1,0,-4,-2,-3,3,0,-1,-4],\n    [-2,-2,1,6,-3,0,2,-1,-1,-3,-4,-1,-3,-3,-1,0,-1,-4,-3,-3,4,1,-1,-4],\n    [0,-3,-3,-3,9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1,-3,-3,-2,-4],\n    [-1,1,0,0,-3,5,2,-2,0,-3,-2,1,0,-3,-1,0,-1,-2,-1,-2,0,3,-1,-4],\n    [-1,0,0,2,-4,2,5,-2,0,-3,-3,1,-2,-3,-1,0,-1,-3,-2,-2,1,4,-1,-4],\n    [0,-2,0,-1,-3,-2,-2,6,-2,-4,-4,-2,-3,-3,-2,0,-2,-2,-3,-3,-1,-2,-1,-4],\n    [-2,0,1,-1,-3,0,0,-2,8,-3,-3,-1,-2,-1,-2,-1,-2,-2,2,-3,0,0,-1,-4],\n    [-1,-3,-3,-3,-1,-3,-3,-4,-3,4,2,-3,1,0,-3,-2,-1,-3,-1,3,-3,-3,-1,-4],\n    [-1,-2,-3,-4,-1,-2,-3,-4,-3,2,4,-2,2,0,-3,-2,-1,-2,-1,1,-4,-3,-1,-4],\n    [-1,2,0,-1,-3,1,1,-2,-1,-3,-2,5,-1,-3,-1,0,-1,-3,-2,-2,0,1,-1,-4],\n    [-1,-1,-2,-3,-1,0,-2,-3,-2,1,2,-1,5,0,-2,-1,-1,-1,-1,1,-3,-1,-1,-4],\n    [-2,-3,-3,-3,-2,-3,-3,-3,-1,0,0,-3,0,6,-4,-2,-2,1,3,-1,-3,-3,-1,-4],\n    [-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4,7,-1,-1,-4,-3,-2,-2,-1,-2,-4],\n    [1,-1,1,0,-1,0,0,0,-1,-2,-2,0,-1,-2,-1,4,1,-3,-2,-2,0,0,0,-4],\n    [0,-1,0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1,1,5,-2,-2,0,-1,-1,0,-4],\n    [-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1,1,-4,-3,-2,11,2,-3,-4,-3,-2,-4],\n    [-2,-2,-2,-3,-2,-1,-2,-3,2,-1,-1,-2,-1,3,-3,-2,-2,2,7,-1,-3,-2,-1,-4],\n    [0,-3,-3,-3,-1,-2,-2,-3,-3,3,1,-2,1,-1,-2,-2,0,-3,-1,4,-3,-2,-1,-4],\n    [-2,-1,3,4,-3,0,1,-1,0,-3,-4,0,-3,-3,-2,0,-1,-4,-3,-3,4,1,-1,-4],\n    [-1,0,0,1,-3,3,4,-2,0,-3,-3,1,-1,-3,-1,0,-1,-3,-2,-2,1,4,-1,-4],\n    [0,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-2,0,0,-2,-1,-1,-1,-1,-1,-4],\n    [-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,1],\n]\nblosum62_Etiquetas = ['A','R','N','D','C','Q','E','G','H','I','L','K','M','F','P','S','T','W','Y','V','B','Z','X','*']\nblosum62 = pd.DataFrame(data = blosum62_Valores,\n                                index = blosum62_Etiquetas,\n                                columns = blosum62_Etiquetas)\nprint(blosum62)","584e5daa":"def UmbralW(Palabra, blosum62):\n    Umbral = 0\n    for i in Palabra:\n        Umbral += blosum62.at[i,i]\n    return Umbral\ndef Umbral2W(Palabra1, Palabra2, blosum62):\n    Umbral = 0\n    for i in range(len(Palabra1)):\n        Umbral += blosum62.at[Palabra1[i],Palabra2[i]]\n    return Umbral\ndef BLAST(blosum62, Q, D, k, T, X):\n    # PASO 1: PREPROCESAMIENTO\n    # 1.2 Extraemos las palabtras de tamanio k\n    Words = []\n    WordsV = []\n    for i in range(len(Q)-k+1):\n        Word = Q[i:i+k]\n        Words.append(Word)\n        Umbral = UmbralW(Word, blosum62)\n        if Umbral >= T:\n            WordsV.append([Word,Umbral])\n        \n    print('\\n\\x1b[6;30;43mExtraemos palabras de k tamanio\\x1b[0m\\n',Words)\n    \n    print('\\n\\x1b[6;30;43mSeleccionamos aquellas palabras que pasan el umbral\\x1b[0m\\n',WordsV)\n     \n    #1.3 Generamos palabras parecidas(neighbors) \n    Neighbors = []\n    N = 0\n    print(\"\\n\\x1b[6;30;43mGeneramos palabras parecidas(neighbors)\\x1b[0m\\n\")\n    for l in (WordsV):\n        print(l[0])\n        for m in range(k):\n            Aux = \"\"\n            Umb = \"\"\n            for n in blosum62.index:\n                word = l[0][:m] + n + l[0][m + 1:]\n                Aux += word + \" \u2551\"\n                Umb += \" \"+str(UmbralW(word, blosum62))+\" \u2551\"\n                Neighbors.append([word, UmbralW(word, blosum62)])\n            print(Aux)\n            print(Umb)\n    \n    #1.4 Seleccionar palabras cuyo umbral sea mayor o igual a T\n    W = []\n    N = 0\n    Aux = \"\"\n    Umb = \"\"\n    print('\\n\\x1b[6;30;43mSeleccionar palabras cuyo umbral sea mayor o igual a T\\x1b[0m')\n    for o in range(len(Neighbors)):\n        if(Neighbors[o][1]>=T):\n            if(Neighbors[o] not in W):\n                W.append(Neighbors[o])\n                Aux += Neighbors[o][0] + \" \u2551\"\n                Umb += \" \"+str(Neighbors[o][1]) + \" \u2551\"\n                N+=1\n                if(N==24):\n                    N=0\n                    print(Aux)\n                    print(Umb)\n                    Aux = \"\"\n                    Umb = \"\"\n    print(Aux)\n    print(Umb)\n    \n    # PASO 2: BUSQUEDA\n    maxQ = \"\"\n    maxD = \"\"\n    # 2.1: Buscar la palabras que superar el umbral en la BD y registrar su posici\u00f3n\n    Posiciones = []\n    for q in W:\n        if(q[0] in D):\n            Posiciones.append([q[0],D.index(q[0]),Q.index(q[0])])\n            print(q[0])\n            print(D.index(q[0])+1)\n    # PASO 3: EXSTENSION\n    # 3.1: Para cada alineamiento sembrado extender a la izquierda hasta que la puntuaci\u00f3n decrezca(M\u00c1XIMO - X)\n    print('\\n\\x1b[6;30;43mPara cada alineamiento sembrado extender a la izquierda hasta que la puntuaci\u00f3n decrezca(M\u00c1XIMO - X)\\x1b[0m\\n')\n    It = 0\n    QAux= Posiciones[0][0]\n    DAux= Posiciones[0][0]\n    IzqD = Posiciones[0][1]\n    \n    IzqQ = Posiciones[0][2]\n    LimiteIzq = 0\n    if(IzqD>IzqQ):\n        Q = (\"-\"*(IzqD-IzqQ)) + Q\n        LimiteIzq = IzqD\n    else:\n        D = (\"-\"*(IzqQ-IzqD)) + D\n        LimiteIzq = IzqQ\n    LimiteDer = LimiteIzq+3\n    DerD = IzqD+3+(LimiteIzq-IzqD)\n    DerQ = IzqQ+3+(LimiteIzq-IzqQ)\n    print('\\nIteracion',It)\n    print(Q[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+Q[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+Q[LimiteDer:len(Q)])\n    print(D[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+D[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+D[LimiteDer:len(D)])\n    PuntuacionActual = Umbral2W(Q[LimiteIzq:LimiteDer], D[LimiteIzq:LimiteDer], blosum62)\n    MaximaPuntuacion = PuntuacionActual\n    print(\"Puntuaci\u00f3n maxima con alineamiento de la semilla = \", PuntuacionActual)\n    menor = min(IzqQ, IzqD)\n    while(menor > 0):\n        menor-=1\n        LimiteIzq-=1\n        It+=1\n        print('\\nIteracion',It)\n        print(Q[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+Q[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+Q[LimiteDer:len(Q)])\n        print(D[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+D[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+D[LimiteDer:len(D)])\n        PuntuacionActual = Umbral2W(Q[LimiteIzq:LimiteDer], D[LimiteIzq:LimiteDer], blosum62)\n        print(\"Puntuaci\u00f3n = \", PuntuacionActual)\n        if(PuntuacionActual >= MaximaPuntuacion-X):\n            print(PuntuacionActual,\">= Maximo - X =\",MaximaPuntuacion,\"-\",X,\"=\",(MaximaPuntuacion-X))\n            if(PuntuacionActual >=MaximaPuntuacion): \n                MaximaPuntuacion = PuntuacionActual\n                MaxQ = Q[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+Q[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+Q[LimiteDer:len(Q)]\n                MaxD = D[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+D[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+D[LimiteDer:len(D)]\n            print(MaximaPuntuacion,\"= M\u00e1ximo hasta ahora\")\n        else:\n            print(PuntuacionActual,\"< Maximo - X =\",MaximaPuntuacion,\"-\",X,\"=\",(MaximaPuntuacion-X))\n            print(\"NO CUMPLE CONDICI\u00d3N, ENTONCES EL ALINEAMIENTO RETROCEDE UNA ITERACI\u00d3N\\n\")\n            LimiteIzq+=1\n            break\n    # 3.2: Para cada alineamiento extendido a la izquierda, extender a la derecha hasta que la puntuaci\u00f3n decrezca(M\u00c1XIMO - X)\n    print(\"\\x1b[6;30;43m\/---------------------------Ahora procedemos por la derecha---------------------------\/\\x1b[0m\")\n    It = 0\n    print('\\nIteracion',It)\n    print(Q[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+Q[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+Q[LimiteDer:len(Q)])\n    print(D[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+D[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+D[LimiteDer:len(D)])\n    PuntuacionActual = Umbral2W(Q[LimiteIzq:LimiteDer], D[LimiteIzq:LimiteDer], blosum62)\n    print(\"Puntuaci\u00f3n maxima con alineamiento de la semilla = \", PuntuacionActual)\n    menor = min(len(Q)-DerQ, len(D)-DerD)\n    while(menor > 0):\n        menor-=1\n        LimiteDer+=1\n        It+=1\n        print('\\nIteracion',It)\n        print(Q[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+Q[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+Q[LimiteDer:len(Q)])\n        print(D[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+D[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+D[LimiteDer:len(D)])\n        PuntuacionActual = Umbral2W(Q[LimiteIzq:LimiteDer], D[LimiteIzq:LimiteDer], blosum62)\n        print(\"Puntuaci\u00f3n = \", PuntuacionActual)\n        if(PuntuacionActual >= MaximaPuntuacion-X):\n            print(PuntuacionActual,\">= Maximo - X =\",MaximaPuntuacion,\"-\",X,\"=\",(MaximaPuntuacion-X))\n            if(PuntuacionActual >= MaximaPuntuacion): \n                MaximaPuntuacion = PuntuacionActual\n                MaxQ = Q[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+Q[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+Q[LimiteDer:len(Q)]\n                MaxD = D[0:LimiteIzq]+\"\\x1b[6;30;42m\u2560\"+D[LimiteIzq:LimiteDer]+\"\u2563\\x1b[0m\"+D[LimiteDer:len(D)]\n            print(MaximaPuntuacion,\"= M\u00e1ximo hasta ahora\")\n        else:\n            print(PuntuacionActual,\"< Maximo - X =\",MaximaPuntuacion,\"-\",X,\"=\",(MaximaPuntuacion-X))\n            print(\"NO CUMPLE CONDICI\u00d3N, ENTONCES EL ALINEAMIENTO RETROCEDE UNA ITERACI\u00d3N\\n\")\n            LimiteIzq-=1\n            break\n    # 3.3 Nos quedamos con las secuecias alineadas de mayor puntuaci\u00f3n, y el resto desechamos\n    print('\\n\\x1b[6;30;43mNos quedamos con las secuecias alineadas de mayor puntuaci\u00f3n, y el resto desechamos\\x1b[0m\\n')\n    print(MaxQ)\n    print(MaxD)\n    print(\"Maxima Puntuacion = \",MaximaPuntuacion)","548442bd":"Q =  'MWAFGGRAAVGLLPRTASRASAWVGNPRWREPIVTCGRRGLHVTVNAGATRHAHLNLHYLQILNIKKQSVCVVHLRNLGTLDNPSSLDETAYERLAEETLDSLAEFFEDLADKPYTLEDYDVSFGDGVLTIKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGKNWVYSHDGVSLHELLARELTKALNTKLDLSSLAYSGKGT'\n# PERRO\nD1 = 'MWTLGRRAAAGLLPRSAPPGSAAAGAGTRGPTRAAPLHGGRGLRVGTGAARGPSHANLSLHHLNQLVNVKKQSVCLMNMRTVGTVSSPGSLDETTYERLAETTLDSLAEFFEDLADKPYTLEDYDVSFGSGVLTVKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGKNWVYSHDGVSLHELLATELTKAFKIKLDLSSLAYSGKGT'\n# HOMBRE\nD2 = 'MWTLGRRAVAGLLASPSPAQAQTLTRVPRPAELAPLCGRRGLRTDIDATCTPRRASSNQRGLNQIWNVKKQSVYLMNLRKSGTLGHPGSLDETTYERLAEETLDSLAEFFEDLADKPYTFEDYDVSFGSGVLTVKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGKNWVYSHDGVSLHELLAAELTKALKTKLDLSSLAYSGKDA'\n# VACA\nD3 = 'MWTLGRRSVASFLPRSALPGFAPTRAGAPRPAKDLSLSGLPGLRIGTAKAPARSQSSLSLRCLNQTLDVKKQSVCWINLRTAGTLGDAGTLDDTTYERLAEETLDSLAEFFEDLADKPYTFEDYDVSFGSGVLTVKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGRNWVYSHDGVSLHELLATELTQALKTKLDLSALAYSGKDTCCPAQC'\n# CHIMPANCE\nD4 = 'MWTLGRRAVAGLLASPSPAQAQTLTRVPRPAELAPLCGRRSLRTGIDATCTPRRASSNLRGLNQIWNVKKQSVYLMNLRKSGTLGHPGLLGSNPYERLAEETLDFLAEFFEDLADKPYTFEDYDVSFGSGVLTVKLGGDLGTYVINKQTPNKQIWLSSPSSGPKRYDWTGKNWVYSHDGVSLHELLAAELTKALKTKLDLSSLAYSGKDA'\n# ABEJA\nD5 = 'MLLTRGTIKHSVFKILSYDLVKSIINKCLIQEINVKCQTNIGYHILHFKKNLNINKDLKILSYESIAHNHCNKNLFIISSNNLSTQELTSVQFEKVSDETLTSLTEYFDELVEQAIHLSDADVSYGDGVLTIKFGDTHGTYVINRQSPNRQIWLSSPKSGPKRYDFIDGKWIYKYDRKTLHELLDDEIPAIIGNQTNFNKCSFSGK'\n# ARROZ\nD6 = 'MASRKLVLGLTAARRLRSRAPVLVSSSPFLEASTSTSDATAATATRGSGLGPWGLFLSSRALSSTRPVSLSAGDAPGSSAADHRSILPEDEYHKLADETIHDLLEKLEEYGDSLQMDGFDIDYGNQVLTLRLGELGTYVVNKQAPNRQIWLSSPVSGPSRFDWDAPTNCWIYRRTGANLVELLEKEIGELCGTPVELS'\n\nQ2 = 'MVKLAKAGKTHGMVK'\nDD2 = 'LHMVKKEGHIPFVK'\n\nQ3 = 'EFIPLMCHWLQTAG'\nDD3 = 'ABPLHCHWLEGHIP'\n\nQ4 = 'GGREAPIGPWWAG'\nDD4 = 'RIAGRREAPIGAWWAGH'\nBLAST(blosum62,Q, D3, 3, 23, 3)","5ffcccf0":"# Algoritmo Blast","c3265244":"# PRACTICA\n\n>NOMBRES: SALCEDO HURTADO, Jorge Andre\n\n>ASIGNACION: Aplicar el algoritmo BLAST para alinear la muestra de la secuencia de proteina Q con la base de datos formados por D1, D2, \u2026, D6. Unicamente aplicar los pasos\t\t\t\t\t\t\t\t\n1. Pre-procesado: obtenci\u00f3n de semillas, con W=3, T=26\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n2. B\u00fasqueda de semillas en la base de datos.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n3. Extensi\u00f3n con X=3\t\t\t\t\t\t\t\t","7c2f7f2f":"# Blosum62"}}