{"cell_type":{"6fee8319":"code","0f39d741":"code","87a9d09e":"code","126b096d":"code","59eea3f4":"code","b8b37d32":"markdown","5e254532":"markdown"},"source":{"6fee8319":"!pip install mtcnn","0f39d741":"from mtcnn import MTCNN\nimport os\nimport numpy as np\nimport pandas as pd\nimport cv2 as cv2\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import imshow\nfrom tensorflow.keras.models import Model, load_model\nimport logging\nlogging.getLogger(\"tensorflow\").setLevel(logging.ERROR)\nimport logging\nlogging.getLogger(\"tensorflow\").setLevel(logging.ERROR)\npd.set_option('display.max_columns', 80)","87a9d09e":"def crop(img):\n    # x, y, width, height = result['box']\n    s=1.2\n    height=img.shape[0]\n    width=img.shape[1]    \n    detector = MTCNN()\n    data=detector.detect_faces(img) \n    if data==[]:\n        return False, None\n    else:\n        for i, faces in enumerate(data): # iterate through all the faces found\n            box=faces['box']  # get the box for each face\n            biggest=0                    \n            area = box[2] * box[3]\n            if area>biggest:\n                biggest=area\n                bbox=box\n            x,y,w,h=bbox  \n            xn=int(x +w\/2)-int(w * s\/2)\n            yn=int(y+h\/2)- int(h * s\/2)\n            xen=int(x +w\/2) + int(w * s\/2)\n            yen=int(y+h\/2) + int(h * s\/2)\n            bbox[0]= 0 if bbox[0]<0 else bbox[0]\n            xn=0 if xn<0 else xn\n            yn=0 if yn<0 else yn\n            xen= width if xen>width else xen\n            yen= height if yen>height else yen\n            img=img[yn:yen, xn:xen]            \n            return True, img","126b096d":"def classify(sdir, csv_path,  model_path, crop_image = False):    \n    # read in the csv file\n    e=1.2\n    class_df=pd.read_csv(csv_path)    \n    img_height=int(class_df['height'].iloc[0])\n    img_width =int(class_df['width'].iloc[0])\n    img_size=(img_height, img_width)    \n    scale=class_df['scale by'].iloc[0]     \n    try: \n        s=int(scale)\n        s2=s\n        s1=0\n    except:\n        split=scale.split('-')\n        s1=float(split[1])\n        s2=float(split[0].split('*')[1]) \n    \n    path_list=[]\n    paths=os.listdir(sdir)\n    for f in paths:\n        path_list.append(os.path.join(sdir,f))\n    print (' Model is being loaded- this will take about 10 seconds')\n    model=load_model(model_path)\n    image_count=len(path_list) \n    index_list=[] \n    prob_list=[]\n    cropped_image_list=[]\n    good_image_count=0\n    for i in range (image_count):       \n        img=plt.imread(path_list[i])        \n        if crop_image == True:\n            status, img=crop(img)            \n        else:\n            status=True\n        if status== True:\n            good_image_count +=1\n            img=cv2.resize(img, img_size)             \n            cropped_image_list.append(img)\n            img=img*s2 - s1\n            img=np.expand_dims(img, axis=0)\n            p= np.squeeze (model.predict(img))           \n            index=np.argmax(p)             \n            prob=p[index]\n            index_list.append(index)\n            prob_list.append(prob)\n    if good_image_count==1:\n        print ( 'length of index list: ', len(index_list), 'index list [0]: ', index_list[0])\n        class_name= class_df['class'].iloc[index_list[0]]\n        probability= prob_list[0]\n        img=cropped_image_list [0]\/255 \n        plt.title(class_name, color='blue', fontsize=16)\n        plt.axis('off')\n        plt.imshow(img)\n        return class_name, probability\n    elif good_image_count == 0:\n        return None, None\n    most=0\n    for i in range (len(index_list)-1):\n        key= index_list[i]\n        keycount=0\n        for j in range (i+1, len(index_list)):\n            nkey= index_list[j]            \n            if nkey == key:\n                keycount +=1                \n        if keycount> most:\n            most=keycount\n            isave=i             \n    best_index=index_list[isave]    \n    psum=0\n    bestsum=0\n    for i in range (len(index_list)):\n        psum += prob_list[i]\n        if index_list[i]==best_index:\n            bestsum += prob_list[i]  \n    img= cropped_image_list[isave]\/255    \n    class_name=class_df['class'].iloc[best_index]\n    plt.title(class_name, color='blue', fontsize=16)\n    plt.axis('off')\n    plt.imshow(img)\n    return class_name, bestsum\/image_count","59eea3f4":"predict_dir=r'..\/input\/beauty-detection-data-set\/images to predict'  \nname='Elizabeth Hurley'\nmloc=r'..\/input\/beauty-detection-data-set\/EfficientNetB1-beauty-100.0.h5'\ncsvloc=r'..\/input\/beauty-detection-data-set\/class_dict.csv'\nresult, probability=classify(predict_dir, csvloc,mloc,  crop_image=True)\nprint (f' {name} is predicted as being {result} with a probability of {probability * 100:5.2f} %')","b8b37d32":"### define a function that takes in an image and detects the faces in the image\n### if there are multiple faces in the image it selects the faces having the most\n### pixels in it and returns that as the cropped facial image","5e254532":"### the classify function use the trained model to make predictions\nsdir is he directory with the images to predict. It can contain a single image  \nor multiple images of the SAME person. The function will process each image  \nindepedently and return a prediction with the averaged probability  \ncsv_path is the path to the class_dict.csv file  \nmodel_path is the path to the trained model   \ncrop_image is a boolean. If set to True the input images will automatically  \nbe cropped to contain just the face. If your images are already cropped  \nset it to False"}}