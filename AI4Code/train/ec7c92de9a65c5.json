{"cell_type":{"087fa04c":"code","d5c65433":"code","08591ba7":"code","9989c5a4":"code","8055e25b":"code","c791855a":"code","3061b8e1":"code","eee8eb0f":"code","6fab43d5":"code","83a15711":"code","ad0a17ae":"code","fdb39c3b":"code","756ba1ab":"code","4ab78b86":"code","a6df95dd":"code","b310849d":"code","13a8afad":"code","05761de1":"code","d19b339d":"code","b0463ac0":"code","6b2ced69":"code","afce5f43":"code","02b8cbf2":"code","3c15aabd":"code","39abeb8c":"code","2ccec11d":"code","c52875c7":"code","9defd032":"code","ba7f2531":"code","23cc1905":"code","c326ae85":"code","eab46747":"code","a93d1742":"code","338a1fd6":"code","f14a210b":"code","fb07b221":"code","58eb5873":"code","8c4b10ed":"code","275e68c1":"code","64b115fa":"code","9d4d9fdf":"code","b0d7bb99":"code","fc49cb50":"code","b8dab2f3":"code","7cf1a6a9":"code","cee84b9e":"code","c8c16b98":"code","ec36f4bd":"code","09220c19":"code","dcedad0c":"code","3067e43f":"code","6f4a352a":"code","fb99967b":"code","fa2689f6":"code","600f5123":"code","e09f82bb":"code","a1ad6610":"code","86962ee2":"code","b1a7b19c":"code","c57f4597":"code","172b7ddf":"code","4fe893a8":"code","f8c72a4c":"code","a18100de":"code","6abbda5f":"code","276cfa5d":"code","82ab88b3":"code","c78f5901":"code","355acec1":"code","3aa3838a":"code","bfbb79a9":"code","a0fc9084":"code","16d02bbc":"code","6da0043e":"code","099ed4c4":"code","942e78f8":"code","a801bc49":"code","d2809f1d":"code","b5c81a1e":"code","3740622e":"code","745c0905":"code","1fd9f582":"code","23fc40a9":"code","81bf12ea":"code","bbdba033":"code","e055490c":"code","521ce669":"code","6be3812e":"code","813c84fd":"code","be9288e0":"code","2ebdc88d":"code","7ffdd010":"code","78799553":"code","1b623792":"code","9a2bcb59":"code","bc212d4c":"code","539af2f3":"code","5bf4f742":"code","cbd70bc4":"code","4dbbd30e":"code","cb3fea8a":"code","9a75b43f":"code","ef482b8e":"code","9e36f28d":"code","4ea8c3a3":"code","df63160e":"code","9c2c1bb8":"code","2a7b60a6":"code","fc40da4d":"code","a806ce32":"code","f33a3d05":"code","ec40ad45":"code","a7873374":"code","8acef1b9":"code","7df45a59":"code","a79c33f0":"code","c11429e6":"code","c2c51db2":"code","6ac902cb":"code","c2bc8c62":"code","20d395ff":"code","be307442":"code","89edc0a9":"code","129e8b3c":"code","59136b77":"code","ae543ac6":"code","f106cab7":"code","bfddc4dc":"code","28a30ca5":"code","1c627667":"code","e1424633":"code","05b6fba4":"code","b0928755":"code","35a37aa6":"code","6a9275ef":"code","09498d0a":"code","ab2ce59e":"code","d3a284c5":"code","4ae1a539":"code","b4290a9e":"code","e3c7e50a":"code","ca222479":"code","709b5d16":"code","32327514":"code","c87a69e1":"code","4a77a82a":"code","690248a4":"code","b9855e35":"code","bd86d421":"code","448a81e3":"code","835fd2ef":"code","7631bcb1":"code","b192012e":"code","61595364":"code","5da22cfc":"code","8c0457e7":"code","2c9eed52":"code","9ee3a33c":"code","6efc45ee":"code","3fae9a6d":"code","c4646d43":"code","921d0161":"code","492a59a6":"code","3b904942":"code","bae37dad":"code","9e3bb522":"code","fc286ba8":"code","78eee2ee":"code","bb69c3e6":"code","091620a5":"code","6ac7b9e7":"code","83bd7e9b":"code","132c80ba":"code","5de61910":"code","56b2ae9a":"code","464649ce":"code","3186f523":"code","8200316d":"code","d65ef1cf":"code","44fb9d42":"code","98c5e637":"code","430fa043":"code","a7808a46":"code","47a2a8a4":"code","b713191f":"code","c1ebdec5":"code","dd90814f":"code","2d4f93ab":"code","c8883c3a":"code","8bfda8c3":"code","14436e29":"code","950235a6":"code","239d19b4":"code","c7015ce6":"code","21195f3b":"code","8c533099":"code","93f1a160":"code","23a2f0d5":"code","b27bba1d":"code","325fdd32":"code","116e4bea":"code","9d04bd60":"code","8fadb414":"code","c9d374e7":"code","41a53b97":"code","82bc62fc":"code","85799026":"code","d4b7af53":"code","df9f0cc2":"code","bb797cdd":"code","c5957a3a":"code","5c22caac":"code","16d4ef46":"code","c7a8fd99":"code","69ba72cb":"code","c89508a2":"markdown","40376791":"markdown","defc843e":"markdown","1f441708":"markdown","fd470258":"markdown","6d4ab7fc":"markdown","08fda0a6":"markdown","bab5651c":"markdown","8bd9cf02":"markdown","bf0520c8":"markdown","495858f9":"markdown","6bc4687a":"markdown","ccbc0980":"markdown","a5602d00":"markdown","8c538460":"markdown","d8d9384b":"markdown","84d912a8":"markdown","dea58b79":"markdown","09a7cc82":"markdown","639580f6":"markdown","880ff240":"markdown","ac32df4a":"markdown","bb690283":"markdown","8455c0e9":"markdown","a1f0d21e":"markdown","6ad04f70":"markdown","85265504":"markdown","852dab2b":"markdown","772e63f4":"markdown","1d5cfb85":"markdown","30c4c153":"markdown","e7abb6ad":"markdown","98915e11":"markdown","c1f3dd07":"markdown","c832278f":"markdown","8a7f488f":"markdown","c68070d6":"markdown","30d8bbf0":"markdown","aa15c818":"markdown","c3209492":"markdown","d3f00d11":"markdown","167bc21d":"markdown","a1a312b3":"markdown","ad73d9b9":"markdown","3ab9a5a2":"markdown","e4137765":"markdown","b1e7d60a":"markdown","34014b7f":"markdown","aa1167a1":"markdown","cd6809b6":"markdown","00b24b3a":"markdown","0977f7fe":"markdown","b0ccaf39":"markdown","76556a57":"markdown","b8bfa52f":"markdown","4bd3450b":"markdown","87c8c912":"markdown","ce87449c":"markdown","cabd0bec":"markdown","3090646f":"markdown","ca64e7ce":"markdown","2afc1952":"markdown","37ccdf2e":"markdown","0271419c":"markdown","8b26b229":"markdown","43411cd5":"markdown","bc354de6":"markdown","d5e6c1ab":"markdown","df1124f4":"markdown","f839676d":"markdown","680eb848":"markdown","1783d51c":"markdown","8c3a265b":"markdown","102492a8":"markdown","87b0db11":"markdown","7e406048":"markdown","ef013730":"markdown","c0e527e8":"markdown","e444aa64":"markdown","dc69ad87":"markdown","0553c4c1":"markdown","bc55e7fc":"markdown","dc580384":"markdown","abc79bc5":"markdown","f854ceb5":"markdown","8db1051d":"markdown","8da5c83c":"markdown","c4e5789a":"markdown","cf2b7460":"markdown","25674daa":"markdown","a3b61778":"markdown","7945271e":"markdown","3e024c9d":"markdown","51acd919":"markdown","aeb5405a":"markdown","f8b9eb84":"markdown","a74fa8b2":"markdown","24a9a0bd":"markdown","669245fa":"markdown","15a16207":"markdown","08d37aae":"markdown","9034379f":"markdown","3760f65c":"markdown","e401bbe2":"markdown","e9f18b4e":"markdown","6be91b64":"markdown","fbec4937":"markdown","70e65c27":"markdown","68f51bd0":"markdown","e0f34b5e":"markdown","12ab023b":"markdown","9fefa0bb":"markdown","7aa2bb0d":"markdown","17deea91":"markdown","97f5071b":"markdown","3194b6a4":"markdown","74d8a5e4":"markdown","4deb4d7e":"markdown","9d573457":"markdown","2b4da297":"markdown","af6920e7":"markdown","572b459c":"markdown","2e319cca":"markdown","2c97a021":"markdown","a6e2a50c":"markdown","ab53a3c7":"markdown","78488950":"markdown","9d54d8da":"markdown","ca1105fd":"markdown","b80a0fa5":"markdown","baaf2687":"markdown","2e584d4b":"markdown","66d80d61":"markdown","8360b823":"markdown","5fbd1d5e":"markdown","583ee4f7":"markdown","34de3f40":"markdown","be9d4195":"markdown","2bd5a056":"markdown","18a96621":"markdown","690c3ede":"markdown","5143bb88":"markdown","d18a7657":"markdown"},"source":{"087fa04c":"import sys\nassert sys.version_info >= (3, 5)\n\nimport sklearn\nassert sklearn.__version__ >= \"0.20\"\n\n# Common imports\nimport numpy as np\nimport os\n\n# to make this notebook's output stable across runs\nnp.random.seed(42)\n\n# To plot pretty figures\n%matplotlib inline\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nmpl.rc('axes', labelsize=14)\nmpl.rc('xtick', labelsize=12)\nmpl.rc('ytick', labelsize=12)","d5c65433":"from sklearn.datasets import load_iris","08591ba7":"data = load_iris()\nX = data.data\ny = data.target\ndata.target_names","9989c5a4":"plt.figure(figsize=(9, 3.5))\n\nplt.subplot(121)\nplt.plot(X[y==0, 2], X[y==0, 3], \"yo\", label=\"Iris setosa\")\nplt.plot(X[y==1, 2], X[y==1, 3], \"bs\", label=\"Iris versicolor\")\nplt.plot(X[y==2, 2], X[y==2, 3], \"g^\", label=\"Iris virginica\")\nplt.xlabel(\"Petal length\", fontsize=14)\nplt.ylabel(\"Petal width\", fontsize=14)\nplt.legend(fontsize=12)\n\nplt.subplot(122)\nplt.scatter(X[:, 2], X[:, 3], c=\"k\", marker=\".\")\nplt.xlabel(\"Petal length\", fontsize=14)\nplt.tick_params(labelleft=False)\n\n#save_fig(\"classification_vs_clustering_plot\")\nplt.show()","8055e25b":"from sklearn.mixture import GaussianMixture","c791855a":"y_pred = GaussianMixture(n_components=3, random_state=42).fit(X).predict(X)","3061b8e1":"from scipy import stats\n\nmapping = {}\nfor class_id in np.unique(y):\n    mode, _ = stats.mode(y_pred[y==class_id])\n    mapping[mode[0]] = class_id\n\nmapping","eee8eb0f":"y_pred = np.array([mapping[cluster_id] for cluster_id in y_pred])","6fab43d5":"plt.plot(X[y_pred==0, 2], X[y_pred==0, 3], \"yo\", label=\"Cluster 1\")\nplt.plot(X[y_pred==1, 2], X[y_pred==1, 3], \"bs\", label=\"Cluster 2\")\nplt.plot(X[y_pred==2, 2], X[y_pred==2, 3], \"g^\", label=\"Cluster 3\")\nplt.xlabel(\"Petal length\", fontsize=14)\nplt.ylabel(\"Petal width\", fontsize=14)\nplt.legend(loc=\"upper left\", fontsize=12)\nplt.show()","83a15711":"np.sum(y_pred==y)","ad0a17ae":"np.sum(y_pred==y) \/ len(y_pred)","fdb39c3b":"from sklearn.datasets import make_blobs","756ba1ab":"blob_centers = np.array(\n    [[ 0.2,  2.3],\n     [-1.5 ,  2.3],\n     [-2.8,  1.8],\n     [-2.8,  2.8],\n     [-2.8,  1.3]])\nblob_std = np.array([0.4, 0.3, 0.1, 0.1, 0.1])","4ab78b86":"X, y = make_blobs(n_samples=2000, centers=blob_centers,\n                  cluster_std=blob_std, random_state=7)","a6df95dd":"def plot_clusters(X, y=None):\n    plt.scatter(X[:, 0], X[:, 1], c=y, s=1)\n    plt.xlabel(\"$x_1$\", fontsize=14)\n    plt.ylabel(\"$x_2$\", fontsize=14, rotation=0)","b310849d":"plt.figure(figsize=(8, 4))\nplot_clusters(X)\n#save_fig(\"blobs_plot\")\nplt.show()","13a8afad":"from sklearn.cluster import KMeans","05761de1":"k = 5\nkmeans = KMeans(n_clusters=k, random_state=42)\ny_pred = kmeans.fit_predict(X)","d19b339d":"y_pred","b0463ac0":"y_pred is kmeans.labels_","6b2ced69":"kmeans.cluster_centers_","afce5f43":"kmeans.labels_","02b8cbf2":"X_new = np.array([[0, 2], [3, 2], [-3, 3], [-3, 2.5]])\nkmeans.predict(X_new)","3c15aabd":"def plot_data(X):\n    plt.plot(X[:, 0], X[:, 1], 'k.', markersize=2)\n\ndef plot_centroids(centroids, weights=None, circle_color='w', cross_color='k'):\n    if weights is not None:\n        centroids = centroids[weights > weights.max() \/ 10]\n    plt.scatter(centroids[:, 0], centroids[:, 1],\n                marker='o', s=35, linewidths=8,\n                color=circle_color, zorder=10, alpha=0.9)\n    plt.scatter(centroids[:, 0], centroids[:, 1],\n                marker='x', s=2, linewidths=12,\n                color=cross_color, zorder=11, alpha=1)\n\ndef plot_decision_boundaries(clusterer, X, resolution=1000, show_centroids=True,\n                             show_xlabels=True, show_ylabels=True):\n    mins = X.min(axis=0) - 0.1\n    maxs = X.max(axis=0) + 0.1\n    xx, yy = np.meshgrid(np.linspace(mins[0], maxs[0], resolution),\n                         np.linspace(mins[1], maxs[1], resolution))\n    Z = clusterer.predict(np.c_[xx.ravel(), yy.ravel()])\n    Z = Z.reshape(xx.shape)\n\n    plt.contourf(Z, extent=(mins[0], maxs[0], mins[1], maxs[1]),\n                cmap=\"Pastel2\")\n    plt.contour(Z, extent=(mins[0], maxs[0], mins[1], maxs[1]),\n                linewidths=1, colors='k')\n    plot_data(X)\n    if show_centroids:\n        plot_centroids(clusterer.cluster_centers_)\n\n    if show_xlabels:\n        plt.xlabel(\"$x_1$\", fontsize=14)\n    else:\n        plt.tick_params(labelbottom=False)\n    if show_ylabels:\n        plt.ylabel(\"$x_2$\", fontsize=14, rotation=0)\n    else:\n        plt.tick_params(labelleft=False)","39abeb8c":"plt.figure(figsize=(8, 4))\nplot_decision_boundaries(kmeans, X)\n#save_fig(\"voronoi_plot\")\nplt.show()","2ccec11d":"kmeans.transform(X_new)","c52875c7":"np.linalg.norm(np.tile(X_new, (1, k)).reshape(-1, k, 2) - kmeans.cluster_centers_, axis=2)","9defd032":"kmeans_iter1 = KMeans(n_clusters=5, init=\"random\", n_init=1,\n                     algorithm=\"full\", max_iter=1, random_state=0)\nkmeans_iter2 = KMeans(n_clusters=5, init=\"random\", n_init=1,\n                     algorithm=\"full\", max_iter=2, random_state=0)\nkmeans_iter3 = KMeans(n_clusters=5, init=\"random\", n_init=1,\n                     algorithm=\"full\", max_iter=3, random_state=0)\nkmeans_iter1.fit(X)\nkmeans_iter2.fit(X)\nkmeans_iter3.fit(X)","ba7f2531":"plt.figure(figsize=(10, 8))\n\nplt.subplot(321)\nplot_data(X)\nplot_centroids(kmeans_iter1.cluster_centers_, circle_color='r', cross_color='w')\nplt.ylabel(\"$x_2$\", fontsize=14, rotation=0)\nplt.tick_params(labelbottom=False)\nplt.title(\"Update the centroids (initially randomly)\", fontsize=14)\n\nplt.subplot(322)\nplot_decision_boundaries(kmeans_iter1, X, show_xlabels=False, show_ylabels=False)\nplt.title(\"Label the instances\", fontsize=14)\n\nplt.subplot(323)\nplot_decision_boundaries(kmeans_iter1, X, show_centroids=False, show_xlabels=False)\nplot_centroids(kmeans_iter2.cluster_centers_)\n\nplt.subplot(324)\nplot_decision_boundaries(kmeans_iter2, X, show_xlabels=False, show_ylabels=False)\n\nplt.subplot(325)\nplot_decision_boundaries(kmeans_iter2, X, show_centroids=False)\nplot_centroids(kmeans_iter3.cluster_centers_)\n\nplt.subplot(326)\nplot_decision_boundaries(kmeans_iter3, X, show_ylabels=False)\n\n#save_fig(\"kmeans_algorithm_plot\")\nplt.show()","23cc1905":"def plot_clusterer_comparison(clusterer1, clusterer2, X, title1=None, title2=None):\n    clusterer1.fit(X)\n    clusterer2.fit(X)\n\n    plt.figure(figsize=(10, 3.2))\n\n    plt.subplot(121)\n    plot_decision_boundaries(clusterer1, X)\n    if title1:\n        plt.title(title1, fontsize=14)\n\n    plt.subplot(122)\n    plot_decision_boundaries(clusterer2, X, show_ylabels=False)\n    if title2:\n        plt.title(title2, fontsize=14)","c326ae85":"kmeans_rnd_init1 = KMeans(n_clusters=5, init=\"random\", n_init=1,\n                         algorithm=\"full\", random_state=2)\nkmeans_rnd_init2 = KMeans(n_clusters=5, init=\"random\", n_init=1,\n                         algorithm=\"full\", random_state=5)\n\nplot_clusterer_comparison(kmeans_rnd_init1, kmeans_rnd_init2, X,\n                          \"Solution 1\", \"Solution 2 (with a different random init)\")\n\n#save_fig(\"kmeans_variability_plot\")\nplt.show()","eab46747":"kmeans.inertia_","a93d1742":"X_dist = kmeans.transform(X)\nnp.sum(X_dist[np.arange(len(X_dist)), kmeans.labels_]**2)","338a1fd6":"kmeans.score(X)","f14a210b":"kmeans_rnd_init1.inertia_","fb07b221":"kmeans_rnd_init2.inertia_","58eb5873":"kmeans_rnd_10_inits = KMeans(n_clusters=5, init=\"random\", n_init=10,\n                              algorithm=\"full\", random_state=2)\nkmeans_rnd_10_inits.fit(X)","8c4b10ed":"plt.figure(figsize=(8, 4))\nplot_decision_boundaries(kmeans_rnd_10_inits, X)\nplt.show()","275e68c1":"KMeans()","64b115fa":"good_init = np.array([[-3, 3], [-3, 2], [-3, 1], [-1, 2], [0, 2]])\nkmeans = KMeans(n_clusters=5, init=good_init, n_init=1, random_state=42)\nkmeans.fit(X)\nkmeans.inertia_","9d4d9fdf":"%timeit -n 50 KMeans(algorithm=\"elkan\", random_state=42).fit(X)","b0d7bb99":"%timeit -n 50 KMeans(algorithm=\"full\", random_state=42).fit(X)","fc49cb50":"from sklearn.cluster import MiniBatchKMeans","b8dab2f3":"minibatch_kmeans = MiniBatchKMeans(n_clusters=5, random_state=42)\nminibatch_kmeans.fit(X)","7cf1a6a9":"minibatch_kmeans.inertia_","cee84b9e":"import urllib.request\nfrom sklearn.datasets import fetch_openml\n\nmnist = fetch_openml('mnist_784', version=1, as_frame=False)\nmnist.target = mnist.target.astype(np.int64)","c8c16b98":"from sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(\n    mnist[\"data\"], mnist[\"target\"], random_state=42)","ec36f4bd":"filename = \"my_mnist.data\"\nX_mm = np.memmap(filename, dtype='float32', mode='write', shape=X_train.shape)\nX_mm[:] = X_train","09220c19":"minibatch_kmeans = MiniBatchKMeans(n_clusters=10, batch_size=10, random_state=42)\nminibatch_kmeans.fit(X_mm)","dcedad0c":"def load_next_batch(batch_size):\n    return X[np.random.choice(len(X), batch_size, replace=False)]","3067e43f":"np.random.seed(42)","6f4a352a":"k = 5\nn_init = 10\nn_iterations = 100\nbatch_size = 100\ninit_size = 500  # more data for K-Means++ initialization\nevaluate_on_last_n_iters = 10\n\nbest_kmeans = None\n\nfor init in range(n_init):\n    minibatch_kmeans = MiniBatchKMeans(n_clusters=k, init_size=init_size)\n    X_init = load_next_batch(init_size)\n    minibatch_kmeans.partial_fit(X_init)\n\n    minibatch_kmeans.sum_inertia_ = 0\n    for iteration in range(n_iterations):\n        X_batch = load_next_batch(batch_size)\n        minibatch_kmeans.partial_fit(X_batch)\n        if iteration >= n_iterations - evaluate_on_last_n_iters:\n            minibatch_kmeans.sum_inertia_ += minibatch_kmeans.inertia_\n\n    if (best_kmeans is None or\n        minibatch_kmeans.sum_inertia_ < best_kmeans.sum_inertia_):\n        best_kmeans = minibatch_kmeans","fb99967b":"best_kmeans.score(X)","fa2689f6":"%timeit KMeans(n_clusters=5, random_state=42).fit(X)","600f5123":"%timeit MiniBatchKMeans(n_clusters=5, random_state=42).fit(X)","e09f82bb":"from timeit import timeit","a1ad6610":"times = np.empty((100, 2))\ninertias = np.empty((100, 2))\nfor k in range(1, 101):\n    kmeans_ = KMeans(n_clusters=k, random_state=42)\n    minibatch_kmeans = MiniBatchKMeans(n_clusters=k, random_state=42)\n    print(\"\\r{}\/{}\".format(k, 100), end=\"\")\n    times[k-1, 0] = timeit(\"kmeans_.fit(X)\", number=10, globals=globals())\n    times[k-1, 1]  = timeit(\"minibatch_kmeans.fit(X)\", number=10, globals=globals())\n    inertias[k-1, 0] = kmeans_.inertia_\n    inertias[k-1, 1] = minibatch_kmeans.inertia_","86962ee2":"plt.figure(figsize=(10,4))\n\nplt.subplot(121)\nplt.plot(range(1, 101), inertias[:, 0], \"r--\", label=\"K-Means\")\nplt.plot(range(1, 101), inertias[:, 1], \"b.-\", label=\"Mini-batch K-Means\")\nplt.xlabel(\"$k$\", fontsize=16)\nplt.title(\"Inertia\", fontsize=14)\nplt.legend(fontsize=14)\nplt.axis([1, 100, 0, 100])\n\nplt.subplot(122)\nplt.plot(range(1, 101), times[:, 0], \"r--\", label=\"K-Means\")\nplt.plot(range(1, 101), times[:, 1], \"b.-\", label=\"Mini-batch K-Means\")\nplt.xlabel(\"$k$\", fontsize=16)\nplt.title(\"Training time (seconds)\", fontsize=14)\nplt.axis([1, 100, 0, 6])\n\n#save_fig(\"minibatch_kmeans_vs_kmeans\")\nplt.show()","b1a7b19c":"kmeans_k3 = KMeans(n_clusters=3, random_state=42)\nkmeans_k8 = KMeans(n_clusters=8, random_state=42)\n\nplot_clusterer_comparison(kmeans_k3, kmeans_k8, X, \"$k=3$\", \"$k=8$\")\n#save_fig(\"bad_n_clusters_plot\")\nplt.show()","c57f4597":"kmeans_k3.inertia_","172b7ddf":"kmeans_k8.inertia_","4fe893a8":"kmeans_per_k = [KMeans(n_clusters=k, random_state=42).fit(X)\n                for k in range(1, 10)]\ninertias = [model.inertia_ for model in kmeans_per_k]","f8c72a4c":"plt.figure(figsize=(8, 3.5))\nplt.plot(range(1, 10), inertias, \"bo-\")\nplt.xlabel(\"$k$\", fontsize=14)\nplt.ylabel(\"Inertia\", fontsize=14)\nplt.annotate('Elbow',\n             xy=(4, inertias[3]),\n             xytext=(0.55, 0.55),\n             textcoords='figure fraction',\n             fontsize=16,\n             arrowprops=dict(facecolor='black', shrink=0.1)\n            )\nplt.axis([1, 8.5, 0, 1300])\n#save_fig(\"inertia_vs_k_plot\")\nplt.show()","a18100de":"plot_decision_boundaries(kmeans_per_k[4-1], X)\nplt.show()","6abbda5f":"from sklearn.metrics import silhouette_score","276cfa5d":"silhouette_score(X, kmeans.labels_)","82ab88b3":"silhouette_scores = [silhouette_score(X, model.labels_)\n                     for model in kmeans_per_k[1:]]","c78f5901":"plt.figure(figsize=(8, 3))\nplt.plot(range(2, 10), silhouette_scores, \"bo-\")\nplt.xlabel(\"$k$\", fontsize=14)\nplt.ylabel(\"Silhouette score\", fontsize=14)\nplt.axis([1.8, 8.5, 0.55, 0.7])\n#save_fig(\"silhouette_score_vs_k_plot\")\nplt.show()","355acec1":"from sklearn.metrics import silhouette_samples\nfrom matplotlib.ticker import FixedLocator, FixedFormatter\n\nplt.figure(figsize=(11, 9))\n\nfor k in (3, 4, 5, 6):\n    plt.subplot(2, 2, k - 2)\n    \n    y_pred = kmeans_per_k[k - 1].labels_\n    silhouette_coefficients = silhouette_samples(X, y_pred)\n\n    padding = len(X) \/\/ 30\n    pos = padding\n    ticks = []\n    for i in range(k):\n        coeffs = silhouette_coefficients[y_pred == i]\n        coeffs.sort()\n\n        color = mpl.cm.Spectral(i \/ k)\n        plt.fill_betweenx(np.arange(pos, pos + len(coeffs)), 0, coeffs,\n                          facecolor=color, edgecolor=color, alpha=0.7)\n        ticks.append(pos + len(coeffs) \/\/ 2)\n        pos += len(coeffs) + padding\n\n    plt.gca().yaxis.set_major_locator(FixedLocator(ticks))\n    plt.gca().yaxis.set_major_formatter(FixedFormatter(range(k)))\n    if k in (3, 5):\n        plt.ylabel(\"Cluster\")\n    \n    if k in (5, 6):\n        plt.gca().set_xticks([-0.1, 0, 0.2, 0.4, 0.6, 0.8, 1])\n        plt.xlabel(\"Silhouette Coefficient\")\n    else:\n        plt.tick_params(labelbottom=False)\n\n    plt.axvline(x=silhouette_scores[k - 2], color=\"red\", linestyle=\"--\")\n    plt.title(\"$k={}$\".format(k), fontsize=16)\n\n#save_fig(\"silhouette_analysis_plot\")\nplt.show()","3aa3838a":"X1, y1 = make_blobs(n_samples=1000, centers=((4, -4), (0, 0)), random_state=42)\nX1 = X1.dot(np.array([[0.374, 0.95], [0.732, 0.598]]))\nX2, y2 = make_blobs(n_samples=250, centers=1, random_state=42)\nX2 = X2 + [6, -8]\nX = np.r_[X1, X2]\ny = np.r_[y1, y2]","bfbb79a9":"plot_clusters(X)","a0fc9084":"kmeans_good = KMeans(n_clusters=3, init=np.array([[-1.5, 2.5], [0.5, 0], [4, 0]]), n_init=1, random_state=42)\nkmeans_bad = KMeans(n_clusters=3, random_state=42)\nkmeans_good.fit(X)\nkmeans_bad.fit(X)","16d02bbc":"plt.figure(figsize=(10, 3.2))\n\nplt.subplot(121)\nplot_decision_boundaries(kmeans_good, X)\nplt.title(\"Inertia = {:.1f}\".format(kmeans_good.inertia_), fontsize=14)\n\nplt.subplot(122)\nplot_decision_boundaries(kmeans_bad, X, show_ylabels=False)\nplt.title(\"Inertia = {:.1f}\".format(kmeans_bad.inertia_), fontsize=14)\n\n#save_fig(\"bad_kmeans_plot\")\nplt.show()","6da0043e":"from matplotlib.image import imread # you could also use `imageio.imread()`\nimage = imread(os.path.join(\"..\/input\/ladybug\/ladybug.png\"))\nimage.shape","099ed4c4":"X = image.reshape(-1, 3)\nkmeans = KMeans(n_clusters=8, random_state=42).fit(X)\nsegmented_img = kmeans.cluster_centers_[kmeans.labels_]\nsegmented_img = segmented_img.reshape(image.shape)","942e78f8":"segmented_imgs = []\nn_colors = (10, 8, 6, 4, 2)\nfor n_clusters in n_colors:\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(X)\n    segmented_img = kmeans.cluster_centers_[kmeans.labels_]\n    segmented_imgs.append(segmented_img.reshape(image.shape))","a801bc49":"plt.figure(figsize=(10,5))\nplt.subplots_adjust(wspace=0.05, hspace=0.1)\n\nplt.subplot(231)\nplt.imshow(image)\nplt.title(\"Original image\")\nplt.axis('off')\n\nfor idx, n_clusters in enumerate(n_colors):\n    plt.subplot(232 + idx)\n    plt.imshow(segmented_imgs[idx])\n    plt.title(\"{} colors\".format(n_clusters))\n    plt.axis('off')\n\n#save_fig('image_segmentation_diagram', tight_layout=False)\nplt.show()","d2809f1d":"from sklearn.datasets import load_digits","b5c81a1e":"X_digits, y_digits = load_digits(return_X_y=True)","3740622e":"from sklearn.model_selection import train_test_split","745c0905":"X_train, X_test, y_train, y_test = train_test_split(X_digits, y_digits, random_state=42)","1fd9f582":"from sklearn.linear_model import LogisticRegression","23fc40a9":"log_reg = LogisticRegression(multi_class=\"ovr\", solver=\"lbfgs\", max_iter=5000, random_state=42)\nlog_reg.fit(X_train, y_train)","81bf12ea":"log_reg_score = log_reg.score(X_test, y_test)\nlog_reg_score","bbdba033":"from sklearn.pipeline import Pipeline","e055490c":"pipeline = Pipeline([\n    (\"kmeans\", KMeans(n_clusters=50, random_state=42)),\n    (\"log_reg\", LogisticRegression(multi_class=\"ovr\", solver=\"lbfgs\", max_iter=5000, random_state=42)),\n])\npipeline.fit(X_train, y_train)","521ce669":"pipeline_score = pipeline.score(X_test, y_test)\npipeline_score","6be3812e":"1 - (1 - pipeline_score) \/ (1 - log_reg_score)","813c84fd":"from sklearn.model_selection import GridSearchCV","be9288e0":"param_grid = dict(kmeans__n_clusters=range(2, 100))\ngrid_clf = GridSearchCV(pipeline, param_grid, cv=3, verbose=2)\ngrid_clf.fit(X_train, y_train)","2ebdc88d":"grid_clf.best_params_","7ffdd010":"grid_clf.score(X_test, y_test)","78799553":"n_labeled = 50","1b623792":"log_reg = LogisticRegression(multi_class=\"ovr\", solver=\"lbfgs\", random_state=42)\nlog_reg.fit(X_train[:n_labeled], y_train[:n_labeled])\nlog_reg.score(X_test, y_test)","9a2bcb59":"k = 50","bc212d4c":"kmeans = KMeans(n_clusters=k, random_state=42)\nX_digits_dist = kmeans.fit_transform(X_train)\nrepresentative_digit_idx = np.argmin(X_digits_dist, axis=0)\nX_representative_digits = X_train[representative_digit_idx]","539af2f3":"plt.figure(figsize=(8, 2))\nfor index, X_representative_digit in enumerate(X_representative_digits):\n    plt.subplot(k \/\/ 10, 10, index + 1)\n    plt.imshow(X_representative_digit.reshape(8, 8), cmap=\"binary\", interpolation=\"bilinear\")\n    plt.axis('off')\n\n#save_fig(\"representative_images_diagram\", tight_layout=False)\nplt.show()","5bf4f742":"y_train[representative_digit_idx]","cbd70bc4":"y_representative_digits = np.array([\n    0, 1, 3, 2, 7, 6, 4, 6, 9, 5,\n    1, 2, 9, 5, 2, 7, 8, 1, 8, 6,\n    3, 2, 5, 4, 5, 4, 0, 3, 2, 6,\n    1, 7, 7, 9, 1, 8, 6, 5, 4, 8,\n    5, 3, 3, 6, 7, 9, 7, 8, 4, 9])","4dbbd30e":"log_reg = LogisticRegression(multi_class=\"ovr\", solver=\"lbfgs\", max_iter=5000, random_state=42)\nlog_reg.fit(X_representative_digits, y_representative_digits)\nlog_reg.score(X_test, y_test)","cb3fea8a":"y_train_propagated = np.empty(len(X_train), dtype=np.int32)\nfor i in range(k):\n    y_train_propagated[kmeans.labels_==i] = y_representative_digits[i]","9a75b43f":"log_reg = LogisticRegression(multi_class=\"ovr\", solver=\"lbfgs\", max_iter=5000, random_state=42)\nlog_reg.fit(X_train, y_train_propagated)","ef482b8e":"log_reg.score(X_test, y_test)","9e36f28d":"percentile_closest = 75\n\nX_cluster_dist = X_digits_dist[np.arange(len(X_train)), kmeans.labels_]\nfor i in range(k):\n    in_cluster = (kmeans.labels_ == i)\n    cluster_dist = X_cluster_dist[in_cluster]\n    cutoff_distance = np.percentile(cluster_dist, percentile_closest)\n    above_cutoff = (X_cluster_dist > cutoff_distance)\n    X_cluster_dist[in_cluster & above_cutoff] = -1","4ea8c3a3":"partially_propagated = (X_cluster_dist != -1)\nX_train_partially_propagated = X_train[partially_propagated]\ny_train_partially_propagated = y_train_propagated[partially_propagated]","df63160e":"log_reg = LogisticRegression(multi_class=\"ovr\", solver=\"lbfgs\", max_iter=5000, random_state=42)\nlog_reg.fit(X_train_partially_propagated, y_train_partially_propagated)","9c2c1bb8":"log_reg.score(X_test, y_test)","2a7b60a6":"np.mean(y_train_partially_propagated == y_train[partially_propagated])","fc40da4d":"from sklearn.datasets import make_moons","a806ce32":"X, y = make_moons(n_samples=1000, noise=0.05, random_state=42)","f33a3d05":"from sklearn.cluster import DBSCAN","ec40ad45":"dbscan = DBSCAN(eps=0.05, min_samples=5)\ndbscan.fit(X)","a7873374":"dbscan.labels_[:10]","8acef1b9":"len(dbscan.core_sample_indices_)","7df45a59":"dbscan.core_sample_indices_[:10]","a79c33f0":"dbscan.components_[:3]","c11429e6":"np.unique(dbscan.labels_)","c2c51db2":"dbscan2 = DBSCAN(eps=0.2)\ndbscan2.fit(X)","6ac902cb":"def plot_dbscan(dbscan, X, size, show_xlabels=True, show_ylabels=True):\n    core_mask = np.zeros_like(dbscan.labels_, dtype=bool)\n    core_mask[dbscan.core_sample_indices_] = True\n    anomalies_mask = dbscan.labels_ == -1\n    non_core_mask = ~(core_mask | anomalies_mask)\n\n    cores = dbscan.components_\n    anomalies = X[anomalies_mask]\n    non_cores = X[non_core_mask]\n    \n    plt.scatter(cores[:, 0], cores[:, 1],\n                c=dbscan.labels_[core_mask], marker='o', s=size, cmap=\"Paired\")\n    plt.scatter(cores[:, 0], cores[:, 1], marker='*', s=20, c=dbscan.labels_[core_mask])\n    plt.scatter(anomalies[:, 0], anomalies[:, 1],\n                c=\"r\", marker=\"x\", s=100)\n    plt.scatter(non_cores[:, 0], non_cores[:, 1], c=dbscan.labels_[non_core_mask], marker=\".\")\n    if show_xlabels:\n        plt.xlabel(\"$x_1$\", fontsize=14)\n    else:\n        plt.tick_params(labelbottom=False)\n    if show_ylabels:\n        plt.ylabel(\"$x_2$\", fontsize=14, rotation=0)\n    else:\n        plt.tick_params(labelleft=False)\n    plt.title(\"eps={:.2f}, min_samples={}\".format(dbscan.eps, dbscan.min_samples), fontsize=14)","c2bc8c62":"plt.figure(figsize=(9, 3.2))\n\nplt.subplot(121)\nplot_dbscan(dbscan, X, size=100)\n\nplt.subplot(122)\nplot_dbscan(dbscan2, X, size=600, show_ylabels=False)\n\nsave_fig(\"dbscan_plot\")\nplt.show()\n","20d395ff":"dbscan = dbscan2","be307442":"from sklearn.neighbors import KNeighborsClassifier","89edc0a9":"knn = KNeighborsClassifier(n_neighbors=50)\nknn.fit(dbscan.components_, dbscan.labels_[dbscan.core_sample_indices_])","129e8b3c":"X_new = np.array([[-0.5, 0], [0, 0.5], [1, -0.1], [2, 1]])\nknn.predict(X_new)","59136b77":"knn.predict_proba(X_new)","ae543ac6":"plt.figure(figsize=(6, 3))\nplot_decision_boundaries(knn, X, show_centroids=False)\nplt.scatter(X_new[:, 0], X_new[:, 1], c=\"b\", marker=\"+\", s=200, zorder=10)\n#save_fig(\"cluster_classification_plot\")\nplt.show()","f106cab7":"y_dist, y_pred_idx = knn.kneighbors(X_new, n_neighbors=1)\ny_pred = dbscan.labels_[dbscan.core_sample_indices_][y_pred_idx]\ny_pred[y_dist > 0.2] = -1\ny_pred.ravel()","bfddc4dc":"from sklearn.cluster import SpectralClustering","28a30ca5":"sc1 = SpectralClustering(n_clusters=2, gamma=100, random_state=42)\nsc1.fit(X)","1c627667":"sc2 = SpectralClustering(n_clusters=2, gamma=1, random_state=42)\nsc2.fit(X)","e1424633":"np.percentile(sc1.affinity_matrix_, 95)","05b6fba4":"def plot_spectral_clustering(sc, X, size, alpha, show_xlabels=True, show_ylabels=True):\n    plt.scatter(X[:, 0], X[:, 1], marker='o', s=size, c='gray', cmap=\"Paired\", alpha=alpha)\n    plt.scatter(X[:, 0], X[:, 1], marker='o', s=30, c='w')\n    plt.scatter(X[:, 0], X[:, 1], marker='.', s=10, c=sc.labels_, cmap=\"Paired\")\n    \n    if show_xlabels:\n        plt.xlabel(\"$x_1$\", fontsize=14)\n    else:\n        plt.tick_params(labelbottom=False)\n    if show_ylabels:\n        plt.ylabel(\"$x_2$\", fontsize=14, rotation=0)\n    else:\n        plt.tick_params(labelleft=False)\n    plt.title(\"RBF gamma={}\".format(sc.gamma), fontsize=14)","b0928755":"plt.figure(figsize=(9, 3.2))\n\nplt.subplot(121)\nplot_spectral_clustering(sc1, X, size=500, alpha=0.1)\n\nplt.subplot(122)\nplot_spectral_clustering(sc2, X, size=4000, alpha=0.01, show_ylabels=False)\n\nplt.show()\n","35a37aa6":"from sklearn.cluster import AgglomerativeClustering","6a9275ef":"X = np.array([0, 2, 5, 8.5]).reshape(-1, 1)\nagg = AgglomerativeClustering(linkage=\"complete\").fit(X)","09498d0a":"def learned_parameters(estimator):\n    return [attrib for attrib in dir(estimator)\n            if attrib.endswith(\"_\") and not attrib.startswith(\"_\")]","ab2ce59e":"learned_parameters(agg)","d3a284c5":"agg.children_","4ae1a539":"X1, y1 = make_blobs(n_samples=1000, centers=((4, -4), (0, 0)), random_state=42)\nX1 = X1.dot(np.array([[0.374, 0.95], [0.732, 0.598]]))\nX2, y2 = make_blobs(n_samples=250, centers=1, random_state=42)\nX2 = X2 + [6, -8]\nX = np.r_[X1, X2]\ny = np.r_[y1, y2]","b4290a9e":"from sklearn.mixture import GaussianMixture","e3c7e50a":"gm = GaussianMixture(n_components=3, n_init=10, random_state=42)\ngm.fit(X)","ca222479":"gm.weights_","709b5d16":"gm.means_","32327514":"gm.covariances_","c87a69e1":"gm.converged_","4a77a82a":"gm.n_iter_","690248a4":"gm.predict(X)","b9855e35":"gm.predict_proba(X)","bd86d421":"X_new, y_new = gm.sample(6)\nX_new","448a81e3":"y_new","835fd2ef":"gm.score_samples(X)","7631bcb1":"resolution = 100\ngrid = np.arange(-10, 10, 1 \/ resolution)\nxx, yy = np.meshgrid(grid, grid)\nX_full = np.vstack([xx.ravel(), yy.ravel()]).T\n\npdf = np.exp(gm.score_samples(X_full))\npdf_probas = pdf * (1 \/ resolution) ** 2\npdf_probas.sum()","b192012e":"from matplotlib.colors import LogNorm\n\ndef plot_gaussian_mixture(clusterer, X, resolution=1000, show_ylabels=True):\n    mins = X.min(axis=0) - 0.1\n    maxs = X.max(axis=0) + 0.1\n    xx, yy = np.meshgrid(np.linspace(mins[0], maxs[0], resolution),\n                         np.linspace(mins[1], maxs[1], resolution))\n    Z = -clusterer.score_samples(np.c_[xx.ravel(), yy.ravel()])\n    Z = Z.reshape(xx.shape)\n\n    plt.contourf(xx, yy, Z,\n                 norm=LogNorm(vmin=1.0, vmax=30.0),\n                 levels=np.logspace(0, 2, 12))\n    plt.contour(xx, yy, Z,\n                norm=LogNorm(vmin=1.0, vmax=30.0),\n                levels=np.logspace(0, 2, 12),\n                linewidths=1, colors='k')\n\n    Z = clusterer.predict(np.c_[xx.ravel(), yy.ravel()])\n    Z = Z.reshape(xx.shape)\n    plt.contour(xx, yy, Z,\n                linewidths=2, colors='r', linestyles='dashed')\n    \n    plt.plot(X[:, 0], X[:, 1], 'k.', markersize=2)\n    plot_centroids(clusterer.means_, clusterer.weights_)\n\n    plt.xlabel(\"$x_1$\", fontsize=14)\n    if show_ylabels:\n        plt.ylabel(\"$x_2$\", fontsize=14, rotation=0)\n    else:\n        plt.tick_params(labelleft=False)","61595364":"plt.figure(figsize=(8, 4))\n\nplot_gaussian_mixture(gm, X)\n\n#save_fig(\"gaussian_mixtures_plot\")\nplt.show()","5da22cfc":"gm_full = GaussianMixture(n_components=3, n_init=10, covariance_type=\"full\", random_state=42)\ngm_tied = GaussianMixture(n_components=3, n_init=10, covariance_type=\"tied\", random_state=42)\ngm_spherical = GaussianMixture(n_components=3, n_init=10, covariance_type=\"spherical\", random_state=42)\ngm_diag = GaussianMixture(n_components=3, n_init=10, covariance_type=\"diag\", random_state=42)\ngm_full.fit(X)\ngm_tied.fit(X)\ngm_spherical.fit(X)\ngm_diag.fit(X)","8c0457e7":"def compare_gaussian_mixtures(gm1, gm2, X):\n    plt.figure(figsize=(9, 4))\n\n    plt.subplot(121)\n    plot_gaussian_mixture(gm1, X)\n    plt.title('covariance_type=\"{}\"'.format(gm1.covariance_type), fontsize=14)\n\n    plt.subplot(122)\n    plot_gaussian_mixture(gm2, X, show_ylabels=False)\n    plt.title('covariance_type=\"{}\"'.format(gm2.covariance_type), fontsize=14)\n","2c9eed52":"compare_gaussian_mixtures(gm_tied, gm_spherical, X)\n\n#save_fig(\"covariance_type_plot\")\nplt.show()","9ee3a33c":"compare_gaussian_mixtures(gm_full, gm_diag, X)\nplt.tight_layout()\nplt.show()","6efc45ee":"densities = gm.score_samples(X)\ndensity_threshold = np.percentile(densities, 4)\nanomalies = X[densities < density_threshold]","3fae9a6d":"plt.figure(figsize=(8, 4))\n\nplot_gaussian_mixture(gm, X)\nplt.scatter(anomalies[:, 0], anomalies[:, 1], color='r', marker='*')\nplt.ylim(top=5.1)\n\n#save_fig(\"mixture_anomaly_detection_plot\")\nplt.show()","c4646d43":"gm.bic(X)","921d0161":"gm.aic(X)","492a59a6":"n_clusters = 3\nn_dims = 2\nn_params_for_weights = n_clusters - 1\nn_params_for_means = n_clusters * n_dims\nn_params_for_covariance = n_clusters * n_dims * (n_dims + 1) \/\/ 2\nn_params = n_params_for_weights + n_params_for_means + n_params_for_covariance\nmax_log_likelihood = gm.score(X) * len(X) # log(L^)\nbic = np.log(len(X)) * n_params - 2 * max_log_likelihood\naic = 2 * n_params - 2 * max_log_likelihood","3b904942":"bic, aic","bae37dad":"n_params","9e3bb522":"gms_per_k = [GaussianMixture(n_components=k, n_init=10, random_state=42).fit(X)\n             for k in range(1, 11)]","fc286ba8":"bics = [model.bic(X) for model in gms_per_k]\naics = [model.aic(X) for model in gms_per_k]","78eee2ee":"plt.figure(figsize=(8, 3))\nplt.plot(range(1, 11), bics, \"bo-\", label=\"BIC\")\nplt.plot(range(1, 11), aics, \"go--\", label=\"AIC\")\nplt.xlabel(\"$k$\", fontsize=14)\nplt.ylabel(\"Information Criterion\", fontsize=14)\nplt.axis([1, 9.5, np.min(aics) - 50, np.max(aics) + 50])\nplt.annotate('Minimum',\n             xy=(3, bics[2]),\n             xytext=(0.35, 0.6),\n             textcoords='figure fraction',\n             fontsize=14,\n             arrowprops=dict(facecolor='black', shrink=0.1)\n            )\nplt.legend()\n#save_fig(\"aic_bic_vs_k_plot\")\nplt.show()","bb69c3e6":"min_bic = np.infty\n\nfor k in range(1, 11):\n    for covariance_type in (\"full\", \"tied\", \"spherical\", \"diag\"):\n        bic = GaussianMixture(n_components=k, n_init=10,\n                              covariance_type=covariance_type,\n                              random_state=42).fit(X).bic(X)\n        if bic < min_bic:\n            min_bic = bic\n            best_k = k\n            best_covariance_type = covariance_type","091620a5":"best_k","6ac7b9e7":"best_covariance_type","83bd7e9b":"from sklearn.mixture import BayesianGaussianMixture","132c80ba":"bgm = BayesianGaussianMixture(n_components=10, n_init=10, random_state=42)\nbgm.fit(X)","5de61910":"np.round(bgm.weights_, 2)","56b2ae9a":"plt.figure(figsize=(8, 5))\nplot_gaussian_mixture(bgm, X)\nplt.show()","464649ce":"bgm_low = BayesianGaussianMixture(n_components=10, max_iter=1000, n_init=1,\n                                  weight_concentration_prior=0.01, random_state=42)\nbgm_high = BayesianGaussianMixture(n_components=10, max_iter=1000, n_init=1,\n                                  weight_concentration_prior=10000, random_state=42)\nnn = 73\nbgm_low.fit(X[:nn])\nbgm_high.fit(X[:nn])","3186f523":"np.round(bgm_low.weights_, 2)","8200316d":"np.round(bgm_high.weights_, 2)","d65ef1cf":"plt.figure(figsize=(9, 4))\n\nplt.subplot(121)\nplot_gaussian_mixture(bgm_low, X[:nn])\nplt.title(\"weight_concentration_prior = 0.01\", fontsize=14)\n\nplt.subplot(122)\nplot_gaussian_mixture(bgm_high, X[:nn], show_ylabels=False)\nplt.title(\"weight_concentration_prior = 10000\", fontsize=14)\n\n#save_fig(\"mixture_concentration_prior_plot\")\nplt.show()","44fb9d42":"X_moons, y_moons = make_moons(n_samples=1000, noise=0.05, random_state=42)","98c5e637":"bgm = BayesianGaussianMixture(n_components=10, n_init=10, random_state=42)\nbgm.fit(X_moons)","430fa043":"plt.figure(figsize=(9, 3.2))\n\nplt.subplot(121)\nplot_data(X_moons)\nplt.xlabel(\"$x_1$\", fontsize=14)\nplt.ylabel(\"$x_2$\", fontsize=14, rotation=0)\n\nplt.subplot(122)\nplot_gaussian_mixture(bgm, X_moons, show_ylabels=False)\n\n#save_fig(\"moons_vs_bgm_plot\")\nplt.show()","a7808a46":"from scipy.stats import norm","47a2a8a4":"xx = np.linspace(-6, 4, 101)\nss = np.linspace(1, 2, 101)\nXX, SS = np.meshgrid(xx, ss)\nZZ = 2 * norm.pdf(XX - 1.0, 0, SS) + norm.pdf(XX + 4.0, 0, SS)\nZZ = ZZ \/ ZZ.sum(axis=1)[:,np.newaxis] \/ (xx[1] - xx[0])","b713191f":"from matplotlib.patches import Polygon\n\nplt.figure(figsize=(8, 4.5))\n\nx_idx = 85\ns_idx = 30\n\nplt.subplot(221)\nplt.contourf(XX, SS, ZZ, cmap=\"GnBu\")\nplt.plot([-6, 4], [ss[s_idx], ss[s_idx]], \"k-\", linewidth=2)\nplt.plot([xx[x_idx], xx[x_idx]], [1, 2], \"b-\", linewidth=2)\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$\\theta$\", fontsize=14, rotation=0)\nplt.title(r\"Model $f(x; \\theta)$\", fontsize=14)\n\nplt.subplot(222)\nplt.plot(ss, ZZ[:, x_idx], \"b-\")\nmax_idx = np.argmax(ZZ[:, x_idx])\nmax_val = np.max(ZZ[:, x_idx])\nplt.plot(ss[max_idx], max_val, \"r.\")\nplt.plot([ss[max_idx], ss[max_idx]], [0, max_val], \"r:\")\nplt.plot([0, ss[max_idx]], [max_val, max_val], \"r:\")\nplt.text(1.01, max_val + 0.005, r\"$\\hat{L}$\", fontsize=14)\nplt.text(ss[max_idx]+ 0.01, 0.055, r\"$\\hat{\\theta}$\", fontsize=14)\nplt.text(ss[max_idx]+ 0.01, max_val - 0.012, r\"$Max$\", fontsize=12)\nplt.axis([1, 2, 0.05, 0.15])\nplt.xlabel(r\"$\\theta$\", fontsize=14)\nplt.grid(True)\nplt.text(1.99, 0.135, r\"$=f(x=2.5; \\theta)$\", fontsize=14, ha=\"right\")\nplt.title(r\"Likelihood function $\\mathcal{L}(\\theta|x=2.5)$\", fontsize=14)\n\nplt.subplot(223)\nplt.plot(xx, ZZ[s_idx], \"k-\")\nplt.axis([-6, 4, 0, 0.25])\nplt.xlabel(r\"$x$\", fontsize=14)\nplt.grid(True)\nplt.title(r\"PDF $f(x; \\theta=1.3)$\", fontsize=14)\nverts = [(xx[41], 0)] + list(zip(xx[41:81], ZZ[s_idx, 41:81])) + [(xx[80], 0)]\npoly = Polygon(verts, facecolor='0.9', edgecolor='0.5')\nplt.gca().add_patch(poly)\n\nplt.subplot(224)\nplt.plot(ss, np.log(ZZ[:, x_idx]), \"b-\")\nmax_idx = np.argmax(np.log(ZZ[:, x_idx]))\nmax_val = np.max(np.log(ZZ[:, x_idx]))\nplt.plot(ss[max_idx], max_val, \"r.\")\nplt.plot([ss[max_idx], ss[max_idx]], [-5, max_val], \"r:\")\nplt.plot([0, ss[max_idx]], [max_val, max_val], \"r:\")\nplt.axis([1, 2, -2.4, -2])\nplt.xlabel(r\"$\\theta$\", fontsize=14)\nplt.text(ss[max_idx]+ 0.01, max_val - 0.05, r\"$Max$\", fontsize=12)\nplt.text(ss[max_idx]+ 0.01, -2.39, r\"$\\hat{\\theta}$\", fontsize=14)\nplt.text(1.01, max_val + 0.02, r\"$\\log \\, \\hat{L}$\", fontsize=14)\nplt.grid(True)\nplt.title(r\"$\\log \\, \\mathcal{L}(\\theta|x=2.5)$\", fontsize=14)\n\n#save_fig(\"likelihood_function_plot\")\nplt.show()","c1ebdec5":"from sklearn.datasets import fetch_olivetti_faces\n\nolivetti = fetch_olivetti_faces()","dd90814f":"print(olivetti.DESCR)","2d4f93ab":"olivetti.target","c8883c3a":"from sklearn.model_selection import StratifiedShuffleSplit\n\nstrat_split = StratifiedShuffleSplit(n_splits=1, test_size=40, random_state=42)\ntrain_valid_idx, test_idx = next(strat_split.split(olivetti.data, olivetti.target))\nX_train_valid = olivetti.data[train_valid_idx]\ny_train_valid = olivetti.target[train_valid_idx]\nX_test = olivetti.data[test_idx]\ny_test = olivetti.target[test_idx]\n\nstrat_split = StratifiedShuffleSplit(n_splits=1, test_size=80, random_state=43)\ntrain_idx, valid_idx = next(strat_split.split(X_train_valid, y_train_valid))\nX_train = X_train_valid[train_idx]\ny_train = y_train_valid[train_idx]\nX_valid = X_train_valid[valid_idx]\ny_valid = y_train_valid[valid_idx]","8bfda8c3":"print(X_train.shape, y_train.shape)\nprint(X_valid.shape, y_valid.shape)\nprint(X_test.shape, y_test.shape)","14436e29":"from sklearn.decomposition import PCA\n\npca = PCA(0.99)\nX_train_pca = pca.fit_transform(X_train)\nX_valid_pca = pca.transform(X_valid)\nX_test_pca = pca.transform(X_test)\n\npca.n_components_","950235a6":"from sklearn.cluster import KMeans\n\nk_range = range(5, 150, 5)\nkmeans_per_k = []\nfor k in k_range:\n    print(\"k={}\".format(k))\n    kmeans = KMeans(n_clusters=k, random_state=42).fit(X_train_pca)\n    kmeans_per_k.append(kmeans)","239d19b4":"from sklearn.metrics import silhouette_score\n\nsilhouette_scores = [silhouette_score(X_train_pca, model.labels_)\n                     for model in kmeans_per_k]\nbest_index = np.argmax(silhouette_scores)\nbest_k = k_range[best_index]\nbest_score = silhouette_scores[best_index]\n\nplt.figure(figsize=(8, 3))\nplt.plot(k_range, silhouette_scores, \"bo-\")\nplt.xlabel(\"$k$\", fontsize=14)\nplt.ylabel(\"Silhouette score\", fontsize=14)\nplt.plot(best_k, best_score, \"rs\")\nplt.show()","c7015ce6":"best_k","21195f3b":"inertias = [model.inertia_ for model in kmeans_per_k]\nbest_inertia = inertias[best_index]\n\nplt.figure(figsize=(8, 3.5))\nplt.plot(k_range, inertias, \"bo-\")\nplt.xlabel(\"$k$\", fontsize=14)\nplt.ylabel(\"Inertia\", fontsize=14)\nplt.plot(best_k, best_inertia, \"rs\")\nplt.show()","8c533099":"best_model = kmeans_per_k[best_index]","93f1a160":"def plot_faces(faces, labels, n_cols=5):\n    faces = faces.reshape(-1, 64, 64)\n    n_rows = (len(faces) - 1) \/\/ n_cols + 1\n    plt.figure(figsize=(n_cols, n_rows * 1.1))\n    for index, (face, label) in enumerate(zip(faces, labels)):\n        plt.subplot(n_rows, n_cols, index + 1)\n        plt.imshow(face, cmap=\"gray\")\n        plt.axis(\"off\")\n        plt.title(label)\n    plt.show()\n\nfor cluster_id in np.unique(best_model.labels_):\n    print(\"Cluster\", cluster_id)\n    in_cluster = best_model.labels_==cluster_id\n    faces = X_train[in_cluster]\n    labels = y_train[in_cluster]\n    plot_faces(faces, labels)","23a2f0d5":"from sklearn.ensemble import RandomForestClassifier\n\nclf = RandomForestClassifier(n_estimators=150, random_state=42)\nclf.fit(X_train_pca, y_train)\nclf.score(X_valid_pca, y_valid)","b27bba1d":"X_train_reduced = best_model.transform(X_train_pca)\nX_valid_reduced = best_model.transform(X_valid_pca)\nX_test_reduced = best_model.transform(X_test_pca)\n\nclf = RandomForestClassifier(n_estimators=150, random_state=42)\nclf.fit(X_train_reduced, y_train)\n    \nclf.score(X_valid_reduced, y_valid)","325fdd32":"from sklearn.pipeline import Pipeline\n\nfor n_clusters in k_range:\n    pipeline = Pipeline([\n        (\"kmeans\", KMeans(n_clusters=n_clusters, random_state=42)),\n        (\"forest_clf\", RandomForestClassifier(n_estimators=150, random_state=42))\n    ])\n    pipeline.fit(X_train_pca, y_train)\n    print(n_clusters, pipeline.score(X_valid_pca, y_valid))","116e4bea":"X_train_extended = np.c_[X_train_pca, X_train_reduced]\nX_valid_extended = np.c_[X_valid_pca, X_valid_reduced]\nX_test_extended = np.c_[X_test_pca, X_test_reduced]","9d04bd60":"clf = RandomForestClassifier(n_estimators=150, random_state=42)\nclf.fit(X_train_extended, y_train)\nclf.score(X_valid_extended, y_valid)","8fadb414":"from sklearn.mixture import GaussianMixture\n\ngm = GaussianMixture(n_components=40, random_state=42)\ny_pred = gm.fit_predict(X_train_pca)","c9d374e7":"n_gen_faces = 20\ngen_faces_reduced, y_gen_faces = gm.sample(n_samples=n_gen_faces)\ngen_faces = pca.inverse_transform(gen_faces_reduced)","41a53b97":"plot_faces(gen_faces, y_gen_faces)","82bc62fc":"n_rotated = 4\nrotated = np.transpose(X_train[:n_rotated].reshape(-1, 64, 64), axes=[0, 2, 1])\nrotated = rotated.reshape(-1, 64*64)\ny_rotated = y_train[:n_rotated]\n\nn_flipped = 3\nflipped = X_train[:n_flipped].reshape(-1, 64, 64)[:, ::-1]\nflipped = flipped.reshape(-1, 64*64)\ny_flipped = y_train[:n_flipped]\n\nn_darkened = 3\ndarkened = X_train[:n_darkened].copy()\ndarkened[:, 1:-1] *= 0.3\ny_darkened = y_train[:n_darkened]\n\nX_bad_faces = np.r_[rotated, flipped, darkened]\ny_bad = np.concatenate([y_rotated, y_flipped, y_darkened])\n\nplot_faces(X_bad_faces, y_bad)","85799026":"X_bad_faces_pca = pca.transform(X_bad_faces)","d4b7af53":"gm.score_samples(X_bad_faces_pca)","df9f0cc2":"gm.score_samples(X_train_pca[:10])","bb797cdd":"X_train_pca","c5957a3a":"def reconstruction_errors(pca, X):\n    X_pca = pca.transform(X)\n    X_reconstructed = pca.inverse_transform(X_pca)\n    mse = np.square(X_reconstructed - X).mean(axis=-1)\n    return mse","5c22caac":"reconstruction_errors(pca, X_train).mean()","16d4ef46":"reconstruction_errors(pca, X_bad_faces).mean()","c7a8fd99":"plot_faces(X_bad_faces, y_bad)","69ba72cb":"X_bad_faces_reconstructed = pca.inverse_transform(X_bad_faces_pca)\nplot_faces(X_bad_faces_reconstructed, y_bad)","c89508a2":"Yikes! That's not better at all! Let's see if tuning the number of clusters helps.","40376791":"And let's plot this:","defc843e":"### Fit and Predict","1f441708":"Let's start by generating some blobs:","fd470258":"How about that? We reduced the error rate by over 35%! But we chose the number of clusters $k$ completely arbitrarily, we can surely do better. Since K-Means is just a preprocessing step in a classification pipeline, finding a good value for $k$ is much simpler than earlier: there's no need to perform silhouette analysis or minimize the inertia, the best value of $k$ is simply the one that results in the best classification performance.","6d4ab7fc":"Let's split it into a training set and a test set:","08fda0a6":"### Clustering for Semi-supervised Learning","bab5651c":"Let's train a Gaussian mixture model on the previous dataset:","8bd9cf02":"Did the algorithm actually converge?","bf0520c8":"About 2 out of 3 clusters are useful: that is, they contain at least 2 pictures, all of the same person. However, the rest of the clusters have either one or more intruders, or they have just a single picture.\n\nClustering images this way may be too imprecise to be directly useful when training a model (as we will see below), but it can be tremendously useful when labeling images in a new dataset: it will usually make labelling much faster.","495858f9":"We could use a `GridSearchCV` like we did earlier in this notebook, but since we already have a validation set, we don't need K-fold cross-validation, and we're only exploring a single hyperparameter, so it's simpler to just run a loop manually:","6bc4687a":"## 11. Using Clustering as Preprocessing for Classification","ccbc0980":"*Exercise: Next, use K-Means as a dimensionality reduction tool, and train a classifier on the reduced set.*","a5602d00":"In the original K-Means algorithm, the centroids are just initialized randomly, and the algorithm simply runs a single iteration to gradually improve the centroids, as we saw above.\n\nHowever, one major problem with this approach is that if you run K-Means multiple times (or with different random seeds), it can converge to very different solutions, as you can see below:","8c538460":"Okay, that's our baseline: 96.89% accuracy. Let's see if we can do better by using K-Means as a preprocessing step. We will create a pipeline that will first cluster the training set into 50 clusters and replace the images with their distances to the 50 clusters, then apply a logistic regression model:","d8d9384b":"So one approach to solve the variability issue is to simply run the K-Means algorithm multiple times with different random initializations, and select the solution that minimizes the inertia. For example, here are the inertias of the two \"bad\" models shown in the previous figure:","84d912a8":"As you can see, $k=5$ looks like the best option here, as all clusters are roughly the same size, and they all cross the dashed line, which represents the mean silhouette score.","dea58b79":"That's a bit better, but still worse than without the cluster features. The clusters are not useful to directly train a classifier in this case (but they can still help when labelling new training instances).","09a7cc82":"As you can see, this visualization is much richer than the previous one: in particular, although it confirms that $k=4$ is a very good choice, but it also underlines the fact that $k=5$ is quite good as well.","639580f6":"Let's train a K-Means clusterer on this dataset. It will try to find each blob's center and assign each instance to the closest blob:","880ff240":"Mini-batch K-Means is much faster than regular K-Means:","ac32df4a":"*Exercise: Continuing with the Olivetti faces dataset, train a classifier to predict which person is represented in each picture, and evaluate it on the validation set.*","bb690283":"*Exercise: Some dimensionality reduction techniques can also be used for anomaly detection. For example, take the Olivetti faces dataset and reduce it with PCA, preserving 99% of the variance. Then compute the reconstruction error for each image. Next, take some of the modified images you built in the previous exercise, and look at their reconstruction error: notice how much larger the reconstruction error is. If you plot a reconstructed image, you will see why: it tries to reconstruct a normal face.*","8455c0e9":"This is a generative model, so you can sample new instances from it (and get their labels):","a1f0d21e":"Now we have a dataset with just 50 labeled instances, but instead of being completely random instances, each of them is a representative image of its cluster. Let's see if the performance is any better:","6ad04f70":"As you can see, there is an elbow at $k=4$, which means that less clusters than that would be bad, and more clusters would not help much and might cut clusters in half. So $k=4$ is a pretty good choice. Of course in this example it is not perfect since it means that the two blobs in the lower left will be considered as just a single cluster, but it's a pretty good clustering nonetheless.","85265504":"Let's plot the model's decision boundaries. This gives us a _Voronoi diagram_:","852dab2b":"The K-Means algorithm can be significantly accelerated by avoiding many unnecessary distance calculations: this is achieved by exploiting the triangle inequality (given three points A, B and C, the distance AC is always such that AC \u2264 AB + BC) and by keeping track of lower and upper bounds for distances between instances and centroids (see this [2003 paper](https:\/\/www.aaai.org\/Papers\/ICML\/2003\/ICML03-022.pdf) by Charles Elkan for more details).","772e63f4":"Next, let's write it to a `memmap`:","1d5cfb85":"## 10. Cluster the Olivetti Faces Dataset","30c4c153":"### Accelerated K-Means","e7abb6ad":"### K-Means++","98915e11":"This is because the propagated labels are actually pretty good: their accuracy is close to 96%:","c1f3dd07":"A bit better. With just 50 labeled instances (just 5 examples per class on average!), we got 92.7% performance, which is getting closer to the performance of logistic regression on the fully labeled _digits_ dataset (which was 96.9%).","c832278f":"*Exercise: Search for the number of clusters that allows the classifier to get the best performance: what performance can you reach?*","8a7f488f":"To speed things up, we'll reduce the data's dimensionality using PCA:","c68070d6":"Of course, we can predict the labels of new instances:","30d8bbf0":"Let's search for best combination of values for both the number of clusters and the `covariance_type` hyperparameter:","aa15c818":"The algorithm automatically detected that only 3 components are needed:","c3209492":"But perhaps we can go one step further: what if we propagated the labels to all the other instances in the same cluster?","d3f00d11":"You can impose constraints on the covariance matrices that the algorithm looks for by setting the `covariance_type` hyperparameter:\n* `\"full\"` (default): no constraint, all clusters can take on any ellipsoidal shape of any size.\n* `\"tied\"`: all clusters must have the same shape, which can be any ellipsoid (i.e., they all share the same covariance matrix).\n* `\"spherical\"`: all clusters must be spherical, but they can have different diameters (i.e., different variances).\n* `\"diag\"`: clusters can take on any ellipsoidal shape of any size, but the ellipsoid's axes must be parallel to the axes (i.e., the covariance matrices must be diagonal).","167bc21d":"**Warning**: the following cell may take close to 20 minutes to run, or more depending on your hardware.","a1a312b3":"An even more informative visualization is given when you plot every instance's silhouette coefficient, sorted by the cluster they are assigned to and by the value of the coefficient. This is called a _silhouette diagram_:","ad73d9b9":"If your data is so large that you cannot use `memmap`, things get more complicated. Let's start by writing a function to load the next batch (in real life, you would load the data from disk):","3ab9a5a2":"## DBSCAN","e4137765":"The optimal number of clusters is not clear on this inertia diagram, as there is no obvious elbow, so let's stick with k=120.","b1e7d60a":"Note: the fact that you see only 3 regions in the right plot although there are 4 centroids is not a bug. The weight of the top-right cluster is much larger than the weight of the lower-right cluster, so the probability that any given point in this region belongs to the top right cluster is greater than the probability that it belongs to the lower-right cluster.","34014b7f":"Rather than manually searching for the optimal number of clusters, it is possible to use instead the `BayesianGaussianMixture` class which is capable of giving weights equal (or close) to zero to unnecessary clusters. Just set the number of components to a value that you believe is greater than the optimal number of clusters, and the algorithm will eliminate the unnecessary clusters automatically.","aa1167a1":"Yes, good. How many iterations did it take?","cd6809b6":"Notice that they are sampled sequentially from each cluster.","00b24b3a":"Not bad! Some of the instances near the edges were probably assigned to the wrong cluster, but overall it looks pretty good.","0977f7fe":"To select the best model, we will need a way to evaluate a K-Mean model's performance. Unfortunately, clustering is an unsupervised task, so we do not have the targets. But at least we can measure the distance between each instance and its centroid. This is the idea behind the _inertia_ metric:","b0ccaf39":"The `score()` method returns the negative inertia. Why negative? Well, it is because a predictor's `score()` method must always respect the \"_greater is better_\" rule.","76556a57":"# Clustering","b8bfa52f":"As you can see, they have a higher inertia than the first \"good\" model we trained, which means they are probably worse.","4bd3450b":"## Likelihood Function","87c8c912":"*Exercise: Use the model to generate some new faces (using the `sample()` method), and visualize them (if you used PCA, you will need to use its `inverse_transform()` method).*","ce87449c":"Let's run the K-Means algorithm for 1, 2 and 3 iterations, to see how the centroids move around:","cabd0bec":"*Exercise: Then split it into a training set, a validation set, and a test set (note that the dataset is already scaled between 0 and 1). Since the dataset is quite small, you probably want to use stratified sampling to ensure that there are the same number of images per person in each set.*","3090646f":"There's no big difference in this case, as the dataset is fairly small.","ca64e7ce":"It looks like the best number of clusters is quite high, at 120. You might have expected it to be 40, since there are 40 different people on the pictures. However, the same person may look quite different on different pictures (e.g., with or without glasses, or simply shifted left or right).","2afc1952":"You can now use the model to predict which cluster each instance belongs to (hard clustering) or the probabilities that it came from each cluster. For this, just use `predict()` method or the `predict_proba()` method:","37ccdf2e":"*Exercise: Next, cluster the images using K-Means, and ensure that you have a good number of clusters (using one of the techniques discussed in this chapter).*","0271419c":"Wow! We jumped from 83.3% accuracy to 91.3%, although we are still only training the model on 50 instances. Since it's often costly and painful to label instances, especially when it has to be done manually by experts, it's a good idea to make them label representative instances rather than just random instances.","8b26b229":"*Exercise: Visualize the clusters: do you see similar faces in each cluster?*","43411cd5":"### Finding the optimal number of clusters","bc354de6":"### Inertia","d5e6c1ab":"Let's see what the best number of clusters is:","df1124f4":"As you can easily verify, inertia is the sum of the squared distances between each training instance and its closest centroid:","f839676d":"## Introduction \u2013 Classification _vs_ Clustering","680eb848":"## Anomaly Detection using Gaussian Mixtures","1783d51c":"Oops, not great... instead of detecting 2 moon-shaped clusters, the algorithm detected 8 ellipsoidal clusters. However, the density plot does not look too bad, so it might be usable for anomaly detection.","8c3a265b":"Now let's plot them:","102492a8":"### Decision Boundaries","87b0db11":"Scikit-Learn also implements a variant of the K-Means algorithm that supports mini-batches (see [this paper](http:\/\/www.eecs.tufts.edu\/~dsculley\/papers\/fastkmeans.pdf)):","7e406048":"### Using Clustering for Preprocessing","ef013730":"To set the initialization to K-Means++, simply set `init=\"k-means++\"` (this is actually the default):","c0e527e8":"Now let's plot the resulting decision boundaries (dashed lines) and density contours:","e444aa64":"Let's check that the PDF integrates to 1 over the whole space. We just take a large square around the clusters, and chop it into a grid of tiny squares, then we compute the approximate probability that the instances will be generated in each tiny square (by multiplying the PDF at one corner of the tiny square by the area of the square), and finally summing all these probabilities). The result is very close to 1:","dc69ad87":"Now let's fit a Logistic Regression model and evaluate it on the test set:","0553c4c1":"### Mini-Batch K-Means","bc55e7fc":"# Gaussian Mixtures","dc580384":"Note that the `KMeans` instance preserves the labels of the instances it was trained on. Somewhat confusingly, in this context, the _label_ of an instance is the index of the cluster that instance gets assigned to:","abc79bc5":"A Gaussian mixture model (explained below) can actually separate these clusters pretty well (using all 4 features: petal length & width, and sepal length & width).","f854ceb5":"**Note**: the results in this notebook may differ slightly from the book. This is because algorithms can sometimes be tweaked a bit between Scikit-Learn versions.","8db1051d":"*Exercise: The classic Olivetti faces dataset contains 400 grayscale 64 \u00d7 64\u2013pixel images of faces. Each image is flattened to a 1D vector of size 4,096. 40 different people were photographed (10 times each), and the usual task is to train a model that can predict which person is represented in each picture. Load the dataset using the `sklearn.datasets.fetch_olivetti_faces()` function.*","8da5c83c":"### K-Means Algorithm","c4e5789a":"You can also estimate the log of the _probability density function_ (PDF) at any location using the `score_samples()` method:","cf2b7460":"Let's map each cluster to a class. Instead of hard coding the mapping (as is done in the book, for simplicity), we will pick the most common class for each cluster (using the `scipy.stats.mode()` function):","25674daa":"How much did the error rate drop?","a3b61778":"Instead of initializing the centroids entirely randomly, it is preferable to initialize them using the following algorithm, proposed in a [2006 paper](https:\/\/goo.gl\/eNUPw6) by David Arthur and Sergei Vassilvitskii:\n* Take one centroid $c_1$, chosen uniformly at random from the dataset.\n* Take a new center $c_i$, choosing an instance $\\mathbf{x}_i$ with probability: $D(\\mathbf{x}_i)^2$ \/ $\\sum\\limits_{j=1}^{m}{D(\\mathbf{x}_j)}^2$ where $D(\\mathbf{x}_i)$ is the distance between the instance $\\mathbf{x}_i$ and the closest centroid that was already chosen. This probability distribution ensures that instances that are further away from already chosen centroids are much more likely be selected as centroids.\n* Repeat the previous step until all $k$ centroids have been chosen.","7945271e":"Another approach is to look at the _silhouette score_, which is the mean _silhouette coefficient_ over all the instances. An instance's silhouette coefficient is equal to $(b - a)\/\\max(a, b)$ where $a$ is the mean distance to the other instances in the same cluster (it is the _mean intra-cluster distance_), and $b$ is the _mean nearest-cluster distance_, that is the mean distance to the instances of the next closest cluster (defined as the one that minimizes $b$, excluding the instance's own cluster). The silhouette coefficient can vary between -1 and +1: a coefficient close to +1 means that the instance is well inside its own cluster and far from other clusters, while a coefficient close to 0 means that it is close to a cluster boundary, and finally a coefficient close to -1 means that the instance may have been assigned to the wrong cluster.","3e024c9d":"Now we can train the model by feeding it one batch at a time. We also need to implement multiple initializations and keep the model with the lowest inertia:","51acd919":"We could compute the BIC manually like this:","aeb5405a":"It's much less than earlier of course. Let's see how we can do better. First, let's cluster the training set into 50 clusters, then for each cluster let's find the image closest to the centroid. We will call these images the representative images:","f8b9eb84":"Gaussian Mixtures can be used for _anomaly detection_: instances located in low-density regions can be considered anomalies. You must define what density threshold you want to use. For example, in a manufacturing company that tries to detect defective products, the ratio of defective products is usually well-known. Say it is equal to 4%, then you can set the density threshold to be the value that results in having 4% of the instances located in areas below that threshold density:","a74fa8b2":"Oh well, even by tuning the number of clusters, we never get beyond 80% accuracy. Looks like the distances to the cluster centroids are not as informative as the original images.","24a9a0bd":"*Exercise: Train a Gaussian mixture model on the Olivetti faces dataset. To speed up the algorithm, you should probably reduce the dataset's dimensionality (e.g., use PCA, preserving 99% of the variance).*","669245fa":"### Multiple Initializations","15a16207":"The K-Means algorithm is one of the fastest clustering algorithms, and also one of the simplest:\n* First initialize $k$ centroids randomly: $k$ distinct instances are chosen randomly from the dataset and the centroids are placed at their locations.\n* Repeat until convergence (i.e., until the centroids stop moving):\n    * Assign each instance to the closest centroid.\n    * Update the centroids to be the mean of the instances that are assigned to them.","08d37aae":"Rather than arbitrarily choosing the closest cluster for each instance, which is called _hard clustering_, it might be better measure the distance of each instance to all 5 centroids. This is what the `transform()` method does:","9034379f":"Let's tackle the _digits dataset_ which is a simple MNIST-like dataset containing 1,797 grayscale 8\u00d78 images representing digits 0 to 9.","3760f65c":"## K-Means","e401bbe2":"Let's look at the parameters that the EM algorithm estimated:","e9f18b4e":"No, we cannot simply take the value of $k$ that minimizes the inertia, since it keeps getting lower as we increase $k$. Indeed, the more clusters there are, the closer each instance will be to its closest centroid, and therefore the lower the inertia will be. However, we can plot the inertia as a function of $k$ and analyze the resulting curve:","6be91b64":"## 12. A Gaussian Mixture Model for the Olivetti Faces Dataset","fbec4937":"## 13. Using Dimensionality Reduction Techniques for Anomaly Detection","70e65c27":"We got a tiny little accuracy boost. Better than nothing, but we should probably have propagated the labels only to the instances closest to the centroid, because by propagating to the full cluster, we have certainly included some outliers. Let's only propagate the labels to the 75th percentile closest to the centroid:","68f51bd0":"# Setup","e0f34b5e":"Now let's plot these representative images and label them manually:","12ab023b":"# Additional Practice Exercise","9fefa0bb":"Let's look at the performance of a logistic regression model when we only have 50 labeled instances:","7aa2bb0d":"Each instance was assigned to one of the 5 clusters:","17deea91":"The rest of the K-Means++ algorithm is just regular K-Means. With this initialization, the K-Means algorithm is much less likely to converge to a suboptimal solution, so it is possible to reduce `n_init` considerably. Most of the time, this largely compensates for the additional complexity of the initialization process.","97f5071b":"### Limits of K-Means","3194b6a4":"The `KMeans` class applies an optimized algorithm by default. To get the original K-Means algorithm (for educational purposes only), you must set `init=\"random\"`, `n_init=1`and `algorithm=\"full\"`. These hyperparameters will be explained below.","74d8a5e4":"Let's plot the silhouette score as a function of $k$:","4deb4d7e":"And the following 5 _centroids_ (i.e., cluster centers) were estimated:","9d573457":"Ouch, these two models don't look great. What about their inertias?","2b4da297":"*Exercise: Try to modify some images (e.g., rotate, flip, darken) and see if the model can detect the anomalies (i.e., compare the output of the `score_samples()` method for normal images and for anomalies).*","af6920e7":"If the dataset does not fit in memory, the simplest option is to use the `memma. First let's load MNIST:","572b459c":"## Model selection","2e319cca":"### Agglomerative Clustering","2c97a021":"As you can see, we end up with the initial model, which is certainly the optimal K-Means solution (at least in terms of inertia, and assuming $k=5$).","a6e2a50c":"That's *much* faster! However, its performance is often lower (higher inertia), and it keeps degrading as _k_ increases. Let's plot the inertia ratio and the training time ratio between Mini-batch K-Means and regular K-Means:","ab53a3c7":"To use Elkan's variant of K-Means, just set `algorithm=\"elkan\"`. Note that it does not support sparse data, so by default, Scikit-Learn uses `\"elkan\"` for dense data, and `\"full\"` (the regular K-Means algorithm) for sparse data.","78488950":"You can verify that this is indeed the Euclidian distance between each instance and each centroid:","9d54d8da":"There's one weight per cluster, but the sum must be equal to 1, so we have one degree of freedom less, hence the -1. Similarly, the degrees of freedom for an $n \\times n$ covariance matrix is not $n^2$, but $1 + 2 + \\dots + n = \\dfrac{n (n+1)}{2}$.","ca1105fd":"### Spectral Clustering","b80a0fa5":"You could now do a few iterations of *active learning*:\n1. Manually label the instances that the classifier is least sure about, if possible by picking them in distinct clusters.\n2. Train a new model with these additional labels.","baaf2687":"### Using clustering for image segmentation","2e584d4b":"## Other Clustering Algorithms","66d80d61":"When you set the `n_init` hyperparameter, Scikit-Learn runs the original algorithm `n_init` times, and selects the solution that minimizes the inertia. By default, Scikit-Learn sets `n_init=10`.","8360b823":"### K-Means Variability","5fbd1d5e":"*Exercise: What if you append the features from the reduced set to the original features (again, searching for the best number of clusters)?*","583ee4f7":"## Variational Bayesian Gaussian Mixtures","34de3f40":"What if the number of clusters was set to a lower or greater value than 5?","be9d4195":"The bad faces are all considered highly unlikely by the Gaussian Mixture model. Compare this to the scores of some training instances:","2bd5a056":"Let's train Gaussian Mixture models with various values of $k$ and measure their BIC:","18a96621":"### Hard Clustering _vs_ Soft Clustering","690c3ede":"Another use case for clustering is in semi-supervised learning, when we have plenty of unlabeled instances and very few labeled instances.","5143bb88":"We cannot use the inertia or the silhouette score because they both assume that the clusters are spherical. Instead, we can try to find the model that minimizes a theoretical information criterion such as the Bayesian Information Criterion (BIC) or the Akaike Information Criterion (AIC):\n\n${BIC} = {\\log(m)p - 2\\log({\\hat L})}$\n\n${AIC} = 2p - 2\\log(\\hat L)$\n\n* $m$ is the number of instances.\n* $p$ is the number of parameters learned by the model.\n* $\\hat L$ is the maximized value of the likelihood function of the model. This is the conditional probability of the observed data $\\mathbf{X}$, given the model and its optimized parameters.\n\nBoth BIC and AIC penalize models that have more parameters to learn (e.g., more clusters), and reward models that fit the data well (i.e., models that give a high likelihood to the observed data).","d18a7657":"We already reduced the dataset using PCA earlier:"}}