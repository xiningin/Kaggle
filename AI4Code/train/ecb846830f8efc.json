{"cell_type":{"6bfc839d":"code","b051e9a7":"code","4146d24f":"code","3500e3f4":"code","196ae797":"code","de9c53e8":"code","d67213f6":"code","f2e18cfb":"code","61d71db8":"code","a719d696":"code","8668e775":"code","293efaa6":"code","ecd49564":"code","899621ea":"code","4543cecd":"code","fab1738f":"code","67d094b1":"code","630cc03d":"code","d0bfdf79":"code","ca9adafe":"code","627eb9c0":"code","2b1bb337":"code","f603965a":"code","dfd88742":"code","0e2e97b5":"code","19931b2c":"code","32d3fd60":"code","e77c4d42":"code","33d4bd32":"code","0e2d7e79":"code","d1544cf8":"code","fe8231d1":"markdown","6519baa2":"markdown","65d272ba":"markdown","d755937d":"markdown","25b11b18":"markdown","ee5663b5":"markdown","b445dcc9":"markdown","ce2ccc03":"markdown","343778c0":"markdown","53747567":"markdown"},"source":{"6bfc839d":"import pyarrow.parquet as pq\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# ML\nfrom sklearn.metrics import r2_score","b051e9a7":"train = pd.read_csv('..\/input\/optiver-realized-volatility-prediction\/train.csv')  \ntrain.head(2)","4146d24f":"PATH_T = '..\/input\/optiver-realized-volatility-prediction\/trade_train.parquet\/'\nPATH_B = '..\/input\/optiver-realized-volatility-prediction\/book_train.parquet\/'","3500e3f4":"filter = [('stock_id', '>', '95')]","196ae797":"%%time\ndataset = pq.ParquetDataset(PATH_T, filters = filter)  \ntable = dataset.read()\ntrades = table.to_pandas()\ntrades['stock_id'] = trades['stock_id'].astype(np.int8)\ntrades.info()","de9c53e8":"%%time\ndataset = pq.ParquetDataset(PATH_B, filters = filter) \nbooks = dataset.read()\nbooks = books.to_pandas()  # I overwrite the pyarrow table object here to save memory\nbooks['stock_id'] = books['stock_id'].astype(np.int8)\nbooks.info()","d67213f6":"print(f'Found {books.time_id.nunique()} unique time ids in tardes\/books.')\nprint(f'Found {books.stock_id.nunique()} unique stock ids in tardes\/books.')","f2e18cfb":"def append_wap1(df):\n    df['wap1'] = (df['bid_price1'] * df['ask_size1'] + df['ask_price1'] * df['bid_size1']) \/ (df['bid_size1']+ df['ask_size1'])\n    return df","61d71db8":"def append_wap2(df):\n    df['wap2'] = (df['bid_price2'] * df['ask_size2'] + df['ask_price2'] * df['bid_size2']) \/ (df['bid_size2']+ df['ask_size2'])\n    return df","a719d696":"books = append_wap1(books)\nbooks = append_wap2(books)","8668e775":"def plot_wap(books_df, time_id, stock_id_arr):\n    \n    fig, ax = plt.subplots(len(stock_id_arr), 1, figsize=(18 , 16))\n    fig.tight_layout(pad=2.0)\n    i= 0\n    \n    for stock_id in stock_id_arr:\n        mask = np.logical_and(books_df[\"stock_id\"]==stock_id, books_df[\"time_id\"]==time_id)\n        ax2 = ax[i].twinx()\n        \n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"wap1\"], ax=ax[i], color='blue')\n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"ask_price1\"], ax=ax[i], color='red')\n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"bid_price1\"], ax=ax[i], color='green')\n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"bid_size1\"] + books_df[mask][\"ask_size1\"], ax=ax2, color='orange')\n        #sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"log_return\"], ax=ax2, color='orange')\n        \n        ax[i].set_title(f'Stock_id: {stock_id}', loc='left', fontweight='bold')     \n        ax[i].legend(['wap', 'ask_price1', 'bid_price1'], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\n        ax2.legend([\"bid_size1 + ask_size1\"], bbox_to_anchor=(1.05, 0.78), loc=2, borderaxespad=0.)\n        i+=1\n    plt.show()","293efaa6":"stock_id_arr = books[\"stock_id\"].unique()\nplot_wap(books, 5, stock_id_arr)","ecd49564":"def wap_balance(books_df):\n    books_df['wap_balance'] = abs(books_df['wap1'] - books_df['wap2'])\n    return books_df","899621ea":"books = wap_balance(books)","4543cecd":"def plot_wap_balance(books_df, time_id, stock_id_arr):\n    \n    fig, ax = plt.subplots(len(stock_id_arr), 1, figsize=(18 , 16))\n    fig.tight_layout(pad=2.0)\n    i= 0\n    \n    for stock_id in stock_id_arr:\n        mask = np.logical_and(books_df[\"stock_id\"]==stock_id, books_df[\"time_id\"]==time_id)\n        ax2 = ax[i].twinx()\n        \n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"wap1\"], ax=ax[i], color='blue')\n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"wap2\"], ax=ax[i], color='green')\n        \n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"wap_balance\"], ax=ax2, color='orange')\n        \n        ax[i].set_title(f'Stock_id: {stock_id}', loc='left', fontweight='bold')     \n        ax[i].legend(['wap1', 'wap2'], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\n        ax2.legend([\"wap_balance\"], bbox_to_anchor=(1.05, 0.78), loc=2, borderaxespad=0.)\n        i+=1\n    plt.show()","fab1738f":"stock_id_arr = books[\"stock_id\"].unique()\nplot_wap_balance(books, 5, stock_id_arr)","67d094b1":"def log_return(list_stock_prices):\n    return np.log(list_stock_prices).diff()","630cc03d":"# books.loc[:,'log_return'] = log_return(books['wap'])\n# books = books[~books['log_return'].isnull()]\n# # apply log_return function and use data to create new row\nbooks.loc[:,'log_return1'] = books.groupby(['stock_id','time_id'])['wap1'].apply(log_return)\nbooks = books[~books['log_return1'].isnull()]\nbooks.loc[:,'log_return2'] = books.groupby(['stock_id','time_id'])['wap2'].apply(log_return)\nbooks = books[~books['log_return2'].isnull()]","d0bfdf79":"def wap_vs_logretrun(books_df, time_id, stock_id_arr):\n    \n    fig, ax = plt.subplots(len(stock_id_arr), 1, figsize=(18 , 16))\n    fig.tight_layout(pad=2.0)\n    i= 0\n    \n    for stock_id in stock_id_arr:\n        mask = np.logical_and(books_df[\"stock_id\"]==stock_id, books_df[\"time_id\"]==time_id)\n        ax2 = ax[i].twinx()\n        \n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"wap1\"], ax=ax[i], color='blue')\n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"log_return1\"], ax=ax2, color='orange')\n        \n#         sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"wap2\"], ax=ax[i], color='green')\n#         sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"log_return2\"], ax=ax2, color='purple')\n        \n        \n        ax[i].set_title(f'Stock_id: {stock_id}', loc='left', fontweight='bold')     \n        ax[i].legend(['wap1'], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\n        ax2.legend([\"log_return1\"], bbox_to_anchor=(1.05, 0.9), loc=2, borderaxespad=0.)\n        i+=1\n    plt.show()","ca9adafe":"stock_id_arr = books[\"stock_id\"].unique()\nwap_vs_logretrun(books, 5, stock_id_arr)","627eb9c0":"def realized_volatility(books_df, time_id, stock_id_arr):\n    for stock_id in stock_id_arr:\n        mask = np.logical_and(books_df[\"stock_id\"]==stock_id, books_df[\"time_id\"]==time_id)\n        \n        realized_vol1 = np.sqrt(np.sum(books_df[mask]['log_return1']**2))\n        realized_vol2 = np.sqrt(np.sum(books_df[mask]['log_return2']**2))\n        \n        print(f'Realized volatility1 for stock_id {stock_id} on time_id {time_id} is {realized_vol1}')\n        print(f'Realized volatility2 for stock_id {stock_id} on time_id {time_id} is {realized_vol2}')","2b1bb337":"stock_id_arr = books[\"stock_id\"].unique()\nrealized_volatility(books, 5, stock_id_arr)","f603965a":"def log_return_hist(books_df, time_id, stock_id_arr):\n    fig, ax = plt.subplots(len(stock_id_arr), 1, figsize=(8 , 20))\n    fig.tight_layout(pad=4.0)\n    \n    i= 0\n    for stock_id in stock_id_arr:\n        mask = np.logical_and(books_df[\"stock_id\"]==stock_id, books_df[\"time_id\"]==time_id)\n        realized_vol1 = np.sqrt(np.sum(books_df[mask]['log_return1']**2))\n        \n        sns.histplot(data=books[mask][\"log_return1\"], ax= ax[i])\n        _std = np.std(books[mask][\"log_return1\"])\n        ax[i].set_title(f'Realized volatility1 for stock_id {stock_id} on time_id {time_id} is {round(realized_vol1, 5)}, teh std is: {round(_std, 5)}',\n                        loc='left', fontweight='bold')     \n        i+=1\n    \n    plt.show()","dfd88742":"stock_id_arr = books[\"stock_id\"].unique()\nlog_return_hist(books, 5, stock_id_arr)","0e2e97b5":"trades.loc[:,'log_return'] = trades.groupby(['stock_id','time_id'])['price'].apply(log_return)\ntrades = trades[~trades['log_return'].isnull()]","19931b2c":"trades.loc[:,'amount'] = trades['price']*trades['size']","32d3fd60":"trades","e77c4d42":"def amount_vs_logretrun(books_df, time_id, stock_id_arr):\n    \n    fig, ax = plt.subplots(len(stock_id_arr), 1, figsize=(18 , 16))\n    fig.tight_layout(pad=2.0)\n    i= 0\n    \n    for stock_id in stock_id_arr:\n        mask = np.logical_and(books_df[\"stock_id\"]==stock_id, books_df[\"time_id\"]==time_id)\n        ax2 = ax[i].twinx()\n        \n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"amount\"], ax=ax[i], color='blue')\n        sns.lineplot(x=books_df[mask][\"seconds_in_bucket\"], y=books_df[mask][\"log_return\"], ax=ax2, color='orange')\n        \n        ax[i].set_title(f'Stock_id: {stock_id}', loc='left', fontweight='bold')     \n        ax[i].legend(['amount'], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\n        ax2.legend([\"log_return1\"], bbox_to_anchor=(1.05, 0.9), loc=2, borderaxespad=0.)\n        i+=1\n    plt.show()","33d4bd32":"trades_id_arr = trades[\"stock_id\"].unique()\namount_vs_logretrun(trades, 5, stock_id_arr)","0e2d7e79":"def tendency(price, vol):    \n    df_diff = np.diff(price)\n    val = (df_diff\/price[1:])*100\n    power = np.sum(val*vol[1:])\n    return(power)","d1544cf8":"mask = np.logical_and(trades[\"stock_id\"]==98, trades[\"time_id\"]==5)\ntendency(trades[mask][\"price\"].values, trades[mask]['size'].values)","fe8231d1":"### WAP (Weighted average price)","6519baa2":"### Logarithm retrun","65d272ba":"# Realized volatility for stocks in features bucket\nWhen we trade options, a valuable input to our models is the standard deviation of the stock log returns. The standard deviation will be different for log returns computed over longer or shorter intervals, for this reason it is usually normalized to a 1-year period and the annualized standard deviation is called **volatility**. \n\nIn this competition, you will be given 10 minutes of book data and we ask you to predict what the volatility will be in the following 10 minutes. Volatility will be measured as follows:\n\nWe will compute the log returns over all consecutive book updates and we define the **realized volatility, $\\sigma$,** as the squared root of the sum of squared log returns.\n$$\n\\sigma = \\sqrt{\\sum_{t}r_{t-1, t}^2}\n$$\nWhere we use **WAP** as price of the stock to compute log returns.\n\nWe are not annualizing the volatility and we are assuming that log returns have 0 mean.\n\nIn this competition, our target is to predict short-term realized volatility. Although the order book and trade data for the target cannot be shared, we can still present the realized volatility calculation using the feature data we provided. \n\nAs realized volatility is a statistical measure of price changes on a given stock, to calculate the price change we first need to have a stock valuation at the fixed interval (1 second). We will use weighted averaged price, or WAP, of the order book data we provided.","d755937d":"Returns are widely used in finance, however **log returns** are preferred whenever some mathematical modelling is required. Calling $S_t$ the price of the stock $S$ at time $t$, we can define the log return between $t_1$ and $t_2$ as:\n$$\nr_{t_1, t_2} = \\log \\left( \\frac{S_{t_2}}{S_{t_1}} \\right)\n$$\nUsually, we look at log returns over fixed time intervals, so with 10-minute log return we mean $r_t = r_{t - 10 min, t}$.\n\nLog returns present several advantages, for example:\n* Normalize data to have a better visualization and are are preferred whenever some mathematical modelling is required\n\nTo compute the log return, we can simply take **the logarithm of the ratio** between two consecutive **WAP**. The first row will have an empty return as the previous book update is unknown, **therefore the empty return data point will be dropped. We have data from \"seconds_in_bucket == 1\" to higher.**","25b11b18":"# Load some data","ee5663b5":"1. **If the Standard deviation is lower, the realized volatility is lower.**\n2. **If the Standard deviation is higher, the realized voaltility is higher.**","b445dcc9":"# Static functions","ce2ccc03":"# Trades","343778c0":"The formula of WAP can be written as below, which takes the top level price and volume information into account:\n\n$$ WAP = \\frac{BidPrice_{1}*AskSize_{1} + AskPrice_{1}*BidSize_{1}}{BidSize_{1} + AskSize_{1}} $$\n\nAs you can see, if two books have both bid and ask offers on the same price level respectively, the one with more offers in place will generate a lower stock valuation, as there are more intended seller in the book, and more seller implies a fact of more supply on the market resulting in a lower stock valuation.","53747567":"## Wap Balance"}}