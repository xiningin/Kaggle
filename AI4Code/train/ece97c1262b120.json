{"cell_type":{"278b860e":"code","989139b4":"code","f5ca196e":"code","a9243adb":"code","6d0fa41e":"code","b4d2f39a":"code","609a4100":"code","aa10fa89":"code","2d21de15":"code","69599ff8":"code","90b66ba9":"code","80ee55ae":"code","b4139269":"code","0e90817f":"code","f8d8cc31":"code","4051a91b":"code","d3d430f6":"code","e4bd4292":"code","824a2eed":"code","41125e8a":"code","a6e467d8":"code","f98bb652":"code","c1c7b5c1":"code","cfcb344c":"code","486732d2":"code","48647de6":"code","17325f60":"code","851d12e9":"code","aaf6a999":"code","9e574701":"code","444e8eed":"code","20a8e9e3":"code","3335fd68":"code","b6995235":"code","69fa4ea3":"code","403a2a77":"code","c2d1080e":"code","4b7012aa":"code","a12ed8ee":"code","cfcdfb72":"code","0846f826":"code","a8b8523d":"code","7a05a0f2":"code","444206d7":"code","58947789":"code","8e9b5cc6":"code","3a92755a":"code","5c2c0ede":"code","eccb1ffc":"code","b1936ddb":"code","9579df9d":"code","842d3d48":"code","a80c2c21":"code","289993bc":"code","9217da51":"code","b688af05":"code","60183125":"code","82f4c534":"code","4aa5e50f":"code","14f4514e":"code","00abdc13":"code","0a360d5b":"markdown","c9720581":"markdown","0cd5d40f":"markdown","ab6c9802":"markdown","9f4d8778":"markdown","6e679321":"markdown","714e4dd2":"markdown","88239f8f":"markdown","db16145f":"markdown","661c24a8":"markdown","6b605ede":"markdown","85aff5d2":"markdown","07353052":"markdown","39d223e8":"markdown","b09660df":"markdown","20efc464":"markdown","f2faecf7":"markdown","c0f5e8dc":"markdown","3fa3a4c0":"markdown","097a8492":"markdown","c5b5bcf4":"markdown","a2daa749":"markdown","9013fb25":"markdown","9a9a1909":"markdown","ae6ca3a3":"markdown","9f611b92":"markdown","582921f3":"markdown","9572a954":"markdown","720af795":"markdown","58d9a7ac":"markdown","1b90ae6e":"markdown","b434f0f6":"markdown","41843a68":"markdown","201148b8":"markdown","254db51c":"markdown","4ab762b7":"markdown","3621c697":"markdown","1221eeaf":"markdown","94524733":"markdown"},"source":{"278b860e":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport os\nfrom datetime import tzinfo, timedelta, datetime\nfrom dateutil import relativedelta\nimport math","989139b4":"dfBitstamp = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2019-08-12.csv', delimiter=',')\n#dfBitstamp = pd.read_csv('..\/input\/bitcoin-historical-data\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv')\ndfBitstamp.dataframeName = 'Bitstamp_USD-BTC_1-min_data'\nnRow, nCol = dfBitstamp.shape\nprint(f'{nRow} linhas por {nCol} colunas')","f5ca196e":"dfBitstamp.rename(index=str, columns={\n    'Timestamp':'DataHora',\n    'Open':'Valor_Abertura',\n    'High':'Valor_Maxima',\n    'Low':'Valor_Minima',\n    'Close':'Valor_Fechamento',\n    'Volume_(BTC)':'BTC_Negociado',\n    'Volume_(Currency)':'USD_Negociado',\n    'Weighted_Price':'Preco_Medio_BTC'\n}, inplace=True);","a9243adb":"dfBitstamp.head(15)","6d0fa41e":"dfBitstamp.info()","b4d2f39a":"dfBitstamp.DataHora = pd.to_datetime(dfBitstamp.DataHora, unit='s')","609a4100":"dfBitstamp.head(15)","aa10fa89":"intervaloData = relativedelta.relativedelta(dfBitstamp.DataHora.max(), dfBitstamp.DataHora.min())\nprint(f'Dataset engloba dados de {intervaloData.years} anos, {intervaloData.months} meses e {intervaloData.days} dias')","2d21de15":"dfBitstampPorAno = dfBitstamp.groupby(dfBitstamp.DataHora.dt.year).mean()\ndfBitstampPorPeriodo = dfBitstamp.groupby([dfBitstamp.DataHora.dt.year, dfBitstamp.DataHora.dt.month]).mean()\ndfBitstampPorMes = dfBitstamp.groupby(dfBitstamp.DataHora.dt.month).mean()\ndfBitstampPorDia = dfBitstamp.groupby(dfBitstamp.DataHora.dt.date).mean()\ndfBitstampPorSemanaAno = dfBitstamp.groupby(dfBitstamp.DataHora.dt.weekofyear).mean()\ndfBitstampPorDiaSemana = dfBitstamp.groupby(dfBitstamp.DataHora.dt.weekday).mean()\ndfBitstampPorAno.index.names = dfBitstampPorMes.index.names = dfBitstampPorSemanaAno.index.names = dfBitstampPorDiaSemana.index.names = ['Periodo']","69599ff8":"dfTransacoesValidas = dfBitstamp[dfBitstamp.BTC_Negociado.notna()].DataHora\ndfBitstampPorAno['Transacoes_Periodo'] = dfTransacoesValidas.groupby(dfBitstamp.DataHora.dt.year).count()\ndfBitstampPorPeriodo['Transacoes_Periodo'] = dfTransacoesValidas.groupby([dfBitstamp.DataHora.dt.year, dfBitstamp.DataHora.dt.month]).count()\ndfBitstampPorMes['Transacoes_Periodo'] = dfTransacoesValidas.groupby(dfBitstamp.DataHora.dt.month).count()\ndfBitstampPorSemanaAno['Transacoes_Periodo'] = dfTransacoesValidas.groupby(dfBitstamp.DataHora.dt.weekofyear).count()\ndfBitstampPorDiaSemana['Transacoes_Periodo'] = dfTransacoesValidas.groupby(dfBitstamp.DataHora.dt.weekday).count()","90b66ba9":"traceBTC = go.Bar(\n                x = dfBitstampPorAno.index,\n                y = np.round(dfBitstampPorAno.BTC_Negociado, 9),\n                name = 'BTC\/transa\u00e7\u00e3o',\n                marker = dict(color = 'rgba(84, 92, 229, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                text = dfBitstampPorAno.index)\n\ntraceActiveMinutes = go.Scatter(\n                x = dfBitstampPorAno.index,\n                y = dfBitstampPorAno.Transacoes_Periodo,\n                text = dfBitstampPorAno.index,\n                name = 'Transa\u00e7\u00f5es ',\n                marker = dict(color = 'rgba(168, 69, 227, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                yaxis='y2')\n\nlayout = go.Layout(\n    title='Anual - Volume negociado x Quantidade de transa\u00e7\u00f5es',\n    xaxis=dict(\n        title='Per\u00edodo',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='Volume negociado (em BTC)',\n        ticksuffix = ' BTC',\n        hoverformat = ',9f',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis2=dict(\n        title='Transa\u00e7\u00f5es por per\u00edodo',\n        ticksuffix = ' transa\u00e7\u00f5es\/periodo',\n        hoverformat = ',2f',\n        titlefont=dict(\n            size=16\n        ),\n        overlaying = 'y',\n        side = 'right',\n        rangemode = 'tozero'\n    )\n)\n\npy.iplot(go.Figure(data = [traceBTC, traceActiveMinutes], layout=layout))","80ee55ae":"traceBTC = go.Bar(\n                x = dfBitstampPorMes.index,\n                y = np.round(dfBitstampPorMes.BTC_Negociado, 9),\n                name = 'BTC\/transa\u00e7\u00e3o',\n                marker = dict(color = 'rgba(84, 92, 229, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                text = ['Janeiro','Fevereiro','Mar\u00e7o','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'])\n\ntraceActiveMinutes = go.Scatter(\n                x = dfBitstampPorMes.index,\n                y = dfBitstampPorMes.Transacoes_Periodo,\n                text = ['Janeiro','Fevereiro','Mar\u00e7o','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],\n                name = 'Transa\u00e7\u00f5es ',\n                marker = dict(color = 'rgba(168, 69, 227, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                yaxis='y2')\n\nlayout = go.Layout(\n    title='Mensal - Volume negociado x Quantidade de transa\u00e7\u00f5es',\n    xaxis=dict(\n        title='Per\u00edodo',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='Volume negociado (em BTC)',\n        ticksuffix = ' BTC',\n        hoverformat = ',9f',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis2=dict(\n        title='Transa\u00e7\u00f5es por per\u00edodo',\n        ticksuffix = ' transa\u00e7\u00f5es\/periodo',\n        hoverformat = ',2f',\n        titlefont=dict(\n            size=16\n        ),\n        overlaying = 'y',\n        side = 'right',\n        rangemode = 'tozero'\n    )\n)\n\npy.iplot(go.Figure(data = [traceBTC, traceActiveMinutes], layout=layout))","b4139269":"traceBTC = go.Bar(\n                x = dfBitstampPorSemanaAno.index,\n                y = np.round(dfBitstampPorSemanaAno.BTC_Negociado, 9),\n                name = 'BTC\/transa\u00e7\u00e3o',\n                marker = dict(color = 'rgba(84, 92, 229, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                text = dfBitstampPorSemanaAno.index)\n\ntraceActiveMinutes = go.Scatter(\n                x = dfBitstampPorSemanaAno.index,\n                y = dfBitstampPorSemanaAno.Transacoes_Periodo,\n                text = dfBitstampPorSemanaAno.index,\n                name = 'Transa\u00e7\u00f5es ',\n                marker = dict(color = 'rgba(168, 69, 227, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                yaxis='y2')\n\nlayout = go.Layout(\n    title='Semanal - Volume negociado x Quantidade de transa\u00e7\u00f5es',\n    xaxis=dict(\n        title='Per\u00edodo',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='Volume negociado (em BTC)',\n        ticksuffix = ' BTC',\n        hoverformat = ',9f',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis2=dict(\n        title='Transa\u00e7\u00f5es por per\u00edodo',\n        ticksuffix = ' transa\u00e7\u00f5es\/periodo',\n        hoverformat = ',2f',\n        titlefont=dict(\n            size=16\n        ),\n        overlaying = 'y',\n        side = 'right',\n        rangemode = 'tozero'\n    )\n)\n\npy.iplot(go.Figure(data = [traceBTC, traceActiveMinutes], layout=layout))","0e90817f":"traceBTC = go.Bar(\n                x = dfBitstampPorDiaSemana.index,\n                y = np.round(dfBitstampPorDiaSemana.BTC_Negociado, 9),\n                name = 'BTC\/transa\u00e7\u00e3o',\n                marker = dict(color = 'rgba(84, 92, 229, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                text = ['Domingo','Segunda','Ter\u00e7a','Quarta','Quinta','Sexta','S\u00e1bado'])\n\ntraceActiveMinutes = go.Scatter(\n                x = dfBitstampPorDiaSemana.index,\n                y = dfBitstampPorDiaSemana.Transacoes_Periodo,\n                text = ['Domingo','Segunda','Ter\u00e7a','Quarta','Quinta','Sexta','S\u00e1bado'],\n                name = 'Transa\u00e7\u00f5es ',\n                marker = dict(color = 'rgba(168, 69, 227, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                yaxis='y2')\n\nlayout = go.Layout(\n    title='Diario - Volume negociado x Quantidade de transa\u00e7\u00f5es',\n    xaxis=dict(\n        title='Per\u00edodo',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='Volume negociado (em BTC)',\n        ticksuffix = ' BTC',\n        hoverformat = ',9f',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis2=dict(\n        title='Transa\u00e7\u00f5es por per\u00edodo',\n        ticksuffix = ' transa\u00e7\u00f5es\/periodo',\n        hoverformat = ',2f',\n        titlefont=dict(\n            size=16\n        ),\n        overlaying = 'y',\n        side = 'right',\n        rangemode = 'tozero'\n    )\n)\n\npy.iplot(go.Figure(data = [traceBTC, traceActiveMinutes], layout=layout))","f8d8cc31":"dfBitstampPorPeriodo.index.names = ['Ano','Mes']\ndfBitstampPorPeriodo.index = [dfBitstampPorPeriodo.index.get_level_values(0), dfBitstampPorPeriodo.index.map('{0[1]}\/{0[0]}'.format)]\ndfBitstampPorPeriodo.index.names = ['Ano','Periodo']","4051a91b":"tracePorcentagem = go.Scatter(\n                name = 'Volume\/per\u00edodo',\n                x = dfBitstampPorPeriodo.index.get_level_values(1),\n                y = np.round(dfBitstampPorPeriodo.BTC_Negociado, 9),\n                marker = dict(color = 'rgba(84, 92, 229, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                text = dfBitstampPorPeriodo.index.get_level_values(1))\n\ntraceUSD = go.Scatter(\n                name = 'Valor m\u00e9dio',\n                x = dfBitstampPorPeriodo.index.get_level_values(1),\n                y = np.round(dfBitstampPorPeriodo.Preco_Medio_BTC, 2),\n                marker = dict(color = 'rgba(229, 84, 165, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)),\n                text = dfBitstampPorPeriodo.index.get_level_values(1),\n                yaxis='y2')\n\nlayout = go.Layout(\n    title='Volume negociado (em BTC) x Valor m\u00e9dio (em USD), por per\u00edodo',\n    xaxis=dict(\n        title='Per\u00edodo (M\u00eas\/Ano)',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='Volume negociado no per\u00edodo (em BTC)',\n        ticksuffix = ' BTC',\n        hoverformat = ',2f',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis2=dict(\n        title='Valor m\u00e9dio por BTC (em USD)',\n        tickprefix = 'USD ',\n        hoverformat = ',2f',\n        titlefont=dict(\n            size=16\n        ),\n        overlaying = 'y',\n        side = 'right'\n    )\n)\n\npy.iplot(go.Figure(data = [tracePorcentagem, traceUSD], layout=layout))","d3d430f6":"df2018 = dfBitstamp[dfBitstamp.DataHora.dt.year >= 2018]\ndfBitstampAtualDiario = df2018.groupby(by=dfBitstamp.DataHora.dt.date).mean()","e4bd4292":"trace = go.Scatter(\n                x = dfBitstampAtualDiario.index,\n                y = np.round(dfBitstampAtualDiario.Preco_Medio_BTC, 2),\n                marker = dict(color = 'rgba(84, 92, 229, 0.9)', line=dict(color='rgb(0,0,0)',width=1.5)))\nlayout = go.Layout(\n    title='Valor do BTC por Per\u00edodo (M\u00eas\/Ano) a partir de 2018',\n    xaxis=dict(\n        title='Per\u00edodo',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='Valor de 1 BTC (em USD)',\n        tickprefix = 'USD ',\n        hoverformat = ',2f',\n        titlefont=dict(\n            size=16\n        )\n    )\n)\n\npy.iplot(go.Figure(data = [trace], layout=layout))","824a2eed":"dfBitstampAtualSemanal = df2018.groupby(by=dfBitstamp.DataHora.dt.weekofyear).mean()\ndfBitstampAtualMensal = df2018.groupby(by=dfBitstamp.DataHora.dt.month).mean()","41125e8a":"dfBitstampAtualDiario['Variacao_Percentual'] = ((dfBitstampAtualDiario.Preco_Medio_BTC - dfBitstampAtualDiario.Preco_Medio_BTC.shift()) \/ dfBitstampAtualDiario.Preco_Medio_BTC) * 100\ndfBitstampAtualDiario.Variacao_Percentual.fillna(0, inplace=True)\ndfBitstampAtualDiario.index = pd.to_datetime(dfBitstampAtualDiario.index)\ndfBitstampAtualDiario['Acumulado_Variacao'] = dfBitstampAtualDiario.Variacao_Percentual.cumsum()\ndfBitstampAtualDiario['Volatilidade'] = np.std(dfBitstampAtualDiario.Variacao_Percentual)","a6e467d8":"dfBitstampAtualSemanal['Variacao_Percentual'] = ((dfBitstampAtualSemanal.Preco_Medio_BTC - dfBitstampAtualSemanal.Preco_Medio_BTC.shift()) \/ dfBitstampAtualSemanal.Preco_Medio_BTC) * 100\ndfBitstampAtualSemanal.Variacao_Percentual.fillna(0, inplace=True)\ndfBitstampAtualSemanal['Acumulado_Variacao'] = dfBitstampAtualSemanal.Variacao_Percentual.cumsum()\ndfBitstampAtualSemanal['Volatilidade'] = np.std(dfBitstampAtualSemanal.Variacao_Percentual)","f98bb652":"dfBitstampAtualMensal['Variacao_Percentual'] = ((dfBitstampAtualMensal.Preco_Medio_BTC - dfBitstampAtualMensal.Preco_Medio_BTC.shift()) \/ dfBitstampAtualMensal.Preco_Medio_BTC) * 100\ndfBitstampAtualMensal.Variacao_Percentual.fillna(0, inplace=True)\ndfBitstampAtualMensal['Acumulado_Variacao'] = dfBitstampAtualMensal.Variacao_Percentual.cumsum()\ndfBitstampAtualMensal['Volatilidade'] = np.std(dfBitstampAtualMensal.Variacao_Percentual)","c1c7b5c1":"tracePorcentagem = go.Scatter(\n                name = 'Rentabilidade Diaria',\n                x = dfBitstampAtualDiario.index,\n                y = dfBitstampAtualDiario.Variacao_Percentual,\n                line = dict(\n                    color = 'rgba(84, 92, 229, 0.9)',\n                    width = 1.5\n                ),\n                text = dfBitstampPorPeriodo.index)\n\ntraceVolatilidadeMaxima = go.Scatter(\n                name = 'Volatilidade - Limite Superior',\n                x = dfBitstampAtualDiario.index,\n                y = dfBitstampAtualDiario.Volatilidade,\n                line = dict(\n                    color = 'rgba(229, 84, 165, 0.9)',\n                    width = 4,\n                    dash = 'dash'\n                ),\n                text = dfBitstampPorPeriodo.index\n)\n\ntraceVolatilidadeMinima = go.Scatter(\n                name = 'Volatilidade - Limite Inferior',\n                x = dfBitstampAtualDiario.index,\n                y = - dfBitstampAtualDiario.Volatilidade,\n                line = dict(\n                    color = 'rgba(229, 220, 84, 0.9)',\n                    width = 4,\n                    dash = 'dash'\n                ),\n                text = dfBitstampPorPeriodo.index\n)\n\nlayout = go.Layout(\n    title='Volatilidade x Rentabilidade Diaria, com limites superiores e inferiores',\n    xaxis=dict(\n        title='Dia',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='%',\n        ticksuffix = ' %',\n        titlefont=dict(\n            size=16\n        )\n    )\n)\n\npy.iplot(go.Figure(data = [tracePorcentagem, traceVolatilidadeMaxima, traceVolatilidadeMinima], layout=layout))","cfcb344c":"tracePorcentagem = go.Scatter(\n                name = 'Rentabilidade Semanal',\n                x = dfBitstampAtualSemanal.index,\n                y = dfBitstampAtualSemanal.Variacao_Percentual,\n                line = dict(\n                    color = 'rgba(84, 92, 229, 0.9)',\n                    width = 1.5\n                ),\n                text = dfBitstampAtualSemanal.index)\n\ntraceVolatilidadeMaxima = go.Scatter(\n                name = 'Volatilidade - Limite Superior',\n                x = dfBitstampAtualSemanal.index,\n                y = dfBitstampAtualSemanal.Volatilidade,\n                line = dict(\n                    color = 'rgba(229, 84, 165, 0.9)', \n                    width = 4,\n                    dash = 'dash'\n                ),\n                text = dfBitstampAtualSemanal.index\n)\n\ntraceVolatilidadeMinima = go.Scatter(\n                name = 'Volatilidade - Limite Inferior',\n                x = dfBitstampAtualSemanal.index,\n                y = - dfBitstampAtualSemanal.Volatilidade,\n                line = dict(\n                    color = 'rgba(229, 220, 84, 0.9)',\n                    width = 4,\n                    dash = 'dash'\n                ),\n                text = dfBitstampAtualSemanal.index\n)\n\nlayout = go.Layout(\n    title='Volatilidade x Rentabilidade Semanal, com limites superiores e inferiores',\n    xaxis=dict(\n        title='Semana do ano (1 - 54)',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='%',\n        ticksuffix = ' %',\n        titlefont=dict(\n            size=16\n        )\n    )\n)\n\npy.iplot(go.Figure(data = [tracePorcentagem, traceVolatilidadeMaxima, traceVolatilidadeMinima], layout=layout))","486732d2":"tracePorcentagem = go.Scatter(\n                name = 'Rentabilidade Mensal',\n                x = dfBitstampAtualMensal.index,\n                y = dfBitstampAtualMensal.Variacao_Percentual,\n                line = dict(\n                    color = 'rgba(84, 92, 229, 0.9)',\n                    width = 1.5\n                ),\n                text = dfBitstampAtualMensal.index)\n\ntraceVolatilidadeMaxima = go.Scatter(\n                name = 'Volatilidade - Limite Superior',\n                x = dfBitstampAtualMensal.index,\n                y = dfBitstampAtualMensal.Volatilidade,\n                line = dict(\n                    color = 'rgba(229, 84, 165, 0.9)',\n                    width = 4,\n                    dash = 'dash'\n                ),\n                text = dfBitstampAtualMensal.index\n)\n\ntraceVolatilidadeMinima = go.Scatter(\n                name = 'Volatilidade - Limite Inferior',\n                x = dfBitstampAtualMensal.index,\n                y = - dfBitstampAtualMensal.Volatilidade,\n                line = dict(\n                    color = 'rgba(229, 220, 84, 0.9)',\n                    width = 4,\n                    dash = 'dash'\n                ),\n                text = dfBitstampAtualMensal.index\n)\n\nlayout = go.Layout(\n    title='Volatilidade x Rentabilidade Mensal, com limites superiores e inferiores',\n    xaxis=dict(\n        title='M\u00eas (1 - 12)',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='%',\n        ticksuffix = ' %',\n        titlefont=dict(\n            size=16\n        )\n    )\n)\n\npy.iplot(go.Figure(data = [tracePorcentagem, traceVolatilidadeMaxima, traceVolatilidadeMinima], layout=layout))","48647de6":"dfBitstampAtualDiario['Ganho_Day_Trade'] = dfBitstampAtualDiario.Valor_Maxima - dfBitstampAtualDiario.Valor_Minima\ndfBitstampAtualDiario['Percentual_Day_Trade'] = ((dfBitstampAtualDiario.Valor_Maxima - dfBitstampAtualDiario.Valor_Minima) \/ dfBitstampAtualDiario.Valor_Minima) * 100","17325f60":"tracePorcentagem = go.Scatter(\n                name = 'Pre\u00e7o M\u00e9dio (em USD)',\n                x = dfBitstampAtualDiario.index,\n                y = dfBitstampAtualDiario.Preco_Medio_BTC,\n                line = dict(\n                    color = 'rgba(84, 92, 229, 0.9)',\n                    width = 1.5\n                ),\n                text = dfBitstampAtualDiario.index)\n\ntraceVolatilidadeMaxima = go.Scatter(\n                name = 'Pre\u00e7o M\u00e1ximo (em USD)',\n                x = dfBitstampAtualDiario.index,\n                y = dfBitstampAtualDiario.Valor_Maxima,\n                line = dict(\n                    color = 'rgba(229, 84, 165, 0.9)',\n                    width = 1.5,\n                    dash = 'dash'\n                ),\n                text = dfBitstampAtualDiario.index\n)\n\ntraceVolatilidadeMinima = go.Scatter(\n                name = 'Pre\u00e7o Minimo (em USD)',\n                x = dfBitstampAtualDiario.index,\n                y = dfBitstampAtualDiario.Valor_Minima,\n                line = dict(\n                    color = 'rgba(229, 220, 84, 0.9)',\n                    width = 1.5,\n                    dash = 'dash'\n                ),\n                text = dfBitstampAtualDiario.index\n)\n\nlayout = go.Layout(\n    title='Valores Negociados (em USD\/BTC) x Ganho Poss\u00edvel (em %\/BTC)',\n    xaxis=dict(\n        title='Dia',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='Valor por BTC (em USD)',\n        tickprefix = 'USD ',\n        titlefont=dict(\n            size=16\n        )\n    )\n)\n\npy.iplot(go.Figure(data = [tracePorcentagem, traceVolatilidadeMaxima, traceVolatilidadeMinima], layout=layout))","851d12e9":"traceGanhoUSD = go.Scatter(\n                name = 'Ganho M\u00e1ximo (em USD)',\n                x = dfBitstampAtualDiario.index,\n                y = round(dfBitstampAtualDiario.Ganho_Day_Trade, 2),\n                line = dict(\n                    color = 'rgba(84, 92, 229, 0.9)',\n                    width = 1.5\n                ),\n                text = dfBitstampAtualDiario.index)\n\ntraceGanhoPorcentagem = go.Scatter(\n                name = 'Ganho M\u00e1ximo (em %)',\n                x = dfBitstampAtualDiario.index,\n                y = round(dfBitstampAtualDiario.Percentual_Day_Trade, 6),\n                line = dict(\n                    color = 'rgba(229, 84, 165, 0.9)',\n                    width = 1.5,\n                    dash = 'dash'\n                ),\n                text = dfBitstampAtualDiario.index,\n                yaxis = 'y2'\n)\n\nlayout = go.Layout(\n    title='Ganho M\u00e1ximo (em USD\/BTC e %\/BTC) x Data',\n    xaxis=dict(\n        title='Dia',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis=dict(\n        title='Valor por BTC (em USD)',\n        tickprefix = 'USD ',\n        hoverformat = ',2f',\n        titlefont=dict(\n            size=16\n        )\n    ),\n    yaxis2=dict(\n        title='Percentual por BTC (em %)',\n        ticksuffix = ' %',\n        hoverformat = ',6f',\n        titlefont=dict(\n            size=16\n        ),\n        overlaying = 'y',\n        side = 'right'\n    )\n)\n\npy.iplot(go.Figure(data = [traceGanhoUSD, traceGanhoPorcentagem], layout=layout))","aaf6a999":"print(f'Nossa massa de dados engloba {dfBitstampAtualDiario.Percentual_Day_Trade.count()} dias.')\nprint(f'Temos {dfBitstampAtualDiario[dfBitstampAtualDiario.Percentual_Day_Trade > 0.5].Percentual_Day_Trade.count()} casos onde o lucro potencial diario \u00e9 acima de 0.5% (apenas por considera\u00e7\u00e3o)')\nprint(f'Temos {dfBitstampAtualDiario[dfBitstampAtualDiario.Percentual_Day_Trade > 1].Percentual_Day_Trade.count()} casos onde o lucro potencial diario \u00e9 acima de 1% (minimo aceit\u00e1vel)')\nprint(f'Temos {dfBitstampAtualDiario[dfBitstampAtualDiario.Percentual_Day_Trade > 2].Percentual_Day_Trade.count()} casos onde o lucro potencial diario \u00e9 acima de 2% (desejado)')\nprint(f'A m\u00e9dia de lucro m\u00e1ximo diario \u00e9 de {round(dfBitstampAtualDiario.Percentual_Day_Trade.mean(),6)}%, que representa USD {round(dfBitstampAtualDiario.Ganho_Day_Trade.mean(),2)} por BTC negociado')","9e574701":"import keras as K\nimport tensorflow as tf","444e8eed":"dfCasoDeEstudo = df2018\ndfBitstampAtualDiario2019 = dfCasoDeEstudo.groupby(by=dfBitstamp.DataHora.dt.date).mean()\ndfBitstampPorPeriodo2019 = dfCasoDeEstudo.groupby([dfCasoDeEstudo.DataHora.dt.year, dfCasoDeEstudo.DataHora.dt.month]).mean()","20a8e9e3":"dfBitstampAtualSemanal2019 = dfCasoDeEstudo.groupby(by=dfBitstamp.DataHora.dt.weekofyear).mean()\ndfBitstampAtualMensal2019 = dfCasoDeEstudo.groupby(by=dfBitstamp.DataHora.dt.month).mean()","3335fd68":"#utilizando os dados de 2018-2019, vamos treinar uma rede. \ndaily_up_or_down = np.zeros(dfCasoDeEstudo.Preco_Medio_BTC.size)\ncount = 0\nfor i in range(dfCasoDeEstudo.fillna(0).Preco_Medio_BTC.size):\n    if i == 0:\n        continue\n    else:\n        if dfCasoDeEstudo.Preco_Medio_BTC[i] >= dfCasoDeEstudo.Preco_Medio_BTC[i-1]:\n            daily_up_or_down[i] = 1\n        else:\n            daily_up_or_down[i] = 0\n        if dfCasoDeEstudo.Preco_Medio_BTC[i] == dfCasoDeEstudo.Preco_Medio_BTC[i-1]:\n            count+=1","b6995235":"len70 = dfCasoDeEstudo.Preco_Medio_BTC.size * 70 \/ 100\nmaxlen = dfCasoDeEstudo.Preco_Medio_BTC.size","69fa4ea3":"#split de 70-30\n#y sempre deslocado um valor pra baixo\ndf2019_train = dfCasoDeEstudo.reset_index().drop(['DataHora', 'Valor_Abertura', 'Valor_Maxima', 'Valor_Minima','Valor_Fechamento', 'BTC_Negociado', 'USD_Negociado'], axis=1)[0:int(len70)]\ndf2019_test = dfCasoDeEstudo.reset_index().drop(['DataHora','Valor_Abertura', 'Valor_Maxima', 'Valor_Minima','Valor_Fechamento', 'BTC_Negociado', 'USD_Negociado'], axis=1)[int(len70):maxlen-1]\ny_train = daily_up_or_down[0:int(len70)]\ny_test = daily_up_or_down[int(len70):maxlen-1]\n\nprint(f\"df2019_train shape is {df2019_train.shape}\")\nprint(f\"df2019_test shape is {df2019_test.shape}\")\nprint(f\"y_train shape is {y_train.shape}\")\nprint(f\"y_test shape is {y_test.shape}\")\n","403a2a77":"df2019_train = df2019_train.fillna(0)\ndf2019_test = df2019_test.fillna(0)","c2d1080e":"batch_size = 32\ntime_steps = 1\nprediction = 1 #valor a ser previsto (um dia a frente)\nnum_features = 1 # numero de atributos usados; DataHora, Preco Medio BTC","4b7012aa":"RS_VALUE = True\n#Limpa o modelo previamente usado, sen\u00e3o ir\u00e1 acumular camadas\nK.backend.clear_session()\ntf.logging.set_verbosity(tf.logging.ERROR) #desliga os warnings do tensorflow\ninit   = K.initializers.glorot_uniform(seed=1)\ntheOptimizer = K.optimizers.RMSprop()\nmodel = K.models.Sequential()\nmodel.add(K.layers.LSTM(units=32, return_sequences=RS_VALUE,\n                        batch_input_shape=(batch_size, time_steps, num_features),\n                        kernel_initializer=init, activation='relu'))\nmodel.add(K.layers.LSTM(units=8, return_sequences=RS_VALUE))\nmodel.add(K.layers.LSTM(units=10, return_sequences=RS_VALUE))\nmodel.add(K.layers.Dense(units=1,  kernel_initializer=init, activation='tanh'))\n#model.compile(loss='binary_crossentropy', optimizer=theOptimizer, metrics=['mae','mse'])\n#model.compile(loss='mean_squared_error', optimizer=theOptimizer, metrics=['mae','mse'])\nmodel.compile(optimizer=theOptimizer,\n              loss=tf.keras.metrics.mean_squared_error,\n              metrics=[tf.keras.metrics.RootMeanSquaredError(name='rmse')])\nmodel.summary()\nprint(f\"batch_size is {batch_size}\")\n#Train\nmax_epochs = 100\nprint(\"Iniciando treinamento... \")\nX = df2019_train.Preco_Medio_BTC[0:].values[0:((df2019_train.Preco_Medio_BTC.size) - (df2019_train.Preco_Medio_BTC.size % time_steps))]\nX_train = X.reshape(-1, time_steps, num_features) #Esta formata\u00e7\u00e3o \u00e9 necess\u00e1ria para o LSTM\ny = y_train[0:((df2019_train.Preco_Medio_BTC.size) - (df2019_train.Preco_Medio_BTC.size % time_steps))]\ny_train = y.reshape(-1, time_steps, num_features)\nh = model.fit(X_train, y_train, batch_size=batch_size, shuffle=False, verbose=1)\nprint(\"Treinamento finalizado \\n\")","a12ed8ee":"X_test = df2019_test.Preco_Medio_BTC[0:].values[0:((df2019_test.Preco_Medio_BTC.size) - (df2019_test.Preco_Medio_BTC.size % time_steps))]\nX_test = X_test.reshape(-1, time_steps, num_features)\ny_test = y_test[0:((df2019_test.Preco_Medio_BTC.size) - (df2019_test.Preco_Medio_BTC.size % time_steps))]\ny_test = y_test.reshape(-1, time_steps, num_features)","cfcdfb72":"eval = model.evaluate(X_test, y_test, verbose=0)\nprint(\"Dados de teste: loss = %0.6f MAE = %0.2f%% \\n\" \\\n% (eval[0], eval[1]*100) )","0846f826":"y_pred = model.predict(X_test, batch_size=batch_size, verbose=0)","a8b8523d":"y_test_values = y_test.T[0][0][0:]\ny_pred_values = y_pred.T[0][0][0:]","7a05a0f2":"y_pred_values[y_pred_values>0] = 1\ny_pred_values[y_pred_values<=0] = 0","444206d7":"from sklearn.metrics import classification_report\nprint(classification_report(y_test_values, y_pred_values))","58947789":"#split de 70-30\n#y esta sendo deslocado um valor pra baixo, para simular o dia seguinte\ndf2019_train2 = dfCasoDeEstudo.reset_index().drop(['index','DataHora','Valor_Fechamento', 'BTC_Negociado', 'USD_Negociado'], axis=1)[0:int(len70)]\ndf2019_test2 = dfCasoDeEstudo.reset_index().drop(['index','DataHora','Valor_Fechamento', 'BTC_Negociado', 'USD_Negociado'], axis=1)[int(len70):maxlen-1]\ny_train2 = dfCasoDeEstudo.fillna(0).Valor_Fechamento[1:int(len70)+1]\ny_test2 = dfCasoDeEstudo.fillna(0).Valor_Fechamento[int(len70)+1:maxlen]\ndf2019_train2 = df2019_train2.fillna(0)\ndf2019_test2 = df2019_test2.fillna(0)\nprint(f\"df2019_train shape is {df2019_train2.shape}\")\nprint(f\"df2019_test shape is {df2019_test2.shape}\")\nprint(f\"y_train shape is {y_train2.shape}\")\nprint(f\"y_test shape is {y_test2.shape}\")","8e9b5cc6":"batch_size = 32\ntime_steps = 1\nprediction = 1 #valor a ser previsto\nnum_features = 4 # numero de atributos usados; Preco Medio BTC, Valor_Abertura, Valor_Minima, Valor_Maxima","3a92755a":"RS_VALUE = True\t\nK.backend.clear_session()\ntf.logging.set_verbosity(tf.logging.ERROR) #desliga os warnings do tensorflow\ninit   = K.initializers.glorot_uniform(seed=1)\ntheOptimizer = K.optimizers.RMSprop()\nmodel2 = K.models.Sequential()\nmodel2.add(K.layers.LSTM(units=32, return_sequences=RS_VALUE,\n                        batch_input_shape=(batch_size, time_steps, num_features),\n                        kernel_initializer=init, activation='sigmoid'))\nmodel2.add(K.layers.LSTM(units=8, return_sequences=RS_VALUE))\nmodel2.add(K.layers.LSTM(units=5, return_sequences=RS_VALUE))\nmodel2.add(K.layers.Dense(units=1,  kernel_initializer=init, activation='relu'))\n#model2.compile(loss='mean_squared_error', optimizer=theOptimizer, metrics=['mae','mse'])\nmodel2.compile(optimizer=theOptimizer,\n              loss=tf.keras.metrics.mean_squared_error,\n              metrics=[tf.keras.metrics.RootMeanSquaredError(name='rmse')])\nmodel2.summary()","5c2c0ede":"X2 = df2019_train2[0:((df2019_train2.Preco_Medio_BTC.size) - (df2019_train2.Preco_Medio_BTC.size % time_steps))]\nX_Train2 = np.zeros((num_features,time_steps,df2019_train2.Preco_Medio_BTC.size))\ny2 = y_train2.values[0:((df2019_train2.Preco_Medio_BTC.size) - (df2019_train2.Preco_Medio_BTC.size % time_steps))]\ntrainY2 = y2.reshape(-1, time_steps, 1)","eccb1ffc":"X_Train2[0][0] = X2.Valor_Abertura\nX_Train2[1][0] = X2.Valor_Minima\nX_Train2[2][0] = X2.Valor_Maxima\nX_Train2[3][0] = X2.Preco_Medio_BTC","b1936ddb":"#Train\t\nprint(\"Iniciando treinamento... \")\nh = model2.fit(X_Train2.T, trainY2, batch_size=batch_size, shuffle=False, verbose=1)\nprint(\"Treinamento finalizado \\n\")\n","9579df9d":"dftest2 = df2019_test2[0:((df2019_test2.Preco_Medio_BTC.size) - (df2019_test2.Preco_Medio_BTC.size % time_steps))]\nX_test2 = np.zeros((num_features,time_steps,df2019_test2.Preco_Medio_BTC.size))\nX_test2[0][0] = dftest2.Valor_Abertura\nX_test2[1][0] = dftest2.Valor_Minima\nX_test2[2][0] = dftest2.Valor_Maxima\nX_test2[3][0] = dftest2.Preco_Medio_BTC\nseriesY2 = y_test2.values[0:((df2019_test2.Preco_Medio_BTC.size) - (df2019_test2.Preco_Medio_BTC.size % time_steps))]\ntestY2 = seriesY2.reshape(-1, time_steps, 1)","842d3d48":"eval = model2.evaluate(X_test2.T, testY2, verbose=0)\nprint(\"Dados de teste: loss = %0.6f MAE = %0.2f%% \\n\" \\\n% (eval[0], eval[1]*100) )","a80c2c21":"#pegar valores\ny_pred2 = model2.predict(X_test2.T, batch_size=batch_size, verbose=0)","289993bc":"y_pred2[0]","9217da51":"#Treinamento como regress\u00e3o\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.svm import SVR\nfrom sklearn import datasets\nimport matplotlib.pylab as plt","b688af05":"from sklearn.model_selection import train_test_split\nX_train_sk, X_test_sk, y_train_sk, y_test_sk = train_test_split(dfCasoDeEstudo.reset_index().fillna(0).drop(['index','DataHora','Valor_Fechamento', 'BTC_Negociado', 'USD_Negociado'], axis=1),\n                                                   dfCasoDeEstudo.fillna(0).Valor_Fechamento, test_size=0.33, random_state=0)","60183125":"model_sk = LinearRegression()\n# 2. Use fit\nmodel_sk.fit(X_train_sk, y_train_sk)\n# 3. Check the score\nmodel_sk.score(X_test_sk, y_test_sk)","82f4c534":"model_sk.predict(X_test_sk)","4aa5e50f":"y_pred_sk = model_sk.predict(X_test_sk) \nplt.plot(y_test_sk, y_pred_sk, '.')\n\n# plot a line, a perfit predict would all fall on this line\nx = np.linspace(0, 330, 100)\ny = x\nplt.plot(x, y)\nplt.show()","14f4514e":"#clf = SVR(gamma='scale')\n#clf.fit(X_train_sk, y_train_sk)\n#clf.score(X_test_sk, y_test_sk)","00abdc13":"model_sk_2 = LinearRegression()\nmodel_sk_2.fit(df2019_train2, y_train2)\nmodel_sk_2.score(df2019_test2, y_test2)\n#86 melhor do que 99, eu suponho","0a360d5b":"## Analise Preliminar\n\nA aus\u00eancia de tr\u00eas curvas no gr\u00e1fico j\u00e1 me soa como um pess\u00edmo sinal para a rentabilidade potencial da moeda.\nAntes de tomar uma decis\u00e3o, no entanto, vou buscar o m\u00e1ximo de lucro potencial que o bitcoin me oferece diariamente.","c9720581":"# TCC - Analise de Bitcoin com base em dados historicos\n\n### Alunos - Ciro Mora e Renan Renger\n","0cd5d40f":"### Faremos uma classifica\u00e7\u00e3o bem simples com apenas dois valores para nossa vari\u00e1vel de verifica\u00e7\u00e3o Y.\n\n### Se o pre\u00e7o medio de um dia para o outro subiu ou estagnou, ser\u00e1 atribuido o valor 1, ou seja, venda.\n### caso contrario, 0\n\no ideal seria ter um terceiro tipo para -1 quando o valor m\u00e9dio n\u00e3o \u00e9 alterado, mas os casos de estagnacao de precos sao bem raros, aprox 1% dos dados obtidos, ent\u00e3o n\u00e3o vale a pena uma classica\u00e7\u00e3o s\u00f3 para eles\n\n#### Os dados de treinamento da variavel X (df2019) ser\u00e3o splitados 70-30, utilizando os primeiros 70% dos dados historicamente para tentar adivinhar os ultimos 30%","ab6c9802":"## 2 - Rela\u00e7\u00e3o entre volume negociado e valor","9f4d8778":"## Analise Preliminar\n\nAinda mantendo o comportamento diario, a vis\u00e3o semanal apresenta todas as mesmas caracteristicas que j\u00e1 esperavamos, com boas oportunidades para \"short\" e \"long\" durante o come\u00e7o do ano e uma maior estabilidade nos valores no final do ano, quando o \"hype\" j\u00e1 havia morrido e grande parte da m\u00eddia deixava de noticiar quase diariamente a situa\u00e7\u00e3o da criptomoeda.\n\nEnfase para as semanas 24 a 32, onde podemos ver claramente um padr\u00e3o chamado de \"Retra\u00e7\u00e3o de Fibonacci\", onde o ativo salta de valor (24 - > 25), tem uma queda pequena (25 -> 26), uma nova alta (26 -> 27), uma nova baixa (27 -> 28) e, finalmente, uma ultima disparada (28 -> 29) antes de cair para o valor inicial da corrida (29 -> 32).","6e679321":"# Identificar os dados para utilizar num treinamento de rede LSTM","714e4dd2":"# Analises\n## 1 - Comportamento Temporal\n\nVamos iniciar a analise com o comportamente temporal do bitcoin no decorer da sua vida at\u00e9 a data mais atual do dataset.\n\nGerados dataframes relativos aos intervalos desejados para analise temporal - Anual, Mensal. Semanal e Diario","88239f8f":"### Resultado do treinamento","db16145f":"## Objetivos\n\n### Responder quest\u00f5es pertinentes aos dados obtidos\n\n### Identificar os dados para utilizar num treinamento de rede LSTM\n\n### Treinar uma rede LSTM para gerar o valor medio do pre\u00e7o do bitcoin do dia seguinte com base em dados historicos","661c24a8":"## Analise Preliminar\n\nA priori, 3,60% de volatilidade di\u00e1ria \u00e9 um valor elevad\u00edssimo, muito al\u00e9m do normal de outros investimentos de risco semelhante (tais \u00edndices geralmente s\u00e3o atigindos somente com noticias, divulga\u00e7\u00f5es de resultados ou comunicados de extrema import\u00e2ncia, sendo considerados como eventos an\u00f4malos). Para piorar a situa\u00e7\u00e3o, durante 3 ou 4 primeiros meses do ano de 2018, por termos vindo de um crash da moeda, temos taxas de rentabilidade ainda mais desconexas com a volatilidade calculada, elevando ainda mais o risco de investimentos no ativo.\n\nO que chama a aten\u00e7\u00e3o \u00e9 a eventual estabiliza\u00e7\u00e3o da moeda conforme o ano se transcorria, os efeitos do crash dando lugar a uma rentabilidade e um risco menor, assumindo um comportamento quase que totalmente dentro da volatilidade do per\u00edodo ao chegarmos na segunda metade de Agosto, com apenas um caso de quebra de padr\u00e3o (06\/09), podendo estar associado a algum evento an\u00f4malo que pode ser investigado em momento oportuno.\n\nVale mencionar, ainda assim, que investidores cientes do risco apresentado pelo ativo poderiam lucrar tanto \"na alta\" (com opera\u00e7\u00f5es do tipo \"long\") quanto \"na baixa\" (\"short\" em dias de queda acentuada), em especial na primeira semana de Fevereiro, que apresentou taxas muito al\u00e9m das calculadas pro per\u00edodo.","6b605ede":"# Conclus\u00e3o\n\n### Infelizmente n\u00e3o foi poss\u00edvel adquirir um resultado confi\u00e1vel com base na rede utilizada, em ambos os treinamentos\n\nInicialmente, foi feito um treinamento com dados de saida normalizados, e em seguida um com o valores puros e mais variaveis de entrada.\nO primeiro treinamento apresentou MAE de aproximadamente 50%, enquanto O segundo retornou um MAE de 70%, ambos valores muito altos para o erro absoluto\n\nContudo, o segundo treinamento conseguiu retornar um valor de predi\u00e7\u00e3o, que era nosso objetivo inicial. Esse valor calculado seria o Valor de Fechamento do Bitcoin calculado para o dia seguinte da amostra. Infelizmente com uma acur\u00e1cia t\u00e3o baixa ainda n\u00e3o \u00e9 possivel utilizar esse valor como dado real para investimento, mas j\u00e1 \u00e9 um resultado que pode ser tunado e otimizado com o tempo. \n\nAssim, a conclus\u00e3o que podemos obter segue a apresentada acima com as quest\u00f5es. O valor de bitcoin aparenta ser muito vol\u00e1til para identificar ele mesmo com uma rede neural, e esta volatilidade impede que um potencial investidor possa tomar decis\u00f5es com precis\u00e3o melhor do que s\u00f3 jogar uma moeda e decidir pela sorte. Al\u00e9m disso, as margens que podemos conseguir no Day Trade s\u00e3o t\u00e3o baixas que n\u00e3o valem o esfor\u00e7o de desenvolver um algoritmo que consiga operar nessa escala, valendo mais a pena focar no Swing Trade e obter lucros \"reais\".","85aff5d2":"### Teste de MLP 1 - rede composta por 4 camadas, sendo a primeira nInputs, a segunda 8 nos, a terceira 10 nos, e a camada de saida com apenas um valor, 1 ou 0\n\nEntrada - dataset somente com pre\u00e7o-medio do BTC \nSaida - fizemos o encoding retornar 1 caso o valor do dia seja maior que o do dia anterior, 0 caso contrario.","07353052":"## 5 - Aptid\u00e3o a \"Day Trade\"\n\nComo dito antes, o conceito de \"Day Trade\" se resume em efetuar opera\u00e7\u00f5es que s\u00e3o iniciadas e finalizadas (ou \"abertas\" e \"fechadas\", na terminologia financeira) no mesmo dia, contabilizando lucro ou prejuizo por dia ao inv\u00e9s de per\u00edodos maiores.\n\n**Como poss\u00edvel Day Trader, interessa saber se o bitcoin apresenta o potencial de rentabilidade diaria que considero \"justa\" pelo seu risco, em torno de 2% ao dia (ou 60% a.m) ou , caso esteja \"de bom humor\", poderia at\u00e9 mesmo operar com uma margem de \"apenas\" 1% a.d (30% a.m).**\n\nCaso a moeda n\u00e3o atinja essa margens, trabalharemos apenas com \"Swing Trade\", operando em escalas semanais e gastando menos \"recursos\" com o desenvolvimento de um \"rob\u00f4\".","39d223e8":"#### Segundo treinamento\t\nComo o treinamento com valores bin\u00e1rios mostrou sinais de overfitting, vamos utilizar os valores normais como par\u00e2metros de entrada, e o valor de fechamento como saida. Assim, o valor obtido ap\u00f3s treinamento ser\u00e1 num\u00e9rico, e possivelmente com mais features teremos outra an\u00e1lise do sistema.","b09660df":"# Conclus\u00e3o\n\nComo era esperado, o BTC apresenta uma volatilidade muito al\u00e9m de outras modalidades de investimento de risco semelhantes (salvo por eventos an\u00f4malos nessa modalidades), por\u00e9m com uma rentabilidade igualmente elevada, que vem decaindo lentamente conforma a moeda atinge uma nova fase de letargia ap\u00f3s o \"boom\" ocorrido em 2017.\n\nPara um trader que busca retornos r\u00e1pidos, o BTC deixou de lado a caracteristica explosiva dele e tornou-se desvantajoso, substituido facilmente por a\u00e7\u00f5es ou pelo pr\u00f3prio IBOV, no caso de trader brasileiros.\nJ\u00e1 para nossa proposta, o comportamento mais est\u00e1vel da moeda torna mais f\u00e1cil da automatiza\u00e7\u00e3o do processo, visto que a chance de detectarmos padr\u00f5es \u00e9 maior em dados mais centrados.","20efc464":"## 3 - Volatilidade do Ativo e 4 - Rentabilidade\n\nPara todas as analises de agora em diante, vamos focar apenas nos dados a partir de 2018, visto que queremos entender o comportamento financeiro do ativo e que, por essa \u00f3tica, dados anteriores n\u00e3o representam o comportamento da moeda, como visto no gr\u00e1fico de comportamento anual;\n\n**Para calculo da Volatilidade, usaremos o desvio padr\u00e3o da porcentagem de rentabilidade em cada um dos per\u00edodos**, calculado da seguinte forma:\n\n**Rentabilidade no Per\u00edodo: (pAtual - pAnterior)\/pAnterior**, sendo **pAtual = Pre\u00e7o no Per\u00edodo Corrente** e **pAnterior = Pre\u00e7o no Per\u00edodo Anterior**\n\n---\n\nConsiderando a proximidade entre as duas grandezas a serem analisadas (a volatilidade \u00e9 calculada a partir da rentabilidade, afinal), faremos uma analise conjunta de ambas, tanto em intervalos diarios, quanto mensais e semanais","f2faecf7":"## Considera\u00e7\u00f5es do treinamento de deep learning\n\nIremos separar as variaveis e organizar uma database para treinamento do valores de bitcoin, para identificar se haver\u00e1 flutua\u00e7\u00e3o de bitcoin, e qual o valor (inclusive com a dire\u00e7\u00e3o). \n\nPor\u00e9m \u00e9 necess\u00e1rio saber qual resultado queremos obter. Por exemplo, se obtermos o preco medio diario do proximo dia... o que isso nos diz? Se o preco cair, podemos vender, e se o preco subir, podemos comprar? E se fizermos para uma semana? O pre\u00e7o medio di\u00e1rio ser maior ou menor n\u00e3o significa que devemos comprar ou vender imediatamente o investimento feito no bitcoin. \nPortanto, por hora, gostariamos de utilizar uma rede neural com base nos dados passados e tentar bater esses valores com valores j\u00e1 existentes antes de tentar adivinhar o futuro.\n\nNo caso, se pegassemos todos os dados de 2019 at\u00e9 julho, e utilizassemos esses dados para verificar os valores medios obtidos dia a dia de agosto, esses teriam que bater. E a partir dessa rela\u00e7\u00e3o sim, decidir se \u00e9 valido investir (comprar) ou vender. Por\u00e9m \u00e9 poss\u00edvel essa an\u00e1lise n\u00e3o retorne nenhum resultado, ou um resultado t\u00e3o bom que seja impreciso com a realidade.\n\nTeremos nossas variaveis X (df2019) para entrada de dados, e y para saido de resultado classificado.","c0f5e8dc":"### Analise Preliminar\nInfelizmente nenhuma rela\u00e7\u00e3o (tanto diretamento quanto inversamente) foi observada entre o valor m\u00e9dio de venda e o volume de BTC no per\u00edodo;\n\nTalvez melhorando o conjunto de dados com informa\u00e7\u00f5es das ordens em si e considerando o quanto desse volume foi de compra e quanto de venda, possamos chegar a uma rela\u00e7\u00e3o minimamente informativa entre as duas grandezas.","3fa3a4c0":"## Variaveis utlizadas\n\nUtilizaremos somente duas variaveis para entrada, DataHora e Pre\u00e7oMedio. isso \u00e9 para simplificar a an\u00e1lise do LSTM que ser\u00e1 desenvolvido mais a frente. Caso essas variaveis n\u00e3o apresentem resultado significativo, faremos uma an\u00e1lise mais detalhada e com mais vari\u00e1veis.","097a8492":"# Quest\u00f5es Pertinentes\n## 1 - Comportamento Temporal\nAntes de buscarmos nos aprofundar no dataset, vale uma compreens\u00e3o do comportamento temporal do ativo, partindo por uma vis\u00e3o cronol\u00f3gica linear e seguindo para uma analise grupos temporais semelhantes, como meses, semanas e dias da semana;\n\n## 2 - Rela\u00e7\u00e3o entre volume negociado e valor\nPara validar uma cren\u00e7a informal (que quanto mais BTC se negocia, maior o valor da moeda), podemos cruzar essas duas vari\u00e1veis em uma escala temporal e ver existe realmente uma rela\u00e7\u00e3o entre elas;\n\n## 3 - Volatilidade do Ativo\nUma da vari\u00e1veis que define a classe de risco de um ativo \u00e9 seu grau de volatilidade. Antes de seguimos com nossos planos de investir em BTC, devemos analisar qual o grau de risco da moeda;\n\n## 4 - Rentabilidade\nAl\u00e9m do risco, para definirmos se um investimento \u00e9 vi\u00e1vel, devemos ver sua rentabilidade hist\u00f3rica (lembrando sempre que isso n\u00e3o nos garante rendimentos futuros e sim deve ser utilizado como base) e cruzar isso com a volatilidade, definindo se desejamos investir ou n\u00e3o em tal ativo;\n\n## 5 - Aptid\u00e3o a \"Day Trade\"\nO conceito de \"Day Trade\" \u00e9 operar em intervalos curtos de tempo, no caso da nossa analise sendo definido como opera\u00e7\u00f5es no mesmo dia; Para tal, o ativo deve apresentar uma amplitude consider\u00e1vel em seus valores m\u00e1ximos e m\u00ednimos, permitindo que a um bom trader (que a analise assume que somos) maximizar seus lucros;","c5b5bcf4":"### Analise Preliminar\nSalvo por uma queda na sexta e s\u00e1bado, que pode ou n\u00e3o estar associada a uma quest\u00e3o de mercado com maior fluxo (China) e seu fuso hor\u00e1rio, existe uma consist\u00eancia na quantidade de transa\u00e7\u00f5es por dia, assim como um padr\u00e3o de transa\u00e7\u00f5es mais \"volumosas\" no meio da semana;","a2daa749":"### Analise Preliminar\nEnquanto a quantidade de transa\u00e7\u00f5es por m\u00eas mantem uma regularidade, o valor por transa\u00e7\u00e3o apresenta uma queda nos meses centrais, com altas no \u00ednicio e fim do per\u00edodo.\nTalvez ao cruzar com os dados de valor m\u00e9dio da moeda nesses meses, possamos compreender o que causou tal comportamento.","9013fb25":"## 1\u00bapasso - Convers\u00e3o de labels de colunas para termos locais","9a9a1909":"Antes de seguirmos com a defini\u00e7\u00e3o de um per\u00edodo para analise, vamos estudar os intervalos em que os dados se encontram, para termos uma vis\u00e3o melhor do todo","ae6ca3a3":"### Analise Preliminar\nComo era esperado, uma vez que a ado\u00e7\u00e3o do Bitcoin como ativo negoci\u00e1vel come\u00e7ou a \"engrenar\" em 2013, houve uma regularidade no volume de transa\u00e7\u00f5es quebrada apenas por 2017, ano de maior visibilidade do ativo na m\u00eddia. \nNo que tange ao volume por transa\u00e7\u00e3o, 2015 e 2016 apresentam comportamentos an\u00f4malos, com varia\u00e7\u00f5es muito distintas do padr\u00e3o dos outros anos (aumento na quantidade de transa\u00e7\u00f5es, diminui\u00e7\u00e3o do volume transferido a cada opera\u00e7\u00e3o) ","9f611b92":"## Analise Temporal - Anual, mensal, semanal e diaria\nPara todas as analises temporais, vamos focar no volume de bitcoins negociados em um dado per\u00edodo em virtude da quantidade de transa\u00e7\u00f5es (**vide a observa\u00e7\u00e3o acima**) neste mesmo intervalo de tempo;","582921f3":"### Analise Preliminar\nAssim como na escala mensal (e como era esperado), a vis\u00e3o semanal nos mostra uma regularidade na quantidade de transa\u00e7\u00f5es e uma maior estaabilidade, com alguns movimentos indicando poss\u00edvel padr\u00e3o, surgindo mais claramente na semana 14 e seguindo, com algumas pequenas varia\u00e7\u00f5es, at\u00e9 a semana 39;\nPara um trader, esse poderia ser um momento de aten\u00e7\u00e3o e maior analise, pois pode revelar uma queda mais acentuada no pre\u00e7o e maior potencial de retorno (iremos explorar essa possibilidade em momento oportuno);\nUma observa\u00e7\u00e3o \u00e9 merecida ao per\u00edodo que engloba as semanas 51, 52 e 53. Podemos ver claramente uma queda brusca tanto na quantidade de transa\u00e7\u00f5es quanto no volume das mesmas nessas semanas, fazendo valer uma analise mais detalhada em momento futuro;","9572a954":"## 2\u00ba Passo - Convers\u00e3o da Data Unix para Data \"Humana\"","720af795":"# Estudo preliminar - Intervalos de data e valor","58d9a7ac":"# Treinando uma rede LSTM para gerar o valor medio do pre\u00e7o do bitcoin do dia seguinte com base em dados historicos ","1b90ae6e":"## Conclus\u00e3o\n\nMesmo que desconsiderassemos a taxa de transferencia da rede (que possivelmente comeria o lucro de qualquer transa\u00e7\u00e3o abaixo de 0.5% de lucro), as margens que podemos conseguir no Day Trade s\u00e3o t\u00e3o baixas que n\u00e3o valem o esfor\u00e7o de desenvolver um algoritmo que consiga operar nessa escala, valendo mais a pena focar no Swing Trade e obter lucros \"reais\".","b434f0f6":"#### Parametros","41843a68":"#### Montando o modelo","201148b8":"## Analise Preliminar\n\nO mais est\u00e1vel dos gr\u00e1ficos, a volatilidade mensal do BTC ultrapassa a anual de op\u00e7\u00f5es mais conservadoras, situando-se acima dos 12% a.m.\n\nMesmo assim, dois meses apresentaram rentabilidade fora desse alcan\u00e7e (Fevereiro e Junho), com perdas muito superiores ao limite da volatilidade (37% e 24%, respectivamente). \nNo que tange a Fevereiro, o comportamento \u00e9 esperado, visto as discrep\u00e2ncias no que tange a rentabilidade diaria, cabendo uma analise mais detalhada de Junho para que possamos localizar a causa dessa an\u00f4malia.","254db51c":"### Pos-Conclus\u00e3o, treinamentos adicionais\n\ncomentarios - \n\nSe tiver tempo, tente rodar de novo seu algoritmo e melhorar um pouco os resultados. Como voc\u00ea teve muita dificuldade com o LSTM, eu sugiro tentar treinar um modelo usando algum algoritmo do scikit-learn (pode ser o linear regression e ou SVR, por exemplo), usando como X alguns pre\u00e7os anteriores (digamos, os 10 pre\u00e7os anteriores), e como Y o pre\u00e7o a ser previsto. J\u00e1 deve dar um resultado melhor em rela\u00e7\u00e3o ao que voc\u00ea conseguiu. Se voc\u00ea conseguir fazer isso, pode mostrar l\u00e1 no dia da apresenta\u00e7\u00e3o (n\u00e3o precisa enviar os resultados de novo).\n\nhttps:\/\/www.kaggle.com\/andyxie\/beginner-scikit-learn-linear-regression-tutorial","4ab762b7":"# Antes de seguirmos, observa\u00e7\u00f5es devem ser feitas: \n\nPor quest\u00e3o de simplicidade, estamos assumindo que cada minuto onde houveram transa\u00e7\u00f5es, UMA E APENAS UMA TRANSA\u00c7\u00c3O FOI FEITA.\nIsto \u00e9 feito para n\u00e3o ser necess\u00e1ria a incrementa\u00e7\u00e3o do dataset com dados das opera\u00e7\u00f5es em si (que podem ou n\u00e3o serem fornecidos pela bolsa de criptoativos), atigindo assim uma escala e comportamento mais simplificados para nossa an\u00e1lise.\n\nVale ainda mencionar que os valores em BTC s\u00e3o exibidos com 9 casas por se tratar da menor unidade tecnicamente negoci\u00e1vel (Satoshi, 10^-9 BTC)\n\n## Novamente: Os valores de transa\u00e7\u00f5es podem (e, geralmente, devem) ser maiores do que os apresentados nos gr\u00e1ficos, os desmonstrados servindo apenas para analise de tend\u00eancia!","3621c697":"# Descri\u00e7\u00e3o do dataset\n## Terminologia\n**Criptoativos \/criptomoeda** -> \"Moeda digital\" baseada em opera\u00e7\u00f5es matem\u00e1ticas e com forte apelo para descentraliza\u00e7\u00e3o dos recursos financeiros e maior agilidade, privacidade e seguran\u00e7a do que as alternativas atuais;\n\n**BTC** -> Bitcoin, primeira criptomoeda desenvolvida e lan\u00e7ada comercialmente para negocia\u00e7\u00e3o, considerada a mais forte e est\u00e1vel dentre as exist\u00eantes atualmente devido a sua \"resili\u00eancia\" a crises e desvaloriza\u00e7\u00f5es; \n\n**USD** -> United States Dollar ou Dolar Americano, moeda usada como refer\u00eancia para as transa\u00e7\u00f5es na maioria das bolsas, devido a f\u00e1cil convers\u00e3o entre BTC e USD;\n\n**Bitstamp** -> Bolsa de criptoativos online respons\u00e1vel por facilitar as negocia\u00e7\u00f5es entre traders; Provem informa\u00e7\u00f5es relacionadas ao valor e as transa\u00e7\u00f5es efetuadas, servindo como base de dados para esse estudo;\n\n**Trader** -> Negociador que opera no mercado (neste caso, de criptoativos) visando, atrav\u00e9s de consecutivas opera\u00e7\u00f5es de compra e venda, obter lucro;\n\n**Long** -> Investimento visando\/\"apostando\" lucro em caso de aumento no valor do ativo, normalmente envolvendo a compra a valores mais baixos e venda a valores mais altos;\n\n**Short** -> Oposto ao Long, visa ganhos \"alugando\" ativos a um valor mais alto, vendendo os mesmos imediatamente e os recomprando a um pre\u00e7o mais baixo, devolvendo a mesma quantidade de ativos (que valem menos do que quanto \"alugados\") e lucrando com a diferen\u00e7a entre o valor no momento da venda e da recompra;\n\n## Colunas\n**Timestamp** - > Data (em formato Epoch Unix) da coleta dos dados; Ser\u00e1 transformada posteriormente em data \"humana\" para melhor compreens\u00e3o; Intervalos de aproximadamente 1 em 1 minuto, com fuso definido para UTC;\n\n**Open** -> Valor inicial de negocia\u00e7\u00e3o da moeda naquele intervalo de medi\u00e7\u00e3o, em USD;\n\n**High** -> Maior valor atingido pelo ativo durante aquele intervalo de medi\u00e7\u00e3o, em USD;\n\n**Low** -> Menor valor atingido pelo ativo durante aquele intervalo de medi\u00e7\u00e3o, em USD;\n\n**Close** -> Valor do ativo no momento de fechamento do intervalo de medi\u00e7\u00e3o, em USD;\n\n**Volume_(BTC)** -> Volume, em BTC, negociado na Bitstamp durante um dado intervalo de medi\u00e7\u00e3o;\n\n**Volume_(Currency)** -> Volume, em USD, negociado na Bitstamp durante um dado intervalo de medi\u00e7\u00e3o;\n\n**Weighted_Price** -> Pre\u00e7o m\u00e9dio do ativo naquele intervalo, em USD; Calculado com base nos volumes negociados; Ser\u00e1 considerado como pre\u00e7o m\u00e9dio para quest\u00f5es analiticas.","1221eeaf":"### Iniciando o treinamento com a rede LSTM. ","94524733":"# Pr\u00e9-processamento dos dados"}}