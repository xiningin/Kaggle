{"cell_type":{"008c9dc0":"code","ee844cfd":"code","e615519c":"code","ee52e2e3":"code","25b10280":"code","efdbd7ab":"code","f7231805":"code","1d068fdb":"code","504b2d50":"code","b42f194b":"code","73d76ef1":"code","64cead0b":"code","afcb7787":"code","8c5bf414":"code","88089148":"code","46c90153":"code","5a6f9f06":"code","7a7ef720":"code","b40b1111":"code","2b8eecea":"code","0090e65b":"code","2c71c437":"code","fa59811f":"code","63560dde":"code","4d7b87cf":"code","5a0c43cd":"code","a68eb3e6":"code","b4d6e39f":"code","5acfcaac":"code","7591e881":"code","ffd34852":"code","9664674f":"markdown","fd2174bc":"markdown","3834242a":"markdown","93d3de82":"markdown","a9dd82ee":"markdown","7c9d57f2":"markdown","300f52ad":"markdown","457b1ee9":"markdown","9e9f8f4b":"markdown","3bfd3c5e":"markdown","e8022fe3":"markdown","b22d2950":"markdown","c7271314":"markdown","fa563b2f":"markdown","8e4ecf8c":"markdown"},"source":{"008c9dc0":"import numpy as np\nimport pandas as pd\nimport seaborn as sns","ee844cfd":"df = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                   'X1': [3,6,4.5,6.1,8.8,9.1,10,11.8,13],\n                   'X2': [5,5.2,6,8,7,7.9,5.8,4.2,5.7]})\ndf","e615519c":"sns.scatterplot(df['X1'],df['X2'])","ee52e2e3":"c1 = ( 4.5 , 6 )\nc2 = ( 8.8 , 7 )\nprint('Group1')\nprint('Iteration1')\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c1','c2','c2','c2','c2','c2']})\nprint('Centroids : ',c1,c2)\nprint(df_dist)\nprint()\nprint('Iteration2')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c1','c2','c2','c2','c2','c2']})\nprint(df_dist)\nprint()\nprint('Iteration3')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\nprint('As centroid value does not change after Iteration 2, the algorithm stops here...')\nInertia_c1 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'] - c1[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'] - c1[1])**2)))**2)\nInertia_c2 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'] - c2[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'] - c2[1])**2)))**2)\ntotal_inertia = Inertia_c1 + Inertia_c2\nprint('C1 Inertia : ',Inertia_c1)\nprint('C2 Inertia : ',Inertia_c2)\nprint(\"Total Inertia : \",total_inertia)","25b10280":"c1 = ( 6 , 5.2 )\nc2 = ( 6.1 , 8 )\nprint('Group2')\nprint('Iteration1')\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c2','c2','c2','c1','c1','c1']})\nprint('Centroids : ',c1,c2)\nprint(df_dist)\nprint()\nprint('Iteration2')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c2','c2','c2','c1','c1','c1']})\nprint(df_dist)\nprint()\nprint('Iteration3')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\nprint('As centroid value does not change after Iteration 2, the algorithm stops here...')\nInertia_c1 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'] - c1[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'] - c1[1])**2)))**2)\nInertia_c2 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'] - c2[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'] - c2[1])**2)))**2)\ntotal_inertia = Inertia_c1 + Inertia_c2\nprint('C1 Inertia : ',Inertia_c1)\nprint('C2 Inertia : ',Inertia_c2)\nprint(\"Total Inertia : \",total_inertia)","efdbd7ab":"c1 = ( 4.5 , 6 )\nc2 = ( 10 , 5.8 )\nprint('Group3')\nprint('Iteration1')\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c1','c2','c2','c2','c2','c2']})\nprint('Centroids : ',c1,c2)\nprint(df_dist)\nprint()\nprint('Iteration2')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c1','c2','c2','c2','c2','c2']})\nprint(df_dist)\nprint()\nprint('Iteration3')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\nprint('As centroid value does not change after Iteration 2, the algorithm stops here...')\nInertia_c1 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'] - c1[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'] - c1[1])**2)))**2)\nInertia_c2 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'] - c2[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'] - c2[1])**2)))**2)\ntotal_inertia = Inertia_c1 + Inertia_c2\nprint('C1 Inertia : ',Inertia_c1)\nprint('C2 Inertia : ',Inertia_c2)\nprint(\"Total Inertia : \",total_inertia)","f7231805":"c1 = ( 6.1 , 8 )\nc2 = ( 6 , 5.2 )\nprint('Group4')\nprint('Iteration1')\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c2','c2','c2','c1','c1','c1','c2','c2','c2']})\nprint('Centroids : ',c1,c2)\nprint(df_dist)\nprint()\nprint('Iteration2')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c2','c2','c2','c1','c1','c1','c2','c2','c2']})\nprint(df_dist)\nprint()\nprint('Iteration3')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\nprint('As centroid value does not change after Iteration 2, the algorithm stops here...')\nInertia_c1 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'] - c1[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'] - c1[1])**2)))**2)\nInertia_c2 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'] - c2[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'] - c2[1])**2)))**2)\ntotal_inertia = Inertia_c1 + Inertia_c2\nprint('C1 Inertia : ',Inertia_c1)\nprint('C2 Inertia : ',Inertia_c2)\nprint(\"Total Inertia : \",total_inertia)","1d068fdb":"c1 = ( 8.8 , 7 )\nc2 = ( 11.8 , 4.2 )\nprint('Group5')\nprint('Iteration1')\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c1','c1','c1','c1','c2','c2']})\nprint('Centroids : ',c1,c2)\nprint(df_dist)\nprint()\nprint('Iteration2')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c1','c1','c1','c2','c2','c2']})\nprint(df_dist)\nprint()\nprint('Iteration3')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c1','c1','c1','c2','c2','c2']})\nprint(df_dist)\nprint()\nprint('Iteration4')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\nprint('As centroid value does not change after Iteration 3, the algorithm stops here...')\nInertia_c1 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'] - c1[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'] - c1[1])**2)))**2)\nInertia_c2 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'] - c2[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'] - c2[1])**2)))**2)\ntotal_inertia = Inertia_c1 + Inertia_c2\nprint('C1 Inertia : ',Inertia_c1)\nprint('C2 Inertia : ',Inertia_c2)\nprint(\"Total Inertia : \",total_inertia)","504b2d50":"c1 = ( 6 , 5.2 )\nc2 = ( 11.8 , 4.2 )\nprint('Group6')\nprint('Iteration1')\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c1','c1','c1','c2','c2','c2']})\nprint('Centroids : ',c1,c2)\nprint(df_dist)\nprint()\nprint('Iteration2')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\ndf_dist = pd.DataFrame({'ID': ['s1','s2','s3','s4','s5','s6','s7','s8','s9'],\n                        'Dist_c1':np.sqrt(((df['X1']-c1[0])**2) + ((df['X2']-c1[1])**2)),\n                        'Dist_c2':np.sqrt(((df['X1']-c2[0])**2) + ((df['X2']-c2[1])**2)),\n                        'cluster':['c1','c1','c1','c1','c1','c1','c2','c2','c2']})\nprint(df_dist)\nprint()\nprint('Iteration3')\nc1 = (df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'].mean())\nc2 = (df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'].mean(),df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'].mean())\nprint('Centroids : ',c1,c2)\nprint('As centroid value does not change after Iteration 2, the algorithm stops here...')\nInertia_c1 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X1'] - c1[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c1'].index),:]['X2'] - c1[1])**2)))**2)\nInertia_c2 = np.sum((np.sqrt(((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X1'] - c2[0])**2) + ((df.loc[list(df_dist[df_dist['cluster'] == 'c2'].index),:]['X2'] - c2[1])**2)))**2)\ntotal_inertia = Inertia_c1 + Inertia_c2\nprint('C1 Inertia : ',Inertia_c1)\nprint('C2 Inertia : ',Inertia_c2)\nprint(\"Total Inertia : \",total_inertia)","b42f194b":"df2 = pd.read_csv('..\/input\/abalone-dataset\/abalone.csv')","73d76ef1":"df2.head()","64cead0b":"df2.shape","afcb7787":"df2.drop('Sex',axis = 1,inplace = True)","8c5bf414":"sns.pairplot(df2,diag_kind = 'kde')","88089148":"from scipy.stats import zscore\ndf_scaled = df2.apply(zscore)\ndf_scaled.head()","46c90153":"from sklearn.cluster import KMeans","5a6f9f06":"cluster_range = range(1,15)\ncluster_errors = []\nfor num_clusters in cluster_range:\n  model = KMeans(num_clusters)\n  model.fit(df_scaled)\n  cluster_errors.append(model.inertia_)","7a7ef720":"import matplotlib.pyplot as plt","b40b1111":"clusters_df = pd.DataFrame({'clusters':cluster_range,\n                            'inertia': cluster_errors})\nclusters_df","2b8eecea":"plt.figure(figsize = (12,6))\nplt.plot(clusters_df['clusters'],clusters_df['inertia'],marker = 'o')\nplt.xlabel('k')\nplt.ylabel('Inertia')","0090e65b":"kmeans = KMeans(n_clusters = 3,n_init = 15,random_state = 2)\nkmeans.fit(df_scaled)","2c71c437":"centroids = kmeans.cluster_centers_\ncentroids","fa59811f":"centroid_df = pd.DataFrame(centroids,columns = list(df_scaled.columns))\ncentroid_df","63560dde":"df_scaled['labels'] = list(kmeans.labels_)\ndf_scaled","4d7b87cf":"sns.pairplot(df_scaled,hue = 'labels')","5a0c43cd":"sns.set(style = 'ticks',color_codes=True)\n\ndf2 = pd.read_csv('..\/input\/matplotlib-datasets\/iris_dataset.csv')\n\ndf2","a68eb3e6":"df2.drop('species',axis = 1,inplace = True)\n\ndf_scaled = df2.apply(zscore)\n\nsns.pairplot(df_scaled,diag_kind='kde')","b4d6e39f":"clusters_range = range(1,15)\ninertia = []\nfor num_clust in clusters_range:\n  model = KMeans(n_clusters = num_clust,random_state = 2)\n  model.fit(df_scaled)\n  inertia.append(model.inertia_)\n\nplt.plot(cluster_range,inertia,marker = 'o')","5acfcaac":"kmeans = KMeans(n_clusters=3,random_state=2)\nkmeans.fit(df_scaled)\ndf2['class'] = kmeans.labels_\ndf2","7591e881":"sns.pairplot(df2,hue = 'class')","ffd34852":"from mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure(figsize=(10,8))\nax = Axes3D(fig,rect = [0,0,1,1],elev = 10,azim = 120)\nlabels = kmeans.labels_\nax.scatter(df_scaled.iloc[:,0],df_scaled.iloc[:,2],df_scaled.iloc[:,3],c = labels.astype(np.float),edgecolor = 'k')\nax.w_xaxis.set_ticklabels([])\nax.w_yaxis.set_ticklabels([])\nax.w_zaxis.set_ticklabels([])\nax.set_xlabel('Sepal Length')\nax.set_ylabel('Petal Length')\nax.set_zlabel('Petal Width')\nax.set_title('3D plot for KMeans Clustering')","9664674f":"### ***KMeans Clustering algorithm implementation using euclidean distance***","fd2174bc":"### ***As we can see, we get the minimum total inertia for group1 or group3 centroids(32.9899). So we can select any one of the two groups as our final model.***","3834242a":"# **KMeans on real dataset**","93d3de82":"The 3 best features which we can see from the pairplot for evidently separating the classes are sepal_length, petal_length and petal_width. So we will see the representation of this data in a 3D plot.","a9dd82ee":"1. Group1:\n * c1 -> ( 4.5 , 6 )\n * c2 -> ( 8.8 , 7 )\n2. Group2:\n * c1 -> ( 6 , 5.2 )\n * c2 -> ( 6.1 , 8 )\n3. Group3:\n * c1 -> ( 4.5 , 6 )\n * c2 -> ( 10 , 5.8 )\n4. Group4:\n * c1 -> ( 6.1 , 8 )\n * c2 -> ( 6 , 5.2 )\n5. Group5:\n * c1 -> ( 8.8 , 7 )\n * c2 -> ( 11.8 , 4.2 )\n6. Group6:\n * c1 -> ( 6 , 5.2 )\n * c2 -> ( 11.8 , 4.2 )","7c9d57f2":"# **KMeans Clustering**\n![alt text](https:\/\/jhui.github.io\/assets\/ml\/kmeans.png)\n\n#### Visualization link : https:\/\/www.naftaliharris.com\/blog\/visualizing-k-means-clustering\/\n\nK-Means starts by randomly defining k centroids. From there, it works in iterative (repetitive) steps to perform two tasks:\n\n1. Assign each data point to the closest corresponding centroid, using the any of the above distance measure.\n2. For each centroid, calculate the mean of the values of all the points belonging to it. The mean value becomes the new value of the centroid.\n\nOnce step 2 is complete, all of the centroids have new values that correspond to the means of all of their corresponding points. These new points are put through steps *1* and *2* producing yet another set of centroid values. This process is repeated over and over until there is no change in the centroid values, meaning that they have been accurately grouped. Or, the process can be stopped when a previously determined maximum number of steps has been met.\n\nNow the problem is that, if any other random centroids were selected, the clusters could have been completely different. For this purpose, we pass an argument \"n_init\" to the algorithm so that it selects different combinations of random values as starting centroid points and gives us the best starting centroid combination depending on the **minimum value of inertia\/within-cluster sum-of-squares**.\n\n***INERTIA :*** \n\n![alt text](https:\/\/i.ibb.co\/kKctMzj\/Capture1.png)\n\nInertia is calculated by taking the sum of squares of distance of each data point from the centroid value.","300f52ad":"# **Distance for continous values :** \n\n1. Euclidean Distance = np.sqrt( (a1-b1)^2 + (a2-b2)^2 )\n2. Manhattan distance = np.abs(a1-b1) + np.abs(a2-b2)\n3. Cosine Distance = 1 - [ ( (a1xb1)+(a2xb2) ) \/ ( np.sqrt(a1^2 + a2^2) x np.sqrt(b1^2 + b2^2) ) ]\n#### ***Cosine distance = 1 - Cosine_Similarity***\n![alt text](https:\/\/neo4j.com\/docs\/graph-algorithms\/current\/images\/cosine-similarity.png)\n\n*Distance based models should involve mandatory scaling of data.*\n\nA general thumbrule for scaling - \n\n1. Use \"StandardScalar\/zscore\" when majority of our data is continous.\n  *  Range of \"StandardScalar\/zscore\" is between **-3 to +3**.\n  *  StandardScalar\/zscore = (Value - mean_data)\/std_data\n2. Use \"MinMaxScalar\" when majority of our data is categorical or there are a 50% continous and 50% categorical variables.\n  *  Range of \"MinMaxScalar\" is between **0 to +1**.\n  *  MinMaxScalar = (Value - min_value)\/(max_val - min_val)\n3. \"MaxNormalization\" is generally used to scale pixel of image data (Convert from 0-255 grayscale to 0-1 scale)\n  *  Range of \"MaxNormalization\" is between **minimum_value to +1**.\n  *  StandardScalar\/zscore = Value\/max_val\n","457b1ee9":"# KMeans on Iris Dataset","9e9f8f4b":"As the slope starts becoming constant after k = 3, we will choose value of k as 3 for our kmeans modelling.","3bfd3c5e":"***Please UpVote if you like the work!!!***","e8022fe3":"\nAs we can see, at k = 3, the inertia values starts reducing at a constant rate. So we select k = 3 and build our kmeans model.","b22d2950":"### Elbow Plot\n\n![alt text](https:\/\/miro.medium.com\/proxy\/0*jWe7Ns_ubBpOaemM.png)\n\nTo determine the optimal number of clusters, we have to select the value of k at the \u201celbow\u201d ie the point after which the distortion\/inertia start decreasing in a linear fashion.","c7271314":"***Please UpVote if you like the work!!!***","fa563b2f":"Looking at the pairplot above we can see that we have 3 different classes, where class 1 represents INFANT, class 0 represents FEMALES and class 2 represents the MALES.","8e4ecf8c":"# **Distance for Categorical values :**\n\n1. ***Jaccard distance = 1 - Jaccard_Similarity***\n\nAssume we have two vectors A and B. To calculate the Jaccard similarity we use the following formula:\n\nJaccard similarity = M11 \/ ( M01 + M10 + M11 )\n\nIn other words, the Jaccard similarity coefficient measures the number of attributes where A and B are both 1, divided by the number of attributes where A and B are dissimilar, plus the number of attributes where they are both 1.\n\n**Jaccard distance = 1 - M11 \/ ( M01 + M10 + M11 )\n = (M01 + M10) \/ ( M01 + M10 + M11 )**\n"}}