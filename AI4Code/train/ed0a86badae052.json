{"cell_type":{"b74d67d7":"code","0dd1932c":"code","772f3536":"code","d7972501":"code","51c40fbc":"code","d2290366":"code","712e02da":"code","2828ebb7":"code","da7fac90":"code","ff7af36f":"code","2bb9262c":"code","2a74b50a":"code","c94fc8e3":"code","d5c32bd2":"code","44a653cc":"code","f9d4b093":"code","9b1a9aae":"code","13605d9c":"code","1e2c966c":"code","670bbc12":"code","3f8c4ddb":"code","51b941c1":"code","c74eb0f8":"code","ba863137":"code","c8015f63":"code","ebfb16b8":"code","25a70ab5":"code","9c56e61a":"code","d0435772":"code","fa71a70a":"code","c36715e9":"code","90ea9114":"code","49244752":"code","c727d435":"code","b66eff6b":"code","2a3e6095":"markdown","1ca5cd32":"markdown"},"source":{"b74d67d7":"!cp -r ..\/input\/mask-rcnn\/Mask_RCNN-master\/* .\/","0dd1932c":"import numpy as np\nimport pandas as pd\nimport pydicom\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport os\nimport sys\nimport math\nfrom tqdm import tqdm\nimport seaborn as sns\nimport random\n\nimport cv2\nfrom mrcnn.config import Config\nfrom mrcnn import model as modellib\nfrom mrcnn import visualize\nfrom mrcnn import utils\nfrom mrcnn.model import log\n\nimport tensorflow as tf\nimport keras","772f3536":"tf.__version__","d7972501":"tf.test.is_gpu_available()","51c40fbc":"dirname = '..\/input\/rsna-pneumonia-detection-challenge\/'\ntrain = pd.read_csv(dirname+'stage_2_train_labels.csv')\n#train.fillna(value=-1, inplace=True)\nprint(train.head())\nprint(train.describe())\n#print(train.isnull())","d2290366":"pneumonia_locations = {}\ntrain_images = []\ntarget = []\nfor i in range(len(train)):\n    n = str(dirname + 'stage_2_train_images\/' + train['patientId'][i] + '.dcm')\n    if n not in train_images:\n        train_images.append(n)\n        target.append(train['Target'][i])\n    if train['Target'][i]==1:\n        loc = [int(train['x'][i]), int(train['y'][i]),\n               int(train['width'][i]), int(train['height'][i])]\n        if n in pneumonia_locations:\n            pneumonia_locations[n].append(loc)\n        else:\n            pneumonia_locations[n] = [loc]\ntrain_images = pd.DataFrame(train_images)\ntrain_images.columns = ['filepath']\ntrain_images['Target'] = target","712e02da":"del train\nprint(train_images.head())\nlen(train_images)","2828ebb7":"X = list(train_images['filepath'])\nrandom.seed(42)\nrandom.shuffle(X)\nl = int(0.2*len(X))\ntrain_X = X[l:]\nval_X =X[:l]","da7fac90":"print(len(train_X))\nprint(len(val_X))","ff7af36f":"sns.countplot(train_images.Target)","2bb9262c":"i=0\nln = []\nfor item in pneumonia_locations:\n    ln.append(len(pneumonia_locations[item]))\n    i+=1\nsns.countplot(ln)","2a74b50a":"%%time\nim = (pydicom.dcmread(train_images['filepath'][0]).pixel_array)\nplt.imshow(im)\nplt.show()","c94fc8e3":"fig = plt.figure(figsize = (15,10))\ncolumns = 5\nrows = 2\nfor i in [0,1]:\n    df = train_images[train_images['Target']==i].sample(5)\n    df = list(df['filepath'])\n    for j in range(5):\n        fig.add_subplot(rows, columns, i*columns + j +1)\n        plt.imshow((pydicom.dcmread(df[j]).pixel_array)) #cmap = plt.cm.bone\n    del df","d5c32bd2":"f, axarr = plt.subplots(2, 5, figsize=(20, 15))\naxarr = axarr.ravel()\naxidx = 0\ndf1 = train_images[train_images['Target']==0].sample(5)\ndf2 = train_images[train_images['Target']==1].sample(5)\ndf = np.concatenate((np.array(df1['filepath']),np.array(df2['filepath'])),axis=0)\ndf = list(df)\nfor i in range(len(df)):\n    axarr[axidx].imshow(pydicom.dcmread(df[i]).pixel_array)\n    if df[i] in pneumonia_locations:\n        l = pneumonia_locations[df[i]]\n        for j in l:\n            axarr[axidx].add_patch(patches.Rectangle((j[0], j[1]), j[2], j[3], linewidth=2, edgecolor='b', facecolor='none'))\n    axidx+=1\nplt.show()","44a653cc":"class PneumoniaConfig(Config):\n    NAME = 'Pneumonia'\n    \n    GPU_COUNT = 1\n    IMAGES_PER_GPU = 8\n    \n    BACKBONE = 'resnet50'\n    \n    NUM_CLASSES = 2  # background + 1 pneumonia classes\n    \n    IMAGE_MIN_DIM = 256\n    IMAGE_MAX_DIM = 256\n    RPN_ANCHOR_SCALES = (16, 32, 64, 128, 256)\n    TRAIN_ROIS_PER_IMAGE = 32\n    MAX_GT_INSTANCES = 4\n    DETECTION_MAX_INSTANCES = 3\n    DETECTION_MIN_CONFIDENCE = 0.78  ## match target distribution\n    DETECTION_NMS_THRESHOLD = 0.01\n\n    STEPS_PER_EPOCH = 200\n\nconfig = PneumoniaConfig()\nconfig.display()","f9d4b093":"class DatasetGenerator(utils.Dataset):\n    \n    def __init__(self, fp, pneumonia_locations=None, batch_size=32, image_size=1024, predict=False):\n        super().__init__(self)\n        self.fp = fp\n        self.pneumonia_locations = pneumonia_locations\n        self.batch_size = batch_size\n        self.image_size = image_size\n        self.predict = predict\n        \n        self.add_class('Pneumonia', 1, 'pneumonia')\n        for id, fps in enumerate(fp):\n            self.add_image('Pneumonia',image_id=id,\n                          path =fps)\n        \n    def load_mask(self, image_id):\n        info = self.image_info[image_id]\n        fps = info['path']\n        if fps in self.pneumonia_locations:\n            l = self.pneumonia_locations[fps]\n            mask = np.zeros((self.image_size, self.image_size, len(l)), dtype=np.uint8)\n            class_ids = np.zeros((len(l),), dtype=np.int32)\n            i=0\n            for a in l:\n                x=int(a[0])\n                y=int(a[1])\n                w=int(a[2])\n                h=int(a[3])\n                mask_instance = mask[:,:,i].copy()\n                cv2.rectangle(mask_instance, (x,y), (x+w,y+h), 255, -1)\n                mask[:,:,i] = mask_instance\n                class_ids[i] = 1\n                i+=1\n        else:\n            mask = np.zeros((self.image_size, self.image_size, 1), dtype=np.uint8)\n            class_ids = np.zeros((1,), dtype=np.int32)\n        return mask.astype(np.bool), class_ids.astype(np.int32)\n    \n    def load_image(self, image_id):\n        info = self.image_info[image_id]\n        fps = info['path']\n        image = pydicom.dcmread(fps).pixel_array\n        if len(image.shape) != 3 or image.shape[2] != 3:\n            image = np.stack((image,) * 3, -1)\n        return image\n    \n    def image_reference(self, image_id):\n        info = self.image_info[image_id]\n        return info['path']","9b1a9aae":"train_gen = DatasetGenerator(train_X, pneumonia_locations)\ntrain_gen.prepare()\n\nval_gen = DatasetGenerator(val_X, pneumonia_locations)\nval_gen.prepare()","13605d9c":"# Load and display random samples\nimage_ids = np.random.choice(train_gen.image_ids,5)\nfor image_id in image_ids:\n    image = train_gen.load_image(image_id)\n    mask, class_ids = train_gen.load_mask(image_id)\n    visualize.display_top_masks(image, mask, class_ids, \n                                train_gen.class_names, limit=1)\n    print(mask.shape)\n    print(image.shape)","1e2c966c":"# Load random image and mask.\nimage_id = np.random.choice(train_gen.image_ids, 1)[0]\nimage = train_gen.load_image(image_id)\nmask, class_ids = train_gen.load_mask(image_id)\n\n# Compute Bounding box\nbbox = utils.extract_bboxes(mask)\n\n# Display image and instances\nvisualize.display_instances(image, bbox, mask, class_ids, \n                            train_gen.class_names)","670bbc12":"def model_definition():\n    print(\"loading mask R-CNN model\")\n    model = modellib.MaskRCNN(mode='training', \n                              config=config, \n                              model_dir='\/kaggle\/working')\n    \n    # load the weights for COCO\n    model.load_weights('\/kaggle\/input' + '\/cocowg\/mask_rcnn_coco.h5',\n                       by_name=True, \n                       exclude=[\"mrcnn_class_logits\",\n                                \"mrcnn_bbox_fc\",  \n                                \"mrcnn_bbox\",\"mrcnn_mask\"])\n    return model   \n\nmodel = model_definition()","3f8c4ddb":"from keras.callbacks import (ModelCheckpoint, ReduceLROnPlateau, CSVLogger)\n\ndef callback():\n    cb = []\n    checkpoint = ModelCheckpoint('\/kaggle\/working'+'\/pneumonia_wg.h5',\n                                 save_best_only=True,\n                                 mode='min',\n                                 monitor='val_loss',\n                                 save_weights_only=True, verbose=1)\n    cb.append(checkpoint)\n    reduceLROnPlat = ReduceLROnPlateau(monitor='val_loss',\n                                   factor=0.3, patience=5,\n                                   verbose=1, mode='auto',\n                                   epsilon=0.0001, cooldown=1, min_lr=0.00001)\n    log = CSVLogger('\/kaggle\/working'+'\/pneumonia_history.csv')\n    cb.append(log)\n    cb.append(reduceLROnPlat)\n    return cb","51b941c1":"import warnings \nwarnings.filterwarnings(\"ignore\")","c74eb0f8":"CB = callback()\nLEARNING_RATE = 0.006\n\nmodel.train(train_gen, val_gen, \n                learning_rate=LEARNING_RATE*2,\n                custom_callbacks = CB,\n                epochs=2, layers='all') ","ba863137":"history = model.keras_model.history.history","c8015f63":"CB = callback()\nLEARNING_RATE = 0.006\n\nmodel.train(train_gen, val_gen, \n                learning_rate=LEARNING_RATE,\n                custom_callbacks = CB,\n                epochs=6, layers='heads') ","ebfb16b8":"new_history = model.keras_model.history.history\nfor k in new_history: history[k] = history[k] + new_history[k]","25a70ab5":"# CB = callback()\n# LEARNING_RATE = 0.006\n\n# model.train(train_gen, val_gen, \n#                 learning_rate=LEARNING_RATE,\n#                 custom_callbacks = CB,\n#                 epochs=18, layers='all')","9c56e61a":"# new_history = model.keras_model.history.history\n# for k in new_history: history[k] = history[k] + new_history[k]","d0435772":"epochs = range(1,len(next(iter(history.values())))+1)\npd.DataFrame(history, index=epochs)","fa71a70a":"plt.figure(figsize=(17,5))\n\nplt.subplot(131)\nplt.plot(epochs, history[\"loss\"], label=\"Train loss\")\nplt.plot(epochs, history[\"val_loss\"], label=\"Valid loss\")\nplt.legend()\nplt.subplot(132)\nplt.plot(epochs, history[\"mrcnn_class_loss\"], label=\"Train class ce\")\nplt.plot(epochs, history[\"val_mrcnn_class_loss\"], label=\"Valid class ce\")\nplt.legend()\nplt.subplot(133)\nplt.plot(epochs, history[\"mrcnn_bbox_loss\"], label=\"Train box loss\")\nplt.plot(epochs, history[\"val_mrcnn_bbox_loss\"], label=\"Valid box loss\")\nplt.legend()\n\nplt.show()","c36715e9":"class InferenceConfig(PneumoniaConfig):\n    GPU_COUNT = 1\n    IMAGES_PER_GPU = 1\n    \ninferconfig = InferenceConfig()\nmodel = modellib.MaskRCNN(mode='inference', \n                              config=inferconfig,\n                              model_dir='\/kaggle\/working')\nmodel.load_weights('\/kaggle\/working\/pneumonia_wg.h5',\n                  by_name = True)","90ea9114":"test = []\nfor dname, _, filenames in os.walk('\/kaggle\/input\/rsna-pneumonia-detection-challenge\/stage_2_test_images\/'):\n    for filename in filenames:\n        test.append(str(os.path.join(dname, filename)))\nprint(test[:5])","49244752":"def predict(fp, filepath='submission.csv', min_conf=0.95):\n    with open(filepath, 'w') as file:\n        resize_factor = 1024\/ config.IMAGE_SHAPE[0]\n        \n        file.write(\"patientId,PredictionString\\n\")\n\n        for image_id in tqdm(fp):\n            image = pydicom.read_file(image_id).pixel_array\n            # If grayscale. Convert to RGB for consistency.\n            if len(image.shape) != 3 or image.shape[2] != 3:\n                image = np.stack((image,) * 3, -1)\n            image, window, scale, padding, crop = utils.resize_image(\n                image,\n                min_dim=config.IMAGE_MIN_DIM,\n                min_scale=config.IMAGE_MIN_SCALE,\n                max_dim=config.IMAGE_MAX_DIM,\n                mode=config.IMAGE_RESIZE_MODE)\n\n            patient_id = os.path.splitext(os.path.basename(image_id))[0]\n\n            results = model.detect([image])\n            r = results[0]\n\n            out_str = \"\"\n            out_str += patient_id\n            out_str += \",\"\n            assert( len(r['rois']) == len(r['class_ids']) == len(r['scores']) )\n            if len(r['rois']) == 0:\n                pass\n            else:\n                num_instances = len(r['rois'])\n\n                for i in range(num_instances):\n                    if r['scores'][i] > min_conf:\n                        out_str += ' '\n                        out_str += str(round(r['scores'][i], 2))\n                        out_str += ' '\n\n                        # x1, y1, width, height\n                        x1 = r['rois'][i][1]\n                        y1 = r['rois'][i][0]\n                        width = r['rois'][i][3] - x1\n                        height = r['rois'][i][2] - y1\n                        bboxes_str = \"{} {} {} {}\".format(x1*resize_factor, y1*resize_factor, \\\n                                                           width*resize_factor, height*resize_factor)\n                        out_str += bboxes_str\n\n            file.write(out_str+\"\\n\")","c727d435":"submission = os.path.join('\/kaggle\/working', 'submission.csv')\npredict(test, filepath=submission)","b66eff6b":"submit = pd.read_csv(submission)\nsubmit.head(10)","2a3e6095":"[Reference notebook 1](https:\/\/www.kaggle.com\/ipythonx\/keras-global-wheat-detection-with-mask-rcnn\/data?select=mask_rcnn_coco.h5)\n\n[Reference notebook 2](https:\/\/www.kaggle.com\/hmendonca\/mask-rcnn-and-coco-transfer-learning-lb-0-155)\n\n[Matterport's implementation of Mask-RCNN](https:\/\/github.com\/matterport\/Mask_RCNN)","1ca5cd32":"# Inference"}}