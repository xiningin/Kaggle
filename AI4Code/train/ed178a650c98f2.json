{"cell_type":{"29411bbd":"code","5eb8381a":"code","8305679d":"code","f35ff64d":"code","62967fa5":"code","27cd3aca":"code","c2bfb8e5":"code","00f1f53c":"code","65a879ac":"code","32bfb1a3":"code","056b2f9e":"code","b6ef8862":"code","42431545":"code","c24fb3c1":"code","af85f436":"code","daea3b04":"code","d6f51897":"code","ced9cfea":"code","996ada41":"code","97427437":"code","44c0f1e0":"code","2779abee":"code","2f0a07e5":"code","6aef3352":"code","c139807f":"code","04987aeb":"code","ca61aebe":"code","e22938e6":"code","ae34df7b":"code","46bf4a7e":"code","be0d5627":"code","340c0ca5":"code","43accf3e":"code","fcb2c0a0":"code","959f18ca":"code","50cef7d3":"code","74be83b0":"code","ba5c95da":"code","015f30f1":"code","b1c3e3ea":"code","9af3f47b":"markdown","f29425d7":"markdown"},"source":{"29411bbd":"import os\nimport random\nimport pandas as pd\nimport numpy as np\nimport cv2\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom tqdm import tqdm\nfrom torchvision import datasets, transforms, models \nfrom torchvision.datasets import ImageFolder\nfrom torchvision.transforms import ToTensor\nfrom torchvision.utils import make_grid\nfrom torch.utils.data import random_split\nfrom torch.utils.data.dataloader import DataLoader\nimport matplotlib.pyplot as plt\n%matplotlib inline","5eb8381a":"data_dir = '..\/input\/tally-marks-dataset'","8305679d":"Name0 = os.listdir(data_dir)\nName=sorted(Name0)\nprint(Name)\nprint(len(Name))","f35ff64d":"N=list(range(len(Name)))    \nnormal_mapping=dict(zip(Name,N)) \nreverse_mapping=dict(zip(N,Name)) ","62967fa5":"dataset=[]\nfor i in tqdm(range(len(Name))):\n    path=os.path.join(data_dir,Name[i])\n    for im in os.listdir(path):          \n        labeli=normal_mapping[Name[i]]\n        img1=cv2.imread(os.path.join(path,im))\n        img2=cv2.resize(img1,dsize=(100,100),interpolation=cv2.INTER_CUBIC)\n        img3=img2.astype(np.float32)\n        image=torch.from_numpy(img3).permute(2,0,1) ###\n        dataset+=[[image,labeli]]","27cd3aca":"dataset[100]","c2bfb8e5":"# view one image shape of the dataset.\nimg, label = dataset[100]\nprint(img.shape)\nprint(label)","00f1f53c":"def show_image(img,label):\n    img2=img.permute(1,2,0).numpy().astype(int)\n    print(img2.shape)\n    print(reverse_mapping[label])\n    plt.imshow(img2)\n    #plt.imshow(cv2.cvtColor(img2,cv2.COLOR_BGR2RGB))","65a879ac":"show_image(*dataset[20])","32bfb1a3":"torch.manual_seed(20)\nval_size = len(dataset)\/\/10\ntest_size = len(dataset)\/\/5\ntrain_size = len(dataset) - val_size - test_size","056b2f9e":"train_ds, val_ds, test_ds = random_split(dataset, [train_size, val_size, test_size])\nlen(train_ds), len(val_ds), len(test_ds) ","b6ef8862":"batch_size = 64\ntrain_loader = DataLoader(train_ds, batch_size, shuffle=True, num_workers=4, pin_memory=True)\nval_loader = DataLoader(val_ds, batch_size, num_workers=4, pin_memory=True)\ntest_loader = DataLoader(test_ds, batch_size, num_workers=4, pin_memory=True)","42431545":"m=len(dataset)\nM=list(range(m))\nrandom.seed(2021)\nrandom.shuffle(M)","c24fb3c1":"dataset[0][0]","af85f436":"fig, axs = plt.subplots(4,4,figsize=(15,15))\nfor i in range(16):\n    r=i\/\/4\n    c=i%4\n    img, label = dataset[M[i]]\n    img2=img.permute(1,2,0).numpy().astype(int)\n    ax=axs[r][c].axis(\"off\")\n    ax=axs[r][c].set_title(reverse_mapping[label])\n    ax=axs[r][c].imshow(img2)\nplt.show()","daea3b04":"def accuracy(outputs, labels):\n    _, preds = torch.max(outputs, dim=1)\n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds))\n\nclass ImageClassificationBase(nn.Module):\n    def training_step(self, batch):\n        images, labels = batch \n        out = self(images)                  # Generate predictions\n        loss = F.cross_entropy(out, labels) # Calculate loss\n        return loss\n    \n    def validation_step(self, batch):\n        images, labels = batch \n        out = self(images)                    # Generate predictions\n        loss = F.cross_entropy(out, labels)   # Calculate loss\n        acc = accuracy(out, labels)           # Calculate accuracy\n        return {'val_loss': loss.detach(), 'val_acc': acc}\n        \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses\n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()      # Combine accuracies\n        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}\n    \n    def epoch_end(self, epoch, result):\n        print(\"Epoch [{}], train_loss: {:.4f}, val_loss: {:.4f}, val_acc: {:.4f}\".format(\n            epoch, result['train_loss'], result['val_loss'], result['val_acc']))","d6f51897":"def evaluate(model, val_loader):\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    history = []\n    optimizer = opt_func(model.parameters(), lr)\n    for epoch in range(epochs):\n        # Training Phase \n        model.train()\n        train_losses = []\n        for batch in tqdm(train_loader):\n            loss = model.training_step(batch)\n            train_losses.append(loss)\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n        # Validation phase\n        result = evaluate(model, val_loader)\n        result['train_loss'] = torch.stack(train_losses).mean().item()\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","ced9cfea":"torch.cuda.is_available()","996ada41":"def get_default_device():\n    \"\"\"Pick GPU if available, else CPU\"\"\"\n    if torch.cuda.is_available():\n        return torch.device('cuda')\n    else:\n        return torch.device('cpu')\n    \ndef to_device(data, device):\n    \"\"\"Move tensor(s) to chosen device\"\"\"\n    if isinstance(data, (list,tuple)):\n        return [to_device(x, device) for x in data]\n    return data.to(device, non_blocking=True)\n\nclass DeviceDataLoader():\n    \"\"\"Wrap a dataloader to move data to a device\"\"\"\n    def __init__(self, dl, device):\n        self.dl = dl\n        self.device = device\n        \n    def __iter__(self):\n        \"\"\"Yield a batch of data after moving it to device\"\"\"\n        for b in self.dl: \n            yield to_device(b, self.device)\n\n    def __len__(self):\n        \"\"\"Number of batches\"\"\"\n        return len(self.dl)","97427437":"device = get_default_device()\ndevice","44c0f1e0":"train_loader = DeviceDataLoader(train_loader, device)\nval_loader = DeviceDataLoader(val_loader, device)\ntest_loader = DeviceDataLoader(test_loader, device)","2779abee":"m=len(dataset)\nM=list(range(m))\nrandom.seed(2021)\nrandom.shuffle(M)","2f0a07e5":"input_size = 3*100*100\noutput_size = len(Name)","6aef3352":"def accuracy(outputs, labels):\n    _, preds = torch.max(outputs, dim=1)\n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds))\n\nclass ImageClassificationBase(nn.Module):\n    def training_step(self, batch):\n        images, labels = batch \n        out = self(images)                   # Generate predictions\n        loss = F.cross_entropy(out, labels)  # Calculate loss\n        return loss\n    \n    def validation_step(self, batch):\n        images, labels = batch \n        out = self(images)                    # Generate predictions\n        loss = F.cross_entropy(out, labels)   # Calculate loss\n        acc = accuracy(out, labels)           # Calculate accuracy\n        return {'val_loss': loss.detach(), 'val_acc': acc}\n        \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses\n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()      # Combine accuracies\n        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}\n    \n    def epoch_end(self, epoch, result):\n        print(\"Epoch [{}], train_loss: {:.4f}, val_loss: {:.4f}, val_acc: {:.4f}\".format(\n            epoch, result['train_loss'], result['val_loss'], result['val_acc']))","c139807f":"class CnnModel(ImageClassificationBase):\n    def __init__(self):\n        super().__init__()\n        self.network = nn.Sequential(\n            nn.Conv2d(3, 100, kernel_size=3, padding=1),\n            nn.ReLU(),\n            nn.Conv2d(100, 150, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(2, 2),\n\n            nn.Conv2d(150, 200, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.Conv2d(200, 200, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(2, 2),\n\n            nn.Conv2d(200, 250, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.Conv2d(250, 250, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(2, 2),\n\n            nn.Flatten(), \n            nn.Linear(36000, 6400),  \n            nn.ReLU(),            \n            nn.Linear(6400, 640),  \n            nn.ReLU(),\n            nn.Linear(640, 64),  \n            nn.ReLU(),\n            nn.Dropout(0.25),\n            nn.Linear(64, output_size))\n        \n    def forward(self, xb):\n        return self.network(xb)","04987aeb":"model = CnnModel()\n#model.cuda()\n#model","ca61aebe":"for images, labels in train_loader:\n    print('images.shape:', images.shape)    \n    out = model(images)      \n    print('out.shape:', out.shape)\n    break","e22938e6":"device = get_default_device()\ndevice","ae34df7b":"train_dl = DeviceDataLoader(train_loader, device)\nval_dl = DeviceDataLoader(val_loader, device)\nto_device(model, device)","46bf4a7e":"@torch.no_grad()\ndef evaluate(model, val_loader):\n    model.eval()\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    history = []\n    optimizer = opt_func(model.parameters(), lr)\n    for epoch in range(epochs):\n        # Training Phase \n        model.train()\n        train_losses = []\n        for batch in tqdm(train_loader):\n            loss = model.training_step(batch)\n            train_losses.append(loss)\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n        # Validation phase\n        result = evaluate(model, val_loader)\n        result['train_loss'] = torch.stack(train_losses).mean().item()\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","be0d5627":"model = to_device(CnnModel(), device)","340c0ca5":"history=[evaluate(model, val_loader)]\nhistory","43accf3e":"num_epochs = 10\nopt_func = torch.optim.Adam\nlr = 0.005","fcb2c0a0":"history+= fit(num_epochs, lr, model, train_dl, val_dl, opt_func)","959f18ca":"history+= fit(num_epochs, lr\/10, model, train_dl, val_dl, opt_func)","50cef7d3":"def plot_accuracies(history):\n    accuracies = [x['val_acc'] for x in history]\n    plt.plot(accuracies, '-x')\n    plt.xlabel('epoch')\n    plt.ylabel('accuracy')\n    plt.title('Accuracy vs. No. of epochs')\n    plt.show()\n    \ndef plot_losses(history):\n    train_losses = [x.get('train_loss') for x in history]\n    val_losses = [x['val_loss'] for x in history]\n    plt.plot(train_losses, '-bx')\n    plt.plot(val_losses, '-rx')\n    plt.xlabel('epoch')\n    plt.ylabel('loss')\n    plt.legend(['Training', 'Validation'])\n    plt.title('Loss vs. No. of epochs')\n    plt.show()","74be83b0":"plot_accuracies(history)","ba5c95da":"plot_losses(history)","015f30f1":"evaluate(model, test_loader)","b1c3e3ea":"from sklearn.metrics import classification_report\n\npred = []\nY = []\nfor i, (x,y) in enumerate(test_loader):\n    with torch.no_grad():\n        outputs = model(x)\n    pred += [int(op.argmax()) for op in outputs]\n    Y += [int(yi) for yi in y]\n\nprint(classification_report(Y, pred))","9af3f47b":"# Conv2d Model","f29425d7":"# Tally Marks Classify Torch Conv2d"}}