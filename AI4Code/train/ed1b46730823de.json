{"cell_type":{"1958b28f":"code","a896425a":"code","952afd77":"code","16b5e388":"code","f364310f":"code","623ff90f":"code","5a8e8ee1":"code","6f971560":"code","c5c357ab":"code","e3eea5ad":"code","01de12db":"code","196fbc68":"code","e41c73af":"code","5ce30e2f":"code","d8c062eb":"code","4a018cc4":"code","61aefb92":"markdown","8f762cad":"markdown","20b866fa":"markdown","577ca858":"markdown","0b38c2ed":"markdown"},"source":{"1958b28f":"import cv2\nimport numpy as np\nimport os\n#from random import shuffle\nfrom sklearn.utils import shuffle\nfrom random import randint\n\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D,MaxPooling2D,Activation, Flatten,Dense,BatchNormalization,Dropout\n\nimport matplotlib.pyplot as plt","a896425a":"classes=os.listdir('..\/input\/seg_train\/seg_train\/')\n\n#making a dictionary which maps class label to value.\n# 0 for Building , 1 for forest, 2 for glacier, 3 for mountain, 4 for Sea , 5 for Street\nlabel={}\nfor instance in classes:\n    if instance== 'forest': label[instance]=1\n    elif instance== 'buildings': label[instance]=0\n    elif instance== 'glacier': label[instance]=2\n    elif instance== 'mountain': label[instance]=3\n    elif instance== 'sea': label[instance]=4\n    elif instance== 'street': label[instance]=5\n\n","952afd77":"def get_classlabel(class_code):\n    labels = {2:'glacier', 4:'sea', 0:'buildings', 1:'forest', 5:'street', 3:'mountain'}\n    return labels[class_code]","16b5e388":"#assign every image a label according to its class.\n\nimg_size=150\n\ndef data_making(directory):\n    \n    data,labels=[],[]\n    for folder in os.listdir(directory):\n        path=os.path.join(directory,folder)\n        \n        for img in os.listdir(path):\n            \n            path_img=os.path.join(path,img)\n            \n            img_label=label[folder] #previously label_onehot was there. \n            \n            img_data=cv2.resize(cv2.imread(path_img),(img_size,img_size)) #reading in bgr format. if need be use ,cv2.IMREAD_GRAYSCALE to read image in gray scale\n            \n            data.append((img_data))\n            labels.append((img_label))\n    \n    \n    \n    #shuffle data \n    shuffle(data,labels,random_state=817328462)\n    return data,labels","f364310f":"train_Images, train_Labels = data_making('..\/input\/seg_train\/seg_train\/') #Extract the training images from the folders.\n\ntrain_Images = np.array(train_Images) #converting the list of images to numpy array.\ntrain_Labels = np.array(train_Labels)\n","623ff90f":"test_Images, test_Labels = data_making('..\/input\/seg_test\/seg_test\/') #Extract the testing images from the folders.\n\ntest_Images = np.array(test_Images) #converting the list of images to numpy array.\ntest_Labels = np.array(test_Labels)","5a8e8ee1":"f,ax = plt.subplots(4,4) \nf.subplots_adjust(0,0,3,3)#(left,bottom,vertical_distance b\/w columns,)\nfor i in range(0,4,1):\n    for j in range(0,4,1):\n        rnd_number = randint(0,len(train_Images))\n        ax[i,j].imshow(train_Images[rnd_number])\n        ax[i,j].set_title(get_classlabel(train_Labels[rnd_number]))\n        ax[i,j].axis('off')\n        \n","6f971560":"model1=Sequential()\n\nmodel1.add(Conv2D(256,(5,5),input_shape=train_Images.shape[1:]))\nmodel1.add(Activation(\"relu\"))\nmodel1.add(BatchNormalization(axis=-1, momentum=0.99, epsilon=0.001))\nmodel1.add(MaxPooling2D(pool_size=(2,2)))\nmodel1.add(Dropout(0.5, noise_shape=None, seed=None))\n\nmodel1.add(Conv2D(180,(3,3)))\nmodel1.add(Activation(\"relu\"))\nmodel1.add(BatchNormalization(axis=-1, momentum=0.99, epsilon=0.001))\nmodel1.add(MaxPooling2D(pool_size=(2,2)))\nmodel1.add(Dropout(0.5, noise_shape=None, seed=None))\n\nmodel1.add(Conv2D(140,(3,3)))\nmodel1.add(Activation(\"relu\"))\nmodel1.add(BatchNormalization(axis=-1, momentum=0.99, epsilon=0.001))\nmodel1.add(MaxPooling2D(pool_size=(2,2)))\nmodel1.add(Dropout(0.3, noise_shape=None, seed=None))\n\nmodel1.add(Conv2D(120,(3,3)))\nmodel1.add(Activation(\"relu\"))\nmodel1.add(BatchNormalization(axis=-1, momentum=0.99, epsilon=0.001))\nmodel1.add(MaxPooling2D(pool_size=(2,2)))\nmodel1.add(Dropout(0.3, noise_shape=None, seed=None))\n\n\nmodel1.add(Conv2D(96,(3,3)))\nmodel1.add(Activation(\"relu\"))\nmodel1.add(BatchNormalization(axis=-1, momentum=0.99, epsilon=0.001))\nmodel1.add(MaxPooling2D(pool_size=(2,2)))\nmodel1.add(Dropout(0.3, noise_shape=None, seed=None))\n\nmodel1.add(Flatten())\n\nmodel1.add(Dense(128))\nmodel1.add(Activation(\"relu\"))\n\nmodel1.add(Dense(128))\nmodel1.add(Activation(\"relu\"))\n\nmodel1.add(Dense(6))\nmodel1.add(Activation(\"softmax\"))\n\nmodel1.compile(loss='sparse_categorical_crossentropy',optimizer='adam',metrics=['accuracy'])\n#using categorical_crossentropy you have to convert the labels into one hot functions.........\n#better option is to use `sparse_categorical_crossentropy`\n\n","c5c357ab":"model1.summary()","e3eea5ad":"history=model1.fit(train_Images,train_Labels,batch_size=64,validation_split=0.1,epochs=17)","01de12db":"train_loss=history.history[\"loss\"]\nval_loss=history.history[\"val_loss\"]\n\nepoch_count=range(1,len(val_loss)+1)\n","196fbc68":"plt.plot(epoch_count,train_loss,'r--')\nplt.plot(epoch_count,val_loss,'b-')\nplt.legend([\"train loss\",\"val loss\"])\nplt.xlabel(\"epoch\")\nplt.ylabel(\"loss\")\nplt.show()","e41c73af":"model1.evaluate(test_Images,test_Labels,verbose=1)","5ce30e2f":"def data_making_for_prediction(directory):\n    \n    data=[]\n    for img in os.listdir(directory):\n            \n        path_img=os.path.join(directory,img)\n        img_data=cv2.resize(cv2.imread(path_img),(img_size,img_size)) #reading in bgr format. if need be use ,cv2.IMREAD_GRAYSCALE to read image in gray scale\n            \n        data.append((img_data))\n    \n    \n    \n    #shuffle data \n    shuffle(data)\n    return data","d8c062eb":"pred_Images=data_making_for_prediction('..\/input\/seg_pred\/seg_pred')\npred_Images = np.array(pred_Images) #converting the list of images to numpy array.\n","4a018cc4":"f,ax = plt.subplots(2,2) \nf.subplots_adjust(0,0,3,3)#(left,bottom,vertical_distance b\/w columns,)\nfor i in range(0,2,1):\n    for j in range(0,2,1):\n        rnd_number = randint(0,len(pred_Images))\n        ax[i,j].imshow(pred_Images[rnd_number])\n        ax[i,j].set_title(get_classlabel(model1.predict_classes(np.array(pred_Images[rnd_number]).reshape(-1,150,150,3))[0]))\n        ax[i,j].axis('off')","61aefb92":"a function to get  class label when class value is given to it....useful in visualizing prediction from the model.","8f762cad":"select epoch where we get highest val_accuracy and lowest val_loss.........train till there and make predictions to get better scores...... ","20b866fa":"import the required libraries to run this code.....","577ca858":"finally lets see how our model predicts...................","0b38c2ed":"visualization of the train_data...."}}