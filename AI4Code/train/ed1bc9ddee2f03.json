{"cell_type":{"a5346393":"code","7ce0f9b6":"code","8ae1f87a":"code","b09b0a92":"code","c1254ee9":"code","3a48884e":"code","75836e4e":"code","920a8b07":"code","1abd4a94":"code","9fcddac4":"code","7cb8b8a4":"code","082f5404":"code","38e58b7f":"code","1e440012":"code","28cd926f":"markdown","4a8fe5b2":"markdown"},"source":{"a5346393":"import pandas as pd\nimport pathlib\nfrom tqdm.notebook import tqdm\nimport numpy as np\nimport matplotlib.pyplot as plt","7ce0f9b6":"df_train = pd.read_csv(\"..\/input\/google-smartphone-decimeter-challenge\/baseline_locations_train.csv\")\ndf_test = pd.read_csv(\"..\/input\/google-smartphone-decimeter-challenge\/baseline_locations_test.csv\")","8ae1f87a":"train_collectionName = df_train[\"collectionName\"].unique()","b09b0a92":"df_train_highway = df_train[df_train['collectionName'].isin([train_collectionName[0],\n                                                           train_collectionName[1],\n                                                           train_collectionName[2],\n                                                           train_collectionName[3],\n                                                           train_collectionName[4],\n                                                           train_collectionName[5],\n                                                           train_collectionName[6],\n                                                           train_collectionName[7],\n                                                           train_collectionName[8],\n                                                           train_collectionName[9],\n                                                           train_collectionName[10],\n                                                           train_collectionName[11],\n                                                           train_collectionName[12],\n                                                           train_collectionName[13],\n                                                           train_collectionName[14],\n                                                           train_collectionName[15],\n                                                           train_collectionName[16],\n                                                           train_collectionName[17],\n                                                           train_collectionName[18],\n                                                           train_collectionName[19],\n                                                           train_collectionName[20]])]","c1254ee9":"df_train_tree = df_train[df_train['collectionName'].isin([train_collectionName[21],\n                                                          train_collectionName[22],\n                                                          train_collectionName[24],\n                                                          train_collectionName[25],\n                                                          train_collectionName[27]])]","3a48884e":"df_train_downtown = df_train[df_train['collectionName'].isin([train_collectionName[23],\n                                                              train_collectionName[26],\n                                                              train_collectionName[28]])]","75836e4e":"# ground_truth\np = pathlib.Path(\"..\/input\/google-smartphone-decimeter-challenge\")\ngt_files = list(p.glob('train\/*\/*\/ground_truth.csv'))\nprint('ground_truth.csv count : ', len(gt_files))\n\ngts = []\nfor gt_file in tqdm(gt_files):\n    gts.append(pd.read_csv(gt_file))\nground_truth = pd.concat(gts)","920a8b07":"def calc_haversine(lat1, lon1, lat2, lon2):\n    \"\"\"Calculates the great circle distance between two points\n    on the earth. Inputs are array-like and specified in decimal degrees.\n    \"\"\"\n    RADIUS = 6_367_000\n    lat1, lon1, lat2, lon2 = map(np.radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n    a = np.sin(dlat\/2)**2 + \\\n        np.cos(lat1) * np.cos(lat2) * np.sin(dlon\/2)**2\n    dist = 2 * RADIUS * np.arcsin(a**0.5)\n    return dist","1abd4a94":"def percentile50(x):\n    return np.percentile(x, 50)\ndef percentile95(x):\n    return np.percentile(x, 95)","9fcddac4":"def get_train_score(df, gt):\n    gt = gt.rename(columns={'latDeg':'latDeg_gt', 'lngDeg':'lngDeg_gt'})\n    df = df.merge(gt, on=['collectionName', 'phoneName', 'millisSinceGpsEpoch'], how='inner')\n    # calc_distance_error\n    df['err'] = calc_haversine(df['latDeg_gt'], df['lngDeg_gt'], df['latDeg'], df['lngDeg'])\n    # calc_evaluate_score\n    df['phone'] = df['collectionName'] + '_' + df['phoneName']\n    res = df.groupby('phone')['err'].agg([percentile50, percentile95])\n    res['p50_p90_mean'] = (res['percentile50'] + res['percentile95']) \/ 2 \n    score = res['p50_p90_mean'].mean()\n    return score,df","7cb8b8a4":"score_highway,df_highway = get_train_score(df_train_highway, ground_truth)\nscore_tree,df_tree = get_train_score(df_train_tree, ground_truth)\nscore_downtown,df_downtown = get_train_score(df_train_downtown, ground_truth)","082f5404":"print(\"highway :\" , score_highway )\nprint('tree : ' ,score_tree)\nprint('downtown : ' , score_downtown)","38e58b7f":"c1,c2,c3 = \"blue\",\"green\",\"red\"\nfig, ax = plt.subplots(nrows=1, ncols=3,figsize = (25,5))\nax[0].hist(df_highway.err, bins=range(100), color=c1)\nax[0].set_title('highway')\nax[0].set_xlabel('error',fontsize = 20)\nax[0].set_ylabel('freq')\nax[0].set_ylim(0,30000)\nax[1].hist(df_tree.err, bins=range(100), color=c2)\nax[1].set_title('tree')\nax[1].set_xlabel('error',fontsize = 20)\nax[1].set_ylabel('freq')\nax[1].set_ylim(0,30000)\nax[2].hist(df_downtown.err, bins=range(100), color=c3)\nax[2].set_title('downtown')\nax[2].set_xlabel('error',fontsize = 20)\nax[2].set_ylabel('freq')\nax[2].set_ylim(0,30000)","1e440012":"fig = plt.figure(figsize = (10,5))\nplt.hist([df_highway.err,df_tree.err,df_downtown.err], stacked=True, bins=range(100),color=[c1,c2,c3], label=[\"highway\",\"tree\",\"downtown\"])\nplt.xlabel('error',fontsize = 15)\nplt.show()","28cd926f":"### We divided the data into three regions and evaluated them.\n\nUsing [this discussion](https:\/\/www.kaggle.com\/c\/google-smartphone-decimeter-challenge\/discussion\/245160) as a guide, we divided the data into three areas: highways, streets with trees, and city streets, and evaluated the training data in each area.\n\nThe results are as follows.\n\nhighway : 3.4528073895024414\n\ntree : 6.173261717576203\n\ndowntown : 19.432900281799608\n\nThank you for sharing this discusiion with us.\n\nhttps:\/\/www.kaggle.com\/c\/google-smartphone-decimeter-challenge\/discussion\/245160\n\nI used the following code as a reference for the evaluation script.\n\nThank you for sharing code with us.\n\nhttps:\/\/www.kaggle.com\/t88take\/gsdc-phones-mean-prediction#evaluate-train-score","4a8fe5b2":"**We can see that the data in the city is small in number but has a large error. In the evaluation of this competition, it may be effective to approach the data where the error is large even if the number is small.**"}}