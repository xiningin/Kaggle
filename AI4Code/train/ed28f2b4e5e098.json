{"cell_type":{"124a98f1":"code","c19a0ed9":"code","a9ff99f5":"code","e10d25cb":"code","e285e02e":"code","afc8f546":"code","60556250":"markdown","e2dfca1b":"markdown","6593b00f":"markdown"},"source":{"124a98f1":"import os\nimport sys\nimport random\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport cv2\nimport itertools\nfrom pathlib import Path\nfrom glob import glob\nfrom tqdm.notebook import tqdm\nfrom multiprocessing import Pool\n\nfrom scipy.optimize import minimize, minimize_scalar\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.neighbors import KDTree","c19a0ed9":"# Install helmet-assignment helper code\n!pip install ..\/input\/helmet-assignment-helpers\/helmet-assignment-main\/ > \/dev\/null 2>&1\nfrom helmet_assignment.score import NFLAssignmentScorer, check_submission\nfrom helmet_assignment.features import add_track_features","a9ff99f5":"# Config\nSEED = 42\nCONF_THRE = 0.30\nDIG_MAX = 30","e10d25cb":"def add_cols(df):\n    df['game_play'] = df['video_frame'].str.split('_').str[:2].str.join('_')\n    if not 'video' in df.columns:\n        df['video'] = df['video_frame'].str.split('_').str[:3].str.join('_') + '.mp4'\n    return df\n\n\n# path \nBASE_DIR = Path('..\/input\/nfl-health-and-safety-helmet-assignment')\nTRAIN_DIR = BASE_DIR \/ 'train'\nTEST_DIR = BASE_DIR \/ 'test'\nIMAGES_DIR = BASE_DIR \/ 'images'\n    \n# Reading data\nDEBUG = (len(glob(str(TEST_DIR \/ '*'))) == 6)\n\nif DEBUG:\n    tracking = pd.read_csv(BASE_DIR \/ 'train_player_tracking.csv')\n    helmets = pd.read_csv(BASE_DIR \/ 'train_baseline_helmets.csv')\nelse:\n    tracking = pd.read_csv(BASE_DIR \/ 'test_player_tracking.csv') \n    helmets = pd.read_csv(BASE_DIR \/ 'test_baseline_helmets.csv')\n    \nlabels = pd.read_csv(BASE_DIR \/ 'train_labels.csv')\nsub = pd.read_csv(BASE_DIR \/ 'sample_submission.csv')\n\n# processing data\ntracking = add_track_features(tracking)\nhelmets = add_cols(helmets)\nlabels = add_cols(labels)\n\n# sampling Data\nif DEBUG:\n    sample_videos = labels['video'].drop_duplicates().sample(1, random_state=42).tolist()\n    sample_gameplays = ['_'.join(x.split('_')[:2]) for x in sample_videos]\n    tracking = tracking[tracking['game_play'].isin(sample_gameplays)]\n    helmets = helmets[helmets['video'].isin(sample_videos)]\n    labels = labels[labels['video'].isin(sample_videos)]\n\nprint(tracking.shape, helmets.shape, labels.shape)","e285e02e":"def find_nearest(arr: np.array, value: int):\n    arr, value = arr.astype(int), int(value)\n    idx = np.abs(arr - value).argmin()\n    return arr[idx]\n\ndef normalize_arr(arr: np.array):\n    _mean = np.mean(arr, axis=0)\n    out_arr = arr - _mean\n    _norm = np.linalg.norm(out_arr)\n    out_arr = out_arr \/ _norm\n    return out_arr\n\ndef rotate_arr(u, t):\n    t = np.deg2rad(t)\n    R = np.array([\n        [np.cos(t), -np.sin(t)],\n        [np.sin(t),  np.cos(t)]\n    ])\n    return  np.dot(R, u.T).T\n\ndef mapping(h_arr: np.array, t_arr: np.array):\n    out_norm = float('INF')\n    out_idx = None\n    out_x = None\n    out_dig = None\n    \n    tree = KDTree(t_arr)\n    for i in range(len(t_arr)):\n        dist, idx = tree.query([t_arr[i]], k=len(h_arr))\n        idx = np.sort(idx[0])\n        norm_t_arr = normalize_arr(t_arr[idx])\n                \n        # minimization norm\n        def opt_rot(dig):\n            rot_t_arr = rotate_arr(norm_t_arr, dig)\n            return np.linalg.norm(np.sort(rot_t_arr[:, 0])-h_arr[:, 0])\n                \n        for bounds in [(-DIG_MAX , DIG_MAX), (180-DIG_MAX, 180+DIG_MAX)]:\n            result = minimize_scalar(opt_rot, bounds=bounds, method='bounded') \n            if out_norm > result.fun:\n                out_norm = result.fun\n                out_idx = idx\n                out_x = rotate_arr(norm_t_arr, result.x)[:, 0]\n                out_dig = result.x\n                \n    return out_idx, out_x\n\ndef main(args: pd.DataFrame):\n    video_frame, subhelmets = args\n    gameKey, playID, view, frame = video_frame.split('_')\n    gameKey, playID, frame = int(gameKey), int(playID), int(frame)\n\n    # get nearest-frame\n    _index = (tracking['gameKey']==gameKey) & (tracking['playID']==playID)\n    subtracking = tracking[_index].copy()\n    est_frame = find_nearest(subtracking[\"est_frame\"].values, frame)\n    subtracking = subtracking[subtracking['est_frame']==est_frame]\n    subtracking = subtracking.reset_index(drop=True)\n\n    if view == 'Endzone':\n        subtracking[['x', 'y']] = subtracking[['y', 'x']].values\n\n    # normalizing \n    subhelmets = subhelmets[subhelmets['conf']>CONF_THRE].copy()\n\n    if len(subhelmets) > len(subtracking):\n        subhelmets = subhelmets.tail(len(subtracking))\n\n    subhelmets['x'] = subhelmets['left'] + subhelmets['width'] \/\/ 2\n    subhelmets['y'] = subhelmets['top'] + subhelmets['height'] \/\/ 2\n    subhelmets[['norm_x', 'norm_y']] = normalize_arr(subhelmets[['x', 'y']].values)\n    subhelmets = subhelmets.sort_values('norm_x').reset_index(drop=True)\n\n    # mapping tracking2helmets\n    h_arr = subhelmets[['norm_x', 'norm_y']].values\n    t_arr = subtracking[['x', 'y']].values\n    out_idx, out_x = mapping(h_arr, t_arr)\n\n    # helmets labeling \n    players = subtracking['player'].tolist()\n    players = [p for i, p in enumerate(players) if i in out_idx]\n    _pred = pd.DataFrame({'label': players, 'x': out_x}).sort_values('x')['label']\n    subhelmets['label'] = _pred.values\n    \n    return subhelmets[['video_frame', 'left', 'width', 'top', 'height', 'label']]","afc8f546":"# multi processing\ndf_list = helmets.groupby('video_frame')\nsubmission_df = []\n\np = Pool(processes=4)\nwith tqdm(total=len(df_list)) as pbar:\n    for subdf in p.imap(main, df_list):\n        submission_df.append(subdf)\n        pbar.update(1)\np.close()\n\n# submission\nsubmission_df = pd.concat(submission_df).reset_index(drop=True)\nsubmission_df.to_csv('submission.csv', index=False)\n\nif DEBUG:\n    scorer = NFLAssignmentScorer(labels[labels['video_frame'].isin(submission_df['video_frame'].unique())])\n    score = scorer.score(submission_df)\n    print(f'score: {round(score, 5)}')","60556250":"## IMPORT MODULE & CONFIG","e2dfca1b":"## This notebook\n\nThis notebook is based on [NFL Baseline - Simple Helmet Mapping](https:\/\/www.kaggle.com\/its7171\/nfl-baseline-simple-helmet-mapping) by [tito](https:\/\/www.kaggle.com\/its7171).  \n\nThe major change is to select trackings according to the number of helmets.  \nIn tito's notebook, itertools.combinations was used to randomly select what not to use. There are some combinations that cannot be verified with this method. Another problem is that there is a trade-off between execution speed and accuracy.\n\nIn this implementation, the distance is measured between each player and the player with the close distance is selected. This probably improved the execution speed (The speed is almost 28 times faster!).\n\nThe reason why I decided on this idea is because I thought that what would fit in the picture would be a close distance between the players, and players who are far apart would not be captured in the first place. The implementation itself uses sklearn.neighbors.KDTree, but since this is the first time I have used it, there may be other better ways to handle it.\n\nThere are also some minor changes, such as using scipy.optimize.minimize_scalar to search for DIG, and the normalize_arr function is different.  \n\nBut I haven't tested which process is better, so if anyone has, I'd appreciate it if you'd share!\nIf you have any questions or suggestions for improvement, please comment.\n\n## Reference\n\n* [NFL Baseline - Simple Helmet Mapping](https:\/\/www.kaggle.com\/its7171\/nfl-baseline-simple-helmet-mapping) by [tito](https:\/\/www.kaggle.com\/its7171).  \n* [Helper Code + Helmet Mapping + Deepsort](https:\/\/www.kaggle.com\/robikscube\/helper-code-helmet-mapping-deepsort) by [\nRob Mulla](https:\/\/www.kaggle.com\/robikscube)","6593b00f":"## MAIN"}}