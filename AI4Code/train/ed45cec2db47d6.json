{"cell_type":{"8bcb5093":"code","df77a41b":"code","d84c16c5":"code","cda4af50":"code","9e64aa57":"code","2153ce78":"code","f7811218":"code","82df7471":"code","f2e637f2":"code","0f04168f":"code","de8d7caa":"code","269132c4":"code","de42d4f4":"code","3ff6cfab":"code","f271efcd":"markdown","27d662cc":"markdown","c2eb81d4":"markdown","d3cad463":"markdown","bdb307ec":"markdown","cb54e75a":"markdown","17d8b9bc":"markdown","fa3bb5a7":"markdown","de8f7096":"markdown","a08571fd":"markdown"},"source":{"8bcb5093":"import numpy as np\nimport torch\nfrom torch.utils.data import DataLoader, Dataset\nimport sys\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.utils import data\nfrom matplotlib import pyplot as plt\n","df77a41b":"device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')         \nprint(device)","d84c16c5":"train_data = np.genfromtxt('..\/input\/digit-recognizer\/train.csv', delimiter=',')\ntest_data = np.genfromtxt('..\/input\/digit-recognizer\/test.csv', delimiter=',')","cda4af50":"train_images = train_data[1:, 1:]\ntrain_labels = train_data[1:, 0]\n\ntest_images = test_data[1:]","9e64aa57":"class my_train_dataset():    \n\n    def __init__(self, train_images, train_labels):\n\n        super(my_train_dataset).__init__()\n        \n        self.X = train_images.reshape(-1,1,28,28)       \n        \n        self.X = torch.from_numpy(self.X).float()\n        self.Y = torch.from_numpy(train_labels).long()\n        \n            \n    def __getitem__(self,index):\n        \n        image = self.X[index]\n        label= self.Y[index]\n\n        return image, label\n        \n    def __len__(self):\n        return len(self.X)\n\n\n\nclass my_test_dataset():    \n\n    def __init__(self, test_images):\n\n        super(my_test_dataset).__init__()\n        \n        self.X = test_images.reshape(-1,1,28,28)       \n        \n        self.X = torch.from_numpy(self.X).float()\n        \n            \n    def __getitem__(self,index):\n        \n        image = self.X[index]\n\n        return image\n        \n    def __len__(self):\n        return len(self.X)","2153ce78":"#### Define CNN Model ####\n\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n      \n        self.conv1 = nn.Conv2d(1, 32, 3, padding = 1)\n        self.conv2 = nn.Conv2d(32, 64, 3, padding = 1)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv3 = nn.Conv2d(64, 128, 5, padding = 2)\n        self.hidden = nn.Linear(128,64)\n        self.output = nn.Linear(64, 10)\n        # self.dropout = nn.Dropout(0.3)\n\n        \n    def forward(self, x):\n\n        x = F.relu(self.conv1(x))\n        x = self.pool(F.relu(self.conv2(x)))       \n        x = F.relu(self.conv3(x)) \n        x = F.avg_pool2d(x, [x.size(2), x.size(3)], stride=1)\n        x = x.reshape(x.shape[0],x.shape[1])\n        x = self.hidden(x)\n        # x = self.dropout(x)\n        x = self.output(x)\n\n        return x","f7811218":"net = Net()\nnet.to(device)\nnet","82df7471":"Training_Loss = []\nTraining_Accuracy = []\n\ndef train(model, data_loader, epochs):\n    net.train()\n    for epoch in range(epochs):\n        avg_loss = 0.0\n        for batch_num, (feats, labels) in enumerate(data_loader):\n            feats, labels = feats.to(device), labels.to(device)\n            \n            outputs = model(feats)\n            loss = criterion(outputs, labels)\n            \n            optimizer.zero_grad()\n            \n            loss.backward()\n            optimizer.step()\n            \n            avg_loss += loss.item()\n\n            if batch_num % 50 == 49:\n                print('Epoch: {}\\tBatch: {}\\tAvg-Loss: {:.4f}'.format(epoch+1, batch_num+1, avg_loss\/50))\n                avg_loss = 0.0    \n            \n            torch.cuda.empty_cache()\n            del feats\n            del labels\n            del loss\n\n\n        train_loss, train_acc = test_classify(model, data_loader)\n        print('Train Loss: {:.4f}\\tTrain Accuracy: {:.4f}\\t'.\n              format(train_loss, train_acc))\n        Training_Loss.append(train_loss)\n        Training_Accuracy.append(train_acc)\n    \n    \n    \ndef test_classify(model, test_loader):\n    model.eval()\n    test_loss = []\n    accuracy = 0\n    total = 0\n\n    for batch_num, (feats, labels) in enumerate(test_loader):\n        feats, labels = feats.to(device), labels.to(device)\n        outputs = model(feats)\n\n        _, pred_labels = torch.max(F.softmax(outputs, dim=1), 1)\n        pred_labels = pred_labels.view(-1)\n\n        loss = criterion(outputs, labels.long())\n\n        accuracy += torch.sum(torch.eq(pred_labels, labels)).item()\n        total += len(labels)\n        test_loss.extend([loss.item()]*feats.size()[0])\n        del feats\n        del labels\n\n    model.train()\n    return np.mean(test_loss), accuracy\/total","f2e637f2":"#Training Batch size\nBatch_size = 256\n\n# Loss Function\ncriterion = nn.CrossEntropyLoss()\n\n# Optimizer\noptimizer = torch.optim.Adam(net.parameters(),lr=0.001)\n\n# Epochs\nnum_Epochs = 25","0f04168f":"##### Train Dataloader #### \ntrain_dataset = my_train_dataset(train_images,train_labels)          \ntrain_dataloader = data.DataLoader(train_dataset, shuffle= True, batch_size = Batch_size, num_workers=4,pin_memory=True)\n\n\n#### Test Dataloader ####\ntest_dataset = my_test_dataset(test_images)\ntest_dataloader = data.DataLoader(test_dataset, shuffle=False, batch_size=1, num_workers=0, pin_memory=True)","de8d7caa":"train(net, train_dataloader, epochs = num_Epochs)","269132c4":"import csv\n\ndef predict(model, test_loader):\n    \n    model.eval()\n    total = 0\n    index= 1\n    with open('output.csv',mode='w') as output_file:\n      \n        f=csv.writer(output_file,delimiter=',')\n        f.writerow(['ImageId','Label'])\n\n\n        for batch_num, (feats) in enumerate(test_loader):\n            feats = feats.to(device)\n            outputs = model(feats)\n\n            _, pred_labels = torch.max(F.softmax(outputs, dim=1), 1)\n            pred_labels = pred_labels.view(-1)\n\n            f.writerow([str(index), int(pred_labels)])\n            index+=1\n","de42d4f4":"predict(net, test_dataloader)","3ff6cfab":"plt.figure(figsize=(10,10))\nx = np.arange(1,26)\nplt.plot(x, Training_Loss, label = 'Training Loss')\nplt.xlabel('Epochs', fontsize =16)\nplt.ylabel('Loss', fontsize =16)\nplt.title('Loss v\/s Epochs',fontsize =16)\nplt.legend(fontsize=16)\n\nplt.figure(figsize=(10,10))\nplt.plot(x, Training_Accuracy, label = 'Training Accuracy')\nplt.xlabel('Epochs', fontsize =16)\nplt.ylabel('Accuracy', fontsize =16)\nplt.title('Accuracy v\/s Epochs',fontsize =16)\nplt.legend(fontsize=16)\n\n","f271efcd":"# **Training Method**","27d662cc":"# Loss and Accuracy plots","c2eb81d4":"**Import necessary modules**","d3cad463":"**Predict and write outputs to CSV**","bdb307ec":"# **Hyperparameters**","cb54e75a":"# **Dataloading Scheme**","17d8b9bc":"# **Model Architecture**","fa3bb5a7":"**Train the model**","de8f7096":"**Dataloaders**","a08571fd":"*Writing Pytorch custom dataloader using Dataset class and __getitem__ method*"}}