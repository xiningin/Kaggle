{"cell_type":{"642dab05":"code","cc4c636c":"code","66e65bc4":"code","56163b04":"code","3d336034":"code","b45b064f":"code","1205cceb":"code","df7e444c":"code","59054ad7":"code","1b1ccd01":"code","00b5f7d2":"code","6fb87a02":"code","f920e741":"code","78128630":"code","002dffd4":"code","04bfd88e":"code","fa900d23":"code","4269282e":"code","05e272ff":"markdown"},"source":{"642dab05":"#need to uninstall fastai1\n!pip uninstall fastai -y\n\n#Need to add fast-v2-offline dataset to your input before install\n!pip install -q \/kaggle\/input\/fast-v2-offline\/dataclasses-0.6-py3-none-any.whl\n!pip install -q \/kaggle\/input\/fast-v2-offline\/torch-1.6.0-cp37-cp37m-manylinux1_x86_64.whl\n!pip install -q \/kaggle\/input\/fast-v2-offline\/torchvision-0.7.0-cp37-cp37m-manylinux1_x86_64.whl\n!pip install -q \/kaggle\/input\/fast-v2-offline\/fastcore-1.0.1-py3-none-any.whl\n!pip install -q \/kaggle\/input\/fast-v2-offline\/fastai-2.0.8-py3-none-any.whl","cc4c636c":"from fastai.tabular.all import *","66e65bc4":"import sys\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import log_loss\nfrom tqdm.notebook import tqdm\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset, DataLoader\n\nimport warnings\nwarnings.filterwarnings('ignore')","56163b04":"import sys\nsys.path.append('..\/input\/iterative-stratification\/iterative-stratification-master')\n\nfrom iterstrat.ml_stratifiers import MultilabelStratifiedKFold\nimport pandas as pd\nfrom sklearn.model_selection._split import _BaseKFold","3d336034":"train_features = pd.read_csv('..\/input\/lish-moa\/train_features.csv').set_index('sig_id')\ntrain_targets = pd.read_csv('..\/input\/lish-moa\/train_targets_scored.csv').set_index('sig_id')\ntest_features = pd.read_csv('..\/input\/lish-moa\/test_features.csv').set_index('sig_id')\ndrug = pd.read_csv('..\/input\/lish-moa\/train_drug.csv').set_index('sig_id')\n","b45b064f":"ss = pd.read_csv('..\/input\/lish-moa\/sample_submission.csv').set_index('sig_id')","1205cceb":"train = train_features.merge(drug, left_index=True, right_index=True)","df7e444c":"def preprocess(df):\n    df = df.copy()\n    df.loc[:, 'cp_time'] = df.loc[:, 'cp_time'].map({24:0, 48:0.5, 72:1})\n    df.loc[:, 'cp_dose'] = df.loc[:, 'cp_dose'].map({'D1': 0, 'D2': 1})\n    return df","59054ad7":"train = preprocess(train)\ntest = preprocess(test_features)","1b1ccd01":"targets=train_targets.loc[train.cp_type == 'trt_cp']\ntrain = train.loc[train.cp_type == 'trt_cp']","00b5f7d2":"cont_names = list(train.columns[1:-1])\ny_names = list(targets.columns)","6fb87a02":"#need to merge train and targets to a single dataframe\ntrain2 = train.merge(targets, left_index=True, right_index=True)","f920e741":"nepochs = 50\nbatch_size = 128\nval_batch_size = batch_size * 4\ncriterion = nn.BCELoss()","78128630":"class DrugAwareMultilabelStratifiedKFold(_BaseKFold):\n\n    SAMPLES_PER_EXPERIMENT = 6\n\n    def __init__(self,\n                 max_experiment_cnt=3,\n                 n_splits=3,\n                 shuffle=False,\n                 random_state=None):\n        super().__init__(n_splits=n_splits, \n                         shuffle=shuffle, \n                         random_state=random_state)\n        self._skf = MultilabelStratifiedKFold(n_splits=n_splits, \n                                              shuffle=shuffle, \n                                              random_state=random_state)\n        self.drug_threshold = self.SAMPLES_PER_EXPERIMENT * max_experiment_cnt\n\n    def _iter_test_indices(self, X=None, y=None, groups=None):\n        drug_set = X.merge(y, left_index=True, right_index=True)\n        targets = y.columns\n        vc = X['drug_id'].value_counts()\n        vc1 = vc.loc[vc <= self.drug_threshold].index.sort_values()\n        vc2 = vc.loc[vc > self.drug_threshold].index.sort_values()\n\n        drug_id_to_fold = {}\n        sig_id_to_fold = {}\n        if len(vc1) > 0:\n            tmp = drug_set.groupby('drug_id')[targets].mean().loc[vc1]\n            for fold, (_, idx_val) in enumerate(self._skf.split(tmp, tmp[targets])):\n                drug_id_to_fold.update({k: fold for k in tmp.index[idx_val].values})\n\n        if len(vc2) > 0:\n            tmp = drug_set.loc[drug_set.drug_id.isin(vc2)].reset_index()\n            for fold, (_, idx_val) in enumerate(self._skf.split(tmp, tmp[targets])):\n                sig_id_to_fold.update({k: fold for k in tmp.sig_id[idx_val].values})\n\n        drug_set['fold'] = drug_set.drug_id.map(drug_id_to_fold)\n        unset_folds = drug_set.fold.isna()\n        drug_set.loc[unset_folds, 'fold'] = drug_set.loc[unset_folds].index.map(sig_id_to_fold)\n        test_folds = drug_set.fold.astype('int8').values\n\n        for i in range(self.n_splits):\n            yield test_folds == i","002dffd4":"class MoaModel(nn.Module):\n    def __init__(self, num_columns):\n        super(MoaModel, self).__init__()\n        self.batch_norm1 = nn.BatchNorm1d(num_columns)\n        self.dropout1 = nn.Dropout(0.35016565859755877)\n        self.dense1 = nn.utils.weight_norm(nn.Linear(num_columns, 221))\n        \n        self.batch_norm2 = nn.BatchNorm1d(221)\n        self.dropout2 = nn.Dropout(0.3831830207882558)\n        self.dense2 = nn.utils.weight_norm(nn.Linear(221, 775))\n        \n        self.batch_norm3 = nn.BatchNorm1d(775)\n        self.dropout3 = nn.Dropout(0.37312149555800084)\n        self.dense3 = nn.utils.weight_norm(nn.Linear(775, 206))\n    \n    def forward(self, cat, x):\n        x = self.batch_norm1(x)\n        x = self.dropout1(x)\n        x = Mish()(self.dense1(x))\n        \n        x = self.batch_norm2(x)\n        x = self.dropout2(x)\n        x = Mish()(self.dense2(x))\n        \n        x = self.batch_norm3(x)\n        x = self.dropout3(x)\n        x = F.sigmoid(self.dense3(x))\n        \n        return x","04bfd88e":"def set_seed(seed):\n    torch.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n    np.random.seed(seed)","fa900d23":"nstarts=1 #starts from 1\nall_preds = []\nfor seed in range(nstarts):\n  seed_preds = []\n  print(f'Train seed {seed}')\n  set_seed(seed) \n  \n  splitter = DrugAwareMultilabelStratifiedKFold(n_splits=5, shuffle=True, random_state=seed)\n  for n, (tr, te) in enumerate(splitter.split(X=train, y=targets)): #train and targets data should not be overlapped\n      print(f'Train fold {n+1}')\n      splits = (L(list(tr)), L(list(te)))\n    # train2 must be a combination of train and targets dataframe\n    # cont_names and y_names must be in list form\n      to = TabularPandas(train2,[Normalize, FillMissing], cat_names = [],cont_names=cont_names, y_names=y_names, splits=splits)\n      trn_dl = TabDataLoader(to.train, bs=512, shuffle=True, drop_last=True)\n      val_dl = TabDataLoader(to.valid, bs=512*4)\n      dls = TabularDataLoaders(trn_dl, val_dl).cuda()\n      model = MoaModel(874).cuda()\n      learn = Learner(dls, model, loss_func=BCELossFlat(), opt_func=ranger)\n      learn.fit_flat_cos(20, 0.039745218935223835, cbs=[EarlyStoppingCallback(), ReduceLROnPlateau()])\n      dl = learn.dls.test_dl(test.copy()) #test df must has the same form as the train df, so put cp_dose\/time to number\n      seed_preds.append(learn.get_preds(dl=dl)[0].cpu().numpy())\n  all_preds.append(np.mean(seed_preds, axis=0))\npreds = np.mean(all_preds, axis=0)","4269282e":"ss[y_names] = preds\nss.loc[test.cp_type =='ctl_vehicle', y_names] = 0\nss = ss.reset_index()\nss.to_csv('submission.csv', index =False)","05e272ff":"This notebook is based on https:\/\/www.kaggle.com\/muellerzr\/fastai-tabular @Zach Mueller and https:\/\/www.kaggle.com\/ppicheta\/lish-moa-drug-aware-multilabelstratifiedkfold @Piotr Picheta"}}